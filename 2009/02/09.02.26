00:02:40 <stanv_> thanks!!!
00:02:59 <aleator> Anyone know what needs to go wrong in order to get following error: http://haskell.pastebin.com/d196927cc 64 bittyness I guess, but..
00:03:04 <stanv_> big thanks! Gracenotes thoughtpolice BMeph
00:03:36 <stanv_> OldException works fine
00:19:57 <michaelcdever> hey can anyone tell me if there are any performance effects to chaining i.e >>= , positive or negative?
00:24:38 <Axman6> michaelcdever: there can be positive ones, like chaining maybe's with them can give you quick failure
00:24:52 <Axman6> if you get a Nothing, the whole chain fails right away
00:24:58 <Axman6> same with []
00:25:54 <sjanssen> michaelcdever: as opposed to what?
00:27:08 <ivanm> matthew-_: have you reviewed my graphviz changes?
00:29:08 <michaelcdever> as opposed to writing it out normally, just wondering why its done if theres no real benefit to it
00:29:21 <michaelcdever> bar readability of course
00:30:03 <kaol> define "normally"
00:30:18 <sjanssen> I don't follow you, how else does one write "f >>= g >>= h"?
00:31:19 <michaelcdever> blah <- f
00:31:28 <michaelcdever> blah2 <- g blah
00:31:39 <michaelcdever> blah3 <- h blah2
00:31:41 <sjanssen> oh, do notation *is* >>=
00:32:05 <zeno___> just syntactic sugar
00:32:06 <sjanssen> @undo do blah <-f; blah2 <- g blah; h blah2
00:32:06 <lambdabot> f >>= \ blah -> g blah >>= \ blah2 -> h blah2
00:32:14 <sjanssen> @. pl undo do blah <-f; blah2 <- g blah; h blah2
00:32:14 <lambdabot> h =<< g =<< f
00:41:00 <michaelcdever> can anyone point out to me whats wrong with this? it must be my only-awake brain but i can't see it
00:41:06 <michaelcdever> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1782
00:43:56 <andun> michaelcdever: is that & supposed to be a $?
00:44:57 <dmwit> michaelcdever: I see your problem.  You're trying to do too much in one function.
00:47:25 <michaelcdever> yep its meant to be $
00:51:36 <michaelcdever> it worked before when i had it in another function
00:51:54 <michaelcdever> it worked before when i had it in another function
00:54:18 <gio123> @seen  faxathisia
00:54:18 <lambdabot> I haven't seen faxathisia.
01:02:01 <zeno___> michaelcdever: whatever <- somestuff;return somestuff is the same as just somestuff
01:02:11 <zeno___> sorry resturn whatever
01:04:20 <zeno___> case fileE of... could be simplified to pixbufNewFromFile =<< iconpath (IconDetails (if` fileE "Folder" "File"))
01:14:04 <mopped> say I have (silly example) f x = (fst $ divMod x 7, 100, snd $ divMod x 7), is divMod calculated twice and it would be better to have say let h = divMod x 7, or does hte compiler compute it once and juts fetch values twice?
01:16:56 <porges> if you want sharing it's better to do it explicitly
01:17:18 <porges> that way you *know* it will happen :)
01:20:01 <mopped> aha ok
01:40:13 <fasta> What's the use of the methods of the Error class? I changed the example below Control.Monad.Error s.t. the definitions are all undefined and then all the examples still run. If I remove the instance, it doesn't work however, but it seems kind of pointless.
01:40:48 <wli> There are random things you can trip over that throw the predefined errors.
01:41:09 <wli> I think the fail method of the Monad class or some such.
01:43:29 <wli> > runErrorT (fail "msg" :: ErrorT String Maybe ())
01:43:30 <lambdabot>   Just (Left "msg")
01:43:46 <wli> fasta: Witness the above.
01:43:49 <fasta> wli:  [] <- return [1]
01:43:56 <fasta> wli: I probably did the same.
01:44:53 <niet> can I patternmatch on a function? like generateKey ((coPrime x y) == True) =
01:45:46 <doserj> generateKey x y | coPrime x y = ...
01:45:48 <LeoD> try guards? generateKey x y | coPrime x y =
01:45:53 <wli> You generally do something like generateKey x y | coPrime x y = ...
01:45:57 <porges> lol
01:46:06 <fasta> 3.1 stereo
01:46:24 <wli> Or if x and y are inherited from an enclosing scope, generateKey | coPrime x y = ...
01:47:39 <wli> I almost always end up turning on PatternGuards and PatternSignatures
01:48:23 <wli> PatternSignatures is actually to eliminate ambiguous types in list comprehensions.
01:48:44 * wli doesn't quite yet have a good way to deal with the ambiguous types in exponents.
01:49:20 <fasta> wli:  PatternSignatures?
01:49:51 <fasta> And exponents? ;)
01:49:52 <wli> Yeah. Like fib (n :: Integer) = fib (n - 1) + fib (n - 2)
01:50:14 <fasta> Why don't you just leave everything abstract?
01:50:14 <wli> With -Wall x^2 gives you defaulting warnings.
01:50:45 <wli> The real use for PatternSignatures is when you do things like [(n, f n) | n :: Integer <- [0..]]
01:51:39 <fasta> What's wrong with fib :: (Num a, Num a1) => a -> a1?
01:51:47 * wli mostly uses them in list comprehensions, though occasionally in PatternGuard affairs like Just (n :: Integer) <- ...
01:52:22 <dmwit> What's wrong with [(n, f n) | n <- [0 :: Integer ..]]?
01:52:37 <wli> fasta: I only do that at the top level. In nested scopes I want to fiddle with types in other ways.
01:52:40 <dmwit> Or n <- [0..] :: [Integer], if you have an expression there.
01:52:58 <fasta> I try to remove type annotations as much as possible, and only introduce them when I cannot figure out why it doesn't compile anymore.
01:53:05 <wli> dmwit: Not much, I just find the PatternSignatures version more aesthetically pleasing.
01:53:30 <porges> compilation is only of secondary importance
01:54:27 * wli nails down types with explicit type signatures at the top level every type and eschewing defaulting with -Wall -Werror
02:02:35 <niet> should a RSA key generation function be instant? then mine sucks...
02:02:46 <niet> (dont knw if it is correct either :P )
02:04:46 <Ferdirand> which primality test do you use ?
02:05:17 <wli> I usually use trial division.
02:05:45 <Ferdirand> :)
02:07:06 <Workybob> > let f = (,); a = 1; b = 2; c = f a; d = c b in case d of ((,) x y) -> x
02:07:08 <lambdabot>   1
02:07:59 <wli> In a pinch I might do Pollard's rho or something.
02:09:49 <whpearson> Has anyone implemented traces, in a trace monoid sense in haskell? -> http://en.wikipedia.org/wiki/Trace_monoid
02:13:03 <wli> There's a version of Pollard's rho that just stops when you find a factor to use as a primality test.
02:20:37 <dmwit> whpearson: I don't know of any implementation, but it sounds useful.
02:22:15 <whpearson> It shouldn't be too hard (to at least do a skeleton), so I might make it my first hackage release.
02:23:20 <niet> what si trial division? test every case? i do divide up until the square root
02:26:02 <dmwit> niet: Yes, exactly.  Divide up to the square root.
02:26:42 <dmwit> There are faster methods, but that one is very easy to code up. =)
02:26:53 <Ferdirand> you can use trial division to weed out small factors, then use a more complex test on the remains
02:27:49 <Ferdirand> *candidates with small factors*
02:29:01 <fasta> whpearson: if one can implement it more efficiently than with the writer monad, then it is sounds useful.
02:29:41 <fasta> s/is//
02:33:31 <whpearson> fasta:  The main thing that needs implementing is a function to tell if two strings are equal in a trace sense. E.g. If (a,b) and (b,a) is independent then "abbb" is traceEq to "bbba"
02:34:59 <whpearson> I'm not sure how I would get the writer monad to do that.
02:35:07 <fasta> whpearson: yes, but this is only useful if you do it at a very low level of the system (I mean it is basically a wider synchronization criterion).
02:36:13 <whpearson> fasta: I'm interested in reverse engineering/debugging things, so yup I'm interested in the low level.
02:37:21 <fasta> whpearson: so, then forget about the Writer monad and just make the simplest thing that might possible work. If it is useful people will drool over it and adapt it to the rest of the system :)
02:37:34 <fasta> possibly*
02:40:02 <fasta> whpearson: also, it seems your approach would only work if you had a really big machine, or are you intending to do something smart?
02:40:28 <whpearson> fasta: Be more specific with approach...
02:41:38 <fasta> whpearson: never mind
02:42:35 --- mode: irc.freenode.net set +o ChanServ
02:43:00 <whpearson> They are really having issues with chanserv aren't they.
02:43:36 <Botje> probably not written in haskell, that one :)
02:45:03 <whpearson> @faq Can haskell make chanserv more stable?
02:45:03 <lambdabot> The answer is: Yes! Haskell can do that.
02:45:32 <Workybob> not based on lambdabot's performance it can't :P
02:49:57 <ivanm> why does the haskell reddit have a narwhal for its logo now?
02:51:12 <Workybob> because someone decided they liked that one on the page of Haskell logos
02:51:19 <Workybob> I'm not keen personally
02:52:04 <ivanm> I know they were talking about having a vote for a new logo, but I only ever saw discussions about what to vote for and how to set up the voting, not an announcement of the vote itself :s
02:52:18 <Workybob> no
02:52:23 <Workybob> it seems to be... rather slow progress
02:52:27 <ivanm> heh
02:52:37 <ivanm> I suppose that's one way of stating it ;-)
02:52:49 * Workybob thinks we should use this... http://www.haskell.org/haskellwiki/Image:UnsafeHaskell.png
02:53:37 * ivanm thinks we should use this: http://www.haskell.org/haskellwiki_logo_small.png
02:53:38 <ivanm> :p
02:53:45 <Workybob> haha
02:53:50 <Workybob> I really hate that logo actually
02:54:08 <dmwit> What ever happened to the logo competition?
02:54:19 <Workybob> it says absolutely nothing about the language other than "you're gonna need an APL keyboard" -- which is a lie
02:54:21 <dmwit> Did it just fizzle out in the judging phase because there were no rules set up ahead of time?
02:54:29 <Workybob> I think so, yes
02:54:42 <Workybob> there have been various suggestions for ways to vote, and... nothing more
02:54:47 <ivanm> dmwit: there was going to be a vote, but no-one could agree on how to vote
02:54:53 <dmwit> right
02:55:24 <dmwit> I was worried that might happen when the voting system wasn't published before the competition began.
02:55:29 <dmwit> Sometimes I hate being right. =/
02:55:52 <ivanm> dmwit: you hate it when your pessimism is right?
02:55:53 <ivanm> ;-)
02:55:56 <dmwit> There were some really good submissions -- one of them deserves to be used!
02:56:02 <dmwit> ivanm: exact. =)
02:57:07 <nanothief> well they needed a vote on deciding how to vote then!
02:59:06 <Workybob> I vote that we have a vote for deciding if we need to vote to decide how we should vote for a vote
03:00:10 <yitz> Auction off the right to pick the logo to the highest bidder, and pay the money to the designer of the winning logo
03:00:27 <Workybob> haha
03:00:39 <Workybob> there's a problem with that
03:00:44 <Workybob> you can bid infinity
03:00:54 <Workybob> because then you chose your own logo and gain your infinity back
03:01:11 <yitz> Workybob: infinite computations are allowed in Haskell.
03:01:21 <Workybob> yeh, but trying to compare them is not such a good idea
03:01:25 <Workybob> :P
03:01:29 <yitz> Workybob: but obviously you can't pick your own design
03:01:44 <Workybob> but that only encourages people to not bid
03:01:57 <Workybob> (after all, they want someone else to win and pick their design for them)
03:02:10 <yitz> Workybob: if no one bids, we fall back to the original plan
03:02:22 <Workybob> of voting to vote about a vote?
03:02:27 <yitz> or something
03:02:50 <yitz> of procrastinating ad infinitum about how to vote
03:02:55 <Workybob> hehe
03:04:51 <pejo> Infinite computations are allowed in most languages, nothing unique there to Haskell.
03:07:06 <mperillo> hi
03:07:30 <blackh> mperillo: Hello!
03:07:45 <mperillo> I'm planning to build a new PC, and I'm wondering what CPU do build (to do some test with Haskell parallel support)
03:08:24 <mperillo> s/CPU do build/CPU to buy/
03:09:08 <mperillo> the new Intel Core i7, seems interesting; is the new HyperThreading effective with GHC?
03:09:18 <pejo> mperillo, basically any intel or AMD CPU are dual core or more by now, aren't they?
03:09:32 <mperillo> pejo, right
03:10:06 <mperillo> but Intel Core 2 Quad has plain 4 core; Intel Core i7 has 4 core + HyperThreading -> 8 effective cores
03:10:48 <flux> I don't think it's fair characterisation to say HT gives extra cores
03:11:01 <flux> hardware threads would be more appropriate
03:11:18 <mperillo> flux, right
03:11:26 <flux> well, not unless they give close to 200% performance compared to unicore :)
03:11:57 <pejo> It depends on your workload really, but I haven't seen anyone commenting on typical "workloads" from haskell programs.
03:12:41 <pejo> flux, for some standard SAP benchmark the new i7 server CPU's actually gave close to 200%.
03:13:23 <flux> pejo, and for other benchmarks they give <100% performance due to memory bus saturation?
03:13:45 <flux> (no, I don't know if they do, but they have in the past :))
03:14:10 <pejo> flux, yes, the "old" HT was horrible in practice. The "new" HT is supposed to be much better.
03:14:21 <mperillo> pejo, the workload is variable; it will be used as a normal PC (no games) but I want to invest some money and buy a better hardware, since some time I may need to run some Haskell program that needs to process large data sets
03:15:26 <raxas> since my last month experiments with atom 330, 2 cores+HT pretending 4 cores, I consider hyperthreading to be no more than scam
03:17:50 <niet> how can I force an execution?
03:18:08 <niet> like, let a = main ; main returns a tuple. i want to to force it
03:18:17 <niet> so a is instant later
03:18:29 <cnwdup> niet, seq
03:18:41 <aleator> Anyone know what needs to go wrong in order to get following error: http://haskell.pastebin.com/d196927cc ?
03:18:48 <cnwdup> x `seq` f x evaluates x even it isn't necessary at the time.
03:20:06 <cnwdup> aleator, although you shouldn't be able to use it in let with the expected result.
03:20:17 <cnwdup> aleator, sorry. That was for niet.
03:20:42 <cnwdup> niet, got my message?
03:21:12 <niet> no
03:21:54 <cnwdup> niet, you can use seq for that. x `seq` f x evaluates x even if it isn't necessary at the time. Something like main `seq` let a = main in doSomething main shoudl work.
03:22:32 <cnwdup> *doSomething a
03:22:48 <pejo> mperillo, I can't comment much on the expected haskell performance, but i7 appears to be very fast (and somewhat pricey), so if you can afford it it's probably a good choice.
03:25:12 <mperillo> pejo, the 920 model seems to be affordable
03:25:35 <mperillo> and I have no problem at waiting 6 months to buy a new PC
03:26:07 <fasta> mperillo: waiting is pointless, since new generations are not _that_ much faster anymore.
03:26:43 <fasta> mperillo: and if you are interested in the parallel stuff, you should simply buy a T2 :)
03:27:36 <zachk> t2?
03:27:58 <fasta> www.sun.com/processors/UltraSPARC-T2/
03:28:24 <mperillo> fasta, the T2 can handle 8 concurrent threads, the same as Intel Core i7
03:28:56 <mperillo> ah, my bad... 8 concorrents threads per core
03:29:03 <fasta> mperillo: I thought the T2 did something smart with hiding memory latencies too.
03:29:08 <zachk> does n body gravitation go nicely over multiple cores?
03:29:49 <blackh> zachk: Aha - a question I know the answer to! The answer is no - it
03:29:51 <blackh> 's terrible
03:30:02 <mperillo> fasta, what price it has?
03:30:38 <fasta> mperillo: I don't know, but probably the "if you have to ask, it's to expensive kind".
03:30:41 <fasta> too*
03:31:00 <kinte> who isfasta
03:31:13 <niet> can only 2 args-functions be `f`-ed?
03:31:57 <mperillo> fasta, the price is about $1000
03:32:00 <blackh> niet: Yes.
03:32:04 <mperillo> affordable
03:32:12 <niet> let add x y z = x+y+z in 1 `add` 2 `add` 3
03:32:13 <niet> > let add x y z = x+y+z in 1 `add` 2 `add` 3
03:32:13 <niet> lambdabot ?
03:32:14 <lambdabot>       Overlapping instances for Show ((t -> t) -> t -> t)
03:32:14 <lambdabot>        arising from...
03:32:24 <mperillo> but GHC port to T2 is not yet mature
03:32:32 <pejo> mperillo, the T2 is probably not suited for your typical workload, I don't think it does much of instruction reordering etc.
03:32:52 <fasta> mperillo: that cannot take much time anymore, since it was supposed to take 3 months.
03:33:50 <pejo> fasta, the ghcsparc blog (?) has some nice graphs and such, but my impression is that baseline performance is ..slow.
03:34:21 <kinte> dfd
03:35:49 <fasta> pejo: I don't know the exact numbers, but single threaded performance indeed is slow. Multi-threaded should be faster than anything what Intel has currently.
03:37:31 <pejo> fasta, yes, but suppose he wants to run Mozilla as well. :-)
03:39:34 <mperillo> pejo, yes may run Mozilla, but I'm not interested in performance; I have another PC for that
03:41:21 <mperillo> but I guess I will go with an Intel CPU :)
04:05:49 <StefanK> hello, why does an CVar consist of 2 MVars? Why does one MVar not suffice? thanks...
04:08:50 <mperillo> how efficient is snocU in uvector package?
04:11:52 <pernod> Hi
04:12:04 <pernod> I have a newbie style question.
04:12:16 <pernod> Where can I post code to get feedback please?
04:12:34 <pernod> (If someone has time, of course)
04:12:44 <dormoose> hpaste.org, last I checked
04:12:51 <dormoose> Or, basically, any online pastebin.
04:13:01 * ivanm points to the topic
04:13:10 <pernod> Thank you.
04:13:56 <StefanK> can anyone explain how CVars work in contrast to an MVar please?
04:14:47 <pernod> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1783#a1783
04:15:17 <ivanm> pernod: why so many doubles? :o
04:15:24 <pernod> Good question.
04:15:29 <pernod> I'm a n00b.
04:15:35 <pernod> Any advise welcome :)
04:16:01 <ivanm> pernod: what is the difference between the two?
04:16:11 <pernod> This is just an extract
04:16:26 <ivanm> do they represent different things? are all those doubles different for the two types?
04:16:29 <pernod> The code is an implementation of the Black Scholes formulas for option pricing.
04:16:43 <pernod> No, the doubles will be the same.
04:16:53 <ivanm> yes, but IIRC aren't most items there the "same" (i.e. time based)?
04:16:57 <pernod> Put the behaviour will be different depending on type.
04:17:01 <cmcq> data OptionType = Call | Put, then data Option = Option OptionType Double Double ...
04:17:19 <ivanm> pernod: ^^ I was trying to lead you towards something like what cmcq has
04:17:34 <pernod> Ok.
04:17:38 <ivanm> though even then, I'd just have the function take those doubles in, rather than having it as part of the data structure (depending on usage)
04:17:46 <ivanm> maybe use record format? *shrug*
04:17:56 <pernod> I tried that, but it was as ugly :)
04:18:17 <pernod> I come from an OO background, so I suspect I tend to think too much in objects.
04:18:27 <ivanm> I'd say so ;-)
04:19:14 <pernod> So cmcq's suggestion will allow me to factor out the repetiotion?
04:19:23 <ivanm> pernod: yes
04:19:36 <pernod> I shall give it a go then. Thank you very much for your help.
04:19:40 <pernod> ivanm++
04:19:44 <ivanm> though I probably wouldn't have the Option data type
04:19:47 <ivanm> pernod: if a data type isn't directly related to a Get or a Put, then it shouldn't be part of the data structure
04:20:06 <ivanm> (by "directly related", I mean that it isn't specific to that get or put but is more general)
04:20:09 <ivanm> pernod: :D
04:20:12 <ivanm> @karma
04:20:12 <lambdabot> You have a karma of 2
04:20:28 <pernod> (I googled freenode haskell before I came here ;))
04:20:33 <ivanm> heh
04:20:34 <shapr> pernod: Good choice!
04:20:46 <ivanm> shapr: to come here?
04:20:52 <dormoose> yes.
04:21:00 <dormoose> The most fun and helpful bunch I've seen yet.
04:21:08 <pernod> I'm not sure I understand the "directly related"
04:21:11 <ivanm> after all, you probably wouldn't want to go to that _other_ #haskell channel... :p
04:21:12 <shapr> ivanm: Yes!
04:21:20 <ivanm> pernod: OK... what do those different doubles represent?
04:21:34 <pernod> Strike price, price of underlying etc.
04:21:34 <shapr> ivanm: I think there have been two other #haskell channels.
04:21:36 <ivanm> are they independent of a particular get/put call?
04:21:42 <ivanm> shapr: :o
04:21:46 <ivanm> but yours won? :p
04:21:51 <pernod> Yes
04:21:59 <shapr> ivanm: Well, this one ended up being most popular, yes.
04:22:04 <ivanm> pernod: then they're not "directly related" to the get/put call
04:22:12 <niet> does maain have to be main = do ...; or is a pure function main enough?
04:22:13 <niet> or if it is pure the pogram is alays useless? :P
04:22:22 <ivanm> niet: as long as the type is IO ()
04:22:37 <ivanm> a fully pure program is useless, due to laziness
04:22:47 <ivanm> i.e. it will never evaluate or do anything
04:22:53 <dormoose> niet: You can do main = putStrLn "foo"
04:23:00 <pernod> By independent, you mean that I create a pile of options (either puts or calls), and they will all have different doubles in them?
04:23:17 <ivanm> niet: note that the do notation is syntactic sugar for monadic notation, so if you don't like do ... you can use >> and >>= directly
04:23:33 <temoto> Is there standard function to find all divisors?
04:23:40 <vincenz> byorgey: ping
04:23:50 <ivanm> pernod: I mean that the values in the doubles are the same if its a Get or a Put
04:24:31 <pernod> They can be, yes, but they don't have to.
04:24:48 <temoto> Is there standard function to find integer divisors of Int?
04:24:53 <ivanm> pernod: for example (this isn't very realistic), say that we wan't to consider whether to buy or sell shares, and that the purchase price == sale price... in that case, you wouldn't include the price as part to the Buy | Sell data structure
04:25:18 <ivanm> pernod: but if the meanings are different, then by all means keep them together
04:25:49 <ivanm> if the meaning is different (or has a different value or something maybe) depending on whether it's a Get or a Put, then it should be with that constructor
04:26:01 <ivanm> temoto: I don't think so...
04:26:12 <niet> is it not possible to have 2 exes in the same dir?
04:26:14 <zachk> pernod: define a third function that has the body of both functions in it. then just "alias" d1 to each one
04:26:16 <ivanm> @hoogle (Integral a) => a -> [a]
04:26:17 <lambdabot> Prelude repeat :: a -> [a]
04:26:17 <lambdabot> Data.List repeat :: a -> [a]
04:26:17 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
04:26:23 <ivanm> niet: it is... have them in different files
04:26:24 <zachk> that will take care of your repetition
04:26:29 <pernod> Well. The data will be the same, but the functions that act upon that data will be different depending on the type of option.
04:26:56 <pernod> I guess my terminology differs from yours.
04:26:58 <ivanm> pernod: in that case, having that many constructors might make sense
04:27:08 <zachk> pernod: if they are going to be different why are they the same ? :D
04:27:26 <ivanm> or else you can have a function on the Get | Put data structure that returns another function
04:27:32 <andun> i have a program that needs to use different internal representations (with a similar interface but different constructors) of some data based on an input parameter. is there a general way to do this?
04:27:56 <pernod> zachk: I come here for programming advice and you get all existential on me :D
04:28:02 <ivanm> pernod: if you choose to keep those doubles with the Get and Put constructors, then you might want to consider record syntax, as you might find it cleaner than direct pattern matching all the time
04:28:18 <ivanm> andun: care to give us more info?
04:28:19 <pernod> Yeah, I attempted record syntax before I came here.
04:28:40 <pernod> But it didn't really make things clearer to me, so I thought there would be A Better Way.
04:28:44 <andun> i'll try to construct an example...
04:28:45 <ivanm> pernod: if you gave us more code, we could possibly give you a better help
04:29:15 <ivanm> pernod: the main advantage of record syntax is that if you only want one of those multiple Double values, you don't have to go foo (Get _ _ _ x _ _ ) ...
04:29:34 <ivanm> and by naming the fields, it helps stop you from mixing the positions up
04:29:46 <ivanm> pernod: also, having type aliases for all of them could help as well
04:29:49 <pernod> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1784#a1784
04:29:54 <ivanm> (to remember which is which)
04:30:15 <pernod> That should be working code.
04:30:29 <cmcq> except for the first line
04:30:41 <ivanm> pernod: first of all, you shouldn't re-create the data structure all the time
04:30:43 <zachk> pernod: there is nothing wrong with the way you are doing it. if you hate the repetition break off the repetivenes to another function: you could also just use a record syntax(i know its not as pretty) and through an option "flag" into your record then use a ifthen or a case statement to pick the function. but that is how i do stuff because i am still a newb :-D
04:30:44 * ivanm annotates
04:30:46 <pernod> Indeed, because I just pasted that in from you :)
04:31:16 <pernod> I was trying to avoid the ifthen, actually.
04:31:47 <pernod> I wanted to try to use polymorphism to solve this, because I like Teh Arcane.
04:31:56 <ivanm> pernod: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1784#a1785
04:31:56 <zachk> i like if thens
04:32:08 <ivanm> that makes it slightly cleaner already
04:32:47 <pernod> What's this x@ notation?
04:33:00 <zachk> yeah what does that do?
04:33:17 <Japsu> named patterns
04:33:20 <pernod> I like that.
04:33:25 <pernod> A bit OO, in a way :D
04:33:36 <Japsu> > let f x@(a, b) = (x, a) in f (2, 3)
04:33:38 <lambdabot>   ((2,3),2)
04:33:48 <andun> ivanm: i think i figured out how to do it in my simple example :-p
04:33:54 <ivanm> andun: heh
04:33:58 <Japsu> so in my example, x is a shorthand for (a, b)
04:34:09 <zachk> oh sweet
04:34:16 <niet> how can I compile to a linux-exe when Im on windows?
04:34:30 <zachk> ssh to the linux box
04:34:31 <Japsu> niet, you need a cross-compiler toolchain
04:34:33 <andun> something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1786#a1786
04:35:13 <niet> is it not possible to have 2 exes in the same dir?
04:35:33 <pernod> Thank you for your help ivanm.
04:35:38 <zachk> with the same name. no. if you need them to act different add argument processing to them
04:36:04 <ivanm> pernod: hang on, there's more!
04:36:07 <ivanm> gimme a minute!
04:36:14 <pernod> Ooh!
04:36:28 <pernod> The suspense is unbearable!
04:37:38 <Alpounet> Bye alll
04:38:11 <ivanm> pernod: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1784#a1787
04:38:32 <ivanm> you can make Values a parameter of Option if you want (data Option = Call Values | Put Values), but that's up to you
04:38:50 <ivanm> or even combine them into another data structure like cmcq did above
04:39:08 <ivanm> pernod: of course, converting Values into record syntax would make it even cleaner
04:39:38 <pernod> Thanks. I'll need to ponder this a bit, I think.
04:39:40 <ivanm> pernod: of course, I _think_ I got all the abstractions out right... you might want to double check the maths in case I missed a sign somewhere or something :s
04:39:49 <ivanm> pernod: well, your nick is an anagram of ponder... ;-)
04:40:14 <pernod> ivanm: No worries, I need to to take a look at quickcheck, anyhow.
04:40:36 * aleator thinks that hackage should have way to comment on packages as well as donate money for authors. :)
04:40:46 <pernod> ivanm: Hey, I never thought about that. I use the nick because of the connection to my name, and pastis.
04:40:54 <ski_> (isn't "Pernod" a manufacturer of fine spirits .. like Absinthé ?)
04:41:21 <pernod> ski_: Ricard makes Pernod, which is an apertif spirit from Provence.
04:41:46 <ski_> ok
04:42:16 <ivanm> pernod: what's pastis?
04:43:01 <byorgey> vincenz: pong
04:43:18 <pernod> ivanm: http://en.wikipedia.org/wiki/Pastis
04:43:21 <hackage> Uploaded to hackage: network-server 0.2.0
04:43:27 <pernod> Incidentally, I can't stand the stuff :D
04:43:42 <ivanm> *shudder* sounds atrocious
04:43:50 <ivanm> then again, I'm not a big fan of ethanol ;-)
04:44:07 <vincenz> byorgey: do you have syntax coloring on your wordpress blog for haskell, and how come you're not in #oasis?
04:45:58 <byorgey> vincenz: I do not have syntax coloring, although I'd like to.
04:46:23 <byorgey> vincenz: as for the second question, I'm... not sure.
04:46:37 <vincenz> ok
04:48:28 <blathijs> What does the "| ce -> e" part mean in "class Collects e ce | ce -> e where" ? I can't find it in the Haskell Report, so I suspect it's a GHC extension?
04:49:20 <ivanm> blathijs: functional dependency
04:49:24 <ivanm> it's a ghc extension
04:50:04 <ivanm> it means that for the class "Collects e ce", there must be exactly one type of e for each type of ce
04:51:03 <ivanm> e.g. "instance Collects (Foo Int Bool) | Bool -> Int" if the second type parameter to Foo is Bool, then the first is Int
04:51:16 * ivanm probably has something wrong in his description there, but it's something like that
04:51:23 <ivanm> @go functional dependencies ghc
04:51:24 <lambdabot> No Result Found.
04:51:28 <ivanm> @go functional dependency
04:51:29 <lambdabot> http://en.wikipedia.org/wiki/Functional_dependency
04:51:29 <lambdabot> Title: Functional dependency - Wikipedia, the free encyclopedia
04:51:34 <ivanm> there's something in RWH about it IIRC
04:51:45 <blathijs> RWH?
04:52:17 <ivanm> Real World Haskell
04:52:20 <ivanm> @where RWH
04:52:20 <lambdabot> is http://www.realworldhaskell.org/blog/
04:54:00 <StefanK> val <- takeMVar var
04:54:07 <StefanK> how to putStr this val?
04:54:12 <niet> can I patternmatch against a function(result) ?
04:54:14 <quicksilver> putStr val
04:54:19 <quicksilver> (if it's a string)
04:54:21 <pejo> blathijs, I think it's implemented in some other compilers as well, it's been around for a whiel.
04:54:25 <ivanm> StefanK: on the next line, just have "putStr (show val)"
04:54:36 <ivanm> if val isn't a String but is an instance of Show
04:55:33 <StefanK> thanks
04:55:38 <byorgey> niet: I'm not sure what you mean.  can you give an example of what you'd like to do?
04:55:43 <StefanK> and how to sleep?
04:55:58 <quicksilver> in GHC, threadDelay
04:57:03 <StefanK> thanks
05:00:47 <StefanK> why do you need 2 MVars, the second for ack, to implement a CVar? putMVar blocks so 1 MVar should suffice, doesnt it?
05:02:41 <StefanK> once again CVar implemented using (dataMVar, ackMVar). why do you need the ackMVar?
05:10:49 <cognominal> what is comap? it is used in Yi/Keymap/Vi.h
05:12:00 <quicksilver> sounds like it ought to be the method of CoFunctor?
05:12:41 <quicksilver> that is, it's like fmap with the arrow reversed
05:12:43 <lilac> probably comap :: CoFunctor f => (a -> b) -> (f b -> f a)
05:12:56 <quicksilver> CoFunctor f => (b -> a) -> (f a ->  f b)
05:13:18 <lilac> unification successful!
05:14:00 <cognominal> lilac, quicksilverm defined where?
05:15:12 <cognominal> Control.Compse apparently
05:15:42 <RLa> logs url is broken in xchat
05:16:22 <RLa> anyway, i would like to use some kind of ide for haskell but i do not know what is available there
05:18:02 <ivanm> RLa: there isn't a fully complete one
05:19:07 <ivanm> there's plugins for Visual Studio and Eclipse, there's the new leksah project
05:19:17 <ivanm> as well as whole bunch of dead ones
05:19:27 <RLa> i currently use kate for syntax hilight but it does not help to indent function body
05:19:45 <ivanm> AFAIK, most people here use text editors, such as yi (the haskell editor), emacs, [g]vi[m], that Mac one, etc.
05:19:59 <ivanm> RLa: hmmm.... kdevelop has haskell support IIRC (since you seem to be a kde user)
05:20:24 <ivanm> I know that emacs' haskell-mode has indentation support, but it's funky (just like haskell's indentation rules :p )
05:20:25 <RLa> very good, i will look at it
05:20:44 <RLa> i do not get on very well with emacs :(
05:20:49 <ivanm> heh
05:22:36 <RLa> kdevelop does syntax hilight but no indentation :/
05:23:20 <ivanm> RLa: well, I don't know how good it is but you can check out leksah (which should be on hackage) if you want a full-blown IDE
05:26:19 <mstr> emacs haskell-mode is nice
05:30:46 <quicksilver> kuribas's emacs haskell indentation code is much better than the haskell-mode code
05:30:52 <quicksilver> @where kuribas-indentation
05:30:52 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
05:37:33 <matthew-_> right, for those of you with icfp experience
05:37:39 <matthew-_> you know this \category stuff?
05:37:56 <matthew-_> If, say I wanted to use D.1.3
05:38:06 <ski_> *argh* ..
05:38:21 <matthew-_> should what follows be {Concurrent Programming}{Parallel programming}
05:38:31 <matthew-_> ( http://www.acm.org/about/class/ccs98-html )
05:38:32 * ski_ wish people would stop using `cofunctor' for `contravariant functor'
05:38:32 <matthew-_> ?
05:39:16 <ski_> (hint : `contravariant functor' is not the dual of `covariant functor')
05:41:50 <matthew-_> gah, no, I'm wrong
05:41:52 <matthew-_> bother
05:45:11 <ivanm> matthew-_: ping!
05:45:38 <matthew-_> ivanm: pong!
05:45:47 <ivanm> have you managed to look through my changes yet?
05:45:50 <matthew-_> nope
05:45:56 <matthew-_> nor will I for a fortnight
05:45:57 <matthew-_> sorry
05:46:04 <matthew-_> but I'm just orders of magnitude too busy
05:46:10 <ivanm> OK
05:48:57 <porges> anyone know of anything along the lines of FSVec but for heterogenous vectors (ie. tuples)
05:52:32 <temoto> Why doesn't interpreter cache results of frequently called pure functions?
05:52:36 <temoto> ghci
05:52:46 <temoto> They are known to return same result, right?
05:53:40 <niet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1788#a1788 <- euler problem in haskell, takes way too long, how could I simplify it or not bruteforce it?
05:53:52 <ski_> which results to cache ?
05:54:06 <fasta> quicksilver: does kuribas-indentation work with Emacs23?
05:54:23 <ski_> (and when to flush the memory ?)
05:54:31 <ski_> also, looking up arguments in a table may not be a neglible cost
05:55:01 <temoto> ski_: often calculated. This could be configured, man.
05:55:13 <temoto> niet: i'm trying to solve euler problem too :)
05:55:54 <ski_> temoto : e.g. how would you table/memo `fix :: forall a. (a -> a) -> a' ?
05:56:19 <quicksilver> fasta: yes.
05:56:33 <fasta> quicksilver: well, it doesn't here :)
05:56:51 <quicksilver> temoto: the effort of configuring it would be similar to the effort of memoising it yourself.
05:57:07 <quicksilver> temoto: but mainly the reason it doesn't do it is you haven't written and submitted the patch to GHC yet.
05:57:34 <quicksilver> fasta: in what fashion does it fail?
05:58:08 <fasta> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1789#a1789
05:58:17 <whpearson> Is there a guide to releasing a package on hackage?
05:58:20 <temoto> quicksilver: i thought it's like such a common thing, someone HAD to contribute that long ago, or there are obvious reasons not to do it, but i don't see those reasons.
05:59:18 <fasta> quicksilver: I had a working Emacs configuration, added  (add-hook haskell-mode-hook 'turn-on-haskell-indentation) to it and it stopped working.
06:00:19 <temoto> ski_: i know functions are not comparable in haskell, but this could be done possibly loosing some lazyness. And you could cache i.e. only a -> a functions.
06:00:40 <JohnMeacham> anyone have any ideas for writing a parameterizable happy parser? I want to be able to turn on and off certain productions.
06:01:04 <quicksilver> fasta: "stopped working"?
06:01:19 <quicksilver> it gets a bit messy if you have both modes running at once; need to turn off the other indent-mode
06:01:26 <fasta> quicksilver: I pasted the error of the debugger.
06:01:32 <fasta> quicksilver: and I already found the problem.
06:01:41 <fasta> quicksilver: the code was missing a '.
06:02:14 <fasta>  (add-hook haskell-mode-hook 'turn-on-haskell-indentation) needs to be  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
06:02:25 <niet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1788#a1788 <- euler problem in haskell, takes way too long, how could I simplify it or not bruteforce it?
06:02:35 <niet> filter (\[a,b,c] -> (a^2 + b^2 == c^2) && (a+b+c == 1000))
06:02:35 <quicksilver> fasta: I was just about to tell you that, yes.
06:02:48 <niet> thats what  want to find
06:02:51 <fasta> quicksilver: but that's how the author has put it in his installation file.
06:02:55 <quicksilver> niet: the point of the project euler is that most of the problems are too slow to brute force in the most naive way possible
06:03:15 <quicksilver> niet: the "problem" is the mathematical insight needed to simplify the algorithm.
06:04:13 <temoto> niet: yeah there are guys solving problems with a piece of paper. But i bruteforced few of 25 solved.
06:05:42 <niet> ok
06:08:22 <StefanK> CVar = (MVar a, MVar ()). is the only reason we DO NOT need this producer-consumer CVar-connect because GHC implements putMVar blocking-if-already-full ??
06:08:36 <StefanK> /connect/concept
06:09:05 <temoto> There is 'in' operator in python, returns whether left operand is element of right operand list. Is there something like that in haskell?
06:09:10 <quicksilver> not entirely sure what you mean to emphasise with "because GHC implements"
06:09:17 <quicksilver> there are no choices in the semantics of MVars
06:09:19 <tromp_> :t elem
06:09:20 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:09:25 <quicksilver> the whole point about them is that put blocks when they're full
06:09:29 <quicksilver> and take blocks when they're empty.
06:09:35 <StefanK> it seems putMVar overwrites already-full MVars but ghc implements it to block if already full
06:09:41 <fasta> quicksilver: how do you enable the mode? It only appears to work when I do M-x haskell-indent-mode
06:09:46 <Alpounet> > (in) e s = elem e s
06:09:47 <lambdabot>   <no location info>: parse error on input `in'
06:09:51 <quicksilver> haskell-indent-mode is the old one
06:09:52 <fasta> quicksilver: I don't have any other hooks that I use.
06:09:59 <quicksilver> the new one is haskell-indentation-mode
06:10:30 <Alpounet> no way to define alphanumerics operators ?
06:10:32 <fasta> quicksilver: yes, sorry, that's the one that I meant.
06:10:35 <quicksilver> StefanK: why does it "seem putMVar overwrites full mvars" ?
06:10:37 <temoto> > let (in) e s = elem e s
06:10:38 <lambdabot>   <no location info>: parse error on input `in'
06:10:50 <doserj> in is a reserved keyword
06:10:54 <quicksilver> Alpounet: no, but you can use any alphanumeric in infix mode
06:10:54 <StefanK> quicksilver: this paper also creates an CVar because putMVar overwrites per default and GHC seems to implement special behaviour : http://research.microsoft.com/en-us/um/people/simonpj/papers/concurrent-haskell.ps.gz
06:11:05 <Alpounet> ah
06:11:07 <Alpounet> yeah
06:11:10 <temoto> oh sure, reserved
06:11:14 <quicksilver> > 1 `elem` [1,2,3,4]
06:11:15 <Alpounet> with `it`
06:11:15 <lambdabot>   True
06:11:23 <Alpounet> > in = elem
06:11:24 <lambdabot>   <no location info>: parse error on input `in'
06:11:36 <Alpounet> damned
06:11:41 <temoto> > (in_) e s = elem e s
06:11:42 <lambdabot>   <no location info>: parse error on input `='
06:12:00 <doserj> > in_ e s = elem e s
06:12:01 <lambdabot>   <no location info>: parse error on input `='
06:12:08 <fasta> quicksilver: I am saying that when I press TAB when I load a Haskell buffer, I get a TAB char, not an indentation.  I only have (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation) in my .emacs related to haskell-mode and the (require 'haskell-mode), but that's it.
06:12:10 <temoto> ah drop it, i'll use `elem` form
06:12:20 <temoto> it's only two bytes longs
06:12:23 <temoto> longer*
06:12:38 <doserj> > let in_ e s = elem e s in 2 `in` [1..10]
06:12:39 <lambdabot>   <no location info>: parse error on input `in'
06:12:45 <doserj> > let in_ e s = elem e s in 2 `in_` [1..10]
06:12:47 <lambdabot>   True
06:12:48 <quicksilver> fasta: was the buffer in haskell-mode at all?
06:12:54 <fasta> quicksilver: yes
06:13:14 <Alpounet> heh doserj :p
06:13:15 <fasta> quicksilver: if I manually M-x <the indent command> then it works.
06:13:21 <fasta> quicksilver: but the hook doesn't.
06:13:28 <quicksilver> can't explain that.
06:13:36 <quicksilver> hooks run when the buffer switches to that mode
06:13:43 <quicksilver> are you sure the buffer was in haskell-mode?
06:13:44 <StefanK> quicksilver: an MVar can very nearly be used to mediate a producer/consumer connection [...] there is nothing to stop the producer overrunning and writing a second value before the consumer has removed the first. [...] easily solved by using a second MVar to handle ack from the consumer to the producer. CVar a = (MVar a, MVar ())
06:13:57 <fasta> quicksilver: yes, it says "Haskell" in the mode line.
06:14:46 <quicksilver> StefanK: that paper talks about MutVars not MVars, doesn't it?
06:15:02 <quicksilver> ah no, I see it.
06:15:02 <temoto> > filter (elem 10) [1..20]
06:15:03 <lambdabot>       No instance for (Enum [t])
06:15:03 <lambdabot>        arising from the arithmetic sequence ...
06:15:09 <greenrd> I'm having trouble trying to load a plugin into gitit
06:15:12 <fasta> (turn-on-haskell-indentation
06:15:12 <fasta>  (lambda nil
06:15:12 <fasta>    (abbrev-mode 1))
06:15:12 <fasta>  turn-on-haskell-indent turn-on-haskell-doc-mode)
06:15:15 <StefanK> quicksilver: is there a difference? we learned MVar stands for Mutable Variable
06:15:17 <temoto> Please help with elem.
06:15:22 <greenrd> gitit uses the GHC API to load and interpret plugins
06:15:29 <fasta> quicksilver: the value of haskell-mode-hook looks a bit wrong.
06:15:29 <greenrd> This is the error I'm getting:
06:15:47 <greenrd> gitit: /usr/lib/ghc-6.10.1/ghc-6.10.1/HSghc-6.10.1.o: unknown symbol `editlinezm0zi2zi1zi0_SystemziConsoleziEditlineziReadline_a46_closure'
06:15:47 <greenrd> gitit: gitit: unable to load package `ghc-6.10.1'
06:15:50 <quicksilver> StefanK: well, the choice of MVar api in that paper must have been reversed later.
06:16:05 <Alpounet> temoto, what do you want your code to do ?
06:16:07 <quicksilver> StefanK: that's not how mvar's actually behave now.
06:16:29 <greenrd> maybe I need to somehow link gitit with editline?
06:16:31 <quicksilver> fasta: yes, that looks wrong.
06:17:01 <quicksilver> (turn-on-haskell-doc-mode turn-on-haskell-decl-scan (lambda nil (haskell-indentation-mode)))
06:17:04 <quicksilver> is what I have
06:18:14 <temoto> Alpounet: i want to get a list of anti intersection of two lists. As in  g [1..5] [1..7] = [6,7]
06:18:35 <temoto> Alpounet: i thought i could use filter elem for that
06:19:11 <Alpounet> it is, if you use it smartly
06:19:23 <Alpounet> I advise you, first, to write a "long" version
06:20:25 <StefanK> quicksilver: thanks very much!
06:21:20 <tippit> what can be said about the numbers in pythagoras theorem? a^2+b^2=c^2, if im looking for a,b and c that satisifes pythagoras theorem and also a+b+c=1000, then brutefocring doesnt work so I need to simplify it and not search for all numbers. (this is project euler 9 btw).
06:21:39 <tippit> i still dont get what i can simpify and there isnt anything about it that i can fidn on wikipedia
06:22:20 <doserj> tippit: there is no need to look for c
06:23:36 <tippit> why not?
06:23:41 <tippit> c= 1000-a-b
06:23:49 <tippit> but i dont see how that helps
06:23:50 <Alpounet> yeah
06:23:55 <mlesniak> Is there a difference between using "," and "|" in list comprehensions, e.g. are [f (a,b)| a <-[1], b<-[3]] and [f (a,b)| a <-[1] | b<-[3]] the same? If yes, why exist two possiblities, i.e. what is the advantage of one over the other?
06:24:25 <quicksilver> mlesniak: they are completely different.
06:24:26 <doserj> tippit: well, with that I find the answer instantly in ghci
06:24:27 <byorgey> tippit: see https://secure.wikimedia.org/wikipedia/en/wiki/Pythagorean_triples
06:24:41 <quicksilver> mlesniak: (well, those two examples happen to be the same but it's a degenerate example)
06:24:42 <MarcWeber> join #xorg
06:24:50 <byorgey> tippit: you can generate triples by  a = 2mn, b = m^2 - n^2, c = m^2 + n^2
06:24:52 <mlesniak> quicksilver: Oh, thanks, any link for more information? Google couldn't help me much on "haskell lish comprehension"
06:24:57 <quicksilver> mlesniak: list comprehensions use ","
06:25:03 <quicksilver> the second "|" is a GHC extension
06:25:05 * mlesniak nods
06:25:28 <mlesniak> quicksilver: Ah, I understand. That's why I did not found enough information ;-)
06:25:33 <quicksilver> mlesniak: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#parallel-list-comprehensions
06:25:39 <byorgey> > [ (x,y) | x <- [1..3], y <- [1..3] ]
06:25:40 <Petrosian> mlesniak: Observing the output of each is a good start
06:25:41 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
06:25:45 <byorgey> > [ (x,y) | x <- [1..3] | y <- [1..3] ]
06:25:46 <lambdabot>   [(1,1),(2,2),(3,3)]
06:26:09 <mlesniak> Petrosian: Hmm, you're right. In my small examples the just seem to be the same
06:26:30 <quicksilver> mlesniak: due to the remarkable theorem that 1 = 1 * 1 :)
06:26:36 <mlesniak> quicksilver: :P
06:26:45 <mlesniak> quicksilver: Petrosian Thanks for your help!
06:27:08 <mlesniak> (...and byorgey, thanks, too :))
06:28:01 <byorgey> quicksilver: isn't that on page 1046 of PM?
06:28:30 <Alpounet> PM ?
06:28:39 <quicksilver> byorgey: the only copy I have is in greek, and the page numbers don't match I don't think.
06:28:46 <Petrosian> Does anyone know what the relative difficulty increase is when checking multi-parameter type classes as opposed to haskell98 type classes?
06:28:50 <byorgey> hehe
06:29:00 <Petrosian> Is it conceptually the same, with a few tweaks, for example
06:29:05 <byorgey> Alpounet: Principia Mathematica, by Russell and Whitehead
06:29:05 <Petrosian> Or all together just harder!
06:29:08 <quicksilver> Petrosian: AFAIK it's a non-issue.
06:29:16 <quicksilver> not really harder at all.
06:29:23 <quicksilver> fundeps are something harder though
06:29:27 <int-e> byorgey: knowing that generator turns it into a pen & paper problem. (the sum of these three numbers factos easily)
06:29:28 <Alpounet> Ah.
06:29:30 <Petrosian> quicksilver: Cheers
06:29:45 <byorgey> int-e: indeed.
06:29:54 <Petrosian> quicksilver: Know of any related papers perchance?
06:30:14 <Petrosian> And on a side note, any reason haskell98 type classes aren't multi-parameter in that case?
06:32:11 <doserj> Type-classes were invented to deal with the overloading of == and +,-,* etc. There just was no need for multi-parameter type classes
06:32:42 <doserj> (and without fundeps, they are actually not very useful)
06:32:57 <Petrosian> Hmm
06:33:25 <Petrosian> The syntax suggested otherwise to me
06:33:41 <Petrosian> For example, class (A a) => B a where
06:34:40 <pejo> Petrosian, check Mark Jones initial paper on fundeps, it has a good history about how mptc's weren't as useful as they were initially thought to be.
06:34:41 <Petrosian> Would've thought under the original, single param scheme that (A a) => was superfluous in the sense that "a" is the only free variable that could possible be user, and simply "A" would suffice
06:34:56 <Petrosian> pejo: Cheers, will do
06:37:42 <quicksilver> Petrosian: I don't think I understand your point about A a => B a
06:37:50 <fasta> quicksilver: I don't see where turn-on-haskell-indent is coming from, though.
06:38:03 <quicksilver> fasta: some previous attempt to customise maybe?
06:38:24 <fasta> quicksilver: no, I will probably have to find it myself.
06:38:46 <fasta> quicksilver: well, at least maybe haskell-mode enables it by itself?
06:39:30 <Petrosian> quicksilver: Under haskell98 type classes, couldn't you simply have something like `class A => B a where'?
06:39:35 <Petrosian> I know, it's not a hugh time saver.
06:40:50 <quicksilver> Petrosian: that just looks odd.
06:41:00 <quicksilver> Petrosian: recall you can write things like "class A a => B [a]"
06:41:03 <byorgey> Petrosian: even with only single param type classes, you could still have something like 'class (A a) => B (Foo a)'
06:41:12 <niet> genAB = [[a,b] | a <- [1..1000], b <- [1..1000]]
06:41:13 <quicksilver> Petrosian: class A a => B (Either a Int)
06:41:14 <cmcq> or (Eq a, Eq b) => Eq ((,) a b)
06:41:14 <niet> satisfies = filter (\[a,b] -> (a^2 + b^2 == (1000-a-b)^2))
06:41:15 <quicksilver> etc.
06:41:16 <niet> tripleProduct = product $ head $ satisfies genAB
06:41:18 <niet> is what i did, it takes a fews seconds, how can i improve it?
06:41:29 <Petrosian> quicksilver, byorgey: Good point, thanks!
06:41:40 <quicksilver> Petrosian: cmcq's example is a good one too
06:41:59 <doserj> quicksilver: can you?
06:42:17 <byorgey> niet: b only has to go up to (1000-a)
06:42:37 <byorgey> actually, (1000-a-1)
06:43:21 <byorgey> niet: also, did you run it in ghci?  if you compile it with -O2 it will likely be much faster.
06:43:31 <quicksilver> doserj: yes, although you can't do the other way around (A [a] => B a) in h98
06:43:37 <quicksilver> doserj: that require UndecidableInstances
06:43:46 <Petrosian> Wait, are you sure?
06:43:56 <Petrosian> That applies for the instance declarations, but not for class decls. surely?
06:44:07 <Petrosian> (GHC is throwing out an error for me)
06:45:00 <quicksilver> Petrosian: you're completely right
06:45:06 <quicksilver> (and so presuably was doserj)
06:45:12 <quicksilver> I was talking about instance decls all along.
06:45:43 <doserj> but of course noone would like instance declaration to look different than class declarations
06:45:53 <doserj> so the point is still valid :)
06:45:59 <Petrosian> The point still stands
06:46:14 <Petrosian> It would make an ugly, albeit concise syntax!
06:47:22 <Petrosian> Tho', possibly, prevent class/instance decl. confusion
06:50:39 * whpearson is having a parameter ordering conundrum
06:51:19 <whpearson> If you were given a function that removed one list from another, which way would would you put the parameters?
06:52:03 <quicksilver> > [1..5] \\ [3,4]
06:52:05 <lambdabot>   [1,2,5]
06:52:10 <quicksilver> in that order, personally.
06:52:24 <doserj> whpearson: in the same order as - on numbers
06:53:54 <whpearson> I did that originally, then wondered if it mucked up doing point free code where you tend to want the data structure last...
06:54:12 <whpearson> If I understand things correctly.
06:54:24 <fasta> quicksilver: I fixed some things, but now I get: File mode specification error: (void-function haskell-indentation-mode)
06:54:34 <quicksilver> whpearson: that's why we have section notation :)
06:54:35 <byorgey> whpearson: well, there's always 'flip'.  I wouldn't worry about it too much.
06:54:59 <quicksilver> fasta: sounds like you haven't loaded the file haskell-indentation.el
06:55:16 <fasta> quicksilver: as in with load-file?
06:55:22 <quicksilver> well I use auto-load
06:55:29 <doserj> or require
06:55:31 <quicksilver> (autoload 'haskell-indentation-mode "haskell-indentation" "Major mode for editing Haskell scripts - kuriabs indentation mode." t)
06:56:53 <ski_> s/kuriabs/kuribas/
06:56:54 <fasta> quicksilver: thanks, I believe it is working.
06:57:47 <quicksilver> ski_: that is only a comment string. But you're right of course :)
07:02:01 <niet> is filter lazy?
07:02:52 <fasta> niet: yes, filter (const True) [1..]
07:03:12 <fasta> niet: filterM isn't however.
07:03:44 <dolio> > filterM (const . const $ True) [1..] 5
07:03:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:04:11 <ski_> > runIdentity (filterM (const (return True)) [1..])
07:04:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:04:29 <fasta> .. in the monads where I use filterM :)
07:04:56 <niet> so filter . filter will do comparisons for each element and not raverse twice?
07:05:04 <niet> traverse
07:05:13 <ski_> > evalState (filterM (const (return True)) [1..]) ()
07:05:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:05:20 <fasta> niet: you should not care about that.
07:05:56 <fasta> niet: it will probably be merged into one call to filter, and if not you could write a RULE which does that.
07:06:10 <quicksilver> but even if it isn't merged
07:06:12 <fasta> niet: or a source to source transformation of Haskell source code, if you don't like RULES.
07:06:17 <quicksilver> it still only traverses once.
07:06:55 <fasta> Oh, right.
07:07:23 <ski_> (i.e. it may or may not traverse an intermediate (more or less virtual) list, but it would not traverse the input list twice)
07:09:00 <niet> RULES?
07:09:21 <quicksilver> a GHC extension for specifying code rewritin
07:09:28 <niet> ok
07:09:30 <quicksilver> effectively allows you to reporgam the optimiser
07:09:33 <quicksilver> to some extent
07:09:40 <quicksilver> and indeed, break everything if you choose to.
07:09:54 <ski_> 8.13.7. RULES pragma <http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#rules>
07:10:02 <byorgey> niet: you really needn't worry about RULES.  I have never used them.
07:10:10 <pejo> It would be really nifty with easy to use and more powerful rules. :-)
07:11:30 * ski_ is tempted to `@where+' that to `ghc-rules'
07:13:22 <quicksilver> @where+ rules http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#rules
07:13:22 <lambdabot> Nice!
07:13:26 <quicksilver> ski_: be bold! :)
07:14:30 * ski_ is not
07:14:56 <niet> all languages are formal systems I guess(are they completely?) but does Haskell have more derivable properties than Java? ie can you reason about a haskell program on a higher level?
07:15:07 <ski_> (also plain `rules' doesn't have the same sound as `ghc-rules' ..)
07:15:36 <quicksilver> ski_: no, but it's easier to remember and not likely to be ambiguous in this channel.
07:15:38 <pejo> niet, not having wild sideeffects is really nice when you want to reason about things.
07:15:43 <alinp> hi
07:15:57 <alinp> I just installed ghc 6.10.1 as binary distribution on ubuntu
07:17:38 <alinp> and when running ghc --make Setup I'm getting this: Could not find module `Setup':
07:18:00 <alinp> does anyone have any idea about what's happening here ?
07:19:21 <niet> when RSA encrypting someting like "hello" how do I encrypt each letter? do I take the hexadecimal value of "h" or something and then chnage that?
07:19:58 <Valodim> uh, not really..
07:20:00 <dormoose> alinp: Setup.hs, perhaps, not Setup?
07:20:01 <opqdonut> niet: usually blocks of some length
07:20:17 <p_l> niet: You take byte values of whole blocks and do arithmetic on them
07:20:25 <opqdonut> niet: so for example interpret 8 characters as a binary number of length 8*8
07:20:28 <whpearson> I would like some comments on the small class for traces I made. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1792#a1792 Especially where I might put it in the module hierarchy.
07:20:42 <alinp> Linking Setup ...
07:20:42 <alinp> /usr/bin/ld: cannot find -lgmp
07:20:42 <alinp> collect2: ld returned 1 exit status
07:21:06 <alinp> dormoose: sorry, it was my bad ... the folder that I was into was deleted and .. nevermind
07:21:07 <alinp> but
07:21:11 <alinp> now I'm getting this
07:21:21 <alinp> shouldn't I specify the location of libraries ?
07:21:44 <alinp> because the distribution was installed in one of my home folders
07:21:52 <alinp> not in a standard OS folder
07:22:05 <alinp> in order to make the ldconfig to pickup the libraries
07:22:10 <dormoose> alinp: That's libgmp, the arbitrary-precision math. It should come with your OS. Check if /usr/lib/libgmp.so exists.
07:22:25 <alinp> well, should be there ?
07:22:34 <alinp> or in the distribution's lib folder ?
07:23:17 <dolio> filter p l = build (\c z -> foldr (\x xs -> if p x then c x xs else xs) z l)
07:23:19 <pejo> alinp, if you want ld to find things you need to pass -L/somewhere/lib to it.
07:23:25 <fasta> nominolo: Scion's C-c C-l interferes with the one from Haskell mode and C-c C-t doesn't even work.
07:23:37 <pejo> alinp, but dormoose's suggestion sounds better, check if it's already installed.
07:23:58 <nominolo> fasta: ah, right, I wanted to fix that
07:24:07 <dolio> filter p (filter q l) =expand build (\c z -> foldr (\x xs -> ...) (build (\c' z' -> foldr (\y ys -> ...) z' l))) =fusion build (\c z -> foldr (\y ys -> if q x then (\x xs -> if p x then c x xs else xs) x xs else xs) z l) =beta build (\c z -> foldr (\y ys -> if q x then (if p x then c x xs else xs) else xs) z l) =contract filter (p . q) l
07:24:14 <dolio> Wow, that looks bad.
07:24:24 <alinp> well, the thing is that: ubuntu 8.10 comes with ghc 6.8 package
07:24:29 <alinp> I wanted 6.10
07:24:31 <nominolo> fasta: the idea was that Scion takes over the C-c C-l functionality from Haskell mode
07:24:35 <fasta> nominolo: also, the M-x scion that the user needs to do is redundant.
07:24:40 <alinp> so ... I removed 6.8 ... and plated this new one
07:24:46 <alinp> from haskell's site
07:24:54 <alinp> maybe I need the old one ?
07:24:58 <alinp> (also)
07:25:11 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1793#a1793 <-- no rules necessary for filter fusion.
07:25:13 <dormoose> alinp: nope, but you need the libgmp package.
07:25:25 <alinp> libgmp.so.3@
07:25:26 <alinp> libgmp.so.3.4.2
07:25:29 <nominolo> fasta: it is, ATM, because there is no good reason to connect to a running server
07:25:35 <alinp> it seems that I have these 2 in /usr/lib
07:25:56 <dormoose> alinp: dpkg -l libgmp3c2 should tell you whether it's installed.
07:26:32 <alinp> ii  libgmp3c2                               2:4.2.2+dfsg-3ubuntu1                   Multiprecision arithmetic library
07:26:33 <alinp> so
07:26:37 <alinp> I guess is installed
07:26:49 <dolio> Err, that shouldn't be p . q.
07:27:02 <alinp> libgmp3-dev
07:27:07 <alinp> I don't need this one also ?
07:27:16 <dormoose> Probably you do.
07:27:30 <nominolo> fasta: I could make it idempotent so it can be put into the haskell-mode-hook
07:27:46 <dormoose> alinp: libgmp3-dev libgmp3c2 libgmpxx4ldbl are installed o'er here
07:27:55 <dolio> Man, I messed up on the xs and ys, too.
07:28:06 <alinp> yep, hurray
07:28:07 <dormoose> alinp: And yes, you need it, because you're doing linking against libgmp.
07:28:08 <alinp> it worked
07:28:11 <alinp> thanks guys
07:28:18 <dormoose> (=
07:28:30 <fasta> nominolo: if I can make a suggestion, just implement the "get type at current location" thing first, have it work with haskell-mode and then do other things.
07:28:55 <nominolo> fasta: that's not so easy to implement
07:29:26 <fasta> nominolo: or something else which is easy to implement?
07:29:37 <fasta> nominolo: because currently Scion has no features, AFAIK.
07:29:47 <nominolo> fasta: have you turned on background-typechecking?
07:30:19 <fasta> nominolo: yes, I did, but Scion as a whole didn't help, because C-c C-l didn't work.
07:30:29 <nominolo> fasta: why not?
07:30:32 <fasta> nominolo: so, I didn't really see the benefits, although there might be.
07:30:42 <nominolo> what doesn't work?
07:30:47 <fasta> nominolo: C-c C-l worked, but clashed with Haskell-mode.
07:30:55 <fasta> nominolo: I want that the module gets loaded.
07:31:10 <fasta> nominolo: it did say compiled in 0.0 seconds, or something like that.
07:31:19 <nominolo> right, that's what i wanted to get to work bofore the release
07:31:26 <fasta> nominolo: yes, I understood.
07:31:31 <nominolo> that it works without a cabal file
07:32:02 <nominolo> fasta: have you tried it on a project with a .cabal file?
07:32:08 <fasta> nominolo: yes
07:32:16 <nominolo> did that work?
07:32:27 <fasta> nominolo: C-c C-t didn't, but otherwise yes.
07:32:36 <fasta> nominolo: it said something like loaded <project foo>
07:32:53 <nominolo> C-c C-t needs background typechecked info, which it doesn't do automatically yet
07:33:20 <nominolo> Hm, I think I should make C-c C-l smarter
07:33:52 <nominolo> ATM, you have to do M-x scion; C-c C-o file; C-c C-l
07:36:24 <ski_> @where scion
07:36:24 <lambdabot> I know nothing about scion.
07:36:42 <nominolo> fasta: I guess C-c C-l should find out whether we might be in a .cabal project, present you with all the components and let the user pick one.  Alternatively, it should work just with a file
07:37:16 <fasta> nominolo: "components"?
07:37:28 <nominolo> @where+ scion http://code.google.com/p/scion-lib/
07:37:28 <lambdabot> Nice!
07:37:35 <fasta> nominolo: you mean like library/executable?
07:37:37 <nominolo> fasta: library / executable
07:37:40 <fasta> haha
07:38:13 <nominolo> @where scion
07:38:13 <lambdabot> http://code.google.com/p/scion-lib/
07:38:28 <nominolo> @cookie lambdabot
07:38:28 <lambdabot> Unknown command, try @list
07:38:30 <fasta> nominolo: yes, and if there is only one pick that one obviously.
07:38:39 <nominolo> right
07:39:03 <Alpounet> @list
07:39:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:39:15 <nominolo> @botsnack
07:39:15 <lunabot>  :)
07:39:15 <lambdabot> :)
07:40:31 <dormoose> :)
07:40:48 <wli> A lot of the pain here is that I actually end up having to do something with errors vs. letting them propagate all the way to program exit.
07:43:22 <hackage> Uploaded to hackage: barrie 0.4.1
07:45:20 <wli> Stack an ErrorT WhateverError atop everything else, runErrorT at the inner monad, deal with it all in either. The error throwers are simplified, but the handler can only be simplified so much.
07:59:45 <drdozer> o/
08:01:57 * boegel waves
08:02:43 * drdozer waves at boegel
08:03:29 <niet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1795#a1795
08:03:44 <niet> i guess im missing something incredibly obvious but...
08:04:15 <niet> very weird, bug?
08:05:06 <quicksilver> niet: different between Int and Integer
08:05:30 <quicksilver> overflowing at 2^32 or 2^64 will change the result
08:05:54 <drdozer> >855^2753 `mod` 3233
08:06:01 <drdozer> > 855^2753 `mod` 3233::Int
08:06:03 <lambdabot>   31
08:06:09 <drdozer> > 855^2753 `mod` 3233
08:06:11 <lambdabot>   123
08:06:53 <quicksilver> normally when performing powers modulo a base, we keep reducing modulo that base after each squaring.
08:06:57 <niet> somethign with the read?
08:06:57 <niet> ah i was jsut gona say
08:07:05 <quicksilver> so we never overflow, and get the right answer.
08:07:11 <drdozer> decrypt :: (Integral b) => Int -> b -> String -> Int
08:08:02 <niet> how do I make emacs insert the type of a function?
08:19:39 <wli> No dice with @djinn (Monad m, Monad m') => (t -> m' (m t)) -> m t -> m' (m t)
08:20:15 <byorgey> wli: I don't think you can write such a thing in general.
08:20:26 <byorgey> wli: only if you can commute m m'  to m' m.
08:20:44 <wli> It actually never commutes.
08:20:58 <wli> m' and m appear in the same order both times.
08:21:46 <byorgey> @type \f m -> fmap join $ Data.Traversable.sequence (fmap f m)
08:21:47 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad f, Data.Traversable.Traversable m, Functor f, Monad m) => (a1 -> f (m a)) -> m a1 -> f (m a)
08:22:07 <wli> That probably does it.
08:22:17 <byorgey> after you do (fmap f m), you get something of type  m (m' (m t))
08:22:35 <byorgey> so to be able to reduce that to  m' (m t), you have to first commute the m and m' to get (m' (m (m t)))
08:22:41 <byorgey> then you can use (fmap join).
08:23:29 <byorgey> so you can write it if and only if m is an instance of Traversable.
08:23:46 <byorgey> well, I guess I'm not 100% sure about the 'only if' part =)
08:24:45 <wli> I guess Data.Traversable.sequence is a sequence working on Maybe
08:25:41 <byorgey> wli: it generalizes the Prelude sequence from lists to any traversable functor.
08:26:06 <byorgey> I'm pretty sure Maybe is Traversable, if that's what you're saying.
08:26:24 <dolio> @instances-importing Data.Traversable Traversable
08:26:24 <lambdabot> Maybe, []
08:26:48 <dolio> @instances-importing Data.Traversable Data.Set Data.Map Data.Sequence Traversable
08:26:48 <lambdabot> Map k, Maybe, Seq, ViewL, ViewR, []
08:27:32 <byorgey> @instances-importing Data.Tree Traversable
08:27:33 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
08:27:45 <byorgey> um
08:27:56 <dolio> You need to import Data.Traversable to get the class in scope.
08:28:00 <wli> Yeah, generalized sequence is it. liftM listToMaybe . sequence . maybeToList more concretely.
08:28:12 <byorgey> @instances-importing Data.Traversable Data.Tree Traversable
08:28:12 <lambdabot> Maybe, Tree, []
08:28:26 <byorgey> ah, cool, I never understood instances-importing before =)
08:28:32 <byorgey> wli: great!
08:28:52 <raji> do you have any implmentations of 3D range trees in haskell
08:29:16 <wli> raji: Try R trees.
08:29:17 <dons> hunt around on hackage.haskell.org
08:29:43 <wli> raji: Look for R  trees. The multidimensional analogue of range trees is called an R tree.
08:29:48 <raji> wli, i was looking for orthogonal range trees not R trees
08:30:08 <wli> raji: I've not heard of orthogonal range trees. Sorry, then.
08:30:09 <niet> what the fuck how can ther eb a clash between Int and Integer ?
08:30:38 <quicksilver> niet: they are different types.
08:30:45 <raji> wli, maybe they are same. it is used for spatial queries like smallest lexicographical point less than other point etc
08:30:59 <dolio> @type \f m -> Data.Traversable.traverse (join . f) m
08:31:00 <lambdabot> forall (m :: * -> *) a a1 (t :: * -> *). (Applicative m, Data.Traversable.Traversable t, Monad m) => (a1 -> m (m a)) -> t a1 -> m (t a)
08:31:04 <wli> That sounds different.
08:31:29 <dolio> @type \f m -> fmap join $ Data.Traversable.traverse f m
08:31:30 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Data.Traversable.Traversable m, Applicative f, Monad m) => (a1 -> f (m a)) -> m a1 -> f (m a)
08:31:49 <byorgey> niet: if you need to convert, use 'fromIntegral'
08:32:06 <byorgey> > (2::Int) + (3::Integer)
08:32:07 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
08:32:12 <byorgey> > fromIntegral (2::Int) + (3::Integer)
08:32:13 <lambdabot>   5
08:33:06 <byorgey> dolio: ah, nice.
08:34:00 <niet> yeah but wtf now i ahve to explicitly annotate my whole fucking program with Integer instead of Int
08:34:13 <niet> so the typesystem si greta until you actually use it heh
08:34:46 <raji>  i'll pose the problem. i've a sequence of tuples { R,G,B ,cost }, The number of such tuples is 800x600.  For ith point i want to get the highest cost of tuples from 1<=j<i such that Rj<Ri AND Bj<Bi AND Gj<Gi ?
08:35:06 <raji> Then i insert ith point and query i+1th point
08:35:50 <wli> I've got a number of things like maybe (return ()) and maybe (return Nothing) floating around to hopefully abstract out.
08:35:57 <niet> and ic ant fakkin !! an Integer
08:35:57 <niet> how retarded is this?
08:36:23 <Twey> In general terms if you're using !! you're doing something wrong
08:36:41 <Twey> Lists are meant to be iterated; selecting specific values is rarely useful
08:36:50 <newsham> how many steps doesit take to (!! 12345678901234567890) ?
08:37:08 <Twey> 12345678901234567891, I believe
08:37:30 <raji> wli, does my problem sound good for R trees ?
08:37:52 <wli> Well, there are occasional functions where you define a list of tabulated values and then !! to extract the right one for your answer.
08:37:58 <wli> raji: No, it sounds different.
08:38:23 <raji> wli, anything that comes to your mind
08:38:48 <quicksilver> niet: you do not have to annotate your whole program.
08:39:05 <quicksilver> niet: you just have to learn when to use which types, and give the type checker the occasional small nudge in the right direction.
08:39:13 <wli> raji: R trees are like trees of intervals in N dimensions. There an interval's analogue is a box, a_k <= x_k <= b_k for 1 <= k <= n
08:39:21 <fasta> quicksilver: this indent mode doesn't handle a <- b <newline> <lots of spaces> c <-d <TAB>
08:39:36 <quicksilver> niet: there are important reasons to distinguish between Int and Integer
08:40:03 <fasta> quicksilver: but it does show less candidates for other situations, but I am not yet convinced that it is superior.
08:40:08 <wli> Just say (!!) = genericIndex
08:40:31 <quicksilver> fasta: unlike other modes, it doesn't reindent when the cursor on at the right-hand end of the line
08:40:33 <Twey> OCCASVS: Yeah, I have played it16:40:08 < wli> Just say (!!) = genericIndex
08:40:38 <fasta> quicksilver: oh, I see, there is back space for this
08:40:38 <Twey> Bah
08:40:43 <quicksilver> fasta: yes ;)
08:40:44 <Twey> Damn you, scroll wheel
08:40:50 <Twey> niet: 16:40:08 < wli> Just say (!!) = genericIndex
08:40:51 <quicksilver> TAB to move to the next-right
08:40:54 <raji> wli, thanks i'll see if augmenting R trees will help
08:40:59 <fasta> quicksilver: still, I was kind of used to the TAB banging ;)
08:41:14 <quicksilver> yeah
08:41:24 <quicksilver> me too, but after a while I preferred this one
08:41:25 <niet> and why does haskell eat up all resources when you run a heavy program, who told ghc it owns my computer? can I set max memory and processor usage?
08:41:28 <niet> Couldn't match expected type `Integer' against inferred type `Int'
08:41:28 <niet>     In the second argument of `E.encrypt', namely `(pubn :: Integer)'
08:41:32 <niet> kdding me ? ^^
08:41:43 <quicksilver> niet: that's no different from any other program on your computer
08:41:52 <quicksilver> niet: all programs on your computer can hog all the resources
08:41:59 <quicksilver> blame the author of your OS for that.
08:42:10 <Twey> Unless you ulimit them
08:42:12 <quicksilver> it's certainly got nothing to do with ghc.
08:42:25 <quicksilver> niet: as I've said twice. They are differen types.
08:42:39 <niet> yeah but ::Integer converts it, doesnt it?
08:42:42 <quicksilver> no.
08:42:47 <quicksilver> ::Integer is an annotation, not a conversion.
08:42:51 <Twey> fromIntegral does
08:42:56 <niet> so what does?
08:42:58 <quicksilver> it tells the type checker that the type *is* Integer.
08:43:00 <quicksilver> fromIntegral.
08:43:23 <niet> (read (show pubn)::Integer)
08:43:26 <whpearson> Also nice can be used to make programs hog less CPU
08:43:43 <Twey> niet: ... no
08:43:48 <doserj> @src fromIntegral
08:43:48 <lambdabot> fromIntegral = fromInteger . toInteger
08:44:00 <doserj> in this case, toInteger would be sufficient :)
08:44:17 <Twey> TouchÃ©
08:45:09 <quicksilver> doserj: true, but it's better to learn fromIntegral because it works both ways around
08:45:21 <quicksilver> and in various other situations like Int -> Double
08:45:32 <quicksilver> there's no real reason to use toInteger specifically
08:45:46 <niet> RSA: getMBlocks: VirtualAlloc MEM_COMMIT failed: The paging file is too small fo
08:45:46 <niet> r this operation to complete.
08:45:48 <niet> uh?
08:46:11 <doserj> quicksilver: toInteger says exactly what it does. fromInteger is not so clear. You have to know what the result should be
08:46:23 <quicksilver> doserj: fromIntegral, not fromInteger.
08:46:37 <doserj> sorry, yes. same argument.
08:46:42 <quicksilver> doserj: I agree the name is possibly confusing. But fromIntegral can be used in many more situations.
08:46:49 <quicksilver> doserj: and in particular it subsumes toInteger entirely
08:46:58 <quicksilver> I find it simpler to learn + remember one thing than two.
08:48:01 <doserj> there is nothing to learn about toInteger :)
08:48:47 <nomeata> Hi. Is Magnus Therning here somethimes?
08:49:09 <quicksilver> niet: I've never used windows, but I believe that's the message that windows gives when you run out of memory.
08:49:23 <quicksilver> if so, that probably means you have a memory leak
08:50:00 <Twey> Sounds like you've got let a = 1:a in a or something
08:50:37 <redditbot> GHC on SPARC: Benchmarking
08:50:37 <redditbot> koweycode: inkscape layers
09:08:29 <Cheshire> > 12
09:08:31 <lambdabot>   12
09:09:36 <boegel> Cheshire: what were you expecting?
09:09:45 <Cheshire> 12
09:10:26 <asgaroth>  /join #latex
09:12:55 <fasta> Is there an OS (one which runs e.g. Firefox) where fork bombs don't work btw?
09:13:07 <tromp_> haskell lives up to expectations!
09:13:28 <SamB> fasta: don't work for what ?
09:13:50 <pejo> fasta, you usually handle that with a proper user limit on resources.
09:13:53 <fasta> SamB: in that one can stop the fork bomb without rebooting the machine.
09:14:04 <quicksilver> fasta: well the win32 platform doesn't have fork()
09:14:05 <Ferdirand> fasta: nproc in /etc/security/limits.conf, for linux
09:14:16 <SamB> quicksilver: so ?
09:14:16 <Cheshire> fasta mac os
09:14:29 <SamB> well, how do you stop it if you've run out of processes ?
09:14:36 <Cheshire> mac os x
09:14:45 * SamB forgets what happened the last time he ran one
09:14:53 <Cheshire> I could not figure out how to fix this in linux
09:14:56 <fasta> Ferdirand: ah, thanks.
09:15:02 <idnar> SamB: log in as a different user :P
09:15:20 <SamB> idnar: well, that works if you've root ...
09:15:46 <idnar> most shells have kill as a builtin
09:15:53 <idnar> so as long as you can still access a shell somewhere, it should be okay
09:16:16 <Ferdirand> alternatively, if you have a spare shell, use sash or ash (shells with many simple commands as builtins)
09:16:45 <idnar> exec busybox
09:17:44 <fasta> Cheshire: what does mac os x do?
09:17:51 * SamB wonders if starting a new shell is actually prevented
09:18:11 <Cheshire> fasta it goes swampy and slow but you can kill it.. in linux it crashes the computer straight away
09:20:40 <hcube> hi! i'm developing a rendering engine in haskell and i'm wondering where should i place it in module name hierarchy. can you help me? opengl is in Graphics.Rendering.OpenGL glut and glfw is in Graphics.UI.*** My engine's name is Lambda Cube
09:21:13 <hcube> I'd like to name modules in "haskell way"
09:21:41 <Cheshire> why is it called Lambda Cube
09:21:50 <niet> what is a flac-file?
09:22:15 <whpearson> niet: Lossless music, I think
09:22:18 <pejo> niet, it's a music file.
09:22:27 <hcube> I can rename it
09:22:51 <hcube> If you have a good name suggestion please tell me ;)
09:25:17 <quicksilver> hcube: well Graphics.UI is for UI toolkit like things.
09:25:25 <quicksilver> hcube: I'd think Graphics.Rendering or just Graphics.
09:25:43 <quicksilver> hcube: I don't think the haskell hierarchy is particularly well defined ;0
09:26:19 <hcube> what about Lamda Cube as rendering engine's name?
09:26:26 <Cheshire> why
09:26:33 <SamB> idnar: huh, it looks like the process limit is checked at fork time, so if the login program forks before changing users ...
09:27:03 <Cheshire> @go lambda cube
09:27:04 <hcube> Cheshire: just for fun
09:27:04 <lambdabot> http://en.wikipedia.org/wiki/Lambda_cube
09:27:19 <hcube> i know about type systems
09:27:32 <Cheshire> okj :)
09:33:41 <niet> i need to raise to a huge power, ie, 123^13332009, that takes forever so how do I do it?
09:34:35 <niet> hcube: you working on a 3d-engine?
09:35:40 <hcube> yep
09:35:46 <koala_man> niet: I don't suppose it's modulo anything?
09:36:02 <hcube> i'd like to release it soon
09:36:04 <quicksilver> niet: repeated squaring.
09:36:19 <roconnor> niet: you do realize that the number is bigger than all the computer memory in the universe?
09:36:31 <hcube> now i'm writing a yampa based example using my engine
09:36:48 <niet> koala_man: yes mod something
09:37:08 <niet> roconnor: I thought Linux was suppsoed to be better than Windows
09:37:30 <koala_man> niet: that's much easier faster
09:37:56 <niet> what is? repeated squaring?
09:38:06 <Cheshire> @xeal
09:38:06 <lambdabot> better be atleast 16x16 color with extended ascii set
09:38:15 <koala_man> exponents under modulo
09:38:27 <lilac> niet: a ^ (2*b) `mod` n = (a^2)^b `mod` n = (a^2 `mod` n) ^ b `mod` n
09:38:34 <niet> but if the nbr is that big how can i ever calc it? can i make it smaller iwth mod?
09:38:50 <lilac> niet: a ^ (2*b+1) `mod` n = (a^2)^b * a `mod` n = ((a^2 `mod` n) ^ b `mod` n) * a `mod` n
09:39:07 <lilac> divide. conquer.
09:40:28 <quicksilver> niet: "I thought Linux was supposed to be better than Windows"? is that some failed attempt at trolling?
09:40:53 <quicksilver> niet: the haskell programming lanuage is plenty interesting enough, let's stick that topic
09:41:13 <lilac> > (123 :: Expr) ^^ 13332009
09:41:17 <lambdabot>   123 * 123 * (123 * 123) * (123 * 123 * (123 * 123)) * (123 * 123 * (123 * 1...
09:41:27 <lilac> with the right Num instance, this could be quite elegant...
09:42:16 <lilac> newtype BaseN = BaseN { inBase :: Int -> Int }; instance Num BaseN where...
09:42:29 <niet> quicksilver: failed attempt at joking
09:42:49 <lilac> then, (123^^13332009) `inBase` 42
09:43:23 <ErhardtMundt> hi
09:43:33 <ErhardtMundt> BONUS, are you there?
09:44:02 <roconnor> lilac: think that would work?
09:44:17 <ErhardtMundt> BONUS, i have something to talk you about
09:44:36 <roconnor> lilac: that is much nicer that the obvious dependently typed solution
09:44:46 <lilac> roconnor: i'm working on it right now...
09:44:56 <roconnor> Int -> Integer
09:45:05 <roconnor> or maybe Integer -> Integer would be better
09:45:15 <roconnor> lilac: put it on hackage :P
09:45:23 <bremner> @src lcm
09:45:23 <lambdabot> lcm _ 0     =  0
09:45:23 <lambdabot> lcm 0 _     =  0
09:45:23 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
09:46:11 <Alpounet> @src quot
09:46:11 <lambdabot> Source not found. You type like i drive.
09:49:13 <lilac> roconnor: it doesn't have sufficient sharing to be maximally efficient, but it does do all the `mod`s at the right time
09:49:18 <temoto> How to count how many times each char is in text?
09:49:33 <lilac> niet: btw the answer is 15
09:49:58 <temoto> And what is wrong with this: let cnt1 s c = length $ filter (c `elem`) s   ?
09:51:06 <lilac> roconnor, niet: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1797#a1797
09:51:41 <lilac> with Expr-like tricks, it should be possible to do CSE too
09:52:25 <temoto> cnt1 s c = length $ filter (c `elem`) s
09:52:29 <temoto> > cnt1 s c = length $ filter (c `elem`) s
09:52:30 <lambdabot>   <no location info>: parse error on input `='
09:52:36 <temoto> > let cnt1 s c = length $ filter (c `elem`) s
09:52:36 <lambdabot>   <no location info>: parse error on input `;'
09:53:05 <Cheshire> how do you reduce the gap between specification and implementation in haskell?
09:53:24 <roconnor> lilac: hah, Eq instance
09:53:24 <temoto> > let cnt1 s c = length $ filter (c `elem`) s in cnt1 "sesdess" 's'
09:53:25 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
09:53:28 <Cheshire> especially in tree transform...
09:53:41 <temoto> Yes! Exactly this error i get. Why couldn't match?
09:53:51 <Saizan> ?type elem
09:53:52 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:53:53 <rmoss> i'm trying to write a tokenizer that strips leading/trailing punctuation but includes essential non-alpha characters such as hyphens or apostrophes.  I'm concerned however that my approach is a bit long winded http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1798#a1798 any ideas?
09:53:55 <pejo> Cheshire, compared to what, specification and implementation in C?
09:53:56 <lilac> roconnor: yeah, that kinda sucks; i'd rather do Eq by working out the result via Integer
09:54:01 <Cheshire> lol
09:54:08 <Saizan> temoto: elem checks if a value is an element of a list
09:54:16 <lilac> Cheshire: use haskell as a specification language?
09:54:24 <Cheshire> I mean what I scribble on paper vs. what it takes to explain to haskell what I meant
09:54:30 <temoto> Saizan: i know. Then string is a list of chars, isn't it?
09:54:33 <Saizan> temoto: but you want a function that compares your element to another in the list for filter
09:54:45 <temoto> omg
09:54:48 <lilac> Cheshire: you mean they're not /the same/? ;-)
09:54:51 <pejo> Cheshire, scribble more formally.
09:54:51 <Saizan> > length $ filter ('c' ==) "abcabc"
09:54:52 <lambdabot>   2
09:54:53 <temoto> i'm so stupid
09:55:00 <whpearson> I'm checking an expensive property of two strings, that is easily shown to be false if they are different lengths, is it worth doing the length check first, or is there something clever I could do?
09:55:10 <Cheshire> serious question..
09:55:14 <temoto> Saizan: thank you.
09:55:33 <temoto> How to count how many times *each* char is in text?
09:55:40 <lilac> Cheshire: how big is the gap? can you give us an example of specification and corresponding program?
09:56:26 <Saizan> > map (\xs -> (head xs, length xs)) . group . sort $ "mississipi"
09:56:27 <lambdabot>   [('i',4),('m',1),('p',1),('s',4)]
09:57:00 <temoto> uh..
09:57:04 <Cheshire> hbm
09:58:00 <temoto> Saizan: i'm confused with dollar before string
09:58:33 <Elly> temoto: $ means "apply"
09:58:37 <Saizan> temoto: f $ x = f x
09:58:38 <lilac> > (head &&& length) <$> group (sort "mississippi")
09:58:39 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
09:58:42 <Elly> so you can read that, if you want, as (sort "mississippi")
09:58:52 <Saizan> not really
09:59:06 <temoto> Elly: yeah well i understand that and that's why i'm confused :)
09:59:09 <Saizan>  map (\xs -> (head xs, length xs)) . group . sort $ "mississipi" == (map (\xs -> (head xs, length xs)) . group . sort) "mississipi"
09:59:37 <temoto> why map in parenthesis?
09:59:46 <niet> how can I letrec in hasekll? ie recursively call a lambda?
09:59:47 <temoto> shouldn't it get 2 arguments?
10:00:08 <temoto> like filter in previous function
10:00:09 <pejo> niet, 'let' is recursive.
10:00:12 <Saizan> temoto: f . g . h $ x == f (g (h x))
10:00:23 <Saizan> @src (.)
10:00:23 <lambdabot> (f . g) x = f (g x)
10:00:33 <lilac> foo . group . sort $ "mississippi" == (foo.group.sort)("mississippi") == (\x -> (foo.group) (sort x)) "mississippi" == (foo.group) (sort "mississippi")
10:00:50 <temoto> AHA
10:00:54 <lilac> == (\x -> foo (group x)) (sort "mississippi") == foo (group (sort "mississippi"))
10:01:43 <temoto> so parenthesis to make foo compose with group and not apply (sort "misi") to 'group' only
10:02:02 <temoto> and then.. i got it, thanks
10:02:11 <lilac> \o/
10:02:22 <Saizan> it's group that's applied to the result of (sort "missisipi")
10:02:45 <temoto> yeah well wouldn't it be better like
10:03:20 <lilac> map (\xs -> (head xs, length xs)) . group . sort $ "mississipi" == map (\xs -> (head xs, length xs)) . group $ sort "mississipi"
10:03:26 <temoto> > map ((\xs -> (head xs, length xs)) . group . sort) "missisipi"
10:03:27 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
10:03:37 <temoto> damn
10:03:42 <Saizan> temoto: that's different, and incorrect
10:03:43 <lilac> temoto: you need the 'map' inside brackets too
10:03:57 <lilac> (foo is "map (\xs -> ...)")
10:04:12 <Saizan> only (\xs -> (head xs, length xs)) is the function passed to map as its first argument
10:04:23 <lilac> > (map (\xs -> (head xs, length xs)) . group . sort) "mississippi"
10:04:24 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
10:04:24 <temoto> that's because i don't understand what's between map and string
10:04:51 <whpearson> > sort mississippi
10:04:52 <lambdabot>   Not in scope: `mississippi'
10:04:56 <whpearson> > sort "mississippi"
10:04:58 <lambdabot>   "iiiimppssss"
10:05:08 <whpearson> > group. sort $ "mississippi"
10:05:09 <lilac> > let (~>) = flip ($) in "mississippi" ~> sort ~> group ~> map (head &&& length)
10:05:10 <lambdabot>   ["iiii","m","pp","ssss"]
10:05:10 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
10:05:19 <temoto> aha
10:05:52 <rmoss>  i'm trying to write a tokenizer that strips leading/trailing punctuation but includes essential non-alpha characters such as hyphens or apostrophes.  I'm concerned however that my approach is a bit long winded http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1798#a1798 any ideas?
10:05:56 <temoto> then i don't understand '.' between lambda and group
10:06:19 <whpearson> > map (head) . group. sort $ "mississippi"
10:06:20 <lambdabot>   "imps"
10:06:20 <Gracenotes> > let (.) = flip ($) in "mississippi".sort.group.map(head &&& length) -- even more devious >_>
10:06:22 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
10:06:38 <Saizan> temoto: map (\x -> ...) . group is parsed as (map (\x -> ..)) . group
10:06:39 <lilac> > let (~>) = flip ($); (~>>) = flip (<$>) in "mississippi" ~> sort ~> group ~>> (head &&& length)
10:06:41 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
10:06:54 <temoto> aah
10:07:15 <Saizan> temoto: function application always takes precedence over operators
10:07:24 <temoto> well... shouldn't it better then as
10:07:40 <temoto> > map (\xs -> (head xs, length xs) (group . sort "missisipi")
10:07:41 <lambdabot>   <no location info>: parse error on input `;'
10:07:54 <temoto> nono i'l do it
10:07:58 <temoto> > map (\xs -> (head xs, length xs) (group . sort $ "missisipi")
10:07:59 <lambdabot>   <no location info>: parse error on input `;'
10:08:03 <temoto> doh
10:08:06 <Saizan> forgot a paren
10:08:11 <temoto> oh
10:08:15 <temoto> > map (\xs -> (head xs, length xs)) (group . sort $ "missisipi")
10:08:16 <lambdabot>   [('i',4),('m',1),('p',1),('s',3)]
10:08:21 <temoto> whooray!
10:08:31 <temoto> That's how i understand it.
10:08:40 <temoto> map. two arguments. :)
10:08:55 <lilac> temoto: or...
10:09:03 <temoto> Is this considered ugly in haskell world?
10:09:03 <Saizan> heh, but in haskell two-argument functions are really 1-argument ones that return a function :)
10:09:07 <lilac> > map (\xs -> (head xs, length xs)) (group (sort "mississippi"))
10:09:08 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
10:09:22 <lilac> temoto: yes, there's a tendency to use . and $ instead of lots of parens
10:09:27 <temoto> lilac: yeah but i like . and $ where i understand them
10:09:40 <grn> Where can I learn more about Maybe? Real world Haskell book isn't too clear on that topic.
10:09:48 <lilac> grn: here? :)
10:09:52 <temoto> Saizan: yeah i learned that, but i don't feel it yet.
10:10:19 <lilac> grn: what do you want to know about it?
10:10:24 <grn> lilac, oh, I thought of a web site ;-)
10:10:36 <whpearson> I think like temoto at the moment, but I can see the confusion potential. I think building a better type sense is important.
10:10:37 <Saizan> temoto: i see, but it's very nice once you're familiar with it :) so don't give up!
10:10:55 <temoto> grn: anything maybe-ish is like a usual python object. It's either Just that type value or Nothing (None)
10:11:51 <whpearson> @type  map (\xs -> (head xs, length xs)) . group . sort
10:11:52 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
10:12:07 <Saizan> grn: what are your doubts?
10:12:37 <whpearson> @type  map (\xs -> (head xs, length xs)) .
10:12:38 <lambdabot> parse error (possibly incorrect indentation)
10:12:42 <whpearson> @type  map (\xs -> (head xs, length xs)) . group
10:12:43 <lambdabot> forall a. (Eq a) => [a] -> [(a, Int)]
10:13:06 <grn> So if I have: data Maybe a = Just a | Nothing, then by writing: Just "abc" I construct an object of type String and by writing: Just 123 I get an integer?
10:13:36 <omnihil> @type Just 123
10:13:37 <lambdabot> forall t. (Num t) => Maybe t
10:14:21 <Saizan> grn: Maybe String and Maybe Integer, respectively
10:14:26 <CTA> Heyy =D
10:15:05 <lilac> grn: 'Just' is (amongst other things) a function from type a to type Maybe a
10:15:07 <grn> So Maybe String stands for all the strings and Nothing?
10:15:10 <temoto> whpearson: yeah i finally understood it. map (\xs -> (head xs, length xs)) . group . sort  is a function to calculate that kind of statistics on strings.
10:15:26 <CTA> is there a way to have a recurring decimal in Haskell?
10:15:32 <lilac> grn: yes. the type Maybe String is inhabited by values Just s (for all s in String), plus Nothing (plus _|_)
10:15:47 <quicksilver> CTA: slightly strangely worded question.
10:16:04 <quicksilver> CTA: the type 'Double', for example, is a fixed precision floating point format.
10:16:14 <lilac> CTA: every recursive decimal is a fraction, so Fraction ?
10:16:19 <lilac> @type 3 % 4
10:16:20 <lambdabot> forall t. (Integral t) => Ratio t
10:16:23 <grn> Ok, it's clear. Thanks!
10:16:32 <lilac> ok, Ratio Integer
10:16:32 <CTA> well today in math
10:16:36 <quicksilver> CTA: but if you jsut want to represent a fraction precisely, then use Rational.
10:16:39 <lilac> s/recursive/recurring/
10:16:50 <CTA> we've been doing using algebra to convert decimal to fracting
10:17:02 <quicksilver> CTA: on the other hand, you could model recurring decimals explicitly if ou chose to.
10:17:03 <lilac> quicksilver: Rational == Ratio Integer?
10:17:08 <quicksilver> lilac: yes.
10:17:16 <roconnor> @src Rational
10:17:17 <lambdabot> type Rational = Ratio Integer
10:17:20 * lilac needs a faster \b
10:17:26 <temoto> Why my ghci says '3%4' % not in scope?
10:17:34 <lilac> @index Ratio
10:17:34 <lambdabot> Data.Ratio
10:17:39 <lilac> temoto: import Data.Ratio
10:17:40 <quicksilver> temoto: :m Data.Ratio
10:17:49 <CTA> (like so http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1799#a1799 )
10:18:01 <lilac> :m +Data.Ratio is safer
10:18:03 <grn> I must admit that Haskell is a very elegant language.
10:18:04 <quicksilver> CTA: you could for example do data RecurringDecimal = [Digit] [Digit] [Digit]
10:18:16 <temoto> oh well it prints 3%4 then
10:18:24 <quicksilver> CTA: where the first list of digits is before the decimal point, the second is after, and the third is the recurring fragment.
10:18:30 <quicksilver> it's unlikely anyone would want to though.
10:18:31 <temoto> ok, but why does it print 2%4 ? Why not 0.5?
10:18:44 <quicksilver> the expression as a rational is better in most respects.
10:18:48 <omnihil> @type 2%4
10:18:49 <lambdabot> forall t. (Integral t) => Ratio t
10:18:51 <omnihil> @type 0.5
10:18:52 <lambdabot> forall t. (Fractional t) => t
10:18:54 <quicksilver> recurring decimals are ambiguous and hard to work with.
10:19:09 <quicksilver> temoto: that's just the way 'show' for Rational has chosen to display it.
10:19:16 <quicksilver> temoto: if it used decimal notation it would lose precision.
10:19:34 <CTA> It was just a question, the example i shown is a basic one of A-A* questions in GCSE and I really like them and aren't that bad at that either =)
10:19:35 <quicksilver> - you wouldn't want to 'show' 1%3 and then lose your accuracy.
10:19:48 <temoto> quicksilver: how to make float out of Ratio?
10:20:11 <lilac> CTA: if you have k =(decimal) xxxx.yyyyy<zzzz><zzzz><zzzz>... then 10^n k = xxxxyyyyy.<zzzz><zzzz>... and 10^(n+m) k = xxxxyyyyy<zzzz>.<zzzz>...
10:20:42 <quicksilver> temoto: realToFrac
10:20:48 <lilac> CTA: therefore, (10^(n+m) - 10^n) k = xxxxyyyyy<zzzz> - xxxxyyyyy
10:20:49 <quicksilver> > realToFrac (1%3) :: Float
10:20:51 <lambdabot>   0.33333334
10:21:17 <lilac> CTA: so k = (xxxxyyyyy<zzzz> - xxxxyyyyy) / (10^(n+m) - 10^n), as a fraction
10:21:56 <lilac> (where n = length ys; m = length zs)
10:22:14 <Alpounet> what is the simplest way to print a list to console in Haskell ?
10:22:27 <lilac> Alpounet: from ghci, just mention its name at the prompt
10:22:32 <tromp_> print list
10:22:33 <temoto> thanks
10:22:50 <Alpounet> lilac, yep, but outside ghci ?
10:23:26 <Alpounet> isn't there something like iter in the List module ?
10:23:29 <lilac> Alpounet: what tromp_ said :)
10:23:37 <Alpounet> oh
10:23:38 <lilac> @type print
10:23:38 <Alpounet> ok
10:23:39 <lambdabot> forall a. (Show a) => a -> IO ()
10:23:42 <Alpounet> :p
10:23:54 <tromp_> iterate
10:24:13 <lilac> Alpounet: foldl, foldr and map are something like iter
10:24:19 <lilac> but inside-out in some sense
10:24:35 <Alpounet> I know, was just looking for the shortest solution (for writing)
10:25:07 <zachk> > let f=foldr (+) 0 [1..100] in f
10:25:09 <lambdabot>   5050
10:25:30 <zachk> > let f=foldr (+) 0 [1..1000000] in f
10:25:32 <lambdabot>   * Exception: stack overflow
10:25:36 <Gracenotes> :O
10:26:10 <quicksilver> Alpounet: well the key point is that lists already have a Show instance
10:26:13 <rmoss>  i'm trying to write a tokenizer that strips leading/trailing punctuation but includes essential non-alpha characters such as hyphens or apostrophes.  I'm concerned however that my approach is a bit long winded http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1798#a1798 any ideas?
10:26:14 <quicksilver> so they know how to print themselves.
10:26:34 <quicksilver> Alpounet: if you had to write it for yourself, you'd use something based on foldr to write it.
10:26:38 <Alpounet> okay... thank to type classes and instanciating of this typeclass for List ?
10:26:44 <quicksilver> yes.
10:26:50 <Alpounet> Okay, thanks.
10:26:50 <quicksilver> > show [1,2,3]
10:26:51 <lambdabot>   "[1,2,3]"
10:26:59 <zachk> let f n a=if n==0 then a else f (n+1) (n+a)
10:27:05 <zachk> let f n a=if n==0 then a else f (n+1) (n+a) in f
10:27:13 <zachk> let f n a=if n==0 then a else f (n+1) (n+a) in f 1 1000000
10:27:24 <zachk> > let f n a=if n==0 then a else f (n+1) (n+a) in f 1 1000000
10:27:45 <lambdabot>   thread killed
10:27:46 <Cheshire> rmoss, yes
10:27:47 <Gracenotes> .-.
10:27:53 <zachk> oh my
10:27:55 <Cheshire> lexer []     c      = []
10:27:55 <Cheshire> lexer (a:x)  c      | isLetter a                           = makeWord [a] x  c
10:27:55 <Cheshire>                     | otherwise                            = lexer x c
10:27:59 <mercury^> zachk: What are you doing? :<
10:28:11 <mercury^> You have to start with negative numbers for that to work.
10:28:26 <Cheshire> rmoss, you could  dropWhile (not . isLetter)
10:28:28 <lilac> quicksilver: writing show for [] with foldr is hard :) much easier to do it recursively...
10:28:28 <mercury^> But there is a very simple closed form for that anyway.
10:28:56 <quicksilver> lilac: "something like" foldr ;)
10:29:06 <lilac> quicksilver:  :)
10:29:24 <lilac> although i'm now wondering what the shortest way to write show for [] with foldr /is/ :)
10:30:59 <rmoss> Cheshire: would I not then have a problem keeping the non-alpha character that I do want?
10:31:33 <quicksilver> > "[" ++ init (foldr (\a s -> show a ++ "," ++ s) "" [1,2,3]) ++ "]"
10:31:34 <lambdabot>   "[1,2,3]"
10:31:37 <quicksilver> lilac: something like that.
10:32:08 <witkamp> any one have some time for some stupid noob questions
10:32:18 <witkamp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1800#a1801
10:32:24 <lilac> quicksilver: isn't that too strict at the end of the list?
10:33:30 <lilac> quicksilver: no, it's fine, ignore me :)
10:33:44 <Alpounet> @src init
10:33:44 <lambdabot> init [x]    = []
10:33:44 <lambdabot> init (x:xs) = x : init xs
10:33:44 <lambdabot> init []     = undefined
10:34:14 <quicksilver> witkamp: what's the quesiton?
10:34:30 <witkamp> i am getting at type inference problem
10:35:00 <witkamp> I would like the list to have type (Show a) => [Elf -> a]
10:35:08 <quicksilver> no you wouldn't ;)
10:35:14 <quicksilver> you think you would, but actually that's wrong.
10:35:19 <witkamp> hmm
10:35:22 <quicksilver> that would allow the caller to choose any type "a"
10:35:28 <witkamp> how so
10:35:30 <quicksilver> as long as it satisfied show.
10:35:32 <witkamp> learn me good
10:35:39 <quicksilver> because that's what that type means.
10:35:59 <quicksilver> it means "for all types a that you choose, this has the type [Elf -> a], as long as the type is a member of class Show"
10:36:05 <lilac> witkamp: if you give me hmembers :: (Show a) => [Elf -> a], then i can do: head hmembers myelf :: Int
10:36:33 <quicksilver> to do what you are trying to do you'd need an existential
10:36:40 <lilac> witkamp: Show a => [Elf -> a] means forall a. Show a => [Elf -> a]
10:36:50 <lilac> witkamp: you want exists a. Show a => [Elf -> a]
10:36:51 <quicksilver> but it would be fairly useless - since the only thing you can with an arbitrary Show is show it, you might as well do that first
10:37:00 <quicksilver> and just use the type [Elf -> String]
10:38:04 <witkamp> So i understand i can use [Elf ->String]
10:38:23 <witkamp> thinking. thanks
10:40:48 <lilac> witkamp: the key thing to remember is, if you give someone something of type "forall a. f a" then /they/ get to choose a, and what you give them must work for any such value.
10:40:58 <niet> does anyone have all of ghc in their head?
10:41:13 <niet> what is the hit-by-a-bus-factor of haskell?
10:41:26 <witkamp> I understand that part of the contraint
10:41:51 <witkamp> however I don't get why I  can't make a list with that constraint
10:42:40 <pejo> niet, if some key figures quit it is likely that development on ghc would slow down. On the other hand: why would that happen now and not in the past 15 years?
10:42:54 <sw17ch> > [1,"hi"] :: (Show a) => [a]
10:42:55 <lambdabot>   Couldn't match expected type `a' against inferred type `[Char]'
10:43:23 <hackage> Uploaded to hackage: test-framework-quickcheck2 0.2.1
10:43:23 <hackage> Uploaded to hackage: test-framework-quickcheck 0.2.1
10:43:23 <hackage> Uploaded to hackage: test-framework-hunit 0.2.1
10:43:23 <hackage> Uploaded to hackage: test-framework 0.2.1
10:44:21 <witkamp> i like sw17ch example
10:44:29 <niet> pejo: im planning to take it and have it only for myself so you just wondering who I have tot ake out
10:44:39 <witkamp> why doesn't that work?
10:45:11 <pejo> niet, ghc is free, you can't prevent people from forking it.
10:45:28 <lilac> witkamp: because 1 is not :: Show a => a
10:45:50 <lilac> witkamp: for instance, there's a Show instance for Bool
10:45:55 <niet> pejo: ill just shoot github+spj+dons+you then, you set an example
10:45:59 <lilac> witkamp: but [1, "hi"] is not of type [Bool]
10:46:12 <lilac> witkamp: so it's not of type "forall a. Show a => [a]"
10:46:57 <niet> i used to think how monads and such was a hack around the mathematical prison of haskell but now I just realize it was my mind that was imprisoned in the land of OO. After doing some halfadvanced GUIs like an mp3player etc in other languages i see how having all the state/sideeffects in one place plus the awesome patternmatching would make it very easy to ensure all execution-paths are correct.
10:47:31 <lilac> niet: explicit monads like haskell has are not a hack. /implicit/ monads like other languages have are hacks
10:47:40 <lilac> :)
10:48:04 <lilac> (to be honest, i think having partiality in haskell rather than as a monad is a bit nasty)
10:49:36 <Shurique> what's the easiest way to send simple text-only HTTP POST requests?
10:50:26 <Alpounet> lilac, where do you see Monads in e.g C++ or Java ?
10:50:42 <Alpounet> I don't get it, can you explain your point ?
10:53:32 <mathijs> Hi all, I think I reached a basic level of haskell knowledge, but I need to adapt to fp and data structures in general. I read some good stuff about the book 'Structure and interpretation of computer programs', so I want to buy it. Is this a good choice? (not outdated a bit?) I'm affraid that since it's not haskell-oriented it might confuse me?
10:54:30 <niet> mathijs: sicp is availaboe for free on the internets
10:55:45 <mathijs> niet: I know, but I prefer paper books. Of course I can look at it online and see of it fits me, but I was wondering of any others can comment on it from a haskell perspective.
10:56:52 <niet> http://mitpress.mit.edu/sicp/full-text/book/book.html
10:56:57 <Botje> mathijs: a lot of the book is spent on program structure and algorithm design
10:57:11 <yohan> Does haskell have closures?
10:57:25 <yohan> or is everything undefined
10:57:31 <Botje> yohan: yes, it does.
10:57:34 <niet> it is about scheme which is one of the most functional languages except for haskell and it ia very good book about programming in general, defineately worth it anyhow
10:57:35 <mathijs> Botje: so it won't distract me from learning haskell?
10:58:09 <pejo> mathijs, there are probably better books for learning haskell specifically.
10:58:13 <yohan> Botje, really? Can you explain it?
10:58:16 <niet> it is more about programming than a specific language
10:58:21 <mathijs> niet: cool, and I guess scheme is not that different to haskell at the level described in the book?
10:58:50 <lament> mathijs: extremely different.
10:59:04 <Botje> mathijs: you can skim the really scheme-specific things, but it's a pretty good book.
10:59:08 <lament> they're basically nothing at all alike, at the level described in SICP.
10:59:16 <Botje> esp. the interpretation part is cool
10:59:25 <Botje> yohan: don't really have time for thtat atm:)
10:59:30 <niet> well most of the algorithms are pretty straightforward to translate since both languages use recursion only
10:59:32 <lament> SICP is all about code-data equivalence and lisp-specific implementation of data structures
10:59:39 <yohan> what's atm? ass to mouth?
10:59:48 <niet> at the moment?
10:59:50 <yohan> ah
10:59:52 <yohan> sorry
10:59:57 <mathijs> pejo: I read/worked through RWH and did some small hobby programs with haskell. I'm quite comfortable with it, so I don't need a haskell book, just something that fits the design and teaches me FP techniques. Need to unlearn my OOP skills :)
11:00:05 * Badger doesn't have time for this ass to mouth!
11:00:31 <yohan> Can anybody explain haskell?
11:00:43 <Badger> yes
11:00:43 <yohan> I heard its like python
11:00:47 <Badger> @faq anything
11:00:47 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:00 <yohan> How can he do that?
11:01:12 <Alpounet> yohan, it's very different of Python
11:01:17 <kerlo> @faq Can Haskell exceed the speed of light?
11:01:17 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:19 <yohan> Alpounet: how so?
11:01:25 <mathijs> lament: so you're saying it might confuse me and will teach me stuff I can't (or shouldn't) apply to haskell?
11:01:26 <Alpounet> Python is dynamically typed
11:01:26 <roconnor> Haskell is like ML, sort of
11:01:28 <kerlo> yohan: anyway, would you like a Haskell tutorial?
11:01:34 <Alpounet> python is quite Object Oriented
11:01:38 <Badger> @faw can Haskell create and destroy energy?
11:01:38 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:45 <Badger> hm
11:01:47 <skorpan> Badger: what the
11:01:49 <skorpan> !!!
11:01:50 <Badger> it even accepted my typo!
11:01:50 <niet> yohan: lazy, pure functional programming. dividing programs into sideeffectfree and effectful parts to isolate errors and improve debugging and correctness(make less mistakes int he first place, fidn the ones you do faster). program for multiple cores easily.
11:01:53 <yohan> I'm not very good at tutorials
11:01:58 <Badger> lambdabot is truly an AI
11:02:03 <lament> mathijs: SICP is a very good textbook that I (and many others) believe everybody should read. But it has nothing to do with Haskell or Haskell style of functional programming.
11:02:04 <yohan> lazy language?
11:02:12 <yohan> like ppl from the south?
11:02:18 <Alpounet> yohan > so read a book
11:02:33 <yohan> ah
11:02:36 <niet> > take 10 [1..]
11:02:36 <yohan> Yeah k
11:02:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:02:43 <niet> yohan ^^
11:02:48 <m0nkfish> i wouldnt say it has NOTHING to do with haskell
11:02:48 <yohan> Cool
11:02:51 <niet> yohan == johan? swedish?
11:03:00 <yohan> niet: yeah
11:03:04 <yohan> I'm from swed
11:03:16 <niet> where? age?
11:03:17 <yohan> But this haskell, can I connect it to C?
11:03:25 <niet> it is popular at chalmers
11:03:28 <lament> m0nkfish: mathijs has read RWH so he already knows whatever basics of general FP that SICP can teach that would apply to Haskell. Everything else in SICP is quite Scheme-specific.
11:03:37 <niet> yohan: yes via FFI(foreign function interface)
11:03:49 <yohan> cool
11:03:54 <kerlo> @help faq
11:03:54 <lambdabot> faq. Answer frequently asked questions about Haskell
11:03:55 <yohan> niet: a/s/l?
11:04:11 <lament> mathijs: But you should read SICP anyway, because it's very important stuff!
11:04:12 <niet> asl? sweden 16, skåne
11:04:29 <yohan> Im writing my master thesis about why imperative programming languages are fast
11:04:39 <niet> which uni?
11:04:44 <yohan> Chalmers
11:04:54 <niet> didnt you study haskell then?
11:04:55 <lament> yohan: interesting topic
11:04:59 <yohan> niet: cool stuff
11:05:01 <lament> yohan: Do you like chalmers?
11:05:10 <pejo> yohan, and what are your conclusions?
11:05:15 <yohan> lament: yeah its a cool school
11:05:32 <yohan> I conluded that C is the fastest language
11:05:46 <mathijs> yohan: no ASM?
11:06:08 <kerlo> I think I prefer C--. Not sure, though.
11:06:08 <yohan> ASM? Ass to mouth?
11:06:20 <yohan> Havn't seem that one
11:06:28 <kerlo> Assembly language.
11:06:29 <mathijs> assembly
11:06:39 <yohan> what's that?
11:06:46 <mathijs> faster than c :)
11:06:48 <kerlo> I think it's essentially machine code with some syntactic sugar.
11:07:05 <yohan> So why not code assembly?
11:07:22 <mathijs> because execution speed isn't a key factor anymore
11:07:42 <Cheshire> yohan do you actually not know what happens when you compile a .c file?
11:07:49 <yohan> My friend tried sorting 100 million integers in haskell, but it didnt work...but it C it did
11:07:49 <mathijs> development speeds, lack of errors, abstractions, modularity are far more important
11:07:58 <Alpounet> and because humain beings can't write huge programs in Assembly
11:08:09 <mathijs> yohan: your friend did it the wrong way :)
11:08:13 <niet> yohan: did you study CS? you seem to have not much clue for soeone writing a masters
11:08:15 <yohan> hold on
11:08:15 <Alpounet> and assembly is not portable
11:08:17 <yohan> I have the code here
11:08:28 <Cheshire> Alpounet, nnobody should read or write huge programs..
11:08:31 <mathijs> Alpounet: to emulators :)
11:08:35 <yohan> is it ok if I post two lines here?
11:08:40 <mathijs> ok
11:08:49 <yohan> s = sort [0..100000000]
11:08:55 <yohan> I think it looks pretty simple
11:08:58 <yohan> but it didnt work
11:09:02 <yohan> how do I write it in the right way?
11:09:07 <Cheshire> > sort [0..100000000]
11:09:19 <lambdabot>   mueval: Prelude.read: no parse
11:09:23 <yohan> thats what i wrote.
11:09:24 <Cheshire> , sort [0..100000000]
11:09:26 <lunabot>  luna: Not in scope: `sort'
11:09:28 <Bmeph_|work> @tell centrinia Do you know if Prof. Moore wrote a "Part II"?
11:09:28 <lambdabot> Consider it noted.
11:09:34 <augustss> Haskell doesn't have a good library sort function, like C does.
11:09:35 <Cheshire> > sortBy (<) [0..100000000]
11:09:37 <lambdabot>   Couldn't match expected type `Ordering'
11:09:44 <Cheshire> > sortBy compare [0..100000000]
11:09:54 <lambdabot>   mueval: Prelude.read: no parse
11:10:01 <Cheshire> why does it not parse?
11:10:03 <Cheshire> > sort [0..100000000]
11:10:06 <Cheshire> > sort [0..10]
11:10:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
11:10:15 <lambdabot>   mueval: Prelude.read: no parse
11:10:16 <yohan> So you can't sort 100000000 integers in haskell?
11:10:25 <mathijs> yohan: off course you can
11:10:27 <Cheshire> > sort ([0..100000000]::[Integer])
11:10:27 <augustss> Cheshire: it does parse, it's just the bot's very bad error message
11:10:32 <Bmeph_|work> Why is it that all the slow people say that speed doesn't matter, and all the small people say that size doesn't matter? ;p
11:10:35 <roconnor> http://www.dpmms.cam.ac.uk/~cm434/mathmololcats/
11:10:38 <yohan> but it didnt work, it just exited
11:10:45 <mathijs> yohan: the default 'sort' function is just not optimized for sorting huge lists
11:10:45 <Cheshire> > sort ([0..100]::[Integer])
11:10:52 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:10:54 <Cheshire> > sort [0..1000]
11:10:55 <kerlo> Well, it didn't work with lambdabot for some unknown reason.
11:10:55 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:10:57 <Cheshire> > sort [0..10000]
11:10:58 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:11:00 <Cheshire> > sort [0..100000]
11:11:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:11:03 <Cheshire> > sort [0..1000000]
11:11:05 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:11:07 <niet> > last $ sort ([0..100]::[Integer])
11:11:08 <yohan> hehe
11:11:08 <lambdabot>   100
11:11:08 <Cheshire> > sort [0..10000000]
11:11:11 <yohan> its gonna die
11:11:18 <lambdabot>   mueval: Prelude.read: no parse
11:11:18 <niet> > last $ sort ([0..100000000]::[Integer])
11:11:19 <Cheshire> why ?
11:11:22 <niet> > last $ sort ([0..100000000]::[Integer])
11:11:31 <lambdabot>   mueval: Prelude.read: no parse
11:11:42 <lambdabot>   mueval: Prelude.read: no parse
11:11:45 <augustss> Because it's not a very good sort function.
11:11:45 <roconnor> isn't getting the head of a sort relatively cheap?
11:11:48 <Gracenotes> it's gon' be deayd
11:11:55 <Gracenotes> it's a merge sort of sorts
11:12:02 <mathijs> roconnor: nope, sort needs to work through the whole list
11:12:03 <Cheshire> roconnor, that's why I expect it to work -- but it doesn't
11:12:05 <yohan> oh
11:12:11 <kerlo> yohan: anyway, what sorting algorithm did you use in C?
11:12:11 <Cheshire> @src sort
11:12:11 <lambdabot> sort = sortBy compare
11:12:15 <Cheshire> @src sortBy
11:12:16 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:12:16 <roconnor> mathijs: but it is O(n) right?
11:12:18 <yohan> quicksort
11:12:19 <Cheshire> @src insertBy
11:12:19 <lambdabot> insertBy _   x [] = [x]
11:12:19 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
11:12:19 <lambdabot>                                  GT -> y : insertBy cmp x ys'
11:12:19 <lambdabot>                                  _  -> x : ys
11:12:20 <yohan> in-place
11:12:22 <Gracenotes> - @src isn't the actual thing
11:12:25 <Gracenotes> that's just insertion sort
11:12:41 <augustss> That one might actually work :)
11:12:52 <Gracenotes> you can check out the source in Data.List. It does rely on some primitive-fu, iirc
11:12:53 <mathijs> roconnor: never checked, I believe it to be O(n) yes
11:13:01 <Cheshire> > let insertBy _   x [] = [x] ; insertBy cmp x ys@(y:ys') = case cmp x y of { GT -> y : insertBy cmp x ys' ;  _  -> x : ys } ; sortBy cmp = foldr (insertBy cmp) [] ; sort = sortBy compare in sort [1..10
11:13:02 <Cheshire> > let insertBy _   x [] = [x] ; insertBy cmp x ys@(y:ys') = case cmp x y of { GT -> y : insertBy cmp x ys' ;  _  -> x : ys } ; sortBy cmp = foldr (insertBy cmp) [] ; sort = sortBy compare in sort [1..10]
11:13:05 <lambdabot>   <no location info>: parse error on input `;'
11:13:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:13:15 <Cheshire> > let insertBy _   x [] = [x] ; insertBy cmp x ys@(y:ys') = case cmp x y of { GT -> y : insertBy cmp x ys' ;  _  -> x : ys } ; sortBy cmp = foldr (insertBy cmp) [] ; sort = sortBy compare in sort [1..100000000]
11:13:16 <lambdabot>   * Exception: stack overflow
11:13:20 <Cheshire> weird
11:13:22 <Cheshire> > let insertBy _   x [] = [x] ; insertBy cmp x ys@(y:ys') = case cmp x y of { GT -> y : insertBy cmp x ys' ;  _  -> x : ys } ; sortBy cmp = foldr (insertBy cmp) [] ; sort = sortBy compare in sort [1..10000000]
11:13:23 <lambdabot>   * Exception: stack overflow
11:13:25 <Cheshire> > let insertBy _   x [] = [x] ; insertBy cmp x ys@(y:ys') = case cmp x y of { GT -> y : insertBy cmp x ys' ;  _  -> x : ys } ; sortBy cmp = foldr (insertBy cmp) [] ; sort = sortBy compare in sort [1..1000000]
11:13:27 <lambdabot>   * Exception: stack overflow
11:13:28 <Cheshire> > let insertBy _   x [] = [x] ; insertBy cmp x ys@(y:ys') = case cmp x y of { GT -> y : insertBy cmp x ys' ;  _  -> x : ys } ; sortBy cmp = foldr (insertBy cmp) [] ; sort = sortBy compare in sort [1..100000]
11:13:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:13:34 <ziman> the sort in libs is actually mergesort
11:13:36 <Gracenotes> spam spam spammity spam spam
11:13:41 <Cheshire> why does it overflow though
11:13:46 <Gracenotes> it used to be quicksort, but that proved too slow
11:13:50 <Gracenotes> in teh libs
11:13:51 <ziman> the @src entry doesn't correspond to Data.List.sort, afaik
11:13:59 <mathijs> roconnor: actually, when looking for the smallest number in a list (and doing that a few times), I found it to be faster to turn the list into a Data.Set
11:14:00 <kerlo> Heapsort and in-place merge sort appear to be the best sorting algorithms, according to Wikipedia.
11:14:01 <Gracenotes> yep. It does not.
11:14:09 <yohan> oh
11:14:39 <Gracenotes> depends on the type of input, of course
11:14:39 <yohan> well
11:14:43 <Cheshire> oh I undersand
11:14:46 <yohan> stl sort uses quicksort
11:14:52 <Cheshire> head . sort = min
11:14:54 <yohan> and switches at a particular depth
11:14:57 <Cheshire> so it must check the entire list
11:15:02 <Gracenotes> randomized quicksort is nice. kinda of a pain in Haskell though
11:15:04 <yohan> thats the fastest for the general case
11:15:14 <roconnor> mathijs: is that like sorting by doing Data.Set.toList . Data.Set.fromList  ?
11:15:16 <Gracenotes> quicksort with a partition is a pain in Haskell :) without using arrays
11:15:56 <Gracenotes> by which I mean the famous swapping algorithm :/ anyways, off to class
11:15:58 <roconnor> Gracenotes: I love my sorts to be non-deterministic!
11:16:03 <mathijs> roconnor: toAscList
11:16:10 <Gracenotes> roconnor: with certain result, though ;)
11:16:31 <roconnor> Gracenotes: only when equivlent values are equal :/
11:16:44 <yohan> see you guys
11:16:45 <Gracenotes> yes, true true
11:16:52 <Gracenotes> well, I'll probably be late, argh gb'ye
11:16:56 <byorgey> mathijs: that makes sense, I imagine it builds some sort of lazy tree internally.
11:17:02 <mathijs> roconnor: it does take up a bit more memory than just sorting normally. But for huge lists, it speeds it up quite noticable.
11:17:26 <lilac> libstdc++' std::sort uses introsort
11:17:42 <zachk2> is there a lambdabot in another channel where i can "spam" im not allowed to install ghci here D:
11:17:46 <mathijs> byorgey: red-black balanced tree I believe, but it re-balances only when needed (so lazy yes)
11:17:53 <roconnor> Gracenotes: I half take back my complaint.  You ususally don't care about the order of equivalent elements; although sometimes a stable sort is needed.
11:17:59 <byorgey> zachk2: just pm lambdabot
11:18:05 <zachk2> ty
11:18:57 <kerlo> Is there a function that takes "hello world" and gives ("hlowrd","el ol")?
11:19:03 <Cheshire> lol
11:19:04 <RLa> introsort?
11:19:06 <Cheshire> what
11:19:26 <kerlo> That takes "123456789" and gives ("13579","2468")?
11:19:46 <RLa> odd and even numbers?
11:19:53 <Saizan> odd and even indices
11:19:58 <roconnor> do we have a block or chuncks function yet for lists?
11:20:08 <roconnor> then kerlo's function would be transpose . block 2
11:20:19 <byorgey> roconnor: in Data.List.Split there is
11:20:22 <roconnor> (well, almost be that
11:20:25 <byorgey> transpose . chunk 2
11:20:31 <Saizan> > map snd . partition (odd . fst) . zip [0..] $ "hello world"
11:20:32 <lambdabot>   Couldn't match expected type `[(a, b)]'
11:20:35 <roconnor> does lambdabot have it?
11:21:13 <Cheshire> @let zigZag = cycle [Left, Right]
11:21:14 <lambdabot>  Defined.
11:21:20 <Saizan> > (map snd *** map snd) . partition (odd . fst) . zip [0..] $ "hello world"
11:21:21 <lambdabot>   ("el ol","hlowrd")
11:21:26 <Cheshire> @hoogle [Either a b] -> ([a],[b])
11:21:27 <lambdabot> No results found
11:21:37 <byorgey> ah, partitionEithers
11:21:40 <Cheshire> @let partition :: [Either a b] -> ([a],[b]); partition = partition
11:21:41 <lambdabot>  <local>:10:52:
11:21:41 <lambdabot>      Ambiguous occurrence `partition'
11:21:41 <lambdabot>      It could refer to ...
11:21:45 <Cheshire> :t partition
11:21:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:21:47 <roconnor> @let zagZig = cycle [Right, Left]
11:21:47 <lambdabot>  Defined.
11:21:50 <mathijs> is there a way to get unfoldTree (from Data.Tree) to parallelize? I have a big (infinite) tree structure that I need to traverse. The traversal function is cheap, but the branching-calculation(which happens lazily whenever the traverser needs them) is heavy. So I would like to somehow give parts of the tree to different cores.
11:21:56 <Cheshire> @let partition' :: [Either a b] -> ([a],[b]); partition' = partition'
11:21:57 <lambdabot>  Defined.
11:22:11 <byorgey> I think that's been added to the libraries now, hasn't it?
11:22:12 <Cheshire> :t partition' . zipWith ($) zigZag
11:22:12 <lambdabot> forall a. [a] -> ([a], [a])
11:22:51 <byorgey> > transpose ["ab", "cd", "e"]
11:22:52 <lambdabot>   ["ace","bd"]
11:22:57 <roconnor> > zipWith ($) zagZig "hello world"
11:22:57 <byorgey> ok, that does work
11:22:58 <lambdabot>   [Right 'h',Left 'e',Right 'l',Left 'l',Right 'o',Left ' ',Right 'w',Left 'o...
11:23:08 <roconnor> > partionEithers $ zipWith ($) zagZig "hello world"
11:23:08 <lambdabot>   Not in scope: `partionEithers'
11:23:16 <roconnor> > partitionEithers $ zipWith ($) zagZig "hello world"
11:23:17 <lambdabot>   Not in scope: `partitionEithers'
11:23:26 <Saizan> lambdabot is on 6.8.x
11:23:33 <roconnor> aww
11:23:36 <Cheshire> @let left (Left x) = return x ; left (Right _) = mzero
11:23:37 <lambdabot>  Defined.
11:23:54 <Cheshire> :t (left <=< zipWith ($) zigZag)
11:23:55 <lambdabot>     Ambiguous occurrence `left'
11:23:55 <lambdabot>     It could refer to either `L.left', defined at <local>:12:0
11:23:55 <lambdabot>                           or `Control.Arrow.left', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-33
11:23:58 <Cheshire> omg.........
11:24:08 <Cheshire> I really hate this lambdabot thing
11:24:16 <Saizan> ?type L.left
11:24:17 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m) => Either t t1 -> m t
11:24:21 <Cheshire> it's so blatantly obvious which 'left' I mean
11:24:37 <Saizan> fix GHC then :)
11:24:44 <byorgey> :t (L.left <=< zipWith ($) zigZag)
11:24:45 <lambdabot> forall a. [a] -> [a]
11:24:52 <ski_> > foldr (\x -> uncurry . flip $ (,) . (x:)) ([],[]) "123456789"
11:24:53 <lambdabot>   ("13579","2468")
11:25:04 <Cheshire> :t (L.left <=<) &&& (L.left <=<)
11:25:05 <lambdabot> forall t t1 (m :: * -> *) a. (MonadPlus m) => (a -> m (Either t t1)) -> (a -> m t, a -> m t)
11:25:30 <augustss> @src unlines
11:25:30 <lambdabot> unlines = concatMap (++ "\n")
11:25:43 <kerlo> @help unlet
11:25:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:25:49 <kerlo> @list
11:25:50 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:25:54 <Cheshire> :t (L.left =<<) &&& (L.left =<<)
11:25:55 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m) => m (Either t t1) -> (m t, m t)
11:26:08 <kerlo> @help undefine
11:26:08 <lambdabot> undefine. Reset evaluator local bindings
11:26:09 <ski_> kerlo : how about that above ?
11:26:15 <byorgey> kerlo, now see what you've started ;)
11:26:43 <niet> didnt augusts do quicksort(real quicksort that sorts inplace) in haskell and post to his blog about it?
11:26:51 <roconnor> @let partitionEithers = let {left  a (l, r) = (a:l, r); right a (l, r) = (l, a:r)} in foldr (either left right) ([],[])
11:26:52 <lambdabot>  Defined.
11:26:55 <roconnor> > partitionEithers $ zipWith ($) zagZig "hello world"
11:26:56 <lambdabot>   ("el ol","hlowrd")
11:27:02 <Saizan> niet: he did, with mutable arrays
11:27:03 <roconnor> > partitionEithers $ zipWith ($) zigZag "hello world"
11:27:04 <lambdabot>   ("hlowrd","el ol")
11:27:10 <kerlo> byorgey: I hadn't even noticed. :-P
11:27:18 <ski_> > foldr (\x -> uncurry . flip $ (,) . (x:)) ([],[]) "hello world"
11:27:19 <lambdabot>   ("hlowrd","el ol")
11:27:28 <roconnor> I prefer mine :P
11:27:48 <ski_> @type zigZag
11:27:49 <lambdabot> forall a. [a -> Either a a]
11:28:11 <roconnor> zigZag = cylce [Left,Right]
11:28:30 <kerlo> @freshname
11:28:30 <lambdabot> Ham
11:28:44 <roconnor> aww we passed Hal
11:28:46 <ski_> @freshmeat
11:28:46 <lambdabot> Unknown command, try @list
11:29:31 <trofi> @ud2
11:29:31 <lambdabot> Maybe you meant: id undo url
11:29:39 <Cheshire> @freshmane
11:29:39 <lambdabot> Har
11:29:42 <Cheshire> har
11:29:45 <ski_> Har Har
11:29:50 <ski_> @arr
11:29:50 <lambdabot> Aye Aye Cap'n
11:29:57 <kerlo> @. arr freshname
11:29:57 <lambdabot> Yeh scurvy dog...
11:30:17 <kerlo> @arr Do you pay any attention to your input?
11:30:17 <lambdabot> Aye
11:30:30 <ski_> You fight like a dairy farmer!
11:30:32 <kerlo> @arr Are you lying to me?
11:30:32 <lambdabot> Yeh scurvy dog...
11:30:38 <kerlo> Yes, I think it is.
11:30:49 <Cheshire> @farmer
11:30:49 <lambdabot> I'm casting the dye on the face of the water.
11:31:25 <kerlo> Do all of @freshname's names start with "Ha"?
11:31:35 <ski_> (the appropriate answer is "How appropriate, you fight like a cow!")
11:31:38 <niet> is it possible to fund all hpastes?
11:31:50 <lilac> @@ @vixen @freshname
11:31:50 <lambdabot>  My instant messenger doesn't work.
11:31:54 * Bmeph_|work prefers to cast his dice before swine
11:31:55 <ski_> niet : maybe if you're a millionarie ..
11:31:56 <lilac> niet: you want to donate?
11:32:09 <lilac> niet: hpaste.org has a list
11:32:23 <niet> was that guy really writing a master's thesis(especially at chalmers) you think? he seeemed fairly clueless.
11:32:40 <ski_> (who ?)
11:33:03 <niet> yohan
11:33:04 <lament> ski_: MI ftw
11:33:38 <ski_> lament : This is the END for you, you gutter-crawling cur!
11:34:12 <skorpan> niet: he was trolling, i'm sitting right next to him
11:34:12 <Cale> ã¸ãããï¼
11:34:33 <lament> ski_: and i have a TIP for you! Get the POINT?
11:35:07 <lament> orson card's masterpiece
11:35:11 <ski_> lament : I'm shaking, I'm shaking !
11:35:12 <lament> everything else he wrote is crap.
11:35:23 <lilac> skorpan: O-o
11:35:36 <lament> ski_: How appropriate. You fight like a cow.  ;)
11:35:37 <skorpan> lilac: what?
11:35:46 <lilac> skorpan: sitting right next to him?
11:35:53 <skorpan> lilac: yes, in the same room
11:36:06 <lament> skorpan: are you at chalmers too? do you like it?
11:36:16 <ski_> lament : no no. you should give an insult of your own now, not give an answer to an insult !
11:36:22 <skorpan> lament: i love chalmers. i'm writing a master thesis about a javascript mode for yi.
11:36:48 <lament> nice
11:37:11 <skorpan> and jean-philippe bernardy is my supervisor!
11:37:30 <skorpan> koen claessen is my "mentor" as they like to call it, but i've only spoken to him a few times
11:37:46 <Cale> Lament and Ski are changing into Zippy?
11:37:50 <Apocalisp> @hoogle [(a, b, c)] -> [((a, b) [c])]
11:37:50 <lambdabot> No results found
11:37:57 <Apocalisp> @hoogle [(a, b, c)] -> [((a, b), [c])]
11:37:57 <lambdabot> No results found
11:38:00 <ski_> Cale : not zippy, MI !
11:40:18 <lilac> @type groupBy (\(a,b,c) (d,e,f) -> a==d && b==e) . sort
11:40:19 <lambdabot> forall t t1 t2. (Ord t2, Ord t1, Ord t) => [(t, t1, t2)] -> [[(t, t1, t2)]]
11:41:10 <lilac> @type (((\a,b,c) -> (a,b)) . head) &&& map (\(a,b,c) -> c)) .  groupBy (\(a,b,c) (d,e,f) -> a==d && b==e) . sort
11:41:11 <lambdabot> parse error on input `,'
11:41:16 <lilac> @type ((\(a,b,c) -> (a,b)) . head) &&& map (\(a,b,c) -> c)) .  groupBy (\(a,b,c) (d,e,f) -> a==d && b==e) . sort
11:41:17 <lambdabot> parse error on input `)'
11:43:25 <lilac> @type map ((\((a,b,_):_) -> (a,b)) &&& map (\(a,b,c) -> c)) . groupBy (\(a,b,c) (d,e,f) -> a==d && b==e) . sort
11:43:26 <lambdabot> forall t t1 t2. (Ord t2, Ord t1, Ord t) => [(t, t1, t2)] -> [((t, t1), [t2])]
11:44:37 <yohan> http://www.ddj.com/cpp/184403941
11:44:44 <yohan> http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern
11:50:44 <niet> is it not possibel to divide a list into 2 parts without reversing the first half after its done?
11:50:47 <Cale> yohan: ... is that somehow related to something in this channel? :)
11:50:49 <niet> and without using ++ ?
11:51:00 <Cale> niet: hm?
11:51:21 <Cale> > splitAt 5 "hello, world"
11:51:22 <lambdabot>   ("hello",", world")
11:51:30 <Cale> Like that?
11:51:32 <niet> skorpan: what is yi? and how is that masters-sthesis worthy?
11:51:49 <MyCatVerbs> niet: yi's a text editor written in... whatever.
11:52:19 <MyCatVerbs> niet: probably. What division do you want? One stream of odd characters, one stream of even characters, or just a half-way split?
11:52:19 <ski_> Cale : it looks a bit similar to `Fix' ..
11:52:43 <MyCatVerbs> s/characters/elements/
11:53:17 <ski_> @src splitAt
11:53:17 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
11:53:36 <ski_> (.. maybe niet wanted just one traversal ..)
11:53:58 <Cale> That's an example implementation of splitAt, the real implementation is smarter.
11:54:02 <Cale> (and longer)
11:54:13 <niet> half-way-split not using splitAt
11:54:28 <skorpan> niet: yi is an editor written in haskell and configurable in haskell. this is not a mode for syntax highlighting. it has access to the abstract syntax tree which is modified while writing code and it will use the abstract syntax tree to some extent to check for common gotchas or downright stupid code, such as dividing strings etc.
11:54:30 <ski_> (yes i know) but presumably niet wanted to look at an implementation
11:54:49 <skorpan> niet: basically, yi is like xmonad, but an editor, or emacs, but in haskell
11:55:01 <Cale> niet: ah, halfway? That's an annoying operation for lists, but it's doable.
11:55:04 <ski_> niet : oh, you want to split in two parts of roughly same length ?
11:55:14 <niet> Cale: well at an index really
11:55:25 <Cale> niet: Well, why not use splitAt then?
11:55:44 <Cale> Would you like to see a one-pass implementation of splitAt?
11:55:55 <ski_> niet : do you want to contiguous split, or would `\[0,1,2,3,4] -> ([0,2,4],[1,3])' suffice ?
11:55:56 <dancor> skorpan: it checks for dividing strings even tho you can do instance Num String?
11:56:15 <skorpan> dancor: this is a javascript mode :)
11:56:41 <skorpan> afaik, you can't divide strings in javascript and you can't overload any of the built-in operators
11:56:43 <dancor> ohhh
11:56:52 * ski_ wants a partial evaluator for haskell ..
11:57:10 <dancor> ski_: partial how
11:57:15 <Cale> splitAt 0 xs = ([],xs); splitAt n [] = ([],[]); splitAt n (x:xs) = let {(us,vs) = splitAt (n-1) xs} in (x:us,vs)
11:57:16 <Cheshire> Cale could a compiler transform (take n xs, drop n xs) into one pass version?
11:57:18 <ski_> partial evaluator
11:57:33 <Cale> Cheshire: Not an existing compiler.
11:57:33 <MyCatVerbs> Cheshire: not profitably. :)
11:57:43 <yohan> lol
11:57:50 <dancor> mm  http://en.wikipedia.org/wiki/Partial_evaluator
11:58:07 <Cheshire> they are bothe defined by the same recursion scheme
11:58:09 <MyCatVerbs> dancor: yes, exactly that.
11:58:17 <Cale> Cheshire: There are some troubling aspects of making that transformation automatically.
11:58:49 <blackh> @seen dons
11:58:49 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
11:59:02 <yohan> just iterate over it and copy all the values
11:59:09 <niet> Mergesort> divide [1..10] 4 0 [] -> ([5,4,3,2,1],[6,7,8,9,10]) is what i get but want Mergesort> divide [1..10] 4 0 []
11:59:09 <niet> ([1,2,3,4,5],[6,7,8,9,10])
11:59:17 <pejo> ski, would supero do?
11:59:35 <dancor> ski_: would you want it to make hard decisions about what was worth doing at compile time?  like if you use static data to create something infinite or extremely large you wouldn't want that to happen at compile time..
11:59:48 <ski_> dancor : one standard example is that partially evaluating an interpreter, with a program to interpret as static input, compiles that program
12:00:03 <Cale> niet: btw, mergesorting is easier if you start out by dividing the list into one-element lists and then merge adjacent pairs.
12:00:05 <blackh> Hey, can someone help with a cabal question for the shootout game?  http://alioth.debian.org/tracker/?func=detail&atid=411646&aid=311443&group_id=30402
12:00:25 <yohan> for(int i = 0; i < splitpoint; i++) {copy}
12:00:29 <Cale> niet: That way you don't end up wasting time calculating the length
12:00:29 <ski_> dancor : and partially evaluating the partial evaluator, with the interpreter as static input, yields a compiler
12:00:35 <Cheshire> yohan please stop
12:00:43 <yohan> im sorry
12:00:46 <dancor> i.e. doesn't laziness make partial evaluation harder
12:00:47 <Cheshire> it's ok
12:00:48 <yohan> dont know haskell syntax
12:00:59 <blackh> Should I tell Isaac to use cabal install --global ?
12:01:03 <yohan> but anyways u can do that
12:01:06 <ski_> (and partially evaluating the partial evaluator, with the partial evaluator as static input, yields an optimized partial evaluator)
12:01:17 <ski_> (these three are known as Futamura projections)
12:01:33 <MyCatVerbs> > let { divideInHalf (a:b:l) = let (la,lb) = divideInHalf l in (a:la,b:lb); divideInHalf (a:[]) = ([a],[]), divideInHalf [] = ([],[]); } in divideInHalf [1..10]
12:01:34 <lambdabot>   <no location info>: parse error on input `,'
12:01:42 <MyCatVerbs> Blast.
12:02:01 <Cheshire> @go self applicable partial evaluator
12:02:01 <Cheshire> this is fun
12:02:11 <lambdabot> http://citeseer.ist.psu.edu/61020.html
12:02:11 <lambdabot> Title: Self-applicable partial evaluation for pure lambda calculus
12:02:18 <blackh> In other words: If I said "delete your ~/.cabal and issue the command with 'cabal install --global <pkg>'" would that work and install everything into the ghc install?
12:02:26 <MyCatVerbs> > let { divideInHalf (a:b:l) = let (la,lb) = divideInHalf l in (a:la,b:lb); divideInHalf (a:[]) = ([a],[]); divideInHalf [] = ([],[]); } in divideInHalf [1..10]
12:02:27 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
12:02:37 <MyCatVerbs> ...why did I do that? Wrong thing entirely.
12:02:38 <ski_> dancor : i would probably expect some not-too-complicated binding-time analyzer (for off-line PE) .. and possibly allow explicit staging annotations for more complex situations
12:02:46 <ski_> pejo : possibly
12:02:55 <yohan> niet: did you try my solution?
12:03:34 <yohan> I can post it on the internet
12:03:36 <Cale> yohan: I don't think your solution makes sense in the context of Haskell... or, I don't understand how to interpret it anyway.
12:03:40 <pejo> ski, I think supero would do much of what you want, unless you specifically want a partial evaluator in the traditional sense.
12:03:57 <yohan> Cale, I don't understand
12:04:08 <Cale> yohan: "copying" doesn't make sense.
12:04:15 <yohan> a = 5
12:04:18 <Cale> yohan: Values simply exist.
12:04:19 <yohan> i mean a = b
12:04:25 <yohan> that means that a copied b
12:04:34 <Cheshire> yohan in what language
12:04:40 <yohan> in mathematical
12:04:42 <Cale> In Haskell, that means that a and b are the same value.
12:04:46 <Cheshire> yohan mathematical language ...?
12:04:56 <yohan> Yeah I guess
12:05:00 <Cheshire> yohan no
12:05:02 <yohan> you mean a == b?
12:05:04 <Cale> (or, it defines a to be the same value as b, but it doesn't copy b)
12:05:05 <lispy> > let b = 1; a = b in a
12:05:07 <lambdabot>   1
12:05:21 <yohan> ok, so copy(a,b)?
12:05:27 <Cheshire> yohan that is better!
12:05:27 <yohan> whats the function called?
12:05:30 <Cheshire> copy
12:05:32 <Cale> There's no such operation. Values don't ever change.
12:05:38 <niet> Cale: you can calc the length the fist tiem then just divide it by 2 nstead, or you mean save the first step to?
12:05:41 <yohan> copy(a,b) { a = b}
12:05:45 <Cheshire> yohan no
12:05:48 <yohan> thanks
12:05:48 <Cale> niet: You can do that.
12:06:07 <yohan> Cool, I'm getting the hang of it
12:06:09 <Cale> niet: I'm just saying it's easier to divide the list into the one-element lists you'll eventually chop it into anyway
12:06:11 <Cheshire> yohan no you are not
12:06:23 <yohan> Yeah I know, but its progress
12:06:27 <yohan> I'm learning
12:06:27 <Cale> niet: and then merge those in pairs
12:06:29 <yohan> I'm sorry
12:06:34 <Cheshire> yohan what are you learning
12:06:35 <Cheshire> ?
12:06:39 <yohan> Haskell
12:06:41 <Cheshire> Not haskell
12:06:42 <Cheshire> :p
12:06:49 <Cheshire> watch:
12:06:50 <Cheshire> > copy(a,b) { a = b}
12:06:51 <lambdabot>   Not in scope: `copy'
12:06:52 <Cale> Cheshire: He might have just found something out :)
12:06:54 <yohan> ok, explain to me
12:06:57 <yohan> please
12:07:04 <yohan> well, define it
12:07:22 <lispy> > let copy (a, b) = { a = b} in copy (1,2)
12:07:22 <yohan> lambdabot #DEFINE copy(a,b) a = b
12:07:23 <lambdabot>   <no location info>: parse error on input `{'
12:07:31 <Cale> yohan: It might help to mention that in Haskell, x = x + 1 is an infinite loop.
12:07:43 <lispy> > let x = x + 1 in x
12:07:44 <yohan> should fix the bot maybe
12:07:53 <MyCatVerbs> Cale: not with a lazy Peano instance for Num! ;D
12:07:57 <Cale> MyCatVerbs: yes
12:07:58 <lambdabot>   thread killed
12:08:04 <yohan> you mean for(;;x++)?
12:08:05 <Cale> MyCatVerbs: But with, say, Integer ;)
12:08:15 <yohan> or maybe for(;;x + 1)
12:08:17 <Cheshire> yohan, I think that you know that C and Haskell are not the same language
12:08:18 <Cale> yohan: Something like that
12:08:20 <yohan> that's more correct
12:08:34 <Cale> Cheshire: He's trying his best to translate :)
12:08:45 <lispy> > fix (\x -> x + 1)
12:08:47 <Cheshire> you can't learn haskell that way
12:08:48 <yohan> Yeah, but like C with templates? like functions
12:09:01 <lambdabot>   thread killed
12:09:01 <yohan> like you have functions, and everything is functions
12:09:04 <Cheshire> look at the guys post about taking 6 years to learn haskell by understanding it in terms of assembly
12:09:11 <Cale> Cheshire: hehe
12:09:12 <yohan> so a = b doesnt work, you have to write copy(a,b) { a = b}
12:09:22 <Cale> yohan: The latter doesn't work either
12:09:28 <yohan> latter?
12:09:34 <Cheshire> yohan, I thougth I already showed you this is not valid haskell
12:09:40 <Cale> copy(a,b) { a = b} <-- this is not valid Haskell
12:09:48 <Cheshire> yohan, maybe you missed it though, or you are ignoring it and being silly on purpose hard to know
12:09:49 <ski_> pejo : do you have any link to Supero handy ?
12:09:52 <yohan> ok, so how do you copy stuff?
12:09:54 <Cale> (nor does it correspond to valid Haskell in any way)
12:09:57 <Cale> yohan: You don't.
12:10:02 <Cheshire> yohan, actually it's easy to know based on your language earlier..
12:10:04 <psygnisfive> and you dont NEED to copy stuff wither
12:10:07 <psygnisfive> either*
12:10:10 <yohan> so you cant do anything? you have to have loops and copy
12:10:14 <yohan> else its not a language
12:10:21 <Cale> yohan: You produce new values from old ones by applying functions to them.
12:10:21 <temoto> How come my ghci says "group" not in scope?
12:10:25 <pejo> @google supero ndm site:york.ac.uk
12:10:25 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/supero/
12:10:25 <lambdabot> Title: Neil Mitchell - Supero
12:10:27 <yohan> it has to be turing complete
12:10:29 <temoto> and my friend too
12:10:34 <temoto> on my job it works
12:10:37 <Cheshire> it's juts some trolling guy
12:10:44 <pejo> ski, the IFL-paper there gives a good overview, I think there are more details in his thesis.
12:10:46 <lispy> yohan: in C a variable is a slot that holds a value right?  So you can update the value in that slot.  In Haskell, a "variable" is just a name given to a value.  Since the value cannot change and the "variable" is not a slot, copying isn't really meaningful in the same way as C.
12:10:47 <psygnisfive> yohan, lambda calculus is turing complete but has no ability to copy things like that.
12:10:47 <Cheshire> incase that was not obvious...
12:10:52 <Cale> Cheshire: I don't think he's trolling...
12:10:55 <yohan> so copy(a,b) { c=b; a=c;}?
12:10:57 <mstr> yohan: you could try emacs lisp first
12:11:01 <Cheshire> Cale should have seen him earlier about his PhD thesis...
12:11:24 <Cale> yohan: Perhaps it would help to see how some algorithms translate into Haskell...
12:11:30 <niet> Cale: is their a function: elemList :: [a] -> [[a]] ?
12:11:30 <yohan> lispy: so copy it into a new value?
12:11:37 <byorgey> temoto: did you import Data.List first?
12:11:39 <Cale> niet: elem will do it.
12:11:41 <byorgey> temoto: :m +Data.List
12:11:42 <temoto> byorgey: no
12:11:48 <Cale> niet: Well... depends on what you want.
12:11:55 <yohan> psygnisfive: lambda calculus, is that some math thing?
12:11:56 <yohan> how does that relate to haskell ?
12:12:02 <temoto> byorgey: yeah, now it works.
12:12:03 <Cale> niet: Oh... you mean...
12:12:08 <Cale> niet: map (:[])
12:12:08 <lispy> yohan: you can create values if that is what you mean
12:12:10 <ehird> yohan: err.
12:12:13 <Cale> > map (:[]) [1,2,3,4,5]
12:12:14 <lambdabot>   [[1],[2],[3],[4],[5]]
12:12:17 <lispy> > 1 -- the value of 1
12:12:18 <lambdabot>   1
12:12:19 <MyCatVerbs> > let { splitInHalf l = div' l l; div' (a:al) (b1:b2:bl) = let (ra,rb) = div' al bl in (a:ra,rb); div' rb (_:[]) = ([],rb); div' rb [] = ([],rb); } in splitInHalf [1..10] -- niet, this what you want? :)
12:12:20 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
12:12:32 <temoto> byorgey: thank you very much. Why does it work on my job without :m ? Same ubuntu, installed from apt.
12:12:33 <blackh> yohan: Lambda calculus is a maths thing and Haskell is based on it.
12:12:33 <yohan> yeah, so copy(b) {a=b; return a;}
12:12:36 <yohan> right?
12:12:39 <lispy> > let copy (a, b) = a == b in copy (1,2)
12:12:40 <lambdabot>   False
12:12:44 <ehird> okay, so reading the logs yohan is very obviously a troll.
12:12:56 <Cale> yohan: Lambda calculus is to functional languages roughly what turing machines are to imperative languages.
12:13:06 <yohan> ehird: whats a troll?
12:13:13 <ehird> a thing that sits under bridges
12:13:15 <ehird> and enforces tolls
12:13:17 <lispy> > let copy (b) = let a = b in a in copy (2)
12:13:18 <lambdabot>   2
12:13:18 <yohan> what's a turing machine ?
12:13:21 <lispy> yohan: like that?
12:13:27 <ehird> what's water
12:13:28 <yohan> lispy: what?
12:13:35 <lispy> > let copy (b) = let a = b in a in copy (2) -- yohan
12:13:36 <blackh> yohan: Goats generally go over the bridge that the troll lives under.
12:13:36 <lambdabot>   2
12:13:42 <yohan> ahhhhhhhhhh
12:14:00 <byorgey> temoto: strange, I don't know.  it shouldn't. ;)
12:14:06 <MyCatVerbs> yohan: you're a long, long way off the mark here. Please try reading a Haskell tutorial? I would recommend Real World Haskell, or Yet Another Haskell Tutorial.
12:14:06 <impomatic> Trolls are ugly!
12:14:07 <lispy> yohan: the parens are unnecessary by the way
12:14:07 <yohan> how can you have two equals in one statement?
12:14:10 <yohan> that doesnt compile
12:14:11 <ehird> <yohan> Im writing my master thesis about why imperative programming languages are fast
12:14:13 <psygnisfive> lispy, that works in a completely useless way tho :)
12:14:13 <Cale> yohan: Of course, lispy's code will be implemented without actually making a copy.
12:14:14 <ehird> hahahaha
12:14:22 <yohan> oh
12:14:24 <Cale> yohan: It will just pass you back the same thing you put in.
12:14:37 <yohan> ehird: come on, they are fastest?
12:14:39 <lispy> psygnisfive: right, copy is useless :)
12:14:52 <Cale> yohan: It defines 'a' to be another name for the value 'b', and then results in 'a', which is the same as resulting in 'b'.
12:14:53 <ehird> yohan: yes. haskell was designed to be the slowest language possible
12:14:53 <yohan> in assembly speed
12:14:57 <niet> divide [1..10] 4 0 []
12:14:57 <niet> ([5,4,3,2,1],[6,7,8,9,10]) , does thta matter for mergesorting btw, if it is [5,4,3,2,1] or [1,2,3,4,5] in thats tep?
12:15:07 <MyCatVerbs> lispy: nonsense. There are lots of places where `id` is a fantastically useful combinator.
12:15:09 <ehird> most times it takes infinite time to run a haskell program
12:15:14 <yohan> ehird: oh, don't really understand
12:15:24 <byorgey> niet: nope, it shouldn't matter.
12:15:24 <Cheshire> MyCatVerbs, you use `id` instead of $ ?
12:15:26 <Cale> yohan: Perhaps come to #haskell-overflow, and I'll try to explain the basics of how functional programming works.
12:15:27 <yohan> ehird: are you 'trolling'?
12:15:47 <lispy> MyCatVerbs: sure, so lets simplify and just say, copy = id :)
12:15:48 <ehird> Yes. I am sitting under a bridge and enforcing the toll.
12:15:54 <yohan> what?
12:15:54 <psygnisfive> id is often a very useful combinator
12:15:56 <Cale> yohan: (so there will be less noise and hopefully it'll be easier to understand :)
12:16:02 <psygnisfive> especially if you're coding in SKI
12:16:04 <blackh> yohan learnt what the word 'troll' means in the last 2 minutes.
12:16:09 <psygnisfive> but even then!
12:16:14 <yohan> wikiedpai is nice man
12:16:18 <ziman> :t ap const const
12:16:19 <lambdabot> forall a. a -> a
12:16:25 <ziman> id is useless :P
12:16:26 <psygnisfive> spelling is nice too, man
12:16:29 <lispy> yohan: you might want to stick to simple.wikipedia.org for now
12:16:32 <temoto> Why on my job PC ghci knows group and sort right from the start, whereas on my laptop it required :m +Data.List  ?
12:16:39 <MyCatVerbs> Cheshire: not often. I just use infix notation as a way to mark up what're functions, sometimes. :)
12:16:39 <yohan> http://en.wikipedia.org/wiki/Troll_(gay_slang)
12:16:43 <psygnisfive> id is useless unless you need to map a list to itself! :o
12:16:52 <temoto> Did i set up something?
12:17:00 <temoto> Where could it be?
12:17:14 <byorgey> temoto: do you have a .ghci file on your work PC?
12:17:15 <Cale> temoto: Perhaps you'd loaded a file which imported Data.List?
12:17:25 <yohan> cool, well I think I'm gonna try haskell
12:17:30 <yohan> and compare it to C, and maybe C++
12:17:36 <skorpan> screw id, i use const for everything...
12:17:40 <psygnisfive> good luck yohan.
12:17:41 <Cale> yohan: It's very very different.
12:17:45 <lispy> skorpan: hah
12:17:48 <temoto> byorgey: probably, i can't say right now.
12:17:53 <yohan> Like japanese food?
12:17:54 <temoto> byorgey: is it ~/.ghci?
12:17:58 <Cale> yohan: It's best to pretend that you don't know anything about programming when you start to learn it. :)
12:18:00 <byorgey> temoto: right.
12:18:01 <ehird> [20:16:18] <ziman> :t ap const const
12:18:05 <ehird> aka, SKK
12:18:10 <yohan> Cale: well I know C man
12:18:12 <temoto> byorgey: thanks, i'll look it.
12:18:15 <skorpan> oh, `ap' is S?
12:18:16 <niet> @src odd
12:18:16 <lambdabot> odd = not . even
12:18:17 <lispy> :t ap const const
12:18:17 <ehird> yep
12:18:18 <lambdabot> forall a. a -> a
12:18:22 <niet> @src even
12:18:22 <lambdabot> even n = n `rem` 2 == 0
12:18:22 <skorpan> did not know that
12:18:27 <byorgey> skorpan: indeed, for the ((->) r) monad
12:18:30 <ehird> > let s = ap; k = const; i = ap const const in s k i (s k i)
12:18:31 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
12:18:31 <lambdabot>        Exp...
12:18:33 <jkup> yohan: maybe try using map, filter, lambda in python first
12:18:33 <ehird> aw.
12:18:36 <skorpan> my favorite is YI
12:18:38 <Cale> yohan: Later on, you'll figure out ways to apply your knowledge of C, but initially, it will just get in the way and make it harder to learn.
12:18:45 <yohan> I tried haskell but I couldn't get it to sort my integers, guess I will check some book
12:18:53 <Cheshire> jkup, why would you try python to learn haskell that does not even make sense
12:18:56 <lispy> > sort [10..1]
12:18:57 <lambdabot>   []
12:19:05 <lispy> oh no, haskell is broken :(
12:19:09 <lispy> > sort [10,9..1]
12:19:09 <jkup> it's less of a shift in thinking
12:19:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:19:17 <lispy> oh wait, no it's not
12:19:17 <Cheshire> jkup, that is not good
12:19:19 <yohan> jkup: python, is that like an include file?
12:19:29 <Cheshire> > sort [1..1000000000]
12:19:30 <MyCatVerbs> Cheshire: because Python already has map, filter and list comprehensions.
12:19:36 <Cale> > let qsort [] = []; qsort (x:xs) = less ++ x : greater where (less, greater) = partition (<= x) xs in qsort [7,1,6,10,2,5,8]
12:19:38 <Cheshire> MyCatVerbs, haskell does as well
12:19:53 <lambdabot>   thread killed
12:19:54 * lispy sighs as he realizes yo	is not productive or attempting to be
12:19:55 <Cale> Cheshire: was that *really* necessary? ;)
12:20:04 <Cheshire> Cale, this is the list we couldn't sort earlier
12:20:08 <MyCatVerbs> Cheshire: yes. People are suggesting it as a stepping stone. :)
12:20:18 <Cheshire> apparently it works in C
12:20:25 <MyCatVerbs> Cheshire: myself, I'd recommend writing nontrivial calculations in C++ templates.
12:20:27 <psygnisfive> yohan where are you from?
12:20:30 <Cale> Well, it's a very long list.
12:20:34 <MyCatVerbs> Cheshire: or Verilog. ^^
12:20:47 <Cheshire> I thought that we would get the head of the list until I realized that   head . sort = min
12:21:11 <MyCatVerbs> Cheshire: you mean foldl1' min.
12:21:18 <ehird> [20:19:54] â¢ lispy sighs as he realizes yo	is not productive or attempting to be <-- took you a while?
12:21:43 <lispy> ehird: I try to give the benefit of the doubt :)
12:21:48 <ehird> :-)
12:22:19 <temoto> what is yois?
12:22:21 <ziman> :t foldU
12:22:23 <lambdabot> Not in scope: `foldU'
12:22:44 <lispy> heh, yois is my autocomplete failing, should have been yohan
12:22:47 <psygnisfive> ziman: no, fold U!
12:22:57 <Cale> yohan: In order to sort that billion element list, you need at least enough memory to store it all. A list is not the same thing as an array, and includes more structure than just its elements. So sorting that billion element list is going to do a lot of allocation.
12:23:01 <ziman> who, me?
12:23:17 <ziman> :)
12:23:21 <yohan> psygnisfive: Sweden
12:23:31 <Cale> yohan: If you wanted to sort a billion element *array* (Haskell also has arrays), that would be a different matter.
12:23:33 <lispy> Cale: do we have an efficient inplace array based sort in Haskell?
12:23:34 <MyCatVerbs> lispy: oh! Are you perchance on a *very* laggy ssh connection, with irssi at the far end?
12:23:38 <yohan> Cale, just put it on the hard drive
12:23:47 <lispy> MyCatVerbs: why yes, I am.
12:23:54 <Cale> yohan: yeah, that requires a good bit more work though :)
12:24:08 <Cale> lispy: Not in the libraries, I don't think, but it's not so hard to write one.
12:24:10 <yohan> doesn't paging do that automagically?
12:24:10 <psygnisfive> what year are you at university, yohan.
12:24:13 <MyCatVerbs> lispy: ahhh. I get the same artifact too. Control characters going through uninterpreted.
12:24:22 <yohan> I'm the fifth year
12:24:27 <lispy> Cale:  friend of mine ran Prelude.sort on a billion or so elements and ran out of ram.  So he rewrote it in Java.
12:24:32 <psygnisfive> undergraduate or graduate?
12:24:36 <yohan> psygnisfive: why?
12:24:39 <Cale> yohan: I suppose you can let it do that. Still, the list is going to be extremely large.
12:24:41 <MyCatVerbs> lispy: sort isn't in Prelude, it's in Data.List?
12:24:48 <Cheshire> lispy, and did the java one work?
12:24:49 <psygnisfive> well, either way you should ask for a refund of all the money you spent on your education.
12:24:50 <yohan> graduate
12:24:56 <lispy> MyCatVerbs: Haskell98 versus non-Haskell98 :)
12:25:07 <yohan> psygnisfive: Dude, not fair :(
12:25:24 <lispy> Cheshire: last I talked to him the java version was buggy...dunno if it ran to completetion or not
12:25:31 <Cale> psygnisfive: Wait, you didn't ask what he studied!
12:25:33 <psygnisfive> yohan, let me put it this way. ehird is 13 and he knows more about computer science than you do.
12:25:42 <MyCatVerbs> psygnisfive: that was significantly harsher than #haskell's mean, uh, harshness level.
12:25:57 <Cale> Yeah, we should be polite here :)
12:26:03 <Cheshire> sorry Cale
12:26:04 <yohan> computer science? is that really a science?
12:26:15 <yohan> and what does computers have to do with programming languages
12:26:15 <Cale> yohan: No, it's only called that :)
12:26:23 <psygnisfive> im an asshole, but this guys a trolling idiot. and if he's seriously a 5th year grad student, everything i said is poignant.
12:26:34 <Cale> yohan: Similarly, geometry really isn't about measuring the Earth.
12:26:45 <yohan> ah
12:26:46 <yohan> ture
12:26:47 <yohan> true
12:26:58 <yohan> psygnisfive: dude, what?
12:27:04 <lispy> But anyway, do we have an efficient "inplace" sort in Haskell?  In particular, one that is O(n logn) with, say O(n) space?
12:27:19 <yohan> ah
12:27:36 <yohan> mmm...
12:27:37 <yohan> O?
12:27:45 <Cheshire> lispy, I think augustss posted one
12:27:57 <Cale> lispy: It exists, but it doesn't come with the array libraries.
12:27:58 <mle> yohan: http://en.wikipedia.org/wiki/Big_o_notation
12:27:59 <Cheshire> @go quicksort that amuse me
12:28:00 <lambdabot> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
12:28:00 <lambdabot> Title: Things that amuse me
12:28:03 <MyCatVerbs> lispy: Data.List.sort, provided you waive the "inplace" requirement. No more than 2x-ish memory overhead though, AFAIK?
12:28:10 <Cale> yohan: What are you studying?
12:28:16 <ziman> as EWD put it, CS is as much about computers as astronomy is about telescopes ;)
12:28:51 <Cale> yohan: It seems hard to imagine that you would graduate from an undergraduate program in computer science without having done at least a little bit of complexity theory.
12:28:52 <lispy> MyCatVerbs: his data set was 250mb and his program ran out of space (used ByteString for the parsing)
12:28:54 <yohan> mle: reading
12:29:14 <yohan> Cale: I'm studying computer engineering
12:29:14 <mmorrow> > zipWith id [(*2), const 9, (^2)] [1..]
12:29:15 <lambdabot>   [2,9,9]
12:29:30 <lispy> MyCatVerbs: and as Cale just pointed out, the memory usage to have the full *list* in memory is going to be bad because the list has extra overhead per entry compared to an array
12:29:32 <mmorrow> id is not useless! :)
12:29:40 <yohan> Cale: why? What are you studying?
12:29:50 <temoto> const? what is that?
12:29:53 <temoto> @src const
12:29:53 <lambdabot> const x _ = x
12:29:55 <yohan> lispy: not if you use bubblesort
12:30:03 <TuringTest> Hmmm.....  I wonder if I am hitting a garbage collector bug in ghc-6.10.1
12:30:08 <newsham> > const 5 "test"
12:30:08 <Cale> yohan: My undergrad degree is in pure mathematics. I had only 2 CS courses, and one of them had a lot of complexity theory in it.
12:30:09 <lambdabot>   5
12:30:14 <lispy> yohan: I think you mean, bubbletronsort.
12:30:19 <temoto> newsham: how to understand that?
12:30:25 <yohan> Cale: nice stuff
12:30:35 <newsham> temoto: its a function which always returns the same thing (hence const)
12:30:38 <yohan> lispy: I don't know about that one
12:30:42 <sw17ch> The algorithms and datastructures course was the weeder @ my college.
12:30:44 <newsham> const x = \arg -> x
12:30:54 <temoto> oh
12:30:57 <sw17ch> that's where complexity hit for the first time
12:31:00 <newsham> > map (const 3) "test"
12:31:01 <lambdabot>   [3,3,3,3]
12:31:04 <MyCatVerbs> lispy: mmmm. One of the unboxed arrays, then? You're right that it does seem a little odd that there isn't (AFAIK) an array sort around already.
12:31:08 <TuringTest> Question : is there a trac ticket somewhere on GC bugs in ghc-6.10.1 ... time to search
12:31:09 <temoto> aha, i got it
12:31:37 <pejo> TuringTest, there have been fixes to the barriers in the RTS lately.
12:31:40 <lispy> MyCatVerbs: yeah, my friend cited the lack of good sorts for large datasets as a reason why haskell hasn't caught on
12:31:42 <mmorrow> > maybe 0 id $ Just 42
12:31:43 <lambdabot>   42
12:31:47 <temoto> newsham: thanks. Looks useless, but at least i understand usage. :)
12:31:49 <mmorrow> > maybe 0 id $ Nothing
12:31:50 <lambdabot>   0
12:31:53 <lispy> MyCatVerbs: and I think there is some value in that statement.
12:31:56 <TuringTest> pejo: Hmm... thanks
12:32:12 <mmorrow> temoto: such function don't seem useful until you start using higher-order functions
12:32:19 <skorpan> Cale: you're an undergrad?
12:32:23 <mmorrow> then `id' plays the same role as `0'\
12:32:26 <newsham> you can always just use a lambda, but "const n" is somewhat descriptive
12:32:27 <Cale> In the other, we all wrote compilers which compiled a simple imperative language to a simple assembly language, which provided the basis for studying regular and context free languages, and various types of finite automata.
12:32:27 <mmorrow> (or `1')
12:32:33 <Cale> skorpan: I was an undergrad.
12:32:46 <skorpan> so what are you now?
12:32:46 <Cale> skorpan: I'm actually applying to graduate programs right now.
12:32:55 <mmorrow> > foldr (.) id (replicate 8 show) $ 42
12:32:55 <skorpan> oh, okay
12:32:56 <lambdabot>       No instance for (Num String)
12:32:56 <lambdabot>        arising from the literal `42' at <i...
12:33:00 <yohan> Cale: where at?
12:33:01 <lispy> skorpan: They expelled him for being too knowledgable
12:33:06 <MyCatVerbs> skorpan: "a squishly, fleashy meatling human".
12:33:09 <yohan> COme to chalmers, we have cool education
12:33:12 <mmorrow> > foldr (.) id (replicate 8 show) $ "42"
12:33:13 <MyCatVerbs> *squishy
12:33:13 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
12:33:17 <mmorrow> > foldr (.) id (replicate 4 show) $ "42"
12:33:18 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"42\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
12:33:28 <yohan> best C teachers you can find
12:33:35 <Alpounet> hey guys
12:33:46 <Alpounet> are there some stuffs done for embedding haskell on embedded devices ?
12:33:54 <mmorrow> @type let ntimes n = foldr (.) id . replicate n in ntimes
12:33:55 <lambdabot> forall a. Int -> (a -> a) -> a -> a
12:33:57 <yohan> Alpounet: I would use LUA
12:33:57 <Alpounet> I mean mobiles, u-controlers, etc
12:34:01 <MyCatVerbs> yohan: handy! Out of curiosity, could you explain token pasting in the preprocessor to me, please?
12:34:38 <pejo> Alpounet, Geoffrey Mainland at harvard has some stuff about sensor networks, but he's getting some kind of C-dialect out of it iirc.
12:34:42 <Cale> yohan: I'm applying to McMaster for computer science because I know some of the professors there and they contacted me about considering being their grad student.
12:34:42 <yohan> MyCatVerbs: sure, see http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation
12:35:05 <TuringTest> What I am seeing:  My regex search works its way through a 1 million element list just fine.  Then at the end something is causing ~ 25 MB of stack to get allocated, causing the stack space to crash unless I use +RTS -K to increase it.
12:35:10 <Cale> Also, probably Western for pure mathematics, and maybe some others in southern Ontario.
12:35:19 <Cale> I'm not really interested in having to move.
12:35:20 <yohan> Cale: wicked
12:35:23 <MyCatVerbs> yohan: lazy git. ;P
12:35:27 <Cale> (at least not far)
12:35:35 <MyCatVerbs> yohan: (efficient, though) :)
12:35:37 <yohan> MyCatVerbs: Best explaination there is :-)
12:35:46 <Alpounet> pejo, ok thanks... As the type-safety and the flow control are very strong in Haskell, some work on such stuff could be great !
12:35:51 <quicksilver> TuringTest: you've built up a large thunk during the process.
12:35:59 <quicksilver> TuringTest: everything is fine until you try to evaluate that thunk
12:36:08 <quicksilver> (that's what causes a stack overflow)
12:36:09 <temoto> I thought wiki is more about definition than explanation.
12:36:27 <TuringTest> quicksilver: That would make sense, if _anything_ had been building a thunk.
12:36:35 <pejo> Alpounet, Hume is targeting embedded systems, and there's plenty of others too I think.
12:36:53 <niet> he is trollsorting
12:37:35 <niet> map smackTheDonkey [yohan,less_alive_yohan..dead_yohan]
12:37:51 <niet> weeder?
12:37:57 <Alpounet> pejo, great... Like on mobile phones ?
12:38:08 <yohan> pejo: still, if you want to have a high level languuage, why not use lua? I'm talking 100kb vm
12:38:14 <Cale> niet: (it looks as if you might have been lagged ;)
12:38:31 <yohan> niet: what?
12:38:34 <Cale> niet: A weeder course is one which causes those who are not dedicated to drop out.
12:38:40 <yohan> niet: are you a homosexual?
12:38:44 <Alpounet> !faq Can Haskell eat Lua whenever it wants ?
12:38:49 <Alpounet> damned
12:38:52 <skorpan> use @
12:38:52 <Alpounet> @faq Can Haskell eat Lua whenever it wants ?
12:38:52 <lambdabot> The answer is: Yes! Haskell can do that.
12:38:56 * TuringTest looks at (succ offset) suspiciously)
12:38:59 <Alpounet> yep, just mistypped
12:39:01 <Alpounet> typed*
12:39:01 <Cale> niet: (thereby doing them a painful but important favour)
12:39:03 <yohan> lua has nothing to do with lua
12:39:04 <lispy> ?users
12:39:05 <lambdabot> Maximum users seen in #haskell: 658, currently: 644 (97.9%), active: 31 (4.8%)
12:39:09 <yohan> >I
12:39:15 <yohan> i mean haskell
12:39:17 <yohan> >I
12:39:34 <yohan> What sort of embedded device are you talking about? Microcontroller?
12:39:49 <yohan> FPGA ?
12:39:52 <Alpounet> Any. Just wanted  to know if there was some work done in this field
12:40:15 <mmorrow> Alpounet: in most stuff i've seen the idea is to either use haskell to generate lowlevel code for an embedded system, or to take haskell source code and (also use haskell to) compile it to some appropriate lowlevel rep
12:40:18 <yohan> loads, but not sure haskell is a good candiate
12:40:21 <newsham> niet,yohan: please keep it civil.
12:40:26 <yohan> newsham: sorry
12:40:29 <mmorrow> Alpounet: have you seen the reducern(2) ?
12:40:34 <temoto> I'm not meaning anyone it's just you guys speak about trolling... we've invented funny word at job. TRANSACTION TROLLBACK.
12:40:47 <yohan> hehe
12:40:47 <sw17ch> niet: the weeders are the ones that overload you with tons of work to gain a minimal grade
12:40:50 <yohan> :D
12:40:54 <niet> can i patternmatch against a functionresult? f (length xs < 10) xs ; f xs ; ?
12:41:01 <Cheshire> neit, no
12:41:11 <sw17ch> in other words, they are the courses that consume you entirely for a whole semester
12:41:11 <Cale> f xs | length xs < 10 = ...
12:41:14 <newsham> you can use guards to check conditions
12:41:32 <Cale>      | otherwise = ...
12:41:33 <mmorrow> @where reduceron2
12:41:33 <lambdabot> I know nothing about reduceron2.
12:41:38 <mmorrow> @go reduceron2
12:41:39 <lambdabot> http://www.cs.york.ac.uk/fp/reduceron/
12:41:39 <lambdabot> Title: The Reduceron
12:41:43 <newsham> although when you use guards you kinda make it harder ot use equaitonal reasoning
12:41:45 <Alpounet> Thanks ;)
12:42:18 <mmorrow> whoa, they're working on the reduceron again!
12:42:25 <mmorrow> "From 1 October 2008 we will work for 15 months on the Reduceron."
12:42:57 <Alpounet> Yep.
12:43:12 <Alpounet> That looks like an amazing work, I must take a deeper look @ this
12:43:18 * TuringTest compiles with a few bang patterns...
12:43:23 <hackage> Uploaded to hackage: hdbc-tuple 0.0.1
12:43:23 <hackage> Uploaded to hackage: typical 0.0.1
12:43:27 <mmorrow> Alpounet: the source code is a good read too
12:43:39 <Cale> The hackage and reddit bots really ought to post urls...
12:43:53 <quicksilver> Cale: tinyurls perhaps
12:43:56 <quicksilver> (or xrls)
12:44:06 <quicksilver> Cale: would be nice to keep the typical line length short.
12:44:12 <Cale> quicksilver: well, yes
12:44:21 <quicksilver> and inhibit lambdabot from printin page titles.
12:44:23 <newsham> wouldnt a twitter and/or an -announce channel be better?
12:44:34 <Cheshire> announce would be great if the bots were just in there
12:44:37 <Cale> quicksilver: I have that turned off anyway, because it often crashed the bot.
12:44:38 <Cheshire> that way we would not hear them
12:44:42 <tibbe> @seen dons
12:44:42 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
12:44:43 <Cheshire> (unless we wanted)
12:44:56 <quicksilver> Cheshire: if you don't want to hear them you can ignore them.
12:45:00 <Cheshire> no I can't
12:45:04 <Cale> No?
12:45:05 <Cheshire> people still talk about them
12:45:08 <Cheshire> I tried it
12:45:20 <Cale> It would be the same problem wouldn't it?
12:45:27 <quicksilver> well, people talking about them is the point of having them
12:45:38 <quicksilver> the whole idea of a hackage bot and a reddit bot is to trigger interesting discussion.
12:46:00 <Cale> (like we don't have enough discussion in here already ;)
12:46:16 <quicksilver> sometimes we do and sometimes we don't.
12:46:20 <Cale> True.
12:46:25 <quicksilver> it gets pretty quiet in here when I shut up.
12:46:31 <Cheshire> basically I hate these bots but who am I to complain
12:46:31 <Cale> heh
12:46:55 <quicksilver> I still think you can ignore them. I do not believe conversation *about* them is that common or that disruptive.
12:47:10 <mmorrow> disruptive to what?
12:47:25 <quicksilver> mmorrow: disruptive to the goal of someone who wants to /ignore them.
12:47:31 <mmorrow> ah
12:47:32 <niet> im 16 i can do haskell, python, java, c++, c, scheme and i know algorithms and datastructures, sicp, basic mahienlearning, basic 3dengine,s linear algebra, mobile phone programming. how the hell does people at 20 not pass a fakking quicksort-exam?
12:47:33 <TuringTest> quicksilver: Ha Ha Ha....I found the lazyness bug.  It was incrementing the offset of the searched string...most regex I test use that somewhere, but the very simple test did not force it and built a 10^6 deep thunk.  :)
12:47:34 <mmorrow> heh
12:47:42 <quicksilver> TuringTest: ;)
12:47:46 <newsham> sooner or later someone will come in and ask about monads and we can get back to business as normal
12:47:51 <Cheshire> niet, you think you can do haskell
12:47:59 <Cheshire> niet, but is that the same as being able to?
12:48:07 <quicksilver> that's not really called for.
12:49:22 <mmorrow> niet: knowledge doesn't imply intelligence nor does intelligence imply knowledge
12:49:24 <newsham> most 20 year olds dont know haskell, python, java, c++, etc..  not everyone is highly motivated to learn all of those
12:49:42 <Cale> niet: Either they end up not being lucky enough to be exposed to the same things as you, or focus their attention on other things...
12:50:05 <temoto> @w80 expose
12:50:12 <lambdabot> *** "expose" wn "WordNet (r) 2.0"
12:50:12 <lambdabot> expose
12:50:12 <lambdabot>      n : the exposure of an impostor or a fraud; "he published an
12:50:12 <lambdabot>          expose of the graft and corruption in city government"
12:50:12 <lambdabot>          [syn: {unmasking}]
12:50:14 <lambdabot> [30 @more lines]
12:52:22 <temoto> @w80 be exposed
12:52:24 <lambdabot> *** "Be" wn "WordNet (r) 2.0"
12:52:24 <lambdabot> Be
12:52:24 <lambdabot>      n : a light strong brittle gray toxic bivalent metallic element
12:52:24 <lambdabot>          [syn: {beryllium}, {glucinium}, {atomic number 4}]
12:52:24 <lambdabot>      v 1: have the quality of being; (copula, used with an adjective
12:52:26 <lambdabot> [38 @more lines]
12:52:50 <niet> expose yohan radiation
12:52:59 <niet> > expose yohan hug
12:52:59 <lambdabot>   Not in scope: `expose'Not in scope: `yohan'Not in scope: `hug'
12:53:06 <newsham> you're exposed to something if someone has brought it to your attention or you have come across it in your studies
12:53:23 <niet> i know
12:54:15 <Cale> niet: It was temoto who was trying to look it up :)
12:54:23 <sw17ch> niet: what's your favorite data structure?
12:54:24 <sw17ch> :D
12:54:44 * tibbe wonders why you always have to wrap Network.Socket.recv in `try`
12:54:47 <temoto> Like i was exposed to functions composing rules?
12:55:08 <tibbe> somehow a library function that throws an exception during normal use seems strange to me
12:55:10 <Cale> temoto: If you've seen the definition that (f . g) x = f (g x), then yes :)
12:55:28 <pejo> tibbe, on some operating systems (Solaris) you might be interrupted and have to redo the call.
12:55:55 <tibbe> pejo for recv on sockets?
12:56:02 <mmorrow> tibbe: i hate how retvals of -1 + ERRNO=.. are converted (lossily) to exceptions
12:56:11 <newsham> pejo: i thikn its more to do with the library translating EOF into an exception
12:56:14 <tibbe> pejo: the socket library always throws an EOF exception on EOF
12:56:29 <tibbe> pejo: no way to know when you reached EOF so you always get the exception
12:56:32 <mmorrow> actually, i don't like Network.Socket very much at all
12:56:34 <Cale> temoto: What's your native language? Your host is in .ru, but your nick appears Japanese (perhaps) :)
12:56:37 <temoto> Cale: i've seen that before and i used  sum $ filter odd [1..]   but today i learned  map (\xs -> (head xs, length xs)) . group . sort $ "string"
12:57:01 <tibbe> mmorrow: I'm considering changing it in network-bytestring
12:57:09 <tibbe> mmorrow: probably to returning an empty bytestring
12:57:15 <temoto> Cale: russian.
12:57:29 <tibbe> mmorrow: or possibly Nothing
12:58:10 <ErhardtMundt> hello BONUS :)
12:58:27 <temoto> Cale: i tried to create a nick that is not taken, and i almost successed.
12:58:31 <pejo> tibbe, hm, apparently recv() is safe, but read() can give EAGAIN.
12:58:32 <newsham> do any recv's return empty string prior to throwing EOF or is the exception your first indication?
12:58:50 <Cale> temoto: :)
12:58:54 <tibbe> pejo: ok, we retry on EAGAIN in network-bytestring
12:58:56 <pejo> tibbe, still, you can get EINTR on recv().
12:59:05 <tibbe> newsham: exception is the first indication
12:59:06 <newsham> pejo: dont the haskell runtime/libs hide that?
12:59:21 <newsham> tibbe: perhaps make it the second indication and you can have it both ways
12:59:27 <tibbe> pejo: I think we should retry on EINTR as well
12:59:32 <pejo> newsham, they might, I hope so.
13:00:01 <tibbe> newsham: right, if you call recv on a socket that previously returned an empty bytestring indicating EOF you should get an exception
13:00:17 <temoto> sw17ch: how could there be "favourite datastructure"?
13:00:46 <mmorrow> one thing in particular that's impossible with current Network.Socket is to `accept' nonblockingly
13:00:50 <sw17ch> temoto: for example, mine is a Trie: http://en.wikipedia.org/wiki/Trie
13:01:13 <tux_rocker> why can't i find anything like PHP's explode() or perl's split() in Data.List?
13:01:14 <osfameron> I like the Enfilade
13:01:14 <tibbe> newsham: it seems like you get 0 as a return value every time you call recv after the socket has been closed
13:01:29 <newsham> right
13:01:32 <tibbe> mmorrow: oh, I though it was non-blocking
13:01:34 * tibbe goes check
13:01:35 <osfameron> tux_rocker: there's now Data.Split
13:01:39 <sw17ch> tux_rocker: check out the split package on hackage: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
13:01:50 <sw17ch> osfameron: it's Data.List.Split
13:01:55 <osfameron> oops
13:01:56 <newsham> you also get zero when you recv/read on it if its non-blocking and not selected for reading (no data available)
13:02:00 <osfameron> well, that one anyway :-)
13:02:17 <newsham> but at eof, it will select for reading
13:02:23 * tux_rocker goes to look
13:02:27 <ziman> will we be programming reducerons some day? :)
13:02:54 <sinelaw> Does "implementing functional programming in hardware"  make any sense at all?
13:03:00 <temoto> sw17ch: looks like a Huffman tree.
13:03:03 <tibbe> newsham: oh so you can get 0 on non-EOF, interesting
13:03:08 <jfredett> Performance related question -- how much faster/slower is bytestring as compared to string wrt parsing w/ parsec, regex matching, etc?
13:03:08 <mmorrow> tibbe: i'm pretty sure that when you do that accept returns -1 and a particular value of errno means that nothing is trying to accept (and not some other error), but Network.Socket just turns every -1 retval into an exception and doesn't retain the info about what happened
13:03:26 <mmorrow> *...nothing is trying to connect...
13:03:32 <jfredett> is it worth devoting alot of time to now- to avoid big refactoring later?
13:03:34 <sw17ch> temoto: : it's linked on the "See also" section :)
13:03:45 <sinelaw> i'm thinking about desiging a cpu that will be designed a-priori for functional programming
13:03:46 <tibbe> mmorrow: i wonder if that could be improved
13:03:47 <mmorrow> but i'd love to be wrong about this :)
13:03:55 <mmorrow> tibbe: yeah, that would be great
13:03:59 <sinelaw> err....wrong grammar, but the idea should get through that sentence :
13:04:13 <StoneToad> jfredett: try to set it up so it wont be big refactoring?
13:04:19 <sinelaw> does the idea make any sense at all?
13:04:42 <temoto> sw17ch: it is :)
13:04:44 <jfredett> StoneToad: well, I don't mind devoting some time now- while its small, rather than later, when it inevitably is less small...
13:04:45 <mmorrow> it'd be easy to do so to, but i guess there's a decision you'd have to make (whether to use exceptions at all, or just expose the C interface verbatim)
13:04:53 <tibbe> mmorrow:                  throwErrnoIfMinus1Retry_repeatOnBlock "accept"
13:04:53 <tibbe> 			(threadWaitRead (fromIntegral s))
13:05:03 <mmorrow> oh sweet
13:05:07 <tibbe> mmorrow: it looks like it uses select for accept on non mingw
13:05:30 <mmorrow> interesting
13:05:43 <jfredett> StoneToad: as it stands, theres really only one module which would need alot of work. and I'm knee deep in refactoring it. I'm just wondering if it'd be better to release sooner w/o Bytestrings, or wait and refactor now.
13:05:44 <tibbe> mmorrow: there's a note about the windows implementation
13:05:47 <sinelaw> i think there is a fundamental problem - CPU's are physical, time-driven systems, and functional programming is time-independent
13:06:02 <pejo> sinelaw, they were just discussing the reduceron.
13:06:03 <LouisJB> is there a version of visual haskell that runs in Visual Studio 2008?
13:06:10 <sinelaw> pejo, what is that?
13:06:19 <temoto> mygod...
13:06:28 <mmorrow> tibbe: wait, so i'm confused. is it currently possible to use the Network.Socket to do a non-blocking call to `accept' ?
13:06:29 <tibbe> mmorrow: the socket is made non-blocking on unix
13:06:40 <tibbe> mmorrow: http://darcs.haskell.org/libraries/network/Network/Socket.hsc
13:06:46 <tibbe> mmorrow: check the accept function
13:07:03 <mmorrow> i've read the code and couldn't manage to figure out how to call accept and to not block
13:07:03 <temoto> LouisJB: please, let at least Haskell be free of MS ways.
13:07:09 <pejo> @google reduceron
13:07:10 <lambdabot> http://www.cs.york.ac.uk/fp/reduceron/
13:07:10 <lambdabot> Title: The Reduceron
13:07:17 <tibbe> mmorrow: well your thread will block but using select in the background so it's cheap
13:07:24 <newsham> the haskell socket api is blocking i believe
13:07:32 <newsham> despite the fact that the underlying socket the runtime uses arent
13:07:40 <mmorrow> tibbe: ah, so my situation was i was trying to use my own scheduler
13:07:42 <newsham> you have haskell threads for asynch
13:07:45 <tibbe> newsham: arent?
13:07:52 <tibbe> mmorrow: I see
13:07:53 <mmorrow> so i didn't want ghc's rescheduler to mess with me
13:07:56 <mmorrow> but it was
13:08:03 <newsham> the runtime uses nonblocking sockets to do its job but presents a blocking api to you
13:08:06 <mmorrow> s/rescheduler/scheduler/
13:08:11 <tibbe> the API is blocking but is more efficient than normal C blocking calls since it uses select behind the scenes
13:08:14 <sinelaw> pejo, thanks
13:08:24 * sw17ch wonders if it's possible to gut GHC's scheduler without too much of a problem
13:08:24 <StoneToad> jfredett: oh, no idea then, I'm of the lazy-doing-it-right-the-first-time-so-never-have-to-touch-it-again camp so... not that I actually managed that very well in haskell yet
13:08:31 <newsham> tibbe: how does that make it more efficient?
13:08:32 <mmorrow> i was using epoll
13:08:46 <tibbe> newsham: it's more efficient that using one OS thread per haskell thread
13:08:54 <mmorrow> but Network.Socket as-is can't be used unless you use ghc's scheduler
13:08:55 <temoto> Guys do you know that select() is the most sucking async method?
13:09:02 <Cheshire> temoto, no
13:09:05 <tibbe> newsham: it uses green threads and uses async I/O as an optimization
13:09:13 <jfredett> StoneToad: hehe, I think I'll wait and poke around for benchmarks... I'm of the "Just-lazy" camp.
13:09:14 <tibbe> mmorrow: right
13:09:16 <newsham> tibbe: its fairly standard in unix to use either a single thread or a select-based event loop
13:09:25 <tibbe> mmorrow: we want epoll instead of select in the RTS
13:09:33 <mmorrow> tibbe: yay! :)
13:09:33 * jfredett :: (Maybe Productive, Maybe Not)
13:09:47 <tibbe> newsham: right, so the I/O manager is doing the select
13:09:57 <Gracenotes> Either Productive Not ;)
13:09:57 <temoto> The only reason to use select() is to get equally bad performance on Windows and UNIX w/o rewriting low level code.
13:10:12 <StoneToad> jfredett: hey, if you don't have to optimize it because it's not a major speed difference, you didn't have to touch it!
13:10:14 <blackh> newsham: The efficiency is because OS threads are virtual memory hogs
13:10:17 <tibbe> temoto: well, we want epoll :)
13:10:21 <temoto> On Windows it is better to use their native async WinAPI.
13:10:35 <temoto> On Linux it is better to use rtsig or epoll.
13:10:46 <temoto> On FreeBSD it is better to use kqueue.
13:10:47 <TuringTest> temoto: And on OS X ?
13:10:54 <temoto> see BSD :)
13:11:03 <jfredett> StoneToad: true that.
13:11:41 <TuringTest> temoto: Very true.  man kqueue come up on OS X.  And OS X uses the regex.h library from FreeBSD â which is quite buggy
13:11:42 <tibbe> temoto: right, people are working on all these things
13:11:44 <temoto> That's why i'd say no one wants to mess with those low level functions but use libraries like libevent or it's successor libev.
13:12:48 <temoto> tibbe: i see. It's just i spotted too many `select` words and it's a very annoying subject for so i must said all that :)
13:12:52 <Riastradh> kqueue(2) on OS X (and perhaps FreeBSD) is a little simplified.  For whatever brain-damaged reason, it doesn't work, for example, on tty file descriptors, or perhaps on any non-socket file descriptors, so it must be composed with select(2) in order to work in general.
13:13:07 <Riastradh> (The same goes for poll(2) on OS X, which is implemented in terms of kqueue(2).)
13:13:10 <temoto> mygod..
13:13:15 <Riastradh> Fortunately, libev already knows how to work around this brain damage.
13:13:17 <Philonous> What would I need to do to force a list  in parallel? would something like walk [] = (), walk (x:xs) = x `par` walk xs work?
13:13:43 <tibbe> temoto: I'd say libevent is too heavy weight for the RTS
13:14:01 <temoto> tibbe: real time system?
13:14:09 <Riastradh> Run-time system.
13:14:22 <mmorrow> tibbe: ah yeah, so i have a darcs repo of that libev binding i was talking about a while back at http://www.moonpatio.com/repos/hsev/
13:14:23 <temoto> huh?
13:14:30 <temoto> tibbe: what do you mean?
13:14:36 <tibbe> temoto: GHC's run time system
13:14:50 <temoto> uhhh AH!!
13:14:54 <tibbe> temoto: too much code to link in
13:14:56 <Riastradh> tibbe, what about libev, which is pretty much just the core event structure of libevent without any extras such as an HTTP client and everything?
13:15:06 <temoto> As in "everything linked into every executable" ?
13:15:06 <tibbe> mmorrow: libev is supposedly more lightweight
13:15:17 <tibbe> Riastradh: right
13:15:39 <tibbe> mmorrow: I see that it's BSD licensed which is good
13:15:52 <temoto> Man i didn't hear about RTS since Delphi.
13:16:13 <mmorrow> tibbe: i like it for sure. the only thing is that if you actually want to use that binding (or any equiv one you write yourself), you have to rewrite your own Network.Socket and System.IO or else ghc crashes your party quick
13:16:23 <temoto> What about like shared libraries?
13:16:36 <temoto> Is it used to deliver small haskell binaries?
13:16:56 <paper_cc> ahem... small Haskell binaries :(
13:17:03 <mmorrow> System.IO is easy enough to replace, but Network.Socket is a total PITA on account of all those structs and misc in the C api
13:17:18 <temoto> Like every windows user heard that problem, like he requires vcl70.dll ?  :)
13:17:41 <paper_cc> is "do\n\t<code...>\n`finally`\n\t<code...>\n" valid Haskell? GHC parses this but LHC doesn't ... *confused*
13:17:57 <temoto> LHC?
13:18:01 <tibbe> mmorrow: I wrote network-bytestring
13:18:03 <paper_cc> @where lhc
13:18:03 <lambdabot> http://lhc.seize.it/
13:18:07 <paper_cc> temoto: ^^
13:18:12 <temoto> As in CERN?
13:18:12 <tibbe> mmorrow: it has gather I/O support
13:18:25 <mmorrow> paper_cc: the LHC parser has like 20+ reduce-reduce errors and a bunch more shift-reduce last time i saw
13:18:34 <tibbe> mmorrow: I would be interested to see what performance we could get GHC to use libev for the RTS
13:18:35 <Gracenotes> dodnondontnno'tnntt'f'ifa'inaanay'lyyl'y
13:18:36 <paper_cc> temoto: no, as in Haskell compiler
13:18:46 <mmorrow> tibbe: cool yeah, i've read your code for network-bytestring
13:18:59 <mmorrow> tibbe: yeah, that would be very interesting
13:19:04 <tibbe> mmorrow: we're cleaning it up a bit and then we'll release
13:19:10 <paper_cc> mmorrow: well, so my indentation is valid?
13:19:14 <mmorrow> tibbe: oh nice. so you're working with bos then?
13:19:31 <bos> disculpe?
13:19:33 <tibbe> mmorrow: I'm patching network to make it expose some internals (the FFI bindings and Storable instance) under a .Internal module
13:19:39 <tibbe> mmorrow: yes
13:19:46 <mmorrow> paper_cc: i'm no sure. either that or you've found a case where the parser pukes
13:19:58 <tibbe> mmorrow: then we should have gather I/O. Then I need someone to write a few Windows patches
13:20:17 <mmorrow> yuk, windows
13:20:22 <tibbe> mmorrow: yes
13:20:34 <tibbe> mmorrow: but it would be nice if the library got widely used
13:20:42 <tibbe> mmorrow: but I'll release it without windows support
13:20:42 <mmorrow> yes]
13:20:47 <tibbe> mmorrow: but accept patches
13:20:47 <mmorrow> hehe
13:20:58 <mmorrow> "patches welcome!"
13:21:05 <tibbe> mmorrow: exactly
13:21:08 * sw17ch wants a cabalized network
13:21:22 <temoto> paper_cc: how is it compared to ghc?
13:21:35 <paper_cc> temoto: it's incomplete =)
13:21:58 <temoto> paper_cc: why would you use it?
13:23:54 <paper_cc> temoto: well, a compiler buildable with Cabal with a runtime consisting of 4 C source files is something wonderful for unusual places (a standalone C environment for example)
13:24:13 <temoto> Is it possible to update running haskell code, suppose it would be run in interpreter?
13:24:41 <paper_cc> temoto: no this isn't possible
13:24:59 <temoto> no erlangish hotswaps?
13:25:28 <paper_cc> temoto: no built-in dynamic stuff AFAIK
13:25:46 <temoto> Ah right, it's dynamic.
13:26:07 <paper_cc> (while you can use hs-plugins and the LLVM binding =) )
13:29:17 <mmorrow> temoto: but there's nothing stopping someone from writing a compiler that can do this (elegantly)
13:31:11 <mmorrow> you'd need to either compile to bytecode and have an interpreter or compile to machine code + have an assembler + have a linker and then compile/assemble/link straight to mem
13:31:34 <mmorrow> if you had that hotswapping would be trivial
13:32:23 <mmorrow> (assuming you got to design the rts/linking-method from the start)
13:33:29 <mmorrow> which rules out compiling to C as a viable way to accomplish hotswapping
13:33:52 <temoto> No way to use C and hotswapping?
13:33:57 <mmorrow> but parts of the rts could be written in C
13:34:20 <temoto> I saw implementation of dynamic code reloading in C.
13:34:20 <mmorrow> temoto: well if you also wrote your own C compiler maybe :)
13:34:47 <mmorrow> temoto: (i'm assuming that calling out to any other program (e.g. gcc) is disallowed)
13:34:51 <temoto> mmorrow: they were only playing with pointers.
13:34:59 <kryptiskt_> you could compile a .so from C and do dlopen
13:35:06 <temoto> no-no they were using usual gcc
13:35:44 <mmorrow> yeah, my ideal system would be completely self-contained
13:36:33 <ehird> yo, lisp machines :P
13:36:37 <ehird> problem solved
13:36:38 <mmorrow> but compiling to C is really nice since it's so portable and once you got the C is completely self-contained
13:36:50 <thoughtpolice> temoto: yes it is possible
13:37:20 <thoughtpolice> hs-plugins has recently been updated for ghc 6.10 and i've successfully used it to write code that can update dynamicaly
13:37:53 <mmorrow> sure, but you are at the mercy of ghc and its megabytes upon mebabytes of code statically linked into your prog
13:38:21 <thoughtpolice> only on the initial link
13:38:32 <thoughtpolice> when you unload and then reload object files out of memory, they're linked in memory
13:38:32 <mmorrow> and hs-plugins/ghc writes out to multiple tmp files, ghc-api isn't threadsafe, and you depend on ld and as
13:38:56 <thoughtpolice> so you get a kinda slow initial compile of the code, but the idea is to have a shim and load objects into memory
13:39:09 <thoughtpolice> nobody said the situation was perfect
13:39:15 <mmorrow> thoughtpolice: sure, but also you can't garbage collect code in memory
13:39:25 <thoughtpolice> also, the last point isn't a problem if you already have ghc
13:39:32 <thoughtpolice> because you'll need as/ld either way
13:39:41 <mmorrow> thoughtpolice: don't get me wrong. hs-plugins and the ghc-api are awesome.
13:39:50 <mmorrow> i just dream of something better :)
13:39:54 <thoughtpolice> sure
13:40:14 <mmorrow> you don't need ld/as if you have your own linker + assembler
13:40:16 <thoughtpolice> i'm just saying there are working solutions now, and i've used hs-plugins successfully for multi-threaded hot-swapping code
13:40:31 <thoughtpolice> but yes, there should be a more ideal solution
13:40:36 <thoughtpolice> because it would be useful
13:41:25 <mmorrow> sure, so have i. but it's not "hot-swapping" in the sense that you can /replace/ code. you can only augment it.
13:41:54 <mmorrow> by linking more and more into the running image
13:42:36 <mmorrow> but once a given chunk of code is linked, that's all she wrote
13:42:53 * glguy remembers the old days when you could write: do m -> c ...
13:43:18 <temoto> thoughtpolice: thanks.
13:43:50 <seliopou> would it be relevant to bring up erlang in this discussion?
13:43:53 <thoughtpolice> mmorrow: depends if you consider 'unloading and reload updated object files and getting a new function in return' to be replacing, but it's not really that important anyway.
13:43:54 <mmorrow> temoto: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
13:44:06 <thoughtpolice> mmorrow: but yes, there are problems
13:44:17 <thoughtpolice> executable size is one of them unfortunately when you talk with ghc
13:44:38 <thoughtpolice> (strip+gzexe help on that notw fwiw)
13:44:42 <mmorrow> thoughtpolice: (i know i rant about this a lot lately ;) but....) smlnj is friggin sweet
13:44:52 <thoughtpolice> mmorrow: yeah it looks pretty awesome
13:44:54 * mmorrow finds paper/relevant link
13:45:01 <mmorrow> you've gotta see some of this stuff..
13:45:31 <mmorrow> hehe, strip take you from 25MB+ to 14MB+
13:45:31 <thoughtpolice> mmorrow: i normally use mlton but I have smlnj v110.68 installed
13:45:52 <thoughtpolice> mmorrow: i have determined getting the ml-risc system to work with either compiler is impossible :(
13:46:07 <yohan> fialed
13:46:10 <mmorrow> smlnj uses ml-risc
13:46:39 <thoughtpolice> mmorrow: i looked around and I had to try applying patches to files to get examples to work
13:46:51 <mmorrow> thoughtpolice: this is interesting http://www.cs.princeton.edu/~appel/papers/hotslide.ps
13:46:57 <thoughtpolice> mmorrow: but yeah it's a pretty solid compiler. i have appel's book which actually documents it! :)
13:47:02 <thoughtpolice> (circa early 1990s anyway)
13:47:06 <mmorrow> this is awesome: ftp://ftp.cs.princeton.edu/techreports/1989/220.ps.gz
13:47:09 <thoughtpolice> mmorrow: tylere_
13:47:20 <mmorrow> yeah, the fact that all this is from the 90s is whats so amazing to me
13:47:29 <Botje> appel's book ftw.
13:47:56 <pejo> mmorrow, for those of us who don't know the report numbers by heart - what report is that?
13:47:58 <mmorrow> it seems that no one seems to have carried the awesome stuff in smlnj into other compilers
13:47:59 <Cheshire> compiling with continuations ?
13:48:02 <thoughtpolice> Botje: appel's CPS book + spj's fp book = win :)
13:48:10 <Botje> heh, of course.
13:48:15 <mmorrow> pejo: all these links i'm getting from http://www.cs.princeton.edu/~appel/papers/
13:48:23 <Botje> though the appel book really convinced me to write my compiler using CPS
13:48:29 <Botje> and i'm using CPS again for my thesis, so yay!
13:48:30 <thoughtpolice> yeah
13:48:34 <mmorrow> and that one was "A Runtime System"
13:48:37 <thoughtpolice> it covers lots of good stuff
13:48:39 <thoughtpolice> and isn't very big either
13:48:47 <ehird> cps + cheney on the mta, hell yeah!
13:48:56 <mmorrow> Botje: yeah, i remember you using cps in you mini ml compiler
13:49:11 <kerlo> > let True = False in True
13:49:12 <lambdabot>   True
13:49:22 <kerlo> That's not an error yet, I see.
13:49:24 <mmorrow> Botje: is there still a darcs repo for that btw?
13:49:28 <Botje> mmorrow: yup
13:49:36 <mmorrow> link? :)
13:49:49 <Botje> sec :)
13:50:00 <Botje> have to dig it out of my home folder
13:50:10 <Botje> http://infogroep.be/~dharnie/milc
13:50:37 <mmorrow> sweet, thx
13:52:44 <Botje> still needs a decent type system and a garbage collector, though
13:53:05 <Botje> okay
13:53:08 <Botje> back to writing slides
13:53:14 <Botje> need to present these in 12 hrs :)
13:53:26 <mmorrow> heh
13:53:28 <Cheshire> eep
13:57:15 * TuringTest stares the worst case in the face an runs out of patience
14:01:21 <camio> Anyone know where I can find a non-lazy hGetContents?
14:03:17 <Botje> make it yourself!
14:03:43 <Botje> do { foo <- hGetContents handle; length foo `seq` return foo }
14:05:15 <camio> Thanks
14:05:32 <camio> I don't like that defn. too much, but it'll do the job.
14:05:59 <camio> Hrm, how could I do it without the arbitrary 'length'?
14:06:24 <mmorrow> you can use Control.Parallel.Strategies.rnf
14:06:27 <Botje> last foo ? :)
14:06:31 <Botje> or deepSeq
14:07:17 <mmorrow> \h -> do a <- hGetContents h; rnf a `seq` hClose h; return a
14:08:20 <camio> Thanks, rnf seems like the best soln.
14:08:54 <seliopou> camio: What about Data.Bytestring?
14:09:05 <seliopou> I believe hGetContents is strict in that module
14:09:33 <mmorrow> that'd be faster that using a String too
14:10:31 <camio> seliopou: Yeah, I was aware of that. I'm using other libs that don't support ByteString yet. That'll be a future modification.
14:10:36 <Spockz|lap> A friend of mine has an G4 PowerBook and he has problems installing GHC through macports. Should I be here for help, or in the macports channel?
14:12:10 <Riastradh> Spockz|lap, write a clear, concise description of the problem, including output from `port -d install ghc', so that you can, with little effort, ask the same question in multiple channels or on mailing lists.
14:13:20 <Spockz|lap> Ok Riastradh, I'll compile that. :)
14:23:00 <jkup> how could one write this program without using the (.) operator? "main = interact(show . lines)"
14:23:17 <kerlo> @hoogle randomR
14:23:18 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:23:18 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
14:23:18 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
14:23:18 <dolio> interact (\x -> show (lines x))
14:23:24 <roconnor> @unpl (show . lines)
14:23:24 <lambdabot> (\ c -> show (lines c))
14:23:33 <ehird> has anyone done a hack to let you use in-file stuff in ghci?
14:23:47 <ehird> like :toplevel data Foo a = Nil | Foo a (Foo a)
14:23:50 <kerlo> @hoogle randomIO
14:23:50 <lambdabot> System.Random randomIO :: Random a => IO a
14:23:51 <Gracenotes> or, without lambdas, main = interact lineit where lineit x = show (lines x)
14:24:12 <jkup> thanks
14:24:13 <dolio> ehird: Not that I know of.
14:24:22 <ehird> dolio: graah
14:24:23 <dolio> And that seems like something I'd know about.
14:24:31 <ehird> it haunts me daily
14:24:54 <dolio> Or, someone talked about something like that.
14:25:04 <dolio> But it was quite a hack.
14:25:27 <ehird> the whole point of the REPL is to hack ;)
14:25:29 <dolio> Some kind of shell script wrapper around ghci that wrote to a file and reloaded ghci all the time or something.
14:26:02 <ehird> heh, my idea was similar
14:26:11 <ehird> wrap ghci, if there's a syntax error, append to file and :load
14:26:19 <ehird> if that fails, revert change and display original syntax error
14:28:11 <bremner> Is http://www.haskell.org/haskellwiki/Generic_number_type#squareRoot  really the best way to compute square roots of large integers?
14:28:31 <kerlo> Yay, I got codepad to do a merge sort of 2309 Ints: http://codepad.org/0GaPG6kC
14:28:37 <ehird> "The most efficient way is to call the native implementation of the square root of GNU's multiprecision library."
14:28:38 <ehird> haha
14:29:21 <kerlo> Did somebody say generic number type?
14:29:59 <dolio> Someone should really get around to wrapping up more of GMP in a library.
14:30:33 <dolio> Maybe I'll start looking into that again.
14:30:40 <kerlo> > (2.0 * 3.0 - 6.0)**(1.0/3.0)
14:30:41 <lambdabot>   0.0
14:30:57 <kerlo> Darn.
14:31:12 <kerlo> > (3.0 * 5.0 - 15.0)**(1.0/5.0)
14:31:13 <lambdabot>   0.0
14:31:37 <kerlo> > (5.0 * 8.0 - 40.0)**(1.0/5.0)
14:31:38 <lambdabot>   0.0
14:31:44 <dolio> I don't think you'll have problems with that until you get rather large numbers.
14:31:53 <kerlo> > (5.0 * 8.0 - 40.0)**(1.0/999.0)
14:31:54 <lambdabot>   0.0
14:32:00 <dolio> On the left.
14:32:43 <kerlo> > (sum (replicate 100 0.1) - 10.0)**(1.0/999.0)
14:32:44 <lambdabot>   NaN
14:32:48 <kerlo> > (sum (replicate 100 0.1) - 10.0)**(1.0/3.0)
14:32:50 <lambdabot>   NaN
14:33:05 <kerlo> > (sum (replicate 100 0.1) - 10.0)
14:33:06 <lambdabot>   -1.9539925233402755e-14
14:33:12 <yohan> lohl
14:33:23 <kerlo> Why can't I take the cube root of that?
14:34:05 <dolio> Hmm...
14:34:42 <dolio> > 0.1 ** (1/3)
14:34:43 <lambdabot>   0.4641588833612779
14:34:49 <dolio> > (-0.1) ** (1/3)
14:34:50 <lambdabot>   NaN
14:35:15 <tromp_> (1/3)*3
14:35:21 <tromp_> > (1/3)*3
14:35:22 <lambdabot>   1.0
14:35:25 <dolio> > (-1) ** (1/3)
14:35:26 <lambdabot>   NaN
14:35:45 <dolio> Doesn't like negatives, I guess.
14:36:02 <osfameron> maybe it doesn't not like positives
14:36:25 <kerlo> I have a better function, though.
14:36:35 <tromp_> >  (-1) ** (1/3) :: CReal
14:36:37 <lambdabot>   * Exception: log of negative number
14:36:37 <kerlo> Take the natural log, then the opposite, then the reciprocal, then the square root.
14:36:44 <olsner> maybe it doesn't not like non-negatives
14:37:05 <jkup> > (-1/10) ** (1/3)
14:37:06 <lambdabot>   NaN
14:37:19 <kerlo> Has someone been telling lambdabot that an exponent between 0 and 1 is a log again?
14:37:23 <tromp_> >  (-1) ** (1/2)
14:37:24 <lambdabot>   NaN
14:37:38 <kerlo> > log 2.718281828
14:37:39 <lambdabot>   0.9999999998311266
14:37:39 <dolio> > (-1) ** 2
14:37:40 <Cheshire> >  (-1) ** (1/2) :: Complex
14:37:41 <lambdabot>   1.0
14:37:41 <lambdabot>       `Complex' is not applied to enough type arguments
14:37:41 <lambdabot>      Expected kind `?...
14:37:48 <olsner> or is it not just that it doesn't not like non-negatives?
14:37:49 <dolio> > (-1) ** 2.5
14:37:49 <Cheshire> >  (-1) ** (1/2) :: Complex Rational
14:37:51 <lambdabot>   NaN
14:37:51 <lambdabot>       No instance for (RealFloat (Ratio Integer))
14:37:51 <lambdabot>        arising from a use o...
14:38:00 <Cheshire> >  (-1) ** (1/2) :: Complex CReal
14:38:02 <lambdabot>   0.0 :+ 1.0
14:38:32 <kerlo> > let steep x = sqrt(-1/(log x)) in steep 0.1
14:38:33 <lambdabot>   0.6590102289822608
14:38:48 <kerlo> > let steep x = sqrt(-1/(log x)) in steep (iterate (*0.1) 1)
14:38:49 <lambdabot>       No instance for (Floating [a])
14:38:49 <lambdabot>        arising from a use of `steep' at ...
14:38:56 <kerlo> > let steep x = sqrt(-1/(log x)) in map steep (iterate (*0.1) 1)
14:38:57 <lambdabot>   [NaN,0.6590102289822608,0.4659906017846561,0.3804797331016252,0.32950511449...
14:39:20 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 4 (map steep (iterate (*0.1) 1))
14:39:21 <lambdabot>   [0.3295051144911304,0.29471833397440744,0.2690397993802069,0.24908245390497...
14:39:29 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 7 (map steep (iterate (*0.1) 1))
14:39:30 <lambdabot>   [0.24908245390497036,0.23299530089232806,0.21967007632742028,0.208397332493...
14:39:36 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 10 (map steep (iterate (*0.1) 1))
14:39:37 <lambdabot>   [0.20839733249330517,0.19869906023094136,0.1902398665508126,0.1827765516654...
14:39:44 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 13 (map steep (iterate (*0.1) 1))
14:39:45 <lambdabot>   [0.18277655166544662,0.1761278922307902,0.17015570945524217,0.1647525572455...
14:40:07 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 20 (map steep (iterate (*0.1) 1))
14:40:08 <lambdabot>   [0.14735916698720372,0.1438078218124472,0.14050145290469288,0.1374131317538...
14:40:14 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 30 (map steep (iterate (*0.1) 1))
14:40:16 <lambdabot>   [0.12031825601340967,0.11836173121509304,0.11649765044616403,0.114718955912...
14:41:00 * Botje can't wait to see the next line
14:41:25 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 30 (map (round . (*1000) . steep) (iterate (*0.1) 1))
14:41:26 <lambdabot>   [120,118,116,115,113,111,110,108,107,106,104,103,102,100,99,98,97,96,95,94,...
14:41:28 <magthe> Within 5 minutes I've wanted a function that applies two functions to the same input and returns the results in a tuple... it feels like the type of function that would already exist... does it?  Something along (a -> b) -> (a -> c) -> a -> (b, c)
14:41:40 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 50 (map (round . (*1000) . steep) (iterate (*0.1) 1))
14:41:41 <lambdabot>   [93,92,91,91,90,89,88,87,87,86,85,84,84,83,82,82,81,81,80,79,79,78,78,77,77...
14:41:52 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 70 (map (round . (*1000) . steep) (iterate (*0.1) 1))
14:41:53 <lambdabot>   [79,78,78,77,77,76,76,75,75,74,74,73,73,72,72,71,71,71,70,70,69,69,69,68,68...
14:42:01 <seliopou> magthe: (&&&)
14:42:04 <Saizan> magthe: (&&&) from Control.Arrow
14:42:04 <kerlo> It's a really steep function.
14:42:05 <seliopou> in Control.Arrow
14:42:28 <magthe> ah, thanks... I had a nagging suspicion I might be led in that direction, haha
14:42:32 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 90 (map (round . (*1000) . steep) (iterate (*0.1) 1))
14:42:33 <lambdabot>   [69,69,69,68,68,68,67,67,67,66,66,66,65,65,65,64,64,64,63,63,63,63,62,62,62...
14:42:45 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 150 (map (round . (*1000) . steep) (iterate (*0.1) 1))
14:42:46 <lambdabot>   [54,54,53,53,53,53,53,53,52,52,52,52,52,52,51,51,51,51,51,51,51,50,50,50,50...
14:42:53 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 300 (map (round . (*1000) . steep) (iterate (*0.1) 1))
14:42:55 <lambdabot>   [38,38,38,38,38,38,38,38,38,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,0,...
14:43:02 <kerlo> > let steep x = sqrt(-1/(log x)) in drop 1000 (map (round . (*1000) . steep) (iterate (*0.1) 1))
14:43:03 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:43:08 <kerlo> Aha!
14:43:11 <ViaToR_SG> ouch!
14:43:14 <Gracenotes> amwahahaha
14:43:23 <hackage> Uploaded to hackage: HDBC-mysql 0.4
14:43:23 <hackage> Uploaded to hackage: data-accessor-mtl 0.2
14:43:23 <hackage> Uploaded to hackage: data-accessor-monads-fd 0.2
14:43:23 <hackage> Uploaded to hackage: data-accessor-transformers 0.2
14:43:42 <kerlo> Those zeros are all rounding error, of course. It finally multiplied by 0.1 so much that it went all the way to 0.
14:44:28 <liff>  /away unta
14:48:18 <Gracenotes> hm. Prompted by a SO question, what's so-called 'lambda lifting' in the context of Haskell? Currying?
14:49:09 <ehird> err, just regular lambda lifting
14:49:12 <ehird> it's not really that interesting
14:49:16 <Gracenotes> i.e. partial application. Well, that'll only work if it's the last parameter
14:49:22 <ehird> http://en.wikipedia.org/wiki/Lambda_lifting
14:49:23 <Gracenotes> :x
14:49:30 <ehird> lambda lifting != partial application
14:49:50 <Gracenotes> does Haskell utilize it?
14:50:38 <ehird> implementation specific
14:50:41 <ehird> but no, none do afaik
14:51:43 <pejo> Gracenotes, lambda lifting is apparently a performance optimization for ghc.
14:52:00 <Gracenotes> er, yeah, sorry, GHC != Haskell.
14:52:12 <Gracenotes> an optimization's an optimization, though
14:52:13 <Gracenotes> :)
14:52:14 <pejo> Gracenotes, what does "SO" mean?
14:52:29 <roconnor> speical orthoginal
14:52:51 <Gracenotes> Stack Overflow, a site containing people asking Enterprise Quality questions and receiving Enterprise Quality answers
14:53:01 <pejo> Gracenotes, it depends on your compiler backend, some backends can't handle local functions.
14:53:37 <Gracenotes> it's a pretty good idea, I think. Anyway, URL http://stackoverflow.com/?sort=hot
14:53:52 <Gracenotes> http://stackoverflow.com/questions/592584/what-is-lambda-lifting
15:07:25 <Eljugador> www.eljugador.net
15:07:25 <Eljugador> www.eljugador.net
15:07:26 <Eljugador> www.eljugador.net
15:08:42 <monochrom> hard sell :)
15:16:39 <Gracenotes> I can't even tell what that page is about
15:17:03 <dons> interesting way to talk about an FFI http://merjis.com/developers/perl4caml
15:17:03 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
15:18:45 <PeakerWork> I just realized "TDD" can also mean type-driven-development :) thinking and writing down the types first, and then implementing
15:18:49 <PeakerWork> probably something that most Haskellers do
15:19:01 <Cheshire> I do the thinking bit..
15:19:26 <drdozer> PeakerWork: a bit of sig first, a bit of impl first - depends
15:19:48 <drdozer> PeakerWork: I often write classes and use them before writing instances
15:19:56 <PeakerWork> -Wall forces you to specify all the top-level types anyway, so why not do that first?
15:20:18 <drdozer> because sometimes the types are a pig to work out - easier to make it compile and ask ghci
15:20:51 <monochrom> I write the = sign first before the lhs and rhs.
15:22:02 <PeakerWork> drdozer: any examples of such a case?
15:22:38 <BONUS> PeakerWork: i guess stuff including monad transformers and multiparam typeclasses sometimes
15:24:08 <PeakerWork> I think if its hard to figure out the type, its hard to implement it correctly too
15:24:45 <Saizan> the type might just be long :)
15:24:48 <BONUS> PeakerWork: one example that i can think of where the type is hard to figure out but the implementation easy is the parameterized state monad
15:25:04 <BONUS> from sigfpe's latest blog post
15:25:08 <PeakerWork> ah, yeah
15:25:19 <lilac> i hear with type families it's sometimes non-obvious what the right type is
15:25:20 <BONUS> it's PState s1 s2 a = PState (s1 -> (a,s2))
15:25:31 <Ornedan_> This is O(l^2), I think: dropEach l = case l of [] -> []; (x:xs) -> xs:map (x:) (dropEach xs)
15:25:41 <BONUS> and the impleemntation is like State, but the type is hard to figure out unless you know the intuition for it before
15:25:41 <Ornedan_> How do I get an equivalent O(l)?
15:25:56 <BONUS> i'd say it's rare but sometimes it's easier to implement something than figure out the type
15:26:01 <Ornedan_> I know how I'd do it if I had O(1) ++, but I don't :P
15:26:07 <roconnor> is the parameterized state monads in a slice category?
15:26:13 <PeakerWork> Ornedan_: do you know about DList?
15:26:21 <Ornedan_> PeakerWork: Nope
15:26:30 <lilac> Ornedan_: isn't your result list size O(l^2)?
15:26:34 <PeakerWork> Ornedan_: DList has O(1) ++ but you can't read the list until you're done building it
15:27:10 <PeakerWork> (or rather, reading it before you're done will defeat the purpose)
15:27:12 <Gracenotes> it has regular O(n) traversal-of-the-whole-list, though, right?
15:27:36 <Gracenotes> hm, no reason why it shouldn't
15:27:42 <PeakerWork> DList basically keeps (x++) instead of x, and then composes those around
15:28:00 <PeakerWork> an efficient implementation of (x++) of course, rather than actually (x++)
15:28:18 <PeakerWork> @hoogle replicate
15:28:18 <lambdabot> Prelude replicate :: Int -> a -> [a]
15:28:18 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
15:28:18 <lambdabot> Data.List replicate :: Int -> a -> [a]
15:28:24 <lilac> @type concat . map (\l -> case l of [] -> []; (x:xs) -> [xs, [x]]) . tails
15:28:25 <lambdabot> forall a. [a] -> [[a]]
15:28:39 <PeakerWork> @index replicate
15:28:39 <lambdabot> Data.List, Prelude
15:28:39 <lilac> > concat . concat . map (\l -> case l of [] -> []; (x:xs) -> [xs, [x]]) . tails $ [1,2,3]
15:28:41 <lambdabot>   [2,3,1,3,2,3]
15:28:54 <lilac> > let dropEach l = case l of [] -> []; (x:xs) -> xs:map (x:) (dropEach xs) in dropEach [1,2,3]
15:28:55 <lambdabot>   [[2,3],[1,3],[1,2]]
15:29:31 <Ornedan_> PeakerWork: Looking at DList, thanks
15:30:48 <lilac> > map (uncurry (++)) . uncurry zip . (drop 1 . tails &&& inits) $ [1,2,3]
15:30:49 <lambdabot>   [[2,3],[3,1],[1,2]]
15:31:59 <lilac> Ornedan_: i think even with maximal sharing, your result list is of size O(n^2), so you can't use []
15:47:40 <tromp_> > 6*7
15:47:41 <lambdabot>   42
15:48:13 <tomh> > product [1..999]
15:48:14 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
15:48:57 <bremner> > product [1..product[1..99]]
15:49:12 <lambdabot>   thread killed
15:50:19 <tomh> hehe
15:50:25 <bolrod> > product [1..product[1..4]
15:50:28 <lambdabot>   <no location info>: parse error on input `;'
15:50:35 <bolrod> > product [1..product[1..4]]
15:50:37 <lambdabot>   620448401733239439360000
15:50:49 <tomh> > fromMaybe (Maybe "a")
15:50:50 <lambdabot>   Not in scope: data constructor `Maybe'
15:50:57 <tomh> > fromMaybe (Just "a")
15:50:58 <lambdabot>       Overlapping instances for Show
15:50:58 <lambdabot>                                  (Maybe ...
15:51:11 <Gracenotes> @type fromMaybe
15:51:13 <lambdabot> forall a. a -> Maybe a -> a
15:51:31 <Gracenotes> you may be thinking of the not-entirely-recommended-for-use fromJust
15:51:36 <Gracenotes> ;)
15:51:57 <glguy> unsafeCoerceMaybe
15:51:58 <glguy> ?
15:52:10 <ddarius> safeFromJust = id
15:52:26 <Gracenotes> unsafeOveruseUnsafe
15:53:13 <glguy> maybeToCausuallyIntroducedBug
15:56:44 <tomh> > fromMaybe "" (Just "A")
15:56:45 <lambdabot>   "A"
15:57:31 <tomh> > newIOref []
15:57:31 <lambdabot>   Not in scope: `newIOref'
15:57:40 <Cheshire> monad m = do x <- m ; return x
15:57:40 <kpreid> > newIORef []
15:57:41 <lambdabot>   Not in scope: `newIORef'
15:57:42 <tomh> > newIORef []
15:57:43 <lambdabot>   Not in scope: `newIORef'
15:57:49 <tomh> ah :/
15:57:56 <kpreid> even if it was imported it wouldn't help
15:58:00 <kpreid> > print []
15:58:01 <lambdabot>   * Exception: "<IO ()>"
15:58:30 <kpreid> lambdabot eval never runs an io action
15:58:41 <tomh> > performGC
15:58:42 <lambdabot>   Not in scope: `performGC'
15:58:43 <kpreid> it also doesn't let you refer to  unsafePerformEval
15:58:47 <kpreid> er, unsafePerformIO
15:58:58 <skorpan> unsafePerformEval is bad ass though
15:59:28 <tomh> so there is no way to make labdabot to weird stuff? :)
15:59:35 <tomh> *lambdabot
15:59:50 <Gracenotes> however, you can use an STRef in the ST monad, I think. Not sure.
15:59:57 <kpreid> @y
15:59:57 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . ? @ v
16:00:01 <kpreid> @v
16:00:01 <lambdabot> Just 'J'
16:00:07 <Gracenotes> > runST
16:00:08 <lambdabot>       Overlapping instances for Show ((forall s. ST s a) -> a)
16:00:08 <lambdabot>        arising...
16:00:10 <kpreid> sadly, the real 'v' is dead
16:00:21 <kpreid> > runST $ return 1
16:00:22 <lambdabot>   /tmp/8685906758426659938:70:36: Not in scope: `runST'
16:00:31 <kpreid> (wot?)
16:00:34 <Gracenotes> ..odd
16:01:06 <Gracenotes> > runST $ do { a <- newSTRef 4; readSTRef a }
16:01:07 <lambdabot>   /tmp/2738080778722612509:70:36: Not in scope: `runST'/tmp/27380807787226125...
16:01:31 <Gracenotes> > newSTRef
16:01:32 <lambdabot>       Overlapping instances for Show (a -> ST s (STRef s a))
16:01:32 <lambdabot>        arising f...
16:01:58 <Gracenotes> waitwat
16:02:26 <tomh> > runST $ newSTRef 4 >>= (\x -> readSTRef x) >>= (
16:02:27 <lambdabot>   <no location info>: parse error on input `;'
16:02:29 <tomh> oops
16:02:38 <tomh> > runST $ newSTRef 4 >>= (\x -> readSTRef x) >>= (\x -> return x)
16:02:39 <mle> you got a filename out of it?
16:02:39 <lambdabot>   /tmp/6670427742802827324:70:36: Not in scope: `runST'/tmp/66704277428028273...
16:02:46 <monochrom> > const 0 newSTRef
16:02:47 <lambdabot>   /tmp/8616267175103233549:70:44: Not in scope: `newSTRef'
16:03:23 <mle> > const 0 foo
16:03:24 <lambdabot>   Not in scope: `foo'
16:03:36 <Gracenotes> /tmp/blahblahblah is where lambdabot puts the code to compile it and run it, iirc
16:03:51 <mle> o/~ one of these things is not like the other o/~
16:03:52 <tomh> > let xs = [1..100000000000] in if length > 1 then 1 else 0
16:03:53 <lambdabot>       No instance for (Ord ([a] -> Int))
16:03:53 <lambdabot>        arising from a use of `>' at ...
16:04:03 <tomh> > let xs = [1..100000000000] in if length xs > 1 then 1 else 0
16:04:18 <lambdabot>   thread killed
16:04:29 <skorpan> i still don't understand why length can't be lazy
16:04:36 <ddarius> skorpan: It can be.
16:04:40 <tomh> > if length [1..1000000000000000] > 1 then 1 else 0
16:04:55 <lambdabot>   thread killed
16:04:55 <tomh> how
16:05:09 <tomh> different implementation?
16:05:09 <ddarius> Use a lazy numeric type.
16:05:18 <Gracenotes> length will give you the length. The alternative is checking every single element to see if it's greater than your given length. Certainly not efficient.
16:05:34 <skorpan> Gracenotes: i don't follow
16:05:35 <Gracenotes> something you can do is use a combination of drop and null
16:05:45 <ddarius> > genericLength [0..] > (1 :: Natural)
16:05:47 <lambdabot>   True
16:06:02 <tomh> > if length [1..] > 1 then 1 else 0
16:06:15 <Gracenotes> um, hm. Something I don't know about Natural then
16:06:18 <lambdabot>   mueval: Prelude.read: no parse
16:06:28 <monochrom> A function can only be as lazy as its type allows.
16:06:48 <skorpan> so what about length :: [a] -> Int is strict?
16:06:51 <skorpan> :t length
16:06:51 <Gracenotes> not to mention Natural is a bit inefficient
16:06:55 <lambdabot> forall a. [a] -> Int
16:06:56 <skorpan> or maybe not Int
16:06:59 <skorpan> okay, so Int
16:07:12 <bolrod> > genericLength [0..] > (1000000000000000 :: Natural)
16:07:23 <monochrom> Int is pretty strict.
16:07:27 <lambdabot>   thread killed
16:07:28 <Gracenotes> I dunno. I'd do a combination of drop and null, personally
16:07:32 <skorpan> but what's strict about [a]?
16:07:45 <monochrom> Nothing. But [a] is not the point. Int is the point.
16:07:48 <Gracenotes> > null . drop 1 $ [1..]
16:07:49 <Olathe> > 1 :: Natural
16:07:50 <ozy`> are you pattern matching against [a]?
16:07:53 <lambdabot>   False
16:07:53 <lambdabot>   1
16:08:03 <skorpan> @src length
16:08:03 <lambdabot> Source not found. Maybe you made a typo?
16:08:09 <skorpan> how is length implemented?
16:08:13 <tomh> > dropWhile (> 0) [1..]
16:08:16 <ddarius> @src length
16:08:17 <lambdabot> Source not found. There are some things that I just don't know.
16:08:22 <Olathe> How does it know that genericLength is increasing ?
16:08:28 <lambdabot>   thread killed
16:08:39 <monochrom> If the return type is strict like Int there is no lazy implementation of length.
16:08:47 <skorpan> why not?
16:09:00 <bolrod> > let {length [] n = n; length (x:xs) n = length xs (n+1)} in length [1..10]
16:09:01 <lambdabot>       Overlapping instances for Show (a -> a)
16:09:01 <lambdabot>        arising from a use of `s...
16:09:07 <bolrod> hm
16:09:11 <Saizan> because you can only return one single Int and all at a time
16:09:12 <bolrod> > let {length [] n = n; length (x:xs) n = length xs (n+1)} in length [1..10] 0
16:09:15 <lambdabot>   10
16:09:20 <Saizan> so you've to consume the list first.
16:09:31 <skorpan> is Integer strict as well?
16:09:41 <Gracenotes> a natural is basically a list, anyway. may as well declare an number instance for [()]
16:09:41 <monochrom> I have a secret list xs. Without asking me anything about xs, tell me it's length.
16:09:48 <ozy`> skorpan: consider evaluating "x > 0"... you can't answer that for x :: Int unless x has been fully evaluated
16:09:49 <monochrom> Integer is also strict.
16:10:12 <skorpan> how do you know whether a type is "strict" or not?
16:10:25 <Olathe> > (1 :: Natural) - 1
16:10:27 <lambdabot>   0
16:10:30 <skorpan> ozy`: that makes sense
16:10:33 <monochrom> Not always well-documented.
16:11:18 <skorpan> so instead of seeing (length xs) > 0, what ghc sees is (some Int) > 0, is that why?
16:11:21 <Gracenotes> http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/src/Data-Number-Natural.html
16:11:25 <monochrom> Yes.
16:11:37 <skorpan> makes my brain explode!
16:12:29 <mle> for naturals, wouldn't > n be lazy beyond n, but <n be strict?
16:12:40 <Saizan> yeah, it doesn't try to "fuse" the comparison in the recursive definition for length
16:12:52 <ozy`> skorpan: it's possible to define a "numeric" type that is significantly lazier than Int with such operations. implementing this is left as an exercise for the reader ;)
16:13:06 <Gracenotes> heh, "efficiency isn't the point of this module"
16:13:15 <Gracenotes> lazy numbers, always being inefficient
16:13:20 <Gracenotes> goshdarn
16:13:20 <skorpan> now for something completely different: where does "++" come from? is this some universal symbol for concatenation that i don't know about?
16:13:38 <monochrom> Yes.
16:14:09 <skorpan> what is it called? where is it on wikipedia?
16:14:24 * QtPlatypus has never seen it used as such. "Though I've noticed lots of diffrent symbols for concatination"
16:14:33 <mmorrow> i just changed my mind about having (++) in Monoid .... it think (+) should be mappend
16:14:43 <ozy`> skorpan: a lot of languages use + for concatenation. aside from that there's not really a standard....
16:14:59 <Gracenotes> butbutbutconflictwith(+)inNum
16:15:01 <QtPlatypus> Overloading + for concatenation is nasty.
16:15:02 * koninkje hates (+) for concatenation
16:15:06 <augustss> I think + for concatenation sucks.  I think commutative when I see +
16:15:16 <mmorrow> yeah, that's true
16:15:20 <QtPlatypus> augustss: Likewise.
16:15:26 <mmorrow> ok, i just changed my mind back
16:15:27 <Saizan> * then
16:15:30 <ozy`> yes, overloading + for concatenation would have been in significant conflict with the aims of haskell
16:15:31 <skorpan> so did anyone have a name for this symbol "++"?
16:15:35 <Olathe> (+) s1 s2 = sort (s1 ++ s2)
16:15:35 <mauke> we should use . for mappend, that's compatible with perl :-)
16:15:38 <Olathe> Commutative !
16:15:42 <ozy`> skorpan: plusplus :p
16:15:44 <mmorrow> ozy`: what does that mean?
16:15:51 <mmorrow> "the aims of haskell"
16:15:59 <koninkje> not sucking?
16:16:10 <mmorrow> Gracenotes: (clearly i'm not a fan of Num as-is ;)
16:16:11 <ozy`> mmorrow: koninkje just said it best :p
16:16:20 <mmorrow> koninkje: and why would that suck?
16:16:34 <augustss> skorpan: I'm trying to remember what Miranda used for concatenation, it might have been ++.  If not, it started with Haskell.
16:16:40 <mmorrow> i think (++) for lists sucks
16:16:53 <mmorrow> since it steals a nice symbol for a particular use
16:17:02 <ozy`> augustss: I'm sure I've seen at least one language before haskell that uses ++ for concatenation
16:17:03 <mmorrow> when it could be in Monoid
16:17:10 <Gracenotes> mmorrow: what? Do you think Num should recognize its abstract-algebraic quote-roots-unquote? :)
16:17:14 <koninkje> mmorrow: Well, a handful of active folks here all dislike it, so chances are a significant portion of the community will agree. Upsetting the community == suckage
16:17:15 <skorpan> i hear C++ .. never mind.
16:17:26 <monochrom> â is still available
16:17:29 <koninkje> (or `elem` rather)
16:17:36 <skorpan> so please, anyone, what is the symbol called? :(
16:17:44 <augustss> there and many beautiful unicode operators
16:18:01 <Gracenotes> augustss: http://unicodesnowmanforyou.com/
16:18:08 <monochrom> I do not understand why symbols must have names.
16:18:13 <koninkje> mmorrow: I'm all for (++) replacing mappend in Monoid, FWIW
16:18:19 <skorpan> augustss: and in emacs we C-x 8 RET to get them!
16:18:25 <monochrom> (I mean names beyond "plus plus" for ++ for example)
16:18:30 <mle> urg, how does yi in emacs mode do M- commands?
16:18:34 <mmorrow> Gracenotes: it'd be nice if we could build rings out of a group + a monoid
16:18:36 <skorpan> monochrom: so that i can read about it on wikipedia :P
16:18:36 <mle> it doesn't seem to like Esc
16:18:44 <ozy`> mle: gotta use meta, I think
16:18:53 <mle> on a terminal?
16:18:55 <ozy`> mle: good luck to you if you don't have a meta key....
16:18:57 <mmorrow> koninkje: dislike what?
16:19:02 <monochrom> Do you like "concatenation"?
16:19:03 <skorpan> i use meta on terminal yi
16:19:12 <skorpan> monochrom: the *symbol*
16:19:13 <mle> sure, but it isn't doable from all terminals
16:19:16 <mmorrow> koninkje: "a handful of active folks here ..."
16:19:22 <koninkje> mmorrow: using (+) for concatenation. ...Or I may have been mixing conversations...
16:19:39 <monochrom> I understand less now. What is wrong with search for ++ on wikipedia?
16:19:42 <mmorrow> koninkje: ah, i've already changed my mind since (+) is by convention commutative
16:19:49 * koninkje nods
16:20:03 <skorpan> monochrom: it doesn't tell me anything about the ++ symbol (with the plus signs not as separate symbols but as one longer symbol)
16:20:23 <skorpan> hm, maybe if i just copy the symbol from the yi source code and search for that...
16:20:28 <monochrom> You can create a new page for ++, you know...
16:20:40 <skorpan> monochrom: ++ already exists but is about "increment"
16:20:56 <monochrom> edit that page and talk about haskell concatentation.
16:21:08 <skorpan> monochrom: but then what do i learn? nothing.
16:21:16 <skorpan> it also seems like the yi source code is missing the ++ symbol
16:21:58 <ErhardtMundt> bye
16:22:28 <koninkje> skorpan: There's a friend of mine who, whenever he wants to learn something, will start a stub page on Wikipedia with what he already knows. When he comes back in a few weeks, some gurus have almost always found it and fleshed it out
16:22:34 <koninkje> (social engineering)++
16:22:34 <monochrom> I don't see what is there to learn about the ++ symbol beyond knowing what it does in Haskell and how to do it. Does anyone know? Please tell me.
16:23:15 <skorpan> monochrom: i'd like to know when it was first used and for what. i'm into useless knowledge.
16:23:34 <ozy`> monochrom: skorpan seems to be under the mistaken impression that syntax, and life in general, has some kind of actual meaning beyond the utterly superficial
16:23:54 <mmorrow> skorpan: i always assumed it was because appending is analogous to "adding" the lists
16:23:56 <skorpan> ozy`: was that really necessary?
16:24:09 <ozy`> skorpan: I kid :p
16:24:26 <skorpan> oh, sorry... it wasn't that obvious. :P
16:24:46 <ozy`> skorpan: hmm, I thought the "life is meaningless" part would have given it away... oh well
16:25:10 <mmorrow> koninkje: haha, that's an excellent idea
16:25:18 * mmorrow starts scheming
16:25:19 <ozy`> anyway, (++) is almost but not entirely similar to (+)
16:25:28 <ozy`> that's as good an explanation as any
16:25:47 <dons> ?bug
16:25:47 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:26:03 <mmorrow> @spider
16:26:03 <lambdabot> Unknown command, try @list
16:26:09 * QtPlatypus nods "I think it was picked arbiternally"
16:26:35 <QtPlatypus> arbitrarly
16:26:42 <skorpan> @src concat
16:26:42 <lambdabot> concat = foldr (++) []
16:26:58 <mmorrow> @source mconcat
16:26:58 <lambdabot> mconcat not available
16:27:09 <mmorrow> mconcat = foldr mappend mempty
16:27:13 <mmorrow> (default def)
16:27:23 <mauke> @src mconcat
16:27:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:27:50 <skorpan> rocket surgeon*
16:29:13 <mmorrow> Saizan: yeah, (*) could be nice for Monoid
16:29:22 <mmorrow> class Monoid a where one :: a; (*) :: a -> a -> a
16:29:55 <mauke> that would look weird in sortBy
16:30:07 <newsham> If I were to do    print . sort . lines =<< getContents   on a large file how much heap space would that take?  how much stack space?
16:30:08 * koninkje prefers (+),(*) as defining Semiring
16:30:20 <newsham> is all of the sorting happening on the stack?
16:30:28 <mmorrow> class (Monoid a) => Group a where inverse :: a -> a
16:31:19 <mmorrow> koninkje: Semi_ are boring though since they don't even have an identity ==> not much useable structure
16:31:20 <koninkje> Though I've yet to see a nicely simple presentation of Monoid,Semiring,Group,Ring,Field...
16:32:02 <koninkje> mmorrow: semirings aren't boring in the slightest. They're used all over the place in NLP and statistical modeling. I find Rings are more boring
16:32:24 <Saizan> newsham: you need to have all the file in memory at some point, in the heap
16:32:28 <koninkje> Often the semirings are boolean algebras, but not always with some of the esoteric ones
16:33:03 <mmorrow> koninkje: boolean algebras are boring, since they're just degenerate heyting algebras ;)
16:33:14 <newsham> saizan; *nod* but how much space on heap vs. stack?
16:33:15 * mmorrow likes inciting rage
16:33:20 <mmorrow> :)
16:33:23 <koninkje> mmorrow: sure sure :)
16:33:42 <koninkje> It's the negation that makes Rings so much less common, interestingness aside
16:34:27 <Saizan> @source Data.List
16:34:27 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:34:47 <mmorrow> yeah, if you're not doing math and _starting_ with a A, i can see how using a semiA and just adding an id when needed may be more convenient
16:36:47 <koninkje> id usually isn't the problem (for which just do Eq,SemiA :)  As I said, it's usually the negation. Though the Show in Haskell can be annoying at times as well
16:37:48 <mmorrow> wait, what are you considering as the definition of semiring here?
16:38:48 <mmorrow> because i think your semiring might be what i'm considering to be a ring
16:38:57 <koninkje> (S,+,*,0,1) where (S,+,0) a monoid, (S,*,1) a monoid, and 0 is the left-/right-zero of *
16:39:25 <mmorrow> ok, that's a ring in my book :)
16:39:31 <koninkje> Also I think + must be commutitive, I forget off hand. * doesn't need to be (else "commutitive semiring")
16:39:58 <koninkje> Rings add the additional requirements that there must be a negate operation on S, mutatis mutandis
16:40:05 <mmorrow> so i guess what you're considering to be a proper ring, i'd call a field
16:40:17 <mmorrow> ohhhhh
16:40:19 <mmorrow> nevermind
16:40:32 <koninkje> I seem to regall there's something extra in a field, but that's not my, er, field :)
16:40:38 <mmorrow> wait a sec
16:41:03 <mmorrow> ok, so i just glossed over the fact that you don't have a group (+,0)
16:41:16 <koninkje> A nice inclusion chain is at the top of http://en.wikipedia.org/wiki/Field_(mathematics)
16:41:19 <mmorrow> ok, i see what we're talking about now
16:41:25 <Saizan> newsham: mmmh, mergesort' might be producing big thunks
16:41:55 <mmorrow> koninkje: yeah, i just rarely even consider semianythings so am not used to thinking about them
16:42:07 <Saizan> newsham: that kind of tail recursions where the accumulator is a list always worried me, but never managed to tell if it's safe or not
16:44:10 <mmorrow> koninkje: i think it's slightly odd that that concept is refered to as "semiring", since it's made of two monoids, while a semigroup isn't even a monoid
16:44:54 <newsham> something's blowing my stack.  I think its "mapM_" I'm doing.
16:44:57 <mmorrow> that's what confused me when you said having id was easy (because i thought we were talking about something with out any id's)
16:45:07 <newsham> mapM_ is going to force the input list right?
16:45:12 <newsham> err.. the output list
16:45:15 <koninkje> mmorrow: there's not a lot of structure in semirings, but there's enough to where things get interesting. In Peano-style arithmetics, the mixing of + and * get you into undecidability problems. Also path search through a graph can be parameterized on semirings in interesting ways
16:45:37 <Saizan> newsham: one element at a time though
16:45:39 <newsham> this doesnt seem to blow stack:   mapM_ putStrLn . sort . lines =<< getContents
16:45:43 <mmorrow> koninkje: sure, i can see that. i was just being snotty earlier ;)
16:45:48 <newsham> this blows stack:  mapM_ (putStrLn . show) . sort =<< mapM inet_addr . lines =<< getContents
16:46:20 <koninkje> I'm not sure that "semi-" has any real meaning besides "we discovered this interesting thing after we discovered the more complex one"
16:46:44 <Saizan> ah "mapM" is more likely to use the stack
16:46:47 <Saizan> ?src sequence
16:46:47 <lambdabot> sequence []     = return []
16:46:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:46:47 <lambdabot> --OR
16:46:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:46:51 <mmorrow> koninkje: ahh. yeah a case of "retronaming"
16:46:58 <drhodes> is there an unApply?   (unApply (square 2)) == 2
16:47:07 <Saizan> sequence is not tail-recursive, nor productive
16:47:18 <koninkje> drhodes: that's not decidable in general
16:47:45 <koninkje> (If it were then all of crypto would be very unhappy)
16:47:56 <omnihil> drhodes, what if you had a function that maps all inputs to the output value of '1'? what would unapply do?
16:48:08 <drhodes> nonononononono.... since these are lazy, they've not been evalutated yet.
16:48:21 <newsham> well i have to force everything anyway, to do a sort, but it seems like mapM is causing my stack to overflow
16:48:23 <ozy`> drhodes: that can be done in languages that use term rewriting
16:48:30 <newsham> and the idea of "just make stack bigger" doesnt seem to be ideal
16:48:30 <ozy`> drhodes: haskell is not such a language
16:48:42 <newsham> i'm not sure what the right thing to do here is
16:48:57 <dolio> mapM takes O(n) stack, where n is the length of your list.
16:49:09 <dolio> At least, for bad monads.
16:49:12 <ozy`> drhodes: however.... the good news is, you can fake it by building all the function-and-argument data structures by hand
16:49:24 <Saizan> dolio: IO is one of those i guess
16:49:28 <dolio> Yeah.
16:49:37 <mmorrow> drhodes: so you'd need to keep the applications at the haskell level then (rather than the rts level)
16:49:40 <newsham> (not sure why inet_addr isnt marked pure,  i can probably safely unsafePerformIO over it)
16:49:43 <mmorrow> then it'd be trivial
16:49:49 <newsham> but, lets say I wanted to apply IO function across a huge list
16:49:52 <newsham> and i didnt want to blow stack
16:49:56 <newsham> whats a programmer to do?
16:50:26 <Saizan> use ContT IO to use heap instead?
16:50:46 <eagleuk> hi
16:50:54 <dolio> You could use a sequence built from unsafeInterleaveIO.
16:50:54 <ozy`> drhodes: http://pure-lang.sourceforge.net/ <- this language is superficially similar to haskell, but uses term rewriting, so that you can do exactly what you were asking
16:51:08 <Saizan> ah, yeah, that too
16:51:08 <mmorrow> drhodes:: you could use  data Ap :: * -> * where Ret :: a -> Ap a; Ap :: Ap (a -> b) -> Ap a -> Ap b
16:51:09 <ozy`> drhodes: no guarantees as to how nice it is to use, though....
16:51:27 <eagleuk> I got a problem i need to write small assignment in haskell anyone can help - beginer level
16:51:34 * drhodes 's brains starts to leak.
16:51:34 <conal> @seen arjanb
16:51:34 <lambdabot> arjanb is in #haskell-blah, #ghc, #darcs and #haskell. I don't know when arjanb last spoke.
16:51:42 <mmorrow> drhodes: well, that wouldn't work for unapply
16:51:58 <newsham> is this common enough that there should be an unsafeLazyMapM ?
16:52:43 <newsham> (anyone know why Network.Socket.inet_addr is IO?  did they write it to throw exceptions on exceptional inputs?)
16:52:45 <Saizan> a lazySequence would be appreciated
16:52:51 <newsham> the C inet_addr is pure.
16:53:07 <Saizan> @source Network.Socket
16:53:07 <lambdabot> http://darcs.haskell.org/packages/network/Network/Socket.hs
16:53:19 <monochrom> Brain leaks help unlearning.
16:53:30 <newsham> 404 on that
16:53:54 <newsham> (btw, this sort program is running extremely slowly compared to C or even python)
16:53:55 <eagleuk> I need to define a function that testes if the word is square-free, for example abba isnt and helo is
16:54:02 <eagleuk> anyone can help?
16:54:15 <newsham> eagle: define square free
16:54:26 <newsham> (is this a homework problem?)
16:54:38 <eagleuk> actually yes, it is
16:54:54 <Saizan> newsham: ioError (userError ("inet_addr: Malformed address: " ++ ipstr))
16:54:59 <Saizan> on -1
16:54:59 <drhodes> ozy`: thanks. mmorrow thanks.  so much to learn :)
16:55:05 <koninkje> drhodes: just define data App a b = (a->b) :$ a. And then define eval (f :$ x) = f x. So unapply (f :$ x) = x
16:55:08 <newsham> what part do you need help with?  can yu ask a specific question so that we dont accidentally do your homework? :)
16:55:20 <newsham> saizan: makes sense I guess.  *sigh*
16:55:26 <mmorrow> koninkje: ah nice, that's what exactly what i was going for
16:55:52 <koninkje> drhodes: but you'll need to use (:$) everywhere instead of normal application, and you'll need to use eval everywhere you want to really do application
16:56:03 <newsham> eeagle: so what is the definition of your problem and how are we going to get started on it?
16:56:11 <drhodes> ok koninkje I'll stare at that for a couple days. thank you.
16:56:21 <eagleuk> well i am beginner
16:56:32 <mmorrow> rwbarton had this nifty idea at one point where haskell would let you "overload" application
16:56:35 <Saizan> newsham: not really to me, but anyhow.. :)
16:56:43 <koninkje> drhodes: Actually, you'll probably want to define it recursively so that you can evaluate a whole tree at once
16:56:50 <mmorrow> so "sqrt 42" could mean whatever you want it to
16:57:02 <newsham> saizan: the C API overloads -1 for Nothing.  it should return Maybe Address
16:57:18 <newsham> where Address is a 32-bit address
16:58:02 <newsham> (meaning you cant distinguish inet_addr("255.255.255.255") from error)
16:58:13 <mmorrow> so you'd define a function  a -> foo b, and then a (foo (a -> b) -> foo a -> foo b) i guess or something
16:58:17 <newsham> there's a better API wich doesnt have this deficiency
16:58:19 <mmorrow> oops
16:58:34 <mmorrow> *.. a function (a -> foo a), and then ....
16:58:45 <koninkje> data App a b where Ret : a -> App a a ; (:$) : App a (a->b) -> App a a -> App b b ... or something like that
16:58:59 <mmorrow> hmm
16:59:19 <eagleuk> I have to define a function that tests if a word  is square, example abcab is squarefree but abbab isnt do no where to start
16:59:40 <mmorrow> koninkje: how could you get a (App a (a->b)) though?
16:59:42 <cjb> eagleuk: we don't write homework code for you here
16:59:58 <eagleuk> i just ask for help, not for code, allright?
17:00:09 <mmorrow> i think maybe only one type param is needed
17:00:23 <koninkje> mmorrow: that's the part I'm not sure about. It'd be easier to just have App : * -> *, but that doesn't give enough info for unapply
17:00:50 <mmorrow> koninkje: yeah, exactly. that's where i deadended earlier
17:00:58 <newsham> eagle: i dont understand what it means to be square or square-free
17:00:59 <koninkje> Actually, that first argument to (:$) should be App (a->b) (a->b) I believe
17:01:12 <newsham> does square mean it has two identical letters in a row?
17:01:23 <koninkje> Thus, Ret f :$ Ret x =~= f $ x
17:01:47 <mmorrow> but i think we'd need  an `a' *and* a `b' in the final App for unapply
17:01:47 <eagleuk> yeah or it might be adad is square - means we can split into two identical parts
17:01:58 <koninkje> it's just the applicative functor pattern
17:02:13 <koninkje> mmorrow: yeah, we need both a and b to have that info
17:02:20 <newsham> well the first thing you need is a good definition of what it means to be a square string
17:03:07 <tromp_> containing ww
17:03:33 <tromp_> for nonempty string w
17:11:15 <chrisdone> if I have a library licensed as GPL, and I want to use it in a program, do I have to license that program as GPL?
17:11:43 <chrisdone> I've licensed my Blogination program as BSD3 without realising I'm using several libraries that are GPL licensed
17:11:44 <p_l> chrisdone: If it's under GPL without any kind of linking exception, then yes
17:11:46 <Riastradh> Is there an alternative implementation of the library which someone could use in the place of the GPL'd library?
17:12:09 <chrisdone> no
17:13:35 <Riastradh> The FSF's interpretation, then, is that you must release your program under the GPL.
17:14:08 <chrisdone> I see
17:14:59 <p_l> chrisdone: can you link those libraries dynamically?
17:16:17 <chrisdone> I don't know
17:16:39 <Riastradh> According to Richard Stallman, dynamic linking doesn't change the situation.
17:17:36 <p_l> Riastradh: Even if you don't use GPLed headers, load it as a big blob and manually link symbols? Then you can argue that it will work with whatever implementation/library that has the same API
17:18:22 <Riastradh> See <http://clisp.cvs.sourceforge.net/*checkout*/clisp/clisp/doc/Why-CLISP-is-under-GPL>.
17:19:29 <Riastradh> Here's a particularly relevant excerpt by RMS, about dynamically linking:  `I said I would have to ask the lawyer.  What the lawyer said surprised me; he said that judges would consider such schemes to be ``subterfuges'' and would be very harsh toward them.  He said a judge would ask whether it is ``really'' one program, rather than how it is labelled.  So I went back to Jobs and said we believed his plan was not allowed by the 
17:19:56 <chrisdone> admittedly, the libraries are very good and pretty much make the program what it is. so I suppose in that sense the functionality of the program is only about 10% my work. it seems fair in this case. do you think so?
17:21:44 <p_l> chrisdone: I'd say this - are you really interested in giving more freedom by using BSD3 or do you not care?
17:21:49 <Riastradh> On the other hand, if you went to the trouble of rewriting all the libraries yourself, and implementing compatible interfaces without copying any code, then I don't think any judge would require you to release your program under the GPL.  However, I am not a lawyer, and this is not legal advice.
17:22:22 <Pseudonym> The FSF's position is that interface copyrights don't exist.
17:22:32 <Pseudonym> And this was proven in court, e.g. in the Apple lawsuit.
17:22:48 <p_l> Pseudonym: However they will be stingy if you use dynamic linking
17:22:54 <Riastradh> Pseudonym, do you have any better references offhand than an email conversation with RMS archived in CLISP's CVS repository?
17:22:56 <Cale> Oh, hey, there are two new Catsters videos!
17:23:04 <Cale> http://www.youtube.com/watch?v=4QgjKUzyrhM
17:23:10 <Cale> http://www.youtube.com/watch?v=eaJmUUogb6g
17:23:14 <Pseudonym> Yes, an email conversation with RMS somewhere in my inbox!
17:23:21 <Pseudonym> What better reference do I need?
17:23:32 <Pseudonym> The thing is, though, the FSF relies heavily on that position.
17:23:38 <Pseudonym> After all, it's usually THEM doing the reimplementing.
17:23:41 <Riastradh> How about references that mere mortals such as I can read and point other mere mortals to?
17:24:29 <p_l> chrisdone: Which libraries are you using?
17:24:55 <chrisdone> p_l: honestly, I always want code I release openly to be used by anyone for anything. but this code is only 300 lines and isn't that special so I don't mind so much in this case
17:25:14 <chrisdone> p_l: Pandoc, ConfigFile and, highlighting-kate
17:25:24 <Pseudonym> http://groups.csail.mit.edu/mac/projects/lpf/Copyright/copyright.html
17:25:32 <Pseudonym> How about that?
17:26:18 <chrisdone> p_l: it's just simple blog software: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blogination
17:26:19 <monochrom> I would public-domain it.
17:26:49 <p_l> chrisdone: ConfigFile is okay - it's LGPL
17:27:00 <chrisdone> p_l: I suspect so for that one
17:27:46 <p_l> chrisdone: For Pandoc, you might try checking if you could link it with your code by assuming GPLv3
17:28:42 <chrisdone> it all seems a bit dubious to me
17:28:44 <p_l> the same for highlightin-kate
17:28:52 <koninkje> drhodes: See http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1806#a1807 for more on that idea
17:29:06 <Riastradh> Pseudonym, well, I don't think that gives as clear an answer about dynamic linking.
17:29:58 <Pseudonym> No, but i was talking about your comment about reimplementing.
17:30:02 <Riastradh> OK.
17:30:39 <chrisdone> deciding on licenses is one of the things I dislike most about releasing software. I don't have a law degree, nor do I want to spend time thinking about copyright
17:31:19 <chrisdone> :-(
17:31:23 <Pseudonym> That's why you pick an existing licence.
17:31:33 <monochrom> People actually have to pay lawyers for that.
17:31:35 <Philippa_> you can mostly get by using one of GPL or BSD
17:31:38 <skorpan> no, that's why you don't license your software
17:31:46 <Philippa_> skorpan: then nobody can use it
17:31:54 <skorpan> exactly!
17:31:56 <skorpan> :)
17:31:56 <Pseudonym> Except you, obviously,.
17:31:57 <monochrom> I just public-domain it.
17:31:59 <p_l> hmmm... it doesn't look like you can avoid changing the licence with GPL3
17:32:09 <Pseudonym> Public domain is cool, but I like the back pointer to me.
17:32:10 <p_l> chrisdone: Welcome in GPL hell
17:32:38 <conal> @ask arjanb may I acknowledge you (for comments) in my type class morphism paper?  if i may, what's your name?  i can guess, based on your /whois info.
17:32:38 <lambdabot> Consider it noted.
17:32:40 <koninkje> Also, "public domain" doesn't exist in all countries. Use the WTFPL if you want that
17:32:48 <Riastradh> chrisdone, that's what <http://home.ccil.org/~cowan/floss> is for.
17:33:04 <monochrom> wtf is wtfpl?  <duck>
17:33:07 <p_l> Also you might not be able to use public domain licence and use GPL code :)
17:33:12 * monochrom looks it up
17:33:17 <koninkje> http://sam.zoy.org/wtfpl/
17:33:29 <Pseudonym> When I contribute to a project, there's usually already a licence.
17:33:36 <monochrom> Heh nice.
17:34:05 <p_l> I usually go BSD3 or MIT route
17:34:07 <chrisdone> Riastradh: "You should use the license already in use in that community." <-- I did that, I automatically put BSD3 for my haskell libraries. I guess for this one I'll have to make an exception
17:34:40 <p_l> chrisdone: GPL was designed to be viral (and yes, I'll use that name as much as I want, GNU zealots)
17:35:05 <skorpan> i just read the WTFPL and it's exactly what i'm looking for.
17:35:37 <chrisdone> is GPL like the IO monad?
17:35:42 <monochrom> Stallman himself says GPL is infectious.
17:35:52 <skorpan> chrisdone: yes, except the IO monad is for the real world
17:35:55 <monochrom> So don't worry about calling it viral.
17:35:57 <SubStack> the only medicine is MORE COWBELL
17:36:23 <p_l> Cowbell Hero? :)
17:36:55 <Riastradh> Enough lawyers are sketched out by the notion of releasing software into the public domain that I prefer to avoid it.
17:37:09 <Pseudonym> unsafePerformGPL
17:37:26 <chrisdone> what does "sketched out" mean?
17:37:57 <p_l> Pseudonym: It executes HCF instruction ;-)
17:38:16 <Riastradh> chrisdone, I think that `community' there is meant to imply that you are contributing to an existing collection of software in a single project, such as GHC.
17:38:34 <p_l> chrisdone: They fade into 2D so fast you get to see them change to red
17:38:43 <Riastradh> chrisdone, that is: they find it to be sketchy, and are unsure whether it would carry weight in a court.
17:38:56 <chrisdone> ah, ok
17:39:18 <Riastradh> Specifically, because copyright is automatically assigned to a creator, your estate might demand royalties from users of the software, and a court may uphold that.
17:39:18 <koninkje> drhodes: For a complete look at implementing unapply, you'll want to add another constructor to App which gives "unapplication". Then the eval function needs to be rewritten so that it can do the right lookahead to plumb the things back together by removing the Unapp and the :$ in one step
17:39:23 <p_l> Riastradh: What about the fact that after certain amount of time all copyrights go into public domain automatically (at least in normal countries)
17:39:37 <Philippa_> chrisdone: if you only link against Pandoc you can release your source BSD
17:39:54 <Philippa_> er, not just Pandoc. GPLed libs generally
17:40:09 <Riastradh> p_l, oh, that will never happen for software.  Software came after Mickey Mouse.
17:40:14 <Philippa_> that's important because someone can swap to another lib and still have the BSD rights on your code
17:40:46 <p_l> Riastradh: Depends on country. In some 1st world countries copyright law still has clauses like "25 years from first release"
17:41:03 <Riastradh> p_l, cool!  What countries?
17:41:14 <edwardk> chrisdone: unlike the IO monad, you don't pass the state of the world around, you just sign it over to the FSF.
17:41:20 <Riastradh> Philippa_, not according to Richard Stallman.  See <http://clisp.cvs.sourceforge.net/*checkout*/clisp/clisp/doc/Why-CLISP-is-under-GPL>, as I just quoted a few minutes ago.
17:42:12 <p_l> Riastradh: I would have to delve in legal papers to make a list, but I recall that in Poland there was a general clause of copyright length that wasn't changed since a long time. Last big addition was in 1994 which added software into the mix
17:42:46 <p_l> Riastradh: You could probably argue that anything written before 1994 is public domain
17:42:48 <Riastradh> Anyway, where I live, Mickey Mouse reigns supreme in the realm of copyright.
17:43:20 <p_l> BTW, what are copyrights laws on antarctica?
17:43:20 <Riastradh> p_l, there are many things I could argue; few of them would a court accept.
17:43:31 <wli> HCF == Halt and Catch Fire or Highest Common Factor?
17:43:39 <p_l> wli: Halt and Catch Fire
17:43:44 <edwardk> RMS makes me sad
17:43:44 <Philippa_> Riastradh: Thus far I'm not seeing what looks like a legit complaint. I specifically said source for a reason
17:44:02 <Philippa_> you would have to offer GPLed source with binaries
17:44:25 <wli> p_l: Copyright laws in Antarctica are those of the country administering whatever research base etc. you're on.
17:45:09 <Riastradh> I see.
17:45:48 <p_l> wli: If I set up my own base in Antarctica, outside of any currently established, can I declare my own jurisdiction? :)
17:46:15 <wli> p_l: I have my doubts your claims to such would be respected.
17:46:23 <drhodes> koninkje: Thanks for the help, I appreciate it.
17:46:25 <Philippa_> Riastradh: it's important if someone wants to rip out the GPL-infected part of the codebase, basically
17:46:37 <monochrom> US forces may quickly move in because your land owns oil, but otherwise yes.
17:46:50 <Philippa_> I'm not denying that it's a circumvention of part of the GPL's intent. I just don't have much sympathy.
17:47:17 <p_l> monochrom: That means I have to add dead-man-switch operated nuke in it...
17:47:46 <monochrom> More interesting is if you start distributing Windows through a server in your base, what will happen?
17:48:14 <wli> p_l: There's a lot of crap that goes on to prevent ordinary people from becoming stateless and thereby escaping being under the jurisdiction of any country at all. Even if you have a legitimate, solid legal argument it will basically be ignored.
17:48:14 <p_l> monochrom: I don't see a point. I always download my windows isos from microsoft.com
17:48:29 <monochrom> But I want to download from you!
17:48:41 <koninkje> drhodes: Sure thing. Out of interest, I posted the solution up there too just now
17:48:46 <p_l> wli: I can however ignore claims from other countries. They have to use physical means to do anything
17:48:51 <wli> p_l: The way people dodge things is by paying off one jurisdiction vs. another.
17:48:58 <wli> p_l: And they will.
17:49:04 <Philippa_> Riastradh: the fact that RMS's main example is building a program from another program rather than a library affects likely responses from a judge, too
17:49:46 <wli> p_l: Playing off one jurisdiction vs. another. "Regulatory arbitrage" or whatever.
17:49:49 <Philippa_> it really is the case that while /a/ parser/renderer is a critical part of, say, a wiki, it's less critical /which/ one
17:49:58 * p_l adds a new goal to his todo: get enough stuff to start self-sufficient base in antarctica. *Armed*
17:50:52 <wli> Moving on, monadic interpreter...
17:51:03 <Riastradh> Philippa_, sorry, what do you mean by `building a program from another program rather than a library'?  The example under discussion in that email conversation was CLISP's use of the readline library.
17:51:36 <Philippa_> yes, and RMS says "I don't think so", but his example of a case where a lawyer didn't think so was re a new front-end for GCC
17:52:23 <p_l> Philippa_: And thanks for that. Now we have Apple financing LLVM and clang ^_^
17:52:37 <Philippa_> heh
17:52:47 <wli> LLVM I've heard of. What's clang?
17:52:48 <Philippa_> well yeah, but that's also because in many regards GCC is a POS :-)
17:52:52 * p_l is off to finally configure TCPIP Services for OpenVMS Alpha
17:53:38 <p_l> I heard many good things about Sun's compiler suite
17:53:55 <monochrom> porn open site?
17:54:00 <p_l> And certainly it's on-line help is much easier to understand wrt functionality you enable by switches
17:54:11 <p_l> monochrom: Piece Of Shit?
17:54:48 <monochrom> there are too many acronyms
17:55:02 <kerlo> p_l: you should get Agora Nomic to recognize your jurisdiction over part of Antarctica.
17:55:06 <Philippa_> also Point Of Sale
17:55:22 <kerlo> If Agora is sufficiently advanced by that time, you may even be able to get one of them to join you.
17:56:06 <p_l> kerlo: Well, if everything goes the way I want, in few decades I'll be claiming some space on some celestial object beyond mars orbit. Should be far enough to avoid missiles
17:57:05 <kerlo> True.
17:57:12 <kerlo> You should claim some land on Jupiter. :-P
17:57:26 <monochrom> Far enough to have no internet access, too.
17:57:43 <monochrom> How are we going to chat with you through IRC?
17:57:54 <kerlo> Low-density parity check codes.
17:58:06 <p_l> monochrom: I'll use batch processing and relay network. I'll have to drop irc, though, till I find a way to partition my concioussness
17:58:25 <wli> Reed-Solomon codes etc.
17:58:33 <kerlo> Low-density parity check codes.
17:58:46 <kerlo> Reed-Solomon codes are high-density parity check codes. You want low-density parity check codes.
17:59:08 <monochrom> RFC 2938483 "space pigeons"
18:00:06 * wli attempts to focus on monadic interpreters.
18:00:33 <wli> Expanding expressions beyond numeric literals might help.
18:00:33 <edwardk> kerlo: alas, you'll get all the way out there, and then start communicating back with them. and half a dozen SAN vendors will all sue you for patent infringement... and you'll have to fly back
18:00:53 <kerlo> Low-density parity check codes are patented?
18:01:05 <kerlo> That's ridiculous. I invented them.
18:01:09 <kerlo> Okay, that's an exaggeration.
18:01:31 <kerlo> Still, I dislike it when people patent math.
18:01:50 <pastah> so, i want to write a rule/decision-making thingamojigg
18:01:58 <p_l> kerlo: Move to a place where patent office doesn't allow that and then make them leave WTO
18:02:08 <kerlo> If you can define it in one line, it shouldn't be patentable.
18:02:10 <edwardk> kerlo: unfortunately most of the interesting flavors are, and everyone of the patent applications has exorbitant claims, and few if any have even been challenged
18:02:33 <pastah> it's meant to have a lot of properties and rules and stuff and in the end i want to be able to take a collection of tables and a collection of people and generate a seating arrangement
18:02:56 <pastah> anyone got any ideas where i can read about this sort of problem and different aproaches to it?
18:02:58 <edwardk> p_l: yeah but if the whole idea was to use them to communicate back here... then well, one end point inevitably will run afoul of the issue ;)
18:03:12 <ddarius> pastah: Just give everyone the same seat.  Everything will work out.
18:03:15 <pastah> *about where*
18:03:22 <pastah> ddarius: the more the merrier?
18:03:50 <kerlo> pastah: sounds like all you need is a general NP problem solver.
18:03:52 <pastah> all i seem to find is business rules and contracts and stuff like that, but i don't even know the basics in dealing with stuff like this
18:04:02 <kerlo> Not to be confused with a general NP-complete problem solver, even though that's the same thing.
18:04:23 <pastah> kerlo: ???
18:04:33 <edwardk> pastah: grab gprolog and the faq and have at it ;)
18:04:46 <kerlo> Prolog, yes. What he said.
18:04:49 <pastah> edwardk: sorry, this has to be in haskell
18:04:57 <wli> Why gprolog? Mercury!
18:05:01 <pastah> (assignment)
18:05:09 <ddarius> pastah: Implement Prolog in Haskell and then solve it.
18:05:10 <edwardk> ok, then write the prolog program first, and transcode it into a set of typeclasses ;)
18:05:24 <wli> LogicT baby
18:05:39 <monochrom> Use a SAT solver. There is one written in Haskell.
18:05:39 * wli is mostly trying to manage the repl.
18:05:56 <edwardk> wli: how fares the interpreter?
18:06:06 <wli> He likely has restrictions on the third-party code he can use.
18:06:14 <edwardk> fair enough
18:06:17 <sm> how do I turn a cpp macro into haskell string ?
18:06:32 <pastah> could someone please take me seriously
18:06:35 <pastah> ;)
18:06:36 <wli> edwardk: I have a repl that binds names to numeric literals and handles various sorts of errors.
18:06:37 <p_l> the joys of running on a wip emulator - your code will fail, randomly, with nothing to follow on :-)
18:07:05 * p_l wonders if the authors got ALUs right - you don't want errors in your RSA keys
18:07:12 <edwardk> pastah: actually i am. the prolog approach really is the easiest, and you can basically reimplement most of them as a system of typeclasses or as wli pointed out logict statements
18:07:39 <sm> let me retype: how do I declare a haskell string whose content comes from a cpp variable ?
18:07:48 * ddarius has implemented Prolog in Haskell.
18:07:53 <wli> Probably the easiest way to go if you can't use LogicT outright is to reimplement it.
18:07:58 <edwardk> cpp as in c preprocessor or as in c++?
18:08:08 <sm> as in c preprocessor
18:08:26 <pastah> wli: but there has to be something i can read about a problem like this
18:08:35 <BMeph> Does anyone have a nice (or not-so-nice) operator for (\ c f g x -> f x `c` g x)?
18:08:36 <edwardk> um. #define FOO "what about it"\nfoo :: string\nfoo = FOO
18:08:43 <edwardk> er :: String
18:08:44 <pastah> how to formulate rules, how do i make properties, stuff like that
18:08:51 <ddarius> edwardk: Too much C#
18:09:13 <pastah> @pl \c f g x -> f x `c` g x
18:09:13 <lambdabot> liftM2
18:09:15 <ddarius> BMeph: liftA2/M2
18:09:19 <sm> edwardk: you're right, I need to include the quotes in the definition, thanks
18:09:58 <wli> pastah: Read Oleg's paper on LogicT and various implementations of Prolog in Haskell.
18:10:04 <edwardk> pastah: well, ok, start with a simple horn clause solver. add a unit propagation rule and go from there.
18:10:19 <BMeph> ddarius: liftM2 is not an operator. I've used liftM2, but I was curious whether anyone made up an _operator_ for it. :)
18:10:33 <pastah> edwardk: "horn clause"?
18:10:36 <ddarius> BMeph: `liftM2`
18:10:47 <edwardk> http://en.wikipedia.org/wiki/Horn_clause
18:10:58 <witkamp_> can I use Data.Binary.Get with Data.ByteString
18:11:15 <witkamp_> I know it works with Data.ByteString.Lazy
18:11:19 <BMeph> ddarius: I was going to say "Thanks for trying", but I take it back before offering. :p
18:11:21 <edwardk> pastah: if you want to understand this stuff, start http://www.doc.ic.ac.uk/~rak/papers/ with Chapter0.pdf and go from there ;)
18:11:29 * wli isn't sure what to implement next.
18:11:42 <edwardk> wli: got lambda?
18:12:38 <ddarius> BMeph: c <$> f <*> g
18:12:52 <pastah> wli, edwardk: thanks :D
18:14:08 <edwardk> if you need it i can probably drudge up a 20 or 30 line resolution based theorem provider in perl i did a long time ago for expository purposes.
18:14:34 <wli> edwardk: No, just top-level bindings of names to literal values, a discriminated union of Integer, Double, and Char.
18:14:58 <edwardk> then lambdas sound like a nice start. ;)
18:15:08 <edwardk> makes you start thinking about the environment more.
18:15:26 <wli> edwardk: I thought types and primitive operations would be up next.
18:15:28 <edwardk> debruijn vs. barendregt convention vs. hoas, etc.
18:15:34 <edwardk> types are overrated ;)
18:15:58 <edwardk> wli: did you ever see http://www.augustsson.net/Darcs/Lambda/top.pdf ?
18:16:34 <pastah> wli: why implement prolog in haskell? isn't writing stuff in haskell itself good enough?
18:17:10 <edwardk> pastah: prolog is good at certain pattens of inference that are just awkward to write directly
18:17:12 <koninkje> pastah: prolog (or logic programming generally) gives backtracking search and unification
18:17:34 <tromp_> :t union
18:17:34 <MyCatVerbs> pastah: prolog is sexy. Seeeeeeexy.
18:17:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
18:17:40 <tromp_> @src union
18:17:41 <lambdabot> union = unionBy (==)
18:17:48 <tromp_> @src unionBy
18:17:48 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
18:18:06 <wli> edwardk: Looking.
18:19:41 <pastah> edwardk: the annyoing thing here is that this HAS to be something that is written in haskell
18:20:03 <pastah> and writing a prolog parser/interpreter isn't exactly within my timeframe (~20 hrs)
18:20:18 <p_l> pastah: You sure? :)
18:20:57 <edwardk> pastah: class exercise?
18:21:07 <p_l> pastah: Caffeine IV, copy of PAIP and 20hrs of Lisp->Haskell translation :)
18:21:46 <edwardk> pastah: then if the constraints are simple just use a fairly direct interpretation of them, and the list monad
18:22:03 <wli> pastah: Well, when I say that, I really mean the logic engine parts ignoring all the syntactic processing and so on watering it down to the point that the language isn't really there.
18:22:32 <ddarius> MyCatVerbs: Prolog is a sin against nature.  Logic programming can be sexy though.
18:23:36 <p_l> ddarius: And is beautiful way to get students confused in practical :3
18:23:44 <wli> I had some crackpot scheme a while ago to write an interpreter for a logic language with "prolog technology theorem prover" semantics. LogicT captured the semantic core of that, and really all people need to do is to put a front end atop it to achieve that.
18:24:32 <wli> I'm too dimwitted to figure out how to use monads to back-end the semantics of any language, never mind logic languages, so it won't be for me to do.
18:26:07 <wli> edwardk: Well, the "exercise" as I've defined it for myself is to hammer out something like PCF with some sort of polymorphic type system with user-defined types.
18:26:11 <chrisdone> ddarius: did you read the Logic Programming chapter of SICP?
18:26:23 <wli> edwardk: And modules, too, of course.
18:26:36 <ddarius> chrisdone: Years ago, yes.
18:27:48 <wli> edwardk: This PCF: http://en.wikipedia.org/wiki/Programming_language_for_Computable_Functions
18:31:28 <Philippa_> wli: I'd recommend doing the explicitly-typed version without polymorphism first
18:32:09 <wli> I already need to revise things for that.
18:32:15 <Philippa_> wli: you get a choice of where to go for polymorphism after that, but if you go with something Hindley-Milner-like and implicit then it's easy enough to do both things at once
18:32:28 <Philippa_> fair enough I guess. What're you stuck on?
18:32:56 <wli> The command I've got to bind names to values doesn't take types.
18:33:07 <Philippa_> *nod*
18:33:10 <wli> I'm not really stuck on that per se, though.
18:33:24 <Philippa_> more things like how to define datatypes in the first place?
18:33:33 <wli> Philippa: Yeah.
18:34:01 <wli> Actually, with as limited as my goals are, an explicitly typed final product is fine.
18:37:08 <MyCatVerbs> ddarius: admittedly, every time I've attempted to use Prolog, I've ended up giving up and using it as if it were Lisp with funny syntax.
18:37:51 * wli didn't have much of a problem trying to use Prolog or Mercury the last time(s) he tried, but those were before the big brain fry.
18:37:53 <MyCatVerbs> ddarius: just writing the Lisp equivalent, with an extra "result" parameter, abusing call/* like crazy. It works well enough, though.
18:38:04 <ddarius> MyCatVerbs: If only.  But that sounds more like unfamiliarity with logic programming than particular aspects of Prolog.
18:38:47 <ddarius> Admittedly, in my opinion, "functional" is often what you do actually want.
18:39:01 <MyCatVerbs> ddarius: quite possibly. I still can't work out how to trick the thing into colouring a graph for me.
18:39:26 <MyCatVerbs> In, say, less time than it'll take for good old Sol to burn out, naturally.
18:42:27 <edwardk> mycatverbs well, if you're happy treating it like a lisp, maybe an interpretation of prolog's semantics along the lines of http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4594 might make it clearer
18:43:53 <MyCatVerbs> edwardk: cool! Not sure if I have the background to follow that, but interesting, thank you.
18:44:13 <edwardk> mycat: skip down to the section where they give the evaluation of B, and the rest is noise
18:44:42 <ddarius> MyCatVerbs: Conal Elliott and Frank Pfenning have a nice paper on interpreting (nice) logic languages (using ML).
18:45:05 <edwardk> MyCatVerbs: definition 4.1 and the surrounding text i think are what made prolog click for me
18:45:37 <edwardk> mainly because you can transliterate that into 30 lines of haskell and just start hacking.
18:46:12 <ddarius> That's a motley of Greek lettersl.
18:46:23 <MyCatVerbs> I don't get stuck at the question "what are Prolog's semantics?" I'm fairly well acquanted with them.
18:46:28 <edwardk> fair enough
18:46:36 <MyCatVerbs> The point I get stuck at is, "great, now how do I get this to do anything useful?"
18:46:43 <edwardk> ddarius: yeah it is a bit gratuitous =)
18:46:47 <ddarius> MyCatVerbs: What are Prolog's semantics?
18:47:10 <Pseudonym> MyCatVerbs: What are the semantics of the cut?
18:47:22 <MyCatVerbs> At least, I think I am. I started out on Prolog by reading a textbook called "The Art of Prolog", which more or less attempts to teach the language by describing roughly how to write an interpreter for it.
18:47:34 <Pseudonym> MyCatVerbs: Leon Sterling was one of my lecturers.
18:47:41 <edwardk> Pseudonym: it replaces the failure continuation with the current cut continuation ;)
18:47:48 <Pseudonym> Ha.
18:48:22 <MyCatVerbs> Pseudonym: eliminate all alternatives up to the head of the currently-followed clause. So you can backtrack back past the *whole* of the current clause, but not through any smaller part of it prior to the cut.
18:48:47 * edwardk gives mycatverbs a cookie.
18:48:47 <ddarius> MyCatVerbs: I highly recommend looking at the notion of an "abstract logic programming language" and the closely related notions of uniform proof and focusing.
18:48:57 <MyCatVerbs> edwardk: thank you. ^^
18:49:18 <Pseudonym> You will note that every proposed meaning is operational in nature.
18:49:20 <MyCatVerbs> ddarius: I don't think I can actually explain unification in a non-messy manner, though.
18:49:24 <maxote> ddarius, using Agda2, Epigram, ...?
18:49:30 <edwardk> mycatverbs: hah i think i still have that book out on my shelf
18:49:31 <Pseudonym> There was a cottage industry in the 90s of giving declarative semantics to the cut.
18:49:43 <edwardk> Pseudonym: thats where logic programming went to die
18:50:10 <Pseudonym> Logic programming isn't dead, of course.  There's a bit of a renaissance thanks to constraint programming.
18:50:12 <edwardk> oleg was the sole survivor. i think he killed and ate the others. this might explain why he always seems a little off kilter when you meet him.
18:50:26 <Pseudonym> edwardk: Richard O'Keefe is still very much alive and posting.
18:50:37 <wli> How is constraint programming different from logic programming?
18:50:39 <koninkje> edwardk++
18:50:50 <MyCatVerbs> ddarius: I note that Prolog seems to have made some portion of Haskell type-hackery easier - HM resembles Prolog's unifier closely enough that I can work some "interesting" types out by working out what the recursion scheme would be for the Prolog version.
18:51:15 <edwardk> Pseudonym: well, there were a few that survived by huddling behind bolted doors and barred windows. i hear rumours that pfenning survived the purge as well. =)
18:51:17 <MyCatVerbs> I thought constraint and logic programming were interchangable terms?
18:51:40 <Pseudonym> Not really, no.  Though you can think of pure Prolog as constraint programming on Herbrand domains.
18:51:50 <MyCatVerbs> edwardk: the cover is addictive to stare at, for some reason. :)
18:51:56 <ddarius> MyCatVerbs: All those "typing rules" and such and similar looking rules elsewhere, can be very nicely and directly transcribed into a reasonably nice logic language.  lambdaProlog is often adequate.
18:52:07 <Pseudonym> Logic programming is programming with logical assertions.
18:52:21 <Pseudonym> What you do with logic variables doesn't depend on that definition.
18:52:34 <wli> I've not been able to get lambdaprolog implementations running for whatever reason, so I went with Mercury.
18:52:42 <koninkje> MyCatVerbs: If you'd like to see the difference, compare Prolog (logic programming) with ECLiPSe (Contraint--Logic programming)
18:52:48 <Pseudonym> Haha.
18:52:50 * Pseudonym wipes eyes
18:52:53 <Pseudonym> Mercury, I fear for you.
18:52:59 <maxote> a domain of 100 bool vars is very inefficient in Prolog, and superefficient in CSP.
18:53:11 <Pseudonym> Actually, the place where I work uses Mercury now
18:53:20 <koninkje> http://www.eclipse-clp.org/ (because some Java IDE makes Google hate it)
18:53:27 <wli> Pseudonym: I don't claim to know anything serious about any of this. What's the deal?
18:53:28 <ddarius> As far as I know, Mercury doesn't differ from Prolog in any of the ways lambdaProlog differs from Prolog (though it certainly differs in many ways that it doesn't) [I guess typing is an exception]
18:53:32 <Pseudonym> For constraint programming, no less!
18:53:38 <MyCatVerbs> koninkje: thanks for thinking to give the link. :)
18:53:48 <Pseudonym> wli: If you see "bromage" anywhere in the Mercury source code, that's me.
18:54:18 <Pseudonym> Probably not much of my code left outside of the examples directory.
18:54:56 <koninkje> For contraint--logic programming, constraints can be thought of as a laziness in the usual logic evaluation strategy
18:55:18 <koninkje> (of course, constraint programming, sans logic, also exists and is different)
18:55:19 <Pseudonym> Or you can think of Richardson unification as eagerness.
18:55:51 <Pseudonym> Either way, you get stuck when you have negation.
18:56:03 <koninkje> Sure. Though often constraints are things like X > 5 which aren't unification exactly, but they can still be delayed
18:56:38 <Pseudonym> Right, unification is a constraint system on Herbrand domains.
18:56:45 <Pseudonym> X > 5 is just in a different domain.
18:56:46 <koninkje> exactly
18:57:12 <wli> I've seen things like linear algebra solvers somehow landing in constraint-related affairs.
18:57:13 <koninkje> though delayed unification can be fun >;)
18:57:40 <koninkje> linear algebra, integer programming, and the like are typical (non-logic) constraint programming
18:57:43 <Pseudonym> wli: Yup.  And linear inequality solvers, too.
18:57:53 <Pseudonym> Yet another use for the simplex algoritm.
18:58:03 <maxote> and SMT too
18:58:23 <wli> Pseudonym: Fourier-Motzkin elimination I've not seen directly. No idea how one uses the simplex algorithm for that.
18:59:04 <Pseudonym> wli: Fourier-Motzkin is useful for eliminating variables if, say, a variable is purely internal.
18:59:21 <Pseudonym> If a variable doesn't escape some scope, then you eliminate it.
19:00:11 <Pseudonym> That can help make the problem tractable, or help produce meaningful output.
19:00:13 <wli> Pseudonym: AFAIK Fourier-Motzkin is just the algorithmic procedure for solving systems of linear inequalities. I've no idea where the simplex algorithm comes into it.
19:00:16 <Pseudonym> But it doesn't actually solve the problem.
19:00:52 <bremner> Fourier-Motzkin finds all basic solutions; simplex finds 1.
19:01:13 <Pseudonym> Perhaps more to the point, simplex can prove the non-existence of solutions quickly.
19:01:17 <wli> The simplex algorithm was optimization last I checked.
19:01:21 <maxote> bremner, all best solutions?
19:01:51 <bremner> I missed the context. sec.
19:02:27 <Pseudonym> I believe that Fourier-Motzkin is hard to implement incrementally.
19:02:40 <Pseudonym> Because you want to be able to backtrack in logic programming.
19:02:47 <Pseudonym> But don't quote me on that.
19:02:50 <wli> I'm obviously pig ignorant of how this is dealt with in any practical fashion, so maybe there's an optimization subproblem floating around.
19:03:07 <ddarius> Pseudonym: Not if you use a forward mode language.
19:03:20 * Pseudonym is still thinking of Mercury
19:03:24 <Pseudonym> You can never escape it.
19:03:59 <ddarius> Hermes was the messenger of the Gods.  Hopefully he can move.
19:04:12 <Pseudonym> For the record, the simplex algorithm can be modified to do all sorts of things, including constraint satisfaction.
19:04:24 <MyCatVerbs> Pseudonym: \M\e\r\c\u\r\y
19:04:26 <wli> I imagine that if you isolate one variable, you can use the simplex algorithm to establish constant upper and lower bounds.
19:04:28 <bremner> so, if you want to know if a system of linear inequalites has solutions, Fourier-Motzkin is massive overkill, since it finds a complete description of the solution set (or at least it can be used to do that)
19:04:40 <Pseudonym> When you use the simplex algorithm for optimisation, you add a rule to represent the optimisation function.
19:05:03 <Pseudonym> I can't remember the details, but if you _don't_ do that, you can use it to do satisfaction.
19:05:15 <Pseudonym> Because all you really need to know in constraint logic programming is whether or not there is a solution.
19:05:22 <Pseudonym> Only at the very end do you need to know what it is.
19:05:36 <orbitz> is it pronounced Scale-a, or Scalla (like scallop)?
19:05:39 <wli> I've never seen the simplex algorithm used for anything but optimization.
19:05:39 <bremner> Pseudonym: err, I think some of the details are important, since SAT is NP-Hard, and LP is O(n^3)
19:05:54 <koninkje> Ska-lah
19:06:01 <bremner> You can use branch-and-bound to solve _Integer_ programs
19:06:02 <Pseudonym> The only question you need to know an answer to is: Does this extra equality or inequality fail or not?
19:06:13 <orbitz> like Ska the music?
19:06:18 <Pseudonym> bremner: Well I'm thinking of CLP(R).
19:06:30 <Pseudonym> Though I guess Q as well.
19:06:46 * bremner has no idea what those things are, but knows something about linear optimization.
19:06:48 <Pseudonym> Integer programming is, as you say, a more difficult problem.
19:06:55 <koninkje> orbitz: yeah. Though scall[op]-a I've also heard
19:06:59 <Pseudonym> CLP(R) = Constraint logic programming on reals.
19:07:13 <orbitz> i liek scall[op]-a myself
19:07:16 <orbitz> what is Integer programmign?
19:07:16 <Pseudonym> By "real", of course, they mean IEEE-754.
19:08:06 <bremner> orbitz: roughly speaking, finding integer solutions to systems of linear inequalities
19:08:17 <koninkje> orbitz: though the ash vs open-o pronunceation falls under differences in English dialects, so I wouldn't worry about it. I've never heard it said with the long A though
19:08:40 <wli> I've already had a fair amount of trouble trying to impement fraction-free Gaussian elimination.
19:08:46 <bremner> orbitz: actually finding the best integer solution according to some linear function
19:09:11 <bremner> wli: you could look at the source code to lrslib by david avis
19:09:39 <bremner> wli: it is not pretty, but it does pivoting in the integers
19:09:42 <orbitz> bremner: thanks
19:10:07 <bremner> wli: mind you, maybe this actually written down in a book somewhere :-)
19:10:41 <wli> bremner: I did a fair amount of pivoting.
19:11:21 <bremner> wli: is there more to Gaussian elimination than pivoting until the matrix is triangular?
19:11:35 <wli> bremner: It looked kind of like the extended gcd, where I pivoted about the smallest nonzero element.
19:12:30 <bremner> wli: I don't really remember the details, but yes, fast  GCDs are part of it. ISTR Jack Edmonds had some ideas to speed things up, so called "q-pivoting"
19:12:35 <wli> bremner: From there I just kept going until I had isolated things to only one nonzero element in a column, then peeled off the row and column (obviously complete pivoting is going on here).
19:13:07 <wli> bremner: I was mostly doing it for pedagogical reasons, so I wasn't very worried about speed.
19:13:43 <wli> bremner: I failed when it came time to track all the pivoting so the actual solution could be reconstructed from the reduced matrix.
19:13:44 <bremner> wli: hmm,  well, I'm surprised you needed/wanted to clear the whole column out, but what do I know?
19:14:08 <bremner> wli: well, maybe just having a triangular matrix would be a win
19:15:15 <wli> bremner: Once you've isolated things to where there's only one nonzero element in the column, swap rows to put it at the top row, swap columns to put it at the far left, and then peel off the top row and left column to reduce the matrix.
19:15:59 <bremner> wli: I haven't thought about the problem in a recursive way
19:17:26 <bremner> anyway, it was fun talking linear algebra, but I have to sleep now. Bye all
19:17:32 <wli> bremner: I couldn't figure out how to do the bookkeeping for full pivoting for ordinary Gaussian elimination either, or, for that matter, the lower triangular part of the LU decomposition.
19:53:42 <ush> i have a contest
19:53:45 <ush> can i broadcast it
19:53:56 <ush> Item 41 (Gene Salamin): There are exactly 23,000 prime numbers less than 218. <-- 10,000 ush points to the first person that verifies that in haskell
19:54:28 * ush coughs
19:54:55 * wli boggles.
19:56:01 <twb> How can I generate a dependency graph between Haskell modules in src/?  i.e. something in Graphviz .dot notation.
19:56:01 <lambdabot> twb: You have 1 new message. '/msg lambdabot @messages' to read it.
19:56:18 <Riastradh> Grep, sed, and awk!
19:56:19 <twb> I'm thinking something like generating a .d file and then mangling it.
20:00:03 <monochrom> Wow, there are 23000 prime numbers less than 218.
20:01:19 <ush> 2^18, not 218!
20:01:27 <ush> damn
20:01:32 <monochrom> Well you should proofread.
20:01:43 <ush> i pasted it right in from html with a <sup>18</sup>
20:01:53 <wli> That's not a good way to go about it.
20:02:04 <ush> well, it usually doesn't give me problems
20:02:08 <wli> One should count the number of prime numbers in some interval.
20:02:27 <ush> the interval 0 < x < 2^18
20:02:41 <wli> The interval is an input.
20:02:48 <ush> one of you have the function?
20:03:40 <wli> e.g. the command takes N arguments which are intervals (pairs of integers), and produces N lines of output, one count of the number of prime numbers in each of the intervals in the order they were specified.
20:04:04 <ush> ideally
20:04:11 <ush> how do you do everything you said in the last clause
20:04:31 <ush> i can imagine the brute force method, but that's it
20:06:24 <ush> surely we have shortcuts to counting primes?
20:06:24 <wli> There are smarter sieves, e.g. the sieve of Atkin.
20:06:33 <ush> good, brb
20:07:51 <wli> Compute \pi(n) with interval arithmetic until you've narrowed it down to only include one integer.
20:09:12 <ush> evidently, 'melissa o'neill' first implemented this in haskell
20:09:19 <wli> I doubt it can actually be made that accurate.
20:10:45 <ush> i wish you people acted like hackers
20:10:47 <ush> instead of professors
20:11:12 <ush> not you, wli
20:11:30 <ush> everyone else...
20:11:35 <araujo> or hackers professors
20:11:43 <glguy> code crackers?
20:11:45 <glguy> slackers?
20:11:55 <ush> you're stalking me glguy
20:11:55 <jcd1> wasting time with all the chat-room yackers.
20:12:05 <glguy> ush, you keep joining my channels!
20:12:18 <ush> it's your fault for being in all the interesting channels
20:12:31 <monochrom> I act like a merchant. 10000 ush points worth nothing to me.
20:12:45 <ush> they're worth 35 USD each
20:12:54 <jcd1> there's smart ways to compute pi(x) but you don't need them for numbers around 2^18
20:13:29 <monochrom> Give me 10000 CAD and I will find some prof to do it for me for free.
20:13:46 <ush> hell, i can do that just as easy
20:13:47 <monochrom> US pesos worth nothing too.
20:13:52 <ush> i came here because i thought it would be quick
20:15:11 <jcd1> people are probably thinking you're trying to cheat on your homework
20:15:19 <jcd1> not me, mind you.  I'm just lazy.
20:19:49 <pastah> can haskell cook me dinner?
20:19:52 <pastah> @faq
20:19:52 <lambdabot> The answer is: Yes! Haskell can do that.
20:21:44 <Adamant> @faq can Haskell defeat Bill Brasky in man to language combat?
20:21:44 <lambdabot> The answer is: Yes! Haskell can do that.
20:22:10 <ddarius> I've never heard of the Bill Brasky language.
20:22:28 <Adamant> ddarius: it's not ordered
20:22:34 <ush> like i have homework that involves doing that
20:22:38 <Adamant> man to language sounds better in English
20:22:44 <ush> i bet i could pass that off as a term paper
20:22:47 <ush> or a senior thesis
20:28:17 <psygnisf_> @faq: can haskell solve the halting problem?
20:28:17 <lambdabot> The answer is: Yes! Haskell can do that.
20:28:25 <psygnisf_> :o
20:29:00 <lament> @vixen can haskell solve the halting problem?
20:29:00 <lambdabot> church is my favourite computer scientist.
20:29:34 <psygnisf_> holy crap
20:30:13 <psygnisf_> man what a netsplit
20:30:38 --- mode: irc.freenode.net set +o ChanServ
20:31:40 <maxote> psygnisf_: they need backup => they need netsplit, damn it!
20:31:50 <psygnisf_> what? lol
20:31:58 <mib_a9uz8fbo> @help
20:31:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:32:07 <mib_a9uz8fbo> @list
20:32:07 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:32:58 <mib_a9uz8fbo> @help quote
20:32:58 <lambdabot> quote <nick>
20:32:58 <lambdabot> remember <nick> <quote>
20:32:58 <lambdabot> Quote somebody, a random person, or save a memorable quote
20:35:58 <sw17ch> @seen dons
20:35:58 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I don't know when dons last spoke.
20:40:19 <mib_a9uz8fbo> @help hoogle
20:40:19 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
20:40:43 <mib_a9uz8fbo> @hoogle local_search
20:40:44 <lambdabot> No results found
20:41:51 <mib_a9uz8fbo> @hoogle bio.Alignment.AAlign
20:41:51 <lambdabot> No results found
20:43:07 <bos> @swen dcoutts
20:43:08 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 4h 33m 19s ago.
20:43:31 <mib_a9uz8fbo> @help dice
20:43:31 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
20:44:25 <sw17ch> night all
20:45:03 <dolio> @dice 10000000d4
20:45:03 <lambdabot> 10000000d4 => 25004342
20:47:04 <mib_a9uz8fbo> what's the point of the dice command?
20:47:30 <kerlo> The point is to do precisely what it does.
20:47:41 <dons> it gives us random numbers with various constraints on the output
20:47:50 <dons> useful for decision making :)
20:48:24 <mib_a9uz8fbo> @dice 2d1
20:48:24 <lambdabot> 2d1 => 2
20:48:34 <mle> oddly restrictive language that it takes
20:48:43 <mle> better to make d a general operator...
20:49:32 <dolio> @dice 1.5 * (10d6)
20:49:32 <lambdabot> unexpected ".": expecting digit, "d", "+" or end
20:50:19 <mle> @dice 4+3d6*9
20:50:19 <lambdabot> unexpected "*": expecting "+" or end
20:50:28 <mle> @dice 2d2d2
20:50:28 <lambdabot> unexpected "d": expecting digit, "+" or end
20:51:28 <mib_a9uz8fbo> @dice 2+2
20:51:28 <lambdabot> 2+2 => 4
20:51:48 <mib_a9uz8fbo> @dice 2+2d4
20:51:48 <lambdabot> 2+2d4 => 10
20:51:54 <pumpkin_> o.O
20:52:19 <mib_a9uz8fbo> @source dice
20:52:19 <lambdabot> dice not available
20:54:43 <mib_a9uz8fbo> ?fact lambdabot
20:54:43 <lambdabot> I know nothing about lambdabot
20:55:24 <psygnisfive> ?fact myself
20:55:24 <lambdabot> I know nothing about myself
20:55:27 <psygnisfive> :D
20:55:33 <psygnisfive> ?fact haskell
20:55:33 <lambdabot> I know nothing about haskell
20:55:48 <psygnisfive> @faq can haskell make you know stuff about haskell?
20:55:48 <lambdabot> The answer is: Yes! Haskell can do that.
20:56:09 <psygnisfive> @dice teach lambdabot haskell
20:56:09 <lambdabot> unexpected "t": expecting number
20:56:12 <psygnisfive> :o
20:56:15 <psygnisfive> noooo
20:58:36 <mib_a9uz8fbo> I had an interview a couple weeks ago, they said use any language you want so I did all the questions in Haskell.  A couple days later they said my skill set didn't match what they were looking for.
20:59:01 <chrisdone> does anyone remember lokadin?
20:59:20 <lament> mib_a9uz8fbo: was it as ASP.NET developer position?
21:00:05 <mib_a9uz8fbo> ha, no, the job description said they were looking for functional programmers
21:00:37 <lament> aw
21:00:44 <mib_a9uz8fbo> I'd rather poke out my eyes than work on ASP.NET
21:00:45 <lament> must have been some real reason then :)
21:01:06 <mib_a9uz8fbo> hehe, yeah I must suck
21:01:29 <chrisdone> or you didn't suck enough
21:02:41 <wli> To a significant extent, the math-type algorithms are boring to program. Once you've done the math, the programming part is pretty much all relatively simple loops.
21:04:03 <mib_a9uz8fbo> I'd take boring programming over what I'm doing now.
21:04:07 <ush> isn't that more true of other algorithms
21:04:12 <ush> if the math is the exciting part ?
21:04:29 <wli> It's true of a lot of things.
21:04:45 <lament> algorithms are boring, because the problem is known and the solution is known.
21:05:00 <ush> the algorithm is the solution
21:05:02 <lament> And even if the solution is not known, it's still only half as boring.
21:05:02 <ush> that and popularity
21:05:30 <wli> I guess I should say Project Euler vs. math per se.
21:05:53 <ush> project euler is creating problems solely to find solutions
21:05:55 <wli> The math can end up demanding interesting data structures, multiply-indexed data sets, etc.
21:06:06 <ush> rather counterproductive, if you forget its role as an educational tool
21:06:31 <wli> It's far more educational wrt. math than any sort of programming.
21:06:53 <ush> it teaches programming by creating the necessity to understand the language
21:07:05 <ush> assuming it wasn't there to begin with
21:07:17 <wli> And frankly, Haskell abstracts so much of the programming tasks away that it's really not about programming at all when done in Haskell.
21:07:31 <wli> e.g. arbitrary-precision arithmetic
21:08:00 <wli> A fair number of the problems can be smacked down by virtue of Haskell's built-in arbitrary-precision arithmetic.
21:08:03 <ush> i'd say haskell liberates you from needless procedure in programming
21:08:06 <ush> and brings you to the heart of the program
21:08:17 <ush> i think we're in agreement
21:08:52 <wli> i.e. Project Euler isn't a good source of problems to learn programming in Haskell from.
21:09:03 <ush> what is?
21:09:11 <ush> an AI textbook?
21:09:15 <wli> Things like counting the number of primes in an interval aren't a good way.
21:09:26 <chrisdone> ush: SICP
21:09:27 <wli> It's tough without getting too domain-specific.
21:09:29 <mib_a9uz8fbo> Project Euler problems are mostly too simple to learn programming
21:09:46 <ush> mostly
21:09:49 <wli> SICP is time-tested programming pedagogy.
21:09:58 <chrisdone> 100% quality
21:10:04 <ush> SICP huh
21:10:09 <chrisdone> 0.9% 80s
21:10:12 <mib_a9uz8fbo> say you try to learn C++ with Project Euler, you'd really be missing the point of C++
21:10:15 <dolio> Ruby quiz.
21:10:33 <wli> There are probably other problem sets.
21:10:44 <wli> Oh, yeah, the 99 Prolog problems.
21:10:53 <dolio> Although the ruby quiz website stopped updating.
21:11:13 <ush> i'm going to start a new *chan meme, "wherezdapdf"
21:11:18 <ush> let's see how much damage i can cause
21:12:27 <wli> For me, at the level I'm at, Haskell is mostly about monad transformer stacks.
21:12:40 <ush> i got two pages into SICP and got turned off by the creative commons license
21:13:06 <mib_a9uz8fbo> SICP moves too slow
21:13:23 <ush> says the mibbit user
21:13:34 <ush> but how are we supposed to evaluate the quality of what you say if we don't know who you are?
21:14:14 <pumpkin_> the nick certainly isn't the most memorable thing ever
21:14:18 <mib_a9uz8fbo> the wireless drivers don't work on my laptop on linux, and there aren't any irc clients I like for windows
21:14:40 <pumpkin_> mib_a9uz8fbo: how do I pronounce your nick?
21:14:48 <mib_a9uz8fbo> how ever you like
21:14:51 <pumpkin_> aguzatefboe
21:15:31 <ush> wait until the age of open specifications, mib_a9uz8fbo
21:15:35 <ush> it'll be wonderful
21:15:49 <ush> assuming we haven't turned into a 1984-style dystopia by then
21:15:56 * wli needs to do a fair amount of self-teaching and/or professional practice.
21:15:56 <Riastradh> ...turned off by the Creative Commons licence?
21:16:00 <ush> it's really a "wait 5 years and see" kind of thing
21:16:22 * wli needs to put serious thought into how best to learn programming.
21:16:42 <mib_a9uz8fbo> yeah, I don't get why wireless drives aren't open
21:16:55 <Riastradh> One reason is obnoxious FCC regulations.
21:17:02 <ush> write a cascading beowulf cluster AI worm
21:17:14 <ush> to destroy google, or something
21:17:45 <mib_a9uz8fbo> FCC only applies to US
21:17:47 <Riastradh> Specifically, software-controlled radio is a big `no-no' at the FCC, because apparently soldering a radio oneself is unimaginably more difficult than writing software to drive wifi cards into restricted frequency ranges.
21:18:13 <Riastradh> The US supplies a substantial portion of the market for wifi hardware.
21:18:18 <pumpkin_> the whole idea of having restricted frequency ranges is so fragile anyway
21:18:50 <mib_a9uz8fbo> If I wanted to mess with radio communications I wouldn't use wifi cards
21:18:53 <pumpkin_> "outlaw software radios and only the outlaws will have software radios" or something like that :P
21:18:54 <wli> The exercises need to be small enough and self-contained enough to focused, but they also need to have enough scope to be substantial.
21:19:39 <wli> It's a very difficult balance to achieve. It probably requires experience teaching to have reliable judgment on that front.
21:19:40 <ush> i can't wait until encryption is illegal
21:19:48 <ush> that will be a strange week
21:20:00 <SamB> why week ?
21:20:20 <Riastradh> ush, why did the Creative Commons licence under which the text of SICP is available turn you off?
21:20:25 <ush> Riastradh: i was kidding
21:20:52 <mib_a9uz8fbo> if you use encryption you're supporting terrorism, didn't you know?
21:21:23 * SamB proclaims that mib_a9uz8fbo shall henceforth be known as "wacomcast"
21:21:38 <wli> I actually think some of the SICP exercises are too self-contained.
21:22:09 <SamB> mib_a9uz8fbo: but we're also supporting the FBI!
21:22:15 <ush> maybe they think you're too loose
21:22:32 <bohanlon> Anybody here going to BAHUG on Saturday or NEPLS on Thursday?
21:23:13 <wli> Don't you know? Encryption needs to be illegal because it gets in the way of the data mining dissident dragnet!
21:24:08 <SamB> next they'll be outlawing terrabyte ethernet/disk drives
21:24:39 <maxote> SamB, where's the frontier?
21:24:58 <SamB> they haven't done anything like that yet
21:25:31 <SamB> I just figure those would make data mining hard, too
21:25:55 <maxote> SamB, spying .. is not it illegal?
21:26:13 <wli> A mini-database engine might make a decent project. Or maybe a mini-filesystem.
21:26:31 <w0lter> what difference between [a]-[b] and [a]->[a] in map :: (a->b)->[a]->[b] and dropWhile::(a->Bool)->[a]-[a]? Thanks
21:26:40 <wli> Maybe reimplementing a subset of ed(1).
21:26:44 <maxote> damnit netsplit, twice in two hours
21:26:53 <gwern> awesome would be for someone to take up the FUSE binding and rewrite some of the easier FSs like a compressing fuse fs
21:27:05 <wli> Or, perhaps, sed(1).
21:28:08 <wli> Well, I'm speaking of programming exercises.
21:28:29 <wli> I'm not sure if FUSE is simplistic enough or not.
21:29:15 <ush> what does FUSE do again
21:29:26 <pumpkin_> filesystem in userspace
21:29:32 <SamB> how does fuse compare with 9p?
21:29:32 <wli> It's a userspace filesystem framework for Linux.
21:29:37 <ush> ah, yes
21:29:38 <ush> nifty
21:29:59 <ush> SamB: my cellphone uses 9p, ever since i took it to those satanists
21:30:07 <w0lter> what difference between [a]->[b] and [a]->[a] in map :: (a->b)->[a]->[b] and dropWhile::(a->Bool)->[a]-[a]? Thanks
21:30:18 <ush> get it? cause my cellphone's in Limbo ;);)
21:30:25 <wli> I don't know enough about either to say. 9p I know even less about.
21:31:12 <gwern> ush: too obscure a joke. most people've not heard very much about inferno compared to plan 9
21:31:25 <wli> I've heard of Inferno.
21:31:47 <ush> hey, you reach one man
21:31:57 <w0lter> Oh, understand different type
21:32:52 <SamB> ush: uh, limbo is not that closely related to styx
21:33:14 * ush throws up
21:33:16 <wacomcast> it's on the other side of styx
21:33:33 <ush> i'm not sure those are even the same religion
21:33:56 <SamB> wacomcast: only if you're accessing a filesystem provided by a program running on an inferno system!
21:34:37 <wacomcast> I'm going to create a file system called "Dante"
21:35:26 <pumpkin_> will it be heavenly?
21:35:29 <pumpkin_> or infernal?
21:35:38 <gwern> styx is more classical greek, limbo is modern catholicism...
21:35:41 <pumpkin_> or will it allow you to purge your deleted files?
21:36:05 <wacomcast> it will have 9 levels of permissions, none of which give you write access
21:36:12 <pumpkin_> lol
21:36:13 <ush> lol
21:36:21 <SamB> lol indeed
21:36:33 <ush> SamB you follower
21:36:41 <pumpkin_> will it classify your porn into the various vices?
21:36:49 <SamB> I was holding my noodle bowl!
21:37:23 <SamB> pumpkin: isn't that just (const Lust) ?
21:37:33 <pumpkin_> depends on what kind of fetishes you have :)
21:43:52 <Philippa_> pumpkin: Sloths don't seem all that common a choice though
21:44:12 <SamB> hah
21:47:29 <wacomcast> >c :: String -> String
21:52:34 <wacomcast> Has anyone here played with clojure?
21:54:27 <wacomcast> @run map (+) [1..10]
21:54:28 <lambdabot>       Overlapping instances for Show (a -> a)
21:54:28 <lambdabot>        arising from a use of `s...
21:54:46 <Heffalump> overlapping instances??
21:55:09 <Heffalump> @run (+1) :: Int -> Int
21:55:10 <lambdabot>       Overlapping instances for Show (Int -> Int)
21:55:10 <lambdabot>        arising from a use o...
21:55:19 <wacomcast> @run map (+1) [1..10]
21:55:20 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
21:55:22 <Heffalump> @run (id) :: Char -> CHar
21:55:23 <lambdabot>   Not in scope: type constructor or class `CHar'
21:55:27 <Heffalump> @run (id) :: Char -> Char
21:55:28 <lambdabot>       Overlapping instances for Show (Char -> Char)
21:55:28 <lambdabot>        arising from a use...
21:55:34 <pumpkin_> doesn't simple-reflect have an a->a Show?
21:55:39 <pumpkin_> not sure what else does though
21:55:51 <Heffalump> yeah, I was wondering if it's that and a standard show functions instance
21:59:41 <wacomcast> @source show
21:59:42 <lambdabot> show not available
22:00:38 <pumpkin_> it's not @source, it's @src, probably
22:00:43 <pumpkin_> @src [] show
22:00:43 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:00:50 <pumpkin_> still not :) but I think that's the idea
22:00:55 <pumpkin_> @src [] (>>=)
22:00:55 <lambdabot> xs >>= f     = concatMap f xs
22:01:07 <wacomcast> @src show
22:01:07 <lambdabot> show x = shows x ""
22:01:07 <pumpkin_> given that show is a method of Show
22:01:14 <pumpkin_> oh it isn't :)
22:01:18 <pumpkin_> I was confused
22:01:22 <wacomcast> @src shows
22:01:22 <lambdabot> Source not found. That's something I cannot allow to happen.
22:01:30 <pumpkin_> that's probably the Show method
22:01:35 <pumpkin_> @src Show
22:01:35 <lambdabot> class  Show a  where
22:01:35 <lambdabot>     showsPrec :: Int -> a -> ShowS
22:01:35 <lambdabot>     show      :: a   -> String
22:01:35 <lambdabot>     showList  :: [a] -> ShowS
22:01:43 <pumpkin_> weird
22:01:45 <wacomcast> ah
22:04:32 <wacomcast> @src State (>>=)
22:04:32 <lambdabot> Source not found. There are some things that I just don't know.
22:11:51 <sm> so, Dijkstra said "The competent programmer is fully aware of the limited size of his own skull. He therefore approaches his task with full humility, and avoids clever tricks like the plague."
22:12:22 <sm> I enshrined it in my project's NOTES. But, I'm starting to wonder if it's compatible with using haskell :)
22:13:02 <Philippa_> heh. The sort of clever tricks Haskell tends to encourage aren't quite the sort Dijkstra had in mind
22:13:41 <sm> can you code a medium-large haskell app with non-clever code ?
22:14:08 <sm> what's clever today may not be tomorrow
22:14:13 <glguy> clever is a really ambiguous term
22:14:18 <sm> but it may be clever again next year..
22:14:21 <glguy> ask that again with a more specific one
22:14:58 <Philippa_> sm: if monad transformers don't count as 'clever', then definitely
22:15:23 <Philippa_> if you'll allow a couple of important idioms as non-clever, then definitely
22:18:32 <sm> Philippa_: good to hear
22:19:01 <sm> I think I may have to grant an exception for Makefile
22:19:32 <quicksilver> it's worth pointing out that "clever tricks" is more specific than just "clever".
22:22:17 <Philippa_> sm: you can do an awful lot with just ghc --make, it's great :-)
22:23:28 <sm> Philippa: what about, say, counting patches since release tag for the version string
22:25:23 <sm> or generating support files for regression tests or doing pre-release sanity checks or uploading to hackage ?
22:26:39 <Philippa_> *nod*. Fair enough - though at some point I should really look at how much of that can be done with cabal and possibly a little preprocessor abuse instead
22:27:28 <sm> I don't see it being as easy ("easy").. but the idea is intriguing
22:32:47 <Philippa_> sm: if you're comfortable doing it with makefiles then fair enough - the comment really was speculative :-)
22:36:27 * wli forgets the deal with mutually-recursive modules.
22:38:45 <wli> Does ghc --make do those or do you still need .hi-boot files?
22:39:06 <dolio> You need the boot files.
22:40:38 <wli> I don't see why it can't chase down strongly-connected components to spew out equivalents of those in an automated fashion, but I rarely (if ever) have needed mutually recursive modules, and it's not like I'm remotely capable of patching ghc to support them.
22:40:46 <wli> (in that fashion)
22:47:22 <Philippa_> you can use .hs-boot now, which is a bit more pleasant
22:48:16 <wli> How do they differ from the old .hi-boot files?
22:49:50 <dmwit> They're spelled differently. ;-)
22:50:23 <pumpkin_> hs-boot allows me to alternate between hands when typing
22:50:27 <pumpkin_> hi are on the same hand
22:50:52 <dmwit> You people and your wacky qwerty keyboards.
22:50:57 <pumpkin_> hah
22:51:05 <pumpkin_> I was just wondering if my statement was true on dvorak
22:51:37 <imyourmonad> if i want to do an mp3player in haskell, what would i use for playing mp3 in a separate thread? STM and refs?
22:51:51 <pumpkin_> not sure STM would do much for you here
22:51:55 <imyourmonad> also do you suggest I use xmonad or gtk2hs?
22:52:07 <pumpkin_> those are rather different
22:52:11 <imyourmonad> pumpkin:nah i just need to kill the thread nce it is played
22:52:17 <pumpkin_> gtk2hs for GUI probably :)
22:52:27 <imyourmonad> but refs? or how do I use threads in haskell?
22:52:33 <imyourmonad> isnt xmonad a GUI lib?
22:52:43 <pumpkin_> it's a window manager afaik
22:53:02 <quicksilver> @hoogle forkIO
22:53:02 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
22:53:12 <quicksilver> imyourmonad: Control.Concurrent is how you use threads in GHC ;)
22:53:46 <pumpkin_> @hoogle forkOS
22:53:46 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
22:53:55 <pumpkin_> if you wanna be heavy
22:54:20 <pumpkin_> does forkOS give you a new thread regardless of +RTS -Nx settings?
22:54:55 <wli> I don't remember .hi-boot well enough to remember the difference.
22:55:21 <wli> pumpkin: forkOS is for kernel threads IIRC so yes.
22:56:36 <quicksilver> pumpkin_: no.
22:56:47 <Philippa_> wli: .hi-boot uses the internal 'interface' format, .hs-boot is basically haskell code
22:57:04 <quicksilver> pumpkin_: forkOS makes a new lightweight thread which is 'bound' to a particular capability.
22:57:09 <pumpkin_> aha
22:57:25 <quicksilver> there is almost no point using it.
22:57:29 <Alpounet> Hi all. Why do I get an error with that : helper (' ':xs) = helper xs
22:57:40 <quicksilver> it exists for compatibility with FFI libraries that use thread-local state.
22:57:50 <Alpounet> (parse error on input '=', it tells me)
22:58:01 <pumpkin_> I see
22:58:06 <byorgey> Alpounet: that looks fine to me.  it's probably something on a previous line.
22:58:33 <Saizan> Alpounet: the ghci prompt doesn't accept definitions, you've to put those in files
22:58:38 <quicksilver> Alpounet: you probably used that in a context where it's not expecting a definition to appear
22:58:44 <quicksilver> > 1 + (helper = 4)
22:58:45 <lambdabot>   <no location info>: parse error on input `='
22:58:51 <quicksilver> that kind of context, for example :)
22:59:03 <wli> Philippa: It vaguely seems like progress is being made toward handling mutually recursive modules completely automatically.
22:59:11 <jkup> would it be better to use guards in that case? helper (x:xs) | x == ' ' = helper xs | otherwise = x : helper xs
22:59:31 <Alpounet> Saizan, quicksilver, byorgey, ok I'm pasting it... But the whole function definition is in a file and I just :load it in ghci
22:59:41 <wli> I wonder if non-ghc Haskell implementations already do so.
22:59:41 <dmwit> jkup: In that specific case, it would be better to use filter.
23:00:27 <Alpounet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1809#a1809
23:00:45 <dmwit> indentation
23:00:46 <quicksilver> jkup: in general, pattern matching is faster than ==
23:01:01 <dmwit> Alpounet: You've got to indent all the clauses in the where block equally.
23:01:23 <dmwit> Alpounet: But in this specific case, let me again recommend "filter".
23:01:25 <quicksilver> alternatively, and less friendly: BZZZZT - you used a TAB. GO directly to Jail. Do not pass go.
23:01:31 <dmwit> helper = filter (/= ' ')
23:01:33 <Alpounet> dmwit, I actually learn, and have two implementations, the first is the one I pasted, the other is a one-liner with filter
23:01:45 <dmwit> Alpounet: Ah, okay. =)
23:01:55 <quicksilver> basically don't use literal TABs with haskell indentation unless you know exactly how that works :)
23:02:18 <Alpounet> but I just wanted to be sure pattern matching one the "current head of the list" was working, i.e pattern matching i'm currently on a space caracter
23:02:41 <Alpounet> Ok, indentation problem
23:02:44 <quicksilver> Alpounet: well, do you understand the answer? It's the indentation of the "helper = " clauses
23:03:06 <Alpounet> yep.
23:03:18 <quicksilver> Alpounet: incidentally, there's no need to use "where" here. You could have just had those three cases for 'strip' instead.
23:03:23 <Alpounet> I'm just writing the whole thing with a bad editor :(
23:04:04 <RamzaB> can anyone help me with installing vi/emacs for haskell, I've never used either of them before
23:04:29 <Alpounet> RamzaB, linux / windows ? Which distribution of linux, if linux ?
23:04:37 <RamzaB> im using windows
23:04:48 <dmwit> Just grab the binaries from their respective websites.
23:04:48 <Alpounet> first, download e.g emacs for windows
23:04:57 <Alpounet> then download "haskell-mode" for emacs
23:05:11 <Alpounet> and install it the way described on a README file or on the website
23:05:16 <Alpounet> and you'll be done :-)
23:05:21 <quicksilver> haskell-mode will be incorporated in a win32 download package, I imagine.
23:05:23 <dmwit> RamzaB: Don't listen to Alpounet, he's speaking heresy!
23:05:28 <quicksilver> it certainly is in the OSX one.
23:05:36 <RamzaB> thank you
23:05:39 <wli> Hmm. What's a good data structure to represent an ordering on a finite set?
23:05:42 <sm> who's doing i18n/gettext in their haskell app ? anyone ?
23:05:43 <dmwit> Get vim with its bundled syntax highlighting, then grab the Haskell mode.
23:06:07 <byorgey> wli: what operations do you want to support?
23:06:12 <quicksilver> wli: A list :)
23:06:25 <quicksilver> [7,1,3,5] -- finite ordered set.
23:06:27 <RamzaB> just wondering, is there no IDE for haskell?
23:06:29 <dmwit> A function!
23:06:41 <dmwit> f 7 = 1; f 1 = 3; f 3 = 5 -- a finite ordered set
23:06:43 <Alpounet> dmwit, haha, a good old troll come back... Who is gonna win this time ? ;-)
23:06:54 <quicksilver> RamzaB: not a complete one.
23:07:04 <dmwit> RamzaB: Didn't you ask that last night?
23:07:09 <dmwit> The answer is the same tonight...
23:07:09 <byorgey> a predicate!
23:07:14 <wli> byorgey: comparison, removal from the set, and moving to the highest precedence.
23:07:24 <byorgey> p 7 1 = True; p 1 3 = True; p 3 5 = True  -- a finite ordered set
23:07:25 <RamzaB> yea
23:07:38 <quicksilver> RamzaB: there is a plugin for visual studio which as far as I know has bit-rotted; a plugin for eclipse which is bit-rotted; and a mode for emacs which is very good but many people wouldn't call an IDE.
23:07:53 <quicksilver> there is also leksah which is not remotely finished
23:08:05 <byorgey> wli: and this is supposed to be a total ordering?
23:08:05 <dmwit> There's a nice GHC compiler plugin for vim, too.
23:08:26 <wli> byorgey: Construction of the initial ordering doesn't really matter how it's done. Total ordering, yes.
23:08:42 <quicksilver> wli: that sounds like a priority queue
23:09:13 <Alpounet> Btw, which implementation is the faster : the one I pasted (with correct identation) or the one with filter ? I'd think the one with pattern matching, but not quite sure...
23:09:28 <wli> quicksilver: Maybe so.
23:10:37 <jkup> Alpounet: strip :: String -> String; strip = filter(/= ' ')
23:10:43 <dmwit> Alpounet: It's not likely to be noticeable.
23:11:03 <jkup> I think that is what you're after
23:11:27 <Alpounet> jkup, that's exactly my second version.
23:11:46 <wli> Okay, I need double indexing: one by some sort of handle to the element for pointer-like retrieval, another for priority queue -like operations, and in whatever I'm indexing, the associated data is contained.
23:12:24 <Alpounet> So there isn't any reason to prefer one to another in that case, except for the filter version's shortness
23:13:38 <p_l> newsham: your gift of VMS install media killed my productivity xD
23:13:51 <wli> Stuff the things in an array so the array indexes act as pointers, e.g. Array Int (Int, AssocData), then Map Int Int is the priority queue, and from there, just keep them in sync.
23:14:12 <dobblego> is there a function to change the working directory?
23:14:59 <Axman6> @hoogle dir
23:14:59 <lambdabot> Text.XHtml.Transitional dir :: Html -> Html
23:14:59 <lambdabot> module System.Directory
23:14:59 <lambdabot> System.Posix.Internals Directory :: FDType
23:15:06 <Axman6> @hoogle directory
23:15:06 <lambdabot> package directory
23:15:06 <lambdabot> module System.Directory
23:15:06 <lambdabot> System.Posix.Internals Directory :: FDType
23:15:10 <Axman6> bah
23:15:23 <Alpounet> @hoogle cd
23:15:23 <lambdabot> System.Posix.Types data CDev
23:15:23 <lambdabot> System.Posix.Internals type CDir = ()
23:15:23 <lambdabot> System.Posix.Internals type CDirent = ()
23:15:34 <wli> Use maxView/maxViewWithKey to find the next one to fiddle with, and then a disaster occurs when I try to do the rest of everything with them.
23:15:40 <Axman6> @hoogle pwd
23:15:40 <lambdabot> No results found
23:16:12 <Alpounet> @src cd
23:16:12 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:16:17 <dobblego> I looked in System.Directory and System.Environment
23:17:05 <Alpounet> http://www.haskell.org/onlinelibrary/directory.html => setCurrentDirectory, I guess
23:17:16 <wli> setCurrentDirectory looks like it.
23:17:38 <dobblego> oh missed that one cheers :)
23:17:39 <Alpounet> "Error reporting. setCurrentDirectory may fail with: isPermissionError if the user is not permitted to change directory to that specified; or isDoesNotExistError if the directory does not exist."
23:17:47 <wli> FilePath is just a String?
23:17:55 <Alpounet> :-)
23:18:09 <wli> Shouldn't it be [String] to abstract out directory separators?
23:18:37 <Alpounet> That's probably internally handled
23:18:48 <jrockway> when you go down that road, you end up with Common Lisp ;)
23:18:50 <Alpounet> \\ or / on windows, / on linux
23:18:50 <wli> It should have another failure for illegal characters in the path.
23:19:22 <wli> I'm not sure but I think Windows is \ only.
23:20:05 <wli> \NUL and the separator are illegal characters in most kernels, too.
23:21:40 <Alpounet> wli, for handling special caracters ('\n', '\t', etc), we must double all the "\" when working on Windows directories, in most languages ...
23:21:49 <jeffz`> windows accepts / in most paths, unix style paths are relative to the current drive
23:21:51 <Alpounet> I guess this is the same thing in Haskell
23:22:47 <quicksilver> Alpounet: pattern matching is faster than == in general
23:22:54 <quicksilver> Alpounet: in particular, if there are lots and lots of patterns.
23:23:11 <dmwit> wli: FilePath is String, but it provides </> as a function to concatenate to FilePaths with teh appropriate separator.
23:23:17 <quicksilver> Alpounet: for this case of only one pattern (' ') it is reasonable to expect the compiler to generate the same code.
23:23:41 <Alpounet> ok
23:23:50 <Alpounet> Is it -s to see generated assembly code ?
23:24:01 <quicksilver> -ddump-asm or something similar
23:24:04 <Alpounet> ok
23:24:18 <quicksilver> Alpounet: there is a good reason to use filter, though
23:24:30 <quicksilver> filter is defined in terms of 'build' which has RULES
23:24:32 <quicksilver> so it fuses.
23:24:37 <quicksilver> your hand-written filter won't fuse.
23:25:03 <Alpounet> 'fuse' ?
23:25:28 <Axman6> become super Ã¼ber fast
23:25:30 <Axman6> >_>
23:25:46 <Cale> Alpounet: the process by which multiple loops/recursions are combined into a single pass by rewriting code
23:25:54 <pumpkin_> or gets rid of intermediate generation/consumption of datastructures
23:26:28 * Axman6 is realy liking this album
23:26:30 <Axman6> ll*
23:26:38 <quicksilver> Alpounet: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
23:26:50 <quicksilver> in particular 8.14.3 List fusion
23:27:20 <Alpounet> Ok, thanks.
23:28:12 <quicksilver> because of list fusion, it makes sense to use "foldr" "map" and "filter" by name instead of writing your own versions
23:28:55 <Alpounet> Okay.
23:29:01 <CTA> is anyone here an accountant?
23:29:16 <pumpkin_> they don't ever really define "good" in the sense of good consumer/producer on that page
23:29:29 <mmorrow> Alpounet: use -S to get a .s
23:29:51 <Alpounet> Okay, like with g{cc|++}
23:29:58 <pumpkin_> ghc-core dumps it too doesn't it? along with the core
23:30:01 <jkup> ghc -S  blah.hs
23:34:41 <mmorrow> pumpkin: it looks like ghc-core uses "-ddump-simpl -ddump-asm -ddump-simpl-stats"
23:37:49 <Alpounet> strip :: Char -> String -> String;strip c s = filter (/= c) s <<< is there a way to retire "s" from there ?
23:38:08 <mmorrow> pumpkin: did that last msg i sent make it?
23:38:18 <mmorrow> (pumpkin: it looks like ghc-core uses "-ddump-simpl -ddump-asm -ddump-simpl-stats")
23:38:19 <pumpkin_> yup :)
23:38:23 <mmorrow> heh, cool
23:39:43 <mmorrow> pumpkin: the way i find the available options is in ghci type ":set -ddump-" and then hit tab a few times
23:39:50 <mmorrow> it works nicely
23:39:58 <mmorrow> tabcompletefishing++
23:40:03 <pumpkin_> awesome
23:42:08 <mmorrow> also, you can set both -fobject-code and -ddump-asm in ghci so when you :load Foo.hs all the asm will fly by
23:42:33 <pumpkin_> sounds unpleasant :P
23:42:34 <mmorrow> unfortunately -fobject-code only applies to _loaded_ files and not interactively typed expressions..
23:42:40 <pumpkin_> I don't read x86 for pleasure
23:42:49 <mmorrow> pumpkin_: haha, it is slightly actually :)
23:43:04 <mmorrow> -ddump-bcos and a few others are actually interesting though
23:43:08 <pumpkin_> once we get GHC on arm, I might start
23:43:19 <pumpkin_> just bcos it wants to?
23:43:27 <mmorrow> you know it
23:43:35 <pumpkin_> what is bcos? :P
23:43:41 <mmorrow> bytecode objects
23:44:05 <mmorrow> it dumps the bytecode asm (w/ random core bits shoved in in random places :(  )
23:44:09 <Alpounet> any answer to my previous question ?
23:44:15 <pumpkin_> ah
23:44:30 <pumpkin_> Alpounet: yup, just leave it out
23:44:36 <mmorrow> Alpounet: oh, you can just leave off the s
23:44:45 <pumpkin_> I think it's called eta reduction or something fancy like that
23:44:53 <mmorrow> @pl \c s -> filter (/= c) s
23:44:53 <lambdabot> filter . (/=)
23:45:30 <mmorrow> (or (\c -> filter (/=c)) of course)
23:46:29 <mmorrow> (h . g . f) x y ==> (h . g (f x)) y ==> h (g (f x) y)
23:46:52 <Alpounet> pumpkin_, yep I know the name, but the problem is that I define a function with two args, but GHC will see only one of the args, right ?
23:46:54 <mmorrow> @pl \x y -> h (g (f x) y)
23:46:54 <lambdabot> (h .) . g . f
23:46:57 <mmorrow> oops
23:47:08 <Alpounet> or he is smarter than I thought :p
23:47:10 <pumpkin_> Alpounet: how do you mean see one args?
23:47:34 <mmorrow> @pl \x y -> h (g (f x)) y
23:47:34 <lambdabot> h . g . f
23:47:40 <Alpounet> strip c = filter (/= c)
23:47:47 <jkup> > :t filter (/= ' ')
23:47:48 <lambdabot>   <no location info>: parse error on input `:'
23:47:51 <Alpounet> _this_ is the shorter way ?
23:47:58 <mmorrow> either that or
23:48:04 <mmorrow> strip = filter . (/=)
23:48:12 <Alpounet> ok
23:49:11 <mmorrow> Alpounet:   \x -> f x ==== f
23:49:33 <mmorrow> so (foo x = f x ===> foo = f)
23:49:53 <mmorrow> @pl \x y -> g (f x y)
23:49:53 <lambdabot> (g .) . f
23:49:58 <mmorrow> @pl \x y z -> g (f x y z)
23:49:58 <lambdabot> ((g .) .) . f
23:50:03 <mmorrow> @pl \x y z a -> g (f x y z a)
23:50:03 <lambdabot> (((g .) .) .) . f
23:50:06 <mmorrow> and so on
23:51:22 <mmorrow> @type filter (/=' ')
23:51:23 <lambdabot> [Char] -> [Char]
23:52:00 <Alpounet> Okay, thanks.
