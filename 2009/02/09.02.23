00:00:11 <lifflander> The user can enter a large number, which I want to parse as an Integer.
00:01:41 <pumpkin_> read str :: Integer
00:01:44 <mmorrow> readM :: (Read a) => String -> Maybe a; readM s = case reads s of [] -> Nothing; (a,_):_ -> Just a
00:01:45 <lifflander> This part of it works fine until the length to the input is over 300 characters.
00:01:58 <mmorrow> hmm, what happens?
00:02:04 <lifflander> Then I get a read parse error.
00:02:18 <mmorrow> , read (replicate 1000 '1') :: Integer
00:02:21 <lunabot>  1111111111111111111111111111111111111111111111111111111111111111111111111...
00:02:34 <mmorrow> , read (replicate 1000 '1') :: Int
00:02:34 <lifflander> Could it be getLine?
00:02:35 <lunabot>  -954437177
00:02:50 <mmorrow> lifflander: maybe, but that sounds odd
00:03:07 <pumpkin_> lifflander: can you show us the relevant piece of code?
00:03:12 <lifflander> It works perfectly until the integer gets to big
00:03:14 <lifflander> Okay...
00:03:57 <lifflander> repl i key num = do putStr prompt
00:03:58 <lifflander>                     input <- getLine
00:03:58 <lifflander>                     case head input of
00:03:58 <lifflander>                       '1' ->
00:03:58 <lifflander>                           do (k2@(pub,pri)) <- genKey i
00:04:03 <mmorrow> heh
00:04:46 <mmorrow> lifflander: you can paste at hpaste.org :)
00:04:48 <pumpkin_> @where hpaste
00:04:48 <lambdabot> http://hpaste.org/
00:04:57 <lifflander> okay
00:05:03 <alinp> Hi
00:05:36 <lifflander> I'm getting an internal server error at hpaste.org
00:05:36 <alinp> does anyone knows a repository where a cabal command line for ubuntu is ?
00:05:42 <mmorrow> uhoh
00:05:44 <Axman6> @where hpastetwo
00:05:44 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
00:05:49 <Axman6> lifflander: ^^
00:05:51 <mmorrow> lifflander: try moonpatio.com
00:05:58 <mmorrow> (you don't need the 8080)
00:06:07 <Axman6> mmorrow: what's up with hpaste anyway?
00:06:14 <mmorrow> i dunno, i'll see
00:06:14 <Axman6> i heard you're looking after it now?
00:06:15 <pumpkin_> aren't they different vhosts on the same box?
00:06:22 <alinp> I found that can be build manually, but I thought maybe is there a repository for it
00:06:26 <mmorrow> Axman6: yeah, i didn't know it was down
00:06:29 <pumpkin_> alinp: not that I know of
00:06:45 <pumpkin_> Axman6: how old are you?
00:06:46 <alinp> pumpkin_: so I should build it manually ?
00:06:46 <Axman6> mmorrow: ah, well it's been down for the last few hours
00:06:49 <mmorrow> pumpkin: they're actually on two different ones but i'm eventually gonna get around to merging them
00:06:50 <Axman6> 19
00:06:55 <pumpkin_> alinp: bootstrap.sh should work
00:07:04 <Axman6> pumpkin_: why?
00:07:05 <pumpkin_> mmorrow: ah
00:07:14 <mmorrow> wuh, "database is locked"
00:07:14 <pumpkin_> Axman6: just been trying to get a feel for ages in here :P
00:07:16 <lifflander> Okay, I'm pasted it here @where http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1549#a1549
00:07:34 <pumpkin_> mmorrow: I thought you might have some sort of regular db backup script that locked the db as it was backing it up
00:07:38 <pumpkin_> but it's been running for a while now
00:07:38 <TomMD> pumpkin_: What, are you making a wiki?
00:07:48 <pumpkin_> TomMD: nope, just for my own edification
00:08:03 <mmorrow> hpaste2 uses an sqlite3 db
00:08:03 <Axman6> what about YOU pumpkin_? huh?
00:08:10 <pumpkin_> 24
00:08:13 <Axman6> sqlite++
00:08:48 <TomMD> And studying, pumpkin_?
00:08:52 <pumpkin_> I'm actually an old 70-year-old pervert trying to ensnare the young'uns in here by pretending to be interested in their language
00:08:57 <pumpkin_> TomMD: yup
00:09:05 <lifflander> Did you see the code?
00:09:33 <pumpkin_> lifflander: yeah, but I don't get it
00:09:57 <pumpkin_> pn == "@pn" ?
00:09:59 <mmorrow> weird. anyone have an idea why a "hpaste.db-journal" would have been created (and who/what would have done so?)
00:10:51 <lifflander> That's for a macro that can be used in the REPL...if not then it is an Integer than needs to be read
00:11:59 <pumpkin_> and that's PublicKey Integer Integer ?
00:12:06 <lifflander> Yes.
00:12:30 <lifflander> The issue as stated before: it works fine when 1 - ~300 digits are inputted after that I get a parse error from read.
00:12:47 <lifflander> I'm testing right now on a small example...
00:13:30 <BMeph> lifflander: Sounds like something's converting your number into a Double, somewhere inside your program.
00:15:17 <mmorrow> hmm, looks like the Takusen sqlite3 binding isn't "handl[ing] the SQLITE_BUSY condition..." or something
00:16:32 <lifflander> What would that happen -- considered that PublicKey is of type Integer -> Integer
00:17:00 <pumpkin_> yeah, it seems unlikely, although the ~300 does sound like a Double :)
00:17:21 <kmeyer> so why does Bulat even hang out on haskell-cafe?
00:17:46 <pumpkin_> kmeyer: he likes haskell and likes to stir up shit? :P
00:17:46 <mmorrow> ok, hpaste.org is working
00:17:54 <lifflander> I will try to comment out the macro and insert the read function right the PublicKey
00:18:19 <kmeyer> pumpkin_: seems more like a troll to me
00:19:45 <lifflander> That did not fix the problem.
00:20:32 <glguy> complaints about the mailing list are best kept out of #haskell. we don't need the ML's problems dragging our channel down :)
00:21:19 <pumpkin_> lifflander: try printing out the value that you're about to read before you read it?
00:22:06 <pumpkin_> the mailing list has been awfully quiet for the past few hours
00:23:09 <lifflander> Okay...I just dumped the GHCI output. Look here: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1549
00:23:12 <lifflander> Last post.
00:24:05 <pumpkin_> did you print out what you were reading?
00:24:43 <lifflander> No, I'm modifing it now.
00:24:55 <gaze__> how would setuiding tend to work out with the scheduler?
00:25:36 <lifflander> I just think I found the problem a ^D was in there around 300 digits in?
00:25:43 <lifflander> Why would this be happening?
00:25:46 <pumpkin_> that would do it
00:26:19 <lifflander> How would that get in the string? any terminal experts?
00:26:28 <gaze__> like, is there any way that I could drop privilages, pick 'em up to write a file, and then drop 'em again but not get pulled out to do something else?
00:26:37 <mmorrow> glguy: i think the Takusen sqlite binding might not be handling the case of SQLITE_BUSY correctly (or something like this)
00:26:41 <mmorrow> glguy: http://www.mail-archive.com/sqlite-users@sqlite.org/msg28225.html
00:26:58 <mmorrow> "Don't use sqlite3_exec. Use sqlite3_step and test the returned status.  When you get an SQLITE BUSY you need to clear the contention. Try a short wait and relaunching the SQL statement with sqlite3_step."
00:27:08 <ivanm> @tell matthew-_ I've just remembered there's another change to graphviz that I wanted to make (ratio of output IIRC)... I'll send you an updated version of my changes in a few hours
00:27:08 <lambdabot> Consider it noted.
00:27:17 <lifflander> Thanks for the help every one.
00:27:19 <glguy> mmorrow, the insides of Takusen are a crazy labrynth to me
00:27:33 <mmorrow> glguy: heh, yeah they're "amusing"
00:28:21 <glguy> labyrinth*
00:28:32 <pumpkin_> lifflander: maybe it's just an artifact of you copying and pasting? have you tried typing it out by hand? (I'll wait 20 minutes for you to finish if you want :P)
00:29:04 <pumpkin_> mmorrow: you should get on twitter!
00:29:29 <pumpkin_> you gotta get the 2.0-ness going
00:30:09 <lifflander> Yes I have tried that...I am running the shell in inferior mode in Emacs, maybe Emacs is inserting for some reason.
00:31:13 <mmorrow> pumpkin_: heh, i might
00:31:49 <lifflander> I just applied a filter to the list of chars to get out everything but numbers, that fixed the problem.
00:35:11 <dons> when you look inside takusen, you see oleg's brain
00:35:13 <gaze__> okay... when exactly will whatever handles concurrency cause a process to yield?
00:35:38 <dons> gaze__: allocating
00:35:41 <dons> or calling 'yield'
00:35:55 <gaze__> hmm...
00:35:56 <dons> gaze__: if you allocate memory, you risk having a new thread scheduled
00:36:10 <dons> which is nice if you want to hide latency :)
00:36:32 <dons> not sure we're quite at the level yet though
00:37:26 <lifflander> Bye.
00:38:22 <dmead_home> yo guys
00:38:24 <dmead_home> how do you say
00:38:29 <dmead_home> > map (1+) [1,2,3]
00:38:30 <lambdabot>   [2,3,4]
00:38:31 <dmead_home> in lisp
00:38:52 <glguy> mapcar
00:39:10 <glguy> (mapcar (lambda (x) (1+ x)) '(1 2 3))
00:39:11 <glguy> I'd guess
00:39:49 <artyoms> glguy: oops, you should write (+ 1 x)
00:40:01 <piksi> hello, i'd love to hear if there are some more sophisticated or preferred ways of using ogl with haskell than fieldtrip?
00:40:11 <glguy> Oh, I was thinking they had a 1+ function
00:40:20 <glguy> maybe I'm thinking of Factor instead
00:40:35 <opqdonut> incf ;)
00:41:04 <artyoms> piksi: I don't think that fieldtrip is "sophisticated"
00:41:09 <glguy> someone with a clisp interpreter try that 1+
00:41:14 <hotaru2k3> glguy: there's actually been talk of getting rid of 1+ in factor
00:41:37 <mmorrow> [1]> (1+ 1)
00:41:37 <mmorrow> 2
00:41:40 <mmorrow> (clisp)
00:41:43 <glguy> hurray!
00:41:44 <piksi> artyoms: and that's why i was asking
00:41:46 <artyoms> piksi: fieldtrip should be easy to use, but I haven't used it :)
00:42:32 <artyoms> piksi: what are you trying to do?
00:43:34 <piksi> artyoms: looking for a production ready way to do ogl visualisations for haskell from procedurally generated content
00:43:47 <mmorrow> one thing that isn't in any std lib that i'm amazed is missing is (some equivalent form of) data a ::: b = a ::: b
00:44:13 <opqdonut> err, data (a,b) = (a,b) ?
00:44:14 <glguy> there's a library of strict tuples
00:44:15 <mmorrow> there's currently no (in a base lib) way to get that
00:44:18 <artyoms> piksi: i'd go with sdl/opengl bindings if i were to use haskell for this task
00:44:19 <glguy> if that's what you're looking for
00:44:20 <mmorrow> tuples don't work though
00:44:27 <mmorrow> oops
00:44:28 <opqdonut> ah, nonstrict
00:44:29 <mmorrow> i meant:
00:44:41 <artyoms> piksi: you should post your question on reactive/fieldtrip mailing list
00:44:52 <mmorrow> data T a b = Tip a | T (T a) (T a)
00:45:15 <mmorrow> so you can foldl1 T . fmap Tip
00:45:23 <glguy> where does 'b' come in?
00:45:30 <mmorrow> ah, delete that
00:45:35 <opqdonut> :D
00:45:35 <piksi> artyoms: oh, there was already libsdl bindings for haskell? stupid me :-)
00:45:36 <mmorrow> data T a = Tip a | T (T a) (T a)
00:45:46 <opqdonut> so a binary tree type?
00:45:52 <mmorrow> yes
00:46:12 <glguy> mmorrow, I had to define my own today :( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1637
00:46:29 <mmorrow> i define that exact T type in probably 25% of all modules i write
00:47:21 <opqdonut> if we had monomorphic tuples / fixed-length lists, that would be easy
00:47:45 <opqdonut> data Tuple a = Tuple a a; type Tree = Mu Tuple
00:48:03 <mmorrow> yeah, that's exactly why it fills the gap left by tuples
00:48:08 <piksi> artyoms: anyway, thanks!
00:49:26 <mmorrow> (how this came up is i was just thinking of a one-liner to parse lisp exps with ReadP and was trying to think of a good existing type to use for application (without shoehorning it into Data.Tree))
00:49:34 <mmorrow> nothing
00:49:47 <redditbot> Unbounded Operator: Fock States in Haskell
00:49:47 <redditbot> Neil Mitchell's Haskell Blog: Hoogle package search
00:49:57 <artyoms> piksi: you're welcome! drop a line somewhere, i'm interested in production-ready visualization in haskell
01:07:53 <mmorrow> , readP_to_S (let lexP p=do{a<-p;skipSpaces;return a};nestP nest p=p<++nest(nestP nest p);parensP=between (char '('>>skipSpaces)(char ')');digitP::ReadP Int;digitP=read `fmap` munch1 isDigit;varP=munch1 isAlpha;tip = flip Node []; exp0P = nestP parensP(choice[(tip.Left)`fmap`digitP,(tip.Right)`fmap`varP]);lispP=parensP(Node(Right[])`fmap`many((choice.fmap lexP) [exp0P, lispP])) in lispP) "(f x 0)"
01:07:54 <lunabot>  [(Node {rootLabel = Right "", subForest = [Node {rootLabel = Right "f", s...
01:08:00 * mmorrow stops screwing around
01:08:04 <ulfdoz> wtf?
01:08:10 <mmorrow> a lisp parser
01:08:24 <pumpkin_> wow :)
01:08:42 * mmorrow has been using ReadP a lot lately
01:17:38 <glguy> mmorrow, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1637#a1638 maybe a library is in order :)
01:18:29 <mmorrow> glguy: that's an excellent idea. i'll collect all the spread out util funcs i have for that type too
01:19:09 * glguy adds the monad instance
01:19:53 <mmorrow> i've found that that foldTree is easier on the stack if you cps it
01:20:11 <jpcooper> in parsing terms, what is a terminal?
01:20:17 <jpcooper> you've got my interested in parsing now
01:20:31 <jpcooper> I would guess that it's something that signifies the end of a sequence of tokens?
01:20:37 <pumpkin_> jpcooper: a rule that doesn't involve other rules
01:20:49 <pumpkin_> in the AST, it can't have children
01:21:19 <jpcooper> could you recommend a book that gives a good introduction to parsing?
01:22:34 <psygnisfive> jpcooper: parsing techniques.
01:22:46 <psygnisfive> http://www.cs.vu.nl/~dick/PTAPG.html
01:22:47 <jpcooper> thanks
01:22:55 <psygnisfive> whole first edition is available online
01:23:48 <glguy> mmorrow, my test code runs significantly slower with cps style vs stack
01:23:57 <glguy> 2.3 -> 3.5 seconds
01:24:04 <jpcooper> my university's library sadly doesn't have a newer one
01:24:25 <psygnisfive> ::shrug::
01:24:28 <psygnisfive> first edition is cool
01:26:28 <LostMonarch> guys.. when I get an error in a let or where block on the second line.. am I making a mistake with spaces\tabs ?
01:26:39 <ivanm> possibly
01:26:51 <glguy> LostMonarch, you'll need your tabs set to 8-space stops
01:27:37 <ivanm> glguy: which is yet another reason why literal tabs are bad...
01:28:08 <LostMonarch> so the \t can be source of my problems?
01:30:04 * maltem doesn't ever use tabs, except in Makefiles and .calendar :)
01:32:42 <LostMonarch> it continues raising an error
01:32:46 <LostMonarch> mmh
01:36:33 <glguy> boo
01:36:37 <glguy> foldMap inlines (I guess
01:36:40 <glguy> while fold does not
01:36:44 <glguy> foldMap id is better than fold!
01:49:04 <fynn> hey, you're smart people right
01:49:13 <fynn> know about algorithms and such
01:49:35 <fynn> Is there a better BFS than the one presented here?: http://en.wikipedia.org/wiki/Breadth-first_search#Algorithm_.28informal.29
01:50:08 <fynn> I'm interested in any alternative, particularly one that doesn't use a global queue.
01:51:06 <blackh> fynn: That is a very interesting question!
01:51:28 <earthy> fynn: the queue can be implicit in a lazy language
01:51:34 <fynn> blackh: thanks, you seem like a nice guy too!
01:51:48 <fynn> earthy: hmm, how do you mean?
01:52:04 <Gracenotes> well, there are heuristic-based refinements and so on, but that algorithm essentially *is* breadth-first search.
01:52:05 <boegel> hiya gang
01:52:16 <ivanm> I thought there was only one BFS algorithm by definition (or are you asking about implementations, etc.?)
01:52:34 <boegel> I'm still having troubles with getting my data type I'm using for this netflix thing completely strict in memory...
01:52:43 <Gracenotes> how you implement it is your business, although you can greatly simplify it if you know (for instance) that your graph doesn't contain cycles
01:52:56 <fynn> ivanm: alternative implementations.
01:53:00 <earthy> fynn: basically, rather than queueing the successors to be examined, you prepend the examinations still to be performed
01:53:11 <earthy> er... append
01:53:14 <ivanm> maybe have a look at how FGL does it?
01:53:27 <ivanm> but BFS implementation is probably also dependent upon graph implementation
01:53:29 <fynn> ivanm: FGL?
01:53:33 <ivanm> @where FGL
01:53:33 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
01:53:41 <paper_cc1> functional graph library
01:53:44 <boegel> if I want to force strictness on a UArray, I just need to do something like, for a function with return type UArray,  "aUArray `seq` aUArray" right, where the construction of aUArray is in the where?
01:54:03 <fynn> ivanm: tbh, I'm not interested in the most optimal solution
01:54:14 <fynn> very likely the most optimal is the Python one there
01:54:20 <fynn> using essentially a global queue
01:54:28 <ivanm> then what exactly are you wanting?
01:54:35 <fynn> just interested in alternative approaches to this.
01:54:40 <ivanm> note that very rarely in Haskell do you talk about a global _anything_
01:54:54 <fynn> right, but it's not a huge deal here
01:55:12 <fynn> you can either pass the queue up and down, or just, like the Python version, do it all in iteration
01:55:39 <fynn> earthy: is that something you can pseudo-code really quick?
01:55:47 <fynn> curious how the actual haskell code would go.
01:56:12 <ivanm> IIRC, fgl uses something "funky" to do BFS (or is that DFS?)
01:57:12 <Gracenotes> instead of queuing away nodes, you could recursively examine them. A queue is a poor man's recursion ;) some of the time, anyway
01:57:26 <fynn> Gracenotes: great answer! how?
01:57:42 <fynn> exactly the kind of stuff I came to hear.
01:58:02 <fynn> I can't see how to do it in a pure recursive fashion.
01:58:21 <Gracenotes> oh, never mind, that would be DFS
01:58:26 <fynn> yup.
01:58:33 <Gracenotes> well.. the 'visited' set would still have to be 'global' anyway you slice it
01:58:48 <opqdonut> Gracenotes: isn't it more like "a stack is poor man's recursion" ;)
01:58:58 <Saizan> to do BFS without some kind of queue you need delimited continuations :)
01:59:00 <blackh> Does this algorithm require a visited dictionary?
01:59:03 <fynn> yeah, basically I'd imagine Haskell would do that the same way as Python's implementation there, basically
01:59:28 <fynn> blackh: not necessarily, I'm interested in implementation for trees really
01:59:30 <fynn> so no cycles
01:59:37 <fynn> but a general solution is interesting.
01:59:38 <Gracenotes> opqdonut: hehe. right
01:59:41 <paper_cc1> Saizan: how would that help?
01:59:49 <fynn> Saizan: delimited what now? :)
02:00:08 <paper_cc1> @where cps
02:00:08 <lambdabot> I know nothing about cps.
02:00:12 <paper_cc1> :(
02:00:23 <Saizan> paper_cc1: http://haskell.org/haskellwiki/Library/CC-delcont#Breadth-first_Traversal
02:00:47 <fynn> whoa, cool.
02:00:53 <Gracenotes> you could treat BFS is a non-deterministic automaton of sorts. Go from the starting node, to all not-visited ones, to all not-visited ones, etc.
02:01:47 <Saizan> (i can't say that i fully understand it, i probably still need pencil and paper to see how that works)
02:01:53 <Gracenotes> so, uh, maybe ListT (State (Set Node)) Node, although not so sure about ListT
02:01:53 <pejo> Is it only me that finds a queue both quite simple and efficient?
02:02:08 <Gracenotes> coooomplicated
02:02:17 <Gracenotes> (the transformers)
02:03:43 <ghegde> hey everyone! i am a newbie.. wondering if somebody can come to rescue :P
02:04:43 <blackh> ghegde: Spill da beans, guv'nor
02:04:56 <fynn> pejo: it's a great solution, and very efficient, but I had a hunch someone would have a mind-blowing alternative in store.
02:05:29 <fynn> pejo: (it's O(n), and you can't get any better than that really)
02:05:31 <ghegde> :) .. okies here's the thing , i am trying to implement a bounded buffer(trying out with STM)
02:05:36 <blackh> fynn: Can't we do exactly the same thing with a lazy list in place of the queue?
02:05:58 <ghegde> now i have some code like this: do{ (num_left, ps) <- readTVar tv
02:07:18 <ghegde> about the buffer data: data Buffer a = MkBuffer  Int (TVar (Int, [a]))
02:07:51 <ghegde> so made up of the remaining capacity in the buffer and a list acting like the buffer of items..
02:08:19 <fynn> blackh: you're asking me?  I'm so newbish in Haskell, sometimes I even make mistakes in co-recursions ;)
02:08:39 <blackh> fynn: I'll have a go...
02:09:52 * paper_cc1 thinks about something like \f node -> (f . tag) &&& children $ node
02:10:53 <glguy> Huffman encoding tables form a monoid :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1639#a1640
02:12:56 <Peaker> almost everything forms a monoid :)
02:14:36 <mmorrow> glguy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1637#a1641
02:14:37 <ivanm> Peaker: OK, so what _doesn't_ form a monoid? :p
02:14:45 <mmorrow> glguy: oh sucky, cps was slower?!
02:15:19 <mmorrow> innnteresting
02:15:36 <glguy> mmorrow, we'll want this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1637#a1642
02:15:40 <glguy> mmorrow, it was breaking some inlining
02:15:46 <glguy> might not be slower in general
02:15:49 <Gracenotes> some things form more than one monoid, too :X
02:16:18 <mmorrow> glguy: cool
02:16:35 * glguy didn't switch the names over to yours though in that paste
02:17:09 <mmorrow> too bad Data.Tree has the rights to Tree
02:17:36 <mmorrow> i dunno though, T is nice and brief
02:19:27 <mmorrow> glguy: i'd be interested to find out what the best strategy for folding over these kindof trees is, ie stack vs. heap (and if comparable whether/not using stack you could ever overflow when you'd be ok if you used heap)
02:25:12 <ManateeLazyCat> Where i can find resource about Yi editor? Have Wiki site about it?
02:25:59 <blackh> fynn: Well, it works but it needs to be made more efficient. http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1554#a1554
02:27:57 <hotaru2k3> ManateeLazyCat: http://haskell.org/haskellwiki/Yi
02:28:54 <ManateeLazyCat> hotaru2k3: Thanks, but it too little, haven't Wiki site to collection all resource about Yi?
02:29:30 <mmorrow> @type traverse
02:29:31 <lambdabot> Not in scope: `traverse'
02:30:10 <temoto> @type 10
02:30:11 <lambdabot> forall t. (Num t) => t
02:31:12 <boegel> > let cs = [1,2,3] :: [Char]
02:31:13 <lambdabot>   <no location info>: parse error on input `;'
02:31:19 <boegel> > [1,2,3] :: [Char]
02:31:20 <lambdabot>       No instance for (Num Char)
02:31:20 <lambdabot>        arising from the literal `1' at <inte...
02:31:26 <boegel> why is this a problem?
02:31:55 <boegel> > map Data.Char.chr [1,2,3] :: [Char]
02:31:56 <lambdabot>   "\SOH\STX\ETX"
02:31:59 <mmorrow> boegel: you can write:
02:32:00 <boegel> hmm
02:32:07 <fynn> blackh: thanks!
02:32:24 <mmorrow> instance Num Char where fromInteger = chr . fromIntegral
02:32:53 <mmorrow> then that'll work
02:33:16 <boegel> mmorrow: hmmk, thanks
02:33:19 <mmorrow> a + b = fromInteger (a + b)
02:33:20 <mmorrow> ...
02:33:40 <mmorrow> boegel: (i'd never thought of doing that before, but i think i like it :)
02:35:04 <dmwit> :t until
02:35:05 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
02:35:16 <blackh> fynn: Actually I think the efficiency is OK with this. It all depends on ++ and how efficiently that's working. It's certainly doing everything in the right order.
02:36:09 <dmwit> > until (uncurry (==)) (((+1) . snd) &&& snd) (0.0, 0.0)
02:36:10 <lambdabot>   (0.0,0.0)
02:36:14 <glguy> haha! *not* using bytestring gives huge speedup in my huffman program
02:36:24 <glguy> 2.3 sec -. 0.23
02:36:26 <dmwit> > until (uncurry (==)) (((+1) . snd) &&& snd) (1.0, 0.0)
02:36:36 <glguy> ->*
02:36:41 <lambdabot>   thread killed
02:36:44 <dmwit> hum
02:36:54 <dmwit> > 1e9 == 1e9 + 1
02:36:56 <lambdabot>   False
02:37:02 <dmwit> > 1e8 == 1e8 + 1
02:37:03 <lambdabot>   False
02:37:08 <dmwit> > 1e7 == 1e7 + 1
02:37:09 <lambdabot>   False
02:37:14 <dmwit> > 1e6 == 1e6 + 1
02:37:16 <lambdabot>   False
02:37:17 <paper_cc1> > 1e18 == 1e18 + 1
02:37:18 <lambdabot>   True
02:37:23 <pejo> glguy, strict bytestrings -> lazy lists?
02:37:28 <dmwit> Oh, right, I'm going the wrong direction.
02:37:36 <dmwit> > 1e12 == 1e12 + 1
02:37:38 <lambdabot>   False
02:37:42 <dmwit> > 1e15 == 1e15 + 1
02:37:43 <lambdabot>   False
02:37:45 <blackh> > take 10 $ [1..1000000000000000000] ++ [1..1000000000000000000]
02:37:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
02:37:51 <dmwit> > 1e17 == 1e17 + 1
02:37:52 <lambdabot>   True
02:38:20 <dmwit> > until (uncurry (==)) (((+1) . snd) &&& snd) (1e16, 1e16+1)
02:38:22 <lambdabot>   (1.0e16,1.0e16)
02:38:30 <dmwit> > until (uncurry (==)) (((+1) . snd) &&& snd) (1e15, 1e15+1)
02:38:38 <blackh> fynn: It's definitely not traversing the whole first list, so it looks like ++ is efficient in a lazy context.
02:38:44 <dmwit> I'll do this in a msg.
02:38:45 <lambdabot>   thread killed
02:40:00 <paper_cc1> stringtable-atom-0.0.6 doesn't compile on ghc-6.11.20090215. can anyone help?
02:40:44 <fynn> blackh: yeah, trying to completely understand that solution
02:41:09 <fynn> I may ask more questions (tomorrow) about the various proposed solutions...
02:41:52 <mmorrow> boegel: err, i had that backwards. anyways, here is the correct code for instance Num Char http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1555
02:42:09 <paper_cc1> (the compilation log is at http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1643#a1644)
02:42:16 <mmorrow> , [0..4] :: [Char]
02:42:19 <lunabot>  "\NUL\SOH\STX\ETX\EOT"
02:42:32 <mmorrow> ,  negate 4000 :: Char
02:42:34 <lunabot>  '\4000'
02:42:43 <mmorrow> oops
02:42:51 <pejo> mmorrow, why do we want an instance Num Char?
02:43:09 <blackh> fynn: The trick to it is that (ns ++ children) doesn't give you a list, it does nothing until you pull the next item off the list, at which point it does the bare minimum - i.e. takes the next item out of the graph from wherever it was up to.
02:43:30 <mmorrow> pejo: i dunno, "just cause"
02:43:58 <mmorrow> pejo: (boegel asked why nums aren't auto converted to Chars, which gave me the idea)
02:44:29 <mmorrow> i think it actually could be nice though.. it'll at least save you an `ord'
02:44:30 <fynn> blackh: yeah... very elegant
02:44:45 <mmorrow> ,  negate 4000 :: Char
02:44:47 <lunabot>  '\1110112'
02:45:08 * ivanm still finds it magic how any random numeric 'literal' is automagically changed to the correct type
02:45:22 <quicksilver> omg it's a kuribas :)
02:45:27 * quicksilver waves at kuribas 
02:45:34 <mmorrow> fixed negate http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1555#a1556
02:45:35 <fynn> blackh: basically, there was your solution (which earthy seemed to propose as well) and the rocket-science continuations one
02:46:26 <mmorrow> ivanm: it just calls whatever type that is 's fromInteger..
02:46:44 <ivanm> mmorrow: duh
02:46:50 <paper_cc1> @ty 1234
02:46:52 <lambdabot> forall t. (Num t) => t
02:46:55 <mmorrow> *... (whatever type that is)'s ...
02:47:15 <mmorrow> ivanm: oh, so you mean "neato" rather than "magic"? ;)
02:47:30 * mmorrow thinks it's neato too
02:47:43 <ivanm> mmorrow: now I do ;-)
02:47:46 <mmorrow> heh
02:47:54 <ivanm> it's neato how it automagically works ;-)
02:48:01 <mmorrow> yeah, totally
02:48:05 <mmorrow> @ty 1234 :: Double
02:48:07 <lambdabot> Double
02:48:09 <mmorrow> @ty 1234 :: Int
02:48:11 <lambdabot> Int
02:49:54 <kuribas> quicksilver: hi
02:50:43 <kuribas> quicksilver: I have added support for pc-select-mode :)
02:50:48 <quicksilver> ah, excellent.
02:50:54 <quicksilver> that was Peaker that wanted that.
02:51:10 <kuribas> I see.
02:51:14 <quicksilver> I think pc-select-mode is immoral and possible leads to moral turpitude.
02:51:22 <quicksilver> but that's Peaker's risk, I suppose.
02:51:32 <ivanm> what's pc-select-mode meant to be?
02:51:42 <quicksilver> shift-arrow to extent your selection
02:51:50 <kuribas> I also think so, but it was an easy addition.
02:52:02 <quicksilver> yeah, even immoral people should be allowed convenient haskell editing ;)
02:52:23 <kuribas> Right :)
02:53:06 <kuribas> It's maybe good as a transition from other editors.
02:53:09 <pejo> What's wrong with pc-select-mode?
02:53:26 <ivanm> quicksilver: in what?
02:55:31 <kuribas> pejo: Selecting the mark using C-space becomes clumsy.  Pc-select-mode doesn't work well together with other Emacs commands.
02:58:38 <kuribas> Wait, that's only in delete-selection-mode ...
03:01:41 <crazyboy> Enter text here...hii
03:01:45 <crazyboy> how are you
03:01:55 <crazyboy> where 0131s the girls?
03:01:56 <crazyboy> ;)
03:02:26 <ivanm> better question: where are the ops?
03:03:08 <Saizan> crazyboy: this channel is about the Haskell programming language.
03:03:46 <osfameron> I guess Snark was just here for the girls too? ;-)
03:03:56 <ivanm> osfameron: lol
03:12:25 <ivanm> crazyboy obviously couldn't find any girls :p
03:13:03 <blackh> I had this brilliant idea of giving a smart arse reply about how, statistically speaking, male programmers greatly outnumber female ones, ergo he has come to the wrong place...
03:13:14 <osfameron> @faq can you use haskell to find girls?
03:13:14 <lambdabot> The answer is: Yes! Haskell can do that.
03:13:16 <osfameron> yay!
03:13:20 <blackh> but I couldn't find any figures to back this claim up. So for now it remains entirely anecdotal.
03:13:25 <ivanm> osfameron: heh
03:13:36 <boegel> does anyone know if there's a *nix command that gives you the max. amount of memory that a process has allocated in it's lifetime?
03:14:35 <pejo> boegel, not standard one atleast. Can't you get the RTS to print lots of memory statistics though?
03:14:54 <boegel> pejo: yeah, I could profile the run
03:15:11 <boegel> pejo: but that makes it a lot slower :)
03:15:34 <boegel> peoj: seems like overkill just to figure out how much memory the thing needs
03:15:54 <pejo> boegel, I meant some +RTS-switch, no recompilation necessary.
03:16:33 <boegel> pejo: oh, really?
03:18:05 <pejo> boegel, +RTS -s
03:19:02 <boegel> pejo: hmm, great, thanks
03:19:31 <boegel> pejo: it seems my tool might also benefit from using compaction GC instead of copying
03:23:50 <boegel> hmm, 93% of the time spent in garbare collection :)
03:39:02 <artyoms> did anybody manage to build takusen on GHC 6.10? is the project dead?
03:40:12 <boegel> if I'm getting a "Stack space overflow" after setting it to 100M (with +RTS -K), then I must be doing something wrong, right? :)
03:49:17 <cizra> Sounds like infinite recursion?
03:49:21 <Axman6> boegel: sounds like a reasonable conclusion
03:50:09 <cizra> boegel: 93%? That's bad. I wonder if it'd be possible to turn off garbage collection in order to gain speed. And if it'd be a smart idea.
03:51:27 <Axman6> @localtime Axman6
03:51:31 <lambdabot> Local time for Axman6 is Mon Feb 23 22:51:27 2009
03:53:31 <boegel> cizra: I doubt it :)
03:53:46 <boegel> cizra: I throwing around lots of data, so maybe it even makes sense
03:54:10 <boegel> cizra: I'm just trying to come up with a good ADT that'll make the data I need to cope with fit in memory
04:09:59 <boegel> cizra: using +RTS -A256M brings it down to just 14% GC time :)
04:10:31 <cizra> boegel: Does it also help speed?
04:11:42 <defun> Hi. Is this valid: (data Constructor = ConstructorFoo [String] | ConstructorBar Int) and then (type SomeType = ConstructorFoo) or is it (type SomeType = Constructor)?
04:12:02 <boegel> cizra: of course, it goes from 1.5m to ~10s on my PowerBook
04:12:45 <Saizan> defun: the latter
04:13:02 <boegel> cizra: on a larger input, it even goes from 16m to 0.5m :)
04:13:14 <defun> thanks
04:14:18 * boegel concludes: GC is evil
04:15:42 <boegel> cizra: unfortunately, that's just one part of the deal...
04:19:44 <cizra> boegel: Yea..
04:21:17 <boegel> cizra: it's actually fitting the data in memory that's causing me headaches
04:21:40 <SamB> boegel: maybe you shouldn't be doing that ;-P
04:22:19 <boegel> SamB: what? trying to fit the data in memory?
04:22:23 <SamB> yeah ;-P
04:22:52 <boegel> SamB: well, if I think a step further, I think that'll be a requirement to get any kind of decent performance
04:23:10 <Maddas> Maybe the real problem is that you have too much data! Drop some, nobody will notice! ;-P
04:23:14 <SamB> what kind of data did you say it was ?
04:23:32 <boegel> SamB: it's only 100M integer values between 1-5, with accompanying indices
04:23:38 <boegel> SamB: basically, it's the Netflix data
04:23:53 <jpcooper> so there's UML for OOP. Could anyone suggest some formats in which I can design my programmes for Haskell?
04:23:55 <boegel> SamB: 100M user ratings for 17770 movies and ~480k unique users
04:24:02 <boegel> Maddas: heh :)
04:24:18 <boegel> SamB: the user ratings are 1-5, so a Word8 is sufficient
04:24:32 <boegel> SamB: 100M Word8 is roughly 100M
04:24:55 <boegel> SamB: and I would like to use an IntMap which maps user IDs to ratings for a user, so something like
04:25:12 <boegel> SamB: IntMap [(Int,Word8)]
04:25:29 <boegel> SamB: Word8 being the user rating, the Int being the movie id
04:25:38 <cizra> boegel: Integer values between 1-5? You need around 3 bits to encode one such sucker.
04:25:50 <SamB> you do know that Word8 gives no savings in that type ?
04:25:57 <boegel> cizra: right, but Haskell doesn't have a 3bit data type, does it? :)
04:26:00 <maltem> Maddas: Pick some random data subsets, compute each, then find some way to iterate that until the results on the subsets are close to each other?
04:26:09 <cizra> boegel: GHC's open-source!
04:26:18 <boegel> SamB: well, that's a dumb example, [(Int,Word8)] is of course horrible in terms of space
04:26:27 <boegel> SamB: what I'm trying to use now is something like
04:26:47 <boegel> SamB: IntMap (UArray Word16 Word16, UArray Word16 Word8)
04:27:33 <boegel> SamB: i.e. a map of user id (1-480k) to a pair of UArrays, one containing the movie IDs (1-17770), the other containing the corresponding ratings (1-5)
04:27:45 <boegel> SamB: it's not ideal, but that seems to be the best option in terms of space
04:28:06 <boegel> SamB: unfortunately, my experiments seems to suggest it's not enough yet
04:28:28 <SamB> do your experiments involve profiling by closure type ?
04:28:34 <boegel> SamB: I'm using seq all over the place, to make sure everything is strict, but I'm still using >1G for only 1M user ratings, let alone 100M
04:28:45 <boegel> SamB: closure type?
04:29:11 <boegel> SamB: the math says that the type I mentioned last should work...
04:29:16 <SamB> ./a.out +RTS --help
04:30:07 <boegel> SamB: what do you mean by closure type?
04:30:35 <SamB> hold on, I want to see if this +RTS -hT -RTS really does what I was hoping ...
04:31:03 <SamB> ah, no
04:31:31 <boegel> SamB: :)
04:31:58 <SamB> I guess you have to build with profiling on ... well, anyway ...
04:32:16 <boegel> @paste
04:32:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:33:59 <boegel> my experimental code looks something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1646#a1646
04:34:19 <SamB> boegel: I mean +RTS -hd -RTS
04:34:26 <boegel> running it with 1000000 as command line argument shows that it needs a hell of a lot of memory, and I'm unsure why
04:35:27 <boegel> SamB: hmm: invalid heap profile option: -hd
04:35:32 <boegel> SamB: GHC 6.10.1
04:35:55 <SamB> boegel: that one needs a profiling build
04:36:02 <boegel> SamB: ah, k
04:36:49 <SamB> +RTS -hT -RTS, the only option I have for heap profiling without a profiling build, looks like it does give some kind of breakdown ... dunno how useful ...
04:37:21 * quicksilver agrees that heap profiling is the way to investigate boegel's problem.
04:37:28 <quicksilver> it's a neat tool
04:38:03 <boegel> quicksilver: hmmk
04:38:16 <boegel> let's see if I can figure out what's up with this
04:38:42 <boegel> do you guys think it's doable to keep track of that amount of data in memory, so it can be processed reasonably fast?
04:39:00 <chrisdone> why ain't hpaste's urls like http://hpaste.org/view/1646?
04:39:05 <SamB> what is Data.Binary.Get.S ?
04:39:09 <boegel> I keep getting stack space overflows too
04:39:15 <yitz> > (undefined, undefined) `seq` 42 -- boegel
04:39:16 <lambdabot>   42
04:39:30 <boegel> yitz: ?
04:39:43 <SamB> yitz: yes, (,) is lifted
04:39:54 <boegel> SamB: which means?
04:40:01 <SamB> yitz: good question
04:40:03 <yitz> boegel: this line makes no sense: (w8Val, vs, s) `seq` ...
04:40:05 <Saizan> ah, seq-ing on a tuple, or any other constructor, is meaningless
04:40:06 <PeakerWork> I think Haskell should have type product and type sum primitives instead of ADT's
04:40:11 <PeakerWork> and type product should not be lifted
04:40:19 <boegel> yitz: hmm
04:40:25 <SamB> yitz: did you think that was related to your problem in some way ?
04:40:26 <PeakerWork> though maybe "data" syntax should be retained for these operations for simplicity
04:40:33 <boegel> yitz: how do I enforce strictness for multiple things then?
04:40:35 <SamB> is it ?
04:40:50 <quicksilver> m' `seq` m' makes no sense either.
04:40:52 <SamB> x `seq` y `seq` val
04:40:59 <opqdonut> boegel: a `seq` b `seq` thing
04:41:04 <boegel> hmm
04:41:13 <SamB> opqdonut: no! x and y are essential!
04:41:27 * boegel thought he saw (a,b) `seq` <something with a and b> in Real World Haskell
04:41:40 <boegel> quicksilver: it doesn't?
04:41:47 <yitz> boegel: oh yeah? better let the authors know if so
04:41:50 <SamB> er. When I said "good question", I meant to say that to chrisdone :-)
04:41:51 <boegel> quicksilver: doesn't that enforce evaluation?
04:41:59 <boegel> yitz: I'm not 100% sure though, but I'll check
04:42:10 <quicksilver> boegel: (x `seq` x) means 'ensure that x is evaluated whenever x is evaluated)
04:42:11 <SamB> boegel: was it possibly an example of what NOT to do ?
04:42:16 <quicksilver> boegel: that's just "x"
04:42:21 <boegel> quicksilver: right...
04:42:29 <boegel> SamB: dunno, but I'll check
04:42:40 * boegel fixes these issues
04:42:41 <Saizan> boegel: you want "x `seq` return x", or "return $! x" there
04:42:47 <SamB> what's the URL of ndm's blog entry about seq ...
04:43:11 <yitz> boegel: m' `seq` return m'
04:44:05 <boegel> ok, thanks you guys
04:44:17 <SamB> http://neilmitchell.blogspot.com/2008/05/bad-strictness.html
04:44:18 <yitz> boegel: but return is not strict in the IO monad (a small bug in GHC imho)
04:44:25 <boegel> this might be the reason why I was seeing these huge amounts of memory usage
04:44:37 * SamB wishes blogspot had tracebacks
04:44:47 <jpcooper> @pl line <$ (withMVar nodeVar $ handle dbc)
04:44:47 <lambdabot> line <$ withMVar nodeVar (handle dbc)
04:44:53 <quicksilver> yitz: can't see why you'd want return to be artificially strict.
04:44:57 <quicksilver> yitz: laziness by default.
04:45:01 <boegel> yitz: erm.. ok... what does that mean for me? that m' `seq` return m' won't really work?
04:45:08 <SamB> anyway ... what *is* Data.Binary.Get.S ?
04:45:18 <SamB> quicksilver: I think it violates the monad laws too ;-)
04:45:22 <idnar> it comes before Data.Binary.Get.T
04:45:23 <yitz> quicksilver: if return is strict, then IO is a monad even w.r.t. seq. otherwise not.
04:45:46 <SamB> if you mean strict in the sense of forcing the value returned
04:45:52 <maltem> boegel: in any case you'll want sum' instead of sum, where sum' = foldl' (+) 0
04:45:57 <quicksilver> yitz: nothing satisfies the monad laws w.r.t seq
04:45:59 <chrisdone> :t (<$)
04:46:00 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
04:46:02 <quicksilver> so why bother even considering it?
04:46:10 <SamB> monad laws wrt seq ?
04:46:17 <Saizan> return x >>= f == f x, so x can't be strict in the argument
04:46:17 <boegel> wow, that looks a LOT better
04:46:21 <quicksilver> as long as you can distinguish \_ -> _|_ from _|_, equational reasoning is broken.
04:46:24 <Saizan> *return
04:46:29 <yitz> boegel: so no need for  seq there, if it gets evaluated then it gets evaluated. if not, you're in trouble anyway.
04:46:35 <boegel> now I'm seeing 20M of memory usage vs 250M with 100k data elements
04:46:35 <quicksilver> I don't worry about laws in the presence of seq.
04:46:49 <yitz> quicksilver: it does if you use .! instead of . for your category
04:47:03 <quicksilver> yitz: I'd not sure what your point is, but "x `seq` return x" is certainlya useful construction.
04:47:05 <SamB> Saizan: hmm ?
04:47:15 <boegel> maltem: how does that make a difference?
04:47:29 <yitz> quicksilver: in the IO monad, as it stands today? how so?
04:47:31 <SamB> boegel: less stack overflows
04:47:34 <boegel> quicksilver: also in the IO monad?
04:47:57 <boegel> SamB: because each 'step' of calculating the sum is done in a strict manner?
04:47:57 <quicksilver> yitz: because "x `seq` return x" forces x to be evaluated before its returned
04:47:59 <SamB> quicksilver: not as useful as "return $! x"
04:48:01 <maltem> boegel: sum by itself, defined in terms of foldl instead of foldl', is really unuseable
04:48:14 <boegel> maltem: hmm, k
04:48:20 <SamB> boegel: yeah, basically
04:48:22 * boegel is learning radically fast here
04:48:25 <yitz> SamB: because less keystrokes?
04:48:25 <Saizan> SamB: return x >>= f == f x is the first law, right? so by f = const (return ()), return _|_ /= _|_
04:48:33 <quicksilver> maltem: (well, unless the optimiser is smart enough to catch it)
04:48:40 <maltem> well right
04:48:41 <SamB> if you build up a lot of steps before actually running them, you're likely to overflow the stack
04:48:46 <idnar> SamB: isn't that the same thing?
04:48:55 <idnar> @src ($!)
04:48:55 <lambdabot> f $! x = x `seq` f x
04:49:05 <yitz> maltem: yeah. I wish they would fix sum and product in the prelude already.
04:49:12 <SamB> Saizan: where's the problem ?
04:49:21 <yitz> quicksilver: I don't think the optimiser catches it.
04:49:23 <boegel> SamB: how is "return $! x" different from "x `seq` return x" ?
04:49:30 <idnar> yitz: it would probably be nicer if the compiler could figure it out
04:49:35 <SamB> boegel: well, it is shorter ;-P
04:49:36 <quicksilver> yitz: it does for "Int", in some cases.
04:49:40 <idnar> yitz: that way they're still usable with lazy Nums
04:49:44 <yitz> quicksilver: I find myself needing to redefine them all the time
04:49:49 <quicksilver> > sum [1..1000000]
04:49:51 <lambdabot>   * Exception: stack overflow
04:49:55 <yitz> quicksilver: oh, maybe for Int
04:50:01 <quicksilver> > sum [1..1000000] :: Int
04:50:03 <lambdabot>   * Exception: stack overflow
04:50:03 <SamB> boegel: also you don't need to create a variable to hold x
04:50:04 <boegel> SamB: heh, k
04:50:13 <boegel> SamB: right...
04:50:15 <quicksilver> hmm, possibly not with .. though ;)
04:50:20 <yitz> heh
04:50:27 <idnar> > maxBound :: Int
04:50:28 <lambdabot>   9223372036854775807
04:50:29 <chessguy_work> > foldl' (+) 0 [1..10000000]
04:50:30 <lambdabot>   50000005000000
04:50:40 <SamB> @src ($!)
04:50:40 <lambdabot> f $! x = x `seq` f x
04:50:47 <SamB> @src $!
04:50:48 <lambdabot> f $! x = x `seq` f x
04:50:52 <SamB> sweet
04:50:53 <chessguy_work> @src foldl'
04:50:53 <lambdabot> foldl' f a []     = a
04:50:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:51:00 <SamB> doesn't matter if you use parens or not on opnames
04:51:42 * SamB wonders what's wrong with his preview-latex
04:52:13 <yitz> idnar: I see. I'd rather sum work properly for strict types, and you can redefine it for lazy naturals, than vice versa
04:52:38 <yitz> idnar: and relying on optimization to catch this doesn't feel right
04:53:02 <boegel> I'm gonna post a nice blog post about this whole thing tonight
04:53:10 <boegel> so I won't forget what I was learned...
04:53:33 <yitz> boegel: is your code working better now?
04:53:56 <boegel> yitz: hell yeah :)
04:54:07 <yitz> boegel: great! then blog away :)
04:54:08 <boegel> yitz: much faster, much less memory, no more stack overflows
04:54:19 <SamB> hmm, does anyone else use Preview in AUCTeX ?
04:54:26 <ivanm> SamB: I do
04:54:29 <boegel> yitz: I do still need the option to adjust the GC activity though, but that makes sense
04:54:49 <boegel> yitz: I'm producing a hell of a lot of junk along the way
04:54:52 <ivanm> mainly to check the math stuff is right (though it's not as good as actually running latex)
04:55:11 <SamB> ivanm: when you run it and then hit C-c C-l, do you see things like:
04:55:13 <SamB>  !name(paper.tex) !offset(111)
04:55:15 <SamB> ?
04:55:19 <yitz> idnar: the right thing is probably to make sum and product Num methods, with foldl' as the default
04:55:38 <ivanm> SamB: I don't think so...
04:55:46 <ivanm> not in the .tex file, anyway...
04:55:50 <ivanm> oh, wait, duh, that's the log
04:55:52 <yitz> boegel: that's ok, it's usual for haskell. it's designed for that.
04:55:54 * ivanm digs up a tex file
04:56:04 <boegel> yitz: k
04:56:06 <SamB> ivanm: I meant in the log
04:56:15 <SamB> well, not the real log
04:56:17 <SamB> the output
04:56:20 <boegel> yitz: there's just so much to think of if you're handling this much data
04:56:49 <yitz> boegel: not really, it becomes natural after you've done it once or twice.
04:57:00 <ivanm> SamB: nope, can't find any mention of offset
04:57:13 <ivanm> just a lot of Preview stuff
04:57:31 <boegel> yitz: but it sure wasn't natural for me
04:57:44 <jpcooper> @pl onClicked entryButton $ entryGetText entry >>= historyUpdate
04:57:44 <lambdabot> onClicked entryButton (historyUpdate =<< entryGetText entry)
04:57:46 <yitz> boegel: you're getting there fast :)
04:57:46 <boegel> yitz: I can think of good ways to handle the data in C, but it far less obvious in Haskell
04:58:07 <jpcooper> @pl onClicked entryButton $ entryGetText entry >>= historyUpdater (updateHistory xml) . ("> " ++)
04:58:07 <lambdabot> onClicked entryButton (historyUpdater (updateHistory xml) . ("> " ++) =<< entryGetText entry)
04:58:11 <SamB> ivanm: okay, just checking that the fact that I only see those in the .log file isn't causing me trouble ;-P
04:58:13 <boegel> yitz: I really wanted to do this in Haskell though, because of the ease do actually do something with the data once you have it :)
04:58:29 <yitz> boegel: think of what would happen to someone who has been programming in haskell for years and has never seen C.
04:58:32 <ivanm> SamB: if you run latex normally and _still_ see them, _then_ you might have a problem
04:58:38 <yitz> boegel: (though very few such people exist yet)
04:59:10 <boegel> yitz: I can imagine :
04:59:11 <boegel> :)
04:59:22 <SamB> ivanm: the problem I have is that Preview isn't picking up anything to preview
04:59:29 <boegel> yitz: C is ok if you need to do something simple, and do it very fast
04:59:43 <ivanm> SamB: hmmm....
04:59:44 <boegel> yitz: but it sucks to write something complicated that you'll need to adjust some time later
04:59:46 <ivanm> not even your section titles?
04:59:54 <cizra> boegel: And even then, it's probably righter to optimize your algorithm, not your language.
05:00:18 <boegel> cizra: which is, imho, easier in Haskell
05:00:44 <boegel> cizra: it forces you to really think about what you're implementing, instead just get the code doing what you have in mind initially
05:00:54 <cizra> boegel: Irrelevant. I'm saying that C versus FooLanguage doesn't necessarily mean fast versus not so fast.
05:01:12 <boegel> cizra: I agree, but I was talking about maintainability of the code
05:01:14 <cizra> boegel: .. of course I agree.
05:01:25 <cizra> .. about maintainability and beauty of Haskell and stuff.
05:01:26 <SamB> ivanm: yeah!
05:01:34 <boegel> cizra: that's one of the reasons I wanted to tackle this with Haskell
05:01:36 <cizra> We seem to agree a lot
05:01:39 <ivanm> SamB: weird :s
05:01:48 <ivanm> a problem with your preview-latex stuff? or with your tex file?
05:01:52 <ivanm> try a minimal file maybe...
05:01:53 <boegel> cizra: show (to myself) that Haskell can be fast if it's done right, and learn a lot along the way :)
05:02:10 <boegel> cizra: too bad I'm taken already :P
05:03:50 <klibbigt> how do I compile again?
05:04:03 <klibbigt> ghc --make -O2 Test.hs onyl creates Test.o
05:04:06 <ivanm> klibbigt: ghc --make Foo.hs
05:04:08 <klibbigt> I want Test.exe
05:04:12 <mib_0inw> Can we find the longest increasing subsequence of 2 D points ? (x,y) < (a,b) if (x<a && y<b), i want for pixels , resolution of  800x600, (total number of points is 4*10^5), so an O(nlogn) would be good ? The problem is that 1D algorithm doesn't generalize to 2D
05:04:23 <ivanm> klibbigt: hmmm.... do you have a main function in Test.hs?
05:04:45 <klibbigt> my computer has a temp of 73degrees celsius in the core, something must be wrong right(intel processor)
05:04:49 <klibbigt> ivanm: yes
05:05:20 <cizra> boegel: Heh heh. I didn't mean to keep you as a pet or something.
05:06:04 <ivanm> klibbigt: my C2D has a core temp of 70 C atm.... and it doesn't seem to be having any problems
05:06:09 <mib_0inw> how is closures implemented in haskell ? doing an inline of a function would be one way :)
05:06:15 * boegel thinks cizra would be an ideal name for a pet
05:06:15 <ivanm> when it gets to > 80, _then_ be worried ;-)
05:06:24 <PeakerWork> mib_0inw: that doesn't sound like a sane Ord instance
05:06:50 <mib_0inw> PeakerWork: sane Ord instance ?
05:06:51 <boegel> klibbigt: try search for a.out or something
05:06:54 <ivanm> klibbigt: OK... is your file the Main module?
05:06:59 <PeakerWork> mib_0inw: so if x<a and y>b, (x,y) > (a,b) ?
05:07:02 <boegel> klibbigt: you should add -o Test.exe
05:07:18 <ivanm> boegel: I don't have to... unless windows stuff is weird :s
05:07:33 <PeakerWork> mib_0inw: can (flip (<)) work sanely in the way you described?
05:07:41 <boegel> ivanm: Windows is crap, which makes it wierd
05:07:48 <xdie> hi all
05:08:11 <xdie> @slap
05:08:11 * lambdabot slaps  with a slab of concrete
05:08:30 <boegel> @slap xdie
05:08:30 * lambdabot orders her trained monkeys to punch xdie
05:08:35 <xdie> how to join lambdabot to #culturalibredigital
05:08:38 <mib_0inw> PeakerWork: No it is not defined. That is the problem with 2D, Say we have points (1,1) (2,3) (3,2) (3,4) , the MLIS is 3, (1,1) (2,3) (3,4) , in (1,1) (2,3) (3,2) (4,3) , the LIS is 3 (1,1) (3,2) (4,3) but it depends which point you choose .
05:08:40 <SamB> ivanm: huh, I guess it's my doc
05:08:44 <xdie> jeje
05:08:50 <klibbigt> ivanm: does it have to be called Main? then no...
05:09:01 <klibbigt> how can i telel the compiler it is the main?
05:09:16 <mib_0inw> PeakerWork: so (2,3) != (3,2) , you can't order it , you have to check them both
05:09:20 <PeakerWork> mib_0inw: so you want the best permutation subset?
05:09:42 <PeakerWork> mib_0inw: or just the subset?
05:09:57 <mib_0inw> PeakerWork: longest increasing sequence
05:10:02 <PeakerWork> mib_0inw: also I wouldn't call this "increasing" or  (<), because its not Ord, but something else here
05:10:16 <xdie> @join #culturalibredigital
05:10:16 <lambdabot> Not enough privileges
05:10:19 <xdie> :(
05:10:21 <xdie> any canl helpme
05:10:26 <mib_0inw> PeakerWork: it is increasing because (x,y) < (a,b) if (x<a && y<b)
05:10:49 <PeakerWork> mib_0inw: but I think you can't define an Ord instance that does that, so you can't define  (<) to behave that way
05:11:26 <PeakerWork> if that "if" is "iff"
05:11:29 <mib_0inw> PeakerWork: you want to extend the 1D algorithm by defining ord, which will be a problem
05:11:46 <juhp_>  cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however
05:11:46 <juhp_>  process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1
05:11:46 <juhp_>  then I remove process-1.0.1.1
05:12:06 <juhp_> (then I remove ghc;)
05:12:08 <PeakerWork> mib_0inw: so I'd say its `ordered` rather than (<)
05:12:41 <SamB> huh, apparantly it doesn't like that I did \usepackage{preview} ...
05:12:46 <PeakerWork> mib_0inw: or `increasing`
05:12:54 <mib_0inw> PeakerWork: yes true
05:12:59 <juhp_> guess one of those is a package?
05:13:41 <Saizan> juhp_: you've unregistered ghc? that's not a wise move
05:14:05 <juhp_> Saizan: no I removed the rpm ;) :)
05:14:13 <PeakerWork> mib_0inw: not sure if the O(logN) algorithm is applicable here
05:14:23 <mib_0inw> mib_0inw: n logn
05:14:31 <mib_0inw> PeakerWork: ^
05:15:15 <mib_0inw> NlogN or N (logN^2) or N (logN^3)
05:15:18 <mib_0inw> not N^2
05:15:51 <dcoutts_> juhp_: the problem was that you had global and user packages shadowing each other such that it looked like your ghc api package depended on two version of another package
05:15:57 <ivanm> klibbigt: sorry, my computer died
05:16:10 <ivanm> klibbigt: in case no-one else told you, at the top of your file have "module Main where"
05:16:22 <juhp_> dcoutts_: so better to move .ghc out of the way?
05:16:33 <klibbigt> if i really want to have module Test where, how do I compile?
05:16:38 <dcoutts_> juhp_: that probably happened because you got the exact same package version registered in both global and user, but user masks global, so you were effectively replacing a dependency of a global package (bad idea)
05:16:43 <PeakerWork> mib_0inw: wait, a subsequence is contiguous or not in the original list?
05:17:04 <dcoutts_> juhp_: unregister process-1.0.1.1 and use ghc-pkg list to look for packages with the same version that are registered both per-user and globally
05:17:08 <yitz> boegel: cizra actually isn't a good name for pet. But there doesn't seem to be an obvious lojban word for pet. perhaps pe'udal ("friend-animal")?
05:17:28 <juhp_> dcoutts_: ok - maybe I should avoid cabal upgrade :)
05:17:31 <juhp_> ?
05:17:39 <dcoutts_> juhp_: eg, did you register Cabal-1.6.0.1 per-user (and that one probably built against process-1.0.1.1)? if so that masks the global one
05:17:40 <boegel> yitz: I was just joking...
05:17:44 <juhp_> dcoutts_: ok will try
05:17:51 <yitz> boegel: i know :)
05:18:05 <dcoutts_> juhp_: yes, I've disabled world upgrade in the latest release for just this reason, it helped people shoot themselves in the foot
05:18:15 <boegel> another question for you guys: what would be more memory efficient, an UArray Int Word8 or a ByteString to keep track of a list of bytes?
05:18:17 <juhp_> ah good
05:18:42 <klibbigt> does haskell come with any basic gui/2d capabilities?
05:18:54 <boegel> klibbigt: see gtk2hs
05:19:13 <mib_0inw> PeakerWork: a subsequence isn't continguous. It is only with unique indices ordered a < b < c ...
05:20:48 <boegel> seems like I'm still missing something, because running my app with 100M inputs still needs 3.6G :-/
05:21:01 <boegel> I want it to get under 3G, so I can use my iMac for the number crunching
05:21:31 <klibbigt> import Gtk2hs
05:21:35 <klibbigt>     Could not find module `Gtk2hs':
05:21:47 <klibbigt> (im using windows)
05:21:52 <dcoutts_> klibbigt: that's not what it's called, see the demos, tutorials, api docs
05:22:01 <mib_0inw> PeakerWork: was i clear ?
05:22:25 <boegel> klibbigt: you need to install the package
05:22:57 <dcoutts_> klibbigt: http://haskell.org/gtk2hs/documentation/#hello_world
05:27:01 <maltem> boegel: Both should be as compact as an array can be
05:27:16 <maltem> i.e. no difference
05:27:21 <boegel> maltem: hmm, k
05:27:51 <boegel> I wonder why I need still need fucking 3.6G to store an IntMap with 100M bytes (Word8) in it...
05:29:24 <boegel> bleh, I even run out of memory on a machine with 16G RAM :(
05:31:24 <boegel> is there much overhead in an IntMap? mine will have 480k keys, and a UArray (or even a pair of them) as value
05:34:58 <dcoutts_> boegel: speed or memory?
05:35:20 <mib_0inw> PeakerWork: ?
05:35:35 <boegel> dcoutts_: memory, mostly
05:35:59 <boegel> dcoutts_: I want the whole thing to fit into something like 2G, and also want it to be reasonably fast
05:36:15 <boegel> (seems like I'm not the first to tackle Netflix with Haskell, see http://www.nabble.com/UArray-Word16-Word32-uses-twice-as-much-memory-as-it-should--tt20575862.html#a20575862)
05:36:24 <dcoutts_> boegel: you can calculate the memory cost per element
05:37:29 <boegel> dcoutts_: any pointers to how?
05:37:47 <boegel> dcoutts_: I assume there's on overhead of a couple of words per key?
05:37:59 <boegel> > 480000*4 / (2^30)
05:38:00 <lambdabot>   1.7881393432617188e-3
05:38:12 <boegel> seems unlikely that's going to kill me
05:41:23 <dcoutts_> boegel: look at the data definition:
05:41:28 <dcoutts_> data IntMap a = Nil
05:41:28 <dcoutts_>               | Tip {-# UNPACK #-} !Key a
05:41:28 <dcoutts_>               | Bin {-# UNPACK #-} !Prefix {-# UNPACK #-} !Mask !(IntMap a) !(IntMap a)
05:41:57 <RayNbow> @google ghc unpack pragma
05:41:58 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
05:41:58 <lambdabot> Title: 8.13.Pragmas
05:42:25 <dcoutts_> boegel: so in the Bin case we've got 1 word for the constructor, 1 each for the prefix and mask (unboxed int) and 1 each for the child pointers
05:42:25 <klibbigt> boegel: what are you doing?
05:42:49 <dcoutts_> boegel: so that's 5 words * 4 or 8 bytes depending if you're on are 32 or 64bit box
05:43:05 <boegel> klibbigt: handling a massive amount of data :P
05:43:14 <klibbigt> yes but what kind?
05:43:26 <klibbigt> netflix?
05:43:37 <boegel> dcoutts_: even then 480k*8 is roughly 4M
05:43:54 <boegel> dcoutts_: so, that's not the reason for my >3.5G memory usage, clearly
05:45:29 <RayNbow> dcoutts_: is it required for the fields annotated with the UNPACK pragma to be also annotated with bangs?
05:45:53 <boegel> klibbigt: yeah, exactly
05:47:06 <boegel> oh, wait, 5 _words_ * 8 bytes, that's like 40 bytes * 480k (worst case)
05:47:11 <boegel> even then, still only 20M
05:47:24 <daf> boegel: if you want to know where your memory is going, you can use GHC's heap profiler
05:47:51 <daf> boegel: the GHC manual describes how to use it quite well
05:48:10 <dcoutts_> RayNbow: yes, the ! adds strictness (changes semantics), the UNPACK changes the representation (does not change semantics)
05:49:39 * maltem sometimes whishes for a more compact syntax for {-# UNPACK #-} when there are many fields to unpack
05:52:11 <boegel> daf: yeah, doing so right now (usinng +RTS -hd on a profiled build, right?)
05:52:28 <boegel> could someone in here forward me the last mail of this thread on Haskell-Cafe: http://groups.google.com/group/fa.haskell/browse_thread/thread/269b40efe7f0a38d
05:52:31 <boegel> I wanna contact the TS
05:58:50 <Workybob> @hoogle Monad m => ((a -> b) -> b) -> ((a -> m b) -> m b)
05:58:51 <lambdabot> No results found
05:58:58 * Workybob wonders if that function is possible to write
05:59:06 <Workybob> oh wait
05:59:08 <Workybob> it's id
05:59:09 <Workybob> >.<
05:59:12 <boegel> lol
05:59:22 <xdie> @slap h0cin
05:59:23 * lambdabot smashes a lamp on h0cin's head
05:59:28 <boegel> Workybob: then why doesn't hoogle find it? :)
05:59:34 <Workybob> boegel: good question
05:59:40 <Workybob> oh, it's not quite id
05:59:41 <boegel> @hoogle Monad m => (a -> b -> b) -> (a -> m b -> m b)
05:59:41 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:59:41 <lambdabot> Data.IntMap adjustWithKey :: (Key -> a -> a) -> Key -> IntMap a -> IntMap a
05:59:41 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:59:54 <boegel> Workybob: liftM2?
05:59:58 <Workybob> it's id wdth a more relaxed type
06:00:04 <Workybob> no, wrong associativity
06:00:17 <Workybob> not a -> (b -> b)  (a -> b) -> b
06:00:37 <Workybob> I doubt it's possible to write
06:01:56 <boegel> Workybob: nothing is impossible! you go girl!
06:02:10 <Workybob> I'm busy looking at a specific case of it
06:02:16 <Workybob> see if I can see what the general version is
06:04:14 <klibbigt> boegel: most people seem to hack somthing together in C++, some have gotten the whole set into 200MB
06:04:42 <boegel> klibbigt: yeah, compressed, but then it's probably horribly slow to work with :)
06:04:43 <quicksilver> Workybob: it's not possible to write, in general.
06:04:55 <quicksilver> Workybob: it's a case of what you might call the 'callback' problem.
06:04:56 <Workybob> quicksilver: no, I was slowly coming to that conclusion
06:05:18 <quicksilver> or monadic tunnelling
06:08:15 <boegel> compiling with -O1 -funbox-strict-fields seems to be helping big time...
06:08:28 <Saizan> why not -O2?
06:10:13 <Workybob> because O2 contains only experimental optimisations that may or may not give you anything, no?
06:10:22 <Workybob> and often are a loss IIRC
06:10:35 <boegel> Saizan: O2 seems to be doing worse in terms of execution time (although memory usage stays the same)
06:10:47 <Philonous> I have a list an mapped some expensive functions over it. Would walk [] = (); walk (x:xs) = x `par` walk xs suffice to force the list in parallel?
06:11:11 <boegel> @info par
06:11:12 <lambdabot> par
06:11:18 <boegel> @vixen you stupid trut
06:11:19 <lambdabot> how's the weather over there?
06:11:27 <boegel> @type par
06:11:28 <lambdabot> forall a b. a -> b -> b
06:11:32 <boegel> @src par
06:11:32 <lambdabot> Source not found. Wrong!  You cheating scum!
06:11:38 * boegel cries
06:11:48 <Philonous> http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html
06:11:59 <Philonous> AFAIK it's build in
06:12:27 <Philonous> Or wait. I think I just contradicted myself
06:12:58 <Saizan> Workybob: i always though O2 was safe, and the experimental ones had to be enabled manually
06:13:25 <boegel> Saizan, Workybob: is there any way to tell what's enabled on top of O1 in O2?
06:13:40 <Workybob> not sure there is beyond rtfm
06:13:53 <boegel> my tool seems to be running with 2.4G now, something I can live with
06:17:10 <dolio> "-O2: Means: Apply every non-dangerous optimisation, even if it means significantly longer compile times. The avoided dangerous optimisations are those that can make runtime or space worse if you're unlucky."
06:19:14 <boegel> dolio: hmm, doesn't seem to fit with what I'm seeing...
06:20:19 <Saizan> you should consider reporting this as a bug, especially if you find which optimization is causing problems
06:20:22 <boegel> how do I interpret the graph the heap profiling gives me? the Y-axis says "bytes", but is that the amount of bytes in total for closure X, or?
06:20:43 <boegel> Saizan: I could figure it out if I knew what's enabled on top of O1 :)
06:21:54 <boegel> on my PowerBook (PowerPC G4), the O1 seemed better, but on a Pentium 4 system, they seem equal
06:22:22 <dolio> It also says that O2 is unlikely to produce better code thatn O1.
06:22:41 <dolio> I don't know what the additional optimizations are, either, though.
06:22:42 <boegel> hmmk
06:23:37 <boegel> do you guys know of any more options besides -funbox-strict-fields that might save me space?
06:24:57 * sw17ch notes that the surfacing of Jon Harrop probably means that haskell-cafe is on the verge of imploding
06:24:58 <boegel> -O1 @ P4 yields 27s for 1M elements, while O2 yields 26.5s
06:25:12 <boegel> validated with multiple runs, so O2 seems slightly faster
06:26:17 <boegel> dolio: in http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html, it's listed what is enabled at -O/O2
06:26:26 <dolio> Oh, he did send something.
06:26:39 <dolio> I thought he was busy posting bogus benchmark numbers on comp.lang.functional.
06:28:09 <dolio> Huh, -firrefutable-tuples.
06:30:19 <dolio> Huh, only 3.
06:30:39 <sw17ch> has any one called into haskell from foreign code using callbacks and the FFI?
06:30:43 <sw17ch> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
06:30:45 <dolio> -fstatic-argument-transform could conceivably cause worse performance.
06:30:54 <sw17ch> i'm looking at that and trying to figure out where "wrapper" is defined
06:31:52 <dolio> But I don't think GHC is very aggressive about applying that optimization, even when it's turned on.
06:32:28 <mmorrow> sw17ch: what do you mean "where" ?
06:32:56 <sw17ch> mmorrow: the example i linked to doesn't describe how/where to define "wrapper"
06:33:02 <sw17ch> unless i justm issed it
06:33:12 <mmorrow> ah
06:33:15 <sw17ch> oh, look
06:33:16 <mmorrow> i've done it like:
06:33:23 <mmorrow> foreign import ccall "wrapper"
06:33:23 <mmorrow>   mkRCb :: CRescheduler -> IO (FunPtr CRescheduler)
06:33:24 <sw17ch> it might be the section *right* above the one i linked to
06:33:31 <mmorrow> type CRescheduler = Ptr CPeriodicEv -> CDouble -> IO CDouble
06:33:33 <boegel> a lot of my memory seems to go to Bin, i.e. IntMap
06:33:34 <boegel> strange
06:34:01 <dolio> Do you have a link to your code? I accidentally deleted the channel history.
06:34:19 <sw17ch> mmorrow: : no, i was wrong. that defines how to wrap a macro
06:34:20 <boegel> dolio: my code?
06:34:25 <dolio> Right.
06:34:35 <sw17ch> mmorrow: do you have more expanded code somewhere?
06:34:49 <mmorrow> sw17ch: sure, i can paste
06:34:52 <sw17ch> :D
06:35:30 <boegel> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1647#a1647
06:35:52 <boegel> dolio: this is the optimized version, after the seq problems mentioned by several people in here got solved
06:35:52 <dolio> Anyone know what "liberate case" is? The docs just say "turns on liberate case". :)
06:37:01 <bremner> @src sort
06:37:01 <lambdabot> sort = sortBy compare
06:37:10 <dolio> Huh, well, I don't see anything the static argument transform would make worse.
06:37:28 * bremner was wondering why the hell sort didn't take a comparison function :-)
06:37:35 <sw17ch> :t sortBy
06:37:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:37:39 <sw17ch> :D
06:37:57 <sw17ch> :t Ordering
06:37:58 <lambdabot> Not in scope: data constructor `Ordering'
06:38:11 <drhodes> :t Ord
06:38:12 <lambdabot> Not in scope: data constructor `Ord'
06:38:19 <drhodes> :i Ord
06:38:59 <sw17ch> data Ordering = LT | EQ | GT
06:39:39 <bremner> :type compare
06:39:46 <bremner> :t compare
06:39:47 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
06:40:01 <Saizan> is it overkill to use both an heap for laziness and a local environment for lexical closures?
06:40:25 <boegel> dolio: here's an example of a heap profile
06:40:34 <boegel> dolio: I'm somewhat puzzled on how to interpret this...
06:40:36 <boegel> dolio: http://users.elis.ugent.be/~kehoste/testMemSizeUArray.ps
06:41:07 <boegel> for example, why doesn't the Y-axis add up to 1G?
06:41:33 <dolio> Is this with -O2?
06:42:02 <boegel> dolio: yes
06:42:11 <boegel> dolio: -O2 -funbox-strict-fields
06:42:17 <dolio> Maybe it is SATing something, then...
06:42:25 <boegel> dolio: SATing?
06:42:32 <dolio> Static argument transform.
06:42:42 <boegel> dolio: I think the -O1 is pretty much the same
06:42:48 <dolio> One of the things says "main:Main.sat_s2o1"
06:42:56 <boegel> dolio: actually, this is -O1, sorry
06:43:05 <dolio> Oh, okay, then.
06:43:13 <boegel> dolio: I generated another one with -O2, but it looks pretty much the same
06:43:27 <boegel> dolio: yeah, I'm unsure what the main:... thing is
06:43:39 <dolio> I've actually never used this feature of GHC, so I'm not really sure how to read it, either.
06:43:49 <boegel> dolio: also, I don't get why the Bin part is that high (although I still don't fully get the Y-axis)
06:43:57 <pejo> dolio, liberate case transforms f = \t -> case v of V a b -> a : f t into f = \t -> case v of V a b -> a : (letrec f = \t -> case v of V a b -> a : f t in f) t
06:44:20 <boegel> daf: do you know how to interpret this heap profile?
06:45:01 <pejo> dolio, which can be simplified to f = \t -> case v of V a b -> a : (letrec f = \t -> a:f t in f t).
06:46:22 <boegel> goddamned, what a confusing graph :-/
06:47:38 <dolio> pejo: Ah, okay.
06:48:20 <daf> boegel: AIUI, it's by constructir
06:48:24 <daf> * constructor
06:48:45 <daf> boegel: I'm not sure what s2o1 and ARR_WORDS are, but the others seem fairly self-explanatory
06:49:10 <mmorrow> sw17ch: i actually just cleaned up this binding to libev i have and made a repo http://moonpatio.com/repos/hsev/
06:49:46 <mmorrow> it has a few uses of "wrapper", as well as some foreign imports that have to be spec as "safe" since they call back into haskell (via those callbacks)
06:49:56 <boegel> daf: I'm mainly confused about the interpretation of the Y-axis... why doesn't it add up to 1G?
06:49:56 <dolio> boegel: Oh, it doesn't add up to 1 GB the 1e9 has units of bytes x seconds.
06:50:12 <dolio> So if you find the area under that curve, presumably it's 1e9.
06:50:28 <boegel> dolio: so, it's actually the amount of data allocated per second? the height?
06:50:45 <sw17ch> mmorrow: do you know a good representative file of the feature set i was looking for? :)
06:50:47 <quicksilver> no, it's the amount being used at that instant.
06:50:52 <quicksilver> the heap profile doesn't show you allocation rate
06:50:56 <quicksilver> it shows residency
06:50:58 <dolio> It's the amount of heap taken up by whatever the stuff on the right corresponds to.
06:51:00 <daf> boegel: where are you getting the 1G from?
06:51:16 <mmorrow> sw17ch: http://moonpatio.com/repos/hsev/src/System/Ev/Internal.hs
06:51:17 <boegel> daf: "1,039,211,002 bytes"
06:51:18 <daf> oh, right
06:51:34 <quicksilver> you have to add up all the entries for that
06:51:36 <dolio> So "main:Main.sat_s2o1" starts off as the entire heap and shrinks over time.
06:51:39 <boegel> daf: confusing graph if you ask me :)
06:51:43 <daf> boegel: that's byte-seconds, not bytes
06:51:44 <mmorrow> sw17ch: of note are foreign import ccall safe "ev_loop"                 ev_loop :: Ptr CLoop -> CInt -> IO () and,
06:51:46 <sw17ch> mmorrow: ah, thanks so much
06:52:07 <mmorrow> and there're two "wrapper"s at the top
06:52:20 <dolio> Which probably means its... [1..n].
06:52:23 <sw17ch> _start and _stop?
06:52:26 * boegel is having trouble learning anything at all from this
06:52:30 <daf> the curves are remarkably smooth
06:52:41 <boegel> daf: yeah :) I wonder if that's a good thing :P
06:52:50 <dolio> Or perhaps not...
06:53:08 <daf> boegel: well, it tells you which proportion of your data belongs to each data type
06:53:16 <boegel> dolio: well, it would have to be _something_ in main
06:53:18 <daf> boegel: you can also ask it to partition the graph in different ways
06:53:28 <boegel> daf: hmm, k
06:53:37 <dolio> Yeah, but I'm thinking that [1..n] shouldn't take up a huge space on the heap.
06:53:47 <dolio> It should be lazily generated and consumed.
06:53:48 <boegel> daf: well, at least this is saying me IntMap doesn't seem the best way to go
06:53:57 <dolio> If it's not fused away entirely.
06:53:58 <boegel> dolio: yeah, I agree
06:54:39 <boegel> dolio: but, it's processed by foldrM, which might be a reason why it can't be consumed lazily, right?
06:54:54 <dolio> Well, that foldrM might build something big.
06:54:56 <dolio> I'm not sure.
06:54:56 <boegel> dolio: it's actually pretty much useless
06:55:39 <mmorrow> sw17ch: and one of those wrappers is used in prepRescheduler :: Rescheduler -> IO (FunPtr CRescheduler) which is is http://moonpatio.com/repos/hsev/src/System/Ev.hs
06:55:50 <boegel> dolio: using "return $!" instead of "return $" in addOne didn't make any difference
06:56:12 <sw17ch> mmorrow: thanks. that's good to know.
06:56:17 <sw17ch> some one took interest in my portaudio bindings
06:56:25 <sw17ch> so now i'm personally being shamed into improving them
06:56:33 <mmorrow> sw17ch: hehe, nice
06:56:44 <mmorrow> sw17ch: that reminds me, i've gotta check those out
06:56:54 <sw17ch> mmorrow: oh dear. please send patches :)
06:57:04 <sw17ch> that was my "lets learn the FFI" project
06:57:05 <mmorrow> :)
06:57:16 <dolio> boegel: What kind of argument should I run this with?
06:58:24 * sw17ch goes back to look at his portaudio project.... cries
06:58:51 <sw17ch> holy cow, i'm so going to change all of this...
06:59:09 <sw17ch> record field disambiguation...
06:59:14 <sw17ch> record punning
06:59:16 <sw17ch> oh man, here we go
06:59:22 <boegel> dolio: see the graph
06:59:33 <boegel> dolio: something like 100000 is doable in under a minute
07:00:13 <dolio> I actually ran it with 1,000,000. Took around 20s.
07:00:45 <boegel> dolio: yeah, could be
07:00:53 <boegel> dolio: depending on your system
07:01:13 <boegel> dolio: 100,000,000 takes 22m and 2.4G :)
07:03:50 <dolio> Oh, wait.
07:04:25 <boegel> dolio: :)
07:04:32 <dolio> I have an idea.
07:04:42 * boegel woehes
07:06:46 <sw17ch> is it legit to force people into 6.10 yet?
07:07:18 <dolio> boegel: Guess what. I just made your program 10x faster.
07:07:28 <boegel> dolio: holy crap
07:07:31 <boegel> dolio: tell me how :)
07:07:37 <dolio> Install mersenne-random.
07:07:45 <dolio> And use that, because System.Random sucks.
07:07:47 <boegel> dolio: heh :)
07:07:56 <boegel> dolio: the use of Random is just to test it
07:08:12 <boegel> dolio: in the real thing, I'm reading the data from scratch, it's not randomly generated
07:08:30 <boegel> dolio: does it help at all with the memory usage?
07:08:38 <dolio> Yes.
07:08:45 <boegel> dolio: really?
07:09:07 <dolio> Memory usage is down by about 100x.
07:09:37 <dolio> Only 40x total heap allocation, but 100x copied garbage.
07:09:44 <boegel> dolio: wtf?
07:10:07 <boegel> dolio: why on earth does System.Random need that much memory?
07:11:31 <dolio> Hmm...
07:11:58 <bremner> sw17ch: IMHO, no
07:12:13 <mmorrow> boegel: System.Random is *super* slow
07:12:17 <sw17ch> :(
07:12:32 <sw17ch> was record field disambiguation or punning available in 6.8?
07:13:05 <mmorrow> boegel: (and *super* not . (`elem` [AWESOME]))
07:13:15 <dolio> Actually, I lied. That wasn't the problem.
07:13:32 <dolio> Check this out:
07:13:47 <mmorrow> liar!
07:14:23 <dolio> If you replace "randomNumber (i1,i2) = randomRIO (i1,i2)" with "randomNumber _ = randomIO" it makes an even bigger improvement.
07:14:51 <dolio> I was using the equivalent of randomIO with the mersenne package. But writing it back to a range made it just as slow as System.Random.
07:15:02 <mmorrow> interesting
07:15:03 <bremner> is there a standard library routine for randomPermutation?
07:15:54 <mmorrow> bremner: no, but one easy way to do it that's somewhat decent is to just:
07:15:58 <bremner> sw17ch: re ghc6.10 it depends on your audience I guess.  People who rely on distros mostly won't have 6.10 yet
07:16:17 <dolio> So doing 'r <- random ; return (r `mod` (i2 - i1) + i1)' makes it orders of magnitude slower.
07:16:30 <sw17ch> bremner: it's true :(
07:16:43 <dolio> And heap usage balloons.
07:16:43 <boegel> dolio: so, how do I generate a random number in a certain range quickly then?
07:16:50 <dolio> Even with "return $! ...".
07:16:58 <boegel> dolio: sounds like a bug... :)
07:17:00 <mmorrow> > let xs = ['a'..'z'] in fmap snd . sortBy (compate `on` fst) . zip (randoms (mkStdGen 112358)::[Int]) $ xs
07:17:01 <lambdabot>   Not in scope: `compate'
07:17:05 <mmorrow> > let xs = ['a'..'z'] in fmap snd . sortBy (compare `on` fst) . zip (randoms (mkStdGen 112358)::[Int]) $ xs
07:17:06 <lambdabot>   "bemtykovwnxuqjzfshldigacpr"
07:17:28 <whpearson> Is a patch a type of Arrow? Patch as in the diff/patch idea, something that transforms a string into another string.
07:17:45 <quicksilver> whpearson: no.
07:17:56 <quicksilver> well, probably not.
07:17:58 <bremner> mmorrow: thanks.
07:18:03 <quicksilver> depends if you admit arbitrary functions as patches.
07:18:05 <quicksilver> if you do, then yes.
07:18:14 <mmorrow> > let permute gen xs = fmap snd . sortBy (compare `on` fst) . zip (randoms gen ::[Int]) $ xs in permute (mkStdGen 9274893) ['a'..'z']
07:18:15 <lambdabot>   "usotjazedkicqpwgvynxrlfhmb"
07:18:18 <quicksilver> most definitions of patch have more 'structure' and don't admit arbitrary functions though.
07:18:21 <mmorrow> bremner: np
07:18:37 <coconut> hi, I want to lear more about the internals of ghc, the different phases of code generation etc. where is a good place to start?
07:18:59 <Saizan> (it might still be an arrow in the CT sense, but many things are)
07:19:00 <mmorrow> coconut: http://hackage.haskell.org/trac/ghc/
07:19:02 <quicksilver> sw17ch: record punning goes back to 6.6 and disambiguation to 6.6 ot 6.68, IIRC. I don't recommend the features though.
07:19:11 <mmorrow> coconut: in particular, http://hackage.haskell.org/trac/ghc/wiki/Commentary
07:19:17 <dolio> boegel: Oh, wait. Never mind. It was exiting with an error that I didn't see with all the debugging information.
07:19:25 <quicksilver> Saizan: I think "Arrow" is probably a bad name for the type class, for that reason :)
07:19:33 <boegel> dolio: yeah, you need values in that range
07:19:37 <pejo> coconut, the ghc developer wiki has some links to some lectures.
07:19:37 <coconut> thanks
07:19:40 <whpearson> Hmm, okay. I'm trying to figure out a good abstraction for what they are.
07:19:41 <boegel> dolio: otherwise you'll run into trouble
07:19:44 <sw17ch> quicksilver: why? i think they are really nice to have around
07:20:00 <boegel> dolio: so, the random number generation doesn't seem to be the issue?
07:20:31 <quicksilver> sw17ch: I think life is made simpler by accepting that record selectors are not field names.
07:20:38 <quicksilver> sw17ch: they are functions, as in "x :: MyType -> Int"
07:20:51 <bremner> @src ransoms
07:20:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:20:56 <bremner> @src randoms
07:20:56 <lambdabot> Source not found. There are some things that I just don't know.
07:21:11 <quicksilver> sw17ch: if you treat them as functions, the namespacing/punnning thing doesn't really arise.
07:21:15 <quicksilver> sw17ch: still, just my opinion ;)
07:21:47 <sw17ch> quicksilver: ideally, you're right. i just hate having to end up with really long names for my records. i'm not wanting to treat them like "fields", but i don't want to type a paragraph to get something out either
07:22:04 <sw17ch> data Foo = Foo { zomgItsSolongWhyAmIStillTyping :: Int }
07:22:05 <sw17ch> i hate that
07:22:26 <sw17ch> and when i'm dealing with lots of data types with similar fields...
07:22:28 <dolio> boegel: Yeah. Randoms aren't the issue.
07:22:28 <sw17ch> i end up having to do that :(
07:23:12 <dolio> Oh well.
07:23:54 <maltem> boegel: I think that generation of those many random numbers will slow everything down, but not really affect memory usage
07:24:03 <boegel> maltem: I'd agree
07:24:14 * boegel wonders what the issue is then
07:24:39 <dolio> boegel: The profiler does say that 37% of the allocation is done in randomNumber, though.
07:25:25 <mmorrow> , parseExp "\\rec x -> rec {foo = x}"
07:25:26 <lunabot>  Right (LamE [VarP rec,VarP x] (RecUpdE (VarE rec) [(foo,VarE x)]))
07:26:17 <boegel> dolio: hmm
07:26:37 <boegel> dolio: even with the Mersenne pacakge?
07:26:48 <boegel> (I'm having trouble installing it on my PB)
07:26:57 <sw17ch> quicksilver: is there an alternative to punning you don't mind?
07:27:02 <cnwdup> How can I use catch in a monad transformer with the lowest being IO?
07:27:55 <dolio> Didn't profile with that. Hold on.
07:28:46 <mdiin> @src mapAccumL
07:28:46 <lambdabot> mapAccumL _ s []        =  (s, [])
07:28:46 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
07:28:46 <lambdabot>    where (s', y ) = f s x
07:28:46 <lambdabot>          (s'',ys) = mapAccumL f s' xs
07:29:19 * boegel holds on
07:30:31 <mmorrow> , ppDoc `fmap` (let upd lbl = do rec <- newName "rec"; x <- newName "x"; lamE (fmap varP [rec,x]) (recUpdE (varE rec) [return (lbl, VarE x)]) in upd 'subForest)
07:30:32 <lunabot>  \rec_0 x_1 -> rec_0{subForest = x_1}
07:30:59 <quicksilver> sw17ch: in reasonable sized programs I don't use field names at all.
07:31:03 <mmorrow> , $(let upd lbl = do rec <- newName "rec"; x <- newName "x"; lamE (fmap varP [rec,x]) (recUpdE (varE rec) [return (lbl, VarE x)]) in upd 'subForest) (Node 0 []) [Node 1 []]
07:31:05 <lunabot>  Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = []}]}
07:31:06 <quicksilver> sw17ch: I use lenses.
07:31:21 <sw17ch> quicksilver: i guess i'm not sure what a lense is :)
07:31:24 <sw17ch> linky?
07:31:31 <quicksilver> sw17ch: you still need to find ways to manage your namespace but I don't find that substantially different from any other identifier
07:31:38 <tomh> any dutch people here with an msc atm?
07:31:41 <quicksilver> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
07:31:44 <quicksilver> sw17ch: ^^
07:31:46 <klibbigt> has anyone actually run something significant in haskell on the netflix dataset?
07:32:21 <boegel> klibbigt: planning to
07:32:43 <tromp_> yes, tomh
07:32:46 <sw17ch> quicksilver: hmmmm
07:32:52 <tomh> tromp_: in CS?
07:32:54 <klibbigt> i just did a small implementation when i was a beginner haskeller
07:32:56 <tromp_> yes
07:33:09 <tomh> can you recommend some 'afstudeer' companies to me? :)
07:33:15 <klibbigt> tomh: did you do netflix in haskell? results?
07:33:23 <tomh> i didn't
07:33:24 <klibbigt> boegel: what are you planing to do? svd?
07:33:36 <tromp_> sorry; i never went to any company:(
07:33:46 <tomh> where did you do your thesis?
07:33:51 <tromp_> at cwi
07:33:56 <tromp_> cwi.nl
07:34:03 <tomh> well thats a company sort of
07:34:13 <tromp_> ok, i can recommend them:)
07:34:19 <tomh> and what about your peer students, where did they do their thesis?
07:34:42 <dolio> boegel: With the mersenne package it does more like 15% allocation.
07:35:05 <tromp_> boy, can't  remember what they did
07:35:24 <tomh> ok
07:35:30 <whpearson_> I might try making making an automorphism class.
07:35:36 <tromp_> one was within uva
07:35:54 <boegel> klibbigt: hell no, see my blog post
07:35:58 <tromp_> in what was then called aten lab
07:36:04 <boegel> dolio: how much was it with System.Random?
07:36:12 <dolio> 37%
07:36:12 <Saizan> whpearson_: is your patch type going to be of kind * -> * -> * ?
07:36:18 <sw17ch> quicksilver: that's a really cool technique
07:36:19 <tromp_> this was back in 89
07:36:21 <boegel> dolio: hmm, k
07:36:29 <tomh> ok thats a long time ago
07:36:32 <boegel> dolio: finally got Mersenne working, trying it too now
07:36:56 <tomh> im having a hard time finding any companies doing something with functional programming here
07:36:58 <whpearson_> saizan: I'm still a bit fuzzy about kinds at the moment.
07:37:14 <tromp_> i can imagine...
07:37:37 <quicksilver> sw17ch: as soon as you have nested records, it's really nice
07:37:50 <sw17ch> quicksilver: i have lots of nested records!
07:37:58 <Saizan> whpearson_: well, is it going to take type parameters like (->) in a -> b? otherwise Monoid might fit
07:37:58 <quicksilver> sw17ch: if you've ever written \x -> x { y = y x { z = z' } }
07:38:04 <quicksilver> then you know what I mean ;)
07:38:09 <tomh> tromp_: you work at cwi now?
07:38:10 <sw17ch> quicksilver: i could hug you right now
07:38:20 <sw17ch> scurry has been suffering from that for a long time now
07:38:23 <quicksilver> sw17ch: there is an implementation on hackage called 'Data.Accessor'
07:38:29 <quicksilver> I'm not wild on their choice of primitive
07:38:30 <sw17ch> i didn't like the syntax :\
07:38:36 <quicksilver> but it shows what you can do.
07:38:40 <tromp_> i left in 2006
07:38:51 <tomh> ok
07:39:13 <quicksilver> sw17ch: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1058 is my version
07:39:22 <whpearson_> saizan: I had a variant of it with monoid, but it doesn't quite capture the whole logic of the class. It doesn't say anything about what it does to strings.
07:39:58 <boegel> dolio: how do I obtain the profiling packages for Mersenne?
07:39:59 <whpearson_> saizan: I'll mock something up quick this evening and see how it works.
07:40:49 <dolio> You pass --enable-library-profiling when you build it.
07:41:14 <boegel> dolio: hmm, k
07:43:08 <hackage> Uploaded to hackage: blogination 0.4
07:43:16 <sw17ch> quicksilver: why haven't you hackaged that? :)
07:43:35 <sw17ch> or is it a simple enough constrcut that it's not worth it?
07:43:37 <quicksilver> sw17ch: because it's not finished.
07:43:45 <sw17ch> oic :)
07:43:47 <klibbigt> which is the "official" haskell mailing list? comp.lang.fa.haskell? comp.lang.haskell? comp.lang.functional?
07:43:51 <quicksilver> I don't finish stuff. I start it and work on it until something else is more interesting.
07:45:05 <sw17ch> quicksilver: foo <.> a <.> b -- grab return field b from the record stored at field a of foo ?
07:45:17 <dancor> @src zipWith
07:45:17 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:45:17 <lambdabot> zipWith _ _      _      = []
07:45:18 <dancor> @src zip
07:45:19 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:45:19 <lambdabot> zip _      _      = []
07:45:23 <dancor> why no reuse
07:45:26 <dancor> efficiency?
07:45:51 <idnar> I don't see why zipWith (,) would be less efficient, but maybe I'm missing something
07:46:02 <Ferdirand> how accurate is @src anyway ?
07:46:41 <MyCatVerbs> Ferdirand: reeeeasonably. There are places where #ifdef hackery gets used, but not that many.
07:46:55 <idnar> of course, which should reuse which? :P
07:47:04 <MyCatVerbs> Ferdirand: it won't show you any of the rewrite RULES or anything, though.
07:47:06 <quicksilver> sw17ch: that would be "lGet (a <.> b) foo"
07:47:21 <idnar> it (@src) is implemented by reading stuff out of a text file, so it's as accurate as whatever was manually put in that text file :P
07:47:21 <quicksilver> sw17ch: I wanted an infix operator for lGet btu I haven't made up my mind what it should look like.
07:47:23 <sw17ch> quicksilver: ah, i'll just have to play with stuff like this... or look closer
07:47:37 <quicksilver> sw17ch: anyway, <.> composes two lenses, it doesn't actually do the access (yet)
07:47:43 <idnar> quicksilver: do you have a module called Deus.Ex?
07:47:53 <quicksilver> idnar: no, only the submodule 'Machina'
07:47:55 <sw17ch> quicksilver: so you do the composition, and then use lGet to specify what record to whack with the lense stack?
07:47:58 <MyCatVerbs> idnar: heheh, nano-swords.
07:47:59 <sw17ch> :)
07:48:05 <quicksilver> idnar: that actually runs my IRC bot
07:48:19 <quicksilver> sw17ch: yes. lGet is not a very pretty name. As I say, I hadn't decided what name I liked.
07:48:24 <quicksilver> sw17ch: but yes, you're right.
07:48:33 <sw17ch> is </> a valid operator?
07:48:38 <boegel> dolio: thanks a lot for your help (and the others too of course), I'll be off home soon
07:48:39 <idnar> quicksilver: sweet
07:48:48 <boegel> dolio: I hope I can manage to write up a blog post on all this
07:48:56 <sw17ch> foo </> a <.> b
07:48:57 <quicksilver> sw17ch: sure. It's used by FilePath but that doesn't mean you can't use it for something else.
07:48:57 <gwern> whoa, jdh is still on -cafe
07:48:59 <sw17ch> i like that for some reason
07:49:23 <sw17ch> gwern: part of me died when i saw his message this morning
07:49:46 <gwern> sw17ch: must be spring. all the trolls are popping out of hibernation
07:49:55 <sw17ch> gwern: and a few frogs
07:49:56 <sw17ch> :P
07:50:16 <sw17ch> but really, -cafe has been heavily populated by trolls lately
07:50:53 <MyCatVerbs> sw17ch: has it? That's a pity.
07:51:21 <sw17ch> MyCatVerbs: there was the throdown about ghc vs. gcc and now jdh has crawled out from underneath a lilly pad somewhere
07:54:15 <boegel> dolio: on my end, with System.Random it runs for 1m14 and needs 504M, while with Mersenne it runs for 51s and needs 495M
07:54:21 <boegel> so the main gain is in runtime
08:00:17 <mmorrow> quicksilver: this could be nice for lenses:
08:00:22 <mmorrow> @let focus lens a f = (uncurry f) (lens a)
08:00:22 <lambdabot>  Defined.
08:02:21 <quicksilver> :t focus
08:02:21 <lambdabot> forall t a b c. (t -> (a, b)) -> t -> (a -> b -> c) -> c
08:02:36 <klibbigt> can you define hashmaps algebraically?
08:02:37 <mmorrow> > focus (\(a,((b,c),(d,e))) -> (c, \c -> (a,((b,c),(d,e))))) ("hai",((42,9000),([],Nothing))) (\x k -> k (x * 2000))
08:02:38 <lambdabot>   ("hai",((42,18000000),([],Nothing)))
08:02:53 <klibbigt> exactly what can you define algebraically?
08:03:15 <mmorrow> quicksilver: (where the case of a lens would be a special case)
08:03:47 <boegel> dolio: how did you manage to determine how much heap allocation is done by Random?
08:03:51 * quicksilver nods
08:04:05 <mmorrow> > focus (\(a,((b,c),(d,e))) -> (c, \c -> (a,((b,c),(d,e))))) ("hai",((42,9000),([],Nothing))) (\x k -> (k . k) (x * 2000))
08:04:06 <lambdabot>       Occurs check: cannot construct the infinite type:
08:04:06 <lambdabot>        b = ([Char], (...
08:04:09 <mmorrow> grr
08:04:14 <dolio> boegel: compile with -prof -auto-all
08:04:20 <dolio> boegel: Run with +RTS -p
08:04:29 * mmorrow wants infinite types
08:04:34 <boegel> dolio: ah, I was using the -h<x> options
08:05:31 <dolio> addOne does even more allocation than randomNumber.
08:05:53 <boegel> dolio: which makes perfect sense, because there the UArray are built :)
08:06:02 <dolio> Yeah.
08:06:14 <boegel> I think I'll just have to test this on the real thing, and see how much space it needs
08:07:14 <mdmkolbe> What sort of things would someone use the Zipper for?
08:07:17 <dolio> But +RTS -sstderr shows that there's 4.5 GB of allocation and only about 1.5 GB of copying (for my runs at 1 million).
08:07:24 <mmorrow> ghci> focus (\(a,((b,c),(d,e))) -> (c, \c -> (a,((b,c),(d,e))))) ("hai",((42,9000),([],Nothing))) (\x k -> (unsafeCoerce k . k) (x * 2000)) :: (String,((Int, (String,((Int,Int),([a], Maybe b)))), ([a], Maybe b)))
08:07:26 <mmorrow> woot
08:07:41 <dolio> I suppose that could be a lot of discarded arrays.
08:07:44 <mmorrow> (gives ("hai",((42,("hai",((42,18000000),([],Nothing)))),([],Nothing))))
08:08:43 <pejo> @google oleg zipper
08:08:44 <lambdabot> http://lambda-the-ultimate.org/node/1036
08:08:44 <lambdabot> Title: Zipper-based file server/OS | Lambda the Ultimate
08:09:06 <boegel> dolio: yeah, makes perfect sense, I'm recreating arrays all over the place
08:09:13 <boegel> dolio: there will be a lot of GC
08:09:30 <mmorrow> y f = let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z
08:10:05 <mmorrow> ghci> take 10 $ y (\fib m n -> m : fib n (m+1)) 0 1
08:10:05 <mmorrow> [0,1,1,2,2,3,3,4,4,5]
08:10:14 <mmorrow> oops
08:10:20 <mmorrow> m+n
08:24:25 <rio> uh, understanding how to define foldl using foldr is a real pain in the ass
08:24:38 <hcube> I've just upgraded cabal-install and it seems that currently it is inpossible to install reactive, due to disabled upgrade feature. (ghc 6.10.1 uses quickcheck 1.* but reactive requires 2.*) Do you know any solution?
08:25:16 <drdozer> hi
08:25:29 <drdozer> I have 2 programs (main methods) that do basically the same thing
08:25:39 <drdozer> but work on 2 data-structures
08:26:08 <drdozer> I want to merge them into a single command-line app that depending on a switch runs on one or the other data type
08:26:12 <drdozer> is there a trick to this?
08:26:48 <Cheshire> you have mainA, mainB :: IO a ?
08:27:18 <maltem> hcube: for quickcheck, having multiple versions shouldn't harm, I'd say, so just install another quickcheck
08:27:20 <Cheshire> and you want to write like   main = do args <- getArgs ; case checkArgs of A -> mainA ; B -> mainB
08:27:23 <Cheshire> ?
08:27:25 <drdozer> yeah, and they share 90% logic with 4 funcs that bind them to a particular datatype
08:27:45 <Cheshire> in that case you could abstract the functions out
08:27:58 <Cheshire> so it's mainA, mainB :: foo -> bar -> IO a
08:29:53 <Cheshire> so it's mainBoth :: foo -> bar -> IO a**
08:31:29 <hcube> maltem: cabal sait hat quickcheck is already installed
08:31:39 <hcube> *sais
08:31:53 <hcube> *say
08:31:56 <dcoutts_> hcube: are you looking for quickcheck-2 perhaps?
08:32:52 <hcube> i'd just like to install reactive
08:32:52 <dcoutts_> the default version is 1.x you need to do
08:32:53 <dcoutts_> cabal install 'quickcheck >= 2'
08:33:10 <drdozer> Cheshire: I will refactor towards that and see what drops out
08:33:15 <rio> thats pain.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1648
08:33:17 <hcube> thanks
08:33:26 <hcube> now it works
08:34:09 <dcoutts_> hcube: ah, so reactive builds now? so the problem was that reactive did not correctly specify the version of qc that it needs, you might like to inform the maintainer of the reactive package.
08:35:22 <hcube> dcoutts_: no, just quickcheck
08:35:37 <hcube> cabal install reactive still drops errors
08:36:43 <hcube> here is the output: http://pastebin.com/m3d96dced
08:38:07 <hcube> now i have qc 1.x and 2.x
08:38:11 <dcoutts_> hcube: right, so as that explains, consistent dependencies cannot be found automatically
08:38:36 <dcoutts_> apparently reactive does specify the version of QC that it needs, which is < 2
08:38:53 <dcoutts_> but Stream-0.3.1 requires QC >= 2
08:38:56 <dcoutts_> hence the conflict
08:38:57 <HugoDaniel> how do i remove a package installed with cabal ?
08:39:11 <dcoutts_> hcube: it might be possible to get it to work using an older version of Stream
08:39:16 <skorpan> HugoDaniel: ghc-pkg unregister and remove the directory
08:39:26 <skorpan> there's no "uninstall" capabilities afaik
08:39:56 <paper_cc> HugoDaniel: and maybe remove installed executables from ~/.cabal/bin (manually)
08:40:03 <HugoDaniel> oh bummer :(
08:40:13 <HugoDaniel> this is going to be a pain in the ass
08:40:29 <skorpan> lol
08:40:37 <dcoutts_> HugoDaniel: not necessarily, they're not in a place where they cause any problem
08:41:00 <dcoutts_> and if you ever need to blow it all away that's easy
08:41:10 <dcoutts_> unregistering individual packages is easy
08:41:34 <HugoDaniel> well ghc-pkg says it cannot find package
08:41:35 <HugoDaniel> :S
08:41:36 <dcoutts_> it's just removing old package files that isn't automated, but that's not necessary except to recover disk space
08:42:26 <dcoutts_> HugoDaniel: you mean the package you unregistered? or you're talking about something that you think is or should be registered?
08:42:47 <hcube> with an older stream version reactive compiles fine :)
08:42:49 <hcube> thanks
08:43:08 <hackage> Uploaded to hackage: AERN-RnToRm-Plot 0.1.2
08:43:08 <hackage> Uploaded to hackage: AERN-RnToRm 0.4.9
08:43:08 <hackage> Uploaded to hackage: AERN-Real 0.9.9
08:43:34 <HugoDaniel> i mean, cabal install happs-server, worked fine, now for ghc-pkg unregister i have this: ghc-pkg: cannot find package happs-server
08:43:40 <HugoDaniel> :/
08:43:59 <Botje> check with ghc-pkg list
08:44:06 <Botje> perhaps the pacakge is not named happs-server
08:44:16 <dcoutts_> HugoDaniel: use ghc-pkg list to see
08:44:22 <HugoDaniel> ah ok
08:44:26 <HugoDaniel> i must put the exact name
08:44:40 <HugoDaniel> where is the pkg dir of ghc ?
08:44:45 <dcoutts_> HugoDaniel: but also, by default it uses --global, but cabal installs things per-user, so you would want to ghc-pkg unregister --user HAppS-server
08:44:57 <dcoutts_> also note that ghc-pkg is case sensitive
08:45:22 <dcoutts_> HugoDaniel: ghc-pkg list shows the file names of both package databases
08:45:34 <HugoDaniel> it still outputs ghc-pkg: cannot find package HAppS-Server-0.9.3.1
08:45:42 <HugoDaniel> even though i have specified the correct name
08:45:48 <drdozer> mm, ghc is giving me errors at line 1:0, when I'm fairly certain the error must be elsewhere in the file
08:45:53 <dcoutts_> HugoDaniel: did you use --user ?
08:46:01 <HugoDaniel> ok
08:46:06 <HugoDaniel> it works with --user
08:46:07 <HugoDaniel> ;)
08:46:49 <HugoDaniel> sweet
08:46:50 <HugoDaniel> thanks
08:47:08 <senxhnsshp> what would be a good exercise in topology to implement in haskell?
08:47:12 <senxhnsshp> homology?
08:47:35 <senxhnsshp> homology of the alphabet, black characters on white screen?
08:47:50 <quicksilver> "/win 20
08:47:53 * quicksilver sighs
08:48:02 <quicksilver> "/lose everything
08:49:02 <HugoDaniel> hmm
08:49:07 <HugoDaniel> why can't i install ghc from cabal ?
08:49:18 <HugoDaniel> is compiling ghc from source "recommended" ?
08:49:35 <paper_cc> installing precompiled binaries is recommended
08:49:45 <quicksilver> because ghc's build system is as complicated as a computation engine the size of the amazonian rainforest, with data carried by squirrels on zipwires.
08:49:52 <redditbot> GHC on SPARC: Sanity
08:49:52 <redditbot> Wadler's Blog: Conal Elliot on Type class morphisms
08:49:58 <bogner> quicksilver: good analogy
08:49:58 <quicksilver> and cabal can't do squirrel-grade build systems.
08:50:05 <MyCatVerbs> HugoDaniel: meh. It's not really all that necessary, but it's generally painless and takes about an hour or two to build on modern-ish CPUs.
08:50:22 <quicksilver> precompiled binaries / packages are recommended.
08:50:33 <HugoDaniel> :D
08:51:03 <MyCatVerbs> That complicated, really? I seem to remember ./configure && make && make install # having worked just fine for me last time I tried it.
08:51:33 <paper_cc> bwhaha
08:51:40 <senxhnsshp> homology of the alphabet, black characters on white screen?
08:51:41 * paper_cc compiled ghc after two tries
08:51:46 <senxhnsshp> what would be a good exercise in topology to implement in haskell?
08:52:07 <MyCatVerbs> HugoDaniel: if your distro packages GHC, use that one. You lose the benefit of rolling upgrades if you build it yourself.
08:52:17 <quicksilver> MyCatVerbs: the complexity is there, behind that makefile.
08:52:23 <quicksilver> MyCatVerbs: cabal doesn't use makefiles.
08:52:53 <MyCatVerbs> quicksilver: that's fine by me. Things behind makefiles are allowed to be arbitrarily complicated iff they work.
08:53:09 <MyCatVerbs> quicksilver: I haven't had any issues building from any of the stable release tarballs.
08:53:19 <quicksilver> MyCatVerbs: right, but that's still the answer to why ghc doesn't use cabal.
08:53:29 <quicksilver> MyCatVerbs: cabal cannot yet replicate all the complexity in that makefile.
08:54:11 <dcoutts_> quicksilver: in principle it'd be possible, but it's fairly pointless
08:54:26 <MyCatVerbs> In practice, wouldn't making Cabal that complicated ruin it? :P
08:55:28 <MyCatVerbs> quicksilver: anyway, where did we get onto Cabal-ization of GHC? I was addressing HugoDaniel's query about building GHC.
08:55:54 <MyCatVerbs> Oh right, because he asked about installing GHC from Cabal. Upscroll FTW.
08:57:12 <raxas> senxhnsshp: knotworks on regular grid
08:58:44 <raxas> senxhnsshp: http://knotwork.sourceforge.net/ is java
09:00:40 <drdozer> Cheshire: thanks for the sugestion - it's worked a charm
09:04:12 <HugoDaniel> when i do a cabal install parsec, it goes for the 2.1 version, why is this ?
09:04:24 <dcoutts_> HugoDaniel: that's the default version
09:04:45 <dcoutts_> if you want version 3 then: cabal install 'parsec >= 3'
09:05:06 <ziman> can I have both?
09:05:10 <dcoutts_> yes
09:05:13 <HugoDaniel> thanks dcoutts_  :)
09:05:18 <dcoutts_> btw, don't assume that version 3 is better because it has a higher version number
09:06:36 <HugoDaniel> hmm
09:06:48 <HugoDaniel> i am using the parsec.error, wich is only present on version 3
09:07:04 <HugoDaniel> i feel that both parsec, and hxt (the parsers im using) are VERY slow :(
09:07:06 <BONUS> hmmm, is there any way to catch only Prelude.read: no parse exceptions with catch
09:07:16 <HugoDaniel> my xpath query strings are also not the best...
09:07:26 <BONUS> short of making ayour own NoRead exception and implementing a wrapper over read
09:07:43 <quicksilver> BONUS: just NEVER EVER EVER EVER EVER use read
09:07:57 <quicksilver> BONUS: and please, never even consider catching an exception raised in pure code
09:08:01 <quicksilver> that way madness lies.
09:08:10 <BONUS> yeah that i know hehe
09:08:15 <BONUS> also, reads 4 lyfe
09:08:21 <quicksilver> use "reads" and intercept the parse failure in a sensible way.
09:09:32 <BONUS> true that
09:10:57 <BONUS> i was just kinda curious
09:12:22 <dcoutts_> BONUS: the answer is that you can raise exceptions in pure code and catch them in IO
09:13:28 <dcoutts_> that's good for "top level" style exception handler and as quicksilver says you don't want to do that generally for local error handling
09:13:57 <BONUS> yeah, i've avoided using exceptions from pure code so far
09:14:16 <dcoutts_> BONUS: they're fine for things that are programming mistakes of course
09:14:30 <dcoutts_> eg pre-conditions not satisfied
09:14:40 <BONUS> it's just that i'm writing about exceptions and i'm wondering if i should introduce throwing and catching exceptions from purecode at all
09:15:03 <dcoutts_> BONUS: well you can talk about error, that's like unchecked exceptions in java
09:15:11 <PeakerWork> I keep writing: mRead :: Read a => String -> Maybe a
09:15:16 <dcoutts_> and useful in the same sorts of cases
09:15:20 <PeakerWork> @hoogle Read a => String -> Maybe a
09:15:20 <lambdabot> Prelude read :: Read a => String -> a
09:15:21 <lambdabot> Text.Read read :: Read a => String -> a
09:15:21 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
09:15:29 <dcoutts_> for error handling in pure code I like to use data structures that model the outcomes
09:15:41 <dcoutts_> and if that includes error cases then those are just extra outcomes
09:15:41 <Cheshire> BONUS, I don't think it's an important thing
09:15:45 <BONUS> me too
09:15:46 <quicksilver> dcoutts_: they're not that great even for programming mistakes
09:15:53 <quicksilver> dcoutts_: since they only get forced lazily.
09:15:53 <Cheshire> BONUS, but that doesn't mean you should or shouldn't includei t..
09:16:05 <dcoutts_> quicksilver: well, that's ok too :-)
09:16:12 <quicksilver> dcoutts_: well yes, it's ok if it's ok
09:16:24 <BONUS> i was wondering if i should cover exceptions as they are presented in marlow's paper "An Extensible Dynamically-Typed Hierarchy of Exceptions"
09:16:28 <quicksilver> but often that isn't what you want.
09:17:07 <BONUS> i'll probably do that but i'll write in bold fonts to avoid exceptions in pure code whenever possible and use stuff like Maybe and Either instead
09:17:08 <dcoutts_> quicksilver: I don't really see the problem
09:17:30 <quicksilver> dcoutts_: well if it *is* a programming error you presumably want to know about it.
09:17:38 <dcoutts_> quicksilver: checking too much up front at runtime can make the code too strict, some assertion checking has to be done lazily if it's to be done at all
09:17:42 <quicksilver> dcoutts_: so laziness is hiding a bug in your code.
09:17:52 <quicksilver> dcoutts_: sure, I agree.
09:17:58 <dcoutts_> quicksilver: well, you can hide bugs in programs in many ways
09:18:00 <quicksilver> it's ok when that is the behaviour you want.
09:18:21 <quicksilver> true.
09:18:23 <dcoutts_> quicksilver: since you don't rely on the exception being raised for correct behaviours then I don't see that it matters much when it is raised
09:18:49 <BONUS> for instance, take the trivial program presented in RWH: :take two numbers from the user input and do `div` between them
09:18:50 <quicksilver> I know you understand the issues involved.
09:19:04 <BONUS> do you guys think that exceptions should be used in that case or should the programmer check for 0
09:19:05 <quicksilver> There is a choice in how much work you do to decide if an error has occurred.
09:19:14 <dcoutts_> aye
09:19:29 <quicksilver> All other things being equal, I would use an Either type, which forces your code to do "enouguh" work to check it's Right
09:19:36 <quicksilver> (well the first time you pattern match, it does)
09:19:46 <quicksilver> there are some patterns of behaviour where that really *isn't* waht you want
09:19:55 <quicksilver> (forcing an 80G file to check for well-formed-ness)
09:20:12 <quicksilver> but then you have to accept that you may get asynchronous well-formed-ness-failures
09:20:18 <quicksilver> that's the price you pay for streaming large files.
09:20:34 <dcoutts_> so an approach which I don't think gets enough attention but is very FP, is just using lazy data types to encode the outcomes, including errors, like:
09:20:35 <dcoutts_> data Entries = Next Entry Entries
09:20:35 <dcoutts_>              | Done
09:20:35 <dcoutts_>              | Fail String
09:20:45 <dcoutts_> works great for streaming, and also is safe
09:21:04 * quicksilver nods
09:21:07 <dcoutts_> no danger of loosing errors or throwing exceptions in odd places
09:21:16 <quicksilver> that's what the iteratee would do
09:21:18 <quicksilver> (for example)
09:21:20 <dcoutts_> and provide functions to fold, unfold, map etc
09:21:36 <dcoutts_> quicksilver: aye, but this is simple and pure
09:21:51 <dcoutts_> it does tend to rely on lazy IO however
09:21:57 <dcoutts_> but then I think that's ok :-)
09:22:29 <BONUS> so like list but with two []s, where one represents a failure
09:22:30 <quicksilver> dcoutts_: iteratee is simple and pure.
09:22:32 <BONUS> interesting
09:22:40 <dcoutts_> quicksilver: it's pure
09:22:46 <dcoutts_> BONUS: right, exactly
09:23:03 <quicksilver> dcoutts_: lazy IO, as you well know, is subtle and dangerous ;)
09:23:11 <quicksilver> not to mention poorly named.
09:23:22 <dcoutts_> I prefer subtle and elegant ;-)
09:23:24 <BONUS> should be more ephasis that it's kind of unsafe
09:23:38 <quicksilver> join the campagin for "sinfulInterleaveIO"
09:23:44 <BONUS> haha
09:24:02 <quicksilver> I have a rant about the fact we should call it 'interleaved IO' instead of 'lazy IO'
09:24:14 <quicksilver> to emphasise the fact it's different from normal, (safe) laziness
09:24:15 <dcoutts_> sure, that's a sensible name
09:24:19 <quicksilver> I should post it to the cafe.
09:24:25 <BONUS> that sounds good yeah
09:25:03 <BONUS> when people hear lazy IO, they tend to associate the "lazy" with "purity" since hey, you need purity for laziness
09:25:20 <dcoutts_> quicksilver: I was trying to think how an iterator interface to my tar or zlib libs would work, I don't think it is simple
09:25:28 <dcoutts_> quicksilver: and for zlib it's not clear that it's possible
09:25:34 <quicksilver> BONUS: conversely when people read about problems wiht lazy IO, they infer that there are problems with laziness.
09:25:50 <BONUS> hehe
09:25:53 <bogner> BONUS: but don't they associate IO with "scary non-pure stuff"?
09:26:14 <quicksilver> dcoutts_: someone's got to choose the chunk size. You can imagine that choice being made by client or server
09:26:28 <quicksilver> dcoutts_: and you can imagine variable chunk sizes if that suits the compression algorithm
09:26:39 <BONUS> that too, but sometimes ppl tend to think the lazy part is like the lazy from pure code
09:26:41 <dcoutts_> quicksilver: the problem with zlib is that I don't think we can make a continuation based api for it that is pure and safe
09:27:01 <dcoutts_> quicksilver: because if you're holding a continuation then you can call it many times
09:27:36 <dcoutts_> quicksilver: but if you're holding a list you can only force it once and if you look at it again the value is cached/memoised
09:27:48 <dcoutts_> quicksilver: so we cannot hide the side effects safely
09:28:02 <dcoutts_> the fact that internally we have to thread the zlib state
09:28:32 <quicksilver> dcoutts_: you're trying to make it look pure to the client?
09:29:00 <dcoutts_> quicksilver: no IO anywhere in the zlib api
09:29:09 * quicksilver nods
09:29:26 <dcoutts_> quicksilver: we want a completely pure interface, but we'd like to provide an interface that can be used with iterator style stuff
09:29:57 <quicksilver> well if you want ot provide a completely pure interface then you are committed to interleaved IO
09:30:04 <quicksilver> because there really is underlying IO going on ;)
09:30:12 <dcoutts_> no there isn't
09:30:25 <dcoutts_> but there is a state thread
09:32:51 * quicksilver doesn't understand but sadly doesn't have time to pursue it just now.
09:37:26 <paper_cc> interesting. berkeleydb-2008.10.31 interface has a pure look but has so much unsafePerformIO behind that it probably won't survive a single-threaded-state violation
09:38:48 <Cheshire> paper_cc :(
09:39:44 <paper_cc> Cheshire: what? I just looked at the source code and it seemed to violate referential transparency
09:39:57 <Cheshire> paper_cc, it's a shame
09:40:32 <Cheshire> you start with this great pure language -- and then lose all the nice properties
09:43:09 <hackage> Uploaded to hackage: AERN-Net 0.2.1
09:43:13 <paper_cc> it looks like you even can't preserve the nice properties given the implementation goal (make a map stored using libDB with an interface equivalent to Data.Map) without doing lots of copying
09:45:19 <gwern> > (6*6) * 100000 * 2
09:45:21 <lambdabot>   7200000
09:53:31 <CTA> heyy guys, so i've figured out/remembered how to do some more function stuff, i've done: doubleMe :: (Integral a) => a -> a this is fine for integers but when I give it a floating point ghci screams at me?
09:54:19 <dcoutts_> CTA: right, floating point types are not an instance of Integral
09:54:47 <dcoutts_> if you manage to generalise that function to Num or something, instead of Integral then it'll work fine
09:55:03 <dcoutts_> in ghci, use :info to see which types are instances of which classes
09:55:04 <CTA> Is there someway I can make a function have a numeric input but you are unaware if it'll be int/float?
09:55:20 <glguy> 09:54 < dcoutts_> if you manage to generalise that function to Num or something, instead of Integral then it'll work fine
09:55:36 <CTA> doubleMe :: (Num a) => a -> a
09:55:36 <CTA>  works fine
09:55:49 <CTA> :)
09:56:03 <Badger> ?faq can haskell double me?
09:56:03 <lambdabot> The answer is: Yes! Haskell can do that.
09:56:23 <dcoutts_> glguy: a case for "I refer the honourable gentleman to the answer I gave some moments ago"
09:56:54 <glguy> dcoutts_, my method needed three clicks followed by 'enter' :)
09:57:04 <dcoutts_> glguy: heh heh
09:57:27 <jpcooper> @hoogle (Monad m) => Bool -> String -> m a
09:57:28 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:57:28 <lambdabot> Language.Haskell.TH.Syntax qReport :: Quasi m => Bool -> String -> m ()
09:57:28 <lambdabot> System.Console.GetOpt ReturnInOrder :: String -> a -> ArgOrder a
09:57:33 <CTA> so this code is fine, like correct way to do? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1670#a1670
09:57:39 <CTA> *do it
09:57:48 <jpcooper> @hoogle (Monad m) => Bool -> String -> m ()
09:57:48 <lambdabot> Language.Haskell.TH.Syntax qReport :: Quasi m => Bool -> String -> m ()
09:57:48 <lambdabot> Language.Haskell.TH report :: Bool -> String -> Q ()
09:57:48 <lambdabot> Language.Haskell.TH.Syntax report :: Bool -> String -> Q ()
09:58:12 <jpcooper> I'd like something like guard but takes a string
09:58:14 <jpcooper> to fail in IO
09:58:55 <twoflower> hi. does anybody know what has happened with book.realwordhaskell.org?
09:59:27 <CTA> realworldhaskell.something/read
09:59:33 <coconut> I have a function which computes something, and *sometimes* I want it to print some output while doing this... is there an easy way to have two versions: one with the IO monad, one without?
09:59:59 <blueonyx> twoflower, youre missing a l? http://book.realworldhaskell.org/ works for me
10:00:25 <Cheshire> coconut, make it polymorphic over IO monad or Identity monad
10:01:29 <twoflower> bluonyx, just a typo there. http://book.realworldhaskell.org/ returns now address not found...
10:01:58 <twoflower> I hope this is just a dns issue.
10:02:17 <blueonyx> im currently reading it online :/
10:02:19 <boegel> yo!
10:02:34 <coconut> Cheshire: how can I use putStrLn then?
10:02:46 <boegel> I'm having some trouble getting my datatype to behave as I expected...
10:03:12 <Cheshire> polyfun p1 p2 .. putStrLn = do ... ; putStrLn "boo" ; ...
10:03:20 <Cheshire> polyfun q1 q2 ... putStrLn :: IO a
10:03:20 <twoflower> Could you please give an IP of it?
10:03:26 <boegel> I'm using an IntMap of (UArray Int Word8), but when I'm using an IntMap of (UArray Int Int), I see no difference in the amount of memory the tool uses
10:03:30 <Cheshire> polyfun q1 q2 ... return :: Identity a
10:03:31 <boegel> that doesn't make sense to me
10:03:41 <boegel> UArray Int Word8 code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1672#a1672
10:03:47 <coconut> coconut: I see. there's no typeclass to support this?
10:03:55 <Cheshire> coconut,  Monad
10:03:59 <boegel> (exact) same code, but with UArray Int Int: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1671#a1671
10:04:13 <twoflower> wow, it works again!
10:04:18 <boegel> does anyone know what I need to add to make sure the Word8 is _really_ a single byte?
10:04:22 <coconut> oh, I could make Identity an instance of MonadIO ?
10:04:27 <Cheshire> no
10:04:33 <coconut> why?
10:04:36 <boegel> seems to me GHC thinks it might be a better idea to convert the Word8 to Int or something...
10:04:44 <Cheshire> that would be a lie
10:04:54 <Cheshire> I showed you how to do it
10:05:02 <Cheshire> is this way I suggested not good?
10:05:16 <Cheshire> or do you not understand it?
10:05:24 <coconut> it does solve the problem
10:05:30 <jpcooper> @hoogle [a] -> [a]
10:05:31 <lambdabot> Prelude cycle :: [a] -> [a]
10:05:31 <lambdabot> Prelude init :: [a] -> [a]
10:05:31 <lambdabot> Prelude reverse :: [a] -> [a]
10:05:42 <coconut> however I don't like tossing around  functions that never changes
10:05:51 <coconut> that screams for a type class in my opinion
10:06:00 <Cheshire> ok then
10:06:05 <Cheshire> 1) implement this so that it works
10:06:13 <boegel> dolio: ping
10:06:16 <Cheshire> 2) abstract that away by making the typeclass you think of
10:06:34 <Cheshire> but start from something that is working
10:06:38 <dolio> boegel: I was about to go to lunch. Is it urgent? :)
10:06:40 <coconut> thanks
10:07:20 <boegel> dolio: not really, but look at this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1671#a1671
10:07:39 <boegel> dolio: this version needs the same amount of memory as the Word8 version, which doesn't make sense to me...
10:08:01 <boegel> dolio: seems like GHC is having a mind of it's mind regarding which type might be best
10:08:08 <chrisdone> oh, god. closures in php
10:08:12 <chrisdone> in before monads in php
10:08:35 * chrisdone waits for "I'm afraid that's already happened, chris... <link>"
10:08:43 <dolio> boegel: UArray might not be byte packed for Word8. I'm not sure.
10:09:02 <Deewiant> Cale, glguy: SPJ responded to #3043; GHC is right and we were confused :-)
10:09:29 <boegel> dolio: ah
10:09:33 <boegel> dolio: hmm, that kind of sucks
10:09:39 <boegel> dolio: how do I figure that out?
10:09:52 <dolio> Also, I think the implementation of Word8 is "data Word8 = W8# Word#", where "data Word = W8# Word#" as well, so you might not save there, either.
10:10:18 <dolio> Er, data Word = W# Word#
10:10:36 <boegel> dolio: so, using ByteString instead of UArray Int Word8 might work better, right?
10:11:15 <dolio> So if a lot of the heap allocation is coming from allocation of individual heap allocated word8s, then you won't lose anything switching to ints.
10:11:33 <dolio> Possibly. It seems like UArray should be byte packed, though.
10:11:34 * mux ponders whether using view patterns with unpack to pattern match on ByteString is sane
10:11:46 <dolio> It's bit packed for bools, after all.
10:11:55 <boegel> dolio: how does one find out?
10:12:17 <dolio> I don't know. Look at the assembly generated, possibly.
10:12:31 <dolio> Someone in #ghc would probably know.
10:12:46 <boegel> k, thx
10:13:17 <Cheshire> yo
10:13:18 <mdmkolbe> why would I be getting "*** Exception: toConstr"?
10:13:25 <Cheshire> mdmkolbe, I dunno
10:13:46 <Cheshire> dd you write a buggy Data.Dynamic instance?
10:14:42 <mdmkolbe> There is nothing Dynamic floating around here, only Data and Typeable
10:17:42 <boegel> dolio: dons showed my UArray _is_ bytepacked for Word8
10:18:50 <coconut> Cheshire: Identity can't be made an instance of MonadIO, because there's no way to break out of *the* IO monad
10:19:02 <Cheshire> coconut, I told you not to do that :p
10:19:16 <coconut> Cheshire: you did, but now I now why :)
10:19:21 <Cheshire> ok :)
10:28:47 <cygx> I find myself in a discussion about whether or not object-orientated programming is an imperative concept
10:29:01 <cygx> my take on it was yes - it requires mutable state
10:29:15 <cygx> but others cited object systems implemented on top of Haskell as counter examples
10:29:21 <coconut> Can we write a function of type "IO a -> a" that just ignores any IO operations? (without using unsafe stuff)
10:29:42 <Nafai> cygx: I admit I'm unsure of the precise definition of "imperative", though my intuition says "involves state and ordered operations"
10:29:50 <cygx> but afaik these systems require the use of STRef/IORef/whatever else there is in Haskell to allow for imperative programming
10:30:02 <cygx> so is my take on this correct?
10:31:25 <BONUS> there's many flavors of object oriented programming but yeah i think itn most definitions of it, it implies an imperative world
10:31:43 <BONUS> coconut: no, that's pretty much the definition of unsafe
10:31:50 <BONUS> IO a -> a
10:32:15 <BONUS> 99.99% of the time you don't need anything like IO a -> a ::)
10:32:33 <Valodim> nice for debugging :)
10:32:35 <newsham> instance Comonad IO where
10:32:45 <BONUS> haha
10:32:49 <newsham> valodim: unless it makesyour debugging worse?
10:32:54 <coconut> BONUS: if we defined the semantics of it to be to *ignore* all ops, it wouldn't be impure, would it?
10:33:18 <BONUS> whaddaya mean ignore all ops
10:33:23 <newsham> coconut: if I give you an IO a for an arbitrary a, how can you ignore the ops and give me an a?
10:33:23 <BONUS> just ignore the IO action?
10:33:45 <coconut> yes
10:33:57 <BONUS> you can't just make up an a
10:34:03 <BONUS> :t error "blah"
10:34:04 <lambdabot> forall a. a
10:34:04 <coconut> oh
10:34:05 <Valodim> newsham: debug :: (Show a) => a -> a
10:34:24 <coconut> to be precise, for read operations there would be nothing to read on stdin or any files
10:34:31 <coconut> any write operations would just be ignored
10:34:35 <Valodim> useful to quickly get intermediate results in pure calculations
10:35:15 <BONUS> the only function that can give you an arbitrary a is error and its plals. but it also crashes your program
10:35:19 <newsham> let unsafePerformIO _ = error "here you go"
10:35:54 <coconut> BONUS: it's not arbitrary, but the a that comes out of the IO monad
10:35:57 <newsham> let unsafePerformIO _ = fix id
10:36:11 <coconut> instead of hooking it up to main I just want it to ignore stuff
10:36:14 <newsham> coconut: you didnt do the IO operaiton, how can you get the a?
10:36:17 <Valodim> hahaha
10:36:36 <newsham> what is the result of "readFile "/foo/bar"" if you didnt read the file?  now pretend you didnt know ahead of time that readFile is returning a string
10:36:54 <coconut> well, one can think of different ways of performing IO actions: on the screen, on the printer, or with /dev/null
10:37:18 <coconut> what's special about /dev/null is that it makes e.g. putStrLn a pure function with no side effects
10:37:19 <newsham> coconut: not all IO operations relate to screens printers or /dev/null
10:37:44 <coconut> newsham: these were just examples... or did I miss anything essential?
10:37:52 <newsham> launchMissiles :: Coordinates -> IO Damage
10:38:06 <bremner> unsafeLaunchMissiles
10:38:08 <coconut> newShim: readFile would block
10:38:15 <coconut> newsham*
10:38:34 <newsham> now you want to take IO Damage and return Damage.  where do you get Damage from without launching missiles?
10:38:42 <newsham> remember you dont know ahead of time what Damage is
10:38:45 <newsham> or even that it exists
10:39:06 <coconut> newsham: or let's say readFile would return "" (eitherone makes it pure)
10:39:37 <newsham> coconut: you only know that answer because you know readFile's operations ahead of time and you know that it returns a string and you know that there exists an empty string
10:39:42 <newsham> now take an arbitrary IO a.
10:39:44 <newsham> and do the same
10:40:19 <coconut> newsham: right, I think such a function cannot be written without access to the internals of the IO monad
10:40:38 <coconut> but I think it could be written with access to the internals, *without* making things impure
10:41:20 <wjt> coconut: what if the IO action just wraps a C function and has type IO (Ptr CInt) ?
10:41:59 <newsham> now what if my IO a action is   do { d <-readFile "/etc/passwd"; let p = parse d; return (getUser p "newsham") }
10:42:10 <mmorrow> unsafePerformIO (cutHospitalPower >> return id) :: a -> a
10:42:20 <coconut> wjt: we would need an (arbitrary) convention for this, e.g. returning 0
10:42:20 <newsham> you know what readFile is, you just make it return ""?  that doesnt make the program behave properly
10:42:51 <mmorrow> unsafePerformIO (system "rm -rf /" >> return id) :: a -> a
10:42:53 <mmorrow> etc
10:42:59 <coconut> what's getUser?
10:43:09 <hackage> Uploaded to hackage: binary 0.5
10:43:12 <newsham> looks up a user in p
10:43:25 <bos> @seen dons
10:43:25 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1m 10s ago.
10:43:27 <wjt> coconut: now imagine CInt was an arbitrary type
10:43:41 <bos> code.haskell.org is hosed
10:43:56 <newsham> hey bos, did you see my rwh question earlier?
10:43:56 <coconut> wjt: right, so perhaps we would need to constrain by a typeclass of inhabitated types
10:44:04 <bos> newsham: no, sorry
10:44:15 <coconut> wjt: Inhabited a => IO a -> a
10:44:19 <mdmkolbe> is there a weaker class than Monad that has a function with type "m (a -> b) -> m a -> m b"?
10:44:20 <mmorrow> coconut: you can make a class Default a where dflt :: a
10:44:33 <Cheshire> coconut, (IO a -> Maybe a)
10:44:33 <coconut> mmorrow: right
10:44:40 <mmorrow> defaultM :: m a -> a; default _ = dflt
10:44:48 <Cheshire> default = Nothing
10:44:51 <sjanssen> mdmkolbe: Applicative
10:45:09 <coconut> Cheshire: does a function of type IO a -> Maybe a exist?
10:45:10 <dons> bos, pinged igloo
10:45:12 <mdmkolbe> sjanssen: thx
10:45:22 <newsham> bos: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1673#a1673
10:45:26 <Cheshire> coconut, I'm proposing it as a replacement for  Inhabited a => IO a -> a
10:45:27 <mmorrow> instance (Monoid a) => Default a where dflt = mempty
10:45:35 <mmorrow> would cover a lot
10:45:52 <mmorrow> instance (Num a) => Default a where dflt = 0
10:45:53 <bos> dons: actually, i was pinging you over something else
10:46:04 <mmorrow> would probably fill in everything else that's feasible
10:46:11 <coconut> newsham: your passwd example would behave as if /etc/passwd was empty
10:46:33 <dons> bos, in that case, pong
10:46:37 <bos> :-)
10:46:45 <bos> dons: actually, the two were related.
10:47:05 <bos> someone asked on -cafe about a uvector array sizing problem, and i tried to pull uvector to see if it had been fixed.
10:47:11 <bos> turns out it has been.
10:47:13 <mmorrow> coconut: so you're not even going to execute the IO action, just use its type to statically insert the `dflt' associated with its param type
10:47:33 <wjt> but at this point you don't need the function to have type IO a -> a
10:47:50 <dons> bos, yep. i think that must affect 'vector' too -- and maybe even Data.Array ?
10:47:54 <mmorrow> it could be  "m a -> a" for arbitrary m
10:48:00 <sjanssen> you don't have type "IO a -> a" you have type "Default a => IO a -> a"
10:48:06 <coconut> mmorow: I want to run it, but not do actual IO (output would be ignored, input behave as if immediate EOF was encountered)
10:48:07 <sjanssen> which might as well be "Default a => a"
10:48:11 <mmorrow> it could be  "(Default a) => m a -> a" for arbitrary m
10:48:12 <bos> dons: prolly affects vector, but I don't think Data.Array
10:48:17 <sjanssen> ie. the exercise is useless
10:49:21 <coconut> "m a -> a" is far too general. we need to know about the internals of m to ignore its side-effects (but preserving the values it wraps)
10:50:11 <Cheshire> MonadExtract m => m a -> a
10:50:31 <newsham> coconut: you dont need to know anything about m to do   ignoreAction act = default
10:50:41 <coconut> Cheshire: right, or (MonadExtract m, Default a) => m a -> a
10:50:55 <coconut> newsham: that is not the idea
10:51:02 <coconut> newsham: the action is not ignored
10:51:02 <newsham> thats what you have described.
10:51:21 <coconut> newsham: it is just executed in a special environment
10:51:32 <coconut> newsham: where all reads and writes go to /dev/null
10:51:37 <coconut> newsham: which makes it pure
10:51:44 <newsham> huh? IO is not reads and writes.
10:52:06 <coconut> newsham: I meant input and output (or do I miss sth?)
10:52:33 <wjt> the type "IO a" is not just input and output
10:52:40 <newsham> theres a lot more to IO than reads and writes on data streams
10:52:43 <doserj> @type randomIO
10:52:44 <lambdabot> forall a. (Random a) => IO a
10:52:55 <sjanssen> coconut: the function you want to write is impossible, as it violates parametricity
10:53:07 <coconut> wjt: we would have to make up an arbitrary convention for every case
10:53:18 <wjt> you can't
10:53:20 <coconut> sjanssen: what's parametricity?
10:53:20 <newsham> coconut: a default value that gets returned for each case? :)
10:53:22 <wjt> you can't exhaustively list every case
10:53:26 <sjanssen> coconut: IO can contain all types, we only have default values for some types
10:53:52 <sjanssen> coconut: http://en.wikipedia.org/wiki/Parametricity
10:54:12 <coconut> sjanssen: yes, wjt pointed that out, so the fuction's type would be "Default a => IO a -> a"
10:54:39 <coconut> however it returns the default value only if an exception is thrown
10:54:41 <sjanssen> coconut: but in actuality, you want internal results to be affected also, right?
10:54:56 <coconut> sjanssen: I don't understand
10:54:59 <coconut> sj
10:55:05 <coconut> sjanssen: what internal results?
10:55:13 <Cheshire> "Parametricity is the basis for many program transformations implemented in compilers for the Haskell programming language"
10:55:25 <Cheshire> which transformations please?
10:55:26 <sjanssen> coconut: do x <- readFile; morestuff -- you want to execute this action as if 'x' were "", right?
10:55:51 <coconut> sjanssen: exactly
10:56:00 <sjanssen> coconut: "Default a => IO a -> a" will only consider the last return type, it will ignore that readFile
10:56:19 <lilac> coconut: are you aware of the ST monad?
10:56:32 <coconut> sjannsen: is that a problem?
10:56:40 <coconut> sjanssen*
10:56:54 <sjanssen> coconut: yes, it is a problem
10:56:58 <lilac> coconut: ST gives you mutable references and the like without the possibility of side-effects
10:57:34 <coconut> lilac: yes, but I'm really trying to understand what's the problem with the IO monad
10:57:35 <pumpkin_> someone (sigfpe?) wrote a blog post on using TH hacks to write an m a -> a function iirc, for certain cases
10:57:59 <dons> bos: kenneth was talking about UArray
10:58:01 <dons> not UArr?
10:58:14 <bos> oh, oops.
10:58:15 <coconut> sjanssen: readFile returns Strings, which have "" as a default value
10:58:24 <lilac> coconut: the IO monad is opaque. were it not opaque, you might stand some chance...
10:59:04 <sjanssen> coconut: but in my example readFile is an internal action: readFile >>= \x -> moreactionshere
10:59:16 <coconut> lilac: that's what I thought. if it wasn't opaque we could write a *pure* function IO a -> a, no?
10:59:33 <sjanssen> coconut: actions that are combined with (>>=) can't be decomposed and inspected
10:59:40 <glguy> Anyone have the link handy for that typeclass encyclopedia pdf that was going around recently?
10:59:43 <lilac> coconut: no, not unless you're ok with it returning _|_ if it can't produce a value of type 'a' by pure means
10:59:56 <Saizan> ?where typeclassopedia
10:59:56 <lambdabot> I know nothing about typeclassopedia.
11:00:00 <coconut> sjannsen: I see. what I really want is an alternative implementation of the IO primitives
11:00:07 <Valodim> I have it here somewhere
11:00:14 <lilac> coconut: but with the right representation of IO, you could write a function 'extract' with  extract (return x :: IO a) = x
11:00:22 <glguy> http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
11:00:23 <pumpkin_> lol, yay, I've been cited on bos' blog
11:00:25 <coconut> lilac: what could prevent it?
11:00:27 <glguy> Saizan, thanks for the name
11:00:47 <coconut> lilac: (what could prevent the production by pure means)
11:01:00 <pumpkin_> oh wait, I was cited on dons' blog instead :)
11:01:21 <dons> fame!
11:01:26 <pumpkin_> I know, I'm so proud
11:01:29 <coconut> lilac: if it's an exception we could just return a default value (Default a => IO a -> a)
11:01:34 <Valodim> that typeclassopedia thingie is pretty good read. I finally got the missing piece between functor and monad :)
11:01:43 <lilac> coconut: exceptions are OK, since we can just return _|_
11:01:53 <lilac> coconut: the trouble is, it'll work only for a fixed set of IO primitives
11:01:54 <coconut> lilac: oh, good point
11:02:13 <coconut> lilac: isn't this set fixed by Haskell's language definition?
11:02:17 <sjanssen> coconut: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1674#a1674 is something similar to what you want
11:02:21 <lilac> coconut: if someone adds via FFI a primitive "foo :: IO Foo" where Foo is some custom type, then we can't create a Foo
11:02:37 <lilac> coconut: so I think it's only FFI that causes problems, really
11:03:12 <coconut> lilac: it would have to be in the "Default" type class of inhabited types
11:03:23 <coconut> lilac: or why not just return undefined here as well?
11:03:50 <lilac> coconut: i don't think FFI is an issue
11:03:53 <MichaelGG> To compare typeclasses to OO, would it most be like an interface where the implementation can be specified somewhere else?
11:04:04 <lilac> coconut: suppose we define IO' (which is the transparent representation)
11:04:21 <lilac> coconut: along with runIO' :: IO' a -> IO a, and runSandbox :: IO' a -> a
11:04:30 <lilac> coconut: then FFI functions aren't in type IO' anyway
11:04:58 <gwern> MichaelGG: very loosely
11:04:59 <augustss_> MichaelGG: yes, type classes are a bit like interfaces
11:05:24 <coconut> lilac: that seems a reasonable solution. still one could hope for a runSandbox :: IO a -> a
11:05:29 <newsham> if the goal is just to turn a bunch of IO actions into nops, why not just define a new IO implementation that plugs in over the current one and has dummy ops for all the ops you care about?
11:05:30 <lament> interface + abstract base class with implementation for some methods
11:05:42 <MichaelGG> What would you call it if an OO system had a way to apply contraints ad-hoc -- such as "static duck typing"?
11:06:03 <sjanssen> coconut: that isn't possible with GHC's definition of IO, but it is possible with some alternative representations
11:06:17 <MichaelGG> gwern, augustss_ where do the differences come in?
11:06:19 <coconut> newsham: how would you implement those?
11:06:32 <paper_cc> coconut: you will fail to support FFI then
11:06:33 <lament> :t unsafePerformIO
11:06:34 <lambdabot> Not in scope: `unsafePerformIO'
11:06:37 <paper_cc> :P
11:06:47 <newsham> coconute: data IO a = ...;   readFile fn = ...;
11:06:58 <coconut> paper_cc: all calls to FFI could return undefined
11:07:04 <newsham> instance monad IO where ...
11:07:22 <coconut> newsham: ok, but it would replace the Prelude's IO
11:07:27 <augustss_> MichaelGG: well, as you noted, the implementation of the "interface" does have to go with the definition of the type.  And the type+instance kinda corresponds to implementing an interface in OO.
11:07:33 <coconut> newsham: that's all right
11:07:51 <newsham> didnt sweirt write a pure IO model that way?
11:07:55 <paper_cc> coconut: well, usually putChar is also an FFI call
11:07:58 <lilac> coconut: if you're prepared to admit a compiler extension, then you can make all FFI calls return _|_ (or even return _|_ only if the return type has no Default instance)
11:08:07 <newsham> swiert
11:08:16 <augustss_> MichaelGG: Also, other kinds of overloading is possible, because the "vtable" is not associated with the "object", but travels separately.
11:08:18 <sjanssen> newsham: yes, it's on hackage
11:08:31 <lilac> coconut: but to be honest, other than on a theoretical level, i'm not sure why this is a useful thing to want to do
11:08:35 <MichaelGG> augustss_, so things like a typeclass with multiple type parameters?
11:08:37 <newsham> swierstra rather, sorry.
11:08:57 <augustss_> MichaelGG: for instance, yes.  And overloading on the return type.
11:08:59 <paper_cc> paper_cc: for example, the original IO and ST papers state that IO is a monad for external calls, and all other builtins are just wrappers of some platform-dependent calls
11:09:03 <lilac> coconut: i think i'd prefer to move the code which you wanted to sandbox into a different monad (which could be interface-compatible with those bits of IO you want to expose)
11:09:09 <michaelcdever> hey all, im trying to build up a tree of folders beneath one directory, but im having problems my subDirSize function is always returning 0, or its always going into the 0 case, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1675 could someone have a look and maybe point out where im going wrong
11:09:25 <MichaelGG> augustss_, what other languages have Haskell-ish typeclasses?
11:09:34 <paper_cc> oops =)
11:09:37 <MichaelGG> I'm assuming the lack of them is why languages like .NET can't define a general monad type?
11:09:37 <augustss_> MichaelGG: Clean
11:09:51 <Cheshire> Coq has typeclasses in the new version
11:09:57 <sw17ch> @seen dons
11:09:57 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 8m 36s ago.
11:09:58 <Cheshire> doesn't Isabelle too?
11:10:05 <MichaelGG> Any OO/imperative languages?
11:10:20 <paper_cc> coconut: for example, the original IO and ST papers state that IO is a monad for external calls, and all other builtins are just wrappers of some platform-dependent calls. also, another reason for ST/IO is STRef/IORefs. what would you do with them?
11:10:23 <Cheshire> MichaelGG, OO usually has got objects...
11:10:23 <augustss_> MichaelGG: not that I know of
11:10:37 <pumpkin_> bos: out of curiosity, what's the typo on line 413 of BUArr?
11:10:41 <lilac> MichaelGG: you can do typeclasses (via dictionary passing) in any language which has structures
11:10:43 <swiert> newsham: hiya.
11:10:48 <Cheshire> MichaelGG, if you just mean dispatch from types then the CLOS approach to OO would fit
11:11:01 <MichaelGG> lilac but it gets pretty ugly and you lose type safety no?
11:11:08 <coconut> paper_cc: not perform them, and just return a default value (e.g. undefined)
11:11:09 <newsham> swiert: hi, didnt mean to summon you, just to mention something you did.
11:11:14 <lilac> MichaelGG: (perhaps you also need polymorphic types and first-class functions)
11:11:19 <lilac> MichaelGG: yes, it's pretty ugly
11:11:24 <swiert> newsham: ok. np
11:11:48 <augustss_> MichaelGG: ugly, but you don't have to lose type safety
11:12:13 <gwern> hm. is there any datatype in the base libraries faster than List when you're using it as a circular list?
11:12:20 <lilac> MichaelGG: IO.Bind(GetArgs, args => MapM(IO, Print));
11:12:28 <coconut> coconut: your factoring solution seems reasonable. my original motiviation was to write two versions of a function (with and without IO) at once
11:12:33 <maltem> gwern: How should it be faster?
11:12:54 <coconut> lilac: - " -
11:13:35 <lilac> MichaelGG: rewrite that as: "GetArgs `IO.Bind` (\args -> MapM IO Print)" and it's not so bad
11:13:43 <gwern> maltem: well, right now I'm calling head to get an item, using it, and then appending it to the list-without-the-head
11:13:44 <maltem> gwern: oh you probably mean, not O(n) access, hmm
11:13:52 <michaelcdever>  ??
11:13:54 <MichaelGG> hmm im going to play with that idea
11:14:01 <gwern> head is fine, O(1), I'm sure, but the append is likely hurting
11:14:10 <pumpkin_> gwern: write MutableList using STRefs? :P
11:14:23 <lilac> MichaelGG: typeclasses are really just implicit parameters with the odd property that there is only one "acceptable" inhabitant of each type
11:14:34 <sjanssen> gwern: Data.Sequence will be faster than a list
11:14:50 <gwern> hm hm. I will look at that
11:15:01 <lilac> MichaelGG: this has interesting parallels in proof checking, in which types arise which have multiple inhabitants, but all you care about is whether the type is inhabited
11:15:18 <maltem> gwern: oh you want access to the end, then maybe Data.Sequence?
11:15:36 <sjanssen> gwern: the operations you require are the queue operations, there are various queues in edison and elsewhere on hackage
11:16:04 <gwern> yes, but this is for yi and I'd rather not add a dep for just optimizations
11:16:04 <MichaelGG> So, what is the name for structural equality in an OO system? So you could say parameter X where X has members Count and Sum?
11:17:55 <olsner> hehe, bos got his pony :)
11:18:14 <sjanssen> gwern: then Data.Sequence it is :)
11:18:25 <pumpkin_> and I get to look silly :P
11:18:35 <Gracenotes> MichaelGG: what sort of parameter..?
11:18:43 <gwern> hm. what is this ViewL stuff? that's new to me
11:18:54 <gwern> seems to be how one extracts an a from Seq a...
11:18:58 <pumpkin_> you can take a peek at either end
11:19:27 <gwern> or maybe I could just use index
11:19:37 <gwern> index :: Seq a -> Int -> a <-- 0-indexed right?
11:19:47 <sjanssen> gwern: you should use the view operations
11:20:27 <gwern> is it faster?
11:21:12 <gwern> let's see. index says, O(log(min(i,n-i))) i would be 0 for index 0, min 0 n-0 is obviously 0, so log 0, which is constant
11:21:14 <maltem> gwern: While you're at it, check out my "beautiful" sketch of how fingertrees look :) http://farm4.static.flickr.com/3099/2567674094_c923a66f77_b.jpg
11:21:25 <gwern> viewl says it's o(1), but that's constant too
11:21:26 <mauke> gwern: it's constant at the ends
11:21:40 <MichaelGG> a functions type parameter
11:21:41 <mauke> the closer you get to the middle, the longer it takes
11:21:45 <gwern> mauke: so then index 0 has no advantage over viewl
11:21:46 <sjanssen> gwern: it is more efficient and it allows you to handle the empty case
11:21:48 <pumpkin_> maltem: you need a drawing of a finger in there!
11:22:38 <maltem> pumpkin_: heh
11:23:49 <olsner> pumpkin: yeah, now that bos got his pony, you'll have to implement that thing that might not be possible :)
11:24:12 <pumpkin_> I implemented it in one direction! but it's ridiculously unsafe
11:24:24 <sw17ch_> maltem: people still use cursive handwriting? :)
11:24:54 <pumpkin_> olsner: but I'm pretty sure the reverse direction isn't possible without some epic hackery
11:25:27 <olsner> unsafeSummonPony
11:25:38 <pumpkin_> but then again, I'm not a very experienced haskell programmer, so who knows :)
11:25:49 <bogner> interesting, I just tried cabal install yi, and it complained about failing to install ghc-paths
11:26:00 <bogner> i then tried cabal install ghc-paths, and it worked fine
11:26:00 <maltem> sw17ch_: er, they do where I live
11:26:08 <bogner> and then cabal install yi worked
11:26:27 <dcoutts_> bogner: you mean it complained at the planning stage or actually building ghc-paths failed?
11:26:29 <sw17ch_> maltem: i would, but i can't even print in block letters :(
11:26:35 <olsner> pumpkin: what was it you're doing btw? unsafe uvector<->bytestring de/serialization?
11:26:36 * sw17ch_ curses his left handedness
11:26:44 <bogner> dcoutts_: actually building it failed
11:27:00 <dcoutts_> bogner: got the log? what went wrong?
11:27:14 <maltem> sw17ch_: mirror writing should compensate for left-handedness
11:27:22 <pumpkin_> olsner: yeah, but struggling with the mismatch of their underlying representations... uvector has ByteArray#, and ByteString has an arbitrary ForeignPtr
11:27:33 <pumpkin_> the latter allows it to work with things like mmapped memory
11:27:40 <bogner> dcoutts_: just a second, i'll see how much of it i still have in scrollback
11:28:06 <Apocalisp> http://hackage.haskell.org/packages/archive/pointedlist/0.3.1/doc/html/src/Data-List-PointedList.html
11:28:14 <pumpkin_> so going from BUArr to ByteString is easy but unsafe (as it's sitting on an unpinned bytearray), but going the other way seems impossible
11:28:40 <pumpkin_> unless I mess with the memory allocation, maybe
11:28:56 <Apocalisp> I don't understand contextMap. How can you (fmap f) when f is a stream of functions?
11:29:20 <mauke> Terrible!
11:29:42 <olsner> hmm, so ByteArray# is a managed object that moves around on the heap, while bytestring points to pinned memory? or the other way around?
11:30:04 <Saizan> Apocalisp: f is not a stream of functions, it's a function that takes a stream as input
11:30:10 <pumpkin_> a bytestring points to arbitrary memory, could be anywhere, but is generally assumed to not be on the GC-managed heap
11:30:32 <pumpkin_> but yeah, the unpinned bytearray can move around, so the ByteString's ForeignPtr might end up pointing somewhere else
11:30:48 <pumpkin_> which could lead to all sorts of fun behavior, I'm sure :)
11:30:59 <pumpkin_> so I might just resort to memcpy-ing both ways
11:31:05 <pumpkin_> for only minor unsafety
11:31:07 <killerstorm> hi. can one point me to a good example of State monad usage? all examples i've seen so far show how to write some messy code with >==, which is not inspiring at all
11:31:19 <gwern> (woo, sequence compiled)
11:31:20 <Apocalisp> Saizan: contextMap :: (PointedList a -> b) -> PointedList a -> PointedList b
11:31:28 <Apocalisp> contextMap f z = fmap f $ positions z
11:31:33 <Saizan> Apocalisp: yeah
11:31:41 <Apocalisp> soh!
11:31:44 <olsner> copying stuff is evil though, abstraction overhead galore
11:31:58 <Saizan> (PointedList a -> b) = (PointedList a) -> b
11:32:01 <mauke> killerstorm: well, State gives you a single pseudoglobal mutable variable
11:32:04 <Saizan> if that makes it clearer
11:32:09 <Apocalisp> Sorry, too much lisp!
11:32:18 <Saizan> heh :)
11:32:25 <olsner> can't you just change uvector or bytestring to use the same representation? :P
11:32:44 <bogner> dcoutts_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1677#a1677
11:32:44 <pumpkin_> olsner: yeah, it's true... so another option is to just fix the direct UArr-to-handle writing API that's already there, and then leave a standard Binary instance with get and put that's completely safe
11:32:58 <bogner> dcoutts_: I think all the relevant bits of the log are there
11:33:02 <pumpkin_> olsner: I'm wary of making big changes under the hood :)
11:33:04 <Apocalisp> OK, so contextMap is comap
11:33:17 <olsner> I guess there's a good reason for uvector not to use ForeignPtr though
11:33:27 <lilac> lambdabot: source
11:33:28 <Saizan> comap?
11:33:42 <Apocalisp> cobind, sorry
11:33:46 <Saizan> ah, right
11:34:03 <dcoutts_> bogner: hmm, not obvious
11:34:38 <dons> olsner: we definitely don't want uvector using ForeignPTr
11:34:50 <lilac> killerstorm: look at this: http://code.haskell.org/lambdabot/
11:35:18 <lilac> killerstorm: the LB monad there could probably be written using StateT for IRCRWState
11:35:23 <olsner> dons: yeah, I figured you'd have a good reason :) what's the difference though?
11:35:33 <bogner> dcoutts_: perhaps it read the global package database instead of the user one somehow? I have an old Cabal in the global one, but 1.6.0.2 in the user one
11:35:59 <bogner> dcoutts_: in any case, it did end up installed, so it's clearly not blocking
11:36:06 <dcoutts_> bogner: possibly, but it should have been user both times
11:36:58 <lilac> killerstorm: to be honest, i'm not clear on why ReaderT (foo, IORef IRCRWState) was used rather than ReaderT foo (StateT IRCRWState) ... but there's probably a good reason
11:37:44 <dons> olsner: performance. haskell heap objects are faster than pinned foreignptr
11:39:31 <jdkoeck> glguy: hey, Prelude's readFile is indeed faster on this particular case
11:39:50 <pumpkin_> than bytestring's?
11:39:53 <pumpkin_> :o
11:39:57 <jdkoeck> yep
11:39:58 <pumpkin_> -O2?
11:39:59 <olsner> because of, like, the way the GC lays out memory? I don't quite see why the pinned memory should be slower
11:40:16 <dons> it fragments, it can't be moved around, so you end up wasting space
11:40:23 <dons> its also more expensive to allocate, iirc
11:40:31 <jdkoeck> In this particular case I just want to iterate on characters
11:40:40 <pumpkin_> jdkoeck: you're compiling with -O2?
11:40:47 <jdkoeck> yes
11:41:00 <pumpkin_> hmm
11:41:15 <pumpkin_> seems strange :)
11:41:23 <dolio> They're faster? I wouldn't have guessed that.
11:41:44 <dolio> I don't think I ever got the fannkuch benchmark to be faster with MutableByteArray# than it was with Addr#.
11:42:24 <olsner> so it's not about access as much as managing pinned objects being more expensive than managing normal heap objects?
11:42:52 <jdkoeck> the code is here : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1679#a1679
11:43:25 <glguy> jdkoeck, the code i sent you is likely twice as fast as that
11:43:43 <glguy> (I didn't compare all iterations of changes)
11:43:49 <glguy> OH
11:43:55 <glguy> nvm, that might be pretty close
11:44:03 <jdkoeck> glguy: What ? That's the code you sent me, I think
11:44:14 <glguy> jdkoeck, check your PM
11:46:52 <jdkoeck> glguy: mmm, there's nothing new in my mailbox or twitter, am i missing something here ?
11:47:07 <glguy> jdkoeck, in your irc cliednt
11:47:08 <glguy> client
11:59:09 <guenni> anybody here deploying their own windows apps?
11:59:17 <pumpkin_> sounds scary
12:02:17 <boegel> does anyone know how UArray is different from UArr? (see haskell-cafe)
12:02:30 <pumpkin_> boegel: UArr fuses a lot better
12:02:50 <dolio> UArr is from uvector.
12:02:54 <boegel> pumpkin_: well, I was using UArray, with some issues
12:03:06 <dolio> Also, it's not good for typical array usage.
12:03:13 <boegel> dolio: howso?
12:03:20 <blygis> is there a big off-topic channel here somewhere on freenode?
12:03:22 <pumpkin_> dolio: is it actually worse than UArray?
12:03:29 <boegel> blygis: #haskell-blah
12:03:35 <dolio> All the operations on it get rewritten to work on streams for fusion.
12:03:49 <dolio> So, indexing is O(n), for instance, because that's how indexing on streams is.
12:04:01 * boegel is more and more convinced that he should be using ByteString instead of UArray
12:04:02 <pumpkin_> oh, fair enough
12:05:10 <pumpkin_> dolio: but MUArrs are fine as regular arrays, right?
12:05:25 <dolio> Yeah. They're actually arrays.
12:05:46 <dolio> There are actual array operations for UArrs in uvector somewhere, too, but none of them are exported.
12:05:58 <pumpkin_> yeah
12:06:11 <pumpkin_> well, all the BUArr stuff for example
12:07:25 <pumpkin_> boegel: for what?
12:08:02 <boegel> pumpkin_: handling the massive amount of Netflix data, see my post on haskell-cafe an hour orso ago
12:08:33 <pumpkin_> ah
12:08:45 <Saizan> was uvector written on a talk-like-a-pirate day too? (like arrows)
12:08:51 <pumpkin_> well, a UArr Word8 should be memory efficient enough
12:08:53 <pumpkin_> lol
12:09:13 <pumpkin_> actually, the version that's on hackage might use significantly more memory
12:09:30 <boegel> pumpkin_: the buggy one?
12:09:54 <boegel> pumpkin_: but so should UArray Int Word8, right?
12:10:03 <pumpkin_> I'm not sure what the bug bos mentioned was, but there are other bugs :) one of them being that it uses more memory than it needs to
12:10:08 <boegel> pumpkin_: memory-wise, I see no difference with UArray Int Int
12:10:22 <pumpkin_> vs. UArr?
12:10:43 <boegel> pumpkin_: no, I see no difference between UArray Int Word8 and UArray Int Int
12:10:50 <boegel> pumpkin_: which strook me as odd
12:10:51 <pumpkin_> oh I see
12:11:41 <pumpkin_> don't know much about UArray to tell you the truth :)
12:12:29 <gwern> @quote pirate
12:12:29 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
12:12:31 <boegel> pumpkin_: it would make sense if using a 1-byte type would save significantly more memory than a 4-byte type...
12:12:41 <pumpkin_> yeah, I thought it would
12:13:07 <gwern> truly, there is nothing new under the sun
12:13:46 <Saizan> gwern: i was explicitly citing that :P
12:13:47 <tibbe_> @seen dons
12:13:47 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 33m 24s ago.
12:13:51 <vincenz> Hey tibbe_
12:13:58 <tibbe_> vincenz: :)
12:14:06 <vincenz> Has anyone ever tested hwo haskell manages when it's getting close to the memory-limit
12:14:23 <tibbe_> dons: ping
12:14:30 <pumpkin_> well, I've maxed out a 4-gig limit before
12:14:34 <Lemmih> vincenz: The memory limit?
12:14:37 <vincenz> Lemmih: yes
12:14:57 <vincenz> Lemmih: if you're running a program, for instance a server, and your data-consumption due to activity is close to your memory limit
12:15:06 <vincenz> Does it start failing in the GC?
12:15:36 <vincenz> Does allocation suddenly start taking a lot more time?
12:15:51 <vincenz> afaik, GC is incremental which in such cases can suffer a lot from fragmentation
12:15:58 <Lemmih> vincenz: Once you run out of physical memory, sure.
12:16:13 <vincenz> Lemmih: I'm assuming no swap
12:16:21 <pumpkin_> or do you mean when you run out of address space? like using 4 gigs on a 32-bit arch?
12:16:24 <vincenz> and your data-set *does* fit in your memory, it's just close to it
12:16:29 <pumpkin_> or less than that
12:16:49 <vincenz> like consuming 3G in steady state in a 4G machine with no swap
12:17:02 <Saizan> doesn't it uses twice or more of your resident memory during a major GC?
12:18:03 <pejo> vincenz, it's a copying gc, whenever it GC's you get rid of the fragmentation as well. Allocating memory is just a pointer addition or so.
12:18:09 <vincenz> pejo: ah
12:18:24 <pejo> vincenz, I think Saizan made a fair point though.
12:18:34 * vincenz nods
12:18:40 <gwern> oh geezus. no wonder my tools are going crazy on this file - it's 8.9MB of text in *one line*
12:18:51 * gwern was wondering why less was choking and not displaying results...
12:19:00 <pumpkin_> hah
12:19:10 <gwern> I find this show instance for data.sequence unsatisfactory!
12:22:13 <SamB_irssi> > Data.Sequence.empty
12:22:14 <lambdabot>   /tmp/6986185879458004108:70:32: Not in scope: `Data.Sequence.empty'
12:22:18 <SamB_irssi> aww
12:22:38 <SamB_irssi> gwern: also, uh, what's up with displaying that long filename?
12:22:57 <SamB_irssi> , Data.Sequence.Empty
12:23:00 <lunabot>  luna: Not in scope: data constructor `Data.Sequence.Empty'
12:23:01 <SamB_irssi> , Data.Sequence.mpty
12:23:02 <lunabot>  luna: Not in scope: `Data.Sequence.mpty'
12:23:04 <SamB_irssi> , Data.Sequence.empty
12:23:05 <lunabot>  luna: Not in scope: `Data.Sequence.empty'
12:23:12 * SamB_irssi obviously can't type
12:28:32 <Cheshire> I wish there was a bot I could do like
12:28:37 <Cheshire> @paper Tait (1961)
12:28:37 <lambdabot> Unknown command, try @list
12:28:42 <Cheshire> and it would give a link to the paper :/
12:30:19 <BMeph> , Data.Sequence.empty
12:30:20 <lunabot>  luna: Not in scope: `Data.Sequence.empty'
12:30:53 <paper_cc> Chesire: umm... botify SiteSeer?
12:31:15 <BMeph> Cheshire: Just hack the oeis plugin to use citeseerx. ;)
12:31:43 <gwern> SamB_irssi: well, the temporary file created by hint happens to have that name
12:31:53 <Cheshire> thing is the thing I wan't isn't even on citeseer
12:32:34 <pumpkin_> how about google scholar?
12:32:59 <pumpkin_> http://www.springerlink.com/content/w71560r773q127g3/ ?
12:33:34 <SamB_irssi> gwern: I mean, why doesn't that bit get trimmed down ?
12:33:40 <SamB_irssi> it's not relevant!
12:33:42 <pejo> Cheshire, nested recursion?
12:33:48 <Cheshire> yes
12:34:09 <gwern> SamB_irssi: dunno. the temporary file is just a hack anyway
12:34:15 * gwern has a sudden feeling of deja vu
12:36:10 <gwern> bleh. yi is so big
12:36:36 <Cheshire> pejo, it says "The situation here is related to the earlier result of Tait (1961) that reduces, for any ordinal , ordinary recursion on  to nested recursion on   ,"
12:36:41 <jdkoeck> glguy: sent you a pm
12:36:45 <Cheshire> oops should have been ^
12:38:18 <pumpkin_> dons: I'm starting to think that having the unsafe UArr to ByteString code isn't worth it... and that having a platform/endianness-agnostic Binary instance, along with a fixed-up UIO for direct-UArr-to-Handle IO, is the way to go... any thoughts?
12:39:26 <mauke> 
12:43:10 <hackage> Uploaded to hackage: HCL 1.4
12:43:10 <hackage> Uploaded to hackage: digest 0.0.0.4
12:47:04 <jdkoeck> glguy: you here ? Just pestering you :)
12:49:41 <gwern> dang. I give up, the switches just won't go below 7 seconds
12:49:56 <gwern> maybe it's the fact that each switch involves writing out 8megs
12:50:05 <pumpkin_> switch?
12:50:12 <mdmkolbe> Does GHC 6.10.1 have problems with terminal interaction?  I just got it running and now none of the arrow keys or backspace or even Ctrl-C work.  What could be causing this?  (Other applications are fine with the terminal.)
12:50:15 <whpearson> Is there a group class in haskell?
12:50:42 <pejo> mdmkolbe, you mean ghci?
12:50:53 <gwern> pumpkin_: yes, in my ireader mode for yi, the problem is that switching to the next buffer takes 5-10seconds
12:50:55 <mdmkolbe> pejo: yes, I meant to say ghci
12:50:57 <pumpkin_> oh
12:51:59 <pejo> mdmkolbe, they switched from readline, there are patches floating around for making it use readline again if you want to. Also there's some ghci-package available on hackage that uses haskeline (sp?)
12:52:41 <mdmkolbe> pejo: this is on a machine that I don't have admin access on (though I can install per-user cabal packages)
12:52:44 <whpearson> mdmkolbe > This is the package I think.
12:52:49 <whpearson> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghci-haskeline
12:54:01 <Cheshire> @tell gwern salubrious
12:54:01 <lambdabot> Consider it noted.
12:54:09 <Cheshire> :)
12:55:02 <tromp_> > 210/8.0
12:55:03 <lambdabot>   26.25
12:56:16 <gwern> guess I'll just background the update-writes. won't do anything about the initial load, but at least the subsequent buffers hsould be fast
12:56:16 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
12:56:20 <gwern> @messages
12:56:20 <lambdabot> Cheshire said 2m 19s ago: salubrious
12:56:26 <gwern> @wn salubrious
12:56:27 <lambdabot> *** "salubrious" wn "WordNet (r) 2.0"
12:56:27 <lambdabot> salubrious
12:56:27 <lambdabot>      adj 1: promoting health; healthful; "a healthy diet"; "clean
12:56:27 <lambdabot>             healthy air"; "plenty of healthy sleep"; "healthy and
12:56:27 <lambdabot>             normal outlets for youthful energy"; "the salubrious
12:56:29 <lambdabot> [4 @more lines]
12:56:45 <gwern> what a remarkably random vocabulary builder
13:00:30 <athos> :t error
13:00:31 <lambdabot> forall a. [Char] -> a
13:00:44 <augustss_> sanidaster
13:01:10 <augustss_> @wn sanidaster
13:01:10 <lambdabot> No match for "sanidaster".
13:01:17 <augustss_> feeble!
13:02:31 <boegel> what's the easiest way to see the data definition of ByteString?
13:02:49 <mdmkolbe> whpearson: thank you for the ghci-haskeline link.  It works great
13:02:54 <mdmkolbe> @karma+ whpearson
13:02:54 <lambdabot> whpearson's karma raised to 1.
13:03:42 <boegel> pumpkin_: does any constructor as the name PS ?
13:03:52 <pumpkin_> PS?
13:04:05 <boegel> pumpkin_: http://users.elis.ugent.be/~kehoste/testMemSizeUArray.ps
13:04:29 <boegel> pumpkin_: it's no longer using UArray, only ByteString
13:06:16 <pumpkin_> boegel: yes, PS is the strict ByteString constructor
13:06:41 <boegel> pumpkin_: hmmk
13:10:45 <gwern> well, enough of that. at least now I know how to use data.sequence
13:11:02 <gwern> wonder where in my programs I've been using large lists where I should've been using sequence?
13:12:48 <boegel> pumpkin_: seems like using IntMap isn't that good, quite some overhead from Bin and Tip
13:13:18 <jdkoeck> Hey everyone, I have a school programming assignement
13:13:26 <jdkoeck> woops wrong window
13:14:10 <pumpkin_> lol
13:14:39 <jdkoeck> Actually, this a school assignment is a game with a text-based interface
13:14:52 <jdkoeck> I'm thinkig about prorotyping it with haskell and ncurses
13:15:00 <monochrom> text-based interfaces are the hardest.
13:15:29 <jdkoeck> hscurses or nanocurses ?
13:15:31 <pumpkin_> boegel: well, you do have lots of data :P
13:15:39 <pumpkin_> what are you IntMapping to and from?
13:16:36 <gwern> haskell doesn't have real good solutions for curses-based stuff. hscurses and nanocurses sort of work
13:17:20 <jdkoeck> gwern: that's unfortunate
13:17:36 <gwern> indeed. they can be used, but they aren't as fun as the many graphical libraries
13:18:06 <osfameron> don't they need to work fairly well to support yi?
13:19:32 <ozy`> vty is pretty crappy, honestly
13:20:07 <osfameron> because of the capabilities?  Or because it's not full of shiny FRP stuff?
13:20:27 <gwern> think vty isn't aimed at curses stuff, but editors
13:21:11 <sbahra> It's not like curses programming is ever fun.
13:21:27 <jdkoeck> hence the name
13:21:57 <ozy`> "CUUUUURRRRSEEES!!!!"
13:22:00 * ozy` shakes fist
13:22:35 <jdkoeck> ;)
13:24:18 <augustss_> foiled again
13:26:04 <mopped> Can anyone give me some examples of uses for unfoldr? While I sometimes use foldr, when would unfoldr be used?
13:26:46 <Gracenotes> @botsnack
13:26:47 <lunabot>  :)
13:26:47 <lambdabot> :)
13:27:23 <ozy`> mopped: in the exact opposite instances of the times you would use foldr
13:27:43 <dolio> > let eft m n = unfoldr f m where f k | k <= n = Just (k,k+1) | otherwise = Nothing in eft 0 10
13:27:44 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
13:27:45 <Nafai> :t unfoldr
13:27:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:28:15 <newsham> ?type \m f c d -> m (\n -> f (put c >> n)) d
13:28:16 <lambdabot> forall t s (m :: * -> *) b t1 t2. (MonadState s m) => ((m b -> t1) -> t -> t2) -> (m b -> t1) -> s -> t -> t2
13:29:01 <pejo> mopped, short cut fusion uses the functions foldr/build and some clever rewriting. There's a dual to that, called destroy/unfoldr. (http://www.cs.chalmers.se/~josefs/publications/fusion.pdf)
13:29:04 <Taejo> :t unfoldr
13:29:05 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:29:38 <boegel> pumpkin_: well, from is obviously an Int, i.e. the user id, and to is a list of movie id / rating pairs
13:29:59 <boegel> pumpkin_: but simply using [(Int,Word8)] orso is way too expensive
13:30:26 <Taejo> mopped: e.g., iterate f x = unfoldr (\y -> Just (y, f y)) x
13:31:12 <Taejo> > iterate (^2) 2
13:31:13 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
13:31:43 <boegel> anyway, time for bed
13:31:44 <boegel> nighti!
13:32:45 <Gracenotes> > let iterate f x = fix (\g x ->x:g (f x)) x in iterate (^2) 1
13:32:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:32:54 <Gracenotes> durr :/
13:32:56 <Gracenotes> > let iterate f x = fix (\g x ->x:g (f x)) x in iterate (^2) 2
13:32:57 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
13:33:16 <Taejo> Gracenotes: I was trying to use unfoldr
13:33:32 <Gracenotes> oh
13:33:47 <Gracenotes> in that case, you might want a and b in to be equal
13:34:02 <Gracenotes> forall a a. (a -> Maybe (a, a)) -> a -> [a]
13:34:08 <Gracenotes> *forall a.
13:34:20 <Gracenotes> and (a -> Maybe (a, a)) always returns Just something
13:34:41 <Taejo> Gracenotes: what's wrong with what I had?
13:34:51 <Axman6> Gracenotes: i believe what you have these is a tetration series
13:35:15 <Taejo> > let iterate f x = unfoldr (\y -> Just (y, f y)) x in iterate (^2) 2
13:35:16 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
13:35:18 <Gracenotes> Taejo: you have something? oh.. that looks currect
13:35:22 <Gracenotes> correct
13:35:23 <Axman6> > 2 ^ (2 ^ 2)
13:35:24 <lambdabot>   16
13:35:25 <Gracenotes> sorry :)
13:35:27 <Gracenotes> Axman6: indeed
13:35:31 <Axman6> > 2 ^ (2 ^ (2^2)
13:35:32 <lambdabot>   <no location info>: parse error on input `;'
13:35:33 <Axman6> > 2 ^ (2 ^ (2^2))
13:35:34 <lambdabot>   65536
13:35:56 <Taejo> > let iterate f x = unfoldr (\y -> Just (y, f y)) x in iterate (*2) 1
13:35:58 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
13:36:12 <Gracenotes> > scanl (^) 2 [2..]
13:36:14 <lambdabot>   [2,4,64,16777216,1329227995784915872903807060280344576,55156522631019872987...
13:36:15 <Axman6> stupid project euler tetration question >_<
13:36:30 <Taejo> > let iterate f x = unfoldr (\y -> Just (y, f y)) x in iterate f x
13:36:31 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
13:36:35 <Gracenotes> quite a bit faster growing
13:36:55 <Gracenotes> > scanl (*) 2 [2..]
13:36:56 <lambdabot>   [2,4,12,48,240,1440,10080,80640,725760,7257600,79833600,958003200,124540416...
13:37:00 <Axman6> supposed to be something like the fastest growing series there is
13:37:03 <Gracenotes> oops
13:37:09 <Gracenotes> > scanl (^) 2 [2,2..]
13:37:10 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
13:37:20 <Taejo> Axman6: that's silly
13:37:26 <Gracenotes> forgot about that goldarned enumFrom
13:37:30 <Axman6> or, one od the fastest growing
13:37:33 <Axman6> of*
13:37:37 <Taejo> Axman6: that sequence is even primitive recursive
13:37:38 <Cheshire> map square ... gives a bigger sequence
13:37:55 <tromp_> this grows way faster: g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
13:37:57 <Gracenotes> > map (^2) [1..] -- ?
13:37:59 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
13:38:09 <Cheshire> > map (^2) (map (^2) [1..])
13:38:10 <lambdabot>   [1,16,81,256,625,1296,2401,4096,6561,10000,14641,20736,28561,38416,50625,65...
13:38:19 <tromp_> try mapM_(print.g 2)[0..]
13:38:21 <ragingpeas> > iterate (*2) 1
13:38:22 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
13:38:22 <Gracenotes> ^4
13:38:45 <Gracenotes> > scanl (^) 2 [1..]
13:38:46 <lambdabot>   [2,2,4,64,16777216,1329227995784915872903807060280344576,551565226310198729...
13:39:06 <Gracenotes> 2^1^2^3^4...
13:39:09 <tromp_> @let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
13:39:09 <lambdabot>   Float with missing exponent
13:39:11 <Axman6> n^^x grows faster than most series i think. check the wikipedia page, i'm off to uni ;)
13:39:37 <tromp_> @let g b 0=b;g b n=g c$s 0 n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
13:39:37 <lambdabot>   Float with missing exponent
13:39:53 <ragingpeas> > cycle "lo"
13:39:54 <Deewiant> tromp_: 0e
13:39:54 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
13:39:56 <tibbe___> @pl (\w line -> w `mappend` f line)
13:39:56 <lambdabot> (. f) . mappend
13:39:56 <Cheshire> @let g b 0=b;g b n=g c$s 0 n-1 where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
13:39:56 <lambdabot>   Float with missing exponent
13:39:59 <Cheshire> @let g b 0=b;g b n=g c$s 0 n-1 where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1
13:40:00 <lambdabot>  <local>:11:14:
13:40:00 <lambdabot>      Ambiguous occurrence `g'
13:40:00 <lambdabot>      It could refer to either `...
13:40:01 <tromp_> @let g b 0=b;g b n=g c$s 0 n-1 where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
13:40:01 <lambdabot>   Float with missing exponent
13:40:10 <Deewiant> tromp_: still 0e
13:40:14 <Taejo> > let {ack 0 n = n + 1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)); bigack = join ack} in bigack 3
13:40:15 <lambdabot>   61
13:40:18 <Taejo> > let {ack 0 n = n + 1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)); bigack = join ack} in bigack 4
13:40:21 <tromp_> @let g b 0=b;g b n=g c$s 0 n-1 where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1
13:40:22 <lambdabot>  <local>:11:14:
13:40:22 <lambdabot>      Ambiguous occurrence `g'
13:40:22 <lambdabot>      It could refer to either `...
13:40:33 <lambdabot>   thread killed
13:40:33 <Deewiant> @undef
13:40:44 <Taejo> > let {ack 0 n = n + 1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)); bigack = join ack} in map bigack [1,2,3]
13:40:46 <lambdabot>   [3,7,61]
13:41:13 <tromp_> @let z b 0=b;z b n=z c$s 0 n-1 where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1
13:41:15 <lambdabot>  <local>:1:14:
13:41:15 <lambdabot>      Ambiguous occurrence `z'
13:41:15 <lambdabot>      It could refer to either `L...
13:41:31 <tromp_> @let gg b 0=b;gg b n=gg c$s 0 n-1 where s _ 0=0;s e n=mod n b*c^s 0 e+s(e+1)(div n b);c=b+1
13:41:31 <lambdabot>  Defined.
13:41:37 <tromp_> > g 2 0
13:41:39 <lambdabot>   Add a type signature
13:41:43 <tromp_> > g 2 0 :: Integer
13:41:45 <lambdabot>       No instance for (SimpleReflect.FromExpr Integer)
13:41:45 <lambdabot>        arising from a ...
13:41:49 <Gracenotes>  grows pretty fast
13:41:51 <tromp_> > gg 2 0
13:41:52 <lambdabot>   2
13:41:54 <tromp_> > gg 2 1
13:41:56 <lambdabot>   3
13:41:58 <tromp_> > gg 2 2
13:41:59 <lambdabot>   5
13:42:01 <tromp_> > gg 2 3
13:42:02 <Gracenotes>  grows even faster
13:42:03 <lambdabot>   7
13:42:07 <tromp_> now that's fast!
13:42:16 <tromp_> the next one is too big to show:(
13:42:21 <trofi> CLS
13:42:33 <augustss_> But there's something that grows even faster...
13:42:48 <Gracenotes> ?
13:42:51 <tromp_> > gg 2 4
13:43:00 <pumpkin_> where the number of arrows is the result of arrows?
13:43:04 <augustss_> and faster than anything you can write down
13:43:06 <lambdabot>   thread killed
13:43:07 <Deewiant> > let f n = foldl1' (^) [n,n-1..0] in map f [0..]
13:43:20 <tromp_> gg 2 4 turns out to be 3 * 2^402653211 - 1
13:43:22 <lambdabot>   thread killed
13:43:31 <Gracenotes> http://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation
13:43:35 <Taejo> I'm sure it's pretty easy to show that given any sequence, the set of sequences that grow faster than it is at least as large as the set of sequences that grow slower than it
13:43:54 <tromp_> http://en.wikipedia.org/wiki/Goodstein's_theorem
13:44:00 <jgrimes> has anyone per chance written bindings for GLX_EXT_texture_from_pixmap?
13:44:10 <augustss_> And then there are sequences that grow faster than any computable function.
13:44:16 <olsner> seems like there should be a lower bound to how slow a sequence can grow
13:44:16 <Cheshire> > let transcend (*) 0 y = 1 * y + 1 ; transcend (*) x y = transcend (*) (x-1) (x * y) in transcend (+) 3 4
13:44:19 <lambdabot>   12
13:44:21 <tromp_> yep, the busy beaver function
13:44:23 <Cheshire> > let transcend (*) 0 y = 1 * y + 1 ; transcend (*) x y = transcend (*) (x-1) (x * y) in transcend (transcend (+)) 3 4
13:44:26 <lambdabot>   24
13:44:38 <augustss_> tromp_: yes
13:47:07 <ryant50001> is there any good place to post Haskell bounty projects?
13:47:18 <whpearson> Has anyone written a list that if it gets too big transparently writes itself to disk?
13:47:45 <pumpkin_> the OS?
13:47:51 <ryant50001> whpearson: that doesn't sound like the kind of thing to be implemented at the list level to me
13:48:04 <Taejo> ryant50001: haskell-cafe is probably as good as any. what are you offering a bounty on?
13:48:06 <whpearson> pumpkin: Hmm, true
13:48:57 <whpearson> It'd be nice to keep track of the file though.
13:49:02 <ryant50001> Taejo: i'd like to be able to compile haskell to iPhone
13:49:10 <jeffwheeler> I thought my friend had made up that up-arrow notation. That's neat!
13:49:18 <pumpkin_> ryant50001: wouldn't we all :P
13:49:26 <Taejo> ryant50001: that's a bit beyond me
13:49:28 <ryant50001> pumpkin_: well i'm willing to throw cash behind it :P
13:49:32 <Taejo> what hardware does it run?
13:49:39 <Taejo> s/hardware/processor/
13:49:40 <pumpkin_> ARM
13:49:40 <Deewiant> ARM, no?
13:49:46 <ryant50001> Taejo: it's ARM or the successor of ARM
13:49:52 <pumpkin_> it's ARM :)
13:50:03 <Heffalump> "successor of ARM"?
13:50:13 <ryant50001> Heffalump: i thought they rebanded recently
13:50:24 <ryant50001> Heffalump: i didn't mean like a *real* successor
13:50:49 <ryant50001> ah, they just changed the version numbering system
13:51:13 <whpearson> ryant50001: I'm trying to write and EDSL, so I don't want to have to worry the end user about file management/writing things ideally.
13:51:21 <pumpkin_> it runs armv6 instructions
13:52:02 <ryant50001> whpearson: ah
13:52:21 <Heffalump> ryant50001: yeah, it was just a branding exercise
13:52:26 <blackh> ryant50001: I could very interested. I have spare hours and extensive embedded experience.
13:52:35 * Heffalump realises you probably meant "rebranded" above rather than "rebanded"
13:52:41 <ryant50001> yeah :P
13:52:43 <blackh> ryant50001: ...and an abiding passion for Haskell, I might add!
13:52:45 <whpearson> iphone shmiphone, I want haskell written in javascript for the palm pre :P
13:52:51 <ryant50001> blackh: awesome
13:52:55 <Heffalump> they continued with the v<n> scheme for architectures, though they introduced separate profiles - v7a, v7r and v7m
13:53:03 <ryant50001> whpearson: lol
13:53:21 <Heffalump> and the v7 CPUs are Cortex-[A|R|M]<something>
13:53:30 <blackh> ryant50001: For the last four years I've been working on an ARM-linux based embedded project in C++. I know that ghc 6.8.3 works on Debian ARM.
13:53:40 <ryant50001> blackh: ah, cool
13:53:55 <blackh> ryant50001: I don't know much about the iPhone, though. Can you tell me some technical details, such as, what OS it uses?
13:54:02 <pumpkin_> iphone os :)
13:54:05 <ozy`> ryant50001: "compiling haskell to iphone" can mean one of several things. you'd definitely need to get ghc working with mach-O/ARM, but in the event that you'd want to write a cocoa touch app in haskell you'd also need to jump through a few hoops to make HOC work
13:54:07 <tromp_> customized OSX
13:54:39 <ozy`> ryant50001: I dunno if HOC compiles on OS X these days... I'm sure you'd find all kinds of hilarious bugs if you put it on the iphone
13:54:40 <blackh> ryant50001: Here's a Haskell programming running on an arm processor: http://blacksapphire.com/antispam/
13:55:04 <ryant50001> ozy`: i'm ok with using some Objective C
13:55:39 <ryant50001> ozy`: i want the ability to build most of my logic in Haskell, with a relatively thin Objective-C wrapper at most
13:55:53 <ryant50001> ozy`: also, i'm interested more in OpenGL than in Cocoa, but i'm not sure how much Cocoa i'd still need to use
13:56:36 <pumpkin_> I know the iphone pretty much inside out if anyone has any questions about it, but I have no time to get ghc working on it :(
14:00:25 <blackh> pumpkin_: What do you use to develop C on the iPhone?
14:00:42 <pumpkin_> I just use the apple official toolchain (the one that comes with xcode)
14:00:53 <pumpkin_> from makefiles mostly
14:01:02 <ryant50001> pumpkin_: what problems do you think would arise using -via-c to get it onto the iphone?
14:01:09 <ryant50001> just the ability to build the standard libraries?
14:01:12 <pumpkin_> otherwise, there is an unofficial one that works on all platforms
14:01:14 <ryant50001> (and runtime libraries)
14:01:33 <ozy`> ryant50001: most of the logic in a typical objective-C app isn't even written in C, per se... it's done through the cocoa runtime. I haven't worked with openGL though, so that might be more doable
14:01:36 <pumpkin_> ryant50001: as far as I know, it's a real pain to bootstrap ghc through hc files... I seem to remember seeing a ticket on the ghc trac about it, scheduled for 6.12
14:01:40 <blackh> pumpkin_: How does the iPhone differ from the Mac?
14:01:58 <pumpkin_> blackh: in terms of the basic OS structure, not much
14:01:59 <ryant50001> hm
14:02:14 <blackh> pumpkin_: Does it have a Darwin kernel?
14:02:24 <pumpkin_> yeah, more or less the same xnu as mac os
14:02:33 <ozy`> blackh: different GUI framework, different hardware constraints, and some other variations on the available frameworks... otherwise it's more or less the same beast
14:02:35 <blackh> Well, that's pretty easy then. :)
14:02:58 <ryant50001> ozy`: i might include wrappers of whatever is needed (cocoa, whatever) in the bounty project
14:03:04 <pumpkin_> but in general, getting ghc actually compiled to the iphone doesn't seem very useful
14:03:04 <ryant50001> ozy`: or it might be a separate project
14:03:13 <pumpkin_> cross-compiling to iphone from your host seems more useful
14:03:18 <ryant50001> pumpkin_: i agree
14:03:24 <blackh> ryant50001: Threading is disabled on the Debian ARM version of ghc, so there may be an issue there.
14:03:33 <ozy`> for what it's worth, part of the reason apple went with nextstep as the basis of OS X is that they were already planning to put it on 70 different CPU archs back in the late 90s
14:03:36 <ryant50001> blackh: odd
14:03:38 <pumpkin_> given the memory requirements of ghc, and the fact that springboard kills you after exceeding 64 megs, I'm not sure you'd get much done natively on the iphone
14:04:04 <ozy`> ryant50001: separating the projects might be wise.... although one would be dependent on the other
14:04:30 <ryant50001> ozy`: yeah
14:04:44 --- mode: irc.freenode.net set +o ChanServ
14:04:44 <blackh> ryant50001: It could be something easy, or it might not. My guess is that it's somehow related to the "mangler", since that's very processor-specific.
14:05:18 <ryant50001> blackh: what's the mangler? i don't know too much about haskell's internals
14:06:22 <blackh> ryant50001: The so-called "evil mangler" is a piece of code that (if I understand correctly) munges the assembler output (of gcc I assume) and does some Haskell-specific things, possibly related to tail recursion - but don't quote me.
14:06:38 <sw17ch> @seen dons
14:06:39 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 5m 38s ago.
14:06:43 <pumpkin_> mangling is usually used in the context of symbols
14:06:44 <ryant50001> blackh: oh right, i've heard of that
14:06:51 <pumpkin_> I thought
14:07:05 <ryant50001> pumpkin_: yeah, it usually is, but i think this is more like an optimizer
14:07:11 <pumpkin_> ah
14:07:47 <ryant50001> blackh: how necessary is the mangler? are we talking about a constant-factor improvement in runtime speed or a reduction in order?
14:08:49 <dons> ryant50001: 2x
14:08:53 <blackh> ryant50001: I don't know the answer to that question.
14:09:21 <ryant50001> dons: oh; that's not such a big deal for my project
14:09:28 <ryant50001> dons: does it seriously impact memory usage?
14:10:06 <ryant50001> dons: in case you missed the context, i'm trying to find someone to set up compiling to iPhone as a bounty project; if you know anyone who would be interested, let me know
14:10:15 <sw17ch> dons: ping
14:10:40 <Nafai> Is there something where I can do some simple 2D text animation?  Would Cairo be my best choice for that?
14:10:56 <Nafai> I just want to make a simple app that scrolls text in a configurable font and color, etc
14:11:20 <dcoutts> Nafai: it'd be doable
14:11:58 <blackh> ryant50001: I'm definitely interested.
14:11:59 <Nafai> Oh, and it will listen on a port to get the text
14:12:54 <lukeo05> is there a room more suitable for haskell beginners?
14:13:03 <Nafai> lukeo05: This is it
14:13:20 <lukeo05> oh lord.
14:13:22 <Nafai> lukeo05: We have a separate channel for advanced topics #haskell-in-depth, so feel free to ask beginner questions here
14:13:55 <Nafai> lukeo05: People are really newbie friendly here, even with some of the seemingly advanced topics going on
14:14:13 <lukeo05> Nafai: Okay cool, thats good to know. Thanks.
14:14:16 <Nafai> np
14:14:24 <Nafai> Do you have any specific questions?
14:14:29 <Nafai> Welcome, btw. :)
14:15:06 <lukeo05> No not really... Just why does it make sense in lectures, but when I try and actually apply something in practice it just blows my mind!?
14:15:15 <pumpkin_> that's quite normal :)
14:15:42 <Nafai> Indeed.
14:15:51 <Nafai> I still feel that way often
14:16:21 <gaze__> what's the best way to seteuid in a concurrent program?
14:16:47 <gaze__> so that I don't all of a sudden find another "thread" executing with high privilages
14:17:56 <Cale> lukeo05: It takes a while to get accustomed to this particular way of constructing software. It took me a couple months before I felt like I could actually do anything useful, and about a year to feel genuinely comfortable.
14:18:07 <michaelcdever> can anyone tell me how to print out the amount of seconds it takes to carry out a function?
14:18:08 <Cale> (But it's definitely worth it)
14:18:18 <Cale> michaelcdever: In ghci, you can :set +s
14:18:37 <Cale> and it'll print the amount of time and allocation
14:18:59 <michaelcdever> ah, i just want to time a function carried out in one line of code
14:19:54 <Cale> michaelcdever: Is it a pure function?
14:20:03 <sjanssen> gaze__: correct me if I'm wrong, but seteuid seems to be a process setting rather than a thread setting
14:20:16 <michaelcdever> nope, tis an IO function
14:20:30 <gaze__> right.
14:20:45 <gaze__> it applies to the entire process...
14:20:53 <Cale> :t getClockTime
14:20:56 <lambdabot> Not in scope: `getClockTime'
14:21:00 <Cale> :t System.Time.getClockTime
14:21:01 <lambdabot> IO System.Time.ClockTime
14:21:07 <gaze__> hence why if the scheduler rips me out, another thread will have elevated privilages
14:21:13 <gaze__> until the other thread reschedules and drops it
14:21:16 <sjanssen> gaze__: oh, so you have one thread that needs escalated privileges, rather than the other way around?
14:21:21 <Cale> :t System.Time.diffClockTimes
14:21:22 <lambdabot> System.Time.ClockTime -> System.Time.ClockTime -> System.Time.TimeDiff
14:21:23 <gaze__> yeah exactly
14:21:28 <Cale> You can use those.
14:21:58 <sjanssen> gaze__: can you do the higher privilege tasks in a forked process?
14:22:13 <michaelcdever> yep, just saw that there, thanks Cale
14:22:56 <Cale> With the newer Data.Time library, you could also use  getCurrentTime and diffUTCTime
14:23:26 <gaze__> eehhh would rather not do that.
14:23:32 <gaze__> isn't there some way to halt the scheduler?
14:23:43 <sjanssen> no, I don't think so
14:24:14 <sjanssen> and you'd have even more trouble in the -threaded runtime
14:24:35 <gaze__> eeeew
14:24:41 <gaze__> hadn't thought of that...
14:25:25 <Cale> What are your other threads doing?
14:25:40 <gaze__> doing sockets stuff
14:25:45 <gaze__> this is an smtp server
14:26:47 <gaze__> basically threads for clients... and a thread that dequeues and delivers into local mailboxes
14:26:57 <gaze__> and the delivery thread has to execute with elevated privilages
14:28:39 <zong_sharo> can somebody help me with parsec?
14:28:40 <lambdabot> zong_sharo: You have 1 new message. '/msg lambdabot @messages' to read it.
14:28:42 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1685#a1685
14:28:52 <Cale> Well, Haskell threads are not mapped directly to OS threads or processes... but I suppose there are things you can do to rig up a system of pausing the other threads while you do some work.
14:29:35 <gaze__> yeah! I was thinking of kinda 'disabling interrupts' until I can drop privilages
14:29:48 <sjanssen> you can do something like this, but it will be ugly
14:29:54 <sw17ch> Cale, gaze__: actually, i was wondering about something justl ike this the other day
14:30:04 <sw17ch> i want a threadSuspend function
14:30:14 <Cale> Maybe an abstraction around forkIO which handles an exception which you throw to the thread to pause it.
14:30:22 <zong_sharo> i can't understand, why manyTill consumes more chars, than shold be
14:30:22 <sw17ch> it asks the RTS to abstain from scheduling the thred until it's enabled again
14:31:38 <gaze__> well... I kinda want the inverse of that, where my thread will never get switched out
14:31:50 <pumpkin_> lol
14:32:39 <whpearson> Is GHCI nice to hack at?
14:32:39 <sjanssen> gaze__: does your program have certain critical sections where privileges must be low?
14:32:50 --- mode: irc.freenode.net set +o ChanServ
14:33:05 <Cale> zong_sharo: You have it stop when it reaches a hyphen followed by 1 or more *digits*
14:33:06 <pumpkin_> whpearson: you mean actually the source of ghci? or using it to play with code?
14:33:17 <gaze__> I'd rather the privileges be low for the bulk of the program, and then regain them for critical sections.
14:33:37 <whpearson> pumpkin_: Source. I'm thinking about using it as the interpreter of the EDSL.
14:33:45 <Cale> zong_sharo: '.' is not a digit, and it stops parsing there, so the .2 goes into 'rest'
14:34:18 <Cale> er...
14:34:43 <sjanssen> gaze__: I still think forkProcess is the way to go here :)
14:34:56 <hallongrottan> is there a way to make lambdabot join a channel?
14:35:03 <gaze__> auh... maybe you're right...
14:35:47 <zong_sharo> Cale: aahh, got it
14:35:48 <sjanssen> gaze__: does the delivery process need to communicate back to the rest of the program?
14:36:04 <gaze__> not really. It should just dequeue stuff
14:36:22 <sjanssen> hallongrottan: which channel?
14:36:39 <gaze__> forking is probably ideal because I can fully drop privilages
14:36:45 <hallongrottan> sjanssen: #yane, its a bachelors project, writing a NES emulator in Haskell
14:37:03 <gaze__> if someone gets some shell code in, obviously they can seteuid back to zero...
14:37:19 <Cale> zong_sharo: and of course, the terminator for manyTill isn't included in its result
14:37:26 <sjanssen> lambdabot: @join #yane
14:37:27 <zong_sharo> Cale: what parsec's equivalent for regex '([A-Za-z_+-]+?)-(\d+)'
14:37:36 <zong_sharo> i don't get it
14:37:42 <hallongrottan> thanks for the help sjanssen
14:37:58 <Cale> zong_sharo: You want the package name in the first part and the version in the second?
14:38:41 <zong_sharo> yeah
14:38:45 <zong_sharo> or
14:39:10 <jeffwheeler> HaskellDB can do database introspection, I think, but I can't seem to find an example of it doing this anywhere online.
14:39:11 <zong_sharo> not end in a hyphen followed by one or more digits
14:39:34 <jeffwheeler> In fact, I'm having quite a bit of trouble finding any modern resources on HaskellDB; am I missing anything vital?
14:40:01 <jeffwheeler> Or, perhaps this is actually modern (despite the warning)? http://haskelldb.sourceforge.net/getting-started.html
14:42:27 <Cheshire> @w80 prolixity
14:42:28 <lambdabot> *** "prolixity" wn "WordNet (r) 2.0"
14:42:28 <lambdabot> prolixity
14:42:28 <lambdabot>      n : boring verboseness [syn: {prolixness}, {long-windedness}, {wordiness}]
14:43:14 <ddarius> Nice word.  It describes me well.
14:43:15 <Cale> zong_sharo: this is a little bit of an annoyance about parsec as opposed to most other parser combinator libraries -- it doesn't like to backtrack by default, and if you need backtracking, you have to use 'try'
14:43:20 <Cheshire> hehe
14:43:48 <Cheshire> Cale, I have trouble with ReadP because (+++) is fair :
14:43:57 <Cheshire> Cale, both ways seems inadequate ...
14:44:00 <zong_sharo> Cheshire: quoting from the spec:
14:44:04 <zong_sharo> Cheshire: oops
14:44:07 <Cale> Cheshire: what's wrong with it being fair?
14:44:11 <zong_sharo> Cale: quoting from the spec:
14:44:19 <zong_sharo> Cale: '''A package name may contain any of the characters [A-Za-z0-9+_-]. It must not begin with a hyphen, and
14:44:21 <zong_sharo> must not end in a hyphen followed by one or more digits.
14:44:23 <zong_sharo> '''
14:44:25 <glguy> Cheshire, if you don't want fair, you've got <++
14:44:45 <Cale> zong_sharo: right.
14:45:21 <Cheshire> Cale, I've had two sep. problems with it, One is horrendously bad efficiency (like 20 seconds to parse a 30 char string), and the second is parsing something like   a b c  as eiher (a b) c  or a (b c)
14:45:57 <Cheshire> using <++ fixed the first, but for the second you have to do some more hard work
14:46:16 <zong_sharo> Cale: any advice?
14:47:37 <Cheshire> (could just be my inexperiencedness though.. maybe there is a realy neat way to do what I was doing, not sure)
14:47:49 <Cale> zong_sharo: Just a moment :)
14:56:14 <Cale> zong_sharo: I see. The description is a little annoying to turn directly into a parser.
14:56:26 <Cale> But I think I can see how to do it :)
14:58:04 <infoe|wk> jeffwheeler: I havent done any db work from haskell, but have you seen the apps and libraries/database interfaces on the haskell wiki? http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
14:58:56 <jeffwheeler> infoe|wk: I saw the HaskellDB page, which I assumed was the best option; I might resort to something lower-level if I keep having trouble.
15:00:51 <Cale> btw, I don't understand why notFollowedBy in Parsec has such an annoying type.
15:02:25 <olsner> Cale: what's annoying about it?
15:04:07 <Cale> olsner: It seems to assume that the result of the parser you give it will be a single token.
15:04:23 <Heffalump> to limit lookahead?
15:04:38 <Cale> The inferred type is more general.
15:04:42 <Cale> (in any case)
15:04:53 <olsner> oh, right, t is constrained by Stream s m t ... yeah, that looks daft
15:05:03 <olsner> the value is obviously not used for anything
15:05:21 <Cale> You can always add a 'return undefined' to any parser to make it fit that type, but it's silly.
15:05:53 * Cheshire blames the habit of writing down type signatures explicitly..
15:06:20 <olsner> return undefined is bad though
15:06:44 <Cale> yeah, it's just a bug, if you ask me
15:06:55 <olsner> e.g. liftIO (printf ...) causes Exception: undefined because printf wanted to have the type m a
15:07:55 <Cale> zong_sharo: The real problem is that I also don't think that regex fits the definition either -- if it did, then it would be easy :)
15:09:56 <Cale> abc-123-def is a valid package name, but abc-123 is not.
15:10:47 <Cale> and when we get something like abc-123, we want the parse to stop at abc without having consumed any further characters.
15:11:10 <Cale> So we need to look ahead.
15:12:00 <glguy> and this is why having toEnum use Int is a bad choice: *** Exception: Enum.fromEnum{Word64}: value (18446744073709551615) is outside of Int's bounds (-9223372036854775808,9223372036854775807)
15:14:29 <olsner> :)
15:16:15 * Cheshire is surprised Tait has a paper from 2000, .. I was alive back then!
15:16:34 <Gracenotes> hm. It seems that the automatically derived Read instance for a simple enum reads in the whole token, /then/ tries to match it against the names
15:17:06 <Gracenotes> would be somewhat difficult otherwise, anyway..
15:24:35 <zong_sharo> Cale: any progress?
15:27:21 <pejo> Cheshire, he has stuff from 2006 atleast, http://home.uchicago.edu/~wwtx/
15:28:29 <Cale> zong_sharo: I'm close :)
15:29:49 <Apocalisp> Can lambdabot show precedence of operators?
15:30:42 <Cale> zong_sharo: Parsec is strange though :P  I'm more used to ReadP
15:30:55 <whpearson> Anyone have any advice for easily making other instances of monoids for lists?
15:31:08 <Cale> whpearson: You'd have to newtype
15:31:45 <Cale> aha, got it
15:33:54 <Cale> Let me just take a moment to clean it up slightly
15:34:58 <whpearson> Any shortcut ways to make it instances of foldable, traversable etc?
15:36:07 <monochrom> @info (+)
15:36:07 <lambdabot> (+)
15:36:15 <pumpkin_> @info is useless
15:36:15 <lambdabot> is useless
15:36:16 <monochrom> lambdabot doesn't show precedence.
15:36:17 <pumpkin_> :P
15:36:29 <monochrom> @stab lambdabot
15:36:29 * lambdabot locks up lambdabot in a Monad
15:36:33 <Cheshire> @quote
15:36:33 <lambdabot> arrogance says: I'm not arrogant. I'm just better than you in every way possible!
15:36:41 <monochrom> That is harsh punishment!
15:36:47 <Cheshire> @noxon
15:36:47 <lambdabot> I believe in the battle-whether it's the battle of a campaign or the battle of this office, which is a continuing battle.
15:37:24 <whpearson> Cale: Tried newtyping it, and futzing about with generalised newtype deriving, but it doesn't seem to be that simple.
15:37:26 <Cale> zong_sharo: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1561#a1561
15:38:03 <Cale> zong_sharo: Oops, cut off a couple imports at the top
15:38:08 <Cale> import Text.Parsec
15:38:08 <Cale> import Text.Parsec.String
15:38:13 <whpearson> I'd want to redefine the monoid instance for foldMap as well.
15:38:15 <Cale> (kind of obvious ;)
15:38:42 <Cale> whpearson: hm? You don't want to derive the instance...
15:38:47 <Cale> whpearson: You want to write a new one.
15:38:51 <chromakode> hey guys, what happened to the Haskell 2009 logo contest?
15:39:00 <Cale> whpearson: Oh, I missed the other bit
15:39:02 <pumpkin_> voting-system-bound
15:39:20 <chrisdone> if I have a ByteString (not Char8), how might I use a Read instance on it to get an Int?
15:39:32 <chromakode> pumpkin_: ha.
15:39:38 <Cale> whpearson: Yeah, you can try newtype deriving, but typically the other monoid-selector instances aren't instances of much else.
15:39:56 <pumpkin_> chrisdone: you could map (chr . fromIntegral) on it
15:39:58 <chrisdone> that's a lazy ByteString, btw, if that matters
15:40:06 <sjanssen> chrisdone: Char8.ByteString and ByteString are the same type
15:40:06 <chrisdone> :t chr
15:40:07 <lambdabot> Int -> Char
15:40:11 <Cale> whpearson: (you're expected to unwrap the thing after you've finished doing monoidy things with it :)
15:40:15 <zong_sharo> Cale: you are my hero!
15:40:40 <sjanssen> chrisdone: thus, you can use Data.ByteString.Lazy.Char8.unpack
15:41:10 <dolio> @type BSC.readInt
15:41:11 <lambdabot> BSC.ByteString -> Maybe (Int, BSC.ByteString)
15:41:34 <pumpkin_> @index readInt
15:41:34 <lambdabot> Numeric
15:41:42 <chrisdone> sjanssen: oh, awesome
15:41:43 <pumpkin_> @hoogle readInt
15:41:44 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
15:41:44 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
15:41:44 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
15:41:55 <chrisdone> dolio: oh double awesome?
15:42:00 <whpearson> Cale: I'd rather not have to, trying to make a EDSL so want to hide as much stuff as possible.
15:42:18 <leimy> @users
15:42:18 <lambdabot> Maximum users seen in #haskell: 658, currently: 608 (92.4%), active: 24 (3.9%)
15:42:32 <Cale> whpearson: Of course, there's another option -- just define your own associative operator and unit.
15:43:00 <Cale> whpearson: But if you need Writer or other things which use the Monoid interface, then that obviously doesn't work.
15:43:51 <Cale> Or write the instances of Foldable, etc. by hand for your new type.
15:43:53 <whpearson> Cale: Yeah, I'd like to keep that flexibility. Especially things like foldMaps.
15:43:58 <Cale> (if deriving doesn't work)
15:45:52 <whpearson> Cale: It is a blasphemy against the religion of not writing boiler plate, but I'll probably go that route.
15:47:15 <whpearson> Sleep beckons.
15:53:48 <skorpan> exactly what does "unsafe" mean in haskell?
15:54:05 <dolio> Depends.
15:54:13 <sjanssen> skorpan: any number of things
15:54:15 <Cale> skorpan: That it breaks expected guarantees about how things can behave.
15:54:25 <sjanssen> usually something that subverts purity or type safety
15:55:16 <dolio> It means something bad could happen if you aren't careful.
15:55:45 <monochrom> unsafe means if you are careless you get type inconsistencies e.g. Int and String become the "same" thing like in Perl. If you're careful that's alright.
15:55:50 <cjb> as opposed to the safe type of programming, where nothing ever goes wrong :)
15:55:51 <mdmkolbe> What is the easiest way to install haskell hilighting for Emacs (v22)?  Is there a cabal command for it?  (This is a per-user install since I'm not admin on this machine)
15:56:02 <cjb> mdmkolbe: install haskell-mode.el
15:56:29 <cjb> mdmkolbe: http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
15:57:15 <dolio> Doesn't have to be purity or type safety, necessarily, either.
15:57:35 <dolio> unsafeRead/Write for MArrays does no bounds checking, for instance.
15:57:42 <monochrom> It's like sudo. Privilege escalation.
15:58:06 <dolio> So memory safety would be another thing to add to the list.
15:58:47 <pumpkin_> launching ICBMs too, or clubbing seals
15:59:08 <dolio> And then there's the arguments about head being called unsafeHead, because it's a partial function.
15:59:18 <chrisdone> bahhhh crap
15:59:32 <chrisdone> I accidentally wrote: (stdin,stdout_,_,proc) <- runInter
15:59:41 <chrisdone> so when I'm doing a get from stdout, error
16:00:00 <chrisdone> spent like 15 minutes trying to figure it out!
16:00:37 <monochrom> Oh hahaha.
16:00:51 <dolio> Too bad you didn't have the -W option that tells you when you fail to shadow global constants.
16:01:11 <chrisdone> dolio: good idea. I think I'll enable that in GHCi by default
16:01:11 <monochrom> A long time ago I wrote a C program to fflush(stdin). I intended fflush(stdout) of course. Multiple strange behaviours pursued.
16:01:20 <dolio> That's not a real option.
16:01:28 <chrisdone> dolio: oh ;_;
16:01:34 <dolio> You can only have it warn when you *do* shadow things.
16:02:01 <chrisdone> I kind of like shadowing.. but I guess it leads to problems like this
16:02:24 <chrisdone> I really dislike foo''' though! D_D
16:02:59 <dolio> Numbers are an alternative. :)
16:03:12 <chrisdone> is that what you do?
16:03:18 <dolio> Depends on the situation.
16:03:29 <dolio> I'd rather have foo3 than foo'''.
16:03:38 <monochrom> Like Stephan202 ? :)
16:04:43 <dolio> @girl19
16:04:43 <lambdabot> LOL
16:05:01 <chrisdone> oh bloody wootage!
16:05:12 * chrisdone does an evil laugh and twiddles his fingers
16:05:36 <chrisdone> I hacked vgrabbj a tad so that it prints the size of an image when it outputs it
16:05:43 <temoto> @w80 word son
16:05:44 <lambdabot> *** "word" wn "WordNet (r) 2.0"
16:05:44 <lambdabot> word
16:05:44 <lambdabot>      n 1: a unit of language that native speakers can identify; "words
16:05:44 <lambdabot>           are the blocks from which sentences are made"; "he
16:05:44 <lambdabot>           hardly said ten words all morning"
16:05:46 <lambdabot> [31 @more lines]
16:05:55 <temoto> @w80 "word son"
16:05:55 <lambdabot> No match for ""word son"".
16:05:56 <chrisdone> so I'm using -X to stop it forking, and it repeatedly sends images to stdout
16:06:03 <chrisdone> I read them in with libgd
16:06:09 <chrisdone> fuck yeahhhhh
16:06:28 <temoto> uh.. "word son" explained.. anyone?
16:06:49 <dolio> Context?
16:07:03 <pumpkin_> temoto: did you only join to use @w80? :P
16:07:29 <mdmkolbe> @help w80
16:07:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:08:04 <ozy`> temoto: prob'ly just some punk's cracked-out idiom. you follow me, droog?
16:09:17 <Stephan202> monochrom: que?
16:09:20 <temoto> dolio: well... pretty much this: http://dpaste.com/375/
16:09:45 <Stephan202> ah :)
16:09:49 <dolio> Oh.
16:09:51 <temoto> pumpkin_: yeah i joined for w80. :)
16:09:53 <newsham> as in "word, son" ?
16:09:55 <dolio> He was calling you son.
16:10:11 <monochrom> We were talking about variable names with lots of ''' like foo'''' vs numbering like foo202.
16:10:24 <dolio> And "word" means something like "affirmative" in that context.
16:10:25 <Stephan202> monochrom: yes, took me a little too long to get it :)
16:10:25 <temoto> ozy`: I do, droog :)
16:10:57 <Stephan202> (202 stands for feb 20, my birthday)
16:10:57 <temoto> dolio: thank you very much.
16:11:05 * monochrom looks for the next victim to wake up and disturb.
16:11:09 <Stephan202> :D
16:13:19 <dolio> Or, perhaps not ascent, but general acknowledgement.
16:26:00 <score> why do people both making arch/debian haskell packages when there is cabal?
16:26:48 <dcoutts> score: because people prefer packages from their native package manager
16:27:01 <dcoutts> it guarantees a higher level of QA, though less freshness
16:27:04 <dcoutts> they're complementary
16:27:09 <skorpan> i used to use arch's haskell packages but now i just don't bother anymore... cabal does it much better.
16:27:17 <score> okay, fine for debian, but arch linux?
16:27:22 <dolio> The arch packages are automatically generated using cabal, no?
16:27:26 <skorpan> yes dolio
16:27:37 <dcoutts> skorpan: yes, it's ok for hard code haskell hackers, but not for "outside" or new users
16:27:42 <dcoutts> hard core
16:27:55 <skorpan> dcoutts: not that i'm hardcore, but yes, i agre
16:27:56 <Saizan> the arch packages give you disinstallation
16:27:57 <skorpan> agree*
16:28:02 <skorpan> cabal isn't that difficult to use anyways
16:28:05 <Saizan> though you only have one version available
16:28:06 <dcoutts> Saizan: heh, and that
16:28:14 --- mode: irc.freenode.net set +o ChanServ
16:28:23 * Lemmih feels very hard core typing 'cabal install pony'.
16:28:44 * Saizan didn't get a pony with that :\
16:29:00 <dcoutts> Saizan: you should demand your pony!
16:29:17 <dcoutts> one comes free with every cabal installation
16:30:12 <dons> anyone want to write a library that provides a TH macro that prints a pony when your code is compilinmg?
16:30:20 <Saizan> oh, then i should have the house full of them.. ;)
16:30:26 <dons> import Pony   -- should essentially eval a pony at compile time
16:30:30 <Lemmih> My pony is defective. It has a growth on its head.
16:30:39 <dons> that's a unicorn!
16:30:44 <dcoutts> mm, mine too
16:30:46 <dcoutts> send it back
16:30:55 <dons> cabal install pony --narwhal -- for v 2.0
16:30:58 <dons> patches accepted
16:31:24 <lament> in no other language community people would get so excited over a silly ascii art picture.
16:31:40 <dcoutts> dons: it should randomly pick pics and one time in N say "No, you cannot have a pony!"
16:31:46 <dons> sure, there's already a perl Pony package.
16:31:48 <dons> on CPAN.
16:31:49 <SubStack> apt-get moo
16:31:50 <Gracenotes> people aren't getting excited, are they?
16:31:52 <lament> well, actually in the Malbolge community they would, because that would be an impressive achievement.
16:31:58 <SubStack> dons: not just one
16:32:00 <lament> but there is no Malbolge community :(
16:32:09 <dons> lament: what's your concern?
16:32:34 <SubStack> 21 modules with pony in them on cpan
16:32:43 <dons> heh
16:32:51 <dcoutts> SubStack: and lol?
16:32:57 <dcoutts> cabal install lolcode
16:33:03 <SubStack> there used to be a POE::Knee races in #perl
16:33:30 <lament> dons: i think this shows something essential about haskell, but i'm not sure what it is.
16:34:20 <SubStack> tolerance
16:34:25 <SubStack> and expressive capability
16:34:32 <SubStack> good things for a language community to have
16:34:38 <dcoutts> lament: na, it's just that we've recently got to a semi-mature distribution system, and we're feeling self-satisfied
16:35:38 <dons> fun?
16:35:46 <dons> and a mature distribution mechanism :)
16:36:01 <SubStack> machines doing the work so the humans can play!
16:36:24 <lollan> Hi, I want to start haskell , what compiler / interpreter is the best ?
16:36:25 <edwardk> dons: sounds like some kind of pr0n torrent thing
16:36:44 <dons> heh
16:36:49 <dons> lollan: GHC
16:36:52 <dons> haskell.org/ghc
16:36:54 * Saizan uploads a pony package that depends on base >= 5, so noone can install it anymore
16:36:59 <dons> boo on Saizan !
16:37:00 <lollan> thanks dons
16:37:23 <edwardk> wait  i need to get a pony first
16:37:43 <edwardk> or just upload a base > 5 ;)
16:38:06 <Saizan> hah
16:39:01 <Saizan> btw(of what?), can you implement laziness without an heap?
16:39:40 <edwardk> saizan: sure, but you'll wind up without memoization and a rather slow evaluator
16:40:01 <Saizan> memoization == sharing there?
16:40:07 <twb> Does the "Grapefruit" package allow developers to do 2D vector stuff (e.g. via libcairo)?
16:40:14 <twb> Or it is just widgets?
16:40:47 <edwardk> saizan: yeah
16:41:11 <rainmann> @useras
16:41:11 <lambdabot> Maximum users seen in #haskell: 658, currently: 610 (92.7%), active: 17 (2.8%)
16:41:37 <dons> twb: i think its widgets
16:41:43 <dons> there's other libs for 2D vector stuff
16:42:40 <Saizan> ok, then i'll surrender to an heap for call-by-need
16:44:29 * twb does cabal list | grep cairo
16:44:55 <dcoutts> twb: it's not on hackage yet sadly
16:45:02 <twb> Lame, no hits.
16:45:18 <twb> I wanted to get those Darcs GUI students to use cairo, because it sounds awesome and sexy
16:45:18 <dons> $ cabal list | grep -i 2D
16:45:40 <dcoutts> what's with this grep?
16:45:44 <dcoutts> just cabal list 2D
16:45:45 <dons> $ cabal list | grep -i cairo
16:45:45 <dons> * cairo Synopsis: An elegant analog clock using Haskell, GTK and Cairo Homepage: http://haskell.org/gtk2hs/archives/2006/01/26/cairo-eye-candy/
16:45:48 <dons> * svgcairo
16:45:57 <dcoutts> it already does substring matching on the package name
16:46:20 <dcoutts> admittedly it doesn't search descriptions etc yet
16:46:24 <twb> dcoutts: it might not have been in the package name; I wanted to search the description, too
16:46:32 <sjanssen> twb: there is a cairo binding, you just have to download it from somewhere other than cairo
16:46:39 <dcoutts> twb: aye
16:47:31 * twb closes gmane.c.v.darcs.user and goes back to reading RWH
16:47:34 <dcoutts> cabal list | grep  is sadly very slow because it has to parse 1000 .cabal files
16:47:49 <dcoutts> which is why "cabal list name" does not search descriptions yet
16:48:06 <dcoutts> there's an open ticket on it if someone wants to work on that
16:48:24 <dcoutts> the solution is to generate a local index/cache after we download
16:48:28 <dcoutts> and use that for searches
16:49:35 * dcoutts goes back to checking lazy IO code
16:50:28 <dcoutts> here's a nice function:
16:50:28 <dcoutts>     interleave :: [IO a] -> IO [a]
16:50:29 <dcoutts>     interleave = unsafeInterleaveIO . go
16:50:29 <dcoutts>       where
16:50:29 <dcoutts>         go []     = return []
16:50:29 <dcoutts>         go (x:xs) = do
16:50:31 <dcoutts>           x'  <- x
16:50:33 <dcoutts>           xs' <- interleave xs
16:50:35 <dcoutts>           return (x':xs')
16:51:03 <dcoutts> use it in place of sequence (on IO types)
16:51:21 <dcoutts> and it delays the IO actions until that bit of the list is consumed
16:51:43 <dcoutts> eg if you're processing all files in a directory or something
16:51:53 <edwardk> cute
16:52:39 <edwardk> kind of a poor man's ListT done right?
16:52:44 <dcoutts> I'm using it for creating tarballs from a recursive directory scan
16:53:05 <dcoutts> edwardk: hmm, well it gives us something back that looks pure
16:53:09 <Gracenotes> oh.. unsafeInterleaveIO will work nicely instead of the () -> IO a I'm using
16:53:29 <edwardk> yeah, which always scares the hell out of me, but hey ;)
16:53:35 <dcoutts> edwardk: where as I presume ListT is layering over IO ? so we're still in IO
16:53:41 * juhp ponders whether to get darcs-2.2.1 from hackage or mornfall
16:53:50 <edwardk> http://www.haskell.org/haskellwiki/ListT_done_right
16:54:08 <edwardk> basically each step has an io action when you apply it to io.
16:54:12 <Gracenotes> @hoogle unsafeInterleave
16:54:13 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
16:54:13 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
16:54:13 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
16:54:14 <edwardk> which makes it more explicit
16:54:33 <Gracenotes> so, to force the value somehow..
16:54:35 * edwardk cowers in fear from unsafe* effects unless absolutely forced not to ;)
16:54:50 <dcoutts> edwardk: hmm
16:55:09 <dcoutts> edwardk: unsafeInterleaveIO is not at all unsafe in the way unsafePerformIO is
16:55:25 <Gracenotes> doesn't it use unsafePerformIO? ;)
16:55:30 <edwardk> i don't like getContents either =P
16:55:34 <dcoutts> Gracenotes: not observably
16:55:39 <dcoutts> edwardk: bah :-)
16:55:49 <edwardk> dcoutts: until you give me a lazy file system the abstraction leaks
16:55:59 <Gracenotes> as I've said, unsafePerformIO is only dangerous if you use it dangerously
16:56:04 <Gracenotes> :)
16:56:08 <dcoutts> edwardk: of course, but when it works it's lovely
16:56:24 <dcoutts> edwardk: in many applications it's fine and much shorter
16:56:25 <monochrom> All of math is a big soup of tautology.
16:56:59 <edwardk> agreed, it just annoys me that it doesn't compose well.
16:57:03 <dcoutts> edwardk: eg this traversing dirs thing, that's not going to work if you change the dirs, but a direct implementation would not fare any better
16:57:12 <edwardk> so give me a lazy functional file system and you can getContents to your heart's content ;)
16:57:18 <dcoutts> edwardk: right, it only composes in the context of a complete consumer
16:57:49 <dcoutts> edwardk: oh a persistent consistent snapshotting one? yes, that'd be nice
16:58:08 <dcoutts> it annoys me that we cannot get that with mmap
16:58:15 <dcoutts> open a file read only with COW
16:58:24 <dcoutts> and be protected from writes by other processes
16:58:26 <pumpkin_> moo
16:58:33 <monochrom> /dev/zero is a lazy file system.
16:58:56 <edwardk> yeah. fix it up withsome kind of sha-based indexing scheme like venti or foundation and you have the basis of an actual file system that could be built with a reason for immutability
16:59:16 <edwardk> monochrom: i hereby give you permission to apply getContents to /dev/zero til your heart's content ;)
16:59:16 <pumpkin_> building it on top of ZFS shouldn't be too painful
16:59:22 <pumpkin_> as ZFS is all COW anyway
17:00:20 <dcoutts> right, just applying 20 year old DB concepts
17:00:20 <mdmkolbe> Is there a way to declare a type family and a type instance in a single line?
17:00:33 <edwardk> semi-colon? =)
17:01:49 <monochrom> /dev/urandom is the next generation lazy file system. Improving on /dev/zero technology, it now contains the complete work of Gdel translated into Chinese --- you just have to search for it.
17:02:08 <cjb> monochrom: you mean /dev/random?  :)
17:02:15 <monochrom> Yes.
17:02:18 <cjb> I'm not sure we can make that claim about urandom
17:02:29 <monochrom> What is the difference?
17:02:38 <pumpkin_> urandom isn't as random :P
17:02:44 <cjb> oh, urandom will always output bits, even if the entropy degrades
17:02:50 <pumpkin_> random will block until more entropy comes in
17:03:16 <monochrom> Then /dev/random
17:03:30 <cjb> sorry for pedanting your joke :)
17:04:09 <mdmkolbe> @hoogle [a] -> a
17:04:09 <lambdabot> Prelude head :: [a] -> a
17:04:09 <lambdabot> Prelude last :: [a] -> a
17:04:09 <lambdabot> Data.List head :: [a] -> a
17:04:16 <monochrom> haha
17:04:44 <edwardk> cjb: thats fine, you may just have to pause in your search from time to time ;)
17:04:46 <pumpkin_> bos lost his 1337sauce :(
17:04:55 <cjb> edwardk: with random, yes
17:05:09 <bos> :-)
17:06:24 <edwardk> well, i mean if you want to ensure that reading from urandom will find godel's works in chinese eventually, taking a break from time to time will let even that one refresh its randomness pool ;)
17:06:50 <cjb> oh, I see.  if you have an entropy source, yeah.
17:07:13 <cjb> (many setups, such as a rackmount server, end up with really really poor entropy sources)
17:07:16 <monochrom> Will have to wait either way. One is forced, the other is highly recommended.
17:08:51 <Gracenotes> I convert matter to make my entropy
17:09:08 <monochrom> I eat newbies for entropy.
17:09:09 <Gracenotes> ain't I speshul :(
17:09:13 * pumpkin_ hides
17:09:36 <mdmkolbe> monochrom: newbies are generally predictable so I'm not sure they'll make good entropy
17:09:52 * pumpkin_ does his best to be unpredictable
17:12:05 <SamB> edwardk: I don't think finding godel's works in chinese would take long at all
17:12:14 * SamB is pretty sure he didn't have any of those ;-P
17:12:17 <mdmkolbe> Is there a way to break a type synonym cycle (e.g. data X m a; type Foo a = X Foo a) without adding another constructor in there (e.g. make Foo a newtype)?
17:12:18 <monochrom> They are generally unpredictable. They come up with crazy rephrasings of whatever you tell them about monads. OK after watching 100 newbies you know "but their rephrasings are always one of A, B, C, D, or E". Well that is still no prediction because you still don't know which of A,B,C,D,E the next newbie who comes in will use. That's the source of entropy.
17:12:57 <SamB> monochrom: what if someone starts seeding your pool with fake newbies ?
17:13:14 <dolio> pumpkin_: I'm not sure a person qualifies as a newbie once they've used byteArrayContents#.
17:13:21 <pumpkin_> lol
17:13:26 <monochrom> Then I don't know. Maybe fake newbies are even more entropic!
17:13:49 <pumpkin_> I'm a newbie dabbling in things he shouldn't be dabbling in then :P
17:13:49 <SubStack> maximally irreducible newbies
17:13:51 <cjb> alone, their entropy is unreliable, but if you XOR a couple of them together..
17:14:06 <cjb> maybe that's just for hash functions :)
17:14:10 <SubStack> they form an orthonormal basis
17:14:21 <monochrom> hahahaha
17:15:48 * SubStack has moved into the everything-with-monads phase after mucking about with glut programming in haskell
17:16:16 <edwardk> samb: i was referencing an earlier statement that included the words 'translated into' ;)
17:16:44 <SamB> edwardk: ah
17:16:47 <monochrom> newtype Foo a = MkFoo (X Foo a)   does this work?
17:17:21 <dibblego> @type Data.Traversable.sequence
17:17:22 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
17:17:31 <dibblego> why is this (Monad m) => and not (Applicative m) => ?
17:17:43 <dolio> @type Data.Traversable.sequenceA
17:17:44 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
17:19:09 <dibblego> does sequence == sequenceA?
17:19:30 <dolio> If the applicative corresponds to the monad.
17:20:26 <glguy> all Monads can have an Applicative instance
17:20:34 <glguy> so if you have everything in place
17:20:41 <glguy> you can use sequenceA in sequence's place
17:20:41 <dibblego> yeah I think dolio means if ap = (<*>)
17:21:05 <dolio> Yeah, but someone could go nuts and switch the ZipList and [] applicative instances.
17:22:05 <Gracenotes> ..right..
17:22:06 * Saizan wonders when it's a good time to perform GC in a lambda calculus evaluator
17:22:37 <dolio> > getZipList $ sequenceA [ZipList [1,2,3], ZipList [4,5,6]]
17:22:38 <lambdabot>   Not in scope: `sequenceA'
17:22:45 <dolio> > getZipList $ Data.Traversable.sequenceA [ZipList [1,2,3], ZipList [4,5,6]]
17:22:46 <lambdabot>   [[1,4],[2,5],[3,6]]
17:23:03 <dolio> > Data.Traversable.sequence [[1,2,3], [4,5,6]]
17:23:04 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
17:23:40 <Gracenotes> so I've heard :X
17:24:36 <ddarius> Saizan: When you run out of memory is probably a good time.
17:24:37 <dons> Saizan: at the end of an inner scope?
17:24:55 <dolio> Saizan: Just do region inference.
17:24:59 <dons> i.e. once you reduce something to a value, collect the detritus
17:25:11 <dons> that might be too much though, i guess. but its kind of region-ish
17:25:32 <monochrom> Saizan: during the time you wait for user input.
17:25:53 <dons> hey, the standard papers on region GC are probably in terms of a simple lambda calc term lang
17:25:58 <dons> iirc, tofte's paper is
17:26:04 <dons> so just do that :)
17:26:57 <Saizan> heh, ok :)
17:27:38 <Saizan> since most values are lambdas even when reduced they retain most of the lexical scope
17:27:55 <dons> oh, it really is lambda calc?
17:28:06 <dons> not a lambda-ish lang
17:28:09 <dons> numbers are functions?
17:28:13 <dons> data is functions?
17:28:17 <Saizan> not sure yet.
17:29:29 <roconnor> what is a good unicode arrow to use for the -> in case statements?
17:29:30 <mdmkolbe> given "data F m x; type Foo a = F m a; data Bar m z", is there flag that will allow me to say "type Baz a = Bar Foo a" instead of having to say "type Baz a = Bar (F m) a"?
17:29:48 <roconnor> I'm a little hesitant to use  because it is being used for reduction
17:29:56 <Saizan> i throw away the old scope when i dereference a variable, so that's a good point i suppose
17:30:22 <roconnor> Maybe I should use  for reduction instead
17:31:04 <glguy> mdmkolbe, how about: type Foo = F m
17:31:33 <Gracenotes> Saizan: you should try  reduction
17:31:44 <dons> monkey-hand?
17:31:54 <glguy> mdmkolbe, there is an extension to do soem weird stuff in in "type" declarations
17:31:57 * dons tries to interpret the odd symbol he's looking at
17:32:12 <Cale> dons: snowman
17:32:18 <Cale> (I think)
17:32:57 <mdmkolbe> glguy: that works, thx
17:33:23 <dons> that's not a snowman!
17:33:25 <dons> that's a pony.
17:33:33 <dibblego> 
17:33:33 <glguy> mdmkolbe, http://haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-synonyms also
17:33:44 <sjanssen> U+2603 SNOWMAN
17:34:14 <dons> UNICORN Not Found
17:34:14 <dons> :/
17:34:26 <dons> PONY Not Found
17:34:39 <dons> U+2604 COMET
17:34:55 <dons> interesting. my font is drawing  as a comet
17:35:02 <dons> 
17:35:05 <dons> and comet as nothing
17:35:23 <dons> 
17:35:44 <monochrom> You've go transitivity.
17:35:48 <dolio> No wonder people were criticizing your font yesterday.
17:35:58 <dons> Liberation Sans!
17:36:03 <dons> actually, I'm using terminus
17:38:20 <monochrom>  is Chinese unicorn
17:38:55 <SubStack> is the space pope reptillian?
17:40:03 <dolio> So, nobody's figured out a proof of (t t'. ((a. t a) -> t') -> (a. t a -> t')) ->  still?
17:41:14 <SamB> dolio: why would that be rovable ?
17:41:19 <SamB> *provable
17:41:21 <monochrom> Why should it be provable?
17:41:40 <Adamant> I have no idea how people read Chinese fonts on the computer without putting their eyeballs right next to the monitor
17:42:00 <SamB> Adamant: possibly they use a lower resolution
17:42:06 <SamB> or bigger font sizes
17:42:07 <ddarius> Adamant: Since my font is bold, that would not help.
17:42:28 <Adamant> I was looking at monochrom's
17:42:33 <dolio> Someone in the thread about ST mentioned that they didn't think you could write a function ((a. t a) -> t') -> (a. t a -> t'), but they didn't know how to prove it.
17:42:40 <Adamant> too much in too small a space
17:42:43 <Valodim> when you're used to it the radicals can actually be made out quite well
17:42:52 <Adamant> I'm just starting
17:43:07 <SamB> dolio: oh, possibly I mislocated the quantification
17:43:11 <hackage> Uploaded to hackage: regex-tdfa 0.97.4
17:43:17 <monochrom> That only means ((a. t a) -> t') -> (a. t a -> t') is unprovable. Unprovable does not imply disprovable.
17:43:27 <dolio> Sure.
17:43:30 <SamB> also true
17:44:04 <monochrom> If you add a classical axiom, you get a consistent extension of your logic in which ((a. t a) -> t') -> (a. t a -> t') is provable. Therefore it is undisprovable.
17:44:13 <qloop> would this be the place to ask (possibly stupid) beginners' questions?
17:44:34 <Adamant> yes
17:44:34 <Gracenotes> regex, tumescent deterministic finite automaton
17:44:48 <dolio> Ah, I guess that makes sense.
17:44:54 <Saizan> qloop: sure
17:44:58 <Adamant> #haskell-in-depth isn't
17:44:58 <dolio> I can stop thinking about it, then.
17:45:11 <monochrom> When Chinese characters are used, usually we use larger fonts, e.g., 16 point instead of 12 point.
17:45:36 <ddarius> dolio: No, you can't show that it is false (because it may not be), but you can prove that it isn't provable.
17:45:43 <SamB> monochrom: wouldn't you be more worried about the *pixel* size ?
17:46:01 <monochrom> Perhaps 16 pixels instead of 12 pixels.
17:46:02 <mdmkolbe> grrr ... liberalised type synonyms don't seem to apply to type families.  (I'm trying to build a data type that is parameterizable over a type family that is passed to it's type constructor.)
17:46:02 <ddarius> SamB: Why?
17:46:04 <dolio> Hmm...
17:46:25 <SamB> ddarius: well, the glyphs need to rasterize
17:46:28 <monochrom> I don't know! Firefox says "12" and "16".
17:46:28 <ddarius> Well, I guess technically.
17:46:45 * Gracenotes is a fan of the zooming keys with this laptop
17:46:52 <ddarius> It's 72(?) points per inch so you need to worry about pixels per inch.
17:46:55 <qloop> ok... is there some way to add two IO Floats, and if so, how? the + operator (any any other operator for that matter) doesn't seem to be defined
17:46:57 <SamB> if you use too small a size, there will not be enough room for all of the holes!
17:47:00 <Gracenotes> although it still only zooms pixels, doesn't make it more readable
17:47:02 <qloop> and google didn't really work out either
17:47:04 <Gracenotes> qloop: liftM2
17:47:20 <Eelis> dolio: what is the type of the a variable there?
17:47:30 <sjanssen> qloop: do x <- ioFloatA; y <- ioFloatB; return (x + y)
17:47:34 <monochrom> I actually know. Firefox and GNOME are aware of screen DPI. When you ask for "16 point font" they try to use the right number of pixels.
17:47:36 * edwardk just started buying bigger and bigger monitors. solved the scaling problem ;)
17:47:37 <SamB> Gracenotes: you'd better explain what IO Floats are ...
17:47:47 <Gracenotes> qloop: you take the two floats and "lift" + into it
17:47:57 <Gracenotes> *IO floats
17:48:30 <Gracenotes> so liftM2 (+) float1 float2 :: IO Float. This does float1 before float2, so it's not commutative like normal + is
17:48:39 <dolio> Eelis: In a Haskell type it'd have some kind as a type.
17:49:03 <Eelis> dolio: oh, you're viewing it as a Haskell thing. never mind then.
17:49:06 <Gracenotes> @src liftM2
17:49:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:49:12 <Gracenotes> so equivalent to what sjanssen said
17:49:56 <Gracenotes> SamB: in this case, dunno :x
17:50:37 * ddarius just bought smaller and smaller pixels.
17:50:59 <monochrom> Smashing of tiny things.
17:51:07 <sjanssen> qloop: you might want to skip to the section on the IO Monad in whatever tutorial you're using
17:51:11 <dolio> Eelis: It has the type of whatever the domain of t is. :)
17:52:58 <Eelis> dolio: then the proposition is not true if it t is universally quantified, because then it should hold for an empty domain and t' = True, which it doesn't.
17:53:45 <monochrom> Sometimes non-empty domains are assumed. The proposition is still untrue for the reason I cited.
17:54:53 <Eelis> i can't find that citation
17:55:19 <Eelis> and clearly only a pervert would assume non-empty domains
17:55:34 * ddarius accuses monochrom of plagiarizing tautologies.
17:56:10 <monochrom> You can extend the [constructive] logic with classical axioms to break the proposition.
17:56:34 <Eelis> oh, you equate "unprovable" with "untrue" ?
17:57:07 <monochrom> Only a pervert would allow empty domains. Most logics in the literature and in theorem provers assume non-empty domains.
17:58:14 <qloop> Gracenotes, sjanssen: thanks, that seemed to do the trick
17:58:18 <Eelis> so much for jokes
17:58:24 <qloop> atleast for now
18:02:12 <chessguy> well, that was a conversation-killer
18:02:21 <Elly> er
18:02:29 <Elly> unprovable and false are different :P
18:03:22 <Eelis> sure, the real question is whether "untrue" and "false" are different ;)
18:03:35 <mdmkolbe> it depends on the logic
18:03:39 <Eelis> no shit.
18:04:18 * mdmkolbe goes off to put that in the @faq for #logic
18:04:31 <mdmkolbe> @faq
18:04:31 <lambdabot> The answer is: Yes! Haskell can do that.
18:08:30 <Gracenotes> how many MB is Haskell's recorded logs?
18:10:02 <dons> 600M or so, last i checked
18:10:05 <Cale> Gracenotes: I have a log file which only goes back to August 15 2008 and is 87 MB, I could dig up some older ones if you care.
18:10:26 <Gracenotes> nope, just wondering
18:10:37 <Gracenotes> lots of data :)
18:22:36 <guenni> since there is no imap library does anybody know of an imap.dll that can be used via ffi?
18:28:50 <saml> @hoogle email
18:28:51 <lambdabot> package hsemail
18:29:41 <saml> :t imap
18:29:42 <lambdabot> Not in scope: `imap'
18:30:08 <saml> > imap (+ 1) (return ())
18:30:10 <lambdabot>   Not in scope: `imap'
18:30:15 <guenni> saml: well thanks, I wasn't aware of that package
18:30:54 <saml> guenni, are you trying to send/get email from haskell?
18:31:08 <mdmkolbe> Is there some kind of type debugger for haskell? (Note I've got GADTs, and type families floating around here)
18:31:19 <guenni> saml: yes
18:31:22 <saml> maybe ghci mdmkolbe ?
18:31:51 <mdmkolbe> sami: how?  (note I'm talking about debuging the type inference not the execution)
18:32:54 <ddarius> mdmkolbe: The Chameleon system has a type debugger that can be used on Haskell, but it won't understand most extensions and definitely not those.
18:35:01 <SamB> mdmkolbe: well ... you could have GHC trace the type-checking process, but you probably won't get much out of the results ...
18:35:46 <SamB> which is to say I find such traces largely incomprehensible
18:35:48 <saml> guenni, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MissingH  this seems to have sendmail but it's not working for windows.. i have no idea how to send emails or get emails from haskell actually
18:36:10 <saml> that package has Network.Email.Sendmail
18:36:18 <guenni> saml: thx
18:36:44 <SamB> saml: well, usually when *I* do anything in windows that results in an attempt to send email, outlook tries to do it but isn't configured
18:37:12 <SamB> (Well, at school anyway.)
18:38:56 <saml> sending email is hard from your local machine even with linux.. and not get yoru emails flagged as spam
18:39:10 <Axman6> woah, sshing from uni, thought it was that was blocked. whoot
18:41:04 <guenni> well for know I'd just be happy to access my own email via imap
18:41:44 <guenni> but since there is no haskell lib for that, someone on the mailinglist suggested to use an imap.dll via ffi
18:41:57 <guenni> and that's what I'm gonna do
18:42:05 * SamB is puzzled by log entries like this:
18:42:13 <SamB> Feb 15 06:49:47 hydrogen exim[11866]: 2009-02-15 06:49:47 1LYfTI-00035O-82 faile
18:42:13 <SamB> d to write to main log: length=134 result=-1 errno=28 (No space left on device)
18:42:13 <SamB> Feb 15 06:49:47 hydrogen exim[11866]: write failed on panic log: length=122 resu
18:42:13 <SamB> lt=-1 errno=28 (No space left on device)
18:42:13 <SamB> ~
18:42:23 <guenni> I just need to find an imap.dll first and then hopefully some docs
18:42:38 <saml> i'd guess for that, you use network to open socket and use hsemail to parse imap.. but that's just a guess.
18:43:04 <SamB> aren't those things on /var just like that log entry is ?
18:43:35 <andyjgill> Does anyone has experience using OpenGL from the ghci command line?
18:44:17 <mdmkolbe> Ok, so here is what I've been able to boil the type problem down to: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1692#a1692  (The infinate loops in there are due to boiling it down.  The original code should terminate)  Any ideas on how to solve this?
18:45:06 <chrisdone> andyjgill: I think I did a bit. at least I used glut. tended to end ghci when the main loop ended though
18:46:32 <andyjgill> I'm wondering aboutt GLUT vs other libraries, and which will continue to work as you restart the program.
18:51:21 <chrisdone> couldn't say
19:03:14 <chrisdone> why isn't gtk2hs on hackage?
19:03:37 <dcoutts> chrisdone: it's build system is a bit complex, more so than cabal can handle yet
19:04:03 <chrisdone> ok
19:04:26 <Gracenotes> dcoutts: hm. is the same thing true with, say, curl?
19:04:51 <chrisdone> is there a libcurl package on Hackage?
19:05:01 <Gracenotes> @hackage curl
19:05:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/curl
19:05:12 <Gracenotes> not sure if it's caballized though
19:05:24 <dcoutts> Gracenotes: everything on hackage uses cabal
19:05:41 <Gracenotes> oh. I see :X
19:06:07 <Gracenotes> hm, I don't even have curl on my computer yet. I've just used wget and 'converted' curl commands to wgets
19:06:08 <dcoutts> they do not have to use the default build system, but they have to be cabal packages as defined in the Cabal spec
19:06:28 <Gracenotes> lemme try to install the curl package :)
19:06:44 <Gracenotes> yep. >configure: error: curl libraries not found, so curl package cannot be built
19:07:12 <Gracenotes> how much more complicated is it for gtk2hs...?
19:07:55 <dcoutts> Gracenotes: it uses a pre-processor that requires tracking deps between .chs files. Cabal cannot yet do that. gtk2hs also uses two custom pre-processors.
19:08:21 <Gracenotes> chs?
19:09:10 <Gracenotes> oh... duh
19:20:46 <chrisdone> if I'm receiving webcam images 30 times a second, how can I display this graphically?
19:21:31 <SubStack> mplayer can do that if it's v4l
19:21:54 <chrisdone> I mean from haskell
19:22:50 <gwern> any familiar with Data.Sequence? is there a more sensible way to check for an empty Seq than seeing whether length == 0?
19:22:57 <gwern> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html#v%3Aempty
19:22:57 <SubStack> gtk, sdl, glut bindings...
19:23:28 <chrisdone> SubStack: how do you render an image from memory with those libraries?
19:23:46 <SubStack> depends considerably!
19:23:57 <chrisdone> on what?
19:24:11 <gwern> the phase of the moon
19:24:20 <gwern> and whether this is the dawning of the age of aquarius
19:24:36 * gwern notes that this buffer-local state stuff in Yi is awfully hard
19:24:41 <SubStack> the manners in which images are rendered using those libraries varies considerably
19:24:51 <SubStack> 3d textures and drawing context and whatever sdl uses
19:25:48 <gwern> (also, yi needs to spin some code off so my compiles don't take so long!)
19:28:00 <BMeph> gwern: Just curious, but what's wrong with 'null'? :)
19:28:24 <gwern> doh
19:28:49 <chrisdone> null = (==0) . length, don't believe their lies
19:28:58 <gwern> 'tis shorter
19:29:16 <roconnor> > null (repeat 0)
19:29:17 <lambdabot>   False
19:29:28 <roconnor> > ((==0) . length) (repeat 0)
19:29:43 <lambdabot>   thread killed
19:29:51 <roconnor> oh
19:29:57 <roconnor> Data.Sequence
19:30:04 <roconnor> I guess I should read the scrollback
19:30:27 <monochrom> Data.Sequence.null exists too.
19:30:40 <roconnor> @src Data.Sequence.null
19:30:40 <lambdabot> Source not found.
19:30:45 <gwern> yes, which is why I was saying d'oh, I missed it
19:30:48 <Gracenotes> :O
19:30:53 <Gracenotes> gwern: :O
19:30:54 <roconnor> lambdabot: thanks for not bitching
19:31:08 <chrisdone> preflex: be roconnor
19:31:08 <preflex>  no quotes found for roconnor
19:32:56 <monochrom> But real programmers do null . fmap (const ()) . reverse . (mappend empty)
19:33:04 <chrisdone> haha
19:33:44 <gwern> woo. my ireader mode is now lickety-split fast
19:33:48 <gwern> it is also compeltely broken
19:34:27 <BMeph> gwern: I disagree.
19:34:45 <gwern> BMeph: oh yeah? on what authority?
19:34:49 <BMeph> gwern: If you're using null now, then it's only incompletely broken. ;p
19:35:21 * gwern misses the joke
19:35:28 <juhp> where does hspwd come from (needed by darcs/tests)
19:35:31 <juhp> ?
19:36:03 <gwern> short utility defined in the same dir
19:36:15 <juhp> gwern: ah thanks
19:36:17 * BMeph means to point out that it does part of what it's supposed to. Maybe not very much of what it's supposed to, but some is not none.
19:36:41 <juhp> gwern: hm not in hackage ;)
19:37:04 <gwern> probably not included in the tarball. I doubt the whole testing infrastructure is there
19:37:14 <gwern> if you're developing, should work off the darcs darcs
19:40:05 <gwern> ok, so the bug is just that the initialization code erases the user data... but it looks fine to me. hm.
19:47:40 <shapr> yay, more people for the Boston Haskell User's Group!
19:48:10 <gwern> bleh
19:48:20 <cjb> shapr: :) is there a mailing list somewhere?
19:48:20 <gwern> just realized null returns True if it's empty, not false
19:48:38 <gwern> that would certainly explain this behavior...
19:48:40 <shapr> cjb: Um, no...
19:48:49 <shapr> cjb: Work has been keeping me furiously busy.
19:49:05 <shapr> cjb: The BlueSpec conference room can seat 15 comfortably, and 20 with standing room.
19:49:24 <shapr> I'm estimating we get 15 people, but there could be more than 20.
19:49:28 <roconnor> gwern: should have used dependent types :P
19:49:28 <gwern> shapr: you should tell'em to relax, as the global economy is slowing down, there's no need to be furiously busy
19:49:47 <shapr> I'm also desperately wishing for someone else to present nifty code.
19:49:58 <gwern> roconnor: I was actually thinkign 'maybe we should make True and False entirely different types', but I suppose dependent types would do as much
19:50:04 <shapr> I don't think a (my) QuickCheck presentation will be overly spiffy.
19:50:39 <SubStack> it'd be fun to present some of my haskell projects
19:50:50 <SubStack> but this town is too tiny I expect
19:51:09 <SubStack> maybe I could get the LUG revived
19:51:29 <gwern> whew! seems to work!
19:51:54 <shapr> SubStack: You could show up in Boston?
19:52:02 <gwern> (between seq and buffer-local variable, much faster)
19:52:04 <SubStack> a bit far away considering I'm in Alaska
19:52:06 <shapr> oh, alaska.edu? I think not.
19:52:26 <shapr> SubStack: Clearly you should visit PortlanD!
19:52:36 <shapr> They have the largest concentration of Haskell goodness anywhere!
19:52:39 <shapr> Except maybe Chalmers...
19:52:42 * SubStack lived there until he was 10
19:52:50 <shapr> Well, there's East Cambridge as well...
19:54:08 <senxhnsshp> what is a good topology exercise to program in haskell?
19:55:11 <gwern> colorign graph registers
19:56:11 <monochrom> Trivially and vacuously, every buggy program is only incompletely broken, not completely broken. Proof: if you run it for 0 steps or time units, nothing will happen, which is the right behaviour.
19:57:48 <roconnor> find a program of type ((Nat -> Bool) -> Bool) -> ((Nat -> Bool) -> Bool) -> Bool) that returns True iff the inputs are equal
19:57:58 <roconnor> maybe that isn't a _good_ exercise
19:59:09 <pumpkin_> ?
19:59:51 <roconnor> 
19:59:58 <monochrom> Is that even possible?
20:00:02 <Gracenotes> roconnor: what sort of parameter is ((Nat -> Bool) -> Bool) :?
20:00:25 <roconnor> it is a predicate on a cantor space
20:00:48 <Gracenotes> oh, cantor.
20:00:59 <QtPlatypus> roconnor: Isn't that equiverlent to the halting problem?
20:01:34 <monochrom> Using "X->Bool is like PowerSet(X) or Set of X", that is P(P(Nat)) or sets of sets of Nat. Typical value is {{3,2,4}, {2,9,8}}.
20:01:46 <roconnor> QtPlatypus: not if it only is going to work on continuous functions
20:01:51 <monochrom> It's equivalent to the nonhalting problem.
20:02:21 <monochrom> "returns False iff the inputs are different" would be equivalent to the halting problem.
20:02:55 <roconnor> QtPlatypus: which is why this is a topology problem
20:05:12 <chrisdone> orbitz: man I need more poppavic quotes
20:05:19 <chrisdone> preflex: be poppavic
20:05:19 <preflex>  remember - C is compiled, not assembled.
20:09:35 <jrockway> hmm, is there a way to get "undo" (C-/) to work in the newer ghcis (that don't use readline)?
20:09:48 <jrockway> i keep pressing C-w, which doesn't do the right thing anymore, and that I can't recover from with C-/
20:10:20 <monochrom> There was undo? I be damned.
20:10:48 <jrockway> it's a readline thing, yeah
20:11:10 <monochrom> I be really damned. It had undo!
20:12:08 <monochrom> If you know how to hunt down the key bindings of editline, you may find out how to undo.
20:12:55 <jrockway> it would be nice if editline just read my .inputrc :)
20:13:00 <jrockway> but i will take a look
20:16:06 <jrockway> (incidentally, the editline conversion also breaks the emacs interface to ghci)
20:18:33 <monochrom> some file under /etc controls editline. some post on glasgow-haskell-users mailing list had a contributed config file to config it to more familiar key bindings.
20:32:06 <jrockway> i find it ironic that the FSF wants to make free software (like ghc) harder to use (by licensing readline under the GPL)
20:32:30 <sjanssen> jrockway: FSF has a different definition of "free" than you do
20:32:31 <cjb> jrockway: I think it's pretty clear that this isn't actually their goal
20:32:46 <jrockway> either way, "rlwrap" makes my problems go away :)
20:32:58 <sjanssen> jrockway: you lose completion support, however
20:32:59 <jrockway> and tab completion still works as well
20:33:06 <jrockway> apparently not, i just tried it :)
20:33:21 <sjanssen> interesting
20:37:16 <monochrom> FSF also has a different definition of "hard".
20:37:53 <joed> monochrom: FSF has a crumblie falling out of your beard definition of most things.
20:37:56 <BMeph> monochrom: And don't forget their "alternative" definition of "PITA"... ;p
20:38:14 <monochrom> ...
20:39:32 <monochrom> The goal of GPL is to make it hard to keep derivatives secret.
20:39:56 <jrockway> yeah, i understand the goal of the GPL, and i respect the FSF
20:40:05 <jrockway> however, legally requiring people to play nice together never works
20:40:16 <jrockway> otherwise we wouldn't have ... crime
20:40:18 <joed> It is somewhat succesful as well, the cost of respecting it is astronomical.
20:40:24 <cjb> jrockway: you say that, but one of these licenses has like 80% mindshare, and it isn't the BSD one
20:40:43 <joed> Sadly that cost is sitting on the poor GPL holder.
20:40:51 <jrockway> yeah, iono
20:40:54 <senxhnsshp> what is a good topology exercise to program in haskell?
20:41:09 <jrockway> I will contribute code to a project regardless of its license (within reason), and I think most other people are the same way
20:41:16 <jrockway> i don't mean to set off a licensing rant, though :)
20:41:23 <cjb> joed: *shrug* no-one forced them to use GPL code.  It's no different to proprietary -- if you want it, you need to follow the terms, else just do something else.
20:41:59 <jrockway> it is a shame that GHC can't choose to be "more free", though
20:42:18 <jrockway> i mean, the "requirements" of the GPL are met -- ghc is free for everyone to use, modify, and redistribute
20:42:19 <joed> cjb: Ah, If I write GPL code, you use it, and I cannot afford to sue you?
20:42:41 <cjb> joed: the FSF will happily do it for you
20:43:03 <cjb> as would the Software Freedom Law Center, or the Software Freedom Conservancy.  you'd have no shortage of free legal aid.
20:43:12 <jrockway> depends on the project
20:43:18 <cjb> all of these groups provide pro bono legal advice to free software projects
20:43:22 <joed> cjb: It depends.
20:43:25 <jrockway> i doubt anyone would protect my tiny libraries
20:43:36 <jrockway> they only care about 'high-profile' things, like Linux and busybox
20:43:41 <cjb> jrockway: the FSF are pretty enthusiastic about this sort of thing :)
20:43:42 <jrockway> which is definitely fine
20:43:44 <joed> cjb: And no they won't if I consult on it.
20:44:04 <sjanssen> jrockway, joed, cjb: can we redirect this conversation to #haskell-blah or elsewhere?
20:44:14 <cjb> yeah, okay, we can just stop :)
20:44:20 <jrockway> yeah, i am not really interested in discussing this
20:44:25 * joed nods. Point taken.
20:44:30 <jrockway> rlwrap fixes my problem
20:44:39 <jrockway> and "cat | ghci" fixes the emacs problem
20:50:00 <redditbot> Mwhahaha! A haskell-xmpp library ... lambdabot, are you listening?
20:50:42 * ddarius makes a reddit topic with lambdabot commands in it.
20:51:09 <sjanssen> :)
20:52:01 <monochrom> Like @stop trolls ?
20:52:14 <monochrom> @stop monochrom
20:52:14 <lambdabot> Maybe you meant: show slap
20:52:23 <monochrom> busted
20:52:33 <ddarius> <redditbot> @slap monochrom
20:52:57 <monochrom> I like the mutation @stab. It's more violent.
20:53:01 <monochrom> @stab monochrom
20:53:01 * lambdabot hits monochrom with a hammer, so they breaks into a thousand pieces
20:53:20 <ddarius> "they"?
20:53:37 <monochrom> They made lambdabot politically correct. Yeah, they.
20:54:13 <Axman6> but they aren't they until they've broken...
20:54:45 <jrockway> "he or she" is so much harder to type than "they"
20:54:52 <jrockway> correctness, whoneedsit?
20:55:21 <sjanssen> "they breaks" is just laziness
20:56:05 <Axman6> using they instead of 'he or she' works fine, and i don't think there's any real reason to oppose its use
20:56:14 <Axman6> but, i'm an engineer, wtf would i know :)
20:56:24 <sjanssen> is that actually grammatically correct?
20:56:34 <ddarius> sjanssen: "they breaks"?  No.
20:56:51 <Axman6> they broke would be ok though
20:57:09 <ddarius> Axman6: Not in the full context.
20:57:22 <Axman6> yeah
20:57:48 <jrockway> yeah, that is really the more pressing error :)
20:58:15 <monochrom> I heard that this kind of "they" dated back to 18xx and therefore has been perfectly correct.
20:58:25 <sjanssen> "they breaks" seems like a translation from German or something
20:58:26 <jrockway> btw, i have another potentially off-topic question: are there any plans to have haskell conferences that are less "academic"
20:58:39 <jrockway> i have spoken at a lot of programming conferences, but i have never had to submit a paper :)
20:59:03 <SubStack> I herd you like abstracts
20:59:05 <ddarius> Most of them aren't "academic."  I don't think any require you to submit a paper.
20:59:16 <jrockway> ah, ok
21:00:35 <jrockway> i guess I saw ACM and SIGPLAN and immediately thought "only for academics" :)
21:01:31 <monochrom> Most talks will be academically inclined.
21:02:07 <jrockway> yeah, i don't really mind listening to that kind of talk, but it's not the sort of conference i am used to participating in
21:02:26 <shapr> jrockway: There are lots of Haskell conferences that are just for fun!
21:02:41 <ddarius> I believe most Haskell-specific get-togethers are extremely informal and very much like most other programming language get-togethers.
21:02:47 <jrockway> that is more of the kind of conference i am used to
21:03:04 <jrockway> if anyone has ever been to YAPC (or PyCon, probably), that is what I have in mind when I think "programming conference"
21:03:12 <jrockway> there are talks, then everyone goes and has beer or whatever
21:03:26 <jrockway> and the talks are more of the "here's what I did with $foo" or "here's my new library"
21:03:26 <shapr> jrockway: EuroHaskell happened right after EuroPython
21:03:39 <shapr> jrockway: Yah, EuroHaskell started out as "beer and code"
21:03:46 <shapr> and the motto was "more code, less talk"
21:03:46 <ddarius> jrockway: What gives you the impression that it is not this way for Haskell?
21:04:00 <sjanssen> jrockway: I think the closest thing to that would be the various Haskell user groups and hackathons
21:04:08 <shapr> jrockway: AngloHaskell was very similar, we all went to the pub after the academic talks.
21:04:14 <sjanssen> (not having been to anything like this myself)
21:04:30 <shapr> jrockway: For example, #haskell itself was started by a guy with NO DEGREE and NO COMPUTER SCIENCE BACKGROUND!
21:04:35 <shapr> Isn't that AMAZING?
21:04:42 <jrockway> heh :)
21:04:47 * shapr grins
21:04:51 <ddarius> shapr: All you have to do to start a channel is join it.
21:04:55 <shapr> right, well
21:04:58 <shapr> I didn't say it was hard.
21:05:16 <jrockway> but yeah, i am pretty new to the community, so any knowledge i have is a result of googling for "haskell conference"
21:05:16 * ddarius stops bursting shapr's bubble.
21:05:20 * shapr snickers
21:05:31 <shapr> jrockway: Clearly, you should hang out here with all the cool kids.
21:05:36 <shapr> jrockway: Or wait, are you in Boston?
21:05:36 <jrockway> yeah
21:05:39 <jrockway> no, chicago
21:05:42 <shapr> dang
21:05:49 <shapr> There's a Haskell User's Group meeting in Boston this weeknd.
21:05:55 <jrockway> ahh, cool
21:05:56 <shapr> in fact, it was organized by that SAME GUY!
21:05:59 <jrockway> i will be in boston for the lisp conference next month
21:05:59 <shapr> with NO DEGREE!
21:05:59 <shapr> ok ok
21:06:05 <dolio> Plus, the guy who founded #haskell is plagued by chronic boinging.
21:06:10 * shapr laughs
21:06:20 <shapr> jrockway: Awesome! I'll buy you a beer!
21:06:58 <shapr> jrockway: And I'll introduce you to lots of Haskellers if I can scrape 'em up.
21:07:07 <ddarius> shapr: If that guy's boss gets his way, that guy will no longer be able to say "with NO DEGREE"
21:07:09 <shapr> I'm hoping for fifteen or twenty at the first user's group on Saturday.
21:07:13 <shapr> ddarius: This is true :-)
21:07:17 <jrockway> cool
21:07:26 <shapr> But it's been a good story so far!
21:07:37 <shapr> jrockway: I'm sure I can scrape up two or three, maybe even four or five.
21:07:40 <ddarius> jrockway: shapr has photographic evidence of Simon Peyton Jones on a unicycle at some kind of Haskell get-together.
21:07:45 <shapr> Also true!
21:07:55 <shapr> Heck, I have a collection of famous functional programming language researchers on unicycles!
21:07:59 <shapr> Quite seriously, I do!
21:07:59 * blackh feels left out and will have to remain aloof and mysterious, being located very near the edge of the world.
21:08:22 <shapr> jrockway: The Haskell community is not nearly as stick-in-the-mud as some people think.
21:08:24 <sjanssen> blackh: the world has an edge?
21:08:31 <shapr> Unless of course, they just fell off a unicycle.
21:08:40 <jrockway> heh, i gathered that much
21:08:43 <jrockway> but sometimes you never know :)
21:08:53 <blackh> sjanssen: Yes - it's right near here.  Ships fall off sometimes.
21:08:55 <jrockway> i mean, clearly all the cool kids use ruby exclusively ;)
21:09:04 <shapr> Yeah, a lot of them do.
21:09:12 <shapr> I'm not all exclusive and stuff.
21:09:23 <shapr> I'm like ... 'There are neat things in this world.' TELL ME ABOUT MORE OF THEM!
21:09:37 <SubStack> haskell is way more hip than ruby I'd say
21:09:37 <shapr> and like, Haskell is clearly one of those cool things you should pick up..
21:09:41 <jrockway> yeah, exactly
21:09:44 <SubStack> ruby is *so* 2005
21:09:44 <shapr> Haskell has shiny toys to charm your mind!
21:09:48 <ddarius> And then shapr gets an earful of category theoretic drugdery.
21:09:51 <jrockway> programming langauges are exactly the sort of thing to not get religious about
21:10:06 <shapr> Actually, I was getting harangued about monoids and groupoids today at lunch.
21:10:11 <shapr> It was pretty cool!
21:10:14 <SubStack> shapr: me too @ neat things
21:10:15 <glguy> ruby?
21:10:21 <shapr> glguy: Shiny, red.
21:10:24 <SubStack> shiny things
21:10:27 <shapr> SHINY!
21:10:30 <glguy> oh, I got my wife one  for v-day!
21:10:36 <shapr> glguy: oooh nifty!
21:10:46 <shapr> SubStack: Yah, shiny is good.
21:10:49 <shapr> Haskell is shiny.
21:10:57 <shapr> But there is also other shiny stuff too.
21:10:58 <SamB> which is why the only code I wrote today was in Python and SQL
21:11:04 <SamB> at least, as far as I can remember ;-)
21:11:21 <shapr> jrockway: So yeah, I'll buy you a beer, and try not to become sufficiently inebriated to speak Swedish.
21:11:25 <SamB> (programming languages not being the sort of thing to get religious about)
21:11:30 <SubStack> I wrote some ruby at work in a very haskellish fashion
21:11:32 * SamB prefers to be religious about religion
21:11:36 <shapr> SubStack: Cool! How did it turn out?
21:11:41 <SubStack> well, ruby 1.9 has function composition built in
21:11:47 <SubStack> but we're mostly just using ruby 1.8
21:11:57 * ddarius has only written C# and battled with CSS today.
21:11:57 <shapr> jrockway: So, have you been reading Real World Haskell online?
21:11:58 <SubStack> so a few lines of hack to get that in there
21:12:15 <jrockway> shapr: actually, i bought the dead tree version
21:12:20 <ddarius> And except that I should probably go to sleep, I'll probably write Haskell today too.
21:12:23 <shapr> oh, me too!
21:12:29 <jrockway> but i was using haskell on-and-off before that
21:12:44 <shapr> oh oh, me too!
21:12:52 <ddarius> shapr: ?
21:12:58 <SubStack> it's a fancy script that takes a shape file and builds a big map to fill it with map server data
21:13:00 <shapr> um, I wrote Haskell before I bought RWH.
21:13:14 <shapr> ddarius: ooh, I did capoeira today too.
21:13:14 * SubStack still hasn't picked up a copy
21:13:17 <jrockway> haskell didn't really click with me until we decided to start using it for work
21:13:23 <shapr> jrockway: really?
21:13:24 <jrockway> then i made an actual effort to learn it
21:13:25 <SubStack> looked at some of the pages online, looks like a good book anyways
21:13:26 <ddarius> shapr: I very highly suspect that you've written way more Haskell before reading RWH than after.
21:13:32 <shapr> SubStack: It's neat, I want to get my copy autographed by the authors.
21:13:36 <shapr> I hope I can track them down someday.
21:13:40 <jrockway> i did the usual things, "omg i can write a tree in so few lines of code"
21:13:47 <shapr> dons said he may stop by Boston on his way to Utrecht for the HackFest.
21:13:48 <jrockway> but that does not really make an application :)
21:13:57 <shapr> Clearly there should be a Boston Haskell User's Group organized for that sort of gathering.
21:14:08 <shapr> jrockway: What did you do with Haskell at work?
21:14:15 <SubStack> writing glut apps forces you to learn monads pretty quick
21:14:16 <shapr> ddarius: You are correct!
21:14:23 <jrockway> we sell a load testing service, and are rewriting the acutal tester in haskell
21:14:24 <shapr> ddarius: I haven't written much Haskell at all lately.
21:14:28 <shapr> whoa nifty
21:14:29 <jrockway> it works much better than the C versions
21:14:32 <jrockway> (and perl versions)
21:14:36 <shapr> That's awesome!
21:14:43 <shapr> Wait, you don't work for quviq, do you?
21:14:45 <SubStack> the glut bindings are so much shinier than the c counterparts
21:14:46 <jrockway> nope
21:14:50 <SubStack> on account of the monads
21:14:51 <shapr> ok
21:14:55 <shapr> SHINY!
21:15:02 <SamB> SubStack: and here I thought it was shaders!
21:15:09 <SubStack> you can do shaders too!
21:15:16 <jrockway> (actually, nothingmuch has written all of the code, so give him any credit for doing it :)
21:15:16 <SubStack> well, if you have the hardware
21:15:21 <SamB> SubStack: that made it shinier, I mean
21:15:26 <SubStack> it's true
21:15:33 <jrockway> the only "real app" i have written in haskell is a command-line client for communicating with generic persistent processes
21:15:38 <jrockway> (see my app-persistent github)
21:15:42 <SamB> and now you tell me it's *monads*?
21:15:46 <jrockway> anyway, writing that app made it all come together for me
21:15:50 <jrockway> "monads are easy", etc ;)
21:15:55 <SubStack> I want to make a real compatability layer so I can see the slow but correct version of the shader output despite my laptop being the suck
21:16:09 <SamB> jrockway: github is a service that hosts git repositories ...
21:16:21 <jrockway> heh
21:16:29 <SubStack> and then I can just run it on a nice computer and it'll look the same but be crazy fast
21:16:33 <SamB> might want to rename your thing ;-)
21:16:34 <jrockway> github == "repository hosted on github" ;)
21:16:39 <SamB> oh!
21:17:14 <SubStack> pesky graphics cards
21:18:18 <shapr> jrockway: Clearly you have joined the cool kids, out behind the library, talking about monads.
21:18:30 <gaze__> what happens if I block in some FFI thing?
21:18:52 <SamB> jrockway: I'm not sure I can scroll that far down on 32-bit
21:18:55 <SamB> wait, app starts with an a
21:18:57 <SamB> hehehe
21:19:44 <jrockway> heh
21:19:46 * SubStack monads it up a notch
21:19:53 <sjanssen> gaze__: are you running the non-threaded or threaded RTS?
21:20:09 <gaze__> well, I'd like to know the behavior in both
21:20:32 <sjanssen> in the non-threaded RTS the whole runtime will block until the foreign call returns
21:21:03 <sjanssen> in the threaded RTS, a separate OS thread is used for blocking foreign calls, so other threads continue to run
21:21:43 <sjanssen> also, foreign calls can't be interrupted by exceptions
21:22:03 <gaze__> ooh cool, okay
21:22:09 <gaze__> yeah I figured
21:22:26 <SamB> look what I made today: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1693#a1693
21:23:01 <glguy> a python program??
21:23:06 <SamB> yes!
21:23:06 <glguy> :-p
21:23:11 <SamB> but it's for LHC
21:23:29 <SamB> my excuse is that no Haskell bindings for sqlite are installed on nun
21:23:41 <BMeph> SamB: You know, they have support groups for Python programming. You can get help... ;p
21:24:07 <SamB> BMeph: but #python has gone to the dogs! I don't think they'd be much use to me these days
21:24:08 <SubStack> I hear they box them up and put them on airplanes.
21:24:29 <SamB> SubStack: ah, you've heard about the web framework?
21:24:36 <SamB> @quote screw ruby
21:24:36 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
21:24:41 <SamB> @quote screw.ruby
21:24:42 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
21:25:01 <jrockway> very catchy
21:25:13 <SamB> unfortunately also fictional ;-P
21:25:28 <jrockway> the foo on bar pattern really only worked for ruby
21:25:32 * SubStack thinks python can be ok, if a bit dull
21:25:41 <jrockway> perl tried to start "perl on poles" (for maypole), but it didn't stick
21:25:47 <jrockway> perhaps because maypole sucked ;)
21:26:10 <Axman6> perl on poles sounds very gay
21:26:34 <jrockway> it kinds of sounds like what you'd do to perl after you killed it
21:26:39 <jrockway> parade its head around on poles
21:27:14 <SamB> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1693#a1694
21:27:17 <jrockway> (not to be anti-perl though, perl is the best out of the ruby/python/perl family ;)
21:27:22 <SamB> that's the code if you care
21:27:31 * SubStack ranks them: perl, ruby, python
21:27:59 <jrockway> it's kind of a tie between ruby and python
21:28:13 <SamB> I've always been partial to python, but then Python was my first favorite language
21:28:16 <jrockway> python has weird ideas about programming, and ruby has common idioms like "lload a module which modifies 10 other classes"
21:28:31 <SamB> wierd ideas about programming ?
21:28:39 <jrockway> like, "use a class instead of a closure"
21:28:44 <SamB> eh ?
21:28:57 <SubStack> ruby is getting more functional goodness while python is taking it away
21:29:02 <jrockway> yeah
21:29:05 <SamB> those ARE closures
21:29:06 <SamB> ;-P
21:29:14 <jrockway> says the python programmer :)
21:29:40 <SamB> and you can just as easily use function-closures as class-closures
21:29:40 <SubStack> the lack of *proper* scope is annoying though
21:29:46 <SubStack> in ruby and python
21:29:53 <SamB> proper being ?
21:30:01 <SubStack> for all blocks like how perl does it
21:30:10 <SamB> oh
21:30:14 <jrockway> perl does do a good job with scoping
21:30:24 <jrockway> i also appreciate having to declare variables before using them
21:30:25 <Axman6> wow... i've had 150 hits from reddit.com/ (as opposed to /r/haskell/)
21:30:27 <SamB> you mean like in C how {} delimit a scope ?
21:30:41 <SubStack> yeah
21:31:16 <SamB> yeah, Python hasn't got a great track record with that (list comprehensions used to leave droppings -- do they still ?)
21:31:47 <jrockway> i am also amused by python3k's scores on the programming language shootout
21:31:59 <jrockway> the same programs run slower in python 3 than in python 2
21:32:04 <jrockway> not exactly The Way Forward, imho
21:32:05 <SamB> but python is the one thing on nun guarenteed to be able to interface with the trac database
21:32:15 <SamB> because trac is written in python
21:32:34 <glguy> jrockway, kind of like ghc 6.10.1, eh?
21:32:34 <SubStack> at any rate, languages are getting much friendlier and fun
21:32:35 <SamB> jrockway: I've always been either amused or horrified at the idea of python 3k
21:33:01 <SubStack> even as some language devolve into something terrible
21:33:06 <SamB> depending on how seriously I took the possibility of it's being adopted
21:33:16 <jrockway> glguy: and perl 5.10.0, which made passing arguments to functions slower
21:33:20 <SamB> at this point I don't see it going anyway
21:33:22 <jrockway> (fortunately that was fixed quickly)
21:33:23 <SamB> er. anywhere
21:33:24 <sjanssen> glguy: programs run slower in 6.10.1?
21:33:42 <glguy> sjanssen, some
21:33:51 <glguy> the inliner seems kind of unpredicable
21:33:57 <SamB> I don't anticipate needing python 3k until, oh, 3k
21:33:59 <sjanssen> wasn't it always?
21:34:04 <Axman6> sjanssen: the pidigits one from the shootout does, triggers an Integer bug in 6.10.1 which causes it not to deallocate or something
21:34:05 <glguy> got worse?
21:34:14 <glguy> sjanssen, and the results on the shootout were mixed as well
21:34:21 <SamB> sjanssen: correlary: inliner changes are a bit unpredictable as well
21:34:57 <glguy> I had crypto code take ~10x hit with the switch
21:35:32 <glguy> and compiling got waaaaaay slower with large sets of constants
21:38:42 <thoughtpolice> the Integer bug is apparently fixed for ghc 6.10.2
21:38:56 <thoughtpolice> not sure about the compile-time bug re. lots of constants, though
21:39:14 <Axman6> thoughtpolice: yeah it's supposed to have been fixed
21:44:57 <Axman6> ha, screw IE. visitors to my site using IE make up 2.84% of my traffic.
21:45:15 <pumpkin_> bah
21:45:25 <pumpkin_> this is frustrating
21:45:27 <Axman6> almost 60% firefox
21:45:32 * Axman6 hugs pumpkin_ 
21:46:34 <monochrom> Nice.
21:47:44 <jrockway> that 2% will send you a lot of hate mail if you block them, though
21:47:59 <Axman6> jrockway: they can suck it up then :)
21:47:59 <jrockway> i used to serve xhtml as ... xhtml, which broke IE
21:48:01 <jrockway> yeah
21:48:16 <SamB> jrockway: how will they figure out his email address ?
21:48:16 <jrockway> i was surprised people wanted to read my blog so badly that they actually sent me email about it
21:48:18 <Axman6> i need a new main page for my site
21:48:19 <monochrom> No one is blocking them. Just rendered unpleasantly.
21:48:20 <jrockway> dunno
21:48:30 <Heffalump> I thought  it was firefox users that sent hate mail
21:48:45 <SamB> Heffalump: when ?
21:48:55 <Heffalump> a couple of years back mainly
21:49:04 <SamB> about ?
21:49:07 <SubStack> they can just write a greasemonkey script real quick that fixes it
21:49:12 <SubStack> IE users are powerless
21:49:22 <jrockway> back in the day, when online banking sites only worked in IE4 or whatever
21:49:25 <Heffalump> lack of FF compatibility
21:49:26 <monochrom> My http://www.vex.net/~trebla/haskell/ is deliberately xhtml. I advertised it just here. No one complained.
21:49:27 <jrockway> fortunately that era is mostly gone
21:49:28 <Heffalump> yeah, precisely
21:49:49 <SamB> so does IE still not do XHTML ?
21:49:54 <jrockway> dunno
21:49:59 * wli typically writes HTML with nvi-1.79 conformant to HTML-1.1 and so scares off IE users in a different manner entirely.
21:50:01 <redditbot> Loop unrolling with Template Haskell, applied to mandelbrot
21:50:03 <jrockway> i eventually caved and removed non-HTML markup from my XML
21:50:06 <jrockway> and started serving it as HTML
21:50:07 <SamB> even my school installs firefox everywhere now ...
21:50:10 <SubStack> because all the web designers are using ff or safari and then hacking together IE support after-the-fact
21:50:22 <jrockway> exactly
21:50:27 <jrockway> that is what I do, anyway ;)
21:50:39 <jrockway> "you guys still use IE?  wow..."
21:50:43 <SamB> there's not much else you can do about IE
21:50:43 <monochrom> Hmm html 1.1
21:50:49 <Axman6> my girlfriend's uni was apparently removing firefox...
21:50:49 <SubStack> I don't even test in IE for my own stuff ;)
21:50:54 <Axman6> like seriously, wtf
21:51:08 <jrockway> when i was in school, we didn't have firefox installed on the lab machines, because it wasn't 1.0 yet
21:51:14 <SamB> Axman6: in favour of IE ?
21:51:18 <jrockway> and only software greater than version 1.0 can be installed, according to their policy
21:51:28 <SubStack> I remember when it was firebird
21:51:30 <SamB> jrockway: that's pretty idiotic policy
21:51:33 <jrockway> yeah :)
21:51:34 <SubStack> not when it was pheonix though
21:51:39 <pumpkin_> back in my day, we didn't have web browsers
21:51:42 <jrockway> i didn't tell them that emacs 21 was actually emacs 0.21...
21:51:43 <pumpkin_> we browsed the web with nc
21:51:44 <SamB> I remember when it was Msomething-or-other
21:51:53 <SamB> jrockway: it isn't!
21:52:10 <jrockway> was there ever an emacs 1.0?
21:52:10 <SamB> pumpkin: silly
21:52:11 * SubStack is as old as perl
21:52:18 <jrockway> i thought they just started ommitting the 0. after a while
21:52:20 <Axman6> SamB: yeah, think so
21:52:34 * wli is mosty just pig ignorant of non-ancient webstuff.
21:52:58 <SamB> pumpkin: there were no such dark days!
21:53:00 <jrockway> people are really weird about version numbers, though
21:53:03 <jrockway> i've never figured it out
21:53:14 <SamB> trac is at 0.11
21:53:16 <jrockway> "i'd like to use your module, but it's not 1.0 yet.  any timeline for that?"
21:53:25 <SubStack> heh
21:53:33 <SubStack> as if version numbers actually meant something
21:53:35 <Axman6> jrockway: yeah, stupidest policy evar
21:53:36 <Heffalump> <1.0 does imply instability of interface
21:53:38 <jrockway> yeah
21:53:39 <wli> My web design knowledge may very well predate the birth of a number of #haskell denizens.
21:53:44 <Heffalump> otherwise why would you use it?
21:53:45 <SamB> yeah, 1.0 does sometimes mean something
21:53:53 * SubStack uses alpha code all the time for important things
21:53:54 <jrockway> it may or may not mean anything
21:54:00 <erikc> 1.0 IS FOREVER
21:54:08 <jrockway> but if you have the code, then ... you can read it and decide whether or not to use it
21:54:11 <Axman6> i should've released my last AVar update as 0.1.0 :(
21:54:17 <wli> Use IBM versioning policy: the initial version is 2.1; no release is ever *.0
21:54:28 <SamB> 2.1 ?
21:54:34 <jrockway> i don't think people really understand that open source means you can open the source code and read it :)
21:54:34 <SamB> that's a funny time to start
21:54:35 <erikc> wli: haha, very true
21:54:49 <jrockway> yeah
21:54:53 <wli> 0.x and 1.x are ess marketable.
21:54:54 <SamB> wli: I guess the .0 releases are just summarily sent back for debugging ?
21:54:56 <jrockway> or, if you are sun, you can jump from 1.4 to 5!
21:55:16 <Axman6> heh
21:55:17 <SubStack> > 5 - 1.4
21:55:18 <lambdabot>   3.6
21:55:18 <SamB> jrockway: they DID call 1.2 "Java 2", didn't they?
21:55:21 <wli> No, the version number is just viewed in like fashion to a brand name.
21:55:24 <SubStack> it's 360% as good!
21:55:26 <jrockway> hmm, i don't remember
21:55:35 <jrockway> some people want to call perl 5.10 "perl5 version 10"
21:55:35 <SubStack> 460% even!
21:55:46 <jrockway> clearly that will make people want to use perl! it's version 10!
21:55:52 <SubStack> zomgz
21:56:06 <SamB> as if 5 wasn't impressive enough
21:56:06 <erikc> Perl VX
21:56:11 <erikc> is a better name
21:56:23 <SamB> very few of the programs I use make it up that high ;-P
21:56:30 <araujo> Perl 3000
21:56:31 * wli might guess that nowadays minor version numbers of *.1 are probably not marketable anymore.
21:56:52 <SamB> wli: sure they are! it means they fixed the .0 bugs!
21:56:53 <jrockway> i always number version numbers from 0.01; 0.01, 0.02, ...
21:57:02 <jrockway> i've never made it to 100, so i'm not sure what happens there
21:57:08 <SubStack> perl would skip past 3000 straight to 4000
21:57:12 <jrockway> (incidentally, cabal made me pick 0.1 instead of 0.01)
21:57:14 <SubStack> nobody will want to repeat python's mistakes
21:57:31 <jrockway> well, there is this "perl6" thing that is really hindering perl5
21:57:38 <SamB> hmm, but there is no SimCity 4000
21:57:40 <wli> In fact, dotted versioning is probably just out the window entirely. Verbal versioning is probably the way it'll go.
21:57:43 <monochrom> Learn from Intel. Call your haskell project "FunParser T3200"
21:57:45 <SamB> so that's not as cool
21:57:45 <jrockway> people think that perl6 is perl5 + some patches, but that is not the case
21:57:52 <wli> Numeric versioning, even.
21:58:00 <SamB> jrockway: yeah
21:58:04 <monochrom> Actually "Terminator T3200" may be even better.
21:58:10 <SamB> they should have called it perl 9
21:58:13 <SamB> or something
21:58:18 <jrockway> yeah
21:58:20 <araujo> jrockway, then they hit against the wall when they release it is a whole different language
21:58:23 <Heffalump> perlNG
21:58:25 <wli> Debian, for instance, has lenny, etch, bo, sid, woody, etc. No numbers.
21:58:35 <Axman6> monochrom: urgh, i hate CPU namings these days. you used to be able to say 'id lik a 2.4gigihertz pentyum pls. kthz' but no more!
21:58:37 <araujo> Haskell'''''''''
21:58:38 <Heffalump> it does have numbers, just noone can remember them
21:58:39 <SubStack> perl should come out with some prequels after perl6
21:58:46 <jrockway> wli: my debian login prompt says "Debian 5.0" :)
21:58:51 <SubStack> to fill in the backstory
21:58:54 <jrockway> but yeah, names are so much cooler!
21:59:00 <artyoms> why perl 4000? perl 9000! :)
21:59:13 <jrockway> omg, perl 10000 for perl 5.10
21:59:13 <lispy> Haskell' can be Haskoool!
21:59:13 <wli> Well, not really "no numbers," but "non-numeric."
21:59:16 <SubStack> perl 9000... coming to you in the YEAR ONE BILLION
21:59:17 * araujo proposes ' as versioning for Haskell
21:59:22 <jrockway> the 5 stands for the number of digits
21:59:25 <SamB> wli: hey, what's the codename for experimental ?
21:59:27 <monochrom> Names are cooler? "FunParser Peculion"?
21:59:39 <jrockway> that sounds like a great library
21:59:46 <wli> If Debian competely avoided numeric versions it'd be the epitome of the marketing trend.
21:59:47 <SubStack> araujo: degrees, minutes, seconds?
21:59:48 <jrockway> it is so complete that it even has an AWESOME name!!1
21:59:59 <wli> SamB: No clue.
22:00:10 <SubStack> I could get behind dms for versioning
22:00:14 <artyoms> SubStack: LOL
22:00:16 <araujo> SubStack, prime ....
22:00:19 * SamB tries to think of a Toy Story character scarier than sid
22:00:20 <SubStack> oic
22:00:30 <SamB> maybe Zurg?
22:00:47 <SubStack> just misunderstood
22:01:08 <wli> I'm so far out of the Debian loop I'd not be surprised if my packages had all been taken over by other people without my knowledge and my Debian developer status revoked years ago without my knowledge either.
22:01:19 <araujo> haha
22:01:24 <SamB> wli: can they revoke that?
22:01:42 * araujo thought wli used other distro ....
22:01:49 <wli> I'm so far out of the Debian loop I have no idea.
22:02:04 <SamB> but I seriously doubt your packages have been subsisting on NMU for however many years you've been out of the loop
22:02:38 <SamB> though I'd have thought they'd send you some email about it
22:03:03 <SamB> (or have you been bit-bucketing their emails ?)
22:03:27 <SamB> wli: what were your packages ?
22:03:43 <wli> araujo: I've always used other distros. I just used to have mostly Debian boxen until the 50 or so boxen I had besides my work laptops were all junked by relatives I'm trying to get enough money together to sue.
22:04:01 <wli> SamB: libaio and hugs98 I think.
22:04:16 <araujo> hah
22:04:20 <araujo> good luck with that
22:04:22 <araujo> :P
22:04:44 <SamB> now hugs I could see getting by with NMUs
22:04:58 <twb> WTF? :load XMonad.Prompt --error--> <no location info>: module `XMonad.Prompt' is a package module
22:05:02 <SamB> not much has changed
22:05:21 <SamB> twb: :m
22:05:25 <mmorrow> i like how this came out, http://moonpatio.com/fastcgi/hpaste.fcgi/
22:05:27 <twb> Gah
22:05:27 <RichardG_> Hello
22:05:32 <SamB> I know
22:05:55 <wli> That's why I have to pay the lawyers to take the case; none think my case is worth any damages or likely enough to to be won to take it on percentages of damages.
22:06:08 <Axman6> mmorrow: what was the problem yesterday btw?
22:06:23 <mmorrow> Axman6: hmm. which problem? :)
22:06:36 <Axman6> mmorrow: the hpaste one, with the locked db
22:06:44 <RichardG_> I'm looking for some information on STM.  In particular, I'd like to learn more about how retries and fairness are handled in GHC 6.10.  Is there a place that I can find this info?
22:06:44 <mmorrow> ahhh
22:07:00 <pumpkin_> mmorrow: you know c--?
22:07:13 <mmorrow> Axman6: it looks like Takusen isn't handling the sqlite BUSY_WAIT error code correctly (or something)
22:07:23 <mmorrow> pumpkin_: i'm learning :)
22:07:29 <Axman6> rightio
22:08:00 <erikc> mmorrow: thats slick
22:08:25 <wli> My living situation was so badly disrupted by the grave illness and insurance company's denia of short-term disability that I've lost all proof I ever owned anything, including what little of what I ever had remaining in my possession.
22:10:05 <araujo> wli, sorry to hear that man
22:10:19 <araujo> hope you sort out everything
22:11:10 <pumpkin_> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1695#a1695 :P make any sense to you? it's wrong!
22:13:50 <wli> I literally no longer have proof of my own identity, never mind title and registration for my car. My computers, furniture, most of my clothes, huge piles of small but valuable items, etc. all vaporized.
22:14:42 <pumpkin_> :(
22:15:17 <wli> Some fraction (30%?) of my books and my car itself were most of what survived by both value and volume.
22:16:07 <Axman6> wli: what happeed to get you to this point?
22:17:26 <wli> Axman6: Staph and my heath insurance provider denying short-term disability for repetitive hospitalization due to it.
22:19:30 <wli> (Additionally or alternatively, inadequate care from the hospitals and doctors.)
22:20:21 * araujo thinks wli should get a job as a spy
22:22:04 <mmorrow> pumpkin_: gah, i just broke moonpatiopaste for a second trying to paste the cmm output from nqueens (random garbage got injected into the title somehow...)
22:22:15 <pumpkin_> :o
22:22:18 <mmorrow> pumpkin_: finally managed it though http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1570
22:22:53 <mmorrow> (sometime that happens (random stuff gets squirted into the title/author fields in the sqlite table)
22:22:56 <mmorrow> heh
22:22:57 <pumpkin_> updae?
22:23:04 <wli> araujo: Spies don't leave massive paper trails of medical paperwork and health insurance claims everywhere they go. Probably better to recruit someone healthier for that.
22:23:33 <wli> mmorrow: nqueens in SML/NJ?
22:23:41 <araujo> wli, :(
22:24:48 <mmorrow> erikc: the nice thing to is that you can use do-notation when you feel like it/to interleave doing other stuff while building up code, but on you also can just build it as a datatype too which would be preferable if you're generating (haskell code representing the) code
22:24:51 <Jedi_Stannis> how would I write a function similar to show, except if passed a string it doesn't quote it (it just returns the given string)?
22:24:58 <mmorrow> wli: i got it from nofib
22:25:07 <mmorrow> wli: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1570
22:25:57 <wli> mmorrow: What's cm if not SML/NJ's compilation manager?
22:28:04 <mmorrow> wli: oh, cmm := c--
22:28:15 <mmorrow> http://www.cminusminus.org/
22:28:17 <wli> do notation suffers from two large aesthetic issues: (1) expansivenes (2) imperative resemblance
22:28:25 <klibbigt>  what sia  good topology exercise to do? I study math on my own, im interested in computer vision, im 16 and we only do derivates so far in school.
22:28:25 <klibbigt> write c omputer program that decies homology groups on the alphabet?
22:28:25 <klibbigt> would haskell be suited for that?
22:28:51 <wli> c-- I recognize; abbreviating it as cmm seems weird.
22:29:18 <mmorrow> wli: yeah, but in this case i guess the imperative resemblance is kinda appropriate since it's being (ab)used to model essentially asm
22:30:11 <Axman6> Jedi_Stannis: you could make a class Show' a where show' :: a -> String; instance Show' a where show' = show; instance Show' String where show' = id
22:30:36 <pumpkin_> isn't cmm slightly different from c--?
22:30:45 <pumpkin_> at least in the sense of what ghc deals with
22:31:11 <wli> klibbigt: ISTR Munkres having an exercise on whether some comb-like space called the "long line" was "connected im kleinem" (which I can't remember whether is named for Felix Klein, German for "in the small," or both).
22:31:12 <mmorrow> yeah, ghc's isn't the full spec
22:32:01 <pumpkin_> bah, I hereby declare my x86_64 effort on pause
22:32:13 <mmorrow> and i just called that monad Cmm since i was using that -ddump-cmm output for an idea of how a lang at-a-similar-level/for-a-similar-purpose would do things while writing the code
22:32:26 <klibbigt> is that a site wli?
22:32:32 <mmorrow> so i make no claims that that's at all c-- either :)
22:33:48 <wli> klibbigt: No clue how one would combine topology with programming though I've heard of it in Mitchell's "Foundations for Programming Languages" book and some more sophisticated people wrt. FP/PL/type theory.
22:33:54 <Jedi_Stannis> Axman6: thanks, ill give that a shot.  Is there any way to pattern match a string (or character?)  to do something like: show' (String s) = s; show' a = show a (no new class needed if this is possible)
22:34:03 <mmorrow> wli: haha, i had that (a?) Munkres book for a course
22:34:17 <Axman6> Jedi_Stannis: String is just [Char]
22:34:28 <wli> klibbigt: Munkres is AIUI a standard/major topology textbook. NFI if it's actually any good.
22:34:51 <mauke> Jedi_Stannis: no
22:35:23 <mauke> well, you could do something like that with Typeable
22:35:31 <wli> (It could be standard/major in the same way as various truly terrible textbooks are standard/major freshman calc textbooks.)
22:36:08 <wli> klibbigt: I have no idea what a homology group on the alphabet is.
22:36:11 <mmorrow> klibbigt: write a mini stripped down version of ImageMagick
22:36:20 <mauke> show' :: (Typeable a, Show a) => a -> String; show' x = case cast x of Just s -> s; Nothing -> show x
22:37:01 * mmorrow had to do that in a course and it was sweet, both in terms of the coolness of the code/result and how much i learned
22:37:32 <Alpounet> haha
22:38:03 * mmorrow had to write it in C though
22:38:09 <Alpounet> I've read somebody telling that Java is a very strong language, and that when compiling some java code the compiler won't let us do anything
22:38:17 <Alpounet> that it is very strict
22:38:18 <Alpounet> haha :D
22:38:34 <Jedi_Stannis> mauke: Thanks, that looks like what I was going for
22:40:22 * wli is in the rather sad situation of steadily, dramatically declining programming abilities over the course of a long already-passed period of time and no plausible potential for recovery.
22:40:47 <mmorrow> klibbigt: while not directly topology+computer-vision, this has some really cool cool stuff in the assignments: http://www1.cs.columbia.edu/~cs4162/html05s/
22:42:26 <wli> I'm probably worse off than some freshmen I've flunked despite my best efforts to give away all the points I could (i.e. without _something_ turned in I couldn't even blindly give away 100% credit on assignments).
22:42:33 <jekor> I'd like to create a version of try for my monad (a combination of the CGI and Reader monads). Wrapping and unwrapping the monads is kicking my butt. Anyone have pointers on what I could study to figure this out?
22:43:07 <mmorrow> wli: reverse this negative feedback loop
22:43:26 <pumpkin_> well, ENTER() is a lot easier to read than that crap I pasted earlier
22:44:03 <wli> mmorrow: I'm bouncing in and out of hospitals a bit frequently for that.
22:47:18 <mmorrow> wli: well i hope the best comes of it that can
22:50:21 <wli> jekor: Try making a counter monad that rewraps a State monad transformer around the regular monad transformers? I did that at one point, though I can't seem to figure it out anymore.
22:52:13 <jekor> I don't understand where the state monad comes in.
22:52:31 <mmorrow> jekor: also, read the cgi pkg code
22:52:33 <wli> jekor: Wrapping monads is similar regardless of which kind of monad it is.
22:52:56 <jekor> mmorrow: I found some hints in CGI's tryCGI.
22:52:58 <mmorrow> jekor: that's what i did when i was learning haskell and wanted to do the exact same thing you're wanting to
22:53:05 <jekor> wli: Gotcha.
22:53:21 <jekor> For some reason though, I get stuck somewhere while trying to keep the types in my head ;)
22:53:44 <jekor> runReaderT keeps throwing me off.
22:53:55 <wli> I think it's the lift method or some such.
22:54:00 <mmorrow> and CGIT is just a newtype around a Reader and Writer, so you can pick up some ideas on working with wrapped transformers from there
22:54:15 <mmorrow> (and then wrap the one you're using as an example ;)
22:55:13 <jekor> Thanks, guys.
22:55:31 <mmorrow> @type runReaderT (ask >>= \x -> return (x, "asdf")) 2001
22:55:32 <lambdabot> forall r (m :: * -> *). (Monad m, Num r) => m (r, [Char])
22:55:49 <mmorrow> @type runIdentity $ runReaderT (ask >>= \x -> return (x, "asdf")) 2001
22:55:50 <lambdabot> forall r. (Num r) => (r, [Char])
22:56:22 <mmorrow> @type runWriterT $ runReaderT (ask >>= \x -> return (x, "asdf")) 2001
22:56:23 <lambdabot> forall w (m :: * -> *) r. (Monad m, Monoid w, Num r) => m ((r, [Char]), w)
22:56:27 <mmorrow> @type runStateT $ runReaderT (ask >>= \x -> return (x, "asdf")) 2001
22:56:28 <lambdabot> forall s (m :: * -> *) r. (Monad m, Num r) => s -> m ((r, [Char]), s)
22:57:29 <mmorrow> @unmtl ReaderT r (WriterT w Identity) a
22:57:29 <lambdabot> r -> (a, w)
22:57:37 <mmorrow> @unmtl ReaderT r (Writer w) a
22:57:37 <lambdabot> r -> (a, w)
22:59:46 <glguy> jekor, you get "runReaderT" for free, if you choose, in the newtype definition :)
23:00:53 <jekor> Heh. That's the part that was throwing me off while reading the CGI code.
23:11:47 <jekor> Whoa. I did it. Thanks.
23:12:54 <CTA> hey :D
23:13:08 <Axman6> o/
23:13:41 <wli> In other news, I don't think I can pull off an LUP factorization. I think I'll have to settle for a Gauss-Jordan elimination solver.
23:14:16 <wli> With row-only pivoting.
23:14:36 <CTA> factorial, is that the product of all the numbers upto n (not including n?)
23:14:52 <wli> including n
23:14:59 <CTA> ah kk
23:16:04 <CTA> so like this?
23:16:05 <CTA> factorial :: (Integral a) => a -> a
23:16:05 <CTA> factorial x =
23:16:05 <CTA>   product ([1..x])
23:16:15 <wli> yep
23:16:22 <CTA> (:
23:17:33 <CTA> no way, the factorial of 5 can't be 120?
23:17:52 <CTA> it is lol yeah :/ 24 * 5
23:17:59 <wli> I think it could be Num a, Enum a
23:18:09 <ddarius> > product [2..100]
23:18:11 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
23:18:47 <Axman6> CTA: factorials get big fast
23:18:52 <CTA> yeahh
23:19:07 <CTA> I've never heard of them only in programming, like never heard of them in maht
23:19:09 <CTA> *math
23:19:23 <Axman6> you'll hear more of them soon i'm sure ;)
23:19:26 <Alpounet> You'll soon :p
23:19:28 <Axman6> they're fairly common
23:19:48 <CTA> *Main> factorial 10
23:19:48 <CTA> 3628800
23:20:14 <CTA> o.O lol
23:20:15 <Axman6> > scanl (*) 1 [1..]
23:20:16 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
23:20:32 <Axman6> > scanl (*) 1 [2..]
23:20:33 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
23:20:46 <CTA> lamdabot is like a ghci in a way?
23:21:01 <Axman6> does a lot more than that though
23:21:07 <Axman6> @go lambdabot
23:21:08 <ddarius> factorial (-0.5) --> -2 * sqrt pi
23:21:09 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
23:21:09 <lambdabot> Title: Lambdabot - HaskellWiki
23:21:47 <CTA> Mwha when I know some more Haskell - a lot more - I shall try and make one, console based :D
23:22:39 <ddarius> Actually, I guess that would be factorial (-1.5)
23:23:17 <wli> Subfactorials, Stirling numbers, Eulerian numbers, and the like are all right up there with factorials.
23:23:19 <ddarius> Or maybe the other way
23:23:22 <dmwit> CTA: You can use \bot in a console.
23:23:27 * ddarius should probably go to sleep.
23:23:33 <wli> Mostly Stiring numbers and factorials, though.
23:24:01 <dmwit> Well, assuming you can get it installed, that is.
23:25:34 <CTA> I got possible incorrect indention
23:25:35 <CTA> theMax x y =
23:25:35 <CTA>   if x > y then
23:25:35 <CTA>   x
23:25:35 <CTA>   else
23:25:35 <CTA>   y
23:26:01 <ddarius> CTA: I will verify that indeed your indentation is incorrect.
23:26:11 <CTA> how is correct?
23:26:40 <Cale> theMax x y =
23:26:43 <Cale>   if x > y
23:26:49 <Cale>      then x
23:26:54 <Cale>      else y
23:26:57 <CTA> ah kk
23:28:12 <CTA> factorial.hs:8:0: parse error (possibly incorrect indentation)
23:28:12 <CTA> Failed, modules loaded: none.
23:28:12 <CTA> Prelude>
23:28:17 <CTA> still get error
23:28:42 <CTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1697#a1697
23:32:08 <jrockway> why do you have that extra blank line?
23:33:20 <CTA> i think it looks clearer?
23:33:27 <mauke> CTA: trailing -> in line 1
23:33:40 <CTA> i see now
23:33:44 <CTA> a -> a ->
23:40:28 <wli> > let stirlingCycle n k | n == 0 = if k == 0 then 1 else 0 | k == 0 = if n == 0 then 1 else 0 | k > n = 0 | otherwise = (n - 1) * stirlingCycle (n - 1) k + stirlingCycle (n - 1) (k - 1) ; stirlingSubset n k | n <= 0 || k <= 0 = if n == 0 && k == 0 then 1 else 0 | k == 1 || k == n = 1 | otherwise = stirlingSubset (n - 1) (k - 1) + k * stirlingSubset (n - 1) k in mapM_ print [[(n `stirlingCycle` k :: Integer, n `stirlingSubset` k) | k <- [0 .. n]] | n <- [0 
23:40:29 <lambdabot>   <no location info>: parse error on input `;'
23:41:02 <wli> You've got to be kidding me.
23:43:32 <Axman6> heh
23:44:01 <ddarius> wli: That's what you get for using meaningful names like "stirlingCycle"
23:45:09 * Axman6 would use sycle >_>
