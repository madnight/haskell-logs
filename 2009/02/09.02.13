00:01:09 <nj32> i want to use the DES in crypto library which takes Word64, for text.
00:09:04 <z0d> Is there a library for tracing the evaluation of expressions? I've found traced, but I'm not sure this is what I need.
00:10:45 <sjanssen> z0d: Debug.Trace?
00:11:55 <z0d> sjanssen: I'll check it out, thank you
00:12:22 * rwbarton .oO  f <*> x = trace (show f ++ "(" ++ show x ++ ")) (f x)
00:12:41 <mmorrow> does anyone know how to force firefox to show you files as text/plain even though the server doesn't send them as such?
00:12:52 <mmorrow> it's driving me crazy!
00:13:14 <dolio> show f?
00:13:39 <mmorrow> oo
00:13:43 <rwbarton> Well, that's the hard part :)
00:13:47 <dolio> :)
00:13:59 <mmorrow> ohhh
00:14:05 <mmorrow> i thought that comment was re: firefox
00:14:49 <mmorrow> rwbarton: you can use getClosureData and print out some random info about it i guess
00:16:12 * mmorrow writes a cgi program or something that grabs a url, then spits it out as text/plain
00:20:28 <thoughtpolice2> mmorrow: https://addons.mozilla.org/en-US/firefox/addon/8207
00:20:35 <thoughtpolice2> mmorrow: i use it all the time
00:21:31 <mmorrow> thoughtpolice++++
00:21:34 <mmorrow> :)
00:22:55 <rwbarton> Is there some way to generalize this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1377#a1377
00:29:12 --- mode: irc.freenode.net set +o ChanServ
00:46:32 <Lemmih> thoughtpolice2: pong.
01:01:06 <sw2wolf> is haskell slow than erlang ?
01:02:19 <quicksilver> I would expect haskell to be faster than erlang in most tests.
01:02:19 <osfameron> sw2wolf: at what?
01:02:30 <quicksilver> There will probably be some cases where the erlang's RTS wins though
01:02:48 <quicksilver> because it's tuned towards certain kinds of concurrent message passing.
01:03:18 <pettter> massive parallellisation is where erlang excels, is it not?
01:03:25 <sw2wolf> i see
01:04:12 <quicksilver> e.g. http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=hipe&box=1
01:04:19 <sw2wolf> i just used YAWS and now i want to learn haskell for its beautiful  code layout
01:04:34 <quicksilver> pettter: massive parallelisation of message passing and receiving
01:04:46 <quicksilver> pettter: (rather than, say, massive parallelisation of CPU-intensive calculation)
01:04:57 <ski_> roconnor : `argfc :: () -> a -> a' ?
01:04:59 <ski_> mmorrow : `callCC' in SML/NJ does imply referential opacity
01:05:10 <vegai> fascinating that binary trees haskell vs erlang-hipe is 1.0 in memory and speed
01:05:14 <mmorrow> ski_: nice
01:05:28 <vegai> oh, not speed. Erlang is 1.3 faster in that
01:06:04 <vegai> ah, they use pmap
01:06:51 <ski_> (fyi, given `f :: X -> X; f = argfc ()', `f = const x' where `x' is the argument to the "first call" of `x')
01:07:00 <vegai> so erlang's parallel implementation on quad core is 1.3 faster than ghc's sequential implementation
01:07:56 <dmwit> vegai: O_o
01:08:22 <ski_> (another example of using a continuation twice is `twicecc :: (a,Not a) -> (a,Not a)' ..)
01:08:39 <mstr> how can you make libraries with ghc, that can be linked to C programs?
01:08:51 <ski_> (all these are without using any other kind of effects)
01:09:00 <dmwit> mstr: Look up the FFI.
01:09:02 <dmwit> ?where ffi
01:09:02 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
01:09:05 <mstr> all I can find are tutorials that work the other way
01:09:11 <dmwit> ah
01:09:21 <lament> it's the same FFI
01:09:27 <mstr> thanks
01:09:27 <dmwit> The FFI also tells how to do that.
01:09:39 <lament> 'foreign export' as opposed to 'foreign import'
01:09:48 <ziman> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Calling_Haskell_from_C , maybe
01:12:05 <quicksilver> mstr: 'carefully'
01:12:23 <quicksilver> you'll have to link in the GHC runtime etc.
01:20:39 <lpsmith> Ok,  I'm playing around with lhs2TeX's \eval feature,  which is supposed to let you call ghci to generate output in your paper
01:21:13 <lpsmith> But when I try running it with GHC 6.10.1,  I just get "ERROR - Undefined variable"
01:21:35 <lpsmith> Is anybody around that might have an idea/
01:21:37 <lpsmith> ?
01:26:57 <swiert> lpsmith: kosmikus hangs out here and designed lhs2TeX.
01:27:52 <swiert> lpsmith: did you remember to include "%options ghci -pgmL lhs2TeX -optL--pre" ?
01:29:19 <lpsmith> swiert:  Thanks,  I just figured out that I hadn't and was looking for that magic incantation :)
01:29:33 <swiert> np.
01:35:35 <chrisdone> monads are hard, let's learn python!
01:37:48 <dolio> You can't use python without knowing about monads.
01:38:31 <Axman6> you just don't know you know about monads?
01:38:49 <dolio> Yeah.
01:39:27 <dolio> Their lambda abstractions aren't allowed to be monadic (at least, that used to be the case).
01:39:43 <opqdonut> hehe :)
01:39:47 <opqdonut> nice way of putting it
01:40:22 <dolio> So confusing!
01:42:01 <opqdonut> 16. How can I get Postfix to listen on a port other than 25?
01:42:04 <opqdonut> woops
01:42:13 <pao> hi all...
01:42:21 <hackage> Uploaded to hackage: haskeline 0.6.1.2
01:42:36 <mmorrow> rwbarton: you debug show for functions earlier prompted a "Debuggery" module http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1351#a1351
01:42:39 <mmorrow> *your
01:42:58 <pao> from an old python habit I'm explicitly importing names also in haskell...
01:43:05 <pao> but it's becoming cumbersome
01:43:18 <pao> is there a way to import all the namespace...
01:43:28 <opqdonut> just say "import Module"
01:43:33 <pao> and still be able to tell if an import line is still required?
01:44:31 <pao> opqdonut: how do I decide if "import Module" is still required in my file after factorization (except the naive method of trying to remove the import)
01:44:41 <pao> is there any editor support?
01:44:44 <dolio> I think GHC may warn if you don't use anything from a module.
01:44:50 <dolio> With -Wall, at least.
01:44:57 <pao> dolio: great... let me try
01:46:18 <pao> dolio: it works thanks
01:46:43 <pao> dolio: what is the best practice? explicit or implicit imports?
01:47:01 <dolio> I usually just go implicit.
01:47:21 <dolio> Some people insist on either being explicit or importing qualified, but that's a lot of work.
01:48:47 <pao> dolio: thanks
01:49:27 <mmorrow> dolio: re: smlnj's callcc, here's the (apparently actual) code used for "preemptive scheduling with atomic regions" which makes critical use of callcc: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1352#a1352
01:50:16 <dolio> I'm having difficulties cooking up examples of badness with it.
01:50:32 <mmorrow> the signal handlers are cool. they get passed the current continuation, and they return a continuation which is called to resume the program
01:50:56 <mmorrow> dolio: with what? sml's callcc or that cwcc?
01:50:59 <dolio> I tried a scheme example I found, but apparently you can't letrec normal values.
01:51:04 <dolio> SML's.
01:51:07 <mmorrow> oh cool :)
01:51:21 <mmorrow> are you using smlnj?
01:51:25 <dolio> Yeah.
01:51:27 <mmorrow> sweet
01:54:04 <dolio> I thought I had something where I could do "m + m" where m is some fancy callcc stuff (and it's wrapped in more fancy callcc stuff) to get m to evaluate to different values...
01:54:55 <dolio> But it didn't work, because when I called back out I was calling with the same n that got passed back in.
01:55:07 <dolio> Instead of an n that got mutated.
01:55:18 <mmorrow> heh. first-class continuations are fun
01:56:07 <dolio> Hey, you know what the other kinds of continuations it has are?
01:56:21 <mmorrow> no?
01:56:38 <dolio> The operators are abort and capture, and the type is 'a control_cont, but I tested some simple expressions and they don't seem to be any different than callcc and throw.
01:56:49 <mmorrow> ohhhh yeah. i saw those
01:57:05 <mmorrow> apparently the continuations they use are more primitive than a' cont
01:57:11 <mmorrow> but i'm not sure exactly how
01:57:22 <dolio> I thought maybe they were the kind that don't automatically duplicate the continuation...
01:57:25 <mmorrow> err, i mean 'a cont ;)
01:57:32 <mmorrow> hmm
01:57:39 <dolio> but 'capture (fn k => 5) + 5' turned into 10.
01:57:54 <dolio> Instead of 5 like you'd expect with throwing the continuation away.
01:58:10 <mmorrow> ah, apparently they "Unlike an ordinary continuation cont, a control_cont does not remember the exception-handler of its creator. "
01:58:13 <mmorrow> http://www.smlnj.org/doc/SMLofNJ/pages/cont.html
02:01:23 <mmorrow> dolio: hmm, i don't see that you'd expect 'capture (fn k => 5) + 5' to be 10
02:01:28 <mmorrow> err
02:01:34 <mmorrow> i mean .... to be 5
02:01:59 <dolio> You wouldn't with callcc.
02:02:10 <mmorrow> oh, hmm
02:03:04 <dolio> > let control f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) id in runCont (liftM2 (+) (control $ \k -> return 5) (return 5)) id
02:03:06 <lambdabot>   5
02:03:16 <dolio> I thought it was that operator.
02:03:29 <mmorrow> ohhh, i see now.
02:04:30 <dolio> callCC f = control $ \k -> f k >>= k
02:04:53 <dolio> I think that's right...
02:05:20 <dolio> > let control f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) id ; callcc f = control $ \k -> f k >>= k in runCont (liftM2 (+) (callcc $ \k -> return 5) (return 5)) id
02:05:22 <lambdabot>   10
02:05:37 <dolio> > let control f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) id ; callcc f = control $ \k -> f k >>= k in runCont (liftM2 (+) (callcc $ \k -> k 6) (return 5)) id
02:05:38 <lambdabot>   11
02:06:57 <mmorrow> is there an `undefined' in sml?
02:08:27 <dolio> It's easy enough to define one if not.
02:08:36 <dolio> Although, more of a pain than in Haskell.
02:08:40 <mmorrow> heh, i'm trying hard :)
02:09:55 <dolio> fun f () = f () ; val u = f ()
02:09:56 <ski_> dolio : iirc, `control_cont' is suitable for implementing threading systems with
02:10:16 <dolio> That appears to hang sml on loading, though.
02:10:31 <mmorrow> woot, i just found:
02:10:32 <mmorrow> val cast : 'a -> 'b
02:10:35 <ski_> (not surprisingly)
02:11:06 <ski_> maybe you could try encoding `twicecc' in haskell ?
02:11:29 <mmorrow> open SMLofNJ;   open Unsafe;
02:13:31 <dmwit> ?quote sprynge
02:13:31 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
02:14:00 <dmwit> Oh, shoot, I thought that was "Beware of the function a -> b. [...]"
02:14:01 <dmwit> =P
02:14:24 <kaol> @djinn [a] -> a
02:14:24 <lambdabot> Error: Undefined type []
02:14:26 <ski_> - map (argfc ()) [0,1,2,3];
02:14:26 <ski_> val it = [0,0,0,0] : int list
02:14:40 <ivanm> kaol: @djinn doesn't understand recursive types such as lists
02:14:59 <ivanm> though the only "sensible" choices are head and tail
02:15:16 <ivanm> even then, there's the possibility of an error
02:16:12 <mmorrow> heh
02:16:12 <dmwit> :t (!!1) -- also sensible
02:16:13 <mmorrow> Error: throw from one top-level expression into another
02:16:13 <lambdabot> forall a. [a] -> a
02:16:16 <Axman6> @djinn a -> Bool -> Maybe a
02:16:17 <lambdabot> f a b =
02:16:17 <lambdabot>     case b of
02:16:17 <lambdabot>     False -> Nothing
02:16:17 <lambdabot>     True -> Just a
02:17:36 <kaol> @djinn Maybe a -> Maybe b -> Maybe a
02:17:36 <lambdabot> f a b =
02:17:36 <lambdabot>     case a of
02:17:36 <lambdabot>     Nothing -> Nothing
02:17:36 <lambdabot>     Just c -> case b of
02:17:36 <lambdabot>               Nothing -> Nothing
02:17:38 <lambdabot>               Just _ -> Just c
02:17:59 <mmorrow> ski_: what is argfc?
02:18:49 <Twey> Were you all to use Haskell for a Web application, what would you use for output?  I'd really prefer something fairly close to the output (I like knowing that what I'm editing is pretty much going to end up being what comes out the other end, even if it goes through some reformatting) and of course it needs to be capable of HTML 4.01 Strict (and preferably validating it; it would be nice if it could reformulate the document on the fly, too)
02:19:18 <ski_> mmorrow : see about an hour ago
02:19:27 <Twey> I was told that Hackage was practically bogged down with template engines, but all I've been able to find so far are HSP and HStringTemplates, both of which look decidedly unfinished
02:19:34 <mmorrow> i use Text.XHtml.{Strict or Frameset}
02:19:38 <ski_> val twicecc = fn : 'a * 'a cont -> 'a * 'a cont
02:20:00 <ski_> (the trick now is being able to actually use `twicecc', too ..)
02:20:08 <Twey> mmorrow: Can it easily be reformatted into HTML?  Most clients don't like it if you drop support for half their clients :-P
02:20:08 <mmorrow> hmm, i looked in scrollback but i couldn't find an actual definition, just a type
02:20:30 <ski_> oh .. that's because i haven't shown the definition :)
02:20:32 <mmorrow> Twey: i'm not sure. There's also Text.Html
02:20:40 <mmorrow> ski_: grrrr.
02:20:48 <ski_> (i was thinking you might have some fun trying to figure it out, yourselves ..)
02:20:53 <mmorrow> hehe
02:20:57 <Axman6> Twey: most clients will handle XHTML just fine
02:21:02 <ski_> (it's not very complicated)
02:21:34 <Twey> That's the main setback to working with the markup libraries directly, as I see it... I'd really like something like Python's Genshi, where you can write XHTML and have it converted to HTML or HTML5 or whatever on the fly; it just makes everything a lot easier, especially if/when it's upgrade time
02:21:44 <Twey> Axman6: Most do; IE doesn't
02:21:58 <Axman6> yeah, but fuck IE :)
02:22:11 <Twey> Unfortunately IE still has a ~50% market share, and while I'd love to make a political statement by avoiding it, it's not a good career move if you want to stay in employment
02:22:50 <Twey> (and actually XHTML support is crappier than HTML support in most browsers, although obviously none so much as IE)
02:22:53 <lchaplin> Twey: i do not agree, i think you differ yourself (to a better) when you make such a statement
02:23:19 <lchaplin> and if the company does not appreciate your awareness for quality, then you're obviously at the wrong company
02:23:54 <Twey> lchaplin: It might be hard finding a company that doesn't mind losing half its clients in order to make a statement
02:24:20 <lchaplin> Twey: tried OSS companies?
02:24:36 <Twey> I think even they would balk at it
02:24:47 <Twey> I mean, what major sites use real XHTML these days?
02:24:53 <Twey> Mozilla Quest Quest?
02:26:33 <lchaplin> Twey: well, i've been thinking about having my company site making without IE support and a redirect to landing page with other browsers
02:26:51 <ski_> (mmorrow : ok, i found the (a ?) paper talking about `argfc' and `twicecc' .. if you're interested)
02:27:03 <chrisdone> that's a pain in the ass when I want to access your site but I'm on someone else's computer
02:27:09 <Twey> Aye
02:27:25 <Twey> And it doesn't make a good impression
02:27:26 <Axman6> then you tell them to install firefox
02:27:42 <ski_> ("You can enter a room once, and yet leave it twice." Peter Landin)
02:27:44 <Twey> They'll just see it as laziness
02:28:05 <lchaplin> laziness while running a OSS biz?
02:28:15 <lchaplin> rather a political statement
02:28:17 <chrisdone> Axman6: you can tell them to lose weight while they're at it
02:28:23 <Twey> Heh
02:28:25 <dolio> ski_: Good tip.
02:28:31 <Axman6> chrisdone: it's good health advice, so sure
02:28:31 <dolio> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341#a1353
02:28:45 <Twey> I'm theoretically in agreement with you here, but it doesn't keep bread on the table.
02:28:49 <chrisdone> Axman6: ha, depends on the person ;-)
02:28:54 <Twey> Yeah
02:29:01 * Twey is trying to *gain* weight
02:29:12 <chrisdone> "why, you cheeky--HRRRRRNNNNNNNGGGGGG"
02:29:14 <ski_> (.. tip ?)
02:29:14 <Axman6> chrisdone: well, if they didn't need to lose weight, i wouldn't say anything :P
02:29:18 <Twey> Hahahahaha
02:29:24 <lchaplin> Twey: i have about 10% IE viewers on my page having about 80k visits a month, tbh, i don't care about IE
02:29:59 <mmorrow> dolio: ooh, cool
02:30:12 <ski_> (dolio : oh, right .. the thesis probably mentions them as well)
02:30:30 <dolio> mmorrow: a = 3, b = 4.
02:31:15 <Twey> lchaplin: Lucky you :)
02:31:26 * ski_ was looking at "Using a continuation twice and its implications for the expressive power of call/cc" Hayo Thielecke (at <http://www.cs.bham.ac.uk/~hxt/research/htpapers.html>)
02:31:39 <lchaplin> when i think, what i have to pay my developers just to make the site IE compatible, i'd save a lot of money and their nervs not persuing IE at all
02:32:11 <mmorrow> whoa, that's sweet
02:32:13 <lchaplin> they have nightmares about IE6.0 :)
02:32:20 <ski_> also <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/> by Andrzej Filinski is interesting .. e.g. the "Representing Monads","Representing Layered Monads" papers
02:32:25 * mmorrow grokifies
02:32:36 <dolio> I don't remember seeing argfc in the thesis, but I can't say I've read it exhaustively.
02:33:02 <ski_> dolio : `arg-fc' is at least in "Using a continuation twice and .."
02:33:46 <ferret_0567> can I declare function in the GHCI interpreter?
02:34:05 <mmorrow> i want to have a go at coroutines via callcc
02:34:05 <Twey> ferret_0567: You can use 'let'
02:34:05 <asgaroth> ferret_0567: let f x = ..
02:35:26 <mmorrow> actually, forget that. i want to have a go at preemptively scheduled threads
02:35:43 <Twey> Haha
02:35:45 <ski_> then you'll need to set up a timer interrupt
02:35:48 <Twey> 'There's just so much to do!'
02:36:10 <mmorrow> apparently the signal handling machinery + callcc make it easy
02:36:12 * ski_ str seeing something like this for SML/NJ
02:36:20 <ski_> m
02:36:45 <ferret_0567> what is a good place to start learning haskell?
02:36:51 <ski_> here
02:36:58 <ferret_0567> I haven't really started with it yet
02:37:03 <Twey> @index unsafePerformIO
02:37:04 <lambdabot> System.IO.Unsafe, Foreign
02:37:10 <mmorrow> ski_: i've been reading http://www.smlnj.org/compiler-notes/90-tr-reppy.ps
02:37:47 <mmorrow> in which they give this snippet http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1352
02:38:18 <mmorrow> i guess all you need is that code/equivalent + a queue implem + a timer interrupt
02:38:28 <ski_> (be sure to read about linear continuations .. and the "Abstracting Control","Representing Control" papers are nice for CPS,nqCPS)
02:38:28 <mmorrow> (+ callcc)
02:38:56 <ferret_0567> I tried learnyouahaskell.com and it isn't that good, at least, not for me
02:39:11 <Twey> ferret_0567: Try RWH
02:39:18 <ski_> yes, i can have been in realtion to CML i saw it
02:39:36 <ferret_0567> Twey: link please
02:39:49 <ski_> @where rwh
02:39:49 <lambdabot> is http://www.realworldhaskell.org/blog/
02:40:18 <mmorrow> ferret_0567: imo the best way to learn would be to write a program that does something useful for you, which gives you the motivation to tough through having to constantly look stuff up
02:40:36 <Twey> ferret_0567: http://book.realworldhaskell.org/read/
02:40:37 <ski_> (specifically <http://book.realworldhaskell.org/>)
02:40:59 <Twey> There's a dead-tree version too
02:42:00 <ferret_0567> Intel Parallel Programming Podcast: Real World Haskell
02:42:02 <ferret_0567> so that mean
02:42:17 <ferret_0567> so that means that haskell is really good for parallel programming?
02:42:38 <Twey> Haskell's really good for just about everything
02:42:52 <Twey> Parallel programming is one of functional programming's strong points, though, yes.
02:43:00 <ferret_0567> how good is gtk2hs?
02:43:14 <Axman6> ferret_0567: makes parallel programming much easier than most languages (but it's never something that's super easy)
02:43:17 <Twey> (i.e. imperative languages suck at it more than the average)
02:43:19 <chrisdone> @help set
02:43:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:43:32 <Twey> ferret_0567: Well, it's stable and working
02:43:43 <ferret_0567> Twey: is it feature complete?
02:43:47 <Twey> Yes
02:43:53 <ferret_0567> great!
02:43:55 <chrisdone> someone set the rwh to the proper link?
02:44:09 <Twey> It's probably a bit more low-level than most Haskell programmers like to code on a day-to-day basis (i.e. it's pretty imperative-feeling) but yes, it works
02:44:17 <chrisdone> @remember rwh is http://book.realworldhaskell.org/
02:44:17 <lambdabot> Okay.
02:46:19 <wli> Reasoning about space usage is one of the weak points. It's not a problem in most userspace code.
02:46:21 <Axman6> chrisdone: think you mean @where+
02:46:40 <tibbe> @src foldl
02:46:40 <lambdabot> foldl f z []     = z
02:46:40 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:46:56 <thoughtpolice2> wli: agreed
02:47:50 <ski_> @quote rwh
02:47:51 <lambdabot> rwh says: is http://book.realworldhaskell.org/
02:47:54 <wli> Databases are one case where that's critical because they operate in a vaguely fixed memory space analogous to operating system kernels. Operating system kernels are another such case, but privileged mode programming has other issue also rendering it awkward.
02:48:51 <ski_> @where+ rwh <http://book.realworldhaskell.org/>,<http://www.realworldhaskell.org/blog/>
02:48:51 <lambdabot> I will remember.
02:49:08 <Axman6> @where rwh
02:49:08 <lambdabot> <http://book.realworldhaskell.org/>,<http://www.realworldhaskell.org/blog/>
02:49:30 <Twey> wli: What are the issues with privileged-mode programming?
02:49:59 <mlesniak> Is there a flag such that ghci will display the time it took for an expression to evaluate?
02:50:45 <asgaroth> mlesniak: :set +s
02:51:01 <wli> Twey: Tremendous amounts of raw memory manipulation and in-core memory format and memory layout affairs are there beyond rather stringent space usage control needs.
02:51:04 <chrisdone> ooo, cool
02:51:20 <mlesniak> asgaroth: Ah, looked at the wrong place in the documentation, chapter 3.8 states +s :D Thanks
02:51:54 <wli> Twey: Also tremendous amounts of interfacing with assembly/machine code as well as code invoked by the CPU in response to exceptions.
02:52:07 <Twey> Hmm, fair point.
02:52:17 * Twey continues waiting for BitC.
02:53:53 <wli> Maybe whoever/whatever is funding the Cyclone group will get something moving (that group seems to have actually made some forward progress, albeit in not-so-pretty directions).
02:54:11 <wli> Mutatis mutandis for Ada.
02:55:03 <blueonyx> hi
02:55:39 <ski_> lo
02:55:45 <ski_> (wli : yay, a "mutatis mutandis" brethren ! :)
02:55:57 <wli> I don't see a whole lot of hope for FP per se in systems programming, but rather, the use of some methods developed in FP contexts to systems programming environments/languages.
02:56:50 <wli> I think what's most desperately needed are strong/powerful module systems.
02:57:17 <senex3> Am I blind or is there no »count«-function in Haskell?  I want something like count :: (a -> Bool) -> [a] -> Integer
02:57:38 <Ferdirand> (length.filter) ?
02:57:53 <senex3> ok, looks good, thanks :)
02:58:07 <wli> > @pl \p xs -> length (filter p xs)
02:58:08 <lambdabot>   <no location info>: parse error on input `@'
02:58:16 <wli> @pl \p xs -> length (filter p xs)
02:58:16 <lambdabot> (length .) . filter
02:58:28 <Ferdirand> yep, sorry
02:59:00 <Twey> wli: Strong agreement on 'not-so-pretty'
02:59:48 <wli> Twey: I would say that some of the directions are not-so-relevant, also, but maybe there was some emphasis on userspace-level systems programming in addition to kernel-level.
03:02:36 <wli> I would love to park some serious talent on the problem of getting serious linguistic power applied to systems programming under its operational restrictions but I'm not in any sort of position to call any of those shots.
03:02:45 * ski_ wonders whether there's any construction of integer-length sequences ..
03:03:17 <wli> ski: List comprehensions?
03:03:33 <ski_> no, i mean like lists, but length may be negative
03:04:02 <wli> I don't see any meaningful notion of a negative length list.
03:04:03 <ski_> forall xs. exists ys. xs ++ ys = []
03:04:08 <ski_> that sort of thing
03:04:48 <ski_> one can create bags with negative multiplicity of some elements
03:05:11 <ski_> (well, "bags" .. i.e. a generalization)
03:06:18 <wli> type Bag t = Map t Int, insertWith (+), unionWith (+), fromListWith (+), etc.
03:07:40 <ski_> yes
03:08:06 <ski_> but i think one can also do it in a similar fashion to grothendieck construction
03:08:17 <dmwit> Like a bag, but ordered, then?
03:08:23 <ski_> yes
03:08:29 <Twey> What's that... a list?  :-P
03:08:34 <dmwit> data OrderedBag = Negative [a] | Positive [a] -- =)
03:08:54 <dmwit> cons x (Positive xs) = (x:xs)
03:09:07 <dmwit> cons x (Negative []) = Positive [x]
03:09:28 <dmwit> cons x (Negative (y:ys)) = assert (y == x) (Negative ys)
03:09:31 <dmwit> err...
03:09:37 <dmwit> That last one doesn't make me so happy. =P
03:10:03 <ski_> i don't think it's that simple
03:10:27 <dolio> You could instead use [a + a].
03:10:51 <dolio> Where Left a annihilates Right a, and vice versa.
03:11:26 <dolio> And the 'length' is the lefts minus the rights, or something.
03:11:45 <ski_> hm, something like that could be it
03:12:14 <ski_> (i suppose it's not that surprising that this seems to require element equality ..)
03:14:11 <dolio> Well, you don't have to, I suppose.
03:14:22 <dolio> You could just not work with the quotient type.
03:14:28 <dolio> length with still work.
03:15:03 <ski_> and `sum' would too .. hm
03:15:32 <dolio> Will, even. Not sure how my fingers typed 'with'.
03:15:50 * ski_ didn't even notice that
03:16:32 <ferret_0567> Twey: I know how to program in bash at the "good" level, I'm not very good at it and by no means am I an expert
03:16:47 <Twey> Heh
03:16:52 <ferret_0567> Twey: I don't know regular expressions very well either
03:17:00 <Twey> Haskell is... a bit different to bash scripting :-P
03:17:03 * Axman6 doesn't cound bash as programming
03:17:13 <chrisdone> haskell is just like using pipes!
03:17:14 <Axman6> count either
03:17:23 <Axman6> but backwards
03:17:28 <ivanm> has anyone managed to build the chart library using ghc 6.10 + gtk2hs 0.10 ?
03:17:57 <chrisdone> :t map (*5) >>> filter (>5) >>> map show
03:17:59 <lambdabot> forall a. (Ord a, Num a) => [a] -> [String]
03:18:05 <ferret_0567> Twey: that book you sent me the link to says that they expect you to already know how to program. Does that include people with basic skills or will I need to find another book?
03:18:41 <Twey> ferret_0567: You might struggle with a few concepts, but you can probably use bash as a starting point
03:18:57 <ferret_0567> Twey: ok, that's good news
03:19:23 <ferret_0567> I'm only 15 so...I don't know that much math either :(
03:19:26 <Axman6> ferret_0567: we're here to help
03:19:53 <chrisdone> they always say that. "I'm only 15!!"
03:20:13 <ferret_0567> chrisdone: why is that so bad?
03:20:21 <Axman6> and then you stick you... check bash.org for the rest of that quote >_>
03:20:28 <Axman6> your*
03:20:50 <chrisdone> Axman6: order reverse in quote the getting congrats
03:20:52 <ferret_0567> Axman6: link?
03:21:39 <ferret_0567> chrisdone: reverse order in the quote getting congrats?
03:22:19 <ferret_0567> chrisdone: is that what you mean?
03:22:29 <Twey> ferret_0567: Don't worry.  The main aspect of maths that applies is category theory, and everyone's new to that.  :-P
03:22:34 <Twey> (and you don't need it anyway)
03:22:37 <chrisdone> > unwords . reverse . words $ "order reverse in quote the getting congrats"
03:22:39 <lambdabot>   "congrats getting the quote in reverse order"
03:23:28 <ferret_0567> oh, I see
03:23:44 <ferret_0567> if you give me any other string I will be able to change it around
03:24:00 <Axman6> ferret_0567: http://bash.org/?24 ( chrisdone also0
03:24:19 <ferret_0567> Twey: at least I know about the set comprehensions
03:25:37 <ferret_0567> Axman6: lol
03:25:56 <ferret_0567> Axman6: I already saw that one
03:36:44 <ferret_0567> Axman6: bash.org quote 111338 is my favorite
03:40:19 <augustss_> @seen dcoutts
03:40:20 <lambdabot> dcoutts is in #haskell-hac5, #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 55m 7s ago.
03:52:14 <dcoutts> augustss_: pong
03:57:22 <ivanm> has anyone managed to get haskell-mode in emacs to play nicely with ghci-6.10? I keep getting ^J's everywhere :s
03:57:54 <lilac> ivanm: i seem to recall someone mentioned something about setting the ghci command to ghci | cat
03:57:57 <Alpounet> ^J's ?
03:58:12 <lilac> > '\010'
03:58:14 <lambdabot>   '\n'
03:58:18 <ivanm> lilac: oh?
03:58:31 <ivanm> Alpounet: that's what emacs uses to print a "literal" newline
03:58:42 <Alpounet> ok
03:58:57 <dmwit> ^A \1 ... ^J \10 ... ^Z \26
03:59:06 <dmwit> it's twuuu
03:59:58 <dmwit> Also:
04:00:02 <dmwit> > '\4'
04:00:04 <lambdabot>   '\EOT'
04:00:15 <dmwit> ^D -- end of transmission
04:00:35 <Alpounet> > '\6'
04:00:37 <lambdabot>   '\ACK'
04:00:56 <dmwit> ASCII is such a ridiculous character set these days.
04:01:19 * osfameron huggles ascii
04:01:21 <Axman6> > '\5'
04:01:23 <lambdabot>   '\ENQ'
04:01:26 <Axman6> > '\7'
04:01:28 <lambdabot>   '\a'
04:01:33 <Axman6> > '\8'
04:01:34 <lambdabot>   '\b'
04:01:56 <Alpounet> Axman6, you should use a list :p
04:01:56 <SamB> and, er, \a is bell ?
04:01:57 <Axman6> > ['\1'..]
04:01:58 <lambdabot>   "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\E...
04:02:01 <dmwit> Okay, \a is alert, what's \b?
04:02:13 <ivanm> lilac: that seems to freeze emacs... >_>
04:02:19 <ivanm> dmwit: backspace?
04:02:21 <lilac> ivanm: alas
04:02:22 <dmwit> oh, duh
04:02:24 <Axman6> possibly
04:02:33 <Axman6> \v is funky
04:02:39 <dmwit> \v is vertical space
04:02:59 <Axman6> verticle tab i've always heard it called
04:03:00 <dmwit> (It's the pagination character! O_o)
04:03:01 <SamB> ivanm: wait until you try ghci | HsColour -tty
04:03:05 <dmwit> Yeah, vertical tab.
04:03:11 <dmwit> It inserts vertical space. =)
04:03:17 <ivanm> lilac: heh: "target `|' is not a module name or a source file" <-- this is why it fails
04:03:36 <chrisdone> > '\BUCKET'
04:03:43 <lambdabot>   <no location info>:
04:03:45 <lambdabot>      lexical error in string/character literal at chara...
04:03:54 <chrisdone> eek, bad lag
04:03:57 <ivanm> SamB: in emacs?
04:04:02 <Axman6> putStrLn "test\vtesting more\vstuff"
04:04:14 <dmwit> > "\bucket"
04:04:15 <lambdabot>   "\bucket"
04:04:18 <SamB> ivanm: no, on the TTY
04:04:26 <Alpounet> Axman6, forgot >
04:04:34 <ivanm> SamB: well, I'm talking about getting emacs to play nicely with 6.10 ;-)
04:04:40 * SamB doesn't think it's actually useful unless perhaps you are mwallace
04:04:43 <ivanm> Alpounet: lambdabot won't process/run any IO stuff...
04:04:48 <Axman6> Alpounet: putStrLn doesn't work in lambdabot, so i left it out
04:04:49 * ivanm /= mwallace
04:04:51 <ivanm> ;-)
04:05:02 <SamB> ivanm: I was just on the subject of crazy things to do involving ghci and pipes ;-)
04:05:03 <dmwit> Try (putStrLn "\\\v\\\v\\\r/").
04:05:04 <Alpounet> Axman6, ok, I did not know
04:05:20 <vorner> reply-pokus
04:05:20 <vorner> reply-pokus
04:05:20 <vorner> reply-pokus
04:05:20 <vorner> reply-pokus
04:05:20 <vorner> reply-pokus
04:05:27 <ivanm> SamB: heh
04:05:28 <dmwit> gwah
04:05:28 <Axman6> woah... didn't think ghci | HsCoour -tty would work :O
04:05:30 <chrisdone> ivanm: I have ghc6.10 with emacs. hang on..
04:05:32 <Alpounet> lambdabot is more purely fonctional than Haskell itself ? :p
04:05:49 <dmwit> Alpounet: \bot has to protect against malicious users.
04:05:54 <ivanm> Axman6: no, but having HsColour might ;-)
04:06:02 <ivanm> (rather than HsCoour)
04:06:04 <dmwit> Alpounet: The simplest way is to just rule out IO entirely. =)
04:06:09 <Axman6> heh, that too
04:06:10 <SamB> ivanm: mwallace said he *uses* that sometimes, so a few of us tried it but it didn't seem to do anything useful for us
04:06:26 <Axman6> damn, this is so cool :)
04:06:30 <ivanm> SamB: I seem to recall someone saying once that after a while it bogs down/crashes
04:06:30 <Alpounet> dmwit, quite right yeah
04:06:43 <chrisdone> ivanm: (custom-set-variables '(haskell-program-name "ghci-no-tty"))
04:06:43 <chrisdone> ivanm: then make ghc-no-tty: cat | ghci $*
04:06:43 <chrisdone> ivanm: got it from Conal's blog
04:07:05 <ivanm> dmwit: so is the only reason monads were introduced into Haskell was a way of filtering out possible malicious commands for lambdabot? ;-)
04:07:11 <dmwit> ;-)
04:07:13 <SamB> ivanm: no
04:07:23 <ivanm> chrisdone: *nod*
04:07:28 <ivanm> happen to have a link anywhere?
04:07:40 <ivanm> and I presume ghc-no-tty is a seperate bash script or something?
04:07:40 <dmwit> ivanm: Also as a way to occupy academics who felt a need to write tutorials...
04:07:45 <ivanm> heh
04:07:50 <ivanm> not just academics though...
04:08:02 <chrisdone> ah, not a blog
04:08:04 <chrisdone> http://www.nabble.com/problem-with-echo-prompting-in-ghci-(visible-in-emacs)-td20451779.html
04:08:04 <malcolmw> ivanm: I find the hscoloured output of ghci useful only for reading type error messages
04:08:19 <SamB> ivanm: before, lambdabot would simply have needed to not actually do anything specified in any "action list" the expression happened to return
04:08:25 <ivanm> thanks chrisdone
04:08:36 <ivanm> malcolmw: *nod*
04:08:40 <SamB> of course, I'm pretty sure lambdabot, unlike NHC, is actually post-monad
04:08:43 <chrisdone> welcome
04:08:58 <ivanm> SamB: ssshhhh!
04:09:11 <SamB> ssshhhh?
04:09:15 <chrisdone> does SPJ say "m-Oh-nad" or "mon-ad"?
04:09:34 <SamB> you mean moe-nad or mon-ad?
04:09:40 <chrisdone> yeah
04:09:48 * SamB doesn't remember
04:09:48 <chrisdone> http://www.youtube.com/watch?v=9fohXBj2UEI <- she says moe-nads, though
04:09:56 * SamB says mon-ad
04:10:15 * ivanm typically doesn't say/pronounce it at all...
04:10:24 * Beelsebob says app-lic-a-tive
04:10:26 <Beelsebob> >.>
04:10:28 <malcolmw> tomayto, tomahto, let's call the whole thing off...
04:10:33 <chrisdone> ivanm: not talking enough Haskell to your buh-dees!
04:10:36 <SamB> chrisdone: why don't you watch his haskell tutorial vidios?
04:10:37 <Alpounet> ivanm, people guess you talk about monad without saying it ?
04:10:51 <chrisdone> SamB: I have, but I can't remember
04:10:56 <SamB> ivanm: not even in your MIND?
04:10:59 <Beelsebob> malcolmw: did you get my patch for hsColour that gives you inline css output for blogs btw?
04:11:05 <SamB> chrisdone: in the same boat am I
04:11:05 <Axman6> Beelsebob: not app-lic-a-tiv?
04:11:11 <chrisdone> easier to type one line in IRC than load up a video and wait for him to say it
04:11:18 <malcolmw> Beelsebob: yes, I got it, but am hesitating to apply it
04:11:22 <ivanm> chrisdone: nah, my supervisor is sick of hearing me talk about it :p
04:11:23 <SamB> chrisdone: again, same boat!
04:11:25 <Beelsebob> oh?
04:11:37 <chrisdone> SamB: I'm waiting
04:11:45 <ivanm> SamB: I find that I can read words without having to read them out aloud...
04:11:52 <chrisdone> ivanm: what does your supervisor do?
04:12:05 <Beelsebob> I was a bit unhappy about not being able to specify colours on the command line – but I couldn't think of a nice way to do it
04:12:07 <malcolmw> Beelsebob: I'm not quite sure how it differs from the ordinary output  - can you give me some more explanation?
04:12:09 <SamB> ivanm: so you don't subvocalize when you read?
04:12:16 <ivanm> he's a math prof that also does a fair amount of (atrocious C) programming
04:12:23 <SamB> ivanm: I found that that was bad for my comprehension
04:12:26 <chrisdone> ivanm: I do that when reading novels. I don't bother reading character names, I just see it as a symbol
04:12:27 * vorner is sorry for the flood, seems like a bug in his client he just created :-|
04:12:43 <SamB> chrisdone: you skip subvocalizing in NOVELS!???!?
04:12:47 <chrisdone> vorner: there was no flood
04:13:08 <Axman6> chrisdone: sure there was
04:13:10 <chrisdone> SamB: only character names. if it's even vaguely unusual I skip over bothering to subvocalise it
04:13:16 <Axman6> at 5 past
04:13:24 <chrisdone> Axman6: oh, right
04:13:29 <SamB> chrisdone: so, say, Tilja?
04:13:30 <Beelsebob> malcolmw: there's a few blogs out there that will reject the <font> based stuff as being old-illegal html
04:13:40 <Beelsebob> so doing it with css is your only option
04:13:46 <ivanm> chrisdone: with that script, do you have #!/bin/sh or something at the top?
04:13:46 <vorner> Ah, then I was dropped by freenode fast enough. I have like 100 messages to this room in a log
04:13:52 <chrisdone> SamB: that's easy enough
04:14:07 <chrisdone> ivanm: no, I just have "cat | ghci $*" and chmod +x. why?
04:14:14 <SamB> chrisdone: Axtrig?
04:14:16 <malcolmw> Beelsebob: yes, but HsColour already has a -css output option
04:14:29 <chrisdone> SamB: yeah, that's skipped over
04:14:39 <ivanm> chrisdone: just checking, because I always thought scripts needed to be told what to be executed with, and Conal's email doesn't specify anything like that :s
04:14:45 <Beelsebob> malcolmw: yep, but at least the blog I'm using doesn't let you upload a CSS file to use with your page, or fiddle with the headers
04:14:50 <Beelsebob> dons had the same problem
04:14:54 <Axman6> @src repeat
04:14:54 <lambdabot> repeat x = xs where xs = x : xs
04:15:06 <Axman6> @src replicate
04:15:07 <lambdabot> replicate n x = take n (repeat x)
04:15:19 <Alpounet> @src take
04:15:19 <lambdabot> take n _      | n <= 0 =  []
04:15:19 <lambdabot> take _ []              =  []
04:15:19 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
04:15:32 <Axman6> Beelsebob: movabletype++ ;)
04:15:37 <malcolmw> Beelsebob: so is it not possible to simply inline a CSS file into the generated HTML?
04:15:58 <Beelsebob> malcolmw: only in the <head> – which is what I'm trying to avoid
04:16:19 <malcolmw> Beelsebob: I see
04:16:20 <chrisdone> SamB: I mean, it's just like when you see >>> or >=> in Haskell. you don't subvocalise that, it's just a visual symbol. I do the same for silly names. trouble is when I chat to someone about the novel I'm like "and then v..thingie.. whatever -- other person suggests word -- right, said X!"
04:16:32 <Axman6> Beelsebob: what's wrong with that?
04:17:02 <tibbe> @src filter
04:17:03 <lambdabot> filter _ []     = []
04:17:03 <lambdabot> filter p (x:xs)
04:17:03 <lambdabot>     | p x       = x : filter p xs
04:17:03 <lambdabot>     | otherwise = filter p xs
04:17:04 <Beelsebob> malcolmw: I did ponder not making it output any of the surrounding content of the page – just a div that could by copy/pastad onto a blog, which would make its intended purpose clearer
04:17:12 <chrisdone> ivanm: I would randomly guess it's ran with /bin/sh, but I have no idea
04:17:21 <Beelsebob> but I didn't see the point in making it more special
04:17:22 <ivanm> yeah
04:17:30 <ivanm> anyway, I can sanely use ghci in emacs now! \o/
04:18:10 * chrisdone tries out adding HsColour to his ghci-no-tty ..
04:19:12 <malcolmw> Beelsebob: so now I understand the problem a bit better.
04:19:41 <chrisdone> haha, funky
04:21:38 <malcolmw> Beelsebob: but I'm a bit wary of the hard-coded list of "builtins" which get styled differently
04:21:55 <ivanm> chrisdone: but is it usable/scalable?
04:21:58 <ivanm> _that_ is the question!
04:22:04 <Beelsebob> malcolmw: yeh, I was a bit wary of them
04:22:16 <Beelsebob> the "builtins" are all the Prelude functions
04:22:27 <malcolmw> Beelsebob: otherwise, the code looks fine
04:22:28 <chrisdone> ivanm: is it BUSINESS READY?
04:22:38 <Beelsebob> but I'm not certain how to tel you that they're more special than any other function
04:22:42 <ivanm> who cares about business ready?
04:22:43 <ivanm> ;-)
04:23:01 <malcolmw> Beelsebob: so I don't consider Prelude functions as more special
04:23:09 <Beelsebob> okies :)
04:23:22 <Beelsebob> it's partly the code just looks nicer that way (imho)
04:23:29 <Beelsebob> but there's certainly no good reason to do it
04:24:25 <malcolmw> Beelsebob: one could consider adding different colourings of builtins as a separate feature
04:24:33 <Beelsebob> true
04:24:43 <Beelsebob> yep, I'll have a think about how to do that orthogonally
04:24:58 <Beelsebob> I suspect that it's more a case of colour "these" functions specially, rather than builtins
04:25:10 <malcolmw> Beelsebob: and instead of hard-coding the list, allow the user to specify a file containing the list of "specials" on the command-line, with a default file of Prelude functions already supplied
04:25:16 <Beelsebob> yep :)
04:26:11 <malcolmw> Beelsebob: OK, so do you want to send me a revised patch?  or shall I apply it as is, then remove the builtin stuff?
04:26:24 <ivanm> is there a guide somewhere to the new exception stuff in 6.10?
04:27:05 <Beelsebob> if you apply it as is, but minus bulitins – I'll have a work on a couple of other patches – I want to make the specification of colours on the command line more general, so that the styles in my patch are no longer hard coded
04:27:30 <quicksilver> ivanm: yes, the paper
04:27:46 <ivanm> quicksilver: which paper?
04:27:58 <quicksilver> 'extensible exceptions' I think it's called
04:28:20 <ivanm> @go extensible exceptions
04:28:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions
04:28:21 <lambdabot> Title: HackageDB: extensible-exceptions-0.1.1.0
04:28:32 <ivanm> heh, don't think that's it somehow ;-)
04:28:33 <pao> ivanm: is a paper written by Marlow
04:28:52 <pao> @go extensible exceptions marlow
04:28:53 <lambdabot> No Result Found.
04:29:36 <ivanm> "asynchronous exceptions in haskell"? that's the closest paper the haddock docs reference...
04:29:55 <pao> ivanm: http://www.haskell.org/~simonmar/papers/ext-exceptions.pdf
04:30:23 <ivanm> thanks pao
04:30:49 <pao> ivanm: np
04:40:52 <Axman6> > let (>) = flip (>) in 1 > 2
04:41:07 <lambdabot>   thread killed
04:42:14 <dcoutts> @seen augustss_
04:42:14 <lambdabot> augustss_ is in #haskell. I last heard augustss_ speak 1h 1m 54s ago.
04:43:35 <Axman6> :t let (>) = flip (>) in (>)
04:43:37 <lambdabot> forall b c. b -> b -> c
04:44:37 <ski_> @type fix flip
04:44:38 <lambdabot> forall b c. b -> b -> c
04:44:54 <Axman6> why c? o.O
04:45:58 <ski_> @type flip
04:46:00 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:46:13 <ski_> probably it got the names from that
04:56:15 <MyCatVerbs> @index readHex
04:56:15 <lambdabot> Numeric
04:56:31 <MyCatVerbs> Huh. Not renamed to Data.Numeric or anything?
05:11:27 <true\false1> http://pastebin.com/m33cb00fd I tried to write the quicksort today.. Didn't work
05:11:51 <true\false1> Looked at the Learn you a Haskell example of it, and I really don't see why minewould refuse to work?
05:12:10 <koeien> true\false1: tabs/spaces?
05:12:51 <true\false1> Grmbl probably, let me just redo it all quickly then
05:12:57 <koeien> it is recommended to use only spaces
05:13:01 <tromp> if first element is the biggest, then you recursively call with the whole list
05:13:17 <tromp> so it never finished, and runs out of memory
05:13:31 <koeien> tromp: no
05:13:34 <true\false1> Oh right, well I'm using notepad++ for a change
05:13:41 <jeltsch> Hello all. I have a problem with cabal sdist
05:13:55 <tromp> oh wait
05:14:02 <tromp> you select from xs
05:14:04 <koeien> true\false1: i use vim and have 'set expandtab'
05:14:07 <jeltsch> I get the following error:
05:14:11 <koeien> tromp: indeed
05:14:13 <jeltsch> 'ghc-options: -O0' is not needed. Use the --disable-optimization configure flag.
05:14:23 <jeltsch> And the following warning:
05:14:36 <jeltsch> Instead of 'ghc-options: -fglasgow-exts' it is preferable to use the 'extensions' field.
05:14:46 <true\false1> koeien: I just indented itall using spaces .. Was fine now
05:14:47 <jeltsch> And the following note:
05:14:50 <jeltsch> the public hackage server would reject this package.
05:14:55 <koeien> true\false1: ok. good to hear
05:15:02 <jeltsch> How should I make Hackage accept this?
05:15:24 <koeien> jeltsch: my guess is to use --disable-optimization instead... :) why do you want that anyway?
05:15:31 <true\false1> Ta
05:15:46 <jeltsch> koeien: I suppose, --disable-optimization is a flag, a package user can give if he/she wants to disable optimization.
05:16:03 <jeltsch> koeien: What if I as the package maintainer want optimizations to always be disabled.
05:16:08 <koeien> jeltsch: appearantly you have -O0 in your .cabal file
05:16:13 <koeien> yeah why do you want that?
05:16:16 <jeltsch> koeien: Exactly.
05:16:47 <jeltsch> koeien: I want optimizations unconditionally disabled since with optimization GHC 6.10.1 hangs.
05:17:06 <jeltsch> koeien: So I want to work around a GHC bug.
05:17:24 <koeien> you cannotspecify --disable-optimization in the .cabal file?
05:17:28 <Saizan> jeltsch: hackage policy has actually changed recently so that -O0 is actually accepted
05:17:31 <Saizan> koeien: no, you can't
05:17:47 <koeien> ok
05:17:54 <jeltsch> Saizan: Thanks for this info.
05:18:16 <jeltsch> Does Hackage also reject packages because of distribution quality warnings or only because of errors.
05:18:59 <jeltsch> The warning is that I use -fglasgow-exts. But what else should I do if I use extensions which are not supported by Cabal, at least by older Cabal versions which I want to support too?
05:19:02 <Saizan> you can use the check form on the upload page to test that
05:19:38 <jeltsch> Saizan: Okay, I will do that.
05:20:12 <jeltsch> By the way, I need to run configure before sdist. Does it matter whether I run configure with or without --user if the only thing I want to do afterwards is setup sdist?
05:20:54 <Saizan> jeltsch: it shouldn't
05:21:45 <jeltsch> Saizan: Ok.
05:28:25 <ski_> (hm .. "Controlling Effects" by Andrzej Filinski is interesting too)
05:33:59 <jeltsch> I want upload several packages to Hackage with inter-dependencies.
05:34:15 <jeltsch> Is it safe to upload them shortly after each other, in dependency order.
05:34:28 <jeltsch> That is, is it guaranteed that Hackage builds them in the order I upload them?
05:34:51 <jeltsch> If not, package builds may fail, resulting, for example, in documentation not generated. :-(
05:35:16 <ski_> ("While these techniques for modeling computational effects all share a similar feel, they do differ substantially in the details. It was therefore a remarkable observation by Moggi that they could each be seen as a particular instance of a generic schema, parameterized by a *monad*, a simple concept from category theory [Mog89].")
05:43:17 <jeltsch> Hmm, is there something important on TV at the moment? No-one wants to talk anymore.
05:50:14 <quicksilver> jeltsch: well I think it will simply refuse to build a package if it doesn't have the dependencies
05:50:20 <quicksilver> jeltsch: then it will try again in a day or something.
05:50:21 <quicksilver> I"m not sure.
05:50:53 <jeltsch> quicksilver: I didn’t know that Hackage tries again. Are you sure?
05:51:28 <quicksilver> jeltsch: no.\
05:51:31 <jeltsch> quicksilver: But even if it does, it might take days until a couple of packages is built if Hackage always tries them in the wrong order (one day per package).
05:52:43 <MyCatVerbs> quicksilver: Hackage doesn't use cabal-install? :)
05:58:41 <inbuninbu> is anyone here very familiar with yampa?
05:58:52 <chessguy> 'morning
05:59:49 <Peaker> inbuninbu: not very, but a bit. I think Reactive is far nicer..
06:00:40 <beelsebob> inbuninbu: not very, but a bit too
06:00:46 <inbuninbu> Peaker: i was just wondering if there are any decent, yet simple examples... the documentation seems rather... sparse
06:00:47 <beelsebob> reactive is a chunk nicer – but also a chunk less working
06:01:02 <beelsebob> inbuninbu: the space invaders one in yampa arcade seems to fit that description
06:02:00 <inbuninbu> beelsebob: is the source available somewhere? it covers some of the core functionality, but glosses over how to connect it to IO. or at least it seems so to me
06:02:24 <beelsebob> uh, good question
06:02:35 <beelsebob> I'm not sure I've ever actually run it
06:03:42 <Peaker> inbuninbu: I think the part about how it connects to IO was clear in that pdf about the invaders
06:04:09 <inbuninbu> Peaker: ok, thanks i guess i'll take another look
06:04:27 <inbuninbu> and i think i found the source. should have checked hackage before...
06:12:29 <ertai> @seen dons
06:12:29 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 17h 22m 10s ago.
06:16:36 <drhodes> > choose 1 [True, False]
06:16:38 <lambdabot>   Couldn't match expected type `[Bool] -> t'
06:17:35 <gnuvince> :t choose
06:17:36 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
06:21:36 <Alpounet> hi
06:21:42 <drhodes> hello
06:22:14 <drhodes> @users
06:22:14 <lambdabot> Maximum users seen in #haskell: 664, currently: 621 (93.5%), active: 18 (2.9%)
06:23:17 <Alpounet> cantor left #haskell ! Quite sad, huh.
06:24:12 <bastl1> has anyone used Data.Algorithm.Munkres ?
06:24:46 <Alpounet> bastl1: what's your problem with it ?
06:26:29 <bastl1> the default for nonexistent edges in an 2-dim-array of weights is weight 0, but that obviously confuses the algorithm ...
06:26:34 <bastl1> i dont implement it my self.
06:27:14 <bastl1> the student creates an UArray with "array", and there appear those 0-entries with the wrong semantic.
06:35:01 <augustss> @seen dcoutts
06:35:01 <lambdabot> dcoutts is in #haskell-hac5, #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 50m 1s ago.
06:36:38 <appletizer> @seen appletizer
06:36:39 <lambdabot> You are in #haskell and ##logic. I last heard you speak just now.
06:38:24 <vincenz> /opme
06:38:26 --- mode: ChanServ set +o vincenz
06:38:29 --- mode: vincenz set -o vincenz
06:38:35 <Alpounet> are there some haskell interpreters on web pages ?
06:39:05 <Alpounet> don't have any on those crap computers @ my university...
06:40:27 <MyCatVerbs> Alpounet: Unix machines? If you don't have a really restrictive quota, you could install Hugs in your home directory. GHC is doable in theory too, but quite big.
06:41:00 <Peaker> Alpounet: you could also /query lambdabot :)
06:41:19 <Peaker> > const "Yes" "Are you a Haskell interpreter?"
06:41:21 <lambdabot>   "Yes"
06:41:26 <bastl1> whats wrong with this expression ?
06:41:28 <bastl1> > (array (1,3) [(1,1),(2,2),(3,3)]) :: IArray UArray Int
06:41:30 <lambdabot>       Not in scope: type constructor or class `IArray'    Not in scope: type ...
06:42:19 <Peaker> @index UArray
06:42:19 <lambdabot> Data.Array.Unboxed
06:42:21 <hackage> Uploaded to hackage: simplesmtpclient 0.2
06:42:21 <hackage> Uploaded to hackage: grapefruit-examples 0.0.0.0
06:42:21 <hackage> Uploaded to hackage: grapefruit-ui-gtk 0.0.0.0
06:42:21 <hackage> Uploaded to hackage: grapefruit-ui 0.0.0.0
06:42:21 <hackage> Uploaded to hackage: grapefruit-records 0.0.0.0
06:42:46 <Alpounet> peaker > I know but I'm on mibbit for IRC and both lambdabot & mibbit IRC client support only 1-line text writing...
07:03:38 <geezusfreeek> Alpounet, http://codepad.org/
07:04:16 <Alpounet> didn't know it was also an interpreter/compiler :p
07:04:21 <Alpounet> thanks geezusfreeek
07:04:22 <geezusfreeek> yup :)
07:04:25 <geezusfreeek> welcome
07:15:24 * paper_cc was doing physical modelling and suddenly found himself creating a function plotting application
07:15:47 <paper_cc> is there a good way to embed a haskell interpreter into a haskell program?
07:16:45 <paper_cc> (GHC API doesn't even provide a way to redirect output... at least I couldn't find one)
07:18:42 <dcoutts_> @seen augustss
07:18:42 <lambdabot> augustss is in #haskell. I last heard augustss speak 43m 41s ago.
07:22:45 <Cheshire> :t liftM . liftM
07:22:48 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
07:23:15 <Alpounet> damned, lambdabot can't solve Project Euler stuff
07:23:34 <Alpounet> or maybe could with some optimizations, hmm
07:27:48 <mm_freak> i've just read an interesting post on haskell-cafe, which raised the question:  does it suffice for referential transparency that a function called with the same arguments needs to produce the same result, _if_ it returns?
07:28:15 <mm_freak> i.e. if a function returns x in one call and ⊥ in another, is it referentially transparent?
07:28:17 <lilac> mm_freak: i assume 'function' here implies purity
07:29:00 <lilac> and the answer is i think 'no'.
07:29:17 <lilac> suppose we have a function which has a 50% chance of returning its argument and a 50% chance of being _|_
07:29:24 <mm_freak> lilac: i think, "pure function" is the same as "referentially transparent function"
07:29:37 <lilac> then y = (f x, f x) is not the same as y = let k = f x in (k, k)
07:29:59 <maltem> mm_freak: I'd just argue that x /= _|_, so it returns different values on the same input
07:30:08 <mm_freak> hmm
07:30:42 <Cheshire> isn't returns ⊥ an oxymoron
07:30:46 <Cheshire> ?
07:30:49 <mm_freak> is there some theoretic argument that supports this?  or is it rather a question of intuition?
07:31:02 <lilac> mm_freak: well, i was more asking if the function may have side-effects (for some definition of side-effects)
07:31:09 <mm_freak> it appears to me as a question like "what is 0^0?"
07:31:29 <tromp> > 0^0
07:31:31 <lambdabot>   1
07:31:39 <paper_cc> oops
07:31:40 <Alpounet> :|
07:31:48 <mm_freak> Cheshire: "to return something" for me is equivalent to "to result in something" for functions
07:31:49 <tromp> that's pretty well defined
07:31:52 <z0d> :t (^)
07:31:54 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:31:57 <Alpounet> Somebody has to patch lambdabot
07:32:16 <maltem> Cheshire: probably, what about "has value"?
07:32:23 <mm_freak> although haskell makes you be careful about that, because "to return something" can be misunderstood as using the 'return' function
07:32:29 <Cheshire> mm_freak, maybe if you draw a distinction you can form a different view about what function means
07:32:45 <mm_freak> lilac: no side effects, just that the function is allowed not to finish
07:32:54 <lilac> mm_freak: partiality is a monad
07:33:14 <mm_freak> tromp: 0^0 is not well defined
07:33:14 <lilac> we're looking for referential transparency with respect to that monad
07:33:23 <lilac> (whatever that means)
07:33:46 * lilac thinks he's rambling
07:34:20 <mm_freak> tromp: about the same mess as 0/0
07:34:30 <lilac> mm_freak: /how/ can a function sometimes return a value and sometimes bottom out, if it's side-effect free?
07:34:33 <Alpounet> > 0/0
07:34:35 <lambdabot>   NaN
07:34:50 <lilac> mm_freak: 0/0 is not defined, whereas 0^0 has only one sensible interpretation
07:35:28 <Alpounet> lambdabot should answer "glasses wearing smiley" or something like that, for 0^0
07:35:34 <mm_freak> lilac: but consider that 0^x gets a singularity, if you say that 0^0 = 1
07:35:43 <maltem> The problem about 0^0 is, there are some mathematicians who say it weren't defined :)
07:36:04 <rwbarton> They are all wrong (if they really exist). :)
07:36:06 <Alpounet> most of them say that
07:36:09 <lilac> mm_freak: 0^x is screwed /anywayw/ since 0^(-1) isn't finite
07:36:59 <maltem> mm_freak: what singularity?
07:37:09 <Alpounet> > 0^(-1)
07:37:11 <lambdabot>   * Exception: Negative exponent
07:37:14 <lilac> if anything, it's nicer that it go from infinity for <0 to 0 for >0 via 1
07:37:18 <paper_cc> > 0^^(-1)
07:37:20 <lambdabot>   Infinity
07:37:21 <Alpounet> 1^(-1)
07:37:22 <tromp> how many functions are there from an m element set to an n element set?
07:37:25 <Alpounet> > 1^(-1)
07:37:28 <lambdabot>   * Exception: Negative exponent
07:37:32 <Alpounet> ah, ok
07:37:35 <mm_freak> lilac: 0^x is a perfectly valid partial function, if you set 0^0 = 0
07:37:36 <Alpounet> > 1^^(-1)
07:37:38 <lambdabot>   1.0
07:37:42 <lilac> tromp: the set of such functions is n^m :)
07:37:49 <lilac> that should give you a clue.
07:38:03 <tromp> exactly. and how many fnuctions are there from the empty set to the empty set?
07:38:15 <lilac> well, one.
07:38:23 <tromp> yes, clearly one
07:38:26 <mm_freak> the point is that every (partial) function c^x is singularity-free, unless you set 0^0 = 1
07:38:47 <lilac> mm_freak: what?
07:38:56 <Alpounet> tromp > so you would define 0^0 as equal to 1 ?
07:39:15 <tromp> of course
07:39:19 <rwbarton> There's really no question, "everyone" defines 0^0 = 1.
07:39:28 <lilac> mm_freak: 0^x /is/ a perfectly valid partial function
07:39:32 <idnar> > 0^0
07:39:34 <lambdabot>   1
07:39:50 <mm_freak> lilac: sorry, i forgot:  "without singularities"
07:39:58 <maltem> rwbarton: Everyone who defines it. Yet, there are those plesky people who say it weren't defined
07:40:27 <tromp> yes, just like there are people who say 0 is not a natural number:)
07:40:32 <lilac> mm_freak: 0 is a singularity in the sense of differentiability with your 0^x
07:40:32 <rwbarton> maltem: I suppose all of them write a polynomial P(x) = a_0 + sum_{i = 1}^n a_i x^i rather than P(x) = sum_{i = 0}^n a_i x^i
07:40:35 <Alpounet> :)
07:40:59 <maltem> tromp: That's what the majority of maths profs in Germany says, I think
07:41:09 <lilac> mm_freak: but i'm not clear on what sense of singularity you mean here
07:41:24 <Alpounet> rwbarton: most of us say X^0 is fine as X is an indeterminate
07:41:37 <Alpounet> (not sure of this English word...)
07:41:38 <mm_freak> lilac: on differentiability (at least from left to right)
07:41:46 <lilac> mm_freak: you want 0^x to be a /constant/ partial function, i think, at the expense of making x^0 not be a constant /total/ function
07:41:46 <quicksilver> I'd call it a singularity it it was undefined and a discontinuity if it's defined.
07:41:48 <maltem> rwbarton: well they don't :)
07:41:58 <rwbarton> maltem: Well then you can safely ignore their claims about 0^0 :)
07:41:59 <paper_cc> :t (1 `div` 0)^0
07:42:00 <lambdabot> forall t. (Integral t) => t
07:42:01 <Alpounet> most of them*
07:42:03 <Alpounet> sorry
07:42:07 <paper_cc> > (1 `div` 0)^0
07:42:09 <lambdabot>   1
07:42:11 <Alpounet> I believe in 0^0 = 1 :p
07:42:13 <lilac> mm_freak: 0^x is not differentiable at 0 anyway. it's not even continuous there.
07:42:13 <mm_freak> lilac: well, that's a valid argument
07:42:25 <mm_freak> lilac: however, i think, it really depends on the purpose
07:42:40 <lilac> are you aware of any cases where it makes sense to treat 0^0 as 0?
07:42:42 <Alpounet> must go, bye
07:42:51 <lilac> that is, where it makes something work cleanly where otherwise it woudl not
07:42:54 <mm_freak> lilac: no, not right away
07:43:06 <lilac> however, there are lots of cases where 0^0 == 1 makes them work nicely
07:43:36 <lilac> at some point, you need to say how (^) is defined, and picking the definition which has the most nice properties seems most sensible
07:43:57 <maltem> 0^0 = 1 is even the most consistent
07:44:25 <maltem> because x^0 := 1
07:44:49 <lilac> yes. 0^x is nasty anyway. x^0 needn't be.
07:45:13 <mm_freak> lilac: indeed
07:45:27 <mm_freak> lilac: my original point is that 0^0 is not well defined
07:46:00 * maltem thinks the dicussion circle is closed now :P
07:46:40 <rwbarton> @type (^)
07:46:42 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:46:55 <paper_cc> @ty (^^)
07:46:57 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
07:50:05 <lispy> It's funny how often the discussion of 0^0 comes up here
07:50:47 <rwbarton> the key point is, 0^(0 :: Integer) = 1.  If someone wants to treat 0^(0 :: Double) as undefined, I have no real problem with that
07:50:56 <doserj> especially considering that functional programmers should know how the function space operator ^ behaves...
07:51:27 <chessguy> lispy, it's probably even more often than in #math :)
07:52:04 <Peaker> did anyone here use FFI+QuickCheck to test C code?
07:52:26 <chessguy_work> heh, that's a cool idea
07:52:29 <lispy> rwbarton: wait, why are you okay with 0^(0::Integer)
07:53:01 <sw17ch> Peaker: it's crossed my mind many many times
07:53:05 <chessguy_work> > 0^(0::Integer)
07:53:06 <sw17ch> never done it :)
07:53:07 <lambdabot>   1
07:53:08 <Peaker> I want to write unit tests for C code, but obviously they don't need to be in C themselves
07:53:16 <lispy> Peaker: yeah, that is a cool idea.  You could probably even use a different library to help automate it.
07:53:18 <Peaker> sw17ch: I don't know much about quickcheck beyond writing simple properties and checking them
07:53:35 <chessguy_work> mm, i wouldn't really call quickcheck properties unit tests, per-se
07:53:58 <Peaker> lispy: It can work for conceptually pure C code, probably not for IO code?
07:54:02 <chessguy_work> more like invariant tests
07:54:03 <lispy> chessguy_work: well, they check at the unit level :)
07:54:06 <sw17ch> quickcheck is like fuzz testing that's a little less fuzzy
07:54:18 <mm_freak> well, i think, the hottest topic in here is still the fibonacci sequence
07:54:32 <mm_freak> probably there are as many expressions of it as there are people in here =)
07:54:34 <maltem> lispy: with the unit being a function property - easy enough
07:54:44 <lispy> Peaker: I've never used quickcheck to test IO code in Haskell
07:54:47 <mm_freak> > fix (\r x y -> x + r y (x+y)) 0 1
07:54:59 <mm_freak> uhm
07:55:03 <mm_freak> > fix (\r x y -> x : r y (x+y)) 0 1
07:55:06 <mm_freak> d'oh
07:55:19 <chessguy_work> lispy, i guess i think of unit tests as testing that some very particular event/function-call/operation/whatever returns the right result
07:55:30 <Peaker> lispy: I think my IO unit tests for C should probably also be in Haskell, why write them in C? :)
07:55:42 <lambdabot>   thread killed
07:55:42 <Peaker> I used to write my C unit tests in Python, but now that Haskell is my primary language...
07:55:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:55:53 <lispy> mm_freak: wow, that totally hosed lambdabot
07:55:56 <Toxaris> chessguy_work, lispy: isn't one of the ideas of unit testing that the other units are replaced by fake implementations?
07:56:10 <Peaker> Toxaris: no, that's mocking
07:56:11 <chessguy_work> Toxaris, if need be, to isolate the unit
07:56:42 <Peaker> If you need mocking to unit-test properly, there is a lot of agreement that you should probably refactor your unit so that it is testable separately
07:56:43 <chessguy_work> Toxaris, i would say that mocking is a means to unit testing
07:56:53 <lispy> Toxaris: I don't think that is central to unit testing, but everyone does it with unit testing
07:57:17 <mm_freak> lispy: there are easier ways to do that
07:57:23 <mm_freak> > fix id 0
07:57:25 <lambdabot>   * Exception: stack overflow
07:57:29 <mm_freak> oh, ok
07:57:43 <Peaker> @type fix id
07:57:45 <lambdabot> forall a. a
07:57:48 <mm_freak> i doesn't stack overflow for me, it rather kills my system
07:58:09 <lispy> mm_freak: um, when you make lambdabot go freaky, I can't type anything until she gives up :)
07:58:19 <lispy> I need to figure out why that is, it's annoying
07:58:36 <mm_freak> yeah, and it may happen that she doesn't give up in time =)
07:58:38 <Toxaris> chessguy_work, Peaker: ok I see.
07:58:41 <Peaker> lispy: do you have a memory limit on it?
07:59:12 <mm_freak> if that happens, she starts to thrash-swap before even having a chance to give up
07:59:14 <mreh> does anyone have any ideas how i might fill the next six months? I need temporary work. Anyone need some Haskell hacking?
07:59:16 <lispy> ah yeah, there is a rogue mueval
07:59:42 <lispy> 100% CPU
07:59:48 <lispy> I'm tempted to killit
07:59:54 <lispy> But, if that might kill lambdabot
08:00:00 <lispy> Cale: are you around?
08:00:46 <lispy> Peaker: how would I set a memory limit?  With ulimit?
08:00:51 <maltem> mreh: Fill six months - how about Google SOC?
08:01:08 <mm_freak> lispy: through an RTS option maybe?
08:01:14 <mreh> do you get paid for that?
08:01:26 <lispy> mreh: yeah, you do but you also need to be at least a part-time student
08:01:30 <maltem> mreh: Google gives stipends
08:01:39 <Peaker> lispy: yeah
08:01:43 <mreh> how about unemployed?
08:01:49 <mm_freak> lispy: with +RTS -M you can set the maximum heap size
08:01:51 <maltem> mreh: oh yeah I forgot about the student part
08:02:04 <Peaker> lispy: if you kill lambdabot, you can just relaunch it? I'm pretty sure killing mueval won't kill lambdabot anyhow
08:02:09 <mreh> i'll enroll in some cookery classes
08:02:59 <mm_freak> lispy: the main problem i see is that the RTS doesn't free memory
08:03:14 <mm_freak> that really sucks, and it should at least be possible to do that voluntarily
08:04:03 <mreh> any alternatives to SOC? I am no elligable
08:04:16 <mreh> it looks like office temping again for me!
08:04:25 <lispy> mreh: there are those hire a coder websites...
08:04:42 <mreh> monster.com?
08:04:45 <lispy> Peaker: I don't know how cale starts lambdabot
08:04:52 <skorpan> i "worked" for rentacoder a couple of times... it was horrible.
08:05:16 <lispy> ?bot
08:05:16 <lambdabot> :)
08:05:18 <lispy> hmm
08:05:25 <paper_cc> [OT] I create global IO state like myStateVar = makeIORef myStateVar 1.0 :: IORef Float, where makeIORef = const $ unsafePerformIO . IORef. Can I be sure that all my state variables are distinct?
08:05:36 <lispy> Well, that seemed to help :)
08:05:38 <Peaker> lispy: you can check the existing cmdline in /proc/<lambdabot pid>/cmdline
08:06:34 <maltem> Heh, now they mark their questions as being on-topic
08:06:48 <paper_cc> off-topic rather
08:07:02 <maltem> how so?
08:07:22 <rwbarton> @unpl const $ unsafePerformIO . IORef
08:07:22 <lambdabot> (\ _ f -> unsafePerformIO ((IORef) f))
08:07:37 <paper_cc> maltem: not about the ongoing discussion =)
08:07:56 <maltem> oh, *that* topic.
08:11:16 <mm_freak> paper_cc: probably not the answer you were looking for, but why don't you use StateT?
08:12:23 <mm_freak> if i really need global state, i make some state type (data AppConfig = …), which may of course be simply Float, and then something like:  type AppIO = StateT AppConfig IO
08:13:22 <mm_freak> that's a lot more predictable than unsafePerformIO-ed global IORefs
08:13:31 <quicksilver> paper_cc: just make the IORefs in your main action or similar, and pass them into the functions that need them.
08:13:39 <quicksilver> abhor these ridiculous top level state hacks.
08:13:47 <paper_cc> mm_freak: well, I need to pass state between GLUT-rendered frames
08:13:51 <quicksilver> (preferably abhor IORefs entirely, but one abhorrence at a time)
08:14:08 <mm_freak> paper_cc: i don't see a problem with that
08:14:24 <paper_cc> quicksilver: just tired of passing 8 IORefs to one function...
08:15:18 <quicksilver> then pass a data structure which contains 8 IORefs.
08:15:22 <quicksilver> or one IORef.
08:15:37 <Modius> Okay - this is gonna sound loaded and petty and almost inappropriate for this forum; but you guys are into types.  In a C# 3 meet the presenter said that var x = FunctionCall()  (where in C# 3 x type is inferred) is bad because if x.Foo were accessed, and FuncionCall's return were swapped for another type that also had "Foo" it would invisibly change.  I was wondering where, in the terminology of type safety, this equivalence fa
08:15:37 <Modius> lls so I can go study.  It was presented as an abandonment of static checking but I do not believe was presented accurately.
08:16:03 <paper_cc> mm_freak: i have something like keyboard Key Modifiers = modifyIORef param f, display = <render using param> etc
08:16:30 <gwern> @quote hubris
08:16:30 <lambdabot> LarryWall says: We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.
08:16:33 <reprap> is haskell fast enoughf or large-scale image analysis and mahcine learning?
08:16:59 <mm_freak> paper_cc: ah, it uses callbacks, you mean?
08:17:00 <reprap> why is it never possible to isntall anything from hackage? it is always dependont on 32 different moduels that noone has
08:17:00 <chessguy_work> Modius, your question got cut off. but in haskell, the equivalent idea is type inference without explicit type annotation. it's certainly possible, and powerful, but not generally recommended for robust code
08:17:07 <cizra> reprap: Wouldn't this depend more on algorithm design?
08:17:18 <quicksilver> paper_cc: your display function should take the contents of the IORef not the IORef.
08:17:28 <mm_freak> reprap: for machine learning yes
08:17:32 <quicksilver> paper_cc: the display function should (probably) not change the state
08:17:34 <paper_cc> mm_freak: it's GLUT. it does all event handling using callbacks
08:17:39 <reprap> cizra: to a alrge extent yes
08:18:07 <reprap> but how fast are numerical libs in haskell?
08:18:14 <mm_freak> paper_cc: then i'd follow quicksilver's suggestion and use one IORef with a larger data structure
08:18:15 <reprap> do they use BLAS LAPACK etc?
08:18:30 <Modius> chessguy_work:  So in mainstream haskell code (acknowledging haskell coders are far from mainstream) types are explicitly listed?  What about intra-function (var is for call-stack variables)?
08:18:34 <paper_cc> quicksilver: I need to establish a display callback of type IO () in my main once, and it's called by GLUT not by me, so I need the IORef
08:18:38 <cizra> reprap: have no idea. Dhrystone them. Or dig in the source.
08:19:04 <quicksilver> paper_cc: yes, you do.
08:19:09 <chessguy_work> Modius, i'm not sure what you mean by intra-function
08:19:17 <Modius> chessguy_work:  I want to make clear, in C#3 functions still have to declare their return type explicitly - this concern is all on local variables holding result of a function call.
08:19:23 <quicksilver> paper_cc: but putting them at the top level is a problem, not a solution.
08:19:25 <cizra> Modius: Type declarations are a huge help for debugging for newbs like me. And they're good for documenting stuff as well.
08:19:30 <chessguy_work> Modius, but yes, top-level definitions are mostly annotated explicitly
08:19:41 <chessguy_work> Modius, yes, i'm familiar with c#
08:19:46 <cizra> Modius: The only downside I know about is making a function needlessly narrow (String->String, insteald of [a]->[a] for example)
08:20:09 <rwbarton> Modius: one difference is the Haskell equivalent of "x.Foo" requires x to belong to some typeclass of which Foo is a member
08:20:12 <chessguy_work> Modius, for one thing, there are a lot less local variables in haskell
08:20:14 <Modius> cizra:  I am talking about variables defined within (C#3) functions - function definitions in this language are forced to privide their types
08:20:29 <rwbarton> Modius: whereas in C# "x.Foo" makes sense for any class x which has a Foo method
08:20:38 <Modius> chessguy_work:  Acknowledged - still having a tad less power, we still need them in C#3 for functional solutions
08:20:56 <rwbarton> Modius: there's more intent in the haskell version, the C# version is a bit like duck typing
08:21:44 <Modius> chessguy_work:  We end up still needing "temporaries" holding intermediate results of type Blah<Foo, Blah<Thing<Nee, Lookup<Y>>>>>
08:22:02 <chessguy_work> Modius, yes, i'm well aware of that
08:22:25 <Modius> In. . .  dispute.. . . .  is a restriction that would require that signature be typed in instead of "var"
08:22:32 <paper_cc> quicksilver: say I have module X that can render an X, module Y that can render an Y and module Main that contains the actual rendering callback. both X and Y have some state that will be modified by other callbacks. how do I let X and Y manage their own state by themselves in such situation?
08:23:07 <chessguy_work> Modius, it would be encouraged in haskell
08:23:13 <chessguy_work> in general
08:23:21 <Modius> But that is not for you guys - I just wanted to hear some terminology and any thought on the topic.  Technically, you could get the same effect in haskell by having "function" A call into B, change B's return type but have the return type still gel with what "A" is using it for.
08:24:03 <chessguy_work> Modius, this would also appear to be relevant: http://thread.gmane.org/gmane.comp.lang.haskell.beginners/748/focus=759
08:24:08 <Modius> chessguy_work:  You mean encourage typing of a local variable or equivalent?
08:24:29 <chessguy_work> Modius, explicit typing, yes
08:24:51 <chessguy_work> (it's still typed if you use 'var' in C#, or without a type annotation in haskell)
08:25:08 <rwbarton> I'd say it's pretty rare to see type signatures inside the body of a function where they're not needed (e.g. to resolve overloading)
08:25:22 <McManiaC> hey
08:25:33 <Modius> chessguy_work:  Sorry, I probably used bad terminology.  I realize it's explicitly typed, the "dispute" is over use of var or the full type annotation.
08:25:35 <chessguy_work> well, yeah, ok. i guess for local variables
08:25:37 <McManiaC> how can i define a type which is only either 1 oder 0?
08:25:42 <McManiaC> i thought its data Bit = 1 | 0
08:25:47 <McManiaC> but ghci doesnt seem to like it =)
08:26:03 <chessguy_work> McManiaC, you can't use numeric literals as data constructers
08:26:05 <paper_cc> McManiaC: data Bit = Zero | One. 0 and 1 are reserved =)
08:26:26 <McManiaC> okay
08:26:36 <quicksilver> paper_cc: personally I would create a datastructure holding all the state: data SimluationState = { xState :: X, yState :: Y }
08:26:42 <Cheshire> data Bit = O | I
08:26:47 <rwbarton> Also, you can't enter data declarations directly into ghci, if that's what you were trying to do.  They need to be in a file
08:27:05 <quicksilver> paper_cc: it's trivial to 'upgrade' a function X -> X into a function SimulationState -> SimulationState
08:27:15 <McManiaC> they are, rwbarton =)
08:27:16 <quicksilver> paper_cc: so you 'patch together' your modification functions like that
08:27:29 <quicksilver> the techniques for doing such things are sometimes called lenses or functional references.
08:27:49 <paper_cc> quicksilver: but it's non-trivial to add Z (at least you will have to recompile X and Y)
08:28:03 <quicksilver> paper_cc: no you won't. That's the whole point.
08:28:04 <Peaker> Modius: In C#, C++, Java,  you have "Blah.Attribute" and Attribute is looked up in the namespace defined by which type Blah is.  In Haskell, names are resolved regardless of types.  Type-classes may assign different implementations to different names, but the type and "meaning" is guaranteed to be the same,
08:28:13 <chessguy_work> Modius, rwbarton is right. usually we have explicit type annotations (the equivalent of your naming the type explicitly) at the top level, but not for local variables. but that's because we don't have very many local variables, and it's obvious what their types are
08:28:21 <quicksilver> paper_cc: X has functions which modify the X state (X -> X)
08:28:34 <quicksilver> paper_cc: the main module 'upgrades' those functions to operate on SimulationState
08:28:38 <quicksilver> but the X module doesn't know about that.
08:28:47 <paper_cc> aha, and then I have liftX :: X -> SimulationState?
08:28:56 <Peaker> Modius: so in C#, inferring the type of "X" may break "X.Blah" because Blah is looked up in a different namespace, but in Haskell, X.Blah is not valid, and "Blah x" is the same "Blah" regardless of what x is
08:28:56 <quicksilver> sort of.
08:29:05 <paper_cc> quicksilver: thanks =)
08:29:13 <quicksilver> liftXModifier :: (X -> X) -> (SS -> SS)
08:29:22 <quicksilver> getX :: SS -> X
08:29:27 <quicksilver> and so on
08:30:31 <Modius> Peaker:  Understood - yeah, the issue is cluttered by all the "class/object" baggage in play here.
08:31:34 <quicksilver> paper_cc: there is a rather good, and fairly short, blog by twanvl on this
08:31:45 <Peaker> Modius: OO classes being namespaces, in addition to the modules' namespaces is a horrible feature, IMO
08:31:47 <paper_cc> @where lenses
08:31:48 <lambdabot> I know nothing about lenses.
08:31:49 <quicksilver> paper_cc: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
08:32:07 <quicksilver> I think I recommend doing it by hand, the first time, so you get a feel for how it fits together.
08:32:14 <quicksilver> There is an implementation as Data.Accessor on hackage though
08:32:18 <Peaker> quicksilver: btw: I think functional-references are instances of 6.10's Category class
08:32:27 <Modius> Peaker:  Agreed to the power of 10
08:32:32 <quicksilver> Peaker: indeed they are, yes.
08:32:41 <Peaker> Data.Accessor is broken, I think, because it depends on the transformers package, rather than mtl
08:32:55 <Peaker> which is newer/more-maintained between mtl/transformers?
08:33:15 <quicksilver> I don't really like Data.Accessor's choice of primitives either.
08:33:19 <leimy> > liftM2 (*) [1..3] [4..6]
08:33:20 <lambdabot>   [4,5,6,8,10,12,12,15,18]
08:33:39 <leimy> :t liftM1
08:33:40 <lambdabot> Not in scope: `liftM1'
08:33:43 <Peaker> quicksilver: Instead of exporting ^> you should be able to use Category's compose, but its pretty horrible that you have to hide Prelude to do that
08:33:44 <leimy> er
08:33:48 <leimy> :t liftM
08:33:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:33:49 <Modius> chessguy_work:  Here's one for you:  An equivalent of the complaint I was hearing about var could be made in Haskell:    dosomething (length (somefunc 69))      somefunc returns a list of X.   Now somefunc is changed to return a list of Y
08:33:54 <leimy> :T LIFTM2
08:33:57 <leimy> damnit
08:33:59 <leimy> :t liftM2
08:34:01 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:34:27 <Peaker> I hope Haskell' will make liftM2, (>>) and others all be in Applicative
08:34:38 <chessguy_work> Modius, what's your actual question about that?
08:34:43 <leimy> I haven't messed with Applicative
08:34:50 <Modius> chessguy_work:  If in C# one happened to put the list into a local before requesting the length as a var, you would get the same behavior as using the non-local (no need for code change upon return type change, even though equivalent for length purposes).
08:34:51 <leimy> but from what i've been seeing it's powerful.
08:35:14 * leimy just started using Monoids with Parsec
08:35:33 <Peaker> leimy: Applicatives are like Monads, except you have (>>), ap, and liftM2, but not (>>=) or join
08:35:52 <leimy> :t ap
08:35:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:35:55 <Modius> chessguy_work:  A list of X and a list of Y are equivalent from the  perspective of wanting their length.  Would you want to tag the calling code to explicitly want and expect a list of "X" before taking lenght?
08:35:59 <leimy> :t (>>=)
08:36:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:36:09 <leimy> oooh
08:36:13 <leimy> interesting.
08:36:21 <Peaker> leimy: monads let you bind/sequence any effects you want, while looking at the result of any previous effect -- Applicatives disallow looking at the result of previous effects when choosing which stuff to sequence together
08:36:38 <leimy> Peaker, that's kind of nice
08:36:43 <leimy> because a lot of time I end up with
08:36:46 <chessguy_work> Modius, i wouldn't put the return of somefunc in a local variable in that haskell code, no
08:36:48 <leimy> blah >>= return . function
08:37:07 <leimy> anytime I need return . something, I could have done it with ap I guess.
08:37:11 <Peaker> leimy: it has nice properties in that it allows the implementation to do more interesting stuff that it can't for monads.  Also, IMO it makes more sense to speak of commutative Applicatives than commutative Monads, for example
08:37:18 <Peaker> leimy: with fmap
08:37:23 <leimy> yep
08:37:24 <Modius> chessguy_work:  But do you see any safeguard that you originally wanted "list of X" as worth ensuring within that function
08:37:26 <leimy> fmap works too.
08:37:31 <Peaker> leimy: Monad's fmap is liftM
08:37:49 <Peaker> Applicative's fmap is fmap, because it subclasses Functor properly :)
08:37:49 <leimy> I rarely use liftM, when I really should :-)
08:37:52 <chessguy_work> Modius, it is ensured by the fact that you used length on it
08:38:28 <Modius> chessguy_work:  It is assured that it has a length or is a list, NOT that it is a list of X, somefunc could be changed to return a list of Y
08:38:33 <Peaker> Modius: The problem they mention is an interesting one and shows why mixing up types and namespaces can really make type inference problematic
08:38:56 <Peaker> I have another point against C# when debating it from now on :-)
08:39:01 <chessguy_work> Modius, so what if they do?
08:39:10 <leimy> Peaker: yeah there's some occasions where fmap works were liftM does too
08:39:14 <Modius> Peaker:  My "list length", where length is a common  attribute rather than a member, is still an example of the wider issue.
08:39:18 <leimy> like I can use it on the result of readFile
08:39:20 <leimy> but not all things.
08:39:34 <Peaker> leimy: it should be all occasions, fmap and liftM are supposed to be equal. Monad forgot to subclass Functor so its not
08:39:38 <leimy> fmap parseFile $ readFile filename
08:39:45 <Peaker> leimy: but all Monad instances should also be Functor instances and have fmap which is identical to liftM
08:39:51 <leimy> but liftM works too
08:40:00 <leimy> So fmap for any Monad could be liftM?
08:40:07 <Peaker> leimy: yeah, and to avoid having (Functor m, Monad m) =>   its best to use liftM there :-(
08:40:08 <Modius> chessguy_work:  I consider it the equivalent of the example they gave in the argument against "var" - that the return type of the called function could change without requiring a change in caller due to equivalencce in the syntax of extracting a desired attribute.
08:40:12 <Peaker> leimy: yep
08:40:16 <leimy> damnit
08:40:32 <leimy> Getting this stuff right the first time is tricky when you're using the language that blazed the monad trail :-)
08:40:35 <leimy> so I understand.
08:40:40 <Peaker> yeah :)
08:40:40 <chrisdone> that is an awesome hostname
08:41:59 <leimy> Peaker: But I can use liftA there right now too eh?
08:42:10 <leimy> I mean, it'll stick my function into a monad
08:42:12 <leimy> so it works?
08:42:17 <Peaker> leimy: liftA is really there for symmetry, as Applicatives do subclass Functor and thus have fmap
08:42:24 <McManiaC> hmmmm One | Zero isnt exactly what i need, is there no way i can use "data" (or do i need sth else?) to control that only 1 and 0 (as Int) gets into my code?
08:42:29 <leimy> :t liftA
08:42:31 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
08:42:36 <leimy> Ah
08:42:45 <Peaker> leimy: If you use liftA and monad stuff you'll get:  (Applicative m, Monad m) => ...   and if you use liftM you'll get just (Monad m) => ...
08:43:08 <leimy> is there a runtime difference?  or just the type stuff?
08:43:33 <leimy> one is more general than the other I guess
08:43:36 <Peaker> I think (Applicative m, Monad m) => ... would translate to an extra type-class vtable argument for many functions, so it might have an effect on runtime in ghc
08:43:37 <Modius> Thanks for the insight, chessguy, Peaker, all - great getting insight from people who've had type inference available to them for more than 15 minutes
08:43:58 <leimy> very interesting...
08:44:16 <chrisdone> Modius: I know you from lisp circles. hiiii
08:45:41 <leimy> Now that I'm using Parsec I need to learn more about Either it seems
08:45:47 <leimy> I got really used to Maybe for error handling.
08:46:09 <quicksilver> Peaker: not likely to be terribly important since GHC inlines so agressively
08:46:12 <quicksilver> Peaker: but, you're right
08:46:18 <quicksilver> (and this is a difference between GHC and JHC)
08:46:38 <quicksilver> @users
08:46:38 <lambdabot> Maximum users seen in #haskell: 664, currently: 635 (95.6%), active: 24 (3.8%)
08:46:43 <chrisdone> leimy: Maybe Error or Maybe ValueWeWanted?
08:46:57 <Peaker> quicksilver: what does JHC do?
08:46:58 <leimy> Just result or Nothing :-)
08:46:58 <Cheshire> leimy, it's exactly the same except that instead of Nothing you get an error message
08:47:08 <quicksilver> Peaker: passes the type, not the dictionary
08:47:13 <leimy> Well, Maybe is an instance of MonadPlus :-)
08:47:15 <leimy> Either is not.
08:47:17 <leimy> I think
08:47:18 <quicksilver> Peaker: so it's only one argument, even if there are two constraints.
08:47:18 <Peaker> quicksilver: btw: I didn't come back to annoy you after I made Widget a record of functions :-)
08:47:25 <FunctorSalad> aren't both MonadError?
08:47:33 <quicksilver> Peaker: is that because it failed so badly you collapsed in despair?
08:47:38 <redditbot> On Identation
08:47:38 <redditbot> A Monadic, Functional Implementation of Real Numbers
08:47:38 <redditbot> grapefruit-ui: Declarative user interface programming on top of gtk2hs
08:47:39 <paper_cc> McManiaC: no you can't (at least you can't do that with typechecking)
08:47:46 <leimy> I don't think Either is a Monad at all.
08:47:50 <Peaker> quicksilver: nope, I am pretty satisfied with the progress :)
08:47:51 <leimy> according to the docs anyway
08:47:59 <Peaker> quicksilver: but I had to suspend it due to a heavy project I'm undertaking now at work
08:48:02 <quicksilver> it is, in Control.Monad.Error
08:48:05 <paper_cc> leimy: (Either errorMessage) is
08:48:07 <leimy> oh...
08:48:11 <quicksilver> (and it does also have a MonadPlus instance)
08:48:12 <FunctorSalad> nvm Maybe isn't MonadError  it seems
08:48:13 <leimy> I was looking at Data.Either.
08:48:18 <leimy> quicksilver: nice!
08:48:21 <quicksilver> Peaker: sucks
08:48:44 <Peaker> quicksilver: I ended up with a nice semantic model for widgets, as "model editors" which is only a little bit different from:  type Widget model = model -> (Image, Map Event model)
08:48:50 <FunctorSalad> (the error type is supposed to be able to contain string messages in MonadError)
08:48:51 <chrisdone> > Left "No!" >> Right 1 :: Either String Integer
08:48:51 <chrisdone> > Right 1 >> Left "Aw." :: Either String Integer
08:48:53 <lambdabot>   Left "No!"
08:48:53 <lambdabot>   Left "Aw."
08:48:56 <leimy> interesting
08:48:59 <leimy> runErrorT
08:49:03 <quicksilver> Peaker: that sounds very nice
08:49:05 <leimy> haven't played with that either :-)
08:49:13 <FunctorSalad> runError = error "runError ran"? ;)
08:49:26 <chrisdone> FunctorSalad: hehe
08:49:50 <Peaker> quicksilver: with conal's advice, I got rid of the Draw monad and I just unsafePerformIO font-size computations, because they are truly pure
08:49:58 <Peaker> quicksilver: so instead, I have a nicer "Image" there
08:50:24 <Peaker> last I worked on it, I struggled with how to add animations to this model though, and I can't figure out an elegant way yet
08:50:36 <Peaker> (I want editing of the model to animate the change, rather than just render a totally new image)
08:50:53 <quicksilver> Peaker: yes, that's quite an interesting problem in general.
08:51:05 <FunctorSalad> > throwError "omg it's an error" :: Either String Int
08:51:05 <quicksilver> Peaker: for example, how should the UI react to events which arrive mid-animation?
08:51:06 <lambdabot>   Left "omg it's an error"
08:51:14 <FunctorSalad> > return 1 :: Either String Int
08:51:16 <lambdabot>   Right 1
08:51:21 <quicksilver> Peaker: this is something I hoped to explore with my Reactive explorations.
08:51:26 <FunctorSalad> seems pretty handy, maybe it should be used more :)
08:51:35 <Peaker> quicksilver: I think it is okay to treat the animation as presentational only, but be in the new state immediately
08:51:46 <leimy> Yeah that's definitely cool.
08:51:50 <chrisdone> :m + Control.Monad Control.Applicative Control.Arrow Control.Monad.Error Data.List.Higher Data.Bool.Higher Data.Function Data.Typeable Data.Time Data.Time.Clock Data.Time.Format Text.Printf System.Locale Data.Traversable Control.Monad.Reader Data.Monoid Data.Maybe Data.List Data.Char Data.Ord System.IO System.Directory System Codec.Binary.UTF8.String Control.Monad.Maybe
08:51:52 <Peaker> quicksilver: it would be nice if the animation after another change would continue where it had left off
08:51:58 <chrisdone> that's my .ghci, what else is good to have?
08:52:02 <FunctorSalad> direct error handling by returning Either doesn't make it clear that it's for error handling...
08:52:16 <rwbarton> chrisdone: some kind of :set prompt I would imagine :)
08:52:29 <chrisdone> already got: :set prompt "Haskell> "
08:53:08 <Peaker> FunctorSalad: Maybe the answer is aliasing Either, Left and Right to Error, Error and OK
08:53:26 <quicksilver> Peaker: but the animation might not look like it's "ready" for the next action until a certain point
08:53:32 <quicksilver> Peaker: or it might even be moving or appear to move.
08:53:33 <chrisdone> :hoogle Failure
08:53:46 <quicksilver> Peaker: if several events arrive, do you queue up the animations or abort the earlier ones?
08:53:46 <chessguy_work> peaker: or Throws
08:53:52 <chessguy_work> (just kidding)
08:53:55 <chrisdone> http://hackage.haskell.org/packages/archive/applicative-extras/0.1.3/doc/html/Control-Applicative-Error.html#t%3AFailing
08:54:06 <chrisdone> useful ^
08:54:10 <quicksilver> Peaker: obviously I can see possible answers to all of these. I'm just saying it's an interesting bit to design.
08:54:14 <Peaker> quicksilver: I smoothly "integrate" the animations together :)
08:54:23 <Peaker> quicksilver: ideally
08:54:26 <FunctorSalad> Peaker: that or just replace "A -> Either String B" with "MonadError String m => A -> m B", but maybe that's a performance hit
08:54:27 <Peaker> quicksilver: (aborting the rest of the animation towards the discarded state)
08:54:34 <FunctorSalad> (and it's more to type :( )
08:55:08 <Peaker> FunctorSalad: You have to eventually choose a type somewhere, and that place is going to not be polymorphic and use Either - it won't be clear its for errors either, perhaps
08:55:08 <FunctorSalad> it would use dictionaries unless the user of that function is in the same project as the function, wouldn't it?
08:55:32 <chrisdone> anyone actually got benchmarks that clearly indicate using a typeclass instance is a performance hit over a concrete type?
08:55:35 <Peaker> quicksilver: I have a good idea of how I want it to look, but no idea how to translate that to a nice semantic model
08:55:41 <quicksilver> FunctorSalad: not necessarily, no, inlining is possible cross-package.
08:55:56 <Peaker> quicksilver: anyhow, thanks a lot for the advice there, you and conal really improved the widget set greatly :)
08:56:11 <FunctorSalad> quicksilver: inlining implies possibility type specialization? that's great
08:56:31 <quicksilver> FunctorSalad: GHC is really a whole-program compiler with some basic separate compilation support :)
08:56:47 <FunctorSalad> why are we warned not to use typeclasses if perfomance matters then?
08:56:57 <Peaker> how does ghc decide what to inline?
08:57:17 <quicksilver> if the source of the function is non-recursive and less than 42 characters.
08:57:30 <quicksilver> FunctorSalad: because not everything inlines :)
08:57:31 <Peaker> Hey, instead of having native compilation at one end and JIT at the other -- maybe you could compile with profile output from previous runs as input -- to hint about what's worth inlining/etc
08:58:03 <FunctorSalad> Peaker: or if you do {-# INLINE myFunction #-}
08:58:18 <Peaker> you could run programs in profile mode for a while, and then recompile them to "fast mode" where they're optimized to the way you use them
08:58:29 <Peaker> that would be a cool feature
08:58:37 <FunctorSalad> (I don't know how certain that makes the inlining though)
08:58:51 <wli> Nonrecursive doesn't sound like a great idea; unrolling loops can work wonders in numerous cases.
08:58:59 <Peaker> I think everything that's used just once should be inlined, I hope that's done
08:59:19 <FunctorSalad> wli: OTOH recursion is rare in haskell and one can hope that map, foldl etc. get optimized already
08:59:29 <Elly> what
08:59:32 <lpsmith> FunctorSalad:  that's reasonably certain,  however the inliner doesn't touch recursive definitions
08:59:35 <Elly> "recursion is rare in haskell"?
08:59:36 <chrisdone> Elly: you hear!
08:59:44 <chrisdone> Elly: he means explicit recursion
08:59:48 <Elly> oh
08:59:49 <Elly> yes
08:59:57 * Elly fades out again
09:00:01 <FunctorSalad> yes, as opposed to higher-order functions
09:00:18 <FunctorSalad> lpsmith: I see
09:00:19 <chrisdone> I can look at the bulk of my programs and find no explicit recursion
09:00:21 <quicksilver> Peaker: everything used once in inlined with a module but not cross-module
09:00:28 <quicksilver> (if it's non-recursive)
09:00:29 <chrisdone> (or use of the "if" syntax)
09:00:40 <wli> FunctorSalad: Try knot-tying.
09:00:41 <lpsmith> FunctorSalad:  You can also use GHC.Exts.inline  to ask for inlining on a call-site by call-site basis.
09:01:07 <osfameron> knot-tying hurts my brain..
09:01:09 <reprap> why do some languages force you to declare var X when var can be any type? is that to simplify parsing?
09:01:14 <Peaker> quicksilver: if its recursive its used more than once :)
09:01:16 <FunctorSalad> Peaker: I think everything that's used just once *and is not exported* is inlined
09:01:59 <chrisdone> reprap: which force you to do that?
09:02:44 <FunctorSalad> reprap: in C# it invokes type inference I think
09:03:00 <FunctorSalad> in other languages it may be to protect you from typos in expressions using that var
09:03:54 <chrisdone> FunctorSalad: how does declaring a variable which can be any type help inference?
09:05:09 <quicksilver>  /win 27
09:06:25 <Peaker> quicksilver: you're winful
09:07:17 <quicksilver> ;)
09:07:30 <FunctorSalad> chrisdone: var kitten; return (kittn + 1)
09:07:38 <FunctorSalad> err, it doesn't help inference
09:08:01 <FunctorSalad> with that line about C# I just meant that "var" tells C# to even do inference
09:09:52 <Alpounet> hi
09:10:14 <chrisdone> in lojban we say "coico'o"; greetings in passing
09:18:36 * quicksilver resists the temptation to hit chrisdone with the xkcd cartoon he's undoubtedly seen 100 times before.
09:19:25 <cizra> quicksilver: There should be a version translated into Lojban somewhere.
09:21:47 <lilac> quicksilver: which one are you thinking of?
09:22:12 <quicksilver> cizra: there is, yes, it is or used to be on lojban.org
09:22:20 <quicksilver> lilac: http://xkcd.com/191/
09:23:18 <lilac> cizra, quicksilver: http://imgs.xkcd.com/comics/lojban_translated.png
09:23:46 <stijntimbermont> Hi all
09:23:55 <Cale> hello
09:24:18 <stijntimbermont> What does it mean when a program (compiled with ghc) terminates with "<<loop>>"
09:24:34 <roconnor> > 54 *8
09:24:35 <lambdabot>   432
09:24:39 <quicksilver> stijntimbermont: it means it found an infinite recursion, which it was able to detect.
09:24:43 <quicksilver> (it can't detect all such)
09:25:00 <tromp> it cant even solve the halting problem??
09:25:07 <stijntimbermont> I see
09:25:11 <Peaker> quicksilver: why does JHC pass the type as arg instead of typeclass vtable? its going to have to perform the vtable lookup inside based on (type, typeclass) tuple anyhow?  If the idea is to pass less args through a big func invocation hierarchy, why not create vtable groups for various types based on what groups of vtables got passed in practice?
09:25:17 <quicksilver> tromp: it can, actually, but no one knows how long it takes.
09:25:21 <stijntimbermont> any tips on locating the infinite loop in the source code?
09:25:50 <quicksilver> Peaker: don't ask me as JohnMeacham. I think he has described some of his reasons on the -cafe in the past.
09:26:14 <quicksilver> Peaker: my understand is that reducing the amount to be passed is good though
09:26:23 <quicksilver> s/ as / ask /
09:26:27 <jacobian> stijntimbermont: I'd be curious for an answer to this as well.  Currently I'm using "observe" which does help quite a bit.
09:26:44 <Peaker> quicksilver: yeah, you can do that by passing around vtable groups
09:27:08 <Peaker> quicksilver: if you see (Monad m, Applicative a) => in types, then create a (Monad m, Applicative a) vtable or vtable-group, and pass that as a single arg
09:28:01 <Peaker> quicksilver: oops, Applicative m too. you can't group stuff of a different type
09:28:18 <quicksilver> Peaker: sure, but that's linear in the number of different contexts.
09:28:27 <quicksilver> Peaker: whereas the JHC way is just linear in the number of types.
09:28:29 <quicksilver> seems neater.
09:28:38 <stijntimbermont> the problem is that I have no idea where to start looking for a loop. I made a change that must have introduced it, but I see no apparent reason
09:28:39 <Peaker> quicksilver: probably incurs an extra lookup cost, though
09:28:56 <quicksilver> Peaker: only if that lookup can't be resolved at compile time.
09:29:04 <Peaker> GHC sucks for saying <<loop>> and not saying what happened more specifically
09:29:59 <quicksilver> well, it doesn't want to store symbol table information for every thunk that might blackhole.
09:30:07 <quicksilver> that would be major executable clutter.
09:30:40 <stijntimbermont> would be very useful during development though :)
09:31:09 <Cale> stijntimbermont: You might try ghci...
09:31:09 <Cheshire> that's a good idea for a debug switch
09:31:30 <Cale> I think you can :set -fbreak-on-exception
09:31:32 <SamB_irssi> , [t| String |]
09:31:33 <Cale> and then :trace
09:31:35 <lunabot>  ConT String
09:31:42 <Cale> (whatever thing is causing the loop)
09:32:04 <SamB_irssi> , [t| String |] >>= ppr
09:32:05 <lunabot>  luna: Not in scope: `ppr'
09:32:07 <SamB_irssi> , [t| String |] >>= pprint
09:32:09 <lunabot>  luna: Not in scope: `pprint'
09:33:00 <stijntimbermont> ghci loops without detecting it  ... But that doesn't say much either
09:34:23 <Cheshire> , [$ty| String |]
09:34:26 <lunabot>  luna: Exception when trying to run compile-time code:
09:37:41 <stijntimbermont> does :trace only work in between breakpoints?
09:38:09 <Peaker> quicksilver: debug information is "major executable clutter" :)
09:38:09 <Cale> stijntimbermont: Well, yes, the -fbreak-on-exception is supposed to treat exceptions as breakpoints though.
09:38:14 <Peaker> quicksilver: that's what DWARF is for
09:38:18 <stijntimbermont> i mean: is there a way to interrupt a looping process and then use :history to see where it was at that time
09:38:21 <Peaker> though DWARF is a horrible format
09:38:32 <Cale> stijntimbermont: yes, Ctrl-C should do it.
09:38:39 <stijntimbermont> ah .. I did't see that :/
09:38:39 <Cale> (with -fbreak-on-exception)
09:38:44 <Peaker> stijntimbermont: that's statistical profiling -- you may go with deterministic profiling if you just compile it in profile mode
09:38:53 <Peaker> or do what Cale said :)
09:39:26 <Cale> Oh, yes, you can also compile the thing with -prof -auto-all and run with +RTS -p on the commandline.
09:39:44 <Cale> You'll get a .prof file telling you how many times each function was entered.
09:39:55 <Cale> (Hopefully helping you work out where the loop is)
09:40:34 <quicksilver> Peaker: well my point is that in a typical C-like language the overhead of naming every function is actually not that big.
09:40:50 <quicksilver> Peaker: but in an STG-compiler, the overhead of naming every single thunk would be enormous.
09:41:13 <drhodes> there's a {if __name__ == __main__: run some tests while building a module} idiom in python which is good for testing.  The issue is runhaskell is looking for a main, however, with more than one module involved, there's more than one main, then "hiding (main)" will be needed. Is there a better approach?
09:42:39 <Peaker> quicksilver: then only name thunks that happen to have names as functions already
09:43:03 <Peaker> quicksilver: Actually, who cares if debug mode throws in a lot of extra clutter?
09:43:47 <quicksilver> it's just a question on the magnitude of 'a lot'
09:43:53 <quicksilver> but you're right, of course.
09:44:00 <stijntimbermont> I tried the :trace approach, I let my program go for a while (it is supposed to print stuff, but that doesn't seem to happen), then I interrupt it, but the :history doesn't tell me much, its only 21 lines
09:44:02 <quicksilver> -prof -auto-all does something a bit like it
09:44:10 <stijntimbermont> lets try that other approach
09:45:02 <Cale> drhodes: When you compile, you can use --main-is to say which IO action should be main.
09:45:34 <Cale> drhodes: So you don't have to name them all main.
09:45:46 <drhodes> thanks Cale
09:46:05 <lpsmith> Ok,  I've been playing with lhs2TeX's "eval" feature,  which allows one to call ghci to generate parts of your paper
09:46:06 <stijntimbermont> hmm its complaining that I don't have profiling libs for some dependency
09:46:11 <Cale> er, -main-is rather
09:46:11 <lpsmith> And now I have things kind of working
09:46:28 <lpsmith> but I can't use any definitions in my paper inside \eval{}
09:47:14 <FunctorSalad> ghc is really weird with the one-dash two-dash thing ;)
09:47:31 <FunctorSalad> compatiblity I suppose
09:47:34 <Cale> stijntimbermont: If it's a package from hackage, you can use something like  cabal install -p --reinstall <packagename>
09:48:14 <stijntimbermont> Cale: thanks, google said something similar :)
09:50:02 <maltem> FunctorSalad: along with that funny -(one strange letter)(actual option name) convention, so favoured among compiler writers
09:50:32 <Cale> maltem: Yeah, that's pretty silly :)
09:50:42 <Cale> @quote flags
09:50:43 <lambdabot> shapr says: GHC has more flags than the UN
09:50:55 <FunctorSalad> I can understand that one, e.g. 'd' for the various dump options
09:51:15 <Alpounet> @quote GHC
09:51:15 <lambdabot> gaal says: (ghc predicted a cpu death on my computer once.)
09:51:23 <Cale> @ghc
09:51:23 <lambdabot> ghc says: Implicit parameters escape from the monomorphic top-level binding(s)
09:51:27 <Cale> @ghc
09:51:27 <lambdabot> ghc says: eval_thunk_selector: strange selectee
09:51:37 <Alpounet> hah
09:51:53 <Cale> @ghc
09:51:53 <lambdabot> ghc says: Functional dependencies conflict between instance declarations
09:51:57 <maltem> FunctorSalad: I'm OK with d for dump, but f for flag is a little dumb :)
09:52:43 <maltem> FunctorSalad: also it's actually -ddump-*, which kind of defeats the purpose of prefixing it with a d
09:52:58 <quicksilver> maltem: it all maintains the important sense of mystique.
09:53:02 <Cale> I'm starting to think that it's a little silly for the -X... flags to even exist, since it's more convenient to use LANGUAGE pragmas anyway.
09:53:09 <FunctorSalad> maltem: I noticed that after I said it ;) maybe d=debug
09:53:29 <Peaker> Cale: there's another important advantage -- changes to pragmas, rather than cli options, appear in the mtimes and rebuild properly
09:53:37 <quicksilver> if it wasn't for stuff like -optl-shared well, just anyone might be able to build shared libraries.
09:54:23 * FunctorSalad once wrote like 5 variants of "--show-iface" before he caught the right one
09:54:32 <FunctorSalad> show-interface, show-iface-file, ...
09:56:21 <leimy> @users
09:56:21 <lambdabot> Maximum users seen in #haskell: 664, currently: 640 (96.4%), active: 22 (3.4%)
09:56:28 <maltem> Well I suppose we just have to live with those names.
09:56:35 <pumpkin> how is lambdabot so forgetful?
09:56:56 <leimy> no persistent state?
09:57:10 <pumpkin> it does have persistent state though
09:57:14 <pumpkin> maybe not for the @users though
09:57:15 <pumpkin> hmm
09:57:21 <maltem> lunabot: @users
09:57:21 <maltem> ... whatever the syntax would be
09:57:25 <FunctorSalad> maltem: if there were synonyms for option, we'd have to ponder which to use because it looks best, which would be even worse :-(
09:57:37 <FunctorSalad> (I mean I agree with you)
09:58:17 <maltem> FunctorSalad: Yeah I could imagine those arguments :)
09:59:48 <eu-prleu-peupeu> hi there
10:00:12 <eu-prleu-peupeu> is everything fine ?
10:02:11 <paper_cc1> , src src
10:02:12 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
10:02:22 <paper_cc1> , src 'src
10:02:25 <lunabot>  src :: Name -> Doc
10:05:52 <stijntimbermont> I have my program now producing profile info, but that does not seem to help me either: there is not really some function standing out
10:09:26 <reprap> hmm not only is the haskell way of splitting programs in sideeffectfree stuff and effectful stuff awesome in making programs easier to debug and program, it also the only thing that makes sense.
10:10:08 <roconnor> yep
10:10:15 <FunctorSalad> reprap: yes. I don't know how I'll ever manage to program with implicit side effects again :'-(
10:11:48 <stijntimbermont> I fixed my loop: really strange
10:12:00 <roconnor> @type callCC (\x -> return Left (\a -> x (Right a)))
10:12:02 <lambdabot> forall a b. (MonadCont ((->) a)) => a -> Either a b
10:12:30 <roconnor> @type callCC (\x -> return (Left (\a -> x (Right a))))
10:12:31 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m) => m (Either (b1 -> m b) b1)
10:13:31 <roconnor> @type callCC (\x -> put 'a' >> return (Left (\a -> put 'b' >> x (Right a))))
10:13:32 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m, MonadState Char m) => m (Either (b1 -> m b) b1)
10:13:45 <stijntimbermont> I had something like this:    do { .....   let  { x = ... ; y = ...x... } ;   .... }        replaced it with   do {  ...  x <- return (..); y <- return (...x...)  ; ......  }      loop is gone!
10:14:01 <reprap> I find so often when I really have to write code that works under all circumstances(menaing productioncode not my own personal project) it means cluttering it with exceptions and such and if you really want to amek it safe there is a lot of them and still you kind of need to pass around something liek True/False for sucess fail and it isnt pretty
10:14:17 <roconnor> stijntimbermont: that seems unusual
10:14:50 <Cheshire> stijntimbermont: oh I make that mistake all the time!
10:14:55 <FunctorSalad> stijntimbermont: the ghc user guide does mention that let is Bad for performance because of lazyness
10:15:11 <roconnor> what's wrong with you people!
10:15:26 <Cheshire> stijntimbermont: the binding rules with let inside do notationare totally stupid
10:15:26 <FunctorSalad> I wouldn't have thought that x <- return ... is less lazy though
10:15:32 <Cheshire> let x = x gives a fixedpoint
10:15:36 <Cheshire> x <- return $ x  doesn't
10:15:42 <Cheshire> it gives an out of scope in this case
10:15:44 <pumpkin> benl23: you around?
10:15:59 <Cheshire> :t do let x = 3 ; return ()
10:16:01 <lambdabot> parse error (possibly incorrect indentation)
10:16:15 <roconnor> stijntimbermont: everyone here is wrong.  let is really nice.  I'm surprised you were having trouble.
10:16:22 <stijntimbermont> even if let is bad for performance, i don't see how it can ever lead to an infinite loop
10:16:27 <rwbarton> stijntimbermont: you must have y in the RHS of let x = ...
10:16:44 <rwbarton> and there must already be a y in scope before the let
10:16:46 <Cheshire> roconnor, let inside do notation is /nice/?
10:16:48 <FunctorSalad> hmm thought you just meant performance
10:16:51 <stijntimbermont> and i don't see why  x <- return (.....)  is less lazy than  let x = ....
10:17:00 <roconnor> stijntimbermont: rwbarton is right.  You probably accidently shadowed some variable.  That is the source of many of my loops
10:17:07 <Cheshire> stijntimbermont: no it's about scoping rules -- not lazyness
10:17:34 <stijntimbermont> i'll double check whether it's a shadowing problem
10:17:48 <FunctorSalad> is "case (f x) of { y -> stuff }" less lazy than "let y = f x in stuff" ?
10:17:49 <Cheshire> you can write  let x = 1 : x  to get a infinite list but  x <- return (1 : x)  will either say x is out of scope or use a previous binding of x
10:18:11 <rwbarton> FunctorSalad: no (only less polymorphic)
10:18:24 <paper_cc> btw, is "do { let foo = bar; baz }" actually "let foo = bar in baz" or "(\bar -> baz) foo"?
10:18:27 * roconnor wonders if -Wall would reveal the shadowning
10:18:35 <gour> anyone is playing with turbinado framework?
10:18:36 * czShadoW hates shadowing, because of highlight.
10:18:57 <FunctorSalad> rwbarton: hmm would "let !y = f x in ..." be a good idea then?
10:19:23 <rwbarton> roconnor: I think it should
10:19:38 <rwbarton> paper_cc: it is really let foo = bar in baz, I think
10:19:40 * rwbarton checks report
10:19:41 <FunctorSalad> (assuming f x will definately get evaluated at some point, and that this is an inner loop)
10:19:54 <stijntimbermont> It was a shadowing probem :$
10:20:03 <koeien> FunctorSalad: if you are sure of that, you may do ! yes
10:20:15 <roconnor> > runStateT (runCont (callCC (\x -> modify (++'a') >> return (Left (\a -> modify (++'b') >> x (Right a))))) id) 'c'
10:20:16 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
10:20:19 <koeien> in that case, the semantics are the same; you might ged improved performance
10:20:20 <stijntimbermont> anyway, my problem is fixed, thanks for the help guys
10:20:23 <roconnor> > runStateT (runCont (callCC (\x -> modify (++'a') >> return (Left (\a -> modify (++'b') >> x (Right a))))) id) "c"
10:20:24 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
10:20:39 <roconnor> > runStateT (runCont (callCC (\x -> modify (++"a") >> return (Left (\a -> modify (++"b") >> x (Right a))))) id) "c"
10:20:41 <lambdabot>       Occurs check: cannot construct the infinite type:
10:20:41 <lambdabot>        r = Either (b1...
10:20:58 <roconnor> ah right
10:21:40 <roconnor> stijntimbermont: did the shadowing involve 'y' ?
10:21:41 <koeien> > case undefined of () -> "37" -- FunctorSalad
10:21:42 <lambdabot>   "* Exception: Prelude.undefined
10:21:47 <roconnor> ah too late
10:21:57 <koeien> > let () = undefined in "37" -- FunctorSalad
10:21:59 <lambdabot>   "37"
10:22:07 <koeien> FunctorSalad: so yes there is a difference in strictness
10:22:11 <paper_cc> > case undefined of x -> "foo"
10:22:11 <roconnor> > case undefined of _ -> "37" -- koeien
10:22:13 <lambdabot>   "37"
10:22:13 <lambdabot>   "foo"
10:22:24 <koeien> ah yes
10:22:28 <FunctorSalad> koeien: thanks
10:22:28 <paper_cc> > (\x -> "37") undefined
10:22:29 <lambdabot>   "37"
10:22:38 * koeien substituted y for some "real" stuff, but this is not necessarily the case
10:22:51 <FunctorSalad> so bang is redundant on the outermost level of "case" patterns?
10:23:02 <koeien> no it's not :/
10:23:05 <koeien> :)
10:23:33 <FunctorSalad> hmm
10:23:58 <FunctorSalad> > let !() = undefined in "37"
10:23:59 <lambdabot>   "* Exception: Prelude.undefined
10:24:13 <paper_cc> case undefined of 0 -> "foo"; _ -> "bar"
10:24:18 <paper_cc> > case undefined of 0 -> "foo"; _ -> "bar"
10:24:20 <lambdabot>   "* Exception: Prelude.undefined
10:24:37 <FunctorSalad> paper_cc: well that couldn't possibly work, but it's interesting that even with just one branch it doesn't
10:26:25 <FunctorSalad> > case (undefined :: ()) of _ -> "38"
10:26:27 <lambdabot>   "38"
10:26:57 <FunctorSalad> aha, so what koeien wrote isn't considered an exhaustive pattern match because undefined isn't matched? :(
10:27:24 <paper_cc> > case (undefined :: ()) of x -> (const "foo) x
10:27:25 <lambdabot>   <no location info>:
10:27:25 <lambdabot>      lexical error in string/character literal at chara...
10:27:32 <paper_cc> > case (undefined :: ()) of x -> (const "foo") x
10:27:33 <lambdabot>   "foo"
10:27:41 <lilac> > case undefined of !x -> "42"
10:27:42 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
10:27:50 <lilac> , case undefined of !x -> "42"
10:27:51 <lunabot>  luna: Prelude.undefined
10:27:58 <roconnor> > case undefined of ~() -> "42"
10:28:00 <lambdabot>   "42"
10:28:06 <paper_cc> > {-# LANGUAGE BangPatterns #-} case undefined of !x -> "42"
10:28:07 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
10:28:08 <rwbarton> FunctorSalad: I don't think that's accurate; by that definition only trivial "pattern matches" would be exhaustive
10:28:27 <FunctorSalad> rwbarton: hmm true
10:31:35 <FunctorSalad> "non-exhaustive match" was just my bogus explanation why it would even try to match anything in a one-branch case statement
10:32:09 <adrian_> @pl \n -> [1..n] >>= f
10:32:09 <lambdabot> (f =<<) . enumFromTo 1
10:33:01 <pmurias> hi
10:33:12 <pmurias> is Parsec the right thing for parsing binary data?
10:33:48 <paper_cc> err... interpreting binary file formats?
10:33:50 <paper_cc> no
10:34:05 <paper_cc> Data.Binary is
10:34:18 <paper_cc> (or Data.MMap, or ...)
10:35:10 <FunctorSalad> Data.Binary seems good, but wouldn't a Parsec with token type Word8 work too?
10:35:14 <skorpan> how does alex handle unicode characters by itself? does yi provide this? because when i'm trying out some unicode characters in standalone alex, it won't recognize them.
10:35:25 <tarcieri> hi
10:35:29 <tarcieri> is Haskell stackless?
10:36:03 <Lemmih> tarcieri: No.
10:36:13 <tarcieri> so it uses the C stack?
10:37:01 <paper_cc> undoubtely it uses the CPU stack SS:ESP
10:37:02 <Lemmih> tarcieri: That depends on the implementation. There are quite a few Haskell compilers.
10:37:11 <Cheshire> tarcieri, what does stackless mean?
10:37:26 <tarcieri> Cheshire: keeps its own stack on the heap as opposed to using the C stack
10:37:32 <pmurias> paper_cc: Data.Binary seems very low level
10:37:44 <tarcieri> Cheshire: Erlang is stackless, for example
10:37:46 <smtms> tarcieri, what has C to do with Haskell?
10:37:48 <Cheshire> tarcieri, well haskell evaluation is not even stack frame based -- we use graph reduction
10:38:38 <tarcieri> I have very little idea about how Haskell is actually executed...
10:38:45 <tarcieri> like what the runtime actually is
10:38:58 <lilac> tarcieri: usually people want to know whether a language is stackless for weird coroutine hacks
10:39:10 <lilac> you can do weird coroutine hacks in haskell
10:39:12 <wli> The evaluation model depends on the compiler. I think ghc uses 2 or 3 stacks, and other compilers do other things.
10:39:37 <FunctorSalad> putting Debug.Trace.trace statements everywhere made /me realize that he knows nothing about haskell evaluation either ;)
10:39:49 <tarcieri> lilac: I'm interested because another VM I've been following just went from stackless to "stackfull" as saw a pretty substantial performance improvement
10:40:06 <smtms> tarcieri, which VM is that?
10:40:15 <tarcieri> Rubinius
10:40:17 <smtms> tarcieri, I've heard about VM's going in the other direction :-)
10:40:32 <tarcieri> it's Smalltalk 80 inspired, and I guess Smalltalk 80 was originally stackless
10:40:42 <Cheshire> I don't understand what it means
10:40:53 <Cheshire> how can you keep your own stack
10:40:54 <Cheshire> ?
10:41:21 <tarcieri> you keep your own stack in the heap
10:41:55 <pmurias> paper_cc: what i want is to describe the format declarativly instead of outputing/reading individual bits
10:42:07 <paper_cc> Cheshire: you can even avoid using CALL and RET at all ... why not?
10:42:22 <hackage> Uploaded to hackage: sexpr 0.1.1
10:42:39 <paper_cc> pmurias: ahem. then it's beyond my experience =)
10:42:48 <Cheshire> paper_cc, it doesn't really make sense to me
10:43:02 <Cheshire> paper_cc, I don't know how to program assemlbb though
10:44:01 <lpsmith> Argh,  I hate type classes sometimes.    So I decided,  for the sake of clarity,   to use a typeclass.   Nevermind what I really want in the circumstance is an ML-style functor.
10:44:05 <pmurias> paper_cc: i might end up building something on top of Data.Binary if i don't find anything that does what i want
10:44:21 <FunctorSalad> Cheshire: I think you can just imagine a "while" loop that manually manipulates some explicit stack
10:44:33 <lpsmith> And what was a zero-penalty abstraction now is a order of magnitude slower
10:44:38 <FunctorSalad> (in a stateful language, obviously)
10:45:00 <Cheshire> oh I see
10:45:03 <paper_cc> Cheshire: well, "calling" something (in simple imperative languages) is just remembering where you want to return and jumping to some other piece of code. When it encounters, say, a C "return", it gets the return pointer and jumps back to the caller. Stack is just a convenient place to store such return info
10:45:09 <Cheshire> who calls that stackless? :S
10:45:22 <tarcieri> what exactly is Haskell's execution model
10:46:01 <dmead> ?seen dons
10:46:02 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 21h 55m 42s ago.
10:46:08 <FunctorSalad> hehe
10:46:09 <lilac> why would anyone use a stackless model? that's like saying "I'm not going to use the EAX and EBX registers, just because I'm not"
10:46:20 <Cheshire> then I implement haskell in a stackless way
10:46:26 <tarcieri> lilac: lightweight concurrency
10:46:26 <maltem> tarcieri: not sure about "exact", but it's good to think of it as term rewriting
10:46:31 <Cheshire> tarcieri, using the definitions above
10:46:45 <Cheshire> maltem, do you miss out on sharing with that model though?
10:46:55 <lilac> tarcieri: that makes no difference; ESP and EBP are just registers
10:47:09 <maltem> Cheshire: well it's term rewriting with sharing :-/
10:47:12 <wli> Not exactly. Stacklessness has more to do with how the calling convention stores e.g. spilled registers, etc.; the stack model is not uniquely privileged above all other possibilities.
10:47:13 <lilac> tarcieri: why does it matter which register your stack pointer is in?
10:47:46 <tarcieri> heh, Haskell just confuses me
10:47:53 <lpsmith> There are many reasons for not using C's stack,  not just concurrency
10:48:20 <paper_cc> non-trivial execution model with memos and lazyness and ...?
10:48:24 <FunctorSalad> maybe a dumb question, but why is it called "C stack"? sounds like a processor-level thing
10:48:35 <paper_cc> s/lazyness/laziness/
10:48:56 <tarcieri> like uhh, GHC takes your Haskell code and turns it into C-- code, and then ???
10:49:04 <tarcieri> I think I'm missing a few steps there
10:49:07 <Cheshire> I guessed C builds a bit/abstrarcts a bit over the assembly kind of thing (which is just incrementing a pointer right?)
10:49:14 <tarcieri> like where the garbage collector shows up in the whole equation
10:49:24 <Cheshire> tarcieri, at runtime
10:49:32 <maltem> tarcieri: oh, *that* kind of execution model :)
10:49:43 <erikc> tarcieri: http://hackage.haskell.org/trac/ghc/wiki/Commentary
10:50:02 <tarcieri> maltem: yeah, how does Haskell tell the CPU to do stuff
10:50:04 <erikc> its a pretty different execution model
10:50:05 <Cthulhon> lilac: Well, general execution model aside, x86 has so many implicit register uses, it'd be pretty inefficient to not use ESP for the stack.  Much longer encoding of some instructions, and others like push/pop/call/ret would have to be decomposed into more explicit operations.
10:50:16 <maltem> tarcieri: GHC builds an executable that includes the run-time system (RTS)
10:50:25 <tarcieri> ok
10:50:31 <wli> FunctorSalad: Sometimes it is, sometimes it isn't. On x86(-64) it is to some extent hardwired into the CPU. In others (e.g. MIPS) there is no particular special treatment of any register as a stack register or automatic usage by the CPU of a stack. On others, e.g. SPARC, register spilling to a C-like stack is automated even beyond automatic stack usage in various cases like in x86(-64).
10:50:33 <paper_cc> Cheshire: it's like *stack = &returnAddr; stack++; jump(Function). Even assembly abstracts over it and calls it CALL Function =)
10:50:43 <maltem> tarcieri: It's just a plain old executable, principally the same kind you get out of a C compiler
10:50:45 <Cheshire> weird
10:51:00 <paper_cc> what?
10:51:15 <pmurias> FunctorSalad: it's called the C stack because C uses it
10:51:47 <paper_cc> pmurias: a C interpreter wouldn't use the CPU stack
10:51:49 <wli> FunctorSalad: IA64 goes even beyond SPARC in having a "backing store" parallel to a stack, which acts something like a secondary stack.
10:52:06 <dmead> hey channel
10:52:17 <dmead> i have a question but i'm not sure how to ask it
10:52:21 <dmead> so i'll just form it like a retard
10:52:32 <dmead> how do you write loops without running out of memory?
10:52:35 <tarcieri> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/FunctionCalls
10:52:36 <wli> FunctorSalad: IA64 even automates access to both those stack-like affairs in a fashion similar to how SPARC does it for its single stack.
10:52:37 <tarcieri> aaaah
10:52:44 <Cheshire> dmead, I don't even write loops at all
10:52:53 <paper_cc> dmead: use strict folds
10:53:00 <dmead> say i want to write a blocking serial driver, what prevents the runtime from gobbling up the machine's memory?
10:53:29 <dmead> Cheshire, some people design memoizing loop operators
10:53:31 <FunctorSalad> wli: *nod* :)
10:53:37 <dmead> which is really what i'm asking
10:53:42 <tarcieri> okay cool
10:53:45 <tarcieri> wiki link was very informative
10:53:46 <dmead> anybody?
10:53:46 <tarcieri> thanks
10:53:49 <Cheshire> dmead, that sounds horrific
10:53:58 <FunctorSalad> (/me only knows a bit of MIPS from school as far as assembly is concerned)
10:54:11 <dmead> Cheshire, it's a trick to be able to do threaded blocking I/O
10:54:27 <dmead> to design real world software, you need that
10:54:39 <paper_cc> dmead: well, blocking I/O isn't a Haskell loop (whatever a Haskell loop is)
10:54:46 <Cheshire> dmead, really.. because I have not heard of "memoizing loop combinators" before
10:54:55 <pmurias> paper_cc: a stackless C interpreter wouldn't, a stackfull one would
10:55:23 <paper_cc> pmurias: by definition =)
10:55:50 <dmead> paper_cc, like i said, i'm not sure how to ask the question
10:56:02 <dmead> but i think i've gotten the idea across, yes?
10:57:03 <lilac> Cthulhon: that was my point. if you're going to have something stack-like, why /not/ use the CPU's stack register?
10:57:05 <paper_cc> no I think =( it even took me quite a bit of time to remember what "memoizing" is ...
10:57:14 <paper_cc> dmead: ^^
10:57:21 * paper_cc blames himself
10:57:48 <dmead> :P
10:58:10 <dmead> thats the only term i know that properly describes this concept
10:58:27 <dmead> i want to write blocking i/o that doesn't eat up memory
10:58:57 <dmead> i'm just not sure of the ins and outs in how to do that in a pure langauge
10:59:09 <Mauke> with IO
10:59:09 <dmead> C et al is really easy of course
10:59:22 <paper_cc> blocking on I/O will block on some OS internal structures without eating any memory at all ... unless you want to perform an active wait
10:59:42 <dmead> active wait as in?
10:59:50 <dmead> continually reading the input?
10:59:51 * maltem was wondering if mauke had been permanently capitalized
11:00:07 <stepcut> dmead: left-fold enumerators?
11:00:14 <FunctorSalad> erm I don't really know what I'm talking about, but isn't one of the hGet family of functions already blocking automatically?
11:00:25 <dmead> stepcut, theres nothing to enumerate
11:00:38 <dmead> say you just want to print the bits coming in from a serial port
11:00:40 <mauke> ok, which Haskell IO functions don't block?
11:01:42 <dmead> well it's a deeper problem than just blocking, you also have to read dev links and handle all sorts of stuff AND memoize
11:01:48 <chrisdone> unsafePerformDontBlock
11:01:50 <mauke> what?
11:02:06 <dmead> so what are you supposed to do with that then?
11:02:14 <dmead> keep calling it recusivly?
11:02:18 <mauke> I've written an IRC bot in Haskell, does that count?
11:02:21 <dmead> sure
11:02:40 <mauke> so what's the problem here?
11:03:41 * sw17ch wishes Language.C used record syntax and had derived Show for most of its data types :(
11:03:46 <sw17ch> deriving*
11:03:53 <stepcut> dmead: you could print the bits using left-fold enumerators... how is that different than printing in incoming network connection?
11:03:59 <paper_cc> dmead: then, you are operating over a stream of input events [that FRP stuff...]
11:04:32 <dmead> stepcut, i'm not sure.. i guess i have to give it a think
11:04:42 <paper_cc> dmead: you _can_ write mapM_ (putStrLn . show) (some infinite stream ...) and don't block
11:04:45 <gbacon> is it possible to lazily select n random elements of a list?
11:04:49 <dmead> i'm pretty ignorant of doing useful IO in haskell
11:04:52 <FunctorSalad> sw17ch: maybe you could add a "{-! global : derive Show !-}" and run DrIFT on it?
11:05:02 <dmead> gbacon, yes
11:05:04 <sw17ch> FunctorSalad: what black magic is this?
11:05:07 <FunctorSalad> (not sure if that was the exact syntax)
11:05:08 <dmead> > take 5 [1..10]
11:05:10 <lambdabot>   [1,2,3,4,5]
11:05:11 <gbacon> dmead: got a pointer?
11:05:23 <mauke> sw17ch: do you know about standalone deriving?
11:05:26 <dmead> take is lazily evaluated
11:05:29 <dmead> iirc
11:05:31 <sw17ch> mauke: no!
11:05:38 <sw17ch> do explain
11:05:41 <sjanssen> dmead: almost all IO functions block the current thread, but allow all other threads to run
11:05:44 <mauke> 'deriving instance Show Foo'
11:05:52 <mauke> bam, now Foo implements Show
11:05:56 <FunctorSalad> sw17ch: http://repetae.net/computer/haskell/DrIFT/
11:05:56 <sw17ch> no way
11:06:02 <gbacon> dmead: right, but say I want to take 7 random elements from [1..]
11:06:09 <dmead> random elements?
11:06:27 <paper_cc> @ty randoms
11:06:28 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
11:06:44 <dmead> hmm
11:06:48 <dmead> is that still lazily evaluated?
11:06:50 <osfameron> can't really do that for an infinite list...
11:07:14 <gbacon> I want to avoid computing the list's length and therefore holding the whole mamajama in core
11:07:20 <dmead> osfameron, you can put the upper bounds of the rand() call have to be known
11:07:29 <FunctorSalad> sw17ch: just add "{-! global : Show !-}" on top of the file, run DrIFT on it and hope it doesn't die ;)
11:07:50 <sw17ch> oh my
11:07:50 <osfameron> dmead: yeah
11:08:13 <osfameron> gbacon: there's a nice algorithm for that
11:08:19 <gbacon> the single-element case is elegant: accumulate your current index and if randR (0,1) < (1/index), that's your hit
11:08:27 <FunctorSalad> sw17ch: err not totally on top, after the import statements (not sure it matters)
11:08:38 <paper_cc> :t randomRs
11:08:40 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
11:08:42 <gbacon> osfameron: [citation needed] :-)
11:08:43 <paper_cc> gbacon: ^^
11:09:14 <gbacon> paper_cc: I'm not really trying to generate random integers
11:09:35 <osfameron> gbacon: yeah, that one tbh. i blogged about it ages ago.. citation? i think it's in the nethack source
11:10:14 <osfameron> for multiple random elements there's a similar algorithm iirc
11:10:17 <dmead> gbacon, but thats what you need to do if you want to select random elements
11:10:19 <FunctorSalad> sw17ch: btw I meant the file that contains the data types that need the Show instance
11:10:21 <paper_cc> gbacon: well, map (xs !!) . randomRs (0, length xs)   =)
11:10:37 <mauke> paper_cc: now do it in constant memory
11:10:45 <gbacon> mauke: right
11:10:56 <paper_cc> hmm
11:11:02 <mauke> paper_cc: also, that can select the same element twice
11:11:09 <paper_cc> I can't generate O(N) of memory in constant memory
11:11:30 <mauke> assume the number of elements we want to take is fixed
11:12:04 <gbacon> what I'm really trying to do is select files from a pool at random, so I'm thinking of forkIO-ing directory walkers that will write back to a channel and then drawing randomly from getChanContents
11:12:40 <sw17ch> FunctorSalad: well, i just found a way around it using makue's suggestion
11:12:43 <paper_cc> mapAccumL (\xs n -> let xs
11:12:45 <paper_cc> err
11:13:02 <sw17ch> 24 deriving instances later... :)
11:14:14 <paper_cc> gbacon: mauke: mapAccumL (\xs' n -> let ys = drop n xs' in (head ys, tail ys)) (cycle xs) . randoms
11:14:33 <Cheshire> paper_cc, why not let (y:ys) = drop ... (y,ys)
11:14:36 <paper_cc> oops, that still can select the same elements =(
11:15:06 <gbacon> ?ty mapAccumL (\xs' n -> let ys = drop n xs' in (head ys, tail ys)) (cycle xs) . randoms
11:15:07 <lambdabot> Not in scope: `xs'
11:15:10 <FunctorSalad> sw17ch: I just assumed you didn't want to write "deriving instance" for every type
11:15:22 <gbacon> ?ty mapAccumL (\xs' n -> let ys = drop n xs' in (head ys, tail ys)) (cycle xs') . randoms
11:15:23 <lambdabot> Not in scope: `xs''
11:15:24 <sw17ch> FunctorSalad: I don't have access to the original libarary
11:15:24 <paper_cc> :t \xs -> mapAccumL (\xs' n -> let ys = drop n xs' in (head ys, tail ys)) (cycle xs) . randoms
11:15:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
11:15:26 <lambdabot>       Expected type: [a]
11:15:26 <lambdabot>       Inferred type: a
11:15:27 <FunctorSalad> btw, CPP is helpful if you need to do stand-alone derivings for multiple types ;)
11:15:30 <sw17ch> FunctorSalad: I didn't, your way would be nicer
11:15:36 <sw17ch> but in this case... it wasn't that bad
11:15:43 <paper_cc> @ty mapAccumL
11:15:45 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:15:56 <paper_cc> @ty randoms
11:15:57 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
11:15:59 <FunctorSalad> (err I mean deriving multiple typeclasses)
11:17:12 <lilac> gbacon: you want random numbers uniformly distributed from [1..] ?
11:17:24 <lilac> gbacon: you can't have them! that's not a distribution.
11:17:50 <gbacon> lilac: no, I have a list that's expensive to compute, and I want n random elements of it lazily
11:18:14 <gbacon> lilac: so I don't want to depend on length xs
11:18:20 <Baughn> lilac: Depends on the type..
11:18:34 <paper_cc> gbacon: [1..] is infinite. is your list infinite?
11:18:37 <Baughn> gbacon: You can't have N random elements from a list without knowing the size of the list
11:18:45 <lilac> Baughn: good point ;-)
11:18:56 <gbacon> Baughn: why?
11:19:07 <lilac> gbacon: you want n random /uniformly distributed/ elements?
11:19:16 <Baughn> gbacon: Well, not with a uniform distribution
11:19:20 <lilac> gbacon: you can't compute a uniform distribution without knowing the number of elemetns
11:19:27 <Baughn> gbacon: You could have an exponential distribution easily enough, I guess
11:19:44 <mauke> then why does it work for N=1?
11:19:46 <Baughn> gbacon: And "why"?
11:20:06 <Baughn> gbacon: ..there's no way to do it. To get the full reasoning for /why/ there is no way, take an introductory stats course. ;)
11:20:35 <lilac> gbacon: put it this way: the probability of picking the first element of your list needs to be 1/n. hence you need to know n.
11:20:52 <Baughn> gbacon: But basically, if you can't compute the probability that it'll be one particular element, then you can't pick any elements; and for a uniform distribution, the chance it'll be one element depends on the size of the list
11:20:57 <gbacon> lilac: but I can do that with an accumulating parameter
11:21:02 <Alpounet> Project Euler is quite easy with Haskell :-p
11:21:07 <gbacon> for the single-element case
11:21:11 <Baughn> gbacon: n has to be the same for every element
11:21:16 <lilac> gbacon: that you can do it in one pass (Knuth's method) is irrelevant; you still need to process the whole list before you produce one element.
11:22:13 <gbacon> lilac: not so.. I know I have my hit when randR (0,1) < 1/k
11:22:17 <Baughn> gbacon: Now, you *could* make up an exponential distribution, where the cumulative probability goes to 1 as the list size goes to infinity, in which case you could do it just fine without knowing n.. but it'd be anything but uniform, and it wouldn't be pure exponential either unless your list is actually infinite
11:22:20 <gbacon> where k is the accumulating parameter
11:22:25 <lilac> gbacon: that's not how it works!
11:22:46 <lilac> gbacon: you /switch/ which element you select with probability 1/k
11:23:02 <lilac> you can't stop until you've processed the whole list.
11:23:13 <lilac> otherwise your distribution is not uniform.
11:23:26 <lilac> indeed, you will /always/ pick the first element with your method :)
11:23:38 <gbacon> lilac: oh, you're right
11:23:39 <lilac> (randomR (0,1) < 1/1 with probability 1)
11:23:44 <gbacon> duh
11:24:11 <Baughn> gbacon: To get a uniform distribution, you MUST know the size of the list. There is no way around this, at all.
11:25:43 <mstr> > zip [1..10] [2..20]
11:25:44 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
11:27:10 <Baughn> gbacon: A better question, perhaps - does the distribution really need to be uniform?
11:28:07 * wli attempts to golf map (recip . fromInteger :: Integer -> Rational) . scanl1 (*) . unfoldr (\(u :: Rational) -> if u == 0 then Nothing else let a :: Integer = ceiling $ recip u in Just (a, u*fromInteger a - 1))
11:29:19 <Hiato> Hello all, I was just messing with Haskell (I learn by experimentation) and I was wondering if there was a trivial way to split an array (or whatever a [a,b,c] thing is called - pardon my ignorance) into n equal parts
11:29:31 <mauke> "list"
11:29:46 <lament> what if the length of the list is not divisible by n? :(
11:29:46 <mauke> yes, but there's no prewritten function for it (at least not in the standard libraries)
11:29:55 <mauke> I think there's something on hackage
11:29:57 <Baughn> Data.List.splitAt will take you halfway
11:29:58 <drhodes> :t break
11:30:01 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:30:05 <paper_cc> @ty splitAt
11:30:07 <lambdabot> forall a. Int -> [a] -> ([a], [a])
11:30:15 <paper_cc> @ty mapAccumL
11:30:17 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:30:30 <paper_cc> @hoogle (a, b) -> (b, a)
11:30:30 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
11:30:30 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
11:30:30 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
11:30:59 <Hiato> Hrmm.. ok, thanks, I'll check those out
11:31:30 <paper_cc> Hiato: splitAt is your friend, the others aren't =)
11:31:48 <Hiato> roger that, thanks
11:32:07 <drhodes> groupBy is a good one to check out too, it's related
11:32:48 <Hiato> many thanks paper_cc, splitAt was exactly what I needed, drhodes, I'll check out groupBy now, thanks
11:32:55 <Toxaris> @type uncurry (flip (,)) -- paper_cc
11:32:56 <lambdabot> forall b a. (a, b) -> (b, a)
11:33:00 <paper_cc> fst $ mapAccumL ((uncurry $ flip (,)) . uncurry splitAt) [1..] [2,6,3,4]
11:33:07 <paper_cc> >fst $ mapAccumL ((uncurry $ flip (,)) . uncurry splitAt) [1..] [2,6,3,4]
11:33:14 <paper_cc> > fst $ mapAccumL ((uncurry $ flip (,)) . uncurry splitAt) [1..] [2,6,3,4]
11:33:16 <lambdabot>   Couldn't match expected type `x -> ((Int, [a]), y)'
11:33:19 <mauke> :t snd &&& fst
11:33:20 <lambdabot> forall a b. (a, b) -> (b, a)
11:33:56 <paper_cc> > fst $ mapAccumL (uncurry splitAt . (snd &&& fst)) [1..] [2,6,3,4]
11:33:57 <lambdabot>   Couldn't match expected type `x -> (([a], Int), y)'
11:35:43 <Toxaris> @type (uncurry (flip splitAt))
11:35:45 <lambdabot> forall a. ([a], Int) -> ([a], [a])
11:36:18 <Cheshire> @type ((id && length) .) . uncurry (++)
11:36:19 <lambdabot>     Couldn't match expected type `Bool' against inferred type `a -> a'
11:36:19 <lambdabot>     In the first argument of `(&&)', namely `id'
11:36:19 <lambdabot>     In the first argument of `(.)', namely `(id && length)'
11:36:41 <Cheshire> @type (id &&& length) . uncurry (++)
11:36:42 <lambdabot> forall a. ([a], [a]) -> ([a], Int)
11:37:03 <ozy`> :t uncurry . flip splitAt
11:37:04 <lambdabot>     Couldn't match expected type `b -> c'
11:37:06 <lambdabot>            against inferred type `([a], [a])'
11:37:07 <ozy`> awww
11:37:08 <lambdabot>     Probable cause: `flip' is applied to too many arguments
11:37:17 <ozy`> :t uncurry . flip . splitAt
11:37:19 <lambdabot>     Couldn't match expected type `b -> c'
11:37:19 <lambdabot>            against inferred type `([a], [a])'
11:37:19 <lambdabot>     Probable cause: `splitAt' is applied to too many arguments
11:37:22 <ozy`> pffff
11:37:32 <lilac> > fst <$> iterate (splitAt 5 . snd) ([], [1..])
11:37:37 <lambdabot>   [[],[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24...
11:37:38 <Toxaris> what are you trying to do btw?
11:37:40 <Cheshire> :t uncyurry $ flip splitAt
11:37:41 <lambdabot> Not in scope: `uncyurry'
11:38:01 <ozy`> :t uncurry $ flip splitAt
11:38:02 <lambdabot> forall a. ([a], Int) -> ([a], [a])
11:38:47 <paper_cc> > let groups gs xs = snd $ mapAccumL (((snd &&& fst) .) . flip splitAt) xs gs in groups [2,6,4,3] [1..]
11:38:48 <lilac> > takeWhile (not.null) . tail $ fst <$> iterate (splitAt 5 . snd) ([], [1..20])
11:38:49 <lambdabot>   [[1,2],[3,4,5,6,7,8],[9,10,11,12],[13,14,15]]
11:38:50 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
11:39:00 <ozy`> > tail $ fst <$> iterate (splitAt 5 . snd) ([], [1..])
11:39:01 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25...
11:39:09 <ozy`> > tail $ fst <$> iterate (splitAt 2 . snd) ([], [1..])
11:39:10 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21...
11:39:32 <mauke> > tail $ fst <$> iterate (splitAt 3 . snd) ([], [1 .. 7])
11:39:34 <lambdabot>   [[1,2,3],[4,5,6],[7],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
11:39:50 <ozy`> @pl (\x y -> x:y:[])
11:39:50 <lambdabot> (. return) . (:)
11:39:53 <mauke> needs more unfoldr
11:40:20 <paper_cc> *confused* what Applicative is this <$> for? %(
11:40:28 <ozy`> > zipWith ((. return) . (:)) `ap` tail $ [1..]
11:40:30 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12...
11:41:05 <Twey> paper_cc: [a], clearly
11:41:48 <ozy`> @unpl (. return) . (:)
11:41:48 <lambdabot> (\ d g -> ((:)) d (return g))
11:42:15 <yrlnry> Hello, Haskelloides.
11:42:35 <paper_cc> Twey: it's clear if you're familliar with Applicative :/
11:42:37 <ozy`> soup
11:42:54 <paper_cc> @ty <$>
11:42:55 <Twey> paper_cc: I'm not
11:42:56 <lambdabot> parse error on input `<$>'
11:42:57 * mauke is tempted to say "hello, you ... HOMOID!"
11:43:01 <Toxaris> @src (<$>)
11:43:01 <lambdabot> f <$> a = fmap f a
11:43:06 <paper_cc> @ty (<$>)
11:43:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:43:14 <Twey> paper_cc: But I know that iterate returns a list
11:43:15 <Toxaris> paper_cc: no need to understand Applicative to understand (<$>)
11:43:19 <paper_cc> oops, this isn't even applicative =(
11:43:22 <Twey> Heh
11:43:40 <Twey> Unless it was partially applied *looks again*
11:43:51 <Twey> :t iterate
11:43:53 <lambdabot> forall a. (a -> a) -> a -> [a]
11:43:58 <Twey> No, I'm safe.
11:44:27 <Twey> There's also fmap on functions, of course, where fmap = (.)
11:44:28 * paper_cc suddenly understands that he found that `map` he was always declaring
11:44:38 <Twey> ... you declare map? :-P
11:44:41 <Toxaris> paper_cc: (<$>) = fmap, (<*>) = ap, but <*> works for potentially more types then ap, and that's it.
11:44:55 <paper_cc> Twey: I declared fixity =)
11:44:59 <Twey> We've an awful lot of maps.
11:45:01 <Twey> Ah :)
11:45:21 <Twey> (.) = map = fmap
11:45:23 <paper_cc> @src Functor (->)
11:45:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:45:30 <Twey>  = (<$>)
11:45:32 <Twey> It's all very confusing
11:45:36 <lilac> > (\xs ns -> (map.map) snd.groupBy ((==) `on` fst) $ zip (zip ns [1..] >>= uncurry replicate) xs) [1..10] [1,2,3]
11:45:37 <lambdabot>   [[1],[2,3],[4,5,6]]
11:45:44 <Twey> @src Functor ((->) e)
11:45:44 <lambdabot> Source not found. :(
11:45:49 <Twey> Boo
11:45:54 <mauke> @src (->) fmap
11:45:55 <lambdabot> fmap = (.)
11:46:01 <Twey> Oh
11:46:03 * Twey feels silly.
11:46:04 <paper_cc> @src Functor
11:46:04 <lambdabot> class  Functor f  where
11:46:04 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
11:46:14 <lilac> > (\xs ns->map snd<$>groupBy(on(==)fst)$zip(zip ns[1..] >>=uncurry replicate)xs) [1..10] [1,2,3]
11:46:15 <lambdabot>   Couldn't match expected type `(a, b)'
11:46:23 <Cheshire> Haskell ADTs are domain equations
11:46:40 * Nafai reads Oleg's OOHaskell paper and finds it fascinating
11:47:28 <lilac> is there a name for the sort of associativity that 'fmap' possesses?
11:47:40 <redditbot> Haskell prime proposal for improved numeric classes
11:47:53 <Twey> Eep, an Oleg-paper
11:48:12 <paper_cc> a Papeg?
11:48:15 <Cheshire> lilac, what is the equation?
11:48:26 * wli ponders FFI calls to Fortran.
11:48:37 <lament> transitivity?
11:48:43 <lament> no
11:48:56 <lilac> Cheshire: (f <$> g) <$> x = f <$> (g <$> x), but the <$>s are at different types
11:48:56 <Nafai> wli: Someone just wrote an FFI for Factor to Fortran
11:49:37 <lilac> Cheshire: (f <$>_-> g) <$>_F x = f <$>_F (g <$>_F x) where <$>_-> is for functions and <$>_F is for the functor
11:49:55 <hydrapheetz> :t <$>
11:49:56 <lambdabot> parse error on input `<$>'
11:49:59 <hydrapheetz> :(
11:50:16 <Cale> wli: From what I could tell, it works seamlessly with GNU's Fortran compiler.
11:50:31 <paper_cc> @users
11:50:31 <lambdabot> Maximum users seen in #haskell: 668, currently: 667 (99.9%), active: 37 (5.5%)
11:50:50 <paper_cc> :t (<$>)
11:50:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:50:55 <paper_cc> hydrapheets: ^^
11:51:02 <mauke> map (f . g) x = map f (map g x) , also known as (f . g) . x = f . (g . x)
11:51:08 <hydrapheetz> Oh.
11:51:25 <Cale> lilac: That's just the functoriality in disguise.
11:51:34 <Toxaris> lilac: I wouldn't call that associativity
11:51:45 <Cheshire> how do you get to grips with logical relations?
11:51:48 <Cale> fmap (f . g) = fmap f . fmap g
11:51:52 <Toxaris> lilac: the random fact that (.) is also fmap is not really important here
11:51:57 <lilac> Cale: obviously. but is there a name for this property?
11:52:10 <Cale> (one of) the functor laws.
11:52:11 <lilac> Toxaris: i disagree; categorically they're related
11:52:12 <lament> preservation of composition?
11:52:13 <Cheshire> lilac, it wasn't obvious
11:52:31 <lilac> Cheshire: it's obvious when you know it and have seen the proof ;-)
11:52:37 <Cheshire> i.e. I thought you presented it that way /because/ it's different
11:52:42 <Cale> So, fmap (f . g) x = fmap f (fmap g) x, and if we choose to use (.) as fmap, we can write that as (f . g) . x = f . (g . x)
11:52:47 <Cale> er
11:52:52 <Cale> fmap f (fmap g x) rather
11:53:00 <Cheshire> fmap (f . g) = fmap f . fmap g  is just distributivity isn't it?
11:53:11 <Cale> Well, sort of :)
11:53:30 <Toxaris> lilac: i would say "fmap is compatible with (.)"
11:53:38 <gbacon> Baughn: this program is a toy, but in principle I suppose it should be uniform as in fair to all
11:53:40 <Cale> fmap preserves composition
11:54:25 <gbacon> well, maybe not a toy..
11:54:42 <MyCatVerbs> > (fmap (isUpper) (toUpper)) 'a'
11:54:42 * wli would say that fmap distributes over composition.
11:54:43 <lambdabot>   True
11:54:55 <Baughn> gbacon: Can't have your cake and eat it too. ;)
11:55:00 <mauke> > fmap isUpper toUpper 'a'
11:55:02 <lambdabot>   True
11:55:20 <ozy`> :t fmap isUpper toUpper
11:55:21 <lambdabot> Char -> Bool
11:55:25 <ozy`> :t fmap isUpper
11:55:25 <lament> yeah, maybe 'distributive law' is not such a bad name for this property
11:55:26 <lambdabot> forall (f :: * -> *). (Functor f) => f Char -> f Bool
11:55:29 <mauke> > return True 'a'
11:55:30 <lambdabot>   True
11:55:49 <ozy`> mauke: ahhhh I see
11:55:54 <lilac> Toxaris: the same property is exhibited by (*) for any two rings, i think
11:56:13 <Toxaris> lilac: the same property is exhibited by any morphism between two structures
11:56:16 <gbacon> Baughn: but for large n, doesn't exponential approximate uniform?
11:56:31 <Toxaris> lilac: because it is the conventional definition of morphism between structures
11:56:41 <ozy`> :t (`fmap` toUpper)
11:56:42 <lambdabot> forall b. (Char -> b) -> Char -> b
11:56:56 <lilac> Toxaris: it's a special form of commutative diagram, where all the arrows are in some sense related
11:57:33 <Baughn> gbacon: Well, you don't know in advance what n is, so the size of n can't affect it. :P
11:58:21 <Baughn> gbacon: And no. The probability distribution function of the exponential distribution is, well, exponential; the uniform distribution, flat. This won't change.
11:58:50 <Baughn> gbacon: Though I suppose it'll be closer for large n once you /get/ far into the list, but chances are you'll already have picked your element long before then
11:59:42 <lilac> with the distribution where p_i = 2^(-i), the distribution looks the same no matter where you are
12:03:18 <wli> lilac: Aren't Zipf distributions more common? e.g. p_i = (fromInteger i + a)^^(-k)/zeta a k ?
12:03:34 <lilac> wli: you have a distribution over distributions? ;-)
12:04:55 <wli> lilac: You could say that. :)
12:07:55 <lilac> wli: i /could/ say that? with what probability? do you have a distribution over distributions over distributions too?
12:08:05 * lilac waits for the YO DAWG :)
12:08:20 <wli> lilac: YO DAWG :)
12:08:54 <lament> sounds bayesian
12:09:00 <dcoutts_> @seen augustss
12:09:00 <lambdabot> augustss is in #haskell. I last heard augustss speak 5h 33m 59s ago.
12:14:37 <maltem> Bah. I hacked together a script that draws me a module dependency graph of Haskell source files, via graphviz. The generated graphs are correct, but overly futile.
12:16:41 <maltem> Looks like module dependencies isn't something you want to visualize as a drawn graph.
12:19:03 <augustss> dcoutts_: a gtk2hs question
12:19:03 <yrlnry> maybe you could draw the complement of the graph instead.  :)
12:19:26 <maltem> yrlnry: Heh. Or maybe I should eliminate arrows by analyzing transitivities.
12:21:44 <yrlnry> maltem: that sounds like a really interesting problem in general.
12:22:05 <yrlnry> Find a minimal relation R such that the transitive closure of R is equal to some given relation T.
12:22:10 <maltem> Or "group" modules that all import, say, Control.Monad.
12:23:05 <maltem> yrlnry: Yeah, maybe it would be even nice to have a collection of such algorithms in a library.
12:23:42 <Hiato> Sorry to disturb again, but I don't suppose someone could tell me why this works. I wasn't finished with the function but it seems that I don't need the layer of recursion (in my head, I had to map out the local max's, reverse it, add a zero to the end and repeat until I got two values, then one would be zero - however, this *seems* to work just fine, and it moans about ambiguous references if a add another max call) max x = if head x == 0 then t
12:23:57 <McManiaC> anyone using eclipse functional programming plugin for haskell?
12:24:05 <dsrogers> seen mmorrow
12:24:32 <McManiaC> "An error occurred during provisioning. Cannot connect to keystore. JKS"
12:24:56 <dsrogers> McManiaC: why are you tryingto use SSL?
12:25:08 * lament suspects the plugin is bitrotten
12:25:27 <McManiaC> im not? dsrogers
12:25:57 * McManiaC is just hitting the "next" button
12:25:57 <McManiaC> ;)
12:27:03 <maltem> yrlnry: Just in case... is there an obvious approach to finding that R?
12:27:25 <dsrogers> McManiaC: keystore is for accessing private keys, usually used by java for SSL transactions.
12:29:35 <paper_cc> Hiato: seems like you were truncated
12:29:46 <McManiaC> dsrogers: is there a way to get around that?
12:30:29 <dsrogers> McManiaC: I have no idea.  That's the only clue I have.  sorry :-(
12:30:42 <McManiaC> =)
12:30:45 <McManiaC> okay thx anyway
12:32:33 <Hiato> paper_cc: yes, indeed
12:33:01 <Hiato> basically, why does this work? max x = if head x == 0 then tail x else map head (groupBy (\x y -> x>y) (0:(reverse x))) [wrote it myself, but to me it seems to be missing bits that could make it work]
12:33:29 <paper_cc> @let hiatoMax x = if head x == 0 then tail x else map head (groupBy (\x y -> x>y) (0:(reverse x)))
12:33:32 <lambdabot>  Defined.
12:33:41 <paper_cc> > hiatoMax [-1,-2,-3]]
12:33:43 <lambdabot>   <no location info>: parse error on input `]'
12:33:46 <paper_cc> > hiatoMax [-1,-2,-3]
12:33:48 <lambdabot>   [0]
12:33:53 <paper_cc> Hiato: ^^
12:33:54 <Hiato> (only tested with >0)
12:34:05 <Hiato> hiatoMax [101,1,4,2,45,6,3,7,102,97]
12:34:09 <yrlnry> maltem: When I said it sounded interesting, I meant I couldn't think offhand of a solution.  My first idea would be just to look for triples A->b, b_.C, a->C and then eliminate A->C, and repeat until there were none left.
12:34:17 <Hiato> > hiatoMax [101,1,4,2,45,6,3,7,102,97]
12:34:18 <lambdabot>   [0,97,102]
12:34:24 <sm> a cabal question. I have two versions of utf8-string installed, and a bunch of packages depending on each. Now I can't build one because "package indirectly depends on multiple versions". What's best to do ? Do I have to cabal reinstall one of the depender sets ?
12:34:34 <Hiato> bleh, wth, that's what I would expect, but winhugs is going mad
12:34:45 <Hiato> well, either way, thanks paper_cc
12:34:57 <Hiato> Main> maximum [101,1,4,2,45,6,3,7,102,97]
12:34:57 <Hiato> 102
12:35:09 <paper_cc> Hiato: what did you want to do?
12:35:16 <lstor> Does anyone have a recommendation of a good, basic text about Monads?
12:35:19 <Hiato> find the maximum of a list
12:35:28 <paper_cc> @where ychim
12:35:28 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
12:35:29 <yrlnry> lstor: a whole text, or a short article?
12:35:33 <paper_cc> lstor: ^^
12:35:56 <lstor> yrlnry: Both, I guess :)
12:35:57 <yrlnry> lstor: I preferred this one: http://blog.sigfpe.com/2007/04/trivial-monad.html
12:36:00 <yrlnry> Note same author.
12:36:01 <Hiato> but it needs to be recursive, however, winhugs complains about ambiguous references if I make it recursive...
12:36:06 <lstor> paper_cc: Noted, taking a look
12:36:11 <lstor> yrlnry: Thank you :)
12:36:21 <yrlnry> Sure.
12:36:35 <lstor> And yes, I've been reading some on his blog, so this is gonna be good, I guess :)
12:36:35 <maltem> yrlnry: I feared that would be your only answer :)
12:36:40 <McManiaC> wtf
12:36:48 <yrlnry> maltem: well, I haven;'t thought about it at all.
12:36:50 <paper_cc> Hiato: map head $ something here... is surely going to return a list while you want a single element
12:37:21 <mauke> Hiato: 'max' and 'maximum' are existing functions
12:37:32 <mauke> Hiato: are you sure you're actually calling the code you wrote?
12:37:45 <paper_cc> Hiato: you get something like "maximums of all strictly descending sequences in a list"
12:38:36 <paper_cc> s/maximums/maxima
12:38:37 <Hiato> mauke: haha, yeah, it's probably calling the built-in! that;s why! thanks. paper_cc: yeah, that's what I intended to do, recursively
12:38:52 <paper_cc> @ty max
12:38:53 <lambdabot> forall a. (Ord a) => a -> a -> a
12:39:22 <paper_cc> Hiato: do it, then do it again, etc? *not sure if it will terminate
12:39:54 <dcoutts> sm: you'll need to rebuild some packages, cabal install should be able to do that.
12:39:59 <wli> foldr ((Just .) . ap maybe max) Nothing
12:40:04 <Hiato> should do, because eventually it will reduce to [0,X] and then it gets picked up
12:40:07 <Hiato> but lets see
12:40:13 <paper_cc> Hiato: try it on [1,1,1]
12:40:36 <paper_cc> @ty maximum
12:40:38 <lambdabot> forall a. (Ord a) => [a] -> a
12:40:41 <Hiato> heh, very good point paper_cc
12:40:51 <sm> dcoutts: thank you.. indeed I found that hiding the old version and cabal install --reinstall the depender took care of it (I think without breaking other stuff)
12:40:51 <paper_cc> @src Ord
12:40:52 <lambdabot> class  (Eq a) => Ord a  where
12:40:52 <lambdabot>     compare      :: a -> a -> Ordering
12:40:52 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:40:52 <lambdabot>     max, min         :: a -> a -> a
12:40:58 <Hiato> hrmm... I'll have to rethink my strategy
12:41:21 <paper_cc> > maximum []
12:41:22 <lambdabot>   * Exception: Prelude.maximum: empty list
12:41:27 <paper_cc> oh
12:42:01 <wli> let safeMaximum = foldr ((Just .) . ap maybe max) Nothing in (safeMaximum [5,1,4,2,3], safeMaximum [])
12:42:05 <paper_cc> @ty liftM2 max
12:42:07 <lambdabot> forall a1 (m :: * -> *). (Monad m, Ord a1) => m a1 -> m a1 -> m a1
12:42:12 <wli> > let safeMaximum = foldr ((Just .) . ap maybe max) Nothing in (safeMaximum [5,1,4,2,3], safeMaximum [])
12:42:13 <lambdabot>   (Just 5,Nothing)
12:42:18 <paper_cc> > (liftM2 max) 1 2
12:42:20 <lambdabot>       No instance for (Num (m a1))
12:42:20 <lambdabot>        arising from the literal `1' at <in...
12:42:35 <paper_cc> > (liftM2 max) (Just 1) (Just 2)
12:42:37 <lambdabot>   Just 2
12:42:45 <paper_cc> (liftM2 max) (Just 1) (Nothing)
12:42:55 <paper_cc> > (liftM2 max) (Just 1) Nothing
12:42:56 <lambdabot>   Nothing
12:43:13 <wli> Yeah, that's not quite the desired behavior.
12:43:25 * paper_cc wants max to have mplus behaviour
12:43:40 <paper_cc> @ty maybe
12:43:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:43:42 <mauke> > max (Just 1) (Just 2)
12:43:43 <lambdabot>   Just 2
12:43:47 <mauke> > max (Just 1) Nothing
12:43:48 <lambdabot>   Just 1
12:43:57 <paper_cc> @src (>) Maybe
12:43:58 <lambdabot> Source not found. You untyped fool!
12:44:31 <paper_cc> @src Maybe (>)
12:44:32 <lambdabot> Source not found. There are some things that I just don't know.
12:45:05 <idnar> since when does Maybe have an Ord instance?
12:45:28 <Hiato> assuming nice input: mx x = if head x == 0 then head (tail x) else mx (0:(reverse (map head (groupBy (\x y -> x>y) (0:reverse x)))))
12:45:37 <paper_cc> @ty foldl' max Nothing . map Just
12:45:38 <lambdabot> forall a. (Ord a) => [a] -> Maybe a
12:45:47 <idnar> > Nothing > Nothing
12:45:49 <lambdabot>   False
12:45:50 <idnar> > Nothing == Nothing
12:45:51 <lambdabot>   True
12:45:53 <idnar> > Nothing < Nothing
12:45:54 <lambdabot>   False
12:45:58 <paper_cc> @ty foldl1 max
12:46:00 <lambdabot> forall a. (Ord a) => [a] -> a
12:46:07 <maltem> > min (Just 1) Nothing
12:46:09 <lambdabot>   Nothing
12:46:31 <paper_cc> @check Just x > Nothing
12:46:32 <lambdabot>   "OK, passed 500 tests."
12:47:44 <paper_cc> > foldl1 max []
12:47:46 <lambdabot>   * Exception: Prelude.foldl1: empty list
12:48:06 <mauke> @src maximum
12:48:06 <lambdabot> maximum [] = undefined
12:48:06 <lambdabot> maximum xs = foldl1 max xs
12:49:05 <yrlnry> @src foldl1
12:49:05 <lambdabot> foldl1 f (x:xs) = foldl f x xs
12:49:05 <lambdabot> foldl1 _ []     = undefined
12:49:10 <yrlnry> okay.
12:49:29 <yrlnry> Why have a separate case for maximum [] ?
12:49:57 <yrlnry> foldl1 max [] is undefined anyway.
12:50:10 <maltem> In reality it's error "maximum: empty list" -- or something
12:50:17 <yrlnry> Ah.
12:50:30 <yrlnry> > maximum []
12:50:32 <lambdabot>   * Exception: Prelude.maximum: empty list
12:50:54 <mauke> lambdabot's @src is fake anyway
12:51:00 <yrlnry> Okay.
12:52:26 <roconnor> @src sum
12:52:26 <lambdabot> sum = foldl (+) 0
12:52:42 <roconnor> @src sort
12:52:42 <lambdabot> sort = sortBy compare
12:52:47 <roconnor> @src sortBy
12:52:47 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:53:31 <roconnor> > foldr (insertBy compare) [] [1,2,3,undefined]
12:53:31 <Olathe> maximum [] = errorEmptyList "maximum"
12:53:32 <lambdabot>   * Exception: Prelude.undefined
12:53:46 <paper_cc> @ty errorEmptyList
12:53:48 <lambdabot> Not in scope: `errorEmptyList'
12:53:56 <Olathe> It's an internal function.
12:54:23 <Olathe> errorEmptyList :: String -> a
12:54:23 <Olathe> errorEmptyList fun =
12:54:23 <Olathe> error ("Prelude." ++ fun ++ ": empty list")
12:54:45 <roconnor> ooh I got my frist link exchange proposal spam.  My site must be getting popular
12:55:59 <yrlnry> How 1995.
12:56:31 <McManiaC> i asked earlier but i still dont know how to do this... i have a function which should only return a list of 0 and 1 (ints)
12:56:56 <McManiaC> i tried to set up a typeclass but that wont do it
12:57:02 <McManiaC> does anyone have an idea?
12:57:06 <Olathe> > let f = [0, 1, 0] in f
12:57:07 <lambdabot>   [0,1,0]
12:57:08 <mauke> what's the problem?
12:57:17 <sw17ch> is Hieroglyph broken for any one else when building with 6.10?
12:57:20 <sw17ch> i get Gtk errors
12:57:23 <sw17ch> Not in scope
12:57:47 <McManiaC> i want "the user" to insert only 1 and 0 too
12:57:52 <McManiaC> so no other ints but 1 and 0
12:58:01 <mauke> ok, so check for that
12:58:55 <sw17ch> data OneOrZero = OOZZero | OOZOne
12:59:01 <roconnor> sw17ch: I do
12:59:06 <Olathe> Eeeewww
12:59:07 <roconnor> I think
12:59:09 <sw17ch> :D
12:59:15 <sw17ch> roconnor: yeah, i'm not sure what's u
12:59:16 <sw17ch> p
12:59:28 <Olathe> data Bool = False | True
12:59:37 <roconnor> sw17ch: I filed a bug report with gtk, but they ignored it and released anyways
12:59:41 <mauke> data Zero; data One
12:59:57 <roconnor> sw17ch: grantend they might be deliberately breaking backwards compatability
12:59:58 <sw17ch> roconnor: is it a gtk problem?
13:00:02 <mauke> class ZeroOne a; instance ZeroOne Zero; instance ZeroOne One
13:00:20 <Olathe> Oh dear.
13:00:27 <roconnor> sw17ch: I'm not a gtk expert.  GTK doesn't export the same modules it did before
13:00:34 <sw17ch> hmm...
13:00:38 <McManiaC> hmm
13:00:39 <mauke> data OhGodWtf = forall a. (ZeroOne a) => Zomg a
13:00:45 <Olathe> The letter e occurs in both Zero and One, so we need to exploit that.
13:00:45 <roconnor> sw17ch: I sort of expect half of the GTK code to break with 6.10
13:00:48 <mauke> foo :: [OhGodWtf]
13:00:48 <sw17ch> so, doesn't that mean that Hieroglyph is at fault then?
13:01:06 <Olathe> The letter o, too.
13:01:07 <sw17ch> lol
13:01:09 <lstor> yrlnry, paper_cc: I've started on 'ychim' and looked a bit at trivial-monad too, and they seem to be exactly what I was looking for. Thanks!
13:01:10 <roconnor> sw17ch: well, perhaps Hieroglysh should have specified gtk2hs 6.8.*
13:01:15 <roconnor> glyph
13:01:22 <sw17ch> yeah, ti's not too specific
13:01:29 <sw17ch> base* cairo* containers* gtk*
13:01:31 <sw17ch> etc..
13:01:41 <roconnor> sw17ch: standard version policy says 6.10 can change the interface arbitrarily
13:02:01 <sw17ch> orly?
13:02:06 <sw17ch> i see
13:02:30 <roconnor> orly: presumably gtk2hs uses the standard versioning policy, since some of the same people are involved with the development of both
13:02:35 <sw17ch> yeah, it appears as though Gtk.Event and others have vanished from Graphics.UI.Gtk.Cairo
13:02:37 <roconnor> but I'm not sure
13:02:42 <roconnor> sw17ch: exactly
13:02:51 <dcoutts> roconnor: I'm not sure it's really following the PVP
13:03:03 <roconnor> well i thought it was vanished from Graphics.UI.Gtk
13:03:23 <roconnor> sw17ch: dcoutts would know more about the versioning policy than me
13:03:34 <sw17ch> dcoutts: know why Heiroglyph breaks? :D
13:04:56 <roconnor> sw17ch: the "right" thing to do is to patch and upload a new heiroglyph that  has the right versioning dependencies
13:05:11 <roconnor> then patch it to work with 8.10 and upload that to hackage too
13:05:20 <sw17ch> mmm
13:05:21 <roconnor> then maybe tell the author
13:05:32 <sw17ch> i'd assume we should tell the author first )
13:05:33 <sw17ch> :)
13:05:47 <roconnor> some people tell the author in a different order than I do :P
13:05:55 <dcoutts> sw17ch: if you can figure out what is going on with Gtk.Gdk.Event then pleas let me know. Looking at the code it's exported, yet people tell me it is not.
13:06:17 <sw17ch> dcoutts: i did a cabal install Hieroglyph and stuff blew up
13:06:37 <dcoutts> sw17ch: thanks for the bug report :-)
13:06:54 <sw17ch> is it Gtk.Gdk.Event?
13:07:12 <sw17ch> he's using import qualified Graphics.UI.Gtk as Gtk
13:07:15 <sw17ch> and then using Gtk.Event
13:07:44 <dcoutts> sw17ch: oh well that works too. The fully qualified name is Graphics.UI.Gtk.Gdk.Event.Event
13:08:29 <sw17ch> dcoutts: can you get a type signature by loading Graphics.UI.Gtk in ghci?
13:08:32 <sw17ch> for Event
13:08:35 <sw17ch> i can't
13:08:39 <sw17ch> the symbol doesn't appear to be defined
13:09:22 <roconnor> sw17ch: that's exactly what I remember
13:09:58 <sw17ch> actually, i can't find the module Graphics.UI.Gtk.Gdk.Event or Graphics.UI.Gtk.Gdk
13:10:03 <sw17ch> module(s)
13:10:05 <sw17ch> dcoutts: ^^
13:10:18 <sw17ch> they don't appear to be exported :\
13:10:20 <dcoutts> sw17ch: it's Graphics.UI.Gtk.Gdk.Events, with an 's' ,sorry I spelled it wrong before
13:10:33 <dcoutts> that's the module name, which exports Event type and constructors
13:10:38 <dcoutts> and yes I get the same in ghci
13:10:38 <sw17ch> hey, that fixes it
13:10:49 <dcoutts> but I cannot explain it from looking at the code
13:10:52 <sw17ch> i added this to the heiroglyph imort list
13:10:53 <sw17ch> import qualified Graphics.UI.Gtk.Gdk.Events as Gtk
13:10:55 <sw17ch> and it works
13:11:04 <dcoutts> looking at the code it's quite clearly exported and re-exported
13:11:14 <sw17ch> hmmm
13:11:42 <dcoutts> it does:
13:11:43 <dcoutts> import Graphics.UI.Gtk.Gdk.Events               hiding (marshExposeRect,
13:11:43 <dcoutts>                                                         marshalEvent)
13:11:53 <jutaro> gtk2hs has changed from Event to EventM as standard. So 'old' code needs to import old event module explicitely
13:11:56 <roconnor> dcoutts: in 8.10?
13:12:12 <sw17ch> dcoutts: it's not in the 0.10.0 docs either
13:12:20 <sw17ch> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/Graphics-UI-Gtk.html
13:12:26 <sw17ch> Gdk.Events doesn't show up
13:12:42 <roconnor> er
13:12:43 <dcoutts> ah, it's missing the module export. I swear it was there before
13:12:50 <sw17ch> :)
13:12:56 <roconnor> right
13:13:59 <roconnor> http://hackage.haskell.org/trac/gtk2hs/ticket/1152
13:14:08 * wli wonders if there are quad-precision or higher floating point type implementations floating around.
13:14:18 <roconnor> > pi :: CReal
13:14:19 <lambdabot>   3.1415926535897932384626433832795028841972
13:14:24 <roconnor> or higher :)
13:14:37 <sw17ch> > pi :: Rational
13:14:39 <lambdabot>       No instance for (Floating Rational)
13:14:39 <lambdabot>        arising from a use of `pi' a...
13:14:42 <wli> Well, I didn't have arbitrary precision in mind, but...
13:14:43 <sw17ch> darn
13:15:10 <jutaro> dcoutts: gtk2hs event export was removed by decision to make us use new EventM style.
13:15:16 <wli> What's the name of that module again? I've almost certainly already installed it.
13:15:30 <roconnor> jutaro: ah so you can close my bug report?
13:15:33 <sw17ch> jutaro: can that note be put in the docs somewhere?
13:15:40 <dcoutts> jutaro: aye, what confused me was that EventM was not exported either
13:15:44 <sw17ch> oh hey
13:16:02 <jutaro> it is in the top notes: replaced Event for EventM monad, thereby improving efficiency and convenience
13:16:18 * sw17ch decides to learn to read
13:16:54 <roconnor> sw17ch: so there we have it. Heiroglyph is broken
13:17:01 <sw17ch> oh noez :(
13:17:06 <jutaro> dcoutts: I've not switched my code to new events, so I don't know if they are exported correct. But this is on my list.
13:17:35 <wli> lambdabot can't hoogle CReal
13:17:59 * sw17ch wonders if any one knows how to contact on J.R. Heard
13:18:02 <sw17ch> one*
13:18:08 <roconnor> wli: you can hayoo CReall
13:18:11 <roconnor> CReal
13:18:33 <roconnor> sw17ch: I'll send you his email
13:18:39 <sw17ch> merci beaucoup
13:19:44 <roconnor> his address is so hard to find.  that's why I suggest uploading to hackage first.  It's always easier :P
13:20:51 <wli> cabal: There is no package named creal
13:21:10 * sw17ch is scared of clobbering others packages
13:21:19 * sw17ch considers it ... not nice?
13:21:19 <sw17ch> :)
13:21:58 <roconnor> wli: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:CReal
13:24:03 <wli> roconnor: No functions for showing the things in scientific notation?
13:24:08 <roconnor> sw17ch: Ya I don't know what the etiquette is here
13:25:11 <roconnor> wli: you could convert it to double
13:25:22 <wli> roconnor: There's no obvious conversion function.
13:25:22 <roconnor> wli:  but ya, it could use some more functions
13:25:35 <roconnor> wli: there are the unobvious ones
13:26:09 <roconnor> > realToFrac (pi::CReal)
13:26:10 <lambdabot>   * Exception: CReal.toRational
13:26:15 <roconnor> oh crap
13:26:18 <roconnor> that doesn't work
13:26:39 <roconnor> wli: sorry.  You'll have to patch the source
13:27:11 <roconnor> wli: technically you could use showCReal, but ...
13:28:35 <wli> roconnor: showGFloat barfs.
13:28:54 <roconnor> right
13:28:59 <wli> That is, despite the RealFloat instance.
13:29:03 <roconnor> right
13:29:19 * roconnor thinks the RealFloat instance is a big mistake
13:29:30 <roconnor> wli: you could try my CReal package
13:29:49 <roconnor> wli: it isn't as fast, but at least it has an approximation function
13:29:56 <roconnor> that is exported
13:30:20 <wli> I have Data.Number.CReal from somewhere.
13:31:03 <roconnor> my CReals is a totally different implemenation
13:31:19 <roconnor> http://r6.ca/FewDigits/
13:35:29 <wli> Data/Interval.hs:65:1: coarbitrary is not a (visible) method of class Arbitrary
13:36:38 <byorgey> wli: coarbitrary got moved to its own type class in QuickCheck 2.x
13:38:34 <roconnor> :(
13:38:46 <roconnor> dependency hell
13:39:05 <roconnor> wli: I guess you can just comment out the whole instance
13:39:47 <dolio> CPP to the rescue!
13:41:01 <roconnor> oh
13:43:00 <paper_cc> is there a Berkeley DB binding with a Haskellish interface and without unsafePerformIO?
13:44:58 <tromp> > 9.13*1.12
13:44:59 <lambdabot>   10.225600000000002
13:47:18 <roconnor> @wiki IO_Semantics
13:47:18 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
13:55:33 <Cheshire> what is inductive products (as a datatype), opposed to just products?
13:56:33 <dolio> Cheshire: I'd expect it to be some kind of family of tuples like Haskell has, only inductively defined.
14:15:31 * pumpkin does a little dance
14:18:01 <pumpkin> dons: is there anything I can do to make evaluating those monster patches I sent you easier?
14:23:43 <dmead> ?seen dons
14:23:43 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1m 12s ago.
14:23:51 <dmead> dons: poke
14:37:29 <beelsebob> awww... #haskell just got ovetraken by ##1234567890 – we're only 9th biggest now
14:38:22 <cypher-> hehe
14:38:34 <cjb> how many people are in that?
14:38:50 <byorgey> about 666, apparently =)
14:38:59 <byorgey> but more people keep joining
14:39:08 <asgaroth> @users
14:39:08 <lambdabot> Maximum users seen in #haskell: 671, currently: 643 (95.8%), active: 21 (3.3%)
14:40:21 <pumpkin> spam that channel
14:40:29 <pumpkin> let's get over 9000!! people in here
14:40:41 <ddarius> 9000 double factorial !!
14:41:03 <fintanstele> i just got out of my comfy lurking spot to say: please don't do that
14:41:13 <Spark> where is the list of biggest channels
14:41:21 <Spark> i imagine #ubuntu is near the top
14:41:28 * fintanstele goes back to his cave
14:41:35 <Spark> and ##c ##c++ ##java can't be far off either
14:41:43 <tromp> > product [1..9000] :: Int
14:41:44 <lambdabot>   0
14:42:23 <asgaroth> > product [1..product [1..9000]]
14:42:38 <lambdabot>   thread killed
14:43:12 <tromp> > product [1..32] :: Int
14:43:48 <lambdabot>   -6045878379276664832
14:43:57 <tromp> > product [1..56] :: Int
14:43:59 <lambdabot>   6908521828386340864
14:44:17 <tromp> > product [1..59] :: Int
14:44:19 <lambdabot>   162129586585337856
14:44:31 <comex> > product [1..] :: Int
14:44:38 <tromp> > product [1..111] :: Int
14:44:40 <lambdabot>   0
14:45:00 <tromp> > product [1..96] :: Int
14:45:48 <fintanstele> what is this? brute force bug hunting?
14:46:11 <dolio> > product . enumFromTo 1 . product . enumFromTo 1 $ 9000
14:46:32 <tromp> > product [1..66] :: Int
14:46:56 <lambdabot>   mueval: Prelude.read: no parse
14:47:03 <lambdabot>   0
14:47:03 <lambdabot>   0
14:47:11 <lambdabot>   thread killed
14:47:22 <Cheshire> > scanl1 (*) [1..]
14:47:39 <tromp> > product [1..64] :: Int
14:47:48 <lambdabot>   -9223372036854775808
14:48:11 <altmattr> hi folks, what is the current consensus of opinion regarding tabs vs spaces?
14:48:32 <wli> There is no consensus.
14:48:34 <tromp> dont use tabs in src code
14:48:53 <wli> The majority opinion is probably in favor of spaces. I favor tabs.
14:49:06 <sjanssen> I had lambdabot join ##1234567890, and now she seems to have left freenode
14:49:13 <sjanssen> I wonder if that is just too much load for her?
14:49:23 <altmattr> gotcha - thanks
14:49:48 <altmattr> such a shame really - leaves tabs with no reason to exist
14:50:26 <Olathe> Tabs are the work of SATAN !
14:51:25 <dolio> Tab is the key you use to do autocomplete. :)
14:51:44 <sereven> or configurably enter multiple spaces
14:51:51 <dolio> Yes.
14:52:39 <altmattr> if only - my damn editor maps that to esc and I can't map it to tab no matter how hard I try
14:53:02 <altmattr> that = autocomplete
14:53:13 <dolio> What editor? That's pretty out of the way.
14:53:19 <altmattr> textmate
14:53:23 <dolio> Unless you remap capslock to escape like I did when I used vim.
14:53:39 <altmattr> it is the one thing that keeps me from jumping into textmate fully
14:53:45 <cytzol> sjanssen: I may or may not have done too much @yowing. I apologise.
14:54:03 <pumpkin> @bot
14:54:03 <lunabot>  :)
14:54:04 <lambdabot> :)
14:54:07 <altmattr> it is so hardwired into my brain that autocomplete = tab (or . <wait> from my old OO days)
14:54:13 <dolio> It may also have been people computing gigantic factorials.
14:54:30 <sjanssen> ah, probably
14:54:51 <sereven> @vixen are you mad at Cheshire for scanl1 (*) [1..]?
14:54:52 <lambdabot> i truely am
14:55:02 <pumpkin> truely? :P
14:56:19 <Aviator> XD lambdabot is in ##1234567890 too?
14:56:57 <Gracenotes> @. vixen keal
14:56:57 <lambdabot> church is my favourite computer scientist.
14:56:59 <Gracenotes> .-.
14:57:02 <cytzol> Whose idea was that
14:57:55 <sjanssen> Aviator, cytzol: it was me
14:58:22 <Aviator> XD lol this is awesome
14:58:54 <Aviator> and that channel is overcrowding like a 4chan thread
15:00:03 <Alp`Engaged`> good night, all
15:01:34 <koeien> Aviator: LOL
15:03:21 <inimino> yowza
15:07:43 <wli> roconnor: CReal is preposterously slow. :(
15:09:30 <Cale> wli: I had similar problems with it. It's great if you're computing something whose description in terms of the basic transcendental functions is really simple, but even fairly small summations or products seem to take forever.
15:09:57 <wli> Cale: Are there other, faster arbitrary-precision floating point modules out there?
15:10:04 <Cale> I don't know.
15:10:20 <Cale> I wonder how one might design a truly practical computable reals package, one whose performance approached that of floating point numbers if that's all the precision one needed.
15:10:23 * wli resurrects arbfloat.
15:10:37 <Cale> (but which was still correct)
15:10:51 <Cale> It's really nice to be able to rely on the field axioms.
15:11:49 <wli> (Basically nothing but data ArbFloat = ArbFloat { AFexp :: Integer, AFdigits :: [Word32] })
15:11:55 <wli> ergh
15:12:14 <Cale> That's similar to rationals then?
15:12:17 <wli> it must be data ArbFloat = ArbFloat { expAF :: Integer, digitsAF :: [Word32] }
15:13:34 <Cale> oh, or is the expectation that the list be infinite?
15:13:45 <wli> Cale: It's basically just 2**(32*expAF f) * sum [2**(32*k)*(digitsAF f ! k) | k <- [0..]]
15:14:15 <wli> Cale: The expectation is that the list may be infinite, yes.
15:14:17 <wli> ergh
15:14:29 <wli> 2**(32*expAF f) * sum [2**(-32*k)*(digitsAF f ! k) | k <- [0..]]
15:14:33 <Cale> ah, then you want a negative exponent, yeah
15:15:00 <wli> Cale: Unless I'm doing p-adic numbers and then I'd want something very different wrt. radix. ;)
15:15:05 <Cale> :)
15:17:01 <wli> I have data ArbFloat = ArbFloat { exponentAF :: Integer, mantissaAF :: (Word32, [Word32]), signAF :: Bool } | AFNaN | AFInfinity Bool
15:17:27 <wli> I may need help with division.
15:29:49 <roconnor> > 48 *1024
15:29:50 <lambdabot>   49152
15:30:14 <Elly> nearly special time :)
15:30:43 <FunctorSalad_> ?
15:30:56 <byorgey> FunctorSalad_: 1234567890 seconds since the Epoch
15:30:56 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:31:05 <byorgey> in about 30 seconds
15:31:18 <Olathe> O-o
15:31:25 <Olathe> zomg
15:31:40 <lstor> According to my system time
15:31:43 <lstor> It is..
15:31:44 <lstor> NOW
15:31:58 <sjanssen> @users ##1234567890
15:31:59 <lambdabot> Maximum users seen in ##1234567890: 1270, currently: 1266 (99.7%), active: 501 (39.6%)
15:33:28 <X-Scale> has someone said in ##c....  Happy New Epoch!! :)
15:38:45 <cknapp> It's not really a new epoch, though...
15:38:52 <BrokenClockwork> hey, 1.0 / 200 gives me 5.0e-3 how can I change display result to 0.005 ?
15:38:57 <BrokenClockwork> > 1.0 / 200
15:38:58 <lambdabot>   5.0e-3
15:39:26 <wli> Cale: Hmm. That may have cancellation issues.
15:40:09 <brad_larsen> can someone explain to me why the Functor instance for pairs makes sense?
15:40:25 <brad_larsen> > (+5) `fmap` (0,0)
15:40:27 <lambdabot>   (0,5)
15:40:42 <Cheshire> brad_larsen, it's the (a,-) functor
15:41:04 <Cheshire> bard_larsen, in theory I guess there could be a (-,a) functor but you can't implement it in haskell
15:41:07 <brad_larsen> ah.
15:41:18 <brad_larsen> not H98?
15:42:23 <hackage> Uploaded to hackage: haskelldb-hdbc-sqlite3 0.12
15:42:23 <hackage> Uploaded to hackage: haskelldb-hdbc-postgresql 0.12
15:42:23 <hackage> Uploaded to hackage: haskelldb-hdbc-odbc 0.12
15:42:23 <hackage> Uploaded to hackage: haskelldb-hdbc 0.12
15:42:23 <hackage> Uploaded to hackage: haskelldb 0.12
15:43:31 <Olathe> Only 35.20898328770249 years until 2345678901 !
15:43:47 <Raevel> sweet
15:43:54 <Raevel> at least i'll probably be alive then
15:44:12 <koeien> brad_larsen: the problem is that you can only parametrise on the last type argument(s)
15:44:12 <Aviator> haskelldb updated? woohoo!
15:44:37 <brad_larsen> i guess what i was asking doesn't make much sense.
15:45:09 <koeien> bree.g. you can define a functor instance for (Either a) b
15:45:46 <brad_larsen> koeien, yes, i've run into that before.  hence State monad is State s a
15:45:48 <mreh> myGetLine :: String -> IO String
15:45:49 <mreh> myGetLine = do c <- getChar
15:45:50 <mreh>                if c == '\n' then return "" else return (c : myGetLine)
15:45:59 <mreh> any idea why this gives me a type error?
15:46:01 <brad_larsen> instead of State a s
15:46:05 <koeien> brad_larsen: yes. the other way around is not possible
15:46:06 <Olathe> And 1973 was 0123456789
15:46:29 <brad_larsen> mreh:  the recursive call to myGetLine
15:46:35 <koeien> mreh:this does not make sense. myGetLine should be of type :: IO String instead
15:46:52 <mreh> doy!
15:47:44 <koeien> mreh: also, the recursive call is not done correctly. it should be do { rest <- myGetLine ; return (c:rest) } instead
15:48:03 <koeien> (or, (c:) `liftM` myGetLine)
15:48:16 <mreh> dont know what that is
15:48:40 <koeien> first try to understand the first line, and try to figure out what's wrong with your solution :)
15:49:05 <mreh> i roughly know why
15:49:18 <mreh> the type of myGetLine is IO String and it wants a String
15:49:24 <mreh> I dont really understand the mechanics of why
15:49:27 <koeien> okay. (c:myGetLine) is a type error
15:49:37 <mreh> yeah, i've fixed it now
15:49:43 <mreh> myGetLine :: IO String
15:49:43 <mreh> myGetLine = do c <- getChar
15:49:43 <mreh>                if c == '\n' then return "" else do l <- myGetLine
15:49:43 <mreh>                                                    return (c : l)
15:49:51 <koeien> mreh: "IO String" is an action that, when performed, returns a string
15:50:01 <mreh> that's what confused me
15:50:06 <koeien> so you have to perform the action, fetch the result, and put it in
15:50:20 <koeien> otherwise you just put an action in a list (you can do that by the way)
15:50:23 <mreh> is that what the <- does?
15:50:33 <koeien> :t [putStrLn "hello", print 37]
15:50:35 <lambdabot> [IO ()]
15:50:58 <koeien> mreh: myGetLine >>= (\l -> return (c:l))
15:51:23 <Cale> mreh: yes
15:51:30 <Cheshire> mreh, <- is shorthand for >>=
15:51:41 <Cale> In a do-block, v <- x means "run x and call its result v"
15:51:49 <koeien> you can sugar this into what you had. the '<-' is "binding the result of..."
15:51:55 <Cale> the do-block as a whole represents another IO (or other monad) action
15:53:00 <beelsebob> (c:) <$> myGetLine -- this is much nicer ofc though
15:53:11 <mreh> is that a section?
15:53:16 <beelsebob> yes
15:53:24 <mreh> what are the <> for?
15:53:27 <koeien> yes
15:53:28 <beelsebob> <$> is fmap
15:53:36 <roconnor> @type (<$>)
15:53:36 <beelsebob> it applies the function *inside* the functor
15:53:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:53:47 <roconnor> @type fmap
15:53:48 <beelsebob> so it applies the (c:) inside the IO action
15:53:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:54:05 <beelsebob> result – an IO action that gets the line, and then conses c onto it
15:56:21 <mreh> too much information
15:56:30 <beelsebob> consider the same thing for lists
15:56:37 <beelsebob> > fmap (+1) [1,2,3]
15:56:39 <lambdabot>   [2,3,4]
15:56:45 <beelsebob> it applies that function, inside the list
15:56:54 * wli guesses some degree of denormalization must apply.
15:57:05 <beelsebob> > fmap ('a':) ["jam", "ham", "spam"] -- same thing, almost
15:57:07 <lambdabot>   ["ajam","aham","aspam"]
15:57:11 <beelsebob> this works for all functors
15:57:14 <beelsebob> e.g. Maybe...
15:57:23 <beelsebob> > fmap ('a':) (Just "jam")
15:57:25 <lambdabot>   Just "ajam"
15:57:37 <beelsebob> and also IO actions (which I can't demonstrate with lambdabot)
15:57:56 <beelsebob> with an IO action, it applies the function to the result of the impure computation
15:58:09 * wli thinks something like bounded normalization makes sense.
15:59:22 <beelsebob> we can even take this further... (:) <$> getChar <*> myGetLine -- now all we're missing is the if part
15:59:29 <wli> Opportunistically do partial normalization at various places in the implementation, add some API function to force normalization further.
15:59:50 <beelsebob> but that really does require monads
15:59:54 <beelsebob> not just applicatives
16:04:21 <Cale> hmm
16:05:12 <Cale> Does an applicative with that sort of branching imply that it's a monad?
16:06:24 <byorgey> Cale: what sort of branching?
16:06:35 <beelsebob> Cale: not any sort of branching
16:06:39 <beelsebob> just some sorts of branching
16:07:58 <beelsebob> (if' (=='\n') (\_ _ -> "") (:)) <$> getChar <*> myGetLine -- does this work?
16:08:02 <beelsebob> I'm not certain
16:08:09 <beelsebob> it looks like it should
16:08:41 <beelsebob> maybe I was wrong about that one being monadic
16:08:55 <jasondew> anyone know who maintains the GD bindings?
16:09:01 <beelsebob> oh wait – that one doesn't work
16:09:10 <beelsebob> that one evaluates myGetLine whether the condition was true or not
16:09:16 <beelsebob> so yeh, it does need a monad
16:09:57 <Cale> So applicative + if -> monad?
16:10:05 <byorgey> anything where you need to decide which effects you want based on some intermediate result requires a monad.
16:10:05 <Cale> Or is it something in between?
16:10:32 <byorgey> Cale: what, precisely, do you mean by 'applicative + if' ?
16:10:35 <beelsebob> it's not so much applicative + if -> monad, it's applicative + if and not wanting to be too strict -> monad
16:10:35 <Cale> Can you define join using the applicative operations and an  if :: f Bool -> f a -> f a -> f a ?
16:10:46 <Cale> (I don't think so...)
16:10:51 <beelsebob> Cale: no, you can't
16:11:01 <Cale> So there might be something in between there.
16:11:08 <byorgey> Cale: I see, no, monad is more powerful than that
16:11:14 <Cale> Yeah.
16:11:14 <beelsebob> I'm not sure what you mean by between the two
16:11:27 <Cale> beelsebob: Between Applicative and Monad
16:11:29 <beelsebob> what would it be able to express?
16:11:37 <beelsebob> i.e. what more than applicative but less than monad
16:11:45 <byorgey> it would be able to express some useful things.
16:11:49 <Cale> This function in particular.
16:12:00 <beelsebob> Cale: I think bind is the crucial thing missing here
16:12:13 <beelsebob> it needs a "do the getChar first, then do the if, then figure out the rest"
16:12:15 <Cale> Well, this doesn't need the full power of bind.
16:12:23 <beelsebob> doesn't it?
16:13:19 <byorgey> applicative + if  allows you to do anything where you know the computations you want to choose among beforehand (and there are finitely many).
16:13:35 <byorgey> monad lets you arbitrarily *compute* new computations based on intermediate results.
16:13:43 <byorgey> so there could be infinitely many you want to choose among.
16:13:48 <Cale> yeah
16:13:50 <beelsebob> the key is that the function (if') returns a wrapped value from a pure value, rather than requiring the whole thing to be wrapped?
16:13:56 <beelsebob> unless I'm missing something
16:14:27 <beelsebob> hmm... interesting
16:14:30 <Cale> beelsebob: Well, it lets you decide which of two computations you'd like to choose to execute based on the result of another.
16:14:41 <Cale> (and thus you could choose between finitely many)
16:14:49 <beelsebob> Cale: yeh, that's kinda what I'm saying – it does that by only needing a pure valued input
16:14:56 <beelsebob> rather than needing the whole function to be wrapped up
16:15:07 <beelsebob> which is exactly the difference between (=<<) and (<*>)
16:15:43 <ddarius> beelsebob: They're not even the same type.
16:15:45 <beelsebob> so I find this interesting – it suggests that monads are only necessary over applicatives when you actually want sequencing
16:15:50 <beelsebob> ddarius: that's my point
16:16:01 <beelsebob> (<*>)'s type has the function all wrapped up
16:16:07 <beelsebob> you can't evaluate anything until you get into the applicative
16:16:22 <beelsebob> (=<<) doesn't – it allows you to figure out what action you want without getting inside the monad yet
16:16:37 <Cale> I find this wording to be confusing... but I think I see what you're saying.
16:16:47 * byorgey was about to say that =)
16:16:53 <beelsebob> yeh, sorry
16:17:03 <beelsebob> a decent amount of champagne has passed my lips :/
16:17:26 <beelsebob> so hmm, does this mean that monads are litterally all about sequencing?
16:17:27 <byorgey> hehe
16:17:29 <rndm> beelsebob: hopefully in the canonical direction
16:17:36 <beelsebob> rndm: so far, yes :)
16:17:45 <beelsebob> are they only more powerful than applicatives exactly when you want sequencing
16:17:45 <Cale> beelsebob: Well... so are applicatives, in a way.
16:17:52 <beelsebob> true
16:18:17 <Cale> beelsebob: The difference between applicatives and monads is in your ability to choose what the rest of the computation should be.
16:18:23 <beelsebob> yeh
16:18:29 <beelsebob> decision half way through
16:18:35 <byorgey> I don't think either are inherently about sequencing.
16:18:37 <wli> > let orbit (n :: Integer) k = unfoldr (\(x, s) -> let y = (x * k) `mod` n in if member y s then Nothing else Just (y, (y, Data.Set.insert y s))) (1, empty) ; order n k = length $ orbit n k in (orbit 40 3, order 40 3)
16:18:38 <Cale> In an applicative, it's fixed independently of the result of the earlier computations.
16:18:39 <lambdabot>   Not in scope: `member'    Ambiguous occurrence `empty'
16:18:39 <lambdabot>      It could refer ...
16:18:42 <byorgey> no more than function composition is, at least.
16:18:44 <wli> ergh
16:18:54 <beelsebob> byorgey: I think monad really is
16:19:09 <beelsebob> it's sole advantage over applicative is that you can base descisions based on "earlier" computations
16:19:10 <Cale> byorgey: Well, perhaps composing computations is a better name than sequencing.
16:19:16 <beelsebob> i.e. ones on the right of the =<<
16:19:18 <byorgey> Cale: sure.
16:19:21 <wli> > let orbit (n :: Integer) k = unfoldr (\(x, s) -> let y = (x * k) `mod` n in if Data.Set.member y s then Nothing else Just (y, (y, Data.Set.insert y s))) (1, Data.Set.empty) ; order n k = length $ orbit n k in (orbit 40 3, order 40 3)
16:19:23 <lambdabot>   /tmp/2059571785234403431:70:139: Not in scope: `Data.Set.member'/tmp/205957...
16:19:30 <wli> Brilliant.
16:19:42 <byorgey> Cale: that's my point.
16:19:43 <Cale> beelsebob: But we just found a nice thing sitting in between applicative and monad which has a weaker kind of selection.
16:19:53 <beelsebob> did we?
16:19:56 <Cale> Yes :)
16:20:02 <beelsebob> what can it not do?
16:20:10 <beelsebob> (that a monad can)
16:20:18 <Cale> class Applicative f => Branchy f where ifA :: f Bool -> f a -> f a -> f a
16:20:31 <Cale> It can't select between infinitely many futures.
16:20:36 <idnar> that sounds arrowish
16:20:43 <beelsebob> but that's just liftA2 (if') isn't it?
16:20:46 <Cale> no
16:20:51 <Cale> It's intended to be different.
16:20:56 <beelsebob> oh so hang on
16:21:04 <beelsebob> this thing can do the lazyness with finitely many things
16:21:05 <byorgey> beelsebob: liftA2 (if') would still have the effects of both its arguments.
16:21:08 <idnar> @type liftA2 (if1)
16:21:09 <beelsebob> but can't deal with infinitely many
16:21:09 <lambdabot> Not in scope: `if1'
16:21:11 <idnar> @type liftA2 (if')
16:21:12 <beelsebob> interesting
16:21:12 <wli> Somebody please add fully-qualified Map and Set to lambdabot's namespace.
16:21:13 <lambdabot> Not in scope: `if''
16:21:27 <idnar> @type let if' p a b = if p then a else b in liftA2 (if')
16:21:29 <lambdabot> forall b (f :: * -> *). (Applicative f) => f Bool -> f b -> f (b -> b)
16:21:44 <Cale> hmm...
16:21:48 <idnar> @type let if' p a b = if p then a else b in liftA3 (if')
16:21:49 <lambdabot> forall b (f :: * -> *). (Applicative f) => f Bool -> f b -> f b -> f b
16:22:05 <beelsebob> idnar: it has the right type, but not the right semantics
16:22:09 <Cale> > let orbit (n :: Integer) k = unfoldr (\(x, s) -> let y = (x * k) `mod` n in if S.member y s then Nothing else Just (y, (y, S.insert y s))) (1, S.empty) ; order n k = length $ orbit n k in (orbit 40 3, order 40 3)
16:22:11 <beelsebob> so... hmm
16:22:11 <lambdabot>   /tmp/67296378691101627:70:139: Not in scope: `S.member'/tmp/672963786911016...
16:22:14 <Cale> okay.
16:22:16 <Cale> I don't know :)
16:22:18 <beelsebob> I really get the feeling it should be possible to implement bind with that
16:22:31 <wli> > let orbit (n :: Integer) k = unfoldr (\(x, s) -> let y = (x * k) `mod` n in if Set.member y s then Nothing else Just (y, (y, Set.insert y s))) (1, Set.empty) ; order n k = length $ orbit n k in (orbit 40 3, order 40 3)
16:22:31 <Cale> beelsebob: Forget bind, think about join.
16:22:33 <lambdabot>   ([3,9,27,1],4)
16:22:40 <beelsebob> Cale: well, one or the other
16:22:44 <beelsebob> they're equally powerful
16:22:48 <Cale> beelsebob: To implement join, you need something which decreases the number of functor applications.
16:22:59 <Cale> beelsebob: But ifA doesn't give us anything like that.
16:23:02 <beelsebob> hmm
16:23:13 <beelsebob> I'm not sure I get what you mean by decreasing the number of function apps
16:23:20 <Cale> :t join
16:23:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:23:38 <Cale> m (m a) -> m a -- we go from 2 m's to 1.
16:23:44 * byorgey doesn't get it either, how does (>>=) 'decrease the number of functor applications'?  yet you can implement join with that.
16:23:50 <idnar> @type (>>=)
16:23:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:24:00 <idnar> there's an m a and an a there :P
16:24:10 <Cale> well, take a = m b
16:24:23 <byorgey> ah, ok
16:24:26 <beelsebob> ahhh
16:24:30 <beelsebob> interesting
16:25:30 <idnar> @type (=<<) id
16:25:31 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
16:25:44 <ddarius> @src join
16:25:45 <lambdabot> join x =  x >>= id
16:27:48 <Cale> (but yeah, bind is a little harder to think about in this way because it has both a and b)
16:27:56 <beelsebob> so hmm
16:28:14 <beelsebob> do we have any Branchies that are useful as Monads?
16:28:34 <Cale> Or any Branchies which are not Monads? :)
16:28:39 <beelsebob> yeh
16:28:45 <byorgey> that's the more interesting question...
16:29:20 <beelsebob> well what I was thinking was are the monadic operators actually useful on IO for example, if you have the IO Branchy
16:29:34 <byorgey> hmm, ZipList is Branchy I think
16:29:44 <byorgey> although I'm not sure what laws Branchy things should satisfy.
16:30:54 <byorgey> instance Branchy ZipList where ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith if' bs xs ys
16:30:57 <Cale> ifA (pure True) x y = x
16:31:02 <Cale> ifA (pure False) x y = y
16:31:04 <Cale> for one
16:31:09 <byorgey> check! =)
16:31:39 <byorgey> er, sorry, that should be zipWith3 or something
16:32:05 <byorgey> hopefully the idea is clear =)
16:32:18 <beelsebob> @instances Monad
16:32:19 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:32:21 <byorgey> (the point being that ZipList is an Applicative which is not a Monad)
16:32:28 <beelsebob> so hmm
16:32:38 <beelsebob> are there any Applicatives which are not Branchies
16:32:58 <beelsebob> yes, the normal list applicative?
16:33:00 <idnar> > let ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in ifA (pure True) (ZipList [1]) (ZipList [2])
16:33:02 <lambdabot>   Not in scope: `if''    Ambiguous occurrence `pure'
16:33:02 <lambdabot>      It could refer to e...
16:33:10 <byorgey> beelsebob: that's a monad, so it has to be Branchy
16:33:17 <beelsebob> oh, duh
16:33:18 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in ifA (pure True) (ZipList [1]) (ZipList [2])
16:33:20 <lambdabot>       Ambiguous occurrence `pure'
16:33:20 <lambdabot>      It could refer to either `Control.Appl...
16:33:26 <byorgey> doh!
16:33:30 <beelsebob> @instances Applicative
16:33:31 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
16:33:33 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in ifA (Control.Applicative.pure True) (ZipList [1]) (ZipList [2])
16:33:34 <lambdabot>       No instance for (Show (ZipList t))
16:33:34 <lambdabot>        arising from a use of `show' ...
16:33:41 <byorgey> double doh
16:33:43 <beelsebob> @instances-importing Control.Applicative Applicative
16:33:44 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
16:33:48 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in getZipList $ ifA (Control.Applicative.pure True) (ZipList [1]) (ZipList [2])
16:33:50 <lambdabot>   [1]
16:33:57 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in getZipList $ ifA (Control.Applicative.pure False) (ZipList [1]) (ZipList [2])
16:33:58 <lambdabot>   [2]
16:34:03 <idnar> yay
16:34:07 <beelsebob> ((,) a) is another Branchy that's not a monad, isn't it
16:34:43 <idnar> why isn't ((,) a) a monad?
16:34:45 <byorgey> beelsebob: that's the writer monad
16:34:52 <beelsebob> is it?
16:35:02 <beelsebob> I thought that needed Monoid on the a?
16:35:20 <byorgey> beelsebob: yeah, the Applicative instance requires Monoid on the a too.
16:35:25 <beelsebob> oh, okay
16:35:27 <byorgey> it just isn't shown in that list.
16:35:31 <Peaker> idnar: without Monoid or something else, how do you implement "return"?
16:35:50 <beelsebob> Peaker: similarly though, how do you implement pure, as byorgey points out
16:35:54 <Peaker> yeah
16:35:57 <Peaker> same thing
16:36:01 <Peaker> pure=return
16:36:14 <byorgey> right, @instances-importing just doesn't list type class constraints
16:36:33 <idnar> Peaker: okay, but assuming you have Monoid...?
16:36:37 <Peaker> > return 5 :: (Int, Int)
16:36:39 <lambdabot>       No instance for (Monad ((,) Int))
16:36:39 <lambdabot>        arising from a use of `return'...
16:36:42 <Peaker> idnar: mempty then
16:36:57 <idnar> Peaker: hmm?
16:37:05 <Peaker> idnar: then it is a monad
16:37:09 <idnar> > Control.Applicative.pure 5 :: (Int, Int)
16:37:10 <lambdabot>       No instance for (Monoid Int)
16:37:10 <lambdabot>        arising from a use of `Control.Appl...
16:37:16 <idnar> > Control.Applicative.pure [5] :: (Int, Int)
16:37:18 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
16:37:20 <beelsebob> hmm, I think Cale's laws may actually encode the whole thing
16:37:21 <idnar> oops
16:37:21 <Peaker> I was hoping it would complain about missing Monoid instance
16:37:26 <idnar> > Control.Applicative.pure [5] :: ([Int], [Int])
16:37:28 <lambdabot>   ([],[5])
16:37:32 <byorgey> anyway, I don't know of any Applicatives that aren't Monads other than ZipList
16:37:34 <Peaker> > return 5 :: ([Int], Int)
16:37:35 <idnar> > return [5] :: ([Int], [Int])
16:37:36 <lambdabot>       No instance for (Monad ((,) [Int]))
16:37:36 <lambdabot>        arising from a use of `retur...
16:37:37 <lambdabot>       No instance for (Monad ((,) [Int]))
16:37:37 <lambdabot>        arising from a use of `retur...
16:37:42 <beelsebob> in that they demand that ifB (pure True) x _|_ = x
16:37:48 <idnar> so, there's an Applicative instance but no Monad instance
16:37:49 <Peaker> the writer monad seems to not be imported there
16:37:50 <beelsebob> which is the thing we really wanted
16:37:57 <idnar> (where is that Applicative instance defined?)
16:38:19 <Peaker> idnar: that's the disadvantage of orphaned instances -- the writer monad instance is really an orphan instance
16:38:35 <idnar> anyhow Writer is just a newtype of (,) a
16:38:37 <Peaker> (you have imported both the class and the type, but the instance isn't there)
16:38:51 <idnar> I can't find a definition for (,) a though
16:39:03 <byorgey> idnar: I think it's in Control.Monad.Instances, isn't it?
16:39:12 <idnar> byorgey: not on my local system
16:39:39 <byorgey> idnar: huh, maybe there isn't one
16:39:45 <byorgey> idnar: there's only the Writer newtype
16:39:50 <idnar> anyhow, that doesn't really matter
16:39:57 <byorgey> > return [5] :: Writer [Int] [Int]
16:39:58 <lambdabot>       No instance for (Show (Writer [Int] [Int]))
16:39:58 <lambdabot>        arising from a use o...
16:40:10 <idnar> the point is ((,) a) is a monad even if there's no standard instance :P
16:40:13 <beelsebob> hmm
16:40:18 <byorgey> indeed =)
16:40:23 <idnar> NEEEEXT!
16:40:58 <beelsebob> would it make any sense for Branchy and Applicative to be equal – i.e. is it possible that (<*>) and pure are not sufficient to write ifB, but that for anything that you can get an Applicative instance of, you can also write ifB
16:41:11 <Petrosian> Hey, anyone got any useful examples of using mfix?
16:41:16 <idnar> what is Const?
16:41:25 <byorgey> beelsebob: that sounds possible, I don't know.
16:41:30 <byorgey> idnar: newtype Const a b = Const a
16:41:49 <byorgey> it's an Applicative (and Monad) with Monoid a
16:41:53 <idnar> that's an applicative that "contains no value"?
16:41:55 <Cale> beelsebob: Possibly for Hask, but I highly doubt in an arbitrary category.
16:42:07 <byorgey> idnar: right.
16:42:20 <idnar> funky (also, can't find a monad instance, but I guess I can probably figure it out)
16:42:36 * beelsebob is suddenly stricken with the wish he'd learned more of category theory
16:42:52 <idnar> > Control.Applicative.pure 5 :: Const String
16:42:54 <lambdabot>       `Const String' is not applied to enough type arguments
16:42:54 <lambdabot>      Expected ki...
16:42:59 <idnar> > Control.Applicative.pure 5 :: Const String Int
16:43:00 <lambdabot>       No instance for (Show (Const String Int))
16:43:00 <lambdabot>        arising from a use of ...
16:43:01 <byorgey> idnar: it's mostly useful in conjunction with things like Traversable -- e.g. for computing some property of a structure that doesn't depend on the data it contains
16:43:08 <idnar> > getConst $ Control.Applicative.pure 5 :: Const String Int
16:43:10 <lambdabot>       No instance for (Show (Const String Int))
16:43:10 <lambdabot>        arising from a use of ...
16:43:22 <idnar> whaat?
16:43:29 <idnar> > getConst (Control.Applicative.pure 5 :: Const String Int)
16:43:31 <lambdabot>   ""
16:43:34 <idnar> ah
16:43:56 <Peaker> beelsebob: what's the type of ifB?
16:43:58 <idnar> byorgey: okay
16:44:18 <byorgey> > getConst (Const "foo" (+1) <*> Const "bar" 5)
16:44:20 <lambdabot>   Couldn't match expected type `(a2 -> a2) -> Const a (a1 -> b)'
16:44:26 <beelsebob> Peaker: ifB :: (Branchy b) => b Bool -> b a -> b a -> b a
16:44:35 <byorgey> err, hmm
16:44:44 <byorgey> oh, duh
16:44:57 <idnar> byorgey: I guess the instances are the same as for (,) a, except with the second member discarded
16:45:05 <byorgey> idnar: right.
16:45:46 <byorgey> all you do is just mempty for pure, and mappend for <*>.
16:46:19 <byorgey> idnar: McBride and Paterson's "Applicative Programming With Effects" has some neat examples of its use.
16:46:26 <Peaker> beelsebob: not all Applicatives can implement that
16:46:32 <beelsebob> Peaker: which one can't?
16:46:58 <gwern> good grief. I looked in at noon and y'all were talking about applicative; and now it's 8 and y'all are *still* talking about applicative
16:47:14 <beelsebob> gwern: no, we're talking about Branchies now
16:47:20 <byorgey> Peaker: we know you can't implement that using the Applicative methods.  beelsebob's question was whether there is *actually* anything which could be an instance of Applicative but not Branchy.
16:47:28 <Peaker> beelsebob: if you have some parser/grammar type as an applicative instance, you don't want to have your grammar depend on the previous parse results - so you can build a DSM from it
16:47:33 <idnar> beelsebob: I'm sure you could deliberately construct an applicative that isn't a branchy
16:47:39 <Peaker> byorgey: I understand
16:47:52 <gwern> beelsebob: looks like an applicative discussion to me -_-
16:47:55 <byorgey> gwern: I think you need a larger sample size. ;)
16:47:56 <idnar> beelsebob: the question is whether there are any /interesting/ applicatives that aren't branchies, or any interesting branchies that aren't monads
16:47:58 <beelsebob> idnar: are you sure?
16:48:07 <beelsebob> idnar: well, we already found the latter
16:48:13 <beelsebob> ZipList is a Branchy but not a Monad
16:48:29 <idnar> oh, well, yes
16:48:29 <gwern> byorgey: I only deal in logical proofs! we care not for sample sizes!
16:48:59 <gwern> (show me as many non-black non-ravens, and I still will maintain we do not know ravens are black!)
16:49:01 <idnar> if it's not possible to build ifB from pure and <*>, then my intuition tells me that it should be possible to construct an applicative that isn't a branchy; I can't prove that, though :P
16:49:20 <beelsebob> idnar: yeh, nor can I, which is why I'm suspicious of it
16:49:28 <byorgey> beelsebob: well, there aren't going to be any other *standard* instances that are Applicative but not Branchy, because ZipList is the only standard Applicative instance that isn't a monad
16:49:32 <beelsebob> I can't even think how a proof would start
16:49:34 <gwern> hm, c.h.o is down?
16:49:48 <idnar> the thing is, an applicative constructed in that fashion would probably not have much practical value :P
16:49:49 <beelsebob> byorgey: yeh, I want to think more generally than the standard things we see in haskell
16:49:57 <byorgey> right, ok.
16:49:59 <gwern> yeah, it's up for ping but a darcs pull & web browsing fails
16:50:02 <gwern> how annoying
16:50:12 <byorgey> gwern: yeah, down for me too.
16:50:22 <idnar> I'm too tired to think about this properly; but you just need to find some way to deliberately "break" ifB without breaking <*> / pure
16:51:01 <beelsebob> Cale: your Branchy laws aren't quite right btw – should have been ifB (pure True) (pure x) _ = pure x and ifB (pure False) _ (prue y) = pure y
16:51:07 <idnar> so, what other applicatives do we have? parsec?
16:51:15 <Cale> beelsebob: oh?
16:51:18 <Cale> beelsebob: why?
16:51:29 <beelsebob> well, take the ZipList branchy for example
16:51:33 <Cale> beelsebob: I think it's *very* important that it's not just for pure
16:51:33 <beelsebob> oh hang on
16:51:41 <beelsebob> am I thinking bollocks
16:51:42 <idnar> we already proved Cale's version for ZipList :P
16:51:43 <beelsebob> ...
16:51:44 <beelsebob> *thinks*
16:51:52 <beelsebob> yeh, sorry, I'm thinking bollocks
16:51:53 <Peaker> beelsebob, idnar, byorgey: here you go: data NotBranchy a = NotBranchy (IO ()) ; instance Functor NotBranchy where fmap = id ; instance Applicative NotBranchy where pure _ = NotBranchy (return ()) ; (NotBranchy x)<*>(NotBranchy y) = (NotBranchy (x>>y))
16:51:55 <beelsebob> too much booze
16:51:58 <idnar> oh, maybe not
16:52:30 <idnar> @type fmap
16:52:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:52:32 <idnar> @type id
16:52:34 <lambdabot> forall a. a -> a
16:52:39 <byorgey> Peaker: fmap = id??
16:52:53 <Peaker> byorgey: yeah, it doesn't actually contain a value -- its an applicative purely for the effect
16:53:10 <byorgey> ohhhh, right, I see. sorry.
16:53:15 <idnar> id :: (a -> b) -> NotBranchy a -> NotBranchy b
16:53:21 <idnar> how can that unify?
16:53:38 <byorgey> oh, wait!
16:53:43 <byorgey> Const works.
16:53:47 <byorgey> it isn't a monad, I forgot.
16:53:53 <byorgey> and it isn't Branchy either.
16:53:55 <beelsebob> oh, awesome
16:53:58 <idnar> I guess Peaker meant const
16:54:08 <beelsebob> so Branchy is useful
16:54:14 <byorgey> for the same reason as Peaker's example above -- a 'Const b a' does not actually contain an a.
16:54:17 <Peaker> yeah, I don't know Const, so I re-made it up :)
16:54:24 <idnar> beelsebob: eh, only if NotBranchy is useful
16:54:41 <byorgey> beelsebob: let's not jump to conclusions =)
16:54:43 <beelsebob> idnar: which is reducable to if Const is useful
16:54:44 <Peaker> beelsebob: there's ArrowChoice which is pretty similar
16:54:44 <beelsebob> which it is
16:55:01 <Peaker> @src ArrowChoice
16:55:01 <lambdabot> Source not found. Sorry.
16:55:10 <idnar> beelsebob: but Const is a monad
16:55:13 <byorgey> Peaker: yeah, I wonder what the connection is.
16:55:22 <beelsebob> idnar: no its not?
16:55:26 <Peaker> ArrowChoice to Arrow is what Branchy is to Applicative?
16:55:43 <idnar> beelsebob: oh, whoops, I'm thinking of Identity
16:55:51 <byorgey> Peaker: something like that.
16:55:52 <idnar> uhm, so is Const a Branchy?
16:55:56 <beelsebob> nope
16:56:14 <beelsebob> so we have an Applicative which is not a Branchy, and a Branchy which is not a Monad
16:56:24 <byorgey> no, it isn't.  you could *implement* it, but it wouldn't satisfy the laws.
16:56:39 <byorgey> since a 'Const x Bool' does not actually contain a Bool
16:56:46 <byorgey> you wouldn't know which to pick.
16:57:21 <Peaker> beelsebob: who is a Branchy that is not a monad?
16:57:27 <beelsebob> ZipList
16:57:28 <idnar> Peaker: ZipList
16:57:28 <byorgey> Peaker: ZipList
16:57:42 <idnar> oh boy
16:57:59 <byorgey> someone should write this up on their blog =)
16:58:08 <Peaker> finite ZipLists are well-formed Applicatives?
16:58:21 <byorgey> I'll do it if no one else does, but I need to get back to writing my Monad.Reader article...
16:58:35 <beelsebob> Peaker: yep, pure is robot monkey, and <*> is pairwise application
16:58:45 <byorgey> beelsebob: no, pure is repeat
16:58:55 <beelsebob> oh, yeh
16:59:19 <byorgey> pure is robot monkey for the normal list instance, which corresponds to the list monad too.
16:59:28 <beelsebob> yeh
17:00:14 <byorgey> well, fun hashing this out with you all
17:00:19 * byorgey goes back to writing
17:01:03 * beelsebob will try and synthesise a blog entry about this tomorrow if no one else wants to
17:01:10 <beelsebob> I may be rather more sober
17:02:28 <idnar> someone write a paper
17:03:26 <byorgey> I kind of doubt it's worth a paper, unless we can find some great use case for which Branchy is well-suited
17:03:46 <beelsebob> well, Ivan Tomac just went "oh hay, I could really use that in my GPU code generator"
17:03:49 <idnar> oh, yeah, we need an interesting use of ifB :P
17:03:49 <beelsebob> so...
17:03:57 <idnar> oh, sweet
17:04:22 <byorgey> beelsebob: well, maybe we can =)
17:04:56 <gwern> @quote Pilgrim
17:04:57 <lambdabot> No quotes match.
17:04:58 <byorgey> it's not necessarily *un*interesting to use things as Branchies which also happen to be Monads.
17:05:00 <gwern> @quote Mark
17:05:01 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
17:05:03 <gwern> @quote Mark
17:05:03 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
17:05:12 <byorgey> it's nice to know that you're not using more power than you actually need.
17:05:19 <gwern> @remember MarkPilgrim "In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end."
17:05:20 <lambdabot> Nice!
17:05:21 <beelsebob> byorgey: true true
17:05:24 <gwern> @flush
17:05:42 <byorgey> now all we need is some nice syntax sugar for using ifB
17:05:50 <beelsebob> byorgey: also, I can see tripple-wise ifB on ZipLists being really useful
17:06:06 <byorgey> beelsebob: indeed.
17:06:42 <byorgey> haha, someone was just asking the other day how to pick elements alternatingly from two lists
17:07:15 <byorgey> with a Branchy instance for ZipList you could just write   ifB (cycle [True, False]) l1 l2
17:07:26 <beelsebob> neat
17:07:29 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in getZipList $ ifA (cycle [True, False]) (ZipList [1..]) (ZipList [2..])
17:07:29 <byorgey> well, except with some annoying ZipList constructors in there too
17:07:30 <lambdabot>   Couldn't match expected type `ZipList Bool'
17:07:38 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in getZipList $ ifA (ZipList . cycle [True, False]) (ZipList [1..]) (ZipList [2..])
17:07:40 <lambdabot>   Couldn't match expected type `a -> [a1]'
17:07:42 <idnar> erf
17:07:44 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in getZipList $ ifA (ZipList $ cycle [True, False]) (ZipList [1..]) (ZipList [2..])
17:07:46 <lambdabot>   [1,3,3,5,5,7,7,9,9,11,11,13,13,15,15,17,17,19,19,21,21,23,23,25,25,27,27,29...
17:08:01 <idnar> > let if' p a b = if p then a else b; ifA (ZipList bs) (ZipList xs) (ZipList ys) = ZipList $ zipWith3 if' bs xs ys in getZipList $ ifA (ZipList $ cycle [True, False]) (ZipList [1,1..]) (ZipList [2,2..])
17:08:03 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
17:08:12 <beelsebob> shiny as hell :)
17:08:37 <byorgey> that's a pretty complicated way to make (cycle [1,2]) =)
17:08:42 <idnar> haha
17:08:46 <beelsebob> haha
17:08:50 <byorgey> but I could see it being actually useful in some circumstances.
17:09:01 <byorgey> just have to think up some interesting examples.
17:09:31 <beelsebob> fmap fmap fmap sequence fmap return is my current favourite way of writing nothing useful
17:09:45 <idnar> @type fmap fmap fmap sequence fmap return
17:09:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m [a]
17:09:51 <beelsebob> it's return
17:09:56 <beelsebob> fmap fmap fmap sequence fmap is mapA
17:09:59 <chessguy> is it possible to use record syntax for multiple constructors?
17:10:00 <Olathe> @type return
17:10:02 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:10:15 <idnar> *groan*
17:10:20 <byorgey> chessguy: yeah, just be careful using the projection functions in that case, they become partial.
17:10:23 <idnar> > fmap fmap fmap sequence fmap return [1,2,3]
17:10:25 <lambdabot>       No instance for (Show (m [a]))
17:10:25 <lambdabot>        arising from a use of `show' at <...
17:10:33 <idnar> > fmap fmap fmap sequence fmap return [1,2,3] :: Maybe [Int]
17:10:35 <lambdabot>   Just [1,2,3]
17:10:37 <chessguy> byorgey:  oh, good call
17:10:40 <idnar> whee
17:10:48 <beelsebob> > fmap fmap fmap sequence fmap (return . (+1)) [1,2,3] :: Maybe [Int]
17:10:49 <lambdabot>   Just [2,3,4]
17:11:08 <idnar> @type fmap fmap fmap
17:11:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:11:19 <byorgey> chessguy: you get runtime pattern-match errors if you call a projection function on a value with a different constructor.
17:11:22 <idnar> @type fmap fmap fmap sequence
17:11:23 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (m :: * -> *) a. (Monad m, Functor f1, Functor f) => f (f1 [m a]) -> f (f1 (m [a]))
17:11:33 <idnar> @type fmap fmap fmap sequence fmap
17:11:34 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
17:11:41 <chessguy> byorgey:  sure. i know what a partial function is :)
17:11:53 <beelsebob> @type let sequence = foldr (liftA2 (:)) (pure []) in fmap fmap fmap sequence
17:11:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a. (Functor f1, Functor f, Applicative f2) => f (f1 [f2 a]) -> f (f1 (f2 [a]))
17:12:00 <beelsebob> no monads here ;)
17:12:03 <byorgey> ok, sorry, I know you know what a partial function is, I was just elaborating =)
17:12:16 <chessguy> byorgey:  so i would just have to be careful to use the record functions on the right side of a clause in which i had pattern-matched the right constructor
17:12:52 <byorgey> chessguy: right.  personally, I don't know if it would be worth it.
17:13:19 <byorgey> chessguy: if I were tempted to write such code, I would just split each of the constructors into their own record type
17:13:35 <chessguy> byorgey:  fair enough
17:14:00 <byorgey> that way the type system will actually tell you if you use a projection function on the wrong thing.
17:14:14 * beelsebob runs off to bed
17:14:27 <byorgey> chessguy: feel free to do whatever you want, of course =)
17:14:54 <chessguy> byorgey:  sure. but it's always wise to get the opinion of someone more experienced, and to take it to heart
17:15:36 <chessguy> especially if you have a UPenn prof's ear!
17:15:58 <byorgey> hehe
17:16:31 <Gracenotes> hm... it seems that text-to-speech is probably not the best way to work through PDFs when exercising
17:16:40 <Gracenotes> I don't think there is a good way :/
17:16:46 <byorgey> chessguy: it's too bad we never got to meet while I was living in DC
17:16:56 <chessguy> byorgey:  i didn't know you lived there
17:17:01 <chessguy> byorgey:  you were downtown?
17:17:19 <byorgey> yeah, on capitol hill, near eastern market if you know where that is
17:17:35 <chessguy> i avoid DC :)
17:17:41 <chessguy> we're out in Reston
17:17:42 <byorgey> fair enough =)
17:17:54 <chessguy> and i work in Tyson's Corner
17:18:18 <byorgey> cool
17:19:28 <lepassive> I'm trying to write a tree-like in haskell http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1385#a1385 but till now I only got a flower :S
17:28:45 <ztirF> @src ap
17:28:46 <lambdabot> ap = liftM2 id
17:29:19 <ztirF> @pl f x (g y)
17:29:19 <lambdabot> f x (g y)
17:29:25 <ztirF> @pl \x y -> f x (g y)
17:29:26 <lambdabot> (. g) . f
17:30:17 <idnar> @type ap
17:30:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:30:56 <chessguy> > read '3'
17:30:58 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
17:31:02 <idnar> @unpl ap
17:31:03 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
17:31:06 <idnar> meh
17:31:11 <chessguy> > digitToInt '3'
17:31:13 <lambdabot>   3
17:34:55 <idnar> > ap f g x y
17:34:57 <lambdabot>   Add a type signature
17:35:03 <idnar> mmm
17:36:56 <dolio> > ap f (g :: Expr -> Expr) x y :: Expr
17:36:58 <lambdabot>   f x (g x) y
17:42:09 <Nafai> Is code.haskell.org down?
18:00:16 <byorgey> hmm, I seem to remember seeing somewhere a formulation of the monad laws in terms of fmap, return, and join.
18:00:24 <byorgey> anyone have any ideas where that might be?
18:01:16 <Saizan> you just have to translate the diagrams from CT
18:02:08 <byorgey> yeah, I know, but I'm writing an article and I want to give a link to a page that explains it nicely
18:02:26 <byorgey> and I remember seeing such a page before, I just can't find it now.
18:03:55 <rovar> has anyone here used haskell to work on massive numerical data sets?
18:04:39 <rovar> I'm considering using haskell for naive bayes calculations, but am worried that the boxing of individual numbers would impact performance adversely, there also seems to be limited support for simd.
18:04:57 <sereven> byorgey: the wikibooks haskell category theory page discusses it iirc, but that may not be the one you're after
18:06:02 <rovar> brb
18:06:14 <gwern> are ints boxed?
18:06:31 <gwern> bayes would probably involve ints and... floating?
18:06:39 <gwern> double, actually, I guess
18:07:54 <Saizan> Ints are boxed unless they don't
18:08:22 <byorgey> Ints can be unboxed.
18:08:32 <bd_> gwern: Ints are boxed unless the compiler can prove they don't need to be (in which cast it /may/ unbox it) or you explicitly force it to unbox them
18:08:32 <byorgey> "can be" being the key term
18:08:59 <byorgey> sereven: thanks, I'll check it out
18:10:43 <byorgey> sereven: aha, that is actually the page I was remembering, thanks =)
18:10:46 <byorgey> sereven++
18:11:01 <sereven> awesome, lots of sweet diagrams, too.
18:11:26 <byorgey> indeed, it's a great page
18:11:47 <byorgey> I really got a lot out of that page, back when I was learning that stuff.
18:11:55 * byorgey wonders who wrote it
18:14:24 <byorgey> looks like David House, mostly
18:21:24 <byorgey> does anyone know if David House hangs out in here at all?
18:24:13 <pumpkin> benl23: how's the build going?
18:24:59 <benl23> just got in. Got 6.10.1 and darcs built, was just about to do the validate.
18:25:28 <pumpkin> ah cool :)
18:37:38 <Nafai> What's up with code.haskell.org?
18:42:05 <byorgey> not up, down ;)
18:42:43 <Nafai> :(
18:48:35 <olivierp> hi all, I'm having trouble trying to convert 2 variables from Dynamic to the same type
18:49:19 <olivierp> instance EMatch Dynamic where
18:49:20 <olivierp>     match tags x y = case fromDyn2 x y of
18:49:20 <olivierp>         Just (l1, l2) -> match tags l1 l2
18:49:20 <olivierp>         Nothing -> return (False, tags)
18:49:20 <olivierp> fromDyn2 :: forall a . (Eq a, Typeable a) => Dynamic -> Dynamic -> Maybe (L a, L a)
18:49:20 <olivierp> fromDyn2 x y = do
18:49:22 <olivierp>     (l1 :: L a) <- fromDynamic x
18:49:24 <olivierp>     (l2 :: L a) <- fromDynamic y
18:49:26 <olivierp>     return (l1, l2)
18:49:58 <olivierp> I'm getting this error:
18:50:00 <olivierp>     Ambiguous type variable `a' in the constraints:
18:50:00 <olivierp>       `Eq a' arising from a use of `match' at Join/Join.hs:67:25-40
18:50:01 <olivierp>       `Typeable a'
18:50:01 <olivierp>         arising from a use of `fromDyn2' at Join/Join.hs:66:26-37
18:50:01 <olivierp>     Probable fix: add a type signature that fixes these type variable(s)
18:51:24 <Saizan> type of match?
18:51:57 <olivierp> class EMatch a where
18:51:58 <olivierp>    match :: [Tag] -> a -> a -> IO (Bool,[Tag])
18:52:03 <SamB> olivierp: -XScopedTypeVariables ?
18:52:23 <olivierp> yes
18:52:41 <olivierp> (but not sure it's still necessary)
18:52:49 <SamB> oh, wait, you said that's from a use
18:52:53 <SamB> or it did, rather
18:52:58 <SamB> where did you use it ?
18:53:05 <SamB> oh, the instance
18:53:15 <olivierp> yes
18:54:32 <olivierp> (yes I do need ScopedTypeVariables, for the (L :: a) pattern matching only... if you have anything simpler I'm interested)
18:54:38 <SamB> well, that instance DOESN'T fix the type
18:54:58 <olivierp> which type?
18:55:04 <SamB> olivierp: well, I think you could just take out the ":: L a"s and take out the scoped type variables ...
18:55:54 <olivierp> no, because then the 2 fromDynamic aren't bound to the same type... but  I'll check
18:56:59 <SamB> olivierp: the type signature on the function should take care of that
18:57:35 <olivierp> ok, that seems to work but I'm still getting the same error
18:58:06 <SamB> well, you don't seem to say what type you want to convert to
18:58:58 <Saizan> right, you're not telling it which type 'a' fromDyn2 should use
18:59:37 <SamB> not that you have to SAY, but you do need to make sure it isn't ambiguous
18:59:48 <olivierp> I want anything that's an instance of EMatch since I'm calling match on it afterwards
19:00:17 <SamB> well I'm afraid Dynamic can't pick the type for you
19:00:25 <Saizan> then you need to define an existential wrapper and use that, i think
19:00:33 <olivierp> hmm, that makes sense
19:03:27 <olivierp> but then I won't be able to get my 2 wrapped values to agree on their type
19:03:58 <olivierp> the whole point of trying to use Dynamic was that
19:04:33 <Saizan> if you the existential has a Typeable context then you can
19:04:42 <olivierp> so that I can call match on them recursively
19:05:03 <olivierp> hmm
19:05:36 <Saizan> Dynamic is the optimized version of data Dyn = forall a => Typeable a => Dyn a
19:05:55 <Saizan> (modulo syntax errors)
19:09:41 <olivierp> data Argument = forall a . Eq a => Arg (L a) deriving (Typeable)
19:09:41 <olivierp> instance Eq Argument
19:09:41 <olivierp> instance Eq Dynamic
19:09:41 <olivierp> instance EMatch Dynamic where
19:09:42 <olivierp>     match tags x y = case fromDyn2 x y of
19:09:42 <olivierp>         Just (Arg l1, Arg l2) -> match tags l1 l2
19:09:43 <olivierp>         Nothing -> return (False, tags)
19:09:45 <olivierp> fromDyn2 :: Dynamic -> Dynamic -> Maybe (Argument, Argument)
19:09:47 <olivierp> fromDyn2 x y = do
19:09:49 <olivierp>     l1 <- fromDynamic x
19:09:51 <olivierp>     l2 <- fromDynamic y
19:09:53 <olivierp>     return (l1, l2)
19:10:02 <olivierp> this doesn't work:
19:10:12 <olivierp> Join/Join.hs:67:47:
19:10:12 <olivierp>     Couldn't match expected type `a' against inferred type `a1'
19:10:12 <olivierp>       `a' is a rigid type variable bound by
19:10:13 <olivierp>           the constructor `Arg' at Join/Join.hs:67:14
19:10:13 <olivierp>       `a1' is a rigid type variable bound by
19:10:13 <olivierp>            the constructor `Arg' at Join/Join.hs:67:22
19:10:15 <olivierp>       Expected type: L a
19:10:15 <SamB> olivierp: have we introduced you to hpaste.org ?
19:10:17 <olivierp>       Inferred type: L a1
19:10:19 <olivierp>     In the third argument of `match', namely `l2'
19:10:21 <olivierp>     In the expression: match tags l1 l2
19:10:29 <SamB> well, consider yourself introduced
19:11:15 <olivierp> yes, but I'm not quite sure what the length threshold is :)
19:11:52 <SamB> well, it's not strict but I think it'd be easier to help you if you pasted to there.
19:11:59 <SamB> you can paste new versions on the same page
19:13:03 <olivierp> sure
19:15:05 <olivierp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1386
19:15:20 <olivierp> (unchanged)
19:18:10 <olivierp> so, this is what I was thinking of when I said I couldn't have the two match using an existential wrapper... but I guess I didn't quite understand what you suggested
19:27:59 <Saizan> olivierp: with data AnyMatch = forall a. (Typeable a, EMatch a) => AnyMatch a, you can write an instance EMatch AnyMatch where ..
19:28:19 <Saizan> olivierp: not sure if that gets you any closer to what you wanted to do
19:32:37 <olivierp> are you sure I can? I think that runs into the same issue with each use of the constructor binding the type variable
19:33:07 <olivierp> match :: [Tag] -> a -> a -> IO (Bool,[Tag])
19:36:39 <Saizan> .. match tags (AnyMatch x) (AnyMatch y) = cast y of Just y' -> match tags x y; Nothing -> return (False,tags) -- this should typecheck
19:36:53 <Saizan> ops
19:37:09 <Saizan> make that "match tags x y'"
19:38:31 <olivierp> but if you don't cast for both x and y it's not gonna work is it?
19:39:26 <Saizan> you try to cast 'y' to the type of 'x', if that works you can match on x and the casted y
19:39:42 <Saizan> otherwise they are different types and can't match
19:40:16 <drhodes> for,  allFuncs :: (a -> ((b -> c -> d) -> e) ... ) -> n     with arbitrary grouping, are all definitions for allF with arity size (1 .. (n-1)) well formed?
19:40:56 <drhodes> allF = allFuncs
19:42:43 <Saizan> well formed in the sense that those are valid types, most won't have a valid implementation though
19:44:26 <olivierp> Saizan: hmm I think this might well work, thanks a lot!
19:44:58 <drhodes> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))     -- from the "you could have invented monads tutorial
19:45:28 <drhodes> (Float -> (Float,String))      ->        ((Float,String) -> (Float,String))
19:45:57 <hydrapheetz> urp
19:46:02 <drhodes> bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs)    -- is the solution
19:46:03 <hydrapheetz> hm
19:46:21 <hydrapheetz> > map (ord) "Stringy"
19:46:22 <lambdabot>   [83,116,114,105,110,103,121]
19:46:27 <Saizan> that's the same type as "(Float -> (Float,String)) -> (Float,String) -> (Float,String)" if it helps
19:46:34 <hydrapheetz> > sum $ map (ord) "Stringy"
19:46:35 <lambdabot>   752
19:46:41 <Saizan> because -> is right associative
19:48:30 <hydrapheetz> Wonder why it doesn't work with something in a struct-like ... type
19:49:20 <drhodes> the reason why it's right associative, is because partial application is automatic.. right?
19:50:29 <drhodes> because it gets reduced to functions of one variable before run time..
19:52:23 <Saizan> the implementation might be smarter
19:52:44 <Saizan> but at the level of types you only have 1-argument functions that return other functions
19:54:01 <Saizan> so yes, that's the reason
19:55:19 <Gracenotes> > 0xDEADBEEF
19:55:21 <lambdabot>   3735928559
19:58:23 <olivierp> Saizan: infinite recursion...
19:59:12 <olivierp> oops
20:01:30 <olivierp> Saizan: no, my bad. It works but I still get a stack space overflow, I guess this isn't very efficient
20:01:49 <SamB> olivierp: are you using foldl ?
20:02:34 <olivierp> no, the code I'm working with might, I'll check
20:02:59 <drhodes> @karma help
20:03:00 <lambdabot> help has a karma of 0
20:03:21 <SamB> olivierp: it's just that that's the #1 cause of stack overflows, as far as I know
20:03:29 <olivierp> SamB: no, no foldl or foldr
20:04:23 <olivierp> SamB: well it's possible that some traversals are equivalent to folds
20:04:45 <SamB> olivierp: try heap profiling ?
20:04:58 <SamB> see if you're building up a lot of thunks
20:05:08 <Saizan> uhm, you can get infinite recursion from that code only if you have something like AnyMatch (AnyMatch (AnyMatch ...)))
20:05:12 <olivierp> SamB: never done it... link?
20:05:35 <SamB> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
20:06:16 <olivierp> Saizan: the infinite recursion was because I forgot the AnyMatch constructors in the match definition
20:07:08 <drhodes> @karma+ Saizan
20:07:08 <lambdabot> Saizan's karma raised to 3.
20:07:17 <Saizan> yay
20:07:58 <olivierp> Saizan: hence the oops. With the constructors it works (gives the right output) but also overflows the stack, I must be doing something horribly inefficient
20:12:15 <Saizan> olivierp: stack overflows are usually caused either by strict non-tail recursion or tail-recusion with a lazy accumulator
20:12:35 <Saizan> @wiki Stack overflow
20:12:35 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
20:13:38 <Saizan> the primary example of the latter is foldl and that's why we've foldl', but you get the same effect with equivalent explicit recursion
20:18:17 <brad_larsen> quick TH question:  is it possible to define a function doubledyn, that does a double dynamic lookup?
20:19:30 <brad_larsen> so if we have foo = "value of foo", bar = "foo", and baz = "bar", $(doubledyn baz) === "value of foo"
20:19:30 <brad_larsen> ?
20:20:08 <brad_larsen> i tried for a while, but get staging errors with all my attempts.  so i'm wondering if it's not possible to define
20:25:36 <SamB> brad_larsen: you can't use values in splices in the module that defines them
20:25:49 <SamB> unless they are defined inside those splices
20:39:25 <brad_larsen> SamB, I don't think that's my problem
20:40:02 <SamB> brad_larsen: there *is* no staging support in GHC's TH implementation
20:40:25 <brad_larsen> ghci gives me errors about a stage restriction
20:40:27 <brad_larsen> that's what i mean
20:41:26 <SamB> which means that you can't call functions defined in the same module from a splice
20:42:01 <brad_larsen> in one module I have the following def
20:42:17 <brad_larsen> doubledyn s = dyn $(dyn s)
20:42:25 <brad_larsen> in a separate module, I have
20:42:36 <brad_larsen> foo = 5
20:42:38 <brad_larsen> bar = "foo"
20:42:41 <brad_larsen> baz = "bar"
20:42:48 <brad_larsen> main = print $(doubledyn baz)
20:43:06 <SamB> the baz in the splice counts as a call
20:44:15 <brad_larsen> hmm
20:45:57 --- mode: irc.freenode.net set +o ChanServ
20:48:09 <pumpkin> has anyone here used language-c to generate c? I just want to output a list of function prototypes but the AST I need to throw together is proving more complex than I thought
21:00:59 <pumpkin> yay for data.derive
21:02:49 <pumpkin> wow, this NodeInfo stuff makes it look like they don't really intend for Language.C to be used for generating c
21:03:47 <pumpkin> yay it's mmorrow
21:03:57 <mmorrow> hullo
21:03:58 <lambdabot> mmorrow: You have 3 new messages. '/msg lambdabot @messages' to read them.
21:04:48 * mmorrow loves getting the same messages for the third time :)
21:04:56 <pumpkin> :o
21:06:18 <mmorrow> i wonder what the chain of events is that causes these weird state replays
21:07:07 <mmorrow> i just tried to to think of a likely case, but i haven't a clue
21:08:00 <dolio> Only the third?
21:08:44 <dolio> There's one message I've been sent probably 6 or 7 times.
21:08:47 <dolio> From multiple bots.
21:21:11 <mmorrow> the bots are conspiring
21:23:09 <mmorrow> dolio: apparently there's a `lazysml : bool ref' in SMLofNJ.Control
21:23:25 * pumpkin is making an awesome tool
21:23:37 <mmorrow> oh rly?
21:23:48 <dolio> How awesome?
21:24:59 <pumpkin> really awesome!
21:25:10 <dolio> Oh shit!
21:25:19 <pumpkin> but I wish there were an arm disassembler out there for harpy :P
21:25:27 <mmorrow> oh snap
21:25:37 <mmorrow> i guess you have to write one!
21:26:09 <pumpkin> eventually
21:26:15 <pumpkin> for now I'll settle with intel
21:26:32 <mmorrow> so what is the tool?
21:27:25 <pumpkin> given a binary (presumably undocumented, written in c) library, it'll dump a basic header for it
21:29:08 <mmorrow> oh sweet. this might be handy too http://www.cs.york.ac.uk/fp/darcs/ELF
21:29:26 <mmorrow> err, i guess it's probably not elf though (?)
21:29:44 <pumpkin> eventually I'll make it format-agnostic, but for now I'm working on mach-o because I know it pretty well (and erikc has his module for it up on hackage)
21:29:53 <pumpkin> but I think he made one for elf too
21:30:12 <mmorrow> yeah, a dwarf one too
21:30:21 <pumpkin> and I think he was working on PE too
21:30:26 <pumpkin> not sure if he finished it though
21:31:58 <mmorrow> the elf one though is missing a few items, and coincidently and other elf lib is missing almost exactly the opposite (wrt executable or library - relevant pieces) pieces :/
21:32:36 <pumpkin> :o
21:32:47 <pumpkin> you should fill in the missing bits :) I had to fill in a few for macho
21:32:59 <mmorrow> unfortunately though i think merging them would still some up short by a thingy or two
21:33:00 <pumpkin> (I also use mach-o because it makes me feel manlier)
21:33:12 <mmorrow> pumpkin: i want to definitely. it's on my list
21:33:20 <mmorrow> pumpkin: heh
21:34:07 <pumpkin> > filter (< 5) [1..10]
21:34:09 <lambdabot>   [1,2,3,4]
21:35:45 <pumpkin> eww, harpy doesn't work on ByteStrings
21:36:24 <pumpkin> ah, I can unpack it
21:39:57 <pumpkin> can I get a Ptr Word8 for a given ByteString?
21:40:42 <pumpkin> oh actually nevermind
21:40:56 <dolio> You should be able to.
21:41:19 <dolio> You might have to import the Internals module.
21:41:25 <dolio> Or whatever it's called.
21:41:35 <pumpkin> turns out harpy's just converting the ptr word8 to a list anyway
21:41:42 <pumpkin> so I can do it myself :P
21:43:41 <pumpkin> is harpy not lazy?
21:43:51 <pumpkin> in disassembling
21:44:09 <pumpkin> oh I guess it can't be with that type
21:44:19 <pumpkin> that's annoying
21:45:50 <pumpkin> the issue is that I have to look at the instructions to determine where to stop, and the buffer doesn't contain only instructions
21:45:59 <pumpkin> but it tries to parse the entire thing as instructions :/
21:48:16 <pumpkin> anyone have any suggestions? do I just have to edit their export list and get at the lower-level interface?
21:48:42 <mmorrow> pumpkin: i'd say that's the least you'll have to end up doing
21:48:49 <pumpkin> :P
21:49:12 <mmorrow> it shouldn't be that painful though :)
21:49:16 <pumpkin> once I have the assembly I know what to do
21:49:28 <pumpkin> or can apply heuristics at least :P
21:49:37 <pumpkin> mmorrow: I agree :) harpy needs to be lazier!
21:49:57 <mmorrow> nice! put on your hacking mittens!
21:50:05 <mmorrow> err, i mean shoes!
21:50:09 <pumpkin> lol
21:50:13 <pumpkin> I never take them off!
21:51:58 * pumpkin iz epic hax0r
21:55:45 <pumpkin> wow, harpy runs on parsec
21:55:57 <pumpkin> sounds like a job for attoparsec to me, or data.binary
21:57:19 <ozy`> this strikes even me as a dumb question, but what's the smallest, most portable device you guys would use for (brief stints of) writing code?
21:57:30 <ozy`> also cheap.
21:57:59 <jrockway> ozy`: i use an eeepc901 regularly
21:58:11 <jrockway> the keyboard is junk, but i connect my happy hacking keyboard to it and all is well
21:58:16 <jrockway> it is fast enough, and the screen is great
21:58:27 <pumpkin> ozy`: I use a macbook air :P
21:58:35 <jrockway> i have written some real code without the hh keyboard though
21:58:42 <jrockway> it is possible, but you need to be really motivated :)
21:58:51 <jrockway> (for me, it was writing the slide software for my talk the next day :)
21:58:56 <pumpkin> I know someone who insists he writes code on his iphone
21:58:58 <pumpkin> but I don't believe him
21:59:01 <ozy`> an eeepc is at once too big to type on with my thumbs, and too small to type on with my hands
21:59:13 <ozy`> a full-size laptop like a macbook is... too big, period
21:59:17 <jrockway> yeah
21:59:22 <jrockway> so get the happy hacking keyboard :)
21:59:26 <ozy`> iphones are too small
21:59:28 <jrockway> it is small, light, and a wonderfu lkeyboard
21:59:31 <ozy`> no, that would defeat the point
21:59:58 <ozy`> (I should have said: iphones' small size and keyboard layout makes punctuation impossible to use)
22:00:19 <jrockway> well, unless there is some device that warps the space-time continuum, you are kind of stuck, right?
22:00:31 <jrockway> if the eeepc is too small (keyboard-wise), and you can't carry another keyboard
22:01:11 <ozy`> the eeepc is too small to type on like I'd type on a full-sized keyboard.... however, if it were smaller still, with the same layout, I could just use my thumbs
22:01:22 <jrockway> ahh, i see
22:01:53 <jrockway> the 10" eee (and similar netbooks) have a "full-sized" keyboard
22:02:05 <jrockway> there is also the thinkpad x series
22:02:16 <jrockway> i have tried coding on my mobile phone -- doesn't work for me
22:02:16 <ozy`> I haven't seen those in stores... not sure I'd want one anyway (10" eeepcs I mean)
22:02:28 <pumpkin> @hoogle defaultState
22:02:28 <jrockway> yeah, i don't really like them either
22:02:28 <lambdabot> No results found
22:02:46 <ozy`> well phones are made to be as small as possible with no regard for people who need punctuation
22:03:10 <jrockway> i have a phone where the keyboard is under the screen... it does have punctuation
22:03:18 <jrockway> but it doesn't have a good text editor or language runtime :)
22:03:27 <jrockway> i can't use emacs over ssh because there is no control key
22:03:36 <jrockway> (not a problem if you are an ed user, perhaps)
22:03:41 <ozy`> heh
22:04:04 <ozy`> (I'm a vim user... I'd need an escape key but a control key would not be absolutely vital)
22:04:17 <jrockway> you, you could get by
22:04:29 <jrockway> the latency (for me) is bad though, so you might want line-buffering on the client side
22:04:33 <jrockway> and that means you are stuck with ed :)
22:04:59 <ztirf_> hey is anyone here good with GreenCard?
22:05:27 <ztirf_> I have a bunch of functions that are all doing the same kind of array marshaling
22:05:44 <ztirf_> so I'd like to try to automate that a bit
22:07:20 <ztirf_> the interface is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1387#a1387
22:08:49 <pumpkin> boo
22:09:30 <pumpkin> fail
22:11:25 * wli actually uses ed now and then.
22:11:38 * wli attempts to figure out how to subtract.
22:16:49 <jrockway> btw, are there any libraries to abstract away some of the tedium of reading JSON-formatted messages from a socket?
22:17:00 <jrockway> right now i am having my server add newlines after each JSON message, so i can use LineBuffering
22:17:15 <jrockway> but that is a hack I would like to see go away (and I don't feel like writing an incremental JSON parser)
22:19:34 <Asztal> you could just count braces to find where it ends and then use a real JSON parser
22:20:26 <Asztal> but I guess you'd have to parse strings and thus string escapes too then
22:20:36 <jrockway> yup, that's what I was thinking
22:22:33 * wli is failing to figure out how to subtract.
22:23:28 <jrockway> wli: like "a - b"?
22:23:33 <mjrosenb> parsing escapes is generally not that difficult
22:23:43 <mjrosenb> assuming that the escaping rules aren't insane
22:23:54 <wli> jrockway: Yeah, for a potentially infinite list of digits of type Word32
22:24:07 <jrockway> wli: ah, ok
22:24:19 <mjrosenb> wli: associating to the right, or the left?
22:24:43 <jrockway> it seems like the JSON parser should be able to read from the stream until there is a successful parse, and then call a callback with the parsed data
22:24:48 <jrockway> the JSON library confuses me though
22:24:53 <wli> mjrosenb: Not sure what you mean.
22:24:55 <jrockway> so much code for what seems to be a simple concept
22:25:12 <mjrosenb> wli: a - b - c is it (a-b) -c or is it a - (b - c)
22:25:30 <mjrosenb> or in your case subtract [a,b,c]
22:25:45 <wli> mjrosenb: I don't really care. I could write it as subtract x y or some such.
22:26:07 <wli> mjrosenb: I'm only considering 2 operands at the moment.
22:26:50 <mjrosenb> wli: what operations are you letting yourself use?
22:27:17 <wli> Well, I have a sign-and-magnitude affair.
22:27:40 <mjrosenb> those are never fun.
22:27:54 <wli> data ArbFloat = ArbFloat { exponentAF :: Integer, mantissaAF :: (Word32, Word32), signAF :: Bool }
22:27:57 * mjrosenb highly recommends two's compliment
22:28:04 <wli> ergh
22:28:23 <wli> data ArbFloat = ArbFloat { exponentAF :: Integer, mantissaAF :: (Word32, [Word32]), signAF :: Bool } | AFNaN | AFInfinity
22:28:47 <wli> mjrosenb: How am I supposed to have an infinite number of digits with 2's complement?
22:29:01 <int-e> wli: what's the extra Word32 in the mantissa?
22:29:32 <mjrosenb> presumably a non-empty list
22:29:36 <wli> int-e: Nonempty lists are newtype NEL t = NEL (t, [t]); basically just [Word32] required to be nonempty.
22:30:48 <mjrosenb> wli: if you ever have an *infinite* list, then you have other issues
22:30:49 <int-e> wli: ok. if the list can be infinite then you have a problem - to figure out the sign, you have to compare the two numbers, which may not terminate. And you pretty much need to know the sign before you can generate any digits of the result.
22:31:12 <mjrosenb> but arbitrarialy large lists shouldn't pose a problem
22:31:43 <jberryman> do any Vim users use this script, "Shim": http://www.vim.org/scripts/script.php?script_id=2356 ?
22:31:49 <int-e> right
22:32:10 <Zao> jberryman: Looks handy.
22:32:14 <mjrosenb> well if the first element of the list is the most signifigant word, then comparing is a piece of cake
22:32:45 <pumpkin> either I fail or harpy fails
22:32:49 <mjrosenb> *assuming* that there's some finite term that is not equal between the two of them
22:33:16 <pumpkin> anyone here happen to know how to disassemble in their head?
22:33:17 <wli> I don't really know if they'll ever be infinite. I guess that I have to assume it can be.
22:33:26 <wli> The Num API may be wrong for it.
22:33:29 <pumpkin> disassemble intel that is
22:33:44 * mjrosenb is cureently failing at architecting a test suite
22:34:14 <wli> I may have to do sign-and-magnitude on a per-digit basis or something.
22:35:22 <mjrosenb> wli: wait, why does two's compliment not work?
22:35:44 <wli> mjrosenb: They're never fixed width.
22:36:23 <wli> mjrosenb: Second off, differing positive and negative bounds can't be tolerated.
22:36:45 <mjrosenb> wli: the mantissaAF is supposed to represent a decimal expansion, or just a large number?
22:37:10 <wli> mjrosenb: A radix 2^32 expansion.
22:37:45 <mjrosenb> wli: how would you give a floating point approximation of your ArbFloat
22:38:17 <mjrosenb> also, since you're already using an Integer, why not just use two of them?
22:38:47 <wli> 2**(32*exponentAF x) * ((fst $ mantissaAF x) + sum [2**(-32*k) * mantissaAF x ! k | k <- [0 ..]]
22:39:02 <wli> ergh
22:39:13 <wli> 2**(32*exponentAF x) * ((fst $ mantissaAF x) + sum [2**(-32*k) * snd (mantissaAF x) ! k | k <- [0 ..]])
22:40:59 <wli> mjrosen: In cases where cancellation is catastrophic, testing for sign/zero only up to some tolerance needs to be supported.
22:41:01 <pumpkin> whee, harpy works
22:42:12 <pumpkin> I have now determined that the first instruction of almost all the functions I'm looking at is push ebp surprise surprise :P
22:43:17 <wli> mrosenb: Essentially the things need to be denormalized most of the time and things trying to peek into the results can only ask for and/or get results within some tolerance.
22:43:51 <int-e> pumpkin: let me guess, the last byte is C3? :)
22:43:59 <mjrosenb> wli: i see.
22:45:26 <pumpkin> int-e: it's hard to determine "last byte" at this point :P
22:45:32 <pumpkin> I'll have that eventually
22:46:06 <wli> It may be that I need to pass the tolerance all the way down.
22:46:26 <pumpkin> int-e: but yeah, I'd be willing to bet that most functions will end in that :P
22:47:11 <mjrosenb> pumpkin: tail call elimination?
22:47:20 <wli> Integer for a mantissa also precludes infinite digit strings.
22:47:30 <pumpkin> mjrosenb: that was one of the sources of "most" :)
22:47:32 <int-e> yes, most, but not all.
22:51:38 <sm> evening all
22:51:50 <pumpkin> now I need to adapt harpy to deal with incremental decoding
22:52:15 <sm> on gnu/linux, is there a good system tool to check if your ghc threads (started with forkIO) are still running ?
22:52:31 <sm> I think I tried with top/htop and could not see them
22:53:15 <mjrosenb> sm: process accounting?
22:53:44 <sm> mjrosenb: I'm not sure how to do that.. is there a command ?
22:54:28 <jeffz`> sm, In GHC, threads created by forkIO are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.
22:54:42 <pstickne> within the limits of the threads...
22:54:59 <jdavis> Is it possible to make mutually recursive types? like "data PlusExpr = Plus Expr Expr" and "data MinusExpr = Minus Expr Expr" and "data Expr = PlusExpr | MinusExpr | Integer"?
22:55:02 <sm> I see, that's what I figured. So switching to forkOS probably isn't the right thing
22:55:20 <jdavis> I was able to define it, but it's not doing exactly what I expect.
22:55:21 <jeffz`> sm, quote from Control.Concurrent docs
22:55:21 <roconnor> jdavis: yes
22:55:37 <sm> I'm running some long-lived rss2irc bots, and I think a thread is dying after a while
22:55:56 <roconnor> jdavis: data Expr = PlusExpr PlusExpr | MinusExpr MinusExpr | Integer
22:56:28 <jdavis> roconnor: Can you explain?
22:56:50 <roconnor> jdavis: you need to give a constructor name for each case
22:56:52 <roconnor> then the type
22:56:57 <sm> I guess there's no linux tool that can show this then.. only ghc knows
22:57:10 <mjrosenb> jdavis: you're just declaring a constructor that doesn't wrap anything
22:57:19 <jeffz`> sm, I guess you could get each thread to tell you that they're still alive.
22:57:20 <roconnor> PlusExpr {- <- constructor name -} PlusExpr {- <- type -}
22:57:26 <mjrosenb> jdavis: it's like saying data Expr = A | B | C
22:57:34 <sm> yes, some kind of heartbeat seems called for
22:57:44 <mjrosenb> is there any documentation on how to use the state monad?
22:57:47 <sm> or exception catching
22:58:17 <jdavis> mjrosenb, roconnor : Ok, I think I'm getting a little confused between type constructors and value constructors. I will do some more experimentation. Thanks!
22:58:53 <roconnor> jdavis: nothing here is a type constructor
22:59:16 <roconnor> jdavis: It's just that the syntax for data is very confusing
22:59:32 <jdavis> roconnor: what's the difference between a type and a type constructor?
23:00:08 <roconnor> jdavis: Maybe is a type constructor
23:00:11 <jdavis> roconnor: is there a document that clears up the syntax for "data" a little more precisely? I'm just reading through tutorials.
23:00:18 <roconnor> :kind Maybe
23:00:24 <roconnor> @kind Maybe
23:00:26 <lambdabot> * -> *
23:00:27 <roconnor> @kind Int
23:00:29 <lambdabot> *
23:01:01 <roconnor> what's the usual reference on the syntax for data?
23:01:03 <ztirf__> arrrrrrgh does anyone have greencard working?
23:01:07 <roconnor> a chapter in the wiki book?
23:01:22 * wli tries to remember how to do things with signed digits and runs into trouble.
23:02:09 <jdavis> Ok, I'll check out the wikibook.
23:02:35 <pumpkin> in parsec (2.1) how can I apply a predicate to a parser?
23:03:32 <jdavis> roconnor: Is there a possible problem with using the same name for the value constructor and the type?
23:04:09 <roconnor> no, they are always in different contexts
23:04:22 <roconnor> but it does make it confusing for beginners
23:04:23 <wli> Do the signed digits need to be of magnitude at most half the radix or of magnitude up  to the radix?
23:04:28 <mjrosenb> jdavis: ok, try this.
23:04:37 <mjrosenb> jdavis: :t Minus
23:04:50 <mjrosenb> jdavis: :t PlusExpr
23:05:14 <mjrosenb> jdavis: note that Minus is expecting to recieve two expressions
23:05:32 <mjrosenb> jdavis: whereas PlusExpr is expecting to recieve nothing.  it's already a value
23:05:55 <jdavis> mjrosenb: Ok, I think I'm starting to understand.
23:07:02 <wli> I can't remember if you get a unique zero from half the radix or what.
23:07:54 <roconnor> wli over half the radix more is adequate
23:08:12 <roconnor> wli: as long as the number of digits is greater than the radix
23:08:13 <wli> Okay, might as well be the whole radix at that point.
23:09:25 <pumpkin> is there an easy way to make a GenParser check what it consumes against a predicate so that it'll fail if the predicate returns false?
23:11:08 <byorgey> @type satisfy
23:11:10 <lambdabot> Not in scope: `satisfy'
23:11:33 <pumpkin> satisfy :: (Char -> Bool) -> CharParser st Char	Source
23:11:33 <pumpkin>  ?
23:11:47 <byorgey> ah, yeah, I guess that's not what you're looking for, huh
23:12:07 <pumpkin> not really :/
23:12:18 <jdavis> mjrosenb, roconnor : thanks guys, it's working for my more complex problem.
23:12:27 <byorgey> pumpkin: can't you just use 'guard'?
23:12:40 <pumpkin> oh, didn't think of that
23:12:45 <byorgey> do { x <- parseFoo ; guard (predicate x) }
23:12:54 <pumpkin> yeah :P thanks :)
23:12:57 <byorgey> sure =)
23:15:14 <pumpkin> hrm
23:15:52 <pumpkin> if in an export list, you don't write (..) next to a type, does that mean you aren't exporting all its constructors?
23:16:59 <pumpkin> I guess so
23:19:59 <wli> roconnor: I'm thinking assembly-like syntax for arithmetic ops under a reader monad for the number of digits needed.
23:20:27 <wli> roconnor: Or otherwise a reader monad for some sort of tolerance. Total violence to the usual API assumed for numbers.
23:21:30 <wli> roconnor: I don't entirely understand how the tolerance should be specified. Should it be relative or absolute or some combination of both or what?
23:21:43 <pumpkin> hmm, manyTill in parsec isn't doing what I expect
23:22:41 <wli> roconnor: I'm also unsure what kind of number the tolerance should be. I think letting it be an arbitrary-precision float could be problematic.
23:23:56 <wli> Possibly a combination of a reader monad and an error monad for various kinds of floating point errors.
23:24:57 <wli> I'm convinced scrapping the Num API is necessary.
23:25:14 <jdavis> how does :type work? is there a way to get the type at runtime?
23:25:25 <jdavis> from within the program?
23:26:23 <pumpkin> no
23:26:24 <pumpkin> well
23:26:36 <pumpkin> basically no
23:26:47 <jdavis> oh, ok
23:29:05 <sm> oh cool, you can just printf in IO
23:31:08 <pumpkin> hmm, my manyTill never seems to call the "till" bit
23:31:46 <pumpkin> oh, I had it backwards :P
23:33:02 <pumpkin> byorgey: using guard seems to cause parsec to spit out "unknown parse error" when the guard condition fails :/
23:37:34 <mjrosenb> is there any reason that _ <- foo is valid
23:37:38 <mjrosenb> but foo isn't
23:37:41 <mjrosenb> ?
23:40:09 <pumpkin> bah, this is making no sense :/
23:42:25 <hackage> Uploaded to hackage: darcs 2.2.1
23:47:42 <sm> nice hackage bot, I haven't seen it work before - new ?
23:47:56 * wli can't figure out how to carry digits even with the digits signed of magnitude up to radix - 1.
23:48:26 <pumpkin> is there a "monadic if"?
23:48:35 <sm> when ?
23:48:55 <pumpkin> that does two different things depending on whether it's true or false
23:49:09 <pumpkin> the predicate
23:49:18 <pumpkin> *condition
23:49:19 <sm> yes but I forget where
23:49:30 <pumpkin> @hoogle ifM
23:49:30 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
23:49:30 <lambdabot> Distribution.Simple.Utils createDirectoryIfMissingVerbose :: Verbosity -> Bool -> FilePath -> IO ()
23:49:30 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
23:49:35 <pumpkin> :P
23:51:35 <ski_> mjrosenb : valid where ?
23:58:20 <wli> addAF, subAF, mulAF, divAF, sgnAF, absAF, logAF, expAF :: (MonadReader Tolerance m, MonadError AFError m) => ArbFloat -> ArbFloat -> m ArbFloat
23:58:30 <wli> hmm, woops
