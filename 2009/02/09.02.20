00:23:08 <kohwj> is there any best practices regarding function name ambiguity in haskell? i've seen lots of code that import modules with long names and don't use those names, perhaps to save space.
00:24:13 <mmorrow> what do you mean "don't use those names"?
00:24:40 <kohwj> for instance, "sort" is easier to type than "Data.List.sort". but what if the name of the function in question doesn't convey as much meaning as the name of the module plus the function name?
00:24:42 <pumpkin_> qualified imports?
00:24:51 <kohwj> yes, i can use qualified imports, but
00:25:07 <kohwj> they aren't standard. "Data.List" could be "dl" or "list"
00:25:10 <mmorrow> ohh. yeah, you can choose the label you want to use for qualified imports
00:25:28 <pumpkin_> kohwj: but because imports are forced to be at the top of a file
00:25:30 <mmorrow> well, it would have to be Dl, DL, or List
00:25:33 <mmorrow> or L, etd
00:25:35 <pumpkin_> finding out what mapping the developer used isn't hard
00:25:35 <mmorrow> *etc
00:25:39 <ivanm> mmorrow: no it wouldn't
00:25:58 <mmorrow> ivanm: ? you can't say import qualified Data.List as list
00:26:01 <ivanm> import qualified Data.List as ChoosingThisNameJustToProveMMorrowWrong
00:26:02 <ivanm> ;-)
00:26:07 <pumpkin_> lol
00:26:28 * mmorrow doesn't know how he was wrong
00:26:37 <ivanm> kohwj: why particularly do you care about this?
00:26:43 <mmorrow> but aaaanyways :)
00:26:47 <ivanm> mmorrow: you said "it would have to be Dl, DL or List" ...
00:26:57 <ivanm> and I was demonstrating that it doesn't _have_ to be one of those
00:26:59 <mmorrow> yeah, ie it can't start with a lower case letter
00:27:07 <mmorrow> oh
00:27:08 <kohwj> ivanm, mmorrow: qualified imports are a great idea, but wouldn't some sensible standardisation on those shorthand names be useful to make code from different developers more clear?
00:27:08 <ivanm> well, that's a different story ;-)
00:27:12 <Zao> There's some more popular than others though, like Map/M, Set/S.
00:27:35 <ivanm> kohwj: I don't think so... qualifications are normally for "dodgy" packages such as Data.Map, etc. AFAIK
00:27:49 <ivanm> and it's usually not that hard to work out...
00:27:53 <Zao> I suppose ByteString falls into that category as well.
00:28:00 <ivanm> yeah
00:28:04 <Zao> Only bothersome bit there is finding out which variant the author used.
00:28:17 <ivanm> Zao: well, that's just performance semantics usually, isn't it?
00:28:26 <ivanm> since don't they have the same (or at least similar) APIs?
00:28:28 <mmorrow> kohwj: they're variable names, like let x = 4 in x * 2
00:28:28 <mmorrow> and visible only within a module
00:28:39 <mmorrow> i think they give the _freedom_ to choose a convention should you see fit, but they don't force one on you
00:28:53 <ivanm> let Map = Data.Map in M.map ?
00:28:54 <ivanm> ;-)
00:29:01 <Zao> What if I import a module that has imported say lazy bytestrings unqualified.
00:29:11 <Zao> Wouldn't that leak into me unless they have an explicit export list?
00:29:16 <ivanm> Zao: well, that only matters if they re-export it
00:29:31 <ivanm> which is stupid... you should usually never re-export modules that aren't from the same library
00:30:02 <Axman6> hmm, i'd quite like a nice darcs tutorial, that didn't try and show me how simple darcs is by skimping on the information
00:31:00 <mmorrow> kohmj: haskell's module system could definitely be better, though (imho)
00:31:04 <mmorrow> also, you can alias multiple modules to a single name
00:31:22 <ivanm> Axman6: "darcs help"
00:31:23 <ivanm> ;-)
00:31:31 <ivanm> mmorrow: in what ways?
00:31:38 <mmorrow> import qualified Foo.Hai as X  \n   import qualified Forty.Alphabets as X  ...
00:31:49 <ivanm> I think _forcing_ module -> filename would probably be a good idea
00:31:49 <kohwj> ivanm: maybe i'm a little too particular about it, but with multiple people working on the same code, there could be different qualified names across multiple files, leading to some confusion
00:31:53 <mmorrow> then X.foo could be in either module
00:32:02 <Zao> Can you use unicode letters in module names?
00:32:03 <ivanm> mmorrow: oh? ghc, etc. doesn't stop that?
00:32:16 <mmorrow> ivanm: no, in fact it's a feature! :)
00:32:17 <pumpkin_> nope
00:32:25 <pumpkin_> I've seen people use that on purpose
00:32:27 <mmorrow> (i'm serious when i say it's a feature)
00:32:32 <mmorrow> i use it on purpose :)
00:32:36 <ivanm> kohwj: *nod*, though that sounds like you need to implement coding practices for the project rather than hope haskell can do it for you ;-)
00:32:43 <ivanm> mmorrow: in what way?
00:32:45 <ivanm> and why?
00:33:22 <mmorrow> import qualified Data.ByteString as B   .... import qualified Data.ByteString.Internal as B .... import qualified Data.ByteString.Unsafe as B
00:33:31 <ivanm> ahhhhh......
00:33:43 <mmorrow> i like it for that
00:33:43 * ivanm didn't realise this was possible....
00:33:53 <mmorrow> i just realized it maybe two months ago
00:33:58 <ivanm> dammit, that means some of the assumptions I did for my code parsing for SourceGraph invalid! :@
00:34:07 <mmorrow> heh
00:34:23 <ivanm> it's hard enough matching functions to modules without _this_ thrown in :@
00:34:36 <mmorrow> heh. just parse the import list..
00:34:46 <ivanm> then again, from memory it mightn't be that much of a problem...
00:34:59 <ivanm> mmorrow: well, if you import the whole module it isn't that easy
00:35:27 <kohwj> ivanm: i see... thanks :)
00:35:31 <ivanm> though IIRC, what I did was create a list of all functions imported from that module (by reading the export list), and possibly tagging them if they were imported with an alias
00:35:41 <ivanm> kohwj: what, didn't you think of that? :o
00:35:48 <ivanm> or are you being sarcastic? >_>
00:36:16 <mmorrow> ivanm: well, you'd need to know where functions come from too..
00:36:39 <ivanm> mmorrow: yeah... I use Tying the Knot to parse all modules at the same time
00:36:49 <ivanm> so it only works for modules in the same project
00:36:50 <kohwj> ivanm: well, i just thought that some global standards could be set.
00:36:50 <mmorrow> what's Tying the Know?
00:36:54 <mmorrow> *Knot
00:37:00 <ivanm> @where TyingTheKnot
00:37:00 <lambdabot> I know nothing about tyingtheknot.
00:37:05 <ivanm> @go Tying The Knot
00:37:06 <lambdabot> http://www.tyingtheknot.net/
00:37:07 <lambdabot> Title: BEBB | Studios
00:37:10 <ivanm> that's not it ;-)
00:37:18 * ivanm finds it manually
00:38:00 <mmorrow> http://haskell.org/haskellwiki/Tying_the_Knot  ?
00:38:46 <ivanm> yeah....
00:38:48 <mmorrow> if that's it, i'm not positive how it's related, especially since module dep graphs are acyclic... but i'd love to hear how
00:38:52 <ivanm> though it's blank here for me :s
00:39:03 <ivanm> mmorrow: the code is online, and so is my thesis I did it for ;-)
00:39:11 <mmorrow> i'll check it out
00:39:15 <Axman6> when you export a type, but not its constructors, people using the code can't see what's inside that datatype right?
00:39:19 <ivanm> mmorrow: is that page blank for you?
00:39:25 <mmorrow> no
00:39:28 <mmorrow> http://haskell.org/wikisnapshot/TyingTheKnot.html
00:39:32 <mmorrow> can you see that?
00:40:00 <ivanm> ahhhh, the search gave me Tying_the_knot
00:40:06 <ivanm> lack of capitilisation :s
00:40:19 <mmorrow> where's your thesis, i'd love to check it out :)
00:40:36 <ivanm> ivanmiljenovic.wordpress.com
00:40:36 <mmorrow> (i'm assuming we're talking about http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Graphalyze)
00:40:41 <mmorrow> cool
00:40:43 <ivanm> mmorrow: that and SourceGraph
00:40:52 <mmorrow> ahh
00:40:53 <ivanm> SourceGraph is what has the actual module parsing stuff
00:41:27 <mmorrow> cool, i haven't seen SourceGraph before
00:41:31 * ivanm is annoyed that he spent all that time and effort providing well-documented code samples in his thesis, and his supervisor just ignored them :@
00:41:55 <ivanm> mmorrow: yeah, I'm about to start updating it (/me has been lazy over summer) as soon as matthew-_ approves my new graphviz changes so I'm sure of the API
00:42:07 <mmorrow> nice
00:42:39 <mmorrow> Axman6: right
00:42:47 <Axman6> ta
00:42:56 <hackage> Uploaded to hackage: AVar 0.0.3
00:43:18 <Axman6> oh, that's mine :)
00:43:39 <ivanm> AVar? what is it?
00:43:59 <pumpkin_> fancy stuff
00:44:08 <Axman6> funky amazing magic
00:44:10 <Axman6> >_>
00:44:11 <pumpkin_> CRAZY concurrency
00:44:29 <Axman6> CRAZY!
00:44:30 <kohwj> hm..
00:44:34 <Saizan_> ?yow
00:44:35 <lambdabot> HOORAY, Ronald!!  Now YOU can marry LINDA RONSTADT too!!
00:44:41 <Saizan_> that CRAZY?
00:44:48 <kohwj> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AVar "Mutable variables with Exception handling and concurrency support"
00:44:52 <ivanm> Axman6: CRAZY, as in the godfrey's ads? ;-)
00:45:02 <Axman6> ha
00:45:03 <mmorrow> ivanm: (re: your thesis) very cool, i look forward to reading it :)
00:45:06 <ivanm> \o/
00:45:09 <ivanm> that's one! :p
00:45:18 <Axman6> @hackage AVar
00:45:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AVar
00:46:17 <ivanm> mmorrow: as part of honours here, we have to do a 10-15 min discussion a week after submission with supervisor, second reader and honours supervisor... instead of asking me about what I did, we spent most of the time working out what C's longjump/setjump would look like in a graph ;-)
00:46:59 <mmorrow> ivanm: the graphviz program "tred" (well, the algorithm, however it's applied) does wonders for readability of large graphviz-rendered graphs
00:47:16 <mmorrow> ivanm: heh
00:47:17 <ivanm> oh? somehow missed that one :s
00:47:32 <mmorrow> it's super nice
00:47:39 <mmorrow> i use it always now
00:47:45 <ivanm> mmorrow: ahhh, it removes transitives... which isn't really want I wanted
00:47:53 <ivanm> since I _want_ to show all edges that are meant to be there
00:48:06 <mmorrow> but it still retains all info
00:48:45 <mmorrow> (it isn't unique in the case of cyclic graphs, but it still captures the info)
00:48:49 <pumpkin_> @pl \x -> (x - radius, x + radius)
00:48:49 <lambdabot> ap ((,) . subtract radius) (radius +)
00:48:52 <pumpkin_> ew
00:48:54 <ivanm> well, if foobar calls foo and bar, then you'd want to see that despite foo also calling bar :s
00:49:16 <mmorrow> sure, depending on what you're trying to convey
00:49:55 <mmorrow> but try it on a huge jumbled graph, and look at the huge decrease in rats-nest-ness
00:50:13 <ivanm> mmorrow: *nod*
00:50:53 <quicksilver> ewww.. the call graph of my program has a rat living in it!
00:50:56 <ivanm> @tell matthew-_ mmorrow just told me about graphviz' tred command... maybe we should consider adding that as a DotGraph -> IO DotGraph function?
00:50:56 <lambdabot> Consider it noted.
00:51:02 <ivanm> quicksilver: heh
00:51:10 <mmorrow> quicksilver: you know it!
00:51:42 <jkff> @seen ski_
00:51:42 <lambdabot> ski_ is in #haskell.se, #haskell, ##logic, #haskell-in-depth and #haskell.hr. I last heard ski_ speak 1d 9h 46m 31s ago.
00:51:47 <mmorrow> ivanm: yeah, i've been meaning to implem it in haskell for a while now
00:52:15 <ivanm> mmorrow: I don't mean implement in haskell, I mean calling the graphviz one ;-)
00:52:21 <ivanm> though I've got a few similar functions in Graphalyze
00:52:27 * ivanm -> dinner
00:52:31 <mmorrow> heh, but it wouldn't be too hard i don't think
00:58:19 <pumpkin_> Axman6: you need a test suite!
00:58:28 <cepera> hi all! I am a newbie in a haskell. What practical fields can I use it?
00:58:30 <pumpkin_> you would've noticed the no export issue in that case :)
00:58:39 <Axman6> cepera: all of them
00:58:45 <pumpkin_> cepera: it's a programming language, you can use it for anything possible to program ;)
00:58:48 <Axman6> yeah, probably
00:59:06 <cepera> hm. I can not write drivers on haskell))
00:59:22 <pumpkin_> no fundamental reason you can't, really
00:59:25 <Axman6> sure you can
00:59:31 <Axman6> there are kernels written in haskell
00:59:49 <Axman6> L4.verified for example
01:00:13 <cepera> ohh. Its interesting. link pls&
01:00:17 <pumpkin_> http://web.cecs.pdx.edu/~kennyg/house/ also
01:00:39 <pumpkin_> westbaer: oi
01:00:40 <Axman6> http://www.ertos.nicta.com.au/research/l4.verified/
01:00:57 <cepera> tnx
01:00:58 <westbaer> :o pumpkin
01:01:56 <cepera> is haskell a good programming language for AI?
01:02:22 <pumpkin_> cepera: what makes a programming language good for something like that? :)
01:02:24 <NameAlreadyInUse> i'd wager that it is probably better than most for AI
01:02:27 <quicksilver> there are no good programming languages for AI
01:02:32 <quicksilver> in fact, AI doesn't really exist.
01:02:35 <pumpkin_> cepera: I'd say yes, but it's a vague question
01:02:39 <quicksilver> but, haskell is probably better than most of the alternatives.
01:02:54 <Axman6> you could totally write AIs easily in C
01:02:56 <Axman6> >_>
01:03:25 <cizra> Axman6: Generate random C. Eventually you'll hit conscious code.
01:03:34 <Axman6> yup
01:03:48 <NameAlreadyInUse> if conscious code is possible
01:03:53 <cepera> I'm just interesting, should I learn haskell more
01:04:03 <pumpkin_> cepera: you're asking us, obviously we're going to say yes :P
01:04:13 <cepera> :)
01:04:31 <Axman6> of course you should
01:04:41 * pumpkin_ points at Axman6
01:04:43 <pumpkin_> see!
01:05:07 <cizra> cepera: Haskell can convert Pi into a rational number!
01:05:21 <cepera> employer in my country don't know what is haskell)
01:05:40 <Axman6> toRational (pi :: Double)
01:05:41 <NameAlreadyInUse> cepera: that is their loss (:
01:05:43 <Axman6> > toRational (pi :: Double)
01:05:44 <lambdabot>   884279719003555%281474976710656
01:05:51 <pumpkin_> omg
01:05:53 <pumpkin_> awesome
01:05:56 <pumpkin_> haskell++
01:05:58 <Axman6> > 884279719003555 / 281474976710656
01:05:59 <lambdabot>   3.141592653589793
01:06:05 <Axman6> > 884279719003555 / 281474976710656 :: CReal
01:06:07 <lambdabot>   3.1415926535897931159979634685441851615906
01:06:08 <pumpkin_> omg, that's like all of pi!
01:06:11 <cizra> > (pi :: CReal) - (884279719003555 / 281474976710656 :: CReal)
01:06:12 <lambdabot>   0.0000000000000001224646799147353177226066
01:06:12 <Axman6> pi :: CReal
01:06:38 <cizra> That's precise enough for my humble needs.
01:06:57 <cizra> cepera: Show me another programming language that can do this kind of thing in one line...
01:07:59 <cepera> ohh, i dont know
01:08:04 <cepera> :)
01:08:16 <pumpkin_> > scanl1 (+) [1,3..]
01:08:17 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
01:08:20 <pumpkin_> whee
01:08:32 <cepera> what means numbers 884279719003555 and 81474976710656
01:08:33 <cizra> > toRational (exp 1 :: Double)
01:08:35 <lambdabot>   6121026514868073%2251799813685248
01:08:37 <pumpkin_> cizra: APL/J or something :P
01:08:41 <NameAlreadyInUse> cizra: i recall J having inbuilt arbitrary precision arithmetic
01:08:59 <cizra> cepera: They are just numbers that, when divided, produce approximately Pi
01:09:01 <Axman6> but J is fucked up, so it doesn't count
01:09:23 <cizra> pumpkin_: I don't know about J, but I've heard of APL. No thanks.
01:09:30 <pumpkin_> :P
01:09:32 <Axman6> frigging project euler. the j entries all look like 2.[/#$^@.2@@.]3@#%@@$^%^(^
01:09:53 <int-e> cizra:  bc -l <<<'scale=60; a(1)*4 - 884279719003555 / 281474976710656'
01:09:56 <pumpkin_> cizra: it's new and improved!
01:10:04 <Thunder> cizra: Be careful, there are mor powerful languages than Haskell. i.e. Gopher
01:10:14 <Axman6> heh
01:10:32 <pumpkin_> @faq can haskell be more powerful than languages that are more powerful than haskell?
01:10:32 <lambdabot> The answer is: Yes! Haskell can do that.
01:10:45 <pumpkin_> sweet!
01:11:17 <Thunder> pumpkin: But tweaking the compiler is not the standard progamming technology
01:11:29 <cizra> int-e: Hah. Good!
01:11:29 <pumpkin_> ?
01:12:07 <pumpkin_> int-e: is that sleepSort something you came up with, or a well known ridiculous algorithm?
01:12:17 <cizra> Thunder: I've heard good things about some system programming language (forgot the name) designed from ground up to be easily formally provable. Also, very fast.
01:12:44 <int-e> cizra: ATS?
01:13:17 <NameAlreadyInUse> i haven't even looked into ATS
01:13:17 <cizra> int-e: no.. Don't remember. Something with Lispy syntax.
01:13:39 <int-e> pumpkin_: I don't remember - I know that other people have come up with it (no references), but I believe I reinvented it myself, too.
01:13:47 <cizra> Thunder: Wikipedia doesn't know about Gopher
01:13:58 <Thunder> cizra: Proofable correct software for real world projects was demonstrated to successfully written with SPARK.
01:14:24 <quicksilver> not only SPARK.
01:14:26 <int-e> pumpkin_: not that I'd take credit for it ;)
01:14:30 <Thunder> cizra: Gopher is a "predcessor" of Haskell, with all the belts removed.
01:14:48 <quicksilver> there have been a few real world proved things.
01:14:53 <cizra> Thunder: Hmm, OK. That language I was talking about has roots in EROS.
01:15:02 <pumpkin_> :)
01:15:09 <hotaru2k3> cizra: http://en.wikipedia.org/wiki/Gofer_%28software%29
01:15:19 <earthy> E-lang
01:15:25 <Thunder> quicksilver: The other languages I do not know.
01:15:39 <earthy> the capability language.
01:15:56 <inimino> is anybody actually using E?
01:16:19 <earthy> SPARK seems painful
01:16:20 <pejo> Thunder, if it's the language by Mark Jones you're thinking about it's 'Gofer'.
01:16:53 <earthy> otoh, provably correct software development has also been shown using Z
01:17:21 * cizra ponders if it's possible/wise/ethical to teach a newb Haskell as eir first programming language.
01:17:25 <earthy> http://en.wikipedia.org/wiki/Z_notation
01:17:52 * earthy thinks cizra has concepts mixed
01:17:52 <pejo> cizra, plenty of universities have done so.
01:18:23 <earthy> cizra: you don't teach a programming language. you teach programming. the formalism used is of slightly lesser importance
01:18:43 <quicksilver> to some extent that's true
01:18:44 <cizra> earthy: Hmmm. A good point.
01:18:50 <earthy> however, haskell does provide clarity that most procedural languages can not.
01:18:58 <quicksilver> but the practical experience of teaching haskell is many miles apart from the practical experience of teaching java.
01:19:02 <cizra> pejo: How to compare the success, though?
01:19:15 <quicksilver> for example, one of the first things you teach when teach java is that a variable is a box you can put values in.
01:19:21 <quicksilver> (and, change later)
01:19:35 <earthy> quicksilver: that is because the formalism that is java is not clean enough to express all programming concepts clearly
01:19:49 <quicksilver> no it's not.
01:19:53 <earthy> which in turn implies that the exposition necessarily becomes harder to understand.
01:19:54 <pejo> cizra, you'd need a control group for that. I'm not really familiar with how you set up these kind of experiments.
01:19:56 <quicksilver> it's because the formalism is different.
01:20:02 <quicksilver> and some of the differences are profund.
01:20:24 <quicksilver> it's not different because java is ugly; it's different because they are so different.
01:20:29 <quicksilver> (it's true that java is ugly)
01:20:35 <earthy> yes, but the profound differences tend not to be in areas that you need when teaching programming to newbies
01:20:44 <quicksilver> I disagree entirely.
01:20:55 <quicksilver> And I've taught programming at undergraduate and masters levels.
01:21:02 * earthy has as well :)
01:21:19 <earthy> in both Java and Haskell
01:21:32 <ivanm> wtf? I run "ghc-pkg check", and it says that ghc-6.10.1 has missing dependencies! :o
01:21:40 <ivanm> is this because I've just updated cabal?
01:21:51 <ivanm> (note that it doesn't say _which_ dep its missing)
01:22:27 <quicksilver> the existence of a REPL for haskell makes the teaching techniques available pretty different, too.
01:22:46 <earthy> yeah, having a REPL does have a huge impact
01:24:10 <osfameron> though not being able to properly define functions at REPL is still annoying
01:24:15 <earthy> but when teaching newbies programming I'd want them to learn about values, expressions, functions/procedures, paramter passing, loops, recursion and state.
01:24:24 <earthy> osfameron: you can
01:24:33 <earthy> at least in ghci you can
01:24:41 <NameAlreadyInUse> earthy: how?
01:24:43 <osfameron> with multiple patterns?
01:24:47 <earthy> yup
01:24:51 <NameAlreadyInUse> i have been wondering
01:25:32 <earthy> Prelude> let f [] = 1; f (x:xs) = 1 + f xs
01:25:36 <earthy> Prelude> f [12]
01:25:37 <earthy> 2
01:26:10 <pumpkin_> bah!
01:26:13 <earthy> haskell *does* have semicolons and curly braces, you know
01:26:13 <ivanm> earthy: ummmm..... wtf?
01:26:18 <pumpkin_> segmentation faults should not be happening
01:26:39 <ivanm> oh, wait forget that
01:26:43 * ivanm misread the function
01:26:47 <earthy> plus, ghci allows toplevel lets
01:27:04 <earthy> ivanm: that was to throw people off and force them to read it closely :)
01:27:16 <ivanm> heh
01:27:34 <ivanm> it that's the case, that was just _evil_
01:28:13 <NameAlreadyInUse> earthy: can they be given type signatures too?
01:28:21 <earthy> NameAlreadyInUse: sure can
01:28:22 <rainmann> yes
01:28:47 <earthy> it is kinda annoying that you have to type the entire thing onto one line though
01:28:49 <ivanm> though didn't hbc have a _proper_ REPL?
01:29:00 <ivanm> as in being able to create data structures, etc.?
01:29:15 <quicksilver> I think so, yes.
01:29:26 * kohwj concurs with it being annoying to have to type it all in one line
01:29:31 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=1564#a1564
01:29:33 <quicksilver> kohwj: you don't.
01:29:37 <earthy> http://www.cs.chalmers.se/~augustss/hbc/interactive.html
01:29:39 <kohwj> isn't there something like python's "\"?
01:29:45 <NameAlreadyInUse> so i can do something like "f :: a -> IO a; let f = return"?
01:29:46 <quicksilver> :{
01:29:50 <quicksilver> :}
01:29:58 <halberd> frowny face happy face
01:30:01 <cizra> dolio: :80?
01:30:14 <earthy> NameAlreadyInUse: try it. :)
01:30:24 <kohwj> quicksilver: ?
01:30:35 <cizra> > main :: IO(); main = return ()
01:30:36 <lambdabot>   * Exception: "<IO ()>"
01:30:48 <kohwj> Prelude> x = do {            <interactive>:1:2: parse error on input `
01:30:51 <cizra> > main :: IO(); main = do ; return ()
01:30:52 <NameAlreadyInUse> earthy: i did in ghci, it says parse error on ";" :S
01:30:52 <lambdabot>   * Exception: "<IO ()>"
01:30:56 <quicksilver> kohwj: :P
01:30:59 <quicksilver> kohwj: :{
01:31:02 <earthy> because your let is in the wrong place
01:31:06 <Cope> wow this channel has grown in 2 years!
01:31:09 <kohwj> quicksilver: same
01:31:09 <earthy> Prelude> let f :: a -> IO a; f = return
01:31:13 <NameAlreadyInUse> ahh
01:31:21 <NameAlreadyInUse> thanks
01:31:32 <NameAlreadyInUse> yeah, got it now
01:32:15 <pumpkin_> BLAH
01:32:18 <NameAlreadyInUse> that will save me a lot of time; sometimes i need to add type signatures to functions when using the function composition operator
01:32:24 <quicksilver> kohwj: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1492#a1492
01:32:25 <pumpkin_> SEGMENTATION FAULTS DO NOT BELONG IN MY PURE COE
01:32:27 <earthy> uhuh.
01:32:29 <quicksilver> ^^ multiline ghci.
01:32:48 <kohwj> quicksilver: ah! :)
01:32:54 <earthy> hey that's useful
01:33:13 <ivanm> pumpkin_: then don't use the unsafeSegFault function! ;-)
01:33:13 <earthy> still doesn't allow toplevel declarations such as data though
01:33:21 <pumpkin_> ivanm: I'm not!
01:33:31 <ivanm> hmmm..... :p
01:33:41 <NameAlreadyInUse> earthy: yes, it would be handy if it did
01:33:43 <quicksilver> nope
01:33:47 <quicksilver> just multiline expressions
01:34:01 <quicksilver> doesn't do layout either, AFAIK
01:34:24 <pumpkin_> :( :(
01:35:06 <pumpkin_> Warning: 0x82b4e0 still allocated at shutdown
01:35:14 <pumpkin_> bunch of those
01:36:13 <ivanm> has anyone managed to successfully build cabal-1.6.0.2 and _use it_?
01:36:21 <ivanm> ghc is complaining about deps :@
01:46:29 <Saizan_> ivanm: what error are you getting in particular?
01:47:33 <dcoutts> ivanm: enquiring minds want to know!
01:48:48 <CTA> Hey, yesterday about the case, it was indention, notepad++ didn't show it not in line but then I redid it in notepad and it worked, so back to notepad
01:52:47 <CTA> Anyone here got msn messenger and got SmarterChild added?
01:53:32 <quicksilver> CTA: probably there was a TAB in there instead of a space.
01:53:52 <quicksilver> dcoutts: incorrect deps for ghc, he said
01:53:54 <CTA> I think that's what the problem was
01:54:04 <quicksilver> dcoutts: (but apparently the error message didn't tell him what the failing deps where)
01:54:22 <CTA> haha lol i'm mucking around with functions :)
01:54:46 <quicksilver> 09:21 < ivanm> wtf? I run "ghc-pkg check", and it says that ghc-6.10.1 has  missing dependencies! :o
01:55:15 <dcoutts> quicksilver: oh right, he broke his ghc
01:55:39 <quicksilver> well I probably can't speak for him any further ;)
01:55:47 <ivanm> dcoutts: no, upgrading to your new version of cabal broke my ghc!
01:55:47 <quicksilver> he didn't sound like he was aware he had broken it ;)
01:56:00 <dcoutts> ivanm: no it didn't, ye silly nonce! :-)
01:56:16 <dcoutts> ivanm: what did you unregister?
01:56:31 <Saizan_> mmorrow: ping? do you perhaps have a function to show the TH in a way that's really copy/paste-able? i.e. fixing how Name's are shown
01:56:34 <CTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1566#a1566 mwha, btw does H.I.V stand for highly infectious virus?
01:57:02 <CTA> XD
01:57:44 <dcoutts> ivanm: ghc-pkg check says what is missing. Upgrading Cabal only adds packages, it never unregisters.
01:58:23 <dcoutts> ivanm: I'd say it could be the ebuilds fault if you're using an ebuild, but none of the packages that the ghc api package depends on are covered by ebuilds.
01:59:58 <CTA> whats one of the best free text editors for writing Haskell code in? I mean is there any that like automatically indent/high keywords etc?
02:00:03 <CTA> excluding notepad++
02:00:50 <dcoutts> CTA: when I used windows (many years ago) I used textpad which had ok Haskell highlighting
02:01:04 <rittyan> when I used windows I used e**cs
02:01:08 <osfameron> I used to use gvim on Windows.  Learning curve, but good.  Same for emacs I guess.
02:01:13 <CTA> why you staring it?
02:01:24 <CTA> emacs = educational mac?
02:01:51 <rittyan> not really
02:01:54 <daf> haha
02:02:02 <czShadoW> EMACS = the extensible, customizable, self-documenting, real-time display editor
02:02:09 <CTA> lol whats a eMac?]
02:02:16 <CTA> kk is it a program?
02:02:37 <osfameron> funnily enough, it's a text editor
02:02:53 <osfameron> someone was in here asking about them
02:03:02 <quicksilver> http://www.emacswiki.org/cgi-bin/wiki/EmacsW32
02:03:12 <quicksilver> possibly waht you want for running it on windows.
02:03:16 <quicksilver> although I've never tried.
02:04:55 <blackh> CTA: Don't listen to these fools! Use a proper editor, like jEdit.
02:05:23 <BD> sbt, where can i download it?
02:05:53 <Workybob> CTA: don't listen to them!  The reason that no one can decide which of vim or emacs is better is that they both suck
02:05:54 <Workybob> >.<
02:06:24 <blackh> Workybob speaks the truth
02:06:30 <CTA`> what do you use Worky?
02:06:46 <Workybob> SubEthaEdit, which, unfortunately for you is neither free, nor available on windows
02:06:49 <Workybob> :(
02:07:13 <CTA`> whats it available on, and is it good? how much
02:07:20 <Workybob> I know a lot of people who use TextMate, which suffers from the same problems
02:07:25 <Workybob> Mac only, in both cases
02:07:34 <Workybob> and IIRC $20 for students, $40 for anyone else
02:07:35 <blackh> jEdit is great - it's free, available on Windows, works well, and it's a proper editor. http://jedit.org/
02:07:58 <CTA`> I'm getting MacBook Pro when going to college =D
02:08:02 <Workybob> :)
02:08:09 <Workybob> make sure you try out both of them then
02:08:14 <CTA`> thats like 2 years though lol
02:08:21 <quicksilver> Didn't jon harrop used to post on the haskell list about how much better ocaml was than ghc?
02:08:23 * Workybob shrugs – they're still lovely machines
02:08:29 <mornfall> blackh: jEdit, eh? :)
02:08:32 <quicksilver> "I don't believe any of OCaml's major issues will ever be addressed. The only
02:08:32 <quicksilver> way forward is to replace OCaml with something better. The problem is that
02:08:32 <quicksilver> few people in the Linux world understand what that means and none of those
02:08:34 <quicksilver> people are able to do it. "
02:08:36 <mornfall> Get a real operating system. Use emacs.
02:08:37 <mornfall> : - ]
02:08:37 * quicksilver boggles
02:08:40 * Thunder snickers. ICANN Translation Service: "The documents you provided, can't be processed. They appear as unreadable glibberish. Is it possible, that you send us the wrong documents? The files we have are named '.tex'. Please send the original Word Documents."
02:08:41 <ricky_clarkson> emacs
02:08:58 <Workybob> quicksilver: o.O
02:09:09 <Workybob> does he understand what he means by "better"?
02:09:20 <Workybob> does he have any explanation of what "better" might look like?
02:09:36 <mmorrow> Saizan_: yes i do, one sec
02:09:43 <mmorrow> (it's cleanNames)
02:09:53 <pejo> quicksilver, why do you pay attention to what he writes anyways?
02:10:02 <cizra> Plonk 'em!
02:10:07 <quicksilver> pejo: because I'm curious about the human condition.
02:10:19 <quicksilver> pejo: you're right that's it's not terrible productive to bring it up here, though. Sorry.
02:10:24 <CTA`> is he me?
02:11:19 <pejo> CTA, he is Jon Harrop.
02:11:28 <CTA> ah
02:11:39 <idnar> Thunder: hahaha
02:11:43 <mmorrow> Saizan_: so,  cleanNames==>clean up varnames, pretty==>parse the String from show as haskell and pprint it, pp==>cleanName then render the TH as the haskell code _it represents_
02:11:52 <mmorrow> Saizan_: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/src/Language-Haskell-Meta-Utils.html#cleanNames
02:12:10 * wli tries to remember the name of the guy who actually got some version of emacs (maybe hemlock) booting on the bare metal.
02:12:39 <ricky_clarkson> Jon Harrop trolls the mono mailing lists atm.
02:13:00 <ricky_clarkson> And once he tried to discredit me by saying I was irrelevant as I was an academic.
02:13:11 <quicksilver> ;)
02:13:11 <ricky_clarkson> I pointed out that I'm not so he deleted mine and his comments. :)
02:13:18 <wli> Was that the clueless ocaml bigot?
02:13:21 <ricky_clarkson> Yes.
02:13:28 <quicksilver> he's a bit more complex than that.
02:13:38 <quicksilver> He appears to be an interesting variety of commercial troll.
02:13:55 <quicksilver> causing controversy to draw attention to his products and services
02:14:01 <quicksilver> no idea if he actually sells anything ;)
02:14:09 <blackh> quicksilver: He doesn't just live under a bridge, he runs a shop from under a bridge.
02:14:53 <Workybob> quicksilver: ohh, that's a new strategy... I knew about trolls doing it to drag in ad revenue
02:14:57 <ricky_clarkson> He's always promoting the Nobody Gives a Flying Fuck consultancy.
02:14:58 <Workybob> but never to get people to buy their products
02:15:05 <CTA> any more good text editors apart from jEdit? I think it's alright just automatically saves to C:\ instead of ..\Code which I specified
02:15:14 <ricky_clarkson> CTA: emacs
02:16:46 <cizra> CTA: Vim \o/
02:17:09 <ricky_clarkson> Tabs!
02:17:13 <ricky_clarkson> Oh, wrong argument.
02:17:31 <blackh> I'm not saying jEdit is the best. I'm just saying that it lets you edit your file.  Vim and emacs will edit your file, but they want a relationship too.
02:18:12 <cizra> hahah, that's a true AND a funny one, blackh
02:18:16 <pao> blackh: ... they're great lovers ;-)
02:18:22 <ricky_clarkson> The barrier to entry for emacs is lower, as it comes with all those silly menus by default.
02:18:36 <mmorrow> most things are funny /because/ they're true :)
02:18:40 <ricky_clarkson> But I know that even complete novices can get to grips with vim, as I've taught them to.
02:18:41 <joga> well, gvim has silly menus too
02:18:44 <quicksilver> and emacs has the best haskell indentation mode (as far as I know)
02:18:59 <quicksilver> one that actually understands layout properly.
02:19:04 <nomeata> Hi. Is David Waern or Simon Marlow sometimes here?
02:19:10 <cizra> Hell. Perhaps I, a life-long Vimmer should give emacs a shot.
02:19:10 <ricky_clarkson> (as long as it's in vim mode not vi mode)
02:19:16 <pejo> nomeata, yes.
02:19:25 <ricky_clarkson> cizra: Do you customise vim with your own code?
02:19:26 <mmorrow> cizra: don't do it!!
02:19:28 <quicksilver> nomeata: simon marlow is almost always here, although he's often busy.
02:19:49 <Peaker> quicksilver, that's an overstatement (about emacs indentation)
02:19:51 <cizra> ricky_clarkson: Not much. I've written some macros (to run the current doc through LaTeX n' stuff)
02:19:51 <nomeata> pejo: what are their nicknames?
02:19:54 <pao> the only reason I won't switch to emacs it that I've got vim implanted in my brain ;-)
02:19:58 <cizra> mmorrow: Please elaborate?
02:20:06 <mmorrow> cizra: just being silly
02:20:07 <quicksilver> nomeata: simon marlow is JaffaCake
02:20:13 * mmorrow uses vim
02:20:14 <quicksilver> Peaker: ?how so?
02:20:32 <ricky_clarkson> cizra: Ok.  Personally I used vim for years, and never got around to customising it.  It looked difficult for no particular technical reason.
02:20:34 <Peaker> quicksilver, maybe the haskell mode that comes with Ubuntu is broken but it indents in a stupid and annoying way
02:21:04 <ricky_clarkson> cizra: Everyone who uses emacs writes at least some code to customise it - the barrier to doing so seems lower, and it seems more immediate when you do do it.
02:21:04 <blackh> jEdit's Haskell support is not that great. I also used Eclipse with the Haskell plug-in, but that is very rough and doesn't look like anyone's really working on it.
02:21:10 <quicksilver> Peaker: ok, but that's not the mode I was talking about.
02:21:11 <pejo> nomeata, waern, but apparently he hasn't been here for a while according to lb.
02:21:22 <quicksilver> Peaker: I  waas talking about this one:
02:21:23 <nomeata> pejo, quicksilver: thx
02:21:23 <pao> ricky_clarkson: are you familiar with emacs lisp? ... sounds a good reason to give lisp a shot ...
02:21:26 <ricky_clarkson> blackh: The intersection of people who like Haskell and Eclipse is probably too small.
02:21:30 <quicksilver> @where kuribas-indentation
02:21:30 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
02:21:36 <ricky_clarkson> pao: Yes.  It's not a good lisp, but it works for emacs.
02:21:40 <nomeata> JaffaCake: hi. it seems that the haddock interface have become arch dependent (at list int-size-dependent) in haddock 2, and were not before
02:21:45 <ricky_clarkson> Dynamically-scoped by default.
02:21:52 <nomeata> JaffaCake: this makes stuff a bit inconvenient for Debian
02:22:04 <ivanm> dcoutts: the only possible difference I can see between them is the private filepath version being used
02:22:08 <blackh> yi works, but someone needs to drag it into the 21st century in the GUI department.
02:22:27 <ricky_clarkson> I haven't tried yi - I keep meaning to look for screenshots or to try it.
02:22:35 <mmorrow> yi is sweet
02:23:07 <Axman6> textmate does a decent job on OS X
02:23:21 <nomeata> JaffaCake: Do you think it’s reasonable to change the format to use consistent sizes, and have a release relatively quickly? (I’d look into patching something)
02:23:53 <CTA> So if I got a mac you would recommend me to get SubEthaEdit?
02:23:59 <Axman6> no
02:24:04 <blackh> ricky_clarkson: yi does the job and it (obviously) has good Haskell support. With a bit more work it'll be wonderful.
02:24:49 <nomeata> Or anyone else knowledgable about haddock’s internals: ^
02:25:30 <CTA> Axman you tslking to me?
02:25:33 <CTA> *talking
02:25:39 <Axman6> yes
02:25:49 <CTA> why wouldn't you recommend it?
02:26:37 <quicksilver> why pay for a substandard product when there are better ones for free?
02:26:45 <CTA> name better ones?
02:27:03 <Axman6> TextMate
02:27:12 <pao> CTA: vim, emacs are the obvious ones :-)
02:27:38 <Axman6> i don't find vim gives me any benefits over textmate, and emacs hurts my hands
02:27:55 <rittyan> funny thing, I thought that textmate is closer to emacs  than to vim
02:28:01 <CTA> does it work on windows?
02:28:07 <Axman6> no
02:28:24 <mmorrow> does anything work on windows?
02:28:27 <Axman6> rittyan: in some ways sure, but it's not ctrl obcessed, so it doesn't hurt
02:28:42 <CTA> it's not free? 30 Day Trial
02:28:51 <Workybob> I find it interesting that everyone stays with windows because there's "more software available for it"
02:28:54 <Axman6> no, it's not free
02:29:04 * quicksilver has never really understood the idea that the control key hurts.
02:29:09 <Workybob> yet all the software suggestions here are qualified with "it doesn't work on windows"
02:29:12 <quicksilver> maybe I'm just an ergonomic freak.
02:29:21 <quicksilver> Workybob: emacs and vim both work on windows.
02:29:23 <Workybob> quicksilver: it's at the maximum stretch of your weakest finger
02:29:32 <kohwj> how should ambigiouity in accessor functions in record syntax be resolved? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1496#a1496
02:29:34 <quicksilver> Workybob: I've been using emacs heavily for 15 years
02:29:36 <osfameron> I have my caps lock key mapped to Ctrl
02:29:39 <joga> Workybob, software that works for 30 days and then nags, and you have to hunt them from scattered sites on the web etc ;)
02:29:40 <Workybob> and the one that's most likely to be affected by carpul tunnel
02:29:44 <Axman6> quicksilver: how; the joints going?
02:29:45 <CTA> you said why when there are better free ones? then i said name one?
02:29:46 <osfameron> sadly I don't know where to put my caps lock key...
02:29:47 <quicksilver> Workybob: never once have I experienced any pain or discomfort of any kind.
02:29:52 <Peaker> quicksilver, I tried the mode now - it breaks pc-select-mode :(
02:29:56 <Workybob> quicksilver: lucky you :)
02:29:57 <Axman6> CTA: vim and emacs are both free
02:30:00 <quicksilver> Peaker: doh.
02:30:07 <quicksilver> Peaker: you could try contacting kuribas about it
02:30:08 <Axman6> i just don't really like them (i prefer vim though)
02:30:10 <quicksilver> preflex: seen kuribas
02:30:10 <preflex>  kuribas was last seen on #haskell 87 days, 21 hours, 6 minutes and 13 seconds ago, saying: Does anyone know of a language for numerical computations like octave, but in a more functional style?
02:30:11 <hotaru2k3> (for certain definitions of free)
02:30:13 <joga> turning capslock into control is a lot more comfy, imo
02:30:13 * wli uses UNIX-style Sun Type 6 keyboards.
02:30:31 <quicksilver> Peaker: I'll PM you his email address if you like
02:30:38 <Axman6> joga: tried to do that on my mac, but seems none of the software to do it works with leopard
02:30:40 <wli> On such keyboards, control and capslock are in the correct positions to begin with.
02:30:45 <Peaker> quicksilver, Why "duh" :)
02:30:52 <Peaker> quicksilver, yeah, sure
02:30:54 <blackh> kohwj: Either put them in different modules, or use different names.
02:30:56 <quicksilver> Peaker: not 'duh', but 'doh' ;)
02:31:00 <joga> Axman6, hmm, can you use xmodmap in os x?
02:31:08 <quicksilver> Peaker: 'duh' means "you stupid boy" but 'doh' means "oh, that's annoying"
02:31:09 <Axman6> no
02:31:13 <joga> ok
02:31:18 <Axman6> since OS X doesn;t use X
02:31:27 <Axman6> works fine in X11, but X11 sucks
02:31:38 <cizra> *slurp*
02:31:56 <blackh> kohwj: record namespace clutter is a bit of an annoyance in Haskell
02:32:29 <quicksilver> although it's less of a problem if you don't think of them as OO-style field names.
02:32:45 <quicksilver> if you think of them as toplevel functions "dName :: D -> String" and "eName :: E -> String"
02:32:53 <quicksilver> then it's more natural that they need different names.
02:33:03 <quicksilver> it's consistent with how we handle all other functions, after all.
02:33:19 <wli> I usually prefix and/or suffix them with something obvious.
02:33:42 <mmorrow> i can never decide if i want to prefix or suffix them
02:33:47 <mmorrow> it makes me crazy
02:33:59 <kohwj> blackh: ah, i see
02:35:14 <mmorrow> kohwj: alternatively you can make a class e.g.  class Name a where name :: a -> String
02:35:36 <quicksilver> that's probably not to be advised casually though
02:35:39 <mmorrow> instance Name E where name (E n) = n
02:35:54 <mmorrow> yeah, i find doing that a total pain..
02:35:54 <quicksilver> there are circumstances where it's what you want, but..
02:36:00 <quicksilver> dont' forget quicksilver's first rule
02:36:07 <quicksilver> (1) If you think you need a type class, you don't. Think again.
02:36:13 <mmorrow> heh
02:36:20 <kohwj> that's interesting.
02:36:32 <Peaker> quicksilver, records and typeclasses share the same namespace problem :)
02:36:35 * wli tries to think of a simple typed language with user-defined data types and modules.
02:36:52 <kohwj> wli: C++?
02:36:53 * kohwj ducks
02:37:04 <mmorrow> C++ has modules??
02:37:18 <EvilTerran> "namespaces"
02:37:18 <quicksilver> arguably C++ namespaces are about as capable as haskell modules
02:37:23 <quicksilver> since haskell modules are really just namespaces
02:37:24 <mjrosenb> is there any way of having in implementation of class C a automatically give an implementation D a?
02:37:25 <doserj> kohwj: you can also declare E and D in different modules. Use the existing namespace mechanisms for what they were designed for!
02:37:26 <wli> Namespaces are a crappy substitute for a module system.
02:37:33 <ivanm> quicksilver: my problem with ghc ended up being that the gentoo ebuild for cabal-1.6.0.1 forgot to mark its status as being shipped with 6.10.1, so when I upgraded to 1.6.0.2 it unregistered 1.6.0.1 and ghc didn't like that :s
02:37:36 <quicksilver> neither is a module system in the ML sense.
02:37:45 <quicksilver> ivanm: oh, interesting.
02:37:45 <mmorrow> can you explicitly import into and export from symbols into/outof namespaces?
02:37:58 <quicksilver> mmorrow: useing foo::bar;
02:38:01 <quicksilver> or something.
02:38:09 * quicksilver has never really used C++ namespaces, only read about that.
02:38:21 <mmorrow> yeah, me neither
02:38:52 <ivanm> quicksilver: have you ever really used C++ though? :p
02:39:09 <quicksilver> ivanm: somewhat, in the pre-namespaces days
02:39:31 <quicksilver> I used a C++-like language called "THINK Object C"
02:39:36 <quicksilver> and then I used C++ a bit.
02:39:55 <wli> Data structures for expressions aren't too tough.
02:40:08 <quicksilver> mjrosenb: No.
02:40:19 <wli> Next is what to do about user-defined types.
02:40:26 <quicksilver> mjrosenb: there is a way of saying that an instance of class C *must* have an instance of class D.
02:40:27 <wli> After that, what to do about modules.
02:40:31 <quicksilver> or vice versa.
02:41:27 <mjrosenb> quicksilver: so i have a class that feels like Show, but carries more data around, and i don't want to have to say Instance Show Foo where show = pshow default
02:41:32 <Peaker> I think Haskell should probably differentiate between "subclass because its expressiveness is a superset [possible to auto-derive super-class]" and "subclass because of laws that apply"
02:41:46 <quicksilver> mjrosenb: make Show a superclass of it.
02:41:54 <mjrosenb> quicksilver: how?
02:42:02 <quicksilver> class Show a => MyShow a where ...
02:42:10 <wli> I think modules might be handled as sets of declarations.
02:42:51 <mjrosenb> quicksilver: but how would that avoid the show = myshow default in every instance?
02:43:28 <quicksilver> mjrosenb: it wouldn't, but it would at least document the connection.
02:43:36 <quicksilver> mjrosenb: and reduce contexts
02:43:43 <quicksilver> allow haskell to infer Show a from MyShow a
02:44:04 <wli> One kind of declaration might be a type declaration, another might be a function declaration.
02:44:12 <mjrosenb> actually i think that this would lead to more show = myshow...
02:44:31 <mjrosenb> since i currently don't have instances of show for everything that has an instance of myshow
02:45:30 <wli> Import directives and fixity declarations crop up, too, though I probably want to ignore fixity for minilanguages (in fact, parsing altogether; just use read/show).
02:46:40 <quicksilver> mjrosenb: well I don't really know what you're trying to do ;)
02:46:46 <quicksilver> sounds like abuse of the type class system to me
02:46:50 <quicksilver> but then, I normally think that.
02:47:09 <wli> I guess I'm trying to concoct a sort of mini-ML, only even tinier and stupider.
02:47:11 * mjrosenb thinks that alot
02:50:37 <wli> Never mind. I just saw what MiniML actually looks like and it's even stupider.
02:52:16 <wli> Import directives smell like at first they'd want an import/export set at the module level, but local imports are tricky that way.
02:54:11 <wli> I guess I can write off local imports as a feasibly implementable language feature for a language intended to be this stripped down.
02:56:44 <wli> The bigger picture is probably a distinction between recording interactions between the module being defined and other modules and populating the namespace within the module or more locally within various declarations of the module.
02:58:28 <wli> i.e. auto-populate a list of other modules used ("imported") by the module being defined and freely allow namespace manipulation within the module (module-global imports, qualified imports, local imports, passing parameters to various modules, etc.).
03:00:04 <mjrosenb> strangely, the thing that's sane isn't allowed
03:00:12 <mjrosenb> but something that's totally off the wall
03:00:14 <mjrosenb> is fine
03:00:15 <mjrosenb> :(
03:00:30 <wli> mjrosenb: Whats's the thing that's sane but disallowed?
03:01:49 <mjrosenb> wli: i have a class, MyShow, which requires a function myshow
03:02:11 <mjrosenb> wli: and i want to avoid "Instance Show foo where show = myshow bar"
03:02:24 <mjrosenb> wli: for *every* instance of MyShow
03:02:34 <mjrosenb> rather
03:02:42 <mjrosenb> instance Show Foo
03:02:49 <ivanm> anyone know why the author of the digest library used the zlib library directly rather than the haskell zlib bindings?
03:03:07 <wli> instance MyShow t => Show t where show = myshow?
03:04:13 <int-e> Which isn't allowed because the context (MyShow t) isn't taken into consideration when deciding which instances of Show to pick, i.e. that's an overlapping instance (which overlaps with all other Show instances)
03:04:29 <mjrosenb> wli: what int-e said
03:04:37 <int-e> presumably allowing overlapping instances achieves the desired result.
03:04:45 <mjrosenb> yes, but eww.
03:05:18 <wli> Don't derive Show instances on things you want to use MyShow for?
03:05:25 <mjrosenb> does ghc do any sort of sanity checking to make sure i don't instantiate both Show and MyShow?
03:05:47 <dolio> The more specific instance is chosen.
03:06:04 <dolio> So if you instantiate both, it uses the Show instance you made explicitly.
03:06:07 <quicksilver> but only if its in scope.
03:06:11 <quicksilver> which makes the extension unsound.
03:06:26 <blackh> Is there some tidy way to say
03:06:41 <quicksilver> indeed, it makes the semantics of the extension undefined, since it can vary based on how much gets inlined and how you split up your modules.
03:07:14 <mjrosenb> also
03:07:15 <blackh> Urk. Please ignore me.
03:07:18 * int-e doesn't like that extension either.
03:07:42 <mjrosenb> evidently, it also thinks that i've instantiated MyShow for types that i have not instantiated it for
03:07:59 <ivanm> blackh: ignore who?
03:08:00 <ivanm> :p
03:08:23 <dolio> That was pretty tidy.
03:09:21 <chrisdone> merry friday
03:11:44 <ivanm> chrisdone: you're only 21 hours late :p
03:12:36 <chrisdone> let's do the time warp again?
03:13:34 <Thunder> I didn't found the unsafeSegFault function mentioned this morning here... Which hackage packet is it?
03:13:52 <ivanm> Thunder: that was a joke...
03:14:01 <dolio> It's pretty easy to write yourself.
03:14:02 <Thunder> Oops.
03:14:20 <ivanm> since someone (pumpkin?) was complaining that their pure code kept segfaulting
03:14:25 <quicksilver> (unsafeCoerce# (0::Int)) :: IO ()
03:14:26 <ivanm> dolio: oh? any pointers?
03:14:28 <pumpkin_> yup
03:14:31 <quicksilver> ^^ that probably segfaults.
03:14:34 * Thunder seeks for a stone to cover himself.
03:14:44 <pumpkin_> by pure code, I mean no unsafe* functions either :)
03:14:49 <ivanm> > (unsafeCoerce# (0::Int)) :: IO ()
03:14:49 <lambdabot>   Not in scope: `unsafeCoerce#'
03:14:53 <dolio> unsafeCoerce () ()
03:14:53 <ivanm> awwwww :(
03:14:55 <ivanm> ;-)
03:15:05 <ivanm> Thunder: why did you want to know?
03:15:32 <idnar> unsafeCoerce () () abort()s
03:15:35 <Thunder> pumpkin: let unsafe = const in unsafe unsafe ... works
03:15:37 <idnar> I haven't been able to get a segfault yet
03:15:51 <Thunder> ivanm: Just to know.
03:15:56 <chrisdone> how does haskell code get from code text in a .hs file to a compiled executable program?
03:15:57 <ivanm> idnar: what, ghc is too smart for your own good and _knows_ that you don't really want a segfault?
03:16:07 <ivanm> chrisdone: by using a compiler
03:16:09 <idnar> ivanm: hahaha, something like that :P
03:16:12 <ivanm> just like all other compiled languages
03:16:13 <ivanm> ;-)
03:16:26 <chrisdone> how does GHC do it?
03:16:44 <ivanm> by reading it in, converting it to various intermediary forms, then spitting out machine code
03:16:58 <chrisdone> what intermediary forms?
03:16:58 <ivanm> (that's my very rough understanding on how any compiler works)
03:17:02 <ivanm> chrisdone: Core, etc.
03:17:03 <Thunder> He! Stop! I did not ask for this function, because it's necessary to include it into the standard Prelude! So PLEASE stop developing it.
03:17:37 <ivanm> Thunder: awww...
03:18:05 <chrisdone> ivanm: why?
03:18:13 <ivanm> chrisdone: why what?
03:18:25 <chrisdone> what convert it to various intermediary forms?
03:18:35 <ivanm> well, it can't do stuff when it's in text form ;-)
03:18:49 <ivanm> and it uses Core, etc. to do the various optimizations, mangling, etc.
03:19:04 * ivanm isn't an expert, as he's never written a compiler
03:19:11 <ivanm> chrisdone: maybe you should ask on #ghc?
03:19:53 <vininim> predicated explicit gated simple uniform single static assignment form is one of the commons way of intermediate representation (obviously not)
03:20:34 <ivanm> vininim: :o
03:20:51 <cizra> Oh wow. Lots of adjectives.
03:21:01 <dolio> , newU 10 (\arr -> mapM_ (\n -> writeMU arr n 5) [10000..]) :: UArr Int
03:21:08 <lunabot>  Killed.
03:22:05 <mornfall> Well, SSA is unlikely to be used by a functional (as opposed to imperative) compiler.
03:22:06 <dolio> That'll segfault.
03:22:23 <mornfall> dolio: That's a silly way to trig a segfault.
03:22:45 <mornfall> Dreferencing NULL is the canonical way. :)
03:22:50 <mornfall> Deref*
03:23:08 <dolio> Writing to unallocated memory is a silly way to segfault?
03:25:23 <chrisdone> what is a segfault?
03:25:59 <ivanm> @go define:segfault
03:25:59 <lambdabot> No Result Found.
03:26:02 <ivanm> @go segfault
03:26:04 <lambdabot> http://en.wikipedia.org/wiki/Segmentation_fault
03:26:04 <lambdabot> Title: Segmentation fault - Wikipedia, the free encyclopedia
03:26:07 * cizra slams a SIGSEGV on chrisdone's face
03:26:07 <ivanm> chrisdone: ^^
03:26:22 <cizra> killall -HUP politicians
03:26:24 * SamB tries to give sudo the root password *twice* before remembering to use his own
03:26:25 <ivanm> cizra: I thought we were meant to be the _friendly_ programming-related channel...
03:26:36 <cizra> Hmm. You can trigger segfaults with kill.
03:26:38 <ivanm> SamB: yeah, I keep forgetting that as well :s
03:26:47 <ivanm> cizra: of course you can, it uses C! :p
03:26:58 <cizra> ivanm: (= We're ol' friends with chrisdone, he won't be angry. (at least I hope)
03:27:01 <SamB> ivanm: that doesn't mean we can't hang up on politicians!
03:27:18 <ivanm> cizra: heh
03:28:14 <ivanm> SamB: I meant it wasn't nice to slam the SIGSEGV
03:28:25 <SamB> oh
03:28:35 <ivanm> hanging up pollies (by their coattails?) is a different story ;-)
03:28:36 <chrisdone> anyone got some documentation about how to remove a SIGSEGV from your face?
03:28:52 <dolio> Of course 'peek nullPtr' works too.
03:28:54 <ivanm> go to runlevel 3 maybe?
03:28:54 <SamB> chrisdone: it depends on how it is attached
03:29:01 <ivanm> (is that the reboot runlevel?)
03:29:01 <dolio> If that's your bag.
03:29:02 <chrisdone> SamB: slammed
03:29:13 <SamB> chrisdone: well, I don't think it's attached then
03:29:15 <pejo> mornfall, MLTon uses SSA.
03:29:16 <cizra> dd if=/chrisdone/face of=/dev/null
03:29:19 <SamB> usually such things fall off
03:29:23 <cizra> Oops, the SIGSEGV went together with the face.
03:32:47 <mornfall> pejo: "unlikely", as opposed to "never used". :)
03:32:50 <chrisdone> > let x = x in x
03:33:05 <lambdabot>   thread killed
03:33:53 <pejo> mornfall, why is it unlikely?
03:34:03 <mmorrow> @let help = text "Segmentation fault"
03:34:04 <lambdabot>  Defined.
03:34:07 <mmorrow> > help
03:34:08 <lambdabot>   Segmentation fault
03:34:14 <rittyan> lol
03:34:16 <mmorrow> hehe
03:34:19 <cizra> heh
03:34:40 <chrisdone> ?faq Can Haskell be configured to segfault when someone asks for help?
03:34:40 <lambdabot> The answer is: Yes! Haskell can do that.
03:35:54 * vincenz wishes hayoo were called hoogle :)
03:36:06 * Workybob wonders what hayoo does that hoogle doesn't
03:36:23 <SamB> Workybob: I think hoogle can't search the entire hackage ?
03:36:36 <int-e> > foldr (($$) . text . (:[])) (text "") "Hi"
03:36:37 <lambdabot>   H
03:36:37 <lambdabot>  i
03:36:39 <SamB> but hayoo doesn't search in as interesting a way ?
03:36:45 <Workybob> neil updated it a while ago – you can add hackage modules to the search with
03:36:49 <Workybob> ... some syntax
03:37:00 <ivanm> Workybob: yes, but hayoo is already integrated into hackage
03:37:07 <Workybob> so?
03:37:14 <ivanm> whereas IIRC, you need to rebuild the hoogle database for each module you add in
03:37:20 <SamB> yeah
03:37:21 <Workybob> nope
03:37:37 <SamB> you can't just say "search the whole damn hackage"!
03:37:38 <Workybob> it has a seperate database for each (documented) hackage module
03:37:39 <ivanm> *shrug* then hayoo had the ability to be integrated first and was integrated
03:37:48 <ivanm> Workybob: who, hoogle or hackage?
03:37:52 <Workybob> SamB: IIRC neil tried that, and found that the results were horribly cluttered
03:37:57 <Workybob> ivanm: hoogle does
03:37:59 <ivanm> s/hackage/hoogle/
03:38:18 <ivanm> Workybob: well, that looks like the difference between the two
03:38:23 <Workybob> what does?
03:38:24 <ivanm> oh, and hayoo is Web 2.0 ;-)
03:38:28 <Workybob> so is hoogle
03:38:41 <Workybob> you guys really haven't used hoogle in a long time, have you?
03:38:53 <SamB> er, I probably have
03:38:57 <SamB> I don't use hayoo
03:39:00 <SamB> anyway
03:39:11 <ivanm> Workybob: that it appears hayoo has all of hackage in it
03:39:11 <dcoutts_> Workybob: I don't think hoogle has ever searched all of hackage, that requires more automation, however the plan is to do so, to use hoogle as the primary interface to hackage.
03:39:16 <ivanm> Workybob: probably not
03:39:25 <ivanm> Workybob: since we have hoogle here ;-)
03:39:29 <ivanm> @hoogle DotNode
03:39:29 <lambdabot> No results found
03:39:34 <ivanm> ^^ hayoo found the correct result
03:39:36 <Workybob> dcoutts_: as I just said – it doesn't do it by default
03:39:42 <Workybob> but you can add more hackages to search
03:39:43 <Workybob> http://haskell.org/hoogle/?hoogle=parse+%2Btagsoup
03:39:48 <mornfall> pejo: How many other such compilers do you know?
03:40:02 <mornfall> I know lots that use CPS, eg.
03:40:05 <dcoutts_> Workybob: but only from a subset that hoogle knows about, not arbitrary packages from hackage.
03:40:14 <ivanm> Workybob: yes, it doesn't do it by default, but hayoo does
03:40:17 <ivanm> there's the difference
03:40:21 <dcoutts_> Workybob: Neil and I have discussed how to automate and integrate it better
03:40:24 <ivanm> and hoogle doesn't appear to be web 2.0 with all its bling
03:40:29 <mornfall> pejo: And many imperative that use some variation on SSA.
03:40:30 <chrisdone> what does GHC do when it is "linking"?
03:40:42 <SamB> chrisdone: link stuff!
03:40:43 <dcoutts_> chrisdone: call gcc to link object files and libraries
03:40:52 <chrisdone> does it only call gcc?
03:40:52 <ivanm> chrisdone: basically, combines all the seperate modules into one executable file
03:40:56 <Workybob> dcoutts_: oh, I see – yeh, but surely that's just a matter of getting hackage to ping hoogle to rebuild individual databases when they get documents generated?
03:41:01 <SamB> but it links stuff you probably would have forgotten if you were doing it yourself
03:41:20 <Workybob> ivanm: yeh, that's why I use hoogle over hayoo – I don't want the enormous number of results that hayoo produces from random packages I'm not using
03:41:40 <chrisdone> what reasons might there be for it to be incredibly slow at doing it?
03:41:41 <SamB> Workybob: I think hackage should be doing the building!
03:41:43 <ivanm> Workybob: yes, but if you're trying to find a library that does something... *shrug*
03:41:51 <ivanm> they both have pluses and minuses
03:41:54 <Workybob> ivanm: true true
03:41:57 <Workybob> SamB: plausable
03:42:03 <Workybob> IIRC it's just an extra option to hackage
03:42:03 <ivanm> chrisdone: if there's a lot of files to link?
03:42:10 <Workybob> so it should be easy enough surely?
03:42:11 <SamB> chrisdone: the incredibly large number of object files, tied with the slowness of GNU ld in that situation
03:42:20 <chrisdone> how much is " a lot"?
03:42:21 <Workybob> haddock*
03:42:31 <ivanm> SamB: so you're saying we need to use non-GNU ld to speed it up?
03:42:37 <chrisdone> SamB: how do I know how much is incredibly large?
03:42:44 <ivanm> chrisdone: how many do you have that it's taking so long?
03:42:48 <ivanm> as in, what are you building?
03:42:49 <SamB> chrisdone: well, if base was made with -fsplit-objects -- a lot
03:42:52 <ivanm> it normally doesn't take long for me...
03:42:53 <dcoutts_> Workybob: it's a matter of hackage building hoogle input files
03:43:02 <chrisdone> ivanm: how do I count the number of object files?
03:43:11 <ivanm> chrisdone: what are you building?
03:43:21 <quicksilver> ghc takes a very long time to link, compared to most other software development systems
03:43:23 <ivanm> because for haskell stuff, you have one object file per module
03:43:27 <chrisdone> many things
03:43:29 <quicksilver> I agree entirely with chrisdone.
03:43:32 <ivanm> quicksilver: oh? why is that?
03:43:39 <SamB> chrisdone: for a first approximation, count the files in libHSbase.a
03:43:42 * ivanm doesn't really bother timing it
03:43:54 <quicksilver> because it splits libraries down into lots of small files
03:44:00 <quicksilver> which isn't really a case GNU ld is optimised for
03:44:01 <ivanm> ahhh
03:44:05 <quicksilver> (or, indeed, OSX ld either)
03:44:12 <ivanm> quicksilver: so it's not that the linking is slow, there's just a lot to link?
03:44:21 <SamB> quicksilver: oh, they don't use GNU ld on OS X?
03:44:25 <quicksilver> SamB: no.
03:44:30 <SamB> didn't know that
03:44:34 <int-e> chrisdone: ar t /opt/ghc-6.11/lib/ghc-6.11.20090218/base-4.0.0.0/libHSbase-4.0.0.0.a | wc --> 10724 here
03:44:51 <dcoutts_> chrisdone: are you on linux? if you've got binutils older than 2.17 then it can be quite slow with .a files containing 10,000's of .o files
03:45:09 <quicksilver> SamB: darwin has its own executable format. it might be derived from the NeXT linker, but I'm not sure.
03:45:30 <chrisdone> I am using ubuntu hardy. what command can I run to query the version of binutils?
03:45:48 <bremner> chrisdone: apt-cache policy binutils
03:45:54 <quicksilver> dpkg -s binutils
03:46:15 <chrisdone> it says 2.18.1~cvs20080103-0ubuntu1
03:46:32 <pejo> quicksilver, it says "Apple Computer, Inc. version cctools-622.5.obj~13" here. So hard to tell.
03:46:52 <ivanm> quicksilver: so you're saying we need a new haskell-specific linker?
03:47:22 <dcoutts_> chrisdone: the other reason it'll be slower compared to some other systems is that it's doing static linking, so for big projects it's generating a large executable file, which is a lot of disk IO
03:47:44 <kohwj> has blogging your haskell experiences helped you learn the language?
03:47:47 <chrisdone> since changing hard drives from an 80GB OK-ish one to a crappy 20GB one, my build times have gone from 5-10 seconds to about 5 minutes. is there nothing I can do about this other than buying new hardware?
03:48:04 <quicksilver> ivanm: not really haskell-specific, but one which scales better, perhaps.
03:48:14 <dcoutts_> chrisdone: other systems often use dynamic linking, which means less disk IO
03:48:18 <quicksilver> ivanm: I think C++ has a related problem (linking very slow)
03:48:28 <dcoutts_> quicksilver: using shared libs will solve it
03:48:30 <quicksilver> chrisdone: link to a RAM disk.
03:48:35 <chrisdone> dcoutts_: can it be configured to not do dynamic linking?
03:48:44 <chrisdone> er, static linking
03:48:52 <dcoutts_> chrisdone: not yet, it's not finished
03:48:53 <pejo> quicksilver, didn't someone at google write an elf linker in C++ to .. well, whatever they do.
03:48:53 <ivanm> not yet
03:49:08 <dcoutts_> pejo: yes, (go)ld
03:49:09 <ivanm> IIRC, one issue is that you _have_ to do static linking in windows
03:49:21 <chrisdone> why?
03:49:29 <SamB> dcoutts: so you don't think it would help to link in the GHCi .o instead of the .a ?
03:49:31 <dcoutts_> ivanm: well no but finding .dll files is a pita on windows
03:49:41 <ivanm> close enough ;-)
03:49:49 <cizra> chrisdone: /dev/shm/ is probably a RAM-disk ready for using
03:49:52 <dcoutts_> SamB: maybe
03:50:12 <ivanm> tmpfs! ;-)
03:50:28 <SamB> I remember lambdabot used to be much faster to load dynamically than to link, for me, actually ...
03:50:50 <quicksilver> SamB: yes, witness how fast ghci is
03:50:52 <SamB> so much so that I attempted to restore this functionality
03:50:59 <quicksilver> SamB: (even at loading compiled .o files)
03:51:10 <SamB> quicksilver: especially then
03:51:17 <wli> ramdisks are another matter entirely
03:51:22 <SamB> because it doesn't have to go through and parse/typecheck/compile everything
03:51:34 <wli> The distro convention is for /dev/shm/ to be tmpfs or ramfs.
03:51:34 <SamB> also I don't think ramdisks help much in Linux
03:52:24 <wli> ramdisks are ram-backed bdevs, not ram-backed fs's.
03:52:51 <SamB> wli: is that so ?
03:52:55 <chrisdone> what is a bdev?
03:52:59 <SamB> I don't think that's a universal truth
03:53:03 <SamB> chrisdone: block device
03:53:16 <ivanm> whereas a bhead is a block-head? :p
03:53:21 <SamB> for instance, is that true on Amiga ?
03:53:24 <chrisdone> is my hard drive a block device?
03:53:31 <SamB> chrisdone: yes
03:53:48 <SamB> as is your floppy
03:53:51 <bremner> chrisdone: probably several from the OS view
03:53:56 <SamB> and I guess your CD
03:54:02 <wli> Um... the kernel driver for ramdisks is a block device driver. The kernel drivers for tmpfs and ramfs are filesystem drivers.
03:54:35 <wli> And /dev/shm/ is a directory, not a block special file.
03:54:48 <SamB> wli: we might mean any one of those things when we say "ramdisk"
03:54:54 <wli> Which part of this is ambiguous?
03:55:08 <SamB> or we might be talking about one of those hardware devices ;-P
03:55:08 <chrisdone> what does 'shm' mean?
03:55:11 <wli> There is no ambiguity about what ramdisks are.
03:55:12 <SamB> shared memory
03:55:21 <SamB> wli: yes, there is!
03:55:40 <dcoutts_> SamB: if the amiga did it's ramdisk by running it's ordinary file system driver on a block of memory then that's not quite the same as a separate file system implementation that uses malloc()
03:55:49 <wli> The usual terminological tactic.
03:56:19 <SamB> dcoutts: I don't think it used an ordinary fs driver
03:56:55 <SamB> wli: look! http://www.amazon.com/Gigabyte-GC-RAMDISK-i-RAM-Hard-Drive/dp/B000EPM9NC
03:57:09 <dcoutts_> SamB: so it's separate from if you had a "real" ram disk, ie physical hardware
03:57:19 <wli> In some kernels there is less of a distinction between block device drivers and filesystem drivers.
03:57:37 <wli> (e.g. NT)
03:58:04 <SamB> wli: well, some of us refer to any filesystem OR block device backed by RAM as a ramdisk
03:58:40 <SamB> that's not an exclusive-or
03:59:10 <dcoutts_> SamB: the other point I was going to make is that while linux file systems delay writes, so you can seek all over a file writing while it's in cache, without generating real disk seeks, the same is not true for file metadata like size/extents
03:59:32 <dcoutts_> SamB: it's only more recent linux file systems like ext4 etc that do delayed allocation of extents
03:59:53 <SamB> dcoutts: hmm.
03:59:59 <dcoutts_> I believe those allow you to make a temp file, write, read and delete it without necessarily ever hitting the disk
04:00:05 <wli> Ramdisk means something very specific in Linux, i.e. drivers/block/brd.c
04:00:18 <SamB> wli: not all of us are kernel hackers
04:00:46 <dcoutts_> SamB: nevertheless, the distinction is fairly clear. They're quite different levels of abstraction.
04:01:45 <SamB> there are, yes, at least three different ways of implementing what I call a ramdisk ...
04:02:08 <dcoutts_> -> #haskell-overflow :-)
04:02:12 <wli> RAM-backed pseudofilesystems typically don't even commit metadata to the RAM backing them; they just use what the kernel typically caches for disk-backed filesystems as metadata.
04:02:37 <SamB> wli: hmm ?
04:02:39 <wli> i.e. kernel data structures
04:03:09 <SamB> the kernel usually caches those ?
04:03:31 <SamB> what the heck
04:03:31 <wli> Disk-backed filesystems keep metadata on disk somewhere. They get marshalled into kernel data structures and vice-versa.
04:03:38 <SamB> Amiga can boot from a ramdisk ?
04:03:45 <Adamant> yes
04:03:52 <wli> RAM-backed filesystems do not use the analogous process for their metadata.
04:04:05 <SamB> wli: true
04:04:10 <wli> They never marshal the metadata to/from the backing RAM.
04:04:26 <SamB> hmm.
04:04:30 <SamB> they might!
04:04:40 <dcoutts_> but that would be pointless :-)
04:04:44 <SamB> not all of them need be as efficient as eachother
04:04:45 <dcoutts_> (unless you're compressing)
04:04:50 <wli> There is one exception: tmpfs. Hugh Dickins arranged for it to do so at my request so that tmpfs could swap out metadata.
04:05:04 <daf> wli: hmm, I thought there was no guarantee that the fs cache kept the metadata around
04:05:22 <SamB> daf: presumably theres some way to pin it
04:05:25 <SamB> in Linux
04:06:10 <wli> daf: It can be pinned for the duration of various operations. The pseudofilesystems just pin them immediately after creation and un-pin them immediately prior to destruction.
04:06:27 <daf> ah, right
04:06:38 <wli> (The pinning just consists of elevating the reference count.)
04:07:07 * SamB wonders if you can get cycles
04:07:07 <daf> I guess the alternative would be to somehow flag the file system so that it was never cached
04:08:09 <wli> daf: There's no double caching. The backing RAM is actually just the same sort of affair used to cache file data in disk-backed filesystems, once again artificially kept live.
04:08:48 <SamB> anyway ... what were we talking about ?
04:08:56 <SamB> oh yeah, -fsplit-objects kills ld(1)
04:09:05 <wli> daf: In that case refcounts aren't elevated, but rather, the filesystem is flagged as memory-backed so eviction is never attempted.
04:10:13 <wli> tmpfs is once again an exception; it has its own drivers to marshal data to/from swap.
04:12:17 * SamB for some reason thinks of the zipper fs and boggles at how a purely-functional datastructure can possibly have multi-threaded access ...
04:15:02 <daf> wli: aye. I meant that that would b the alternative way to avoid double-caching. but since it makes the fs code simpler, doing is with the fs cache makes sense.
04:19:09 <Furious_Joe> I tried to compile something that uses Network, and when ghc links it I get heaps of undefined reference errors. Can anyone help?
04:19:21 <Axman6> did you use ghc --make?
04:19:26 <SamB> Furious_Joe: what undefined reference errors ?
04:19:40 <quicksilver> almost certainly Furious_Joe did not use --make
04:19:44 <quicksilver> and the solution is to use it :)
04:19:50 <Furious_Joe> I didn't use --make, give me a second
04:20:12 <Furious_Joe> damn you guys are good
04:22:26 <ivanm> is there any time that you _want_ to build modules seperately rather than using --make ?
04:23:00 <quicksilver> cabal doesn't use --make, I don't think
04:23:05 <quicksilver> I don't know why not though
04:23:13 <dcoutts_> erm, yes it does
04:23:19 <ivanm> heh, about to say...
04:23:25 <quicksilver> if you were compiling a mixed language project you might want not to use it.
04:23:32 <ivanm> quicksilver: true
04:23:37 <quicksilver> but honestly I think it not being the default confuses more people than it helps :)
04:23:37 <dcoutts_> quite, cabal does but should not use --make
04:23:43 <ivanm> or using a makefile or something
04:23:52 <ivanm> dcoutts_: why shouldn't it?
04:24:01 <quicksilver> ivanm: normally, even if you built the modules separately with "ghc -c"
04:24:08 <quicksilver> ivanm: you would still use ghc --make for the final step
04:24:10 <ivanm> because of module Foo might not be in Foo.[l]hs ?
04:24:19 <ivanm> quicksilver: *nod*
04:24:24 <quicksilver> (because it automatically finds the packages you need)
04:24:25 <dcoutts_> ivanm: doesn't scale to pre-processors, isn't fast enough and does not parallelise
04:24:29 <ivanm> but how many people bother to use ghc -c ?
04:24:35 <ivanm> dcoutts_: ahhhh
04:24:38 <quicksilver> dcoutts_: "isn't fast enough" ?
04:24:45 <ivanm> dcoutts_: well, you only have yourself to blame for not fixing it :p
04:25:03 <dcoutts_> quicksilver: no, you'd use ghc foo.o -package bar -o baz, not --make.
04:25:08 <dcoutts_> quicksilver: for linking I mean
04:25:39 <dcoutts_> quicksilver: how long does ghc --make take to notice there is nothing to do in a large package?
04:25:51 * ivanm raises his hands
04:25:54 <ivanm> about yay long?
04:25:55 <ivanm> :p
04:26:13 <dcoutts_> ivanm: yes, and that's too long
04:26:19 <dcoutts_> compare that to make
04:26:32 <ivanm> wow, you don't even know how far apart my hands were and it's too long! :o
04:26:33 <dcoutts_> it can stat 1000 files and do nothing nearly instantly
04:26:38 <ivanm> heh
04:26:50 <ivanm> "make: good at doing nothing!"
04:26:50 <ivanm> ;-)
04:26:57 <dcoutts_> it's true! :-)
04:27:04 <quicksilver> dcoutts_: ah, right, understand your point now.
04:27:05 <quicksilver> yes.
04:27:06 <dcoutts_> it's very good at that
04:27:15 <ivanm> and you want haskell software to be good at doing nothing as well?
04:27:22 <dcoutts_> yep :-)
04:27:27 <dcoutts_> well, a Haskell build system
04:27:31 <ivanm> so we need to release a no-op library?
04:27:42 <dcoutts_> ivanm: now you're just being silly! :-)
04:27:58 <ivanm> and to optimise it, we can use bytestrings... bytestrings are fast, right? :p
04:28:03 <ivanm> dcoutts_: silly? moi? ;-)
04:28:09 <nominolo> dcoutts_: i also want to make sure that haskell's proprocessors can all be run in stream-processor mode
04:28:20 <nominolo> dcoutts_: very important for IDE stuff
04:28:26 <Axman6> ivanm: bytestrings or parallel arrays
04:28:29 <dcoutts_> nominolo: hmm? what do you mean exactly?
04:28:44 <Axman6> and MVars, because they're faster than mutexes
04:28:52 <dcoutts_> nominolo: just stdin -> stdout?
04:28:57 <nominolo> dcoutts_: yep
04:28:58 <dcoutts_> nominolo: that's not possible in general
04:29:10 <nominolo> why not?
04:29:13 <dcoutts_> nominolo: but we can easily prepare a source tree of pre-processed files
04:29:16 <nominolo> multiple inputs?
04:29:40 <dcoutts_> nominolo: having to invoke things like gcc/cpp. It needs an input file location to search for things relative to it.
04:30:11 <nominolo> hmpf.  the "finding" step should be abstracted
04:30:20 <nominolo> too bad we can't do that for legacy code
04:30:26 <dcoutts_> nominolo: that's doable for pure Haskell pre-processors
04:30:29 <dcoutts_> not for FFI tools
04:30:37 <nominolo> yeah
04:30:45 <dcoutts_> nominolo: I guess this is because for an IDE you want to be able to build without saving the file
04:31:00 <nominolo> dcoutts_: exactly
04:31:44 <dcoutts_> nominolo: one trick would be to save temp files into another dir and put that on the search path first
04:31:45 <nominolo> dcoutts_: and, ATM, ghc doesn't allow proprocessing files in memory
04:31:54 <nominolo> dcoutts_: yes, but that's messy
04:32:17 <dcoutts_> nominolo: but it'd work with all pre-processors we support
04:32:39 <dcoutts_> nominolo: I'd go for a caching approach rather than an all-in-memory approach
04:32:51 <dcoutts_> ie generate .hs files on disk
04:32:59 <dcoutts_> have ghc api (re)load them
04:33:20 <nominolo> dcoutts_: i'd rather have an abstraction there, so i can use a database or the network
04:33:30 <dcoutts_> trying to abstract out the files inbetween is hard
04:34:00 <dcoutts_> it only works for preprocessors we have any control over
04:34:18 <nominolo> dcoutts_: also, we have to manually re-run the preprocessor, because ghc won't notice when, say, the .y file has been updated
04:34:39 <dcoutts_> nominolo: no, that's what the a future cabal dependency based build system is for
04:35:12 <nominolo> dcoutts_: we've been waiting for that for a while now ;)
04:35:22 <dcoutts_> nominolo: it'll be a while yet too I'm afraid
04:35:34 <dcoutts_> it's not a small job
04:36:03 <nominolo> apropros job.  what are you doing these times?
04:36:04 <chrisdone> is the value of `undefined' said to be _|_?
04:36:23 <nominolo> chrisdone: _|_ is any form of undefined/error/non-termination
04:36:43 <Axman6> undefined terminates >_>
04:36:50 <dcoutts_> nominolo: finishing my thesis and working with Well-Typed
04:38:44 <Axman6> any one ever used the book C Programming: a modern approach?
04:39:25 <bremner> its right beside "military intelligence" and "rational religion" on my shelf :-)
04:40:06 <SamB> Axman6: is that joke based on the the title alone?
04:40:11 <SamB> er. bremner
04:40:13 <SamB> sorry
04:40:18 <bremner> yeah, call me shallow
04:40:19 <SamB> I can't even blame that on the swapping
04:40:47 * bremner doesn't even hate C
04:40:52 * SamB wonders what such a book should be about
04:40:53 <Axman6> it's a nice book. puts an influence on not writing hackish, un readable code
04:41:05 <mjrosenb> is there a reason why there isn't a State interface to Random?
04:41:15 <dcoutts_> mjrosenb: but there is!
04:41:19 <mjrosenb> or have i been unable to find one?
04:41:21 <mjrosenb> efb
04:41:27 * SamB wonders if it should include some of augustss' blog entries
04:41:35 <dcoutts_> mjrosenb: there's a package for it on hackage
04:41:50 <Axman6> @hoogle State
04:41:50 <lambdabot> module Control.Monad.State
04:41:50 <lambdabot> Test.HUnit.Base data State
04:41:50 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
04:42:11 <mjrosenb> dcoutts_: ok, so it won't come with ghc
04:42:57 <hackage> Uploaded to hackage: monadiccp 0.3
04:45:54 <Axman6> mjrosenb: only the most useful, base libraries tend to come with ghc
04:48:04 <mjrosenb> Axman6: this seems quite useful
04:48:18 <mjrosenb> at least the functionality that i want is 2 lines of code
04:48:21 <mjrosenb> well
04:48:22 <mjrosenb> four
04:48:36 <mjrosenb> but two of them are type signatures that i don't think i can avoid
04:48:41 <Axman6> well yes, but it's built up from the basis of random right? it's a wrapper on top of random
04:48:58 <mjrosenb> randomS = State random
04:49:43 <mjrosenb> gah
04:50:04 <mjrosenb> it also looks like i might run into random's issues
04:52:41 <chrisdone> how does one get a new account on the Haskell wiki? I've already got one, I'm just curious. is there some network of trust thing going on or do people just have to ask a wiki admin?
04:54:58 <nominolo> chrisdone: isn't there a sign-up button?
04:56:22 <Axman6> new account creation has been disabled
05:03:17 <rainmann> is it possible to flip a type constructors arguments to produce a new type constructor?
05:04:50 <daf> yes
05:04:52 <dcoutts_> type Flip t a b = t b a
05:04:52 <quicksilver> rainmann: no but yes
05:05:10 <Axman6> data Pair a b = P a b; data Pair' b a = flip P?
05:05:11 <Axman6> heh
05:05:32 <quicksilver> there is a newtype alternative too
05:05:40 <quicksilver> which requires wrapping unwrapping
05:06:05 <rainmann> ok ta
05:22:13 <kohwj> has blogging your haskell experiences helped you learn the language?
05:22:52 <Axman6> not really
05:25:03 <kohwj> Axman6: hm... i theorise that two things that come out from blogging help: firstly, the act of communicating requires deeper thought, and secondly, discussions.
05:25:53 <lilac> dibblego: if you want to declare instances for a flipped type constructor, you'll need the 'newtype' variant
05:25:59 <mjrosenb> gah, i have randomR (0,5) in legitamate gode
05:26:00 <Axman6> kohwj: well in my case, it's caused me to actually write comments (and haddock them too) in some software i've been writing. and to also thing about the interface
05:26:17 <dibblego> lilac, yeah I figured that thanks
05:29:03 <chrisdone> lunabot: source
05:40:42 <chrisdone> what is it called in general pattern match terms when a pattern containing the same term twice means that these two must be equal? like (X,X) matches (x,x) but not (x,y)
05:41:13 <quicksilver> chrisdone: well it's no longer unification then, as far as I know
05:41:26 <Workybob> that sounds like unification to me
05:41:26 <mjrosenb> chrisdone: unification
05:41:39 <quicksilver> hmmm, yes, it is.
05:41:46 <quicksilver> what was the word I meant.
05:41:54 <chrisdone> why is it unification?
05:41:54 <quicksilver> it *is* unification, it's no longer...
05:42:03 <mjrosenb> quicksilver: nice save :-p
05:42:04 <quicksilver> no longer simple structural recursion?
05:42:27 <quicksilver> no long a simple constructor match?
05:42:28 <quicksilver> hmm.
05:42:34 <chrisdone> unification has free variables on both sides, I'm talking about pattern matching with free variables on only one side
05:42:38 <quicksilver> I don't know what the word is for what it isn't ;)
05:43:06 <chrisdone> what is the difference between pattern matching and unification?
05:44:20 <chrisdone> what is this syntax called? foo | True = ...
05:44:57 <mjrosenb> chrisdone: guarded patterns, i think
05:45:04 <chrisdone> thanks
05:45:54 <chrisdone> what is the difference between pattern matching and unification?
05:47:22 <quicksilver> chrisdone: simple pattern matching never has additional equality constrains
05:47:32 <quicksilver> (like the two occurrences of x in your example)
05:47:38 <quicksilver> it's completely structurally guided
05:47:57 <quicksilver> you just match nested constructors, and assign names to some of the sub-structures.
05:49:07 <chrisdone> is it still pattern matching if I add the multiple occurences constraint?
05:50:14 <quicksilver> I don't know if pattern matching has an accepted technical definition.
05:50:18 <quicksilver> But I'd say "no"
05:50:29 <quicksilver> that's not "simple" or "haskell-style" pattern matching, at least.
05:50:44 <chrisdone> but it is pattern matching nonetheless?
05:51:09 <quicksilver> I don't know.
05:54:07 <doserj> chrisdone: it is sometimes called "non-linear pattern matching"
05:55:06 <chrisdone> doserj: if (?x a ?x) matches (q a q), is that a non-linear pattern match?
05:55:32 <doserj> as far as I understand it, yes.
05:55:49 <chrisdone> does GHC support an extension for non-linear pattern matching?
05:56:07 <doserj> no
06:04:57 <chrisdone> quicksilver: incase you are interested in an exampl, SICP has a non-linear pattern matcher for matching patterns against records in a logic database: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_Temp_668
06:06:24 <quicksilver> nice.
06:07:26 <CTA> Heyy
06:09:35 <blackh> Morning/afternoon/evening CTA!
06:10:08 <CTA> Haii (: - 14.10
06:10:09 <chrisdone> blackh: are people who live in the part of the world where it is night inferior to you?
06:10:34 <blackh> That would mean I am inferior to myself!
06:10:36 <CTA> 2.10 pm =D
06:10:46 <blackh> 03:10 AM :)
06:11:09 <mauke> you are not the real chicago transit authority
06:20:07 <dolio> Anyone suspect that Bulat's C++ code doesn't do anything at runtime?
06:20:23 <CTA> Bulat?
06:20:49 <dolio> "movabsq $499999999500000000, %rsi" is suspicious, right?
06:21:05 <CTA> btw what's %s?
06:21:37 <mauke> ECONTEXT. url?
06:22:05 <mmorrow> lol
06:22:17 <lilac> CTA: %s in a printf format string means "insert the next argument (which is a string) here"
06:22:34 <lilac> CTA: %s may also be short for 'percentages'
06:22:44 <dolio> mauke: http://www.mail-archive.com/haskell-cafe@haskell.org/msg54329.html
06:22:44 <chrisdone> mmorrow: ou est la lunabot source
06:23:01 <mmorrow> chrisdone: the luna src is at:
06:23:14 <mmorrow> (one sec)
06:23:30 <mmorrow> http://moonpatio.com/repos/luna/
06:23:36 <chrisdone> thanks
06:23:38 <mmorrow> do you want the bot source itself?
06:23:44 <mmorrow> slash the evaluator src?
06:24:00 <CTA> I thought printf was C?
06:24:00 <chrisdone> I was considering running the bot in another channel
06:24:14 <mmorrow> (neither use that version of "luna", but an older way-not-organized version)
06:24:16 <CTA> So you can do printf %d integerVariable?
06:24:41 <chrisdone> mmorrow: where is the source for the lunabot sat here in #haskell?
06:24:46 <mmorrow> chrisdone: cool, i'll see if i can get it extracted from itself and into a minimally working repo
06:24:49 <Axman6> printf "%d" integer
06:25:02 <Axman6> > printf "%d" 1 :: String
06:25:03 <quicksilver> CTA: printf is indeed C, but someone wrote a haskell printf.
06:25:03 <lambdabot>   "1"
06:25:09 <quicksilver> as a rule, I don't recommend it.
06:25:14 <chrisdone> quicksilver: why?
06:25:23 <Axman6> > printf "%d %f" 1 pi :: String
06:25:24 <lambdabot>   "1 3.141592653589793"
06:25:32 <quicksilver> because it has a clever buy annoying type class overloaded interface
06:25:38 <mmorrow> the TH printf is super swell
06:25:46 <quicksilver> s/buy/but/;
06:25:55 <chrisdone> quicksilver: why is it annoying?
06:26:01 <mauke> argh
06:26:06 <mauke> another printf bug
06:26:09 <CTA> so is that how you would output variables? not putStrLn?
06:26:23 <quicksilver> because you often have to expicitly annotate types
06:26:27 <Axman6> sometimes it's easier to use printf
06:26:27 <quicksilver> or get weird errors if you don't.
06:26:39 <quicksilver> CTA: personally, I would use putStrLn.
06:26:41 <Axman6> :t printf
06:26:42 <lambdabot> forall r. (PrintfType r) => String -> r
06:26:48 <quicksilver> Axman6: yes, sometimes it is easier.
06:26:55 <Axman6> @src PrintfType
06:26:55 <lambdabot> Source not found. Maybe you made a typo?
06:27:09 <CTA> how do you output var's with putStrLn?
06:27:19 <Axman6> using show
06:27:26 <lilac> putStrLn $ "foo is " ++ show foo ++ ", bar is " ++ show bar
06:27:27 <Axman6> > show 139712412
06:27:28 <lambdabot>   "139712412"
06:27:32 <Axman6> > show 139712412.23509726
06:27:33 <lambdabot>   "1.3971241223509726e8"
06:27:42 <Axman6> > show "sup dawg"
06:27:44 <lambdabot>   "\"sup dawg\""
06:27:56 <CTA> you have to: using show?
06:28:14 <Axman6> you can use print, which is putStrLn . show
06:28:59 <quicksilver> CTA: you putStrLn strings. You need some way to represent the contents of your variable as a string.
06:29:10 <quicksilver> show is one way to do that which works for many types.
06:29:14 <quicksilver> of course it's not the only way.
06:29:41 <mmorrow> , $(printf "%s %d") omg" 2001
06:29:42 <lunabot>  luna: lexical error in string/character literal at end of input
06:29:46 <Axman6> > printf "%-10.5f" pi
06:29:48 <lambdabot>   Add a type signature
06:29:49 <mmorrow> , $(printf "%s %d") "omg" 2001
06:29:51 <lunabot>  "omg 2001"
06:29:55 <Axman6> > printf "%-10.5f" pi :: String
06:29:56 <lambdabot>   "3.14159   "
06:29:56 <mmorrow> , $(printf "%s %d") "omg"
06:29:58 <lunabot>  luna: No instance for (GHC.Show.Show (a[a7er] -> GHC.Base.String))
06:30:04 <Axman6> > printf "%10.5f" pi :: String
06:30:05 <lambdabot>   "   3.14159"
06:30:25 <mmorrow> all my printf does is %s and %d :(
06:30:32 <Axman6> ok, i have no reason to be awake right now. night all
06:33:21 <CTA> anyone here created a game in Haskell?
06:33:24 <chrisdone> print $ "Pi is " « Float 10 5 pi « ", an integer: " « 10
06:33:29 <chrisdone> that would be cool ^
06:33:39 <mauke> no, it wouldn't
06:33:42 <chrisdone> why?
06:33:49 <mauke> reminds me of C++ :|
06:33:54 <quicksilver> chrisdone: how is that qualitatively different from:
06:33:55 <chrisdone> so?
06:34:04 <mauke> C++ makes me rage
06:34:15 <mauke> rage leads to the dark side
06:34:17 <quicksilver> putStrLn $ "Pi is" ++ showFloat 10 5 pi ++ ", an integer " ++ show 10
06:34:31 <quicksilver> (answer, just because of having to type 'show' before 10, but who cares about that?)
06:34:44 <rohan> i am following the haskell in 5 steps tutorial, but when i try to compile A.hs program, i get Failed to load interface for `Control.Parallel':
06:34:54 <rohan> how do i get that module? i am using ubuntu 8.04 which has ghc 6.8.x
06:35:04 <quicksilver> apt-get install libghc6-parallel-dev
06:35:20 <rohan>  thanks quicksilver :)
06:35:27 <dolio> Anyhow, in this case, %rsi is the name of the register that the value 499999999500000000 is being loaded to, which is itself supposed to be the result of the loop Bulat is using to show the difference between the speed of code generated by GCC and GHC.
06:35:27 <chrisdone> quicksilver: it depends how often I have to write show
06:35:34 <dolio> Not a printf formatter.
06:35:44 <rohan> quicksilver: umm there is no such package
06:36:50 <CTA> is it only the "hard to get into" uni's that teach Haskell?
06:37:09 <dolio> It's the ones that aren't in the US.
06:37:22 <cizra> CTA: I'm currently writing a game in Haskell.
06:37:25 <bremner> CTA: no, but you might only find it in a programming languages survey course
06:37:26 <rohan> CTA: are there even unis that teach haskell?
06:37:37 <rohan> quicksilver: oh ok my bad, it's not there in 8.04, but present in 8.10
06:37:37 <cizra> rohan: Mine does
06:37:39 <CTA> I heard so
06:37:46 <CTA> cizra where you live
06:38:04 <blueonyx> <- had haskell
06:38:04 <rohan> cizra: and which uni?
06:38:25 <cizra> CTA: Estonia, Tallinn Technical University. Haskell was just a small course for 1/4 of the CS students.
06:38:41 <CTA> I live in England
06:38:53 <cizra> Well, commuting's gonna be expensive then.
06:39:00 <rohan> lol
06:39:16 <mmorrow> chrisdone:
06:39:17 <chrisdone> quicksilver: I might prefer join and a list
06:39:18 <mmorrow> , [$here|pi is $(pi), and [0..4] is $([0..4])|]
06:39:20 <lunabot>  "pi is 3.141592653589793, and [0..4] is [0,1,2,3,4]"
06:39:28 <CTA> Camebridge does I think
06:39:34 <CTA> --e
06:40:03 <chrisdone> Glasgow teaches a language embedded in Haskell
06:40:17 * CTA wants plain Haskell
06:40:19 <CTA> lol
06:40:24 <Cheshire> , [$here|[$here\|pi\|] is $([$here\|pi\|])|]
06:40:26 <lunabot>  "[$here|pi|] is [$here|pi|]"
06:40:32 <Cheshire> , [$here|[$here\|pi\|] is $([$here|pi|])|]
06:40:33 <lunabot>  luna: parse error on input `|]'
06:40:35 <bremner> If I had the right book, I would teach programming languages using haskell the whole term.  But right now I am just using it for bits and pieces
06:40:37 <Cheshire> , [$here|[$here\|pi\|] is $([$here|pi\|])|]
06:40:39 <lunabot>  "[$here|pi|] is [$here|pi|]"
06:40:49 <mmorrow> it doesn't work with quasiquoters/TH inside (YET!)
06:40:53 <chrisdone> expert bbcode
06:41:03 * Cheshire heard you like quasiquotation
06:41:11 <mmorrow> Cheshire: you only have to escape the trailing "|]"
06:41:48 <mmorrow> , [$here| $([$here| $(pi) \|]) |]
06:41:50 <lunabot>  " [$here| $(pi) |] "
06:41:52 <CTA> cizra may I see some of that game code?
06:41:56 <pejo> CTA, programmign courses teach a lot of useful stuff, exactly which languge they use isn't that important, you can always switch language after the course.
06:42:00 <mmorrow> , eval ([$here| $([$here| $(pi) \|]) |])
06:42:03 <lunabot>  <<[Char]>>
06:42:06 <cizra> CTA: Sure, but it's 1) very simple, 2) incomplete, 3) buggy
06:42:15 <mmorrow> , (fromDyn . eval) ([$here| $([$here| $(pi) \|]) |]) :: Maybe String
06:42:17 <CTA> 4) that's fine
06:42:17 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe GHC.Base.String'
06:42:20 <mmorrow> , (fromDynamic . eval) ([$here| $([$here| $(pi) \|]) |]) :: Maybe String
06:42:23 <lunabot>  Just " 3.141592653589793 "
06:42:27 <mmorrow> :)
06:42:41 <cizra> CTA: http://pastebin.com/f305f74b3
06:42:57 <hackage> Uploaded to hackage: HsSVN 0.4.1
06:42:57 <hackage> Uploaded to hackage: HsHyperEstraier 0.3.1
06:42:57 <hackage> Uploaded to hackage: Lucu 0.2.1
06:42:57 <hackage> Uploaded to hackage: HsOpenSSL 0.5.2
06:43:01 <mmorrow> , [$here| $(eval [$here| $(pi) \|]) |]
06:43:03 <lunabot>  " eval [$here| $(pi) |] "
06:43:08 <mmorrow> grr
06:43:47 <CTA> o.O /me needs to read some more tuts
06:44:10 <cizra> CTA: I'm a newbie as well (=
06:44:26 <CTA> (: where you learning from? LYAH/RWH?
06:44:28 * chessguy_work hates it when you figure out an abstraction, and then you realize that you can't write anything in terms of that abstraction anyway :(
06:44:30 <chrisdone> , [$here|SELECT apple FROM bear WHERE knows_what_apples_is = TRUE AND size > $(536)|]
06:44:32 <lunabot>  "SELECT apple FROM bear WHERE knows_what_apples_is = TRUE AND size > 536"
06:44:41 <chrisdone> hmm, nifty
06:44:46 <chrisdone> I might use this
06:45:00 <chrisdone> can it do cleverer stuff like padding and decimal places?
06:45:20 <cizra> CTA: Bugging innocent bystanders and lots of different tutorials.
06:45:35 <mauke> , [$here|SELECT apple FROM bear WHERE knows_what_apples_is = TRUE AND size > $(printf "%.3f" 536 :: String)|]
06:45:38 <lunabot>  luna: Couldn't match expected type `t -> GHC.Base.String'
06:46:06 <mmorrow> , let knows_what_apples_is = False; size = 42 in [$here|SELECT apple FROM bear WHERE knows_what_apples_is = TRUE AND $(size > 536)|]
06:46:08 <lunabot>  "SELECT apple FROM bear WHERE knows_what_apples_is = TRUE AND False"
06:46:19 <chrisdone> , [$here|$("")|]
06:46:21 <lunabot>  "\"\""
06:46:31 <CTA> haha lol, I wish I could take a programming course NOW @ 15
06:46:35 <mmorrow> , let knows_what_apples_is = False; size = 42 in [$here|SELECT apple FROM bear WHERE $(knows_what_apples_is == True) AND $(size > 536)|]
06:46:37 <lunabot>  "SELECT apple FROM bear WHERE False AND False"
06:46:54 <chrisdone> but mmorrow,
06:46:58 <chrisdone> how does a bear know what apples is?
06:47:04 <mmorrow> duh!
06:47:11 <rohan> i'm absolutely new to haskell, and reading YAHT (yet another haskell tutorial). is that a good place to start?
06:47:14 <lilac> mmorrow: also, isn't selecting the apple out of a bear going to be messy?
06:47:17 <chessguy_work> shouldn't it be knows_what_apples_are ?
06:47:22 <chrisdone> rohan: I don't think so. Real World Haskell is a good place to start
06:47:23 <mmorrow> lilac: the more the better
06:47:26 <chrisdone> chessguy_work: no
06:47:36 <mmorrow> chessguy_work: absolutely not
06:47:44 * chessguy_work scratches  his head
06:47:49 <mauke> chrisdone: http://encyclopediadramatica.com/Apples_Bear
06:48:01 <rohan> chrisdone: ok, i'll try reading that.
06:48:11 <mauke> er, d'oh
06:48:16 <mauke> s/chrisdone/chessguy_work/
06:48:43 <chessguy_work> heh. my company filter says that page is in the category "Tasteless"
06:48:53 <mmorrow> chrisdone: here is here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1450
06:49:07 <chrisdone> , [$here|$(printf "%.2f" 3.141592654)|]
06:49:09 <lunabot>  luna: Couldn't match expected type `t -> a'
06:49:22 <FunctorSalad> where can I learn me a FRP? :-(
06:49:28 <chrisdone> , [$here|$((printf "%.2f" 3.141592654)::String)|]
06:49:30 <lunabot>  luna: Couldn't match expected type `t -> GHC.Base.String'
06:49:34 <FunctorSalad> it's kinda hard to learn just from the haddock...
06:49:41 <mmorrow> chrisdone: it doesn't do fancy stuff yet
06:49:51 <chrisdone> mmorrow: it doesn't do expressions?
06:49:53 <mmorrow> iirc it doesn't even do %f
06:50:00 <mmorrow> ohh
06:50:06 <rohan> how's Learn You a Haskell?
06:50:07 <mmorrow> i thought you were trying $ty
06:50:07 <FunctorSalad> (any of them, I don't know which is most mature for UIs currently?)
06:50:27 <mmorrow> chrisdone: well, actually yeah, it doesn't do TH syntax yet
06:50:31 <chrisdone> rohan: some like it. depends on your taste
06:50:42 <mmorrow> since i haven't finished that in haskell-src-meta yet
06:50:53 <chrisdone> ok
06:51:01 <CTA> Is it hard to set GHCi up on a mac?
06:51:09 <rohan> chrisdone: ok, thanks
06:52:49 <mmorrow> , case [$here| $([0..4]) |] of " [0,1,2,3,4] " -> True; _ -> False
06:52:51 <lunabot>  True
06:52:56 <mstr> CTA: no
06:53:13 <CTA> Kk, I want one just the price is putting me off
06:53:31 <mstr> "port install ghc" ?
06:53:48 <quicksilver> CTA: get someone else to pay.
06:53:51 <cizra> GHCs are unusually cheap
06:54:15 <zachk> cizra: what by cheap do you mean free?
06:54:33 <zachk> :D
06:54:36 <cizra> zachk: Yea..
06:54:38 <Cheshire> , [$here|
06:54:39 <lunabot>  luna: lexical error in string/character literal at end of input
06:54:40 <CTA> Lol, Mam and Dad wouldn't, I'm going to try to get them to help me with a little fund for it ol..
06:54:42 <CTA> *lol
06:54:54 <Cheshire> , ) [$here|
06:54:55 <lunabot>  luna: lexical error in string/character literal at end of input
06:56:16 <mstr> CTA: mac mini or the white macbook aren't that expensive
06:56:46 <zachk> . foldr (+) 0 [1..10]
06:57:06 <zachk> how do i get luna to do that
06:57:16 <mauke> ,
06:57:16 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
06:57:52 <zachk> , foldr (+) 0 [1..10]
06:57:53 <lunabot>  55
06:58:14 <quicksilver> > foldr (+) 0 [1..10]
06:58:15 <lambdabot>   55
06:58:21 <quicksilver> and, lambdabot gives the same answer as lunabot
06:58:24 <quicksilver> what's the odds of that?
06:58:24 <mauke> > 10 * 11 `div` 2
06:58:26 <lambdabot>   55
06:58:27 <quicksilver> I smell conspiracy.
07:00:29 * dolio smells what The Rock is cookin'.
07:00:33 <cizra> > ", \"> \">\"\""
07:00:35 <lambdabot>   ", \"> \">\"\""
07:00:41 <cizra> bah. Didn't work.
07:00:53 <mauke> lern2quine :-)
07:01:18 <quicksilver> > text ", \"> \">\"\""
07:01:19 <lambdabot>   , "> ">""
07:01:36 <quicksilver> unfortunately lb's initial indent is enough to make lunabot ignore it ;)
07:02:02 <cizra> )=
07:02:03 <FunctorSalad> @botsnacks
07:02:03 <lambdabot> :)
07:02:03 <lunabot>  :)
07:02:10 <quicksilver> :)
07:02:13 <cizra> :)
07:02:32 <cizra> I'm a bot! I took my Turing last summer and passed with flying colors!
07:02:56 <mauke> @localtime preflex
07:02:57 <lambdabot> Local time for preflex is 2009-02-20 15:02WHERE IS SARAH CONNOR?
07:03:28 <dolio> What?
07:03:40 <mauke> what what
07:03:58 <mauke> hah, appropriate: Terminator 2 CMS-101-Level One OC ReMix
07:04:04 <mmorrow> you foster parents are dead!
07:04:10 <mmorrow> r
07:05:23 <cizra> http://pastebin.com/f50b9fc45
07:05:26 <cizra> Why do I get that error+
07:05:27 <cizra> ?
07:05:55 <mauke> because of the return
07:06:26 <cizra> Why don't I get that on lines 23, 24 etc?
07:06:44 <mauke> because they're not part of the return value
07:06:57 <mauke> :t (>>)
07:06:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:07:10 <mauke> and as you can see, (>>) ignores the return type of its first operand
07:07:37 <cizra> > putStrLn "foo" >> return ()
07:07:38 <lambdabot>   * Exception: "<IO ()>"
07:07:49 <quicksilver> cizra: they're all equally wrong
07:07:59 <quicksilver> cizra: it's just hte earlier ones aren't a compile error.
07:08:33 <cizra> quicksilver: Bah. Well. Should I do that putStrLn "foo" >> return () trick then?
07:08:53 <quicksilver> cizra: first, you should understand what you're doing.
07:08:59 <quicksilver> return $ putStrLn "hi there"
07:09:09 <quicksilver> is constructing the action 'putStrLn "hi there"'
07:09:12 <cizra> Well, putStrLn returns an IO ()
07:09:13 <quicksilver> but not executing it!
07:09:20 <quicksilver> just constructing it and then throwing it away
07:09:21 <quicksilver> in this case
07:09:25 <cizra> Oh, hmm.
07:09:25 <quicksilver> it has type IO ( IO () )
07:09:35 <cizra> I wondered about that one.
07:09:39 <quicksilver> an IO action which, when executed, returns an IO action which you throw away.
07:09:57 <mauke> basically, 'return' in the middle of a do block is wrong
07:10:13 <cizra> oookay. But I want to actually execute a putStrLn and then kick the bucket.
07:10:35 <mauke> what do you mean by "kick the bucket"?
07:10:44 <cizra> return from the function.
07:10:46 <Botje> unsafeKickBucket
07:10:50 <mauke> that's not what 'return' does
07:10:59 <mauke> 'return' is a virtual constructor, not a control flow thingy
07:11:04 <quicksilver> cizra: important note - return has nothing to do with returning from the function.
07:11:05 * cizra is tainted
07:11:15 <quicksilver> cizra: if that is what you want, though
07:11:27 <quicksilver> cizra: then your code would never get past line 19
07:11:38 <quicksilver> ah, no
07:11:42 <quicksilver> there is a third case
07:11:44 <quicksilver> N ->
07:11:56 <quicksilver> you need to use the third case
07:12:06 <quicksilver> case expressions don't simply 'fall off the end' like you're hoping.
07:12:12 <Hiato> Hello all, sorry to ask another question about typecasting (I just don't seem to get it), but what do I need to do to make Haskell happy about the numerical types here?[(-1)^(x `mod` 2) * (x/x+1)|x <- [1..n]] (where n is defined elsewhere)
07:12:21 <cizra> quicksilver: So, basically I'll still have to nest the thing under case N.
07:12:23 <mauke> Hiato: there are no casts
07:12:49 <mauke> Hiato: is the result supposed to be a floating point number?
07:12:54 <Hiato> er, well, perhaps my syntax is foul, but it complains about mixing fractional and integral numbers
07:12:56 <Hiato> yes
07:13:25 <cizra> quicksilver: Can I put another do-block into case? Like ... N -> do ; do other stuff
07:13:38 <Hiato> (I just need to make it alternate between positive and negative, mauke)
07:13:42 <quicksilver> cizra: http://pastebin.com/m12be7bde
07:13:50 <quicksilver> cizra: is one possible solution
07:13:53 <quicksilver> NB I haven't tested it
07:13:56 <quicksilver> but that's the idea.
07:14:10 <mauke> [(-1)^(x `mod` 2) * (x' / x' + 1) | x <- [1 .. n], let x' = fromIntegral x]
07:14:25 <cizra> quicksilver: Hah, just what I thought.
07:14:35 <Hiato> ok, thanks mauke
07:14:38 <quicksilver> Hiato: fromIntegral to upgrade from an integer type to a fractional one.
07:14:52 <quicksilver> Hiato: round/ceiling/floor to approximate a fractional type by an integer one
07:15:02 <lilac> return_in_the_style_of_other_programming_languages = callCC . const
07:15:04 <quicksilver> Hiato: realToFrac to convert from one fractional type to another
07:15:04 <Hiato> and if I wanted to have a bad style, I could just throw in the fromIntegral before all the x's
07:15:12 <Hiato> aha, I see, thanks
07:15:15 <mauke> Hiato: not the first one
07:15:21 <mauke> `mod` is for integers
07:15:24 <quicksilver> those are the most commonly used type conversions.
07:15:35 <Hiato> right, because of mod, actually, 5.1 `mod` 2.1 should work
07:15:39 <Hiato> roger that
07:15:43 <Hiato> thanks guys :)
07:16:03 <quicksilver> > 5.1 `mod'` 2.1
07:16:05 <lambdabot>   0.8999999999999995
07:16:11 <quicksilver> mod' exists for that reason.
07:16:14 <cizra> quicksilver: I'm pretty comfortable around pure code by now, but those impurities, dos and don'ts still make me sweat.
07:16:20 <quicksilver> and that example illustrates quite well why it's not the default.
07:16:33 <quicksilver> cizra: good. that attitude is the right way round ;)
07:16:43 <mauke> preflex: calc '2 5.1 % 2.1
07:16:44 <preflex>  0.11100110011001100110011001100110011001100110011001
07:16:49 <drhodes> @hoogle Integer -> Int
07:16:50 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
07:16:50 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
07:16:50 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
07:16:54 <quicksilver> > 5.1 `mod'` 2.1 :: Rational
07:16:55 <lambdabot>   9%10
07:17:04 <quicksilver> ^^ on the other hand, Rational rocks ;)
07:17:13 <opqdonut> Hiato: why do you even use mod there?
07:17:14 <quicksilver> I love that you can use decimal notation for Rational.
07:17:26 <Hiato> hrmm... [(-1)^(x `mod` 2) * (xr / xr + 1) | x <- [1 .. n], let xr = fromIntegral x] still seems to yield integral results (well, either 2 or zero)
07:17:38 <opqdonut> > [(-1)**x' * (x' / x' + 1) | x <- [1 .. n], let x' = fromIntegral x]
07:17:39 <lambdabot>   * Exception: not a number
07:17:45 <Hiato> well, as far as I understand, one cannot say (-1)^(if odd x then 1 else 0)
07:17:48 <opqdonut> hmm
07:17:50 <Hiato> or, perhaps there is a way
07:18:11 <opqdonut> Hiato: (-1)^(x `mod` 2) is just the same as (-1)^x
07:18:16 <opqdonut> when x is an integer
07:18:22 <Hiato> ah, yeah, whoops :P
07:18:40 <Hiato> still doesn't correct the other flaw, somewhere
07:18:50 <Hiato> I'm no longer getting fractions, merely 0.0 or 2.0
07:19:03 <Hiato> aha
07:19:08 <dolio> x' / x' + 1 = (x' / x') + 1
07:19:10 <Hiato> nvm, my bad, that was silly of me
07:19:15 <Hiato> yes, indeed
07:19:16 <Hiato> :P
07:19:17 <opqdonut> hehe
07:19:24 <opqdonut> and btw, why not:
07:19:53 <opqdonut> > [(-1)^^x * (x % (x + 1)) | x <- [1 .. n]]
07:19:54 <lambdabot>   * Exception: not a number
07:20:14 <opqdonut> err
07:20:18 <opqdonut> > let n = 10 in [(-1)^^x * (x % (x + 1)) | x <- [1 .. n]]
07:20:20 <lambdabot>   [(-1)%2,2%3,(-3)%4,4%5,(-5)%6,6%7,(-7)%8,8%9,(-9)%10,10%11]
07:20:22 <opqdonut> there
07:21:25 <cizra> let n = 100 in sum [(-1)^^x * (x % (x + 1)) | x <- [1 .. n]]
07:21:28 <cizra> > let n = 100 in sum [(-1)^^x * (x % (x + 1)) | x <- [1 .. n]]
07:21:29 <lambdabot>   2126095643991513237687041380525277645295683%7041757898200960193617914702466...
07:21:49 <cizra> let n = 10 in sum [(-1)^^x * (x % (x + 1)) | x <- [1 .. n]]
07:21:55 <cizra> gah. sorry.
07:21:56 <cizra> > let n = 10 in sum [(-1)^^x * (x % (x + 1)) | x <- [1 .. n]]
07:21:58 <lambdabot>   7303%27720
07:22:00 <Hiato> Out of interest, how does one alter the precision of the standard division operator?
07:22:03 <cizra> >  7303/27720
07:22:05 <lambdabot>   0.26345598845598844
07:22:07 <cizra> What does it converge to?
07:22:11 <opqdonut> Hiato: by changing the numeric type
07:22:12 <cizra> e?
07:22:29 <Hiato> it converges on 1.3068... if you end on an even number and add one
07:23:14 <cizra> How to convert a rational into a double?
07:23:23 <Hiato> which, I believe, is pretty darn close to a fraction that, if you continually cube, and then at any point, round up, has an awesome chance (read: in my tests, 100%) of being prime
07:23:53 <cizra> Oooh. Cool.
07:28:30 <lilac> > let return' = Cont . const in (do x <- return 1; y <- return 2; return' (x + y); return (x - y)) `runCont` id
07:28:31 <lambdabot>   3
07:29:30 <quicksilver> lilac: or you can just use Either in 'MonadExit' style.
07:29:39 <lilac> > let n = 1000 in sum [(-1)^^x * (x % (x + 1)) | x <- [1..n]] :: CReal
07:29:40 <lambdabot>   Couldn't match expected type `CReal'
07:29:47 <quicksilver> lilac: in which case 'Left' (also called 'exit') is your return.
07:30:24 <lilac> quicksilver: that allows the caller to distinguish between early and late exits, though
07:30:44 <quicksilver> lilac: not if you constraint the type to Either a a ;)
07:30:50 <quicksilver> lilac: but yes
07:31:12 <lilac> is the Cont-based formation more efficient?
07:32:14 <cizra> Is there a way to debug-step through Haskell code? (to see where it gets the wrong results)
07:34:23 <saml> i think ghci can step through
07:34:31 <saml> but i haven't   used it
07:38:37 <cizra> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
07:38:42 <cizra> seems you're right, saml
07:38:48 <quicksilver> cizra: ghci has a source debugger; it's a little immature
07:39:08 <quicksilver> generally speaking I use other approaches to debug haskell code
07:39:41 <saml> since haskell is purely functional, sequential debugging doesn't make much sense
07:40:12 <saml> someone will do ph.d on debugging purely functional programs using formal proofs or something
07:41:35 <saml> you know i was trolling
07:42:01 <saml> but how would mathematician debug his proof?
07:42:20 <saml> by going crazy and writing stuff all over including napkins.  you basically have to do the same with haskell
07:42:35 <osfameron> import Control.Napkin
07:44:23 <cizra> saml: Wrong. Purely functional stuff has execution paths which I'm interested in.
07:46:30 <saml> draw the path on napkin. reduce the graph by hand. do memoization on head. seriously, i think it takes some getting used to before you can see graph your functions reduce to
07:46:33 <cizra> YAY! My tic-tac-toe program works! It's a little dumb, of course, but at least it works!
07:46:56 <saml> post it on github. that's how programmers blog.
07:47:01 <Cheshire> cizra, I think you are best to think about evaluation than execution in general
07:47:44 <cizra> Cheshire: I've got a function with a lot of guards. One of them was buggy and returning the wrong result. The identity of that sucker I wanted to find out.
07:48:06 <Eelis> saml: a mathematician can debug his proof by writing it in a proof assistant
07:49:42 * maltem wonders a little if typical mathematicians would get interested in proof assistants
07:50:00 <saml> Eelis, yup. i was gonna write "since haskell is a programming language. probably computer can help formal proof" but then i haven't used proof assistant. and i'm a courteous troll. i can't troll on materials i haven't even looked at yet.
07:50:38 <saml> but i do assume debugging haskell would mean extending typesystem probably
07:50:57 <Cheshire> maltem, I don't think so
07:52:21 <maltem> saml: There's a recent discussion on -cafe about how to somehow integrate proofs into Haskell without going straight to dependently-typed language. But I don't think there was any worthy outcome of the discussion
07:52:37 <Cheshire> maltem, sounds like how do I wash myself without getting wet
07:52:54 <maltem> heh
07:52:55 <MyCatVerbs> Cheshire: a lot of lemon napkins.
07:53:39 <saml> keeping the language simple and providing tools like lint would be better i guess
07:53:39 <dolio> You can have an external tool that lets you do (effectively) dependently typed stuff without baking it into the language.
07:53:56 <dolio> That's what Catch does, for instance.
07:53:57 <quicksilver> cizra: I debug haskell by methodically trying stuff in ghci
07:54:13 <dcoutts_> why not just equational proofs
07:54:23 <quicksilver> cizra: try expression - don't get expected result - try smaller expression - narrow done on problem
07:54:35 <quicksilver> then, once you locate the problem you can add a test or even a quickcheck property for it
07:54:41 <Cheshire> dcoutts, then we have to write our programs using origami :p
07:54:43 <quicksilver> by copy-pasting from your ghci session
07:55:15 <maltem> Cheshire: The sad thing about dependently typed languages is that you really wanted your vectors to always have the right length, but then you're looking at rather large logic framework. (Or better to say, I, not you)
07:55:24 <dcoutts_> Cheshire: that's not so bad :-)
07:55:32 <cizra> quicksilver: Well, I had a function to check if anyone has won the game yet. I checked accidentally if marks 0, 0 and 0 contain the same value. Dumb.
07:55:34 * saml mostly debugs hard to debug stuff by asking here 
07:55:55 <saml> or by making testcase.. the problem is apparent on testcase
07:56:10 <Cheshire> maltem, by "large logic framework" you mean like.. to write the program and have it all fit together you've to prove some facts about arithemetic (of the indices)
07:56:11 <Cheshire> ?
07:56:23 <bavardage> o/
07:56:32 <bavardage> could someone try and explain fixity assocativity to me :P
07:56:52 <bavardage> I'm not sure I understand the difference between infixl infix and infixr
07:57:06 <maltem> Cheshire: Right, you have to prove more than you hoped initially
07:57:19 <Cheshire> dcoutts, I think you'd get beautiful programs at the end.. but in both cases it's like you have to learn a new trade
07:57:29 * dcoutts_ heads off to London for Lemmih's LHC talk at the London Haskell Users Group
07:57:56 <Cheshire> maltem, I wonder about that..
07:58:01 <cizra> http://pastebin.com/f10d81df5
07:58:11 <cizra> -- my extremely amazing tic-tac-toe game!
07:58:25 <maltem> Cheshire: Well I'm just talking how dependently-typed stuff looks like ;)
07:58:33 <maltem> *what
07:58:44 <Cheshire> maltem, oh do you have same example?
07:59:57 <maltem> Cheshire: I don't have something particular in mind, I was just browsing the examples from the Agda source tree, or tutorials to coq/epigram/what they're all called
08:00:42 <maltem> bavardage: The l and r stand for left and right associativity
08:00:53 <dolio> Tutorials for that stuff start everything from scratch.
08:01:07 <dolio> If you were actually programming, you'd have a standard library full of proofs.
08:01:14 <maltem> bavardage: That is, if # is infixl, then (a # b # c) is parsed as ((a # b) #  c)
08:01:31 <bavardage> riight :P
08:01:45 <bavardage> and so if # is infixr, then (a # b # c) is (a # (b # c))
08:01:46 <maltem> dolio: hm right
08:01:57 <maltem> bavardage: yeah right
08:02:06 <bavardage> and just infix by itself?
08:02:07 <dolio> At least, one would hope.
08:02:10 <bavardage> is that default to left?
08:02:20 <maltem> bavardage: then a # b # c will be a parse error
08:02:24 <bavardage> oh kk
08:03:38 <dolio> Agda has a library with some, for instance.
08:04:03 <dolio> "scanr-defn : ∀ {a b} (f : a → b → b) (e : b) → scanr f e ≗ map (foldr f e) ∘ tails" etc.
08:06:17 <Cheshire> oh
08:06:44 <Cheshire> this www.cs.nott.ac.uk/~ctm/unify.ps.gz
08:07:18 <Cheshire> maltem and dolio if you didn't see it, this is a cool example
08:07:45 <Cheshire> the correctness proofs are ommitted in the paper but you don't need them to just write the program
08:08:03 <Cheshire> @w80 ommitted
08:08:03 <lambdabot> No match for "ommitted".
08:08:05 <Cheshire> @w80 omitted
08:08:05 <lambdabot> *** "omitted" wn "WordNet (r) 2.0"
08:08:05 <lambdabot> omit
08:08:05 <lambdabot>      v 1: prevent from being included or considered or accepted; "The
08:08:05 <lambdabot>           bad results were excluded from the report"; "Leave off
08:08:06 <lambdabot>           the top piece" [syn: {exclude}, {except}, {leave out}, {leave
08:08:08 <lambdabot> [10 @more lines]
08:10:05 <maltem> ah thanks for the link
08:17:16 <drhodes> to go from [Integer] to [Int], where all the members of [Integer] are guarenteed to be <255, what is the general idiom of casting one type to another?
08:17:45 <drhodes> casting is not the right word, yes, but the point is clear, I thing.
08:17:48 <drhodes> think.
08:17:51 <MyCatVerbs> drhodes: map fromInteger.
08:18:40 <MyCatVerbs> drhodes: I consider the word "convert" to be most clear, in this case.
08:18:56 <drhodes> :t fromInteger
08:18:57 <lambdabot> forall a. (Num a) => Integer -> a
08:19:08 <maltem> Even though "cast" is clear enough. There's nothing to confuse it with in Haskell
08:19:19 <drhodes> yeah. I need to figure out what forall is about.
08:19:23 <drhodes> thanks MyCatVerbs
08:20:00 <MyCatVerbs> maltem: well, unsafeCoerce. But coercive casting is common in other languages, and few people use Haskell exclusively.
08:20:33 <paper_cc> drhodes: forall in fromInteger's type says fromInteger can convert to any (forall a) numeric (Num a) type, that's all
08:20:33 <MyCatVerbs> drhodes: that reads as, "for any type 'a' where (Num a) holds, fromInteger :: Integer -> a"
08:21:13 <MyCatVerbs> drhodes: and (Num a) is a typeclass which says that 'a' is a thing that behaves like a number.
08:22:38 <drhodes> so how is this different than fromInteger :: Num a => Interger -> a ?
08:22:52 <paper_cc> drhodes: it isn't
08:23:15 <paper_cc> that's lambdabot that writes all quantifications explicitly
08:23:45 <drhodes> oh.  Well, so "forall" isn't a keyword then.
08:23:49 <jpcooper> @hoogle (a -> b -> c) -> (a -> b) -> a -> c
08:23:49 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:23:49 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
08:23:49 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
08:24:00 <paper_cc> drhodes: it is, actually, but non-H98 one
08:25:35 <paper_cc> lambdabot also writes kind signatures (also not used in Haskell 98):
08:25:39 <paper_cc> @ty (>>=)
08:25:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:27:02 <drhodes> :t fmap
08:27:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:28:00 <paper_cc> jpcooper: `ap` on functions has the needed signature
08:31:25 <jpcooper> thanks paper_cc
08:31:54 <jpcooper> paper_cc, could you tell me what to read to understand that more?
08:32:28 <quicksilver> jpcooper: well, look at the three parts of (a -> b -> c) -> (a -> b) -> (a -> c)
08:32:43 <quicksilver> jpcooper: they all have one thing in common - they all have "a ->" at the beginning.
08:32:57 <paper_cc> jpcooper: In general? don't know actually... Monad instance for ((->) a) still surprises me from time to time
08:33:06 <quicksilver> jpcooper: if we give "a ->" a name, let's call it "m"
08:33:21 <quicksilver> then "m (b -> c) -> m b - > m c"
08:33:28 <quicksilver> looks like function application
08:33:36 <quicksilver> function application with "m" in the way.
08:33:38 <quicksilver> :t ap
08:33:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:33:58 <jpcooper> I'd like to see how function application is a functor
08:34:01 <quicksilver> in fact, if it turns out that "m" is a monad, we can do function application with an "m" in the way - and it's called ap.
08:34:22 <quicksilver> so the question is, is "a ->" a monad?
08:34:26 <quicksilver> and the answer is yes
08:34:30 <quicksilver> and therefore ap is right thing ;)
08:34:45 <quicksilver> you mean, how "a ->" is a functor?
08:34:49 <jpcooper> yes
08:34:59 <paper_cc> fmap f g = f . g
08:35:08 <jpcooper> of course
08:35:09 <quicksilver> well being a functor means there is a way to get from "f a" to "f b" using a function "a -> b"
08:35:32 <quicksilver> in the case of "a ->" (and renaming types) that's getting from a -> b to a -> c using b -> c
08:35:41 <quicksilver> which is function composition.
08:35:45 <jpcooper> oh I see now
08:35:51 <jpcooper> thank you
08:35:55 <quicksilver> any time :)
08:36:02 <jpcooper> I guess I can use <$> for this
08:36:11 <quicksilver> <$> is fmap
08:36:12 <quicksilver> <*> is ap
08:36:18 <jpcooper> right
08:36:19 <chessguy_work> hey ya'all
08:36:19 <quicksilver> so it was <*> you asked for, initially
08:36:20 <jpcooper> of course
08:36:26 <jpcooper> hello
08:36:54 <lupsyn> isn't it correct ? treefoldl f x g y (Node a ts)= foldl g (f x a) (map (treefoldl f x g y) ts)
08:37:03 <Cheshire> lupsyn, what
08:37:49 <lupsyn> this is a treefoldr for the generic trees treefoldr f x g y (Node a ts) = f a (foldr (g) y (map (treefoldr f x g y) ts))
08:38:19 <Cheshire> lupsyn, can you give a definition of the tree?
08:38:34 <paper_cc> looks like it's Tree a = Node a [Tree a]
08:39:03 <lupsyn> Tree a = Void | Node a [Tree a]
08:39:20 <paper_cc> lupsyn: then you need a case for Void
08:39:22 <Cheshire> lupsyn, I guess that we could consider:
08:39:31 <lupsyn> treefoldr f x g y Void = x
08:39:34 <Cheshire> Tree1 a = Void1 | Node1 a (Tree1 a)
08:39:35 <Cheshire> and
08:39:44 <Cheshire> Tree2 a = Void2 | Node2 a (Tree2 a) (Tree2 a)
08:39:48 <Cheshire> and Tree3, and ...
08:39:58 <Cheshire> lupsyn, then your Tree, would be limit of all them
08:40:14 <lupsyn> yep...
08:40:31 <Cheshire> lupsyn, do you know how to compute what type the fold should be for Tree_n ?
08:41:47 <dons> ?bug
08:41:47 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
08:42:02 <lupsyn>  (a -> b -> b1) -> b1 -> (b1 -> b -> b) -> b -> Tree a -> b1
08:42:16 <edbond> How to benchmark functions?
08:44:04 <chrisdone> edbond: do you know what profiling is?
08:44:08 <chessguy_work> read the latest thread on -cafe started by Bulat, then do the exact opposite
08:44:36 <edbond> chrisdone: yes. I write fast sqrt and want to test it against default sqrt.
08:44:46 <chrisdone> edbond: http://book.realworldhaskell.org/read/profiling-and-optimization.html
08:44:54 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
08:45:16 <chessguy_work> @src sqrt
08:45:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:50:13 <chessguy_work> @type map read `fmap` getArgs
08:50:14 <lambdabot> Not in scope: `getArgs'
08:50:16 <quicksilver> edbond: in that kind of case, write a program which does enough sqrts to take a sensible amount of time, and time it.
08:50:24 <chessguy_work> @type map read `fmap` System.Environment.getArgs
08:50:26 <lambdabot> forall a. (Read a) => IO [a]
08:51:38 <chessguy_work> @type map read `fmap` getArgs
08:51:39 <lambdabot> Not in scope: `getArgs'
08:51:46 <chessguy_work> @type System.Environment.getArgs
08:51:47 <lambdabot> IO [String]
09:00:06 <webar7> HugoDaniel, ah HA!
09:00:27 <HugoDaniel> hey webar7
09:00:30 <HugoDaniel> :)
09:00:38 <shukhov> does a uudecode function exist in haskell?
09:01:24 <Zao> Did you check the Codec category on Hackage?
09:01:54 <Zao> dataenc seems to do it.
09:02:02 <Zao> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dataenc
09:05:52 <drhodes> :t (::)
09:05:53 <lambdabot> parse error on input `::'
09:06:36 <quicksilver> drhodes: :: is syntax
09:06:42 <quicksilver> (for type signatures)
09:06:59 <drhodes> oh well, so much for world domination.
09:07:31 <HugoDaniel> :t [::]
09:07:32 <lambdabot> parse error on input `::'
09:07:42 <webar7> HugoDaniel, using xmonad I want to rebind Ctrl-Alt-LeftArrow to move through workspaces
09:07:47 <webar7> but
09:07:56 <webar7> HugoDaniel, http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-CycleWS.html#1 is not too helpful
09:08:09 <lilac> :t [undefined :: Int]
09:08:10 <lambdabot> [Int]
09:08:46 <webar7> HugoDaniel, putting import XMonad.Actions.CycleWS ... stuff in my config
09:08:54 <ozy`> :t undefined:undefined
09:08:55 <lambdabot> forall a. [a]
09:09:18 <ozy`> :t let x = undefined in x:x
09:09:19 <webar7> HugoDaniel, I get an error about syntax for the line , ((modMask x,               xK_Down),  nextWS)  ...
09:09:19 <lambdabot> forall a. [a]
09:09:39 <ozy`> lambdabot uses NoMonomorphismRestriction?
09:10:16 <ozy`> never mind, that works regardless
09:10:30 <HugoDaniel> webar7: i would guess you need something like: ((modMask x .|. ctrlMask,               xK_Left),  nextWS)
09:11:18 <HugoDaniel> webar7, http://hpaste.org/  paste it
09:11:45 <quicksilver> ozy`: haskell does use NoMonomorphism restriction.
09:11:57 <quicksilver> ozy`: sorrry, I mean, lambdabot does.
09:12:04 <ozy`> quicksilver: erm.... heh, all right :p
09:12:41 <quicksilver> it's traditional for ":t" to ignore the monomorphism restriction
09:12:45 <quicksilver> it does in ghci, also.
09:14:20 <ozy`> ah, so that's what's going on.
09:14:36 <quicksilver> because you use :t for subexpressions and stuff
09:14:46 <quicksilver> and the MR is only enforced for named bindings.
09:15:14 <webar7> HugoDaniel, I'm uising what is on http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-CycleWS.html#
09:15:19 <maltem> @type let x = 12 in x
09:15:20 <lambdabot> forall t. (Num t) => t
09:15:25 <skorpan> in the polish parsers paper by hughes and swierstra, i find newtype Rec = R (String -> Progress) -> (String -> Progress) but this gives me a syntax error, obviously, so i'm not sure what to do now?
09:15:26 <webar7> HugoDaniel, errm http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-CycleWS.html#1
09:16:22 <quicksilver> ozy`: but the haskell monomorphism restriction doesn't apply to purely parametric polymorphism
09:16:41 <HugoDaniel> webar7: the code shown is to be put inside the defaultConfig record
09:16:44 <ozy`> quicksilver: clearly I do not fully understand it :p
09:16:54 <HugoDaniel> you cannot copy paste it into the config file and hope that it will work :)
09:16:56 <webar7> oh
09:17:01 <quicksilver> ozy`: the MR only applies to things with type class contexts
09:17:05 <webar7> but ... :)
09:17:09 <quicksilver> ozy`: because its motivation is all about sharing and stuff.
09:17:13 <HugoDaniel> for instance
09:17:18 <webar7> what is a defaultConfig record ... :P
09:17:21 <quicksilver> ozy`: purely parametric polymorphism isn't a sharing problem
09:17:24 <HugoDaniel> http://hackage.haskell.org/packages/archive/xmonad/0.8.1/doc/html/XMonad-Core.html#t%3AXConfig
09:17:32 <webar7> hmm ahh ok
09:17:40 <ozy`> quicksilver: ah, okay
09:18:09 <quicksilver> ozy`: e.g. the polymorphic value [] can in fact be shared between two lists of different types
09:18:17 <quicksilver> ozy`: it really *is* a polymorphic value.
09:18:31 <HugoDaniel> your xmonad.hs file should be something like: main = xmonad $ defaultConfig { borderWidth = 2, terminal = "xterm", keys = ((modMask x .|. ctrlMask,               xK_Left),  nextWS) }
09:18:38 <quicksilver> whereas the polymorphic value 4, by constrant, can't be shared between an Int version and a Double version.
09:19:10 <HugoDaniel> but im not sure if the keys mapping is done that way... maybe the guys at the #xmonad know better :P
09:19:30 <HugoDaniel> i've started using it today (alongside with freebsd)
09:19:30 <lilac> quicksilver: so the runtime representation of [] really is of type [a] for all a?
09:19:57 <quicksilver> lilac: yes; in a GHC compiled module there is (can be) a global top-level []
09:20:05 <quicksilver> lilac: shared by all lists of whatever type.
09:20:38 <quicksilver> similarly Nothing, and so on.
09:22:06 <lilac> seems slightly strange that the M-R would assume an implementation did that...
09:24:05 <quicksilver> lilac: yes, it does.
09:24:17 <quicksilver> lilac: lots of things about the MR seem slightl strange
09:26:44 <sjanssen> webar7: I suggest you visit #xmonad for any xmonad issues
09:28:09 <skorpan> does anyone know what hughes and swierstra mean when they write: newtype Rec = R (String -> Progress) -> (String -> Progress)? GHC complains about the syntax.
09:28:22 <quicksilver> skorpan: I'm sure they intend another set of ()
09:28:39 <quicksilver> newtype Rec = R ((String -> Progress) -> (String -> Progress))
09:28:46 <skorpan> quicksilver: but then thu function recognize (R r) inp = r Done inp doesn't fit the type
09:28:50 <skorpan> thu = the
09:29:15 <skorpan> Done is of type Progress btw
09:29:35 <quicksilver> hmm
09:29:40 <quicksilver> skorpan: got a link to the paper?
09:29:54 <skorpan> but then again they write:   A recognizer take two arguments: a continuation for recognizing the rest of the input once once this recognizer has succeeded, and the input of which a prefix has to be recognized.
09:29:55 <skorpan>  
09:30:07 <skorpan> i'll see if i can find one
09:30:10 <skorpan> http://portal.acm.org/citation.cfm?id=944727
09:30:22 <skorpan> this code is in page 4
09:30:47 <skorpan> but given the paragraph i pasted, i assume they probably meant: R (String -> Progress) (String -> Progress), right?
09:30:58 <HugoDaniel> i have installed ghc 6.8.3 from a package... but i dont have the cabal-install, is this normal ?
09:31:06 <ozy`> HugoDaniel: yes
09:31:10 <quicksilver> skorpan: well, no, because (R r) only has one parameter.
09:31:13 <skorpan> but no, the constructor in a newtype must take only one argument
09:31:15 <HugoDaniel> hmm, what can i do to fix it ?
09:31:16 <ozy`> HugoDaniel: you have to install cabal-install afterwards.
09:31:24 <HugoDaniel> okey
09:31:29 <HugoDaniel> ill build it then...
09:31:34 <ozy`> HugoDaniel: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall <- look at the bottom
09:32:04 <HugoDaniel> my shell is tcsh :)
09:32:11 <quicksilver> stupid acm
09:32:15 * quicksilver finds a downloadable link
09:32:22 <HugoDaniel> thanks
09:32:43 <Cheshire> would people that paid for acm accounts get angry if acm suddenly become free?
09:32:58 <HugoDaniel> :)
09:33:16 <HugoDaniel> i go to acm through the university proxy
09:38:08 <quicksilver> skorpan: I think (String -> Progress) -> (String -> Progress) is correct.
09:38:20 <quicksilver> skorpan: I think there is something wrong with "recognize"
09:38:47 <quicksilver> maybe it should be r (const Done) input
09:39:00 <skorpan> that compiles
09:39:23 <skorpan> i'll just go with that for now, thanks
09:39:40 <quicksilver> np
09:40:11 <skorpan> pretty annoying with both one syntax error and a code error in the same page
09:41:26 <mathijs> Hi all, I'm looking for a function that does this:  divideLists :: Int -> [a] -> [[a]]; divideLists 4 [1..20] == [[1,5,9,13,17],[2,6,10,14,18],[3,7,11,15,19],[4,8,12,16,20]]
09:41:27 <quicksilver> ;)
09:41:39 <quicksilver> skorpan: I think they might be typographic problems
09:41:46 <quicksilver> skorpan: symbols fails to show up.
09:41:53 <skorpan> maybe
09:42:57 <Botje> mathijs: sort numbers according to their value `mod` 4, then group them?
09:42:59 <quicksilver> > let chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n); divideLists n = transpose . chunksOf n in divideLists 4 [1..20]
09:43:00 <lambdabot>   [[1,5,9,13,17],[2,6,10,14,18],[3,7,11,15,19],[4,8,12,16,20]]
09:43:05 <quicksilver> mathijs: ^^
09:43:13 <quicksilver> 'chunksOf' is pretty useful in its own right.
09:43:18 <mathijs> quicksilver: thanks!
09:43:20 <quicksilver> And transpose is just too nice not to use ;)
09:43:40 <mathijs> Botje: no, not according to value, it has to work on any list
09:44:02 <quicksilver> although in pracitce, during your lifetime you will only use it on a finite number of lists
09:44:03 <Botje> mathijs: oh. it has to work like that.
09:44:07 <quicksilver> so you could jsut hardcode it for those.
09:44:34 <Botje> how was i supposed to guess that :)
09:44:48 <quicksilver> Botje: you need a better abduction module.
09:45:22 <Botje> :)
09:46:08 <mathijs> quicksilver: I need this to efficiently partition stuff I'll mapReduce to all cores. Do you think your chunksOf is gonna execute in constant space without allocating stuff when 1 thread (chunk) executes faster than another?
09:46:22 <quicksilver> chunksOf runs in constant space
09:46:46 <quicksilver> it should be fine, I believe.
09:46:51 <rwbarton> > let chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n); divideLists n = transpose . chunksOf n in divideLists 4 [1..200000]
09:46:52 <lambdabot>   [[1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,1...
09:47:00 <rwbarton> > let chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n); divideLists n = transpose . chunksOf n in divideLists 4 [1..]
09:47:01 <lambdabot>   [[1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,1...
09:47:21 <quicksilver> rwbarton: and prove it can produce the second list, too ;)
09:47:29 <rwbarton> > let chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n); divideLists n = transpose . chunksOf n in divideLists 4 [1..] !! 1
09:47:30 <lambdabot>   [2,6,10,14,18,22,26,30,34,38,42,46,50,54,58,62,66,70,74,78,82,86,90,94,98,1...
09:47:33 <quicksilver> \o/
09:48:39 <mathijs> > let chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n); divideLists n = transpose . chunksOf n in divideLists 4 [1..17]
09:48:41 <lambdabot>   [[1,5,9,13,17],[2,6,10,14],[3,7,11,15],[4,8,12,16]]
09:48:51 <mathijs> nice :)
09:49:34 <harblcat> One day I vow I will understand what is said in this channel...
09:50:21 <mauke> how do I shot web?
09:50:23 <Botje> harblcat: arcane runes and steamworks obscura
10:00:02 <skorpan> has anyone been succesful in making emacs' inf-haskell work with 6.10.1
10:00:03 <skorpan> ?
10:01:01 <conal> skorpan: i have
10:01:23 <conal> skorpan: do you mean the ^J stuff?
10:01:46 <gwern> > 6.55 * 4
10:01:47 <lambdabot>   26.2
10:02:19 <gwern> > 3 / (6.55 * 4)
10:02:20 <lambdabot>   0.11450381679389313
10:02:35 <gwern> > (6.55 * 4) / 3
10:02:36 <lambdabot>   8.733333333333333
10:02:39 <skorpan> conal: yeah
10:03:23 <conal> skorpan: i have a work-around, thanks to Judah Jacobson.
10:03:45 <conal> skorpan: i have a shell script "ghci-no-tty", containing "cat | /usr/local/bin/ghci $*"
10:03:55 <conal> skorpan: and then in emacs i set haskell-program-name to "/home/conal/bin/ghci-no-tty"
10:04:00 <mauke> $* better written as "$@"
10:04:08 <conal> mauke: oh?
10:04:35 <mauke> yeah, to preserve arguments with spaces in them
10:04:51 <conal> wow.  what do they each mean?
10:05:23 <mauke>   Expands to the positional parameters, starting from one.
10:06:23 <mauke> word splitting happens after variable expansion, so your version will turn ghci-no-tty "foo bar" into ... ghci foo bar
10:06:49 <mauke> "$*" would turn all arguments into a single space separated argument
10:06:58 <mauke> "$@" is magic in that it quotes each arg separately
10:06:58 <skorpan> is there any tool for "unfolding" a foldr?
10:07:01 <conal> and $@ is somehow different?
10:07:01 <conal> oh!
10:07:14 <mauke> it also expands to nothing if there are no arguments
10:07:15 <conal> mauke: thanks for the pointer and explanation.  i've fixed my script.
10:09:08 <skorpan> thanks conal that worked nicely
10:09:20 <conal> skorpan: super! :)
10:10:04 <skorpan> so, did anyone know of a tool for unrolling a foldr to see what it would result in?
10:10:16 <mauke> > foldr f z [1 .. 10]
10:10:17 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
10:10:30 <skorpan> oh...
10:10:40 <skorpan> > foldr (\x y -> pSym (intToDigit x) <|> y) rFail [0..9]
10:10:41 <lambdabot>   Not in scope: `pSym'Not in scope: `rFail'
10:10:52 <skorpan> > foldr (\x y -> lol (intToDigit x) <|> y) z [0..9]
10:10:53 <lambdabot>   Not in scope: `lol'
10:10:57 <skorpan> > foldr (\x y -> m (intToDigit x) <|> y) z [0..9]
10:10:58 <lambdabot>   Couldn't match expected type `Char -> f a'
10:11:00 <skorpan> .....
10:11:30 <MyCatVerbs> skorpan: call the functions that you want to see the fold for "f" and "g". There's some clever typeclass hackery in lambdabot that makes it work for a handful of specific names.
10:11:40 <idnar> > foldr (\x y -> f (intToDigit x) <|> y) z [0..9]
10:11:41 <lambdabot>   Couldn't match expected type `f a' against inferred type `Expr'
10:11:56 <idnar> I'm not sure intToDigit x is going to work, though
10:11:57 <Cheshire> > fun "f" x
10:11:57 <lambdabot>   Add a type signature
10:12:00 <Cheshire> > fun "f" x :: Exp
10:12:01 <Cheshire> > fun "f" x :: Expr
10:12:01 <lambdabot>   Not in scope: type constructor or class `Exp'
10:12:02 <lambdabot>   f x
10:12:12 <MyCatVerbs> > foldr (\x y -> f (intToDigit x) `g` y) z [0..9]
10:12:13 <lambdabot>   Add a type signature
10:12:17 <Cheshire> > foldr (\x y -> fun "pSym" (fun "intToDigit" x) <|> y) (var "rFail") [0..9] :: Expr
10:12:18 <lambdabot>       Ambiguous occurrence `var'
10:12:18 <lambdabot>      It could refer to either `Data.Number.S...
10:12:20 <skorpan> > foldr (\x y -> f x <|> y) g [0..9]
10:12:21 <lambdabot>       No instance for (Show (f a))
10:12:21 <lambdabot>        arising from a use of `show' at <in...
10:12:22 <Cheshire> > foldr (\x y -> fun "pSym" (fun "intToDigit" x) <|> y) (expr "rFail") [0..9] :: Expr
10:12:23 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Char]'
10:12:26 <MyCatVerbs> > (foldr (\x y -> f (intToDigit x) `g` y) z [0..9]) :: Expr
10:12:27 <Cheshire> > foldr (\x y -> fun "pSym" (fun "intToDigit" x) <|> y) (fun "rFail" x) [0..9] :: Expr
10:12:28 <lambdabot>   Add a type signature
10:12:29 <lambdabot>   Couldn't match expected type `Expr' against inferred type `f a'
10:12:35 <idnar> BZZZZZZZZZZZT!
10:12:36 * idnar hides
10:12:39 <MyCatVerbs> skorpan: unfortunately, it's kind of brittle. :)
10:12:45 <Cheshire> > foldr (\x y -> fun "<|>" (fun "pSym" (fun "intToDigit" x)) y) (fun "rFail" x) [0..9] :: Expr
10:12:46 <lambdabot>   Add a type signature
10:12:53 <mauke> > foldr (\x y -> "(f (intToDigit " ++ show x ++ ") <|> " ++ show y ++ ")") 0 [1 .. 4]
10:12:54 <lambdabot>       No instance for (Num [Char])
10:12:54 <lambdabot>        arising from the literal `0' at <in...
10:13:01 <skorpan> yeah, so does anyone blah blah for showing the result of a foldr? :P
10:13:11 <mauke> > foldr (\x y -> "(f (intToDigit " ++ show x ++ ") <|> " ++ y ++ ")") "z" [1 .. 4]
10:13:12 <lambdabot>   "(f (intToDigit 1) <|> (f (intToDigit 2) <|> (f (intToDigit 3) <|> (f (intT...
10:13:53 <skorpan> lol
10:15:39 <skorpan> so what would be the best way to go if i want pSym '1' <|> pSym '2' <|> ... <|> pSym '9'?
10:16:29 <idnar> what's wrong with what you have there?
10:17:11 <skorpan> i'm not sure about the parentheses
10:17:40 <idnar> @hoogle (<|>)
10:17:40 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:17:40 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
10:17:40 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
10:17:54 <skorpan> well this is from the polish parsers paper
10:18:00 <skorpan> R p <|> R q = R (\k inp -> p k inp `best` q k inp)
10:18:15 <skorpan> and i'm also not sure about the base case for the fold, "rFail"
10:18:20 <idnar> well, if it's left-associative, I guess you want foldl instead
10:18:25 <skorpan> it successfully recognizes "23x" for instance
10:18:33 <idnar> and maybe you should use foldl1 to avoid needing a base case
10:18:50 <skorpan> oh... lol. :)
10:19:02 <idnar> > foldl1 (\x y -> "(f (intToDigit " ++ show x ++ ") <|> " ++ y ++ ")") [1 .. 4]
10:19:03 <lambdabot>       No instance for (Enum [Char])
10:19:03 <lambdabot>        arising from the arithmetic sequen...
10:19:37 <idnar> > foldl1 (\y x-> "(f (intToDigit " ++ show x ++ ") <|> " ++ y ++ ")") [1..4]
10:19:38 <lambdabot>       No instance for (Enum [Char])
10:19:38 <lambdabot>        arising from the arithmetic sequen...
10:19:49 <idnar> oh, meh
10:20:19 <lilac> > let chunksOf n = fmap (fmap (fmap (fmap fmap fmap) (fmap fmap fmap) snd) (fmap fmap groupBy) (on (==) fst)) zip ((fmap (fmap join) (fmap fmap replicate) n) [1..]) in chunksOf 4 [1..10]
10:20:20 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10]]
10:20:56 <idnar> > foldl1 (\x y -> show x ++ " <|> " ++ show y) . map (\x -> "pSym (intToDigit " ++ show x ++ ")") $ [1..4]
10:20:57 <lambdabot>   "\"\\\"\\\\\\\"pSym (intToDigit 1)\\\\\\\" <|> \\\\\\\"pSym (intToDigit 2)\...
10:21:08 <idnar> noo
10:21:14 <idnar> > foldl1 (\x y -> x ++ " <|> " ++ y) . map (\x -> "pSym (intToDigit " ++ show x ++ ")") $ [1..4]
10:21:15 <mauke> ESHOW
10:21:15 <lambdabot>   "pSym (intToDigit 1) <|> pSym (intToDigit 2) <|> pSym (intToDigit 3) <|> pS...
10:21:22 <skorpan> uhm, lookin gat the type of foldl1, it doesn't seem like i can use that at all
10:21:36 <skorpan> because i need [Int] and the result must be Rec
10:22:11 <skorpan> i'm fiddling around with zipWith (<|>) now... :P
10:22:15 <Taejo> why would somebody declare "type Yes_No = Bool"
10:22:27 <idnar> @type let pSym = fun "pSym" in foldl1 (<|>) . map (pSym . intToDigit) $ [1..4]
10:22:28 <mauke> ENTERPRISE QUALITY CODE
10:22:28 <lambdabot> forall (f :: * -> *) a. (Alternative f, SimpleReflect.FromExpr (f a)) => f a
10:22:33 <idnar> hrm, no
10:22:34 <kerlo> > fix show
10:22:35 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:22:42 <mauke> > fix error
10:22:43 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
10:22:46 <idnar> @type foldl1 (<|>) . map (pSym . intToDigit) $ [1..4]
10:22:47 <lambdabot> Not in scope: `pSym'
10:22:48 <gwern> > (30 * 100) / 160
10:22:50 <lambdabot>   18.75
10:23:00 <idnar> what's the type of pSym?
10:23:04 <skorpan> Rec
10:23:11 <kerlo> Cool, fix error has a quotation mark at the beginning.
10:23:12 <idnar> hrm, actually, I probably can't do what I want with the bot
10:23:14 <skorpan> and <|> is Rec -> Rec -> Rec
10:23:14 <idnar> but I think that code should work
10:23:26 <skorpan> but looking at the type of foldl1 one should be able to say that it can't do it
10:23:27 <idnar> you map pSym over the list, and then fold with <|>
10:23:32 <skorpan> :t foldl1
10:23:33 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:23:34 <skorpan> oh
10:23:38 <skorpan> well, then...
10:23:59 <paper_cc> > foldl1 (const id) []
10:24:00 <lambdabot>   * Exception: Prelude.foldl1: empty list
10:24:06 <skorpan> seems to compile at least
10:24:22 <skorpan> paper_cc: that's the whole thing about foldl1, it doesn't require a base case but can't do empty lists
10:24:30 <idnar> @src (<|>)
10:24:30 <lambdabot> Source not found. That's something I cannot allow to happen.
10:24:34 <idnar> heh
10:24:38 <skorpan> idnar: R p <|> R q = R (\k inp -> p k inp `best` q k inp)
10:24:45 <paper_cc> skorpan: I know, thanks =)
10:24:48 <skorpan> idnar: it compiled well but still seems to recognize "23x"
10:24:48 <idnar> yeah, I was just wondering what the Applicative version looked like
10:25:03 <idnar> skorpan: but if you write it out manually, it doesn't?
10:25:11 <skorpan> idnar: i'll see
10:25:33 <skorpan> okay, it does
10:25:38 <skorpan> dammit..
10:26:29 <skorpan> i think i might see what the error is, but not why
10:27:43 <skorpan> it only tries to recognize the first character in the input and never anything else
10:36:13 <gwern> > (10 * 200) / 21
10:36:14 <lambdabot>   95.23809523809524
10:38:45 <gwern> > (50 * 200) / 136
10:38:47 <lambdabot>   73.52941176470588
10:41:12 <gwern> > (100 * 100) / 93.50
10:41:14 <lambdabot>   106.95187165775401
10:41:57 <gwern> > (200 * 100) / 162
10:41:58 <lambdabot>   123.45679012345678
10:42:46 <gwern> > (100 * 90) / 85
10:42:47 <lambdabot>   105.88235294117646
10:42:53 <boegel> gwern: having fun?
10:42:59 <ikkebr> 50 / (0*0)
10:43:02 <gwern> much, thanks
10:43:02 <ikkebr> > 50 / (0*0)
10:43:03 <lambdabot>   Infinity
10:43:21 * boegel now understand why people were complaining about the signal to noise ratio
10:46:07 <dons> ?yow
10:46:07 <lambdabot> I'm gliding over a NUCLEAR WASTE DUMP near ATLANTA, Georgia!!
10:46:31 <Adamant> that would explain the heat
10:47:09 <mauke> preflex: quote
10:47:10 <preflex>  <mwc> C++ is multiparadigm in the same way a dog with 4 table legs nailed onto it is an octopus
10:47:46 <Cheshire> preflox quote
10:48:04 <mauke> tab fail
10:48:40 <ari> Sooooo... what's the story with the mtl and transformers packages? data-accessor depends on the latter, but they apparently don't like each other (I get a complaint about Control.Monad.Trans being found in both mtl and transformers)
10:48:55 <vininim> they see me templatin', they hatin'
10:49:26 <mathijs> quicksilver: I tried your transpose.chunksOf suggestion. It's really nice, but parMapping on the resulting lists becomes a memory hog. I suspect if 1 thread is a bit slower than the others, the original list stays in memory from the lowest index(where the slow thread is) till the highest(fastest thread)
10:50:21 <gwern> vininim: they want to catch you riding stictly?
10:50:39 <gwern> > (30 * 100) / 152
10:50:40 <lambdabot>   19.736842105263158
10:51:11 <gwern> > (30 * 100) / 161.50
10:51:12 <lambdabot>   18.575851393188856
10:51:22 <vininim> heh
10:57:38 <mightybyte> @pl f a b = a++" "++b
10:57:38 <lambdabot> f = (. (' ' :)) . (++)
10:58:02 <maltem> ari: looks like you should hide mtl when compiling a module that uses the other packages
11:03:40 <Alpounet> @pl f a b = map show [1..9]
11:03:40 <lambdabot> f = const (const (map show [1..9]))
11:03:59 <gwern> > 10000000 / (50 * 365.25)
11:04:01 <lambdabot>   547.5701574264202
11:04:10 <ari> maltem: Hm, thanks, I continued developing my stuff with ghci -hide-package transformers (I don't know what transformers does that mtl doesn't) and it's kinda working now...
11:04:47 <cizra> *snif* My architecture sucks )=
11:05:11 <ari> ... now let's just see if I can actually get data-accessor-template to do something more useful than make half of my definitions go out of scope for no reason ):
11:05:14 <gwern> > 548 / 26.2
11:05:15 <lambdabot>   20.916030534351144
11:05:21 <ari> maltem++
11:07:47 <Fredrik_> > repeat 1
11:07:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:07:53 <Fredrik_> > repeat 0.1
11:07:54 <lambdabot>   [0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0....
11:08:13 <BMeph_> I definitely like: "Lazy: The tendency to avoid doing others' work." :)
11:08:23 <necroforest> > take 500 (cycle "asdf")
11:08:24 <lambdabot>   "asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfas...
11:08:43 <necroforest> > (cycle "asdf") !! 5000
11:08:44 <lambdabot>   'a'
11:08:49 <Fredrik_> > foldr (+) 0.0 $ take 10 $ repeat 0.1
11:08:51 <lambdabot>   0.9999999999999999
11:08:57 <whpearson> Where can I find the syntax for applying language extensions? Specifically multiparam typeclasses.
11:09:00 <Fredrik_> gotta love floating point :)
11:09:19 <mauke> {-# LANGUAGE MultiParamTypeClasses #-}
11:09:20 <glguy> > sum (replicate 10 0.1)
11:09:21 <lambdabot>   0.9999999999999999
11:09:29 <necroforest> > let isEven = (cycle [0,1]) !!
11:09:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:09:32 <whpearson> Thanks, mauke
11:09:33 <mauke> > sum (replicate 10 0.1) :: Rational
11:09:34 <lambdabot>   1%1
11:09:36 <necroforest> > let isEven x = (cycle [0,1]) !! x
11:09:37 <lambdabot>   <no location info>: parse error on input `;'
11:09:40 <necroforest> > isEven x = (cycle [0,1]) !! x
11:09:41 <lambdabot>   <no location info>: parse error on input `='
11:09:51 <necroforest> > isEven x = (cycle [1,0]) !! x
11:09:52 <lambdabot>   <no location info>: parse error on input `='
11:09:54 <necroforest> bah
11:10:09 <gwern> > (30 * 100) / 102.34
11:10:10 <lambdabot>   29.314051201876097
11:10:19 <paper_cc> @let isEven x = cycle [1, 0] !! x
11:10:20 <lambdabot>  Defined.
11:10:25 <paper_cc> necroforest: ^^
11:10:33 <necroforest> ah
11:10:38 <Taral> > isEven 0
11:10:39 <lambdabot>   1
11:10:41 <maltem> ari: Hm I'm not sure of transformers either. Looks just like a reorganized mtl?
11:10:44 <necroforest> >isEven 523423942
11:10:48 <gwern> > (30 * 100) / 180.49
11:10:49 <lambdabot>   16.62141946922267
11:10:56 <paper_cc> necroforest: space :P
11:10:58 <mauke> stop failing at lambdabot :(
11:11:00 <necroforest> > isEven 523423942
11:11:03 <necroforest> ;(
11:11:04 <lambdabot>   1
11:11:39 <paper_cc> necroforest: though it is linear in x (most probably), and that's not good ...
11:11:49 <necroforest> paper_cc, that was the point
11:12:04 <paper_cc> ?
11:12:13 <necroforest> a rediculous way to decide if something is even
11:12:43 <paper_cc> ah
11:12:57 <mauke> > let isEven x = x == 0 || isOdd (x - 1); isOdd x = isEven (x - 1) in isEven 523423942
11:13:12 <lambdabot>   thread killed
11:13:19 <mauke> yeah, baby
11:13:34 <paper_cc> @let isEven = (cycle [0, 1] !!)
11:13:36 <lambdabot>  Defined.
11:13:47 <necroforest> > isEven 3
11:13:48 <lambdabot>   1
11:13:50 <paper_cc> necroforest: that's the way to write it as a section
11:13:52 <paper_cc> oops
11:14:00 <paper_cc> @let isOdd = isEven
11:14:00 <mauke> @define
11:14:01 <lambdabot>  Defined.
11:14:05 <necroforest> lol
11:14:17 <paper_cc> an odd definition =)
11:14:26 <mauke> @let isEven = (cycle [True, False] !!)
11:14:28 <lambdabot>  Defined.
11:15:36 <paper_cc> mauke: why does it fail with explicit recursion and succeed with (!!)?
11:15:37 <necroforest> @let isEven x = x `in` [2*y | y <- [0..]]
11:15:37 <lambdabot>   Parse error
11:16:29 <necroforest> @let isEven x = x `elem` [2*y | y <- [0..]]
11:16:30 <lambdabot>  <local>:2:0:
11:16:30 <lambdabot>      Multiple declarations of `L.isEven'
11:16:30 <lambdabot>      Declared at: <loc...
11:16:38 <necroforest> @let isEven2 x = x `elem` [2*y | y <- [0..]]
11:16:39 <lambdabot>  Defined.
11:16:47 <necroforest> > isEven2 500
11:16:49 <lambdabot>   True
11:17:05 <paper_cc> > isEven2 7642363784
11:17:06 <necroforest> paper_cc, stack overflow maybe?
11:17:15 <paper_cc> @src (!!)
11:17:15 <lambdabot> xs     !! n | n < 0 = undefined
11:17:15 <lambdabot> []     !! _         = undefined
11:17:15 <lambdabot> (x:_)  !! 0         = x
11:17:15 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:17:20 <lambdabot>   thread killed
11:17:23 <mauke> > isEven2 1
11:17:26 <necroforest> thats tail recursion
11:17:37 <necroforest> so you don't need a stack or anything to do it
11:17:38 <lambdabot>   thread killed
11:17:45 <necroforest> with the corecursion i think you do?
11:17:51 <paper_cc> hmm
11:18:02 <Cheshire> necroforest, don't think it really works like that in haskell
11:18:18 <necroforest> lol my isEven function doesn't halt for odd input
11:18:22 <necroforest> thats awesome
11:18:32 <Cheshire> sounds like you have a halting problem
11:18:45 <mathijs> is it possible to read/update a shared state (using the state monad) in multiple threads?
11:19:12 <mauke> State is just a wrapper around s -> (a, s)
11:19:33 <maltem> > let isEven 0 = True; isEven n = isOdd (n-1); isOdd n = isEven (n-1) in isEven 12
11:19:36 <lambdabot>   True
11:19:53 <paper_cc> > let isEven x = if x == 0 then True else if x == 1 then False else isEven $ x-2 in isEven 325643352452
11:20:09 <lambdabot>   thread killed
11:20:22 <paper_cc> > isEven 325643352452
11:20:37 <lambdabot>   thread killed
11:20:40 <paper_cc> aha
11:20:56 <lament> > let isEven = even in isEven 12
11:21:00 <lambdabot>   True
11:21:04 <lament> ha!
11:21:07 <Eridius> I must be missing something... why all the extremely bad implementations of isEven?
11:21:20 <shukhov> just check the last bit
11:21:30 <paper_cc> Eridius: necroforest started the contest :)
11:21:46 <dons> dolio: its nice how consistently uvector yields good code
11:21:58 <paper_cc> dons: uvector?
11:22:08 <Cheshire> > let (isEven,isOdd) = (liftA2 (||) (==0) (not . isOdd), not . isEven) in isOdd 13
11:22:14 <lambdabot>   * Exception: stack overflow
11:22:19 <Cheshire> > let (isEven,isOdd) = (liftA2 (||) (not . isOdd) (==0), not . isEven) in isOdd 13
11:22:24 <Cheshire> aw..
11:22:25 <lambdabot>   * Exception: stack overflow
11:23:29 <paper_cc> > let (isEven,isOdd) = (liftA2 (||) (==0) (not . isOdd . prev), not . isEven) in isOdd 13
11:23:32 <lambdabot>   Not in scope: `prev'
11:23:36 <zeno> hmmm does ghc run on ARM? i just put debian on my g1 i wonder if it would work
11:23:41 <paper_cc> > let (isEven,isOdd) = (liftA2 (||) (==0) (isOdd . pred), not . isEven) in isOdd 13
11:23:44 <Cheshire> > let (isEven,isOdd) = (liftA2 (||) (==0) (isOdd . pred), not . isEven) in isOdd 13
11:23:45 <lambdabot>   True
11:23:48 <lambdabot>   True
11:23:51 <necroforest> zeno, gl?
11:24:46 <Eridius> of course these implementations all fail for negative numbers :/
11:25:07 <Cheshire> doesn't matter since negative numbers don't exist
11:25:20 <Eridius> o_O
11:25:20 <paper_cc> the (!!) version seems the most elegant of them all though
11:25:39 <skorpan> is "combinator" in haskell synonymous with "higher-order function"?
11:26:09 <Eridius> so what's wrong with just testing mod 2?
11:26:10 <flx_> skorpan, I think it also requires that the function returns another function
11:26:39 <skorpan> flx_: so "a higher-order function which itself returns a function"
11:26:51 <whpearson> Does this -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1575#a1575 seem like a sensible typeclass for storing differences from data. Like patches for files?
11:27:02 <paper_cc> @hoogle a -> [a]
11:27:02 <lambdabot> Prelude repeat :: a -> [a]
11:27:02 <lambdabot> Data.List repeat :: a -> [a]
11:27:02 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
11:27:16 <skorpan> but that's not specific enough, i suppose, since some higher-order functions are higher-order only in the sense that they return another function
11:27:27 <paper_cc> > let isEven = foldl ($) True . (`take` repeat not) in isEven 2
11:27:28 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
11:27:28 <lambdabot>      Proba...
11:27:37 <necroforest> @src cycle
11:27:37 <lambdabot> cycle [] = undefined
11:27:37 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:27:43 <paper_cc> > let isEven = foldl (flip ($)) True . (`take` repeat not) in isEven 2
11:27:44 <lambdabot>   True
11:27:51 <skorpan> so "a combinator is a higher-order function which both takes at least one function as an argument and returns another function"?
11:28:38 <Cheshire> skorpan, combinators are like  Kxy = x  Ix = x  etc
11:28:59 <zeno> necroforest: tmobile g1
11:29:07 <Draconx|Laptop> skorpan, a combinator is a function with no free variables.
11:29:13 <ufear> hey dudes =)
11:29:16 <vav> Suggestions how to fix ambiguous Exception type in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1574 ? (forkProcess $ ............) :: (IO ProcessID) , but my various annotation attempts have failed.
11:29:17 <zeno> default os is a java vm on linux kernel but i rooted it and put debian on
11:29:22 <skorpan> no free variables, eh...?
11:29:50 <skorpan> i suppose that's a nice way of putting it
11:30:16 <Eridius> > let isEven = head . (`take` cycle [True, False]) . (+1) . abs in isEven 5
11:30:17 <lambdabot>   True
11:30:23 <Eridius> oops
11:30:27 <sjanssen> vav: use base 3 or Control.OldException
11:30:28 <ufear> I'm just starting out with haskell, want to convert a char to an Int, found that there is some function digitToInt, but it doesnt appear to exist, guess I need to import something right?
11:30:34 <Draconx|Laptop> skorpan, (\x -> x) -- this is a combinator: the x on the right is bound to the x on the left
11:30:45 <paper_cc> @hoogle digitToInt
11:30:45 <skorpan> Draconx|Laptop: yeah i know :)
11:30:45 <lambdabot> Data.Char digitToInt :: Char -> Int
11:30:51 <vav> sjanssen: thanks
11:30:53 <paper_cc> ufear: ^^ Data.Char
11:30:57 <ufear> so I should import Data.Char?
11:30:58 <ufear> oki
11:31:16 <Eridius> > let isEven = head . reverse . (`take` cycle [True, False]) . (+1) . abs in isEven 5
11:31:18 <lambdabot>   False
11:31:25 <ufear> I tried that when at school, gave some error
11:31:32 <ufear> guess its due to me using some custom compiler and not GHC =)
11:31:46 <ufear> time to switch over
11:32:43 <edbond> how to output several lines? [IO ()] -> IO () ?
11:32:49 <ufear> I get an unexpected operator '.'
11:32:54 <ufear> when importing data.char
11:33:20 <Eridius> edbond: maybe sequence_ ?
11:33:35 <Eridius> @hoogle sequence_
11:33:35 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
11:33:35 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
11:33:35 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
11:34:40 <edbond> Eridius: thanks. I am a bit afraid of monads )
11:35:15 <maltem> huh?
11:35:17 <maltem> afraid?
11:35:28 <andresj> lol
11:35:51 <andresj> ufear, isn't it Data.Char
11:36:07 <sw17ch> is there a way to ask the RTS to stop scheduling a specific thread for a while?
11:36:16 <ufear> ya got that andresj =)
11:36:21 <ufear> looks like Helium doesnt support it
11:36:34 <andresj> haha that's pretty bad---maybe just Char?
11:37:37 <ufear> I got Char imported
11:37:49 <ufear> theres some .lvm file libary for that, but nothing for data at all lol
11:39:04 <ufear> GHC looks to be doing better, thx :)
11:39:32 <sw17ch> No one has any ideas?
11:41:33 <dons> threadDelay ?
11:41:41 <dons> yield?
11:42:16 <paper_cc> @hoogle yield
11:42:16 <lambdabot> Control.Concurrent yield :: IO ()
11:42:24 <paper_cc> @hoogle threadDelay
11:42:24 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
11:42:41 <sw17ch> i'm more thinking about trying to implement some sort of soft-real-time library
11:42:45 <sw17ch> dons, paper_cc ^^
11:43:08 <sw17ch> i need an outside thread to be able to tell another thread not to run for a bit
11:43:13 <sw17ch> throwYieldTo()
11:43:19 <sw17ch> or throwThreadDelayTo()
11:43:28 <sw17ch> forgive the trailing parens... :(
11:43:36 <whpearson> @hoogle sleep
11:43:36 <lambdabot> No results found
11:44:44 <djsiegel2> Hey, can someone please point me in the right direction http://paste2.org/p/150918 I am trying to cabal install hieroglyph, but I need to update cabal install to work with GHC 6.10, and the zlib package is failing to build so I'm stuck.
11:46:45 <Eridius> djsiegel2: why not just reinstall cabal from scratch?
11:47:06 <Eridius> as I recall it wasn't hard to install in the first place. I think there's even a script lying around somewhere that handles cabal and its dependencies for you
11:47:19 <djsiegel2> Eridius: I will try that, thanks.
11:48:00 <Eridius> djsiegel2: http://ghcmutterings.wordpress.com/2008/11/10/bootstrapping-cabal-install/
11:48:41 <djsiegel2> Yes, running it! :)
11:49:12 <djsiegel2> It's amazing how lovely cabal is when it works, up until the moment it fails and you feel stranded, helpless and alone.
11:49:25 <Eridius> heh
11:49:28 <Eridius> @src last
11:49:28 <lambdabot> last [x]    = x
11:49:28 <lambdabot> last (_:xs) = last xs
11:49:28 <lambdabot> last []     = undefined
11:49:41 <Eridius> huh, that could have been implemented as head . reverse
11:50:25 <djsiegel2> Isn't most of the Prelude implemented with explicit matching?
11:50:35 <Cheshire> probably
11:50:42 <Eridius> I guess so
11:50:45 <djsiegel2> also, wouldn't reverse require N conses
11:51:00 <Cheshire> of course
11:51:05 <Eridius> if you only pull the first element off, it doesn't have to actually build the rest of the list
11:51:13 <Eridius> @src reverse
11:51:13 <lambdabot> reverse = foldl (flip (:)) []
11:51:40 <djsiegel2> Yeah, but I think that fold evaluates before you can get the last element
11:51:50 <Eridius> hmm
11:51:54 <Eridius> that's what I was just wondering actually
11:52:22 <whpearson> Sum float makes me sad :(
11:53:06 <djsiegel2> holy moly, cabal is bringing my entire system down
11:53:13 <Eridius> ?
11:53:28 <djsiegel2> "Resolving dependencies"
11:53:36 <djsiegel2> my DE is frozen
11:53:45 <Eridius> huh
11:53:51 <djsiegel2> cabal just dies with out of memoery error...
11:54:01 <Eridius> weird
11:58:34 <pumpkin> these haskell performance threads seem to become flamebait
11:58:41 <paper_cc> sw17ch: you need a more precise definition of "not run a bit"
11:58:42 <pumpkin> especially when bulat jumps in :)
11:58:47 <paper_cc> @w80 flamebait
11:58:48 <lambdabot> No match for "flamebait".
11:59:19 <sw17ch> paper_cc: do { tid <- forkIO a; plsDontRun a; threadDelay 10000; okRunNow a; }
12:01:43 <paper_cc> @hoogle ThreadId -> a
12:01:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:01:44 <lambdabot> Prelude id :: a -> a
12:01:44 <lambdabot> Data.Function id :: a -> a
12:02:04 <pumpkin> what does that do?
12:11:15 <paper_cc> *looking through the docs of Control.Concurrency* interesting... there's no way to solve sw17ch's problem? seems to be an easy thing to implement in the scheduler
12:11:45 <sw17ch> paper_cc: glad you didn't find anythign either.. i thought i'd seen something about marking a thread as "non-runable" but i can't seem to figure out where i think i saw that
12:12:04 <sw17ch> my problem would also be solved with ignorable exceptions
12:12:10 <sw17ch> that could suspend a task
12:12:15 <Taejo> @pl \x -> toEither <$> f x
12:12:16 <lambdabot> (toEither <$>) . f
12:12:37 <paper_cc> sw17ch: or exceptions that would behave like signals
12:12:48 <sw17ch> paper_cc: yeah, i guess that's closer to what i'm looking for :)
12:12:49 <paper_cc> (asynchronous, that is)
12:17:08 <skorpan> @type ((f.) . g)
12:17:09 <lambdabot>     Ambiguous type variable `b' in the constraints:
12:17:09 <lambdabot>       `SimpleReflect.FromExpr b'
12:17:09 <lambdabot>         arising from a use of `g' at <interactive>:1:8
12:17:15 <paper_cc> @ty
12:17:16 <lambdabot> <no location info>: not an expression: `'
12:17:22 <paper_cc> @ty \f g -> (f .) . g
12:17:23 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
12:17:34 <paper_cc> @unpl \f g -> (f.).g
12:17:34 <lambdabot> \ f g d i -> f (g d i)
12:17:42 <skorpan> what's @ty?
12:17:47 <skorpan> shorthand for type?
12:18:24 <Taejo> skorpan: longhand for :t :)
12:18:39 <skorpan> :P
12:19:36 <paper_cc> skorpan: \bot commands can be abbreviated like Vim or Gdb ones: omit letters as long as it's unambigous
12:19:45 <skorpan> hm, does ghc "optimize" (\x -> x `elem` [1..9]) to (\x -> x >= 1 && x <= 9)?
12:20:37 <paper_cc> skorpan: disasm it :P
12:20:45 <skorpan> yeah, but i figured someone here ought to know ;)
12:20:56 <pejo> skorpan, unlikely, elem uses ==.
12:21:36 <paper_cc> skorpan: oh, certainly it won't as long as it's :: (Num a) => a -> Bool
12:22:02 <skorpan> what is the condition for being able to do [x..y]? i suppose x and y have to instantiate some typeclass?
12:22:06 <paper_cc> @ty enumFromTo
12:22:07 <lambdabot> forall a. (Enum a) => a -> a -> [a]
12:22:22 <paper_cc> skorpan: [a..b] <=> enumFromTo a b
12:22:25 <skorpan> oh
12:22:56 * paper_cc dreams about "enumFrom: a to: b" ...
12:23:46 <skorpan> but wouldn't ghc be able to do such an "optimization" if x and y both instantiate Eq?
12:24:20 <skorpan> or Ord rather
12:24:36 <paper_cc> skorpan: x and y are surely of the same type
12:24:43 <skorpan> right
12:26:23 * paper_cc wonders if it's guaranteed that forall a b x. x `elem` enumFrom a b => a <= x && x <= b
12:27:22 <skorpan> i'm more concerned about whether doing such an optimization would mess someone's code up, if they're doing something depending on lazy evaluation
12:28:38 <paper_cc> > 1234 `elem` [1..345678902]
12:28:39 <lambdabot>   True
12:28:46 <paper_cc> > 1234 `elem` [1..34567890243567]
12:28:47 <lambdabot>   True
12:28:55 <paper_cc> > 1234 `elem` [1..3456789024356756789]
12:28:56 <lambdabot>   True
12:29:08 <paper_cc> > 3456789024356756789 `elem` [1..3456789024356756789]
12:29:13 <pumpkin> lol
12:29:23 <paper_cc> this is linear time indeed
12:29:23 <lambdabot>   thread killed
12:29:49 <pumpkin> paper_cc: the assertion is true, but I doubt there's a rewrite rule specifically for that
12:30:28 <paper_cc> pumpkin: is it a semantic law or something?
12:30:39 <skorpan> lol, i was sitting around thinking what the heck "wnioski (conclusions)" meant in the end of the paper on polish parsers
12:30:44 <pumpkin> paper_cc: I'm not sure I'd say that
12:31:06 <pumpkin> all enumFromTo requires is for the class to implement Enum, not Ord
12:31:22 <pumpkin> I mean type
12:31:23 <pumpkin> :)
12:31:40 <paper_cc> pumpkin: then the assertion isn't neccesarily true?
12:31:49 <paper_cc> (for user-defined types I mean)
12:32:13 <pumpkin> well, I'd argue that an Enum instance should sort of imply an Ord, but as it stands, it doesn't
12:32:20 <pumpkin> so you wouldn't even be able to write x <= b
12:32:39 <pumpkin> @instances Enum
12:32:40 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
12:34:25 <paper_cc> pumpkin: the question is, if we have (Enum a, Ord a), is one somehow required (a la monad laws) to implement enumFromTo accordingly?
12:34:49 <sjanssen> paper_cc: there are some instances that break that law
12:35:17 <sjanssen> > 1.5 `elem` [1 .. 2]
12:35:19 <lambdabot>   False
12:35:27 <paper_cc> @ty [1..]
12:35:29 <lambdabot> forall t. (Enum t, Num t) => [t]
12:35:34 <paper_cc> @ty [1..2]
12:35:36 <lambdabot> forall t. (Enum t, Num t) => [t]
12:35:39 <paper_cc> @ty 1.5
12:35:41 <lambdabot> forall t. (Fractional t) => t
12:35:49 <paper_cc> @ty [1.5 .. 4]
12:35:51 <lambdabot> forall t. (Enum t, Fractional t) => [t]
12:35:55 <sjanssen> paper_cc: the specific type instantiated in that example is Double
12:35:56 <whpearson> We need conal's Typeclass morphisms! I think...
12:36:00 <pumpkin> paper_cc: I think the Enum class kinda sucks, honestly :)
12:36:03 <paper_cc> [1.5 .. 4]
12:36:06 <pumpkin> paper_cc: but in general, I'd say yes
12:36:11 <paper_cc> > [1.5 .. 4]
12:36:13 <lambdabot>   [1.5,2.5,3.5,4.5]
12:36:16 <pumpkin> the idea of from-ness and to-ness seems to imply an ORd
12:36:30 <pumpkin> if you just had an enumerate function
12:36:47 <pumpkin> that returned things in an undefined order
12:37:01 * paper_cc recalls the Haskell' discussion about dropping Enum for floating-point types
12:37:04 <pumpkin> I'd be fine with that :)
12:37:16 <paper_cc> , src ''Enum
12:37:17 <pumpkin> paper_cc: or make it actually enumerate them interestingly :P
12:37:19 <sjanssen> > maxBound :: Int
12:37:21 <lunabot>  class Enum a where
12:37:21 <lunabot>          succ :: a -> a
12:37:21 <lunabot>          pred :: a -> a
12:37:21 <lambdabot>   9223372036854775807
12:37:30 <paper_cc> @src Enum
12:37:30 <lambdabot> class  Enum a   where
12:37:30 <lambdabot>     succ                     :: a -> a
12:37:30 <lambdabot>     pred                     :: a -> a
12:37:30 <lambdabot>     toEnum                   :: Int -> a
12:37:30 <lambdabot>     fromEnum                 :: a -> Int
12:37:32 <lambdabot> [3 @more lines]
12:37:34 <whpearson> Pumpkin, you can have a notion of next to ness and between without having greater than etc.
12:37:41 <sjanssen> > [9223372036854775807 + 1 ..] -- another problem with the Enum class
12:37:43 <lambdabot>   [9223372036854775808,9223372036854775809,9223372036854775810,92233720368547...
12:38:09 <whpearson> @src ord
12:38:09 <lambdabot> Source not found.
12:38:11 <sjanssen> > fromEnum (9223372036854775807 + 1)
12:38:12 <lambdabot>   -9223372036854775808
12:38:16 <whpearson> @src Ord
12:38:16 <lambdabot> class  (Eq a) => Ord a  where
12:38:16 <lambdabot>     compare      :: a -> a -> Ordering
12:38:16 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:38:16 <lambdabot>     max, min         :: a -> a -> a
12:38:27 <necroforest> @src (+)
12:38:27 <lambdabot> Source not found. Do you think like you type?
12:38:32 <paper_cc> 2 `elem` [fromIntegral (maxBound :: Int) + 1 ..]
12:38:36 <necroforest> @src +
12:38:36 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:38:43 <necroforest> @src elem
12:38:44 <lambdabot> elem x    =  any (== x)
12:38:51 <necroforest> @src any
12:38:51 <lambdabot> any p =  or . map p
12:38:52 <paper_cc> > 2 `elem` [fromIntegral (maxBound :: Int) + 1 ..]
12:39:07 <lambdabot>   thread killed
12:39:26 <paper_cc> (fromIntegral (minBound :: Int)) `elem` [fromIntegral (maxBound :: Int) + 1 ..]
12:39:27 <pumpkin> whpearson: certainly, but the implementation just feels dirty right now (especially of the Float/Double instances)
12:39:43 <necroforest> @src fromIntegral
12:39:43 <lambdabot> fromIntegral = fromInteger . toInteger
12:39:50 <paper_cc> > (fromIntegral (minBound :: Int)) `elem` [fromIntegral (maxBound :: Int) + 1 ..]
12:39:52 <paper_cc> grr
12:39:54 <necroforest> that's cheap
12:40:01 <necroforest> @src fromInteger
12:40:02 <lambdabot> Source not found. It can only be attributed to human error.
12:40:03 <gwern> 'nd those of you who object to these generalizations — those of you shaking your heads and saying to yourselves, No, I very much do want to specify by hand the file name and location in the hierarchical directory structure for every bit of data on my system — are almost certainly, I would wager, computer programmers. '
12:40:06 <lambdabot>   thread killed
12:40:12 <gwern> hee hee
12:40:18 <pumpkin> gwern: gruber?
12:40:25 <pumpkin> I liked that post
12:40:59 <gwern> pumpkin: daringfirballs.net so dunno
12:41:19 <pumpkin> yeah, that's him :)
12:43:05 <ski_> (is it possible to be an advanced / power user without being at least a bit a programmer ?)
12:43:05 <lambdabot> ski_: You have 1 new message. '/msg lambdabot @messages' to read it.
12:43:14 <ski_> @messages
12:43:14 <lambdabot> jkff said 11h 50m 27s ago: No, I only looked at the "synthetic topology of datatypes" book. Is ASD cool? :)
12:43:42 <FunctorSalad> $ ghc-pkg list process --> process-1.0.1.0
12:43:44 <ski_> @msg jkff well, it seems interesting, at least
12:43:44 <lambdabot> Not enough privileges
12:43:46 <FunctorSalad>  $ cabal install --rei checkers --> "cabal: There is no available version of process that satisfies ==1.0.1.0"
12:43:49 <ski_> erm
12:43:52 <ski_> @tell jkff well, it seems interesting, at least
12:43:53 <lambdabot> Consider it noted.
12:44:49 <gwern> > (200 * 30) / 50
12:44:52 <lambdabot>   120.0
12:45:05 <pumpkin> ski_: yay, you found the command I was looking for that I'd forgotten about
12:45:38 <ski_> @help tell
12:45:38 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
12:45:40 <ski_> @help ask
12:45:41 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
12:45:50 <ski_> those commands are the same, iirc
12:46:01 <pumpkin> I meant @msg
12:46:05 <ski_> oh
12:46:10 <ski_> (:
12:46:19 <pumpkin> I was trying @say and @message and neither worked :P
12:46:40 <ski_> the simplest didn't occur to you ? ;)
12:46:40 <pumpkin> I'm trying to understand the SPECIALIZE pragma better
12:46:46 <pumpkin> I guess I could just experiment with it
12:46:52 <pumpkin> ski_: nope, I love to overcomplicate :P
12:47:28 * ski_ does that, too, at times
12:47:37 <Saizan> FunctorSalad: using the new cabal-install?
12:48:22 <FunctorSalad> Saizan: yes, but process has been making trouble before too ;)
12:48:53 <pumpkin> but a quick question: if I have a polymorphic data T a = T !a !a !a and use -funbox-strict-types, that normally won't unbox the three parameters, but is it possible to use SPECIALIZE to ask it to make some specialized unboxed versions?
12:49:12 <gwern> > 50 / 30
12:49:15 <lambdabot>   1.6666666666666667
12:49:18 <FunctorSalad> Saizan: I have -p in my .cabal/config FWIW
12:49:54 <FunctorSalad> (enable library profiling)
12:50:27 <FunctorSalad> I thought ghc binaries shipped with -p, though
12:51:09 <Saizan> they do, however cabal is not able to tell if a package has the profiling libs installed, so it won't die in the resolution phase for that
12:51:13 <Saizan> only at build time
12:51:32 <sjanssen> pumpkin: GHC will only specialize functions, not data types
12:51:51 <pao> @users
12:51:52 <lambdabot> Maximum users seen in #haskell: 665, currently: 634 (95.3%), active: 18 (2.8%)
12:52:16 <FunctorSalad> hmm then there must be some other reason why it tries to re-fetch/install process (btw I have --constraint=process-1.0.1.0 too since -1.0.1.1 breaks everything)
12:52:19 <sjanssen> pumpkin: but sometimes, in a sufficiently specialized function, the actual use of T will disappear
12:52:20 <pumpkin> sjanssen: I meant more along the lines of using that datatype in a function, such that the specialized type of the function implied that type being non-polymorphic
12:52:40 <FunctorSalad> (with the ghc package depending on process-1.0.1.0)
12:53:04 <sjanssen> FunctorSalad: you're probably seeing the diamond dependency problem
12:53:42 <pumpkin> FunctorSalad: check if you have the exact same package in both user and system-wide
12:53:50 <sjanssen> a built package depends on process-X, a package you want to install depends (possibly indirectly) on process-Y
12:54:01 <FunctorSalad> pumpkin: using only system-wide (...in my user dir ;))
12:54:12 <pumpkin> lol
12:54:47 <FunctorSalad> sjanssen: hmm that's possible
12:55:36 <Saizan> yeah, we need to find why cabal thinks your process-1.0.1.0 is not suitable for this build
12:55:39 <sjanssen> FunctorSalad: do you only have one version of process installed?
12:56:07 <FunctorSalad> sjanssen: yes, just removed -1.0.1.1 and everything that depended on it ;)
12:56:16 <Saizan> FunctorSalad: maybe try cabal unpack checkers, and cabal configure inside the dir, you'll hopefully get a warning explaining the situation
12:56:24 <pumpkin> I guess I should just experiment with what specialization will do :)
12:56:35 <FunctorSalad> then I over-installed the ghc 6.10.1 binary dist
12:56:40 <pumpkin> it would be nice if it could unbox things
12:56:49 <FunctorSalad> Saizan: will do
12:57:20 <sjanssen> pumpkin: do you have a concrete example?
12:57:35 <pumpkin> sjanssen: I'm thinking particularly about statistics-fusion actually
12:57:39 <FunctorSalad> Saizan: cabal configure works ;) (so does build)
12:57:44 <pumpkin> all its functions operate specifically on Doubles
12:58:02 <pumpkin> because it can unbox the strict triple it uses as an accumulator
12:58:18 <FunctorSalad> ok, configure; build; copy; register worked
12:58:27 <pumpkin> it would be nice to make it general with (UA a, Num a), but have specialized instances for Double and Float
12:58:54 <pumpkin> sjanssen: http://hackage.haskell.org/packages/archive/statistics-fusion/0.2/doc/html/Math-Statistics-Fusion.html that one
12:59:32 <sjanssen> pumpkin: ah, so you'd rather have nice polymorphic versions
12:59:47 <pumpkin> sjanssen: yes, but without sacrificing the nice fast Double version
13:00:02 <pumpkin> sjanssen: I know GHC won't (can't) unbox a polymorphic type
13:00:22 <sjanssen> pumpkin: for the simpler functions, I bet you could change the type and notice no drop in performance (when -O is on)
13:01:02 <pumpkin> really? the generated asm is quite beautiful
13:01:06 <Saizan> FunctorSalad: with no error/warning ? even with -v? possibly -v3
13:01:07 <pumpkin> having them be boxed means memory
13:01:16 <pumpkin> whereas now it's registers
13:01:21 <pumpkin> :P
13:01:21 <sjanssen> pumpkin: you should check the core to be sure, but I would not be surprised if T does not exist at all
13:01:30 <sjanssen> pumpkin: note the INLINE pragmas on all those functions
13:01:35 <pumpkin> true
13:01:37 <pumpkin> hmm
13:01:51 <pumpkin> I'll poke around the depths then, and see :)
13:02:09 <FunctorSalad> Saizan: "There is no available version of process that satisfies ==1.0.1.0" does show up with -v3, but configure just goes on
13:04:28 <sjanssen> pumpkin: hmm, "don't support polymorphism, as we can't get unboxed returns if we use it.
13:04:34 <pumpkin> yup
13:04:39 <sjanssen> pumpkin: is concerning.  I'm assuming dons wrote that?
13:04:42 <pumpkin> yeah
13:04:47 <pumpkin> I only wrote a couple of functions in there :)
13:06:12 <sjanssen> but the unboxed return might not be such a big deal?  What really matters is that the inner loops use appropriate unboxing
13:06:20 <Saizan> FunctorSalad: i see, we'd need to analyze the package.conf to understand what's going on then..
13:07:09 <FunctorSalad> Saizan: I guess I messed it up with all that "ghc-pkg unregister --force", reinstalling ghc, and so on ;)
13:07:39 <pumpkin> sjanssen: I think the return he's talking about is an intermediate value in the folds, but I'm not sure
13:07:39 <FunctorSalad> Saizan: can you just "cabal install" everything without manually managing process on your system?
13:07:50 <pumpkin> if it's just the return of the whole function, I'm sure it makes almost no difference
13:08:02 <chessguy_work> 'ello
13:08:48 <FunctorSalad> (FSVO 'everything')
13:08:57 <pumpkin> anyway, I need to go organize a social event now, I'll be back a bit later :)
13:09:27 <chessguy_work> pumpkin, watch out for side effects!
13:10:13 <FunctorSalad> or could I compile the ghc-6.10.1 core libraries against process-1.0.1.1?
13:10:32 <FunctorSalad> (maybe by just replacing ghc-6.10.1/libraries/process ?)
13:13:37 <FunctorSalad> I'll try just starting the package.conf from scratch
13:15:54 <SamB_irssi> @hoogle m Bool -> m a -> m a -> m a
13:15:54 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
13:15:54 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
13:15:54 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
13:18:52 <dons> this loop unrolling TH macro is awesome!
13:19:10 * FunctorSalad sneaked process-1.0.1.1 into ghc-6.10.1-src... let's see if it compiles ;)
13:20:38 <FunctorSalad> hmm seems I'll have to change more than that
13:20:54 <dons> ok. so Claus' TH macro for loop unrolling makes our program go from 0.9s to 0.09s
13:22:18 <chessguy_work> dons, what program?
13:22:41 <dons> http://www.reddit.com/r/haskell/comments/7z1c5/smacking_down_gcc_claus_reinkes_loop_unrolling/ :)
13:22:51 <dons> just a very cool example of how to unroll loops automatically via TH
13:22:53 <chessguy_work> gracias
13:22:56 <dons> (no -funroll-loops requireD)
13:23:08 <pejo> dons, how many timesdo you inline it?
13:23:21 <dons> i tried 8, then i tried 64 :)
13:23:34 <dons> at 64 we got a 10x speedup, and a 5x speedup over gcc -O3 -funroll-loops
13:23:45 <dons> so this seems like a good technique to explore further
13:25:26 <sw17ch> :)
13:25:29 <sw17ch> wow, very slick
13:25:35 <pejo> dons, so excessive inlining leads to better performance?
13:25:38 <dons> the loop this generates is mega awesome.
13:25:49 <dons> pejo: mm. loop unrolling for tight recursion
13:25:50 <FunctorSalad> what sort of loop does it unroll?
13:25:57 <dons> usual recursive loops
13:26:06 * dons hunts for the asm
13:26:43 <dons> Claus is my Haskell Hero for 2009 now.
13:26:58 <sw17ch> dons: have that assembly yet? :D
13:27:06 * sw17ch has a hard time navigating -ddump-simpl
13:27:07 <dons> its huge and full of straight lines :)
13:27:12 <sw17ch> hah
13:27:47 <chessguy_work> dons, wow, for the whole year?
13:27:57 <dons> the whole freaking year
13:28:59 <guenni> about left-fold-enumerators and such, are there any coherent code samples?
13:29:13 <sw17ch> the irony of B.Z.'s latest response is hilarious after Claus' msg
13:30:55 <dons> :(
13:31:34 <sw17ch> usually -cafe is fun... there are a few individuals that ruin the atmosphere :(
13:31:39 <chessguy_work> so the win is that we don't have to recurse as much?
13:31:47 <chessguy_work> by unrolling?
13:32:41 <sw17ch> > 3x win over GCC with TH, i need to learn TH...
13:32:42 <lambdabot>   <no location info>: parse error on input `,'
13:32:45 <sw17ch> whoops
13:32:50 <sw17ch> greater than 3x win...
13:32:57 <sw17ch> (sorry lambdabot, i'm sure that was confusing)
13:34:12 * beelsebob goes wow at the recursion unrolling Claus played with
13:34:54 <chessguy_work> beelsebob, that seems to be the usual response
13:34:59 <beelsebob> indeed
13:35:06 <sw17ch> really though, that's freaking fast
13:35:08 <beelsebob> stunningly obvious when someone points it out
13:35:18 <sw17ch> beelsebob: kinda like RSA
13:35:21 <beelsebob> (it's always obvious when you know how)
13:35:23 <beelsebob> sw17ch: indeed
13:35:42 <sw17ch> RSA is all voodoo until some one shows how easy it is...
13:36:15 <beelsebob> nice to see something useful can come out of such a troll driven thread though :)
13:37:06 <beelsebob> it's an interesting case though – it's the kind of thing that ghc *should* be able to see that it can unroll the loop *much* more often than gcc should be able to
13:37:08 <sw17ch> i need to see that code reduced to something a lot smaller so i can show it off
13:37:23 <beelsebob> simply because of referential transparency, and being able to check that nothing interferes with the loop condition
13:37:27 <sw17ch> but yeha, GHC should see that... any clues as to why it doesn't?
13:37:35 <sw17ch> just not checked?
13:37:51 <beelsebob> well the loop unrolling I think is certainly something ghc just doesn't do
13:37:59 <sw17ch> not at all?
13:38:11 <beelsebob> I don't think so, no
13:38:13 * sw17ch thinks about it, and decides that it makes sense
13:38:15 <chessguy_work> @quote loop
13:38:15 <lambdabot> chessguy says: the loop is only in your brain
13:38:39 <sw17ch> yeah, if your focus is tail recursion, then i guess unrolling that doesn't really enter your mind as a good option
13:38:42 <beelsebob> it would be nice to see ghc do a source level transformation though – and magically do recursion unrolling as above for you
13:38:45 <sw17ch> or an obvious option
13:38:56 <beelsebob> well no – the tail recursion is specifically so that it can compile it to a loop
13:39:00 <sw17ch> i wish i could make sense of the Claus example
13:39:11 <beelsebob> so one would expect that you then go "hmm, I could heavily optimise the loop after"
13:39:32 <sw17ch> is that something you represent in core, or is that going to be an optimization performed on the assembly
13:39:41 <pejo> beelsebob, sometimes smaller code is faster than unrolled code. I don't think we know exactly when.
13:40:00 <sw17ch> somehow duff's device comes to mind
13:40:12 <beelsebob> pejo: surely there's significant research into that already though – it is after all something that imperative compilers do rather a lot
13:40:17 <chrisdone> > let (×) = mappend in Just "sup " × Just "dawg"
13:40:18 <lambdabot>   Just "sup dawg"
13:40:25 <chrisdone> is this awesome (y/n)?
13:40:37 <Raevel> y
13:40:38 <pejo> beelsebob, have any references?
13:40:46 <beelsebob> chrisdone: y, but I'm not sure about why × as a symbol
13:40:49 <Raevel> i should buy that t-shirt
13:40:50 <conal> would someone please remind me how to embed CPP-#defined symbol into a lexical string?
13:40:58 <beelsebob> pejo: no, not of the top of my head, but I'd be very surprised if there weren't any
13:41:20 <chrisdone> beelsebob: A monoid is a set M with binary operation * : M × M → M.
13:42:05 <chrisdone> beelsebob: is not × therefore fitting?
13:42:10 <pejo> beelsebob, I think a lot of the commercial vendors have an idea, but they're not publishing papers on it. The functional programmers tend to not look too hard at that problem I think.
13:42:17 <sw17ch> @src fix
13:42:17 <lambdabot> fix f = let x = f x in x
13:42:21 <beelsebob> chrisdone: I guess I see × as having specific connotations – I tend to use symbols like ⊗ or ⊕ for that
13:42:52 <conal> something like ## for concat'ing ?
13:44:34 <beelsebob> pejo: http://www.freepatentsonline.com/5797013.html <-- seems to have a decent amount of relevance
13:46:30 <chessguy_work> heya conal . nice paper the other day -- seems to capture nicely some of the things we've been talking about
13:46:40 <conal> chessguy_work: :)
13:47:25 <pejo> beelsebob, is there a link on that page, or just an abstract?
13:47:32 <mathijs> ?pl \x -> f (g x)
13:47:32 <lambdabot> f . g
13:47:37 <chessguy_work> beelsebob, wait, what? loop unrolling is patented?
13:47:40 <beelsebob> just an abstract – that's all I could find on google scholar
13:48:05 <beelsebob> chessguy_work: that technique at least by the looks of things
13:48:27 <chessguy_work> wow, i didn't know you could patent something so abstract
13:48:30 <beelsebob> this one too http://www.freepatentsonline.com/5265253.html
13:48:40 <beelsebob> well, it's the algorithm that's patented – not the concept
13:48:42 <beelsebob> but still
13:48:43 <beelsebob> a bit wow
13:49:11 <bavardage> right so I'm a haskell noob, but are there anything like constructors?
13:49:15 <redditbot> Smacking down GCC: Claus Reinke's loop unrolling Template Haskell
13:49:15 <redditbot> Denotational design with type class morphisms: Draft paper
13:49:21 <bavardage> I want a datatype that orders itself from the start
13:49:32 <beelsebob> bavardage: yes – you define them when you define your data type
13:49:39 <bavardage> beelsebob: how :P?
13:49:50 <beelsebob> data X = Y Int | Z String -- Y and Z are your constructors
13:49:59 <beelsebob> X notably, is a *type* constructor
13:50:01 <bavardage> but how do I actually make them do something?
13:50:04 <CTA> Heyy
13:50:17 <bavardage> like a have    data Foo = Foo [Integer]
13:50:20 <beelsebob> Y 5 -- this is a value in the type X – it was constructed with the Y constructor
13:50:31 <bavardage> but I want Foo to order the list of integers
13:50:35 <beelsebob> Z "jam" -- this is another value in X - it was constructed with the Z constructor
13:50:46 <beelsebob> ah, then you want a virtual constructor
13:50:47 <bavardage> kk
13:50:55 <Cale> bavardage: Data constructors never "do" anything.
13:50:59 <bavardage> right
13:51:00 <beelsebob> data Foo = Foo [Integer]; foo = Foo . sort
13:51:05 <Cale> But you can write functions which take their place.
13:51:13 <Cale> like beelsebob showed :)
13:51:17 <CTA> what's data? quick summary?
13:51:18 <bavardage> oh kk :P
13:51:27 <bavardage> thanks, I think I get the idea
13:51:28 <Cale> CTA: It defines new datatypes
13:51:41 <beelsebob> bavardage: traditionally then you would export the data type, but not it's constructors from the module, and you would export foo too
13:51:50 <beelsebob> so module Foo (Foo(), foo) where ...
13:51:59 <bavardage> oh kk
13:52:05 <beelsebob> then everyone *has* to use foo to construct a Foo
13:52:10 <bavardage> makes sense :D
13:52:24 <CTA> I only know to to make basic functions
13:52:44 <beelsebob> CTA: data defines data types
13:52:53 <chessguy_work> CTA, most things in haskell are basic functions, when done right :)
13:53:06 <chessguy_work> ok, s/most/many/
13:53:09 <beelsebob> data Foo = Foo [Integer] -- this define a data type called Foo, it has one constructor Foo which takes a list of integers as an argument
13:53:11 <Cale> CTA: The data keyword is followed by the name of the new type constructor followed by 0 or more (type) variables, and then an equals sign. After the equals sign you have one or more cases separated by |, each of which consists of the name of a new data constructor and 0 or more types which are the types of that data constructor's parameters.
13:53:24 <CTA> haha =P I mean like: addHelloTo x = x ++ " hello" XD
13:53:32 <CTA> and simple if expressions
13:53:41 <Cale> For example...
13:53:45 <chessguy_work> CTA, gotta start somewhere
13:53:50 <CTA> haha yeah lol
13:53:54 <CTA> Cale you talking to me?
13:54:00 <Cale> CTA: yes
13:54:15 <Cale> data Employee = Boss String Integer | Underling String
13:54:21 <CTA> if x >= 2009 then putStrLn "YOU LIE" else "stfu"
13:54:28 <CTA> hmm mkay?
13:54:38 <Cale> Defines a new datatype whose members look like  Boss "Fred" 2000,  Underling "Sam"  etc.
13:54:55 <true\false> CTA:  That should really have an explicit type
13:54:56 <Cale> You can write functions which act on these new values by pattern matching
13:54:58 <gwern> CTA: then putStrlin foo else bar? ain't gonna type mon
13:55:05 <chessguy_work> woohoo, my tests passed. i guess that means i can go home
13:55:08 * chessguy_work grins
13:55:17 <true\false> addHelloTo :: [Char] -> [Char]
13:55:17 <Cale> raise n (Boss name salary) = Boss name (salary + n)
13:55:17 <beelsebob> chessguy_work: hold it!
13:55:23 <chessguy_work> beelsebob, nooooooooo
13:55:24 <beelsebob> prove it correct before you go home!
13:55:27 <beelsebob> bad chessguy_work
13:55:28 <beelsebob> :P
13:55:33 <chessguy_work> beelsebob, this is C#, not haskell
13:55:35 <chessguy_work> :)
13:55:36 <beelsebob> hehe
13:55:37 <Cale> raise n (Underling name) = Boss name n
13:55:46 <CTA> [Char] -> [Char] ?
13:55:59 <beelsebob> Cale: does this type assume that underlings earn nothing?
13:55:59 <beelsebob> :D
13:56:02 <CTA> meaning you get a Char then return one?
13:56:05 <Cale> beelsebob: yes :)
13:56:16 <chessguy_work> i think you want to call that 'promote'
13:56:20 <beelsebob> ah, so they're PhD students Cale?
13:56:24 <chessguy_work> haha
13:56:24 <beelsebob> >.>
13:56:30 <whpearson> [Char] is an array of Char s
13:56:36 <chessguy_work> beelsebob, and postdocs
13:56:39 <beelsebob> I think it should be called passVivaAndGetResearchGrant
13:56:41 <Cale> beelsebob: hehehe
13:56:42 <whpearson> Not array, list
13:56:50 <chessguy_work> right, i'm outta here
13:57:03 <Cale> CTA: another example would be perhaps...
13:57:11 <CTA> String == [Char] ?
13:57:23 <whpearson> CTA: Yup :)
13:57:24 <Cale> data Colour = RGB Integer Integer Integer | CMYK Float Float Float Float
13:57:47 <Cale> Types are also allowed to be recursive
13:58:07 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
13:58:09 <CTA> so then RGB 1 2 3 and CMYK 1.1 2.2 3.3 4.333339 ?
13:58:09 <true\false> Cale: Hmm, such as Lists?
13:58:15 <Cale> yes
13:58:17 <Cale> or
13:58:23 <beelsebob> or you could have passViva (Underling n) = (Boss n 0); getResearchGrant v (Boss n v') = v + v'; getResearchGrant v (Underling _) = error "Underlings should not be given money bitch"
13:58:30 <Cale> data List a = Empty | Cons a (List a)
13:58:52 <CTA> data seems nice little thing
13:59:01 <beelsebob> CTA: it's pretty much the core of Haskell
13:59:02 <CTA> handy to learn when I deeply get into Haskell mwha
13:59:07 <beelsebob> haskell is all about data, not functions
13:59:11 <beelsebob> except that functions are data
13:59:17 <beelsebob> so ... it's all about functions :)
13:59:26 <Cale> well...
13:59:28 <Cale> :)
13:59:48 <mathijs> how can I place class constraints on a type? I need "type LeveledNode a = (a,Int)" and tell that a is Integral
14:00:08 <beelsebob> type Integral a => Levelednode a = (a,Int)
14:00:08 <Cheshire> mathijs, it will be inferred by the compiler
14:00:28 <CTA> so, ...: data name = forename [Char] | surname [Char] ?
14:00:49 <mathijs> beelsebob: that doesn't work
14:00:51 <Cale> CTA: Type and data constructors must start with an uppercase letter, other than that, it's valid.
14:00:54 <beelsebob> mathijs: doesn't it?
14:01:03 <beelsebob> bugger :(
14:01:07 <mathijs> Cheshire: I can't force it explicitly?
14:01:13 <beelsebob> oh, because it's a type synonym
14:01:17 <beelsebob> you'll need a newtype for it
14:01:24 <Cale> CTA: So  data Name = Forename String | Surname String
14:01:24 <Cheshire> mathijs, you can write type signatures everywhere you use it but that seems tedious to me
14:01:31 <CTA> constructors = Name or Forename etc?
14:01:36 <Cale> yeah
14:01:46 <CTA> I mean, is it just one or both
14:01:57 <mathijs> Cheshire: to me too.
14:01:57 <CTA> I mean like the data name or the = NAMEHERE
14:02:15 <beelsebob> CTA: you will also be interested in type – which is simpler than data – it simply says that a type can be named something different
14:02:18 <sjanssen> data TypeConstructor = DataConstructor1 String | DataConstructor2 String
14:02:23 <Cale> In that, Name is a type constructor, and Forename, Surname are data constructors.
14:02:28 <beelsebob> for example... type String = [Char] -- from now on, you can use String to mean [Char]
14:02:53 <beelsebob> (and vice versa)
14:03:15 <iago_> someone recommends one generics library?
14:03:22 <CTA> so could I type !@ = [Char] ?
14:03:44 <beelsebob> if you want to use symbols, they become infix, and they must begin with a ':
14:03:46 <beelsebob> ':' too
14:03:47 <Cale> CTA: Symbol characters only work as infix type constructors...
14:03:52 <Cale> and yeah...
14:04:13 <Cale> They have to start with a :, which is the only "uppercase" symbol character ;)
14:04:22 <beelsebob> e.g. data Complex a = a :+ a -- a possible value of Complex Float is 1.0 :+ 2.0
14:04:32 <CTA> why cant function names[0] == uppercase?
14:04:48 <beelsebob> CTA: to distinguish between data constructors, and functions
14:04:54 <Cale> CTA: because that's how we distinguish data constructors from other variables.
14:05:07 <beelsebob> it's not necessary, but it makes code a lot more readable, by both human and compiler
14:05:08 <Cale> They're special when pattern matching
14:05:12 <Cale> No, it is necessary.
14:05:16 <Cale> (I think)
14:05:26 <CTA> It is
14:05:35 <CTA> (LYAH) said soo
14:05:36 <CTA> BYE
14:05:43 <Fredrik_> I'm just toying with functions for an imaginary tetris game. Can anyone comment on my line clearing code?
14:05:44 <Fredrik_> clear_lines lines = clear_lines' [] lines []
14:05:45 <Fredrik_> clear_lines' front (x:xs) back
14:05:45 <Fredrik_>     | ' ' `elem` x = clear_lines'        front  xs (x:back)
14:05:45 <Fredrik_>     | otherwise    = clear_lines' (blank:front) xs    back
14:05:45 <Fredrik_>                      where
14:05:46 <Fredrik_>                          blank = map (const ' ') x
14:05:48 <Fredrik_> clear_lines' front [] back = front ++ back
14:05:53 <beelsebob> Fredrik_: try a pastebin ;)
14:05:58 <beelsebob> hpaste is the recommended
14:06:25 <lepassive> is there any RDBMS fully written in haskell ?
14:06:49 <necroforest> Oracle
14:06:58 <Fredrik_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1577
14:07:19 <lepassive> necroforest, oracle is written in Haskell :D ?
14:07:27 <necroforest> lol no
14:07:28 <Cheshire> Frederik, I don't like it
14:07:35 <Fredrik_> I figure :)
14:07:38 <Fredrik_> so how can i improve
14:07:44 <Fredrik_> i'm new to haskell
14:09:14 <beelsebob> Fredrik_: I'd split it up
14:09:29 <beelsebob> into a function which replaces full lines with blank ones
14:09:36 <beelsebob> and a function which bubbles blank ones up
14:09:47 <beelsebob> having said that – I wouldn't represent the board that way
14:10:39 <beelsebob> oh hang on – I see what's wrong
14:10:47 <beelsebob> you're representing the board upside down
14:10:58 <beelsebob> make the head of the list the bottom of the board and it suddenly gets more easy
14:11:32 <Fredrik_> hm, i'll try that out. thanks!
14:12:37 <beelsebob> Fredrik_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1577#a1578
14:12:52 <beelsebob> if the head is the bottom of the board
14:13:43 <Fredrik_> ah, so clear lines aren't even part of the board... that's clever, but i'm sure i'll run into problems further down the road
14:14:34 <Fredrik_> couldn't i just do clearLines = filter (' ' `notElem`)
14:14:35 <Fredrik_> ? :)
14:14:51 <beelsebob> it could be
14:15:14 <Fredrik_> anyway, that's just brilliant code somehow. so elegant and clever :)
14:15:24 <beelsebob> note – not my idea
14:15:34 <Fredrik_> I needed much more lines of code in other languages.
14:16:17 <beelsebob> so yeh – your drawing code should now pad with enough lines of blank to fill up the board,
14:16:19 <beelsebob> reverse
14:16:24 <beelsebob> and then do as it does now
14:16:38 <Fredrik_> yeah, there's not much code to refacter. I just started the project 20 minutes ago ;)
14:16:43 <beelsebob> :)
14:17:13 <beelsebob> or if you're drawing to a graphical context, there's not even any reversing necessary, just draw in the other order :)
14:17:38 <bavardage> right, so I have a type Term defined as follows data Term = Term (Integer, Integer)
14:17:47 <bavardage> how do I get the second part of a term?
14:17:59 <bavardage> snd doesn't work, since it wants something of type (a,b)
14:18:08 <bavardage> how do I treat a term as what it actually is?
14:18:22 <Cheshire> secondPart (Term (x, y)) = y
14:18:36 <bavardage> thanks :D
14:18:39 <bavardage> dammit
14:18:44 <bavardage> forgot the Term in the pattern
14:20:16 <beelsebob> bavardage: define Term as a functor
14:20:25 <beelsebob> oh no – no argument
14:20:27 <beelsebob> it's not a functor
14:20:48 <beelsebob> so yeh, define firstPart, secondPart, or more generally – unTerm
14:20:54 <beelsebob> then you can use fst and snd
14:21:01 <beelsebob> unX and inX are generally useful for any type
14:21:17 <bavardage> oh kk
14:21:24 <bavardage> well atm I've defined power and coeff
14:21:57 <Fredrik_> Inserting new lines as punishment is also very easy now:
14:21:58 <Fredrik_> insert_lines n lines = (take n $ repeat "ZZZZZZZZZZ") ++ lines
14:22:21 <Fredrik_> can i express (take n $ repeat) more concise?
14:22:52 <beelsebob> replicate IIRC
14:22:52 <Axman6> replicate
14:22:54 <beelsebob> @type replicate
14:22:55 <lambdabot> forall a. Int -> a -> [a]
14:23:01 <Axman6> > replicate 1
14:23:02 <conal> could someone help me with a CPP issue?  I want to splice a CPP-#defined symbol into a haskell string literal, and i can't remember the magic.
14:23:02 <lambdabot>       Overlapping instances for Show (a -> [a])
14:23:02 <lambdabot>        arising from a use of ...
14:23:04 <Axman6> > replicate 1 1
14:23:06 <lambdabot>   [1]
14:23:07 <beelsebob> YES, well and truely beelsebob'd Axman6! :P
14:23:15 <Axman6> hell yeah!
14:23:24 <Fredrik_> awesome!
14:23:24 <thetallgu1> conal: sure.  Use another tool...
14:23:40 <Axman6> > replicate 7 1
14:23:41 <lambdabot>   [1,1,1,1,1,1,1]
14:23:42 <conal> thetallgu1: :) :p
14:23:46 <Axman6> better example >_>
14:23:50 <beelsebob> Fredrik_: you might also want to define filledLine = "ZZZZZZZZZZ"
14:23:56 <conal> i'm using the CPP LANGUAGE pragma
14:25:29 <Axman6> conal: never tried, but one thought... what about splitting the string at that point with "...\[\n]\THING_TO_REPLACE\[\n]\ ..." ([\n] indicating new lines in the actual code...)
14:26:35 <conal> i think i'm looking for something like ##
14:27:04 <beelsebob> pejo: I was pointed at this http://www.cs.ualberta.ca/~berube/publications/spec07.shtml by people in #gcc
14:27:29 <conal> Axman6: thx.
14:29:43 <pejo> beelsebob, I think you're tackling a different problem if you have profile data to guide your inlining. (Still an interesting paper though).
14:29:55 <thetallgu1> conal: are you looking for trigraph support?
14:30:07 <conal> thetallgu1: no idea what trigraph support is
14:30:18 <beelsebob> pejo: I think the idea is that the compiler can do the profiling as it compiles
14:30:34 <beelsebob> which sounds like an especially good plan in a referentially transparent language
14:30:55 <dons> http://www.reddit.com/r/haskell_proposals/comments/7z1uf/implement_loop_unrolling_for_c_level_loops_in_ghc/
14:31:07 <pejo> beelsebob, oh, then I didn't understand the abstract. Let me re-read.
14:31:42 <dons> pejo, benl23 do you guys know much about what we've considered for loop unrolling in ghc in the past?
14:32:25 <beelsebob> dons: no idea no – are there docs about it?  Also, I kinda like the idea of "recursion unrolling" – it sounds more general than loop unrolling (might work even if we don't have tail recursion)
14:32:30 <pejo> dons, I've read the secrets of the ghc inliner paper, that's all.
14:32:52 <thetallgu1> conal: I've never found a good description of it, but it's the only thing that pattern matched at all for me.
14:33:17 <dons> JaffaCake: any thoughts ^^
14:33:23 <conal> thetallgu1: thx.
14:33:35 <dons> i'm just blown away by how easy this was (Claus' prototype) and how much perf. we got from it.
14:33:48 <dons> and then ... can we do loop unrolling automagically on stream fused loops...
14:33:53 <beelsebob> dons: yeh, I guess the hard bit though is recognising when it gives you benefit
14:33:58 <dons> since we go  to such lengths to produce perfect loops
14:34:07 <dons> seems like maybe even the next killer step for stream fusion
14:34:08 <beelsebob> that example was really rather clear cut, and I'm not even sure there how you would see it without being a human
14:34:32 <Axman6> dons: reckon it's something that could use a {-# PRAGMA #-}?
14:34:38 <Axman6> s/could/should
14:35:03 <Axman6> so the developer can define where it speeds things up and where it doesn't (after testing)
14:35:12 <dons> i was wondering if i could massage a rewrite rule to unroll the loops at the end of stream fusion pipelines
14:35:37 <beelsebob> also worth noting – wow – jhc beats gcc straigt out the box!
14:35:46 <pejo> dons, isn't that just to inline the function in itself a couple of times?
14:35:47 <Axman6> beelsebob: at what?
14:35:50 <dons> sort of
14:35:58 <beelsebob> Axman6: the example in the trollery thread that dons got something useful out of
14:35:58 <dons> the body needs to be unrolled, and arguments incremented
14:36:12 <Cthulhon|> conal: ## doesn't do anything for strings.  The CPP (or some part of the C compiler) coalesces adjacent strings, so concatenation is just "str" MACRO "str".
14:36:36 <Cthulhon|> I don't know how GHC deals with that.
14:38:26 <conal> Cthulhon|: thanks.  i'll give it a try.
14:39:57 <mathijs> is there a simple way to make all items in a list unique?
14:40:05 <sioraiocht> mathijs: nub
14:40:08 <sioraiocht> @type nub
14:40:09 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:40:15 <mathijs> tnx
14:40:20 <sioraiocht> > nub [1,1,3,6,3,5]
14:40:21 <lambdabot>   [1,3,6,5]
14:40:39 <sioraiocht> @src nub
14:40:40 <lambdabot> nub = nubBy (==)
14:40:44 <sioraiocht> @src nubBy
14:40:45 <lambdabot> nubBy eq []             =  []
14:40:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:41:00 <sioraiocht> yeah, it's O(n^2)
14:41:14 <sioraiocht> or wait, not quite
14:41:16 <sioraiocht> but still
14:41:22 <sioraiocht> not a very fast function =)
14:41:48 <beelsebob> mathijs: you may also want to try Data.Set.fromList
14:42:05 <beelsebob> (unless you want to maintain ordering)
14:42:09 <mathijs> beelsebob: thanks, might be faster
14:42:25 <Axman6> sioraiocht: toList . fromList can be faster
14:42:33 <mathijs> nope, I need to check a list for inclusion of a range of numbers, sounds like a set to me
14:42:47 <beelsebob> note – my point was not to use fromList for this task specifically – but that Data.Set.Set might be a better data type for you
14:43:02 <sioraiocht> Axman6: that would be...linear, wouldn't it?
14:43:06 <sioraiocht> you would always pass through the list twice?
14:43:08 <Axman6> think so
14:43:13 <beelsebob> oh, yeh sioraiocht
14:43:16 <beelsebob> not mathijs
14:43:17 <beelsebob> sorry
14:43:27 <beelsebob> sioraiocht: I don't think it's linear
14:43:33 <sioraiocht> beelsebob: oh, okay, heh
14:43:33 <beelsebob> I think it's O(n * log(n))
14:43:34 * sioraiocht wouldn't know
14:43:45 <beelsebob> (Data.Set builds a tree internally IIRC)
14:43:58 <sioraiocht> yeah, that's makes sense, it would still ahve to check for duplicates on every insert...
14:44:05 <Axman6> yeah O(n log n) sounds about right
14:44:10 <mathijs> is it lazy? I need to check an infinite list for inclusion of certain elements
14:44:27 <Axman6> :t toList
14:44:28 <lambdabot> Not in scope: `toList'
14:44:33 <Axman6> :t S.toList
14:44:34 <lambdabot> forall a. S.Set a -> [a]
14:44:38 <beelsebob> mathijs: Data.Set isn't no
14:44:49 <beelsebob> it needs to know what order the elements come in
14:44:54 <sioraiocht> mathijs: nub is also strict
14:44:56 <Axman6> > S.toList . fromList $ [1..]
14:44:57 <lambdabot>   Not in scope: `fromList'
14:45:01 <Axman6> > S.toList . S.fromList $ [1..]
14:45:02 <lambdabot>   /tmp/7019379680590071222:70:36: Not in scope: `S.toList'/tmp/70193796805900...
14:45:02 <beelsebob> sioraiocht: are you sure?
14:45:08 <beelsebob> > nub [1..]
14:45:08 <sioraiocht> beelsebob: nope, i'm wrong
14:45:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:45:09 <sioraiocht> my mistake
14:47:10 <CyberFlame> hi everybody
14:47:28 <CyberFlame> make money here:
14:47:29 <CyberFlame> check out my new site---> easy-money2600.tk
14:47:30 <CyberFlame> check out my new site---> easy-money2600.tk
14:47:30 <CyberFlame> check out my new site---> easy-money2600.tk
14:47:41 <mathijs> so if I try to create a set out of [1..1000000] it would immediately try to allocate?
14:47:42 <Axman6> @where ops
14:47:43 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:47:52 <pejo> beelsebob, I'm sorry, but to me it seems like that paper is about how to let benchmarks like SPEC CPU have a profile guide optimization number as well?
14:48:09 <andyjgill> Has anyone goto the llvm working on OSX?
14:48:10 --- mode: ChanServ set +o glguy
14:48:14 --- mode: glguy set +b *!*@gateway/web/ajax/mibbit.com/x-69373a940f878eab
14:48:14 --- kick: CyberFlame was kicked by glguy (glguy)
14:48:15 <Axman6> yep
14:48:25 <Axman6> ta glguy :)
14:48:38 --- mode: glguy set +d cdr03-84-91-10-32.netvisao.pt
14:48:46 --- mode: glguy set -o glguy
14:48:46 <beelsebob> andyjgill: llvm + c is an option in Xcode – I'd be surprised if it didn't work
14:49:04 <Axman6> beelsebob: it had issues.
14:49:25 <Axman6> andyjgill: you need to tell cabal where LLVM is installed (i used my macports install)
14:49:38 <andyjgill> I'm getting a  _LLVMGetPointerToGlobal not found.
14:49:56 <andyjgill> I did that. It finds llvm-config just fine.
14:50:45 <Axman6> still needs a custom flag, and i can't remember where it is. check augustss_'s blog
14:53:27 <beelsebob> does Bulat have a history of trolling, or an alterior motive here?
14:53:58 <beelsebob> He seems to be *really* going after just trying to get poor dons to say "ghc is slower than gcc in all cases, you win" – which ofc is a falsehood
14:56:00 <thetallgu1> beelsebob: I think he got discouraged with the Haskell community at some point.
14:57:09 <thetallgu1> beelsebob: he made some proposals a few years ago for sweeping changes in the Haskell syntax, some of which I thought were reasonably interesting, but not a lot of bang for the buck
14:57:39 <beelsebob> hmm
14:58:12 <beelsebob> so he wishes Haskell was his perfect language playground that magically solved all his problems, and when it got very close, but missed he was discouraged?
14:58:20 <dons> i really don't think i've mislead him here. 3x slower in his benchmark, 3x slower on the shootout. GCC -O0 is the benchmark we should hope to beat.
14:58:23 <thetallgu1> beelsebob: I think ever since then (and the lack of positive response) he changed sign.
14:58:34 <beelsebob> dons: indeed
14:58:41 <beelsebob> I don't think anyone ever mislead him
14:58:47 <dons> getting him to submit a benchmark though was really good
14:58:56 <dons> look how much progress we made over the last few years of stones
14:59:02 <pumpkin> moo
14:59:22 <thetallgu1> Hey, that pumpkin is a cow!
14:59:41 <pumpkin> :o
14:59:55 <thetallgu1> or perhaps a bull
14:59:56 <beelsebob> dons: indeed – I think it was particularly harsh of him to accuse you of lazyness, when some of the biggest optimisations like ByteStrings have come straight from your magic fingers
15:00:03 <dons> all this thread did was confirm exactly what I've been saying (and Bulat's been disputing). GHC isn't "thounsands of times slower"
15:00:17 <pumpkin> that statement was just ridiculous
15:00:27 <pumpkin> hyperbole doesn't belong in benchmarking :P
15:01:01 <dons> its just really unclear to me what his point is. or if there's a point wrapped up in fear, and misdirected anger
15:01:06 <TomMD> No, but in many cases it also isn't easy or straight forward to bring GHC compiled Haskell within 3x gcc C code.
15:01:18 <beelsebob> no
15:01:23 <pumpkin> TomMD: using things like uvector really makes it a lot easier
15:01:30 <beelsebob> on the other hand in many cases it's very easy to get Haskell code 50 times faster than C code
15:01:34 <TomMD> pumpkin: Yes, I know.
15:01:37 <beelsebob> (like anything amenable to light weight threading)
15:01:43 <glguy> TomMD, it is as easy as getting the plshootout guys to make it a problem on their site
15:02:00 <glguy> and then waiting patiently
15:02:17 <TomMD> glguy: Are they accepting new problem submissions?
15:02:17 <dons> well, bulat's benchmark was < 3x slower, so what's he complaining about. nothing new to see.
15:02:26 <dons> other than that loop unrolling might be the next big thing for ghc
15:02:33 <glguy> TomMD, probably not :)
15:02:45 <mle> I think it's better to say it's easy to get Haskell code much faster than C code that any human is willing to write.
15:02:55 <pejo> dons, are you measuring using the new codegen, or is that not in HEAD yet?
15:03:06 <beelsebob> yeh – that I find very confusing dons – he posted a benchmark that seemed to be slow, various people analysed it, claus did something clever, and now he seems to think it's a bad thing that said clever thing exists
15:03:12 <dons> no, i'm only using ghc 6.10.1 for this stuff.
15:03:21 <shapr> Is this thread on -cafe?
15:03:25 <TomMD> Yes
15:03:28 <beelsebob> shapr: yeh
15:03:31 <TomMD> Almost made me filter the cafe.
15:03:40 <pumpkin> shapr: I don't recommend reading it if you don't want to get frustrated :)
15:03:46 <beelsebob> well
15:03:50 <beelsebob> there's some nice bits of it
15:03:51 <dons> beelsebob: or even just that the thing he submitted wasn't actually slow. so wtf? it was within the 3x range, and well inside gcc -O0
15:03:56 <beelsebob> there's a couple of cool results too
15:04:00 <shapr> pumpkin: I've dealt with Bulat before, long time ago.
15:04:03 <beelsebob> but yes – it's very frustrating
15:04:21 <pumpkin> shapr: best leave it that way :P
15:04:39 <dons> there's definitely either some personal, or cultural things going on here.
15:04:48 <beelsebob> dons: what I find most amusing is that the kind of example he's pointing out is actually *more* amenable to a compiler with referential transparency on its side than to gcc
15:05:03 <beelsebob> in theory, we could deal with *way* more cases than gcc can deal with
15:05:10 <shapr> dons: Bulat is just difficult, it's not cultural.
15:05:11 <beelsebob> (but it'll take a good few man hours)
15:05:12 <pumpkin> but then again, cafe is still way above anything else I've ever seen... another mailing list I'm on has a 14-year-old responding with "R U A JEW?" to technical questions :)
15:05:31 <pejo> beelsebob, waving the rt-flag as long as we don't take proper advantage of it doesn't exactly convince people though.
15:05:54 <beelsebob> pejo: no – but it certainly gives us hope for the Haskell uber-compiler of doom
15:06:03 <beelsebob> that it's *possible* given the man hours
15:06:04 <dons> so, it seems though that he's not demoralising anyone today
15:06:11 <dons> and if anything, Claus has inspired a new path
15:06:14 <dons> so yaya
15:06:15 <pejo> beelsebob, certainly, I think Supero was a nice demonstration of the potential.
15:06:24 <dons> lemonade from russian lemons
15:06:26 <p_l> beelsebob: gcc isn't the best example you can look up to, I think
15:06:29 <dons> e.g. http://www.reddit.com/r/haskell_proposals/comments/7z1uf/implement_loop_unrolling_for_c_level_loops_in_ghc/
15:06:47 <shapr> In my opinion, Haskell is usually a better choice than C, even seven years ago.
15:06:52 <p_l> dons: such lemonade would be >40%, wouldn't it?
15:07:02 <dons> and it is pretty clear from this thread isn't it, how GHC is doing?
15:07:07 <beelsebob> pejo: no, but it's a nice target to aim for at the moment
15:07:28 <beelsebob> dons: I'm glad you can look on this so calmly
15:07:28 <regulate> p_l: proof? yes
15:07:39 <beelsebob> as you can see, it's got me rather... irritated
15:07:45 <shapr> Whenever someone dumps a bunch of emotion into a discussion, it's hard to learn anything.
15:07:48 <dons> i'm not going to be baited by him. he is trying hard though!
15:08:02 <shapr> dons: Good job, stay cheerful!
15:08:45 <dons> shapr: i just do my little koan: http://tinyurl.com/35p6nt
15:09:11 <dons> and then remember *not* to press reply
15:09:20 <shapr> haha
15:09:28 * beelsebob should probably go bed – hard days playing with new camera tomorrow :)
15:09:35 <dons> :)
15:09:43 <shapr> My original goal for starting #haskell was to learn something nifty. That was it.
15:10:12 <Botje> @vixen are you nifty?
15:10:12 <lambdabot> i truely am
15:10:13 <shapr> I have succeeded beyond my wildest dreams!
15:10:21 <beelsebob> :)
15:10:44 <dons> so this was originally misleading, http://www.haskell.org/pipermail/haskell-cafe/2009-February/056196.html (and no one has reproduced the final result, afaik)
15:11:06 <dons> afaik, the table is this, http://www.haskell.org/pipermail/haskell-cafe/2009-February/056251.html
15:11:10 <shapr> dons: Well, if it helps any, I gain lots of nifty learning from using bunches of code you've written :-)
15:11:10 <beelsebob> dons: we duplicated that at work
15:11:23 <beelsebob> but looking at the asm generated revealed that the compiler had computed the final value
15:11:29 <dons> oh, entirely statically?
15:11:29 <beelsebob> and stuck it in there
15:11:31 <beelsebob> yeh
15:11:54 <gwern> dons: any way to put bulat on moderation or kill this -cafe thread? it's already unfortunately ugly
15:12:08 <dons> shrug
15:12:13 <dons> he'd go bananas
15:12:26 <shapr> I remember Igloo wrote a benchmarking program of some sort once. That seems like the way to learn something to me, make all results reproducible and comparable on many arches.
15:12:27 <dons> i'm done with it. i think we're good. looking into loop unrolling seems profitable
15:12:29 <TomMD> And start his own ML?  I seem to recall that happening once before with someone.
15:12:31 <gwern> better he go bannanas in private than public. geeks can be very stubborn
15:12:43 <allbery_b> not again
15:12:48 <shapr> Bulat is very stubborn.
15:13:01 * allbery_b makes not to delete h-c threads while trying to get his riotous inbox under control
15:13:03 <dons> he's not going to state his position anyway
15:13:06 <allbery_b> note even
15:13:16 <dons> or open tickets.
15:13:24 <travisbrady> dons: any recs if I'd like to do large scale log processing/analysis with ByteString and Data.Array.Vector?  i want to write some stuff to do basic stats, outlier/funky data detection, etc
15:13:26 <dons> so, shrug. we got him to submit a benchmark
15:13:50 <dons> travisbrady: i've been using uvector, but probably best to start with bytestring first
15:14:03 <dons> maybe look at the statistics-fusion library for ideas there
15:14:09 * Axman6 wonders what's going with this bulat fella
15:14:25 * dons longs for the days when he was on uzbek dialup
15:14:36 <gnut> dons: I just bought a copy of real world haskell!
15:14:42 <shapr> Axman6: I believe he is using haskell-cafe as an outlet for pressures in other parts of his life.
15:14:52 <dons> shapr: do you remember when he announced he'd got DSL?
15:14:57 <dons> gnut: woo!
15:14:59 <gnut> now I have something to read on the porcelain throne
15:15:07 <shapr> dons: When was that?
15:15:16 <dons> i'm trying to find it. it was quite a cool post.
15:15:16 <Axman6> shapr: heh, i see
15:15:23 <dons> http://www.mail-archive.com/haskell-cafe@haskell.org/msg20255.html
15:15:26 <gnut> and that's where I do my best thinking :)
15:15:28 * Axman6 fills out police record form
15:15:35 <Cheshire> la la la
15:15:45 <shapr> I know it's sometimes easy for geeks to turn their attention towards trying to 'win' a discussion instead of trying to learn something.
15:16:01 <shapr> I do that myself sometimes.
15:16:10 <TomMD> You do not.  Take that back.
15:16:25 <shapr> heh
15:16:33 <shapr> TomMD: You haven't seen me at this c# job ;-)
15:16:33 <beelsebob> hehe
15:17:19 * allbery_b has been there (occasionally against bulat, even)
15:17:29 <repnop> shapr: i think thats why tech communities come off so hostile often
15:17:30 <allbery_b> and given that I'm barely awake I'll pass, thanks
15:17:35 <shapr> repnop: I agree.
15:17:39 <TomMD> But seriously - it would be great to see unrolling applied to these pure haskell computational jobs we've got.  There is tens to hundreds of lines of *manually* unrolled loops in any optimised hash/cipher implementation that we could ditch.
15:17:50 <allbery_b> (sadly I just figured out which thread, and I'm interested in jhc, darnit)
15:18:08 <dons> TomMD: exactly
15:18:09 <shapr> Yeah, if someone sees a problem, it is their responsibility to either fix it, submit it to a bug tracker, or stfu
15:18:24 <dons> TomMD: we do this surprisingly often, I found out, after asking around a bit.
15:18:27 <dons> cheap win here
15:19:06 <TomMD> dons: the main question in my mind is how to move from Claus's custom unroller for each function to a generic / compiler level.
15:19:15 <ddarius> TomMD: The unroll TH thing has been done before (by Igloo I believe)
15:19:17 <allbery_b> duff's device anyone? automatic unrolling is kinda hard to optimize appropriately without running and gathering data, is my understanding
15:19:33 <allbery_b> sometimes it's a big win, most of the time its a waste of effort
15:19:36 <shapr> Is there any research on what ratio of bus speed to cache size makes compact code faster than unrolled code?
15:19:36 <dons> anyone thought about what it would take to entirely constant fold static streams?
15:19:36 <Axman6> shapr: i had a look, and i couldn't see anything out of the ordinary from him?
15:19:46 <allbery_b> but then I'm not really a compiler expert
15:19:46 <ddarius> dons: The thread mostly destroyed any credibility Bulat had on this topic.-
15:19:49 <TomMD> ddarius: And I wished GHC would automatically unroll hash algorithms before - but my excitement is not diminished by time.
15:19:51 <shapr> Axman6: Who, Bulat?
15:19:54 <Axman6> yes
15:19:56 <Cheshire> is supero unrolling
15:20:03 <dons> so when we fuse sum . enumFromTo down to a single loop, what kind of rules would we need to have to unroll that loop and solve it
15:20:08 <Axman6> yeah* (yes that was a typo, heh)
15:20:14 <dons> shapr: you can measure it ,  at least
15:20:25 <shapr> dons: That would be interesting.
15:20:26 <ddarius> dons: I believe it's trivial with the build/foldr except that, uncontrolled, it leads to code blow-up.
15:20:43 <allbery_b> yep
15:20:51 <dons> hmm. with build/foldr?
15:21:00 <allbery_b> unrolling is easy knowing whne to stop is hard
15:21:02 <dons> i've not seen that. we do get some good examples with streams
15:21:04 <Nafai> shapr!
15:21:08 <shapr> Axman6: What do you think of this? "afaik, ghc can be compared with 20-years old C compilers. it uses registers for performing tight loops but has very simple register allocation procedure. also it doesn't unroll loops"
15:21:09 <dons> e.g. replicate not generating a loop
15:21:13 <shapr> Nafai!
15:21:24 * Heffalump waves
15:21:28 <dons> shapr: so the technical aspect is correct
15:21:30 <Nafai> How's it going dude?
15:21:31 <shapr> hiya Heffalump! Did you meet Lemmih?
15:21:34 <Heffalump> yep
15:21:42 <dons> it uses registers ok for tight loops, and doesn't do loop unrolling
15:21:44 <Axman6> shapr: well the C thing was just mean, but the rest is somewhat true isn't it?
15:21:46 <allbery_b> he's still using gcc as his benchmark?  gcc, as optimizing compilers go, sucks rocks
15:21:48 <dons> it is getting a very clever register allocator though
15:21:59 <Axman6> dons: hooray
15:22:00 <ddarius> Yes, there's a rule that will do fuse conses, so when applied to a static list it reduce completely to a fixed computation (that can then be constant folded in theory), but it's commented out because it generates too much code.
15:22:14 <dons> mmm. cons fusing. interesting
15:22:14 <shapr> Axman6: Right, but 'mean' doesn't belong in a constructive discussion.
15:22:25 <Axman6> heh, indeed
15:22:26 <dons> that's disabled in streams because ghc takes too long to reduce them all :)
15:23:06 <shapr> Axman6: As soon as someone starts being mean, the positions are polarized, and the discussion becomes emotionally charged.
15:23:35 <shapr> dons: That's consfusing to me ;-)
15:23:36 <pumpkin> it's a pity it's hard to moderate mailing lists like htat
15:23:39 <Axman6> shapr: yeah i agree (i missed whichever post that was from)
15:23:40 <dons> hehe
15:23:49 <dons> "Cons fusion to prevent confusion!"
15:23:53 * shapr laughs
15:23:54 <dons> that's an ICFP paper right there
15:23:57 <shapr> yes!
15:24:09 <Axman6> "Cons fusion: it's easy stuff!"
15:24:11 <shapr> dons: Oh hey, I'm giving a talk on STM at a Canadian uni soon!
15:24:11 <dons> i love starting with the title
15:24:14 <dons> then doing the research
15:24:17 <dons> hehe
15:24:18 <Axman6> haha
15:24:53 <dons> so how do we get Claus to be provoked into a loop unrolling example, with out all the flaming going on ?
15:25:08 <dons> -- we did learn things in this thread, but still it got insane
15:25:09 <shapr> Truly, Claus Reinke is good at turning things into constructive discussions.
15:25:44 <dons> bulat really refused to engage with my responses here too, sadly
15:25:56 <shapr> It sure looks like Bulat is trying to start an argument.
15:26:06 <shapr> > Turning this into a ticket with associated test will:
15:26:06 <shapr> but why you think that this is untypical and needs a ticket? ;)
15:26:07 <lambdabot>   <no location info>: parse error on input `;'
15:26:12 <shapr> heh
15:26:36 <shapr> I think the correct response there is "What did you want to accomplish with this thread?"
15:27:07 <ddarius> dons: "Removing Confusion from Cons Fusion"
15:27:39 <Cheshire> have you seen Huttons one
15:27:49 <dons> i think he wanted to prove that i was misleading people, actually. that the shootout programs are all fake library examples, and ghc is never competitive with C (?) "low-level haskell code is usually 3 times harder
15:27:50 <Cheshire> What is the meaning of these constant interruption
15:27:53 <dons> to write and 3 times slower than gcc code. native haskell code is tens
15:27:56 <dons> to thousands times slower than C code"
15:28:18 <pumpkin> I'd still like to see an example of that that isn't deliberately made slow
15:28:22 <pumpkin> (the thousands bit)
15:28:37 <ddarius> pumpkin: That's easy to do.
15:28:47 <dons> ah well. we're done i think. loop unrolling needs some thinking about.
15:28:52 <ddarius> pumpkin: A lot of newbies write code that is extremely inefficient.
15:29:00 <pumpkin> oh well yeah
15:29:10 <pumpkin> but newbies in c will malloc and free the same thing in an inner loop too
15:29:11 <pumpkin> :P
15:29:17 <ddarius> dons: Loop unrolling could be added just by allowing a fixed number of recursive inlines.
15:29:21 <dons> getting rid of those non-fusible left folds that force list generation (sum, length etc) would help
15:29:41 <Cheshire> isn't supero the equiv. of loop unrolling?
15:29:42 <ddarius> I believe that isn't really done, again, for code size reasons.  It's not clear what recursive things to inline.
15:29:57 <shapr> Aha, Bulat feels attacked at http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/53325
15:29:59 <Cheshire> "from mailing list trolling to loop unrolling"
15:30:01 <ddarius> Cheshire: Not really, though it will do that to some extent.
15:30:04 <pumpkin> "i don't need jhc speed, i just warn people that believes Don tales."
15:30:20 <pumpkin> Don the teller of tales
15:30:49 <shapr> Bulat is clearly confused about something.
15:30:51 <dons> shapr: or his last sentence is that i'm misleading people.
15:30:54 <TomMD> Cheshire: Ever since ndm started working there hasn't been any progress in bringing supero to GHC (that I know of).  Its a shame because the status of yhc isn't exactly solid.
15:31:01 <dons> "someone too lazy to test speed yourself tell us tales
15:31:01 <dons> and attack me when i say about real situation
15:31:02 <dons> "
15:31:05 <shapr> dons: Yeah, he clearly believes that. I dunno why, but he does.
15:31:30 <Cheshire> here is my point of view;  benchmarks are lies
15:31:46 <shapr> Cheshire: But useful lies, lies for teaching :-)
15:31:51 <ddarius> There are lies, damn lies, statistics, and benchmarks.
15:32:03 <pumpkin> and The Word of Bluat
15:32:09 <Cheshire> and I love how it's always timing a fact an a fib program
15:32:11 <pumpkin> Bulat, which is only true :)
15:32:17 <shapr> As long as you keep in mind that a benchmark is necessarily a lie, everything works out okay.
15:32:52 <Axman6> shapr: ok, after seeing that link above, i can see what you mean
15:33:10 <shapr> dons: Oh, I think I know what he's talking about!
15:33:56 <shapr> He's upset because he thinks benchmarks involve naive code only.
15:34:14 <shapr> He thinks that hand tuned benchmark programs are deceptive.
15:34:24 <shapr> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/53323
15:34:29 <ddarius> shapr: He says that, and then presents an even more naive example and a broken benchmarking methodology even for a toy benchmark.
15:35:00 <ddarius> He's clearly not interested in facts.
15:35:02 <skorpan> who is bulat and why do we care about him?
15:35:09 <ddarius> skorpan: No one and we don't.
15:35:11 * wli is not impressed with the benchmark methodology on the shootout.
15:35:12 <Cheshire> skorpan, I don't
15:35:25 * Cheshire is waiting for this convo. to die
15:35:31 <ddarius> wli: Indeed, it's all toy benchmarks too, see what Cheshire said above.
15:35:33 <pumpkin> skorpan: one of the feather rufflers on cafe :)
15:35:37 * Cheshire doesn't cre about politics
15:35:37 <shapr> skorpan: Because, he clearly has a lot of energy and emotional investment... if he can get it into his head that we'd rather produce something cool than argue, he'll be a great member of the community!
15:35:52 <wli> Things should be measured across multiple inputs even for microbenchmarks.
15:36:37 <wli> e.g. for Fibonacci numbers, cmdline args for the index of the Fibonacci number to be output.
15:37:17 <allbery_b> I hope nobody is expecting something called a shootout to be an accurate or even appropriate benchmark
15:37:25 <shapr> Well, one approach could be to use something like QuickCheck to generate a class of problems that one submission must solve.
15:37:36 <allbery_b> I tend to expect golfing
15:37:45 <shapr> allbery_b: It seems that Bulat does not.
15:37:52 <wli> I don't see why there shouldn't be something more serious than the shootout floating around, though.
15:37:58 <allbery_b> yep
15:38:10 <Cheshire> allbery_b, everyone trusts it that's the problem...
15:38:14 <allbery_b> he's also several years behind the curve on haskell compilers
15:38:15 <Cheshire> "wow look ATS it the top what's that?"
15:38:27 * shapr laughs at "Shock news – benchmarks lead to compiler and library optimisations. -- News at 11!"
15:38:53 <ddarius> It would take a lot of effort to make even a more meaningful cross language benchmark and even then the results would be highly dubious.
15:39:12 <Axman6> i think it's stupid to expect there to be a compiler that will let you write inefficient code, and it'll make it efficient. GHC is pretty good at doing that anyway
15:39:44 <ddarius> Benchmarks are useful as performance regression tests for particular implementation or personal testing for specific issues.
15:39:44 <allbery_b> cross language, cross system, cross load, there's no way anything i comparable to anything
15:40:17 <shapr> This is a very silly thread.
15:41:32 <shapr> What is it Heffalump used to say a lot? If it's got numbers it's science, if it doesn't it's opinion.
15:41:49 <dons> nice.
15:41:55 <ddarius> Even with numbers, it's can easily not be science.
15:42:23 <wli> Well, let's start with the stupid: how do you make a Fibonacci benchmark scientific?
15:42:24 <ddarius> Having judged a few science fairs, adequate controls are an important and commonly missing or inadequate feature.
15:42:29 <shapr> ddarius: Yeah, but "not fast" and that sort of thing is purely a personal thing.
15:42:31 <dons> i wonder if you would catch personality issues like Bulat's in a job interview
15:42:46 <shapr> wli: At a minimum, be able to reproduce it.
15:42:48 <ddarius> dons: You can't tell quickly enough?
15:42:49 <dons> could you accidentally employ someone who would turn out to be so hard to collaborate with? or would it be obvious?
15:43:10 <ddarius> dons: In some cases it will be obvious, in others it won't be.
15:43:16 <shapr> dons: It's usually obvious, but sometimes those people are nice when they're first hired because they're desperate.
15:43:24 <dons> mm
15:43:32 <wli> shapr: But more specifically, what do you demand of the programs, what metrics do you use on the results, what does "being able to reproduce it" mean?
15:43:48 <allbery_b> you have to hit the trigger, which could be awfully narrow
15:43:48 <shapr> dons: In my experience, rules of any sort exist primarily to remove unhelpful people from a community.
15:43:52 <gnut> if they're really good, you won't find out until it's too late
15:43:57 <ddarius> Sometimes personality issues are just not some thing that becomes immediately a problem and most of the time its the mix of personalities.
15:44:01 <gnut> good at their game, that is.
15:44:26 <wli> shapr: One could, for instance, use statistical tests for whether the mean of one set of samples is larger than the mean for another set of samples.
15:44:30 <shapr> wli: I demand an approach that will help me learn something, or help me improve something.
15:44:57 <ddarius> There was a recent paper about improving benchmarking methodology.
15:45:13 <wli> That sounds like a good thing to look at.
15:45:20 <gnut> they should fold in the variance in those numbers
15:45:41 <wli> Reporting variances, confidence intervals, etc. all sounds like a good idea.
15:45:44 <shapr> To me, science/research/etc boils down to "Hey, I figured out a better way to do something, check it out!"
15:45:48 <wli> But what about asymptotic growth?
15:46:01 <lament> shapr: sounds more like engineering
15:46:15 <shapr> lament: Pi spigot?
15:46:17 <lament> i thought science was "hey, i figured out how this thing works"
15:46:31 <wli> It's not too meaningful to have a Fibonacci benchmark where things get specialized to a particular number's bit patterns.
15:46:44 <shapr> lament: Hm, could be.
15:46:46 <wli> Or its factorization, or whatever.
15:46:55 <shapr> wli: Unless it's a crypto benchmark?
15:47:19 <gnut> i thought science was "hey, i figured something out, and it's cool"
15:47:27 <shapr> Dude, I totally have to talk to Bulat.
15:47:30 <wli> shapr: Well, yes, but I'm sticking to a benchmark involving computing one-off Fibonacci numbers.
15:47:30 <shapr> gnut: Yeah, I like that too.
15:48:01 <Cheshire> and art is "hey"
15:48:01 <Cheshire> and music is "hey!"
15:48:08 <wli> I'd think for the Fibonacci stuff you'd have inputs and outputs.
15:48:14 <whpearson> Is there any reason why you can't specify a more specific instances of a typeclass. E.g. I want to define and use an instance of monoid [t] where t is specific type... Now I can see that you can't differentiate between two instances for the same type e.g. Num s, but I'd rather not have to wrap a whole new type.
15:48:17 <shapr> Cheshire: I like it!
15:48:19 <ddarius> shapr: Why do you have to talk to Bulat?
15:48:51 <wli> The inputs may vary, and so you can plot out a curve of how performance varies with input.
15:48:53 <shapr> ddarius: I'm going to try to communicate to him that he's just dumping a bunch of bad vibes, not accomplishing anything useful.
15:49:13 <shapr> ddarius: I've done it before, once or twice :-)
15:49:49 <allbery_b> <shapr> Dude, I totally have to talk to Bulat.
15:49:54 <allbery_b> masochism can be treated
15:50:11 <ddarius> shapr: To Bulat or to others?
15:50:36 <shapr> allbery_b: I am convinced that most people want to contribute positively, and that some people just don't know the right way to do that.
15:50:39 <shapr> ddarius: Bulat specifically.
15:50:47 <ddarius> shapr: It doesn't seem to have worked.
15:51:09 <shapr> ddarius: It worked at the time :-)
15:51:10 <dons> i think he'll just drain your energy, shapr , since he won't do a mind meld
15:51:17 * shapr shrugs
15:51:19 <shapr> I gotta try.
15:51:34 <shapr> And then I gotta do my best to get rid of him if it doesn't work.
15:52:09 <pumpkin> assassin?
15:52:30 <shapr> no :-P
15:52:48 <pumpkin> oh, I was just about to call my shady friends
15:52:51 * pumpkin sulks
15:52:58 * shapr grins
15:55:15 <pumpkin> yay for sebastian sylvain's response
15:55:21 <pumpkin> I hope that thread ends there :)
15:55:45 <skorpan> sylvan was in my "nollk" when i started at chalmers
15:55:47 <skorpan> yay for chalmers
15:55:53 <pumpkin> nollk?
15:55:58 <jeffwheeler> Is it possible to search gtk2hs libs through Hoogle? There's the Hoogle built specifically for gtk2hs, but it is apparently old.
15:56:06 <skorpan> that's the "committee" for welcoming new students
15:56:10 <pumpkin> ah :)
15:56:11 * ddarius wishes people would just not add to troublesome threads from the get-go.
15:56:27 <skorpan> nollk means nollkommitté which means "zero committee", and by zero they mean the new students
15:56:39 <pumpkin> I just avoid posting on cafe at all :P which gets me excluded from future logo voting :(
15:57:03 <jeffwheeler> . . . whenever that happens. :P
15:57:15 <skorpan> i only posted to café twice iirc and in one of them i took sarcasm/irony for real
15:57:23 <dons> ddarius: it would be interesting to have a 'mute' for a thread
15:57:27 <dons> so an admin could cut off a thread
15:57:39 <dons> 'this thread is closed'
15:57:40 <pumpkin> we need a "forum" :P
15:57:46 * shapr shrugs
15:59:50 <thetallgu1> welcome to the internet, guys.
16:00:14 <shapr> yay!
16:00:31 <pumpkin> you can be complacent about it :) or you can strive to change attitudes in smaller groups :P
16:00:37 <shapr> yes!
16:00:50 <shapr> sOpen: Noon Feb28th at BlueSpec!
16:01:10 <FunctorSalad> just drag politics into the argument too
16:01:12 <FunctorSalad> ;)
16:01:43 <sOpen> shapr, cool, thanks!
16:01:58 <pumpkin> ooh a generic feistel cipher in haskell
16:06:17 <mriou_> dons: in my experience, trolls are better ignored
16:06:59 <dons> yep
16:07:15 <mriou_> if you have a real troll, he'll create another thread anyway :)
16:07:47 <glguy> That's an interesting alternative to letting trolls take over the IRC channel by sending to the mailing list
16:07:53 <shapr> heh
16:07:57 <mriou_> those people are tiring though
16:08:09 <shapr> glguy: I don't have a banhammer for -cafe :-)
16:08:13 <shapr> wish I did somedays
16:08:22 <vininim> trolling in realtime is funnier. =P
16:09:08 <mriou_> ignored, they get tired quickly, banned they come back
16:09:52 <mriou_> problem is, they're very good at being hard to ignore :)
16:10:01 * Axman6 hasn't had a troll come back to #macintosh for a long time :(
16:10:10 <shapr> mriou_: I think banning works on #haskell
16:10:28 <glguy> discussion on moderation strategies is welcome to move into #haskell-ops
16:10:36 <vininim> which thread you guys are talking about anyway? I didn't notice the loop unrolling getting into trolling
16:10:41 <mriou_> shapr: irc has a different dynamic though
16:11:15 <Axman6> does bulat come on irc?
16:11:20 <pumpkin> vininim: maybe you have a frustration filter on your mail client :)
16:11:47 <vininim> heh
16:12:00 <vininim> I read from archives though
16:12:08 <FunctorSalad> you could train one of the bayesian filters on frustratingness...
16:12:18 <Nafai> So are you guys saying I should just mark "Read all" to the 125 messages sitting in my -cafe mailbox?
16:12:22 <Axman6> i found that -cafe was too high traffic for me, and i wasn't interested enough
16:12:56 * FunctorSalad just has 8385 unread in it ;)
16:13:01 * wli has doubts it's feasible to get the necessary semantic information from word-based filters. Perhaps some natural languagre parsing is in order.
16:13:17 <pumpkin> Axman6: I use a gmail filter to send it past the inbox, and just check it when I want to. It organizes things into conversations for you so it's quite easy to sift through comfortably without it cluttering up your inbox
16:13:31 <FunctorSalad> wli: don't you think trolloid arguments would correlate pretty wll with certain words?
16:13:38 <vininim> gmail and archiving is awesome for mailing lists
16:13:39 <FunctorSalad> *well
16:13:46 <Axman6> pumpkin: me too, but i rarely found aything that i was interested enough in to read :\
16:14:01 <pumpkin> wli: a simple bag-o'-words approach might work though... if it contains bulat/coppin give it a low score, for example :P
16:14:11 <FunctorSalad> ^^
16:14:16 <vininim> hahaha
16:14:22 <wli> FunctorSalad: It's possible, but I just don't know if it's true.
16:14:30 <vininim> come on, coppin is sometimes fun for those who don't daily read the ml
16:14:40 <vininim> *funny
16:14:43 * shapr has 21k unread in -cafe :-/
16:14:46 <wli> FunctorSalad: Perhaps something more on the order of newsreaders' killfiles is in order.
16:15:18 <FunctorSalad> wli: it doesn't give you the same fuzzy feeling of your AI filter improving all the time though :D
16:15:56 <wli> FunctorSalad: Do all the semantic analysis on email/etc. metadata, and let the autofilter kill whole threads at a time, ban people, domains, etc.
16:16:50 <shapr> dons: The message finding that extra test in the asm is interesting.
16:18:01 <wli> FunctorSalad: Well, I don't mean to literally hand write killfiles, just to use the categorization methods used by those killfiles in the AI filter.
16:18:49 <shapr> Oh hey, I should totally email the mailing lists about the Boston Area User's Group meeting!
16:20:47 <wli> You want to pass from message-by-message filtering on body contents to thread-by-thread and author-by-author filtering based on the message body affairs.
16:21:33 <wli> Or, at least, I do, esp. when dealing with high-volume mailing lists.
16:22:11 <eu-prleu-peupeu> hello peoples of haskle!
16:22:26 <eu-prleu-peupeu> i salut you from planet earth
16:22:53 <FunctorSalad> wli: it seems body word count would have more predictive power than metadata, but maybe that's just wishful thinking
16:23:07 <shapr> Oh, I like Tom Davie's message!
16:24:28 <wli> FunctorSalad: Well, when I want to get rid of crap started by trolls, I generally want to kill the whole thread.
16:24:47 <wli> FunctorSalad: Also, I'd love for the AI filters to identify trolls.
16:24:48 <FunctorSalad> wli: it may seem very simplistic but sets of words alone can convey a lot of information about topic and emotion... maybe word digrams would be viable if you have a huge amount of mails
16:25:50 <FunctorSalad> wli: I was thinking of more of a general interestingness pre-filter than a troll filter :)
16:26:26 <FunctorSalad> (to priorize what to read)
16:27:01 <wli> FunctorSalad: So, message body analysis says yes or no on a message-by-message basis, which splits things up into ham and spam. Then the frequent authors of spam get dumped into a troll vs. non-troll database of authors. Then the filtering, when carried out, doesn't go message-by-message, but kills whole threads at a time.
16:27:46 <wli> Kill any thread with either a troll posting to it or a spam message.
16:27:56 <mriou_> wli: usually if you reach more than 20 messages in the thread with more than 30% messages from a single person, chances of trolling are high
16:28:39 <vininim> uh, I must be really naive and stupid at language design, but the guy has some argument.
16:28:41 <wli> mriou: Sounds like a good idea, too. Thread and author awareness would be good in general.
16:28:58 <pumpkin> vininim: what is it?
16:29:42 <shapr> catechu: Want to come to a Boston Area Haskell User's Group on Feb28th at BlueSpec?
16:30:03 <wli> Thread awareness also gives you a tree structure. You can nuke subthreads vs. whole threads per se. Say, the subthread rooted at a troll's post vs. the whole thread.
16:30:24 <vininim> pumpkin: if I brought it here I would possibly be trolling :)
16:30:36 <pumpkin> vininim: not if you had a legitimate point :P
16:30:38 <vininim> but I agree with some points
16:30:55 <Sekaino> Another fun question! :)
16:31:00 <wli> FunctorSalad: So I think this thread and author awareness has a lot of potential.
16:31:04 <mriou_> wli: I don't know of any ML community that found a way to totally get rid of trolls though
16:31:09 <pumpkin> vininim: the haskell community seems to be quite open to criticism in general though :)
16:31:49 <mriou_> vininim: it's not necessarily having a point, it's driving it to a point where you flood the whole thread (plus another)
16:31:49 <wli> mriou: Well, this is only about mail filter design, not solving the social problem altogether.
16:31:51 <vininim> it's like haskell is praised for its abstraction, but it's normal idiom doesn't seem to be optimizable that hard
16:32:05 <Sekaino> Say I want to define an instance for Monad, but only want to restrict it to types that are members of Eq.  i.e. instance (Eq a) => Monad (Foo a) where...  or similar.   How would I do it?
16:32:05 <vininim> (as of now)
16:32:43 <vininim> so people end up having to resort to things that defeat haskell purpose to get in benchmarks reach, but that's not news and he doesn't offer nothing new =P
16:32:45 <pumpkin> vininim: how do you mean? things like Data.Stream (the fusible one) are almost drop-in replacements for lists and are significantly better in terms of performance
16:33:25 <vininim> the template haskell loop unrolling shouldn't even be compared to gcc loop unrolling
16:34:01 <pumpkin> vininim: ... :)
16:34:47 <Saizan__> Sekaino: that's not really supported by the Monad class
16:34:50 <FunctorSalad> vininim: hmm if you only have to uglify the inner loops for performance and can have the rest of the program in nice haskell, that's still a win I'd think
16:34:59 <Saizan__> Sekaino: you can say that it's designed to prevent that
16:35:17 <Sekaino> Fair enough, I was just curious.
16:35:18 <pumpkin> vininim: can you elaborate on why they shouldn't be compared?
16:35:37 <Sekaino> I could see situations where conditional instances for type wrappers might be desired though.
16:35:44 <pumpkin> no one's saying having good compiler support for unrolling isn't important, but the TH can help in some cases until that happens
16:35:59 <Saizan__> Sekaino: those are called restricted monads generally, and if you need to use them the best current approach is to use rmonad from hackage
16:36:12 <pumpkin> rmonad ftw :)
16:36:21 <Sekaino> Saizan__, thanks. :)  Good information.
16:36:23 <mathijs> I have an infinite Data.Tree, which I wish to collect some data from. I can climb the tree level by level (levels), but some branches traverse in directions I don't need. I can't use fmap because that will climb one branch further and further.  Is there a way to control traversal for Data.Tree?
16:36:24 <vininim> pumpkin: the c example is idiomatic standard c, the template haskell is haskell-fu at it's most
16:36:44 <pumpkin> vininim: dons' example using uvector?
16:36:50 <vininim> claus
16:36:55 <pumpkin> ah, of course
16:37:10 <pumpkin> but sumU (enumFromToU 0 bigNumber) doesn't seem too bad
16:37:13 <pumpkin> and is almost comparable
16:37:29 <pumpkin> in terms of speed
16:38:08 <pumpkin> and using Data.Stream as a list replacement, you could write it even more simply, without having scary U suffixes :P
16:38:53 <mriou_> pumpkin: Data.Stream has significantly better performance mostly for infinite lists no? or would it be faster than say Sequence for all type of lists?
16:39:20 <pumpkin> I thought Sequence was slower than a regular list for listy things, but if you ever need random/last access, Sequence is the way to go
16:39:40 <pumpkin> but I think Stream is better for many typical listy operations (things that people won't yell at you for using lists for)
16:39:55 <thetallgu1> There's nothing like coding up a bit of raw javascript to remind you just how much Haskell rocks.
16:39:57 <Saizan__> mathijs: it looks like you need to write your own traversal pattern matching on the contructors
16:40:26 <pumpkin> either way, uvector has a nice API that is pretty close to that of regular lists and is crazy fast :) but of course you can't use infinite vectors anymore
16:40:50 <pumpkin> and I have actually written things significantly bigger than sums of sequential numbers using it
16:40:57 <pumpkin> so it's not just silly benchmarks that are helped by it
16:40:59 <mriou_> pumpkin: we need a micro-benchmark ;)
16:41:12 <pumpkin> :D
16:41:28 * wli wonders if there are RMonad instances for Set 
16:41:36 <pumpkin> wli: yes! it's awesome
16:41:40 <vininim> oh, I missed the Data.Stream example
16:41:53 <mathijs> Saizan__: yeah I was planning to do that, I just hoped there was some kind of traverseBy or traverseWhile thingy
16:41:57 <vininim> quite nice
16:42:10 <pumpkin> vininim: I don't think anyone proposed that on the thread did they?
16:42:13 * shapr sighs
16:42:15 <pumpkin> but uvector is pretty sweet :)
16:42:29 <ddarius> shapr: You need to make a South Massachusetts Area User Group.
16:42:38 <shapr> haha
16:42:51 <pumpkin> shapr: how's interest looking for the CHUG at this point?
16:43:26 <vininim> pumpkin: not the uvector
16:43:44 <wli> No instance for IntSet
16:43:46 <vininim> dan doel one
16:43:46 <pumpkin> vininim: ah, I must've missed the Data.Stream example
16:43:46 <mriou_> mmmh I might give uvector a good try then
16:43:53 <vininim> Data.List.Stream
16:43:55 <pumpkin> wli: you could write one easily though :) you need a suitable instance
16:44:16 <pumpkin> that lib also has Data.Stream if you want it
16:44:36 <pumpkin> oh I see :)
16:44:49 <pumpkin> yeah, that's almost less work than the uvector one, but not as fast :)
16:45:53 <pumpkin> vininim: anyway, I think the basic point is that the state of the art is a lot better than bulat presents it as being, and you can write good looking code that performs well, without ever using a magic hash
16:47:26 <vininim> yes, but well, he's just ignorant  not really a troll. =P
16:47:55 <pumpkin> vininim: I think that would be a possible explanation if he hadn't been around for so long, which is why people are starting to get frustrated with him
16:48:20 <vininim> heh
16:49:04 <pumpkin> anyway, time to go to a play :)
16:49:06 <pumpkin> ciao
16:49:18 <redditbot> Feistel Ciphers and DES in Haskell
16:50:19 <mriou_> vininim: I just counted, 28 out of 80 :)
16:53:51 <ehird> What's a good alternative to a list with fast `elem` performance?
16:54:12 <wli> Set
16:54:15 <Axman6> Data.Set?
16:54:31 <ehird> ok, thanks :)
16:57:05 <ehird> are Data.Sets ordered?
16:57:26 <ddarius> ehird: You can't tell, but I believe that that is the case.
16:57:34 <ehird> OK
16:58:13 <Sekaino> Well one would imagine any data structure is technically ordered when it's written to memory...
16:59:13 <ddarius> Sekaino: The VMM might foil that.
16:59:25 <Sekaino> :)
16:59:43 <FunctorSalad> what's the point of calling getSessionDynflags, immediately followed by setSessionDynFlags here? http://www.haskell.org/haskellwiki/GHC/As_a_library
17:00:43 <FunctorSalad> hmm maybe I should ask such questions on the talk pages ;)
17:02:48 <chessguy> @bot
17:02:48 <lambdabot> :)
17:02:48 <lunabot>  :)
17:03:35 <olsner> lunabot: @bot
17:04:37 <ddarius> FunctorSalad: I would check the history of the page.
17:05:31 <whpearson> Would people object to me making Sum and Product functors?
17:05:51 <ddarius> whpearson: It depends.
17:06:15 <ddarius> whpearson: Also, you may want to consider making them Num, etc. instances (if they aren't already)
17:06:26 <FunctorSalad> ddarius: it's there from the first first real edit
17:07:02 <jamii> @seen conal
17:07:02 <lambdabot> conal is in #haskell, #ghc and #haskell-in-depth. I last heard conal speak 2h 28m 36s ago.
17:07:03 <Gracenotes> hm. on that note, is there a GHC extension that allows type classes in datatype definitions?
17:07:04 <FunctorSalad> hmm apparently setSessionDynFlags "also reads the package database (unless it has already been read), and prepares the compilers knowledge about packages"
17:07:12 <conal> jamii: hi
17:07:19 <jamii> hi.
17:07:48 <altmattr> jamii: hi
17:07:49 <FunctorSalad> Gracenotes: existentials?
17:08:12 <Gracenotes> oh, hm... that would probably work, wouldn't it
17:08:13 <jamii> conal: I'm in the middle of writing neural network library using vector-space.
17:08:21 <conal> neat
17:08:31 <jamii> conal: I've ended up needing recompose' :: HasBasis v => (Basis v -> Scalar v) -> v
17:08:33 <whpearson> ddarius: Nope they aren't Num instances.
17:08:46 <coconut> Hi, how can I learn how CPS transformation works and what it's good for? (I more ore less understand CPS itself)
17:08:51 <FunctorSalad> . o O ( that DynFlags type is slightly intimidating :) )
17:08:57 <jamii> conal: I dont think this is possible in the current library - it would have to be in the vectorspace class
17:09:23 <FunctorSalad> Gracenotes: the annoying part is that you don't get to use "deriving" (except Typeable) :-(
17:09:27 <jamii> conal: Mind if I add a patch for it?
17:10:03 <FunctorSalad> conal: while we're talking about vector-space... is there any provision for finite-dimensional spaces?
17:10:12 <conal> jamii: interesting.  there's a name for that signature.  searching my memory.  it's the isomorphism between a vector space and the linear maps from that space to its scalar field.
17:10:14 <Gracenotes> ah
17:10:27 <ddarius> coconut: Olivier Danvy has several good papers on the CPS transform.
17:10:38 <conal> jamii: note that Basis -> Scalar v  is a linear map.
17:10:38 <jamii> conal: Yep, I need it to calculate the gradient.
17:11:11 <bremner> conal: sounds like the usual identification of R^n and (R^n)^*
17:11:27 <conal> bremner: yeah.  what's it called?  i'm blanking.
17:11:30 * ddarius finds the word "identification" too strong.
17:11:34 <FunctorSalad> dual space?
17:11:35 <conal> jamii: so a nicer signature might be (v :-* Scalar v) -> v
17:11:35 <ddarius> conal: The dual
17:11:44 <conal> oh yeah.
17:11:50 <FunctorSalad> incidentally there's also an iso for finite-dim spaces ;)
17:11:57 <coconut> ddarius: thanks! is there an elementary one available online?
17:11:58 <FunctorSalad> *only
17:12:00 <FunctorSalad> not also
17:12:17 <jamii> FunctorSalad: I think the isomophisim is V -> V^*^* ?
17:12:25 <FunctorSalad> though I don't know how it works with computability in the picture :)
17:12:25 <jamii> Rather than V -> V^*
17:12:30 <ddarius> jamii: That's the natural isomorphism.
17:12:37 <FunctorSalad> yep
17:12:44 <FunctorSalad> (only for finite dimensions too)
17:12:48 <ddarius> jamii: Every finite vector space of the same dimension is isomorphic.
17:13:16 <ddarius> So, R^n and (R^n)^* both being n-dimensional, are isomorphic.  But, to witness this isomorphism, you need a basis.
17:14:06 <conal> jamii: please do me send a patch.  i'll work with it after the icfp deadline (march 2).  i have a lot more writing work to do.
17:14:35 * FunctorSalad wonders whether it would be a good idea to make vectors from all the different math libraries on hackage instances of VectorSpace
17:14:41 <jamii> ddarius: Yep. I remember that class. I was the only one in my group who found dual spaces obvious, which I attribute to haskell
17:14:51 <jamii> conal: Cool. On it
17:15:20 <conal> :)
17:15:40 <jamii> FunctorSalad: Definitely. Seeing as all the machine learning libraries Im writing work on arbitrary vector spaces.
17:15:58 <conal> jamii: btw, i may gpl that library for a while.  would you have a problem with that change?
17:16:02 <ddarius> coconut: http://www.brics.dk/~danvy/ lists all of his publications, most (all?) are available online.  You probably want some of his older ones listed here: http://www.brics.dk/~danvy/research.html
17:16:14 <ddarius> coconut: Just pick out ones that sound reasonable.
17:16:24 <jamii> conal: No problem.
17:16:37 <conal> cool.
17:17:13 <mathijs> sorry... didn't pay attention in maths class I guess... how can I find which power of 2 a number is?
17:17:27 <ddarius> mathijs: Log
17:17:28 <jamii> mathijs: log x / log 2
17:17:37 <Axman6> logBase 2 x
17:17:38 <conal> logBase 2 x
17:17:40 <conal> :)
17:17:44 <jamii> :-P
17:17:44 <mathijs> cool thanks :)
17:17:48 <Axman6> hooray, beelsebob'd conal :P
17:18:01 <FunctorSalad> jamii: how did you write recompose' (since it's not possible unless the basis is finite)?
17:18:20 <olsner> beelsebob: congratulations, you're now a verb!
17:18:26 <ddarius> mathijs: If it's a big number, log isn't going to work (in most programming languages) and you'd be better off counting divisions.
17:18:48 <conal> olsner: that means beelsebob is now imperative instead of functional.
17:18:50 <ddarius> (log won't work because it "only" works on floating point numbers)
17:19:17 <jamii> FunctorSalad: Havent yet. I just wrote it per instance for my test cases. Havent thought about infinite dimensional spaces yet
17:19:48 <olsner> conal: a heap of fail upon him!
17:19:52 <jamii> FunctorSalad: I have a whole terms worth of notes on infinite dimensional spaces. Let me go dig them up while I think about this
17:20:10 <olsner> he's referentially filthy now
17:20:11 <ddarius> jamii: I would recommend ignoring that case
17:20:13 <mathijs> ddarius: I'll keep that in mind... for now it seems to work
17:21:15 <FunctorSalad> jamii: the standard example would be V := real-valued sequences with only finitely many non-zero entries, then V has countable dimension but V* has uncountable dimension (but as I said, I'm not sure about the effect of computability)
17:22:13 <FunctorSalad> (you get a linear functional for *any* sequence, even with infinitely many non-zero entries)
17:22:28 <FunctorSalad> (which acts by the "infinite dot product")
17:22:47 <jamii> ddarius: Im actually hoping to have perceptrons working in inf. dim. spaces
17:23:56 <ddarius> jamii: Then I recommend not ignoring that case.
17:24:07 <jamii> ddarius: :-)
17:24:24 <jberryman> does anyone else find unfoldr really cumbersome to use? I would rather have it be unfoldr :: (b->Bool) -> (b->(a,b)) -> b -> [a]
17:24:32 <jberryman> am I doing something wrong?
17:24:43 * whpearson has a nasty habit of wanting to write multiple paramatised type classes -_-
17:24:55 <ddarius> jberryman: Write unfoldr' in terms of unfoldr with that signature.
17:25:21 <ddarius> jberryman: In my opinion, unfoldr's signature is the right one for a couple of reasons, one being that it avoids code duplication.
17:25:53 <ddarius> (In particular, assume you have the unfoldr' with the signature you desire and consider how you'd write unfoldr in terms of it.)
17:26:12 <newsham> jberryman: I use a wrapper  unfoldUntil :: (b -> Bool) -> (b -> (a, b)) -> b -> [a]
17:26:15 <jamii> In a normed inf dim space I can at least provide `gradient :: (a :-* b) -> [a]` st gradient f converges.
17:26:38 <newsham> unfoldUntil :: (b -> Bool) -> (b -> (a, b)) -> b -> [a]
17:26:44 <newsham> unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
17:26:48 <FunctorSalad> maybe unfold should use it's own type rather than (Maybe (a, b)) to denote 1 + a*b
17:27:01 <ddarius> FunctorSalad: That would be even worse.
17:27:04 <FunctorSalad> the (Maybe (a,b)) always looks odd to me
17:27:23 <FunctorSalad> why would that be worse?
17:27:44 * wli suggested MonadPlus last night.
17:27:46 <mokus> I always liked Either () (a,b) as a compromise
17:28:17 <jamii> *normed countably inf dim space
17:28:39 <newsham> > unfoldUntil null (splitAt 3) "this is a test"
17:28:41 <lambdabot>   ["thi","s i","s a"," te","st"]
17:28:57 <ddarius> FunctorSalad: You'd have to learn this new type, few(er) standard functions would work with it, most likely your functions wouldn't produce it.  You'd end up having to convert to/from it and Maybe (or something else) and it would still have the same "problem" as the Maybe version.
17:29:07 <ddarius> Basically, you don't gain anything and you lose a lot.
17:29:28 <wli> chunk n = unfoldr \s -> guard (not $ null s) >> return (splitAt n s)
17:29:29 <newsham> I dont see anything wrong with having a low-level unfoldr and them simpler helpers based on that
17:29:31 <FunctorSalad> ddarius: ok, I'm probably looking at it from the wrong angle
17:29:37 <jberryman> ddarius, newsham: thanks
17:30:10 <ddarius> newsham: I agree.  I have no problem with an "unfoldUntil" in the standard libraries.  I just think unfoldr made the right choice.
17:30:14 <ddarius> (for itself)
17:30:21 <FunctorSalad> (the point being concise usability rather than pointing out the similarity to [a] = Nil | Cons a [a]
17:30:22 <newsham> *nod*
17:30:59 <ddarius> FunctorSalad: How would your suggesting make anything noticably more concise?
17:31:29 <FunctorSalad> ddarius: can't think of anything better than Maybe (a,b) in that regard
17:32:09 <ddarius> On a related topic, I think use of Bool should be minimized to be replaced with Maybe returning functions in many cases.
17:32:17 <ddarius> E.g. instead of null, uncons.
17:32:23 <SamB> huh
17:32:32 <dons> i wish we had CSR to go with CPR
17:32:45 <FunctorSalad> hxt uses empty ArrowList's for "false" ;)
17:32:46 <dons> so that returning a Maybe allowed avoiding a heap check
17:32:48 <ddarius> dons: What would the rule be?
17:32:54 <SamB> JHC is stealing -- er, integrating -- our changes
17:33:10 <SamB> some of them, anyway
17:33:12 <ddarius> SamB: That's (part of) how open source works, no?
17:33:18 <dons> ddarius: something like:   T | F -> Int#,   N | J a -> (# Int#, a #)
17:33:27 <SamB> I guess so
17:33:35 <dons> so there'd be a sums to products flattening , to keep things in registers on return
17:33:36 <ddarius> You stole his entire compiler, did you not? (Not you specifically)
17:33:41 <SamB> hehe, yes
17:33:59 <wli> > let unfoldM f x = do { (y, x') <- f x ; ys <- unfoldM f x' ; return $ y : ys } `mplus` return [] ; chunk n = unfoldM (\s -> guard (not $ null s) >> return (splitAt n s)) in chunk 3 "this is a test" :: Maybe [String]
17:34:01 <lambdabot>   Just ["thi","s i","s a"," te","st"]
17:34:04 <dons> i think i can construct a program where returning a Bool will be slower than an Int representing a Bool
17:34:11 <SamB> I didn't know darcs 2 could do that
17:34:15 <dons> due to the lack of a constructed sum result optimisation
17:34:25 <dons> leading to heap checks for the return
17:34:43 <wli> @type let unfoldM f x = do { (y, x') <- f x ; ys <- unfoldM f x' ; return $ y : ys } `mplus` return [] ; chunk n = unfoldM (\s -> guard (not $ null s) >> return (splitAt n s)) in (unfoldM, chunk)
17:34:44 <lambdabot> forall t (m :: * -> *) t1 a (m1 :: * -> *). (MonadPlus m1, MonadPlus m) => ((t -> m (t1, t)) -> t -> m [t1], Int -> [a] -> m1 [[a]])
17:34:53 <ddarius> dons: Will that still be the case with pointer tagging or will you need a bigger sum?
17:35:01 * wli likes that.
17:35:02 <dons> pointer tagging makes it cheaper, i think
17:35:07 <dons> we still get a heap check though
17:35:16 <dons> it just becomes cheaper to use the result
17:35:30 <SamB> why do you need a heap check with Bool ?
17:35:37 <dons> i should blog this and try to implement the optimisation
17:35:40 <SamB> aren't True and False already there ?
17:35:42 <dons> those heap checks bug me no end
17:36:03 <ddarius> dons wants to break multithreading in GHC
17:36:10 <dons> yep
17:36:15 <dons> hella break
17:36:28 <dons> returning a sum type => implicit yield
17:36:31 <dons> we must squash them!
17:36:59 <SamB> dons: and they said it was pre-emptive!
17:37:01 <ddarius> We'll know GHC optimization has succeeded when the GHC implementors need to add "safe-points" in loops.
17:37:06 <dons> hehe
17:37:19 <Axman6> dons: this loop unrolling stuff looks quite impressive indeed
17:37:37 <dons> well, i think our loops are low level enough that it really does matter
17:37:43 <dons> there used to be so much cruft that you'd not notice
17:37:51 <Axman6> heh
17:37:52 <ddarius> I'm very confident that someone (and I'm pretty sure it was Igloo) did that when TH was brand-spanking new.
17:38:02 <dons> ddarius: yes, it rings a bell.
17:38:08 <dons> Igloo: was it you?
17:38:34 <Igloo> I think I wrote something to unroll Mandelbrot, yes
17:38:46 <SamB> hmm, that involved going outside ... right ?
17:39:32 <Igloo> Almost an order of magnitude speedup according to http://web.comlab.ox.ac.uk/people/Ian.Lynagh/Fraskell/
17:39:48 * SamB wonders if anyone will get his horrible, horrible pun
17:40:03 <dons> hey, that's not on hackage!
17:40:20 <dons> oh, yes, i remember seafood and you going at it over TH optimisations for a while there
17:40:38 <dons> he was doing algebraic stuff, and you were doing loops and other things lik ethat
17:41:00 <Igloo> Oh, but a lot of that is not using (^)
17:41:05 <ddarius> SamB: Nope.
17:41:21 <Igloo> 20-25% improvement for unrolling a 3 or 4-deep loop by the looks of it
17:42:10 <dons> is that code still extant?
17:42:29 <Igloo> Links are at the bottom
17:42:34 <Igloo> But i'll doubtless need updating
17:42:46 <dons> groovy
17:42:50 <wli> Curiously throwError's error doesn't get propagated along; the RHS of the mplus seems to clobber the error.
17:43:11 <ddarius> wli: mplus = catch roughly for error monads
17:43:53 <wli> So basically the guard is doing a throwError "" and the mplus is catching it and clobbering it.
17:44:45 <wli> When I do a throwError by hand it gets clobbered by the mplus in like fashion.
17:44:54 <ddarius> I endorse Cale's proposal to split MonadPlus into two classes (actually three, return MonadZero) with the same operations but different laws.
17:45:19 <wli> > mzero :: Either String [String]
17:45:20 <lambdabot>   Left ""
17:45:59 <wli> ddarius: Where does return MonadZero come up?
17:46:20 <ddarius> MonadPlus used to be split into MonadZero and MonadPlus.  I'd like to return to that.
17:46:51 <wli> Yeah, I get that part, the third class for "return MonadZero" is what stumps me.
17:47:37 <ddarius> Cale suggests splitting MonadPlus into MonadPlus and MonadOrElse, the latter for "catchy" things like Maybe and Either, the former for "non-deterministic" things like [] and parsers.
17:49:08 * SamB considers forwarding his local mail to his actual email account
17:49:19 <redditbot> Loop unrolling with Template Haskell, applied to mandelbrot
17:49:26 <SamB> ... but then I would have to make my cron jobs shut up when successful
17:49:29 <dons> Igloo: haha
17:49:31 <dons> :)
17:49:46 <Igloo> dons: Huh?
17:49:46 <SamB> someone seems to have gotten Hackage confused with reddit ?
17:50:04 <Igloo> Oh
17:50:08 <SamB> dons: why do you laugh evilly after reddit posts ?
17:53:37 <dons> Igloo: was the loop unrolling trick published anywhere?
17:53:47 <dons> is there a TH paper that talks about doing loop unrolling ?
17:53:52 <ddarius> Igloo would know, but I think so.
17:54:48 <Igloo> It might have been in the MetaOCaml workshop; I don't remember
17:56:45 <dons> back in the day when there was a metaocaml workshop? :)
17:56:55 <dons> the one in vancouver (?)
17:56:59 <SamB> what ... the ... heck ?
17:57:07 * SamB sees an *old* citeseer page!
17:57:13 <Igloo> I don't remember
17:57:18 <blackdog> hey, is there any explicit framework for benchmarking in haskell? in particular, it'd be nice to have explicit access to memory usage/GC stats at runtime rather than searching through profiling reports afterwards...
17:57:27 <SamB> huh,
17:57:47 <SamB> it looks like citeseerx is down and they failed it over to classic citeseer ?
17:58:18 <chessguy> blackdog:  there's a few benchmarking packages on hackage. not sure if they're what you're looking for
17:58:26 <SamB> wierd
17:58:30 <SamB> now I'm at citeseerx
17:58:39 <SamB> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.9813
17:58:40 <blackdog> chessguy: yeah, i tried out Microbench - was a bit buggy, and only does cpu time
17:58:51 <blackdog> (and i think the author's AWOL anyway)
17:58:51 <chessguy> blackdog:  there are a few others too
17:58:57 * chessguy shrugs
17:59:27 <dons> blackdog: +RTS -sstderr should have hooks, eh?
17:59:37 <blackdog> righto, fair enough. don't mind writing my own, just wanted to make sure i wasn't reinventing the wheel (now with added corners!)
18:00:51 <SamB> dons: this is such a paper http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.9813
18:07:16 * SamB adds some funny tags to http://citeseerx.ist.psu.edu/summary?doi=10.1.1.10.9607
18:11:19 <SamB> arg, my compose key is broken
18:11:43 <shapr> Has anyone built ghc 6.10 for ARM?
18:16:34 <Axman6> @hoogle Pvar
18:16:34 <lambdabot> Language.Haskell.Syntax HsPVar :: HsName -> HsPat
18:16:42 <Axman6> hmm
18:18:12 <Axman6> @hoogle RightHandSide
18:18:12 <lambdabot> No results found
18:19:30 <Axman6> dons or Igloo, got any tips on getting Fraskell running under 6.10? there's a lot of stuff it can;t find (i've changed the imports so they follow the current naming)
18:20:09 <jeffwheeler> Is there any package on Hackage that I can look to as an example for setting up testing with modern QuickCheck?
18:20:29 <jeffwheeler> I have a feeling I should be separating it into different files, but I'm not sure the best way.
18:20:54 <ddarius> xmonad perhaps?
18:20:55 <Axman6> i think they're generaly split into different files, yes
18:21:01 <SamB> you don't HAVE to
18:21:12 <SamB> do you have a whole lot of tests ?
18:21:18 <jeffwheeler> xmonad is pretty big; I was thinking something like Binary or something.
18:21:28 <jeffwheeler> SamB: probably not. But I haven't written them yet. ;)
18:21:44 <SamB> well, you can put them in your file before they become unmanageable
18:22:00 <SamB> there is some script floating around in various encodings
18:22:12 <SamB> (maybe sometimes perl, sometimes Haskell ... that sort of thing ;-)
18:22:16 <gwern> Axman6: I once tried fraskell. I think I got bogged down on type changes in gtk - before it became gtk2hs, is how long ago it was
18:22:20 <SamB> that will help you to test properties
18:22:44 <SamB> gwern: and how many packages per month were you hackaging at the time ?
18:22:52 <Axman6> gwern: ah. well the errors i'm getting look like they could be TH errors actually
18:23:05 <SamB> Axman6: TH has changed a lot
18:23:08 <gwern> SamB: hey, I gave a solid day to fraskell!
18:23:13 <Axman6> SamB: apparently so :\
18:23:14 <SamB> gwern: hah
18:23:20 <gwern> SamB: and... somewhere around 50-100 :(
18:23:32 <SamB> Igloo: do you know a page about changes to TH ?
18:23:37 <Axman6> Pvar -> VarP?
18:23:53 * SamB checks the TH page
18:24:53 <SamB> Axman6: does it look like it's supposed to be a pattern ?
18:25:07 <Axman6> no idea...
18:25:26 <Axman6> instance Defines Pat where; defines (VarP v) = [v]; defines (TupP ps) = unionMap defines ps
18:25:35 <Axman6> i changed thos to VarP and TupP btw
18:25:37 <gwern> in fraskell's case, I think I decided that it'd be easier to just rewrite the thing
18:25:39 * SamB gets ready to file a doc bug for the way http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
18:25:52 <SamB> direct links to http://research.microsoft.com/~simonpj/papers/meta-haskell/notes2.ps
18:26:34 <Igloo> Axman6: That sounds right
18:26:50 <SamB> hmm, but I can't find an HTML page about that one :-(
18:26:56 <SamB> SPJ!!!
18:26:59 <Axman6> Igloo: if i can get this all fixed up and working, would you like me to send you a diff or something?
18:27:00 * Igloo wouldn't have thoguth it would be /that/ hard to update
18:27:23 <Igloo> I doubt anything fundamental has changed, just renamings
18:27:39 <SamB> Igloo: those can be hard to figure out
18:27:40 <Axman6> Fun -> ?
18:27:40 <Igloo> Axman6: If you get it fixed up and working then you are the new maintainer. Congratulations  :-)
18:27:49 <Axman6> Igloo: haha, sure :)
18:27:50 <Igloo> FunD, probably
18:27:57 <Axman6> thanks
18:28:19 <SamB> Axman6: don't you just love Open Source ?
18:28:27 <Axman6> indeed :)
18:28:54 <Axman6> not the nasty GNU kind though (though i am aware Fraskell is GPL'd)
18:30:20 * shapr watches the Coconut Google Tech Talk on youtube.
18:30:40 * olsner watches shapr watch stuff
18:31:04 <shapr> olsner: You like coconut?
18:31:26 <Axman6> what's coconut?
18:31:34 <shapr> http://www.youtube.com/watch?v=yHd0u6zuWdw
18:31:37 <olsner> I don't even know what it is, and am barely conscious as it is
18:31:47 <olsner> shapr: hi, though :P
18:32:00 <shapr> hej olsner!
18:32:19 <shapr> ska du resa till USA och drick öl med mig?
18:32:34 <shapr> er, dricka... whatever.
18:32:41 <olsner> tjaba tjenare hallå! nån dag, kanske... men idag ska jag nog börja med att sova
18:33:04 <shapr> good idea
18:33:39 <olsner> yep, I've been converging on that idea for a few hours already, talking some random finnish in #esoteric etc
18:34:17 * olsner implements sleep (now, actually)
18:34:21 <Axman6> Igloo: i'm finding that using ghci and eg :info Tup<tab> is making this process quite easy
18:35:50 <Axman6> whoot, errors are now down to a side that fits on my terminal :P
18:38:31 <Axman6> anyone know what RightHandSide might be? (instance FreeVars e => FreeVars (RightHandSide e) where)
18:40:13 <shapr> Axman6: It's there to represent the free variables onthe right hand side of the expression?
18:40:36 <shapr> It's a type that's being parameterised?
18:41:14 * wli Shouldn't that be partially evaluated?
18:42:19 <Axman6> shapr: i reallt have no idea, i've never done any work with TH, and i'm wondering where i came from
18:42:25 <shapr> oh
18:42:54 <Saizan> it makes me think of Body, but that's not parametrized
18:42:55 <Axman6> trying to get this code of Igloo's to work
18:43:44 <jeffwheeler> I'm a bit lost trying to figure out what `cabal test` does . . . there don't seem to be any properties in the cabal file that are used frequently.
18:43:55 <mmorrow> Axman6: TH hacking?! :)
18:44:01 <shapr> jeffwheeler: Maybe it should run the unit tests?
18:44:18 <Axman6> mmorrow: well, not really. TH conversion from old TH to current TH
18:44:18 <jeffwheeler> shapr: I gathered that; how do I hook into it.
18:44:31 <Saizan> jeffwheeler: it runs the runTests (or simiraly named) UserHook, currently
18:44:40 <Axman6> mmorrow: though, i know you're the man when it comes to TH, so any help you can give would be awesome :)
18:44:52 <mmorrow> Axman6: what are you doing?
18:44:56 <jeffwheeler> Saizan: ah, that's something I can google! Thanks. :)
18:45:12 <Saizan> ?hoogle UserHooks
18:45:12 <lambdabot> module Distribution.Simple.UserHooks
18:45:12 <lambdabot> Distribution.Simple data UserHooks
18:45:12 <lambdabot> Distribution.Simple UserHooks :: Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO () -> IO (Maybe PackageDescription) -> [PPSuffixHandler] -> [Program] -> Args -> ConfigFlags -> IO
18:45:12 <lambdabot> HookedBuildInfo -> (Either GenericPackageDescription PackageDescription, HookedBuildInfo) -> ConfigFlags -> IO LocalBuildInfo -> Args -> ConfigFlags -> PackageDescription -> LocalBuildInfo -> IO () -
18:45:14 <lambdabot> > Args -> BuildFlags -> IO HookedBuildInfo -> PackageDescription -> LocalBuildInfo -> UserHooks -> BuildFlags -> IO () -> Args -> BuildFlags -> PackageDescription -> LocalBuildInfo -> IO () -> Args -
18:45:14 <Axman6> trying to get the code from http://web.comlab.ox.ac.uk/people/Ian.Lynagh/Fraskell/ to work with 6.10
18:45:17 <lambdabot> [10 @more lines]
18:45:24 <Saizan> eek, flood
18:45:44 <Igloo> Axman6: Axman6 Might be Body
18:45:53 <jeffwheeler> Yeah, "cabal test" wasn't finding much useful stuff. Thanks!
18:46:09 <Axman6> i'll try it, thanks
18:46:42 <dons> blackdog: you were asking about stats at runtime?
18:46:47 <dons> without using -sstderr
18:46:59 <Axman6> Igloo: any clue about DotDot?
18:47:01 <SamB> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1586#a1586
18:47:01 <dons> iavor and i looked at the runtime headers, and it looks like the GC status can be bound to
18:47:06 <Axman6> seems like an odd name...
18:47:10 <SamB> Why does this work in GHC with no flags?
18:47:11 <dons> so i'll see if i can whip up a nice binding to them
18:47:20 <SamB> shouldn't the MR kill it ?
18:47:33 <Igloo> Axman6: It was probably the .. in export lists
18:47:57 <Igloo> Axman6: If it's an instance then you could comment it out or delete it, and see what the typechecker complains is missing
18:48:09 <Axman6> ah, good idea :)
18:48:21 <dons> Igloo: have you looked at  FFI bindings to Stats.c in rts/ before?
18:48:31 <dons> or do you know why its not been done? :)
18:48:32 <Saizan> jeffwheeler: btw, the idea is to completely reform testing support, you may want to comment on this http://hackage.haskell.org/trac/hackage/ticket/215
18:48:36 <Axman6> Igloo: heh, no complaints...
18:48:40 <blackdog> dons: yeah
18:48:48 <Igloo> dons: No idea
18:49:01 <dons> they seem perfect for bindings, fwiw.
18:49:12 <dons> and i think will enable a new kind of self-inspection we've not had
18:49:19 <dons> programs will be able to report on their own bad behaviour :)
18:49:25 <jeffwheeler> Saizan: thanks for the link.
18:49:53 <dons> you could imagine a modified 'main' that emits warnings when your GC perf stats are > some threshold
18:49:59 <dons> and other kinds of system warnings
18:50:02 <dons> seems all very cool, imo
18:50:55 <blackdog> dons: that is AWESOME :)
18:51:12 <dons> blackdog: so check back in a couple of days if i've not pinged you
18:53:15 <Axman6> Igloo: last problem is Statement: instance (Defines p, Defines d, FreeVars e, FreeVars d) => FreeVars (Statement p e d) where
18:53:31 <Igloo> Axman6: Stmt
18:53:43 <mmorrow> Axman6: looking at the code, this might be useful as a reference for the new TH syn http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/src/Language-Haskell-Meta-Syntax-Vars.html#Vars
18:54:01 <Axman6> tried that looking at that, but Stmt has no types like statement does
18:54:18 <mmorrow> yeah, you'll have to change Stament .. to just "Stmt"
18:54:24 <mmorrow> *Statement
18:54:31 <Axman6> ok, thanks
18:55:09 <shapr> catechu: Boston Area Haskell User's Group?
18:55:14 <mmorrow> also, looks like you have the choice of either doing s/String/Name/ and then fixing all code that uses said function to use Name, or doing (nameBase :: Name -> String) (or something)
18:56:19 <mmorrow> wow, fraskell has a bunch of sweet TH code.. can't believe i haven't seen it before
18:56:33 <sjanssen> @google fraskell
18:56:35 <lambdabot> http://web.comlab.ox.ac.uk/people/Ian.Lynagh/Fraskell/
18:56:35 <lambdabot> Title: Fraskell
18:57:37 <mmorrow> hmm, actually i think i've seen this code in a paper
18:57:47 <mmorrow> but one that i forgot about
18:57:56 * mmorrow googlemachines
18:58:31 <mmorrow> Axman6: well, nameBase or just show
18:58:50 <mmorrow> show would be the safer bet
18:59:25 <Axman6> argh, ok now i have no idea what i'm doign -_-
18:59:43 <mmorrow> just wing it, it'll work out :)
18:59:49 <Axman6> i am :P
18:59:53 <mmorrow> hehe
19:00:13 * mmorrow knows that dance
19:00:42 <SamB> so no answers about why http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1586#a1586 works with no flags to GHC ?
19:01:23 <Axman6> SamB: is there a reason it shouldn't? (probably the bang patterns i guess...)
19:01:37 --- mode: ChanServ set +o glguy
19:01:38 <SamB> Axman6: I was thinking the MR
19:01:42 --- mode: glguy set -ob glguy *!*@gateway/web/ajax/mibbit.com/x-69373a940f878eab
19:01:45 <SamB> ss = 4
19:01:51 <Axman6> MR?
19:01:57 <SamB> shouldn't that be typed ss :: Integer ?
19:02:13 <SamB> Axman6: the infamous ...
19:03:46 <SamB> Axman6: you know, the Monomorphism Restriction
19:03:56 <SamB> hugs gives this:
19:04:04 <mmorrow> > help
19:04:05 <lambdabot>   Not in scope: `help'
19:04:08 <Axman6> i know of it, but not what it actually is
19:04:09 <mmorrow> aww
19:04:13 <SamB> ERROR "regress/tests/bugs/RayT.hs":87 - Type error in application
19:04:13 <SamB> *** Expression     : V (f x dx) (f y dy) n
19:04:13 <SamB> *** Term           : n
19:04:13 <SamB> *** Type           : Integer
19:04:13 <SamB> *** Does not match : Double
19:05:08 <Axman6> bloody hell. listening to the ave maria and it's sending shivers down my spine
19:05:43 <Axman6> mmorrow: i am getting a lot of String/Name errors btw :\
19:05:43 <SamB> oh, those aren't bang patterns
19:05:52 <SamB> those are just H98 strict fields
19:06:19 <Axman6> ah, didn't know that was H98
19:07:50 <Axman6> SamB: with some vector code i wa working with, i found a nice convention for working with vector operations was to use .x where . would be on the side of the vector(s). so you could have n *. (V x y z) = V (x*n) (y*n) (z*n), and also .*.
19:08:08 <SamB> Axman6: this is just a compiler test case, okay ;-P
19:08:15 <Axman6> think i picked that up from some of Don's code
19:08:16 <SamB> we don't need style tips really
19:08:23 <Axman6> heh, ok :P
19:08:34 <Saizan> SamB: i've always understood that the MR is enforced lazily, i.e. don't let it be polymorphic but if you can tell which type to use from the context use that, like lambda-bound vs. let-bound variables
19:09:01 <SamB> but of course if by using an odd style you can find bugs, post them to the trac
19:09:25 <SamB> (or a typical style, for that matter ;-)
19:09:30 <SamB> Saizan: hmm.
19:10:28 <SamB> does hugs have a way to trace the typechecking process?
19:10:46 <Saizan> which is a bit ugly since you can no longer give a principal type to ss by looking at its definition
19:11:05 <SamB> Saizan: can you direct me to chapter and verse ?
19:14:39 <newsham> I have a question about someting in chapter 26 (bloom filter) of RWH
19:15:21 <newsham> under the section "polymorphic testing" an unused argument is used, supposedly to specify a type.
19:15:46 <newsham> (pg600).
19:16:11 <newsham> :t prop_one_present (undefined :: Int) :: (Hashable a) => a -> Property
19:16:12 <lambdabot> Not in scope: `prop_one_present'
19:16:12 <lambdabot>     Not in scope: type constructor or class `Hashable'
19:16:41 <newsham> did the authors intend to give an explicit type signature to prop_one_present to force "a" to be "Int" here?
19:17:10 <newsham> the authors did not provide any type signatures so the type is:  prop_one_present :: (Hashable a) => b -> a -> Property
19:17:24 <newsham> perhaps the intention was   (Hashable a) => a -> a -> Property?
19:18:47 <Saizan> SamB: the "Motivation" for Rule 2 makes it quite clear i think http://www.haskell.org/onlinereport/decls.html
19:20:23 <Saizan> newsham: why use two parameters though?
19:20:39 <newsham> saizan: see the definition of prop_one_present here http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html
19:21:15 <SamB> Saizan: hmm. So I resolve them for the whole module at one go?
19:21:26 <newsham> I am guessing, but I thikn the intention was that the tester could provide one argument to fix the polymorphism to make it monomorphic
19:22:02 <newsham> at least this is what the prose seems to be hinting at, but as far as I can tell thats not what the code is actually doing here
19:22:16 <newsham> (perhaps there's a hidden type signature in the author's code that didnt make it into the book)
19:22:44 <Saizan> SamB: it seems like that
19:23:09 <SamB> so ... why doesn't hugs load it then ?
19:23:27 <Saizan> newsham: seeing the example uses i tend to afree
19:23:29 <Saizan> *agree
19:23:47 <Saizan> it's a bug!
19:24:19 <newsham> how much for an upgrade? ;-)
19:24:22 <newsham> gotta run, bbl.
19:28:32 <Saizan> btw, that one in the report looks like the clearer description of the MR available around
19:33:37 * wli never bothered trying to figure out why anyone thought the MR was necessary.
19:34:23 <SamB> wli: hey, I'm only implementing it because it's in the standard
19:35:18 <wli> Yeah. I'm trying to reencode these MPEG-4 audio files as mp3's so my car can read them.
19:35:59 <SamB> after I first thought I'd got it working, my next step was to try to get -fno-monomorphism-restriction working again too ;-)
19:39:13 <chessguy> heh. i wonder how many classes i can make this an instance of
19:39:13 <chessguy> http://codepad.org/pt9HJKRp
19:40:53 <chessguy> i think Monoid is going to be a problem
19:44:56 <Saizan> chessguy: comonad
19:46:36 <chessguy> Saizan, yeah, that one looks pretty easy
19:46:44 <Axman6> Boléro is such an awesome piece of music
19:48:23 * Axman6 turns it down again
19:48:54 <chessguy> @type (+) `fmap` (Node 3 [])
19:48:55 <lambdabot> forall a. (Num a) => Tree (a -> a)
19:50:44 <Axman6> how hard would it be to make an instance of Show for functions anyway? could you use TH to get something that could show the name, and maybe show a lambda if it's not fully applied?
19:51:20 <Axman6> guess you can't take the arguments passed to a function from the function to show them too :\
19:51:44 <chessguy> Applicative isn't bad for Named either
19:52:04 <Saizan> , [| (+) 1 2 |]
19:52:06 <lunabot>  AppE (AppE (VarE +) (LitE (IntegerL 1))) (LitE (IntegerL 2))
19:52:39 <chessguy> Axman6, i'm actually playing with this Named class for the purpose of using it to wrap functions
19:52:59 <chessguy> so i can pattern match on them
19:54:04 <chessguy> hm, Monad will be easy too :)
19:54:36 <Axman6> chessguy: could do some funky stuff like instance MonadPlus a => MonadPlus (Names a) where mplus (Names s1 x) (Named s2 y)  = Named ("("++s1 ++ " `mplus` " ++ s2++")") (mplus x y)
19:55:06 <Axman6> and build up a history of what was done
19:56:03 <chessguy> that could be interesting
19:56:18 <Axman6> :t ap
19:56:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:56:37 <chessguy> @type (<*>)
19:56:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:56:51 <chessguy> wow, i never would have recognized that a week ago
19:56:54 <chessguy> byorgey++
19:56:59 <newsham> axman: show (\x -> 2*x) == show (\x -> x+x)   ?
19:57:01 <chessguy> gotta love the typeclassopedia :)
19:57:23 <Axman6> newsham: probably not
19:57:39 <newsham> so no referential transparency
19:58:01 <Axman6> newsham: well, they are different functions
19:58:20 <newsham> or at least thats the argument in http://haskell.org/haskellwiki/Show_instance_for_functions#Theoretical_answer
19:58:40 <dolio> No they aren't.
19:59:22 <newsham> i dont know if its valid, but wouldnt the counterargument be that equality isnt defined over functions ?
19:59:22 <dolio> At least, excepting out-there stuff, like Float, possibly.
19:59:34 <SamB> dolio: sure they are!
19:59:45 <SamB> try Galois Fields
20:00:10 <SamB> that reminds me, Galois should have a Field Hockey team ;-P
20:00:14 <wli> Continued fractions, p-adic numbers, etc.
20:00:47 <SamB> > (\x -> 2*x) x
20:00:49 <lambdabot>   2 * x
20:01:01 <SamB> > (\x -> x+x) x
20:01:02 <lambdabot>   x + x
20:01:34 <dolio> > (\x -> 2*x) 2 :: Int
20:01:36 <lambdabot>   4
20:01:40 <dolio> > (\x -> x+x) 2 :: Int
20:01:41 <lambdabot>   4
20:01:46 <newsham> ?let sheq x y = (show x) == (show y)
20:01:46 <lambdabot>  Defined.
20:01:49 <dolio> You're not allowed to distinguish those.
20:01:54 <newsham> > sheq (\x -> 2*x) (\x -> x*x)
20:01:55 <SamB> (this is what we get for not including properties that must be proven in our typeclasses ;-P)
20:01:55 <lambdabot>       Overlapping instances for Show (t -> t)
20:01:55 <lambdabot>        arising from a use of `s...
20:02:20 <newsham> > sheq ((\x -> 2*x) x) ((\x -> x*x) x)
20:02:20 <SamB> newsham: it's trying to use the one from SmallCheck *and* the one from lambdabot ...
20:02:21 <lambdabot>   False
20:03:33 <chessguy> newsham,  the approach i want to experiment with is wrapping all such functions in "Named", and then saying "look, if they have the same label, and they're the same type, they're the same. it's up to the client to make sure that's ok"
20:03:51 <Saizan> newsham: you start to lose a lot of equational reasoning if you allow things that behave the same to be distingued
20:06:16 <SamB> @spell seize
20:06:35 <newsham> saizan: but if your intent is for debugging, then is it really an issue?  you dont usually use "show f" in a program, just in dev
20:06:36 <chessguy> @source MonadPlus
20:06:36 <lambdabot> MonadPlus not available
20:07:36 <jeffwheeler> Err . . . "*** Gave up! Passed only 20 tests."? It didn't fail any tests (it states so when that happens), but it only passed 20.
20:07:45 <jeffwheeler> I presume that means there were too many constraints/shrinks?
20:07:53 <Saizan> newsham: ah, ok, in that case the problem is that ghc doesn't store the code with each function
20:08:16 <chessguy> @index MonadPlus
20:08:16 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:08:16 <Saizan> jeffwheeler: yeah
20:08:34 <Saizan> jeffwheeler: more that too many generated cases were discarded
20:10:32 <jeffwheeler> Saizan: this is the code that's causing the error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1590; I suppose expecting the random int to be within the random length of the list is a bit picky.
20:10:50 <jeffwheeler> Saizan: (that is, in the second one)
20:13:25 <saml> http://unicodeforyou.appspot.com/lamda   large lambda!!!!!!!
20:13:51 <jeffwheeler> http://unicodeforyou.appspot.com/lambda
20:13:56 <gwern> λ <-- doesn't look so large to me
20:14:15 <gwern> 'sides, that's the greek lambda, not the math lambda we all know n love
20:14:52 <Axman6> that's an ugly lambda
20:15:02 <jeffwheeler> http://λ.com
20:15:07 <jeffwheeler> works in my browser
20:15:07 <Axman6> ok, maybe the font i'm using makes it an ugly lambda
20:15:47 <gwern> whoa, that url does work
20:15:53 <gwern> that's pretty darn cool
20:16:03 <jeffwheeler> I've seen the snowman.com site before
20:16:14 <jeffwheeler> except I thought it was owned by Cabel Sasser or whatever
20:16:20 <jeffwheeler> one of the Panic guys
20:16:28 <Saizan> jeffwheeler: yeah, i'd use foraAll (choose (0, length l)) $ \n ->
20:16:51 <jeffwheeler> Saizan: oh, that's neat; thanks.
20:17:29 <erikc> you can have unicode urls?
20:17:36 <jeffwheeler> sorta
20:17:53 <jeffwheeler> erikc: look at how the URI expands in your address bar, and you can register that
20:18:04 <erikc> heh, weird
20:20:25 <dons> here's an idea: write a haskell binding to the nytimes
20:20:26 <dons> http://developer.nytimes.com/
20:21:02 <newsham> dons: have a RWH question for bloom filter chapter.  can you field?
20:21:24 <dons> try bos, he wrote it.
20:21:32 <dons> he's the bloomfilter mega guru
20:21:38 <newsham> danke.  will catch him.
20:23:58 <shapr> or ask edwardk
20:24:15 <chessguy>  @get-slap
20:24:21 <chessguy> @get-slap
20:24:21 <lambdabot> shapr!!
20:24:21 <Nafai> It's about Scala, but interesting: http://www.sauria.com/blog/2009/02/20/refactoring-in-the-functional-programming-world/
20:24:23 <shapr> whaat?
20:27:36 <chessguy> that's a strange blog post. he seems to switch topics in the middle of it
20:28:23 <vostibackle> is haskell better than lisp for pattern matching on trees which represent first-order sentences to do unification, substitution, etc?
20:28:54 <dons> it has built in pattern matching, unlike lisp
20:29:12 <dons> pattern matching on data is also highly optimised in haskell
20:29:35 <regulate> is there an equivallent of perldoc in this universe?
20:29:48 <SamB> regulate: not quite.
20:29:49 <dons> regulate: haddock?
20:29:53 <regulate> ufh
20:30:02 <chessguy> i almost said "literate haskell" :)
20:30:06 <Saizan> hoogle --info, if you setup your database right
20:30:26 <SamB> oh, I guess chessguy is the closest ;-)
20:30:40 <SamB> regulate: what did you want to do with it ?
20:30:49 <vostibackle> dons: yeah, I started thinking haskell might be better when I noticed a bunch of stuff about pattern matching. I don't know haskell at all though so I'm not sure if the pattern matching stuff can do what I know I could eventually do (with a lot of work) in lisp. I guess I'll do a tutorial..
20:31:10 * Nafai finally got through the -cafe mailing list for today
20:31:29 <SamB> Nafai: that's a strange thing to do ;-P
20:31:32 <dons> hehe
20:31:37 <dons> it was a long day on -cafe
20:31:44 <chessguy> vostibackle, i've done a bit of logic-sentence fiddling in haskell. what are you trying to do?
20:31:45 <dons> but hey, we learned some TH magic
20:31:51 <Nafai> SamB: What, read -cafe?
20:31:55 <regulate> SamB: command line reference
20:32:02 <SamB> Nafai: try to get through it
20:32:10 <SamB> regulate: what is this "command line" you speak of ?
20:32:29 <SamB> er, I mean, are you looking for manpages or ?
20:32:31 <Saizan> vostibackle: e.g. see how unification is done in this demo prolog interpreter: http://darcs.haskell.org/hugs98/demos/prolog/Subst.hs
20:32:35 <blackdog> dons: also, i learned that GHC is too slow for everything ever and i should write all my code in C++
20:32:38 <blackdog> learning is fun!
20:32:39 <vostibackle> Saizan: awesome, thanks
20:33:01 <vostibackle> chessguy: toying around with an AI idea
20:33:07 * blackdog goes back to writing hideously inefficient javascript
20:33:08 <dons> i learned that ghc can sum ints in 4 instructions, which is nice.
20:33:10 * chessguy likes AI :)
20:33:18 <SamB> dons: 4?
20:33:21 <chessguy> i'd love to hear more about it, if you care to share
20:33:41 <SamB> vostibackle: oh, it sounded like you wanted to write a compiler to me!
20:34:11 <regulate> SamB: it could be smarter than that
20:34:15 <vostibackle> SamB: I meant first-order logical language :)
20:34:31 <Nafai> Darn
20:34:35 <Nafai> Not enough time for Haskell today
20:34:40 <Nafai> And maybe not tomorrow
20:34:41 <SamB> regulate: you want library documentation then ?
20:35:13 <regulate> SamB: without having to fire up a browser, yeah.
20:35:43 <SamB> regulate: not at the moment
20:36:06 <SamB> well, I guess you could try the hoogle thing
20:36:20 <regulate> then i guess i'll read up on web libraries
20:36:30 <Saizan> for the "standard" libraries it works out of the box
20:36:55 <regulate> i'm also going to have ghci's :info use this
20:37:08 <Saizan> i.e. the ones on http://haskell.org/ghc/docs/latest/html/libraries/index.htmls
20:37:12 <Furious_Joe> How do I pattern match against a data constructor in a function declaration? So for "data ProgOptions = ConfFile Port Users Speed SaveFile", "readConf (config portNum userTree maxSpeed saveFile) = blablabla" breaks.
20:37:39 <chessguy> Furious_Joe, you can't
20:37:45 <Furious_Joe> :(
20:37:53 <SamB> you have to put in the data constructor
20:38:14 <Furious_Joe> SamB: what do you mean?
20:38:32 <SamB> readConf (ConfFile portNum userTree maxSpeed saveFile) = blablabla
20:39:27 <Furious_Joe> but then what variables are the parts of the constructor bound to?
20:39:49 <SamB> portNum etc.
20:41:09 <Furious_Joe> that works, thanks
20:41:26 <SamB> you are welcome
20:42:22 <Furious_Joe> Will that work, even though ConfFile represents a string?
20:42:36 <Axman6> what do you mean?
20:43:24 <Furious_Joe> well, ConfFile is a string that points to a file, so elswhere I have "type ConfFile = String"
20:44:12 <SamB> type and data constructors are in different namespace
20:44:14 <SamB> s
20:44:27 <SamB> and yeah, the "data" declaration syntax is confusing
20:44:28 <rwbarton> Furious_Joe: I think you intended to have a data constructor in your data ProgOptions definition
20:44:47 <SamB> no matter how used to it *I* am by this point ... it still doesn't make any sense
20:44:50 <rwbarton> data ProgOptions = X ConfFile Port Users Speed SaveFile, where X is a name for a data constructor
20:45:17 <Furious_Joe> oh, ok, thanks.
20:45:35 <rwbarton> often people use the same name for the data constructor (if there's only one) and the type constructor, which is confusing in its own way
20:45:36 <SamB> oh!
20:45:48 <SamB> is that what he was trying to do
20:45:57 <rwbarton> that's my guess :)
20:48:12 <Furious_Joe> that seems to have fixed everything, thanks
20:49:21 <redditbot> Who's going to write a Haskell binding to the New York Times?
21:16:30 <senxhnsshp> can Haskell handle huge matrices as well as C++?
21:16:42 <senxhnsshp> i mean huge huge sparse ones, 20K*500K
21:17:25 <Axman6> there's interfaces to things like lapack
21:18:43 <wli> That's not that big of a matrix.
21:19:14 <wli> The truly big ones fill up supercomputers' RAM entirely, and they've got numerous terabytes of RAM.
21:21:22 <Elly> senxhnsshp: at that point, it's not C++ handling the matrix; they probably have their own code to efficiently represent those matrices in memory
21:22:36 <BMeph> C++ handles sparse matrices? That's news to me. :)
21:23:15 <wli> The truly big ones people don't represent explicitly; they use something of a caching scheme and recompute the elements as-needed.
21:34:40 <wli> LAPACK doesn't work well for me; I need things like fraction-free Gaussian elimination with arbitrary-precision integers, arbitrary-precision rational arithmetic, quad-precision or higher-precision floating point, etc.
21:35:08 <Axman6> o.O
21:35:18 <Axman6> what sort of stuff do you do?
21:36:39 <wli> Well, it's all recreational and/or pedagogical, but it's all relatively dumb. Some of it is computing approximations for special functions, where you need to work in a higher precision than you're eventually going to use the approximation for.
21:38:13 <wli> The integer arithmetic is for some integer linear equations that arise when I'm trying to do algebra for recreational/pedagogical purposes.
21:38:59 <wli> Similar for the rational arithmetic.
21:39:45 <wli> The linear algebra over the rationals arises when you're trying to implement division by algebraic numbers, for instance.
21:42:59 <wli> Hmm, STArray isn't an instance of MArray?
21:43:00 <hackage> Uploaded to hackage: AVar 0.0.4
21:44:14 <Axman6> :t unsafeCoerce
21:44:15 <lambdabot> Not in scope: `unsafeCoerce'
21:44:33 <Axman6> , [|$ty|unsafeCoerce|]
21:44:34 <lunabot>  luna: parse error on input `|'
21:44:40 <Axman6> , [|$ty|unsafeCoerce]
21:44:41 <lunabot>  luna: parse error on input `|'
21:44:49 <Axman6> , [$ty|unsafeCoerce|]
21:44:52 <lunabot>  luna: Exception when trying to run compile-time code:
21:44:57 <Axman6> :\
21:46:18 <Gracenotes> aha, I have discovered Another Annoying Acronym: tbh
21:46:41 <Gracenotes> acronyms-you-wish-people-wouldn't-use-because-you-usually-have-to-look-them-up
21:46:42 * wli tries to remember how fraction-free Gaussian elimination works.
21:47:02 <Gracenotes> wli: lots of multiplication? :/
21:47:19 <ozy`> Axman6: say, are you using the updated TM bundle?
21:47:23 <wli> Not sure.
21:47:32 <rwbarton> wli: It's decidedly nontrivial.  I don't know more than that.
21:47:44 <Axman6> ozy`: i don't think i am actually. i'll svn up now ;)
21:48:22 <wli> Maybe I should just try polymorphic Gaussian elimination.
21:49:07 <ozy`> Axman6: it has my contact information in it, in case you find any more holes... I haven't had as much time to work on it lately so I'm going to leave it alone for the time being unless there's an issue
21:49:24 <Axman6> ok, sure
22:00:27 <ddarius> @seen luqui
22:00:27 <lambdabot> I saw luqui leaving #haskell 2d 16h 23m 15s ago, and .
22:02:26 <jme_009> 3
22:02:27 <jme_009> 2
22:02:27 <jme_009> 1
22:02:29 <jme_009> ?DCC SEND "ff???f?" 0 0 0
22:02:29 <lambdabot> Unknown command, try @list
22:03:04 <Elly> oops?
22:03:12 <shapr> yeactl
22:24:43 <wli> For some reason I thought fraction-free Gaussian elimination was not that much more involved than ordinary Gaussian elimination, but anyway.
22:39:05 <ivanm> @yow!
22:39:05 <lambdabot> Is it 1974?  What's for SUPPER?  Can I spend my COLLEGE FUND in one
22:39:05 <lambdabot> wild afternoon??
22:39:12 <ivanm> (just to ensure this channel wasn't dead...)
22:39:13 <shapr> @quote
22:39:13 <lambdabot> MyCatVerbs says: does that make any sense, or should I go find some gin and try to explain that again?
22:39:56 <travisbrady> anyone have any pointers with this error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1592#a1592
22:47:48 <ivanm> travisbrady: is that the entire module you've pasted there?
22:48:20 <ivanm> what is the UA class?
22:49:52 <travisbrady> that's everything yes
22:49:56 <travisbrady> i've updated it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1592#a1593
22:50:11 <travisbrady> http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/Data-Array-Vector.html#t%3AUA
22:50:21 <travisbrady> "This type class determines the types that can be elements immutable unboxed arrays"
22:51:02 <ivanm> travisbrady: it looks like you're folding over arrays rather than the lemeent of arrays
22:51:03 <travisbrady> the second error makes it look as if there is some nesting, but i'm not understanding
22:51:36 <ivanm> travisbrady: that can't be the entire file ;-)
22:51:47 <ivanm> the error is complaining about line 27, which isn't part of the code :p
22:52:15 <ivanm> @type fooldU
22:52:16 <lambdabot> Not in scope: `fooldU'
22:52:19 <ivanm> @hoogle foldU
22:52:19 <lambdabot> No results found
22:52:19 <travisbrady> this is everything http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1592#a1594
22:52:23 <ivanm> @hoogle foldlU
22:52:23 <lambdabot> No results found
22:52:32 <travisbrady> oh i had some comments in there
22:52:37 <travisbrady> i just didn't paste them
22:52:49 <ivanm> travisbrady: foldlU :: UA a => (a -> a -> a) -> UArr a -> a
22:53:15 <ivanm> but you're first argument to fold1u is folder, which isn't of type (a -> a -> a)
22:53:30 <travisbrady> hmm, that looks odd
22:53:34 <ivanm> also, fold1U should only take 2 argumetns, you're giving it 3
22:53:37 <travisbrady> "foldlU :: UA a => (b -> a -> b) -> b -> UArr a -> b" <-- from http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/Data-Array-Vector.html#t%3AUA
22:53:58 <ivanm> ahhh, I looked at fold1U rather than foldlU :s
22:54:00 <ivanm> @slap fonts
22:54:00 * lambdabot locks up fonts in a Monad
22:54:17 <ivanm> whatever, you're types are still wrong
22:54:45 <ivanm> travisbrady: add types to all your functions
22:54:47 <ivanm> that might help
22:54:52 <travisbrady> yeah, i can't don't understand how
22:54:52 <travisbrady> ok
22:59:30 <travisbrady> hmm, no luck, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1592#a1595
23:01:08 <ivanm> travisbrady: compare the type of foldlU with your folder type
23:01:15 <ivanm> *with the type of folder
23:01:31 <ivanm> foldlU :: UA a => (b -> a -> b) -> -> UArr a -> b
23:01:53 <ivanm> folder :: (Uarr Int, UArr Int, UArr Int) -> Uarr Int -> (UArr Int, UArr Int, UArr Int)
23:01:58 <ivanm> do those two types match up?
23:02:13 <ivanm> even the _shape_ of them don't match up, let alone the UA requirement
23:03:06 <travisbrady> oh oops, not UArr Int for the 2nd arg of folder, just Int
23:04:05 <ivanm> travisbrady: blah takes a triple
23:04:14 <ivanm> foldlU expects a function that takes a function
23:05:21 <travisbrady> ivanm: yay, it worked, thank you
23:05:33 <wli> I'm having trouble with Gauss-Jordan of all things.
23:06:10 <travisbrady> ivanm: is this the right way to do it?
23:06:26 <Trinithis> > as
23:06:27 <lambdabot>   Not in scope: `as'
23:06:41 <ivanm> travisbrady: to do what?
23:06:45 <ivanm> wli: Gauss-Jordan what?
23:07:05 <wli> Elimination.
23:07:08 <Trinithis> @src filterM
23:07:08 <lambdabot> Source not found. Sorry.
23:07:13 <Trinithis> @src filterM_
23:07:13 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:07:14 * ivanm vaguely recalls that
23:07:14 <Cale> ivanm: Matrix row-reduction.
23:07:23 <ivanm> yeah, sounds even more familiar now...
23:07:36 <Trinithis> does lambdabot not do src anymore?
23:07:37 <ivanm> Trinithis: it's similar to the normal filter, but done using do, etc.
23:07:38 <travisbrady> ivanm: just is this a good solution to the problem?  is the style completely hideous?
23:07:42 <ivanm> @src filter
23:07:42 <lambdabot> filter _ []     = []
23:07:42 <lambdabot> filter p (x:xs)
23:07:42 <lambdabot>     | p x       = x : filter p xs
23:07:42 <lambdabot>     | otherwise = filter p xs
23:07:52 <ivanm> travisbrady: I have no idea what the problem is ;-)
23:07:59 <ivanm> and the function names leave a bit to be desired :s
23:08:05 <Cale> Trinithis: It does, it just doesn't have everything. The sources are in a text file which just has particular definitions.
23:08:15 <wli> Let me post...
23:08:47 <travisbrady> ivanm: yes, they're terrible and i'm changing them, the idea is to partition a list of Ints into a triple such that the first element is GT some Int k and so one for EQ and GT
23:09:02 <ivanm> travisbrady: in one pass?
23:09:08 <ivanm> any particular reason for using a UArray?
23:09:21 <travisbrady> i'm just trying to get used to using uvector
23:09:27 <sjanssen> > filterM (const [True, False]) "abc"
23:09:29 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
23:09:40 <wli> http://pastebin.com/m3f1dde8a <-- my feeble attempt at Gauss-Jordan elimination.
23:10:40 <wli> The bad news is that elimGJ doesn't seem to do anything at all:
23:10:44 <wli> runSTArray $ do { m <- newArray_ ((1::Int,1::Int),(2,3)) ; mapM_ (uncurry (writeArray m)) [((1,1),3::Rational),((1,2),-1),((1,3),1),((2,1),-1),((2,2),3),((2,3),1)] ; elimGJ m ; return m}
23:10:44 <wli> array ((1,1),(2,3)) [((1,1),3%1),((1,2),(-1)%1),((1,3),1%1),((2,1),(-1)%1),((2,2),3%1),((2,3),1%1)]
23:12:45 <Trinithis> is this a correct defn of filterM: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1597#a1597
23:13:06 <ivanm> @type filterM
23:13:07 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
23:13:15 <rohan> in haskell, is the number of tab spacs / indentation important? i have two programs which are EXACTLY same but for the number of spaces used to indent, and i am getting an error
23:13:19 <ivanm> Trinithis: looks like it
23:13:30 <Cale> rohan: yes
23:13:37 <Trinithis> alright... i'm doing this cause i want to convert it to python
23:13:43 <Cale> rohan: You should try to ensure there are no tab characters in the file.
23:13:45 <ivanm> rohan: as long as you're consistent, then if you use two spaces rather than four spaces to a tab then no, not really
23:13:54 <ivanm> Trinithis: :o
23:14:08 <Trinithis> > filterM [True, False] [1..4]
23:14:09 <lambdabot>   Couldn't match expected type `a -> m Bool'
23:14:12 <rohan> any idea how i can ensure no tab characters are present, when using vim?
23:14:14 <Cale> tab characters are always treated by the Haskell compiler as aligning to the nearest 8-space boundary
23:14:20 <Cale> :set expandtab
23:14:24 <SamB> ivanm: I think he wanted to know if they were important, not if the distinctioon between them was important ...
23:14:26 <Trinithis> > filterM (const [True, False]) [1..4]
23:14:27 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
23:14:29 <Cale> (or add the equivalent to your .vimrc
23:14:31 <Cale> )
23:14:31 <ivanm> SamB: ahhh
23:14:59 <wli> Ugh, swapRows doesn't do anything, either.
23:15:18 * ivanm notices that the first non-ChanServ nick listed in this channel seems to be an erlang programmer...
23:15:19 <Gracenotes> Trinithis: a powerset is just all permutations of an element being in a set (True) and not being in a set (False)
23:15:49 <ivanm> > length $ filterM (const [True, False]) [1..4]
23:15:50 <lambdabot>   16
23:15:56 <SamB> ivanm: not if Cale takes ops
23:15:56 <Gracenotes> the list monad handles this nicely :)
23:16:07 <ivanm> which is 2^(length of list)
23:16:09 <Gracenotes> I'm not sure if there's a Python equivalent, though. It's easily code-able though
23:16:11 <ivanm> SamB: heh
23:16:21 <Cale> ivanm: Could be prolog.
23:16:34 <Gracenotes> you can even model the powerset of a list with a binary string
23:16:34 <ivanm> *shrug* I've never done anything with prolog
23:16:41 <rohan> i am still getting this error - http://rafb.net/p/TvQFr635.html
23:16:49 <ivanm> I bought a book on prolog at a book fair, but didn't do much withi it
23:16:54 <SamB> ivanm: I heard they had the same syntax
23:17:02 <Gracenotes> Trinithis: for [1,2,3,4], 0000 corresponds to []. 1111 corresponds to [1,2,3,4]. 1010 corresponds to [1,3]. and so on
23:17:10 <Cale> rohan: Well, that's a type error now...
23:17:17 <ivanm> rohan: that's not a spacing issue AFAICT...
23:17:23 <Cale> rohan: the problem is the extra commas
23:17:30 <Cale> er, comma
23:17:41 <Cale> rohan: after "Hello"
23:17:43 <ivanm> Haskell /= Python ;-)
23:18:04 <Cale> Perhaps you meant for the comma to be inside the quotes :)
23:18:10 <Gracenotes> > do { a <- "01"; b <- "01"; c <- "01"; d <- "01"; return $ concat [a,b,c,d] } -- ?
23:18:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
23:18:15 <Gracenotes> :(
23:18:24 <SamB> (sort of like if you used scheme's "read" to parse the code for a language of your own ... only Prolog actually *has* syntax)
23:18:34 <rohan> Cale: oh wow that was stupid of me.. yes, the comma was to be inside the quites :)
23:18:34 <Gracenotes> ah.
23:18:45 <Gracenotes> > do { a <- "01"; b <- "01"; c <- "01"; d <- "01"; return [a,b,c,d] } -- ?
23:18:46 <lambdabot>   ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","101...
23:18:47 <ivanm> I recently had to do something in python... for some reason, when printing you just separate different values with commas and it converts them to strings and concatenates, but otherwise you have to do it by hand :s
23:19:14 <Cale> rohan: in the error message, it shows more clearly how it ended up parsing the thing.
23:19:34 <SamB> ivanm: you mean it doesn't just write them one after another ?
23:20:00 <Cale> > replicateM 4 "01"
23:20:01 <lambdabot>   ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","101...
23:21:42 <Cale> > [0..] >>= \n -> fmap ('1':) (replicateM n "01")
23:21:43 <lambdabot>   ["1","10","11","100","101","110","111","1000","1001","1010","1011","1100","...
23:23:14 <rohan> Cale: i was a bit confused, i am absolutely new to haskell
23:23:25 <mriou_> hey, does someone know if there's a way to define a data type in ghci (data Foo = F ...)
23:23:27 <mriou_> ?
23:23:42 <Cale> rohan: quite all right, let us know if you have any other confusion or questions :)
23:23:44 <Gracenotes> *Double Monad For Great Effect*
23:24:18 <Cale> mriou_: nope, put all your declarations in a file and load it. I find it's handy to keep two terminal windows open. :r will reload the currently loaded file
23:24:52 <mriou_> Cale: yeah, :r is handy but sometimes for quick experimentation it would be handy
23:25:06 <mriou_> although I'm aware it's probably difficult given you have to be in IO
23:25:35 <mriou_> do you know if there's any other repl that allows something like that?
23:26:06 <Cale> It could support it, most likely. It just doesn't... iirc, I think it was HBC which used to allow that.
23:26:58 <mriou_> Cale: isn't the whole ghci session strictly in IO?
23:27:24 <wli> Hmm.
23:27:26 <Cale> It imitates the inside of an IO do-block
23:27:27 <Cale> sort of
23:27:57 <Cale> Except there are :-commands, and if the expression you type is not an IO action, it applies print to it
23:28:17 <mriou_> mmh yeah ok, I'll continue with files and :r then
23:28:25 <mriou_> thanks for the help
23:33:29 * wli is completely bombing this.
23:33:49 * wli suspects no one looked at the code (or if anyone did, they found it unreadable).
23:35:07 * SamB thinks John Meacham's tag-naming process must consist of banging on the keyboard
23:36:27 <wli> I can't seem to try out any useful functions acting on arrays.
23:37:05 <wli> e.g. I can't look at the results of selectPivot because runSTArray hates any returns but array returns.
23:41:16 <mriou_> another question :) how would one make a type an instance of Eq when the implementation of = would be monadic?
23:43:07 <mriou_> I have an algebraic data type that defines, among other constructors: WyRef (IORef String)
23:43:12 <ivanm> SamB: *shrug* maybe it does, I just find the change in syntax weird :s
23:47:28 * wli experiences major mutable array headaches.
23:49:22 <redditbot> Tag your #haskell tweets on twitter
23:49:54 <ivanm> ... OK ...
23:50:29 * Gracenotes wonders where else to tag tweets
23:54:13 <pumpkin_> say you have a pet parrot
23:54:21 <pumpkin_> and you train it to tweet haskell
23:54:34 <pumpkin_> in that case, it is not acceptable to get a branding iron with #haskell on it and use it on the parrot
23:57:03 <harblcat> pumpkin_: how would you pronounce '#'?
23:57:21 <pumpkin_> I'm tempted to pronounce the entire #haskell as hashkell
