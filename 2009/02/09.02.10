00:00:01 <lambdabot>   * Exception: Prelude.undefined
00:00:05 <Olathe> Hahaha
00:03:06 <Olathe> > deriv (const 5) x
00:03:09 <lambdabot>   0
00:03:13 <ski_> > (deriv . deriv) (^ 5) `map` [-3..3]
00:03:15 <lambdabot>   [-540,-160,-20,0,20,160,540]
00:03:43 <Olathe> > showFunc $ (deriv . deriv) (^ 5) `map` [0..10]
00:03:45 <lambdabot>   Not in scope: `showFunc'
00:03:49 <Olathe> > sayFunc $ (deriv . deriv) (^ 5) `map` [0..10]
00:03:53 <lambdabot>   map (\x -> ((-1)*x^10 + (-8)*x^9 + 288*x^8 + (-2816)*x^7 + 53248*x^6 + 3604...
00:03:56 <Olathe> Eww
00:04:05 <Olathe> That's not quite right.
00:04:22 <Olathe> > (deriv . deriv) (^ 5) $ x
00:04:24 <lambdabot>   ((1 * 1 + 1 * 1) * (x * x) + (1 * x + x * 1) * (1 * x + x * 1) + ((1 * x + ...
00:05:30 <ski_> @type sayFunc
00:05:32 <lambdabot> forall a. (Real a, Fractional a) => [a] -> Expr
00:05:58 <ski_> @src sayFunc
00:05:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:06:06 <ski_> i guess not
00:06:07 <Olathe> > iSayFunc $ (deriv . deriv) (^ 5) `map` [0..10]
00:06:10 <lambdabot>   map (\x -> 20*x^3) [0..10]
00:06:31 <Olathe> iSayFunc xs = say $ "map (\\x -> " ++ (showPoly $ iLagrange xs) ++ ") [0.." ++ show (length xs - 1) ++ "]"
00:06:43 <Olathe> iLagrange ys = lagrange.map ((%1).toInteger) $ ys
00:08:12 <Olathe> > reduce $ (deriv . deriv) (^ 5) $ x
00:08:14 <lambdabot>   ((1 + 1 * 1) * (x * x) + (1 * x + x * 1) * (1 * x + x * 1) + ((1 * x + x * ...
00:08:45 <mjrosenb> hrmm, i don't seem to understand how mvars work
00:08:47 <Olathe> > let red 0 = id; red n = reduce . red (n - 1) in red 50 $ (deriv . deriv) (^ 5) $ x
00:08:49 <lambdabot>   (2 * (x * x) + (1 * x + x * 1) * (1 * x + x * 1) + ((1 * x + x * 1) * (1 * ...
00:08:55 <Olathe> > let red 0 = id; red n = reduce . red (n - 1) in red 5000 $ (deriv . deriv) (^ 5) $ x
00:08:57 <lambdabot>   (2 * (x * x) + (1 * x + x * 1) * (1 * x + x * 1) + ((1 * x + x * 1) * (1 * ...
00:09:09 <Olathe> OK
00:09:33 <Olathe> > reduce (1 * x)
00:09:35 <lambdabot>   1 * x
00:09:40 <Olathe> I guess it can't.
00:10:03 <ski_> there ought to be a `Natural -> (forall a. (a -> a) -> (a -> a))' function in the library ..
00:10:22 <ski_> Olathe : why ?
00:10:41 <Olathe> Oh, it can't reduce that long Expr into 20*x*x*x
00:10:54 <ski_> but why ?
00:11:15 <ski_> > reduce (x - x)
00:11:15 <Olathe> Oh, it probably doesn't assume it's a ring or something.
00:11:17 <lambdabot>   x - x
00:11:28 <Olathe> Or, apparently, even an additive group.
00:11:37 <Olathe> > x + (negate x)
00:11:39 <lambdabot>   x + negate x
00:12:01 <Olathe> > reduce $ x + (negate x)
00:12:03 <lambdabot>   x + negate x
00:12:29 <ski_> > reduce (1 + 1)
00:12:32 <lambdabot>   2
00:12:47 <Cheshire> :t reduce
00:12:49 <lambdabot> Expr -> Expr
00:12:54 <Olathe> @src reduce
00:12:54 <lambdabot> reduce _ 0 = undefined
00:12:54 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
00:12:54 <lambdabot>     where d = gcd x y
00:13:01 <Olathe> O-o
00:13:01 <ski_> > 1 + 1 :: Expr
00:13:03 <lambdabot>   1 + 1
00:13:08 <Cheshire> > id (1 + 1)
00:13:10 <lambdabot>   2
00:13:32 <Cheshire> @let don'tReduce :: Expr -> Expr; don'tReduce = id
00:13:36 <ski_> @slap lambdabot
00:13:36 <lambdabot>  Defined.
00:13:36 * lambdabot clobbers lambdabot with an untyped language
00:14:00 <Olathe> Hmm...I wonder if Expr uses constructors for the functions.
00:14:04 <Olathe> > Negate 1
00:14:06 <lambdabot>   Not in scope: data constructor `Negate'
00:14:17 <mjrosenb> blast.  i've just written a bunch of haskell code
00:14:24 <ski_> is that bad ?
00:14:25 <mjrosenb> and i can't run ghc on my desktop
00:15:07 * ski_ wonders what that means
00:15:22 <mjrosenb> ski_: me?
00:15:36 <Olathe> > fromExpr (x^2)
00:15:38 <lambdabot>   Not in scope: `fromExpr'
00:15:39 <ski_> aye, you sir
00:15:42 <Cheshire> what is a Pi-foo reflecting universe?
00:15:49 <lament> mjrosenb: ghc can usually run
00:15:54 <lament> once installed
00:16:00 <mjrosenb> i've tried for a while
00:16:06 <mjrosenb> and it really doesn't want to
00:16:07 <Olathe> > reduction (1 + 2 + 3 + 4)
00:16:08 <lambdabot>   Not in scope: `reduction'
00:16:20 <mjrosenb> if you guys think you can help me to get it running, i'm all ears
00:16:27 <Olathe> > Debug.SimpleReflect.Expr.reduction (1 + 2 + 3 + 4)
00:16:29 <lambdabot>       Failed to load interface for `Debug.SimpleReflect.Expr':
00:16:29 <lambdabot>        Use -v ...
00:16:31 <mjrosenb> my desktop is a ppc64 box running linux
00:16:33 <Olathe> @type f
00:16:35 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
00:16:41 <Olathe> > SimpleReflect.Expr.reduction (1 + 2 + 3 + 4)
00:16:42 <lambdabot>       Failed to load interface for `SimpleReflect.Expr':
00:16:42 <lambdabot>        Use -v to see...
00:16:45 <mjrosenb> and i haven't been able to get ghc to bootstrap
00:18:40 <Cheshire> maybe you can use an old version
00:18:55 <Ringo48> is there an easy way to generate random numbers?
00:19:20 <Olathe> > doubleExpr (1 + 2)
00:19:21 <mjrosenb> Cheshire: you know where there's a binary newer that 6.4.2?
00:19:22 <lambdabot>   Not in scope: `doubleExpr'
00:19:31 <mjrosenb> since that one doesn't work
00:19:48 <Ringo48> nothing as easy to use as C's rand()?
00:20:55 <bastl> Can someone advise me with this ugly code? I just want to count labels in a Data.Tree: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1325
00:21:06 <mjrosenb> Ringo48: it's not a very well behaved function.. not really a function at all
00:21:19 <Olathe> @hoogle monadrandom
00:21:21 <lambdabot> package MonadRandom
00:21:35 <Ringo48> yes, but it's convenient to use...
00:21:50 <ski_> @type random
00:21:51 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
00:21:57 <Cheshire> bastl, use pattern matching in the def. of 'f' and use better variable names
00:22:02 <ski_> @type State random
00:22:03 <Olathe> > do { a <- getRandom; return a }
00:22:04 <lambdabot> forall s a. (RandomGen s, Random a) => State s a
00:22:04 <lambdabot>   Not in scope: `getRandom'
00:22:17 <Ringo48> yeah, I saw that in the docs, but that looks like a pain to use
00:22:22 <Cheshire> realName (Just x) = Just (1 + x) ; realName Nothing = 1
00:22:41 <ski_> Ringo48 : usually, you'd use it in conjunction with a state-monad, then
00:22:57 <Ringo48> passing around RandomGens and what not
00:23:04 <Ringo48> sigh, okay
00:23:14 <Ringo48> thank you
00:23:31 <mjrosenb> or f = fmap (+1) `mplus` Just 1
00:23:39 <pumpkin-> I guess there are no xml combinators as simple as the xhtml package?
00:23:46 <mjrosenb> err
00:23:53 <mjrosenb> or f x = fmap (+1) x `mplus` Just 1
00:24:09 <ski_> Ringo48 : there is no need to explicitly pass the prng around .. that's what the state monad is for
00:24:39 <ski_> maybe 1 succ
00:25:01 <Ringo48> but I already have code written that doesn't use the state monad
00:25:05 <bastl> mjrosenb: talking to me?
00:25:32 <mjrosenb> bastl: yes
00:25:39 <ski_> Ringo48 : only the code that will use random numbers, or depend on code that does, will need to be rewritten, then
00:25:50 <Cheshire> maybe (Just 1) (Just . (+1))
00:26:02 <Ringo48> yeah, that's the impression I was getting
00:26:05 <ski_> Ringo48 : also, in some cases it might be nices to pass down an infinite list of random whatevers
00:26:05 <Cheshire> Just . maybe 1 (+1)
00:26:18 <ski_> @type randoms
00:26:19 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
00:26:22 <Ringo48> so I thought I'd ask before I spent the time to do that
00:26:38 <bastl> how about the union thing? in fact i want to accumulate a map when traversing the children of a node
00:27:06 <bastl> this "bigger"-function is ugly (but works somehow)
00:28:34 * ski_ ponders fall-through in haskell
00:28:54 <Toxaris> bastl: you could consider  case compare x y of
00:29:31 <Olathe> Oh dear.
00:29:35 <bastl> ski_: i hope you mean Ringo, not me ... ?
00:29:43 <Olathe> Fall through is the work of SATAN !
00:29:43 <Ringo48> ?
00:29:56 <Toxaris> bastl: or  if x == y then x + 1 else max x y
00:30:14 <mjrosenb> hrmm, the haskell runtime seems to be forgetting to call exec
00:30:41 <ski_> bastl : ? .. i can't see where i referenced you
00:30:46 <bastl> Toxaris, i think the approach is not good, i want to increment a specific value in the map whenever i hit the key.
00:30:53 <bastl> ski_: ok then.
00:31:15 * ski_ was just pondering generally
00:31:25 <bastl> 624 ppl in #haskell ...
00:31:27 <ski_> Olathe : i think it could be nice, in some cases
00:32:52 <Badger> @users
00:32:53 <lambdabot> Maximum users seen in #haskell: 697, currently: 625 (89.7%), active: 12 (1.9%)
00:32:58 <mjrosenb> bastl: how is what Toxaris proposed any different from what you have?
00:33:01 <Badger> still not 700
00:33:04 <Badger> :o
00:33:18 <Toxaris> mjrosenb: I understand that he doesn't like what he has
00:33:55 <mjrosenb> Toxaris: yes, but he didn't seem to like yours either
00:34:05 <pumpkin-> @index fromMaybe
00:34:05 <lambdabot> Data.Maybe
00:34:05 <bastl> mjrosenb: it's not.
00:34:20 <ski_> (bastl : oh .. you were involved in the `Just' stuff above .. i didn't notice. i was just generally invoked by the casing)
00:34:58 <bastl> perhaps a nicer looking function. im thinking about folding all children to get the accumulated map.
00:35:08 <bastl> (to mjrosenb )
00:35:17 <Toxaris> bastl: what about writing fromList :: Tree a -> [a] first, then working on the list?
00:35:21 * ski_ remembers someone having a simple nice motivating example of fall-through quite a while ago .. but can't recall the details :/
00:35:34 <Toxaris> bastl: toList of course
00:35:34 <bastl> what is fall-through?
00:36:09 <bastl> Toxaris: good idea. but want to get used to fold one day :-)
00:36:22 <Toxaris> bastl: well, fold over the list :)
00:36:23 <ski_> in C-family languages, it is when one branch of a switch may continue into another branch
00:36:46 <Toxaris> bastl: if that works, define foldTree
00:36:47 <bastl> ski_: ah.
00:36:52 <ski_> in haskell, i'm thinking of sharing some code between some (but not all) branches
00:37:06 <Toxaris> bastl: then make Tree an instance of Data.Foldable, and be most generally happy :)
00:37:24 <ski_> (the direct problem is finding some nice syntax for it ..)
00:37:28 <mjrosenb> are there any known issues with ghc-6.6.1 and threading / runProcess?
00:37:36 <bastl> ski_ ouch. thats indeed devilish
00:38:14 <Toxaris> ski_: there already is     f x = case x of <branches here> where <common code here>
00:38:15 <ski_> but i belive it can be useful, to avoid either code-duplication, or unwanted auxilary naming
00:38:17 <bastl> can you give one good example? haskell is hard to read. but that would make it even harde.
00:38:33 <ski_> (and for more natural expression, possibly)
00:39:00 <mjrosenb> ski_: i think that could be more easily handled with disjunctive pattern matching
00:39:44 <ski_> (this in a similar way to how or-patterns is useful)
00:40:31 <ski_> mjrosenb : yes, "or patterns" (aka "disjunctive patterns") are a bit similar, but not quite the same
00:41:10 <ski_> the latter handle the case when the bodies for several branches are exactly the same
00:41:26 <Toxaris> disjunctive pattern means  "(p | q) matches if p matches or q matches, and binds what p and q binds"?
00:41:43 <ski_> bastl : it's hard to give any concrete example without finding a good syntax
00:41:46 * Cheshire mumbles about it being a shame nobody is implementing Epigram 2
00:41:49 <ski_> Toxaris : yes
00:41:53 <mjrosenb> Toxaris: the binding variables need to be the same between p and q
00:42:13 <mjrosenb> but it would be awesome if you could inherit from the parent scope
00:42:23 <ski_> mjrosenb : or at least only the interection of the bound variables of `p' and `q' is bound by the compound pattern
00:42:41 <ski_> mjrosenb : inherit in what sense ?
00:43:21 <mjrosenb> right, so if you had \ default -> \ (Just default | Nothing) -> default
00:43:21 <ski_> (bastl : though possibly i can describe an example without giving code .. but i want to have a natural example, then)
00:43:40 <ski_> oh, you mean non-linear patterns
00:44:20 <ski_> `case ... of (x,x) -> True; _ -> False'
00:44:59 <mjrosenb> no, in this case, if the Just branch of the or-pattern is taken, then default is bound by that
00:45:08 <ski_> this is hard in general, because of undecidability of function equality (or any `codata' for that matter)
00:45:16 <mjrosenb> if the Nothing branch, then the default binding from the lambda remains
00:45:17 <ski_> .. oh
00:45:36 <ski_> that would seem strange, imo
00:45:46 <mjrosenb> it also seems useful
00:46:05 <ski_> how about
00:46:20 <ski_>  \(default,(Just default | Nothing)) -> default
00:46:21 <ski_> then ?
00:46:28 <ski_> or
00:46:37 <ski_>  \((Just default | Nothing),default) -> default
00:47:09 <Toxaris> ski_: what would they mean?
00:47:19 <ski_> that's what i ask, yes
00:47:22 <mjrosenb> ski_: there's no nested scope there
00:47:29 <mjrosenb> mine has explicit nested scopes
00:47:46 <ski_> that's one point i wanted clarified :)
00:48:26 <ski_> bastl : iirc, the example i was thinking of was something like this
00:48:27 <mofmog> hey anyone wanna comment on my code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1326#a1326
00:48:43 <ski_> some function was to be defined, which gave `IO' results
00:49:00 <Toxaris> does that mean that   curry (\(..., ...) -> ...)  /=  \... -> \... -> ...
00:49:15 <ski_> it `case'd on something (possibly user input string), and had three cases
00:49:29 <ski_> one case was termination of the function, i.e. base case
00:49:55 <ski_> the two other cases did different things, but both recurred
00:50:01 <mjrosenb> Toxaris: that doesn't hold in haskell98
00:50:11 <ski_> (maybe something more in common too, i don't recall)
00:50:35 <ski_> of course one could do nested `case' .. but that would be unnatural in this case
00:50:44 <Toxaris> mjrosenb: why not?
00:50:51 <mjrosenb> \ x -> \ x -> x
00:50:52 <ski_> (and i can imagine that it would be harder in some cases using guards)
00:50:53 <mjrosenb> vs
00:51:05 <mjrosenb> uncurry (\ (x,x) -> x)
00:51:26 <Toxaris> @type curry
00:51:28 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
00:51:35 <mjrosenb> err
00:51:36 <mjrosenb> curry
00:51:37 <Toxaris> but I see what you mean
00:52:10 <Toxaris> ok I agree, since shadowing is already influenced by the notion of "outer scope", why not make more complicated shadowing rules
00:52:33 <mjrosenb> well this is requisit on or/disjunctive pattern being implemented
00:52:38 <mjrosenb> which they are not
00:52:39 <ski_> (mjrosenb : btw, i'm not saying your idea would necessarily be bad .. i just think it would need some thought)
00:53:21 <mjrosenb> ski_: yeah, and without some of the clarifications i gave, it would be downright absurd
00:53:35 * ski_ wants true and-patterns in haskell
00:54:44 <ski_> (this whole business of where you bind your variables, and where you have collative combination and where you have shadowing is a bit murky)
00:55:51 <Toxaris> > let foo arg | (_, 'x') <- arg, ('y', _) <- arg = 42 in foo ('y', 'x')
00:55:52 <lambdabot>   42
00:56:56 <ski_> , let f (succ -> x)@(pred -> y) = (x,y) in f 10
00:56:57 <lunabot>  luna: parse error on input `@'
00:58:02 <mjrosenb> what does (succ -> x) mean?
00:58:17 <bastl> what approaches are there for generic programming? SYB, Uniplate, any more?
00:58:19 <ski_> , let f (succ -> x) (pred -> y) = (x,y) in join f 10
00:58:20 <lunabot>  (11,9)
00:58:31 <ski_> , let f (not -> x) = x in f True
00:58:32 <lunabot>  False
00:58:37 <dreixel> bastl: Plenty! The best one depends on what you want to do.
00:58:46 <monkfish> hmmm
00:58:58 <Toxaris> mjrosenb: (f -> x) matches y if x matches (f y)
00:59:02 <ski_> mjrosenb : a value `v' matches `f -> p' if `f v' matches `p'
00:59:04 <monkfish> is there like a dropBefore or a dropUntil function
00:59:05 <bastl> use syntax trees as normal data to work on.
00:59:17 <ski_> (it's strange syntax, yes)
00:59:20 <dreixel> bastl: but make sure to check out at least also EMGM (http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/EMGM) and MultiRec (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/multirec)
01:00:01 <mjrosenb> ...
01:00:03 <ski_> dropUntil p = dropWhile (not . p)
01:00:10 <mjrosenb> wow, that's a bit on the powerful side
01:00:12 <Toxaris> > let f (succ &&& pred -> (x, y)) = (x, y) in f 10
01:00:13 <lambdabot>   <no location info>: parse error on input `->'
01:00:23 <ski_> , let f (succ &&& pred -> (x, y)) = (x, y) in f 10
01:00:24 <lunabot>  luna: Not in scope: `&&&'
01:00:53 <Toxaris> we need higher-order bots. myBot = lambdabot `union` lunabot
01:01:11 * ski_ would like a sensible semantics of this `e -> p' pattern ..
01:01:34 <ski_> (.. hm, monad coproducts)
01:01:53 <Toxaris> as long as matching against IO doesn't get a special case
01:02:37 <monkfish> is there a more elegant solution to this:
01:02:38 <monkfish> take 1 (dropWhile (\x -> (numLength x) < 1000) fibs)
01:02:45 <monkfish> or a quicker one (!)
01:02:49 <ski_> (if i recalled which hpaste motivated fall-through, i could show that)
01:03:20 <mjrosenb> monkfish: head at least
01:03:22 <mjrosenb> or hd
01:03:26 <monkfish> heh
01:03:28 <monkfish> i see
01:03:29 <mjrosenb> whatever this language uses
01:03:34 <ski_> `head' in haskell
01:03:39 <monkfish> ta
01:03:41 <Toxaris> mjrosenb: head /= take 1
01:03:50 <ski_> (`hd' in SML)
01:03:52 <monkfish> but he is right i did need head ;)
01:03:55 <Toxaris> > take 1 []
01:03:56 <lambdabot>   []
01:04:00 <Toxaris> > head []
01:04:02 <lambdabot>   * Exception: Prelude.head: empty list
01:04:03 <monkfish> although actually i think im going about it the wrong way
01:04:23 <monkfish> im doing project euler 25 to train myself in haskell-fu
01:04:28 <Toxaris> monkfish: numLength is something like (length . show)?
01:04:37 <monkfish> pretty much
01:04:43 <monkfish> i mean that would make sense
01:04:48 <monkfish> rather than
01:04:59 <mjrosenb> monkfish: oh... yes, computing fibonacci numbers that get that large gets quite slow
01:05:17 * mjrosenb has computed the 10,000,000,000 fibonacci number
01:05:19 <monkfish> let numLength x = if x == 0 then 0 else 1 + (numLength (x `div` 10))
01:05:21 <monkfish> :3
01:05:30 <monkfish> but yeah length . show works
01:05:31 <monkfish> hehe
01:05:58 <mjrosenb> monkfish: logs are your friend
01:06:19 <monkfish> logs are not my friend :(
01:06:26 <monkfish> they beat me up in high school
01:06:59 <Beelsebob> Any of you heard of a version of lex that can deal with indentation based blocks, ala haskell or python
01:07:29 <ski_> succ . floor . logBase 10
01:07:57 <Toxaris> monkfish: what let big = 10 ** 1000 in ... (< big) ...
01:08:02 <Toxaris> what about
01:08:16 <monkfish> hmm?
01:08:18 <monkfish> whats ** do again?
01:08:24 <Toxaris> > 10 ** 1000
01:08:26 <lambdabot>   Infinity
01:08:29 <Toxaris> :(
01:08:30 <monkfish> :o
01:08:33 <monkfish> thats huge
01:08:34 <Toxaris> > 10 ^ 1000
01:08:36 <monkfish> ;p
01:08:36 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
01:08:46 <mjrosenb> does the problem specify that you need to use integer math?
01:08:52 <monkfish> nah
01:08:55 <monkfish> just that you solve the problem
01:09:06 <monkfish> ive found the first fib with 1000 digits
01:09:08 <mjrosenb> fib x \approx \phi ^ x
01:09:18 <monkfish> but im trying to figure out how to find the position of this number in the lis
01:09:27 <Olathe> Does seq a a do anything more than a ?
01:09:34 <Toxaris> Olathe: no
01:10:06 <Olathe> How do I turn a from a possible-huge thunk into something more evaluated ?
01:10:10 <monkfish> is there a way to count the number of drops im doing
01:10:22 <mjrosenb> monkfish: take, then len
01:10:23 <monkfish> maybe ill just zip with [1..]
01:10:32 <monkfish> good idea/bad idea
01:11:12 <Toxaris> Olathe: replace some b which gets evaluated by (seq a b).
01:11:57 <scap> this is my first night playing with haskell can anyone help me write the definition for disjointUnion :: (Eq a, Eq b) => Set a -> Set b -> Set (Either a b)
01:11:59 <monkfish> yay i got it
01:12:00 <monkfish> :D
01:12:14 <mjrosenb> 4785?
01:12:21 <pumpkin-> scap: you'll need Ord too
01:12:27 <pumpkin-> unfortuantely
01:12:28 <Olathe> scap: What's the difference between a union and a disjoint union ?
01:12:30 <monkfish> head (dropWhile (\(x,y) -> (numLength y) < 1000) (zip [1..] fibs))
01:12:32 <ski_> > let phi*phi - phi - 1 = 0 in phi
01:12:33 <lambdabot>   <no location info>: Parse error in pattern
01:12:39 <scap>        disjointUnion [1, 2, 3] [1, 2]
01:12:39 <scap> [Left 1,Left 2,Left 3,Right 1,Right 2]
01:13:00 <pumpkin-> @instances Ord
01:13:01 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:13:01 <scap> and Either is defined as      Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
01:13:02 <scap> data
01:13:04 <Olathe> Toxaris: So, that's, loosely, used to ensure that if b is evaluated, a is, too ?
01:13:26 <Toxaris> Olathe: if b is evaluated at this position.
01:13:37 <Olathe> Toxaris: Ahh, thanks.
01:13:50 <Toxaris> Olathe: and evaluated = evaluated to whnf
01:14:27 <Toxaris> so   ((a, b) seq c) will not evaluate a and b
01:14:41 <Toxaris> I mean  ((a, b) `seq` c)  of course
01:14:52 <Olathe> Ahh.
01:14:57 <Olathe> I was just about to ask about tuples :)
01:15:14 <Olathe> Is there a seq for multiple values ?
01:15:20 <koala_man> chain it
01:15:35 <Olathe> > foldr seq 0 [a, b, c, d]
01:15:36 <Toxaris> Olathe: its not only tuples, its all data constructors, including your self-defined
01:15:37 <lambdabot>   0
01:15:43 <Olathe> > foldr seq d [a, b, c]
01:15:45 <lambdabot>   d
01:16:03 <Olathe> Does that turn a, b, and c to WHNF ?
01:16:14 <ski_> > foldr seq () [a,undefined,b]
01:16:15 <lambdabot>   * Exception: Prelude.undefined
01:16:34 <Olathe> Toxaris: Ahh, that's evil.
01:16:47 <ski_> indeed it is
01:16:52 <Toxaris> actually, its cool
01:17:13 <ski_> > undefined `seq` ()
01:17:15 <lambdabot>   * Exception: Prelude.undefined
01:17:22 <ski_> > (\x -> undefined x) `seq` ()
01:17:24 <lambdabot>   ()
01:17:44 <ski_> so `f = \x -> f x' doesn't hold
01:17:44 <Olathe> So, I need something like f t r xs = seq t' $ seq r' $ seq xs' $ f t' r' xs' ?
01:18:04 <ski_> @src ($!)
01:18:05 <lambdabot> f $! x = x `seq` f x
01:18:17 <Olathe> Hmm...
01:18:20 <ski_> (also see strict patterns)
01:18:37 <Toxaris> Olathe: note that just adding seq here and there normally doesn't help
01:19:19 <Toxaris> but (f $! t' $! r' $! xs') may be what you want
01:19:22 <Olathe> I want to get a foldl'-like effect.
01:19:26 <doserj> @type curry $ uncurry Data.Set.union . (Data.Set.map Left *** Data.Set.map Right)
01:19:27 <lambdabot> forall a a1. (Ord a, Ord a1) => S.Set a1 -> S.Set a -> S.Set (Either a1 a)
01:19:29 <Olathe> Ahh.
01:19:31 <Olathe> Thanks :)
01:19:55 <Olathe> @index ($!)
01:19:56 <lambdabot> Prelude
01:20:29 <Toxaris> > const $! 42 $! undefined
01:20:30 <lambdabot>       Overlapping instances for Show (b1 -> b)
01:20:30 <lambdabot>        arising from a use of `...
01:20:47 <ski_> > (const $! 42) $! undefined
01:20:49 <lambdabot>   * Exception: Prelude.undefined
01:21:05 <Olathe> > (+) $! (1 + 2) $! (3 + 4)
01:21:06 <lambdabot>       Overlapping instances for Show (b -> b)
01:21:07 <lambdabot>        arising from a use of `s...
01:21:07 * ski_ grumbles about wrong associativity of `$' and `$!'
01:21:14 <Olathe> Ehh ?
01:21:17 <Toxaris> oh, $! like $, makes kind of sense
01:21:19 <ski_> > ((+) $! (1 + 2)) $! (3 + 4)
01:21:20 <lambdabot>   10
01:21:26 <Olathe> O-o
01:21:27 <Toxaris> consistently broken
01:21:42 <Olathe> But that evaluates (1 + 2) strictly ?
01:21:52 <ski_> yes
01:22:03 <ski_> (which it would do anyway, for `Integer')
01:22:14 <Olathe> infixr 0 $
01:22:15 <Olathe> infixr 0 $!
01:22:18 <Olathe> Hmm...
01:22:23 <Olathe> Ahh, thanks :)
01:22:55 <Olathe> > (+) $! 1 + 2 $! 3 + 4
01:22:56 <lambdabot>       Overlapping instances for Show (b -> b)
01:22:56 <lambdabot>        arising from a use of `s...
01:23:01 <Olathe> > ((+) $! 1 + 2) $! 3 + 4
01:23:03 <lambdabot>   10
01:23:33 <Olathe> > (+) $ 1 + 2 $ 3 + 4
01:23:34 <lambdabot>       Overlapping instances for Show (b -> b)
01:23:34 <lambdabot>        arising from a use of `s...
01:23:36 <Olathe> Weird.
01:24:06 <Olathe> > (+) (3 7)
01:24:07 <lambdabot>       Overlapping instances for Show (a -> a)
01:24:07 <lambdabot>        arising from a use of `s...
01:24:10 <Olathe> Ahh.
01:24:34 <Olathe> Hmm...
01:24:47 <Olathe> Is there any infixl ($) replacement ?
01:24:54 <Olathe> Or, in this case, ($!)
01:25:30 <Cheshire> I just use (.)
01:25:59 <ski_> not that i know of
01:26:04 <Olathe> Oh, I mean for arguments rather than functions.
01:26:10 <Olathe> Alright.
01:26:26 <Cheshire> an argument q is equiv. to a function () -> q
01:26:35 <Olathe> It is ?
01:26:46 <Cheshire> > (reverse . const "foo") ()
01:26:48 <lambdabot>   "oof"
01:26:51 <Olathe> > let f () = 9 in f
01:26:52 <lambdabot>       Overlapping instances for Show (() -> t)
01:26:52 <lambdabot>        arising from a use of `...
01:26:53 <Cheshire> > (reverse $ "foo")
01:26:55 <lambdabot>   "oof"
01:26:58 <ski_> @djinn (() -> a) -> a
01:26:58 <lambdabot> f a = a ()
01:27:03 <ski_> @djinn a -> (() -> a)
01:27:04 <lambdabot> f a _ = a
01:27:08 <BW^-> guys, what problems do you consider Haskell be best at solving?
01:27:23 <monkfish> MAFS
01:27:23 * ski_ chides djinn for not matching on the unit value ..
01:27:41 <Beelsebob> BW^-: it's biggest strength is probably compilers
01:27:49 <Olathe> BW^-: Well, I'm making something to recompress PNG files.
01:27:54 <BW^-> beelsebob: you mean write compiles in haskell?
01:28:04 <Cheshire> how come every compiler written in haskell is totally unreadible :/
01:28:11 <BW^-> let's compare it with Scheme/Lisp, RoR and C++.
01:28:12 <Beelsebob> BW^-: writing compilers in, yes
01:28:18 <Cheshire> GHC, JHC, .. these are yuck
01:28:25 <Beelsebob> Cheshire: because compilers are hard to write in general
01:28:27 <BW^-> beelsebob: why?
01:28:29 <Beelsebob> name one easy to read compiler ;)
01:28:34 <ski_> (.. there are compilers written in RoR ?)
01:28:37 <Beelsebob> BW^-: it's excellent at tree maniputaltion
01:28:41 <Olathe> ski_: Haha
01:28:44 <Cheshire> There are lots
01:28:52 <Cheshire> None of them written in haskell
01:28:56 <mofmog> a compiler that you use... ON THE WEB!
01:29:09 <Beelsebob> Cheshire: example?
01:30:14 * ski_ compiles the web carefully into a small ball
01:30:27 <Olathe> @type scanl
01:30:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
01:30:31 <Olathe> @type scanl'
01:30:32 <lambdabot> Not in scope: `scanl''
01:33:10 <Beelsebob> Cheshire: noting ofc that all the compilers I know of written in Haskell are compiling *really* complex languages
01:33:15 <Beelsebob> e.g. Haskell or Perl
01:34:00 <mjrosenb> iirc some absurd amount of ghc is dedicated to desugaring the haskell code
01:34:17 <Cheshire> Beelsebob, elf and kp6 (perl 6 compilers) are much more hackable than GHC and they are put together for the fun of it
01:34:29 <cjs> @seen dons
01:34:29 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 3h 13m 14s ago.
01:34:38 <Beelsebob> Cheshire: yes, and they took *way* longer to write than pugs did
01:34:55 <Beelsebob> pugs was written specifically because writing a compiler for perl 6 was concievable in a short amount of time in Haskell
01:35:03 <Beelsebob> while not reasonably concievable in another language
01:37:00 <Cheshire> dunno why that matters, pugs isn't a compiler and dev. time wasn't the issue
01:38:02 <araujo> well, it seems like perl6 itself is trying to get some functional features ... that could be a good reason too ...
01:38:12 <Beelsebob> it matters because it demonstrates haskell's strength as a compiler authoring language
01:38:35 <pejo> Cheshire, why don't you fix up an existing compiler, or write a new one that is easily hackable? there should be plenty of people hacking on it if it's easy.
01:38:36 <araujo> Also, Larry wants to attract Haskell hacker too for it ....
01:40:05 <chrisdone> araujo: because haskell developers r so smort?
01:40:19 <kalven> what did larry have to do with pugs?
01:41:18 <Cheshire> Beelsebob, I'm not saying "Haskell is crap don't write compilers in it", I'm saying that I cannot name one real language with a compiler implemented in haskell that you don't have to spend a month decoding to modify
01:41:33 <BW^-> beelsebob: how is it excellent attree manipulation?
01:41:39 <Cheshire> pejo, 1) it doesn't interested me to throw away years of other peoples work to reimplement the same thing 2) other fish to fry
01:41:46 <BW^-> what are the differences and similarities between Lisp and Haskell?
01:42:05 <arw> parantheses
01:42:11 <Beelsebob> Cheshire: 1) I didn't have to spend a month to do a bit of hacking on ghc 2) I can't name a single language where you don't have to take some time to understand its compiler
01:42:50 <araujo> (1, 1 ... &[+]) ... this is a nice fib in perl6 :P
01:43:58 <pejo> Cheshire, have you looked at the timber compiler? It's 16k lines of Haskell or so.
01:44:05 <arw> BW^-: the syntax is of course different. haskell is statically and strongly (whatever that means) typed, lisp dynamically and weakly (again, no real definition for that). lisp is mostly used as an interpreted language, haskell as compiled.
01:44:06 <araujo> kalven, he wants to take some ideas from haskell , and so he supports pugs
01:45:06 <pejo> Cheshire, but I think Beelsebob makes a valid point, you have to take some time to understand any compiler that you're hacking on.
01:45:28 <ski_> (arw : lisps are traditionally strongly typed)
01:45:52 <ski_> (and there's many compilers for lisps)
01:46:33 <aleator_> I recall there was some haskell trick for editing nested structures ala lisp setf. Can anyone remember where?
01:46:52 <ski_> lenses aka functional references ?
01:49:11 <Cheshire> Maybe if I put a positive spin on it you'd agree:  I think we could do orders of magnitude better using Haskell that is currently done
01:49:18 <Cheshire> pejo, I am talking about personal experience, having done bits and peices on most language implementations I've used
01:50:24 <Cheshire> aleator_, you can just put STRefs throughout it if you want mutation
01:50:39 <kalven> araujo: so because he wants some functional features in perl6 he supports that pugs is implemented in haskell?
01:50:51 <fasta> arw: try saying that in #lisp and you will be banned for trolling.
01:51:48 <mjrosenb> fasta: i'd say he's still trolling
01:51:53 <aleator_> Cheshire: Not mutation. Perhaps it was early iteration of func. references. Is there anything else of similar style?
01:52:24 <Cheshire> aleator_, "functional references" sounds like a cute name for mutable data to me
01:52:54 <araujo> kalven, well, he seems to like the idea, yeah
01:53:00 <kalven> hehe
01:53:03 <fasta> mjrosenb: me too, but the ops don't ban for that reason here ;)
01:53:03 <Cheshire> aleator_, what does it mean to you?
01:53:27 <ski_> (Cheshire : yes .. one wonders what it has to do with functions ..)
01:54:08 <arw> fasta, mjrosenb: you are right (except for the trolling part). that was total nonsense.
01:54:21 <araujo> kalven, I also see that as an attempt at getting some perl hackers interested at haskell, and viceversa
01:54:29 <aleator_> Cheshire: I heard it 3min ago so I'm still reading what it is.
01:58:01 <kalven> araujo: I don't know if larry had much influence over ms tang in her choice of language.
01:59:16 <araujo> kalven, haha.. if Larry read you, I bet he would answer something like he isn't that sure he got some influence over perl6 itself ... haha, but I just think he likes the idea of using haskell
01:59:24 <araujo> :)
01:59:47 * araujo points he is on #perl6 and you could ask yourself anytime
02:01:01 <boegel> @src foldr
02:01:01 <lambdabot> foldr f z []     = z
02:01:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:01:53 <ski_> @tgt unfoldl
02:01:53 <lambdabot> Maybe you meant: ft let thx
02:10:03 <pao_> I've seen that interpreted code using alloca in ghci tends to leak memory... when compiled everything works correctly
02:10:30 <pao_> I've tried to find evidence about that without success... is it a bug or a well known behaviour?
02:12:29 <aleator_> Hah! It was semantic editor combinators I was thinking of!
02:14:25 <Cheshire> why is it "semantic"?
02:14:50 <aleator_> Cheshire: See http://conal.net/blog/posts/semantic-editor-combinators/
02:14:57 <Cheshire> i just read that it doesn't say
02:15:44 * ski_ . o O ( forall x y. \(f x) -> x = \(f y) -> y )
02:20:06 <Toxaris> I call this idea “semantic editor combinators”, because it’s a composable way to create transformations on rich values.
02:20:46 <Toxaris> maybe semantic was just the missing buzzword?
02:21:59 <ski_> you could ask conal next time he shows up, here
02:23:17 <Toxaris> oh i think i found it. he wants to edit the value, not the expression, that is the semantics, not the syntax
02:24:02 <Toxaris> anyway, its cool.
03:10:21 <povman> I'm designing a haskelly version of mindrover
03:14:15 <cognominal> mindrover?
03:15:29 <povman> a computer game where you put components onto a robot, then make programs using a graphical interface and dragging logic components around and connecting them and the physical components with wires
03:15:55 <povman> and you can put guns and make them shoot each other etc
03:16:43 <lambdapants> question: easy way to read ascii char into Word8?
03:17:37 <lambdapants> or does one just Data.ByteString.pack a string... infact I think I've answered my own question.
03:18:03 <lambdapants> ...uh thankyou all for your help!
03:18:42 <povman> sometimes you just need someone to bounce ideas off.
03:22:05 <lilac> povman: sounds a lot like LEGO MindStorm ;-)
03:22:33 <povman> it's very similar, except completely virtual and more violent.
03:22:52 <Raevel> peow peow
03:23:37 <povman> i'm designing a cpu component and sockets-like communication between components
03:23:45 <povman> and wireless!
03:24:30 <povman> and real-time code uploading
03:25:50 <povman> cpu will run a simple monad
04:49:20 * byorgey makes lambdaberry jam
04:52:56 <RayNbow> byorgey sure is #haskell's lambda chef :p
04:53:02 <koeien> can you give me the recipe?
04:54:29 <byorgey> koeien: sure.  (1) boil 4c water with 1c lambdasugar  (2) add lambdaberries  (3) simmer for 30 minutes or until lambdaberries are tender
04:55:50 <RayNbow> > orderPizza
04:55:51 <lambdabot>   Pepperoni-lambda, coming up!
04:55:53 <byorgey> the lambdasugar is key, though, lambdaberry jam desugars into implicit parameters
04:56:29 <RayNbow> byorgey: 4c = ?
04:56:31 <RayNbow> 4 cups?
04:57:05 <byorgey> yeah, sorry, stupid american measuring system =P
04:57:21 <byorgey> @go 4 cups in liters
04:57:22 <lambdabot> http://www.exploratorium.edu/cooking/convert/measurements.html
04:57:22 <lambdabot> Title: Equivalents and Measures
04:57:37 <RayNbow> 4 US cups = 0.946352946 L
04:57:37 <byorgey> huh, it used to return the result from the calculator
04:59:13 <quicksilver> byorgey: @go is made of STRING and FAIL.
04:59:20 <quicksilver> byorgey: depend on it at your own risk.
04:59:28 <byorgey> quicksilver: haha
04:59:43 <byorgey> @remember quicksilver @go is made of STRING and FAIL.
04:59:43 <lambdabot> Done.
04:59:45 * SamB thinks it used to work better
04:59:57 * SamB decides to blame google for it's not working so well anymore
05:00:19 <quicksilver> the time rapidly approaches where we can reasonable blame google for all ills.
05:00:27 * SamB certainly has no blame in this ;-P
05:00:31 <quicksilver> I for one welcome our new algorithmically-challenged overloads.
05:12:19 <Twey> int80_h: Unfold
05:12:49 <Botje> yay
05:12:55 <Botje> my haskell course wlil use RWH :D
05:12:58 <Twey> Nice!
05:13:08 <Twey> Which institution?
05:13:17 <Botje> VUB
05:14:27 <Twey> Vrije Universiteit Brussel?
05:16:50 <athos> @instance Monoid
05:16:50 <lambdabot> Maybe you meant: instances instances-importing
05:16:53 <athos> @instances Monoid
05:16:53 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
05:24:04 <edbond> how can I add debug ouput in functions?
05:24:16 <RayNbow> @hoogle trace
05:24:16 <lambdabot> Debug.Trace trace :: String -> a -> a
05:24:16 <lambdabot> module Debug.Trace
05:24:16 <lambdabot> package traced
05:24:59 <SamB> edbond: do you see how to use it ?
05:25:19 <SamB> if not, we could have augustss explain it ;-P
05:25:39 * SamB is sticking his tongue out for augustss' benefit
05:25:53 * SamB is not sticking his tongue out at edbond 
05:26:27 <edbond> SamB: An example would be very helpful.
05:27:44 <SamB> fun x = trace ("fun " ++ show x) (x^2)
05:28:06 <SamB> hmm ... does that need a "\n"?
05:28:17 <doserj> no
05:28:44 <doserj> @src trace
05:28:45 <lambdabot> trace string expr = unsafePerformIO $ do
05:28:45 <lambdabot>     hPutStrLn stderr string
05:28:45 <lambdabot>     return expr
05:29:33 <edbond> http://gist.github.com/61382
05:31:29 <Saizan> trace takes two arguments
05:31:29 <Saizan> the String to print and the value to return
05:36:08 <edbond> thanks all. it works as expected. :)
05:36:23 <jpcooper> hello
05:36:35 <jpcooper> could anyone please tell me how to get haskell-mode for emacs to indent if expressions?
05:36:39 <jpcooper> (properly)
05:36:49 <SamB> jpcooper: I don't know either
05:36:52 <opqdonut> me neither
05:36:56 <SamB> I think I usually end up doing it myself
05:37:09 <opqdonut> i just stopped using if ...\n then ...\n else ...
05:37:11 <jpcooper> shame. I think I'll look at the code
05:37:16 <jpcooper> what do you use instead?
05:37:49 <opqdonut> jpcooper: i do it without the \n's
05:38:09 <jpcooper> you must have a nice wide screen
05:39:45 <opqdonut> just small fonts ;)
05:41:12 <jpcooper> not going to work very well on 14.1"
05:41:46 <quicksilver> jpcooper: get kuribas' indentation mode
05:41:58 <quicksilver> @where kuribas-indentation
05:41:58 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
05:43:11 <jpcooper> thank you
05:44:36 <mreh> is anyone here self employed?
05:45:47 <jpcooper> mreh, I hope to be starting some maths tutoring :)
05:46:04 <blackh> mreh: I could be considered self employed.
05:46:26 <mreh> it's probably a route that I will find myself going down
05:46:29 <blackh> mreh: I do programming on contract for various companies.
05:46:45 <mreh> in the US?
05:46:53 <blackh> mreh: No, In New Zealand
05:47:16 <mreh> is it good work?
05:47:24 <jpcooper> do you not enjoy working for companies?
05:47:31 <mreh> no
05:47:56 <mreh> but i suppose contracting is very much the same: shup up and do this
05:48:00 <mreh> but better paid
05:48:29 <blackh> mreh: I've been doing it for at least 10 years.  It's been really varied and I've been able to work in more or less the areas I've wanted to (Linux, in particular).
05:49:04 <mreh> do you approach a contract agency and they find you work?
05:50:18 <blackh> mreh: I have been lucky. I have a very good friend who's a "technologist" for want of a better term. He solves people's problems and when programming is required, he calls on me. So it works really well. I have been working from home for many years.
05:50:37 <vpalle> will I get in trouble if I equate algebraic datatypes with discriminated unions? ( functional languages in general..)
05:50:37 <zachk> blackh: that sounds like "heaven"
05:50:56 <zachk> no but you might get sued for discrimination D:
05:50:58 <blackh> mreh: He likes to go into offices and be surrounded by people and make jokes.  I am a complete hermit - I barely tolerate offices.  A perfect match!
05:51:34 <vpalle> thats okay ;)
05:52:01 <jpcooper> vpalle, do you get bored?
05:53:10 <vpalle> jpcooper, not sure how to answer that question..
05:53:31 <jpcooper> I mean in general
05:53:37 <jpcooper> do you want a change of job ever
05:54:49 <vpalle> boy, do I, I'm finishing my thesis... Thought about outsourcing it
05:56:57 <jpcooper> bloody wish I could find a decent job while in university
05:57:14 <jpcooper> the problem is is that I'm not interested in learning languages practical to making money on the web
05:57:28 <vpalle> I know the feeling
05:57:53 <lilac> jpcooper: i found a job writing in-house software for a local company while at uni
05:58:07 <jpcooper> in which language?
05:58:14 <lilac> i... don't want to say.
05:58:24 <jpcooper> there's a Ruby company where I am. Maybe I should have a look at Ruby
05:58:27 <mstr> that's gotta be c# or php
05:58:32 <lilac> VB6
05:58:36 <mstr> :D
05:58:37 <jpcooper> :|
05:58:40 <lilac> :(
05:58:40 <pk_> @instances IO
05:58:41 <lambdabot> Couldn't find class `IO'. Try @instances-importing
05:58:43 <jpcooper> mstr, look what you've done now
05:58:53 <vpalle> c# 3.0 isn't THAT bad..
05:59:05 <lilac> well, it started in VB6. then i was forced to port it to VBA in Access
05:59:07 <lilac> *shudder*
05:59:10 <jpcooper> it's like a starving person saying that rice every day isn't that bad
05:59:20 <vpalle> :)
06:00:36 <zachk> hey i like rice!
06:00:44 <vpalle> Learn F#, I think there will an increasing demand for it.. Don't hold your breath though
06:01:07 <zachk> i went to learn f# and they wanted to charge me for some "journal" for it and went pffffffffffft
06:01:30 <jpcooper> @instances MonadIO
06:01:31 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
06:01:40 <jpcooper> bloody shame that Maybe isn't
06:01:54 <lilac> jpcooper: lol
06:02:10 <lilac> instance MonadIO Maybe where liftIO _ = Nothing
06:02:27 <jpcooper> hmm
06:02:34 <jpcooper> maybe I am thinking of this the wrong way round
06:02:35 <zachk> why do you want maybe to be io, you don't want the compiler to optimize junk in it away?
06:02:37 <vpalle> zachk, theres an entire msdn development center for learning F#..
06:02:40 <jpcooper> what I would like is maybe values inside of IO
06:02:43 <lilac> @djinn IO a -> Maybe a
06:02:43 <lambdabot> Error: Undefined type IO
06:02:55 <lilac> jpcooper: in that case you want MaybeT I think
06:03:18 <jpcooper> lilac, do you know why it isn't in the standard libraries?
06:03:26 <lilac> @wiki New monads/MaybeT
06:03:26 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
06:03:43 <lilac> jpcooper: just an oversight i think
06:03:52 <zachk> jcooper: try "all about monads" it starts on maybe
06:04:00 <SamB> lilac: there wasn't something wrong with it ?
06:04:10 <lilac> SamB: it's worked fine when i've used it
06:04:38 <SamB> so ... why hasn't it been added to the mtl? just because the MTL actually sucks ?
06:04:50 <quicksilver> because the MTL isn't really maintained, I think.
06:04:56 <lilac> SamB: though i note that the wiki page uses -fallow-undecidable-instances
06:04:59 <quicksilver> you can always use Either ()
06:05:19 <lilac> instance (Monoid w, MonadWriter w m) => MonadWriter w (MaybeT m) where
06:05:26 <lilac> ^^ i assume that's the undecidable one
06:05:41 <lilac> (though i don't see why it would be)
06:09:34 <Botje> Twey: yes, sorry. IRCing in class is not a good career move ;)
06:12:25 <Twey> Botje: *nod* :)
06:15:04 <Twey> Why aren't the standard monads implemented as cases of MonadT?
06:15:12 <Twey> Over Identity
06:15:21 <Twey> Since they've all got transformers anyway :-\
06:17:00 <quicksilver> Twey: speed, I think.
06:18:21 <Twey> Well, Identity could be compiler-optimised out
06:20:06 <quicksilver> and the moon could be made of green cheese
06:20:08 <quicksilver> but, it isn't.
06:20:16 <Twey> Heh
06:20:23 <Twey> You don't know that
06:20:28 <Twey> Have you been up there? :-P
06:20:35 <quicksilver> I am there now.
06:20:41 <quicksilver> along with lunabot
06:20:54 * Twey laughs.
06:35:25 <pk_> it's pretty messy to use lifted operators
06:36:02 <Peaker> pk_: ?
06:36:15 <Peaker> pk_: which kind of lift? What operators?
06:36:26 <pk_> infix operators
06:41:44 <Beelsebob> pk_: <^ and ^> are your friends
06:42:43 <pk_> @ty <^
06:42:44 <lambdabot> parse error on input `<^'
06:42:46 <pk_> @ty (<^)
06:42:47 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
06:43:16 <pk_> @ty (^>)
06:43:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
06:43:30 <Beelsebob> > [True,False] <^(&&)^> [False, True]
06:43:31 <lambdabot>   [False,True,False,False]
06:43:42 <pk_> cool
06:43:55 <pk_> exactly what I was looking for
06:44:15 <Beelsebob> they're in the InfixApplicative package
06:44:28 <pk_> thx
06:45:13 <Beelsebob> only downside is that <^(&&)^> is not an expression in itself
06:45:24 <Beelsebob> :(
06:45:51 <ehird> haha, I love the "haskell through wtfs/min" post "I've always been told that Haskell is heavily functional and pure. WTF are these do-blocks, then? Oh, monads. Wait, what? "
06:46:23 <Beelsebob> fair comment
06:47:42 <pk_> @ty <^(&&)^>
06:47:44 <lambdabot> parse error on input `<^'
06:47:50 <pk_> @ty (<^(&&)^>)
06:47:51 <lambdabot> parse error on input `)'
06:48:15 <lilac> @ty (\x y -> x <^(&&)^> y)
06:48:17 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
06:48:32 <pk_> thx
06:49:29 <lilac> has anyone proposed that extended slice notation for haskell' yet?
06:52:12 <Beelsebob> pk_: can ofc use liftA2 (&&) to deal with that, if you really want to pass the lifted function about
06:52:32 <lilac> the proposal was: (< ... i) ~> (\x -> x < ... i), (i ... >) ~> (\y -> i ... > y), (< ... >) ~> (\x y -> x < ... > y), for <, > any operator, i any non-operator and ... any sequence of tokens
06:53:03 <pk_> ofc ?
06:53:11 <pk_> I'm sorry my english is bad
06:53:12 <lilac> of course
06:53:15 <pk_> thx
06:53:48 <lilac> pk_: let (^&&^) = lfitAt (&&) in foo ^&&^ bar
06:53:56 <lilac> s/fi/if/g
06:54:41 <Beelsebob> true, but that doesn't work for all operators
06:56:06 <hallongrottan> @pl  getMem >>= \mem -> return $ mem ! addr
06:56:06 <lambdabot> (! addr) `fmap` getMem
06:56:16 <hallongrottan> SWEET
06:56:21 <lilac> Beelsebob: due to associativity / precedence?
06:56:50 <lilac> hallongrottan: (!addr) <$> getMem :)
06:56:51 <Beelsebob> lilac: well no, I mean you can't define once, and then have all operators suddenly have a lifted version
06:57:11 <lilac> Beelsebob: sure. <^ / ^> are great for that.
06:57:22 <Beelsebob> yep
06:57:37 <lilac> but if you're going to be using the same lifted operator over and over, it can be handy to define a shorter version
06:57:39 <Beelsebob> except for the <^(insert operaor here)^> not being an expression thing
06:57:45 <Beelsebob> yep indeed
06:57:58 <hallongrottan> lilac: yes, i know :)
06:58:22 <lilac> Beelsebob: i view (<^(!$)^>) not being legal as a bug in Haskell98 myself :)
06:58:37 <Beelsebob> yeh
06:58:52 <Beelsebob> its hard to come up with something general there though
06:59:09 <lilac> see my proposal above ;)
06:59:23 <lilac> (note, not originally my idea)
06:59:49 <Beelsebob> well, it's still not totally general
07:00:05 <Beelsebob> in that it still doesn't allow for things like supplying the 5 argument to a 7 argument function
07:02:01 <lilac> Beelsebob: well, no, but it's not /for/ that ;-)
07:02:09 <Beelsebob> true
07:02:25 <Beelsebob> I just get the feeling that the whole partial application syntax ought to be tidyable up somehow
07:02:29 <Beelsebob> but I can't quite get how
07:03:03 <lilac> (_1 < foo && _2 > bar) ~> (\x y -> x < foo && y > bar) ?
07:04:06 <Peaker> Beelsebob: replace textual syntax with presentational GUI widgets :)
07:04:21 <Beelsebob> Peaker: yeh, that's certainly a good idea
07:04:34 <ray> drag 'n' drop haskell
07:04:47 <Peaker> there you have the common perception that GUI means using a mouse :)
07:06:11 <ray> C-e H-z M-x shiny-haskell-widgets
07:06:34 <lilac> Beelsebob: let's all use labview
07:07:46 <maltem> The problem with going away from purely textual representations is that you'll be programming whole new programming environments
07:08:10 <koeien> gone is grepping/diffing/darcs
07:08:18 <maltem> right
07:08:42 <Beelsebob> koeien: yeh, and back in comes diffing on syntax graphs
07:08:54 <Beelsebob> which is *way* better than "hey, this line in the middle of an expression is different"
07:08:56 <koeien> Beelsebob: oh yeah sure. fix all the bugs, get people to know it, ...
07:09:03 <Beelsebob> darcs stays, just with a better diff algorithm
07:09:20 <koeien> Beelsebob: no, you need a better overview of patches
07:09:28 <koeien> Beelsebob: otherwise it'
07:09:36 <koeien> s like putting MS Word files in version control
07:09:42 <koeien> it works, but you won't have all the power
07:10:01 <Beelsebob> oh, sure
07:10:05 <maltem> Beelsebob: of course, if the hypothetical new programming environment turns out to be versatile and usable, it would be just cool
07:10:10 <Beelsebob> you need to view the files with a CSG viewer
07:10:14 <Beelsebob> not with a text viewer
07:10:16 <koeien> i like the idea, you just need a lot of effort
07:10:24 <Beelsebob> no surprise, as we don't have text files any more
07:10:43 <SamB> complex solid geometry?
07:11:39 <lilac> bah, just represent each graph node by an MD5 hash of its contents, and integrate your file format directly into git
07:11:46 <koeien> MD5 is evil
07:11:52 <maltem> SamB: Start with a cube, and keep modelling until you have a Haskell program!
07:12:13 <ray> start with a block of virtual marble and chisel away
07:12:22 <koeien> (not necessarily for non-cryptographic purposes, but then there may be better options)
07:12:30 <ray> with the aid of an undo function, you could outdo the old masters
07:12:45 <lilac> start with an empty hard drive and fire neutrinos at it until you've got the program you wanted
07:12:47 <maltem> lilac: I too think that a content tracker is the right choice in general
07:13:31 * lilac wonders how practical that'd be
07:13:52 <maltem> lilac: The neutrino thing?
07:18:31 <Axman6> is doing a lot of lst ++ [x] ok if the list is being consumed as it's being built? need to append thing to the end rather than the beginning
07:18:42 * Axman6 is sleepy and being obvious
07:19:00 <Peaker> Axman6: I think its not, why not use DList?
07:20:59 <mib_lvokxe2a> @pl  \x y v -> ( f x v) == (f y v)
07:20:59 <lambdabot> (. f) . ap . ((==) .) . f
07:23:13 <mib_lvokxe2a> @pl  \x y v -> g( f x v) == g(f y v)
07:23:14 <lambdabot> (. ((g .) . f)) . ap . (((==) . g) .) . f
07:23:39 <mib_lvokxe2a> 	@pl \x y v -> g( f x v)
07:24:37 <mib_axpehp8r> @pl \x y v -> g( f x v)
07:24:37 <lambdabot> const . (g .) . f
07:28:28 <mib_axpehp8r> @pl \t1 t2 p -> (fromMaybe False) $ liftM2 equal (subtermAt t1 p)(subtermAt t2 p)
07:28:28 <lambdabot> ((fromMaybe False .) .) . (. subtermAt) . ap . (liftM2 equal .) . subtermAt
07:28:56 <mib_axpehp8r> 	@pl \t1 t2 p -> liftM2 equal (subtermAt t1 p)(subtermAt t2 p)
07:29:11 <mib_axpehp8r> @pl \t1 t2 p -> liftM2 equal (subtermAt t1 p)(subtermAt t2 p)
07:29:12 <lambdabot> (. subtermAt) . ap . (liftM2 equal .) . subtermAt
07:29:23 <doserj> @type \ f x y -> uncurry (==) . (f x &&& f y)
07:29:25 <lambdabot> forall t a a1. (Eq a) => (t -> a1 -> a) -> t -> t -> a1 -> Bool
07:38:02 <maltem> Axman6: repeatedly appending to the end of a list, like (((a ++ b) ++ c) ++d), is O(nÂ²)
07:38:25 <Axman6> yeah, figured out a better way anyway
07:39:01 <Axman6> uisng tail recursion of course
07:42:08 <hackage> Uploaded to hackage: hsql-postgresql 1.7.1
07:43:17 <anakreon> Hello everyone. I'm afraid I'll have to ask for your help once more.
07:43:50 <anakreon> I am writting a program with hxt. Some problems I had previusly have been resolved.
07:43:51 <Axman6> that's what we're here for
07:44:40 <anakreon> Now I need some advice on state usage. The code is at: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1294#a1294
07:45:40 <anakreon> I need to read the state and modify it. An example is the commented code for function "general"
07:46:44 <Valodim> hm. trying to get ftgl to work here, but I'm getting a ton of undefined reference errors using ghc --make :|
07:47:09 <Valodim> cabal install ftgl worked without errors, reinstalled (locally and globally) a bunch of times but can't get it to work
07:47:21 <anakreon> The intention is to: check if an entry exists in the map. If not add an entry with a unique key derived from the state variable lref and execute a statement. Otherwise, execite and other statement which uses the value retrived from the map.
07:48:58 <anakreon> There is an example from the wiki on hxt which uses state but I'm afraid I do not understand it.
07:49:36 <hcube> Hi! what's the relation of generic and tempalte haskell?
07:49:59 <hcube> *template
07:51:18 <Cheshire> hcube, hm..... I wish I knew
07:52:11 <hcube> because I'd like pass to a function a pattern as a parameter and it is not valid in haskell. so i have to use template haskell or generic haskell
07:53:01 <Cheshire> I think maybe generic haskell has got stronger guarantees about the well typedness of programs than TH... but there are less programs you can write with it
07:53:01 <Cheshire> (I could be totally wrong about that last bit)
07:53:01 <Cheshire> hcube, why do you pass a pattern?
07:59:51 <Beelsebob> Axman6: I would bet looking at the memory usage that most of our time is allocation/deallocation
08:00:02 <Beelsebob> it looks like it needs some serious work to get it into a straight loo
08:00:06 <Beelsebob> loop
08:00:13 <Axman6> yah :\
08:00:59 <Philonous> Axman6: Did you get 6.10.1 to run? (btw. which arch are you on? )
08:01:22 <Axman6> i could't get it to compile on x86
08:02:16 <Philonous> Ah, bummer.
08:05:35 <hcube> Cheshire: here is my code snippet what i'd like to simplify: http://pastebin.com/m4efbd95b
08:06:36 <Cheshire> hcube, something which jumps out at me is this:
08:06:48 <Cheshire> @let list nil cons [] = nil ; list nil cons (x:xs) = cons x xs
08:06:50 <lambdabot>  Defined.
08:07:22 <chrisdone> Cheshire: what do you think of liskell?
08:08:20 <Cheshire> hcube, so instead of using  a = l ++ defaultTUValues,  then head [x | TU_colourop x <- l],  you could use  something like list to pick the first TU_colourop or give a default
08:08:27 <Cheshire> hcube, whch means you don't have to use head..
08:09:05 <hcube> I'd like to write a code like this: getAttr TU_colourop l --(l::[TU_Attr])
08:11:39 <hcube> Cheshire: you are right about default values, but i'd like to replace list comprehensions with a function
08:11:57 <hcube> and i think it is possible only in template or generic haskell
08:12:19 <Axman6> o.O
08:13:29 <Cheshire> not something I use chrisdone
08:14:36 <Axman6> > foldr `f` x [a,b,c]
08:14:38 <lambdabot>   Couldn't match expected type `[Expr] -> t'
08:14:49 <Axman6> argh, right yes
08:14:55 <Axman6> > foldr (`f`) x [a,b,c]
08:14:56 <lambdabot>   <no location info>: parse error on input `)'
08:14:59 <chrisdone> mk
08:15:16 <BONUS> > foldr f x [a,b,c]
08:15:17 <lambdabot>   f a (f b (f c x))
08:15:30 <Axman6> trying to see if i could make it infix
08:16:05 <Axman6> > lex . show .  foldr f x $ [a,b,c]
08:16:07 <lambdabot>   [("f"," a (f b (f c x))")]
08:18:33 <Cheshire> chrisdone, why is it interesting?
08:18:34 <pk_> @ty lex
08:18:36 <lambdabot> String -> [(String, String)]
08:18:41 <pk_> lex "a"
08:18:46 <pk_> > lex "a
08:18:47 <lambdabot>   <no location info>:
08:18:47 <lambdabot>      lexical error in string/character literal at chara...
08:19:27 <Valodim> http://209.85.129.132/search?q=cache:H9MN-tJd9rAJ:hpaste.org/11782+undefined+reference+%22ftglGetLayoutError%22&hl=en&ct=clnk&cd=1&ie=UTF-8
08:19:27 <Valodim> heh, that's exactly the error I get, and the only relevant google result I could find. anyone got a hint?
08:23:16 <chrisdone> Cheshire: personally I've always prefered editing and reading s-expressions. it's also nice to write subtle macros to improve things with the haskell syntax that are just annoying but we have to "live with", but with a lisp syntax can just fix. sexprs have a nice regularity and transparency. also first class pattern matching would be relevant to my interests. but generally haskell's semantics with a lisp syntax would be ideal for me
08:23:52 <Cheshire> chrisdone, I internalized pattern matching for a small universe of types just by using GADT
08:24:20 <chrisdone> yeah I think I saw that
08:24:23 <Cheshire> (and associated types to check match totality)
08:26:34 <chrisdone> there are certainly lots of things that you can do in haskell that in lisp people just go straight for macros for. I think it's just subtle changes that macros are useful for in constructs that involve creating bindings
08:27:37 <chrisdone> do intermediateValue <- getFoo
08:27:37 <chrisdone>    case intermediateValue of
08:27:37 <chrisdone>      ..
08:27:37 <chrisdone> this pattern really irks me but I could abstract away the intermediateValue with a macro
08:28:05 <Cheshire> you don't need macros to improve that
08:28:19 <chrisdone> how do you do it then?
08:28:27 <Cheshire> I just write it as you have there
08:28:34 <Toxaris_> maybe an approach like Fortress is the way to go, where libraries can extend the parser
08:28:46 <chrisdone> ~_~
08:28:54 <pejo> Toxaris, so that we absolutely can't reason about our code.
08:28:57 <Cheshire> it is possible to do it without naming intermediateValue though
08:29:04 <chrisdone> Cheshire: how??
08:29:16 <jpcooper> chrisdone, check pm
08:29:17 <ehird> unsafePerformIO. Duh.
08:29:31 <Cheshire> internalize pattern matching and lift it to monadic values
08:29:55 <chrisdone> example?
08:30:14 <Toxaris_> pejo: you have to be aware of the specification of all imported libraries to reason about code anyway
08:30:16 <Cheshire> I think I will leave it as a puzzle from here :p
08:30:22 <chrisdone> ha
08:30:23 <geezusfreeek> :t maybe
08:30:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:30:42 <geezusfreeek> functions like that are a godsend for cases like this
08:30:45 <Toxaris_> peji: Or do you know what "import Obscure.From.Hackage; main = launchTheMissiles" will do?
08:31:08 <chrisdone> geezusfreeek: it's more like when you're doing some deep-ass pattern matching
08:31:41 * geezusfreeek tries not to think about that sentence too much
08:31:47 <chrisdone> ;-)
08:32:37 <pejo> Toxaris, I don't think that is an argument for making it even harder though.
08:33:24 <Toxaris_> pejo: so where is the border? e.g. do you like Haskell's fixity declarations?
08:33:35 <chrisdone> Cheshire: what does 'internalize' mean?
08:34:45 <Toxaris_> @type (liftM (\x -> case x of Left (x, []) -> x))
08:34:47 <lambdabot> forall t t1 t2 (m :: * -> *). (Monad m) => m (Either (t1, [t2]) t) -> m t1
08:34:50 <lispy> Is unsafePerformIO covered in RWH?
08:35:10 <Toxaris_> thats nearly nice, but a lightweight syntax for (\x -> case x of ...) would be cool, like in ML
08:36:01 <bzoto> hi
08:36:19 <chrisdone> what does it mean to internalize something in programming?
08:37:09 <Cale> chrisdone: Never heard the term... do you have some context perhaps?
08:37:12 <lispy> lisp has a notion of 'intern'ing a symbol right?
08:38:16 <chrisdone> Cale: what Cheshire said above, <Cheshire> chrisdone, I internalized pattern matching for a small universe of types just by using GADT
08:38:42 <pejo> Toxaris, that also makes it hard to read stuff, yeah.
08:38:53 <Saizan_> chrisdone: it means reifying it as a term of the language, so that it becomes first class, roughly
08:39:15 <chrisdone> oh right
08:40:11 <Cale> Ah, yes, I was just coming back to say that after reading the conversation :)
08:40:43 <Cheshire> Cale, in my book this well ordering thing came up again
08:41:09 <Cheshire> Cale, I am just curious (about well ordering R).. even though it is true -- don't you feel it is kind of a lie?
08:41:15 <Toxaris_> pejo: well, I don't like the extend-the-parser idea myself, because it seems to be not very composable. You add an import and everything changes meaning. Thats not the case with e.g. current Haskell imports, where the worst thing would be that compilation breaks -- assuming no type hackery
08:41:29 <Saizan_> (i guess the representation of patterns is just a record of functions with the appropriate type)
08:41:42 <Cale> Cheshire: Everything is kind of a lie ;)
08:41:51 <JoelyWoely> it's either "true" nor "false", it's just a consequence of the axiom of choice
08:41:52 <ehird> @hoogle (a -> b -> c) -> (a -> b) -> c
08:41:53 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:41:53 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
08:41:53 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
08:41:56 <ehird> @hoogle (a -> b -> c) -> (a -> b) -> a -> c
08:41:56 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:41:56 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
08:41:56 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
08:42:03 <ehird> Hm.
08:42:04 <Cale> Cheshire: Even the natural numbers, really.
08:42:06 <ehird> It's the "split".
08:42:08 <ehird> For func tions.
08:42:13 <Cheshire> JoelyWoely, I mean it's true in ZFC or whathaveyou
08:42:50 <JoelyWoely> numbers do't exist, so statements about them can't really be true or false
08:42:51 <Cale> We will never actually make use of most natural numbers, except that their presence lets us simplify statements we make about numbers.
08:43:29 <JoelyWoely> I forgot who said "if the number 1 existed, it would be in a museum, and everybody would visit to come and behold the number 1"
08:43:36 <Cale> Most natural numbers have existence proofs which are too long to fit in the universe ;)
08:44:12 <Cheshire> oh no
08:44:15 <Cheshire> this isn't what I meant at all
08:44:28 <Cale> And most real numbers are not even definable ;)
08:44:47 <Cale> Well, it's sort of a philosophical issue.
08:44:53 <JoelyWoely> Cale: i forgot, the definable numbers are countable, right?
08:44:58 <Cale> JoelyWoely: yes.
08:45:01 <ehird> @pl \f g x -> f (g x) x
08:45:02 <lambdabot> flip flip id . liftM2
08:45:07 <ehird> @pl \f g x -> f x (g x)
08:45:07 <lambdabot> ap
08:45:10 <ehird> Ah, ap
08:45:14 <ehird> :t ap
08:45:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:45:21 <ehird> So ap is like branching generalized to all monads.
08:45:27 <ehird> Nice.
08:45:40 <Cale> The thing is, the axiom of choice more or less directly hands us the well-ordering for R...
08:45:53 <Cale> So if you want to say that's a lie, you have to argue with an axiom.
08:46:06 <Cale> Which is a matter of philosophy more than a matter of mathematics.
08:46:17 <Toxaris_> ehird: branching? ap is application generalized to monads.
08:46:17 <doserj> it doesn't hand it to you. It just claims there is one :)
08:46:35 <JoelyWoely> "lie" and "axiom to which you have philosophical objections" are not synonyms
08:46:36 <Cale> doserj: Showing that there is one is the same thing as handing it to you, for a mathematician.
08:46:51 <ehird> Toxaris_: Think of ((->) t)'s monad instance.
08:46:57 <Philonous> The axiom of choice is obviously true, the well-ordering principle obviously false and zorns lemma is too complex to judge about.
08:47:01 <ehird> ap f g x = f x (g x)
08:47:04 <Saizan_> it's branching for commutative monads
08:47:10 <ehird> It's "splitting" or "branching" the two functions.
08:47:35 <Cheshire> classical logic and set theory is endlessly facinating
08:47:38 <JoelyWoely> Cale: doh countability of definable numbers should have been obvious
08:47:42 <Cale> Once I know that something exists, I can proceed to make use of that fact, because the first-order logic axioms basically let me do that.
08:47:45 <Toxaris_> for what meaning of "splitting" or "branching"?
08:47:53 <Cale> JoelyWoely: Yeah, there are only countably many definitions :)
08:47:59 <lilac> Philonous: i wouldn't say AC is obviously true; indeed, i'd say it's obviously false ;-)
08:48:15 <Cale> lilac: That the Cartesian product of a collection of nonempty sets is nonempty?
08:48:24 <ehird> lilac: Yikes.
08:48:32 <ehird> Toxaris_: The intuitive meaning.
08:48:44 <Cale> There are too many formulations of AC :)
08:48:49 <Toxaris_> but intuitively, after branching, I have two values
08:48:55 <Cheshire> lilac, I wonder what you even mean by this
08:49:00 <doserj> The axiom of choice may be true. I am more worried about the powerset axiom :)
08:49:08 <Cheshire> lilac, my original question is: Although true, does it not feel like a lie
08:49:11 <ehird> Toxaris_: Okay, it's branching _and_ collapsing.
08:49:22 <Cale> doserj: That's an interesting position.
08:49:26 <ehird> Both your functions need the same value, then it collapses the result of one into another.
08:49:35 <ehird> Useful indeed!
08:49:55 <JoelyWoely> Cheshire: some consequences of AC are obvious and intuitive, while others feel like a lie. oh well.
08:50:02 <lilac> Cheshire: if it feels like a lie, why are you assuming that it's true?
08:50:14 <Cheshire> lilac, because I am talking in the context of ZFC
08:50:31 <Cale> There are other good reasons to hold on to the axiom of choice.
08:50:48 <lilac> Cheshire: if you feel that ZFC leads to lies, then perhaps you should not work in ZFC?
08:50:55 <bzoto> sorry to interrupt, I have a probably stupid question
08:51:01 <Cale> bzoto: Go for it.
08:51:11 <mornfall> Can I have an example of a ZFC consequence that feels like a lie?
08:51:23 <bzoto> I defined this class: class Zut a where blorb :: a -> a -> a
08:51:25 <ehird> @hoogle [a] -> a -> Int
08:51:26 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
08:51:26 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
08:51:26 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:51:29 <JoelyWoely> mornfall: well ordering theorem, existence of nonmeasurable sets
08:51:29 <Cale> mornfall: Cheshire is worried about the well ordering of the Reals.
08:51:37 <Toxaris_> ehird: ok I think I see what you mean then.
08:51:42 <Cale> bzoto: okay
08:51:45 <bzoto> then tried to do:
08:51:48 <Cheshire> I am not worried about it really
08:51:53 <bzoto> instance (Num a) => Zut a where  blorb x y = x + y
08:52:05 <Cale> bzoto: You'll need some extensions for that.
08:52:05 <Cheshire> it is very interesting though
08:52:11 <mornfall> Hm. Not sure what's problem with ordering reals (or anything bigger, anyawy).
08:52:13 <mornfall> anyway*
08:52:23 <Cale> bzoto: Because that instance overlaps with everything.
08:52:23 <mornfall> +the
08:52:32 <bzoto> ah, thanks
08:52:32 <jpcooper> @hoogle Functor f => [f a] -> f [a]
08:52:32 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:52:32 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
08:52:32 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
08:52:43 <Cheshire> here is another thing which is provable in ZFC that feels like a lie to me:   forall P : Program, Halts(P) \/ ~Halts(P)
08:52:44 <lilac> mornfall: Banach-Tarski is i think the most obvious disproof of AC
08:52:50 <bzoto> so what should I do, practically?
08:53:01 <Cale> bzoto: Normally, you need at least one type constructor in the instance head...
08:53:03 <ehird> Cheshire: err, that seems pretty true to me
08:53:05 <lilac> mornfall: for some definition of "disproof" :)
08:53:10 <ehird> a program either halts or it doesn't.
08:53:22 <rwbarton> Cheshire: Intuitionistic logic is a nice topos to visit, but I wouldn't want to live there.
08:53:26 <Cale> bzoto: You could just write the polymorphic function  blorb :: (Num a) => a -> a -> a; blorb x y = x + y
08:53:39 <Saizan_> maybe the discussion on ZFC should move to -in-depth?
08:53:40 <Cheshire> isn't every topos intuitionistic?
08:53:43 <lilac> mornfall: AC says you can take a solid sphere, cut it into 7 pieces, and put them back together into two spheres each identical to the original
08:53:47 <geezusfreeek> i like intuitionistic logic
08:53:53 <bzoto> yes, the problem is that I was trying also to do:
08:53:54 <rwbarton> Cheshire: not if you mean non-classical
08:53:58 <Cale> lilac: Once you see the proof of that, it's no longer surprising.
08:54:01 <bzoto> instance Zut [a] where  blorb x y = x ++ y
08:54:02 <zachk> ive heard you can do it with 5 pieces
08:54:05 <mornfall> lilac: I still don't see a problem with that. :)
08:54:07 <Cheshire> rwbarton, huh? tell me more :)
08:54:18 <Cheshire> I just read about what a topose is yesterday though..
08:54:18 <doserj> lilac: and you can't really "cut" it into these 7 pieces.
08:54:18 <lilac> Cale: not surprising, but obviously a bad model of reality
08:54:20 <Cale> lilac: The pieces aren't measurable! They're strange clouds of points.
08:54:21 <rwbarton> Cheshire: e.g., assuming a classical logic, the topos of sets is classical :)
08:54:33 <Cale> lilac: Who said anything about "reality"? What is reality anyway?
08:54:50 <lilac> Cale: reality is that thing which mathematics was created to model
08:54:51 <Cheshire> rwbarton, it's not strictly a categorical notion then?
08:55:00 <Cheshire> lilac, oh no, by no means
08:55:02 <Cale> lilac: I disagree. :)
08:55:04 <zachk> reality isnt what it seems
08:55:06 <mornfall> Things that are continuum or bigger *do* behave counterintuitively. That's not a problem of AC though, removing AC doesn't "fix" that problem.
08:55:07 <rwbarton> Cheshire: what, being classical?
08:55:08 <nominolo> anyone know whether it is possible to define mfix for a CPS-style monad?
08:55:08 <Philonous> lilac: Knowing that ]0,1[ \subset R has the same amount of members as R I don't see a Problem with the spheres.
08:55:08 <lilac> Cale: i have no objection to the study of ZFC at all
08:55:30 <lilac> Cale: but assuming that it's the model in which we should reason about our universe i find questionable
08:55:31 <Cale> Philonous: Right, it's almost the same as that.
08:55:34 <Cheshire> nominolo, I'm not sure what the point would be, you can already make loops without mfix
08:55:50 <Cheshire> rwbarton, I thought toposes were defined as basically CCCs
08:55:52 <Cale> lilac: It's not directly the model in which we reason about our universe.
08:56:03 <bzoto> my initial idea was to write a polimorphic function "blorb" to sum number and to concatenate lists
08:56:04 <Cheshire> I must have got a really wrong impression from this Lawvere book..
08:56:04 <Saizan_> nominolo: there are slides from M. Carlsson on that
08:56:04 <Cale> lilac: It's a collection of tools we can possibly use for that task...
08:56:20 <Cale> lilac: But any model of the universe will have many more axioms.
08:56:22 <nominolo> Cheshire: i want to feed parts of the output of a monadic function as its argument
08:56:23 <bzoto> just as an exercise
08:56:28 <Saizan_> nominolo: and you need IORefs or something like that
08:56:28 <rwbarton> Cheshire: yes.  The category of sets is a CCC.  The truth values are subobjects of the final object {*} which are {} and {*} corresponding to false and true.
08:56:34 <geezusfreeek> cue existential conversation about what the universe is
08:56:36 <lilac> Cale: sure, but it will probably also lack some axioms of ZFC
08:56:38 <zachk> and every axiom is based on taking something on faith
08:56:58 <Cheshire> rwbarton, but you can interpret classical logic into a CCC?
08:57:07 <Cale> lilac: No. Physicists need functional analysis, which needs basically all of ZFC.
08:57:12 <Cheshire> that is really a surprise to me
08:57:29 <Saizan_> bzoto: if you want an instance for any number you have to enable UndecidableInstances and OverlappingInstances
08:57:31 <Cale> lilac: (at least in modern quantum mechanics)
08:57:42 <rwbarton> Cheshire: you can interpret intuitionistic logic into a CCC, then it might happen that the laws of classical logic hold, and then we call the topos classical
08:57:43 <lilac> Cale: don't get me started on modern quantum mechanics ... :)
08:57:56 <rwbarton> Cheshire: (disclaimer: I am not an expert on topoi)
08:57:59 <Cheshire> rwbarton, sorry I don't follow this
08:58:09 <Cheshire> rwbarton, it's no wonder though, the concept is new to me
08:58:22 <Cale> lilac: It seems to work and be useful, which at the end of the day is really the only measuring stick for truth.
08:58:27 <lilac> Cale: in any case, my point is this: people like to think that mathematics is 'truth'
08:58:45 <bzoto> Saizan_: thanks, probably I'm trying to do something stupid with a static type system
08:58:46 <Cale> lilac: Truth is an arbitrary label we attach to things in various ways :)
08:59:12 <lilac> Cale: "follows from these axioms" is a reasonable definitino of "truth" as long as you're conscious of it :)
08:59:14 <Cheshire> @go Arctic Termination ... Below Zero
08:59:17 <lambdabot> http://portal.acm.org/citation.cfm?id=1427683
08:59:17 <lambdabot> Title: Arctic Termination ...Below Zero
08:59:30 <Cheshire> these research people and puns...
08:59:33 <cjb> lilac: I'd just say that they find it helpful to enumerate their assumptions and axioms and build sanely on top of them.  (We should all be so rigorous.)
08:59:58 <Cale> bzoto: The trouble is with what happens when someone comes along and writes an instance (Num a) => Num [a]
09:00:02 <mornfall> lilac: Hm. If they say mathematics is truth, I say they are crazy.
09:00:09 <mornfall> That's the whole problem. :)
09:00:31 <Cale> bzoto: Because a future module could always contain such an instance, selection of instances is based on the structure of the type alone and not on which typeclasses it already belongs to
09:00:39 <Saizan_> bzoto: not exactly, you could for example write an instance Zuf Int, and instance Zuf Double, etc.. you just can't define one for all Num a => a nicely
09:00:46 <mornfall> "Truth" like that (any definition of truth that could make mathematics true, I suppose) is subject of religion, not science. :)
09:00:57 <zachk> i am crazy and i say mathematics is true :-D
09:00:58 <Cale> bzoto: That is, when you write  instance (Num a) => Baz a, it's almost as if you're writing  instance Baz a
09:00:59 <lilac> mornfall: exactly :)
09:01:11 <bzoto> Yes, at first I used just Integer
09:01:18 <bzoto> and it worked fine
09:01:28 * lilac just learnt something new about what IRC considers to be a legal /inck
09:01:43 <eric_j> why is this a slow reverse function: reverse3 (x:xs) = foldr (:) [x] $ reverse3 xs
09:01:45 <Saizan_> bzoto: you can have a wrapper though, newtype NumZ a = NumZ a deriving Num; instance Num a => Zuf (NumZ a) where ...; and use (NumZ a) instead of 'a'
09:01:52 <bzoto> thanks a lot
09:02:05 <mornfall> lilac: I'm glad we sorted out that objections against ZFC are largely theological and not scientific. ;)
09:02:20 <lilac> mornfall: i was assuming that was obvious ;-)
09:02:31 <Cale> mornfall: Well... I just changed my idea of what truth is. Asking whether mathematics as a whole is true or not is similar to asking if a bottle of rubbing alcohol or a chair is true or not. It's a system, not a statement :)
09:02:34 <mornfall> Unfortunately, it's never quite obvious.
09:02:37 <lilac> (right from the moment we started branding axioms as 'obviously true' or otherwise) :)
09:02:42 <nominolo> Saizan_: do you remember some more details about these slides?
09:02:51 <lispy> > let reverse3 = foldl1' (flip (:)) in revers3 [1..10]
09:02:53 <lambdabot>   Not in scope: `revers3'
09:02:56 <lispy> > let reverse3 = foldl1' (flip (:)) in reverse3 [1..10]
09:02:58 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
09:02:58 <lambdabot>        Expect...
09:03:01 <lispy> doh!
09:03:03 <Cale> Asking if a statement of mathematics is true or not is up to the axioms of the system in which it resides.
09:03:08 <nominolo> Saizan_: I can't find much using "carlsson mfix"
09:03:11 <lispy> > let reverse3 = foldr1 (flip (:)) in reverse3 [1..10]
09:03:12 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
09:03:12 <lambdabot>        Expect...
09:03:38 <Saizan_> eric_j: becuase it's equivalent to reverse3 (x:xs) = reverse3 xs ++ [x] and (++) is O(n) so the reverse becomes O(n^2)
09:03:40 <nominolo> Saizan_: ah, MonadFix works a bit better
09:03:51 <mornfall> lispy: You can't use foldr1 that way.
09:04:02 <mornfall> lispy: Or foldl1 for that matter.
09:04:03 <Cale> But since mathematics makes no *predictions* about observations you could make, it's not a science, and so it's not subject to petty issues like the scientific method. :)
09:04:16 <lispy> mornfall: yeah, guess I need foldl/foldr
09:04:31 <mornfall> lispy: It's type is (a -> a -> a) -> ..., while (:)'s type is a -> b -> b.
09:04:45 <eric_j> Saizan_, i guess i don't understand, why is it materializing all the sublists? is there some hidden strictness in there?
09:04:46 <mornfall> Well, a -> [a] -> [a].
09:04:46 <idnar> lilac: oh, the real fun is the part where the RFC specifies that {}| are considered to be the lowercase versions of []\
09:04:51 <lispy> mornfall: yeah, I /msg lambdabot and saw that, thanks :)
09:04:51 <mornfall> That's not going to unify no way you bend it.
09:04:58 * lispy nods
09:04:59 <idnar> lilac: I think most software ignores that provision these days, though
09:05:29 <brutopia> hey, how do I program in haskell like using yield in python
09:05:44 <Cheshire> brutopia, just the same except don't write yield
09:05:45 <lispy> > let reverse3 = foldr' (flip (:)) [] in reverse3 [1..10]
09:05:45 <mornfall> brutopia: What's "using yield in python" like? :) Isn't that a sideeffect?
09:05:46 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
09:05:46 <lambdabot>        Expect...
09:05:52 <brutopia> I was thinking on how to convert accepted answer on this question to haskell http://stackoverflow.com/questions/104420/how-to-generate-all-permutations-of-a-list-in-python
09:05:57 <lispy> > let reverse3 = foldl' (flip (:)) [] in reverse3 [1..10]
09:05:59 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
09:06:04 <idnar> the "yield" keyword is used in Python generators, which are a limited form of coroutines
09:06:23 <lispy> brutopia: you would either use the natural laziness of haskell or you'd use something like CPS
09:06:25 <idnar> I suppose the closest to that would be the Cont monad
09:06:36 <lilac> brutopia: in that case, you'd use the list monad
09:06:38 <Cheshire> why would Cont be of us here?
09:06:41 <Cheshire> us
09:06:42 <Cheshire> use*
09:06:43 <Saizan_> eric_j: they are not materialized all at once, but they are still computed if you eventually look at the whole list
09:07:01 <idnar> but you probably want to translate a Python "data-oriented" generator into a Haskell function producing a list, not some Cont-monad craziness
09:07:19 * Cheshire snickers at "data-oriented"
09:07:33 <idnar> Cheshire: as opposed to "control-flow-oriented" :P
09:07:43 <lispy> co-routines in haskell are "intrinsic" for lack of better description
09:07:44 <brutopia> sounds reasonable, I saw one example of python 2.5 generators in haskell using continuations and it seemed overly complicated
09:08:35 <ehird> Yeah, just return a list.
09:08:51 <Botje> yes
09:09:00 <Botje> anything involving continuations is generally complicated :)
09:09:12 <mornfall> Lift the permutations implementation from Data.List.
09:09:14 <mornfall> : - )
09:09:21 <lispy> continuations remind me of gotos to be honest
09:09:28 <idnar> to put it another way, Haskell doesn't need generator expressions, because list comprehensions (along with almost everything else) are already lazy
09:09:40 <mornfall> lispy: Maybe because they are generalisation thereof.
09:09:56 <idnar> continuations are the ultimate control-flow building block
09:09:58 <tromp__> @let rev xs = foldr (\x f g -> f(x:g)) id xs []
09:10:01 <lambdabot>  Defined.
09:10:09 <brutopia> I'm learning haskell and I'm trying to find some nice little algorithms I could try to convert
09:10:26 <lilac> > let permutations [] = [[]]; permutations [x] = [[x]]; permutations (x:xs) = do ys <- permutations xs; n <- [0..length ys]; let (h,t) = splitAt n ys in h ++ [x] ++ t in permutations [1,2,3]
09:10:28 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
09:10:28 <lambdabot>        Expect...
09:10:44 <tromp__> > rev "redrum"
09:10:46 <lambdabot>   "murder"
09:11:59 <lilac> > let permutations [] = [[]]; permutations [x] = [[x]]; permutations (x:xs) = do ys <- permutations xs; n <- [0..length ys]; let (h,t) = splitAt n ys in return $ h ++ [x] ++ t in permutations [1,2,3]
09:12:01 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
09:12:49 <brutopia> what does the dollar sign mean?
09:12:56 <lispy> :t ($)
09:12:58 <lambdabot> forall a b. (a -> b) -> a -> b
09:13:08 <gnuvince> f (a) == f $ a
09:13:08 <lispy> > reverse $ [1..10]
09:13:10 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
09:13:19 <lilac> brutopia: it means function application. f $ a = (f) (a)
09:13:41 <lispy> brutopia: basically it just lows the precedence.  This is only really useful for syntatic reasons
09:13:53 <lispy> brutopia: but there are occasionally other uses, like with zip
09:13:56 <lispy> :t zipWith ($)
09:13:57 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
09:14:20 <lilac> > map ($x) [f,g] :: [Expr]
09:14:22 <lambdabot>   [f x,g x]
09:14:35 <Toxaris_> :t zipWith id
09:14:37 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
09:20:09 <klirr> http://en.wikipedia.org/wiki/Function_composition is that true for haskell? f(g(h(x))) == f(h(g(x))) ?
09:20:51 <klirr> or wait, associative but not commuatative?
09:21:44 <JoelyWoely> hm?
09:21:56 <JoelyWoely> function composition generally isn't commutative
09:22:02 <quicksilver> klirr: function composition is associative but not commutative, that's right.
09:22:12 <quicksilver> (f.g).h == f.(g.h)
09:22:22 <quicksilver> but f.g /= g.f (in general)
09:22:24 <tromp__> cant get any straight answers on #perl :(
09:22:28 <quicksilver> in general their types don't even match.
09:22:36 <Raevel> there are no straight answers in perl
09:22:49 <tromp__> my question was: is there a regex that never matchers?
09:23:02 <tromp__> shld have a straight answer...
09:23:11 <Raevel> /[^allchars]/
09:23:24 <klirr> can i compose foldl with map?
09:23:28 <stepcut> this works with base-3.0.3.0 but not base-4: "sockPath <- try (getEnv "SSH_AUTH_SOCK") >>= either (error . show) return", I get an error,     Ambiguous type variable `e' in the constraint: `Exception e' arising from a use of `try'. Is there a fix that will work with 6.8 and 6.10?
09:23:36 <quicksilver> the practice of asking perl questions here when you don't get an asnwer in #perl is spirited but not encouraged.
09:23:51 <quicksilver> klirr: yes. sort of.
09:23:53 <Raevel> not really a perl question though :-)
09:24:01 <ehird> quicksilver: Lol!
09:24:10 <quicksilver> klirr: if they are both partially applied so they are unary.
09:24:18 <quicksilver> klirr: (.) composes unary functions.
09:27:51 <klirr> let a = ((foldl (\x y -> x+y) 0) . map) (\x -> x*x)
09:27:53 <klirr> doesnt work
09:28:30 <klirr> quicksilver: but haskell people are so smart and knowledgeable they can often answer anything
09:28:38 <Deewiant> stepcut: you need to specify the exception type you want to catch (probably IOException)
09:28:51 <pumpkin> > foldl (+) 0 . map (^2) $ [1..10]
09:28:53 <lambdabot>   385
09:29:04 <Deewiant> stepcut: if you want to retain 6.8 compatibility, depend on the extensible-exceptions package (which essentially brings the new 6.10 exceptions stuff into 6.8)
09:29:17 <pumpkin> > foldl (+) 0 . map (join (*)) $ [1..10]
09:29:19 <lambdabot>   385
09:29:35 <pumpkin> > foldl (\x y -> x + y) 0 . map (\x -> x * x) $ [1..10]
09:29:36 <lambdabot>   385
09:29:53 <pumpkin> klirr: make sense?
09:30:05 <stepcut> Deewiant: cool, that's what I am doing, just wanted to make sure it was right ;)
09:30:06 <pumpkin> maybe not the middle one
09:30:33 <klirr> only unary functions can be composed?
09:30:41 <klirr> hmm no now i see your example
09:30:44 <quicksilver> klirr: you can do anything you like
09:30:48 <quicksilver> but (.) composes unary functions.
09:30:52 <Deewiant> all functions are unary ;-)
09:30:57 <pumpkin> yeah :P
09:31:05 <klirr> because of currying?
09:31:07 <pumpkin> yup
09:31:09 <Deewiant> yep
09:32:31 <pumpkin> > ((+) . (^2)) 1 2
09:32:33 <lambdabot>   3
09:32:38 <pumpkin> > ((+) . (^2)) 3 2
09:32:40 <lambdabot>   11
09:33:21 <quicksilver> I don't think all functions are unary because of currying.
09:33:28 <quicksilver> I think all functions are unary because that is how haskell is.
09:33:30 <quicksilver> (or STLC)
09:33:37 <Deewiant> > (((+) .) . (*)) 2 3 4
09:33:38 <lambdabot>   10
09:33:45 <quicksilver> but it's also just a point of view
09:33:53 <quicksilver> you could call a function from a 2-tuple binary if you want.
09:38:43 <klirr> what si the use of foldl? why isnt Data.List.foldl' the default foldl? for any large inputs foldl overflows
09:38:54 <klirr> well i guess it is for laziness
09:39:16 <dons> foldl has no use.
09:39:16 <klirr> is foldl . map faster than foldl' . map?
09:39:20 <dons> nope
09:39:37 <dons> it is a bug, almost, that it exists -- due to the absence of `seq` in H98
09:39:48 <klirr> what is the advantage of foldr ten?
09:39:55 <klirr> then
09:39:56 <dons> foldr is lovely
09:39:59 <klirr> why?
09:40:05 <pumpkin> foldr is the more "natural" way to fold
09:40:07 <lilac> > foldl (flip (:)) [] "dlroW olleH"
09:40:08 <lambdabot>   "Hello World"
09:40:25 <dons> in a lazy language, folding under the constructor is the natural way to transform lists.
09:40:28 <klirr> but why is it? i think it harder to think in foldl than foldr ways
09:40:37 <klirr> to write foldr i write foldl then swithc the params
09:40:38 <Igloo> dons: Err, seq is in H98
09:40:44 <Cheshire> klirr, it's easier to think about foldr
09:40:55 <dons> Igloo: sorry, yes. but nothing using it. no foldl'
09:41:30 <Igloo> The absence of foldl' is a bug, granted. I'm not sure I'd call the presence of foldl a bug.
09:41:37 <klirr> when is it easier to think about foldr?
09:41:41 <doserj> dons: ($!) is in H98
09:41:41 <dons> its weird. gofer had foldl'
09:41:45 <dons> foldl' f a []     =  a
09:41:45 <dons> foldl' f a (x:xs) =  strict (foldl' f) (f a x) xs
09:41:54 <dons> and sum/product, etc defined in terms of it.
09:42:01 <klirr> isnt there some things which cant be done or that foldl is defined in terms of dolr?
09:42:03 <dons> so maybe just the absence of foldl' is the bug?
09:42:09 <dons> dcoutts_: do you remember what we concluded on this?
09:43:05 <lilac> > let a *? 0 = 0; a *? b = a * b; xs = [1,2,3,0,undefined,4,5] in (foldl (*?) 1 xs, foldl' (*?) 1 xs)
09:43:05 <klirr> > scanr (+) 0 [0.3,0.5,0.2]
09:43:08 <lambdabot>   [1.0,0.7,0.2,0.0]
09:43:08 <lambdabot>   (* Exception: Prelude.undefined
09:43:17 <lilac> > let a *? 0 = 0; a *? b = a * b; xs = [1,2,3,0,undefined,4,5] in (foldl' (*?) 1 xs, foldl (*?) 1 xs)
09:43:19 <lambdabot>   (* Exception: Prelude.undefined
09:43:20 <klirr> > reverse $ scanr (+) 0 [0.3,0.5,0.2]
09:43:21 <lambdabot>   [0.0,0.2,0.7,1.0]
09:43:29 <klirr> the last oen is what id want...
09:43:52 <klirr> > reverse $ scanr (+) [0.3,0.5,0.2]
09:43:54 <lambdabot>   Couldn't match expected type `[a]'
09:44:09 <klirr> > reverse $ drop 1 $ scanr (+) 0 [0.3,0.5,0.2]
09:44:11 <lambdabot>   [0.0,0.2,0.7]
09:44:15 <Saizan_> > scanl (+) 0 [0.3,0.5,0.2]
09:44:16 <lambdabot>   [0.0,0.3,0.8,1.0]
09:44:20 <klirr> > reverse $ drop last  $ scanr (+) 0 [0.3,0.5,0.2]
09:44:21 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a] -> a'
09:44:27 <klirr> > reverse $ droplast  $ scanr (+) 0 [0.3,0.5,0.2]
09:44:29 <lambdabot>   Not in scope: `droplast'
09:44:44 <klirr> > reverse $ init $ scanr (+) 0 [0.3,0.5,0.2]
09:44:46 <lambdabot>   [0.2,0.7,1.0]
09:45:00 <klirr> no not hwta iw ant still
09:45:09 <lilac> > let _ *? 0 = 0; a *? b = a * b; xs = [1,2,3,undefined,4,5,0] in (foldl (*?) 1 xs, foldl' (*?) 1 xs)
09:45:11 <lambdabot>   (0,* Exception: Prelude.undefined
09:45:18 <lilac> ^^ that's the case where you want foldl not foldl'
09:45:56 <klirr> scanl1 (+) [0.3,0.5,0.2]
09:47:56 <niff> > init $ scanl (+) 0 [0.3,0.5,0.2]
09:47:57 <lambdabot>   [0.0,0.3,0.8]
09:53:46 <niff> > init $ scanl (+) 0 [0.3,0.5,0.2]
09:53:48 <lambdabot>   [0.0,0.3,0.8]
09:53:56 <niff> > drop 1 $ scanl (+) 0 [0.3,0.5,0.2]
09:53:58 <lambdabot>   [0.3,0.8,1.0]
09:54:34 <Beelsebob> > scanl1 (+) [0.3,0.5,0.2]
09:54:36 <lambdabot>   [0.3,0.8,1.0]
09:54:53 <lilac> > scanl1 (+) []
09:54:55 <lambdabot>   []
09:55:55 <stepcut> is there a way to do something like this, {-# OPTIONS_GHC -package=base-3.0.3.0 #-}
09:55:56 <stepcut>  
09:56:01 <dcoutts_> dons: I think we reckoned sum = foldl blah was a mistake, that it should have been foldr or foldl', but foldl' had been removed or not included for some reason
09:56:30 <dcoutts_> stepcut: use the .cabal file for that kind of thing.
09:56:50 <stepcut> dcoutts_: well, I want, runhaskell MyApp.hs, to work
09:56:50 <dcoutts_> stepcut: it'd be far to brittle in a options pragma in an .hs file
09:57:04 <dons> dcoutts_: right. and gofer uses foldl'. so still unknown is why foldl' wasn't in the spec.
09:57:16 <dons> launcbury thought it was an oversight.
09:57:32 <dcoutts_> stepcut: then make your app work with base 3 or 4, possibly using cpp.
09:57:51 <dcoutts_> dons: is there a ticket for it for H' ?
09:58:23 <stepcut> dcoutts_: I guess I'll just do, runhaskell -package=base-3.0.3.0 MyApp.hs for now until I can update it to base 4
09:58:24 <dons> mm
09:58:24 <dcoutts_> dons: Oege tells me that in Orwel, the FP language from oxford, that foldl was strict.
09:58:31 <dons> yep
09:58:39 <dons> gofer had a lazy foldl too, interestingly.
09:59:07 <dcoutts_> dons: you mean its standard foldl was lazy and had foldl' strict one?
10:00:48 <dons> right. it just used foldl' everywhere though.
10:01:00 <dons> but the distinction between foldl and foldl' was there in 94.
10:02:07 <dcoutts_> dons: so Oege says the used default foldl strict because there are basically no uses where the lazy one is required.
10:02:18 <dcoutts_> the/they [in orwel]
10:02:36 <dons> or anywhere.
10:03:31 <roconnor> @src reverse
10:03:31 <lambdabot> reverse = foldl (flip (:)) []
10:07:32 <Beelsebob> > (e ** pi) - pi
10:07:34 <lambdabot>   e**pi - pi
10:07:38 <Beelsebob> :(
10:07:58 <lament> that's pretty accurate
10:08:04 <roconnor> > x ** y + 1
10:08:06 <lambdabot>   x**y + 1
10:09:01 <Deewiant> > exp 1 ** pi - pi
10:09:03 <lambdabot>   19.99909997918947
10:09:12 <lament> > exp pi - pi
10:09:13 <lambdabot>   19.999099979189474
10:09:14 <Beelsebob> damn
10:09:21 <Beelsebob> lambdabot's maths is inacurate
10:09:28 <Deewiant> > exp 1 ** pi - pi :: CReal
10:09:30 <lambdabot>   19.9990999791894757672664429846690444960689
10:09:31 <Deewiant> :-P
10:09:32 <mle> heh
10:09:36 <Beelsebob> damn
10:09:39 <lament> Deewiant: it's 'exp pi', sheesh
10:09:42 <fsanches> how can that be? lambdabot is never wrong!
10:10:12 <lament> lambdabot is acting to the best of her knowledge
10:10:16 <Deewiant> lament: sheesh
10:10:20 <lament> sheesh
10:10:25 * Beelsebob giggles
10:10:31 <lament> > sheesh
10:10:33 <lambdabot>   Not in scope: `sheesh'
10:10:40 <lament> > s h e e s h
10:10:41 <lambdabot>   Couldn't match expected type `a -> Expr -> Expr -> Expr -> a1 -> t'
10:11:10 <fsanches> @slap lament
10:11:10 * lambdabot beats up lament
10:11:12 <Beelsebob> there's an xkcd about telling people that if e^pi - pi doesn't come out at 20, then you have rounding bugs in your implementation
10:11:25 <Deewiant> :-)
10:12:02 <lament> > let exp pi - pi = 20 in exp pi - pi
10:12:03 <lambdabot>   <no location info>: Parse error in pattern
10:12:06 <lament> :P
10:12:15 <rwbarton> > exp (pi * sqrt 163) :: CReal
10:12:16 <lambdabot>   262537412640768743.9999999999992500725971981856888793538563
10:14:56 <Cale> Someday I'm really going to have to read about the reason for that carefully.
10:16:02 <pumpkin> wasn't that one of the ones ramanujan came up with?
10:16:58 <pumpkin> maybe not
10:18:12 <Cale> I think it's more modern.
10:18:20 <Cale> At least the explanation is.
10:19:21 <Cale> Oh, it was an April Fool's joke that said Ramanujan predicted that it would be an integer.
10:19:56 <ehird> > exp 1 ** (0:+1 * pi) + 1
10:19:57 <lambdabot>   0.0 :+ 1.2246467991473532e-16
10:20:31 <Cale> It's somewhat believable since Ramanujan did make use of zany numbers of that sort. He has a series expansion for pi which uses e^(pi sqrt(58))
10:21:14 <FunctorSalad> I'm despairing :( how do you derive stuff for types with existential constructors? I even tried modifying the "derive" package, but no luck so far
10:21:31 <Cale> > exp (pi * sqrt 58) :: CReal
10:21:33 <lambdabot>   24591257751.9999998222132414695761923552658122276102
10:21:44 <FunctorSalad> I've ran into that several times already so there must be some solution I guess...
10:21:59 <Cale> FunctorSalad: Mostly I end up writing it by hand.
10:22:09 <Deewiant> Standalone deriving?
10:22:26 <rwbarton> , [d| data Foo = forall a. Num a => a -> Foo |]
10:22:26 <Cale> Standalone deriving can't do much which normal deriving can't.
10:22:28 <lunabot>  luna: Not a data constructor: `a'
10:22:38 <rwbarton> , [d| data Foo = forall a. Num a => Foo a |]
10:22:39 <FunctorSalad> Cale: the part that makes me want to automate it is that in some cases the instances are identical
10:22:41 <mightybyte> > exp (pi * sqrt (-1))
10:22:41 <lunabot>  DataD [] Foo [] [ForallC [a_0] [AppT (ConT Num) (VarT a_0)] (NormalC Foo ...
10:22:42 <lambdabot>   NaN
10:23:31 <FunctorSalad> for binary methods like Eq and Ord you need some casting, though
10:23:34 <Cale> > exp (pi * sqrt 58) - 12^3 * (231^2 - 1)^3 + 744 :: CReal
10:23:35 <lambdabot>   -262537388049509504.0000001777867585304238076447341877723898
10:23:54 <Cale> > exp (pi * sqrt 163) - 12^3 * (231^2 - 1)^3 + 744 :: CReal
10:23:56 <lambdabot>   1487.9999999999992500725971981856888793538563
10:24:07 <Cale> oh, duh :)
10:24:11 <Cale> > exp (pi * sqrt 163) - (12^3 * (231^2 - 1)^3 + 744) :: CReal
10:24:13 <lambdabot>   -0.0000000000007499274028018143111206461437
10:24:15 <niff> where is join?
10:24:21 <Cale> niff: In Control.Monad
10:24:55 <ziman> if a CReal value is not integral, does it mean the represented number cannot be integral?
10:24:59 <dmead> hey channel
10:25:15 <niff> what doe sjoin do?
10:25:23 <niff> Control.Monad.join :: (Monad m) => m (m a) -> m a
10:25:26 <niff> hmm?
10:25:38 <niff> it takes a monad container and returns the contained stuff?
10:25:43 <Cale> ziman: Basically.
10:26:00 <ziman> nope, it "collapses" two nested containers into one
10:26:08 <Cale> niff: join x = do y <- x; v <- y; return v
10:26:26 <ziman> > join $ Just (Just 5)
10:26:28 <lambdabot>   Just 5
10:26:46 <Cale> In the "action" view of things, join x is the action which runs x, then runs its result, returning the result of that.
10:27:19 <Cale> In the list monad, it's simply concatenation (pick a list from the list of lists, then pick an element from that list)
10:27:37 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
10:27:39 <lambdabot>   [1,2,3,4,5,6,7,8]
10:28:10 <FunctorSalad> in the probability monad, it is a random number generated with a method chosen at random ;) ;)
10:28:17 <Cale> indeed.
10:28:34 <idnar> > join $ Just Nothing
10:28:35 <Cale> In the function monad, it applies the given function to the parameter to which the whole function has been applied
10:28:36 <lambdabot>   Nothing
10:28:39 <Cale> > join (*) 5
10:28:40 <lambdabot>   25
10:28:44 <idnar> > join $ Nothing
10:28:45 <lambdabot>   Nothing
10:28:47 <Cale> er, applies it twice
10:28:49 <Cale> rather
10:30:33 <Cale> @oeis 3,9,21,231
10:30:35 <lambdabot>  Sequence not found.
10:30:44 <Twey> Probability monad?
10:31:14 <Cale> Twey: Random number generation monads are essentially the same as probability distributions
10:31:30 <Cale> Well, ways of representing probability distributions, I should say
10:31:52 <niff> does gaussian distributeion mean uniform?
10:31:58 <Cale> niff: no...
10:32:17 <Twey> So you define a probability distribution and when you run it you get a result?
10:32:17 <Cale> niff: Its PDF looks like a bell.
10:32:22 <Cale> Twey: yeah
10:32:33 <Twey> Oh, that's nice
10:32:36 <niff> *Matrix Data.List Control.Monad> Control.Monad.join (*) 5
10:32:36 <niff> <interactive>:1:0:
10:32:36 <niff>     No instance for (Monad ((->) a))
10:33:11 <Cale> niff: http://en.wikipedia.org/wiki/Gaussian_distribution
10:33:22 <FunctorSalad> Twey: here's one with explicit probabilities http://hackage.haskell.org/packages/archive/probability/0.2.1/doc/html/Numeric-Probability-Distribution.html#t%3AT
10:33:52 <Cale> Also, WriterT (Product Rational) [] is handy for keeping track of probabilities.
10:34:12 <FunctorSalad> Twey: then there's the monte-carlo monad for just efficiently generating random numbers http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monte-carlo
10:35:39 <Cale> Hmm, I wonder for which d it happens that Q(sqrt(-d)) has class number 2...
10:35:50 <ziman> niff, it might be in Control.Monad.Instances
10:35:51 <Gracenotes> hm... if I'm trying to write a monad instance for a newtype'd ReaderT, I'm probably doing something wrong, right? :)
10:36:09 <Gracenotes> I should probably write the instance for the WriterT that contains it
10:36:09 <Cale> Gracenotes: use newtype deriving to derive Monad and Functor instances
10:36:11 <FunctorSalad> Gracenotes: you can derive Monad for newtypes
10:37:14 <Twey> FunctorSalad: Is there some sample code using it?
10:37:17 <Gracenotes> Cale: ah, thanks :)
10:38:00 <Gracenotes> it's somewhat complicated using newtype'd monad transformers together, but I think it'll pay off in the end, I think
10:39:36 <Gracenotes> Cale: uh... how would a newtype work with deriving?
10:40:07 <rwbarton> with GeneralizedNewtypeDeriving
10:40:12 <FunctorSalad> Twey: don't know about the probability package; I've used the monte-carlo a bit but it's entangled with the rest of that program (so not exactly a good example)
10:40:17 <Cale> newtype Foo a = ReaderT MyEnv OtherMonad a deriving (Functor, Monad)
10:40:23 * rwbarton wonders how to add the names of GHC extensions to his IRC client's tab completion
10:40:36 <Gracenotes> oh, but I'll need a GHC extension. okay.
10:40:54 <Gracenotes> Cale: also, do you mean Foo (Reader T...)?
10:41:03 <Cale> yes
10:41:05 <Cale> sorry
10:41:14 <Gracenotes> thanks :D
10:41:39 <FunctorSalad> Twey: maybe one nice example is "u01v = liftM3 Vec3D u u u where u = uniform 0 1". that generates a uniformly random vector in the unit cube
10:41:41 <Gracenotes> I assume that some GHC extensions will become part of the core language in Haskell'?
10:41:51 <daf> yes
10:42:03 <Cale> yeah, that's basically the point of Haskell'
10:42:09 <hackage> Uploaded to hackage: blogination 0.2
10:42:16 <Twey> FunctorSalad: That is a nice example
10:43:21 <rwbarton> I guess we can just have bots hanging out here with names like GeneralizedNewtypeDeriving :)
10:43:37 <Gracenotes> hehe, "(even with cunning newtype deriving: the type constructor has wrong kind)"
10:44:02 <Gracenotes> due to a typo. Still, cunning indeed.
10:53:29 <FunctorSalad> could one implement Ord for an existential type by comparing the TypeReps in case cast returns Nothing?
10:54:52 <mauke> that might require unsafePerformIO
10:54:57 <FunctorSalad> :O
10:55:22 <FunctorSalad> how so? typeOf seems to be pure
10:55:28 <dolio> What cast?
10:55:39 <rwbarton> presumably there's a Typeable context in the existential
10:55:53 <rwbarton> but TypeRep isn't an instance of Ord
10:55:54 <FunctorSalad> yes, rwbarton
10:56:01 <FunctorSalad> (on both)
10:56:19 <lilac> @instances-importing Data.Dynamic Ord
10:56:19 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:56:24 <FunctorSalad> rwbarton: it contains a "Key" though (whatever that is) so it probably could be made one
10:56:29 <dolio> I get the feeling that won't work.
10:56:34 <rwbarton> FunctorSalad: I guess you could  compare `on` show  and hope :/
10:56:41 <FunctorSalad> :D
10:56:48 <lilac> Ord would not be in a specified order if you used the Key, presumably
10:57:03 <dolio> Is there an Ord constraint in the existential, too?
10:57:04 <lilac> might not even be deterministic
10:57:14 <FunctorSalad> dolio: yes
10:57:26 <dolio> Hmm, I guess that might work.
10:57:45 <FunctorSalad> say, "data T = forall a. (Typeable a, Eq a, Ord a) => T a"
10:57:46 <mauke> typeRepKey' = unsafePerformIO . typeRepKey
10:57:49 <niff> > join (*) 5
10:57:51 <lambdabot>   25
10:57:51 * lilac is still concerned about nondeterministic orderings of the TypeReps
10:57:52 <mauke> instance Ord TypeRep where
10:57:52 <mauke>     compare = compare `on` typeRepKey'
10:58:04 <lilac> Eq should be fine, though
10:58:42 <FunctorSalad> mauke: I see... didn't know the key was trapped in IO
10:59:12 <FunctorSalad> (now lilac's comment makes sense to me too)
10:59:35 <dolio> You can just compare their string representations. That wouldn't be nondeterministic.
10:59:58 <dolio> Assuming no one's done some Oleg-like mischief and made two types with the same type rep.
11:00:14 <FunctorSalad> yes, sounds better (especially if the existential type in question is package-local)
11:00:18 <mauke> what's the point?
11:00:22 <dolio> Although, in that case, they've already subverted the type system, so bad ordering is the least of your problems.
11:00:24 <mauke> typeRepKey exists and works fine
11:01:17 <FunctorSalad> mauke: the question is whether it returns the same value every time
11:01:47 <mauke> IIRC the source looks like typeRepKey x = return (...)
11:01:47 <rwbarton> I guess with compare `on` show you can double check that the TypeReps are == when the strings are and throw an error otherwise.
11:02:23 <mauke> I looked it up when I wrote this code
11:03:43 <Gracenotes> hm.. to what extent does hIsClosed :: Handle -> IO Bool perform IO?
11:04:06 <FunctorSalad> rwbarton: since I'd try the cast before comparing typeReps, that case you mention should be an "catastrophic failure" ;)
11:04:07 <Gracenotes> for, say, a socket
11:04:23 <idnar> Gracenotes: whether it's closed or not depends on I/O state
11:04:29 <Gracenotes> does it look up some Haskell-specific memory location, or does it look at the socket itself?
11:04:36 <idnar> oh
11:08:08 <Gracenotes> I'm using Chans to do IO, and I'd like to have the person calling a write/read method know if it's closed or not, not just the thread directly inputting/outputting to the Chan
11:09:25 <Gracenotes> one option is to check hIsClosed every time a read/write function that reads/writes to a Chan is called
11:09:43 <Gracenotes> but.. this might be inefficient
11:10:03 <Gracenotes> hm. Maybe I could just use an isClosed MVar?
11:10:45 <Gracenotes> that seems sane. Anyway, I need to go to class now. *bye*
11:13:07 <jpcooper> say I'm in MaybeT IO. What happens if I'd like to extract something from an IO operation?
11:13:28 <lilac> jpcooper: in Monad transformers generally, you use 'lift'
11:13:31 <lilac> @type lift
11:13:32 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
11:13:51 <lilac> @type liftIO
11:13:52 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:13:56 <jpcooper> but that will then be a IO (Maybe a) won't it?
11:14:10 <mauke> what?
11:14:16 <lilac> substituting in your types, that's...
11:14:28 <lilac> @type lift :: IO a -> MaybeT IO a
11:14:30 <lambdabot>     Not in scope: type constructor or class `MaybeT'
11:14:59 <jpcooper> so I have an IO operation, I'm inside MaybeT IO, and I won't the thing inside of the IO operation
11:15:03 <jpcooper> I guess I need to use liftIO
11:15:05 <lilac> liftIO is good when you don't expose that you've got a monad transformer, or when it's many levels deep
11:15:27 <lilac> jpcooper: then use 'lift'
11:15:32 <jpcooper> okay
11:15:34 <lilac> i repeat, lift :: IO a -> MaybeT IO a
11:15:47 <jpcooper> instance MonadTrans MaybeT where
11:15:47 <jpcooper>   lift = MaybeT . liftM Just
11:16:02 <jpcooper> I would like access while still inside MaybeT IO
11:16:03 <lilac> so it takes your IO operation (of type IO a) and produces a value of type MaybeT IO a
11:16:17 <jpcooper> okay
11:16:46 <lilac> 'lift' for MaybeT basically maps a 'Just' (== return) under the IO, producing IO (Maybe a)
11:16:54 <jpcooper> yeah sure. Thanks
11:17:31 <paolino> @src MonadTrans
11:17:32 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:19:07 <paolino> hard umorism eh
11:20:14 <lilac> paolino: i think it's 'class MonadTrans t where lift :: (Monad m) => m a -> t m a'
11:20:53 <tromp__> wiku2hgr
11:21:43 <paolino> MonadTrans is not easy for object oriented  thinking
11:29:37 <paolino> @users
11:29:38 <lambdabot> Maximum users seen in #haskell: 697, currently: 620 (89.0%), active: 10 (1.6%)
11:34:07 <ehird> Wow, a safe use of unsafeCoerce.
11:34:12 <ehird> Well, kinda.
11:35:07 <roconnor> where?
11:35:16 <ehird> ~/Code/
11:35:19 * roconnor has only seen 1, maybe 2 safe uses of unsafeCoerce
11:35:27 <ehird> I just need to figure out whether it actually is safe
11:36:04 <roconnor> the one safe use was to cast a type variable to another type variable that was known to be the same type.
11:36:12 <ehird> Uh oh, segfault.
11:36:17 <ehird> :-(
11:36:25 <ehird> roconnor: That was pretty much the use, except there was an issue :(
11:36:26 <roconnor> the other almost safe use I saw was casting to and from GHC.Any
11:36:27 <Elly> roconnor: oO
11:36:32 <tromp__> u need to use safeSegfault instead
11:36:47 <roconnor> but I'm not certain that is safe
11:37:08 <ehird> I'm basically trying to do "instance Functor ((,) t)"
11:37:15 <ehird> I'm thinking it's actually possible right now
11:37:16 <mauke> @hoogle raise
11:37:16 <lambdabot> package happraise
11:38:18 <geezusfreeek> unsafeCoerce for a standard Functor instance??
11:38:26 <ehird> Yeah.
11:38:28 <ehird> I'm rather evil.
11:38:49 <erikc> :w
11:38:55 <geezusfreeek> why on earth would you need unsafeCoerce for that?
11:38:57 <erikc> curses!
11:39:00 <skorpan> @pl \a b c d e f g h i j k l ->  l k j i h g f e d c b a
11:39:04 <lambdabot> flip (flip . ((flip . (flip .)) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .)
11:39:04 <lambdabot>  .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((
11:39:04 <lambdabot> ((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .)
11:39:04 <lambdabot>  .) .) . (((((((flip .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (
11:39:06 <lambdabot> flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) .
11:39:07 <ehird> geezusfreeek: I laugh in the face of standard semantics, sir.
11:39:09 <lambdabot> ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))))))))))
11:39:12 <lambdabot> optimization suspended, use @pl-resume to continue.
11:39:13 <ehird> Oh joy.
11:39:14 <ehird> @pl-resume
11:39:21 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .)
11:39:21 <lambdabot>  .) . (((((((((flip .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((
11:39:21 <lambdabot> flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .
11:39:23 <lambdabot> ) .) . (((((((flip .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (
11:39:26 <geezusfreeek> thank you skorpan
11:39:26 <lambdabot> flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) .
11:39:29 <lambdabot> ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))))))))))
11:39:32 <lambdabot> optimization suspended, use @pl-resume to continue.
11:39:56 <mauke> oatmeal + nail clippings
11:40:02 <Elly> don't do that :P
11:40:51 <mmorrow> flip is oatmeal?
11:40:51 <lambdabot> mmorrow: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:41:19 <Elly> mmorrow: if it isn't, your oatmeal is done wrong
11:41:25 <mmorrow> hehe
11:42:09 <hackage> Uploaded to hackage: SHA 1.0.4
11:45:47 * Badger hugs skorpan 
11:45:54 <hallongrottan> @pl get >>= \st -> writeMemory addr (xReg st)
11:45:55 <lambdabot> writeMemory addr . xReg =<< get
11:45:58 <hallongrottan> omg
11:46:12 <orroz> what do you think of clojure? in some ways i find it more practical than haskell but it is a lot less elegant.
11:46:33 <mmorrow> why more practical?
11:46:48 <mmorrow> does it compile to machine code? :)
11:46:55 <Cheshire> java machine code :p
11:47:05 * mmorrow weeps
11:48:36 <mmorrow> foreign import ccall "malloc" c_malloc :: CSize -> IO (Ptr a)   -- pretty practical (ie s/malloc/anything C/)
11:49:35 <orroz> well less IO-monad-in-the-*ss
11:49:58 <CosmicRay> orroz: what's the matter with the io monad?  I think it's one of the best features of Haskell.
11:51:30 <roconnor> @unmtl StateT s Maybe a
11:51:30 <lambdabot> s -> Maybe (a, s)
11:52:17 <orroz> it makes me want to blow my brains out
11:52:27 <ryant5000> does anyone here know of a reasonably clean way to simulate haskell-style tagged unions in C#
11:53:01 <orroz> i can isolate effects by convention, the enforcement just makes some things a royal PITA but perhaps i need more practice only
11:54:51 <geezusfreeek> once you get used to it you don't even notice that you are isolating your IO stuff anymore
11:55:00 <int80_h> I have a list of booleans. I want to iterate over them looking for EQ. What would that map look like?
11:55:06 <mmorrow> orroz: haskell eval bots can ensure security in the type system
11:55:10 <mmorrow> , print 42
11:55:11 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
11:55:17 <mauke> orroz: just write everything in IO
11:55:21 <int80_h> I mean, I'm just looking for a single EQ, as soon as I find it I can stop
11:55:29 <mauke> int80_h: EQ :/: Bool
11:55:39 <mmorrow> , readFile "/etc/passwd"
11:55:40 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO GHC.Base.String))
11:55:53 <ehird> Yikes.
11:55:55 <mmorrow> no need to hide readFile
11:56:02 <int80_h> @type EQ
11:56:04 <lambdabot> Ordering
11:56:06 <ehird> lambdabot does though :)
11:56:09 <ehird> , unsafeCoerce 2
11:56:09 <lunabot>  luna: Not in scope: `unsafeCoerce'
11:56:15 <mmorrow> > readFile
11:56:16 <lambdabot>       Overlapping instances for Show (FilePath -> IO String)
11:56:16 <lambdabot>        arising f...
11:56:21 <ehird> huh
11:56:22 <mmorrow> > readFile "/etc/passwd"
11:56:24 <lambdabot>   * Exception: "<IO [Char]>"
11:56:27 <int80_h> mauke: ah, yes of course it's tertiary, not boolean
11:56:28 <ehird> , unsafePerformIO (readFile "/etc/passwd")
11:56:29 <lunabot>  luna: Not in scope: `unsafePerformIO'
11:56:32 <mmorrow> why bother hiding it?
11:56:40 <mmorrow> without unsafePerformIO you can't use it
11:56:51 <mmorrow> (which is why hiding unsafePerformIO is crucial)
11:56:57 <mauke> int80_h: EQ `elem` list
11:57:03 <Badger> > unsafePerformIO
11:57:04 <lambdabot>   Not in scope: `unsafePerformIO'
11:57:08 <Badger> :'(
11:57:13 <mmorrow> , unsafePerformIO (print 42)
11:57:14 <lunabot>  luna: Not in scope: `unsafePerformIO'
11:57:16 <int80_h> well maybe I'm going about this problem incorrectly. right now I'm using compare
11:57:25 <mmorrow> , $(runIO (print 42))
11:57:26 <lunabot>  luna: Not in scope: `runIO'
11:57:37 <mmorrow> , runST (unsafeIOToST (print 42))
11:57:38 <lunabot>  luna: Not in scope: `unsafeIOToST'
11:57:47 <int80_h> which generates either LT,GT, or EQ. Where all I really want is True (is equal) or false (is not equal)
11:57:49 <mmorrow> (+ all equivalent formulations thereof)
11:57:50 <Elly> mmm, unsafeIOToST
11:58:02 <geezusfreeek> int80_h, use (==) instead of compare?
11:58:30 <int80_h> geezusfreeek: ah yes, I tried that but on reflection I tried incorrectly
12:04:21 <saml> > 1 2 3 4 5
12:04:23 <lambdabot>       No instance for (Num (t -> t1 -> t2 -> t3 -> a))
12:04:23 <lambdabot>        arising from th...
12:04:44 <trofi> > a b c d e
12:04:45 <lambdabot>   Couldn't match expected type `Expr -> Expr -> Expr -> Expr -> t'
12:04:54 <idnar> > f a b c d e
12:04:55 <lambdabot>   Add a type signature
12:05:01 <saml> > f x :: Expr
12:05:01 <lilac> > f a b c d e :: Expr
12:05:04 <lambdabot>   f x
12:05:04 <lambdabot>   f a b c d e
12:05:26 <saml> > f x (g x) :: Expr
12:05:27 <lambdabot>   Add a type signature
12:05:40 <lilac> > f x (g x :: Expr) :: Expr
12:05:41 <lambdabot>   f x (g x)
12:05:45 <tromp__> > [a] :: Expr
12:05:47 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
12:05:54 <lilac> > [a] :: [Expr]
12:05:55 <trofi> > [a] :: [Expr]
12:05:57 <lambdabot>   [a]
12:05:57 <lambdabot>   [a]
12:05:59 <idnar> heh
12:06:11 <lilac> > map ($x) [f,g] :: [Expr]
12:06:11 <idnar> > map ($x) [f, g, h] :: [Expr]
12:06:13 <lambdabot>   [f x,g x]
12:06:13 <lambdabot>   [f x,g x,h x]
12:06:19 <lilac> *blink*
12:06:26 <lilac> GET OUT OF MY MIND
12:06:32 <tromp__> > return a  :: [Expr]
12:06:34 <lambdabot>   [a]
12:06:36 <idnar> :D
12:06:50 <trofi> [:
12:10:20 <int80_h> [#haskell]
12:10:23 <int80_h> oops
12:10:31 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1296#a1297
12:11:02 <int80_h> having a parsing error problem, trying to use let, guards and where for the first time
12:11:17 <pumpkin> you can use a guard for a case or a function
12:11:36 <pumpkin> not sure what your intended behavior there is
12:11:43 <tromp__> @let church n f = (!!n) . iterate f
12:11:46 <lambdabot>  Defined.
12:11:51 <int80_h> using guards for a case
12:12:01 <pumpkin> you might want the guards to be in the top-level definition?
12:12:08 <tromp__> > church 15 (+2) 1
12:12:10 <lambdabot>   31
12:12:19 <kakazza> If I have a "let function bla bla" in the interpreter, how do I delete that? Or... undefine "function"
12:12:41 <tromp__> > church 66 (map pred) "|ok"
12:12:43 <lambdabot>   ":-)"
12:12:47 <int80_h> pumpkin: not sure I understand. If I'm using let ... in ..., you're saying that the guards should come before that?
12:13:16 <pumpkin> int80_h: why do you have both a let .. in and a where?
12:13:25 <pumpkin> is there  some reason for them to be separate?
12:13:35 <asgaroth> readability I guess
12:13:35 <tromp__> > church 34 (map succ) ":-)"
12:13:37 <lambdabot>   "\\OK"
12:13:47 <pumpkin> also, a guard just returning true or false
12:13:56 <pumpkin> you could just return the result of the guard
12:14:03 <int80_h> pumpkin: well I thought it was a matter of correct form. I had gotten the idea what one uses let .. in when you are binding variables, and one uses where when defining local functions
12:14:10 <pumpkin> hmm
12:14:21 <pumpkin> the last thing is that you want &&, not and, there
12:14:47 <pumpkin> @src otherwise
12:14:47 <lambdabot> otherwise = True
12:14:56 <true\false> I have a question..
12:15:04 <true\false> @t (+)
12:15:04 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:15:05 <saml> I have the answer
12:15:12 <true\false> @t +
12:15:12 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:15:16 <pumpkin> :t (+)
12:15:17 <lambdabot> forall a. (Num a) => a -> a -> a
12:15:21 <pumpkin> @type (+)
12:15:22 <lambdabot> forall a. (Num a) => a -> a -> a
12:15:43 <saml> that's why you can compose + easily:  x + y + z + ....
12:15:50 <true\false> Heh ta.. But the question is that does (Num a) specify that the type variable a must contain a type which uses Num?
12:15:50 <saml> because it's a -> a  -> a
12:16:05 <pumpkin> yes
12:16:08 <saml> a should implement operators defined by Num class
12:16:12 <mauke> true\false: a type that is a Num
12:16:16 <int80_h> pumpkin: I changed and to && and still have the parse error
12:16:27 <pumpkin> int80_h: yeah, that's because your guards are in the wrong place
12:16:31 <true\false> So do add more, is it (Num a, Eq a) => a -> [a], for example?
12:16:35 <pumpkin> int80_h: just saying that you'd encounter that error later :)
12:16:46 <mauke> true\false: yes, but Num already includes Eq
12:17:05 <int80_h> pumpkin: I'm not sure where to put them then, if not in the "in" clause
12:17:07 <true\false> mauke: Sure, but was wondering about the way to do that :)
12:17:44 <int80_h> pumpkin: am I over complicating things? Is it okay (idiomatic) to just use either where or let?
12:18:20 <saml> can lambda bot tell me which classes class C inherites from?
12:19:04 <mauke> I don't think so
12:19:06 <tromp__> you mean which classes it implies?
12:19:25 <saml> like, class (Eq a, Show a) => Num a where...
12:19:31 <augustss> int80_h: foo==True is just silly, use foo
12:19:50 <saml> so I ask lambda bot about Num... and it tells me Eq and Show.. and other classes Eq and Show inherit from
12:19:54 <tromp__> or use (foo==True)==True, to be sure
12:19:56 <asgaroth> int80_h: and you can't use guards on function applications, just on function definitions
12:20:36 <pumpkin> int80_h: I've made a change to your paste
12:20:38 <int80_h> augustss: but in this case, foo would return False, which in the test means "not composite", so I want to return True "is Prime"
12:20:39 <pumpkin> the formatting is messed up though
12:20:40 <augustss> int80_h: And isPrime = not (testOne && testTwo)
12:21:18 <augustss> int80_h: foo==True is alway superflous
12:21:32 <asgaroth> tromp__: Or `foldr ($) foo (take 100 $ repeat (==True))' to be really sure :D
12:21:36 <augustss> Why test if a Bool is true?
12:22:00 <int80_h> augustss: because it might not be ?
12:22:07 <pumpkin> int80_h: if it isn't true, what is it?
12:22:10 <saml> > if x then 1 else 2 where x = True
12:22:11 <lambdabot>   1
12:22:13 <pumpkin> false or bottom :P
12:22:23 <saml> > if x == True then 1 else 2 where x = True
12:22:25 <lambdabot>   1
12:22:26 <pumpkin> the latter case you can't do much about
12:22:28 <asgaroth> @pl if x == True then 1 else 0
12:22:29 <lambdabot> if' (x == True) 1 0
12:22:29 <int80_h> got it
12:22:59 <dolio> @check \x -> (x == True) == x
12:23:00 <lambdabot>   "OK, passed 500 tests."
12:23:05 <saml> @pl if x then 1 else 0
12:23:06 <lambdabot> if' x 1 0
12:23:33 <saml> @src if'
12:23:33 <lambdabot> Source not found. It can only be attributed to human error.
12:23:47 * asgaroth is annoyed that such an if' isn't included in the standard prelude/that it isn't the normal notation for if
12:23:54 <augustss> Me too!
12:24:05 <pumpkin> me too!
12:24:07 <pumpkin> I hate if
12:24:15 <asgaroth> saml: if' p a b = if p then a else b
12:24:20 <saml> > let if' p a b = if p then a else b  in if' True 1 2
12:24:22 <lambdabot>   1
12:24:24 <pumpkin> it could easily be a function like anything else, why give it special syntax?
12:24:38 <FunctorSalad_> precedence someone said
12:24:51 <asgaroth> someone else once said avoid parentheses
12:24:56 <asgaroth> *avoiding
12:24:58 <FunctorSalad_> :)
12:25:06 <pumpkin> there are other ways to do that which we use everywhere else :P
12:25:22 <asgaroth> exactly. that's why it's especially annoying
12:25:28 <saml> can you implement if' without if then else?
12:25:28 <ray> it's for defining if' with
12:25:34 <asgaroth> and there are tons of helpers like flip you could use with if'
12:25:46 <pumpkin> ray: or you could just use pattern matching
12:25:46 <asgaroth> saml: pattern matching
12:25:46 <augustss> saml: yes
12:25:50 <FunctorSalad_> hmm I for one like every way of avoiding parentheses and ($) we can get ;)
12:25:53 <trofi> don't like if? use case w/pattern match
12:25:59 <asgaroth> saml: if' True a _ = a; if' False _ b = b
12:26:11 <ray> pattern matching, schmattern matching
12:26:11 <tromp__> augustss, how can your basic expressions start with a number, like 10 PRINT "hi";  ?
12:26:14 <pumpkin> trofi: I do, but I'm just questioning the need to add special syntax to the language in the first place
12:26:25 <augustss> tromp__: a good question :)
12:26:36 <pumpkin> did you make a Num instance for ->?
12:26:38 <asgaroth> trofi: not much better, since it still doesn't work for things like point-less^Wfree notation and such
12:26:40 <FunctorSalad_> syntax isn't categorically a bad thing
12:26:48 <augustss> tromp__: 10 had better be a function
12:26:57 <pumpkin> FunctorSalad_: I agree, but the alternatives are perfectly good here, unlike in certain other cases
12:26:57 <FunctorSalad_> there's a reason you're not entering your code in GHC core ;)
12:27:04 <saml> > let 10 _ = 10 in 10 "hello"
12:27:06 <lambdabot>   <no location info>: Parse error in pattern
12:27:13 <FunctorSalad_> pumpkin: that's right...
12:27:21 <tromp__> so you abuse^H^H^H^H^Huse from Integral to map numbers to functions?
12:27:30 <monochrom> basic in haskell is evil
12:27:39 <tromp__> :t fromIntegral
12:27:39 <pumpkin> instance Num (a -> b) ... ?
12:27:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
12:27:41 <trofi> @hoogle Bool -> a -> a
12:27:41 <lambdabot> Control.Exception assert :: Bool -> a -> a
12:27:41 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
12:27:41 <lambdabot> Control.Parallel par :: a -> b -> b
12:27:54 <int80_h> I think basic in haskell is cute
12:27:58 <augustss> tromp__: you need an instance where fromInteger will turn the literal into a function
12:28:00 <trofi> @hoogle Bool -> m a -> m a
12:28:01 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
12:28:01 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
12:28:01 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
12:28:36 <tromp__> :t fromInteger
12:28:37 <lambdabot> forall a. (Num a) => Integer -> a
12:28:45 <augustss> tromp__: and then you need to worry about '10 PRINT X*X'
12:28:57 <FunctorSalad_> wasn't there also a plan to have syntax for "x >>= (case x1 of ....)" ?
12:29:01 <FunctorSalad_> or sth like that
12:29:03 <augustss> :t 10
12:29:04 <lambdabot> forall t. (Num t) => t
12:29:14 <FunctorSalad_> err
12:29:27 <FunctorSalad_> x >>= (\x1 -> case x1 of ...)
12:29:48 <augustss> FunctorSalad: yes, i'd like that
12:29:55 <tromp__> normal ppl would give up after realizing 10 PRINT X*X' parses as (10 PRINT X) *X'
12:30:16 <augustss> tromp__: wimps!
12:31:11 <augustss> FunctorSalad: perhaps 'case of ...'
12:31:48 <FunctorSalad_> augustss: I'm not sure I quite got it right... the suggestion was some hybrid of lambda and case
12:31:55 <trofi> >> ?
12:32:07 <augustss> FunctorSalad_: that's what I meant
12:32:36 <augustss> 'case of ...' would be '\ x -> case x of ...'
12:32:53 <FunctorSalad_> augustss: ah right, like "f = case of (Just a) -> ... ; Nothing -> ..."?
12:33:05 <augustss> yep
12:33:08 <monochrom> interesting
12:33:28 <mauke> so now I have a parser without completely understanding how it works. papers++ :-)
12:33:39 <trofi> :]
12:33:50 <FunctorSalad_> then for the monadic you could just do "g = (>>=) f" and still don't have to name the intermediate
12:34:06 <pumpkin> dons: ping
12:34:09 <doserj> multi-case lambda would also be nice. \Just a -> ...; Nothing -> ...
12:34:09 <augustss> tromp__: another good one is '10 PRINT SIN(X)'
12:34:25 <pumpkin> augustss: sounds like a nightmare :P
12:34:31 <mauke> what does PRINT PRINT do?
12:34:38 <pumpkin> augustss: now the real question is, can you make it reject nonsensical basic?
12:34:39 <augustss> type error
12:34:48 <michaelcdever> dons: forking my filesearch bypassess the too many open file errors!
12:34:53 <michaelcdever> dons: :D
12:34:57 <augustss> pumpkin: it rejects some nonsensical BASIC
12:35:05 <trofi> @pl \x -> case x of _ -> True
12:35:05 <lambdabot> (line 1, column 17):
12:35:05 <lambdabot> unexpected "_"
12:35:05 <lambdabot> expecting variable, "(", operator or end of input
12:35:42 <trofi> @pl \x -> case x of; _ -> True
12:35:42 <lambdabot> (line 1, column 16):
12:35:42 <lambdabot> unexpected ";"
12:35:42 <lambdabot> expecting variable, "(", operator or end of input
12:35:55 <Badger> lambdabot needs @basic
12:36:01 <augustss> pumpkin: with more clever type tricks you can make it reject more.  like only allowing variables after LET
12:36:09 <pumpkin> ah
12:36:13 <FunctorSalad_> it needs @basic like a... (how did it go?)
12:36:33 <FunctorSalad_> (fish needs a bicycle?)
12:36:42 <FunctorSalad_> ;)
12:36:52 <enticingjelly> any physicists here?
12:37:00 <Badger> there are undoubtedly uses to which a fish could put a bicycle
12:37:05 <FunctorSalad_> :)
12:37:23 <pumpkin> enticingjelly: I really wonder where your nick came from, but am afraid to ask
12:37:52 <Badger> pumpkin: I could say the same about you
12:37:58 <kakazza> Hi
12:38:00 <enticingjelly> does the same small pot of the same small amount of water start to boil sooner on a big stove or a small?
12:38:06 <enticingjelly> the actual cooking area
12:38:07 <pumpkin> Badger: or you ;)
12:38:16 <enticingjelly> don't know how to say that in english
12:38:21 <enticingjelly> pumpkin, eh, no, not from that %)
12:38:33 <pumpkin> :o
12:38:45 * Badger is not enticed by this jelly
12:38:56 <kakazza> How can I have this "let sequ n = if odd n then "hi" else "bye"" in a source file split to cases "sequ <odd n> = print "hi"; sequ <even n> = print "bye"?
12:39:14 <kakazza> like factorial 0 = 1; factorial n = n * factorial (n-1)
12:39:22 <ziman> kakazza, you can use guards
12:39:29 <kakazza> guards?
12:39:31 <mauke> sequ n | odd n = "hi" | otherwise = "bye"
12:39:32 <Badger> > let sequ n = if odd n then "hi" else "bye"" in a source file split to cases "sequ <odd n> = print "hi"; sequ <even n> = print "bye"
12:39:34 <lambdabot>   <no location info>: parse error on input `='
12:39:54 <Badger> aw.
12:40:12 <Badger> I totally did not read
12:40:14 <ziman> > let sequ n | odd n = n*2; sequ n | even n = n `div` 2 in (sequ &&& sequ) (3, 4)
12:40:15 <lambdabot>       No instance for (Integral (t, t1))
12:40:15 <lambdabot>        arising from a use of `sequ' ...
12:40:17 * Badger facepalms
12:40:23 <ziman> > let sequ n | odd n = n*2; sequ n | even n = n `div` 2 in (sequ *** sequ) (3, 4)
12:40:25 <lambdabot>   (6,2)
12:40:34 <kakazza> mauke - I'd love to have it in two lines, like factorial, because it's gonna be more then printing "hi" and "bye" ;)
12:40:54 <mauke> kakazza: insert a newline after "hi"
12:41:12 <kakazza> and next line begins with pipe | ?
12:41:19 <mauke> yes (indented)
12:41:50 <augustss> efficientjelly: I'd say it starts boiling soon on a big one, because there will be more radiated heat from the surrounding area hitting the pot.  But maybe this is supposed to be a trick question.
12:41:51 <FunctorSalad_> btw view patterns are also neat for avoiding cluttter - I guess they haven't caught on because of the annoying "non-exhaustive pattern" warning? ;)
12:43:11 <FunctorSalad_> I think they're good if you like to "preprocess" one of many arguments to a function
12:43:33 <FunctorSalad_> (without naming the unprocessed input)
12:44:27 <kakazza> ziman and/or mauke: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1299#a1299
12:44:27 <kakazza> ?
12:44:36 <FunctorSalad_> actually nvm my statement. I haven't read enough recent code to know whether they caught on.
12:44:52 <kakazza> ah
12:45:09 <kakazza> Didn't c&p correctly I think
12:45:12 * kakazza checks
12:45:43 <mauke> kakazza: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1299#a1300
12:46:45 <FunctorSalad> oh no disconnected
12:47:05 <kakazza> Is that a better solution than the n | odd n = foo; n | even n = bar; version?
12:47:22 <Cheshire> data Polarity = Odd | Even
12:47:58 <kakazza> Cheshire?
12:47:59 <ziman> kakazza, what i meant is: http://codepad.org/6LaKBts8
12:48:40 <kakazza> Both look pretty good, but I guess for longer code the splitting is more readable than | otherwise
12:49:01 <ziman> you can attach multiple guards to a single definition or use multiple definitions, each with a single guard
12:52:38 <kakazza> I see
12:52:41 <kakazza> Thanks
12:52:56 <kakazza> I just started with haskell a few minutes ago, so please bear with me :)
12:53:59 <kakazza> http://codepad.org/j3TRX7ly <== How would I solve that? I know it thinks the result could be a fraction since there's "n/2" but due to the guard which makes sure the number is even, the result will never be a fraction. I do know about :: Int and :: Fraction, but I don't know where to put it.
12:54:50 <pumpkin> the page isn't loading for me
12:54:54 <pumpkin> but maybe try `div` ?
12:54:58 <pumpkin> instead of /
12:56:07 <kakazza> That did the trick
12:56:19 <kakazza> what does div do? Or where in the doc would I find it?
12:56:53 <geezusfreeek> :t div
12:56:54 <lambdabot> forall a. (Integral a) => a -> a -> a
12:56:56 <geezusfreeek> :t (/)
12:56:57 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:57:21 <augustss> kakazza: use hoogle
12:57:33 <Zao> kakazza: The Report would probably be a good start.
12:57:46 <Zao> augustss: Hoogle seems rather unhelpful about div.
12:57:51 <augustss> :(
12:57:52 <geezusfreeek> @hoogle div
12:57:52 <lambdabot> Prelude div :: Integral a => a -> a -> a
12:57:52 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
12:57:52 <lambdabot> Control.Exception DivideByZero :: ArithException
12:58:00 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Adiv
12:59:09 <Zao> http://www.haskell.org/onlinereport/basic.html
12:59:12 <Zao> See 6.4.2
13:09:18 <roconnor> @type mod
13:09:19 <lambdabot> forall a. (Integral a) => a -> a -> a
13:09:30 <roconnor> @src Integral
13:09:31 <lambdabot> class  (Real a, Enum a) => Integral a  where
13:09:31 <lambdabot>     quot, rem, div, mod :: a -> a -> a
13:09:31 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
13:09:31 <lambdabot>     toInteger           :: a -> Integer
13:09:38 <roconnor> @src Real
13:09:39 <lambdabot> class  (Num a, Ord a) => Real a  where
13:09:39 <lambdabot>     toRational      ::  a -> Rational
13:13:46 <saml> > mod 1 1
13:13:48 <lambdabot>   0
13:17:54 <roconnor> @hoolge [a -> m a] -> a -> m a
13:17:54 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
13:17:54 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
13:17:54 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
13:18:45 <roconnor> @type foldr
13:18:47 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:20:18 <roconnor> > foldl [f,g] a
13:20:19 <lambdabot>   Couldn't match expected type `a -> b -> a'
13:20:43 <roconnor> > foldl f z [a,b]
13:20:44 <lambdabot>   f (f z a) b
13:21:05 <roconnor> > foldl (>>=) a [f,g]
13:21:06 <lambdabot>   Couldn't match expected type `m b' against inferred type `Expr'
13:21:16 <roconnor> @type foldl (>>=)
13:21:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
13:21:57 <roconnor> @type foldl (>>=) . return
13:21:58 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
13:22:15 <roconnor> do I really need a foldl to do what I want?
13:22:16 <tehgeekmeister> is there a prelude function that returns the nth item of a list?
13:22:27 <roconnor> > [1,2,3]!!2
13:22:27 <tehgeekmeister> or do i have to use take and drop together?
13:22:28 <lambdabot>   3
13:22:33 <roconnor> > [1,2,3]!!0
13:22:34 <tehgeekmeister> okay, thanks, forgot about that one
13:22:35 <lambdabot>   1
13:22:45 <sbahra> dons, were there CSS changes made to hackage now?
13:22:48 <sbahra> s/now/recently/
13:24:07 <sbahra> dons, http://tinypic.com/view.php?pic=2h72laq&s=5
13:25:27 <roconnor> > (foldl (>>=) . return) 0 ((const Nothing):repeat return)
13:25:47 <lambdabot>   mueval: Prelude.read: no parse
13:25:55 <roconnor> > (foldl (>>=) . return) 0 ((const Nothing):replicate 100 return)
13:25:59 <lambdabot>   Nothing
13:26:07 <roconnor> :/
13:26:14 <Cheshire> :t flip (foldl (>>=) . return)
13:26:17 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
13:27:01 <Cheshire> :t sequence . sequence
13:27:03 <lambdabot> forall a. [[a]] -> [[a]]
13:28:14 <dolio> @type foldr (>=>) return
13:28:16 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
13:28:25 <trofi> i'd like to play with XMPP in haskell. which package should i look at to implement simple transport?
13:28:36 <roconnor> > (foldr (>=>) return) 0 ((const Nothing):repeat return)
13:28:38 <lambdabot>       No instance for (Show (m [b -> Maybe b]))
13:28:38 <lambdabot>        arising from a use of ...
13:28:47 <roconnor> > (foldr (>=>) return) ((const Nothing):repeat return) 0
13:28:49 <lambdabot>   Nothing
13:28:53 <roconnor> :)
13:28:58 <roconnor> @src (>=>)
13:28:58 <lambdabot> Source not found. You type like i drive.
13:31:36 <roconnor> @hoogle (>=>)
13:31:37 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:31:46 <roconnor> @src Control.Monad.(>=>)
13:31:46 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:31:49 <dolio> , [$ty| (.) |]
13:31:53 <lunabot>  forall a b c . (c -> b) -> (a -> c) -> a -> b
13:32:29 <dolio> I don't know where src gets its stuff, but I don't think it has anything that new.
13:33:11 <dolio> @type runKleisli . foldr (>>>) (arr id) . map Kleisli
13:33:13 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
13:34:28 <tibbe> anyone managed to configure emacs and haskell-mode to always insert 4 spaces for indentation?
13:35:36 <jpcooper> is () not a bottom type?
13:36:05 <dolio> You mean you don't want it to do smart indenting.
13:36:11 <dolio> There should be a way to turn it off.
13:36:41 <roconnor> is there a foldr-map ?
13:37:04 <dolio> What do you mean/
13:37:17 <roconnor> I don't know
13:37:28 <dolio> foldr g z . map f = foldr (g . f) z (I believe) if you're talking fusion.
13:37:33 <roconnor> I just wrote (foldr f z (map g l))
13:37:42 <roconnor> it seemed odd
13:37:44 <roconnor> ah
13:37:46 <roconnor> fusion
13:38:01 <roconnor> I'll let the compiler do that
13:38:08 <Heffalump> fold build fusion should handle that one
13:38:11 <dolio> GHC probably even figures that out on its own if map is implemented correctly.
13:39:21 <dolio> @src map
13:39:21 <lambdabot> map _ []     = []
13:39:22 <lambdabot> map f (x:xs) = f x : map f xs
13:39:29 <dolio> Not like that, of course. :)
13:39:36 <sjanssen> roconnor: there isn't a foldr-map directly, but map (can become) is a build, and foldr fuses with build
13:39:47 <lepassive> I understand how this is evaluated Prelude> sq $ 2
13:39:48 <lepassive> 4 , but don't get how is that evaluated Prelude> ($ 2 ) $ sq
13:39:57 <Olathe> @type foldr
13:39:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:40:17 <sjanssen> roconnor: see GHC.Base for the gory details
13:40:23 <dolio> map f l = build (\c z -> foldr (c . f) z l)
13:40:42 <Olathe> @pl \el ac -> g (f el) ac
13:40:42 <lambdabot> g . f
13:41:14 <Gracenotes> :t (>>= return)
13:41:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
13:41:17 <sjanssen> lepassive: "($ 2)" is a function that takes a function and applies 2 to it
13:41:21 <mauke> lepassive: ($ 2) $ sq  ==>  ($) ($ 2) sq  ==>  ($ 2) sq  ==>  sq $ 2  ==>  sq 2
13:41:31 <sjanssen> lepassive: it can also be written "(\f -> f 2)"
13:42:02 <dolio> > let build :: (forall b. (a -> b -> b) -> b -> b) -> [a] ; build k = k (:) [] ; map f l = build (\c z -> foldr (c . f) z l) in map (+1) [1..10]
13:42:02 <Gracenotes> oh, duh... thanks, monad laws >_>
13:42:04 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:42:30 <jeffersonheard> ping roconnor
13:42:36 <lepassive> aha thanks sjanssen and mauke
13:42:58 <jeffersonheard> oh hey, you are there.  good.  remind me again how to convert your AlphaColour Double -> (Double,Double,Double,Double)?
13:46:22 <lepassive> @type foldl1
13:46:24 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
13:46:50 <lepassive> @src foldl1
13:46:50 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:46:50 <lambdabot> foldl1 _ []     = undefined
13:47:24 * wli will have to figure out how to do alignment directives for poly.
13:48:05 <lepassive> foldl1 doesn't start with initial value = 0, but starts with first element
13:48:39 <lepassive> how can i use src thing in GHCI ?
13:54:50 <dzrk> is partial function application a form of closure?
13:55:18 <koeien> you can think of it in that way. i never think of closures in Haskell though :)
13:55:49 <mornfall> koeien: Oh, you should, sometimes. ;)
13:56:09 <Raevel> isn't it more helpful to just think partial evaluation?
13:56:45 <lepassive> @src reads
13:56:45 <lambdabot> reads = readsPrec minPrec
13:56:56 <asgaroth> mostly importantly, don't think of it as currying, which is common mistake :)
13:57:06 <asgaroth> *a common mistake
13:57:37 <dolio> The function is already curried when you partially apply it. :)
13:57:44 <mauke> mmh, curry
13:58:22 <koeien> dolio: yeah, at least partially curried ;)
13:58:26 <Raevel> hmm, but does the currying actually occur at all?
13:59:19 <dolio> Currying is when you take a function like (a,b) -> c and give back a function a -> b -> c.
13:59:22 <Cale> Closures are an implementation detail which is not something to worry about unless you're implementing a language. Things are best understood in terms of their semantics.
13:59:35 <dolio> But most functions in Haskell are curried from the get go.
13:59:41 <Raevel> dolio: right
13:59:46 <Raevel> most, but not all, though?
13:59:54 <koeien> Raevel: you can easily make your own :)
13:59:55 <dolio> So there's no currying going on, I suppose.
14:00:00 <lepassive> is lambdabot hpaste aware ?
14:00:03 <koeien> also it doesn't make sense to speak of "currying a Int->Int"
14:00:17 <dolio> Well, it depends what you're doing.
14:00:35 <dolio> Sometimes using uncurried functions makes them easier to compose, and you can curry afterward.
14:00:54 <asgaroth> in some sense, haskell doesn't have any uncurried functions, since tuples are just a data type and not really "two parameters"
14:00:57 <dolio> Instead of doing stuff like "(((f .) .) .) . g" like people do.
14:01:10 <koeien> dolio: let f .: g = (f.) . g
14:01:30 <Raevel> until i started using haskell i had the impression that partial application was synonomous with currying :-/, i think that's a common misconception? Feels like i see it everywhere
14:01:34 <dolio> Technically those are two separate cases, really.
14:01:46 <koeien> Raevel: they are different. however curring enables partial application
14:01:48 <koeien> so they are related
14:02:06 <dolio> Uncurried functions are better when you g :: a -> (b, c) and you want to compose it with f :: (b, c) -> d or something.
14:02:22 <koeien> dolio: you cannot uncurry a -> (b,c)
14:02:37 <Raevel> i'm trying to remember how i do partial application in js
14:02:38 <koeien> oh n/m i see what you mean now
14:02:50 <dolio> Right, but it composes better with the uncurried f than with the curried f.
14:03:11 <mauke> uncurry :: (a -> (b, c)) -> ((b -> c -> d) -> d)
14:03:34 <koeien> :t uncurry
14:03:35 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:03:43 <koeien> mauke: that seems wrong
14:03:58 <mauke> @djinn (a -> (b, c)) -> ((b -> c -> d) -> d)
14:03:59 <lambdabot> -- f cannot be realized.
14:04:04 <mauke> right
14:04:11 <mauke> @djinn (a -> (b, c)) -> (a -> (b -> c -> d) -> d)
14:04:11 <koeien> no b to apply...
14:04:11 <dolio> mauke's is a combination of uncurry and (.).
14:04:11 <lambdabot> f a b c =
14:04:11 <lambdabot>     case a b of
14:04:11 <lambdabot>     (d, e) -> c d e
14:04:23 <Raevel> oh right, in js i just take the args to the first func, return a new func and then when that's executed i concat all the args together
14:04:50 <koeien> mauke: yeah you need an "a" to apply to the first function
14:05:04 <mmorrow> @pl \(a,b)->(a,a)
14:05:04 <lambdabot> join (,) . fst
14:05:09 <mmorrow> @pl \(a,b)->(b,a)
14:05:09 <lambdabot> uncurry (flip (,))
14:05:11 <mmorrow> i meant
14:05:22 <mauke> :t (snd &&& fst)
14:05:22 <mreh> can anyone think of a way to detect if/make a polygon "clockwise"
14:05:23 <lambdabot> forall a b. (a, b) -> (b, a)
14:05:32 <mmorrow> @index (&&&)
14:05:32 <lambdabot> Control.Arrow
14:05:45 <mmorrow> @index uncurry
14:05:45 <lambdabot> Data.Tuple, Prelude
14:05:48 <mmorrow> @index flip
14:05:48 <lambdabot> Prelude
14:05:50 <mmorrow> :)
14:06:14 <mmorrow> i always define a local (&&&) and (***) because  i don't want to import Control.Arrow
14:06:29 <mmorrow> (for no good reason really i guess)
14:06:58 <matthewp> Is this the best way to write a cycle using a foldr? It's about as clean as I've been able to get it
14:06:59 <matthewp> cycle' xs = foldr (:) (cycle' xs) xs
14:07:24 <mmorrow> @type fix . (++)
14:07:26 <lambdabot> forall a. [a] -> [a]
14:07:27 <Heffalump> you should bind cycle' xs to a name and use that in the recursion
14:07:30 <Cheshire> matthewp, why don't you defin (++) and then use that
14:07:41 <mmorrow> , fix . (++) $ [0..4]
14:07:43 <lunabot>  [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,...
14:07:55 <Cheshire> :t concat . repeat
14:07:57 <lambdabot> forall a. [a] -> [a]
14:08:04 <mmorrow> @type fix . (:)
14:08:06 <lambdabot> forall a. a -> [a]
14:08:15 <Cheshire> it's fun to derive fix . (++) from concat . repeat
14:08:28 <Cheshire> you get to use fixed point induction
14:08:28 <mmorrow> concat . fix . (++)
14:08:52 <matthewp> ok, thanks
14:08:54 <mmorrow> @type fix . concat . (:) . (:[])
14:08:55 <lambdabot>     Couldn't match expected type `[[a]]'
14:08:55 <lambdabot>            against inferred type `[[a1]] -> [[a1]]'
14:08:55 <lambdabot>     Probable cause: `.' is applied to too few arguments
14:09:08 <mmorrow> @type fix . (concat .) . (:) . (:[])
14:09:10 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
14:09:10 <lambdabot>       Expected type: a -> [[a]] -> [[a]]
14:09:10 <lambdabot>       Inferred type: a -> [[a]] -> [a]
14:09:17 <mmorrow> @free fix
14:09:18 <lambdabot> f . g = h . f => f (fix g) = fix h
14:10:12 <mmorrow> @type (concat .) . ((:) . (:[]))
14:10:14 <lambdabot> forall a. a -> [[a]] -> [a]
14:10:20 <mmorrow> grr
14:10:35 <int80_h> < let a = [1,2,3,4,5]
14:10:35 <mmorrow> grr/me gives up
14:10:40 <mmorrow> oops
14:10:41 <int80_h> < a
14:10:50 <int80_h> > let a = [1,2,3,4,5]
14:10:52 <lambdabot>   <no location info>: parse error on input `;'
14:10:59 <int80_h> > let a = [1,2,3,4,5] in a
14:11:01 <lambdabot>   [1,2,3,4,5]
14:11:05 <int80_h> > a
14:11:06 <lambdabot>   a
14:11:09 <Badger> a
14:11:14 <int80_h> hmm
14:11:22 <mmorrow> @type a
14:11:23 <lambdabot> Expr
14:11:34 <int80_h> > a = [1,2,3,4,5]
14:11:35 <mmorrow> it's the SimpleReflect stuff
14:11:35 <lambdabot>   <no location info>: parse error on input `='
14:11:53 <mmorrow> , foldl f z [a,b,c,d,e]
14:11:55 <lunabot>  f (f (f (f (f z a) b) c) d) e
14:12:12 <Badger> @type b
14:12:13 <int80_h> > zipWith (^) [1,2,3,4,5] [5,4,3,2,1]
14:12:14 <lambdabot> Expr
14:12:14 <roconnor> @type comparing
14:12:15 <lambdabot>   [1,16,27,16,5]
14:12:16 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:12:30 <roconnor> @hoogle (b -> a) -> b -> b -> Bool
14:12:31 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
14:12:31 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:12:31 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
14:12:51 <mmorrow> @type [concat . fix . (:), fix . (++)]
14:12:52 <lambdabot> forall a. [[a] -> [a]]
14:13:00 <hcube> is it possible to use ghc as a template haskell preprocessor? (template haskell -> haskell98 compiler)
14:13:34 * int80_h curses
14:14:37 <Cheshire> > map (zipWith (^)`ap`reverse . enumFrom 0) [1..]
14:14:39 <lambdabot>       precedence parsing error
14:14:39 <lambdabot>          cannot mix `ap' [infixl 9] and `(.)' ...
14:14:45 <Cheshire> > map ((zipWith (^)`ap`reverse) . enumFrom 0) [1..]
14:14:46 <lambdabot>   Couldn't match expected type `a -> [a1]'
14:15:02 <wli> data Mu f = Up (f (Mu f)) ; class Prj f where prj :: f t -> t ; dn :: Mu f -> Mu f ; dn (Up x) = prj x ?
14:15:38 <Cheshire> > map ((zipWith (^)`ap`reverse) . enumFromTo 0) [1..]
14:15:40 <lambdabot>   [[0,1],[0,1,1],[0,1,2,1],[0,1,4,3,1],[0,1,8,9,4,1],[0,1,16,27,16,5,1],[0,1,...
14:15:53 <mmorrow> i :: b -> a, h :: a -> b, f :: a -> b -> b, g :: b -> b -> b, g . h == f ===> h . fix . f == fix . g
14:15:54 <Cheshire> > map (tail . (zipWith (^)`ap`reverse) . enumFromTo 0) [1..]
14:15:56 <lambdabot>   [[1],[1,1],[1,2,1],[1,4,3,1],[1,8,9,4,1],[1,16,27,16,5,1],[1,32,81,64,25,6,...
14:16:16 <mmorrow> oh, and   i . h == id
14:16:23 <ra> I often get assembler error messages when I try to install a package using cabal or compile some package my self
14:16:50 <Cheshire> > map (tail . (zipWith (*)`ap`reverse) . enumFromTo 0) [1..]
14:16:51 <lambdabot>   [[0],[1,0],[2,2,0],[3,4,3,0],[4,6,6,4,0],[5,8,9,8,5,0],[6,10,12,12,10,6,0],...
14:17:11 <pejo> ra, OS/Toolchain?
14:18:08 <mmorrow> oops, i mean  i . fix . f == fix . g
14:18:11 <mmorrow> (or something)
14:18:15 <ra> Ubuntu 8.10 x86_64, gcc 4.3.2, ghc 6.8.2
14:18:37 <asgaroth> @type join
14:18:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:18:53 <mmorrow> maybe it's the 6.8.2 mangler interacting badly with gcc4.3.2-produced asm
14:18:54 <mmorrow> ?
14:18:58 <pejo> ra, all from ubuntu-packages?
14:19:15 <wli> %subst varid a = "\mathrm{" a "}" %subst conid a = "\mathsf{" a "}" %subst keyword a = "\mathit{" a "}" works nicely, though.
14:19:19 <ra> mmorrow, yes
14:20:04 <mmorrow> ra: if that's whats happening i guess your options are upgrading ghc or downgrading gcc
14:20:49 <ra> mmorrow: which version of gcc is compatible for ghc 6.8.2?
14:21:05 <kerlo> @help free
14:21:05 <lambdabot> free <ident>. Generate theorems for free
14:21:16 <kerlo> Hmm.
14:21:20 <kerlo> @free [a]
14:21:20 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
14:21:29 <kerlo> @free ((a -> b) -> a) -> a
14:21:29 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
14:21:33 <mmorrow> ra: (i'm not positive this is what's happening but..) i know at least 4.1.2 is
14:21:35 <Cheshire> @free x :: x
14:21:36 <lambdabot> f x = x
14:21:44 <kerlo> @free c :: ((a -> b) -> a) -> a
14:21:45 <lambdabot> (forall p q. g . p = q . f             =>              f (h p) = k q) => f (c h) = c k
14:21:55 <roconnor> > group []
14:21:56 <mmorrow> when was gcc-4.3.2 released?
14:21:56 <lambdabot>   []
14:22:08 <kerlo> Why all the spaces?
14:22:33 <ra> mmorrow: The error messages are not consistent
14:22:35 <mmorrow> if after ghc-6.8.2 it may very well be that some spacing/something of the asm output was changed
14:23:01 <mmorrow> the mangler is sensitive to that since it's a perl script that manipulates the asm gcc spits out :/
14:23:19 <mmorrow> (and this only happens with -fvia-C too)
14:23:36 <mmorrow> ra: i'd ask in #ghc if this is a know problem
14:23:41 <mmorrow> *known
14:24:06 <ra> mmorrow: Thanks
14:24:11 <mmorrow> np
14:25:33 <kerlo> @pl \x y -> fix x
14:25:34 <lambdabot> const . fix
14:25:48 * kerlo bows to the almighty @pl
14:26:05 <mauke> :t fmap return fix
14:26:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> a) -> m a
14:27:48 <geezusfreeek> @unpl const . fix
14:27:48 <lambdabot> (\ d _ -> fix d)
14:28:07 <mmorrow> @type fix . (return .)
14:28:09 <lambdabot> forall b (m :: * -> *). (Monad m) => (m b -> b) -> m b
14:28:14 <mmorrow> um
14:28:23 <mmorrow> @type \f -> fix (return . f)
14:28:25 <lambdabot> forall b (m :: * -> *). (Monad m) => (m b -> b) -> m b
14:28:25 * SamB_irssi wonders why google code search is interested in .xpm files -- he doesn't think those really count
14:28:31 <monochrom> (m b -> b) is very hard to provide.
14:28:31 <kerlo> @unpl fix . (return .)
14:28:31 <lambdabot> (\ d -> fix (\ g -> return (d g)))
14:28:54 <mmorrow> i'm trying to remember how to do mfix with fix + return
14:29:03 <mmorrow> (i'm not sure it's equivalent though)
14:29:11 <mmorrow> @type mfix
14:29:12 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:29:20 <kerlo> Good luck.
14:29:22 <mmorrow> heh
14:29:42 <kerlo> Hey, maybe you'll find instance Monad m => MonadFix m. :-)
14:29:43 <mauke> :t return . fix
14:29:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> a) -> m a
14:30:02 <mmorrow> @type \f -> return (fix (\x -> (=<< f x)))
14:30:04 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (Monad m1, Monad m) => (((a -> m b) -> m b) -> m a) -> m1 ((a -> m b) -> m b)
14:30:07 <mmorrow> gah
14:30:25 <grahamhutton> mmorrow: http://leventerkok.googlepages.com/mdo.pdf
14:30:28 <monochrom> mfix is usually not doable by fix + return. it has to be custom-made for the specific monad type.
14:30:41 <mmorrow> grahamhutton: cool, thx
14:30:49 <mauke> :t \f -> fix . f . return
14:30:51 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (m a1 -> a -> a) -> a1 -> a
14:31:00 <mauke> :t \f -> fix (f . return)
14:31:01 <lambdabot> forall c (m :: * -> *). (Monad m) => (m c -> c) -> c
14:31:30 <mmorrow> monochrom: yeah, iirc you could make an expression with at least the same type though with (.) + fix + return
14:31:35 <ra> mmorrow: I tried with gcc-4.1, it is still giving similar errors
14:32:01 <mmorrow> ra: hmm, i'm out of ideas. i'd definitely ask in #ghc
14:32:20 <ra> mmorrow: thnx
14:32:38 <mmorrow> :)
14:32:40 <Deewiant> ra: anything like http://hackage.haskell.org/trac/ghc/ticket/2871 ?
14:33:21 <mmorrow> @type @type \f -> fix (f =<<)
14:33:23 <lambdabot> parse error on input `@'
14:33:25 <mmorrow> @type \f -> fix (f =<<)
14:33:26 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
14:33:38 <mmorrow> that one
14:33:39 <mauke> :t fix . (=<<)
14:33:41 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
14:33:47 <mmorrow> even better
14:33:55 <Deewiant> :t fix . (>>=)
14:33:56 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
14:33:56 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
14:33:56 <lambdabot>     In the second argument of `(.)', namely `(>>=)'
14:34:18 <mmorrow> ahhh, from the paper:
14:34:20 <mmorrow> mfix (return Â· h) = return (fix h)
14:34:37 <mmorrow> (+ two other equivalences)
14:35:26 <ra> Deewiant: no, its something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1331#a1331
14:35:48 <Deewiant> ra: right, haven't seen anything like that before
14:35:51 <monochrom> fix . (>>=) would break the mfix laws usually.
14:35:57 <Deewiant> ra: file a bug I guess
14:36:28 <ra> Deewiant: ok,
14:40:04 <mmorrow> ra: whoa weird, that's definitely not the mangler
14:40:43 <leimy> should exitSuccess kill all forkIO'd threads?
14:40:52 <mauke> yes
14:40:56 <leimy> not working :-)
14:41:13 <mmorrow> wuh, when main exits the rts exits
14:41:14 <mauke> it probably throws an exception
14:41:57 <leimy> mmorrow: that could be my problem yeah.
14:42:09 <hackage> Uploaded to hackage: hyphenate 0.1
14:42:45 <grahamhutton> mmorrow: back to the mfix question, as far as I understand, there is no generic definition of mfix --- you need to define this by hand for particular instances...
14:47:55 <mmorrow> grahamhutton: interesting. i recall reading somewhere that mdo was at one point considered-for/desired-as the definition of "do"
14:48:27 <mmorrow> so if that was the case, mfix would essentially need to be in Monad?
14:48:58 <grahamhutton> mmorrow: not every monad supports mfix
14:49:00 <mauke> only if the block uses recursive bindings
14:49:31 <mmorrow> ahh, so "do" would be "mdo" only if there existed a MonadFix instance i guess was the semantics they had in mind
14:50:36 <Deewiant> kind of like it's possible to separate fail into its own class: if you use it, or pattern match in a 'do', you need the MonadFail instance, otherwise only Monad
14:50:49 <int80_h> I have a list [1,2,3] and a list [4,5,6]. I would like to multiply each element on the second list on each element on the first list [1*4,1*5,1*6,2*,2*5...] what would that look like?
14:51:04 <leimy> zipwith?
14:51:09 <int80_h> I tried using zipWith, but that didn't get me exactly what I wanted
14:51:11 <Deewiant> > [ x*y | x <- [1,2,3], y <- [4,5,6] ]
14:51:13 <lambdabot>   [4,5,6,8,10,12,12,15,18]
14:51:31 <int80_h> zipWith only multiplies pairs
14:51:34 <leimy> right
14:51:37 <Deewiant> int80_h: see above
14:51:39 <int80_h> Deewiant, that's it right there thanks
14:51:39 <leimy> you need a kind of cartesian product
14:51:41 * mmorrow wishes do := mdo-if-exists-mfix personally
14:51:52 <pumpkin> liftM/A2
14:52:06 <augustss> I'd use mdo more if it had a reasonable name
14:52:10 <mmorrow> i mean, let bindings are by default recursive... why not do too?
14:52:14 <mauke> > liftM2 (*) [1,2,3] [4,5,6] :: [Expr]
14:52:15 <lambdabot>   [1 * 4,1 * 5,1 * 6,2 * 4,2 * 5,2 * 6,3 * 4,3 * 5,3 * 6]
14:52:20 <int80_h> Deewiant, that should work with lists of unequal length right?
14:52:22 <mmorrow> augustss: yeah, like "do" ;)
14:52:24 <Deewiant> int80_h: yep
14:52:43 <Deewiant> oh, liftAn is an n-way cartesian product? cool
14:52:45 <leimy> mauke: neet
14:52:50 <leimy> er neat
14:52:51 <leimy>  :-)
14:53:18 <leimy> > liftM2 (*) [1..3] [4..6]
14:53:20 <lambdabot>   [4,5,6,8,10,12,12,15,18]
14:54:00 <osfameron> Deewiant: isn't the cartesian-product thing a consequence of it being the List monad?
14:54:08 <Deewiant> osfameron: yes
14:54:36 <mmorrow> , [$i| (,,,,) "qwert" "asdf" "jkl;" "zxcv" "12345"|]
14:54:38 <lunabot>  [('q','a','j','z','1'),('q','a','j','z','2'),('q','a','j','z','3'),('q','...
14:54:43 <Deewiant> add an implicit 'in the list monad' to the end of my statement to clarify :-)
14:54:48 <mmorrow> , [$i| (,,) "qwert" "asdf" "12345"|]
14:54:50 <lunabot>  [('q','a','1'),('q','a','2'),('q','a','3'),('q','a','4'),('q','a','5'),('...
14:55:07 <osfameron> Deewiant: heh, ok
14:55:08 <z0d> > (*) [1..3] [4..6]
14:55:10 <lambdabot>       No instance for (Num [t])
14:55:10 <lambdabot>        arising from a use of `*' at <interact...
14:55:10 <mmorrow> , [$i| (*) [1..3] [4..6] |]
14:55:12 <lunabot>  [4,5,6,8,10,12,12,15,18]
14:55:23 <Deewiant> > liftA3 (,,) [1..2] [3..4] [5..6]
14:55:25 <lambdabot>   [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
14:55:28 <Deewiant> sweet
14:55:45 <mmorrow> , [$i| (,,) [1..2] [3..4] [5..6] |]
14:55:47 <lunabot>  [(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]
14:55:51 <mmorrow> , [$i| (,,,) [1..2] [3..4] [5..6] [0..] |]
14:55:53 <lunabot>  [(1,3,5,0),(1,3,5,1),(1,3,5,2),(1,3,5,3),(1,3,5,4),(1,3,5,5),(1,3,5,6),(1...
14:55:55 <osfameron> what's that [$i|...|] syntax ?
14:56:00 <kpreid> what's this [$i| ? an implicit lift rewriter?
14:56:02 <mmorrow> liftAn via QuasiQuoter
14:56:20 <mmorrow> it's {-# LANGUAGE QuasiQuotes #-} syntax
14:56:22 <ddarius> Hacky idiom brackets ?
14:56:26 <mmorrow> heh
14:56:41 <kpreid> ah, the 'n' being the interesting part
14:56:52 <Deewiant> mmorrow: so what's i defined as
14:57:09 <mmorrow> "i" is called "vix" in haskell-src-meta since vixey suggested it, but had i known it was "idiom brackets" i'd have kept the name as "i"
14:57:31 <mmorrow> , ppDoc `fmap` (parseExp i) "(*) [1..3] [4..6]"
14:57:33 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
14:57:50 <mmorrow> , ppDoc `fmap` (quoteExp i) "(*) [1..3] [4..6]"
14:57:52 <lunabot>  ((*) <$> [1..3]) <*> [4..6]
14:58:02 <mmorrow> , ppDoc `fmap` (quoteExp i) "(,,,) [1..3] [4..6] [] []"
14:58:04 <lunabot>  ((((,,,) <$> [1..3]) <*> [4..6]) <*> []) <*> []
14:58:11 <Deewiant> , i
14:58:12 <lunabot>  luna: No instance for (GHC.Show.Show
14:58:17 <mmorrow> , [$ty| i |]
14:58:20 <lunabot>  QuasiQuoter
14:58:24 <mmorrow> , src ''QuasiQuoter
14:58:27 <lunabot>  data QuasiQuoter = QuasiQuoter {quoteExp :: (String -> Q Exp),
14:58:27 <lunabot>                                  quotePat :: (String -> Q Pat)}
14:58:30 <Deewiant> , src ''i
14:58:31 <lunabot>  luna: Not in scope: type variable `i'
14:58:33 <Deewiant> , src 'i
14:58:36 <lunabot>  i :: QuasiQuoter
14:58:40 <Deewiant> gah
14:58:41 <dolio> , [$i| ((,,,) . (+1)) [1,2] [3,4] [5] [6] |]
14:58:43 <lunabot>  luna: A section must be enclosed in parentheses thus: (+ 1)
14:58:44 <mmorrow> (src should be called "info"
14:58:45 <mmorrow> )
14:58:47 <z0d> > map (+) [1..3] [4..6]
14:58:49 <lambdabot>   Couldn't match expected type `[t1] -> t'
14:58:57 <Deewiant> dolio: bug #2956
14:59:08 <mmorrow> dolio: yeah, there's some weird bug with sections in TH
14:59:08 <kpreid> , [$ty| [$ty| 1 |] |]
14:59:09 <lunabot>  luna: parse error on input `|]'
14:59:17 <mmorrow> , [$ty| [$ty| 1 \|] |]
14:59:20 <lunabot>  Doc
14:59:21 <Deewiant> it's fixed but not released
14:59:23 <dolio> , [$i| ((,,,) . (\x -> x+1)) [1,2] [3,4] [5] [6] |]
14:59:23 <mmorrow> , [$ty| [$tyQ| 1 \|] |]
14:59:25 <lunabot>  [(2,3,5,6),(2,4,5,6),(3,3,5,6),(3,4,5,6)]
14:59:27 <lunabot>  Type
14:59:33 <mmorrow> , [$tyQ| 1 |]
14:59:36 <lunabot>  ForallT [a] [AppT (ConT Num) (VarT a)] (VarT a)
14:59:48 <mmorrow> , [$tyQ| let fix f = let x = f x in x in fix |]
14:59:50 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a)) (VarT a)))...
14:59:56 <leimy> , Control.Monad.liftM2 (Data.Monoid.mappend) (fmap Data.Monoid.Product [1..3]) (fmap Data.Monoid.Product [4..6])
14:59:57 <lunabot>  luna: Not in scope: `Data.Monoid.mappend'
15:00:02 <mmorrow> QuasiQuoters are soo cool
15:00:02 <leimy> > Control.Monad.liftM2 (Data.Monoid.mappend) (fmap Data.Monoid.Product [1..3]) (fmap Data.Monoid.Product [4..6])
15:00:03 <lambdabot>   [Product {getProduct = 4},Product {getProduct = 5},Product {getProduct = 6}...
15:00:37 <leimy> > fmap (getProduct) $ Control.Monad.liftM2 (Data.Monoid.mappend) (fmap Data.Monoid.Product [1..3]) (fmap Data.Monoid.Product [4..6])
15:00:39 <lambdabot>   [4,5,6,8,10,12,12,15,18]
15:00:54 <mmorrow> here's the source code for `i': http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/src/Language-Haskell-Meta-QQ-Vixey.html
15:01:25 <ddarius> You have a Vixey module?
15:01:31 <Deewiant> -- | Vixey's idea.
15:01:49 <mmorrow> ddarius: i didn't know "i" meant idiom until recently
15:02:06 <mmorrow> i thought it was just an arbitrary name
15:04:40 <athos> > mconcat $ map Sum [1..]
15:04:42 <lambdabot>   Sum {getSum = * Exception: stack overflow
15:04:47 <athos> :(
15:04:50 <z0d> > zipWith (+) [1..3] [4..6]
15:04:51 <lambdabot>   [5,7,9]
15:05:00 <Deewiant> > liftA2 (+) [1..3] [4..6]
15:05:02 <lambdabot>   [5,6,7,6,7,8,7,8,9]
15:10:21 <ahamay42> Hi everyone
15:10:39 <ahamay42> I've got a question about defining Exceptions in GHC
15:11:31 <ahamay42> see http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1301#a1301
15:13:18 <ahamay42> I call GHC 6.8.2 like that:
15:13:18 <ahamay42> ghc -XDeriveDataTypeable Except.hs
15:13:18 <ahamay42> And get this error:
15:13:18 <ahamay42> Except.hs:9:9:
15:13:18 <ahamay42>     Type constructor `E.Exception' used as a class
15:13:19 <ahamay42>     In the instance declaration for `E.Exception MyException'
15:13:43 <mauke> <ahamay42> I call GHC 6.8.2 like that:
15:13:48 <mauke> call GHC 6.8.2
15:13:50 <mauke> 6.8.2
15:14:08 <mauke> hmm, the zoom effect doesn't really work in IRC
15:14:23 <mauke> you need 6.10 for extensible exceptions
15:14:32 <ahamay42> i see
15:14:37 <ahamay42> thanks, I'll try that
15:15:09 <lepassive> can i query the source in GHCI ??
15:15:18 <Gracenotes> what would be more expensive -- having a True/False MVar Bool, or an empty/full MVar ()?
15:15:21 <mauke> lepassive: no
15:15:36 <Gracenotes> or if not more expensive, which would be preferred :)
15:15:41 <mmorrow> Gracenotes: they aren't isomorphic if that's what you mean
15:16:01 <ozy`> @let (<<:#) = zip
15:16:03 <lambdabot>  Defined.
15:16:09 <lepassive> mauke, hmmm is there some way around that instead of bothering lambdabot  ?
15:16:17 <ozy`> @let (%$>) = tail
15:16:20 <lambdabot>  Defined.
15:16:31 <dolio> Much more lucid.
15:16:36 <ozy`> :t (<<:#)<$>(%$>)
15:16:38 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
15:16:46 <Gracenotes> mmorrow: well, yes. But in one case I would use isEmptyMVar, in another case I would use takeMVar
15:16:48 <mmorrow> lepassive: lambdabot just has a bunch of not-necessarily-up-to-date defs for a few functions in a txt file
15:17:03 <monochrom> I think MVar Bool (empty, true, false) and MVar () (empty, ()) are different.
15:17:20 <Gracenotes> I'm basically using it as a binary countdown latch
15:17:23 <monochrom> I mean: since they're different, they're incomparable.
15:17:36 <lepassive> okay mmorrow thanks
15:17:37 <mmorrow> Gracenotes: ok, but (MVar ()) == {empty,full}, while (MVar Bool) == {empty, full&False, full&True}
15:18:00 <Gracenotes> True, False, FileNotAvailableYet :P
15:18:07 <Gracenotes> okay, MVar () it is
15:18:07 <tehgeekmeister> is there a function that does arbitrarily deep nested mapping for you?  like the equivalent of foo f = map (map (map ... (map f))) somelist
15:18:22 <pumpkin> no
15:18:35 <int80_h> how do I operate on negative exponents? ex. 2^-1
15:18:38 <pumpkin> what type would it have?
15:18:40 <mmorrow> with TH there is :)
15:18:40 <augustss> ^^
15:18:43 <tehgeekmeister> right
15:18:46 <tehgeekmeister> that makes sense
15:18:50 <int80_h> if I try 2^(-1) I get a complaint in ghci
15:18:54 <tehgeekmeister> didn't think about the type
15:18:58 <pumpkin> > 2 ^^ (-1)
15:18:58 <augustss> > 2^^(-1)
15:19:01 * mmorrow finds the paste
15:19:01 <lambdabot>   0.5
15:19:01 <lambdabot>   0.5
15:19:17 <Gracenotes> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1224
15:19:27 <Gracenotes> a Flatten typeclass
15:19:29 <mmorrow> oh nice, it's in lunabot
15:19:37 <ddarius> @hackage DeepArrow
15:19:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/DeepArrow
15:19:47 <mmorrow> , $(fmaps 6) (*2) [[[[[[42]]]]]]
15:19:49 <lunabot>  [[[[[[84]]]]]]
15:19:56 <Gracenotes> you can have arbitrary-level list nesting, but with a couple of language extensions
15:19:59 <mmorrow> i'll paste it
15:20:18 <mmorrow> it's just doing a foldr with (.) and fmap
15:20:32 <Gracenotes> hm.
15:21:01 <macron> hey mmorrow, any public haskell-src-meta version control repo I can make patches against?
15:21:02 <Gracenotes> either way, the above hpaste provides a means of doing it without TH, though it's still hacky :)
15:21:31 <Gracenotes> , $(fmaps 6) (*2) [[[[[[42]]]],[10]]]
15:21:33 <lunabot>  luna: No instance for (GHC.Num.Num [[[a]]])
15:21:46 <augustss> Nothing is as hacky as TH
15:21:47 <tehgeekmeister> yeah, i was just wondering because i find myself doing map (map (map f)) semi often
15:21:50 <tehgeekmeister> or something like that
15:21:52 <Gracenotes> , $(fmaps 6) (*2) [[[[[[42]],[[10]]]],[]]]
15:21:52 <augustss> Almost
15:21:54 <lunabot>  [[[[[[84]],[[20]]]],[]]]
15:22:10 <tehgeekmeister> to do the equivalent of a nested loop in other languages
15:22:23 <tehgeekmeister> oh maybe the list monad would make that easier?  *thinks
15:22:36 <tehgeekmeister> no because that wouldn't preserve the nesting
15:22:38 <tehgeekmeister> and i need to
15:23:14 <Gracenotes> tehgeekmeister: nested loops in other languages is a lot closer to (map (map (map (map f)))) than (maps f) :)
15:23:19 <mmorrow> tehgeekmeister: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1302
15:23:27 <augustss> tehgeekmeister: iterate map f !! 3
15:23:35 <ozy`> hey, if any TM users are in here, I just committed the haskell bundle patches I've been making lately
15:23:49 <augustss> hmmm, the types wont work
15:23:50 <mmorrow> , ppDoc `fmap` fmaps 8
15:23:52 <monochrom> I think (map (map (map f))) is not that bad.
15:23:52 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
15:24:06 <mmorrow> , $(fmaps 8) (*2) [[[[[[[[42]]]]]]]]
15:24:09 <lunabot>  [[[[[[[[84]]]]]]]]
15:24:16 <tehgeekmeister> mmorrow: that is TH, isn't it?
15:24:21 <mmorrow> , $(fmaps 10) (*2) [[[[[[[[Node [42] []]]]]]]]]
15:24:23 <lunabot>  [[[[[[[[Node {rootLabel = [84], subForest = []}]]]]]]]]
15:24:31 <kerlo> , Sure sounds like Template Haskell.
15:24:32 <lunabot>  luna: Not in scope: data constructor `Sure'
15:24:34 <mmorrow> tehgeekmeister: yes, you can't type that in hindley milner
15:24:38 <Gracenotes> > let applyN = foldr (.) id . replicate in applyN 5 (*2) $ 10
15:24:39 <lambdabot>   Couldn't match expected type `[a -> a]'
15:24:46 <Saizan> ozy`: haskell bundle?
15:24:50 <Gracenotes> hm :/ I always mess up that idiom
15:24:59 <tehgeekmeister> i think i'll just keep writing map map map map map.  =P
15:25:10 <tehgeekmeister> (fortunately i rarely need to nest that deeply.)
15:25:21 <Gracenotes> > let applyN n f = foldr (.) id $ replicate n f in applyN 5 (*2) $ 10
15:25:22 <lambdabot>   320
15:25:37 <Gracenotes> > 10 * (2^5)
15:25:39 <lambdabot>   320
15:25:53 <mmorrow> oh, also fmaps isn't repeated application
15:26:05 <mmorrow> i think i misunderstood what you wanted
15:26:07 <kerlo> @type fmap fmap fmap fmap fmap
15:26:09 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
15:26:15 <ozy`> Saizan: in Textmate
15:26:17 <mmorrow> @type fmap . fmap . fmap . fmap . fmap
15:26:18 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) a b (f4 :: * -> *). (Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (
15:26:18 <lambdabot> f3 (f4 b))))
15:26:25 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1296#a1303
15:26:31 <ozy`> Saizan: forgot to expand the acronym :p
15:26:36 <int80_h> having problem using map with ^^
15:26:50 <int80_h> trying it out in ghci works fine, but not when I apply it in a function
15:26:50 <kerlo> @type let x = x fmap in x
15:26:51 <lambdabot>     Occurs check: cannot construct the infinite type:
15:26:51 <lambdabot>       t = ((a -> b) -> f a -> f b) -> t
15:26:51 <lambdabot>     Probable cause: `x' is applied to too many arguments
15:26:57 <int80_h> I get a type error I can't quite explain
15:27:24 <Elly> @hoogle [a] -> [[a]]
15:27:24 <lambdabot> Data.List inits :: [a] -> [[a]]
15:27:24 <lambdabot> Data.List tails :: [a] -> [[a]]
15:27:24 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
15:27:29 <Elly> aha, that's where it was
15:27:41 <Saizan> ozy`: oh, i've read it as TH, i really need those new glasses
15:28:15 <ehird> @type let x = fmap x in x
15:28:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
15:28:16 <lambdabot>       Expected type: a -> b
15:28:16 <lambdabot>       Inferred type: f a -> f b
15:28:40 <ehird> @type \xs -> fix (flip fmap xs)
15:28:42 <lambdabot> forall a b. (a -> a) -> a -> b
15:29:34 <ddarius> Doesn't look very terminatey.
15:31:03 <Elly> someone did a neat trick once to get subsets not to contain many copies of []
15:31:06 <Elly> but I don't remember what it was
15:31:15 <Elly> I'm using: concats . map tails . inits
15:31:26 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1296#a1303
15:31:41 <int80_h> having trouble using ^^ with map in a function
15:31:57 <int80_h> works fine for my in ghci, but I've got a type error I can't figure out
15:32:53 <int80_h> oh wait I've got the problem
15:33:32 <int80_h> list if Doubles
15:33:34 <int80_h> of
15:34:33 <monochrom> "No instance for (Num ((a -> b -> a) -> Int -> Integer))"  that's awesome :)
15:35:05 <int80_h> I don't understand that. I just figured out by manually trying out the code
15:35:29 <int80_h> hmm, my solution didn't work out
15:35:51 <int80_h> I tried to fix things by changing the type def of isPrime to Double -> Bool
15:36:13 <int80_h> monochrom: what's a good solution to this?
15:36:17 <monochrom> Usually wrong number of parameters or silly typos.
15:36:23 <mauke> or missing parens
15:36:27 <mauke> also, == True is redundant
15:37:03 <int80_h> monochrom: oh, this isn't really a type mismatch?
15:37:28 <mauke> 1 `mod` n? o_O
15:37:34 <int80_h> wel, I tried map(2(^^)) r, and that didn't work either
15:37:40 <monochrom> Suppose you intend "sin 0 + 0" but you're drunk and you mistype:
15:37:42 <monochrom> > sin + 0
15:37:44 <mauke> int80_h: that's the same thing
15:37:44 <lambdabot>       No instance for (Num (a -> a))
15:37:44 <lambdabot>        arising from the literal `0' at <...
15:37:52 <mauke> er, not quite
15:37:59 <mauke> it makes 2 even more functiony
15:38:00 <monochrom> Then you get "no instance for (Num blahblah)"
15:38:24 <Saizan> int80_h: what's the type of farctorsof2 ?
15:39:15 <int80_h> coming up with that...
15:39:40 <mauke> you will get better error messages if you use more type signatures
15:40:47 <Saizan> ?type (^^)
15:40:49 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
15:41:56 <Saizan> oh wait
15:42:03 <Saizan> the error doesn't belong to the code.
15:42:09 <int80_h> ack
15:42:09 <hackage> Uploaded to hackage: regex-tdfa 0.97.3
15:42:11 <mib_zvo312> having a function of type IO (), how can I use that function and capture output its's output in a file ?
15:42:21 <mauke> mib_zvo312: what output?
15:42:29 <Saizan> the error is from map (2 (^^)) which is what makes the inferrer think 2 should be a function
15:42:32 <mauke> (also, IO () is not a function)
15:42:39 <mib_zvo312> the output of the function
15:42:45 <mauke> mib_zvo312: output to where?
15:43:01 <Saizan> map (2^^) looks fine, and should give a saner error, if any
15:43:07 <mib_zvo312> it evaluates and print message to screen
15:43:19 <mib_zvo312> i want to write then to file
15:43:26 <mauke> it depends on how it prints them to the "screen"
15:43:28 <int80_h> I'm getting new errors with mod, all of a sudden
15:44:01 <mib_zvo312> i thins with print
15:44:49 <mib_zvo312> the function is verboseCheck
15:45:13 <mib_zvo312> how can i save the printings to this one to file ?
15:45:36 <int80_h> Saizan type of factorsof2 is factorsof2 :: (Integral a) => a -> (Int, a)
15:46:37 <int80_h> Saizan: so, setExp2r  = map (2^^) r should work?
15:47:02 <Apocalisp> What do you call the (Arrow a) => (a b c) where (a b _) is the identity functor?
15:47:14 <monochrom> > map (2^^) [3,1,4,1,5]
15:47:16 <lambdabot>   [8.0,2.0,16.0,2.0,32.0]
15:47:29 <int80_h> monochrom: yeah it works fine in the interpreter
15:47:39 <monochrom> I would impeach r.
15:47:55 <mauke> I'd use more type signatures
15:48:03 <Saizan> int80_h: give us the error about that code
15:48:06 <int80_h> okay adding type signatures
15:48:15 <monochrom> r came from s. s came from m. m came from factorsof2. I would impeach factorsof2.
15:48:21 <int80_h> Saizan: okay posting, then adding type sigs
15:48:32 <int80_h> impeach?
15:48:39 <monochrom> (Usual law for management: impeach he who is absent from the meeting!)
15:48:41 <int80_h> kick it out of office?
15:48:49 <monochrom> s/Usual/Useful/
15:49:25 <monochrom> impeach /= kick out.  kick out is just a consequence.
15:50:12 <int80_h> Saizan: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1296#a1304
15:50:45 <mauke> argh
15:50:55 <roconnor> rwbarton: it's tempting to represent rotations by their covering space, and restrict the interface so you can only ask about rotations.  That way, question about the covering space could be added to the interface later.
15:51:06 <mauke> isPrime n = not (testOne && testTwo)
15:51:06 <roconnor> rwbarton: I'm not sure if that works out though.
15:51:34 <int80_h> mauke: changing that now
15:51:41 <Saizan> ?type (^)
15:51:43 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:51:43 <roconnor> warning, unused variable n
15:51:46 <Saizan> ?type (^^)
15:51:48 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
15:51:48 <int80_h> mauke: was focused on other problems
15:52:00 <Saizan> int80_h: the result of (^^) is a Fractional
15:52:16 <monochrom> haskell is hard :)
15:52:17 <Saizan> int80_h: but you're using that list where it must contain Integer
15:52:37 <monochrom> > map (2^) [ 3::Integer, 1, 4 ]
15:52:39 <lambdabot>   [8,2,16]
15:52:47 <Saizan> int80_h: because n :: Integer and elem :: Eq a => a -> [a] -> Bool
15:53:17 <Saizan> so, what monochrom said :)
15:53:45 <int80_h> what, "haskell is hard"? ;)
15:53:59 <Botje> let's go shopping!
15:54:10 <monochrom> let's troll #haskell
15:54:14 <Saizan> oh, wait the Integer constraint comes from factorsof2 (n -1) actually
15:54:27 <Saizan> int80_h: use ^ instead of ^^
15:54:56 <int80_h> Saizan: but what if I have an exp that is negative?
15:55:14 <mauke> then you better convert your integers to fractions
15:55:20 <int80_h> Saizan: I did some tests, I may run into negative exponents
15:55:31 <Saizan> int80_h: then you can't use Integer..
15:55:49 <int80_h> would I use Double or Fractional?
15:56:06 <Saizan> well, both.
15:56:16 <Saizan> Fractional is a class, and Double is an instance of it
15:56:21 <int80_h> I need to be able to hold numbers as big as 50000000000
15:56:44 <Saizan> > 50000000000 :: Double
15:56:45 <lambdabot>   5.0e10
15:57:04 <mauke> use Rational :-)
15:57:15 <int80_h> okay
15:58:15 <int80_h> someone said debugging Haskell consists largely of solving type puzzles
15:58:19 <int80_h> I concur
15:58:59 <int80_h> nap time
15:59:09 <int80_h> then I'll convert to Rational
15:59:28 * int80_h has a Rational conversion experience
16:00:24 <roconnor> rwbarton: oh.  I guess if you want to take the difference of two orientations, then there isn't a unique element in the covering space to pick. hmm
16:03:04 <int80_h> < 1::Rational ^ (-2::Rational)
16:03:15 <int80_h> > 1::Rational ^ (-2::Rational)
16:03:16 <lambdabot>   <no location info>: parse error on input `-'
16:03:27 <int80_h> > 1::Rational ^ ((-2)::Rational)
16:03:28 <lambdabot>   <no location info>: parse error on input `-'
16:03:32 <int80_h> ugh
16:03:37 <int80_h> parse error?!
16:04:33 <int80_h> > 1::Rational ^ ((2)::Rational)
16:04:34 <lambdabot>   <no location info>: parse error on input `Rational'
16:04:50 <Saizan> > (1::Rational) ^ ((2)::Rational)
16:04:51 <lambdabot>       No instance for (Integral Rational)
16:04:52 <lambdabot>        arising from a use of `^' at...
16:05:03 <Saizan> > (1::Rational) ^^ ((2)::Rational)
16:05:05 <lambdabot>       No instance for (Integral Rational)
16:05:05 <lambdabot>        arising from a use of `^^' a...
16:05:11 <Saizan> gah
16:05:15 <Saizan> > (1::Rational) ** ((2)::Rational)
16:05:16 <int80_h> indeed
16:05:16 <lambdabot>       No instance for (Floating Rational)
16:05:16 <lambdabot>        arising from a use of `**' a...
16:05:24 <dystopianray> is there opengl support for haskell?
16:05:38 <Saizan> > (1::Rational) ^^ ((2)::Integer)
16:05:40 <lambdabot>   1%1
16:05:45 <Saizan> > (1::Rational) ^^ ((-2)::Integer)
16:05:46 <lambdabot>   1%1
16:05:55 <Saizan> > (4::Rational) ^^ ((-2)::Integer)
16:05:57 <lambdabot>   1%16
16:06:01 <int80_h> ah!
16:06:12 <mauke> > 4 ^^ (-2) :: Rational
16:06:13 <lambdabot>   1%16
16:06:27 <int80_h> good, okay enough for now. I'll pick this up later
16:06:35 <int80_h> Rational seems to be the way to go
16:08:44 <jeffersonheard> ping roconnor
16:09:04 <ozy`> dystopianray: yep
16:09:19 <dystopianray> awesome
16:09:32 <ozy`> dystopianray: http://www.haskell.org/haskellwiki/Opengl
16:10:48 <pumpkin> what's a good package for getting utf8 output from a String?
16:11:42 <roconnor> jeffersonheard: ack
16:12:13 <jeffersonheard> roconnor:  remind me again how to get the color components from an AlphaColour?
16:12:31 <jeffersonheard> The necessary functions seem to be in Data.Colour.Internal
16:12:33 <roconnor> ya, sorry about the lack of documentation about that.
16:12:38 <beelsebob> pumpkin: utf8-string?
16:12:41 <roconnor> step 1, composite on black
16:12:56 <roconnor> er
16:13:09 <pumpkin> @hackage utf8-string
16:13:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
16:13:09 <roconnor> step 0, check if alpha channel is 0, if so, return black
16:13:14 <roconnor> step 1, composite on black
16:13:19 <jeffersonheard> right
16:13:24 <pumpkin> beelsebob: thanks :)
16:13:31 <roconnor> step 2, darken by the reciprocal of the alpha channel
16:13:34 <jeffersonheard> then "darken" by the reciprocal of the alpha chanel?
16:13:56 <jeffersonheard> then toSRGB
16:14:00 <jeffersonheard> for Cairo
16:14:01 <jeffersonheard> k
16:14:06 <roconnor> then you have a Colour, and you can do what you'd like
16:14:14 <roconnor> toSRGB for cairo is what I recommend
16:14:36 <jeffersonheard> gah.  one day we will have to have a pure library using a consistent colorspace for vector graphics
16:14:42 <roconnor> you can use (mzero :: Colour a) instead of black if you don't feel like importing the name black
16:14:48 <jeffersonheard> OpenGL is based on linear color, yes?
16:14:55 <jeffersonheard> iirc
16:15:12 <roconnor> i'd recommend linear colour for most OpenGL uses
16:15:19 <roconnor> but maybe not all openGL uses.
16:19:39 <jeffersonheard> k
16:19:40 <jeffersonheard> thanks
16:19:42 <jeffersonheard> that was what I needed
16:23:23 <mmorrow> a SKI QQ
16:23:25 <mmorrow> , [$ski|SIKI|]
16:23:27 <lunabot>  K :$ I
16:23:41 <mmorrow> , [$ski|SIKI(SKIS(KIS)IK)SKISIK|]
16:23:43 <lunabot>  (((((((K :$ I) :$ (((S :$ I) :$ I) :$ K)) :$ S) :$ K) :$ I) :$ S) :$ I) :$ K
16:24:02 <mmorrow> , [$ski|SIII|]
16:24:04 <lunabot>  I
16:24:17 <ozy`> @index :$
16:24:18 <lambdabot> bzzt
16:24:23 <ozy`> @hoogle :$
16:24:23 <lambdabot> Parse error:
16:24:23 <lambdabot>   --count=20 :$
16:24:23 <lambdabot>              ^
16:24:25 <mmorrow> , src '(:$)
16:24:28 <lunabot>  data SKI = ... | (:$) SKI SKI | ...
16:24:28 <lunabot>  infixl 9
16:24:34 <mmorrow> , src ''SKI
16:24:36 <lunabot>  data SKI = S | K | I | SKI `(:$)` SKI
16:24:45 <mmorrow> heh, prettyprinter fail
16:24:56 <ozy`> whoops
16:25:12 <Gracenotes> :$
16:25:42 <Pseudonym> You don't have B, C and the primed versions?
16:25:52 <ozy`> I unwittingly used (:$) to mean "cons" in a lisp interpreter
16:26:01 * ozy` better change it to something else
16:26:02 <Apocalisp> What is "the constant arrow"?
16:26:23 <mmorrow> here's the src to the "SKI" module http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1306#a1306
16:26:53 <mmorrow> Pseudonym: good point, i should add those
16:27:20 <Pseudonym> The other thing is, you could use phantom types to make this type-correct.
16:27:50 <mmorrow> tell that to @pl ;)
16:27:55 <mmorrow> hehe
16:28:27 <mmorrow> that would be cool though
16:29:24 <mmorrow> oh, i almost forgot the coolest part:
16:29:27 <mmorrow> , (\e -> case e of [$ski|SIII|] -> True; _ -> False) I
16:29:30 <lunabot>  True
16:29:44 <mmorrow> it simplifies and double-parses for pattern context
16:29:53 <mmorrow> so you match against the result
16:30:07 <Shimei> I got my Real World Haskell! :D
16:30:31 <Shimei> Strangely enough, amazon.ca had something like a $20 discount.
16:31:29 <ozy`> > let infixr + 5 in 3 + 1 + 2
16:31:30 <lambdabot>   <no location info>: parse error on input `5'
16:31:45 <mmorrow> > let infixr 5 + in 3 + 1 + 2
16:31:46 <ozy`> d'oh
16:31:47 <lambdabot>   Not in scope: `+'
16:31:51 <mmorrow> grr
16:31:58 <ozy`> heh, it redefines it?
16:32:05 <mmorrow> interesting
16:32:09 <mmorrow> > let (+) = (+); infixr 5 + in 3 + 1 + 2
16:32:24 <lambdabot>   thread killed
16:32:25 <mmorrow> > let (+) = (Prelude.+); infixr 5 + in 3 + 1 + 2
16:32:27 <lambdabot>   6
16:32:31 <ozy`> awesome
16:32:52 <mmorrow> that is pretty cool
16:33:08 <mmorrow> now if only we could make data decls in lets
16:33:19 <ozy`> yeah that'd be pretty awesome
16:33:30 <mmorrow> totally
16:34:49 * roconnor sighs
16:35:04 <roconnor> I can't even cut an paste within openoffice calc
16:35:30 <beelsebob> roconnor: look at it this way â€“ at least it can draw a line graph
16:35:34 <beelsebob> (unlike apple's numbers)
16:35:44 <roconnor> :)
16:37:50 <beelsebob> the devs on apple bug reporter told me that this *is not* a bug... http://www.cs.kent.ac.uk/people/rpg/tatd2/lc.png
16:37:53 <beelsebob> o.O
16:40:16 <ozy`> beelsebob: you mean the way it's labeled?
16:40:37 <beelsebob> no, the fact that it's not a line chart
16:40:43 <beelsebob> (line charts have two continues axes)
16:40:51 <steven_ashley> Hi guys, I am having a little bit of trouble defining and implementing a type-class. I've managed to reduce it to a two liner.
16:40:51 <steven_ashley> class Escapable a where escape :: Escapable b => a -> b
16:40:52 <steven_ashley> instance Escapable Int where escape = id
16:41:03 <beelsebob> it's a bar graph, that they've drawn the bars wrong on
16:41:24 <ozy`> beelsebob: ah, that's weird
16:42:49 <steven_ashley> The error I get is, Couldn't match expected type `b' against inferred type `Int'. `b' is a rigid type variable bound by the type signature for `escape'. Expected type: Int -> b. Inferred type: Int -> Int.
16:43:39 <ozy`> beelsebob: is it different in the '09 version?
16:43:44 <steven_ashley> the Escapable b => constraint should be satisfied as Escapable Int is instantiated
16:43:47 <beelsebob> ozy`: nope
16:43:54 <ozy`> beelsebob: well... damn.
16:43:58 <steven_ashley> and I am out of ideas :(
16:44:02 <beelsebob> ozy`: I filed the bug even before numbers existed (it's existed in keynote since 2003)
16:44:16 <Cale> steven_ashley: It sounds like you've given something a type signature which is more polymorphic than the implementation you gave.
16:44:33 <Cale> steven_ashley: What type is inferred when you comment out the type signature
16:44:34 <Cale> ?
16:44:50 <Cale> steven_ashley: oh, I missed your actual code
16:44:58 <Cale> steven_ashley: yes, that's sort of the problem
16:45:02 <beelsebob> ozy`: as I said according to them it's "correct behavior"
16:45:25 <Cale> steven_ashley: id isn't capable of turning an Int into *anything* Escapable.
16:46:23 <Cale> steven_ashley: By the type signature you gave, an implementation of escape for Int would have to be capable of turning an Int into any other instance of Escapable, including, say, Char, if there were an instance for that.
16:46:45 <steven_ashley> ahh sure, I see
16:47:08 <steven_ashley> is there a way of specifying it will turn it into 'Some' instance of escapable, but you don't know which one?
16:47:23 <Cale> You could create an existential type...
16:47:28 <beelsebob> steven_ashley: using type families would sort it
16:47:46 <steven_ashley> cheers guys :)
16:47:52 <Cale> Or multiparameter typeclasses
16:48:00 <beelsebob> class Escapable a where {type b; escape :: Escapable b => a -> b}
16:48:01 <Cale> class Escapable a b where
16:48:07 <Cale>   escape :: a -> b
16:48:14 <Cale> instance Escapable Int Int where
16:48:17 <Cale>   escape = id
16:48:36 <beelsebob> instance Escapable Int where {type b = Int; escape = id }
16:48:48 <Cale> beelsebob: Is that really correct notation?
16:48:53 <beelsebob> Cale: I think so, yeh
16:49:00 <Cale> I would have thought it was:
16:49:08 <beelsebob> oh, no
16:49:09 <Cale> class Escapable a where
16:49:13 <Cale>   type E a
16:49:15 <beelsebob> the b bit is rather bullshit
16:49:18 <Cale>   escape :: a -> E a
16:49:24 <beelsebob> yeh, that one ;)
16:49:25 <Cale> instance Escapable Int where
16:49:30 <Cale>   type E Int = Int
16:49:42 <beelsebob> sorry, brain fail
16:49:45 <Cale>   escape = id
16:51:11 <sjanssen> preflex: seen dcoutts_
16:51:11 <preflex>  dcoutts_ was last seen on #haskell 6 hours, 48 minutes and 53 seconds ago, saying: the/they [in orwel]
16:51:13 <sjanssen> preflex: seen dcoutts
16:51:13 <preflex>  dcoutts was last seen on #ghc 14 hours, 11 minutes and 37 seconds ago, saying: mm, yes, fairly clear
16:52:00 <cpfr> Hey is there a nice way to load haskell code at runtime
16:52:09 <cpfr> I found hs-plugins and hs-src-exts
16:52:31 <cpfr> but I think I would rather just a nice way to eval what parseFile from hs-src-exts gives me
16:52:35 <toliko_smoren> hey, is there a way to do something x times using a HOF?
16:53:30 <cpfr> toliko_smoren, does that action have side-effects?
16:53:48 <sjanssen> toliko_smoren: for monadic actions, there is replicateM
16:53:53 <toliko_smoren> not using monads
16:54:06 <toliko_smoren> no side-effects
16:54:15 <sjanssen> for functions, you can do something like iterate f x !! n
16:54:21 <cpfr> try the functions repeat and take
16:54:39 <sjanssen> or possibly foldr (.) id (replicate n f)
16:54:49 <sjanssen> cpfr: replicate is better than take n . repeat x
16:55:19 <toliko_smoren> thanks, trying to not use recursion as much
16:55:24 <cpfr> sjanssen, is there an optimization I am missing?
16:55:52 <roconnor> @src replicate
16:55:52 <lambdabot> replicate n x = take n (repeat x)
16:56:02 <sjanssen> cpfr: no, it's just shorter
16:56:08 <sjanssen> > replicate 3 'x'
16:56:10 <lambdabot>   "xxx"
16:56:17 <sjanssen> > take 3 $ repeat 'x'
16:56:18 <cpfr> sjanssen, oh ok
16:56:18 <lambdabot>   "xxx"
16:56:34 <ozy`> > iterate map
16:56:35 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
16:56:35 <lambdabot>        Expect...
16:56:45 <ozy`> > iterate map (+ 1)
16:56:46 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
16:56:46 <lambdabot>        Expect...
16:56:50 <ozy`> right
16:57:26 <sjanssen> > iterate (map (+1)) [1, 2] -- will work
16:57:27 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12...
16:57:28 <cpfr> > iterate $ map (+1)
16:57:30 <lambdabot>       Overlapping instances for Show ([a] -> [[a]])
16:57:30 <lambdabot>        arising from a use...
16:57:55 <ozy`> ahhhh
16:58:05 <ozy`> > map
16:58:06 <lambdabot>       Overlapping instances for Show ((a -> b) -> [a] -> [b])
16:58:06 <lambdabot>        arising ...
16:58:54 <cpfr> sjanssen, any idea about my question
16:59:09 <ozy`> now, why would there be any Show instances at all for a function?
16:59:15 <ozy`> what wizardry is this?
16:59:29 <sjanssen> cpfr: which question?
16:59:43 <cpfr> Hey is there a nice way to load haskell code at runtime
16:59:52 <sjanssen> ozy`: it's so we can get nice output like <Int -> Int> in lambdabot
16:59:56 <ozy`> ah
17:00:00 <ozy`> > (+)
17:00:01 <lambdabot>       Overlapping instances for Show (a -> a -> a)
17:00:01 <lambdabot>        arising from a use ...
17:00:06 <ozy`> psshhf
17:00:06 <sjanssen> cpfr: I think GHC's API is what people use nowadays
17:00:14 <sjanssen> cpfr: hint is a wrapper around that
17:00:17 <ozy`> > (+) :: Int -> Int
17:00:18 <lambdabot>   Couldn't match expected type `Int'
17:00:26 <ozy`> d'oh
17:00:29 <ozy`> > (+) :: Int -> Int -> Int
17:00:30 <lambdabot>       Overlapping instances for Show (Int -> Int -> Int)
17:00:30 <lambdabot>        arising from ...
17:00:40 <sjanssen> ozy`: yeah, I think somebody broke it at some point
17:00:40 * ozy` gives up
17:00:59 <sjanssen> > return () :: IO () -- does this still work?
17:01:01 <lambdabot>   * Exception: "<IO ()>"
17:03:59 <Markus--> Hello dear Haskell users
17:04:05 * lispy does not like the multiline lambdabot error messages
17:04:09 <Markus`> is anybody here who can help me please?
17:04:10 <lispy> Hello Markus`
17:04:16 <Markus``> one moment please
17:04:27 <Markus``> i have to choose a nickname which isnt registered.
17:04:37 <Markus``> ok fine. Hello Lispy
17:04:50 <Markus``> i have a little problem;-) and i need some help with Haskell, can you help me?
17:05:16 <lispy> Your best bet is to just ask away
17:05:26 <lispy> if I can't help, maybe someone else will chime in
17:05:27 <ozy`> "Markus{}" and "[M]ark[us]" are always popular choices
17:05:37 <lispy> People here are pretty responsive and helpful I find
17:05:47 <Markus``> iam an Computerscience student from germany and i'm already familiar with some programminglanguages like Java or C++ ...
17:05:56 <lispy> [M]arkus, big M, little arkus
17:06:02 <Markus``> tomorrow iam actually writing my exams in so called "formal methods"
17:06:04 <Botje> Markus``: good, you have a lot to unlearn
17:06:29 <Markus``> and i'd heared today from my friend that we need some tiny haskell skills to write some stupid functions like "min max" etc
17:06:53 <Markus``> and iam absolutely new to haskell, never used it and never will i think ... i simply need some help the get familiar with the syntax like
17:07:00 <Markus``> "how to declare functions etc"
17:07:03 <pumpkin> o.O
17:07:07 <Botje> Markus``: uh. you can't learn haskell in a day
17:07:08 * SamB_XP curses Botje for having a keyboard that was plugged in
17:07:11 <Markus``> can anyone help me here with this? i think we wont need so much time
17:07:13 <ozy`> Markus``: well. you've got a lot of work ahead of you.
17:07:20 * SamB_XP wanted to say that about the unlearning
17:07:24 <Botje> people have tried it, they're still trying to get the skull fragments out
17:07:26 <Markus``> please dont take it wrong, i dont need to learn haskell
17:07:32 <ozy`> Markus``: http://www.willamette.edu/~fruehr/haskell/evolution.html
17:07:35 <SamB_XP> Markus``: what do you need to use it for ?
17:07:36 <pumpkin> Markus``: neither did I :)
17:07:37 <SamB_XP> ozy`: heh
17:07:45 <Markus``> i simply need some small informations
17:07:54 <Botje> Markus``: work through the first few chapters of learn you a haskell or YAHT
17:07:55 <SamB_XP> Markus``: what for?
17:08:03 <Markus``> its for my exam tomorrow
17:08:08 <Botje> you can skim them in half an hour
17:08:14 <Botje> why did you find this out only today?
17:08:15 <Markus``> we get some weak excercises with a few points for them
17:08:26 <Markus``> well , my friend told me today hehe , i was pretty sure we dont need it
17:08:32 * SamB_XP tests something
17:08:42 <Markus``> its something simple about haskell  we simply need some functions like ...
17:08:43 * SamB_XP tests something again
17:08:44 <Botje> you weren't the least bit curious about this "haskell" thing?
17:08:50 <ozy`> Markus``: seriously, look over http://www.willamette.edu/~fruehr/haskell/evolution.html
17:08:51 <Markus``> well a bit :D
17:08:55 <ozy`> Markus``: and then read LYAH
17:08:59 <Markus``> thanks for the Link ozy :)
17:09:00 * SamB_XP tests something again
17:09:15 * pumpkin tests SamB_XP
17:09:17 * SamB_XP tests something again after having pressed okay
17:09:18 * pumpkin tests SamB_XP again
17:09:18 <Markus``> but i hoped to get some faster help instead of reading endless tutorials t.t
17:09:20 <lispy> an hour with learn you a haskell or RWH (both found online) and you'll be rock'n the exam I bet
17:09:21 <ozy`> Markus``: if your head starts to explode you can stop reading at any point
17:09:24 <Markus``> i have only a few questions....
17:09:31 <ozy`> Markus``: okay, ask away
17:10:16 <ozy`> (the link I posted is just a lot of examples of the kind of things you'll see in haskell code)
17:10:17 <Markus``> OK, can someone of you write me an example function called "minAndMax" which gets a tuple of two Ints (Int, Int) and returns a pair which is sorted with the min at the front, and the max at the end?
17:10:38 * SamB is tempted to try involving HList somehow
17:10:51 <sjanssen> Markus``: we will not be doing your homework for you
17:11:07 <Markus``> sjanssen its not a homerwork
17:11:23 <Markus``> iam simply searching a fast solution where i can extract the complete synthax ;)
17:11:47 <Markus``> but i was already afraid that its going to be interpreted like "hey can somebody do my homework for me"
17:11:51 <Botje> (uncurry (\a b -> if a > b then (,) else flip (,)) (1,2)) (1,2)
17:12:02 <Botje> have fun.
17:12:11 <cpfr> Botje++
17:12:12 <lispy> > let mam (x,y) = (min x y, max x y) in (mam (1,2), mam (2,1))
17:12:14 <lambdabot>   ((1,2),(1,2))
17:12:14 <Markus``> intressting
17:12:18 <Botje> heh, it's even bugged :]
17:12:24 <Botje> should be a < b
17:12:39 <Markus``> iam looking actually for a simpler solution hehe.. without using functions from libs
17:12:50 <Botje> Markus``: mine doesn't use functions from libs
17:12:56 <sjanssen> Markus``: okay, so you do understand that what you ask seems like a homework question.  I think the most efficient way for you to pick up the basics of Haskell is to run through 'Learn You A Haskell' quickly
17:13:09 <cpfr> Markus``, I think you should learn the Prelude
17:13:11 <Markus``> iam doing it already
17:13:15 <Botje> okay, maybe i lied.
17:13:19 <Markus``> but thats a good idead
17:13:20 <Markus``> -d
17:13:24 <Markus``> the Prelude lib
17:13:33 <Gracenotes> hmm... you mean sorting ((a, b), (c, d)) as if it were [a, b, c, d], but maintaining the tuple structure?
17:13:47 <Botje> join (\(a,b) -> if a < b then (,) else flip (,)) (a,b)
17:14:00 <cpfr> minMax looks a bit like partition
17:14:37 <Markus``> OK found what i need in the Prelude.hs
17:14:49 <Markus``> but you guys can tell me maybe something offtopic
17:14:49 <lispy> > let mam (x,y) = (head (groupBy (<) [x,y]), tail (groupBy (<) [x,y]))
17:14:51 <lambdabot>   <no location info>: parse error on input `;'
17:15:05 * wli remembers that he's lost his implementations of CSSD and CWP. (CPO-STV could be interesting.)
17:15:05 <lispy> > let mam (x,y) = (head (groupBy (<) [x,y]), tail (groupBy (<) [x,y])) in (mam (1,2), mam (2,1))
17:15:07 <lambdabot>   (([1,2],[]),([2],[[1]]))
17:15:16 <Markus``> are you developing some software with Haskell or are you simply fascinated from this language and use it in your free time to program some random stuff?
17:15:28 <Botje> Markus``: yes and yes :)
17:15:42 <lispy> > let mam (x,y) = (head (sort [x,y]), tail (sort [x,y])) in (mam (1,2), mam (2,1))
17:15:43 <Markus``> cool cool Botje, in which business are you working?
17:15:44 <lambdabot>   ((1,[2]),(1,[2]))
17:15:51 <Botje> oh, i'm still a student
17:15:51 <Markus``> 5 +5
17:15:53 <Markus``> _Ü
17:15:55 <Markus``> :D
17:15:56 <Botje> but i'm writing a trading sim
17:15:59 <Botje> in haskell
17:16:00 <roconnor> @type runMaybeT
17:16:01 <lambdabot> Not in scope: `runMaybeT'
17:16:09 <Markus``> intresting
17:16:17 <ozy`> Markus``: if you want to try out a line of code, precede it with "> "
17:16:26 <ozy`> > cycle "DESU "
17:16:27 <cpfr> Botje, TAC?
17:16:28 <lambdabot>   "DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU...
17:16:44 <FunctorSalad> ^^
17:16:49 <lispy> > cycle "Badger " ++ "Snake!"
17:16:51 <lambdabot>   "Badger Badger Badger Badger Badger Badger Badger Badger Badger Badger Badg...
17:17:16 <lispy> I'm sure it will get to snake eventually
17:17:40 <Botje> cpfr: what? :)
17:17:42 <Markus``> maybe you can explain me by the way what exactly "Int -> Int -> Int" means :)?
17:17:54 <Botje> Markus``: read some tutorials first, please
17:18:01 <Botje> Int -> Int -> Int is a type.
17:18:03 <Markus``> maybe a dumb question for ya, but its the same like some funny questions i get from my students when i teach them in c++
17:18:10 <Markus``> OK
17:18:20 <lispy> :t id
17:18:22 <lambdabot> forall a. a -> a
17:18:23 <cpfr> Botje, http://www.sics.se/tac/page.php?id=1
17:18:24 <Markus``> i'll come back to you if there is something confusing me, in tutorials
17:18:29 <mfp> @pl join (\(a,b) -> if a < b then (,) else flip (,))
17:18:29 <lambdabot> join (uncurry (flip flip (flip (,)) . flip flip (,) . (if' .) . (<)))
17:18:29 <ozy`> Markus``: "Int -> Int -> Int" describes a function from two Ints to another Int.
17:18:34 <Botje> that would be good, yes :)
17:18:48 <lispy> it also describes a function from Int to a function that is from Int to Int
17:18:49 <ozy`> Markus``: it's written with two (->)s because it's curried
17:18:57 <FunctorSalad> > (\x -> show (show x) ++ show x) " preceeded by its quotation is not a meme"
17:18:59 <lambdabot>   "\"\\\" preceeded by its quotation is not a meme\\\"\"\" preceeded by its q...
17:18:59 <lispy> Int -> Int -> Int is the same as Int -> (Int -> Int)
17:19:00 <Botje> cpfr: hmm, i was thinking more like ports of call or high seas trader
17:19:01 <ozy`> lispy: well if it's curried, they're the same thing :p
17:19:04 <Botje> something with boats :)
17:19:12 <FunctorSalad> err or something
17:19:30 <lispy> > fix show
17:19:32 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:19:50 <Gracenotes> is there any reason why an "hPutStr" to a socket Handle might not work..? I've tried (putStrLn line >> hPutStr sock (line ++ "\r\n")), and it prints to stdout but doesn't send anything to the socket. I can read from the socket just fine.
17:20:20 <FunctorSalad> hFlush sock?
17:20:20 <Botje> @src hPutStr
17:20:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:20:24 <sjanssen> Gracenotes: how do you know that no data is sent through the socket?
17:20:30 <Gracenotes> wireshark
17:20:47 <FunctorSalad> (I never used sockets in haskell but hFlush always seems to be the answer)
17:20:48 <sjanssen> Gracenotes: the problem is most likely buffering (stdout is LineBuffering, the socket is probably buffering by size)
17:20:55 <Gracenotes> and also because I've connected the program to a simple TCP server
17:20:57 <Axman6> marko: Int -> Int -> Int says that this is a function which takes an int, and returns a function from Int -> Int, which will then take an int and return an int
17:21:14 <saml> :t (->)
17:21:15 <lambdabot> parse error on input `->'
17:21:16 <Gracenotes> sjanssen: ah... that's most definitely the problem
17:21:26 <Axman6> uh, Markus``, not marko
17:21:27 <ozy`> :t (\t -> t)
17:21:28 <lambdabot> forall t. t -> t
17:21:31 * Gracenotes tries hSetBuffering
17:21:56 <Axman6> > show . fix $ show
17:21:58 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:22:03 <iagoabal> does anyone knows a good solution when you have a computation formed with a number of subcomputations super = do sub1; sub2..., super is stateful but you don't want that sub* can change the state (only should read it)
17:22:18 <augustss_> gracenotes: hFlush
17:22:24 <Axman6> @check (show . fix $ show) == (fix show)
17:22:38 <Axman6> o.O
17:22:52 <jasondew> anyone know how to "install the profiling libraries" for the GD bindings?
17:22:53 <Botje> iagoabal: you could use an explicit evalstate to start a new subcomputation
17:23:06 <Botje> that wouldn't affect the current state
17:23:18 <Botje> OR you use the reader monad for sub*
17:23:18 <Markus``> ok guys i'll be right back ...
17:23:19 <ozy`> :t \t -> (. t $)
17:23:24 <Axman6> jasondew: cabal install <name-of-package> -p?
17:23:25 <lambdabot> parse error on input `)'
17:24:09 <Gracenotes> augustss_: thanks :D hSetBuffering also works... although I'm interested in keeping buffering for reading the socket, so hFlush it is
17:24:14 <SamB> @free fix
17:24:23 <lambdabot> f . g = h . f => f (fix g) = fix h
17:24:36 <SamB> @free show
17:24:45 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Show a) => a -> String\n"
17:24:51 <lispy> SamB: hey now!  no free shows!
17:24:57 <SamB> lispy: hah
17:25:00 <SamB> @free shows
17:25:01 <FunctorSalad> @free fail
17:25:07 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Show a) => a -> String -> String\n"
17:25:13 <lambdabot> Expected variable or '.'
17:25:13 <ozy`> > cycle [()]
17:25:16 <iagoabal> Botje, now I'm using only the reader monad, because the state only changes in each call to super, is like a counter of iterations made, so I have something like super = sub1; sub2; ...; local (+1) super
17:25:17 <lispy> ?free beer
17:25:23 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:25:25 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
17:25:36 <lispy> No such thing as free beer I guess
17:25:52 <Botje> evalstate would be my guess, then
17:25:55 <lispy> ?free cycle
17:25:56 <lambdabot> $map f . cycle = cycle . $map f
17:25:57 <lunabot>  luna: parse error on input `='
17:26:12 <SamB> hah
17:26:18 <mmorrow> ,  (\x -> [$ski|S[(,)][id][x]|]) 42
17:26:18 <lambdabot> mmorrow: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:26:20 <lunabot>  (42,42)
17:26:25 <iagoabal> Botje, the problem with evalState is that is concrete for State, but local is valid for any MonadReader ;/
17:26:30 <shapr> yow!
17:26:34 <iagoabal> I'm working with monad interfaces
17:26:37 <mmorrow> , [$ski|SIK[\x->x]I|]
17:26:39 <lunabot>  ((\x -> x) :$ K :$ \x -> x) :$ I
17:26:40 <lispy> shapr: yo!
17:26:49 <shapr> y0 lispy
17:26:52 <SamB> mmorrow: are you trying to anger ski ?
17:26:54 <FunctorSalad> @free (\x -> (\f -> f x))
17:26:55 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
17:27:02 <mmorrow> SamB: yes!
17:27:03 <roconnor> ``but local is valid for any MonadReader'', because MonadReader in the MTL is broken?
17:27:05 <lispy> FunctorSalad: congrats
17:27:14 <mmorrow> heh, true i guess that lights him up everytime ..
17:27:19 <jasondew> @Axman6 thanks; runhaskell Setup configure -p worked great
17:27:20 <lambdabot> Unknown command, try @list
17:27:22 <FunctorSalad> lispy: did I break it? :(
17:27:38 <Gracenotes> @free runState
17:27:39 <Axman6> no worries
17:27:39 <lambdabot> Plugin `free' failed with: /tmp/ghc25834_0/ghc25834_59.hspp:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
17:27:41 <lispy> FunctorSalad: pretty effectively I'd say
17:27:52 <Gracenotes> @free negate
17:27:54 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Num a) => a -> a\n"
17:28:01 <lispy> ?free (+)
17:28:01 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
17:28:04 <iagoabal> roconnor, some misunderstanding with my English?
17:28:07 <shapr> Sounds like free is having a bad day.
17:28:09 <shapr> @hpaste
17:28:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:28:11 <roconnor> iagoabal: nope
17:28:14 <lispy> ?free map
17:28:15 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
17:28:18 <roconnor> iagoabal: ignore me
17:28:31 <roconnor> @unmtl ReaderT e (Cont r) a
17:28:31 <lambdabot> e -> (a -> r) -> r
17:28:43 <roconnor> @unmtl ContT r (Reader e) a
17:28:43 <lambdabot> (a -> e -> r) -> e -> r
17:28:55 <Gracenotes> it seems @free isn't really free... with it comes the price of rejection
17:28:57 <Botje> oh, boo
17:30:38 * roconnor tries to figure out what local does to ContT r (Reader e)
17:31:55 <dolio> It's cool. You can implement state with it.
17:33:21 <alatter> @unmtl ContT e (RWS r w s) a
17:33:21 <lambdabot> (a -> r -> s -> (e, s, w)) -> r -> s -> (e, s, w)
17:33:23 <mmorrow> heh, how by some combo of local + callCC or something?
17:34:00 <saml> > local + callCC
17:34:02 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
17:34:02 <lambdabot>        Exp...
17:34:07 <roconnor>     local f m = ContT $ \c -> do
17:34:09 <roconnor>         r <- ask
17:34:10 <roconnor>         local f (runContT m (local (const r) . c))
17:34:16 <dolio> > let get = ask ; put a = callCC (\k -> local (const a) (k ())) in runReader (runContT (do a <- get ; put (a + 1) ; b <- get ; return (a,b)) return) 5
17:34:18 <lambdabot>   (5,6)
17:34:26 <mmorrow> nice
17:34:30 <roconnor> the "local (const r)" seems unusual
17:34:46 * mmorrow adds that to his haskell ircbot one-liner file
17:35:04 <dolio> Well, you could take modify as primitive.
17:35:15 <dolio> Then it's modify f = callCC (\k -> local f (k ()))
17:35:22 <dolio> And put a = modify (const a)
17:35:47 <ozy`> :t (%)
17:35:48 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
17:36:04 <roconnor> dolio: that seems unsettling
17:36:05 <mmorrow> > let get = ask ; put = modify . const; modify f = callCC (\k -> local f (k ())) in runReader (runContT (do a <- get ; put (a + 1) ; b <- get ; return (a,b)) return) 5
17:36:07 <lambdabot>   (5,6)
17:36:09 <mmorrow> hehe
17:36:51 <mmorrow> @unmtl ContT r (Reader e) a
17:36:51 <lambdabot> (a -> e -> r) -> e -> r
17:36:56 <roconnor> I was wondering if it was okay to have MonadReaders where the environment can change.
17:37:00 <mmorrow> oh nice, it's just CPS state
17:37:07 <mmorrow> (with a flip)
17:38:25 <dolio> @unmtl ReaderT e (ContT r) a
17:38:26 <lambdabot> err: `ContT r a' is not applied to enough arguments, giving `/\A. (A -> a r) -> a r'
17:38:35 <dolio> @unmtl ReaderT e (Cont r) a
17:38:35 <lambdabot> e -> (a -> r) -> r
17:38:41 <mmorrow> http://moonpatio.com/repos/monad-cps/src/Control/Monad/CPS/S.hs
17:39:01 <Axman6> :t (^)
17:39:02 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:39:06 <lepassive> How is F# compared to Haskell ?
17:39:11 <roconnor> what was the paper about what functions are okay to have in monad transformers?
17:39:13 <Axman6> > 0.5^8
17:39:14 <lambdabot>   3.90625e-3
17:39:16 <Gracenotes> lepassive: carefully
17:39:27 <ozy`> lepassive: haskell is cooler :p
17:39:29 <Axman6> > (1/16) ^ 8
17:39:31 <lambdabot>   2.3283064365386963e-10
17:39:32 <mmorrow> roconnor: what do you mean by "ok"?
17:39:51 <lepassive> ozy`, yes much cooler than OCaml :P
17:39:54 <lispy> lepassive: F# has strict evaluation and lacks type classes but in some regards it is quite similar
17:40:26 <iagoabal> I thought F# is like a MS-Caml :P
17:40:29 <dolio> Does F# not have the usual ML first class modules?
17:40:36 <Gracenotes> Workflows are like spacesuits...
17:40:45 <mmorrow> sml is the coolest ml imho
17:40:46 <ozy`> dolio: nope
17:40:49 <lispy> dolio: I don't know the answer to that one
17:40:53 <mmorrow> they all have ugly syntax though
17:40:54 <lepassive> lispy, I thought MS took haskell and added some terrible features and repackaged it as F#
17:40:57 <ozy`> dolio: it uses the .NET module system
17:40:57 <dolio> That's kind of a significant loss.
17:41:01 <lispy> dolio: but the researcher who started F# has all the features of F# listed on his web site
17:41:07 <mmorrow> ozy`: ugh
17:41:13 <lispy> lepassive: not at all, they started with OCaml
17:41:26 <ozy`> lepassive: no, F# is pretty much ocaml with the serial numbers filed off
17:41:39 <Gracenotes> eh. So the pattern matching syntax is the same as OCaml?
17:41:47 <dolio> Although their first class patterns are neat.
17:41:56 <dolio> Active patterns? Is that what they're called?
17:41:59 <ozy`> it adds some neat features to try to be like haskell, but it's still more like an ocaml/C# hybrid
17:42:02 <lepassive> Hmmm then why MS is supporting haskell and is taking over OCaml work ?
17:42:06 <lispy> Gracenotes: as far as I can tell yes, including the lack of multiple pattern matches on a line
17:42:39 <lispy> Gracenotes: But, I'm not an F# expert, nor I have looked at it recently
17:42:39 <ozy`> lepassive: consider for a moment that MS is a ridiculously big company.
17:42:52 <roconnor> mmorrow: there was a paper about what property monad transformer operations ought to have.
17:43:02 <ozy`> lepassive: in other words, the right hand doesn't necessarily know what the left hand is doing
17:43:33 <lepassive> ozy`, :D
17:43:54 <iagoabal> ozy`, or perhaps they don't want monad headaches
17:43:56 <iagoabal> ;P
17:44:02 <roconnor> modular monad transformers
17:44:07 <iagoabal> in .Net
17:44:34 <ozy`> iagoabal: exactly the opposite... half the people at MS seem to have decided at some point that monads are the best thing since sliced bread
17:44:44 <mmorrow> roconnor: hmm, i'll have to read it. it seems to me that "ought to have" is meaningless without qualification
17:44:52 <ozy`> so monads are taking over all .NET right now... very slowly.
17:44:59 <ozy`> *all of
17:45:25 <mmorrow> (but judging from the title i guess the qualification is "for them to be \"modular\" in the sense of how it's defined in this paper")
17:45:25 <iagoabal> ozy`, I can see the face of any java/C# programmer when see monads the first time
17:45:31 <Gracenotes> ozy`: eventually we shall a programming language where entire programs are monads! mwahahaha!
17:45:35 <Gracenotes> oh wait...
17:45:37 <Gracenotes> :)
17:45:48 <roconnor> mmorrow: in order to automatically be able to lift a monad operation it needs to be special
17:45:51 <iagoabal> but caml-like is more near
17:46:01 <iagoabal> and easy to learn
17:46:22 <lepassive> iagoabal, I took SCJD/MCAD and when I read about Monads just said bleh :D
17:46:25 <mmorrow> roconnor: ok, so that's how modular is defined. i think monadLib either does this or almost does this.
17:46:33 <Saizan> roconnor: btw, there was an implementation of that somewhere, do you have a link?
17:46:53 <roconnor> mmorrow: local isn't part of a ReaderM in monadLib.  It is part of RunReaderM
17:46:55 <Saizan> i can't find it anymore
17:46:56 <redditbot> Agate â€“an Agda-to-Haskell compiler
17:47:06 <mmorrow> roconnor: ok, i don't know monadLib particulars
17:47:16 <roconnor> Saizan: All I have http://www.cs.nott.ac.uk/~mjj/publications.html#mmt
17:47:29 <mmorrow> anyways, that's what monadLib strives for from what i understand
17:48:12 <iagoabal> lepassive, the ammount of tutorials etc trying to explain monads are a good measure of they are hard to understand for the most part of people
17:48:27 <Saizan> ?hackage mmt -- perhaps?
17:48:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mmt -- perhaps?
17:48:27 <roconnor> mmorrow: oh, interesting.  "local" is a nice operation.
17:48:42 <roconnor> mmorrow: which suggests it ought to be part of the ReaderM signature.
17:48:44 <cads> @hoogle (a -> b -> c) -> ((a, b) -> c)
17:48:44 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
17:48:44 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
17:48:44 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
17:48:57 <cads> ya mon1
17:49:00 <cads> !*
17:49:09 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mmtl <- here it is
17:49:19 <mmorrow> roconnor: yeah, i think there are some differing opinions on how the monadLib classes/etc could best be structured
17:49:24 <lepassive> iagoabal, I agree. the hard part is to understand how simple they are
17:49:37 <cads> type signatures are the dog's cojones :)
17:50:05 <mmorrow> roconnor: i built haddocks (w/ src links!) for the darcs monadLib as of around last week: http://moonpatio.com/docs/monadLib-4/
17:50:28 <mmorrow> it has some changes over the hackage one (notably shift and reset)
17:50:40 <mmorrow> not sure what else though..
17:50:51 <iagoabal> lepassive, they are simple, but I know lot of people that have difficults to understand higher order functions
17:51:06 <iagoabal> so, imagine monads
17:51:40 <roconnor> mmorrow: RunReaderM et al. have more general signatures now
17:52:21 <roconnor> not sure I understand why
17:52:23 <mmorrow> interesting. i know glguy was trying to make it so that shift/reset could be lifted through anything, maybe that's related
17:52:42 <iagoabal> well, not just the concept, but any simple "trick" using it
17:52:48 <mmorrow> Saizan: that mmtl pkg looks interesting
17:54:18 <Saizan> mmorrow: the point is that you no longer need to write lifting instances
17:54:30 <mmorrow> Saizan: that's lovely
17:54:50 <Gracenotes> hm... it seems that, in Parsec, the 'string' function consumes the characters that are matched, even if the rest of the current parser fails
17:55:02 <mmorrow> Gracenotes: use ReadP :)
17:55:10 <Gracenotes> so string "parse" <|> string "pat" will fail :/
17:55:19 <Saizan> yeah
17:55:30 <Saizan> you need "try" to get fair backtracking
17:55:36 <Gracenotes> yeah, I am using try
17:55:37 <roconnor> @type tell
17:55:38 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
17:55:46 <mmorrow> , readP_to_S (string "parse" +++ string "pat") "pattern"
17:55:47 <lunabot>  [("pat","tern")]
17:55:51 <Gracenotes> choice $ map try [my stuffs]
17:55:54 <Saizan> try (string "parse") <|> string "pat" will match "pat"
17:56:03 <cads> > length $ filter (\x -> (uncurry gcd x)==1) $ ranged 10 100 where ranged a b = [(a+k,b-k)|k<-[0,a-b]]
17:56:04 <lambdabot>   0
17:56:06 <mmorrow> roconnor: oh, also lunabot has the darcs monadLib in scope if you want to mess with it
17:56:14 <cads> > length $ filter (\x -> (uncurry gcd x)==1) $ ranged 10 100 where ranged a b = [(a+k,b-k)|k<-[0,b-a]]
17:56:15 <roconnor> oh nice
17:56:16 <lambdabot>   0
17:56:35 <cads> doh
17:56:37 <cads> > length $ filter (\x -> (uncurry gcd x)==1) $ ranged 10 100 where ranged a b = [(a+k,b-k)|k<-[0..b-a]]
17:56:39 <lambdabot>   32
17:56:41 <cads> whee.
17:57:10 <mmorrow> , runId . runContT return $ shift (\k -> k 42 >>= k >>= k) >>= return . (*2)
17:57:11 <lunabot>  336
17:57:34 <mmorrow> , runId . runContT return $ callCC (\k -> k 42 >>= k >>= k) >>= return . (*2)
17:57:36 <lunabot>  84
17:57:51 <Gracenotes> mmorrow: what is this readP you speak of :X?
17:58:20 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Text-ParserCombinators-ReadP.html
17:58:27 <Gracenotes> the matches aren't as simple as string foo <|> string bar, though
17:59:08 <mmorrow> with ReadP you just do:  fmap choice parsers
17:59:11 <mmorrow> oops
17:59:14 <mmorrow> choice parsers
17:59:33 <mmorrow> choice = foldr (+++) pfail
17:59:41 <mmorrow> which is
17:59:48 <mmorrow> foldr mplus mzero
17:59:58 <mmorrow> msum i guess
18:00:03 <pumpkin> is pfail like phail?
18:00:11 <mmorrow> totally
18:00:25 <pumpkin> foldr (epic) pfail
18:00:30 <mmorrow> heh
18:00:36 <pumpkin> don't need them paren
18:00:37 <pumpkin> s
18:00:49 <Gracenotes> okay.. so are there any character combinator/primitives? :)
18:00:58 <mmorrow> Gracenotes: no
18:01:23 <mmorrow> Gracenotes: parsek (which is what ReadP is a stripped version of) does have the parsec interface though
18:01:55 <mmorrow> http://www.augustsson.net/Darcs/Parsek/
18:02:37 <mmorrow> i think that parsek has the parsec shell duplicated verbatim
18:02:48 <mmorrow> (except there's no `try' of course)
18:04:22 <Gracenotes> that is pretty neat. Sequential parsing with try works too, though
18:04:47 <Gracenotes> so many ways to do nondeterminism, so little time
18:04:53 <mmorrow> ReadP has (<++) for that if desired
18:05:14 <mmorrow> (s/ReadP/Parsek/)
18:05:24 <mmorrow> ((they're the same thing underneath)
18:05:25 <mmorrow> )
18:05:41 <cads> how should I most easily express the notion of the range (a, b) as including the integers between, but not including, a and b?  Something more elegant than  ex-range a b = [x|x <- [ceiling a.. floor b], x != a, x != b]
18:05:53 <mmorrow> the fundamental difference is that parsec searches depth-first, which ReadP/Parsek is breadth-first
18:06:02 <mmorrow> s/which/while/
18:06:47 <Ralith> cads: use ceiling a + 1, floor b - 1
18:06:47 * mmorrow disappears
18:06:50 <Ralith> perhaps?
18:07:10 <Gracenotes> > let blah a b = [(floor a)+1 .. (ceiling b-1)] in blah 1.5 7.5
18:07:12 <lambdabot>   [2,3,4,5,6,7]
18:07:22 <Gracenotes> > let blah a b = [(floor a)+1 .. (ceiling b-1)] in blah 1 7
18:07:23 <lambdabot>   [2,3,4,5,6]
18:07:48 <cads> Gracenotes:  Nioce!
18:07:49 <Gracenotes> also, if they're integers, you don't need floor or ceiling :)
18:07:52 <Ralith> Gracenotes: you might want to make it consistent
18:07:52 <cads> yep
18:07:53 <wli> Breadth-first parsers sound rather useful.
18:07:57 <Ralith> i.e. (ceiling b)-1
18:08:01 <Ralith> rather than (ceiling b-1)
18:08:08 <Gracenotes> er, yeah, right
18:08:15 <Gracenotes> > let blah a b = [(floor a)+1 .. (ceiling b)-1] in blah 1.5 7.5
18:08:17 <lambdabot>   [2,3,4,5,6,7]
18:08:19 <Gracenotes> my mistake
18:08:22 <cads> that's great, I hadn't thought of taking the floor of a
18:08:37 <pumpkin> > let blah a b = [(floor a)+1 .. (ceiling b)-1] in blah 1 7
18:08:39 <lambdabot>   [2,3,4,5,6]
18:08:40 <pumpkin> tada
18:08:45 <cads> wonderful!
18:08:45 <pumpkin> the precedence is the same
18:08:56 <Gracenotes> congrats, pumpkin! That's almost what I just had! :D :D :D
18:09:07 <pumpkin> Gracenotes: I copied and pasted from what you had :P
18:09:09 <cads> (floor x) + 1 = floor (x+1)
18:09:18 <Gracenotes> except, again, if they're integers, don't take the floor or ceiling
18:09:20 <Gracenotes> :t floor
18:09:21 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
18:09:25 <pumpkin> was just showing that those parens don't change anything
18:09:28 <Gracenotes> floor expects its argument to be a RealFrac
18:09:30 <cads> anyways, I'm sooo close now, to solving euler problem 202
18:09:37 <wli> You could, for instance, attempt typechecking on various parse trees and reject the ones that fail to typecheck.
18:09:47 <Gracenotes> > let blah a b = [(floor a)+1 .. (ceiling b)-1] in blah (1::Int) (7::Int)
18:09:48 <lambdabot>       No instance for (RealFrac Int)
18:09:48 <lambdabot>        arising from a use of `blah' at <...
18:09:52 <Gracenotes> cads: you see, this fails
18:10:08 <Gracenotes> > let blah a b = [a+1 .. b-1] in blah (1::Int) (7::Int)
18:10:09 <wli> Closer to DWIM that way. ;)
18:10:09 <lambdabot>   [2,3,4,5,6]
18:10:12 <Gracenotes> tada.
18:10:37 <cads> hrm
18:11:02 <cads> still need to get used to what the type system has to say about numbers
18:11:08 <Ralith> > let blah a b = [a+1 .. b-1] in blah
18:11:09 <lambdabot>       Overlapping instances for Show (a -> a -> [a])
18:11:09 <lambdabot>        arising from a us...
18:11:16 <Ralith> er
18:11:17 <Ralith> > let blah a b = [a+1 .. b-1] in blah 1 7
18:11:19 <lambdabot>   [2,3,4,5,6]
18:11:27 <Ralith> and you could just do
18:11:40 <Ralith> blah :: Integer -> Integer -> [Integer]
18:11:54 <Ralith> that's the most elegant, I think
18:12:16 <Ralith> > 1.5::Int
18:12:17 <lambdabot>       No instance for (Fractional Int)
18:12:17 <lambdabot>        arising from the literal `1.5' ...
18:12:20 <Gracenotes> well, that wouldn't allow Ints
18:12:25 <Ralith> o
18:12:28 <Ralith> Integral?
18:12:43 <Gracenotes> I'm not sure if Enum is defined for all Integrals
18:12:49 <Gracenotes> @instances Enum
18:12:50 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
18:13:11 <Gracenotes> of course, you can do (Integral a, Enum a) => blah your signature
18:13:22 <Gracenotes> :D
18:13:56 <Ralith> > let blah :: (Integral a, Enum a) => a -> a -> [a]; blah a b = [a+1..b-1] in blah 4 12
18:13:57 <lambdabot>   [5,6,7,8,9,10,11]
18:14:03 <Ralith> cads: there you go!
18:14:05 <pumpkin> > toEnum (12345678901234567890 :: Integer)
18:14:06 <lambdabot>   Couldn't match expected type `Int' against inferred type `Integer'
18:14:12 <pumpkin> > fromEnum (12345678901234567890 :: Integer)
18:14:13 <lambdabot>   -6101065172474983726
18:14:18 <pumpkin> mmm
18:14:24 <Gracenotes> heh
18:14:25 <pumpkin> > fromEnum (123456789012345678901234567890 :: Integer)
18:14:27 <lambdabot>   -4362896299872285998
18:14:50 <Ralith> wait
18:14:53 <Ralith> enum is defined for bool?
18:14:55 <cads> > length $ filter (\x -> (uncurry gcd x)==1) $ [(floor(c/3) +1 +k ,ceiling(2*c/3) -1 -k)|k<-[0,b-a]], where c = (1000001 +3)/2
18:14:55 <Ralith> Bool
18:14:56 <pumpkin> yup
18:14:56 <lambdabot>   <no location info>: parse error on input `,'
18:14:57 <Ralith> wtf is the point of that
18:14:59 <pumpkin> > succ False
18:15:01 <lambdabot>   True
18:15:02 <Ralith> ah.
18:15:04 <pumpkin> > pred True
18:15:06 <lambdabot>   False
18:15:09 <Gracenotes> it's not terribly useful
18:15:11 <Ralith> > succ True
18:15:12 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
18:15:13 <pumpkin> > [False..True]
18:15:15 <lambdabot>       Failed to load interface for `False':
18:15:15 <lambdabot>        Use -v to see a list of th...
18:15:19 <pumpkin> o.O
18:15:25 <Gracenotes> space needed :x
18:15:35 <cads> hehe
18:15:47 <pumpkin> > fromEnum False
18:15:48 <lambdabot>   0
18:16:00 <Ralith> cads: that solution to your tastes?
18:16:36 <cads> Ralith: [floor(a) +1.. ceiling(b) -1] is perfect
18:17:02 <pumpkin> that looks awfully unhaskellish
18:17:24 <cads> it's not too bad
18:17:47 <pumpkin> why put the parameters in parentheses?
18:18:01 <cads> oh
18:18:04 <Ralith> cads: what's wrong with the more elgant version we provided?
18:18:38 <Gracenotes> what's elegant about it..? :)
18:19:01 <cads>  > let blah a b = [(floor a)+1 .. (ceiling b)-1] in blah 1 7
18:19:11 <cads> that was pumpkin's right?
18:19:17 <Ralith> I was talking about
18:19:20 <Ralith> > let blah :: (Integral a, Enum a) => a -> a -> [a]; blah a b = [a+1..b-1] in blah 4 12
18:19:22 <lambdabot>   [5,6,7,8,9,10,11]
18:19:24 <Gracenotes> yeah, that was mine :x
18:19:33 <Gracenotes> that's only for Integrals, though
18:19:43 <Ralith> is that not what cads wanted?
18:19:50 <pumpkin> what are you trying to do again?
18:19:50 <cads>  > let blah a b = [(floor a)+1 .. (ceiling b)-1] in blah 1.2 7.9
18:20:00 <Ralith> cads: do you need to support non-Integrals?
18:20:04 <cads> > let blah a b = [(floor a)+1 .. (ceiling b)-1] in blah 1.2 7.9
18:20:06 <lambdabot>   [2,3,4,5,6,7]
18:20:10 <cads> yeah
18:20:12 <Ralith> oh, ok
18:20:14 <Gracenotes> cads: hm. You know, you don't need to do floor (a/b)
18:20:23 <Gracenotes> Just do -- a `div` b
18:20:40 <Gracenotes> those automatically floors it
18:20:52 <cads> are you talking about what I tried to get lambdabot to do a little earlier?
18:20:53 <Gracenotes> *that*
18:20:58 <Gracenotes> cads: yeah
18:21:12 <cads> hehe, yeah, I need to work on that a bit real quick. I'll use div
18:22:15 <Gracenotes> > let blah a b = [(a `div` 2)+1 .. (b `div` 2)] in blah 2 15
18:22:17 <lambdabot>   [2,3,4,5,6,7]
18:22:42 <cads> wait, but floor (a/b) = a `div` b, ceiling (a/b) = 1 + a `div` b
18:22:54 <cads> wait, strike that wait, but
18:23:34 <cads> I've confused myself now, it's okay, I need to get back to my text editor and use these ideas before the leak of my braine!
18:23:47 <Gracenotes> hm... ceiling (a/b) == 1 + a `div` b iff a `mod` b == 0. Hm... :/
18:24:15 <cads> I really ought to find a supplement for this kind of math
18:24:22 <Axman6> ceiling (a/b) = (a+b-1) `div` b
18:24:48 <Gracenotes> @check \a b -> b == 0 || floor (fromIntegral a/fromIntegral b) == a `div` b
18:24:49 <lambdabot>   "OK, passed 500 tests."
18:24:56 <sOpen> shapr, hmm?
18:25:09 <Gracenotes> @check \a b -> b == 0 || ceiling (fromIntegral a/fromIntegral b) == (a `div` b)+1
18:25:10 <lambdabot>   "Falsifiable, after 3 tests:\n0\n1\n"
18:25:29 <Gracenotes> @check \a b -> b == 0 || ceiling (fromIntegral a/fromIntegral b) == (a+b-1) `div` b
18:25:30 <lambdabot>   "Falsifiable, after 0 tests:\n0\n-1\n"
18:25:44 <cads> functional testing is damne sexy
18:26:48 <Gracenotes> @check \a b -> a <= 0 || b <= 0 || ceiling (fromIntegral a/fromIntegral b) == (a+b-1) `div` b
18:26:49 <lambdabot>   "OK, passed 500 tests."
18:27:07 <ski_> > let blah a b = [floor a + 1 .. ceiling b - 1] in blah 1 7
18:27:08 <lambdabot>   [2,3,4,5,6]
18:30:58 <gwern> offhand, does anyone know whether hsjudy is used by any project?
18:31:43 <alatter> gwern: I have a thing put together using tagsoup to scrap the hackage website, if you want the link ...
18:32:11 <alatter> gwern: searching for links to a package
18:32:31 <alatter> gwern: although it's stupid to hit the website when I have a copy of all of the .cabal files locally ...
18:32:37 <gwern> alatter: hm, sounds interesting
18:33:18 <gwern> alatter: I don't think it's stupid - I'd rather not figure out the proper shell incantation to upackage all the tarballs just right
18:33:26 <alatter> gwern: http://panicsonic.blogspot.com/2008/02/html-scraping-with-tagsoup.html
18:33:59 <alatter> gwern: I haven't used in a few months, though
18:34:24 <SamB> alatter: well, you could always set up your own hackage mirror ;-P
18:34:28 <alatter> gwern: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tar   :-)
18:35:06 * Axman6 is trying to figure out how http://mathworld.wolfram.com/BBPFormula.html can be used as a digit extraction formula
18:35:39 * gwern is trying to assess how successful past summer of codes have been
18:35:50 <gwern> there have been a distressing number of failures
18:36:45 <SamB> hey, hey, at least Language.C did eventually get published
18:36:49 <Gracenotes> Axman6: http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf is related to how some formulas for pi can be used for digit extraction
18:36:59 <gwern> SamB: yeah, it only took two separate socs
18:37:08 <gwern> SamB: and guihaskell is just an abject failure
18:37:11 <Gracenotes> by "converting" between expressions of the form (a + b(c + d(e + ...)))
18:37:22 <dolio> @check \n -> 4/(8*n+1) - 2/(8*n+4) - 1/(8*n+5) - 1/(8*n+6) < (1/16)^(n-1) - (1/16)^n
18:37:23 <lambdabot>   Add a type signature
18:37:24 <Axman6> Gracenotes: yeah that's the spigot one, i was wondering about this BBP one (whatever that means_
18:37:39 <dolio> @check \n -> 4/(8*n+1) - 2/(8*n+4) - 1/(8*n+5) - 1/(8*n+6) < (1/16)**(n-1) - (1/16)**n
18:37:40 <lambdabot>   "Falsifiable, after 4 tests:\n4.0\n"
18:37:53 <Gracenotes> in a sense, then, that one is a spigot :) it seems
18:38:12 <gwern> alatter: I think your code doesn't work with http4k, and I had to chuck in a extension
18:38:28 <gwern> oh well
18:38:58 <Gracenotes> Axman6: if you read Python, http://en.literateprograms.org/Pi_with_the_BBP_formula_(Python)
18:39:08 <Gracenotes> linked from wiki page, anyway
18:39:09 <Axman6> i don't, but i can try
18:39:22 <Axman6> but my internet is failing yet again -_-
18:39:22 <Pseudonym> > p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])
18:39:24 <lambdabot>   <no location info>: parse error on input `='
18:39:34 <Gracenotes> Axman6: that seems to be done for me too... but the Google cache is up
18:39:42 <Gracenotes> http://en.wikipedia.org/wiki/BBP_formula#cite_note-4 lists C++, Python, and Ruby
18:39:50 <Pseudonym> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in p 100
18:39:51 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,...
18:40:30 <Gracenotes> what formula does that one use?
18:40:30 <alatter> gwern: boo.  ah well.
18:40:36 <Axman6> Pseudonym: nice. how's the speed of it?
18:40:40 <Pseudonym> Gracenotes: Continued fractions.
18:40:51 <Gracenotes> continued fractions, based on which formula?
18:40:59 <Pseudonym> Uhm... let me see.
18:41:05 <dolio> @check \n -> (4/(8*n+1) - 2/(8*n+4) - 1/(8*n+5) - 1/(8*n+6))*(1/16)**n < (1/16)**(n-1)
18:41:06 <lambdabot>   "Falsifiable, after 439 tests:\n-0.125\n"
18:41:24 <Gracenotes> is that the one from the spigot paper..?
18:41:45 <Pseudonym> It's been a while since I wrote it.
18:41:52 <Gracenotes> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in last $ p 1000
18:42:06 <Gracenotes> .. .. ..
18:42:07 <lambdabot>   thread killed
18:42:13 <dolio> @check \m -> let n = fromInteger m in (4/(8*n+1) - 2/(8*n+4) - 1/(8*n+5) - 1/(8*n+6))*(1/16)**n < (1/16)**(n-1)
18:42:15 <lambdabot>   "OK, passed 500 tests."
18:42:17 <dolio> There we go.
18:43:22 <Gracenotes> > let piG3 = g(1,180,60,2) where g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in piG3
18:43:23 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,...
18:43:31 <Pseudonym> Hmm.  No idea, actually.
18:43:37 <Pseudonym> Oh, I like that one.
18:43:47 <Gracenotes> > let piG3 = g(1,180,60,2) where g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in piG3 !! 10000
18:43:52 <Gracenotes> 7, iirc
18:44:00 <lambdabot>   mueval: Prelude.read: no parse
18:44:13 <Gracenotes> hm
18:44:25 <Gracenotes> ghci says 8 :)
18:44:30 <Gracenotes> I think it's 1000 that's 7
18:44:36 <Gracenotes> > let piG3 = g(1,180,60,2) where g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y:g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in piG3 !! 1000
18:44:40 <lambdabot>   9
18:44:57 <Gracenotes> -.-
18:45:14 <Axman6> we seriously need a faster pidigits program for the shootout. the current one leaks like mad, and we're being beaten by pyhton and lua
18:45:22 <Axman6> and we're not thrashing Ruby
18:45:33 <pumpkin> ultimate dishonor
18:45:34 <Gracenotes> I tried writing a faster one
18:45:52 <Gracenotes> all my optimizations failed :/ except for one, anyway
18:45:57 <Axman6> me too... ended up with exactly the same one as the current one :'(
18:46:08 <Axman6> the problem is the formatting
18:46:16 <wli> What algorithm does it use?
18:46:45 <rwbarton> Axman6: the program is fine under versions of ghc other than 6.10.1
18:47:00 <rwbarton> Axman6: I wish I knew why
18:47:09 <wli> Aha, compiler breakage.
18:47:09 <rwbarton> or rather, why it leaks under 6.10.1
18:47:22 <Axman6> well, apparently it leaks under 6.8.3 (unless the shootout machine now has 6.10.1)
18:47:30 <Gracenotes> wli: you have to use a certain algorithm
18:47:46 <mmorrow> link?
18:47:52 <Pseudonym> @let fibs = scanl (+) 0 (1:fibs)
18:47:56 <Axman6> http://shootout.alioth.debian.org/u64q/benchmark.php?test=pidigits&lang=all#about
18:47:56 <lambdabot>  Defined.
18:48:17 <Gracenotes> but, it uses a basic spigot with a mechanism that self-corrects for overflows that happen with conversion between 'bases'
18:48:18 <mmorrow> @let ats = let go _ [] _ = []; go _ _ [] = []; go n a@(i:is) (x:xs) | n==i = x : go (n+1) is xs | otherwise = go (n+1) a xs in go (0::Int)
18:48:21 <lambdabot>  Defined.
18:48:38 <mmorrow> @let pie n = let fibs m n = m : fibs n (m+n) in (*4) . foldl' (\a b -> a + atan(1/b)) 0 . fmap fromIntegral . take n . ats (fmap(\k->2*k+1)[1..]) $ fibs 0 1
18:48:39 <Pseudonym> > scanl (+) 0 [ 4 * atan2 1 (fromIntegral (fibs !! i)) | i <- [1,3..] ]
18:48:41 <lambdabot>   [0.0,3.141592653589793,4.996183089593018,5.785765328992541,6.09285289407165...
18:48:42 <lambdabot>  Defined.
18:48:48 <mmorrow> > pie 100
18:48:50 <lambdabot>   3.141592653589794
18:48:56 <mmorrow> > pie 100 :: CReal
18:48:57 <lambdabot>   3.1415926535897932384626433832795028841972
18:49:02 <Pseudonym> > scanl (+) 0 [ 4 * atan2 1 (fromIntegral (fibs !! i)) | i <- [3,5..] ]
18:49:04 <lambdabot>   [0.0,1.8545904360032244,2.6441726754027473,2.9512602404818593,3.06887339329...
18:49:08 <Gracenotes> using a counting variable cut my time down by half a second, about
18:49:11 <jganetsk> does anyone know what a CAF is?
18:49:17 <Pseudonym> > drop 10 $ scanl (+) 0 [ 4 * atan2 1 (fromIntegral (fibs !! i)) | i <- [3,5..] ]
18:49:19 <lambdabot>   [3.1413668052471952,3.1415063871991924,3.1415597027606688,3.141580067493025...
18:49:21 <gwern> constant applicative form
18:49:42 <mmorrow> jganetsk: it's a function of arity 0
18:49:44 <Pseudonym> A CAF is a supercombinator that isn't a lambda abstraction.
18:50:00 <mmorrow> (not that (in ghc at least)   foo = \x -> x      has arity 0
18:50:01 <mmorrow> )
18:50:14 <Pseudonym> mmorrow: That's a lambda abstraction.
18:50:17 <Pseudonym> :-)
18:50:20 <mmorrow> but it has arity 0
18:50:39 <Elly> @hoogle fix
18:50:39 <lambdabot> Data.Function fix :: (a -> a) -> a
18:50:39 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
18:50:39 <lambdabot> module Control.Monad.Fix
18:50:42 <Gracenotes> foo = foo has arity 0
18:50:58 <Pseudonym> Operationally, a CAF is something that has arity 0, but would expend work to evaluate it.
18:51:09 <mmorrow> , [| let id x = x in id |]
18:51:10 <lunabot>  LetE [FunD id_0 [Clause [VarP x_1] (NormalB (VarE x_1)) []]] (VarE id_0)
18:51:14 <Pseudonym> So (+1) has arity 0, but requires no work to evaluate.
18:51:20 <Pseudonym> But (1+2) requires work to evaluate.
18:51:20 <mmorrow> , [|let id = \x->x in id|]
18:51:22 <lunabot>  LetE [ValD (VarP id_0) (NormalB (LamE [VarP x_1] (VarE x_1))) []] (VarE i...
18:51:31 <Gracenotes> top-level CAFs aren't garbage-collected
18:51:32 <mmorrow> FunD vs. ValD
18:51:38 <Gracenotes> because, what if they're needed again? :)
18:52:08 <Pseudonym> Gracenotes: Yes, they are.
18:52:13 <Gracenotes> :X
18:52:16 <alatter> gwern: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1335#a1335
18:52:16 <Gracenotes> you don't say
18:52:21 <Pseudonym> If they're accessible from the root, they're not garbage collected.
18:52:29 <Pseudonym> If they're not, they are garbage collected.
18:52:45 <Pseudonym> I know you know, but don't confuse the questioners. :-)
18:52:57 <mmorrow> not static ones though..
18:53:23 <Gracenotes> *cue 10 minutes of qualification*
18:53:26 <mmorrow> (because they're in ro .text)
18:53:28 <mmorrow> hehe
18:54:46 <gwern> alatter: it's not actually that important :)
18:55:32 <Gracenotes> hm. Top level unsafePerformIO'd IORef. An absolutely terrible idea?
18:55:48 <SamB> hey, dons, shouldn't you link to http://www.cse.unsw.edu.au/~dons/irc/haskell-09.html from http://www.cse.unsw.edu.au/~dons/irc/ ?
18:55:51 <Gracenotes> it seems Data.Random uses it :)
18:55:51 <ozy`> Gracenotes: in other words... globals?
18:55:58 <Gracenotes> yeah.
18:56:09 <ozy`> I think HOpenGL uses it too
18:56:51 <Gracenotes> @go unsafePerformIO newIORef
18:56:52 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html
18:56:52 <lambdabot> Title: System.IO.Unsafe
18:57:03 <SamB> @ask dons shouldn't you link to http://www.cse.unsw.edu.au/~dons/irc/haskell-09.html from http://www.cse.unsw.edu.au/~dons/irc/ ?
18:57:04 <lambdabot> Consider it noted.
18:57:31 <Gracenotes> ah. so polymorphism is a no-no in those
18:59:18 <toliko_smoren> is there an operator similar to : which adds something to the end of the list?
18:59:41 <monochrom> It doesn't have a standard name.
18:59:48 <roconnor> , runReader ask 7
18:59:49 <lunabot>  luna: Not in scope: `runReader'
18:59:51 <Gracenotes> list++[x]. But it has to crawl through the whole list before it can append it
18:59:55 <shapr> So, anyone else showing up for the Boston Haskell User's Group?
19:00:01 <roconnor> , MonadLib.Monads.runReader ask 7
19:00:02 <lunabot>  luna: Not in scope: `MonadLib.Monads.runReader'
19:00:04 <mmorrow> , runReaderT 7 ask
19:00:05 <lunabot>  luna: No instance for (GHC.Show.Show (m a))
19:00:11 <mmorrow> , runId (runReaderT 7 ask)
19:00:12 <lunabot>  7
19:00:14 <Gracenotes> it you're constantly doing that throughout the program, try a DList
19:00:17 <jeffz`> Gracenotes: there's been some extensive discussion on -cafe about unsafePerformIO newIORef if you're interested in searching for it
19:00:23 <jganetsk> why is a CAF different from just a regular thunk?
19:00:26 <toliko_smoren> thanks
19:00:30 <rwbarton> shapr: I might, where/when?
19:01:00 <Gracenotes> jeffz`: ah... is that the unsafe discussion?
19:01:09 <shapr> rwbarton: February 28th @ BlueSpec  in Waltham
19:01:15 <Gracenotes> great, I can read it in the comfort of GMail :)
19:01:29 <roconnor> mmorrow: it'd be nice if MonadLib.Monads was in scope too
19:01:37 <rwbarton> shapr: cool, a friend of mine works there
19:01:40 <mmorrow> hmm, that would be nice :)
19:01:45 <shapr> rwbarton: excellent!
19:01:49 <alatter> gwern: it's too late for me now - I'm already writing a better version
19:01:50 <jeffz`> Gracenotes: I think the subject was something like "top level bindings"
19:02:03 * SamB lols at "shapr seems to be unliked too. He/She got beaten 22 times."
19:02:09 <sOpen> shapr, no transport :-/ also not much of a Haskell "user", yet
19:02:13 * wli screams as he realizes hmatrix lacks exponential integrals for complex arguments.
19:02:24 <Gracenotes> jeffz`: oh, I don't have that archived. Do you have a link?
19:02:40 <shapr> sOpen: mass transit is available.
19:02:41 <Gracenotes> in this case, though, the unsafely accessed IORef would not leave the module
19:03:00 <sOpen> shapr, oooOOooo... maybe then
19:03:06 <shapr> sOpen: Plus, hooking up with people who know more is a great way to learn!
19:03:21 <sOpen> I've never been to Waltham... exotic locale. :-P
19:03:26 <shapr> I've been asked to give another short talk on monads while riding a unicycle
19:03:44 <shapr> I think I'll skip that and go for a hands-on QuickCheck demo instead.
19:03:47 <int-e> Gracenotes: I knew I had seen this on the wiki. http://www.haskell.org/haskellwiki/Top_level_mutable_state
19:04:00 <SamB> shapr: did you already do that once ?
19:04:10 <shapr> bohanlon: You want to come to a Haskell User's Group in Waltham on the 28th of February?
19:04:18 <mmorrow> roconnor: ok, done
19:04:25 <int-e> Gracenotes: (note the {-# NOINLINE #-}. There's also the suggestion of using -fno-cse, but it's not explained why it is needed.)
19:04:26 <shapr> SamB: Yeah, that's why I was asked to do it again. It seems to be a good publicitly stunt.
19:04:39 <roconnor> oh there is an STMonadTransformer
19:04:41 <SamB> shapr: I'm having some trouble believing that it is possible
19:04:41 <mmorrow> roconnor: oh, also note that `lift' is `lift_' because it clashes with the TH `lift'
19:04:47 <shapr> SamB: There are pix.
19:04:48 <roconnor> @hackage STMonadTrans
19:04:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/STMonadTrans
19:04:52 <SamB> shapr: so I can see why it'd be a good stunt
19:04:55 <shapr> heh
19:05:01 <roconnor> mmorrow: good to know
19:05:01 <SamB> shapr: I won't believe it until I see a video
19:05:06 <SamB> with sound
19:05:08 <shapr> bah
19:05:42 <mmorrow> , runReader 7 ask
19:05:43 <lunabot>  7
19:05:51 <shapr> toliko_smoren: Is Boston too far away for a Haskell User's Group?
19:06:01 <Gracenotes> hm
19:06:20 <Gracenotes> I might be able to get a ferry and somehow get a drive up to Boston :)
19:06:20 <bohanlon> shapr: Yeah, I should be able to make that
19:06:22 <int-e> jganetsk: a CAF is created before any haskell evaluation starts. it's also shared between all places that use it. these facts makes them difficult to garbage collect.
19:06:27 <shapr> bohanlon: spiffy!
19:06:38 <roconnor> mmorrow: I wrote a package that implements Data.Accessor.MonadLib
19:06:40 <ozy`> shapr: I'd go to that
19:06:46 <roconnor> I should upload it I guess
19:06:51 <mmorrow> , runCont id (callCC (\k -> forever (k 42) >> return 0))
19:06:52 <lunabot>  42
19:06:52 <shapr> ozy`: Cool!
19:06:58 <mmorrow> roconnor: oh nice
19:06:59 <jeffz`> Gracenotes: gmane is handy, http://thread.gmane.org/gmane.comp.lang.haskell.cafe/909/focus=917 http://thread.gmane.org/gmane.comp.lang.haskell.cafe/4528/focus=4548 http://thread.gmane.org/gmane.comp.lang.haskell.cafe/20163
19:07:08 <mmorrow> roconnor: on hackage?
19:07:14 <bohanlon> shapr: is there a mailing list or website or something?  I know that I got mail at some point, but I do not remember much more than that...
19:07:14 <roconnor> not yet
19:07:17 <toliko_smoren> hey, can anyone look why this doesnt work, i am sure its something really stupid http://pastie.org/385704
19:07:23 <shapr> bohanlon: You did?
19:07:28 <Axman6> :t return . runST
19:07:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => (forall s. ST s a) -> m a
19:07:32 <roconnor> mmorrow: I'll probably put it up there now
19:07:37 <mmorrow> roconnor: sweet
19:07:48 <shapr> No, there's not a mailing list yet..
19:07:51 <pumpkin_> Gracenotes: where you at?
19:07:55 <bohanlon> shapr: I am pretty sure, because I remember forwarding something to someone else, but I could be imagining this...
19:07:56 <Gracenotes> Stony Brook university
19:07:59 <shapr> And since new accounts for the HaskellWiki are disable...
19:08:04 <shapr> bohanlon: huh, when was that?
19:08:07 <pumpkin_> Gracenotes: that's NY?
19:08:10 <roconnor> mmorrow: It'll be hard to move people from MTL to monadLib
19:08:15 <pumpkin_> ah yes
19:08:15 <shapr> In any case, I'm glad there's interest :-)
19:08:26 <Gracenotes> yep, Long Island. The little thing hanging off the lower right of New York
19:08:32 <pumpkin_> shapr: I'm only coming to see you do capoeira on a unicycle
19:08:34 <shapr> On the other hand, gbeshers is vaguely close...
19:08:43 <shapr> pumpkin_: Hah, no capoeira on a unicycle!
19:08:43 <pumpkin_> haskell is boring in comparison
19:08:44 <bohanlon> shapr: I do not remember; I can look through my archives at work; it may have been ``we are thinking about doing this; I know that you may be interested''
19:08:53 <Gracenotes> wow, Boston is much further East than I had thought
19:08:59 <shapr> bohanlon: wow cool!
19:09:08 <Gracenotes> but of course it is... it has a port and such...
19:09:18 <bohanlon> shapr: so when/where?
19:09:28 <shapr> bohanlon: BlueSpec in Waltham, February 28th
19:09:49 <shapr> I'm really not sure how long it'll last, because I don't know who wants to talk about what.
19:10:02 <shapr> So far I've persuaded two people to talk... and I'm one of those people.
19:10:09 <pumpkin_> lol
19:10:13 <pumpkin_> what will you talk about?
19:10:25 <shapr> QuickCheck, SmallCheck and friends
19:10:26 <pumpkin_> and who's the other one?
19:10:28 <pumpkin_> ah
19:10:44 <shapr> edwardk, he's giving an intro to comonads and Kan extensions.
19:10:49 <gwern> his talk will consist of 'Haskell YEEAAAAHH!', and then he will wait for any questions
19:10:50 <shapr> And showing how they can make your Haskell code FASTER!
19:10:58 <pumpkin_> oog
19:10:59 <pumpkin_> ooh
19:11:02 * Axman6 thinks someone needs to write a CzechCheck, just for funsies
19:11:07 <shapr> Axman6: Go for it!
19:11:17 * Axman6 wouldn't know how :(
19:11:30 <shapr> Anyway, if anyone else wants to give a talk, contact me, or email the mailing list (when it exists).
19:11:32 <Gracenotes> okay, but if there is a Haskell meetup, someone needs to tape it and put in on some video-hosting service
19:11:41 <Gracenotes> please :)
19:11:41 <shapr> Gracenotes: Show up with a video camera ;-)
19:11:56 <Axman6> shapr: any chance these talks will be recorded and put online?
19:11:57 <Gracenotes> for those who can't show up, with or without camera
19:12:01 <TomMD> Meetup where?  Still talking about London
19:12:05 <Axman6> damn you Gracenotes
19:12:09 <shapr> TomMD: Boston
19:12:29 <shapr> TomMD: There are several Haskellers in London though, you could get something happening :-)
19:12:36 <Gracenotes> Axman6: there's no use thinking of anything. I've already thought of it seconds before you have.
19:12:44 <monochrom> speaker becomes nervous if aware of camera. use a pinhole camera.
19:12:52 <Axman6> Gracenotes: you're not related to beelsebob are you?
19:12:55 <bohanlon> shapr: Ah, okay.  I talked to Ravi at ICFP, and he e-mailed me saying that folks were trying to get something together.  One of my coworkers mentioned that would be interested in talking, but it is not clear whether we can legally give the talk
19:13:00 <shapr> Aha
19:13:20 <shapr> bohanlon: So, do you work at Peerium?
19:13:30 <Gracenotes> Axman6: nope
19:13:32 <bohanlon> shapr: I am at MITRE
19:13:36 <shapr> oohh
19:13:39 <TomMD> shapr: Not in London - just figured that was the discussion.
19:13:40 * Axman6 thinks you must be
19:13:50 <TomMD> shapr: I (will) live in Portland :-)
19:13:57 <shapr> TomMD: Where are you now?
19:13:57 <gwern> mitre still exists?
19:14:09 * gwern thought MITRE was just something that existed in the computer history books
19:14:15 <shapr> bohanlon: BBC's dirac was prototyped in Haskell, trivial info...
19:14:24 <Gracenotes> Axman6: I amn't, I say!
19:14:25 <bohanlon> gwern: yes, and we still do stuff...
19:14:49 <gwern> bohanlon: now I know you're pulling my leg
19:14:49 <roconnor> @hackage data-accessor-monadLib
19:14:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor-monadLib
19:14:53 <roconnor> mmorrow: ^^
19:15:02 <shapr> At least, there was a guy who was writing a video codec for the BBC, and prototyping it in Haskell on this channel, and then Dirac appeared later, so I assume...
19:15:27 <pumpkin_> shapr: sorry :/
19:15:52 <shapr> bohanlon: Well, if you can legally give a talk, it would be very cool :-)
19:16:07 <gwern> shapr: btw, I was looking back at the 2006 SoC, and I was wondering - what went wrong with haskell.net?
19:16:21 <shapr> gwern: Nothing?
19:16:26 <shapr> Nobody used it?
19:16:36 * Gracenotes fetches a sammich for himself
19:16:51 <roconnor> , (first^:second^=10) (('b',7),"hallo")
19:16:52 <lunabot>  luna: Not in scope: `^:'
19:16:52 <gwern> shapr: well, yes, why did that happen?
19:17:03 <roconnor> > (first^:second^=10) (('b',7),"hallo")
19:17:03 <shapr> gwern: I don't know.. I guess I didn't advertise enough.
19:17:04 <bohanlon> shapr: You might e-mail ramsdell (at mitre dot org) (or my uid at mitre dot org)
19:17:04 <lambdabot>   Not in scope: `^:'Not in scope: `^='
19:17:12 <shapr> bohanlon: Cool, will do.
19:17:40 <bohanlon> shapr: We have an internal FP list, and I am sure that several others would be interested (though many are not in the Boston area)
19:18:14 * gwern is a little surprised at shapr's indifference. that was the only failure of 2006's SoC. maybe being a mentor was more casual than I thought
19:18:15 <mmorrow> roconnor: sweet
19:18:21 <shapr> gwern: Wait, what?
19:18:35 <shapr> gwern: Haskell.net succeeded in terms of implementation, yeah?
19:18:42 <shapr> gwern: I thought you meant "why isn't anyone using it?"
19:18:48 <johannh> Hey all. I'm just getting started here, so my terminology's probably off, but is it possible to give an instance for a typeclass for a concrete type? I have a generic (Show (Interval a)), but I want (Show (Interval Date)) to give a nicer-looking representation.
19:18:53 <gwern> well, they're the same thing
19:18:53 <roconnor> mmorrow: data-accessor is totally awsome.  I don't know why it doesn't get more attention.
19:19:04 * tehgeekmeister just had an epiphany
19:19:09 <shapr> gwern: 'Failure' would mean the student didn't get any money.
19:19:10 <mmorrow> roconnor: i've been meaning to check it out
19:19:14 <shapr> gwern: from one viewpoint
19:19:14 <gwern> my understanding was that SoC wasn't about funding academic research, but getting things done
19:19:24 <shapr> gwern: I agree.
19:19:36 <mmorrow> roconnor: Peaker was talking about it the other day. i think he wanted to use TH to write something related
19:19:40 <tehgeekmeister> for loops and such in imperative language, where the main point is to += or something or another into a variable on each iteration, are essentially folds
19:19:46 <roconnor> mmorrow: I sort of dismissed it when I first heard about it.  But then I wrote the exact data type myself.
19:19:52 <SamB> gwern: yeah, even so it's not expected to have a 100% output rate
19:19:55 <mmorrow> roconnor: heh
19:19:58 <roconnor> mmorrow: So I figured it was useful after all
19:20:19 <gwern> SamB: people are expected to die, but doctors still do autopsies and mortality conferences
19:20:52 <roconnor> mmorrow: you get to write foo %= bar  inside the state monad
19:21:07 <SamB> gwern: sure, carry on!
19:21:22 <roconnor> mmorrow: unfortunately you can't write foo %= foo +1
19:21:33 <johannh> roconnor: Hey, are you the roconnor once of Berkeley?
19:21:37 <roconnor> mmorrow: but you can write foo %: (+1) if you want.
19:21:58 <roconnor> johannh: Hi johannh! yes I am.  Are you writing Haskell for your job now?
19:22:37 <mmorrow> interesting
19:23:24 <cads> hey, guy in #math gave an interesting problem.  " Given n "starting" points and n "finishing" points in the plane: Determine the (not necessarily unique) pairing of points such that the sum of the lengths of the straight lines between the members of each pair is minimized."
19:23:27 <johannh> Nope, I'm still deep in q/APL-land for now; F# is on hold, and they've recently thrown the doors wide open, so I'm futzing around with Haskell to see if I want to use it.
19:23:48 <cads> he points out that brute forcing it will be O(n!)
19:24:12 <roconnor> johannh: you want to use it
19:24:24 <cads> and that pruning against the best discovered solution gives no guarantees
19:24:41 <roconnor> you can hire me as a consultant :P
19:25:16 <shapr> roconnor: How much do you charge?
19:25:28 <roconnor> shapr: umm
19:25:33 <sOpen> 6 Coulombs
19:25:43 <roconnor> shapr: oh let's say $100 / hr
19:25:43 <johannh> roconnor: Heh. Well, I'm not sure what's left of our budget these days...
19:25:47 <roconnor> Canadian!
19:26:29 <TomMD> @go $100 Canadian to US
19:26:30 <lambdabot> No Result Found.
19:26:49 <roconnor> @go stopped converting over a year ago ;(
19:26:49 <lambdabot> No Result Found.
19:27:02 <chessguy_work> cads, sounds like a standard optimization problem
19:27:07 <johannh> roconnor: I'm still trying to figure out how to do simple things in purely-functional land, like dynamic-programming stuff like making a recombining binary tree that works, etc.
19:27:07 <shapr> roconnor: Hm, that's more than I make, so I'll have to pass.
19:27:25 <johannh> roconnor: s/binary/binomial
19:27:30 <roconnor> shapr: pass on what?
19:27:31 <tehgeekmeister> will mapM work over other types such as Data.Map?
19:27:51 <shapr> roconnor: hiring you for contract haskell work ;-)
19:27:53 <chessguy> mapM doesn't work for Data.Map
19:27:56 <chessguy> @type mapM
19:27:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:28:00 <roconnor> johannh: the trick to dynamic programing in haskell is to assume you have the answer before you begin.
19:28:08 <dolio> @type Data.Traversable.mapM
19:28:09 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
19:28:16 <roconnor> shapr: oh.  Maybe I shouldn't have picked my fee randomly.
19:28:31 <chessguy> @instances-importing Traversable
19:28:32 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
19:28:44 <chessguy> gee,thanks
19:28:47 <MarcWeber> When using [ (a,b,c) | a <- listC, b <- listB, c <- listA] does ghc force a particular order evaluating listA, listB, listC ?
19:28:50 <dolio> :)
19:28:55 <cads> chessguy_work: yeah, it's a pretty simple search/optimization problem, but I was wondering if anyone knew off the top of their head what complexity it has
19:28:59 <dolio> @instances-importing Data.Traversable Traversable
19:29:00 <lambdabot> Maybe, []
19:29:07 <dolio> @instances-importing Data.Traversable Data.Map Traversable
19:29:07 <lambdabot> Map k, Maybe, []
19:29:40 <chessguy> ohhh, now i see how that command works
19:29:43 <roconnor> shapr: are you in need of consultants?
19:29:47 <chessguy> @help instances-importing
19:29:48 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
19:29:52 <shapr> well, not at the moment.
19:30:11 <johannh> roconnor: inscrutable, but clearly I just have to read more. I'm just getting to the point where I can understand the things google turns up for that.
19:30:24 <tehgeekmeister> dolio: so if i read the result of that command right, Data.Map is traversable?
19:30:31 <dolio> Yes.
19:30:43 <roconnor> johannh: http://r6.ca/blog/20081116T213644Z.html
19:30:44 <tehgeekmeister> cool
19:30:50 <chessguy> tehgeekmeister, http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
19:30:51 <dolio> So you can mapM over it.
19:31:26 <tehgeekmeister> chessguy: oh i didn't know they listed the instances on those pages.  thanks!
19:31:55 <chessguy> tehgeekmeister, and i didn't know Data.Traversable had its own mapM
19:32:06 <tehgeekmeister> chessguy: i'm glad it does, makes my life a lot easier
19:32:16 <roconnor> johannh: http://www.reddit.com/r/haskell/comments/7du1b/a_haskell_zen_moment/c06e9bz
19:36:22 <lepassive> can you help me debugging this program ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1336#a1336
19:36:37 <lepassive> it gives me Tree.hs:24:10: parse error on input `<-'
19:37:06 <Axman6> you need  = do in the prefious line
19:38:38 <roconnor> shapr: do you work as a consultant?
19:38:55 <johannh> roconnor: interesting, thanks.
19:39:06 <gwern> roconnor: thought he was more of a contractor
19:39:08 <lepassive> Axman6, Okay now     Couldn't match expected type `IO' against inferred type `(->) Int' in 27:16
19:39:17 <shapr> roconnor: Yes
19:39:23 <roconnor> gwern: oh?  What is a contractor?
19:39:44 <gwern> roconnor: someone with a contract!
19:39:53 <roconnor> shapr: a haskell consultant?
19:39:56 <Axman6> lepassive: you're not passing a second argument to viewDir
19:39:57 <shapr> roconnor: Actually, I am looking to hire someone in the Boston area for a C# job.
19:40:00 <Axman6> or viewfile
19:40:01 <shapr> roconnor: Not anymore
19:40:01 <Axman6> F*
19:40:02 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1327#a1334 <-- anyone have comments on my description of the 2006 Summer of Code
19:40:31 <roconnor> shapr: I've never programmed in C# in my life :)
19:40:41 <geezusfreeek> oh wuddayaknow, my monad transformer stack doesn't inline well
19:40:47 <gwern> you know haskell; how hard coud C# be to learn?
19:41:06 <shapr> gwern: It still says that Haskell.Net is a failure!
19:41:08 <lepassive> Axman6, Ah yes
19:41:23 <shapr> roconnor: C# is easy, politics are hard.
19:41:30 <gwern> shapr: no it doesn't, it says unssuccessful
19:41:41 <johannh> mumble-mumble-shopping
19:41:54 <gwern> I decided on a 3part system - successful == coded and used, unsuccessful == coded and not-used, failure = not-coded and not-used
19:42:05 <shapr> Oh, and you have to leverage synergy for mindshare uptake of ... mental pain, I assume.
19:42:10 <hackage> Uploaded to hackage: data-accessor-monadLib 0.0.0
19:42:23 <shapr> We need buy-in to meet and exceed this quarter's expectations.
19:42:24 <roconnor> hackage: that's me!
19:42:52 * gwern feels mocked. it seems like a sensible set of distinctions to me :(
19:43:10 <jganetsk> so question about CAFs
19:43:12 <geezusfreeek> does monadLib inline more nicely than mtl, bychance?
19:43:20 <jganetsk> i've compiled some code to assembly and am trying to understand what's going on
19:43:23 <shapr> gwern: Sorry, I wasn't talking about your document, I was talking about my C# job.
19:43:26 <jganetsk> and i see one thing i dont understand
19:43:31 <roconnor> geezusfreeek: does the mtl not nicely inline?
19:43:33 * wli kinda-sorta manages to grind it down to Ci/Si
19:43:40 <Axman6> geezusfreeek: failure = coded, but doesn't work too?
19:43:45 <Axman6> uhm gwern
19:43:46 <jganetsk> my CAF has a closure in the text segment
19:43:58 <jganetsk> when the CAF is ini tialized
19:44:04 <johannh> I wonder how hard it would be to write a q/Haskell bridge...
19:44:11 <jganetsk> that closure is overwritten with an indirection
19:44:15 <geezusfreeek> roconnor, not according to http://haskell.org/haskellwiki/Performance/Monads and my profiling
19:44:17 <gwern> Axman6: no, means not-coded
19:44:18 <jganetsk> and points to a heap-allocated closure with a CAF-blackhore
19:44:22 <jganetsk> which is later updated
19:44:25 <shapr> gwern: I see your new version, looks good.
19:44:27 <jganetsk> why is the indirection necessary?
19:44:30 <gwern> Axman6: as in the c lib in '06 didn't get finished
19:44:43 <roconnor> geezusfreeek: is your mtl compiled with optimizations on?
19:44:54 <geezusfreeek> should be
19:45:01 <roconnor> hmm
19:45:17 <roconnor> I'm not aware of monadLib having better inlining
19:45:25 <roconnor> but I don't know
19:45:27 <cads> let gokyugen c = let x = (c+3)/6; haduken a b =  length $ filter (\x -> (uncurry gcd x)==1) $ [(a+k ,b-k) |k <- [0..b-a]] in haduken (1 + floor x) (-1 + ceiling (2*x)) in gokyugen 1000001
19:45:30 <shapr> gwern: The language-c lib in hackage has been used to parse the Linux kernel, is that a different lib?
19:45:37 <cads> > let gokyugen c = let x = (c+3)/6; haduken a b =  length $ filter (\x -> (uncurry gcd x)==1) $ [(a+k ,b-k) |k <- [0..b-a]] in haduken (1 + floor x) (-1 + ceiling (2*x)) in gokyugen 1000001
19:45:39 <lambdabot>   80840
19:45:53 <geezusfreeek> i suppose i could just unroll my stack as suggested in the wiki article
19:45:58 <geezusfreeek> i'm just going to get myself lost though
19:46:01 <gwern> shapr: I believe that was the result of the *second* SoC trying to create a language.c lib
19:46:04 <shapr> ohh
19:46:30 <roconnor> geezusfreeek: When I last had performace problems, I blamed it on the fact that debian haskell library packages were not compiled with optimisations on
19:46:47 <shapr> btw, is there a standard way to get a mailing list on haskell.org?
19:46:53 <cads> roconnor: you still in debian?
19:47:01 <roconnor> cads: ubuntu
19:47:01 <shapr> I'm sure I should know this, since I'm an admin, but I don't remember :-(
19:47:05 <roconnor> cads: kubuntu
19:47:16 <roconnor> cads: did the tor ACM thing work for you?
19:47:27 <Gracenotes> has anyone here written an NFA-to-regular-expression converter, by chance...?
19:47:32 <SamB> shapr: what do you want it for ?
19:47:34 <cads> roconnor: couldn't get it to work
19:47:42 <shapr> SamB: Boston User Group
19:47:42 <roconnor> :/
19:47:48 <johannh> roconnor: I've got to run; most-of-Sarah says hi. It's been nice running into you.
19:47:56 <roconnor> johannh: I'm usually here
19:48:22 <SamB> shapr: isn't it traditional to set up HUG mailing lists independantly ?
19:48:25 <cads> roconnor: I didn't try enough exit points, and on top of that i'm not 100% on whether I had configured things correctly.. I need to get back to that but have been busy
19:48:55 <cads> roconnor: in debuntu, have you recompiled ghc/cabal from upstream?
19:48:56 <shapr> SamB: There's a tradition?
19:49:52 <lepassive> I modified it a little bit http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1338#a1338 and gives me Tree.hs:35:13:    Couldn't match expected type `FilePath' against inferred type `Char'
19:49:52 <cads> roconnor: or is there a package maintainer that you know?
19:50:10 <roconnor> cads: I use cabal install a lot more today
19:50:17 <lepassive> and I'm worried also about the duplicated part of get entries
19:50:35 <SamB> shapr: maybe not
19:50:36 <roconnor> cads: and I don't worry about performance for a lot of my code that I write
19:50:41 <cads> nor I
19:50:46 <SamB> most of them aren't even called HUGs, apparantly
19:50:59 * SamB wonders if this is intended to avoid confusion with hugs98?
19:52:43 <cads> roconnor: I haven't written anything that requires performance at all :)
19:52:59 <cads> but I hate the debian packages.. been thining of moving to arch or gentoo
19:53:57 <shapr> what don't you like about debian packages?
19:54:10 * gwern dislikes the way they wink at me
19:54:21 <shapr> gwern: Yeh, I understand that.
19:54:31 <shapr> rpms keep pinching my butt :-(
19:54:45 * lepassive is trying to cut a tree
19:55:01 <shapr> axe :: Tree -> Log
19:55:23 * Axman6 will do it for you
19:57:16 <cads> shapr: well for example the ghc-cabal package got taken out
19:57:17 <dolio> More like Tree -o Log, amirite?
19:57:28 <lepassive> Axman6_, Well I want to do it myself as it my first script in haskell
19:57:53 <Axman6_> i was making reference to the axe thing :P
19:57:59 <cads> shapr: but before it was removed, the cabal package was broken for the longest time
19:58:11 <lepassive> Axman6_, oh sorry
19:59:02 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1327#a1339 <-- 2007 done
19:59:40 <gwern> interesting how consistent 2006 and 2007 are - 4 successes and 2 unsuccessful
20:00:03 <shapr> cads: Huh, did you file a bug?
20:00:39 <shapr> cads: If you want to fix the Haskell packages in Debian, it's entirely possible the maintainer will let you take over after an improved NMU.
20:00:47 <shapr> In fact, I think it's likely :-)
20:01:41 <cads> lemme find out who maintains them
20:02:11 <cads> I guess I could take that responsibility.. it would have to be through the mentor program though
20:04:22 * wli obtains a preposterously complex continued fraction for \int_{-\infty}^x \frac{e^{Kt}}{t^2+1}dt
20:04:29 <ozy`> oh man
20:04:46 <wli> w0t?
20:05:11 <ozy`> okay how many of you are behind this? http://dis.4chan.org/prog/ <-- the "Prefix/polish notation in Java" post
20:05:23 <gwern> we're all behind it
20:05:28 <gwern> don't you know? anon is legion
20:05:37 <ozy`> oh snap
20:05:39 <Axman6_> wait, 4chan has non porn areas?
20:06:48 <gwern> Axman6_: well sure. although /b/ is a bit fuzzy
20:07:22 <ozy`>  /b/ is the new myspace.
20:07:34 <ozy`> too many dumb teenagers. no longer fun.
20:07:43 <ozy`> computer unnecessary.
20:09:45 <gwern> @seen dcoutts_
20:09:45 <lambdabot> dcoutts_ is in #ghc and #haskell. I don't know when dcoutts_ last spoke.
20:10:20 <gwern> @seen dcoutts
20:10:20 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
20:10:28 <gwern> bleh
20:10:39 <gwern> does anyone else know what came of Andrea Vezzosi's cabal/make work?
20:10:56 <Cale> @seen Saizan
20:10:56 <lambdabot> Saizan is in #haskell.it, #haskell-soc, #haskell-blah, #yi, #ghc, #haskell-overflow and #haskell. I last heard Saizan speak 2h 15m 3s ago.
20:11:22 * wli vaguely wonders if Gauss-Kronrod-Laguerre quadrature is a better way to go about this.
20:12:47 <dolio> Yes.
20:13:45 <glguy> roconnor, do you understand the monadlib typeclasses yet?
20:13:50 <cads> !L!L!L!LOL!
20:13:52 <glguy> roconnor, I havne't read the backlog
20:14:05 <glguy> just the part where my name came up :)
20:14:15 <cads> oh gawn, 4chan: "my" `hax` "anus"
20:14:43 <roconnor> glguy: not the new Run classes
20:15:32 <roconnor> glguy: (and maybe not the old run classes either :)
20:15:56 <wli> Actually it would be Gauss-Legendre-Kronrod because it's only e^{Kt}(pt+q)/(t^2+at+b) on the intervals where the piecewise function takes on the form of some rational function with denominator t^2+at+b and the remainder of the numerator when divided by the denominator of pt+q.
20:16:08 <Axman6_> http://dis.4chan.org/read/prog/1234319331/1-40 eh? o.O
20:16:13 <glguy> roconnor, the idea is that you can change the type that a monad transformer is indexed by
20:16:20 <glguy> when you use one of the local run functions
20:16:27 <lepassive> now I'm frustrated.. any help ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1340#a1340
20:16:51 <glguy> so you can run a (ReaderT Char m) locally in a (ReaderT Int m)
20:17:40 <glguy> in the case of continuations, you can run a computation with a different final result than that of the surrounding one
20:18:45 <roconnor> glguy: the type variable j doesn't occur in the function signature
20:19:23 <cads> oh hax, my algorithm might not be efficient enough to solve the euler project problem for the number that it requires
20:19:26 <drguildo> can somebody explain to me what the job of the cabal-install bootstrap.sh script is?
20:19:52 <pumpkin_> drguildo: to save you the effort of installing cabal-install yourself
20:20:03 <drguildo> it seems to try to download and install all library dependencies, is this correct?
20:20:10 <pumpkin_> yup
20:20:17 <drguildo> and so it is a bug if it fails to do this?
20:20:31 <drguildo> as in it complains about a missing library
20:20:43 <glguy> roconnor, the functional dependencies use the j
20:20:55 <drguildo> Configuring cabal-install-0.6.0...
20:20:55 <drguildo> Setup: At least the following dependencies are missing:
20:20:55 <drguildo> network >=1 && <3
20:20:55 <drguildo> Sorry, something went wrong.
20:21:02 <glguy> roconnor, Iavor is better at explaining why we had to add that
20:21:27 <drguildo> is this a bug?
20:22:02 <roconnor> glguy: why not simply (ReaderM m i, Monad n) => RunReaderM m i n ?
20:22:48 <ozy`> drguildo: it's probably an issue with 1) your GHC version, 2) your $PATH, or 3) an imminent hardware failure that's going to destroy your computer
20:22:52 <Cale> drguildo: I think it probably assumes that you have a network library, as that's usually included with GHC, unless you got the light GHC package.
20:23:14 <drguildo> i'm using the ghc that comes with the latest ubuntu
20:23:33 <Cale> drguildo: Oh, then apt-get install libghc6-network -- or something like that
20:23:35 <drguildo> so like, it doesn't work with by far the most popular linux distro
20:23:55 <drguildo> which seems like a flaw in the program given the apparent intention of bootstrap.sh
20:23:57 <Cale> libghc6-network-dev
20:24:05 <drguildo> i know how to get it working
20:24:12 <drguildo> i just want to know whether to file a bug or not
20:24:26 <drguildo> i don't know why it downloads and installs all this other stuff
20:24:30 <drguildo> like this zlib library
20:24:36 <drguildo> and then craps out when it gets to the network one
20:24:38 <Cale> zlib doesn't come with ghc
20:24:58 <ozy`> drguildo: bootstrap.sh kinda sucks, yeah. I think ubuntu is a common enough distro that you can ask them to support it with an OS-specific check or two
20:25:01 <drguildo> and network does?
20:25:07 <Cale> drguildo: yes
20:25:28 <drguildo> so why do i have to install it as an extra package?
20:25:35 <Cale> drguildo: The ubuntu people separated out the libraries into separate deb packages though.
20:25:47 <glguy> roconnor, probably just because then you don't get ReaderM for free on the n in using RunReaderM
20:25:52 <glguy> but that's about all I can think of
20:25:53 <drguildo> i see
20:25:56 <drguildo> it doesn't surprise me
20:26:00 <drguildo> they love to do that shit
20:26:07 <drguildo> like seperating out header files etc
20:26:09 <ozy`> they're hilarious like that
20:26:17 <drguildo> as if hard drive space is uber expensive
20:26:54 <drguildo> oh yeah, and those -dbg packages
20:26:59 <ozy`> it would be nice of them to offer to download all the "extra" stuff they removed from base packages
20:27:11 <Cale> Personally, I don't even use ubuntu's GHC package. I just install the generic linux binary.
20:27:15 <ozy`> like, just in case you actually want to do things
20:27:17 <drguildo> so that by default backtraces are practically useless
20:27:29 <gwern> whew, glad that's done
20:27:41 <gwern> shapr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1327#a1341
20:27:49 <gwern> I'm going to send that to -cafe soon I suppose
20:28:04 <drguildo> Cale: i think i'll do that as well
20:28:05 <toliko_smoren> is there are a way to ignore the possibility that maybe will not be nothing?
20:28:38 <gwern> will not be nothing... will be Just?
20:28:45 <Cale> Ubuntu's dev cycle is pessimally aligned with the GHC dev cycle, so Ubuntu's packages are almost always 6 months behind.
20:28:45 <toliko_smoren> yeah
20:29:02 <toliko_smoren> i know its always going to be something
20:29:03 <drguildo> that's not so bad
20:29:07 <drguildo> i mean that's just unfortunate
20:29:10 <Cale> toliko_smoren: fromJust
20:29:13 <gwern> fromJust maybe
20:29:14 <ozy`> toliko_smoren: you have to destructure the value somehow.
20:29:16 <drguildo> what's bad is that they do stupid crap like this
20:29:19 <toliko_smoren> and i am using findIndex
20:29:22 <Cale> toliko_smoren: Or just neglect to pattern match the Nothing case.
20:29:28 <ozy`> @hoogle fromJust
20:29:28 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
20:29:29 <drguildo> that breaks stuff
20:29:33 <roconnor> , let get = ask ; put = modify . const; modify f = callCC (\k -> local f (k ())) in runReader 5 (runContT return (do a <- get ; put (a + 1) ; b <- get ; return (a,b)))
20:29:34 <lunabot>  luna: Occurs check: cannot construct the infinite type: i = b -> i
20:29:35 <wli> oooh http://www.ams.org/mcom/1997-66-219/S0025-5718-97-00861-2/home.html
20:30:19 <ozy`> drguildo: I don't know why on earth they would include GHC by default without significant parts of the standard library
20:30:39 <glguy> lunabot has MonadLib
20:30:45 <glguy> how do you ask it what type something has
20:30:49 <drguildo> ozy`: me neither, i think they just have some weird fetish for splitting packages up
20:31:02 <roconnor> glguy: I don't know
20:31:03 <Cale> drguildo: Well, to be fair, there's a light binary distribution of GHC as well, which doesn't include libraries such as network. But the optimal thing (in my mind) would be just to always include cabal-install with ghc, and then regardless of how little else was included, it would be possible to get stuff from Hackage.
20:31:04 <ozy`> drguildo: does it even get used by anything in base ubuntu?
20:31:27 <ozy`> Cale: that would be pretty awesome
20:32:02 <ozy`> Cale: in fact, that might be a good idea for the next version of GHC...
20:32:05 <roconnor> , let get = ask ; put = modify . const; modify f = callCC (\k -> ask >>= \i -> local (f i) (k ())) in runReader 5 (runContT return (do a <- get ; put (a + 1) ; b <- get ; return (a,b)))
20:32:06 <lunabot>  luna: No instance for (MonadLib.RunReaderM
20:32:18 <drguildo> ozy`: ghc? no. you need to enable an extra repository to even be able to install it.
20:32:31 <ozy`> drguildo: what?!
20:32:38 <geezusfreeek> and it's old
20:32:38 <Cale> It's just universe, isn't it?
20:32:46 <drguildo> Cale: yeah
20:32:50 <ozy`> what the hell man
20:32:57 <ozy`> that's just stupid
20:32:58 <Cale> I can't imagine living without universe.
20:33:15 <drguildo> that's basically the second-class citizen repository
20:33:20 <roconnor> right
20:33:21 <Cale> Well, I suppose I can. I just wouldn't use the package manager as much.
20:33:34 <drguildo> then multiverse is like "you're completely on your own"
20:33:38 <Cale> What does that make multiverse then? I suppose third-class.
20:33:42 <Cale> ah
20:33:43 <Cale> yes
20:34:09 <Cale> Universe is community supported.
20:34:10 <roconnor> glguy: no instance for RunReaderM (ContT ..)
20:34:37 <Cale> I suppose it is a bit much to ask for the core company to take care of all that themselves.
20:34:39 <toliko_smoren> i was talking about this, rotate90 boards = [findIndex (n==) boards] ++ (rotate90 (delete n boards)), how do I make findIndex be not Maybe Int but Int
20:35:07 <drguildo> i'm just going to try installing the generic linux "package" from the ghc website
20:35:08 <cads> roconnor: what happens if you do   'sudo apt-get install libghc6-cabal-dev' ?
20:35:50 <drguildo> anyway i don't think i'll report a bug
20:36:06 <drguildo> i think the problem's with ubuntu
20:36:23 <drguildo> and if i reported on there i can almost guarantee it'd get ignored for at least a year
20:36:26 <drguildo> no joke
20:36:45 <ozy`> drguildo: show up on the package maintainer's doorstep
20:36:47 <cads> drguildo: are you in debian or ubuntu?
20:36:56 <drguildo> cads: ubuntu
20:37:04 <roconnor> ooooh, there is an mmtl!
20:38:08 <roconnor> cads: sudo aptitude install libghc6-cabal-dev says ``No packages will be installed, upgraded, or removed.
20:38:22 <cads> drguildo: I'm trying to solve the problem of why cabal doesn't seem to be in any of the packages in debian.
20:38:50 <cads> roconnor: that's because libghc6-cabal-dev seems to be a meta-package whos dependency is satisfied by ghc6
20:38:57 <roconnor> yes
20:39:03 <cads> which is a little silly
20:39:09 <glguy> roconnor, the types don't work out
20:39:13 <roconnor> cads: why?
20:39:19 <glguy> roconnor, it is known to be missing :)
20:39:43 <roconnor> maybe I'd drop monadLib and use the mmtl
20:39:47 <drguildo> cads: good luck
20:39:54 <cads> roconnor, because the ghc6 package doesn't have cabal in it.  _unless_ there's a way of making ghc6 work like cabal?
20:40:16 <roconnor> cads: ah
20:40:43 <glguy> instance (RunReaderM m i m i) => RunReaderM (ContT x m) i (ContT x m) i where local i (C m) = C (local i . m)
20:40:44 <roconnor> ugh
20:40:46 <glguy> roconnor, ^
20:40:56 <cads> do apt-file search cabal, and you have a few different packages that have .cabal files in them, and the hugs version of cabal comes up, but no cabal executable
20:41:12 <roconnor> ugh, the mmtl has the stupid ErrorT
20:41:23 <jeffz`> the cabal executable is cabal-install cads, not part of Cabal
20:41:24 <roconnor> maybe I just need to write my own monad transformer lib
20:41:46 <glguy> roconnor, what would you change in monadlib?
20:41:52 <glguy> that leads you to needing your own new one?
20:42:05 <roconnor> glguy: http://hackage.haskell.org/packages/archive/mmtl/0.1/doc/html/Control-Monad-Trans.html
20:42:16 <roconnor> specifically tmap :: (Monad m, Monad n) => (forall a. m a -> n a) -> (forall b. n b -> m b) -> t m c -> t n c
20:42:45 <cads> jeffz, doing a file search for packages that have cabal-install in them finds nothing in all of debian testing. I'm thinking of shooting an email to the ghc maintainers
20:43:01 <jeffz`> cads, cabal-install isn't packaged, you have to build and install it from hackage
20:43:25 <roconnor> , let local0 i (C m) = C (local i . m); get = ask ; put = modify . const; modify f = callCC (\k -> ask >>= \i -> local0 (f i) (k ())) in runReader 5 (runContT return (do a <- get ; put (a + 1) ; b <- get ; return (a,b)))
20:43:27 <lunabot>  luna: Not in scope: data constructor `C'
20:43:27 <glguy> roconnor, you wouldn't be able to fit that into monad lib?
20:43:59 <jeffz`> cads, ie, download it, tar xf, ghc --make Setup, ./Setup configure, ./Setup build. ./Setup install
20:44:25 <cads> jeffz` There was an old version but it had become broken with the newer version of ghc6.  if it's the case that it's not packaged, I'd like to package it
20:45:03 <glguy> roconnor, I've pushed a commit for that instance to my fork
20:45:06 <jeffz`> cads, shrug.  I'm using 6.8.2 from Ubuntu, but I've installed cabal-install from hackage.
20:45:07 <glguy> roconnor, I'll prod yav later
20:46:49 <jeffz`> cads, I don't see much point in packaging it, since the install is per user and you can discard your ~/.ghc at anytime.
20:47:11 <roconnor> , let local0 i m = callCC (local i . flip runContT m); get = ask ; put = modify . const; modify f = callCC (\k -> ask >>= \i -> local0 (f i) (k ())) in runReader 5 (runContT return (do a <- get ; put (a + 1) ; b <- get ; return (a,b)))
20:47:12 <lunabot>  luna: Occurs check: cannot construct the infinite type:
20:47:13 <glguy> roconnor, you haven't answered yet, why not just add tmap to MonadT?
20:47:48 <roconnor> glguy: Well, yes maybe that is the way to go
20:48:20 <drguildo> this isn't good!
20:48:29 <cads> jeffz`, perhaps it could be installed in a global place, similar to ruby's gems manager.. but I see what you mean, the install is pretty painless.
20:48:30 <drguildo> i just installed the binaries off the ghc website
20:48:32 <jganetsk> does anyone understand how CAFs work internally?
20:48:38 <drguildo> and cabal-install bootstrap.sh still fails
20:48:43 <jganetsk> i have been looking at assembly code, and there seems to be unnecessary indirection
20:48:51 <drguildo> i removed all the old ghc packages and everything
20:49:05 <drguildo> now it's complaining that zlib is missing
20:49:10 <drguildo> something it installed before
20:49:23 <cads> jeffz`: I remember last time I installed cabal I had to manually fetch some extra dependencies. aaaah, I suppose I've just gotten fat and lazy here in debian
20:49:28 <drguildo> unless i'm missing something bootstrap.sh is very broken
20:50:13 <roconnor> glguy: I'm not yet sure how to properly use the mmtl
20:50:18 <drguildo> has anybody except me actually, you know, used it?
20:51:49 <drguildo> meh
20:51:53 <wahjava> hi all
20:52:02 <drguildo> hi
20:52:08 <wahjava> hi drguildo
20:52:29 * drguildo wonders under which circumstances bootstrap.sh works
20:52:50 <drguildo> i guess if all the dependencies are already satisfied
20:53:00 <drguildo> but then that almost defeats the purpose of it
20:53:17 <drguildo> unless i'm missing something
20:53:31 <wahjava> hey pumpkin
20:53:38 <pumpkin_> ?
20:53:40 <pumpkin_> hi
20:54:13 <wahjava> pumpkin_: I hope you remember me, i'm the *one* having doubt about simple state monad in YAHT.
20:54:23 <pumpkin_> yup
20:54:44 <drguildo> i guess if it fails with the binaries off the ghc website and with the latest darcs version then i'll file a bug
20:55:16 <wahjava> pumpkin_: as per your suggestion, I wrote that program without any explicit use of monad, but I'm unable to discover/invent the need of monad, other than for writing good looking programs
20:55:26 <drguildo> /usr/bin/ld: cannot find -lgmp
20:55:26 <drguildo> collect2: ld returned 1 exit status
20:55:27 <drguildo> wtf?
20:55:44 <pumpkin_> wahjava: how did you do it?
20:55:57 <wahjava> let me paste it.
20:56:24 <drguildo> writing good looking programs sounds like an awesome reason to me
20:57:12 <Cale> wahjava: The purpose of monads is the purpose of any abstraction: to save from rewriting code, and to give a uniform interface where available.
20:57:42 <dino-> drguildo: I use that bootstrap.sh, but sometimes you have to satisfy native lib deps to allow the Haskell libs to build.
20:57:45 <Cale> wahjava: The functions in Control.Monad are available for any monad at all, meaning that you don't have to write them over and over for various specific types.
20:57:49 <wahjava> pumpkin_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1342#a1342
20:58:09 <dino-> drguildo: Are you by any chance using a debian-based distro?
20:58:19 <drguildo> dino-: i sure am
20:58:20 <mmorrow> glguy> how do you ask it what type something has
20:58:26 <dino-> If so, you need libgmp3-dev
20:58:27 <mmorrow> , [$ty| \x -> x |]
20:58:29 <dino-> for that -lgmp
20:58:30 <lunabot>  forall a . a -> a
20:58:34 <mmorrow> , [$tyQ| \x -> x |]
20:58:37 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
20:58:47 <mmorrow> , src ''Maybe
20:58:50 <lunabot>  data Maybe a = Nothing | Just a
20:58:51 <mmorrow> , src 'Just
20:58:54 <lunabot>  data Maybe a_0 = ... | Just a | ...
20:58:54 <lunabot>  infixl 9
20:58:57 <dino-> Well, probably 3, check which are available with apt-cache search libgmp or similar
20:59:12 <mmorrow> hmm
20:59:14 <wahjava> Cale: I understand that thing, but the problem I'm having is in understanding getState and putState functions defined.
20:59:46 <Cale> wahjava: Oh, those sound specific to one particular monad.
20:59:54 <dino-> Something also about zlib above.. I have zlib1g-dev installed
20:59:56 <Cale> wahjava: Are you reading anything in particular?
21:00:05 <dino-> I'm using Debian lenny at the moment
21:00:12 <drguildo> dino-: thanks
21:00:52 <wahjava> Cale:  http://en.wikibooks.org/wiki/Haskell/YAHT/Monads#A_Simple_State_Monad
21:00:59 <Cale> okay
21:01:20 <Cale> So the fact that it's a monad doesn't really have anything to do with getState and putState.
21:02:04 <wahjava> Cale: okay.
21:02:14 <Cale> The purpose of getState is to be a computation whose result is the current state, and which doesn't itself change the state.
21:02:28 <kerlo> What's this Maybe a_0 thing all about?
21:02:57 <wahjava> Cale: and putState
21:03:01 <Cale> On the other hand, putState is a function which takes a value, and produces a computation which sets the state to that value, regardless of what it was before, and whose result is ()
21:03:24 <dino-> drguildo: Just checked a machine on our network with Ubuntu Intrepid on it, same libs: libgmp3-dev and zlib1g-dev. Both of these have GHC 6.10.1, Cabal 1.6.0.1 and cabal-install 0.6.0
21:04:06 <wahjava> Cale: but where is the state: cur <- getState ; putState (cur+1) ? how can you modify cur ?
21:04:29 <Cale> 'modify'?
21:04:32 <drguildo> dino-: it worked, thanks
21:04:36 <Cale> cur is a name for the result of getState
21:04:44 <dino-> drguildo: One thing I just thought to mention, sometimes I've changed the --user to --global in that bootstrap.sh and run it as root (and then ignore the final failure message). To just install that bad boy systemwide. If that works for you.
21:04:48 <Cale> So if getState produces a different result, then cur will be different.
21:04:48 <dino-> Just a thought.
21:04:51 <drguildo> it seems what it boils down to is that bootstrap.sh doesn't really help much
21:05:02 <mmorrow> , help
21:05:03 <wahjava> Cale:  okay.
21:05:04 <lunabot>  type of an expression:      , [$ty| \x -> x |]
21:05:04 <lunabot>  get info for a type/class:  , src ''Monad
21:05:04 <lunabot>  get info for a var/con:     , src 'fix
21:05:10 <wahjava> Cale: so it is like this:
21:05:16 <drguildo> ghc library management in general seems kinda crappy
21:05:21 <dino-> drguildo: It does and it doesn't. It does do the dl/cabal build/install of the 4 things for you.
21:05:28 <drguildo> i just tried to do a cabal upgrade and it failed
21:05:30 <dino-> But needs hand-doinking in my usage of it.
21:05:34 <dino-> :(
21:05:58 <wahjava> Cale: getState >>= putState (\x -> x + 1) >>= (\x -> (v, x)) ?
21:06:10 <Cale> > let inc = do x <- get; put (x+1); return x in runState (do x <- inc; y <- inc; z <- inc; return (x,y,z)) 0
21:06:11 <lambdabot>       Ambiguous occurrence `get'
21:06:11 <lambdabot>      It could refer to either `L.get', defin...
21:06:17 <Cale> grr
21:06:19 <mmorrow> heh
21:06:19 <Cale> @undefine
21:06:21 <Cale> > let inc = do x <- get; put (x+1); return x in runState (do x <- inc; y <- inc; z <- inc; return (x,y,z)) 0
21:06:23 <lambdabot>   ((0,1,2),3)
21:06:56 <Cale> wahjava: See how that works?
21:07:03 <Cale> wahjava: The initial state passed in is 0.
21:07:28 <sbahra> wahjava, :)
21:07:42 <sbahra> Not in channel?
21:07:55 <dino-> You know, I haven't really done the cabal upgrade yet. That's like bring all libs up to latest?
21:08:12 <wahjava> Cale: okay, any ideas if my guess is correct ? getState >>= putState (\x -> x + 1) >>= (\x -> (v, x)) ?
21:08:12 <dino-> s/libs/everythings that cabal ever installed/
21:08:12 <Cale> wahjava: So the 'get' in the first inc will have 0 as its result, and then the state will be updated by the put to (0+1) = 1, and 0 will be returned by the first inc.
21:08:33 <Cale> wahjava: That looks like it doesn't typecheck to me.
21:08:35 <wahjava> hey sbahra. I'm not at my place, just managed to steal some free time, so trying out haskell.
21:08:44 <sbahra> ic
21:09:04 <Cale> If you want...
21:09:25 <Cale> do x <- get; put (x+1)  =  get >>= \x -> put (x+1)
21:09:55 <Cale> Does that help?
21:10:20 <wahjava> Cale: yes, thanks :)
21:10:25 <Cale> So the result of 'get', which is the current state, will be bound to x.
21:10:31 <drguildo> i need to sleep
21:10:34 <Cale> Then put (x+1) will update the current state to x+1
21:10:34 <drguildo> thanks for the help guys
21:10:35 <wahjava> thanks pumpkin_ and Cale :)
21:10:59 <sbahra> Ah, no more chocolate.
21:11:06 <Cale> So the total effect is that it increments the state.
21:11:08 <sbahra> wahjava, what do you think of having a short meeting this weekend to discuss deadlines?
21:11:19 <Cale> My inc above did one extra thing:
21:11:23 <wahjava> so instead of storing state, we're simply transferring it between getState and putState
21:11:27 <Cale> do x <- get; put (x+1); return x
21:11:32 <sbahra> wahjava, this way we can have new-and-improved Haskell support for next release.
21:11:45 <Cale> Which is
21:11:55 <Cale> get >>= \x -> put (x+1) >> return x
21:12:18 <Cale> So instead of the result of this being ()
21:12:21 <pumpkin_> is shootout running 6.10 or 6.8?
21:12:24 <sbahra> wahjava, I have to sleep very soon, so let me know.
21:12:27 <Cale> it'll now be x
21:12:36 <Gracenotes> @quote fatmouse
21:12:36 <lambdabot> No quotes match. I feel much better now.
21:12:45 <Axman6> pumpkin_: 6.8 i believe
21:13:02 <wahjava> sbahra: i've no problems with meet. please post the time on the list.
21:13:16 <sbahra> wahjava, posting to both channels is annoying. Let's stick to one. :)
21:13:22 <sbahra> wahjava, ok, I'll send the e-mail.
21:13:27 <wli> modify (+1) doesn't seem to cut it.
21:13:31 <Cale> wahjava: The state is carried between each of the State monad computations which are chained together with >>= and >> and the other monadic combinators.
21:13:44 <mmorrow> , let bind x = modify (\(env,d) -> ((x,d):env,d)); pop n = modify (\(env,d) -> (env,d-n)); push n = modify (\(env,d) -> (env,d+n)) in runState ([],0) (push 20 >> bind "x" >> pop 7 >> bind "y" >> pop 10 >> bind "z" >> push 3)
21:13:46 <lunabot>  ((),([("z",3),("y",13),("x",20)],6))
21:13:51 <Cale> wahjava: And get and put are just primitive computations for accessing that.
21:13:57 <wahjava> sbahra: okay.
21:14:21 <mmorrow> (note that lunabot has monadLib so runState args are flipped, and s/put/set/)
21:14:48 <mmorrow> ((just in case that causes confusion))
21:15:05 <wahjava> Cale: okay. I guess I'll write some code myself, then I'll have better understanding of the concepts. thanks for your time :)
21:15:38 <cads> do you guys know where I could find a nice haskell cheatsheet that details layout and function specification, and stuff like let and in, and where?
21:15:49 <wahjava> Cale: btw, what is the significance of (), is this an empty tuple ?
21:15:54 <Cale> yes
21:16:10 <mmorrow> wahjava: it's kinda like "void" in C
21:16:17 <Cale> It's useful as the result type of a computation which has no interesting result.
21:16:18 <mmorrow> (but it actually is a value)
21:16:28 <byorgey> cads: try http://blog.codeslower.com/2008/10/The-Haskell-Cheatsheet
21:16:28 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:16:29 <Cale> The state monad is a tricky example for beginners to functional programming, since it makes use of functions in a way that most people are not used to.
21:16:38 <ozy`> wahjava: () is a useful value to return from a function which is called strictly for its side effects
21:16:40 <wahjava> mmorrow: oh, okay. () == state ?
21:16:53 <ozy`> wahjava: precisely because () means nothing useful
21:16:54 <wahjava> mmorrow: I mean is '()' a generic type.
21:17:01 <wahjava> ?
21:17:03 <mmorrow> err, () == "nothing but here's a ()"
21:17:08 <Cale> wahjava: the state type is usually not (), because () is too boring
21:17:21 <mmorrow> the type of () is (), and it has only one value which is ()
21:17:30 <mmorrow> (well, two values including undefined)
21:17:36 <mmorrow> @type ()
21:17:37 <ozy`> wahjava: () is the one and only value of a type which is also called ()
21:17:37 <lambdabot> ()
21:17:41 <wahjava> okay
21:17:53 <Gracenotes> there are two values for Bool: True and False. there is one value for (): it's ().
21:18:11 <Cale> wahjava: There would be no point in using the State monad if you chose () as your state type. The result of 'get' would always be (), and the only defined thing you could 'put' would be ().
21:18:12 <cads> byorgey: that cheatsheet's exactly what I needed, thanks
21:18:14 <Gracenotes> it's called "unit" (think "un" as in "unary", one)
21:18:26 <Axman6> wahjava: () is basically void in haskell
21:18:34 <Cale> Empty tuple is a good way to think of it.
21:18:54 <ozy`> wahjava: the reason () exists in the first place is partly that every haskell expression always has a return value.
21:19:49 <wahjava> okay.
21:20:04 <mmorrow> that's a better way to put it
21:20:06 <wahjava> thanks Cale, ozy` and Axman6 .
21:20:13 <mmorrow> you return () when you have nothing to return
21:20:19 <ozy`> Axman6: by the way I committed my patch today
21:20:28 <Axman6> oh awesome :)
21:20:30 <ozy`> Axman6: and I have commit rights for the haskell bundle
21:20:41 <sbahra> wahjava, http://haskell.org/onlinereport/exps.html#unit-expression
21:20:47 <Axman6> whoot :)
21:20:51 <ozy`> so any other things you notice that need fixing, I can fix and commit right away
21:21:06 <ozy`> Axman6: so hurry up and download the new version :p
21:21:12 <Axman6> :P
21:21:12 <mmorrow> foreign import ccall unsafe "free" c_free :: Ptr a -> IO ()
21:21:24 <mmorrow> void free(void *p)
21:21:33 <Axman6> ozy`: my current download status for anything: "16,455,748  --.-K/s  eta 45h 44m"
21:21:48 <ozy`> Axman6: wh... what
21:22:26 <Axman6> my ISP is being a ... @#%#$^@$% 2Y^@%&@$%^$%& @#$^!@# right now
21:22:38 <wahjava> sbahra: thanks. so it is a null expression, simply.
21:22:47 <sbahra> wahjava, not sure what you mean.
21:24:10 <Gracenotes> it's not null in the same way a value is null in Java/C++/etc.
21:25:10 <ozy`> wahjava: remember, () is its own type. you can't have a () of type String or Int... those are non-nullable
21:25:12 <sbahra> wahjava, it is a type and a value (data () = ()).
21:25:24 <sbahra> @info ()
21:25:24 <lambdabot> ()
21:25:26 <sbahra> Nice.
21:25:35 <sbahra> @src ()
21:25:35 <lambdabot> data () = ()
21:25:37 <Cale> ... what did that do?
21:25:43 <Cale> @info
21:25:44 <lambdabot> ()
21:25:47 <Cale> heh
21:25:48 <sbahra> @info 1
21:25:48 <lambdabot> 1
21:25:53 <sbahra> @info Eq
21:25:53 <lambdabot> Eq
21:25:54 <Gracenotes> lambdabot's @info strikes me as not terribly useful
21:26:00 <Gracenotes> it's basically a sophisticated echo
21:26:00 <sbahra> @info Hi dude
21:26:00 <lambdabot> Hi dude
21:26:12 <Cale> Oh, that's... odd.
21:26:18 <geezusfreeek> uhhhh
21:26:19 <sbahra> @info ctcp cale ping
21:26:19 <lambdabot> ctcp cale ping
21:26:34 <Gracenotes> @vixen Is lambdabot's @info useful?
21:26:34 <lambdabot> whoa whoa whoa, one question at a time!
21:26:40 <Gracenotes> @vixen sorry. Is lambdabot's @info useful?
21:26:40 <lambdabot> it's okay, i forgive you
21:26:40 <sbahra> @info Last test
21:26:40 <lambdabot> Last test
21:26:41 <Cale> @info @info
21:26:41 <lambdabot>  Parse error at "@info" (column 1)
21:26:52 <Cale> okay...
21:27:08 <sbahra> There's also another bug, I think.
21:27:12 <sbahra> :t True
21:27:12 <lambdabot> Bool
21:27:19 <sbahra> This doesn't work when PRIVMSGing lambdabot.
21:27:39 <Cale> But @type should
21:27:48 <sbahra> Yes, only @type, not :t.
21:28:04 <Cale> I think it's a consequence of how the shortcut was added.
21:28:07 <Gracenotes> yeah... I've noticed that too
21:28:09 <sbahra> @help
21:28:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:28:11 <sbahra> @list
21:28:11 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:28:22 <Gracenotes> how the shortcut was added? hastily?
21:28:36 <Cale> Gracenotes: probably
21:29:00 <sbahra> I guess this might be a good time for me to actually use darcs.
21:29:01 <Gracenotes> @ty -- is a @type alias (for instance)
21:29:02 <lambdabot> <no location info>: not an expression: `'
21:29:11 <Cale> :t and :k are special, and got added to the command parsing at a sort of high level, rather than being something that the plugins register in a uniform way
21:29:12 <lambdabot> parse error on input `,'
21:29:41 <Gracenotes> @t
21:29:41 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:29:48 <sbahra> @
21:30:03 <sbahra> @    type ()
21:30:14 <Gracenotes> what.. there are topic list functions?
21:30:17 <Gracenotes> @help topic-snoc
21:30:17 <lambdabot>  @topic-snoc #chan <mess> -- Add a new topic item to the back of the topic list
21:30:21 * sbahra notes fetching source takes a long time
21:30:24 <sbahra> Oh, very useful.
21:30:58 <Gracenotes> @help topic-cons
21:30:58 <lambdabot>  @topic-cons #chan <mess> -- Add a new topic item to the front of the topic list
21:31:06 <sbahra> @topic-tail
21:31:06 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
21:31:08 <sbahra> :)
21:31:14 <Gracenotes> oh, ha
21:31:26 <sbahra> @topic-tail Ab, b
21:31:26 <lambdabot> I do not know the channel Ab, b
21:31:32 <sbahra> @topic-tail #haskell
21:31:57 <geezusfreeek> ...
21:32:12 <geezusfreeek> @bot
21:32:12 <lambdabot> :)
21:32:12 <lunabot>  :)
21:32:12 <sbahra> <sbahra> @topic-tail ##FreeBSD
21:32:12 <sbahra> <lambdabot> Topic does not parse. Should be of the form ["...",...,"..."]
21:32:29 <Gracenotes> I find the name "snoc" amusing. Like cons's bastard son or something
21:32:32 <Axman6> @topic
21:32:32 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join oeis todo type
21:32:47 <sbahra> @topic-tell #haskell
21:32:47 <lambdabot> ["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://moonpatio.com", "
21:32:47 <lambdabot> Logs: http://tunes.org/~nef/logs/haskell/"]
21:32:50 <Axman6> whoops
21:33:00 <sbahra> @topic-tell #haskell-FreeBSD
21:33:00 <lambdabot> Coming soon: http://freebsd.haskell.org/ || Mailing list: http://www.haskell.org/mailman/listinfo/freebsd-haskell || FreeBSD tickets: http://hackage.haskell.org/trac/ghc/wiki/GHC-6.10.2
21:33:06 <sbahra> That's nice.
21:33:14 <Axman6> @topic-init
21:33:14 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
21:33:16 <sbahra> @topic-tell #C
21:33:16 <lambdabot> Do not know that channel
21:33:23 <sbahra> @topic-init #haskell
21:33:38 <Gracenotes> @topic-tell #0
21:33:39 <lambdabot> Do not know that channel
21:35:56 <cads> I've got this program to solve a project euler problem, but it seems like it's going to take at least ten thousand times longer than the sane example version.
21:36:13 <cads> this is the program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1343#a1343
21:36:17 <tonyIII_> I saw this error came up for array-0.1.0.0, where can I track its current status? "Duplicate instance declarations:       instance Typeable2 IOArray"
21:36:31 <cads> I've thrown about an hour of cpu time at it, and there doesn't seem to be any end in sight
21:36:54 <wli> There's some incomplete gamma function stuff, too.
21:37:28 <cads> so I was wondering two things, the first is if it would be easy to refactor the code so that it gave me a progress indicator, the second is if it would be very hard to refactor so that the tast was split between the four cpus on my brother's computer
21:37:38 <sbahra> cads, because I just can't read this properly, but I don't see a terminating condition for pathsBounces?
21:37:55 <sbahra> Oh, I'm not reading this properly. Nevermind. :)
21:39:45 <cads> well, basically pathsBounces calls laserPoints... laserPoints 1 10 figures out which of the points  [(1,10), (2, 9), (3,8), ..., (10,1)] have coordinates that are coprime
21:41:44 <cads> to give a simple example...  if you give it  a b, it will construct   [(a,b), (a+1, b-1), (a+2,b-2),... (b, a)], and count the coprime pairs in that
21:41:55 <sbahra> cads, yes and no, respectively. Parallelism is not difficult for this problem.
21:42:12 <sbahra> cads, learn about forkIO.
21:43:19 <cads> I think I really need to transform the algorithm into something more efficient
21:44:30 <cads> the 3rd example finishes in a couple seconds, but the number of pairs that need to be gcd
21:44:41 <cads> 'ed in the 4th example is about 1000 times larger
21:44:49 <cads> and over larger numbers
21:45:13 <cads> correction, 10,000 times larger :/
21:47:07 <cads> I need to return to the math
21:48:25 <ozy`> > (\a b -> zip [a..b] [b, b - 1 .. a]) 1 10
21:48:26 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
21:49:45 <cads> ah crikey
21:51:08 <cads> I didn't know you could use .. for other kinds of sequences
21:51:29 <zloog> anyone ever heard of Data.Data?
21:51:31 <ozy`> yeah you can
21:51:54 <ozy`> zloog: I have now
21:51:55 <Gracenotes> > (\a b -> zip `ap` reverse $ enumFromTo a b) 1 10
21:51:56 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
21:52:19 <Gracenotes> @pl \a b -> zip `ap` reverse $ enumFromTo a b
21:52:19 <lambdabot> ((zip `ap` reverse) .) . enumFromTo
21:52:21 <ozy`> hey, does GHC work with Haiku?
21:53:00 <_dolio> > (\a b -> let k = a + b in map (id &&& (k -)) [a..b]) 1 10
21:53:01 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
21:53:04 <zloog> ozy`: Yeah cabal is complaining about it not existing :(
21:53:08 <zloog> ozy`: o well
21:53:40 <QtPlatypus> :t (&&&)
21:53:41 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:55:12 <Gracenotes> (b -> c) -> (b -> c') -> b -> (c, c')
21:55:43 <cads> dolio, grace, what's so bad about about the list comprehension form:
21:55:49 <cads> > (\a b -> [(a+k ,b-k) |k <- [0..b-a]]) 1 10
21:55:50 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
21:56:33 <_dolio> Nothing. I just don't normally use them.
21:56:34 <Gracenotes> there's nothing so bad about any of the forms :)
21:57:24 * wli chokes on basic generalized continued fraction evaluation.
21:57:32 <Gracenotes> and dolio's version, as a list comprehension, looks like something like
21:57:37 <Gracenotes> > (\a b -> let k = a+b in [ (x, k-x) | x <- [a..b]]) 1 10
21:57:39 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
22:00:44 <Axman6> @hoogle ([a],[b]) -> [(a,b)]
22:00:45 <lambdabot> No results found
22:01:18 <dolio> > (\a b -> map ((a+) &&& (b-)) [0..b-a]) 1 10
22:01:19 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
22:01:22 <ozy`> :t uncurry zip
22:01:23 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
22:01:46 <ozy`> :t curry . uncurry
22:01:47 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
22:03:47 <rwbarton> Anybody here know what it means when Agda turns pieces of my program yellow?
22:04:04 <Pseudonym> Yes, time to change your toner cartridge.
22:04:05 <Axman6> yello feaver
22:04:12 <Axman6> w*
22:06:04 <dolio> > curry (((+) *** (-) >>> uncurry (&&&) >>> map) &&& (enumFromTo 0 <<< uncurry (flip (-))) >>> uncurry id) 1 10
22:06:05 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
22:06:39 <cads> hehe
22:07:07 <roconnor> glguy: oh ContT doesn't fit into the modular monad transformers framework
22:07:08 <Pseudonym> There's a lot of uncurrying there.
22:07:25 <Pseudonym> But I do like this:
22:07:29 <Pseudonym> :t uncurry (&&&)
22:07:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
22:07:35 <Pseudonym> I'll have to remember that one.
22:07:38 <glguy> roconnor, it doesn't?
22:07:38 <cads> any insights on how we may calculate the number of pairs in that list that are mutually prime?
22:07:46 <roconnor> nope
22:07:58 <glguy> roconnor, why does it have a MonadTrans instance?
22:08:06 <Pseudonym> > filter (\(x,y) -> gcd x y == 1) [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
22:08:06 <glguy> or doesn't it
22:08:07 <lambdabot>   [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
22:08:20 <Pseudonym> All of them.
22:08:22 <rwbarton> they all are, because all the pairs sum to 11 which is prime...
22:08:36 <roconnor> glguy: it does
22:08:42 <roconnor> glguy: which is very confusing
22:09:04 <zloog> Is there a way i can see the # versions of an installed package?
22:09:47 <Gracenotes> > filter (\(x, y) -> gcd x y == 1)  [(1,15),(2,14),(3,13),(4,12),(5,11),(6,10),(7,9),(8,8),(9,7),(10,6),(11,5),(12,4),(13,3),(14,2),(15,1)]
22:09:48 <lambdabot>   [(1,15),(3,13),(5,11),(7,9),(9,7),(11,5),(13,3),(15,1)]
22:09:54 <roconnor> glguy: maybe I should write to Mauro Jaskelioff
22:10:18 <cads> > blap a b = length $ filter (\(x, y) -> gcd x y ==1) $ [(a+k ,b-k) |k <- [0..b-a]] in blap 1 10
22:10:19 <lambdabot>   <no location info>: parse error on input `='
22:10:45 <Pseudonym> @pl \x y -> 1 == gcd x y
22:10:45 <lambdabot> ((1 ==) .) . gcd
22:10:52 <Gracenotes> > filter (((==1) .) . gcd)  [(1,15),(2,14),(3,13),(4,12),(5,11),(6,10),(7,9),(8,8),(9,7),(10,6),(11,5),(12,4),(13,3),(14,2),(15,1)]
22:10:52 <lambdabot>   Couldn't match expected type `Bool'
22:11:08 <Pseudonym> @pl \(x,y) -> 1 == gcd x y
22:11:08 <lambdabot> uncurry (((1 ==) .) . gcd)
22:11:19 <ozy`> :t (== 1) . gcd
22:11:20 <lambdabot> forall a. (Integral a, Num (a -> a)) => a -> Bool
22:11:20 <Gracenotes> oh, yeah, forgot about the (,)
22:11:36 <ozy`> :t (== 1) . (. gcd)
22:11:37 <cads> > blap a b = filter (\(x, y) -> (gcd x y) ==1) $ [(a+k ,b-k) |k <- [0..b-a]] in blap 1 10
22:11:38 <lambdabot> forall c a. (Integral a, Num (a -> c)) => ((a -> a) -> c) -> Bool
22:11:38 <lambdabot>   <no location info>: parse error on input `='
22:11:43 <ozy`> bleh
22:12:03 <ozy`> > (length / sum) [1..10]
22:12:04 <lambdabot>       No instance for (Fractional ([Int] -> Int))
22:12:04 <lambdabot>        arising from a use o...
22:12:08 <Axman6> > t (.).(.) (==1) gcd
22:12:09 <lambdabot>   Couldn't match expected type `((b1 -> c1) -> (a -> b1) -> a -> c1)
22:12:26 <Axman6> :t (.).(.) (==1) gcd
22:12:27 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
22:12:27 <lambdabot>     Probable cause: `.' is applied to too many arguments
22:12:27 <lambdabot>     In the second argument of `(.)', namely `(.) ((== 1)) gcd'
22:12:30 <Gracenotes> the way I think of it is: (. g) f is f x "dot g", and (g .) x is "g dot" $ f x
22:12:38 <roconnor> > liftM2 (/) length sum [1..10]
22:12:39 <lambdabot>       No instance for (Fractional Int)
22:12:39 <lambdabot>        arising from a use of `/' at <i...
22:12:42 <Axman6> :t (.).(. dgc) (==1)
22:12:43 <lambdabot> Not in scope: `dgc'
22:12:43 <Gracenotes> er, (g .) f
22:12:48 <Axman6> :t (.).(. ) gcd (==1)
22:12:49 <lambdabot>     No instance for (Integral Bool)
22:12:49 <lambdabot>       arising from a use of `gcd' at <interactive>:1:9-11
22:12:49 <lambdabot>     Possible fix: add an instance declaration for (Integral Bool)
22:12:52 <Axman6> bleh
22:12:52 <roconnor> > liftM2 (/) genericLength sum [1..10]
22:12:53 <lambdabot>   0.18181818181818182
22:13:26 <roconnor> > 10/55
22:13:27 <lambdabot>   0.18181818181818182
22:13:32 <ozy`> > liftM2 (%) length sum [1..10]
22:13:33 <lambdabot>   2%11
22:13:59 <Axman6> :t genericLength
22:14:00 <lambdabot> forall b i. (Num i) => [b] -> i
22:14:39 <ozy`> now why isn't the regular length generic?
22:15:13 <Gracenotes> because... dunno
22:15:29 <Axman6> > genericLength [1..10000] :: Complex CReal
22:15:33 <lambdabot>   10000.0 :+ 0.0
22:16:10 <ozy`> > genericLength [1..20] :: [Int]
22:16:11 <lambdabot>       No instance for (Num [Int])
22:16:11 <lambdabot>        arising from a use of `genericLength...
22:16:27 <Axman6> :t cis
22:16:28 <lambdabot> forall a. (RealFloat a) => a -> Complex a
22:16:43 <Gracenotes> > liftA2 (/) genericLength (fromIntegral sum) [1..10000] :: Complex CReal
22:16:44 <lambdabot>       No instances for (Integral ([a] -> a), Num ([b] -> Complex CReal))
22:16:44 <lambdabot>     ...
22:16:52 <Gracenotes> eek
22:17:03 <Gracenotes> ouch, bad idea. nevermind.
22:17:15 <cads> hey my computer just had a bad crash, lemme see if I can find the channel logs up until things reset
22:17:49 <byorgey> > liftA2 (/) genericLength (fromIntegral . sum) [1..10000] :: Complex CReal
22:18:03 <dolio> Because error messages with type classes are scary to newbies.
22:18:04 <lambdabot>   thread killed
22:18:09 <Gracenotes> heh >_>
22:18:17 <dolio> That's why map is lists only.
22:18:21 <wli> byorgey: That's terrifying; what's it do?
22:18:49 <dolio> And other such decisions.
22:18:51 <byorgey> wli: computes an average, looks like.  err... the reciprocal of the average?
22:19:18 <byorgey> I dunno, I was trying to fix Gracenotes's code =)
22:19:20 <Gracenotes> yeah, I must have switched about the functions. It's interesting, anyway
22:19:37 <ozy`> dolio: that's a problem with the error messages, not the definitions.
22:19:46 <Gracenotes> > liftA2 (/) (fromIntegral . sum) genericLength [1..10000] :: Complex CReal
22:20:01 <lambdabot>   thread killed
22:20:29 <dolio> Well, when you get your time machine, you can go back to 1998 and explain that to the haskell committee. :)
22:20:56 <Gracenotes> > (50005000 :+ 0) / (10000 :+ 0)
22:20:58 <lambdabot>   5000.5 :+ 0.0
22:21:02 <Gracenotes> :+0
22:21:07 <cads> >let blap a b = length $ filter (\(x, y) -> gcd x y ==1) $ [(a+k ,b-k) |k <- [0..b-a]] in map (\x -> blap x 100) [1..100]
22:21:23 <Gracenotes> 0.0
22:21:27 <cads> : (
22:21:44 <cads> lambdabot we're gonna have a personal chat
22:21:44 <Gracenotes> > (50005000 :+ 0) / (10000 :+ 0) :: Complex CReal
22:21:45 <lambdabot>   5000.5 :+ 0.0
22:22:07 <dolio> And then go back to 1992 and get some crystal pepsi.
22:22:25 <Gracenotes> > fromIntegral $ sum [1..10000] :: Complex CReal
22:22:26 <lambdabot>   50005000.0 :+ 0.0
22:22:33 <Gracenotes> > genericLength [1..10000] :: Complex CReal
22:22:37 <lambdabot>   10000.0 :+ 0.0
22:22:45 <Gracenotes> ..I don't see the thread killing problem :/
22:22:56 <byorgey> cads: you need a space between the > and the expression
22:23:03 <cads> > let blap a b = length $ filter (\(x, y) -> gcd x y ==1) $ [(a+k ,b-k) |k <- [0..b-a]] in blap 10 100
22:23:04 <lambdabot>   32
22:23:14 <cads> 32 is right!
22:23:14 <ozy`> > fromIntegral . liftA2 (/) (fromIntegral . sum) genericLength [1..20] :: Complex CReal
22:23:15 <lambdabot>   Couldn't match expected type `Complex CReal'
22:23:25 <ozy`> > (fromIntegral . liftA2 (/) (fromIntegral . sum) genericLength [1..20]) :: Complex CReal
22:23:26 <lambdabot>   Couldn't match expected type `Complex CReal'
22:23:33 <ozy`> meh
22:46:59 <redditbot> Gtk2HS 0.10.0 released! 6.10 support, and lots of cool new stuff
22:58:18 <wli> Okay, looks like it's \int_{-\infty}^x \frac{e^{Kt}}{t^2+1} dt = \sin K \cdot \matfrak{Re}\,\mathrm{Ei}(Kx+Ki)
22:58:41 <wli> Ei(z) has continued fractions and series for everything.
23:01:15 <wli> I only have a series for Ei(z) under the condition z is real and positive.
23:02:07 <wli> The continued fraction looks like it's a special case of Gauss' continued fraction and so globally convergent.
23:03:15 <wli> I see problems around K = \pi
23:15:48 <FunctorSalad> ghc panic upon trying to compile for profiling? :( "iface/TcIface.lhs:843:13-44: Irrefutable pattern failed for pattern [data_con]"
23:17:05 <Gracenotes> hm.. just what does mdo do?
23:17:16 <rwbarton> mmagic
23:17:34 <Gracenotes> how does it do it?
23:17:40 <rwbarton> mfix
23:17:57 <rwbarton> the translation is somewhat complicated
23:18:00 <Gracenotes> I'm aware of that.. but how would an mdo expression desugar?
23:18:23 <dolio> > mdo x <- [1:x, 2:x] ; return x
23:18:24 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:18:37 <dolio> > transpose $ mdo x <- [1:x, 2:x] ; return x
23:18:37 <rwbarton> it builds a tuple containing the LHSs of all <- statements plus the final value of the block
23:18:38 <lambdabot>   [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1...
23:19:05 <Gracenotes> > do x <- [1:x, 2:x] ; return x
23:19:05 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Expr'
23:19:06 <rwbarton> and passes a function on that type which is the body of the mdo block to mfix
23:19:13 <Gracenotes> ah.
23:20:14 <Gracenotes> would the use of mfix enable Y-combinator-esque recursion..?
23:20:38 <dolio> > runIdentity $ mdo x <- return (1:y) ; y <- return (2:x) ; return x
23:20:39 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
23:20:54 <rwbarton> yeah, mfix in the Identity monad is just fix
23:21:22 <dolio> Yeah. Makes mdo a let-alike.
23:21:23 <Gracenotes> > let x = (1:y); y = (1:x) in x
23:21:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:21:35 <Gracenotes> > let x = (0:y); y = (1:x) in x
23:21:36 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
23:21:38 <dolio> With differences in polymorphism, probably.
23:21:51 <Gracenotes> how about in, say, the list monad?
23:22:15 <Gracenotes> > mdo x <- [1..3]; return x
23:22:16 <lambdabot>   [1,2,3]
23:22:23 <Gracenotes> > mdo x <- [1..x]; return x
23:22:38 <lambdabot>   thread killed
23:22:43 <Gracenotes> > mdo x <- [1..3]; y <- [1..x]; return (x,y)
23:22:44 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
23:22:58 <rwbarton> > mdo y <- [1..x]; x <- [1..3]; return (x,y)
23:22:58 <Gracenotes> > mdo x <- [1..y]; y <- [1..x]; return (x,y)
23:22:59 <lambdabot>   * Exception: stack overflow
23:23:13 <lambdabot>   thread killed
23:32:10 <wli> Im(e^{iK}Ei(Kx-iK))
23:33:55 <wli> The problems around K=\pi are at least less apparent.
23:34:40 <zeno> @src mdo
23:34:40 <lambdabot> Source not found. stty: unknown mode: doofus
23:34:55 <zeno> @hoogle mdo
23:34:55 <lambdabot> keyword mdo
23:34:55 <lambdabot> package mdo
23:34:55 <lambdabot> package RandomDotOrg
23:36:22 * wli suddenly realizes that the fundamental recurrence relations are a bad way to evaluate generalized continued fractions.
23:36:53 <BMeph> zeno: Control.Monad.Fix
23:41:09 <Adamant> wli: do they cause any problems with recursion?
23:41:22 <Adamant> specifically not allowing tail-recursion
23:41:49 <Adamant> or is that a completely moronic question
23:41:54 <wli> Adamant: I've not thought about that. I'm thinking about floating point numerical affairs.
23:42:05 <Adamant> ah
23:49:08 <zeno> BMeph: thx
23:54:56 <wli> I think they're called Steed's method and Lentz' method.
