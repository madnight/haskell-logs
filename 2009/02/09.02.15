00:01:02 <dancor> it seems like A and B have to locally store change histories
00:01:26 <dancor> and the fun part is merging histories
00:01:50 <dancor> i'm not sure what exactly you have to trade-off to guarantee non-interactive conflict resolution
00:02:02 <dancor> def something
00:38:09 <Axman6> :t const (+1)
00:38:10 <lambdabot> forall a b. (Num a) => b -> a -> a
00:38:32 <pumpkin> Axman6: I'm making an epic ARM disassembler :D
00:38:38 <Axman6> > foldl' (const (+1)) 0 [1..10]
00:38:40 <lambdabot>   11
00:38:46 <Axman6> ah
00:39:10 <Axman6> pumpkin: how's it going? i would't be able to offer much, that HARM thing isn't my code
00:39:27 <pumpkin> it's going fine :) just thought you'd be interested
00:39:37 <pumpkin> I have it decoding all the basic arm instructions
00:39:42 <Axman6> > foldl' (flip const (+1)) 0 [1..10]
00:39:44 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
00:39:44 <lambdabot>      Proba...
00:39:53 <Axman6> bah
00:39:56 <pumpkin> and have just finished a useful generic representation of the instructions
00:40:05 <Axman6> nice :)
00:40:33 <Axman6> hey... it'd be nice if you could use the saem syntax as the HARM stuff, it's basically slightly modified ARM assembly
00:40:57 <Axman6> @pl (\acc x -> 1+acc)
00:40:57 <lambdabot> const . (1 +)
00:41:07 <Axman6> hmm, close
00:42:49 <pumpkin> I took a look at HARM but it doesn't support many instructions, but I might write a little converter for the subset it supports
00:43:05 <Axman6> that'd be awesome :)
01:14:36 <crutcher> Hi. I don't understand the kind error this is throwing: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1411#a1411
01:15:30 <crutcher> I'm trying to define a type class, and an instance. And I don't understand the parameterized type system enough to make it work
01:15:44 <crutcher> I'd appreciate a pointer, if anyone has time
01:16:02 <pumpkin> if you posted the error too it would help
01:16:22 <crutcher> Utils.hs:33:14:
01:16:22 <crutcher>     Kind mis-match
01:16:23 <crutcher>     Expected kind `* -> *', but `PJLHeap a' has kind `*'
01:16:23 <crutcher>     In the instance declaration for `Heap (PJLHeap a)'
01:16:47 <crutcher> I'd like to do something like: instance Heap PJLHeap where
01:16:53 <crutcher> but that is illegal
01:17:30 <pumpkin> why?
01:17:36 <crutcher> I'm trying to lift out a type class, and then play with different imps
01:17:47 <crutcher> I don't know why. When I try that, I get:
01:18:05 <crutcher> Utils.hs:35:0:
01:18:05 <crutcher>     Type synonym `PJLHeap' should have 1 argument, but has been given 0
01:18:06 <crutcher>     In the instance declaration for `Heap PJLHeap'
01:18:37 <crutcher> i don't _think_ Heap needs to be multi-parameter
01:18:44 <crutcher> but I'm not sure what I'm doing wrong.
01:21:25 <crutcher> is this a place where I should be using: class Heap h a | h -> a ?
01:23:31 <hydrapheetz> I'm ... horribly confused.
01:23:55 <Axman6> oh noes
01:24:36 <Axman6> what's wrong hydrapheetz?
01:24:40 <hydrapheetz> I'm going through Real World Haskell right now, and just finished doing chapter 3. I'm working on one of the questions which is to write an implementation of length
01:24:56 <hydrapheetz> I came up with this: length' (x:xs) = 1 + length' xs
01:25:18 <Axman6> should work, but i'm guessing you're getting a stack overflow?
01:25:21 <hydrapheetz> I'm still trying to figure out how that works
01:25:24 <hydrapheetz> nonono, it works
01:25:28 <Axman6> ok
01:25:40 <Axman6> (well, you will get a stack overflow with lonf lists ;)
01:25:45 <hydrapheetz> oh
01:25:48 <hydrapheetz> Works well with small ones
01:26:08 <Axman6> so what're you confused about?
01:26:25 <hydrapheetz> I'm just hung up on how something like what I came up with works the way it does
01:26:49 <crutcher> what, specifically, are you confused about
01:27:04 <BMeph> crutcher: Try: '(h :: * -> *)' :)
01:27:07 <hydrapheetz> oh
01:27:39 <Axman6> well, take it in steps. start with length' [1,2,3] -> 1 + length' [2,3] ->  1 + 1 + length' [3] -> 1 + 1 + 1 + length' [] -> 1+1+1+0
01:28:00 <hydrapheetz> wouldn't length' [1..10] just get turned into something like 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1? </3amLogic>
01:28:05 <hydrapheetz> oh, ninja'd.
01:28:11 <Axman6> yep
01:28:18 <crutcher> BMeph: as in: class Heap (h :: * -> *)? That gives me a parse error
01:28:24 <hydrapheetz> I wouldn't know where to begin to optimize that to avoid a stack overflow
01:28:55 <Axman6> hydrapheetz: well, to begin with, you can use an accumulating parameter, something like this:
01:29:07 <hydrapheetz> oh, with a wildcard?
01:29:37 <Axman6> length' xs = len xs 0; len [] acc = acc; len (_:xs) acc = len xs (acc+1)
01:29:42 <crutcher> BMeph: I don't understand your suggestion. Is what I did what you meant?
01:30:10 <Axman6> hydrapheetz: that's slightly better (i think), should produce a smaller thunk
01:30:52 <hydrapheetz> That just looks like a function inside a function, if I'm reading it right
01:30:59 <Axman6> yep, it is
01:31:13 <Axman6> but notice how len has an accumulating parameter?
01:31:18 <hydrapheetz> Oh, yeah
01:31:33 <hydrapheetz> so len xs 0 is where the new function is defined, then?
01:31:36 <ski_> crutcher : have you enabled `KindSignatures' ?
01:31:43 <BMeph> crutcher: Also, add '-XKindSignatures' to your options. :)
01:31:57 <Axman6> well, it's where it's used. the thing after the first ; is the definition of len
01:32:06 <BMeph> crutcher: Yes, that was wwhat I meant. :)
01:32:20 <ski_> crutcher : alternatively, `{-# LANGUAGE KindSignatures #-}' to the top of your module file
01:32:28 <BMeph> s/ww/w/
01:33:19 <Axman6> hydrapheetz: that functio will still create a stack overflow, but on longer lists i think. still, not good. ou're probably not far enough into haskell to be taught about $!, but i'll do it anyway i you like :P
01:33:44 <BMeph> ski_: That's not an alternative, that's an addition. ;)
01:33:47 <hydrapheetz> Well, I'm going through it a little at a time. I tend to be slow when learning new(er) languages.
01:33:59 <Axman6> hydrapheetz: well do you know what $ does?
01:34:05 <hydrapheetz> Function composition?
01:34:18 <Axman6> well, in a way. technicaly that's .
01:34:28 <hydrapheetz> er
01:34:45 <hydrapheetz> putStrLn $ show $ [1,2,3] would be putStrLn (show([1,2,3])) ?
01:34:59 <crutcher> Okay, did that, and it parses again. But I still get either a kind error if i use "instance Heap (PJLHeap a)" or a type parameter error if I use "instance Heap PJLHeap"
01:35:08 <Axman6> what it does is it lets you write things like f . g . h $ x, instead of writing (f . g . h) x, saves parens basically
01:35:33 <Axman6> hydrapheetz: usually you're write that as putStrLn . show $ [1,2,3]
01:35:40 <Axman6> you'd*
01:35:52 <hydrapheetz> Oh, didn't think that was possible
01:36:18 <Axman6> generally you ony ever use one $ in an expression like that. all the rest would be .
01:37:17 <hydrapheetz> Neat.
01:38:25 <Axman6> often you'll see things like f . g x . h y $ z
01:38:32 <Axman6> which becomes...
01:38:33 <BMeph> crutcher: Hm, try adding an 'a' after the h in the Heap class line, as well. :)
01:38:46 <Axman6> @unpl (\z -
01:38:46 <lambdabot> Unbalanced parentheses
01:38:50 <Axman6> @unpl (\z -> f . g x . h y $ z)
01:38:50 <lambdabot> (\ z -> f (g x (h y z)))
01:39:14 <hydrapheetz> That does look cleaner
01:39:32 <Axman6> it does take some time getting used to using function composition though
01:40:33 <Axman6> things like show . (+) seem fine, there's a function on both sides of the . , but (+) has the type a -> a -> a, not a -> b (or a -> a)
01:40:56 <crutcher> BMeph: bleh.  class Heap h where and instance Heap H where work fine, iff H is not a type synonym
01:41:14 <crutcher> so its some kind of interaction with type synonym parameters
01:41:21 <ddarius> crutcher: The Report disallows type synonyms to be used as class instances.
01:41:39 <crutcher> ddarius: Yes, which is why I was using TypeSynonymInstances
01:42:26 <crutcher> but even so, there seems to be some strange behaviour around type synonym instances where the type synonym is parameterized
01:42:35 <pk> hey
01:42:57 <ddarius> crutcher: You can't use partially applied type synonyms (for good reason)
01:42:59 <crutcher> and I don't know anywhere near enough to figgure out: a) what it is, and b) if it is legitimately a bug
01:43:08 <pk> I have a litle reactive question
01:43:27 <pk> what happens when Behaviors are recursives ?
01:43:38 <crutcher> ddarius: why not?
01:44:13 <ddarius> crutcher: Because, in the general case, it would correspond to having type level lambdas which would make type checking -significantly- more complicated.
01:44:56 <pk> should I make my own fix like function on behaviors to handle it ?
01:50:03 <pao> hydrapheetz: $ is function application
02:39:02 <Martijn> Is it possible to tell GHC -threaded on a per module basis, in some pragma?
02:39:26 <ddarius> No
02:39:41 <Martijn> So for a package the only place is in the .cabal file?
02:40:47 <ddarius> It might be possible to put the flag in a pragma, though I doubt it.  If you could, it certainly wouldn't apply to the one module only.
02:40:54 <Martijn> Do packages depending on a -threaded package need to set -threaded themselves, too?
02:42:34 <ddarius> The -threaded flag specifies which run-time to use.
02:42:52 <ddarius> The run-time is only linked in when actually building an application.
02:44:08 <Martijn> I'm using hWaitForInput in my library. I guess what I'm asking is: do I need to warn users to set -threaded, or can I do something that makes that automatic for them?
02:45:15 <ddarius> If you can put it in the .cabal file, what's wrong with that solution?
02:46:11 <Martijn> There's nothing wrong with that. :-) If that's sufficient, that's awesome. I'm just worried that packages depending on my package will need to be aware of the fact that my package is compiled with -threaded and take some action themselves.
02:49:04 <ddarius> You can try it and find out.  Make a small application and use cabal to build it and pull in your package and see if it gets built correctly.
02:49:39 <Martijn> Will do, thank you. :-)
02:50:07 <Martijn> Do you know when -threaded was introduced?
02:50:52 <ddarius> A good long while ago.  I don't remember when exactly off-hand.
02:51:31 * Martijn nods.
02:58:22 <dcoutts> Martijn: if you're writing a library then -threaded does not apply
02:58:49 <dcoutts> you cannot, as a library author, specify if -threaded is needed or not
02:59:20 <dcoutts> it is only at link-time that the version of the runtime to use is selected
02:59:25 <dcoutts> so it's apps that specify
02:59:43 <Martijn> So I should warn users of my library, then?
02:59:56 <dcoutts> perhaps, or try not to assume either model
03:00:43 <Martijn> That's be best, but I don't know how to -- I need to use hWaitForInput.
03:01:14 <thoughtpolice2> Unavoidable if you depend on nonblocking foreign calls though I guess
03:01:45 <Martijn> hWaitForInput is the only reason I need to use it. I don't do any FFI. But maybe I can write my own hWaitForInput that doesn't depend on -threaded?
03:02:10 <dcoutts> Martijn: I would not recommend it
03:02:28 <Martijn> What would you recommend?
03:02:37 <dcoutts> Martijn: just use the function and don't worry too much
03:02:55 <Martijn> Ok =)
03:07:39 <sannysanoff> hello gentlemen
03:07:43 <Martijn> Hallo
03:07:52 <sannysanoff> how to write IOUArray Int Int to a file and read it back then?
03:11:34 <sannysanoff> sunday, got it.
03:12:08 * robyonrails roby[away]
03:12:38 <Martijn> I'd answer your question if I could. :-)
03:12:54 <sannysanoff> Martijn, hehe
03:15:19 <ski_> (BMeph : sorry, i became engrossed in a conversation and forgot about the highlighting here)
03:42:03 <blancolioni> (tap tap) is thing on?
03:42:06 <blancolioni> good morning
03:42:37 <blancolioni> this is a new experience for me
03:43:29 <idnar> everyone is busy installing the new Debian release
03:43:42 * idnar hides
03:44:03 * kaol is busy preparing to break unstable with GHC 6.10.1
03:44:06 <blancolioni> oh, whoops, that might have sounded presumptive ..
03:44:18 <blancolioni> I don't know if this works or not, irc virgin typing
03:44:36 <kaol> welcome to #haskell
03:44:44 <blancolioni> well, thank you! :-)
03:45:04 <idnar> blancolioni: heh, I thought you meant that #haskell being quiet was a new experience
03:45:16 <idnar> blancolioni: anyhow, welcome :)
03:45:24 <blancolioni> ha!
03:45:32 <blancolioni> thanks
03:45:37 <blancolioni> I have a Question
03:45:38 <kaol> @users
03:45:38 <lambdabot> Maximum users seen in #haskell: 666, currently: 617 (92.6%), active: 15 (2.4%)
03:45:51 <blancolioni> say I'm developing a library package in ghc
03:46:02 <blancolioni> and I have a bunch of test programs
03:46:17 <blancolioni> how do I tell them to use the source tree instead of the previously installed package?
03:46:23 <blancolioni> -i ../src didn't seem to work
03:47:55 <yitz> deafening silence descends once again on #haskell
03:47:57 <redditbot> Arrow syntax ...
03:48:05 <blancolioni> luckily, the type checked ==> works feature of haskell makes this easier, because I can just install it before testing
03:48:24 <blancolioni> well, it is Sunday morning
03:48:38 <blancolioni> here
03:49:11 <yitz> blancolioni: support for test suites is probably the most often requested feature of cabal.
03:49:26 <yitz> blancolioni: i'm not sure how far along they are with that support though.
03:49:30 <blancolioni> ah
03:49:59 <yitz> dcoutts could tell you, if he is still listening
03:50:55 <blancolioni> well, no biggie
03:51:44 <yitz> blancolioni: you can leave your question for him with our bot
03:51:53 <blancolioni> lambdabot?
03:51:56 <FunctorSalad_> @bot
03:51:57 <yitz> yes
03:51:57 <lunabot>  :)
03:51:57 <lambdabot> :)
03:52:01 <yitz> @help ask
03:52:01 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
03:52:03 <dcoutts> @arr!
03:52:04 <lambdabot> I want me grog!
03:52:12 <blancolioni> lol
03:52:28 <blancolioni> cheers
03:53:13 <blancolioni> I loved the paper on not sandboxing lambdabot
03:53:18 <blancolioni> the things people come up with
03:53:29 <blancolioni> on sandboxing, whoops
03:53:34 <BONUS> everybody czech this out http://blog.sigfpe.com/2009/02/beyond-monads.html it's awesome
03:53:49 <dcoutts> blancolioni: at the moment the standard trick for test executables is to make then not buildable by default in release versions
03:53:56 <yitz> BONUS: dan is always awesome imho
03:54:55 <Heffalump> that idea isn't at all new, though
03:54:58 <BONUS> yeah
03:55:09 <BONUS> ah. it's new to me and i'm really thrilled by the concept
03:55:25 <BONUS> it's just one of those things that are so simple you go: why didnt i think of that
03:55:41 <blancolioni> dcoutts: so they get built normally after installation of the package?
03:56:39 <dcoutts> blancolioni: if the executables are marked not buildable in the released package then they will not get built
03:56:48 <dcoutts> blancolioni: for hacking you just make them buildable
03:57:12 <dcoutts> blancolioni: and when we add proper support for tests then you switch over to that :-)
03:57:30 <blancolioni> dcoutts: is there a way of telling ghc not to use a particular package?
03:57:42 <blancolioni> so that it looks in the source tree instead?
03:57:42 <dcoutts> blancolioni: -hide-package
03:57:47 <blancolioni> *laugh*
03:57:53 <dcoutts> blancolioni: it looks in the source tree first anyway
03:58:13 <blancolioni> I was about to ask if this was one of those blindingly obvious questions...
03:58:15 <blancolioni> does it/
03:58:17 <blancolioni> ?
03:58:19 <blancolioni> hmmmm
03:58:33 <blancolioni> I must have been dreaming
03:58:49 <dcoutts> blancolioni: -i../src should work if you've got a layout like $top/test/Foo.hs and $top/src/TheStuff.hs
03:58:59 <blancolioni> yes, that's what I have
03:59:13 <blancolioni> I thought that wasn't working for some reason
03:59:14 <ski_> the parameterized continuation monad is nice .. i've used it for some interesting looping operations
03:59:14 <blancolioni> weird
03:59:26 <dcoutts> blancolioni: maybe you forgot --make last time
04:00:37 <ski_>   arbitrary = liftM Sudoku $ evalLoopCT $
04:00:43 <ski_>     loopCT [1..9] `thenC2T`
04:00:47 <ski_>     loopCT [1..9] `thenC2T`
04:00:48 <ski_>     lift cell
04:01:04 * blancolioni does a head to desk
04:01:37 <blancolioni> uh, yeah, -i../src -- I have a strong memory of that not working ...
04:01:38 <ski_> where each `loopCT [1..9]' focuses the loop down from `[[Cell]]' to `[Cell]' and then to `Cell'
04:01:59 <mathijs> BONUS: when can I expect some new stuff in LYAH? I really like it but it has been silent for a few weeks now :(
04:02:05 <blancolioni> dcoutts: cheers!
04:02:26 <mathijs> BONUS: and don't forget to add a paypal thingy :)
04:02:31 <dcoutts> blancolioni: you're welcome :-)
04:02:52 <ski_> (`loopCT [1..9] :: Cont2T [b] b Gen Int' here)
04:03:12 <true\false> Is there paypal for LYAH?
04:03:23 <mathijs> nope
04:03:40 <ski_> (so, one could abstract out the "nesting" of the loops, without abstracting out the loop body)
04:03:47 <true\false> Hmm, even I think it deserves something.. Very nice introduction to Haskell
04:04:10 <mathijs> yup, that's why I'm asking
04:04:24 <BONUS> mathijs:  hey :)
04:04:37 <mathijs> hey
04:04:44 <BONUS> i've been really busy with school for the last couple of weeks but i'm picking up the pace today :]
04:04:54 <mathijs> nice
04:04:56 <BONUS> expect a new section today or tomorrow and then timely updates
04:05:00 <BONUS> cause i have some more freizeit
04:05:12 <BONUS> also hmm a paypal eh? maybe i'll add a link to a charity
04:05:56 <mathijs> BONUS: that's possible too. It's your money :P
04:06:25 <BONUS> adding a link to a charity instead of my own paypal just feels like it fits more with LYAH :]
04:06:34 <BONUS> good idea though yeah
04:09:18 <paper_cc> can one build HOpenGL with lhc?
04:10:26 <lebowski> Gasp
04:10:32 <lebowski> A Haskell channel with 600+ users
04:10:41 <Valodim> is that so surprising?
04:10:56 <lebowski> Indeed
04:11:00 <z0d> Valodim: It was for me
04:11:44 <paper_cc> @users
04:11:44 <lambdabot> Maximum users seen in #haskell: 666, currently: 620 (93.1%), active: 22 (3.5%)
04:11:55 <igel> evil! :)
04:12:02 <lebowski> hah
04:15:59 <blancolioni> Say one wanted to write a demo application for Yet Another Functional GUI Library
04:16:26 <blancolioni> if it happened that creating a 4e D&D character happened to be a perfect application to write
04:16:32 <blancolioni> would the nerdiness be overpowering?
04:16:46 <lebowski> Yes
04:16:50 <blancolioni> thought so
04:17:06 <tdanecker> @hoogle Either
04:17:07 <lambdabot> module Data.Either
04:17:07 <lambdabot> Prelude data Either a b
04:17:07 <lambdabot> Data.Either data Either a b
04:17:11 <lebowski> Just bein' honest
04:25:05 <chrisdone> haskelldb looks pretty cool
04:25:14 <AllNight^> haskelldb?
04:25:26 <paper_cc> @hoogle haskelldb
04:25:27 <lambdabot> package haskelldb
04:25:27 <lambdabot> package haskelldb-dynamic
04:25:27 <lambdabot> package haskelldb-flat
04:25:29 * AllNight^ doesnt think he's heard of that :)
04:25:31 <ski_> @where haskelldb
04:25:32 <lambdabot> http://haskelldb.sourceforge.net/
04:25:39 <AllNight^> ty :)
04:26:35 <tux_rocker> is haskelldb that package where you specify database queries in an embedded domain-specific langueage?
04:26:54 <chrisdone> yeah
04:28:12 <chrisdone> I'm just reading the paper, it seems pretty haskelly to have a type safe query language
04:28:20 <chrisdone> http://haskelldb.sourceforge.net/haskelldb.pdf
04:28:46 <AllNight^> does this use the HList library?
04:29:39 * AllNight^ thinking of some other Haskell DB stuff he's seen
04:29:39 <chrisdone> dunno, I don't think so
04:34:04 <chr1s> I think HaskellDB suffers from bit rot. (at least the last time I checked)
04:38:27 <BONUS> anyone written anything on parametrised monad transformers?
04:38:49 <BONUS> i'm trying to write a class and i wonder if the underlying monad should be Monad or ParametrisedMonad
04:40:47 <ski_> BONUS : what are you trying to write ?
04:40:58 <BONUS> ParametrisedMonadTrans class
04:41:12 <BONUS> i'm just fiddling with the idea if those parametrised monads have transformers
04:41:15 <BONUS> and what they're like
04:42:02 <ski_> interesting question
04:42:24 <BONUS> is it plift :: Monad m => m a -> t m s s a
04:42:32 <ski_> pm :: (* -> * -> * -> *)
04:42:51 <ski_> pt :: (* -> * -> * -> *) -> (* -> * -> * -> *)  -- i'd suppose
04:42:55 <BONUS> or is it plift :: PMonad m => m s1 s2 a -> t (m s1 s2) s1 s1 a
04:43:23 <ski_> BONUS : depends on whether you want to lift a monad or a parameterized monad
04:43:35 <BONUS> yeah i guess that's true. i wonder which might be more useful
04:43:38 <ski_> instinctly, i'd try the latter
04:43:49 <ski_> (and use explicit coercions for the former)
04:44:18 <ski_> (i.e. `paramState :: State s a -> State2 s s a', et.c.)
04:44:40 <BONUS> hmm
04:44:52 <ski_> (though it might be nice with a class for this too, i suppose .. just like lifting monads into transformers)
04:47:19 <tux_rocker> chr1s: a new version of haskelldb was released last friday
04:48:06 <ski_> so, hm
04:48:30 <ski_> let's try to figure out a parameterized state monad transformer, yea ?
04:49:25 <BONUS> yeah hmm
04:50:19 <BONUS> i was toying with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1414#a1414
04:50:25 <ski_>   newtype State2 s0 s1 a = MkS2 {unS2 :: s0 -> (s1,a)}  -- the non-transformer
04:50:31 <chr1s> tux_rocker: awesome
04:50:38 <BONUS> yeah
04:51:14 <BONUS> newtype State2T m s0 s1 a = MkS2 { unS2 :: s0 -> m (s1, a)} -- this as the transformer?
04:51:17 <BONUS> or could it be
04:51:49 <BONUS> newtype State2T m s0 s1 a = MkS2 { unS2 :: s0 -> m s0 s1 (a, s1) }
04:52:18 <ski_> i'm not sure
04:52:36 <ski_> also, i'm not sure about
04:52:38 <ski_>   lift' :: (PMonad m) => m s1 s2 a -> t (m s1 s2) s3 s3 a
04:52:45 <BONUS> yeah me neither
04:53:21 <ski_> hmm
04:53:24 <BONUS> if you have a normal monad as the underlying monad, i have a feeling it all ends up being rather simple and not new/interesting
04:53:40 <ski_>   newtype State2T t s0 s1 a = MkS2T {unS2T :: ?}
04:53:43 <ski_> with
04:53:48 <ski_>   t :: * -> * -> * -> *
04:53:53 <ski_> was my thought
04:54:19 <ski_> but i can now just imagine `?' as `t s0 s1 a', which doesn't seem very profound
04:54:35 <BONUS> hmm
04:54:42 <BONUS> yeh it just looks like a wrapper then
04:54:54 <ski_> possibly what we need is type records, so that we could do
04:55:09 <BONUS> hmm yes maybe
04:55:30 <ski_>   newtype State2T t (s0,s0') (s1,s1') a = MkS2T {unS2T :: s0 -> t s0' s1' (s1,a)}
04:55:48 <ski_> where  s0'  and  s1'  are the parameters to pass to `t'
04:56:13 <BONUS> ah
04:56:25 <BONUS> so they'd be passed to t in the lifting operation then?
04:57:05 <ski_> (note that  (s0,s0')  is meant to be a *pair* of two types, here .. *not* the type of pairs of values of the respective types !)
04:57:31 <ski_> (here the haskell notation of `(a,b)' for the pair-type is really bothersome)
04:57:34 <BONUS> yeah, so it's not the (,) type constructor with 2 types but a pair of types
04:57:41 <ski_> *nod*
04:57:42 <BONUS> that always kind of bothered me too
04:58:16 <ski_> (we could for the moment write the pair-type of `a' and `b' as `Pair a b', should we need to use it)
04:58:19 <ski_> i.e.
04:58:26 <ski_>   newtype State2T t (s0,s0') (s1,s1') a = MkS2T {unS2T :: s0 -> t s0' s1' (Pair s1 a)}
04:58:40 <BONUS> ooh, resourceful
04:59:24 <BONUS> how would you define lift then
04:59:40 <ski_> so, a `lift' operation here should, imo, map from an underlying `t' into `State2T', using trivial state parameters for the "outer part"
04:59:45 <ski_> i.e. possibly
05:01:02 <BONUS> that looks good yeah, seems like they could be stacked that way
05:01:02 <ski_> (hm, sorry, i was above using `t' for the parameterized monad .. imagine i had used `pm' instead)
05:01:10 <BONUS> yeah
05:01:29 <BONUS> also i thought about using normal monads for the underlying monads but it just doesnt make sense because you can't stack them that way
05:01:47 <Phil88> hey all
05:01:47 <BONUS> so an underlying PMonad is the way to go yeah
05:01:52 <BONUS> hi
05:01:54 <ski_>   plift :: forall s s0 s1 s1' pm. PMonad m => pm s0 s1 a -> pt pm (s,s0) (s,s1) a
05:02:00 <blancolioni> hi Phil
05:02:16 <ski_> (renamed your `t' into `pt')
05:03:09 <BONUS> you mean PMonad pm?
05:03:28 <true\false> Question on functional decomposition.. Is it just essentially saying that passing the result of one function into another function?
05:04:50 <BONUS> would this still keep the semantics if we wrote pm s0 s1 a -> pt pm s s0 s s1 a
05:05:04 <Phil88> i was hoping someone could help me write a haskell function? I'm new to functional programming, so still have a lot of concepts to grasp. The function needs to take 2 Ints, and decide whether or not one Int is divisible by the other, and return a Boolean to represent that. This (http://pastebin.com/d11620b78) is what I've come up with so far, but it doesn't work :\
05:05:05 <BONUS> i.e. if we dropped type pairs because they can be confusing due to lack of good notation
05:06:03 <BONUS> Phil88: you have to do mod x y or x `mod` y
05:06:11 <BONUS> because mod is just a normal function like any else
05:06:32 <BONUS> so you have to call it normally or surround it in backticks, in which case you can call it sandwiched between two operators
05:06:39 <BONUS> s/operators/operands
05:06:57 <Phil88> ah, thanks a lot! It works :D
05:07:01 <BONUS> :]
05:07:14 <Phil88> figured it probably was something trivial :p
05:07:38 <BONUS> although you don't have to use guards and then return True or False
05:07:40 <BONUS> you can just do
05:07:53 <BONUS> divisibleBy x y = x `mod` y == 0
05:08:17 <BONUS> because == returns a True or a False either way
05:08:22 <Phil88> ah, because x `mod` y == 0 will just evaluate
05:08:26 <BONUS> it's not just for using in if expressions or guards
05:08:27 <BONUS> exactly
05:08:47 <ski_> BONUS : er, yes `PMonad pm' (i was about to write that, but apparently forgot)
05:10:07 <ski_> true\false : if you mean `functional *composition*', then yes
05:11:21 <ski_> BONUS : no `pm s0 s1 a -> pt pm s s0 s s1 a' there would prohibit composing (a parametric monad transformer like) `State2T' with itself
05:12:13 <ski_> (since `pm' would not have same kind as `pt pm')
05:12:31 <BONUS> ah, you're right
05:12:35 <BONUS> what about IdentityT
05:12:42 <BONUS> could we write that
05:12:44 <ski_> (it might be that one could do something if one had kind polymorphims .. i'm not sure)
05:13:26 <ski_> `IdentityT' being what ? a paremeterized monad ? a parameterized monad transformer ?
05:13:36 <BONUS> i mean PIdentity
05:13:38 <ski_> (recall that `Identity' is a monad, not a monad transformer)
05:13:38 <BONUS> whoops
05:14:21 <mmorrow> gah, i'm so used to haskell i forgot a return stmt in C and was trying to figure out where the segfault was happening for 20 minutes
05:14:37 * ski_ grins
05:14:42 <ivanm> mmorrow: lol
05:14:43 <Axman6> heh :)
05:14:50 <mmorrow> :)
05:14:50 <BONUS> basically the parametrized monad to serve as the identity on parametrized monad transformer stacks
05:14:53 <Axman6> @remember mmorrow gah, i'm so used to haskell i forgot a return stmt in C and was trying to figure out where the  segfault was happening for 20 minutes
05:14:53 <lambdabot> Nice!
05:14:56 <true\false> ski_: Indeed I do, thanks
05:15:17 <mauke> Axman6: enable compiler warnings
05:15:20 <ski_> BONUS : ok
05:15:27 <mauke> oops
05:15:43 <ski_>   newtype Identity2 ? ? a = MkI2 {unI2 :: ?}
05:15:43 <mauke> I need to stop using approximate matching when reading IRC messages
05:15:48 <Axman6> mauke: s/Axman6/mmoorrow?
05:15:50 <Axman6> -o
05:15:59 <ski_>   newtype Identity2 () () a = MkI2 {unI2 :: a}  -- imo
05:16:20 <ski_> (`()' being the empty type tuple, not the unit type)
05:17:00 <BONUS> ah
05:17:04 <BONUS> let me try and write out an instance
05:18:33 <BONUS> hmm we can't just write newtype Identity2 s1 s2 a = MkI2 {unI2 :: a} ?
05:18:40 <ski_> (one could also consider writing an concrete inclusion from a monad `m' to a parameterized monad `pm' .. like `newtype MakeMonad2 () () m a = MkM2 {unM2 :: m a}')
05:19:21 <Axman6> could someone explain what [ALWAYS Just L] means in Core?
05:19:50 <ski_> BONUS : i'm not sure whether that would be a valid appoximation
05:19:59 <BONUS> yeah hm
05:20:29 <ski_> BONUS : you might try approximating type tuples with tuple types, using GADT to declare the correct constructor types
05:20:34 <BONUS> how about a PMonadLift class that allows lifting from normal monads to parametrized ones? think that's worth exploring further?
05:20:45 <ski_> (i'd sad there's no GADT `newtype's ..)
05:20:55 <BONUS> hmm
05:21:10 <ski_>   data Identity2 :: * -> * -> * -> *
05:21:12 <ski_>     where
05:21:24 <ski_>     MkI2 :: a -> Identity2 () () a
05:21:45 <BONUS> ooh, nice
05:21:59 <ski_> yes, such a lifting class might be useful (like i said before)
05:22:03 <ski_> just like a class
05:22:35 <ski_>   class MonadToTrans m t | m -> t , t -> m
05:22:37 <ski_>     where
05:23:03 <BONUS> you mean MonadToPMonad or something?
05:23:04 <dolio> Proof irrelevant GADTs?
05:23:05 <ski_>     toTrans :: forall a n. Monad n => m a -> t n a
05:24:00 <ski_> dolio : well, proof irrelevance would imply the whole of a value of type `Identity2 s0 s1 a' would be irrelevant, not just the outer constructor, no ?
05:24:18 <dolio> Something like that.
05:24:35 <ski_>     fromTrans :: forall a. (forall n. Monad n => t n a) -> m a
05:24:51 <dolio> Although as I understand it, some of the technicalities of proof irrelevance are similar to newtypes.
05:25:00 <ski_> quite possible
05:25:03 <dolio> Namely that you can pattern match on them, but evaluation is still lazy.
05:25:21 <ski_> so, e.g. we'd have
05:25:43 <mmorrow> mauke: good suggestion
05:25:43 <ski_>   toTrans :: forall s a n. Monad n => State s a -> StateT s n a
05:26:03 <ski_>   fromTrans :: forall s a. (forall n. Monad n => StateT s n a) -> State s a
05:26:06 <mmorrow> mauke: i just found another :/
05:26:10 <mauke> preflex: ? cflags
05:26:11 <preflex>  -std=c89 -pedantic -Wall -W -Wno-missing-field-initializers -Wundef -Wendif-labels -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -O2
05:26:24 <ski_> one might consider the alternate typing for `fromTrans' as
05:26:26 <mmorrow> preflex: help
05:26:27 <preflex>  try 'help help' or see 'list' for available commands
05:26:30 <mmorrow> preflex: list
05:26:31 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
05:26:39 <ski_>     fromTrans :: forall a. t Identity a -> m a
05:27:15 <ski_> (and maybe for `toTrans' too, though that then really needs `MonadFunctor' to be useful)
05:27:40 <Saizan> MonadFunctor?
05:27:52 <ski_>   class MonadFunctor t
05:27:54 <ski_>     where
05:28:15 <Axman6> no one knows what [ALWAYS Just L] means in Core?
05:28:24 <ski_>     tmap :: forall m n a. (Monad m,Monad n) => (forall x. m x -> n x) -> t m a -> t n a
05:28:28 <ski_> compare with
05:28:37 <ski_> @type Control.Monad.State.mapStateT
05:28:39 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
05:28:47 <ski_> @type Control.Monad.Writer.mapWriterT
05:28:48 <lambdabot> forall (m :: * -> *) a w (n :: * -> *) b w'. (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
05:28:53 <ski_> @type Control.Monad.Cont.mapContT
05:28:55 <lambdabot> forall (m :: * -> *) r a. (m r -> m r) -> ContT r m a -> ContT r m a
05:28:56 <ski_> et.c.
05:29:46 <ski_> `tmap' allows one to change the "underlying monad" in a monad stack, but keeping the uppermost level
05:30:01 <BONUS> i wonder what sigfpe and the rest of haskell-cafe would think about these parametrized monad transformers
05:30:22 <Axman6> bloody hell Core naming is terrible :( so hard to follow
05:30:49 <ziman> it should use randomly chosen cracklib words :)
05:30:56 <blancolioni> ^+^_shpn [ALWAYS Just L] :: (a_agws Data.Maclaurin.:> u_agww)
05:30:56 <ski_> (Axman6 : i assume `ALWAYS' is not just the name of a data constructor ..)
05:31:07 <blancolioni> that's not obvious?   :-)
05:31:14 <Axman6> ski_: nope
05:31:19 <pejo> Axman, isn't the ALWAYS some kind of inlining-information?
05:31:41 <Axman6> could be, it's used like this: n_aCj [ALWAYS Just L] :: Int#
05:33:16 <ski_> BONUS : you could send off a post, if you think you can present the stuff ok
05:34:24 <BONUS> i think you'd do a better job at it :) but i can try
05:34:46 <Axman6> how do you get GHc to keep the intermediate C files?
05:34:50 * ski_ hasn't yet dared to attempt anything re mailing-lists
05:35:13 <BONUS> yeah me neither
05:35:28 <mauke> .oO( I wish gavin would come back so I could test my script )
05:37:34 <ski_> (btw, obviously `MonadFunctor' is a generalization of `FunctorFunctor')
05:38:07 <Saizan> BadgerBadger?
05:38:25 <ski_> no funghi for me, thank you very much
05:38:39 <ivanm> ski_: how bout roast reptile?
05:38:51 <ivanm> ;-)
05:38:55 * ski_ wonders whether `MonadFunctor' would actually be needed for the above maps in `Control.Monad.*'
05:39:05 <idnar> MultiFunctor
05:39:45 <ski_> (also, obviously this naming is irksome .. what we'd really want is classes that are parameterized by both kinds and types)
05:40:20 <ski_>   class Functor k0 k1 (f :: k0 -> k1)
05:40:23 <ski_>     where
05:40:25 <ski_>     ...
05:40:42 <ski_> (possibly the kind arguments to `Functor' could be inferred)
05:42:02 <ski_> then `FunctorFunctor' would just be this above `Functor' with `k0' and `k1' both being something like `(f :: * -> *) | Functor f'
05:42:27 <mmorrow> this is a cool C one-liner:
05:42:29 <mmorrow> main(){((long int(*)(long int,int,void *,size_t))(dlsym(dlopen("/lib/libc.so.6",RTLD_LAZY|RTLD_LOCAL),"syscall")))(__NR_write,1,"qwerty\n",7);}
05:42:30 <hackage> Uploaded to hackage: hsql-postgresql 1.7.3
05:42:42 <mmorrow> (#include <dlfcn.h> #include <sys/syscall.h>)
05:42:58 * ski_ suspects the above utterances appear like incomprehensible nonsense to most mylookers
05:43:07 <augustss> looks fine to me
05:43:13 <mmorrow> :)
05:43:45 <Saizan> FunctorFunctor should be the one with f :: (* -> *) -> *, no?
05:44:04 <Saizan> so k0 = * -> *, k1 = *
05:44:04 <ski_> no, `(* -> *) -> (* -> *)' i was aiming for
05:44:11 <mauke> http://mauke.ath.cx/stuff/c/bin.c ,  http://mauke.ath.cx/stuff/c/hell.c (now with bsd support)
05:44:12 <Saizan> ah
05:44:16 <augustss> mmorrow: but i'm not sure why you'd want to do it
05:44:58 <ski_> (though, if the one with `(* -> *) -> (* -> *)' is `FunctorFunctor', i'm not sure what to call the one with `(* -> *) -> *')
05:45:31 <mmorrow> augustss: "just cuz" ;)
05:45:56 <augustss> mmorrow: it's unportable.  In at least two ways.
05:46:01 <blancolioni> gcc oneline.c
05:46:02 <blancolioni> /tmp/ccY5RC3Q.o: In function `main':
05:46:02 <blancolioni> oneline.c:(.text+0x13): undefined reference to `dlopen'
05:46:02 <blancolioni> oneline.c:(.text+0x20): undefined reference to `dlsym'
05:46:14 <mmorrow> augustss: what are they?
05:46:19 <wahjava> blancolioni: you need -ldl
05:46:24 <mmorrow> ooh yeah, that too
05:46:27 <blancolioni> lol
05:46:43 <wahjava> blancolioni: BtW, this is not a C language channel ;)
05:46:54 <mm_freak> is there any way to allow infinite types?
05:46:56 <mmorrow> augustss: (other than the hard-coded libc filename)
05:47:04 <blancolioni> wahjava: *laugh*
05:47:13 <augustss> mmorrow: well, who says libc in in /lib/libc.so.6?
05:47:26 <ski_> mm_freak : yes, name them as a `data' or `newtype'
05:47:41 <mm_freak> ski_: same thing
05:47:49 <ski_> (or use predefined names as `Mu')
05:47:53 <augustss> mmorrow: also casting a void* to a function pointer is nit guaranteed to work on all platforms.
05:48:10 <mm_freak> ski_: my case is a little bit more complicated, as it seems…  newtype does not resolve the problem
05:48:11 <mmorrow> augustss: ahhh, interesting.
05:48:14 <Peaker> IMO:Overloading that is used for extra convenience, rather than extra power, is usually misguided
05:48:15 <mauke> augustss: those platforms can't use dlsym then anyway
05:48:26 <augustss> very true :)
05:48:29 <mmorrow> heh
05:48:47 <ski_> mmorrow : function pointer can, however, be safely casted into any other function pointer type (and back), istr
05:48:54 <augustss> yep
05:48:58 <paper_cc> mauke: why? can't there be UNIXes with segmented memory?
05:49:25 <mauke> what does segmented memory have to do with it?
05:49:31 <augustss> you could imagine having two kinds of dlsym: dlsumfun, dlsymnonfunc
05:49:52 <mauke> s/nonfunc/obj/ :-)
05:49:59 <ski_> aye
05:50:02 <mmorrow> hmm
05:50:03 <paper_cc> mauke: take DOS compact memory model
05:50:04 <trofi> dlnosym
05:50:27 <augustss> mauke: AIX on Power was like thart.
05:50:29 <paper_cc> mauke: function* is short, data* is long
05:50:31 <augustss> that.
05:50:55 <paper_cc> mauke: or just separate Read-Write and Execute-Noread memory segments
05:50:57 <true\false> Still not entirely clear on functional composition..
05:51:15 <ski_> true\false : any particular example troubling you ?
05:51:16 <augustss> PDP1/34
05:51:19 <true\false> Oh, one secnd..
05:51:21 <blancolioni> true\false: as in f . g ?
05:51:22 <augustss> PDP11/34
05:51:33 <mauke> paper_cc: so how did it do dlsym()?
05:51:51 <true\false> blancolioni: Yes.. And I just got my example to work, but I'm only so-so clear on this
05:51:51 <blancolioni> augustss: pdp11 -- best architecture ever
05:52:04 <augustss> blancolioni: I have to agree!
05:52:20 <Axman6> true\false: understanding the type of (.) helps a lot
05:52:21 <paper_cc> mauke: DOS didn't =) but there still are segmented architectures. are they out of luck with dlsym()?
05:52:36 <wahjava> anyone using Emacs CVS and GHCi ?
05:52:41 <trofi> how do they handle 'void *' ?
05:52:45 <mmorrow> mauke: your hell.c trashes the stack and/or the regs. i tried mmaping /dev/zero, writing the hell data to it, and calling it. it works, but segfaults if you try to call it again/random other things
05:52:49 <true\false> Axman6: Erm I might have it actuially
05:53:03 <Axman6> :t (.)
05:53:05 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:53:27 <mauke> weird
05:53:36 <mmorrow> mauke: i'll paste it
05:53:57 <mauke> mmorrow: http://rafb.net/p/u1zOwE43.html
05:54:24 <mauke> maybe it doesn't like how I mess with %ebp
05:54:38 <ski_> (.) :: (c <- b) -> (b <- a) -> (c <- a)
05:54:58 <mm_freak> this is the problematic code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1415#a1415
05:55:08 <wahjava> anyone experience this issue ( http://groups.google.com/group/comp.emacs/browse_thread/thread/d4b1fa8deebf01c4/f52c82bd347dd066 ) with GHCi and Emacs CVS ?
05:55:13 <mm_freak> newtype did not resolve the infinite type problem
05:55:21 <wahjava> s/ence/encing/
05:56:32 <mm_freak> it would be easiest to implement in untyped lambda calculus, and easy to implement in typed lambda calculus with infinite types
05:56:54 <mm_freak> and somehow i have no idea how to implement it at all in haskell
05:58:40 <Saizan> mm_freak: do you need 'b' to appear in the type?
05:59:07 <mm_freak> Saizan: if i want to allow different folding outcomes than 'a', it seems so
05:59:21 <Saizan> mm_freak: newtype LList a b = LList ((a -> LList a b -> b -> b) -> b -> b)
05:59:23 <Saizan> ops
05:59:32 <Saizan> mm_freak: newtype LList a = LList (forall b. (a -> LList a b -> b -> b) -> b -> b)
05:59:47 <augustss> Saizan: you took the word from my mouth!
05:59:55 <Saizan> s/LList a b/LList a/
06:00:15 <mm_freak> Saizan: then the function passed as the first argument couldn't do anything with the outcome, or am i wrong?
06:00:52 <Saizan> mm_freak: it can do anything, it gets to choose the 'b'
06:01:03 <mm_freak> uhm, let me try
06:01:18 <Saizan> mm_freak: this is not an existential type, it's a polymorphic component
06:02:08 <mm_freak> indeed, thanks
06:02:20 <mm_freak> however, is there any way to express this in h98?
06:03:07 <Saizan> mmh, i don't think so, but i'd defer to augustss on this :)
06:03:34 <augustss> ummmm
06:04:02 <mmorrow> mauke: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1399#a1399
06:04:10 <augustss> It might be possible in some indirect way using classes
06:04:24 <mmorrow> i'm not sure if i'm doing something wrong, or that code is just trashing stuff
06:04:53 <augustss> classes can be seen as records whcih can have polymorphic components, after all
06:04:56 <mmorrow> mauke: at the bottom is the disasm via harpy
06:05:15 <Axman6> bloody hell, the C produced by -C is even harder to read than the Core :(
06:06:15 <mm_freak> hmm
06:06:16 <mauke> mmorrow: what OS is this?
06:06:20 <mmorrow> linux
06:06:24 <mm_freak> why not just allow infinite types?
06:06:27 <pejo> Axman, what is it you're trying to figure out in the first place? Have you seen the ghc-core tool?
06:06:33 <mauke> mmorrow: that's an older version of my code, right?
06:06:33 <mmorrow> Linux ganon 2.6.25.9-40.fc8 #1 SMP Fri Jun 27 16:25:53 EDT 2008 i686 GNU/Linux
06:06:38 <Axman6> pejo: yeah, i'm using it
06:06:48 <mmorrow> mauke: i'm not sure. probably (i got it a few months ago)
06:07:06 * mmorrow gets teh new version
06:07:09 <augustss> mmorrow: 'call 0x13'?
06:07:10 <paper_cc> mauke: the call 13h isn't going to be relocated by the os, is it?
06:07:27 <mauke> mmorrow: should change anything, just a few redundant pushes/pops
06:07:42 <ski_> mm_freak : lots of common type-errors would be allowed, or found quite a bit later, if equi-recursive types would be allowed
06:07:56 <augustss> umm, is that a relative call?
06:07:59 <ski_> (mm_freak : you can play with them in `ocaml -rectypes' if you wish)
06:08:02 <mauke> augustss: yes
06:08:48 <augustss> And the program is allowed to do insb?
06:08:58 <mauke> I have no idea what that is
06:09:02 <mm_freak> ski_: i think, i'll just use Saizan's approach
06:09:14 <mm_freak> it seems to emulate infinite types in a certain sense
06:10:01 <augustss> And the ja and jb jump to never-never land
06:10:08 <mmorrow> i think that's harpy trying to disasm non-instructions
06:10:10 <Axman6> pejo: i'm glad i am too, just checked out what the emitted Core looks like from GHC, and it seems ghc-core cleans it up a _lot_
06:10:24 <mauke> mmorrow: what are the { } doing in ({((MEMMAP)(mm))->addr=(void*)(x);}) ?
06:10:46 <mmorrow> mauke: i dunno, i thought since i'm doing an assignment that would be better?
06:11:04 <mauke> not really
06:11:12 <mauke> except it causes compiler warnings :-)
06:11:14 <mmorrow> cool
06:11:19 <mmorrow> heh, i noticed :)
06:12:04 <augustss> Is this just to execute some sequence of bytes?
06:12:41 <augustss> Can't you just use mprotect() to turn on exec on the page where the array is?
06:13:07 <mauke> blargh, hwlen
06:13:22 <mmorrow> augustss: i could, but i wanted to work out allocating memory and executing data i write into it
06:13:28 <mauke> unsigned char hw[] = { ... }; ... sizeof hw
06:13:35 <augustss> mmorrow: ok
06:13:44 <mmorrow> augustss: and i read that mprotect has undefined behavior on malloced memory
06:14:07 <augustss> mmorrow: I could believe that :)
06:14:23 <augustss> mmorrow: have you single stepped it in the debugger?
06:14:42 <mmorrow> augustss: not yet, but that's an excellent idea :)
06:14:57 <mauke> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1399#a1400
06:15:09 <mauke> does that work better?
06:15:23 <mmorrow> i'll try
06:16:22 <pejo> Axman, well, you need to know roughly what you're looking for unless you happen to know all of core already, I think. There's a section in the ghc manual that describes the core output, which was mostly accurate last time I checked it.
06:17:11 <Axman6> i've sort of got used to looking at core, and i can tell when it's made some nice optimisations, but it's ahrd to follow a lot of the time
06:17:15 <mmorrow> mauke: beautiful, that works nicely.
06:17:24 <mauke> the magic of S[
06:17:27 <mmorrow> heh
06:18:41 <Valodim> the last operation on a list is O(n), right?
06:18:47 <mauke> yes
06:18:55 <Valodim> k..
06:19:34 <Valodim> why isn't that mentioned in the haddock of Data.List? Seems pretty significant to me :|
06:19:41 <mauke> it's obvious
06:21:11 <Valodim> kinda.. but still, most collections have info on the runtimes of their operations, why not this most basic one
06:23:32 <Martijn> Why is getRunMud :: Mud (forall a. Mud a -> IO a) not equal to getRunMud :: Mud (Mud a -> IO a)?
06:24:29 <Saizan> Martijn: in the latter case the caller gets to choose what type to use for 'a'
06:24:36 <mauke> hell.c updated. let's hope I didn't break BSD again :-)
06:24:56 <Martijn> Ah... these quantifiers still confuse me. :-(
06:25:00 <Martijn> Thanks, Saizan.
06:25:13 <Martijn> I wish I fully understood them.
06:26:15 <Axman6> are there ever times where you have to put a forall x. ... in?
06:26:25 <Saizan> i usually see them through the game metaphor, where you decide which side has the freedom to pick a type for the quantified variable
06:27:05 <Martijn> Yes, that's a useful methaphor, except I don't see why the caller doesn't get to choose what type to use for 'a' in the first case.
06:27:41 <Saizan> Axman6: you mean on the outermost level? i think you need only if you want to use ScopedTypeVars
06:28:16 <Saizan> or inside a data definition
06:29:42 <Saizan> Martijn: well, what can happen in the first case also depends on the definition of Mud
06:30:34 <Saizan> Martijn: the latter is equivalent to forall a. Mud (Mud a -> IO a), so i can immediately instantiate that to a particular type
06:30:54 <Martijn> Yes, that's how it usually is
06:31:00 <ski_> Martijn : in the first case, whoever gets the result of type `forall a. Mud a -> IO a' may choose the `a' (at that point)
06:31:01 <Martijn> So I think I understand that version
06:31:15 * Martijn nods.
06:34:27 <Martijn> I'm trying to imagine what consequences those different types have for the implementation of getRunMud. Because in both cases getRunMud promises to be polymorphic in a.
06:34:30 <Saizan> e.g. forall a. [a -> a] is a list of functions for the same type 'a', while [forall a. a -> a] is a list of polymorphic functions over 'a', i.e. you can still instantiate each one to a different type
06:35:47 <Martijn> Hrm
06:36:20 <Saizan> Martijn: it highly depends on the definition of Mud
06:36:54 <Martijn> Yes, the problem arose when I used the result of getRunMud twice in the definition of a function. The first use pinned a to be () while the second wanted a to be Bool.
06:37:03 <Martijn> type Mud = StateT MudState IO for now
06:38:34 <Peaker> Isn't the new post about ParameterizedMonad just an arrow with return?
06:39:37 <Saizan> Martijn: then i think you've your answer, if the result of getRunMud is supposed to be used with different types then it has to be polymorphic
06:40:20 <blancolioni> one disadvantage of sudo is that you eventually forget the savagely complicated root password
06:40:20 <Martijn> Yes
06:41:21 <z0d> blancolioni: That's what password managers are for.
06:41:38 <blancolioni> don't you need a password to access your password manager?
06:42:22 <z0d> blancolioni: only 1
06:42:30 <Saizan> Martijn: have you ever looked at System F?
06:42:55 <Martijn> Saizan: If I have, I didn't know it was called System F.
06:43:33 <Saizan> Martijn: it's also called the polymorphic lambda calculus, there polymorphic functions are represented as functions that take a type as parameter
06:44:35 <Saizan> Martijn: haskell: id x = x , System F: id a (x :: a) = x, and both are of type forall a. a -> a
06:44:51 <Saizan> then you also have to apply those type parameters explicitly
06:45:01 <Martijn> Yes, I think I've seen that before
06:45:07 <Saizan> (id Int) :: Int -> INt
06:45:20 <Martijn> And the forall a. in Haskell can be seen as a type parameter
06:45:28 <blancolioni> z8d: I guess sudo will be my password manager from now on :-)
06:46:05 <Saizan> yeah, you can say that in haskell the type parameters are filled by the typechecker for you
06:46:23 <Martijn> Yes... they're (usually) implicit.
06:46:40 <Martijn> Hmm... I think I'm beginning to understand a bit better now.
06:47:40 <Martijn> I wrote: do runMud <- getRunMud; runMud (blah ()); runMud (blah Bool)
06:47:56 <Martijn> And that didn't compile until I moved the forall a. inside the type argument to Mud
06:48:45 <Martijn> And now I'm guessing another way to solve the problem would be to call getRunMud twice.
06:48:48 <Saizan> yeah, becasue in the first case you've only one place to pass a type paramter (i.e. directly to getRunMud) and you can't pass two of them at the same time
06:48:56 <Saizan> Martijn: exactly
06:49:02 <Martijn> Interesting
06:49:20 <drhodes> have there been/are there efforts to port the evil mangler to haskell?
06:49:23 <blancolioni> Saizan: I think I had a similar problem with a gui-building DSL
06:49:42 <blancolioni> data Gadget a represents a gui that manipulates a state a
06:49:53 <Martijn> It feels kinda silly though, because I could just define: doRunMud m = do runMud <- getRunMud; runMud m
06:49:59 <blancolioni> and it's nice to have inner gadgets of a different type
06:50:08 <Martijn> But I guess that's only okay because getRunMud doesn't have any side effects.
06:50:35 <blancolioni> I've solved it temporarily by transform :: (a -> b) -> (b -> a -> a) -> Gadget b -> Gadget a
06:50:46 <blancolioni> but I wonder if there's some way forall could do it better
06:51:24 <Saizan> blancolioni: that's more complicated because you want an heterogeneous collection
06:51:32 <blancolioni> yes
06:52:55 <Saizan> you can use existentials if you can afford to lose information about which specific type the internal gadgets use, and just manipulate them through an interface
06:53:22 <blancolioni> Saizan: that's pretty much what I want -- I don't care about the type of the internal gadgets
06:53:43 <blancolioni> Saizan: they supply their own a -> b and b -> a -> a
06:54:18 <Peaker> ok, the parameterized Monad thing is cool.  its obvious in retrospect :)
06:55:00 <Saizan> blancolioni: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types <- here it makes an example with a typeclass
06:55:18 <Saizan> blancolioni: but you can also use a record of functions
06:56:06 <Saizan> like data InnerG a = forall b. InnerG (a -> b) (b -> a -> a) (Gadget b)
06:56:27 <Martijn> mdo just solved a compiler error for me but I no longer am sure what's going on. Everything seems to work, though. :-\
06:56:31 <Saizan> then you can have a [InnerG a] inside a (Gadget a)
06:56:36 <mreh> does anyone know how Haskell interfaces with GLFW?
06:57:52 <blancolioni> Saizan: it just seems ... too easy :)
06:57:56 <blancolioni> thanks for the help
06:57:59 <blancolioni> and he link
06:58:03 <blancolioni> ^he^the
06:58:27 <Saizan> blancolioni: well, you're severely restricted on what you can do with such values, but it might suit what you want
06:59:27 <Saizan> Martijn: as long as it doesn't loop you're fine :)
06:59:36 <blancolioni> Saizan: that's what was frustrating me -- the inner type was completely shielded from the outside
06:59:49 <blancolioni> but there didn't seem to be any easy way of hiding it from the data declaration
07:01:05 <ski_> Peaker : haskell-cafe ?
07:01:24 <Peaker> ski_, possibly, I saw it on reddit
07:01:42 <ski_> oh .. then that might be the sigfpe post
07:01:43 <Peaker> it was on a blog (maybe posted on cafe too)
07:02:03 <Martijn> Saizan: nope, doens't loop :-)
07:02:14 <Peaker> Yeah - it also seems to have a relationship to Category/Arrow beyond that of Writer which he implements there (with swapped tuples!)
07:03:19 <Peaker> btw:
07:04:31 <Peaker> It should probably become ParametrizedApplicative
07:04:31 <Peaker> (my enter key is too close to various keys, sorry)
07:04:56 <Martijn> various keys even :-)
07:04:56 <Peaker> While normal monads make the value inside them an explicit type parameter, parameterized monads also make the sequenced thing explicit in the type -- which is unsurprising if you consider that monads generally do sequencing in addition to value passing
07:05:46 <Peaker> class ParametrizedApplicative a where {
07:06:07 <Peaker> oh! somehow shift-space is return here
07:06:36 <Peaker> that's why I
07:06:55 <blancolioni> Saizin: that's incredible -- I tried a few versions of existential data typing, but couldn't find one that worked
07:06:58 <blancolioni> wow
07:07:06 <blancolioni> thanks again
07:07:26 <peaker> xchat is broken, and associated shift+space with return somehow
07:09:14 <Valodim> ..how do I cast from a Word32 to an Int64?
07:09:39 <Saizan> Valodim: fromIntegral
07:09:42 <Valodim> I usually use fromEnum to get to Int, but I can't find an equivalent for Int64?
07:09:46 <Valodim> will try, thanks
07:09:53 <Saizan> blancolioni: np :)
07:10:59 <Martijn>     Inferred type is less polymorphic than expected
07:10:59 <Martijn>       Quantified type variable `a' escapes
07:10:59 <Martijn>     In the first argument of `gets', namely `mRunMud'
07:11:03 <Martijn> Hrm
07:11:13 <blancolioni> Martijn: I was just about to say the same thing!
07:11:15 <Valodim> works, thanks
07:11:25 <blancolioni>  gadgetInner (G _ _ (Inner (InnerE get set g))) = (get, set, g)
07:11:46 <blancolioni> I guess it's talking about the b from InnerE escaping to the result
07:12:29 <Martijn> Life is tough :-( :-)
07:12:34 <peaker> class ParamApplicative f where { pure :: a -> f s s a ; (<*>) :: f s1 s2 (a->b) -> f s2 s3 a -> f s1 s3 b }
07:13:57 <Martijn> blancolioni: Do you understand your problem already? I'm not sure what's wrong in my case yet.
07:14:01 <Martijn> type RunMud = forall a. Mud a -> IO a
07:14:01 <Martijn> getRunMud :: Mud (forall a. Mud a -> IO a)
07:14:01 <Martijn> getRunMud = gets mRunMud
07:14:32 <blancolioni> Martijn: no -- this is the one that stumped me last week :-(
07:14:46 <blancolioni> I mean, I know what the problem is, but I don't know how to solve it
07:14:51 <Martijn> Yeah
07:15:07 <Saizan> you can't get the (a -> b) or (b -> a -> a) out freely, you can only use them with the packed value of type 'b'
07:15:40 <Saizan> or wrap them inside another existential wrapper
07:15:54 <Martijn> Perhaps the a needs to be a parameter to the RunMud type synonym in my case
07:16:36 <Saizan> Martijn: how is mRunMud defined?
07:16:49 <blancolioni> Saizan: right, because if you could get the get/set out freely, you could do bad things with them
07:17:02 <blancolioni> (I think)
07:17:07 <Martijn> mRunMud is a field in record MudState with type RunMud
07:17:54 <Saizan> is it like data MudState = MudState { mRunMud :: RunMud, ... } ?
07:18:00 <Martijn> Yes
07:19:02 <peaker> Martijn: Use case to get an existentially-typed value out of a constructor
07:19:27 <Saizan> it's not existentially-type here, though
07:19:58 <Saizan> but trying with get and case doesn't hurt i guess
07:20:38 <mreh> how can i find if i have a haskell package already installed on my system?
07:20:46 <Martijn> mreh: ghc-pkg list
07:20:56 <mreh> is that in *ni?
07:20:59 <mreh> *nix?
07:21:04 <blancolioni> yes
07:21:08 <Martijn> Yes. I'm not sure about Windows.
07:21:18 <Saizan> ah, i see, to use gets there you need an impredicative instantiation, and the typechecker probably doesn't handle that well
07:23:02 <Martijn> I'm trying to create a minimal test case now and the error has changed: Illegal polymorphic or qualified type: RunMud. Perhaps you intended to use -XImpredicativeTypes.
07:23:02 <Saizan> blancolioni: it's more like you can't give them the right type when you get them out, you'd want a first-class exists
07:23:38 <Saizan> heh, as i guess :)
07:23:42 <Saizan> *guessed
07:23:49 <Saizan> does it work with that flag?
07:24:02 <Martijn> No
07:25:05 <Saizan> Martijn: do s <- get; return (mRunMud s) :: Mud RunMud -- ?
07:25:06 <Martijn> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1417#a1417
07:25:45 <Martijn> Saizan: nope, error stays
07:26:13 <Martijn> But it's really complaining about the type signature, and not about the implementation
07:27:48 <Martijn> With -fglasgow-exts I get the old error back (less polymorphic than expected)
07:28:37 <Martijn> But! With -fglasgow-exts *and* { s <- get; return (mRunMud s) } it works!
07:29:25 <blancolioni> Martijn: if I understand correctly, the bit with the existential is being sorted out within the { .. } ?
07:29:31 <blancolioni> so nothing escapes?
07:30:00 <Martijn> Nothing escapes; I just want to return a polymorphic function.
07:30:32 <blancolioni> the problem is that I have a polymorphic IO function that can display any Gadget
07:30:46 <blancolioni> but for the inner gadget, of some unknown type, that's a bit tricky
07:31:49 * Saizan wonders what -fglasgow-exts is enabling
07:31:59 <blancolioni> hmmm, can I make an IRC-sized test case?
07:32:23 <Martijn> Saizan: exactly
07:32:33 <blancolioni> everything?
07:32:37 <blancolioni> :)
07:33:09 <Saizan> maybe there's another LANGUAGE pragma to turn on :)
07:41:25 <blancolioni> so this is the problem: http://thewhitelion.org/haskell/escape.hs
07:41:47 <blancolioni> the b in the type signature is not the same b as the b in the existential
07:41:59 <blancolioni> which is fair enough, really
07:42:53 <blancolioni> I guess I have to pack the show function into the Inner data type
07:43:08 <Martijn> or the result of the function (just an IO ())
07:43:43 <blancolioni> Martijn: what do you mean?
07:44:12 <Saizan> Martijn: the value of type 'a' can change
07:44:24 <Martijn> oh, right, my bad.
07:45:37 <byorgey> blancolioni: exactly
07:46:07 <Martijn> blancolioni: 'data X = forall a. X a (a -> String)' is the same as 'data X = X String' for all practical purposes.
07:48:01 <redditbot> Agda 2 Proof of the Cont Monad laws -- Thanks to eta
07:51:29 <peaker> blancolioni: Why are you not using a normal accessor there?
07:52:20 <blancolioni> peaker: casualty of creating a small test case
07:52:51 <peaker> blancolioni: what's "get"?
07:54:07 <blancolioni> Q is really a DSL that can put arbitrary types into a GUI
07:54:21 <blancolioni> and the idea is that it can have little subguis of different types
07:54:34 <blancolioni> so I can't let those subgui types escape into the parent
07:55:04 <paolino> anyone knows where is Either e Monad instance ?
07:55:09 <blancolioni> http://thewhitelion.org/haskell/GadgetTestCase.lhs
07:55:25 <blancolioni> palino: uh, not there by the way
07:55:35 <Martijn> paolino: there's one in Control.Monad.Instances, but it's evil.
07:55:42 <peaker> Martijn: Why is it evil?
07:55:51 <paolino> what is evil ?
07:56:01 <Martijn> Because it requires e to be an instance of the Error type class
07:56:09 <peaker> blancolioni: Is it a good idea to have a closed-type for gadgets?
07:56:28 <blancolioni> peaker: what do you mean?
07:57:02 <peaker> blancolioni: your Element type seems like it should be open, not closed
07:57:24 <maltem> Martijn: It's in Control.Monad.Error, not .Instances.
07:57:42 <blancolioni> peaker: sorry, I'm not sure what open/closed is w.r.t types
07:58:22 <peaker> blancolioni: If its a library, your users cannot extend it by adding a new type of element later.. If Element was a record of functions, they could
07:58:22 <paolino> what is this story of missing Error instance, is it in the Constraints ?
07:58:35 <blancolioni> ah, right
07:58:51 <blancolioni> peaker: this is really just a prototype to test some ideas I had about GUIs
07:58:58 <peaker> blancolioni: Ah, cool, what ideas?
07:59:06 <peaker> blancolioni: (I am also working on a GUI widget set)
07:59:16 <blancolioni> peaker: isn't everybody? :-)
07:59:17 <augustss> @src fix
07:59:17 <lambdabot> fix f = let x = f x in x
07:59:46 * dolio isn't.
08:00:04 <Cheshire> lol
08:00:16 <blancolioni> peaker: well, when I implemented a version of the Fudgets library using Gtk, I realised that it wasn't ideal for the kinds of guis I needed
08:00:25 <blancolioni> state was flying all over the place
08:00:47 <blancolioni> and while it remained purely functional, it wasn't the nice kind of purely functional
08:01:17 <blancolioni> in the same way that a chihuahua is technically still a dog
08:01:48 <blancolioni> so what I'm doing is admitting that a gui will often be used to manipulate a state, and building from there
08:02:11 <peaker> blancolioni: Well, my widget set is purely funcitonal in a good way, I hope :) Though I have not yet used it for real work yet, so I am not sure, maybe you can see if the model works for you?
08:02:38 <blancolioni> peaker: sure!  I don't grok arrows at all though
08:02:41 <peaker> blancolioni: My widget type is: type Widget model = ...   such that the widget "edits" a model.
08:02:51 <peaker> blancolioni: my widget set doesn't have arrows, though they are not hard to grok
08:03:37 <peaker> blancolioni: Actually: type Widget model = model -> ...   so you're even allowed to write your own function there and see the model input before returning the widget :)
08:03:40 <blancolioni> peaker: my widget type is Gadget state, where the gadget "edits" the state lol
08:04:02 <peaker> blancolioni: And when you create a widget, you give it an accessor (Just like yours :-) to edit its part of the state
08:04:09 <blancolioni> peaker: is it online somewhere?
08:04:18 <peaker> blancolioni: cabal install lui -- but its far from ready/usable for real work
08:04:28 <blancolioni> peaker: yeah -- I've got that functionality working using a transform fucntion
08:04:36 <Saizan_> ?hackage lui
08:04:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lui
08:04:53 <blancolioni> basically I cheat by turning Gadget b into Gadget a using supplied get/set functions
08:05:09 <blancolioni> you can see http://thewhitelion.org/darcs/barrie
08:05:19 <blancolioni> and get a free calculator!
08:05:19 <peaker> blancolioni: yes, the get/set pair is called an "accessor" and I use this "trick" too
08:06:06 <blancolioni> peaker: but the problem is that the inner gadget now changes the outer state
08:06:16 <peaker> blancolioni: why is that a problem?
08:06:47 <peaker> blancolioni: Look at Example.hs in the lui package. It should be runnable...
08:07:15 <peaker> weird, I used darcs get http://thewhitelion.org/darcs/barrie/   but I get an empty directory
08:07:45 <blancolioni> peaker: oh?  I probably didn't set it up properly
08:08:06 <blancolioni> peaker: the problem is that the inner gui might be building its thing in stages
08:08:20 <blancolioni> peaker: and an intermediate stage might not be suitable for writing to the outer state
08:08:23 <peaker> blancolioni: I am not sure.  I don't really have time to work on LUI at the moment, or read barrie's code. But when I have some time I'd love to
08:08:42 <blancolioni> peaker: no worries -- thanks for testing the darcs for me :-)
08:08:45 <peaker> blancolioni: Why do you have an "intermediate" stage? Can you give an example?
08:10:03 <blancolioni> peaker: yes ... say I'm building a list of friends.  I have an inner gadget that lets me create a new entry.  It works from a template, into which I fill in the details, this template then gets turned into a real Friend value and returned
08:10:11 <blancolioni> I don't want to clutter the main state with templates
08:10:28 <blancolioni> but I also don't want incomplete Friend values in there
08:10:53 <peaker> blancolioni: Ah, I see. Your model accessor does not have to access the real model directly
08:11:45 <peaker> blancolioni: For example, you can have:  data Model = M { guiModel :: gui state here, realModel :: real model here } -- and hand an accessor to your widget hat gets/sets the GUI model by converting to/from Model
08:11:54 <blancolioni> peaker: exactly --- I've been trying to think of some way of having the inner gadget carry around its own state
08:12:54 <{g}> Hey People! Has haskell classes or something similar?
08:13:00 <ski_> Martijn : probably you want `ImpredicativeTypes' for `Mud (forall a. ..a..)', yes
08:13:01 <peaker> {g}: No
08:13:15 <blancolioni> peaker: oh ... the outer gui could have an extended state, and its result is the real bit
08:13:25 <ski_> (Martijn : `instance Error e => Monad (Either e)' is evil, indeed)
08:13:28 <peaker> blancolioni: that is, guiModel contains uninteresting data, and only carries the information useful to the widget, for example "intermediate" GUI state
08:13:43 <peaker> blancolioni: But "realModel" can remain clean and final
08:13:47 <Cheshire> {g}: typeclasses
08:13:50 <ski_> peaker : yes, such an `ParamApplicative' would be quite natural to consider
08:13:56 <peaker> blancolioni: Your widget should probably have a state type that's most natural for what it presents
08:14:10 <{g}> peaker: how do you group a set of functions then?
08:14:11 <ski_> {g} : it all depends on what you mean by "classes"
08:14:24 <Cheshire> {g}: you don't usually -- or put them all in one file
08:14:38 <peaker> {g}: Depends on what kind of grouping you want and for what purpose. You can use modules, typeclasses or records/tuples
08:14:38 <ski_> {g} : if you want, you can group functions together into a record
08:14:55 <cantor> question: how can i take an integer e.g. 123 and transform it into a list [1,2,3] ?
08:14:55 <blancolioni> peaker: ah, but what I was looking at was a cheap way of slapping a gui over an existing state
08:14:59 <{g}> ski_: Class Http () { function post() {...}; function get() {...} }; Http::post("...");
08:15:06 <{g}> ski_: something like that.
08:15:32 <peaker> blancolioni: You can export a convenience "convertor" from (exportedNiceModel,yuckyIntermediateModel) <-> guiModel
08:15:42 <{g}> maybe you guys use something like namespaces then?
08:15:44 <blancolioni> peaker: that's true
08:15:55 <peaker> blancolioni: so your Widget user just has to store a yuckyIntermediateModel somewhere in his model, but never actually look inside or touch it
08:16:00 <peaker> {g}: Modules are namespaces, yes
08:16:14 <{g}> Ok. Lets talk about modules.
08:16:37 <blancolioni> I think that I shall never see a module lovely as a tree
08:16:46 <{g}> Say you write a module that has a bunch of http related functions. How would you call it - "Http" or "HTTP"?
08:16:55 <Cheshire> HTTP
08:17:03 <peaker> @hoogle http
08:17:04 <lambdabot> package HTTP
08:17:05 <lambdabot> package HTTP-Simple
08:17:05 <lambdabot> Text.XHtml.Frameset httpequiv :: String -> HtmlAttr
08:17:15 <blancolioni> {g}: either is syntactically fine
08:17:39 <peaker> blancolioni: I don't think its a good idea for the widget itself to be stateful
08:17:41 <ski_> {g} : it might be nice if you consider which of the features mentioned on <http://community.schemewiki.org/?object-oriented-programming> you want ..
08:17:42 <{g}> blancolioni: i know. im just thinking about what is nicer. I will go with "Http".
08:17:45 <blancolioni> peaker: I need to sit down and think some more now :-)
08:17:49 <peaker> blancolioni: its a nicer model to have a widget that just edits state
08:17:59 <peaker> blancolioni: If some of that state happens to be internal/belong to the widget, that's fine IMO
08:18:15 <{g}> ski_: im not talking about haskell. just about coding in general. i like to get input from users of different languages.
08:18:21 <blancolioni> peaker: ah, well, it's a little more complicated than that
08:18:28 <ski_> {g} : yes, me too
08:18:29 <peaker> blancolioni: how so?
08:18:40 <blancolioni> peaker: the Gadget data type is just for expressing state manipulation operations
08:18:57 <blancolioni> peaker: there's a separate data type Widget which describes what it actually looks like
08:18:58 <{g}> ski_: great. whats your favorite language?
08:19:01 <ski_> {g} : `classes' means different things to different people
08:19:56 <blancolioni> peaker: so gadgets aren't really widgets, in the sense of a gui that's carrying state around
08:19:59 <peaker> blancolioni: Ah, so your "Gadget" is probably just Accessor
08:20:23 <blancolioni> peaker: pretty much
08:20:58 <ski_> ({g} : clarifying, the "yes, me too" was in response only to the two former parts of your statement i was responding to)
08:21:25 <peaker> blancolioni: Look at: http://github.com/Peaker/lui/blob/8939a5f8abe6196287be2d513d5c0dfdc482dfcb/src/Graphics/UI/LUI/Accessor.hs
08:21:34 <blancolioni> peaker: it puts a box with standard knobs around other state/accessor combinations
08:21:42 <{g}> ski_: sorry, this clarified nothing.
08:21:50 <blancolioni> so that the gui builder can put pretty widgets around it
08:21:52 * Baughn cooks delicious hot chocolate. You can't have any.
08:22:02 <peaker> Though my (^>) should probably be Category..
08:22:06 <peaker> (Category's dot)
08:22:27 <peaker> blancolioni: "gui builder"? What's that?
08:23:02 <blancolioni> > gtkMain :: Gadget a -> Widget -> a -> IO a
08:23:03 <lambdabot>   Not in scope: `gtkMain'    Not in scope: type constructor or class `Gadget'...
08:23:10 <blancolioni> whoops, sorry lambdabot
08:23:22 <peaker> blancolioni: You're doing this around Gtk+?
08:23:34 <blancolioni> peaker: well, text or Gtk so far
08:23:36 <peaker> blancolioni: I am rendering/laying out my own widgets/graphics
08:23:48 <blancolioni> peaker: but it's UI library agnostic
08:23:50 <ski_> {g} : just meaning that i wasn't responding to the "i like to get input from users of different languages."
08:24:15 <ski_> ({g} : if you still want, i can mention a couple of languages i find nice ..)
08:24:28 <blancolioni> peaker: I have zero talent for layout and design, so I specifically designed the thing so that other people can take care of it
08:25:16 <{g}> ski_: go ahead :)
08:25:30 <blancolioni> peaker: which is what the Widget does
08:26:32 <ski_> {g} : Haskell,Prolog,Mercury,Scheme,Agda[2],LF,(Coq)
08:27:04 <blancolioni> {g}: Haskell, Ada
08:27:09 <ski_> (in no particular order)
08:27:17 <{g}> ski_: interesting. i never coded any of them.
08:27:21 <peaker> blancolioni: Would like to discuss it some time. If you have time, and can check out lui and give me some feedback, that'd be great :-)
08:27:43 <ski_> {g} : for OO things, O'Caml is an interesting design point .. but i'd prefer something more coalgebraic .. in the vein of O'Haskell or Timber, perchance
08:27:57 <ski_> also Charity is intersting
08:28:09 <blancolioni> peaker: I'll do that :)
08:28:22 <peaker> ski_: What are "OO things"? :)
08:28:22 * {g} coded assembler, basic, pascal, c++, java, bash, javascript and php. I like php most.
08:28:41 <ski_> peaker : that's a vague question :) (see the above mentioned link)
08:29:03 <peaker> ski_: in your sentence "for OO things", what did you mean?
08:29:22 <pejo> Peaker, not saying what ski meant, but "people" often mean subtyping.
08:29:23 <ski_> (peaker : basically, "OO things" are what enough people call "OO things", as far as i can determine)
08:29:50 <peaker> ski_: Well, I think Haskell has all the positive traits of OO, and then some (lacking of course some of the more horrible traits)
08:29:57 <peaker> ski_: that's a good link btw :)
08:30:25 <ski_> (yes)
08:30:58 <ski_> Haskell lacks a nice syntax for coalgebraic definitions
08:31:18 <peaker> ski_: what are coalgebric definitions?
08:31:22 <ski_> also Haskell lacks inheritence (and coinheritence) (it may be argued whether this is good or bad)
08:31:28 <{g}> ski_: what are coalgebric definitions?
08:31:44 <ski_> things like (using Pseudo-Haskell syntax)
08:32:01 <peaker> ski_: I think implementation inheritence is a really bad idea.  Hey, even Java's author agrees it was a bad idea :)
08:32:11 <AllNight^afk> well it _sort_ of supports inheritance - you can have one TypeClass that is a subclass of another TypeClass
08:32:19 <ski_>   codata Stream a = Head :: a
08:32:20 <ski_>                   & Tail :: Stream a
08:32:42 <peaker> AllNight^afk: that's not inheritance, and that's a good thing :)
08:32:46 <ski_>   repeat :: a -> Stream a
08:32:50 <ski_>   Head (repeat a) = a
08:32:52 <ski_>   Tail (repeat a)
08:33:13 <AllNight^afk> I agree peaker - but I think it's worth bringing up when people say 'Haskell doesnt support subclassing' - becuase it _does_ support what you probably _want_ from subclassing :)
08:33:44 <ski_>   from :: Num a => a -> Stream a
08:33:49 <ski_>   Head (from n) = n
08:33:50 <ski_>   Tail (from n) = from (n+1)
08:34:22 <ski_> one may think of `Head' and `Tail' as messages that can be sent to a value of the type `Stream a'
08:34:35 <AllNight^afk> hello jan_
08:34:54 * AllNight^ just realised he's forgotten to mark himself back :|
08:35:01 <peaker> AllNight^afk: What people usually want from implementation inheritence is a simple type product (to "add" more members), or a closed type sum (because OO languages don't have proper closed type sums, they're forced to use inheritence instead, which is far inferior for this purpose)
08:35:05 <maltem> ski_: What is, in that example, the semantic difference to a plain old data type?
08:35:31 <ski_> AllNight^ : that's sometimes called `interface inheritance' and isn't at all as problematic as `implementation inheritance' is
08:35:34 <maltem> ski_: Or is it indeed just syntax?
08:36:00 <dolio> In Haskell, there is no difference between algebraic and coalgebraic definitions, other than syntax (in that proposed extension).
08:36:03 <mauke> AllNight^: there's no need to change your nick. we already have an /away command
08:36:08 <ski_> it's mostly syntax, seeing that haskells `data' types already can be infinite
08:36:10 <dolio> But there are languages where they would be different.
08:36:34 <pejo> Peaker, you are much too general in your statements, you are thinking of some OO languages that don't support those specific features.
08:36:52 <ski_> however, there's several aspects to "(implementation) inheritance"
08:36:54 <peaker> pejo: I should have used the word "most" there, yeah
08:36:55 <maltem> ok. yeah I've seen that distinction between (finite) data and (lazy) codata
08:37:04 <ski_> (a) over-riding
08:37:15 <ski_> (b) extending
08:37:17 <AllNight^> is that all we really mean by co-data? infinite strucures?
08:37:23 <AllNight^> structures*
08:37:32 <ski_> (a) is arguably more problematic than (b)
08:37:58 <dolio> They're potentially infinite, unlike data in a total language.
08:37:59 <peaker> Interface-inheritance is really unnice because it requires types to inherit all the interfaces they implement and mixes up all their names into a single namespace
08:38:05 <dolio> They don't have to be infinite.
08:38:10 <peaker> ski_: There's the common namespace mangling thing too
08:38:20 <rovar> chessguy:  you about?
08:38:32 <ski_> peaker : yes, i'm ignoring that dimension as orthogonal, rn
08:38:36 <ski_> consider a coalgebraic type, `Foo' with a couple of operations
08:38:40 <peaker> dolio: does a total language have codata?
08:38:44 <rovar> !seen chessguy
08:38:50 <dolio> Agda and Coq do.
08:38:58 <dolio> Oh, and so does Charity.
08:39:04 <ski_> now consider you have defined a constructor for it `blah :: Bar -> Foo'
08:39:16 <AllNight^> those arent full languages though - Charity at least isnt turing complete
08:39:17 <peaker> ski_: The namespace mangling is really important too, because it makes things like type inference in these OO languages painful and unsafe
08:39:28 <AllNight^> I dont think Coq is - dont know about Agda
08:39:28 <ski_> now, you're *extending* `Foo' to `Foo2' by adding a couple of new operations
08:39:33 <dolio> "Total" might traditionally mean provably terminating, but you can extend it to provably productive if you add codata.
08:39:51 <peaker> dolio: productive meaning that it makes progress?
08:39:54 <maltem> AllNight^: Agda isn't unless you turn off the totality/termination checker
08:39:58 <AllNight^> hello SyntaxNinja
08:39:59 <ski_> what you want to do here is reuse the implementation of `blah' to defined `blah2 :: Bar -> Foo2', just adding cases for the new operations
08:40:05 <pejo> Peaker, if you are using interface-inheritance, what you described is  the entire point of it though, to get all the names in the same namespace?
08:40:31 <peaker> pejo: I disagree, I think the point is to be able to use the interface methods on that object
08:40:59 <peaker> pejo: how these methods are named is less important
08:41:09 <ski_> the same scenario can be done with *algebraic* types and coinheritance, instead .. adding constructors to an algebraic type, and wanting to reuse a pattern-matching function, just adding cases for the new constructors
08:41:23 <ski_> (this is related to the "expression problem", btw)
08:41:34 <AllNight^> hello Dybber
08:42:07 <dolio> peaker: Yes. In that it takes finite time for each observation to complete (but your program might continue making those observations indefinitely).
08:43:29 <dolio> peaker: So, for instance, it's easy to write [1..] on coinductive lists, because peeling off each subsequent number is trivially terminating...
08:43:37 <peaker> dolio: Is it decidable to convert normal ADT's to CADT's?
08:44:01 <ski_> peaker : yes, namespace issues are important too .. but orthogonal to the points i wanted to make
08:44:29 <dolio> peaker: But filtering such lists isn't, because there's no guarantee that the predicate will succeed after a finite string of elements.
08:44:42 <peaker> ski_: true
08:45:18 <AllNight^> hello Trafalgard, igel_, boegel, neurogeek :)
08:45:24 <peaker> dolio: so implementing filter on a codata will be impossible?
08:45:32 <Trafalgard> Morning
08:45:35 <ski_> AllNight^ : there has been suggestions of adding a `Nontermination' monad to total languages, for expressing those operations that you can't / won't prove total (/ productive) .. this would not affect the parts of the language not using `Nontermination' in their types, though
08:46:08 <dolio> peaker: More or less, yes. I mean, as long as you can write 'filter (< 0) [1..]'.
08:46:25 <dolio> That's clearly not productive.
08:47:04 <peaker> dolio: how do total languages filter elements from their lists? Do they only use filter on ordinary finite sturctures?
08:47:07 <AllNight^> you can filter infinite lists in finite time -- provided that the number of distinct elements in the list is finite
08:47:27 <AllNight^> e.g. cyclic lists
08:47:39 * AllNight^ was thinking about this not so long ago :)
08:47:42 <dolio> Yeah, you can filter ordinary, finite lists.
08:48:14 <AllNight^> I dont mean that - I mean lists which are infinite - but where the nub of that list would be finite
08:48:15 <peaker> AllNight^: but the problem with (cycle [..]) is that you've lost the information about its repetative nature
08:48:23 <ski_> peaker : for dependently types languages, i imagine a proof that the specific instance of filtering is productive should be enough
08:48:35 <dolio> And you might be able to write down some properties about the list and the predicate that would allow you to write a filter function, but that might be difficult/not very useful in general.
08:48:51 <AllNight^> well what I'd do is construct a MySeq type class supporting all the sequence operations
08:48:54 <pejo> Peaker, I'm not sure but I get the impression  you conflate artifacts in existing languages with subtyping as a concept. I'm not a type theorist, but I know that there are calculi with both sound and complete type inference, if that is what you desire.
08:49:10 <AllNight^> and then data mySeqImpl x = MyList List x | Cyclic List x | ...
08:49:24 <AllNight^> and that way you can hold on to the information that something is cyclic
08:50:02 <AllNight^> or 'almost' cyclic (my term for a cyclic list prepended by an ordinary finite list - if anyone knows of an official term for such a thing please let me know) :)
08:50:14 <Saizan_> AllNight^: or use an uniform representation and pair it with a proof of the property
08:50:17 <mattam> ski_: yes, and your computation then does (inductive) recursion on this proof.
08:50:25 * ski_ wonders whether graph types can handle the above cyclic issues nicely ..
08:50:48 <ski_> mattam : quite possible indeed
08:51:09 <peaker> pejo: Subtyping does not require mangling namespaces, though. Namespaces are a syntactic thing, and subtyping is a semantic thing.  Languages that conflate namespaces with semantics are the ones creating inference problems
08:51:10 <ski_> (mattam : but what if the proof was used with proof irrelevance ?)
08:51:11 <AllNight^> Saizan_ - that's what I'd ideally like to do ... but I'm only beginning to get to grips with theorem provers
08:51:47 <mattam> But most of the time, the productivity criterion is syntaxic and you resort to ugly hacks like adding Epsilon steps to your datatypes...
08:52:02 <AllNight^> Epsilon steps?
08:52:17 <mattam> ski_: well, it's a typical case where it's irrelevant but useful.
08:52:25 <peaker> pejo: The problem I'm referring to is the one where the namespace is associated with the type, and inferring a different type infers a different namespace, so the names you use (which are just text tokens, non-unique) might refer to different things, with different semantics/laws and even types
08:52:26 <mattam> AllNight^: skips if you prefer
08:52:46 <ski_> AllNight^ : "rational value" ("rational tree" in Prolog)
08:52:57 <AllNight^> ah :)
08:53:02 <peaker> pejo: whereas languages that do the "right thing" of treating names and namespaces as a syntactic thing can build an ASG before inferring types
08:53:07 <ski_> (the idea being a similarity with
08:53:09 <ski_> > 1 / 12
08:53:11 <lambdabot>   8.333333333333333e-2
08:53:13 <ski_> )
08:53:43 <mattam> So when you can't produce something immediately you introduce a skip in the stream, a meaningless element.
08:54:46 <Saizan_> an ad-hoc version of the non-termination monad, then?
08:55:01 <mattam> Yes.
08:56:07 <dolio> In one of the papers that works on the non-termination monad, they mention that it's kind of 'strict' non-termination.
08:56:09 <AllNight^> btw... a couple of things that occur to me -
08:56:10 * ski_ recalls some slides on nontermination stuff .. possibly by Conor McBride
08:56:35 <mattam> strict?
08:56:47 <dolio> In that the computation either all converges, or all fails to converge.
08:57:02 <AllNight^> 1) we can represent an infinite list with a finite number of elements in it as a pair Nat -> x:FiniteList of y * y -> Nat -- such that the 2nd function returns an index at which the provided value occurs
08:57:12 <dolio> But to model a more lazy non-termination, you need to add constructors to data types like that.
08:57:27 <AllNight^> then if you can prove both functions halt - we've defined an infinite list who's nub is finite (checking people agree with my reasoning)
08:57:43 <mattam> dolio: you mean when you use it to model proof search with disjunctions for example?
08:57:51 <boegel> AllNight^: hiya!
08:58:13 <AllNight^> b) even if you do that - there are still problems - becuase now you can filter that list in finite time, but you still cant (for example) determine if a given finite sequence exists in it as a subsequence in finite time (not in general anyway)
08:58:39 <AllNight^> sorry... I'm fairly new to Haskell / FP .. but am I right on those points?
08:59:05 <dolio> mattam: Well, I don't know about that. They were just talking about how if you have something like D [a], you can never have a piece of the list converging, even if that's all you care about.
08:59:06 <mattam> I see each value in the computation monad as a single computation, so 'all' is meaningless here...
08:59:39 <mattam> Ok.
08:59:43 <dolio> I suppose, it's like working in ML or some other strict language.
08:59:46 <dolio> Instead of Haskell.
09:01:56 <ski_> AllNight^ : i'm not sure exactly on your `Nat -> x:FiniteList of y * y -> Nat' notation
09:02:09 <mattam> AllNight^: you can represent an infinite list with [Nat -> x] alone.
09:02:16 <Saizan_> dolio: i.e. m >>= f = _|_ if m = _|_ even if f _|_ /= _|_ ?
09:02:49 <Saizan_> mh, not that you can really pass _|_ to f..
09:02:50 <ski_> Saizan_ : i believe so, yes
09:03:01 <AllNight^> hi boegel :)
09:03:03 <dolio> I suppose that's a way of putting it, except that there is no _|_ you can give as an argument to f.
09:03:10 <mattam> Oh alright, the [(FiniteList y) * (y -> Nat)] gives you a finite presentation.
09:04:09 <peaker> is that (y -> Nat) or (Nat -> y) ?
09:04:09 <dolio> Well, no, not really, I guess.
09:04:29 <peaker> oh, nm, I see
09:05:06 <dolio> Saizan_: In haskell you can have 2 : _|_, but there's no similar value in the partiality monad.
09:06:01 <peaker> #haskell-in-depth maybe? :-)
09:06:08 <ski_> (unless you thread the monad through each cons link)
09:06:22 <dolio> But there is if you model partiality as 'codata Colist a = [] | a :: Colist a | Later (Colist a)'.
09:06:32 <ski_> (i.e. define a new list/stream type)
09:06:39 <dolio> Right.
09:07:00 <ozy`> > drop 10 $ [1..20] ++ undefined
09:07:02 <lambdabot>   [11,12,13,14,15,16,17,18,19,20* Exception: Prelude.undefined
09:07:19 <ski_>   codata CoList a = [] | a :: NonTerm (CoList a)
09:07:21 <Saizan> yeah, it's not surprising that those definitions are equivalnet
09:07:47 <ozy`> > [1..undefined]
09:07:48 <mattam> AllNight^: Yes, you can't do that. But basically you gave the finite representation of your list there, so it's like cheating.
09:07:49 <lambdabot>   * Exception: Prelude.undefined
09:09:23 <ozy`> is there a pragma I can put in a file so I don't have to pass -fwarn-incomplete-patterns every time I build?
09:09:42 <Saizan> {-# OPTIONS -fwarn-incomplete-patterns #-}
09:09:46 <dolio> {-# OPTIONS_GHC -fwarn-incomplete-patterns #-}
09:09:50 <ozy`> ah, thank you
09:11:22 <ski_> (.. or alternatively doing the colists (potentially finite streams) the even way)
09:11:57 <gueux> hi :-)
09:12:06 <gueux> is there a game library?
09:12:23 <earthy> there are sdl bindings
09:12:40 <earthy> http://sourceforge.net/projects/hsdl/
09:12:51 <earthy> http://abstractabsurd.blogspot.com/2008/04/intro-to-sdl-with-haskell.html
09:13:02 <Saizan> ?hackage haskgame
09:13:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskgame
09:13:20 <earthy> and there's http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
09:14:09 <gueux> ok
09:14:13 <gueux> thanks :-)
09:14:54 <earthy> wtf is haskgame doing in the Graphics category?
09:15:19 <gueux> my goal is to code a little game (maybe on a go board) with a haskell servor and then a web-based client
09:16:06 <Saizan> ah, then those link won't be of much use, probably
09:16:13 <earthy> indeed
09:16:46 <earthy> then you'll have to make do with adt's to model your gamestate
09:17:29 <gueux> adt's?
09:17:31 <earthy> you might also want to take a look at http://cleangl.sourceforge.net/ for an approach
09:17:35 <earthy> abstract data types
09:17:41 <gueux> ok :-)
09:18:01 <gwern> @hoogle escape
09:18:02 <lambdabot> No results found
09:18:22 <Cheshire> @pl \m k c -> m (\a -> k a c)
09:18:22 <lambdabot> (. flip) . (.)
09:18:25 <gwern> does anyone know the lib which has the function to url-escape strings?
09:18:39 <Cheshire> @pl \a f -> f a
09:18:39 <lambdabot> flip id
09:19:27 <earthy> gwern: Text.XHtml, IIRC
09:19:38 <Saizan> ?hoogle escape
09:19:38 <lambdabot> No results found
09:19:51 <Saizan> ?hoogle urlEncode
09:19:51 <lambdabot> No results found
09:20:03 <gwern> earthy: xhtml? that's an odd place. doesn't seem like there's anything xhtml specific about it
09:20:11 <earthy> no, indeed
09:20:41 <earthy> GoogleChart has an urlEnc function...
09:21:08 <earthy> Web.Codec.URLEncoder in hs-twitter
09:21:09 <peaker> haskgame is really initial, and only offers a few conveniences over SDL/SDL-ttf
09:21:33 <peaker> (yet). the idea is for it to be a full wrapper some time, which is more Haskell-like/convenient than the direct SDL bindings
09:21:50 <gwern> @hoogle escapeURIString
09:21:51 <lambdabot> No results found
09:22:02 <gwern> hm, my old xmoand code says it's from network.uri...
09:22:12 <earthy> hm.
09:22:34 <gwern> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html#v%3AescapeURIString <-- here we go
09:22:39 <earthy> ah.
09:22:46 <earthy> that would be the right place
09:22:52 <earthy> html package, still
09:22:58 <earthy> wouldn't have looked there
09:23:11 <earthy> other than 'it's in the same package as Text.Xhtml'
09:23:50 <Saizan> it's the network package
09:24:07 <gwern> presumably it would be called with isReserved ...
09:24:10 * earthy is obviously damn tired
09:24:13 <gwern> oops, that's not right: 'Link [Str "emperor Palpatine"] ("%68%74%74%70://%73%74%61%72%77%61%72%73%2E%77%69%6B%69%61%2E%63%6F%6D/%77%69%6B%69/%45%6D%70%6
09:24:16 <gwern> 5%72%6F%72%20%50%61%6C%70%61%74%69%6E%65","alt text")'
09:25:12 <gwern> isUnreserved isn't much better...
09:25:14 <gwern> 'Link [Str "emperor Palpatine"] ("http%3A%2F%2Fstarwars.wikia.com%2Fwiki%2FEmperor%20Palpatine","alt text")'
09:25:23 <ehird> :t callCC
09:25:25 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:26:05 <gwern> ah, there we go. isAllowedInURI
09:26:14 <gwern> 'Link [Str "emperor Palpatine"] ("http://starwars.wikia.com/wiki/Emperor%20Palpatine","alt text")'
09:26:22 <trofi> @src MonadCont
09:26:22 <lambdabot> class (Monad m) => MonadCont m where
09:26:22 <lambdabot>     callCC :: ((a -> m b) -> m a) -> m a
09:28:00 <mm_freak> for the category of sets, let f: ℝ → ℝ, but f is not the identity function, is it still an identity morphism?  or is only the identity function an identity morphism?
09:28:37 <rwbarton> Only the identity function is the identity morphism.
09:28:40 <Cheshire> mm_freak, whats the difference between function and morphism?
09:28:45 <ozy`> hmm, the haskell ranking on the shootout is a bit behind on multicore machines
09:28:58 <rwbarton> Because the identity function is the only function f such that f . g = g and g . f = g for all g (exercise)
09:29:37 <rwbarton> (Well, more precisely, that argument shows that we must take the identity morphism to be the identity function)
09:31:13 <Toxaris> I think that by definition, there is exactly one identity morphism for every object
09:31:39 <mm_freak> rwbarton: thanks
09:32:13 <dolio> Actually, that's probably not by definition, but you can prove it.
09:32:20 <Cheshire> mm_freak, hello....
09:32:20 <mm_freak> Cheshire: i'm trying to learn category theory…  a morphism in category theory is an abstract mapping from one object to another
09:32:47 <dolio> Because if you have two identities id1 and id2, then id2 = id1 . id2 = id1.
09:33:11 <Cheshire> mm_freak, so what's the difference?
09:33:29 <rwbarton> I think since Hom(A, A) is a set, we can talk about whether or not f in Hom(A, A) is "the identity" by checking whether it's equal to the specified id_A.
09:33:34 <mm_freak> Cheshire: functions are just one kind of morphism
09:33:42 <Cheshire> in category of sets
09:33:54 <monochrom> setegory of cats
09:34:01 <dolio> In the category of sets, morphisms are functions.
09:34:40 <Toxaris> dolio: that does make sense, but the definition of category (I have in mind) specifically says "there is a id_A for every A so that ...". I understand that as "this morphism has a name, we know it, it is one morphism we can point to", not "from all the morphism, one has this property"
09:34:45 <dolio> But in the free category generated by some arbitrary graph, one wouldn't say the morphisms are functions.
09:34:53 <mm_freak> i've seen someone on usenet explain the Bool type as a category
09:35:33 <rwbarton> sure, two objects False and True with a morphism False -> True
09:35:41 <mm_freak> although it was just a joke, it somehow showed the power of category theory
09:35:51 <Cheshire> thank you dolio
09:36:25 <dolio> Of course, I think there's some equivalence in which you can look at every category as a category of sets and functions. But you'd have to ask someone more knowledgable about that.
09:36:28 <Toxaris> mm_freak: reminds me of the -cafe thread about documentation
09:36:39 <mm_freak> Toxaris: i think, that's where i've seen it
09:36:46 <mm_freak> sorry, not usenet
09:36:50 <mm_freak> i meant -cafe
09:37:16 <mm_freak> (using gmane for mailing lists can be confusing)
10:04:19 <augustss> Who is this Gregg Reynolds guy?
10:04:41 <mm_freak> http://en.wikibooks.org/wiki/Haskell/Category_theory ⇐ in the second exercise from the first section, why isn't it a category?  i don't find composition to be non-associative =/
10:07:06 <dolio> f . g : A -> A, f . h : A -> A, g . f : B -> B, g . h : B -> B
10:07:25 <mm_freak> i just find that there is no h with h = (g . f), other than the identity of B
10:07:27 <dolio> The only morphisms of those types are id_A and id_B.
10:08:16 <dolio> So, (f . g) . h = id_A . h = h, and f . (g . h) = f . id_B = f.
10:08:21 <dolio> But h /= f.
10:08:58 <mm_freak> ok, so i was on the right track
10:09:34 <mm_freak> g . f _must_ be id_B, because it's the only morphism B → B
10:09:35 <mm_freak> right?
10:09:40 <dolio> Yeah.
10:10:05 <byorgey> augustss: good question.
10:10:21 <mm_freak> so if i'd introduce two more morphisms A → A and B → B, then it _may_ be a category again?
10:10:36 <augustss> He seems to move from one wrong insight to the next
10:10:44 <dolio> Heh.
10:10:44 <augustss> :)
10:11:04 <dolio> mm_freak: Possibly. You might not be able to get away with just two.
10:12:15 <mm_freak> ok, thanks
10:12:31 <Cale> Gregg Reynolds?
10:12:35 <pumpkin> lol
10:12:40 <Cale> Is this someone on the mailing list?
10:12:57 <dolio> He blogs, too.
10:13:15 <pumpkin> I missed the name, but some how when I saw "<augustss> He seems to move from one wrong insight to the next" I knew who it was
10:13:31 <pumpkin> *somehow
10:14:23 <Cale> Oh, I've seen this guy's blog. I read a couple sentences and decided it wasn't worth my time :)
10:14:41 <augustss> Cale: good choice
10:15:24 <rwbarton> mm_freak: You can make it into a category by adding two more morphisms : A -> A
10:15:33 <rwbarton> It's even a mildly interesting category
10:16:41 <Cale> Quick! Someone write a program to enumerate all the categories with n arrows :)
10:17:04 <dolio> All of them?
10:17:10 <Cale> yeah :)
10:17:49 <dolio> Oh, I guess that's not so bad.
10:17:54 <Cale> There are only so many nonisomorphic categories with a finite number of arrows.
10:18:15 <dolio> I was thinking n non-identity morphisms at first.
10:23:16 * rwbarton is having trouble mentally enumerating all 3-element monoids
10:24:01 <Cale> rwbarton: Writing out multiplication tables might help...
10:26:04 <gueux> I try to declare two different option types in the same module
10:26:34 <gueux> ghci says that I can't: "Multiple declarations of `Board.Empty'"
10:26:37 <gueux> is it?
10:26:51 <Cale> hm?
10:27:04 <gueux> is it impossible?
10:27:07 <Cale> gueux: Oh, are you reusing the name of a data constructor?
10:27:19 <gueux> yes
10:27:20 <Cale> Yes, that's not allowed, you have to give them different names.
10:27:38 <rwbarton> (because otherwise what would the type of Empty be)
10:27:41 <Cale> Otherwise, if you write "Empty", what type is it supposed to infer?
10:27:47 <peaker> gueux: its likely that if you have "Empty" as a data constructor, you might want to use Maybe instead
10:27:55 <gueux> Empty: option type :-)
10:28:03 <Cale> @src Maybe
10:28:03 <lambdabot> data Maybe a = Nothing | Just a
10:28:13 <Cale> ^^ perhaps that's what you're looking for?
10:28:14 <gueux> oh
10:28:16 <gueux> sorry
10:28:28 <gueux> in OCaml it is not the same names :-)
10:28:47 <gueux> it is Empty and Some :-)
10:28:51 <gueux> thanks again
10:29:11 <rwbarton> (Isn't it Some and None?)
10:29:24 <gueux> 13:28:54 < gueux> it is Empty and Some :-)
10:30:07 <gueux> oh yes
10:30:09 <ziman> It's Some and None in OCaml
10:30:12 <gueux> rwbarton: you are right
10:30:26 <gueux> and I was wrong
10:31:53 <McManiaC> "Contexts differ in length"
10:32:31 <McManiaC>  When matching the contexts of the signatures for
10:32:31 <McManiaC>       delete :: forall a. (Ord a) => a -> Tree a -> Tree a
10:32:31 <McManiaC>       join :: forall a. Tree a -> Tree a -> Tree a
10:32:49 <McManiaC> ???
10:33:30 <McManiaC> what is ghci trying to tell me? =)
10:33:34 <byorgey> McManiaC: it's hard to tell from just the error message.  could you paste your code somewhere?
10:33:38 <byorgey> @where hpaste2
10:33:38 <lambdabot> http://hpaste.org/
10:33:57 <byorgey> oh, hey!
10:34:05 <byorgey> it's not at moonpatio anymore.  nice.
10:34:06 <Cale> what the...
10:34:36 <rwbarton> byorgey: actually, it's not quite so nice, because moonpatio has a separate hpaste2 instance
10:34:37 <Cale> Or is the url just wrong? :)
10:34:42 <Cale> oh
10:34:44 <byorgey> oh, I see.
10:34:48 <McManiaC> http://pastebin.com/d48cc0f19
10:35:44 <byorgey> McManiaC: if join calls delete, and delete requires an Ord constraint, then join should require an Ord constraint too.
10:36:09 <Raynes> Did someone say rain[t] :>
10:36:12 <McManiaC> ah okay
10:36:21 <idnar> enlarge your context in just seven days with all-natural herbal supplements!
10:36:29 <michaelcdever> hey could someone have a look and tell me if there's anyway of speeding this code up? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1421
10:36:32 <McManiaC> thx, works now :)
10:36:41 <byorgey> McManiaC: great =)
10:36:41 <monochrom> haha idnar
10:36:58 <byorgey> @remember idnar enlarge your context in just seven days with all-natural herbal supplements!
10:36:59 <lambdabot> It is stored.
10:37:15 <monochrom> "enlarge your context with all-natural transformations"
10:38:26 <pumpkin> lol
10:48:02 <redditbot> Writing a Rule Engine in Haskell - Part 1
10:50:40 * SamB wonders why emacs 22 isn't highlighting the bodies of comments :-(
10:51:19 <Cale> rwbarton: I'm finding that it helps to start by fixing one of the products and seeing what can be inferred from associativity. In particular, saying that each of the 4 undetermined products is 1 will give you one of 3 particular monoids (one of which is a group). Then you're allowed to assume that they're all not 1.
10:52:06 <maltem> michaelcdever: any particual reason that you're doing that concurrently?
10:52:15 <maltem> *particular
10:57:50 <michaelcdever> maltem: speed!
10:57:54 <michaelcdever> or so i though
10:58:00 <michaelcdever> *thought
10:58:40 <michaelcdever> see it starts at "/", i.e. the highest folder in a linux distro, and goes through the whole system!
10:59:44 <maltem> michaelcdever: It looks to me like the concurrency is what would make your code go slow :)
11:00:00 <maltem> michaelcdever: you're forking a zillion threads, all doing little work
11:00:13 <michaelcdever> i would have though more threads => more speed
11:00:19 <pumpkin> nope
11:00:21 <maltem> no :)
11:00:29 <pumpkin> more threads => more overhead unless the threads are well thought out
11:00:53 <michaelcdever> hmm, well it seemed to run faster
11:00:58 <maltem> well if you have a zillion CPU cores it may pay off
11:01:24 <pumpkin> one core for every file on your system :P
11:01:27 <pumpkin> or folder maybe
11:01:35 <pumpkin> still not a very parallel thing
11:01:39 <Cale> Even then, you'll have to wait for I/O
11:01:44 <michaelcdever> damnit lol
11:01:52 <mauke> so I heard you like to seek all over your disk
11:02:04 <pumpkin> (YO DAWG)
11:02:09 <michaelcdever> gues i didnt think that through
11:03:28 <paper_cc> *thinking* is having a constant number of active workers and a global queue for waiting tasks better than a simple one-thread solution here?
11:05:27 <daf> you're still waiting on IO
11:06:28 <paper_cc> assuming the OS isn't caching things
11:06:57 <michaelcdever> ah ill just have to time both versions and see which averages faster
11:07:00 <michaelcdever> thanks though
11:07:39 <CTA> Haskell any good for commercial games?
11:09:02 <pumpkin> CTA: only awesome free games, sorry
11:09:10 <Cale> CTA: Sure, if you could convince someone to use it :)
11:09:11 <Vq^> CTA: theres no problem with the end product being commercial
11:09:12 <pumpkin> the IO monad doesn't allow money in
11:09:21 <blancolioni> pumpkin: lol
11:09:25 <Vq^> CTA: Haskell programs can be sold
11:09:35 <Cheshire> any commercial games out there written in haskell?
11:09:44 <blancolioni> unsafeEarnMoney :: a -> IO $
11:09:45 <augustss> @src lines
11:09:45 <lambdabot> Source not found. My brain just exploded
11:09:47 <Cale> Not that I'm aware of.
11:09:58 <augustss> what?!?
11:10:02 <beelsebob> CTA: doing some 3D work in Haskell, I've discovered significant advantages
11:10:11 <Cheshire> @wiki Data.List.Split
11:10:12 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
11:10:13 <beelsebob> e.g. lazyness lets you start pushing data to the GPU before you've finished computing it all
11:10:16 <blancolioni> is playing the stock market a commercial game?
11:10:19 <dcoutts> CTA: there are at least two games startups using Haskell
11:10:22 <beelsebob> it lets the CPU/GPU work much more interleaved
11:10:23 <Cale> blancolioni: hehe
11:10:40 <pilkarn> damn i program clojrue and I want to mark all impure functions with !. is there some functional language that does have something monad-like as typenotations but they have no effect? ie an impre function could be randInt :: Int -> Int -> SideeddectInt
11:10:43 <Cale> dcoutts: Oh? Interesting.
11:10:53 <CTA> The thing is, I've been around alot of programming languages, C, C++, pascal [scar], and now just C#, Ive jsut like 2 weeks ago got a book, but im thinking about quiting programming until I leave school - so i can focus on gcse's - but when i come back i want to create powerful games/applications i dont know which programming language to use thats the thing
11:10:56 <blancolioni> CTA: I read a paper recently about offloading work to the GPU in a type-safe way
11:11:20 <beelsebob> CTA: hint for passing your english GCSE – GCSEs, not GCSE's
11:11:23 <Cale> pilkarn: Are you looking for the Identity monad?
11:11:26 <beelsebob> it doesn't belong to the GCSE
11:11:30 <Cale> pilkarn: I don't think I understand your question.
11:11:50 <pumpkin> pilkarn: all functions are pure in haskell
11:11:56 <blancolioni> so, you know, it's hardware-aware ... although I suspect a 3D graphics library is not the killer feature it needs
11:12:00 <pumpkin> except for unsafePerformIO and other unsafe* ones
11:12:17 <Cale> But they don't exist ;)
11:12:20 <CTA> I mean, I might stop programming so that I can focus on math, english and science, then when i leave school in the summer get a book and then get a course
11:12:20 <silkarn> yes but is there a language that is functional but doesnt enforce purity, just marks it and tracks it?
11:12:21 <Vq^> pumpkin: hush, they don't exist remember ;)
11:12:28 <dcoutts> Cale: it's well known that anygma are using Haskell, there's another less well known one too.
11:12:41 <pumpkin> oh no, the Ministry Of Haskell Happiness is knocking on my door :(
11:12:51 <blancolioni> CTA: Haskell is worth learning, whether you end up using it commercially or not
11:12:56 <Elly> better than having the Ministry of Sound knocking on your door :O
11:13:10 <pumpkin> ministry of sound would be better
11:13:11 <blancolioni> on the down side, it makes ones experience with almost any other language a PitA
11:13:31 * dcoutts would prefer the ministry of silly walks
11:13:33 <pumpkin> the ministry of haskell happiness is coming to lock me up in an IO monad and they took my unsafePerformIO away from me :(
11:13:41 * blancolioni walks in a silly manner
11:14:03 <CTA> Could I use Haskell to make things like a poker game? multiplayer - online
11:14:14 <Vq^> CTA: of course
11:14:16 <blancolioni> CTA: absolutely!
11:14:17 <Twey> blancolioni: I don't know, I'm learning Forth and it feels... OK
11:14:21 <dcoutts> isn't that what Joel did?
11:14:23 <Baughn> CTA: Haskell is a general-purpose programming language. You can make about anything that isn't hard realtime.
11:14:24 <silkarn> CTA: you could do anything
11:14:30 <blancolioni> in fact, right now I'm working on my Bridge program
11:14:54 <McManiaC> let say i have a function
11:14:54 <Baughn> CTA: In fact, you could probably do hard realtime too, but you'd have to solve some problems regarding time use in lazy programs first. We'd cheer you on.
11:14:54 <blancolioni> Twey: these feelings will pass :-)
11:14:55 <McManiaC> delete :: (Ord a) => a -> Tree a -> Tree a
11:15:06 <CTA> But, compared to other languages, like java, c, c#, c++ etc would it be ALOT more harder?
11:15:18 <Baughn> Easier, probably. :P
11:15:18 <Cale> CTA: No, probably easier in many ways.
11:15:19 <blancolioni> CTA: easier I think
11:15:21 <Cheshire> CTA, A lot - two words
11:15:22 <McManiaC> and i want to use it for a tree "Ord a => Tree (a,b)"
11:15:23 <Twey> Definitely easier.
11:15:23 <pumpkin> @faq can haskell detect if a haskell program will terminate without running it?
11:15:23 <lambdabot> The answer is: Yes! Haskell can do that.
11:15:25 <blancolioni> lol
11:15:38 <CTA> COOL =D
11:15:45 <Baughn> pumpkin: Yes, but it does that by rewriting the program to always temrinate immediately
11:15:52 <Twey> Especially compared to C.
11:15:52 <Cale> CTA: Of course, using a language you don't know is going to be harder than using one which you do, until you learn it :P
11:15:53 <pejo> Baughn, "have to solve some problems"?
11:15:56 <Cheshire> McManiaC, does Ord a imply Ord (a,b) though?
11:15:57 <pumpkin> Cheshire: you forgot the more harder correction :)
11:15:59 <ferret_0567> why does this take so long to run on a 7 line file?
11:16:00 <ferret_0567> main = interact wordCount where wordCount input = show (length (lines input)) ++ "\n"
11:16:02 <CTA> Lol I'll learn it hopfully when I come back to programming, just the thing is I just bought a c# book like 2 weeks ago lol..
11:16:04 <Twey> I don't know about 'easier' compared to Java, but it would certainly be less tedious.
11:16:09 <Baughn> pejo: Some problems. Yes. ^^;
11:16:19 <pumpkin> Baughn: hah
11:16:34 <Cale> ferret_0567: What?!
11:16:37 <Baughn> pejo: The question of calculating limits to time usage in lazily evaluated languages is... interesting, in the chinese sense
11:16:45 <rwbarton> It's currently harder to use Haskell than Java for certain things, e.g., writing Java applets
11:16:57 * Twey chuckles.
11:17:09 <McManiaC> lol
11:17:14 <Twey> I don't think that's a goal so much as a means
11:17:17 <paper_cc> is it hard to write a GHC bytecode to Java bytecode translator in Haskell :P
11:17:21 <rwbarton> or more seriously, making use of Java libraries
11:17:28 <Cale> ferret_0567: It's instantaneous for me.
11:17:32 <Twey> Yeah
11:17:36 <ferret_0567> I get this for: $ time runghc < quux.txt
11:17:36 <Cale> ferret_0567: How are you compiling it?
11:17:38 <Baughn> paper_cc: Well, if GHC used bytecode...
11:17:38 <ferret_0567> real    0m0.659s
11:17:38 <ferret_0567> user    0m0.556s
11:17:38 <ferret_0567> sys     0m0.052s
11:17:39 <Twey> Well, obviously.
11:17:47 <Cale> ferret_0567: runghc compiles the code first.
11:17:59 <Cale> ferret_0567: So you're seeing the time it takes to compile the program.
11:18:04 <ferret_0567> Cale: err...then how do I interpret it?
11:18:09 <Twey> ferret_0567: Try 'runhaskell' — that's an interpreter
11:18:11 <paper_cc> Baughn: Well, it has bytecode compilation doesn't it?
11:18:16 <Twey> Or compile it first with 'ghc'
11:18:21 <Cale> ferret_0567: Just compile the program first with ghc.
11:18:29 <blancolioni> or run it in ghci
11:18:34 <Baughn> paper_cc: ghci does. Not a very good one; it's about on par with interpreters, I think.
11:18:39 <ferret_0567> Cale: runhaskell takes even longer
11:18:52 <Twey> So compile it
11:18:53 <Cale> ferret_0567: Normally it's just a symlink to runghc
11:18:57 <rwbarton> maybe runhaskell is a symlink to runhugs :P
11:18:59 <Twey> Really? Huh.
11:19:00 <ferret_0567> opps, I meant that to go to Twey
11:19:03 <Cale> (or hugs, yeah)
11:19:05 <CTA> ghci = command prompt thing? is there a compiler for Haskell? And would I use a compiler to make a game?
11:19:15 <rwbarton> CTA: Yes.
11:19:15 <blancolioni> Haskell: the language with hugs
11:19:16 <McManiaC> ghc is the compiler CTA
11:19:16 <Twey> CTA: Yes, yes, and, er...
11:19:18 <Cheshire> CTA, ghc --make MyAwesomeGame.hs
11:19:20 <Baughn> paper_cc: But for performance, you'll want to target the JVM as a "native" assembly target. I'm not sure that makes any sense at all...
11:19:22 <Cale> CTA: ghci is an interactive environment.
11:19:38 <Cale> CTA: You load your program's code into it, and then you can type expressions and see the results.
11:19:46 <blancolioni> CTA: ghc is your compiler
11:19:46 <Baughn> paper_cc: Especially given that sun's java interpreter starts by attempting to decompile the code and then recompiling to native machine code
11:19:57 <McManiaC> funny
11:20:01 <blancolioni> but ghci is beautiful, because you can interactively load and test your modules
11:20:01 <McManiaC> 1 question 1000 answers
11:20:03 <blancolioni> individually
11:20:06 <Twey> Hah
11:20:14 <Twey> Yes, interpreters are good
11:20:15 <Cale> ferret_0567: If you care about performance, you should always compile with at least -O if not -O2
11:20:29 <paper_cc> Baughn: really? how then does Groovy work...?
11:20:38 <blancolioni> twey: yes, it completely changes (for the better) application development
11:20:54 <Baughn> paper_cc: Oh, it maintains semantics
11:21:07 <Twey> paper_cc: Groovy can be decompiled to Java — odd-looking Java, but Java nonetheless
11:21:14 <Twey> Er, compiled Groovy.
11:21:15 <CTA> in c++ you create function like: void a() { std::cout << "hai"; } how would you do that in Haskell?
11:21:16 <Baughn> paper_cc: It's just, if you don't start from java source code, the dynamic compiler will produce bad results
11:21:19 <pumpkin> pfff decompilation
11:21:20 <Twey> They both compile to the same bytecode
11:21:27 <daf> paper_cc: even with a JVM target, you would still need bindings to all the Java libraries in order to be able to do useful things
11:21:31 <p_l> paper_cc: It doesn't decompile the code into Java, but more like AST-form used by compiler
11:21:31 <Baughn> paper_cc: And the farther from java you get.. the worse the results. Haskell is pretty far from java.
11:21:43 <blancolioni> CTA: a = putStrLn "hai"
11:21:49 <paper_cc> generating decompileable assembly is ... well ... a VERY strange task
11:21:59 <true\false> CTA oO
11:22:12 <p_l> Baughn: They are making HotSpot much better with languages other than Java
11:22:20 <Twey> More accurately, a = putStr "hai"
11:22:21 <McManiaC> CTA: http://haskell.org/haskellwiki/Learning_Haskell
11:22:26 <ferret_0567> dang, 0.005 seconds on a P4-M@2.80GHz?! I think that's faster than C!
11:22:29 <blancolioni> twey: true that
11:22:31 <Twey> CTA: C++ 'functions' aren't functions at all
11:22:33 <McManiaC> CTA: take a look at 2.1 and 2.2 :)
11:22:36 <Baughn> p_l: Which will be very interesting once they've actually done it and we can see how well it works.;)
11:22:49 <pumpkin> ferret_0567: do it 1000 times
11:22:59 <pumpkin> tiny times aren't very good for comparison :)
11:23:02 <Cale> ferret_0567: a 7 line file is a silly test :)
11:23:02 <CTA> ill look9ing through real world haskell now
11:23:11 <Baughn> ferret_0567: It's in the noise. Do it repeatedly; and repeat it inside the program, not with a shell script or anything
11:23:11 <blancolioni> CTA: good book that
11:23:15 <McManiaC> CTA: good =)
11:23:17 <Twey> Indeed it is
11:23:18 <CTA> Ill just muck around with it here and then, and when leave school get dirty =)
11:23:28 <rwbarton> ferret_0567: I can guarantee you that your program runs much slower than any reasonable C equivalent :)
11:23:29 <Cale> ferret_0567: Random noise, like other programs running on your machine, is going to dominate the time.
11:23:36 <blancolioni> CTA: haskell is very good for dipping ones toes in
11:23:45 <maltem> CTA: Alas, Haskell is a pure language
11:23:49 <blancolioni> alas?
11:23:51 <CTA> Alas?
11:23:54 <Twey> 'Alas'?
11:23:54 <ferret_0567> Baughn: what do you mean repeat it inside the program?
11:23:56 <Cale> cale@zaphod:~$ seq 1 1000000 | time ./lines
11:23:56 <Cale> 1000000
11:23:56 <Cale> 2.31user 0.13system 0:04.61elapsed
11:23:59 <Baughn> "Alas?"?
11:24:08 <true\false> maltem: As a first language, isn't it a bit like torture?
11:24:09 * blancolioni enjoys the Greek chorus
11:24:14 <Twey> xD
11:24:15 <Baughn> ferret_0567: Something like "main = replicateM 1000 main'"
11:24:17 <Cale> ^^ that's your program, compiled with -O2 on a P4 2.4 GHz.
11:24:18 <Twey> maltem: Er, no
11:24:23 <Twey> true\false: ^
11:24:24 <CTA> lol hai true\false..
11:24:25 <maltem> ey, I thought "alas" would be an English word?
11:24:31 <Twey> maltem: It is
11:24:35 * McManiaC can barely read everything Oo
11:24:38 <Twey> maltem: We're just expressing shock and astonishment
11:24:41 <maltem> maybe means something different from what I thought
11:24:47 <Baughn> ferret_0567: Then make main' your previous main. With any luck that'll just work, but of course it won't if it relies on reading stdin.
11:24:51 <Twey> It means 'unfortunately'
11:24:57 <blancolioni> maltem: jammer, eheu
11:25:02 <Cale> It's much slower than wc -l
11:25:07 <blancolioni> malhereusement
11:25:08 <true\false> CTA: You're worse than me planning for when I finished my A Level exams :)
11:25:23 <CTA> Haha =P
11:25:26 <Cale> But, that's to be expected.
11:25:27 <maltem> Well then it means what I thought. I was replying to CTA planning to get dirty
11:25:31 <Baughn> ferret_0567: Oh, and the "proper" way to replicate wc in haskell is to use the bytestring functions
11:25:32 <blancolioni> lol
11:25:38 <Twey> maltem: Ahhhh.
11:25:45 <Baughn> ferret_0567: Which don't deal with unicode. But then, neither does wc.
11:26:00 <blancolioni> maltem: luckily, there's some dirty little secrets tucked away there
11:26:05 <CTA> Ah, Lol I'm ditching programming - mostly - and going to try and study hard, then go back to programming (:
11:26:07 <Twey> There's a UTF-8 library, isn't there?
11:26:12 <CTA> does haskell get many revs?
11:26:22 <Cale> revs?
11:26:22 <Twey> CTA: ... revs?
11:26:25 <Baughn> Twey: Yep, but it's necessarily a lot slower. I don't know if it's slower than C, though...
11:26:28 <blancolioni> CTA: speed?
11:26:38 <Cale> reviews?
11:26:39 <blancolioni> there's the language shootout page
11:26:39 <silkarn> how do convert string -> List
11:26:47 <Cale> silkarn: read ?
11:26:54 <Twey> I guess the question is 'why would you care'?
11:26:54 <CTA> revisions?
11:26:54 <Cale> > read "[1,2,3]" :: [Integer]
11:26:56 <lambdabot>   [1,2,3]
11:26:58 <Baughn> silkarn: A string is already a list. Of characters, mind.
11:27:07 <Twey> Probably you could get away with just implementing a Unicode-aware check for newlines
11:27:13 <Cale> oh, yes, String = [Char]
11:27:23 <Cale> > [1,2,3] ++ [4,5]
11:27:25 <lambdabot>   [1,2,3,4,5]
11:27:26 <abc528> hi all
11:27:27 <blancolioni> CTA: non-backward-compatible updates?
11:27:28 <Cale> > "hello" ++ "world"
11:27:30 <lambdabot>   "helloworld"
11:27:32 <Baughn> Twey: Well, IIRC utf-8 only has one byte sequence for newline, which is the standard \n
11:27:36 <blancolioni> CTA: or ongoing compiler work?
11:27:39 <Cale> hello abc528
11:27:44 <Baughn> Twey: Same with words. The problem is more wc's -c option..
11:27:50 <Twey> Baughn: Mmm.
11:27:52 <Cheshire> Cale why don't you put mappend and fmap back in?
11:27:55 <silkarn> and hwo do I read a line+
11:27:57 <McManiaC> can i somehow use a function "Ord a => a -> b" on a touple "Ord a => (a,b)" where b is not "in Ord" ?
11:28:05 <Twey> But you can do the same thing with space characters, surely
11:28:08 <Cale> Cheshire: I might be able to do that... if hint has the appropriate features now.
11:28:15 <Twey> Oh wait
11:28:18 <Twey> Sorry, my idiocy
11:28:24 <Baughn> McManiaC: Sure
11:28:31 <Baughn> > fmap (+1) (1,3)
11:28:33 <lambdabot>   (1,4)
11:28:37 <blancolioni> silkarn: getLine
11:28:40 <Baughn> McManiaC: But not with fmap, directly. ^^;
11:28:51 <Cheshire> swap . fmap f . swap
11:28:52 <Cale> McManiaC: you mean apply it to the first element?
11:29:24 <Cale> first f
11:29:30 <Cale> If you import Control.Arrow
11:29:32 <McManiaC> insert :: (Ord a) => a -> Tree a -> Tree a
11:29:41 <rwbarton> CTA: ghc gets new language features frequently, but they're not standardized
11:29:44 <McManiaC> which i wanna use for:
11:29:50 <McManiaC> add' :: Ord a => (a,b) -> Dict a b -> Dict a b
11:30:01 <McManiaC> Dict a b = Tree (a,b)
11:30:18 <pumpkin> I'd be quite happy to say "I'm learning ghc" over haskell, if standard haskell is lacking all those fun features
11:30:22 <CTA> will there be alot more things changed by summer 2010?
11:30:22 <Cale> Oh, then (a,b) is not in Ord.
11:30:28 <Cheshire> McManaiC, you can make data Leaf a b = Leaf a b
11:30:28 <ferret_0567> Cale: well, it's less than 2 seconds slower
11:30:40 <Cheshire> instead of (a,b)
11:30:51 <blancolioni> CTA: there will be things added, but the basic language will remain the same
11:30:58 <CTA> kk
11:31:02 <ferret_0567> Cale: I tried my program on a 2.8GHz P4-M and it's less than 2 secs. slower with music playing
11:31:12 <CTA> Ill just muck around with it here and then and then get a book in 2010 =(
11:31:14 <CTA> *=)
11:31:25 <ferret_0567> Cale: than wc -l, that is
11:31:31 <pumpkin> ferret_0567: there's a wiki article on making a fast wc -l program :)
11:31:41 <McManiaC> (a,b) is required tho Cheshire
11:31:44 <McManiaC> =(
11:31:50 <Cheshire> McManiaC, impossible
11:31:53 <McManiaC> ok
11:32:14 <McManiaC> so i have to write a 2nd function =)
11:32:36 <rwbarton> McManiaC: you could make a newtype Pair k v = Pair (k, v) with an Ord instance that only compares k, and then set Dict a b = Tree (Pair a b)
11:32:38 <ksf> bleeding hell.
11:33:10 <ksf> I'm so used to little endian, I completely forgot that div/mod'ing straight away doesn't work out for big endian.
11:33:21 <rwbarton> McManiaC: or, probably more sanely, you could make a version of add called "addBy" that takes an explicit comparison function rather than using an Ord instance
11:33:26 <Baughn> ksf: Hmm? Sure it does..
11:33:29 <silkarn> http://www.anygma.com/TheCompany.html
11:33:44 <true\false> in foldl (\acc n -> if take nlen n == needle then True else acc) False (tails haystack) -- In this, what exactly does that False (tails haystack) do?
11:33:50 <Baughn> ksf: Er, unless you're looking at the assembly level. You aren't, right?
11:34:04 <ksf> i'm looking at the byte level.
11:34:07 <ksf> ...and bits.
11:34:15 <CTA> I like the "round" keyword
11:34:19 <true\false> Erm whoops .. I wasn't looking at the entire thing, ignore.
11:34:22 <Baughn> ..seems sempler to parse it to an Integer first
11:34:43 <rwbarton> true\false: it's not a subexpression
11:34:53 <Twey> CTA: Keyword?
11:34:55 <rwbarton> true\false: your expression is (foldl (long lambda expression) False) (tails haystack)
11:35:03 <pmurias> hi, i get:
11:35:09 <Twey> If you're talking about Haskell, round is a function
11:35:12 <Twey> @src round
11:35:12 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:35:14 <McManiaC> rwbarton: hm i guess that wont do it, thx anyway
11:35:24 <true\false> rwbarton: Yes I just noticed heh.. Slipped past me for a minute
11:35:24 <Twey> A magic native function, but a function nonetheless
11:35:27 <blancolioni> @type round
11:35:29 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:35:40 <CTA> That's what I meant, by i didnt think it was function because wasnt concatenated by parenthesees
11:35:43 <pmurias>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
11:35:43 <pmurias>            against inferred type `B.ByteString'
11:35:46 <CTA> I cant spell..
11:36:03 <Twey> CTA: Brackets aren't used for function application in Haskell
11:36:05 <Cheshire> CTA, you can do it if you try hard
11:36:06 <pmurias> when i try to use Data.Binary
11:36:09 <blancolioni> CTA: you mean x = round y instead of round (y)
11:36:12 <Twey> The equivalent of C-like a(b) is simply a b
11:36:35 <pumpkin> pmurias: you need to use the right bytestring... unfortunately there are different kinds :/
11:36:44 <Cale> > let myFunction x = x^2 + x + 1 in myFunction 5
11:36:46 <lambdabot>   31
11:37:04 <pumpkin> pmurias: try importing qualified Data.ByteString.Lazy as L
11:37:14 <pmurias> pumpkin: why don't they have a common typeclass
11:37:15 <pmurias> ?
11:37:21 <pumpkin> pmurias: nope :P
11:37:41 <pumpkin> someone tried to make one I think
11:37:58 <maltem> pmurias: I think the argument was that the type class would be "too large"
11:38:29 <pumpkin> pff, some of the c++ classes in the osx kernel have a couple hundred vtable entries!
11:38:40 <ski_> dolio : not every category is (i.e. can be made) concrete over `Set', if that's what you were thinking of
11:38:43 <ski_> silkarn : "is there a language that is functional but doesnt enforce purity, just marks it and tracks it?" what's the difference ?
11:39:04 <rwbarton> ski_: unless you are willing to enlarge your universe right
11:39:05 <rwbarton> ?
11:39:13 <Cale> ski_: I suppose that it would let you use values of type IO t as if they were values of type t directly?
11:39:25 <pumpkin> with perfectly safe herbal remedies?
11:39:49 <ferret_0567> is there a Haskell autocomplete for Vim?
11:40:08 <ksf> what's a morphism called that results in a projection of its category, hiding all morphisms but itself?
11:40:25 <ksf> there's hasktags.
11:40:26 <ski_> rwbarton : i seem to recall the example being the category of homotopies (and i seem to recall it was Lawvere proving there is no way to make it concrete over `Set')
11:40:35 <pmurias> maltem: what's the problem with an overly large typeclass?
11:41:01 <ski_> rwbarton : not having studied this, i can't say whether size issues are relevant
11:41:08 <pmurias> pumpkin: thanks, worked for me
11:41:31 <blancolioni> when ghc says Expected type x, Inferred type y, which one is which?
11:41:34 <blancolioni> I can never remember
11:41:47 <ski_> Cale : yes, but that would just be syntactic sugar on haskell (which i've been trying to design), unless the impurity wasn't tracked
11:41:49 <Cheshire> blancoliononi me neither lol
11:41:53 <ksf> x is the one you should pass, y is the one you passed.
11:42:02 <maltem> pmurias: I'm not sure, maybe it would just be considered unorthodox
11:42:03 <blancolioni> Cheshire: glad I'm not the only one! hee
11:42:08 <blancolioni> ksf: thanks
11:42:31 <hackage> Uploaded to hackage: pqueue-mtl 1.0
11:42:31 <hackage> Uploaded to hackage: stateful-mtl 1.0
11:43:24 <ski_> F. William Lawvere, Homotopy is not Concrete
11:43:58 <maltem> blancolioni: I admit to keep wondering about that too
11:44:26 <blancolioni> maltem: don't worry, I shan't tell anyone :)
11:44:27 <Twey> blancolioni: x is the type it expects, and y is the type it inferred :-P
11:44:45 <ski_> ksf : i don't understand your question. could you clarify ?
11:44:54 <blancolioni> next question: does GHC ever get confused when you're changing the type of an exported function in a cabalised library?
11:45:02 <blancolioni> one that's already installed
11:45:15 <maltem> blancolioni: I have wondered about some textual or graphical representation that would make it immediately clear, but I haven't thought of a good one yet
11:45:15 <Twey> 'Changing the type'?
11:45:17 <ferret_0567> what is the function that counts characters?
11:45:25 <Baughn> blancolioni: DOn't do that without bumping the version number
11:45:25 <ksf> ski_, I just thought It'd be a nice thing to say to a girl.
11:45:32 <Twey> What could be clearer than 'expected type x, inferred type y'?
11:45:39 <Twey> HAHAHA, ksf
11:45:53 <MyCatVerbs> ferret_0567: a string is a list of characters in Haskell, so you use the function "length", which counts the number of elements in any list.
11:45:58 <ehird> anyone using yi on os x?
11:45:59 <blancolioni> baughn: no worries, my darcs repository doesn't work yet :)
11:46:06 <ferret_0567> MyCatVerbs: oh yeah
11:46:08 <blancolioni> (which will be my next queston of course)
11:46:11 <ski_> ksf : maybe if the girl in question is a category terrorist ..
11:46:27 <blancolioni> twey: well, did it expect the type going in, or coming out?
11:46:43 <blancolioni> twey: I had findGadget:: String -> ....
11:46:47 <Twey> blancolioni: The expected type is the one it's been told to expect
11:46:59 <blancolioni> twey: now I have findGadget:: [String] -> ...
11:47:01 <Twey> (from the top down)
11:47:04 <ksf> nah, there's some platonic ideal leaking through when you explain it after she started to stare blankly at you.
11:47:21 <mauke> context >> expression << context
11:47:28 <maltem> Twey: I usually wonder where the top is
11:47:32 <blancolioni> but I wonder if ghc is finding the old type somewhere
11:47:36 <Twey> blancolioni: Uhm, you can't just... change the type of an expression like that
11:47:46 <ski_> ksf : oh .. you mean like when what you're interested is platonic love ?
11:47:54 <maltem> Twey: That is, which sub-expression the error talks about
11:48:00 <blancolioni> twey: well, that's the thing, I changed the type, then I changed the type of the thing that uses it
11:48:01 <mauke> "expected type" is what the context demands of the expression; "inferred type" is what the expression itself is
11:48:02 <Twey> blancolioni: The top is the top-level functions in your program
11:48:06 <ksf> rather as in "if you were a cake, you'd be the only one on earth"
11:48:09 <Twey> From the top
11:48:10 <blancolioni> but the error looks like it's using the old type
11:48:22 <Twey> blancolioni: Have you recompiled the library?
11:48:26 <blancolioni> (which led me to the expected, inferred question)
11:48:34 <blancolioni> twey: make clean; make config; make
11:48:41 <blancolioni> I didn't uninstall the package though
11:48:44 <blancolioni> maybe I should do that
11:48:47 <Twey> Yeah
11:48:51 <blancolioni> oh, this is all in the same library though
11:49:01 <Twey> make clean will just remove the stuff in the build directory, generally
11:49:13 <blancolioni> twey: well, I wrote the Makefile :-)
11:49:15 <Twey> If you have installed it elsewhere it's liable to get it from there
11:49:23 <Twey> Hmm
11:49:44 * ski_ suddenly wonders whether Clean uses a Makefile to build
11:50:02 <ski_> (Concurrent Clean, for you pedants)
11:50:08 <mauke> My stack overfloweth.
11:50:11 <Gracenotes> I'm reading about existential types.. do those have much to do with type unification?
11:50:25 <Gracenotes> both have "type" in the name :D
11:50:32 <ddarius> Gracenotes: No more or less than universal quantification.
11:50:32 <blancolioni> ok, this is just weird ... I think there's a problem between the keyboard and the screen
11:50:40 <ski_> Gracenotes : not much more than all type checking has to do with unification
11:50:53 <Gracenotes> fair enough.
11:51:30 <ski_> (blancolioni : try binary-search debugging)
11:51:39 <Cheshire> Is existential a good name
11:51:40 <Cheshire> ?
11:51:45 <Cheshire> do they really exist at all
11:52:05 <blancolioni> ski_: are we talking about commenting half the file and trying that, rinse, repeat?
11:52:26 * ski_ always thinks of the quantification when those philosophers/thinkers are mentioned
11:53:12 <ddarius> Cheshire: "existential type" is really "type containing existential quantification"
11:53:12 <Cheshire> I don't feel that existential type as a name makes any sense at all
11:53:13 <ski_> blancolioni : no, we're talking about cutting the thing between the keyboard and and the screen in two, and trying with one half at a time
11:53:22 <blancolioni> ski: lol
11:53:27 <Twey> Hahaha
11:53:29 <blancolioni> but I need it!
11:54:01 <Twey> The thing between my keyboard and screen is... a cereal bowl
11:54:01 <stepcut> is standalone deriving in GHC 6.8.3?
11:57:29 <Deewiant> stepcut: I'm fairly certain it is
11:58:11 <stepcut> Deewiant: thanks
12:04:01 <SamB> hey, does anyone happen to know if it's possible to configure ispell to allow both american and british spellings at once ?
12:04:55 <Twey> You could always merge the dictionaries
12:05:02 <SamB> other than that ?
12:05:08 <ehird> I get this:
12:05:08 <ehird>     Could not find module `Graphics.UI.Gtk':
12:05:11 <ehird> after installing gtk2hs
12:05:14 <ehird> :\
12:05:29 <SamB> ehird: how do you build?
12:05:37 <blancolioni> ehird: is that a fedora install?
12:05:38 <SamB> the code that tries to import it, I mena
12:05:47 <rwbarton> what's after the : ?
12:05:47 <ehird> samb: ghc --make
12:05:50 <ehird> blancolioni, nope
12:05:54 <ehird> rwbarton:       Use -v to see a list of the files searched for.
12:05:58 <Twey> ehird: I think it's Graphics.UI.GTK
12:06:00 <ehird> I bui
12:06:01 <ehird> er
12:06:06 <ehird> Twey: no, this is one of the demos
12:06:13 <ehird> I'm assuming they didn't break their own demos!
12:06:14 <Twey> Oh
12:06:16 <Twey> Hmm
12:06:32 <SamB> maybe they did
12:06:36 <ehird> I build gtk2hs like: PKG_CONFIG_PATH=(hideously long) ./configure --prefix=/Library/Frameworks/GHC.framework/Versions/Current/usr
12:06:42 <SamB> by some kind of freak editor accident ?
12:06:54 <blancolioni> twey: I think Gtk is correct
12:06:56 <ehird> SamB: .GTK doesn't work either
12:07:07 <rwbarton> does ghc-pkg list show gtk2hs?
12:07:13 <blancolioni> import qualified Graphics.UI.Gtk as Gtk
12:07:15 <SamB> @hoogle gtk
12:07:16 <lambdabot> package soegtk
12:07:16 <lambdabot> package yi-gtk
12:07:18 <ehird> [ehird:~/Downloads/gtk2hs-0.10.0/demo/hello] % ghc-pkg list|grep gtk
12:07:19 <ehird> [ehird:~/Downloads/gtk2hs-0.10.0/demo/hello] %
12:07:35 <Twey> I'd try, but I can't get gtk2hs to build
12:07:48 <ehird> wait a secamo...
12:07:48 <ehird> * gtk            : no
12:07:50 <Twey> No, it is Gtk
12:07:54 <ehird> HOW ODD.
12:07:57 <Twey> ehird: Maybe ghc-pkg?
12:08:01 <ehird> G_CONFIG_PATH=/Library/Frameworks/Gtk.framework/Resources/dev/lib/pkgconfig/Library/Framew
12:08:03 <ehird> doh!!
12:08:08 <Twey> Ahhhhhh
12:08:14 <Twey> Forgot to append?  :)
12:08:23 <ehird> Forgot the colon :-)
12:08:27 <ehird> "b/pkgconfig/Library/Framew"
12:08:31 <Twey> *looks more closely*
12:08:37 <Twey> Oh :-D
12:08:51 <ehird> ... although this still happens: checking for GTK... no
12:11:31 <Cheshire> Kripke relations are just relations indexed by a context then
12:13:32 <ski_> (rwbarton,(dolio) : however .. if i'm allowed to make a wild guess, i'd wager that the problem with homotopy is not size issues, but that homotopy morphisms are not functions on structures sets preserving that structure, but equivalence classes of such functions)
12:13:50 <pumpkin> that's crazy talk
12:16:02 <gueux> isn't it possible to provide only the signature of a module? ghci responds me: "The type signature for ... lacks an accompanying binding"
12:16:33 <trofi> of a module?
12:16:45 <blancolioni> in a module?
12:16:49 <alatter> guex: if you're prototyping things, I often just use 'undefined' as the body of a function I want to provide a type for
12:17:18 <blancolioni> alatter: oh, yeah, that's useful for records as well
12:17:42 <blancolioni> if there's no suitable value before other things have been done to it
12:17:49 <blancolioni> blows up nice and early too
12:17:50 <ski_> gueux : unfortunately, haskell's module system lacks module signatures
12:18:05 <gueux> arg
12:18:24 <gueux> so, I need to use alatter solution
12:18:31 <gueux> alatter's solution
12:18:44 <ski_> (.. though now i see you probably weren't after that)
12:19:06 <pmurias> is there a way i could read in little endian data with Data.Binary?
12:19:29 <trofi> @hoogle word16le
12:19:29 <lambdabot> No results found
12:19:37 <alatter> pmurias: yup.  It's in the Data.Binary.Get module
12:19:37 <trofi> @hoogle 16le
12:19:37 <lambdabot> Parse error:
12:19:37 <lambdabot>   --count=20 16le
12:19:37 <lambdabot>              ^
12:19:49 <ehird> @hoogle "@£(*!*(&
12:19:50 <lambdabot> Parse error:
12:19:50 <lambdabot>   --count=20 "
12:19:50 <lambdabot>              ^
12:19:55 <ehird> ...
12:20:01 <ehird> @hoogle "; ls
12:20:02 <lambdabot> Parse error:
12:20:02 <lambdabot>   --count=20 ""; ls"
12:20:02 <lambdabot>              ^
12:20:06 <trofi> :]
12:20:10 <bolrod> O.o
12:20:40 <blancolioni> this must be obvious
12:20:43 <gueux> ski_: so, how can I do parametrized modules? I need to provide a signature to do it...
12:20:46 <blancolioni> uiElementName :: Widget -> [String]
12:20:49 <trofi> @hoogle "; cat /etc/fstab
12:20:49 <lambdabot> Parse error:
12:20:49 <lambdabot>   --count=20 ""; cat /etc/fstab"
12:20:49 <lambdabot>              ^
12:20:56 <blancolioni> findGadget :: [String] -> Behaviour a -> Maybe (Gadget a)
12:21:07 <blancolioni> uiElementName w >>=
12:21:09 <blancolioni> >                                  \ x -> findGadget x behaviour
12:21:10 <lambdabot>   Not in scope: `findGadget'Not in scope: `behaviour'
12:21:16 <alatter> guex: what do you mean by paramterized modules?  In the ML sense?
12:21:30 <gueux> yes
12:21:31 <blancolioni> expected [string], found string
12:21:54 <alatter> guex: Haskell modules can't do that.  Typeclasses are often used to provide similar functionality.
12:21:56 <mauke> makes sense
12:22:09 <rwbarton> blancolioni: seems unsurprising, the name of an element is probably a String not a [String]
12:22:11 <gueux> alatter: ok
12:22:14 <blancolioni> uiElementName evaluates to a list of string, findGadget expects a list of strings as the first argument
12:22:18 <alatter> guex: Or just parametric polymorphism.
12:22:29 <mauke> blancolioni: >>= is concatMap, x is a String
12:22:45 <blancolioni> mauke: aaarrrrrrrrrrrrrrrrhhhhhhhhhhh
12:22:54 <blancolioni> it used to be in the Maybe monad
12:23:14 * blancolioni has a long hard look at himself
12:23:28 <opqdonut> :t listToMaybe
12:23:30 <lambdabot> forall a. [a] -> Maybe a
12:23:33 <opqdonut> :t maybeToList
12:23:35 <lambdabot> forall a. Maybe a -> [a]
12:23:46 <ski_> gueux : see e.g. <http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html> (and subsequent posts, i think)
12:23:49 <blancolioni> the thing was, uiElementName used to return Maybe String
12:24:01 <blancolioni> now it returns [String]
12:24:08 <blancolioni> but I left the Monad in
12:24:14 <blancolioni> because I am stoopid
12:24:25 <mauke> WISDOM SHALL BE RECEIVED.
12:24:38 * blancolioni gets hit in the head by flying wisdom
12:24:54 <Cheshire> Unidentified Flying Wisdoms
12:26:07 <blancolioni> findGadget (uiElementName w) behaviour
12:27:09 <pmurias> alatter: thanks
12:27:57 <ehird> " Yi only attempts to support GHC 6.8.3 and is moving towards 6.10."
12:28:01 <ehird> Does Yi not work on 6.10...?
12:28:32 <jrockway> it works for me under 6.10... i think
12:28:48 <Gracenotes> > 0o0377
12:28:50 <lambdabot>   255
12:28:58 <Gracenotes> o raly :o
12:29:52 <mle> jrockway: which ui lib are you using?
12:30:22 <jrockway> vty
12:30:24 <ksf> last time I tried, it compiled fine.
12:30:52 <jrockway> i have not looked at it in depth
12:30:57 <blancolioni> gtk2hs 0.10.0 works with ghc 6.10 doesn't it?
12:31:02 <jrockway> i installed it this morning, edited some files, and pushed it onto my todo list
12:31:14 <jrockway> i was surprised how well it worked :)
12:31:17 <jrockway> and how good the design is
12:31:22 <gueux> and then, with classes, can I use types which are not already defined?
12:31:23 <jrockway> i may not have to rewrite emacs ;)
12:31:40 <ksf> cursor movement is slow.
12:32:00 <ksf> it works if you press keys, but it can't keep up with my mousewheel.
12:32:05 <ehird> I installed gtk2hs with the OS X gtk port
12:32:25 <ehird> _hopefully_ I'll get a native Yi, and it doesn't seem to use many gtk widgets so it'll fit in looks-wise, too.
12:32:26 <ehird> hopefully.
12:32:35 <alatter> guex: that's the idea.  It isn't precisely the same as ML functors, though.
12:33:07 <gueux> alatter: gueUx :-)
12:33:27 <alatter> gueux: sorry!  lot's of vowels, there
12:33:36 <ehird> tab-complete :-)
12:34:06 <pejo> ehird, can hardly fail.
12:34:08 <gueux> it's a french word, that's the explaination :-)
12:34:15 <alatter> gueux: the '==' operator is a great example of typeclasses in Haskell.
12:34:25 <ehird> pejo: oh believe me gtk2hs on os x is a _nightmare_
12:34:38 <pejo> ehird, I meant tabcomplete. :-)
12:34:40 <ehird> oh
12:34:41 <ehird> :-P
12:34:54 <alatter> ehird: is the native gtk at all useful for gtk2Hs?
12:35:02 <ehird> alatter: Yes.
12:35:06 <ehird> It works fine.
12:35:20 <ehird> Although it misses a few libraries; might wanna compile them yourself. Should be enough for yi though.
12:35:22 <ehird> But yes, works great.
12:35:27 <ehird> It's just a pain to get compiled properly.
12:35:41 <alatter> ehird: I've been to scared to embark on that journey.  I guess I should give it a try
12:35:50 <mauke> > Just "fine" === length "fine"
12:35:52 <lambdabot>   False
12:36:02 <ehird> alatter: Try http://www.gtk-osx.org/ for the native installer
12:36:11 <ehird> alatter: PKG_CONFIG_PATH=/Library/Frameworks/Gtk.framework/Resources/dev/lib/pkgconfig:/Library/Frameworks/GLib.framework/Resources/dev/lib/pkgconfig:/Library/Frameworks/Cairo.framework/Resources/dev/lib/pkgconfig
12:36:15 <ehird> put that before the gtk2hs ./configure
12:36:20 <rwbarton> :t (===)
12:36:22 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
12:38:15 <ehird> How can I use cabal-install to install all the dependencies of a package, but not the pkg?
12:39:31 <dons> mm
12:40:01 <doserj> Ctrl-C at the right moment :)
12:40:08 <ehird> ... wait a second
12:40:14 <ehird> There's an experimental cocoa gui for yi?
12:40:20 <ehird> And nobody told me... why? :-P
12:42:04 <gueux> I'd like to do a class like this one: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1403#a1403
12:42:30 <mauke> that's highly non-H98
12:42:47 <gueux> but I can't find a complete example with a type which is not already defined
12:42:57 <gueux> mauke: :-)
12:44:18 <gueux> it's just the idea: I just want to say: ok, this type does not exist, but one day, it will
12:45:42 <rwbarton> gueux: you need to add the parameter 'a' to each of those data types
12:45:59 <gueux> ok
12:47:04 <gueux> rwbarton: data Position a ?
12:47:13 <rwbarton> right, and then also when you use them
12:47:49 <gueux> and then:   isLegal :: State -> Move -> Bool
12:47:52 <gueux> oups
12:48:07 <gueux> isLegal :: State a -> Move a -> Bool ?
12:48:41 <gueux> ghci says: Illegal family instance for `State'...
12:49:42 <rwbarton> well, you need {-# LANGUAGE TypeFamilies #-}
12:51:16 <gueux> rwbarton: ?
12:51:33 <paper_cc> @wiki GHC/Type_families
12:51:33 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
12:51:34 <gueux> ok
12:51:47 <gueux> I put it on the top of my file
12:51:51 <gueux> and it worked
12:52:03 <paper_cc> gueux: well, if you just want to forward-declare your types, it's not neccesary at all
12:52:17 <gueux> thanks
12:53:01 <paper_cc> gueux: by saying "data Foo" you're "defining" a type: a datatype with _no_ constructors
12:53:03 <gueux> paper_cc: I wanted to have several "State" types for example
12:53:26 <gueux> ok
12:53:27 <paper_cc> parametrized types? data State a = something?
12:53:30 <peaker> Or an associated data type in a class?
12:53:32 <rwbarton> paper_cc: no, it's not a definition, it's in a class
12:54:22 <paper_cc> rwbarton: "data Foo" is a definition when put on the top level, isn't it?
12:54:50 <rwbarton> paper_cc: oh, yes.
12:55:15 <rwbarton> but not if it's inside a class declaration.
12:55:29 <paper_cc> (11:51:46 PM) gueux: I put it on the top of my file
12:55:29 <paper_cc> (11:51:51 PM) gueux: and it worked
12:55:33 <paper_cc> rwbarton: ^^
12:55:47 <rwbarton> meaning the LANGUAGE pragma I assumed
12:56:18 <paper_cc> gueux: do you actually want a State type for every a in Boardgame a?
12:56:24 <gueux> well, I just want to have "ML module sig" like with haskell
12:56:45 <gueux> paper_cc: you mean the same State type?
12:56:55 <gueux> I'm not sure :-)
12:56:58 <Olathe> If there are multiple ways to solve a problem, are there easy ways of keeping track of the current global optimum and halting tries that are guaranteed to be suboptimal ?
12:57:09 <paper_cc> gueux: I don't mean, I ask =)
12:57:59 <alatter> ehird: thanks for the pointers for gtk2hs on OS X - but 'make' bombs out pretty early on
12:58:46 <alatter> gueux: do you have code up somewhere we can take a look at? http://hpaste.org/ is pretty good
12:59:08 <gueux> paper_cc: so, I think the State could be the same for all the Boardgames :-)
12:59:17 <paper_cc> gueux: if you want a single State type for any Boardgame, you don't have to do anything except define the State type
12:59:30 <gueux> ok
12:59:30 <paper_cc> it doesn't matter if it is defined before or after Boardgame
13:02:02 <paper_cc> gueux: if you want to limit exports from your module, you should write "module Foo ( DataType(constructors or nothing or .. (two dots) for all constructors), functionOne, functionTwo ... ) where" at the top of your file$ then you will export only the entities listed
13:02:06 <gueux> paper_cc: in fact, State would be a record with a "board" of type Board, a "player turn" of type Player,...
13:02:40 <paper_cc> gueux: what's the purpose of having a typeclass then?
13:02:45 <gueux> ...
13:03:18 <gueux> it's because I want to have "ML module sig"
13:03:30 <pejo> gueux, I think ski answered your question earlier: 12:17:50 <ski_> gueux : unfortunately, haskell's module system lacks module signatures
13:03:38 <gueux> and it seems that it is not possible
13:03:41 <gueux> pejo: yes
13:04:08 <gueux> but paper_cc rehasked me why I wanted to use typeclass
13:04:33 * paper_cc is frustrated by the fact he doesn't know any ML at all
13:04:52 <gueux> in fact my ultimate goal would be to define what a boardgame is
13:05:02 <gueux> and then to define some boardgames :-)
13:05:22 <rwbarton> if you plan on implementing several boardgames, and then writing functions that operate on any of them, the typeclass approach makes perfect sense
13:05:34 <gueux> rwbarton: ok
13:05:59 <paper_cc> is something to do such things called a module in ML?
13:06:12 <gueux> rwbarton: it is exactely what I want to do
13:06:39 <pejo> @google type classes ml modules aplas
13:06:41 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/publications/WehrChakravarty2008.html
13:06:41 <lambdabot> Title: ML Modules and Haskell Type Classes: A Constructive Comparison
13:06:45 <gueux> "a module sig" permit to say: that is a family of modules
13:07:07 <gueux> and then "use" the functions of these modules
13:07:21 <gueux> or apply functor on these modules :-)
13:07:47 <paper_cc> gueux: a typeclass defines "a family" (in that ML sense) of types
13:08:07 <paper_cc> there's no such thing for modules though :(
13:08:21 <gueux> yes, but a boargame can be a type, too
13:08:23 <gueux> :-)
13:08:48 <pejo> paper_cc, augustss has a couple of blog posts of something that was easy to do in ML and hard to do in Haskell in December last year iirc.
13:09:03 <Toxaris> but typeclasses are somewhat implicit, while ML-style modules are very explicit
13:09:21 <pejo> paper_cc, the blog posts are rather enlightening for those of us who aren't very familiar with ML-style module systems.
13:09:30 <mreh> i've followed the instructions to install a module from hackage, however my compiler cant find it
13:09:34 <mreh> what gives?
13:09:43 <cypher-> even if they have the same expressive power, ML modules are quite more painful to use
13:09:44 <pejo> mreh, does ghc-pkg list it?
13:09:53 <Toxaris> mreh: your compiler == ghc?
13:10:14 <mreh> yes, and yes
13:10:16 <ksf> how come http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/doc-index.html lists "verboseCheck", but Test.QuickCheck doesn't contain it?
13:10:18 <paper_cc> gueux: then, if you want to have some types associated with your Boardgame you can use either MultiParamTypeClasses && FunctionalDependencies or TypeFamilies
13:10:48 <Toxaris> cypher-: depends. in Haskell you sometimes have to use newtypes to select the instance you want, in that cases ML can be easier
13:11:25 <paper_cc> paper_cc: using MultiParamTypeClasses will be a pain when you want to have a not-very-small number of associated types though
13:12:08 <Toxaris> mreh: what do you mean with "does not find it"? do you compile with --make and it doesn't find the modules?
13:12:29 <pejo> ksf, differing version between your Test.QuickCheck and the one docs are for on haskell.org?
13:13:07 <ksf> that's what I thought, but the ghc docs don't contain verboseCheck, either.
13:13:08 <mreh> i'm using GHCI, Toxaris
13:13:32 <ksf> oh, wait.
13:13:35 <Sekaino> Anyone active for a quick question about type class instantiation?
13:13:47 <mreh> so i attempted to load the module that imported the package i installed, not much luck
13:14:00 <mreh> import Data.Colour.RGBSpace.HSV
13:14:37 <ksf> I've got a newer version that ghc-latest: 2.1.0.1
13:14:39 <alatter> mreh: what error are you getting?
13:14:44 <alatter> mreh: what are you typing in ghci?
13:14:48 <mreh> i got that from hackage, also where i got it
13:14:51 <blancolioni> Sekaino: shoot
13:15:04 <mreh> just :load SimpleGraphics, standard way to load a module
13:15:22 <alatter> mreh: right
13:15:34 <Sekaino> blancolioni, I'm importing Data.Complex to use the (Complex a) datatype.  It has the Show class instantiation derived for it.  I want to replace the implementation of Show.  Is there any way to hide the default implementation?
13:15:35 <mreh> i've fixed it
13:15:40 <mreh> sorry about that :D
13:15:51 <mreh> for somereason you need to restart GHCI!
13:16:03 <Saizan_> Sekaino: no, there isn't
13:16:03 <Sekaino> (i.e. I want it to show polar representation by default, rather than cartesian)
13:16:05 <mreh> it's always the last one you try isnt it
13:16:11 <alatter> mreh: good to hear it works :-)
13:16:24 <Saizan_> Sekaino: the best you can do is wrap it in a newtype and write a different instance for that
13:16:26 <blancolioni> Sekaino: good question
13:16:26 <Sekaino> Hm, that's unfortunate.  So my only option is to do a newtype and rederive the classes?
13:16:42 <Toxaris> Sekaino: not rederive it, but write an instance by hand
13:16:53 <blancolioni> Sekaino: you can automatically rederive most of them
13:16:56 <Sekaino> Well rederive the other instances, and hand-code the one I want to change, I mean.
13:16:57 <ksf> now I don't know which one to use.
13:17:01 <mreh> is anyone doing a Haskell project with GSOC?
13:17:07 <Toxaris> Sekaino: but maybe it is easier just to write showPolar and use that instead of show
13:17:09 <ksf> OTOH, I now know that my function isn't tested properly.
13:17:24 <blancolioni> you could also write 'showPolar', depending on what your need is
13:17:37 <Sekaino> Toxaris, that would normally be the case, but I'm using Data.Complex as one of several backends that overload the show method.
13:17:42 <ksf> I need a random distribution between 0 and 2^56-2 for my Integers.
13:17:56 <rwbarton> Sekaino: You can use GeneralizedNewtypeDeriving to automatically derive Num and so on
13:18:13 <Sekaino> rwbarton, GHC extension?
13:18:49 <Toxaris> Sekaino: Show is meant for printing Haskell code, not user readable code or code in some specific presentation, so it may be "more correct" in some sense to use a different type class
13:18:52 <pmurias> mreh: GSOC = Google Summer of Code?
13:18:59 <blancolioni> Sekaino: yes
13:19:14 <mreh> pmurias: yes
13:19:15 <Toxaris> Sekaino: otoh, Show is handy because it is already there :)
13:19:36 <mreh> i'm not sure what the deal is, is there a list of proposed projects compiled already?
13:20:05 <pmurias> mreh: doesn't it happen in a different time of year?
13:20:25 <Toxaris> application are due soon
13:21:04 <mreh> it happens in the summer
13:21:14 <mreh> where do i apply?!
13:21:42 <Sekaino> Toxaris, that's a good point.  I was choosing to use Show since the showsPrec construction is rather convenient. :)
13:22:54 <alatter> Sekaino: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/prettyclass
13:24:38 <Sekaino> alatter, good to know.  For this project, however, I'm trying to stay as vanilla Haskell98 as possible as a teaching tool.
13:25:04 <Sekaino> Speaking of which, what's the latest word on when the Haskell' standard will be ready? :)
13:25:45 <Cale> 世界の何かな...
13:25:54 <alatter> I thought they were thinking about doing incremental updates, rather than one big new standard.  I haven't hard anything in a while.
13:26:06 <pumpkin> Cale: o.O
13:26:11 <Sekaino> 世界の愛だね。
13:26:18 <Cale> :)
13:26:20 <pumpkin> lol
13:26:25 <Cale> hehe
13:26:51 <pumpkin> 世界の肛門の
13:26:54 <repnop> そうと？
13:27:03 <blancolioni> 哇
13:27:43 <Cale> Sekaino: Last I've heard, it's sort of become an ongoing project to separately standardise the extensions... but I'm not certain.
13:28:18 <Sekaino> Aha, but that implies no changes to the core language, no?
13:28:38 <blancolioni> I hope the if-then-else syntax change goes in
13:28:43 <idnar> Sekaino: wasn't that always the case?
13:28:44 <Cale> Well... its goal was never to describe changes that haven't been implemented.
13:28:47 <blancolioni> but that's unlikely to affect existing programs
13:29:06 <Cale> So, it's sort of "boring" in that regard.
13:29:16 <Cale> blancolioni: Which one?
13:29:37 <blancolioni> cale: the one that makes else work as you'd expect in a monad
13:29:42 <Sekaino> Well my understanding from a long while back when I last looked at it was that small changes to the core language were being considered if someone had a working implementation somewhere and demonstrated it was better.  However, I can see backwards-compatibility winning out.
13:29:55 <Cale> blancolioni: oh, actually, I find that change confusing.
13:30:01 <blancolioni> cale: really?  how so?
13:30:20 <Cale> blancolioni: the 'else' is part of the 'if', so making it a separate statement in the do-block shouldn't work.
13:30:41 <Cale> If you always indent if/then/else correctly, it's not a problem.
13:31:06 <Cale> The 'then' and 'else' are part of the 'if', and siblings, so they should be indented the same, and more than the 'if' is.
13:32:35 <blancolioni> cale: I sort of agree, but on the other hand, it seems odd that a layout which "looks" right, and works in expressions, should suddenly fail in a do
13:33:43 <Cale> I would be more in favour of restricting the syntax of if in expressions further, I think :)
13:33:50 <blancolioni> :-)
13:34:06 <Cale> I also want to see tabs become a lexical error.
13:34:11 <blancolioni> maybe it was
13:34:14 <Cheshire> I would get rid of if
13:34:30 <blancolioni> agreed wholeheartedly with the tabs
13:34:50 <Cale> I don't think I'd go that far... if/then/else is common enough that it's nice to have special syntax for it.
13:35:10 <Cale> The 'then' and 'else' make reading code a bit nicer.
13:35:24 <blancolioni> the problem with the if is that it looks exactly like a well-known imperative construct, but actually isn't much like it at all
13:35:28 <mauke> then = id; else = id
13:36:09 <Saizan_> are there some cases where a path like "././dist/doc/html/Cabal/." is not the same as "dist/doc/html/Cabal/" ?
13:36:32 <Cale> Saizan_: I wouldn't think so...
13:36:40 <blancolioni> maybe it should be changed to a si-alors-autre expression, that wouldn't be confusing at all
13:37:41 <Saizan_> i wonder why normalise doesn't do that transformation then
13:37:42 <blancolioni> man, I remember a compiler book I once read which argued that having reserved keywords was convenient, because you could easily change them to other languages
13:38:15 <mauke> "GRUNNUR"
13:38:52 <Nafai> Do I have to do anything special to use Debug.Trace?
13:39:00 <Nafai> I'm not getting any output from it
13:39:05 <Sekaino> Another quick question: if I wanted to enable GeneralizedNewtypeDeriving by default in the source, what's the syntax? :)
13:39:11 <blancolioni> nafai: the expression is probably not being evaluated
13:39:18 <blancolioni> nafai: because of laziness
13:39:30 <rwbarton> Sekaino: {-# LANGUAGE GeneralizedNewtypeDeriving #-}
13:39:34 <rwbarton> at the top of your file
13:39:36 <Sekaino> rwbarton, thanks.
13:39:44 <Nafai> blancolioni: Hrm.
13:39:53 <blancolioni> rwbarton: any difference between that and OPTIONS_GHC?
13:40:41 <rwbarton> blancolioni: OPTIONS_GHC needs -XGeneralizedNewtypeDeriving, and it's not portable to other compilers that happen to also support the pragma
13:41:17 <BMeph> I agree with Cheshire. There arer a few "clever" bits to Haskell that are just a bit too clever for their own good. :\
13:41:35 <blancolioni> rwbarton: thanks -- I needed to add one of those just today, so I looked in the ghc users guide because I always forget how
13:41:46 <Cale> Though... it may be academic at this point, since I think hugs unfortunately lacks that extension...
13:42:04 <peaker> BMeph: any examples?
13:42:27 <Cale> I nominate GeneralizedNewtypeDeriving as the extension with the highest value/implementation difficulty ratio.
13:42:43 <Cheshire> deriving sucks...
13:42:50 <Sekaino> It does seem like a no-brainer to have it.
13:42:53 <mathijs> Hi all, I'm a bit new to haskell modules and stuff. I know about qualified and hiding. I would like to change/expand some functionality of HAppStack (HAppS fork). A module in there defines an instance of a class that I want to define differently. Of course I can hide the instance when I import and rewrite it, but I need my definition to be used in the other code as well. How can I do this?
13:43:03 <Cheshire> we should just take the best generic haskell thing out there and replace deriving with it
13:43:38 <BMeph> peaker: 'return'.
13:44:54 <BMeph> peaker: It should, in my opinion, have always been known as 'eta' or 'pure', but 'return' was deliberately provocative.
13:45:04 <ehird|away> Someone should put HOC on hackage.
13:45:25 <Cale> mathijs: It's unfortunate, but controlling which instances are imported and used is tricky. A better solution might be to either replace the existing instance by submitting a patch to HappStack, or else newtyping the datatype you want to write an instance for.
13:45:52 <Cheshire> I wonder how it would go if monad was defined in terms of Functor (m a) => eta and join
13:46:36 <Cheshire> (forall a. Functor (m a))
13:46:46 <Sekaino> Out of curiosity, has anyone suggested a patch that allows instances to be overridden more easily?  This workaround with newtype seems a bit like a cludge to me.
13:47:03 <Cheshire> oh that should just be m..
13:47:54 <Cale> Sekaino: There have been some proposals... but to do anything sane, you have to give the instances names, which starts to eat away at the purpose of typeclasses.
13:47:54 <blancolioni> Sekaino: tricky
13:47:55 <mathijs> Cale: hrm... coming from ruby, that's a big miss :(   So if I need some change something somewhere (that's not a bug to send a patch for, just something that in this -personal- case is better to do another way), I need to replace/copy everything that comes on top of it?
13:47:55 <peaker> BMeph: Ah, that kind of overly clever :)
13:47:59 <ehird> Huh...
13:48:00 <ehird> Warning: the following files would be used as linker inputs, but linking is not being done: HOC_cbits.o
13:48:00 <ehird> ghc: no input files
13:48:00 <ehird> Usage: For basic information, try the `--help' option.
13:48:00 <ehird> cabal: Error: some packages failed to install:
13:48:00 <ehird> HOC-1.0 failed during the building phase. The exception was:
13:48:06 <peaker> BMeph: I agree, I thought you meant eliminating features
13:48:11 <BMeph> Cale:Just curious, but have you heard of any project to introduce keywords to make a class open or closed?
13:48:45 <Cale> BMeph: There have been various informal proposals about that as well... there might also be a paper about open ADTs...
13:48:56 <peaker> mathijs: Just newtype and define whatever instance you want
13:48:57 <Cheshire> there is about open ADTs
13:49:00 <Cale> mathijs: newtyping usually isn't *so* bad.
13:49:00 <rwbarton> mathijs: what you're suggesting doesn't really make sense in the Haskell world, for example, the code which you want to use your instance may have already been compiled with the original instance inlined in.
13:49:06 <pmurias> mathijs: so you want to monkey-path typeclasses ? ;)
13:49:08 <blancolioni> Sekaino: I mean, if you're talking about replacing 'show' for a type, that's a whole program change
13:49:20 <Cale> mathijs: But I'll admit it could be a good deal better.
13:49:20 <pmurias> * monkey-patch
13:49:23 <peaker> Cale: I am not sure its unfortunate that instance imports are uncontrollable, just have to think of the instances as an inherent part of the type
13:49:27 <rwbarton> mathijs: moreover you're now relying on the implementation of that code rather than its semantics
13:49:33 <Cale> peaker: yes...
13:49:39 <BMeph> Cale: What, you mean official support for Swierstra's "A la Carte" tricks? :)
13:49:42 <Cale> mathijs: Which class is it, anyway?
13:49:53 <peaker> Cale: If you could control instance imports, I hate to think what people would do with that )
13:49:56 <peaker> :)
13:50:01 <Cale> BMeph: mm... not specifically related to monads.
13:50:13 <Cale> Or... no, I was thinking of something else there.
13:50:19 <Cale> Perhaps it is closely related.
13:50:24 <ddarius> My types are too big.
13:50:54 <BMeph> Cale: I thought that paper was dealing more with ADTs than monads. I'll read it again, then. :)
13:50:56 <ehird> Anyone used HOC?
13:51:14 <mathijs> Cale: in this case it's Text.XHtml. It's imported into SimpleHTTP, but I would like Text.XHtml.Strict to be used(they are swappable).
13:51:16 <Cale> BMeph: Yes, I mistook which paper you were talking about.
13:51:24 <Cale> BMeph: (at first)
13:51:47 <Sekaino> blancolioni, agreed.  It would just be nice to be able to "toggle" which instantiation of a class you want to be active if there are more than one way to do things sometimes. (i.e. showing a complex number as polar or cartesian by default).  However, I've notice that Haskell doesn't tend to make setting "defaults" simple.
13:52:04 <Cale> mathijs: Oh, that seems difficult.
13:52:16 <Cale> mathijs: It's unfortunate we don't have a fancier module system.
13:52:23 <blancolioni> hmmmm ... I'm trying to build yi
13:52:25 <blancolioni> build-depends: Cabal >= 1.6 && < 1.7
13:52:35 <blancolioni> [fraser@kimba yi]$ ghc-pkg list
13:52:35 <blancolioni> /usr/lib64/ghc-6.8.3/package.conf: Cabal-1.6.0.1, GLUT-2.1.1.2, HUnit-1.2.0.0, OpenAL-1.3.1.1,
13:52:43 <blancolioni> [fraser@kimba yi]$ ./Setup configure
13:52:45 <Cale> mathijs: (if we did, then SimpleHTTP could have taken the Text.Html module to use as a parameter)
13:52:48 <blancolioni> Setup: yi.cabal: This package requires Cabal version: >=1.6
13:52:54 <mathijs> Cale: the problem is that Text.XHtml and Text.XHtml.Strict are compatible and define the same stuff. I used Text.XHtml in my own code to build a document, but HAppStack gave it a XHTML Transitional header, since the instance for XHtml that it knows is 'wrong'
13:53:07 <blancolioni> is this more subtle than expected?
13:53:24 <peaker> Maybe I am too much of a conservative, but I am not sure enhancing the module system is that superior to just taking some function record as an argument, rather than using some specific module
13:53:33 <Cale> mathijs: Can you just change your code to use the same module?
13:53:38 <peaker> (And the current module system has great simplicity going for it)
13:53:52 <Heffalump> am I right that the ST monad transformer in stateful-mtl is unsafe?
13:54:00 <Cale> peaker: It's just troublesome when the records get really large, and when they include things like types and instances.
13:54:14 <lepassive> anyone is using xmonad and ubuntu ?
13:54:28 <ddarius> Heffalump: I'm not sure how it would make sense (but I haven't looked at it yet).  What would STT s Maybe be?
13:54:29 <blancolioni> Sekaino: the 'show' function is trapped between two competing and incompatible requirements, or at least expectations
13:54:34 <ddarius> lepassive: I am.
13:54:36 <Heffalump> ddarius: well, precisely
13:54:45 <Heffalump> it is implemented by importing GHC.ST, which I can't find any haddock for
13:54:52 <peaker> Cale: If you want different types in different cases, just need some type-classes or more function records :)
13:55:00 <Heffalump> rather than by actually using operations with "unsafe" in thename
13:55:27 <mathijs> Cale: well, for now I just changed the source code and it works. I can't really send a patch or anything, because nothing is broken in the first place. It's just a problem when 2 modules define the same stuff (are swappable). I mean in my code the type of the page is XHtml (which came from Strict), but since HAppS got its definitions from XHtml (nonstrict) it fails.
13:55:28 <lepassive> ddarius, I tried to ask in #xmonad but no one seems active now.. I installed XMonad using Synaptic when i start a XMonad session it just freezes!
13:55:31 <peaker> Cale: If you use (exists module. module.SomeType) -- how do you type-check SomeType?
13:55:41 <Cale> peaker: Large product types tend to be difficult to manage is all.
13:55:51 <mathijs> Cale: I changed the HAppS source, not mine... I'm not gonna change to transitional :)
13:56:03 <ehird> @hoogle throwDyn
13:56:04 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
13:56:04 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
13:56:20 <peaker> Cale: How do fancy module systems handle parameterized modules with different types in them?
13:56:23 <Cale> peaker: With a module signature...
13:56:35 <ddarius> lepassive: I've never installed xmonad using Synaptic and I have xmonad set as my window manager so I don't explicitly start a session.
13:56:35 <ehird> I'm getting HOC/Exception.hs:73:23: Not in scope: `throwDyn'
13:56:39 <ehird> not sure why
13:56:45 <ehird> it imports Control.Exception
13:57:16 <alatter> ehird: throwDyn is not in base4 Control.Exception
13:57:19 <ehird> ah!
13:57:20 <ehird> where is it?
13:57:31 <alatter> ehird: base3, or Control.OldException
13:57:33 <peaker> Cale: So if I want to use either XHtml or XHtml.Strict -- you'd have "SomeXHtml type variables here" that represents a specific module, with the specific types in it?
13:57:53 <ehird> alatter: what's its repplacement?
13:57:57 <lepassive> ddarius, then I shouldn't install it from synaptic ?
13:57:59 <alatter> peaker: you'd pass in types and functions on those types to the 'import' statement
13:58:03 <mathijs> Cale: I even think what's happening is wrong/unsafe. I mean the XHtml in my code, is different from XHtml in the HAppS module, but the compiler doesn't warn about it, it just takes my stuff and pretends it's from the other definition. Which works in this case, but seems dangerous somehow.
13:58:09 <Cale> peaker: Basically they treat the modules themselves as those big data structures you're referring to, and the things which are exported meet a given signature.
13:58:16 <alatter> ehird: extensible exceptions.  All exceptions are now sortof like the Dyn exception
13:58:19 <peaker> alatter: Then the module is a compile-time value you can pass as an argument to other modules or functions?
13:58:30 <rwbarton> Heffalump: yes, it is broken in the same way as STMonadTrnas
13:58:30 <Cale> mathijs: that sounds sort of impossible...
13:58:33 <peaker> Cale: ah
13:59:23 <peaker> mathijs: Symbols from different versions of the same library are considered different, afaik. If it works, its the same version, most probably
13:59:29 <ehird> HOC is irritatingly unmaintained.
13:59:35 <Cale> peaker: So then you can have modules which are defined in terms of another module which is required to contain certain definitions.
13:59:50 <alatter> ehird: but you should just be able to build it against base3
13:59:54 <Cale> (like functions on the module level)
13:59:58 <Heffalump> I wish people wouldn't write packages like that. It's asking for trouble.
14:00:02 <ehird> it works now, except ../inplace.conf: openBinaryFile: does not exist (No such file or directory)
14:00:17 <peaker> Cale: I see. It sounds like nice syntactic sugar, probably implementable with TH?
14:00:17 <ehird> when it does 		-package-conf ../inplace.conf
14:00:17 <ddarius> lepassive: If there's a synaptic package for it, it should work.  Check the manual/website to see if there are any particulars to setting it up.
14:00:45 <rwbarton> Heffalump: what's odd is it's written by someone who's not either of the two people involved in the recent STT thread
14:00:45 <Cale> peaker: I imagine that would be quite involved.
14:00:51 <Cale> peaker: But maybe.
14:00:57 <rwbarton> Everyone is writing broken STTs these days it seems
14:01:00 <mathijs> peaker: what i mean is that in my code, where I imported Strict, I built up a document which type is XHtml. I gave this to a function in HAppS (which has its definition of XHtml from the non-strict variant), which happily works with it without telling me it's a different thing.
14:01:03 <lepassive> ddarius, okay thanks alot and sorry for disturbance
14:01:23 <Cale> mathijs: Perhaps both of them get their datatypes from the same module.
14:01:28 <Heffalump> rwbarton: well, the first one has been around for a year
14:01:51 <alatter> peaker: You'd have trouble, because the new import would have to be unrolled to data-type definitions, which then wouldn't type-check against equivalent definitions unrolled to a different location.  At least, that's the first problem I can think of.
14:01:58 <pmurias> how should i sort a list?
14:02:04 <Cale> mathijs: I'm betting that it's the same XHtml datatype which both libraries use.
14:02:09 <Cale> pmurias: Data.List.sort
14:02:16 <Cale> > sort [5,2,7,2,5,8,1]
14:02:18 <lambdabot>   [1,2,2,5,5,7,8]
14:02:20 <sbahra> > sort [10 .. 1]
14:02:22 <lambdabot>   []
14:02:24 <ehird> *sigh
14:02:28 <mathijs> Cale: that's quite possible, didn't investigate. But what if they both defined the datatype in exactly the same way (copy paste)? Would I get a warning then?
14:02:29 <Jarvellis> Is there a generally aproved of haskell tutorial for not very skilled programers?
14:02:29 <ehird> This is nigh-on impossible.
14:02:29 <sbahra> > sort [10,9 .. 1]
14:02:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:02:34 <ddarius> Why are people writing STTs at all?
14:02:38 <Cale> mathijs: You'd get an error.
14:02:47 <peaker> alatter: I see.  Sounds like the main use of parameterized modules in Haskell would be Strict vs Lazy modules?
14:03:11 <mathijs> Cale: Even if they are carbon copies? in that case I feel safe again :)
14:03:27 <Cale> mathijs: yes, even if they're carbon copies :)
14:03:35 <alatter> peaker: or for dropping in a different container type with different run-time performance
14:04:16 <ehird> Anyone here at all used/compiled with HOC?
14:04:16 <alatter> peaker: but I guess typeclasses are okay for that ...
14:04:58 <dsrogers> haddock is telling me "haddock: parse error in doc string" but not telling me WHERE.
14:05:04 <peaker> alatter: A big module signature would contain all of the expected exported types, right?
14:05:12 <dsrogers> how do I get haddock to tell me where the problem is?
14:05:13 <Nafai> Yay, sent my first e-mail to -cafe
14:05:39 <mathijs> Cale: cool.  I guess I just need to let go my monkey-patching behaviors. newtyping my way around it will work, but feels ugly. I guess trading monkey-patching for some other ugly workaround is just the way it is for now :)
14:06:20 * dsrogers kills haddock
14:06:24 * dsrogers kills haddock dead
14:06:42 * idnar kills haddock in a fire, just to make sure
14:06:59 <Nafai> Hopefully people will respond well to my post :)
14:07:20 <dsrogers> no one knows how to get around this, huh?
14:07:22 <ehird> Warning: the following files would be used as linker inputs, but linking is not being done:
14:07:25 <ehird> not sure what that means.
14:07:33 <ferret_0567> how do you convert an Integer to a [Char] (or String)?
14:07:43 <comex> show
14:07:44 <Olathe> > show 5
14:07:46 <lambdabot>   "5"
14:07:52 <ferret_0567> ok, thanks
14:07:52 <blancolioni> ehird: ghc didn't recognise the extension, so it assumes it's something for the linker
14:08:08 <Cale> show is generally how you turn things into strings
14:08:10 <Cale> > show [1,2,3]
14:08:12 <lambdabot>   "[1,2,3]"
14:08:26 <Cale> > show (Just (1,[2,3],"hello"))
14:08:28 <lambdabot>   "Just (1,[2,3],\"hello\")"
14:08:41 <blancolioni> ehird: but the poor thing is confused, because it hasn't been asked to link
14:09:06 <blancolioni> *file* extension I mean
14:09:19 <ehird> blancolioni: it's just "c-sources: HOC_cbits.o"
14:09:46 <pumpkin> > [1,2,3] :: [Num a => a]
14:09:47 <lambdabot>       Overlapping instances for Show ((Num a) => a)
14:09:48 <lambdabot>        arising from a use...
14:09:51 <pumpkin> boo
14:09:53 <blancolioni> ehird: right, so HOC_cbits.o is a file that's only required for the link stage
14:10:00 <Cale> dsrogers: hmm...
14:10:16 <ehird> blancolioni: but then immediately after, "ghc: no input files"
14:10:45 <blancolioni> ehird: how are you running ghc?
14:10:51 <ferret_0567> what is the equivalent to argv[1] in Haskell?
14:10:58 <ehird> blancolioni: "Setup.hs build"
14:11:04 <blancolioni> ferret: args <- getArgs
14:11:10 <dons>  [f] <- getArgs
14:11:24 <dons> import System.Environment
14:11:34 <blancolioni> ehird: which package?
14:11:39 <ehird> blancolioni: HOC.
14:11:52 <blancolioni> (sorry, I have no idea how to scroll back on this thing)
14:11:55 <pumpkin> is the fact that ghc won't compile huge source files considered a bug?
14:12:10 <pumpkin> or just an indication that you should split up your code a bit
14:12:15 <Deewiant> both? :-P
14:12:23 <pumpkin> I was looking for it in the ghc trac
14:12:55 <pumpkin> but everyone seems to acknowledge it, so I was wondering if it was accepted or maybe already fixed in head
14:14:01 <chessguy_> wow, dons  putting down a smack-down on the mailing list
14:14:22 <pumpkin> yeah, I was just going to comment :)
14:14:30 <blancolioni> ehird: it looks like a packaging problem, but I couldn't really say.  are you using the cvs version?
14:14:33 <pumpkin> he sounds harsher than usual :) but then again it's coppin
14:14:37 <Cheshire> @go Compiling Polymorphism Using Intensional Type Analysis
14:14:41 <lambdabot> http://citeseer.ist.psu.edu/harper95compiling.html
14:14:43 <ehird> blancolioni: The SVN version from the new google code project
14:14:51 <monochrom> Oh, coppin, hahaha. About time.
14:15:31 <monochrom> Perhaps I should not have unsubscribed. Sounds like there is great entertainment value.
14:15:33 <blancolioni> I imagine somebody did a bad commit, but it's not a package I've tried before
14:15:36 <chessguy_> pumpkin: i usually find Coppin's discussions interesting
14:15:43 <pumpkin> really?
14:15:49 <pumpkin> some of them make me want to strangle him
14:15:53 <pumpkin> others merely make me curious
14:16:00 <chessguy_> at the least,  he's a regular, and shouldn't be accused of being a troll
14:16:26 <Sekaino> Another quick question:  Is there any way to specify multiple types as instances of some class all with the same implementation?
14:16:31 <pumpkin> he seems like a bit of a regular semitroll
14:16:50 <monochrom> Coppin brings up interesting subjects but he approaches those subjects in a confrontational and narrow-minded way.
14:16:51 <pumpkin> he confuses me
14:17:15 <dons> oh, sorry guys.
14:17:16 <blancolioni> has it really been three years?
14:17:18 <chessguy> strange, coppin is one of the few names i recognize on the list, and i recognize it because i like his emails
14:17:19 <dons> more tired than anything.
14:17:32 <chessguy> dons:  not a good time to be writing emails then
14:17:33 <dons> the request was broken in so many ways
14:17:38 <ferret_0567> dons: I can't seem to make a new list with the arguments in main...how do I do that?
14:17:41 * dons drinks some more coffee
14:17:52 <chessguy> dons:  there's nothing wrong with pointing out how the request was broken
14:17:55 <blancolioni> dons: well, you investigated the request probably more than it deserved ..
14:18:04 <chessguy> blancolioni:  agreed
14:18:09 <pumpkin> dons: oh no need to apologize, I'd be tempted to respond in similar ways sometimes, but as a complete stranger to most poeple on that list, I don't think it would look good
14:18:24 <Nafai> dons: Finally got around to mailing -cafe about my problem!
14:18:27 <chessguy> the content of dons' email was brilliant, as usual
14:18:39 <jeffz`> dons++
14:18:40 <chessguy> the tone of it was just awfully cynical
14:18:41 <dons> well, hmm. i wouldn't say that. it was more obvious
14:18:50 <ehird> hrmph. I wonder how anyone uses HOC.
14:18:51 <dons> just try to compile the programs. see what's wrong
14:18:57 <rwbarton> dons: I'm not sure you need more coffee after writing a 222-line email in 42 minutes :)
14:18:58 <ferret_0567> main = [f] <- getArgs putStrLn (show args)
14:19:00 <dons> make the usual assumptions of : forgetting -O , using ghci etc
14:19:06 <monochrom> "wtf is higher-rank polymorphism? I cannot think of a use. therefore it's just ivory tower stuff."  This was a classical example.  "wtf is higher-rank polymorphism" is an interesting subject.  His opinion on it is outrageous.
14:19:18 <ferret_0567> I tried that, with the newline between getArgs and putStrLn
14:19:20 <chessguy> dons:  yes, but, as mentioned, you gave the request far more analysis than it deserved
14:19:22 <ferret_0567> it does not work
14:19:27 <blancolioni> dons: sure, but these are all things he  should have done
14:19:27 <dons> ferret_0567: oh, all on one line? use a ;
14:19:39 <ferret_0567> dons: no, I have it split on two lines
14:19:45 <rwbarton> ferret_0567: can you be more specific than "it does not work"?
14:19:50 <dons> yes, guys. sometimes hitting a soft ball on sunday morning is fun :)
14:19:56 <rwbarton> ferret_0567: wait, what's args?
14:20:16 <chessguy> monochrom:  but i think you'll find that he won't argue for that opinion. i suspect it's more of a devil's advocate thing
14:20:18 <ferret_0567> rwbarton: the arguments to the program
14:20:18 <dons> i have to be careful not to sound mean. yell if i do that.
14:20:28 <rwbarton> ferret_0567: why do you think that?
14:20:35 <chessguy> dons:  you definitely did sound mean this time
14:20:37 <rwbarton> ferret_0567: do you mean f?
14:20:39 <chessguy> to me anyway
14:20:44 <pumpkin> the three years thing sounded mean
14:20:55 <dons> import System.Environment
14:21:00 <dons> main = do args <- getArgs; print (reverse args)
14:21:03 <Cheshire> what are you guys talking about?
14:21:06 <ferret_0567> rwbarton: yeah, however, I changed f to args and...it still doesn't work. GHC gives:
14:21:09 <ferret_0567> squareX.hs:4:14: parse error on input `<-'
14:21:11 <pumpkin> Cheshire: coppin's latest email on cafe
14:21:17 <dons> i wonder if you're using tabs, ferret_0567 ?
14:21:21 <blancolioni> but come on, three years and the exact same sort of thing over and over again
14:21:24 <ferret_0567> dons: I am not using tabs
14:21:32 <dons> ?paste
14:21:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:21:38 <blancolioni> it doesn't hurt to point that out, does it?
14:21:40 <chessguy> blancolioni:  i'll be the first to raise my hand and say i've got a very thick skull :)
14:21:45 <ferret_0567> oh, I didn't know that you have to use do
14:21:46 <monochrom> chessguy: IMO he should just uninstall his opinion-generator in his brain.
14:22:06 <pumpkin> blancolioni: I can definitely see why he'd be frustrated :P I've only been doing haskell for a couple of months and am already somewhat frustrated with some of his emails
14:22:07 <dons> i really wanted to find the physics crank test
14:22:10 <Deewiant> You should bash your head against the wall more often; it helps thin your skull
14:22:11 <dons> its somewhere on the internet
14:22:16 <dons> about how to rate a post for 'crankhood'
14:22:16 <hydrapheetz> :t ($!)
14:22:18 <lambdabot> forall a b. (a -> b) -> a -> b
14:22:22 <monochrom> Whether one argues for one's outrageous opinion or not, saying it out just once is one time too many.
14:22:23 <hydrapheetz> hum
14:22:25 <chessguy> blancolioni:  i've asked plenty of downright stupid questions in my own 3 years of learning haskell, mostly in this channel, but i'd like to think i've learned a lot in the process.
14:22:26 <ehird> blancolioni: Think I found the problem
14:22:27 <ehird> options = [(GHC,["dist/build/HOC_cbits.o","-lobjc","-lffi","-framework Foundation"])], ghcProfOptions = [], ghcSharedOptions = [], customFieldsBI = []}})
14:22:34 <ehird> It's the only file there, but we're not linking, so it's ignored
14:22:39 <ehird> and thus we're not compiling anything
14:22:46 <ehird> clearly, it should be linking...
14:22:55 <Cheshire> it says "If you want to do a normalization proof for simply typed lambda calculus ala Tait,Girard,..."
14:22:56 <Deewiant> :t ap seq
14:22:56 <rwbarton> dons: this one? http://math.ucr.edu/home/baez/crackpot.html
14:22:57 <lambdabot> forall a a1. (a -> a1) -> a -> a1
14:23:01 <pumpkin> chessguy: I don't think stupid/uninformed questions are a problem, it's mostly being opinionated and making (possibly implied) inflammatory statements
14:23:05 <Cheshire> deos anyone know if these proofs are actually online somewhere?
14:23:26 <blancolioni> I think stupid questions are fine, but there's a way of asking you know
14:24:16 <blancolioni> ehird: yeah, you might need a --make or something?
14:24:20 <chessguy> i learn best by challenging what i don't understand
14:24:24 <blancolioni> it's an odd line
14:24:28 * chessguy shrugs
14:24:35 <dons> rwbarton++ yes!
14:24:39 <pumpkin> chessguy: things like "is it possible to make money using haskell??? does anyone actually do it?" is a question, but the tone bothers me
14:24:41 <dons> thanks, s/crank/crackpot/
14:24:43 <chessguy> if i don't understand something, i tend to disbelieve it
14:24:50 <ehird> blancolioni: doesn't work
14:25:14 <chessguy> pumpkin:  strange. i don't detect a bad tone at all in that one.
14:25:20 <chessguy> maybe just me
14:25:24 <pumpkin> he has a wink at the end of his email
14:25:32 <pumpkin> there seems to be a strong implied message to me
14:25:38 <pumpkin> but maybe it's just the limitations of the text medium :)
14:25:39 <monochrom> is it possible to learn haskell? has anyone actually done it?  <duck>
14:25:43 <Sekaino> Nobody?
14:25:49 <rwbarton> monochrom: no
14:25:51 <Sekaino> (Regarding:) Another quick question:  Is there any way to specify multiple types as instances of some class all with the same implementation?
14:26:24 <blancolioni> monochrom: without a .net target there's absolutely no point in learning it
14:26:31 <ferret_0567> how do I convert a String to an Integer?
14:26:33 <monochrom> I think you have to repeat the implementation as many times as the number of instances.
14:26:35 <ferret_0567> I have it almost working
14:26:39 <Deewiant> ferret_0567: read
14:26:40 <ddarius> chessguy: If he just arrived at the mailinglists maybe, I'd agree, but after > 2 years I'm sure he could have found the "Jobs" link on Haskell.org or noticed all the emails about CUFP or know things he's been told before.
14:26:42 <ferret_0567> I am very close now
14:26:46 <blancolioni> > read "123"
14:26:48 <Deewiant> > read "1234" :: Int
14:26:48 <lambdabot>   * Exception: Prelude.read: no parse
14:26:49 <lambdabot>   1234
14:26:54 <blancolioni> whoops
14:26:57 <ehird> I just can't figure out why ghc seems to think linking isn't being done
14:26:59 <blancolioni> I am such a newbie
14:27:11 <chessguy> ddarius:  i suppose that's fair
14:27:12 <ferret_0567> blancolioni: me too
14:27:20 <Sekaino> monochrom, that's what I just did, but I was curious if there was a shortcut that wasn't so tedious.
14:27:33 <wli> instance rules
14:27:35 <ferret_0567> instead of making a boring add function, I decided to try and make this
14:27:36 <blancolioni> ehird: does the 0.7 release compile?
14:27:44 <ehird> It isn't cabalised, blancolioni
14:27:49 <wli> instance ClassA t => ClassB t where ...
14:27:52 <rwbarton> Sekaino: You might find it helpful to write a top-level version of each class function that works on all your types, and then use them in each instance
14:27:53 <Deewiant> Sekaino: template haskell, the C preprocessor
14:28:21 <ferret_0567> IT WORKS!
14:28:24 <chessguy> ddarius but then maybe his question wasn't meant to garner information, but to foster discussion
14:28:38 <Sekaino> rwbarton, no major worries since the implementations were all one-liners.  It's just a lot of boiler-plate for no semantic gain.
14:28:38 <Cheshire> closest I get is www.mpi-sws.org/~dreyer/tor/papers/gallier.pdf
14:28:48 <ddarius> chessguy: That's a nice way of saying "troll" I guess.
14:28:49 <blancolioni> ferret: careful, Haskell is addictive
14:28:55 <monochrom> hahahaha
14:28:57 <chessguy> bah
14:28:59 <ferret_0567> blancolioni: it sure is
14:29:08 <chessguy> it's not a troll if it's on-topic and it's not malicious
14:29:12 <Sekaino> Deewiant, good thought, but overkill for this instance. (har har)
14:29:33 <monochrom> is "troll" defined by action or by intention?
14:29:36 <Deewiant> Sekaino: yeah, that makes sense only if you've got dozens of types
14:29:42 <chessguy> both
14:29:45 <mauke> I accidentally the whole mailing list
14:29:47 <ferret_0567> !paste
14:29:50 <mathijs> :info Troll
14:29:52 <mathijs> :P
14:29:56 <dons> mauke: mwahaha
14:30:14 <ferret_0567> what is the URL for hpaste?
14:30:27 <blancolioni> wait, what does lambdabot default to in 'read "123"' ?
14:30:32 <davidL> @where hpaste2
14:30:32 <Deewiant> blancolioni: ()
14:30:33 <lambdabot> http://hpaste.org/
14:30:35 <Deewiant> > read "()"
14:30:37 <lambdabot>   ()
14:30:40 <blancolioni> oh, fair enogh
14:30:41 <ddarius> chessguy: I'm not saying he is a troll, but he's clearly not emailing the list for the list's benefit nor apparently for his benefit either since he hasn't seemed to have gotten anywhere in the last three years.
14:30:41 <blancolioni> enough
14:31:21 <ddarius> chessguy: We have an entire conference about people making money with Haskell (and other FP languages), I don't think we need Andrew's help "garnering discussion" on at least that topic.
14:31:39 <monochrom> If Coppin doesn't intend to troll, his presentation of his trollish and confrontational persona  (and after all these years learning the norms of this community!) certainly proves him stupid.
14:32:16 <monochrom> Yes, I'm going for the "not malicious, just stupid" thing.
14:32:18 <Cheshire> he's probably like 8 or something and smart for his age
14:32:20 <pumpkin> he's weird, because he seems to like haskell, but he also seems to enjoy pissing people off
14:32:36 <ferret_0567> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1427#a1427
14:32:38 <ddarius> Cheshire: And thus a liar or an 8 year sys admin?
14:32:53 <ddarius> monochrom: That's mostly how I lean.
14:33:01 * wli gets nowhere with speeding up the addition chain code.
14:33:03 <ddarius> s/8 year/8 year old/
14:33:07 <ferret_0567> blancolioni, dons: check it out! ^^^
14:33:20 * wli also gets nowhere with the arbitrary-precision floating point code.
14:33:39 <blancolioni> ferret: sweet
14:33:54 <pumpkin> wli: you trying to make a faster CReal? that would be nice
14:34:09 * wli may not have goten anywhere for the past several (10?) years but is not trying to piss anyone off.
14:34:39 <ddarius> wli: Didn't you learn monads in the last year or so?
14:34:54 <ddarius> Oh, for the float code.
14:34:58 <wli> pumpkin: I don't think I am. I'm just trying to squeeze more digits out of not-very-well-conditioned operation.
14:35:15 <pumpkin> ah
14:35:33 <ferret_0567> well, now that that works, I can go back to the book!
14:35:35 <wli> ddarius: I would say ca. 2 years ago as 1997 is/was the 10-year mark.
14:36:43 * wli mostly remembers determining that it was 10 years after initially learning Haskell to grok monads.
14:36:55 <blancolioni> I think I read my first Haskell standards draft in 1991, which means that my Haskell knowledge can now have a beer if it doesn't travel to the US
14:36:59 <rwbarton> @seen mmorrow
14:37:00 <lambdabot> I saw mmorrow leaving #ghc and #haskell 6h 29m 5s ago, and .
14:37:05 <gueux> I'm trying to use a multiple parameters class
14:37:09 <Deewiant> blancolioni: :-D
14:37:14 <monochrom> hahahaha
14:37:34 <gueux> can I just insert something at the beginning of my file to enable it?
14:37:42 <ehird> aha
14:37:42 <ehird> http://code.google.com/p/hoc/source/detail?r=379
14:37:51 <rwbarton> @ask mmorrow is it possible/easy to have http://hpaste.org/new redirect to http://hpaste.org/fastcgi/hpaste.fcgi/new?  Finger memory, you know
14:37:52 <lambdabot> Consider it noted.
14:37:53 <Cheshire> what a strange article
14:37:54 <Cheshire> http://en.wikipedia.org/wiki/Generic_programming
14:37:57 <Deewiant> gueux: {-# LANGUAGE MultiParamTypeClasses #-}
14:38:22 <gueux> Deewiant: thanks :-)
14:38:25 <blancolioni> ehird: nice one
14:38:43 <ehird> I think the thing I'm coming away with is "HOC is awful unmaintained hack; invent own obj-c bridge pronto"
14:38:59 <Deewiant> gueux: GHC often knows to tell you to pass -XSomethingOrOther to it to make something work; you can replace that with {-# LANGUAGE SomethingOrOther #-} in the file
14:39:24 <idnar> WARNING: Unmaintained hack detected, initiating reimplementation at Level Seven priority.
14:39:29 <wli> If I'm so dumb it took me 10 years to grok monads, I'm not likely to get anywhere before anyone else on anything else anyway.
14:39:35 <dons> actually , i was wrong, he's been on the lists asking the same questions for 2 years, not 3. http://article.gmane.org/gmane.comp.lang.haskell.cafe/21757/
14:39:39 <ehird> idnar: Yes, exactly!
14:39:46 <ehird> HOC is way too complicated.
14:39:50 <gueux> Deewiant: ok
14:39:58 <peaker> Is Luke Palmer here sometimes?
14:40:00 <ehird> Need less code, less bitrot, mmph... need more hours in the day...
14:40:00 <idnar> ehird: the name even sounds like "hack" ;)
14:40:10 <ddarius> peaker: Yes.
14:40:16 <ehird> idnar: it's huck and hack. huck is the sound cats make when coughing up a furball.
14:40:17 <ehird> no good, no good.
14:40:20 <rovar> chessguy, is GPLip usable and fetchable someplace?
14:40:24 <blancolioni> dons: actually, that's almost literally the same question
14:40:28 <rwbarton> @seen luqui
14:40:28 <lambdabot> I saw luqui leaving #haskell 12h 14m 35s ago, and .
14:40:35 <chessguy> rovar:  nah
14:40:37 <blancolioni> same style too
14:40:39 <idnar> ehird: hee hee
14:40:45 <rovar> damn
14:41:06 <chessguy> rovar:  there is a GP library on hackage though
14:41:13 <rovar> orly?
14:41:15 <ferret_0567> rwbarton: why does lambdabot say and ."
14:41:21 <ferret_0567> "and ."*
14:41:35 <rwbarton> ferret_0567: I have no idea.
14:41:54 <rovar> hgalib?
14:41:55 <vincenz> dons: he's like the gavino of haskell
14:42:18 <monochrom> hmm, gavino?  /me googles
14:42:27 * ddarius should probably eat today.
14:42:30 <ehird> Bloody hell. hoc-ifgen is broken.
14:42:42 <ehird> Killmekillmekillmekillme.
14:42:57 <monochrom> probably google doesn't help unless there are more keywords.
14:43:58 <ehird> OhthankgodIthinkit'sworkingnow
14:44:07 <blancolioni> ehird: lol
14:44:15 <ehird> I think I'll sue whoever wrote HOC
14:44:23 <pejo> monochrom, how about "gavino troll"?
14:44:41 <ehird> Setup.hs: At least the following dependencies are missing:
14:44:41 <ehird> HOC -any
14:44:43 <ehird> Erm, no.
14:45:02 <pumpkin> ehird: still struggling with it? :/
14:45:07 <Cheshire> is it really healthy to victimize people like this...
14:45:13 <ehird> pumpkin: I've installed HOC, but cabal thinks I haven't.
14:45:22 <pumpkin> ah weird
14:45:25 <ehird> Yet:
14:45:25 <ehird> % ghc-pkg list|grep HOC
14:45:25 <ehird>     Cabal-1.6.0.1, Diff-0.1.2, HOC-1.0, HTTP-3001.1.3, binary-0.4.4,
14:45:32 <ehird> ... oh wait.
14:45:34 <monochrom> I see, gavino trolls the lisp community.
14:45:38 <pumpkin> weird
14:45:55 <ehird> % bash make-bindings-macos.sh --user
14:45:58 <ehird> That worked
14:46:05 <ehird> Loading package HOC-1.0 ... linking ... ghc: unable to load package `HOC-1.0' ... you're kidding me
14:46:11 <pumpkin> lol
14:46:27 <Cheshire> monochrom, when I ran a lisp channel on this network gavino did not troll it, we just chatted about logic programming and he taught me some tricks in bash
14:46:33 <ehird> Braaaiiiins.... braaaiiiiiiinssss...
14:46:43 * ehird limps around
14:46:54 <pumpkin> ehird: are you holding your arms out in front of you?
14:46:58 <ehird> Yes.
14:47:02 <ehird> I mean, Braaains.
14:47:28 <ehird> ghc:
14:47:29 <ehird> unknown symbol `_autoreleaseObject'
14:47:30 <shapr> yow
14:47:30 <ehird> Oh what the heck.
14:47:31 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:47:39 <pumpkin> yow back at you!
14:47:39 <idnar> @yow
14:47:40 <lambdabot> Yow!  I threw up on my window!
14:47:47 <idnar> yow indeed
14:47:52 <Cheshire> yow shapr
14:48:04 <redditbot> Crackpot index
14:48:05 <blancolioni> ehird: objc library not being linked in?
14:48:18 <ehird> blancolioni: It's loading HOC
14:48:25 <Cheshire> @hackage BNFC
14:48:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BNFC
14:48:28 <ehird> The full block:
14:48:29 <ehird> Loading package template-haskell ... linking ... done.
14:48:29 <ehird> ghc:
14:48:29 <ehird> unknown symbol `_autoreleaseObject'
14:48:29 <ehird> Loading package HOC-1.0 ... linking ... ghc: unable to load package `HOC-1.0'
14:48:41 <blancolioni> ehird: the C bit though
14:48:49 <blancolioni> or should that have happened automatically?
14:48:51 <ehird> Well, all the previous bindings work.
14:50:00 <ehird> ah, wait
14:50:03 <ehird> that is on the first compilation, yes
14:50:25 <ehird> hmm it is my official opinion that HOC makes no damn sense whatsoever.
14:50:28 <blancolioni> _autoreleaseObject sounds like something in the basic objc library
14:50:33 <ehird> right
14:50:39 <ehird> ahh wait
14:50:58 <blancolioni> so there must be a -lobjc or something needed
14:51:00 <ehird> how can you make GHC link with an object file in a .cabal file?
14:51:08 <pumpkin> iut's not in libobjc
14:51:13 <pumpkin> not in mine at least
14:51:20 <ehird> i mean, the Proper Way(TM)
14:51:54 <blancolioni> ghc-options ?  but there's probably something More Proper
14:52:17 <BMeph> dons: ping
14:52:39 <ehird> extra-libraries: token list
14:52:39 <ehird> A list of extra libraries to link with.
14:53:00 * ehird crosses fingers
14:53:07 <ehird> Nope.
14:53:13 <pumpkin> what were you trying?
14:53:34 <ehird>     extra-libraries: objc, ffi, HOC_cbits.o
14:53:40 <ehird> pumpkin: where's your autoreleaseObject?
14:53:47 <pumpkin> I don't have one
14:53:51 <pumpkin> it's not in libobjc for me
14:53:53 <ehird> aha,
14:53:53 <ehird> HOC_cbits/MemoryManagement.h:void autoreleaseObject(id obj);
14:53:58 <ehird> so it's a problem with cbits linking
14:54:03 <pumpkin> ah
14:54:20 <ehird> I'm trying     ld-options: HOC_cbits.o
14:54:23 <pejo> ehird, is this the hoc-package itself you're trying to build, or trying to use it?
14:54:30 <ehird> pejo: I'm trying to build HOC
14:54:47 <ehird> Okay let's try this
14:54:54 <ehird> Argh. Same issue.
14:55:01 <pejo> ehird, through runhaskell Setup .. etc?
14:55:09 <ehird> yes, along with hacking the cabal file.
14:55:26 <ehird> ... *lightbulb*
14:55:38 <pumpkin> :o
14:55:52 <dons> BMeph:
14:55:56 <ehird> hm.
14:56:54 <ehird> y'da thought this'd be simple
14:57:02 <ehird> just linking with another object file
14:57:04 <dsrogers> how do I resolve conflicts in darcs?
14:57:06 <Cheshire> does anyone know how to fix this?
14:57:07 <Cheshire> % ls ~/.cabal/bin
14:57:07 <Cheshire> alex	happy
14:57:14 <Cheshire> but cabal says:
14:57:15 <Cheshire> cabal: The program alex is required but it could not be found
14:57:22 <Cheshire> when I try to compile a program
14:57:24 <pumpkin> does ghc-pkg say it's installed?
14:57:25 <Deewiant> Cheshire: it needs to be in your PATH
14:57:37 <dsrogers> sorry, wrong channel
14:57:43 <Cheshire> I tried to do: export PATH=~/.cabal/bin/:$PATH
14:57:48 <Cheshire> but still cabal says that
14:57:49 <ehird> aha, I think I got it. possibly!
14:57:54 <Deewiant> Cheshire: $HOME, not ~, might help
14:58:09 <Cheshire> oh I have
14:58:10 <Cheshire> export PATH=$PATH:$HOME/.cabal/bin
14:58:17 <Cheshire> in .profil
14:58:19 <Cheshire> in .profile
14:58:22 <ehird> ... or not
14:58:29 <Deewiant> And you've reloaded your .profile?
14:58:39 <Deewiant> Cheshire: if 'which alex' says it can be found cabal should find it
14:58:44 <Cheshire> no it was there already
14:58:49 <Deewiant> If not, your question belongs in ##bash or somewhere :-)
14:58:52 <ehird> #cabal
14:58:53 <ehird> oops
14:59:01 <Cheshire> well I'm actually trying to figure out how to get cabal to compile something
14:59:06 <ehird> where's the cabal channel?
14:59:09 <Cheshire> I don't really care about this PATH stuff
14:59:24 <Deewiant> Cheshire: it wants a program in your PATH and evidently it isn't in your PATH.
14:59:46 <kryptiskt> try echo $PATH
15:00:05 <ferret_0567> what is good style for ifs?
15:00:14 <Deewiant> if x
15:00:15 <Deewiant>   then y
15:00:17 <Deewiant>    else z
15:00:19 <Deewiant> oops
15:00:22 <Deewiant> one less space on the else
15:01:00 <ferret_0567> a Real World Haskell book comment says: Using end-line indentation (ie. lining up then and else with if) is bad style according to the book Code Complete (2nd edition - Chapter 31).
15:01:22 <mornfall> Hm. Ideas why a Haskell program would be dying of SIGBUS?
15:02:04 <ehird> bleh
15:02:36 * mornfall valgrinds...
15:02:38 <pumpkin> mornfall: are you doing anything unsafe?
15:02:46 <mornfall> pumpkin: Well, IO. :)
15:02:56 <pumpkin> that should generally be safe
15:02:57 <ehird> nobody know anything about linking arbitrary .o files with cabal?
15:03:03 <mornfall> It seems to be writing a file.
15:03:32 <rovar> anyone had any luck running Graphics.Rendering.Cairo on ubuntu?
15:03:40 <alatter> ehird: It looks like te commit-log for the HOC svn repo in google-code has recent commits.  maybe you could email them to see how they build it?
15:03:47 <mornfall> It dies just after ftruncate.
15:03:48 <mornfall> Hm.
15:03:54 <ehird> alatter: There's relevant commits -  I think they're not on GHC 6.10 yet
15:04:07 <rovar> it says  it has a dependency: cairo >=0.9.13
15:04:16 <alatter> ehird: ah.
15:04:22 <rovar> i've got the cairo2 libs/headers, but anything prior isn't supported.
15:04:49 <ehird> alatter: basically, in the cabal they have "    c-sources: HOC_cbits.o". this convinced ghc to link with HOC_cbits.o, but it's now calling ghc with just that and no other files for some reason at one point, and you get "Warning: the following files would be used as linker inputs, but linking is not being done: HOC_cbits.o" then a "no input files" error
15:04:58 <ehird> so I need to figure out how to convince ghc to link with HOC_cbits.o.
15:05:14 <Cheshire> why do you have to change
15:05:23 <Cheshire> import System.Console.Readline
15:05:23 <Cheshire> into
15:05:29 <Cheshire> import System.Console.Editline.Readline
15:05:30 <Cheshire> ?
15:05:58 <Cheshire> would it not be better if the code worked /without/ changing it?
15:06:10 <mathijs> how can I change ghci in 6.10.1 back to using readline? editline sucks
15:06:12 <Botje> Cheshire: libreadline is GPL, libeditline is BSD or somesuch
15:06:26 <alatter> ehird:  yup.  I think that cabal supports passing arbitrary linker flags
15:06:30 <Lemmih> ehird: Change it to HOC_cbits.c?
15:06:30 <Cheshire> I don't see why  import System.Console.Readline  can't import the editline implementation of readline
15:06:43 <ehird> Lemmih: It's not c, and it can't be compiled like that. It's Objective-C.
15:06:45 <alatter> Lemmih: the ./configure script does the compiling up front
15:06:48 <ehird> it has to be the object file
15:07:05 <ehird> alatter: it does, but ld-flags: HOC_cbits.o doesn't work...
15:07:07 <Deewiant> ?users
15:07:07 <lambdabot> Maximum users seen in #haskell: 666, currently: 640 (96.1%), active: 34 (5.3%)
15:07:10 <alatter> ehird: so you could pass the object in and pretend it's a flag
15:07:15 <ehird> I tried that
15:07:19 <alatter> ehird: ah, dang
15:07:29 <pumpkin> oh no, the devil is in our user count
15:07:45 <ddarius> pumpkin: That count is inaccurate anyway.
15:07:47 <alatter> pumpkin: you'd better fetch 27 people, quick
15:07:51 <pumpkin> I know :)
15:07:56 <pumpkin> we were up to 699 just the other day
15:08:34 <ehird> hmmm
15:09:10 <peaker> Cool. This Luke Palmer dude seems to have reached the exact same vision for which I learned Haskell, by learning Haskell and FRP :)
15:09:37 <mornfall> pumpkin: (Nvm, solved.)
15:09:46 <pumpkin> mornfall: what was it? :o
15:10:01 <monochrom> I want to know too. SIGBUS is serious business. :)
15:10:03 <peaker> ddarius: what's Luke Palmer's nick?
15:10:14 <BMeph> peaker: luqui. :)
15:10:36 <mornfall> pumpkin: I was writing over a file that's probably not been unmapped yet (yes, I'm using bytestring-mmap). Adding removeFile before BL.writeFile helped.
15:10:42 <pumpkin> ah
15:10:58 <monochrom> interesting
15:11:32 <peaker> BMeph: thanks
15:11:33 <ehird> bleh, this should be trivial
15:11:50 <pumpkin> ah
15:12:07 <pejo> mathijs, google for readline ghc 6.10 patch and the second hit will give instructions
15:12:26 <mathijs> pejo: thanks
15:13:52 <Cheshire> if I download a darcs repo and then  say created a bunch of files in there.. can I have darcs remove the ones I made?
15:13:53 <mathijs> pejo: too bad I need to patch and recompile. I'll stick to crappy editline for now.
15:13:58 <Cheshire> or at least list the files that shouldn't be there
15:14:39 <Cheshire> oh _darcs/pristine
15:14:46 <Saizan_> mathijs: you can install ghci-haskeline from hackage
15:15:00 <Saizan_> mathijs: it works well in my experience
15:15:05 <mle> Cheshire: darcs whatsnew -ls
15:15:11 * ehird crosses fingers
15:15:23 <ehird> Gotta work 50th time... ooh, a different error.
15:15:23 <Cheshire> oh cool thanks mle
15:15:31 <ehird> Ah. Loading package HOC-1.0 ... <command line>: can't load .so/.DLL for: HOC_cbits (dlopen(libHOC_cbits.dylib, 9): image not found)
15:15:38 <ehird> It was meant to link it statically (libHOC_cbits.a)...
15:15:39 <mathijs> Saizan_: that's just ghci linked to readline?
15:16:06 <Saizan_> mathijs: it uses haskeline, a pure haskell clone
15:16:35 <mathijs> Saizan_: if it works better than editline, why didn't ghc switch to it?
15:17:23 <ferret_0567> ehird: your on OS X?
15:17:27 <ehird> Yes.
15:17:34 <ehird> HOC is an objective-c binding..
15:17:49 <Saizan_> mathijs: before the release we didn't realise how bad editline was, and haskeline came out after it
15:17:55 <ferret_0567> ehird: you can use ObjC on other operating systems too, you know
15:17:59 <ehird> Well, yeah.
15:18:03 <ehird> But it's kind of painful.
15:18:09 <mathijs> Saizan_: so will 6.10.2 switch to it? or 6.11?
15:18:27 <Saizan_> mathijs: i think that's the plan
15:18:37 <mathijs> Saizan_: cool. thanks
15:18:44 <Saizan_> not sure about which version
15:25:26 <pumpkin> ehird: did you get any further?
15:25:36 <ehird> I'm trying something
15:27:26 <mathijs> Saizan_: is there already some estimate release date for ghc's next version? I would like to do some playing around with shared libraries, I understood they should work (beta) in the next release.
15:27:45 <ehird> pumpkin: I basically ran the linker myself
15:27:48 <ehird> I think it might work
15:27:48 <ksf> It's hard to come up with a thing more soothing than a rigorous test suite running flawlessly.
15:27:51 <ehird> ... Nope.
15:27:51 <pumpkin> ehird: ooh
15:27:53 <pumpkin> oh
15:27:54 <ehird> GRAH!
15:28:01 * ehird bashes head against wall repeatedly
15:28:16 <pumpkin> do more bashing and I'm sure it'll start working
15:28:22 <ehird> I'm becoming a hermit ->
15:29:14 <peaker> ksf: A dependently typed program that's fully specified compiling and then the checksummed compiled result being proven equivalent to some spec? :)
15:29:33 <Saizan_> mathijs: a release candidate is scheduled for the end of this week
15:29:40 <pumpkin> ooh
15:30:10 <ehird> Grah ... this is useless to the Nth degree.
15:30:22 <ksf> peaker, my point. It's hard to come up with proofs like that.
15:30:35 <ksf> (though admittedly not the intended point)
15:31:14 <mathijs> Saizan_: nice, and minor versions don't break source-compatibility?
15:31:21 <ksf> ehird, the proper terminology is "arbitrarily sensefree"
15:31:46 <peaker> ksf: I am so satifsfied with the reliability of well styled type-checked Haskell code that I don't feel I need tests for much of it
15:32:05 <peaker> ksf: though admittedly, it is possible to write Haskell in a style that renders type safety almost meaningless
15:32:25 <ksf> like, for example, if you're doing binary serialisation.
15:32:27 <ehird> This is driving me utterly crazy. Who the hell thought this was all a good idea.
15:33:13 <Saizan_> mathijs: right
15:33:49 <loadquo> Does anyone recommend B.C. Pierce's Basic Category Theory for Computer Scientists?
15:33:49 <ehird> Who here is responsible for the abomination known as hoc? :p
15:34:02 <peaker> ksf: Well, if we had a good pickler combinator library...
15:34:04 <Ralith> could be
15:34:14 <Cheshire> I recommend  Conceptual Mathematics  if you are a beginner
15:34:44 <Cheshire> It's the first time I read something about category theory and actually understood it ....
15:35:05 <cypher-> Cheshire: author?
15:35:09 <smtms> if I happen to know category theory, but know nothing about Haskell, what would you recommend?
15:35:19 <Cheshire> @go Conceptual Mathematics
15:35:21 * cypher- likes some texts that were recommended on haskell.org
15:35:22 <lambdabot> http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/0521478170
15:36:06 <loadquo> Cheshire: Thanks
15:36:41 <cypher-> if I'm lucky I will have category theory at uni in 1.5 years ;-)
15:37:06 <cypher-> but that's only if I find cash to stay for MA, and get accepted *sigh*
15:37:09 <ehird> @hoogle remove
15:37:10 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
15:37:10 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
15:37:10 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
15:37:15 <ehird> (trying to remove an element from a list)
15:37:24 <Gracenotes> :t delete
15:37:26 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
15:37:28 <ehird> aha, thanks
15:37:45 <Gracenotes> @type (\\) --for multiple elements, iirc
15:37:47 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:38:06 * ehird prays to the god of working software.
15:38:43 <cypher-> that god is not very merciful
15:38:57 <Gracenotes> @pl \elem list -> list \\ repeat elem
15:38:57 <lambdabot> (line 1, column 20):
15:38:57 <lambdabot> unexpected "\\"
15:38:57 <lambdabot> expecting variable, "(", operator or end of input
15:39:01 <Gracenotes> :x
15:39:35 <ehird> cypher-: he's a jerk.
15:39:39 <ksf> ehird, don't. eris loves to intercept those.
15:39:47 <Gracenotes> @pl \xs x -> f (xs) (repeat x)
15:39:48 <lambdabot> (. repeat) . f
15:39:53 <ehird> yeah it did exactly the same thing it did the last 5 billion times
15:41:57 <dcoutts> ehird: you cannot link with arbitrary .o files. It can compile C. Dunno about Objective-C
15:42:09 <ehird> dcoutts: I have to link with arbitrary .o files. :-)
15:42:24 <dcoutts> ehird: that's fine, but Cabal does not support it
15:42:32 <ehird> :-(
15:42:34 <dcoutts> not the Simple build system anyway
15:42:47 <dcoutts> you can do what you like with build-type: Custom
15:44:54 <ehird> dcoutts: the package hacked it with "c-sources: foo.o", but that broke in ghc 6.10
15:45:09 <dcoutts> ehird: yeah, it was an accident if that ever worked
15:45:12 <dons> anyone played with grapefruit + arrows syntax + gtk yet?
15:45:23 <ehird> dcoutts: unfortunately, its make build system doesn't work...
15:45:31 <Cheshire> @hackage grapefruit
15:45:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/grapefruit
15:45:40 * dons is thinking about doing some gtk screencasts
15:45:49 <dons> write a little program, record that process, end result: little gui app
15:45:57 <dcoutts> ehird: thing is, how are we to know if that .o file is up to date? We should not be looking to allow arbitrary .o files, but extra build rules.
15:46:02 <dons> now that youtube's kinda reasonable compression-wise
15:46:10 <ivanm> dons: write a little program to make screencasts, and eat-your-own-dogfood? :p
15:46:23 <ehird> dcoutts: Yes, well, I'd do everything about HOC differently personally.
15:46:25 <mathijs> dons: do you have any experience building QT apps?
15:46:27 <dons> :)
15:46:30 <dons> mathijs: nope
15:47:17 <Nafai> dons: Sounds like a great idea!
15:47:18 <pumpkin> haskell screencasts in general would be cool
15:47:25 <pumpkin> not just for gtk
15:47:39 <dons> i started doing them for xmonad, a while ago, but youtube's compression wasn't so great. but now they seem to do a much better job
15:47:43 <mathijs> dons: I looked around a bit but atm gtk seems better supported than QT... maybe it's time for me to switch toolkit :(
15:47:50 <pumpkin> dons: vimeo is really good
15:47:54 <Nafai> An answer to my question on -cafe would be good too :)
15:47:57 <dons> i.e. this is really readable http://www.youtube.com/watch?v=MugQXHUZPK8
15:48:00 <zeno__> just read rwh, ive heard of arrows but they wern't mentioned.  what are they used for in general?
15:48:04 <dons> you can see cabal at work :)
15:48:05 <redditbot> GHC on SPARC: Allocate!
15:48:05 <augustss> dcoutts!
15:48:11 <dcoutts> augustss!
15:48:20 <dons> mathijs: or you could improve the support for QT?
15:48:21 <ferret_0567> where can I get OOHaskell from?
15:48:21 <Cale> zeno__: Well, they're another type of library interface, like monads.
15:48:40 <dons> ferret_0567: i'm not sure you'd want to get it.
15:48:43 <ferret_0567> http://homepages.cwi.nl/~ralf/OOHaskell/ isn't loading
15:48:46 <dons> its not really suitable for beginners :)
15:48:49 <ferret_0567> dons: I'm not sure either
15:48:55 <pumpkin> ferret_0567: just say no!
15:49:02 <ferret_0567> dons: but, I want to know where I can get it
15:49:05 <ferret_0567> pumpkin: no way!
15:49:08 <dons> one good rule: if it isn't on hackage.haskell.org
15:49:10 <dons> then don't bother
15:49:13 <dons> unless you've a good reason
15:49:17 <pumpkin> dons: gtk2hs? :P
15:49:20 <mathijs> dons: well, since I'm learning haskell I don't think I can be of any help yet. But who knows
15:49:34 <dcoutts> pumpkin: sigh
15:49:34 <ferret_0567> ok then
15:49:47 <pumpkin> dcoutts: ?
15:49:57 <dons> dcoutts: we need a library for querying hackage. i think that in place is my hackathon goal
15:49:57 <cypher-> ferret_0567: loads for me just fine
15:50:26 <ferret_0567> cypher-: my wireless must SUCK then
15:50:30 <ferret_0567> DNS resolves SO SLOW!
15:50:44 <ferret_0567> The DNS server is on the LAN, even!
15:51:00 <ferret_0567> in fact...the DNS server is my router
15:51:05 <pumpkin> ferret_0567: works here too, but I'd avoid trying to apply OO to haskell until you know it's really what you want
15:51:35 <pumpkin> dcoutts: I wasn't criticizing!
15:51:39 <dons> trying to do OO -- esp Ralf + Oleg OO -- on day 1 is the wrong way to learn haskell :)
15:52:33 <Cheshire> ...in the type system
15:52:50 <ferret_0567> erm...OOHaskell seems to be for GHC 6.4
15:53:01 <peaker> I'm not sure why you'd want OO in Haskell at all
15:53:02 <roconnor> ``
15:53:03 <roconnor> Fix buffer overrrun bug at extreme low conversion ratios. Thanks to Russell
15:53:05 <roconnor>      O'Connor for the report.
15:53:11 <ehird> OOHaskell is dead and whatnot.
15:53:14 * roconnor tries to remember filing a bug report
15:53:20 <ehird> And also, ummm, kind of rubbish. as in unneeded.
15:53:20 * roconnor tries to remember using the software
15:53:27 <mauke> oh yeah, they use weird pattern signatures
15:53:37 <ddarius> roconnor: Perhaps you were sleep-bug-reporting.
15:53:39 <ksf> Am I guessing right if I guess that runGetstate takes a number of bytes to skip before parsing as argument?
15:53:48 <mauke> like foo (x :: a) (y :: a) = ... to make sure x and y have the same type, only more complicated
15:53:51 <peaker> Type-classes, function records and unexported constructors already do everything that is good about OO
15:53:52 <ksf> the Int64 parameter doesn't seem to be documented.
15:53:58 <dons> woo, haskelldb back in business. http://aur.archlinux.org/packages.php?ID=23936
15:54:11 * dons is happy to see really big projects from the past getting revived on hackage
15:54:17 <roconnor> ddarius: maybe it is a nother Russell O'Connor :P
15:54:23 <dons> ksf: yikes.
15:54:31 <dons> ksf: if its not documented, it needs to be :/
15:54:41 <dons> someone going to cabalised oohaskell? :)
15:54:50 <mathijs> great, I'm very interrested in haskelldb. :)
15:55:02 <ehird> [23:54:10] • dons is happy to see really big projects from the past getting revived on hackage
15:55:04 <ehird> HOC, please.
15:55:12 <ehird> :P
15:55:13 <SamB> dons: how would that be meaningful ?
15:55:15 <ddarius> dons: You'd have to be pretty insane to want to use OOHaskell.
15:55:22 <mauke> Higher Order C?
15:55:23 <sclv> 00haskell was suceeded by timber.
15:55:28 <SamB> does it even build ?
15:55:29 <pumpkin> mauke: objective c binding
15:55:30 <sclv> which seems useful
15:55:36 <ddarius> sclv: No, O'Haskell was succeeded by Timber.
15:55:44 <dons> yes, i was confused for a second :)
15:55:45 <sclv> oh -- oops, you're right.
15:55:54 <dons> Timber is alive and well, and comes out of that OHugs etc land
15:55:57 <dons> aka Oregon.
15:56:05 <ddarius> @hackage timberc
15:56:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/timberc
15:56:20 <Nafai> I read most of the OOHaskell paper the other day
15:56:24 <Nafai> It was interesting, at least
15:56:43 <Nafai> The parts I understood
15:56:58 <dons> the haskell database story seems pretty solid now. multiple backends, multiple working intermediate layers, and a couple of high level front ends
15:57:14 <pumpkin> ferret_0567: maybe we can suggest more idiomatic alternatives to your OO urges for haskell?
15:57:15 <dons> similar with graphics, 3 active backends (gtk, qt, wx), several layers on top.
15:57:25 <dons> and frp in general seems to be kicking along ok.
15:57:30 <Nafai> Yeah
15:57:36 <Nafai> Grapefruit looks interesting
15:57:45 <Nafai> And webdev stuff is picking up
15:58:18 <dons> and lots of web stuff. yeah, too much. we need a survey to work it all out.
15:58:23 <dons> things are specialising a lot too.
15:58:28 <dons> i.e. we have *wiki* libraries now.
15:58:32 <dons> not just web libs
15:58:40 <ehird> Haskell is pretty much great right now.
15:58:50 <ehird> The evangelism has paid off, I guess.
15:58:53 <Nafai> Are there any other cool analysis tools out there these days, like hlint?
15:58:57 <ehird> Time to kick back and relax?
15:59:06 <dons> ehird: training maybe?
15:59:22 <dons> training + infrastructure + maturity + ...
15:59:36 <dons> means enough people are writing enough things to do pretty much everything
16:01:10 * cypher- is relucant to say that haskell gained enough momentum
16:01:10 <Cheshire> > 1+1
16:01:12 <lambdabot>   2
16:01:27 <pumpkin> dons: about those uvector patches... :)
16:01:47 <Nafai> Maybe it's gaining enough that in a few years I might even write Haskell for owrk
16:01:49 <pumpkin> dons: I'm just curious, is there anything I can do to help?
16:01:49 <roconnor> ddarius: I don't remember using this software ever.
16:01:50 <Nafai> work, even
16:01:51 <dons> pumpkin: thanks. yes. on my queue
16:01:59 <dons> pumpkin: other than find me extra say, 10 hours a day?
16:02:04 <pumpkin> sorry, didn't mean to bug :)
16:02:09 <dons> cypher-: yes, not enough yet.
16:02:14 <dons> we must push on!
16:02:34 <dons> until we're all just working in haskell for good $, we're not done.
16:02:36 <dolio> Get dons some caffeine pills.
16:02:44 <pumpkin> lol
16:02:47 <cypher-> dons: I worked for some guys who wanted to start using fp for a lot of development, but they went for F#
16:02:49 <pumpkin> caffeine pills are bad!
16:02:51 <roconnor> does Erik de Castro Lopo  hang out here?
16:03:00 <cypher-> the reason being very good integration with their infrastructure
16:03:28 <dons> cypher-: right.
16:03:31 <dons> that's entirely reasonable.
16:03:38 <dons> we might actually want   to look at F# interop
16:03:46 <dons> or at least documenting all the .NET stuff
16:04:31 <dons> all the F# stuff is helping train up more haskellers too , though
16:04:35 <dons> and makes the general case for FP easier
16:04:45 <inimino> ugh, .net
16:04:46 <augustss> dons: true
16:04:55 <cypher-> hehe, true
16:05:07 <cypher-> I've seen a lot of really funny f# code
16:05:21 <cypher-> written by people who used c# for too long ;-)
16:05:31 <augustss> not enough bondage and discipline in F#
16:06:23 <jpcooper> I bring xchat up and this is what I read
16:06:23 <wli> IMHO more advanced module systems would help.
16:06:25 <dons> a decent % of RWH sales have gone to F# developers, i bet. I've seen a number of posts on how haskell teaches them the foundations for what they're trying to do.
16:06:36 <dons> puts the structure in place for how you're "supposed" to do F#.
16:06:55 <cypher-> the problem with f# is that it allows very strange style of programming that does not essentially make use of the functional features, but isntead uses features that allow for interoperatility with the rest of .net
16:07:12 <cypher-> exactly, haskell forces you to learn how you should do things in f#
16:07:25 <cypher-> because in haskell there is no other way ;-)
16:07:36 <mathijs> TM :)
16:07:52 <Twey> Oh well, that's OK
16:07:59 <gwern> 'FYI, for the curious, the monad stack for ServerT (leaving out all
16:08:00 <gwern> kinds of additional typing) looks like:
16:08:02 <gwern> ServerT $ ReaderT $ WebT $ ErrorT $ FilterT $ WriterT $ MaybeT m
16:08:04 <gwern> o.0
16:08:09 <Twey> Argggh
16:08:24 <dons> gwern: mwahaha
16:08:26 <Twey> One can use $ in type definitions?
16:08:43 <gwern> money can buy anything, even type definitions
16:08:47 <Twey> Haha
16:08:49 <Valodim> ..what the hell
16:09:24 <cypher-> dons: is your nickname being so close to the name of F#'s developer a coincidence?
16:09:40 <gwern> cypher-: dons is the original!
16:09:53 * Nafai points everyone to http://article.gmane.org/gmane.comp.lang.haskell.cafe/52927 :)
16:09:57 <ddarius> It was a conspiracy of their parents.
16:09:58 <Nafai> Answer at your leisure, please :)
16:10:37 <cypher-> :)
16:10:45 <gwern> Nafai: actually I was vaguely wondering why you weren't using one of the hackage rss libs
16:10:57 * cypher- goes back to do his floating point computation work :/
16:11:21 <Cale> cypher-: dons is Don Stewart.
16:11:35 * augustss pities cypher- 
16:12:03 <dons> cypher-: haha
16:12:14 <dons> all the dons from .au are hacking your lambdas
16:12:15 <Nafai> gwern: I am. I'm using the "feed" library
16:12:16 <gwern> if I were more knowledgeable about pop culture, I would attempt a 'will the real don stewart please stand up, please stand up?' parody, but you will just have to imagine it
16:12:36 <Nafai> I suppose I should have pointed that out
16:12:44 <dons> sclv: would you say haskelldb and takusen are at similar levels of abstraction?
16:12:45 <Cale> All your dons are belong to us?
16:12:56 <gwern> dons is in ur repo hacking ur lambdas
16:13:06 <Nafai> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/feed <- this library
16:13:11 <dons> or does haskelldb put enough additional abstractions in place to be a bit higher.
16:13:12 <gwern> hm. repo has 2 syllables. perhaps 'darcs'
16:13:13 <thetallguy> dons is hacking lambdas while .au burns
16:13:18 <dons> thetallguy: true enough
16:13:26 <thetallguy> ergo, dons == nero
16:13:27 <dons> there's floods this weekend though
16:13:31 <dons> fires were last week
16:13:39 <ehird> dons is responsible for the .au fires; he's making space for a million haskell robots
16:13:40 <thetallguy> dons: just like San Diego
16:13:43 <gwern> 'dons is in ur darcs, hacking ur lambdas' <-> 'im in ur base, killing ur teammates'
16:13:46 <ehird> he'll deny it, but it's TRUE!!
16:14:03 <ehird> oh heck yeah HOC is building
16:14:09 <ehird> it's like my birthday
16:14:11 <ehird> except not
16:14:20 <thetallguy> the rains make for a growth boom which fuels more fires...
16:14:35 <thetallguy> dons: are the fires out now?
16:14:50 <dons> anyone know if we have a database abstraction matrix, the way we do for guis (or did have?)
16:14:56 <dons> thetallguy: yeah, i think so.
16:15:02 <dons> further north, there's heavy flooding
16:15:08 <dons> (its a big country)
16:15:43 <thetallguy> so I hear
16:15:43 <dons> this page is out of date, http://haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
16:16:25 <thetallguy> I found the TH wiki info somewhat outdated, too.
16:16:37 <Cale> http://members.shaw.ca/andysmyth/ -- here's what dons would look like if he were black, and a vocalist, apparently.
16:16:38 <ehird> okay, after dealing with HOC, I'm going to write my own objc bindings so that nobody else has to go through what I just have
16:16:40 <roconnor> heh, Gregg Reynolds is getting a little out of hand. ^_^
16:16:48 <Saizan> Nafai: maybe you need to sprinkle a little of unsafeInterleaveIO on the action returning [Item]
16:17:00 <thetallguy> if I get more time with it, I'll try and update.
16:17:18 <pumpkin> roconnor: intergalactic telefunctors? :P
16:17:37 <pumpkin> wow, hard smackdown from ddarius on that thread :P
16:17:45 <pumpkin> even harsher than dons on coppin
16:18:00 <roconnor> pumpkin: in this case I read "The Container Fiction"
16:18:09 <pumpkin> ah
16:18:16 <roconnor> pumpkin: but it is more than that.
16:18:32 <ehird> is it smackdown monday?
16:18:33 <roconnor> pumpkin: he does make few good points in his blogs posts
16:18:40 <Cale> roconnor: I read a couple sentences of that and decided it wasn't worth reading.
16:18:52 * dcoutts reads dons reply on epic failure with great amusement
16:18:55 <roconnor> pumpkin: but I think there are many bad points too
16:19:04 <pumpkin> roconnor: yeah :)
16:19:24 <pumpkin> ehird: I think so :P people have decided to not put up with any more BS on caf
16:19:27 <pumpkin> *cafe
16:19:36 <dolio> Is it Monday?
16:19:43 <ehird> yeah, being nice is fine but after a while you have to sort out the riffraff...
16:19:49 <augustss> roconnor: it's hard to find the good points in the drivel
16:19:51 <pumpkin> dolio: for some people :)
16:20:11 <ehird> HOC works!
16:20:13 <ehird> thank the lord.
16:20:42 * thetallguy thanks dcoutts for the pointer.  Wouldn't have read that thread otherwise.
16:20:44 <pumpkin> wow!
16:21:06 <pumpkin> ehird: now what?
16:21:16 <ehird> pumpkin: Now I compile Yi with its cocoa frontend!
16:21:20 <pumpkin> :o
16:22:27 <gwern> ehird: does that frontend actually work?
16:22:37 <NameAlreadyInUse> what's the deal with "unfoldr"?
16:22:41 <dcoutts> thetallguy: dons is getting pretty good at the flaming politely :-) I like the bit: "Besides the technical aspects, your presentation categorises the post somewhere between internet crank and internet troll"
16:22:42 <ehird> gwern: If it doesn't I'll be veeery angry at the waste of my time :P
16:22:49 <dolio> NameAlreadyInUse: It's awesome.
16:22:52 <gwern> NameAlreadyInUse: it's like, the dual of the foldr, man
16:22:58 <ehird> Specifically, people may die.
16:23:06 <thetallguy> dcoutts: I liked, ``After three years of this...''
16:23:10 <dcoutts> heh heh heh
16:23:12 <gwern> ehird: not jpb! he's keeping yi alive!
16:23:27 <ehird> gwern: Maybe he should have thought of that beforehand.
16:23:28 <gwern> thetallguy: I wondered, has coppin really been posting stuff like that for 3 years?
16:23:40 <NameAlreadyInUse> gwern: i understand that, i am just not sure what it means
16:23:41 <dcoutts> gwern: if not really three years it certainly feels like it
16:23:45 <augustss> just two, I think
16:23:55 <thetallguy> gwern: I thought he was more recent, but it seems like an eternity
16:23:58 <Axman6> :t unfoldr
16:24:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:24:05 <ddarius> gwern: No, two-ish years.
16:24:28 <gwern> hmm. I dunno. it took me a while to catch on to coppin
16:24:32 <ddarius> [16:39] <dons> actually , i was wrong, he's been on the lists asking the same questions for 2 years, not 3. http://article.gmane.org/gmane.comp.lang.haskell.cafe/21757/
16:24:37 <gwern> so can't remember the first time I really noticed
16:24:51 <thetallguy> NameAlreadyInUse: unfoldr is tricky.  I like to think of it as a seed and a rule that together produce a sequence
16:25:03 <ehird> Yi/GHC.hs:35:40: Not in scope: `WS.new'
16:25:04 <ehird> what.
16:25:09 <dcoutts> thetallguy: that's exactly the right way to think about it I'd say
16:25:18 <thetallguy> NameAlreadyInUse: look at the source for iterate
16:25:53 <gwern> hm, GHC.hs? wonder if got hit by api bitrot
16:26:23 <Axman6> NameAlreadyInUse: unfoldr takes a function that turns a b into either Nothing, or Just (a,b), it'll heep iterating this function on the b's from those pairs, and form a list of a's until it hits a Nothing
16:26:37 <gwern> ooh, that's interesting. might be a pointedlist bug
16:26:40 <thetallguy> nice gathering on a Sunday afternoon.  Who's making the roast?
16:26:43 <dsrogers> is there a nominal way to write (\x -> dataType{accessor=x})?
16:27:08 <roconnor> dsrogers: use Data.Accessor?
16:27:29 <ehird> it builds thank god.
16:27:30 <dcoutts> dsrogers: I just do that and perhaps name it as setWhatever
16:27:35 <ehird> this must work.
16:27:45 <dons> dcoutts: i was thinking of this with the 'crank' thing, btw, http://math.ucr.edu/home/baez/crackpot.html
16:27:47 <dsrogers> ok
16:27:49 <gwern> ehird: what did you do?
16:28:02 <ehird> built yi with the cocoa frontend on ghc 6.10 and os x leopard.
16:28:03 <thetallguy> Oh, some of you are veggies, aren't you?  Hmm...  Roast squash stuffed with onions, mushrooms, ricotta and black beans?
16:28:04 <dons> but its not entirely applicable. sometimes we really do get crackpots though :)
16:28:05 <ehird> HOC isn't meant to build on those.
16:28:09 <ehird> it involved hacks. bad hacks.
16:28:26 <gwern> thetallguy: I'm not a veggie! I'm made of meat!
16:28:33 <gwern> my whole family is made of meat!
16:28:40 <Axman6> > unfoldr (\b -> if b > 100 then Nothing else Just (b,b*b)) 2 -- NameAlreadyInUse
16:28:42 <lambdabot>   [2,4,16]
16:28:43 <thetallguy> I guess I'd better go eat something.
16:28:46 <NameAlreadyInUse> ok
16:28:48 <Axman6> hmm
16:28:50 <NameAlreadyInUse> i think i've got it now
16:28:57 <thetallguy> gwern: are you volunteering to be roasted?
16:29:11 <Axman6> > unfoldr (\b -> if b > 100 then Nothing else Just (b,2*b)) 2
16:29:13 <gwern> no way. I'm too lean.
16:29:13 <lambdabot>   [2,4,8,16,32,64]
16:29:14 <ehird> OMG.
16:29:17 <ehird> Yi cocoa works.
16:29:26 <Axman6> ehird: really? :o
16:29:29 <ehird> Yeah.
16:29:31 <thetallguy> NameAlreadyInUse: it's easier if you take out the Maybe's
16:29:33 <roconnor> pumpkin: ooh, I just read ddarius's smackdown
16:29:36 <ehird> I'm getting errors, though -- do I need to make a config file>?
16:29:39 <roconnor> I guess he is right
16:29:43 <ddarius> dons: I wounder what our version of 8 would be.
16:29:45 <gwern> ehird: think so
16:29:47 <dons> i'm a bit concerned we need this smackdown business.
16:29:51 <pumpkin> Axman6: guard is nice there in my opinion :)
16:29:56 <thetallguy> gwern: we'll wrap you in bacon...
16:29:59 <ehird> gwern: what should I copy it from?
16:30:02 <Axman6> :t guard
16:30:04 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:30:04 <gwern> thetallguy: and sausage!
16:30:08 <ehird> dons: big communities bring rubbish people, something has to happen
16:30:13 <gwern> ehird: well, there are a oucple configs in Yi/Users
16:30:17 <dons> training the hard way, eh?
16:30:33 <Axman6> > unfoldr (\b -> guard (b > 100) >> Just (b,2*b)) 2
16:30:34 <thetallguy> gwern: sausage stuffing, bacon wrapping.
16:30:35 <lambdabot>   []
16:30:36 <dons> ddarius: citing category theory? :)
16:30:45 <Axman6> > unfoldr (\b -> guard (b < 100) >> Just (b,2*b)) 2
16:30:47 <lambdabot>   [2,4,8,16,32,64]
16:30:56 <Axman6> pumpkin: indeed, ta :)
16:31:06 <thetallguy> I wonder what the haskell equivalent of wrapping something in bacon is?
16:31:09 <ddarius> dons: Yeah, I was thinking Moggi might actually count, though I'm iffy about that, but who else?
16:31:12 <pumpkin> thetallguy: return
16:31:35 <thetallguy> pumpkin: monads can't compete with pork, in my opinion
16:31:37 <Zao> Urge to define   bacon = return  rising.
16:31:59 <pumpkin> instance Monad Bacon where
16:32:01 <roconnor> bacon is like applicative functors ...
16:32:03 <Axman6> nothing can compete with bacon
16:32:14 <ehird> Monads are like Bacon
16:32:15 <thetallguy> I think point-free style has that sort of cruncy goodness
16:32:20 <pumpkin> and burritos
16:32:24 <augustss> Is bacon a container?
16:32:25 <pumpkin> bacon burritos :)
16:32:29 <Axman6> Bacon are like Integers, infinitely perfect
16:32:35 <thetallguy> augustss: ooh, very nice
16:32:38 <pumpkin> augustss: http://www.bbqaddicts.com/blog/recipes/bacon-explosion/
16:32:41 <Axman6> s/are/is
16:32:53 <dolio> augustss: Containers are a lie!
16:32:54 <ddarius> dons: Neither of the Simons nor Wadler, though notable personages in the Haskell community, seem very useful for producing crackpottery.
16:33:06 <gwern> I read about the bacon explosion in the new york times
16:33:10 <augustss> dolio: I know!  So bacon is a lie!
16:33:17 <dolio> @yow!
16:33:18 <lambdabot> Yow!  I'm having a quadrophonic sensation of two winos alone in a steel mill!
16:33:22 <pumpkin> gwern: I've made two of them :D
16:33:25 <nominolo_> @users
16:33:26 <lambdabot> Maximum users seen in #haskell: 666, currently: 619 (92.9%), active: 26 (4.2%)
16:33:31 <thetallguy> my work here is done
16:33:34 <z0d> Evil!
16:33:38 <Axman6> :O
16:33:45 <nominolo_> not right now
16:33:47 <z0d> @users
16:33:48 <lambdabot> Maximum users seen in #haskell: 666, currently: 619 (92.9%), active: 27 (4.4%)
16:33:55 <Axman6> i'm upset it doesn't remember when the max was 699
16:34:00 <pumpkin> yeah, me too
16:34:10 <ehird> You know how I said the cocoa gui worked?
16:34:12 <nominolo_> it was?
16:34:13 <ehird> It's dropping newlines.
16:34:19 <pumpkin> ehird: :D
16:34:20 <Axman6> heh
16:34:24 <pumpkin> nominolo_: yup, until lambdabot died
16:34:26 <ehird> also cursor keys lag it to forever.
16:34:30 <Axman6> @quote ehird
16:34:31 <lambdabot> ehird says: 2009: The Year of the Combinatorial Explosion of Haskell Web Frameworks. Also, the Linux Desktop.
16:34:40 <nominolo_> pumpkin: do you know when that was?
16:34:44 <ehird> It's literally not even displaying newlines.
16:34:47 <nominolo_> the 699 number
16:34:49 <pumpkin> nominolo_: a week ago-ish?
16:34:50 <ehird> That is rather crap.
16:35:00 <gwern> ehird: well file a bug
16:35:01 <nominolo_> crazy
16:35:05 <Axman6> bleh, why are quotes persistent, but not all time highest members
16:35:09 <gwern> I think you're the 2nd person to use the cocoa
16:35:16 <gwern> (after munkby)
16:35:17 <pumpkin> Axman6: make a patch for lambdabot!
16:35:19 <ehird> gwern: I'd rather rewrite it using my binding :-)
16:35:21 <augustss> @quote bacon
16:35:21 <lambdabot> No quotes match. Just what do you think you're doing Dave?
16:35:24 <thetallguy> So, Lisa, are you saying you never are going to eat lambas again?
16:35:25 <Axman6> :O
16:35:27 <dolio> Axman6: Quotes aren't persistent.
16:35:32 <Axman6> no bacon quotes?
16:35:38 <gwern> @flush
16:35:40 <thetallguy> Functions?  No.
16:35:49 <thetallguy> If statements?  No.
16:35:50 <Axman6> dolio: sure they are, that quote of ehird has survived at least two lambdabot crashes
16:35:51 <nominolo_> @quote pork
16:35:52 <lambdabot> No quotes match. :(
16:36:04 <dolio> Axman6: My xahlee quotes keep getting deleted.
16:36:04 <thetallguy> case statements?  NO!  Dad, those are all lambdas!
16:36:18 <augustss> @quote beef
16:36:19 <lambdabot> No quotes match. It can only be attributed to human error.
16:36:31 <loadquo> @quote quote
16:36:32 <lambdabot> lambdabot says: Plugin `quote' failed
16:36:33 <nominolo_> @quote chicken melon
16:36:34 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
16:36:37 <pumpkin> @remember FrancisBacon Nam et ipsa scientia potestas est
16:36:38 <lambdabot> Good to know.
16:36:40 <augustss> @quote cookie
16:36:40 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
16:36:47 <pumpkin> @quote bacon
16:36:48 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
16:36:52 <pumpkin> :(
16:37:03 <thetallguy> Oh, I remember, I actually had a question.
16:37:19 * Axman6 has a question
16:37:25 <Axman6> how tall are you thetallguy?
16:37:31 <ehird> "tall"
16:37:32 <augustss> thetallguy: Yes!  Haskell can do that.
16:37:45 <thetallguy> If an interactive program runs forever, does it return bottom?
16:37:54 <Zao> No-one knows.
16:38:07 <Axman6> thetallguy: try it and tell us
16:38:12 <pumpkin> thetallguy: return bottom seems like an odd concept
16:38:13 <thetallguy> Axman6: tall enough to reach the ground *and* the ceiling
16:38:21 * Axman6 is too
16:38:36 <thetallguy> pumpkin: I agree.  is it's value bottom?
16:38:37 * Twey isn't tall at all
16:38:44 <nominolo_> thetallguy: did you fix the lights at the hackathon in freiberg?
16:38:47 * Twey 's legs are so short they barely reach the ground
16:38:48 <augustss> thetallguy: you mean it keeps interacting while it's running?
16:39:01 <roconnor> ddarius: turns out it was another Russell O'Connor who made the libsamplerate bug report.
16:39:08 <thetallguy> nominolo_: Yes, that sounds familiar.
16:39:15 <thetallguy> augustss: yes
16:39:17 <ddarius> roconnor: You've been cloned!
16:39:26 <roconnor> Find the name "Russell O'Connor" on Planet Haskell that isn't referring to me is a little disturbing
16:39:52 <thetallguy> e.g.   foo xs = do { print xs ; x <- getline; foo (x:xs) }
16:39:53 <pumpkin> wow
16:39:55 <dolio> Did anyone make you take an "eye test" recently?
16:39:56 <augustss> thetallguy: then it's not bottom.  I'm not really sure what you think the question means
16:40:31 <thetallguy> augustss: i'm not sure either, but I wrote that little fragment and someone responded...
16:40:45 <thetallguy> ﻿interactive bottom?
16:40:54 <Axman6> giggity
16:41:01 <pumpkin> interacting with the bottom can lead to unexpected results
16:41:11 <BONUS> ah w00t
16:41:14 <BONUS> @seen ski_
16:41:14 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I last heard ski_ speak 4h 17m 27s ago.
16:41:17 <augustss> thetallguy: as you give it longer and longer input sequences it gives you longer and longer output sequences.  No bottom in sight
16:41:19 <thetallguy> So I was trying to make some sense of that.
16:41:34 <BONUS> how long does it usually take for a mail to appear on haskell-cafe
16:41:49 <gwern> a minute or 3
16:42:01 <nominolo_> BONUS: not long.  but some mail interfaces don't show your own mail
16:42:03 <thetallguy> actually, in my original, the print statement was missing
16:42:08 <augustss> thetallguy: Just think of it as a dunction of type String->String
16:42:10 <pumpkin> BONUS: your email arrived for me
16:42:17 <augustss> s/dunc/func/
16:42:26 <roconnor> god
16:42:30 <BONUS> ah
16:42:37 <roconnor> how many Russell O'Connor, Computer Programmer Analyst are there out there?
16:42:42 <BONUS> strange, i didn't get my own email bounced back to me then
16:42:43 <thetallguy> I like dunction.  Have to figure out something for it to apply to.
16:42:48 <BONUS> well, as long as people got it :]
16:42:54 <thetallguy> augustss: how about the case with no output?
16:43:03 <pumpkin> BONUS: about parametrized monad transformers, right?
16:43:07 <BONUS> yeah
16:43:40 <thetallguy> ﻿foo xs = do { ﻿x <- getline; foo (x:xs) }
16:43:44 <augustss> thetallguy: if it at some point stops outputting despite given longer inputs it has a bottom.
16:44:27 <Axman6> thetallguy: dunction: a function who's definition consists of only either error "str" or undefined
16:45:16 <augustss> thetallguy: but don't let the IO confuse you.  In this case it's much easier to think of it as a regular function.
16:45:48 <thetallguy> Axman6: I was thinking  dunction: a student who has trouble understanding Functional Programming.
16:45:58 <Axman6> heh :)
16:46:21 * thetallguy squints at augustss
16:46:25 <augustss> dunction - programming with donuts and coffee
16:46:30 <Axman6> hmm, in that definition of foo, would ghc see that xs was never actually used?
16:47:06 <thetallguy> augustss: bravo on your definition.
16:47:46 <p_l> hey, donuts and coffee are not bad :)
16:48:05 <redditbot> Crackpot index
16:48:24 * thetallguy thinks he should go back and read his type theory book on _|_ again.
16:48:45 <augustss> thetallguy: foo (i:is) xs = show xs ++ foo is (i:xs); main = interact $ foo []
16:48:52 <Saizan> Nafai: ping?
16:49:07 <roconnor> dons: what's up with the crackpot index post?
16:49:14 <Nafai> Saizan: Pong, sorry.  Stepped away for a second
16:49:40 <dons> roconnor: bookmarking :)
16:49:47 <augustss> thetallguy: now you can reason about foo.  A regular function
16:50:03 <roconnor> :)
16:50:24 <Saizan> Nafai: found your problem, you actually have an infinite loop because of let
16:50:44 <thetallguy> augustss: which fails to match on the first call...
16:51:07 <augustss> Sorry, flip the arguments to foo
16:51:12 <Nafai> Saizan: Oh, really?
16:51:15 <Saizan> Nafai: "let items = deDupItems items seenMap" is a circular definition, because let is recursive, so both items refer to the same thing
16:51:26 <thetallguy> augustss: ah, that's better.
16:51:41 <Nafai> Oh
16:51:45 <augustss> thetallguy: actually  main = interact $ flip foo [] . lines
16:51:46 <Saizan> Nafai: same problem with "let feed = withFeedItems items feed"
16:52:02 <thetallguy> augustss: yes, that was clear
16:52:14 <Nafai> Saizan: Okay
16:52:27 <Nafai> Stupid imprerative programming :)
16:52:27 <Saizan> Nafai: you need to use different names on the LHS, like "let items' = deDupItems items seenMap"
16:52:35 <Saizan> heh :)
16:52:37 * Nafai nods
16:52:41 * Nafai tries
16:52:45 <Nafai> imperative, even
16:53:05 <Saizan> ina do-block you can use an idiom like "items <- return $ deDupItems items seenMap" to get shadowing
16:53:09 <mauke> palpative
16:53:15 <augustss> thetallguy: so by making the input longer you can always make the output longer.  You never get stuck.
16:53:33 <Nafai> Saizan: I think that's what I was thinking about when I first used that
16:53:34 <Twey> Hmmmm
16:54:01 <augustss> thetallguy: but bottom is very useful for reasoning about foo.  E.g., if you want to find out how much output a limited input gives you.
16:54:10 <Twey> > do { let x = 3; x + 1 }
16:54:12 <lambdabot>   <no location info>: parse error on input `}'
16:54:23 <Twey> Huh.
16:54:29 * thetallguy is listening.
16:54:32 <Nafai> Saizan: Okay, about my serialization question...will I have the seenMap with changes after the let item' = ... line?
16:54:32 <Twey> That's a peculiar error.
16:54:37 <dolio> Even if it doesn't do output, it's still not bottom.
16:54:40 <mauke> > do let {x = 3}; x + 1
16:54:41 <lambdabot>       No instance for (Num (t t1))
16:54:41 <lambdabot>        arising from the literal `3' at <in...
16:55:01 <dolio> It could be an infinite, productive sequence of IO operations that keeps accepting input, but never displays anything.
16:55:18 <Saizan> Nafai: no, seenMap is a pure value and so immutable
16:55:22 <augustss> thetallguy: just stick a bottom at the end of the input and calculate the output.  when you get to bottom in the output you have as much output as that input will give you.
16:55:23 <Nafai> It doesn't look like I will
16:55:36 <thetallguy> ah.
16:55:39 <Saizan> Nafai: you need deDupItems to return the new updated Map
16:55:46 <dons> here's an attempt to summarise the state of play for active haskell db libs,
16:55:47 <dons>  http://archhaskell.wordpress.com/2009/02/16/haskelldb-high-level-type-safe-database-queries-for-haskell/
16:55:59 <dons> in the context of arch packages. if anyone has any additional hints/ info in this area, let me know.
16:56:09 <thetallguy> augustss:  Okay, that seems to put things back in place.
16:56:14 <Nafai> Saizan: So return a tuple of the map and the items?
16:56:22 <Saizan> Nafai: yeah
16:56:40 * Axman6 still wants a puerly haskell DB without some other backend
16:56:52 <stepcut> augustss: but in this example, foo xs = do { x <- getline; foo (x:xs) }, there is no output it just keeps calling foo with a bigger accumalator value ?
16:56:53 <mauke> puerile?
16:56:57 <thetallguy> Axman6: is that purely or puerile?
16:57:18 <Axman6> purely even
16:57:24 <Twey> Axman6: MACID?
16:57:24 <augustss> stepcut: that one is bottom
16:57:28 <dons> Axman6: something layered http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TCache
16:57:58 <stepcut> augustss: but, interactive too! :)
16:58:13 <Twey> mauke: I was wondering if I could use let blocks for non-monadic values if I didn't use any binds
16:58:28 <mauke> apparently not
16:58:38 <Axman6> dons: hmm, looks interesting
16:58:39 <Twey> do { let x = 3; x + 1 } looks like it should be translated directly into let x = 3 in x + 1
16:58:39 <augustss> stepcut: if I have you the binary for that program and all you could do was to run it you couldn't tell
16:58:48 <Twey> Yeah, but the error it gave was most peculiar
16:59:13 <mauke> let gobbled it all up
16:59:15 <thetallguy> augustss: okay, that's good.  stepcut was the one who read my original code (without the print), while in my head I was thinking about the one with the print
16:59:18 <dons> Axman6: i added that to the post, thanks for  the hint.
16:59:24 <Axman6> :)
16:59:44 <dons> this arch thing is turning into the weekly review of hackage i always wanted
17:00:09 <Twey> mauke: Ah, is that what happened
17:00:23 <stepcut> augustss: maybe you could to some degree. If the program never read stdin, then the pipe would fill up and block. So you might know that it was doing something with your stdin...
17:00:26 <Twey> Ahhh, I see
17:00:27 <thetallguy> dons: are you get change messages with your arch report?
17:00:33 <dons> thetallguy: ?
17:01:11 <thetallguy> stepcut and I lament that the hackage rss says ``new version of xxx'', but never ``updated xxx  to work with 6.10'' or the like
17:01:31 <dons> ah
17:01:36 <thetallguy> dons: so I was wondering if you were doing osmething that extracted more info?
17:01:46 <dons> yes, i want that too. the new hackage system should support much better querying
17:01:47 <Twey> How does that de-sugar, then?
17:01:58 <dons> i'm getting that new / updated info via the arch packages
17:02:19 <augustss> stepcut: yes, but now you're doing something besides running the program.  But you are right at some lower level of abstraction where we can somehow observe if input is being consumed.
17:02:24 <thetallguy> dons: it's like hearing music leaking from someone else's earbuds.
17:02:55 <dons> thetallguy: right :)
17:03:06 <augustss> dons: I wish there was a "what's new" field in hackage.
17:03:07 <thetallguy> stepcut, augustss: like Linus' hack to look at socket activity of a process to see if it needs a higher priority for interaction
17:03:14 <dons> the new hackage server supports programmatic queries, so i hope to release a libhackage during the utrecht hackathon
17:03:23 <dons> then all these ad hoc scripts for scraping hackage can go away
17:03:31 <dons> augustss: yep
17:03:48 <thetallguy> It's the one thing debian did right (he said snidely)
17:04:07 <Nafai> Saizan: Thanks for the help!  I've got a minor problem with my serialization now
17:04:21 * dons likes the fact haskelldb can get released, and all required dependencies are available pre-packaged :)
17:04:45 <thetallguy> available at your local software mart?
17:04:48 <augustss> thetallguy, stepcut: but I wouldn't really call a program that just reads interacting.  Inter maybe, but not acting. :)
17:04:50 <Nafai> Saizan: I just pushed a new version to github
17:04:51 <Twey> thetallguy: You only hear the drums?
17:05:07 <thetallguy> Twey: the cymbals, I think.
17:05:13 <Nafai> I get this when I try to run my program again:
17:05:14 <Nafai> nafai@taleswapper:~/Projects/recent-feed$ ./recent-feed
17:05:14 <Nafai> recent-feed: seenMap.ser: openBinaryFile: resource busy (file is locked)
17:05:22 <Nafai> I don't quite understand what that means
17:05:25 <Twey> Maybe people just listen to a lot of D&B
17:05:40 <Twey> Nafai: Means what it says it does
17:05:40 <Nafai> lsof doesn't show the serialization file as being open
17:05:45 <Twey> Hm
17:05:57 <Twey> Maybe a double-open?
17:06:01 <stepcut> augustss: heh
17:06:06 * thetallguy nearly strangled someone with their own earbuds while smushed into an airplane seat.
17:06:07 <Nafai> Hrm
17:06:35 <Nafai> Does encodeFile and decodeFile from Data.Binary properly close files?
17:06:49 * augustss decides not to travel with thetallguy 
17:07:01 <Twey> Haha
17:07:12 <Twey> Nafai: Should do... you'd think someone would have noticed :-P
17:07:28 <Nafai> That's what I imagined
17:07:35 <Nafai> I don't directly open the files myself
17:07:37 <thetallguy> augustss: you wouldn't have to worry.  You wouldn't have had them up so high, nor ignored my request to turn them down...
17:08:04 <thetallguy> augustss: still, you wouldn't want to sit next to me because I hog all the space.
17:08:13 <Twey> Too tall?
17:08:27 <dons> dcoutts: haskell-src-exts requires happy, but that info isn't available in the .cabal file
17:08:32 <thetallguy> Twey: no, too many theta's.
17:08:34 <Twey> Oh!
17:08:36 <dons> so tools fail :) what's the thoughts on this?
17:08:39 <Twey> Yes, I was just about to mention that
17:08:45 <Twey> Er, yesterday
17:08:48 <dons> Nafai: if you hit eof, yep
17:08:59 <Twey> thetallguy: Haha
17:09:03 <thetallguy> so, Data.List failed me the other day.
17:09:11 <Twey> Oh?
17:09:14 <dons> maybe i should just make every lib depend on alex and happy
17:09:22 <dons> so they're always going to be satisfied
17:09:25 * Twey laughs.
17:09:30 <ivanm> dons: isn't that a bit of overkill?
17:09:31 <Twey> A highly elegant solution.
17:09:38 <dons> i did it for cabal
17:09:44 <dons> now everyone using arch has an up to date cabal
17:09:45 <Nafai> dons: http://github.com/Nafai77/recent-feeds/blob/7187603b427c30103027ee1345f085f3893fac88/recent-feed.hs (see the function on line 28...anythin weird there?)
17:09:46 <thetallguy> I was trying to ask if one infinite list was a subset of another
17:09:47 <Twey> There's something buggered up with, er, what was it... oh!  Yes
17:09:52 <dons> and xmonad does it for ghc --> a haskell toolchain for every child
17:09:53 <dons> so why not?
17:09:54 <ivanm> this is one reason why kolmodin doesn't want us to copy you and churn out heaps of ebuilds for all hackage packages
17:09:56 <dons> disk is cheap
17:10:02 <dons> ivanm: why's  that?
17:10:09 <thetallguy> and (\\) was not helpful
17:10:13 <Twey> dons: happs-tutorial has issues
17:10:20 <ivanm> because we can test it and get it right if we check them by hand
17:10:24 <Twey> Says it wants something from syb, which is hidden
17:10:26 <Twey> Hang on
17:10:27 <dons> i check them by hand
17:10:36 <dons> but if i have happy on my machine i don't get a failure.
17:10:40 <augustss> thetallguy:you could never get the answer yes
17:11:02 <Twey>     Could not find module `Data.Generics':
17:11:03 <Twey>       it is a member of package syb, which is hidden
17:11:08 <Twey> dons: I'm told it's a dependency error
17:11:18 <dons> ah ha
17:11:26 <dons> looks like missing --constraint='base<4'
17:11:30 <Toxaris> dons: could happy be hidden for cabal-builds where the cabal file doesn't request it, just like unmentioned packages are?
17:11:32 <dons> in the configure stage, Twey
17:11:39 <Twey> Aha
17:11:41 <dons> Toxaris: cabal files never request it
17:11:42 <thetallguy> augustss: no, but I wanted to do something like :  property $ take 100 $ (xs \\ ys)
17:11:44 <dons> they never list  their tools
17:11:46 <dons> its a mistake
17:11:59 <Toxaris> oh wasn't aware of that. back to square 1, then
17:12:09 <thetallguy> but of course, (\\) didn't know my lists were sorted integers..
17:12:09 <dons> yep. adding a tool-depends: happy, alex, m4
17:12:10 <dons> etc
17:12:23 <ivanm> m4? what do you use that for?
17:12:26 <augustss> thetallguy: should work for finite ys.  Doesn't it?
17:12:37 <dons> i don't know. someone must.
17:12:40 <thetallguy> augustss: no
17:12:46 <dons> (just an example)
17:12:52 <stepcut> dons: you'll be happy to hear that the guestbook.cabal for the example happstack application *does* list its dependency on the trhsx tool :)
17:12:55 <augustss> @src (\\)
17:12:55 <lambdabot> (\\) = foldl (flip delete)
17:13:02 <dons> stepcut: oh, how does it do that?
17:13:04 <thetallguy> augustss: presumably i could do (take nx xs)    (take ny ys)
17:13:22 <thetallguy> augustss: I mean no in a different sense.
17:13:25 <stepcut> dons: magic? let me check.
17:13:49 <Toxaris> dons: so you want to generate this information out of nothing for your packaging? couldn't you do that by trying to build it with hidden executable, if it works, it doesnt depend
17:13:54 <thetallguy> That is, given that both sequences are infinite, I don't know how many of each to take
17:14:16 <dons> Toxaris: i want    to generate it by reading the .cabal file :)
17:14:20 <dons> that, and that alone.
17:14:20 <stepcut> dons: http://patch-tag.com/publicrepos/happstack/happstack/templates/project/guestbook.cabal
17:14:22 <stepcut> dons: http://patch-tag.com/publicrepos/happstack/happstack/templates/project/Setup.hs
17:14:24 <augustss> thetallguy: if they are both infinte there's no chance unless you know they are sorted
17:14:27 <Toxaris> not sure how to hide an executable, maybe put a fake one in path
17:14:34 <dons> build-tools !
17:14:37 <thetallguy> so I would have to take a finite number from the subset, then look at the infinite one...
17:15:01 <thetallguy> augustss: yes, which I sort of concluded was why Data.List didn't have what I wanted.
17:15:06 <Nafai> It looks like it doens't like having decodeFile and encodeFile in the same function
17:15:11 <Nafai> Would this be because of laziness?
17:15:20 <Nafai> (encoding and decoding to the same file)
17:15:23 <augustss> thetallguy: it can't have everything. :)
17:15:35 <thetallguy> augustss: prove it!
17:15:52 <stepcut> augustss: Data.List is not an infinite list of functions ? :(
17:16:07 <augustss> no :(
17:16:17 * Twey laughs.
17:16:26 <Toxaris> build-tools: sh   would be nice for stupid windows users like myself
17:16:30 <thetallguy> we could make it so
17:16:57 <Twey> Toxaris: How can you run cabal without sh?  o.@
17:16:59 <pumpkin> http://en.wikipedia.org/wiki/Extended_real_number_line ooh, IEEE floats minus the NaN
17:17:03 <Twey> And how can you run sh on Windows?
17:17:13 <thetallguy> plusn :: [(Integer -> Integer)]
17:17:32 <augustss> But does Data.List contain enough functions that you could make any list function?  (Without using recursion or case.)
17:17:37 <Toxaris> Twey: I cannot. open a console, type "sh".
17:17:46 <thetallguy> plusn = map (+) [0..]
17:18:05 <pumpkin> augustss: with unfoldr you can pretty much do most things (in an ugly way) I think, can't you?
17:18:18 <pumpkin> most list-generating things, that is
17:18:39 <thetallguy> augustss:  I'm guessing not, but I can't think of a proof off the top of my head.
17:18:43 <augustss> pumpkin: My guess is that it does, yes.
17:19:10 <thetallguy> Hmm...
17:19:22 <augustss> But I have no proof.
17:19:52 <augustss> Any computable function, that is.  The others are tricky.
17:19:56 <Twey> Toxaris: I'm not sure I understand
17:19:59 <dolio> foldr + unfoldr should give you general recursion.
17:20:20 <Toxaris> Twey: I can not (seriously) run cabal with sh. I run sh under windows by, well, running sh.
17:20:24 <Nafai> Anyone have a good example of using encodeFile/decodeFile from Data.Binary?
17:20:33 <Toxaris> Twey: s/with/without
17:20:43 <Twey> Toxaris: I didn't think there was a sh on Windows
17:20:49 <Twey> (except Cygwin)
17:20:56 <hotaru2k3> Twey: there are several
17:21:05 <Twey> Huh
17:21:10 <Toxaris> Twey: well, it was not preinstalled
17:21:13 <dolio> I suppose it depends on what you allow yourself. For instance, tail isn't 'foldr ...' exactly if you're using the standard tuple.
17:21:17 <Twey> Obviously :)
17:21:51 <Toxaris> Twey: my approach to windows is to install nearly all of cygwin, then install cabal-install, then be happy
17:22:06 <Twey> Haha, nice approach
17:22:14 <Twey> Don't forget to cabal install that
17:22:16 <augustss> dolio: but tail is already there :)
17:22:33 <dolio> Yeah, but there might be other functions like that that aren't. :)
17:22:52 <Twey> But they can be defined in terms of tail, no?
17:22:59 <Twey> everythingButFirstTwoElements = tail . tail
17:23:00 <dolio> Like, uh, para.
17:23:07 <Twey> para?
17:23:31 <Nafai> Is there a way to make Data.Binary encode/decodeFile non-lazy?
17:23:33 <dolio> para f z [] = z ; para f z (x:xs) = f x xs (para f z xs)
17:23:45 <augustss> Can we agree that any list function can be defined in terms of null, head, tail and fix?
17:24:43 <augustss> and operations on other basic types if they are involved
17:24:44 <dons> Nafai: yes, force the result
17:25:34 <augustss> So we just need to encode fix with the Data.List functions.
17:25:40 <dolio> Seems likely. Those and the list constructors.
17:25:46 <Twey> Like so many Haskell functions, para looks deceptively simple, yet I suspect it to be quite powerful
17:25:57 <augustss> dolio: user, cons and nil too
17:26:10 <augustss> s/user/sure/
17:26:35 <Nafai> dons: I'm not sure how you mean?  In this function: http://gist.github.com/64935
17:27:03 <Toxaris> Twey: para looks like the old (foldr over tails) trick
17:27:18 <dolio> Twey: Anyhow, you can't write para as foldr directly. Instead you write a fold that computes (para f z xs, xs), and project out the first component.
17:27:44 <Twey> 'project'?
17:27:51 <dolio> fst
17:27:54 <Twey> Ah
17:31:37 <dolio> @type let dup x = (x,x) in foldr id undefined . unfoldr (Just . dup)
17:31:39 <lambdabot> forall b. (b -> b) -> b
17:31:50 <dolio> @type let dup x = (x,x) in foldr id undefined . unfoldr (Just . dup) $ (1:)
17:31:52 <lambdabot> forall t. (Num t) => [t]
17:31:57 <dolio> > let dup x = (x,x) in foldr id undefined . unfoldr (Just . dup) $ (1:)
17:31:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:32:38 <Toxaris> @type \f z xs -> foldr (uncurry f) z (zip xs (tails xs))
17:32:39 <lambdabot> forall a b. (a -> [a] -> b -> b) -> b -> [a] -> b
17:33:06 <Axman6> > tails [1..5]
17:33:08 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
17:34:01 * Axman6 still finds that annoying
17:34:14 <Toxaris> what?
17:34:48 <Axman6> well, [1,2,3,4,5] isn't a tail of [1,2,3,4,5]
17:36:05 <Toxaris> so how should it be called?
17:36:38 <ozy`> @let sonic = tail . tails
17:36:41 <lambdabot>  Defined.
17:36:59 <ozy`> so... I got an e-mail today about haskell support in textmate
17:37:33 <thetallguy> Axman6: think of it as all splits of a list, at [0..n]
17:38:04 <Axman6> well, it doesn;t follow on from tail, which it implies it should
17:38:15 <ozy`> > sonic [1..5]
17:38:16 <Axman6> so you often have to write things like drop 1 . tails
17:38:17 <lambdabot>   [[2,3,4,5],[3,4,5],[4,5],[5],[]]
17:38:24 <Axman6> > sonic []
17:38:26 <lambdabot>   []
17:38:29 <ozy`> D:
17:38:33 <Axman6> o.O
17:38:38 <ozy`> > tails []
17:38:41 <lambdabot>   [[]]
17:38:44 <Axman6> ah right
17:38:46 <ozy`> ohhhhh
17:38:48 <ozy`> cool
17:38:58 <Axman6> i guess tail . tails is safe then
17:39:10 <ozy`> > tails . sonic $ cycle "desu"
17:39:12 <lambdabot>   [["esudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesud...
17:40:12 <Axman6> sorry if this is incredibly ignorant, but what is this desu thing anyway?
17:41:17 <ozy`> a popular 4chan meme
17:41:23 <ozy`> don't worry about it too much
17:44:04 <Svrog> are functions first . const and second . const defined somewhere already?
17:44:11 <ozy`> (Axman6: in case your curiosity persists, I have procured this reenactment of the popularizing incident: http://www.rsmw.net/shot/desu_live_action.gif )
17:44:50 <Axman6> o.O
17:45:00 <Axman6> :t first . const
17:45:02 <lambdabot> forall b d a. a -> (b, d) -> (a, d)
17:46:35 <PeteS> is the "real world haskell" book somewhere available as pdf?
17:46:50 <Axman6> not as PDF, but html, uoer
17:46:54 <Axman6> sure*
17:47:05 <PeteS> for download?
17:47:07 <Axman6> that was an excellent typo
17:47:10 <PeteS> hehe
17:47:13 <Axman6> well, you could script it
17:47:26 <Axman6> or you could just buy the book ;)
17:47:36 <PeteS> =)
17:48:06 <redditbot> FS: MaybeT - The CPS Version
17:48:16 <znutar> In my case I have the book but I sometimes wish I had a pdf copy to put on my ebook reader and save 3 or 4 pounds of paper in my bag
17:52:54 <ozy`> znutar: if you have the print copy, can't you download an ebook of it for free?
17:54:56 <znutar> ozy`: I haven't really looked into it since I assumed it would involve paying for it again.  Does O'Reilly give that stuff away?
17:55:04 <ozy`> I forgot
17:55:09 <ozy`> lemme go find my print copy
17:55:35 <ozy`> I haven't even opened it since I really got comfortable with hacking away on arbitrary code
17:58:09 <ozy`> okay, the last page of mine says that the Safari version -is- free, but only lasts 45 days
17:58:46 <SamB> arg, emacs keeps aborting when I start it in X ...
18:07:09 <eli_> ozy`: you mentioned getting an email about textmate and haskell?
18:07:16 <ozy`> eli_: yeah. was that you?
18:07:18 <ozy`> I replied
18:07:20 <eli_> no
18:07:24 <jpone>  '<
18:07:38 <jpone> no
18:07:41 <eli_> i've been trying to find a decent package
18:07:59 <ozy`> I have SVN access to the bundle now
18:08:00 <eli_> though i've gotten pretty comfortable with vi over the years
18:08:00 <jpone>  
18:08:09 <jpone>  
18:08:09 <jpone>  
18:08:09 <jpone>  
18:08:09 <jpone>  
18:08:09 <jpone>  
18:08:09 <jpone>  
18:08:11 <jpone>  
18:08:13 <jpone>  
18:08:15 <jpone>  
18:08:17 <jpone>  
18:08:19 <jpone>  
18:08:19 <dolio> @where ops
18:08:19 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
18:08:20 <Axman6> jpone: ...
18:08:21 <jpone>  
18:08:23 <jpone>  
18:08:25 <jpone>  
18:08:27 <jpone>  
18:08:29 <jpone>  
18:08:31 <jpone>  
18:08:33 <jpone>  
18:08:35 <jpone>  
18:08:37 <jpone>  
18:08:39 <jpone>  
18:08:41 <jpone>  
18:08:42 <pumpkin> uh
18:08:43 <jpone>  
18:08:44 <ozy`> jpone: desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu
18:08:45 <jpone>  
18:08:47 <jpone>  
18:08:49 <koeien> this is pointfree
18:08:49 <jpone>  
18:08:51 <jpone>  
18:08:53 <jpone>  
18:08:55 <jpone>  
18:08:56 <ozy`> this is wreaking havoc with my IRC client
18:08:57 <jpone>  
18:08:57 <Axman6> jpone--
18:08:58 <Nafai> koeien: pointless, actually :)
18:08:59 <jpone>  
18:09:01 <jpone>  
18:09:03 <jpone>  
18:09:04 --- mode: ChanServ set +o dibblego
18:09:05 <jpone>  
18:09:05 <koeien> Nafai: i know :)
18:09:08 <jpone>  
18:09:08 <pumpkin> yay
18:09:08 <Nafai> :)
18:09:08 --- kick: jpone was kicked by dibblego (dibblego)
18:09:14 <Axman6> @karma jpone
18:09:15 <lambdabot> jpone has a karma of -1
18:09:25 <pumpkin> @karma Axman6
18:09:25 <lambdabot> Axman6 has a karma of 5
18:09:28 <ozy`> eli_: anyway I'm gradually improving the textmate bundle. I really wanna know what people think of it with my recent patches
18:09:35 --- mode: dibblego set -o dibblego
18:09:44 * Axman6 things that lambdabot should decrease karma when stuff like that happens
18:09:51 <ozy`> I have a handful of additional improvements in mind, but I dunno if people really care
18:09:52 <eli_> ozy`: is there a gz of it?
18:09:56 <Axman6> thanks dibblego
18:10:21 <SamB> Axman6: lambdabot is too forgetful for that to be at all effective
18:10:24 <ozy`> eli_: no. the TM manual actually tells you the exact instructions for installing bundles, and happens to use the haskell bundle as an example
18:10:25 <ozy`> http://manual.macromates.com/en/bundles#installing_a_bundle
18:10:51 <Axman6> SamB: hmm, yeah i guess it would be
18:10:56 <Axman6> it*
18:11:03 <Axman6> wait, scratch that
18:11:34 <jpone> yeaaaaaaaaaaahhhhhhhhhhhhhhh
18:11:34 <jpone>  
18:11:34 <jpone>  
18:11:34 <jpone>  
18:11:34 <jpone>  
18:11:35 <jpone>  
18:11:37 <jpone>  
18:11:39 <jpone>  
18:11:41 <jpone>  
18:11:43 <jpone>  
18:11:44 --- mode: ChanServ set +o dibblego
18:11:45 <jpone>  
18:11:47 --- mode: dibblego set +b *!i=jpgunitg@*.238-130-66.mc.videotron.ca
18:11:52 <ozy`> jpone: dude what the stuff
18:12:09 <eli_> someone let me know if jpone ever becomes sane.
18:12:17 <eli_> is /ignored now
18:12:19 <ozy`> eli_: he's b&
18:12:43 <eli_> like /b/?
18:13:04 <eli_> oh, banned
18:13:16 <eli_> i read that as bet
18:13:16 <alatter> maybe also /b/ ...
18:13:23 <ozy`> hahaha
18:13:25 <Axman6> heh
18:13:33 <eli_> either bet or bamp
18:13:34 <ozy`> sorry, anglocentricism :p
18:14:02 <eli_> naah it's my own personal typographical obsession
18:14:56 <eli_> so i just started learning haskell yesterday
18:15:20 <eli_> I'm enjoying it a lot more than other languages
18:15:27 <eli_> and this nick is bothering me
18:16:04 <Axman6> i started learning haskell just under a year ago, and fell in love. now ,my blog's even on planet.haskell.org :)
18:16:42 <lowmagnet> Yes, it may be love for me too
18:16:52 <ozy`> haskell is wicked nifty, yeah
18:17:04 <ray> haskell's great, but blogging about it?
18:17:26 <Valodim> ..uh, yeah? people mostly blog about stuff they consider great
18:17:39 <hydrapheetz> Haskell still warps my mind
18:17:42 <lowmagnet> well haskell bloggers are more about lambda calculus and category theory than wang waving
18:17:43 <Axman6> all the cool kids blog about haskell
18:18:10 <Axman6> i don't blog about theory, i don't know enough about it to do so :P
18:18:19 <lowmagnet> of course lambda calculus and category theory give me a headache since i know very lille about both
18:18:49 <lowmagnet> I can code in lambdaMOO, does that count? It has tuples :)
18:19:13 <lowmagnet> but the blogs tend to be helpful
18:19:33 --- mode: dibblego set -b *!i=jpgunitg@*.238-130-66.mc.videotron.ca
18:19:37 <ray> just read academic papers and imagine they're blog entries
18:20:07 <hydrapheetz> :t reverse
18:20:08 <lambdabot> forall a. [a] -> [a]
18:21:46 <lowmagnet> Why do folks ask the bot questions GHCi and hugs can answer?
18:22:01 <ray> because they're in their irc clients, probably
18:22:14 <Zao> lowmagnet: Because they haven't realized that, or they don't know that lambdabot serves privately too?
18:23:32 <hydrapheetz> :(
18:23:34 <Adamant> :t slide
18:23:36 <lambdabot> Not in scope: `slide'
18:23:38 <ozy`> lowmagnet: sometimes they speculate that others might be intrigued or amused by whatever they're working on
18:23:50 <Adamant> other times they're just trying to be funnay
18:24:01 <ozy`> lulz
18:24:52 <lowmagnet> Well i've been putting stuff into GHCi to see how long it would take to do things. Did 12345^50000 as a test
18:25:02 <lowmagnet> it took a while but it didn't lose its cool.
18:25:21 <dolio> > 12345^50000
18:25:23 <lambdabot>   358685150680482492742961852202311354121718163113611806718192953899125174176...
18:25:33 <lowmagnet> it's at least smart enough to stop there
18:26:24 <Philonous> Doesn't lambdabot compile the expression to native code?
18:26:54 <ozy`> I believe so
18:27:16 <pumpkin> it uses mueval
18:27:54 <lowmagnet> so it's sandboxed
18:28:01 <pumpkin> which doesn't really compile to native code afaik
18:28:03 <pumpkin> http://code.haskell.org/mubot/mueval/README
18:29:14 <hotaru2k3> > let primes = 2:3:5:filter (\n -> all ((0/=) . mod n) $ takeWhile (<=(ceiling . sqrt $ fromIntegral n)) primes) [7,9..] in primes !! 10000
18:29:17 <lambdabot>   104743
18:30:24 <lowmagnet> Yeah, parts of that make sense to me, the rest is line noise ;)
18:30:57 <lowmagnet> I've got much reading to do. I ordered real world haskell from a-z a bit a go.
18:31:39 <hydrapheetz> :t (/=)
18:31:40 <lambdabot> forall a. (Eq a) => a -> a -> Bool
18:31:45 <hydrapheetz> hum.
18:33:13 <Philonous> > nubBy (\x y -> y `mod` x == 0) [2..]
18:33:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:33:49 <hotaru2k3> let primes = nubBy (\x y -> y `mod` x == 0) [2..] in primes !! 10000
18:33:57 <hotaru2k3> > let primes = nubBy (\x y -> y `mod` x == 0) [2..] in primes !! 10000
18:33:59 <Ralith> @src nubBy
18:33:59 <lambdabot> nubBy eq []             =  []
18:33:59 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:34:13 <lambdabot>   thread killed
18:34:51 <hotaru2k3> "nubBy (\x y -> y `mod` x == 0) [2..]" doesn't work
18:35:08 <Philonous> It does, it's just rather slow
18:35:22 <pumpkin> it's O(inf)
18:36:19 <Philonous> pumpkin: For the whole list. yes.
18:36:21 <hotaru2k3> makes things that need to finish in minutes take hours == doesn't work
18:37:31 <ozy`> hotaru2k3: so in other words, it's O(too damn big)
18:37:50 <hotaru2k3> ozy`: exactly
18:39:02 <pumpkin> it's actually O(inf^2)
18:39:37 <wli> > let sieve m ~(n:ns) = case minViewWithKey m of { Just ((k, ps), m') | n == k -> sieve (unionWith (++) m' $ fromListWith (++) [(k + p, [p]) | p <- ps]) ns ; _ -> n : sieve (insertWith (++) (n*n) [n] m) ns } in take 10 $ sieve empty [2..]
18:39:41 <lambdabot>   Not in scope: `minViewWithKey'Not in scope: `unionWith'Not in scope: `fromL...
18:40:40 <hydrapheetz> That looks like line noise to me D:
18:40:42 <Philonous> hotaru2k3: There is a comparatively fast implementation of the Sieve of Eratosthenes on literate programms, but I can't reach the site atm
18:41:28 <ozy`> hydrapheetz: it contains a multi-line definition collapsed into a single line
18:41:45 <hydrapheetz> I'm still kind of new to haskell
18:41:53 <hotaru2k3> Philonous: yeah, i figured there was probably one there but couldn't reach the site about a week and a half ago
18:42:02 <wli> lambdabot's broken and can't use Data.Map functions even when qualified with M. anyway.
18:42:32 <hackage> Uploaded to hackage: filestore 0.2
18:42:32 <hackage> Uploaded to hackage: pqueue-mtl 1.0.1
18:42:32 <hackage> Uploaded to hackage: stateful-mtl 1.0.1
18:44:25 <ferret_0567> how do I get a certain element from a list?
18:44:44 <pumpkin> ferret_0567: !!
18:44:49 <pumpkin> > [1..10] !! 2
18:44:53 <lambdabot>   3
18:44:53 <ferret_0567> pumpkin: that acts weird when using show
18:44:55 <pumpkin> but it's O(n) so be careful
18:45:15 <ozy`> > "THE PRESIDENT OF THE UNITED STATES OF AMERICA" !! 12
18:45:17 <lambdabot>   'T'
18:45:25 <pumpkin> ferret_0567: ?
18:45:39 <ozy`> ferret_0567: define "acts weird"
18:45:54 <ferret_0567> ozy`: it can print [, ], or ','
18:46:02 <ferret_0567> > putStrLn (show [1..10] !! 1)
18:46:04 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
18:46:11 <pumpkin> that's because a char isn't a string
18:46:29 <pumpkin> or because your precedence is wrong
18:46:43 <pumpkin> > putStrLn (show ([1..10] !! 1))
18:46:45 <lambdabot>   * Exception: "<IO ()>"
18:46:52 <pumpkin> if course IO doesn't work here :)
18:47:04 <pumpkin> > text (show ([1..10] !! 1))
18:47:06 <lambdabot>   2
18:47:08 <ozy`> > show ([1..10] !! 2) -- ferret_0567, did you mean to do this?
18:47:10 <lambdabot>   "3"
18:47:13 <ferret_0567> > print (show [1..10] !! 1)
18:47:15 <lambdabot>   * Exception: "<IO ()>"
18:47:17 <ferret_0567> oh
18:47:27 <pumpkin> > text (show [1..10] !! 1)
18:47:29 <ozy`> ferret_0567: lambdabot won't perform IO
18:47:31 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
18:47:32 <ferret_0567> well, why does show alone work?
18:47:34 <pumpkin> > text . return (show [1..10] !! 1)
18:47:36 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
18:47:39 <pumpkin> > text . return $ (show [1..10] !! 1)
18:47:41 <lambdabot>   1
18:47:51 <pumpkin> :P
18:48:07 <redditbot> haskelldb, and categorising the Haskell database suite
18:48:11 <pumpkin> > text . return $ (show [1..10] !! 0)
18:48:12 <ozy`> ferret_0567: because it returns a string without performing any IO actions
18:48:13 <lambdabot>   [
18:48:21 <alatter> :t text
18:48:23 <lambdabot> String -> Doc
18:48:50 <wli> pumpkin: pumpkinbot has trouble using lib functions from Data.Map as well.
18:48:52 <ferret_0567> show [1..10] !! 1
18:49:00 <Axman6> > text "one\ntwo\nthree"
18:49:02 <lambdabot>   one
18:49:02 <lambdabot>  two
18:49:02 <lambdabot>  three
18:49:14 <ferret_0567> > show [1..10] !! 1
18:49:15 <lambdabot>   '1'
18:49:28 <ferret_0567> > show [1..10] !! 0
18:49:28 <Axman6> :t show [1..10] !! 1
18:49:30 <lambdabot>   '['
18:49:31 <lambdabot> Char
18:49:36 <ferret_0567> see that?
18:49:36 <Axman6> :t show ([1..10] !! 1)
18:49:37 <pumpkin> wli: I can check its mueval import list later
18:49:37 <ozy`> ferret_0567: you should know that function application has a higher precedence than any operator
18:49:38 <lambdabot> String
18:49:48 <ferret_0567> ozy`: ok, noted
18:50:00 <sereven> > show [10..] !! 1
18:50:02 <lambdabot>   '1'
18:50:12 <sereven> > show $ [10..] !! 1
18:50:13 <lambdabot>   "11"
18:50:23 <Axman6> ferret_0567: do you see the difference between shwo [1..10] !! 1 and show ([1..10] !! 1)?
18:50:47 <ozy`> (ferret_0567: ie. if you write "show [blah] !! x", it gets evaluated as "(show [blah]) !! x" instead of "show ([blah] !! x)")
18:50:50 <Axman6> show*
18:50:59 <ferret_0567> Axman6: yes
18:51:28 <Axman6> > show [1..10]
18:51:31 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10]"
18:51:37 <ferret_0567> Axman6: now it works right
18:52:54 <Axman6> ferret_0567: the thing to remember is that function appication always has higher precidence than infix functions
18:53:12 <Axman6> so you can say f x y = sqrt x ^ sqrt y
18:53:15 <ozy`> ferret_0567: the ($) operator is useful for splitting up multiple function and operator applications without resorting to parentheses.... "f $ x" means the same as "f x," but ($) has a very low precedence, so "x" can be almost anything
18:53:22 <ferret_0567> now I have to implement the lastButOne function using functions that I learned in the Real World Haskell book so far
18:53:46 <pumpkin> explicit recursion?
18:53:46 <Axman6> so lastButOne [1..10] would give 9?
18:53:51 <ferret_0567> ozy`: sweet
18:53:54 <ferret_0567> Axman6: yes
18:54:04 <pumpkin> ferret_0567: how about lastButOne [1] ?
18:54:08 <pumpkin> or lastButOne []
18:54:24 <Axman6> error i guess
18:54:37 <pumpkin> I think it should return random uninitialized memory
18:54:49 <Axman6> me too
18:55:58 <ferret_0567> Axman6: no, I will use the length function to check the length of the list and throw an exception if it is too small
18:56:51 <ferret_0567> or, rather, I'll just return nothing, since I haven't learned exceptions yet...
18:57:17 <Axman6> what do you mean return nothing?
18:57:25 <ferret_0567> Axman6: return an empty list
18:57:25 <ozy`> you can't just return nothing
18:57:29 <ozy`> oh
18:57:42 <ozy`> ferret_0567: will the argument be a list of lists?
18:57:45 <Axman6> ferret_0567: so, lastButOne [1..10] will return [9] then?
18:57:50 <ferret_0567> ozy`: possibly
18:58:20 <Axman6> because that won't typecheck if it it can return either [] or 9
18:58:28 <ozy`> ferret_0567: if you return an empty list in one branch of the function, you have to return a list of some kind in all other branches, too
18:58:54 <ferret_0567> ozy`: ok
18:59:00 <ozy`> if you want to be able to "return null," then make it return a Maybe value
18:59:13 <ozy`> "Just x" for non-null values... "Nothing" for null
18:59:15 <roconnor> > let (x,y) = ("let (x,y) = (",") in (text x++show x++\",\"++show y++y)") in text (x++show x++","++show y++y)
18:59:17 <lambdabot>   let (x,y) = ("let (x,y) = (",") in (text x++show x++\",\"++show y++y)") in ...
18:59:17 <ferret_0567> ozy`: I have not learned about Maybe yet
18:59:25 <roconnor> bah
18:59:30 <ozy`> ferret_0567: that's okay, you'll see it soon
18:59:58 <ozy`> :t foldr (>>=)
19:00:00 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
19:00:00 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
19:00:00 <lambdabot>     In the first argument of `foldr', namely `(>>=)'
19:00:01 <wanghorn> what about using pattern matching so your function only matches non-empty arrays?
19:00:02 <sereven> at this point, no pattern matching or Maybe yet, iirc, but this problem is great for motivating them
19:00:04 <ozy`> D:
19:00:08 <Axman6> :o
19:00:10 <ferret_0567> ozy`: Although, I don't think they want me to implement support for lists-of-lists in this function. Do you think they want me to do that?
19:00:20 <ozy`> ferret_0567: no, I don't think so.
19:00:30 <ferret_0567> ozy`: ok then
19:00:38 <Axman6> :t foldr (=<<)
19:00:41 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
19:01:02 <ferret_0567> ozy`: that makes it relatively simple, the function should be finished in a few minutes
19:01:20 <ozy`> ferret_0567: the other option available to you is to use "undefined" (or error "whoops") for a return value
19:01:21 <Axman6> ferret_0567: which list functions do you know about?
19:01:42 <Axman6> @src undefined
19:01:42 <lambdabot> undefined =  error "Prelude.undefined"
19:02:17 <wanghorn> > head []
19:02:19 <lambdabot>   * Exception: Prelude.head: empty list
19:02:19 <ozy`> didn't undefined have a recursive definition in some version of the Prelude?
19:02:30 <Axman6> the gopher one did
19:02:36 <ferret_0567> Axman6: drop, tail, and head
19:02:36 <ddarius> undefined | False = undefined
19:02:49 <ferret_0567> Axman6: oh yeah, almost forgot, and length
19:02:57 <Axman6> ferret_0567: no init?
19:03:03 <ferret_0567> Axman6: nope
19:03:10 <Axman6> lamw :(
19:03:12 <Axman6> -e*
19:03:12 <ozy`> init is easy enough to implement
19:03:28 <ddarius> init is a cruddy function
19:03:29 <Axman6> lastButOne = last . init
19:04:20 <Axman6> > last . init $ [1..10]
19:04:22 <lambdabot>   9
19:04:26 <Axman6> > last . init $ [1]
19:04:28 <lambdabot>   * Exception: Prelude.last: empty list
19:04:42 <Axman6> @src error
19:04:42 <lambdabot> error s = throw (ErrorCall s)
19:04:48 <Axman6> :t throw
19:04:50 <lambdabot> Not in scope: `throw'
19:04:54 <Axman6> :(
19:05:13 <Axman6> :t Control.Exception.throw
19:05:14 <lambdabot> forall a. GHC.IOBase.Exception -> a
19:09:19 <Svrog> how would one go about finding a substring in a lazy bytestring? by converting it to a strict bytestring first and using findSubstring? or is there a better way?
19:09:34 <ozy`> man, this damn iphone SDK is taking forever to download
19:09:46 * ozy` goes to do something else for the next hour
19:11:08 <ferret_0567> > last . init $ [1,2,3]
19:11:10 <lambdabot>   2
19:12:04 <ferret_0567> :t last
19:12:06 <lambdabot> forall a. [a] -> a
19:12:28 <ferret_0567> :t init
19:12:29 <lambdabot> forall a. [a] -> [a]
19:13:23 <Axman6> > init [1..10]
19:13:25 <lambdabot>   [1,2,3,4,5,6,7,8,9]
19:13:35 <Axman6> > iterate init [1..10]
19:13:37 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8],[1,2,3,4,5,6,...
19:13:42 <Axman6> > iterate init [1..5~]
19:13:44 <lambdabot>   <no location info>: parse error on input `]'
19:13:45 <Axman6> > iterate init [1..5]
19:13:47 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1],[],* Exception: Prelude.init: empt...
19:14:11 <ferret_0567> if the list length is 3, do you think I should just return the last item in the list or should I just return a empty list?
19:14:32 <Axman6> eh?
19:14:45 <ferret_0567> nvm
19:20:30 <ferret_0567> what is the type for list?
19:20:42 <Axman6> [a]?
19:21:31 <ferret_0567> ok then, I didn't know [a] meant the whole list
19:21:41 <Axman6> as a type it does
19:21:47 <ferret_0567> I thought it meant a single item in the list
19:21:51 <Axman6> it means a list containing a's
19:21:58 <Axman6> it can also mean that too
19:22:21 <ferret_0567> :t []
19:22:23 <lambdabot> forall a. [a]
19:22:29 <Saizan> ferret_0567: the notation "[a]" is quite overloaded
19:22:29 * ferret_0567 uses []
19:22:43 <ferret_0567> Saizan: I can see that
19:23:13 <Axman6> ferret_0567: you can say '[] a' as well when talking about the type of a list
19:23:37 <Axman6> ferret_0567: also [x] is shorthand for (x:[])
19:23:46 <Axman6> girly monkey face
19:24:04 <Axman6> > [x] == (x:[])
19:24:06 <lambdabot>   True
19:24:16 <Axman6> > [x,y] == (x:y:[])
19:24:18 <lambdabot>   True
19:25:59 <wli> Prolog does it with [X|[Y|T]] or some such, which is a little less ambiguous.
19:26:02 * Axman6 just found this on hackage: http://blog.codeslower.com/static/CheatSheet.pdf
19:28:01 <ferret_0567>     Couldn't match expected type `[a]'
19:28:01 <ferret_0567>            against inferred type `[a1] -> [a1]'
19:28:01 <ferret_0567>     In the first argument of `head', namely `(drop (length xs - 2))'
19:28:03 <ferret_0567> what?
19:28:07 <ferret_0567> I don't get it
19:28:32 <Axman6> drop (length xs - 2) xs
19:28:42 <ferret_0567> oh
19:28:48 <ferret_0567> I forgot that last bit...
19:28:58 <ferret_0567> crud, how could I forget that?
19:29:09 <Axman6> easily, you're still learning :)
19:29:14 <Axman6> everyone does it
19:30:01 <ferret_0567> Axman6: and that makes no difference
19:30:08 <ferret_0567> Axman6: notice that it says first argument
19:30:24 <Axman6> what is the whole piece of code?
19:30:24 <ferret_0567> oh
19:31:29 <dolio> > let xs = [1..10] in head (drop (length xs - 2) xs)
19:31:31 <lambdabot>   9
19:31:55 <dolio> > let xs = [1..10] in last . init $ xs
19:31:58 <lambdabot>   9
19:32:31 <Saizan> > let xs = [1..10] in reverse xs !! 1
19:32:33 <lambdabot>   9
19:33:02 <ferret_0567> @hpaste
19:33:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:33:06 <jml> RWH is very good btw. Am glad I bought the hard copy.
19:33:16 <Axman6> yep :)
19:34:45 <hotaru2k3> http://hpaste.org/new is 404
19:35:03 <rwbarton> Just use http://hpaste.org
19:35:04 <Axman6> hey, it's using hpaste2 now
19:35:11 <hotaru2k3> (should be http://hpaste.org/fastcgi/hpaste.fcgi/new i think)
19:35:16 <Axman6> the @hpaste link needs to be updated
19:35:47 <Axman6> and that url could do with some rewriting/aliasing
19:36:08 <lepassive> join #python
19:36:17 <Axman6> no :O
19:36:29 <lepassive> sorry haha
19:36:42 <lepassive> Is there any ORM solution around haskell world ?
19:36:43 <Axman6> :P
19:37:38 <ferret_0567> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1431#a1431
19:38:02 <Axman6> ferret_0567: that won't type check
19:38:12 <Axman6> you can't return a list of an a
19:38:29 <Axman6> actually, it will typecheck, but it'll only work for [[a]]
19:38:41 <ferret_0567> Axman6: wow, that's an odd twist
19:38:50 <ferret_0567> Axman6: well, what should I return then?
19:39:03 <Axman6> you should use error
19:39:22 <ferret_0567> Axman6: I know, but that is for later, not now
19:39:29 <ferret_0567> Axman6: I'm trying to follow my book
19:39:43 <Axman6> well, it's pretty much what you need to use
19:40:10 <ferret_0567> what should I return then?
19:40:18 <lispy> :t error
19:40:20 <lambdabot> forall a. [Char] -> a
19:40:28 <Axman6> there is nothing that you can return apart from error or undefined
19:40:50 <lepassive> ferret_0567, are you trying to return the before *last* element ?
19:40:51 <BMeph> ferret_0567: Also, did you notice that if 'length xs' is 3, then 'length xs - 2' is 1, in other words, your second if statement there is redundantly repetetive. Over again. ;p
19:41:29 <Axman6> lepassive: yeah, it's a RWH exercise
19:41:53 <ferret_0567> BMeph: oh...
19:41:56 <ferret_0567> crud
19:41:56 <lispy> Not only is it redundantly repetitive and over again, but it's unnecessary because it's not needed
19:42:24 * lispy is being mean :)
19:42:32 <hackage> Uploaded to hackage: data-spacepart 20090215.0
19:42:32 <hackage> Uploaded to hackage: spacepart 0.1.0.0
19:42:46 <Axman6> "Not only is it redundantly repetitive and over again, but it's unnecessary because it's not needed" self describing sentense :O
19:42:58 <lispy> Axman6: totally
19:43:02 <Axman6> well,t he last part at least
19:43:08 <Ralith> Axman6: also gramatically incorrect!
19:43:12 <Axman6> well done :)
19:43:21 <lispy> ferret_0567: Have you met the Maybe data type?
19:43:49 <ozy`> lispy: he said earlier that he hadn't
19:44:00 <ferret_0567> why can't I return a1...?!?!
19:44:02 <ferret_0567> I don
19:44:07 <lispy> ferret_0567: I would also like to introduce you to pattern matching
19:44:08 <ferret_0567> I don't see why I can't
19:44:10 <Ralith> because you use too much punctuation
19:44:19 <Axman6> ferret_0567: well, where are you going to get that a from?
19:44:33 <lepassive> why not implement it like that ? Prelude> last $ fst $ splitAt (length l -1) l
19:44:34 <lepassive> 21
19:44:35 <ferret_0567> Axman6: from inside my function
19:44:47 <Axman6> ferret_0567: you could return 1,  but then it wouldn't work with ['a'..'z'] woul it
19:44:50 <Axman6> would it*
19:45:47 <ferret_0567> Axman6: I have no idea if it work work with ['a'..'z'] or not
19:45:56 <ferret_0567> s/work/would/
19:46:06 <Axman6> well 1 a character?
19:46:10 <Axman6> or Char?
19:46:16 <lispy> > '1'
19:46:19 <lambdabot>   '1'
19:46:22 <lispy> Yeah, it's a Char :)
19:46:27 <Axman6> '1' is
19:46:38 <Axman6> but then the function won't work with [1..10] any more
19:46:53 <lepassive> ferret_0567, and isn't !! an option ? you can always retrieve the before (length) element ?
19:47:24 <ozy`> ferret_0567: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1431#a1432 <- you don't have to write functions this way but you'll see this style used later in the book
19:48:07 <redditbot> Comparison of type families and functional dependencies
19:48:11 <ferret_0567>  Couldn't match expected type `Char' against inferred type `[a]'
19:48:13 <ferret_0567> lepassive: yes
19:48:36 <Axman6> ozy`: that won't typecheck for the given type either
19:48:39 <lispy> redditbot: what about them?
19:48:43 <Axman6> it'll only work for [[a]] -> [a]
19:48:54 <lepassive> ferret_0567, then i guess l !! (length l -2) will just cut it
19:49:11 <ozy`> Axman6: all I meant to do was show him the syntax
19:49:20 <dolio> Hey lambdabot, get a load of lispy talking to irc bots!
19:49:30 <ferret_0567> lepassive: I don't think I have learned !! in the book yet, although I already know it
19:49:42 * lispy wonders why we have a redditbot
19:49:45 <Axman6> > text "lawl dolio"
19:49:47 <lambdabot>   lawl dolio
19:50:08 <lepassive> ferret_0567, okay sorry, what about last $ fst $ splitAt (length l -1) l   ?
19:50:23 <ferret_0567> lepassive: I have not learned $ in the book yet either
19:50:30 <ferret_0567> so...I think I'm screwed
19:50:48 <Axman6> last ( fst (splitAt (length l - 1)  l))
19:50:51 <lispy> Not screwed, just temporarily ignorant.  We'll get you up to speed thouh.
19:50:55 <lepassive> ferret_0567,  $ mean "put on hold until the right side is evaluated"
19:51:10 <Axman6> not really
19:51:41 <ferret_0567> The problem is I want to follow what is available where I am at in the book
19:51:44 <sjanssen> lepassive: ($) is not strict in its second argument
19:51:47 <ferret_0567> what the book has taught me so far
19:52:03 <Axman6> ferret_0567: you're hampering your learning i think
19:52:11 <Axman6> take every opportunity to learn you can
19:52:17 <ferret_0567> oh, ok then
19:52:36 <ferret_0567> then I'll use !!
19:52:42 <lispy> ferret_0567: so, do you understand the problem with returning a normal value when the list is too short?
19:52:43 <lepassive> ferret_0567, the best way before venturing RWH is http://learnyouahaskell.com/ I'm doing it that way really
19:53:19 <lepassive> sjanssen, hmm which is stricter f . g x or f $ g x ?
19:53:36 <ferret_0567> lepassive: I don't like learnyouahaskell.com
19:53:47 <ferret_0567> lepassive: it has no exercises, it seems
19:54:10 <Axman6> ferret_0567: you're supposed to write the code that's written though, to practice using it
19:54:19 * Axman6 always hated exercises in books
19:54:32 <ferret_0567> Axman6: well, I can do that later, I'm sure
19:54:35 * lispy always hated.
19:54:46 <lepassive> ferret_0567, oh shame on you. BONUS has put alot of effort on it.
19:54:52 <BMeph> lepassive: You do know that those are two different values, right? :)
19:55:23 <lepassive> BMeph, isn't (f.g) x = f(g(x)) ?
19:55:34 <lispy> lepassive: yeah, notice the parens :)
19:55:38 <ferret_0567> lispy: yes, you will return a normal value, and the calling function will think that value was in the list that was passed to the lastButOne function
19:55:39 <Axman6> lepassive: it's no strictness that $ has to do with, it;s binding
19:56:00 <Axman6> f $ g y $ x == f (g y x)
19:56:13 <lispy> ferret_0567: there is more to it than that actually.
19:56:27 <lispy> ferret_0567: unless you know the type of 'a' how will you return a value of type a?
19:56:29 <lepassive> Oh my. still paren as in imperative lang :D
19:56:46 <Axman6> has nothing to imperative languages
19:57:23 <ferret_0567> lispy: you don't
19:57:39 <lepassive> Axman6, no I mean I'm thinking always of f of something of something...
19:57:49 <lispy> ferret_0567: then, how can you return a normal value in the first then branch?
19:58:33 <rovar> is there a recommended way to pack data into bytestrings for marshalling?
19:58:47 <rovar> i.e. ints and such
19:58:49 <ferret_0567> lispy: I don't think you can, from what your asking me
19:59:13 <Axman6> rovar: there are functions for doing that with lists, you don't need to use bytestrings
19:59:15 <lispy> ferret_0567: yeah, that's why we were talking about using either error or undefined there.  But maybe you understand that now?
19:59:35 <rwbarton> rovar: Data.Binary
19:59:39 <ferret_0567> lispy: yeah, I understand now
19:59:44 <lispy> ferret_0567: cool :)
19:59:46 <ferret_0567> lispy: is error a type?
19:59:58 <ivanm> @hoogle error
19:59:59 <lambdabot> Prelude error :: String -> a
19:59:59 <lambdabot> module Control.Monad.Error
19:59:59 <lambdabot> module Foreign.C.Error
19:59:59 <rovar> the data does need to end up in a bytestring though, using BerkeleyDB
20:00:00 <lispy> ferret_0567: error is sort of magical as far as the type goes.
20:00:09 <lispy> > error "What type will this be?"
20:00:12 <lambdabot>   * Exception: What type will this be?
20:00:12 <ivanm> > error "this is an error"
20:00:14 <lambdabot>   * Exception: this is an error
20:00:24 <lepassive> I'm wondering why there's no ORM yet available in Haskell ?
20:00:31 <ivanm> lepassive: ORM/
20:00:32 <ivanm> ?
20:00:35 <Axman6> rovar: see http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
20:00:42 <ferret_0567> what does undefined look like?
20:00:50 <Axman6> @src undefined
20:00:50 <lambdabot> undefined =  error "Prelude.undefined"
20:00:51 <ivanm> > undefined
20:00:53 <lambdabot>   * Exception: Prelude.undefined
20:00:55 <lepassive> Object relational mapper -changes the way anyone writes a database applications - ?
20:00:56 <lispy> ivanm: object relational mapping/model it's like your data base tables correspond to classes, rows are instances, etc
20:01:07 <ivanm> ahhh
20:01:27 <rovar> lepassive: entirely unnessary in haskell, IMO
20:01:29 <ferret_0567> I think I'll use Error
20:01:36 <ferret_0567> or rather, error
20:01:57 * ivanm recently proof-fread a paper by biologists about how they created a database-based website, full of buzzword acronyms like ORM and POJO :s
20:02:12 <lispy> POJO?
20:02:18 <ivanm> Plain Old Java Objects
20:02:19 <lispy> POJO is new to me
20:02:21 <lispy> oh
20:02:35 <ivanm> as in "normal" java, rather than all those add-on libraries people have developed
20:02:45 <lepassive> rovar, we all said that until the came up
20:02:59 <lepassive> they*
20:03:01 <ivanm> what's even better is that they explicitly said that.... if it were up to me, I wouldn't show off that I used "normal Java" in my program :s
20:03:16 <rovar> Java sucks, and therefore needs ORM and other tricks to attempt to make it more declaritive.
20:03:42 <rovar> ORMs also waste a tremendous amount of effort in their endeavors, too.
20:03:50 <rovar> well.. most of them
20:04:05 <lepassive> rovar, I read the database part in RWH and it uses the same way  anyone will be doing without an ORM
20:04:07 <lispy> Actually, I think haskell has an ORM
20:04:33 <lispy> At least it can statically check your database access to make sure you follow the schema
20:04:42 <lepassive> rovar, a great thing feature is that you can easily change the database
20:04:52 <ivanm> what, doesn't Haskell have enough buzzwords/acronyms of its own that we've been forced down to the level of having to borrow some from Java? :s
20:04:53 <ivanm> ;-)
20:05:15 <rovar> lepassive: that abstraction is nice. And is perfectly doable with HDBC
20:06:19 <lepassive> rovar, did i forget to mention it CRUDs the table without having to write (addPodcast/remove/Select/modify) ?
20:06:32 <ferret_0567> do you think that if I have a list with only two items in it, that since lastButOne will act like head in that case, I should make lastButOne see to it that length xs > 2 or error?
20:07:22 <lispy> Seems like, lastButOne [1,2] = 1, right?
20:07:27 <ferret_0567> yes
20:07:36 <lispy> Maybe I didn't get the question then
20:07:49 <ferret_0567> no, you've got it right
20:07:51 <rovar> lepassive: I've used ORMs extensively in ruby and python.  Unless you're dealing with a huge amount of business objects, I don't see how you'd get as much gain in Haskell, its just too easy to make accessors for your records.
20:08:02 <ferret_0567> lispy: it that case, lastButOne [1,2] == head [1,2]
20:08:32 <rovar> effectively, you could replicate ActiveRecord without ActiveRecords 1000's of lines of code :)
20:08:43 <lispy> ferret_0567: I feel like, this function will server as a more interesting exercise when you get to pattern matching
20:09:00 <lispy> ferret_0567: so, personally, I would put it aside and pick it up again when you get there :)
20:09:07 <ferret_0567> lispy: should I make it so that lastButOne errors unless length xs > 2?
20:09:15 <rovar> but I guess you could make that thin wrapper generic enough to be considered an ORM.. so there goes my argument :P
20:09:27 <lispy> ferret_0567: yes, that seems fair
20:09:58 <lispy> ferret_0567: here is an exercise.  Write lastButOne without length, head or drop :)
20:10:08 <rwbarton> ferret_0567: wait, why should it give an error when length xs == 2?
20:10:43 <rovar> lepassive: I guess my primary issue is this. We interact with SQL databases via SQL. then we spend huge amounts of efforts making our applications speak "not SQL"
20:10:55 <rovar> why not cut out the middleman and don't effing use SQL?
20:11:24 <ivanm> rovar: like what erlang does?
20:11:35 <ferret_0567> lispy: I already have head and drop gone
20:11:36 <p_l> rovar: If you have application that doesn't need relational database, don't use a relational database. Simple as that
20:11:41 <sjanssen> ivanm: or HAppS
20:11:44 <ferret_0567> rwbarton: because then lastButOne [1,2] == head [1,2]
20:11:46 <rovar> ivanm: like what it can do, sure. DETS has its limitations, but I like the idea.
20:11:52 <rwbarton> ferret_0567: ... so?
20:11:57 <Nafai> http://gist.github.com/64935 <- In this function, how do I make decodeFile non-lazy?  I've done a temporary where I print the contents of seenMap after that, but I don't want to do that
20:12:04 <rwbarton> ferret_0567: I mean, last [1] doesn't give an error, so why should lastButOne [1,2]?
20:12:35 <ivanm> sjanssen: well, I've never used HApps{,tack}, so wouldn't know (but I have read about erlang's mnesia database)
20:12:41 <rovar> p_l: Exactly, now if we can just people to understand that, in most cases, they don't need an RDBMS.
20:12:48 <Ringo48> isn't a "let ... in ..." construct an expression?
20:12:58 <ferret_0567> rwbarton: simply because lastButOne [1,2] acts like head [1,2]
20:13:03 <rovar> ivanm: I'm a big fan of Scalaris.
20:13:06 <ddarius> Ringo48: Yes.
20:13:07 <hotaru2k3> fib 1 == sqrt 1, that doesn't mean fib 1 should give an error.
20:13:10 <Ringo48> I have this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1404
20:13:29 <Ringo48> I'm getting an error "The last statement in a 'do' construct must be an expression"
20:13:35 <ivanm> rovar: never heard of it... then again, I'm not a fan of DBs in general ;-)
20:13:37 <Ringo48> when I just have a let ... in ...
20:13:51 <p_l> rovar: I usually use RDBMS (i.e. last time I had anything to do where I was the one designing database, we actually used JOINS etc in serious manner)
20:13:55 <ferret_0567> ok...I guess I'll change it to if not greater than 1, error
20:14:05 <rwbarton> Ringo48: because "in" isn't indented more than "let", "in" begins a new statement of the do block
20:14:09 <ivanm> Ringo48: in a do block, you don't use "in" for a let construct
20:14:11 <sjanssen> Nafai: !seenMap <- if hasFile
20:14:27 <ivanm> also, the last statement in a do block has to be the correct monadic type
20:14:30 <ivanm> e.g. return x
20:14:32 <rovar> p_l: did your data layout require it? sometimes it's good to denormalize.
20:14:35 <lispy> Ringo48: you could make the "let .. in" variant work there but you probably need a return in front of the let
20:14:40 <ddarius> Ringo48: Put a space before 'in' and it will work.
20:14:46 <Ringo48> rwbarton: thanks, that was it
20:15:06 <Ringo48> what I get for blindly trusting emacs to indent for me, I guess
20:15:15 <ddarius> Ringo48: Incidentally, do-notation supports a shortcut for this case.
20:15:23 <Nafai> sjanssen: Thanks!
20:15:35 <rovar> if it did, then good.. there's no escaping RDBMS' use for reporting. However for OLTP, i'd stick with key/value stores any day.
20:15:41 <ddarius> @undo do rg <- m; let f x = x; bar
20:15:41 <lambdabot>  Parse error at end of input
20:15:41 <ferret_0567> ahhhh....I like Haskell a lot already
20:15:45 <Ringo48> I see... leaving out "in" works there
20:15:54 <ddarius> @undo do rg <- m; let {f x = x}; bar
20:15:54 <lambdabot> m >>= \ rg -> let { f x = x} in bar
20:15:56 <rovar> ferret_0567, it told me it likes you too.
20:16:02 <p_l> rovar: last time I did it you could say that joins etc. recreated map/reduce in database engine, so that Ruby (which is quite slow compared to Postgres :P) only took care of displaying it
20:16:12 <lispy> ?faq Can Haskell mitigate the need for an ORM?
20:16:12 <lambdabot> The answer is: Yes! Haskell can do that.
20:16:26 <rovar> lambdabot: I agree.
20:16:28 <Ringo48> that, incidentally, emacs indents correctly
20:16:52 <Ringo48> thank you
20:17:06 <rovar> p_l: heh. interesting way to look at it :)
20:17:20 <p_l> rovar: That's what you get for playing with EXPLAIN :)
20:17:37 <ozy`> http://news.ycombinator.com/item?id=482657 <- don't you all want to be able to hack haskell from the mountaintops?
20:17:39 <p_l> Pgadmin3 makes a nice job of showing the results in tree form
20:18:18 <ferret_0567> ?faq Can Haskell destroy the Earth?
20:18:18 <lambdabot> The answer is: Yes! Haskell can do that.
20:18:20 <ferret_0567> LOL
20:18:34 <rovar> p_l: there was an interesting techtalk from a cpny called rentrak. They discussed all of their efforts to get postgres to scale to 100s billions of txns per day.
20:18:55 <ozy`> ferret_0567: someone's working on a new haskell compiler called LHC, so it's more appropriate than you realize...
20:18:59 <Ringo48> actually, I'd be happy to be doing anything on mountain tops right about now, but it's too cold and snowy to make it much fun
20:19:09 <p_l> rovar: the basic definitions could be better handled by simple text file format, however Postgres showed to be quite flexible system for analysis
20:19:22 <ferret_0567> ozy`: what's go great about LHC?
20:19:23 <lispy> ?faq Can Haskell unsafePerformMissileLaunch?
20:19:23 <lambdabot> The answer is: Yes! Haskell can do that.
20:19:33 <p_l> rovar: also, I didn't really have time to play with that :)
20:19:57 <ozy`> ferret_0567: well, LHC stands for both "Lemmih's Haskell Compiler" and "Large Hadron Collider"....
20:20:24 <ferret_0567> ozy`: what is so great about Lemmih's Haskell Compiler then?
20:20:35 <ozy`> ferret_0567: I dunno, really
20:20:41 <ozy`> I didn't say it was good
20:20:44 <ozy`> just that it exists
20:20:58 <ferret_0567> ok then...
20:21:04 <rwbarton> I believe it aims to (one day) produce much faster code than GHC
20:21:07 <lispy> Well, it's faster than GHC on some of the benchmarks.  Which means that competition could improve GHC in the long run :)
20:21:11 <ozy`> you were talking about haskell destroying the world
20:21:24 <ozy`> lispy: that'd be pretty sweet
20:21:44 <lispy> I'm entirely skeptical that it's supercompilation mode is as general as dictionary passing for type class functions
20:22:12 <lispy> I mean, we know that dictionary passing always works even if it adds run-time overhead
20:22:43 <lispy> But, the specialization of LHC might not work all the time?  In that case, does it fall back?  I hope so :)
20:23:31 <stepcut> lispy: I saw some code in LHC like this:
20:24:12 <stepcut> if canSpecialize expr then specialize expr else unsafePeformIO launchMissles
20:25:00 <lispy> stepcut: I've seen it die on sufficiently polymorphic recursion :)
20:25:11 <lispy> but, that was in JHC a few years ago
20:25:25 <lispy> and I think the person that found the example passed it on
20:26:10 <ddarius> I believe JHC/LHC uses a type passing implementation in cases that can't get statically resolved.
20:26:21 <gnut> hello all
20:26:37 <lispy> ddarius: that seems like the right thing to do
20:26:52 <rovar> i <3 Data.Binary
20:27:03 <Japsu> unsafeAccelerateParticles
20:27:24 <p_l> unsafeChangeLawsOfPhysics
20:27:35 <rovar> rwbarton: (Whichever gods you're in to) bless you and your family.
20:30:05 <jml> ?faq Can Haskell square a circle?
20:30:05 <lambdabot> The answer is: Yes! Haskell can do that.
20:30:10 <jml> just checking.
20:30:34 <gnut> anyone got ghc-6.10.1 working on the ps3 here?
20:30:57 <kmeyer> gnut: you mean on linux/ppc?
20:31:04 <kmeyer> sure, it works. interactive is broken.
20:31:08 <rovar> ?faq Can Haskell compute the Ultimate Question Regarding Life, the Universe, and Everything?
20:31:08 <lambdabot> The answer is: Yes! Haskell can do that.
20:31:28 <gnut> kmeyer: yeah
20:31:34 <gnut> kmeyer: yellow dog linux
20:31:39 <kmeyer> doesn't matter
20:31:47 <kmeyer> linux/ppc ghc 6.10.1 mostly works
20:31:51 <kmeyer> but as I said, interactive doesn't
20:32:08 <gnut> I don't need ghci
20:32:14 <gnut> but did you get it to compile?
20:32:14 <kmeyer> then it works :)
20:32:19 <lispy> ?get-shapr
20:32:20 <lambdabot> shapr!!
20:32:23 <gnut> I got fedora rpms for ghc-6.4.2
20:32:26 <lispy> He does some Ps3 stuff
20:32:30 <gnut> and the compilation of 6.10.1 dies
20:32:39 <kmeyer> gnut: why not get fedora rpms for ghc-6.10.1?
20:32:39 <gnut> it says it gets to an impossible place
20:32:45 <gnut> they have those?
20:32:47 <kmeyer> um, yes.
20:32:51 <gnut> I couldn't find those
20:32:55 <gnut> hmmm....
20:33:03 <kmeyer> fedora rawhide is on 6.10.1
20:33:08 <kmeyer> F-10 and F-9 are on 6.8.3
20:33:13 <gnut> let me check
20:33:16 <kmeyer> I don't want to know where you found 6.4.2
20:34:03 <gnut> heh
20:34:23 <gnut> forgive my linux inadequacies for finding rpms... I'm a solaris user
20:35:05 <lepassive> back. connection problems
20:35:11 <jml> gnut: rpms aren't exactly a linux-wide phenomenon
20:35:25 <kmeyer> nor is finding them challenging anymore
20:35:34 <gnut> jml: yeah... I know there are other packaging systems
20:38:23 <pumpkin> if I call writeFile on a file that already exists, it complains about it being locked
20:38:25 <pumpkin> is that normal?
20:38:54 <rovar> you probably need to open it in append mode for all processes.
20:39:02 <pumpkin> but it's just writeFile
20:39:05 <pumpkin> I don't explicitly open it
20:39:12 <pumpkin> I guess I need to do an open/write/close?
20:39:18 <pumpkin> and I don't want to append
20:39:24 <rovar> yea, unless there is a way to change the defaults.
20:39:24 <pumpkin> I just want to overwrite it if it already exists
20:39:38 <ddarius> pumpkin: Are you sure some other process isn't using the file?
20:39:39 <rovar> but if it's opened by another process that could have negative side effects
20:39:55 <shapr> lispy: ?
20:39:55 <pumpkin> ddarius: it's a file I just generated using the same program (the same call, even)
20:40:04 <pumpkin> ddarius: no one else around but me
20:40:06 <lispy> shapr: people here are discussing ghc on ps3s
20:40:17 <shapr> lispy: Jag är lite full.
20:40:33 <lispy> shapr: oh, well I still don't speak swedish
20:40:40 <shapr> tyvärr
20:41:26 <ddarius> pumpkin: How did you "generate" the file?
20:41:27 <lispy> shapr: haha, I used google translate.  I see
20:41:50 <pumpkin> ddarius: I called writeFile with a string
20:41:55 <shapr> lispy: jo, faktist
20:41:57 <pumpkin> the program ends
20:42:08 <pumpkin> then I run it again, same writeFile, same string, it says the file is locked
20:42:43 <shapr> pumpkin: Have you tried strace and lsof?
20:43:07 <stepcut> uh-oh. Is shapr drunk and talking swedish again?
20:43:19 <shapr> oj
20:44:55 <pumpkin> shapr: no trace, but I'll try with dtruss
20:45:19 <pumpkin> lsof says no one has it open
20:45:32 <pumpkin> oh I'm stupid :)
20:45:48 <pumpkin> as I'm sure you've noticed already :P
20:47:26 <shapr> pumpkin: What?
20:47:31 <shapr> pumpkin: What was it?
20:47:51 <pumpkin> I was calling my program with a wildcard that included the output file, so it would try to open both
20:47:59 <pumpkin> :)
20:48:07 <shapr> aha
20:53:55 * shapr hugs kosmikus 
20:54:50 <pumpkin> what's the simplest way to generate arbitrary xml in haskell without concating strings?
20:54:59 <shapr> HaXml?
20:59:53 <pumpkin> all those modules in it are daunting
20:59:53 <shapr> It's not terribly scary.
20:59:53 <glguy> if you are going for simple, haxml isn't it
20:59:53 <SamB> generating arbitrary XML by concatenating strings is not simple ;-P
20:59:53 <glguy> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xml
20:59:53 <SamB> well, I mean, not with arbitrary text in it
20:59:53 <pumpkin> hmm
20:59:53 <stepcut> pumpkin: the awesomest way is to use HSP
21:00:45 <stepcut> pumpkin: see this file for an example of it's awesomeness: http://patch-tag.com/publicrepos/happstack/happstack/templates/project/src/AppControl.hs
21:01:56 <pumpkin> how does that bit at the end work? :o
21:02:11 <pumpkin> or any of it actually
21:02:14 <stepcut> pumpkin: there is a pre-processer that converts it into normall haskell code
21:02:18 <pumpkin> ah :)
21:02:33 <stepcut> thats what the trhsx stuff in the OPTIONS_GHC pragma is doing
21:03:31 * stepcut goes to bed
21:04:01 <pumpkin> thanks :)
21:05:45 * rwbarton wonders whether quasiquoting could be helpful here
21:09:40 <thetallguy> rwbarton: to replace trhsx you mean?
21:14:42 <gnut> kmeyer: did you get ghc running on the ps3?
21:15:01 <gnut> I just found an rpm, but a simple print seems to give errors
21:17:09 <kmeyer> gnut: no, but I have ghc running just fine on linux/ppc.
21:17:23 <kmeyer> which is the same architecture/platform as a ps3.
21:18:40 <pumpkin> how does one use the PPUs (is that what they're called?) on a PS3?
21:18:57 <pumpkin> I mean ignoring haskell
21:20:11 <p_l> pumpkin: SPU libraries + code compiled for SPUs, or by using the code compiled for SPUs and direct access to spufs
21:21:03 <pumpkin> hmm
21:21:16 <rwbarton> thetallguy: right
21:21:41 <p_l> in first case, remember that the util library for SPU will call pthreads, in second, you have to create threads yourself, as the call required to actually start execution is a blocking one
21:21:47 <rwbarton> thetallguy: replacing the outer <% %>
21:34:34 <gnut> kmeyer: yes. you're right. I guess there are some errors with the printing to console bit
21:34:34 <erikc> the ppc rpm for ghc worked fine for me on yellow/ps3 a while back
21:34:34 <Olathe> SPUs have only one piece of code loaded at a time, which makes things much less general.
21:34:34 <Olathe> No context switching or anything.
21:34:34 <pumpkin> sounds like it'd be nice for parMap though
21:34:34 <pumpkin> on chunked input
21:34:34 <erikc> the linux plans had context-switching in the plans, i dont know if they ever delivered on it
21:34:34 <erikc> on the ps3 os they have a runtime system which does task and job scheduling
21:34:34 <erikc> its just slow, you need to dma out the whole local store
21:36:08 <p_l> erikc: I think the utility libraries allow for task management and job scheduling
21:37:17 <erikc> yup
21:38:24 <p_l> still, I believe that instead of that stupid ioctl for executing code, there should have been a simple command written to one of the files :)
21:43:10 <rovar> is there a way to namespace a record? I would like to have the same name in two different data types if possible
21:43:32 <erikc> heh, i think there was a lot of confusion over how to program that thing :), the business angle was a bit screwy
21:43:40 <pumpkin> rovar: unfortunately not easily
21:43:48 <pumpkin> so people do lame prefix namespacing :P
21:44:04 <rovar> yea, that's my current approach, not a big deal I guess.
21:44:05 <erikc> the only way to enough performance out of it to justify the cost was to go super low level, at which point you had to roll your own execution model
21:44:51 <erikc> otherwise you might as well just get an 8-way xeon and enjoy the luxuries of symmetric memory
21:49:14 <p_l> erikc: ... don't scare me with SMP, please
21:52:34 <p_l> erikc: Also, I'm only saying that this blocking ioctl is a bad idea, IMHO
21:52:48 <erikc> ah
21:54:09 <p_l> the programming model for SPUs is quite neat, though they have a little low amount of memory :)
21:58:17 <pumpkin> anything with the word synergy in it though instantly sounds like BS in my mind
21:58:21 <pumpkin> even though I know they're cool :P
21:58:30 <erikc> ?
21:58:49 <pumpkin> Synergistic Processing Elements (SPE)
21:59:03 <ferret_0567> lispy: I believe I know how to write lastButOne without using length. Make another function named length' that returns the number of elements in a list
21:59:20 <pumpkin> ferret_0567: you can do it one pass though
21:59:33 <ferret_0567> pumpkin: with a lambda function?
21:59:34 <p_l> pumpkin: I personnaly would prefer Support Processing Unit or something similar :P
21:59:46 <p_l> *personally
21:59:56 <pumpkin> p_l: yeah :P or anything but synergistic, really
22:00:07 <pumpkin> sounds like total marketing speak
22:00:35 <erikc> the Synergistic Processing Element for the Cell Broadband Engine
22:00:53 <ferret_0567> pumpkin: ?
22:01:01 <p_l> pumpkin: Unfortunately some marketroids are too powerful. And it's more of a rule than exception
22:01:06 <pumpkin> ferret_0567: yes
22:01:22 <ferret_0567> pumpkin: good
22:02:08 <ferret_0567> once I learn about lambda functions I will rewrite lastButOne to use a lambda function that performs the same operation as length
22:02:20 <pumpkin> oh not that
22:02:25 <pumpkin> I mean, you can do it without a lambda too :P
22:02:32 <ferret_0567> pumpkin: oh
22:02:46 <pumpkin> and you shouldn't need to explicitly get the length
22:03:06 <ferret_0567> pumpkin: really?
22:03:49 <pumpkin> yeah
22:03:52 <ferret_0567> pumpkin: is there anything like Python's [-2] list indexing syntax?
22:03:57 <pumpkin> no
22:04:18 <ferret_0567> pumpkin: then why do you say that?
22:04:44 <pumpkin> nothing in "second to last" implies needing to know the length of the list
22:04:53 <pumpkin> you just need to know when you're near the end
22:05:02 <rwbarton> ferret_0567: maybe try writing last without length first
22:05:03 <ferret_0567> oh
22:05:09 <ferret_0567> rwbarton: ok
22:05:34 <rwbarton> ferret_0567: have you learned about pattern matching?
22:05:36 <wks> a list can be infinite
22:05:47 <wks> [1..] !! (-3)
22:06:15 <rovar> not sure how to do this correctly:  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1405#a1405
22:06:55 <ferret_0567> rwbarton: I am learning about that now
22:06:58 <pumpkin> rovar: what's the problem?
22:07:09 <rwbarton> ferret_0567: ok, cool.  It will be easier with pattern matching
22:07:22 <pumpkin> rovar: indent your three cases a little more?
22:07:37 <pumpkin> not sure if that makes a difference
22:07:42 <rovar> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1405#a1406
22:07:51 <rovar> i pasted the error this time. will try indenting
22:07:56 <pumpkin> oh, that won't fix it :)
22:08:06 <pumpkin> just put an explicit type on one of your random bounds
22:08:17 <rwbarton> ghc doesn't know whether you want an Integer, or a Double, or what
22:08:20 <pumpkin> (1, 3 :: Int)
22:08:22 <pumpkin> or something
22:08:59 <rwbarton> You might be interested in using a Random monad
22:09:14 <rovar> rwbarton: yea, I use that elsewhere.
22:09:26 <rovar> I just wanted a quick pure function for that.
22:09:35 <rovar> pumpkin: thanks, i did  case p :: Int ...
22:09:37 <rovar> that fixed it
22:10:01 <rwbarton> and also in deriving Enum and Bounded for your Class type
22:10:06 <rwbarton> :t randomR
22:10:08 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
22:10:50 <rovar> ahh
22:11:00 <rwbarton> then you could write a function to return a random value of something that's Enum and Bounded and then you won't have to change anything if you add another class
22:11:03 <rovar> you're right.. i remember reading about that somewhere
22:11:22 <rovar> when I first started learning about Haskell
22:11:30 <rovar> a week ago :)
22:12:24 <rwbarton> BTW, just because some code uses a monad doesn't make it impure
22:12:31 <rovar> true
22:12:52 <rovar> in this case it would be pure, because it would always return the same results for the same input
22:12:58 <rwbarton> right
22:13:05 <rwbarton> you could use a State StdGen monad
22:13:16 <rovar> I use that elsewhere too :)
22:13:31 <rwbarton> and you could even runState an action right here to write this exact function without changing its meaning or type signature
22:13:36 <rwbarton> ok, cool
22:14:38 <rovar> can't find that tutorial on using bounded and enum to generate random types.
22:16:29 <rwbarton> @let randomE g = let (e, g') = randomR (fromEnum minBound, fromEnum maxBound) g in (toEnum e, g')
22:16:31 <lambdabot>  Add a type signature
22:16:49 <rwbarton> d'oh. hmm...
22:17:01 <rovar> hehe
22:17:12 <rwbarton> @let randomE :: forall a. (Bounded a, Enum a) -> StdGen -> (a, StdGen); randomE g = let (e, g') = randomR (fromEnum (minBound :: a), fromEnum (maxBound :: a)) g in (toEnum e, g')
22:17:13 <lambdabot>  <local>:30:19:
22:17:13 <lambdabot>      Illegal operator `.' in type `forall a . ((Bounded a, En...
22:17:15 <rwbarton> gah
22:17:43 <rwbarton> @let randomE g = let (e, g') = randomR (fromEnum (minBound `asTypeOf` e'), fromEnum (maxBound `asTypeOf` e')) g ; e' = toEnum e in (e', g')
22:17:46 <lambdabot>  Defined.
22:17:49 <rwbarton> @type randomE
22:17:51 <lambdabot> forall t a. (Bounded a, Enum a, RandomGen t) => t -> (a, t)
22:18:04 <rwbarton> > randomE (mkStdGen 42) :: (Bool, StdGen)
22:18:06 <lambdabot>   (True,1720602 40692)
22:18:23 <porges> @src asTypeOf
22:18:24 <lambdabot> asTypeOf = const
22:18:27 <porges> :D
22:18:39 <rwbarton> then add "deriving (Bounded, Enum)" to your data declaration
22:19:09 <rwbarton> Hmm, my code requires the monomorphism restriction to work. :)
22:19:30 <Gracenotes> asTypeOf shows the POWER of polymorphism in type signatures™
22:19:37 <erikc> are there any libraries that have an interesting use of the ((->) r) monad instance? im curious what it'd be useful for?
22:20:06 <pumpkin> erikc: calling join on a function is fun :)
22:20:10 <Gracenotes> erikc: it's generally more convenient to use Readers
22:20:20 <rwbarton> Hmm, maybe it doesn't...
22:20:22 <pumpkin> but I don't know of libraries that make a point of using it
22:20:31 <Gracenotes> otherwise, ((->) r) is neat for writing concise pointless code
22:21:18 <Gracenotes> it's a way of calling a function with two arguments, but modifying the first argument
22:21:28 <erikc> right
22:21:41 <Gracenotes> on the other hand `ap` modifies the second argument
22:22:35 <rwbarton> > local (+1) (*10) 5
22:22:37 <lambdabot>   60
22:23:27 * rwbarton plans to replace all occurrences of >>> with `local`
22:23:39 <pumpkin> @index local
22:23:40 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
22:24:30 <porges> @src local
22:24:30 <lambdabot> Source not found. My brain just exploded
22:24:56 <porges> rwbarton: you could use conor's combinators :)
22:24:58 <rwbarton> Oh, that code doesn't actually require the MR, because the bindings of (e, g') and e' are "mutually recursive"
22:25:21 <Gracenotes> > runReader (do { local (+1) (do { asks (*10)}) }) 5
22:25:23 <lambdabot>   60
22:25:40 <Gracenotes> huh
22:25:42 <Gracenotes> @type local
22:25:44 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:25:52 <Gracenotes> ah...
22:25:56 <rovar> i replaced the ; with a \n in your code and am getting a parse error on the 2nd line.
22:26:46 <porges> s/conor/conal
22:27:47 <rwbarton> did you indent e' under (e, g')?
22:27:58 <rovar> yar
22:28:33 <rovar> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1407#a1407
22:28:43 <ferret_0567> Gracenotes: most of  that looks like gibberish to me
22:28:49 <ferret_0567> Gracenotes: soon it should make sense
22:28:50 <pumpkin> @hoogle Double -> Float
22:28:51 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
22:28:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:28:51 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:29:06 <rwbarton> rovar: that might be too much? not sure
22:29:21 <Gracenotes> ferret_0567: I didn't use so many statements as I thought.. so the do's were rather superfluous >_>
22:29:35 <rwbarton> yeah, the binding has to start in the same column
22:29:44 <Gracenotes> > runReader (local (+1) (asks (*10))) 5
22:29:46 <lambdabot>   60
22:30:13 <hydrapheetz> > reverse "racecar bob"
22:30:15 <lambdabot>   "bob racecar"
22:30:19 <hydrapheetz> Kingdom of Loathing ~
22:30:39 <rovar> rwbarton: it works with the semicolon, I'll just leave it for now :)
22:30:55 <Gracenotes> ferret_0567: or if you mean the type signature... MonadReader, MonadState, etc. are just a bunch of typeclasses that add extra functions to certain types of monads
22:31:23 <rovar> rwbarton: Thanks for your help.
22:31:28 <Gracenotes> local could be of type: (r -> r) -> Reader r a -> Reader r a
22:31:58 <Gracenotes> another type of MonadReader defines local to be: (r -> r) -> (r -> a) -> r -> a
22:32:16 <rwbarton> oh, hmm.
22:32:16 <Gracenotes> @djinn (r -> r) -> (r -> a) -> r -> a
22:32:17 <lambdabot> f _ a b = a b
22:32:33 <Gracenotes> hrm. I wonder why djinn didn't want to use (r -> r). >_>
22:33:06 <gueux> what is the good way to do a "while loop" like in haskell?
22:33:25 <gueux> s/what is the/is it a/
22:33:51 <pumpkin> gueux: what will the loop do?
22:34:11 <pumpkin> there are different ways to go about it depending on what your final product will be :)
22:34:44 <gueux> is has to test the entry given by the user while it is not a "legal entry"
22:35:00 <pumpkin> test? so it'll return a Bool ?
22:35:11 <gueux> ?
22:35:11 <pumpkin> gueux: remember, everything returns a value
22:35:12 <gueux> no
22:35:21 <gueux> it returns unit :-)
22:35:23 <rwbarton> sounds like it lives in IO
22:35:24 <Gracenotes> @type untilM
22:35:26 <lambdabot> Not in scope: `untilM'
22:35:28 <pumpkin> then forM_ or something
22:35:31 <Gracenotes> :(
22:35:47 <rwbarton> I would just use explicit recursion in this case
22:35:50 <gueux> forM_
22:35:51 <gueux> ahah
22:35:57 <gueux> what a good name
22:36:07 <pumpkin> gueux: I guess your input list isn't fully defined, if you're grabbing input on the fly?
22:36:11 <pumpkin> then I'd do as rwbarton said :)
22:36:29 <Gracenotes> @type \t f a -> sequence $ until t f a
22:36:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => ([m a] -> Bool) -> ([m a] -> [m a]) -> [m a] -> m [a]
22:36:36 <Gracenotes> eek
22:36:48 <pumpkin> :t until
22:36:50 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
22:37:27 <Gracenotes> @src until
22:37:28 <lambdabot> until p f x | p x       = x
22:37:28 <lambdabot>             | otherwise = until p f (f x)
22:38:01 <pumpkin> so it's like an iterate that stops after the predicate finishes?
22:38:14 <gueux> pumpkin: exactely
22:38:17 <Gracenotes> returning a value. Just like until ;)
22:38:27 <Gracenotes> oops, wrong question target. *hides*
22:39:51 <gueux> I'm not sure that until is the good solution... (a -> Bool) is ok (my Test) but (a -> a) ??
22:40:24 <gueux> (() -> a) :-)
22:40:33 <rwbarton> no, it doesn't apply here
22:40:58 <Gracenotes> something like (a -> Bool) -> (a -> m a) -> a -> m a, would be nice-ish.
22:41:08 * Gracenotes mourns the lack of M-suffixed functions
22:42:01 <Gracenotes> or even (a -> m Bool). hm.
22:42:29 <rwbarton> yeah, there are too many options
22:42:53 <rwbarton> and in this case there isn't a natural starting value either
22:42:59 <pumpkin> Gracenotes: write a general transformer function that takes a non-M function and gives you one that has an M on it :P
22:43:08 <pumpkin> transformer = (++ "M")
22:43:09 <pumpkin> whee
22:43:18 <Gracenotes> one would only need survey the existing monads to see whether (a -> Bool) or (a -> m Bool) makes more sense
22:43:34 <Gracenotes> every single existing monad ever. Include BASIC.
22:45:17 <rwbarton> I guess you could write untilA :: (ArrowFoo (~>)) => (a ~> Bool) -> (a ~> a) -> (a ~> a) where ArrowFoo is the appropriate class and then it would apply to (->) also
23:10:32 <Axman6> http://www.reddit.com/r/programming/comments/7xoeh/anonymous_is_the_most_beautiful_programming_font/ <- finaly someone else who agrees with me about anonymous!
23:12:08 <mle> the 8pt seems bad
23:12:28 <mle> 9-10 are good though, hmmmm
23:12:37 <mle> (using the mac labels)
23:13:30 <Axman6> i usually use 13pt, my eyes are bad enough as it is
23:13:50 <mle> i spend ... most of my waking hours looking at monaco 10 pt -.-
23:14:02 <mle> well that and whatever emacs is using, hmmm
23:15:39 <ferret_0567> toList   Cons x xs              = toList (fromList xs)
23:15:40 <ferret_0567> toList   Nil                    = []
23:16:01 <ferret_0567> that doesn't work, anybody familiar with Real World Haskell should know where Cons comes from
23:16:30 <Axman6> ferret_0567: first thing, you'll want toList (Cons x xs)
23:17:01 <kmeyer> Axman6: heh, I use 14pt liberation mono
23:17:02 <kmeyer> :)
23:17:10 <ferret_0567> Axman6: oh, I see
23:17:15 * p_l uses 14pt Consolas ^^;
23:17:30 <hotaru2k3> why aren't there more monspace fonts with decent unicode coverage?
23:17:43 <Axman6> because monospace  looks silly
23:18:25 <ferret_0567> Axman6: that doesn't work
23:18:32 <glguy> hotaru2k3, the “fixed” font has good coverage
23:18:34 <Axman6> i don't find consalas as nice as nice as anonymous
23:18:43 * p_l uses monospace or close to monospace fonts for everything
23:18:49 <ferret_0567> top line is now: toList   Cons x xs              = toList (Cons x xs)
23:19:11 <mle> better to use cell-fonts
23:19:12 <Axman6> ferret_0567: no, on the other side, toList (Cons x xs) = ...
23:19:13 <Zao> Sounds awfully circular that.
23:19:18 <hotaru2k3> glguy: "fixed"?
23:19:22 <ferret_0567> Axman6: oh
23:19:26 <glguy> hotaru2k3, the default xterm font
23:19:32 <mle> monospace in latin/greek/etc and double-width for kanji/kana/etc
23:19:42 <ferret_0567> Axman6: so change the side I changed back?
23:19:52 <p_l> AFAIK "fixed" will pick whatever monospace fonts fulfill the requirements....
23:20:05 <Axman6> well, that's wrong too, but we'll get to that. you need to use :
23:20:15 <glguy> p_l, that doesn’t sound right
23:20:37 <Axman6> ferret_0567: do you know how to create a list?
23:21:27 <ferret_0567> Axman6: yes, that's easy enough: (0:1:2:[]) or [0,1,2]
23:21:51 <pumpkin> I need to generate a string with a particular decimal format... I know there's a printf, but is there an sprintf?
23:21:53 <pumpkin> @hoogle sprintf
23:21:53 <lambdabot> No results found
23:22:01 * ferret_0567 hopes that's correct
23:22:03 <Axman6> ferret_0567: would you like me to give you the answer, and then explain it if you need me to?
23:22:10 <glguy> pumpkin, printf is also sprintf
23:22:11 <ferret_0567> Axman6: no, not right now
23:22:26 <ferret_0567> Axman6: unless explaining it will help me with learning
23:22:29 <Axman6> ok, because there's not much i can tell you without giving you the answer
23:22:48 <pumpkin> glguy: oh wow, interesting type printf has
23:22:51 <Axman6> i think it may. you'll realise what's going on in the function better
23:22:52 <pumpkin> I always assumed it was just a static IO output
23:22:57 <p_l> glguy: I think fixed is mostly implemented by various different fonts which are then put under one label (X11 has a mechanism for grouping fonts from different encodings for greater coverage)
23:23:04 <gueux> I'd like to do a thing like: "askgood = do putStrLn ".."; 3
23:23:22 <ferret_0567> Axman6: ok
23:23:46 <gueux> I've understood that haskell doesn't like that
23:23:57 <ferret_0567> Axman6: please tell me how to fix it, and please explain it for me
23:23:58 <gueux> but I can't see how to change it :-)
23:23:58 <Axman6> ferret_0567: ok, toList (Cons x xs) = x : toList xs; toList Nil = []
23:24:18 <pumpkin> wow, this printf type is mind-boggling
23:24:24 <ferret_0567> Axman6: I've never seen that syntax before...
23:24:27 <Axman6> gueux: do {putStrLn ".."; return 3}
23:24:34 <Axman6> ferret_0567: which syntax?
23:24:45 <pumpkin> > let x = (printf "%0.2f
23:24:46 <Axman6> ferret_0567: you can replace the ; with a new line
23:24:47 <lambdabot>   <no location info>:
23:24:47 <lambdabot>      lexical error in string/character literal at chara...
23:24:56 <pumpkin> > let x = (printf "%0.2f" pi) in x
23:24:58 <lambdabot>   Add a type signature
23:24:58 <ferret_0567> Axman6: I've tried putting (Cons x:toList xs) on the right side before
23:25:03 <pumpkin> > let x = (printf "%0.2f" pi :: String) in x
23:25:05 <lambdabot>   "3.14"
23:25:16 <pumpkin> but it'll also be an IO if you ask nicely!
23:25:18 <Axman6> ferret_0567: no, just x : toList xs
23:25:21 <gueux> Axman6: that does not work
23:25:21 * pumpkin feels boggled
23:25:52 <Axman6> gueux: sure it does... but it'll be of type Num a => IO a
23:26:07 <ferret_0567> Axman6: you use just x because it's just a single item out of the List argument?
23:26:12 <gueux> ok
23:26:16 <Axman6> ferret_0567: yep
23:26:23 <ferret_0567> Axman6: do you use 13 pt. for IRC, too?
23:26:29 <olsner_> what really bugs me about printf though is that it is of type 'IO a' but return undefined... so liftIO (printf ...) will crash with an "Exception: undefined"
23:26:36 <Axman6> ferret_0567: firstly, do you understand how that list type actually works?
23:26:45 <gueux> I hadn't read the error message well
23:26:55 <pumpkin> olsner_: it isn't of type IO a though
23:26:56 <Axman6> ferret_0567: yep, i've reduced it for now though, trying it out
23:26:57 <pumpkin> is it?
23:27:17 <olsner_> pumpkin: well, the IO version is
23:27:21 <ferret_0567> Axman6: I think so
23:27:25 <pumpkin> ah
23:27:50 <pumpkin> :t printf
23:27:52 <lambdabot> forall r. (PrintfType r) => String -> r
23:27:56 <Axman6> ferret_0567: well, it's actually exactly the same as the normal list type. Cons == (:), and Nil == []
23:27:57 <pumpkin> @src PrintfType
23:27:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:28:12 <gueux> arg...
23:28:15 <Axman6> in fact, [] is called Nil, and (:) is called Cons
23:28:46 <gueux> Axman6: I've just put your code
23:28:48 <Axman6> dinner time, i'll be back shortly ferret_0567
23:28:52 <gueux> and then: askgood
23:28:54 <ferret_0567> Axman6: I knew that
23:28:59 <pumpkin> we need all the cars and cdrs scheme has
23:29:03 <ferret_0567> Axman6: what time it is where you are?
23:29:05 <gueux> I've got an error (again)
23:29:07 <olsner_> pumpkin: that is, the PrintfType class instance says IO a rather than IO ()
23:29:09 <ferret_0567> Axman6: it's 1:30 AM over here
23:29:10 <Axman6> 6:30pm
23:29:18 <ferret_0567> wow, where do you live?
23:29:19 <gueux>  parse error (possibly incorrect indentation)
23:29:35 <Axman6> aus
23:29:36 <gueux> I can't see how to indent it better
23:29:41 <p_l> 0730 here :)
23:29:42 <pumpkin> olsner_: I see. why would they do IO a rather than IO ()? will it return an IO String if you ask nicely?
23:29:43 <gueux> there is only two lines
23:29:59 <gueux> each is indented at 0
23:30:40 <ferret_0567> not even this works:
23:30:41 <ferret_0567> toList   Cons x xs              = x : toList xs
23:31:56 <gueux> ferret_0567: you need some (toList xs)
23:32:02 <olsner_> pumpkin: if you use printf as IO String, and actually extract the string, you'll get the undefined-exception
23:32:14 <pumpkin> oh I see
23:32:23 <pumpkin> so the IO a is completely pointless?
23:32:30 <olsner_> yep, afaik
23:33:46 <ferret_0567> where do I need (toList xs)?
23:34:59 <BMeph> ferret_0567: (Cons x xs), yes; (toList xs), no. :)
23:35:32 <ferret_0567> BMeph: in what part of my function?
23:35:39 <ferret_0567> toList   Cons x xs              = x : toList xs
23:35:49 <ferret_0567> the left or right part?
23:35:57 <BMeph> ferret_0567: The left side.
23:36:09 <ferret_0567> BMeph: then I already have it like you have it
23:36:15 <ferret_0567> BMeph: it still does not work
23:36:22 <BMeph> ferret_0567: You can put it on the right side, too, it just doesn't do much. :)
23:36:48 <BMeph> ferret_0567: So, what is the complaint?
23:37:24 <ferret_0567> BMeph:     Equations for `toList' have different numbers of arguments
23:38:25 <ferret_0567> BMeph: the other line of my function is: toList   Nil                    = []
23:39:41 <ferret_0567> BMeph: so what is wrong?
23:40:40 <BMeph> ferret_0567: It sounds like you put the parens arount the Cons part, but didn't save before you re-compiled. ;)
23:40:48 <BMeph> Er, *around
23:40:49 <gnut> what does "hPutChar: permission denied" mean?
23:41:32 <ferret_0567> BMeph: I didn't
23:41:49 <ferret_0567> BMeph: I never put any parens around the Cons part
23:41:57 <BMeph> ...
23:42:14 <BMeph> ferret_0567: That's what's wrong. :)
23:42:30 <ferret_0567> ListADT.hs:1:0: The function `main' is not defined in module `Main'
23:42:37 <ferret_0567> BMeph: it still doesn't work ^^^
23:44:09 <ferret_0567> BMeph: shouldn't I be able to compile this seperately?
23:44:33 <ferret_0567> BMeph: as a module or something?
23:45:30 <ferret_0567> does anybody know how to compile a hs file into a module?
23:46:15 <pumpkin> ferret_0567: you need to write a main function
23:46:20 <pumpkin> that "does something"
23:46:39 <pumpkin> main = print $ myFunction [1..100]
23:46:41 <pumpkin> or something
23:47:35 <ferret_0567> pumpkin: I wanted to use my file from ghci
23:47:43 <ferret_0567> pumpkin: I do not want a main function
23:48:17 <Axman6> ferret_0567: why do you need to compile it then?
23:48:45 <ferret_0567> Axman6: oh yeah, I can use it interpreted...
23:48:50 <Axman6> yep
23:48:52 <ferret_0567> I forgot, I don't know how
23:49:00 <Axman6> ghci file.hs
23:49:12 <BMeph> ferret_0567: ':load <Insert your file name>
23:49:22 <BMeph> '
23:50:08 <pumpkin> ferret_0567: also, :r to reload the file in ghci
23:50:11 <pumpkin> if you've edited it outside
23:51:38 <Eridius> I saw a slideshow on the web once (I think it was a PDF) on Haskell, and it gave an example of a very short Haskell program. The interesting part was the program code contained an infinite loop problem, but the type engine caught it and refused to compile.
23:51:40 <Eridius> This was used as an example of how powerful the type system in Haskell was. Does anybody know what slideshow I'm talking about?
23:52:12 <Axman6> google might be able to help
23:52:29 <Axman6> @go kind:pdf haskell type system infinite
23:52:31 <lambdabot> http://www.pphsg.org/cdsmith/types.html
23:52:31 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
23:53:01 --- mode: ChanServ set +o glguy
23:53:02 --- mode: glguy set -ob glguy *!*@ip72-207-23-205.sd.sd.cox.net
23:53:38 <ferret_0567> Axman6, BMeph, pumpkin: hey, it works!
23:53:43 <pumpkin> yay
23:53:45 <Axman6> :)
23:54:28 <ferret_0567> I will always use parentheses around patterns from now on, except for the very simple ones like []
23:54:45 * BMeph cyber-high-fives ferret_0567
23:54:46 <ferret_0567> patterns which have multiple words should have () around them
23:55:25 <glguy> the outer-most pattern in a case-branch doesn't need parentheses around it, however
23:55:38 <Axman6> ferret_0567: that's the way it's done :)
23:55:56 <Axman6> glguy: well, he's starting with pattern matching in functions
23:56:27 <Eridius> Axman6: that link didn't help, but I forgot google has a kind: query
23:57:09 <Eridius> Axman6: also, it's filetype: in google. kind: works on Spotlight ;)
23:57:20 <Axman6> heh, ideed, sorry :P
23:57:32 <Axman6> i was thinking about how that's just like spotlight
23:59:25 <Eridius> hrm, I'm not finding it
23:59:26 <Eridius> :/
23:59:43 <p_l> google also had a query that allowed to find files by their headers, iirc
