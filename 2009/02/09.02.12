00:00:09 <Ralith> no, I'm expositing upon yours :P
00:00:14 <RayNbow> > map ($5) [succ, (*4), pred]
00:00:15 <lambdabot>   [6,20,4]
00:00:30 <RayNbow> > sequence [succ,(*4),pred] 5
00:00:31 <lambdabot>   [6,20,4]
00:00:33 <Cheshire> Ralith, what do you want from me, a BNF?
00:00:44 <Cheshire> Ralith, do you really not see what I meant by that
00:00:55 <Ralith> I don't want anything from you.
00:01:23 <Ralith> what you said is literally meaningless.
00:01:51 <Ralith> everything has every relationship with zero or more instances of everything else
00:02:11 <Ralith> "zero or more" makes the statement a lingual noop.
00:02:37 <Cheshire> Ralith: so peano induction is a "noop"?
00:02:48 <Ralith> what?
00:04:48 <sm> would someone on windows mind telling me what the System.Info (os) function returns ?
00:07:17 <Deewiant> sm: mingw32
00:07:29 <RayNbow> bah, Deewiant beat me to it :p
00:07:38 * RayNbow was about to paste the same answer :p
00:07:48 <sm> thanks!
00:08:15 <sm> now, how do you open a url on windows.. some dll perhaps
00:08:44 <pao> Hi all
00:08:57 <Ralith> what does 'open a url' mean?
00:09:01 <Ralith> run a web browser?
00:09:04 <Ralith> download a file over http?
00:09:14 <sm> open a browser
00:09:31 <Ralith> then you'd want to use one of the functions to launch an external process.
00:09:49 <tonyIII_> pao: welcome to ask.
00:09:51 <sm> yes, I'm trying to find out which process to run in a robust way
00:10:07 <sm> eg I have a haskell app that serves its ui over http, it needs to pop up a browser to localhost
00:11:50 <sm> so far: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1320#a1320
00:12:07 <sm> I think it can try a few platform-specific options and check the exit code
00:17:48 <ziman> sm, system('start http://url.com')
00:18:43 <Ralith> sm: windows offers some way to discover the default browser, and some *nix desktop environments do, but it'd be a lot of work.
00:18:57 <Ralith> perhaps it'd be better to just tell your user to open the URL by hand?
00:19:25 <sOpen> python has a cross-platform browser opening capability
00:19:55 <sOpen> You could ship a python script, py2exe executable, or call open depending on what OS you find
00:20:18 <sOpen> I believe it uses the operating system's default browser from the user's preferences
00:20:41 <Ralith> just because somebody has implemented it doesn't mean it's worth the effort.
00:20:47 <sOpen> of course, there's probably a better way :-P
00:21:49 <sOpen> excuse me, i meant "start" not open previously
00:22:38 <hexpuem> is it possible to deforest something like this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1369#a1369
00:22:53 <sm> Ralith: no way, the whole point of this exercise is to make a "just works" app for non-techies
00:23:05 <sm> and cross-platform. It's not so easy ..
00:23:11 <Ralith> sm: even non-techies know how to open a browser.
00:23:29 <sm> in this case, they shouldn't have to.. they've already clicked on the app icon
00:23:50 <sOpen> sm, the app icon could be a "shortcut"?
00:24:08 <sm> the app needs to start up too though.. it's the server
00:24:16 <sOpen> sm, how are you shipping? do you have different packages for different platforms?
00:24:41 <Ralith> sm: ahh.
00:24:45 <sm> sOpen: ideally not, but if necessary yeah..
00:25:15 <Ralith> sm: does the app exit when the browser is closed?
00:25:23 <Ralith> if not, I suggest doing things differnetly to keep from confusing your nontechie users.
00:25:33 <sOpen> oh, that could be a problem
00:25:53 <sm> Ralith: alas no, but that seems less of an issue
00:26:12 <sm> when they start it again it can quit
00:26:26 <Ralith> you could do it with AJAX, I think.
00:26:30 <sOpen> Uh... the page could AJAX to the server once a minute... if the server doesn't get a heartbeat from the page, then die
00:26:37 <Ralith> actually
00:26:41 <sOpen> That seems like a hack, though
00:26:46 <Ralith> I'm pretty sure there's a javascript event for when the page is closed
00:26:54 <sOpen> Ralith, yes!
00:27:09 <sOpen> hmmm
00:27:13 <sOpen> tabs could cause problems
00:27:20 <sOpen> you'd have to track open pages on the server-side
00:27:23 <sm> yes I'm doing ajax.. good ideas
00:27:31 <Ralith> sOpen: no you wouldn't
00:27:34 <sm> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1320#a1321
00:27:38 <sOpen> Ralith, no?
00:27:46 <Ralith> at least
00:27:48 <Ralith> I don't think so
00:27:59 <sOpen> How will the server know if it should die or not?
00:28:07 <Ralith> hm, I guess you're right
00:28:10 <Ralith> still, that's not hard at all
00:28:11 <sOpen> I guess pages could set cookies, maybe
00:28:24 <sOpen> yeah, you'd still need a way to timeout the server, though
00:28:28 <sm> the heartbeat seems simple
00:28:50 <sm> but really I'm more concerned with getting it going than killing it
00:28:55 <sOpen> sometimes the browser will explode without calling the onPageClose event or whatever
00:30:04 <sOpen> yeah, you could do it with cookies, i believe they share state across sessions
00:30:21 <sOpen> "how do I lock a cookie?"
00:42:10 <jeffz`> sm: you'd use ShellExecute to open an url with the default browser
00:42:40 <sm> thanks jeffz, any idea how to call that from haskell ?
00:43:17 <jeffz`> sm, write a ffi binding for it using the Win32 package as a basis
00:43:40 <sm> ok, good to know
00:45:29 <jeffz`> sm, relatively simple, you could start by adding System/Win32/Shell.hsc and follow the style of any other module in that directory for types, headers, error handling and what not.
01:45:05 * wli tries to figure out how to get signalling floats.
01:48:01 <daf> wli: what's a signalling float?
01:48:31 <wli> They raise SIGFPE on overflow/underflow et al.
01:49:11 <daf> there's an ieeeeee package that tells you about fp error conditions
01:49:16 <daf> there's a monad and verything
01:52:04 <wli> Raising signals could be awkward esp. with the numeric hierarchy presuming functions are pure, but anyway.
01:52:47 <daf> AIUI, SIGFPE is ignored
01:52:57 <daf> errors are reported asynchronously
01:55:11 <fasta> Is there a library which predefines cpp macros for just about every partial function in the prelude, with the goal of getting rid of the Prelude.head empty list, or Prelude.maximum empty list errors?
01:56:42 <quicksilver> cpp macros which use __LINE__ and __FILE__ don't solve the problem.
01:56:48 <quicksilver> they just move it one step up the tree.
01:57:06 <quicksilver> maybe that's not what you meant
01:57:22 <fasta> quicksilver: they have solved it in every case that I cared about.
01:58:11 <quicksilver> they only move it one step up the tree - so it's only useful if that one step up the tree is your code
01:58:17 <quicksilver> if that *is* your code, then you have a better solution
01:58:19 <quicksilver> don't use them!
01:58:52 <fasta> quicksilver: what better solution? You mean like using safe_maximum returning a Maybe and all that?
01:59:34 <quicksilver> yes.
01:59:44 <quicksilver> or a case of your own
01:59:48 <quicksilver> or listToMaybe
01:59:49 <quicksilver> and so on.
02:06:39 <augustss> quicksilver: one step up the tree is immensely better :)
02:25:14 <edbond> Is it possible to do several things after let .... in block?
02:25:29 <beelsebo_> do several things?
02:25:37 <beelsebo_> you never "do" thinks in a haskell program
02:25:45 <beelsebo_> the program *is* something
02:25:45 <cizra> .. except in do-blocks.
02:25:58 <beelsebo_> no, do blocks are just really bad syntactic sugar
02:26:11 <beelsebo_> they *are* an IO action, they don't do the IO action
02:26:14 <ivanm> beelsebo_: why "really bad"?
02:26:16 <edbond> I want to make Debug.Trace and return value.
02:26:34 <beelsebo_> (monadic action rather)
02:26:45 <ivanm> edbond: ummmm.... the returning of a value will happen anyway...
02:26:48 <quicksilver> edbond: that is what trace does.
02:26:52 <quicksilver> trace "hi" 3
02:26:54 <ivanm> and to do trace, you just do: trace "msg" value
02:26:55 <beelsebo_> edbond: like this?  trace "jam ham spam" (and return the value here)
02:26:59 <quicksilver> traces "hi" and then returns 3
02:27:25 <edbond> yeah, there is also traceShow. thanks, I got it about 'several things' :)
02:27:58 * ivanm thinks Debug.Trace should include a function: tracer a = trace (show a) a
02:28:08 <ivanm> I end up defining that function so many times when debugging my code... :s
02:28:15 <Peaker> ivanm: Yeah, I keep defining it myself and call it traceId
02:28:19 <beelsebo_> ivanm: use Hood for stuff like that
02:28:23 <beelsebo_> it's much more flexible
02:28:26 <ivanm> Hood?
02:28:29 <cizra> Does tracing enforce computation of traced thunks?
02:28:31 <ivanm> isn't that yhc only?
02:28:34 <beelsebo_> nope
02:28:39 <beelsebo_> it existed way before yhc
02:28:53 <fasta> cabal: There is no package named hood
02:28:56 <beelsebo_> it's a single module that defines tracing functions that let you observe all calls to particular functions
02:28:59 <fasta> Sorry, hood doesn't exist.
02:29:18 <beelsebo_> http://www.haskell.org/hood/ <-- there you go
02:29:20 <ivanm> fasta: it predates cabal
02:29:32 <beelsebo_> I may actually poke it and cabalise it
02:29:34 <beelsebo_> it's a damn shiny toy
02:29:38 <fasta> ivanm: so, then it has been abandoned.
02:29:41 <ivanm> (cabal-the-build-format, not cabal-the-install-tool)
02:29:44 <ivanm> fasta: who says?
02:29:52 <fasta> ivanm: all these tools are research toys.
02:29:57 <ivanm> gtk2hs isn't installable by cabal (yet), but it hasn't been cabalised as yet
02:30:02 <ivanm> fasta: which tools?
02:30:07 <fasta> ivanm: just like the ghci debugger; it has no practical value at all.
02:30:24 <quicksilver> fasta: if you've never used it, you don't know that.
02:30:28 <ivanm> beelsebo_: by the looks of things, it mightn't be buildable atm (if it needs patches for ghc-5...)
02:30:35 <quicksilver> fasta: please find some useful comments to make, or go elsewhere.
02:30:36 <fasta> quicksilver: I think I installed it a long long time ago.
02:30:41 <ivanm> fasta: ummmm..... what's so bad with the ghci debugger?
02:30:45 <beelsebo_> ivanm: yeh, I'll fiddle – I've at least used it with ghc 6.6 though
02:30:50 <beelsebo_> so it's not that massively out of date
02:31:01 <fasta> ivanm: I have been over that a million times already.
02:31:02 <beelsebo_> ivanm: there's also gHood somewhere (it's bloody hard to get though)
02:31:08 <beelsebo_> which visualises hood's output
02:32:47 <fasta> quicksilver: it is useful to say that some tools are simply broken. See: http://www.haskell.org/hat/download.html I think malcolmw put that message there, because I asked him to.
02:32:49 <ivanm> fasta: I don't recall ever reading it (then again, I lurk a lot...)
02:34:01 <quicksilver> fasta: "sorry hood doesn't exist" "all these tools are research toys" "it has no practical value at all"
02:34:19 <quicksilver> fasta: so on the one hand, we have beelsebo_ who has actually used hood, and is explaining how it might be useful.
02:34:32 <quicksilver> fasta: and on the other hand, we have you, you have not used it, and just spread FUD.
02:34:57 <beelsebo_> quicksilver: tbf, I did use hood as a research toy – but it certainly can be *very* useful in situations where you'd normally use debug.trace and it doesn't provide *quite* enough info
02:34:57 <fasta> quicksilver: unless you have used these tools and actually benefited from it in a real program larger than 10 lines, it's not FUD.
02:34:59 <ivanm> matthew-_: ping!
02:35:02 <fasta> quicksilver: I used this tools.
02:35:17 <fasta> these*
02:35:20 <Cheshire> I thought that hat and hood and stuff don't work anymore?
02:35:29 <beelsebo_> hat works fine
02:35:30 <Cheshire> like the new GHC are not able to compile them
02:35:38 <beelsebo_> but it sure as hell takes a crap load of fiddling to get it to compile
02:35:39 <quicksilver> fasta: if you'd said "I tried to use this tool on a 3 module program and I found it less useful than Debug.Trace because ...."
02:35:40 <fasta> Cheshire: yes, we know.
02:35:48 <quicksilver> fasta: then that would have been a useful comment. Yours were not.
02:35:50 <Cheshire> fasta, I wasn't sure
02:36:10 <fasta> quicksilver: I used it when I had a complicated problem. The tools simply has zero utility.
02:36:36 <ivanm> fasta: how much "fiddling" or asking did you do before deciding it had zero utility?
02:36:39 <quicksilver> No. The tool didn't solve your problem.
02:36:42 <fasta> quicksilver: by complicated I mean a program with > 50 modules and > 10KLOC.
02:36:48 <fasta> ivanm: I contacted the author.
02:36:50 <ivanm> maybe it had zero utility for _you_ because it didn't do what you wanted...
02:36:50 <quicksilver> hood also cannot cure my cold.
02:36:57 <ivanm> quicksilver: awww....
02:36:57 <quicksilver> that doesn't mean hood has zero utility.
02:37:09 <fasta> ivanm: and he told me that it didn't work for my real world case.
02:37:09 <ivanm> fasta: which app has > 50 modules? or is this a private one?
02:37:19 <ivanm> which real world case is that though?
02:37:19 <fasta> ivanm: private, of course.
02:37:57 <beelsebo_> bottom line: The state of debugging haskell is pretty appaulind
02:37:59 <beelsebo_> appauling*
02:38:16 <beelsebo_> otoh... it's an open research problem, not just a matter of writing a debugger and being done
02:38:25 <beelsebo_> so stop winging and do the research ;)
02:38:49 <fasta> I think it would be far more productive to just start writing one and eating your own dog food.
02:39:12 <fasta> But the problem is that there is no real goal; only the artificial goal of producing "research".
02:39:16 <beelsebo_> I've so far written 3 different debuggers for Haskell ;)
02:39:28 <beelsebo_> (all based on hat)
02:40:16 <ivanm> fasta: then stfu and write one yourself if you think so little of those that are already available!
02:40:33 <fasta> ivanm: how is that relevant?
02:40:37 * ivanm thinks "research" is a real goal
02:40:52 <ivanm> fasta: you still haven't said exactly _how_ hood, etc. fail to work
02:40:54 <Cheshire> ivanm, seems a bit rude
02:41:00 <ivanm> Cheshire: yeah, a bit maybe
02:41:01 * fasta believes all the interesting things have already been invented
02:41:06 <beelsebo_> especially considering no one knows what a useful debugger for Haskell actually looks like
02:41:07 * ivanm blames his extreme exhaustion
02:41:16 <ivanm> fasta: oh well then, I guess we can just give up then
02:41:24 <Cheshire> yeah being exausted makes it ok
02:41:25 <fasta> It's just that we need some more stuff about the universe.
02:41:27 <beelsebo_> fasta: oh, okay then, I guess a debugger for haskell that's useful isn't interesting
02:41:28 <ivanm> who cares about fusion power, biotech, etc.
02:41:30 <beelsebo_> or can't be invented
02:41:38 <beelsebo_> so lets all stop bitching, and get over it
02:41:58 <fasta> ivanm: the things you talk about are just applications, not research.
02:42:13 <fasta> Well, maybe that's a bit too extreme.
02:42:14 <beelsebo_> fasta: you know how to sustain fusion reactions?
02:42:19 <beelsebo_> blimey
02:42:21 <beelsebo_> that's impressive
02:42:26 <ivanm> fasta: it takes research to work out how to do fusion power
02:42:32 <fasta> beelsebo_: I know how I could build a machine with could.
02:42:39 <ivanm> anyway, IIRC a lot of people thought physics was over about 100 years ago
02:42:39 <beelsebo_> go on then ;)
02:42:40 <fasta> beelsebo_: I know how I could build a machine which could find out for me.
02:42:41 <beelsebo_> do it
02:42:52 <ivanm> and then these smart-arses invent this fandangled thing called "quantum physics"
02:43:09 <ivanm> fasta: well, you must be a genius because no-one else has managed to do so...
02:43:20 <fasta> ivanm: not really; I didn't invent it.
02:43:30 <beelsebo_> fasta: so, given that you know how to write said debugger, and there's no research left to do... What would a Haskell debugger look like?
02:43:49 <Cheshire> 3D
02:43:54 <beelsebo_> haha
02:43:55 <beelsebo_> :D
02:44:03 * beelsebo_ wants to say that in his viva now
02:45:13 <fasta> beelsebo_: a debugger fundamentally answers queries the user has over his/her program. So, whenever a user (i.e. yourself) has a problem, it should formulate it in some formal language and then you must work just as long until the debugger can solve that problem. Continue that for a few years and you have something that might be useful.
02:45:35 <fasta> s/it/he\/she
02:45:51 <Cheshire> fasta, that sounds like interactive theorem proving to me
02:45:58 <ivanm> fasta: wow, that's a different version of a debugger than anyone else has ever seemed to implement...
02:46:01 <Cheshire> fasta, is there a similarity?
02:46:01 <beelsebo_> or algorithmic debugging, but backwards
02:46:11 <ivanm> sounds like it might be pushing the boundaries of the Halting Problem as well...
02:46:21 <fasta> Cheshire: I do not oppose interactive theorem proving at all.
02:46:45 <ivanm> @wn debugger
02:46:46 <lambdabot> *** "debugger" wn "WordNet (r) 2.0"
02:46:46 <lambdabot> debugger
02:46:46 <lambdabot>      n : a program that helps in locating and correcting programming
02:46:46 <lambdabot>          errors
02:47:05 <fasta> ivanm: apparently, since the utility of all the other Haskell ones is zero, since they do not build.
02:47:06 <beelsebo_> fasta: so, given that this is something that requires knowledge of the entire execution of your program, how do you propose to solve the problem of storing all reductions that ever took place during the execution?
02:47:08 <ivanm> looks like a completely different definition of debugger than you have...
02:47:20 <ivanm> fasta: I meant debuggers for _any_ language, not just haskell
02:47:23 <ivanm> gdb for example
02:47:36 <quicksilver> certainly it is interesting to imagine useful ways to debug haskell.
02:47:42 <fasta> ivanm: gdb is the simplest debugger one could possibly create.
02:47:53 <beelsebo_> ivanm: tbf, gdb or a debugger like it is pretty useless against Haskell code
02:48:06 <ivanm> beelsebo_: yes.... but I was talking about a debugger in general
02:48:08 <daf> fasta: that's not true
02:48:09 <beelsebo_> yep
02:48:17 <beelsebo_> no
02:48:19 <daf> fasta: a source debugger is more useful than a binary debugger, for a start
02:48:25 <quicksilver> having said that, I don't thin it's fair to describe the current situation as 'appalling'
02:48:26 <beelsebo_> the simplest debugger is this: trace "jam" value
02:48:43 <quicksilver> I don't particularly find haskell harder to debug than other languages
02:48:48 <quicksilver> although I tend to do it differently.
02:48:54 <daf> what quicksilver said
02:48:56 <beelsebo_> yeh
02:49:04 <beelsebo_> what I think most of us do is actually algorithmic debugging
02:49:05 <beelsebo_> but manually
02:49:07 <beelsebo_> with ghci
02:49:09 <fasta> daf: yes, it's not the simplest one, but let's say I am not impressed by it in any way.
02:49:13 <ivanm> quicksilver: yes, having a prompt makes haskell much easier to debug than C or Fortran for example
02:49:23 <quicksilver> this is not unrelated to the situation with IDEs: it is definitely interesting to consider what features a good haskell IDE might have
02:49:32 <quicksilver> and yet, I'm happier without an IDE than I am in other languages.
02:49:43 <ivanm> quicksilver: have you tried leksah?
02:49:46 <quicksilver> no.
02:49:55 <ivanm> I tried the first release, but it didn't seem to work
02:50:00 <ivanm> haven't tried the latest one
02:50:12 <quicksilver> I'm very unlikely to give the time of day to anything which doesn't let me continue to use emacs.
02:50:12 <ivanm> but yes, in general I just do my haskell hacking in a text editor
02:50:19 <beelsebo_> quicksilver: yeh, I've often hypothesised that the reason debugging Haskell is "harder" than debugging C is that when you want to break out a Haskell debugger, you generally have a *much* nastier error to search for than when you break out gdb
02:50:23 <ivanm> quicksilver++ ;-)
02:50:32 <ivanm> @remember quicksilver I'm very unlikely to give the time of day to anything which doesn't let me continue to use emacs.
02:50:32 <lambdabot> Okay.
02:50:38 <ivanm> quicksilver: so yi is out as well then? :p
02:50:50 <quicksilver> yi looks like it might become emacs-like enough for me to enjoy it
02:50:59 <ivanm> beelsebo_: because the simpler errors are gone already?
02:51:04 <beelsebo_> indeed
02:51:07 <quicksilver> and it might even be easier to extend than emacs, which would be great.
02:51:12 <quicksilver> I'm not big fan of elisp ;)
02:51:21 <beelsebo_> or because there are whole swathes of error classes that don't occur – like null pointers
02:51:22 <ivanm> quicksilver: my main potential criticism with yi is that emacs is convenient in that you can do _all_ your editing in it...
02:51:34 <ivanm> I don't think we'll get something to replace auctex, etc. any time soon in yi :(
02:51:49 <pejo> quicksilver, preach it! Gnus ftw!
02:51:56 <ivanm> beelsebo_: I included them in my "simpler errors" ;-)
02:52:01 <ivanm> pejo: as in the mail client?
02:52:05 <Peaker> I think it might be useful to have a Haskell pure expression debugger that just shows you the values of all the sub-expressions, and you can "zoom in" into any sub-expression to see how it is composed
02:52:05 <beelsebo_> fair enough
02:52:28 <beelsebo_> Peaker: hat-explore
02:52:35 <beelsebo_> it's very useful!
02:52:38 * ivanm has idly considered writing a haskell MUA using yi as the editor, but in the end decided he had nfi how to do it and wasn't that interested
02:52:56 <beelsebo_> especially in that you can mark expressions as correct/incorrect and have it do algorithmic debugging in the background
02:53:19 <ivanm> beelsebo_: you're making me very interested in hat and hood... hurry up and cabalise them already! :p
02:53:28 * Peaker is with ivanm 
02:53:33 <beelsebo_> hat I'm not gonna touch the cabalisation of
02:53:38 <beelsebo_> that would be rather nightmarish
02:53:53 <beelsebo_> the build system is rather old and rickety, and only well understood by malcolmw
02:54:06 <beelsebo_> but Hood I'm having a stare at cleaning up at the moment
02:54:14 * ivanm volunteers beelsebo_ to prod malcomw to cabalise hat
02:54:15 <ivanm> ;-)
02:54:31 <beelsebo_> I think he's been intending to clean it up for the past 4-5 years
02:54:35 <ivanm> I must be getting confused with something else, but I thought hat was one of the tools ndm wrote...
02:54:37 <ivanm> :s
02:54:39 <ivanm> beelsebo_: heh
02:54:40 <beelsebo_> but doesn't have time or funding to do anything with it
02:55:38 <beelsebo_> I think there are a couple of things that need to happen for Hat to get useful
02:55:48 <beelsebo_> 1) ghc api become good enough that hat-trans can be written in it
02:55:57 <beelsebo_> 2) someone come up with a good way of linking against non-traced libraries
02:56:16 <pejo> beelsebob, does any of the debuggers for haskell work with sources beyond h98?
02:56:22 <beelsebo_> hat does
02:56:29 <beelsebo_> so does hood in fact
02:56:45 <beelsebo_> hat covers an odd set of Haskell that isn't quite all of H98, but is a lot more at the same time
02:58:25 <mm_freak> hi there
02:59:22 <lilac> hello
02:59:55 <mm_freak> i've found a construction of lists in pure lambda calculus, which seems entirely equivalent to haskell lists, but with a little difference:  if you willingly give up the laziness property, then you can append to these lists in an O(1) operation
03:02:09 <blackh> mm_freak: Tell me more
03:03:10 <mm_freak> it's in untyped lambda calculus, so you can't represent them straightforwardly in haskell…
03:03:23 <mm_freak> the empty list:  \f z -> z
03:03:36 <mm_freak> cons:  \x xs f z -> f x xs z
03:03:54 <matthew-_> pong
03:04:00 <ivanm> hey matthew-_
03:04:03 <matthew-_> hey
03:04:06 <matthew-_> sorry, I have to go!
03:04:10 <matthew-_> I'll be back in about 90 mins
03:04:10 <ivanm> heh
03:04:15 <ivanm> k then
03:04:18 <matthew-_> depending on whether or not I get fired... ;)
03:04:23 <ivanm> lol
03:04:24 <lilac> mm_freak: snoc?
03:05:11 <blackh> mm_freak: Theoretical foundation overflow error
03:05:18 <mm_freak> the 'destructive' append function looks like this:  \xs x f z -> xs f ((cons x empty) f z)
03:05:32 <quicksilver> mm_freak: well, DLists have O(1) append...
03:06:08 <mm_freak> quicksilver: i'm just having a theoretical look at lists
03:06:27 <mm_freak> found that church lists can be made lazy easily by changing the parameters of the folding function
03:06:39 <quicksilver> mm_freak: I was just suggesting that O(1) append isn't a ridiculous property to find
03:06:56 <lilac> mm_freak: so it's based on observing that 'foldr f x [a1,a2,...,an] == foldr f (f an x) [a1,a2,...,an-1]'
03:07:00 <quicksilver> mm_freak: especially if you are 'representing lists as functions' -- which is a common feature of church lists and DLists.
03:07:31 <mm_freak> lilac: almost
03:07:47 <pejo> JaffaCake, I was looking at the ghcmutterings blog last night: are there any more details available (papers, tr's, etc?) on the improvements to parallelism you've made?
03:08:21 <JaffaCake> pejo: we're writing a paper, I'll announce something when it's ready
03:08:39 <mm_freak> lilac: foldr f z (append xs x) == foldr f (f x z) xs
03:08:58 <mm_freak> quicksilver: oh, i didn't know that DLists have a functional representation
03:09:02 <pejo> JaffaCake, a - nice! Thanks.
03:09:11 <lilac> mm_freak: i think i'm being dense. what's the difference?
03:09:30 <ivanm> mm_freak: didn't you read RWH? :o
03:09:38 <ivanm> they cover DLists in there!
03:09:40 <ivanm> ;-)
03:09:49 <mm_freak> no, i didn't
03:09:56 <ivanm> oh, wait, "functional representation" == "theoretic representation"?
03:09:56 <lilac> mm_freak: infinite lists, perhaps?
03:10:12 <ivanm> they just implemented DLists as just wrappers around (.)
03:10:18 <mm_freak> lilac: maybe i'm being dense =)
03:10:29 <lilac> mm_freak: what happens when you append another element?
03:10:39 <mm_freak> ivanm: functional in that only functions are used
03:10:41 <osfameron> ooo, with a functional list you can even append stuff to infinite lists in constant time!
03:11:05 <mm_freak> lilac: the rule is recursive, but the foldr rule applies to church lists
03:11:09 <ivanm> mm_freak: ahhh
03:11:12 <mm_freak> not to the representation above
03:11:49 <mm_freak> i started writing a little paper about it…  i hope, i'm not just reinventing the wheel here
03:12:14 <lilac> mm_freak: it looks like 'foldr f z (append (append xs x1) x2) == foldr f (f x2 (f x1 x)) xs' when i'd expect 'foldr f (f x1 (f x2 x)) x2'
03:12:45 <lilac> mm_freak: no, wait. too early in the morning for me
03:12:49 * lilac goes for coffee
03:12:51 <mm_freak> lilac: there is nothing wrong with appending elements to church lists, which is exactly what that foldr rule suggests
03:13:01 <mm_freak> lilac: but it doesn't apply to lazy lists
03:15:13 <mm_freak> the main point is that normal haskell lists don't feature O(1) appending at all, but this seems to be a cosmetic restriction, because internally it would be possible, if you can live with sacrificing the laziness property
03:15:57 <mm_freak> of course, we wouldn't want that, but i find it interesting that it's possible
04:04:31 <eu-prleu-peupeu> http://i41.tinypic.com/24dna5x.png
04:06:45 <jkff> Hi. Does anyone know of a nice monoid (Int, mappend, mempty) such that its mconcat is a good hash function for lists of integers? The only one I can think of is XOR, but it doesn't look like a good hash.
04:08:37 <lilac> mm_freak: your type is not isomorphic to list. i'm not sure exactly what it is, but you can tell whether elements were added by cons or snoc
04:09:17 <lilac> MMLists> snoc (snoc (cons 6 (cons 5 (cons 4 empty))) 3) 2
04:09:18 <lilac> 6:5:4:[](b: [])(b: [])(b: 3:[](b: 2:[](b: [])))
04:09:42 <mm_freak> lilac: without the snoc operator, they are, that's the point
04:10:15 <BONUS> jkff: probably hard to achieve because of associativity
04:10:19 <lilac> mm_freak: it depends what you mean by isomorphic then (since snoc is implementable in terms of cons and empty)
04:11:48 <jkff> BONUS: Why does associativity make it hard? I understand why commutativity would, but why associativity?
04:12:13 <jkff> I mean, I see that it's hard, but I don't understand why :)
04:12:44 <BONUS> just a gut feeling i guess
04:12:58 <Cheshire> jkff, just pick a random subset of Integer^2, the chance that relation is assocative is small
04:13:28 <jkff> Cheshire: That only implies that I am not going to pick the hash function in a random way :)
04:13:28 <Cheshire> another way to look at it:
04:13:31 <quicksilver> jkff: \a b -> a * p + k + b (modulo q)
04:13:45 <Cheshire> mappend seed (mappend seed' key)
04:13:46 <quicksilver> jkff: for some primes p and q and some number k
04:13:48 <quicksilver> I think.
04:14:07 <Cheshire> mappend (mappend seed key) key'
04:14:09 <mm_freak> lilac: huh?  how can you implement snoc through cons and empty?  (without folding, since you can construct arbitrary functions through folding)
04:14:37 <Cheshire> happens with the argument names suggests it too, I think
04:14:50 <lilac> mm_freak: no, you're right; only by violating the abstraction can you do that :)
04:14:56 <Cheshire> jkff, not a random way, but from that set
04:15:10 <jkff> quicksilver: Looks intriguing. /me checks
04:16:04 <mm_freak> lilac: yeah ;)
04:16:21 <mm_freak> lilac: however, the snoc operator is actually violating the abstraction, too
04:16:30 <mm_freak> after all, it's a lazy list abstraction
04:16:31 <jkff> quicksilver: So, we have to make it so that ap^2 + bp + kp + c + k ==q== ap+bp+c+k+k, which seems hard to achieve
04:17:02 <jkff> Oh!
04:17:04 <jkff> I was mistaken
04:17:33 <jkff> This means that (ap+k)==q==(ap+k)p for all a
04:19:04 <lilac> mm_freak: as far as i can see, it works fine with lazy lists
04:19:17 <lilac> (that is, i'm trying it and i see no problems
04:19:24 <lilac> will hpaste in a moment
04:19:35 <mm_freak> lilac: try to change the folding function inside of the fold
04:20:01 <jkff> quicksilver: That boils down to q|(p-1). Thanks, that's very cool!
04:20:05 <mm_freak> lilac: and observe that in a list snocked n times, there will be n+1 incarnations of the fold
04:21:05 <mm_freak> in particular, if your list is fully snoc-constructed, then operations like head and tail become O(n) operations
04:21:12 <mm_freak> that's how you give up laziness
04:24:00 <mm_freak> lilac: with lazy lists, the head function reads:  \xs -> xs (\y ys z -> y) (error "head of empty list")
04:24:11 <paolino> what is used for simple marshalling?
04:24:17 <chrisdone> preflex: be poppavic
04:24:17 <preflex>  I said what I meant: you expect others to save you and ridicule me, (which is fine), but now pick yer GOD.
04:24:31 <lilac> mm_freak: i don't see how you've given up laziness. it still seems lazy to me :)
04:24:43 <chrisdone> paolino: show/read?
04:24:55 <chrisdone> paolino: there are a couple packages on Hackage for serialisation
04:25:05 <lilac> mm_freak: obviously an infinite list built with snoc will diverge under head
04:25:05 <mm_freak> lilac: construct a large list through snocs and then try the head function
04:25:14 <lilac> slow != strict
04:25:28 <mm_freak> but it consumes the entire list
04:25:32 <paolino> chrisdone: I couldn't make generic-xml to compile
04:25:45 <lilac> mm_freak: it forces the minimum it needs to in order to get the result
04:25:52 <quicksilver> jkff: not at all. I didn't come up with it, I've seen it somewhere, and I couldn't remember the details of how to make it work.
04:26:51 <jkff> quicksilver: I have found the details to make it work. If we consider computer arithmetic, where a reasonable q is a power of 2, then the only reasonable answer is to have q=32768 and p=65537, without constraints on k
04:27:07 <mm_freak> lilac: probably haskell's own laziness improves that
04:27:07 <jkff> There are no bigger q's such that p-1|q
04:27:14 <jkff> and p is prime
04:27:18 <paolino> chrisdone: anyway it was serializing the right word to search for :)
04:27:42 <matthew-_> ivanm: back and alive!
04:27:46 <lilac> mm_freak: /any/ list implementation will require forcing all the snocs in tail (snoc (snoc (...) y) z)
04:27:51 <lilac> s/tail/head/
04:27:54 <ivanm> matthew-_: \o/
04:28:10 <matthew-_> indeed
04:28:23 <mm_freak> lilac: yes, but normal haskell lists don't feature appending as an O(1) operation
04:28:24 <quicksilver> might even be I saw it in Knuth, now I thinkg about it.
04:28:44 <lilac> mm_freak: however, you're right in the sense that tail (fix (flip snoc 1)) diverges and shouldn't
04:29:00 * lilac wonders if it's possible to build an efficient foldl for this structure
04:29:05 <ivanm> matthew-_: OK, so the changes I want to make include adding more running wrapper-functions that I've got atm in my Graphalyze library
04:29:11 <matthew-_> ivanm: ok
04:29:29 <SamB_XP_> lilac: it shouldn't ?
04:29:34 <SamB_XP_> hmm.
04:29:37 <mm_freak> what you called MMLists…  ;)
04:29:46 <mm_freak> feature that, under the constraint that you give up laziness
04:29:51 <SamB_XP_> > init (fix (1:))
04:29:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:29:52 <matthew-_> ivanm: you going to send me some patches?
04:30:00 <SamB_XP_> lilac: I guess you're right
04:30:06 <ivanm> matthew-_: yeah... just asking you on advice on how to design this ;-)
04:30:16 <matthew-_> ahh!
04:30:29 <matthew-_> you're assuming that I've looked at this library in the last 6 months?!
04:30:56 <ivanm> actually.....
04:31:04 <jkff> quicksilver: There's just one issue: this function induces only a semigroup, not a monoid.
04:31:04 <ivanm> I might have stuffed up what I was reading :s
04:31:09 <SamB_XP_> lilac: I don't think you can get that behaviour without using reversed linked-lists
04:31:13 <ivanm> matthew-_: you _did_ make a release in August ;-)
04:31:17 <quicksilver> jkff: Ah. Does that matter for you?
04:31:20 <SamB_XP_> (which start at the tail and are made of snocs)
04:31:29 <jkff> T.i., it looks like there does not exist a k such that the function becomes a monoid.
04:31:36 <matthew-_> ivanm: that's 6 months....
04:31:53 <ivanm> is it? wow, time flies... :s
04:32:04 <jkff> Well, I am not sure, but looks like it does. Essentially, I am hashing immutable red-black trees, that's why I need an associative hash. I need to provide a hashcode for the empty tree, too.
04:32:09 <jkff> And it has to be the unit.
04:32:15 <quicksilver> doh.
04:32:21 <ivanm> matthew-_: OK, nvm, I stuffed up my reading/conversion
04:32:30 <ivanm> I'll try and get these patches done by the end of the weekend
04:32:45 <matthew-_> awesome, I'm uber busy right now anyway
04:32:53 <ivanm> matthew-_: so I take it they let you keep your job? :p
04:32:53 <matthew-_> so I wouldn't be able to look at them until next week
04:32:58 <matthew-_> yeah, something like that
04:33:16 <ivanm> what is this job anyway? I thought you were a PhD student for some reason :s
04:33:20 <matthew-_> I am
04:33:36 <jkff> However, probably I can get away with nonempty trees. Maybe this will allow me to use a semigroup.
04:34:20 <ivanm> matthew-_: oh, this job is what lets you live as a PhD student? ;-)
04:34:31 <matthew-_> the phd is nominally a job ;)
04:34:36 <matthew-_> it's just I suck at it
04:35:03 <ivanm> ahhhh
04:35:06 <ivanm> what's your topic?
04:35:20 <matthew-_> see, such specifics are beneath me!
04:35:24 <ivanm> heh
04:35:53 <McManiaC> hi
04:36:03 <McManiaC> addToDie die1 = \seed1 -> ......
04:36:17 <McManiaC> is the \seed1 just a "short expression" for a lambda term?
04:36:42 <McManiaC> equal to (\seed1 -> ...) ?
04:36:53 <BONUS> yeah
04:37:09 <BONUS> it's the same as writing addToDie die1 seed1 =  ......
04:37:18 <McManiaC> yeh ok
04:37:29 <BONUS> f x y = ... is equal to f = \x -> \y -> ...
04:37:29 <jpu> Hello everybody. Does anybody know how to pass an escaped character on the command line to System.getArgs? e.g. "\r" which now appears as "\\r"
04:38:01 <Cheshire> well if you ignore type rules I think
04:38:12 <Cheshire> > let f x = (x 1, x True) in f id
04:38:13 <lambdabot>       No instance for (Num Bool)
04:38:13 <lambdabot>        arising from the literal `1' at <inte...
04:38:24 <McManiaC> i just thought u need some parantheses around the term
04:38:25 <McManiaC> =)
04:38:25 <Cheshire> oh it really is the same then?
04:38:36 <quicksilver> jpu: that's up to your shell, not haskell.
04:38:40 <mm_freak> jpu: program `echo -e "blah\r\nblah"`
04:39:05 <quicksilver> mm_freak: I think `` will convert the newline into IFS (i.e. a space)
04:39:23 <mm_freak> quicksilver: oh
04:39:39 <quicksilver> hmm. doesn't seem to, actually.
04:39:41 <BONUS> McManiaC: yeah when you open up a lambda like \a -> .... it eats up everything to its right
04:39:48 <BONUS> the whole expression
04:39:50 <quicksilver> maybe it does. Maybe I don't know how to test.
04:39:52 <jpu> I'm using bash on linux which for every other language just passes an escaped char to the program.
04:39:53 <mm_freak> quicksilver: for me it does
04:39:58 <mm_freak> % echo `echo -e "x\ny"`
04:39:58 <mm_freak> x y
04:40:02 * quicksilver nods
04:40:23 <McManiaC> BONUS: yup, i know about lambdas =)
04:40:34 <mm_freak> however, in zsh i can write:  program $'x\ny'
04:40:36 <quicksilver> jpu: you are misunderstanding and misdiagnosing the problem.
04:40:41 <mm_freak> % echo $'x\ny'
04:40:41 <mm_freak> x
04:40:41 <mm_freak> y
04:40:42 <McManiaC> have been learning scheme the last 5 months at uni
04:40:51 <quicksilver> jpu: I suspect you are getting confused by 'show'
04:40:56 <quicksilver> which adds a layer of escaping to a string
04:40:58 <quicksilver> although I'm not sure.
04:42:01 <mm_freak> > show (chr 10)
04:42:02 <lambdabot>   "'\\n'"
04:42:03 <jpu> I'm wrapping a c library, which parses AT commands, with haskell but when passing e.g. "AT\r" on the command line, haskell passes it to my c function as "AT\\r"
04:42:37 <mm_freak> > show (chr 0)
04:42:39 <lambdabot>   "'\\NUL'"
04:42:53 <quicksilver> jpu: that sounds like you calling 'show' on it.
04:43:51 <quicksilver> the string AT<CARRIAGE RETURN> is 'shown' to "AT\r"
04:43:57 <mm_freak> jpu: use (map ord) before showing the string and see, whether it contains a 10
04:44:05 <quicksilver> the string AT<BACKSLASH>r is 'shown' to "AT\\r"
04:44:09 <mm_freak> > show . map ord $ "blah\nblubb"
04:44:10 <lambdabot>   "[98,108,97,104,10,98,108,117,98,98]"
04:45:14 <quicksilver> if you type % mycommand "AT\r" "
04:45:23 <quicksilver> at a shell prompt, you are giving the parameter AT<BACKSLASH>r
04:45:32 <quicksilver> not AT<CARRIAGE RETURN>
04:46:27 <mm_freak> afaik, the bourne shell doesn't provide any means to pass a \n
04:50:15 <p_l> mm_freak: echo -e
04:51:03 <p_l> eventually 'echo -e -n' to have full control over output (no default newline at end)
04:52:35 <jpu> Ah, I think I've found the solution: ./testAT $'AT\r'
04:53:11 <SamB_XP_> jpu: that's not a \n !
04:53:29 <jpu> AT requests are ended with "\r"
04:53:57 <SamB_XP_> oh, why did mm_freak say \n
04:53:59 <SamB_XP_> BAAAD mm_freak
04:54:13 <SamB_XP_> must be that screwy IPv6
04:57:05 <jacobian> Supposing I'm descending a tree and I come to a leaf that tells me to restart computation at a node higher up the tree.  What are some of the techniques for backing up?  It feels like it want's to be some sort of continuation
04:57:20 <SamB_XP_> jacobian: zippers
04:57:42 <SamB_XP_> @where zipper
04:57:42 <lambdabot> I know nothing about zipper.
04:57:44 <jpu> Thank you everybody for the help.
04:57:46 <ulfdoz> depth first traversal
04:57:47 <SamB_XP_> @where zippers
04:57:47 <lambdabot> I know nothing about zippers.
04:57:54 <jacobian> Great, thanks
05:03:04 <jacobian> man, does this mean I have to learn comonads now :)
05:06:06 <applicable> can you do the ycombinator in haskell?
05:06:47 <Baughn> @type fix
05:06:48 <lambdabot> forall a. (a -> a) -> a
05:06:53 <Baughn> Like that?
05:07:08 <Baughn> @src fix
05:07:08 <lambdabot> fix f = let x = f x in x
05:09:48 <applicable> is fix = ycombinator?
05:09:49 <applicable> it jsut crashes ghc
05:10:03 <Baughn> > fix (const 4)
05:10:05 <lambdabot>   4
05:10:16 <Baughn> > fix (1:)
05:10:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:12:06 <McManiaC> nice quit msg
05:13:26 <BONUS> jacobian: http://www.haskell.org/haskellwiki/Zipper
05:13:50 <BONUS> also while zippers are comonads, you don't have to know anything about comonads to understand and make us of zippers :)
05:14:02 <BONUS> just like you don't have to know that lists are monads to use them
05:14:16 <quicksilver> applicable: fix is related to the Y combinator, but it's not precisely the same.
05:14:32 <quicksilver> applicable: the Y combinator cannot be typed; but the Y combinator is not recursive.
05:14:38 <quicksilver> fix is defined using recursion.
05:17:10 <jkff> quicksilver: Colleagues suggested me a much easier variant: foldr xor 0 . map md5, this works perfectly for ascending lists, which is precisely my case
05:17:25 <jkff> However, that does not work well for non-ascending lists
05:17:32 <jkff> Of which I don't care :)
05:18:47 <quicksilver> jkff: :)
05:40:46 <osfameron> ICFP programming contest results are VERY hard to find
05:40:57 <osfameron> for 2008, was it 1st Java, 2nd JS, 3rd Perl ?
05:41:02 <osfameron> or am I confused?
05:41:12 <sbahra> I think you are confused.
05:41:18 <sbahra> I think the "FP" is for functional programming?
05:41:21 <osfameron> you seem to have to watch a video to find the results - is there a summary page?
05:41:44 <osfameron> sbahra: yes.  That doesn't mean I'm confused though.
05:42:00 <earthy> http://icfpcontest.org/results/ <- 2008
05:43:01 <osfameron> earthy: ta
05:43:21 <osfameron> doesn't say where the highest placing Perl using team was.  Aha though, http://en.wikipedia.org/wiki/ICFP_Programming_Contest suggests Perl placed second ;-)
05:43:37 <byorgey> sbahra: you can use any language you want, lots of people use non-functional languages in the ICFP programming contest.
05:46:14 <jkff> One man even used TeX
05:46:29 <jkff> IIRC, the winning entry was in C++
05:46:49 <osfameron> jkff: the results page earthy linked to suggests C++ was 2007
05:54:34 <tromp> > ()
05:54:35 <lambdabot>   ()
05:55:20 <sbahra> byorgey, and the winners were Java, JS and Perl?
05:59:34 <pozic> How can I import just a constructor named Cons from a module, but not the accessors?
06:00:05 <byorgey> pozic: import Foo (Cons)
06:00:49 <Lemmih> import Foo (DataType(Cons))
06:01:15 <pozic> Lemmih: yeah, that's it.
06:02:02 <pozic> import Cons(Cons(Cons)) looks kind of funny.
06:04:48 <opqdonut> :D
06:06:36 <lilac> pozic: yeah, what is this, lisp or something?
06:06:56 <lilac> import Cons $ Cons Cons
06:07:03 <lilac> ;-)
06:08:07 <lilac> ap import (join id) Cons
06:16:05 <osfameron> Would anyone (possibly someone who has been to an ICFP) have any comments on this as a possible introduction for a "functional pearl" session?  (first draft) http://greenokapi.net/misc/fp_paper.txt
06:16:54 <osfameron> I'm not sure if I'm completely barking up the wrong tree with style/approach (hence the very rough draft before I get committed too far into it)
06:17:24 <opqdonut> heh
06:18:31 <osfameron> it's basically a "as a formal paper" version of http://www.slideshare.net/osfameron/functional-pearls-version-2-presentation
06:19:20 <lilac> osfameron: well, it's amusing at least :)
06:20:43 <osfameron> heh, that's a start I guess :-)
06:21:43 <pozic> osfameron: don't functional pearls usually solve an existing problem in a better way?
06:21:57 <bastl> osfameron:; i dont understand the "perl has closures" conversation
06:22:16 <pozic> bastl: his presentation is about Perl.
06:22:53 <osfameron> pozic: http://web.cecs.pdx.edu/~apt/icfp09_cfp.html#pearls suggests that it can also be about "a novel use or exposition of functional programming in the classroom"
06:22:54 <bastl> still, should one know van Tannen and buneman ?
06:23:29 <pozic> osfameron: have you already been accepted?
06:23:40 <osfameron> bastl: thanks, maybe it isn't clear from context... it was funnier in http://perl.plover.com/classes/fp/samples/slide010a.html where I took it from
06:24:00 <osfameron> pozic: no, this is for the submission.  Apparently you need to write a *paper* even though you're giving a talk
06:24:21 <pozic> The annoying thing with these "functional pearls" is that simply because there is a conference, does not mean there is something worth publishing.
06:24:33 <osfameron> indeed
06:24:39 <osfameron> I'll email him now in fact to ask
06:33:59 <byorgey> osfameron: that certainly looks very different from other "functional pearls" I've seen.
06:34:08 <mreh> does GHC use a classpath-like machanism?
06:34:49 <byorgey> osfameron: what you have so far seems more like history than novel exposition, but I don't know where you plan to go with it.
06:34:53 <osfameron> byorgey: yeah... I've read some of the technique pearls, but none of the "educational pearls" that the CFP mentioned.
06:35:30 <byorgey> yeah, I guess that's probably because there aren't that many of them.
06:35:41 <osfameron> byorgey: true - I'll get into exposition of techniques for implementing monads in Perl as the main body - it's basically a reworking of http://greenokapi.net/blog/2008/12/01/functional-pearls-v2-now-with-monads-at-the-london-perl-workshop-2008/
06:36:09 <osfameron> it might be that what I want to talk about is inappropriate for ICFP, but I thought it might be fun for some light entertainment ;-)
06:38:54 <osfameron> well, I've emailed Andrew Tolmach as the "Program Chair" to ask clarification.  If he replies "Dear God, Perl? No not today thank you" then I'll know not to bother finishing it ;-)
06:39:04 <tomh--> is import Char deprecated?
06:39:13 <tomh--> there are some new namespaces now right?
06:39:26 <Saizan_> import Data.Char
06:39:35 <osfameron> aha, Lennart is on the chair, I can pester him when he's in :-)
06:39:41 <tomh--> ok thanks, is there any page which recommends the new names ?
06:39:53 <osfameron> s/chair/committee/
06:40:01 <Saizan_> mreh: you can pass it -idir to add search directories for sources
06:40:01 <z0d> Is there a function or library which will show the steps of the evaluation?
06:40:12 <z0d> for arbitrary code
06:40:21 <lilac> hat?
06:40:33 <lilac> or 'trace' if you can modify the code
06:40:40 <Saizan_> or the ghci debugger
06:41:20 <z0d> hat?
06:41:32 <Saizan_> tomh--: you can look at the modules of the haskell98 package and see what they re-export
06:42:07 <tomh--> ok
06:42:19 <tomh--> is there a command in ghci to see what certain modules expert then?
06:42:23 <tomh--> *export
06:43:09 <byorgey> tomh--: :browse Module
06:43:27 <Saizan_> :browse won't tell you where they come from though
06:43:56 <Saizan_> ?hoogle chr
06:43:57 <lambdabot> Data.Char chr :: Int -> Char
06:43:57 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
06:43:57 <lambdabot> System.Posix.Internals c_s_ischr :: CMode -> CInt
06:44:22 <Saizan_> tomh--: i'd just use hoogle on the symbols you want to import
06:47:21 <redditbot> Cool example of GADTs: from untyped expressions to well-typed expressions
06:47:21 <redditbot> hasktags - like ctags but for Haskell
06:47:33 <tomh--> ok
06:48:14 <chessguy_work> 'morning ya'all
06:51:05 <chessguy_work> wow, quiet channel today
06:51:17 <chessguy_work> @users
06:51:17 <lambdabot> Maximum users seen in #haskell: 661, currently: 623 (94.3%), active: 20 (3.2%)
06:54:20 <chessguy_work> this could be becoming an interesting little combinator library: http://codepad.org/ElhDbKtq
06:56:23 <quicksilver> chessguy_work: what is the actual 'a' value stored under hte constructor?
06:56:28 <chessguy_work> some kind of state
06:56:35 <quicksilver> 'current value' or something?
06:56:40 <chessguy_work> a scratch-pad of sorts
06:57:06 <chessguy_work> i should probably rename that type variable to 'state'
06:58:48 <BONUS> multi-letter type variable names?
06:58:48 <BONUS> why i never
06:59:59 <chessguy_work> the idea is composable, stateful strategies, which have control over what strategies get run in the future
07:00:13 <chessguy_work> i suspect it's somehow continuation-related, but not sure
07:00:33 <quicksilver> chessguy_work: although they don't have much useful control about what is run in the future
07:00:37 <quicksilver> because they can't inspect them
07:00:43 <quicksilver> all they can do is add more or throw them away.
07:00:47 <chessguy_work> true
07:00:56 <quicksilver> still interesting though.
07:01:44 <chessguy_work> quicksilver, i considered replacing Strategy with a typeclass
07:02:26 <chessguy_work> class Strategy s where eval :: s a -> a -> a
07:02:41 * quicksilver nods
07:03:25 <chessguy_work> newtype Strategic a = Strategic (a -> a); instance Strategy Strategic where eval (Strategic s) = s
07:03:39 <chessguy_work> but then you could throw in an ADT there too if you wanted
07:16:54 <applicable> can I write a program that fires up ghci and loads a specific module?
07:19:42 <asgaroth> Can anyone suggest some freely available CS lectures about functional programming(perhaps with an emphasis on the math/theory) (optional: that use Haskell)?
07:20:00 <applicable> i have written a matrix dsl and i just want an .exe that fires up a prompt in the DOS-window for the user
07:20:04 <applicable> can I write a program that fires up ghci and loads a specific module?
07:21:01 <asgaroth> applicable: ghci <module name>
07:21:29 <chessguy_work> quicksilver, that seems to make it a bit messy though :(
07:21:40 <applicable> yeah but when the user doubleclicks the exe it should fire up automatically
07:21:53 <chessguy_work> applicable, batch file
07:21:55 <rovar> everything is too damn easy in haskell.  It should make people work, dammit
07:22:34 <paper_cc> it should make programs work rather
07:23:14 <rovar> The programs work just fine, people don't have to work hard enough, IMO. They need to sweat a bit. It builds character.
07:23:54 <rovar> we should introduce pointers and explicit memory management. That outta fix those lazy bastards.
07:24:10 <osfameron> rovar: you could do it in a DSL!
07:24:26 <Zao> We obviously need a C-ish DSL.
07:25:03 <rovar> oh i know. How about a Random Transform Monad that has some random chance of executing the functions it contains
07:25:18 <applicable> how do I compile again? ghc --make -O2 Main?
07:25:33 <rovar> other times it returns the Left side of an Either like type called Hahaha or something
07:25:47 <applicable> how do I import my own module from the same dir?
07:26:13 <chessguy_work> lol, you guys are nuts
07:27:14 <applicable> how do I import my own module from the same dir?
07:27:36 <chessguy_work> applicable, dude, try some ritalin first
07:27:45 <rovar> import MyOwnModule
07:27:46 <rovar> ?
07:28:47 <rovar> if it's not picking it up, your current working directory may not be correct. you'll have to cd to the appropriate location 1st
07:29:27 <mm_freak> rovar: unfortunately that "Random Transform Monad" is not a monad
07:30:14 <mm_freak> it breaks the monad laws:  return x >>= f == f x;  c >>= return == c
07:31:31 <applicable> module Main where
07:31:31 <applicable> import Matrix
07:32:34 <applicable> they are in the same dir
07:32:42 <lilac> mm_freak: i suspect there's a way of getting it to work nonetheless
07:33:15 <quicksilver> applicable: what's the exact error message?
07:33:21 <rovar> mm_freak, only sometimes, that's the beauty of it :)
07:33:37 <applicable> works when compiling but no in ghci+emacs
07:33:42 <mm_freak> lilac: by making this randomness non-random ;)
07:33:46 <applicable> ould not find module `Matrix':
07:33:47 <applicable>       Use -v to see a list of the files searched for.
07:33:50 <mm_freak> rovar: lol true
07:33:54 <mm_freak> however, see you later
07:34:10 <quicksilver> applicable: your ghci is in the wrong directly.
07:34:11 <lilac> mm_freak: take a functor which does the random failing part, and use the free monad over that
07:34:14 <quicksilver> directory.
07:34:17 <quicksilver> damn typing.
07:34:39 <applicable> so how do I launch ghci form within a haskell module
07:34:39 <applicable> bvasiclaly i jsut want: load ghci with module Matrix
07:36:41 <applicable> but cant i just make it launch ghci+module Matrix when clicked?
07:37:18 <quicksilver> make your shell script cd to the correct directory first.
07:37:37 <rovar> and make sure emacs isn't moving you to the wrong directory
07:37:49 <rovar> trixie emacses
07:38:50 <quicksilver> well tricksy haskell-modes
07:39:01 <quicksilver> but his batch file won't be in emacs.
07:41:03 <tomh--> mm if you do import Prelude, why can't you do Prelude.() ?
07:41:11 <asgaroth> Can anyone suggest some freely available CS lectures about functional programming(perhaps with an emphasis on the math/theory) (optional: that use Haskell)?
07:41:28 <tomh--> asgaroth: look at our universities website
07:41:44 <tomh--> http://www.cs.uu.nl/wiki/FP/WebHome
07:41:52 <tomh--> and http://www.cs.uu.nl/wiki/AFP
07:42:13 <tomh--> i mean http://www.cs.uu.nl/wiki/Afp
07:43:12 <quicksilver> tomh--: you need import qualified Prelude to get the Prelude.Foo syntax.
07:44:12 <rovar> what is the idiomatic way to "pattern match" against a concatonated string?
07:44:26 <rovar> foo :: String -> Net ()
07:44:38 <rovar> foo x (delim ++ "quit")  ...
07:44:41 <asgaroth> tomh--: hmm, are the lectures available online somewhere(I get something that looks like an access denied error in Dutch on the first link) and can't see it on the wiki?
07:44:49 <koeien> > let f ('h':'e':'l':'l':'o':xs) = xs in f "helloworld"
07:44:51 <lambdabot>   "world"
07:44:52 <daf> rovar: use guards, or view patterns
07:44:55 <BONUS> you can only pattern match on constructors
07:45:02 <BONUS> and ++ isn't a constructor
07:45:03 <applicable> i did with python
07:45:04 <koeien> view patterns are the new solution
07:45:11 <applicable> ghci <filename>
07:45:15 * rovar looks up view patterns
07:45:18 <daf> foo x | "quit" `isSuffixOf` x = ...
07:45:54 <rovar> daf, i would like to insure that the delimiter is present as well
07:46:11 <daf> well, then:
07:46:35 <daf> foo x y | delim ++ "quit" == y = ...
07:47:18 <applicable> can I lsit alll functions in a module?
07:47:21 <tomh--> quicksilver: any reason why it needs to do that for prelude?
07:47:22 <redditbot> Ever wondered how big a closure is?
07:47:22 <redditbot> GHC on SPARC: Allocate!
07:47:22 <redditbot> Dana update: Core execution language, dependent combinators
07:47:22 <redditbot> Announced: The 5th Haskell Hackathon
07:47:27 <rovar> that seems somewhat redundant.. but it's explicit and simple, so it'll work for now :)
07:47:59 <applicable> if i want to rpovide a ghc+ghci+myModule as one package/binary, can I?
07:48:37 <tomh--> asgaroth: mm  seems to be dutch only ;/
07:49:17 <tomh--> quicksilver: for example if i build my own module Test i can use x and Test.x without qualified
07:49:30 <beelsebo_> http://www.cs.kent.ac.uk/people/rpg/tatd2/rof.png <-- google knows all :)
07:49:42 <asgaroth> tomh--: okay, then it's no use to me, although and I speak German and English and Dutch seems kinda like a mixture of both :)
07:49:53 <quicksilver> tomh--: only in ghci.
07:49:58 <quicksilver> tomh--: that's not a haskell feature
07:49:59 <quicksilver> AFAIK.
07:50:14 <quicksilver> ghci has a special purpose hack to always support qualified identifiers for everything.
07:50:23 <quicksilver> (lambdabot has something similar)
07:50:46 <tomh--> mm so if my program compiles in ghci, it might not in ghc?
07:51:16 <quicksilver> no.
07:51:26 <quicksilver> using it in source files won't work unless you import it qualified.
07:51:48 <tomh--> i can put it in source and then load it in ghci
07:52:01 <tomh--> that works
07:52:08 <tomh--> lemme see if it compiles with ghc
07:52:20 <quicksilver> hmm
07:52:24 <quicksilver> looks like I might be wrong.
07:53:18 <quicksilver> tomh--: I think actually the special case is ()
07:53:26 <quicksilver> you just can't do Prelude.()
07:53:31 <quicksilver> Prelude.Int should work
07:53:33 <quicksilver> (for example)
07:53:56 <quicksilver> wonder how I never knew that.
07:54:29 <tomh--> ah ok
07:54:51 <tomh--> well now you know :)
07:54:53 <tomh--> and me too
07:54:57 <quicksilver> quicksilver-- # being wron
07:55:04 <Saizan_> applicable: you want to use the ghc-api, or the "hint" package which is a simpler wrapper around it
07:55:12 <mreh> how can I "install" a module on my computer?
07:55:22 <mreh> so i can import it into everything i do
07:56:38 <mreh> rather than placing it the same dir as everything i develop that is
07:56:57 <quicksilver> mreh: make it into a package.
07:57:09 <mreh> it is
07:57:09 <quicksilver> in the ghc-pkg list sense of the word package.
07:57:18 <McManiaC> im trying to understand monads... can u see monads as "actions" which changes to current "world" whereas normal functions just change the data which u put into them?
07:57:36 <mreh> ghc-pkg list?
07:58:20 <Saizan_> mreh: "make it into a package" more or less means write a .cabal file for it and use cabal to install it
07:58:45 <BONUS> McManiaC: that's just the I/O monad that changes the "world"
07:59:28 <paper_cc> McManiaC: State, for example, changes the state of itself, and [] (the list monad) can execute your actions more than once
07:59:50 <mreh> okay, i'll look into it, thanks
08:00:03 <BONUS> basically monads are for computations that can be sequenced
08:00:53 <McManiaC> but is a "state" of a monad "static"? or do i have to pass it into the monad everytime i want to access it again?
08:02:03 <BONUS> i like to think of monads as boxes
08:02:21 <paper_cc> McManiaC: you have to pass it _only_ when you want to access it, before that time, it doesn't even exist
08:02:27 <paper_cc> (in the case of State)
08:02:37 <paper_cc> IO is special in this sense
08:02:52 <paper_cc> because its state is passed by the compiler to your main :: IO ()
08:03:23 <McManiaC> hmmmm
08:03:33 <McManiaC> still strange
08:03:34 <McManiaC> :D
08:04:13 <BONUS> basically you can think of something being a monad as being "funny"
08:04:40 <BONUS> ["haha"] is a funny string, just like Just "haha" is a funny string, only it's a different kind of humor
08:04:51 <BONUS> and moands come with an operation >>= which says
08:05:16 <BONUS> give me a funny A and a function that takes a normal A and returns a funny B and i'll give you a funny B
08:05:47 <BONUS> so in a sense you inject the A into the function
08:06:05 <BONUS> > (Just 3) >>= \x -> Just (show x)
08:06:07 <lambdabot>   Just "3"
08:06:18 <BONUS> [1,2,3] >>= \x -> [show x]
08:06:22 <BONUS> > [1,2,3] >>= \x -> [show x]
08:06:23 <lambdabot>   ["1","2","3"]
08:06:24 <BONUS> etc.
08:06:28 <paper_cc> > [2,4,6] >>= \x -> [show x, show (x+1)]
08:06:29 <koeien> > liftM show (Just 3)
08:06:29 <lambdabot>   ["2","3","4","5","6","7"]
08:06:30 <lambdabot>   Just "3"
08:06:49 <BONUS> see, it takes a funny something and a function that takes that normal something and returns a funny something else
08:07:15 <paper_cc> @where You could have invented monads
08:07:15 <lambdabot> I'm right here, silly.
08:07:26 <paper_cc> @google "You could have invented monads"
08:07:27 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:07:27 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
08:07:43 <paper_cc> ^^ that's very good to read btw
08:08:24 <McManiaC> hmmkay
08:09:21 <rovar> also, you might want a primer on Types in Haskell, I found this to be helpful:  http://learnyouahaskell.com/making-our-own-types-and-typeclasses
08:09:27 <rovar> BONUS might disagree
08:09:48 <BONUS> haha
08:10:11 <BONUS> yeah i think when a lot of people don't get monads, it's because they don't have such a good understanding of the type system beforehand
08:10:32 <rovar> the concept of a Monad was easy for me to grok, how it applied to programming is what twisted my head around. I've been coding in C++ for far too long.
08:10:57 <rovar> so yea, learning types is what solidified it for me
08:11:36 <paper_cc> @where+ "You could have invented monads" http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:11:36 <lambdabot> I will never forget.
08:11:49 <paper_cc> @where You could have invented monads
08:11:50 <lambdabot> I'm right here, silly.
08:11:55 <paper_cc> grr
08:12:09 <McManiaC> ill take a look at those links, thx =)
08:12:41 <quicksilver> @where "You
08:12:42 <lambdabot> could have invented monads" http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:12:51 <quicksilver> probably not what paper_cc meant to do :)
08:12:58 <rovar> I'm still an abject novice at Haskell.  Looking at the "you could have invented..." I got to Exercise One and was like "???"
08:13:36 <paper_cc> quicksilver: yep.
08:13:53 <BONUS> also i like this
08:13:58 <BONUS> http://www.haskell.org/haskellwiki/Monads_as_containers
08:14:01 <cschneid> what's the simplest web framework in haskell.  I want one that just maps urls & http verbs => functions.  (simplest == both amount and confusingness of code).
08:15:52 <rovar> cschneid, i'm not sure about relative ease, but the one with currently the most active support and development is happstack
08:16:16 <Saizan_> cschneid: the most simple might be fastcgi
08:16:19 <geezusfreeek> in my opinion it's hard to go wrong with plain ol' fastcgi for familiarity
08:17:01 <quicksilver> fastcgi doesn't actually provide a url to function map though, does it?
08:17:16 <cschneid> I've  asked this here before.  But I'm just learning haskell (Real World Haskell came yesterday), and I'm most familiar with the web, so I figured I'd start there.
08:17:16 <rovar> quciksilver, that sounds like a single data structure to me
08:17:20 <quicksilver> you have to write code which interrogates PATH_INFO and dispatches yourself.
08:17:23 <geezusfreeek> perhaps not, but it's pretty obvious how you might do it
08:17:29 <quicksilver> sure.
08:17:33 <quicksilver> I know, because I've done it :P
08:17:43 <quicksilver> (in several languages one of which is haskell)
08:17:58 <cschneid> what about one level lower: what's the most stable native web server I can hook into?  (rather than using apache & fastcgi).
08:18:18 <rovar> look at happstack
08:18:20 <geezusfreeek> happstack has a decent http server afaik
08:18:28 <geezusfreeek> and good url mapping built in
08:18:32 <rovar> #happs
08:19:01 <yesMen> hi
08:19:02 <quicksilver> happstack was forked from happs? or happstack *is* happs?
08:19:09 <geezusfreeek> kind of both
08:19:31 <yesMen> has anyone managed to build and install the haskell sdl in windows ?
08:19:33 <geezusfreeek> happstack is happs, revived
08:19:41 <paper_cc> because pure happs is orphaned
08:20:19 <cschneid> ok, I'll figure it  out.  Maybe I'll write my own super-simple one for learning purposes
08:21:52 <yesMen> im having lots of errors installing haskell sdl on windows
08:22:54 <mattam> @seen swiert
08:22:54 <lambdabot> swiert is in #haskell. I don't know when swiert last spoke.
08:23:11 <swiert> mattam: hi!
08:23:17 <mattam> Hi!
08:23:42 <mattam> Just wanted to check if you had an updated version of your TPHOLs pearl.
08:24:05 <mattam> But how's Sweden and testing?
08:24:05 <swiert> mattam: Yes. I can send you the latest draft.
08:24:14 <swiert> But I'm not sure how much has changed.
08:24:47 <swiert> Sweden's all right.
08:24:49 <mattam> Please do, I've just read the first and did not annotate it at all.
08:25:33 <swiert> Finally managing to get some work done, instead of spending all my time shoveling bureaucracy.
08:25:49 <swiert> Have you moved to Harvard yet?
08:26:17 <mattam> Good. I'm not there yet. I've waited 2 hours at the U.S. embassy and lost my day, today.
08:26:30 <McManiaC> <rovar> I'm still an abject novice at Haskell.  Looking at the "you could have invented..." I got to Exercise One and was like "???" <<< same
08:26:31 <McManiaC> :S
08:26:58 <swiert> Ugh. I'm moving within the EU and the hassle has already been annoying.
08:27:04 <z0d> What do you use for editing Haskell code?
08:27:26 <mattam> But that's completely OT, I spoke about Haskell and bug-free software to the consulate employee!
08:27:38 <quicksilver> z0d: emacs
08:27:39 <geezusfreeek> z0d, there is a pretty decent haskell-mode for emacs
08:27:46 <z0d> Thanks.
08:28:26 <swiert> mattam: Yeah - they ask you what you're going to do in the US. I had the same when I needed a visa for my Microsoft internship.
08:29:39 <mattam> It's quite funny, the guy immediately switched to trashing Vista and saying that even some features were restricted due to bugs in it, like cd burning (is it real?).
08:30:15 <flowerpower> sweden sucks!
08:30:56 <swiert> mattam: I was just thinking someone should write an essay about constructive mathematics for the Onwards! thing Simon advertised.
08:30:57 <Vq^> flowerpower: as long as it sucks less...
08:31:01 <swiert> mattam: any inspiration?
08:31:32 <mattam> Oh ah... something like Coquand's slides on constructive math and functional programming?
08:31:48 <Vq^> mattam: no idea, i haven't actually bumped into many bugs in vista
08:32:08 <flowerpower> eveyrhting is swedens fault! the halting problem, Coquand's slides, world war 1 etc!
08:32:27 <swiert> mattam: hmm. good one.
08:32:36 <mattam> http://www.cs.chalmers.se/~coquand/esop.pdf
08:33:16 <swiert> mattam: yeah - I found those a few days ago.
08:33:31 <mlesniak> Can anybody take a look at my problem with the transformation of if-else-if into one case-of? See http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1322#a1322 for the detailed code (which has only about 7 LOCs)
08:33:38 <swiert> I was googling Per's "Constructive mathematics and computer programming" which is impossible to find.
08:33:51 <swiert> mattam: but Peter Dybjer had a copy in his office of course :)
08:34:33 <mattam> hehe. Christine has secret copies of Thierry's articles as well, with fixed proofs of normalisation!
08:34:54 <quicksilver> mlesniak: case is for matching constructors
08:35:03 <quicksilver> mlesniak: not comparing by equality to abitrary expressions.
08:35:08 <quicksilver> you may consider using guards.
08:35:14 <swiert> mattam: yeah - that's the way it goes.
08:36:17 <mlesniak> quicksilver: Ok, thanks, but do I have another option to make this better?
08:36:36 <quicksilver> yes. Guards.
08:38:28 <mlesniak> quicksilver: Do you have an example how to incorporate guards into my example? I thought they very only for function definitions?
08:40:04 <cnwdup> mlesniak, you can use guards in a let.
08:40:10 <quicksilver> your example is rather small.
08:40:15 <quicksilver> with larger context it would be easier
08:40:16 <mlesniak> cnwdup: I see, thanks! Did not knew this
08:40:18 <quicksilver> but you can certainly do
08:40:28 <quicksilver> case () of () | o == a = blah
08:40:36 <quicksilver>           | o == b + 1 = blah
08:41:35 <tromp> which is just an ugly way to write a nested if ?
08:43:28 <quicksilver> perhaps.
08:43:35 <quicksilver> I don't find it particularly more ugly
08:43:35 <pumpkin> case () of () :o
08:43:39 <quicksilver> I find them both ugly.
08:43:50 <mlesniak> quicksilver: Hmm, quite right :-/
08:43:57 <vincenz> @join #oasis
08:44:02 <quicksilver> normally there is a sensible enclosing definition to attach the gurads to
08:44:12 <ozy`> when are we getting the "case of" extension?
08:45:20 <asgaroth> In that monad guide by stefan klinger(the one with the math and the "don't panic"), it is said that a set A with a partial order forms a category with the M = { (x,y) | x,y \in A, x <= y }. How am I to read this "(x,y)" syntax in the context of morphisms? Functions that transform x to y?
08:45:52 <quicksilver> asgaroth: morphisms from x to y.
08:46:13 <quicksilver> asgaroth: morphisms have a domain, a codomain, and a composition law.
08:46:27 <quicksilver> it's sometimes convenient to 'represent them' as their domain and codomain
08:46:34 <quicksilver> which is what he is doing there.
08:46:57 <quicksilver> "how are you to read it?" well, just as pairs (x,y) I suppose.
08:47:22 <redditbot> Parameterized Notions of Computation | Lambda the Ultimate
08:47:45 <asgaroth> excuse me(I only know high school math in a different language), the domain are the values the morphism maps from and the codomain the values it maps to?
08:48:33 <stepcut> as a GSoC project, I would like to see a version of Language.Haskell.Parser that can be easily extend to support arbitrary syntax extensions, such as inline literal XML (like HSP)
08:49:09 <vincenz> btw, I just noticed 'drop' is not as strict as it should be
08:49:17 <vincenz> drop should be strict in its first argument
08:49:23 <vincenz> > drop 100000000 $ [1..]
08:50:09 <quicksilver> asgaroth: Yes.
08:50:09 <quicksilver> asgaroth: although that's only an intuition. Morphisms don't really map anything.
08:50:09 <quicksilver> asgaroth: morphisms are a generalisation of maps.
08:50:14 <Apocalisp> @bot
08:50:14 <lunabot>  :)
08:50:48 <asgaroth> quicksilver: Okay, so I should get rid of imagining morphisms as functions, right?
08:50:51 <vincenz> > 1
08:50:51 <Saizan_> stepcut: btw, the author of haskell-src-exts was trying to make the syntactic extensions it supports (like inline XML) configurable
08:51:00 <quicksilver> asgaroth: well retain that as an intuition if you like.
08:51:01 <Apocalisp> @pl \y x -> if null x then y else x
08:51:08 <lambdabot>   thread killed
08:51:10 <lambdabot> :)
08:51:12 <lambdabot> join . flip (if' . null)
08:51:16 <lambdabot>   1
08:51:26 <quicksilver> asgaroth: just remember that morphisms are a strict generalisation of functions. That is, there aree certainly plenty of categories where morphisms are not functions.
08:51:28 <stepcut> Saizan_: neat!
08:51:39 <quicksilver> asgaroth: for example that one you just gave ;)
08:51:47 <quicksilver> where a morphism is merely the "Fact" that a <= b
08:51:58 <asgaroth> quicksilver: ah, thanks. I think that makes many things clearer
08:52:16 <asgaroth> Since I always tried to picture them as functions and that kinda failed in this case
08:52:21 * quicksilver nods
08:54:31 * asgaroth is amazed that one can walk in here with no significant math knowlegde and get these things explained in an understandable way
08:54:57 <dataangel> In an eagerly evaluated language, do foldr and foldl give the same results as in haskell or no? (on finite lists)
08:55:19 <geezusfreeek> asgaroth, i was not even all that interested in higher maths until i came here :)
08:55:32 <quicksilver> asgaroth: the time must have been right. You don't choose when to understand category theory. It chooses when you are ready.
08:55:37 <quicksilver> dataangel: Yes.
08:55:55 <quicksilver> dataangel: on those subset of programs which still terminate when evaluated eagerly, eager and lazy evaluation give the same results.
08:56:02 <tromp> > foldl (-) 0 [0,1]
08:56:03 <lambdabot>   -1
08:56:10 <quicksilver> dataangel: lazy evaluation makes a few more programs work, but it doesn't change any of the ones which already worked.
08:56:17 <tromp> > foldr (-) 0 [0,1]
08:56:19 <lambdabot>   -1
08:56:26 <asgaroth> geezusfreeek: Yeah, I'm kinda interested since I started with haskell, but haven't learned anything substantial in that area yet
08:56:38 <tromp> > foldr (-) 0 [1]
08:56:39 <lambdabot>   1
08:56:40 <dataangel> quicksilver: interesting, thanks
08:56:46 <tromp> > foldl (-) 0 [1]
08:56:47 <lambdabot>   -1
09:01:36 <ozy`> foldr (/) 0 [0..]
09:01:44 <ozy`> D'OH
09:01:49 <ozy`> > foldl (/) 0 [0..]
09:01:58 <lambdabot>   mueval: Prelude.read: no parse
09:02:16 <ozy`> > [True, True..]
09:02:19 <lambdabot>   <no location info>: parse error on input `]'
09:02:23 <ozy`> whoops
09:02:25 <ozy`> > [True, True ..]
09:02:27 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
09:03:18 <asgaroth> quicksilver: again about my mentioned category: the composition would be (x,y) . (y,z) -> (x,z), right?
09:03:27 <quicksilver> asgaroth: Yes.
09:06:54 <dons> ?yow
09:06:54 <lambdabot> Yow!  Am I having fun yet?
09:06:55 <dons> ?users
09:06:55 <lambdabot> Maximum users seen in #haskell: 661, currently: 638 (96.5%), active: 26 (4.1%)
09:07:45 <asgaroth> quicksilver: hmm, so the type information would be (A,A) x A x A?
09:11:26 <Philonous> Is there some "explode" function a -> [a]-> [[a]] which divides a list into it's part by a delimiter?
09:11:52 <asgaroth> Philonous: see Data.List.Split on hackage
09:12:17 <asgaroth> Since no one can agree on the One True Split there's this module with some variants
09:13:30 <quicksilver> asgaroth: type information of what?
09:13:36 <asgaroth> quicksilver: of the category
09:13:51 <Philonous> asgaroth: Thanks
09:13:54 <asgaroth> that big-Tau thing
09:14:10 <quicksilver> asgaroth: morphism compose is M x M -> M
09:14:18 <quicksilver> only it's not really, it's really M_(AB) x M_(BC) -> M_(AC) for all objects A B C
09:14:28 <geezusfreeek> did we ever surpass the 700 user mark here?
09:14:37 <geezusfreeek> i saw like 699 once
09:14:43 <ziman> @record
09:14:43 <lambdabot> Unknown command, try @list
09:14:45 <Philonous> It seems bizarre though to have a whole package just for splits.
09:15:21 <asgaroth> quicksilver: Since in my case the objects of that category are just that set with a partial order A, it's just M_AA x M_AA -> M_AA or am I missing something?
09:15:32 <asgaroth> *that set A with a partial order
09:15:33 <tromp> @src words
09:15:33 <lambdabot> words s = case dropWhile isSpace s of
09:15:33 <lambdabot>     "" -> []
09:15:33 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:16:00 <quicksilver> the type signature of a category is quite complex
09:16:00 <quicksilver> objects, morphisms, the relationship between objects + morphisms, and the composition rule for moprhisms.
09:16:09 <Gracenotes> I suppose, in Haskell', that we'll put the more common split methods in Prelude?
09:16:19 <quicksilver> Gracenotes: unlikely.
09:16:20 <Gracenotes> one can dream... -.-
09:16:26 <quicksilver> Gracenotes: certainly not unless someone proposes it.
09:16:41 <Gracenotes> it would be nice at least to get the functionality built into GHC
09:17:27 <quicksilver> asgaroth: no, if you set if A, you have objects (say) a,b,c in A, and the morphism composition is M_ab x M_bc -> M_ac
09:17:45 <quicksilver> although in the partial order example each of the hom-sets M_ab is either empty or has just one element.
09:18:34 <saml> :t unpackClosure#
09:18:36 <lambdabot> Not in scope: `unpackClosure#'
09:19:18 <asgaroth> quicksilver: ah, okay. so for instance, if one would use the natural numbers as that set, each number would be one such a or b?
09:20:19 <quicksilver> asgaroth: Yes, then the objects are the natural numbers. There is one morphism from 1 to 2 (because 1 <= 2) but there are no morphisms from 2 to 1.
09:21:16 <asgaroth> okay, I think I get it now, just the question remains: How would I formulate that type information(it's an exercise in that tutorial)?
09:21:24 <quicksilver> asgaroth: to compose the morphism from 1 to 2 with the morphism from 2 to 6, there is only one choice - the unique morphism from 1 to 6.
09:21:24 <quicksilver> this works precisely because partial orders are transitive.
09:21:42 <Cale> In fact, you don't even need a partial order.
09:21:47 <Cale> You only need a preorder.
09:21:48 <asgaroth> yes, I think I understood that part
09:22:33 <McManiaC> given the signature:
09:22:33 <McManiaC> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:22:40 <McManiaC> bind :: (a → StdGen → (b,StdGen)) → (StdGen → (a,StdGen)) → (StdGen → (b,StdGen))
09:22:41 <saml> @pl (\x -> )
09:22:41 <lambdabot> (line 1, column 8):
09:22:41 <lambdabot> unexpected ")"
09:22:41 <lambdabot> expecting lambda abstraction or expression
09:22:57 <McManiaC> why is the "solution" of bind the following
09:23:00 <McManiaC> bind f x seed = let (x',seed') = x seed in f x' seed'
09:23:06 <McManiaC> and not just
09:23:07 <McManiaC> bind f (x,xsg) = f x xsg
09:23:50 <dmwit> McManiaC: The second argument to bind is not a tuple.
09:23:58 <dmwit> So what would that mean?
09:24:04 <paper_cc> McManiaC: because x is a function
09:24:23 <McManiaC> i thought it returns a tuple ?
09:24:44 <dmwit> McManiaC: The first argument to bind is as function which, when applied to *two* appropriate arguments, returns a tuple.
09:24:44 <paper_cc> uncurry f $ x xsg if you wish then
09:24:58 <dmwit> McManiaC: But that's the first argument, and is totally unrelated to the second argument of bind.
09:25:16 <McManiaC> hm okay
09:25:29 <paper_cc> hmm
09:25:30 <asgaroth> quicksilver: So that type information this paper talks about(which is said to be a subset of M x O x O), would in my case be just {((x,y),x,y) | x,y \in A /\ x <= y}?
09:25:47 <paper_cc> :t \f -> (uncurry f .) . ($)
09:25:49 <lambdabot> forall a b c a1. (a -> b -> c) -> (a1 -> (a, b)) -> a1 -> c
09:25:58 <McManiaC> so "f `bind` g" returns a function h which has a signatura StdGen -> (b,StdGen)
09:25:59 <McManiaC> got it
09:26:00 <McManiaC> :D
09:26:09 <dmwit> =)
09:26:22 <paper_cc> McManiaC: that's the point of State =)
09:26:35 <dmwit> paper_cc: Shhh, let sigfpe tell the story. ;-)
09:27:03 <McManiaC> thats pretty cool
09:27:07 <McManiaC> hmmm =)
09:27:07 <lilac> bind f x = do v <- x; f v = \seed -> let (v, seed') = x seed in f v seed'
09:27:14 <dataangel> Anyone know what fold (foldr or foldl) this python code would correspond to? http://rafb.net/p/lte4bJ25.html It passes elements from the list as a first argument like a foldr but combines the starting value with the first element of the list rather than the last like a foldl. Is there a separate name for that or something?
09:28:02 <dons> sounds like foldl
09:28:07 <dons> just with arguments flipped?
09:28:12 <quicksilver> dataangel: your analysis is wrong.
09:28:14 <dmwit> Looks like foldr to me...
09:28:22 <dataangel> quicksilver: which part? :P
09:28:22 <quicksilver> dataangel: it doesn't combine the accum with the first element
09:28:26 <quicksilver> dataangel: it combines it with the last
09:28:28 <quicksilver> eventually
09:28:33 <dmwit> right
09:28:34 <quicksilver> because you keep slicing away at that array
09:28:42 <quicksilver> by the time the 'len(vect) == 1' is true
09:28:53 <quicksilver> the array has been sliced so it only contains the last element
09:28:55 <quicksilver> (not the first)
09:29:00 <dmwit> By the way, foldr is probably going to blow your stack in a strict language...
09:29:17 <paper_cc> do I understand right that the (Reader e) monad is just a fancy name for ((->) e) ?
09:29:30 <dmwit> paper_cc: yes
09:29:32 <quicksilver> "accum" is a very poorly named variable, too, since an accumulator is precisely what it is not ;)
09:29:45 <lilac> dataangel: the result is f(vect[3], f(vect[2], f(vect[1], f(vect[0], accum)))) so it's foldl' (flip f)
09:29:55 <dmwit> what!
09:30:03 <lilac> or more accurately it's foldl1'
09:30:04 <dmwit> What you just wrote is precisely foldr!
09:30:10 <Olathe> @src foldl
09:30:10 <lambdabot> foldl f z []     = z
09:30:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:30:11 <dataangel> quicksilver: In the initial call to fold, the length of vect won't be 1 (assuming we pass in a list with multiple elements). Which means foo(vect[0], accum) is called in the else clause, where vect[0] is the first element. Doesn't that mean it combines with the first element?
09:30:17 <Olathe> @src foldr
09:30:17 <lambdabot> foldr f z []     = z
09:30:17 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:30:21 <quicksilver> dataangel: yes, my analysis was also wrong.
09:30:23 <quicksilver> ;)
09:30:28 <lilac> dmwit: foldr would be f(vect[0], f(vect[1], f(vect[2], f(vect[3], accum))))
09:30:32 <quicksilver> it's foldr (reverse l)
09:30:32 <quicksilver> or foldl' (flip f)
09:30:38 <Toxaris> I would say it is accumulator-based foldl
09:30:52 <Toxaris> and I don't see why accum is not an accum here
09:30:55 <dmwit> urgh...
09:31:08 <dmwit> I need to study foldr and foldl again.
09:31:13 <geezusfreeek> lol, based on all the commotion this has caused i'd say it's not a haskell-like fold :P
09:31:18 <dmwit> I'll never get them right.  or left
09:31:25 <lilac> the first thing it combines with the accumulator is the leftmost element. so it's a left fold.
09:31:30 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
09:31:31 <quicksilver> it is haskell-like
09:31:38 <quicksilver> dmwit and I misread it in different but related ways
09:31:41 <lilac> it's clearly a strict fold.
09:31:43 <geezusfreeek> yes those fold diagrams are very nice
09:31:44 <McManiaC> unit = (,)
09:31:45 <quicksilver> which just shows we both need more coffee.
09:31:47 <lilac> and it fails on empty lists.
09:31:48 <McManiaC> why is this valid haskell??
09:31:49 <lilac> so it's foldl1'
09:32:02 <paper_cc> McManiaC: (1,2) is sugar for (,) 1 2
09:32:02 <quicksilver> McManiaC: (,) is the function which pairs things up
09:32:03 <lilac> McManiaC: (,) is the value constructor for 2-tuples
09:32:03 <dmwit> McManiaC: It's a section of the function \x y -> (x, y)
09:32:06 <quicksilver> > (,) 1 2
09:32:06 <geezusfreeek> :t (,)
09:32:08 <lambdabot> forall a b. a -> b -> (a, b)
09:32:08 <lambdabot>   (1,2)
09:32:11 <lilac> dmwit: no, it's not a section
09:32:15 <lilac> > (1,)
09:32:15 <lambdabot>   <no location info>: parse error on input `)'
09:32:16 <asgaroth> > (,) 1 2
09:32:16 <McManiaC> aaaaaaaaah
09:32:17 <lilac> see?
09:32:17 <lambdabot>   (1,2)
09:32:20 <dmwit> lilac: I know.
09:32:22 <Toxaris> lilac: not exactly foldl1, because you still pass an initial accum
09:32:24 <McManiaC> prefix <-> infix
09:32:27 <McManiaC> okay :)
09:32:35 <McManiaC> cool
09:32:36 <McManiaC> :D
09:32:44 <lilac> Toxaris: right you are.
09:32:53 <geezusfreeek> i wish you could do things like (1,) or (,2)
09:33:11 <lilac> then it's \f x xs -> foldl2' f (x:xs) ?
09:33:12 <dataangel> So it sounds like the consensus is, it's not quite a typical foldl or a typical foldr, so I'm not crazy ;)
09:33:12 <Gracenotes> (1(,))?
09:33:26 <Gracenotes> er, ((,)1). hm.
09:33:31 <geezusfreeek> (1,) ==> ((,)1)
09:33:33 <geezusfreeek> yeah
09:33:35 <Toxaris> > let fold f accum xs = case xs of [x] => f accum x; (x:xs) = fold f (f x accum) xs in fold f x [a, b, c]
09:33:36 <lambdabot>   <no location info>: parse error on input `=>'
09:33:45 <dmwit> > 1 `(,)` 2
09:33:46 <lambdabot>   <no location info>: parse error on input `('
09:33:47 <Gracenotes> then (,2) is (flip(,)2)
09:33:48 <lilac> dataangel: if it did something sensible for empty lists, or didn't take an initial accumulator, it'd be foldl' or foldl1'
09:33:52 <Toxaris> > let fold f accum xs = case xs of [x] -> f accum x; (x:xs) -> fold f (f x accum) xs in fold f x [a, b, c]
09:33:53 <lambdabot>   f (f b (f a x)) c
09:33:56 <dmwit> lilac: So it's not a prefix constructor, either.
09:34:02 <dmwit> lilac: So what do you want to call it? =/
09:34:28 <lilac> > 1 `(+)` 1
09:34:29 <lambdabot>   <no location info>: parse error on input `('
09:34:35 <lilac> it's an operator?
09:34:37 <lilac> hmm
09:34:41 <dmwit> Not quite.
09:34:43 <lilac> no
09:34:58 <lilac> > let fst ((,) a b) = a in fst (1,1)
09:34:59 <lambdabot>   1
09:35:06 <Gracenotes> ooh :x
09:35:09 <Toxaris> > foldl (flip f) x [a, b, c]
09:35:10 <lambdabot>   f c (f b (f a x))
09:35:26 <lilac> dmwit: it's syntactic sugar?
09:35:38 <paper_cc> > (,,,) 1 2 3 4
09:35:39 <lambdabot>   (1,2,3,4)
09:35:47 <dmwit> lilac: Basically, yeah.  But at different times, it helps to think of it as a section, or as a prefix constructor, or as an operator.
09:35:54 <Gracenotes> > iterate reduce (foldl (+) x [1, 2, 3])
09:35:55 <lambdabot>   [x + 1 + 2 + 3,x + 1 + 2 + 3,x + 1 + 2 + 3,x + 1 + 2 + 3,x + 1 + 2 + 3,x + ...
09:36:00 <Toxaris> so (fold f) is nearly (foldl (flip f)), but the last f is applied flipped
09:36:00 <lilac> dmwit: or ',' is a value constructor, but it needs to always be parenthesized?
09:36:03 <Gracenotes> eek. :)
09:36:13 <osfameron> :t reduce
09:36:13 <lambdabot> Expr -> Expr
09:36:28 <Gracenotes> > iterate reduce (foldl (+) 1 [2, 3, x])
09:36:29 <lambdabot>   [1 + 2 + 3 + x,3 + 3 + x,6 + x,6 + x,6 + x,6 + x,6 + x,6 + x,6 + x,6 + x,6 ...
09:36:32 <dmwit> > reduce (x + x)
09:36:34 <lambdabot>   x + x
09:36:44 <dmwit> reduce doesn't seem to do very much.
09:36:49 <saml> > reduce reduce
09:36:50 <lambdabot>   Couldn't match expected type `Expr'
09:36:57 <Toxaris> > reduce (1 + 2)
09:36:58 <lambdabot>   3
09:36:59 <dmwit> > enhance enhance enhance
09:37:00 <lambdabot>   Not in scope: `enhance'Not in scope: `enhance'Not in scope: `enhance'
09:37:08 <Toxaris> > reduce (x + (1 + 2))
09:37:09 <lambdabot>   x + 3
09:37:16 <saml> > reduce (f f f)
09:37:16 <Toxaris> cool
09:37:17 <lambdabot>   Add a type signature
09:37:21 <paper_cc> > reduce (1 + 2 + 3)
09:37:23 <lambdabot>   3 + 3
09:37:24 <Gracenotes> reduce is really only useful for Num literals that happen to be Exprs
09:37:25 <tromp> > (x + (1 + 2))
09:37:26 <lambdabot>   x + (1 + 2)
09:37:32 <paper_cc> > reduce.reduce (1+2+3)
09:37:33 <lambdabot>   Couldn't match expected type `a -> Expr'
09:37:45 <paper_cc> > reduce.reduce $ 1+2+3
09:37:46 <Gracenotes> in "reduce (1 + 2)", 1 and 2 are both actually Expr, not Integer or anything
09:37:46 <lambdabot>   6
09:37:52 <lilac> iterate reduce (foldr (\a b -> b - a * a :: Expr) [1..10])
09:37:54 <osfameron> @index reduce
09:37:54 <lambdabot> bzzt
09:38:07 <lilac> > iterate reduce (foldr (\a b -> b - a * a :: Expr) 0 [1..10])
09:38:13 <lambdabot>   [0 - 10 * 10 - 9 * 9 - 8 * 8 - 7 * 7 - 6 * 6 - 5 * 5 - 4 * 4 - 3 * 3 - 2 * ...
09:38:28 <lilac> > iterate reduce (foldr (\a b -> b - a * a :: Expr) 0 [1..3])
09:38:32 <lambdabot>   [0 - 3 * 3 - 2 * 2 - 1 * 1,0 - 9 - 2 * 2 - 1 * 1,-9 - 2 * 2 - 1 * 1,-9 - 4 ...
09:38:56 <lilac> @hoogle Eq a => (a -> a) -> a -> a
09:38:56 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
09:38:56 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
09:38:56 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:39:05 <lilac> ;(
09:39:05 <Toxaris> > reduce (f (1 + 2))
09:39:06 <lambdabot>   f 3
09:39:16 <Toxaris> thats only correct if f is strict
09:39:22 <Toxaris> so possibly quite misleading
09:39:48 <lilac> it's always correct, if the reduction terminates, isn't it?
09:40:01 <quicksilver> Toxaris: whether it is "correct" or not depends what you think 'reduce' is supposed to do ;)
09:40:06 <Gracenotes> Toxaris: of course it's strict ;) f isn't any arbitrary function after all, it's an Expr
09:40:13 <McManiaC> is
09:40:14 <McManiaC> unit :: a -> (StdGen -> (a, StdGen))
09:40:15 <paper_cc> @let iterate' f x = let xs = iterate f x in fst $ dropWhile (uncurry (/=)) $ zip xs (tail xs)
09:40:16 <lambdabot>  Couldn't match expected type `(a, b)'
09:40:18 <quicksilver> > reduce (f (1+2) (3+4))
09:40:18 <McManiaC> equal to
09:40:19 <lambdabot>   f 3 7
09:40:25 <McManiaC> unit :: a -> StdGen -> (a, StdGen)
09:40:26 <McManiaC> ??
09:40:27 <Toxaris> quicksilver: I think it is a tool for teaching Haskell operational semantics
09:40:32 <dmwit> McManiaC: yes
09:40:43 <lilac> @let untilEq f a | a' == a = a | otherwise = untilEq f a' where a' = f a
09:40:45 <lambdabot>  Defined.
09:40:49 <dmwit> McManiaC: (->) is right-associative
09:40:53 <quicksilver> Toxaris: I think it's a toy example of what you can do with Expr ;)
09:41:01 <lilac> > untilEq reduce (1 + 2 + 3 + 4 + x + 5)
09:41:02 <lambdabot>   10 + x + 5
09:41:04 <dmwit> McManiaC: And binds more loosely than type constructor application.
09:41:06 <quicksilver> Toxaris: otherwise it wouldn't reduce 'under' an arbitrary f.
09:41:09 <paper_cc> @let iterate' f x = let xs = iterate f x in fst.head $ dropWhile (uncurry (/=)) $ zip xs (tail xs)
09:41:10 <lambdabot>  Defined.
09:41:11 <McManiaC> dmwit: so the parantheses are for readability?
09:41:24 <quicksilver> McManiaC: yes, they're for emphasis in that particular context.
09:41:27 <paper_cc> > iterate' reduce (1+2+3+4+x+5)
09:41:29 <lambdabot>   10 + x + 5
09:41:33 <dmwit> McManiaC: The paretheses are to make the connection later in the tutorial more obvious.
09:41:35 <Olathe> > untilEq sin 10
09:41:41 <dmwit> McManiaC: So yes, readability.
09:41:43 <McManiaC> ok
09:41:50 <lambdabot>   thread killed
09:41:59 <lilac> > untilEq (/2) 1.0
09:42:01 <lambdabot>   0.0
09:42:05 <dataangel> lilac: Even in the case of foldl', isn't a left fold marked by elements from the list being passed as the second parameter to f, rather than the first?
09:42:10 <paper_cc> > iterate' (/2) 1.0
09:42:12 <lambdabot>   0.0
09:42:15 <Olathe> > untilEq (*2) 0.0
09:42:17 <lambdabot>   0.0
09:42:18 <hackage> Uploaded to hackage: sexpr 0.1
09:42:21 <Olathe> > untilEq (*2) 1.0
09:42:22 <lambdabot>   Infinity
09:42:37 <Olathe> > untilEq (/0) 1.0
09:42:39 <lambdabot>   Infinity
09:42:46 <Gracenotes> hm... it might make sense to define untilEq in terms of fix
09:42:46 <Olathe> > untilEq (/0) 0.0
09:42:53 * paper_cc thinks that iterate' / untilEq is like fix, but how?
09:42:54 <lilac> dataangel: that's almost irrelevant compared to the order in which the elements are given
09:43:02 <lambdabot>   thread killed
09:43:05 <yesMen> has anyone managed to build the haskell sdl pkg in windows ?
09:43:07 <Toxaris> dataangel: there is not much difference between f and (flip f), so this may be a nice convention in Haskell, but it is not really important
09:43:08 <Gracenotes> unfortunately finding a fixpoint with fix isn't as easy as the name might imply
09:43:09 <lilac> paper_cc: it gives you /a/ fixed point
09:43:44 <lilac> unlike 'fix' it does not give the least fixed point, but it needs extra information in order to do so
09:43:48 <dmwit> paper_cc: iterate' and untilEq are type-restricted, which means they can do slightly better than giving you the least fixed point.
09:44:03 <dataangel> lilac/Toxaris: If your operation isn't associative isn't it important? Not sure I understand.
09:44:10 * dmwit leaves the explanation to lilac, heh
09:44:11 <McManiaC> dmwit: but if you have a function that accepts another function, ie (a->b), u need the parantheses use the function as a variable? or could you leave them out aswell?
09:44:22 <paper_cc> lilac: can one use this fact to implement untilEq?
09:44:23 <dmwit> McManiaC: Then you need them.
09:44:25 <Toxaris> dataangel: but if the foldl you have happens to expect a flipped version of the function you have, just flip it
09:44:26 <dmwit> McManiaC: Think about it.
09:44:26 <ziman> :t untilEq
09:44:28 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
09:44:43 <Toxaris> dataangel: so its just a different API for the same functionality
09:44:46 <ziman> :t iterate'
09:44:47 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
09:44:51 <Toxaris> dataangel: but foldl and foldr differ in functionality
09:45:05 <paper_cc> ziman: well, untilEq == iterate' :)
09:45:08 <dmwit> McManiaC: When you realize how (a -> (b -> c)) and (a -> b -> c) mean the same thing, it will be an addictive revelation.
09:45:13 <ziman> oh, i see :)
09:45:16 <dataangel> Toxaris: ah, so the real semantic difference comes from whether we combine the initial value with the last element or the first one, not whether we pass list elements first or second?
09:45:19 <lilac> paper_cc: i doubt that. if f _|_ == _|_ then fix f = _|_, making implementing untilEq with fix tricky ;-)
09:45:23 <dmwit> McManiaC: At least... it was for me.  But different people have different tastes, so YMMV. =)
09:45:39 <Toxaris> dataangel: exactly.
09:45:51 <dmwit> lilac: nonsense
09:45:57 <dataangel> Toxaris: Why is it more like foldl' than foldl?
09:45:58 <McManiaC> dmwit: hehe
09:45:58 <dmwit> lilac: Any recursive function can be implemented with fix.
09:46:10 <lilac> dmwit: which part is nonsense?
09:46:14 <Toxaris> dataangel: because it is written in a strict language
09:46:23 <dataangel> Toxaris: that was my guess :)
09:46:32 <dmwit> lilac: The trick is that, although you provide untilEq with a function for which we might have f _|_ = _|_, you don't provide f directly to fix.
09:46:41 <Cale> It's really hard to write anything like foldr in that case though.
09:46:43 <dmwit> lilac: So fix can return something other than _|_.
09:46:52 <Cale> (or foldl)
09:46:52 <McManiaC> dmwit: so if you can "curry" a function you dont need parantheses?
09:46:58 <lilac> dmwit: my point was, i don't think you can implement untilEq with fix by exploiting the fact that untilEq returns a fixed point of f
09:47:05 <Cale> That is, if you're considering strictness.
09:47:10 <dmwit> lilac: ah, ah
09:47:29 <lilac> (or at least, not directly)
09:48:05 <dmwit> :t \f x -> fst . fix (uncurry (==)) (\(x, y) -> (y, f y)) . flip (,) x
09:48:07 <lambdabot>     Couldn't match expected type `(a, a)' against inferred type `Bool'
09:48:07 <lambdabot>       Expected type: (a, a) -> (a, a)
09:48:07 <lambdabot>       Inferred type: (a, a) -> Bool
09:48:16 <dmwit> whoops
09:48:37 <dmwit> :t \f x -> fst . until (uncurry (==)) (\(x, y) -> (y, f y)) . flip (,) x
09:48:39 <lambdabot> forall b. (Eq b) => (b -> b) -> b -> b -> b
09:48:52 <dmwit> :t \f x -> fst . until (uncurry (==)) (\(x, y) -> (y, f y)) $ (x, x)
09:48:54 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
09:48:56 <paper_cc> :t until
09:48:58 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
09:49:03 <DjZemich> Is it possible to define a new function on-the-fly in WinHugs?
09:49:10 <dmwit> DjZemich: Use "let".
09:49:13 <Cale> DjZemich: no
09:49:19 <Cale> dmwit: Only ghci has that.
09:49:25 <dmwit> oh, bugger
09:49:39 <Cale> DjZemich: The expectation is that you put definitions in a file, and reload the file when you make changes.
09:50:14 <DjZemich> So if I call a function which return an integer, if I then want to call another function with that integer, that is impossible?
09:50:14 <Cale> DjZemich: It's perhaps best to think of hugs and ghci as interactive debuggers of sorts.
09:50:24 <Cale> DjZemich: You just apply another function...
09:50:27 <Cale> f (g x)
09:50:47 <DjZemich> Yeah but I wan't to do it on-the-fly
09:50:52 <lilac> @type fix (\untilEq f a -> let a' = f a in if a' == a then a else untilEq f a')
09:50:53 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
09:51:06 <dmwit> DjZemich: Perhaps it wouldl be good to say what you mean by "on-the-fly".
09:51:25 <McManiaC> dmwit: one more question? =)
09:51:30 <dmwit> McManiaC: shoot
09:51:35 <McManiaC> dmwit: f * unit = unit * f = f and lift f * lift g = lift (f.g)
09:51:47 <McManiaC> dmwit: the f is always a "normal" function
09:51:50 <McManiaC> correct?
09:51:56 <sbahra> Cale, you can reason with all of axiomatic set theory (ZFC) using first order logic, yes?
09:51:58 <McManiaC> no monad or sth
09:52:09 <Cale> sbahra: yes, ZFC is a first order theory.
09:52:12 <dmwit> McManiaC: Let me take a look at the article, it's been a while since I read it.
09:52:15 <sbahra> Cale, great.
09:52:22 * sbahra is thoroughly enjoying his set theory class so far
09:52:35 <Cale> I don't really know anything about second order logic, to be honest.
09:52:52 <DjZemich> in WinHugs I can call a function who will give me an integer, I wan't to call another function with that integer, but how can i "safe" that integer
09:52:56 <dons> [laziness] gives Haskell some unique features such as the capacity to define
09:52:56 <dons> “infinite” data structures, it also makes it hard to reason about the
09:52:56 <dons> execution of programs since you can’t guarantee that lines of code will be
09:52:57 <dons> executed in any particular order (if at all)
09:53:02 <sbahra> Cale, I don't understand it too well, either. I have never found a reason to use it outside of philosophy.
09:53:08 <dons> its chaos, i tells ya!!
09:53:12 <Toxaris> dmwit: DjZemich wants the result of evaluation the last expression be safed in a variable, like "it" in ghci
09:53:16 <sbahra> Cale, but it allows quantifying over concepts and relations.
09:53:29 <dons> Cale: this guy needs a little clarification, he's well meaning though, http://stepheneasey.wordpress.com/2009/02/01/monad-madness/
09:53:35 <sbahra> Cale, forall F x. F x -> G x
09:53:45 <dmwit> DjZemich: You have to put an equation into a file for that.
09:53:58 <sbahra> Cale, do you know a part of mathematics that is "second-order"?
09:54:00 <Cale> DjZemich: I don't think you can. hugs only evaluates expressions. It doesn't allow you to make definitions interactively.
09:54:01 <sm> morning all.. could someone explain this darcs policy warning to me ? "readFile doesn't ensure the file is closed before it is deleted"
09:54:06 <dmwit> McManiaC: Let's see, x * y = unit x . y?
09:54:08 <sbahra> I think calculus?
09:54:11 <sm> and recommend a standard fix ?
09:54:38 <sm> in other words, it's telling me not to use readFile
09:54:39 <McManiaC> dmwit: i think so, yes
09:54:42 <DjZemich> Okay thanks.
09:54:49 <dmwit> McManiaC: Oops, no, x * y = bind x . y.
09:54:58 <McManiaC> dmwit: oh yes
09:55:00 <McManiaC> :D
09:55:06 <Cale> sbahra: Well, in some sense, my understanding is that ZFC obviates the need for a second order logic, because sets are always the first-order objects of discussion, and you can just form a set of the sets you're interested in, or quantify over the sets of sets you're interested in.
09:55:18 <sbahra> Cale, yes.
09:55:31 <McManiaC> dmwit: unit = (,)
09:55:32 <dmwit> Okay, so unit * f = bind unit . f, so f must return a monad type.
09:55:44 <chrisdone> I just lol'd at my own code. I just found: "maybe Nothing Just" in my code
09:55:48 <sbahra> Cale, and also everything must be a set though (x \in F, where x and F are sets).
09:55:51 <dmwit> chrisdone: heh
09:55:55 <sbahra> Cale, at least, this is where I have gotten with my formalization.
09:55:55 <Cale> DjZemich: In GHCi, you can prefix function and value definitions with 'let'
09:55:58 <lilac> @seen mjd
09:55:59 <lambdabot> I haven't seen mjd.
09:55:59 <dmwit> id :: Maybe a -> Maybe a
09:56:04 <Saizan_> sm: well, readFile uses lazy IO, and the Handle gets closed only when you've forced the whole file (and maybe the GC needs to run?), so you lose control over that file Handle
09:56:05 <chrisdone>   case maybe q Just $ maybe Nothing Just q' of
09:56:07 <Cale> DjZemich: and the result of the last evaluation is bound to a variable 'it'
09:56:30 <Cale> DjZemich: So if you're finding that it's getting in your way not to be able to do that, you can just switch :)
09:56:37 <chrisdone> q' >> q, heh
09:56:55 <DjZemich> Okay thank you :)
09:57:05 <Cale> sbahra: Right, in ZFC, everything is a set.
09:57:18 <Nafai> So what's the best way to get GHC 6.10 on Ubuntu Intrepid?  Just remove all Haskell packages and build GHC and install it in /usr/local and use cabal install for all libraries?
09:57:32 <chrisdone> Nafai: personally I do that
09:57:40 <dmwit> Nafai: You shouldn't need to remove other versions of GHC first.
09:57:57 <chrisdone> Nafai: I have configured it to install to ~/Programs/GHC and use cabal for all the packages
09:57:59 <dmwit> Nafai: You shouldn't need to build GHC, either; there are good binary distributions.
09:58:06 <dmwit> chrisdone: gobo?
09:58:13 <chrisdone> "gobo"?
09:58:15 <dmwit> oh, ~/Programs
09:58:29 <dmwit> I was wondering if your package management was inspired by gobolinux. =)
09:58:33 <chrisdone> ah
09:58:40 <Nafai> I'm find a lot of cool programs are demanding GHC 6.10, like hlint and Yi and so forth
09:58:46 <Nafai> And 6.8 is too old :)
09:58:55 <chrisdone> yes, too old!!
10:00:41 <McManiaC> why do i need sometimes "let ... in" and sometimes just "let"?
10:01:02 <gnuvince> McManiaC: just let is inside a do {} form
10:01:27 <gnuvince> McManiaC: it's explained in RWH
10:01:27 <Cale> McManiaC: do { let <decls> ; <stmts> } = let <decls> in do { <stmts> }
10:01:34 <McManiaC> ah ok
10:01:47 <McManiaC> ive read about it but forgot it again =)
10:01:53 <Cale> let ... in ... is an expression form, and can be used wherever an expression is needed
10:02:12 <Cale> This is in contrast with 'where' which is part of the syntax of function and value declarations.
10:02:41 <Cale> ('where' is a bit special in that it scopes over guards)
10:03:31 <Olathe> O-o
10:04:20 <Olathe> > let x = Just 5 in do { x' <- x; let x'' = x + 1; return x'' }
10:04:22 <lambdabot>   <no location info>: parse error on input `}'
10:05:49 <sm> thank you Saizan_.. I still don't quite see it alas
10:08:23 <samlee> > 1 ? 2
10:08:25 <lambdabot>   Not in scope: `?'
10:08:33 <samlee> > 1 ? 2 where 1 ? 2 = 3
10:08:36 <lambdabot>   3
10:08:40 <Nafai> Now I need to figure out how to tell cabal install to "re-install everything for this version of GHC"
10:09:07 <Saizan_> sm: "lazy IO" is a common name for when you defer the actual IO with unsafeInterleaveIO, so that it gets executed only when the result is requested
10:10:59 <sm> yes, that part I get
10:11:20 <gbacon> is the RWH code available, e.g., in a darcs repo?
10:12:09 <samlee> you mean docbook xml gbacon ?
10:12:30 <gbacon> samlee: no, the example code
10:13:14 <samlee> gbacon, i don't know. i'm sure someone has it though
10:19:19 <gbacon> ?ty handle (\_ -> return Nothing) (Just `liftM` act)
10:19:20 <lambdabot> Not in scope: `act'
10:19:30 <gbacon> ?ty \act -> handle (\_ -> return Nothing) (Just `liftM` act)
10:19:31 <lambdabot> forall e a ex. (ArrowError ex (->)) => ((e, ex) -> Maybe a) -> e -> Maybe (Maybe a)
10:19:45 * BMeph read "the Monad design pattern," and made a *VERY* rude noise at his desk...
10:19:49 <gbacon> ?ty handle
10:19:50 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
10:20:20 <gbacon> ?i handle
10:20:21 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
10:20:28 <BONUS> BMeph: link
10:21:28 <BMeph> BONUS: The same one dons linked a half-hour ago, http://stepheneasey.wordpress.com/2009/02/01/monad-madness/
10:21:32 * Nafai does some fancy stuff with ghc-pkg and shell to get things going
10:23:42 <BMeph> You have to love the very first sentence: "Monads come from the the Haskell programming language." Yep, you heard it here first! ;p
10:23:55 <dons> hehe
10:24:01 <dons> screw you, Moggi
10:24:53 <geezusfreeek> my favorite line is "Since lines of code can execute in any order, its impossible to do things which need to be executed in a sequence, which includes any form of I/O, acquiring locks objects in multithreaded code, reading/writing to sockets, and any concievable action which has a side-effect on any memory elsewhere in our application. "
10:30:41 <BONUS> If you can understand this much, then you can understand any monad.
10:30:42 <BONUS> lolol
10:31:15 <pumpkin> :o
10:32:54 <McManiaC> what exactly is $ ?
10:32:59 <ddarius> @src ($)
10:32:59 <lambdabot> f $ x = f x
10:33:01 <ddarius> It's id.
10:33:08 <McManiaC> okay
10:33:47 <StoneToad> McManiaC: lets you write stuff like print $ a + b instead of print (a + b)
10:34:24 <BONUS> because of its low precedence
10:34:25 <McManiaC> StoneToad: thats exactly why i asked =)
10:34:45 <BONUS> you can read it as: take the expression on the right and apply it to the function on the left
10:34:53 <BONUS> and you can imagine $ as being like really tall
10:34:53 <McManiaC> yup thx
10:35:34 <trin_cz> yaiks, monads in C#.
10:35:48 <McManiaC> ?
10:35:52 <ddarius> Monads have been implemented in just about any language you can imagine now.
10:36:04 <pumpkin> even brainfuck!
10:36:53 <trin_cz> well, implementing is not a problem. but readding the tons of code is.
10:37:07 <ddarius> @google Monads in Java
10:37:08 <lambdabot> No Result Found.
10:38:02 <ddarius> Someone needs to fix @google.
10:38:15 <McManiaC> =)
10:39:45 <Nafai> Yay
10:39:52 <Nafai> cabal installing everything for ghc 6.10
10:40:00 <Nafai> And then re-compiling xmonad
10:41:06 <mmorrow> preflex: seens rwbarton
10:41:08 <mmorrow> preflex: seen rwbarton
10:41:09 <preflex>  rwbarton was last seen on #haskell-in-depth 11 hours, 8 minutes and 23 seconds ago, saying: * rwbarton learned agda yesterday
10:41:09 <chrisdone> how do you work with Chars as numbers so that you can manipulate the numerical value given to the character in unicode?
10:41:48 <Deewiant> chrisdone: fromEnum
10:42:01 <chrisdone> ah, thanks
10:45:43 <rwbarton> mmorrow: yo
10:46:08 <mmorrow> rwbarton: hey. um, i just did an @tell but u guess lamdabot lost it
10:46:23 <rwbarton> yeah, I see it
10:46:35 <ddarius> mmorrow: You told pumpkinbot.
10:46:40 <mmorrow> ohh :)
10:46:48 <rwbarton> @seen pumpkinbot
10:46:49 <lambdabot> I saw pumpkinbot leaving #haskell 1m 16d 13h 46m 3s ago, and .
10:46:53 <mmorrow> heh
10:46:58 <rwbarton> preflex: seen pumpkinbot
10:46:59 <preflex>  pumpkinbot was last seen on #haskell-in-depth 3 minutes and 50 seconds ago, saying: Consider it noted.
10:47:23 <mmorrow> indirect evidence of @tell via preflex ftw
10:48:26 <gbacon> ?ty Control.Exception.handle
10:48:27 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
10:48:57 <gbacon> ?ty \act -> Control.Exception.handle (\_ -> return Nothing) (Just `liftM` act)
10:48:58 <lambdabot> forall a. IO a -> IO (Maybe a)
10:49:28 <gbacon> was the current lambdabot built with a ghc other than 6.10?
10:49:51 <gbacon> I get an ambiguous-type error for that code with 6.10
10:50:54 <gbacon> and the irritating part is that it's over the ignored parameter in the handler
10:55:48 <sOpen> is it possible to operate on thunks directly?
10:55:57 <sOpen> before evaluation, that is
10:56:16 <pumpkin> what would you want to do with them?
10:56:17 <geezusfreeek> sOpen, operate in what way? lazy evaluation already allows you to pass thunks around without evaluating them
10:56:42 <sOpen> pumpkin, suppose I want to simplify them
10:56:51 <pumpkin> simplify?
10:57:07 <sOpen> pumpkin, doing symbolic algebra
10:57:08 <geezusfreeek> sOpen, symbolic reduction?
10:57:13 <sOpen> geezusfreeek, yes
10:57:13 <pumpkin> a thunk is simply an instruction saying "do this if someone asks for me"
10:57:24 <sOpen> but i can't inspect the AST?
10:57:27 <geezusfreeek> sOpen, use an ADT for that, then evaluate it
10:58:29 <Cale> sOpen: You might be able to if language implementations were much more naive.
10:58:42 <sOpen> geezusfreeek, so I need to replicate, say, all of Haskell's operators? or build my own lazy structures?
10:58:56 <sOpen> Cale, how do you mean?
10:59:18 <geezusfreeek> sOpen, you only need to replicate the operations you want to simplify, which i assume is domain specific anyway
10:59:29 <Cale> sOpen: GHC compiles everything into native machine code. There are some remnants of graph reduction in how that code is structured, but it's not explicit.
10:59:50 <sOpen> Cale, oh that's right... ok
11:00:10 <Cale> sOpen: Also, things get inlined and transformed a whole lot, so there's not much guarantee about what you'd see anyway.
11:00:17 <sOpen> Haskell is not Lisp. Haskell is not Lisp. Haskell is not Lisp.
11:00:33 <sOpen> Cale, yes... that makes sense now
11:00:37 <sOpen> Thanks everybody
11:00:39 <sOpen> :-)
11:00:41 <lament> @faq Can Haskell be a Lisp?
11:00:41 <lambdabot> The answer is: Yes! Haskell can do that.
11:00:45 <Cale> hehe
11:00:54 <mmorrow> @faq CAN HAS STDIO?
11:00:55 <lambdabot> The answer is: Yes! Haskell can do that.
11:00:56 <Cale> sOpen: If you want to do transformations at compile time, there's TH
11:01:02 <Cale> sOpen: as well as RULES.
11:01:13 <sOpen> Cale, oh, cool, i'll look into those
11:01:15 <Cale> sOpen: But at runtime, functions are opaque.
11:01:31 <Cale> (you can only apply them if you want to see what they do)
11:02:12 <Cale> It's also important to referential transparency that functions be opaque. Functions that produce the same outputs for the same inputs should be entirely interchangeable.
11:02:18 <sm> cabal installing haddock 2.4.1 on my ubuntu intrepid says ld: cannot find -ledit
11:02:19 <sOpen> Cale, yes. I expect this makes things much smaller and faster
11:02:28 <Cale> And easier to reason about.
11:03:26 <Cale> If you start distinguishing \x -> x*x and \x -> x^2, then it becomes harder to understand how programs work.
11:04:38 <Cale> You certainly wouldn't want a program to break because you replaced one for the other.
11:04:39 <lament> @qc \x -> x*x == x^2
11:04:39 <lambdabot> Not enough privileges
11:05:02 <geezusfreeek> privileges??
11:05:09 <lament> :(
11:05:19 <geezusfreeek> @check \x -> x*x == x^2
11:05:20 <lambdabot>   "OK, passed 500 tests."
11:05:26 <lament> what's qc?
11:05:30 <geezusfreeek> no idea
11:05:33 <lament> @qc
11:05:33 <lambdabot> Not enough privileges
11:05:45 <lament> with the smart spellchecker, 'qc' could be almost anything
11:05:52 <geezusfreeek> @help qc
11:05:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:05:56 <geezusfreeek> @help @qc
11:05:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:06:16 <Deewiant> @rc
11:06:16 <lambdabot> Not enough privileges
11:06:19 <Cale> Probably it spell corrects to something
11:06:22 <Deewiant> @help rc
11:06:22 <lambdabot> rc name. Read a file of commands (asynchonously). FIXME: better name.
11:06:30 <geezusfreeek> haha
11:06:44 <geezusfreeek> needs a better name indeed
11:08:11 <Cale> Is it really named after the old shell, or am I not thinking clearly?
11:08:18 * sm installs libedit-dev for haddock success, and yay, no more internal error
11:08:31 <Deewiant> "Read Commands" -> rc?
11:08:45 <ksf> that's what rc stands for?
11:09:21 <Deewiant> I don't know about the original but that's what I'd guess for @rc
11:10:38 <ksf> indeed: http://en.wikipedia.org/wiki/Configuration_file#UNIX.2FLinux
11:11:33 <ksf> or, even better, http://www.catb.org/jargon/html/R/rc-file.html
11:13:17 * Nafai tries to compile gtk2hs with 6.10
11:14:23 <Nafai> Are there known issues?
11:14:26 <Nafai> I'm having problems
11:14:45 <Nafai> Getting this a lot:
11:14:46 <Nafai> tools/c2hs/base/general/Binary.hs:73:27: Module `Control.Exception' does not export `throwDyn'
11:14:49 <Nafai> make[3]: *** [tools/c2hs/base/general/Binary.o] Error 1
11:15:22 <dolio> Control.Exception did get significantly reworked.
11:15:24 <mauke> that looks like 6.10.1
11:15:31 <mauke> oh, hi
11:15:35 <Nafai> Yeah, 6.10.1
11:15:35 <dolio> You might have to use the base-3 compatibility.
11:15:46 <Nafai> How do I do that?
11:15:48 <mauke> gtk2hs-darcs compiled for me
11:15:57 <Nafai> Okay
11:16:50 <Nafai> Thanks
11:18:21 <asgaroth> Nafai: In general, add base<4 to the dependencies in the .cabal.
11:18:52 <dolio> I don't think gtk2hs builds with cabal, though.
11:23:35 <sereven> how/where in ~/.cabal/config do I set to run haddock --hyperlink-source on all user installed pkgs? flags: --hyperlink-source doesn't seem to do it.
11:25:45 <chrisdone> > let altZip = zipWith ($) $ cycle [fst,snd] in altZip $ zip [1..5] [10..15]
11:25:47 <lambdabot>   [1,11,3,13,5]
11:25:51 <chrisdone> anyone got a better definition for altZip?
11:25:55 <sereven> aha! bet it's -- prog-options
11:26:48 <Cheshire> :t zip3
11:26:49 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
11:26:53 <Cheshire> :t zipWith3
11:26:54 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
11:27:00 <Nafai> Interesting
11:27:15 <Cheshire> :t zipWith3 (cycle [const, flip const]) [1..5] [10..15]
11:27:16 <lambdabot>     Couldn't match expected type `a -> b -> c -> d'
11:27:16 <lambdabot>            against inferred type `[a1 -> a1 -> a1]'
11:27:16 <lambdabot>     In the first argument of `zipWith3', namely
11:27:21 <Nafai> The haddoc that ships with ghc 6.10.1 isn't new enough to build docs for gtk2hs darcs
11:27:35 <mauke> > concatMap (\(x,y) -> [x,y]) $ zip [1..5] [10..15]
11:27:36 <lambdabot>   [1,10,2,11,3,12,4,13,5,14]
11:27:37 <Nafai> haddock
11:27:46 <Cheshire> :t let ($$) f x y = f x y in zipWith3 ($$) (cycle [const, flip const]) [1..5] [10..15]
11:27:48 <lambdabot> forall t. (Enum t, Num t) => [t]
11:28:26 <chrisdone> > zipWith3 ($) (cycle [const,flip const]) [1..5] [10..15]
11:28:27 <lambdabot>   [1,11,3,13,5]
11:29:22 <Cheshire> ahah of course ($$) f x y = f x y is just ($) by eta reducing it
11:29:26 <chrisdone> mauke: good one
11:29:45 <mauke> which is id
11:30:47 <mmorrow> > zipWith3 id (cycle [const,flip const]) [1..5] [10..15]
11:30:48 <lambdabot>   [1,11,3,13,5]
11:31:16 <mmorrow> id++
11:31:40 <mauke> for extra silliness, id = ask and const = return
11:31:54 <chrisdone> heh
11:32:10 <mauke> also, flip const = const id
11:32:36 <mauke> > zipWith3 ask (cycle [return, return ask]) [1..5] [10..15]
11:32:38 <lambdabot>   [1,11,3,13,5]
11:32:59 <Olathe> @pl \a b -> b
11:32:59 <lambdabot> const id
11:33:37 <Olathe> @@ @pl @unpl flip const
11:33:38 <lambdabot>  const id
11:33:51 <chrisdone> I've tended to use const id without thinkinga bout it instead of flip const
11:34:07 <mreh> can i do an if then else in a "do" block that doesn't do anything on the else?
11:34:18 <mauke> :t when
11:34:19 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:34:24 <Olathe> mreh: fail on the else branch.
11:34:34 <Olathe> Ahh, when :)
11:34:37 <mauke> fail is pretty much the opposite of doing nothing
11:34:43 <Olathe> Yes :)
11:34:49 <mreh> yeah, i want to do nothing, not fail
11:34:51 <chrisdone> :hoogle whenM
11:34:57 <chrisdone> @hoogle whenM
11:34:57 <lambdabot> No results found
11:36:16 <geezusfreeek> fail is fail
11:36:30 <trofi> :t when
11:36:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:36:38 <trofi> :t lift
11:36:39 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
11:37:26 <chrisdone> > zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
11:37:28 <lambdabot>   "hail satan"
11:38:05 <mercury^> Sweet. :)
11:38:21 <Cheshire> @let unsteganogrify = zipWith3 ($) (cycle [const,flip const])
11:38:22 <lambdabot>  Defined.
11:38:30 <mmorrow> @remember chrisdone zipWith3 ($) (cycle [const,flip const]) "hai! haha!" "yarlysotense!"
11:38:30 <lambdabot> I will remember.
11:39:20 <mauke> > map (chr . (ord '@' +) . subtract (ord '0') . ord) . show$ 9/11
11:39:21 <lambdabot>   "@>HAHAHAHAHAHAHAHB"
11:39:38 <ziman> heh
11:39:41 <mmorrow> hehe
11:40:09 <chrisdone> hehe
11:46:07 <mreh> myPutStr (c:cs) = do putChar c
11:46:07 <mreh>                      when (cs /= []) putStr $ cs
11:46:28 <mreh> what have i missed here? the return type needs to be IO (), but when gives me a ()
11:46:48 <mauke> cs /= [] better written as not (null cs)
11:46:49 <pumpkin> you sure you don't want myPutStr in the recursive call?
11:46:56 <mauke> you should call myPutStr, not putStr
11:47:00 <mauke> misplaced $
11:47:14 <asgaroth> mreh: $ has to be after [])
11:47:18 <mauke> actually, the check is pointless
11:47:31 <mauke> myPutStr (c : cs) = do putChar cs; myPutStr cs
11:47:39 <asgaroth> mauke: why?
11:47:47 <anakreon> does operator <+> in arrows means choise?
11:47:49 <asgaroth> ah right
11:47:58 <paper_cc> :t (<+>)
11:47:59 <lambdabot>     Ambiguous occurrence `<+>'
11:47:59 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-33
11:47:59 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:55:0-46
11:48:06 <paper_cc> aargh
11:48:10 <pumpkin> ArrowPlus iirc
11:48:14 <asgaroth> :t (Control.Arrow.(<+>))
11:48:15 <lambdabot> Couldn't find qualified module.
11:48:18 <paper_cc> :t (Control.Arrow.<+>)
11:48:19 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
11:48:27 <paper_cc> anakreon: ^^
11:49:17 <anakreon> Strange. Ghci could not report the type of <+> although I had imported Control.Arrow
11:49:57 <anakreon> Still, the type tells it's a binary operator. Is it about choice though?
11:49:59 <mauke> works here
11:50:17 <paper_cc> @src ArrowPlus
11:50:17 <lambdabot> Source not found. My mind is going. I can feel it.
11:50:27 <paper_cc> , src ''ArrowPlus
11:50:29 <lunabot>  luna: Not in scope: type constructor or class `ArrowPlus'
11:50:32 <anakreon> I had typed :t (<+>)
11:50:40 <paper_cc> , src ''Control.Arrow.ArrowPlus
11:50:42 <lunabot>  luna: Not in scope: type constructor or class `Control.Arrow.ArrowPlus'
11:51:35 <paper_cc> @instances ArrowPlus
11:51:36 <lambdabot> Kleisli m
11:52:51 <paper_cc> @src ArrowPlus (Kleisli m)
11:52:51 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:53:43 <BONUS> well i recon it does mplus on the producing monads and returns that as one arrow
11:54:56 <BONUS> instance MonadPlus m => ArrowPlus (Kleisli m) where Kleisli f <+> Kleisli g = Kleisli (\x -> f x `mplus` g x)
11:55:00 <mopped> > let isPrime n = not $ any (\x -> n `mod` x == 0) [2..(ceiling $ sqrt n)] in isPrime 27
11:55:01 <lambdabot>   Add a type signature
11:55:07 <mopped> what's wrong with that?
11:55:23 <paper_cc> mopped: give it a numeric type
11:55:34 <paper_cc> > let isPrime n = not $ any (\x -> n `mod` x == 0) [2..(ceiling $ sqrt n)] in isPrime 27 :: Int
11:55:35 <lambdabot>   Couldn't match expected type `Int' against inferred type `Bool'
11:55:37 <paper_cc> ooops
11:55:40 <paper_cc> sorry
11:56:04 <paper_cc> > let isPrime n = not $ any (\x -> n `mod` x == 0) [2..(ceiling $ sqrt n)] :: Int -> Bool in isPrime 27
11:56:04 <byorgey_> anakreon: it depends what you mean by 'choice'.  If you want arrows which model computations that can choose between alternatives, then you want ArrowChoice
11:56:05 <lambdabot>   Couldn't match expected type `Int -> Bool'
11:56:05 <pumpkin> there's another issue
11:56:34 <byorgey_> anakreon: ArrowPlus is for arrows with a monoid structure, which isn't necessarily the same thing.
11:56:46 <paper_cc> mopped: aha
11:56:48 <Olathe> > let isPrime n = [2..(ceiling $ sqrt n)] in isPrime 27
11:56:49 <lambdabot>   [2,3,4,5,6]
11:56:50 <trofi> :t runST
11:56:51 <lambdabot> forall a. (forall s. ST s a) -> a
11:56:57 <byorgey_> I don't really know of any examples of using ArrowPlus though.
11:56:58 <paper_cc> you can't sqrt integer types
11:57:03 <Olathe> > let isPrime n = any (\x -> n `mod` x == 0) [2..(ceiling $ sqrt n)] in isPrime 27
11:57:04 <lambdabot>   Add a type signature
11:57:04 <mopped> aha
11:57:07 <pumpkin> byorgey_: apparently they're in xmonad
11:57:15 <paper_cc> > let isPrime n = any (\x -> n `mod` x == 0) [2..(ceiling $ sqrt $ fromIntegral n)] in isPrime 27
11:57:17 <lambdabot>   True
11:57:17 <pumpkin> byorgey_: someone was asking about them the other day regarding xmonad
11:57:20 <byorgey_> pumpkin: ArrowPlus? really?!
11:57:21 <Olathe> > let isPrime :: (Integral a) => a -> Bool; isPrime n = any (\x -> n `mod` x == 0) [2..(ceiling $ sqrt n)] in isPrime 27
11:57:22 <lambdabot>       Could not deduce (RealFrac a) from the context (Integral a)
11:57:23 <lambdabot>        aris...
11:57:36 <Olathe> > let isPrime :: (Integral a) => a -> Bool; isPrime n = any (\x -> n `mod` x == 0) [2..(ceiling . sqrt . fromIntegral $ n)] in isPrime 27
11:57:37 <lambdabot>   True
11:57:43 <trofi> :]
11:57:46 <Olathe> > let isPrime :: (Integral a) => a -> Bool; isPrime n = not $ any (\x -> n `mod` x == 0) [2..(ceiling . sqrt . fromIntegral $ n)] in isPrime 27
11:57:47 <lambdabot>   False
11:57:48 * byorgey_ greps the xmonad source tree
11:58:00 <pumpkin> byorgey_: he said he was trying to do something with xmonad and what did <+> do :P I tried to find it in the source tree afterwards and couldn't
11:58:01 <anakreon> pumpkin: I am using the operator with hxt. I think is used to choose between alternatives.
11:58:09 <mopped> thanks
11:58:26 <byorgey> pumpkin: ah, that's a custom operator for merging ManageHooks
11:58:27 <Olathe> You're welcome.
11:58:35 <pumpkin> byorgey: ah, I see
11:58:37 <asgaroth> pumpkin: it's also a shorthand for mappend in xmonad
11:58:46 <pumpkin> ah
11:58:46 <mopped> is there a terser method of deducing if a number is prime?
11:58:53 <paper_cc> that is, <+> has three meanings :(
11:58:55 <BONUS> hmm although it seems more logical for me that Kleisli f <+> Kleisli g = Kleisli (\(x,y) -> f x `mplus` g y)
11:59:01 <pumpkin> haskell needs a registry of allocated operators :P
11:59:09 <byorgey> oh, yeah, I guess it's just that ManageHooks are an instance of Monoid, and <+> is defined as a synonym for mappend
11:59:13 <asgaroth> hmm, that's what byorgey meant, since manage hooks are monoid
11:59:13 <asgaroth> s
12:00:24 <Cheshire> simply typed lambda calculus is the internal language of CCCs?
12:09:15 <chrisdone> @let removeDuplicates = join . map nub . group
12:09:16 <lambdabot>  Defined.
12:09:56 <Baughn> @type runLogic
12:09:57 <lambdabot> forall a r. Logic a -> (a -> r -> r) -> r -> r
12:10:06 <cognominal> what is the relationship between the haskell features implemented by ghc and haskell prime?
12:10:18 <mauke> chrisdone: what's the point of that?
12:10:22 <BONUS> chrisdone: how is that different from just nub
12:10:31 <mauke> BONUS: the type
12:10:39 <ziman> isn't map head sufficient in removeDuplicates?
12:10:40 <Baughn> cognominal: Haskell' codifies the GHC features that have the most support, pretty much
12:10:58 <cognominal> apparently I have some answer here : http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
12:11:03 <mauke> > map nub ["foo", "bar", "baz", "quux"]
12:11:04 <lambdabot>   ["fo","bar","baz","qux"]
12:11:12 <dolio> > join . map nub . group $ [3,3,3,2,2,3,3,2,2,2,3,3,3]
12:11:13 <lambdabot>   [3,2,3,2,3]
12:11:13 <BONUS> umm no
12:11:26 <mauke> oh, d'oh
12:11:28 <mauke> I'm sorry
12:11:39 <BONUS> @type join . map nub . group
12:11:40 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:11:49 <dolio> > map head . group $ [3,3,3,2,2,3,3,2,2,2,3,3,3]
12:11:50 <lambdabot>   [3,2,3,2,3]
12:12:29 <pumpkin> I prefer concat on lists
12:12:33 <Baughn> > observeAll $ interleave (return 3) (return 4)
12:12:35 <lambdabot>   [3,4]
12:12:36 <cognominal> thx Baughn
12:12:40 <pumpkin> unless you're being very monadic :P
12:12:59 <dolio> > join . nub . group $ [3,3,3,2,2,3,3,2,2,2,3,3,3]
12:13:00 <lambdabot>   [3,3,3,2,2,3,3,2,2,2]
12:13:06 <chrisdone> ziman: true map head is bettter
12:13:07 <byorgey> why not just 'map head' instead of 'join . map nub'?
12:13:36 <byorgey> oh, ziman already said that, soryr
12:13:40 <byorgey> *sorry
12:14:16 <chrisdone> > (nub "hello world",map head . group $ "hello world")
12:14:17 <lambdabot>   ("helo wrd","helo world")
12:16:09 <Baughn> > observe $ forM [1..10] (guard . (== 2))
12:16:10 <lambdabot>   * Exception: No answer.
12:16:27 <paper_cc> :t observe
12:16:28 <lambdabot> forall a. Logic a -> a
12:16:36 <paper_cc> @index Logic
12:16:36 <lambdabot> bzzt
12:16:44 <paper_cc> , src ''Logic
12:16:46 <Baughn> paper_cc: It's in the logict hackage-pacakge
12:16:49 <lunabot>  newtype Logic a = Logic {unLogic :: (LogicT Identity a)}
12:17:00 <ziman> > group [3,3,3,2,2,3,3,2,2,2,3,3,3] >>= nub
12:17:01 <lambdabot>   [3,2,3,2,3]
12:17:02 <roconnor> > 10/3
12:17:03 <lambdabot>   3.3333333333333335
12:17:15 <Baughn> I can't figure out what I'm doing wrong there, though
12:17:21 <roconnor> 300/90
12:17:23 <roconnor> > 300/90
12:17:24 <lambdabot>   3.3333333333333335
12:17:29 <roconnor> > 90/300
12:17:30 <lambdabot>   0.3
12:19:21 <Olathe> mopped: isPrime x = x > 1 && (all ((/= 0) . mod x) . takeWhile ((<= x) . join (*))) (2:[3,5..])
12:20:46 <Baughn> @pl foldr mplus
12:20:46 <lambdabot> foldr mplus
12:20:53 <Baughn> @pl foldr1 mplus
12:20:53 <lambdabot> foldr1 mplus
12:21:26 <anakreon> :t (-<<)
12:21:27 <lambdabot> Not in scope: `-<<'
12:21:32 <paper_cc> Baughn: rather, foldr mplus mzero ?
12:21:47 <Baughn> paper_cc: I suppose, but I know it isn't empty now, so..
12:21:51 <Baughn> @pl foldr mplus mzero
12:21:51 <lambdabot> foldr mplus mzero
12:22:00 <Baughn> ..I was hoping to get "mappend" or something similar
12:22:02 <Baughn> @type mappend
12:22:03 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:22:11 <Baughn> Er. mconcat?
12:22:14 <Baughn> @type mconcat
12:22:15 <lambdabot> forall a. (Monoid a) => [a] -> a
12:22:15 <ziman> msum?
12:22:18 <paper_cc> mconcat is for Monoids
12:22:19 <Baughn> @type msum
12:22:20 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:22:25 <Baughn> Oh, thanks. :D
12:22:42 <byorgey> worst. names. ever. =P
12:23:01 * paper_cc wants concat <- mconcat
12:23:09 <Baughn> > observe $ do a <- ((msum . map return) [1..10]); guard (a == 2); return a
12:23:10 <lambdabot>   2
12:23:17 <byorgey> paper_cc: yes, and  ++ <- mappend.
12:23:19 * geezusfreeek wants (++) = mappend
12:23:33 <byorgey> and  map <- fmap, and ...
12:23:59 <Baughn> We could have it, for that matter, in ghc 6.11
12:24:33 <Baughn> Using the same machinery that prefers base-3 to base-4 in hackage now.. alter the prelude in base-5 while maintaining backwards compatibility
12:24:59 <byorgey> that would be pretty great.
12:24:59 <idnar> > [1,2] `mappend` [3,4]
12:25:01 <lambdabot>   [1,2,3,4]
12:25:03 <paper_cc> btw I still don't understand why (MonadPlus a) != (Monad a, Monoid a) ... anybody wants mappend != mplus?
12:25:07 <idnar> > [1,2] `mplus` [3,4]
12:25:09 <lambdabot>   [1,2,3,4]
12:25:31 <idnar> paper_cc: there are a bunch of instances where they're not the same
12:25:37 <geezusfreeek> paper_cc, (Monad a, Monoid a) can't work. not the same kind
12:25:44 <ziman> can you give an example?
12:25:47 <paper_cc> :k Monad
12:25:47 <BONUS> idnar: which ones are those
12:25:53 <idnar> > Just "foo" `mappend` Just "bar"
12:25:53 <paper_cc> er
12:25:58 <BONUS> i always thought MonadPlus was just there for historic reasons
12:26:02 <lambdabot> Class `Monad' used as a type
12:26:03 <geezusfreeek> Monads are * -> *, Monoids are *
12:26:11 <lambdabot>   Just "foobar"
12:26:11 <idnar> wow, lagc
12:26:14 <idnar> > Just "foo" `mplus` Just "bar"
12:26:16 <lambdabot>   Just "foo"
12:27:04 <paper_cc> Why does one want such mappend?
12:27:10 <Baughn> byorgey: Well, then we just need to convince the GHC devs it's pretty great. :)
12:27:14 <idnar> > Left "foo" `mappend` Right "bar"
12:27:15 <lambdabot>       No instance for (Monoid (Either [Char] [Char]))
12:27:15 <lambdabot>        arising from a u...
12:27:21 <idnar> oops
12:27:21 <paper_cc> @instances Monoid
12:27:22 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:27:24 <BONUS> although there's no "monadic" reason, so to speak, for those two to behave differently
12:27:27 <BONUS> or is there
12:28:04 <McManiaC> i got one little question
12:28:05 <Baughn> byorgey: Maintain the old prelude as a separate module for import, or the default in base<5, then we can do whatever we like to fix it. :D
12:28:17 <McManiaC> im coming from scheme (lisp variant)
12:28:38 <idnar> BONUS: I'm not sure if you can define a MonadPlus instance that behaves like the Monoid one for Maybe
12:28:44 <McManiaC> and at university we had to do "check-expects" vor every version, where we executed the function to check if the function works as intended
12:29:06 <idnar> BONUS: the monoid instance is instance (Monoid a) => Monoid (Maybe a)
12:29:15 <paper_cc> McManiaC: are you looking for HUnit?
12:29:24 <idnar> so for MonadPlus, I think mplus would end up with an extra constraint it's not allowed to have?
12:29:30 <Baughn> McManiaC: That's lisp for you. No, you won't have to do that in haskell.. but what's the real question?
12:29:39 <McManiaC> is there something equivalent to that check in haskell? its actually really nice if you run your code and see sth like "all checks passed" in the interpreter
12:29:40 <idnar> (I'm really tired, so excuse me if I'm talking complete garbage)
12:29:45 <geezusfreeek> http://www.haskell.org/haskellwiki/The_Other_Prelude <-- see the MonadPlus and MonadOr type classes
12:29:50 <BONUS> yeaH. but is there a reason that the monoid instance doesn't behave like the MonadPlus one
12:29:50 <paper_cc> @where hunit
12:29:50 <lambdabot> http://hunit.sourceforge.net/
12:29:55 <Baughn> McManiaC: HUnit for unit tests, QuickCheck for fuzzer tests
12:29:59 <paper_cc> McManiaC: ^^
12:30:03 <pumpkin> sourceforge ftl
12:30:05 <geezusfreeek> there are two ways to interpret MonadPlus, and right now it's ambiguous
12:30:15 <idnar> BONUS: ah, well, I guess you could argue about that
12:30:20 <Baughn> McManiaC: In general, you want to use HUnit only for regression tests; bugs you /don't know about yet/ are much easier to catch with QuickCheck
12:30:22 <idnar> BONUS: I think the current behaviour is definitely useful, though
12:30:55 <BONUS> yeah, although it can be kind of confusing i guess
12:31:12 <idnar> I guess the thing is, if you want the MonadPlus behaviour, just use the MonadPlus instance :P
12:31:13 <McManiaC> Baughn: its more about "is the function doing what i want it to do or did i miss on sth?"
12:31:25 <McManiaC> less about bugs
12:31:43 <McManiaC> but ill take a look at those two tests
12:31:57 <idnar> uhm
12:32:03 <MacNala> I have a question: Is it possible to have a Haskell function or functions loaded into a another program structure eg C++ used as a procedure?
12:32:04 <idnar> < paper_cc> btw I still don't understand why (MonadPlus a) != (Monad a, Monoid a) ... anybody wants mappend != mplus?
12:32:14 <idnar> that should be (Monad a, Monoid (m a)) or something?
12:32:22 <paper_cc> yes it should
12:32:26 <Cheshire> Monad m, Monoid (m a)
12:32:47 <idnar> hmm
12:33:08 <idnar> @type liftM2 mappend
12:33:10 <lambdabot> forall a1 (m :: * -> *). (Monad m, Monoid a1) => m a1 -> m a1 -> m a1
12:33:11 <Baughn> McManiaC: If it doesn't, that /is/ a bug. :P
12:33:30 <McManiaC> Baughn: haha okay youre right :P
12:33:50 <idnar> @type mplus
12:33:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
12:33:54 <geezusfreeek> the reason that MonadPlus is not just (Monad m, Monoid m a) is because there is an additional law that has to go with it
12:33:54 <idnar> instance (Monad m, Monoid (m a)) => MonadPlus a where mplus = liftM2 mappend
12:34:26 <paper_cc> idnar: MonadPlus m, rather... this isn't valid Haskell
12:34:26 <idnar> @type mzero
12:34:28 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
12:34:29 <geezusfreeek> but it is controversial which of two possible laws it should be :\
12:34:41 <Baughn> McManiaC: At any rate, you'll want to use QuickCheck most. I may have said this before, but.. it's /very good/ at generating random tests based on a specification of how it /should/ work.
12:34:55 <pumpkin> dons: ping
12:35:06 <ziman> oh i see
12:35:06 <idnar> paper_cc: I meant MonadPlus m; why isn't it valid haskell?
12:35:37 <idnar> oh
12:35:44 <ziman> the Plus in MonadPlus may operate either on `a' or on `m a'
12:35:46 <idnar> hrm, tricksy
12:35:57 <paper_cc> idnar: you want to quantify over a in the constraint :(
12:36:00 <geezusfreeek> mzero >>= f = mzero is necessary, (a `mappend` b) >>= f = (a >>= f) `mappend` (b >>= f)  and  (return a) `mappend` b = a are disputable
12:36:25 <geezusfreeek> in any case, (Monad m, Monoid m a) is not enough to guarantee those laws
12:36:40 <McManiaC> is there any good "howto" / documentation for quickcheck?
12:37:10 <geezusfreeek> i typed something wrong there, but i think it's clear enough
12:37:12 <idnar> mzero >>= f = mzero fails for quite a few monoids, I think
12:37:54 <geezusfreeek> > mzero >> Just 5
12:37:55 <lambdabot>   Nothing
12:38:05 <geezusfreeek> works for that one :)
12:38:14 <idnar> mon/oids/
12:38:24 <idnar> > Nothing `mappend` Just 5
12:38:25 <lambdabot>   Add a type signature
12:38:36 <idnar> > Nothing `mappend` Just 5 :: Maybe Int
12:38:37 <lambdabot>       No instance for (Monoid Int)
12:38:37 <lambdabot>        arising from a use of `mappend' at ...
12:38:43 <paper_cc> :t Nothing `mappend` Just 5
12:38:44 <lambdabot> forall a. (Monoid a, Num a) => Maybe a
12:38:51 <idnar> oh
12:38:54 <idnar> > Nothing `mappend` Just "foo"
12:38:56 <lambdabot>   Just "foo"
12:38:58 <paper_cc> oh I see
12:39:00 <geezusfreeek> > Nothing `mappend` Just (Sum 5)
12:39:02 <lambdabot>   Just (Sum {getSum = 5})
12:39:19 <idnar> anyhow, yeah
12:39:23 <paper_cc> ... or don't I? grr to the generality...
12:39:36 <Olathe> > let primes = nubBy (\a b -> mod b a == 0) (2:[3,5..]) in primes !! 10000
12:39:36 <idnar> Could not deduce (Monoid a) from the context (MonadPlus m, Monad m, Monoid (m a1), Monad m)
12:39:51 <lambdabot>   thread killed
12:39:55 <idnar> why can't it just use magic?!
12:39:55 <Olathe> > let primes = 2:filter (\n -> all ((/= 0) . mod n . fst) . takeWhile ((<= n) . snd) $ pSq) [3, 5..] where pSq = map (\a -> (a, a*a)) primes in primes !! 10000
12:40:02 <lambdabot>   104743
12:40:28 <idnar> actually, I think I did something wrong there
12:40:38 <idnar> @type liftM2 mappend
12:40:39 <lambdabot> forall a1 (m :: * -> *). (Monad m, Monoid a1) => m a1 -> m a1 -> m a1
12:41:58 <idnar> Ambiguous constraint `Monoid a' At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
12:42:02 <idnar> heh
12:42:18 <hackage> Uploaded to hackage: monad-loops 0.3.0.1
12:42:18 <hackage> Uploaded to hackage: event-monad 0.0.1.0
12:42:31 <Cheshire> @hackage monad-loops
12:42:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monad-loops
12:43:19 <idnar> I wonder if there's some way around this
12:43:21 <true\false> Anybody got a good link regarding carried functions?
12:43:46 <Baughn> Curried, you mean?
12:44:10 <Baughn> true\false: http://haskell.org/haskellwiki/Currying
12:44:27 <dolio> @type \f g m n o p -> liftM g (liftM f (m `mappend` n) `mappend` o) `mappend` p
12:44:29 <lambdabot> forall r a1 r1 (m :: * -> *). (Monoid (m r), Monoid (m r1), Monad m, Monoid (m a1)) => (a1 -> r1) -> (r1 -> r) -> m a1 -> m a1 -> m r1 -> m r -> m r
12:44:36 <true\false> Hrm yes ta, I misread.
12:45:03 <dolio> @type \f g m n o p -> liftM g (liftM f (m `mplus` n) `mplus` o) `mplus` p
12:45:04 <lambdabot> forall a1 a a11 (m :: * -> *). (MonadPlus m) => (a11 -> a1) -> (a1 -> a) -> m a11 -> m a11 -> m a1 -> m a -> m a
12:46:15 <mmorrow> @pl \f g m n o p -> liftM g (liftM f (m `mplus` n) `mplus` o) `mplus` p
12:46:15 <lambdabot> ((((mplus .) .) .) .) . flip ((.) . (.) . (.) . fmap) . ((mplus .) .) . (. mplus) . (.) . fmap
12:46:47 <dolio> Also, write a Monoid instance for StateT.
12:47:09 <idnar> instance (Monad m, Monoid (m a)) => MonadPlus m where mplus = mappend doesn't work either
12:47:28 <redditbot> Boston Area Haskell User's Group meeting on February 28th at BlueSpec
12:47:38 <idnar> I'm not entirely sure why
12:47:39 <geezusfreeek> you would have to prove that m a is a monoid for all possible a
12:48:02 <dolio> Because 'a' is monomorphic in the context.
12:48:04 <geezusfreeek> but a is not in MonadPlus a
12:48:12 <geezusfreeek> err
12:48:15 <geezusfreeek> *MonadPlus m
12:48:54 <dolio> You're saying that if there is some a for which (m a) is a Monoid, then you can write mplus :: forall b. m b -> m b -> m b.
12:49:20 <idnar> oh
12:49:41 <idnar> right, it needs to be universally quantified
12:50:05 <dolio> It's impossible to express the right constraint in Haskell.
12:50:17 <dolio> Which would be something like 'forall a. Monoid (m a)'.
12:50:23 <idnar> well, I mean, the definition needs to be universally quantified, but I think I'm wanting it to be existentially quantified
12:50:42 <idnar> or...something?
12:50:54 <idnar> I'm not making much sense, let me go sleep rather
12:51:03 <paper_cc> no, you want universal quantification
12:52:58 <geezusfreeek> it may be informative to compare "instance Monoid a => Monoid (Maybe a)" vs. "instance MonadPlus Maybe"
12:53:02 <mmorrow> , ppDoc `fmap` (let mk n s = fmap varE `fmap` replicateM n (newName s) in do x:xs <- mk 4 "x"; fs <- mk 3 "f"; foldl (\a (f,b) -> [|liftM $f $a `mplus` $b|]) x (zip xs fs))
12:53:04 <lunabot>  liftM x_0 (liftM x_1 (liftM x_2 x_3 `mplus` f_4) `mplus` f_5) `mplus` f_6
12:53:12 <mmorrow> crap
12:53:18 <mmorrow> , ppDoc `fmap` (let mk n s = fmap varE `fmap` replicateM n (newName s) in do x:xs <- mk 4 "x"; fs <- mk 3 "f"; foldl (\a (f,b) -> [|liftM $f $a `mplus` $b|]) x (zip fs xs))
12:53:20 <lunabot>  liftM f_0 (liftM f_1 (liftM f_2 x_3 `mplus` x_4) `mplus` x_5) `mplus` x_6
12:54:48 <dolio> There's a monoid corresponding to the MonadPlus instance, though.
12:54:52 <dolio> It's just called First.
12:55:56 <geezusfreeek> dolio, yes, but the standard Monoid instance for Maybe *can't* be used for MonadPlus
12:56:04 <dolio> True.
12:57:33 <geezusfreeek> all MonadPluses are Monoids, but not all Monoids are MonadPluses, in other words
12:57:58 <BONUS> if we consider >> to be a function of the Applicative class, is it okay to define it as a >> b = fmap const b <*> a
12:58:18 <ziman> :t (*>)
12:58:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
12:58:42 <mauke> @src (*>)
12:58:42 <lambdabot> (*>) = liftA2 (const id)
12:58:42 <BONUS> yeah but is that implementation ok
12:59:08 <mauke> BONUS: that looks like it runs b first
12:59:25 <mauke> and also returns b
12:59:30 <mauke> @src (<*)
12:59:30 <lambdabot> (<*) = liftA2 const
12:59:34 <BONUS> ah hmm
13:00:18 <Olathe> > let orderedSub [] _ = []; orderedSub xs [] = xs; orderedSub (x:xs) yys@(y:ys) = if x == y then orderedSub xs ys else x:orderedSub xs yys in take 20 $ orderedSub [1..] primes
13:00:20 <lambdabot>   [1,4,6,8,9,10,12,14,15,16,18,20,21,22,24,25,26,27,28,30]
13:00:58 <dolio> >> does return b.
13:01:07 <ziman> well, b doesn't look like (f b) to me
13:01:08 <ziman> hm
13:01:19 <ziman> :t fmap const ?b
13:01:20 <lambdabot> forall a b (f :: * -> *). (Functor f, ?b::f a) => f (b -> a)
13:02:25 <dolio> @instances Applicative
13:02:26 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:02:36 <dolio> @instances-importing Control.Applicative Applicative
13:02:37 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
13:03:28 <mmorrow> newtype Foo a = Foo (IO a); instance Monad Foo where .....   Foo m >> Foo n = Foo (replicateM 42 m >> n)
13:03:31 <dolio> > let tell s = (s,()) ; a >> b = a <**> fmap const b in tell "foo" >> tell "bar"
13:03:32 <lambdabot>   ("foobar",())
13:03:45 <dolio> > let tell s = (s,()) ; a >> b = fmap const b <*> a in tell "foo" >> tell "bar"
13:03:47 <lambdabot>   ("barfoo",())
13:03:48 <gbacon> is it possible to implement hGetContents in Haskell? more generally, how can I avoid "over-sequentialization" in the IO monad?
13:04:15 <Cheshire> gbacon, it is implemented using unsafe functions
13:04:30 <gbacon> ...without having to push logic down inside IO?
13:04:36 <dolio> > let tell s = (s,()) in (tell "foo" *> tell "bar", tell "bar" <* tell "foo")
13:04:38 <lambdabot>   (("foobar",()),("barfoo",()))
13:04:53 <BONUS> gbacon: sure its possible
13:05:54 <pastah> @type ask
13:05:56 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
13:06:21 <Orphi> @seen dons
13:06:28 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 16m 3s ago.
13:07:04 <Orphi> hmm... I'm interested in getting a few open tickets for GHC fixed. Should I be asking in #ghc?
13:07:51 * Orphi considers using the Magic Words...
13:08:33 <Orphi> @seen dcoutts
13:08:33 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 20h 46m 39s ago.
13:08:42 <Orphi> oh. LOL.
13:08:43 <dcoutts> @arr!
13:08:43 <lambdabot> I'll keel haul ya fer that!
13:08:48 <Orphi> hahahah!
13:08:54 <Orphi> oh Duncan, it works every time ;)
13:09:20 <gbacon> Cheshire, BONUS: which docs explain how to do it?
13:09:33 <Cheshire> @src hGetContents
13:09:33 <lambdabot> Source not found. I feel much better now.
13:09:36 <Cheshire> oh....
13:09:49 <rovar> I'm tinkering with the code in the roll your own IRC bot.. when attempting to build the final example I run into a problem.
13:10:00 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1326#a1327
13:10:35 <Orphi> dcoutts: I'm looking at a couple of tickets for GHC and wondering if I can do anything useful to get them fixed.
13:10:52 <dcoutts> Orphi: oh yes? which ones
13:11:13 <mmorrow> rovar: it's on account of the new extensible-exceptions. you can do something like this if you want to catch just IO exceptions:
13:11:33 <mmorrow> catchIO :: IO a -> (IOException -> IO a) -> IO a; catchIO = catch
13:11:42 <mmorrow> or to catch everything:
13:11:56 <mmorrow> catchAll :: IO a -> (SomeException -> IO a) -> IO a; catchAll = catch
13:12:07 <Orphi> dcoutts: There's one that's just documentation. It looks really easy to fix - but it's been open for ages. #1891.
13:12:16 <mmorrow> (or just stick a type annotation in "(const $ return ())"
13:12:37 <mmorrow> e.g.  (const (return ()) :: SomeException -> IO ())
13:12:43 <mmorrow> e.g.  (const (return ()) :: IOException -> IO ())
13:13:11 <dcoutts> Orphi: yep, sounds like it should be straightforward
13:13:20 <rovar> mmorrow, thanks, that helped
13:13:38 <Orphi> dcoutts: OK, so is there some way I could write this myself and submit it?
13:13:40 <mmorrow> :)
13:13:42 <gbacon> Cheshire: to put it in a broader context, I'm thinking of the directory-search code in chapter 9 of Real World Haskell where the authors had to push iterator logic inside the search to avoid reading the entire directory
13:13:54 <chessguy_work> hmm. is hugs just being silly here? http://codepad.org/sliOhlaZ
13:13:55 <gbacon> is there no way to return a lazy result?
13:14:06 <mmorrow> gbacon: you can use a Chan for this
13:14:25 <mmorrow> (Chans use the equivalent of what hGetContents is using to get its effect)
13:14:48 <mmorrow> or you could do something like  data Step a = Done | Step a (IO (Step a))
13:15:30 <dcoutts> Orphi: yep, get the code with darcs, make the changes and darcs send in the patch. See http://hackage.haskell.org/trac/ghc/wiki/Building
13:15:37 <mmorrow> (in the Chan case, you'd forkIO a thread to do stuff and stick things in the Chan, and then start reading results from said Chan)
13:16:05 <BONUS> chessguy_work: hmm i found your problem
13:16:09 <Orphi> dcoutts: I didn't think GHC was using Darcs any more?
13:16:09 <BONUS> you are using hugs :]
13:16:19 <chessguy_work> BONUS, :)
13:16:26 <chessguy_work> BONUS, so strictly a hugs issue?
13:16:31 <skorpan> i'm getting this error and can't figure it out: alex.hsinc:66:57: Not in scope: data constructor `I#'
13:16:32 <Orphi> dcoutts: Either way, presumably if I'm only trying to change the HTML documentation, I don't need to be able to actually build the compiler...?
13:16:52 <BONUS> likely yeah, i can test this out in ghc
13:16:55 <kaol> what's needed to make Cabal do parallel builds?
13:16:59 <mmorrow> skorpan: it's in GHC.Exts
13:17:07 <mmorrow> @hoogle I#
13:17:07 <lambdabot> No results found
13:17:09 <skorpan> mmorrow: is that a library?
13:17:20 <skorpan> uhm, module
13:17:24 <mmorrow> skorpan: yes
13:17:28 <gbacon> mmorrow: right, they use the latter approach (data Iterate seed = ...) in their example, but having to rig up so much scaffolding feels un-Haskellish
13:17:28 <mmorrow> (assuming you have ghc)
13:17:37 <skorpan> so is that :m +GHC.Exts and then :l again?
13:17:56 <BONUS> execute should be Strategy s => Plan a s -> a
13:18:15 <skorpan> mmorrow: i tried :m +GHC.Exts and then :l File.hs and i still get the same error :(
13:18:21 <skorpan> (i'm using -XMagicHash btw)
13:18:36 <mmorrow> skorpan: you probably have to import GHC.Exts in the file
13:18:50 <chessguy_work> oh, duh
13:19:08 <mmorrow> gbacon: yeah, wanting IO lazily either needs unsafe operations or the iterate machinery
13:19:20 <gbacon> mmorrow: or Chans?
13:19:27 <dcoutts> Orphi: um, I think it does involve modifying code, because it's the output of -?
13:19:34 <mmorrow> gbacon: well, Chans use unsafeInterleaveIO internally
13:20:01 <gbacon> mmorrow, Cheshire, BONUS: thanks for your help
13:20:06 <dcoutts> kaol: cabal needs a dependency-based approach to building. Doing it in parallel is an easy extension, but the first part is a lot of work.
13:20:17 <mmorrow> gbacon: i see this as a limitation of using a monad for IO (i don't have a better idea ;)
13:20:24 <kaol> dcoutts: enough for a GSoC project?
13:20:46 <gbacon> mmorrow: am I correct in understanding this as one of the problems spj refers to as over-sequentialisation?
13:20:55 <dcoutts> kaol: there's been one already. Ask Saizan_. Are you looking for one for this year?
13:21:28 <mmorrow> gbacon: i'm not sure the context that quote is from, but it seems like you might be correct
13:21:29 <Orphi> dcoutts: Also, dons has posted a couple of performance-related tickets: #2271, #1434, #2270.
13:21:30 <kaol> one project to make Cabal do parallel builds?
13:21:54 <Orphi> dcoutts: These "look easy" to me, and yet nothing has happened to them for months.
13:22:01 <dcoutts> kaol: to do the dependency based build framework
13:22:38 <Orphi> dcoutts: I'd ask dons, but he doesn't appear to be around right now, so... ;)
13:22:56 <Orphi> dcoutts: Does fixing these require altering GHC itself, or just changing library code?
13:23:31 <dcoutts> Orphi: those three are just library code.
13:23:44 <gbacon> mmorrow: see "Open challenge 2" in https://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective-2.pdf
13:23:50 <dcoutts> Orphi: but they're core libs so need validating with a ghc build.
13:23:57 <mmorrow> gbacon: cool, thx
13:24:02 <gbacon> but in that context, he's talking about commutativity
13:24:05 <Orphi> dcoutts: so is it that we know what needs to be done but nobody has yet? or is there some more fundamental problem?
13:24:16 <kaol> so did that project succeed?
13:24:42 <skorpan> is there any nice way to have two different versions of ghc installed?
13:24:49 <dcoutts> kaol: yes, the project goals were achieved.
13:25:04 <dcoutts> Orphi: the first
13:25:17 <kaol> ok. what's missing, then?
13:25:45 <Orphi> dcoutts: so... what are the chances that I might be able to fix some of this myself? ;)
13:26:11 * paper_cc just noticed `class (Applicative m) => Monad m' in The Other Prelude. Humph.
13:26:52 <dcoutts> Orphi: pretty high, those 4 together would maybe take you a week or two. A few days to get to grips with the system and then no more than a day for each problem.
13:27:23 <Orphi> dcoutts: so this looks like a good task for a beginner then?
13:27:49 <dcoutts> Orphi: yes, though if you're looking for a GSoC project you'd want something bigger.
13:28:07 <Orphi> dcoutts: heh, isn't GSoC only for students?
13:28:53 <dcoutts> Orphi: sorry, I thought the context here was GSoC. If you just looking for some useful hacking tasks, those would be good starters.
13:29:19 <Orphi> dcoutts: more like... I want these particular tickets to be fixed, because they're annoying me.
13:29:36 <dcoutts> Orphi: an even better motivation :-)
13:30:08 <Orphi> dcoutts: Indeed. It's maddening to write a complex raytracer and have it spend 80% of its runtime in floor()...
13:31:13 <Orphi> dcoutts: so I guess the form here is to obtain a Linux system, download the GHC build tree and see if I can make it compile to start with...
13:31:52 <chessguy_work> BONUS, got it working: http://codepad.org/hUJohcw8
13:31:55 <Orphi> dcoutts: is there an IRC channel specifically for people trying to build/modify GHC?
13:32:06 <dcoutts> Orphi: yes #ghc
13:32:27 <dcoutts> Orphi: you don't have to do development on linux, but some people will say it's easier
13:32:39 <mmorrow> gbacon: ah, ok. hmm, while that comment can't be applied to IO in general, since ordering of effects usually matters, i think it does apply to the cases when you don't care what order the IO actions are executed in.
13:32:47 <Orphi> dcoutts: Heh. Have *you* tried compiling C on Windoze? It's Not Fun. ;)
13:32:59 <dcoutts> Orphi: I have, I use ghc to do it :-)
13:33:16 <Orphi> dcoutts: Heh, yeah... Well I've done that too once or twice. ;)
13:33:21 <gbacon> mmorrow: thank you
13:33:27 <mmorrow> :)
13:33:36 <Orphi> dcoutts: But I understand that GHC uses Autoconf, Automake, sed scripts, and all kinds of other POSIX stuff.
13:34:21 <kosmikus> any lambdabot admin here? I'd like lambdabot to be in #haskell-hac5, please :)
13:34:26 <chessguy_work> @ops
13:34:26 <lambdabot> Maybe you meant: docs oeis pl
13:34:36 <chessguy_work> @op
13:34:36 <lambdabot> Maybe you meant: . ? @ bf ft id map pl rc v wn yow
13:34:39 <chessguy_work> darnit
13:34:41 <mmorrow> @where ops
13:34:41 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:34:49 <chessguy_work> yeah, what he said
13:34:49 <mmorrow> i think it's just Cale though
13:35:10 * Orphi thought Cale was something similar to cabbage...
13:35:21 <mauke> @join #haskell-hac5
13:35:21 <lambdabot> Not enough privileges
13:35:24 <mauke> not again
13:35:28 <chessguy_work> kosmikus, what is #haskell-hac5?
13:35:31 <Cale> @join #haskell-hac5
13:35:44 <byorgey> Orphi: I believe you're thinking of Kale.
13:35:44 <kosmikus> the channel for the 5th Haskell Hackathon
13:35:54 <Cale> Orphi: That's kale.
13:35:54 <mauke> @echo test
13:35:55 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "mauke!i=mauke@p3m/member/mauke", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo test"]} rest:"test"
13:35:55 <byorgey> kosmikus: oh, when/where is that?
13:35:57 <Orphi> byorgey: ah, yes, possibly...
13:35:58 <kosmikus> thanks, Cale
13:36:07 <chessguy_work> @help echo
13:36:07 <lambdabot> echo <msg>. echo irc protocol string
13:36:09 <Orphi> Cale: er, yeah, sorry...
13:36:10 <kosmikus> byorgey: April 17-20, Utrecht, Netherlands
13:36:19 <kosmikus> see announcement today on haskell@haskell.org
13:36:28 <kosmikus> or alternatively haskell.org/haskellwiki/Hac5
13:36:31 <mauke> @msg #haskell test
13:36:31 <lambdabot> test
13:36:44 <byorgey> ah, cool.  I won't be able to make it, sadly
13:36:53 <kosmikus> why not?
13:37:01 <chessguy_work> byorgey, just figure out where on planet earth is as far from me as possible, and that's a pretty good bet to be where it is
13:37:09 <chessguy_work> good rule of thumb for hackathons
13:37:21 <kosmikus> chessguy_work: where are you located?
13:37:24 <byorgey> kosmikus: I'll be at a reunion for my choir from undergrad
13:37:33 <chessguy_work> kosmikus, virginia, US
13:37:37 <byorgey> chessguy_work: heh, I know what you mean
13:37:38 <kosmikus> byorgey: ok, good reason :)
13:37:50 <kosmikus> chessguy_work: heh, yeah. well, you should organize one in the US.
13:38:02 <kosmikus> there's been a Hac in Portland once, the very first.
13:38:17 <kosmikus> I think all the others have been in Europe though.
13:38:20 <geezusfreeek> chessguy_work, you are closer to more things than me at least. i'm in alabama
13:38:22 <byorgey> once upon a time there was talk of organizing a US hackathon, but it kind of fizzled.
13:38:23 <chessguy_work> kosmikus, that's about as far in the US from me as is possible :)
13:38:34 <kosmikus> sure.
13:38:41 <chessguy_work> geezusfreeek, virginia is not closer to portland than alabama :)
13:38:45 <kosmikus> alsmost the same as Europe :)
13:38:48 <chessguy_work> i don't think
13:38:56 <chessguy_work> kosmikus, yeah, and they're almost as weird :)
13:39:01 <kosmikus> :
13:39:05 <kosmikus> )
13:39:07 <kosmikus> grrr
13:39:15 <Nafai> Is there a way to install a specific version of a library with cabal install?
13:39:16 <kosmikus> my return key is too responsive ...
13:39:31 <byorgey> Nafai: sure, just cabal install library-4.3
13:39:32 <dcoutts> Nafai: cabal install foo-1.0
13:39:39 <Nafai> Ah, thanks ;)
13:39:51 <dcoutts> Nafai: or more generally you can use any constraint: cabal install 'foo >= 2'
13:40:01 <kosmikus> dcoutts: are you going to Hac5?
13:40:11 <geezusfreeek> chessguy_work, yeah i'm slightly closer to portland than you. just barely though
13:40:14 <dcoutts> kosmikus: yes, but I've not thought about it much yet
13:40:24 <kosmikus> dcoutts: great.
13:40:31 <Nafai> Is there a cabal uninstall ? :)
13:40:34 <byorgey> hmm, maybe I should organize an east coast US hackathon, now that I am actually at an academic institution and could provide some space =)
13:40:43 <dcoutts> Nafai: no, you have to undergister and rm files manually
13:40:47 <chessguy_work> byorgey, where are you?
13:41:02 <byorgey> chessguy_work: U Penn, in Philadelphia.  just a hop, skip & a jump for you =)
13:41:12 <chessguy_work> byorgey, oh cool, i have faimly in philly
13:41:21 <chessguy_work> and i've always heard good things about UPenn
13:41:26 <kosmikus> byorgey: you're working with Stephanie Weirich?
13:41:26 <byorgey> yeah, it's great =)
13:41:32 <byorgey> kosmikus: indeed
13:41:44 <kosmikus> cool. on the dependent types project?
13:42:00 <byorgey> something like that.
13:42:03 <chessguy_work> Pierce is at UPenn, right?
13:42:12 <byorgey> yup
13:42:30 <byorgey> I just had a meeting with him 10 minutes ago =)
13:42:33 <kosmikus> byorgey: sad you can't make it. I'd have loved to hear all about it. But you'll be at ICFP, I hope?
13:42:41 <chessguy_work> i thought his email the other week about teaching PL theory via theorem provers was fascinating
13:42:54 <byorgey> kosmikus: I will certainly try to be!
13:43:04 <kosmikus> nice
13:43:12 <kosmikus> we'll meet then
13:43:17 * edwinb might actually get to go to ICFP this year
13:43:19 <edwinb> this will be nice :)
13:43:22 <byorgey> cool, I'll look forward to it =)
13:43:46 <kosmikus> hi edwinb
13:43:52 <kosmikus> you could come to Hac5 too ...
13:43:55 <edwinb> hi kosmikus
13:44:01 <edwinb> Hac5, you say?
13:44:13 * edwinb hasn't been paying attention lately...
13:44:19 <kosmikus> byorgey: you could really organize the next Hackathon at UPenn. I think it would be great.
13:44:26 <kosmikus> edwinb: haskell.org/haskellwiki/Hac5
13:44:30 <edwinb> bah, I have plans that weekend :(
13:44:37 <byorgey> chessguy_work: yeah, it's pretty neat.  I'm auditing the class atm.
13:44:40 <edwinb> (unusually, that far in advance...)
13:44:41 <kosmikus> edwinb: too bad
13:44:50 <kosmikus> how are you these days?
13:44:52 <Beelsebob> ohhhh
13:44:54 <Beelsebob> utrecht
13:44:59 <Beelsebob> that's a sensible place for me to go
13:45:06 <kosmikus> Beelsebob: ?
13:45:06 <byorgey> kosmikus: maybe I will!  this summer, perhaps.
13:45:11 <edwinb> not so bad, trying to get more funding...
13:45:14 <edwinb> how are you?
13:45:32 <kosmikus> edwinb: lots of work, uncertain future :)
13:45:39 <kosmikus> edwinb: but fine, really.
13:45:41 <edwinb> sounds familiar :)
13:45:52 <chessguy_work> you have plans for april already?
13:45:53 <chessguy_work> geez
13:45:57 <edwinb> I gave a lecture on Java GUIs the other day. It seems so wrong...
13:46:02 <Beelsebob> kosmikus: Antwerpen -> Utrecht is easy
13:46:11 <edwinb> chessguy_work: this is unusual... I'm organising a Go teaching day on the 18th...
13:46:38 <Beelsebob> even doable daily
13:46:44 <kosmikus> Beelsebob: oh, I didn't know you're at Antwerpen
13:47:07 <kosmikus> hope to see you in April, then
13:47:11 <wli> Hmm. I wonder if I could use a continued fraction module working over rational function fields to compute the generalized continued fraction expansion of \int_{-\infty}^x \frac{e^{Kt}}{t^2+1} dt
13:47:14 <Beelsebob> will think about it
13:47:22 <Beelsebob> depends how various things go
13:47:57 <kosmikus> edwinb: Go is important as well, but is it as important as Haskell? :)
13:48:00 <chessguy_work> edwinb, oh cool, teaching people to play go?
13:48:09 <edwinb> it is hard to say which is more important
13:48:29 <edwinb> chessguy_work: more training people who already know
13:48:37 * geezusfreeek has never played go
13:48:41 <chessguy_work> edwinb, sounds like fun
13:48:42 <edwinb> terrible! :)
13:48:45 <kosmikus> edwinb: how good are you?
13:48:46 <geezusfreeek> i've always been casually interested
13:48:54 <edwinb> around 2 kyu. So really not that good at all...
13:48:58 <kosmikus> hehe
13:49:04 <kosmikus> already way better than me
13:49:06 <edwinb> I'm just organising, I hope to be taught myself ...
13:49:35 <chessguy_work> "The best players just suck less than the rest" - Garry Kasparov, paraphrased, about chess
13:49:39 <edwinb> heh
13:50:17 <geezusfreeek> it's so true though, at least when you are playing a game with a finite number of choices
13:50:46 <chessguy_work> well, we would suck pretty bad at games with infinite numbers of choices too :)
13:50:49 <kosmikus> geezusfreeek: you should try it. it's really fun, and I like it much better than chess. I just don't have the time for it ...
13:50:56 <Baughn> We don't /know/ how well it's feasible to play the game. The best possible player might just be 15 dan or something.
13:51:17 <Baughn> Go is finite only in a rather uninteresting sense. ;)
13:51:26 <chessguy_work> heh
13:51:31 <chessguy_work> that's a good quote
13:51:40 <tromp> show them the rules in haskell, combine the best of two worlds:)
13:52:10 <Baughn> Somehow I think the scoring might make up most of the ruleset
13:52:48 <tromp> http://homepages.cwi.nl/~tromp/go/SimpleGo.hs
13:52:58 <Nafai> Yay for having GHC 6.10.1 working!
13:53:01 <Cheshire> is it possible to always win Go?
13:53:04 <chessguy_work> don't worry, once i solve chess, i'll become goguy and start on go :)
13:53:08 <tromp> scoring is pretty short
13:53:13 <chessguy_work> shouldn't be too long now
13:53:14 <Baughn> Cheshire: No.
13:53:15 <geezusfreeek> goguy has a nice ring to it
13:53:24 <Cheshire> Baughn, even if you go first?
13:53:30 <Baughn> Cheshire: Absolutely not.
13:53:39 <Baughn> Cheshire: If you have /infinite/ time and space, then you can, but it isn't /feasible/
13:53:51 <Cheshire> Baughn, yeah I mean purely theoretically
13:53:52 <tromp> winning in go depends on komi
13:54:00 <geezusfreeek> so Go cannot be "cracked"?
13:54:03 <Baughn> Unless there are hidden regularities in the game that no human is capable of spotting that would let you do it. :P
13:54:12 <cjb> I don't think shusaku ever lost as black
13:54:14 <tromp> there's always a perfect komi, such that optimal play gives jigo (tie)
13:54:14 <Baughn> geezusfreeek: Not.. likely
13:54:18 <cjb> (in a time where komi didn't exist)
13:54:20 <kosmikus> well, Go is still a "tree game", so the theorems apply
13:54:22 <Cheshire> Baughn, but I thought there was a finite number of different games
13:54:28 <Baughn> The rules are too simple. It seems more likely for chess, I guess
13:54:39 <Baughn> Cheshire: Note the "feasible"
13:54:50 <Cheshire> in theory -_-
13:54:54 <tromp> go is solved up to 55 (by computer) or 7x7 (by human analysis)
13:54:56 <Baughn> 22:51 < Baughn> Go is finite only in a rather uninteresting sense.
13:54:57 <tromp> 5x5
13:54:58 <p_l> Cheshire: When branching factor is over 300, you give up :)
13:55:05 <geezusfreeek> okay, but Go is still a "tree game" in the sense that i imagine Cheshire means?
13:55:16 <chessguy_work> figures that the most interesting conversation of the day would start up just as i'm about to leave for the day
13:55:20 <Cheshire> I don't have a definition of tree game
13:55:21 <chessguy_work> leave work that is
13:55:29 <chessguy_work> i'll just have to follow along on my iphone app
13:55:30 <geezusfreeek> and my understanding is that it is just very very hard to prune that tree in a beneficial way
13:55:38 <Baughn> geezusfreeek: It's a total knowledge game. Those are always winnable for one player or the other; given that go allows you to pass, that means it's always winnable for black.
13:55:42 <cjb> Cheshire: "feasible" == "requires less than the number of total atoms in the universe to store state"
13:55:43 <roconnor> tromp: does black win?
13:55:54 <Cheshire> Baughn, "Those are always winnable for one player or the other" that's what I was asking :p
13:55:56 <tromp> what size and komi, roconnor?
13:56:04 <Baughn> geezusfreeek: ..well, a total knowledge game without chance as an element. :P
13:56:07 <roconnor> 5x5, all komi
13:56:08 <Cheshire> suddenly #haskell is full of finitists!
13:56:20 <tromp> yes, on 5x5 white can't even live
13:56:38 <roconnor> > maxBound :: Int
13:56:39 * p_l wonders if Shogi is "solvable" in the same way as Chess
13:56:39 <lambdabot>   9223372036854775807
13:56:46 <Baughn> Plareplane: It is
13:56:49 <kosmikus> Baughn: am I missing something? there might still be a winning strategy for white, even though it's less likely than that there is one for black.
13:56:49 <Baughn> Er, Plareplane
13:56:51 <Baughn> Er.. p_l
13:56:52 <roconnor> tromp: sooo, white gets 25 komi
13:57:07 <Baughn> kosmikus: If there is, then black can pass its first turn and become white
13:57:08 <tromp> yes, 25 is the fair komi on 5x5
13:57:09 <Draconx|Laptop> kosmikus, no, because black can pass off the first turn to white.
13:57:13 <p_l> Baughn: Even with "Paratroopers", as they are sometimes called? :)
13:57:27 <Baughn> kosmikus: Or.. hang on. Then white can pass too, which would call a game over, and white would win by komi.
13:57:30 <Baughn> Never mind. :P
13:57:32 <tromp> on 7x7 it looks like it should by 9
13:57:46 <roconnor> tromp: interesting
13:57:50 <tromp> on 2x2, fair komi is 1
13:58:07 <tromp> and on 1x2, it's 0 :)
13:58:13 <Baughn> p_l: Paratroopers?
13:58:13 <Heffalump> how do you know it's not a guaranteed draw?
13:58:22 <Draconx|Laptop> Heffalump, white wins draws in Go.
13:58:25 <Baughn> Heffalump: The rules of go prohibit draws
13:58:32 <Heffalump> ah
13:58:32 <roconnor> tromp: I just considered all 2x2 games
13:58:32 <kosmikus> Heffalump: komi is usually a fraction, or you say white wins on draws.
13:58:34 <Baughn> Heffalump: (White gets 7.5 extra points)
13:58:43 <tromp> draws can be prevented by including fraction in komi
13:58:46 <tromp> like 7.5 komi
13:58:46 <roconnor> tromp: It seems like there is only about 2 games.
13:58:49 <p_l> Baughn: "normal" Shogi allows you to reuse figures you captured from enemy, dropping them everywhere except last two? rows from you
13:59:05 <roconnor> tromp: maybe more if black plays badly
13:59:14 <p_l> Baughn: The result is that it's _very_ rare for a game to end in draw
13:59:15 <Nafai> Anyone know if there is problems with the latest darcs hlint?  I'm getting the following error:
13:59:19 <tromp> on what size? 1x2?
13:59:20 <Nafai> Building hlint-1.2...
13:59:20 <Nafai> Setup.hs: data/Hints.hs: copyFile: does not exist (No such file or directory)
13:59:21 <rovar> is there a fn to split a [Char] into [[Char]] delimited by spaces?
13:59:22 <roconnor> 2x2
13:59:26 <Baughn> p_l: So long as there is no chance involved, the number of possible states is finite, and both players have full knowledge of said state, then the game can be solved
13:59:29 <tromp> 2x2 has MANY MANY games
13:59:36 <Zao> rovar: words or lines
13:59:38 <tromp> you can never guess how many
13:59:38 <kosmikus> rovar: words
13:59:47 <dolio> > words "abc def ghi jkl mno pqr stu vwx yz"
13:59:49 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
13:59:52 <rovar> oh yea.. and unwords does the opposite
13:59:54 <roconnor> tromp: oh I suppose that if white has 3 stones, and black plays, then black captures all the white stones
13:59:57 <Baughn> p_l: (Decisions of the other player does not count as chance)
14:00:02 <tromp> yep
14:00:09 <rovar> unwords  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
14:00:10 <roconnor> tromp: okay, this is more intresting
14:00:17 <rovar> > unwords  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
14:00:19 <lambdabot>   "abc def ghi jkl mno pqr stu vwx yz"
14:00:19 <inimino> ooh, Go
14:00:21 <tromp> only superko prevents infinite recapturing
14:00:30 <roconnor> ah right superko
14:00:32 <inimino> ...which not all rulesets have
14:00:37 <Zao> > unwords . words $ " omg wtf "
14:00:38 <lambdabot>   "omg wtf"
14:00:45 <roconnor> ah: I suppose techincally superko doesn't consider symmetries
14:00:45 <Cheshire> so there can be infinite games
14:00:54 <dolio> @check liftM2 (==) (unwords . words) id
14:00:54 <roconnor> maybe it should
14:00:55 <lambdabot>   "OK, passed 500 tests."
14:00:58 <tromp> you can play a game trying to create as many of the 57 2x2 positions as possible
14:00:59 <cjb> don't think this follows
14:01:12 <cjb> it just means you have to exhaust the symmetries once each
14:01:16 <Baughn> roconnor: Superko is already hard enough to implement. Don't make me more work. ;-:
14:01:17 <cjb> at which point superko kicks in?
14:01:23 <cjb> I don't see why it would become infinite
14:01:24 <inimino> roconnor: rulesets are written with human players in mind
14:01:30 <roconnor> Baughn: I want super doper ko
14:01:32 <tromp> you just cant repeat a position that has alrd occured
14:01:37 <Baughn> cjb: Superko prohibits repeating any previous state of the game
14:01:47 <cjb> Baughn: I agree
14:01:53 <Zao> Unlines adds a trailing newline, so it's not quite the inverse of lines either.
14:02:01 <Baughn> As the total state space is finite, that means every game will end. A useful rule. :P
14:02:09 <chessguy_> you mean games are meant to be fun???
14:02:15 <Baughn> It might take longer than the lifetime of the universe, but it'll /end/.
14:02:22 <tromp> there are over 386 billion 2x2 games...
14:02:35 <roconnor> Baughn: not if the ultrafinitists have their way
14:02:44 <kosmikus> Baughn: yes, same with total programming languages :)
14:02:52 <roconnor> (meaning they think the game won't end)
14:03:01 <Baughn> roconnor: I've been trying to work out if goedel's theorem might be applicable to the laws of physics
14:03:08 <cjb> tromp: "the number of 2x2 games is at least 0.3 federal bailouts"
14:03:15 <inimino> heh
14:03:25 <Baughn> roconnor: If it is, it might be possible to do an infinite amount of computation in this universe. ;)
14:03:38 <tromp> yes, i wished i had a dollar for every 2x2 game....
14:03:44 <roconnor> Baughn: that is more of a question about the church turing thesis.
14:03:45 <lament> superko is yucky
14:03:57 <Cheshire> is Go Turing Complete? :P
14:03:57 <inimino> lament: why?
14:04:07 <inimino> Cheshire: no.
14:04:10 <cjb> tromp: I suggest becoming a bank that loses all its money :)
14:04:12 <lament> Cheshire: on an infinite board, sure.
14:04:15 <Cheshire> inimino, why not
14:04:18 <tromp> go is somewhere between pspace hard and expspace hard
14:04:26 <Baughn> Cheshire: Turing-complete requires infinite state-space
14:04:34 <tromp> depending on rules
14:05:05 <tromp> without superko, only basic ko, it's exptime complete
14:05:07 <lament> inimino: 1) it destroys a whole class of pretty games 2) it is too hard to keep track of while actually playing
14:05:19 <inimino> lament: agreed
14:05:20 <z0d> what is super go?
14:05:36 <therp> z0d: super ko
14:05:39 <tromp> superko is trivial to track in practical play
14:05:41 <Baughn> roconnor: I'm reading GEB now. I imagine I'll have a better grasp of this afterwards. :)
14:05:43 <inimino> lament: but computer go probably requires some concessions in the area of ruleset aesthetics
14:05:45 <z0d> Ohh. Sorry.
14:05:56 <tromp> since most moves are on a point never occupied before
14:06:04 <therp> Baughn: I think I'm reading GEB since about a year :)
14:06:06 <inimino> tromp: most!
14:06:10 <lament> inimino: sure, especially since in practice the differences are insignificant
14:06:19 <tromp> only in 2x2 it gets a little hard
14:06:26 <Baughn> therp: And once you're done.. there's a sequel.
14:06:29 <inimino> tromp: but see some pro games where the issue can actually come up
14:06:35 <therp> Baughn: I read that already
14:06:48 <tromp> the most complicated case in pro games has been triple ko
14:06:49 <cjb> inimino: few pros play with superko rules, though :)
14:06:54 <byorgey> Baughn: which sequel is that?
14:07:00 <therp> byorgey: metamagicum
14:07:01 <Baughn> byorgey: "I am a strange loop"
14:07:07 <inimino> tromp, cjb: right
14:07:13 <tromp> which is still easy to keep track of
14:07:13 <therp> baughn: oh probably we meant something different
14:07:16 <Cheshire> are these books worth reading?
14:07:25 <byorgey> Baughn: ah, I got that one for Christmas =)
14:07:25 <Baughn> Cheshire: They're required reading for all humans
14:07:30 <roconnor> Baughn: writing game software is annoying cause you have to cover all these cases that will probably never occur in practice.
14:07:41 <mmorrow> dolio: ping
14:07:42 <Cheshire> :/
14:07:42 <therp> Cheshire: GEB yes. metamagicum.. yes also, but it's not that refined wrt the writing style
14:07:43 <Baughn> Cheshire: Seriously. If you don't read it, you lose your license.
14:07:47 <tromp> superko is by far the most elegant of all methods to ensure game termination
14:07:47 <dolio> What up?
14:07:48 <byorgey> therp: Metamagical Themas, you mean?
14:07:49 <Cheshire> I got the impression it was probably bullshit
14:07:53 <Cheshire> but I haven't read it
14:08:13 <Cheshire> just because math books don't usually become best sellers..
14:08:14 <Baughn> Cheshire: Most certainly not
14:08:17 <therp> byorgey: yes. that's what I meant
14:08:25 <inimino> Cheshire: no, it's quite good.
14:08:27 <byorgey> therp: ok, yeah, I've read that one
14:08:41 <Cheshire> ok I guess I will read it some tim
14:08:46 <Cheshire> time
14:08:47 <mmorrow> dolio: hey, so i'm messing around with CPS state monad, and it seems that i need unsafeCoerce (which is used safely) to implement callCC for it. what are your thoughts on this? i'll paste
14:08:56 <lament> tromp: a game that has entered an infinite loop has effectively terminated, since the outcome is predictable
14:08:57 <inimino> Cheshire: it's not a mathematical treatise by any stretch, but it's a good introduction to a lot of widely-applicable ideas.
14:09:00 <Baughn> Cheshire: He might be /mistaken/ about strange loops being the essence of consciousness, but that doesn't detract from the rest of the book at all. (And besides, I suspect he isn't)
14:09:14 <roconnor> mmorrow: what is CPS state monad?
14:09:20 <mmorrow> (because the newtype for Cont in StateT s (Cont r) a provides the (implicit there) coercion)
14:09:23 <lament> tromp: so i see nothing wrong with declaring such a game as void once the situation arises
14:09:27 <mmorrow> @unmtl StateT s (Cont r) a
14:09:27 <lambdabot> s -> (a -> s -> r) -> r
14:09:34 <mmorrow> is my S
14:09:41 <therp> Cheshire: it's not a mathbook. it's a book about consciousness
14:09:42 <roconnor> mmorrow: stateT Cont is broken in the mtl IIRC
14:09:57 <tromp> voiding is awful. then you need to replay to decide a tournament
14:09:59 <inimino> ...yeah the stuff about consciousness could be a bit of a stretch
14:10:00 <Baughn> Cheshire: It's not about consciousness, it's about meta-mathematics
14:10:09 <Cheshire> mmorrow, perhaps a different 'Cont' like the formulation Chung-chieh Shan gave could avoid the coe.
14:10:13 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1328
14:10:13 <therp> inimino: I would say it's a good introduction why life is not trivial :)
14:10:31 <geezusfreeek> i haven't have any problems with statet cont...
14:10:32 <mmorrow> Cheshire: the coercion happens in StateT s (Cont r) a too, but in the Core
14:10:36 <Baughn> Cheshire: Paradoxes, goedel-incompleteness and all that stuff.. very nifty
14:10:41 <Baughn> Cheshire: It'll make you love math. :)
14:10:46 <mmorrow> why bother jumping through hoops?
14:10:50 <tromp> would you also suggst that voiding triple repetition in chess is an improvement?
14:10:52 <inimino> therp: Alright, I can probably buy that.
14:11:00 <Baughn> Cheshire: I might say, GEB is to math as Haskell is to programming
14:11:14 <mmorrow> dolio: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1328
14:11:21 <dolio> Why are you implementing callCC for this monad?
14:11:32 <mmorrow> dolio: because i felt like it :)
14:11:43 <Cheshire> hoops?
14:11:46 <mmorrow> (it's the same as using callCC in StateT s (Cont r) a)
14:11:59 <tromp> i say avoiding is better than voiding!
14:12:02 <lament> tromp: tourneys have their own rules anyway. They already take care of this situation without superko, and everything seems to work. Why should they change?
14:12:05 <lament> hehe
14:12:07 <Cheshire> actually on second thoughts I have absolutely no idea how you would embed that sort of type system in Haskell
14:12:20 <mmorrow> Cheshire: hoops := going through the trouble of defining the type differently/more-verbosely for the same effect
14:12:24 <roconnor> mmorrow: probably safe, because the sig of callCC is supposed to be ((a -> forall b. S s b) -> S s a) -> S s a
14:12:25 <Cheshire> oh nvm it's actually trivial I just realized
14:12:32 <mmorrow> yeah, it's definitely safe
14:12:43 <roconnor> mmorrow: what is the question?
14:12:53 <mmorrow> i'm just wondering if my "explanation" of why it's needed is indeed correct
14:13:05 <dolio> @type \f s k -> f (\a -> \_ _ -> k s a) s k
14:13:07 <lambdabot> forall t t1 t2 t3 t4 t5. ((t1 -> t2 -> t3 -> t4) -> t -> (t -> t1 -> t4) -> t5) -> t -> (t -> t1 -> t4) -> t5
14:13:23 <Cheshire> mmorrow, when I program in Haskell I don't tend to consider a problem solved if it uses unsafe functions
14:13:28 <mmorrow> the issue is that the forall'ed `o' gets confused with another `o1'
14:13:41 <applicable> how do I make games in haskell?
14:13:41 <tromp> they shld change because a decided game is preferable to a void game
14:13:42 <dolio> Oh, right.
14:13:47 <applicable> any opengl lib?
14:14:05 <dolio> mmorrow: That's because CPS transformed monads like this aren't first-class continuation monads.
14:14:15 <tromp> and the superko rule is no more complex than the void rule. in fact it's simpler
14:14:22 <dolio> Just like Identity a = forall r. (a -> r) -> r isn't a continuation monad.
14:14:23 <ziman> applicable, http://hackage.haskell.org/packages/archive/pkg-list.html <-- you can browse hackage to see what libs are available
14:14:25 <geezusfreeek> applicable, yup
14:14:27 <mmorrow> dolio: interesting
14:14:36 <roconnor> mmorrow: how come other libs don't have unsafe coerce?
14:14:50 <mmorrow> roconnor: because they use a newtype to get it
14:15:12 <tromp> japanese rules have 3 cases of repetition
14:15:14 <ziman> applicable, you can either browse categories or search "GL" using your browser on that page
14:15:22 <mmorrow> since i'm flattening it, i need to "implement the newtype manually"
14:15:23 <tromp> 1) cycles of length 2 are forbidden (basic ko)
14:15:35 <tromp> 2) cycles of length 6 are voided (triple ko)
14:15:56 <tromp> 3) other cycles are not mentioned, thus presumably allowed (infinite games)
14:15:58 <roconnor> mmorrow: what is the types of k and unsafeCoerce k ?
14:16:17 <geezusfreeek> mmorrow, why are you flattening statecont?
14:16:19 <tromp> so, you can have these 3 cases, or a single rule that deals with all cycles uniformly
14:16:26 <dolio> Off the top of my head, I'd say that that unsafeCoerce isn't safe. But I don't have an example that breaks it off the top of my head.
14:16:27 <mmorrow> roconnor: the type system thinks the `o' is another `o1'
14:16:29 <geezusfreeek> mmorrow, i ask because i'm doing essentially the same thing ;)
14:16:39 <mmorrow> geezusfreeek: for speed!
14:16:56 <roconnor> mmorrow: oh forall o. is in the type
14:16:58 <Cheshire> newtyping shouldn't have an effect on speed
14:17:00 <mmorrow> that S is twice as fast as (Strict) mtl State and unboxed tuple state
14:17:12 <tromp> plus, in practice, in 999 out of a 1000 games, there is no difference in behaviour
14:17:19 <mmorrow> Cheshire: it's not the newtype that reduces speed but the cps-ness
14:17:30 <mmorrow> i just personally don't want to sully the code with a newtype :)
14:17:30 <lament> tromp: I agree that the game described by go rules with superko has an elegant description.
14:17:46 <lament> it appeals to me a lot as a mathematician
14:17:50 <Cheshire> o_o
14:17:53 <mle> mmm, Go?
14:18:06 <mle> but do you want Positional superko or Situational superko?
14:18:07 <tromp> the japanese treatment of repetition can only be described as a kludge
14:18:11 <mmorrow> Cheshire: ;)
14:18:17 <tromp> i want positional superko
14:18:19 <lament> tromp: but as a game, i prefer go :)
14:18:21 <Cheshire> you choose unsafeCoerce over a newtyp
14:18:27 <mmorrow> Cheshire: ;)
14:18:28 <tromp> which is simpler
14:18:38 <tromp> and again, there's no difference in poratice
14:18:40 <mle> by only one bit, heh
14:18:44 <roconnor> mmorrow: I think your forall o. has something to do with this
14:18:51 <tromp> so no need to bring in additional state
14:18:56 <edwinb> some members of the British Go Association council are embroiled in a deep discussion over how to deal with superko...
14:18:59 <mle> hm, i think there are cases where it does make a difference, but they basically won't happen in real play
14:18:59 <edwinb> personally, I just play Go ;)
14:19:09 <mmorrow> roconnor: it does, but i'm not sure exactly how to say it
14:19:16 <tromp> positional superko is also easier to program
14:19:24 <cjb> edwinb: I wonder who that could be :)
14:19:37 <dolio> If you pull it out and make it "newtype S t s a = ..." then you can write callCC.
14:19:51 <edwinb> cjb: if you are familiar with the BGA I imagine you can guess :)
14:19:58 <dolio> But then it's not just a CPS implementation of State, it's a combination of State and Cont.
14:20:15 <Cheshire> do State and Cont commute?
14:20:23 <roconnor> mmorrow: can you really implement callCC with the forall o in there?
14:20:31 <roconnor> mmorrow: even forgeting the state?
14:20:39 <dolio> In mtl, StateT s (Cont r) is the same as ContT r (State s).
14:20:49 <dolio> But they could be different.
14:21:00 <roconnor> dolio: I don't think so
14:21:11 <lament> tromp: i think it's prettier that games may go on forever.
14:21:12 <roconnor> @unmtl StateT s (Cont r)
14:21:12 <lambdabot> err: `StateT s (Cont r)' is not applied to enough arguments, giving `/\A. s -> (A -> s -> r) -> r'
14:21:17 <roconnor> @unmtl StateT s (Cont r) a
14:21:17 <lambdabot> s -> (a -> s -> r) -> r
14:21:26 <roconnor> @unmtl ContT r (State s) a
14:21:26 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
14:21:32 <roconnor> different types
14:21:39 <dolio> roconnor: The former could roll back state changes, but it doesn't.
14:21:46 <Cheshire> ?djinn (s -> (a -> s -> r) -> r)   ->   (a -> s -> (r, s)) -> s -> (r, s)
14:21:46 <lambdabot> f a b c =
14:21:46 <lambdabot>     (a c (\ d _ ->
14:21:46 <lambdabot>           case b d c of
14:21:46 <lambdabot>           (e, _) -> e),
14:21:46 <lambdabot>      c)
14:21:55 <roconnor> dolio: well, StateT Cont is wrong in the mtl
14:21:57 <Cheshire> ?djinn (a -> s -> (r, s)) -> s -> (r, s)   ->   (s -> (a -> s -> r) -> r)
14:21:58 <lambdabot> f _ _ (a, _) _ _ = a
14:22:06 <dolio> Yes, I know. :)
14:22:08 <Cheshire> so there is no bijection between them
14:22:10 <mmorrow> roconnor: here are (the only two) tests/examples i've done http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1329
14:22:40 <mmorrow> dolio: oh interesting (re: rolling back state changes)
14:22:43 <mmorrow> hmm
14:23:04 <Cheshire> how do you know which is which?
14:23:06 <dolio> One of the original papers on the subject notes that you can implement callCC in two different ways.
14:23:20 <dolio> One it calls "debug" semantics, and the other is something like "regular" semantics.
14:23:21 <tromp> lament: i wld be bored watching a triple ko played out infinitely long:)
14:23:30 <roconnor> mmorrow: your forall o. fills me with fear because forall o. (a -> o) -> o is isomorphic to a
14:23:38 <mmorrow> what is the "subject" here? (so i can find said paper)
14:23:39 <roconnor> mmorrow: so how can you possibly implement callCC?
14:23:46 <dolio> And mtl chose "regular", even though it's already available with the other nesting.
14:24:01 <Cheshire> by coercing o into o' :p
14:24:13 <mmorrow> roconnor: this callCC implem is *identical* to the monadLib one for StateT s m a, where m has callCC
14:24:14 <roconnor> mmorrow: so how can you possibly *safely* implement callCC?
14:24:27 <lament> tromp: the game tree goes on forever, the actual game stops once the repetition is obvious
14:24:29 <mmorrow> it's just flattened
14:25:03 <mmorrow> (i believe that this is the case, but is what i'm trying to figure out)
14:25:07 <lament> tromp: superko destroys a bunch of otherwise valid and arguably very pretty infinite game trees
14:25:08 <roconnor> mmorrow: it can't be identical because you have a forall o. and they do not
14:25:11 * Cale likes the superko rule.
14:25:14 <dolio> mmorrow: Your CPSed state is not the same as StateT s m where m has callCC. It's the same as StateT s m where m is a CPSed identity monad.
14:25:31 <mmorrow> dolio: ah. ok, what dolio said then :)
14:25:34 <tromp> yes, by design
14:25:35 <mmorrow> oh.
14:25:36 <mmorrow> hmm
14:25:44 <dolio> And CPSed identity doesn't have callCC, because it's the identity monad.
14:25:49 <mmorrow> yeah, hmm.
14:26:00 <tromp> destroying infinite games is its while raison d'etre
14:26:05 <mmorrow> ok, so there must be a way to segfault it then?
14:26:05 <tromp> whole
14:26:09 <mmorrow> i don't see how
14:26:15 <roconnor> mmorrow: yes, let's find out how
14:26:19 <mmorrow> weeee!
14:26:23 <lament> tromp: right, which, as long as you find them pretty, is a bad thing :)
14:26:46 <tromp> by do you want to keep the basic ko rule then?
14:26:47 <dolio> Might be easier to figure out how to segfault the identity monad.
14:26:57 <mmorrow> i'll paste my Id..
14:26:59 <tromp> that destroys most repetition!
14:27:09 <tromp> but why
14:27:14 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1330
14:27:15 <dolio> newtype Identity a = I { unI :: forall o. (a -> o) -> o }
14:27:28 <mmorrow>   Id g >>= f = Id (\k -> g (\a -> unId (f a) k))
14:27:44 <lament> tromp: yes, that's certainly a flaw in my argument :)
14:28:20 <olsner> dolio: runIdentity . return . unsafeCoerce?
14:28:30 <rntz> @hoogle fix
14:28:30 <lambdabot> Data.Function fix :: (a -> a) -> a
14:28:30 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
14:28:30 <lambdabot> module Control.Monad.Fix
14:28:56 <dolio> callCC f = I (\k -> unI (\a -> I (\_ -> unsafeCoerce k a)) k)
14:28:59 <lament> tromp: which i'm willing to overlook by the same reasoning that nihon ki-in overlooks it: it's obviously required to play the game and is obviously an established part of the rules throughout the game's history
14:29:00 <Cale> iirc, there were some contrived cases in which infinite games could be played out and which didn't even contain an ordinary ko.
14:29:02 <mmorrow> callCC f = Id (\k -> unId (f (\a -> Id (\_ -> unsafeCoerce k a))) k)
14:29:06 <mmorrow> heh, beat me
14:29:23 <mmorrow> oh, you forgot the `f'
14:29:36 <cjb> Cale: well, "superko" doesn't have much to do with ko
14:29:43 <Cale> cjb: yes
14:29:50 <cjb> Cale: so maybe they contained no ko, but would still be prevented by superko?
14:29:56 <Cale> yes, that's what I mean
14:30:01 <cjb> (maybe this is obvi.. right)
14:30:21 <lament> cjb: no infinite games are possible with superko, since the board is finite
14:30:24 <Cale> However, they involved one player throwing away a group of something like 8 stones over and over again.
14:30:36 <tromp> yes, so we have a 2cycle rule that suffices for almost all cases
14:30:44 <cjb> lament: yes, that's what I thought, just being slow at working out what Cale meant
14:31:07 <tromp> now to deal with remaining cases, you can either simplify the existing rule to apply to all cycles
14:31:18 <tromp> or start voiding particular more complicated cycles
14:31:36 <Cale> Infinite cycles are bad.
14:31:39 <mmorrow> hehe, callCC for Id works!!
14:31:40 <tromp> the chose poorly:(
14:31:41 <roconnor> mmorrow: got a segfault yet?
14:31:42 <tromp> they
14:31:44 <mmorrow> not yet
14:31:48 <mmorrow> trying..
14:32:08 * roconnor needs to learn how to call a contination twice
14:32:14 <Cale> You want the outcome of a game to be determined.
14:32:26 <mmorrow> runId $ callCC (\k -> (*2) `fmap` (k =<< return 42))
14:32:33 <mmorrow> callCC (\k -> k =<< (*2) `fmap` return 42)
14:32:37 <Cale> If there are infinite cycles, then neither player loses.
14:32:44 <mmorrow> runId $ callCC (\k -> k =<< (*2) `fmap` return 42) -- i meant
14:33:07 <mmorrow> 42 and 84 resp.
14:33:30 <tromp> yes, we need losers!
14:33:35 <tromp> and winners:)
14:33:44 <rovar> someone feel like helping me make this prettier?
14:33:45 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1331#a1331
14:33:46 <roconnor> mmorrow: is that bad?
14:33:57 <mmorrow> it's not :)
14:34:13 <mmorrow> it works like it should weirdly enough
14:34:31 <mmorrow> so either (1) it's actually safe, or (2) there's some way to segfault it
14:34:40 <mmorrow> runId $ callCC (\k -> forever (k 42) >> return 99)
14:34:42 <mmorrow> 42
14:35:22 <mmorrow> i think this means that Id (forall o. (a -> o) -> o) is *not* isomorphic to `a'
14:35:32 <Cale> I'm reminded of the rule in, I think the Japanese rules, where if the players can't agree on the outcome of a game, then they both lose.
14:35:38 <Cheshire> rovar,
14:35:39 <Cheshire> eval (words -> "~id":rest) = privmsg rest
14:35:39 <Cheshire> eval (words -> "~shoo":rest) = write "QUIT" ...
14:35:39 <Cheshire> eval _ = return ()
14:35:44 <mmorrow> you get some extra structure
14:35:49 <cjb> Cale: I think it's more "the game is void and the players should play again" :)
14:36:05 <Cale> cjb: Well, both losing is different for purposes of tournaments.
14:36:14 <dolio> It means you use too much unsafeCoerce.
14:36:16 <cjb> oh, yes
14:36:26 <mmorrow> dolio: heh
14:36:33 <geezusfreeek> needs more cowbell
14:36:33 <cjb> but I don't think this is how Japanese rules work, because games with e.g. tripleko are replayed, not dual-lost
14:36:38 <rovar> Cheshire, that's pretty nifty looking. One thing, I'm trying to make this extensible for a couple dozen  ~functions. I figured at the very least I could factor out the
14:36:39 <rovar> ~
14:36:44 <cjb> but they could have changed over time or I could be misremembering :)
14:36:46 <lament> Cale: infinite game is not the same as indeterminate outcome
14:37:04 <mmorrow> dolio: but seriously here, do you see some way to segfault it? i'm trying to determine if this is safe to use or not.
14:37:20 <tromp> well, infinite games take longer to finish than undetermined ones...
14:37:31 <Cheshire> rovar, so you want to compute this function from a table of command * action pairs
14:37:36 <rovar> i guess i could wrap eval and pass in xs if x == ~
14:37:39 <rovar> Cheshire yea
14:37:53 <lament> Cale: e.g. in chess threefold repetition leads to a draw
14:38:08 <tromp> it can
14:38:13 <tromp> still has to be claimed
14:38:30 <Cale> lament: That's kind of like a slow version of the superko rule.
14:38:44 <Cale> (with a different outcome)
14:38:45 <lament> Cale: no, superko does not lead to any draws
14:38:52 <Cale> It leads to loss.
14:39:02 <lament> Cale: right, and sometimes it leads to things like living groups dying
14:39:18 <Cale> Well, assuming that the player doesn't play the invalid move.
14:39:21 <tromp> so does basic ko:)
14:39:54 <Cale> Superko is fair.
14:40:23 <Cale> The only thing which can really be said against it is that sometimes it's hard for players to remember if the position is a repeat.
14:40:42 <tromp> yes, that happens on 2x2...
14:40:44 <Cale> But for something like a computer implementation, I think it's great.
14:40:49 <rovar> Cheshire I suppose I should put the command/actions in an AL and hav eval lookup the appropriate action as long as the 1st char is a ~
14:41:01 <lament> Cale: optimizing go for computer play seems like a really dumb thing to do
14:41:13 <Cheshire> rovar, but you can match on the string to check if it starts with ~
14:41:20 <lament> Cale: otherwise, yes
14:41:24 <rovar> sure
14:41:26 <lament> i'm fine with superko on KGS or whatever
14:41:36 <lament> (KGS does NOT have superko, does it?)
14:41:41 <tromp> it does
14:41:44 <lament> ahh good
14:41:44 <Cale> lament: Well, on a real board, I think I would agree to superko, but if we got into a situation where it actually applied, we'd probably stop and get some paper or something to keep track :P
14:41:47 <mle> superko can still lead to draw on even boards with zero komi, e.g. 4x4
14:41:51 <geezusfreeek> sounds more like using the computer to optimize go rather than optimizing go for the computer, but i'm not a go player
14:41:53 <tromp> choose some ruleset other than japanese
14:42:22 <lament> what happens if you get an infinite game with the japanese ruleset on KGS?
14:42:31 <tromp> nothing
14:42:35 <Cale> lament: Better hope that it's a timed game?
14:42:38 <Cale> heh
14:42:44 <cjb> else you get bored and log off :)
14:42:52 <mmorrow> dolio, roconnor: i think the fact that `o' is forall`ed is precisely _why_ it's safe. for one reason or another the type system just can't see that. (?)
14:42:52 <Baughn> lament: Game goes on until the players decide to switch rules. ;)
14:43:00 <chessguy_> > fact 25
14:43:00 <lambdabot>   Not in scope: `fact'
14:43:01 <tromp> it becomes a contest of who has the better coffee
14:43:08 <roconnor> mmorrow: I think we can segfault it
14:43:19 <mmorrow> roconnor: are you trying?
14:43:21 * mmorrow is
14:43:25 <roconnor> mmorrow: yes
14:43:28 <mmorrow> :)
14:44:18 <chessguy_> > product [1..25]
14:44:19 <lambdabot>   15511210043330985984000000
14:44:19 <Debugger> Who has the best coffee?
14:44:44 <lament> tromp: do you know if that ever happened?
14:44:47 <Cheshire> hmm I have not had coffee in years
14:45:24 <chessguy_> are there rules about what size a go board can be?
14:45:51 <cjb> chessguy_: 9x9, 13x13, 17x17 and 19x19 are the popular sizes
14:45:59 <cjb> (17x17 only historically)
14:46:16 <chessguy_> cub not what I asked
14:46:18 <cjb> basically, the rule is that 19x19 is a great tradeoff between influence and territory
14:46:23 <cjb> and other sizes are not so much
14:46:24 <tromp> there have been triple kos on kgs
14:46:26 <cjb> so we don't play them
14:46:38 <Cheshire>     Class `Exception' used as a type
14:46:38 <Cheshire>     In the type `Exception'
14:46:39 <Cheshire> :/
14:46:41 <cjb> chessguy_: well, I think this is the answer to the question you didn't ask :)
14:47:09 <tromp> i think they decided to just abandon those games
14:47:28 <redditbot> Resource-safe EDSLs
14:47:33 <Baughn> Cheshire: Hmm?
14:47:36 <tromp> more often, one player is ahead enough that they decide to give up the triple ko and still win
14:47:49 <tromp> i've seen that happen
14:48:08 <Cheshire> just that compiling the latest quickcheck needs you to edit the source code
14:48:17 <lament> cjb: if the tradeoff between influence and territory were different, that would just modify all the josekis accordingly
14:48:42 <lament> obviously a 19x19 corner joseki makes no sense on 39x39
14:48:44 <tromp> > check \r -> 3.0*r/3.0==r
14:48:45 <lambdabot>   <no location info>: parse error on input `\'
14:48:53 <Cale> lament: But in 19x19, the importance of territory and influence at the start of the game is fairly balanced.
14:48:59 <tromp> @check \r -> 3.0*r/3.0==r
14:49:01 <lambdabot>   "Falsifiable, after 3 tests:\n-0.33333333333333337\n"
14:49:17 <lament> Cale: yes, although it seems influence is more important
14:49:26 <lament> hence people not playing 3x3 much anymore
14:49:36 <lament> but does that somehow make the game worse? not really
14:49:39 <Cale> But 5x5 is still kind of funny.
14:49:48 <dolio> Anyone got an unsafeCoerce that segfaults? I'm apparently having trouble...
14:49:56 <tromp> esp. when first move is on (2,2)
14:50:09 <Heffalump> dolio: having trouble with what?
14:50:11 <tromp> then 5x5 is a very close game
14:50:12 <Baughn> dolio: Coerce an int to a function, then try to apply it?
14:50:13 <Cheshire> @hackage http
14:50:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/http
14:50:19 <roconnor> mmorrow: grr
14:50:19 <Heffalump> getting unsafeCoerce to segfault should be pretty trivial
14:50:28 <tromp> @check \r -> 5.0*r/5.0==r
14:50:29 <lambdabot>   "Falsifiable, after 58 tests:\n-3.928571428571429\n"
14:50:39 <dolio> Heffalump: Finding a use of unsafeCoerce that segfaults. I keep getting things like 'non-exhaustive patterns in case' and such. :)
14:50:40 <mmorrow> roconnor: hehe, i can't find one either
14:50:44 <mmorrow> Heffalump: try it
14:50:47 <Cale> Things sort of hover around the 4,4 point which affords a fairly even balance between territory and influence.
14:50:53 <Baughn> @check \r -> 2.0*r/=2.0 == r
14:50:54 <lambdabot>       precedence parsing error
14:50:54 <lambdabot>          cannot mix `(/=)' [infix 4] and `(==)...
14:50:56 <roconnor> mmorrow: I'm not good with making strange uses of callCC
14:50:59 <Baughn> @check \r -> 2.0*r/2.0 == r
14:51:00 <lambdabot>   "OK, passed 500 tests."
14:51:04 <dolio> Baughn: That works, though.
14:51:14 <tromp> any non 2 power fails...
14:51:14 <Baughn> dolio: Um. Works?
14:51:17 <mmorrow> Heffalump: this is the relevant code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1332
14:51:20 <Heffalump> mmorrow: I was about to try Baughn's suggestion, so I won't bother now :-)
14:51:25 <Baughn> tromp: That's to be expected, right?
14:51:27 <lament> Cale: 4x4 has no territory :)
14:51:34 <tromp> @check \r -> 768.0*r/768.0==r
14:51:35 <lambdabot>   "Falsifiable, after 3 tests:\n1.4\n"
14:51:39 <geezusfreeek> @hoogle unsafeCoerce
14:51:39 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:51:49 <mmorrow> but you're not allowed to use unsafeCoerce to try to get callCC to segfault
14:51:53 <mmorrow> that would be trivial
14:52:06 <dolio> Baughn: Segfaults.
14:52:07 <Cale> lament: It can be invaded, but the exchange doesn't work until later.
14:52:15 <mmorrow> the challenge is to determine if the use of unsafeCoerce in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1332 is indeed unsafe or not
14:52:27 <lament> Cale: the reason it doesn't work is because one person gets territory, and the other gets influence, and influence is more important on 19x19 :)
14:52:29 <Baughn> dolio: Which is what you asked for.. ?_?
14:52:35 <dolio> Right.
14:52:39 <mmorrow> i'm starting to think it's safe, and the type system just can't see it
14:52:45 <tromp> > map (\r -> 3.0*r/3.0 - r) [1.0,1.1 .. 1.9]
14:52:46 <lambdabot>   [0.0,0.0,0.0,0.0,0.0,2.220446049250313e-16,0.0,-2.220446049250313e-16,0.0,2...
14:53:08 <dolio> mmorrow: u = unI (callCC (\k -> case unI (k 5) (const return) of f -> f 5)) id
14:53:11 <dolio> Tadaa!
14:53:14 <mmorrow> oooh
14:53:19 <Cale> lament: Right.
14:53:21 <mmorrow> nice
14:53:28 <tromp> > (\r -> 3.0*r/3.0 - r) 1.5
14:53:29 <lambdabot>   0.0
14:53:43 <geezusfreeek> Prelude Unsafe.Coerce> let f = unsafeCoerce 5 :: Int -> Int; Prelude Unsafe.Coerce> f 6; 8718968878589280256
14:53:45 <Cale> lament: Well, it's more important than the territory that's obtained by invading at 3,3
14:53:48 <Baughn> dolio: For the case pattern thing, I expect casting to the wrong /value/ type ends up handing case a type tag that doesn't exist.. thus, "non-exhaustive pattern"
14:53:48 <Cheshire> blugh
14:53:52 <tromp> > map (\r -> 3.0*r/3.0 - r) [1.0,1.1 .. 1.9] !! 5
14:53:53 <lambdabot>   2.220446049250313e-16
14:53:54 <Cheshire> what do you do in this situation?:
14:53:56 <Cheshire> Copying patch 268/375
14:53:57 <tromp> weird
14:54:00 <Cheshire> and it's stuck there...
14:54:06 <jeltsch> Hello, is anyone of the Hackage admins online?
14:54:24 <mmorrow> dolio: oh, wait. you're using unId explicitly
14:54:30 <Baughn> Cheshire: Cancel, install darcs-2.1, then try again. ;)
14:54:35 <mmorrow> hmm
14:54:35 <tromp> > [1.0,1.1 .. 1.9] !! 5
14:54:36 <lambdabot>   1.5000000000000004
14:54:38 <Cheshire> oww
14:54:40 <tromp> aha!
14:54:44 <Cheshire> ok and what about "Not in scope: `buildVerbose'"?
14:54:49 <Cheshire> from runhaskell or cabal
14:54:50 <dolio> Baughn: Yeah. But I thought, for instance, casting the second constructor of a 2-constructor type to a 1-constructor type and matching used to cause segfaults.
14:54:57 <Baughn> Cheshire: Update cabal
14:55:06 <Cheshire> I just installed cabal this moment...
14:55:20 <tromp> > map (\r -> 3.0*r/3.0 - r) $ map (/10) [10..19]
14:55:21 <lambdabot>   [0.0,0.0,0.0,0.0,-2.220446049250313e-16,0.0,2.220446049250313e-16,0.0,0.0,-...
14:55:23 <Baughn> dolio: You expect consistent behaviour from undefined behaviour?
14:55:23 <roconnor> segfault!!!
14:55:29 <roconnor> mmorrow: segfault!!!
14:55:30 <dolio> :)
14:55:35 <mmorrow> weeeeee
14:55:41 <Cheshire> -- hack to turn cpp-style '# 27 "GenericTemplate.hs"' into
14:55:41 <Cheshire> -- '{-# LINE 27 "GenericTemplate.hs" #-}'.
14:55:41 <Cheshire> crazy_perl_regexp =
14:55:41 <Cheshire>  "s/^#\\s+(\\d+)\\s+(\"[^\"]*\")/{-# LINE \\1 \\2 #-}/g;s/\\$(Id:.*)\\$/\\1/g"
14:55:43 <Cheshire> lol
14:55:55 <roconnor> mmorrow: let bad = callCC (\k -> return (Left (\a -> k (Right a)) ))
14:55:57 <Cale> lament: If that influence becomes unimportant, the invasion works, but another play there at any point prior to that can seal it. So 4,4 isn't entirely influence-minded.
14:56:02 <Cheshire> no wonder this doesn't build
14:56:08 <roconnor> mmorrow: let Left f = fst $ runS bad 0 in runS (f 'a') 10 :: (String, Integer)
14:56:21 <geezusfreeek> my world was turned upside down for a second there. "a legit use of unsafeCoerce?!"
14:56:29 <tromp> > 1.4*3/3
14:56:31 <lambdabot>   1.3999999999999997
14:56:37 <roconnor> mmorrow: possibly overly complicated
14:56:41 <Baughn> geezusfreeek: "Working around type system incompleteness"
14:56:47 <lament> Cale: it takes more than 1 move to secure 4x4 against invasion
14:56:56 <lament> to secure the corner anyway
14:57:02 <geezusfreeek> Baughn, i know such cases exist, but i haven't yet seen one
14:57:06 <roconnor> mmorrow: I think I cast a char to a string there
14:57:20 <Cale> 3,3 works if absolutely necessary.
14:57:25 <mmorrow> hmm, interesting
14:57:40 <Cale> But usually there will be other stones around already which makes another move work better.
14:57:42 <Cheshire> Baughn, I have darcs 2.2 though
14:58:29 <Baughn> Cheshire: Upgrade to git?
14:58:46 <pumpkin> lol
14:58:52 <Cheshire> Baughn, no but can git download darcs repos?
14:58:52 <Baughn> ...I'm a bit disillusioned with darcs, I'll admit. It's nice, when it works... on a sufficiently fast computer
14:59:00 <Baughn> Cheshire: Nope
14:59:05 <Cheshire> ok
14:59:08 <Cheshire> useless for me then
14:59:16 <geezusfreeek> i would probably use darcs if it had in-place branching
14:59:39 <Baughn> I'd like a darcs-like frontend to git. Hey, maybe I'll write one.
14:59:44 <Cale> Baughn: which version?
14:59:51 <geezusfreeek> and maybe a few other conveniences that git has that i'm used to
14:59:56 <lament> Cale: fair enough, 3x3 works, but since it would still have worked without 4x4 one of those moves is wasted
14:59:59 <Baughn> Cale: Every version
15:00:06 <roconnor> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1333
15:00:11 <Cale> Baughn: You've even had problems with 2.x?
15:00:16 <Baughn> Cale: Oh yes
15:00:18 <lament> Cale: 4x4 stone has no territory, by adding 3x3 you take the corner
15:00:53 <Baughn> Cale: The way I see it, any revision control system that won't even /try/ to peg my bandwidth is uselessly slow. Darcs *still* doesn't do pipelining.
15:00:59 <Cheshire> Why does   import Console.Readline   not work?
15:01:03 <Cheshire> I have editline
15:01:31 <roconnor> mmorrow: I guess you can't mix up continutations with different return values.
15:01:31 <Cheshire> editline is capable of pretending to be readline, if it /did/ then cabal and all this stuff would compile the program...
15:01:34 <Baughn> Cale: Then there's the lack of in-place branches, and the sheer speed difference between darcs and git.. I love darcs, but I can't use it. ;_;
15:01:54 <Cheshire> but instead it looks like I have to change deps to editline and all the imports
15:02:03 <Cheshire> it seems silly
15:02:19 <roconnor> opps I annotated the wrong paste
15:02:25 <Baughn> Cale: (Downloading the entire GHC repository at ~7kB/s on average takes a bit too long for my purposes)
15:02:29 <mauke> meh, editline is silly
15:02:29 <Cale> lament: I suppose the point I'm trying to make is that the territory is practically yours so long as it's not profitable to invade. So, certainly, as the game progresses, you will have to add a stone *somewhere* to make that secure, but ignoring moves against the 3,3 point is similar.
15:02:52 <roconnor> oh no I got the right one
15:03:00 <Cheshire> mauke, editline probably sucks but it doesn't matter -- I just wanted to compile a program
15:03:13 <lament> Cale: we could argue forever about this :D
15:03:52 <Cale> lament: I know what you mean though.
15:03:56 <lament> Cale: note that the entire board is "practically yours so long as it's not profitable to invade"
15:04:16 <Cale> lament: But unforunately for you, it is ;)
15:04:26 <Cale> unfortunately*
15:04:48 <lament> well, if i'm playing against a 9d, it's not profitable to invade, i might as well resign on move 0 :)
15:04:52 * Nafai tries to purge all distribution managed Haskell packages
15:05:36 <Ringo48> can somebody point me to an example that uses random numbers in "real" code?
15:05:48 <Baughn> Cale: Actually, I did an informal study of that speed.. across an entire day, timed with /bin/time, I spent seven minutes waiting for darcs to work out what it does. Three of those were to upload ten-something patches.. on a lan.
15:06:33 <Cale> Baughn: I suppose I've never used darcs for such a large repository.
15:06:53 <siki> Hello everyone!
15:07:24 <Cale> Baughn: Actually, I wonder why all of the revision control systems seem to transfer patches, and not just the whole repository in one go.
15:07:40 <Cale> Baughn: I've more often been annoyed waiting for patches to be applied than at the transfer time.
15:07:43 <Baughn> Cale: Git /does/ transfer the whole repository in one go, so there you go. :P
15:07:51 <Baughn> (At least if you gc it reasonably often)
15:07:56 <Cale> Baughn: Are you sure?... hmm
15:08:14 <mmorrow> roconnor: yeah, something like that. this is interesting.
15:08:18 <Ringo48> all the examples I can find in the documentation and on wikis are silly examples to generate 10 random numbers inside the top loop or something
15:08:19 <siki> I'm quite a noob. I have a pretty simple question and I'd appreciate some help.
15:08:21 <Baughn> Cale: man git-gc. But even if you don't do that, it still at least pipelines the transfer.
15:08:26 <Cale> siki: ask away :)
15:08:51 <pumpkin> quick, ask before the velociraptors get back!
15:08:59 <BONUS> alternatively: dont ask to ask just ask :]
15:09:02 <Cale> Ringo48: Well, what are you using the random numbers for?
15:09:10 <siki> if I have a simple type defined like: data Foo = Blah Double | Blah2 Double
15:09:21 <roconnor> excluded middle FTSegmentation fault!!!
15:09:41 <Ringo48> I understand "rand()" from C/C++ can't be done in Haskell, but that doesn't help me out at all
15:09:42 <siki> if I have a list of these "Foo"s how do I search for all the "Blah"s in that list?
15:10:01 <newsham> ringo: you can do the equivalent of rand() in IO.
15:10:08 <geezusfreeek> Ringo48, try searching for MonadRandom
15:10:09 <newsham> or make the equivalent of rand() for State
15:10:10 <Ringo48> I need to populate a data structure with several random values
15:10:11 <Cale> siki: one quick way is [x | Blah x <- xs]
15:10:12 <Ringo48> I've seen that
15:10:14 <mauke> isBlah x = case x of Blah _ -> True; _ -> False
15:10:15 <pumpkin> Ringo48: no computer-based RNG is truly random, so it's deterministic and there's a monad for it
15:10:28 <Ringo48> yes, I know that, but I'm not in a monad
15:10:34 <Cale> Ringo48: Basically, here's the idea.
15:10:39 <mauke> pumpkin: there are hardware-based rngs
15:10:41 <pumpkin> then pass around the seed info yourself
15:10:45 <Ringo48> I don't even mind having to pass around a generator
15:10:48 <geezusfreeek> Ringo48, then you should put yourself in a monad ;)
15:10:50 <Cale> Ringo48: The result of a function in Haskell depends only on its parameters.
15:10:55 <newsham> or you can do a similar trick as getContents and make an infinite stream of random values from within IO and then pass that around your pure code
15:10:56 <Ringo48> but I can't find any non-trivial examples of using StdGen
15:11:03 <pumpkin> mauke: yeah, but that falls outside of what I call a computer-based RNG :P
15:11:06 <Ringo48> they're all stupid "This is how you do it in main"
15:11:12 <Cale> Ringo48: So, if a function is going to produce pseudorandom numbers, it will have to take the state of the random generator as input.
15:11:16 <Ringo48> I can't do it in main
15:11:19 <Cale> Ringo48: (as a parameter)
15:11:21 <mauke> Ringo48: why not?
15:11:27 <geezusfreeek> Ringo48, pass it down from main
15:11:28 <mauke> everything is done in main in some sense
15:11:40 <siki> ok thanks a lot I'll try those out
15:11:56 <ddarius> mauke: "isFoo" functions are foul
15:11:58 <Cale> Ringo48: So, we have functions like random :: (Random a) => StdGen -> (a,StdGen)
15:12:01 <Cale> :t random
15:12:01 <Ringo48> can you point me to an example that shows how to generate a random number from some function other than main
15:12:02 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
15:12:02 <Ringo48> ?
15:12:11 <Ringo48> using StdGen
15:12:16 <Cale> Ringo48: ^^ this function is what you use
15:12:20 <Cale> and randomR
15:12:20 <mauke> :t randomIO
15:12:21 <lambdabot> forall a. (Random a) => IO a
15:12:24 <Ringo48> yes, I know that
15:12:26 <mauke> I use randomIO
15:12:28 <Ringo48> but I'm asking for an example
15:12:37 <Cale> okay... what sort of example would you like?
15:12:47 <Ringo48> I've seen all of those, and the documentation on actually using them is (for me) clear as mud
15:12:49 <mauke> foo = randomIO >>= print; main = foo >> foo >> foo
15:13:00 <mauke> except that doesn't typecheck :-)
15:13:09 <Cale> Ringo48: So, you'll normally get hold of a StdGen in main, using the newStdGen function
15:13:18 <geezusfreeek> Ringo48, calm down, we are trying to enlighten you
15:13:18 <dolio> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1328#a1334
15:13:21 <dolio> costrength
15:13:21 <Cale> Ringo48: and pass that as a parameter to any function which needs randomness.
15:13:35 <Ringo48> Cale: yes, I know all of that, I just want an example
15:13:35 <ddarius> mauke: Add a (1+) and it should.
15:13:43 <Cale> Ringo48: What should the example do?
15:13:45 <mauke> yeah
15:13:51 <Ringo48> I don't even care
15:13:52 <Cale> (I'll write it for you)
15:14:02 <Cale> How about rolling a handful of dice?
15:14:12 <chessguy> yahtzee!
15:14:14 <Ringo48> surely there's some non-trivial open source haskell code that uses random values that you could point me to?
15:14:18 <mauke> foo = randomIO >>= \n -> print (n :: Double); main = foo >> foo >> foo
15:14:39 <Cale> I'm sure there is, but I'd have to look for a program which uses it...
15:14:42 <geezusfreeek> http://abstractabsurd.blogspot.com/2008/10/working-through-genetic-programming.html
15:14:45 <ddarius> Cale: I suggest a Monte Carlo-based raytracer as the example...
15:14:49 <Cale> heh
15:15:09 <mauke> Ringo48: http://mauke.ath.cx/preflex/Plugin/Version.hs
15:15:23 <pumpkin> Ringo48: the basic point is that if you're not "in" a monad, a mathematical function can't return different values given the same input, so you need to thread the PRNG state through yourself
15:15:31 <roconnor> *Main> either (\f -> fst $ runS (f 'a') 10) id $ fst $ runS bad 0
15:15:32 <roconnor> '\1823983473'
15:15:39 <roconnor> (your results may vary)
15:16:00 <roconnor> mmorrow: ^^ is a bit nicer
15:16:04 <chessguy> pumpkin:  umm, you really shouldn't explain monads as if they're impure
15:16:14 <pumpkin> I'm not
15:16:18 <newsham> > let g = mkStdGen 1; (x,g') = randomR (1,6) g; (y,g'') = randomR (1,6) in (x+y) :: Int
15:16:19 <lambdabot>   Couldn't match expected type `(t, t1)'
15:16:22 <geezusfreeek> that didn't sounds impure to me
15:16:33 <Ringo48> so basically if I need a random value, but I'm not in a position where I can redo everything "above" me in the call stack, I'm SOL?
15:16:38 <newsham> > let g = mkStdGen 1; (x,g') = randomR (1,6) g; (y,g'') = randomR (1,6) g' in (x+y) :: Int
15:16:39 <lambdabot>   11
15:16:47 <chessguy> pumpkin:  sounds to me like you're saying that if you ARE in a monad, a function can return different values for different inputs
15:16:52 <chessguy> err, for the same input
15:17:05 <newsham> ringo: "redo everything above me in the call stack"?
15:17:10 <pumpkin> chessguy: nope, implying that the monad takes care of threading the PRNG state through for you... but I see it wasn't clear now, sorry :)
15:17:10 <mauke> Ringo48: depends on your call stack
15:17:12 <Cale> Ringo48: If you can't demand that your caller pass you a StdGen, then yes.
15:17:20 <mmorrow> , [$ty| (+++) |]
15:17:25 <mmorrow> og grr
15:17:34 <lunabot>  forall a . ReadP a -> ReadP a -> ReadP a
15:17:35 <mmorrow> what is (+++)
15:17:36 <mmorrow> ?
15:17:42 <pumpkin> ArrowChoice iirc
15:17:44 <chessguy> @hoogle (+++)
15:17:44 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
15:17:44 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
15:17:44 <lambdabot> Text.ParserCombinators.ReadPrec (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
15:17:46 <mmorrow> ahh
15:17:53 <Baughn> Ringo48: Why do you need a random value, exactly?
15:18:05 <Cheshire> why does it say "happy version >=1.15 && <2 is required but it could not be found" after I just did  cabal install happy  ?
15:18:05 <Ringo48> newsham: basically if I don't have a way to change the code that calls my code
15:18:16 <newsham> ringo: if you are in pure code, accept a stdgen as an argument and return a new stdgen as a result
15:18:29 <Baughn> Ringo48: For randomized algorithms that aren't externally observable to be random, unsafePerformIO could work.. but you'd have to be vewwy, vewwy caweful.
15:18:42 <Cale> Ringo48: If the function which calls your code doesn't hand you a StdGen, or another means of constructing random values, then it doesn't *want* you to construct random values, so you can't.
15:18:43 <Cheshire> obviously this purity thing was a mistake
15:18:46 <chessguy> hmm, so i'd really love to be able to get rid of the need for 'wrap' in this code: http://codepad.org/hUJohcw8 ... any suggestions welcome
15:18:48 <Ringo48> newsham: that's what I mean, I can't change the code that calls mine to pass in a StdGen
15:18:49 <pumpkin> the issue with unsafePerformIO is that the compiler will often just not call the function twice
15:18:50 <newsham> ringo: oh, I see what you're saying.  if you arent in a context where you have a stdgen available and arent allowed to do IO, then you may indeed be screwed
15:18:59 <bos> @users
15:19:00 <lambdabot> Maximum users seen in #haskell: 664, currently: 630 (94.9%), active: 31 (4.9%)
15:19:06 <ddarius> Cheshire: That's what I've been saying the -whole time-.
15:19:25 <Cale> Ringo48: It's not part of your function's contract to use a random number generator.
15:19:32 <newsham> ringo: if your caller requires you to be pure, and isnt giving you a stdgen, you cant really make up a different result each time
15:19:35 <mmorrow> dolio: cool. i'm not quite sure what to make of that yet, but i just saw what kinda happening there
15:19:42 <newsham> since your code will have to return the same results every time caled with the same inputs
15:19:56 <Cale> Ringo48: A function of type A -> B *must* give the same value of type B when given the same value of type A.
15:20:03 <Baughn> Ringo48: So, again, /why/ do you need a random number?
15:20:48 <newsham> this is one of the nice things about the type system.  callers can expect nice behavior from functions they call
15:20:50 <Ringo48> Baughn: generating random test data
15:20:53 <chessguy> Cale:  i've been trying to figure out a less-awkward way to say that. sounds so strange to me
15:21:00 <Cale> Ringo48: look at QuickCheck
15:21:10 <Baughn> Ringo48: How random does it need to be?
15:21:41 <geezusfreeek> Ringo48, does it need to be new values every time it is run or is it okay to have the same sequence of values every time?
15:21:50 <Cale> @check \xs -> reverse (reverse xs) == (xs :: [Integer])
15:21:51 <Baughn> Ringo48: You can make up a stdgen from whole cloth using a constant seed. Or a "constant" unsafeperformIO'd seed as a global, in which case it'd be constant per-run.
15:21:51 <lambdabot>   "OK, passed 500 tests."
15:21:54 <newsham> ringo: you can still generate a sequence of data that doesnt seem veyr orderly using pure functions, but they will be the same sequence each time
15:21:58 <Ringo48> it doesn't have to be good enough for cryptography, but I'd prefer it not return the same values very often
15:22:02 <Cale> @check \xs -> reverse xs == (xs :: [Integer])
15:22:03 <lambdabot>   "Falsifiable, after 6 tests:\n[-2,3,0,-2]\n"
15:22:10 <geezusfreeek> if the latter, you can use mkStdGen or whatever it's called
15:22:13 <geezusfreeek> ah, n/m then
15:22:15 <Baughn> Ringo48: Probably just "mkStdGen 42" will do
15:22:17 <Cale> ^^ check it out -- random testing :)
15:22:20 <newsham> > let g = mkStdGen 1 in (randomR (1,6) g, randomR (1,6) g)
15:22:21 <lambdabot>   ((6,80028 40692),(6,80028 40692))
15:22:43 <mmorrow> dolio, roconnor: /me tries this next http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=671  ;)
15:22:44 <newsham> > let g = mkStdGen 1 in randoms g
15:22:45 <lambdabot>   [7917908265643496962,-1017158127812413512,-1196564839808993555,128524678767...
15:23:13 <Cale> > let g = mkStdGen 42 in randomRs (1,6)
15:23:14 <lambdabot>       Overlapping instances for Show (g -> [t])
15:23:14 <lambdabot>        arising from a use of ...
15:23:16 <Cale> > let g = mkStdGen 42 in randomRs (1,6) g
15:23:17 <lambdabot>   [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,...
15:23:22 <Cale> > let g = mkStdGen 42 in randomRs (1,6) g
15:23:24 <lambdabot>   [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,...
15:23:35 <Cale> Completely deterministic, but might be random enough for you
15:24:04 <newsham> if you have access to some parameter that is changing with different calls, perhaps you can use that to seed a generator?
15:24:18 <Baughn> > let g = (unsafePerformIO newStdGen) in randomRs (1,6) h -- ;)
15:24:19 <lambdabot>   Not in scope: `unsafePerformIO'
15:24:37 * Baughn pouts
15:24:43 <Cheshire> what does:  Warning: 'hs-source-dirs: dist/build/autogen' directory does not exist.
15:24:44 <Cheshire>   mean?
15:24:49 <Cheshire> when running cabal
15:25:20 <Cale> Cheshire: Probably that that directory does not exist despite being listed in the .cabal file
15:25:25 <Cheshire> I just made the directory and the error went away
15:25:36 <Baughn> It's not an error, though
15:25:37 <Cheshire> if that fixes the problem maybe cabal should do that automatically
15:25:37 <Saizan_> that's not an error anyhow
15:25:45 <Cheshire> ok Warning :p
15:26:01 <Nafai> Swweet
15:26:02 <Nafai> Er
15:26:03 <Nafai> Sweet
15:26:04 <Saizan_> the error is in the .cabal file, essentially, but it might be there to workaround a bug that's been fixed
15:26:05 <Nafai> Free of 6.8.2
15:26:08 <Baughn> Probably there was a source file aat some point that produced a new one in autogen/ when processed
15:26:13 <Baughn> Now there isn't
15:26:34 <Baughn> (But that should be handled automatically anyway, right? No need to specify the directory)
15:26:51 <Cale> Ringo48: Are things any clearer?
15:26:55 <Saizan_> dist/build/autogen is where cabal creates the Paths_$pkg.hs file, but it'll do so after configure, not before
15:26:56 <Cheshire> @hackage happy
15:26:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happy
15:27:53 <Ringo48> Cale: clear enough
15:27:54 <Ringo48> thank you
15:27:57 <newsham> "Anyone who attempts to generate random numbers by deterministic means is, of course, living in a state of sin."
15:28:18 <Cheshire> does anyone know how to got rid of: Setup.lhs:30:43: Not in scope: `buildVerbose'  ?
15:29:55 <Saizan_> Cheshire: what are you trying to build?
15:30:03 <Cheshire> happy
15:30:22 <Baughn> Ringo48: Just so we're clear, unsafePerformIO is almost certainly the wrong answer. Don't use it. :P
15:31:40 <Cheshire> Saizan_, I had to export PATH=$HOME/.cabal/bin
15:32:03 <Saizan_> Cheshire: that fixed that error?
15:32:08 <Cheshire> yes
15:32:15 <Ringo48> newsham:  well, since I'm already living in a state of sin, it'd be nice to get some random numbers while I'm at it ;-)
15:32:19 <Cheshire> no
15:32:23 <Cale> Ringo48: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1336#a1336
15:32:25 <Cheshire> Saizan_, no it fixed a different error
15:32:32 <Ringo48> Cale: thanks
15:32:44 <roconnor> mmorrow: unsafePerformIO!
15:33:03 <Saizan_> Cheshire: ah, ok :) however that's the location where cabal installs executables by default
15:33:05 <Cale> Ringo48: But if you're doing *lots* of stuff with random numbers, you'll want to use a proper monadic library, like MonadRandom.
15:33:25 <Cale> I'll show how that looks rewritten with the Rand monad...
15:33:35 <roconnor> mmorrow: okay, I have no idea if that code is safe or not
15:34:07 <chessguy> @where cale
15:34:08 <lambdabot> I know nothing about cale.
15:34:57 <chessguy> @where+ cale http://cale.yi.org/index.php/Main_Page
15:34:57 <lambdabot> It is stored.
15:35:39 <roconnor> I suppose IdentityT m a = IdentitityT { runIdentityT :: forall r. (a -> m r) -> m r } would actually be useful to "speed up" monads.
15:36:02 <roconnor> FasterT m a = FasterT { unFasterT :: forall r. (a -> m r) -> m r }
15:36:17 <geezusfreeek> MagicMakeFastMonadT
15:36:23 <Mauke> VTECT
15:36:28 <roconnor> not magic :)
15:36:36 <geezusfreeek> i know, but it sounds cooler
15:36:40 <roconnor> true
15:37:23 <roconnor> runFasterT :: FasterT m a -> m a; runFasterT cmd = unFasterT cmd return
15:37:44 <roconnor> hmm
15:37:45 <Cale> Ringo48: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1336#a1337
15:37:59 * Mauke wonders whether he invented the unFoo/runFoo naming convention
15:38:02 <roconnor> I guess all the magic is in the lifting of the operations and bind.
15:38:39 <chessguy> @src liftM2
15:38:39 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:38:39 <Cale> Ringo48: You would then run one of those computations something like  runRand (dice 3 6) g
15:38:46 <Cale> (where g is a StdGen)
15:39:14 <pastah> WHAT IS THIS!? i have bugs in a haskell program that typechecks!
15:39:34 <pastah> too incredible to be true
15:39:39 <roconnor> pastah: add more types
15:39:47 <roconnor> phantom types
15:40:21 <mmorrow> dolio, roconnor: woot! callCC for Id: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1338#a1338
15:40:25 <mmorrow> ;)
15:40:59 <roconnor> mmorrow: what happens with my example?
15:41:13 <mmorrow> roconnor: i'll check
15:41:41 <roconnor> mmorrow: you do know hat callCC is impossible for Id?
15:41:48 <Ringo48> dice 5 10 (getStdGen) complains that getStdGen returns an (IO StdGen)
15:41:52 <dolio> mmorrow: FYI: that costrength function does not work.
15:42:19 <hackage> Uploaded to hackage: blogination 0.3
15:42:19 <hackage> Uploaded to hackage: random-fu 0.0.0.2
15:42:20 <roconnor> Ringo48: dice 5 10  =<< getStdGen
15:42:55 <dolio> Unsurprisingly.
15:44:21 <chessguy> anybody have any ideas for getting rid of the need for wrap in this code? http://codepad.org/hUJohcw8
15:44:22 <roconnor> mmorrow:
15:44:23 <roconnor> let excludedMiddle = callCC (\k -> return (Left (\a -> k (Right a)) ))
15:44:25 <roconnor>  in either (\f -> runId (f 'a')) id $ runId excludedMiddle
15:44:38 <mmorrow> roconnor: it works because the Typeable thing on the prompts
15:44:49 <roconnor> what does it return?
15:45:34 <mmorrow> "*** Exception: <<Int>>
15:45:49 <roconnor> hmm
15:46:01 <mmorrow> because the prompts are thrown and they're Dynamic Ints
15:46:06 <mmorrow> woot!
15:46:24 <roconnor> mmorrow: this still doesn't seem safe and / or referentially transparent
15:46:33 <mmorrow> hehe
15:46:52 <roconnor> mmorrow: what about the above example I just wrote?
15:47:06 <mmorrow> i didn't do it for S yet, but the same thing would happen
15:47:20 <mmorrow> notice the Phantom type on the P newtype
15:47:34 <roconnor> no
15:47:34 <mmorrow> oh, sorry
15:47:38 <roconnor> oh there
15:47:44 <mmorrow> oh, n/m
15:47:45 <roconnor> oh that int
15:47:45 <mmorrow> yeah
15:48:09 <Cheshire> that excluded middle makes no sense :D
15:48:11 <mmorrow> it's using the same idea as ccdelcont/that whole thing with the prompts
15:48:16 <chessguy> did mmorrow  just do the impossible? :)
15:48:19 <Cheshire> how can classical logic have a computation interpretation
15:48:34 <roconnor> Cheshire: that is why mmorrow's code segfaults
15:48:38 <mmorrow> chessguy: thanks to unsafePerformIO, MVars, Dynamic, and Typeable ;)
15:48:50 <augustss> Cheshire: the double negation of it it has
15:49:12 <roconnor> augustss: for a weak sense of "computational"
15:49:45 <roconnor> maybe a trivial sense is a better way to say it
15:50:19 <roconnor> mmorrow: I'm pretty sure this isn't referentially transparent
15:50:31 <roconnor> mmorrow: and I'm not willing to bet that it is safe either
15:50:34 <roconnor> :)
15:50:47 <mmorrow> roconnor: the implementation isn't, but i believe it's impossible to tell from the outside
15:51:10 <mmorrow> also, it's as safe as using Dynamic
15:51:12 <roconnor> mmorrow: you believe the interface is referentially transparent?
15:51:28 <mmorrow> i mean the one presented through callCC
15:51:32 <mmorrow> not the other one
15:51:38 <roconnor> can unsafePerformIO segfault?
15:51:39 <mmorrow> well.... actually maybe that one too
15:51:57 <roconnor> mmorrow: I beleive your callCC interface isn't referentially transparent
15:52:04 <mmorrow> sure, if you treat an IORef as polymorphic
15:52:27 <roconnor> mmorrow: does haskell treat IORef as polymorphic?
15:52:35 <mmorrow> if you want it to
15:52:45 <Nafai> So is shim being developed any more outside of Yi?
15:52:54 <Nafai> A while back I had shim hooked up with Emacs and it was nice
15:53:04 <roconnor> mmorrow: anyhow, I'll leave it up to you to prove that your callCC isn't referentially transparent
15:53:15 <roconnor> mmorrow: callCC for Id is fundamentally unsound.
15:53:29 <mmorrow> unsafeCoerce a = unsafePerformIO (do x <- newIORef a; readIORef x)
15:53:46 <mmorrow> roconnor: sure, but this is using Dynamic to disallow unsound usage
15:54:05 <mmorrow> so if will just ignore thrown prompts of the wrong type
15:54:13 <Cheshire> :t \a -> do x <- newIORef a; readIORef x
15:54:14 <lambdabot> Not in scope: `newIORef'
15:54:14 <lambdabot> Not in scope: `readIORef'
15:54:17 <mmorrow> and they'll end up as uncaught exceptions
15:54:32 <roconnor> mmorrow: well I believe you are safe, but I still don't think you  are referentially transparent.
15:54:39 <Cheshire> @src unsafeCoerce
15:54:39 <lambdabot> Source not found. Where did you learn to type?
15:55:18 <roconnor> @type (do x <- newIORef a; readIORef x)
15:55:19 <lambdabot> Not in scope: `newIORef'
15:55:19 <lambdabot> Not in scope: `readIORef'
15:55:39 <mmorrow> roconnor: heh, i can live with that. but i still don't see how it isn't (the only way to tell would be to get a hold of a P, and examine its internal Int, but you don't even know the P exists if you're only using callCC)
15:55:55 <roconnor> @hoogle IORef
15:55:56 <lambdabot> module Data.IORef
15:55:56 <lambdabot> Data.IORef data IORef a
15:55:56 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
15:56:40 <mmorrow> err, that unsafeCoerce doesn't work
15:56:45 <mmorrow> you need a
15:56:48 <mmorrow> hmm, wait
15:56:51 <roconnor> mmorrow: unsafeCoerce a = unsafePerformIO (do x <- newIORef a; readIORef x) -- doesn't this have type a -> a?
15:57:10 <mmorrow> yes
15:57:15 <Cheshire> the definition of unsafeCoerce I know uses a global cell
15:57:26 <mmorrow> you need a separately defined IORef of type (IORef a)
15:57:29 <mmorrow> yeah exactly
15:57:30 <Mauke> let x = unsafePerformIO (newIORef a) in unsafePerformIO (readIORef x)
15:57:47 <roconnor> mmorrow: all your unsafePerformIO's are going to get executed in strange orders
15:58:05 <mmorrow> roconnor: it doesn't matter
15:58:28 <roconnor> what happens when you read a reference before it is newed?
15:59:14 <mmorrow> i don't think you can, but if that's possible, you'll just hang on an empty MVar
15:59:24 <roconnor> Mauke: doesn't that still have type a -> a?
15:59:28 <Mauke> yes :(
15:59:46 <roconnor> what happens when you read a reference before it is newed, depending on where your code is located?
16:00:00 <roconnor> you guys suck at writing unsafeCoerce :)
16:00:06 <rovar> Cheshire,how is this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1339#a1339
16:00:16 <Mauke> let x = unsafePerformIO (newIORef undefined) in unsafePerformIO (writeIORef x a >> readIORef x)
16:00:22 <Cheshire> that is fine
16:00:30 <rovar> any more tips?
16:00:41 <Cheshire> pattern match on words
16:01:39 <rovar> ?
16:01:46 <roconnor> Mauke: okay.  but isn't that equivalent to const undefined?
16:01:56 <mmorrow> roconnor: you can never read an MVar before it exists, since the only time one is inspected is in the exception handler when it has caught a thrown prompt, and for that to ever happen means that the MVar not only exists but is full
16:02:02 <Mauke> no, why?
16:02:46 <roconnor> Mauke: because x looks like a function of type.  So the x in writeIORef x a is a different x from the x in  readIORef x
16:02:54 <roconnor> Mauke: although this might be implementation specific
16:03:02 <Mauke> *> oops (42 :: Int) :: Int
16:03:03 <Mauke> 42
16:03:03 <Mauke> *> oops (42 :: Int) :: Char
16:03:03 <Mauke> '*'
16:03:23 <roconnor> Mauke: oh neat
16:03:43 <mmorrow> heh
16:03:44 <roconnor> Mauke:  what happens with:
16:04:04 <roconnor> let {x:: (Eq a) => IO a; x = unsafePerformIO (newIORef undefined)} in unsafePerformIO (writeIORef x a >> readIORef x)
16:04:06 <roconnor> ?
16:04:15 <roconnor> (ie put a class constraint on)
16:05:13 <roconnor> @hoogle unsafePerformIO
16:05:13 <lambdabot> Foreign unsafePerformIO :: IO a -> a
16:05:13 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
16:05:44 <Mauke> yeah, that looks like const undefined
16:06:49 <roconnor> er
16:07:05 <roconnor> should be (Eq a) => IORef a I guess
16:07:35 <roconnor> let f a = let {x :: (Eq a) => IORef a ; x = unsafePerformIO (newIORef undefined)} in unsafePerformIO (writeIORef x a >> readIORef x)
16:07:42 <roconnor> System.IO.Unsafe> f 48 :: Char
16:07:44 <roconnor> *** Exception: Prelude.undefined
16:07:48 <roconnor> System.IO.Unsafe> f 48 :: Int
16:07:50 <roconnor> *** Exception: Prelude.undefined
16:08:07 <roconnor> so the fact that this isn't (const undefined) and is unsafeCoerce is GHC specific.
16:08:35 <Mauke> oops (42 :: Int) ()  -- segfault :-)
16:08:58 <roconnor> System.IO.Unsafe> f (42 :: Int) :: ()
16:09:00 <roconnor> *** Exception: Prelude.undefined
16:09:41 <roconnor> Mauke: I bet it would be (const undefined) in LHC and JHC
16:10:17 <automatical[a]>  /whois roconnor
16:10:21 <automatical[a]> oops
16:10:36 <automatical[a]> dunno where that even came from
16:10:48 <chessguy> @type (!!)
16:10:49 <lambdabot> forall a. [a] -> Int -> a
16:15:46 <roconnor> mmorrow: callCC is totally evaluation order dependent.  It cannot be referentially transparent.
16:16:25 <mmorrow> i guess i don't know what you rdefinition of referentially transparent is
16:16:43 <MyCatVerbs> @type callCC
16:16:44 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:16:48 <mmorrow> oops, and i just found a case where it hangs
16:16:50 <mmorrow> doh
16:16:57 <mmorrow> ghci> runId $ callCC (\k -> forever (k 42) >> return 99)
16:16:58 <roconnor> mmorrow: that f a b is always the same as flip f b a
16:17:21 <mmorrow> roconnor: that shouldn't make any difference here
16:17:33 <roconnor> mmorrow: I think it will.
16:17:56 <mmorrow> i'd love to see if it does of course :)
16:18:40 * roconnor lemme hang some curtain first
16:18:43 <roconnor> er
16:18:49 <roconnor> mmorrow:  lemme hang some curtain first
16:18:55 <roconnor> curtains
16:18:58 <roconnor> and I'll think about it
16:19:08 <mmorrow> heh
16:19:41 <roconnor> it shouldn't be too hard to think of.  Just implement exceptions and have b and a throw different exceptions
16:20:38 <rovar> can someone point me to a simple means of persisting key/value pairs to disk?
16:20:46 <rovar> with or without STM
16:21:27 <Cale> Data.Map has a show instance ;)
16:21:37 <Peaker> probably a Binary instance too?
16:22:12 <rovar> will give it a try
16:23:17 <cognominal> how can I list the installed packages and their versions?
16:23:23 <rovar> no binary instance, but I suppose show will be good enough for now.
16:23:26 <pumpkin> ghc-pkg list
16:24:01 <mmorrow> roconnor: ah, i just fixed the hang  (had to do   (return $! ..) instead of just return)
16:24:23 <cognominal> thx
16:28:21 <mmorrow> roconnor: i think it boils down to ...  "that callCC is not referentially transparent iff  id a = unsafePerformIO (do x <- newEmptyMVar; putMVar x a; takeMVar x)  is not referentially transparent"
16:28:37 <mmorrow> (and the latter _is_ referentially transparent)
16:45:01 <cognominal> When cabal installing pandoc, I get : Error creating man/man1/pandoc.1
16:45:20 <cognominal> how can I skip the installation of the manual?
16:46:07 <cognominal> I suppose I could modify the .cabal file, but I don't know the cabal working directory
16:47:09 <cognominal> or is that the Setup.hs file that I should modify?
16:47:29 <redditbot> Utrecht Summer School 2009: Applied Functional Programming
16:49:00 <Saizan_> cognominal: you'd have to comment out the ,postBuild = ... part from the Setup.hs
16:49:20 <Saizan_> cognominal: then you can run "cabal install" from the directory of the unpacked package
16:49:40 <cognominal> cool, I was about to try that :)
16:50:38 <cognominal> later, how I can diagnose the problem with generating the manual?
16:59:16 <tromp> > ()
16:59:17 <lambdabot>   ()
16:59:28 <lament> >    ()
16:59:29 <lambdabot>   ()
17:00:06 <zax> http://media.fukung.net/images/2085/naked_fan.jpg  - not work safe, although very funny :P
17:03:25 <ozy`> zax: I like how the people with their backs to him are completely oblivious
17:04:45 <zax> Man if that guy jumps forward onto the 2 little girls, they would be scared for life.
17:04:56 <zax> Or wait, they are 4
17:06:38 <whoppix> zax, I think they will notice soon enough..
17:07:09 <whoppix> might be too late by that time, though.
17:11:55 <zax> Yeah, but what would you do if you were 12 years old, watching a football game and suddenly a mid 50 naked man fall over you?
17:12:21 <zax> Hm, let's not go there. Time for sleep, gn!
17:12:36 <Saizan_> btw, #haskell-blah is the place for things like this :)
17:13:00 <dolio> Yes, we're all families in here.
17:15:33 <chessguy> @pl \s -> c (g s) s
17:15:33 <lambdabot> c =<< g
17:15:43 <chessguy> ha
17:17:39 <chessguy> > ((+1) =<< (*2)) 3
17:17:40 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
17:17:40 <lambdabot>      Proba...
17:17:59 <comex> newbie question time
17:18:17 <Axman6> hooray
17:18:26 <chessguy> > ((+) =<< (*2)) 3
17:18:27 <lambdabot>   9
17:18:28 <ozy`> comex: ask away
17:18:49 <chessguy> comex:  we love newbie questions :)
17:18:51 <Axman6> :t ((+) =<<)
17:18:51 <chessguy> makes us feel smart
17:18:52 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
17:18:59 <ozy`> @src (->) >>=
17:18:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:19:02 <ozy`> psh
17:19:10 <ozy`> @src (->) (>>=)
17:19:10 <lambdabot> f >>= k = \ r -> k (f r) r
17:19:20 <comex>  do {num <- [1, 2, 3, 4, 5]; guard (num == 4); return num}
17:19:29 <ozy`> @src (->) return
17:19:29 <lambdabot> return = const
17:19:58 <comex> how exactly does this work? isn't guard just equal to a value? how does it actually manage to 'break out'
17:20:13 <chessguy> @type guard
17:20:14 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:20:27 <Saizan_> > guard (num == 4) :: [()]
17:20:27 <chessguy> @src guard
17:20:27 <lambdabot> guard True  =  return ()
17:20:27 <lambdabot> guard False =  mzero
17:20:28 <lambdabot>   Not in scope: `num'
17:20:36 <Saizan_> > guard (1 == 4) :: [()]
17:20:37 <lambdabot>   []
17:20:40 <Saizan_> > guard (4 == 4) :: [()]
17:20:41 <lambdabot>   [()]
17:21:18 <chessguy> guard has now officially been dissected and laid out on the table :)
17:21:22 <comex> heh
17:21:22 <Saizan_> comex: in the list monad [] means that you've to abandon that branch of computation and backtrack to another
17:21:43 <roconnor> mmorrow: this is tougher than I thought
17:22:05 <dolio> What are you doing? Still proving that his native continuations aren't referrentially transparent?
17:22:12 <roconnor> right
17:23:58 <dolio> Oh, it's wrapped in an Id?
17:24:14 <dolio> What happens when you run my costrength function with it?
17:24:18 <dolio> That's a pretty evil function.
17:24:29 <roconnor> :)
17:24:37 <roconnor> probably throws an exception
17:24:44 <dolio> Ah, okay.
17:24:47 <roconnor> > runId $ callCC (\k -> return $ const True $! a k)
17:24:48 <lambdabot>   Not in scope: `runId'
17:24:49 <roconnor> False
17:25:01 <roconnor> *Main> runId $ callCC (\k -> return $ const True $ a k)
17:25:02 <roconnor> True
17:25:08 <roconnor> does that count as not referentially transparent?
17:25:24 <roconnor> I'm not happy about my use of seq
17:25:28 <dolio> Wow.
17:25:52 <roconnor> oh
17:26:01 <roconnor> let a k = k False
17:26:33 <roconnor> I don't think what I have counts
17:26:39 <comex> oh, so this works because multiple statements in a do use >>
17:26:43 <roconnor> it is close
17:27:06 <Olathe> @pl \k -> k False
17:27:06 <lambdabot> ($ False)
17:27:31 <Cale> comex: yeah, and in the list monad, >>= is effectively concatMap
17:27:32 * mmorrow cackles
17:27:34 <Olathe> That's supposed to be numeric, not boolean.
17:28:11 <roconnor> dolio: can I use callCC to be the "identity function" but as a side effect apply not to the result of the whole computation?
17:29:45 <dolio> I'm not sure I understand that question.
17:30:07 <roconnor> consider Cont Bool
17:30:50 <mmorrow> ghci> costrength [Right 4]
17:30:51 <mmorrow> Left [*** Exception: <<Int>>
17:31:16 <roconnor> I want to do runCont id (callCC \k -> liftM2 (==) (return 8) (returnButWithASideEffectNegeatingTheWholeComputation k 8))
17:31:19 <roconnor> and get False
17:31:40 <mmorrow> and if that delimCC function wasn't shoehorned into Id and just had the P hidden i don't think you'd even be able to get it to throw such an exception
17:31:52 <mmorrow> (barring use of unsafeCoerce)
17:32:52 <mmorrow> cwcc f = prompt (\p -> delimCC p f)
17:33:10 <mmorrow> cwcc :: ((a -> b) -> a) -> a
17:33:34 <Saizan_> which package/code snippet are we talking about?
17:34:03 <roconnor> ugh, all these scheme call/cc examples use set!
17:34:08 <roconnor> that isn't informative for me
17:36:43 <kmeyer> does fgl actually *draw* graphs?
17:36:53 <kmeyer> or does it just do graph manipulation?
17:37:03 <mmorrow> kmeyer: dump to graphviz .dot
17:37:09 <kmeyer> ah, cool
17:37:13 <kmeyer> very cool.
17:37:25 <mmorrow> i mean, as in that's a way to do that (nicely)
17:37:35 <mmorrow> not sure in fgl has canned functions though
17:38:01 <mmorrow> (i have some i can paste though for a (Show a) => [(a,[a])])
17:38:10 <dolio> It may be that this formulation is fine. But Id is not the identity monad.
17:38:19 <dolio> It's the magic continuation monad.
17:38:25 <mmorrow> yes indeed! :)
17:38:30 <mmorrow> haha
17:38:41 <mmorrow> MCM ?
17:38:46 <dolio> Like adding continuations to IO.
17:39:25 <mmorrow> well that's essentially what it's doing
17:39:46 <dolio> But you might be able to do bad things, because it doesn't have a region parameter.
17:39:52 <mmorrow> then just unsafePerformIO'ing away the indiscretions
17:40:07 <mmorrow> dolio: ah, like P ans a ?
17:40:11 <dolio> Similar to using STRefs in the wrong place.
17:40:15 <mmorrow> hmm
17:40:35 <roconnor> ugh
17:40:43 <roconnor> I want to see some advanced examples of callCC
17:40:53 <roconnor> something other than exceptions
17:40:59 <mmorrow> oh, i think this might be taken care of by the test for equality of the Ints inside the P's in the catchDyn
17:41:31 <dolio> Yeah, but that will just throw a runtime exception instead of statically telling you you're messing up.
17:41:35 <dolio> ST could do the same thing.
17:41:48 <mmorrow> true, but that's just because i'm bothering with that Id monad
17:41:58 <mmorrow> i don't think exceptions are possible with:
17:42:08 <mmorrow> cwcc :: ((a -> b) -> a) -> a
17:42:08 <mmorrow> cwcc f = prompt (\p -> delimCC p f)
17:42:17 <mmorrow> (i'm not positive of course)
17:42:23 <dolio> Getting continuations out of a continuation monad is a pain, though.
17:42:28 <dolio> Because it easily leads to infinite types.
17:42:33 <mmorrow> yeah totally a pain
17:42:46 <dolio> You need something like monadLib's Label newtype.
17:42:51 * mmorrow has tried this unsuccessfully sooo many time
17:43:01 <mmorrow> dolio: heh, i just saw that actually
17:43:08 <dolio> Which I always try to come up with on my own, but fail to do so. :)
17:43:18 <mmorrow> looks super useful
17:43:32 <mmorrow> dolio: me too
17:43:54 <Saizan_> ?djinn ((a -> b) -> a) -> a
17:43:54 <lambdabot> -- f cannot be realized.
17:43:57 <Saizan_> !!!
17:44:00 <mmorrow> hehe
17:44:03 <mmorrow> magic
17:47:30 <redditbot> Resource-safe EDSLs
17:48:53 <mmorrow> Saizan_: without the Id nonsense: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341#a1341
17:49:08 <dolio> That's even worse.
17:49:11 <mmorrow> heh
17:49:19 <ddarius> Saizan_: Implementing a single shot callCC with that type is very easy.
17:49:29 <mmorrow> this one has multiple prompts!
17:49:47 <roconnor> ddarius: help me prove it isn't referentially transparent
17:50:50 <Saizan_> ddarius: not without using unsafeSomething i guess?
17:51:06 <ddarius> Saizan_: You need unsafePerformIO of course.
17:51:35 <comex> stupid question 2
17:52:14 <comex> given 'data Wrapped a = Wrap a', how would I declare an instance so that show (Wrap a) = show a
17:52:39 <mmorrow> instance Show (Wrapped a) = <insert exactly what you wrote>
17:52:41 <mmorrow> :)
17:52:49 <Saizan_> s/=/where/
17:52:50 <mmorrow> oops  .... where ...
17:52:55 <Saizan_> and Show a =>
17:53:01 <mmorrow> that too
17:53:03 <comex> [20:52] <Saizan_> and Show a =>
17:53:06 <comex> that's what I'm looking for
17:53:11 <Saizan_> instance Show a => Show (Wrapped a) where show (Wrap a) = show a
17:53:51 <ddarius> -
17:53:52 <ddarius> =
17:54:20 * comex bookmarks the haskell syntax page
18:05:59 <Olathe> > let primes = 2:3:f (tail primes) [5,7..] where f (p:ps) xs = let (ys, _:zs) = break (==(p*p)) xs in ys ++ f ps (filter (\z -> mod z p /= 0) zs) in primes !! 100000
18:06:12 <lambdabot>   1299721
18:10:53 <chessguy> @src replicate
18:10:53 <lambdabot> replicate n x = take n (repeat x)
18:12:33 <nerdlor> mmorrow: many thanks -- i had tried insertWith', but not foldl'.
18:14:57 <dolio> mmorrow: These continuations don't work very well.
18:15:08 <dolio> Most things I'm trying result in exceptions.
18:15:28 <mmorrow> nerdlor: great :)
18:15:39 <mmorrow> dolio: haha, i spoke too soon (yet again ;)
18:16:07 <nerdlor> mmorrow: yeah, i've got some deeper thinking to do wrt laziness and strictness. newbie mistake, i guess...
18:16:12 <dolio> Which probably improves their 'referrential transparency' but only because you can't do the evil things you should be able to do. :)
18:16:13 <mmorrow> dolio: i just got an exception too. i think it's on account of not a specific enough type sig for the Typeable
18:16:27 <mmorrow> dolio: hehe, exactly!
18:17:22 <mmorrow> nerdlor: that case (with insertWith' + foldl' for Maps) comes up a bunch (or at least in my experience), i almost see it as an idiom
18:17:43 <roconnor> mmorrow: your callCC is kinda sucky
18:17:45 <roconnor> :)
18:17:47 <dolio> Like, "bad :: Either (Int -> Int) Int ; bad = cwcc (\k -> Right $ cwcc (\k' -> k (Left k')) + 5)".
18:17:52 <mmorrow> roconnor: :)
18:17:55 <roconnor> Main> runId $ do { p <- callCC (\k -> return (Left (\a -> (k (Right a))))); either (\f -> f True) (return . Right) p }
18:17:57 <roconnor> *** Exception: (unknown)
18:18:11 <roconnor> Control.Monad.Cont> runId $ do { p <- callCC (\k -> return (Left (\a -> (k (Right a))))); either (\f -> f True) (return . Right) p }
18:18:12 <roconnor> Right True
18:18:13 <mmorrow> roconnor: don't take out your frustration on me ;)
18:18:22 <dolio> If you do "either (\_ -> "left") (\_ -> "right") bad" you get "right".
18:18:44 <roconnor> mmorrow: it doesn't work as well as Cont, so it is hard to break referential transparency
18:19:12 <dolio> Maybe I'm not evaluating enough.
18:19:24 <mmorrow> well, Cont works because it's doing no funny stuff. cwcc works because it's being debaucherous
18:19:36 <roconnor> mmorrow: I could implement runId as throw "(unknown)" and be close to your implementation :P
18:19:53 <mmorrow> roconnor: sure, if all you run is `bad' :)
18:20:10 <roconnor> the example above isn't bad
18:20:13 <mmorrow> roconnor: oh, i've also eliminated the whole `Id' from the equation
18:20:22 <mmorrow> to cut down on exceptions
18:20:36 <mmorrow> the Id only introduces problems
18:20:50 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341
18:21:18 <mmorrow> the only way to get an exception now is to not be specific enough with a type so that Typeable can figure it out
18:21:44 <dolio> mmorrow: I'm not using the Id version.
18:22:05 <mmorrow> oh, what's the expression?
18:22:28 <Cale> Olathe: Where did you get that code?
18:22:52 <roconnor> CallCC> let p = cwcc (\k -> (Left (\a -> (k (Right a))))) in either (\f -> f True) (Right) p
18:22:53 <roconnor> *** Exception: (unknown)
18:23:30 <mmorrow> oh, ok ammending my statement.... you can't segfault ;)
18:24:02 <roconnor> I'm starting to think that it might be referentially transparent, given that it throws so many excpetions
18:24:12 * Saizan_ waits for "you can might away from the sharks surrounding you"
18:24:22 * mmorrow likes to make outrageous claim after outrageous claim until he's explicitly proven wrong, then make another until sooner or later he makes one that turns out to be true
18:24:33 <mmorrow> :)
18:24:34 <roconnor> mmorrow: it's good practice
18:24:59 <drhodes> I've managed to implement the game of life.   nextGrid . nextGrid $ firstGrid  will perform 2 steps in the game.  I'd like to print each step as it goes but suffer imperitivitis and want to {while 1: grid = nextGrid grid; print grid.} buts that no good three ways from sunday.
18:25:17 <roconnor> mmorrow: I'll simply classify your cwcc as broken until it can handle the above simple example
18:25:40 <Toxaris> > iterate succ 0
18:25:41 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:25:52 <Saizan_> drhodes: mapM_ printGrid $ iterate nextGrid firstGrid
18:25:53 <dolio> cwcc (\k -> let m = cwcc (\k' -> k (Left k')) in (Right (m + 5))) is a Right
18:26:01 <dolio> cwcc (\k -> let m = cwcc (\k' -> k (Left k')) in m `seq` (Right (m + 5))) is a Left
18:26:16 <Toxaris> drhodes: (iterate nextGrid firstGrid) gives you all the intermediate states of the game, just print them in order
18:26:17 <roconnor> dolio: you did it!
18:26:20 <mmorrow> shit.
18:26:22 * drhodes will investigate the matter, thanks!
18:26:26 <roconnor> dolio: oh did you?
18:26:30 <mmorrow> i'm not sure yet
18:26:35 <dolio> Not exactly.
18:26:36 <roconnor> dolio: is seq cheating
18:26:49 <drhodes> wow, much easier than I thought!
18:26:52 <roconnor> I guess m `seq` isn't always id
18:26:55 <dolio> Seq is the only way to get continuations to be called.
18:27:10 <roconnor> dolio: I think it is cheating
18:27:17 <dolio> It may be.
18:27:36 <roconnor> dolio: I think the trick will be to get let x = expr in f x x to be different from f (expr) (expr)
18:27:46 <mmorrow> yeah, i don't think that counts
18:27:48 <mmorrow> phew
18:27:49 <roconnor> dolio: then it will clearly be not referentially transparent
18:27:56 <dolio> But if you don't use seq, then when you look inside the Right in the first expression, it's supposed to evaluate m, which will go back in time and change the Right to a Left.
18:28:23 <dolio> It just doesn't work with lazy evaluation.
18:28:53 <mmorrow> yeah, the laziness messes with stuff for sure
18:29:02 <mmorrow> oh, i just got an idea
18:29:18 <mmorrow> if this was embedded within ST, then laziness wouldn't be an issue
18:29:26 <mmorrow> since everything in there is strict
18:29:39 <mmorrow> i think
18:29:46 <mmorrow> hmm
18:31:08 <Saizan_> ?hoogle Control.Monad.ST.Lazy
18:31:08 <lambdabot> module Control.Monad.ST.Lazy
18:31:08 <lambdabot> package lazyarray
18:31:08 <lambdabot> package lazysmallcheck
18:31:28 <mmorrow> ok, make that strict ST
18:31:30 <Saizan_> that'd be a bad name if everything was strict
18:33:47 <dolio> I don't think you can make this make sense outside of a monad with the way you normally think of semantics in Haskell.
18:34:04 <mmorrow> i agree
18:34:21 <dolio> Because it's by nature not referrentially transparent.
18:34:34 <dolio> And instead of being that way, it just errors out.
18:34:51 <chessguy> yay tic-tac-toe strategy :)
18:34:53 <chessguy> http://codepad.org/nN9JsxFK
18:35:40 <mmorrow> dolio: yeah. how is the way that this errors out similar/different from the way ccdelcont will error out with a "prompt not found on stack"?
18:35:56 <gweiqi> is seq built in, or is it implemented with case?
18:36:01 <mmorrow> i'm trying to pin it down, but i'm not sure
18:36:06 <chessguy> @src seq
18:36:06 <lambdabot> Source not found. There are some things that I just don't know.
18:36:12 <mmorrow> gweiqi: it's built in
18:36:21 <sereven> hmm, how to  `a ->  [(a -> a)] -> a' where it's something like folding with (.) ? in other words I want to compose each of the list elements, apply each in turn, with the first argument starting the ball rolling (actually it's second, but can flip)
18:36:23 <mmorrow> gweiqi: because it's not implementable in haskell
18:36:25 <gweiqi> mmorrow: could it be implemented with case and a default alternative?
18:36:34 <chessguy> @faq can haskell have things that lambdabot doesn't know about??
18:36:34 <lambdabot> The answer is: Yes! Haskell can do that.
18:36:43 <dolio> mmorrow: You have to write cc-delcont stuff in monadic style, so the flow control actually makes sense there.
18:36:45 <mmorrow> gweiqi: the stopper is that it's polymorphic
18:37:11 <chessguy> @hoogle a -> [a -> a] -> a
18:37:11 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
18:37:11 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
18:37:11 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
18:37:13 <Olathe> Cale: I made it.
18:37:18 <dolio> With 'cwcc :: ((a -> b) -> a) -> a' you can get things that are supposed to be constant, but then should go back in time and change what they are and stuff.
18:37:20 <Toxaris> gweiqi: I don't think so. You can use seq on functions.
18:37:22 <chessguy> @type foldr ($)
18:37:24 <lambdabot> forall b. b -> [b -> b] -> b
18:37:31 <mmorrow> dolio: oh, i see
18:37:39 <gweiqi> mmorrow: this doesn't work? seq a b = case a of _ -> b
18:37:39 <chessguy> sereven:  ^^
18:37:40 <Toxaris> > (error "evaluated") :: (Int -> Int) `seq` ()
18:37:41 <lambdabot>       No instance for (Show (seq (Int -> Int) ()))
18:37:41 <lambdabot>        arising from a use ...
18:38:03 <roconnor> mmorrow: huh? why do you agree with dolio ?
18:38:14 <mmorrow> , let seq a b = case a of _ -> b in undefined `seq` 42
18:38:15 <lunabot>  42
18:38:19 <sereven> chessguy: hmm, yeah, foldr ($) was what I was trying, type checks but my logic must be wrong or something, not correct result
18:38:41 <roconnor> mmorrow: that's due to how default cases are handled
18:38:58 <gweiqi> mmorrow: i see, so haskell eliminates the unnecessary case, rather than having it evaluate a first?
18:39:01 <mmorrow> roconnor: i agree that you can't think you can make sense of it the way you normally think about stuff in haskell because it works in a different way
18:39:06 <chessguy> > foldr ($) 2 [(+2),(*7),(+3)]
18:39:08 <lambdabot>   37
18:39:31 <mmorrow> roconnor: you can't implement seq in haskell
18:39:39 <chessguy> sereven:  you may want to fold in the other direction, depending on what you're doing
18:39:42 <mmorrow> haskell98
18:39:58 <sereven> foldr is correct for this
18:40:06 <chessguy> > foldl' ($) 2 [(+2),(*7),(+3)]
18:40:08 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
18:40:08 <lambdabot>      Proba...
18:40:11 <mmorrow> , let seq !a b = b in undefined `seq` 42
18:40:12 <lunabot>  luna: Prelude.undefined
18:40:28 <roconnor> mmorrow: how come "let m = cwcc (\k1 -> Left (k1 (Right ()))) in either id Right m" doesn't work?
18:40:41 <mmorrow> roconnor: i'm not sure
18:40:43 * mmorrow tries it
18:40:53 <roconnor> mmorrow: I can't change the value of m once I've set it?
18:40:53 <chessguy> @type foldl' ($)
18:40:54 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
18:40:54 <lambdabot>     Probable cause: `$' is applied to too many arguments
18:40:54 <lambdabot>     In the first argument of `foldl'', namely `($)'
18:41:24 <mmorrow> roconnor: give a typesig
18:41:25 <Toxaris> > foldl' (flip ($)) 2 [(+ 2), (* 7), (+ 3)]
18:41:27 <lambdabot>   31
18:41:33 <mmorrow> the Typeable is failing in that one
18:41:35 <chessguy> oh
18:41:36 <chessguy> silly me
18:42:01 <mmorrow> oh wait, maybe not
18:42:05 <roconnor> let m = cwcc (\k1 -> Left (k1 (Right ()))) in either id Right m :: Either ()()
18:42:07 <roconnor> *** Exception: (unknown)
18:42:11 * chessguy is quite curious about his strange new combinator library
18:42:12 <Toxaris> > foldl' (flip ($)) x [(+ 2), (* 7), (+ 3)]
18:42:14 <lambdabot>   (x + 2) * 7 + 3
18:42:20 <hackage> Uploaded to hackage: hsql-postgresql 1.7.2
18:42:38 <Olathe> > let primes = 2:3:f 5 [] (tail primes) where f start ds (p:ps) = let pSq = p*p in foldr (\el ac -> filter (\x -> mod x el /= 0) ac) [start, start + 2..pSq - 2] ds ++ f (pSq + 2) (p:ds) ps in primes !! 115000
18:42:53 <lambdabot>   1511563
18:43:31 <mmorrow> roconnor: i don't know why that doesn't work
18:44:18 <roconnor> mmorrow: can I only use your cwcc for escaping outwards?
18:44:35 <dolio> I think that's it.
18:44:37 <mmorrow> roconnor: i think so, since it uses the exception mechanism
18:44:49 <roconnor> dolio: hmm
18:45:03 <dolio> Is modify the right thing to click to annotate on hpaste2?
18:45:06 <roconnor> dolio: so maybe it is referentially transparent
18:45:15 <mmorrow> dolio: yeah
18:45:58 <roconnor> I can never call a continuation twice
18:46:16 <dolio> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341#a1344
18:46:16 <mmorrow> no, since it will already have been caught
18:46:28 <dolio> I think that should be an example of something bad.
18:46:29 <mmorrow> each cont has only one prompt associated with it
18:46:40 <dolio> But it just errors out, of course.
18:46:42 <mmorrow> if you call it twice, the exception will propogate to top-level
18:47:55 <dolio> In that, when you do case analysis on zoom the first time, it should be a Left, and then you should call f 5, and it should turn into a Right, which the second case analysis picks up (and then I failed to distinguish by making them both 0...).
18:47:57 <roconnor> that's why I keep getting exception unknown when I try to do intersting stuff
18:48:11 <dolio> Whereas if you inline and put "bad 5" in both places, they'll both be Lefts.
18:48:33 <dolio> Except, it's not clear where invoking "f 5" should take you as far as evaluation goes.
18:48:37 <roconnor> dolio: what do you get in practice?
18:48:50 <dolio> Should it take you back to the first case analysis? Etc.
18:48:50 <mmorrow> oh, maybe the prompt/delimCC functions need to be used directly to actually get multiple prompts to work correctly
18:49:03 <dolio> In practice you get "*** Exception: <<Int>>".
18:49:10 <roconnor> right
18:50:21 <mmorrow> i think this would need to be implemented at the rts level to actually make it work like "it should"
18:50:33 <mmorrow> like how sml(nj) does callcc
18:50:54 <Taejo> how would I diagnose *what* is going onto the stack that is causing stack overflows?
18:51:12 <mmorrow> but even then, with lazy eval outside of a monad i think you'd have the same problems
18:52:16 <mmorrow> Taejo: look for an accumulating parameter that's never being (e.g.) tested against another value (since that would force eval of it), or explicitly forced
18:52:39 <mmorrow> barring looking for such things, i don't know of a good way
18:52:57 <Taejo> mmorrow: that's exactly what I was hoping you wouldn't say
18:53:08 <mmorrow> :(
18:53:15 <roconnor> mmorrow: by working as it should, you mean not referentially transparent?
18:53:26 <mmorrow> roconnor: i'm not sure
18:53:34 <roconnor> :)
18:53:35 <mmorrow> i guess i might
18:54:31 <dancor> is anything not referentially transparent in haskell currently
18:54:38 <mmorrow> well, sml is strict but i'm not sure that callcc in sml necessarily implies non-referential transparency
18:54:46 <roconnor> dancor: unsafePerformIO
18:54:50 <dancor> oh duh
18:55:01 <roconnor> which isn't really part of Haskell
18:55:07 <mmorrow> System.Info.os
18:55:14 <mmorrow> maxBound :: Int
18:55:15 <dancor> isn't it used in like readFile
18:55:29 <roconnor> mmorrow: those don't count.  They are constant for the lifetime of the program
18:55:46 <mmorrow> roconnor: what if your prog migrates to another machine?
18:55:51 <mmorrow> ;)
18:56:13 <roconnor> mmorrow: your program manipulation is still sound
18:56:38 <roconnor> mmorrow: if you change A to and equivalent program B, A and B are still equivalent on the new system
18:56:49 * ddarius wonders if he could abuse STM's retry to get multi-shot continuations.
18:57:10 <mmorrow> let foo x = if "linux" == os then x else error "omgomg"
18:57:26 <ddarius> unsafePerformIO is in the FFI addendum
18:57:39 <mmorrow> freeze your heep, send to another machine, run it
18:57:42 <SamB> ddarius: it sounds about as safe as unsafeCoerce
18:57:44 <mmorrow> omgomg
18:57:51 <mmorrow> *heap
18:58:11 <SamB> or possibly as safe as trusting a negative result from unsafePtrEquality
18:58:18 <mmorrow> ddarius: go for it
18:58:20 <roconnor> mmorrow: the catch is that you are not allowed to substitute  System.Info.os with it's "definition" during your program manipulation because  System.Info.os has no transparent definition.
18:58:25 <dolio> mmorrow: Migrating to a different machine doesn't change the constants that got compiled into your statically linked program. :)
18:58:44 <dancor> @src getContents
18:58:45 <lambdabot> getContents = hGetContents stdin
18:58:49 <dancor> @src hGetContents
18:58:49 <lambdabot> Source not found. Just try something else.
18:59:02 <mmorrow> dolio: then System.Info.os would be incorrect then
18:59:08 <dolio> Yep.
18:59:37 <mmorrow> hmm, i'm not sure if that's better or worse
18:59:49 <Taejo> @hoogle comparing
18:59:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
18:59:50 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:00:09 <mmorrow> what if System.Info.os is implemented as   unsafePerformIO (getMaOSPleez)
19:00:21 <mmorrow> and you haven't called it yet before migration?
19:00:23 <geezusfreeek> ddarius, multishot in the sense that you can go to the same continuation twice?
19:00:35 <SamB> mmorrow: well, I don't see how else it could do much else on binary distributions
19:00:47 <SamB> er.
19:00:54 <SamB> take out the second else.
19:00:55 <ddarius> geezusfreeek: Yes, though I'd word it as multi-shot in that callCC can return more than once.
19:01:09 <geezusfreeek> ah yes
19:01:14 <mmorrow> SamB: i dunno, i'm just playing devil's advocate
19:01:23 <SamB> ddarius: you will kill the RTS dead, you will
19:01:29 <ddarius> SamB: That's what I hear.
19:01:46 <SamB> I think you'd better just come up with a pure way to do it
19:01:56 <geezusfreeek> ddarius, could that not be achieved by passing the continuation to itself?
19:02:10 <ddarius> SamB: Come up with a pure way to implement impure full continuations?
19:02:16 <SamB> ddarius: no!
19:02:25 <geezusfreeek> with a newtype wrapper to avoid infinite type, of course
19:02:34 <SamB> ddarius: that's what you shouldn't be doing
19:03:14 <SamB> I mean, unless you wanted to use setjmp/longjmp ;-P
19:03:18 * mmorrow disappears
19:03:41 <ddarius> chessguy: Your thingy doesn't have particularly much to do with continuations, what you want to look at is process trees.  Essentially your Plan type is a process tree of a's with transitions for each possible following Plan.
19:04:31 <chessguy> ddarius: hmmm. but continuations also have to do with how the computation proceeds, right? why is it not related?
19:06:25 <ddarius> chessguy: Continuations are related to concurrency, but your type is much closer to a semantic domain of a process algebra/calculus, e.g. the pi calculus or CSP than to a continuation type.
19:06:52 <chessguy> ddarius:  ok, thanks for the tip. i'll google up some of those terms. what is CSP?
19:07:02 <ddarius> Communicating Sequential Processes
19:07:03 <geezusfreeek> concurrent sequential processes
19:07:05 <geezusfreeek> err that
19:07:10 <geezusfreeek> :)
19:07:17 <chessguy> @fail geezusfreek
19:07:17 <lambdabot> Maybe you meant: fact faq
19:07:21 <geezusfreeek> :(
19:07:21 <ddarius> http://www.usingcsp.com/
19:07:49 <chessguy> hm, i recognize the name Hoare from somewhere
19:07:58 <ddarius> He's pretty notable.
19:08:20 <ddarius> Hoare triples, quicksort
19:09:01 <Taejo> @hoogle on
19:09:01 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:09:01 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
19:09:01 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
19:09:25 <chessguy> ddarius:  cool, thanks
19:10:33 <chessguy> i'm sure any existing work would have a much cleaner interface :)
19:10:34 <ddarius> Hmm, I guess the fact that your Strategy type leads to taking a whole plan would lead to something like a "higher-order" process language.
19:13:48 <chessguy> ddarius:  hmm. i don't get how what i'm doing is related to concurrent channels
19:14:43 <ddarius> You can view your type as being a response/request interleaving.
19:15:58 <ddarius> Game semantics (as in game theory) would probably be a closer fit.
19:16:09 <ddarius> Which is perhaps very not surprising.
19:16:31 <chessguy> well, that suggests that i could be doing something right, which could in fact be surprising :)
19:16:54 <chessguy> hmm. it's not really interleaving
19:17:03 <chessguy> not always anyway
19:19:33 <Cale> Olathe: It's a neat idea. :)
19:20:15 <Cale> It performs rather well for its length :)
19:21:14 <chessguy> Cale:  hm?
19:21:29 <mmorrow> dolio, roconnor: this cwcc works for the "back in time" (kinda) by adding an NFData constraint http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341#a1345
19:22:51 <roconnor> mmorrow: what types do and don't satisfy that constraint?
19:22:52 <Olathe> Cale: Thanks :)
19:23:06 <mmorrow> roconnor: whatever's an instance of NFData
19:23:15 <Olathe> chessguy: I put it up at http://www.haskell.org/haskellwiki/Prime_numbers#Simple_Prime_Sieve_III
19:23:36 <mmorrow> (i don't use it very much so i'm not sure what types have default instances)
19:24:45 <Spark> i'm stuck in vga at the moment
19:24:52 <Spark> but does it do a brute force iteration?
19:24:57 <roconnor> > let notReturn k x = callCC (\l -> k (not (runCont (l x) id))) in flip runCont id $ callCC (\k -> liftM2 (==) (return 8) (notReturn k 8))
19:24:57 <Spark> or is it clever
19:24:58 <lambdabot>   False
19:25:21 <roconnor> > flip runCont id $ callCC (\k -> let notReturn x = callCC (\l -> k (not (runCont (l x) id))) in  liftM2 (==) (return 8) (notReturn 8))
19:25:22 <lambdabot>   False
19:25:27 <roconnor> whee
19:25:32 <roconnor> that's what I was trying to do earlier
19:25:38 <roconnor> > flip runCont id $ callCC (\k -> let notReturn x = callCC (\l -> k (not (runCont (l x) id))) in  liftM2 (==) (notReturn 8) (notReturn 8))
19:25:39 <lambdabot>   True
19:25:42 <dolio> Functions are not NFData.
19:25:47 <dolio> Importantly.
19:26:02 <roconnor> dolio: ^^ that is what I was trying to do before
19:26:14 <dolio> Ah.
19:26:24 <roconnor> notReturn is like return, except it negates the result of the computation as a side effect
19:27:08 <dolio> > flip runCont id $ callCC (\k -> let notReturn = mapCont not . return in liftM2 (==) (notReturn 8) (notReturn 8))
19:27:09 <lambdabot>   True
19:27:14 <dolio> > flip runCont id $ callCC (\k -> let notReturn = mapCont not . return in liftM2 (==) (return 8) (notReturn 8))
19:27:16 <lambdabot>   False
19:27:20 <roconnor> oooh
19:27:22 <roconnor> mapCont
19:27:26 <roconnor> @type mapCont
19:27:27 <lambdabot> forall r a. (r -> r) -> Cont r a -> Cont r a
19:27:42 <roconnor> indeed, what I want.
19:28:15 <roconnor> @src mapCont
19:28:16 <lambdabot> Source not found. Take a stress pill and think things over.
19:28:23 <roconnor> @src Control.Monad.Cont.mapCont
19:28:23 <lambdabot> Source not found. Wrong!  You cheating scum!
19:28:43 <geezusfreeek> @hoogle mapCont
19:28:43 <lambdabot> Control.Monad.Cont mapCont :: (r -> r) -> Cont r a -> Cont r a
19:28:43 <lambdabot> Control.Monad.Cont mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
19:28:54 <geezusfreeek> :(
19:29:31 <ddarius> @djinn (r -> r) -> Cont r a -> Cont r a
19:29:31 <lambdabot> Error: Undefined type Cont
19:29:42 <roconnor> CallCC> let c k x = cwcc (\l -> k (l x)) in cwcc (\k -> 8 == c k 8)
19:29:43 <roconnor> *** Exception: (unknown)
19:29:45 <roconnor> awww
19:29:48 <roconnor> boring
19:29:51 <roconnor> :P
19:30:03 <ddarius> @djinn-add type Cont r a = (a -> r) -> r
19:30:07 <geezusfreeek> @djinn (r -> r) -> (a -> r) -> r
19:30:07 <lambdabot> -- f cannot be realized.
19:30:12 <geezusfreeek> oops
19:30:13 <ddarius> @djinn (r -> r) -> Cont r a -> Cont r a
19:30:13 <lambdabot> f a b c = a (b c)
19:30:24 <geezusfreeek> beat me
19:30:36 <roconnor> mmorrow: let me try your new NFData
19:30:44 <ddarius> mapCont = (.)
19:31:51 <roconnor> mmorrow: still the same
19:32:11 <roconnor> > let c k x = cwcc (\l -> k (l x)) in cwcc (\k -> 8 == c k 8)
19:32:12 <roconnor> *** Exception: (unknown)
19:32:13 <lambdabot>   mueval: Prelude.read: no parse
19:32:13 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
19:32:20 <mmorrow> oh crap, your right
19:32:59 <mmorrow> yeah, cwcc just can't work with laziness
19:33:07 * mmorrow moves on
19:33:21 <roconnor> actually I wanted to do let c k x = cwcc (\l -> k (not (l x))) in cwcc (\k -> 8 == c k 8)
19:33:23 <roconnor> but whatever
19:33:38 <roconnor> mmorrow: sorry
19:33:53 <roconnor> mmorrow: I learned a lot about continuations though :)  I hope you did too
19:34:11 <dolio> I don't think that will do what you want.
19:34:23 <dolio> Even in a language where continuations work right.
19:34:29 <mmorrow> ahah! i just got it to work
19:34:35 <roconnor> dolio: you mean let c k x = cwcc (\l -> k (not (l x))) in cwcc (\k -> 8 == c k 8) ?
19:34:38 <mmorrow> change cwcc to  cwcc f = let x = prompt (\p -> delimCC p f) in rnf x `seq` x
19:34:53 <mmorrow> (and you can delete the rnf from delimCC i guess
19:34:54 <mmorrow> )
19:34:55 <ddarius> @src using
19:34:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:35:04 <dolio> Because (l x) aborts, so c k x = cwcc (\l -> k (not (l x)) is the same as c k x = x.
19:36:04 * mmorrow has renewed hope for the NFData-crippled version of cwcc
19:36:14 <roconnor> dolio: it worked in Cont Bool
19:36:29 <dolio> That's because you used runCont, which delimits the computation.
19:36:35 <roconnor> oh right
19:36:45 <roconnor> damn
19:37:20 <mmorrow> ghci> let m = cwcc (\k -> Left (k (Right ()))) in either id Right m :: Either () ()
19:37:21 <mmorrow> Right ()
19:38:15 <ddarius> That's no problem.
19:38:46 <mmorrow> you can't remove the rnf from delimCC apparently
19:38:51 <roconnor> mmorrow: you can't get rid of the rnf from delimCC
19:38:55 <mmorrow> heh
19:39:06 <ddarius> What you want is: either ($ 1) n m ~> 1 where m :: Either (Int -> Int) Int
19:39:31 <roconnor> mmorrow:  and let c k x = cwcc (\l -> k (not (l x))) in cwcc (\k -> 8 == c k 8) still doesn't work for me (even though it doesn't do what I want)
19:39:31 <mmorrow> touched up http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341#a1346
19:39:32 <ddarius> er either ($ n) id m ~> n
19:40:39 <ddarius> I will be impressed if someone can make a callCC :: ((a -> b) -> a) -> a such that either ($ n) id (callCC (\k -> Left (k . Right))) reduces to n.
19:40:49 <mmorrow> roconnor: hmm, i'm not sure if that one should even work at all
19:42:04 <juhp> hmm cabal-install-0.4.0 was a bit basic...
19:43:20 * ddarius could probably write some -extremely- implementation dependent FFIy code to implement a primitive that would allow that (and probably break half the time too)
19:44:22 <ddarius> 'might need to change the type slightly to ((a -> b) -> a) -> () -> a
19:45:03 <mmorrow> roconnor: yeah, that wouldn't work even if cwcc worked "perfectly", since unrolling
19:45:05 <mmorrow> cwcc (\k -> 8 == cwcc (\l -> k (not (l 8))))
19:45:26 <mmorrow> that's a loop
19:45:31 <mmorrow> , fix (\x -> x)
19:45:32 <dolio> It's True.
19:45:36 <lunabot>  luna: out of memory (requested 2097152 bytes)
19:45:49 <mmorrow> dolio: it does work?
19:46:13 <chessguy> @pl \l -> k (not (l 8))
19:46:13 <lambdabot> k . not . ($ 8)
19:46:13 <ddarius> mmorrow: He explained what it does (under the implicit assumption that k is strict.)
19:46:14 <dolio> Well, I mean, assuming we're doing regular old eager evaluation.
19:46:23 <dsrogers> is there documentation on how WriterT works?
19:46:33 <dsrogers> or Writer generally?
19:46:34 <dolio> cwcc (\l -> k (not (l 8)) = 8
19:48:32 <lispy> dsrogers: definitely
19:48:42 <dsrogers> lispy: where?
19:49:07 <lispy> dsrogers: Well, there are monad guides which cover Writer.  Maybe start there?  the all about monads is good
19:49:20 <dsrogers> ok.  thanks.
19:49:28 <lispy> http://www.haskell.org/all_about_monads/html/writermonad.html
19:49:36 <dsrogers> I was looking in the haskell hierarchical libraries.
19:49:46 <dsrogers> the documentation there is terrible.
19:49:48 <lispy> oh yeah
19:50:14 <lispy> dsrogers: for WriterT, there are research papers that cover transformers and the tutorial I just linked has a section on them
19:50:16 <ddarius> http://web.archive.org/web/20070610100220/http://haskell.org/hawiki/MonadWriter
19:50:29 <dsrogers> thanks.
19:50:44 <lispy> dsrogers: if you still have questions after trying those examples, come back with the questions and I'm sure we can fill in the details
19:51:02 <mmorrow> dang, you're right
19:51:03 <mmorrow> - callcc (fn k => 8 = callcc (fn l => throw k (not (throw l 8))));
19:51:03 <mmorrow> val it = true : bool
19:51:10 <mmorrow> (smlnj)
19:51:21 <dolio> How about my evil example?
19:51:26 <mmorrow> checking...
19:51:31 <mmorrow> err, which one?
19:51:32 <lispy> dsrogers: my compiler, helisp, uses WriterT in the backend as does my other program Autoproc.  So if you need some examples you could look at them :)
19:51:37 <ddarius> If you didn't mind passing the continuation of callCC to it then you could make a multi-shot callCC using a variant of my single shot callCC.
19:51:40 <dolio> Might take some rewriting.
19:51:49 <ddarius> But I suspect that that would mostly defeat the point.
19:52:12 <dolio> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341#a1344
19:52:33 * mmorrow tries
19:53:50 <dolio> Change the 0s to different things, by the way.
19:54:00 <dolio> That was a dumb decision.
19:54:36 * dolio should install smlnj and play around with it himself.
19:56:17 <ddarius> How about a @sml or @scheme command?
19:56:38 <ddarius> If the @unlambda command worked, you could use its callCC
19:59:30 <roconnor> dolio: you can edit the annotation in place I beleive
19:59:41 <dolio> Oh?
20:00:24 <dolio> No, made a new annotation.
20:00:25 <roconnor> click on modify
20:00:50 <ozy`> so folks
20:00:57 <ozy`> well
20:00:59 <ozy`> never mind
20:01:38 <roconnor> dolio: oh
20:01:39 <roconnor> hmm
20:01:50 <dolio> Modify is the new name for annotate.
20:02:05 * wli discovers the Engel expansion method of generating Egyptian fractions.
20:02:06 <roconnor> I thought it worked for me
20:02:10 <roconnor> maybe I was mistaken
20:05:36 <dolio> Man, the smlnj's tutorials page is woefully out of date.
20:05:49 <dolio> Half their links are broken.
20:05:59 <ddarius> Who needs a tutorial when you have a formal semantics !
20:06:17 <dolio> I'm just looking for the names of the constructors of the sum type.
20:06:34 <ddarius> (Admittedly, only for SML and not for the extensions SML/NJ provides to my knowledge.)
20:08:18 <dsrogers> what's the verb for "<-"?
20:09:06 <dibblego> bind?
20:09:11 <dolio> Does it even have one?
20:09:31 <dolio> I see option...
20:10:54 <mmorrow> dolio: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1341#a1348
20:11:10 <mmorrow> it took me a sec because i'm just learning sml syntax
20:11:24 <mmorrow> also, apparently you can't have a "datatype" with more than a single tyvar
20:11:34 <mmorrow> (i tried to make an either datatype)
20:11:41 <dsrogers> isn't ">>=" bind?
20:11:49 <mmorrow> i just used  (Maybe a, Maybe b)  to simulate either
20:11:56 <dolio> That can't be right, can it?
20:12:17 <mmorrow> i dunno, i haven't gone through it yet
20:12:22 * mmorrow looks
20:12:58 <ddarius> mmorrow and dolio learn the eye-searing truth of SML.
20:14:24 <mmorrow> hehe
20:14:48 <wli> How far can you really get with a formal semantics in tow?
20:14:56 <mmorrow> dolio: it looks right to me, although i'm not positive what you had in mind for it to do
20:15:36 <rwbarton> what value of Either Char Int does (Just 'f', Just 35) correspond to?
20:15:44 <dolio> Yeah, I'm going to have to think about it.
20:16:08 <mmorrow> rwbarton: neither, which is why it's a poor substitute :)
20:16:22 <Olathe> @src Either (>>=)
20:16:22 <lambdabot> Left  l >>= _ = Left l
20:16:22 <lambdabot> Right r >>= k = k r
20:16:37 <mmorrow> i've gotta figure out how to define datatypes with more than a single tyvar
20:16:39 <rwbarton> how would you even apply a tycon to multiple arguments in ml?  The postfix notation feels weird
20:16:43 <Olathe> @src Either mplus
20:16:43 <lambdabot> Left _ `mplus` n = n
20:16:43 <lambdabot> m      `mplus` _ = m
20:16:52 <mmorrow> rwbarton: yeah, super weird
20:17:27 <mmorrow> also, i've gotta add SML to the syntax highlighting options on hpaste2 somehow
20:17:42 * mmorrow grudgingly chose OCaml for the syntax highlighter option
20:25:40 <mmorrow> dolio: (not sure if this is relevant, but in smlnj continuations are 100% first-class)
20:27:07 <mmorrow> (which it gets for free since it doesn't use a stack)
20:45:04 <shapr> Yow!
20:45:58 <dsrogers> is -XGeneralizedNewTypeDeriving 6.10 only?
20:46:14 <shapr> mattam: habitez vous a Boston maintenant?
20:46:19 <mmorrow> smlnj is friggin sweet. at any point, you can save the entire state of your heap (and thus the program, since all code lives in heap closures just like all values) to a file (executable is you want), and resume it later.
20:46:52 <roconnor> mmorrow: can't your OS do that?
20:46:59 <mmorrow> *and* because of this + the fact that code is just another heap object, you get hot-swapping ability _for free_
20:47:18 <mmorrow> so it can do what erlang can do, but it does it with real machine code
20:47:47 <ddarius> Um, then it wouldn't be able to do what Erlang could do.
20:47:49 <Gracenotes> dsrogers: here on Ubuntu (6.8.2), it works
20:47:54 <mmorrow> roconnor: maybe, but it'd be nice if you could call a function in ghci which would nicely package everything up into an executable heap image
20:48:19 <mmorrow> the function that saves the heap + code + everything is really nifty too, because
20:48:39 <mmorrow> when you call it initially, it returns false (and saves everything)
20:48:59 <mmorrow> when you execute that image, it is *as if that function had returned true*
20:49:08 <mmorrow> hehe, how clever
20:49:29 <ddarius> fork()
20:50:19 <mmorrow> exactly, but with that new proc being frozen to an image
20:50:32 <mmorrow> that you can run as many times as you want
20:51:30 <mmorrow> the way it saves the heap is it does a garbage collection, but instead to the "tospace" being the tospace, it's whatever memory buffer/file you want to dump everything to
20:52:12 <mmorrow> and since it has no stack, this suffices to save everything of importance
20:52:42 <ddarius> Having a stack or not doesn't really matter, except that it probably makes the implementation a bit easier.
20:53:03 <ddarius> And roconnor is right, you OS can and does do similar things.
20:53:12 <mmorrow> it does for this, since it causes problems/much added complexity to saving the state
20:53:31 <mmorrow> + not having a stack lets smlnj have 100% first-class continuation for free
20:53:38 <ddarius> mmorrow: How is that not just making the implementation harder?
20:53:47 <mmorrow> that's what i'm talking about
20:53:55 <Cale> mmorrow: I've been thinking that it would be cool to be able to do a similar thing in Haskell for a while. It would be nice to be able to take any IO action and turn it into an executable.
20:54:02 <ddarius> mmorrow: It doesn't mean first-class continuations are free it just means you pay for them in a different way.
20:54:04 <mmorrow> Cale: me too.
20:54:15 * roconnor finds continuations plus IO very strange
20:54:22 <mmorrow> ddarius: free := no added implementation effort or complexity
20:54:51 <dibblego> IO () -> [Word8] ?
20:54:52 <mmorrow> just save the registers in a record in heap closure, and voila callcc
20:54:56 <roconnor> but then again, haskell has corrupted me
20:55:01 <ddarius> mmorrow: It just moves the implementation effort elsewhere (i.e. getting good performance while not using the stack)
20:55:51 <wli> Continuations are actually very natural for IO in operating systems.
20:55:54 <Taejo> You know a module needs refactoring when it declares show instances for (,,,,,,,,,,,,,,,,)
20:56:11 <mmorrow> ddarius: well, it spills registers to memory the same as an implem that uses a stack. it just doesn't use a stack "as such"
20:56:14 <wli> You essentially have to build continuations by hand in order to handle device interrupts.
20:56:48 <pstickne> wli:  how are those continuation? :-/
20:56:51 <mmorrow> wli: totally. smlnj handles asynchronous signals/exception with the first-class-continuation mechanism
20:57:16 <ddarius> OSes are rife with things that can be thought of as continuations.
20:57:17 <pstickne> wli:  ohh... in that way
20:57:18 <mmorrow> the current continuation is passed to the signal handler
20:58:03 <dsrogers> Gracenotes: thanks
20:58:37 <wli> Asynchronous IO from userspace is sadly quite different; userspace largely polls there with the expectation of the IO queue never fully emptying.
20:58:56 <Cale> Taejo: hehe
21:00:00 <wli> Error handling via e.g. signals performs poorly from userspace.
21:00:11 <wli> Or otherwise things like e.g. SIGIO.
21:00:58 <pstickne> wli:  not epoll/kqueue/etc?
21:01:04 <Taejo> Cale: it turns out the library is a direct translation from a DTD :(
21:01:25 <wli> pstickne: epoll/kqueue/aio etc. are how IO is best done from userspace.
21:01:52 <Cale> roconnor: continuations seem sort of natural inside the monadic way of thinking... at least to me.
21:02:36 <Taejo> why is hackage linking to 404 docs: http://hackage.haskell.org/packages/archive/haskore/0.1/doc/html/Haskore.html
21:03:15 <mmorrow> <dibblego> IO () -> [Word8]
21:03:20 <mmorrow> dibblego: exactly
21:03:32 <mmorrow> well, it's more like
21:03:32 <wli> There what you want are M:N threads where one kernel thread per-cpu goes over the IO queue in parallel with all the other kernel threads on the other CPU's, and the continuations associated with the IO queue elements are somewhat doable, save that the user threads the continuations represent need to be preempted somehow (possibly voluntarily, otherwise by an exception generated by the kernel like SIGALRM).
21:03:39 <mmorrow> FilePath -> IO Bool
21:03:52 <mmorrow> but that function could be implemented just the same
21:06:25 <wli> From the point of view of the subset of code needed to handle a single chain of dependent IO actions, you get vaguely kernel-like continuation affairs for IO.
21:06:37 <wli> So I think continuations are rather natural for IO.
21:06:47 <mmorrow> interesting
21:08:02 <Taejo> anyone here familiar with the musicxml package?
21:13:26 <Taejo> "Anybody who contemplates Hackage documents as a tutorial is living in a state of sin." -- John von Haskell
21:29:40 <newsham> wli: http://lambda-the-ultimate.org/node/1435
21:44:56 <Taejo> http://www.lostechies.com/cfs-filesystemfile.ashx/__key/CommunityServer.Blogs.Components.WeblogFiles/derickbailey/LiskovSubtitutionPrinciple_5F00_52BB5162.jpg
21:45:00 <roconnor> @hoogle mapCont
21:45:00 <lambdabot> Control.Monad.Cont mapCont :: (r -> r) -> Cont r a -> Cont r a
21:45:00 <lambdabot> Control.Monad.Cont mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
21:46:27 <sbahra> wli, AIO is disgusting, unfortunately. :(
21:48:03 <sbahra> Semantics for notification (errors and other events) is pretty inconsistent, IMO.
21:48:15 <sbahra> And all rather heavy-weight (especially list I/O).
21:49:18 * sbahra wishes POSIX provided something better
21:49:35 <geezusfreeek> AIO isn't inherently bad at least. we can come up with a decent abstraction for it someday
21:49:37 <mmorrow> this is bullshit http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PALL&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&r=1&f=G&l=50&s1=6205469.PN.&OS=PN/6205469&RS=PN/6205469
21:49:53 <mmorrow> description: http://lambda-the-ultimate.org/node/1365
21:50:07 <sbahra> geezusfreeek, I'm speaking of POSIX AIO here.
21:50:11 <geezusfreeek> ah
21:50:15 <geezusfreeek> yeah it's not very nice
21:50:45 <sbahra> I ended up implementing my own library at the time.
21:51:04 <sbahra> Unfortunately in FreeBSD there is a 1:1 mapping to POSIX AIO, which makes it rather pointless for it.
21:51:42 <mmorrow> in that patent, they say that "thew code for every possible continuation is generated and entered into a table". i'm wondering if instead of generating the code for /every/ cont, generating code that takes as arg /any/ of the (keys associated with the) conts would qualify as being sufficiently different
21:51:49 <sbahra> Linux's io_submit is much nicer.
21:52:05 <harblcat> on a scale of 1 to 10, how easy/hard is it to integrate haskell with other languages?
21:52:20 <mmorrow> harblcat: depends on the other language
21:52:25 <Taejo> harblcat: i
21:52:25 <roconnor> harblcat: is the other language C?
21:52:29 <mmorrow> if it's C, then 1
21:53:07 <mmorrow> if that other lang to C is also 1, then it's probably around a 2?
21:53:10 <Taejo> mmorrow: where 1 is easiest?
21:53:14 <mmorrow> yes
21:53:51 <roconnor> see also the BASIC monad
21:54:03 <roconnor> if the other language is BASIC
21:54:08 <mmorrow> i'm not sure that counts ;)
21:54:25 <Axman6> harblcat: so, is the other language C or not?
21:54:41 <harblcat> C++?
21:54:44 <mmorrow> ooh
21:54:55 <mmorrow> much harder
21:55:01 <roconnor> Draconx|Laptop sounds like he is from Waterloo
21:55:01 <Axman6> c++--
21:55:16 <mmorrow> if you can give the C++ a C interface, then that'll be easier
21:55:44 <harblcat> Well, that's kinda a roundabout thing, actually, it's a c++ interface to c code :P
21:55:53 <harblcat> So I guess it's a 1, then
21:55:59 <mmorrow> yay! :)
22:12:26 <dsrogers> what does "the Coverage Condition fails for one of the functional dependencies?" mean?
22:13:24 <dsrogers> it's telling me to use undecidable instances, but I want to understand what this means.
22:17:32 <FrozenOne> Is it me, or is haddock buggy?
22:18:35 <mornfall> dsrogers: As far as I can tell, there's this somewhat technical condition on the form of the dependencies that allows proving decidability. If that is violated, no-one can guarantee you that the result will be decidable, although it usually is.
22:19:06 <dsrogers> ah.
22:22:09 <dmwit> ?seen conal
22:22:10 <lambdabot> I saw conal leaving #haskell and #ghc 1d 5h 8m ago, and .
22:22:23 <Mauke> preflex: seen conal
22:22:24 <preflex>  conal was last seen on #haskell 3 days, 3 hours, 34 minutes and 3 seconds ago, saying: Cale: oops -- dinner time.  i gotta go.  will look for you tomorrow.  thx for the help so far.
22:27:24 <jekor> Can I generalize a function in the IO monad to work in MonadIO if it calls a function that expects IO? I'd like to turn IO a -> a -> IO a into MonadIO m => m a -> a -> m a, but it uses catchSql which is IO a -> (SqlError -> IO a) -> IO a.
22:27:36 <jekor> I get "Couldn't match expected type `IO' against inferred type `m'".
22:28:01 <mmorrow> this is a known problem with callback functions and MonadIO
22:28:35 <jekor> Shucks. So I'd have to write an alternative version of catchSql?
22:28:39 <mmorrow> there's no (in general) way to go from a  (MonadIO m) => m a   to an  IO a
22:29:19 <mmorrow> jekor: either that, or pass it what it expects somehow
22:30:00 <jekor> Does that mean there's some specific way to pass it IO a? Some way to convert the monad?
22:30:31 <mmorrow> i'd try to keep as much IO as possible, since you can always liftIO when needed, but not vice-versa
22:31:52 <jekor> Thanks.
22:31:59 <mmorrow> no problem
22:35:23 <roconnor> ah, FasterT is already implmented
22:35:31 <roconnor> it is called Control.Monad.Codensity
22:35:43 <rwbarton> yes, it's mysterious and awesome
22:36:17 <Gracenotes> hm... it's probably safe to have two threads using the same initial ReaderT value, I should think..?
22:36:30 <roconnor> not sure what codensity has to do with backtracking though
22:36:35 <Gracenotes> albeit with two runReaderTs
22:38:00 <dmwit> ooo, hpastetwo
22:39:50 <dmwit> So, anybody who has fieldtrip-reactive installed want to try something for me?
22:39:52 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1376#a1376
22:40:01 <dmwit> Run that and let me know if it actually shows anything?
22:40:33 <dmwit> (I think it should show a cube; but it seems to show a blank screen here. =/)
23:13:20 <cognominal> is there a tutorial on monads like errorT, stateT and the like?
23:14:36 <Deewiant> cognominal: http://www.haskell.org/all_about_monads/html/
23:18:52 <cognominal> Debolaz,  I am speaking of the *T monads. In what are they speical
23:18:57 <cognominal> *special
23:19:42 <cognominal> or are they just a new names for monads described in the page pointed by your url?
23:20:03 <dolio> They are not monads in themselves. They are ways of building monads from other monads.
23:20:35 <Alpounet> what actually are *T monads ? I've never seen them.
23:20:45 <dolio> So "StateT s []" has both state and list-like (nondeterministic) behaviors.
23:21:18 <cognominal> yea, I am reading the doc of Control.Monad.error, I think it will make sense
23:21:50 <dolio> And the side effects interact in different ways depending on the nesting.
23:22:08 <cognominal> probaby need to read RWH about monads composition
23:22:44 <magthe> anyone around who can answer a probably very simple question about de Bruin notation?
23:22:59 <dolio> Probably.
23:23:23 <Cale> Alpounet: They're talking about monad transformers, like StateT, ReaderT and WriterT.
23:23:49 <magthe> dolio: what would the equivalent be for \xy.x in de Bruin notation?
23:24:04 <dolio> \\2 I believe.
23:24:32 <dolio> Assuming \xy.yx = \\12
23:25:05 <magthe> dolio: yes, that's what my text says too, but I can't square that with the explanation of the notation
23:25:31 <Alpounet> Cale, okay thanks.
23:25:47 <dolio> Numbering usually starts at the closest enclosing lambda.
23:26:04 <dsrogers> in a functional dep, m->a reads "m is determined by a" correct?
23:26:14 <Cale> magthe: The idea is that the natural number n represents the variable bound by the lambda which is n layers outward.
23:26:40 <magthe> ah so you do "count backwards"... that was the missing piece in the explanation
23:27:09 <dolio> That way you can add lambdas around an expression without incrementing all the numbers.
23:27:33 <magthe> yes, it makes sense, from that point
23:27:45 <magthe> dolio, Cale, thanks for the explanation
23:27:45 <Alpounet> can we say that monad transformers are kinda like functors from monads to other monads ?
23:28:55 <magthe> Alpounet: would that mean that for non-mathematicians they actually are like fuzzy things from warm fuzzy things to other warm fuzzy things?
23:29:36 <Cale> Alpounet: hmm... I suppose they're natural transformations between monads.
23:29:58 <Alpounet> magthe, heh
23:29:58 <Cale> :t lift
23:29:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
23:30:06 <ski_> dsrogers : no "`m' determines `a'"
23:30:13 <dsrogers> thanks.
23:30:17 <Cale> lift is a natural transformation  m -> t m
23:30:34 <Alpounet> Cale, oh I see, ok, thanks.
23:32:23 <Cale> I wonder though...
23:32:57 <daf> Cale: heh, I misread that as "life is..."
23:33:56 <Cale> We do have a category of monads on Hask, and monad morphisms between them, though we don't often mention it explicitly. It could be that monad transformers are also functors on this category.
23:35:01 <Alpounet> Cale, I was thinking so, but quite not sure
23:35:29 <rwbarton> The MonadTrans class doesn't require t to be functorial
23:35:48 <rwbarton> I think we had an example of a non-functorial MonadTrans the other day here
23:36:19 <rwbarton> @hoogle mapContT
23:36:20 <lambdabot> Control.Monad.Cont mapContT :: (m r -> m r) -> ContT r m a -> ContT r m a
23:36:44 <Cale> mm... yeah, given a monad map m a -> n a, we ought to have a corresponding t m a -> t n a, if that were the case, but no such thing is guaranteed.
23:37:04 <rwbarton> , src ''ContT
23:37:21 <lunabot>  newtype ContT i m a = C ((a -> m i) -> m i)
23:38:41 <Alpounet> I had printed a paper about category theory and monads... I'll probably see some answer about that in it.
23:40:57 <Alpounet> So monad tranformers are mainly considered as natural transformations between monads ?
23:41:33 <rwbarton> I'm pretty sure there's no map :: forall i. (Monad m, Monad n) => (forall b. m b -> n b) -> (forall a. ((a -> m i) -> m i) -> ((a -> n i) -> n i)).
23:42:21 <hackage> Uploaded to hackage: OGL 0.0.1
23:43:32 <rwbarton> Alpounet: "category theory and monads" is a large subject :)
23:44:05 <Alpounet> I've understood it, when searching for a good paper about it heh
23:44:21 <rwbarton> I don't think there is a really good theoretical notion of monad transformer
23:44:35 <rwbarton> (that we know of anyways)
23:47:32 <redditbot> The Curry-Howard Correspondence in Haskell
23:47:32 <redditbot> Dependencies in Hackage, revisited
23:50:15 <Heffalump> rwbarton: what more is needed than "monad law preserving"?
23:52:29 <rwbarton> I guess you could just require a monad transformer to be an endofunctor on the category of monads and monad isomorphisms
23:53:28 <rwbarton> (with a natural transformation 1 -> t according the MonadTrans definition)
23:54:57 <nj32> how can i convert String -> Word64?
