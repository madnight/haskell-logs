00:05:13 <imyourmonad> is there any easy way to play an mp3 or any music in Haskell?
00:05:20 <imyourmonad> I want to try ou threads
00:07:45 <dmwit> runProcess "mplayer wacky.mp3"
00:07:46 <dmwit> ;-)
00:07:54 <pumpkin_> lol
00:08:12 <imyourmonad> i tried didnt work. monomorphsm restriction
00:08:22 <pumpkin_> o.O
00:08:32 <pumpkin_> @hoogle runProcess
00:08:32 <lambdabot> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
00:08:46 <pumpkin_> how does monomorphism come into play there?
00:08:50 <dmwit> Sounds like a troll to me.
00:08:52 <imyourmonad> just kidding
00:09:06 <pumpkin_> imyourmonad: you've been throwing around haskell buzzwords for a while now:)
00:09:12 <pumpkin_> do you actually have an interest in it
00:09:17 <imyourmonad> sounds like a joke. i hope thise are allowed
00:09:35 <pumpkin_> certainly, but the underlying intent is also relevant :)
00:09:36 <imyourmonad> pumpkin: very much so i already have written a lot of programs in ut
00:10:09 <bos> whee! http://www.reddit.com/r/programming/comments/80pel/finally_fast_unicode_support_for_haskell_using/
00:10:20 <imyourmonad> spamfilter, rsa, parody-maker/markov-chain, euler-projects, etc
00:10:23 <pumpkin_> bos ftw!
00:10:34 <mmorrow> IM IN YOUR MONAD BINDIN YORE VARS TILL ALL THEM VARS AN 10
00:10:38 <mmorrow> KTHX
00:11:02 <imyourmonad> im outta your monad
00:11:09 <pumpkin_> bos: who is the Data.Text team? :o
00:11:21 <pumpkin_> oh, I see :) on the hackage page
00:11:22 <bos> pumpkin_: mostly me :-)
00:11:49 <pumpkin_> so I can write fast code that processes human language too now!
00:11:50 <pumpkin_> yay
00:11:51 <bos> i've probably written about 75% of the code at this point.
00:12:42 * wli completely fails to figure out how to manipulate equations as objects in like fashion to his old Grobner code.
00:12:43 <pumpkin_> mm UnsafeChar
00:13:37 <mmorrow> bos: cool
00:14:00 <mmorrow> bos: is there a repo (in whatever shape/form) for the IOManager hacking?
00:14:35 <pumpkin_> bos: it uses Utf-16 internally?
00:14:58 <pumpkin_> looks like it
00:17:24 <pumpkin_> looks nice :)
00:18:53 <pumpkin_> you could do like dolio's recent patch to uvector and provide an FFI binding to memcpy for uberfast copying
00:19:58 <imyourmonad> and how do I use processes?
00:20:15 <pumpkin_> how do you mean?
00:20:26 <imyourmonad> forkIO is for threads, i get hwo to use it now
00:20:32 <imyourmonad> how do I create a new process?
00:21:00 <pumpkin_> @hoogle fork
00:21:00 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
00:21:00 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
00:21:12 <pumpkin_> you run it?
00:21:23 <pumpkin_> you want fork() itself?
00:22:49 <imyourmonad> i dont know, do I?
00:23:03 <imyourmonad> but why does forkOS has a threadID and not a processID?
00:23:16 <aleator> How do I get forkIO/OS to use multiple cores?
00:23:36 <pumpkin_> +RTS -Nx
00:23:46 <pumpkin_> will give the runtime more OS threads
00:24:05 <pumpkin_> which assuming your OS is doing its job, will map to more cores/CPUs
00:24:49 <aleator> Hmm.. -N8 seems to load only two out of eight cores to 40% which is really odd.
00:25:11 <mmorrow> imyourmonad: System.Posix.Process has a forkProcess
00:25:14 <pumpkin_> well, it obviously depends on your code too :)
00:25:43 <pumpkin_> "the mythical thread-second" or something
00:25:57 <mmorrow> imyourmonad: but ghc's rts doesn't support forkProcess if you're using -threaded, so the IOManager will die in the new proc :(
00:26:08 <mmorrow> so you can't use Handle or Socket IO
00:26:12 <pumpkin_> aw, call rtsFuneral
00:26:32 <aleator> pumpkin_: Yeah. Thats what strange about it. It is non-communicating number crunching with bit of IO.. That shouldn't be hindering it?
00:26:50 <mmorrow> rtsFuneral :: IO ()
00:27:43 <mmorrow> aleator: how many threads are you forkIO'ing?
00:28:10 <aleator> I've tried from 8 to 12.
00:28:39 <mmorrow> aleator: also there's a GHC.Conc.forkOnIO :: Int -> IO () -> IO ThreadId
00:28:51 <mmorrow> where the Int is which processor to run it on
00:28:56 <mmorrow> maybe that'll help
00:29:04 <aleator> Hmm. Interesting!
00:29:17 <mmorrow> aleator: i'd be interested to hear if that works :)
00:30:19 <aleator> mmorrow: Well. It seems that it is not yet on 6.8.2 which I'm still using.. ::(
00:30:26 <mmorrow> ah, too bad
00:31:43 <mmorrow> aleator: hmm, i just checked my 6.8.2 and i seem to have it
00:31:53 <mmorrow> import GHC.Conc  -- ?
00:32:10 <mmorrow> you might have to use -package ghc
00:32:20 <mmorrow> (but --make sure work i think)
00:32:25 <Saizan> aleator: are you sure the computation doesn't end up in only a few threads because of laziness?
00:34:29 <aleator> Saizan: Nope. http://haskell.pastebin.com/m778fd062
00:35:28 <imyourmonad> Could not find module `System.Posix.Process': , its a hackage package?
00:37:44 <jsn> imyourmonad: maybe try ghc --make ?
00:38:05 <pumpkin_> it's not at the linker stage yet is it?
00:38:15 <aleator> mmorrow: GHC.Conc is there but forkOnIO is not..
00:38:23 <jsn> oh, that's right
00:39:17 <jsn> imyourmonad: it does seem to be in the standard libs, though
00:40:31 <imyourmonad> jsn: what do you mean? could it work when compiling? so it is ghci fault?
00:40:47 <imyourmonad> ghc --make -O2 -main-is Threads.main Threads.hs
00:40:47 <imyourmonad> Threads.hs:3:17:
00:40:47 <imyourmonad>     Could not find module `System.Posix.Process':
00:41:14 <jsn> hmm
00:42:19 <jsn> honestly, i have no idea
00:42:34 <Saizan> imyourmonad: which platform are you on? windows? debian?
00:42:40 <imyourmonad> windows
00:43:01 <Saizan> ok, then you don't have System.Process since that's unix only
00:43:22 <Saizan> ops
00:43:26 <imyourmonad> whya rent imports qualified by default?
00:43:29 <Saizan> System.Posix.Process i mean
00:43:30 <imyourmonad> ok
00:44:37 <Saizan> you do have System.Process, which doesn't have a simple fork, you can invoke other executables with it though
00:45:36 <imyourmonad> ok
00:45:53 <imyourmonad> but seriously, isnt there an easy way to play music from a hskell-program?
00:46:19 <lament> i used hmidi
00:46:28 <lament> with great results
00:46:37 <jsn> hehe
00:47:02 <dmwit> I believe there are several audio libraries on hackage.
00:47:17 <jsn> i'm like, wow, i have no idea how you could not have System.Posix.Process
00:47:24 <lament> a demo of my app using hmidi: http://www.youtube.com/watch?v=BtGlQHAEwVo
00:48:11 <dmwit> Holy crap.
00:48:15 <imyourmonad> lament: age?
00:48:18 <dmwit> How long did it take you to learn that?
00:48:33 <dmwit> That must have taken... hours of practice, even after you wrote the program!
00:48:44 <lament> a few hours yeah
00:49:00 <dmwit> awesome =)
00:49:46 <lament> ty :)
00:50:35 <Axman6> imyourmonad: i don't know if this is the reason, but i feel that qualified imports make code ugly and verbose. it doesn't take all that long using haskell to frigure out where functions come from, and having to write a `Control.Concurrent.par` b instead of a `par` b is a huge advantage
00:51:48 <aleator> Eh. Shouldn't +RTS -N8 have the same effect if it is compiler switch or argument to the executable produced?
00:55:54 <wli> import qualified Control.Concurrent as Conc
00:56:07 <Saizan> aleator: if you use that when compiling you're saying ghc to run with 8 OS threads
00:56:27 <Axman6> wli: still a `Conc.par` b is ugly too
00:56:28 <Saizan> aleator: that doesn't affect the binary produced, hopefully :)
00:59:23 <Axman6> @users
00:59:23 <lambdabot> Maximum users seen in #haskell: 658, currently: 588 (89.4%), active: 13 (2.2%)
00:59:41 <visof> hello
01:00:03 <wli> I do import qualified Data.Map as Map and import qualified Data.Set as Set all the time.
01:00:20 <visof> how can i write prime factorization in haskell ?
01:00:27 <Axman6> well, that makes sense though
01:00:37 <wli> visof: one moment please
01:00:43 <visof> ok
01:03:50 <pastah> @src guard
01:03:50 <lambdabot> guard True  =  return ()
01:03:50 <lambdabot> guard False =  mzero
01:04:00 <pastah> thought so...
01:04:44 <Axman6> :t quard
01:04:45 <lambdabot> Not in scope: `quard'
01:04:47 <imyourmonad> how much diskspace does a modern computer game take?
01:04:50 <Axman6> :t guard
01:04:51 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:05:04 <Axman6> imyourmonad: > 1GB?
01:05:07 <pstickne> imyourmonad:  depends
01:05:20 <Axman6> X-plane takes 60GB for the full install...
01:05:25 <pstickne> imyourmonad:  'modern computer game' is a very open-ended subject
01:05:33 <imyourmonad> Axman6: import qualified Control.Concurrent as C;  a <- C.forkIO (readf); is what i do
01:05:45 <Axman6> i still find that ugly
01:06:03 <Axman6> what advantages does that give you?
01:06:11 <imyourmonad> i dont and i prefer seeing directly where stuff comes from, not everything is as obvious as forkIO
01:06:33 <blackh> Axman6: Gidday! I think qualified import is the best solution to namespace clutter too.
01:06:36 <wli> visof: trial division:
01:06:41 <wli> > let factors' ~(p:ps) n | n == 1 = [] | otherwise = let (q, r) = n `divMod` p in if r == 0 then p : factors' (p : ps) q else factors' ps n ; primes = 2 : 3 : [p | p <- [5, 7 ..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q * q <= p) primes)] :: [Integer] ; factors = map (\fs -> (head fs, length fs)) . group . factors' primes in factors $ 2*3*5*7*11*13*17+1
01:06:42 <lambdabot>   [(19,1),(97,1),(277,1)]
01:06:55 <dmwit> import qualified Control.Concurrent as C; import Control.Concurrent (forkIO) -- for the obvious ones
01:07:34 <blackh> Better to have standard names like 'empty' for each container type rather than emptySet, emptyThis, emptyThat
01:08:10 <dmwit> totally
01:09:32 <wli> visof: Probably better to use a Map of prime factors and insertWith (+) p 1
01:09:46 <Axman6> i still dislike having to use X.Y.f all over the place, but that's just me
01:10:24 * dmwit doesn't see how Set.empty is worse than emptySet, and sees several ways it's better
01:10:46 <blackh> I think most of the time you don't have to ... it's only in rare circumstances where you're using a Map and a Set in the same module.
01:11:14 <wli> visof: Not to mention a faster prime generator...
01:11:30 <Axman6> yeah, exactly. it makes sense to use them in certain circumstances, and Map and Set are great examples of it
01:11:35 <wli> quick Map -based affair:
01:11:38 <wli> > let factors' ~(p:ps) n | n == 1 = empty | otherwise = let (q, r) = n `divMod` p in if r == 0 then insertWith (+) p 1 $ factors' (p : ps) q else if p * p >= n then singleton n 1 else factors' ps n ; primes = 2 : 3 : [p | p <- [5, 7 ..], all (\q -> p `mod` q /= 0) (takeWhile (\q -> q * q <= p) primes)] :: [Integer] ; factors = toList . factors' primes in factors $ 2*3*5*7*11*13*17*19*23+1
01:11:39 <lambdabot>       Ambiguous occurrence `empty'
01:11:39 <lambdabot>      It could refer to either `Text.Pretty...
01:11:44 <Axman6> heh
01:12:41 <blackh> How topical!
01:12:50 <Axman6> my thoughts exactly :)
01:13:41 <Axman6> blackh: so i'm back at uni now, and i got some rather nice news for one of my comp courses. our third assignment will be using the uni's new UltraSPARC T2, which is an awesome machine of awesomeness
01:14:09 <blackh> One trouble with this namespace clutter in Haskell is that if a new symbol is added to a library, it can potentially break the compile of any program that uses it.
01:15:04 <blackh> This must be the Terminator 2 of computers.
01:15:38 <Axman6> 8 cores, 8 threads per core, think 16 or 32GB RAM (can't remember which). it's the one the GHC/SPARC work's being done on
01:16:15 <blackh> I just had a look on the net. I want one!
01:16:46 <pumpkin_> I want superduper parallel programs
01:16:49 <blackh> You could make a few Haskell converts with that, I suspect.
01:16:55 <pumpkin_> so I can actually use all that epicness
01:17:06 <pumpkin_> I must sound really eloquent
01:17:26 <civ> hello, i'm trying to 'cabal install haskell-sqlite3' with ghc 6.10,1, but i have problem with directory package
01:17:39 <civ> is there a way to get this to work under ghc 6.10?
01:17:44 <Axman6> blackh: check out the latest post on http://ghcsparc.blogspot.com/ for some ideas of the speed
01:19:26 <pumpkin_> I love reddit comments sometimes: "Yo Dawg! I heard you don't like complete sentences so I accidentally the verb."
01:19:42 <civ> i mean hdbc-sqlite3, of course
01:21:48 <blackh> civ: I have not tried, as I am a disliker of SQL.
01:22:27 <wli> visof: next up is a more efficient list of primes
01:22:46 <wli> visof: primes = catMaybes . snd $ mapAccumL (\m n -> case minViewWithKey m of { Just ((k, ps), m') | k == n -> (unionWith (++) m' $ fromList [(k + p, [p]) | p <- ps], Nothing); _ -> (insertWith (++) n [n*n] m, Just n) }) empty [2 ..] :: [Integer]
01:23:03 <blackh> civ: Have you considered the marvellous benefits of Berkeley DB or DBXML?
01:23:20 <wli> visof: Better to stay on the channel.
01:24:08 <wli> blackh: I wish I could figure out how to use databases.
01:25:43 <civ> blackh, i haven't, but my problem is to get hdbc working in the first place
01:26:06 <imyourmonad> ok I have a problem with installing packages because cabal wants to isntall where it isnt allowed. can I do it manually?
01:26:07 <blackh> wli: What task do you want to use a database for?
01:26:36 <blackh> civ: BerkeleyDB doesn't use hdbc.
01:26:44 <civ> blackh, just for some simple storing
01:27:10 <civ> eg, few plaintext columns for a table
01:27:11 <blackh> civ: BerkeleyDB might be suitable, then. It's really simple - it works like a map of bytestring to bytestring
01:27:16 <wli> blackh: I don't really know when to use them.
01:27:30 <blackh> ^ should be wli:
01:28:05 <wli> blackh: Or, for that matter, how.
01:28:13 <blackh> wli: Use a database whenever using flat files isn't good enough.
01:28:47 <wli> blackh: I usually want them for multidimensional spatial queries, but those are rare for opensource databases to support.
01:29:18 <wli> blackh: Apart from that I rarely know when to use them.
01:29:29 <blackh> wli: Berkeley DB is essentially a dictionary, with some extra capabilities. A lot of simpler problems can be modelled on top of a nice simple dictionary.
01:30:28 <wli> I usually just end up using Data.Map when it comes to that.
01:31:08 <blackh> wli: Berkeley DB is just like Data.Map only persistent, but you have to serialize/deserialize your data.
01:31:16 <wli> Multiply-indexed data sets might be plausible, depending on whether retrieval on multiple keys is supported.
01:32:37 <wli> It would take care of the coherence problem without quite so much boilerplate, save for the marshalling.
01:32:56 <civ> blackh, bdb might be sufficient in my case then, thanks
01:33:01 <civ> must go now
01:33:47 <quicksilver> wli: postgres has spatial indices. I've never used them so I can't speak for how easy to use they are or how well they work.
01:33:56 <blackh> wli: BDB has a single key, but you can concatenate keys together.  BDB is also transactional, so you can think of it doing the same job as STM, only persistently.  ...at the cost of doing marshalling, of course.
01:36:28 <imyourmonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1811#a1811 <- why doesnt that actually rpint the string in the thread?
01:36:39 <imyourmonad> it does in ghci but not when compiled and run
01:37:27 <blackh> Is it because main exits before it gets a chance?
01:37:55 <wli> blackh: I could probably come up with a use but will likely trip over the marshalling.
01:38:27 <blackh> wli: Perhaps you can get away with read/show, depending on what you're doing.
01:39:01 <wli> If I can get away with Read/Show I'm probably set.
01:39:55 <blackh> wli: I maintain the BerkeleyDB package so I'm the person to bug if you can't get it working
01:40:11 <pumpkin_> I like bdb
01:40:17 <pumpkin_> never used it in haskell though
01:42:22 <Axman6> imyourmonad: you know what forkIO does right?
01:43:57 <quicksilver> imyourmonad: because the main thread terminates too fast
01:44:00 <quicksilver> (I would guess)
01:44:06 <quicksilver> once the main thread dies, the program dies.
01:44:18 <quicksilver> in ghci the main thread never dies, because the main thread is ghci.
01:44:55 <wli> Sorry, crying for home again.
01:47:26 <pumpkin_> :(
01:47:50 <wli> We could try Pollard's rho.
01:48:42 <Saizan> "ghci never dies" might be a title for an action movie with robots
01:49:15 <visof> can i make a code that put the output of shell command inside a list that work on
01:49:16 <visof> ?
01:49:36 <imyourmonad> if my mergesort gives stackoverflow, is that because of laziness?
01:49:56 <imyourmonad> ok I have a problem with installing packages because cabal wants to isntall where it isnt allowed. can I do it manually?
01:49:56 <visof> something like "ls Current_directory" , and put the result inside list
01:50:24 <visof> each file name as one element in the list
01:50:30 <Saizan> visof: see System.Process.readProcess
01:50:42 <imyourmonad> Axman6: so how do I make sure the program doesnt finish until the side-thread is finished?
01:50:54 <Axman6> use an MVar
01:50:59 <Axman6> or don't fork the process
01:51:10 <Saizan> imyourmonad: cabal install --user , or cabal install --prefix=
01:51:59 <imyourmonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1813#a1813 <- can I add strictness so it doesnt overflow(mergesort)?
01:52:06 <Axman6> main = do { v <- newEmptyMVar; C.forkIO (readf >>= putMVar m); takeMVar}
01:53:25 <Axman6> imyourmonad: i like your divide function
01:53:26 <Saizan> imyourmonad: i think the problem is that your divide is too strict
01:53:54 <Saizan> try with "(f *** g) ~(a,b) = (f a,f b)"
01:54:03 <quicksilver> imyourmonad: it would be nice if you would stick to a single IRC nick, by the way.
01:54:04 <Saizan> where ~ makes the pattern matching lazier
01:54:35 <quicksilver> imyourmonad: IRC is a community; it's easier to become part of the community if people have recognisable names.
01:54:36 <Axman6> imyourmonad: you might consider writing two functions, evens and odds, which drop every second element, and then having divide xs = (odds xs, evens xs)
01:56:21 <Axman6> quicksilver: who else is he?
01:56:53 <imyourmonad> the divide function was suggested to me by someone, dont remember who, i had my own (not splitAt) but this one is better
01:56:56 <imyourmonad> im niet
01:57:02 <quicksilver> Axman6: yesterday he was niet; in the past he's been 'hask' I think.
01:57:05 <imyourmonad> you paranoid little monad
01:57:06 <quicksilver> I don't remember all the nmes :)
01:57:39 <Axman6> yeah imyourmonad, pick a nick and stick to it, ok?
01:57:40 <Saizan> imyourmonad: yeah, they suggested you to use (***) from Control.Arrow though, probably
01:57:50 <Saizan> ?src (***)
01:57:50 <lambdabot> f *** g = first f >>> second g
01:58:03 <wks> > partition snd zip([0,1,2,3,4,5,6,7],cycle [True,False])
01:58:04 <lambdabot>   Couldn't match expected type `[(a, Bool)]'
01:59:30 <Saizan> > let (f *** g) (a,b) = (f a,g b); divide [] =([],[]); divide [x] = ([x],[]); divide (x:y:xs) = (x:) *** (y:) $ divide xs in divide [1..]
01:59:33 <lambdabot>   * Exception: stack overflow
01:59:39 <Saizan> > let (f *** g) ~(a,b) = (f a,g b); divide [] =([],[]); divide [x] = ([x],[]); divide (x:y:xs) = (x:) *** (y:) $ divide xs in divide [1..]
01:59:40 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
01:59:45 <Saizan> :)
02:00:36 <yaxu> > 3 / 0
02:00:37 <lambdabot>   Infinity
02:00:45 <yaxu> > (3 / 0) > 10
02:00:46 <lambdabot>   True
02:00:49 <Saizan> though, a bottom-up mergesort probably makes more sense
02:00:52 <visof> r <- createProcess (proc "ls" [])  is fine but i want the output in list
02:01:07 <yaxu> so it's ok to divide by zero in haskell?
02:01:09 <visof> named list that i need after that
02:01:53 <Saizan> visof: readProcess gives you the result as a String
02:02:39 <doserj> > 1 `div` 0
02:02:40 <imyourmonad> can mergesort be run on several cores?
02:02:40 <lambdabot>   * Exception: divide by zero
02:02:42 <quicksilver> yaxu: depends on the type.
02:03:10 <yaxu> quicksilver: so floating point divide by zero is ok?
02:03:58 <quicksilver> yaxu: "Double" in GHC follows IEEE rules
02:04:24 <quicksilver> although you can't change the IEEE exception mode or whatever that's called.
02:04:34 <quicksilver> but 1/0 = Inf is a correct IEEE answer
02:05:00 <wks> > let pairMap f (a,b) = (f a, f b) in pairMap (map fst) $ partition snd $ zip [0,1,2,3,4,5,6,7] (cycle [True,False])
02:05:01 <lambdabot>   ([0,2,4,6],[1,3,5,7])
02:05:11 <yaxu> ok handy, thanks quicksilver
02:05:40 <imyourmonad> can mergesort be run on several cores?
02:05:42 <visof> Saizan i have an application that work from the shell but don't work by readProcess
02:06:01 <visof> i get Prelude System.Process> readProcess "factor 20" [] []
02:06:01 <visof> *** Exception: readProcess: factor 20  (exit 127): failed
02:07:02 <Saizan> visof: the first argument is supposed to be the path of an executable
02:08:06 <Saizan> visof: so, like: readProcess "factor" ["20"] ""
02:08:30 <visof> fine
02:08:53 <visof> i get this "20: 2 2 5\n"
02:09:13 <visof> can i convert this string to get [2,2,5]
02:09:21 <quicksilver> Yes, you can.
02:09:28 <imyourmonad> so to use MVar, do I use it with forkIO? do I add the io-action to the MVar then forkIO the MVar?
02:09:39 <quicksilver> First learn to program haskell. Then apply that knowledge to parse that string :P
02:09:45 <visof> ok
02:09:55 <Alpounet> @faq Can Haskell convert "20: 2 2 5\n" to get [2,2,5] ?
02:09:55 <lambdabot> The answer is: Yes! Haskell can do that.
02:10:33 <Saizan> > read "2" :: Int
02:10:34 <lambdabot>   2
02:10:46 <Saizan> > words "foo bar baz"
02:10:47 <lambdabot>   ["foo","bar","baz"]
02:10:49 <quicksilver> > (map read . words . tail . dropWhile (/= ':') $ "20 : 2 2 5") :: [Int]
02:10:50 <lambdabot>   [2,2,5]
02:11:44 <doserj> > map read . tail . words $ "20: 2 2 5\n" :: [Int]
02:11:45 <lambdabot>   [2,2,5]
02:11:45 <fasta> quicksilver: I get Illegal token: , a lot from this indent mode. Do you have the same issue?
02:12:17 <quicksilver> fasta: only if I've made a mistake.
02:12:32 <quicksilver> Illegal token either means your haskell is invalid, or you've done something kuribas' parser doesn't understand :)
02:12:49 <blackh> imyourmonad: No - you create the mvar before forkIO, then use it in the parent and child processes.
02:12:53 <quicksilver> there were intiially some bugs in his parser but he has fixed all the ones that applied to the code I normally write.
02:13:09 <quicksilver> maybe you're using an extension or syntax that tickeles a bug though.
02:14:17 <blackh> imyourmonad: In your child thread, put something into the mvar. In your parent thread, take it out -the parent thread will block until that something is available.
02:14:27 <fasta> quicksilver: create module Foo(a,<newline>b, <newline c) and press enter after the middle comma.
02:14:51 <fasta> quicksilver: if you stick to whatever the mode wants, then it doesn't appear to happen, though.
02:15:03 <quicksilver> fasta: that just worked fine for me
02:15:32 <fasta> Ok, I will make a new module to see whether that makes a difference.
02:15:46 <quicksilver> I seem to be able to press enter before and after all those commas and it indents fine
02:17:19 <fasta> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1815#a1815
02:18:22 <quicksilver> fasta: yes, the fault is that "a" begins a line
02:18:30 <quicksilver> it treats line-beginnings specially
02:18:41 <quicksilver> and slightly incorrectly, technically, I believe.
02:18:54 <quicksilver> it assumes that anythign at line beginning must start a new thing, because of layout
02:19:04 <quicksilver> but actually that's not quite strictly true, as you have just demonstrated.
02:19:28 <fasta> quicksilver: is it the idea that it works like ParEditMode where one always has a valid structure?
02:19:29 <quicksilver> you'll note that hpastetwo's syntax highlighter has the same issue.
02:19:40 <quicksilver> fasta: yes, although a bit more weakly that paredit
02:19:49 <fasta> quicksilver: yes, and even paredit has issues.
02:19:51 <quicksilver> only an initial segment of the file has a valid structure
02:20:16 <quicksilver> paredit is a great thing though ;)
02:20:25 <quicksilver> I use it in haskell-mode for lists-of-tuples sometimes.
02:21:03 <fasta> Yes, there was a time where I programmed Haskell by using lots of parentheses, so I was almost programming Liskell.
02:21:13 <fasta> (and paredit, of course)
02:21:55 <bpalmer> randomly, is there a standard function for let f g (x, y) = g x y ?
02:21:57 <fasta> If people learning Lisp on universities would be told about Paredit, it would be much more popular.
02:22:15 <Saizan> bpalmer: uncurry
02:22:17 <doserj> @src curry
02:22:17 <lambdabot> curry f x y = f (x, y)
02:22:24 <doserj> @src uncurry
02:22:25 <lambdabot> uncurry f p = f (fst p) (snd p)
02:22:35 <bpalmer> ah, of course.
02:22:40 <bpalmer> thanks.
02:23:08 <quicksilver> fasta: I have thought from time to time it would be nice to combine paredit with a fancy highlighter which "shades" fonts in gentle colours to indicate depth of nesting.
02:27:16 <Philippa_> I'd rather shade the background for that one, but yeah, I'd like that in text editors generally
02:28:05 <Axman6> Xcode's way of doing that is sort of interesting. could be nicer though
02:28:43 <quicksilver> Philippa_: background would work too.
02:29:01 <quicksilver> Philippa_: there's actually two choices as well - one is to do some particular shading around the current cursor location
02:29:12 <quicksilver> and the second is just depth-of-expression based, ignoring cursor choice
02:29:23 <Philippa_> eh, pick two dimensions in colour space to offset along :-)
02:29:24 <quicksilver> Axman6: last I sused xcode it didn't : what does it do now?
02:29:44 <quicksilver> Philippa_: yes. Something neutral for the file in general and something a bit more colourful for current insertion point.
02:30:44 <Philippa_> yeah. I've got a darkish blue background, I'm thinking darken further for depth and nudge a little towards purple for current
02:31:05 <Philippa_> (only a little, or it does bad things with the many highlighting colours, but you get the idea)
02:31:28 <Axman6> quicksilver: i'd show you... but apple.com isn't loading for me -_-
02:31:45 <quicksilver> I have thought for a long time such a thing would be a nice help for teaching/understanding layout mode.
02:32:13 <quicksilver> the reason I haven't just done it is it requires your editor to have a decent haskell parser.
02:32:18 <quicksilver> and until recently, mine didn't.
02:32:18 <Philippa_> heh. Best for that'd still be inserting 'phantom' braces IMO
02:32:57 <Philippa_> italicised and/or in a fainter version of the colour used for braces
02:33:46 <Philippa_> what is your editor atm, anyway?
02:34:34 <visof> how can i read num as a string ?
02:34:52 <quicksilver> > (read "3") :: Int
02:34:54 <lambdabot>   3
02:34:58 <quicksilver> Philippa_: emacs.
02:34:59 <Axman6> quicksilver: http://developer.apple.com/technology/tools.html the first of the three pictures above the title Interface Builder
02:35:22 <visof> reverse situation?
02:35:26 * quicksilver nods.
02:35:33 <quicksilver> > show 3
02:35:34 <lambdabot>   "3"
02:37:30 <visof> show for numbers only ?
02:37:43 <visof> can i convert anything in string format ?
02:38:13 <blackh> visof: Anything that derives or is an instance of Show
02:39:18 <Axman6> @instances Show
02:39:18 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
02:39:44 <Axman6> plus many more
02:40:19 <visof> readProcess "factor" ["20"] "" yields a string , right?
02:40:48 <visof> let foo string = map read . tail . words $ string :: [Int]
02:41:06 <visof> when i did foo $ (readProcess "factor" ["20"] "")
02:41:09 <visof> i get error
02:41:12 <visof> why
02:41:27 <Axman6> :t readProcess
02:41:28 <lambdabot> Not in scope: `readProcess'
02:41:29 <quicksilver> visof: I won't tell you unless you tell me what the error was.
02:41:49 <visof>  Couldn't match expected type `a -> String'
02:41:49 <visof>            against inferred type `IO String'
02:42:26 <quicksilver> right, and there is your answer.
02:42:33 <quicksilver> readProcess .... has type "IO String"
02:42:39 <quicksilver> it's an IO action which results in a string.
02:42:47 <quicksilver> your "foo" is a function which works on strings.
02:42:56 <visof> well how can i solve this ?
02:43:11 <quicksilver> foo `fmap` (readProcess "factor" ["20"] "")
02:43:16 <quicksilver> fmap will apply foo "inside" the IO.
02:44:03 <visof> thanks
02:47:28 <imyourmonad> so if i want to read a big file in a different thread and then return the result to the main thread and print it, how do I? create a: readingThread <- newMVar (readFile file); readid <- forkIO readingThread; ?
02:47:45 <quicksilver> not quite.
02:47:53 <quicksilver> create the MVar in the main thread before the fork.
02:48:08 <quicksilver> in the 'reading thread' "putMVar" the data into the MVAR
02:48:14 <quicksilver> in the 'main thread' "takeMVar" it out.
02:48:24 <Axman6> imyourmonad: fotkIO just gives you back a reference to the thread so you can say kill it or send it exceptions
02:48:28 <Axman6> :t forkIO
02:48:29 <lambdabot> Not in scope: `forkIO'
02:48:41 <Axman6> :t Control.Concurrent.forkIO
02:48:42 <lambdabot> IO () -> IO GHC.Conc.ThreadId
02:48:57 <quicksilver> note that since readFile is lazy it won't actually do the work until its demanded
02:48:58 <Axman6> or, IO () -> IO ThreadId
02:49:02 <quicksilver> so it won't end up in the thread you expected.
02:49:05 <quicksilver> readFile is a meanie.
02:49:24 <Axman6> quicksilver: so putting the result in an MVar won't demand it?
02:49:33 <quicksilver> Axman6: of course not.
02:50:02 <quicksilver> Axman6: do you want putMVar mv ([1..]) to terminate or not? ;)
02:50:03 <Axman6> what do you mean of course not? it's a fair enough question...
02:50:09 <imyourmonad> so forkIO doesnt start a thread?
02:50:13 <quicksilver> imyourmonad: yes it does.
02:50:17 <Axman6> it forks a thread
02:50:37 <Axman6> you need to set up a way to communicate between threads
02:50:39 <quicksilver> Axman6: its a perfectly fair question, but the answer is 'of course not'
02:50:50 <quicksilver> Axman6: since there is no general haskell technique for 'demanding' a result.
02:51:01 <Axman6> which is often done using an MVar
02:51:05 <quicksilver> Axman6: (rnf is not part of the standard lib, really)
02:51:13 <Axman6> yeah
02:51:19 <galdor> hi, small problem here :( Updated to ghc 6.10, now I can't import Parsec anymore
02:51:46 <galdor> I just use import Text.ParserCombinators.Parsec
02:51:56 <galdor> and in ghci I get Could not find module `Text.ParserCombinators.Parsec':
02:51:59 <quicksilver> it got moved to Text.Parsec I think.
02:52:05 <Axman6> import Text.Parsec
02:52:20 <galdor> ok, same error with Text.Parsec
02:52:29 <galdor> I have the haskell-parsec installed (ArchLinux)
02:52:39 <quicksilver> that's odd.
02:52:55 <galdor> yeah it is
02:53:25 <imyourmonad> Axman6: and how do I communicate amo
02:53:32 <Axman6> using an MVar
02:53:37 <galdor> I have /usr/lib/ghc-6.10.1/parsec-2.1.0.1/Text/ParserCombinators/Parsec on my system, everything seems ok
02:53:38 <imyourmonad> between threads? the main thread is there automatically right?
02:53:45 <imyourmonad> so I jsut need to forkIO once?
02:53:49 <galdor> is there a way to ask ghci the locations where it searches its libs ?
02:53:58 <blackh> imyourmonad: That's right
02:54:13 <Axman6> do { v <- newEmptyMVar; forkIO (someIOProcess >>= putMVar v); takeMVar v}
02:57:03 <pejo> galdor, ghc -v --make File.hs shoudl print a lot of information.
02:58:08 <visof> how can i convert the list to a string [3] to "[3]"
02:58:24 <wli> Is there any danger in using newStdGen every time instead of chaining the RNG's state?
02:58:56 <galdor> hiding package parsec-2.1.0.1 to avoid conflict with later version parsec-3.0.0
02:58:58 <quicksilver> the danger is you won't get very good randomness.
02:59:01 <galdor> thank you pejo :)
02:59:12 <blackh> visof: show [3]
02:59:13 <galdor> seems ghc is shipped with parsec
02:59:21 <galdor> installing haskell-parsec gives another version
02:59:46 <Axman6> sounds about right
03:00:15 <wli> This Pollard factorization weirdly takes forever on some numbers and rocks for others.
03:00:33 <imyourmonad> thanks axman6  got it wokring now
03:00:46 <imyourmonad> can mergesort be forked to run on several cores easily?
03:00:53 <Axman6> imyourmonad: it's worth learning how the concurrency stuff works
03:01:07 <blathijs> What does the (# a, b #) notation mean? Is that a special kind of tuple (unboxed or something?)
03:01:18 <Axman6> yep, unboxed tuple
03:01:32 <imyourmonad> axman6: what do you mean? just in general or that I should put ore time in it?
03:01:50 <wli> Polyphase merge sorting isn't all that concurrent.
03:02:17 <Axman6> imyourmonad: read the docs for Control.Concurrent(|.MVar|.Chan)
03:02:22 <imyourmonad> any sort that is?
03:03:00 <imyourmonad> what is Mvar and Chan? mutable variable and channel?
03:03:07 <Axman6> i think you could use the parallelism stuff for mergesort, but i think it may be slower
03:03:17 <imyourmonad> Chan is an abstract type representing an unbounded FIFO channel.
03:03:17 <Axman6> imyourmonad: read the docs and find out ;)
03:03:38 <imyourmonad> ye
03:03:39 <imyourmonad> s
03:05:29 <Axman6> Chans are basically a bunch of linhed MVars
03:05:32 <Axman6> linked*
03:06:12 <blathijs> Axman6: k, thanks
03:06:31 <imyourmonad> and for a computer game where you need music, soundeffects and gameplay in separate threads, what would you use?
03:06:36 <Axman6> blathijs: i still haven't been able to figure out exactly what that means though
03:06:54 <wli> I have an idea.
03:07:44 <wli> Put it in memory as a shared mutable array. Divide up the index range into 2^n pieces. Sort the even and odd pieces in different 2 different threads.
03:07:52 <visof> if we have list [2,3,4] , how can we get the permutations of these numbers that should get [2,3,4,6,8,12,24] ?
03:08:07 <wli> Then double the blocksize and merge in the 2 different threads.
03:09:10 <blathijs> Axman6: I think it removes a level of indirection, ie, don't store a pointer to the tuple, but store the tuple's elements directly
03:09:13 <blathijs> Not sure though
03:09:39 <Axman6> yeah, i was thinking that too, but does that mean the contents are unboxed too?
03:09:57 <xenoblitz> guys: can someone explain what the error here means: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1816#a1816 ... PS I know how to fix it... its the commented line... but it would be nice if someone explained in simpler english why I had to give the type explicitly
03:10:05 <xenoblitz> *oh and gals
03:10:08 <Axman6> otherwise how does it know where one element stops and the other begins...
03:10:51 <quicksilver> imyourmonad: you don't bother to put music and soundeffects in separate threads in practice.
03:11:03 <quicksilver> imyourmonad: the OS has buffers for sound
03:11:12 <quicksilver> you can fill those buffers relatively infrequently and keep things running fine.
03:11:22 <quicksilver> having said that, I've never used audio in haskell.
03:11:28 <Saizan> xenoblitz: when you have a definition with no formal parameter, like "foo = .." instead of "foo x = ..", the MR forces it to be monomorphic
03:11:33 <Axman6> xenoblitz: well, to use show, the compiler needs to know which version of show to use. without the type declaration, it won't know what type count is
03:11:59 <Saizan> plus what Axman6 said :)
03:12:16 <doserj> *what type label is
03:12:20 <Saizan> @where report
03:12:20 <lambdabot> http://www.haskell.org/onlinereport/
03:12:47 <xenoblitz> Saizan: is there a simple definition for monomorphic? and thanks :)
03:12:47 <xenoblitz> Axman6: thanks :)
03:12:49 <quicksilver> @go haskellwiki monomorphism restriction
03:12:51 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:12:51 <lambdabot> Title: Monomorphism restriction - HaskellWiki
03:12:59 <xenoblitz> quicksilver: thanks :)
03:13:02 <quicksilver> xenoblitz: the DMR is a pain in the arse; that page explains it somewhat.
03:13:31 <Axman6> xenoblitz: now i come to think of it, it doesn't know which show to use you label either :P
03:13:31 <xenoblitz> thanks guys
03:13:37 <Saizan> http://www.haskell.org/onlinereport/decls.html <- section 4.5.5 explains it here
03:14:26 <Saizan> ?type show
03:14:28 <lambdabot> forall a. (Show a) => a -> String
03:14:41 <Saizan> show is polymorphic because you can call it on different types
03:15:16 <Saizan> monomorphic is the opposite
03:15:22 <visof> > [x*y | x <- [2,3,4], y <- [2,3,4]]
03:15:23 <lambdabot>   [4,6,8,6,9,12,8,12,16]
03:15:36 <xenoblitz> ok makes sense... one type
03:15:42 <Saizan> (the MR actually cares only about polymorphism where classes are involved)
03:15:47 <Saizan> ?type map
03:15:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:16:01 <Saizan> map is only parametrically polymorphic
03:16:18 <Saizan> so if you define it with no formal parameters you won't get the same problems
03:16:34 <visof> oh i want to get [2,3,4,6,8,12,24]
03:16:36 <xenoblitz> amazing stuff... i really need to read up on haskell's type system
03:16:48 <xenoblitz> but i think that's a world of its own :P
03:16:49 <O_4> imyourmonad: in a computer game, wouldn't you be using OpenAL and not concerning yourself with any OS-level audio stuff anyway?
03:17:54 <Saizan> the MR is kind of the worst and most hated part of it :)
03:17:58 <imyourmonad> OpenAL?
03:18:08 <Axman6> > let permthing xs = [x * y | x <- xs, y <- filter (==x) (1:xs)] in permthing [2,3,4]
03:18:10 <lambdabot>   [4,9,16]
03:18:13 <Axman6> hmm
03:18:29 <xenoblitz> Saizan: oh i c so I incidentally hit it by mistake
03:19:14 <Axman6> > let permthing xs = [x * y | x <- xs, y <- filter (/=x) (1:xs)] in permthing [2,3,4]
03:19:16 <lambdabot>   [2,6,8,3,6,12,4,8,12]
03:19:19 <ibid> the MR is a tradeoff. if we didn't have it, we'd get other kinds of complaints
03:19:23 <O_4> imyourmonad: yeah...  http://en.wikipedia.org/wiki/OpenAL
03:19:25 <Axman6> > let permthing xs = nub [x * y | x <- xs, y <- filter (/=x) (1:xs)] in permthing [2,3,4]
03:19:27 <lambdabot>   [2,6,8,3,12,4]
03:19:42 <Axman6> > let permthing xs =  sort . nub $ [x * y | x <- xs, y <- filter (/=x) (1:xs)] in permthing [2,3,4]
03:19:43 <vincenz> How do you tell cabal to use a different directory for it's update?
03:19:43 <lambdabot>   [2,3,4,6,8,12]
03:19:46 <Axman6> ha, so inefficient
03:19:58 <Axman6> visof: how's that?
03:20:03 <xenoblitz> Saizan, ibid: yes I understand... sort of lesser of two evils... for people like me that's really weird though... how just adding something to pattern match against works
03:20:49 <ibid> xenoblitz: not sure about the lesser part. just a different kind of evil, that happened to win an argument back in the day :)
03:21:04 <xenoblitz> ibid: ic ic
03:21:24 <xenoblitz> thanks for the info guys
03:21:24 <xenoblitz> :)
03:21:28 <ibid> :)
03:21:35 <vincenz> I think that cabal needs a --global flag for update
03:21:43 <vincenz> It bugs me that it does it in ~/.cabal
03:21:46 <Saizan> update?
03:21:46 <vincenz> Especially if you sudo it
03:21:50 <vincenz> When you're doing --global installs
03:22:00 <vincenz> Then you get /root/.cabal
03:22:01 <visof> Axman6 where sort and nub functions ?
03:22:08 <vincenz> /usr/local/something would be better
03:22:10 <Axman6> Data.List
03:22:44 <Saizan> vincenz: you'd like a machine-global index of packages?
03:22:55 <vincenz> Saizan: if you're doing --global installs, then yes.
03:22:56 <Saizan> *available
03:23:13 <Saizan> but you call update separately from install
03:23:18 <vincenz> Sure
03:23:26 <vincenz> But if you cabal update without doing sudo, it does it in your homedir
03:23:39 <vincenz> And then when you do 'sudo cabal install --global foo" it breaks
03:23:43 <vincenz> Since it can't find the .cabal directory
03:23:53 <vincenz> I.o.w. update should have a --global functionality too
03:23:59 <Saizan> vincenz: oh, i use cabal install --global --root-cmd=sudo foo
03:24:10 <Saizan> vincenz: so the download/build is not done as user
03:24:11 <vincenz> Saizan: That would still not work, our homedirs are NFS mounted
03:24:20 <visof> Axman6 that function don't do what i want
03:24:35 <visof> > let permthing xs =  sort . nub $ [x * y | x <- xs, y <- filter (/=x) (1:xs)] in permthing [2,2,3]
03:24:36 <lambdabot>   [2,3,6]
03:24:59 <visof> should be [2,3,4,6,12]
03:25:46 <imyourmonad> if i want to read 2 files and print whichever finishes first, how do I? by using put/tale MVar im synchronizing it seems
03:25:49 <quicksilver> but getting "12" requires multiplying three numbers, visof
03:25:54 <quicksilver> (12 = 2 * 2 * 3)
03:25:59 <visof> right
03:26:03 <quicksilver> your code clearly only ever multiplies pairs of numbers
03:26:06 <quicksilver> x * y
03:26:18 <visof> it was wrong
03:26:25 <quicksilver> yes, we agree on that :)
03:26:32 <quicksilver> I was just pointing out how to see the mistake.
03:26:51 <quicksilver> imyourmonad: have them both put into the same MVar
03:26:54 <quicksilver> imyourmonad: then only one can win
03:27:10 <quicksilver> I will warn you again, though, that readFile defers the IO so it's not going to work as expected.
03:28:20 <imyourmonad> i want to print both though
03:28:32 <wli> How can I figure out where a stack overflow is coming from?
03:28:56 <quicksilver> imyourmonad: then use a Chan
03:28:58 <SamB_XP_> wli: profile?
03:29:02 <quicksilver> the first one to arrive will be first in the chan.
03:29:11 <doserj> > let powerset [] = [[]] ; powerset (x:xs) = concatMap ( \ s -> s:[x:s]) (powerset xs) in sort.map product.nub.sort.tail.powerset $ [2,2,3]
03:29:12 <lambdabot>   [2,3,4,6,12]
03:29:27 <lilac> imyourmonad: forkIO $ putStr =<< readContents f
03:29:33 <wli> Gah, there's no way to get a backtrace?
03:29:36 <lilac> imyourmonad: something like that?
03:29:52 <quicksilver> wli: recall that haskell doesn't have a lexical call stack.
03:29:54 <J-roen> Hi. When I use connectTo, how do I know my own port number?
03:30:00 <quicksilver> well "haskell" does ;)
03:30:02 <quicksilver> but GHC doesn't.
03:30:21 <quicksilver> wli: the closest thing to lexical call stack is cost centre stack
03:30:29 <quicksilver> which is why SamB_XP_ is suggesting profiling.
03:30:29 <Saizan> you can get something out of the ghci debugger, is you :set -fbreak-on-exception
03:30:32 <wli> quicksilver: Well, the stack overflow is some sort of stack.
03:30:34 <lilac> quicksilver: but the lexical call stack won't be overflowing so why would you care?
03:30:44 <quicksilver> lilac: wli was asking for a 'backtrace'
03:30:53 <quicksilver> lilac: normally that refers to lexical stack.
03:30:56 <wli> Saizan: That's what I was looking for. Thanks.
03:30:58 <lilac> quicksilver: < wli> How can I figure out where a stack overflow is coming from?
03:31:08 <quicksilver> lilac:  < wli> Gah, there's no way to get a backtrace?
03:31:26 <Saizan> wli: you've to run the expression with ":trace expr"
03:31:37 <lilac> quicksilver: a backtrace in the context of a stack overflow would be for thunk forcing, presumably, no?
03:31:39 <SamB_XP_> all of the other methods involve profiling ;-P
03:31:47 <quicksilver> wli: the stack which overflowed is mostly likely all full of the same operators
03:31:57 <quicksilver> (+ (+ (+ (+ (+ (+ (+ (+ (+ ....
03:31:59 <quicksilver> ;)
03:32:09 <quicksilver> but know which might indeed be a clue.
03:32:13 <wli> That's fine, so long as I have an idea of which one.
03:32:32 <imyourmonad> what ahppened to yohan yesterday? did he manage to sort his 1 billion integers?
03:32:33 <SamB_XP_> you, uh, look to see what kind of thunk you are accumulating on the heap, I think
03:32:45 <imyourmonad> iliac: i dont know
03:33:30 <imyourmonad> how is Data.Map implemented? using STArrays?
03:33:43 <Axman6> no...
03:33:50 <SamB_XP_> imyourmonad: binary trees, generally
03:33:52 <Saizan> no. it's a binary search tree
03:33:52 <Axman6> it's just a datatype... check the docs
03:34:03 <imyourmonad> ok so it isnt a hashtable?
03:34:16 <SamB_XP_> no! Data.HashTable is slower!
03:34:44 <SamB_XP_> (and has a much more painful interface)
03:41:49 <pejo> wli/Saizan, sometimes the debugger points straight to the offender, and in those times it's very useful imho.
03:41:55 <imyourmonad> unbounded fifo channel, but then it prints the first one right? I want to start reading 2 files concurrently, i want to print them out ocne they are finished, but whoever finishes first should print first. what do I use for that?
03:42:40 <Axman6> concurrent reading sounds slow to me :\
03:42:58 <TuringTest> wli: you can also try to compile for profiling and run the binary with the +RTS -xs option. See http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
03:43:05 <O_4> Some people like to thrash their HDs :-p
03:43:18 <SamB_XP_> since when is a stack overflow an exception ?
03:43:34 <visof> quicksilver i can't do intF (factors 20) , the same error that want fmap in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1817#a1817
03:43:38 <SamB_XP_> O_4: you talkin' about -fsplit-objs ?
03:43:52 <visof> the error is  Couldn't match expected type `[a]' against inferred type `IO [Int]'
03:43:54 <visof>     In the first argument of `intF', namely `(factors 20)'
03:44:12 <O_4> SamB_XP_: no, about reading many files simultaneously.
03:45:53 <quicksilver> visof: yes, for the same reason, and with the same solution.
03:46:06 <quicksilver> factors 20 has the type IO [Int]
03:46:17 <quicksilver> because it does IO to calculate the result.
03:46:31 <quicksilver> the solution is intF `fmap` factors 20
03:46:33 <TuringTest> SamB_XP_: a stack overflow occurs not when building thunks but when evaluating one.  I can build a million nested (succ (succ (succ ...))) as a giant thunk, but when I try to evaluate it the GHC runtime stack space might get exhausted.  The stack space can be increased by the +RTS -K... switch.   A different runtime design might have it automatically expand, but this tends to hide the use of huge thunks.  It is current policy to die with hu
03:46:53 <visof> yeah
03:47:07 <SamB_XP_> TuringTest: huh ?
03:47:14 <SamB_XP_> what's that to do with my question ?
03:47:22 <SamB_XP_> I know it's a *bad thing*
03:47:29 <quicksilver> TuringTest: you got cut off, but there is a strong argument that there is a good case for allowing unlimited stack space just like you allow unlimited heap space.
03:47:38 <SamB_XP_> but since when can it be caught ?
03:47:45 <TuringTest> SamB_XP_: you wrote "since when is a stack overflow an exception ?"
03:48:02 <TuringTest> SamB_XP: ooops
03:48:16 <quicksilver> TuringTest: the counter argument is that stack overflow often does indicate a programming bug
03:48:30 <quicksilver> and that GHC code is slow with large stacks.
03:48:51 <Axman6> TuringTest: producing a stack overflow causes an exception from GHC, that's what he was asking about
03:49:01 <alinp> Hi
03:49:04 <alinp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1818#a1818
03:49:07 <koala_man> the stack is automatically expanded, isn't it? and that flag is just the upper limit
03:49:10 <alinp> what may be wrong in here ?
03:49:15 <TuringTest> Axman6: I had not scrolled back far enough.  I apologize to the channel.
03:49:22 <alinp> Ambiguous occurrence `=='
03:49:32 <imyourmonad> axman6: well its msotly an exercise to try and understand concurrency(in general and in haskell)
03:49:55 <imyourmonad> i want to have a decent understanding of the stuff involved in making a videogame before i start doing one
03:49:59 <Axman6> imyourmonad: well, in that case _read the docs!_ ;)
03:50:22 <doserj> alinp: first, hide the prelude
03:50:27 <Axman6> alinp: you're redefining (==)
03:50:37 <doserj> alinp: then, fix the bug in your code
03:51:00 <alinp> I understand
03:51:00 <TuringTest> quicksilver: A "production quality" runtime might have an option to expand the stack.  I am not sure, but I remember GHC had (or still has) problems deallocating space after it is no longer needed.
03:51:01 <alinp> thanks
03:51:39 <quicksilver> TuringTest: GHC has an option to expand the stack.
03:51:44 <quicksilver> TuringTest: it would be trivial to make it unlimited.
03:52:00 <quicksilver> the reason that is not done is (a) some people think that stack overflows are a useful indicator of bugs
03:52:06 <quicksilver> (b) it would perform appallingly.
03:52:18 <quicksilver> I'm almost convinced that I disagree with (a)
03:52:26 <quicksilver> (b) is just an implementation problem, which could be fixed with sufficient work.
03:55:00 <fasta> Is there a browser in which searching in the Haskell documentation does not take more than 1 second? Firefox spikes at 50% (two cores) for a few seconds for a simple query. Or is the JavaScript just that bad?
03:55:57 <quicksilver> fasta: I've certainly heard bad things about that javascript. I don't use it myself.
03:56:03 <quicksilver> what kind of search are you trying to do?
03:56:08 <fasta> quicksilver: it would be useful to have unlimited stack.
03:56:15 <fasta> quicksilver: maxint ;)
03:56:19 <Axman6> never had any problems with safari
03:56:22 <fasta> @hoogle maxint
03:56:22 <lambdabot> No results found
03:56:30 <fasta> @hoogle maxbound
03:56:30 <lambdabot> Prelude maxBound :: Bounded a => a
03:59:18 <fasta> It seems Konqueror is a bit faster.
04:05:27 <johnbs> Should QuickCheck 2.1.0.1 build ok on ghc-6.10? I'm hitting a couple of errors in QuickCheck\Exception.hs...
04:06:27 <Axman6> doesn't it come with GHC?
04:06:38 <johnbs> ghc comes with an older version
04:06:43 <Axman6> ah
04:10:26 <toliko_smoren> hey i am declaring an instance of Num and trying to write a signum. How can I call the signum function for integers?
04:10:43 <toliko_smoren> basically this does not want to work
04:10:44 <toliko_smoren>     signum (Rat a b)= signum (a `div` b)
04:11:25 <Saizan> johnbs: are you using cabal-install to install it?
04:12:13 <Saizan> toliko_smoren: what are the types of 'a' and 'b'?
04:12:13 <johnbs> Saizan: I just ran "runghc Setup.lhs build" (after configure)
04:12:20 <toliko_smoren> Integer
04:12:49 <johnbs> :t signum
04:12:50 <lambdabot> forall a. (Num a) => a -> a
04:13:04 <Saizan> ?type \a b -> signum ((a :: Integer) `div` b)
04:13:05 <lambdabot> Integer -> Integer -> Integer
04:13:25 <wli> This thing is running so slow when traced it's ridiculous.
04:13:35 <Saizan> johnbs: reconfigure using --constraint="base < 4"
04:14:13 <toliko_smoren> so basically i want instead of calling the signum on Rat call the Integer signum
04:14:27 <johnbs> Saizan: great, that works, thanks :)
04:14:39 <Saizan> toliko_smoren: that should work if a and b are indeed Integer
04:14:47 <imyourmonad> i dont get how to pass an IO-action to a Chan, putting there a value I can but how to put an IO-action? ho I fork the Chan?
04:15:00 <doserj> toliko_smoren: you have to convert the Integer signum to a Rat signum
04:15:07 <johnbs> the result has to be the same type as the argument though, so if you put a (Rat _ _) in, you have to get the same type out; you can't get an Integer out
04:15:11 <Saizan> oh, right
04:15:12 <imyourmonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1819#a1819
04:15:14 <int-e> imyourmonad: IO actions are values
04:15:33 <Saizan> ?type \a b -> fromIntegral $ signum ((a :: Integer) `div` b)
04:15:34 <lambdabot> forall b. (Num b) => Integer -> Integer -> b
04:16:16 <toliko_smoren> that appears to work tahnks
04:17:12 <quicksilver> imyourmonad: you could put an IO action in a CHan. YOu can put anything there. But is that really waht you want to do?
04:17:25 <quicksilver> or do you want to execute the IO action and then put the result in the Chan?
04:17:27 <imyourmonad> i dont know
04:17:51 <imyourmonad> I want to start reading 2 files concurrently, i want to print them out ocne they are finished, but whoever finishes first should print first. what do I use for that?
04:18:22 <int-e> imyourmonad: two threads and an MVar used as a lock to make sure that they don't print concurrently.
04:18:50 <quicksilver> or stuff the results (the strings) into an MVar
04:18:55 <quicksilver> sorry, I mean Chan
04:18:59 <quicksilver> and do all the printing in the main thread.
04:19:17 <int-e> imyourmonad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1820#a1820
04:19:20 <quicksilver> it's often sane to do all your printing from one thread because buffering means you can et weird interleaving.
04:19:28 <int-e> quicksilver: I'd prefer an MVar
04:20:03 <int-e> bah
04:20:32 <int-e> (ok, I just proved that MVars are needlessly tricky. I produced a deadlock opportunity.)
04:27:17 <raxas> why swapMVar is designed not atomic but race conditon is beyond me
04:28:22 <imyourmonad> what does thay do int-e?
04:28:29 <imyourmonad> that file you posted
04:29:05 <int-e> raxas: the reason is that with atomic swapMVar or readMVar, the RTS would have to deal with waking up several threads simultaneously for takeMVar or putMVar.
04:30:28 <int-e> raxas: besides, they are atomic if the MVar is never written to when it could be full.
04:31:58 <int-e> imyourmonad: it reads the files given on the command line, and prints them all, in the way you asked for.
04:33:34 <int-e> imyourmonad: The difference between catFiles1 and catFiles2 is that in one version each thread does its own printing while in the second one, the main thread does that. (note I had a bug in catFiles2; there's an annotation with a fixed version. and it wouldn't have happened if I'd had used a Chan for passing the results down to the main thread.)
04:35:12 <imyourmonad> if if stuff x1 into Chan Y and then is tuff x2. now i readChan Y , do i get whatever finished first or do I get x1 always?
04:35:25 <Botje> im in ur monad, radoactivatin ur apples wif a spacesuit an a conveyor belt.
04:36:05 <imyourmonad> iminyourIOMonadforkingyourballs
04:36:12 <Botje> ouch :)
04:36:51 <int-e> imyourmonad: you need several threads to do what you want.
04:39:21 <Axman6> imyourmonad: i'd use an MVar, and take from it twice
04:42:13 <imyourmonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1822#a1822 <- i use a Chan there with 2 threads, it prints the big file first, but perhaps file-reading is so fast it oesnt matter? or is it readFile that fucks with me?
04:43:30 <int-e> imyourmonad: readFile doesn't really read the file, as quicksilver said almost 2 hours ago.
04:43:41 <int-e> <quicksilver> note that since readFile is lazy it won't actually do the work until its demanded
04:44:07 <imyourmonad> can i force readFile
04:45:02 <int-e> something like  do x <- readFile blah; evaluate (length x); return x
04:45:33 <int-e> (evaluate is from Control.Exception. You can also use  do x <- readFile blah; length x `seq` return x)
04:45:36 <quicksilver> I said it three times, IIRC.
04:45:58 <toliko_smoren> is there an easy way of choosing a random element inside a list( i am doing this inside an IO)?
04:48:11 <int-e> toliko_smoren: pick xs = do n <- randomRIO (0, length xs-1); return xs !! n
04:48:40 <toliko_smoren> thanks
04:48:48 <johnbs> imyourmonad: the ByteString file reading functions are strict, it might be easier to use those
04:49:21 <imyourmonad> ah now it works. when usign length seq. the small file is printed first even it if started 2nd. cool.
04:50:20 <imyourmonad> what is the advantage /disadvantage for using MVar instead of Chan for ^^ my task?
04:50:30 <imyourmonad> thanks int-e
04:50:33 <imyourmonad> and quicksilver
04:51:13 <imyourmonad> but i thought Chan meant first in first out but here it is first finished processing first out
04:51:20 <mopped> > let zebra f g [] = []; zebra f g (x:xs) = (f x):(zebra g f xs) in zebra (+1) (-1) [1..10]
04:51:22 <lambdabot>       No instance for (Num (a -> a))
04:51:22 <lambdabot>        arising from a use of `negate' at...
04:51:24 <int-e> hmm, reading a strict ByteString from a fifo special file fails :/
04:52:29 <int-e> mopped: (-1) is a number. use (subtract 1) or (+(-1)) or pred
04:52:48 <mopped> > let zebra f g [] = []; zebra f g (x:xs) = (f x):(zebra g f xs) in zebra (+1) (subtract 1) [1..10]
04:52:49 <quicksilver> imyourmonad: you are right about what it means.
04:52:50 <lambdabot>   [2,1,4,3,6,5,8,7,10,9]
04:52:56 <quicksilver> imyourmonad: readFile is confusing (IMO broken)
04:53:01 <mopped> is there a way to do zebra without explicit recursion?
04:53:03 <quicksilver> by not doign the work until you demand it.
04:53:29 <int-e> quicksilver: it's a bad default for sure
04:56:37 <imyourmonad> quicksilver: yes but since i forced it... which means it should still print the first file to be put to the chan first out right? but it doesnt...
04:57:24 <int-e> imyourmonad: the forcing happens before putting the result into the channel.
04:57:29 <johnbs> int-e: was that with ByteString.readFile? or opening it and then using ByteString.hGetContents? I think ByteString.readFile tries to find out how large the file is before reading (so it can allocate the right amount of space up front), which could explain the fifo special file failure
04:57:32 <int-e> imyourmonad: in a separate thread, too.
04:57:51 <int-e> johnbs: that was using readFile, but I really expect the results to be the same in either case
04:57:56 <johnbs> yeah
04:58:18 <johnbs> probably needs to handle that case better
04:58:52 <int-e> johnbs: but looking at readFile you're probably right, it would make a difference.
05:00:29 <int-e> johnbs: thanks, that helped
05:01:17 <magthe> such a simple thing, and still I can't find out how to do it... is there a way to long split lines of haskell code (not string)?
05:02:03 <blackh> magthe: Make sure you learn the indenting rules.
05:02:26 <imyourmonad> int-e: so what are you saying? that the Chan is useless in my case?
05:02:41 <blackh> magthe: Then it's easy to split lines.
05:03:21 <int-e> imyourmonad: in this particular case, yes, it doesn't add any value over using a simple MVar.
05:03:57 <int-e> imyourmonad: because writing to the MVar or Chan is the last thing the thread does - it won't hurt anybody if it blocks.
05:03:59 <hesselink> mopped: how about this: let zebra f g xs = zipWith ($) (cycle [f,g]) xs in zebra (+1) (subtract 1) [1 .. 10]
05:03:59 <blackh> magthe: I can tell you them right now if you like.
05:04:22 <int-e> imyourmonad: "the thread" being one of the two threads that read the files.
05:05:33 <imyourmonad> data Test x = Plus x | Minus x , if i have a a list of Tests and I want to p-match out the x, how can I ?
05:05:39 <imyourmonad> (\Test x -> diff test x)
05:05:42 <imyourmonad> doesnt work
05:06:37 <Axman6> (\m -> case m of Plus x -> x; Minus x -> y)
05:06:42 <blackh> imyourmonad: One way is to name the field, or write yourself a function to do it. (These are equivalent)
05:06:47 <tomh> what would be the best way to recurse for a certain amount of time in haskell?
05:06:49 <imyourmonad> (\x -> diff test (case x of Plus y -> y
05:06:49 <imyourmonad>                                                       Minus y -> y))
05:06:52 <imyourmonad> not so cute
05:07:13 <Axman6> well, that's how it has to be done, unless you write a fromTest function which does the same thing
05:07:15 <blackh> imyourmonad: data Text x = Plus {value :: x} | Minus {value :: x}
05:09:43 <tromp_> you want to recurse for 150 milliseconds?
05:12:36 <blackh> tomh: The best way I know is to get the time, pass it to your (IO monad) function, and only recurse if the difference between time now and start time is less than X.
05:12:53 <quicksilver> tomh: you could fork a thread and kill the original if it hasn't finished in 150 milliseconds
05:13:03 <quicksilver> although that wouldn't be very accurate time-wise
05:13:39 <magthe> blackh: please tell me
05:13:56 <blackh> tomh: Or some combination of MVar, forkIO and threadSleep.
05:14:08 <blackh> magthe: Indentation rules:
05:14:16 <imyourmonad> how can there not be a sort function in the Prelude?
05:14:37 <gogonkt> haskell
05:15:01 <blackh> magthe: There are four magic keywords, do, let, where and of.  The next non-whitespace token after this keyword determines the indentation level...
05:15:18 <MyCatVerbs> imyourmonad: it sucks a bit, yeah. Import Data.List to get sort.
05:15:35 <tomh> ok so basically it is a good idea to wrap it into an IO monad?
05:15:51 <blackh> magthe: If the next line is lined up with this indentation level, then it's a new line in the same block.  If it's less, this signals the end of the block.  If greater, it's a continuation of the previous line.
05:15:51 <quicksilver> tomh: except in the IO monad, time doesn't exist.
05:15:54 <Petrosian> Afternoon
05:16:00 <MyCatVerbs> tomh: strictly speaking, yes.
05:16:05 <Petrosian> Can type class constraints be present in data definitions?
05:16:09 <magthe> blackh: is that it?
05:16:11 <tomh> quicksilver: how do you mean?
05:16:21 <MyCatVerbs> Petrosian: yes, but it almost invariably doesn't do what you want.
05:16:43 <Petrosian> MyCatVerbs: Right, what's the syntax?
05:16:46 <blackh> magthe: That's it. Apart from that, it's free-form.  'module X where' is also one of these
05:16:58 <Petrosian> Initial stabs in the dark to do it didn't work
05:17:26 <blackh> magthe: So, apart from those four keywords, all whitespace is equivalent (including new lines)
05:17:44 <magthe> blackh: that doesn't answer my question though... I want to split a long line, ie `foo a b` becomes something like `foo a\nb`
05:18:08 <Petrosian> Ahh, nevermind, think I've figured it out!
05:18:11 <imyourmonad> what do i need to do to sort a data? because List.sort doesnt do with it what i want
05:18:12 <blackh> magthe: Is 'foo a b' in a do block?
05:18:22 <quicksilver> magthe: are you talking about your haskell source files, or are you talking about using haskell to manipulate haskell source as strings?
05:18:35 <magthe> quicksilver: haskell source files
05:18:44 <MyCatVerbs> Petrosian: data (Foo variable) => Constructor...
05:18:49 <quicksilver> in your haskell source fiels you just hit return after a
05:18:51 <magthe> blackh: nope, it a function definition in a let-clause
05:18:56 <Petrosian> MyCatVerbs: Thanks, just got there myself
05:18:58 <quicksilver> and then make sure you indent b "far enough"
05:19:05 <blackh> magthe: Those identation rules I gave you do answer your question, though it may not seem like it.
05:19:09 <quicksilver> where "far enough" is past all other indentation blocks enclosing it.
05:19:14 <quicksilver> let blah = foo a
05:19:17 <quicksilver>             b
05:19:18 <MyCatVerbs> Petrosian: http://www.informatik.uni-freiburg.de/~thiemann/haskell/haskell98-report-html/decls.html <- easier to hit the EBNF in the H98 report than to google for it. x_x
05:19:28 <quicksilver> for example.
05:19:35 <blackh> magthe: what quicksilver said ^
05:19:45 <quicksilver> the critical point is that 'b' is "to the right of" the 'f' in 'foo'
05:19:54 <quicksilver> actually, not it's not
05:20:00 <quicksilver> it just has to be to the right of the 'b' in 'blah' ;)
05:20:01 <quicksilver> sorry.
05:20:07 <Petrosian> MyCatVerbs: So how come they rarely do what you want?
05:20:09 <magthe> quicksilver: ah, ok, thanks
05:20:30 <quicksilver> use emacs + kuribas indentation mode and this is completely automatic
05:21:12 <johnbs> does ghc have a syntax-check mode, like -fsyntax-only for gcc?
05:21:42 <quicksilver> johnbs: load the file into ghci? ;)
05:21:52 <johnbs> heh, 'k
05:22:39 <Axman6> "Measuring programming progress by lines of code is like measuring aircraft building progress by weight." -- Bill Gates. i quite like that
05:22:58 <quicksilver> johnbs: ghc -e '()' File.hs
05:23:00 <quicksilver> perhaps.
05:23:16 <imyourmonad> if i have a data X a = X a | Y a deriving eq,ord,show; and theni have [X 12, Y 5, X7] etc and Iw ant to sort it on the vaklue, how can I do that?
05:23:48 <Axman6> don't derive Eq and/or Ord
05:23:48 <johnbs> quicksilver: yep, that seems to work
05:23:49 <quicksilver> imyourmonad: define the function which gets the value out, as discussed earlier
05:23:53 <quicksilver> and then,
05:23:53 <Axman6> make an instance
05:24:01 <quicksilver> sortBy (comparing getValue)
05:24:08 <quicksilver> where 'getValue' is the function which gets the value out.
05:24:15 <blackh> Axman6: Writing Haskell seems slow because I write code for ages, and end up with this tiny piece of code!
05:24:53 <johnbs> blackh: i wish i'd got to that stage
05:25:10 <SamB_XP> heck, I wish I got the tiny piece of code
05:25:27 <SamB_XP> but no, LHC is still a huge piece of shit
05:25:54 <MyCatVerbs> Petrosian: Usually it's better to put the typeclass constraints on the actual functions that make use of the data type, rather than on the data type itself.
05:26:13 <blackh> johnbs: A few months ago, I wrote about the same code-writing-speed vs. functionality as in other languages, but the resulting code was much shorter. But now I can write code faster in Haskell, which is a great stage to be at.
05:26:18 <Petrosian> MyCatVerbs: I see
05:26:36 <Petrosian> MyCatVerbs: From a compilers perspective, are the two always equivalent?
05:27:17 <quicksilver> Petrosian: no. constraints on data types are broken, don't use them.
05:27:20 <Petrosian> I mean, could you always simply fix the constraints of functions on the types, and essentially "remove" the constraint from the data type?
05:27:26 <SamB_XP> Petrosian: no. one of them gives you incomprehensible error messages ;-P
05:27:31 <quicksilver> they are essentially a bug in haskell 98.
05:27:36 <MyCatVerbs> Petrosian: e.g. Data.Map has data Map k a = ..., and (!) :: (Ord k) => Map k a -> k -> a, rather than data (Ord k) => Map k a = ... and (!) :: Map k a -> k -> a.
05:27:40 <blackh> Anyone want to see a nice piece of Haskell code that I wrote? Well, I'm glad you asked... http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1626#a1626
05:27:43 <SamB_XP> the syntax should not have been defined to mean *anything*
05:27:55 <SamB_XP> as it is, it's wasted
05:28:00 <quicksilver> constraints on individual constructors makes slightly more sense
05:28:06 <blackh> It's the Hodgson (?) Sutherland polygon clipping algorithm, and it came out especially nicely as Haskell code.
05:28:06 <quicksilver> and that's actually supported in a useful way by GHC
05:28:09 <quicksilver> (not by haskell 98)
05:28:12 <MyCatVerbs> Petrosian: I was about to ask you to ask someone else, because I couldn't remember what the issue was. Fortunately, SamB_XP and quicksilver just chimed in. :)
05:28:13 <quicksilver> but I've still never used it.
05:28:27 <Petrosian> Message received, thanks :P
05:28:44 <quicksilver> Petrosian: one informal point to - I often find I would regret it.
05:28:59 <quicksilver> Petrosian: parametric data types (that is, where there is no restriction on the type parameter) can be used in unexpected ways.
05:29:22 <quicksilver> you will suddently find a neat use for stuffing  a function or something in the parameter
05:29:34 <quicksilver> (and functions wouldn't have been an instance of whatever constraint you had in mind)
05:29:50 <MyCatVerbs> blackh: looks pretty, but maybe the types could be a little more, uh, wordy?
05:30:17 <MyCatVerbs> blackh: clipPolygon :: Integral a => (a,a,a,a) -> [(a,a)] -> [(a,a)] -- a quaterniton to a function from lists of points to lists of points?
05:30:18 <blackh> MyCatVerbs: I was in a hurry. :)
05:30:45 <tomh> mm for very long running recursions (like while(true)) i have to make sure the recursion is tail recursive right?
05:30:46 <MyCatVerbs> blackh: conventionally, you might want to wrap some of these things in datatypes that specify what they actually are. :)
05:30:52 <imyourmonad> how can I filter on a data? like filter (==Plus) [Plus 1 , Minus 2, Plus 3] ?
05:30:58 <Petrosian> Right, stear clear of constriants on data types then, understood.
05:30:59 <blackh> MyCatVerbs: The first arg is the rectangle to clip to
05:30:59 <MyCatVerbs> tomh: yes.
05:31:17 <Petrosian> Thanks SamB_XP, quicksilver, MyCatVerbs
05:31:17 <quicksilver> imyourmonad: define a predicate 'isPlus'
05:31:37 <MyCatVerbs> imyourmonad: filter (\x -> case x of { (Plus _) -> True; _ -> False; })
05:31:45 <MyCatVerbs> Petrosian: no worries. Sorry I couldn't remember anything. :)
05:31:49 <tomh> and if I use a monad the >>= things are calculated in order or?
05:32:30 <johnbs> depends on the monad (usually, I guess)
05:32:38 <tomh> ok
05:32:41 <MyCatVerbs> imyourmonad: your example there is filtering on a constructor. Normally you'd write a function isPlus :: PlusMinus a -> Bool, as: { isPlus (Plus _) = True; isPlus _ = False; }
05:32:53 <tomh> i better use the IO monad then
05:33:02 <MyCatVerbs> imyourmonad: (rather than using a lambda and case expression (bit ugly) every single time).
05:33:48 <Botje> in a pinch you can get away with [x | x@(Plus _) <- list]
05:33:55 <MyCatVerbs> tomh: strictly speaking, you need to use the IO monad if you're taking computation time into account, because you can't model elapsed time in a pure monad.
05:33:57 <Botje> but if you're going to do it more than once, get a predicate
05:34:16 <MyCatVerbs> tomh: er, "pure code", not "pure monad".
05:34:37 <MyCatVerbs> Botje: ooh, nice syntax abuse. Filing that nugget.
05:34:59 <tomh> ok
05:35:05 <tomh> small crash :/
05:35:25 <tomh> gonna try some stuff now thanks MyCatVerbs
05:52:15 <Fredrik> @t fix
05:52:15 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:52:22 <Fredrik> :t fix
05:52:24 <lambdabot> forall a. (a -> a) -> a
06:02:16 <bremner> @hoogle join
06:02:16 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:02:16 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
06:02:16 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
06:08:23 <pozic> I have a program which doesn't load in ghci when I use defaultValue{<assign a value to all fields of C}, but does load when I do C{<assign a value to all fields of C>}. In particular I get that the use of defaultValue is ambiguous (there is a constraint, which has not been resolved). The type of the complete value when using C{} contains the same constraint. I would have expected that using C and defaultValue in these two ways would be the same, but they
06:09:17 <imyourmonad> Multiset {getMultiset = fromList [(2,1)]}
06:09:28 <imyourmonad> isnt getMultiSet a function then?
06:09:57 <fasta> imyourmonad: there are only functions in Haskell, so yes.
06:10:17 <tomh> mm how can i use the UTCTime from an IO UTCTime in a monad as argument for another function?
06:10:48 <imyourmonad> but why does it say it doesnt exist then?
06:10:51 <quicksilver> pozic: paste source?
06:10:58 <quicksilver> imyourmonad: 's' is a different character from 'S'
06:12:22 <tomh> oh nvm
06:13:40 <chessguy> heh, this is not windows :)
06:16:30 <chessguy> fasta, imyourmonad err, technically, getMultiset is a bit more special than a function
06:16:56 <chessguy> if i'm unerstanding the original question correctly
06:17:55 <chessguy> thanks to our awful hackish record system
06:18:16 <ddarius> chessguy: There's nothing hackish about it.  It's just very conservative/simple.
06:18:46 <chessguy> well, i disagree, but i suppose it's a matter of opinion
06:20:55 <quicksilver> chessguy: it's not hackish. It's just not a record system.
06:21:03 <quicksilver> it's a simple extension to ADTs
06:21:10 <quicksilver> with named selector functions
06:21:16 <quicksilver> and a cooky syntax for record updat e:)
06:21:32 <ddarius> Records = tuples with labelled components.  That's exactly what Haskell records are.
06:22:22 <pastah> i would like to make a typeclass for binary rules, so that given two items of the same type (Item) a rule r :: Item -> Item -> Bool
06:22:51 <pastah> is this even possible?
06:22:56 <dodu> hi
06:23:11 <pastah> @faq is this even possible?
06:23:12 <lambdabot> The answer is: Yes! Haskell can do that.
06:23:42 <dodu> can anyone help me code a program?plsss
06:23:56 <pastah> dodu: what do you want to make?
06:24:08 <Zao> dodu: Homework?
06:24:21 <Zao> dodu: Ask questions related to your problem and you might get an answer.
06:24:23 <dodu> no a contest
06:24:37 <Zao> dodu: Contests are supposed to measure your programming and research skill.
06:24:47 <Zao> Not your `whining on IRC' skill.
06:24:57 <dodu> well i too will try
06:25:10 <dodu> if i cannot will u help me
06:25:21 <Zao> dodu: Ask a question already?
06:25:38 <dodu> i haven't got the question yet
06:25:49 <dodu> it will b c-programmin contest
06:26:13 <dodu> i will receive the question in an hour and half
06:26:25 <Zao> dodu: 1) This is #haskell.
06:26:26 <Zao> 2) No.
06:26:55 <araujo> morning
06:28:25 <dodu> so u guys won't code in C?
06:28:35 <johnbs> not if we can avoid it
06:28:48 <Zao> dodu: Some of us do. The scope of the channel is not C, unless in a FFI context.
06:28:55 <pastah> dodu: no
06:29:10 <Zao> In any way, it's morally wrong to ask for help in a contest.
06:29:22 <dodu> just a help
06:29:24 <dodu> pls
06:29:28 <pastah> @faq can you export haskell functions and call them from C programs?
06:29:28 <lambdabot> The answer is: Yes! Haskell can do that.
06:29:38 <araujo> dodu, this channel is about the haskell programming language?, (do you know it?) .. if you need help with C , you could join ##c instead
06:29:41 <Zao> dodu: We can implement your problem in Haskell :P
06:30:07 <dodu> thanx zao
06:30:18 <pozic> quicksilver, the constraint comes from quite deep. I am not sure how easy it is to create an example, but I will try anyway.
06:30:27 <dodu> will u b here couple of hours from now?
06:30:42 <score> heh
06:31:16 <cjay> lol
06:31:25 <fasta> dodu: we also hit people with sticks until they bleed to death when people use "words" like "u" and "b".
06:31:37 <ddarius> Also Zao, can you mow my grass?
06:31:42 <imyourmonad> anyone using Windows (Vista)? I have problems with permissions to isntall. where can I find out about how to manually install packages(without cabal)?
06:31:53 <dodu> oh sorry
06:31:59 <dodu> i will avoid that
06:32:07 <alinp> (/\) :: Int -> Int -> Int
06:32:13 <quicksilver> imyourmonad: you shouuld be able to use cabal --user, I believe.
06:32:14 <alinp> what's the default infix for /\
06:32:15 <alinp> ?
06:32:23 <quicksilver> i've not used windows though.
06:32:23 <alinp> it's infixr ?
06:32:37 <quicksilver> @hoogle (/\)
06:32:37 <lambdabot> No results found
06:32:50 <quicksilver> alinp: I don't think it exists in the standard library
06:32:51 <alinp> I noticed that even if I delcare the infixr for /\ is the same behavior
06:32:55 <quicksilver> so it just gets the default fixity.
06:32:56 <dodu> can anyone of u code this following code
06:32:59 <alinp> no, it's not
06:33:01 <dodu> 2.Write a C program to generate the operators between the numbers to make it a balanced equation.
06:33:05 <pastah> alinp: use :i
06:33:08 <alinp> I defined it
06:33:14 <dodu> The numbers are passesed as arguments to the function and the program needs to insert operaors
06:33:16 <pastah> oh
06:33:25 <pastah> alinp: same as &&?
06:33:27 <quicksilver> "Any operator lacking a fixity declaration is assumed to be infixl 9"
06:33:35 <dodu> 201c+201d, 201c201d
06:33:38 <alinp> no, same as ^
06:33:50 <quicksilver> dodu: we already said, we're not going to write your C program for you.
06:33:59 <alinp> (I'm doing some exercises regarding that ... and ... you know)
06:33:59 <quicksilver> dodu: if you want to do a contest, do it yourself. Good luck!
06:34:00 <alinp> :)
06:34:04 <Zao> ddarius: If you live in a warm climate and can pay me flight tickets, sure.
06:34:05 <araujo> dodu, this channel is about the haskell language
06:34:06 <Zao> I need a vacation.
06:34:58 <ddarius> Zao: It's very warm here and I could pay flight tickets, unfortunately I don't even have a potted plant.
06:35:14 <alinp> pastah: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1823#a1823
06:35:19 <alinp> this is the function that I defined
06:35:29 <quicksilver> alinp: did you see my answer?
06:35:38 <quicksilver> alinp: "Any operator lacking a fixity declaration is assumed to be infixl 9"
06:35:49 <alinp> infixl ?
06:35:52 <alinp> are you sure ?
06:35:57 <pastah> alinp: GAAAAH!!! n+k
06:36:05 <pastah> you will burn for this
06:36:06 <quicksilver> alinp: I copied and pasted that from the haskell report.
06:36:10 <Zao> How would one solve dodu's problem by the way? Brute force?
06:36:10 <alinp> because if I'm declaring it like this, I can use it: 6 /\ 7
06:36:57 <Ferdirand> Brute force with a list comprehension seems nice
06:36:58 <imyourmonad> why does runhaskell --help hang?
06:37:08 <alinp> quicksilver and pastah, thanks
06:38:19 <imyourmonad> C:\Users\saftarn\Desktop\hmidi-0.1>runhaskell --user setup install
06:38:19 <imyourmonad> ghc: unrecognised flags: --user fails
06:38:46 <imyourmonad> is runhaskell == cabal?
06:39:04 <pozic> quicksilver: I think it is similar to this one: http://paste.debian.net/29375/
06:39:12 <Zao> runhaskell is a friendly wrapper around ghc and friends.
06:39:30 <Zao> It's so that you can write scripts that are ignorant of what Haskell implementation you have.
06:40:36 <quicksilver> pozic: monomorphism restriction
06:40:40 <quicksilver> I think.
06:41:07 <pozic> quicksilver: I didn't disable it in this code, but I did in other code.
06:42:13 <pozic> quicksilver: yes, same problem, even with {-# LANGUAGE NoMonomorphismRestriction #-}
06:43:09 <imyourmonad>  runhaskell Setup install --user --prefix=$HOME
06:43:09 <imyourmonad> what does that do on windows?
06:43:13 <quicksilver> pozic: OK, because of a quirk of the record update syntax
06:43:23 <alinp> is there a way to specify to ghci a prefered editor ... like in hugs: hugs -Evim
06:43:24 <quicksilver> pozic: the expression default_value {aa = undefined}
06:43:25 <alinp> for instance
06:43:44 <quicksilver> pozic: hang on, I'm not saying this very well.
06:43:47 <imyourmonad> so basically what cabal deos it compile a module?
06:44:04 <quicksilver> pozic: suppose foo has some "A" type
06:44:09 <alinp> got it: :set editor vim
06:44:13 <pejo> alinp, doesn't ghci care about $EDITOR?
06:44:15 <quicksilver> pozic: then "foo { aa = undefined }" has a different type
06:44:17 <imyourmonad> can I just compiels tuff instead of using cabal or runhaskell?
06:44:24 <quicksilver> pozic: record update on a polymorphic field allows the type fo change.
06:44:28 <alinp> pejo: don't know, that's why I asked :)
06:44:52 <quicksilver> for example, suppose "foo :: A Int"; then "foo { aa = ' ' }" can have type "A Char"
06:44:55 <quicksilver> pozic: do you follow?
06:45:01 <pozic> quicksilver: yes, but why is that a problem?
06:45:01 <quicksilver> record update is allowed to change the type.
06:45:17 <quicksilver> pozic: because then your expression doesn't determine the type of 'default_value'
06:45:26 <alinp> pejo: yep, it's working by defining $EDITOR
06:45:52 <quicksilver> pozic: since it's over-writing aa anyway, htere is nothing left to constraint the type of notWorking
06:45:59 <quicksilver> sorry, not typing what I mean
06:46:06 <quicksilver> "...nothing left to constrain the type of default_value"
06:46:11 <quicksilver> as used in that expression.
06:46:28 <pozic> quicksilver: so, it should still be whatever the constraint was as before?
06:46:41 <pozic> quicksilver: that would seem simple semantics for me.
06:46:52 <quicksilver> no
06:46:58 <pozic> quicksilver: but I don't really get these semantics.
06:46:58 <quicksilver> what does "before" mean?
06:47:04 <quicksilver> 'default_value' has a polymorphic type
06:47:08 <quicksilver> it's a polymorphic value
06:47:13 <quicksilver> btu polymorphic values are not first-class
06:47:21 <quicksilver> when you actually *use* them, you must use them at a particular type
06:47:33 <quicksilver> so, any expression which contains polymorphic values has two choices:
06:47:37 <pozic> quicksilver: but I am not actually using it yet.
06:47:49 <quicksilver> it must either (1) fix the types of those values concretely
06:47:52 <pozic> quicksilver: If I would print it to the screen or something, then I would be using it.
06:47:56 <quicksilver> (2) pass on the polymorphism outwards
06:48:07 <quicksilver> pozic: yes, but nothing you can do will affect the type of 'default_value'
06:48:13 <quicksilver> (as used in that particular term)
06:48:22 <quicksilver> its type is not constrained in any way by the type of notWorking
06:48:31 <quicksilver> there is no way to 'pass the polymorphism out'
06:49:06 <quicksilver> pozic: the following works:
06:49:07 <quicksilver> notWorking = (default_value `asTypeOf` notWorking) {aa = undefined}
06:49:53 <pozic> quicksilver: so, what would be the pseudo type of notWorking (not as in your last example)?
06:49:57 <quicksilver> pozic: because it constrains the type of default_value (the inner term) to be the same as the type of notWorking (the term currently being constructed)
06:50:18 <quicksilver> pozic: there's no type ambiguity
06:50:26 <quicksilver> pozic: notWorking type checks (with the type you expect)
06:50:35 <quicksilver> pozic: it's a semantic bug
06:50:43 <quicksilver> there's no way to generate code for what you wrote
06:50:49 <quicksilver> because it doesn't know which default_value to choose.
06:50:59 <quicksilver> (it turns out not to matter, but that's not something GHC tries to check)
06:51:28 <pozic> quicksilver: in what case would it matter?
06:53:00 <quicksilver> pozic: well, a concrete instance of 'default_value' refers to a particular Show instance
06:53:16 <quicksilver> in principle different Show instances lead to entirely different values.
06:53:48 <pozic> quicksilver: ah, ok. I understand everything you said now :)
06:53:48 <Deewiant> Argh, bytestring-trie is Data.Trie?!
06:54:05 <Deewiant> That makes as much sense as Data.IntMap being Data.Trie :-/
06:55:09 <quicksilver> pozic: good. It's not very easy to explain :)
06:56:30 <Deewiant> I guess I'll call my tries Data.ListTrie or something
06:56:47 <quicksilver> Deewiant: Data.BetterNameThan.BytestringTrie.Chose
06:57:33 <imyourmonad> $ runhaskell Setup install --user --prefix=C:/progra~1/haskell/
06:57:33 <imyourmonad> isnt that supposed to install correctly?
06:57:34 <Deewiant> quicksilver: I'd have gone with Data.ByteStringMap or something, maybe even ask the BS folks if Data.ByteString.Map could be taken
06:58:11 <quicksilver> imyourmonad: can't help you there. I hope tehre are some windows people around.
06:58:56 <greenrd> Can someone help me with this linking error, that occurs when trying to use the GHC API: http://code.google.com/p/gitit/issues/detail?id=32
06:59:49 <Deewiant> quicksilver: In any case I think Data.Trie is a bad choice for such a specific implementation of tries
06:59:53 <sw17ch> greenrd: is gitit really stored in a Google SVN repository? :D
07:00:15 <sw17ch> greenrd: oh, i see
07:00:18 <sw17ch> just the wiki :)
07:00:25 <sw17ch> (the irony was bout to kill me)
07:00:28 <greenrd> hehe
07:01:13 <Philonous1> Is there a way to force a list in parallel? Should something like walk [] = (), walk (x:xs) = x `par` walk xs do the trick?
07:01:32 <Deewiant> Philonous1: rnf
07:03:12 <sw17ch> does forcing a list in parallel make sense?
07:03:39 <quicksilver> Deewiant: yes, I was agreeing with you, flippantly.
07:05:34 <Beelsebob> why do something that complex?
07:05:39 <Beelsebob> why not parMap rnf id
07:05:52 <imyourmonad> wtf why does install fail when build works? Setuip: CreateDirecetoy: permissiond enied, where the hell is it trying to install?
07:06:07 <Beelsebob> imyourmonad: because you're not root
07:06:14 <Beelsebob> and it's trying to put things in /usr/local/lib
07:06:29 <Philonous1> Deewiant: What does rnf stand for? I can't find it in google
07:06:54 <Deewiant> @hoogle rnf
07:06:54 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
07:06:55 <Beelsebob> reduce to normal form
07:07:04 <Philonous1> Thanks
07:07:36 <Philonous1> sw17ch: Does it not? I have an embarrassingly parallel problem in form of a list that I map expensive operations over. Is this a bad idea?
07:07:44 <Beelsebob> (as opposed to reducing to weak head normal form, which just evaluates the outermost constructor)
07:07:53 <sw17ch> Philonous1: oohhhhh...
07:07:57 <Beelsebob> Philonous1: that's what parMay is for then
07:08:00 <Beelsebob> parMap even
07:08:03 <sw17ch> i got mixed up with parallel list access
07:08:06 <sw17ch> vs what you're doing
07:08:09 <sw17ch> you're just fine :)
07:08:24 <Beelsebob> > parMap rnf (*2) [1,2,3,4,5]
07:08:26 <lambdabot>   [2,4,6,8,10]
07:08:27 <Philonous1> Thanks again :)
07:08:28 <sw17ch> parallel list access doesn't make sense (unless it's not actually a list)
07:08:39 <imyourmonad> Beelsebob: windows...
07:08:47 <Deewiant> > rnf . map (*2) $ [1,2,3,4,5]
07:08:48 <Beelsebob> imyourmonad: I dunno then
07:08:49 <lambdabot>   ()
07:08:51 <imyourmonad> so where is it trying to put things on windows?
07:11:33 <juhp_> dons: is X11 License missing second BSD clause (binary redist)?
07:12:07 <Philonous1> Still: should something like walk [] = (); walk (x:xs) = (df x) `par` walk xs where df is deep force work?
07:12:15 <Philonous1> In theory at least
07:16:48 <Beelsebob> Philonous1: what's wrong with parMap?
07:16:59 <Beelsebob> the function you're searching for already exists
07:17:40 <Beelsebob> @src parMap
07:17:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:17:43 <Beelsebob> :(
07:17:47 <Philonous1> Nothing. I was just wondering if my idea should work or if I got something wrong. I don't want to actually use it , just see if I got the principles right
07:17:49 <bremner> @hoogle parMap
07:17:49 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
07:19:18 <Deewiant> Philonous1: walk = rnf
07:19:34 <Philonous1> Ah good.
07:19:51 <Deewiant> where df = rnf
07:19:52 <Deewiant> :-)
07:20:20 <Beelsebob> walk isn't quite rnf
07:20:26 <Beelsebob> it's ultra-parallel rnf
07:20:36 <mac_wooster> ?
07:20:42 <Beelsebob> it adds extra pars
07:20:47 <Beelsebob> that aren't in the usual list rnf instance
07:21:10 <Deewiant> Ah, true.
07:21:20 <Deewiant> The semantics are the same, though.
07:22:18 <Beelsebob> yep
07:22:31 <lokathor> I use @src to see a lib function's source from the bot, right?
07:23:34 <lokathor> @src max
07:23:34 <lambdabot> max x y = if x <= y then y else x
07:24:52 <HugoDaniel> im planing to go to the hackaton... if i can get the money
07:25:09 <Beelsebob> lokathor: yes and no  you get a reference implementation there
07:25:14 <Beelsebob> not necessarily the one that ghc uses
07:25:16 <Beelsebob> @src foldr
07:25:16 <lambdabot> foldr f z []     = z
07:25:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:25:24 <Beelsebob> see  no nice efficient inner go function
07:28:25 <lokathor> inner go function?
07:28:27 <sw17ch> It kills me, but every once in a while, I love how succinctly I can say certain things in C.
07:28:37 <sw17ch> (me likes to not like things)
07:28:46 <Gracenotes> yeah, I never go why you like go functions
07:28:49 <Gracenotes> *got
07:28:56 <Gracenotes> is it because of the reduced parameter passing? :)
07:29:11 <Beelsebob> Gracenotes: and improved memory efficiency IIRC
07:29:13 <Botje> something about ghc not optimizing that correctly?
07:29:14 <quicksilver> Gracenotes: it's because ghc won't inline recursive functions, mostly.
07:29:24 <Botje> yay
07:29:33 <lokathor> what is an inner go function?
07:29:42 <Gracenotes> quicksilver: so using go over foldr is helpful in what sense..?
07:29:44 <Botje> foo = go 1 where go x = ...
07:29:49 <Gracenotes> if it doesn't inline either of them
07:29:51 <quicksilver> Gracenotes: you don't.
07:30:00 <quicksilver> Gracenotes: the point is that foldr is defined using a go function
07:30:04 <quicksilver> so that foldr itself is inlinable
07:30:13 <Gracenotes> oh, I see
07:30:18 <tomh> mm anyone knows if there are profiling packages for time?
07:30:18 <Gracenotes> makes sense
07:30:34 <quicksilver> in some contexts it does also make sense to share parameters
07:30:38 <quicksilver> rather than passing them down
07:31:02 <quicksilver> tomh: profiling is built in to GHC
07:31:05 <quicksilver> tomh: check the fine manual )
07:31:23 <lokathor> Botje: what does that accomplish? I'm afraid I'm new to haskell and I don't really get some bits about the execution
07:31:52 <lokathor> I'm back on "haskell clearly just uses the substitution model"
07:32:11 <Cheshire> lokathor, that works unless you want to think about efficiency
07:32:27 <Botje> lokathor: if i got the talk above correctly, ghc doesn't like inlining toplevel functions or something like that. for now, don't worry about it :)
07:32:55 <tomh> quicksilver: yes, but apperently not if you use time functions..
07:33:08 <quicksilver> tomh: I don't know what you mean.
07:33:13 <tomh>     Could not find module `Data.Time.Calendar':
07:33:17 <quicksilver> tomh: oh, I do.
07:33:20 <Gracenotes> apparently it's used once for foldr in GHC.Base, once for foldl in GHC.List, and once for foldl' in Data.List
07:33:22 <tomh> Perhaps you haven't installed the profiling libraries for package time-1.1.2.3?
07:33:24 <quicksilver> tomh: you have to recompile all your libraries with profiling
07:33:34 <quicksilver> tomh: or install profiling versions, if your distribution provides them.
07:33:35 <Gracenotes> so the go trick doesn't appear too much in the source. At least, named 'go'
07:33:46 <tomh> quicksilver: what is the best way?
07:33:57 <quicksilver> tomh: it depends what OS you are on, etc.
07:34:01 <tomh> mac
07:34:17 <quicksilver> my package of GHC/osx came with prebuilt profiling versions of all the extralibs
07:34:21 <quicksilver> as far as I remember.
07:34:30 <tomh> i installed it from the site
07:35:27 <quicksilver> the version I have (from the site) includes the file /Library/Frameworks/GHC.framework/Versions/608/usr/lib/ghc-6.8.3/lib/time-1.1.2.1/libHStime-1.1.2.1_p.a
07:35:37 <quicksilver> that's the profiling version of the 'time' package
07:35:41 <tomh> ah k
07:35:48 <quicksilver> you can tell it's profiling because of the _p after the version number
07:35:49 <tomh> i use ghc 6.10.1
07:40:38 <tomh> quicksilver: it appears it uses another version of the time lib then the one on that location
07:40:58 <tomh> any way to tell haskell to get it to use the correct version?
07:42:11 <quicksilver> tomh: first found out why you're using the wrong version
07:42:23 <quicksilver> try "ghc-pkg list"
07:42:31 <quicksilver> and see how many times 'time' appears
07:42:36 <quicksilver> I wonder how you got into this mess :)
07:43:24 <johnbs> or just "ghc-pkg list time"
07:43:33 <tomh> probably because i did cabal upgrade or something
07:43:57 <tomh> ye it shows two
07:44:02 <tomh> how can i cleanly remove one?
07:44:41 <johnbs> ghc-pkg unregister, I guess?
07:44:49 <tomh> ok thanks
07:45:59 <quicksilver> tomh: by the way, cabal upgrade is a terrible idea :)
07:48:42 <tomh> ye i had to find out the hard way
08:05:21 <fasta> How to get the maximum Double value which is not Infinite?
08:06:07 <tromp_> > maxBound:: Double
08:06:08 <lambdabot>       No instance for (Bounded Double)
08:06:08 <lambdabot>        arising from a use of `maxBound...
08:07:56 <fasta> Well, I just use a big value now, if it will ever be an issue, I will write a program which computes it.
08:11:08 <quicksilver> > floatRange (undefined :: Double)
08:11:14 <lambdabot>   (-1021,1024)
08:11:25 <quicksilver> fasta: ^^ I blieve you interpret that as meaning the maximum value is around 2^1024
08:11:46 <lepassive> where is sleep function ?
08:11:48 <doserj> > (2-2^^(-52))*2^^(1023)::Double
08:11:49 <lambdabot>   1.7976931348623157e308
08:12:30 <quicksilver> lepassive: Control.Concurrent.threadDelay
08:12:41 <lepassive> thanks quicksilver
08:12:51 <doserj> > ((2-2^^(-52))*2^^(1023)::Double) +2^^970
08:12:53 <lambdabot>   Infinity
08:14:34 <lepassive> :t threadDelay
08:14:35 <lambdabot> Not in scope: `threadDelay'
08:15:07 <lepassive> it takes an int and runs IO action, but  it  doesn't work ?
08:15:41 <quicksilver> lepassive: actually it does work.
08:16:13 <lepassive> quicksilver,     threadDelay 3 shouldn't it sleep for 3 seconds ?
08:16:28 <quicksilver> no, it should sleep for 3 microseconds.
08:16:56 <tromp_> :t (^^)
08:16:57 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
08:18:15 <lilac> or more accurately, /at least/ 3 microseconds ;-)
08:18:28 <lepassive> quicksilver, aha I see
08:18:49 <quicksilver> lilac: right.
08:19:00 <quicksilver> lepassive: it is documented :)
08:19:05 <johnbs> > encodeFloat 2 1022
08:19:06 <lambdabot>   8.98846567431158e307
08:19:10 <johnbs> > encodeFloat 2 1023
08:19:11 <lambdabot>   Infinity
08:20:09 <johnbs> > encodeFloat 1 1023
08:20:10 <lambdabot>   8.98846567431158e307
08:20:21 <johnbs> (duh, stupid me)
08:21:06 <quicksilver> > encodeFloat 3 1022
08:21:09 <lambdabot>   1.348269851146737e308
08:21:14 <quicksilver> > encodeFloat 7 1021
08:21:17 <lambdabot>   1.5729814930045264e308
08:21:19 <quicksilver> (and so on...)
08:21:27 <johnbs> indeed
08:21:53 <quicksilver> the limit being the binary number which is 52 1s, and the exponent being 970
08:22:02 <quicksilver> which would be the number doserj gave :)
08:22:22 <johnbs> right, sorry
08:26:27 <skorpan> fmap tokenToStyle . tokToSpan <- is this equivalent to (fmap tokenToStyle) . tokToSpan?
08:26:49 <quicksilver> skorpan: yes.
08:27:00 <skorpan> why is that?
08:27:03 <quicksilver> skorpan: function application binds tighter than any operator (like (.))
08:27:10 <skorpan> oh, i see
08:27:15 <skorpan> thanks
08:27:15 <quicksilver> f a # g b is always parsed as (f a) # (g b)
08:27:21 <quicksilver> whatever the operator or the functions are.
08:28:40 * Baughn wonders how it would work to redefine ( )
08:29:12 <Badger> deep dark magics, that
08:29:12 <tomh> mm why do endless tail recursive functions consume all cpu?
08:29:40 <Baughn> Sounds like an infinite loop. Why wouldn't they?
08:29:54 <quicksilver> tomh: what would you hope they would do?
08:29:54 <imyourmonad> doesnt anyone use windows ? how do you install on windows? where does ghc want to pu the files? i can do configure and build but install doesnt work...what does install do? since build works i should be able to do the install myself right?
08:30:16 <tomh> quicksilver: well use less cpu, like when a server is idle and waiting for stuff to do :)
08:30:17 <Baughn> imyourmonad: It's by far easiest to download the binary, and then cabal.exe..
08:30:29 <imyourmonad> isnt it possible to do the whole installation manually? what exactly is needed to eb able to import in ghc?
08:30:39 <quicksilver> tomh: well the function you're describing isn't idle
08:30:45 <quicksilver> tomh: it's constantly tail recursing
08:30:54 <quicksilver> tomh: and idle server is just sitting there waiting on network sockets
08:30:58 <imyourmonad> how do I download the binary? i have only sen tars available at hackage?
08:31:03 <Baughn> tomh: If a server is idle, that usually means it's blocking on input in all threads
08:31:04 <quicksilver> tomh: waiting on sockets is quite different from constantly recursing.
08:31:14 <tomh> mm ok
08:31:19 <Baughn> tomh: Or waiting for timeouts, possibly
08:31:24 <tomh> well need some change in plan then :)
08:31:28 <quicksilver> well, waiting for "stuff" in general :)
08:31:31 <Baughn> Either way, an idle server by definition isn't running code. :P
08:32:02 <visof> quicksilver i have two functions "factorize that use IO string " and triangle function that is normal to use it :
08:32:08 <johnbs> imyourmonad: I use windows. what are you trying to do, exactly?
08:32:17 <visof> map factorize (triangle `fmap` 10)
08:32:24 <visof> that doesn't work
08:32:28 <Cheshire> what the hell is fmap 10
08:32:37 <Baughn> quicksilver: Oh yes, is there a Binary variant that operates on single bits?
08:32:44 <imyourmonad> install a package. i do runhaskell setup configure then build and then install, when doing install i get: createDirectory: permission denied.
08:32:50 <quicksilver> Baughn: I have some memory someone knocked one up
08:32:55 <quicksilver> Baughn: I can't remember offhand what they called it.
08:33:02 <johnbs> imyourmonad: by default it tries to put things in C:\Program Files\Haskell
08:33:06 <visof> No instance for (Show (IO [Int]))
08:33:12 <visof> that is the errro
08:33:15 <visof> error
08:33:21 <johnbs> imyourmonad: you can use the --prefix option when you run configure to tell it to put things somewhere else
08:33:35 <Baughn> quicksilver: BitSyntax, maybe?
08:33:36 <johnbs> imyourmonad: personally, I do runghc configure --prefix=C:\ghc\packages
08:33:40 <quicksilver> Baughn: oh, it's in binary-strict
08:33:43 <imyourmonad> johnbs: ok i have tried given permission in program files\haskell, doesnt work
08:33:46 <quicksilver> Baughn: not entirely logical but there you go.
08:33:51 <imyourmonad> i also trie to run with prefix, didnt work
08:33:59 <Baughn> quicksilver: Well, I probably shouldn't be this worried about network usage for a /filesystem/..
08:34:18 <johnbs> is this on xp, vista, or what?
08:36:15 <imyourmonad> vista
08:36:36 <Baughn> quicksilver: Some months ago, I asked about providing a default Binary instance based on Show, that would still be overridable for individual types. That wasn't usefully possible at the time, but since then, ghc 6.10 was released. Does anything in that make a difference? Type families, maybe?
08:36:41 * Baughn is still absorbing those
08:36:58 <johnbs> hmm... i'm on XP here... not sure what else to tell you :/
08:38:11 <johnbs> you could try getting things direct with cabal, as Baughn said (cabal binary from here: http://www.haskell.org/cabal/download.html)
08:38:43 <imyourmonad> wtf not it works
08:38:53 <Baughn> imyourmonad: Also, you should be aware that a /lot/ of packages, while nominally cross-platform, won't actually build on windows without installing lots of unix compatibility stuff - bash, at least
08:38:56 <imyourmonad> i hav changed the permission a 100 times it has just not worked
08:38:59 <imyourmonad> oh well it does now
08:39:02 <imyourmonad> thansk anyway
08:39:23 <imyourmonad> Baughn: i know i have ubuntu installe,d jsut havent got wirless working
08:39:25 <Baughn> (Build-time dependencies only, thankfully)
08:39:35 <galdor> tell me guys; I have a data Variable = Variable (VarName, Sexp); now I'd like to use lookup on a [Variable]
08:39:45 <galdor> but it get a type error
08:40:04 <Baughn> galdor: lookup? As in Map.lookup?
08:40:05 <Cheshire> @src State >>=
08:40:05 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:40:10 <Cheshire> @src >>= State
08:40:10 <lambdabot> Source not found. You speak an infinite deal of nothing
08:40:16 <Cheshire> @src State (>>=)
08:40:16 <lambdabot> Source not found. It can only be attributed to human error.
08:40:20 <Cheshire> @src (>>=) State
08:40:20 <lambdabot> Source not found. Do you think like you type?
08:40:20 <byorgey> Baughn: galdor probably means the Prelude lookup
08:40:23 <galdor> tells me that [(VarName, Sexp)] is expected, and [Variable] inferred
08:40:24 <quicksilver> galdor: lookup works on [(a,b)]
08:40:33 <quicksilver> galdor: this is a different type from [Variable] ;)
08:40:45 <galdor> even if Variable is a (VarName, Sexp) ?
08:40:48 <Baughn> galdor: It would be helpful to see the actual type error you're getting
08:40:49 <quicksilver> you may know that they are the same in terms of information content
08:40:55 <quicksilver> but you've deliberately made them a separate type
08:41:04 <quicksilver> you could 'reduce' Variable to a mere type synonym
08:41:10 <quicksilver> type Variable = (VarName,Sexp)
08:41:14 <quicksilver> then it would let you use lookup
08:41:15 <Baughn> galdor: Variable is nothing of the kind. data creates a new, wrapped type; it'd work with type synonyms
08:41:21 <galdor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1825#a1825
08:41:52 <galdor> ok so data isn't a kind of alias, it really creates a new different type
08:42:01 <ImInYourMonad> ok i just wa<nt to say
08:42:06 <Baughn> galdor: Alternately you could say data Variable = Variable (unVariable :: [(Foo, Bar)]) and use lookup . unVariable
08:42:33 <ImInYourMonad> now HELLASK is fakking dangerous because i got opengl installed soon+ a bunch of other stuff. haskell wont remain unpopular for long
08:42:39 <byorgey> Baughn: ?
08:42:52 <galdor> Baughn: whow I never saw this syntax
08:42:55 <Baughn> byorgey: Well, unwrapping it first
08:43:06 <Baughn> Although I suppose that won't work as-is
08:43:09 <quicksilver> Baughn's outer set of () should be {}
08:43:10 <byorgey> galdor: you can make a function  unVariable :: Variable -> (VarName, Sexp)  like this:  unVariable (Variable x) = x
08:43:11 <jeltsch> Hello, does anyone know what the GHCi error message <interactive>: warning: too many hs_exit()s means?
08:43:22 <Baughn> You'd have to say flip lookup . unVariable
08:43:34 <byorgey> galdor: then you can say 'map unVariable vars' to change a [Variable] into a [(VarName, Sexp)]
08:43:38 <ImInYourMonad> setup: At least the following dependencies are missing:
08:43:38 <ImInYourMonad> storable-complex -any
08:43:41 <ImInYourMonad> what is that?
08:43:48 <galdor> using type Variable = (VarName, Sexp) seems to be ok
08:43:58 <quicksilver> Baughn: map unVariable, indeed.
08:44:00 <byorgey> galdor: sure, that's actually much simpler =)
08:44:05 <Baughn> ImInYourMonad: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/storable-complex
08:44:12 <galdor> I'm just toying with a non-working lisp interpreter to learn haskell, it's not that easy
08:44:33 * quicksilver finds a non-workgin lisp interpreter significantly easier than a working one.
08:44:48 <Baughn> ImInYourMonad: Use cabal-install to install it. In fact, saying just "cabal install" in the directory with the .cabal file with that dependency would've downloaded and installed storable-cmplex automatically.
08:44:54 <galdor> at least I'm having lot of fun :)
08:45:48 <Baughn> galdor: Once you grasp the difference between data and type, look up newtype - that's something else again. :P
08:45:56 <ImInYourMonad> $ runhaskell setup install
08:45:56 <ImInYourMonad> Installing library in C:\Program Files\Haskell\hmatrix-0.5.0.1\ghc-6.10.1
08:45:56 <ImInYourMonad> setup: Error: Could not find module: Data.Packed with any suffix: ["hi"]
08:46:03 <galdor> Baughn: ok, I think I'll need it
08:46:14 <Baughn> ImInYourMonad: Don't use runhaskell, use cabal.exe
08:46:19 <ImInYourMonad> Data.Packed, but it didnt complain on missing dependencies
08:47:16 <galdor> thank you for your help, now I can evaluate variables :)
08:47:38 <Baughn> galdor: newtype constructs a new type, but doesn't change the actual in-memory data layout; the type is purely a figment of the compiler's imagination. Of course, sometimes the optimizer converts data statements (ADTs) to newtypes..
08:47:49 <Baughn> galdor: (Not that you need to consider what the optimizer does. Much.)
08:47:54 <ImInYourMonad> where is cabal? and cabal install or cabal?
08:48:04 <ImInYourMonad> does cabal.exe come ready with 6.10.1
08:48:05 <ImInYourMonad> ?
08:48:21 <Baughn> It does not. It'll be part of the haskell platform, but that isn't quite ready yet. Until then.. hang on
08:48:46 <galdor> Baughn: so what's the difference between type and newtype ? it seems both of them are some kind of alias
08:49:30 <Baughn> galdor: type is a purely syntactic alias; if you say "type Foo = (Bar,Baz)", the documentation generators, errors and such will generally say Foo but the compiler always treats it as if it is (Bar,Baz)
08:49:42 <galdor> ok
08:49:52 <tromp_> newtype creates a new type, not interchangeable with old
08:50:04 <Baughn> galdor: newtype actually creates a new type, which allows you to define new instances and such on it. It also means any function that works on the old one won't work on the new one.
08:50:17 <galdor> ahh ok
08:50:24 <BONUS> think of type as giving something an alias
08:50:24 <galdor> now I understand
08:50:27 <Baughn> galdor: (But for convenience, it's possible to have every instance for the wrapped type work on the newtype)
08:50:29 <BONUS> like type String = [Char]
08:50:51 <BONUS> it doesnt matter if you write [Char] -> [Char] or String -> String or [Char] -> String, it's all the same
08:50:57 <galdor> so to use lookup on my variables, type is ok since itc interchangeable
08:51:07 <BONUS> and think of newtype as wrapping a type in another type
08:51:20 <Baughn> galdor: However, newtype does /not/ change the way the data is represented in memory; it won't make it lazier, or anything. That's also why you can't say "newtype Foo = Bar | Baz"; there's no type-tag added.
08:51:24 <BONUS> newtype MyInt = MyInt { getMyInt :: Int }
08:51:42 <BONUS> you can't use Int and MyInt interchangeable but you can unwrap the Int from a MyInt and use it then
08:52:10 <Baughn> galdor: data, meanwhile, does wrap the data in-memory; that's called lifting. It's possible for values inside an ADT (eg. type created by data) to be undefined without the whole thing being so, though that's /usually/ not an interesting difference
08:52:11 <galdor> you're really helpful :)
08:52:15 <BONUS> yeah, internally there's no "boxing" overhead
08:52:35 <galdor> I didn't really understand all of this until now
08:52:40 <BONUS> so usually if you have the need to have a data type with only one field, use a newtype
08:52:48 <BONUS> (and one constructor)
08:52:49 <Baughn> galdor: And meanwhile, the GHC optimizer does its level best to convert data to newtype wherever it can prove that won't affect semantics, which it usually can (if, indeed, it won't)
08:52:50 <tromp_> newtype is just like data D a = D a, but with no runtime overhead
08:53:08 <BONUS> tromp_: also it acts different on _|_
08:53:09 <Cheshire> that can't be right
08:53:24 <Cheshire> if it was an efficient version of data then there would be no point in it
08:53:31 <Cheshire> because data could just use the same optimization
08:53:34 <Baughn> Cheshire: It does actually affect semantics
08:53:49 <Baughn> Cheshire: data /does/ use the same optimization, but the compiler can't always prove doing so is the right thing to do
08:53:58 <Baughn> Plus, sometimes you explicitly want the different semantics
08:54:35 <galdor> ok, now gonna work on function evaluation
08:54:40 <Baughn> ImInYourMonad: Oh, sorry
08:54:50 <Baughn> ImInYourMonad: http://haskell.org/~duncan/cabal/ <-- Download cabal.exe from here
08:55:08 <johnbs> or http://www.haskell.org/cabal/download.html
08:55:10 <Baughn> ImInYourMonad: Then you can use cabal install <foo> to install arbitrary packages from hackage; it'll take care of dependencies itself
08:55:23 <Baughn> ImInYourMonad: Or just "cabal install" in any directory there's a .cabal file
08:56:40 <tromp_> also , newtype has different deriving behavior
08:57:14 <Baughn> True. newtype deriving /always/ works, even for custom typeclasses, since the compiler doesn't have to actually do anything; the same raw code will work on both types
08:57:35 <ImInYourMonad> setup.hs:3:0:
08:57:35 <ImInYourMonad>     Warning: In the use of `defaultUserHooks'
08:57:35 <ImInYourMonad>              (imported from Distribution.Simple):
08:57:35 <ImInYourMonad>              Deprecated: "Use simpleUserHooks or autoconfUserHooks, unless you n
08:57:35 <ImInYourMonad> eed Cabal-1.2
08:57:35 <ImInYourMonad>              compatibility in which case you must stick with defaultUserHooks"
08:57:37 <ImInYourMonad> Warning: defaultUserHooks in Setup script is deprecated.
08:57:39 <ImInYourMonad> Configuring OpenGL-2.2.1.1...
08:57:40 <olivierp> hi, does anyone know of a way to have a list of heterogeneous elements that are all instances of Eq, and compare them pairwise, without adding Typeable as a constraint along with Eq?
08:57:41 <ImInYourMonad> setup: sh: runGenProcess: does not exist (No such file or directory)
08:57:41 <lepassive> can I do something like putChar c >> hFlush stdout ??
08:57:43 <ImInYourMonad> oops
08:57:45 <ImInYourMonad> sorry
08:57:47 <Baughn> (Well, technically I think it wraps and unwraps the type, bt those are themselves no-ops, so..)
08:57:47 <ImInYourMonad> but what am i supposed to do there?
08:58:04 <Baughn> ImInYourMonad: Please don't paste anything that large
08:58:14 <Baughn> ImInYourMonad: Also, you see "sh: .. does not exist"
08:58:35 <byorgey> olivierp: you can't compare things with different types, even if they are both instances of Eq.  So I'm not sure what you mean by "compare them pairwise"
08:58:36 <ziman> olivierp, you can use existential types
08:58:37 <Baughn> ImInYourMonad: Though the error message is a bit.. awful; that's what I was talking about for windows packages. You need to install bash as well.
08:58:50 <Baughn> ImInYourMonad: I think you can use msys, or somethnig
08:58:56 <ziman> hm.
08:59:22 <ImInYourMonad> but i cant find cabal in bin, where is cabal.exe supposed to be? or i ahev to install it?
08:59:40 <Baughn> ImInYourMonad: You download it, then stick it somewhere in your PATH. Anywhere will do.
08:59:59 <tromp_> hmm, actually deriving is different from what I though
09:00:05 <ziman> i see. olivierp, sorry for the confusion.
09:00:08 * Baughn put it in c:/windows.. not that I can really recommend that
09:00:32 <tromp_> with newtype MyInt = MyInt Int deriving Show, print (MyInt 42) shows MyInt 42
09:00:33 <olivierp> byorgey, ziman: that's what I'm doing already (wrapping the elements in an existential type), but then I have to use cast to be able to compare them, which then makes me add the Typeable constraint that I don't like
09:00:51 <tromp_> I thought it would just show 42
09:00:56 * whpearson sometimes wishes that all functions that returned strings also returned the length of the returned string
09:01:14 <lepassive> by the way, should i call flush before or after calling "\b" ?
09:01:22 <Baughn> tromp_: That's actually standard deriving, not newtype deriving
09:01:41 <olivierp> byorgey: by compairing pairwise I meant return False if the type doesn't match, and the resut of == otherwise
09:01:41 <Baughn> tromp_: If it was the latter, it'd print 42. I don't think you can force that, though.
09:01:49 <tromp_> how is newtype MyInt = MyInt Int deriving Show not newtype deriving?
09:02:04 <Baughn> Well, deriving show works on data too. ;)
09:02:37 <tromp_> i thought it was same syntax, different meaning for newtype
09:02:39 <Baughn> tromp_: There's actually an explicit exception for Read and Show
09:02:47 <byorgey> olivierp: well, in that case, there's no avoiding the Typeable, since you need to do something with type information at run time.
09:02:57 <Baughn> tromp_: Try Monad ;)
09:03:23 <byorgey> olivierp: normally Haskell erases all type information during compilation.  Typeable is a way to reify the type information as values that can get passed around at runtime.
09:03:32 <olivierp> byorgey: I was hoping that maybe HList could help?
09:03:48 <DBAlex> Hi
09:03:49 <ImInYourMonad> anyone have an example of using hmidi ?
09:04:02 <ImInYourMonad> can it play mp3s?
09:04:17 <dmwit> Dang, dude, still haven't figured out how to play mp3s?
09:04:17 <olivierp> byorgey: that's what i understood yes... ideally i wouldn't need to cast anything
09:04:20 <byorgey> olivierp: that's a nice way to store heterogeneous lists, but it doesn't help.  You still have to have type information around at runtime to decide whether two given elements of the list have the same type, and hence can be compared with ==
09:04:56 <Baughn> ImInYourMonad: It does midis. Someone did experimentally write a (dog-slow) mp3 decoder in haskell, but currently I'd suggest calling out to mpg123 or mplayer if at all possible. ;)
09:04:57 <dmwit> ImInYourMonad: Did you go to Hackage like I suggested several times last night?
09:05:04 <Baughn> ImInYourMonad: mplayer has a convenient slave mode
09:05:07 <trygvis> @hoogle cron
09:05:07 <lambdabot> Text.XHtml.Frameset acronym :: Html -> Html
09:05:07 <lambdabot> Text.XHtml.Strict acronym :: Html -> Html
09:05:07 <lambdabot> Text.XHtml.Transitional acronym :: Html -> Html
09:05:26 <trygvis> hm, anyone know of a library that schedule task at cron like intervals?
09:05:35 <olivierp> byorgey: right, that makes sense... it's just really annoying that (Eq a, Show a) => Num a but not (Eq a, Show a, Typeable a) => Num a
09:05:39 <trygvis> something like quartz you have in java
09:05:41 <DBAlex> http://pastebin.com/m77699aa4 < I have this very simple function munch, it checks if the current 2 characters are the same, if they are then it continues, if they are not I need it to return the string up to the current position
09:05:45 <DBAlex> I know I don't need to return ys
09:05:50 <Baughn> tromp_: Cron/crontab?
09:06:02 <Baughn> trygvis: Er, cron/crontab? Or more like timeouts?
09:06:04 <DBAlex> I just don't know how to drop until the length of the current position
09:06:07 <byorgey> olivierp: I don't see how that would help...
09:06:13 <olivierp> byorgey: even though all instances of Num seem to be Typeable as well
09:06:16 <DBAlex> thats probably wrong anyway (i'm thinking imperative if I do that)
09:06:17 <quicksilver> trygvis: forkIO task where task = do {doSomething; threadDelay 3600000000; task}
09:06:39 <byorgey> olivierp: yes, but do you want to *require* that *any* instance of Num must be Typeable?
09:06:39 <DBAlex> anyone help me?
09:06:42 <glguy> DBAlex, you don't need [x] == [y]
09:06:44 <glguy> x==y
09:06:45 <glguy> will do
09:06:46 <byorgey> olivierp: Num has too many constraints as it is =)
09:06:49 <trygvis> like crontab, just running within my process
09:06:52 <dmwit> DBAlex: I'm not sure I understand your question.
09:07:00 <DBAlex> glguy: ok thanks
09:07:04 <ImInYourMonad> less convenient on windows perhaps?
09:07:20 <glguy> DBAlex, you want to return the string of all the matches?
09:07:24 <olivierp> byorgey: well then I'd want more constraints on the numeric literals
09:07:24 <DBAlex> dmwit: I need to compare the string until the 2 chars (x and y) don't match
09:07:36 <DBAlex> when they don't match I need to return the string up until that point
09:07:45 <DBAlex> glguy: ^ read above
09:07:57 <dmwit> DBAlex: Looks like you're doing fine to me.
09:08:04 <glguy> munch (x:y:ys) | x == y = x : y : munch ys | otherwise = []
09:08:08 <DBAlex> dmwit: but "else ys" is wrong
09:08:12 <olivierp> byorgey: 42:: (Num a, Typeable a, Show a) => a would be just fine
09:08:33 <DBAlex> glguy: hmm ok
09:09:04 <dmwit> More likely
09:09:15 <dmwit> munch (x:y:ys) | x == y = x : munch (y:ys) | otherwise = []
09:09:58 <tromp_> what's a nice nonrecursive definition?
09:10:01 <byorgey> it depends.  DBAlex, should munch [2,2,3,3,4,6] = [2,2], or [2,2,3,3]?
09:10:14 <quicksilver> olivierp: I don't see why that would help you.
09:10:17 <glguy> munch (x:xs) = takeWhile (==x) xs
09:10:24 <dons> ?yow
09:10:24 <lambdabot> How's it going in those MODULAR LOVE UNITS??
09:10:26 <quicksilver> olivierp: you surely aren't storing higher rank polymorphic literals?
09:10:26 <dmwit> glguy: Much better.
09:10:31 <dmwit> glguy: Wait, no.
09:10:37 <dmwit> glguy: Wait, yes.
09:10:38 <dmwit> =P
09:10:41 <DBAlex> erm ok
09:10:43 <byorgey> hey dons =)
09:10:43 * glguy continues to wait
09:10:47 <quicksilver> olivierp: what you actually store is always a concrete type, and all the concrete types you use implement Typeable.
09:10:55 <DBAlex> my brain only works with imperative languages
09:11:04 <DBAlex> I think
09:11:05 <DBAlex> :(
09:11:08 <olivierp> quicksilver: right, except for Num literals
09:11:10 <byorgey> DBAlex: that can be fixed. =)
09:11:17 <dmwit> With an icepick!
09:11:18 <glguy> DBAlex, dont worry, youll recover
09:11:20 <byorgey> just takes a while...
09:11:29 <DBAlex> I try to think of functional programming like some machine just with 2 outputs
09:11:29 <byorgey> dmwit!
09:11:31 <olivierp> quicksilver: they're annoying
09:11:42 * dmwit hides from the police
09:11:48 <DBAlex> i'm constantly thinking that the output should match the input (if its recursive)
09:11:56 <tromp_> now find a nice definition for commonPrefix
09:12:16 <DBAlex> *not 2 outputs, 1 input 1 output
09:12:38 <byorgey> DBAlex: ah, ok, I wondered if that's what you meant =)
09:12:51 <quicksilver> olivierp: you do realise that all they were doing before is defaulting to Integer, right?
09:12:51 <byorgey> DBAlex: sure, everything is a function
09:12:55 <olivierp> quicksilver: my functions end up being polymorphic with the (Eq a, Typeable a) constraint, and hence passing 42 as an argument fails
09:13:05 <dons> heya byorgey
09:13:10 <dons> glguy: coming in to work?
09:13:20 <quicksilver> olivierp: it's not that it doesn't work any more
09:13:29 <byorgey> DBAlex: and in fact it's true that all Haskell functions only take one input.  functions with types like  Int -> Int -> Int  actually take a single Int argument and return another function =)
09:13:32 <quicksilver> olivierp: it's that without hte Typeable constraint, it defaulted 42 to Integer
09:13:44 <quicksilver> olivierp: with the Typeable constraint, defaulting is turned off.
09:13:51 <quicksilver> so it's ambiguous
09:14:21 <olivierp> quicksilver: ok, but isn't that a bit irrelevant for the type system?
09:14:29 <DBAlex> byorgey: yup!
09:14:31 <tromp_> > let (a,b) = ("hello","here") in zipWith const a $ takeWhile id $ zipWith (==) a b
09:14:33 <lambdabot>   "he"
09:15:04 <tromp_> still a little ugly...
09:15:13 <dmwit> zipWith const -> map fst
09:15:17 <dmwit> or map snd
09:15:21 <olivierp> quicksilver: without Typeable a, I ask for a Num a => a argument and I get one, everything's fine (and it could be a Float)
09:15:28 <quicksilver> olivierp: you don't.
09:15:43 <quicksilver> olivierp: you don't get (Num a => a) as an argument
09:15:44 <dmwit> err
09:15:50 <quicksilver> olivierp: you get either Integer, or Float, or whatever.
09:16:00 <tromp_> :t zipWith const
09:16:01 <dmwit> > map fst . takeWhile (==) $ zip "hello" "here"
09:16:02 <lambdabot> forall a b. [a] -> [b] -> [a]
09:16:02 <quicksilver> olivierp: if you use an unqualified literal like '42' it defaults to Integer.
09:16:03 <lambdabot>   Couldn't match expected type `Bool'
09:16:05 <tromp_> :t map fst
09:16:06 <lambdabot> forall a b. [(a, b)] -> [a]
09:16:09 <dmwit> > map fst . takeWhile (uncurry (==)) $ zip "hello" "here"
09:16:11 <lambdabot>   "he"
09:16:13 <DBAlex> glguy: is there a way to modify my original function?
09:16:18 <DBAlex> http://pastebin.com/m77699aa4
09:16:19 <quicksilver> olivierp: obviously if you use a value with a concrete type no defaulting happens.
09:16:21 <dmwit> tromp_: Is that a little better?
09:16:26 <DBAlex> because only the "else ys" is wrong
09:16:35 <quicksilver> olivierp: you never actually pass a 'polymorphic value' of type (Num a => a)
09:16:36 <DBAlex> should it be "else x : y : ys" ?
09:16:46 <glguy> DBAlex, both the then and else branches are wrong
09:16:47 <dmwit> DBAlex: Of course, guards are totally equivalent to if/then/else.
09:16:52 <tromp_> yes, dmwit
09:17:11 <olivierp> quiksilver: yes yes, I understand that these only exist in the type system
09:17:20 <dmwit> ?hoogle Eq a => [a] -> [a] -> [a]
09:17:20 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
09:17:20 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
09:17:20 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
09:17:31 <DBAlex> glyguy: ok
09:17:43 <olivierp> quiksilver: so is there a reasonable way to get the defaulting back? since Int is an instance of Typeable?
09:17:49 <DBAlex> but how do I return the string up until that point?
09:17:52 <DBAlex> or is there no way?
09:17:52 <glguy> DBAlex, to be clear, what is an example input/output pair?
09:18:05 <skorpan> @pl \t -> toTok t `elem` syms
09:18:06 <lambdabot> (`elem` syms) . toTok
09:18:07 <glguy> DBAlex, you don't, you reconstruct the string as you go
09:18:15 <DBAlex> "aaaaaaaaaaaab" and "aaaaaaaaaaaa"
09:18:19 <DBAlex> ah ok
09:18:26 <dmwit> > stripPrefix "he" "hello"
09:18:27 <lambdabot>   Just "llo"
09:18:30 <dmwit> > stripPrefix "here" "hello"
09:18:32 <lambdabot>   Nothing
09:18:34 <dmwit> =/
09:18:47 <quicksilver> olivierp: I don't think so. defaulting is a hack design to work around how inconvenient using numeric literals would be without it :(
09:18:55 <quicksilver> olivierp: I don't think it's a hack you can extend.
09:19:54 <dons> anyone who's not read benl's progress on scaling GHC parallelism on the sparc should check this out. it's a great read, http://www.reddit.com/r/programming/comments/80t4o/benchmarking_haskell_parallelism_on_the_sparc_t2/
09:21:05 <quicksilver> dons: it's interesting how much slower the T2 is than the intel chips in the -N1 case
09:21:20 <quicksilver> dons: do you have any idea if that's due to poor code gen, or hardware differences?
09:21:30 <dons> may be the codegen still.
09:21:41 <pejo> quicksilver, isn't the T2 very simple?
09:22:46 <quicksilver> pejo: I believe it is, but I am sufficiently unfamiliar with modern CPUs that I don't know what kind of difference ou'd expect between it an a core2
09:22:54 <Baughn> Lower clock-rate, lower efficiency per cycle too
09:23:07 <quicksilver> clearly the core2 is much cleverer in terms of branch prediction and pipelining
09:23:19 <quicksilver> so I guess the core2 will do simple arithmetic much faster
09:23:33 <quicksilver> but things like memory load instructions make a big difference
09:23:34 <Baughn> I certainly wouldn't expect anyone in their right mind to go to the heroic efforts the x86 people have, but then they should be able to have a lot more cores
09:23:50 <quicksilver> and I don't know enough to compare
09:23:54 <Baughn> Except.. "8 threads per core" means what, exactly?
09:24:20 <quicksilver> Baughn: the ability to decode and process 8 opcodes at once, I think.
09:24:33 <tromp_> no
09:24:55 <tromp_> shld be hardware support for switching threads on cache miss
09:25:04 <repnop> quicksilver: hmm hasn't intel chips had alu clocked 2x since p4 netburst 533Mhz FSB?
09:25:16 <repnop> or they remove that when switching to core
09:25:36 <trygvis> how do I get the text value from a Text.Atom.Feed.TextContent?
09:26:40 <repnop> ah ignore me, talking T2 versus core 2  i see
09:27:16 <Baughn> tromp_: Ah, so the same stuff modern GPUs do?
09:27:33 <tromp_> didnt know gpus did that:(
09:27:35 <olivierp> Baughn, tromp_: it's just like hyperthreading
09:27:45 <olivierp> masking memory latency
09:27:46 <tromp_> off to lunch
09:28:10 <beelsebo_> what surprises me is that the netburst P4 apparently gets as much gain from hyperthreading as the Core2 gets from a real second core
09:28:11 <Baughn> olivierp: IIRC, hyperthreading actually attempts to run multiple threads /simultaneously/, spreading execution units between the threads
09:28:23 <olivierp> well not quite
09:28:25 <beelsebo_> hopefully that will still apply with Core i7
09:28:32 <Baughn> beelsebo_: Only on somewhat artificial loads
09:28:37 <beelsebo_> Baughn: true true
09:28:53 <olivierp> there is still only one real instruction executed at a time
09:28:57 <Baughn> A second thread that does the same sort of thing as the first one won't be any faster
09:29:17 <Baughn> olivierp: Now, *that* hasn't been true since superscalar execution was implemented. :P
09:29:26 <beelsebo_> Baughn: but surely that's exactly what we're seeing here
09:29:31 <beelsebo_> a second thread doing identical work
09:29:44 <beelsebo_> (hence my surprise)
09:29:59 <Baughn> beelsebo_: You can still have some wins by covering up memory latency, I suppose
09:30:11 <olivierp> well ok, you do funny things in the middle, but issues are made sequential after reardering anyway
09:30:11 <beelsebo_> true true
09:30:16 <Baughn> The core 2 does that on /single/ threads
09:30:51 <Baughn> Or perhaps I should say, the decoding circuitry turns the single thread into a tree of threads
09:30:59 <DBAlex> glguy: could you write munch (x:y:ys) | x == y = x : y : munch ys | otherwise = []
09:30:59 <DBAlex>  on more than one line so its more readable?
09:31:03 <DBAlex> you can pm me if u want
09:31:05 <DBAlex> thanks :(
09:31:29 <glguy> DBAlex, if you don't put the 'y' back in the argument
09:31:37 <glguy> then you won't be matching on things
09:31:42 <glguy> that start with the same value
09:31:58 <DBAlex> can that function be written on more than one line tho?
09:32:02 <johnbs> sure
09:32:09 <johnbs> linebreak before each |
09:32:13 <DBAlex> ok
09:32:43 <DBAlex> johnbs: Reading file "/usr/local/share/hugs/lib/Prelude.hs":
09:32:43 <DBAlex> Reading file "cwkstart.hs":
09:32:43 <DBAlex> Parsing
09:32:43 <DBAlex> ERROR "cwkstart.hs" (line 31): Syntax error in declaration (unexpected `;', possibly due to bad layout)
09:33:25 <johnbs> indent the |'s too
09:33:30 <DBAlex> ok
09:33:31 <DBAlex> brb
09:33:50 <glguy> DBAlex, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1826#a1826
09:44:03 <HugoDaniel> who updates the twitter feed of "reddit_haskell" ?
09:44:20 <HugoDaniel> i find it a very interesting feed :)
09:45:08 <pumpkin_> it's probably a script?
09:45:18 <HugoDaniel> hmm yes indeed
09:46:05 <HugoDaniel> i have just read this blog post about a wannabe erlang or haskell coder: http://yatuc.com/uvu and found it very interesting
09:48:58 <bremner> "Erlang is really good at Erlang-style concurrency"
09:49:42 <FalconNL> Can anyone tell me the accepted way of fixing a package on hackage that doesn't work with cabal? The package in question is called pointfree. It was last maintained in 2007 and there is no contact information for the maintainer. The problem is easily fixed with three minor edits to the .cabal file (at least, that solves the build problems for the manual installation. I assume it works for...
09:49:43 <FalconNL> ...cabal as well). Do I 1) Upload the fix as a new version of the pointfree package 2) Create a new package pointfree-cabalized 3) Do something else?
09:50:37 <roconnor> FalconNL: I've uploaded bugfixes directly to cabal in the past, for what that is worth
09:51:11 <roconnor> FalconNL: and it sounds like you aren't even touching the code
09:51:11 <ImInYourMonad> does SPJ only work on Haskell?
09:51:24 <FalconNL> roconnor: so same package, new version?
09:51:25 <dcoutts> FalconNL: generally the procedure is to try to contact the maintainer, then announce on the cafe and libs list that you plan to take over maintenance if the maintainer cannot be found, then if people think it's ok then you do so.
09:52:11 <dons> bos: http://aur.archlinux.org/packages.php?ID=24268  ++ http://aur.archlinux.org/packages.php?ID=24269
09:52:17 <dons> haskell-tex + haskell-text-icu
09:52:30 <dcoutts> :-)
09:53:06 <pumpkin_> yay, conal is following me
09:53:46 <conal> pumpkin_: oddly, i had to hit Follow several times before it worked.
09:53:52 <pumpkin_> :o
09:54:01 <pumpkin_> twitter fails again!
09:54:18 <bos> dons: nice!
09:54:21 <roconnor> dcoutts: what if FalconNL doesn't want to be maintainer?
09:54:33 <roconnor> FalconNL: that's what I did.
09:55:00 <dcoutts> roconnor: then he should find the maintainer, if necessary by emailing the mailing lists and Ross to find who uploaded the package.
09:56:34 <FalconNL> For what it's worth, the Author is listed as Thomas Jger but it was uploaded by FelixMartini. Not sure if it's a different person or not, but the names would seem to suggest so.
09:59:26 <roconnor> FalconNL: ah, this is the point-free that lambdabot has.  No wonder that names seemed familiar.
09:59:50 <roconnor> that name
10:00:09 <FalconNL> roconnor: yep, but with the major advantage that it actually works on windows. I discovered the package today.
10:00:26 <ski_> Thomas Jger is TheHunter, iirc
10:01:11 <ehird> http://www.serpentine.com/blog/2009/02/27/finally-fast-unicode-support-for-haskell/
10:01:14 <ehird> love
10:03:37 <ski_> yes, Haskell_user_locations comfirms this
10:04:37 <ski_> FalconNL : according to NickServ, TheHunter was last seen 2009-01-28
10:04:44 <HugoDaniel> my monads are mostly pure...
10:04:58 <ski_> meaning ?
10:05:21 <HugoDaniel> i dont know what that means :/
10:05:40 <lilac> mostly pure == only a little bit of unsafePerformOpenHeartSurgery?
10:05:47 <ImInYourMonad> how can I elegantly say: take the head oif not null?
10:05:57 <lilac> take 1?
10:06:02 <ski_> ("mostly unique" or "mostly dead" could be understandable .. but "mostly pure" i'm not sure about)
10:06:16 <lilac> > map (take 1) ["", "a", "ab", "abc"]
10:06:18 <lambdabot>   ["","a","a","a"]
10:06:18 <HugoDaniel> so i guess they are all pure
10:06:42 <ehird> ImInYourMonad: and the result for []?
10:06:49 <ImInYourMonad> (filter (not . null) . map head)
10:06:54 <int-e> > "" == []
10:06:55 <lambdabot>   True
10:07:10 <ehird> @pl (\f -> filter (not . f))
10:07:10 <lambdabot> filter . (not .)
10:07:12 <ski_> > (maybeToList . listToMaybe) `map` inits "abc"
10:07:14 <lambdabot>   ["","a","a","a"]
10:07:17 <Alpounet> http://jpmoresmau.blogspot.com/2009/02/high-level-gui-library-for-haskell.html
10:07:24 <lilac> ImInYourMonad: either "take 1" or listToMaybe
10:07:54 <HugoDaniel> these high level gui's are quite the rage now...
10:08:05 <dons> someone needs to do a survey
10:08:05 <mopped> can somebody explain to me what @pl is?
10:08:13 <ski_> @help pl
10:08:13 <lambdabot> pointless <expr>. Play with pointfree code.
10:08:15 <ehird> removes points.
10:08:18 <ehird> @pl (\a b -> a + b)
10:08:18 <lambdabot> (+)
10:08:19 <ski_> `pl' is pointless
10:08:20 <pumpkin_> bos: does Data.Text support output to handles somehow?
10:08:22 <ehird> points are variables
10:08:23 <mopped> I don't know what points are
10:08:25 <ehird> essentially
10:08:34 <ehird> @pl (\f g h x -> f (g x) (h x))
10:08:34 <lambdabot> liftM2
10:08:39 <lilac> mopped: "pointless" or "point-free" effectively transforms lambdas into combinators
10:08:48 <ehird> @pl (\x y z -> x y y z z (x z))
10:08:48 <lambdabot> flip =<< (ap .) . flip flip id . (ap .) . join
10:08:55 <mopped> does pl calculate it via an algorithm?
10:09:01 <ImInYourMonad> , (filter (not . null) . map head) [[1,2,3],[]]
10:09:04 <ImInYourMonad> > (filter (not . null) . map head) [[1,2,3],[]]
10:09:04 <ehird> mopped: no, faery dust
10:09:05 <lambdabot>       No instance for (Num [a])
10:09:05 <lambdabot>        arising from the literal `1' at <inter...
10:09:06 <lunabot>  luna: No instance for (GHC.Num.Num [a])
10:09:06 <ddarius> mopped: @pl is a compiler to combinators.
10:09:10 <ehird> of course it uses an algorithm :P
10:09:18 <lilac> mopped: what other options are there, other than an algorithm? :)
10:09:22 <mopped> true
10:09:25 <int-e> @pl \a b x y z -> a (b (x y) z)
10:09:25 <lambdabot> (. (.)) . (.) . (.) . (.)
10:09:27 <Alpounet> external program ? :-p
10:09:28 <mopped> Is there an advantage of pointfree?
10:09:34 <ehird> mopped: sometimes, it's cleaner
10:09:35 <ImInYourMonad> > map (\x -> take 1 x) [[1,2,3],[]]
10:09:35 <ehird> other times not
10:09:36 <lambdabot>   [[1],[]]
10:09:41 <ehird> for example
10:09:45 <ski_> lilac : using external randomness or something ?
10:09:51 <ehird> foo x = bar fdf see x
10:09:56 <ehird> @pl (\x -> bar fdf see x)
10:09:56 <lambdabot> bar fdf see
10:09:58 <lilac> i suppose it could text someone with a black belt in haskell and ask them to do it
10:10:03 <ehird> so foo = bar fdf see is clearer there
10:10:14 <HugoDaniel> i like point free as long as it helps . me . compose . things
10:10:15 <Alpounet> lilac, heh
10:10:19 <ddarius> lilac: 'better have unlimited text messages.
10:10:26 * ski_ doesn't find `bar fdf see' very clear ..
10:10:46 <ehird> ski_: :-D
10:10:56 <lilac> sometimes @pl will give you code with a more general type. in such cases, it can be an indication that your code can (and maybe should) be generalized
10:11:13 <bos> pumpkin_: via the ByteString IO functions
10:11:22 <ehird> ehird: @pl (\x y z -> x y y z z (x z))
10:11:22 <ehird> 18:08 lambdabot: flip =<< (ap .) . flip flip id . (ap .) . join
10:11:25 <ehird> or _less_ general
10:11:42 <lilac> @type (\x y z -> x y y z z (x z))
10:11:43 <lambdabot>     Occurs check: cannot construct the infinite type:
10:11:43 <lambdabot>       t = t2 -> t2 -> t2 -> t -> t1
10:11:43 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:11:54 <lilac> @type flip =<< (ap .) . flip flip id . (ap .) . join
10:11:55 <ehird> heh
10:11:56 <lambdabot>     Occurs check: cannot construct the infinite type:
10:11:56 <lambdabot>       a = a1 -> a1 -> a1 -> a -> b
10:11:56 <lambdabot>     Probable cause: `.' is applied to too few arguments
10:12:12 <ehird> @pl (\x y -> x (y x))
10:12:12 <lambdabot> ap (.) (flip id)
10:12:14 <lilac> ehird: i tend to think all type errors are equally general ;-)
10:12:18 <mopped> @pl zebra f g [] = []; zebra f g (x:xs) = (f x):(zebra g f xs)
10:12:18 <lambdabot> (line 1, column 14):
10:12:18 <lambdabot> unexpected "="
10:12:18 <lambdabot> expecting variable, "(", operator or end of input
10:12:19 <ehird> :t ap (.) (flip id)
10:12:20 <lambdabot> forall c c1. (c1 -> c) -> ((c1 -> c) -> c1) -> c
10:12:20 <ehird> lilac: :D
10:12:22 <mopped> only works on lambdas?
10:12:27 <ehird> mopped: yep
10:12:34 <ehird> and expressions
10:12:36 <ehird> @pl id id
10:12:36 <lambdabot> id
10:12:47 <ddarius> @pl flip f x y = f y x
10:12:47 <lambdabot> flip = flip
10:12:49 <lilac> not just those but also...
10:12:50 <lilac> @pl foo x (y:ys) = y:foo x ys
10:12:50 <lambdabot> foo = fix (flip flip tail . (ap .) . flip flip head . (((.) . flip ((.) . (:))) .))
10:12:53 <ehird> :t ap (.) (flip id) succ
10:12:54 <lambdabot> forall c. (Enum c) => ((c -> c) -> c) -> c
10:12:57 <lilac> pattern matching, recursion, ...
10:13:02 <ehird> > ap (.) (flip id) succ fix
10:13:04 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
10:13:07 <lilac> @type fix (flip flip tail . (ap .) . flip flip head . (((.) . flip ((.) . (:))) .))
10:13:08 <lambdabot> forall b a. a -> [b] -> [b]
10:13:10 <ehird> heh
10:13:52 <HugoDaniel> just bought two real world haskell copies this month, one for me the other to evangelize a friend
10:13:55 <lilac> > ap (.) (flip id) succ fix :: Nat
10:13:56 <lambdabot>   Not in scope: type constructor or class `Nat'
10:14:10 <BONUS> HugoDaniel: will you be going door to door selling copies? hahaha
10:14:17 <HugoDaniel> :D
10:14:29 <lilac> HugoDaniel: i only bought one for a friend (i don't need RWH, i have #haskell ;-) )
10:14:30 <BONUS> yes hello mam do you know about our savior Haskell Curry?
10:14:35 <sw17ch> @pl \a b c d -> a b (c d)
10:14:35 <lambdabot> ((.) .)
10:14:37 <HugoDaniel> :D
10:14:49 <lilac> @unpl fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:14:49 <lambdabot> fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:14:51 <BONUS> let haskell into your heart. haha ok i'll stop now
10:14:58 <ehird> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:15:00 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f, Functor f1) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
10:15:04 <lilac> @unpl (.) (.) (.) (.) (.) (.) (.) (.) (.) (.)
10:15:04 <lambdabot> (\ r u x z aa -> r (u x) (z aa))
10:15:09 <sw17ch> the only thing i want let into my heart is blood
10:15:14 <HugoDaniel> i read it mostly online or a wget'ed offline copy
10:15:17 * lilac has a fmappifier kicking around somewhere
10:15:19 <lilac> it's good stuff
10:15:20 <ehird> @pl fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:15:20 <lambdabot> fmap (fmap (fmap fmap)) fmap
10:15:23 <ehird> haha
10:15:27 <ehird> fmap calculus
10:15:40 <mopped> @src fmap
10:15:40 <lambdabot> Source not found. It can only be attributed to human error.
10:15:51 <ehird> :t fmap
10:15:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:15:53 <tromp_> :t fmap
10:15:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:15:57 <ehird> fmap on functions is (.)
10:15:59 <ehird> :t (.)
10:16:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:16:01 <whpearson_> @pl fmap fmap fmap fmap
10:16:01 <lambdabot> fmap (fmap fmap)
10:16:05 <ehird> see the likeness?
10:16:11 <ehird> @pl fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
10:16:11 <lambdabot> fmap fmap (fmap fmap fmap)
10:16:23 <HugoDaniel> you guys are totally crazy
10:16:28 <beelsebo_> @unpl fmap fmap fmap sequence fmap
10:16:28 <lambdabot> fmap fmap fmap sequence fmap
10:16:35 <beelsebo_> @pl fmap fmap fmap sequence fmap
10:16:35 <lambdabot> fmap (fmap sequence) fmap
10:16:37 <HugoDaniel> haskell horror!
10:16:39 <beelsebo_> lame
10:16:39 <BONUS> > (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) zip (map (*2)) [1,2,6] (filter (>4)) [2,5,9]
10:16:40 <ImInYourMonad> is there no function updateAt for lists?
10:16:40 <lambdabot>   [(2,5),(4,9)]
10:16:42 <Baughn> @pl \a b (c, d) e -> b a d fmap e
10:16:42 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . flip flip fmap . (flip .) . flip id
10:16:50 <pumpkin_> oh no, beelsebob lost his B
10:16:56 <ddarius> ImInYourMonad: No, there isn't.
10:17:01 <beelsebo_> ImInYourMonad: no  because if you're using it, you're using the wrong data structure
10:17:08 <Baughn> ImInYourMonad: Look at Data.Seq
10:17:19 <Baughn> Er, Data.Sequence
10:17:38 <HugoDaniel> oh well, its back to vim for me, bye
10:18:26 <tromp_> updateAt i x l = let (la,y:lb) = splitAt i l in la++x:lb
10:18:42 <ehird> > succ . [1,2,3]
10:18:43 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
10:19:00 <sw17ch> seriously, i can't write in other languages any more
10:19:10 <ehird> @pl fmap . fmap . fmap fmap fmap fmap (fmap . fmap fmap) . fmap fmap fmap
10:19:10 <lambdabot> fmap . fmap . fmap (fmap fmap) (fmap . fmap fmap) . fmap fmap fmap
10:19:20 <ehird> @. type pl fmap . fmap . fmap fmap fmap fmap (fmap . fmap fmap) . fmap fmap fmap
10:19:22 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a (f2 :: * -> *) a1 (f3 :: * -> *) a2 b (f4 :: * -> *). (Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => (a2 -> b) -> f (f1 (a -> a1 -> f4 a2)) -> f
10:19:22 <lambdabot> (f1 (f2 a -> f2 (f3 a1 -> f3 (f4 b))))
10:19:23 <sw17ch> every time I add a new piece of state to the program, i get really nervous about trying to manage who can touch it
10:19:24 <ski_> (if you must do an `updateAt', please at least pass an updating function, instead of just throwing away the old value ..)
10:19:25 <ehird> haha
10:19:53 <ddarius> sw17ch: You should have been like that before Haskell.
10:20:14 <Baughn> @pl \a b (c, d) e -> b a d fmap e e a
10:20:15 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (flip =<< ((flip . (flip .)) .) . flip flip id . ((flip . (ap .)) .) . flip flip fmap . (flip .) . flip id)
10:20:35 <sw17ch> ddarius: You can't really expect me to have known there was a better way before learning Haskell. :)
10:21:09 <ddarius> sw17ch: Controlling who has access to state is considered good practice in practically every language.
10:21:17 <sw17ch> ddarius: oh, yes. that i understand
10:21:20 <ehird> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g
10:21:23 <lambdabot> (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .)
10:21:23 <lambdabot> .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
10:21:23 <lambdabot> (((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((
10:21:23 <lambdabot> ((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .)
10:21:26 <lambdabot> .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .)
10:21:28 <sw17ch> but merely creating a new piece of state never bothered me
10:21:29 <lambdabot> [65 @more lines]
10:21:30 <sw17ch> now it does
10:21:31 <lambdabot> optimization suspended, use @pl-resume to continue.
10:21:35 <beelsebo_> >.<
10:21:42 <beelsebo_> I broke lambdabot doing that last time
10:21:45 <beelsebo_> @pl-resume
10:21:51 <lambdabot> (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .)
10:21:51 <Baughn> Nooo
10:21:51 <lambdabot> .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
10:21:51 <lambdabot> (((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((
10:21:52 <lambdabot> ((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .)
10:21:54 <lambdabot> .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .)
10:21:55 <Baughn> This will never finish
10:21:56 <glguy> ehird, quit it
10:21:57 <lambdabot> [65 @more lines]
10:21:58 <ehird> :DDDD
10:21:59 <lambdabot> optimization suspended, use @pl-resume to continue.
10:22:00 <ehird> oh god
10:22:02 <ehird> glguy: hey!
10:22:04 <ehird> that was beelsebo_
10:22:06 <ehird> who said pl-resume
10:22:08 <beelsebo_> >.>
10:22:15 <pumpkin_> concat [ 1 , [2,3], [[4]] ] = [1,2,3,4] o.O (http://codetojoy.blogspot.com/2009/02/brilliance-of-type-signatures-in.html)
10:22:22 <ddarius> sw17ch: Yes, Haskell should have changed it so that now you get nervous about adding state even if only you have access to it.
10:22:25 <Baughn> @pl \a -> a
10:22:25 <lambdabot> id
10:22:40 <sw17ch> ddarius: because, inevitably, some one else will soon ahve access to it
10:22:48 <Baughn> Simple. Elegant. The zen of pointsfree code.
10:22:51 <sw17ch> because it's more convenient just to add a new global extern...
10:22:56 <sw17ch> *sigh*
10:23:02 <arjanb> i think someone should limit lambdabot to one line for each action
10:23:03 <lambdabot> arjanb: You have 1 new message. '/msg lambdabot @messages' to read it.
10:23:12 * glguy was 17seconds lagged
10:23:14 <ehird> arjanb: yep...
10:23:19 <ehird> glguy: blame beelsebo_ :P
10:23:27 <glguy> you are just as guilty
10:24:45 <Baughn> @pl a -> a a a a a
10:24:45 <lambdabot> (line 1, column 3):
10:24:45 <lambdabot> unexpected ">" or "-"
10:24:45 <lambdabot> expecting variable, "(", operator or end of input
10:24:49 <pumpkin_> beware of the whooping stick
10:24:50 <Baughn> @pl \a -> a a a a a
10:24:51 <lambdabot> join (join (join (join id)))
10:25:09 <pumpkin_> isn't that one impossible?
10:25:12 <Baughn> Of course. Neat!
10:25:13 <ehird> yes
10:25:15 <Baughn> pumpkin_: ..well, possibly
10:25:22 <pumpkin_> possibly impossible?
10:25:25 <pumpkin_> or impossibly possible
10:25:31 <Baughn> Impossibly impossible
10:25:44 <pumpkin_> double negation??
10:25:50 <ehird> 18:22 pumpkin_: concat [ 1 , [2,3], [[4]] ] = [1,2,3,4] o.O (http://codetojoy.blogspot.com/2009/02/brilliance-of-type-signatures-in.html)
10:25:51 <ehird> lol wut
10:26:06 <pumpkin_> just one of the examples from that blog post :)
10:26:19 <ehird> i know
10:26:30 <ddarius> I blame lisp.
10:28:40 * whpearson_ is putting off evangelising haskell until he has written something fairly chunky in it
10:31:33 <whpearson_> I mean, it seems pretty awesome at the moment, but I don't truly understand it enough to write coherently about it.
10:32:00 <ddarius> whpearson_: Apparently, that hasn't stopped anyone else.
10:32:39 <Cheshire> lol
10:32:49 <Gracenotes> "Haskell does not support type coercion." comment: Wrong
10:33:00 <Gracenotes> well, it's certainly unsafe...
10:33:15 <Twey> It... doesn't, really
10:33:15 <Cheshire> Gracenotes, fromIntegral is a coercian
10:33:18 <Cheshire> coercion*
10:33:22 <Twey> Er, implicitly
10:33:35 <Cheshire> @let int = fromIntegral
10:33:39 <Cheshire> > (int)3
10:33:41 <lambdabot>  Defined.
10:33:42 <lambdabot>   mueval: Prelude.read: no parse
10:33:42 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
10:34:02 <Gracenotes> Cheshire: that's different. There's no such thing as a function Int a => a -> b
10:34:07 <Gracenotes> *Integral
10:34:13 <Gracenotes> wait, what
10:34:15 <Cheshire> Gracenotes, what's it different to?
10:34:16 <Gracenotes> @type fromIntegral
10:34:20 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:35:19 <Gracenotes> the point is, it's not a coercion; it doesn't happen behind the scenes converting a specific number type to another specific number type
10:35:24 <newsham> > let int x = (fromIntegral x :: Int) in (int) 3
10:35:27 <lambdabot>   3
10:36:12 <Gracenotes> once the concrete type is determined, there's no non-explicit way to change it :)
10:36:13 <newsham> grace: you're saying that type coercion only includes implicit type coercion?
10:36:25 <Cheshire> Gracenotes, Yuo are describing coercive subtyping
10:36:28 <chrisdone> what does "coerce" mean?
10:36:38 <Gracenotes> I'm taking coerce to mean implicit, yes.
10:36:46 <Cheshire> Gracenotes, it does not mean that
10:36:55 <chrisdone> what does it mean?
10:37:11 <newsham> "The term for implicit type conversion is coercion. The most common form of explicit type conversion is known as casting." -wikipedia.
10:37:26 <newsham> hrmm,, interesting, i had always considered explicit and implicit conversion to be coercion
10:38:20 <Gracenotes> Haskell does support polymorphic coercion, instead of ad-hoc that some typeclasses can provide, but it's not safe (hence the unsafe prefix)
10:38:35 <Cheshire> Gracenotes, no ..
10:38:54 <Cheshire> unsafeCoerce isn't 'polymorphic coercion'
10:38:55 <Gracenotes> parametrically polymorphic, that is >_>
10:39:04 <mathijs> Hi all, is there a reason Arrows aren't really mentioned in RWH? some functions are told to be in Control.Arrow, but the subject itself isn't touched. Are they just not generally useful? or are they too advanced to mention? or is there a different reason?
10:39:13 <roconnor> nor in unsafeCoerce Haskell
10:39:15 <roconnor> nor is
10:39:23 <newsham> mathijs: they arent as mainstream.
10:39:25 <Gracenotes> Cheshire: why not? It takes any type and returns a value of any type ;) theoretically, anyway
10:39:36 <lilac> mathijs: they aren't really heavily used in the real world. :)
10:39:46 <pumpkin_> mathijs: I don't know of many applications of Arrow beyond the function instance...
10:39:59 <newsham> pumpkin: kleisli?
10:40:00 <lilac> mathijs: partly because they're not quite what you want for most non-function arrows
10:40:02 <pumpkin_> in fact, I know of one
10:40:03 <pumpkin_> yeah
10:40:08 <pumpkin_> newsham: any others?
10:40:15 <lilac> pumpkin_: there are various arrow-basedparsers
10:40:16 <mathijs> newsham, lilac: Ok so no need to learn about them until I get to a point that I need them? (and how do I know when that is?)
10:40:18 <newsham> pumpkin: any others besides every single monad that exists? :)
10:40:33 <Gracenotes> @type (return *** return)
10:40:35 <lambdabot> forall a (m :: * -> *) b' (m1 :: * -> *). (Monad m1, Monad m) => (a, b') -> (m a, m1 b')
10:40:49 <roconnor> w a -> m a is a nice arrow
10:40:52 <Gracenotes> hrm. :/
10:40:59 <newsham> mathijs: i'd place it as a low priority unless you're interested in some work thats using them frequently
10:41:01 <pumpkin_> :)
10:41:02 <roconnor>   w a -> m b I mean
10:41:08 <roconnor> for comonad w and monad m
10:41:08 <pumpkin_> it just doesn't seem to capture all of arrowness
10:41:29 <lilac> mathijs: you'll probably be fine if you consider every type signature of the form (Arrow a) => f (a b c) as if it said f (b -> c)
10:42:57 <mathijs> lilac: ok so just remember that -> is an arrow and if I somtimes feel I need to transform/describe normal function application I might look into arrows?
10:43:24 <pumpkin_> I've seen people use b ~> c instead of (Arrow a :: * -> * -> *) => a b c
10:43:38 <pumpkin_> or whatever that kind signature syntax is
10:43:57 <Gracenotes> I think it's also clear to just use ->, replacing the typeclass with the instance
10:44:00 <lilac> pumpkin_: you mean (Arrow (~>)) => b ~> c ?
10:44:17 <pumpkin_> yeah
10:44:33 <Gracenotes> Cheshire: would 'parametric polymorphic coercion' apply for unsafeCoerce, then? Even if it's not correct all the time.
10:44:40 <Gracenotes> most of the time.
10:45:03 <Cheshire> just call it unsafeCoerce
10:45:15 <Cheshire> anything else is confusing
10:45:38 <Twey> :t unsafeCoerce
10:45:42 <lambdabot> Not in scope: `unsafeCoerce'
10:45:50 <Gracenotes> @hoogle unsafeCoerce
10:45:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:45:52 <Twey> What does unsafeCoerce do, then?
10:46:03 <Twey> I mean, how does it do it?
10:47:04 <Gracenotes> ghci> (unsafeCoerce (5 :: Float)) :: Int
10:47:04 <_dolio> It doesn't do anything. It's an identity function with a bad type.
10:47:05 <pumpkin_> just treats the memory of one value as that of a given type?
10:47:09 <Gracenotes> 1084227584
10:48:08 <Gracenotes> ghci> (unsafeCoerce (minBound :: Int)) :: Float
10:48:09 <Gracenotes> -0.0
10:49:17 <lilac> Gracenotes: looks about right to me
10:49:24 <Gracenotes> yep.
10:49:40 <lilac> on a 32-bit system at least :)
10:49:48 <Gracenotes> *sheepishly* yeah >_>
10:49:58 <sw17ch> unsafeCoerce map :: Int
10:50:16 <sw17ch> does the int that evaluates to represent where the code for map is stored?
10:50:18 <sw17ch> or what?
10:50:39 <Cheshire> it seems not type safe
10:50:49 <lilac> @index unsafeCoerce
10:50:49 <lambdabot> bzzt
10:50:54 <pumpkin_> sw17ch: something like that I think, if you go the other way and call hte result, it'll definitely crash
10:50:58 <mathijs> something else... given any integral number x, I need to know what odd number would be the 'base' if I start (`div` 2)'ing x. Of course I can easily write this recursively, but maybe there's some mathematical trick I can use?
10:51:08 <lilac> Cheshire: it's, umm, type-dangerous.
10:51:19 <sw17ch> pumpkin_: now i have to try it :)
10:51:37 <Gracenotes> unsafeCoerce Just :: Int returns a pretty low number here
10:51:40 <pumpkin_> mathijs: base? when do you stop `div` 2'ing?
10:51:44 <lilac> mathijs: yeah, there's a trick
10:52:37 <lilac> mathijs: x / ((x ^ (x-1) + 1) / 2)
10:52:40 <mathijs> pumpkin_: yeah. so basically 'last . takeWhile even $ iterate (/2) x'
10:52:45 <pumpkin_> ah
10:52:57 <lilac> pumpkin_: shift right while the lsb is 0
10:53:00 <newsham> mathijs: http://www-graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightLinear
10:53:04 <pumpkin_> ah :)
10:53:34 <sw17ch> pumpkin_: now i have to try it :)
10:53:40 <sw17ch> pumpkin_: definitely does not crash :)
10:53:43 <pumpkin_> :o
10:53:47 <lilac> newsham: aww, my method's not listed there :)
10:53:58 <newsham> lilac: email them :)
10:53:58 <sw17ch> i'll paste
10:54:08 <pumpkin_> lilac: isn't that x^(x-1) going to be rather expensive for large numbers? :o
10:54:29 <lilac> pumpkin_: i didn't say it was fast, just that it was a trick :)
10:54:37 <newsham> is (^) xor or exponentiation?
10:54:39 <pumpkin_> sw17ch: definitely crashed for me
10:54:41 <lilac> xor
10:54:43 <adrian__> @pl \x -> 1 +
10:54:43 <lambdabot> (line 1, column 10):
10:54:43 <lambdabot> unexpected end of input
10:54:44 <lambdabot> expecting white space or simple term
10:54:44 <pumpkin_> oh
10:54:50 <pumpkin_> then it's not bad
10:54:52 <adrian__> @pl \x -> (+) 1
10:54:54 <lambdabot> const (1 +)
10:54:56 <pumpkin_> I thought it was exponentiation :P
10:54:56 <Gracenotes> > 54309 .^. 43892
10:54:59 <lambdabot>   Not in scope: `.^.'
10:55:03 <Gracenotes> :(
10:55:10 <pumpkin_> `xor`
10:55:17 <Gracenotes> oh, I see
10:55:22 <mathijs> lilac: it doesn't seem to give the right results
10:55:30 <lilac> > (\x -> x `div` ((x `xor` (x-1) + 1) `div` 2)) 42 :: Integer
10:55:31 <m0nkfish> > 2^8
10:55:33 <mathijs> newsham: thanks. I'll read it :)
10:55:33 <byorgey_> (^) is exponentiation, in Haskell.
10:55:33 <lambdabot>   21
10:55:34 <lambdabot>   256
10:55:37 <lilac> > (\x -> x `div` ((x `xor` (x-1) + 1) `div` 2)) 256 :: Integer
10:55:40 <m0nkfish> yup explonential
10:55:41 <lambdabot>   1
10:55:45 <lilac> mathijs: works for me :)
10:55:53 <newsham> byorgey: lilac was probably giving a C expression :)
10:56:03 <mathijs> lilac: sorry, I understood ^ as 'power'
10:56:05 <pumpkin_> no C allowed in here
10:56:11 <byorgey_> newsham: apparently.  maybe we should ban him. ;)
10:56:18 <lilac> indeed
10:56:35 <Gracenotes> preflex: karma C
10:56:35 <preflex>  C: 66215
10:56:39 <Gracenotes> see? someone likes it
10:56:43 <byorgey_> hehe
10:56:48 <newsham> ban for using C?  boo..  "freedom fries" all over again
10:56:50 <pumpkin_> that's like praying to a false god in a church of a true god
10:56:57 <pumpkin_> (!)
10:56:58 <chrisdone> what's a nicer way to express x = y = z than x == y && y == z?
10:57:18 <sw17ch> pumpkin_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1827#a1827
10:57:22 <pumpkin_> all (==x) [x,y,z] ? :P
10:57:23 <mathijs> lilac: would that method work on other divisors as well?
10:57:35 <newsham> chris: how about x == y && x == z  ;-)
10:57:39 <pumpkin_> lol
10:57:57 <trygvis> anyone had any luck with the CouchDB package?
10:57:59 <byorgey_> chrisdone: I don't know of any, short of fancy tricks to allow writing things like  x === y === z
10:58:08 <chrisdone> byorgey_: do they involve type classes?
10:58:20 <byorgey_> chrisdone: don't all fancy tricks?
10:58:23 <Gracenotes> > ((&&) `on` (==3)) 3 3
10:58:24 <lambdabot>   True
10:58:26 <Cheshire> equal [x,y,z]
10:58:27 <Gracenotes> > ((&&) `on` (==3)) 3 4
10:58:28 <lambdabot>   False
10:58:29 <lilac> mathijs: no, it's binary specific
10:58:32 <pumpkin_> sw17ch: I was talking about the other way around
10:58:36 <pumpkin_> the one that is obviously dangerous
10:58:41 <Gracenotes> however, on is in Data.Function, so you'll need to import it
10:58:45 <mathijs> lilac: thought so :)  well in this case I need 2, so thanks
10:58:47 <pumpkin_> sw17ch: (unsafeCoerce 0 :: (Int -> Int)) 1
10:58:47 <sw17ch> just whacking an int out?
10:58:51 <sw17ch> ohhhh
10:58:53 <sw17ch> yes, that one :)
10:58:55 <lilac> mathijs: do you see how it works?
10:58:57 <chrisdone> @src equal
10:58:57 <lambdabot> Source not found. That's something I cannot allow to happen.
10:58:57 <sw17ch> i'd assume that would esplode
10:59:04 <pumpkin_> yeah, it certainly does :)
10:59:15 <Gracenotes> chrisdone: got it...? :D
10:59:19 <chrisdone> I didn't know `equal' existed. that's good
10:59:26 <sw17ch> it's funny that the unsafeCoerce map isn't lossy
10:59:34 <mathijs> lilac: analyzing....
10:59:42 <byorgey_> huh? 'equal' doesn't exist.
11:00:00 <chrisdone> oh. caleskell?
11:00:04 <Gracenotes> chrisdone: x==y && x==z  <==>  ((&&) `on` (==x)) y z
11:00:04 <pumpkin_> sw17ch: ?
11:00:22 <chrisdone> Gracenotes: this is horrible, this idea of yours
11:00:25 <Gracenotes> -.- I dunno. Pretty terse if you ask moi.
11:00:52 <byorgey_> > equal [4,5,6]
11:00:53 <lambdabot>   Not in scope: `equal'
11:00:54 <Gracenotes> everything is only used once
11:00:55 <FalconNL> alternatively, all (==x) [y,z]
11:00:57 <byorgey_> chrisdone: no, I think Cheshire just *said* 'equal [x,y,z]'.
11:01:05 <Gracenotes> it doesn't make a list or anything
11:01:12 <chrisdone> oh, lame
11:01:17 <Cheshire> equal :: Eq a => [a] -> Bool
11:01:20 <Gracenotes> psssh. whatev, girlfriend.
11:01:26 <pumpkin_> lol
11:01:46 <byorgey_> 'equal [x,y,z]' makes a very nice implementation, given a (trivial) implementation for 'equal' =)
11:02:14 <chrisdone> equal (x:xs) = all (==x) xs; equal [] = what?
11:02:24 <byorgey_> chrisdone: True, I suppose.
11:02:31 <byorgey_> all the elements of [] are equal (vacuously)
11:02:45 <Cheshire> none of the elements of [] are equal!
11:02:56 <chrisdone> there are no equalities to speak of..
11:03:00 <ziman> there is no "none" quantifier ;)
11:03:06 <Cheshire> how about:
11:03:08 <Cheshire> equal (x:xs) = all (==x) xs
11:03:13 <Cheshire> --- end of definition
11:03:13 <FalconNL> equal [] = undefined :)
11:03:24 <Gracenotes> equal = and . map (==1)
11:03:28 <pumpkin_> > all id []
11:03:29 <lambdabot>   True
11:03:30 <chrisdone> equal [] = unsafeLaunchMissiles
11:03:30 <ziman> x,y{} x==y is obviously true :)
11:03:31 <byorgey_> what I mean is, expressed as a predicate in first-order logic, equal would have a 'forall' at the front, so equal [] must be True.
11:03:42 <Gracenotes> @src and --probably in terms of all?
11:03:43 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:03:46 <Gracenotes> :(
11:03:51 <mathijs> lilac: I don't see it. I get the x `div` part, I get the `div` 2 part, but the x `xor (x-1) + 1 isn't clear to me.
11:03:51 <byorgey_> what ziman said.
11:03:56 <pumpkin_> @src all
11:03:56 <lambdabot> all p =  and . map p
11:04:04 <pumpkin_> Gracenotes fail
11:04:06 <Gracenotes> oh, hehe
11:04:12 <mathijs> lilac: I know what xor does, but I'm not sure why you use it in this case.
11:04:34 <Gracenotes> pumpkin_: better email the failblog
11:04:47 <pumpkin_> already have
11:05:15 <Gracenotes> oh, and did I mention I came up with an elegant solution involving `on` X_X
11:05:31 <chrisdone> if by elegant you mean horrible
11:05:48 <Gracenotes> @type on (&&) . (==)
11:05:49 <lambdabot> forall a. (Eq a) => a -> a -> a -> Bool
11:05:52 <byorgey_> now, now, children ;)
11:05:52 <Gracenotes> dunno what you're talking about
11:06:01 <lilac> mathijs: think about what "x `xor` (x-1)" does to a binary number
11:06:06 <chrisdone> Gracenotes: your face is rubbish!
11:06:24 <Gracenotes> Your mother is an hamster and your father smells of elderberries!
11:06:34 <lilac> mathijs: hint: for a number n > 0, n - 1 is the same as setting the lowest 1-bit to 0 and all lower bits to 1
11:06:40 <Gracenotes> *a
11:07:34 <mathijs> lilac: not for even numbers right?
11:07:53 <mathijs> lilac: ah... lowest 1-bit, got it...
11:08:06 <mathijs> 6
11:08:51 <ImInYourMonad> is it possible construct a data dynamically?
11:09:11 <pumpkin_> how do you mean?
11:09:15 <Gracenotes> not in ghci
11:09:34 <pumpkin_> like defining data X = ... | ... at runtime?
11:11:29 <sw17ch> pumpkin_: i'm just surprised that all it takes is an integer to represent the location of map, or that the guts only need an Int to fully represent map
11:11:39 <sw17ch> either that or i'm misunderstanding something
11:11:39 <Cale> ImInYourMonad: If pumpkin is right about what you mean, more or less no. You're expected to choose large enough types when writing the program.
11:11:43 <sw17ch> which i'm now fairly sure i am
11:13:13 <pumpkin_> sw17ch: well Int will (usually) be 32 bits on a 32-bit machine and 64 bits on a 64-bit machine, but even so, all it is a cast, so it doesn't care about size, it'll just treat one as the other
11:13:32 <sw17ch> pumpkin_: yes, i figured there was a copy in there somewhere
11:13:41 <Cheshire> ImInYourMonad, yes
11:13:45 <sw17ch> now i'm thinking that the memory is probably the same, and we just add a new box with a different type
11:13:49 <Cheshire> wait 'a data' ?
11:13:52 <sw17ch> which probably doesn't even exist outside the compiler
11:14:38 <Gracenotes> heh... unsafeCoerce Right and unsafeCoerce Just to Integer yield the same result for me. 182
11:15:26 <ImInYourMonad> pumpkin: yes at runtime
11:15:45 <ImInYourMonad> like if im doing mahcine learning and want to create a label from a string at runtime.
11:15:56 <lilac> Gracenotes: 182 means 'monadic return' :-)
11:16:00 <lilac> j/k
11:16:51 <ImInYourMonad> "spam" -> Spam vector
11:17:03 <Cheshire> ImInYourMonad, why not use Integer
11:17:16 <Cheshire> "spam" ~> 324235262
11:18:08 <byorgey> ImInYourMonad: why can't you just use the string itself?
11:18:14 <ImInYourMonad> how do I make emacs-mode write the type of a function aboe it?
11:18:28 <brad_larsen> is there a way to be able to use Haskell quasiquotes for pattern matches?
11:18:46 <ImInYourMonad> what is "spam" ~> 324235262, ~> ?
11:18:53 <brad_larsen> i.e. to pattern match on quasiquoted haskell code
11:19:32 <lilac> brad_larsen: yes, you can do that. there's a good example ... somewhere
11:19:52 <ImInYourMonad> Cheshire: ~> i cant do it in ghci
11:20:03 <ImInYourMonad> > "yes" ~>
11:20:04 <lambdabot>   <no location info>: parse error on input `;'
11:20:11 <monochrom> onoes, you're in my monad!
11:20:16 <ImInYourMonad> > "yes"
11:20:17 <lambdabot>   "yes"
11:20:20 <Gracenotes> ~> is a valid identifier
11:20:23 <ImInYourMonad> > ~ "yes"
11:20:24 <lambdabot>   Pattern syntax in expression context: ~"yes"
11:20:25 <brad_larsen> lilac: i've looked on the wiki and such, and haven't been able to figure it out
11:20:50 <monochrom> ~> is valid but you have to use it infix, like + and *
11:20:59 <Gracenotes> > let a ~> b = b - a in 4 ~> 10
11:21:00 <lambdabot>   6
11:21:12 <ski_> > "spam" ~> 324235262
11:21:13 <lambdabot>   "a banana"
11:21:16 <Gracenotes> @hoogle (~>)
11:21:17 <lambdabot> No results found
11:21:25 <mathijs> lilac: well I guess x `xor` x turns all bits to 1 that flipped when doing x-1. + 1 gives a number that just has 1 binary 1 in it, where the location of the bit tells how many times the original number was dividable by 2. this bit is 1-off (because of the + 1) so you `div` 2.
11:21:38 <Gracenotes> @type (~>)
11:21:40 <lambdabot> forall t t1. t -> t1 -> [Char]
11:21:47 <ImInYourMonad> well si there a function String -> Integer?
11:22:05 <Gracenotes> sure, length
11:22:09 <Gracenotes> well, that's Int
11:22:16 <monochrom> @type length
11:22:18 <lambdabot> forall a. [a] -> Int
11:22:23 <Cale> ImInYourMonad: read?
11:22:24 <monochrom> hehehehehe
11:22:29 <Cale> > read "45871532" :: Integer
11:22:31 <lambdabot>   45871532
11:24:19 <ImInYourMonad> well, String -> Integer that can do "hello" -> 188283
11:24:26 <monochrom> I love Gracenotes's answer. I must remember it. I am weary of "how to convert string to int". Meaningless question inspired by sloppy doc from inferior languages. What conversion do you want?
11:24:29 <ImInYourMonad> a hash function
11:25:13 <Gracenotes> hm.
11:25:20 <dons> ?hoogle hash
11:25:20 <lambdabot> package Hashell
11:25:20 <lambdabot> Data.HashTable hashInt :: Int -> Int32
11:25:20 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
11:25:27 <dons> ?hoogle+
11:25:28 <lambdabot> Data.HashTable hashString :: String -> Int32
11:25:28 <lambdabot> module Data.HashTable
11:25:28 <lambdabot> Data.HashTable data HashTable key val
11:25:36 <dons> > Data.HashTable hashString "heya"
11:25:37 <lambdabot>       Failed to load interface for `Data':
11:25:37 <lambdabot>        Use -v to see a list of the...
11:25:39 <dons> boo
11:25:57 <dons> a hashing class might be interesting.
11:26:11 <Gracenotes> well, if you're looking for the standard String-hashing function... hrm
11:26:11 <dons> Binary a => Hashable a :)
11:26:23 <pumpkin_> there's a standard string hashing function?
11:26:23 <maltem> > Data.HashTable.hashString "heya"
11:26:24 <lambdabot>   /tmp/582699886978441315:70:32:
11:26:24 <lambdabot>      Not in scope: `Data.HashTable.hashString'
11:26:35 <maltem> whatever
11:26:36 <monochrom> No, a hashing class will get people into a fight. Different people want to hash differently.
11:26:42 <dons> yes
11:26:45 <Gracenotes> pumpkin_: in many programming languages.
11:26:49 <Gracenotes> there is no standard one
11:26:49 <pumpkin_> and some think it should be illegal
11:26:57 <dons> different people want to serialise differently too, yet we have Data.Binary :)
11:27:09 <monochrom> Darn these conformists.
11:27:15 <dons> then again, given Ord, hashing classes are less useful in Haskell
11:27:20 <Gracenotes> but the common one: summing the product of each character of a string with some prime number to some power
11:27:33 <dons> that's hashString in Data.HashTable
11:27:45 <dolio> So, are we at 5 hackage packages with separate stream fusion now? :)
11:27:50 <dons> :)
11:27:56 <dons> hey, at least we know it works
11:27:57 <dolio> Or did I miss some.
11:28:07 <Gracenotes> it should be easy enough to implement
11:28:10 <monochrom> Oh! A hashing class like the Binary serialise class? Gives you the tools to build your own hash but not dictate which one to build?
11:28:14 <dons> list, uvector, vector, bytstring, text, ... (stream next?)
11:28:21 <dons> monochrom: maybe
11:28:28 <dons> monochrom: or just a single instance
11:28:34 <dons> hash . encode $ x
11:28:44 <dons> i.e. it hashes the bytes of the binary representation
11:28:58 <ski_> instance Hashable a where hash _ = 0
11:29:04 <dons> :)
11:29:16 <pumpkin_> for awesome hash performance in HashTable
11:29:30 <dons> pumpkin_: we love linked lists in haskell :)
11:29:31 <Gracenotes> > sum . map (\(n,c) -> ord c * 31^n) . zip [1..] $ "hello there little hash function"
11:29:33 <lambdabot>   -6576887681617837174
11:29:36 <pumpkin_> yay
11:29:38 <Gracenotes> -.-
11:29:53 <monochrom> O(4000000000) where 4000000000 is the largest possible hash table size.
11:30:01 <pumpkin_> someone should build a (Hashable a, Ord a) hashtable, that uses balanced trees for things with equal hashes :P
11:30:01 <Gracenotes> > (sum . map (\(n,c) -> ord c * 31^n) . zip [1..] $ "hello there little hash function") :: Int
11:30:03 <lambdabot>   -6576887681617837174
11:30:16 <pumpkin_> assuming equal hash doesn't imply EQ in ord
11:30:18 <Gracenotes> > minBound :: Int
11:30:20 <lambdabot>   -9223372036854775808
11:30:35 <pumpkin_> failnotes
11:30:47 <Gracenotes> > logBase 2 9223372036854775808
11:30:48 <lambdabot>   63.0
11:31:02 <Gracenotes> sheesh. Why can't you use 32 like the rest of us!
11:31:11 <Gracenotes> -.-
11:31:26 <dolio> Rest of who?
11:31:31 <Gracenotes> rest of me :(
11:31:34 <pumpkin_> lol
11:31:38 <pumpkin_> Gracenotes: you on mac os?
11:31:47 <Gracenotes> Ubuntu laptop
11:31:53 <pumpkin_> ah
11:32:19 <chrisdone> do we have a class similar to the sequence abstraction in Clojure?
11:32:20 <monochrom> 64 bit computers are 64.
11:32:27 <Gracenotes> yes, I know
11:32:44 * ski_ likes his C64
11:32:47 <dons> chrisdone: what does  it do?
11:32:56 <dons> my guess-- yes, since we have a gazillion things
11:32:58 <Gracenotes> I want one, but like my would-be-incompatible-otherwise apps :/
11:33:10 <chrisdone> it can be defined as an abstract data type: head(x) -> y. next(x) -> x.
11:33:18 <dons> we have lazy lists.
11:33:50 <Cheshire> head(x) -> y.   lol
11:33:51 <chrisdone> a Map could be an instance of this, and an array
11:33:55 <lilac> @quote initial
11:33:55 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
11:33:57 <dons> Traversable?
11:34:00 <dons> Foldable?
11:34:14 <chrisdone> Cheshire: what's funny about that?
11:34:25 <chrisdone> @src Traversable
11:34:25 <lambdabot> class (Functor t, Foldable t) => Traversable t where
11:34:25 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
11:34:25 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
11:34:25 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
11:34:25 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
11:34:31 <ski_> (chrisdone : are those rewrite rules, or type specifications ?)
11:35:01 <lilac> Cheshire: assume 'class Traversable x y | x -> y' and it's a lot more snsible
11:35:08 <ski_> @quote terminal
11:35:08 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
11:35:08 <lambdabot> object in the category of religions and theomorphisms.
11:35:30 <chrisdone> @instances Traversable
11:35:30 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
11:35:31 <lilac> ski_: brilliant! :)
11:35:39 <lilac> Cale++
11:35:39 <chrisdone> @instances-importing Traversable
11:35:40 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
11:35:49 <chrisdone> k
11:35:54 <ski_> (lilac : just a stab in the dark ..)
11:36:12 <Cale> What am I getting karma for? :)
11:36:22 <Cale> oh
11:36:23 <Cale> :)
11:36:28 <ski_> presumably for founding the above religion
11:36:29 <chrisdone> dons: what about ByteString?
11:36:37 <dons> not a functor
11:36:40 <lilac> Cale: "Cale's terminal religion"
11:36:45 <ImInYourMonad> and from Int to String?
11:36:54 <mathijs> ImInYourMonad: how
11:36:55 <mathijs> show
11:36:57 <Cale> The initial religion is atheism.
11:37:03 <dons> hah
11:37:04 <pumpkin_> @hoogle Int -> String
11:37:04 <lambdabot> Language.Haskell.TH tupleDataName :: Int -> Name
11:37:04 <lambdabot> Language.Haskell.TH tupleTypeName :: Int -> Name
11:37:04 <lambdabot> Language.Haskell.TH.Syntax tupleDataName :: Int -> Name
11:37:07 <pumpkin_> lol
11:37:21 <lilac> Cale: i'd have thought agnosticism was the initial religion
11:37:37 <chrisdone> dons: but it has head and next operations?
11:37:38 <Gracenotes> @type (:[]) . chr
11:37:39 <lambdabot> Int -> [Char]
11:37:41 <Cale> Well, okay, we'll take both of those.
11:37:59 * ski_ would find a religion with tenet being "You should believe a statement whenever you believe that if you believed it, it would be true" more interesting
11:38:05 <pumpkin_> > read "768" :: Int
11:38:06 <lambdabot>   768
11:38:10 <ImInYourMonad> is it not possible to go form hashString String -> Int then turn that int back to the string it came from?
11:38:15 <Gracenotes> @type flip replicate ' '
11:38:16 <mathijs> chrisdone: because of laziness and pattern matching, you don't need head and next.
11:38:16 <lambdabot> Int -> [Char]
11:38:30 <dons> chrisdone: so you want something like: head :: c a -> a; next :: c a -> c a ?
11:38:33 <ImInYourMonad> any emacs gods in here? how do I make emacs infer the types of all functions aina file?
11:38:33 <dons> for arbitrary containers?
11:38:36 <pumpkin_> ImInYourMonad: only if you fully encode the string in the integer
11:38:39 <lilac> ski_: belief is a modal logic. stop trying to escape! :)
11:38:42 <pumpkin_> ImInYourMonad: or maintain a mapping
11:38:49 <dons> ?src Monoid
11:38:49 <lambdabot> class Monoid a where
11:38:49 <lambdabot>     mempty  :: a
11:38:49 <lambdabot>     mappend :: a -> a -> a
11:38:49 <lambdabot>     mconcat :: [a] -> a
11:39:39 <chrisdone> dons: is that possible?
11:40:00 <lilac> am i right in recalling that curry-howard in some sense maps monads to modal logics?
11:40:03 <ski_> lilac : i want my modal reasoner to be modest
11:40:05 <Gracenotes> I have a great function a -> String. It's called const "lol"
11:40:17 <dons> what's 'next' do?
11:40:20 <monochrom> Religion is not necessarily about happiness. A religion that talks about happiness is not terminal.
11:40:32 <nominolo> ImInYourMonad: C-c C-t does it for one function
11:40:45 <lilac> terminal religion: "believe in this statement. don't expect any explanation."
11:40:54 <dons> not sure 'next' makes sense given control is reified in our lazy structures
11:41:06 <chrisdone> dons: maybe a better name is 'tail'
11:41:08 <Apocalisp> The terminal religion is _|_
11:41:12 <nominolo> dons: well, Stream has a "next" :)
11:41:14 <Gracenotes> most religions are context-sensitive
11:41:18 <ehird> :t callCC
11:41:19 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:41:21 <dons> chrisdone: then yeah, you can write a trivial class that does head and tail
11:41:35 <chrisdone> dons: could bytestring be an instance of it?
11:41:46 <Cale> Apocalisp: I tried that religion, but my brain crashed and had to be restarted
11:41:58 <dons> with type funkiness, true containers, and monomorphic containers , can be instances, yes
11:42:01 <dons> see .e.g. parsec3
11:42:02 <chrisdone> class Sequence a b where head :: a -> b; next :: a -> a?
11:42:04 <monochrom> Use a virtual machine next time.
11:42:05 <lilac> the initial algebra looks like: data C a = { head :: a; next :: C a } which is of course isomorphic to []
11:42:11 <Apocalisp> religion :: forAll a. non-a.
11:42:20 <dons> chrisdone: basically
11:42:42 <ski_> @quote religion
11:42:42 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
11:42:42 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
11:42:45 <lambdabot> still
11:42:57 <Cale> lilac: Monads are a certain sort of modal operator, yeah.
11:43:07 <chrisdone> dons: is that class I wrote nonstandard haskell?
11:43:21 <ImInYourMonad> nominolo C-c C-t does it in the repl
11:43:21 <lilac> chrisdone: yes, multi-parameter type classes
11:43:23 <Cale> lilac: One with p -> [] p, and [] ([] p) -> [] p
11:43:27 <ImInYourMonad> i want to do it for all in the buffer
11:43:51 <lilac> Cale: is that temporal modal logic?
11:44:09 <ski_> lilac : itym s/initial algebra/final coalgebra/ s/[]/Stream/ ?
11:44:18 <mathijs> chrisdone: I think it's not that useful most of the time. You can use pattern matching on most list-like structures (including bytestring)
11:44:26 <chrisdone> lilac: but that specialises on the implementation doesn't it?
11:44:31 <Cale> lilac: I don't know if it otherwise has a name. I don't know a whole lot about modal logic.
11:44:40 <chrisdone> mathijs: what about Map?
11:44:48 <dolio> lilac: "C a = a * C a" are infinite streams.
11:45:18 <Cale> :t ap
11:45:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:45:23 <monochrom> <3 modal operator. I knew that I should know that monad is a modal operator.
11:45:25 <Cale> That's 'K'
11:45:34 <Cale> (the distribution axiom)
11:45:44 <BMeph> dons, chrisdone: Isn't that the example case for type families? :)
11:45:48 <dons> chrisdone: http://galois.com/~dons/tmp/Z.hs
11:45:49 <Cale> return is a bit like 'N'
11:45:50 <ski_> lilac : that is the system `S4', with axioms `T' and `4' (though usually Cale's `[]' is written as `<>')
11:45:59 <lilac> dolio, ski_: yes. i have learnt over many years that the probability of a statement being correct goes down when "of course" is inserted
11:46:07 <dolio> Heh.
11:46:17 <ski_> lilac : oh, you're talking about linear logic now ?
11:46:24 <ushdf> i'm all out of tobacco
11:46:28 <ushdf> can haskell run to the store for me
11:46:30 <nominolo> ImInYourMonad: C-u C-c C-t
11:46:31 <Gracenotes> [()] is a makeshift number, in a sense
11:46:37 <lilac> @faq can haskell run to the store for ushdf
11:46:37 <lambdabot> The answer is: Yes! Haskell can do that.
11:47:03 * ushdf waits
11:47:03 <mathijs> chrisdone: map is traversable and foldable, so you can take 1 element out and keep the rest (as in tail).
11:47:05 <Gracenotes> hm. *runs off to make a Num instance*
11:47:08 <nominolo> ImInYourMonad: but, I don't know of any way to do it for every function in the file
11:47:30 <chrisdone> mathijs: what if I want to write a function that works for any list-like structure?
11:47:33 <lilac> chrisdone: the point is that, for that Traversible thingy, the type "exists a. Traversible a => a" is isomorphic to a Stream
11:47:43 <ski_> <http://en.wikipedia.org/wiki/Modal_logic> (i was talking about "Modest" in <http://en.wikipedia.org/wiki/Doxastic_logic> before)
11:48:02 <chrisdone> dons: that's cool
11:48:25 <ski_> (lilac : you are aware that "of course" is the name of a modal operation in linear logic, right ?)
11:48:34 <nominolo> ImInYourMonad: though, you will probably have to edit many types manually.  For example, String instead of [Char]
11:48:40 <mathijs> chrisdone: Map is not list-like. You can turn it into a list though(in a few ways, depending on the traveral-order). In that case you might like to make a typeclass for it indeed.
11:49:17 <lilac> ski_: heh, no, i was not :)
11:49:30 <monochrom> which operator is "of course"?
11:49:31 <ski_> (and yes, proving "of course `A'" is usually harder than proving plain "`A'")
11:49:40 <cjay> what is a reasonable global prefix for cabal-install on freebsd? /usr/local is used by ports..
11:49:48 <ski_> monochrom : the one usually denoted by `!'
11:50:06 <nominolo> cjay: /opt/local
11:50:23 <lilac> ski_: is this like 'always A' versus 'A' versus 'eventually A' ?
11:50:25 <ski_> monochrom : a value of type `!a' "contains" as many copies of one value of type `a' as you like
11:50:27 <chrisdone> dons: do you think it's unreasonable to want a class like that?
11:50:30 <dons> nope
11:50:31 <Cheshire> modal logic in 20 seconds is:    [[P]] -> P(x);  [[ <>M ]] -> forall x, [[ M ]];  [[ []M ]] -> exists x, [[ M ]]
11:50:46 <Cheshire> actually I think I switched the two around..
11:51:47 <ski_> giving someone `!pizza' means that they get to eat as many pizzas as they like .. giving them `?pizza' means that they *must* eat as many pizzas as *you* want to feed them
11:53:47 <sw17ch> Does any one think it's a bad idea to add functionallity to the RTS such that one could prevent a thread from running? This would involve adding a threadEnable and threadDisable that either unblock or block the thread.
11:53:48 <ski_> Cheshire : (yes) .. also, it might be clearer to note `x' as an explicit parameter of the semantic bracket
11:54:26 <ski_> (Cheshire : well, actually, if you meant to do Kripke semantics, you need to add some accessability relations there, too ..)
11:55:05 <kryptiskt_> sw17ch: I think the threads are so lightweight that that would be significant baggage for performance.
11:55:22 <sw17ch> kryptiskt_: how so?
11:55:31 <sw17ch> we already check whether threads are runnable in the RTS
11:55:46 <kryptiskt_> Well, that would entail a check at every task-switch
11:55:51 <sw17ch> we do already :)
11:55:56 <sw17ch> don't we?
11:56:08 <sw17ch> unless i'm reading the Scheduling.c code wrong...
11:56:22 <sw17ch> and the context switch is 20ms right?
11:57:17 <kryptiskt_> sw17ch: surely not for green threads
11:57:34 * sw17ch investigates closer
11:58:58 <sw17ch> kryptiskt_: this would have the same performance as blocking on an MVar, no?
12:00:12 <byorgey> I want to write a simple web app that lets the user type some things into a form and then generates an image.  Any suggestions on what would be the easiest to use? cgi? happstack? some other thing?
12:00:36 <chrisdone> I'd go with CGI for something simple like that
12:01:19 <chrisdone> if you want to use an existing web server, anyway. I haven't used happstack
12:02:11 <mathijs> byorgey: happstack is easy for the web part (handling the form, parsing input, returning output).
12:02:42 <byorgey> mathijs: ok, i'll take a look at it. thanks.
12:02:49 <Saizan> byorgey: darcs happstack has a little guestbook demo app that's probably easily adapted
12:02:59 <byorgey> cool
12:03:51 <byorgey> now, the question is, will 'cabal install happs-tutorial' Just Work (tm)?
12:03:54 * byorgey crosses fingers
12:04:10 <mathijs> byorgey: happs-tutorial is for happs, not happstack
12:04:18 <byorgey> mathijs: it's for happstack now.
12:04:26 <mathijs> byorgey: ah, nice :)
12:04:50 <byorgey> oh, it requires ghc 6.10.  fooey.
12:06:40 * byorgey makes a new user for installing ghc 6.10
12:07:23 <Saizan> uhm, happstack doesn't (not sure about -tutorial), but cabal-install solver might not be smart enough to see it
12:12:00 <nominolo> Saizan: btw, my bugfix to GHC was correct, it just needed activating in Haddock
12:12:20 <nominolo> Saizan: if you update from the Haddock main repo, it should now work
12:13:24 <Saizan> nominolo: oh, cool
12:13:45 <nominolo> Let me know if it doesn't
12:14:15 <byorgey> Saizan: I was talking about the tutorial.
12:14:40 <Gracenotes> > ":("
12:14:41 <lambdabot>   ":("
12:15:05 <nominolo> @quote happy
12:15:06 <lambdabot> Korollary says: Can't you pretend that you've never heard of any of this and keep hacking happy java?
12:16:47 <Twey> Hahaha
12:17:01 <Gracenotes> @quote sad
12:17:01 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
12:17:01 <lambdabot>  but then I look at some java code and I'm all happy again
12:17:09 <Gracenotes> ...
12:17:30 <Maddas> @quote happy
12:17:30 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
12:17:30 <lambdabot>  but then I look at some java code and I'm all happy again
12:17:37 <Maddas> Gracenotes: :-(
12:17:40 <Gracenotes> @quote java
12:17:41 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
12:17:48 <Gracenotes> @quote java
12:17:48 <lambdabot> quicksilver says: or in Java, we'd make it more generic by using a PolynomialDivisionOperatorFactory.
12:18:49 <Gracenotes> @quote pascal
12:18:49 <lambdabot> Bulat says: we can also rename Pascal to Blez to avoid confusion
12:19:03 <Gracenotes> good idea :\
12:20:18 <CTA> Hey
12:21:59 <byorgey> hi CTA
12:22:31 <bos> @seen dons
12:22:31 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 32m 1s ago.
12:23:46 <ski_> (lilac : somewhat ..)
12:24:17 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1828#a1828 <- what do you think of my KNN implementation ?
12:24:20 <byorgey> gee whiz, HaXML generates a lot of warnings =P
12:24:54 <ImInYourMonad> 77 lines of haskell deus ex machina!
12:24:57 <CTA> mwha on my work experience all im doing is editing photos
12:26:41 <byorgey> ImInYourMonad: looks nice!
12:27:00 <wli> Wow, my quotes are lame.
12:27:27 <ski_> you have more than one ?
12:27:38 <Cheshire> @quote wli
12:27:38 <lambdabot> wli says: brb kitchen fire
12:27:52 <monochrom> hahahaha
12:28:15 <monochrom> Haskell is so fun you forgot you were cooking? :)
12:28:45 <byorgey> \o/  happs-tutorial installed without a hitch!
12:28:47 <lispy> is there a tool to count lines of code in Haskell?
12:28:54 <lispy> byorgey: nice
12:28:54 <byorgey> cabal-install++
12:28:59 <wli> I literally don't remember what the story behind that.
12:28:59 <byorgey> happstack++
12:29:00 <monochrom> wc -l file.hs
12:29:13 <hellige> byorgey: still looking for comments on the article?
12:29:17 <byorgey> it took like 10 minutes downloading and building all the dependencies, but nothing failed.
12:30:33 <byorgey> hellige: typos only at this point, I already sent in my revisions so I'm not going to be reworking anything
12:30:46 <byorgey> but if there's something that can be fixed quickly I can still send in another patch.
12:31:00 <hellige> byorgey: cool, i didn't want to waste your time... did you catch the misspelling of Uustalu?
12:31:30 <byorgey> hellige: indeed, someone else caught that
12:31:31 <byorgey> thanks
12:31:58 <hellige> np... i had some bigger suggestions, too, but i won't bother. all in all, it's a great article... thanks for putting it together!
12:32:45 <byorgey> hellige: I would still be interested in hearing your bigger suggestions, I just might not do anything about them =)
12:33:01 <hellige> well, i'll just tell you quickly what i had in mind... they're simple.
12:33:06 <byorgey> ok, shoot
12:33:35 <hellige> 1. say something about ST, since it's pretty unique among "non-magic" monads
12:33:56 <hellige> 2. give an example and some intuition for why all Functors aren't Traversable.
12:34:18 <hellige> (since you suggest that the definition of fmap will usually work, modulo $/<*>)
12:34:30 <hellige> 3. some more intuition for ArrowLoop would be helpful.
12:34:50 <hellige> and i have some doubts about your claim that Category can only represent categories whose objects are objects in Hask.
12:34:53 <hellige> i'm not sure that's quite right.
12:35:08 <hellige> i think it's true for arrow, because of arr, but i'm not sure it's true for Category.
12:35:12 <byorgey> hellige: how could it represent anything else?
12:35:53 <hellige> well, the type class really represents a category C in terms of it's hom-objects in Hask.
12:36:11 <hellige> so a type c a b represents the set of morphisms a -> b in the category c.
12:36:15 <lispy> I guess darcs is < 40k loc including the tex bits that are in the source
12:36:20 <byorgey> true
12:36:45 <byorgey> but a and b can only be types.
12:36:47 <hellige> so the objects a and b have to be representable as objects in Hask, but i'm not quite sure that it's the same thing.
12:37:15 <hellige> it seems like claiming that Set can only represent categories whose objects are sets.
12:37:20 <hellige> but that's not quite true.
12:37:28 <byorgey> yeah, I see your point.
12:37:40 <hellige> and i feel like the yoneda embedding is relevant here.
12:37:52 <hellige> but this is where i start to get too deep for my own good.
12:37:59 <hellige> so i can't really make a case, it's just a hunch.
12:38:16 <byorgey> this is where it starts getting out mf my depth too. =)
12:38:26 <byorgey> well, shucks, those are all excellent suggestions.
12:38:27 <ImInYourMonad> what article?
12:38:29 <hellige> this post may be relevant: http://matt.immute.net/content/generalizing-functor
12:38:46 <hellige> well, thanks. but really they're all minor things, or extensions.
12:38:49 <hellige> the article is really great.
12:39:03 <byorgey> there has been talk of wikifying or otherwise html-ifying it after it's published, perhaps I can make some improvements based on your suggestions then.
12:39:08 <byorgey> thanks.
12:39:40 <byorgey> ImInYourMonad: http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
12:39:42 <hellige> yeah, i agree with you that having a proper pdf article is very valuable. but a wiki version would be good, too, eventually.
12:39:59 <whpearson__> byorgey++
12:40:13 * whpearson__ should have done that a while a go
12:43:36 * Heffalump appears
12:44:11 <Gracenotes> @hoogle get
12:44:11 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
12:44:11 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
12:44:11 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
12:44:24 <Heffalump> byorgey: when I render text with diagrams, it seems to put some indeterminate amount of white space around it (in terms of the bounding box). Is this expected? It makes it rather hard to line up multiple lines.
12:44:52 <Gracenotes> @hoogle context
12:44:52 <lambdabot> Language.Haskell.ParseUtils checkContext :: HsType -> P HsContext
12:44:52 <lambdabot> Distribution.Extension FlexibleContexts :: Extension
12:44:52 <lambdabot> Language.Haskell.Extension FlexibleContexts :: Extension
12:45:06 <CTA> I'm debating over C and Haskell for Mac development
12:45:12 <Gracenotes> hm. more in-style to have a function called context, or getContext?
12:45:41 <monochrom> Surely try Haskell first.
12:45:52 <byorgey> Heffalump: hmm, honestly, I don't know much about the text stuff, Dougal Stanton added the text support
12:45:55 <whpearson__> CTA: Developing what?
12:46:18 <CTA> Just apps
12:46:22 <CTA> Maybe simple games
12:46:24 <Heffalump> byorgey: ok. Should I email him then?
12:46:24 <whpearson__> And did you mean objective C?
12:46:36 <byorgey> Heffalump: sure
12:47:03 <CTA> Yeah C OR Obj-C
12:53:27 <whpearson__> Games I'd probably do in C, there is just more stuff/tutorials etc for it. Other random apps I'd try in haskell as well.
12:54:12 <CTA> It would be ObjC rather than C
12:54:16 <ImInYourMonad> as soon as I get opengl working ill start on a game in haskell
12:54:24 <ImInYourMonad> but windows and ghc doesnt seem compatible
12:55:30 <CTA> I might learn Haskell :)
13:02:28 <pumpkin> moo
13:03:47 <christastrophe> im having a bit of scoping trouble in haskell, anyone care to point out the obvious to me :)
13:04:00 <christastrophe> I put up the example on hpaste (id 1829)
13:04:09 <christastrophe> not sure how to really announce that properly here, sorry.
13:04:16 <pumpkin> a url would make it easier
13:04:18 <Cheshire> by hyperlikn
13:04:19 <Cheshire> by hyperlink
13:04:27 <christastrophe> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1829#a1829
13:04:37 <pumpkin> mmkay
13:04:43 <pumpkin> what trouble are you having?
13:04:49 <christastrophe> ghci says padOne is out of scope
13:05:01 <pumpkin> it's only in the last pattern
13:05:30 <ski_> possibly the problem is the `:' in `(padOne n c x):(pad n c xs)' ?
13:06:06 <ski_> (hint : `:' doesn't paste two strings together to a new string)
13:06:11 <byorgey> christastrophe: I'd suggest making padOne into a top-level function, and writing its type.
13:06:28 <byorgey> I think you are slightly confused about what type it is.
13:06:34 <pumpkin> I wonder who Anonymous Anonymous is
13:06:35 <byorgey> ski_: I don't think that's the intention.
13:07:14 * ski_ rereads
13:07:47 <ski_> byorgey : yes, you're right
13:08:07 * ski_ goes to bed before he says anything more stupid
13:08:10 <byorgey> christastrophe: do you see why you're getting the out of scope error, though?
13:08:18 <byorgey> hehe, night ski_  =)
13:08:27 <christastrophe> no the ':' isn't to create a strin g, but to const a string to a list of strings... right?
13:08:36 <byorgey> christastrophe: yes, that's right.
13:08:57 <christastrophe> not clear on the scope error. I've seen example code which uses a function befined in the where clause
13:09:05 <christastrophe> whats different here?
13:09:12 <byorgey> the where clause only scopes over the last declaration.
13:09:16 <pumpkin> you have three patterns, and the where is only visible to the third
13:09:24 <byorgey> so the call to padOne in line 3 is what's giving you the error.
13:09:32 <christastrophe> ah! ca va. now I see.
13:09:35 <byorgey> christastrophe: this is why I suggest making padOne into a top-level function
13:09:47 <christastrophe> damn I knew it was going to be obvious :)
13:10:04 <christastrophe> yeah, now making that a top level makes sense to me
13:10:04 <byorgey> christastrophe: but once you do that, you'll have another error, but I'll let you see if you can figure it out =)
13:10:04 <pumpkin> or you merge the two patterns into one and put a case within it
13:10:04 <Gracenotes> also, you could change the pattern matching into a case statement :) in which case only the function has to see padOne
13:10:16 <Gracenotes> like pumpkin said 3 seconds before I did
13:10:24 <christastrophe> yeah padOne is Int -> Char -> String -> String :)
13:10:33 <Gracenotes> to be fair he did type less
13:10:34 <byorgey> right.
13:11:01 <pumpkin> Gracenotes: your fail haz no excuse, sry
13:11:04 <pumpkin> *ur
13:11:20 <christastrophe> ok. off to fix this up
13:11:32 <christastrophe> danke
13:11:34 <Gracenotes> you did not include a :) in your answer, pumpkin
13:11:41 <pumpkin> oh crap :/
13:11:46 <Gracenotes> from this I can only conclude you harbor ill will towards christastrophe
13:12:28 <christastrophe> irc ill will ... oh noes! :)
13:13:23 <christastrophe> the use of case would be a nice improvement... though I'm not yet fluent in using that form
13:13:50 <byorgey> I actually don't think it would be an improvement.
13:14:03 <pumpkin> pad n c xs = case xs of [] -> ...; (x:xs) -> ...; where padOne = ...
13:14:05 <Gracenotes> it uses pattern matching too.
13:14:09 <byorgey> I try to avoid explicit case statements as much as possible.
13:14:13 <Cheshire> hi
13:14:20 <byorgey> hey Cheshire
13:14:25 <pumpkin> byorgey: too low-level for you?
13:14:29 <Cheshire> anything ne?
13:14:31 <Cheshire> anything new*?
13:14:40 <byorgey> pumpkin: yup, and the syntax is annoying
13:14:59 <pumpkin> I'll take case over if any day :)
13:15:02 <pumpkin> but tend to avoid both if I can
13:15:12 <byorgey> oh, I agree with you there =)
13:15:26 <christastrophe> hmm. both fell unnatural still to me -- (still kicking the training wheels)
13:15:36 <Gracenotes> if?
13:15:45 <Gracenotes> sometimes if is nice. If you have, you know, a boolean
13:16:08 * ushdf coughs
13:16:22 <Badger> if you do.
13:16:29 * ushdf coughs louder
13:17:05 <pumpkin> Gracenotes: I still don't like it
13:17:20 <pumpkin> but then again, I shouldn't be forming strong opinions this early
13:17:24 <Gracenotes> I would much rather prefer a :: Bool -> a -> a -> a
13:17:32 <pumpkin> yeah, me too
13:17:35 <pumpkin> called bool
13:17:41 <Cheshire> Gracenotes, bool :: a -> a -> Bool -> a
13:18:01 <pumpkin> :t maybe
13:18:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:18:04 <Gracenotes> Cheshire: yes, since we have const and flip const otherwise :)
13:18:05 <pumpkin> yup
13:18:13 <Gracenotes> but a function, nonetheless
13:18:24 <Cheshire> you can define this
13:18:28 * Gracenotes thinks we should have a function for (flip const)
13:18:32 <Gracenotes> anyway. that's much better for composition.
13:18:39 <Saizan> ?type flip const
13:18:40 <lambdabot> forall a b. b -> a -> a
13:18:50 <Cheshire> drop = flip const
13:19:00 <Gracenotes> of course, a case isn't much better than an if in the case you want nice function composition
13:20:04 <Gracenotes> bool x y b = if b then x else y... what do I win? :D :D
13:20:12 <Cheshire> Gracenotes nothing
13:20:16 <Cheshire> that is a bad definition
13:20:44 <Gracenotes> well. Ideally one would pattern-match.
13:20:53 <Cheshire> and use meaningful names
13:21:09 <Gracenotes> the person using the function can tell O-O
13:21:31 <mle> :t if'
13:21:33 <lambdabot> Not in scope: `if''
13:21:43 <mle> hrm~
13:21:59 <Cheshire> I don't understand recursive path ordering
13:22:42 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1830#a1830 <- my average, can it be imrpoved?
13:23:04 <Cheshire> ImInYourMonad, you can start by naming things better than 'avg'
13:23:07 <Cheshire> use the word: average
13:23:19 <pumpkin> or mean
13:23:26 <Gracenotes> oh snap
13:24:13 <ushdf> where'd my tobacco go
13:24:27 <ushdf> hmm
13:24:34 <ushdf> @faq can haskell roll me a cigarette
13:24:34 <lambdabot> The answer is: Yes! Haskell can do that.
13:24:50 <ImInYourMonad> avg is better, good programmers use short names, ask paul graham if you dont believe me!
13:25:05 <Cheshire> ImInYourMonad, ok
13:25:24 <Cheshire> ImInYourMonad, why did you paste that code and ask for advice again?
13:25:53 <ImInYourMonad> @ faq can haskell steal cocaine from mexaican druglords and end up a in a threesome with 2 transvestites?
13:25:56 <christastrophe> ok cool. I got that padOne working... here is the new improved one in case anyone wants a peek: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1829#a1831
13:25:59 <ImInYourMonad> @faq can haskell steal cocaine from mexaican druglords and end up a in a threesome with 2 transvestites?
13:25:59 <lambdabot> The answer is: Yes! Haskell can do that.
13:26:20 <ImInYourMonad> Cheshire: what code?
13:26:37 <Gracenotes> ImInYourMonad: the code looks fine to me.
13:26:46 <ImInYourMonad> i only posted it once
13:28:46 <tychob> how can I clean this up with some monadic-foo: \x y -> if x then toUpper y else toLower y
13:29:08 <Cheshire> tychob, bool toUpper toLower
13:29:17 <tychob> :t bool
13:29:19 <lambdabot> Not in scope: `bool'
13:29:25 <Cheshire> tychob, earlier,
13:29:28 <Gracenotes> @hoogle bool
13:29:28 <lambdabot> module Data.Bool
13:29:28 <lambdabot> Prelude data Bool
13:29:28 <lambdabot> Data.Bool data Bool
13:29:31 <Cheshire>  <Cheshire> Gracenotes, bool :: a -> a -> Bool -> a
13:29:43 <Cheshire> bool true false True = true
13:29:44 <Gracenotes> Haskell' teim
13:29:47 <Cheshire> bool true false False = false
13:30:04 <Gracenotes> or just _, whatev.
13:30:26 <burp> hi
13:31:12 <burp> anyone using hdbc with postgresql? I have a "timestamp with time zone" column, and when I want to select the column data I get an exception.
13:31:24 <burp> (when I inserted the date with NOW())
13:31:39 <burp> it looks like "2009-02-27 22:25:13.445448+01"
13:32:00 <tychob> Cheshire: why isn't something like that defined somewhere?
13:32:12 <Cheshire> tychob, I just gave you a definition
13:32:18 <Cheshire> you can make
13:32:21 <tychob> in base, I mean
13:32:22 <Cheshire> MyPrelude.hs
13:32:27 <Cheshire> and then  import MyPrelude
13:32:32 * Gracenotes > "test"
13:32:32 <christastrophe> ok just for fun. can this be re-written without named arguments: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1832#a1832
13:32:44 <Cheshire> @pl chunkWithPad n c s = pad n c $ chunk n s
13:32:45 <lambdabot> chunkWithPad = ap (flip . ((.) .) . pad) chunk
13:32:53 <Gracenotes> -.-
13:33:00 <christastrophe> ah. now that is a useful bot!
13:33:04 <christastrophe> good to know :)
13:33:12 <tychob> @pl \x -> if x then 1 else 2
13:33:12 <Gracenotes> hm. there must be some way
13:33:12 <lambdabot> flip (flip if' 1) 2
13:33:37 <tychob> what is if'?
13:33:48 <wolverian> @src if'
13:33:48 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:33:49 <Gracenotes> if', the function I described earlier. Bool -> a -> a -> a
13:34:03 <tychob> where is it?
13:34:05 <tychob> @index if'
13:34:05 <Cheshire> tychob,  bool 1 2
13:34:05 <lambdabot> bzzt
13:34:07 <wolverian> oh, @src doesn't know lets defined in lambdabot
13:34:14 <wolverian> tychob: @let if' = ...
13:34:21 <Gracenotes> bool true false b = if b then true else false
13:34:27 <Gracenotes> er, s/bool/if'/
13:34:35 <Cheshire> tychob, why are you scared to define a new function?
13:34:41 <Gracenotes> or did I screw that up? Yes, I most certainly did.
13:34:45 <tychob> heh
13:34:53 <pumpkin> tychob: it isn't anywhere, only @pl knows about it :)
13:35:06 <Gracenotes> if' b x y = if b then x else y -- sorry, name nazis
13:35:16 <glguy> ?pl \ b t e -> t:e:[] !! fromEnum b
13:35:16 <lambdabot> flip ((.) . (:)) . flip (:) . ([] !!) . fromEnum
13:35:19 <Gracenotes> can also be written with pattern matching
13:35:35 <glguy> err
13:35:41 <glguy> ?pl \ b t e -> e:t:[] !! fromEnum b
13:35:41 <lambdabot> (flip (:) .) . flip (:) . ([] !!) . fromEnum
13:35:50 <tychob> > if' True 1 2
13:35:51 <lambdabot>   Not in scope: `if''
13:36:12 <glguy> > let if' = (flip (:) .) . flip (:) . ([] !!) . fromEnum in   if' True 1 2
13:36:14 <lambdabot>   [2,1* Exception: Prelude.(!!): index too large
13:36:25 <pumpkin> I prefer bool over if', and its order of operations
13:36:28 <glguy> ?pl \ b t e -> (e:t:[]) !! fromEnum b
13:36:28 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
13:36:38 <ImInYourMonad> prime :: GHC.Int.Int32 , what is that?
13:36:38 <pumpkin> parameter order, that is
13:36:41 <glguy> > let if' = flip (flip . ((!!) .) . flip (:) . return) . fromEnum in if' True 1 2
13:36:42 <lambdabot>   1
13:38:09 * BMeph informs pumpkin that "hes in ur lols, killin ur smilies"
13:38:14 <Gracenotes> hm. regarding chunkWithPad n c s = pad n c $ chunk n s, I think it could possible be defined with liftA3. Not sure how though
13:38:17 <pumpkin> onoes!
13:38:20 <Gracenotes> *possibly
13:38:20 <pumpkin> not in my lulz
13:38:22 <pejo> Cheshire, where are you trying to use rpo?
13:38:54 <pumpkin> wow, today is a slow hackage day
13:39:04 <pumpkin> (in terms of number of releases)
13:39:26 <pejo> pumpkin, close to ICFP deadline, maybe?
13:39:39 <Cheshire> pejo, nowhere .. I just half read an article in JFP about it and it seems interesting
13:40:28 <christastrophe> hmm. anyway you slice it rewriting chunkWithPad without named args makes it much less clear what is going on
13:40:34 <whpearson__> Anyone have any hints for making an instance of Arbitrary. I just have an simple small data that I am wanting to test.
13:41:05 <whpearson__> I have done arbitrary, it is coarbitrary that is puzzling me.
13:41:15 <BMeph> Gracenotes: Well, chunk s = liftA2 (map . take) (iterate . drop) n ... :)
13:41:16 <christastrophe> if ghc compiles them all to relatively the same code than using the most clear form is likely best... at least right now
13:41:24 <christastrophe> this thing: chunkWithPad = ap (flip . ((.) .) . pad) chunk
13:41:27 <christastrophe> that just confuses me :)
13:41:30 <pumpkin> whpearson__: do you need functions of your Arbitrary type?
13:41:44 <pumpkin> otherwise, it's pretty safe to leave coarbitrary undefined
13:42:12 <whpearson__> I'm comparing them, and ordering them.
13:42:24 <christastrophe> BMeph, gotta ask, do you know that off the top of your head, or did that take a while to work out?
13:42:46 <Gracenotes> BMeph: mm, yes. The thing made me think of applicatives is how both chunk and pad in chunkWithPad take n as an argument
13:43:23 <pumpkin> whpearson__: I mean, do you have any higher-order functions that need arbitrary function input?
13:43:29 <pumpkin> involving your type
13:43:53 <Gracenotes> the thing that.
13:44:26 <Gracenotes> @hoogle chunk
13:44:26 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
13:44:26 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
13:44:26 <lambdabot> Data.ByteString.Lazy.Internal chunkOverhead :: Int
13:45:01 <BMeph> christastrophe:  ...umm, both? :)
13:46:07 <christastrophe> BMeph, that is encouraging... but its a bit disouraging as well :)
13:46:14 <BMeph> Gracenotes: Sounds like a Reader Applicative case to me. :)
13:46:31 <Gracenotes> or plain ol' function applicative
13:46:41 <pastah> Can't make a derived instance of `Eq Rule'
13:46:42 <pastah>       (`Rule' has non-Haskell-98 constructor(s))
13:46:45 <whpearson__> pumpkin: Nope, it seems I am okay.
13:46:50 <Gracenotes> hm. thinkin' about formulating it
13:46:52 <pastah> this was caused by GADTs... what to do?
13:47:00 <pastah> derive my own? is there a cheat+
13:47:02 <Cheshire> pastah, write a Eq instance manually
13:47:26 <pastah> @faq can i cheat ghc to make an automatic Eq instance for my GADT
13:47:26 <lambdabot> The answer is: Yes! Haskell can do that.
13:47:42 <christastrophe> here is my chunk: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1833#a1833
13:47:47 <Cheshire> pastah, you can write the GADT with any extra bits omitted, as a regular ADT, and then a function that erases from GADT -> ADT, to use the derive Eq on it
13:47:51 <christastrophe> a lot less point free :)
13:49:05 <Cheshire> i.e.  data Eq x y where REFL :: Eq x x & data UntypedEq = UntypedREFL deriving Eq, strip REFL = UntypedREFL,   x == y = (==)`on`strip
13:49:35 <christastrophe> oh well, thats all for today.
13:50:03 <Heffalump> Cheshire: that doesn't work if your GADT encodes existentials
13:51:41 <Cheshire> Heffalump, I don't understand
13:51:53 <Cheshire> would you show me an existential ?
13:52:07 <Heffalump> data Foo where Foo :: a -> Foo
13:52:43 <Cheshire> yes:  data Foo where Foo :: a -> Foo ; data UntypedFoo = UntypedFoo ; strip (Foo _) = UntypedFoo
13:52:56 <Heffalump> that won't make for a very good Eq instance
13:53:03 <Heffalump> as in, it'll equate unequal things
13:53:22 <Cheshire> look on the bright side, it's the best possible Eq instance :p
13:53:26 <Cheshire> best meaning smallest
13:53:57 <Cheshire> if you used:  data Foo a where Foo :: a -> Foo a,  then you could check the a's being equal
13:54:00 <oms> I've got a head-scratcher if anyone would be willing to take a look: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1834
13:54:23 <pumpkin> fgl looks awesomely featureful
13:54:30 <pumpkin> but the documentation is lacking
13:54:38 <pumpkin> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-DFS.html
13:54:46 <Heffalump> it's not the best possible instance for Data Foo where Foo :: (Typed a, Eq a) => a -> Foo
13:54:49 <oms> that snippet runs in a small space, but taking out {-# SCC "stepBase" #-} makes it consume about 70MB/sec that never gets returned
13:54:59 <Cheshire> Heffalump, oh I didn't consider typeclasses
13:55:55 <Cheshire> even encoding a type like    Foo :: Type a -> a -> Foo,  you could give a better Eq instance
13:55:57 <oms> anyone have any idea how just adding profiling can make something work?
13:56:16 <Heffalump> oms: well, it'll perturb code generation
13:56:25 <Heffalump> it shouldn't have that effect, obviously, I suggest asking ghc-users
13:56:42 <Heffalump> anyone familiar with gtk2hs around?
13:56:52 <oms> so I should look more generally toward ghc people?
13:57:14 <Heffalump> oms: you'd need an expert at reading GHC core to figure this out, certainly
13:57:23 <whpearson__> oms: Try bug reporting it?
13:57:45 <oms> is it immediately obvious, disregarding the SCC's, why that would cause a grotesque space leak?
13:58:12 <oms> i'm too new to recognize space leaks
13:58:39 <BMeph> christastrophe: I made your chunk function "chunkier", but not much: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=1833#a1835
13:59:29 <Cheshire> BMeph,  that gives me the idea:   chunk n (splitAt n -> (x1, x2)) = x1:chunk n x2
14:00:46 <BMeph> Cheshire: Yes...! ;)
14:00:55 <Heffalump> oms: I can't spot anything obvious.
14:01:03 <Heffalump> Did you try a heap profile?
14:01:50 <BMeph> oms: What does...never mind, Heffalump said it. :)
14:02:22 <Heffalump> oms: I'm a little confused by your zipWith in step, because it seems like steps will always be length 3
14:02:55 <Heffalump> hmm, also, oscs might be a bit dubious
14:03:09 <Heffalump> foldl (+) is a bad idea, because it builds up a huge supension
14:03:14 <BMeph> preflex: @seen centrinia
14:03:14 <preflex>  centrinia was last seen on #haskell 3 days, 25 minutes and 54 seconds ago, saying: Hmm.
14:03:19 <Heffalump> I suspect foldl (zipWith (+)) is also asking for some trouble if heads is long
14:03:24 <BMeph> mauke++
14:03:43 <oms> heads should be length 1024 each time
14:04:14 <oms> and what would be better than zipWith if I know what length I'm looking at?
14:04:31 <Heffalump> I'm not sure, actually.
14:04:45 <Heffalump> but 1024 elements should be ok anyway
14:04:52 <Heffalump> and the suspension will collapse once it's done
14:05:06 <Heffalump> just run a heap profile, that should point out the suspect pretty fast even if you can't SCC everything without the problem disappearing
14:05:06 <oms> hm
14:05:21 <oms> i did that, it did pinpoint it to step
14:05:27 <oms> should have mentioned that
14:06:00 <Heffalump> ok, can you talk me through how step works a bit. Isn't steps always of length 3?
14:06:01 <oms> that's why I added the SCC's, to get a line culprit
14:06:31 <oms> the idea is, in step steps n sts
14:06:54 <oms> sts is a list of states, which are complex numbers
14:07:15 <oms> steps is a constant that each element is iteratively multiplied by
14:07:40 <oms> ach, let me go through this again :)
14:07:56 <oms> the names aren't helpful mainly b/c this morphed completely from a different function
14:08:36 <ImInYourMonad> http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast , http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1836#a1836 , so how do I not blow the stack averaging a 1 million elem list?
14:08:42 <Heffalump> the reason I think that steps is always of length 3 is that step is only ever called with ss as its first parameter
14:08:51 <oms> steps is always length 3
14:09:00 <Heffalump> ok, so if steps is always length 3, then so is fs
14:09:05 <oms> it should be constant length during a run
14:09:24 <oms> fs is [[Cpx Double]]
14:09:30 <oms> but yeah, the first dimension is always 3
14:09:37 <oms> then oscs just sums the 3 lists
14:09:49 <Heffalump> so then heads is always length 3, and tails is empty, making head tails an error
14:10:28 <oms> oh, i hadn't thought of that
14:10:46 <oms> that's odd though, given that it does do what i expected it to do :)
14:10:49 <Heffalump> so I'm amazed your program works at all ;-)
14:11:03 <oms> right, and correctly to boot
14:11:21 <Heffalump> I suspect you are not running what you pasted.
14:11:26 <oms> i am
14:11:51 <oms> your suspicions are unfounded!
14:11:57 <Heffalump> ok, I'll try running it. But if my computer blows up I'm going to come after you with a machine gun ;-)
14:12:12 <Gracenotes> @src forever
14:12:12 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:12:13 <oms> should just make noises, if /dev/audio exists for you
14:12:32 <Heffalump> actually, it doesn't. I guess that means it won't get very far.
14:12:35 <seliopou> oms: how are you compiling this?
14:12:38 <Heffalump> I could change /dev/audio to something else.
14:12:51 <oms> seliopou: ghc --make whatever.hs
14:13:02 <oms> occasionally w/ -auto-all -prof
14:13:12 <seliopou> and when do you see the space leak?
14:13:15 <seliopou> in either case?
14:13:17 <Heffalump> ok, I concede that it does work :-)
14:13:28 * Heffalump reads it more carefully
14:13:31 <oms> the leak pops up when *not* profiling
14:13:49 <oms> when the SCC stepBase is being profiled, it doesn't leak
14:13:54 <oms> when not being profiled, it does
14:15:23 <oms> hah, now i can't reason why fs is not 3 long
14:15:30 <oms> thanks Heffalump
14:15:52 <Heffalump> if you put a trace in and run it, step only gets called once.
14:16:09 <oms> but it makes sense that it's wrong
14:16:13 <Heffalump> oh, because oscs is an infinite list
14:16:14 <oms> why's that?
14:16:45 <Heffalump> so it doesn't matter that head tails is an error
14:17:03 <Heffalump> why's what? oscs an infinite list?
14:17:11 <oms> no, step gets called once
14:17:17 <Heffalump> because oscs is an infinite list
14:17:43 <Heffalump> so the program spends all its time processing the oscs from the first iteration of step
14:18:02 <Heffalump> it's possible that the listPutter thread actually dies with an error from the 'head tails'
14:18:13 <Heffalump> I can't remember what happens to exceptions in non-main threads
14:18:33 <oms> it can't die, since it's still putting things in the MVar, since mainLoop is still making noise
14:18:48 <Heffalump> it only ever puts one thing in the MVar
14:18:52 <Heffalump> it's just that that thing is an infinite list
14:19:16 <oms> ah hah
14:19:31 <Heffalump> I still have no idea about your space leak, mind
14:19:45 <oms> that would probably solve it
14:19:51 <Heffalump> well, its probably oscs that is leaking
14:20:18 <ImInYourMonad> god setting up package sin haskell seems like circle-fest. package X depends on package Y that depends on package Z that depends on old package Y that depends on hidden package A ...
14:20:22 <Heffalump> but it's not obvious to me why
14:20:36 <Heffalump> ImInYourMonad: yeah :-( cabal-install is your firend, once you get it installed.
14:20:48 <ImInYourMonad> well thats when i ahve the problem...
14:21:00 <seliopou> oms: like everybody else I don't know about the space leak
14:21:15 <seliopou> however, I compiled just the step function with and without profiling to core
14:21:18 <burp> I guess this is asked often: why are haskell binaries that huge? :>
14:21:25 <seliopou> it's interesting to see what's generated
14:21:35 <Heffalump> burp: because GHC doesn't have dynamic linking, so all the libraries are compiled in statically
14:21:39 <seliopou> profiling looks like it's been ANF'd
14:21:46 <oms> ANF'd?
14:21:47 <seliopou> non-profiling everything's inlined
14:22:01 <burp> Heffalump: when I check a binary with "ldd" it seems it is dynamically linked
14:22:17 <seliopou> A-normal form
14:22:25 <Heffalump> burp: only against C libraries
14:22:34 <seliopou> all the intermediate values are named, but that might just be from how you wrote your program to begin with
14:22:34 <Heffalump> the Haskell libraries are all static
14:22:35 <burp> oh, I see
14:22:43 <burp> ok, that explains it, thanks
14:23:36 <dons> we need a name for the situation where people make a performance complaint, which gets analysed, only to discover they were a) using hugs, or b) using ghci, or c) using ghc -Onot
14:24:10 <Heffalump> dons sounds a bit bitter :-)
14:24:42 <Heffalump> I have a performance complaint, I want stream fusion in GHC! And my problem with dictionaries fixed.
14:24:43 <dibblego> dons, instead, set minimum criteria for the acknowledgement of a performance complaint
14:26:11 <quicksilver> dons: I want a pony!
14:26:18 <oms> hm, now i need to work out a function f like splitAt where f 1 ["abc","def"] = (["a","d"],["bc","ef"])
14:26:25 <Heffalump> write a wiki page which documents the steps to follow, and insist that performance complaints include a statement of having done so
14:26:30 <Heffalump> oms: map (splitAt n) ?
14:26:36 <dolio> Is stream fusion still not up to spec on concatMaps for direct inclusion in GHC?
14:26:40 <Heffalump> oh, with an unzip
14:26:56 <oms> Heffalump: you'd think :)
14:26:59 <amaron> anyone played with hdbc-odbc?
14:27:44 <oms> you figured out i'd need the unzip much faster than i did
14:28:18 <Heffalump> I imagine that's because I have rather more experience with Haskell than you do :-)
14:28:25 <quicksilver> > unzip . map (splitAt 1) $ ["abc","def"]
14:28:26 <lambdabot>   (["a","d"],["bc","ef"])
14:28:31 <oms> much better now, though, no leak
14:28:38 <quicksilver> oms: it's another unzip, isn't it?
14:28:47 <oms> > map (splitAt 1) $ ["abc","def"]
14:28:49 <lambdabot>   [("a","bc"),("d","ef")]
14:28:55 <oms> quicksilver: yeah
14:29:06 <oms> Heffalump: you probably do have much more experience
14:29:09 <oms> so thanks for the help
14:29:15 <Heffalump> no problem
14:29:48 <oms> i do have an odd issue though where the cpu time it takes increases steadily
14:29:55 <oms> when it hits 100% though, nothing changes
14:30:00 <oms> it can still keep up somehow
14:30:26 <Heffalump> something to do with one thread being starved by the other, I guess?
14:30:31 <pejo> Heffalump, what is your problem with dictionaries?
14:30:34 * Heffalump can't think of an obvious explanation, though
14:30:42 <oms> maybe
14:31:06 <oms> ah dammit, it works, but now it just has horrible performance
14:31:09 <oms> kinda yay!
14:31:19 <Heffalump> pejo: http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016667.html
14:31:45 <Cope_> Hello... I don't really know haskell, but I know you guys know about functional programming...
14:32:20 <Heffalump> pejo: so one question is why the infinite list isn't an appropriate design for your program (space leak aside)
14:32:34 <Twey> Cope_: Well... you'd hope so :-P
14:32:37 <Cope_> I want to iterate over a number of lines... and if the whole set of lines fails to include a certain word, say "missing word"
14:32:52 <Cope_> How can I do that without saving state?
14:32:57 <Twey> Easily
14:32:59 <dibblego> @type find
14:33:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:34:14 <Cope_> Twey: what I mean is - how does it work conceptually - I don't know enough haskell to understand a haskel example - but I'm trying to learn how to *think* functionally
14:34:23 <Twey> main = case find ("this" `isInfixOf`) lines of Nothing -> putStrLn "Missing word"; _ -> return ()
14:34:39 <Twey> Cope_: It's all in the return value
14:34:41 <monochrom> As soon as you see the word, exit the loop.
14:34:51 <Twey> You have a function that recurses over the lines, checking each for the word
14:35:00 <monochrom> The fact that you exit the loop prematurely tells you the word is found.
14:35:01 <Twey> If you find it, you return one value; if you don't, you return another
14:35:17 <Cope_> monochrom: right - and that's the problem
14:35:20 <monochrom> The fact that the loop reaches the end normally tells you the word is not found.
14:35:21 <Twey> In the calling function, you can then just check which value was returned
14:35:41 <Cope_> monochrom: because if the word is missing on line 15, we'll exit before we get there
14:35:41 <harbl> if any (== "word") (words yourInput) then "Found word" else "Missing word"
14:35:42 <Twey> (the end being to return a certain value that says 'not found'; Haskell has a type for this called Maybe)
14:35:47 <monochrom> "program counter" is state too. even pure functional languages have that state.
14:35:53 <pejo> Heffalump, that infinite list thing wasn't for me, I think?
14:36:03 <Heffalump> pejo: oops, sorry
14:36:22 <Heffalump> oms: so one question is why the infinite list isn't an appropriate design for your program (space leak aside)
14:36:54 <monochrom> Why do we exit before we get to line 15?
14:37:06 <Cope_> well the algorithm goes:
14:37:56 <Cope_> iterate over the lines, check if the word is there - if it is, exit
14:38:02 <Cope_> at leats that's what I thought you said
14:38:05 <harbl> @src any
14:38:05 <lambdabot> any p =  or . map p
14:38:09 <harbl> @src map
14:38:09 <lambdabot> map _ []     = []
14:38:09 <lambdabot> map f (x:xs) = f x : map f xs
14:38:12 <oms> Heffalump: what are my options with Haskell?  the infinite list design seems natural to the language
14:38:38 <oms> The idea of listPutter is to break up the list
14:38:51 <harbl> Cope_: (\w -> w == "word") is a function that checks whether its input equals word.
14:38:55 <Heffalump> oms: but why?
14:38:59 <oms> by explicitly calculating n values at a time and saving the state necessary to generate more next time
14:39:11 <oms> why what, specifically?
14:39:17 <Heffalump> oms: why break it up?
14:39:19 <monochrom> That is the correct algorithm. If it exits before line 15, that means the word appears somewhere before, maybe line 14, or line 13, ...  which is your specification.
14:39:23 <harbl> Cope_: split your input into words, apply that to everything, or together all the results.
14:39:56 <oms> Heffalump: my logic initially was to avoid making the generation completely asynchronous with the demand
14:40:18 <harbl> @let hasWord word input = any (== word) (words input)
14:40:19 <lambdabot>  Defined.
14:40:22 <Heffalump> if you just use one thread and a single infinite list, the generation will be completely synchronous with the demand
14:40:25 <oms> Heffalump: since it's audio, if the generation doesn't occur close enough to the writing, there'll be gaps
14:40:26 <harbl> > hasWord "foo" "foo bar baz"
14:40:28 <lambdabot>   True
14:40:29 <whpearson__> @hoogle [[a]] -> [a]
14:40:29 <lambdabot> Prelude concat :: [[a]] -> [a]
14:40:29 <lambdabot> Data.List concat :: [[a]] -> [a]
14:40:29 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
14:40:41 <harbl> > hasWord "foo" "barf fart stink"
14:40:42 <lambdabot>   False
14:40:42 * ddarius would use a function returning Either String String
14:41:03 <oms> I think I found that hPutStr blocks on /dev/audio
14:41:17 <oms> roughly for as much time as it takes to play it
14:41:25 <Heffalump> oh, so it stutters?
14:41:47 <oms> yeah, it'll take as much time as it needs to generate samples just waiting for hPutStr to accept them
14:42:04 <ImInYourMonad> how do I do Lisps cond in a monad? case?
14:42:37 <Heffalump> I think you could use a Chan instead of an MVar, then.
14:42:41 <Cheshire> cond ((True, r):_) = r ; cond (_:cases) = cond cases
14:42:46 <Cheshire> (-->) = (,)
14:42:55 <Cheshire> lets you write  cond [ p1 --> r1, p2 --> r2, ... ]
14:42:55 <Heffalump> that ought to provide buffering, and remove the need to explicitly chunk the data
14:42:58 <monochrom> If you pump a lot of bits into /dev/audio, you are blocked because there is a finite-buffer thing going on.
14:43:27 <Heffalump> But if /dev/audio buffers at all, I'd have thought that'd be enough to give your program some time to generate more bits while the buffered ones are being played.
14:44:06 <oms> hmm, i didn't know about Chans
14:44:16 <monochrom> Well that's the default behaviour. There are ioctl calls to insist "don't block". There is also multi-threading programming.
14:44:38 <oms> monochrom: multi-threading is the approach i have
14:44:47 <oms> one thread just writes, the other fills an mvar
14:44:55 <Heffalump> also, if you really must chunk your data, just generate the infinite list and then chunk that infinite list. No need to mess around with state.
14:45:22 <oms> it looks like i have to write to a chan 1 value at a time?
14:45:44 <Heffalump> yes, but mapM_ ought to do what you want for that
14:45:58 <oms> okay, there won't be an absurd overhead to that?
14:46:05 <Heffalump> ah, that I don't know
14:46:17 <monochrom> State is so overrated. Few programmers realize that control-flow already gives you finite state, and accumulator parameter gives you infinite state.
14:46:18 <oms> sequence_?
14:46:32 <Heffalump> mapM_ f xs = sequence_ (map f xs)
14:46:47 <oms> hooray
14:46:52 <oms> so, not better
14:46:52 <ddarius> State is so underrated.
14:47:10 <Heffalump> I'd still like to understand why a single-threaded program doesn't work.
14:47:16 <Heffalump> If /dev/audio buffers then it really ought to
14:47:32 <Heffalump> If you have stuttering I wonder if your memory leak was the cause.
14:47:47 <monochrom> You can use select for single-threaded programming.
14:48:04 <oms> I don't have stuttering anymore, except for when i increase the length of ss from 3 to about 8
14:48:13 <oms> at which point the CPU time is blocking it
14:48:15 <Heffalump> monochrom: why would you need select?
14:48:28 <oms> profiling tells me there's 100% of the time spent in main and 0% elsewhere
14:48:29 <Heffalump> if hPutStr just blocks until it can accept more input, what's the problem?
14:48:43 <Heffalump> oms: did you compile with optimisations?
14:48:50 <oms> nope, i'll try it
14:49:15 <monochrom> If you wait for /dev/audio to be ready and then start computing things to feed it, that's too late.
14:49:31 <Heffalump> monochrom: not if it's buffered
14:49:34 <gwern> maybe ghc should start defaulting to -O2. so many new people seem to not do that
14:49:42 <monochrom> I see. I guess.
14:49:49 <oms> -O2 isn't much better
14:49:59 <Heffalump> do you still have a space leak?
14:50:02 <oms> 8 works, but I tempted fate with 16 and it's bad
14:50:06 <oms> no, which is nice
14:50:20 <Heffalump> what does profiling say now?
14:50:37 <gwern> huh. would you believe no one has done tab completion via bayesian methods?
14:50:48 <Heffalump> and what design does your code have now, the accidental single infinite list from your hpaste, or something different?
14:51:25 <ddarius> gwern: I highly suspect that cell phones have tried it.
14:51:40 <oms> it's basically the same, except i corrected the splitAt to unzip $ map
14:51:51 <ddarius> gwern: For things like IDEs, I don't see what the point would be except perhaps to order the list.
14:51:52 <Heffalump> ok, so you are using the explicit chunking
14:52:05 <oms> profiling is still 100% in main, 0% elsewhere (how can this be)
14:52:09 <monochrom> gcc doesn't default to -O2 either. That default is imperative. You want C newbies to confirm that tail-calls consume stack space.
14:52:38 <Heffalump> oms: errm. Dunno.
14:52:39 <gwern> ddarius: all the completions I've seen on stuff like cellphones have been 'most common word with the current prefix'
14:52:39 <ddarius> monochrom: So they think that recursion is expensive?
14:52:45 <dons> shapr: "I can say that Boston has five companies doing Haskell work"
14:52:50 <dons> how many of these are on the industry page?
14:52:51 <monochrom> Yeah. I'm a conspiracy theorist on this.
14:53:12 <Cheshire> does anyone know some intro texts about typed rewrite systems?
14:53:12 <oms> anyway, i've gotta go, but thanks for the help
14:53:15 <ddarius> monochrom: So it's imperative for imperative programmers?
14:53:21 <Heffalump> I still think you should try the single infinite list in a single thread.
14:53:30 <monochrom> Yeah, that one is an important pun. :)
14:53:33 <oms> so, wait, let me get it right
14:53:48 <oms> generate the list, then just write the whole thing to /dev/audio?
14:53:52 <Heffalump> yep
14:53:57 <oms> there's got to be some reason i didn't do that
14:54:07 <oms> i might be back later with that reason :)
14:54:14 <Heffalump> I'll be asleep :-)
14:54:23 <oms> probably good
14:54:41 <shapr> dons: I dunno
14:54:47 <oms> i think part of the reason is i eventually want to control the sound via user input
14:54:56 <shapr> dons: But I can think of three of them off the top of my head.
14:55:02 <oms> so part of the chunk will be reading input and acting accordingly
14:55:04 <Heffalump> oms: ok, fair enough
14:55:10 <gwern> fun. the installed bash-completion package - doesn't work with bash
14:55:10 <Heffalump> but your chunking solution won't really work very well for that either
14:55:15 <oms> unless there's a better way to replace the inf-list in the middle
14:55:34 <oms> well, haskell plus synchronous user input is dodgy by all the methods i can think of
14:56:52 <oms> is there a general solution for that kind of thing?
14:57:35 <Heffalump> nothing completely obvious, but a variety of options, I think. I'd probably look at Conal Elliott's reactive work first to see if that fitted.
14:57:46 <gwern> dons: is it possible that this WP scripter's problem could be solved by lazy bytestring?
14:58:15 <Gracenotes> is there a nice way to write, when (isJust msg) (func (fromJust msg) >> return ())? Because that's ugly. func :: (Blah -> M ()), msg :: Maybe Blah, entire expression :: M ().
14:58:27 <Gracenotes> maybe (return ()) ((>> return ()) . func) msg doesn't seem that much better.
14:58:46 <Cheshire> Gracenotes,  isJust  and  fromJust  are logically together but physically separate
14:58:56 <Cheshire> that's the first thing I would suggest to improve
14:58:56 <Gracenotes> actually, func :: (Blah -> M a). which complicates things.
14:58:58 <BMeph> monochrom: I don't like conspiracy theorists.
14:59:02 <oms> i'm gonna idle on another computer, later
14:59:08 <Gracenotes> Cheshire: that's why I said it's ugly.
14:59:09 <monochrom> hahaha ok
14:59:25 <BMeph> monochrom: I always have the feeling that there's something they're hiding...
14:59:27 <Cheshire> BMeph, the thing about conspiracy theorestists is they are mostly NSA agents employed to water down the REAL conspiracies
14:59:37 <monochrom> hahaha that's great
14:59:39 <harbl> liftM func msg?  something like that, Gracenotes?
15:00:08 <BMeph> Cheshire: A-HA! I Knew those conspiracy guys were up to something! ;p
15:00:17 <monochrom> logically together but physically separate? long-distance relationship?
15:00:20 <Gracenotes> that works, and I had that before, but it yields M (Maybe Blah), not M (). I suppose I could just do return () afterwords
15:00:23 <Cheshire> lol
15:00:31 <Cheshire> Gracenotes, use >>=
15:01:03 <Cheshire> you could have somethig like
15:01:13 <Cheshire> :t maybe
15:01:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:01:23 <Gracenotes> harbl: actually, it doesn't work
15:01:26 <Cheshire> execute = maybe (return ()) (>> return ())
15:01:32 <Gracenotes> it yields Maybe (M Blah)
15:01:34 <Cheshire> then execute =<< func $ msg
15:01:36 <amaron> I'm having trouble with HDBC.ODBC, I cannot even connect to db: odbc returns error for sqlGetInfo : invalid string or buffer length (within odbc)
15:01:39 <Cheshire> wouldn't that work ?
15:01:46 <amaron> anyone had similar problem?
15:01:48 <Cheshire> oops
15:01:58 <Cheshire> execute (msg >>= func)
15:02:14 <dons> gwern: maybe, i'm not clear what his problem is yet. probably he doesn't want to load 1T into memory though, I bet.
15:02:19 <Gracenotes> Cheshire: yes, although it's not like I'm going to use execute elsewhere
15:02:42 <Cheshire> Gracenotes, since you are doing functional programming  it's ok to .. write functions :
15:03:31 <Cheshire> even if you used it once
15:03:38 <gwern> @seen dcoutts
15:03:38 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 5h 8m 38s ago.
15:03:41 <gwern> @seen dcoutts_
15:03:41 <lambdabot> Last time I saw dcoutts_ was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
15:03:41 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
15:03:41 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 1m 3d 17h 33m 40s ago,
15:03:41 <lambdabot> and .
15:03:42 <ddarius> :,,:``:..
15:03:46 <Gracenotes> mm, gotch... wha
15:04:06 <gwern> anyone know whether cabal's 'package-url:' field is supposed to be used for repo addresses?
15:04:28 <monochrom> lambdabot may as well start up its own irc server to join freenode. :)
15:04:29 <Gracenotes> Cheshire: good point.
15:04:46 <dons> umm. don't do @seen in the channel.
15:05:19 <Gracenotes> @type maybe (return ())
15:05:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
15:05:27 <ddarius> dons: Often @seen is used to kill two birds with one stone.  Normally the output is much shorter.
15:05:29 <Gracenotes> imho something like this would be generally useful
15:05:36 <tomh> lol why is there no #haskell.nl
15:05:57 <Gracenotes> but there I go, suggesting functions I happen to need and golly if I can't write 'em
15:06:50 <gwern> @ask dcoutts the cabal manual isn't too clear, is package-url: just for .tgz links, or for VCS repo URLs as well?
15:06:50 <lambdabot> Consider it noted.
15:06:54 <gwern> @flush
15:07:13 <ImInYourMonad>  given some vectors on the form: [4,3,0,0,0,0,2,3,3,4] whatis thebest way to calculate the distance between them? just summing them is not tat i want. they represent movie-ratings(1-5,0 means havent watched it). some sort of deviation-per-unit-measuer is what i need i think
15:08:10 <tomh> maybe cosine similarity
15:08:54 <tomh> or tanimoto co-efficient
15:10:32 <shapr> tomh: Clearly you should create #haskell.nl!
15:10:51 <tomh> there are lots of haskell people here
15:11:08 <tomh> every respectable university with computer science teaches haskell
15:11:15 <tomh> in holland
15:11:30 <shapr> Exactly! Thus you should create #haskell.nl!
15:11:45 <tomh> ye i can just hang there and see who joins
15:13:01 <shapr> tromp_: Hey, I'm probably visiting NYC in 8 days to meet a visiting Haskeller, want to meet up? Do you know any other NYC Haskellers who'd like to hang out?
15:13:49 <amaron> where would you go: in Monad Bar?
15:14:12 <tromp_> hi Shae
15:14:18 <shapr> hoi tromp_
15:14:24 <shapr> hoe gaat het?
15:14:32 <tromp_> het gaat zijn gangetje:)
15:14:36 <burp> how can I use the pointfree plugin?
15:14:49 <tromp_> where are you visiting from?
15:14:49 <burp> !unpl x
15:15:01 <shapr> tromp_: I'm visiting from Boston.
15:15:24 <tromp_> are you there for the whole weekend?
15:15:30 <shapr> tromp_: zijn gangetje means "It's going steadily" ?
15:15:39 <burp> !help
15:15:51 <tromp_> yeah,
15:15:58 <harbl> burp: /msg lambdabot @help
15:16:02 <burp> ok
15:16:18 <shapr> tromp_: I was planning on arriving on Saturday before noon, and taking the train back Sunday sometime.
15:16:32 <tomh> tromp_: you live in .ny?
15:16:35 <gwern> @pl foo x y z = f (x) $ y z
15:16:35 <lambdabot> foo = (.) . f
15:16:44 <tromp_> in the state, yes:)
15:16:50 <tromp_> not in nyc
15:16:55 <burp> @pl reverse . (drop x) . reverse
15:16:55 <lambdabot> reverse . drop x . reverse
15:16:57 <tomh> why did you leave holland?
15:16:59 <tromp_> middle of long island
15:17:06 <tromp_> for my gf
15:17:08 <burp> @pl \x -> reverse . (drop \x) . reverse
15:17:09 <lambdabot> (line 1, column 23):
15:17:09 <lambdabot> unexpected "\\"
15:17:09 <lambdabot> expecting variable, "(", operator or ")"
15:17:12 <tromp_> now wife
15:17:14 <burp> @pl \x -> reverse . (drop x) . reverse
15:17:14 <lambdabot> (reverse .) . (. reverse) . drop
15:17:14 <tomh> ok
15:17:15 <burp> oops :>
15:17:19 <harbl> @unpl reserve . (drop x) . reverse
15:17:19 <lambdabot> (\ c -> reserve (drop x (reverse c)))
15:17:30 <tomh> many haskell jobs there in the states?
15:17:45 <harbl> @unpl f . g . h
15:17:45 <lambdabot> (\ c -> f (g (h c)))
15:17:47 <Cheshire> foldN init
15:17:52 <tromp_> havent seen any in LI:(
15:18:02 <tomh> ok
15:18:10 <tromp_> apparently there's a few in nyc
15:18:10 <tomh> thats just as much as here then :P
15:18:12 <gwern> tromp_: a little surprising, with all the financials in nyc
15:19:01 <tomh> gwern: well most of them are bankrupt or about to go bankrupt :P
15:19:31 <tromp_> you got any actyivities planned in nyc yet, shae?
15:20:46 <ddarius> shapr: Bringing your unicycle?
15:21:22 <shapr> ddarius: Hm, possibly!
15:21:35 <burp> @pl f a b c d = a b
15:21:35 <lambdabot> f = ((const . const) .)
15:21:44 <burp> @pl f a b c d = a b (c d)
15:21:44 <lambdabot> f = ((.) .)
15:21:51 <burp> the owl ;)
15:22:13 <shapr> I'm trying to think of other Haskellers near NYC.
15:26:55 <bos> Man, GHC produces weird error messages sometimes.
15:27:04 <dons> ?ghc
15:27:04 <lambdabot> ghc says: Illegal polymorphic type
15:27:06 <dons> ?ghc
15:27:06 <lambdabot> ghc says: TELL SIMON: evalAbsence
15:27:07 <dons> :)
15:27:29 <bos> I have two different copies of the same function. One gets a "not in scope" error, the other doesn't.
15:27:34 <bos> They have the same types.
15:28:02 <bos> I don't know quite what to blame.
15:28:22 <asgaroth> ?ghc
15:28:22 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
15:29:25 <Nafai> Speaking of GHC messages
15:29:26 <bos> dons: any ideas? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1838#a1838
15:29:27 <tromp_> shapr, see http://lisp.meetup.com/59/calendar/9631400/
15:29:38 <Nafai> I compiled some code the other day with -Wall
15:29:51 <bos> dons: in the second function, GHC complains that "unfold" is not in scope
15:30:04 <Nafai> And it complained about some variables that shadowed functions (happened to be functions from a record)
15:30:17 <dons> bos: missing -XBangPatterns ?
15:30:22 <dons> so it thinks you're defining !
15:30:39 <Nafai> Does that mean those functions would not be accessible because of the shadowed variable?
15:30:46 <bos> dons: that was it. :-(
15:30:59 * dons remembers this one. there's even a bug report about it
15:31:05 <dons> we tried to solve it in oxford hackathon, but its icky
15:31:12 <bos> alas.
15:31:29 <Saizan> Nafai: in the scope of those variables those identifiers will refer to the variables and not to the functions
15:31:30 <bos> but the good news is that i have the streaming and unstreaming definitions of Data.Text.Lazy done.
15:31:54 <dons> sweet
15:31:57 <bos> and it looks like i can reuse most of the functions over streams to build the lazy API.
15:32:10 <Nafai> Saizan: Ok, that's what I was thinking.  I believe that would explain the behavior I was seeing.
15:32:17 <Nafai> Saizan: -Wall it is from now on I guess
15:35:30 <dcoutts> gwern: package-url: is deprecated, use the new source repository section
15:35:30 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
15:37:01 <dons> bos, yes, i hope so.
15:37:24 <Saizan> @tell nominolo re haddock: after pulling and recompiling from ghc STABLE it worked fine, thanks!
15:37:24 <lambdabot> Consider it noted.
15:39:31 <bos> dons: do you remember why you chose to have the Show instance for lazy ByteString show off the chunk structure?
15:39:53 <dons> nope
15:40:07 <dcoutts> bos: almost certainly my mistake
15:40:12 <bos> :-)
15:40:15 <bos> ok, thanks.
15:40:17 <dons> probably we don't want people to use Show annyway
15:40:34 <dcoutts> bos: for Text it should display as String does I think
15:41:07 <dcoutts> or perhaps with proper unicode symbols for things that are printable
15:42:54 <bos> dcoutts: yeah
15:43:43 <shapr> augustss: Are you in NYC eight days from?
15:43:46 <shapr> er, from now?
15:44:03 <augustss> ummm, no.  I'm in London
15:44:12 <shapr> oh, ok
15:44:57 <shapr> Hm, who else Haskell-oriented might be in NYC eight days from now?
15:45:18 <Lemmih> Me me!
15:45:32 <Alpounet> Lucky you.
15:45:34 <augustss> Howard Mansell, Adam Peacock
15:45:43 <shapr> Lemmih: Oh goodie!
15:45:48 <augustss> Adam is s fun guy!
15:45:49 <shapr> augustss: Oh, Credit Suisse guys?
15:45:53 <augustss> yes
15:46:10 <shapr> Cool, I'll email them.
15:46:20 <augustss> do that
15:51:57 <shapr> adekoba: Hiya!
15:52:04 <adekoba> shapr: hi!
15:52:35 <adekoba> shapr: ready for tomorrow
15:52:37 <shapr> adekoba: So, want to talk about any cool Haskell code you've written tomorrow?
15:52:43 <shapr> adekoba: Um, I'm sort of ready, yeah...
15:52:53 <edwardk> shapr: hah
15:52:57 <shapr> Hey, at least we have a place to meet.
15:53:01 <edwardk> true
15:53:03 <shapr> I just have to come up with something to talk about.
15:53:16 <edwardk> i usually do that before i invite the world ;)
15:53:19 <shapr> Yeah well.
15:53:30 <shapr> I'm all about speculative evaluation.
15:53:53 <edwardk> yes, but you have apparently disabled speculation on all of your let bindings.
15:53:54 <adekoba> I haven't contributed very much to the community. Haskell is sort of a hobby. But I am working on an ID3 parsing library. Not really speech-worthy material.
15:54:12 <shapr> adekoba: Sounds neat to me.. I haven't seen much on binary parsing.
15:54:31 <edwardk> adekoba: no worries. come hang out. i'll try not to bore everyone too much ;)
15:54:33 <shapr> heh
15:54:48 <adekoba> edwardk: what are you talking about?
15:54:48 <shapr> edwardk can talk about anything computer sciency.
15:55:43 <edwardk> adekoba: going to cover an introduction to comonads, get folks to derive a couple, and try to see if i have time to review a practical application of them or two and if i have a TON of time dive into comonad transformers ;)
15:55:53 <edwardk> but i doubt i'll make it to the third before i hear my first yawn ;)
15:56:03 <adekoba> shapr: (the source is here, btw: http://github.com/adekoba/htag)
15:56:25 <adekoba> edwardk: sounds like I'll learn something! Neat.
15:56:34 <dibblego> edwardk, do you define a comonad as coreturn/cobind or coreturn/cojoin?
15:56:35 <shapr> edwardk: I really liked what I read today.
15:57:07 <shapr> edwardk: Oh hey, I could write QC tests for comonad instances.
15:57:15 <edwardk> dibblego: i set it up like in category extras, either coreturn/cobind or coreturn/cojoin/fmap form a complete definition.
15:57:50 <wli> What's cojoin?
15:57:51 <edwardk> dibblego: you pick, i define cobind (extend) and cojoin (duplicate) circularly
15:58:03 <edwardk> duplicate :: Comonad w => w a -> w (w a)
15:58:12 <edwardk> @type join
15:58:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:58:18 <wli> That would be nice for monads with join and bind.
15:58:19 <dibblego> edwardk, have you written anything about this already?
15:58:30 <edwardk> dibblego: yeah this thing called category-extras =)
15:58:40 <dibblego> edwardk, I mean a blog post or similar :)
15:59:01 <edwardk> dibblego: not sure. i've rambled off the explanation a dozen times in here or so
15:59:18 * wli is unclear on cobind as well, actually.
15:59:21 <edwardk> i think if i did write any blog posts on comonads i probably lost them a while back
15:59:25 <edwardk> hah
15:59:27 <whpearson__> Maths is cleverer than me :( It told me how to implement an algorithm and I didn't believe it. Although testing shows maths is right.
15:59:43 <edwardk> heh, let me throw up the first section of my slides in the google group or on comonad.com or something
15:59:48 <shapr> oboy!
16:00:16 <edwardk> i reserve the right to amend them before the talk but the first section was just the derivation of the comonad class definition and motivation for its conventions.
16:00:47 <edwardk> the next section was on practical applications, and i was just about to write it ;)
16:00:52 <edwardk> one sec
16:03:01 <wli> Hmm. The Adjunction class smells vaguely like a Galois connection.
16:03:02 <mdmkolbe> Is there a way to make ghci accept multi-line expressions?  (e.g. "(1 + \n 3)")
16:03:32 <whpearson__> Put them in curly braces?
16:03:34 <shapr> adekoba: Wow, are all those genres statically defined in the ID3 standard?
16:03:42 <monochrom> which Adjunction class?
16:04:16 <adekoba> shapr: the genres are, yes (you may be talking about frames, however)
16:04:36 <shapr> I'm browsing ID3v1
16:04:39 <edwardk> wli: thats because a galois connection is an adjunction ;)
16:04:41 <mdmkolbe> whpearson__: "{ 1 + \n 3 }" doesn't work if that is what you mean
16:04:48 <adekoba> oh, yes, the genres in ID3v1 are statically defined
16:04:52 <shapr> crazy
16:04:55 <adekoba> yes
16:05:06 <edwardk> wli: the closure operation that results is a monad given by the adjunction.
16:05:18 <whpearson__> mdmkolbe: I think I miss understood what you wanted.
16:06:05 <monochrom> wli: Control.Functor.Adjunction? Galois connection is a special case: using lattice or partial order as your category, monotonic function as functor.
16:06:44 <Gracenotes> jeez. I know \n is the way to escape it, but it looks ugly as hell -.-
16:06:45 <mdmkolbe> I have a five line expression that I would like to paste into GHCi without it barfing at me after the first newline (i.e. "\n") of input because the first line by itself isn't a valid expression.  it needs to take all five lines before it parses the expression
16:07:01 <Gracenotes> no offense to \nlovers
16:07:23 <mdmkolbe> @index Control.Functor
16:07:23 <lambdabot> bzzt
16:07:47 <whpearson__> mdmkolbe: Looking at :help it appears to be something like :{\n \n:}\n
16:08:06 <edwardk> that reminds me i need to add adjunctions and galois connections to kata's prelude
16:08:19 <mdmkolbe> whpearson__: awsome, that is just what I need
16:08:40 <whpearson__> Hmm or is that you commands you input.
16:08:57 <wli> Yeah, I just went around reading stuff and found that Galois connections are special cases of adjoint functors.
16:10:14 <edwardk> wli: they do help give a nice intution for them though. its always good to have special cases lying around =)
16:10:36 <mdmkolbe> whpearson__: I just tested it and you start a multi line with ":{" then press enter and it won't parse the input unless you have a blank line starting with ":}"
16:11:04 <monochrom> :}
16:11:15 <whpearson__> mdmkolbe: Yeah, I managed to figure that out eventually.
16:11:15 <edwardk> wli, dibblego: http://comonad.com/haskell/Comonads_1.pdf has the first section
16:11:26 <wli> okay
16:11:29 <edwardk> wli: but mind it was intended to have me narrating over so its not well motivated ;)
16:11:44 <edwardk> i hate ppt slides that say everything you're going to say outloud over them
16:12:05 <monochrom> Did you know that XStyleSheet comments are to be surrounded by (: and :) ?
16:13:18 <adekoba> anyone know what I'm doing incorrectly? getChar has changed behavior recently with ghc-6.10
16:13:21 <adekoba> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1840#a1840
16:15:23 <monochrom> Did you enter "d" "return" to get the first interaction going?
16:15:58 <adekoba> yes
16:15:59 <monochrom> If so that's normal, a C program will do that too. Line-buffering by the OS.
16:16:41 <adekoba> that's fine with me. But the next getChar reads the newline, which I didn't expect
16:16:44 <edwardk> @hoogle setBuffering
16:16:44 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
16:16:54 <edwardk> adekoba: newline is a char ;)
16:17:03 <wli> I have no idea what to use extract and extend for.
16:17:12 <edwardk> wli: thats part two =)
16:17:25 <monochrom> The "return" you pressed earlier becomes the second character.
16:17:25 <edwardk> wli: give me a couple of hours and check in and you'll have an example or three ;)
16:17:42 <adekoba> edwardk: true, but should the character which enters the first character in enter stdin?
16:18:01 <monochrom> Use hSetBuffering to disable line-buffering.
16:18:20 <wli> Canonical projections without restrictons on the comonad parameter are very un-obvious.
16:18:42 <edwardk> your app saw no input because of linebuffering until it saw the enter. then it had two chars in the buffer 'd\n' the first getchar got the first one, the second saw the \n.
16:18:45 <wli> hSetBuffering fileHandle NoBuffering
16:19:35 <wli> I guess for nonempty lists, head is a canonical projection.
16:19:59 * edwardk has to admit that he finds the IO module prelude names to be somewhat annoying. i've been using setvbuf, etc. all in posix compliant happiness for decades and i always have to guess the camelCase crap that is in that module.
16:20:33 <edwardk> er i mean the haskell98 standard io module
16:20:51 <adekoba> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1840#a1842
16:21:01 <wli> newtype NEL t = NEL (t, [t]) instance Comonad NEL where extract (NEL (x, _)) = x ; extend x = NEL (x, [])
16:21:02 <adekoba> It works, but seems verbose
16:21:09 <adekoba> it ought to just be
16:21:27 <adekoba> putStr "blah"; getChar; putStr "blah"; getChar
16:21:37 <edwardk> extend violates a law or two
16:21:43 <wli> ergh s/extend/duplicate/
16:22:04 <edwardk> check your extend against the comonad laws.
16:22:53 <wli> It's supposed to be duplicate not extend
16:23:05 <wli> cojoin and I'd have never flubbed the name.
16:23:06 <edwardk> there are plenty of non-empty list comonad options. the first is to give it access to just the tail of the list after it. that gives you a 'causal stream' comonad.
16:24:17 <edwardk> wli: it still fails ;)
16:24:33 <wli> duplicate x = NEL (x, []) fails?
16:24:54 <edwardk> yep. it typechecks, but fails a law
16:26:04 <wli> I'm totally lost, then.
16:26:06 <edwardk> check that extract . duplicate == id, fmap extract . duplicate == id, and duplicate.duplicate = fmap duplicate . duplicate
16:26:18 <edwardk> those are the comonad laws in terms of extract and duplicate
16:26:48 <edwardk> extract . duplicate should work fine. you just made singleton lists out of them.
16:27:00 <edwardk> but the others blow up unless you give each of the generated lists a copy of the tail of the list
16:27:18 <wli> fmap extract . duplicate == id is a problem.
16:28:19 <edwardk> i did a blog post on a pointed-cycle comonad, just strip off access to the front of the list and you get the causal stream comonad that you are looking for.
16:28:21 <edwardk> http://comonad.com/reader/2008/the-pointed-set-comonad/
16:29:19 <edwardk> though i tend to prefer deriving the non-empty-list comonad as a free comonad. because i can reuse other machinery
16:30:04 <wli> duplicate (x@(NEL(_, []))) =  NEL (x, []) ; duplicate (x@(NEL (_, x':xs)) = let NEL (y, ys) = duplicate (NEL (x', xs)) in NEL (x, y:ys) ?
16:30:24 <edwardk> that i'd believe.
16:30:57 <edwardk> only reason i spotted the other one is because i had made that mistake before =)
16:32:33 <edwardk> my favorite comonad is probably the pointer comonad. which consists of an array and a single index into the array. its just a variation on the 'context' comonad, but i think it tells a nice story about image filters as comonadic actions.
16:33:06 <BMeph> Well, off to read more Pierce texts. See you later...
16:33:22 <Gracenotes> hm. How would we implement stream fusion for standard Haskell lists? Using arrays sekritly?
16:33:55 <wli> Translating to state monads maybe.
16:33:55 <edwardk> Gracenotes: they already have, no? =) isn't that all the magic dons and company snuck into ghc?
16:34:14 <dolio> Stream fusion has nothing to do with arrays.
16:34:18 <trygvis> @hoogle couchmonad
16:34:18 <lambdabot> No results found
16:34:21 <Gracenotes> according to the slides, yes
16:34:45 <dons> Gracenotes: its all about sequences, and it has already been done for lists :)
16:34:45 <Gracenotes> oh, right, the slides didn't even use lists, just an intermediate stream-esque datatype
16:34:48 <dolio> stream-fusion on hackage has list functions with stream fusion.
16:34:54 <dons> there's even a paper on the list implementation
16:35:01 <Gracenotes> I mean for GHC
16:35:04 <Gracenotes> the core :)
16:35:15 <edwardk> dons: ahh its not that standard implementation yet? slacker. ;)
16:35:28 <dolio> To do it for GHC, you just replace all the definitions in base with the ones from stream-fusion.
16:35:51 <Gracenotes> won't result in any weird error messages?
16:36:01 <dons> no, there's even  a patch for it against ghc
16:36:19 <dons> to ghc, to use fusible list comps. but you don't care about that.
16:37:09 <dolio> Fusible [m..n] would be nice. enumFromTo stinks.
16:37:35 <dolio> Actually, stream-fusion doesn't have enumFromTo, anyway.
16:38:45 <wli> I'm honestly not sure what stream fusin is.
16:39:24 <dolio> I get the feeling that implementations of enumFromTo could use some optimization in general.
16:39:27 <dolio> For most types.
16:39:39 <dolio> (And other enum functions.)
16:39:49 <pejo> dolio, what is the problem with fusing [m..n]?
16:40:17 <dolio> Nothing. But using [m..n] syntax doesn't work with stream fused functions.
16:40:42 <dolio> Because it's not defined as "enumFromTo m n = unstream (enumFromToS m n)" or the equivalent.
16:43:30 <dolio> But, for instance, anything that uses numericEnumFrom(To) (which is Float and Double, at least) doesn't use build, so that won't fuse using GHC's existing fusion as far as I can tell.
16:43:36 <mdmkolbe> @source Data.Generics
16:43:36 <lambdabot> http://darcs.haskell.org/packages/base/Data/Generics.hs
16:43:43 <wli> I'm not sure what the Category class is.
16:43:49 <mdmkolbe> why is that 404?  where is it?
16:44:11 <Gracenotes> @pl \func x y -> x >>= \a -> y >>= \b -> func a b
16:44:11 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
16:44:20 <Gracenotes> :(
16:44:28 <Saizan> mdmkolbe: moved in the syb package now
16:44:37 <edwardk> wli: i define it in the beginning of the slides. Control.Category is basically an ancestor of Arrow these days.
16:45:14 <mdmkolbe> Saizan: thx that helped me find it
16:45:14 <edwardk> wli: lets you define things like the dual category (also given in the slide) that can't be made into haskell Arrows.
16:46:03 <edwardk> wli: in category-extras i have a whole Control.Category.* tower to build up the arrow properties without requiring an embedding of all of Haskell like Arrows' 'arr' does.
16:46:05 <dolio> Or lenses.
16:47:38 <wli> I'm stumped.
16:48:42 <mdmkolbe> Is there a well known name for the "data Unit x = Unit" type?  (This is for a paper where I would prefer to use predefined things for the sake of clarity and brevity.)
16:49:19 <Saizan> Proxy
16:49:46 <edwardk> wli: think about it as 'things that take two arguments, have objects and arrows between them, identity arrows for each object, and arrow composition always exists for any two arrows that connect head-to-tail at the same object and arrow composition is associative. Category represents a category by describing its Hom sets... by just looking at how it handles arrows.
16:49:57 <dolio> It's a specialization of the constant functor, at least.
16:50:04 <dolio> Const a b = Const a
16:50:22 <edwardk> er.. ignore 'the things that take two arguments' i was starting a different point of view.
16:50:53 <mdmkolbe> dolio: yep it is, but is there a predefined Const?
16:50:57 <mdmkolbe> @index Const
16:50:57 <lambdabot> bzzt
16:51:10 <edwardk> mdmkolbe: i have a couple of them in category-extras
16:51:10 <dolio> Not in the usual libraries.
16:51:25 <edwardk> mdmkolbe: functor/bifunctorial versions
16:51:27 <dolio> TypeCompose probably has one, too.
16:51:31 * wli nominates edwardk for a from-scratch redesign of the standard libraries.
16:51:47 <edwardk> wli: hah, wait til you see the kata prelude ;)
16:51:58 <mdmkolbe> wli: heh, then maybe we can get the number system right
16:52:10 <edwardk> i've accepted the fact that the redesign i want can't take place in haskell =)
16:53:10 <mdmkolbe> edwardk: due to language limitations or social limitations (e.g. backwards compatability)?
16:53:49 <edwardk> i'm heavily abusing a strange form of multiple inheritance to get it right there, but in haskell you run into the problem that some of the stuff i want can't be given a haskell type and the other half is the cultural restriction that people don't like using a separate class definition for every single method they define. they want some bundling.
16:53:58 <wli> Probably mostly social.
16:54:02 <edwardk> the rigidity of the typeclass system with respect to superclass extension is rough as well.
16:54:51 <edwardk> wli: well, in kata i can have a category of categories, and i can define a generic reader comonad that works over any category with products. i can't define either for haskell
16:55:10 <dons> hey, we're now in 3rd place on the shootout :)
16:55:15 <Nafai> Sweet
16:55:15 <wli> It'd be cool if someone ran off with Haskell's type system and did all the backward-incompatible good stuff.
16:55:19 <Nafai> Who's winning?
16:55:39 <mdmkolbe> edwardk: kata = langauge? link?
16:55:44 <edwardk> wli: i have a library around here jokingly titled "Chapter 1" in which i did that for quite a ways, but it got tedious
16:55:46 <pejo> wli, such as?
16:56:24 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gcc&box=1
16:56:45 <pejo> wli, extending type classes?
16:56:46 <edwardk> mdmkolbe: long running obsession of mine. partially implemented in dozens of flavors over the years. I probably should release something. the perfect is the enemy of the good enough, etc. no resources available online yet.  ;)
16:56:57 <dons> we're fast than C in 5 benchmarks now
16:58:37 <dolio> We need to focus on beating ATS. :)
16:58:37 <wli> pejo: I guess a fair amount of it would be the standard libraries. I'm not sure what extending type classes is.
16:58:39 <edwardk> mdmkolbe: basically think more-or-less untyped haskell with a multiple inheritance fetish
16:58:47 <dolio> Forget C.
16:58:51 <dons> hehe
16:58:56 <wli> I havre no idea what ATS is.
16:59:22 <pejo> wli, just curious about your comment aout running off with Haskell's type system, but I guess you were thinking of the standrad libraries rather than the type system?
16:59:36 <mdmkolbe> wli: ATS = applied type system
17:00:10 <dolio> Wow, haskell pidigits uses 235 times as much memory as C?
17:00:20 <dolio> Is that the one that blew up with 6.10?
17:00:21 <dons> its a GC bug fixed in 6.10.2
17:00:43 <mdmkolbe> wli: it looks like it is very ML'ish
17:00:56 <wli> pejo: Keep the type system, ditch a lot of the baggage.
17:01:12 <dolio> ATS is an evolution of Dependent ML, so...
17:01:28 <wli> pejo: Maybe throw in stuff like a real module system.
17:01:32 <dolio> Or at least, they took a lot from it.
17:01:48 <wli> I checked out their homepage.
17:01:56 <mdmkolbe> dolio: strict I presume?
17:02:10 <dolio> I think so.
17:02:29 <dolio> Dependent ML was pretty spare as far as dependent types went.
17:02:29 <wli> You have to do something special to get "laziness."
17:03:35 <dolio> They focused all the fancy stuff at compile time, unlike stuff like Agda and Coq where you could still conceivably need types around at runtime.
17:03:38 <wli> pejo: Things like syntactic sugar for things like Oleg's natural numbers in the type system sound plausible, too.
17:03:40 <dolio> Or, "types".
17:05:34 <edwardk> wli: in haskell its not so bad. you can use template haskell.
17:05:45 <edwardk> foo = $(binE 10230123)
17:06:12 <dolio> Sort of like what you might get if you revamped GHC's syntax for type-level stuff to be more convenient.
17:06:20 <mdmkolbe> Another language to keep an eye on is Lisaac.  Surprizingly fast given how dynamic an OO system it uses (almost like smalltalk).  (Though I half suspect they are cheating.)
17:06:51 <edwardk> wli: http://comonad.com/haskell/type-int/src/Data/Type/Binary/TH.hs is how i did it anyways.
17:08:35 <edwardk> mdmkolbe: not sure i'll ever get used to languages with titlecased keywords. ;)
17:08:55 <wli> The truly brilliant thing would be applying the type-level numbers to standard library affairs.
17:10:00 <wli> I'm not sure template Haskell affairs in types of standard library functions makes the most sense; best to use compiler magic.
17:10:35 <edwardk> wli: i wrote that library 2 years ago. i've maybe used it once or twice since ;)
17:12:08 <wli> Other things like typeclass-generalized fst, snd, thd, etc., first, second, third, etc.
17:12:26 <wli> (generalized via typeclasses)
17:12:46 <edwardk> wli: they are in category-extras but not quite the way you'd think ;)
17:12:53 <edwardk> wli: except third and thd
17:12:55 <wli> Get rid of fail in Monad, bring back monad comprehensions, etc.
17:13:23 <edwardk> wli: heh, at least with 'codo' sugar they couldn't make me have cofail. ;)
17:13:24 <mdmkolbe> wli: then the LHS of "<-" in do can't be a pattern match
17:13:34 <wli> The idea is that snd (_, x, _) = x, snd (_, x, _, _) = x, etc.
17:13:45 <mdmkolbe> wli: e.g. "do { Just x <- moo; return x }"
17:14:10 <edwardk> mdmkolbe: i'm ok with that, require monadzero if it is and its not the only constructor of the adt.
17:14:12 <wli> mdmkolbe: It requires generating a class constraint on such things.
17:14:14 <dolio> That just types as MonadZero instead of Monad.
17:14:44 <mdmkolbe> do we then allow "do { (x,y) <- moo; return x }"?
17:14:47 <edwardk> mdmkolbe: the haskell committee beat up poor erik meijer back in the day until he gave in on that one. it makes me sad to this day. ;)
17:14:53 <wli> I think there used to be variadic curry/uncurry stuff.
17:15:28 <mdmkolbe> (perhapse "(,)" is irrefutable which would allow it as a plain Monad)
17:15:30 <wli> Using typeclasses to handle the variadic bits, that is.
17:15:44 <dolio> Prior to 98, there was a discussion in the report about "unfailable patterns" which are patterns that could only be refuted by bottom.
17:15:51 <wli> mdmkolbe: I would say that (,), (,,), et al are irrefutable.
17:15:58 <dolio> Unfailable patterns could be matched in Monad instead of MonadZero.
17:16:13 <edwardk> mdmkolbe: i understand the motivation for fail pedagogically, but it means that a whole host of monads including some pretty fundamental ones get messed up to make that rule work.
17:16:26 <edwardk> mdmkolbe: it leads to crap liek that !@*#)(*  Error constraint on Either.
17:16:32 <travisbrady> is there a standard way of finding a substring in Haskell?  something like "hi" in "highlight" in python
17:16:50 <dolio> The reason fail is in Monad is because they wanted to get rid of unfailable patterns, but not lose using Monad to match on tuples.
17:17:00 <whpearson__> travisbrady: isInfixOf
17:17:31 <wli> It's a serious change to the language, but it doesn't change the type system.
17:17:34 * edwardk shrugs. if your pattern fails you crash. nuff said ;)
17:17:37 <travisbrady> whpearson__: thank you
17:17:39 <mdmkolbe> dolio: I presume unfailable patterns have issues where someone adding a constructor to a type could cause other code that depended on them being unfailable to brake
17:17:51 <wli> Which is why running off with the type system could easily work.
17:18:03 <mjb> travisbrady: Check out hoogle, you can do type based look-ups for questions like that.
17:18:13 <edwardk> wli: i just got rid of it, it seemed simpler ;)
17:18:15 <wli> "Run off with" means "use the type system and clobber everything else."
17:18:40 <dolio> Well, sure. I don't think that's a good argument for what they did, though.
17:18:41 <travisbrady> mgs`: thanks, i had googled around but wasn't sure how to put it, most things yielded the BoyerMoore package on hackage
17:19:08 <mdmkolbe> wli: well haskell also has a very nice syntax and you would probably want to keep ADT based type declarations
17:19:13 <whpearson__> @hoogle [a] -> [a] -> Bool
17:19:14 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
17:19:14 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
17:19:14 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
17:19:30 <dolio> I don't think that situation's likely to bite much.
17:19:35 <wli> mdmkoble: Adding a constructor to a type causing other code that depends on it to stop compiling is a good thing.
17:20:14 <wli> Where "it" means irrefutability of pattern matches against elements of the type.
17:20:16 <mdmkolbe> wli: ok, yeah.  I guess I wasn't thinking about the incomplete coverage cases
17:20:54 <mdmkolbe> wli: e.g. "foo (Bar x) = ..." where "data Foo = Bar Int |Baz Int" generates a warning as it should
17:21:05 <whpearson__> travisbrady: You can /msg lambdabot in the way I did to do it handily.
17:21:17 <wli> mdmkolbe: True enough. I'd almost see it as someone just doing backward-incompatible modifications.
17:22:42 <mdmkolbe> @index Id
17:22:42 <lambdabot> bzzt
17:22:43 <edwardk> mdmkolbe: to me do { (x,y) <- foo; whatever x y }  -- should be equivalent to do z <- foo; let (x,y) = z; whatever x y } -- the current magic pattern match behavior is a hack that is occasionally useful for Maybe.
17:23:01 <edwardk> and arguably would be more clear by filtering anyways
17:24:09 <mdmkolbe> edwardk: what happens for do { x <- Nothing; let (Just x) = z; ... }
17:24:35 <mdmkolbe> edwardk: sorry I meant: do { x <- return Nothing; let (Just x) = z; ... }
17:24:47 <Saizan> > let (Just x) = Nothing in 5
17:24:49 <lambdabot>   5
17:24:51 <Saizan> > let (Just x) = Nothing in x
17:24:52 <lambdabot>   * Exception: /tmp/2107325492560128574:71:36-53: Irrefutable pattern failed ...
17:24:58 <edwardk> mdmkolbe: it should blow up. you just used a pattern that doesn't apply.
17:25:13 <edwardk> why should the monad do magic for you?
17:26:15 <mdmkolbe> > do { let (Just x) = Nothing; return 3 }
17:26:16 <lambdabot>   <no location info>: parse error on input `}'
17:26:22 <mdmkolbe> ?
17:26:48 <edwardk> > do { let { Just x = Nothing }; return 3 }
17:26:49 <lambdabot>       No instance for (Show (t1 t))
17:26:49 <lambdabot>        arising from a use of `show' at <i...
17:27:12 <wli> do { Just x <- return Nothing ; return x }
17:27:28 <dolio> > do { ~(Just x) <- return Nothing ; return x } :: [Int]
17:27:29 <lambdabot>   [* Exception: /tmp/372067495495877419:71:32-76: Irrefutable pattern failed ...
17:27:39 <wli> :: MonadZero m => m (Maybe t)
17:27:59 <dolio> > do { ~(Just x) <- return Nothing ; return 5 } :: [Int]
17:28:00 <lambdabot>   [5]
17:28:36 <mdmkolbe> edwardk: ok, you've convinced me.  "fail" must fail!!!!
17:28:39 <edwardk> the current use case for 'fail' is a hodgepodge of concerns that belong arguably to other things that the monad in which they are happening. why should [] care about your Maybe?
17:28:51 <wli> do { Just x <- return Nothing ; return x } :: [Int]
17:28:56 <edwardk> er s/that the/than the
17:29:32 <wli> It's all crap.
17:29:39 <edwardk> mdmkolbe: it becomes a more pressing concern for me if i advocate for similar 'codo' sugar for comonads, because cofail can't even exist!
17:30:12 <dolio> What does codo look like?
17:30:12 <mdmkolbe> edwardk: what does codo look like?
17:30:23 * mdmkolbe only has a tenuous grasp of comonads
17:30:51 <Saizan> with the arrows reversed?
17:31:15 <edwardk> mdmkolbe: replace bind with extend, keep the same desugaring. its trickier to use, because monads don't often do much with the patterns they give you. whereas a comonad is always concerned with the comonad you are in.
17:32:27 <edwardk> consider the comments from http://blog.sigfpe.com/2006/06/monads-kleisli-arrows-comonads-and.html
17:32:30 <wli> Anyway, you get the idea of what I'm on about.
17:33:19 <wli> Statically bounds-checked arrays using type-level natural numbers in the standard libraries would be very sexy, of course.
17:34:37 <edwardk> fibo = 1 `fby` 1 `fby` codo (x:>y:>ys) <- fibo; x + y
17:34:44 <gwern> dcoutts: goodness, http://www.haskell.org/cabal/release/latest/doc/users-guide/authors.html#source-repos is complex
17:35:37 <bos> @pl \i -> return (m,(s,i))
17:35:37 <lambdabot> return . (,) m . (,) s
17:35:42 <bos> yum.
17:36:16 <edwardk> although i admit i think 'undo' is a funnier name for it
17:36:50 <edwardk> because it lets you take apart the comonad, look at it, then return the result you are redecorating it with locally.
17:37:46 <wli> Things that are simultaneously monads and comonads, like nonempty lists, might want something there, too.
17:38:23 <edwardk> a monad's focus is microscopic. you can only see one 'a' at a time, but can build a mountain out of it. a comonad's focus is macroscopic. you can see the entire comonad, but you can only redecorate your own little corner of it.
17:38:42 <wli> (which reminds me, nonempty lists could use some special syntax)
17:39:31 <gwern> dcoutts: also, I can't seem to add a source-repository field in a way which cabal-install can parse
17:40:46 <Gracenotes> hm. I see newtype deriving does not like MonadState very much
17:41:15 <Gracenotes> probably because of the (inherent) duplication of the parametrized state type
17:41:32 <edwardk> Gracenotes try MonadState MyState or whatever in the deriving clause
17:42:01 <Saizan> gwern: e.g. http://hackage.haskell.org/packages/archive/syb-with-class/0.5.1/syb-with-class.cabal
17:42:02 <Gracenotes> MyState happens have a kind * -> *, too.
17:42:05 * Gracenotes tries
17:42:28 <Gracenotes> so it's MyState s in the declaration. lemme try though
17:42:34 <edwardk> whatever the state thing is that you're putting in it then ;)
17:42:45 <Gracenotes> indeed it did work
17:42:49 <Gracenotes> :D
17:42:57 <Gracenotes> thanks
17:43:35 <Gracenotes> so it seems that the deriving clause pays attention to the declared parametric types
17:43:52 <gwern> Saizan: the only difference seems to be filestore doesn't use a Library section
17:46:14 <edwardk> Gracenotes: thats what i love about ghc. usually when i go 'hah, they probably didn't think of this!' they have. =/
17:46:50 <gwern> 'the dev teams thinks of everything!' \trips down a staircase carrying a basilisk corpse, and turns into stone
17:47:30 <mdmkolbe> gwern: what is that a reference to?
17:47:57 <gwern> nethack
17:48:33 <edwardk> =)
17:48:50 <edwardk> mdmkolbe: in nethack just about every possible interaction between two things i the universe that makes sense does something
17:49:38 <edwardk> mdmkolbe: picking up a cockatrice while not wearing gloves. falling into a pit while wielding one, kicking the fountain rattles the pipes, etc.
17:50:00 <dolio> They didn't think about newtype deriving for associated types, apparently.
17:50:11 <edwardk> hah
17:50:20 <edwardk> maybe they did, and cried.
17:50:40 <dolio> Well, it isn't implemented, at least. :)
17:51:09 <dolio> That makes a type families mtl a little less convenient than the existing one.
17:51:10 <Gracenotes> oh, the magic that comes with declaring monad instances
17:51:29 <mdmkolbe> dolio: that and passing partially instantiated data type families as argument to another type (that one bit me this week)
17:51:44 <edwardk> dolio: hrmm.
17:52:24 <edwardk> dolio: i keep meaning to go back and drop back in the original type family definitions for category-extras since i had written it originally for 6.10 before anyone was using 6.10 and had to backport to mptcs.
17:57:29 <Gracenotes> newtypes with non-exported constructors... oh, the power... muahahahahaha
18:00:39 <johannh> Have any of you experimented with automatic differentiation in Haskell? There are a few papers and blog posts out there that I'm working my way through, but I was wondering if anyone here had actual experience.
18:01:35 <edwardk> johannh: i've gone through the steps of deriving it a couple of times
18:03:27 <dolio> > (maxBound :: Word16, maxBound :: Char)
18:03:28 <lambdabot>   (65535,'\1114111')
18:03:36 <johannh> edwardk: Did you run into any problems? I'm working on nonlinear least squares; I'd like to remove SAS from my life, if possible.
18:03:36 <gwern> @tell dcoutts http://www.haskell.org/cabal/release/latest/doc/users-guide/authors.html#source-repos doesn't seem to make clear that you have to already be using section syntax in your .cabal - fix plskthnxbai
18:03:36 <lambdabot> Consider it noted.
18:04:43 <johannh> edwardk: In order to do the optimization, I want derivatives; hence the interest. I do want multi-dimensional derivatives, with all sorts of ugly discontinuities like max/min/if/etc.
18:05:10 <gwern> @tell dcoutts also, cabal check doesn't say anything if you use source-repo - what sort of cabal version requirement does that imply?
18:05:10 <lambdabot> Consider it noted.
18:10:24 <cognominal> is there already a name for that function?   zipFun a b c d =  c (a d) (b d)
18:10:53 <dolio> liftM2 c a b d
18:11:31 <edwardk> johannh: there was a writeup on multidimensional automatic differentiation around somewhere
18:11:50 <byorgey> most recently on Conal's blog.
18:11:57 <edwardk> johannh: discontinuities are fine, just don't rely on the derivative where its undefined ;)
18:12:55 <cognominal> dolio : that means functions as monads?
18:13:08 <cognominal> @pl liftM2
18:13:08 <lambdabot> liftM2
18:13:12 <dolio> Yes, (->) r is a monad for all r.
18:13:38 <cognominal> thx
18:14:03 <dolio> It's the same as the reader monad, without the newtype.
18:14:33 <cognominal> it is a monad of the argument type or the returned type. I am confised
18:14:43 <cognominal> *confused
18:15:13 <edwardk> cognominal: the returned type.
18:15:19 <dolio> @remember xahlee i do wonder, if any reputable computer scientist would blub out such idiotic things as this thread's lispers have been.
18:15:19 <lambdabot> Okay.
18:15:32 <newsham> (->) r = Reading,  (,) w = Writing,   ?? = Arithmetic?
18:15:45 <dolio> (->) r a = r -> a
18:16:12 <byorgey> newsham: (~>) a, perhaps? =)
18:16:28 <edwardk> cognominal: the last parameter of a monad is its parameter Monad ((->) e) has members that look like (->) e a = e -> a
18:16:51 <byorgey> what?
18:16:53 <dolio> @remember xahlee What's left are so called computer scientist, typically morons.
18:16:53 <lambdabot> I will never forget.
18:17:15 <bombshelter13> Hey guys, here's a quicky: are the operators that look like implication operators (=>, <=>) used for anything in haskell? just curious if i can use them for my own purposes.
18:17:34 <edwardk> bombshelter13: => is taken
18:17:36 <newsham> => is used for class restrictions
18:17:40 <newsham> ?type show
18:17:41 <lambdabot> forall a. (Show a) => a -> String
18:17:46 <byorgey> bombshelter13: <=> should be ok, though.
18:17:49 <johannh> edwardk: I know I've seen that multi-d AD around somewhere, but I'm working my way up to it. I'm a relative Haskell newbie, so I'm starting with the 1D examples.
18:17:54 <byorgey> bombshelter13: you can also use ==>, or -->
18:17:58 <edwardk> bombshelter13: BUT you can cheat. <= is less than or equal which has the right semantics on Bool ;)
18:18:10 <byorgey> haha
18:18:19 <edwardk> x <= y ~ y => x if you look at it through fuzzy enough goggles ;)
18:18:26 <bombshelter13> edwardk:  that is just within the context of a type though, right? is it used as an infix in normal code?
18:18:29 <johannh> edwardk: I do get a type error on an example from http://cdsmith.wordpress.com/2007/11/29/some-playing-with-derivatives/ though, that I'd appreciate if someone could explain.
18:18:40 <johannh> (Sorry, parse error.)
18:18:48 <edwardk> bombshelter13: the precedence is probably all wrong, but its legal syntax =)
18:18:57 <bombshelter13> edwardk: the <= thing is cure. :)
18:18:58 <johannh> It's on: diffNum        :: Num b        => (forall a. Num a        => a -> a) -> b -> b
18:19:02 <bombshelter13> cute rather
18:19:10 <newsham> ?type (<=)
18:19:11 <lambdabot> forall a. (Ord a) => a -> a -> Bool
18:19:13 <byorgey> > let (=>) x y = x + y  in  3 => 4
18:19:14 <lambdabot>   <no location info>: parse error on input `=>'
18:19:17 <johannh> I get: "parse error on input `=>'"
18:19:23 <dolio> I thought x <= y was x => y.
18:19:24 <byorgey> bombshelter13: you are not allowed to use => as an infix operator.
18:19:40 <dolio> > [ x <= y | x <- [False, True] , y <- [False, True] ]
18:19:40 <bombshelter13> byorgey: kay, that kinda settles the question then :)
18:19:41 <lambdabot>   [True,True,False,True]
18:19:58 <dolio> > [ (x,y,x <= y) | x <- [False, True] , y <- [False, True] ]
18:19:59 <lambdabot>   [(False,False,True),(False,True,True),(True,False,False),(True,True,True)]
18:20:02 <gnut> hi
18:20:18 <edwardk> ah i'd forgotten that post =)
18:20:27 <edwardk> one sec.
18:20:32 <byorgey> hi gnut
18:20:41 <gnut> I'm trying to use Data.IntMap with ghc-6.10.1 and it says containers-0.2.0.0 is hidden but ghc-pkg list doesn't show it in parentheses... any ideas?
18:20:50 <gnut> byorgey: hey byorgey
18:20:54 <edwardk> dolio: did i get it backwards?
18:21:12 <augustss> gnut: --make?
18:21:16 <byorgey> gnut: are you trying to build a particular package?
18:21:20 <Saizan> gnut: are you building with cabal?
18:21:34 <Saizan> if so you must add containers to build-depends
18:21:35 <gnut> with cabal
18:21:37 <dolio> Well, I'm not sure what you meant by "x <= y ~ y => x".
18:21:41 <gnut> oh...
18:21:49 <gnut> I was using runhaskell
18:22:03 <gnut> let me try that
18:22:21 <byorgey> gnut: runhaskell Setup foo  uses Cabal as well.
18:22:21 <edwardk> i meant (y => x) = (x <= y)
18:22:42 <dolio> But the arrow is pointing the wrong way, since (x <= y) gives you the truth table for x implies y.
18:22:44 <gnut> okay
18:22:46 <byorgey> edwardk: I think that's backwards though.
18:22:47 <cognominal> I am playing with the example of the mona tutorial. This gets me the parent and the grand parents : concatMap (liftM2 (++) parent wrap) . parent $ breedSheep
18:22:48 <gnut> thanks guys
18:22:53 <edwardk> dolio: yeah, i did get it backwards
18:23:00 <edwardk> oh well
18:23:05 <gnut> I thought the build-depends was only for packages that didn't build with ghc
18:23:11 <gnut> but I guess it's all packages.
18:23:21 <edwardk> so x => y = x <= y, not so pretty
18:23:25 <cognominal> now how would I write a simple function that gives me all the parent how remote they are
18:23:35 <byorgey> gnut: yup, that's how Cabal figures out what other packages are needed to build a given package.
18:23:46 <gnut> thanks
18:24:06 <gnut> should the ghc-6.10.1 package be hidden or exposed?
18:24:19 <edwardk> johannh: checking it now
18:24:21 <gnut> I saw it was hidden so I exposed it, but what's the standard?
18:24:24 <byorgey> gnut: probably doesn't matter, that package is not needed very much
18:24:31 <gnut> okay
18:24:39 <byorgey> gnut: it provides the API to call into internals of ghc
18:24:58 <dolio> [ (x,y,x >= y) | x <- [False, True], y <- [False,True] ]
18:25:01 <dolio> > [ (x,y,x >= y) | x <- [False, True], y <- [False,True] ]
18:25:03 <lambdabot>   [(False,False,True),(False,True,False),(True,False,True),(True,True,True)]
18:25:03 <johannh> edwardk: Thanks for taking a look.
18:25:05 <gnut> so why are some of the packages under the ghc-6.10.1 directory (under /usr/local/lib) and others right in /usr/local/lib?
18:25:15 <dolio> Maybe we should put in a Haskell' ticket to reverse the ordering on booleans. :)
18:25:53 <edwardk> johannh: ah you need forall's enabled. try -fglasgow-exts or whatever the new -XWhatever thing is ;)
18:25:56 <Saizan> gnut: some are installed by the ghc install procedure, the others by cabal
18:26:22 <byorgey> gnut: I think the ones inside ghc-6.10.1 are the ones that came with ghc
18:26:30 <edwardk> -XRankNTypes
18:26:30 <jberryman> how would I create an Arbitrary instance for a tree that would generate trees of random number of nodes? is it possible using QuickCheck 1.1?
18:26:40 <edwardk> actually he mentions it when he uses ghci in his example below
18:26:48 <jberryman> (I have a fromList function)
18:27:08 <edwardk> {-# LANUAGE RankNTypes #-} or whatever at the top of your file should cure it
18:27:16 <edwardk> with proper spelling anyways
18:27:20 <gnut> byorgey: yeah. they are... but I was just wondering why not put them all in /usr/local/lib? or I guess it doesn't matter
18:27:38 <Saizan> jberryman: fmap fromList arbitrary ?
18:28:03 <Saizan> gnut: it doesn't matter, the locations are registered by ghc-pkg
18:28:05 <byorgey> gnut: this is the point at which I say "stop poking around in /usr/local and write some Haskell" ;)
18:28:27 <johannh> edwardk: That fixes it, thanks.
18:29:01 <Saizan> byorgey: if he understands these parts he can become a cabal hacker! ;)
18:29:18 <byorgey> Saizan: ah, good point!
18:30:06 <johannh> edwardk: I'll play with that for a bit, then come back. :-)
18:31:18 <Saizan> ok, so, i'm trying to implement a first-class modules monad, i.e. a ReaderT that gives you dictionaries for the "modules" you're importing
18:32:08 <gnut> Saizan: byorgey: heh. thanks. I was writing some haskell... poking around was to give me a better feel for debugging my error messages  :)
18:32:11 <edwardk> saizan: so far so good, readert for environment is kind of its thing ;)
18:32:36 <byorgey> gnut: yeah, I was kidding, poking around is never a bad thing =)
18:33:27 <Saizan> though the dictionaries are like data Dict m = Dict { foo :: A -> m B }, so i end up with an infinite type like ReaderT (Dict (ReaderT (Dict ..) m)) m a
18:34:10 <Saizan> the dictionaries need to be parametrized on the monad, so that i can have circular instances
18:34:30 <edwardk> saizan: so change Dict to have a parameter and then take a fix point through reader to it
18:34:38 <gnut> byorgey: unless it deters you from "real" work.
18:34:46 <byorgey> well, true.
18:35:09 <jberryman> Saizan: I have no idea why that works, but thanks :)
18:35:10 * byorgey stops poking around on IRC and gets back to work
18:35:30 <Saizan> edwardk: that's what i did, though it felt kind of abstraction breaking
18:35:47 <edwardk> saizan: nah because each dictionary is only good for the reader through which its threaded
18:36:45 <Saizan> k
18:36:46 <edwardk> if it ONLY relies on the monad's properties as a dictionary reader you can universally quantify over m with a typeclass constraint, but it doesn't buy you much.
18:37:41 <edwardk> data Dict' = Dict' { foo :: (forall m. MonadReader m => A -> m B) } or whatever
18:37:59 <edwardk> er MonadReader Dict m
18:38:09 <edwardk> er Dict'
18:38:42 <Saizan> uhm, no, the instances will at least need other typeclass constraints
18:39:17 <edwardk> saizan: well, if you have a generic set of traits your monad is allowed to rely on bundle them up into dependencies for a single typeclass for legibility, and viola. ;)
18:39:25 <edwardk> but you lose some genericity
18:40:26 <Saizan> heh, i actually defined an HList for * -> * types to be able to import multiple modules :)
18:42:44 <Saizan> jberryman: well, the arbitrary on the RHS is the one for lists
18:42:54 <Saizan> jberryman: overloading is funny like that :)
18:45:14 <mdmkolbe> @hoogle Maybe a -> a
18:45:14 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
18:45:14 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
18:45:14 <lambdabot> Data.Monoid First :: Maybe a -> First a
18:45:42 <mdmkolbe> @pl fromJust . cast
18:45:43 <lambdabot> fromJust . cast
18:49:48 <Axman6> @src First
18:49:48 <lambdabot> Source not found.
19:26:30 <m3ga> where does one report broken links on hackage?
19:29:54 <Saizan_> depends, if they are links generated from a package description it's best to report them to the maintainer of that package
19:30:23 <mmorrow> , are you among the living?
19:30:25 <lunabot>  luna: Not in scope: `are'
19:30:45 <Saizan_> otherwise follow the report a bug link from www.haskell.org/cabal
19:34:47 <m3ga> thanks Saizan_
19:36:03 <dmwit> Hey guys, I just threw together a nifty hack in Haskell and wanted to boast a bit.
19:36:06 <dmwit> =)
19:36:13 <mmorrow> do it :)
19:36:26 <dmwit> It's for managing a "tag-like" file-system.
19:36:39 <dmwit> You can see an example, sort of, at http://www.dmwit.com/unimportant
19:36:55 <dmwit> What you can't see is that most of the "directories" there are actually links (and all of the files are).
19:37:13 <dmwit> So you can "add" tags to the current set of tags by just cd'ing down.
19:37:26 <dmwit> To "remove" or "change" a tag, you can use the two-argument version of cd...
19:37:32 <dmwit> cd oldtag newtag
19:37:35 <TomMD1> Where is the patch that has the record work resulting in allowing record field name overloading?  Head or 6.10.x?
19:37:43 <dmwit> or cd oldtag "" # to remove a tag
19:37:48 <dmwit> It's kind of fun. =)
19:38:13 <dmwit> well... cd +oldtag "", to be pedantic
19:38:19 <mmorrow> how do you add a tag to a file? "mv" i suppose?
19:38:22 <mmorrow> err
19:38:24 <mmorrow> cp?
19:38:32 <dmwit> The Haskell I wrote is for adding tags. =)
19:38:40 <dmwit> addtag cute foo.jpg
19:38:44 <mmorrow> ah
19:38:49 <dmwit> Then it does all the recursion needed to add links and stuff.
19:39:02 <dmwit> Also, it tries to be mildly smart; for example
19:39:07 <mmorrow> oh, i see. so you're manipuling symlinks
19:39:10 <dmwit> +cute/+animal is actually a link to +animal/+cute
19:39:14 <mmorrow> *manipulating
19:39:17 <dmwit> right
19:40:35 <mmorrow> cool. oleg's zfs has a neat thing going where you can use cd/cp/cat/mv/etc. for arbitraryt datatypes, not just "data Dir = File FilePath | Dir FilePath [Dir]"
19:40:56 <dmwit> huh... so, say, Set?
19:41:01 <dmwit> (i.e. basically exactly this?)
19:41:14 <mmorrow> sure, if you implemented the appropriate whatever for Set
19:41:31 <mmorrow> (whatever := whatever is needed for his zipper)
19:41:44 <dmwit> right
19:41:53 <mmorrow> but i'm not sure how exactly this is done off the top of my head
19:42:42 <dmwit> "Our threads cannot do any IO"
19:42:47 <dmwit> So is ZFS not persisted?
19:42:57 <mmorrow> dmwit: i made a darcs repo from oleg's tarball so i can grab it when necessary, it's at http://www.moonpatio.com/repos/zfs/
19:43:49 <dmwit> whoa
19:43:52 <dmwit> oh
19:43:59 <mmorrow> it has haddocks and a make.sh .... bash make.sh && ./zfs & && telnet localhost 1503
19:44:11 <mmorrow> then you can start cd'ing around
19:44:18 <Gracenotes> argh. I keep trying to write functions that match the type and end up with sneaky identity functions
19:44:26 <Gracenotes> matches the type, at least
19:44:36 <mmorrow> he has an quicky ffi binding to select in there too (which i've also stolen ;)
19:44:50 <mmorrow> (his main "OS" loop uses select)
19:45:20 <dmwit> Huh.
19:45:27 <dmwit> What's the difference between foo and foo/?
19:45:34 * dmwit doesn't understand this
19:45:49 * dmwit starts reading code
19:46:24 <mmorrow> yeah, some of the stuff behaves oddly
19:46:39 <dmwit> ah
19:46:41 <mmorrow> you can mkdir/cat/ls/cd/touch iirc
19:46:47 <mmorrow> at least, probably others
19:46:51 <dmwit> For "foo", ls foo == cat foo. =P
19:46:58 <mmorrow> ah, yeah
19:47:23 <dmwit> Actually, it just seems cat = ls, for all files.
19:47:24 <dmwit> odd
19:49:00 <dmwit> "The recursion is represented via sharing indeed." heh heh
19:49:03 <dmwit> mmorrow++
19:49:06 <dmwit> oleg++
19:49:17 <TomMD> It seems I misunderstood something about record field disambiguation.  Does anyone know why the colliding records must be in different modules?  I can understand the concept of a fully qualified function name (Data.X.fieldName :: a being consistant) but that seems a problem that should be easy to work around by providing a deeper qualification.
19:49:55 <dmwit> Record names *are* function names.
19:50:02 <TomMD> Yes, I know
19:50:25 <dmwit> So why should it be confusing that colliding names need to be in different modules?
19:50:32 <dmwit> You have the same name with two different types.
19:50:38 <dmwit> You need qualification to fix that.
19:50:39 <TomMD> So my point is that making record qualification should have, in some manner only the intermediate language cares about, hidden intra-module conflicts of record names.
19:51:00 <dmwit> I'm not sure type-inference would interact with that so well.
19:51:10 <TomMD> Also, the names can be of the same type and now play nice.
19:51:32 <TomMD> Its nothing more than syntactic sugar - the type system wouldn't need to see it.
19:51:34 <dmwit> Well, you can have multiple constructors, each with the same record name (at the same type), which will certainly play nice.
19:51:38 <mmorrow> for some reason whenever oleg says "indeed" it makes me chuckle
19:51:46 <dmwit> TomMD: Think about the selector function.
19:52:04 <dmwit> TomMD: Its first argument has the type of the entire data declaration.
19:52:21 <dmwit> TomMD: So if you have two data declarations with records named the same way, they are guaranteed to have different types...
19:53:21 <dmwit> I may be missing your point entirely.  It's happened before.
19:53:25 <TomMD> dmwit: Yes, I do understand the reason for its current design.  Perhaps what I am suggesting is not as obvious as I think or perhaps its not doable.  It seems to be simple to have this as sugar, and a first step rewrite would fix the colliding names...
19:54:19 <TomMD> I suppose that has ugly interactions with polymorphism - when 'data A' and 'data B' both have colliding selectors and are both of the same class, then you have a polymorphic function with that class you must pass the selectors as a dictionary.
19:54:49 <dmwit> How do you envision this first pass working?  i.e. how does it decide which of the two selectors to use?
19:54:51 <TomMD> But that is the same as if 'data A' and 'data B' are in different modules.
19:54:58 <dmwit> For concreteness, let's say
19:55:05 <dmwit> data A = A { a :: Int }
19:55:10 <dmwit> data B = B { a :: Int }
19:55:30 <dmwit> We can make it more complicated later, if necessary. ;-)
19:55:39 <TomMD> I've proposed this before on reddit.
19:55:44 <TomMD> basically I'd say:
19:56:31 <TomMD> a hidden class 'class FieldSelector_a' exists with method 'a' and there are hidden instances 'instance FieldSelector_a A' and 'instance FieldSelector_a B'
19:57:08 <TomMD> Then one could pattern match (or use a uniquly generated/intermediate field selector for the individual instances)
19:58:45 <TomMD> If it wasn't clear: these hidden classes and instances could be automatically generated by the compiler.
19:58:58 <wli> Gracenotes: That's why hierarchical modules are good.
19:59:15 <dmwit> hum
19:59:18 <wli> Gracenotes: ML-style nested modules rather
19:59:24 <wli> Gracenotes: higher-order, too
20:00:53 <dmwit> TomMD: The part I don't like about that is that you would get very strange error messages.
20:01:21 <dmwit> TomMD: For example, if you applied (a 3), you would get an error like, "No instance for `FieldSelector_a Int a'" or something...
20:01:24 <TomMD> dmwit: Yes, I've considered several situations in which error messages would get ugly.
20:01:29 <dmwit> Other than that, it seems like it might work.
20:01:35 <Gracenotes> yes, I haven't heard ravings so far about Haskell's module system ;)
20:02:30 <TomMD> dmwit: for your specific example, you'd need to back-track from this intermediate state to the programmers original code to provide a good error message - you certainly don't want to go it from the intermediate.
20:03:24 <wli> Gracenotes: One weakness wrt. ML modules is that (AFAIK) they don't let you split a module definition across multiple files, which helps a lot in the situation where you want Foo.Internal.Bar -type stuff.
20:05:07 <wli> Gracenotes: You would want the hidden inner modules to all be nested in a larger outer module that spans all the files they're implemented in etc. so you get a sort of private namespace to share all those inner modules' guts that gets closed off from the rest of the world in the end.
20:05:51 <Gracenotes> wli: yep the famous Internal scheme
20:06:04 <wli> I guess one could do something tied to directory structure for module nesting.
20:06:25 <Gracenotes> well, if I have some types whose constructors are exposed, I may as well make them types instead of newtypes
20:06:30 <wli> Gracenotes: But with the twist that you actually get the privacy of the internals enforced.
20:06:47 <Gracenotes> since said types are only used internally anyway
20:07:23 <Gracenotes> I just thought keeping it all newtype'd-with-hidden-constructor might make a more consistent design. Well... then again, I do have some special monad class instances for said types
20:07:43 <slava> where can I find an overview of ghc's unicode support?
20:09:22 <wli> The thought I was having was that directory structure automatically inducing module nesting could do some of what I want.
20:11:39 <wli> A directory automatically becomes a module, some file with a special name describes the module contents save for the files and subdirectories all being inner modules visible for import.
20:11:58 <slava> wli: a number of languages do this
20:12:14 <cognominal> trying to install text-icu, it fails. I have many version of libicu around. How cabal manage to find one?
20:12:28 <cognominal> ...and probably the wrong one.
20:12:29 <wli> You can export the inner modules with restricted signatures etc.
20:12:36 <wli> slava: Which ones?
20:12:43 <slava> wli: ocaml I think?
20:12:51 <slava> and factor
20:12:55 <slava> and java too :)
20:13:03 <slava> class and package names map to a directory hierarchy
20:14:13 <wli> ocaml just has ordinary higher-order ML-style modules last I checked. Java has no higher-order affairs e.g. module parameters and no way to restrict "inner module" visibility, not that it has any sort of actual module nesting.
20:14:18 <Gracenotes> hm. not just "directory structure automatically inducing module nesting", but also partially passing along names at the non-internal directory without doing a wrapper scheme
20:14:43 <slava> wli: well, it depends on how you define 'module' then
20:14:45 <Gracenotes> in Java, if you want the functions of some internal class, you have to mirror them in some other class
20:14:50 <Gracenotes> *methods
20:14:55 <wli> Gracenotes: The directory module would just export them with restricted signatures.
20:15:29 <cognominal> I see that foreign imports in hsc files references the relative names  of .h files. but how they are found?
20:15:55 <slava> so how complete is text-icu? what algorithms does it actually implement?
20:16:00 <wli> Gracenotes: The same way you do with nested modules that are all in the same file in the ML systems.
20:16:15 <slava> is it really just encoding/decoding?
20:17:41 <Gracenotes> if it's just a binding to a library, it likely doesn't implement any major algorithms
20:17:58 <slava> but it doesn't even seem to be a complete binding
20:18:07 <slava> icu has a lot of functionality but all i see text-icu expose is encoding and decoding
20:18:10 <slava> and normalization
20:18:28 <slava> so i was wondering if there was any unicode support for haskell (other than text-icu, which doesn't really offer what I'm talking about)
20:19:12 <cognominal> slava, the C function text0icu hooks to : http://pastie.org/402837
20:20:37 <wli> data Sig = Sig { dataExports, dataParams :: Map String Type, typeExports, typeParams :: Map String (Kind, Set Constructor), moduleExports, moduleParams :: Map String Sig }
20:20:40 <Gracenotes> I see you already have a proggit discussion going on, anyway :) If it's not available, I'm certain it will be.
20:20:47 <wli> I wonder if that's remotely close.
20:21:04 <Gracenotes> given that it seems we're on a Unicode roll
20:21:07 <slava> cognominal: right, so its a 5-minute hack to bind a handful of functions
20:21:20 <slava> there's no real unicode support anywhere here it seems
20:21:46 <slava> Gracenotes: that reddit submission was misleading, because the headline announced unicode support but it seems it doesn't exist at all, in any shape or form
20:22:14 <Gracenotes> I think the emphasis in "Fast Unicode support" was on 'fast', not on 'support'
20:22:19 <Gracenotes> :)
20:22:42 <slava> well, what it offers is Unicode strings, which are just sequences of 21-bit integers
20:22:55 <slava> "fast integer sequences" doesn't sound very impressive and probably woulnd't get to the front page ;-)
20:23:09 <Gracenotes> hehe
20:26:57 <conal> arjanb: ping
20:28:24 <wli> Things vaguely want two passes: one to process signatures and another to process modules themselves.
20:29:04 * ddarius is way behind on Haskell-Cafe
20:29:18 <Nafai> It took me a long time to get caught up today
20:29:31 <ddarius> Unread messages: 979
20:29:32 * wli doesn't even have a steady email address anymore.
20:30:53 <Tomas> ddarius: "mark folder as read" ? :)
20:31:36 <Gracenotes> geez, I have 2529 unread
20:31:54 <Saizan_> 4501 here
20:32:10 <Gracenotes> that's 60 less emails than I have in total :)
20:32:39 <Gracenotes> I don't read everything on a mailing list, just peruse.
20:38:26 * wli tries to smoke out a way to generate gnuplot-like plots of curves.
20:38:39 <ddarius> Use gnuplot?
20:38:44 <rovar> bplines
20:39:02 <wli> Well, they're crap generated in Haskell without obvious closed forms.
20:39:12 <wli> Without closed forms altogether.
20:40:09 <Alpounet> looking for a lib ?
20:40:10 <wli> There's not much of an obvious way to even communicate the data to gnuplot since e.g. scatterplots lose the point sequence information.
20:40:13 <wli> Yeah.
20:42:12 <Alpounet> 2D ?
20:42:20 <wli> Yeah, 2D only.
20:43:01 <Alpounet> And the wrapper of GNUPlot isn't convenient ?
20:43:34 <wli> "The" wrapper?
20:44:29 <wli> http://en.wikipedia.org/wiki/SQUFOF <-- looks plausible as an integer factorization algorithm for newbies/whatever faster than the usual trial division, not that I can explain wtf. it's doing.
20:44:49 <Gracenotes> argh, GHC.Prim.Any strikes again
20:45:45 <Alpounet> http://dockerz.net/software/chart.html seems fine, http://darcs.haskell.org/htam/ contains a wrapper around GNUPlot
20:46:51 <Gracenotes> jeez. Even when I set an explicit type, Any still shows up
20:48:09 <Saizan_> Gracenotes: aren't you happy? you can choose Any type you want for your code
20:48:59 <Alpounet> He probably trusts more GHC than himself
20:49:07 <Alpounet> (at least for typing issues :p)
20:49:23 <Alpounet> brb
20:52:47 <Alpounet> back;
20:52:47 <wli> hmatrix is supposed to have a gnuplot wrapper
20:52:51 <wli> I can't find it.
20:52:59 <Gracenotes> Saizan_: in the midst of my elation I accidentally fixed it. but I'd still love to know the kind of typefuckup-fu that can lead to it
20:53:04 <Alpounet> wli, in src/Gnuplot.HS ?
20:53:28 <wli> No, Graphics.Plot
20:55:00 <Alpounet> Oh.
20:55:09 <Saizan_> Gracenotes: i think getting Any means that you've found a bug in GHC
20:55:39 <Gracenotes> really. I've gotten it before
20:56:04 <ddarius> Gracenotes: wtf are you doing?
20:56:27 <Gracenotes> typefuckup-fu
20:56:46 <wli> I can probably do it.
20:57:20 <Gracenotes> ddarius: it's a function that returns IO (M s a -> IO a). Just for testing.
20:57:47 <Gracenotes> GHC thinks it's IO (M s Any -> IO Any)
20:58:12 <ddarius> How are you getting Any?
20:58:34 <Gracenotes> hm. Probably from doing x <- blahblah, x :: (M s a -> IO a), in ghci itself
20:59:12 <Gracenotes> the same from doing blahblah and then it
21:00:42 <Gracenotes> x <- a isn't terribly well-defined in ghci anyway, as far as I know
21:01:04 <wli> Weird. No Jacobian elliptic functions.
21:01:40 <Saizan_> ah, that might be legitimate, since he has no way to pick a type for 'a', it can't leave it polymorphic, but since it doesn't have a typeclass context it's not an "ambiguous type"
21:02:09 <Gracenotes> a legitimate bug? Is that what they call a feature?
21:03:41 <Saizan_> if it's sometimes useful, maybe :)
21:04:32 <Gracenotes> perhaps an explicit forall in the type would help
21:05:06 <Gracenotes> if 'help' means 'make it hackily work'
21:05:22 <Saizan_> at which point?
21:05:50 <Gracenotes> IO (forall a. M s a -> IO a)
21:06:18 <Saizan_> ah, yeah, that's a quite different type
21:06:20 <Gracenotes> eek.
21:06:32 <dolio> That's an impredicative type. GHC doesn't infer those.
21:06:58 <Gracenotes> it would be explicit
21:07:02 <dolio> You could give it that type yourself, of course.
21:13:17 <wli> gsl: exp.c:113: ERROR: underflow
21:13:17 <wli> Default GSL error handler invoked.
21:19:04 <bombshelter13> Hey, I need a good algorithm for completely denesting a tree into a list of it's leaf nodes - don't mind doing the coding part myself, i just need a description of the algorithm. Anyone know a good one for this purpose?
21:20:11 <Alpounet> home made one ?
21:21:16 <bombshelter13> seems like a problem that would have some 'standard' algorithm
21:22:07 <Gracenotes> there are three "standard" algorithms: preorder, inorder, and postorder. (Among others.)
21:22:28 <Twey> bombshelter13: For a tree: data Tree a = Leaf a | Branch (Tree a) (Tree a)... flatten (Leaf a) = [a]; flatten (Branch a b) = concat [flatten a, flatten b]
21:22:35 <Gracenotes> (there are other things you can do, like taking lists of all the nodes at certain depths and concatenating those)
21:22:51 <wli> hmatrix' gnuplot wrapper is crashing all over the place :(
21:22:57 <bombshelter13> ooh, that looks pretty elegant and straightforwards :) i'll try that
21:23:05 <Gracenotes> for a tree like Twey's, there's really only such a thing as inorder :)
21:23:21 <Twey> Heh, aye
21:23:31 <Gracenotes> data Tree a = Leaf a | Branch (Tree a) a (Tree a), there are even more options :)
21:23:32 <Twey> But yeah, there are variants
21:23:38 <Twey> That's the simplest
21:23:42 <Twey> For a binary tree
21:23:58 <Gracenotes> it also means that only leaves can hold values.
21:24:09 <wli> gd looks more promising
21:24:38 <Gracenotes> with values, it's not much more complicated: flatten (Leaf a) = [a]; flatten (Branch left value right) = flatten a ++ [value] ++ flatten b
21:24:57 <bombshelter13> yeah, that's the case here - i'm just doing pathfinding in a graph so it data will only be at the leaves where it either ran out of moves or found it's goal
21:25:12 <Gracenotes> that's inorder
21:25:44 <Gracenotes> Wikipedia has an article on it, too: http://en.wikipedia.org/wiki/Tree_traversal
21:26:17 <Gracenotes> there are also graph traversal algorithms, but if your graph basically is a tree, then there's no need to worry about those
21:26:56 <bombshelter13> Nah, my graph is a graph - the results of my path finding function come back to me as a tree, though
21:28:06 <Gracenotes> oh, okay
21:28:40 <bombshelter13> :) *implements the example that was given*
21:31:47 <Alpounet> can we use '++' in patterns ?
21:33:24 <Gracenotes> I don't think so
21:33:37 <Gracenotes> : can be used because it's a not just a function, it's a constructor
21:34:15 * wli tries graphics-drawingcombinators
21:34:57 <Alpounet> so is there a way to pattern match the fact that some list starts with a fixed set of elements, then somehting (that I want to be returned), then another thing fixed
21:36:31 <Gracenotes> func ('t':'h':'i':'s':' ':'i':'s':' ':'y':'o':'u':'r':' ':'p':'r':'e':'f':'i':'x':suffix) = blah
21:36:43 <Gracenotes> not recommended >_>
21:36:59 <Gracenotes> you can try guards
21:37:09 <wli> I can't quite get a working version of SQUFOF
21:37:12 <Alpounet> yeah
21:37:33 <Gracenotes> and if guards fail they just skip to the next pattern matching declaration (or the next guard, as appropriate)
21:38:52 <Alpounet> let's take an example...
21:39:33 <Alpounet> I give a string which is a web adress (say http://www.haskell.org/), and I want back just "www.haskell.org"
21:39:49 <Alpounet> without using head 7 times
21:39:53 <Alpounet> or a similar trick
21:39:55 <Alpounet> :p
21:40:01 <Alpounet> tail*
21:40:02 <Alpounet> sorry
21:40:38 <Gracenotes> what if I give you "omgastring"
21:40:52 <Gracenotes> do you want "omgastring" back, or do you want Nothing :: Maybe String back?
21:41:22 <Alpounet> doesn't matters
21:41:51 <Alpounet> could even do `error "You idiot, don't you know what a website adress looks like ?!"
21:41:53 <Alpounet> `
21:42:27 <Alpounet> In a real program, for serious use, that would be Nothing/Maybe
21:43:33 <Gracenotes> hm. I'm tempted to use ('h':'t':'t')... :P there must be a one-pass solution using Data.List functions. None comes to mind, though. hm...
21:43:44 <mmorrow> , (\pre xs -> flip drop xs . length . dropWhile id . zipWith (==) pre $ xs)  "qwerASDF" "qwertyuiopasdfghjklzxcvbnm"
21:43:45 <lunabot>  "tyuiopasdfghjklzxcvbnm"
21:44:12 <mmorrow> also, with explicit recursion would be cleaner probably
21:44:24 <Gracenotes> zipWith is a nice idea. Although the length.. hm
21:44:34 <mmorrow> that's the length of the prefix
21:44:38 <Gracenotes> yes.
21:44:41 <mmorrow> with explicit recursion you just fuse
21:44:51 <Gracenotes> I suppose it's only one-pass anyway, due to laziness
21:44:54 <mmorrow> and its O(length of pre)
21:45:18 <mmorrow> Gracenotes: well it depends
21:45:32 <Gracenotes> hm. or two-pass
21:45:36 <mmorrow> yeah, two
21:46:01 <mmorrow> since it can't start dropping til it's traversed it once for the length
21:46:14 <Gracenotes> you could just do a regular (,) zip, dropWhile and map otherwise
21:46:52 <Gracenotes> map snd . dropWhile (\(a,b) -> a == b) $ zip pre xs
21:46:54 <mmorrow> the problem there though is you lose the excess in the longer list
21:47:11 <Gracenotes> I think. Partial match might also not be entirely correct
21:47:40 <Gracenotes> also, that does keep unused bits of a pre in memory. >_>
21:47:55 <Gracenotes> hrm.
21:48:22 <dolio> Now I remember why I decided against writing gmp bindings.
21:48:24 <mmorrow> , let dropPre [] xs = xs; dropPre _ [] = []; dropPre (p:pre) (x:xs) | p==x = dropPre pre xs | otherwise = xs in dropPre  "qwerASDF" "qwertyuiopasdfghjklzxcvbnm"
21:48:25 <lunabot>  "yuiopasdfghjklzxcvbnm"
21:48:39 <mmorrow> oopt, lost the t
21:48:47 <mmorrow> , let dropPre [] xs = xs; dropPre _ [] = []; dropPre (p:pre) (x:xs) | p==x = dropPre pre xs | otherwise = x : xs in dropPre  "qwerASDF" "qwertyuiopasdfghjklzxcvbnm"
21:48:48 <lunabot>  "tyuiopasdfghjklzxcvbnm"
21:49:45 <Gracenotes> and to make it unchanged for partial matches, you'd have to... do some other magic
21:50:02 <Alpounet> domain "http://www.haskell.org/"
21:50:02 <Alpounet> "www.haskell.org"
21:50:27 <Alpounet> takeWhile + drop
21:50:53 <mmorrow> oh, if you want to match all or none, you can just
21:51:06 <Alpounet> domain "#haskell on freenode"
21:51:06 <Alpounet> "*** Exception: Invalid web adress
21:51:22 <Alpounet> (the exception was just to make it short)
21:51:39 <Gracenotes> it's very important for it to be one-pass, to accommodate huge strings like "https://"
21:52:03 <mmorrow> , let dropPre all [] _ = all; dropPre _ _ [] = []; dropPre all (p:pre) (x:xs) | p==x = dropPre all pre xs | otherwise = all in dropPre  "qwerASDF" "qwertyuiopasdfghjklzxcvbnm"
21:52:04 <seliopou_> seems like a bad time to ask, but does anybody have experience building GHC's rts?
21:52:04 <lunabot>  luna: No instance for (GHC.Show.Show
21:52:26 <Alpounet> my drop doesn't go through the list, right ?
21:52:35 <mmorrow> , let go = let dropPre all [] _ = all; dropPre _ _ [] = []; dropPre all (p:pre) (x:xs) | p==x = dropPre all pre xs | otherwise = all in dropPre  [] in go "qwerASDF" "qwertyuiopasdfghjklzxcvbnm"
21:52:36 <lunabot>  []
21:52:39 <Alpounet> takeWhile does.
21:52:41 <mmorrow> , let go = let dropPre all [] _ = all; dropPre _ _ [] = []; dropPre all (p:pre) (x:xs) | p==x = dropPre all pre xs | otherwise = all in dropPre  [] in go "qwerty" "qwertyuiopasdfghjklzxcvbnm"
21:52:42 <lunabot>  []
21:52:45 <mmorrow> grr
21:52:48 <Gracenotes> -.-
21:52:59 <Alpounet> one pass, when assuming we're looking for http
21:53:22 <Alpounet> + the guards
21:53:27 <mmorrow> ?
21:53:54 <Gracenotes> regex...? :)
21:54:10 <Gracenotes> blah blah regex blah blah blah two problems blah blah some guy said
21:54:19 <ManateeLazyCat> Hi, I will develop Haskell GUI program, and need control widgets status or build complex widgets, and now so many high-level GUI library for Haskell, I don't know how to choose, any suggestion?
21:54:19 <Alpounet> heh :-p
21:54:30 <slava> Gracenotes: regexes are beautiful
21:54:35 <Alpounet> I've heard of qtHaskell
21:54:40 <slava> i've come to appreciate the formal theory behind them (regular languages) recently
21:54:42 <Gracenotes> they are :) beautiful theoretical roots
21:54:52 <mmorrow> @let zip' [] ys = Right (Right ys); zip' xs [] = Right (Left xs); zip' (x:xs) (y:ys) = Left (x, y) : zip' xs ys
21:54:52 <lambdabot>  Couldn't match expected type `[Either (t, t1) b]'
21:54:53 <Gracenotes> except back references. Those damn back references.
21:54:59 <Alpounet> slava, the formal theory is (very) fine, regex suck.
21:55:06 <mmorrow> @let zip' [] ys = [Right (Right ys)]; zip' xs [] = [Right (Left xs)]; zip' (x:xs) (y:ys) = Left (x, y) : zip' xs ys
21:55:07 <lambdabot>  Defined.
21:55:11 <mmorrow> @type zip'
21:55:11 <Alpounet> so many \\///^ol$\q etc.
21:55:12 <lambdabot> forall t t1. [t] -> [t1] -> [Either (t, t1) (Either [t] [t1])]
21:55:12 <slava> who cares about backreferences
21:55:18 <slava> they're never used anyway
21:55:24 <mmorrow> > zip' [0..4] [99..]
21:55:25 <lambdabot>   [Left (0,99),Left (1,100),Left (2,101),Left (3,102),Left (4,103),Right (Rig...
21:55:34 <ManateeLazyCat> Have anyone use gtk2hs?
21:55:34 <slava> if you skip backrefs you can implement a very nice NFA matcher
21:55:40 <Gracenotes> yes, I know.
21:56:01 <ManateeLazyCat> I need suggestion about Haskell GUI programming.
21:56:08 <Gracenotes> slava: but, a regex is a regex ;)
21:56:34 <Gracenotes> so Factor's regex are one-pass?
21:56:37 <Alpounet> ManateeLazyCat, qtHaskell looks fine.
21:56:43 <slava> Gracenotes: the new implementation that's being worked on is
21:56:53 <slava> Gracenotes: compiles the dfa down to machine code too
21:57:02 <ManateeLazyCat> Alpounet: I not use qt,
21:57:05 <Gracenotes> neat
21:57:15 <mmorrow> @let isLeft = either (const True) (const False)
21:57:15 <lambdabot>  Defined.
21:57:26 <mmorrow> @let isRight = either (const False) (const True)
21:57:26 <lambdabot>  Defined.
21:57:27 <Gracenotes> slava: lookahead, lookbehind...?
21:57:31 <ManateeLazyCat> Alpounet: In fact, i want to binding xlib.
21:57:34 <slava> Gracenotes: yeah
21:57:47 <slava> Gracenotes: those desugar in terms of negation and conjunction
21:57:48 <Gracenotes> how do you handle that with the NFA?
21:57:57 <Gracenotes> oh, never mind.
21:58:18 <Gracenotes> you could always make a back-references wrapper, possibly.
21:58:26 <slava> Gracenotes: I'd have to ask my coworker about lookbehind, but lookahead is easy; (?=foo)bar => (bar & not(foo))
21:58:53 <slava> i'm not the one working on it
21:59:02 <Alpounet> ManateeLazyCat, something like that : http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11 ?
21:59:09 <cognominal> I want to regroup by modulo but this is not what happens :
21:59:10 <cognominal> groupBy (\a b -> (mod a 3) == (mod b 3) ) [1..10]
21:59:10 <cognominal> [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
21:59:13 <mmorrow> @let zipWith' f xs = fmap (either (Left . uncurry f) Right) . zip' xs
21:59:14 <lambdabot>  Defined.
21:59:19 <cognominal> where I am wrong?
21:59:25 <Alpounet> version 1.4.5, may be stable enough
21:59:34 <ManateeLazyCat> Alpounet: Okay, thank you very much! :)
21:59:42 <slava> Gracenotes: I think group capture is the only thing that's trickier with NFA than the usual backtracking approach that Perl uses
21:59:49 <Alpounet> everything is on hackage, got it ? :-)
21:59:54 <Alpounet> and ...
22:00:00 <slava> Gracenotes: and backrefs are impossible altogether as you've already said
22:00:03 <Alpounet> @faq Can Haskell do anything ?
22:00:04 <lambdabot> The answer is: Yes! Haskell can do that.
22:00:04 <Gracenotes> yeah, one must keep state. It's not like you're limited to a finite set, though
22:00:43 <Gracenotes> Neat thing it is, though. The users aren't so concerned about theory, though, more like "can I feed it so-and-so from my-favorite-regex-engine" :/
22:00:46 <slava> Gracenotes: yeah, you annotate the DFA and the traverser needs some extra logic
22:01:20 <mmorrow> gah, there aren't enough pre-package functions to work with Either
22:01:21 <slava> Gracenotes: well, hopefully users will care about compiled regex performance and a nice set of combinators (union, intersection, negation, concatenation) that cna operate on regexes (in addition to the traditional string syntax)
22:01:53 <cognominal> slava, can you help?
22:02:02 <Gracenotes> intersection! I suppose that was only one step away from finite automata.
22:02:11 <mmorrow> if you're trying to use Either an make a nice and clean + somewhat non-trivial function, you end up having to write like 5 functions just to work with Either
22:02:23 <slava> Gracenotes: perl syntax doesn't have intersection and negation for some reason
22:02:32 <slava> so perl cannot express a regex that matches no strings
22:02:42 <slava> it would be not(kleene_star(dot))
22:03:10 <mmorrow> [^.?]    # ?
22:03:13 <Gracenotes> well. That can match '\n', depending on what you mean by dot
22:03:20 <Gracenotes> *
22:03:22 <mmorrow> [^(.?)]   # i mean
22:03:29 <mmorrow> ?
22:03:34 <Gracenotes> most people use [^\n] for .
22:03:35 <slava> oh, I forgot about negated char classes
22:03:40 <Saizan_> cognominal: groupBy only groups adiacent elements
22:04:23 <Saizan_> cognominal: i'd use a Data.Map.Map for what you're doing
22:04:34 <cognominal> thx Saizan_
22:04:48 <Saizan_> Map.fromList . map (\x -> (x `mod` 3,x))
22:05:14 <Saizan_> Map.fromListWith (++) . map (\x -> (x `mod` 3,[x])) -- actually
22:05:36 <slava> mmorrow: wait, isn't [^(.?)] just anything that's not ( . ? or )
22:05:39 <slava> or am I missing something?
22:06:09 <pumpkin_> moo
22:06:29 <mmorrow> i think it's "not 0 or 1 of (any char)"
22:06:42 <Gracenotes> in most regex engines I've seen . has no meaning in character classes
22:06:48 <slava> right
22:06:53 <slava> the regex syntax is not recursive into []
22:07:08 <mmorrow> ah, well then isn't there a way to say that?
22:07:15 <slava> mmorrow: [^ab] is (not (or a b))
22:07:23 <slava> its not (not (concatenation a b))
22:07:25 <mmorrow> but you can group in char classes
22:07:32 <slava> I don't think so
22:07:37 <mmorrow> i thought
22:07:39 * mmorrow checks
22:07:42 <slava> char classes have their own syntax
22:07:47 <pumpkin_> not that I know of
22:08:01 <slava> otherwise you'd have to say [^a|b] instead of [^ab]
22:08:59 <mmorrow> no, you say:
22:09:04 <mmorrow> [^(a|b)]
22:09:22 <mmorrow> the parens re-introduce the non-charclass context
22:09:22 <slava> so (...) allow you to nest a regex inside a char class?
22:09:25 <slava> ok
22:09:33 <mmorrow> which i think is cool :)
22:09:35 <slava> thanks for the info, I didn't know that
22:09:38 <Gracenotes> um
22:09:44 <Gracenotes> o raly -.-
22:09:45 <mmorrow> just checked, this appears to work with perl
22:09:47 <pumpkin_> what's the point of calling it a character class if you can put multiple sequences in it?
22:09:51 <mmorrow> $ echo asdf | perl -lne '/[^(.?)]/g; print $1'
22:10:06 <mmorrow> and i've definitely used this before and i think it worked
22:11:08 <Gracenotes> mmorrow: well, asdf doesn't contain a (, ., ?, or )
22:11:21 <Gracenotes> sure?
22:11:33 <Gracenotes> '(omg)'.match(/^[^(a|b)]+$/) fails in JS, although JS is hardly a comprehensive implementation
22:11:50 <mmorrow> but the ".?" there means "0 or 1 or (any char)"
22:11:58 <mmorrow> s/or/of/
22:12:02 <mmorrow> but the ".?" there means "0 or 1 of (any char)"
22:12:20 <Gracenotes> unless it means a period or a question mark
22:12:27 <pumpkin_> well, I'm surprised
22:12:30 <mmorrow> i think you have to escape those somehow
22:12:38 <slava> pumpkin_: Perl will do that to you
22:12:42 <pumpkin_> :)
22:12:56 <Gracenotes> I mean, you can always replace a character class with a (blah|foo|bar)
22:13:03 <Gracenotes> or ?:, depending
22:13:10 <pumpkin_> my idea of a regex still fits pretty tightly with regular languages, so backreferences still feel like voodoo, let alone this crazy stuff :P
22:13:20 <mmorrow> hmm, i can't seem to figure out a way to test if this is really doing what i think it's doing
22:13:33 <Gracenotes> echo '(test)'
22:13:33 <pumpkin_> mmorrow: you could read the specs on perl regexes :P
22:13:44 <wli> I can't figure out what I did wrong in my SQUFOF implementation.
22:13:45 <mmorrow> pumpkin_: yeah, i think i'm gonna have to resort to that
22:13:48 <slava> pumpkin_: well, in this case its just shit syntax, nothing non-regular
22:13:52 <pumpkin_> I was under the impression that anything between [] was just verbatim character
22:13:53 <Gracenotes> and make a ^ and $
22:13:56 <pumpkin_> slava: true
22:13:59 <slava> pumpkin_: since regular languages are closed under negation and intersection
22:14:22 <pumpkin_> yup
22:14:25 <Gracenotes> pumpkin_: except for ^ at the beginning and -, where appropriate
22:14:30 <pumpkin_> yeah
22:14:33 <mmorrow> pumpkin_: i (just assumed and it appears to maybe be working) that parens re-introduce non-charclass context
22:14:43 <Gracenotes> in most impls [a-] would match an a or a -
22:14:47 <mmorrow> but i'm gonna check the spec
22:15:08 * wli prepares to paste.
22:15:17 <mmorrow> since it's quite possible that it's just not doing what i think it's doing at all, while producing results that look like it is :/
22:15:23 <mmorrow> which would be sucky ;)
22:15:53 <Gracenotes> most regex syntax is just sugar for formal regular expressions, anyway :)
22:16:03 <mmorrow> ah, yeah i'm talking particularly about perl regexes here
22:16:22 <mmorrow> perl as in the perl language (not pcre, dunno if there's any diff)
22:16:25 <Gracenotes> intersection is nice, although I've never had the need to use it, as far as I know.
22:16:31 <wli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1844#a1844
22:17:03 <mmorrow> Gracenotes: yeah, i've only used it in weird cases where i needed to get something that works by whatever means asap
22:17:10 <slava> mmorrow: pcre is a separate project
22:17:13 <wli> I can't quite figure out where I went wrong.
22:17:31 <slava> mmorrow: they don't follow perl exactly
22:17:37 <mmorrow> ah, i see
22:17:52 <slava> perl 6 regexes have even more features, they're basically like PEGs but even more shit
22:18:07 <mmorrow> hehe, perl -lne rocks
22:21:23 * mmorrow wonders if there's a pugs -lne
22:21:50 * mmorrow wonders where his pugs build went
22:22:48 * mmorrow curses
22:42:30 <patchwork> what would be the best way to send a certain number of http requests a second to a particular url?
22:52:45 <Gracenotes> patchwork: kind of difficult logic to implement, no...?
22:52:47 <wli> I've got something that works more of the time.
22:52:56 <Gracenotes> requests/second is an average
22:53:14 <Gracenotes> are you going to try pausing on-and-off to keep the average?
22:53:40 <patchwork> I was hoping to do it in some kind of steady cycle.
22:53:49 <Gracenotes> and if you for some reason have a 5-second HTTP request, would you hammer them out just to keep up with the average
22:54:44 <Gracenotes> well, it's simple enough to make a simple delay with threadDelay (which is IO). One must choose one's logic, though
22:54:47 <Gracenotes> @hoogle threadDelay
22:54:47 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
22:54:51 <patchwork> well I suppose the average would be a best case, and take into account delays etc.
22:55:44 <patchwork> but yeah I was wondering if I could spawn the necessary amount of threads as necessary to handle a consistent stream of requests
22:56:15 <maxote> what lambda calculus evaluator uses Haskell? Hindley-Milner? System-F, Calculus of Constructions? thanks in advance.
22:57:22 <Gracenotes> patchwork: threads can be spawned with forkIO, and you can share data with MVars. If you're wondrin bout the concurrency part of it
22:57:48 <TomMD> maxote: Is that a question from class work?
22:57:53 <ddarius> maxote: Your question makes no sense.
22:58:06 <patchwork> Gracenotes:  thanks for threadDelay, that is basically what I was looking for.
22:58:16 <maxote> TomMD, not from class work.
22:58:29 <patchwork> ddarius:  possibly just backwards
22:58:30 <Gracenotes> sure
22:58:43 <dolio> Those are all generally defined type systems. There isn't just one implementation of each of them.
22:58:56 <Gracenotes> as far as I know you could implement all of them in Haskell
22:59:06 <TomMD> I think he was asking what type system Haskell uses.
22:59:09 <Gracenotes> you could implement all of them in C. Brainfuck, even.
22:59:19 <maxote> yes TomMD
22:59:53 <dolio> It's close to Hindley-Milner, with some extra stuff.
23:00:13 <maxote> thanks dolio, it's all.
23:00:25 <maxote> HM + extra unknown stuff
23:00:51 <dolio> Type classes may be the extent of the extra stuff.
23:01:04 <dolio> I'm not sure if that overlooks anything.
23:01:33 <TomMD> All the uniquness typing it does not fail to not have is being overlooked.
23:04:12 <ddarius> dolio: You need Damas-Milner for polymorphic recursion.
23:05:08 <ddarius> Obviously, the tons of extensions go greatly beyond Hindley-Milner.
23:06:23 <maxote> ddarius, HM is the core of all typed system. For more capabilities, the extra stuff to HM is added, such extent from HM is required.
23:06:38 <ddarius> maxote: HM is not the core of all typed systems.
23:06:39 <dolio> I thought maybe polymorphic recursion fell under type classes.
23:07:22 <ddarius> dolio: It has nothing particularly to do with type classes.
23:08:46 <cognominal> @lt  (\a b -> cmp (mod a 3) (mod b 3))
23:08:47 <lambdabot> Maybe you meant: ft let
23:09:31 <wli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1844#a1845
23:09:39 <wli> There are still some problems.
23:09:58 <wli> 510511 and 2^(2^5) + 1 don't work.
23:10:55 <wli> What are some other major type system cores?
23:12:08 <cognominal> @pl  (\a b -> cmp (mod a 3) (mod b 3))
23:12:09 <lambdabot> (. flip mod 3) . cmp . flip mod 3
23:12:36 <dolio> I guess something like 'f (x:xs) = f (map (const ()) xs) ; f [] = ()' is polymorphic recursion, right?
23:12:58 <cognominal> @pl  (\b a -> cmp (mod a 3) (mod b 3))
23:12:58 <lambdabot> flip (cmp . flip mod 3) . flip mod 3
23:13:13 <dolio> GHC infers [()] -> () as the type without a signature.
23:13:22 <ddarius> dolio: There are more interesting examples than that.
23:13:31 <slava> :t cmp
23:13:32 <lambdabot> Not in scope: `cmp'
23:14:27 <ddarius> dolio: One example I like is implementing bit reversal sorting by building up nested tuples to make a complete binary tree (effectively).
23:14:42 <cognominal> :t flip
23:14:43 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:14:58 <ddarius> dolio: In general, nested data types lead to polymorphically recursive functions (and you could make a complete binary tree nested data type to make the above example more explicit)
23:19:01 <mmorrow> data Seq a = Nil | Zero (Seq (P a a)) | One (P a (Seq (P a a)))
23:19:13 <mmorrow> is from the okasaki book
23:19:29 <mmorrow> (where      data P a b = P a b)
23:19:59 <mmorrow> "AltBinaryRandomAccessList"
23:20:10 <dolio> My google search has Wadler saying that Hindley-Milner and Damas-Milner are the same. What does the latter add?
23:22:09 <mmorrow> (simplifying)   data Seq a = Nil | Zero (Seq (a, a)) | One a (Seq (a, a))
23:26:50 <score> stuffcorpse: nice name
23:27:36 <stuffcorpse> score: thanks
23:28:36 <mmorrow> dolio: this is good one http://www.lisperati.com/landoflisp/panel60.html
23:29:22 <mmorrow> after that, that's how i visualize the hm typechecker forever more :)
23:30:53 <mmorrow> um, spoiler warning DONT look at that if you want to read that comic from the beginning
23:31:01 <mmorrow> (guess i should have mentioned that..)
23:31:58 <dolio> I've already read it.
23:32:06 <mmorrow> heh, that's a good one
23:33:38 <mmorrow> funny too, i love the robojudge shaking his gavel and looking up to the sky..
23:33:44 <mmorrow> classic
23:34:03 <mmorrow> > (\x -> x x)
23:34:04 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1
23:34:04 <lambdabot>      Prob...
23:34:05 <lament> wonderful comic
23:34:18 <mmorrow> "Then i have no choice..."
23:34:35 <ddarius> dolio: The latter adds polymorphic recursion.
23:34:44 <dolio> Heh.
23:34:45 <rtalreja> is anyone having trouble uploading files to the haskell wiki?
23:35:01 <mmorrow> sml doesn't allow polymorphic recursion by default (or something)
23:35:23 <mmorrow> (i know this because it's constantly mentioned in the okasaki book)
23:40:03 <dmwit> rtalreja: Well, I guess you are.
23:40:26 <ddarius> dolio: Maybe the Milner-Mycroft system is what I wanted.
23:40:42 <dolio> Ah. Okay.
23:40:53 <maxote> ddarius, is MM patented?
23:41:03 <rtalreja> haha, yes i am having trouble uploading a file to the haskell wiki. has anyone else had a problem?
23:41:48 <maxote> when was started the MM system?
23:43:02 <dmwit> rtalreja: Well, you have an account and have logged in, right?
23:43:16 <dmwit> If so, and you're still having trouble, maybe you should write to Ashley or something.
23:43:26 <dmwit> Or the #haskell-cafe list.
23:43:34 <dmwit> errr
23:43:37 <dmwit> no #
23:44:05 <rtalreja> dmwit: yea, i posted my xmonad.hs and just wanted to upload a screenshot. i emailed ashley but haven't gotten a response yet.
23:44:45 <dmwit> You could put it somewhere like imgur or flickr or imagehost for now, and post a link to it.
23:45:44 <rtalreja> dmwit: yea, i should do that, thanks for the suggestion
23:46:20 <maxote> can be implemented the Milner-Mycroft system in Haskell? or is there any legal issue related to the patent policy?
23:47:03 <wli> Okay, I'm getting a bit further with SQUFOF but it still fails for 2^(2^5) + 1
23:49:47 <wli> The wikipedia pseudocode is probably just flat out wrong.
23:50:28 <wli> I may be best off translating C code for it into Haskell.
23:50:38 <wli> Which is some work, given the verbosity of the C.
23:59:10 <maxote> @go Milner-Mycroft typed lambda
23:59:11 <lambdabot> http://citeseer.ist.psu.edu/285362.html
23:59:11 <lambdabot> Title: Type inference with polymorphic recursion - CiteSeerX
23:59:18 <Gracenotes> meh, not so fun having an extra s type parameter just to keep track of an arbitrary state.
23:59:33 <Gracenotes> arbitrarily typed, that is. Which the user might not even need :x
23:59:58 <Gracenotes> could do type MonadU = Monad (), although that might yield some confuzzling error messages
