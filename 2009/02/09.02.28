00:00:49 <Gracenotes> aww, my poor confuzzled non-existent users :(
00:02:00 <ski_> @google Mycroft-OKeefe
00:02:02 <lambdabot> http://www.cs.bham.ac.uk/~udr/tkl/TypedProlog.ps.gz
00:03:11 <maxote> it uses Prolog's unification
00:04:26 <ski_> > (zipWith ((. ('-':)) . (++)) `ap` tail) ["Hindley","Milner","Mycroft","O'Keefe"]
00:04:27 <lambdabot>   ["Hindley-Milner","Milner-Mycroft","Mycroft-O'Keefe"]
00:05:27 <maxote> ski_, you forgot Damas '84 think i
00:05:43 * wli may very well be able to understand the continued fraction algorithm.
00:06:05 <ski_> maxote : it didn't fit the chain
00:06:37 <wli> I'm not sure how to find the continued fraction expansion of sqrt n, though.
00:06:41 <Gracenotes> holy pointless, batman
00:07:00 <adrian_> @pl \x -> (f x :)
00:07:00 <lambdabot> (:) . f
00:07:10 <maxote> @go Damas-Milner typed lambda
00:07:11 <lambdabot> http://www.dcc.fc.up.pt/~typetool/
00:07:32 <Gracenotes> I mean, zipWith f `ap` tail and (. f) . g are commonish idioms, but raly x-x
00:07:55 <Gracenotes> *huggles the channel*
00:08:14 <slava> :t ap
00:08:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:09:04 <Gracenotes> @djinn (m -> a -> b) -> (m -> a) -> (m -> b)
00:09:04 <lambdabot> f a b c = a c (b c)
00:09:45 <pumpkin_> Gracenotes is rubbing the magic lamp
00:10:10 <wli> Given 0 <= sqrt n - k < 1 one has 1 / (sqrt n - k) = (sqrt n + k) / (n - k*k) which is a mess. I don't know what the bounds on n - k * k should be.
00:11:30 <wli> k <= sqrt n < k + 1 so k*k <= n < (k+1)*(k+1) then 0 <= n - k*k < 2*k+1, there.
00:13:17 <wli> (sqrt n + k)/(n - k * k) = (1/2)*(2*sqrt n - 1)/(n - k*k) + (1/2)*(2*k+1)/(n - k*k)
00:14:45 <wli> This is a disaster.
00:16:23 <glguy> k <= sqrt n < 1+k ; k*k <= n < (1+k)^2 ; 0 <= n - k*k < 2k+1
00:16:32 <glguy> wli, am I over simplifying?
00:16:57 <glguy> oh
00:17:36 <glguy> step 2 isn't looking "good" :)
00:18:12 <Gracenotes> oh dear, where could have my microwave-safe container cover have gone
00:18:53 <score> Gracenotes: no such thing. enjoy sucking down industrial plastics
00:19:32 <dmwit> score: ceramic
00:19:36 <Gracenotes> it's better than the styrofoam I have in my closet.
00:19:47 <score> dmwit: oh yeah.
00:20:16 <wli> I basically just need a quadratic polynomial with a root related to n that has a linear term left.
00:20:24 <Gracenotes> in this case, it is plastic (and in 10000 years will disintegrate to kill some living thing). Although I also have ceramic.
00:20:34 <Gracenotes> :/
00:21:16 <pumpkin_> mmm ramen
00:21:32 <maxote> Gracenotes, the DVDs, Blurays, ... will disintegrate and yield a loss of precious data of thousand years ago :s
00:22:42 <joed> Actually go get some onions, white pepper (ground) and leeks and onioins, some immitation crab meat and you have a feast.
00:22:44 <maxote> e.g., your life (youtube) in one Bluray will be desintegrated
00:22:56 <wli> (x - a)^2 - b = x^2 - 2*a*x - b so x = 2*a + b/x will take on the value a + sqrt(b); from there, set a = 1 and subtract 1 from the initial term.
00:23:36 <maxote> the responsible of the plastic disintegration is the radioisotope C14
00:24:11 <score> Gracenotes: i was happily informed of my eventual industrial plastic death from a hippie standing near the single serve pod coffee maker
00:24:23 <wli> Also set b = n.
00:24:37 <wli> I believe I have the continued fraction expansion of sqrt(n) in rational arithmetic.
00:25:12 <Gracenotes> score: it's probably going to affect us somehow; it's definitely going to affect future generations of water-drinkers and food-eaters.
00:25:37 <score> Gracenotes: plastic creatures
00:25:50 <maxote> wli, the process, is it determinist or non-determinist ala Markoviana?
00:26:19 <maxote>  /Markoviana/Monte Carlo/
00:26:29 <Gracenotes> score: yes, of c-what
00:26:39 <wli> The continued fraction method is basically let p_k/q_k be the k-th convergent of the continued fraction expansion of sqrt(n), then search through the numbers p_k^2 - q_k^2*n until one is a perfect square.
00:26:54 <wli> maxote: Deterministic.
00:27:03 <maxote> this "search" is deterministic?
00:27:13 <wli> Yes.
00:27:34 <maxote> by enumeration?
00:28:01 <wli> Yes.
00:28:03 <maxote> will be it NP problem?
00:28:07 <wli> No.
00:28:22 <maxote> wli, thanks much
00:29:24 <ryant50001> has anyone thought about how to write a scene graph in haskell?
00:29:39 <maxote> what's the number of k? (k-th convergent)
00:29:53 <wli> The k-th element of the sequence of convergents.
00:30:16 <maxote> ok
00:31:46 <pumpkin_> ryant50001: a spatial datastructure?
00:32:20 <ryant50001> pumpkin_: well, i'm not sure that it has to include the spatial lookup stuff in it
00:32:44 <ryant50001> pumpkin_:  what i'm really concerned with is the writing of essentially an EDSL for specifying 3d sceneds
00:32:47 <ryant50001> *scenes
00:35:52 <wli> (x - a)^2 - b = x^2 - 2*a*x + a^2 - b so x = 2*a + (b - a^2)/x
00:36:05 <psygnisfive> sioraiocht: how do you say your name? sekht?
00:36:22 <sioraiocht> sheer-ee-ucht
00:36:32 <psygnisfive> which dialect?
00:36:49 <sioraiocht> you would say it that way in connacht or munster
00:36:57 <sioraiocht> síoraíocht is how it is actually spelt
00:37:00 <psygnisfive> ok.
00:37:05 <psygnisfive> crazy irish spelling
00:37:12 <sioraiocht> hahh
00:37:22 <psygnisfive> but its better than scots gaelic ;P
00:37:46 <sioraiocht> well, there's some debate about that ;)  the spelling reform made some regular verbs irregular
00:38:47 <psygnisfive> well.
00:38:51 <sioraiocht> but there is now a better correspondence between spelling and pronuncation, esp for connemara
00:38:55 <psygnisfive> its still crazy :D
00:39:14 <sioraiocht> a lot of people whinge that the official standard and the spelling are heavily connacht biased
00:40:43 <sioraiocht> I don't notice, though, as I speak connacht irish =p
00:40:53 <psygnisfive> :)
00:42:27 <sioraiocht> you can ask bos what he thinks, though.  I dunno which dialect he speaks
00:47:19 <maxote> > (zipWith ((. ('-':)) . (++)) `ap` tail) ["Damas","Milner","Mycroft","O'Keefe"]
00:47:20 <lambdabot>   ["Damas-Milner","Milner-Mycroft","Mycroft-O'Keefe"]
00:47:27 <maxote> perfect!
00:47:59 <ski_> but now poor Hindley is left out of the party :/
00:49:34 <maxote> ski_, i think Hindley is deprecated
00:50:07 <pumpkin_> poor hindley :(
00:50:21 <jrockway> *sigh*, i really need to stop using the internets
00:50:23 <jrockway> http://stackoverflow.com/questions/597521/will-haskell-ever-become-popular
00:50:27 <jrockway> these things just make me cry
00:50:48 <jrockway> i wish people would, you know, actually program more than 'main = print "hello world"' before they dismiss haskell
00:51:12 <jrockway> i stopped reading reddit to get away from this stuff, but it follows me around
00:52:12 <Gracenotes> Haskell sucks at reflection? What is there to reflect?
00:53:03 <ski_> monads
00:53:31 <slxix> How did you decide when a person has dismissed Haskell?
00:53:54 <Gracenotes> explicame, ski_?
00:54:39 <Gracenotes> por favor :3
00:54:49 <ski_> Representing Monads <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RM-abstract.html> Andrzej Filinski
00:55:44 <Gracenotes> it's not just an issue of whether it the language can be represented, but whether it can be controlled
00:56:25 <Gracenotes> I don't see reflection in Haskell as terribly valuable, but apparently this dude once used it on the internet to criticize GHC.
00:56:40 <pumpkin_> "But, it sucks at macros and reflection, it doesn't run on a virtual machine, and the very-strict type system can make it hard to grow systems incrementally, and there are social problems in the [online] culture that makes it hard to learn how to use Haskell well." How do you cram so much wrongness into one sentence?
00:57:18 <jrockway> LOL
00:57:25 <slxix> pumpkin_, how long have you been using the internet?... ;)
00:57:36 <jrockway> "IMO, Haskell is a research tool and will remain a research tool, due to the lack of industry support and the lack of libraries."
00:57:48 <pumpkin_> slxix: SOMEONE IS WRONG ON THE INTERNET :) MUST FIGHT TO THE DEATH
00:58:25 <jrockway> "Haskell specifically? Doubtful. Lisp style programming? Yes, I think that with hardware trends the way they are going, there is going to be more of a need in parallel-friendly languages. Parallel programming is not in and of itself a hopelessly difficult concept, it's just that modern languages did not have it in mind in their development."
00:58:27 <czShadoW> Oh my.
00:58:31 <jrockway> actually, this makes me laugh
00:58:33 <jrockway> not cry
00:58:47 <jrockway> apparently lisp supports parallelism better than haskell
00:58:57 <jrockway> it's fun to talk about two languages you've never used, as though you're an expert on both
00:59:07 <Gracenotes> what the hell is lisp-style programming? sexprs?
00:59:20 <jrockway> i am not sure
00:59:24 <jrockway> it sounds cool though
00:59:27 <jrockway> clojure is the new ruby
00:59:41 <slxix> i think he means functional as lisp-style.
00:59:52 <jrockway> ah
01:00:08 <Gracenotes> so when he thinks function, he thinks lisp.
01:00:13 <Gracenotes> *functional
01:00:14 <jrockway> my CL apps are mostly object-oriented, but i digress...
01:00:18 <Alpounet> Guysn aren't you used to such things ?
01:00:54 <jrockway> yeah
01:00:58 <jrockway> it never gets less painful for me, though
01:01:01 <Alpounet> I mean, I wanted to know about Haskell, I asked to people I trust in, then I discovered it myself, that's all.
01:01:27 <Alpounet> Though I've never tested parallelism
01:01:37 <Alpounet> But I will, don't worry ;-)
01:02:10 <jrockway> if you really want to do it right, you should write a rant about haskell doesn't support parallelism, first
01:02:30 <jrockway> * about how
01:02:45 <Gracenotes> "I think in 20 years a hybrid language that takes the best of functional languages and integrates them into current methodologies as well will win."
01:03:30 <Gracenotes> s/in 20 years/in the past 20 years/? :)
01:04:09 <Twey> Depending on what you define as 'the best' that's one of Haskell, F#, or Common Lisp
01:04:33 <Gracenotes> F# has influenced languages?
01:04:39 <jrockway> CL is probably the closet "hybrid"
01:04:49 <maxote> jrockway, lisp lacks a powerful typed system for checking errors
01:04:53 <jrockway> yes
01:05:06 <jrockway> it has very poor support for functional programming in general
01:05:14 <jrockway> every time you don't mutate something, you pay for it :)
01:05:36 <Alpounet> yeah
01:05:51 <maxote> i think lisp is deprecated too
01:06:12 <jrockway> not really
01:06:14 <Alpounet> and that silly evaluation strategy... it slows down my apps ! Beuuaa
01:06:19 <Twey> Gracenotes: Of course it hasn't
01:06:22 <jrockway> it has a good compiler, good tools, and some good libraries
01:06:43 <jrockway> CLOS is still the state of the art wrt object systems, if that's your thing
01:06:56 <Gracenotes> Twey: just making sure :)
01:07:07 <jrockway> the world would not be a bad place if everyone ditched java and C# and switched to CL instead :)
01:07:12 <jrockway> i don't foresee that, however
01:07:22 <Twey> Gracenotes: It's a hybrid
01:07:37 <maxote> the thing that i expect is a complex teraproject, i can't imagine it written in Lisp. My brain is saying me that it's required to use a powerful typed system for checking the programming errors.
01:08:11 <Gracenotes> Twey: quite
01:10:02 <Alpounet> most of people aren't conscious of what a type system is and why it is useful
01:10:17 <Twey> And some people prefer to work without one
01:10:24 <Alpounet> (to have it strong or not, depending on people and apps, but I prefer a strong one everytime)
01:10:37 <Twey> Common Lisp does have a type system
01:10:46 <Alpounet> Hidden ? :-p
01:10:46 <Twey> It's optional, but it's there
01:11:35 <dmwit> Every value has TST. ;-)
01:11:49 <dmwit> data TST = TST (TST -> TST)
01:11:54 <Gracenotes> Python's is lovely too. afaik Everything has a nice little 'type' tag and some functions attached
01:12:30 <dmwit> In Python, every value is a dictionary. =)
01:12:49 <Twey> In JS too
01:12:52 <dmwit> Except lambdas, I guess.
01:12:59 <Twey> Well, mostly, apart from the bits that are buggered up
01:13:06 <Twey> It's a pretty cool way of looking at things.
01:13:09 <dmwit> Twey: No, JS has base strings, arrays, and doubles.
01:13:14 <Gracenotes> types are somewhat distinct from values in JS
01:13:20 <dmwit> and functions
01:13:34 <Twey> dmwit: Yep
01:13:38 <inimino> functions are objects
01:13:41 <score> nobody can seem to write legit python or ruby
01:13:41 <Gracenotes> it's a not-terribly-descriptive system
01:13:51 <dmwit> inimino: Not quite.  Close... but not quite. =/
01:13:57 <inimino> and so are arrays
01:14:00 <dmwit> inimino: Functions can be used to construct objects.
01:14:01 <Twey> All of which have these little schizophrenic relationships with objects
01:14:13 <Gracenotes> you can't even get the name of a function unless there's a .constructor :) which Firefox supports, not sure if anything else
01:14:15 <inimino> dmwit: actually they are exactly ECMAScript objects
01:14:41 <inimino> dmwit: you can attach arbitrary properties to them and everything
01:14:53 <dmwit> inimino: Arrays are objects, but they're "special" in the sense that you can't just do, for example, for each (x in object), even if object has sequential numerical indices and a length property...
01:14:58 <Twey> And all objects are basically dictionaries
01:15:17 <Twey> Arrays are just objects with numerical property names and a magic 'length' property
01:15:24 <Twey> dmwit: Yes you can.
01:15:33 <dmwit> inimino: Oh, I was under the impression that functions got temporary wrappers when you assigned them properties, like the base types.
01:15:36 <dmwit> Sorry.
01:15:40 <Twey> In fact, for (x in obj) is specifically designed to iterate over objects
01:15:42 <Gracenotes> function fc() { arguments.callee.what = 5}; fc(); fc.what
01:15:47 <Twey> dmwit: No, they're intrinsically objects
01:15:57 <dmwit> Twey: Well... you *can*, but you don't get the same thing as for an Array (at least in Firefox).
01:16:03 <Gracenotes> unfortunately abuse of prototype can screw up for-each :/
01:16:07 <Gracenotes> or for-in actually
01:16:12 <Twey> Using for (x in obj) on arrays is discouraged, since you might get object properties rather than just the numerical ones you probably want.
01:16:16 <dmwit> You get an iterator over all properties, not just the values of the indices.
01:16:29 <Gracenotes> over all enumerable properties only
01:16:30 <Twey> dmwit: That's what for..in does
01:16:40 <inimino> dmwit: right, because for .. in treats arrays just like any other object
01:16:50 <Gracenotes> for instance, array functions are not enumerable
01:17:17 <inimino> though it is true that arrays are treated specially in the handling of the length property
01:17:20 <dmwit> inimino: *shrug* From my experience, for/in behaves differently for an explicit Array object and an own-constructed array-alike.
01:20:57 <Alpounet> don't talk about those crappy languages please
01:21:00 <Alpounet> :-)
01:21:22 <Gracenotes> how 'bout that ActionScript, huh
01:22:26 <dmwit> durr hurr hurr
01:22:32 <Gracenotes> hi im having java problme im using form.write(`hello`) but it doesnt work
01:22:34 <Gracenotes> does ne1 can help me???
01:22:43 <Gracenotes> fresh from ##javascript
01:23:04 <ziman> I'm writing a RTSP monad that streams video over network. Does it make sense to create a new monad for this purpose when I need to expose underlying I/O to allow the user to define an incoming frame handler? (And RTSP itself is full of IO.)
01:23:30 <Gracenotes> (with no offense to the one asking the question, but JS's ubiquity can breed misconceptions)
01:24:01 <pumpkin_> ziman: what would the monad functions do?
01:24:30 <inimino> Gracenotes: hasn't Aankhen been reasonably coherent in the past?
01:24:37 <pumpkin_> ziman: like, what would bind do?
01:24:52 <ziman> create connection, obtain information about the video source, download some video, ...
01:24:54 * inimino wonders if it's some kind of joke
01:25:01 <ziman> it would be a very IO-like monad
01:26:08 <Gracenotes> inimino: oh, I do suppose I've been indirectly trolled. It seemed the perfect example... too perfect.
01:26:42 <inimino> Gracenotes: yes, something so perfect could not but be artifice ;-)
01:27:07 <ziman> in fact, each RTSP action could be an IO action as well, hm
01:27:23 <Gracenotes> @src MonadIO
01:27:23 <lambdabot> Source not found. My pet ferret can type better than you!
01:27:27 <Gracenotes> :(
01:27:42 <Gracenotes> class Monad m => MonadIO m where
01:27:51 <Gracenotes>    liftIO :: IO a -> m a
01:28:15 <Gracenotes> ziman: you can make the RTSP monad an instance of a MonadIO.
01:28:37 <Gracenotes> if you use something like a ReaderT with IO, you can just use GeneralizedNewtypeDeriving
01:29:08 <Gracenotes> or just use type instead of newtype...
01:29:22 <Gracenotes> in many cases you don't need an entirely new monad -- monad transformers will do fine :D
01:29:23 <ziman> ...to force the user explicitly mark all arbitrary IO usage
01:29:45 <ziman> yeah, I mean a monad composed using monad transformers
01:30:17 <wli> SQUFOF would be the simplest algorithm by far if I could actually find an accurate description of it.
01:30:57 <wli> One of my favorite things was some module that basically had pre-lifted versions of all the IO functions.
01:31:08 <Gracenotes> ziman: a 'ReaderT Handle IO a', if Handle is the socket, seems neat.
01:31:21 <Gracenotes> you might not even need a monad.
01:31:37 <Gracenotes> the top-level computation would be from YourType -> IO something
01:32:02 <Gracenotes> quote-top-level-unquote. It depends, but that might be it.
01:33:24 <Gracenotes> I might be assuming too much :) But if you want a monad that can also do IO, a MonadIO instance should be possible.
01:33:31 <ziman> yes, it's very IO-ish. Maybe I was just wrong trying to restrict arbitrary IO in this case.
01:34:05 <ziman> okay, I'll make it MonadIO, thanks.
01:34:10 <Gracenotes> read a frame, launch the missiles, read another frame... :)
01:34:20 <ziman> :-)
01:38:15 <Gracenotes> ziman: well, you can provide an interface to only the IO functions you want if you use a newtype and hide the constructor. Then you'd need to make sure it's *all* the functionality you want
01:38:35 <Gracenotes> @google cale monad transformers
01:38:36 <lambdabot> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
01:38:36 <lambdabot> Title: Monad tutorials timeline - HaskellWiki
01:39:03 <Gracenotes> actually http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
01:39:04 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
01:39:19 <Gracenotes> still learning, but that's what I've come up with
01:44:04 <ziman> I'd like to allow the user to do arbitrary IO in the frame handler but not in the RTSP monad, so i think I'll go for a newtyped Rtsp and getFrames :: (Frame -> IO ()) -> Rtsp ()
01:45:42 <pumpkin_> did ByteString used to be called something else? why is the strict data constructor called PS?
01:49:03 <Cale> pumpkin_: PackedString
01:49:08 <pumpkin_> ah :)
01:49:21 <pumpkin_> was it a name change, or just an internal convention?
01:49:48 <Cale> I think it actually was a name change...
01:50:09 <wli> It really needs the partial numerators to be 1.
01:50:21 <adrian_> @pl \a b -> a ++ [b]
01:50:21 <lambdabot> (. return) . (++)
01:51:25 <pumpkin_> are there any GHC language extensions which are directly incompatible with one another?
01:52:28 <adrian_> @pl \a b -> [a,b]
01:52:28 <lambdabot> (. return) . (:)
01:54:09 <Alpounet> @pl \a b c -> ([[a,b],[a,c],[b,c]], a+b+c)
01:54:10 <lambdabot> ap (ap . (liftM2 (,) .) . ap (ap . (((.) . (:)) .) . (. return) . (:)) ((. flip (flip . ((:) .) . (. return) . (:)) []) . ap . ((:) .) . (. return) . (:))) (((+) .) . (+))
01:54:30 <wli> x = 2*a + (b - a^2) / x, so choose b = n, a = floor (sqrt n), then k <= sqrt n < k + 1 gives 0 <= n - k^2 < 2 * k + 1, <= 2*sqrt n + 1, but there's something where you should be able to pull out a multiplicative factor
01:56:26 <ImInYourMonad> can I fold over 2 lists at once?
01:56:39 <wli> sqrt n / (n - (floor (sqrt n))^2) maybe?
01:57:15 <ImInYourMonad> huh?
01:57:50 <ImInYourMonad> @type floor
01:57:51 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
01:57:58 <ImInYourMonad> hmm what is that?
01:58:00 <Gracenotes> ImInYourMonad: you can zip them
01:58:10 <ImInYourMonad> ag ofc zipWith
01:58:29 <Gracenotes> ag ofc jgdsi nwak lqa?
01:58:39 <adrian_> @djinn [a] -> [a] -> [a]
01:58:40 <lambdabot> Error: Undefined type []
01:58:47 <Gracenotes> in which case the folding will only go up to min(length a, length b)
01:59:21 <ImInYourMonad> what should eb the answer for vectorProduct [] [1,2,3] ?
01:59:59 <Gracenotes> oh, in that case (assuming dot) you don't need any folding. I thought you meant left-fold/right-fold
02:00:53 <Gracenotes> hm. Well, using my naive mathematical logic 0 dimensions is a dot, which may as well be the point 0
02:01:13 <Gracenotes> (not paying attention to any nice linear algebra abstractions)
02:01:31 <Gracenotes> > sum []
02:01:32 <lambdabot>   0
02:03:08 <quicksilver> ImInYourMonad: depends what type of product.
02:03:09 <O_4> @src foldl'
02:03:09 <lambdabot> foldl' f a []     = a
02:03:09 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:03:20 <flux> > product []
02:03:21 <lambdabot>   1
02:03:30 <quicksilver> ImInYourMonad: inner product (dot product) requires two vectors of the same length. Outer (tensor) product works on any pair of vectors.
02:03:31 <Gracenotes> dot prod
02:04:12 <quicksilver> (and cross product requires two vectors of length three)
02:04:28 <quicksilver> there is a wikipedia page all about the different kinds of vector product IIRC>
02:07:04 <wli> You can't do a whole lot better than a = floor (sqrt n), then using the equivalence transformation carrying all the partial numerators to 1 in http://en.wikipedia.org/wiki/Generalized_continued_fraction#The_equivalence_transformation
02:08:02 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1847#a1847 <- is this correct? I dont really know vector math we havent gotten that far in school im mostly learning by myself.
02:08:34 <pumpkin_> bulat's attitude seems better recently
02:08:51 <quicksilver> ImInYourMonad: looks right.
02:09:01 <Gracenotes> the ratio data type works nicely if your teacher forces you to multiply matrices/vectors with fractions :)
02:09:14 <quicksilver> ImInYourMonad: it might be more "obvious" to write vectorLength using sum + map, but nothing wrong with the way you did it.
02:09:22 <quicksilver> ImInYourMonad: you combined the sum + map into a single fold.
02:09:33 <pumpkin_> ImInYourMonad: or vector length in terms of the dot product of the vector with itself
02:10:04 <maxote> wli, you're doing some wrong
02:10:55 <adrian_> @pl \a b-> a+1
02:10:55 <lambdabot> const . (1 +)
02:11:22 <pumpkin_> ImInYourMonad: sqrt . join dotProduct would be one particularly ugly/elegant way of writing it
02:12:16 <wli> maxote: You betcha. "All irrational square roots of integers have a special form for the period; a symmetrical string, like the empty string (for ? 2) or 1,2,1 (for ?14), followed by the double of the leading integer." <-- http://en.wikipedia.org/wiki/Continued_fraction#Periodic_continued_fractions
02:13:20 <pumpkin_> ImInYourMonad: and since you're using foldl', you might want to replace that sum with foldl' (+) 0
02:13:32 <wli> Maybe it's possible to carry out the properFraction procedure in Q(sqrt(x)).
02:13:50 <Gracenotes> even foldl1'
02:14:00 <pumpkin_> > sum []
02:14:01 <lambdabot>   0
02:14:11 <Gracenotes> taken! :)
02:14:25 <pumpkin_> ?
02:14:33 <Gracenotes> point. yours.
02:14:39 <pumpkin_> oh
02:14:46 <pumpkin_> sorry, sleepy :)
02:14:51 <pumpkin_> (and generally slow)
02:15:05 <adrian_> does someone have an example where a foldl is more elegant than a foldr?
02:15:27 <pumpkin_> foldl is generally pretty bad
02:15:43 <pumpkin_> foldl' vs. foldr!
02:15:48 <Alpounet> but is tail recursive, right ?
02:15:49 <wli> Given 0 <= a + b*n^(1/2) - k < 1 one has 0 <= ((a - k) + b*n^(1/2))^2 < 1 also, so there's something.
02:16:33 <Gracenotes> one instance where it was handy lately was rather straight-forward: converting [a, b, c, d] into something like App (App (App a b) c) d
02:17:08 <Alpounet> hmm ?
02:17:13 <Gracenotes> well, a month or so ago.
02:19:18 <ImInYourMonad> Grace/quick: ok i see. i thought about sing map+sum  does laziness make it as fast a s a fold?
02:19:49 <ski_> (istr there's also cross product for 0-, 1-, 7- dimensional vectors)
02:20:03 <pumpkin_> 0-dimensional?
02:20:08 <wli> One need only consider 0 <= a + b*n^(1/2) < 1 even, IOW floor (b*n^(1/2))
02:20:09 <pumpkin_> doesn't sound very interesting :)
02:20:23 <Gracenotes> ImInYourMonad: well, actually there's a way to combine foldl and map into one function
02:20:38 <ski_> (there's only one 0-dimensional vector, of course .. the zero vector)
02:20:54 <Gracenotes> it won't yield a significant speed-up, though
02:21:30 <ImInYourMonad> is: dotProduct v1 v1 == vectorLength v1 ; supposed to eb treu? because it isnt for my functions. or that sint what you meant?
02:21:30 <pumpkin_> ImInYourMonad: your length foldl' is doing the same thing as dotProduct :)
02:21:41 <Gracenotes> if you do the sum of a map of a list, then Haskell only needs one list element at a time. So it's not like it passes through the list twice -- it maps elements as needed, sums 'em as needed
02:21:44 <ski_> (and the base for that space consists of zero base vectors :)
02:21:55 <pumpkin_> ImInYourMonad: it's squared :) that's why I put a sqrt in
02:24:58 <wli> I'm still a little fuzzy on properFraction in Q(n^(1/2)) but it seems vaguely symbolically doable at first glance.
02:26:12 <ImInYourMonad> so which is better? sum+map or foldl? does sum+map use less space or soemthing? and speed is roughylequaivalent?
02:27:14 <dcoutts> ImInYourMonad: foldl' (note the ') will be faster than sum . map
02:27:14 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:27:23 <dcoutts> under stream fusion the latter can be fused into the former
02:27:53 <dcoutts> but not under the current fusion system because sum is a foldl' not a foldr
02:28:18 <Gracenotes> sum $ map f xs == foldl (\a x -> a + f x) 0 xs
02:28:25 <dcoutts> @seen gwern
02:28:25 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 5h 41m 47s ago.
02:28:57 <dcoutts> Gracenotes: yes though we almost certainly want foldl' instead
02:29:05 <Gracenotes> yes
02:30:03 <Gracenotes> it's not equivalent to using foldl', only in semantics (excluding evaluation semantics, I guess)
02:30:18 <ImInYourMonad> vectorLength2 v = sqrt $ CM.join dotProduct v
02:30:25 <ImInYourMonad> how should it be done ebcause thta doesnt work
02:31:00 <dcoutts> Gracenotes: you're right, it's not equivalent, it's much stricter
02:31:18 <ImInYourMonad> does haskell have vectors?
02:31:18 <jekor> Is there a way to tell the compiler that I don't care about the return type if I'm not going to use it? With "mapM_ (get cp "DEFAULT") requiredConfigVars" I'm getting "Ambiguous type variable `a' in the constraint: `Data.ConfigFile.Get_C a'".
02:31:30 <ImInYourMonad> with proper functions operating on it?
02:32:25 <wli> 0 <= (p + q*n^(1/2))/r - k < 1 for integers p, q, r, k, n with n squarefree, n, r > 0, gives 0 <= p + q*n^(1/2) - r*k < r, r*k - p <= q*n^(1/2) < r*(k+1) - p, bisection if nothing else? hope that (r*k-p)^2 <= q^2*n < (r*(k+1)-p)^2 holds somehow?
02:32:35 <dcoutts> Gracenotes: so not equivalent in static semantics or operational semantics
02:32:52 <ski_> jekor : quite possibly the semantics of the overloaded operation depends on the monadic result type, even if you're not going to use the monadic result value
02:33:37 <pumpkin_> ImInYourMonad: if you want to use join on dotProduct, you'll need Control.Monad.Instances
02:33:39 <jekor> That makes sense, I guess.
02:33:54 <pumpkin_> ImInYourMonad: but really the join is golfing it a bit :) it's not necessary
02:34:39 <jekor> So how can I insert a type hint? I want it to just use a String context, but the monad's in there...
02:34:41 <Gracenotes> @hoogle Applicative f => f (f a) -> f a
02:34:42 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
02:34:42 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
02:34:42 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
02:36:46 <jekor> Nevermind, found a way to just get a list of the option names.
02:38:02 <ImInYourMonad> CM is COntrol.Monad, CM.join isnt right?
02:38:06 <maxote> wli, between 0 and 1 there are infinite rationals :s
02:38:28 <pumpkin_> ImInYourMonad: it is, but the instance for -> comes from Control.Monad.Instances
02:38:36 <maxote>  /infinite/infinite possible/
02:39:01 <wli> maxote: There is a way to symbolically compute floor(x) in Q(n^(1/2))
02:39:07 <wli> maxote: I will figure it out.
02:40:00 <Gracenotes> join for ((->) r), the function instance, m (m a) -> m a, or (s -> s -> a) -> s -> a, or, join func value = func value value
02:40:12 <Gracenotes> to inline
02:40:31 * ski_ wonders what an "infinite possible rational" is
02:40:42 <pumpkin_> Gracenotes: ?
02:41:24 <Gracenotes> ‽
02:41:31 <pumpkin_> I didn't get that sentence :P
02:41:49 <maxote> ski, i wanted to say that between 0 and 1 there is an infinite set of possible solution's rationals.
02:42:17 <Gracenotes> I suppose commas roughly mean equivalence
02:42:27 <ski_> maybe you mean that there's an infinite number of rationals between zero and one ?
02:43:14 <romildo> Hi.
02:43:17 <wli> I should be able to search around using properFraction (p :% r), properFraction (q :% r), and isqrt n, or some such.
02:43:30 <maxote> yes, from these can have either 0 rationals as solution or 1 rational as solution or many rationals as solutions.
02:44:21 <ski_> since you're talking about solutions, i imagine you have some equation in mind ?
02:44:45 <wli> Given integers, p, q, r and a squarefree integer n > 1, I want an integer k such that 0 <= (p + q*n^(1/2))/r - k < 1
02:45:00 <wli> No floating point allowed.
02:45:43 <wli> r is positive, sorry.
02:46:50 <romildo> Is there any non-recursive binding expression in Haskell? Something that would allow me to write, for instance, (let' xs = 3 : xs), which would ind xs to a new list with  head 3 and tail xs, where xs refers to a previously defined variale, not the one being defined.
02:47:07 <romildo> s/ind/bind/
02:47:32 <maxote> ski_, i've not an equation in mind, but in my mind i've hypothesis of the ways to give possible results without equation.
02:47:54 <ski_> possible results of what ?
02:48:07 <pumpkin_> romildo: don't think so, but you could just make an intermediate value?
02:48:17 <maxote> ski_, the universe
02:49:05 <ski_> > runIdentity $ do xs <- return [4,5]; xs <- return (3:xs); return xs
02:49:06 <lambdabot>   [3,4,5]
02:49:29 <trofi> :]
02:49:45 <ski_> > [4,5] >$ \xs -> (3 : xs) >$ \xs -> reverse xs
02:49:47 <lambdabot>   [5,4,3]
02:50:03 <Alpounet> brb
02:50:09 <ski_> (you extrapolate the former to list comprehensions)
02:50:59 <ski_> (maxote : i'm sorry, i have no idea what you are talking about now)
02:51:01 <romildo> pumpkin, I would like to build the data structure (the list, for instance) in several steps. The structure has many components. This would imply in many intermediate variales, with distinct names.
02:51:41 <ski_> is the situation too complex for a composition chain ?
02:52:21 * ski_ sometimes wants to write commutative diagrams as definitions in haskell ..
02:52:38 <maxote> ski_, by Cantor, there is a set of infinite rationals between 2 bounded points [a,b], the solution of any problem can be the set of it, the subset of it or the empty set of it (no solutions), q.e.d.
02:53:05 <maxote> assumed integer extreme points [a,b]=[0,1]
02:53:34 <ski_> since that appears to be meant as a proof, what is the proposition to be proved ?
02:53:40 <romildo> pumpkin. Adding new components would disrupt the already used names, making maintenance more difficult.
02:53:59 <maxote> ski_, the proposition is the number theory: the integers and the rationals
02:54:24 <ski_> is the proposition that number theory has a model ?
02:54:27 <pumpkin_> maxote: that there's a (countably) infinite number of rationals between two points doesn't seem to be disputed is there?
02:54:32 <pumpkin_> *is it
02:55:06 <wli> I'm just trying to find floor((p+q*n^(1/2))/r) using purely integer arithmetic IOW no floating point cheats.
02:56:39 <maxote> wli, why do you use floor?
02:56:55 <maxote> why not ceil?
02:57:12 <wli> Continued fractions of elements of Q(n^(1/2))
02:59:49 <wli> You can find reciprocals easily, e.g. r/(p + q*n^(1/2)) = r*(p-q*n^(1/2))/(p^2-q^2*n)
03:00:10 <kapil> last $ takeWhile (\t -> ((r*t-p)^2 <= (q^2*n))) [1..]
03:00:16 <wli> You just need the guarantee that 0 < (p+q*n^(1/2))/r < 1
03:00:45 <wli> kapil: But I need a better starting point, and preferably bisection search.
03:01:12 <maxote> wli, the bisection search goes to infinite, i though.
03:02:16 <maxote> my question, is when stop it? (the halting problem)
03:02:36 <wli> maxote: The search is for an integer k so that k <= (p+q*n^(1/2))/r < 1 where r > 0, n > 1 and is squarefree, and p, q are integers.
03:02:40 <pumpkin_> is that the halting problem? o.O
03:02:42 <wli> ergh
03:02:47 <pumpkin_> it's a halting problem certainly :)
03:03:26 <wli> maxote: The search is for an integer k so that k <= (p+q*n^(1/2))/r < k + 1 where r is an integer with r > 0, n is an integer with n > 1 that's also squarefree, and p, q are integers.
03:04:14 <maxote> pumpkin_, the dirty try is stoping it when the number is sufficiently large to round it and ignore the minor error of the round.
03:04:30 <pumpkin_> well, he's trying to do this in integer math
03:04:46 <maxote>  /number/number of steps/
03:05:12 <pumpkin_> anyway, all I was commenting on was a technicality
03:05:29 <pumpkin_> I haven't been following too closely, half asleep :)
03:06:09 <maxote> e.g. 0.333333333...(i stop here), i round it to 1/3
03:07:47 <maxote>  /try/attempt/
03:10:28 <wli> (r*k-p)/abs q <= sgn(q)*n^(1/2) < (r*(k+1)-p)/abs q; shifting p by r shifts k by 1, so you can take quotients and remainders of p by r
03:10:49 <trygvis> could anyone please try to explain this error to me? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1632
03:11:36 <wli> In fact you know that by irrationality the lower inequality must also be strict.
03:12:34 <ImInYourMonad> hmm perhaps I should create a vector library for Haskell, isnt there one already?
03:12:44 <ImInYourMonad> so i cando Vector x * Vector y
03:12:59 <EvilTerran> ImInYourMonad, i think there's at least one on hackage
03:13:09 <ski_> trygvis : `getDocPrim' appears to give an action in an `CouchMonad', which is not the `IO' monad
03:13:29 <ImInYourMonad> yes i found
03:13:33 <ImInYourMonad> but dont know if they are generalpurpose
03:13:41 <ImInYourMonad> one says: experimental use at yoru own risk
03:13:43 <ski_> trygvis : if `CouchMonad' happens to be in `MonadIO', you could wrap the `IO' actions there inside `liftIO'
03:13:45 <trygvis> right. I'm having problems figuring out to handle the CouchMonad stuff
03:14:06 <trygvis> the documentation is here: http://hackage.haskell.org/packages/archive/CouchDB/0.8.1.2/doc/html/Database-CouchDB.html
03:14:16 <ski_>     liftIO (putStrLn "Just!")
03:14:18 <ski_> et.c.
03:14:26 <trygvis> from the implementation it seems like it do implement MonadIO
03:14:32 <Alpounet> There is a lib for Linear Algebra
03:14:50 <ski_> (also, you'll obviously need to fix the type signatures)
03:14:53 <Alpounet> @hoogle linear algebra
03:14:53 <lambdabot> No results found
03:14:59 <asgaroth> By the way: Is there a chance that in future language revisions, putStrLn and such will be liftIO'ed by default?
03:15:00 <wli> So find m with (r*m-p)^2 < q^2*n < (r*(m+1)-p)^2
03:15:01 <Alpounet> @hoogle algebra
03:15:01 <lambdabot> No results found
03:15:05 <Alpounet> rha
03:15:44 <Alpounet> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Linear_algebra
03:15:58 <wli> Which is a sort of isqrt constrained so that things are congruent to -p mod r.
03:16:07 <ziman> isn't it desirable that all explicit IO gets annotated by liftIO in monadsIO other than IO itself?
03:16:37 <asgaroth> ziman: Even for standard IO it wouldn't harm, since IO is an instance of MonadIO with liftIO = id iirc
03:17:20 <ski_> how about things like `catch' or `forkIO' ?
03:20:14 <trygvis> ski_: but it is actually failing on the res <- assignment
03:21:19 <ImInYourMonad> should a Vector be reppresented as  a List or Array? Lists are simple but you might want to index soemtimes though? and vectors are generally not updated are they?
03:21:37 <ImInYourMonad> Alpounet: yeah hmatrix but i cant install it
03:22:17 <ImInYourMonad> i guess arrays though since i should amke it compatible with my matrix library
03:22:29 <Alpounet> ok
03:31:37 <ski_> trygvis : that's because you stated that you return an `IO' action in the type-signature .. and that `res <- ...' "assignment" (actually a monadic binding), uses an `CouchMonad' action instead
03:33:07 <trygvis> I though the result of the case would determine the return type?
03:34:51 <ImInYourMonad> Could not deduce (Eq (Vector v), Show v) from the context ()
03:34:55 <ImInYourMonad> Possible fix:
03:34:55 <ImInYourMonad>       add (Eq (Vector v), Show v) to the context of
03:34:55 <ImInYourMonad>         the instance declaration
03:34:59 <ImInYourMonad> is that in the data?
03:37:18 <ski_> trygvis : in `do x0 <- a0; x1 <- a1; ...; an', all the `a0',`a1',...,`an' must be actions in the same monad
03:39:33 <ronny> ski_: ping? whats your relation to that curses gtk backend? im in search of the people behind it
03:40:21 <ImInYourMonad> is there a solution for this: I want the datatype of soemthing to be carried around with my instance but all operations on it is on the thing itself, ie fromType x, can that somehow be done automatically?
03:40:34 <ImInYourMonad> with >>= or soemthing?
03:42:53 <blackh> ImInYourMonad: Can you explain a bit more - I don't quite understand what you want to od.
03:44:36 <trygvis> ski_: hm, ok. thanks, I'll try some more
03:44:50 <ImInYourMonad> in my matrix lib and probably in my vector lib there is a lot of the same pattern. take the datastructure of the matrix out of the type, dos oemthign with it, then add the type to it again, can this soemhow be automated?
03:46:18 <blackh> One possibility would be to write a lift-style function that takes a function and "lifts" it into your matrix.
03:47:27 <blackh> e.g. liftMat :: (x -> x) -> Matrix x -> Matrix x   <-- that sort of thing
03:48:45 <maxote> wli, you did a grave mistake
03:49:22 <wli> Which time?
03:51:51 <maxote> it's not true that n < floor(sqrt(n))^2+floor(sqrt(n))+1  e.g. it fails for n=7 { 7<7 }, n=8 { 8<7 }, n=13 { 13<13 }, n=14 { 14<13 }, n=15 { 15<13 }, and so on.
03:52:54 <wli> When did I say that?
03:54:49 <maxote> 10:55 CET <wli> x = 2*a + (b - a^2) / x, so choose b = n, a = floor (sqrt n), then k <= sqrt n < k + 1 gives 0 <= n - k^2 < 2 * k + 1, <= 2*sqrt n + 1, but there's something where you should be able to pull out a multiplicative factor
03:55:34 <maxote> it's not true it <2k+1 from 0 <= n - k^2 < 2 * k + 1
03:55:56 <maxote> where k was floor(sqrt(n)) right?
03:55:57 <wli> Why do I not feel compelled to answer this?
03:57:09 <maxote> i added them k^2 to get n < floor(sqrt(n))^2+floor(sqrt(n))+1
03:57:55 <wli> floor(sqrt(n))^2 + 2*floor(sqrt(n)) + 1 = (floor(sqrt(n)) + 1)^2
03:58:21 <wli> 0 <= sqrt(n) < floor(sqrt(n)) + 1
03:58:36 <maxote> yes, and it's not > than n (for all n)
04:00:04 <wli> 0 <= floor(sqrt(n)) <= sqrt(n) < floor(sqrt(n)) + 1
04:00:38 <wli> which implies (floor(sqrt(n)))^2 <= n <= (floor(sqrt(n)) + 1)^2 = (floor(sqrt(n)))^2 + 2*floor(sqrt(n)) + 1
04:00:47 <maxote> noooo!!!!
04:00:53 <wli> It works. Every time.
04:00:54 <CTA> I'm debating over Winhugs and GHCi
04:01:20 <wli> You missed a factor of 2.
04:01:44 <wli> (floor(sqrt(n)))^2 + floor(sqrt(n)) + 1 = (floor(sqrt(n)) + 1)^2 - floor(sqrt(n))
04:01:58 <wli> This will not be > n on a reliable basis.
04:02:50 <maxote> i missed?
04:03:10 <maxote> oh, yes, i'm sorry!
04:10:44 <bremner> CTA: I would vote for GHCI,  on the grounds that the top level syntax (:type, let, etc...) is used in  Real World Haskell and other documentation
04:11:29 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1849#a1849 <- thanks blackh, i kind of never understood liftM before but I suspected it was something like what I wanted to do. seemed liek such a common pattern there ought to be an abstraction for it.
04:13:25 <blackh> ImInYourMonad: Yes - lifting is a really general concept in Haskell. You could also play around with making it into a Functor and using 'fmap' as your lift function. That may or may not be a good idea, but you can find out if you try it.
04:13:47 <CTA> is :t :l and all that just exactly the same as :type.. like does it do it in the same time etc?
04:14:03 <Alpounet> @faq Can Haskell make me drink 4 coffees in 2 hour ?
04:14:03 <lambdabot> The answer is: Yes! Haskell can do that.
04:14:51 <CTA> is someone who comes on here as bos, bryan o'sullivan or something the one who made RWH>?
04:15:04 <ImInYourMonad> blackh: yeah i was just thinking how i could make an automatic map fucntion
04:15:33 <CTA> @faq b
04:15:33 <lambdabot> The answer is: Yes! Haskell can do that.
04:15:38 <CTA> lol
04:15:51 <CTA> so anything with @faq # will be answered?
04:15:52 <blackh> CTA: Don't know, but dons is Don Stewart.
04:23:29 <bremner> :t interactive
04:23:30 <lambdabot> Not in scope: `interactive'
04:23:36 <bremner> :t interact
04:23:37 <lambdabot> (String -> String) -> IO ()
04:29:26 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1849#a1851 <- how do you mean making a Functor blackh?
04:30:44 <blackh> ImInYourMonad: Yes - that's what I meant. Or you could just do "fmap f v = liftVector f v" might might be more general.
04:31:01 <blackh> ..._which_ might be more general
04:31:15 <blackh> Or just fmap = liftVector
04:37:06 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1849#a1853
04:37:09 <ImInYourMonad> it doesnt work
04:39:25 <blackh> ImInYourMonad: Ah - you're right. The function liftVector is not general enough, that is, it restricts the input type to being the same as the output type, and fmap can't work with this restriction.
04:40:01 <blackh> ImInYourMonad: Change liftVector's type to... (a -> b) -> Vector a -> Vector b
04:41:22 <blackh> ImInYourMonad: Incidentally, you could do this: data Vector v = Vector {fromVector :: v} deriving Show
04:41:43 <blackh> It's just another way of doing what you're already doing.
04:42:18 <blackh> (Then you don't need to define fromVector as a func.)
04:45:40 <ImInYourMonad> thanks blackh, this is really good because im starting to see the use of the more isoteric concepts in Haskell and understanding how things I thought were a bit messy before can be simplified
04:45:52 <ImInYourMonad> but http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1849#a1854 <- how can I use fmap?
04:46:35 <ImInYourMonad> am i not missing something
04:46:43 <ImInYourMonad> how if fmap on lisst defined?
04:46:46 <ImInYourMonad> @src fmap
04:46:46 <lambdabot> Source not found. Just try something else.
04:46:49 <ImInYourMonad> @src map
04:46:49 <lambdabot> map _ []     = []
04:46:49 <lambdabot> map f (x:xs) = f x : map f xs
04:47:16 <blackh> ImInYourMonad: fmap on lists is just map
04:47:34 <benmos> you need fmap (fmap square) I think
04:47:39 <ImInYourMonad> so could I also define a Functor from a Vector to a Matrix or something? is that a mapping between 2 categoreis ? :P
04:47:42 <blackh> ImInYourMonad: Yes, that's it!
04:48:41 <ImInYourMonad> *Vector Control.Monad> fmap (fmap square) (Vector [1,2,3])
04:48:41 <ImInYourMonad> Vector {fromVector = [1,4,9]}
04:48:47 <blackh> ImInYourMonad: You can't do that with a Functor - the "container" type has to stay the same - it's for lifting a function into "something.
04:52:27 <ImInYourMonad> vmap f = fmap (fmap f)
04:55:34 <maxote> @map foo []
04:55:34 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
04:56:46 <maxote> > map foo []
04:56:47 <lambdabot>   Not in scope: `foo'
04:57:26 <maxote> > map map []
04:57:26 <lambdabot>       Overlapping instances for Show ([a] -> [b])
04:57:26 <lambdabot>        arising from a use o...
04:57:43 <maxote> why not?
04:58:51 <maxote> > map map [] []
04:58:52 <lambdabot>   Couldn't match expected type `[a] -> t'
05:01:22 <ImInYourMonad> does it make sence to define instance Num for a vector? if u do v1 * v2 it isn obvious if you mean dotProduct, scalar-product or cross-product right?
05:01:37 <defun> Would anyone here happen to know of a tree-like data structure in which parents can share the same children, and in which the number of children per parent node is infinite? I think this would look somewhat like a net or web, if drawn graphically.
05:02:09 <bremner> defun: really infinite, or just unbounded?
05:03:07 <bremner> if just arbitrary number of children, then I guess a DAG (directed acyclic graph)
05:03:31 <wli> ARHG some of the integers are coming out negative.
05:05:08 <maxote> wli, in sqrt(n) n<0?
05:06:07 <wli> no
05:06:16 <maxote> where in?
05:06:18 <wli> let cf (x :: Double) = let (q :: Integer, r :: Double) = properFraction x in q : cf (recip r) in take 10 $ cf (sqrt 7 + 1 :: Double) :: [Integer]
05:06:18 <wli> [3,1,1,1,4,1,1,1,4,1]
05:06:29 <wli> let cf x = do { (a, u) <- frc x ; v <- inv u ; vs <- cf v ; return $ a : vs } in take 10 . flip runReader 7 . cf $ Q 1 1 1
05:06:29 <wli> [3,1,1,1,5,-3,5,1,1,1]
05:06:34 <defun> bremner: unbounded
05:06:41 <wli> The 5 is wrong, and leads to the -3 after.
05:06:47 <slxix> o
05:07:07 <slxix> oops.  IRC is not vim.
05:07:35 <bremner> defun: so a directed acyclic graph sounds right. I dunno about haskell implementations
05:08:07 <defun> bremner: yes, a DAG seems right. Thanks. I will find a way to implement it.
05:09:10 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1849#a1855 <- why isnt it possinle to define instance Num Vector?
05:09:39 <bremner> ImInYourMonad: what does Num have to support? division would be problematic I suppose
05:10:15 <ImInYourMonad> well you can raise an error then right which is what I do...?
05:10:37 <ImInYourMonad> it might perhaps not make any sense to deifne instance Num anyway since v1 * v2 is a bit ambiguos for vectors
05:10:44 <ImInYourMonad> but why isnt it working at all?
05:12:18 <blackh> ImInYourMonad: Do this: instance (Eq (Vector v), Show v) => Num (Vector v)
05:12:43 <ImInYourMonad> Non type-variable argument in the constraint: Eq (Vector v)
05:12:43 <ImInYourMonad>     (Use -XFlexibleContexts to permit this)
05:12:43 <ImInYourMonad>     In the context: (Eq (Vector v), Show v)
05:13:01 <blackh> Add this line at the top
05:13:12 <blackh> {-# LANGUAGE FlexibleContexts #-}
05:14:25 <blackh> ImInYourMonad: Something is asking for the variables to have Eq and Show instances but I am not sure what it is...
05:14:35 <blackh> ImInYourMonad: But that => stuff should add it
05:14:47 <vincenz> ImInYourMonad: You need to define Eq and Show
05:14:51 <vincenz> they're requirements for Num
05:15:01 <vincenz> class (Eq a, Show a) => Num a where ...
05:15:08 <blackh> Ah - you have done this before!
05:15:22 <vincenz> blackh: referring to me?
05:15:31 <blackh> vincenz: Yes
05:15:31 <wli> Okay, fixed it.
05:15:42 <vincenz> :)
05:15:59 <ImInYourMonad>  unsupported extension: XUndecidableInstances
05:16:04 <ImInYourMonad> which  also had to add
05:16:05 <vincenz> Show is a lame requirement and I do not know the history reasons for requiring it.  Suffice to say, you have to define Eq and Show
05:16:09 <vincenz> ImInYourMonad: you don't need extensions for that code
05:16:12 <wli> It was a sign bug.
05:16:46 <vincenz> how do I annotate that code?
05:17:21 <vincenz> ImInYourMonad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1849#a1856
05:17:24 <vincenz> that should in theory fix it
05:17:37 <vincenz> ImInYourMonad: there's two things you were missing
05:17:44 <vincenz> 1) You were missing an Eq instance for your Vector
05:17:46 <vincenz> secondly when you do
05:17:57 <vincenz> data Foo a = .... deriving(Class, Class2)
05:18:01 <vincenz> it creates
05:18:08 <vincenz> instance (Class a) => Class (Foo a)
05:18:19 <vincenz> for Num, you needed to add the constraint that the 'a' (which is 'v' in your case) actually instatiated those
05:18:27 <vincenz> s/instatiated/instantiated
05:20:11 <vincenz> ImInYourMonad: does that make sense?
05:20:52 <ImInYourMonad> anyone have a link to those category theory lessons with that cute asian girl?
05:21:08 <ImInYourMonad> vincenz: perhaps but i dont get how :P
05:21:27 <vincenz> ImInYourMonad: I fixed your post
05:21:32 <vincenz> the link I pasted
05:21:41 <vincenz> I added Eq to the deriving stanza of Vector
05:21:42 <pejo> @google catsters category theory lecture
05:21:42 <lambdabot> http://www.youtube.com/user/TheCatsters
05:21:42 <lambdabot> Title: YouTube - TheCatsters's Channel
05:22:00 <vincenz> and added the constraints (Eq v, Show v) as constraints to the Num (Vector v) instance
05:22:15 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1852#a1857
05:22:15 <maxote> @go System-F type-system
05:22:16 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-tldi.pdf
05:22:16 <lambdabot> Title: System F with Type Equality Coercions
05:22:53 <maxote> it's 2nd order, System F invented indepently by Girard and Reynolds.
05:23:58 <pejo> maxote, were you looking for pure System F?
05:24:13 <ImInYourMonad> ic ant see where you changed vincenz in your post
05:26:29 <vincenz> ImInYourMonad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1852#a1856
05:26:34 <vincenz> data Vector v = Vector { fromVector :: v } deriving(Eq, Show)
05:26:44 <vincenz> and it should be
05:26:50 <vincenz> instance (Eq v, Show v) => Num (Vector v)
05:27:11 <ImInYourMonad> data Vector v = Vector { fromVector :: v } deriving(Eq, Show)
05:27:15 <ImInYourMonad> instance (Eq (Vector v), Show v) => Num (Vector v)
05:27:20 <ImInYourMonad> is what i ahve, it doesnt work
05:27:37 <jfredett> @seen shapr
05:27:37 <lambdabot> shapr is in #haskell and #haskell-blah. I last heard shapr speak 11h 8m 28s ago.
05:29:54 <blackh> ImInYourMonad: I think you need instance (Eq (Vector v), Show (Vector v)) => Num (Vector v) and the FlexibleInstances extension
05:30:17 <vincenz> o
05:30:20 <vincenz> blackh: you're overcomplicating this
05:30:24 <vincenz> All he needs is
05:30:31 <vincenz> instance (Eq v, Show v) => Num (Vector v)
05:30:31 <vincenz> and
05:30:35 <vincenz> data Vector v = Vector { fromVector :: v } deriving(Eq, Show)
05:31:42 <Axman6> i wish i could go to this :( http://blogs.sun.com/jmcp/entry/kernel_conference_australia_it_s
05:33:16 <vincenz> blackh: besides, what you write makes no sense :)
05:34:01 <blackh> vincenz: Hmm... Making no sense is not so good.
05:34:23 <vincenz> blackh: what you're saying is
05:34:36 <vincenz> if there's an equality instance for 'Vector of v' and a show instance of v, then there's a numeric instance of v
05:34:42 <vincenz> Why not just define the equality instance for Vector of v?
05:34:52 <ImInYourMonad> instance (Eq v, Show v) => Num (Vector v) , thats it yes
05:34:59 <vincenz> right
05:35:04 <vincenz> deriving (Eq) for Vector v means
05:35:04 <blackh> vincenz: You're quite right
05:35:13 <vincenz> if there's an Eq for v, then I will autodefine an Eq for (Vector v)
05:35:19 <vincenz> so you still need the constaint that 'Eq v' exists
05:35:31 <vincenz> think about it like causality chains
05:35:49 <ImInYourMonad> ouldn't match expected type `f a' against inferred type `v'
05:35:49 <ImInYourMonad>       `v' is a rigid type variable bound by
05:35:49 <ImInYourMonad>           the instance declaratio
05:36:09 <vincenz> ImInYourMonad: please use paste?
05:36:50 <vincenz> it's hard to look at it if you just show a part of the error, instead of showing the full source and the full error
05:36:51 <cytzol> Has anyone got LLVM bindings to work under Linux?
05:37:10 <cytzol> llvm provides an .a file, and ghc expects a .so file
05:37:43 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1858#a1858 <- im trying to define negate and abs but i dont get what im doing wrong
05:38:04 <vincenz> cytzol: an .a is a static lib, you need to turn it into a dynamic lib
05:38:24 <cytzol> vincenz: How do I do that?
05:39:05 <vincenz> second
05:39:47 <lilac> ImInYourMonad: i don't understand your 'Vector' type. shouldn't it be 'data Vector a = Vector { fromVector :: [a] }' or similar?
05:40:04 <vincenz> lilac: probably :)
05:40:21 <vincenz> cytzol: I think ld?
05:40:34 <wli> Now I'm getting somewhere.
05:40:42 <vincenz> cytzol: man ld
05:40:50 <cytzol> ok
05:40:52 <ImInYourMonad> data Vector [a] = Vector { fromVector :: [a] }' or similar? you mean?
05:40:58 <lilac> ImInYourMonad: no
05:40:58 <ImInYourMonad> how can it be a -> [a] ?
05:41:03 <Axman6> Vector a
05:41:08 <ImInYourMonad> Vector [1,2,3]
05:41:14 <pejo> vincenz, you need the .so to contain position independent code as well, recompile the library instead.
05:41:24 <lilac> ImInYourMonad: Vector [1,2,3] :: Vector Int
05:41:32 <vincenz> pejo: wrong target, cytzol is the one you intend, but thank you for the information
05:41:53 <Axman6> data Vector a = Vector {fromVector :: [a]}
05:41:57 <pejo> Oh, sorry vincenz.
05:42:01 <cytzol> pejo: Recompile which library? LLVM, or its binding?
05:42:06 <Axman6> deriving (Stuff,Things)
05:42:08 <vincenz> Np, that was informational
05:43:00 <pejo> cytzol, if you need a .so for LLVM and you have an .a it's probably easier to either recompile or install the package that contains the .so.
05:43:33 <cytzol> pejo: I don't have one containing a .so, I just have a .a.
05:43:37 <cytzol> a ".a".
05:44:04 <pejo> cytzol, what distribution?
05:44:09 <ImInYourMonad> data Vector a = Vector { fromVector :: [a] } deriving(Eq, Show)
05:44:11 <cytzol> archlinux
05:44:15 <ImInYourMonad>   Occurs check: cannot construct the infinite type: a = [a]
05:44:15 <ImInYourMonad>     When generalising the type(s) for `liftVector'
05:44:55 <cytzol> I used the haskell-llvm pkgbuild
05:44:58 <pejo> cytzol, I'm guessing dons would know more about haskell on archlinux, he might be around later.
05:45:05 <lilac> ImInYourMonad: right, you need to change liftVector's definition
05:45:08 <cytzol> pejo: ok, thanks.
05:45:15 <ImInYourMonad> but i dont see how the type goes form a to [a], ther eis not ransformation there
05:45:21 <mathijs> Hi all, I'm reading about category theory, and I understand the terminoligy and how it applies to haskell. I get how standard haskell stuff like functions and composition can be translated to category-speak. The only thing that isn't clear to me atm is WHY? what is the advantage of thinking this way? Has it to do with the "know initial and you know all" thingy?
05:45:24 <ImInYourMonad> liftVector :: ([a] -> [b]) -> Vector [a] -> Vector [b] ?
05:45:36 <ImInYourMonad> Occurs check: cannot construct the infinite type: a = [a]
05:45:37 <ImInYourMonad>     When generalising the type(s) for `liftVector'
05:45:39 <lilac> ImInYourMonad: liftVector :: ([a] -> [b]) -> Vector a -> Vector b
05:46:10 <ImInYourMonad> and then how do I change Functor?
05:46:15 <ImInYourMonad> instance Functor Vector where
05:46:15 <ImInYourMonad>     fmap = liftVector
05:47:18 <ImInYourMonad> and should I change the vector-rep to Array?
05:47:28 <ImInYourMonad> in my matrix-lib I use arrays
05:48:59 <lilac> ImInYourMonad: fmap = liftVector . map
05:49:00 <HugoDaniel> hello
05:49:41 <lilac> HugoDaniel: hello!
05:51:32 <ImInYourMonad> ah yes
05:51:37 <chessguy> @pl \f -> m (f:)
05:51:37 <lambdabot> m . (:)
05:51:46 <ImInYourMonad> no i get the fmap directly without doing fmap (fmap f)
05:52:27 <chessguy> @type when
05:52:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:52:40 <lilac> ImInYourMonad: right.
05:53:10 <chessguy> @hoogle m Bool -> m () -> m ()
05:53:10 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
05:53:10 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
05:53:10 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
05:53:20 <HugoDaniel> where can i learn about lazyness in ghc ?
05:53:43 <opqdonut> you mean how it's implemented in ghc?
05:53:47 <HugoDaniel> hmm
05:53:51 <HugoDaniel> yes, sort of
05:54:10 <opqdonut> ?where ifpl
05:54:10 <lambdabot> I know nothing about ifpl.
05:54:22 <HugoDaniel> i want to know how it is used in haskell in more detail
05:54:51 <opqdonut> ?go The Implementation of Functional Programming Languages
05:54:52 <lambdabot> https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
05:54:52 <lambdabot> Title: The Implementation of Functional Programming Languages
05:55:06 <opqdonut> ^ that book has some stuff on how compilers like ghc are implemented
05:55:12 <opqdonut> might be a bit too technical though
05:55:33 <pejo> HugoDaniel, by "used in haskell", do you mean "how it's implemented in ghc", or how one can exploit laziness when programming?
05:56:12 <opqdonut> if you want to see how laziness is used i recommend some haskell tutorial
05:56:20 <ImInYourMonad> can I define more functors for Vector or Functors are esentially map, hence tey are called mappings between categories :P ? but doesnt mapping from ctaegories imply from one category to another rather than a mapping from an item in a category to one in the same?
05:56:25 <HugoDaniel> well, i want to know when the values are processed more precisely
05:56:35 <chessguy> @type sequence_
05:56:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
05:56:37 <HugoDaniel> im guessing this depends on ghc implementation
05:57:01 <opqdonut> HugoDaniel: the basic idea is that pattern matching forces evaluation
05:57:16 <pejo> HugoDaniel, when they are needed, and sometimes earlier than that as an optimization.
05:57:33 <chessguy> @type foldl'
05:57:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:58:09 <HugoDaniel> isn't there a precise way to know it ?
05:58:34 <maxote> @type foldr'
05:58:35 <lambdabot> Not in scope: `foldr''
05:58:39 <opqdonut> HugoDaniel: yeah there is
05:58:56 <opqdonut> HugoDaniel: read up on lambda calculus and evaluation systems for it
05:59:13 <opqdonut> HugoDaniel: especially normal order evaluation, lazy eval is an implementation technique for normal order
05:59:40 <pejo> opqdonut, that discounts any optimizations that ghc might do though.
05:59:56 <opqdonut> pejo: ghc's optimizations don't change semantics
06:00:04 <chessguy> hmm, i'm sure there's a better way to write this
06:00:09 <opqdonut> okay, bar strictness analysis
06:00:15 <pejo> opqdonut, doh, disregards, I mean.
06:00:44 <chessguy> addAll :: [a->a] -> Foo (); addAll [] = return (); addAll (f:fs) = add f >> addAll fs
06:00:50 <pejo> opqdonut, no, but they might change when an expression is evaluated, if you can't observe the difference.
06:00:51 <opqdonut> HugoDaniel: the thing that lazy eval guarantees is that a named value is evaluated at most once
06:00:55 <chessguy> it's almost sequence_
06:01:08 <vincenz> chessguy: how is it not?
06:01:11 <HugoDaniel> ah ok
06:01:13 <vincenz> oh, the ad
06:01:15 <opqdonut> HugoDaniel: this doesn't strictly apply to ghc because of threads and some polymorphism stuff, but it's a good rule of thumb
06:01:19 <vincenz> chessguy: what about: sequence_ . map add
06:01:36 <int-e> chessguy: so it's mapM_
06:01:42 <vincenz> int-e: yes
06:02:00 <chessguy> @type mapM_
06:02:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
06:02:15 <chessguy> oh, of cours
06:02:15 <chessguy> e
06:02:20 <opqdonut> HugoDaniel: you can mostly disregard specific implementations if you just want to understand lazy eval as a programmer
06:02:21 <chessguy> thanks guys
06:03:16 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1859#a1859 <- i dont get how to define Num 's for Vector though, cant i define negate v as fmap negate v? or change ngeate to soemthing thta does the same if there is a circular definition problem arising
06:03:19 <HugoDaniel> yes, im not planning on developing a lazy eval system... at least not now
06:03:25 <opqdonut> :)
06:03:30 <chessguy> it just seems strange to think about a map-like thing when you're not ending up with a list
06:03:49 <opqdonut> ImInYourMonad: it's not circular, the types of those two negates are different
06:03:55 <HugoDaniel> i just would like to know with more precision when are the big computations going to be done in my code
06:04:08 <HugoDaniel> specially since i keep getting this feeling of "postponing" everything
06:04:20 <opqdonut> yeah i understand
06:06:12 <lilac> ImInYourMonad: the typeclass 'Functor' in haskell is really a typeclass of covariant endofunctors on Hask
06:07:20 <DBAlex> hey
06:07:49 <lilac> ImInYourMonad: "negate = fmap negate" would be fine, but you'll need to add Num v to your instance's context
06:07:51 <DBAlex> can someone explain in english what this part "x == y = x : munch (y:ys)" of this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1826#a1826 actually means?
06:07:57 <wli> This thing seems to have trouble with Fermat numbers.
06:08:10 <lilac> ImInYourMonad: since Eq and Show are superclasses of Num, you can replace the existing context with Num v
06:08:23 <DBAlex> x == y is a comparison, so is that like an if statement?
06:08:33 <lilac> DBAlex: the relevant part is | x == y = ...
06:08:41 <DBAlex> but what does the second equals after mean ? lilac ?
06:08:46 <ImInYourMonad> lilac: but how?
06:08:55 <ImInYourMonad> instance (Eq v, Show v) => Num (Vector v)
06:09:02 <DBAlex> the comparison is equal to x in munch y ys ?
06:09:05 <DBAlex> what the f***?
06:09:06 <ImInYourMonad> instance (Eq v, Show v) => (Num (Vector v), Num v) ?
06:09:10 <lilac> DBAlex: in haskell you can say: "foo a b | cond = expr"
06:09:10 <opqdonut> DBAlex: x |p = y means "x is y when p"
06:09:26 <vincenz> chessguy: hi
06:09:27 <lilac> DBAlex: cond is "x == y", expr = "x:munch (y:ys)"
06:09:27 <DBAlex> hmm
06:09:38 <chessguy> vincenz:  hi
06:09:46 <DBAlex> ok
06:09:48 <DBAlex> 1 sec
06:09:54 <lilac> DBAlex: this says, "when x == y, the result is x:munch(y:ys)"
06:10:19 <lilac> ImInYourMonad: instance (Num v) => Vector v where ...
06:10:46 <DBAlex> lilac: and what does x:munch(y:ys) mean? to mean it means select x from the output of munching y in ys ?
06:10:51 <lilac> gah, "instance (Num v) => Num (Vector v) where"
06:11:26 <wli> Any number of the form 2^n +1 even
06:11:27 <lilac> DBAlex: a:b means create the list where 'a' is the first element and the rest of the ilst is 'b'
06:11:40 <lilac> > 1:[2,3,4]
06:11:41 <lambdabot>   [1,2,3,4]
06:11:49 <DBAlex> ah ok
06:11:53 <wli> Or even p^n + 1
06:12:10 <vincenz> chessguy: I saw you started following my twitter :)
06:12:31 <chessguy> vincenz:  indeed. i always perk up when i see your blog entries
06:12:39 <vincenz> Ah, thanks
06:13:12 <vincenz> I don't know why, I'm not that great a writer
06:13:15 <vincenz> And they're not ultra complicated
06:13:17 <opqdonut> which reminds me, I should blog about the gadts vs fundeps comparison I did
06:13:25 <Heffalump> is there some documentaiton of how to configure gtk2hs so that it installs in a directory specific to the GHC version?
06:13:26 <ImInYourMonad> --instance (Num v) => Vector v
06:13:26 <ImInYourMonad> instance (Eq v, Show v) => Num (Vector v)
06:13:31 <ImInYourMonad> but how int he same?
06:13:36 <opqdonut> implemented dimension-checked vector arithmetic with bot
06:13:36 <opqdonut> h
06:13:41 <wli> Worse yet, m^n + 1
06:13:42 <dcoutts> Heffalump: use --prefix and --libdir
06:13:52 <Heffalump> dcoutts: is that definitely all that's needed?
06:14:08 <dcoutts> Heffalump: only the libs are ghc-version specific, so it should be all
06:14:42 <Heffalump> ok, thanks
06:15:52 <int-e> dcoutts: hmm I've never needed --libdir
06:16:17 <Heffalump> can I also just move an installed tree around, or does it know its own locations?
06:16:36 <dcoutts> Heffalump: ghc-pkg knows where the libs are registered, but that's all
06:16:56 <dcoutts> int-e: it's not needed for cabal packages because by default we use a ghc-specific lib subdir, gtk2hs does not do that
06:17:12 <Heffalump> what are the obstacles to cabalising it, BTW?
06:17:33 <dcoutts> Heffalump: on windows the installer adjusts the %PATH% so if you're on windows you'd need to fix that up too
06:17:42 <dcoutts> Heffalump: using c2hs
06:17:43 <int-e> dcoutts: ah! right, I install different ghc versions with different prefixes, and use the same prefix for gtk2hs.
06:18:30 <dcoutts> Heffalump: cabal only handles simple preprocessors because it does not track dependencies
06:18:50 <dcoutts> Heffalump: for .hs file ghc --make does it, for .chs files we just do it in the wrong order
06:19:01 <Alpounet> http://compsoc.dur.ac.uk/whitespace/index.php waw...
06:19:22 <dcoutts> Heffalump: it doesn't matter for most pre-processors, but .chs files can import each other
06:19:50 <dcoutts> and gtk2hs has >100 .chs files and uses the c2hs {# import #} heavily
06:19:58 <Saizan_> dcoutts: don't you also need to build more of the packages at once since they are recursive?
06:20:15 <dcoutts> Saizan_: no, they are not recursive
06:20:58 * dcoutts releases c2hs-0.16.0
06:22:28 <int-e> gtk2hs still uses a custom c2hs, too.
06:22:36 <dcoutts> int-e: that too
06:23:13 <dcoutts> the only problem there is a construct we added for the gtk2hs c2hs which makes it easier to use foreign pointers
06:23:25 <Heffalump> why not merge it in?
06:23:44 <dcoutts> it's not compatible with the approach c2hs took in the mean time
06:24:14 <dcoutts> gtk2hs extended {# call #} but c2hs added a more general {# fun #} with automatic marshaling
06:24:17 <wli> Multiplying by small integers seems to help.
06:24:29 <dcoutts> but gtk2hs needs something in between {# call #} and {# fun #}
06:24:30 <wli> (small primes, maybe?)
06:25:43 <wli> factor (3*(2^(32::Int)+1)) --> (641,20101251)
06:27:30 <ImInYourMonad> why does for Instance Num, abs = fmap abs work, but not fromInteger 0 fmap fromInteger?
06:28:04 <wli> fromInteger is polymorphic on the result type only.
06:28:07 <ImInYourMonad> ah wait, my Vector isnt defined to hold only Integers ?
06:28:49 <ImInYourMonad> cant i say: if my Vector is fo type Integer then apply fromInteger else raise error?
06:29:07 <byorgey> ImInYourMonad: the types of abs and fromInteger are very different.
06:29:09 <byorgey> @type abs
06:29:11 <lambdabot> forall a. (Num a) => a -> a
06:29:37 <byorgey> if you're making an instance for Vector,  abs takes a Vector.  so if Vector is an instance of Functor, you can say fmap abs.
06:29:40 <byorgey> however:
06:29:44 <byorgey> @type fromInteger
06:29:45 <lambdabot> forall a. (Num a) => Integer -> a
06:29:55 <byorgey> fromInteger takes an Integer.  Integer is not an instance of Functor.
06:29:56 <ImInYourMonad> fromInteger (Vector [Integer]) = fmap fromInteger
06:29:56 <ImInYourMonad>           fromInteger (Vector [_]) = error "Type not supported"
06:30:13 <ImInYourMonad> ok
06:30:17 <byorgey> ImInYourMonad: that doesn't make sense.  fromInteger takes an Integer as input.
06:30:21 <wli> factor (17*(2^(2^(6::Int)::Int)+1)) --> (1143767162282257,274177)
06:30:38 <byorgey> fromInteger n = ??? some Vector
06:31:02 <byorgey> like  Vector n n n, or Vector n 0 0, or something like that, probably
06:31:06 <dcoutts> Heffalump: what're you using gtk2hs for ooi?
06:31:20 <Heffalump> byorgey's diagrams package
06:31:36 <Heffalump> and indirectly for drawing darcs patch commutation diagrams
06:31:41 <byorgey> ImInYourMonad: or you can decide that making any Integer into a Vector doesn't make sense, and just have it give an error.
06:31:55 <byorgey> ImInYourMonad: which could be a reasonable thing to do since fromInteger doesn't really belong in the Num class.
06:34:08 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1860#a1860 <- my current vector module, what do you think?
06:35:02 <blackh> ImInYourMonad: I like it.
06:37:24 <byorgey> ImInYourMonad: looks nice so far.  have you forgotten to implement scalarProduct? =)
06:43:52 <Heffalump> dcoutts: is there any reason (apart from time) not to make gtk2hs use installation directories that mirror what cabal packages do?
06:44:06 <dcoutts> Heffalump: none
06:44:41 <CTA> how do i create a function with a symbol instead of text.. e.g. + x y = x + y
06:45:19 <trygvis> CTA: try :info + in ghci
06:45:32 <Igloo> CTA: (*) x y = x + y
06:46:29 <wli> I can't find a convenient premultiplier for 2^(2^(7::Int)::Int)+1
06:47:10 <wli> It does look like the algorithm needs some adjustment to account for recalcitrant cases like Fermat numbers.
06:51:33 <wli> Wow, it took down 2^(46::Int)+1 with some swiftness.
06:55:43 <byorgey> CTA: you can also define infix operators with infix notation, like this:
06:56:00 <byorgey> > let x **& y = x + 3*y  in  3 **& 5
06:56:03 <lambdabot>   18
06:59:46 <Fredrik> Which of the following is more idiomatic?
06:59:46 <Fredrik>     putStrLn . unlines . tails $ name
06:59:47 <Fredrik>     putStrLn . unlines $ tails name
07:02:44 <Heffalump> Fredrik: the former, probably
07:02:50 <Heffalump> but it depends a bit on which feels natural to you
07:03:25 <Igloo> I would use putStrLn $ unlines $ tails name
07:03:34 <int-e> putStrLn $ unlines . tails $ name ?
07:03:56 <Cheshire> I write:  (putStrLn . unlines . tails) name
07:03:56 <Fredrik> this looks very symmetric :)
07:03:59 <int-e> why putStrLn and not putStr anyway?
07:04:05 <Fredrik> right
07:04:15 <Deewiant> > unlines ["foo"]
07:04:16 <lambdabot>   "foo\n"
07:04:18 <arjanb> i use both depending on how the code got changed to that
07:06:21 <Fredrik> Hm wait, I found a better solution :)
07:06:21 <Fredrik> import Data.List
07:06:21 <Fredrik> triangle = putStr . unlines . tails
07:06:21 <Fredrik> main = do
07:06:21 <Fredrik>     putStrLn "What is your name?"
07:06:21 <Fredrik>     name <- getLine
07:06:23 <Fredrik>     triangle name
07:07:14 <Cheshire> :t putStr `fmap` unlines `fmap` tails `fmap` getLine
07:07:15 <lambdabot> IO (IO ())
07:10:38 <cnwdup> :t join
07:10:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:11:12 <Cheshire> (putStr . unlines . tails) =<< getLine
07:11:59 <mjb> Given a type that derives Enum is there a method to find the last tag of the enumeration?
07:12:02 <Alpounet> @pl \n -> putStrLn . unlines . tails $ n
07:12:02 <lambdabot> putStrLn . unlines . tails
07:12:50 <Cheshire> @src Enum
07:12:50 <lambdabot> class  Enum a   where
07:12:50 <lambdabot>     succ                     :: a -> a
07:12:50 <lambdabot>     pred                     :: a -> a
07:12:50 <lambdabot>     toEnum                   :: Int -> a
07:12:50 <lambdabot>     fromEnum                 :: a -> Int
07:12:52 <lambdabot> [3 @more lines]
07:12:57 <Cheshire> @more
07:12:57 <lambdabot>     enumFrom                 :: a -> [a]
07:12:57 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
07:12:58 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
07:13:21 <Cheshire> @src Bounded
07:13:21 <lambdabot> class  Bounded a  where
07:13:21 <lambdabot>     minBound, maxBound :: a
07:13:41 <mjb> Cheshire: Thanks!
07:15:46 <burp> hi, "cabal: cannot configure hxt-8.2.0. It requires base >=4" what is it about this base package?
07:15:59 <HugoDaniel> burp: upgrade your ghc
07:15:59 <burp> I have ghc 6.8.2
07:16:16 <burp> can't I install an older version of hxt via cabal?
07:16:29 <HugoDaniel> yes
07:16:35 <HugoDaniel> cabal install hxt-8.1.0
07:16:39 <HugoDaniel> and there you go
07:16:45 <burp> thanks
07:16:57 <Saizan_> you've to specify that version yourself because the dependency solver is not complete
07:20:29 <burp> debian has ghc 6.8.10 just in unstable
07:20:51 <bremner> burp: true, but some the libraries are still migrating
07:21:20 <burp> yep, thats what I experienced while trying to use ghc from unstable
07:21:21 <burp> broken dependencies
07:23:39 <ImInYourMonad> what other Functors can I define?
07:25:23 <blackh> ImInYourMonad: If you want to go totally crazy, I think you might be able to define an Applicative instance for Vector, then you can define ...
07:25:50 <blackh> v1 + v2 = liftA2 (+) v1 v2
07:26:12 <blackh> At least that's my theory.
07:26:29 <gwern> yay, interwikis are now working in gitit
07:32:35 <Fredrik> @pf a+b
07:32:35 <lambdabot> Maybe you meant: bf pl
07:32:38 <Fredrik> @pl a+b
07:32:38 <lambdabot> a + b
07:33:13 <Fredrik> @pl do {x <- readLn; inputAndSum (acc + x);}
07:33:13 <lambdabot> (line 1, column 4):
07:33:13 <lambdabot> unexpected "{"
07:33:13 <lambdabot> expecting variable, "(", operator or end of input
07:34:43 <arjanb> @@ @pl @undo do {x <- readLn; inputAndSum (acc + x);}
07:34:43 <lambdabot>  inputAndSum . (acc +) =<< readLn
07:35:10 <ImInYourMonad> blackh: ok i will look into it
07:35:53 <Fredrik> Is it possible to check wether "read" will succeed? Or must I catch exception?
07:36:33 <blackh> ImInYourMonad: See Control.Applicative. pure could be defined as "pure x = Vector [x]" - I can't think of any other definition that makes sense.
07:37:09 <Saizan_> Fredrik: use readM s = case reads s of [(a,rest)] | all isSpace rest -> Just a; _ -> Nothing
07:37:29 <blackh> There doesn't seem to be much of a point to a single-dimensional vector but it might be useful as a representation of a scalar for multiplying with a vector...
07:38:43 <Fredrik> What I mean is I want to parse a String into an Int, but when the String is not parsable as an Int, I want to do something else
07:38:46 <blackh> So... "pure 5" would mean the same thing as "Vector [5]".  You could say "Vector [1,0,0] * pure 5" for example.
07:38:52 <Fredrik> > read "123"
07:38:53 <lambdabot>   * Exception: Prelude.read: no parse
07:38:54 <blackh> Not sure if this makes sense for what you want or not.
07:39:16 <Fredrik> > read "123" :: Int
07:39:17 <lambdabot>   123
07:39:22 <Fredrik> > read "nonsense" :: Int
07:39:23 <lambdabot>   * Exception: Prelude.read: no parse
07:39:27 <Fredrik> there we are
07:39:37 <blackh> ImInYourMonad: I must go - it's late.  Good night!
07:40:46 <Fredrik> This is what I do now http://haskell.pastebin.com/m13063d8f
07:40:55 <nomeata> Fredrik: you can use readPrec somehow, but it’s not very nice
07:41:10 <nomeata> > readsPres 0 "nonsense"
07:41:11 <lambdabot>   Not in scope: `readsPres'
07:41:12 <LeoD> is there any difference between pure and return?
07:41:13 <nomeata> > readsPrec 0 "nonsense"
07:41:14 <lambdabot>   []
07:41:35 <nomeata> > (readsPrec 0 "nonsense") :: [(Int,String)]
07:41:36 <lambdabot>   []
07:41:40 <nomeata> > (readsPrec 0 "123) :: [(Int,String)]
07:41:41 <lambdabot>   <no location info>:
07:41:41 <lambdabot>      lexical error in string/character literal at chara...
07:41:44 <nomeata> > (readsPrec 0 "123") :: [(Int,String)]
07:41:45 <lambdabot>   [(123,"")]
07:41:49 <nomeata> (sorry for the spamming :-)
07:42:46 <nomeata> but yes, a "tryread:: Read a => String -> Maybe a" would be useful
07:44:37 <nomeata> Actually, there is "readEither :: Read a => String -> Either String a" in Text.Read, but it’s not exported
07:44:55 <arjanb> i think read should return a Maybe by default
07:45:23 <wli> MonadError
07:45:41 <blackh> LeoD: When a data type is an instance of both Functor and Monad, pure and return are the same.
07:45:55 <LeoD> ah, i see
07:45:56 <nomeata> blackh: at least they should be, by convention
07:49:23 <LeoD> all those typeclasses in the stdlib are kinda hard to keep apart :(
07:50:38 <Saizan_> @google typeclassopedia
07:50:40 <lambdabot> http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
07:50:40 <lambdabot> Title: The Typeclassopedia — request for feedback « blog :: Brent -> [String]
07:52:04 <LeoD> ohh, that looks nice :D
07:52:20 <wli> It'd be nice if this had some more intelligent way to fail on primes than looping.
07:55:29 <Fredrik> So is there a nicer way than this?
07:55:29 <Fredrik> inputAndSum acc = catch
07:55:30 <Fredrik>     (readLn >>= \x -> inputAndSum (acc + x))
07:55:30 <Fredrik>     (\_ -> return acc)
07:58:42 <burp> does Text.Regex.Posix not support [String] matches?
07:58:47 <burp> html =~ "<img src=\"(.+)?\">" :: [String]
07:58:52 <burp> No instance for (RegexContext Regex String [String])
07:59:11 <burp> a single String works, but as I read [String] for all matches should also work
08:01:47 <paper_cc> @ty (=~)
08:01:48 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
08:02:12 <paper_cc> @instances-importing Text.Regex.Posix RegexContent
08:02:12 <lambdabot> Couldn't find class `RegexContent'. Try @instances-importing
08:07:48 <mdmkolbe> IORef is to References as IO is to what?  I'm having trouble coming up with the right word.  Any ideas?
08:07:58 <chessguy> heh. i wonder if "type State2 a b = StateT a (State b)" is generally useful. probably not
08:09:13 <mdmkolbe> chessguy: usually someone would just do "State (a, b)"
08:09:16 <lilac> LeoD: every Monad instance gives rise to an Applicative instance (pure = return, (<*>) = ap). However, there are some Applicative instances which don't correspond to Monad instances
08:09:22 <chessguy> true
08:10:03 <lilac> LeoD: it's normal for the default Applicative instance (the one without a newtype) to be the one derivable from the corresponding Monad instance
08:10:39 <paper_cc> mdmkolbe: IORef is to variables as IO is to mutability
08:10:40 <lilac> LeoD: so in that sense, it's normal that whenever return and pure are both defined for a type, they do the same thing (but this is not guaranteed)
08:10:59 <LeoD> lilac: ah ok, that makes sense :)
08:12:17 <paper_cc> let html = "<img src='foo'> <img src='http://www.example.com/a.gif'>" in html =~ "<img src='(.+)?'>" :: [[String]]
08:12:28 <paper_cc> >> let html = "<img src='foo'> <img src='http://www.example.com/a.gif'>" in html =~ "<img src='(.+)?'>" :: [[String]]
08:12:35 <paper_cc> bzz... sorry :(
08:12:37 <paper_cc> > let html = "<img src='foo'> <img src='http://www.example.com/a.gif'>" in html =~ "<img src='(.+)?'>" :: [[String]]
08:12:38 <lambdabot>   [["<img src='foo'> <img src='http://www.example.com/a.gif'>","foo'> <img sr...
08:13:32 <mdmkolbe> @index (=~)
08:13:32 <lambdabot> bzzt
08:13:37 <mdmkolbe> @type (=~)
08:13:38 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
08:13:59 <chessguy> @bot
08:13:59 <lambdabot> :)
08:14:00 <lunabot>  :)
08:14:08 <paper_cc> burp: ^^ it looks like it supports [[String]] matches
08:17:01 <pernod> Is there quickcheck "cookbook" somewhere?
08:17:45 <pernod> That shows me how to test my functions with short and easily understandable words?
08:18:01 <Saizan_> there's a manual
08:18:05 <pernod> I know.
08:18:12 <pernod> It fails on the short and easily understandable words.
08:18:19 <pernod> (For me, at least :))
08:19:07 <Saizan_> where are you stuck?
08:22:25 <pernod_> Sorry, fell off the internet.
08:22:27 <pernod_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1861#a1861
08:22:45 <shapr> pernod_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1862#a1862
08:22:45 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
08:22:50 <pernod_> I want to generate input values in the range 0 to 1, and 0 to e.g 50
08:23:58 <mdmkolbe> @type (==>)
08:23:59 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
08:24:35 <mdmkolbe> \x -> (0 < x && x < 1) ==> rest_of_prop x
08:24:51 <mdmkolbe> pernod_ this is the cheap way to do it
08:24:56 <pernod_> Ok.
08:25:01 <shapr> You probably want to write your own generator though.
08:25:08 <Saizan_> pernod_: do (x,y) <- forAll (choose (0,1),choose (0,5); return $ compound x y == exp(x*y)
08:25:18 <shapr> Because if you produce a bunch of Ints, many of them will not satisfy that condition.
08:25:43 <Saizan_> forAll let you use your own generator, instead of the one in the Arbitrary instance
08:26:00 <chessguy> sparsecheck does that kind of thing too
08:26:11 <pernod_> I tried doing the property trick on a more involved case and ended up exhausting all my generated values, so I thought I'd try to understand other generators.
08:26:29 <mdmkolbe> pernod_: the concerns that shapr raises are significant (thus why I said "cheap"), you should only do it the way I suggested if this is a really cheap dry run.
08:26:36 <Saizan_> ops, my example is not correct
08:27:11 <Saizan_> pernod_: do x <- forAll (choose (0,1)); y <- forAll (choose (0,5)); return $ compound x y == exp(x*y)
08:28:30 * SamB thinks firefox ought to make all toolbars visible temporarily when you open the "customize toolbar" thing so that you can drag things off of the disabled ones
08:29:43 <pernod_> Saizan_: Thanks, though I get an error message in ghci:
08:29:52 <pernod_>     The last statement in a 'do' construct must be an expression
08:30:01 <ImInYourMonad> can someone give an example of a simple Monad to implement that isn't a part of ghc?
08:30:33 <mdmkolbe> ImInYourMonad: reverse state monad
08:31:02 <mdmkolbe> ImInYourMonad: take a state monad and make the state flow backwards
08:31:11 <ImInYourMonad> eh?
08:31:19 <pernod_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1861#a1863
08:31:34 <SamB> hehehe
08:31:54 <byorgey> ImInYourMonad: there aren't really any simple ones that aren't already in the standard libraries.
08:32:06 * SamB laughs at the idea of using the Google toolbar to do Yahoo! searches
08:32:15 <mdmkolbe> ImInYourMonad: in "do { x; y; z}", "z" gets the original state and any modifications it makes get passed to "y" and the state modified by "y" gets passed to "x"
08:32:18 <byorgey> ImInYourMonad: why not implement ones that already are in the libraries?  even if you know what they do, implementing them yourself is a good exercise.
08:32:19 <Saizan_> pernod_: the return mist be aligned with the above 'y'
08:32:26 <Saizan_> s/mist/must/
08:32:46 <byorgey> ImInYourMonad: e.g. implement Maybe, and [], and ((->) e), and maybe State
08:32:50 <mdmkolbe> ImInYourMonad: it's more of a cute trick than an actually useful monad though
08:34:42 <pernod_> Saizan_: Thanks. One error down, more to go :)
08:34:43 <pernod_>     Couldn't match expected type `Float'
08:34:43 <pernod_>            against inferred type `Property'
08:34:44 <pernod_>     In the first argument of `compound', namely `x'
08:34:44 <pernod_>     In the first argument of `(==)', namely `compound x y'
08:34:44 <pernod_>     In the second argument of `($)', namely
08:34:44 <pernod_>         `compound x y == exp (x * y)'
08:34:53 <pernod_> (Sorry for being dense)
08:36:16 <Saizan_> no, sorry, i've been using forAll assuming a wrong type
08:36:30 <Saizan_> forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
08:36:38 <Saizan_> and Testable Bool
08:38:51 <Saizan_> pernod_: my last annotation should work :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1861#a1865
08:39:58 <pernod_> Saizan_: Indeed!
08:40:03 <pernod_> Thank you very much.
08:40:15 <pernod_> What's going on in there, though?
08:42:18 <Saizan_> pernod_: forAll takes a generator and pass values from it to the function it takes as second argument
08:42:43 <Saizan_> so, if you need more than one generator you can nest forAll calls
08:43:37 <pernod_> I think I understand.
08:43:53 <pernod_> I have another case where I need six inputs, though :)
08:43:58 <pernod_> It will look dodgy ;)
08:44:38 <Saizan_> are they of the same type?
08:45:16 <Saizan_> or you can define Arbitrary instances for them so that you don't have to use forAll at all
08:45:31 <pernod_> Saizan_: Two of them will be positive Doubles, the rest will be percentages like the ones you just illustrated in your example.
08:46:20 <pernod_> I think Arbitrary is the next step, yes.
08:46:44 <pernod_> So we come back to me needing a quickcheck cookbook for OO-dummies :)
08:47:08 <Saizan_> e.g. replicateM 5 (choose (0,50)) gives you a list of 5 elements choosen in that range
08:47:29 <pernod_> Hm. Let me try that.
08:47:45 <trygvis> when I have a function signature like this: "updateTweets db (Tweet tid _ _ _:ts) = do", is it possible to name the Tweet with a variable?
08:48:27 <mauke> tweet@(Tweet ...)
08:48:29 <LeoD> foo@(Tweet tid _ _ _:ts)
08:49:15 <Saizan_> pernod_: other example: newtype Percentage = P Float; instance Arbitrary Percentage where arbitrary = do x <- choose (0,50); Percentage x
08:49:42 <trygvis> thanks!
08:49:56 <Saizan_> pernod_: the coarbitrary method is often left undefined, it's needed only when you want to test functions
08:50:31 <Saizan_> err, test using functions as inputs
08:51:30 <LeoD> @pl \e -> h (g e)
08:51:30 <lambdabot> h . g
08:51:53 <pernod_> Saizan: I can't get it to compile in ghci, though.
08:51:59 <pernod_> COmplaining about the return again.
08:52:19 <Saizan_> i forgot the return..
08:52:28 * Saizan_ is being sloppy today
08:53:13 * pernod_ has probably not done his homework on Monads ....
08:53:21 <pernod_> I'm a bit slow on these things.
08:54:02 <LeoD> @pl \e -> h (g e) e
08:54:02 <lambdabot> h =<< g
08:54:15 <Saizan_> pernod_: this should compile http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1861#a1866
08:55:30 <Saizan_> pernod_: i used a newtype since there's probably already an instance for Float, that gives you a different range
08:56:19 <pernod_> Saizan: That default float with increments of 0.5 is the source of my troubles, so defining a special case with different behaviour is an abstraction I like.
08:56:21 <pernod_> Makes good sense.
08:58:18 <Fredrik> @pl readLn >>= \x -> foldOverLines fun (fun acc x)
08:58:18 <lambdabot> foldOverLines fun . fun acc =<< readLn
08:59:22 <Saizan_> pernod_: with that instance you should be able to write this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1861#a1867
09:00:35 <LeoD> @src join
09:00:35 <lambdabot> join x =  x >>= id
09:00:59 <pernod_> Isn't it possible to specify that the x is type Percentage and avoid the forAll and nesting?
09:01:40 <Saizan_> pernod_: yes, but then it'll be chose in the range (0,50) instead of (0,1)
09:01:44 <pernod_> Something along the lines of where types = (x::Percentage, y::Percentage))
09:01:46 <Fredrik> Can I express the foldOverLines idea more concise than here? http://haskell.pastebin.com/m786bd15
09:02:58 <chrisdone> the @faq should provide more answers like "The answer is nomads. Haskell nomads.", "Did you forget to import -XFlexibleInstances?", "Record syntax was put there by SPJ to test us.", etc.
09:03:54 <jganetsk> question about haskell GC... why does evacuate copy all the words in the heap object?
09:04:00 <Cheshire> chrisdone no record syntax is the remains of all those that drowned when noah was in the ark
09:04:06 <jganetsk> why doesn't it just let scavenge copy the words
09:04:27 <jganetsk> by just putting a pointer in the to-object back to the from-object so that scavenge can do the work later
09:04:31 <Heffalump> jganetsk: might be best to ask on #ghc
09:04:36 <chrisdone> Cheshire: haha
09:04:37 <jganetsk> ok thnks-
09:07:21 <Saizan_> pernod_: prop_compound (P x) (P y) =             compound x y == exp(x*y)
09:07:44 <Saizan_> pernod_: that works but it's not the same as the former
09:08:06 <pernod_> Saizan: I like that one.
09:08:51 <pernod_> I defined a different generator for the year, so I could get a different range.
09:09:23 <pernod_> It gives more concise properties, though at the cost of lots of extra types. A trade-off I'll have to think more of.
09:09:42 <pernod_> Saizan: Thank you. You have been most helpful.
09:09:56 <Saizan_> if you reuse those types for multiple properties i think it's worth it
09:10:09 <pernod_> I will.
09:10:13 <pernod_> My next step :)
09:10:16 <Saizan_> pernod_: np :)
09:10:18 <pernod_> But not today.
09:10:23 <pernod_> Have a good weekend!
09:10:40 <Saizan_> bye
09:12:12 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1868#a1868 <- ROT13 , how can I make the rot13 function cleaner? can I "thread" Maybe results through the whole computation?
09:13:25 <Saizan_> ImInYourMonad: yes, you can use the Maybe monad
09:14:42 <ozy`> ImInYourMonad: your own nick provides the answer
09:22:17 <alar> $ ghc -c mproc2.hs
09:22:17 <alar> $ ghc mproc2.o -package hmatrix -lgfortran
09:22:17 <alar> $ ghci mproc2.hs -package hmatrix -lgfortran
09:22:17 <alar> GHCi, version 6.8.3: http://www.haskell.org/ghc/  :? for help
09:22:17 <alar> Loading package base ... linking ... done.
09:22:18 <alar> Loading package HUnit-1.2.0.0 ... linking ... done.
09:22:22 <alar> Loading package old-locale-1.0.0.0 ... linking ... done.
09:22:24 <alar> Loading package old-time-1.0.0.0 ... linking ... done.
09:22:26 <alar> Loading package random-1.0.0.0 ... linking ... done.
09:22:28 <alar> Loading package QuickCheck-1.1.0.0 ... linking ... done.
09:22:30 <alar> Loading package array-0.1.0.0 ... linking ... done.
09:22:32 <alar> Loading package filepath-1.1.0.0 ... linking ... done.
09:22:34 <alar> Loading package directory-1.0.0.1 ... linking ... done.
09:22:36 <alar> Loading package unix-2.3.0.1 ... linking ... done.
09:22:38 <alar> Loading package process-1.0.0.1 ... linking ... done.
09:22:40 <alar> Loading package haskell98 ... linking ... done.
09:22:42 <alar> Loading package storable-complex-0.1 ... linking ... done.
09:22:44 <alar> Loading package hmatrix-0.4.0.0 ... <command line>: can't load .so/.DLL for: lapack (/usr/local/lib/liblapack.so: Undefined symbol "ztbsv_")
09:22:45 <Cheshire> thanks alar
09:22:47 <alar> how can it be?
09:22:50 <arjanb> please use a pastebin
09:22:53 <alar> ghc finds all libraries, but ghc can't?
09:23:24 <lilac> > map (\c -> toEnum $ (ord c - ord 'a' + 13) `mod` 26 + ord 'a') "hello" :: String
09:23:25 <lambdabot>   "uryyb"
09:23:35 <lilac> ImInYourMonad: ^^ i'd do it something like that
09:24:07 <ImInYourMonad> i dont see how to use the MaybeMonad for it?
09:24:11 <ImInYourMonad> http://www.haskell.org/all_about_monads/html/maybemonad.html
09:31:06 <ImInYourMonad> lilac: where is ord?
09:31:12 <mauke> @index ord
09:31:12 <lambdabot> Data.Char
09:32:43 <ImInYourMonad> thanks, thats a lot nicer
09:33:15 <lilac> ImInYourMonad: you're going to need to deal with characters which aren't in ['a'..'z'] somehow :-/
09:33:51 <ImInYourMonad> but anyhow, could I somehow clean up my own rot13, useful lesson
09:34:05 <Saizan_> alar: ghci uses its own linker, and it's generally more picky
09:35:07 <Saizan_> alar: if /usr/local/lib/liblapack.so is a linker script consider making it a symlink to the real library
09:35:58 <alar> it is symlink
09:38:31 <alar> it seems tha GHCi somehow can't load library gfortran
09:45:01 <xenoblitz> hi people I thought of a good haskell mini-project... I want to find out the possible divisions of a whole integer into for example 3 whole integers...e.g. 5 in to 3 is 1,1,3 ...2,1,2 ... 2,2,1 and so on... and I was thinking of doing it in haskell... was wondering what I should look up on cause I'm at a loss of what this process is called ... similar to factoring but with sums... any ideas? :)
09:45:35 <tromp_> partitioning
09:45:46 <xenoblitz> tromp: thanks :)
09:49:18 <lilac> ImInYourMonad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1868#a1870
09:49:42 <vincenz> alar: was that REALLY necessary?
09:50:22 <alar> vincenz: what?
09:50:33 <vincenz> alar: all the spam
09:50:37 <alar> no
09:50:40 <bremner> xenoblitz: stirling numbers of the second kind
09:51:06 <bremner> xenoblitz: also restricted growth strings
09:51:31 <bremner> xenoblitz: would you like me to paste some related haskell code, or you prefer to puzzle?
09:53:31 <McManiaC> one question about IO
09:54:43 <newsham> hmmm, Data.Text.  sounds like something long overdue.  thanks data.text team!
09:54:47 <McManiaC> why do i have to use "let" in do blocks to print out a variable changed by a pure function instead of writing sth like "putStrLn $ myFunction inpStr"
09:55:14 <newsham> mcmaniac: "let" doesnt print anyting out.  and your putStrLn function should work fine.
09:55:18 <alar> vincenz: do you know how to force GHCi to use the right library? (the one GHC uses)
09:55:21 <newsham> s/function/line/
09:55:34 <vincenz> alar: -package
09:55:45 <lilac> ImInYourMonad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1868#a1871
09:55:47 <alar> vincenz: -package what?
09:55:55 <vincenz> -package theoneyouwant
09:56:02 <Cale> McManiaC: 'let' in all cases just introduces new definitions
09:56:33 <alar> ghc -package hmatrix -l gfortran works just fine, but ghci -package hmatrix -lgfortran can't find the library
09:56:33 <xenoblitz> bremner: puzzle puzzle ;) thanks for the hints though :)
09:56:56 <xenoblitz> bremner: i also want to restrict the cases of a certain length only
09:59:45 <bremner> xenoblitz: you mean like 3 in your example?
10:01:35 <xenoblitz> yes
10:08:20 <gwern> @quote testicle
10:08:20 <lambdabot> No quotes match. Just what do you think you're doing Dave?
10:08:41 <gwern> @remember cowardlydragon [from a reddit comment thread] Don't get me started on monad. What is that, a man with a single testicle?
10:08:41 <lambdabot> It is forever etched in my memory.
10:08:52 <gwern> @quote learning curve
10:08:52 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
10:08:52 <mauke> test.tcl
10:08:56 <gwern> @quote learning
10:08:56 <lambdabot> LarryWall says: <TimToady> learning Haskell itself is easy--I've done it several times already
10:09:00 <gwern> @quote learning
10:09:00 <lambdabot> LarryWall says: <TimToady> learning Haskell itself is easy--I've done it several times already
10:09:06 <gwern> @quote curve
10:09:06 <lambdabot> vincenz says: shapr: lambdas are curved like bananas, they return
10:09:30 <vincenz> heh
10:09:35 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/curves.jpg
10:10:10 <bremner> xenoblitz: The stirling numbers of the second kind count the number of ways of partitioning n elements into k subsets; it seems similar to what want
10:11:08 <gwern> @remember lilac haskell's learning curve is like this: |
10:11:08 <lambdabot> It is forever etched in my memory.
10:11:15 <gwern> @quote curves
10:11:15 <lambdabot> No quotes match. Are you on drugs?
10:11:20 <gwern> @quote curve
10:11:20 <lambdabot> vincenz says: shapr: lambdas are curved like bananas, they return
10:11:23 <gwern> @quote curve
10:11:23 <lambdabot> joelr says: the learning curve is far steeper with Haskell but it is far more elegant and readable
10:11:27 <gwern> @quote curve
10:11:27 <lambdabot> lilac says: haskell's learning curve is like this: |
10:11:28 <lilac> \o/
10:11:33 <gwern> @flush
10:11:50 <skorpan> hlint doesn't seem to be able to parse empty instance declarations, anyone else having this problem?
10:12:20 <ImInYourMonad> lilac: The last statement in a 'do' construct must be an expression <- I get that with the MaybeM;onad thing you posted, did it work fo you?
10:13:30 <xenoblitz> bremner: thanks I'll look it up :)
10:13:33 <lilac> ImInYourMonad: sounds like the indentation might not be right :-/
10:15:19 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1868#a1870
10:15:22 <ImInYourMonad> as in there
10:18:06 <chrisdone> Haskell's learning curve is more like \
10:18:26 <xci> the more you study the worse you get?
10:18:33 <chrisdone> :-)
10:18:35 <xci> applies for me I guess
10:19:48 <ImInYourMonad> I think Haskell is a liberator for the mind. away goes allt he pain of imperative and OO programming and now you can focus on the problem!
10:20:00 <ImInYourMonad> until the intendation bites your ass
10:20:32 <Beelsebob> set your editor to never insert tabs
10:20:40 <Beelsebob> now indentation won't bite you in the ass
10:22:06 <lilac> ImInYourMonad: the only error i get with that paste is that fromMaybe needs to be qualified
10:22:38 <Beelsebob> also, don't use fromMaybe
10:22:50 <Beelsebob> use maybeToList and concatMap
10:22:59 <Cheshire> is there a list of every monad is the world?
10:23:05 <Beelsebob> nope
10:23:13 <Beelsebob> because if you create it, I'll create a new monad
10:23:55 <Cheshire> hmmm
10:24:00 <asgaroth> not having read the context: what's wrong with fromMaybe?
10:24:33 <Beelsebob> or alternatively, maybe x id (x `M.lookup` rot13Map) -- this would work well
10:24:42 <Beelsebob> asgaroth: it's unsafe
10:24:47 <asgaroth> @type fromMaybe
10:24:49 <lambdabot> forall a. a -> Maybe a -> a
10:24:51 <asgaroth> why?
10:24:52 <Beelsebob> (given a non ascii character, the code will crash
10:24:52 <Beelsebob> )
10:24:55 <lilac> Beelsebob: fromMaybe is fine
10:24:57 <Beelsebob> > fromMaybe Nothing
10:24:57 <lambdabot>       Overlapping instances for Show (Maybe (Maybe a) -> Maybe a)
10:24:57 <lambdabot>        aris...
10:25:03 <lilac> you're thinking of fromJust
10:25:06 <asgaroth> fromJust is unsafe, fromMaybe isn't
10:25:11 <Beelsebob> oh, I am
10:25:16 <Beelsebob> argh, I fail at reading
10:26:07 <Beelsebob> okay... different suggestion for now then... some generalisation here would be easy
10:26:20 <Beelsebob> rot13 = ceasarCypher rot13Map
10:26:27 <Beelsebob> ceaserCypher m ... =
10:26:29 <alar> :t fromMaybe
10:26:29 <lambdabot> forall a. a -> Maybe a -> a
10:28:28 <ufear> hi guys =)
10:29:30 <DBAlex> hi
10:29:43 <ufear> im just starting out with haskell, have to write a function that gets a certain basenumber and a list of chars and then returns a number
10:29:44 <DBAlex> anyone got any idea why my encode function isn't working: http://pastebin.com/m37b40764
10:29:46 <ufear> ie
10:29:49 <ufear> fromBase 16 ff gives 255 :)
10:29:52 <DBAlex> it should take e.g. "aaabc" and return [('a',3),('b',1),('c',1)] ...
10:30:29 <ufear> but it should return 0 if one of the chars is out of bound
10:30:53 <Beelsebob> ufear: I would think about writing a simpler function first
10:30:56 <Beelsebob> that takes a base
10:30:58 <Beelsebob> and a char
10:31:01 <Beelsebob> and gives back an int
10:31:04 <asgaroth> ufear define some function that maps characters to numbers(use Data.Char.ord) and then fold the string into the number
10:31:10 <ufear> yesyes
10:31:16 <ufear> the converting itself is fine
10:31:16 <ImInYourMonad> does haskell support unicode?
10:31:20 <ufear> im using ord
10:31:24 <Beelsebob> yes ImInYourMonad
10:31:24 <DBAlex> anyone?
10:31:25 <asgaroth> ImInYourMonad: yes
10:31:25 <ufear> wait let me paste what I have
10:31:27 <ImInYourMonad> can i get a list of all unicode or ascii characters osmehow?
10:31:34 <Gracenotes> ufear: have you heard of a radix, by the way? This Wikipedia article is largely mathematical, but it might be informative: http://en.wikipedia.org/wiki/Radix
10:31:54 <lilac> > ['\0'...] -- ImInYourMonad
10:31:54 <lambdabot>   <no location info>: parse error on input `]'
10:32:01 <EvilTerran> > group "aaabcca" -- DBAlex, this might help
10:32:02 <lambdabot>   ["aaa","b","cc","a"]
10:32:09 <ufear> nope, havent
10:32:09 <lilac> > ['\0'..] -- ImInYourMonad
10:32:10 <ufear> http://pastebin.com/m774914a6
10:32:10 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
10:32:11 <Gracenotes> it's a synonym for 'base' in many cases
10:32:16 <asgaroth> > let base=2 in foldr (\c acc -> acc*2 + if c == "1" then 1 else 0) 0 "1100"
10:32:16 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
10:32:28 <asgaroth> > let base=2 in foldr (\c acc -> acc*2 + if c == '1' then 1 else 0) 0 "1100"
10:32:29 <lambdabot>   3
10:32:29 <EvilTerran> > [minBound .. maxBound] :: Char
10:32:30 <lambdabot>   Couldn't match expected type `Char' against inferred type `[a]'
10:32:32 <DBAlex> EvilTerran: I've already written a function to do that called munch
10:32:34 <EvilTerran> > [minBound .. maxBound] :: String
10:32:36 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
10:32:49 <ufear> radix is what im doing basically yes
10:32:56 <asgaroth> > let base=2 in foldr (\c acc -> acc*2 + if c == '1' then 1 else 0) 0 $ reverse "1100"
10:32:57 <EvilTerran> DBAlex, well, munch only returns what would be the first item of that list
10:32:57 <lambdabot>   12
10:33:27 <DBAlex> EvilTerran: yes sorry, its runs that does that bit
10:33:33 <DBAlex> and i'm using runs to define encode
10:33:47 <ufear> but main problem is just that I dont know how I can make a function return 0 in case some condition is met
10:33:49 <DBAlex> EvilTerran: Main> runs "aaabbbccc"
10:33:49 <DBAlex> ["aaa","bbb","ccc"]
10:33:49 <DBAlex> Main>
10:34:03 <ufear> which I would expect the code I pasted a minute ago would :P
10:34:03 <Cheshire> BDAlex, group
10:34:10 <DBAlex> I don't need group!
10:34:16 <EvilTerran> DBAlex, what's the significance of '9' in runs?
10:34:22 <DBAlex> I need to know why my encode bit isn't working!
10:34:30 <asgaroth> ufear: if any (not . (`elem` "012345")) string then 0 else ...
10:34:48 <DBAlex> EvilTerran: if a "run" of characters is more than or equal to 9 then its fine, if not then you split it up until the run of 9 chars
10:35:01 <DBAlex> e.g. "aaaaaaaaaa" = ["aaaaaaaaa","a"]
10:35:27 <DBAlex> anyone hazard a guess to why encode isn't working? :(
10:35:28 <ufear> well, but my helperfunction is already returning a 0 in case the char is out of bounds
10:35:37 <EvilTerran> DBAlex, well, what does it do that's wrong?
10:35:43 <ufear> so all I want is that if that returns zero that the main will also return with 0
10:36:02 <asgaroth> ufear: I don't think that'd work, since you wouldn't be able to distinguish between real zeros and errors
10:36:24 <asgaroth> returning -1 might be an option, or using Maybe
10:36:30 <ufear> hmm true
10:36:36 <ufear> I was thinking about that earlier
10:36:46 <EvilTerran> returning a Maybe would make most sense
10:36:48 <newsham> ?src Maybe
10:36:48 <lambdabot> data Maybe a = Nothing | Just a
10:36:52 <DBAlex> EvilTerran: Main> encode "aaabbbbbbccc"
10:36:52 <DBAlex> [('a',3),('a',3),('a',3)]
10:36:52 <DBAlex> Should return:
10:36:52 <DBAlex> Main> encode "aaabbbbbbccc"
10:36:52 <DBAlex> [('a',3),('b',6),('c',3)]
10:36:53 <trofi> :t error
10:36:53 <asgaroth> Maybe is probably better in case you might want to expand your code to negative bases
10:36:54 <lambdabot> forall a. [Char] -> a
10:36:57 <alar> where can I find the details of functioning GHCi's linker?
10:36:58 <DBAlex> thats the error
10:37:02 <Gracenotes> or, if you're Java, you can throw a runtime error
10:37:03 <trofi> :t throw
10:37:04 <lambdabot> Not in scope: `throw'
10:37:13 <ufear> nah I dont need negative bases
10:37:15 <ufear> so -1 will work
10:37:21 <ufear> but that still leaves my question standing
10:37:27 <Gracenotes> well, you can have a negative number in a positive base :)
10:37:37 <Gracenotes> all you have to do is parse a negative sign at the front
10:37:55 <ufear> heh well, those are my first haskell assignments ever
10:38:00 <ufear> I dont think im expected to go that far :P
10:38:00 <asgaroth> I'd check the whole string before though and only fold with the helper function if it's valid
10:38:01 <EvilTerran> DBAlex, ah, i think i see the problem
10:38:04 <asgaroth> should be simpler
10:38:17 <newsham> > map (head &&& length) $ group "aaabbbbbbccc"
10:38:17 <EvilTerran> runs "aaabbbccc" = ["aaa","bbb","ccc"], right?
10:38:18 <lambdabot>   [('a',3),('b',6),('c',3)]
10:38:22 <DBAlex> EvilTerran: The problem is that it just looks at the first for each one, but I don't know how to change that !
10:38:22 <ufear> could do that
10:38:25 <Gracenotes> sure. Can add more features later if you like, but should be fine
10:38:25 <DBAlex> EvilTerran: yes
10:38:31 <DBAlex> no, b should be 3
10:38:35 <DBAlex> EvilTerran: ^
10:38:39 <ufear> so theres no way to make the function forcibily return something if a case occurs?
10:38:49 <EvilTerran> > [(x,y) | x <- head ["aaa","bbb","ccc"], y <- length ["aaa","bbb","ccc"]]
10:38:49 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Int'
10:38:56 <ufear> like in nearly all imperative proggramming langs
10:38:58 <EvilTerran> er
10:39:06 <asgaroth> ufear: there is, by using if
10:39:10 <Gracenotes> zippy listy
10:39:12 <EvilTerran> DBAlex, maybe if you stopped using head where you are?
10:39:16 <ufear> fromBase g (x:xs) = if result /= -1 then result + fromBase g xs else 0
10:39:21 <asgaroth> or pattern matching
10:39:25 <ufear> is what I have
10:39:25 <DBAlex> EvilTerran: ?
10:39:27 <EvilTerran> considering head only gives back the first item
10:39:34 <EvilTerran> and you want to look at all the items
10:39:55 <DBAlex> I want to look at the head of each item
10:39:55 <burp> hi :> I got a problem with Maybe in IO monad like this: http://paste.railsbox.eu/show/49/, is there a way I could do sth like getNewestId >>= getById
10:40:05 <asgaroth> ufear: that would only return 0 for the current recursion depth and not force the whole thing to be zero.
10:40:09 <ufear> mm wait, I think I get why this doesnt work
10:40:13 <ufear> ya indeed
10:40:19 <ufear> because that is already outputted before right?
10:40:50 <newsham> burp: you can use fromJust (not recommended), fromMaybe or maybe
10:41:38 <EvilTerran> DBAlex, i suspect you want to be taking the heads of the inner lists returned by "runs", not the head of the list-of-lists
10:41:46 <EvilTerran> > head ["aaa","bbb","ccc"]
10:41:46 <ufear> so your suggestion is to check beforehand asgaroth?
10:41:47 <lambdabot>   "aaa"
10:41:51 <ufear> then ill work on that :)
10:41:51 <EvilTerran> > map head ["aaa","bbb","ccc"]
10:41:52 <lambdabot>   "abc"
10:42:05 <burp> hm ok I will have a look at fromMaybe
10:42:05 <DBAlex> EvilTerran: yes
10:42:09 <DBAlex> ah
10:42:10 <DBAlex> map :)
10:42:11 <newsham> ?src fromMaybe
10:42:12 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
10:42:42 <asgaroth> ufear: Yes, I'd do something like this: if any (not . (`elem` validChars)) string then 0 else foldr (\c acc -> acc*base + charToNum c) 0 (reverse string).
10:42:49 <EvilTerran> DBAlex, well, or something like "[(head run, length run) | run <- runs xs]"
10:43:05 <asgaroth> could be written more efficiently though
10:43:05 <newsham> ?src maybe
10:43:05 <lambdabot> maybe n _ Nothing  = n
10:43:05 <lambdabot> maybe _ f (Just x) = f x
10:43:35 <newsham> getNewestId >>= maybe Nothing getNewestId
10:43:47 <newsham> getNewestId >>= maybe Nothing getById   I mean
10:43:50 <ufear> mm okay I get the point
10:43:53 <ufear> I'll work it out, thanks!
10:43:57 <newsham> np
10:44:05 <DBAlex> EvilTerran: ok
10:44:15 <DBAlex> EvilTerran: the map doesn't work for length
10:44:50 <EvilTerran> there's another problem with that thar list comprehension
10:45:11 <burp> newsham: getById returns IO (Maybe Int)
10:45:18 <DBAlex> ok
10:45:22 <burp> so I need to unpack the (Maybe Int) first too
10:45:26 <burp> but then it works
10:45:45 <burp> oh wait
10:45:46 <newsham> burp: oops.   so   maybe (return Nothing) getById
10:45:52 <EvilTerran> > [(x,y) | x <- [1..3], y <- "abc"] -- using multiple generators in a list-comprehension gets you the cartesian product of the lists, not the zipping of them
10:45:53 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
10:45:59 <newsham> then both return Nothing :: IO Maybe Int,   and getById x :: IO MaybeInt
10:46:33 <burp> newsham: yup, thanks
10:46:49 <EvilTerran> (@ DBAlex)
10:47:21 <DBAlex> yeah
10:47:24 <DBAlex> thats the issue I have now
10:47:40 <lilac> @wiki New monads/MaybeT
10:47:40 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
10:47:52 <newsham> burp: in your situation you kinda want a combination of IO and Maybe monads.  I think the newest STM has MaybeT that you can mix iwth IO
10:48:09 <EvilTerran> DBAlex, as you only want to traverse (runs xs) once in that list comprehension, you should only mention it to the right of a <- once
10:48:12 <lilac> newsham: you mean the newest  MTL?
10:48:14 <newsham> but that might be overkill if you just want it for this one function
10:48:18 <newsham> err.. MTL :)
10:48:19 <newsham> heh
10:48:23 <burp> yes, its just for a small thing
10:48:45 <DBAlex> erm ok
10:49:03 <DBAlex> EvilTerran: brb one second
10:49:15 <DBAlex> EvilTerran: and yes thats correct, how do I define that ?
10:49:22 <EvilTerran> DBAlex, you could write [... | r <- runs xs], and then use "head r" and "length r" in the "..." to get the effect you wanted
10:49:59 <newsham> head &&& length
10:50:11 <ImInYourMonad> if i declare an Applicative Functor for Vector can I then define zipWith for the Vector?
10:50:21 <monochrom> head &&& shoulders
10:50:51 <DrSyzygy> > [ head &&& length $ r | r <- runs [1,1,1,2,2,3,3,3,3,3,3,4,4,5,5,5,6,6,6,6,6,3]]
10:50:51 <lambdabot>   Not in scope: `runs'
10:50:57 <DrSyzygy> Pbtbtbt.
10:51:27 <monochrom> cycle?
10:53:45 <Gracenotes> > ('P':) . map ("pbt"!!) $ randomRs (0,2) (mkStdGen 42)
10:53:46 <lambdabot>   "Ptpbbtbptpppppttbtbpptppbbbpttpbtptbppttpbpbptbppbptbbtbpbbbtbbttbbbttpttb...
10:54:33 <DBAlex> EvilTerran: ah ok
10:54:39 <DBAlex> ok i'll try that
10:54:46 <skorpan> Gracenotes: what was that all about?
10:55:03 <skorpan> i'm actually most curious about ('P':) :P
10:55:34 <Gracenotes> every good pbtpbtbpbtbtpt has to begin with a p, of course
10:55:50 <DBAlex> EvilTerran: ah yes Main> encode "aaabbbcccc"
10:55:50 <DBAlex> [('a',3),('b',3),('c',4)]
10:55:55 <DBAlex> that works perfectly!
10:55:57 <DBAlex> Thanks :)
10:56:04 <DBAlex> I'm annoyed because I wanted to do it myself
10:56:10 <DBAlex> but it works
10:56:18 <Gracenotes> > ('P':) $ zipWith (!!) (cycle "bt") (cycle [0,1])
10:56:19 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
10:56:23 <DBAlex> and I understand more about how list comprehension works now :)
10:56:44 <DBAlex> (I was trying to base mine of an example out lecturer gave us)
10:56:49 <Gracenotes> > ('P':) $ zipWith (!!) (cycle ["bt"]) (cycle [0,1])
10:56:50 <lambdabot>   "Pbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtbtb...
10:57:03 <monochrom> how come everyone (including me) uses 42 to seed the random number generator? :)
10:57:09 <DBAlex> but that way is superior, you assign runs xs to r and then apply functions to the xs, very clever :)
10:57:18 <DBAlex> *apply functions to r
10:57:22 <trofi> @go forty two
10:57:23 <lambdabot> http://en.wikipedia.org/wiki/42_(number)
10:57:23 <lambdabot> Title: 42 (number) - Wikipedia, the free encyclopedia
10:57:36 <ImInYourMonad> vzipWith f v1 v2 = Vector $ zipWith f (fromVector v1) (fromVector v2)
10:57:53 <ImInYourMonad> can I use: liftVector :: ([a] -> [b]) -> Vector a -> Vector b; on that?
10:57:59 <newsham> > map (head &&& length) $ group "aaabbbbbbccc"
10:58:00 <lambdabot>   [('a',3),('b',6),('c',3)]
10:58:19 * SamB wants to set his language to en_US+GB
10:58:26 <newsham> > group "aaabbbbbbccc"
10:58:27 <lambdabot>   ["aaa","bbbbbb","ccc"]
10:58:36 <newsham> > (head &&& length) "aaa"
10:58:37 <lambdabot>   ('a',3)
10:59:39 <newsham> iminyourmonad: if you define applicative you can just use  f <$> v <*> v   to zipWith f
10:59:55 <cnwdup> @src fix
10:59:55 <lambdabot> fix f = let x = f x in x
11:00:26 <sw17ch> :t fix []
11:00:27 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `[a1]'
11:00:27 <lambdabot>     In the first argument of `fix', namely `[]'
11:00:33 <sw17ch> :t fix (:) []
11:00:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> [a]
11:00:34 <lambdabot>     Probable cause: `:' is applied to too few arguments
11:00:34 <lambdabot>     In the first argument of `fix', namely `(:)'
11:00:36 <sw17ch> :t fix (:)
11:00:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> [a]
11:00:37 <lambdabot>     Probable cause: `:' is applied to too few arguments
11:00:37 <lambdabot>     In the first argument of `fix', namely `(:)'
11:00:50 <newsham> :t fix (1:)
11:00:51 <lambdabot> forall t. (Num t) => [t]
11:00:56 <monochrom> See http://www.vex.net/~trebla/haskell/fix.xhtml about the fix function.
11:01:09 <DBAlex> Also
11:01:12 <sw17ch> :t fix (++) []
11:01:13 <lambdabot>     Couldn't match expected type `[a]'
11:01:13 <lambdabot>            against inferred type `[a] -> [a]'
11:01:13 <lambdabot>     Probable cause: `++' is applied to too few arguments
11:01:19 <DBAlex> is it possible to write real applications with haskell?
11:01:27 <DBAlex> Not silly stuff like i'm doing now?
11:01:32 <newsham> ?faq is it possible to write real applications with haskell?
11:01:32 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:35 <Heffalump> why wouldn't it be?
11:01:37 <sw17ch> DBAlex: no, we never write real applications in haskell
11:01:41 <Gracenotes> :t fix --see the type of the first function? :)
11:01:42 <lambdabot> forall a. (a -> a) -> a
11:01:42 <DBAlex> heh
11:01:49 <monochrom> we write surreal applications.
11:01:49 <DBAlex> it just seems to odd to do so
11:02:01 <sw17ch> DBAlex: i wrote a VPN
11:02:01 <newsham> it is odd at first.
11:02:01 <DBAlex> maybe my head is still stuck in procedural mode
11:02:03 <monochrom> xmonad is a window manager in haskell
11:02:03 <sw17ch> in haskell
11:02:11 <sw17ch> we have bit torrent clients
11:02:16 <sw17ch> umm web servers
11:02:18 <dormoose> Hi. When I type 'set | less', I see the environment variable COLUMNS=158. However, in ghci import System;getEnv "COLUMNS" throws an *** Exception: COLUMNS: getEnv: does not exist (no environment variable)
11:02:21 <DBAlex> are the applications slow though?
11:02:22 <dormoose> How come?
11:02:23 <newsham> but haskell does have a fairly powerful library for imperative programming
11:02:29 <sw17ch> DBAlex: hell no
11:02:32 <DBAlex> I suppose if you used ghc then maybe not
11:02:32 <sw17ch> some are incredibly fast
11:02:36 <paper_cc> dormoose: $ export COLUMNS
11:02:45 <repnop> here's a good haskell app
11:02:47 <repnop> xmonad :)
11:03:05 <DBAlex> window manager?
11:03:06 <newsham> dormoose: not all shell variables are exported to the environment
11:03:12 <paper_cc> dormoose: COLUMNS is likely not exported from your shell
11:03:12 <dormoose> paper_cc: Well, now it works.
11:03:15 <newsham> dormoose: type "env" to see your env variables
11:03:31 <repnop> DBAlex: main wm i use when working
11:03:34 <dormoose> Oh my. Can I somehow suck them in with the same program?
11:03:45 <DBAlex> repnop: ok
11:04:00 <newsham> you can use your shell's export command to export the shell variable to the environment
11:04:03 <DBAlex> do you find haskell programs take longer to develop than in a procedural language?
11:04:11 <monochrom> faster
11:04:12 <sw17ch> DBAlex: no
11:04:16 <mperillo> hi
11:04:17 <DBAlex> ok
11:04:19 <sw17ch> DBAlex: and with a lot less code
11:04:27 <DBAlex> yeah i've noticed that
11:04:30 <newsham> dbalex: at first they take much longer :)  but once you get the hang of it, you have some powerful tools and a type checker that helps you find bugs early
11:04:30 <Nafai> DBAlex: I do, but that's just because I'm new to the Haskell-style of thinking
11:04:36 <dormoose> newsham: Any way to do this inside the program? I want to find the width of the current terminal somehow.
11:04:40 <DBAlex> I like how haskell can say a lot in not a lot of code
11:04:55 <DBAlex> like the list comprehension :) thats equal to for each in java/python
11:05:02 <mperillo> how compare using bytestring-mmap to read a big file, against using getContents with ByteStringLazy?
11:05:08 <newsham> dormoose: if you're in unix, there are commands you can send to the terminal driver to get that information
11:05:30 <DBAlex> newsham: ok, what would be a good app to try and write to start?
11:05:39 <newsham> the simplest way to get that would be to run 'stty -a' and parse the output.
11:05:40 <DBAlex> *start to write
11:05:47 <dormoose> newsham: Ho, thanks!
11:05:49 <sw17ch> DBAlex: write the 'cat' program
11:05:50 <DBAlex> (my brain works backwards sometimes, blame CS !)
11:05:57 <newsham> there are probably a few libraries that export the functionality directly to haskell, such as a curses library.
11:06:00 <DBAlex> sw17ch: ok
11:06:10 <monochrom> Use an ncurses binding to find terminal width. nanocurses or hscurses.
11:06:23 <Saizan_> terminfo?
11:06:25 <newsham> dbalex: the simplest to start to write are probably simple terminal interactions.  like a game where you ask the user to guess something
11:06:30 <DBAlex> Nafai: ok, how long have you been programming in haskell? and why did you start?
11:06:33 <newsham> and the user enters guesses and gets feedback
11:06:44 <cnwdup> @src (,,)
11:06:44 <lambdabot> Source not found.
11:07:01 <newsham> but if you want to jump right in and learn something like gui programming, you could write lots of simple giu type apps easily once you get the hang of the library you choose
11:07:04 <Gracenotes> > foldl1 (^) . take 10 $ fix (2:)
11:07:05 <lambdabot>   134078079299425970995740249982058461274793658205923933777235614437217640300...
11:07:06 <DBAlex> sw17ch: ok, that would be interesting
11:07:19 <DBAlex> sw17ch: does the standard prelude have file I/O ?
11:07:22 <Nafai> DBAlex: I've been trying off and on for a couple years, just starting into doing "useful" things.
11:07:31 <DBAlex> Nafai: ok
11:07:35 <sw17ch> @index readFile
11:07:35 <lambdabot> System.IO, Prelude
11:07:38 <DBAlex> Nafai: it took me 2 hours to write 2 functions...
11:07:39 <DBAlex> :P
11:07:43 <sw17ch> DBAlex: yes, readFile
11:07:45 <sw17ch> :t readFile
11:07:49 <lambdabot> FilePath -> IO String
11:07:54 <DBAlex> I'm heavily heavily into the procedural thinking though so...
11:07:56 <Nafai> DBAlex: I've found the ideas of type safety and so forth attractive
11:08:02 <sw17ch> contents <- readFile "someFile.txt"
11:08:05 <paper_cc> @index interact
11:08:05 <lambdabot> System.IO, Prelude
11:08:09 <DBAlex> sw17ch: ok
11:08:10 <CTA> Hey
11:08:12 <paper_cc> @ty interact
11:08:13 <lambdabot> (String -> String) -> IO ()
11:08:14 <pejo> DBAlex, your comparison isn't really fair considering you spent years training on writing imperative stuff.
11:08:17 <newsham> ?type writeFile "/tmp/out" . sort =<< readFile "/tmp/foo"
11:08:18 <lambdabot> IO ()
11:08:34 <DBAlex> pejo: true, thats why I stuck at it
11:08:36 <newsham> that program reas in /tmp/foo, sorts its characters and writes it out to /tmp/out
11:08:47 <paper_cc> @ty interact sort
11:08:47 <lambdabot> IO ()
11:08:51 <DBAlex> i'm willing to take my time learning it, since in the end the outcome could be better programs :)
11:08:55 <paper_cc> newsham: this too =)
11:09:18 <newsham> dbalex: so you can see how you can quickly write some simple programs very tersely
11:09:24 <dormoose> newsham: To run stty from Haskell, I should look at System.Unix.Process, right?
11:09:27 <newsham> like "interact sort".  pretty short program.
11:09:45 <ImInYourMonad> can I create a program that runs another exe-file an passes it command-line-args? like the subprocess module in Python.
11:09:46 <DBAlex> newsham: yup
11:09:53 <newsham> dormoose: yes, although honestly it might be easier to just grab a curses lib and use that, as mono suggests.
11:09:57 <DBAlex> newsham: I think quick sort is the best i've seen
11:09:58 <DBAlex> :)
11:10:04 <DBAlex> very nice definition in haskell
11:10:10 <Saizan_> ImInYourMonad: yes, see System.Process
11:10:19 <DBAlex> thats the thing too though, I feel like i'm writing a maths formula when I program in haskell
11:10:26 <newsham> yah except its not really quick sort.  its quicksort-like.  it operates on lists that take O(n) to traverse.
11:10:44 * paper_cc remembers that augustss post
11:10:56 <DBAlex> ok
11:11:14 <newsham> dbalex: the great thing is that not only do you write it like equations, you can actually treat things like equations when you want to think about your program.
11:11:17 <newsham> thats very powerful.
11:11:17 <Gracenotes> argh. How hard would it have been to define a no command in Unix :( how I hate to type out yes n
11:11:33 <newsham> grace:  yes|sed 's/y/n/g'  ?
11:11:44 <ddarius> @pl \x -> (f x, g x)
11:11:44 <lambdabot> liftM2 (,) f g
11:11:54 <newsham> yes|tr y n ?
11:11:55 <monochrom> There is a yes command in Unix.
11:11:57 <DBAlex> newsham: ok, I suppose i'm a rather bad maths student though, but I can see the beauty, I just wish I was better at maths ! :)
11:12:06 <paper_cc> Gracenotes: umm, echo '#!/bin/sh\nyes n' > ~/bin/no ?
11:12:11 <DBAlex> maybe haskell will improve that too... well at least functional thinking
11:12:13 <paper_cc> s/echo/echo -e/
11:12:20 <newsham> dbalex: practice makes perfect.  now you have a motivating reason to improve.
11:12:27 <monochrom> Oh, yes takes an argument? :)
11:12:32 <DBAlex> newsham: yup
11:12:35 <Gracenotes> paper_cc: the audacity of people who made themselves think they could get away with it! :
11:12:42 <newsham> monochrome: how can you argue with yes?
11:12:44 <Gracenotes> x
11:12:46 <monochrom> Oh haha nice.
11:12:56 <DBAlex> wonder how much harder it is for someone to learn a procedural language when they've only programmed in a function ?
11:13:04 <DBAlex> harder than procedural -> functional ?
11:13:11 <w0lter> isInAny needle haystack = any inSequence haystack
11:13:13 <w0lter>     where inSequence s = needle `isInfixOf` s
11:13:14 <w0lter> my question is : where is s come from? thanks
11:13:15 <CTA> is there a way I can do the equivilant of this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1872#a1872 in haskell?
11:13:29 <DBAlex> s/function/functional
11:13:48 <EvilTerran> w0lter, it's bound as a parameter in "inSequence s =", so is in scope until the end of the body of inSequence
11:13:50 <newsham> dbalex: my favorite comparison is romantic languages vs. chinese.  both can be learned by children, but knowing one doesn't necessarily help you that much in learning the other.
11:14:02 <newsham> whereas learning italian knowing spanish is a lot easier.
11:14:09 <newsham> most imperative languages are fairly closely related.
11:14:12 <DBAlex> yeah
11:14:28 <w0lter> EvilTerran: Is s a part of haystack?
11:14:41 <newsham> but haskell is much different than the imperative languages
11:14:53 <DBAlex> are there any other type of languages?
11:14:59 <DBAlex> other than procedural, functional
11:15:03 <monochrom> > unwords (map show [0..9])
11:15:04 <Saizan_> logic ones
11:15:05 <lambdabot>   "0 1 2 3 4 5 6 7 8 9"
11:15:05 <Gracenotes> stack-oriented
11:15:07 <newsham> logical like prolog?  dont know much about them
11:15:07 <DBAlex> isn't prolog imperative?
11:15:14 <DBAlex> heh
11:15:17 <paper_cc> @ty let isInAny needle = any . map (needle `isInfixOf`) in isInAny
11:15:17 <Gracenotes> it's declarative-ish
11:15:18 <lambdabot>     Couldn't match expected type `a -> Bool'
11:15:18 <lambdabot>            against inferred type `[Bool]'
11:15:18 <lambdabot>     Probable cause: `map' is applied to too many arguments
11:15:31 * DBAlex looks up prolog
11:15:33 <lispy> too many arguments!!
11:15:36 <pejo> @google teach yourself programming in ten years
11:15:37 <lambdabot> http://norvig.com/21-days.html
11:15:37 <lambdabot> Title: Teach Yourself Programming in Ten Years
11:15:37 <lispy> Oh noes
11:15:41 <Gracenotes> DBAlex: stack-oriented ones are very fun. see http://factorcode.org/
11:15:47 <pejo> dbalex, that essay is a good read.
11:15:59 <DBAlex> http://en.wikipedia.org/wiki/Prolog
11:16:00 <lispy> pejo: yeah, it really is
11:16:06 <chrisdone> @src filter
11:16:07 <lambdabot> filter _ []     = []
11:16:07 <lambdabot> filter p (x:xs)
11:16:07 <lambdabot>     | p x       = x : filter p xs
11:16:07 <lambdabot>     | otherwise = filter p xs
11:16:10 <DBAlex> pejo: ok
11:16:21 <Gracenotes> DBAlex: just read through the docs and some tutorials and you'll pick it up. In stack-based languages, every thing is stored on the stack, essentially
11:16:35 <DBAlex> nice
11:16:39 <DBAlex> well I do like the stack
11:16:48 <DBAlex> I wrote an interpreter a while back, thats heavily stack based
11:16:51 <DBAlex> and recursive
11:16:55 <w0lter> Why do we need the "s" here?
11:17:00 <cypher-> if you want to see "nice" programming language, check Q out
11:17:01 <cypher-> ;-)
11:17:12 <dormoose> newsham: Works!
11:17:22 <dormoose> OK, next question: How to "sleep" in the program?
11:17:22 <Gracenotes> the common example that's given is : square ( x -- xsq ) dup * ;
11:17:45 <monochrom> Control.Concurrent.threadDelay sleeps
11:17:50 <Gracenotes> which duplicates the element on the top of the stack and multiplies the two top things together, hence squaring
11:17:53 <Saizan_> dormoose: sleep s = threadDelay (s * 10^6)
11:17:59 <dormoose> Saizan_: Thanks!
11:18:14 <lispy> ?pl sleep s = threadDelay (s * 10^6)
11:18:14 <lambdabot> sleep = threadDelay . (10 ^ 6 *)
11:18:21 <DBAlex> ooh "A language that doesn't affect the way you think about programming, is not worth knowing" < Thats very cool...
11:18:35 <DBAlex> I suppose learning c java and python hasn't really done that
11:18:50 <DBAlex> even VB -> C isn't a big jump really, its just syntactic
11:18:55 <newsham> teach yourself programming in 10k hours.
11:19:13 <newsham> dbalex: pointer manipulation is one major shift.
11:19:13 <lispy> C and java changed the way I think about programming; but once you learn them they no longer change it :)
11:19:20 <Gracenotes> many other jobs require 10k hours of experience
11:19:21 <newsham> if you program using apis that require pointer manipulation
11:19:29 <Gracenotes> electrician, I believe. plumbing.
11:19:30 <monochrom> If you use pointers and unions in C in advanced ways, you learn something new.
11:19:39 <lispy> Gracenotes: yes, that is covered in Norvig's essay
11:19:43 <Gracenotes> stuff like that, services.
11:19:48 <Gracenotes> lispy: oh, really? I should read it...
11:19:54 <lispy> Gracenotes: that to really learn anything of importance or significance it takes time
11:20:06 <monochrom> 2["abcde"] is valid C and it evaluates to 'c'
11:20:20 <ddarius> Because addition is commutative.
11:20:31 <DBAlex> newsham: true
11:20:33 <newsham> ?check \a b -> a[b] == b[a] -- ;-)
11:20:34 <lambdabot>       Occurs check: cannot construct the infinite type:
11:20:34 <lambdabot>        t = [[t] -> a]...
11:20:38 <chrisdone> @let bool false true pred value = if pred value then true value else false value
11:20:40 <lambdabot>  Defined.
11:20:41 <chrisdone> :t bool
11:20:41 <lambdabot> forall t t1. (t -> t1) -> (t -> t1) -> (t -> Bool) -> t -> t1
11:20:47 <chrisdone> > (flip foldr [] . bool (flip const) (:)) (>3) [1,2,3,4,5]
11:20:48 <lambdabot>   [4,5]
11:20:55 <chrisdone> is this awesome (y/n)?
11:21:09 <Cheshire> no
11:21:12 <chrisdone> :-(
11:21:15 <newsham> chrisdone: why not omit pred and use composition?
11:21:18 <lispy> I liked that about agda, that if/then/else can be defined if_then_else :: Bool -> a -> a, (using haskell types)
11:21:31 <lispy> Oh I missed a blank, if_then_else_
11:21:52 <newsham> bool f t False = f; bool f t True = t
11:21:57 <Gracenotes> I like bool better as a function on non-function values, not a function on functions
11:22:01 <newsham> thats the natural deconstructor for Bool.
11:22:45 <newsham> bool (flip const) (:) . (>3)    ...
11:22:47 <Cheshire> @src filter
11:22:47 <lambdabot> filter _ []     = []
11:22:47 <lambdabot> filter p (x:xs)
11:22:47 <lambdabot>     | p x       = x : filter p xs
11:22:47 <lambdabot>     | otherwise = filter p xs
11:22:47 <Saizan_> ?ty let bool f t False = f; bool f t True = t in liftM3 bool
11:22:48 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1 -> m Bool -> m a1
11:23:07 <Saizan_> ?ty let bool f t False = f; bool f t True = t in liftM3 bool :: (t -> t1) -> (t -> t1) -> (t -> Bool) -> t -> t1
11:23:08 <lambdabot> forall t t1. (t -> t1) -> (t -> t1) -> (t -> Bool) -> t -> t1
11:23:34 <b_jonas> lispy: er, what? isn't it Bool -> a -> a -> a ?
11:23:45 <lispy> b_jonas: heh, yeah
11:23:49 <lispy> I can't type
11:23:59 <Cheshire> lol
11:24:11 <Gracenotes> b_jonas: the idea, I think, is that the most variable argument goes last
11:24:15 <lispy> My point was just that, the definition syntax, if_then_else_ is cool and handy
11:24:18 <Gracenotes> so that you can partially apply nicely
11:24:29 <Cheshire> lispy, I agree
11:24:32 <monochrom> If you write a polymorphic function, you can't really think "I prefer people to use it on non-function values". Well you can prefer but people who do it anyway.
11:24:33 <Gracenotes> in general, the thing most likely to vary in an if/then/else is whether it's true or not
11:24:33 <newsham> grace: he's talking about lispy's definition above.
11:24:59 <Gracenotes> oh, bwahahabmzxasqrrrr :(
11:25:00 <Cheshire> lispy, I think we could extend haskell with the form  leftBrack_rightBrack  though, without changing much
11:25:01 <monochrom> s/who/will/
11:25:41 <lispy> Cheshire: I won't be happy until if-then-else need not be a part of the formal syntax :
11:25:44 <lispy> :)
11:26:00 <Cheshire> lispy, well imo if/then/else should not be part of the language at all
11:26:03 <chrisdone> newsham: if I omit pred how do I get the value being tested by the predicate?
11:26:06 <Cheshire> i.e. we should use a function such as bool instead
11:26:13 <ddarius> lispy: You should look at OBJ3
11:26:18 <newsham> chrisdone:   bool x y . p
11:26:36 <chrisdone> newsham: what type do x and y have?
11:26:49 <Cheshire> any type
11:26:51 <newsham> (bool x y . p) x = bool x y (p x)
11:27:03 <Cheshire> join (bool x y . p)
11:27:05 <lispy> Cheshire: well, it should be in a standard library.  Things like if-then-else, forM, while, until, etc are common human constructs.  so Ican see their value for daily programming needs.
11:27:07 <paper_cc> @let if' b x y = if b then x else y
11:27:08 <lambdabot>  Defined.
11:27:10 <Cheshire> = bool (x o) (y o) (p o)
11:27:11 <Saizan_> newsham: his bool passes the value to x and y as well
11:27:12 <Cheshire> doesn't it ?
11:27:13 <chrisdone> yeah I have to use join...
11:27:29 <chrisdone> that's my point
11:27:30 <newsham> saizan: oops!
11:27:34 <Cheshire> and then we are back to Saizans, liftM3 bool
11:28:05 <chrisdone> list nil cons = bool cons (const nil) null
11:28:15 <chrisdone> you say why not use listToMaybe?
11:28:21 <chrisdone> yeah I love making my code bigger, great idea
11:28:29 <Cheshire> :t listToMaybe
11:28:30 <lambdabot> forall a. [a] -> Maybe a
11:28:31 <newsham> now I understand why you did liftM3 comment
11:28:54 <b_jonas> if-else need not be in many languages, but somehow it still manages to be in lots of languages. there still are several where it's a library function though: postscript, smalltalk, common lisp (though in it cond is a builtin), logo (I think)
11:29:18 <ddarius> b_jonas: Actually, it's hacked into Smalltalk
11:29:31 <b_jonas> ddarius: is it? I don't really know smalltalk. how?
11:29:49 <ddarius> It's special-cased by the implementations
11:29:57 <b_jonas> oh, it's a library function in IO too
11:30:14 <b_jonas> ddarius: well, you can probably say that for common lisp too, a compiler will likely handle it directly
11:30:16 <Cheshire> if is important in Lisp, but it's just something we inhert in haskell
11:30:16 <Cheshire> there's not really any good reason to have it.. someone might say 'it looks nice' though
11:30:32 <chrisdone> ~_~
11:30:36 <ddarius> b_jonas: Yes, but in Smalltalk you could, in theory, override it, but in practice you can't.
11:30:48 <Cheshire> b_jonas, it's got to be a primitive in lisp
11:30:59 <b_jonas> Cheshire: well, the |guards for function defns and case are a nice shortcut, so it's not a big leap to have an if as well
11:31:08 <dolio> It could be a macro.
11:31:15 <ddarius> (You could, however, reimplement it yourself.)
11:31:26 <Cheshire> dolio, that's only true if you have true = (lambda (x y) x) or something
11:31:32 <b_jonas> Cheshire: yes, I'm saying in common lisp if is a macro defined from cond, which is basically if-elseif-elseif-etc-else
11:31:40 <b_jonas> whereas in scheme cond is a macro and if is a primitive
11:31:44 <Cheshire> yeah and cond is defined in terms of if
11:31:53 <b_jonas> but neither have special syntax, they can be defined as a macro
11:31:58 <chrisdone> or a macro that makes the consequent and else thunks?
11:32:14 <chrisdone> uh nm
11:32:44 <Cheshire> b_jonas, what I really mean is that you cannot distinguish the values 'true' and 'false' without IF (or COND or anything equivalent)
11:32:55 <Cheshire> in haskell it's no problem to distinguish them by pattern matching though
11:32:58 <p_l> b_jonas: In CL (if) is builtin, cond is usually not. In Scheme it's the other way around
11:33:00 <b_jonas> Cheshire: well, you could implement it if you had a bulitin function (not macro) that turns true/false to those lambdas, so I'd argue it's not special
11:33:13 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1874#a1874 <- what do I need to do?
11:33:23 <Cheshire> the thing which takes true and false and returns some lambdaized version -- that's special
11:33:24 <b_jonas> so you need at least a built-in function, but no built-in special form for it
11:33:43 <b_jonas> whereas you obviously need a special form for lambda, you can't just implement that as a macro with any support function
11:33:46 <Cheshire> and equivalent to IF .. it's just an esoteric formulation of IF
11:34:03 <monochrom> ImInYourMonad: perhaps use fromIntegral to coerce Int to Double
11:34:18 <monochrom> @quote fromIntegral
11:34:18 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:34:38 <Cheshire> the same is true of C, without if (and switch and equivalent things) you could not tell the difference
11:34:41 <b_jonas> Cheshire: ok, I agree you can't really make a meaningful distinction in lisp/scheme where you can have macros
11:34:52 <p_l> newsham: BTW, I've got VMS8.3 running on es40 emulator. For some reason it still can't keep connection to simh-vax cluster... :P
11:34:59 <lilac> @quote 8-ball
11:34:59 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
11:35:03 <Cheshire> (although it's a lot less true in C, since you could still do branching and conditionals..)
11:35:16 <newsham> not familiar with es40.
11:35:23 <b_jonas> this distinction makes more sense in that in like C you couldn't easily implement if as a function, whereas in smalltalk/ruby/postscript it's natural to just make it a function
11:35:42 <Cheshire> I'd argue it is less of a distinction in C though
11:36:24 <Cheshire> the evaluation order problems are more pervasive but that's not the actual issue
11:36:51 <b_jonas> it's not just the evaluation order
11:37:02 <p_l> newsham: es40.org - emulates one of the last alphaservers. Still largely WIP, but it does manage to run standalone VMS8.3. DECnet sometimes works, sometimes not. HP's TCP/IP segfaults on setting a hostname, etc.
11:37:19 <b_jonas> it's that C doesn't have lambdas, so if you pass a function to something, you can't just make it closed on lexicals, you have to pass all data explicitly to it
11:37:30 <b_jonas> which makes passing callbacks to if less convenient
11:38:22 <Baughn> (Unless you use gcc, in which case you can]
11:38:42 <Baughn> ((Somewhat))
11:39:11 <b_jonas> I was thinking on a program I have while I was on the bus, and I found some more abstractions (related to threading) I shall factor out because I either use them at least twice or will use them if I implement the todos
11:39:25 <p_l> Baughn: I'm pretty sure GCC has somewhere a file that contains a "raise cthulhu from r'lyeigh" builtin too.
11:39:28 <newsham> struct { void* f(void *); void *args; }
11:39:49 <b_jonas> newsham: yes, you can pass everything, but it's just not too convenient
11:39:51 <ImInYourMonad> but where!!??
11:40:02 <monochrom> "Oh God, it's full of *'s!"
11:40:06 <Baughn> p_l: That would be crt0.s
11:40:12 <b_jonas> also you're missing a paren
11:40:20 <b_jonas> it's void (*f)(void *)
11:40:26 <b_jonas> no wait
11:40:32 <opqdonut> yeh
11:40:34 <b_jonas> it's actually void *(*f)(void *)
11:40:40 <Baughn> http://brage.info/~svein/eyenuke.png <-- Your mind on haskell
11:40:44 <opqdonut> yeah if the return value is a pointer
11:40:54 <b_jonas> well,  it can be either
11:41:00 <p_l> Baughn: I knew it
11:41:04 <Cheshire> wow
11:41:16 <b_jonas> it might be better for the caller to allocate space for the return in C
11:41:22 <Beelsebob> Baughn: why is that a problem
11:41:23 <Beelsebob> ?
11:41:32 <newsham> void *(*f)(void*)
11:41:41 <opqdonut> Baughn: shame, no hidden picture
11:42:09 <Baughn> opqdonut: No, but I found it amusing the way it twists your mind and then proceeds to make /other/ things look blurry
11:42:39 <b_jonas> ImInYourMonad: I'm not sure we can help if you don't show us the code either
11:43:00 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1874#a1875
11:43:27 <newsham> i wonder if that would be considered an effective form of torture.
11:43:29 <olsner> p_l: "undefined behaviour, program will summon cthulhu at run-time"
11:43:34 <maxote> wli
11:43:34 <newsham> make someone stare at that for a few days.  then release them.
11:43:45 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1874#a1875 <- trying to do knn with cosineSimilarity, I need to fix it to rerturn a double?
11:43:47 <paper_cc> ImInYourMonad: you're passing an integer argument to vectorLength
11:44:11 <b_jonas> why are all your type things commented out?
11:44:22 <Baughn> olsner: If it actually is known to summon cthulhu, then that's defined behaviour, ain't it?
11:44:38 <paper_cc> Baughn: well, that's platform-dependent
11:44:44 <b_jonas> (the compiler can usually give better localized error messages if you give everything a type signature)
11:44:49 <sw17ch> unsafeSummonCthulu
11:45:02 <olsner> Baughn: gcc implements some undefined behaviours it knows about into things like the undefined-instruction instruction or abort() calls
11:45:04 <paper_cc> unsafeWakeCthulhu rather
11:45:15 <dons> mm. it would be useful to have a core2 server somewhere
11:45:20 <Baughn> unsafeMoveStars
11:45:28 <sw17ch> unsafePlayNearCthulusCaveNoisily
11:45:53 <sw17ch> dons: core2 as in the processor architecture?
11:45:53 <Baughn> unsafeAnnoy#haskellers
11:46:07 <sw17ch> > cycle "unsafeAnnoy#haskellers"
11:46:08 <monochrom> ImInYourMonad: which line which column do you mean by "it" in "fix it"?
11:46:08 <lambdabot>   "unsafeAnnoy#haskellersunsafeAnnoy#haskellersunsafeAnnoy#haskellersunsafeAn...
11:46:14 <olsner> unsafeUnsafePun
11:46:15 <paper_cc> Baughn: unsafeAnnoyHaskell# ... that's a basic GHC built-in
11:46:15 <sw17ch> boo
11:46:34 <maxote> wli, answer me when you can if 9699691 fails or not.
11:46:55 <defun> how are applicative funtors better/worse/different from monads?
11:47:19 <dons> sw17ch: yeah, i'm using a GA to breed best gcc flags, and it sucks running that on my laptop :)
11:47:23 <b_jonas> defun: have you looked at byorgey's recent typeclass manual?
11:47:28 <Cale> defun: They are more general. Every monad is an applicative functor. But for that reason, they are less expressive.
11:47:33 <defun> nope.
11:47:38 <sw17ch> dons: ah, right. are you getting any unexpected results with that?
11:47:42 <b_jonas> defun: http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
11:47:43 <dons> not yet
11:47:50 <dons> still evolving...
11:47:55 <conal> defun: AFs compose, which is nifty.
11:48:03 <Cale> ah, that's true
11:48:14 <defun> b_jonas: thanks.
11:48:15 <maxote> wli, answer me if 223092871 fails or not
11:48:21 <Cale> The composition of any two applicative functors is applicative, but the composite of two monads is not a monad in general.
11:48:21 <conal> defun: so you don't need "applicative transformers".
11:48:22 <b_jonas> unsafeJustMakeToastWithoutReadingManToaster
11:48:37 <defun> conal: sounds useful.
11:48:38 <Cale> (though it is an applicative functor)
11:48:41 <sw17ch> makeUnsafeToast
11:48:47 <sw17ch> it has razors instead of butter
11:48:52 <conal> defun: i use it a lot
11:48:56 <sw17ch> unsafeMakeUnsafeToast
11:49:02 <conal> defun: applicative composition, that is.
11:49:12 <sw17ch> razors, but also covers them in butter so they slip out of your hands while applying them to toast
11:49:47 <b_jonas> no, it just grows a hand and stabs you in the face
11:49:54 <b_jonas> (it also makes some toast)
11:50:08 <newsham> defun: the typeclassopedia had a good insight into the difference (no "join")
11:50:11 <sw17ch> b_jonas: oh, right, i see where i missed that
11:50:13 <sw17ch> :P
11:50:43 <ImInYourMonad> b_jonas: because they might be fakkign things up
11:50:56 <ImInYourMonad> monochrom: i dont knwo really because i dont knwo why it doesnt work
11:53:01 <paper_cc> ImInYourMonad: your vectorLength expects a Floating b => [b] argument and you give it an [Int]
11:53:07 <paper_cc> so it fails
11:53:14 <paper_cc> s/it/the typecheck/
11:56:21 <whpearson> Are there any IRC channels for the discussion of algorithms/data structures?
11:57:53 <Riastradh> ##algorithms?
11:58:30 <b_jonas> I've seen this channel accomodate some discussion once
11:58:35 <b_jonas> (or maybe I was just forcing it)
11:59:09 <monochrom> If you use Haskell for pseudocode, no one would notice it's algorithms/data structures.
12:00:34 * whpearson tries it out
12:01:43 <maxote> wli, 6469693231 does failt it or not?
12:01:54 <forkingYourIO> so do I need to change readTest and readData to be FilePath -> IO [a] ?
12:02:16 <whpearson> I have a class class (Enum a, Bounded a, Eq a, Ord a) =>Trace a where {   swappablePairs :: Set (a,a);  unswappablePairs :: Set (a,a)}
12:02:17 <wli> (19545901,331)
12:02:20 <monochrom> What did wli do to deserve this taunting and haunting by maxote?
12:02:28 <wli> maxote: It gives me that instantly.
12:03:07 <Nafai> @info pred
12:03:07 <lambdabot> pred
12:03:15 <Nafai> Where is pred defined?
12:03:24 <Nafai> :t pred
12:03:25 <lambdabot> forall a. (Enum a) => a -> a
12:03:26 <monochrom> pred is a method of Enum
12:03:44 <Gracenotes> if you make an Enum instance, ya gotta make a pred
12:03:48 <Gracenotes> @instances Enum
12:03:48 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
12:03:52 <forkingYourIO> let k = (read (command_line_args !! 2) :: Int) is thayt the problem?
12:04:01 <Gracenotes> > pred 'q'
12:04:02 <lambdabot>   'p'
12:04:03 <whpearson> If a pair is swappable it defines an equivalence class. E.g if (A,B) and (B,A) are swappable  [B,A] `traceEquivalent` [A,B]
12:04:23 <b_jonas> do you? isn't it defaulted from fromEnum and toEnum?
12:04:27 * b_jonas looks that up
12:04:37 <Gracenotes> b_jonas: well, if you derive an instance, yes
12:05:06 <Gracenotes> hm. You might be right -.-
12:05:28 <whpearson> I have have implemented traceEquiv at least for symmetric pairs. I now want to do traceIsInfixOf.
12:05:32 <b_jonas> no, it seems there are no defaultings in Enum
12:05:40 <pumpkin_> dons: how are you getting ghc-core output with -fvia-C? if I try it, it says Prelude.init: empty list
12:05:43 <b_jonas> you have to define EIGHT methods? that's crazy
12:05:59 <pumpkin_> in the context of http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016729.html
12:06:02 <b_jonas> wait, there must be a default for at least enumFrom etc from succ for unbounded ones
12:06:42 <whpearson> The best way I have thought to do this is generate all valid permutations of a string and see if any of them have the string infixed.
12:06:55 <pumpkin_> whpearson: for what?
12:06:59 <Gracenotes> b_jonas: actually, it seems there are default implementations for everything except fromEnum and toEnum
12:07:15 <b_jonas> yeah, the docs seem to say fromEnum and toEnum is enough if your type is not bounded in either way
12:07:16 <Gracenotes> pred                   = toEnum . (`minusInt` oneInt) . fromEnum
12:07:31 <b_jonas> but you need to define more if the type is bounded (and you don't derive)
12:07:35 <Gracenotes> enumFrom x             = map toEnum [fromEnum x ..]
12:08:24 <whpearson> pumpkin_ Check for race conditions (assume swappable pairs are created by parallel process)
12:09:03 <b_jonas> lucky we have the newtype deriving extension
12:09:22 <Gracenotes> or just data deriving
12:09:23 <b_jonas> not that I understand how exactly that works
12:09:47 <sw17ch> i <3 -XGeneralizedNewtypeDeriving
12:10:11 <whpearson> So I'd want to know if two symbols (representing states) could ever occur together.
12:10:57 <maxote> wli, are you using Int (mod 2^32) ?
12:11:07 <wli> no
12:11:10 <whpearson> pumpkin_: This is all process calculi apparently.
12:11:13 <wli> Integer
12:11:23 <wli> arbitrary precision
12:11:30 <ski_> ronny : pong
12:11:35 <ski_> ronny : huh ? which curses gtk backend ?
12:12:13 <forkingYourIO> hmm haskell is an excellent scripting language, slowly it is replacing eveyrthing i did with python
12:12:15 <ronny> ski_: the one on http://zemljanka.sourceforge.net/cursed/ you linked a screenshot of that some time ago
12:12:31 <ronny> ski_: i had a hard time finding a mail address
12:12:38 <ski_> ronny : oh .. that may be so
12:12:51 <ski_> ronny : no direct relation at all
12:13:31 <ronny> i found the mail of someone that might have been the project leader, i hope he actually is
12:13:59 <ski_> ronny : i found that somehow .. maybe someone on #emacs or #screen or #irssi mentioned it a long time ago .. or maybe i somehow found it on the web, when looking around
12:14:31 <ronny> k, thanks
12:15:17 <maxote> wli, i was not saying factoring the 3 numbers [9699691,223092871,6469693231], i was saying the continued fraction of sqrt of these 3 numbers, can you try it? thanks
12:16:38 <forkingYourIO> Could not find module `Graphics.GNUPlot.Simple':
12:16:38 <forkingYourIO>       it is a member of package gnuplot-0.1, which is hidden
12:16:40 <forkingYourIO> huh?
12:17:20 <mauke> forkingYourIO: what are you trying to build?
12:17:53 <maxote> if it fails 3 times then the prize is served.
12:17:59 <wli> [3114,2,3,4,1,1,1,112,1,1]
12:17:59 <wli> [14936,3,2,2,9,85,1194,1,8,4]
12:17:59 <wli> [80434,2,2,11,1,3,1,7,1,3]
12:18:28 <wli> The first 10 elements of all 3 continued fractions.
12:18:29 <forkingYourIO> mauke: I built it successfulyl but when I try to import GNUplot it fails like that
12:18:44 <forkingYourIO> http://hackage.haskell.org/packages/archive/gnuplot/0.1/doc/html/Graphics-GNUPlot-Simple.html
12:18:45 <maxote> wli, are they cyclic?
12:18:55 <wli> in ascending order
12:19:10 <maxote> try some more longer to see the repeated subsequence
12:19:14 <wli> maxote: Yes; however, I may not have enough RAM to find the cycles.
12:21:44 <wli> See http://en.wikipedia.org/wiki/Continued_fraction#Periodic_continued_fractions
12:21:52 <maxote> ok
12:22:05 <omnihil> if I have an IO a and an IO [a] and I want to do { a <- x; b <- xs; return (a:b); } what does that look like with >>= instead of 'do'?
12:22:56 <mauke> @undo do { a <- x; b <- xs; return (a:b); }
12:22:56 <lambdabot> x >>= \ a -> xs >>= \ b -> return (a : b)
12:23:13 <mauke> @. pl undo do { a <- x; b <- xs; return (a:b); }
12:23:13 <lambdabot> (`fmap` xs) . (:) =<< x
12:23:27 <burp> lol
12:23:29 <burp> I like the lsat one
12:23:33 <omnihil> thanks
12:23:39 <mauke> @. pl undo \x xs -> do { a <- x; b <- xs; return (a:b); }
12:23:39 <lambdabot> liftM2 (:)
12:26:25 <b_jonas> wli: you want to find the full period of the continued fraction form of square roots of those six-digit numbers? interesting.
12:26:31 <forkingYourIO> noone using GNUplot?
12:26:44 <b_jonas> I do sometimes use gnuplot,
12:26:55 <b_jonas> not that it's not spelt GNUplot because it has no relation to GNU
12:26:57 <ski_> (ronny : if you find more recent info on it, i could be interested)
12:27:20 <b_jonas> (prononce it with a silent g to make that clear)
12:27:38 <pumpkin_> I've used a bit of gnuplot
12:27:59 <aeolist> we have all done weird things in our private lives pumpkin_
12:28:03 <wli> maxote: I'll just find the period length with map (\x -> let ~(a:as) = runReader (cf $ Q 0 1 1) x in fmap (+1) (findIndex (== 2*a) as)) [9699691,223092871,6469693231]
12:28:10 <forkingYourIO> and how do you import it?
12:28:15 <pumpkin_> aeolist: was just responding to forkingYourIO :)
12:28:17 <maxote> <wli> maxote: Yes; however, I may not have enough RAM to find the cycles. <--- interesting, is it a problem of Haskell? or is it a problem of the algorithm is (too hungry) CPU-intensive or RAM-intensive?
12:28:19 <forkingYourIO>       it is a member of package gnuplot-0.1, which is hidden
12:28:24 <pumpkin_> forkingYourIO: the haskell package?
12:28:24 <wli> maxote: [Just 3746,Just 6580,Just 55582]
12:28:28 <forkingYourIO> yes
12:28:33 <b_jonas> forkingYourIO: note that there's also a channel for gnuplot
12:28:47 <forkingYourIO> well im wondeing about how using it form ghci
12:28:52 <forkingYourIO> from
12:28:53 <wli> maxote: Those are the period lengths. I'm obviously not going to post anything that enormous onto IRC.
12:29:00 <forkingYourIO> import qualified Graphics.GNUPlot.Simple as S
12:29:06 <forkingYourIO> ->      it is a member of package gnuplot-0.1, which is hidden
12:29:07 <pumpkin_> and that doesn't work?
12:29:13 <forkingYourIO> hidden?
12:29:19 <pumpkin_> forkingYourIO: get 0.3 maybe
12:29:29 <b_jonas> wli: are you using arbitary precision floats (with many digits after decimal point) or exact quadratic irrationals for the computation?
12:29:31 <forkingYourIO> == forkingyourIO
12:29:40 <forkingYourIO> waoit im ImInYourMonad
12:30:44 <wli> b_jonas: Integer
12:30:59 <b_jonas> wli: wait, you can use exact rationals
12:31:11 <wli> b_jonas: Exact quadratic irrationals, I guess.
12:31:27 <b_jonas> wli: because you can compare the finite partial fractions to the sqrt int easily by squaring both sides once
12:31:54 <wli> b_jonas: hpaste en route
12:34:14 <forkingYourIO> now it works(or at least the import does). does it require gnuplot to or is it self-contained?
12:34:19 <wli> b_jonas: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1876#a1876
12:34:52 <b_jonas> wait, I won't look at that yet, I'll try my own continued fraction code to
12:35:03 <b_jonas> I'll just change it to use that squaring thing
12:36:04 <paczesiowa> @src mapAccumL
12:36:04 <lambdabot> mapAccumL _ s []        =  (s, [])
12:36:04 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
12:36:04 <lambdabot>    where (s', y ) = f s x
12:36:04 <lambdabot>          (s'',ys) = mapAccumL f s' xs
12:36:18 <forkingYourIO> anyone ahve a simple plot-example to show?
12:36:33 <wli> Only for hmatrix
12:37:58 <wli> Using hmatrix: Graphics.Plot.plot [Numeric.LinearAlgebra.liftVector Prelude.sin] (0, Prelude.pi/2)  256
12:38:08 <b_jonas> hmm, wait, that square root thing isn't such an easy thing to do with my code
12:38:17 <b_jonas> I'll just keep bigfloats then
12:38:41 <paczesiowa> why ghc docs don't have sources for base package?
12:38:45 <wli> b_jonas: "bigfloats"? There are arbitrary-precision floating point numbers around?
12:39:11 <b_jonas> wli: why not? gmp has them too
12:39:53 <wli> b_jonas: I didn't know they were out there to just be used.
12:40:17 <b_jonas> the problem with bigfloats though is that I think the last few continued fraction digits might be wrong
12:40:44 <b_jonas> your numbers were map sqrt [9699691,223092871,6469693231], right?
12:41:09 <wli> Yeah.
12:41:23 <b_jonas> the first one seems hard
12:41:31 <b_jonas> I only get /3114, 2, 3, 4, 1, 1, 1, 112, 1, 1, 1, 1, 4, 3, 1, 1, 3, 1, 9, 79, 3, 2/
12:41:32 <wli> I really did map (\x -> let as = runReader (cf $ Q 0 1 1) x in findIndex (== 2*head as) as)
12:41:39 <yitz> paczesiowa: it's on the ghc trac website. what do you want the src for?
12:42:03 <b_jonas>  /80434, 2, 2, 11, 1, 3, 1, 7, 1, 3, 1, 5, 1, 1, 16, 1, 18, 1, 3, 1, 6, 5/ for the third
12:42:08 <b_jonas>  /14936, 3, 2, 2, 9, 84, 1, 360, 1, 3, 2, 2, 2, 1, 2/ for the second
12:42:23 <paczesiowa> yitz: Data.List (rewrite rules)
12:42:23 <b_jonas> does that agree with yours except possibly the last few numbers?
12:42:34 <Cheshire> @w80 arboreal
12:42:37 <lambdabot> *** "arboreal" wn "WordNet (r) 2.0"
12:42:37 <lambdabot> arboreal
12:42:37 <lambdabot>      adj 1: of or relating to or formed by trees; "an arborous roof"
12:42:37 <lambdabot>             [syn: {arborical}, {arborary}, {arborous}]
12:42:37 <lambdabot>      2: inhabiting or frequenting trees; "arboreal apes" [syn: {arboreous},
12:42:39 <lambdabot> [6 @more lines]
12:42:45 <b_jonas> there's something wrong with my program I think
12:42:46 <Cheshire> @more
12:42:46 <lambdabot>          {tree-living}] [ant: {nonarboreal}]
12:42:46 <lambdabot>      3: resembling a tree in form and branching structure;
12:42:46 <lambdabot>         "arborescent coral found off the coast of Bermuda";
12:42:46 <yitz> paczesiowa: start here: http://hackage.haskell.org/trac/ghc/wiki/DarcsRepositories
12:42:47 <lambdabot>         "dendriform sponges" [syn: {arboreous}, {arborescent}, {arboresque},
12:42:49 <lambdabot>          {arboriform}, {dendriform}, {dendroid}, {dendroidal}, {treelike},
12:42:49 <maxote> b_jonas, use http://hpaste.org/ instead of here
12:42:51 <lambdabot>          {tree-shaped}]
12:42:55 <wli> b_jonas: The period lengths are thousands of digits long. They agree to the length you've pasted them.
12:43:55 <forkingYourIO> *** Exception: gnuplot: runGenProcess: does not exist (No such file or directory)
12:43:58 <b_jonas> these must be some special numbers
12:44:04 <paczesiowa> yitz: thanks, but would be nice to have sources available locally
12:44:04 <b_jonas> or not
12:44:13 <forkingYourIO> runGenProcess, is that msys?
12:44:25 <wli> b_jonas: That list of Maybe Int was the period length for each
12:44:29 <yitz> paczesiowa: use darcs get --partial on those urls
12:44:30 <forkingYourIO> a fork in your balls > ghc on windows?
12:44:36 <b_jonas> wli: ugly
12:44:50 <b_jonas> let me try asking Mathematica
12:46:05 <wli> b_jonas: At least assuming double of the lead element isn't part of the symmetric subsequence of the period.
12:46:11 <wli> sequence $ map (\x -> let as = runReader (cf $ Q 0 1 1) x in findIndex (== 2*head as) as) [9699691,223092871,6469693231]
12:46:11 <wli> Just [3746,6580,55582]
12:46:22 <b_jonas> yeah, Mathematica gives the full period
12:46:45 <wli> Are those lengths correct?
12:46:49 <b_jonas> a moment
12:47:39 <paczesiowa> yitz: where are the rules for maps and folds?
12:48:26 <yitz> paczesiowa: in base, GHC.List
12:48:44 <b_jonas> In[7]:= Map[Length[Last[ContinuedFraction[Sqrt[#]]]]&, {9699691,223092871,6469693231}]
12:48:47 <b_jonas> Out[7]= {3746, 6580, 55582}
12:48:53 <b_jonas> agrees, right
12:48:59 <paczesiowa> yitz: thanks!
12:49:11 <b_jonas> let's try other computer algebra systems too
12:49:19 <b_jonas> let me look up in GAP's manual if they have this
12:49:25 <b_jonas> then maple
12:49:38 <b_jonas> and I think I don't have maxima installed and I definitely don't have magma installed
12:50:02 <maxote> b_jonas, all? that's beast!
12:50:03 <wli> b_jonas: sqrt(2^(2^5)+1) has an "interesting" continued fraction.
12:51:03 <wli> b_jonas: As does sqrt(2^(2^n)+1) for positive integer n, really.
12:51:43 <paczesiowa> :t (# 1, 2 #)
12:51:44 <lambdabot> forall t t1. (Num t1, Num t) => (# t, t1 #)
12:51:57 <paczesiowa> :t \(# a, b #) -> b
12:51:58 <lambdabot> Top level:
12:51:58 <lambdabot>     Couldn't match kind `(#)' against `??'
12:51:58 <lambdabot>     When matching the kinds of `(# t1, t2 #) :: (#)' and `t :: ??'
12:52:46 <paczesiowa> what's up with that?
12:53:05 <ddarius> :k (#,#)
12:53:06 <lambdabot> parse error on input `,'
12:53:18 <ddarius> :k (# Int# , Int# #)
12:53:19 <lambdabot> Not in scope: type constructor or class `Int#'
12:53:19 <lambdabot> Not in scope: type constructor or class `Int#'
12:53:24 <maxote> the served prize is that the 3 numbers are [ 1+2*3*5*7*11*13*17, 1+2*3*5*7*11*13*17*19, 1+2*3*5*7*11*13*17*19*23 ], same as 50511=1+2*3*5*7*11*13.
12:53:31 <ddarius> :k (# Int , Int #)
12:53:33 <lambdabot> (#)
12:53:42 <ddarius> :k (->)
12:53:43 <lambdabot> ?? -> ? -> *
12:53:55 <maxote>  /50511/510511
12:55:13 <b_jonas> wli: gap claims to compute the full period for sqrt(integer), but it gives a single list so I'm not sure how to tell where the period starts
12:56:03 <wli> map factor [9699691,223092871,6469693231] --> [(27953,347),(317,703763),(19545901,331)] in (0.03 secs, 1533800 bytes)
12:57:16 <maxote> b_jonas, it's interesting to write a script for haskell, mathematica, maple, another CAS, axiom, fricas, maxima, ... say: all say the same thing, or all except some of them say one thing, and the rest say the another things.
12:58:09 <SamB> polyglots are cool, yeah
12:58:57 * wli tries to figure out how the diagonal list flattening worked.
12:59:15 <wli> I used to call it "cantor" but anyway.
12:59:41 <paczesiowa> @src build
12:59:41 <lambdabot> build g = g (:) []
13:00:05 <b_jonas> I can't do it easily with maple either
13:00:26 <wli> Basically to interleave a search over an infinite number of infinite lists.
13:00:30 <maxote> b_jonas, i you don't like it, don't use it.
13:00:43 <maxote> there are many CAS packages
13:01:17 <b_jonas> maxote: I just wanted to try if it had a builtin for finding the period
13:01:26 <maxote> http://sourceforge.net/projects/reduce-algebra/   it's new released from Jan-2009
13:01:31 <wli> It should turn [[(i, j) | j <- [0..]]|i <- [0..]] into concat [[(i, j) | j <- [0 .. i]] | | i <- [0 ..]]
13:01:35 <forkingYourIO> No instance for (Floating Int) ; what sia a Floating Int?
13:02:29 <maxote> err, /Jan-2009/31th-Dec-2008/
13:02:47 <Gracenotes> it means that something's an int and you're trying to take the sqrt of it, or something like that
13:02:49 <Gracenotes> *Int
13:03:36 <forkingYourIO> *** Exception: gnuplot: runGenProcess: does not exist (No such file or directory)
13:03:39 <forkingYourIO> runGenProcess, is that msys?
13:03:44 <wli> It was concat . f for f = something
13:03:56 <trofi> @hoogle runGenProcess
13:03:56 <lambdabot> No results found
13:04:41 <forkingYourIO> so how do I go from Int to Double?
13:04:48 <forkingYourIO> fromIntegral doesnt seem to do the trick
13:05:00 <trofi> http://www.nabble.com/Problem-installing-curl-td20445468.html
13:05:13 <forkingYourIO> and why does ghci allow implicit casting?
13:05:30 <paczesiowa> forkingYourIO: there is no casting
13:05:38 <paczesiowa> :t 1
13:05:39 <lambdabot> forall t. (Num t) => t
13:06:12 <forkingYourIO> sqrt 9 -> 3.0
13:06:24 <trofi> :t 9
13:06:25 <lambdabot> forall t. (Num t) => t
13:06:29 <forkingYourIO> how do I solve the sqrt problem?
13:06:41 <mauke> there is no problem
13:06:49 <chessguy> @type sqrt
13:06:50 <lambdabot> forall a. (Floating a) => a -> a
13:07:01 <chessguy> > sqrt (fromIntegral 9)
13:07:02 <lambdabot>   3.0
13:07:02 <maxote> to do easy the scripts, i recommend a plain output's text of the different languages, e.g. one number per line, and to diff them.
13:07:03 <mauke> > sqrt (fromIntegral (length "foo"))
13:07:04 <lambdabot>   1.7320508075688772
13:07:13 <forkingYourIO> well obv there is
13:07:43 <forkingYourIO> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1878#a1878
13:07:59 <chessguy> > sqrt 9
13:08:00 <lambdabot>   3.0
13:08:08 <chessguy> > sqrt (9::Int)
13:08:09 <lambdabot>       No instance for (Floating Int)
13:08:09 <lambdabot>        arising from a use of `sqrt' at <...
13:08:52 <forkingYourIO> so how to Int->whatever i can sqrt
13:08:53 <forkingYourIO> ?
13:08:58 <alatter> fromIntegral
13:09:03 <chessguy> forkingYourIO:  do "vectorLength v = sqrt . fromIntegral $ ... "
13:09:32 <chessguy> @src Floating
13:09:32 <lambdabot> class  (Fractional a) => Floating a  where
13:09:32 <lambdabot>     pi                                                      :: a
13:09:32 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
13:09:32 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
13:09:32 <lambdabot>     (**), logBase                                           :: a -> a -> a
13:09:39 <forkingYourIO> vectorLength v = sqrt . fromIntegral $ L.foldl' (\x y -> x + y*y) 0 v
13:09:44 <forkingYourIO> No instance for (Floating Int)
13:09:44 <forkingYourIO>       arising from a use of `tanimotoCoefficient'
13:10:09 <chessguy> huh?
13:10:22 <byorgey> that error looks like it's coming from somewhere else.
13:10:25 <mauke> forkingYourIO: your lack of type signatures makes finding the problem unnecessarily hard :/
13:10:41 <Gracenotes> :t let x = 5 in x
13:10:41 <lambdabot> forall t. (Num t) => t
13:10:48 <Gracenotes> :t let x = sqrt 5 in x
13:10:49 <lambdabot> forall t. (Floating t) => t
13:10:55 <Gracenotes> :t let x = gcd 5 1 in x
13:10:56 <lambdabot> forall t. (Integral t) => t
13:10:58 <forkingYourIO> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1878#a1879
13:11:19 <forkingYourIO> mauke: well i removed them because i thought they might be causing it
13:11:30 <mauke> uh ... "good" idea
13:11:34 <maxote> and one generic intelligent script that does the report of the diff of the output's texts of all the CAS packages independently of the applied method
13:11:43 <chessguy> forkingYourIO:  "    Probable fix: add a type signature that fixes these type variable(s)"
13:11:44 <tromp_> @hoogle fromJust
13:11:44 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
13:11:51 <tromp_> @hoogle maybe
13:11:51 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:11:51 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
13:11:51 <lambdabot> module Data.Maybe
13:12:12 <andun> is it possible to re-export a module without explicitly listing all functions and data types to re-export?
13:12:26 <mauke> andun: yes
13:12:44 <paczesiowa> @src ($!!)
13:12:44 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:12:52 <paczesiowa> @src ($!)
13:12:52 <lambdabot> f $! x = x `seq` f x
13:12:54 <forkingYourIO> chessguy: yeah and i can never remember what those are
13:12:57 <mauke> module Foo (module Bar)
13:13:00 <mauke> where
13:13:09 <paczesiowa> @src deepSeq
13:13:09 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:13:18 <chessguy> forkingYourIO:  eh?
13:13:41 <andun> mauke: thank you :-)
13:13:50 <DBAlex> how do I define this in haskell, I have a function called quickCheck that checks a function, I want a function that runs quickCheck on a function n times, e.g. nCheck 500 functionname ?
13:13:54 <wli> > let cantor = let zip' (x:xs) (ys:yss) = (x:ys) : zip' xs yss ; zip' [] yss = yss ; zip' xs@(_:_) [] = map return xs ; f [] = [] ; f ([]:xss) = f xss ; f ((x:xs):xss) = [x] : zip' xs (f xss) in concat . f in drop 111 $ cantor [[(i, j) | j :: Int <- [0 .. 10]] | i :: Int <- [0 .. 10]]
13:13:56 <lambdabot>   [(7,10),(8,9),(9,8),(10,7),(8,10),(9,9),(10,8),(9,10),(10,9),(10,10)]
13:13:58 <DBAlex> like what is the type of that function?
13:14:14 <mauke> DBAlex: what is the type of quickCheck?
13:14:38 <DBAlex> mauke: Main> :t quickCheck
13:14:38 <DBAlex> quickCheck :: Testable a => a -> IO ()
13:15:07 <mauke> nCheck n x = replicateM_ n (quickCheck x)
13:15:20 <DBAlex> ok
13:15:22 <chessguy> @type \n x -> replicateM_ n (quickCheck x)
13:15:23 <lambdabot> forall prop. (Testable prop) => Int -> prop -> IO ()
13:15:25 <DBAlex> replicateM_n ?
13:15:38 <chessguy> there's a space in there
13:15:38 <mauke> you fail at copy/paste
13:15:46 <DBAlex> oh yeah sorry
13:15:54 * DBAlex looks up the function
13:15:55 <chessguy> @src replicateM_
13:15:55 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
13:16:09 <forkingYourIO> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1878#a1880
13:16:31 <forkingYourIO> so I fromIntegraled it
13:16:35 <chessguy> forkingYourIO:  you've been told about 8 times to add type signatures...
13:17:02 <DBAlex> ok
13:17:04 <b_jonas> chessguy: is that different from forever?
13:17:10 <b_jonas> @type forever
13:17:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:17:25 <chessguy> b_jonas:  replicateM_ you mean?
13:17:33 <b_jonas> @type let replicateM_ n x = sequence_ (replicate n x) in replicateM_
13:17:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
13:17:36 <alatter> b_jonas: it is similar, except that it stops
13:17:45 <b_jonas> oh, it's replicate, not cycle
13:17:50 <b_jonas> @type let replicateM_ n x = sequence_ (repeat n x) in replicateM_
13:17:51 <lambdabot>     Couldn't match expected type `t -> [m a]'
13:17:51 <lambdabot>            against inferred type `[a1]'
13:17:51 <lambdabot>     In the first argument of `sequence_', namely `(repeat n x)'
13:17:56 <b_jonas> @type let replicateM_ x = sequence_ (repeat x) in replicateM_
13:17:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:18:01 <b_jonas> > repeat 1
13:18:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:18:12 <b_jonas> I see
13:18:39 <b_jonas> chessguy: but one of them was me, it's no wonder he doesn't believe me
13:18:44 <forkingYourIO> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1878#a1881
13:18:58 <DBAlex> > replicateM_ 5
13:18:59 <lambdabot>       Overlapping instances for Show (m a -> m ())
13:18:59 <lambdabot>        arising from a use ...
13:19:07 <DBAlex> > replicateM_ 5 'a'
13:19:08 <lambdabot>   Couldn't match expected type `m a' against inferred type `Char'
13:19:23 <alatter> > replicateM_ 5 "a"
13:19:24 <lambdabot>   [()]
13:19:25 <Spockz|servert> A friend of mine has a problem installing ghc on his PowerBook G4: http://spockz.pastebin.com/f6e0976b5
13:19:43 <mauke> > replicateM 3 "hello"
13:19:44 <lambdabot>   ["hhh","hhe","hhl","hhl","hho","heh","hee","hel","hel","heo","hlh","hle","h...
13:19:50 <b_jonas> ImInYourMonad: that paste is suspicious: it has the constraint Num [b] which likely is an error
13:19:55 <DBAlex> mauke: replicateM_ isn't in hugs standard prelude
13:20:00 <DBAlex> ok i'll try replicateM
13:20:05 <mauke> DBAlex: what?
13:20:17 <mauke> DBAlex: I never said it would be in the prelude
13:20:22 <DBAlex> :S
13:20:24 <DBAlex> ok :P
13:20:27 <ImInYourMonad> but can soemone say what the actual problem is?
13:20:37 <mauke> DBAlex: :also Control.Monad
13:20:44 <DBAlex> is there anything that works the same way as replicateM in the standard prelude?
13:20:49 <ImInYourMonad> i ahve a vector of ints, ic alc the cosineSimilarity which should reutrn a Double, so where is the problem?
13:21:14 <b_jonas> ImInYourMonad: not if you don't add type sigs because this way the compiler will do type derivation in the whole file so it's hard to tell which function has the error
13:21:22 <chessguy> @index replicateM
13:21:22 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:21:48 <b_jonas> if you add the type sig for each function specifying what you think the type should be, you'll be able to tell whcih one has a wrong definition or type because the compiler will give an error for that one function
13:22:07 <DBAlex> mauke: well why would you give a solution with custom functions?
13:22:25 <chessguy> it's all about being friends with the type system, instead of fighting it :)
13:22:39 <mauke> DBAlex: what?
13:22:53 <mauke> DBAlex: why can't you load modules?
13:22:58 <DBAlex> you said replicateM_ isn't in the prelude, so why did you use it !
13:23:07 <chessguy> it
13:23:09 <DBAlex> I can, i'd rather use stuff thats in the prelude though
13:23:13 <mauke> DBAlex: why?
13:23:18 <chessguy> it's not in the prelude, but it is in the standard library
13:23:21 <b_jonas> if you define a function with a function definition that has arguments in it like f x = ..., then its derived type doesn't depend on the uses of f, right? it can however depend on the types of things referenced from that defn
13:23:31 <DBAlex> mauke: because I just do
13:23:42 <Heffalump> b_jonas: not unless those uses are part of a mutually recursive group with f
13:23:44 <mauke> you are now stupid and ugly
13:23:46 <chessguy> smells like homework to me
13:23:52 <alatter> DBAlex: I think hugs ships with Control.Monad.  Its pretty useful
13:23:59 <DBAlex> ok
13:24:05 <b_jonas> Heffalump: ah, right
13:24:07 <Heffalump> mauke: please don't escalate arguments :-)
13:24:34 * mauke watched Linus's git talk last night
13:24:42 <b_jonas> DBAlex: well, you've seen the definition of replicateM_ lambdabot gave, right?
13:24:46 <b_jonas> that almost uses only prelude functions
13:24:53 <b_jonas> sequence_ is in prelude, right?
13:25:01 <chessguy> @index sequence_
13:25:01 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:25:04 <byorgey> ImInYourMonad: here is how you can approach the problem: comment out the part which is causing the error so that it compiles again.  Then go through and carefully add a type annotation to each function which is the type you *think* it should have, *without* using ghci to check.
13:25:12 <b_jonas> er no, replicate is not in prelude
13:25:25 <b_jonas> anyway, either is easy to define
13:25:27 <byorgey> ImInYourMonad: check that it still compiles at each step.  you will inevitably find your bug this way.
13:25:35 <b_jonas> @index replicate
13:25:36 <lambdabot> Data.List, Prelude
13:25:38 <b_jonas> it is?
13:25:57 <byorgey> ImInYourMonad: at this point I don't think anyone really wants to read all that code and perform tons of type inference in their head to figure out what is causing your problem.
13:25:59 <DBAlex> replicate is in the prelude
13:26:05 <DBAlex> well it is here anyway
13:26:15 <b_jonas> it is
13:26:19 <chessguy> byorgey:  you're so much more diplomatic than me :)
13:26:59 <byorgey> chessguy: I try =)
13:27:37 <b_jonas> let { myReplicate :: Int -> a -> [a]; myReplicate n x = (enumFromTo 1 n) >> [x]; } in myReplicate 10 'a'
13:27:44 <b_jonas> > let { myReplicate :: Int -> a -> [a]; myReplicate n x = (enumFromTo 1 n) >> [x]; } in myReplicate 10 'a'
13:27:45 <lambdabot>   "aaaaaaaaaa"
13:28:02 <ImInYourMonad> thanks it works now, i dropped inferring with the notations given by ghci and jsut addwed my own
13:28:10 <pumpkin_> ImInYourMonad: you didn't take my suggestion :(
13:28:14 <b_jonas> the compiler is there to help you
13:28:15 <Heffalump> byorgey: another diagrams question - do you have any plans to fix the behaviour of bounding boxes with rotate?
13:28:17 <b_jonas> :-)
13:28:32 <wli> I guess there's some work to do to interleave things now.
13:29:08 <bd_> @hoogle [[a]] -> [[a]]
13:29:08 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
13:29:08 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:29:08 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:29:36 <Elly> @hoogle par
13:29:36 <lambdabot> Control.Parallel par :: a -> b -> b
13:29:36 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
13:29:36 <lambdabot> Text.XHtml.Strict paragraph :: Html -> Html
13:29:55 <maltem> mauke: My conclusion on that talk was, git is of course awesome, but Linus is tiresome :)
13:29:56 <wli> I wonder if what I call cantor is actually floating around the std libs somewhere under another name.
13:30:17 <mdmkolbe> Ok, I'm stumped.  How do I get this to work? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1882#a1882
13:30:52 <Cheshire> mdmkolbe, use GADTs
13:31:03 <Saizan_> mdmkolbe: you can't, you've to define foo as the member of a typeclass
13:31:03 <Heffalump> mdmkolbe: you just can't do that with type families
13:31:20 <Saizan_> well, not really foo
13:31:20 <ImInYourMonad> can Yi infer types automatically?
13:31:21 <Heffalump> use a GADT or a typeclass as suggested
13:31:30 <Cheshire> data Y where Y :: Foo a -> a -> Y
13:31:40 <mdmkolbe> Cheshire: I need Foo to be open so GADTs are out
13:31:44 <Heffalump> Cheshire: that won't help
13:31:48 <Heffalump> mdmkolbe: type class then
13:31:55 <Cheshire> not true
13:31:57 <Heffalump> Cheshire: the type class constructors have to discriminate amongst the types
13:31:57 <ImInYourMonad> pumpkin: which was your suggestion?
13:32:07 <mdmkolbe> Heffalump: what sort of type class do you mean?
13:32:20 <pumpkin_> ImInYourMonad: dot product of x with itself = length^2
13:32:25 <Heffalump> mdmkolbe: put foo, or something that you use to implement foo, in a typeclass
13:33:29 <wli> I think what gmp has is multiple precision with the precision determined up-front, which is still quite useful.
13:33:54 <Saizan_> mdmkolbe: something like class Bar a where data Foo a; foo' :: Foo a -> a -> X
13:33:55 <mdmkolbe> Heffalump: appologies for being dense, but I'm not seeing how that would work
13:34:36 <mdmkolbe> Saizan_: hmm, I think that I understand it a bit better
13:34:51 <Heffalump> class Something x where foo :: Y (Foo a) a -> X
13:35:09 <Heffalump> no, not quite
13:35:14 <Heffalump> data Y a = Y (Foo a) a
13:35:21 <Heffalump> class Something x where foo :: Y a -> X
13:35:34 <pumpkin_> ImInYourMonad: also, this looks fishy to me: dotProduct v1 v2 = sum . fromIntegral $ zipWith (*) v1 v2
13:35:36 <Heffalump> instance Something (Int -> X) where foo (Y ConstrX1 z) = z 0
13:35:44 <pumpkin_> shouldn't it be fromIntegral . sum ?
13:36:03 <maxote> wli, there is an interesting ToDo
13:36:05 <pumpkin_> or even better, fromIntegral . foldl' (+) 0
13:36:39 <b_jonas> wli: well, procedurally thinking, you need to keep a constant number of bigfloats to compute the continued fraction, so you can just choose the precision to the highest that fits in memory
13:36:52 <maxote> get the period sequence of the continued fraction of sqrt of the sequence but faster later.
13:36:56 <Cheshire> mdmkolbe, consider this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1882#a1883
13:37:01 <b_jonas> that doesn't help you find the period though
13:37:01 <pumpkin_> ImInYourMonad: that kind of thing will give you a crazy type signature that you're unlikely to find real instances
13:37:08 <pumpkin_> ...of
13:37:21 <maxote>  /sequence but/natural sequence but/
13:37:30 <b_jonas> I'm not sure how you could get the period for sure without computing with exact quadratic irrationals
13:37:37 <Cheshire> mdmkolbe, see how if you change the foo parameter of Y -- you have to change 'foo' as well
13:37:44 <mathijs> Can anyone comment on the main differences between parsec2 and parsec3? I'm learning parsec (first from RWH), but I figured that by the time I start using it for production code, parsec3 might be the default, so I would like to start there anyway. Or at least know what differences to expect.
13:38:24 <alatter> mathijs: Parsec3 can be used to parse things other than lists, and can be used as a monad trnsformer (so you cn interleave parsing with other effects)
13:38:26 <mdmkolbe> hmm, I'm going to have to think about this.  The trouble is that there are a lot of "foo" functions and it doesn't make sense to define a type class for each one, but maybe there is a single method I could implement that would do what I want
13:38:51 <alatter> mathijs: parsec3 has a reasonably comprehensve compatibility layer for the parsec2 api, as well
13:38:55 <mdmkolbe> Cheshire: I like what you posted, but I'm going to have to thing through this a bit
13:39:30 <Heffalump> Cheshire's solution is just right if you don't need openness in Foo
13:39:38 <Cheshire> but mine is open
13:39:49 <alatter> mathijs: most folks stick with parsec2 if they don't need what parsec3 has to offer, because parsec2 is faster.
13:39:54 <Heffalump> you can't add new constructors to Foo
13:39:56 <mdmkolbe> Cheshire: how is it open?  (Which I do need)
13:40:22 <Heffalump> if you want openness in both ConstrX* and the foo functions, then you have the expression problem
13:40:33 <Heffalump> for which solutions do exist, but nothing really clean and easy to use
13:40:36 <b_jonas> I think you can somehow simulate open types with typeclasses, I'm just not sure how many extensions that needs
13:40:40 <mdmkolbe> Cheshire: (I liked it until I realized it wasn't open)
13:40:45 <Cheshire> it is open
13:40:47 <mathijs> alatter: so if I just learn parsec2 (and don't need to interleave with other effects), parsec3 is almost 100% compatible and just adds extra features?
13:41:43 <alatter> mathijs: yup.  not exactly 100% - I think there is at least one parsec2 based package that won't build against parsec3
13:41:52 <alatter> mathijs: but really close to 100% :-)
13:41:59 <Heffalump> Cheshire: are you planning on elaborating on that claim?
13:42:01 <maxote> it's useful to say, before of calculating a continued fraction of sqrt of a titanic number, i can predict what's the exact period of its result before of starting its computation.
13:42:33 <maxote> only if the period's sequence is known and exact
13:42:38 <DBAlex> nCheck n(-1) x = quickCheck x
13:42:38 <DBAlex>                    ncheck n x
13:42:41 <DBAlex> whats wrong with this
13:42:53 <DBAlex> actually
13:42:53 <DBAlex> nvm
13:42:54 <mdmkolbe> Cheshire: If more constructors get added to X or I add another type Z along side X, then another constructor would have to be added to Foo which in my case is a no-go since X and Z may be defined in different places but need to use the same Foo/Y
13:42:54 <DBAlex> :S
13:43:08 <Cheshire> mdmkolbe, then you defined  Foo'
13:43:22 <Heffalump> but how do you add cases to foo for it?
13:43:22 <mathijs> alatter: well I can live with that :)  and about the performance... If I use parsec3 for things that could have be done in parsec2, things will be slower? that sounds like a regression. Probably folks will keep using parsec2 until parsec3 offers the same performance when only using parsec2 features?
13:43:32 <Cheshire> Heffalump, you define foo'
13:43:41 <DBAlex> how do I perform more than one operation per line ?
13:44:01 <alatter> mathijs: it is a regression.  I guess it depends on how much speed you need from your parsing.
13:44:24 <DBAlex> nCheck n(-1) x = quickCheck x; nCheck n x
13:44:32 <trofi> :t do { print 1; print 1; }
13:44:33 <lambdabot> IO ()
13:44:34 <DBAlex> I need to do this basically (using c style syntax)
13:44:40 <DBAlex> ok
13:45:17 <maxote> sometimes, if the predicted period of this titanic number is prohibitive then i can avoid starting the computation of its sqrt's continued fraction.
13:45:53 <mathijs> alatter: well I don't expect parsing to be a bottleneck most of the time. thanks for helping :)
13:48:26 <tromp_> :t liftM2
13:48:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:50:25 <Cheshire> mdmkolbe, what is the non-simplified version of your code?
13:50:46 <mdmkolbe> Cheshire: very long
13:51:00 <Cheshire> I guess that means you don't want to show me
13:51:03 <Cheshire> that's fine
13:51:26 <mdmkolbe> Cheshire: but I'm actually thinking you solution might be workable.  Trickly but workable
13:51:40 <bd_> @hoogle isLeft
13:51:40 <lambdabot> No results found
13:51:53 <Cheshire> ideally, it should not be tricky at all
13:52:00 <Cheshire> but I don't really know enough to say
13:52:08 <DBAlex> dontimes (n+1) = do {print n;dontimes n;}
13:52:09 <DBAlex> Main> dontimes 5
13:52:09 <DBAlex> <<IO action>>
13:52:17 <DBAlex> anyone know why this happens?
13:53:02 <chessguy> hm? ghci says <<IO action>> ?
13:53:15 <DBAlex> no, hugs
13:54:01 <maxote> wli, is this sequence monotone ascendent?   sequence $ map (\x -> let as = runReader (cf $ Q 0 1 1) x in findIndex (== 2*head as) as) [1..]
13:54:19 <DBAlex> chessguy: it should work right?
13:54:20 <Cheshire> @seen newsham
13:54:20 <lambdabot> newsham is in #haskell-blah and #haskell. I last heard newsham speak 39m 43s ago.
13:55:15 <DBAlex> > dontimes (n+1) = do {putStrLn [intToDigit n];dontimes n;}
13:55:16 <lambdabot>   <no location info>: parse error on input `='
13:55:22 <DBAlex> > dontimes 5
13:55:23 <lambdabot>   Not in scope: `dontimes'
13:55:38 <chessguy> DBAlex:  check this out: http://codepad.org/2z50aP0L
13:55:43 <DBAlex> chessguy: ok
13:56:17 <DBAlex> ah
13:56:27 <DBAlex> chessguy: is that something to do with monads?
13:56:45 <chessguy> DBAlex:  no, it's something to do with n+k patterns
13:56:50 <chessguy> namely, they suck
13:57:01 <maxote> b_jonas, is it ascendent?   In[7]:= Map[Length[Last[ContinuedFraction[Sqrt[#]]]]&, {0,1,2,3,4,5,6,7,8,9,10,11,12,13}]
13:57:03 <DBAlex> heh
13:57:04 <DBAlex> ok
13:57:10 <chessguy> DBAlex:  you should have a base case anyway
13:57:19 <chessguy> DBAlex:  and then use guards
13:57:32 <b_jonas> maxote: Mathematica
13:57:35 <DBAlex> ok
13:57:37 <BMeph> I think they wouldn't suck as badly if Haskell had a genuine Natural type. :)
13:57:49 <Cheshire> is:
13:57:53 <Cheshire> data Natural a = Zero | Succ a
13:57:55 <Cheshire> good?
13:57:56 <gnut> hi
13:57:57 <maxote> i've not Mathematica :(
13:58:01 <b_jonas> maxote: wait, what do you mean ascendent?
13:58:09 <Cheshire> viewNatural 0 = Zero ; viewNatural n = Succ (n-1)
13:58:15 <BMeph> At least, you'd expect the odd behavior from that end.
13:58:32 <Cheshire> factorial (viewAs -> (n, viewNatural -> Succ m)) = n * factorial m
13:58:42 <maxote> b_jonas, period sequence's next number > current number
14:00:28 <b_jonas> maxote: not likely. this gives the length of the period.
14:02:41 <monochrom> Saturday afternoon is a great time to enjoy the HWN.
14:03:28 <dons> ?yow!
14:03:28 <lambdabot> Not SENSUOUS ... only "FROLICSOME" ... and in need of DENTAL WORK ... in PAIN!!!
14:03:41 <dons> saturday afternoon is a great time to package some haskell software :)
14:04:13 <dons> ok lads: what logical framework does the GHC type system with full extensions correspond to?
14:04:35 <pejo> dons, the Oleg?
14:04:43 <Cheshire> what isa logical framework ?
14:05:00 <mperillo> I'm searching a funtion, so that:  f (a, b) -> (f a, f b)
14:05:04 <paczesiowa> pejo: dons said correspond, not belong
14:05:08 <pumpkin_> how can I ask ghc to not get rid of a .raw_s file?
14:05:09 <dons> say, first order predicate logic, HOL, second order x y z , etc.
14:05:22 <dons> pumpkin_: use ghc-core to view the .s
14:05:26 <dons> else -keep-tmp-files
14:05:33 <pumpkin_> thanks
14:05:35 <monochrom> I don't think it's higher-order yet.
14:06:07 <dons> but no one is really sure.
14:06:14 <dons> need to sit down with curry and howard
14:06:25 <Cheshire> so it's something other than System F(c) ?
14:06:35 <newsham> chesh: ?
14:06:41 <dons> well, System F == second order predicate logic, afaik
14:06:49 <monochrom> It's something other than System F(c).
14:06:55 <dons> propositional.
14:07:02 <Cheshire> hey newsham, I wondered if you have a link to your (possibly draft) thing about marshalling and GADTs?
14:07:16 <dons> now, ghc though implements something not quite the same
14:07:29 <newsham> mperillo:  tupmap f (a,b) = (f a, f b)   -- there you go
14:07:34 <monochrom> Do not use what GHC Core uses. GHC Haskell deliberately doesn't use all of GHC Core.
14:08:02 <mperillo> newsham, thanks; but I was asking if such a function already exist
14:08:11 <SamB> monochrom: what's the extra stuff there for then ?
14:08:11 <newsham> mperillo: if f is polymorphic, it still will only work for tuples of type (a,a) though
14:08:25 <newsham> cheshire: yup, 1 sec.
14:08:34 <dons> now, "GHC supports impredicative polymorphism, enabled with -XImpredicativeTypes. This means that you can call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. "
14:08:40 <newsham> cheshire: what's your email addr?
14:08:52 <Cheshire> newsham, I just wanted to give teh url to mdmkolbe
14:09:03 <dons> http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/
14:09:13 <Cheshire> (to see if what they were doing has any overlap)
14:09:17 <dons>  does that stuff have any impliciations for what we can 'prove' in our logic. i imagine so -- it admits more programs
14:10:03 * mdmkolbe hears his name
14:10:51 <skorpan> i'm not trolling, i'm BOXY YOU SEE?
14:11:22 <Cheshire> dons, what does it mean to prove something in this logic ?  .. I mean isn't everything proved by _|_ already
14:11:33 <monochrom> "what's the extra stuff there for" is not a right question. A right question how "why choose a sufficient but unnecessary intermediate language". An answer is "it's off-the-shelf, it's sufficient, who cares about necessity"
14:11:45 <monochrom> s/how/is/
14:12:43 <dons> Cheshire: types correspond to propositions in this logic, and Haskell programs as proofs
14:12:56 <dons> so you can show a -> a by writing the program for that type
14:12:59 <dons> ?djinn a -> a
14:12:59 <lambdabot> f a = a
14:13:03 <Cheshire> isn't it a trivial logic though?
14:13:10 <dons> well, what logic is it?
14:13:20 <Cheshire> the trivial logic where everything is true
14:13:28 <dons> undefined complicates things
14:13:33 <dons> ignore that for now.
14:13:47 <dons> it's like "trust me, i have a proof"
14:14:23 <dons> hmm. the wikibook probably has something on this...
14:14:26 <mdmkolbe> newsham, Cheshire: at first glance there doesn't appear to be very much direct overlap, but perhaps there is overlap at a deeper level that I haven't seen yet
14:14:45 <dons> http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism#The_problem_with_.E2.8A.A5
14:15:02 <newsham> mdm: what are you working on?
14:15:23 <dons> Cheshire: "if we work with a limited subset of Haskell's type system, and in particular disallow polymorphic types, we have a consistent logic system we can do some cool stuff in."
14:15:29 <dons> wikibook has a nice turn of phrase.
14:16:43 <mdmkolbe> newsham: a generalization of "scrap your boilerplate reloaded" that allows one to define generic types instead of only generic functions
14:17:04 <paczesiowa> can someone explain to me the build function (or augment, I don't even know which one is simpler)?
14:17:23 <mdmkolbe> newsham: e.g. in the style of GH but that works with regular GHC
14:17:27 <Cheshire> mdmkolbe, what is a generic type ?
14:17:52 <Cheshire> I've seen Generic Haskell
14:17:55 <mdmkolbe> Cheshire: a type constructor that is defined in terms of the structure of it's argument
14:18:13 <mdmkolbe> Cheshire: GH would call them type-indexed types
14:19:03 <Cheshire> mdmkolbe, related to http://muaddibspace.blogspot.com/2009/01/more-gadt-nonsense.html at all?
14:19:49 <Cheshire> mdmkolbe, (this is basicaly the same technique as in newshams stuff, applied to a different problem)
14:21:29 <Cheshire> dons, If you just consider the pure lambda fragment that's System F isn't it ? and then GADTs and that add equality proofs into the mix.. I don't know about impredicative or type families (or classes) though..
14:22:12 <ImInYourMonad> is there no way to filter over 2 lists?
14:22:46 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1884#a1884 <- how can I simplify it?
14:23:41 <paczesiowa> :t unzip
14:23:42 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:23:48 <mdmkolbe> Cheshire: given that I don't completely understand that link ("f", "a", "fa", "k", "z"?!), it looks like that link is a variation on the "Reloaded" paper, but probably not the variation that I am working on
14:23:58 <b_jonas> ImInYourMonad: with zip, yeah
14:24:25 <monochrom> unzip . filter p . zip ?
14:24:32 <Cheshire> mdmkolbe, have you seen Peter Morris's generic programming stuff?
14:24:37 <Cheshire> I wonder if it's like that.. or multirec?
14:25:11 <Cale> > unzip . filter (\(x,y) -> x /= 0 && y /= 0) $ zip [0,4,3,2,5] [1,4,0,3,0]
14:25:12 <lambdabot>   ([4,2],[4,3])
14:25:21 <b_jonas> > unzip (filter (\(x, y) -> 0 /= x && 0 /= y) (zip [0,4,3,2,5] [1,4,0,3,0]))
14:25:22 <lambdabot>   ([4,2],[4,3])
14:25:27 <b_jonas> yeah, that's the same
14:26:37 <paczesiowa> > unzip (filter (on (&&) (/=0)) (zip [0,4,3,2,5] [1,4,0,3,0]))
14:26:38 <lambdabot>   Couldn't match expected type `Bool'
14:26:49 <mdmkolbe> Cheshire: Wait until ICFP, then you can be the judge of that
14:26:53 * mdmkolbe crosses fingers
14:27:51 <paczesiowa> > unzip (filter (uncurry (on (&&) (/=0))) (zip [0,4,3,2,5] [1,4,0,3,0]))
14:27:52 <lambdabot>   ([4,2],[4,3])
14:28:29 <monochrom> There is some &&& or *** you can use.
14:29:21 <monochrom> More people should know arrows, at least for the pure function case. It's only natural.
14:30:20 <osfameron> if &&& and *** are the useful part of arrows, then they would be better described as "tupling functions" which sounds far less confusing :-)
14:30:34 <paczesiowa> @hoogle (Arrow a) => a b c -> a (b,b) (c,c)
14:30:34 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:30:34 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
14:30:34 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
14:30:57 <mauke> :t join (***)
14:30:58 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:31:03 <monochrom> Except there are two meanings of "tupling functions". Ambiguity is confusion.
14:31:11 <paczesiowa> mauke: gasp...
14:31:23 <mauke> hmm?
14:31:42 <ImInYourMonad> b_jonas: but for 100K 17K vectors isnt your version a lot slower or does laziness fix that?
14:31:59 <paczesiowa> :t join
14:32:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:32:36 <monochrom> I wonder why "join (***)" doesn't add a Monad context.
14:32:52 <mauke> on what?
14:32:56 <Gracenotes> it's the function monad...
14:32:59 <orbisvicis> hi, id like an account if only temporary to edit the xmonad faq on the haskell wiki
14:33:04 <Cheshire> :t join (***)
14:33:05 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:33:11 <monochrom> Oh!
14:33:14 <bolrod> hm.. why does randomIO give  a stack overflow after a while ;/
14:33:17 <Cheshire> :t join (,)
14:33:18 <lambdabot> forall a. a -> (a, a)
14:33:22 <orbisvicis> assuming, this is the right place
14:33:36 <Gracenotes> (s -> (s -> a)) -> (s -> a)
14:33:38 <mmorrow> @src (->) (>>=)
14:33:38 <lambdabot> f >>= k = \ r -> k (f r) r
14:33:40 <chessguy> orbisvicis:  IIRC, there's an xmonad mailing list
14:33:48 <Gracenotes> and *** is certainly (s -> s -> a)
14:34:03 <Gracenotes> can be :)
14:34:07 <orbisvicis> chessguy: really, id like to make this quick edit...
14:34:31 <chessguy> orbisvicis:  i'd love to oblige, but i don't have access, and i don't know who does
14:34:42 <chessguy> dons, sjanssen  ?
14:34:52 <mmorrow> @src join
14:34:52 <lambdabot> join x =  x >>= id
14:35:18 <mmorrow> @src (->) (>>=)
14:35:18 <lambdabot> f >>= k = \ r -> k (f r) r
14:35:45 <Gracenotes> @djinn (s -> s -> a) -> (s -> a)
14:35:45 <lambdabot> f a b = a b b
14:35:56 <aconbere> I'm trying to install parsec from cabal, but I get an error Could not find module `Data.ByteString.Char8'
14:36:01 <aconbere> not really sure what to do there
14:37:07 <dcoutts> aconbere: do you have bytestring registered? ghc-pkg list bytestring
14:37:29 <dcoutts> aconbere: if it's there in the per-user section then you may have deleted the files without unregistering it
14:38:15 <pumpkin_> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/StrictAnal.html o.O
14:39:01 <pumpkin_> surely there's a better name for that :)
14:39:15 <chessguy> @hoogle StrictAnal
14:39:15 <lambdabot> No results found
14:39:26 <paczesiowa> surely there's lazy version of it:)
14:39:31 * mmorrow dares chesssguy to @go that
14:39:35 <chessguy> haha
14:39:37 <pumpkin_> I think it stands for Strictness Analysis
14:39:39 <pumpkin_> :P
14:39:41 <pumpkin_> but still
14:39:48 <aconbere> dcoutts: so it finds two instances of it, on in my .ghc directory and on in a global file.
14:40:05 <pumpkin_> maybe someone had a sense of humor
14:40:08 <aconbere> how would I go about finding out if I mucked up the package?
14:40:08 <aconbere> :)
14:40:35 <dcoutts> acieroid: right. So you probably deleted the per-user one (eg rm -r ~/.cabal/lib).
14:40:41 <dcoutts> oops
14:40:44 <dcoutts> aconbere: ^^
14:40:47 <aconbere> dcoutts: it's probably true
14:40:58 <aconbere> I was having issues, and have little idea what I'm doing :)
14:41:08 <aconbere> (so why not delete some things eh?)
14:41:49 <dcoutts> aconbere: so if you did recently rm ~/.cabal/lib then you may also want to rm ~/.ghc so that they stay in sync. That will unregister all per-user registered packages for all versions of ghc you've got.
14:42:11 <dcoutts> aconbere: or less drastic, ghc-pkg unregister --user bytestring
14:42:24 <aconbere> yeah, but I may as well start clean :P
14:42:25 <bolrod> so.. is it a bug that randomIO gives a stack overflow?
14:42:38 <dcoutts> aconbere: aye
14:43:08 <mmorrow> bolrod: can you give a one-line example showing the context?
14:43:26 <bolrod> Prelude System.Random> do { x <-  sequence $ take 1000000 $ repeat (randomIO :: IO Integer); putStrLn ( show $head x)  }
14:43:30 <bolrod> 219220019
14:43:33 <bolrod> Prelude System.Random> do { x <-  sequence $ take 1000000 $ repeat (randomIO :: IO Integer); putStrLn ( show $head x)  }
14:43:35 <bolrod> *** Exception: stack overflow
14:43:35 <aconbere> dcoutts: ahh... things appear much happier now
14:43:37 <mmorrow> ah
14:43:41 <mmorrow> sequence's fault
14:43:56 <mmorrow> it's O(n) in stack
14:44:12 <bolrod> and it doesn't clean up after itself?
14:44:32 <mmorrow> sequence won't return anything until it's traversed the entire list
14:44:44 * wli isn't sure how to handle that.
14:44:50 <bolrod> yes.. but why would it work the first time.. and not the 2nd
14:44:59 <orbisvicis> well, i have to go... maybe ill edit the wiki later
14:45:01 <bolrod> besides
14:45:07 <bolrod> Prelude System.Random> randomIO
14:45:08 <bolrod> *** Exception: stack overflow
14:45:11 <bolrod> wont work anymore either
14:45:12 <mmorrow> oh, i just noticed you did the same thing twice
14:45:27 <mmorrow> ghc doesn't decrease the stack after it's grown it or some such
14:45:29 <bolrod> unless I restart ghci
14:45:44 <mmorrow> so yeah, i guess it's "not cleaning up" or something
14:45:47 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1885#a1886 <- how do I use System.Process ? I cant get it to work
14:46:03 <bolrod> but just using randomIO won't use much stack right?.. simple other operations do work
14:46:24 <bolrod> like
14:46:28 <mmorrow> bolrod: yeah, i would just use IO to get a StdGen
14:46:28 <dons> it's just slow, is all. use mersenne-random for speed
14:46:33 <mmorrow> then use randoms
14:46:48 <mmorrow> yeah, System.Random is pretty slow too
14:47:00 <bolrod> I was just trying some things.. and found this a bit odd
14:47:05 <bolrod> don't need it for anything
14:47:35 <ufear> hi guys
14:47:40 <ufear> somebody tried to help me out here earlier
14:47:55 <ufear> I want to check if string contains character not from a certain list
14:48:18 <ufear> so I have this code: validateBaseInput g (x:xs) = if any (not . (`elem` "0123456789")) [x] then False else True
14:48:34 <ufear> but it should check the whole list, and not just x
14:48:40 <ufear> but get errors then :<
14:48:42 <Spockz|servert> hmm, what was the command to set ghci in analyttics mode again? So you can see how many instructions and time it took to execute the command?
14:48:50 <cytzol> ufear: firstly, there's notElem
14:49:03 <Zao> Spockz|servert: Profiling?
14:49:10 <ufear> okay
14:49:13 <ImInYourMonad> isnt Parsec a library I can use from normal haskell-programs?
14:49:14 <paczesiowa> and if smth then False else True === not smth
14:49:30 <bolrod> but other then System.Random being slow.... is there any reason why it should give me a stack overflow?
14:49:39 <mmorrow> bolrod: i think what's happening is that stack isn't garbage collected like heap (or something). that's an interesting example, i wonder what the exact explanation is
14:49:42 <Spockz|servert> Zao: jup, that's it
14:49:42 <cytzol> ufear: now, you're only checking [x] instead of the whole list, so replace (x:xs) with xs and the [x] with xs too
14:49:57 <cytzol> ufear: do you understand why that works?
14:50:10 <Spockz|servert> Zao: but how do I activate it in GHCI?
14:50:16 <bolrod> mmorrow: other functions seem to work fine
14:50:21 <bolrod> like  sum [1..1000]
14:50:26 <bolrod> won't give me a stack overflow
14:50:28 <Zao> Using ghci to profile sounds odd.
14:50:45 <mmorrow> bolrod: but that doesn't leave stuff on the stack
14:50:45 <maxote> mmorrow, why allocate objects into stack and garbage them there?
14:50:45 <bolrod> but if I use just randomIO after it.. will give me a stack overflow again
14:50:48 <ufear> uhm I guess not cytzol, I tried using [x:xs], as that should put x back
14:50:50 <ufear> but that dident
14:50:53 <ufear> and you say this does? :P
14:50:58 <mmorrow> maxote: i don't know
14:51:01 <bolrod> mmorrow: any function that will?
14:51:02 <whpearson_> Are there any recursion functions for traversing potentially circular routes  but keeping a list of where you have been so you don't go back over the same route twice?
14:51:04 <Spockz|servert> Zao: there was an option you could set to see mem. usage and instructions count
14:51:09 <Zao> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
14:51:12 <pumpkin_> > sum [1..10000]
14:51:13 <lambdabot>   50005000
14:51:15 <pumpkin_> > sum [1..100000]
14:51:16 <lambdabot>   5000050000
14:51:17 <pumpkin_> > sum [1..1000000]
14:51:19 <lambdabot>   * Exception: stack overflow
14:51:29 <pumpkin_> > foldl' (+) 0 [1..1000000]
14:51:30 <lambdabot>   500000500000
14:51:44 <maxote> @src sum
14:51:44 <lambdabot> sum = foldl (+) 0
14:51:47 <cytzol> ufear: tell me if this doesn't make sense: when you used (x:xs), you put the head of the list in x and the tail in xs. Then later on, you just stuck them back together again.
14:51:49 <Zao> Spockz|servert: Are you actually referring to ghc or do you really want to profile inside the interactive interpreter?
14:52:01 <maxote> @src foldl
14:52:01 <lambdabot> foldl f z []     = z
14:52:01 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:52:04 <maxote> @src foldl'
14:52:04 <lambdabot> foldl' f a []     = a
14:52:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:52:06 <mmorrow> bolrod: so sum only uses stack when it evaluates the thunk it's built up, but sequence uses stack to actually arrive at its result
14:52:10 <ufear> ya sure it is not the most clean/effective way
14:52:15 <ufear> but it should work right?
14:52:35 <bolrod> mmorrow: and randomIO also uses a stack?
14:52:36 <cytzol> ufear: well, the syntax for joining lists together would be x : xs
14:52:50 <Spockz|servert> Zao: profile inside the interactive interpreter
14:52:53 <cytzol> if you used the []s, you'd have a list in a list
14:52:57 <cytzol> which is not what you want.
14:53:00 <ufear> hmz, fuck lol
14:53:02 <bolrod> and sum won't give me a stack overflow
14:53:03 <kryptiskt_> Spockz|servert: :set +s
14:53:09 <ufear> why dident GHC tell me that :<
14:53:16 <Spockz|servert> kryptiskt_: right!
14:53:25 <maxote> please, rename z by a for same var names
14:53:26 <cytzol> ufear: GHC's errors can be cryptic, sometimes
14:53:42 <mmorrow> bolrod: i don't believe so
14:53:46 <mmorrow> @src sequence
14:53:46 <lambdabot> sequence []     = return []
14:53:46 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:53:46 <lambdabot> --OR
14:53:46 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:53:54 <mmorrow> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:54:15 <bolrod> mmorrow: the thing is ... randomIO gives me a stack overflow
14:54:19 <Spockz|servert> kryptiskt_: and there is also a variant that tells the amount of executions were performed
14:54:20 <bolrod> even without sequence
14:54:22 <mmorrow> heh, i dunno then
14:54:26 <bolrod> @src randomIO
14:54:26 <lambdabot> Source not found. Maybe you made a typo?
14:54:41 <mmorrow> i never really use randomIO because
14:55:04 <maxote> mark them the sources that caused stack overflow, they will be candidates to be removed of any GHC runtime
14:55:05 <basvandijk> Hi guys (dons especially). Do you think this is a usefull thing to release: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1889 It exports a newtype DString which is just a ShowS but implemented using a DList. The reason it isn't just a type synonym is that I can then have a 'instance IsString DString' so I can use overloaded string literals.
14:55:06 <basvandijk>  
14:55:15 <mmorrow> i use mersenne-random or something in non-toy cases
14:55:20 <ufear> okay, thanks cytzol, I've got it figured out now! :)
14:55:21 <dons> basvandijk: what's the use ccccsae?
14:55:23 <mmorrow> for exactly this type of reason
14:55:25 <ufear> still in my first hours of using haskell :P
14:55:35 <cytzol> ufear: are you coming from another language?
14:55:39 <bolrod> me neither... this is the first time.. but still, it should be this weird.. ;p
14:55:52 <mmorrow> bolrod: yeah, it is weird :)
14:56:15 <ufear> well, I know php/java yes
14:56:19 <dons> basvandijk: i think it makes sense to release. so its basically ShowS redone in terms of DList?
14:56:24 <dons> and you have a use for it?
14:56:46 <basvandijk> dons: I'm writing a library for converting numbers into textual numerals: Forexample: 123 > "one hundered twenty three" I do a lot of strings appends in it and I think using a difference list is more efficient
14:57:19 <cytzol> ufear: well, then if you want you can replace "if (something) then False else True" with "not $ (something)", for the same reasons you would in those languages. It does the same thing, just a bit neater.
14:57:51 <bolrod> > sum [1..520175]
14:57:53 <lambdabot>   * Exception: stack overflow
14:57:55 <bolrod> > sum [1..520174]
14:57:57 <lambdabot>   * Exception: stack overflow
14:58:07 <bolrod> > sum [1..52017]
14:58:08 <lambdabot>   1352910153
14:58:10 <bolrod> > sum [1..520171]
14:58:11 <lambdabot>   * Exception: stack overflow
14:58:24 <ufear> hmm
14:58:31 <ufear> okay
14:58:35 <mmorrow> > foldl' (+) 0 [1..520171]
14:58:36 <lambdabot>   135289194706
14:58:36 <ufear> I'll get the whole thing working first
14:58:39 <ufear> and then clean it up after
14:58:44 <cytzol> ok
14:58:44 <ufear> as this is just a part of the problems :P
14:58:45 <bolrod> do { x <-  sequence $ take 100 $ repeat (randomIO :: IO Integer); putStrLn ( show $head x)  }
14:58:50 <mmorrow> sum really should use foldl' (imo)
14:58:51 <bolrod> > do { x <-  sequence $ take 100 $ repeat (randomIO :: IO Integer); putStrLn ( show $head x)  }
14:58:53 <lambdabot>   * Exception: "<IO ()>"
14:59:00 <ufear> rather have something that is near imperative so I can read it :P
14:59:06 <cytzol> heh
14:59:08 <bolrod> > randomIO ::IO Integer
14:59:09 <lambdabot>   * Exception: "<IO Integer>"
14:59:14 <bolrod> k
14:59:33 <mmorrow> yeah, no botIO allowed ;)
14:59:35 <Axman6> mmorrow: that or have a sum'
14:59:44 <paczesiowa> can someone explain to me the build function (or augment, I don't even know which one is simpler)?
14:59:56 <Axman6> :t build
14:59:57 <lambdabot> Not in scope: `build'
15:00:03 <paczesiowa> @src build
15:00:03 <lambdabot> build g = g (:) []
15:00:06 <mjb> Anyone have a idea when Haddock 2.4.2 will be released? The Haddock Trac has no due date set.
15:00:39 <ufear> another question cytzol
15:00:40 <Axman6> hmm, where is it again?
15:00:40 <Axman6> @hoogle build
15:00:40 <lambdabot> Distribution.Simple.Build build :: PackageDescription -> LocalBuildInfo -> BuildFlags -> [PPSuffixHandler] -> IO ()
15:00:40 <lambdabot> Distribution.Simple.GHC build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
15:00:40 <lambdabot> Distribution.Simple.Hugs build :: PackageDescription -> LocalBuildInfo -> Verbosity -> IO ()
15:00:43 <ufear> i'm doing like
15:00:47 <paczesiowa> GHC.Base
15:00:51 <mmorrow> GHC.Exts.build iirc
15:00:53 <paczesiowa> and it has rankN type
15:01:10 <ufear> where validChars = [1..g], where g is an int, and I need it to be a list of chars, rather than ints
15:01:12 <Axman6> :t GHC.Exts.build
15:01:13 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
15:01:31 <ufear> any way to force that?
15:01:39 <dons> basvandijk: if you think it is useful, i suggest releasing it!
15:01:44 <cytzol> > ['a' .. 'f']
15:01:46 <mmorrow> ufear: fmap chr
15:01:46 <lambdabot>   "abcdef"
15:01:53 <mmorrow> > fmap chr [0..]
15:01:55 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
15:02:02 <basvandijk> dons: ok I will. Thanks
15:02:07 <cytzol> ufear: You can make a list of chars like that... maybe you mean '0' instead of 0
15:02:09 <mmorrow> @type chr
15:02:10 <lambdabot> Int -> Char
15:02:11 <mmorrow> @type ord
15:02:11 <omnihil> fmap chr [48..]
15:02:12 <lambdabot> Char -> Int
15:02:18 <omnihil> > fmap chr [48..]
15:02:19 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
15:02:38 <yitz> > toEnum [48..] :: String
15:02:39 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
15:02:40 <Axman6> ^_`
15:02:53 <yitz> > map toEnum [48..] :: String
15:02:54 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
15:03:00 <bolrod> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1642#a1642
15:03:09 <bolrod> some random stuff in ghci...
15:03:17 <ufear> mm okay thanks
15:03:20 <paczesiowa> I have a version of mapAccumL that drops final accumulator value, and I want to fuse it with map, I think I know how new arg should look, but I have no idea how to use build with that
15:03:45 <mmorrow> bolrod: heh
15:03:51 <bolrod> mmorrow: do you have 6.10?.. and get the same?
15:04:14 <mmorrow> bolrod: if you do instead "sum' = foldl' (+) 0"  it's O(1) in stack
15:04:25 <Axman6> > GHC.Exts.build (\(*) end -> 1 * 2 * 3 * 4 * 5 end) (:) []
15:04:26 <bolrod> yeah I know..
15:04:26 <mmorrow> bolrod: yeah. i'll check
15:04:26 <lambdabot>       Inferred type is less polymorphic than expected
15:04:26 <lambdabot>        Quantified type ...
15:04:40 <mmorrow> bolrod: ah, i thought that sum' def was an oversight
15:04:43 <bolrod> but I wanted to see if it would also stack overflow after that randomIO went broked
15:04:51 <mmorrow> ah, i gotcha
15:05:00 <Axman6> > GHC.Exts.build (\(*) end -> 1 * (2 * (3 * (4 * (5 * end))))) (:) []
15:05:00 <lambdabot>   Couldn't match expected type `(a -> [a] -> [a]) -> [a1] -> t'
15:05:16 <Axman6> bah, i did know how to use it :\
15:06:23 <maxote> > let sum' = foldl' (+) 0
15:06:25 <lambdabot>   <no location info>: parse error on input `;'
15:06:36 <ImInYourMonad> anyone can show how to use System.Process.shell or proc ? I cant get it to work...
15:06:39 <maxote> > let sum' = foldl' (+) 0 ;
15:06:39 <lambdabot>   <no location info>: parse error on input `;'
15:06:54 <ImInYourMonad> also, is Parsec nt available from ghci? I have to run in some separate mode?
15:07:11 <paczesiowa> ImInYourMonad: it works in ghci
15:07:18 <mmorrow> bolrod: here's what i get on 6.10.1
15:07:19 <paczesiowa> ImInYourMonad: parsec is regular haskell
15:07:22 <mmorrow> bolrod: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1642#a1643
15:07:27 <dons> bos:     No instance for (Ord T.Text)
15:07:34 <dons> bos: can't put it into a Map?
15:07:37 <mmorrow> bolrod: slight difference, but not by much
15:08:06 <bolrod> mmorrow: I picked 520174 before because it was the highest number that didn't overflow before..
15:08:22 <bolrod> so in 6.10 it still goes cranky
15:08:30 <paczesiowa> > parse (char 'h' >> string "ello") "" "hello"
15:08:31 <lambdabot>   Not in scope: `parse'Not in scope: `string'
15:08:50 <paczesiowa> > parse (char 'h' >> Text.ParserCombinators.Parsec.string "ello") "" "hello"
15:08:51 <lambdabot>   Not in scope: `parse'
15:09:00 <cytzol> "ello"?
15:09:02 <mmorrow> bolrod: looks like the strictness analyzer got better in 6.10.1, or i just have a larger default stack size (OR iirc it's because 6.10.1 will grow the stack on-demand up to a given max size maybe)
15:09:02 <paczesiowa> > Text.ParserCombinators.Parsec.parse (Text.ParserCombinators.Parsec.char 'h' >> Text.ParserCombinators.Parsec.string "ello") "" "hello"
15:09:03 <lambdabot>   /tmp/1808346121523293371:70:32:
15:09:03 <lambdabot>      Not in scope: `Text.ParserCombinators....
15:09:32 <maxote> > let sum' = foldl' (+) 0 in sum' [1..520171]
15:09:33 <mmorrow> bolrod: but System.Random still pukes ;)
15:09:33 <lambdabot>   135289194706
15:09:40 <defun> :t liftM
15:09:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:09:46 <defun> :t fmap
15:09:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:09:48 <bolrod> would be interesting to see why randomIO is going crazy though
15:09:53 <cytzol> Has lambdabot really been through 1808346121523293370 lines of code before that one
15:09:57 <Axman6> paczesiowa: Text.Parsec no?
15:10:02 <mmorrow> bolrod: maybe look at the code
15:10:02 <bolrod> even though its probably a non issue.. and there are other random generators
15:10:18 <Axman6> :t Text.Parsec.parse
15:10:19 <lambdabot> Couldn't find qualified module.
15:10:20 <paczesiowa> > Text.Parsec.parse (Text.Parsec.char 'h' >> Text.Parsec.string "ello") "" "hello"
15:10:21 <lambdabot>       Failed to load interface for `Text.Parsec':
15:10:21 <lambdabot>        Use -v to see a list...
15:10:35 <defun> fmap == liftM
15:10:44 <cytzol> close!
15:10:50 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1891#a1891 <- can some comment on my "analysis" there?
15:11:02 <Gracenotes> paczesiowa: Right "ello"
15:11:24 <bos> dons: just an oversight
15:11:35 <bos> dons: i'd noticed it myself earlier this afternoon
15:11:55 <dons> bos: ah sweet. so there's an instance already handy?
15:12:04 <bos> nah, i'll have to write one.
15:12:06 * dons is doing a prelim review of Data.Text
15:12:16 <dons> oh, can you reuse the Ord ones floating around for bytestrings?
15:12:19 <dons> or is it harder
15:12:31 <bos> it's easy, just a matter of writing Ord over Stream
15:12:42 <dons> ah
15:13:09 <dons> i've not done that.
15:13:09 <bos> i think there's already a compare function written, now that i think of it
15:13:12 <dons> ok
15:13:17 <maxote> > let sum' = foldl' (+) 0 in sum' [1::Int..1000000000]
15:13:17 <lambdabot>   <no location info>: parse error on input `Int..'
15:13:24 <dons> -- | /O(n)/ 'compareBytes' provides an 'Ordering' for 'ByteStrings' supporting slices.
15:13:27 <dons> compareBytes :: ByteString -> ByteString -> Ordering
15:13:37 <maxote> > let sum' = foldl' (+) 0 in sum' [1..1000000000::Int]
15:13:44 <ufear> thanks guys, I figured out it all thanks to you, on to the next :D
15:13:46 <bolrod> mmorrow: -- Stability   :  stable
15:13:53 <lambdabot>   thread killed
15:13:58 <bolrod> on top of the Random.hs code
15:14:03 <bolrod> tis not THAT stable.. maybe
15:14:17 <Axman6> > (1000000000 * 1000000001) `div` 2
15:14:18 <lambdabot>   500000000500000000
15:15:01 <bos> dons: when i wrote the code for lazy stream and unstream, i was astounded that they worked immediately, first try. that doesn't often happen with complicated nested loops, even in haskell.
15:15:18 <dons> heh
15:15:30 <dons> streams are somehow easy to think about, i've found
15:15:37 <dons> very rarely do the implementations go wrong
15:15:48 <dons> breaking out the recursion is probably why: easier on the compiler, easier on the human
15:15:52 <bos> streams are, yes. but functions to pack lists of arrays from streams, not so much.
15:15:57 <dons> not so much
15:16:04 <ImInYourMonad> is (unzip . reverse) lazy?
15:16:14 <mauke> reverse can't be lazy
15:16:26 <paczesiowa> reverse [1..]
15:16:30 <ImInYourMonad> ok
15:16:31 <paczesiowa> > reverse [1..]
15:16:38 <dons> give it some time!
15:16:40 <bolrod> would it be worth to post to the haskell-libraries mailing list about randomIO ?
15:16:43 <maxote> @src reverse
15:16:45 <ImInYourMonad> is (unzip . filter p . zip) ?
15:16:49 <ImInYourMonad> is (unzip . filter p . zip) lazy?
15:16:53 <Axman6> > reverse [(1::Int8)..]
15:17:14 <lambdabot>   mueval: Prelude.read: no parse
15:17:14 <lambdabot> reverse = foldl (flip (:)) []
15:17:18 <lambdabot>   [127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,10...
15:17:20 <Axman6> chop chop!
15:17:21 <mmorrow> bolrod: heh, i think that means it's stable in its instability
15:17:21 <tromp_> > reverse [0..] :: [Word8]
15:17:22 <lambdabot>   [255,254,253,252,251,250,249,248,247,246,245,244,243,242,241,240,239,238,23...
15:17:24 <Axman6> thank you
15:17:42 <maxote> > reverse (reverse [1..])
15:17:57 <lambdabot>   mueval: Prelude.read: no parse
15:18:08 <Axman6> i should really be learning two's complement numbering... but it's not that hard (and it's genius)
15:19:14 <maxote> > reverse (reverse [(1::Int8)..])
15:19:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:19:24 <Axman6> floating point is probably more of an issue actually...
15:19:27 <maxote> > reverse (reverse [(1::Int)..])
15:19:40 <lambdabot>   mueval: Prelude.read: no parse
15:20:02 <bolrod> mmorrow: so... should I make a post to haskell-libraries?.. or is nobody going to bother.. or will it start some flame about how bad the library is
15:20:13 <maxote> the optimizer is bad
15:20:17 <dons> bos: "And special thanks to you Don and your co-authors, your book saved my neck,
15:20:19 <mmorrow> bolrod: do it!
15:20:20 <dons> with its help I was actually able to develop the application in an entirely new
15:20:20 <dons> is that good or bad....
15:20:22 <dons> to me language and with a mere 3 months past deadline"
15:20:44 <bolrod> mmorrow: I'll just link to my paste and the one you made .. :)
15:21:23 <bolrod> oh.. you posted it below mine.. nvm :p
15:22:34 <dons> Axman6: we might just catch ATS yet, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
15:22:46 <mmorrow> bolrod: cool
15:22:49 <Axman6> hooray :)
15:23:02 <Axman6> dons: be sure to show blackh too :D
15:23:11 <mperillo> from ByteString.Lazy.Char8 documentation: As of bytestring 0.9.0.3, this function is stricter than its list cousin
15:23:14 <Axman6> damn, we're doing well
15:23:20 <mperillo> what does it mean?
15:23:31 <Axman6> need 6.10.2 to make pidigits fast again
15:23:32 <mperillo> the function is lines
15:23:45 <ImInYourMonad> so...anyone can show use of System.Process?
15:25:04 <Raynes> In your monad. Runnin' your state.
15:25:30 <tibbe> dons: have you had time to look at the little code snippet I sent you?
15:25:38 <Axman6> dons: hmm, looks like binary trees needs to be faster before we can beat ATS
15:25:40 <skorpan> yo dawg we herd u like monads so we put a monad in your monad so you can lift while you lift..
15:25:54 <pumpkin_> ImInYourMonad: it's a module, what functions are you interested in?
15:26:01 <dons> tibbe: not yet.
15:26:17 <monochrom> ...
15:26:20 <dons> crazy busy week, just catching up now
15:26:27 <cytzol> Is there a simpler way to say "do { a <- getA; a }"?
15:26:29 <tibbe> dons: no worries
15:26:44 <Axman6> cytzol: getA
15:26:49 <Axman6> wait, no
15:26:49 <paczesiowa> cytzol: join getA
15:26:50 <cytzol> that's return
15:26:52 <pumpkin_> join getA
15:26:54 * dons tries swapping a new evil mangler for an old one. 
15:26:56 <dons> stand back!
15:26:59 <cytzol> :t join
15:27:02 <Axman6> now
15:27:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:27:08 <cytzol> gah I didn't stand back in time
15:27:11 <Axman6> @undo do { a <- getA; a }
15:27:11 <lambdabot> getA >>= \ a -> a
15:27:18 <pumpkin_> @. pl undo do { a <- getA; a }
15:27:18 <lambdabot> join getA
15:27:26 <Axman6> which is indeed join getA
15:27:38 <cytzol> Why is join called join, then?
15:27:47 <pumpkin_> > join [[1,2], [3,4]]
15:27:48 <cytzol> It works, but I'm not joining anything
15:27:48 <Axman6> :t join
15:27:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:27:50 <lambdabot>   [1,2,3,4]
15:27:52 <monochrom> join is a generalization of concat.
15:27:58 <cytzol> ah, ok.
15:28:07 <Axman6> > join (^) 3
15:28:08 <lambdabot>   27
15:28:12 <Axman6> > join (^) 4
15:28:13 <lambdabot>   256
15:28:17 <Axman6> > join (^) 8
15:28:18 <lambdabot>   16777216
15:28:26 <Axman6> > join (^) 64
15:28:27 <lambdabot>   394020061963944792122790401001436138050797392704654466679482934042457217714...
15:28:28 <pumpkin_> lol
15:28:30 <cytzol> I seee
15:28:30 <Axman6> >_>
15:28:32 <bos> dons: I'm all in favour of intact necks, rather than the severed kind
15:28:39 <idnar> > join join
15:28:40 <lambdabot>       Occurs check: cannot construct the infinite type:
15:28:40 <lambdabot>        m = (->) (m (m...
15:28:42 <paczesiowa> > build (\ (*) end -> 1*(2*end))
15:28:42 <lambdabot>   Not in scope: `build'
15:28:44 <monochrom> join is also a generalization of something else, and you could name it by that something else.
15:28:48 <dons> wow.
15:28:49 <paczesiowa> > GHC.Base.build (\ (*) end -> 1*(2*end))
15:28:50 <lambdabot>   /tmp/8798073227296848726:70:40: Not in scope: `GHC.Base.build'
15:28:56 <pumpkin_> dons: what does the evil one do?
15:28:57 <dons> swapping in a new mangler gives me a working 6.6.1
15:29:01 <paczesiowa> > GHC.Exts.build (\ (*) end -> 1*(2*end))
15:29:02 <lambdabot>   /tmp/2128861011525840:70:40: Not in scope: `GHC.Exts.build'
15:29:05 <ImInYourMonad> i got it working, runCommand is what I wanted.
15:29:06 <dons> now i can do some regression tests on bytestring :)
15:29:11 <pumpkin_> dons: I was just fooling around with the 6.6.1 mangler too :o
15:29:12 <Axman6> , typ "build"
15:29:21 <ImInYourMonad> man haskell can really do anything, im starting to thinkw hen lambdabot says:
15:29:25 * pumpkin_ feels closer to l33tness
15:29:26 <dons> well, you can drop in the 6.8.2 one without harm, it seems....
15:29:28 <idnar> monochrom: what would that be?
15:29:28 <dons> at least, so far...
15:29:29 <lunabot>  luna: Not in scope: `build'
15:29:34 <ImInYourMonad> @faq can Haskell get you laid with Jessica Alba?
15:29:34 <lambdabot> The answer is: Yes! Haskell can do that.
15:29:35 <Axman6> lame
15:29:38 <ImInYourMonad> he speaks the truth
15:29:40 <dons> rocking.
15:29:41 <paczesiowa> Axman6: it works in my ghci
15:29:41 <Axman6> , typ "GHC.Exts.build"
15:29:44 <lunabot>  luna: Not in scope: `GHC.Exts.build'
15:29:50 <Axman6> paczesiowa: good :)
15:29:56 <dons> bos: you know the classic Map-based 'word counting' benchmark, that had Ord funkiness
15:29:59 <pumpkin_> , [$ty| GHC.Exts.build |]
15:30:03 <lunabot>  luna: Exception when trying to run compile-time code:
15:30:06 <pumpkin_> , [$ty| 'GHC.Exts.build |]
15:30:06 <dons> seems to be doubling in speed 6.6.1 -> 6.8.2 -> 6.10.2 :)
15:30:08 <lunabot>  luna: Exception when trying to run compile-time code:
15:30:11 <paczesiowa> Axman6: still, I have no idea how to (f)use it
15:31:12 <dons> 6.6 : 1.739, 6.8 : 1.560, 6.10: 0.350
15:31:16 <Axman6> paczesiowa: i think the way it works is you build up a function, which you keep modifying until you finally run build on it, which turns it into a list... probably wrong though
15:32:01 <pumpkin_> wow
15:32:14 <pumpkin_> that was guite a jump to 6.10
15:32:21 <paczesiowa> Axman6: it's all easy, until you have to type it in:>
15:32:45 <paczesiowa> Axman6: or not
15:33:10 <paczesiowa> Axman6: it seems kinda stupid (which of course means that I'm stupid)
15:33:11 <bos> dons: Ord funkiness with bytestrings?
15:33:40 <paczesiowa> Axman6: maybe it is double continuation passing style?
15:33:56 <dons> i think we fixed that, which put it around 0.9 - 1.0s iirc.
15:34:05 <dons> the 0.35 i've not seen before
15:34:17 <bos> ah
15:34:20 <bolrod> mmorrow: posted
15:34:20 <dons> anyway, that's probably it though
15:34:26 <dons> ghc 6.10 getting to work
15:34:39 <dons> i'll try the full bytestring regression suite now
15:34:41 * bos `ap` kiddie birthday party
15:35:06 <dons> ciao
15:35:32 * tibbe `ap` his own bday
15:35:34 <monochrom> Pick a specific monad you love. It has something satisfying the join laws. You can use the name for that. Example: for IO it executes to find out what is to be executed, you could call it dereference.
15:35:49 <ImInYourMonad> anyone know of any topology videos?
15:36:23 <monochrom> And lambdabot is a she.
15:36:29 <Olathe> > zipWith subtract `ap` init $ [1..10]
15:36:30 <lambdabot>   [0,0,0,0,0,0,0,0,0]
15:36:48 <skorpan> :t ap
15:36:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:37:12 <skorpan> okay, i don't get it.
15:37:18 <skorpan> :t subtract
15:37:19 <lambdabot> forall a. (Num a) => a -> a -> a
15:37:22 <Olathe> Heheh
15:37:24 <skorpan> :t zipWith
15:37:25 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:37:28 <Olathe> > zipWith subtract `ap` tail $ [1..10]
15:37:30 <lambdabot>   [1,1,1,1,1,1,1,1,1]
15:37:48 <skorpan> is the list the monad for `ap' here?
15:37:55 <Olathe> > let deltas = zipWith subtract `ap` tail in deltas [1..10]
15:37:56 <lambdabot>   [1,1,1,1,1,1,1,1,1]
15:37:59 <Olathe> @type ap
15:38:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:38:17 <Spockz|servert> Is there a way to print functions? So to show the 'source' of (generated) functions?
15:38:24 <mauke> Spockz|servert: no
15:38:33 <skorpan> reflection^2
15:38:43 <Olathe> Spockz|servert: If you want to see the compiler's intermediate results, you can with ghc, but not at runtime.
15:39:03 <Spockz|servert> Olathe: ok. Thanks :)
15:39:11 <Olathe> You could probably do something suitably evil with TH.
15:39:14 <whpearson_> @hoogle (monad m) => (a -> m a) -> a -> m a
15:39:15 <lambdabot> Did you mean: Monad m => a -> m a -> a -> m a /count=20
15:39:15 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
15:39:15 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
15:39:21 <Olathe> Not sure, though.
15:39:42 <Spockz|servert> Olathe: what's TH?
15:39:42 <Olathe> @hoogle Monad m => a -> m a -> a -> m a /count=20
15:39:42 <lambdabot> Data.Sequence update :: Int -> a -> Seq a -> Seq a
15:39:42 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
15:39:42 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
15:40:07 <Olathe> Spockz|servert: It's Template Haskell.
15:40:12 <whpearson_> @instances Data
15:40:12 <lambdabot> Couldn't find class `Data'. Try @instances-importing
15:40:50 <Spockz|servert> Olathe: ah yes I heard someone about that the other day :)
15:41:14 <monochrom> If there is a Shootout slot for "how fast can you print yourself to stdout" it may encourage people to add it.
15:41:51 <paczesiowa> EOF
15:43:18 <Spockz|servert> Hmm, lamdabot doesn't take cookies for it's hard work. :)
15:43:22 * Olathe closes paczesiowa
15:43:39 <Olathe> @botsnack
15:43:39 <lambdabot> :)
15:43:39 <lunabot>  :)
15:43:51 <bolrod> omg.. 1 snack  2 bots!
15:43:57 <Spockz|servert> botfight!
15:45:30 <bolrod> > concat.repeat $ "nom"
15:45:31 <lambdabot>   "nomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomno...
15:45:46 <mauke> > cycle "nom"
15:45:47 <lambdabot>   "nomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomno...
15:46:12 <Spockz|servert> >cycle "mom"
15:46:19 <bolrod> noo
15:46:21 <Spockz|servert> > cycle "mom"
15:46:22 <lambdabot>   "mommommommommommommommommommommommommommommommommommommommommommommommommo...
15:46:49 <Gracenotes> 'o':'m':
15:46:56 <Olathe> "g"
15:47:07 <Mr_Awesome> haha
15:47:16 <gnuvince_> > let nom = "nom"++nom in nom
15:47:17 <lambdabot>   "nomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomno...
15:47:18 <Gracenotes> ++" guys"
15:47:25 <mauke> @src cycle
15:47:25 <lambdabot> cycle [] = undefined
15:47:25 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:47:47 <maxote> @src sequence
15:47:47 <lambdabot> sequence []     = return []
15:47:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:47:47 <lambdabot> --OR
15:47:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:47:56 <hotaru2k3> > fix ("nom"++)
15:48:00 <newsham> > "omm " ++ cycle "nom "
15:48:05 <lambdabot>   "nomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomno...
15:48:07 <lambdabot>   "omm nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom no...
15:48:20 <bolrod> what have I done..
15:48:21 <Spockz|servert> poor lamdabot
15:48:32 <Japsu> > tail . fix $ ("nom"++)
15:48:33 <lambdabot>   "omnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnom...
15:48:45 <maxote> > sequence [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5]
15:48:46 <lambdabot>       No instance for (Show (m [a]))
15:48:46 <lambdabot>        arising from a use of `show' at <...
15:49:06 <Olathe> @type sequence
15:49:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:49:16 <maxote> > sequence $ [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5]
15:49:17 <lambdabot>       No instance for (Show (m [a]))
15:49:17 <lambdabot>        arising from a use of `show' at <...
15:49:36 <Olathe> > sequence . map (:[]) $ [1..10]
15:49:38 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
15:49:44 <Olathe> > map (:[]) $ [1..10]
15:49:45 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
15:49:47 <mauke> > sequence ["ab", "cde"]
15:49:48 <lambdabot>   ["ac","ad","ae","bc","bd","be"]
15:50:21 <bolrod> > let {n = 'n' : o; o='o':m ; m='m':n} in n
15:50:23 <lambdabot>   "nomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomno...
15:50:35 <maxote> > sequence ["a","b","c","d","a","b","c","d","a","b","c","d"]
15:50:37 <lambdabot>   ["abcdabcdabcd"]
15:50:48 <Olathe> > cycle "omn"
15:50:49 <lambdabot>   "omnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnom...
15:50:59 <Japsu> ahah
15:51:09 <maxote> > sequence [(cycle "god")]
15:51:11 <lambdabot>   ["g","o","d","g","o","d","g","o","d","g","o","d","g","o","d","g","o","d","g...
15:51:35 <Gracenotes> > let (n, o, m) = ('n':o, 'o':m, 'm':n) in n -- another way of doing it
15:51:36 <lambdabot>   "nomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomno...
15:51:38 <hotaru2k3> @ty (uncurry(&&&).(($)***($)))
15:51:39 <lambdabot> forall b a b1. (a -> b, a -> b1) -> a -> (b, b1)
15:51:43 <Gracenotes> based on bolrod's
15:51:46 <Olathe> Is there a shortcut for \n -> concat . replicate n ?
15:52:04 <Cheshire> short cut ?
15:52:11 <Olathe> Like a function that does that.
15:52:13 <mauke> I don't think so
15:52:18 <Olathe> Alright, thanks.
15:52:24 <bolrod> let shortcut = concat . replicate in shortcut 10 "ha'
15:52:30 <bolrod> > let shortcut = concat . replicate in shortcut 10 "ha"
15:52:31 <lambdabot>   Couldn't match expected type `[[a]]'
15:52:33 <mauke> (concat .) . replicate
15:52:35 <bolrod> hm
15:52:43 <Olathe> > let shortcut = (concat.) . replicate in shortcut 10 "ha"
15:52:44 <lambdabot>   "hahahahahahahahahaha"
15:52:47 <ImInYourMonad> Pos y -> PosDistance (let (ts,ys) = sharedFeatures test y in f ts ys) , why does thta give intendation error?
15:52:54 <Gracenotes> > sequence . (replicate =<< length) $ "nom"
15:52:55 <lambdabot>   ["nnn","nno","nnm","non","noo","nom","nmn","nmo","nmm","onn","ono","onm","o...
15:53:03 <Cheshire> I prefer shortcut n = concat . replicate n
15:53:07 <mauke> ImInYourMonad: probably because it's indented wrong
15:54:55 <bolrod> > let nom = "nom":[] ++ nom in concat nom
15:54:56 <lambdabot>   "nomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomnomno...
15:56:39 <manveru> heya, i'm just trying to build yi... i'm not really familiar with how cabal works, but it tells me that yi depends on 'binary-0.4.4' and 'binary-0.5' at the same time and that it might cause problems
15:57:07 <defun> Would it be safe to say, from a mathematical point of view, that applicative functors are subsets of monads?
15:57:27 <Gracenotes> > concat $ zipWith (:) (repeat '0') (repeat "1")
15:57:28 <pumpkin_> supersets?
15:57:29 <lambdabot>   "01010101010101010101010101010101010101010101010101010101010101010101010101...
15:57:34 <pumpkin_> or the requirements on them are subsets?
15:57:37 <lilac> defun: they're a subcategory
15:57:45 <lilac> or something
15:57:46 <mauke> fmap = liftM, pure = return, (<*>) = ap
15:57:50 <manveru> this is for yi-0.5.3 from darcs
15:58:20 <lilac> defun: there exists an epic forgetful functor from monads to applicatives
15:58:21 <pumpkin_> it's manveru!
15:58:46 <Cheshire> defun, no
15:58:55 <defun> ok.
15:59:01 <manveru> pumpkin_: orly?
16:01:49 <adamvo> manveru: you won't have issues if you manage to rebuild whatever depends on 0.4.4
16:02:42 <manveru> adamvo: the thing that depends on 0.4.4 is what i'm try to build :)
16:03:48 <defun> :t mdo
16:03:49 <lambdabot> Empty 'do' construct
16:04:49 <idnar> mdo is a keyword, not a function
16:04:56 <Gracenotes> mdo, eeevviiiill. Eeeevvviiiilll!!!
16:05:04 <idnar> it desugars into mfix
16:06:05 <mdmkolbe> Is there a way to use type families to calculate the result type of a function type? (e.g. FunResult (a -> b -> c) ~ c)
16:07:16 <mdmkolbe> The obvious solution produces a "conflicting instance declaration" error: type family FunResult a; type instance FunResult (a -> b) = FunResult b; type instance FunResult b = b
16:08:22 <ImInYourMonad> *RunKNN> C stack overflow in generated code <- wtf!? is that a normal stack overflow problem or something else?
16:09:20 <dons> ghci doing something weird, perhaps
16:09:24 <dons> try compiling it.
16:09:30 <dons> and don't forget to use -O2
16:10:10 <koeien> why are finite fields such a pain to model in Haskell? I can't find a package on hackage :(
16:10:20 <defun> :t foldr
16:10:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:10:44 <defun> :t foldl
16:10:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:11:40 <dons> koeien: galois fields? people just use lists, arrays et al?
16:14:23 <defun> :t map
16:14:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:14:30 <defun> :t fmap
16:14:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:14:48 <ddarius> newtype F p = F Integer; instance Modulo p => Num (F p) where F a + F b = F (a + b `mod` modulus)
16:15:43 <koeien> dons: yeah
16:15:54 <koeien> dons: i implemented GF(32) myself today :)
16:17:12 <pumpkin_> using a Word32? :P
16:17:18 <pumpkin_> oh
16:17:26 <defun> :t <|>
16:17:27 <lambdabot> parse error on input `<|>'
16:17:37 <defun> :t mplus
16:17:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:17:40 <hydrapheetz> :t (<|>)
16:17:41 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
16:17:52 <koeien> pumpkin_: no, it was not efficient, just used lists of Ints
16:18:14 <ImInYourMonad> if a function has the type a :: [Int] -> [Int] -> ([Int], [Int]) and another b :: [Int] -> [Int] -> Double , how can I directly do b (a args)? and not let (x,y) = a args in b x y ?
16:18:32 <pumpkin_> uncurry
16:18:40 <pumpkin_> :t uncurry
16:18:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:18:46 <koeien> ImInYourMonad: use uncurry
16:19:16 <idnar> @type let a = undefined :: [Int] -> [Int] -> ([Int], [Int]); b = undefined :: [Int] -> [Int] -> Double in b . uncurry a
16:19:17 <lambdabot>     Couldn't match expected type `[Int]'
16:19:17 <lambdabot>            against inferred type `([Int], [Int])'
16:19:17 <lambdabot>       Expected type: ([Int], [Int]) -> [Int]
16:19:33 <idnar> @type let a = undefined :: [Int] -> [Int] -> ([Int], [Int]); b = undefined :: [Int] -> [Int] -> Double in a . uncurry b
16:19:34 <lambdabot>     Couldn't match expected type `[Int]' against inferred type `Double'
16:19:34 <lambdabot>       Expected type: ([Int], [Int]) -> [Int]
16:19:34 <lambdabot>       Inferred type: ([Int], [Int]) -> Double
16:19:54 <idnar> man, what the heck am I doing
16:20:06 <ImInYourMonad> i see
16:20:36 <idnar> @type let a = undefined :: [Int] -> [Int] -> ([Int], [Int]); b = undefined :: [Int] -> [Int] -> Double in uncurry b (a ?foo ?bar)
16:20:37 <lambdabot> (?bar::[Int], ?foo::[Int]) => Double
16:22:40 <Gracenotes> what extension is ?extypes ...?
16:22:54 <Gracenotes> which
16:23:31 <mauke> implicit parameters
16:23:42 <skorpan> :t curry
16:23:43 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:24:10 <idnar> that's a very expressive type :)
16:24:16 <Gracenotes> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
16:24:22 <mauke> @. djinn type curry
16:24:23 <lambdabot> f a b c = a (b, c)
16:24:32 <Gracenotes> mhmhmmhmhmmmmm
16:24:49 <skorpan> @pl \(x, y) -> f x y
16:24:50 <lambdabot> uncurry f
16:24:56 <skorpan> darn this bot is clever
16:24:57 <Olathe> @type let f a b c = a (b, c)
16:24:58 <lambdabot> <no location info>: not an expression: `let f a b c = a (b, c)'
16:25:01 <Olathe> @type let f a b c = a (b, c) in f
16:25:02 <lambdabot> forall t t1 t2. ((t, t1) -> t2) -> t -> t1 -> t2
16:25:11 <Gracenotes> implicit parameters is nice. Given that I often use explicit parameters to determine types
16:25:43 <idnar> I have yet to actually write any code using implicit parameters
16:25:46 <idnar> I just use it for @type fun :)
16:25:47 <Olathe> @src curry
16:25:47 <lambdabot> curry f x y = f (x, y)
16:25:50 <Olathe> zomg
16:26:19 <idnar> @. djinn type uncurry
16:26:20 <lambdabot> f a (b, c) = a b c
16:26:24 <skorpan> how does lambdabot do all of this? alpha-conversion and then a simple lookup?
16:26:44 <idnar> @src uncurry
16:26:44 <lambdabot> uncurry f p = f (fst p) (snd p)
16:26:52 <skorpan> not that one, the @pl stuff
16:26:52 <idnar> hmm
16:26:54 <ddarius> skorpan: @pl is a compiler, @djinn is a theorem prover.
16:27:03 <ImInYourMonad> how do I check if == NaN?
16:27:06 <Olathe> It really has that as the source ?
16:27:07 <idnar> I guess that definition of uncurry is a little lazier
16:27:12 <mauke> :t isNaN
16:27:13 <lambdabot> forall a. (RealFloat a) => a -> Bool
16:27:19 <idnar> who knows if it's the real definition, though :P
16:27:34 <ddarius> Olathe: Perhaps, uncurry f ~(x,y) = f x y is a bit nicer and equivalent.
16:27:47 <Gracenotes> it's in the RealFloat typeclass
16:27:58 <Gracenotes> NaN isn't, amusingly
16:28:08 <Gracenotes> although blah blah (0/0) blah blah
16:28:09 <ddarius> :t isIEEE
16:28:10 <idnar> :t NaN
16:28:10 <lambdabot> forall a. (RealFloat a) => a -> Bool
16:28:11 <lambdabot> Not in scope: data constructor `NaN'
16:28:18 <ddarius> Gracenotes: NaN doesn't have to exist
16:28:20 <ImInYourMonad> hmm slowly im groking monads, i felt a small lightbulb beung turned on. just like the IO monad follows dirty actions around I could have the same for other stuff.
16:28:45 <Gracenotes> ddarius: some languages do provide constants. Not to say they have to.
16:29:14 <idnar> if NaN doesn't exist, what does 0/0 give you?
16:29:16 <ddarius> Gracenotes: Haskell doesn't require Float/Double/any instance of RealFloat to be IEEE floating point numbers
16:29:22 <bolrod> nullity!
16:30:00 <Gracenotes> hm. Don't know of any other instances, but sure
16:30:50 <knubbli__> heyho
16:30:51 <pumpkin_> ImInYourMonad: follows dirty actions around?
16:31:09 <knubbli__> check this out : http://www.laura-jung.de.vu/index.php?id=9cb11b lol
16:31:33 <mauke> spam.
16:31:40 <Gracenotes> main = forever watchFromCeiling
16:31:42 <idnar> heh, a new one
16:31:44 <pumpkin_> @where ops
16:31:44 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
16:32:02 <mauke> pumpkin_: it's unlikely that he will return
16:32:21 <idnar> Gracenotes: ceilingCat?
16:33:17 <Gracenotes> following dirty actions around
16:33:26 <idnar> heehee
16:33:45 <idnar> heehee
16:33:47 <idnar> unsafePerformVoyeurism
16:34:47 <glguy> There’s nothing for us to do if the spammer has already left :-p
16:35:08 <idnar> glguy: what, you don't have time machine access?
16:35:19 <glguy> well, if you all give me root access
16:35:26 <glguy> and I set up a system to clear your screen of the spam
16:35:27 <idnar> IRC needs a /balefire command
16:35:36 <mauke> I gave him http://pix.jj.am/gallery/main.php
16:35:55 <Gracenotes> the only natural conclusion to this line of thinking is the stabbing-in-the-face-over-the-internet machine
16:36:17 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/prayer.gif
16:36:24 <Gracenotes> unsafeStabInFace
16:37:06 <ImInYourMonad> which do you prefer ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1899#a1899
16:37:24 <chessguy> haha
16:37:41 <glguy> ImInYourMonad, #2
16:37:43 <idnar> unsafeDeploySwordfish
16:41:16 <Axman6> ImInYourMonad: how long have you been using haskell btw?
16:42:36 <chessguy> another vote for #2
16:43:20 <knubbli__> check this out http://tinyurl.com/rolfxd lol
16:43:26 <edwardk> the only problem is once you have someone in your monad you can't get them out.
16:43:34 <chessguy> edwardk:  :)
16:43:42 <chessguy> edwardk:  depends on the monad !
16:43:46 <edwardk> true
16:44:05 <glguy> bah
16:44:05 <edwardk> but ImInYourComonad makes it easy. ;)
16:44:07 --- mode: ChanServ set +o glguy
16:44:16 --- mode: glguy set +b *!*@d83-181-37-120.cust.tele2.at
16:44:25 --- mode: glguy set -o glguy
16:44:30 <glguy> go figure he'd be persistent
16:44:34 <Axman6> cheers glguy
16:44:48 <mauke> what an idiot
16:46:09 <ImInYourMonad> Axman6: why? tried it a few times before , like 6months ago the first time but every now and then and a lot lately(especially last week). im in highschool so learning by myself. why? I code like shit ? :(
16:46:40 <ImInYourMonad> mauke: who?
16:46:53 <pumpkin_> ImInYourMonad: the spammer
16:46:57 <edwardk> ImInYourMonad: I think he meant the spammer
16:47:02 <Axman6> no, just finding your progress to be quite different to how most people progress
16:47:24 <pumpkin_> how do most people progress?
16:47:40 <pumpkin_> I can't say I feel too conventional
16:47:52 <Axman6> me either
16:48:03 <Axman6> ImInYourMonad: were you CTA before?
16:48:18 <whpearson_> Have I just reinvented the wheel, if so which wheel  ->http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1902#a1902. Also it could do with prettying up some.
16:49:29 <Cale> :t listToMaybe
16:49:30 <lambdabot> forall a. [a] -> Maybe a
16:49:56 <ImInYourMonad> CTA: no
16:50:00 <Cale> er...
16:50:03 * Axman6 throws a FunctionNameTooLong exception
16:50:07 <koeien> whpearson_: a style issues, it's not useful nor pretty to put parens around 'a' when it's not necessary
16:50:13 <Cale> :t catMaybes
16:50:14 <lambdabot> forall a. [Maybe a] -> [a]
16:50:18 <koeien> e.g. Eq (a) or Set (a)
16:50:22 <ImInYourMonad> Axman6: how am I different?
16:50:24 <idnar> FunctionNameLongerThanDefinition
16:50:32 <koeien> whpearson_: just replace it by Eq a and Set a
16:50:32 <Cale> :t \f xs -> listToMaybe . catMaybes . map f
16:50:33 <lambdabot> forall t a a1. (a1 -> Maybe a) -> t -> [a1] -> Maybe a
16:50:42 <Cale> :t \f -> listToMaybe . catMaybes . map f
16:50:43 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> Maybe a
16:51:01 <Axman6> FunctionNameIsMoreExpressiveThanFunctionCodeException
16:51:11 <whpearson_> koeien: Err. Yup those were from before I made it generic.
16:51:16 <Cale> whpearson_: ^^
16:51:28 <koeien> whpearson_: also, look for 'listToMaybe'
16:51:31 * ddarius has an entire file where every function definition has a type longer than it.
16:51:34 <koeien> ah Cale gave the suggestion already
16:51:36 <Cale> whpearson_: Also, your layout for if/then/else is strange
16:51:40 <Cale> if foo
16:51:42 <Cale>    then bar
16:51:45 <Cale>    else quux
16:51:51 <Cale> Or:
16:51:54 <Cale> if foo then bar
16:51:59 <Cale>        else quux
16:52:17 <Cale> The 'then' and 'else' ought to line up.
16:52:30 <Axman6> like a case statement
16:52:39 <Axman6> which i guess an if statement basically is
16:52:42 <Cale> expression ;)
16:53:21 <whpearson_> Cale: Thanks, better to nip bad habits in the bud early
16:53:47 <ddarius> mauke: I have thought about setting up a service for that.
16:54:11 <Axman6> on a totally unrelated note, anyone know what glassfish actually is? there's no about page that i can find, and i'm rather confused...
16:54:13 <Cale> Yeah, that layout you're using won't work inside of a do-block, because the 'else' will be in a separate statement then, and it'll become a syntax error.
16:54:36 * Axman6 wikipedia's it
16:55:31 <cognominal> what is the diff between STM vars and MVars from COntrol.Concurrent?
16:55:52 <cognominal> or are they the same thing?
16:55:53 <Axman6> you can use STM vars atomically
16:56:14 <Cale> cognominal: STM variables can only be accessed inside STM transactions. STM transactions happen as-if-atomically.
16:56:33 <Axman6> so, you can take $10,000 from one stm var, and put it into another, without anyone else being able to see when when is missing the $10,000, but the second doesn't have it
16:56:56 <Axman6> when one*
16:56:57 <cognominal> I guess I know what are STM vars, but Mvars are knew to me
16:57:02 <Cale> Also, TVars can't be empty, iirc
16:57:02 <mauke> cognominal: TVars are like thread-safe IORefs
16:57:28 <Cale> Though there are TMVars which are similar.
16:57:30 <maxote> @src dfs
16:57:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:57:43 <mauke> cognominal: MVars block all the time and can be empty or full
16:57:57 <mauke> TMVars are MVars implemented in STM using TVars
16:57:58 <Axman6> if you try and take from an empty MVar, then your thread will block until another thread puts something into it
16:58:00 <cognominal> boy, now TVars..
16:58:14 <Cale> cognominal: TVars are what you call STM variables.
16:58:22 <Cale> (transactional variables)
16:58:29 <cognominal> ok
16:59:20 <Axman6> from what i can tell, MVars are like using mutexes in C (but faster according to Igloo)
17:00:32 <cognominal> I am trying to make sense of the yi sources but there are so many libraries that I need to learn...
17:00:50 <mmorrow> cognominal: MVar and TVar are the only two that are rts primitives
17:01:03 <mmorrow> everything else is made from a combo of those
17:01:14 <mdmkolbe> What adjictive would you use to describe things that can occur in a haskell pattern?
17:01:31 <mdmkolbe> s/adjictive/adjective/
17:01:41 <mmorrow> what's a "pattern" here?
17:01:53 <jsn> mdmkolbe: you mean, a pattern match?
17:02:02 <mdmkolbe> jsn: yes in a pattern match
17:02:07 <mauke> constructors
17:02:21 <mmorrow> cognominal: newtype TMVar a = TMVar (TVar (Maybe a))
17:02:29 <Axman6> yeah, just constructors afaik
17:02:31 <gwern> cognominal: indeed, yi can be hard to understand. I fall back on trial and error most of the time
17:02:34 <ddarius> mauke: There are many things beyond constructors that can occur.
17:02:46 <gueux> hi :-)
17:02:48 <pumpkin_> addition, sadly
17:03:03 <jsn> gueux: hello
17:03:05 <Axman6> ddarius: like?
17:03:09 <mdmkolbe> mauke: yes, but I need it in adjective form and I have two kinds of constructors (ones that fit in patterns and ones that dont) so "constructive" constructors doesn't exactly work
17:03:13 <pumpkin_> Axman6: addition :P
17:03:20 <gueux> I'd like to catch an exception which can occur is eval: "s <- eval iorefdb line"
17:03:21 <Axman6> eh?
17:03:25 <gwern> I sometimes think jpb is the only one who has a good understanding of yi
17:03:26 <ddarius> Axman6: Variables, as-patterns, lazy patterns, n+k patterns, bang patterns nowadays.
17:03:29 <ddarius> wild cards
17:03:38 <ddarius> record patterns
17:03:41 <gueux> Can I do that with a catch?
17:03:49 <pumpkin_> > let (x+1) = 5 in x
17:03:50 <lambdabot>   4
17:03:55 <pumpkin_> ^
17:03:55 <Axman6> can you actually match on n+k patterns? thought that was just a gofer thing...
17:04:03 <Axman6> how nice
17:04:06 <pumpkin_> no!
17:04:06 <gwern> Axman6: you can
17:04:08 <gueux> (the output of eval is a IO String)
17:04:10 <gwern> it's crazy stuff
17:04:16 <mdmkolbe> also the term "Pattern" is used for something else in this context so "Paternable Constructors" is also unuseable
17:04:41 <pumpkin_> any ghc experts in here willing to help me figure something out? #ghc seems awfully idle :(
17:05:00 <mmorrow> pumpkin_: i'm not an expert, but i know a few things
17:05:17 <mdmkolbe> "Matchable Constructors" is close to the kind of term I want, but I think maybe it has an awkward ring to it
17:07:04 <pumpkin_> mmorrow: mostly trying to figure out how the bootstrapping from .hc files is supposed to work (in 6.6.1). it works fine until I get to the rts, but that starts injecting inline asm based on #ifdefs on *HOST* macros, which seems wrong. The build system appears to change terminology: target->host, host->build
17:07:20 <mmorrow> pumpkin_: just read from #ghc. just a thought: i know that ghc (at one point?) can be compiled by NHC. also, NHC can be bootstrapped via C from what i understand. maybe this path could make it easier??
17:07:33 <pumpkin_> hmm
17:07:57 <mmorrow> like, if you can get NHC built, and then use it to build at least ghc-6.4, you can bootstrap ghc-6.10 from there
17:08:21 <pumpkin_> can I get nhc to spit out x86_64?
17:08:35 <pumpkin_> or does it just compile through c?
17:08:50 <mmorrow> hmm, i dunno. i'd check out their webpage
17:09:05 <mmorrow> i've never used nhc personally
17:09:20 <skorpan> how can i generate native code without using gcc?
17:09:24 <byorgey> Heffalump: there are various things I could do to make the situation with rotation + bounding boxes better, and I hope to do some of them.  But a perfectly general solution seems difficult or impossible.
17:09:32 <mmorrow> skorpan: -fasm
17:09:39 <byorgey> Heffalump: I'd be interested to hear what you think a proper "fix" would look like.
17:09:41 <mmorrow> skorpan: which is the default i think
17:09:42 <pumpkin_> mmorrow: nhc98 is currently restricted to 32-bit machine architectures, or 64-bit machines that have a 32-bit compatibility mode. :/
17:09:51 <skorpan> mmorrow: so gcc is really just an optional dependency?
17:09:53 <mmorrow> pumpkin_: gah!! almost
17:10:13 <mmorrow> skorpan: yeah, the only time you need ghc is if you want to do -fvia-C
17:10:34 <skorpan> cool
17:10:37 <mmorrow> skorpan: of course though, ghc only spits out asm so you still need as
17:10:39 <pumpkin_> so I need to figure out how this cross compilation is supposed to work
17:10:49 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1903#a1903 <- whats wrong with that? trying to use STM...
17:11:09 <mmorrow> pumpkin_: good luck. i've heard that with newer ghc's it's become extremely sketchy
17:11:19 <pumpkin_> mmorrow: I'm still on 6.6.1, because I'm avoiding the newer ones :)
17:11:21 <mmorrow> pumpkin_: maybe try to do it with a 6.4 or 6.6
17:11:24 <mmorrow> ah, nice
17:11:32 <pumpkin_> once I get 6.6.1 going, I'll try to use it to go higher
17:11:35 <Axman6> ImInYourMonad: you need to use atomically
17:11:46 <pumpkin_> but I can't even get 6.6.1 running
17:11:53 <mmorrow> pumpkin_: i've built a 6.8 with a 6.4, so you're golden if you build a 6.6
17:12:31 <mmorrow> pumpkin_: is this for ARM?>
17:12:34 <pumpkin_> it'll still take some messing around, I'm sure, as a lot of things seem to assume darwin implies 32-bit
17:12:44 <pumpkin_> nope, but I'd like to use the knowledge to make an ARM one too
17:12:50 <pumpkin_> I just want a mac os 64-bit ghc
17:13:04 <pumpkin_> it seems a lot harder than it should be :P
17:13:05 <mmorrow> i thought darwin did imply 32-bit :/
17:13:10 <Axman6> which is only slated for fixing by 6.12
17:13:13 <mmorrow> nasty, good luck :)
17:13:18 <pumpkin_> not at all, all macs sold in the last couple of years are 64-bit
17:13:47 <Axman6> mmorrow: gotta remember that Apple had the first desktop 64-bit PC's in the industry
17:13:57 <Axman6> the iMac G5
17:14:00 <mmorrow> true
17:14:02 <pumpkin_> but my question was really more basic than that
17:14:20 <Axman6> tiger was crippled 64 bit, and leopard is actually 64-bit
17:14:35 <pumpkin_> just about how any cross-compile build is supposed to work if it tries to produce a .o using inline asm from the target machine, based on an #ifdef on the host machine's arch
17:14:59 <pumpkin_> seems very odd to me
17:15:36 <mmorrow> i think if you manage to bootstrap, you'll have to just always use -fvia-C
17:15:44 <pumpkin_> yeah, I'm fine with that
17:15:51 <pumpkin_> I'm just following instructions mostly for now
17:15:57 <pumpkin_> ( http://hackage.haskell.org/trac/ghc/wiki/Building/Porting )
17:16:02 <mmorrow> so where does the inline asm come from?
17:16:07 <pumpkin_> but it doesn't work, and I can't see how it's supposed to
17:16:17 <pumpkin_> rts/Adjustor.c
17:16:23 <mmorrow> hmm
17:16:23 <ImInYourMonad> how do i use atmically http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1903#a1904
17:16:47 <mmorrow> pumpkin_: maybe you'll have to rewrite those asm snippets in the worst case
17:16:48 <pumpkin_> #if defined(x86_64_HOST_ARCH)
17:16:48 <pumpkin_>  ... produce x86_64 asm ... #endif
17:16:52 <byorgey> ImInYourMonad: look at the types.
17:16:56 <byorgey> @type atomically
17:16:56 <lambdabot> Not in scope: `atomically'
17:16:58 <mauke> ImInYourMonad: use more parens
17:17:01 <pumpkin_> mmorrow: doesn't that seem wrong?
17:17:38 <mmorrow> pumpkin_: look in rts/AdjustorAsm.S
17:17:50 <mmorrow> see if there's anything in there you can use
17:17:52 <mperillo> how should I define the NFData instance for (UArr a), uvector package?
17:18:00 <pumpkin_> that's only for darwin ppc and i386
17:18:03 <mmorrow> if not i guess you'll have to add some that will
17:18:20 <pumpkin_> it's not even using that file
17:18:23 <mmorrow> oh
17:18:32 <mmorrow> well, this comment may be useful:
17:18:39 <mmorrow>     /* The code is "almost" the same for       32-bit and for 64-bit   */
17:18:39 <mmorrow> #if defined(powerpc64_HOST_ARCH)
17:18:44 <mmorrow> ...
17:19:19 <pumpkin_> I don't think it should be necessary to use that .S file at all
17:19:31 <pumpkin_> the ABI apple's using for intel 64-bit is completely standard
17:19:40 <mmorrow> pumpkin: ohhh, i just looked in Adjustor.c
17:20:10 <mperillo> dons, what is the reason why UArr in uvector package is not an instance of NFData?
17:20:33 <pumpkin_> mperillo: it's superduper strict already :P
17:20:37 <mmorrow> pumpkin_: what line # were you referencing earlier?
17:20:39 <pumpkin_> rnf = lengthU
17:21:00 <mmorrow> ah, i think i found it
17:21:08 <pumpkin_> right near the top
17:21:11 <mperillo> pumpkin_, I'm not sure it is really that strict
17:21:24 <pumpkin_> mperillo: how so?
17:21:34 <pumpkin_> it's unboxed, it has to be strict
17:21:58 <mperillo> pumpkin_, I'm using hGetContents, from ByteString.Lazy, and when the UArr has been created, GHC still want to read from the file
17:22:00 <mmorrow> oh, wait you're looking at 6.1..
17:22:16 * mmorrow was looking at a HEAD and wondering wtf is happening
17:22:19 <pumpkin_> ah :)
17:22:23 <pumpkin_> yeah, 6.6.1
17:22:40 <mperillo> I'm using withFile, and before return, I use `seq`
17:23:07 <mperillo> but still I get an error hGetBufNonBlocking: illegal operation (handle is closed)
17:23:17 <pumpkin_> mperillo: well, someone still needs to request the end result
17:23:45 <pumpkin_> mmorrow: I can paste the suspicious piece of code
17:23:52 <mperillo> let me try with calling lengthU, thanks pumpkin_
17:24:23 <pumpkin_> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1905#a1905 the idea behind that #if just confuses me
17:25:23 <pumpkin_> and obviously, given that my host is (pretending to be) 32-bit, I get /tmp/ghc63310_0/ghc63310_0.s:6:0: bad register name `%rsp'
17:25:27 <mmorrow> pumpkin_: i just unpacked the 6.1 src into http://www.moonpatio.com/repos/LIBS/Language/ghc-6.6.1 for my own reference
17:25:30 <pumpkin_> from that inline asm snippet
17:25:49 <mmorrow> (that server sends .{c,h,....} as text/plain)
17:25:52 <pumpkin_> ah
17:26:26 <mmorrow> i put all kinds of crap up there when i want to reference it constantly
17:26:29 <pumpkin_> (I'm treating my 64-bit endeavour as an unregistered port from my machine to the same machine)
17:26:43 <pumpkin_> (with different flags
17:27:25 <maxote> 6.8.3 is out
17:27:29 <mmorrow> ok, well maybe you just have to mess with all the #id*'s
17:27:36 <mmorrow> s/i8d/if/
17:27:37 <mmorrow> gah
17:27:41 <mmorrow> s/id/if/
17:27:59 <pumpkin_> I'm just questioning myself because I'm sure other people have done cross-compiles before
17:28:02 <pumpkin_> using this
17:28:17 <pumpkin_> maxote: ?
17:28:23 <mmorrow> pumpkin_: yeah, from what i understand it's not a trivial and hands-off endeavour :)
17:28:34 <pumpkin_> certainly not :P
17:28:34 <Axman6> maxote: ?
17:28:38 <defun> :t (<|>)
17:28:39 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
17:28:44 <defun> :t mplus
17:28:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:28:53 <Axman6> @instances Alternative
17:28:54 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
17:29:11 <maxote> err, is released 6.8.4?
17:29:12 <pumpkin_> mmorrow: before treating it as an unregistered port, I actually had to fool around with the cmm a fair bit, and the asm mangler
17:29:18 <pumpkin_> maxote: 6.10.1?
17:29:40 <maxote> i'm using obsolete ghc :s
17:29:45 <mmorrow> pumpkin_: cool. maybe you will become the new porting guru :)
17:29:48 <pumpkin_> lol
17:29:51 <mmorrow> hehe
17:29:58 <pumpkin_> do not want!
17:29:59 <pumpkin_> :P
17:30:12 <mmorrow> YOU CAN HAS CHEEZEBURGER
17:30:13 <pumpkin_> just want ghc 64-bit served up on silver platter :P
17:30:21 <pumpkin_> kthx
17:30:52 <pumpkin_> I think the issue is that they just change terminology somewhere in the build process
17:31:00 <pumpkin_> from target to host, and host to build
17:31:18 <mmorrow> looks like you're in for some fun
17:31:28 <pumpkin_> yeah, it's awesome
17:31:54 * maxote i'm using still 32-bit machine :(
17:32:09 <pumpkin_> I've got several 64-bit machines that aren't being used to their full potential
17:32:40 <Axman6> me too :(
17:32:51 <Axman6> i want to be able to...
17:32:58 <Axman6> > maxBound :: Int
17:32:59 <lambdabot>   9223372036854775807
17:33:02 <Axman6> and get that ^^
17:33:07 <pumpkin_> poor Axman6 :(
17:33:16 <edwardk> @seen bos
17:33:16 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1h 58m 34s ago.
17:33:20 <Axman6> poor pumpkin_ :'(
17:33:20 <ddarius> default (Int64)
17:33:25 <pumpkin_> lol
17:33:28 <Axman6> pumpkin_: what machine(s) do you have anyway?
17:33:30 <pumpkin_> not the same
17:33:37 <pumpkin_> I have a macbook pro, an air, and a mac pro
17:33:45 <pumpkin_> cause I'm a mac whore
17:33:49 <Axman6> just an MBP and G5 here
17:34:24 <Axman6> we've owned macs since i was 6 months old though. never owned a PC either :)
17:35:27 <pumpkin_> I might try going back to my original build
17:35:49 <pumpkin_> and try to go from stage1 by hand
17:36:50 <pumpkin_> actually, I think I have the typical bootstrap issue
17:38:27 <mmorrow> pumpkin_: this might help you get the situation organized in your head (it did for me) http://www.acm.org/pubs/citations/journals/toplas/1994-16-6/p1699-appel/
17:38:38 <mmorrow> crap, borken link
17:38:59 <mmorrow> pumpkin_: here: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.32.2422
17:39:07 <mmorrow> " Axiomatic Bootstrapping: A guide for compiler hackers"
17:39:16 <pumpkin_> thanks
17:39:31 <pumpkin_> I know the basic idea of boostrapping
17:39:39 <mmorrow> it's neat how he oraganizes and formalizes the issues
17:39:54 <mmorrow> pumpkin_: trust me :), this paper makes it formal
17:39:58 <pumpkin_> ah, it does look nice
17:40:12 <pumpkin_> well, the paper does, the pdf is ugly on mac os :)
17:41:40 <mmorrow> i hate when that happens
17:42:14 <ddarius> mmorrow: Don't use Mac OS and you won't have to worry about it.
17:42:17 <mdmkolbe> Is there a class that provides "f a -> a" just like Functor provides "(a -> b) -> f a -> f b"?
17:42:43 <mmorrow> ddarius: sometimes on fedora using evince .ps files are horrific looking
17:42:50 <mmorrow> (in which case i just use gv)
17:43:06 <pumpkin_> I could use gv too
17:43:12 <mmorrow> it's my fallback
17:43:14 <pumpkin_> but it doesn't feel very mac os-ish
17:43:45 <dolio> f a -> a is probably in a Copointed class in category-extras.
17:43:50 <ddarius> mdmkolbe: There's a class CoPointed (or something like that)in category-extras that should have a method like that.  Also, a comonad class should have it as well.
17:44:12 <mdmkolbe> ddarius: thx
17:44:41 <edwardk> it is
17:45:01 <mmorrow> , src ''Copointed
17:45:06 <lunabot>  class (Functor f) => Copointed f where
17:45:06 <lunabot>          extract :: forall a . f a -> a
17:45:29 <mmorrow> , src ''Comonad
17:45:30 <mdmkolbe> Haskell is strange.  I've gotten to the point where I get very disappointed if a polymorphic function with a short signature isn't already in the standard library
17:45:32 <lunabot>  class (Copointed w) => Comonad w where
17:45:32 <lunabot>          duplicate :: forall a . w a -> w (w a)
17:45:32 <lunabot>          extend :: forall b a . (w a -> b) -> w a -> w b
17:45:47 <pumpkin_> I want a Coarrow
17:45:56 <edwardk> heh if nothing else category-extras has been useful in getting people to use common names =)
17:46:11 <ddarius> edwardk: Really?
17:46:36 <edwardk> pumpkin: i just want to avoid Arrow ;)
17:46:44 <pumpkin_> aw
17:46:56 <pumpkin_> does category-extras have a Morphism instead?
17:47:23 <pumpkin_> I bet it doesn't have a StrictAnal though
17:47:44 <pumpkin_> lots of morphisms in category-extras
17:47:46 <pumpkin_> mmm
17:47:47 <ddarius> pumpkin: More likely to talk about lax things in CT.
17:47:54 <edwardk> pumpkin: har, Arrows are just a weakened notion of a Freyd Category.
17:48:03 <edwardk> pumpkin: yeah check Control.Functor.LaxAnal.
17:48:19 <pumpkin_> ah okay
17:48:21 <jekor> Anyone know of an example of doing IO in the Parsec monad?
17:48:52 <pumpkin_> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/StrictAnal.html, maybe it does need a LaxAnal counterpart, to remove explicit strictness where it's not needed
17:49:42 * Axman6 thinks they're both bad names...
17:49:49 <pumpkin_> aw :(
17:50:28 <edwardk> ah
17:51:27 * Axman6 thinks it's worth expanding anal to analysis where possible >_>
17:51:45 * pumpkin_ is reminded of Arrested Development
17:51:46 <edwardk> Axman6: sounds uncomfortable to be one of your dates.
17:51:59 <Axman6> >_<
17:52:00 <Axman6> haha
17:52:26 <Adamant_> first you wreck her hole, then you peer into her soul
17:52:38 <pumpkin_> o.O
17:52:50 <Adamant_> pumpkin: anal to analysis
17:52:50 <Axman6> wow... i think i broke the channel. m'bad guys, m'bad
17:52:55 <edwardk> hahahaha
17:52:56 <Adamant_> lol
17:52:57 <Adamant_> sorry
17:53:09 <ray> LaxAnal is a worse name
17:53:12 <Adamant_> that was pretty tasteless
17:53:37 <pumpkin_> Adamant_: was just o.Oing at the heteronormative statement :)
17:53:42 <Axman6> bleh, dromaeo takes forever to run
17:53:57 <dolio> http://farm1.static.flickr.com/26/49431591_1f85a8689e.jpg
17:54:05 <pumpkin_> yay
17:54:14 * Axman6 isn't sure he wants to click that...
17:54:33 <pumpkin_> Axman6: it's from an awesome tv show :)
17:54:37 <Adamant_> pumpkin_: who says I'm a man?
17:54:58 <Axman6> ha
17:54:59 <pumpkin_> Adamant_: ah, though you were referring to Axman6 who is definitely a man :)
17:55:13 <Axman6> damn straight!
17:55:15 <Adamant_> pumpkin_: because he has man in his name?
17:55:16 * Axman6 grunts
17:55:26 <Adamant_> Axman6: heteronormative!!!!!
17:55:27 <Adamant_> :P
17:55:28 <pumpkin_> nope
17:55:35 <Adamant_> ah you know him
17:55:44 <Adamant_> and I am a guy just for the record
17:55:54 <edwardk> Axman6: yeah there are some things you just can't unsee. the 2 girls 1 cup monad?
17:55:59 <Adamant_> not like that's a surprise on IRC
17:56:02 <pumpkin_> worse is the 1 guy 1 cup monad
17:56:17 <pumpkin_> (wow, all this -blah discussion thinly disguised as on-topic by appending monad)
17:56:30 <edwardk> hah, you've seen through my ploy.
17:56:40 <wolverian> I like how GHC has a package called StrictAnal
17:56:41 <Axman6> edwardk: i've seen worse. much worse. makes you want to wash your eyes with 2g1c poop so you'll feel better worse
17:56:50 <wolverian> s,package,module,
17:57:54 * edwardk cabal install's pony.
17:59:14 <edwardk> hrmm. it looks like text-icu assumes a version of the icu libs newer than the one you get from ubuntu.
18:00:09 <dolio> Well, at least that means ubuntu is out of date on something besides haskell.
18:01:37 <wolverian> blah, you can blame that one on debian
18:01:39 <wolverian> :)
18:03:04 <edwardk> trying to figure out if i can #ifdef it into supporting 3.8 or if i should just upgrade to 4. pros of the former is it would work for folks that just cabal install in ubuntu
18:05:30 * pumpkin_ crosses his fingers
18:05:32 <wolverian> 9.04 has 3.{4,6,8} and 4
18:05:39 <wolverian> or will have.
18:07:29 <ddarius> Apparently Ubuntu's version of llvm is rather out of date as well.
18:09:52 <gwern> > ((((1.1 * 1000) / 0.15) / 60) / 60)
18:09:53 <lambdabot>   2.037037037037037
18:09:55 <edwardk> hrmm, is it possible to #ifdef inside of an  #{enum ... } ?
18:12:47 <edwardk> everytime i read prolog/datalog i always wish they'd ditch the unnecessary parentheses and just use juxtaposition
18:13:49 <pastah> @faq can i with the type system cause a type error when adding a 2x2 matrix to a 2x3 matrix?
18:13:49 <lambdabot> The answer is: Yes! Haskell can do that.
18:14:19 <pastah> @faq can i launch the missiles without unsafePerformIO?
18:14:20 <lambdabot> The answer is: Yes! Haskell can do that.
18:14:35 <pastah> GRAET!
18:14:55 <jsn> >_>  <_<
18:15:04 <ddarius> edwardk: Use lambdaProlog
18:15:05 <Axman6> >_> <_<
18:15:08 <Axman6> >_><_<
18:15:11 <ddarius> (or any of the many successors of Prolog)
18:15:17 <Axman6> <33>
18:15:20 <Axman6> gross
18:15:44 <edwardk> ddarius: fair enough. =-)
18:16:44 <Ansible> haskell noob question:  I'm trying to install something from hackage and it says I need base-4.0.0.0 but base-3.0.1.0 was selected instead.
18:16:55 <Ansible> does this mean I need to upgrade ghc?
18:17:05 <edwardk> ansible using 6.8?
18:17:26 <Ansible> I'm on 6.8.2 (ubuntu default)
18:17:27 <Axman6> Adamant_: base-4.0 comes with ghc 6.10.x
18:17:53 <Ansible> ok, so I'll need to install 6.10 manually then... thx.
18:18:00 <Adamant_> Axman6: I am not a communications device
18:18:08 <Adamant_> well.. sort of
18:18:21 <Axman6> eh?
18:18:44 <Adamant_> Ansible = sci fi FTL comm device
18:19:01 * pumpkin_ screams
18:19:09 <Ansible> very good, Adamant_!
18:19:11 <Axman6> ok, emoticon competition. two faces kissing! (my <33> sucks)
18:19:28 * Axman6 gives pumpkin_ some chcoclate
18:19:33 <pumpkin_> :(
18:19:43 <kerlo> @faq Can Haskell be better than Haskell?
18:19:43 <lambdabot> The answer is: Yes! Haskell can do that.
18:19:50 <kerlo> !
18:20:10 <ddarius> kerlo: Well-foundedness is for the weak.
18:20:17 <maxote> kerlo, is not it an oxymoron?
18:20:18 * Axman6 goea to eat some very dark chocolate with crystalised rose petals that he got for valentines day
18:21:41 <edwardk> ddarius: they call it the LEAST fixed point for a reason. ;)
18:23:48 * ddarius sets up the rival Church of the Greatest Fixed Point
18:23:56 * edwardk reads his statement aloud and then wonders if its because "you'll have to give it in good shape back eventually" and then slinks off into a corner, with his clearly -blah sense of humor today.
18:24:16 * kerlo sets up the First Church of Wait, There's More Than One Fixed Point?
18:25:44 * edwardk sets out to convert kerlo to the church of the greatest fixed point.
18:26:03 <edwardk> clearly, just by the name, you can see it is better than the lowly least fixed point.
18:26:45 * pumpkin_ feels useless
18:28:33 <pumpkin_> Axman6: it'll have to wait some more
18:28:34 * Saizan_ give a sugar lambda to pumpkin_
18:28:45 <Axman6> :(
18:28:48 <pumpkin_> I'm about to rip my computer to shreds :P
18:28:55 <ddarius> pumpkin: I heartily recommend it.
18:29:07 <pumpkin_> I bet it would feel good
18:29:12 * edwardk was about to give pumpkin_ a bottom to play with, but then he realized how #haskell-blah that statement really was.
18:29:12 <Axman6> good time to stop then
18:29:13 <ddarius> pumpkin: I guarantee it.
18:29:30 <pumpkin_> edwardk: can I run StrictAnal on it?
18:29:57 <edwardk> it might take an uncomfortably long period of time.
18:30:12 <pumpkin_> hmm ok
18:30:25 <Saizan_> or very comfortable, depending on your tastes
18:30:40 <maxote> kerlo, what Haskell can be better than Haskell? the left or the right?
18:31:10 <ddarius> > Right "Haskell" > Left "HaskelL"
18:31:11 <lambdabot>   True
18:31:14 <ddarius> > Right "Haskell" > Left "Haskell"
18:31:15 <lambdabot>   True
18:34:59 <maxote> > Left "Haskell" > Right "Haskell"
18:35:00 <lambdabot>   False
18:35:47 <roconnor> > compare (Left "Haskell") (Right "Haskell")
18:35:48 <lambdabot>   LT
18:36:11 <ddarius> So an interesting result is that for the Integer -> a monad/comonad join . duplicate decimates it.
18:36:36 <maxote> > Left "Haskell" == Right "Haskell"
18:36:38 <lambdabot>   False
18:36:51 <Saizan_> decimates?
18:36:57 <edwardk> ddarius: did you just clack those in and get the default instance in ghci or something?
18:37:28 <ddarius> edwardk: I have a bunch of equations/definition on paper.
18:37:36 <maxote> > ( Right "Haskell" ) - ( Left "Haskell" )
18:37:37 <lambdabot>       No instance for (Num (Either [Char] [Char]))
18:37:37 <lambdabot>        arising from a use ...
18:38:19 <ddarius> s/decimate/down sample/
18:39:48 <edwardk> @type duplicate
18:39:49 <lambdabot> forall a b. (a, b) -> (a, (a, b))
18:39:56 <edwardk> where did that one come from?
18:40:07 <ddarius> edwardk: I think an old let definition.
18:40:11 <edwardk> ah
18:40:14 <ddarius> @undefine
18:40:16 <ddarius> :t duplicate
18:40:17 <lambdabot> Not in scope: `duplicate'
18:40:20 <edwardk> ah k
18:40:22 <Axman6> > duplicate ('a',1)
18:40:22 <lambdabot>   Not in scope: `duplicate'
18:46:09 <edwardk> ddarius: downsamples how? my laptop doesn't currently run category-extras (oh, the irony) ;)
18:46:50 <ddarius> duplicate :: (a, b) -> (a, (a, b))
18:46:50 <ddarius> duplicate    (a, b)  = (a, (a, b))
18:48:02 <ddarius> duplicate u = \i j -> u (i+j); join u = \i -> u i i; join . duplicate $ u = \i -> u (i + i) = \i -> u (2*i)
18:49:00 <edwardk> ah ok, that fits
18:50:01 <gwern> @quote
18:50:01 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
18:50:51 <gueux> with 'printf "%s" foo' where foo is a string with '\n's, can I put two spaces at the beginning of each line?
18:51:07 <mmorrow> preflex: seen mauke
18:51:08 <preflex>  mauke was last seen 1 hour, 17 minutes and 41 seconds ago, saying: <private message>
18:51:11 <mmorrow> mauke: ping
18:51:30 <mauke> pong
18:51:42 <Axman6> > text ( printf "%s" "foo\nbar\n thing" :: String)
18:51:43 <lambdabot>   foo
18:51:43 <lambdabot>  bar
18:51:43 <lambdabot>   thing
18:51:55 <MyCatVerbs> gueux: easiest way is to write, "(unlines . map ("  "++) . lines $ foo)" instead of just "foo".
18:51:59 <pumpkin_> mmorrow is back!
18:52:03 <mmorrow> mauke: hey. do you have the actual .s you used for hell.c anywhere? you pasted it at one point but the link no longer exists
18:52:20 <mmorrow> pumpkin_: did you get it bootstrapped yet??
18:52:26 <mauke> mmorrow: http://rafb.net/p/XUpOP054.html
18:52:29 <gueux> MyCatVerbs: ok
18:52:29 <pumpkin_> no, I had to stop before I damaged my computer
18:52:31 <gueux> thanks
18:52:33 <mmorrow> mauke: thanks
18:52:49 <mmorrow> pumpkin_: bah, suck it up! :)
18:53:18 <Axman6> heh
18:53:28 <MyCatVerbs> gueux: that breaks the string into individual lines, adds two spaces to the start of every line, and then puts the lines back together again. Nice and simple, no? ^_^
18:54:04 <pumpkin_> mmorrow: I got myself a nice hc bundle to bootstrap with
18:54:10 <pumpkin_> and then it barfed epicly when I tried to
18:54:42 <mmorrow> pumpkin_: heh
18:55:03 <pumpkin_> lord SPJ does not approve
18:55:59 <mmorrow> mauke: so "movl (%esp), %ecx" puts the PC in return addr (==> the address of the string) into %ecx, right?
18:56:18 <mmorrow> err, meant to delete "PC in"
18:56:29 <mauke> yes
18:56:44 <mauke> (%esp) is the top of the stack, which is the address of the string there
18:58:28 <mmorrow> cool. i'm trying to grok this asm that smlnj uses in its ffi to make arbitrary closures look/act like function ptrs from C, and i think it's using a similar idea to get the address of its entry, because it stores info right before that it needs to access. that made me all of a sudden remember your code and what it'sdoing
18:58:42 <mmorrow> um, did that not all come through?
18:59:02 <mmorrow> grr, i dunno what just happened
18:59:10 <mmorrow> the beginning of that:
18:59:48 <ddarius> mmorrow: The value on the stack points to the return address.  You'd grab eip and index from there.
18:59:52 <mmorrow> mauke: i'm trying to grok this asm that smlnj uses in its C ffi, which makes an arbitrary ml closure look/act like a function ptr from C
19:00:03 <mmorrow> ddarius: sweet
19:00:08 <mauke> mmorrow: I'd do that by generating machine code at runtime
19:00:19 <ddarius> mauke: That's how GHC works.
19:00:22 <mmorrow> mauke: totally, that's what they do (i think)
19:00:50 <mmorrow> well, they have a pre-written hell.c-ish stub thing that they use somehow it looks like
19:01:20 <mmorrow> oh, the punchline of what i was trying to say got chopped..
19:01:40 <mmorrow> so that code does what ddarius just said to get at the PC
19:01:40 <mauke> I used to have something like that in C
19:01:47 <mmorrow> mauke: interesting
19:02:51 <mauke> int (*eprintf)(const char *, ...) = (int (*)(const char *, ...)wrap_vfunc((void (*)())fprintf, sizeof stderr, stderr);
19:02:59 <mauke> eprintf("hello, error!\n");
19:03:13 <mauke> free((void *)eprintf);
19:03:22 <ztirF> anyone know why getNumElements has to return an IO Int instead of just an Int?
19:03:26 <mmorrow> mauke, ddarius: here's the code i'm groking http://moonpatio.com/repos/LIBS/Language/smlnj/runtime/c-libs/smlnj-ccalls/c-entry.asm
19:03:43 <mmorrow> (i put it there since it sends .c/etc as text/plain)
19:04:23 <mmorrow> mauke: oh cool, i'm trying to do pretty much exactly that in various ways
19:04:28 <Axman6> ztirF: what's it do?
19:04:37 <ztirF> returns the size of a mutable array
19:04:39 <mmorrow> mauke: (roughly)
19:04:43 <ddarius> I don't know why they don't just call the next instruction.
19:04:56 <mmorrow> ddarius: yeah, it's confusing me exactly what they're doing
19:04:57 <ddarius> call foo; foo: pop eax
19:05:12 <Axman6> ztirF: well don't you need IO to do anything with mutable arrays? (or ST)
19:05:30 <ztirF> ztirF: yes if you want to mutate them, that makes sense to me
19:05:53 <ztirF> but you can never mutate the size of an IOUArray, right?
19:05:54 <mauke> ddarius: that looks like it will mess up branch prediction
19:05:58 <Axman6> well, if you can getNumElements twice on the sme mutable array, are you guaranteed to get the same result?
19:06:02 <mmorrow> ddarius, mauke: this describes their strategy http://www.smlnj.org/doc/SMLNJ-C/index.html
19:06:11 <Axman6> might be able to
19:06:23 <ztirF> hmm, I see
19:06:36 <Axman6> i dunno, i've never tried
19:08:09 <mmorrow> (bottom of pg 11-12)
19:08:25 <mmorrow> + figure 6
19:11:41 <dolio> There's no need for them to be in the monad. But that's how the MArray class is.
19:12:19 <dolio> I guess in theory you could have an array that did have an impure getNumElements.
19:25:00 <gueux> is there a way to say: "don't interpret the "\" and "," in the following string?
19:25:17 <pumpkin_> it doesn't interpret ,
19:25:24 <gueux> ok
19:25:31 <pumpkin_> but for \, I don't think so
19:25:37 <pumpkin_> just \\?
19:25:43 <mauke> for \ the only way is single-quoted heredocs
19:25:48 <Axman6> , isn;t a special character in strings
19:25:49 <lunabot>  luna: parse error on input `;'
19:25:49 <ddarius> One could make a TH quasi-quoter.
19:25:55 <mauke> er, wrong channel
19:26:00 <gueux> in fact I have a message with multiple "\" inside
19:26:06 <gueux> and on several lines
19:26:50 <mmorrow> here = QuasiQuoter (litE . stringL) (litP . stringL)
19:26:51 <gueux> with \\ I can't see the message
19:26:58 <mmorrow> here :: QuasiQuoter
19:27:01 <gueux> ok for "," :-)
19:27:07 <mmorrow> , [$here| \ ,,, ,, \ |]
19:27:10 <lunabot>  " \\ ,,, ,, \\ "
19:27:21 <gueux> ok
19:27:25 <gueux> thanks
19:27:41 <mmorrow> you need to put `here' in a different module than the one you use it in though
19:27:52 <mmorrow> (if you decide to use a QQ)
19:28:52 <Gracenotes> impressive. The words fuck, damn, etc. appear nowhere in the GHC source code :) hell, once
19:29:01 * pumpkin_ is trying too hard to make his arm instruction representation too typesafe :(
19:29:07 <mmorrow> gueux: this is copy-pasteable and completely self-contained: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/src/Language-Haskell-Meta-QQ-Here.html
19:29:16 <pumpkin_> Gracenotes: but they make up for it with StrictAnal
19:29:29 <Gracenotes> pumpkin_: indeed, that's what made me think of it
19:29:39 <Gracenotes> them researchers and their anatomical precision
19:30:09 <ozy`> Gracenotes: ^ was that comment a dig at the notoriously profane Windows source code by any chance?
19:31:02 <Gracenotes> notoriously profane source code in general :) DOS from 2000, Netscape, etc.
19:31:38 <Gracenotes> a lot of in-development software projects, afaik
19:31:54 <ozy`> ....anything written in C ;)
19:32:21 <Gracenotes> heh. Language is, I'm sure, a factor
19:32:23 <ddarius> Gracenotes: You need British-isms.
19:33:03 <ddarius> (Well, UK-isms)
19:33:18 <Gracenotes> bloody not'nce
19:33:31 <Gracenotes> there's darn
19:34:05 * ddarius doesn't have foul language in his source because he doesn't comment it.
19:34:46 <Axman6> if you can't uderstand it, you shouldn't be reading it!
19:35:07 <edwardk> ddarius: the mathematician philosophy that if it was hard to write it should be hard to read?
19:36:05 <ddarius> Most of my work code isn't hard to write and thus potentially isn't hard to read.
19:36:15 * monochrom doesn't swear because there are more innovative ways to insult. Don't you find "fuck" boring?
19:37:34 <ozy`> you have to use the most colorful vocabulary possible
19:37:52 <monochrom> My basic insult is "you're such a finite state machine".
19:37:54 <ozy`> compound words are good for this
19:37:56 <ozy`> hahaha
19:38:04 <ddarius> monochrom: I am a finite state machine...
19:38:35 <monochrom> "singular-cell automaton" is also pretty handy.
19:38:42 <whoppix> haha
19:39:54 <Gracenotes> Your mother's Chomsky hierarchy number is so low, her tape could go around the world an infinite number of times
19:40:11 <Gracenotes> *badabing*
19:40:26 * edwardk is a stack machine. I just never get around to popping anything off the stack.
19:40:40 <monochrom> One thing I hate is insulting the target's mom.
20:06:28 <pumpkin_> wow
20:08:33 <Axman6> hmm?
20:08:38 * Axman6 is bored...
20:08:39 <dolio> Well, well. Mailman day.
20:15:51 <pumpkin_> mailman day?
20:17:30 <dolio> Mailman day is the day when all the mailing lists that use the mailman software send you something to let you know that you're still subscribed to the list you've been receiving mail from for the past month.
20:19:00 <pumpkin_> aha :)
20:19:13 <pumpkin_> sounds really useful
20:19:22 <dolio> Totally.
20:19:45 <dolio> It has your password, too, for added security.
20:20:09 <Japsu> haha yeah :D
20:20:16 <pumpkin_> I hate emails like that
20:20:28 <pumpkin_> first of all, I'm totally not used to reading my password, so it looks weird as hell
20:20:32 <Japsu> in addition to being mailman day, it's also cron time
20:20:40 <Japsu> or well, it's cron time _soon_
20:20:40 <pumpkin_> but more importantly, it's dumb to send passwords over email
20:20:48 <Japsu> 06:25 GMT+0200
20:21:05 <Japsu> that's when my servers hit their cron.dailies and spam me with the output
20:22:04 <mle> Welcome to March.
20:23:28 <mmorrow> ?localtime mmorrow
20:23:29 <lambdabot> Local time for mmorrow is Sat Feb 28 22:23:28
20:23:34 <mmorrow> :)
20:26:04 <Japsu> there, 6:25
20:26:13 <Axman6> @localtime Axman6
20:26:13 <Japsu> hilights from cronrotate on a monitoring channel
20:26:16 <lambdabot> Local time for Axman6 is Sun Mar  1 15:26:13 2009
20:26:26 <pumpkin_> fail
20:26:38 <Axman6> Sun Mar  1 15:26:38 EST 2009
20:26:42 <Axman6> then
20:27:02 <Axman6> pumpkin_: what're you still doing awake?
20:27:12 <pumpkin_> @localtime pumpkin_
20:27:12 <Axman6> @localtime pumpkin_
20:27:12 <lambdabot> Local time for pumpkin_ is 2009-02-28 23:27:10 -0500
20:27:12 <lambdabot> Local time for pumpkin_ is 2009-02-28 23:27:10 -0500
20:27:19 <Axman6> :o
20:27:29 <Axman6> hmm, aren't you in the UK?
20:30:02 <pumpkin_> nope
20:30:21 <pumpkin_> :)
20:31:02 <Axman6> where are you then?
20:31:07 * Axman6 thought pumpkin_ was cool
20:31:17 <pumpkin_> I'm in New England ;)
20:31:25 <pumpkin_> was born in England though :)
20:31:37 <Japsu> mmhm
20:31:40 <Axman6> slightly more cool
20:31:42 <Japsu> how does @localtime work? CTCP TIME?
20:31:45 <Japsu> @localtime Japsu
20:31:46 <pumpkin_> yup
20:31:49 <lambdabot> Local time for Japsu is Sun Mar  1 06:31:45 2009
20:31:52 <Japsu> yeah
20:31:54 <pumpkin_> Axman6: I'm awesomely cool
20:32:04 <dolio> @localtime preflex
20:32:04 <lambdabot> Local time for preflex is 2009-03-01 04:32WHERE IS SARAH CONNOR?
20:32:10 <Japsu> :D
20:32:14 <Axman6> haha
20:34:55 <centrinia> Hi pumpkin.
20:34:55 <lambdabot> centrinia: You have 1 new message. '/msg lambdabot @messages' to read it.
20:35:00 <pumpkin_> hi centrinia!
20:35:15 <Axman6> something that happens via cron on 0 0 1 * * hsppens at the beginning of the month right?
20:37:41 <BitingTreeFerret> Axman6, what? This in #haskell? Try ##linux or #workingset
20:38:49 <Axman6> BitingTreeFerret: well considering cron was a very recent topic in here, and it's a very friendly and intelligent channel, full of people who would probably know the answer, i thought it was a good place to get a quick answer :)
20:39:00 <BitingTreeFerret> Axman6, ok then
20:39:06 <BitingTreeFerret> I have a question then
20:39:38 <BitingTreeFerret> <BitingTreeFerret> do you guys suggest upgrading the graphics card drivers if the Winamp visualization don't work? ##windows is on a break, it seems
20:39:54 <wli> Let's implement cron in Haskell.
20:39:54 <pumpkin_> o.O
20:40:10 <Axman6> not a terrible idea
20:40:14 <Zao> wli: unsafeTickTock
20:40:23 <BitingTreeFerret> wli, yes!
20:40:27 <BitingTreeFerret> I want to do it
20:40:36 <BitingTreeFerret> I just need to learn Haskell more
20:46:13 <Saizan> http://code.google.com/p/happstack/issues/detail?id=62 <- wrt cron
20:46:16 <Cale> Let's implement init(8) in the type system!
20:46:33 * wli factors 2^(2^6)+1 using continued fractions.
20:47:17 <pumpkin_> what are the factors?
20:47:47 <wli> $ /usr/bin/time ./Q 18446744073709551617
20:47:47 <wli> Just (Right (274177,67280421310721))
20:47:47 <wli> 51.69user 0.03system 0:51.74elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
20:47:47 <wli> 0inputs+0outputs (0major+1085minor)pagefaults 0swaps
20:47:57 <pumpkin_> Just right!
20:47:58 <pumpkin_> ;)
20:48:16 <wli> factor :: Integer -> Maybe (Either Integer (Integer, Integer))
20:48:31 <Cale> > 3*5*17*257*641*65537*6700417 == 2^(2^6) - 1
20:48:32 <lambdabot>   True
20:48:33 <wli> It finds either one or two divisors at once.
20:49:20 <wli> That's a lot of Fermat primes in one product; 3, 5, 17, 257, and 65537.
20:49:36 <Cale> How long for 2^2^7 - 1
20:50:05 <wli> Not sure. I get effective nontermination for 2^(2^7) + 1
20:50:27 <centrinia> > 2^(2^7)-1 == (2^(2^6)-1) * (2^(2^6)+1)
20:50:29 <lambdabot>   True
20:50:59 <wli> 0.01user 0.00system 0:00.00elapsed 250%CPU (0avgtext+0avgdata 0maxresident)k
20:51:07 <centrinia> 129 bit numbers are not that large with respect to factoring.
20:51:10 <Cale> > 2^2^6 + 1 == 274177*67280421310721
20:51:11 <lambdabot>   True
20:51:27 <centrinia> Cale, are those primes?
20:51:29 <Cale> yes
20:53:13 <Cale> > product [3,5,17,257,641,65537,274177,6700417,67280421310721,59649589127497217,5704689200685129054721] == 2^2^8 - 1
20:53:14 <lambdabot>   True
20:53:28 <wli> centrinia: Well, for me, it's a step beyond trial division. I'm still having some trouble with it, since I don't have a primality test and I can't get it to work very well.
20:53:49 <wli> How does 2^(2^7) + 1 factor?
20:54:08 <Cale> like centrinia said...
20:54:19 <pumpkin_> he did -1 didn't he?
20:54:24 <Cale> oh
20:54:25 <centrinia> No, I said how 2^(2^7)-1 factors.
20:54:34 <Cale> right, I misread
20:54:46 <centrinia> wli: Implement a Pollard rho method.
20:54:48 <Cale> > 59649589127497217*5704689200685129054721 == 2^2^7 + 1
20:54:49 <lambdabot>   True
20:55:00 <wli> centrinia: I already tried and failed.
20:55:03 <centrinia> Why?
20:56:49 * Cale tries 2^2^8 + 1
20:57:00 <wli> Cale: What method did you use to factor 2^(2^7) + 1?
20:57:05 <Cale> Mathematica
20:57:24 <wli> They're bound to have some good algorithms.
20:59:00 <Cale> "FactorInteger switches between trial division, Pollard p-1, Pollard rho, elliptic curve and quadratic sieve algorithms."
21:00:19 <monochrom> eh? it tries p-1 before rho?
21:00:34 * monochrom usually uses rho before p-1
21:01:36 <dmwit> Do them all at once on separate cores!
21:01:42 <dmwit> And take the one that answers first. ;-)
21:02:46 <monochrom> The plot thickens because each method itself also calls for multi-core. Especially elliptic curve and quadratic sieve.
21:03:28 <wli> Well, elliptic curve is really randomly trying crap, so it's naturally arbitrarily parallelizable.
21:04:00 <monochrom> For example elliptic curve says try a lot of randomly chosen parameters, one of them may work. There is no sequential dependence between different random choices. This is crying for multi-core.
21:04:02 <wli> QS is linear algebra over Z/2Z so it's got some limitations on parallelism.
21:04:24 <wli> Though plenty of opportunity for it as well.
21:06:27 <Cale> Okay, 2^2^8 + 1 doesn't seem to be getting anywhere inside my attention span :)
21:06:57 <pumpkin_> > 2^2^8 + 1
21:06:58 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
21:07:21 <Cale> > length . show $ 2^2^8 + 1
21:07:22 <lambdabot>   78
21:07:34 <pumpkin_> > 1238926361552897 * 93461639715357977769163558199606896584051237541638188580280321
21:07:35 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
21:07:36 <centrinia> Cale, that makes sense. 78 digits takes a few minutes to a day.
21:07:46 <centrinia> pumpkin :O
21:08:01 * wli sees if continued fractions get lucky.
21:08:15 <Cale> ah, and those are prime as well
21:08:22 <Cale> (pumpkin's factors)
21:08:29 <pumpkin_> I did it in my head
21:08:35 <Cale> haha
21:08:35 <pumpkin_> :P
21:08:37 <Axman6> http://failblog.org/2009/02/18/911-fail/ XD
21:08:46 <wli> pumpkin: Web search for Fermat number factorizations?
21:08:55 <pumpkin_> nope, just have qsieve :)
21:09:09 <wli> What's qsieve?
21:09:16 <monochrom> quadratic sieve
21:09:24 <pumpkin_> ggnfs might be even better
21:09:30 <pumpkin_> but I didn't have that already installed
21:09:51 <wli> I presumed it was an app that did QS.
21:10:07 <wli> I hoped for some detail about authors, implementation language, etc.
21:10:15 <pumpkin_> http://www.thorstenreinecke.de/qsieve/ this one :)
21:10:17 <monochrom> http://www.thorstenreinecke.de/qsieve/  OMG
21:10:37 <monochrom> It's in spooky purple!
21:11:33 <pumpkin_> my ARMness is progressing
21:12:33 <BitingTreeFerret> pumpkin_ have you seen the Pandora ( openpandora.org )? It is _awesome_!
21:12:40 <monochrom> God, 1 second for 496025142797537184410324879054927095334462742231683423624.
21:12:52 <pumpkin_> it's pretty speedy :) and you can run it on multiple nodes
21:13:03 <pumpkin_> BitingTreeFerret: ?
21:13:03 <BitingTreeFerret> monochrom, wow
21:13:11 <BitingTreeFerret> monochrom, how is that possible?
21:13:19 <BitingTreeFerret> pumpkin: it's a ARM-based handheld
21:13:21 <pumpkin_> oh
21:13:23 <monochrom> It doesn't seem to bother to try ECM very hard.
21:13:30 <pumpkin_> I'm an iPhone maniac :)
21:13:34 <BitingTreeFerret> pumpkin_ not a PDA, a little mini-computer
21:13:49 <BitingTreeFerret> pumpkin_ if they had the iPhone for $200, I would buy it
21:14:16 <TomMD> BitingTreeFerret: Do you have one?  I've been thinking of picking up a newish ARM based system to kick-start me into getting some ARM + FP work started.
21:14:16 <Saizan> do we have a bounded Chan or a thread pool library?
21:14:32 <TomMD> Saizan: See Control-Engine for a thread pool.
21:14:45 <BitingTreeFerret> TomMD, nope, they are not even shipping yet
21:14:49 <TomMD> I also have a bounded chan implementation (I think) still in the ipc - but that library never saw enough love.
21:14:50 <Saizan> ?hackage Control-Engine
21:14:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Control-Engine
21:14:59 <BitingTreeFerret> TomMD, it looks very promising
21:15:04 <Saizan> ipc?
21:15:11 <TomMD> ?hackage ipc
21:15:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ipc
21:15:21 <centrinia> > 2^(2^9)-1 == 1238926361552897*10822118526186626384004285328439329883821275513095052798186320967919853410781985762865486979363630049728854622846750063174783245356096219135
21:15:23 <lambdabot>   True
21:15:26 <centrinia> Okay. :)
21:15:30 <pumpkin_> centrinia: qsieve?
21:16:01 <pumpkin_> msieve is probably even better :)
21:16:05 <TomMD> Saizan: I still mean to blog about/document Control-Engine.  Basically the Engine is a spin-off from my DHT while the ThreadPool is very simple and just made sense to throw in there.
21:16:06 <Gracenotes> when is it appropriate to use foralls in datatypes? :)
21:16:31 <centrinia> Wait, :|
21:16:34 <pumpkin_> the reason I've played with these factoring programs is that a friend of mine asked me to break (a small instance of) RSA for him
21:16:35 <TomMD> And IPC was a stop-gap for another project, but has been abandoned since.
21:16:45 <centrinia> :t 2^2^9-1
21:16:46 <lambdabot> forall t. (Num t) => t
21:16:54 <centrinia> > 2^2^9-1
21:16:55 <lambdabot>   134078079299425970995740249982058461274793658205923933777235614437217640300...
21:17:12 <centrinia> > 2^(2^9)-1 == (1238926361552897*10822118526186626384004285328439329883821275513095052798186320967919853410781985762865486979363630049728854622846750063174783245356096219135 :: Integer)
21:17:14 <lambdabot>   True
21:17:25 <Gracenotes> o nos
21:17:30 * wli tries 2^(2^9) + 1
21:17:45 <pumpkin_> Gracenotes: an "internal" forall, or an external one?
21:18:12 <centrinia> > 2^2^9-1 == 2424833*7455602825647884208337395736200454918783366342657*741640062627530801524787141901937474059940781097519023905821316144415759504705008092818711693940737
21:18:13 <lambdabot>   False
21:18:16 <Gracenotes> a forall in one constructor specifically
21:18:17 <centrinia> > 2^2^9+1 == 2424833*7455602825647884208337395736200454918783366342657*741640062627530801524787141901937474059940781097519023905821316144415759504705008092818711693940737
21:18:18 <lambdabot>   True
21:18:22 <centrinia> Yay. :)
21:18:23 * wli vaguely notes that should 2^(2^9) + 1 be prime, it is possible to construct regular polygons with that many sides with straightedge and compass.
21:18:33 <centrinia> Uh, no. 2^2^9+1 is not prime.
21:18:37 <pumpkin_> sad
21:18:40 <Gracenotes> pumpkin_: typeclasses can screw datatypes up :(
21:18:44 <pumpkin_> I was really looking forward to constructing one up
21:18:51 <centrinia> I'm using this by the way: http://homes.cerias.purdue.edu/~ssw/cun/third/pmain901
21:19:09 <centrinia> I'm not wasting clock cycles when someone else has wasted them for me. :)
21:19:10 <wli> centriinia: Well, I have no idea, I'm just running qsieve on it.
21:19:45 <Saizan> TomMD: looks like what i need, thanks :)
21:19:55 <TomMD> np
21:20:16 <centrinia> > 2^2^10+1 == 45592577*6487031809*4659775785220018543264560743076778192897*130439874405488189727484768796509903946608530841611892186895295776832416251471863574140227977573104895898783928842923844831149032913798729088601617946094119449010595906710130531906171018354491609619193912488538116080712299672322806217820753127014424577
21:20:17 <lambdabot>   True
21:20:24 <wli> Fermat numbers are neat because if/when they're prime, you can do compass and straightedge and compass constructions.
21:20:55 <centrinia> They haven't found a new Fermat prime for quite a while now.
21:21:16 <Axman6> > 2^2^100+1
21:21:30 <pumpkin_> that ones' quite big
21:21:32 <lambdabot>   thread killed
21:21:32 <pumpkin_> 's
21:21:51 <wli> A few centuries, yes. ;)
21:22:04 * Axman6 cleams that thread killed means it's a prime number
21:22:24 <wli> 2, 3, 5, 17, 257, and 65537 appear to be all there is for the time being.
21:22:50 <centrinia> Conjecture: 2^2^n+1 is composite for n>4
21:22:51 <pumpkin_> don't be cleaming
21:22:58 <Gracenotes> hm. How often to they find new primes?
21:23:12 <wli> ISTR there being a story about some French guy actually attempting to carry out a construction of a regular polygon with 65537 sides back in the late 1800's.
21:23:20 <Gracenotes> theoretically there's an algorithm to find more, but it can take a long time
21:23:25 <Gracenotes> *do
21:23:29 <centrinia> Gracenotes: They find record holding (in terms of magnitude) primes every year or two.
21:23:30 <wli> With straightedge and compass, that is.
21:23:46 <pumpkin_> finding smaller primes is done often and isn't announced
21:23:51 <wli> Gracenotes: Well, you can run the sieve of Eratosthenes to find more.
21:23:53 <Gracenotes> centrinia: yes, 'largest prime so far' :)
21:24:03 <Gracenotes> indeed. I can use trial division to find more
21:24:08 <centrinia> They are almost always Mersenne primes.
21:24:16 <pumpkin_> 2^43112609 − 1 is prime :o
21:24:17 <pumpkin_> :P
21:24:23 <pumpkin_> let's get lambdabot to compute that
21:24:42 <centrinia> You can make a pseudorandom number generator with a period of 2^43112609-1. :O
21:24:46 <centrinia>  :p
21:24:53 <pumpkin_> orly!
21:25:02 <centrinia> They are called Mersenne Twisters.
21:25:05 <pumpkin_> yeah :)
21:25:11 <Gracenotes> well, it spit out  2^4311261 almost instantly
21:25:22 <newsham> 1 :+ 1 is prime
21:25:29 <pumpkin_> Gracenotes: ask for its digits
21:25:31 <Gracenotes> it's stalling a bit with the extra digit
21:25:34 <pumpkin_> I mean, all of them
21:25:42 <mle> > replicate 43112608 '1'
21:25:44 <lambdabot>   "11111111111111111111111111111111111111111111111111111111111111111111111111...
21:25:45 <Gracenotes> pumpkin_: hm? I did, and I got them
21:25:55 <Gracenotes> it filled my entire buffer
21:25:58 <pumpkin_> :)
21:26:11 <Gracenotes> my buffer, granted, isn't terribly big
21:26:14 <pumpkin_> aw
21:26:22 <Axman6> > read . replicate 43112608 $ '1' :: Integer
21:26:30 <Gracenotes> oh, got the entire number after a few seconds
21:26:35 <mle> Axman6: wrong base, really...
21:26:36 <lambdabot>   mueval: Prelude.read: no parse
21:26:46 <centrinia> > read . replicate 3 $ '1' :: Integer
21:26:50 <lambdabot>   111
21:26:55 <centrinia> That's not what you wanted.
21:26:57 <Gracenotes> > logBase 2 4311261
21:26:58 <lambdabot>   22.039678473990346
21:27:05 <Axman6> centrinia: sue it is
21:27:07 <pumpkin_> I declare that prime to be 10, base that prime
21:27:07 <Axman6> sure*
21:27:27 <Axman6> > read . replicate 100000 $ '1' :: Integer
21:27:31 <lambdabot>   111111111111111111111111111111111111111111111111111111111111111111111111111...
21:27:32 <centrinia> > read . ('0':) . ('b':) . replicate 3 $ '1' :: Integer
21:27:33 <lambdabot>   * Exception: Prelude.read: no parse
21:27:35 <Axman6> > read . replicate 1000000 $ '1' :: Integer
21:27:37 <centrinia> Hmm.
21:27:45 <Gracenotes> madness!
21:27:50 <lambdabot>   thread killed
21:27:53 <mle> > > "0x" ++ replicate 10778152 'F'
21:27:54 <lambdabot>   <no location info>: parse error on input `>'
21:27:55 <wli> Well, for every huge prime p you find, 2^p - 1 is a candidate for being an even bigger one.
21:27:59 <mle> > "0x" ++ replicate 10778152 'F'
21:28:01 <lambdabot>   "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
21:28:05 <mle> there you go
21:28:24 <centrinia> > ('0':) . ('b':) . replicate 3 $ '1'
21:28:25 <lambdabot>   "0b111"
21:28:26 <pumpkin_> thanks
21:28:32 <pumpkin_> is that an accepted literal in haskell?
21:28:42 <pumpkin_> > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
21:28:42 <monochrom> I get lucky. factorization of 2^(2^8)+1 took my ecm implementation just one minute.
21:28:44 <lambdabot>   1532495540865888858358347027150309183618739122183602175
21:28:45 <wli> 2^(2^(2^(2^p - 1) - 1) - 1) - 1 etc.
21:29:16 <monochrom> I'm doing this so late because I had to fix a silly bug.
21:29:22 <newsham> > (2 :+ 1) * (2 :+ (-1))
21:29:22 <centrinia> > let p = 3 in 2^(2^(2^(2^p-1)-1)-1)-1
21:29:25 <lambdabot>   5.0 :+ 0.0
21:29:26 <Axman6> > logBase 2 12345
21:29:29 <lambdabot>   13.591639216030146
21:29:37 <lambdabot>   thread killed
21:29:39 <centrinia> Hey, where's my computation?
21:29:40 <centrinia>  :(
21:29:42 <Axman6>  > 2^13.591639216030146
21:29:51 <Axman6>  > 2**13.591639216030146
21:29:54 <monochrom> Your computation is trapped in a monad!
21:29:55 <pumpkin_> centrinia: I eated it
21:30:01 <pumpkin_> sry
21:30:08 <monochrom> A monad ate it.
21:30:14 <centrinia> > let p = 1 in 2^(2^(2^(2^p-1)-1)-1)-1
21:30:16 <lambdabot>   1
21:30:22 <monochrom> "My monad ate my functor!"
21:30:38 <Axman6> all monads are functors right?
21:30:40 <centrinia> @let fourtower p = 2^(2^(2^(2^p-1)-1)-1)-1
21:30:43 <lambdabot>  Defined.
21:30:43 <pumpkin_> yup
21:30:43 <Gracenotes> omnomnomnomnomnomnom
21:30:45 <newsham> you got your monoid in my functor.
21:30:49 <newsham> you got your functor in my monoid
21:30:50 <centrinia> > fourtower 1
21:30:53 <lambdabot>   1
21:30:55 <edwardk> Axman6: then it sounds like his monad is a cannibal
21:30:55 <centrinia> > fourtower 2
21:30:57 <lambdabot>   170141183460469231731687303715884105727
21:31:07 <pumpkin_> not as good as ackerman
21:31:11 <centrinia> Hmm, I didn't expect fourtower 2 to be so small.
21:31:13 <pumpkin_> ackermann?
21:31:15 <Gracenotes> liftM, fmapm <*>
21:31:19 <Gracenotes> -m
21:31:31 <wli> Ackermann doesn't produce likely primes.
21:31:36 <Gracenotes> x-.-x
21:32:02 <monochrom> All monads are functors, yes.
21:32:08 <Gracenotes> d--w`'`w--b
21:32:25 <centrinia> There is a polynomial over integers that produces only primes and non-positive integers.
21:32:47 <pumpkin_> wli: I beg to differ!
21:33:11 <newsham> > let iter f 0 = f 1; iter f n = f (iter f (n - 1)); ack 0 = succ; acc m = iter (ack (m - 1)) in ack 1 3
21:33:12 <lambdabot>   * Exception: /tmp/8031377122283600459:71:111-122: Non-exhaustive patterns i...
21:33:14 <pumpkin_> centrinia: I've seen that one
21:33:16 <monochrom> I know how to construct such a polynomial of degree 2.
21:33:22 <pumpkin_> or wait, do you mean the diophantine equation in 26 variables or something?
21:33:28 <centrinia> Yeah.
21:34:08 <monochrom> There is a polynomial over integers that produces all and only the halting programs?  <duck>
21:34:29 <pumpkin_> <quack>
21:34:48 <centrinia> Yeah, that question does seem like quackery. :(
21:36:03 <Gracenotes> I dunno about you, but polynomial's integer roots are even numbers >3 that can't be written as a sum of two primes
21:37:19 <newsham> > let iter f 0 = f 1; iter f n = f (iter f (n - 1)); ack 0 = succ; ack m = iter (ack (m - 1)) in ack 1 3
21:37:20 <lambdabot>   5
21:37:21 <centrinia> Computing with Polynomials for Fun and Profit!!!
21:37:28 <newsham> > let iter f 0 = f 1; iter f n = f (iter f (n - 1)); ack 0 = succ; ack m = iter (ack (m - 1)) in ack 4 2
21:37:43 <lambdabot>   thread killed
21:38:27 <pumpkin_> that one's rather large
21:38:51 <newsham> 2^65536 - 3 says the 'pedia
21:38:57 <pumpkin_> pff peanuts
21:40:12 <hydrapheetz> :t ack
21:40:14 <lambdabot> Not in scope: `ack'
21:40:20 <hydrapheetz> dah
21:40:27 <newsham> ?type let iter f 0 = f 1; iter f n = f (iter f (n - 1)); ack 0 = succ; ack m = iter (ack (m - 1)) in ack
21:40:28 <lambdabot> forall t a. (Num a, Enum a, Num t) => t -> a -> a
21:48:12 <newsham> did the behavior of nubBy change recently?
21:48:26 <newsham> ?src nubBy
21:48:26 <lambdabot> nubBy eq []             =  []
21:48:26 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:50:03 <newsham> > take 5 $ nubBy (\a b -> b `mod` a == 0) [2..]
21:50:06 <lambdabot>   [2,3,5,7,11]
21:50:24 <newsham> In ghci 6.8.10:
21:50:24 <newsham> Prelude Data.List> take 5 $ nubBy (\a b -> b `mod` a == 0) [2..]
21:50:25 <newsham> [2,3,4,5,6]
21:50:35 <newsham> Prelude Data.List> take 5 $ nubBy (\a b -> a `mod` b == 0) [2..]
21:50:36 <newsham> [2,3,5,7,11]
21:50:48 <newsham> argument order is flipped
21:50:57 <newsham> err.  6.10.1 rather
21:55:08 <Star_Fruit> hi! can somebody tell me why I am getting an out of scope error for ``arguments'' in my where statement? http://pastebin.com/m2e82f05c
22:00:53 <adamvo> Star_Fruit: I think you can only make bindings like that with let
22:01:04 <Saizan> Star_Fruit: the where clause for a function definition has in scope only the arguments of the function
22:01:21 <Star_Fruit> oh I see
22:01:22 <monochrom> arguments is local to the do-block, where-clause is outside do-block, not inside.
22:01:23 <Star_Fruit> thank you
22:03:06 <bos> uh oh, the dreaded <<loop>> from the RTS
22:03:07 <lambdabot> bos: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:05:22 <ddarius> bos: Unless you are trying to do something clever, it's probably you shadowing something.
22:05:48 <bos> ddarius: could be.
22:07:26 <tcleval> hi i installed xmonad with 'cabal install xmonad', it compiled fine and installed at $HOME/.cabal/bin/xmonad . when i try to start it. xinit xmonad, i get an error about ~/.xmonad/xmoand-i386-linux doesnt exist. what am i missing here?
22:07:52 <Gracenotes> hm, xmoand?
22:08:09 <glguy> tcleval, in general #xmonad is a better resource for those questions
22:08:53 <tcleval> Gracenote , people can miss type
22:09:04 <Gracenotes> sorry, I thought it may have been copied
22:09:55 <tcleval> it is the first time i am trying xmonad and i am having this problem ^^ . how said
22:11:22 <nj32> what is the meaning of ! - symbols in: data AlexPosn = AlexPn !Int !Int !Int
22:11:27 <pumpkin_> strict
22:11:54 <pumpkin_> it means "NO THUNKS ALLOWED HERE"
22:12:00 <nj32> which means the arguments will be evaluated
22:12:04 <nj32> ?
22:12:16 <nj32> no Thunks, ok
22:12:26 <nj32> thanks
22:12:31 <pumpkin_> np :)
22:13:45 <Gracenotes> data Lala = Blah ![Int]... but, pattern matching (Blah xs) on (Blah [undefined]) should work
22:13:49 <Gracenotes> right?
22:14:06 <Gracenotes> but not pattern matching (x:xs). Oh, I love guessing.
22:14:58 <ddarius> Both would work.  In the latter case, x would be bound to undefined.
22:15:47 <ddarius> Matching (Blah undefined) against (Blah xs) would yield an error rather than xs bound to undefined.
22:16:00 <Gracenotes> hm. and let x = x in (Blah x)?
22:16:32 <ddarius> That's equivalent to (Blah undefined) which is equivalent to undefined.
22:17:25 <Gracenotes> equivalent in what sense
22:17:37 <Gracenotes> the former equivalence
22:17:52 <ddarius> Pick one.  They are denotationally equivalent.
22:18:20 <Gracenotes> operationally...?
22:18:43 <ddarius> Operationally, there is no Haskell 98 context that can tell them apart.
22:27:59 <pumpkin_> @index printf
22:28:00 <lambdabot> Text.Printf
22:32:58 <pumpkin_> @hoogle toLowerCase
22:32:58 <lambdabot> No results found
22:33:04 <pumpkin_> hmm
22:33:08 <pumpkin_> @hoogle String -> String
22:33:08 <lambdabot> Distribution.Simple.Utils dotToSep :: String -> String
22:33:08 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
22:33:08 <lambdabot> Distribution.Simple.Utils lowercase :: String -> String
22:35:15 <mmorrow> mauke: ping
22:36:33 <mauke> mmorrow: pong
22:37:52 <bos> ddarius: that was indeed the problem.
22:38:00 <bos> ddarius: which didn't surprise me at all.
22:40:02 <mmorrow> mauke: hey, why are you pushing as well as putting the args to syscall in e{a,b,c,d}x?
22:40:19 <mauke> because that's where BSD looks for them :-)
22:40:22 <mmorrow> ahhh
22:40:24 <mmorrow> :)
22:41:27 <mmorrow> mauke: hmm, so does bsd not pop them then? because you assume it doesn't (?)
22:41:56 <mauke> I think it doesn't
22:42:02 <mmorrow> ok, sweet
22:49:42 <wli> Finally, it's trying ECM on 2^(2^9) + 1
22:49:59 <hydrapheetz> :t zipWith3
22:50:00 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
22:50:43 <pumpkin_> I've been enjoying liftMx on functions recently
22:51:30 <mauke> > (,) <$> [1,2] <*> "bar"
22:51:31 <lambdabot>   [(1,'b'),(1,'a'),(1,'r'),(2,'b'),(2,'a'),(2,'r')]
22:55:04 <Saizan_> > 17/12
22:55:05 <lambdabot>   1.4166666666666667
22:55:36 <Saizan_> sweet my make -jN clone is only 40% slower than ghc --make at building Cabal
22:55:59 <hydrapheetz> :t (<$>)
22:56:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:56:06 <hydrapheetz> :t (<*>)
22:56:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:56:14 <hydrapheetz> Weird.
23:15:57 <chrisdone> :t fmap
23:15:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:16:13 <chrisdone> :t fmap >>> fmap
23:16:14 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f1 (f a) -> f1 (f b)
23:17:47 <chrisdone> :t flip flip
23:17:48 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
23:18:53 <rovar> need help on this one:
23:18:56 <chrisdone> > flip flip 1 (+) 2
23:18:57 <lambdabot>   3
23:19:07 <rovar> getAllPCs :: [C8.ByteString] -> Net ([PC])
23:19:09 <rovar> getAllPcs names = [ x | x <- (mapM getPC names), x /= Nothing]
23:19:33 <rovar> getPC :: C8.ByteString -> Net (Maybe PC)
23:20:28 <chrisdone> couldn't match [Maybe a] against inferred type Net [Maybe PC]?
23:20:43 <chrisdone> s/Maybe a/Maybe PC
23:21:14 <chrisdone> rovar: what type does a list comprehension have?
23:21:15 <mauke> getAllPCs = liftM catMaybes . mapM getPC
23:21:32 <rovar> chrisdone: [a] ?
23:22:10 <chrisdone> so how can the Net monad be used inside it?
23:22:19 <rovar> wow.. catMaybes is a real function..
23:22:23 <rovar> i was looking for something like that
23:22:25 <pumpkin_> it's an awesome one
23:22:31 <pumpkin_> there's also partitionEithers iirc
23:22:38 <pumpkin_> @index partitionEithers
23:22:38 <lambdabot> bzzt
23:22:40 <pumpkin_> :(
23:22:44 <pumpkin_> @hoogle partitionEithers
23:22:45 <lambdabot> No results found
23:22:48 * pumpkin_ fails
23:23:04 <wli> I've found that writer monads are better ways to do things than catMaybes when the outputs are sparse in e.g. unfoldr's etc.
23:23:07 * chrisdone rates catMaybes: ♥ ♥ ♥ ♡ (4/5)
23:23:13 <rovar> chrisdone: I'm not sure :/
23:23:29 <pumpkin_> chrisdone: does 3/4 == 4/5?
23:23:33 <wli> Or mapAccumL/mapAccumR
23:23:35 <chrisdone> whoops, missed a heart
23:23:53 <chrisdone> :t mapAccumL
23:23:54 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:24:21 <chrisdone> @src mapAccumL
23:24:22 <lambdabot> mapAccumL _ s []        =  (s, [])
23:24:22 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
23:24:22 <lambdabot>    where (s', y ) = f s x
23:24:22 <lambdabot>          (s'',ys) = mapAccumL f s' xs
23:24:45 <wli> I use mapAccumL a lot when I should probably be dragging around a reader monad or a state monad.
23:27:22 <chrisdone> :t uncurry (***)
23:27:24 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
23:28:00 <chrisdone> :t curry (***)
23:28:01 <lambdabot>     No instance for (Arrow (,))
23:28:01 <lambdabot>       arising from a use of `***' at <interactive>:1:6-10
23:28:01 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
23:28:25 <chrisdone> think I'll go to bed now
23:30:19 <pumpkin_> mmorrow: the binutils disassembler for ARM has instructions I've never heard of and the architecture reference manual has never heard of either :P
23:31:00 <wli> > let primeStep n = let cmpStep ((k, ps), m) | n /= k = tell [n] >> modify (Map.insertWith (++) (n*n) [n]) | otherwise = put . Map.unionWith (++) m . Map.fromListWith (++) $ [(k + p, [p]) | p <- ps] in gets Map.minViewWithKey >>= maybe (tell [n] >> put (Map.singleton (n*n) [n])) cmpStep in take 15 . flip evalState Map.empty . execWriterT $ mapM_ primeStep [2..]
23:31:01 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
23:31:10 <wli> For example.
23:35:29 <Gracenotes> omg primes
23:35:48 <pumpkin_> my ARM instruction representation is very typed
23:35:55 <pumpkin_> I'm happy
23:36:00 <pumpkin_> but not as typed as it could be :o
23:36:42 <yitz> pumpkin_: it *is* possible to overdo it you know
23:36:48 <pumpkin_> yup :)
23:36:57 <pumpkin_> this isn't too bad though, I don't think
23:37:11 <pumpkin_> you don't have to jump through hoops to define anything
23:37:28 <pumpkin_> still trying to figure out how to do other parts nicely
23:38:14 <yitz> Gracenotes: ?
23:39:00 <Gracenotes> not much
23:39:58 <wli> Gracenotes: What's "omg" about primes?
23:40:06 * yitz looks back at the channel log and realizes what Gracenotes was talking about
23:40:56 <wli> I used that sieve of Eratosthenes as an example of where the unfoldr-based affair with catMaybes sucks vs. a writer monad.
23:41:59 <wli> qsieve just finished up doing its ECM pass on 2^(2^9) + 1
23:43:09 <rovar> question: I have a BerkeleyDB Db object, the function that creates it needs to run in the IO monad, so there is no way I can return the Db object itself from that function, correct?
23:43:15 <Gracenotes> <wli> monads maps pointless guards list comprehensions <lambdabot> primes
23:43:25 <pumpkin_> rovar: yeah
23:43:28 <yitz> wli: using a map as a priority queue?
23:43:29 <Gracenotes> omg enough
23:43:30 <pumpkin_> well...
23:43:36 <wli> yitz: Yeah.
23:43:44 <wli> Gracenotes: hmm?
23:44:14 <rovar> I would like to put it in a ReaderT so that I can have other functions access it, they only want Db, not IO Db
23:44:15 <adrian_> how do you call this transformation: f = id => f a = a?
23:44:21 <adrian_> reverse eta reduction?
23:44:26 <wli> yitz: Well, more than just as a priority queue; it also has to support some lookup operations etc.
23:44:57 <wli> yitz: e.g. for the collisions in unionWith (++) / insertWith (++)
23:44:57 <Gracenotes> wli: I don't know, I should probably go to sleep. I like the code :)
23:45:11 <dolio> The reverse of eta reduction is eta expansion.
23:45:17 <wli> Gracenotes: It's prettier when not on one line.
23:45:39 <dolio> But I'm not sure that's what you'd call that. It's more like inlining the definition of id.
23:45:55 <yitz> wli: should be possible with just a pq. and then Hinze's zipper tree implementation on hackage ought to be a bit better
23:46:16 <yitz> anyway it also supports lookups
23:46:19 <adrian_> dolio: thank you
23:46:20 <yitz> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/PSQueue
23:46:44 <wli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1906#a1906
23:47:01 <wli> yitz: I don't know. It's more self-contained this way.
23:47:05 <rovar> How would I achive this?   (in this example, db is uses as a Db, but I guess I need it to be an IO Db
23:47:07 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1664#a1664
23:47:09 <dolio> Unless you get there by 'f = id ==> f a = id a ==> f a = a', in which case it's eta expansion plus some kind of reduction.
23:47:21 <rovar> type Net = ReaderT Bot (MS.StateT Stuff IO)
23:48:34 <wli> yitz: It's more of a tradeoff of small self-contained crap you can splatter into a codebase wanting it vs. ultimate efficiency.
23:49:21 <wli> For ultimate efficiency use ONeillPrimes.hs with the fully-inlined priority queue anyway.
23:49:25 <yitz> wli: ok. PSQueue is nice, though, worth getting to know it
23:49:47 <wli> Will do, thanks.
23:50:20 <harblcat> Is there anything in Haskell that could encapsulate a lot of relevant data like an object?
23:50:43 <rovar> harblcat: data records?
23:53:29 <harblcat> Maybe a type declaration, perhaps. I was talking about keeping track of something like a name and a number.
23:54:34 <yitz> harblcat: data Person = P {name, number, address :: String}
23:55:56 <harblcat> Are there any merits in doing it that way instead of with a type declaration such as 'type Person = (String, Int)'?
23:57:59 <adrian_> @pl \a g alpha -> g (alpha `f` a)
23:57:59 <lambdabot> flip (.) . flip f
23:58:37 <wli> data Digit = Zero | One | Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten deriving (Eq, Ord, Read, Show, Bounded, Enum) ; newtype PhoneNumber = PhoneNumber ((Digit,Digit,Digit),(Digit,Digit,Digit),(Digit,Digit,Digit,Digit)) ; data Address = Address { street = String, ...
23:59:06 <rovar> so i have the operation:  liftIO $ db_put [] db Nothing s $ lazyToStrict (encode pc)
23:59:06 <mauke> wait, Ten is a digit now?
23:59:19 <wli> No, I just flubbed it.
23:59:34 <harblcat> depends on what base you are using?
23:59:37 <wli> But trying to encode some of the well-formedness constraints in the types would help.
