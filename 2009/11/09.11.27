00:12:15 <b6> Saizan_: 'unknown symbol: atexit' went away after removing LANGUAGE TemplateHaskell and related code. :(
00:15:46 <crash[`]> can someone help me understand the difference between mapM/liftM with mapM_/liftM_ ?\
00:16:44 <Guest57532> hi
00:16:54 <b6> crash[`]: the *_ functions throw away their values. so hopefully they had side effects. like mapM_ putStrLn ...
00:17:03 <Guest57532> ”„” «Â„
00:17:35 <Guest57532> „‡‡‡‡‡‡‡‡‡‡‡‡‰” «Â„
00:17:43 <b6> Guest57532: please switch to utf-8.
00:19:54 <crash[`]> b6 thank you
00:20:07 <b6> np.
00:20:32 <path[l]> ok Ive run out of ideas
00:20:39 <path[l]> can someone help me speed this up
00:20:43 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5120#a5120
00:21:13 <path[l]> in that link I have the memory profile runs, cost center analysis and test data
00:24:31 <Cale> 1.8 billion entries...
00:25:07 <Cale> I'm impressed that the program only takes a minute to run
00:28:50 <manju> how do I write the condition in the list comprehension as 'x `mod` h > 0 and p `mod` x == 0' ?
00:29:09 <manju> x `mod` h > 0 && p `mod` x == 0
00:29:12 <manju>  ?
00:29:28 <Cale> manju: sure, or just put a comma
00:35:38 <toast-opt> looks like i'm not the only one up late :)
00:35:57 <toast-opt> i noticed docs say that Data.Array and Data.Sequence are experimental?
00:36:12 <toast-opt> should i steer clear as a beginner?
00:36:59 <Tobsan> toast-opt: Data.Array should be fine to use, as should Sequence, however the latter I haven't used myself.
00:36:59 <Cale> toast-opt: Not particularly.
00:37:28 <Tobsan> Haven't arrays been around since the first version of ghc or so?
00:37:29 <Cale> toast-opt: The implementations are pretty solid.
00:37:33 <toast-opt> also, i keep running into 'type ambiguous errors, wondered if i'm using it wrong:
00:37:35 <Cale> They have.
00:37:37 <toast-opt> > let x = listArray (0,5) [ 0.0.. ]
00:37:39 <lambdabot>   not an expression: `let x = listArray (0,5) [ 0.0.. ]'
00:37:49 <toast-opt> oh yeah, can't import in lambdabot
00:37:58 <Cale> > let x = listArray (0,5) [ 0.0.. ] in x
00:38:00 <lambdabot>   array (0,5) [(0,0.0),(1,1.0),(2,2.0),(3,3.0),(4,4.0),(5,5.0)]
00:38:10 <toast-opt> oh, thx
00:38:35 <toast-opt> that's weird.  in ghci, Data.Array.IArray.listArray gives me ambiguous type errors
00:38:38 <Cale> The type is ambiguous though. I think lambdabot has extended defaulting on.
00:38:47 <toast-opt> is that because it's a typeclass, not a type?
00:39:33 <manju> flit (q, h:xs) = h : flit (q [x | x <- xs, x `mod` h > 0 && p `mod` x == 0])
00:39:40 <manju> what is wrong with this ?
00:39:52 <Cale> toast-opt: I get "No instance for Show"
00:40:11 <Niccus> you have base cases right
00:40:12 <Cale> toast-opt: because the type is too polymorphic and I haven't selected a specific type of array to use
00:40:32 <manju> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5121#a5121
00:40:34 <Niccus> also a missing comma
00:40:39 <Cale> ghci> let x = listArray (0,5) [ 0.0.. ] in x :: Array Integer Float
00:40:39 <Cale> array (0,5) [(0,0.0),(1,1.0),(2,2.0),(3,3.0),(4,4.0),(5,5.0)]
00:40:49 <Niccus> ...q, [x | x...
00:40:52 <toast-opt> hmm
00:41:02 <toast-opt> do i have to annotate like that?
00:41:15 <Cale> toast-opt: Normally in your program, the types won't be ambiguous
00:41:24 <toast-opt> Cale, they are in this case
00:41:29 <Cale> toast-opt: It's just that on the ghci commandline it's impossible to tell.
00:41:50 <toast-opt> well, in my program it's ambiguous.  maybe because i'm creating the arrays
00:41:55 <Cale> toast-opt: If they are ambiguous in your program, adding one or two signatures should clear it up.
00:42:00 <toast-opt> i can see how it can infer when someone passes you an array
00:42:25 <Cale> It can also infer based on how the array is used, often.
00:42:36 <toast-opt> i added x::(IArray a Double) => a Int Double
00:42:47 <toast-opt> still ambig.  need to say Array Int Double instead?
00:42:53 <Cale> Well, that won't help it decide which sort of array to use.
00:43:14 <toast-opt> and the way to pick is to use type annotation?
00:43:17 <Cale> yeah
00:43:52 <Cale> It needn't be directly on the array
00:44:02 <toast-opt> that solved it
00:44:18 <Cale> If you go passing x to some other function somewhere which takes an array as a parameter, you can annotate that function and solve the problem too
00:44:34 <manju> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5121#a5122
00:44:37 <manju> in this code
00:44:43 <toast-opt> where else would i put it? my function is (Double -> Double) -> String
00:44:53 <toast-opt> arrays are used internally only
00:45:13 <toast-opt> ok, so normally just annotate functions, but i'm doing a weird case
00:45:14 <Cale> toast-opt: well, if that's the case, then you have no choice
00:45:39 <toast-opt> heh, maybe i should just stick with lists until i get more experieince, and eat the perf penalty
00:45:56 <manju> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5124#a5124
00:46:01 <manju> I get this error
00:46:26 <toast-opt> (i'm doing some image processing, and need to make random access into the sequence -- so i think Array is probably best)
00:46:27 <manju> how do I say that a particular input to a function is a particular type ?
00:47:01 <manju> flit (q, h:xs)  is flit (q ::Int, h:xs)
00:47:06 <manju> something like that
00:47:07 <Cale> path[l]: Maybe the right answer is to find a better algorithm which makes more use of the fact that you have a static set of domain names that you're comparing to.
00:47:17 <Niccus> p = 100 :: Float?
00:47:27 <Cale> path[l]: I'm not really sure what it'd look like though
00:47:53 <Cale> path[l]: Build some kind of trie-like structure?
00:48:23 <mxc> @src foldl'
00:48:24 <lambdabot> foldl' f a []     = a
00:48:24 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
00:49:00 <manju> mxc is that for me ?
00:49:12 <mxc> huh, no was just curious abt something
00:49:28 <manju> Niccus: it didn't work
00:49:44 <Cale> It won't work because you're using mod on p
00:49:49 <manju> Niccus:  No instance for (Integral Float)
00:49:51 <manju> something else blah blah
00:49:53 <Cale> and mod only works with integer-like types
00:50:21 <Cale> but also you're doing sqrt on p, and sqrt only works on floating-point-like types
00:50:47 <Cale> and there's no type which is both Floating and Integral
00:51:10 <Cale> manju: So probably you want  ls = [2 .. round (sqrt (fromIntegral p))]
00:51:16 <manju> ah...ok
00:51:27 <manju> I figured it out
00:51:28 <manju> I converted p to frac
00:53:03 * Axman6 prefers to use takewhile (\n -> n*n < x)[1..], much more efficient
00:54:13 <dibblego> @type join (*) >>> (<x)
00:54:14 <lambdabot> Expr -> Bool
00:54:36 <toast-opt> Expr ?
00:54:41 <Axman6> :t x
00:54:43 <lambdabot> Expr
00:54:53 <Axman6> it's from a package that lets you do this magic:
00:55:03 <Axman6> > foldr f z [a,b,c]
00:55:05 <toast-opt> parsec?
00:55:10 <manju> how do I do command-line arguments ?
00:55:12 <Axman6> no
00:55:13 <lambdabot>   f a (f b (f c z))
00:55:21 <Veinor> @pl \x -> xs !! x
00:55:22 <toast-opt> heh, that's cool
00:55:23 <lambdabot> (xs !!)
00:55:23 <crash[`]> manju: getArgs :)
00:55:24 <uwe> @type foldl
00:55:25 <toast-opt> i saw that earlier
00:55:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:55:29 <Veinor> blah, I forgot sections
00:56:00 <crash[`]> :t getArgs
00:56:02 <lambdabot> Not in scope: `getArgs'
00:56:07 <crash[`]> rawr
00:56:14 <Axman6> IO [String]
00:56:15 <toast-opt> > foldl f u [v,w,x,y,z]
00:56:17 <lambdabot>   f (f (f (f (f u v) w) x) y) z
00:56:43 <toast-opt> > foldl' f u [v,w,x]
00:56:47 <crash[`]> manju: It's in System.Environment, but it's the function getArgs with the type signature Axman6 said: getArgs :: IO [String]
00:56:47 <lambdabot>   mueval-core: Time limit exceeded
00:56:56 <toast-opt> oops
00:57:03 <crash[`]> Since it's a list, you can index into, etc
00:58:29 <manju> ah...cool thanks
00:58:49 <crash[`]> just remember it's in the IO monad :)
00:59:12 <manju> crash[`]: thanks
00:59:12 <Axman6> manju: have you done any IO stuff in haskell yet?
00:59:19 <manju> is there a stringToInt ?
00:59:25 <Axman6> read
00:59:26 <crash[`]> read stringVar :: Int
00:59:27 <Axman6> :t read
00:59:27 <manju> Axman6: yeah I've used print
00:59:29 <lambdabot> forall a. (Read a) => String -> a
00:59:37 <Axman6> manju: anything more complex?
00:59:45 <manju> Axman6: no
01:00:10 <Axman6> well, you may find my IO tutorial helpful if you give me one sec :)
01:00:30 <crash[`]> Axman6 I would like to see that too :)
01:00:36 <toast-opt> axman6, i'd like to see that three
01:00:40 <Axman6> http://random.axman6.com/blog/?page_id=70
01:01:02 <manju> I would like to see that four
01:01:05 <toast-opt> very pretty blog btw
01:01:06 <manju> I mean one
01:01:06 <Axman6> i try to teach it in a way that well let you use IO, without having to actually know what it is
01:01:10 <toast-opt> well designed color scheme
01:01:21 <Axman6> toast-opt: thank the guy who designed it :P
01:01:35 <Axman6> it's one of the community wordpress themes i think
01:01:46 <toast-opt> oh, well, good taste then :D
01:02:25 * manju puts the link in his delicious
01:02:27 <Axman6> it's pretty, but sort of annoying too. i dislike how the sidebar disappears on pages
01:02:52 <crash[`]> Axman6: you mean on load?
01:02:55 <Veinor> oh dear, my code is wrapping on my own screen
01:03:12 <Axman6> i think when i get my macbook pro back, i'll add a more full example to the end, and i think i shall use getArgs to do it
01:03:27 <Axman6> maybe i'll give an example of a whole program
01:04:01 <crash[`]> Axman6: got this bookmarked. I gotta go get some sleep - got an interview for FogCreek tomorrow. :)
01:04:10 <toast-opt> > 2 + 2
01:04:11 <lambdabot>   4
01:04:18 <Axman6> take care crash[`] :)
01:04:18 <toast-opt> > 2 + 2 :: Int
01:04:21 <lambdabot>   4
01:04:37 <toast-opt> you can type annotate expressions too?
01:04:39 <toast-opt> cool
01:04:44 <toast-opt> that's exactly what i was looking for
01:04:53 <toast-opt> > 2 + (2 :: Int)
01:04:55 <lambdabot>   4
01:04:56 <crash[`]> well toast-opt: an expression is equivalent really to a value
01:05:07 <crash[`]> referential transparency and whatnot
01:05:13 <crash[`]> makes sense :)
01:05:17 <toast-opt> fair.  i can annotate values :)
01:05:34 <crash[`]> in terms of grammars and whatnot, maybe not so simple, but you clearly get my point :P
01:05:35 <toast-opt> wasn't sure if it was something special for let only
01:05:44 <toast-opt> yes, very
01:05:45 <crash[`]> nope definitely not
01:05:59 <crash[`]> alright actually leaving now, take care all
01:07:01 * manju finished problem 3 in euler project :-)
01:07:02 <Veinor> I think I need to decrease my emacs font size 2 points
01:07:03 <toast-opt> fun little tutorial
01:07:51 <toast-opt> my first 'aha' moment in haskell was when i first realized how easy it is to mix the pure functional code and the IO code
01:08:59 <Niccus> manju: count the number of trailing 0s for x factorial
01:09:18 <manju> what is the difference between = and <- ?
01:09:37 <manju> Niccus: an example ?
01:09:50 <toast-opt> i think <- does IO
01:09:58 <manju> ok
01:10:17 <Zao> toast-opt: <- retrieves a value from a monadic computation inside a do block.
01:10:20 <Niccus> 10! = 3628800 so it'd be 2
01:10:27 <toast-opt> x <- y -- says 'read the value out of y'.  here, 'y' might be :: IO Int, making x :: Int
01:10:29 <bastl> how can I do a "qualified as" import in ghci ?
01:10:51 <kmc> bastl, you can't directly :/
01:10:55 <kmc> put it in a file and load the file
01:10:58 <toast-opt> zao, that's right, it works on any monad, not jsut IO
01:11:12 <toast-opt> but i'm a dumb novice, keep forgetting :)
01:11:17 <bastl> kmc: hmm
01:11:52 <manju> Niccus: ok
01:12:00 <kmc> manju, toast-opt, here is the translation:   do { x <- a; b }   desugars to   a >>= (\x -> b)
01:12:01 <path[l]> Cale sorry I was away. Back now. Well I suppose thats an option too. Main reason Im trying to look for small things is C and Java codes using that exact algorithm seem to be under the time limit
01:12:09 <kmc> >>= is an operator defined separately for every monad
01:12:10 <toast-opt> you can also do fully qualified names when you use them
01:12:19 <toast-opt> kmc, thx, i suspected as much
01:12:37 <manju> kmc: ok
01:12:38 <bastl> toast-opt: right but they are lengthy sometimes ...
01:12:57 <toast-opt> bastl - better than nothing tho
01:13:03 <bastl> yea
01:13:03 <kmc> manju, = as in "let", or at top level of a file, just establishes another name for something -- it doesn't "do" anything
01:13:15 <path[l]> Cale: do you think it makes sense to do a strict map when Im running through the candidate domains? IBecause there are 7500 of them
01:13:29 <kmc> though actually, i should say it establishes a pattern match which can bind many names, and might be only one case among several
01:14:03 <kmc> @undo do { x <- a; b }
01:14:04 <lambdabot> a >>= \ x -> b
01:14:17 <manju> kmc: ok
01:14:19 <kmc> @botsnack
01:14:19 <lunabot>  :o
01:14:20 <lambdabot> :)
01:14:43 <toast-opt> yeah, the lazy eval pervades.  so 'let x = f y' doesn't say 'compute f y, store in x'.  it really says 'x is a name that, if you should need its value, compute it using f y'
01:15:29 <kmc> yeah.  though lazy eval is really a separate issue from (though a cause for) the separation of evaluation and side-effect performance
01:15:30 <toast-opt> 'let x = readLine' does not read input.  that took getting used to.
01:15:58 <kmc> toast-opt, yes, but wasn't it so logical when you figured it out?  you ask for "x" to be the same as "readLine" :)
01:16:06 <toast-opt> heh, yup
01:16:25 <kmc> even if you force an IO action to normal form (with seq or whatever), it still doesn't perform the IO
01:16:34 <toast-opt> coming from scheme, the 'x now names a funciton' wasn't confusing.  what _was_ confusing is that readLine isn't a function!
01:16:38 <toast-opt> it's just an IO String
01:16:40 <kmc> yes :)
01:16:54 <opqdonut> although, if you unsafePerformIO it and then seq it, it does
01:16:57 <toast-opt> once the IO notion clicked, it made perfect sense
01:17:28 <kmc> the brilliance is that "function" and "side effect bundle" are two different type constructors, which can be used inside each other's parameters
01:17:54 <toast-opt> kmc, yeah, i mentioned that earlier.  that was the first 'aha' moment i had with haskell
01:18:02 <Axman6> toast-opt: the messed up thing is, that readLine _is_ a function, and technically a pure one at that
01:18:11 <kmc> toast-opt, then you probably knew more when starting than i did ;)
01:18:15 <kmc> because my mind was blown way before then
01:18:20 <kmc> but yes it's a big one
01:18:24 <toast-opt> i'd done lazy evaluation before with scheme, but i didn't realize what it implied for types until this week with haskell
01:18:46 <toast-opt> axman - i mean, it isn't an (a->b) kind of thing
01:18:57 <Axman6> @src IO
01:18:58 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
01:19:05 <Axman6> it sort of is :P
01:19:05 <path[l]> anyone know how I can do a list.map in a strict manner?
01:19:07 <toast-opt> oh, heh
01:19:07 <kmc> for writing good imperative code, it's essential to be able to pass IO actions as first-class value.  something which the supposed gold standard languages of imperative programming don't even support.
01:19:09 <toast-opt> nm :)
01:19:16 <kmc> Axman6, not in H98
01:19:27 <toast-opt> that's hilarious
01:19:42 <toast-opt> what is 'newtype'?
01:19:50 <kmc> RealWorld is described by the GHC docs as "deeply magical"
01:19:53 <toast-opt> heh
01:20:15 <kmc> toast-opt, in standard Haskell you aren't allowed to see the constructors of the IO type
01:20:18 <toast-opt> which is funny, because programmers in the real world describe haskell as 'deeply magical'
01:20:23 <Axman6> toast-opt: i actually really like that definition, lets you see how IO can be "pure". basically, RealWorld is a type that is treated as being different each time it is seen, repersenting the realworld changing. since it's always going to be unique, IO ius still pure :P
01:20:26 <kmc> that's their loss ;)
01:20:33 <toast-opt> axman6, agreed
01:20:37 <kmc> toast-opt, "newtype" is like an optimized "data", for the case where you have one ctor with one field
01:21:05 <toast-opt> kmc, ah, a 'unique typedef' of sorts.  makes sense
01:21:10 <kmc> it uses the same runtime representation as the underlying field.  so you get the type safety of a new type (unlike a "type" synonym), with no runtime overhead
01:21:19 <toast-opt> sorry, i sometimes speak in C.  it's a speak impediment
01:21:25 <toast-opt> i'm seeking therapy for it
01:21:41 <Axman6> toast-opt: if you say 'newtype Cost = Cost Int', then the code generated will be exactly the same as if you just used Int everywhere you wrote Cost. there's no overhead at all
01:21:46 <kmc> toast-opt, if you know how "data" works, you can mostly think of "newtype" as a more efficient version that works in only some cases
01:22:14 <toast-opt> kmc, so 'data Cost = Cost Int' does not get the efficiency boost?
01:22:20 <Axman6> nope
01:22:21 <kmc> correct
01:22:27 <toast-opt> why not?
01:22:28 <kmc> there is a small difference in the observable semantics
01:22:32 <shambler> marking this to read later: funstuff6689289
01:22:33 <Axman6> (although, i can't see any reason it couldn't)
01:22:38 <kmc> toast-opt, because it will use an extra bit of memory to store the "Cost" constructor
01:22:48 <kmc> it might, under GHC get optimized away anyway, in some situations
01:22:51 <toast-opt> oh, because other code might not know that it is a simple single constructor case
01:23:10 <toast-opt> nm, i see why it might be easier to optimize
01:23:16 <kmc> toast-opt, in the "data" case,  "undefined" and "Cost undefined" are two distinct values.  you can write code that errors on the first and not the second
01:23:45 <Axman6> with newtype, you can only have newtype A = B C, no newtype X = Y Z | Q R
01:24:05 <kmc> with the "newtype" definition this is not the case, because it's (at runtime) the same as the underlying datatype
01:24:41 <kmc> people sometimes translate "data X = Y A B C" to "newtype X = Y (A, B, C)", but they're usually missing the point
01:24:47 <toast-opt> kmc, so it carries a semantic difference in this edge case... that with newtype, 'Cost undefined' and 'undefined' are the same case?
01:24:55 <kmc> correct
01:25:04 <toast-opt> heh, yeah
01:25:13 <Axman6> it's like a type safety tag in a way. you can use more basic types like Int to repersent various different things, like Cost and Weight, and you can make sure that they are never used in the same place by accident
01:25:15 <toast-opt> they saved on the type, put just shifted the cost into the tuple
01:25:22 <kmc> yeah exactly
01:25:27 <kmc> and uglier syntax too
01:25:33 <toast-opt> way uglier
01:25:39 * kmc doesn't like tuples, in general
01:26:10 <Axman6> i use them in things involving lists, where i can be fairly sure they'll get optimised out
01:27:21 <toast-opt> or when you need a really cheap little data type as a hack, glue between two parts
01:28:15 <kmc> yeah, when they're introduced and eliminated in the same function pipeline
01:28:16 <toast-opt> like, fold for example.  foldl' f (extraBit, 0) [0,2..]
01:28:20 <kmc> yeah exactly
01:28:27 <Axman6> i really dislike it when people write things like data Foo = Foo (Int, Char). i always prefer Foo Int Char
01:28:40 <toast-opt> rather, fst $ foldl' f (extraBit, 0) [0..]
01:28:53 <kmc> yeah, the former is clearly wrong in almost any circumstance
01:28:57 <kmc> it's not just notational
01:29:12 <toast-opt> maybe a C programmer who hates not seeing parens
01:29:14 <toast-opt> and commas
01:29:26 <kmc> in C++ defining your own aggregate type takes like 40 lines of code across 3 files
01:29:29 <toast-opt> let add (a,b) = a + b
01:29:40 <Axman6> well, there's an extra indirection in the former, which all C programmers should want to avoid!
01:29:45 <toast-opt> kmc, no, it does not.  more like 20, and 2 files
01:29:51 <toast-opt> maybe 30
01:30:06 <toast-opt> only 30 if you also need to copy values too
01:30:14 <kmc> well that's much better then
01:30:32 <toast-opt> heh, it always makes me laugh that i have to think about that when creating a simple record type
01:30:40 <toast-opt> "will i be copying this later"
01:30:48 <kmc> laugh or cry, you choose
01:30:53 <kmc> i say 3 files because you usually have to change your build scripts as well
01:31:09 <kmc> i once wrote a stupid little preprocessor that would chop up a single file into multiple hpp and cpp files and autogenerate the Makefile
01:31:10 <toast-opt> hey, as long as they want to pay me to write those 30 lines
01:31:50 <toast-opt> i prototype it in python, then spend 5 times as long pounding out C++
01:32:17 <toast-opt> sorry, shouldn't be ragging on C++ so much :)
01:32:26 <path[l]> anyone good at perf optimisation in haskell? Im sure there should be some simple change I can make to drop this time by  a factor of 2 or 4
01:32:40 <kmc> so if you were a sculptor and someone commissioned you to sculpt a marble statue, using only a rusty spoon, you'd be okay with that?
01:32:43 <toast-opt> i like a lot of things about C++.  it's just berevity ain't one of them
01:32:59 <Maddas> kmc: hey, if they pay by hour
01:33:06 <toast-opt> kmc, i'd sculpt it for real first
01:33:19 <toast-opt> if they want to pay me to dup it in rusty spoon, more power to them
01:33:27 <kmc> personally i'm sick of using awful tools, don't care what it pays
01:33:34 <Maddas> :)
01:33:39 <toast-opt> kmc, where do you work?
01:33:47 <kmc> i see it as sort of a matter of craftsman's pride
01:33:51 <kmc> toast-opt, a software company ;P
01:33:55 <toast-opt> heh
01:33:59 <toast-opt> np
01:34:12 <kmc> path[l], sure, hpaste the code and we'll check it out
01:34:18 <toast-opt> just mean that you must be lucky to work in haskell
01:34:19 <path[l]> software craftmanship manifesto?
01:34:28 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5120#a5120 <--- here
01:34:49 <kmc> i mean i can also respect the attitude of "whatever pays", to a degree
01:35:01 <toast-opt> kmc, that's not really it
01:35:07 <Axman6> path[l]: i'll take a look
01:35:26 <kmc> sometimes other aspects of the job are more important
01:35:29 <toast-opt> i love what i do.  but i'm sure there are things i'd love more
01:35:54 <Axman6> path[l]: how large are these UArrays?
01:36:30 <toast-opt> ah, i know.  i'd rather carve marble statues with rusty spoons than use even the best chisels to cut bricks
01:36:42 <toast-opt> C++ might be a rusty spoon, but...
01:36:42 <path[l]> about 32 chars at most
01:37:12 <kmc> so the quality / interestingness of what you're making outweighs how you're making it?
01:37:14 <Axman6> hmm. and do you have a lor of them?
01:37:24 <kmc> that's also respectable
01:37:25 <toast-opt> kmc, to a degree
01:37:26 <path[l]> yeah I have 2500 + 7000
01:37:27 <path[l]> in total
01:37:31 <toast-opt> obviously there's a limit
01:37:40 <toast-opt> and i'm free to prototype and design using whatever i want
01:37:56 <toast-opt> as long as what i do produces C++ code others can grep
01:38:05 <kmc> i guess what i'm saying is that, all else being equal, writing mundane code is a lot more tolerable and maybe even entertaining in a good language.  partially because it's so much quicker
01:38:27 <Axman6> path[l]: hmm, looks like you're creating a lot of arrays in memf, is that right?
01:38:48 <path[l]> Axman6: my understanding is that array is created only once
01:38:49 <Axman6> well, one array per call to memf, but still, there's a lot of calls to distance
01:39:03 <path[l]> yeah
01:39:16 <path[l]> actually I added memf and got a signifiicant speed up
01:39:16 <kmc> around any domain problem there is always a shell of herding and babysitting data, and C++ does its best to make that part take as long as possible
01:39:19 <Axman6> no a new one will be created every time distance is called
01:39:27 <kmc> even if the core is mundane i'd rather focus there
01:39:40 <Cale> Axman6: That's the memo table for f
01:40:03 <toast-opt> kmc, that might make a great button slogan
01:40:08 <Maddas> kmc: Solving a boring problem in an interesting language is still boring
01:40:10 <Cale> Though... it's a little lucky that it works
01:40:20 <path[l]> Axman6:  you're right. One per call to distance
01:40:21 <Axman6> path[l]: bleh, again, i'd love to help you more (i will help you tomorrow if i have time), but once again have to go and pick up my girlfriend
01:40:27 <path[l]> I meant recursively it doesnt
01:40:31 <path[l]> Axman6:  ok np, thanks
01:40:35 <kmc> path[l], have you seen data-memocombinators ?
01:40:41 <path[l]> Cale: why lucky? What is it that I did wrong?
01:41:01 <Axman6> path[l]: what's the speed like if you don't use memf?
01:41:06 <Cale> path[l]: You're technically relying on GHC to lift the definition of the array out of the definition of that function
01:41:30 <Cale> path[l]: (realising that it is independent of i and j)
01:42:03 <Cale> Otherwise, it will be redefined every time the memf function is called
01:42:11 <path[l]> kmc:  yeah but for this problem I can't use anything thats not in ghc. So my option was to either steal the code or do it that way
01:42:18 <kmc> ah
01:42:25 <Axman6> path[l]: not sure if it would help, but it may reduce the amount of allocation if you replace the minimum on that list with min (memf...) (min (memf...) (memf...))
01:42:35 <kmc> by ghc you mean the Haskell Platform libraries? or the smaller set that comes with ghc itself?
01:42:52 <path[l]> ah I see, so whats the right way to do it and not do it in a way that requires ghc to be smart
01:42:52 * kmc isn't too sure what the latter comprises these days
01:43:07 <path[l]> kmc: I think its the platform libraries, since I can use import?
01:43:10 <Cale> path[l]: define the array as a constant rather than a function
01:43:29 <Cale> path[l]: You can still keep the memf function, but lift the (A.array ...) out of it
01:43:38 <Axman6> ah yes, good call Cale
01:43:40 <path[l]> Axman6: sorry I didnt understand. Do you mean make a tuple?
01:43:53 <path[l]> Cale: but the array depends on orig and new doesnt it
01:44:02 <kmc> path[l], import works on the module level; i'm talking about packages (collections of modules for distribution)
01:44:07 <Cale> path[l]: It does, so you can only lift it into the containing where clause
01:44:15 <path[l]> ah
01:44:16 <path[l]> ok
01:44:23 <kmc> ghc comes with some packages (like base and mtl) that provide some modules
01:44:26 <Axman6> Cale: speak noob friendly english man :P
01:44:43 <kmc> there are other packages in the Haskell Platform that you don't get from installing ghc alone
01:44:53 <Axman6> anyway, got to go. later all!
01:44:56 <path[l]> kmc hmm wow ok Im not really sure then. I should check
01:45:10 <path[l]> bye Axman6 , sorry was rerunning to tell you the time without memoisation =p
01:45:10 <Cale> path[l]: Oh, and it's probably a good idea to make extra sure that the array has a monomorphic type (particularly, that its type doesn't have any typeclass constraints, but that's probably already the case)
01:45:12 <kmc> anyway memocombinators isn't in either :/
01:45:38 <kmc> hehe MR again
01:45:44 <Cale> You're using Data.Array rather than Data.Array.IArray, and lots of type signatures, so you're probably safe.
01:45:56 <path[l]> Cale: could you explain that last bit a bit more? About monomorphic type?
01:46:18 <Cale> path[l]: Things which are typeclass polymorphic are really functions (of the typeclass dictionary)
01:46:28 <Cale> and so they'll be recomputed every time they're used
01:46:32 <path[l]> kmc : I was wondering if rather than this approach to memoisation it makes sense to just copy the code of Data.memocombinators into my code. But only if I can expect a big speed up
01:46:43 <path[l]> oh I see
01:46:45 <toast-opt> gotta go.  thx again for all the help!  kmc, axman, um, everyone else i'm forgetting.
01:47:01 <toast-opt> don't think i said thx yet, so yeah
01:47:15 <path[l]> Cale: can you give me an example?
01:47:16 <kmc> path[l], > let x = 2 + 2 in (x :: Integer, x :: Float)
01:47:31 <Cale> path[l]: Sure...
01:47:36 <kmc> x looks like a nice memoized 4
01:47:38 <kmc> but actually it has a (Num a) => in its type, and will be computed twice
01:47:41 <Cale> Oh, kmc has already done it :)
01:47:46 <path[l]> ah ok
01:47:51 <path[l]> heh
01:48:02 <Cale> Even if those are both x :: Integer it will be recomputed if x itself has a polymorphic type.
01:48:09 <path[l]> ok
01:48:26 <toast-opt> oh, ouch, but cool
01:48:32 <kmc> because in a dict-passing impl of typeclasses it becomes >  let x num = (addUsingDict num) 2 2 in (x dictForInteger, x dictForFloat)
01:48:40 <kmc> and now it's a function
01:48:55 <Cale> let x :: (Enum a, Num a) => a; x = product [1..10000] in (x :: Integer, x :: Integer)
01:48:59 <toast-opt> that explains how stuff like fromIntegral works
01:49:09 <Cale> (try that in ghci, and you can see the wait while it gets recomputed)
01:49:23 <kmc> there's something called the "dreaded monomorphism restriction" which is supposed to prevent this
01:49:40 <Cale> (but the MR mostly just creates other problems)
01:49:57 <path[l]> Cale, kmc do those memory graphs suggest any obvious thing I should fix? Especially with regard to laziness
01:50:10 <kmc> hmm i think i missed the graphs
01:50:21 <path[l]> Ive linked them below the code
01:50:31 <path[l]> along with the costCenter thing
01:50:41 <kmc> ah
01:50:42 <path[l]> I dunno why I camel cased that
01:50:43 <path[l]> lol
01:50:59 <path[l]> Ive also linked to the input I created using random numbers
01:53:01 <Cale> The memory usage looks fairly well-behaved.
01:53:38 <Cale> Though the jaggies possibly indicate that something could be deforested
01:53:55 <path[l]> ah I was wondering how to understand that
01:54:05 <path[l]> deforested meaning?
01:54:39 <Cale> Well, in the sense of "removing trees" or intermediate data structures.
01:54:50 <path[l]> ah
01:55:29 <Cale> In this case, I think a list is being iterated over as it's created, and those list cells become garbage right after.
01:55:40 <path[l]> Im guessing its all those Arrays too?
01:55:44 <path[l]> one for each element of the list
01:55:53 <Cale> from the -hd it looks like (:) is the one
01:56:17 <path[l]> really? how do you tell, they all have spikes
01:56:25 <Cale> It's a stacked graph
01:56:34 <Cale> (probably not the best choice of graph here)
01:56:38 <Cale> Bin is a thin flat line along the bottom
01:56:57 <path[l]> hmm
01:57:00 <Cale> then (:) is jaggy, and then everything on top is jaggy because it's sitting on top of that
01:57:10 <path[l]> ok
01:57:33 <path[l]> should I try to recreate a different kind of graph?
01:57:49 <Cale> I'm not sure hp2ps has an option
01:58:05 <path[l]> oh ok
01:58:11 <Cale> But it makes the most sense for it to be a list
01:58:29 <path[l]> does it make sense to try and do the map in a strict manner?
01:58:41 <path[l]> (I guess not since the memory seems to be getting freed)
01:58:43 <Cale> Which map?
01:58:55 <path[l]> the map over the big list of candidate domains
01:59:00 <path[l]> 7500 strings
01:59:28 <Cale> oh hey
01:59:37 <Cale> er...
01:59:42 <Cale> oh, it's dead code
02:00:01 <path[l]> oops, which part
02:00:04 <aleator> ld: library not found for -lHSrts_debug_p
02:00:09 <aleator> What does this mean?
02:00:15 <Cale> I was thinking that you were computing map (distance candidate) domains in surcharges as well in surcharge
02:00:33 <Cale> But you don't use 'distances' anywhere in surcharges.
02:00:57 <Saizan> aleator: i think that rts has to be enabled at ghc configure time
02:01:18 <path[l]> eh heh the where clause is dead you're right
02:01:57 <aleator> Saizan: Ah.. So it is compile ghc-time again :)
02:02:49 <path[l]> anyway yeah I meant the map in surcharges which runs over candidates. Does it make sense to make that happen strictly
02:03:27 <jkff> Saizan: May we continue the discussion about polymorphism? For example, you said that "OO usually doesn't have polymorphism, just subtyping": what definition of polymorphism are you using? IMO, subtyping is one of the forms of polymorphism
02:03:48 <Cale> I can't imagine it helping. Making map strict usually just results in more memory usage.
02:04:14 <path[l]> well I was wondering if preventing gc might mean the program executes faster
02:04:31 <Cale> path[l]: Oh, can you control what options your program is run with?
02:04:49 <path[l]> sadly no :/
02:05:12 <path[l]> if there is an option that would help universall, I can suggest it to the admins here
02:05:20 <path[l]> across all attempts to do such things in haskell
02:05:31 <path[l]> afaik right now all they have is they compiled with O2 and then run
02:05:34 <Cale> oh, well, not really
02:06:23 <Cale> If you could pass RTS options, then you could do things to tweak the garbage collector and see how it helps
02:06:40 <path[l]> well I can always do it on my machine to test a hypothesis
02:06:51 <path[l]> and then if thats true, see if the code can be modified to actually utilise that
02:07:51 <Cale> I wonder what rules are firing.
02:08:43 <path[l]> dun dun dun
02:08:45 <path[l]> split
02:08:46 <Cale> path[l]: Run ghc-core like you would ghc to compile it with -O2, and see if there's a rule in there called map/filter (there should be)
02:09:01 <path[l]> huh?
02:09:03 <Cale> er, or filter/map
02:09:07 <path[l]> ghc-core -O2 ?
02:09:09 <Cale> yeah
02:09:28 <Cale> erm...
02:09:41 <Cale> ghc-core -- -O2 foo.hs
02:09:49 <path[l]> I dont have a ghc-core
02:10:07 <Cale> cabal install ghc-core
02:10:21 <path[l]> ok
02:10:28 <path[l]> what is ghc-core btw?
02:10:51 <Cale> It's basically just a fancy colouriser for a bunch of information that ghc can dump about the intermediate processing that it does
02:11:01 <Cale> ghc -ddump-simpl  will be similar
02:12:01 <path[l]> sorry battling my proxy to use cabal
02:12:06 <path[l]> done now
02:12:07 <path[l]> installing
02:12:29 <Cale> But ghc-core formats the output nicely and passes all the necessary options to get the generated core and assembly
02:12:56 <path[l]> hmm I had a failure
02:13:01 <Cale> huh
02:13:04 <path[l]> pcre-light-0.3.1 failed during the building phase. The exception was
02:13:14 <path[l]> exit: ExitFailure 1
02:13:17 <Cale> nice
02:13:18 * hackagebot upload: hesql 0.6 - Haskell's embedded SQL (ChristophBauer)
02:13:21 <Cale> heh
02:13:35 <Cale> (maybe libpcre-dev isn't installed?)
02:13:53 <path[l]> whats that?
02:13:59 <path[l]> some unix lib?
02:14:04 <Cale> yeah
02:14:13 <Cale> perl-compatible regular expressions
02:14:23 <Cale> But try -ddump-simpl
02:14:31 <Cale> (with plain ghc)
02:14:41 <Cale> oh, actually
02:14:46 <Cale> -ddump-rules
02:15:00 <path[l]> installing pcre
02:15:05 <path[l]> but let me do that meantime
02:15:45 <path[l]> ==================== Transformation rules ====================
02:15:46 <path[l]> Local rules
02:15:46 <path[l]> Imported rules
02:15:50 <path[l]> the others are empty
02:15:55 <path[l]> specialisations
02:15:57 <Cale> huh
02:15:58 <netinho2lol> hey guys
02:16:11 <Cale> This is with -O2?
02:16:15 <path[l]> ghc -ddump-rules -O2 --make ddilemna.hs <--- thats what I ran
02:16:18 <netinho2lol> I have a question about documenting with Haddock :)
02:17:11 <Cale> oh, maybe that's not the option I wanted.
02:18:13 <Cale> -ddump-simpl-stats
02:18:18 <Cale> that's the one
02:18:28 <netinho2lol> haddock -v -d -h Lol.hs -> Warning: Lol: could not find link destinations for: GHC.IOBase.IO
02:18:37 <netinho2lol> i know it's just a warning
02:18:49 <netinho2lol> but how can I link to the site?
02:19:52 <path[l]> I got nothing
02:19:53 <path[l]> as output
02:20:02 <path[l]> ghc -ddump-simpl-stats -O2 --make ddilemna.hs
02:20:41 <Cale> oh, kill the .o file
02:21:10 <path[l]> ah
02:21:48 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5125#a5125
02:22:00 <Cale> It's just interesting to see which rules fired. Often the names are less than helpful, but you can usually tell where list fusion is happening
02:22:22 <Cale> ah, that looks reasonably good
02:23:08 <Saizan_> netinho2lol: e.g. --read-interface=/usr/local/share/doc/ghc/libraries/array,/usr/local/share/doc/ghc/libraries/array/array.haddock for the array package in this case
02:23:17 <Saizan_> netinho2lol: the first can be an url, i think
02:24:06 <netinho2lol> I don't understand you, Saizan_ :P
02:24:24 <netinho2lol> it's to put that where?
02:24:42 <Saizan_> it's a flag to haddock
02:25:38 <netinho2lol> haddock --read-interface=/usr/local/share/doc/ghc/libraries/array,/usr/local/share/doc/ghc/libraries/array/array.haddock -v -d -h Lol.hs like this?
02:25:59 <Cale> path[l]: If you look in the source code for the libraries, you can find where the various rules are defined:
02:26:05 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#filter
02:26:11 <Cale> "filter"     [~1] forall p xs.  filter p xs = build (\c n -> foldr (filterFB c p) n xs)
02:26:39 <path[l]> hmmm
02:27:15 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#map
02:27:17 <Saizan_> netinho2lol: yes, though you'd have to use one for each used package, and change the first location to the corresponding url on hackage
02:27:39 <Saizan_> netinho2lol: a more pratical way is to cabalize your project and then use cabal haddock --html-location="http://hackage.haskell.org/packages/archive/\$pkg/\$version/doc/html/"
02:28:00 <Cale> path[l]: There are a bunch of rules to eliminate intermediate lists between things like pairs of maps
02:28:17 <path[l]> ah ok
02:28:23 <path[l]> makes sense
02:28:27 <path[l]> I was wondering about that
02:30:17 <netinho2lol> Saizan_: too much effort for such a tiny set of functions :P
02:30:22 <Cale> Wow, the core for this program is even more unreadable than usual
02:30:28 <netinho2lol> thanks for the assistance, Saizan_!
02:31:22 <Cale> I guess it's a sign that the inliner is doing its job
02:32:22 <path[l]> lol
02:33:12 <Cale> Oh, and I guess it's partly UArray's fault.
02:33:38 <mmx166mhz> Can sb help me?: I have a list of lists, and have to determine the list who has the biggest first element...?
02:33:43 <aoshdas> hello, i am able to read a file in haskell (i just started with it...), but i cant get to work out how to split the lines (as in, there's \n between lines)
02:33:48 <aoshdas> can somebody help?:)
02:33:57 <mmx166mhz> yes, use lines and words
02:34:05 <mmx166mhz> http://www.zvon.org/other/haskell/Outputprelude/index.html
02:34:08 <mmx166mhz> look at words and lines
02:34:12 <Cale> mmx166mhz: Perhaps use maximumBy
02:34:26 <mmx166mhz> aha, lets have a look at that
02:34:31 <EvilTerran> mmx166mhz, btw, the "official" documentation is at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
02:34:39 <mmx166mhz> aha, thanks
02:34:50 <aoshdas> mmx166mhz, it doesn't work here because i use an IO string :s
02:34:55 <aoshdas> only works with normal strings
02:35:03 <Cale> aoshdas: So run the IO String first
02:35:22 <Cale> aoshdas: an IO String is not a String, but an action which if you were to run it would produce a String
02:36:00 <Cale> aoshdas: So in a do-block, you can write  do s <- myIOStringThingy; ... do stuff with s ...
02:36:06 <Cale> aoshdas: and s will be a String there
02:36:22 <Cale> aoshdas: The do-block as a whole will be a value of type IO t for some t
02:36:38 <EvilTerran> aoshdas, are you familiar with the difference between "commands" and "expressions" in some imperative programming languages?
02:37:36 <aoshdas> yes
02:37:39 <EvilTerran> ie, commands tend to actually do things, while expressions just return a value
02:38:08 <aoshdas> yes i do, got some experience with java...but not too much
02:38:11 <EvilTerran> in haskell, things of type IO <whatever> are commands; you can get something of type <whatever> out of them as Cale described, using a do-block
02:38:33 <Cale> aoshdas: http://www.haskell.org/haskellwiki/Introduction_to_IO is a quick intro
02:38:47 <mmx166mhz> How to make a comparison function?
02:38:55 <EvilTerran> ?src Ordering
02:38:56 <lambdabot> data Ordering = LT | EQ | GT
02:38:56 <Cale> mmx166mhz: A lambda would work
02:39:06 <mmx166mhz> I want to use maximumBy
02:39:06 <Cale> mmx166mhz: you should also know about compare
02:39:11 <Cale> > compare 5 6
02:39:13 <lambdabot>   LT
02:39:14 <EvilTerran> ?type maximumBy
02:39:16 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
02:39:25 <aoshdas> ill look at it, thanks Cale, EvilTerran :)
02:39:31 <Cale> There's also a function called comparing which is handy
02:39:35 <Cale> :t comparing
02:39:37 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
02:39:42 <Cale> It's in Data.Ord
02:39:48 <mmx166mhz> I want the following function: aFunction [12,767] [13,122] must return [12,767]
02:40:04 <Cale> mmx166mhz: for what reason?
02:40:11 <mmx166mhz> (ie: if the list which has the BIGGEST 1st element)
02:40:20 <mmx166mhz> smallest sorry
02:40:21 <Cale> but isn't 13 bigger than 12?
02:40:23 <Cale> oh
02:40:24 <mmx166mhz> :P
02:40:40 <Cale> So minimumBy
02:40:50 <mmx166mhz> how to write down this function using minumumBy?
02:41:01 <Cale> > minimumBy (comparing head) [[12,767], [13,122]]
02:41:03 <lambdabot>   [12,767]
02:41:07 <mmx166mhz> aha!
02:41:29 <mmx166mhz> so comparing head is actually ...?
02:41:35 <mmx166mhz> a function?
02:41:39 <Cale> yes
02:41:42 <mmx166mhz> ok
02:41:50 <Cale> > minimumBy (\xs ys -> compare (head xs) (head ys)) [[12,767], [13,122]]
02:41:52 <lambdabot>   [12,767]
02:42:07 <Cale> there's how it looks without "comparing"
02:42:10 <mmx166mhz> ok
02:42:34 <poucet_> Cale: erm, lists being ordered lexicographically, that seems like overkill
02:43:03 <Cale> I suppose so.
02:43:14 <Cale> It does save comparisons, at the expense of being more dangerous
02:43:33 <Cale> mmx166mhz: Note that this fails miserably if there's an empty list somewhere in there
02:43:45 <mmx166mhz> I will check for that seperately;)
02:44:01 <Cale> mmx166mhz: and as poucet_ points out, you could just use the normal comparison on lists
02:44:09 <Cale> > minimum [[12,767], [13,122]]
02:44:11 <lambdabot>   [12,767]
02:44:23 <mmx166mhz> oh, indeed!
02:44:30 <Cale> When the first element matches, it'll compare the next
02:44:36 <Cale> > minimum [[12,767], [12,100]]
02:44:38 <lambdabot>   [12,100]
02:44:40 <netinho2lol> Saizan_: it's not making the files :(
02:44:55 <mmx166mhz> minimum [["12","767"],["13","122"]]
02:45:05 <Cale> careful
02:45:19 <mmx166mhz> hmm, ok
02:45:20 <Cale> If they're strings, you'll get alphabetic comparisons
02:45:20 <mmx166mhz> thanks
02:45:26 <Cale> > minimum [["12","767"],["13","122"]]
02:45:28 <lambdabot>   ["12","767"]
02:45:35 <Cale> > minimum [["121","767"],["13","122"]]
02:45:37 <lambdabot>   ["121","767"]
02:46:22 <mmx166mhz> I have a list of Integers in string representation, so I'll read them first I gues
02:46:29 <Cale> yeah
02:46:38 <netinho2lol> maybe I have to use   --gen-index
02:46:40 <notweebl> i have a list of tupels which i want to sort by the length of the first element, i was trying sortBy (comparing length fst) list but didn't work
02:46:55 <Cale> sortBy (comparing (length . fst))
02:47:21 <Cale> notweebl: but note that this will recompute the lengths possibly many times
02:47:41 <Saizan_> netinho2lol: --gen-index is to generate an index like the one here http://www.haskell.org/ghc/docs/latest/html/libraries/ , not the actual documentation
02:47:51 <Cale> notweebl: You might want to precompute the lengths and tuple them on before sorting, and then remove them afterward
02:48:09 <Saizan_> netinho2lol: you need to pass it --html though
02:48:30 <Saizan_> netinho2lol: if you want the html output at least
02:48:41 <netinho2lol> but I am passing with html
02:48:59 <notweebl> it's a tuple with 3 elements
02:49:06 <mmx166mhz> how to apply a function to a list, but only to the first element..?
02:49:14 <Cale> > map snd . sortBy (comparing fst) . ap zip (length . fst) $ [("hello", 5), ("hi", 8)]
02:49:16 <lambdabot>   Couldn't match expected type `[b]'
02:49:16 <lambdabot>         against inferred type `GHC.Types...
02:49:43 <netinho2lol> haddock -i /usr/share/doc/ghc6-doc/libraries/base/base.haddock -v -d -h Lol.hs -> Warning: Lol: could not find link destinations for: GHC.Types.Int GHC.Types.Char
02:49:49 <Cale> > map snd . sortBy (comparing fst) . ap zip (map (length . fst)) $ [("hello", 5), ("hi", 8)]
02:49:52 <lambdabot>   [5,2]
02:50:04 <Cale> oh, blah :)
02:50:11 <Cale> > map fst . sortBy (comparing snd) . ap zip (map (length . fst)) $ [("hello", 5), ("hi", 8)]
02:50:13 <lambdabot>   [("hi",8),("hello",5)]
02:50:18 <netinho2lol> but it doesn't generate pages with the "outside" things
02:50:25 <netinho2lol> like IO ()
02:50:31 <notweebl> but it's (S, S, S)
02:51:27 <Saizan_> netinho2lol: pages with the outside things? what do you mean?
02:52:56 <netinho2lol> Saizan_: like, there's a function output that goes like this make :: Lol -> IO ()
02:53:19 <netinho2lol> if I click in Lol it goes to the definition of lol, which is in the file itself
02:53:24 <netinho2lol> but if I click in IO ()
02:53:41 <notweebl> Cale: the list is like ("five", "two", "exactly")
02:53:41 <notweebl> but with more elements
02:54:18 <netinho2lol> Saizan_: but if I click in IO () it goes to file:///home/luis/Documents/lol/proj/System-IO.html#t%3AIO
02:54:25 <netinho2lol> which wasn't generated
02:55:10 <Saizan_> ok, haddock won't generate docs for the used packages, it can link to them if you pass the base location/url of their html documentation paired with the interface, like i showed you above
02:55:32 <netinho2lol> oh
02:56:19 <netinho2lol> so, if I send the files and documentation to someone that doesn't have linux or doesn't have the haddock documentation...
02:56:24 <netinho2lol> puff, right?
02:56:53 <Saizan_> you can create a bundle with all the docs yourself
02:57:33 <Saizan_> copy the base docs over to some relative location and point the links to it
02:57:55 <Saizan_> or, link to the hackage ones
02:58:26 <Saizan_> (not sure what linux has to do with this)
02:58:54 <netinho2lol> gonna do that, Saizan_ :)
02:59:16 <netinho2lol> can you tell me where I can find GHC.Types.Int GHC.Types.Char ?
02:59:22 <netinho2lol> or is this internally defined?
03:00:19 <Saizan_> netinho2lol: try ghc-pkg find-module GHC.Types.Int
03:01:03 <netinho2lol> var/lib/ghc-6.10.4/./package.conf:
03:01:41 <Saizan_> it seems there's no package with that module, maybe it's just some internal ghc thing
03:02:21 <poucet_> How do I install the profiling version of a package with cabal
03:03:46 <koeien37> -p
03:04:10 <poucet_> cabal install -p package?
03:04:15 <poucet_> it complains that it's already installed
03:06:21 <netinho2lol> Saizan_: !!
03:06:28 <netinho2lol> usr/share/doc/ghc6-doc/libraries/ghc-prim,/usr/share/doc/ghc6-doc/libraries/ghc-prim/ghc-prim.haddock
03:06:31 <netinho2lol> :D
03:09:22 <blackh> poucet_: cabal install --reinstall --enable-library-profiling package
03:09:59 <blackh> poucet_: What I do is turn it on in ~/.cabal/config, along with documentation
03:14:45 <watermind> ah I just found out about hughes 'going erlang'
03:15:48 <ksf> WAAAAAAAAGH
03:15:55 <ksf> I can't hide mtl.
03:17:27 <zygoloid> ksf: have you tried throwing a blanket over it?
03:18:22 <ksf> ghc-pkg just doesn't respect my authority.
03:18:30 <ksf> it says I don't have permission to do that.
03:18:41 <mmx166mhz> How to make a list with Three elements OUT OF a list which COULD have more than three elements, by collecting all the other element in the 3rd element.. EG: ["asa","asa","232","34343"] becomes ["asa","asa","23234343"]
03:18:42 * ksf goes on and sulks until someone fixes ghc-pkg
03:19:46 <Niccus> not sure what you mean there
03:20:19 <mmx166mhz> well: Collecting all elements in the third element
03:20:23 <poe> mmx166mhz you want to remove duplicates? Data.List.nub does it.
03:20:27 <mmx166mhz> no no
03:20:31 <EvilTerran> mmx166mhz, "collectToThree (x:y:rest) = ..." might be a good place to start
03:20:44 <mmx166mhz> aha ;)
03:20:47 <mux> http://i.imgur.com/ng5aS.png -- Haskell is the language with the most polite community
03:20:52 <ksf> > (\(x:y:z:zs) -> x:y:(z++zs))  ["asa","asa","232","34343"]
03:20:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
03:21:17 <ksf> > (\(x:y:z:zs) -> x:y:(concat z:zs))  ["asa","asa","232","34343"]
03:21:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
03:21:21 <EvilTerran> > let (x:y:rest) = [1..10] in "x = " ++ show x ++ "; y = " ++ show y ++ "; rest = " ++ show rest
03:21:23 <lambdabot>   "x = 1; y = 2; rest = [3,4,5,6,7,8,9,10]"
03:21:24 <ksf> er uh.
03:21:45 <mmx166mhz> ok, looks good, thanks all
03:21:50 <ksf> > (\(x:y:z:zs) -> x:y:(z ++ concat zs))  ["asa","asa","232","34343"]
03:21:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
03:21:52 * Cyneox re
03:21:56 <ksf> gragh.
03:22:06 <blackh> mux: Maybe we just write less documentation? :)
03:22:33 <ksf> > (\(x:y:zs) -> x:y:(concat zs))  ["asa","asa","232","34343"]
03:22:33 <blackh> mux: Or maybe we swear less because we are less frustrated.
03:22:35 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
03:22:41 <ksf> :t concat
03:22:43 <lambdabot> forall a. [[a]] -> [a]
03:22:48 <Niccus> probably would work if you spell it out as a function and state its type
03:22:50 <EvilTerran> ksf, ITYM [x,y,concat zs]
03:23:00 <ksf> oh yeah.
03:23:10 <ksf> > (\(x:y:zs) -> [x,y,concat zs])  ["asa","asa","232","34343"]
03:23:12 <lambdabot>   ["asa","asa","23234343"]
03:23:36 <ksf> should probably be generalised, though.
03:26:22 <poucet_> Btw, it seems the installation scripts for ghc 6.10.4 are still broken
03:26:23 <aoshdas> how to compare an Int to an Integer?
03:27:07 <Niccus> toInteger
03:27:23 <poucet_> :t fromIntegral
03:27:26 <lambdabot> forall a b. (Integral a, Num b) => a -> b
03:27:34 <poucet_> @t fromIntegral
03:27:40 <EvilTerran> ksf, \n xs -> take n xs ++ [concat (drop n xs)], perhaps?
03:27:45 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:28:10 <aoshdas> thanks! :)
03:28:46 <ksf> EvilTerran, dunno, I'm busy sulking because I can't properly hack on yi with my vim as I can't hide mtl.
03:30:09 <ksf> ...and I don't want to split up a 1750 line .hs file without compiler support.
03:30:15 <EvilTerran> yyyeah
03:31:49 <ksf> ...the average line count in yi is 215, just as a comparison.
03:31:55 <ksf> it's by far the biggest file around.
03:33:56 <Arxor> Hi
03:34:02 <Niccus> hullo
03:34:37 <Arxor> Is there a method like words, only instead of making a list of words a list of sentences (seperated by '\n')
03:34:51 <EvilTerran> lines
03:34:57 <Arxor> thanks
03:35:14 <EvilTerran> :)
03:49:52 <ketil> How do I add to the "context" of a function?  I have a small sub-function in a monadic block that I'm struggling with, and ghc suggests this as "Possible fix"
03:50:48 * hackagebot upload: wumpus-core 0.13.0 - Pure Haskell PostScript and SVG generation. (StephenTetley)
03:52:05 <Saizan> e.g. if you've a type signature for your function "func :: Sometype" you can add some constraint like this "func :: SomeClass a => SomeType" where SomeType would mention 'a'
03:52:20 <Saizan> though that possible fix is not always accurate
04:01:14 <ketil> Hm. I removed the troublesome function, and I get the same thing with 'unsafeFreeze'.  I thought this was straightforward: 'runST $ do writeArray (blah blah) unsafeFreeze' - done.
04:02:54 <path[l]> Cale you here?
04:03:26 <Cale> approximately
04:04:20 <ski> ketil : sounds like you might want
04:04:21 <ski> @type Data.Array.ST.runSTArray
04:04:23 <lambdabot> forall i e. (Ix i) => (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e
04:05:06 <ketil> Hm, yes.  It says it is a 'simple wrapper', I thought it would be simple enough that I could redo it.
04:05:10 <ski> (though i have no idea if this will help you with your type error)
04:05:49 <ski> it's nicer not to use operations with `unsafe' in their name :)
04:05:53 <ketil> Is the source available?
04:06:02 <path[l]> cale any ideas
04:06:02 <ketil> ski: yes.
04:06:02 <path[l]> \
04:06:11 <path[l]> sorry I had walked away suddenly
04:06:33 <Cale> path[l]: No, I've been distracted by some other things too.
04:08:19 <ski> @type let myRunSTArray :: Ix i => (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e; myRunSTArray m_array = runST (Data.Array.ST.unsafeFreeze =<< m_array) in myRunSTArray
04:08:21 <lambdabot> forall i e. (Ix i) => (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e
04:08:29 <ski> ketil : i assume the source is basically that
04:09:06 <ski> (maybe `Data.Array.MArray.unsafeFreeze' instead of `Data.Array.ST.unsafeFreeze' .. it should not matter)
04:09:26 <ketil> Perhaps I just need the correct type signature.  (Can't do ST by heart :-)
04:09:49 <ketil> This works: runSTUArray (newArray (0,1) 0) :: UArray Int Int
04:09:54 <ski> s/GHC.Arr.STArray/Data.Array.ST.STArray/, i suppose
04:10:06 <ski> (it would be nice if ghc didn't leak that implementation detail)
04:10:15 <ketil> This doesn't: runST $ newArray (0,1) 0 >>= unsafeFreeze :: UArray Int Int
04:10:16 <Itkovian> any idea why there's nothing to see on a +RTS -p -hy graph?, except the axis?
04:11:11 <ski> ketil : maybe it doesn't know which type of array `newArray' is to create .. ?
04:11:23 * ski has to run, can't ponder it more, atm
04:11:56 <ketil> It should know from runST and UArray return type - but okay, thanks.
04:16:10 <ketil> Made it work using runSTUArray anyway.
04:16:13 <ketil> :-)
04:21:10 * osfameron always reads that as STFUArray...
04:21:54 <BONUS> haha
04:21:57 <IceDane> Does Text.Regex.Posix have to be installed separately?
04:21:59 <BONUS> ST Fast Unboxed Arrays
04:23:21 <LearnHaskell> hi, I have a problem with making lists/tupels out of a database, someone have a little time to help me?
04:26:03 <LearnHaskell> noboby hero to help with simple problem?
04:26:06 <LearnHaskell> please?
04:26:42 <therp> LearnHaskell: what do you mean by database?
04:26:50 <koeien37> LearnHaskell: it'll probably help to be a little more specific. also, if you have code, you can paste it
04:26:59 <LearnHaskell> yes of course
04:27:09 <LearnHaskell> I will paste the code
04:27:24 <koeien37> ?hpaste
04:27:25 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:30:09 <LearnHaskell> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5126#a5126
04:30:16 <LearnHaskell> ok if someone can help me, plz
04:30:26 <LearnHaskell> I want to do it step by step, the problem is explained in the paste
04:31:06 <LearnHaskell> I have a file with some data, now I want a function which tries to match the input with one of the data in the file
04:32:13 <therp> why would 40128.. return visa?
04:32:18 <IceDane> Sounds like something you could do with ByteString and its assorted functions
04:32:35 <LearnHaskell> cuz it matches the length and prefix
04:32:50 <LearnHaskell> the first numberin the file
04:32:58 <BONUS> yeah why would 40128... return visa? 4012888888881881 has 16 digits
04:33:01 <LearnHaskell> is the prefix of the number, the second number in the file is the length of the
04:33:03 <BONUS> ah i see
04:33:09 <BONUS> it matches 4 16 Visa
04:33:12 <LearnHaskell> yes
04:33:15 <therp> ah ok..
04:33:19 <BONUS> ah ok, i see
04:33:46 <LearnHaskell> so I thought if I could make a list, of lines from the file, then make tupels with the spaces of the lines, then after that I want to do something recursive to try to match the input number with the made tupels
04:33:51 <therp> LearnHaskell: I'd start with parsing file.txt into a list of tuples (Int,Int,String)
04:33:58 <LearnHaskell> yes
04:34:02 <LearnHaskell> that's what I thought
04:34:17 <BONUS> i'd rather do (String,Int,String)
04:34:23 <therp> @ho getLines
04:34:24 <lambdabot> Maybe you meant: hoogle hoogle+ do
04:34:25 <LearnHaskell> yes that's better
04:34:27 <LearnHaskell> for the matching
04:34:27 <therp> @hoogle getLines
04:34:27 <LearnHaskell> later
04:34:27 <lambdabot> No results found
04:34:31 <LearnHaskell> string,int,string
04:34:46 <frank___> i want to use sortBy to sort the length of a first element in a tupel with size 3 which is also in a list. So: [("hello", "3", True),("hi", "4", False")] would be in reverse in this case
04:35:42 * path[l] ;'
04:35:59 <path[l]> oops sorry
04:36:40 <LearnHaskell> therp, how I do I make the tuples form the file
04:36:49 <LearnHaskell> after that I know how to match it recursively I guess
04:37:32 <frank___>   uu zeker
04:37:44 <therp> LearnHaskell: you could use getLine but that would give you an annoying EOF check somewhere
04:37:47 <IceDane> If you want to do it naively, it can be done by using lines, words and then the !! operator
04:38:04 <therp> LearnHaskell: I would use getContents and break the String at "\n"
04:38:06 <IceDane> (and read on the integers)
04:39:22 <therp> but how to break at the string in a nice way. hmm
04:39:31 <path[l]> sortBy (\((a,_,_),(b,_,_) -> (length a) `compare` (length b))  [("hello", "3", True),("hi", "4", False")]
04:39:31 <path[l]>  
04:39:32 <path[l]> 
04:39:32 <path[l]> 
04:39:37 <path[l]> > sortBy (\((a,_,_),(b,_,_) -> (length a) `compare` (length b))  [("hello", "3", True),("hi", "4", False")]
04:39:37 <path[l]>  
04:39:38 <lambdabot>   <no location info>: lexical error at character '\DLE'
04:39:45 <path[l]> why am I printing wierd unicode stuff
04:39:45 <path[l]> 
04:39:51 <LearnHaskell> ye I thought something like takeWhile (\=' ') line ....
04:39:55 <path[l]> hi
04:39:56 <path[l]> 
04:40:02 <path[l]> >  sortBy (\((a,_,_),(b,_,_) -> (length a) `compare` (length b))  [("hello", "3", True),("hi", "4", False")]
04:40:03 <path[l]> ]
04:40:03 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
04:40:04 <lambdabot>   <no location info>: lexical error at character '\DLE'
04:40:05 <IceDane> therp: Why not just read the whole file, use lines, words on each line and then use the !! operator to get each element
04:40:32 <therp> IceDane: oh there is a lines function
04:40:34 <IceDane> All elements are in predefined positions
04:40:37 <IceDane> therp: yeah
04:40:39 <IceDane> :t lines
04:40:40 <lambdabot> String -> [String]
04:40:42 <therp> LearnHaskell: icedane has your answer
04:40:58 <IceDane> > lines "line 1\nline 2"
04:40:58 <lambdabot>   ["line 1","line 2"]
04:40:59 <therp> nice, I overlooked that.
04:41:27 <IceDane> >!! 2 . words .  lines $ "line 1\nline 2"
04:41:35 <IceDane> > !! 2 . words .  lines $ "line 1\nline 2"
04:41:36 <lambdabot>   <no location info>: parse error on input `!!'
04:41:38 <IceDane> heh
04:41:43 <IceDane> > (!! 2) . words .  lines $ "line 1\nline 2"
04:41:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:41:44 <lambdabot>         against inferred type...
04:41:48 <IceDane> I'm still bad at haskell
04:41:59 <IceDane> > (words .  lines $ "line 1\nline 2") !! 2
04:42:00 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:42:00 <lambdabot>         against inferred type...
04:42:09 <IceDane> meh
04:42:21 <therp> IceDane: you want to use map
04:42:32 <IceDane> oh
04:42:33 <IceDane> silly me
04:42:39 <therp> > map words (lines $ "line 1\nline 2")
04:42:40 <lambdabot>   [["line","1"],["line","2"]]
04:42:57 <LearnHaskell> but this is only for two lines?
04:43:17 <LearnHaskell> thisis naive right? how does it work for a file with uknown amount of lines
04:43:27 <frank___> path[l]: the length of the list can be any size and I have the function first (x, _, _) = x
04:43:29 <IceDane> LearnHaskell: lines just splits at every newline
04:43:42 <IceDane> it will work fine for a file of unknown amount of lines
04:44:01 <IceDane> You can just use lazy IO, which should perform better on large files
04:44:30 <BONUS> LearnHaskell: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5126#a5127
04:44:41 <BONUS> here's a basic (albeit a bit ugly, hey, it's early in the morning) solution
04:48:07 <sepp2k> frank___: His solution works fine for any size. If you want to use your first function, you can modify the lambda to use that instead of doing the pattern matching itself, but that won't really make it shorter.
04:48:46 <therp> you could also try list comprehensions instead of the maps..
04:54:32 <path[l]>  >  sortBy (\((a,_,_),(b,_,_) -> (length a) `compare` (length b))  [("hello", "3", True),("hi", "4", False")]
04:55:34 <Botje> compare `on` (length . first)
04:55:41 <Botje> i'd say that's shorter
04:56:13 <Cale> path[l]: what's with the 's?
04:57:42 <notweebl> yeah i see the same
04:58:55 <Axman6> Botje: first?
04:59:21 <notweebl> first (x,_,_) = x he said
04:59:38 <frank___> it says Not in scope: `on`
04:59:43 <Axman6> anyway, (\((a,_,_),(b,_,_)) -> comparing length a b) would be shorter
05:00:08 <Axman6> frank___: you need Data.Function imported i think
05:00:12 <Axman6> @index on
05:00:13 <lambdabot> bzzt
05:00:15 <path[l]> its my stupid irc client
05:00:16 <Axman6> bah
05:00:17 <Botje> on is in Data.Function, yes.
05:00:17 <path[l]> I dunno why
05:00:41 <path[l]> it happens suddenly
05:00:58 <frank___> it works, thanks!
05:02:57 <path[l]> Axman6: if you're back Im still looking for optimisation help =p. Cale very patiently walked me through a lot of stuff today, but sadly I havent obtained any improvements yet
05:03:05 <path[l]> though I did split the memoising Array out
05:10:27 <Axman6> path[l]: well, that's a good start. i'd advise taking a look at Don Stewart's blog, he's got some great articles on how to write high performance haskell
05:11:17 <path[l]> ok but do you have some time to take a look at what I did and give me your suggestions?
05:11:45 <Axman6> yep, i'll take a look shortly. paste your latest code somewhere and i'll see what i can suggest
05:12:00 <path[l]> btw without memoising my function took over 183 minutes and then I broke it. With memoising it takes a minute 40 seconds
05:12:12 <Axman6> excellent
05:12:35 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5120
05:12:41 <path[l]> it includes further down
05:12:45 <path[l]> 1) my test input
05:12:53 <path[l]> 2) memory graphs
05:12:58 <path[l]> and cost center profile
05:14:19 <Axman6> gahh, i'm trying to find a song that i have no idea who it's by or what it's called >_<
05:14:42 <path[l]> lol
05:14:45 <path[l]> what do you kno
05:14:46 <path[l]> w
05:15:07 <Axman6> some of the lyrics
05:15:31 <path[l]> oh thats usually pretty good
05:15:50 <mmx166mhz> I've a function which outputs a "IO String", how can I use the output to display it on the screen. For example: I need a String to place it in a "putStr"
05:15:50 <Axman6> it's a late 90's song i think, and goes something like "i want to get away, i want to fly away, yeah yeah yeah yeah..."
05:16:05 <Axman6> mmx166mhz: one sec
05:16:20 <zygoloid> Axman6: lenny kravitz, fly away, i think
05:16:20 <path[l]> oh
05:16:20 <path[l]> I knoa that
05:16:20 <path[l]> give me few mins
05:16:21 <Axman6> mmx166mhz: http://random.axman6.com/blog/?page_id=70
05:16:27 <Saizan> path[l]: that memf looks like it's reconstructing the array on each call
05:16:30 <path[l]> yeah
05:16:30 <path[l]> thats ut
05:16:31 <Axman6> zygoloid: i'll check it out
05:16:42 <path[l]> he's right
05:17:18 <Axman6> thanks heaps zygoloid :D
05:17:54 <Saizan> though maybe GHC floats the array construction outside
05:18:20 <blackdog> i wonder if there's a command-line options parsing package in the world that isn't a massive bear to use
05:18:53 * blackdog would rather do just about anything than write option handling code. it's his little big horn, apparently.
05:19:37 <blackdog> Axman6: g'day mate. how's code?
05:20:07 <mmx166mhz> thanks axman, that makes sensd
05:20:24 <Axman6> blackdog: it's not. i refuse to code while stuck on windows ;)
05:21:36 <Saizan> path[l]: does this change make any difference? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5120#a5130
05:21:45 <blackdog> why are you stuck on windows?
05:22:13 <Axman6> MBP's having its super drive replaced after dying
05:22:27 <Axman6> was hoping to have it back by today actually
05:23:05 <blackdog> also: no sympathy. I spent half of yesterday debugging linking issues on windows. apparently the last guy had compiled one of the libraries in debugging mode, and never thought to test it on a machine that didn't have Visual C++ installed. joy of joy.s
05:23:25 <Axman6> -_-
05:23:26 <blackdog> get down in the dirt, i'm sure it's not too bad with GHC on it:)
05:23:48 <Axman6> bah
05:23:54 <Axman6> no decent text editors
05:24:24 <blackdog> windows has emacs and vi
05:24:32 <blackdog> what kind of crazy text editor are you kids using these days?
05:24:38 <Axman6> my point exactly >_>
05:24:46 <Axman6> TextMate of course
05:24:50 <blackdog> oh god
05:25:04 <blackdog> feel like repurposing that hoary old chestnut
05:25:20 <Axman6> eh?
05:25:24 <blackdog> "you know the worst part of using TextMate? Coming out to your mother..."
05:25:32 <Axman6> whatchutalkinbout
05:25:47 <blackdog> of course, it's usually used about ruby programmers and cyclists.
05:26:26 <Axman6> well, you stay stuck in the dark ages. i like somehting that lets me get my work done without needing any configuration, and staying out of my way :)
05:27:13 <blackdog> what's it like for haskell? Do you have hoogle hooked in?
05:27:22 <blackdog> or a flymake equivalent?
05:27:44 <ben> Way to be passively homophobic
05:27:45 <Axman6> and don't tell me neither emacs nor vim need configuration. neither of them come with haskell support built in, or easily installable (it's not there by default in TM, but it can be installed through the app i think)
05:27:57 <path[l]> Saizan: I had made that exact same change earlier
05:27:58 <blackdog> ben: yeah, sorry about that. it was a bit tasteless.
05:28:02 <path[l]> when Cale showed it to me
05:28:06 <path[l]> but itmakes no difference
05:28:08 <Axman6> blackdog: it used to, but the haskell bundle isn't well maintained
05:28:17 <path[l]> it turns out ghc is optimising that away for me
05:28:32 <Axman6> Saizan: what change did you make?
05:28:37 <Saizan> ah, i suspected so
05:29:04 <blackdog> Axman6: sure, it takes a bit of fiddling. am genuinely interested, though, not just taking potshots.
05:29:05 <Saizan> in the old days hpaste had diffs!
05:29:08 <blackdog> what's the support like?
05:29:48 <Saizan> Axman6: i bound the memo array to a variable
05:29:58 <Saizan> outside of memf
05:30:00 <Axman6> well, i prefer switching to ghci/terminal to build the code and test it. i think there is some broken haddock support, but i could be wrong.
05:30:15 <Axman6> Saizan: ah, right
05:30:43 <blackdog> Axman6: you still do that for tests, but it's pretty nice to have syntax checking actually in the editor.
05:31:22 <blackdog> i'd kind of like to hack flymake support for TBC, actually. you could keep running tests and have the results pop up in the editor too...
05:31:27 <Axman6> like i said, it's not fantastic for haskell, but it's certainly usable, without too much that';s annoying (it does some strange stuff with indenting)
05:31:46 <Axman6> blackdog: should be simple enough in TM
05:31:59 <Axman6> that surt of thing's quite common
05:32:10 <Axman6> sort*
05:32:22 <blackdog> Axman6: fair enough. every couple of years i check out the competition, emacs has its share of problems
05:33:07 <blackdog> Axman6: it's pretty trivial in emacs too - just have to rig up a test result prettyprinter to spit it out in the right format
05:33:40 <Axman6> i don't want to learn how to use an editor, like i shouldn't need a tutorial to just write my first program in it. so i haven't gone very far with vim or emacs (though i prefer vim)
05:35:59 <Axman6> so to me, one of the most attractive things about TM is that when you open it for the first time, it looks just like textedit or notepad. anyone with halfr a brain can use it. then you can learn what functionality it has, and just write faster
05:36:10 <blackdog> Axman6: hm. I tend to disagree - it's nice if it's intuitive for newbie users, but it's much more important to be continually improvable. I'm by no means an emacs wizard, but the guys who are can make your head spin.
05:36:20 <Axman6> dead simple to extend too. snippets are lively in TM
05:36:42 <Axman6> blackdog: the same is true for TM :)
05:36:58 <blackdog> It does have the undeniable drawback that it's difficult to do any hacking on your windows box, so you get drawn into annoying arguments with blackdog
05:37:16 <Saizan> intuitive interface /= functional interface, in the sense that none implies the other
05:37:43 <path[l]> oh I support textmate too
05:37:45 <blackdog> who will clearly do just about anything rather than write this option handling code:)
05:38:14 <Axman6> i've thought about it a bit, and i feel that TM is far better designed from a users point of view than both vim and emacs
05:38:46 <koala_man> Axman6: how do you discover new functionality with TM?
05:39:02 <Axman6> by looking in the bundle browser
05:39:09 <Axman6> /editor
05:40:05 <path[l]> Axman6/saizan anything else jump out at you guys? One issue is Im reading 2500 domains and 7000 candidates
05:40:20 <path[l]> but Im annoyed that my code takes 4 times longer than java codes :/
05:40:44 <ski> "TM" ?
05:40:49 <blackdog> textmate
05:40:52 <Axman6> i think you need to find a way to reduce the number of times distance is called
05:41:15 * Lycurgus was looking for something like "TextMonad".
05:41:19 <path[l]> huh? you mean since Im calling it once per pair?
05:41:34 <Axman6> well, it's being called a lot
05:41:47 <Axman6> so i'll see if there's something that can be done about it
05:41:52 <path[l]> well I mean thats what every code I see out there that passes the contest is doing =p. But yeah Im trying to think of an efficient way to store the domains
05:42:09 <path[l]> still seems unfair that doing what everyone else does makes me slower by so much
05:42:31 <path[l]> Im wondering if its because they preallocate space for the domains and candidates because they have bounds on the spaces?
05:43:03 <path[l]> they know there are atmost 2500 domains of atmost 31 chars and atmost 7000 candidates of atmost 31 chars
05:43:49 <Axman6> heh, looks like you could do some crazy unrolling using TH
05:44:21 <frank___> bye bye
05:44:25 <path[l]> TH?
05:44:53 <blackdog> Axman6: you may have to wean yourself off the acronyms
05:45:03 <Axman6> path[l]: one thing: you've got f 0 i = i; f j 0 = f 0 j, why not just have f i 0 = i; f j 0 = j?
05:45:12 <Axman6> path[l]: template haskell
05:45:23 <path[l]> ah
05:45:24 <Axman6> lets you manipulate the AST at compile time
05:45:43 <path[l]> hmm ok I can make that change, but I assume thats just stylistic?
05:45:57 <path[l]> oh
05:45:57 <path[l]> nm
05:45:57 <path[l]> misread
05:45:57 <path[l]> sure
05:46:04 <Axman6> sure. could save a little time though
05:46:13 <path[l]> nah I misread
05:46:22 <path[l]> I thought you just wanted me to put it in one line lol
05:46:26 <Axman6> since it's being called so much, every little bit counts
05:46:32 <Axman6> heh. nah
05:46:37 <Axman6> never do that!
05:46:45 <path[l]> hehe
05:47:05 <LearnHaskell> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5131#a5131     <--- I want to sort the list of tupels on the lenght of the prefix, that's the (x,_,_) in the tupels
05:47:14 <path[l]> hmm then is there something faster than minimum I could do? maybe to avoid that termporary list
05:47:46 <path[l]> wtf .... making that change made it take longer
05:47:52 <Axman6> LearnHaskell: sortBy (\(a,_,_) (b,_,_) -> comparing length a b) xs? (i haven't looked at your code
05:47:57 <Axman6> path[l]: huh...
05:48:06 <path[l]> yeah I dont get it
05:48:13 <Axman6> how very odd
05:48:47 <path[l]> btw Ive linked to the input if you wanna run it :), just in case you wanna see the result of a change without me in the loop =p
05:50:55 <path[l]> so whats template haskell
05:52:17 <LearnHaskell> ok
05:52:44 <LearnHaskell> how would you define the sort/
05:52:45 <LearnHaskell> ?
05:52:48 <LearnHaskell> axman
05:52:52 <Saizan> it's a macro system (as in list macros) for haskell
05:52:58 <Saizan> *lisp
05:53:07 <path[l]> oh ok
05:54:03 <Saizan> LearnHaskell: sortBy is a function in Data.List
05:54:30 <Axman6> LearnHaskell: import Data.Ord too, and you can use the comparing function:
05:54:32 <Axman6> :t comparing
05:54:34 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:54:47 <Axman6> basically, you can do this:
05:55:01 <Axman6> > comparing length "hello" "blahh"
05:55:03 <lambdabot>   EQ
05:55:06 <Axman6> > comparing length "hello" "blahhh"
05:55:08 <lambdabot>   LT
05:55:12 <Axman6> > comparing length "hello" "blah"
05:55:14 <lambdabot>   GT
05:55:24 <LearnHaskell> ah
05:57:09 <Axman6> LearnHaskell: comparing is basically: comparing f a b = compare (f a) (f b)
05:57:23 <LearnHaskell> yes
05:57:38 <Botje> which is itself a specialization of `on` :)
05:57:52 <Axman6> well...
05:57:54 <Axman6> @src comparing
05:57:56 <lambdabot> Source not found. I am sorry.
05:57:58 <Axman6> bah
05:57:59 <Botje> :t (compare `on`)
05:58:01 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
05:58:12 <Axman6> anyway, yes, it's defined using on
05:58:28 <LearnHaskell> yes ic
05:58:36 <ski> @type let fst3 (a,_,_) = a in sortBy (comparing (length . fst3))
05:58:38 <lambdabot> forall a t t1. [([a], t, t1)] -> [([a], t, t1)]
05:59:10 <sizur> Hi #haskell
05:59:23 * Botje waves at sizur 
06:01:40 <Axman6> path[l]: if you were feeling adventurous, you might be able to speed things up by doing them in parallel :o
06:02:05 <path[l]> which will only give me an improvement on multicore right?
06:02:23 <Axman6> yes
06:02:41 <Axman6> and probably slow it down if you're using ghc 6.10 :)
06:02:50 <path[l]> haha
06:03:02 <path[l]> how would I do it anyway? though Im just checking if the online contest machine has more than one core
06:03:02 <sizur> And multibox, depending on type of paralelism
06:03:24 <Axman6> we don't do that sort of parallelism here often
06:03:35 <stroan> schedule =
06:03:39 <stroan> oops
06:03:43 <stroan> putty right click paste
06:04:24 <sizur> Axman6: yeah, we don't want to take that away from erlang
06:04:46 <Axman6> we could though, with the erlang package
06:05:31 * sizur jumps to hackage
06:05:57 <Axman6> allows haskell programs to act as erlang nodes
06:06:14 <path[l]> lol
06:06:35 <path[l]> how would I quickly attempt to parallelise that main map that happens
06:07:17 <path[l]> hmm oh its quad core
06:07:31 <path[l]> it might be possible to do this
06:07:38 <sizur> Axman6: wow nice. Fully interoerate with erlang
06:07:56 <Axman6> path[l]: one idea that might help is not being quite so high level and rewriting some of filter (<3) $ map (distance candidate) domains part into an explicit function. i'll see what i can do for you if you give me a few mins
06:08:22 <path[l]> ok
06:20:34 <MHD> 1
06:20:46 <MHD> 2
06:20:46 <MHD> 3
06:20:55 <Botje> MHD: is the next one 4 ?
06:20:56 <Axman6> path[l]: rarg, i'm too tired to work on this now. i'll help you tomorrow if i can, once i've found text editor i can use
06:21:20 <MHD> No, because "let 2 + 2 = 5 in 2 + 2"  is  5
06:21:43 <Axman6> but you're applying succ
06:21:55 <Saizan> path[l]: how common is the null distances case in surcharge?
06:22:24 <MHD> Axman6: Definitions are arbitrary
06:22:57 <Saizan> hah, no, sorry, it doesn't matter
06:23:18 <MarcWeber> Does cabal-install handle installing gtk2hs ?
06:23:30 <MHD> I figgure out Monads yesterday, I'm happy
06:23:37 <dcoutts> MarcWeber: no
06:24:53 <MarcWeber> dcoutts: Can I configure gtk2hs once and use the .cabal files from sub-directories then?
06:25:00 <MarcWeber> I'll try
06:26:54 <dcoutts> MarcWeber: no
06:27:14 <dcoutts> MarcWeber: those .cabal files are actually useless at the moment
06:28:40 * zygoloid reads up and sees "filter (<3)" -- i like that function
06:29:01 <shambler> a:-)
06:30:10 <path[l]> Saizan: sorry was in a conversation
06:30:26 <path[l]> Saizan: very uncommon
06:30:43 * SamB_XP wonders why the WDK 18002SP is so much bigger than the DDK 1830
06:33:29 * MHD is away: autoaway [l(on) p(on)]
06:37:07 <path[l]> http://www.haskell.org/haskellwiki/SPOJ <--- whoa not seen this before
06:37:07 <path[l]> hmm
06:37:16 <Gleesh> Hi
06:44:22 <MHD> Anyone got a pure lambda calculus implementation lying around?
06:44:39 <MHD> I'm trying to write my own, but it's a bit trippy
06:44:46 <Axman6> path[l]: hmm, that one looks nice
07:12:15 <rdeshpande> hello
07:22:57 <geoaxis> hey people, is there a one liner to generate a random number between 1..10 in haskell
07:25:10 <roconnor> geoaxis: 9
07:25:22 <roconnor> e
07:25:23 <roconnor> er
07:25:25 <roconnor> geoaxis: 4
07:25:41 <roconnor> geoaxis: http://xkcd.com/221/
07:26:49 <roconnor> :)
07:27:00 <aavogt> #help
07:27:03 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
07:27:07 <geoaxis> return statement in haskell is not the same as in C or java
07:27:21 <Lemmih> geoaxis: randomRIO (1,10)
07:27:30 <aavogt> return is a function
07:27:34 <roconnor> @type randomR
07:27:37 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
07:27:48 <aavogt> lunabot can run random computations
07:27:55 <aavogt> can anybody recall how?
07:29:55 --- mode: irc.freenode.net set +o ChanServ
07:30:14 <roconnor> @bot
07:30:15 <lunabot>  :o
07:30:37 <lambdabot> :)
07:31:04 <roconnor> > randomR (1,10) (mkStdGen 200911241032)
07:31:06 <lambdabot>   (8,1552971588 40692)
07:31:19 <roconnor> > fst $ randomR (1,10) (mkStdGen 200911241032)
07:31:21 <lambdabot>   8
07:32:42 <burp> > fst $ randomR (1,10) (mkStdGen 45)
07:32:44 <lambdabot>   4
07:32:55 <roconnor> burp: better!
07:32:58 <burp> yup :D
07:32:59 <roconnor> :D
07:34:33 <roconnor> geoaxis: generating a random number is impure and thus we generally require it to be done in a monad in haskell
07:34:51 <roconnor> geoaxis: there is a nice monad random package for doing this.
07:35:42 <roconnor> geoaxis: as mention, you can use functions such as randomRIO if you rather have something easy to use right now.
07:37:16 <burp> monte-carlo package is also nice
07:37:28 <geoaxis> roconnor: well its a trivial lab exercise, and we just touched monads yesterday
07:37:30 <burp> uses random number generator from gsl
07:37:58 <geoaxis> so i think using randomRIO should be fine for now, but will look into mondas after this
07:38:10 <roconnor> geoaxis: what are you trying to do?
07:38:29 <geoaxis> roconnor: generating a soduku
07:39:06 <roconnor> sounds hard
07:39:35 <roconnor> well, hard to do well
07:39:46 <zygoloid> *shrug* if you start with a known grid and apply isomorphisms it's probably not too bad
07:40:27 <zygoloid> i don't know what proportion of the possible solutions you can reach with renumberings, row/column permutations and other simple moves, but i'd guess quite a few
07:40:30 <geoaxis> roconnor: the point is to learn haskell really, not to make a industrail grade soduke generator
07:40:49 <geoaxis> industrial*
07:41:05 <_andre> does anyone have access to the papers "Efficient graph algorithms using lazy monolithic arrays" and "Graph algorithms with a functional flavour"?
07:41:59 * roconnor would be tempted to generate all sudokus in held in some sort of tree structure.
07:42:13 <roconnor> and then pick a random leaf.
07:42:13 <eevar2> geoaxis: how are you doing it? started by creating a solver and adding numbers to an enty grid until there's only one solution?
07:42:20 <eevar2> *empty
07:43:09 <roconnor> with a probability distrubution according to the "path weight"
08:19:47 <bastl> Why do I need "FlexibleInstances" here? What is it good for? Is there a better way? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5134#a5134
08:19:57 <MarcWeber> Yeah. hack-nix supports gtk2hs as well now
08:25:20 <zygoloid> bastl: you need FlexibleInstances because Haskell'98 only allows instances for T a b c ... where a, b, c, ... are distinct type /variables/
08:27:30 <bastl> zygoloid: so the design is ok? I just want unified access ( :: Either String a) to various error-types
08:28:51 <zygoloid> it looks vaguely reasonable to me. FlexibleInstances is a pretty non-controversial extension
08:30:50 <zygoloid> bastl: you probably want a functional dependency b -> a
08:32:00 <bastl> as a parameter to the type-class?
08:35:14 <McManiaC> > let f (x + 5) = x in f 20
08:35:17 <lambdabot>   15
08:35:30 <McManiaC> how far can you go with that?
08:36:01 <zygoloid> bastl: class PWhateverItWas b a | b -> a where ...
08:36:12 <zygoloid> McManiaC: not very far
08:36:33 <zygoloid> > let f (x + 5) = x in f (-42)
08:36:35 <lambdabot>   * Exception: <interactive>:1:149-161: Non-exhaustive patterns in function f
08:36:56 <zygoloid> > let f (x - 1.5) = x in f 6.5
08:36:58 <lambdabot>   <no location info>: Parse error in pattern
08:37:08 <McManiaC> oh okay
08:37:18 <zygoloid> > let f (x + 1) = x in f 4.2
08:37:19 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:37:21 <lambdabot>    `GHC.Real.Integral t'
08:37:23 <lambdabot>   ...
08:37:34 <zygoloid> ^^ just a selection of the things which don't work with n+k patterns
08:37:45 <McManiaC> hehe
08:38:06 <zygoloid> haskell'10 removed them
08:38:20 <aavogt> > let f (x+1) = x in f 4.2::Double
08:38:21 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
08:38:21 <lambdabot>    arising from a use ...
08:38:39 <aavogt> that's a sane restriction
08:39:11 <zygoloid> why?
08:39:44 * zygoloid favours the view pattern approach
08:40:02 <aavogt> me too
08:40:21 <o-_-o> hello
08:40:21 <aavogt> only problem is that view patterns don't have any overlap checking
08:40:43 <zygoloid> , let subtractOne x = x - 1; f (subtractOne -> x) = x in f 4.2
08:40:45 <lunabot>  3.2
08:40:50 <smiler> If I write a function using list comprehentions that generates natural numbers, how do I specify the type of the function so that uses the Integer class?
08:41:00 <McManiaC> whats the difference between luna und lambdabot? ^^
08:41:03 <aavogt> Integer is not a class
08:41:17 <aavogt> Integer is a type
08:41:22 <smiler> Ok?
08:41:41 <o-_-o> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5135#a5135
08:41:42 <aavogt> smiler: it will default to Integer anyways
08:41:43 <ben> smiler: You use a type signature at some point.
08:41:51 <zygoloid> i'm not sure i like the view pattern concrete syntax as much as n+k patterns though
08:41:52 <o-_-o> how do I get rid of the error ?
08:42:26 <zygoloid> you can't get this to work: 'f (nPlusK -> 1 :+ x) = x' for instance
08:42:47 <ben> o-_-o: main must return something of type IO, you are returning a list.
08:43:15 <aavogt> f (nPlusK 1 -> x) works though
08:43:56 <o-_-o> ben: how do I make main return a list ?
08:44:10 <ben> You stop using 'do'
08:44:15 <smiler> ben: Im fighting to figure out the syntax. Say if I have something like fibs = 0 : 1 : [a + b | (a, b) <- zip fibs (tail fibs)], how do I specify that a and b shall be Integers?
08:44:34 <smiler> Sorry for asking you personally ben >_<
08:44:48 <aavogt> smiler: you don't have to specify, but you can write  (b::Integer)
08:45:01 <smiler> aavogt: I get overflows when I don't :/
08:45:01 <ben> smiler: If you say fibs :: [Integer] on a separate line, it should infer it properly
08:45:05 <o-_-o> ben: but I get some other error
08:45:27 <ben> I am not sure whether you can compile a program where main is not returning IO t
08:45:33 <o-_-o> it says error at let, then at =
08:45:34 <smiler> ben: ah
08:45:37 <aavogt> smiler: then something else in your code is fixing the type to Int, like length
08:45:40 <o-_-o> ben: ah
08:45:45 <ben> Consider renaming it, then removing the 'do', remove the second 'let' and add an 'in' before the last line of main
08:46:06 <gwern> @quote HappS
08:46:06 <lambdabot> c2.com says: If you can program anything in HappS you actually already learned Haskell
08:46:12 <smiler> aavogt: oh, I see
08:46:17 <gwern> @quote napoleon
08:46:17 <lambdabot> <BONUS> says: C++ is saner than something? imo C++ is like the guy that goes around shouting "I am napoleon!!!"
08:46:28 <gwern> @quote buttocks
08:46:28 <lambdabot> DanWeston says: Bottom has only one value, not two. Otherwise bottom would have been called buttocks.
08:46:34 <aavogt> haha
08:46:37 <gwern> @quote worst.monoid
08:46:37 <lambdabot> kmc: says: (): worst monoid ever
08:49:09 <o-_-o> Why is haskell so difficult to write functions
08:49:19 <o-_-o> you need do for some and not for others
08:49:26 <roconnor> > const `mappend` id
08:49:27 <o-_-o> and = for some and not for others ?
08:49:28 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
08:49:32 <ben> You never need 'do'
08:49:34 <roconnor> > const () `mappend` id
08:49:35 <lambdabot>   {()->()}
08:49:37 <ben> It just makes some cases easier to write.
08:49:56 <o-_-o> when does one use let ?
08:50:04 <ben> When one wants to give a thing a name
08:50:21 <Apocalisp> > let f x = x * 10 in f 2
08:50:22 <lambdabot>   20
08:50:33 <o-_-o> isPalindrome str =
08:50:35 <o-_-o>   let first = take (round(realToFrac (length str) / 2)) str
08:50:40 <o-_-o> why does this not work then ?
08:50:42 <sepp2k> o-_-o: You use do to more easily make use of monads. You always use = to define functions. You use let (or where) to define variables and functions inside a function.
08:51:04 <ben> o-_-o: The syntax for let outside of do is 'let {declarations} in {expression}'
08:51:10 <zygoloid> aavogt: yeah, but my point was, i prefer the (x + 1)-style syntax to (subtract 1 -> x), since the former is more declarative and the latter is more operational
08:51:16 <shachaf_> o-_-o: Because it has no value. Functions always return a value.
08:52:22 <aavogt> zygoloid: I suppose you could write:   f (npk -> One :+ x) = ...  with the appropriate MPTC and predefined   data One = One; data Two = Two ....
08:52:37 <o-_-o> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5136#a5136
08:52:50 <o-_-o> ok well this doesn't work either!
08:52:53 <Apocalisp> > let isPalindrome str = reverse str == str in isPalindrome "radar"
08:52:55 <lambdabot>   True
08:53:03 <aavogt> perhaps T1 or T2 being better as the types to choose the instance
08:53:09 <shachaf_> o-_-o: Replace the second "let" with "   ".
08:53:50 <o-_-o> shachaf_: oh for a set of declarations one only needs one let ?
08:54:01 <shachaf_> o-_-o: Or an "in" for each "let".
08:54:10 <KlutTut> how can I make a string out of a IO string?
08:54:22 <ben> You cannot.
08:54:23 <shachaf_> o-_-o: By the way, you shouldn't be using length, and also not that whole realToFrac procedure.
08:54:26 <shachaf_> @ty div
08:54:28 <lambdabot> forall a. (Integral a) => a -> a -> a
08:54:49 <o-_-o> shachaf_: ok
08:54:51 <KlutTut> an IO string stays a IO string?
08:55:00 <Apocalisp> KlutTut: It is possible, but YOU cannot.
08:55:01 <o-_-o> shachaf_: it doesn't compile without it
08:55:03 <Apocalisp> ;)
08:55:04 <shachaf_> KlutTut: An IO String isn't a string at all.
08:55:14 <aavogt> KlutTut: use (liftM f) to apply your function  (String -> Something)  and then you have an IO Something
08:55:18 <ben> KlutTut: IO actions might result in values, but they have to be used within yet another IO action. You cannot turn an IO action into the value it results in, but you have to execute the action and tell it what to do with the result.
08:55:24 <shachaf_> o-_-o: "x `div` y" is integer division.
08:56:01 <zygoloid> KlutTut: ioStringToString = const "<<IO>>" :: IO String -> String
08:56:13 <shachaf_> aavogt: s/liftM/fmap/, I hope. That other name is just ugly.
08:56:19 <o-_-o> shachaf_: where are all these things ?
08:56:35 <o-_-o> all I see in the first chapter of haskell books are list operations
08:56:48 <aavogt> shachaf_: that's what happens when dealing with  (Monad m) =>
08:56:59 <aavogt> and you don't want the ugliness of  (Monad m, Functor m) =>
08:57:17 <shachaf_> aavogt: IO is a Functor, though.
08:57:30 * shachaf_ wonders when we get Caleskell.
08:57:31 <aavogt> the latter is worse than the former, because people read type sigs more often than the body
08:57:43 <Hiato> Hello all, yet another quick question. What does 'map + [1,2,3]' do? As in, should I not then be able to do 'map 1 (map + [1,2,3])' to get it to inceraes each number? THis is a theoretical question, I know how to increase numbers :P
08:58:03 <shachaf> Hiato: You mean "map (+) [1,2,3]"?
08:58:10 <aavogt> shachaf_: yeah, if you just have IO then fmap is probably better. I'm just justifying why I chose liftM
08:58:16 <Hiato> shachaf: yeah
08:58:18 <shachaf> Hiato: That returns "[(+) 1, (+) 2, (+) 3]".
08:58:18 <zygoloid> KlutTut: your question is akin to asking, "how can i make a cake out of a recipe from making a cake?" (when you have no ingredients or oven). answer is: you don't
08:58:29 <poe_> Hiato that is parsed as (map) + ([1,2,3]) which is wrong
08:58:30 <roconnor> > sequence (map (+) [1,2,3]) 1
08:58:32 <lambdabot>   [2,3,4]
08:58:39 <KlutTut> hm
08:58:45 <Hiato> shachaf: right, so I guess the problem was the associativty of the functions
08:58:55 <shachaf> Hiato: If you "map 1" onto that, you get "[1 ((+) 1), 1 ((+) 2), 1 ((+) 3)]".
08:59:02 <zygoloid> Hiato: one thing you can do is, map ($ 1) (map (+) [1, 2, 3])
08:59:02 <KlutTut> nice metafor but i'm still bit confused about IO actoins
08:59:14 <aavogt> > map 1 $ map (+) [1..3]
08:59:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:59:15 <lambdabot>    `GHC.Num.Num a'
08:59:15 <lambdabot>      ari...
08:59:20 <aavogt> > map (id 1) $ map (+) [1..3]
08:59:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:59:21 <lambdabot>    `GHC.Num.Num a'
08:59:21 <lambdabot>      ari...
08:59:25 <roconnor> > map ($1) ( (map (+) [1,2,3]))
08:59:26 <poe_> roconnor nice one :)
08:59:27 <lambdabot>   [2,3,4]
08:59:27 <Hiato> blarg, what aboout map (1 $) (map (+) [1,2,3])?
08:59:28 <shachaf> Hiato: Yep, I was going to suggest what zygoloid said. Or make you figure it out. :-)
08:59:31 <ben> KlutTut: An action is an abstract thing. *You* cannot execute it. You can only compose it into a bigger action.
08:59:34 <Hiato> Ah, ninja'd again
08:59:40 <roconnor> > map ($1) $ map (+) [1,2,3]
08:59:42 <lambdabot>   [2,3,4]
08:59:42 <Hiato> ok, thanks guys :)
08:59:49 <ben> KlutTut: A haskell program eventually is a huge composition of composition of actions. Then the runtime executes the one single resulting action.
08:59:53 <zygoloid> KlutTut: this might help: http://metafoo.co.uk/practical-monads.txt
08:59:56 <shachaf> Hiato: (x $) = ($) x = x
09:00:02 <roconnor> > map ($1) . map (+) $ [1,2,3]
09:00:03 <shachaf> Hiato: Except for the types.
09:00:04 <lambdabot>   [2,3,4]
09:00:15 <Hiato> yeah, whoops, meant $ x :P
09:00:25 * roconnor didn't realize that map ($ x) = flip sequence x
09:00:31 <roconnor> kinda obvious though
09:00:41 <ben> damn that (-> r) monad
09:00:51 <ben> err, (->) r?
09:00:57 <zygoloid> yeah, the latter
09:01:13 <shachaf> (r->)monad++
09:01:16 <roconnor> @pl \x -> map ($ x)
09:01:17 <lambdabot> map . flip id
09:01:49 * zygoloid thinks GHC ought to support type operator left sections
09:01:52 <zygoloid> (r ->)
09:02:46 <roconnor> zygoloid: what about operator right sections?
09:02:56 <roconnor> I guess that is more problemantic
09:03:00 <roconnor> no type lambdas.
09:03:07 <shachaf> zygoloid: Of course. We get that in Caleskell, I'm sure I've been promised. Caleskell 2011!
09:03:22 <roconnor> Caleskell+++
09:03:25 * o-_-o now understands more than ever of haskell
09:03:34 <o-_-o> oops wrong window
09:03:49 <shachaf> o-_-o: Yes, that's completely off-topic!
09:03:53 <roconnor> :P
09:04:02 <o-_-o> :-)
09:04:14 <o-_-o> thanks shachaf and ben and others
09:05:56 <Baughn> How would I use haddock to link to a module in a different package?
09:08:26 <Baughn> ..and gah, why is my poor hello, world program 22MB? >_<;
09:08:47 <zygoloid> Baughn: the comma. without that it'd be one byte smaller at /least/ :)
09:09:21 <shachaf> Baughn: ...22MB? What did you do to it?
09:09:50 <Baughn> shachaf: Linked in.. um...
09:10:37 <Baughn> shachaf: base, bytestring, binary, stm, hslogger, network-fancy, derive, hsopenssl, old-time, containers, typehash, network, yjtools, random.. and monads-tf
09:10:41 <Baughn> shachaf: And their dependencies.
09:10:58 <shachaf> Baughn: Did you strip it, at least?
09:11:11 <Baughn> shachaf: No.. trying to get some backtraces. :P
09:11:24 <Baughn> Well, the linker command line is 200 lines
09:13:15 <shachaf> Baughn: I think you've answered your question, then.
09:14:23 <Baughn> shachaf: Takes forever, too. Geez.. I long for 6.12
09:14:38 <Baughn> In fact, I'm going to try RC2 now.
09:19:22 <o-_-o> so I wrote a function like
09:19:37 <o-_-o> palindrome [integer list]
09:19:44 <o-_-o> and it gives palindromes
09:19:53 <o-_-o> how do I make a main out of this
09:19:58 <o-_-o> so I can compile my file ?
09:20:11 <o-_-o> I want to call the function as
09:20:20 <o-_-o> palindrome [100..999]
09:20:22 <Baughn> o-_-o: You are allowed to put more than ten characters per line.
09:20:24 <o-_-o> and print the output in main
09:20:42 <flippo> Never odd or even.
09:21:10 <Gracenotes> hm. if types form a lattice, I guess there's no way for them to be cyclic... unless there are some weird type systems out there that allow this? :o
09:21:17 <Baughn> o-_-o: While you reflect on your sin, try $ main = print (palindrome [100..999]
09:21:23 <o-_-o> Baughn: I will try, it is a hard habit to break as my brain thinks in discrete packets :-)
09:21:29 <Baughn> ..did I seriously just use $ in irc?
09:21:37 <shachaf> Baughn++
09:21:56 <shachaf> Baughn: Although that's usually used for a shell command.
09:22:27 <Gracenotes> Baughn: I think a colon suffices when you're trying to eliminate quotation marks
09:22:40 <Gracenotes> not to say $ isn't all-purpose :P
09:22:45 * shachaf would be more concerned about the absence of a parenthesis.
09:23:30 <crash[`]> Gracenotes: irc phrase precedence? :P
09:23:35 <o-_-o> does the compiled program work faster than if I load the function inside gchi using :l and then execute it ?
09:23:47 <Baughn> Yes, by far. ghci is an interpreter.
09:23:56 <Baughn> Although you'll get another factor of 10 or so by passing -O2 to ghc
09:23:57 <o-_-o> Baughn: ok.
09:24:19 <Gracenotes> ghci doesn't directly interpret source; it does use special Haskell bytecode. which I think runhaskell can handle, too
09:24:39 <shachaf> Gracenotes $ Maybe that should be the new #haskell standard.
09:24:48 <Gracenotes> :o
09:24:49 <crash[`]> Gracenotes: to get that bytecode, however, it has to pass through a compiler
09:25:06 <Gracenotes> yeah. it's hard-wired into GHC, which has several compilation modes
09:25:07 <Gleesh> Been reading some tutorials on functional programming, and seen a fiew example of binary trees where they define the tree type as either being a leaf with data or a node containing 2 subtrees. Is it just me or is that incorrect? Shouldn't the node contain data too?
09:25:09 <crash[`]> if it were to not interpret directly that is
09:25:33 <crash[`]> Gleesh: depends on the type of tree. For example, a finger tree only stores data in its leaves
09:25:39 <tibbe> Gleesh: it's a design choice, some trees do some don't
09:25:49 <Baughn> Gleesh: No, that's a trie
09:25:58 <crash[`]> Baughn: uh what?
09:25:59 <Gracenotes> and a prefix-free trie, at that
09:26:11 <Baughn> Hm.. no, guess not
09:26:16 <Baughn> Gleesh: Er, never mind me.
09:26:19 <crash[`]> Baughn: a tree with data in each node could be a regular binary tree, or a binary search tree...
09:26:19 <Gracenotes> but yeah, it's a bit odd for regular binary trees. I prefer: Tree a = Nil | Branch (Tree a) a (Tree a)
09:26:48 <Baughn> crash[`]: Of course. I don't know why I had that notion..
09:26:48 <Gleesh> isn't it very unnessecary to have a bunch of nodes without data? why would you want that?
09:26:59 <crash[`]> Gleesh: wikipedia.org/wiki/finger_tree
09:27:00 <Gracenotes> (some people might replace Nil with Leaf a)
09:27:15 <Baughn> Gleesh: Well, it's not like the data takes up more space on a leaf than a node..
09:27:18 <crash[`]> That'd be a way of encoding a list, for example, which is (I believe) how haskell does i
09:27:19 <crash[`]> it
09:27:38 <Gracenotes> @src Tree
09:27:39 <lambdabot> Source not found.
09:28:12 <Gracenotes> :/ oh, just for typeclasses. well Haskell's way is equivalent to Tree a = Branch a [Tree a]. an n-ary tree
09:29:38 <Gracenotes> that kind of branch-data-less Tree would be suitable for prefix-free tries.. I think normal binary trees should have information on left, right, and element data per node (excluding leafs)
09:30:45 <crash[`]> Gleesh: I guess the real answer is just that sometimes trees need the structure more than you're concerned about a minor space consumption. You're right though, the structure you quoted is not what you probably learned in your data structures class :)
09:33:10 <Hiato> > map ($/) [1,2,3]
09:33:12 <lambdabot>   Not in scope: `$/'
09:33:28 <crash[`]> wut
09:33:52 <Hiato> Trying to layer two maps to take the ratio of every number to the previous in a list
09:34:13 <Hiato> that is, via currying, and I cant seem to get the application to function
09:34:38 <Hiato> crash[`]: any ideas?
09:34:41 <Lemmih> > zipWith (%) [1,2,3] [4,5,6]
09:34:43 <lambdabot>   [1 % 4,2 % 5,1 % 2]
09:34:47 <crash[`]> i was just going to say zipWith
09:34:47 <crash[`]> :)
09:35:00 <c_wraith> more specifically...
09:35:07 <c_wraith> zipwith and drop
09:35:07 <Hiato> Heh, yeah, I know. And you can do list processin, but I wanna see it done with two maps and currying
09:35:12 <c_wraith> or tail
09:35:21 <crash[`]> c_wraith: why do you need drop/tail?
09:35:29 <c_wraith> crash[`]: because he had one input list
09:35:38 <crash[`]> oh, i misintrepeted what he wrote
09:35:53 <dpratt71> reminds me of my fav version of fibs in Haskell
09:36:15 <shapr> Yay!
09:37:04 <dpratt71> fibs = 0¬†: 1¬†: zipWith (+) fibs $ tail fibs
09:37:57 <BONUS> i like fibs = 0:scanl (+) 1 fibs
09:38:25 <dpratt71> BONUS: hadn't seen that one before
09:38:32 <crash[`]> which is faster? :)
09:38:33 <Hiato> > map ($) $ map (+) [1,2,3]
09:38:34 <lambdabot>   [{-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4},{-3->-1;-2->0;-1->1;0->2;1->3;2-...
09:38:48 <Hiato> wha?
09:39:14 <crash[`]> Hiato: what does that even attempt to accomplish? lol
09:39:15 <BONUS> crash[`]: they're both faster
09:39:23 <BONUS> :P
09:39:26 <crash[`]> :P
09:39:37 <Hiato> I have no idea crash[`]. But that's the idea that I'm trying to get at
09:39:56 <c_wraith> > foldl' ((fst + snd *** snd) . (join (,)) (0, 0) [1,2,3]
09:39:58 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:40:34 <c_wraith> > foldl' ((fst + snd *** snd) . (join (,))) (0, 0) [1,2,3]
09:40:36 <lambdabot>   Couldn't match expected type `b -> a'
09:40:36 <lambdabot>         against inferred type `(b1, b...
09:40:50 <c_wraith> oh, right
09:41:13 <c_wraith> > foldl' ((fst + snd &&& snd) . (join (,))) (0, 0) [1,2,3]
09:41:14 <lambdabot>   Couldn't match expected type `b -> a'
09:41:15 <lambdabot>         against inferred type `(b1, b...
09:41:37 <c_wraith> blah.  I've confused myself again!
09:41:42 <Gleesh> crash: wasn't maily concerned about wasting space, just thought it was wierd that anyone would want empty nodes. :P Seems more logical to have data in everyone. isn't it easier to insert stuff to the right place if all the nodes have data so that you can compare it with the value that's to be inserted, and see if you should go left or right
09:42:15 <c_wraith> Gleesh:  Are you aware of B+ trees?  They don't keep data everywhere, and are generally preferred over B-trees
09:42:33 <Gleesh> c_wraith: no haven't heard of those. googling
09:43:19 <Polarina> @type &&&
09:43:21 <lambdabot> parse error on input `&&&'
09:43:29 <Polarina> @src &&&
09:43:30 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
09:43:31 <c_wraith> > foldl' ((fst + snd &&& snd) . (join (,))) 0 [1,2,3]
09:43:32 <lambdabot>   Couldn't match expected type `b -> a'
09:43:33 <lambdabot>         against inferred type `(b1, b...
09:43:48 <dpratt71> @type (&&&)
09:43:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:43:53 <Polarina> @type (&&&)
09:43:55 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:44:04 <c_wraith> Oh, I see what I'm doing wrong.  There's no clear answer.
09:44:22 <c_wraith> One of these days I'll figure out how to do what I mean. :)
09:44:46 <c_wraith> :t zipwith (+) . drop
09:44:48 <lambdabot> Not in scope: `zipwith'
09:44:54 <c_wraith> :t zipWith (+) . drop
09:44:56 <lambdabot>     Couldn't match expected type `[a]'
09:44:56 <lambdabot>            against inferred type `[a1] -> [a1]'
09:44:56 <lambdabot>     Probable cause: `drop' is applied to too few arguments
09:45:09 <c_wraith> :t zipWith (+) . tail
09:45:11 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
09:45:20 <c_wraith> :t join $ zipWith (+) . tail
09:45:22 <lambdabot> forall a. (Num a) => [a] -> [a]
09:45:53 <c_wraith> > let f = join $ zipWith (+) . tail in f [1..10]
09:45:55 <lambdabot>   [3,5,7,9,11,13,15,17,19]
09:46:31 <crash[`]> c_wraith: what module is join in?
09:46:42 <c_wraith> @hoogle join
09:46:43 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
09:46:44 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
09:46:44 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
09:46:51 <crash[`]> thanks
09:47:05 <c_wraith> I think you also need to import Control.Monad.Instances for the (->) monad instance
09:47:09 <crash[`]> yeah caught that
09:47:10 <c_wraith> which is the one I was using there
09:47:31 <crash[`]> @hoogle %
09:47:32 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
09:49:08 <crash[`]> > let f = join $ zipWith (%) . tail in f [1..10]
09:49:09 <lambdabot>   [2 % 1,3 % 2,4 % 3,5 % 4,6 % 5,7 % 6,8 % 7,9 % 8,10 % 9]
09:49:23 <crash[`]> c_wraith is a genius or something
09:49:42 <c_wraith> Nah. I've just got some practice. :)
09:49:42 <crash[`]> but Hiato already left :P
09:50:38 <c_wraith> also, that may not have been what he wanted
09:50:53 <c_wraith> since if you look at the output closely
09:50:57 <c_wraith> You'll see it's backwards.
09:51:15 <c_wraith> > let f = join $ zipWith (flip (%)) . tail in f [1..10]
09:51:17 <lambdabot>   [1 % 2,2 % 3,3 % 4,4 % 5,5 % 6,6 % 7,7 % 8,8 % 9,9 % 10]
09:51:19 <crash[`]> Mmm
09:51:23 <c_wraith> That's better
09:53:40 <crash[`]> c_wraith, do you haskell professionally or as a hobbyist/
09:54:25 <c_wraith> Professionally, actually.  In an experimental capacity.
09:59:13 <__JN> Hello, can someone help me with a Parsec question? I have a large CSV file (1,5 millon rows) which I'm trying to parse using endBy and sepBy. Problem is, it's eating a lot of RAM so it can't handle a file that large. Is there some other way to read in a file like that in a more economic way?
09:59:45 <poe> __JN you might use lazy bytestrings
10:00:06 <Lemmih> __JN: http://hackage.haskell.org/package/bytestring-csv
10:00:49 <__JN> ok, thanks for the tip
10:08:46 <ddarius> This may also be interesting: http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=2724
10:08:49 <mmorrow> __JN: possibly helpful too (as an alternative to bytestring-csv) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724
10:08:52 <mmorrow> hah
10:08:57 <mmorrow> ddarius: :)
10:09:06 <mmorrow> i really need to package that
10:09:21 <ddarius> mmorrow: Or make a patch for bytestring-csv ?
10:09:46 <mmorrow> ddarius: bytestring-csv though uses alex, so it's incompatible
10:10:46 <mmorrow> alex + e.g. uses ByteString.lines to split lines (w/ actually makes it unable to handle \n's in fields..)
10:11:18 * mmorrow packages that right now, and gets some other hackage pkg maintenance he's been avoiding out of the way as well
10:14:16 <mmorrow> (actually, i can't remember if it (it := bytestring-csv) does or doesn't handle newlines in fields, so don't take my word for that)
10:16:43 <__JN> mmorrow, ddarius: thank you! I'll check it out.
10:16:59 <jkff> Hi. Are there any papers on the essence and various forms of type polymorphism? Not papers on particular forms, but papers highlighting their differences
10:17:09 <jkff> And giving more or less precise definitions
10:17:48 <jkff> Wikipedia says one thing, Saizan_ says an other thing, I think a third thing, people-more-competent-than-me name Strachey's classification outdated..
10:18:27 <ddarius> jkff: http://www.pps.jussieu.fr/~kesner/papers/fcp.pdf  This covers the dynamic pattern calculus which is able to easily represent various forms of polymorphism including some unusual ones.
10:19:38 <jkff> ddarius: Thanks, that's very interesting, but the paper doesn't even mention the word 'parametric', which means it is definitely not a paper about classification of polymorphism :)
10:21:10 <ddarius> jkff: Yeah, I want a different paper in that vein.
10:21:53 <chrisdone> what's the mzero value for the IO monad?
10:21:56 <chrisdone> () ?
10:21:56 <jkff> Well, probably this time I'll have more luck discussing that question: is there any difference in the nature of polymorphism of (+) and sum?
10:22:17 <jkff> Or of (+) and plus=(+) ?
10:22:30 <ddarius> http://www-staff.it.uts.edu.au/~cbj/Publications/patterns_book_intro.pdf
10:22:41 <idnar> @type mzero
10:22:42 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
10:22:44 <roconnor> @src mzero IO
10:22:46 <lambdabot> Source not found. Wrong!  You cheating scum!
10:22:50 <zygoloid> chrisdone: possibly undefined and catch?
10:22:51 <ddarius> jkff: No.
10:22:52 <zygoloid> (mzero and mplus)
10:23:03 <idnar> can't be ()
10:23:04 * roconnor gusses throw "mzero"
10:23:10 <jkff> ddarius: Do they both qualify, then, as bounded parametric, or as ad-hoc?
10:23:15 <shachaf> @instances MonadPlus
10:23:16 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:23:30 <shachaf> Why is IO a MonadPlus anyway?
10:23:39 <crash[`]> this is a non-haskell specific question, but I've got a phone interview in 30 minutes.. the last part of the interview, they have you ask questions.. and I can't think of any to ask lol
10:23:40 <chrisdone> ah, Exception: user error (mzero)
10:23:45 <roconnor> instance MonadPlus IO where
10:23:47 <roconnor>         mzero       = ioError (userError "mzero")
10:23:49 <roconnor>         m `mplus` n = m `catch` \_ -> n
10:23:59 <roconnor> I was more or less right.
10:24:02 <zygoloid> crash[`]: "what's in the special sauce?" depends where you're inreviewing
10:24:08 <zygoloid> roconnor: likewise :)
10:24:08 <path[l]> could someone explain why this is failing? Ive imported import qualified Data.ByteString.Lazy.Char8 as BS and Im doing import qualified Data.ByteString.Lazy.Char8 as BS
10:24:10 <crash[`]> lol
10:24:12 <path[l]> err
10:24:13 <c_wraith> crash[`]: ask about the company's history, what the work environment is like, stuff like that.
10:24:19 <shachaf> crash[`]: "What would be a good question to ask?"
10:24:25 <roconnor> zygoloid: I was more right than you :D
10:24:26 <crash[`]> here's the problem: all that information is incredibly well-known
10:24:27 <ddarius> jkff: They are neither.
10:24:27 <path[l]> could someone explain why this is failing? Ive imported import qualified Data.ByteString.Lazy.Char8 as BS and Im doing listArray (1, BS.length xs) (BS.unpack xs)
10:24:27 <chrisdone> roconnor: that's actually quite a useful instance
10:24:35 <chrisdone> roconnor: never thought of handling errors with mplus
10:24:35 <jkff> ddarius: which are they, then?
10:24:56 <zygoloid> roconnor: well i mentioned the 'catch' bit too ;p
10:25:05 <path[l]>     Couldn't match expected type `Int'
10:25:05 <path[l]>            against inferred type `GHC.Int.Int64'
10:25:05 <path[l]>     In the expression: BS.length xs
10:25:06 <path[l]>     In the first argument of `listArray', namely `(1, BS.length xs)'
10:25:07 <diginux> crash[`]: could ask your interviewer why he/she chose to work there
10:25:07 <crash[`]> it's all published quite clearly across their site/founders personal site
10:25:08 <roconnor> chrisdone: I'm told this is defined in Monad.Error
10:25:19 <crash[`]> is it kosher to ask the interview stuff specifically?
10:25:26 <chrisdone> roconnor: cheers
10:25:27 <crash[`]> rather, personal vs company info
10:25:39 <zygoloid> crash[`]: which country are you in?
10:25:54 <diginux> crash[`]: depends, you should get a feeling pretty quickly what kind of personality the person has, some people like to share, others dont
10:26:00 <path[l]> crash[`]: what's my career path? What kind of goals do we set? Do we ever use these technologies (x, y, z).
10:26:11 <crash[`]> zygoloid: america
10:26:18 <crash[`]> rather USA
10:26:23 <roconnor> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error.html
10:26:24 <crash[`]> thanks for all the help folks btw :)
10:26:33 <EnglishGent> can anyone suggest a good intro to random number generation in Haskell? i.e. how *exactly* one uses System.Random (I know it exists, but that's it)
10:26:40 <jkff> ddarius: Don't type classes implement ad-hoc polymorphism?
10:26:53 <path[l]> anyone know how I can fix my problem?
10:27:01 <path[l]> I thought Int was Int
10:27:21 <jkff> path[l]: BS.length returns Int64, which is not Int
10:27:34 <chrisdone> >            wordThatFits :: Word -> [Word] -> Maybe Word
10:27:34 <chrisdone> >            wordThatFits w@word ws@alreadyPlacedWords = ...
10:27:34 <chrisdone> is this ever considered good practise? I imagine it might've been before haddock
10:27:35 <lambdabot>   Not in scope: `wordThatFits'
10:27:35 <lambdabot>   <no location info>: parse error on input `='
10:27:36 <path[l]> the webpage says it returns Int though
10:27:40 <EnglishGent> path[l] - did you compile everything on the same box? I ran into that whilst trying to link stuff from different machines together (the size of Int is platform specific)
10:27:41 <ddarius> jkff: No.
10:27:51 <path[l]> yeah its just one file
10:28:08 <path[l]> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.5/doc/html/Data-ByteString-Char8.html#v%3Atail <--- length is supposed to return Int
10:28:08 <ddarius> jkff: In this paper, type class polymorphism is described as "qualified types" http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.2778
10:28:22 <path[l]> I dont mind converting it if I knew how
10:28:26 <path[l]> fromIntegral?
10:28:31 <jkff> ddarius: In wadler's paper "How to make ad-hoc polymorphism less ad-hoc", type classes are explicitly named "a new approach to ad-hoc polymorphism"
10:28:33 <EnglishGent> hmm - post the code somewhere & let the channel take a look at it? :)
10:28:53 <roconnor> ddarius: the haskell 98 report calls class polymorphism ad-hoc polymorphism.
10:29:02 <path[l]> hmm that worked
10:29:03 <path[l]> wow
10:29:21 <roconnor> in section 1.3
10:29:36 <ddarius> There are things I can do with ad-hoc "polymorphism" in (most) languages that I can't do with type classes because they are more structured.
10:30:25 <chrisdone> @hoogle (a -> Bool) -> a -> Maybe a
10:30:26 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
10:30:28 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
10:30:28 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
10:30:39 <chrisdone> :t flip find . return
10:30:39 <zygoloid> ddarius: example?
10:30:40 <lambdabot> forall a. a -> (a -> Bool) -> Maybe a
10:30:58 <Baughn> ddarius: Such as?
10:31:02 <path[l]> bah switching to bytestring didn't help me at all
10:31:03 <jkff> ddarius: Is there a precise definition of ad-hoc polymorphism at all?
10:31:10 <roconnor> @type const Just
10:31:12 <lambdabot> forall a b. b -> a -> Maybe a
10:31:18 <Baughn> path[l]: It's not the bytestring, it's the laziness
10:31:22 <Baughn> path[l]: How are you parsing this?
10:31:30 <Baughn> path[l]: (And reading it?)
10:31:33 <ddarius> roconnor, jkff: Using "ad-hoc polymorphism" for a catch-all for anything that isn't inclusion polymorphism or parametric polymorphism, then I agree type classes are ad-hoc polymorphic, but they are distinctly more structured than the wikipedia description of ad-hoc polymorphism.
10:31:38 <roconnor> @djinn (a -> Bool) -> a -> Maybe a
10:31:39 <lambdabot> f a b =
10:31:40 <lambdabot>     case a b of
10:31:40 <lambdabot>     False -> Nothing
10:31:40 <lambdabot>     True -> Just b
10:32:29 <path[l]> Baughn: no I fixed the int problem. Thing is I've been trying to write code for an online contest (which is a frontend that uses SPOJ) and my code is wayyy slower than C or Java codes. So I was using this link -> http://www.haskell.org/haskellwiki/SPOJ
10:32:49 <ddarius> zygoloid, Baughn: Starting off with Haskell 98 type classes (let alone the original type classes), I already couldn't overload a function based on two arguments separately as I easily would be able to in C++.
10:33:17 <roconnor> It's kinda impressive the function djinn picked is "right"
10:33:36 <roconnor> it could have easily swaped the True and False branches.
10:33:53 <roconnor> but it picked it on the order of the constructors (I presume).
10:34:02 <chrisdone> roconnor: wake up sheeple
10:34:02 <path[l]> this is my code -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5120#a5137 (along with cost center analysis and memory graphs)
10:34:05 <ddarius> roconnor: I believe so.
10:34:12 <chrisdone> roconnor: lambdabot is sentient
10:34:23 <path[l]> I cant figure out how to make it faster
10:34:36 <path[l]> except maybe using a mutable array
10:34:36 <roconnor> It is also kind nice that djinn tries to use all the parameters.
10:34:50 <roconnor> it could have simply returned Nothing.
10:34:52 <ddarius> roconnor: It's almost necessary for the way it proves things.
10:35:10 <jkff> ddarius: Well, I agree that type classes are not the widest imaginable form of ad-hoc polymorphism, but it doesn't seem like they are not a form of it at all, if we say that ad-hoc polymorphism is a form of polymorphism where a value has several definitions depending on the particular narrowing of its type
10:35:17 <ben> @djinn Int -> Int -> Int
10:35:17 <lambdabot> Error: Undefined type Int
10:35:18 <chrisdone> @djinn (a -> b -> Bool) -> a -> b -> Either a b
10:35:18 <lambdabot> f a b c =
10:35:18 <ben> aww
10:35:18 <lambdabot>     case a b c of
10:35:18 <lambdabot>     False -> Left b
10:35:18 <lambdabot>     True -> Right c
10:35:56 <roconnor> ben: only works on non-recursive finite types.
10:36:10 <ddarius> jkff: That's fine but that's an extremely broad definition which could be stretched to encompass all forms of polymorphism.
10:36:25 <ben> roconnor: Surely Int is finite. I mean, it is bounded.
10:36:32 <roconnor> ben: useful to derive the defintion of callCC.
10:36:42 <roconnor> ben: ah yes, it could in theory do Int.
10:36:53 <jkff> I think parametric polymorphism doesn't fit in here.
10:36:53 <ddarius> Just put in 2^30 cases.
10:36:54 <roconnor> but it would probably be slow and dumb.
10:37:05 <ben> I suppose
10:37:27 <jkff> Oh well, it seems like there's no consensus on what ad-hoc polymorphism is :)
10:37:57 <ddarius> jkff: For me, it means overloading.  Many don't consider it a form of polymorphism.
10:38:03 <roconnor> @wikipedia ad_hoc
10:38:05 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=ad_hoc
10:38:20 <roconnor> Ad hoc is a Latin phrase which means "for this purpose". It generally signifies a solution designed for a specific problem or task, non-generalizable, and which cannot be adapted to other purposes.
10:38:45 <roconnor> kinda makes sense that there is no consensus on the definition of ad-hoc polymorphism :)
10:38:50 <jkff> Heh
10:39:49 <EnglishGent> can anyone suggest a good intro to random number generation in Haskell? i.e. how *exactly* one uses System.Random (I know it exists, but that's it)
10:40:47 <jkff> So, ad-hoc'ness, parametricity and various forms of bounded quantification are not disjoint at all.
10:41:02 <jkff> EnglishGent: http://www.google.com/codesearch?q=import+system.random
10:41:24 <ddarius> jkff: Do you consider bounded quantification ad-hoc polymorphic, as it does meet the definition you gave before?
10:41:32 <EnglishGent> thanks jkff :)
10:41:57 <jkff> ddarius: I'd say that according to my definition, (+) is ad-hoc polymorphic, whereas plus=(+) is not, because (+) has several definitions and plus has only one
10:42:19 <ddarius> jkff: I asked about bounded quantification.
10:42:54 <jkff> No, I don't consider it ad-hoc polymorphic
10:43:21 <byorgey> EnglishGent: I suggest using the MonadRandom package
10:43:42 <path[l]> so anyone good at figuring out how to speed up stuff?
10:43:45 <roconnor> EnglishGent: http://www.haskell.org/haskellwiki/Examples/Random_list
10:43:54 <roconnor> EnglishGent: actually nevermind
10:44:46 <jkff> ddarius: For example, I don't consider sum :: (Num a) => [a] -> a to be ad-hoc polymorphic because it has exactly one definition that is universal in the sense that every time you're using sum, you're using that definition
10:44:48 <zygoloid> ddarius: ok, by "type classes" i was assuming something wider than haskell'98: in particular, at least MPTC, flexible instances and maybe one of fundeps and type families
10:45:53 <zygoloid> jkff: if on the other hand it were 'class Num a where sum :: [a] -> a', it'd be hard to argue that it's anything other than ad-hoc polymorphism i think
10:46:06 <crash[`]> 10 minutes till my interview.. nerves are killing me :)
10:46:08 <jkff> zygoloid: Yes, then sum would be ad-hoc
10:46:34 <jkff> Thus, polymorphism is not just a property of a type or of a value definition. It's a property of a typed identifier, perhaps..
10:47:31 <path[l]> phone interview?
10:47:43 <jkff> More precisely, the particular form of polymorphism is not a property of things above: the property of being polymorphic or not is a property of a type: if it has a quantifier at the top level, then it is polymorphic.
10:47:59 <crash[`]> yeah phone
10:48:02 <jkff> That also means that (forall a . a) -> String is monomorphic, for instance. Is it?
10:49:00 <roconnor> jfkk that isn't haskell 98
10:49:06 <roconnor> but it seems monomorphic to me.
10:49:27 <jkff> roconnor: glad I'm not alone in that opinion :)
10:49:36 <roconnor> maybe someone will convince me otherwise
10:56:35 <zygoloid> jkff: it also means that ad-hoc versus parametric polymorphism is not a dichotomy -- rather, there's a sliding scale. (+) is more ad-hoc than fix, for instance, i think
10:56:59 <jkff> Well of course, because fix is not even bounded :)
10:57:05 <jkff> At least parametricity has a clear definition
11:05:25 <jkff> Well, another question: is an existential type polymorphic? For instance, exists s . (s, s -> String) ? TAPL calls it "existential polymorphism", but it seems to me like something's wrong here
11:07:02 <jkff> Maybe it is a form of subtyping polymorphism
11:07:31 <jkff> Because this type expession denotes the union of all its subtypes, namely (Int, Int->String) etc.
11:08:15 <jkff> Looks like there is a duality between parametric polymorphism and subtyping
11:09:23 <jkff> Universal quantification denotes intersection whereas existential quantification denotes union
11:10:40 <jkff> And exists s . (s, s -> String) can be encoded as forall r . (forall s . (s, s -> String) -> r) -> r
11:11:18 <jkff> Quite funny. Something to do with covariance and contravariance?..
11:14:48 <chrisdone> I can't believe I've been using `any id $ map ..'
11:14:50 <chrisdone> :D
11:15:34 <roconnor> @type or
11:15:39 <jkff> It has probably been fused away anyways
11:15:42 <lambdabot> [Bool] -> Bool
11:15:54 <roconnor> oh
11:15:55 <jkff> roconnor: any id $ map f xs == any f xs
11:15:58 <roconnor> ya
11:16:00 <roconnor> :)
11:16:08 <chrisdone> ohhhhhhhhhhhhh hell yeah!!!!
11:16:15 <chrisdone> thsi is why I code haskell
11:16:18 <roconnor> any id f = or f
11:16:25 <roconnor> hence
11:16:31 <roconnor> or $ map f xs = any f xs
11:16:38 <chrisdone> 15 minutes writing code without running it, run it first time and wallah
11:16:48 <roconnor> in any case "any id" is very very silly
11:16:48 <chrisdone> http://chrisdone.com/wordclouds/output.png
11:16:54 <chrisdone> worked perfectly!!
11:16:54 <roconnor> chrisdone: you need to use dr.haskell on your code
11:17:20 <dcoutts> anyPar p xs = or (parMap rnf p xs)
11:17:46 <roconnor> dcoutts: does par give you parallel or?
11:17:58 <roconnor> I didn't think it did
11:17:59 <chrisdone> roconnor: I think it's because I wrote this earlier and it stuck in my muscle memory: any id $ [ overlap n (r1,size) (r2,size) | r1 <- s1, r2 <- s2 ]
11:18:09 <dcoutts> roconnor: that's doing the or serially, but doing the property in parallel
11:18:12 <toast-opt> cool, is that a haskell word cloud?
11:18:19 <chrisdone> toast-opt: it sure is!
11:18:31 <roconnor> dcoutts: too bad.
11:18:41 <chrisdone> toast-opt: what text shall I try putting it through?
11:19:02 <dcoutts> roconnor: I bet there's very little to gain in trying to do that in parallel
11:19:10 <jkff> chrisdone: Haskell'98 report?
11:19:19 <dcoutts> roconnor: you'd want to use something other than a list
11:19:26 <toast-opt> chrisdone - how about its own source?
11:19:39 * roconnor remembers to go to chrisdone to figure out the font extents
11:19:42 <roconnor> dcoutts: ?
11:19:46 <toast-opt> can it do punctuation?
11:19:53 <roconnor> dcoutts: why not,   if or did parallel or, it'd be great.
11:20:01 <toast-opt> what font library are you using?
11:20:07 <chrisdone> toast-opt: it ignores punctuation. I'm using libgd
11:20:11 <mmorrow> gah, the specialized csv-parser for CRLF for EOL is a tad bit more than a non-trivial extension of just LF EOL, gonna save this for later, but at least i've got the csv code organized..
11:20:24 <dcoutts> roconnor: because the total running time of the or is tiny, once each element is reduced to True/False
11:20:35 <dcoutts> roconnor: just traversing the list once is a trivial cost
11:20:40 <mmorrow> two-token look-ahead adds like 4 more states..
11:20:50 <toast-opt> chrisdone, i tried to import Gd, and quickly found that it's not in the windows install of ghc
11:21:06 <roconnor> dcoutts: ya, but with parallel or, once the first element is reduced to True, a final result of True will be quickly returned.
11:21:35 <roconnor> dcoutts: actually I suppose there is no point in using par here if you have parrellel or
11:21:46 <chrisdone> toast-opt: yeah, I'm on ubuntu and I had to install libgd-dev
11:21:47 <dcoutts> roconnor: not if you're using normal or
11:21:50 <mmorrow> roconnor: parallel or ==> "full abstraction" !! (whatever that means ..., but i read that this is the case)
11:21:54 <dcoutts> roconnor: I mean normal ||
11:22:09 <toast-opt> chrisdone, not on mac osx either
11:22:10 <toast-opt> :(
11:22:26 <mmorrow> roconnor: (iirc "full abstraction" := the semantics are completely independent of any particular implementation)
11:22:28 <chrisdone> toast-opt: should be able to build libgd from source?
11:23:12 <toast-opt> chrisdone, eh, trying to avoid anything i can't use at work
11:23:12 <dcoutts> roconnor: anyway, the version I was using was actually forAllPar xs prop = and (parMap rnf prop xs)
11:23:21 <mmorrow> well, s/semantics/observable behavior/ (or something) i guess
11:23:28 <dcoutts> oh, he disappeared
11:23:30 <mmorrow> dcoutts: he just bailed
11:23:34 <mmorrow> heh
11:23:58 <toast-opt> chrisdone, so, can you feed the source for the word cloud in?
11:24:13 <chrisdone> toast-opt: yeah I'll try now
11:24:19 <ddarius> mmorrow: It means everything the denotational semantics can represent can be represented in the operational syntax.
11:24:45 <mmorrow> ddarius: yes! that is the exact definition, now that you remind me.
11:24:51 <toast-opt> but yeah, i can use BSD style stuff typically, but often not GPL'd
11:25:28 <ddarius> mmorrow: For that particular case, for PCF, the por was a monotonic function of domain theory that usually wasn't represented.
11:26:11 <toast-opt> of course, WTFPL is my personal favorite open source license ^_^
11:26:15 <mmorrow> ddarius: (we're talking about from that one book, right?)
11:26:28 <toast-opt> can't use WTFPL at work either, but i think it's hilarious! :)
11:26:30 <mmorrow> ddarius: hmm, what does "represented" mean here?
11:26:55 <ddarius> mmorrow: Was not expressible.
11:26:55 <path[l]> whats wtfpl
11:27:13 <ddarius> mmorrow: Perhaps we are talking about from that one book, but I've never read that one book.
11:27:15 <BONUS> i prefer the GPL (Goatse Prostate License)
11:27:30 <mmorrow> ddarius: by the ocaml guy
11:27:36 <Zao> BONUS: Many eyes on the source there.
11:27:36 <mmorrow> ddarius: (trying to google for the name..)
11:27:39 <ddarius> Remy?
11:27:45 <toast-opt> @google wtfpl
11:27:47 <mmorrow> err, not sure yet
11:27:47 <lambdabot> http://sam.zoy.org/wtfpl/
11:27:47 <lambdabot> Title: WTFPL - Do What The Fuck You Want To Public License
11:27:49 <chrisdone> toast-opt: http://chrisdone.com/wordclouds/ownsource.png
11:27:55 <chrisdone> toast-opt: heh, I'll try including operators
11:28:03 <toast-opt> heh, sweet
11:28:04 <ddarius> or Leroy?
11:28:06 <mmorrow> gah, i can't even find the workspace with firefox open on it..
11:28:16 <toast-opt> yeah, can you use the Haskell tokenizer?
11:28:24 <toast-opt> the lexer
11:28:37 <toast-opt> ... see if you can get the white-space-implied curly braces
11:28:58 <int-e> mmorrow: heh, maybe look for the associated core dump instead
11:28:58 <mmorrow> ddarius: ah, Curien
11:29:00 <mmorrow> http://www.amazon.com/gp/product/B001EWFCJC/ref=pd_lpo_k2_dp_sr_1/180-2235785-6378641?pf_rd_m=ATVPDKIKX0DER&pf_rd_s=lpo-top-stripe-1&pf_rd_r=02VTJK68GA2BEWEZE1F7&pf_rd_t=201&pf_rd_p=486539851&pf_rd_i=0817636544
11:29:09 <mmorrow> int-e: hehe
11:29:17 <ddarius> toast-opt: Depending on what you need, there is a lex function.
11:29:21 <mmorrow> Categorical Combinators, Sequential Algorithms and Functional Programming
11:29:33 <mmorrow> maybe not OCaml actually
11:29:46 <ddarius> The CAM book.
11:29:48 <mmorrow> but Caml or something involving *Caml
11:29:52 <mmorrow> ddarius: yesh.
11:30:00 <toast-opt> chrisdone, that is pretty awesome
11:30:21 <ddarius> SML is Standard Meta Language, Caml is Categorical Abstract Machine Language.
11:30:26 <chrisdone> toast-opt: it's quite slow to generate. I have various optimisations up my sleeve that I'll apply, but only after I'm happy with how it works
11:30:36 <ddarius> (Though now (O')Caml is based on the ZINC machine.)
11:30:42 <toast-opt> chrisdone, looks fine :)
11:30:43 <toast-opt> how long did that take to generate?
11:31:00 <chrisdone> toast-opt: that one took 19 seconds
11:31:25 <toast-opt> chrisdone - how many LOC?
11:32:13 <chrisdone> toast-opt: about 500 including comments. I'm doing bird-style literate haskell. hoping to make it into an article
11:32:42 <McManiaC> how do you add class constrictions to a "type/newtype" definition?
11:32:50 <mmorrow> it's a pretty cool book, although somewhat pricey
11:32:57 <toast-opt> hmm, does ghci have a way to execute a console command wo leaving ghci?
11:33:10 <toast-opt> something like os.system(r"ls -a")
11:33:17 <chrisdone> toast-opt: kind of lapsed on the commenting on the main algorithm but I need to tidy it all up anyway http://chrisdone.com/wordclouds/src/WordClouds.lhs.html
11:33:29 <mmorrow> toast-opt: :! echo yes
11:33:46 <chrisdone> toast-opt: woops, disregard that link. let me re-export it
11:33:49 <toast-opt> chrisdone, is that literate code?
11:33:53 <toast-opt> haven't seen
11:34:04 <mmorrow> toast-opt: (or System.Cmd.system "echo yes")
11:34:07 <ddarius> mmorrow: I'd like to read The Algebra of Programming some day, but it is very pricey.
11:34:14 <chrisdone> toast-opt: k, refresh. it's not Knuth-style literate. but it is literate haskell, yeah
11:34:22 * mmorrow looks that one up
11:34:38 <toast-opt> heh, :! works but it doesn't keep my aliases :S
11:35:03 <toast-opt> (windows.  i'm used to command line tools not really working.  even windows-oriented stuff gets it wrong)
11:35:21 <ddarius> mmorrow: http://www.amazon.com/Algebra-Programming-Prentice-Hall-International-Computer/dp/013507245X/ref=ntt_at_ep_dpi_4
11:36:25 <mmorrow> ddarius: holy crap, is it out of print or something?
11:37:04 <toast-opt> chrisdone, do you know if there are any pure-haskell graphics libs?
11:37:46 <toast-opt> pure-functional would be particularly appreciated
11:38:04 <chrisdone> toast-opt: pretty sure there are a few on Hackage
11:38:20 <chrisdone> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
11:38:44 <mmorrow> ddarius: oh wait, (looking at "look inside"), that looks similar (the tex style) to some other paper you linked me too that i said i wanted the tex source for. any relation?
11:39:26 <toast-opt> chrisdone, mostly i'm looking for png encoder
11:39:30 <toast-opt> only found _de_coders so far
11:39:36 <toast-opt> like Codec.Image.PNG
11:40:25 <mtnviewmark> ping dcoutts
11:40:33 <chrisdone> I wrote all this in one go without testing it and it worked perfectly first time: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13264#a13264 am I just an awesome programmer or is Haskell REALLY good at helping you do this?
11:40:37 <ddarius> mmorrow: It's probably just the series's style.
11:40:47 <toast-opt> heh, haskell must be really good :)
11:40:50 <chrisdone> toast-opt: a pure PNG encoder would be a cool project
11:40:52 <bos> preflex: seen dons
11:40:55 <preflex>  dons was last seen on #haskell 1 day, 1 hour, 48 minutes and 13 seconds ago, saying: bos: i've requested a project be created.
11:41:21 <ddarius> chrisdone: You are just supposed to always assume it is your amazing programming skills.
11:41:22 <mmorrow> toast-opt: heh, i've actually got one that does a subset of the possible PNG possibilities. it should work, but i haven't touched it in a long time: http://moonpatio.com/repos/png-writer/
11:41:31 <toast-opt> chrisdone, well, i've wanted to do my own encoders, esp in a lazy language
11:41:36 <ddarius> chrisdone: There is a pure JPEG encoder/decoder (one of the two or maybe both)
11:41:44 <toast-opt> but i only started haskell last week
11:42:09 <toast-opt> ddarius, where at?  maybe they have a lossless encoder
11:42:29 <mmorrow> well, s/subset of the possible PNG possibilities/i think all the ones you'd want/
11:42:33 <chrisdone> ddarius: that'll be a good starting point for studying/getting ideas from then
11:42:50 <chrisdone> mmorrow: oh nice one!
11:42:53 <mmorrow> for JPEG you've got to implem a discrete cosine transform
11:43:15 <mtnviewmark> question: Am I right in thinking that if I read a file into a lazy ByteString (say, via, hGetContents) and then pass that lazy ByteString to pure code, that the handle will be read, as needed, during the computation of the pure code?
11:43:33 <toast-opt> mmorrow, i thought the lossless codec uses something totally different?
11:43:39 <tibbe> mtnviewmark: yes
11:43:41 <chrisdone> mtnviewmark: that's right
11:43:52 <mmorrow> toast-opt: hmm, jpeg is lossy though, do you mean a different format?
11:43:54 <ddarius> The one I was thinking about is in Gofer (I thought it was just old Haskell) http://people.cs.uu.nl/jeroen/article/jpeg/index.html  There appears to be another.
11:43:55 <tibbe> mtnviewmark: remember that the file wont be closed until you demanded the complete input
11:44:05 <mmorrow> ddarius: ah right, that's a good one
11:44:14 <mtnviewmark> excellent - follow on: does ByteString have to do magic to get that behavior, or is it written in just Haskell?
11:44:17 <mmorrow> i actually tried to find that a few months ago and couldn't
11:44:19 <toast-opt> mtnviewmark - i don't think it will do the IO lazily -- io will return you an IO byteString, not a pure byteString
11:44:40 <mmorrow> (unfortunately he does O(n^2) convolution for the discrete cosine tranform though)
11:44:41 <toast-opt> mtnviewmark - so the read isn't lazy, but i think the processing of it can be
11:44:45 <tibbe> toast-opt: it uses unsafeInterleaveIO
11:44:55 <chrisdone> mtnviewmark: I have implemented hGetContents with unsafeInterleaveIO, IIRC that's what it uses
11:44:57 <toast-opt> tibbe, oh, cool.  so it is lazy
11:44:58 <ddarius> mmorrow: It's an extremely unoptimized implementatino.
11:45:03 <tibbe> toast-opt: so it actually interleaves read calls
11:45:04 <mtnviewmark> ooooo that sounds like a fun and dangerous function
11:45:17 <toast-opt> very fun and dangerous :)
11:45:22 <mmorrow> ddarius: heh, yeah that too
11:45:27 <toast-opt> i wonder if it uses transactional IO
11:45:38 <bos> tibbe: want to have a Data.Binary weep-fest with me and mtnviewmark ?
11:45:55 <tibbe> bos: sure
11:45:55 <toast-opt> then it would be really pure
11:45:59 * mtnviewmark gets out his hanky
11:46:05 <chrisdone> mmorrow: wth
11:46:11 * mmorrow calls a waahbulance
11:46:16 <bos> i deeply wish the API was continuation-based.
11:46:18 <mmorrow> *waahmbulance
11:46:24 <chrisdone> mmorrow:  get = get >>= \a -> get >>= \b -> get >>= \c -> ..   return (PngIHdr a b c d e f g)
11:46:28 <mmorrow> bos: yeah, that'd be cool
11:46:28 <toast-opt> tibbe, do you know if it uses transactional file operations where available?
11:46:36 <tibbe> bos: me too. apparently lennart's first attempt resulted in a slowdown
11:46:37 <chrisdone> mmorrow: this before you discovered `ap` or Applicative? :P
11:46:42 <mmorrow> chrisdone: hah, iirc that's generated
11:46:45 <tibbe> toast-opt: I don't think so
11:46:47 <chrisdone> ahh :P
11:46:48 <bos> tibbe: i'm not too surprised.
11:46:54 <mtnviewmark> I deeply wish it supported de-serialization errors
11:47:03 <toast-opt> mmorrow, jpeg has multiple sub formats.  one of them is a lossless format
11:47:22 <tibbe> bos: I'm not quite sure why, normally it would lazily interleave read calls, now it returns a continuation, calls read and pushes the data
11:47:35 <toast-opt> mmorrow, but many codecs don't implement lossless encoding.  crappy ones forget to implement lossless decoding, so they'll reject perfectly valid jpeg
11:47:43 <tibbe> bos: but I'm not too surprised either but I'd like to take some time to read the core
11:47:46 <mmorrow> chrisdone: if i did that again, i'd ditch the GADTs i think
11:47:57 <toast-opt> @google lossless jpeg
11:47:58 <lambdabot> http://en.wikipedia.org/wiki/Lossless_JPEG
11:47:59 <lambdabot> Title: Lossless JPEG - Wikipedia, the free encyclopedia
11:48:05 * tibbe pulled two wisdom teeth and his face is oversized.
11:48:41 <toast-opt> so, which library is a pure functional JPEG encoder?
11:48:45 <mmorrow> toast-opt: ah, it uses a completely diff algorithm
11:48:46 <toast-opt> i think i missed it
11:48:52 <toast-opt> mmorrow, yes, very different
11:49:02 <toast-opt> like jpeg2000
11:49:03 <tibbe> bos: as long as the current chunk being decoded runs in a tight loop returning a continuation every e.g. 4k shouldn't be that bad
11:49:37 <mmorrow> toast-opt: so i guess that it's also named "jpeg" is just a byproduct of the name of that group or whatever, and not to say it's related to "regular" jpeg format
11:49:50 <mtnviewmark> er, so, seems like Binary has several issues and design directions going on at once here:  error support, continuation based input/output (have I got that right), efficiency, better API (?),
11:49:54 <bos> tibbe: right
11:50:08 <tibbe> mtnviewmark: yes
11:50:11 <bos> mtnviewmark: the continuation and error support ought to be the same thing
11:50:25 <ddarius> toast-opt: There is no practical purely functionally implemented JPEG encoder in the Haskell libraries to my knowledge.  There may well be purely functional wrappers around C libraries.
11:50:35 <tibbe> mtnviewmark: and separation of the lower level layer (i.e. Data.Binary.Get) from binary the data format (Data.Binary)
11:50:36 <bos> the binary-strict package has basically the right API, but it's too slow and complex.
11:50:41 <mtnviewmark> cereal uses continuations for success/error handling and propigation (as I understand it) -- is that what we're talking about
11:50:52 <mtnviewmark> or are we talking about using continuation style to feed the input stream?
11:51:10 <toast-opt> mmorrow, lossless jpeg is over 15 years old.  implementers have had plenty of time to catch up if they implemented the early jpeg drafts
11:51:18 <tibbe> mtnviewmark: about returning a continuation when you need more input
11:51:26 <mtnviewmark> yes, the format utility of class Binary actually isn't all that useful for dealing with existing formats
11:51:32 <toast-opt> PNG tends to compress screenshots and cell-shaded graphics better though
11:51:37 <toast-opt> so you might as well use png
11:51:40 <mtnviewmark> it seems only useful for a "quick-n-easy" haskell to haskell transport
11:51:41 <tibbe> mtnviewmark: exactly
11:51:50 <ddarius> mtnviewmark: That's what it is intended to e.
11:51:53 <tibbe> mtnviewmark: right
11:51:55 <ddarius> s/e/be
11:52:05 <tibbe> mtnviewmark: I know what I know the API to look like
11:52:09 <toast-opt> _but_ i heard there's a pure-functional JPEG library, so i want to go see if it implements lossless encoding
11:52:22 <mtnviewmark> except that the Get/Put stuff IS really useful for parsting various standard binary formats...
11:52:25 <ddarius> mtnviewmark: Type classes are not well suited for serializing to/from multiple different formats.
11:52:57 <mtnviewmark> Actually, seems to me that one wants a typeclass per format:   FormatRFC12345 a
11:52:58 <ddarius> mtnviewmark: The class isn't meant for specific formats, the monads are.
11:53:12 <mtnviewmark> and then define how *that* std. maps to/from Haskell types
11:53:30 <mtnviewmark> but that aside, that just said that some of the utilities that come with Binary should be available
11:53:55 <mmorrow> toast-opt: sure, i just identify "jpeg" with the discrete-cosine transform-based encoding, and when i say "jpeg" that's what i mean
11:54:00 <mtnviewmark> ddarius - yes -- which is why perhaps, as a module structure and API, the typeclass shouldn't be "primary"
11:54:07 <tibbe> mtnviewmark: what I really need most often is the getWordXXX type functions
11:54:09 <toast-opt> mmorrow, fair.  which library?
11:54:16 <mmorrow> toast-opt: :o ?
11:54:33 <mmorrow> toast-opt: oh, i was responding to an earlier comment
11:54:37 * mmorrow is catching up
11:54:39 <toast-opt> someone mentioned a pure haskell JPEG library that decodes and encodes
11:54:44 <mtnviewmark> tibbe- yes, me tooo - though  I defined utilites that went to/from Int, since Int is most useful in other functions
11:54:45 <toast-opt> i must have gotten you confused
11:54:51 <tibbe> mtnviewmark: we should split the library in two (I think dcoutts agree)
11:55:30 <tibbe> mtnviewmark: I'd be happy with the library if it returned a continuation when it needed more data or when there was an error
11:55:33 <mtnviewmark> So, I'm up for doing some of this work - and I could even just take a stab at it - but I wanted to be in concert with existing directions
11:55:35 <bos> i wish there was a way in emacs to enter a unicode character by name
11:55:36 <ddarius> mtnviewmark: This is from the documentation of the Binary class: "For parsing and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the Put and Get primitives directly."
11:55:42 <mmorrow> toast-opt: ah right, yeah there's a paper from before haskell was even standardized that details a very non-optimized encoder/decoder using gofer
11:55:55 <toast-opt> :P
11:55:55 <mmorrow> toast-opt: it uses monad-comprehensions and stuff..
11:56:04 <mtnviewmark> ddarius - indeed, and I do -
11:56:09 <mmorrow> toast-opt: but it's good
11:56:30 <toast-opt> mmorrow, yeah, but i'm  looking for something as easy as "import antigravity"
11:56:36 <mmorrow> (good := would be easy to transcribe into modern haskell)
11:56:36 <tibbe> mtnviewmark: bos: gonna watch a movie with my girlfriend now (and eat pain killers). ttyl
11:56:50 <toast-opt> i already wrote my own PNM encoder, and that will work well enough, but then i need to use photoshop or something to open them
11:56:50 <ddarius> toast-opt: There is nothing like that to my knowledge.  Only wrappers around C libraries.
11:57:11 <bos> tibbe: good luck
11:57:12 <mtnviewmark> okay, later tibbe....
11:57:14 <ddarius> Splitting Binary would be trivial.
11:57:18 <mmorrow> toast-opt: pretty much, anything you need you need to implement from scratch
11:57:20 <toast-opt> @google pnm format
11:57:21 <lambdabot> http://en.wikipedia.org/wiki/Netpbm_format
11:57:21 <lambdabot> Title: Netpbm format - Wikipedia, the free encyclopedia
11:57:37 <mmorrow> toast-opt: save for the few things that exist on hackage or elsewhere
11:57:44 <toast-opt> mmorrow,  i'm good with that, but i'm still learning haskell, so png encoder is a bit too much for me right now
11:57:59 <ddarius> toast-opt: Why not use a binding?
11:58:11 <mmorrow> toast-opt: oh, i just linked you to a png encoder i wrote a while back
11:58:25 <mmorrow> toast-opt: http://moonpatio.com/repos/png-writer/
11:58:33 <toast-opt> sweet
11:58:58 <toast-opt> mit style license
11:59:16 <mtnviewmark> okay - is there a good example of continuation based style (especially with reading input) in another library for me to mull over?
11:59:18 <masxmasx> hello :)
11:59:44 <masxmasx> x < 0 = toDigits(-x)         -- toDigits being the function itself, this is one case of it, catching all negative numbers, but it fails
11:59:50 <MoALTz> writing png's is not hard if you have access to the zlib functions...
11:59:56 <masxmasx> can anyone tell me why?:s
11:59:59 * hackagebot upload: monadiccp 0.6.1 - Constraint Programming (TomSchrijvers)
12:00:06 <mmorrow> toast-opt: fortunately we can use zlib for the compression algo
12:00:19 <toast-opt> heh, don't have zlib don't think
12:00:27 <MoALTz> if you want to write it all homebrew though...
12:00:45 <mmorrow> toast-opt: http://hackage.haskell.org/package/zlib
12:01:00 <toast-opt> cool, not gpl
12:01:06 <toast-opt> i'll have to use that
12:01:25 <mmorrow> MoALTz: yeah, if you had to implem the compression too that'd be a little more painful
12:01:36 <MoALTz> mm_freak: more than a little more :)
12:01:44 <MoALTz> oops mmorrow
12:02:03 <mmorrow> MoALTz: i like opposite-exaggeration
12:02:07 <mmorrow> ;)
12:02:37 <mmorrow> "oh yeah, that'll be trivial!"
12:04:29 <dcoutts> mtnviewmark: pong
12:04:38 <mmorrow> toast-opt: so like i said, haven't touched that for a while, but it works. the most obvious and useful optimization would be to take the image data to-be-encoded in something more space-efficient than a [[Word8]]
12:04:43 <mtnviewmark> ah - hello - we had a talk about the binary package
12:04:51 <masxmasx> can anyone help me?:)
12:05:04 <ddarius> masxmasx: No.
12:05:06 <masxmasx> oh
12:05:08 <masxmasx> okay! :(
12:05:10 <masxmasx> thanks anyway =\
12:05:13 <masxmasx> meanie
12:05:27 <kmc> masxmasx, what's your question?
12:05:27 <masxmasx> </3
12:05:28 <ddarius> masxmasx: You haven't provided anywhere near enough information.
12:05:34 <mauke> masxmasx: you haven't asked an answerable question
12:05:41 <masxmasx> oh, excuse me
12:05:45 <nolrai_P> I need to uninstall the mtl so I can use monads-tf how do I do this?
12:05:59 <mmorrow> toast-opt, chrisdone: here's a quicky demonstration prog that generates a random image (w/ alpha channel), and writes it out as a png http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1792
12:06:01 <kmc> nolrai_P, you can use ghc-pkg to hide one
12:06:02 <Saizan> nolrai_P: just "ghc-pkg hide mtl"
12:06:03 <dcoutts> nolrai_P: no, just ghc-pkg hide mtl [--user]
12:06:04 <mtnviewmark> it's in scroll-back - but about adding error support, continuations, refactoring the API, etc....
12:06:05 <h20xt> masxmasx: use hpaste and show all your code
12:06:14 <nolrai_P> Thanks!
12:06:18 <dcoutts> mtnviewmark: right, all needs doing
12:06:30 <masxmasx> toDigits :: Integer -> [Integer]
12:06:30 <masxmasx> toDigits x 		| x < 0 = toDigits(abs(x))
12:06:30 <masxmasx> 			| x `div` 10 == 0 = [x]
12:06:30 <masxmasx> 			| otherwise = toDigits (x `div` 10) ++ [x `mod` 10] -- No instance for (Num (Integer -> [Integer])) arising from a use of `-'
12:06:40 <mauke> masxmasx: don't paste code in the channel, please
12:06:46 <kmc> @where paste
12:06:47 <lambdabot> http://hpaste.org/new
12:06:49 <masxmasx> sorry, figured i could, cause its only a few lines
12:07:11 <mauke> yes. "a few" meaning "more than one" meaning "too much"
12:07:19 <masxmasx> okay! excuse me
12:07:27 <mtnviewmark> so - based on haskell-cafe messages and my own need, was wondering how to proceed
12:07:27 <kmc> where do you have a '-'?
12:07:33 <toast-opt> mmorrow, thx
12:07:37 <kmc> i don't even see it
12:07:42 <mtnviewmark> I was just going to add error to binary myself, but there seem to be bigger plans aloft
12:07:44 <toast-opt> your code looks much better than mine!
12:07:56 <dcoutts> mtnviewmark: right, but they're not happening quickly
12:08:21 <mtnviewmark> hence, things like the cereal fork
12:08:26 <masxmasx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13265#a13265
12:08:28 <kmc> masxmasx, function application is not written f(x)
12:08:42 <kmc> it's f x, with parens around the whole thing if you need to disambiguate
12:08:47 <mauke> masxmasx: the error is on how you're trying to call it
12:08:50 <mauke> s/on/in/
12:08:50 <kmc> so it'd be  toDigits (abs x)
12:08:56 <mauke> the function itself compiles fine
12:09:06 <kmc> masxmasx, are you trying to call like toDigits -3 ?
12:09:12 <kmc> because that's "toDigits minus 3"
12:09:22 <kmc> hence complaining that toDigits is not of a numeric type
12:09:30 <kmc> > succ -3
12:09:32 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
12:09:32 <lambdabot>    arising from the literal `3' at <...
12:09:32 <kmc> > succ (-3)
12:09:34 <lambdabot>   -2
12:11:01 <Saizan> yeah, the error refers to <interactive> so some expression at the prompt
12:11:16 <mauke> and this is why you don't retype error messages
12:11:21 <masxmasx> kmc, im a little confused now (my english isnt really good), i cant enter numbers below zero using "-#"?
12:11:30 <mauke> masxmasx: only sometimes
12:11:49 <Saizan> masxmasx: you've to put parentheses around them, in general
12:12:04 <mauke> masxmasx: "x -y" looks like "x - y", not "x(-y)"
12:12:28 <toast-opt> yeah, negative numbers need parens
12:12:30 <toast-opt> generally
12:12:39 <masxmasx> okay :o thanks a lot! :)
12:12:41 <MoALTz> > succ $ -3
12:12:43 <lambdabot>   -2
12:12:58 <toast-opt> eh, the $ tricks :)
12:13:11 <MoALTz> i love (ab)using $
12:13:16 <MoALTz> even if it makes the code ugly
12:13:20 <masxmasx> :t $
12:13:22 <lambdabot> parse error on input `$'
12:13:33 <toast-opt> heh
12:13:37 <toast-opt> :t ($)
12:13:38 <lambdabot> forall a b. (a -> b) -> a -> b
12:13:40 <toast-opt> it's an operator
12:13:47 <ben> infix id
12:13:57 <mauke> :t (`id`)
12:13:59 <lambdabot> parse error on input `)'
12:14:03 <mauke> :-(
12:14:11 <ben> :t (id)
12:14:12 <lambdabot> forall a. a -> a
12:14:16 <ddarius> :t id
12:14:18 <lambdabot> forall a. a -> a
12:14:28 <ddarius> :t id :: (a -> b) -> a -> b
12:14:30 <lambdabot> forall a b. (a -> b) -> a -> b
12:14:32 <c_wraith> :t id `asTypeOf` ($)
12:14:34 <lambdabot> forall a b. (a -> b) -> a -> b
12:14:43 <mauke> :t (id `id`)
12:14:45 <lambdabot> forall a. a -> a
12:14:55 <ddarius> @djinn (a -> b) -> a -> b
12:14:56 <lambdabot> f a = a
12:15:16 <toast-opt> i wish there was a mirror of $, of type :: a -> (a->b) -> b
12:15:16 <ben> @djinn ($) ? (a -> b) -> a -> b
12:15:16 <lambdabot> Cannot parse command
12:15:28 <ben> Yeah, it should be called ‚Ç¨.
12:15:41 <masxmasx> lambda should be called labda
12:15:42 <toast-opt> ha
12:15:43 <c_wraith> :t flip id
12:15:45 <lambdabot> forall b c. b -> (b -> c) -> c
12:15:46 <toast-opt> i don't have those keys
12:15:52 <toast-opt> :t ^
12:15:54 <lambdabot> parse error on input `^'
12:15:56 <toast-opt> :t (^)
12:15:58 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
12:16:00 <MoALTz> > let Ä = flip ($)
12:16:02 <lambdabot>   <no location info>: parse error on input `ÔøΩ'
12:16:05 <toast-opt> :t (#)
12:16:07 <lambdabot> parse error on input `)'
12:16:21 <ben> @let (‚Ç¨) = flip id
12:16:23 <lambdabot>  Defined.
12:16:28 <masxmasx> so...why would anyone use a functional language when they can use imperative langs too?
12:16:36 <ben> @let infixl 0 ‚Ç¨
12:16:37 <lambdabot>  Defined.
12:16:37 <toast-opt> :t flip
12:16:39 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:16:46 <mauke> masxmasx: why would anyone use an imperative language when they can use functional langs too?
12:16:58 <masxmasx> easier, easier to "read"
12:17:00 <masxmasx> faster
12:17:05 <mauke> no, no, and no
12:17:10 <c_wraith> faster?  really?
12:17:11 <medfly> habit
12:17:17 <_JusSx_> masxmasx: because it's funny
12:17:18 <MoALTz> more control in general
12:17:21 <masxmasx> faster to run, yes :o
12:17:25 <mauke> masxmasx: hell no
12:17:28 <ben> For every unreadable functional language you can name, I can name two unreadable imperative ones~
12:17:31 <mauke> Haskell runs circles around Ruby
12:17:32 <toast-opt> mauke, don't know better?  imperative focused education?
12:18:02 <masxmasx> but there are many more imperative languages ben, so that is not really fair
12:18:03 <medfly> using an alien language takes so much longer
12:18:04 <BONUS> masxmasx: because we're all high here 24/7
12:18:16 <masxmasx> BONUS, that makes sense :D
12:18:42 <c_wraith> functional languages have a really strong advantage:  referential transparency
12:18:49 <MoALTz> the problem i've noticed with functional programming is that if you don't remember any direct way to do something then you have to think very hard about how to solve the problem. with imperiative programming you can instead just hack your way towards a solution and leave it be once it's complete enough to work
12:18:58 <toast-opt> bonus, high on monads?
12:19:12 <c_wraith> masxmasx:  http://scienceblogs.com/goodmath/2009/11/philosophizing_about_programmi.php
12:19:15 <BONUS> indeed *exhales*
12:19:20 <ben> masxmasx: I suspect you need to consider your perspective when asking that question -- chances are, as an imperative programmer, you will find imperative programs easier to read and the imperative programs you write would be faster than an equivalent functional program you write. But that is not really universal.
12:19:24 <toast-opt> heh
12:19:40 <c_wraith> masxmasx: that's an interesting (if incomplete) essay about why referential transparency is important in large projects
12:20:00 <masxmasx> "referential transparency"? :$
12:20:43 <sshc> I'm trying to write a function that behaves like groupBy, but instead of taking a list "[a]" it takes a list of tuples and operates only on the second one "[a, b]".  Its type signature would be: (a -> a -> Bool) -> [(b, a)] -> [(b, [a])]
12:20:56 <h20xt> masxmasx: the single thing that has made me a better C++ programmer is learning haskell, the templated part of C++ is very functional
12:20:58 <masxmasx> but thanks, ill read that when im done with my assignment :D (taking a long time because its actually the first time i use haskell..)
12:21:07 <c_wraith> in short, referential transparency means: "a function will always return the same thing when called with the same arguments"
12:21:14 <toast-opt> h20xt, heh, are you a TMP hacker?
12:21:48 <sshc> how would I write this?
12:22:05 <Guest68217> if you use x <- getline in do and use a where inside that do, why does the x inside the where behave like its not in scope?
12:22:17 <Baughn> In cabal, how would I check whether I'm on a 64 or 32-bit machine?
12:22:17 <toast-opt> h20xt, Boost::MPL?  or roll your own?
12:22:34 <c_wraith> Guest26324: because it's not.  where only attaches to function declarations, not to "do" blocks
12:22:43 <BONUS> sshc: are you familiar with the groupBy ((==) `on` f) idiom?
12:22:48 <aeron[`]> h20xt: uh can you give a practical example? pattern matching on the arguments are the only thing that I could see that for
12:22:54 <toast-opt> :t on
12:22:55 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:23:01 <BONUS> then when you're doing it, just do groupBy ((==) `on` f.snd)
12:23:14 <BONUS> and there you have it
12:23:25 <dcoutts> Baughn: one of ghc's public header files says I think
12:23:40 <toast-opt> fun.  that's cool how you can tell almost exactly what a function does by its generic type
12:23:56 <c_wraith> toast-opt:  sometimes.  :)
12:23:57 <BONUS> :t (\f xs -> groupBy (f `on` snd) xs)
12:23:58 <lambdabot> forall a b. (b -> b -> Bool) -> [(a, b)] -> [[(a, b)]]
12:24:08 <c_wraith> toast-opt:  Num t => t -> t
12:24:15 <c_wraith> toast-opt: what's that function do?  :)
12:24:27 <toast-opt> c_wraith, it doesn't read from a file :)
12:24:36 <ben> It is not a very generic signature, it only works for numbers :(
12:24:40 <Baughn> dcoutts: For a .cabal file?
12:24:48 <ddarius> aeron[`]: The template language of C++ is a lazy functional programming language.  Most of Haskell translates to it readily.
12:24:56 <dcoutts> Baughn: it's not available in .cabal files
12:25:02 <Baughn> dcoutts: I'm looking for something like 'if machine(amd64)' or so.. of course, there's no documentation for what I can use in .cabal files
12:25:06 <c_wraith> ok, fine.  more generically:  [a] -> [[a]]
12:25:13 <dcoutts> Baughn: yes there is
12:25:18 <dcoutts> Baughn: and you can do that
12:25:34 <toast-opt> ddarius, eh, mostly lazy.  it's easy to make things not lazy using :: scope operator
12:25:53 <toast-opt> ddarius, the 'derives from' idiom is need to make it really lazy
12:25:58 <Baughn> dcoutts: Oh, wait. Found it. Not linked from the index, though
12:26:07 <aeron[`]> h20xt: i can understand haskell making you a better programming in general, but I cannot see how it would make you a better C++ programmer specifically because of templates. got an example?
12:26:14 <dcoutts> Baughn: what's not linked?
12:26:15 <ddarius> aeron[`]: http://bartoszmilewski.wordpress.com/2009/10/21/what-does-haskell-have-to-do-with-c/
12:26:26 <dcoutts> Baughn: the section on configurations is in the contents
12:26:29 <ddarius> toast-opt: Haskell is "mostly lazy" too
12:26:52 <Baughn> dcoutts: Sure, but conditions isn't.. well, I found it, anyhow.
12:27:15 <toast-opt> ddarius, sorry, i mean if you use the scope operator too much, it's like using a 'force' function
12:27:16 <sshc> BONUS: I'm not famililiar with that idiom
12:27:20 <Baughn> dcoutts: Heh. Next up: Finagling cabal into calling yasm.
12:27:21 <Guest68217> can anyone help with http://pastebay.com/72909
12:27:37 <dcoutts> Baughn: I guess configurations is not very self-descriptive
12:27:38 <toast-opt> ddarius, ah, scope operator can work like foldl' instead of foldr
12:27:44 <sshc> BONUS: I don't understand what does
12:27:51 <Baughn> dcoutts: Sorry, no.
12:28:02 <Nafai> HSH looks seriously cool
12:28:15 <sshc> BONUS: you have an infix function between f.snd and another function?
12:28:19 <ben> Guest68217: Make nummber an argument of correct and pass it explicitly
12:28:40 <toast-opt> ddarius, eh, template <class T> struct x { typedef f<T>::type type; } will force.  template <class T> struct x : f<T> {}; is lazy
12:29:17 <sshc> BONUS: how does that work?
12:29:40 <ddarius> toast-opt: Usually a language is considered lazy if it doesn't always force its arguments.
12:29:56 <ben> sshc: What is the problem? :s
12:30:12 <toast-opt> ddarius, yes, agreed.  but you have to admit C++ TMP has more gotchas :)
12:30:16 <ben> The syntax of `on`?
12:30:31 <sshc> ben: yes, and I don't understand "groupBy ((==) `on` f)"
12:30:38 <toast-opt> it wasn't designed to be gotcha-free.  it wasn't designed at all :)
12:30:41 <ddarius> toast-opt: Of course.  The template system wasn't designed as a language.  (And C++ always has more gotchas.)
12:30:55 <toast-opt> heh, yeah
12:30:58 <centrinia> :t (==) `on`
12:30:59 <lambdabot> parse error (possibly incorrect indentation)
12:31:00 <ben> sshc: f `on` g is an infix application of on, it is equivalent to on f g.
12:31:03 <centrinia> :t on (==)
12:31:04 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
12:31:11 <ben> much like a == b is equivalent to (==) a b
12:31:16 <aeron[`]> toast-opt: it most certainly designed, just not well necessarily :P
12:31:25 <aeron[`]> it's just been taken much further
12:31:33 <ben> So we are calling on with (==) and f as arguments.
12:31:48 <ben> It returns a new function that takes two arguments, passes both to f, and then passes the return values of that to (==)
12:31:58 <toast-opt> aeron, it was designed for generic programming interfaces.  not to write programs in
12:32:07 <ben> It "=='s its arguments on f"
12:34:00 <Nafai> Is HSH the best of the shell scripting like libraries for Haskell?
12:34:07 <sshc> ben: does `on` identical to $ ?
12:34:12 <ben> no
12:34:21 <aeron[`]> Nafai: what alternatives do you know of?
12:34:23 <ben> @src on
12:34:23 <lambdabot> (*) `on` f = \x y -> f x * f y
12:34:32 <sshc> how are they different?
12:34:44 <ben> `on` returns a new function
12:35:12 <masxmasx> :t return
12:35:14 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:35:30 <Nafai> aeron[`]: I didn't know if there are any, I guess that's what I was asking.
12:35:53 <toast-opt> hmm, hsh looks rather cool
12:39:16 <sshc> :t groupBy ((==) `in` f)
12:39:18 <lambdabot> parse error on input `in'
12:39:22 <sshc> :t groupBy ((==) `on` f)
12:39:24 <lambdabot>     Ambiguous type variable `b' in the constraints:
12:39:24 <lambdabot>       `Eq b' arising from a use of `==' at <interactive>:1:9-12
12:39:24 <lambdabot>       `SimpleReflect.FromExpr b'
12:39:34 <nolrai_P> Is there a name for the type operator (->) ?
12:40:23 <nolrai_P> sshc: thats an odd error.
12:40:27 <Berengal> sshc: Do you know of 'comparing'?
12:40:36 <h20xt> sorry, guys, lost my ssh connection, gotta run but this is a cool article http://bartoszmilewski.wordpress.com/2009/10/21/what-does-haskell-have-to-do-with-c/
12:40:41 <nolrai_P> :t ((==) `on` f)
12:40:42 <lambdabot>     Ambiguous type variable `b' in the constraints:
12:40:42 <lambdabot>       `Eq b' arising from a use of `==' at <interactive>:1:1-4
12:40:42 <lambdabot>       `SimpleReflect.FromExpr b'
12:40:51 <nolrai_P> :t comparing
12:40:52 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:41:29 <Berengal> > sortBy (comparing length) [[1,2,3],[5,4,3,2],[7,4,6,23,4,5,6],[3,4]]
12:41:30 <lambdabot>   [[3,4],[1,2,3],[5,4,3,2],[7,4,6,23,4,5,6]]
12:41:33 <sshc> :t groupBy ((==) `on` snd)
12:41:35 <lambdabot> forall a b. (Eq b) => [(a, b)] -> [[(a, b)]]
12:42:05 <sshc> it returns [[(a, b)]] and not [(a, [b])]
12:42:24 <sshc> I'm trying to write a function that behaves like groupBy, but instead of taking a list "[a]" it takes a list of tuples and operates only on the second one "[a, b]".  Its type signature would be: (a -> a -> Bool) -> [(b, a)] -> [(b, [a])]
12:43:14 <Berengal> sshc: What about when there are different values in fst?
12:43:47 <toast-opt> :t fst
12:43:49 <lambdabot> forall a b. (a, b) -> a
12:43:56 <toast-opt> are there 3-arg tuple functions?
12:44:00 <Berengal> What's the result when applied to [(1, 2), (2, 2)]?
12:44:08 <Berengal> toast-opt: nope
12:44:25 <toast-opt> >map fst [(1,2),(2,2)]
12:45:26 <toast-opt> berengal, would still like to see a nice solution to the 'generic on very different things' problem
12:45:45 <toast-opt> could type classes solve this?
12:46:07 <toast-opt> class Tuple2orMore, having fst and snd
12:46:24 <Berengal> toast-opt: I don't see the need
12:46:25 <ben> Surely Tuple1orMore should have fst already
12:46:26 <toast-opt> and (a,b); (a,b,c); (a,b,c,d)... all in that type class?
12:46:35 <toast-opt> berengal, convenience.  laziness
12:46:42 <toast-opt> ben, true
12:47:06 <Berengal> I can't think of ever needing something like that even for convenience
12:47:21 <toast-opt> Berengal, i use 3 arg tuples all the time
12:47:24 <toast-opt> (in python)
12:47:51 <ben> Maybe you could switch to a two-tuple of a two-tuple and a value :V
12:48:13 <toast-opt> yeah, (a, (b,(c,...)))
12:48:30 * Raynes- has been working with 3 tuples a lot lately. Uses pattern matching lots.
12:48:34 <Berengal> toast-opt: all tuples are isomorphic to two-tuples anyway.
12:48:47 <ben> Isomorphic, really?
12:48:55 <Berengal> Well, n-tuples for n >= 2
12:49:08 <ben> You can encode (a, b, c) as ((a, b), c) and (a, (b, c)), surely that makes it less than isomorphic
12:49:10 <EnglishGent> yes (a,b,c) ~= (a,(b,c))
12:49:18 <ben> Or maybe more. :3
12:49:52 <Berengal> ben: I'd say more. There's no information lost, only gained, and as long as that new information doesn't matter, you could just disregard it
12:49:54 <EnglishGent> two types X & Y are isomorphic if there exists f: X -> Y & g: Y -> X such that f . g & g .f == id
12:50:01 <EnglishGent> the operation is completely reversible
12:50:32 <ben> welp, my linear algebra class seemed to have more requirements for isomorphisms
12:50:36 <EnglishGent> (oh my gods - all this category theory is starting to make *some* kind of sense!)
12:50:57 <Berengal> ben: I'm using the CT definition :)
12:51:07 <EnglishGent> ah - well the word isomorphism can have different meanings
12:51:13 <toast-opt> berengal - it would be nice if they really were equivalent
12:51:14 <ben> do not tell me we are overloading definitions in maths now :(
12:51:19 <ben> Nevermind, I failed that class anyway.
12:51:26 <EnglishGent> but all the other variants are special cases of the category theory definition
12:51:29 <toast-opt> i'll have to tinker with that.  there's probably a good reason for it, i'll look at it :)
12:51:42 <EnglishGent> isomorphism is wierder than you might think
12:51:51 <byorgey> ben: math overloads definitions all the time!
12:52:06 <EnglishGent> for example - if f :: List -> List is an isomorphism .. does it have to preserve the length of the list?
12:52:10 <EnglishGent> Answer: no!
12:52:16 <ddarius> Actually the categorical definition of isomorphism is very simple.
12:52:19 <mauke> s/definitions/my brain/
12:52:45 <ddarius> Incidentally, I think Berengal meant to say all (finite) tuples are isomorphic to nestings of 2-tuples, which is not completely true in Haskell.
12:52:50 <ben> EnglishGent: I suspect it ought to not shorten the list anyway
12:52:51 <lament> meth overload
12:53:05 <EnglishGent> just define f (1,2) = (3,4,5), f (3,4,5) = (1,2) & for all other x, f x = x
12:53:22 <mauke> ben: isomorphisms work both ways
12:53:25 <Berengal> ddarius: it's true enough for my needs
12:53:27 <EnglishGent> f is now an isomorphism - and it's own inverse - but it doesnt preserve list length
12:53:34 <toast-opt> ddarius, well, true, a 3-tuple cannot match a 2-tuple
12:53:40 <EnglishGent> (this shocked me when I first realised it!)
12:53:49 <toast-opt> ddarius but that's really the same as 2-tuples still
12:53:59 <ben> welp
12:54:04 <ddarius> EnglishGent: It depends on what category you are working in.
12:54:15 <ben> That only works for lists of numbers :(
12:54:32 <toast-opt> type Nil | Nil ; f :: (a, (b, Nil))
12:54:43 <toast-opt> now f only accepts 2-tuples of length 2
12:55:06 <toast-opt> f :: (a, (b, (c, Nil))) -> .. only accepts 2-tuples of length 3
12:55:07 <toast-opt> etc
12:55:18 <mauke> type Nil = ()
12:55:32 <toast-opt> mauke, oh yeah, thx !
12:55:33 <ddarius> "2-tuples of length 3" doesn't mean anything using typical definitions.
12:55:39 <EnglishGent> and yeah ddarius - I just mean in general .. I agree that in some categories the isomorphisms have stronger requirements
12:55:53 <lament> tuples don't have a length, they have a width :)
12:55:56 <toast-opt> ddarius - i mean the chained length,
12:56:12 <EnglishGent> btw I am not & do not pretend to be any kind of expert - there are plenty of people here _far_ more knowledgeable than I am
12:56:24 <Phyx-> oooh Haskell 2010
12:56:32 <ddarius> toast-opt: A 2-tuple doesn't have a "chained length."  A nesting of 2-tuples can.
12:56:42 <EnglishGent> I just noticed that one a while back & found it very surprising :)
12:56:44 <toast-opt> like, this n-tuple lib would have:  fst :: (a, rest) -> a ; fst (a,rest) = a
12:56:44 <thoughtpolice> t
12:56:56 <thoughtpolice> ashdfs, wrong window :(
12:57:07 <toast-opt> snd :: (a, (b, rest)) -> b ; snd (a, (b, rest)) = b
12:57:10 <toast-opt> so forth
12:57:30 <toast-opt> i'll have to try it when i get to type classes
12:57:43 <byorgey> thoughtpolice: hehe, I spent a few seconds looking for someone with the nick 'ashdfs' who you were responding to =)
12:57:44 <ddarius> toast-opt: That scheme doesn't require type classes.
12:58:11 <thoughtpolice> byorgey: i need to keep better track of which window has focus in my xmonad :(
12:58:14 <toast-opt> ddarius, yeah, but i would like this scheme to not be confused with real 2-tuples
12:58:50 <ddarius> toast-opt: Then make your own tuple type (if I'm understanding you correctly), then, incidentally, you can make something that is isomorphic to n-tuples.
12:59:03 <toast-opt> yeah
12:59:09 <ddarius> thoughtpolice: Just do what I do and only use full-screen.
12:59:09 <toast-opt> i half understood that
12:59:18 <byorgey> thoughtpolice: heh, I use borderWidth = 2 for that exact reason
12:59:21 <Berengal> toast-opt: Just define a new product operator with the right associativity (pun intended), and you could use those functions easily
12:59:27 <Guest68217> whats wrong with http://pastebay.com/72917
12:59:29 <ddarius> borderWidth = 0
12:59:50 <toast-opt> berengal - ah, true
13:00:15 <byorgey> Guest68217: what is the type of readCC ?
13:00:34 <mauke> Guest68217: why are you using unsafePerformIO if you don't know what you're doing?
13:00:36 <kmc> Guest26324, why are you using unsafePerformIO
13:00:47 <byorgey> Guest68217: also, what is REALLY wrong with that is 'unsafePerformIO' =)
13:00:47 <Guest68217> integer
13:01:04 <Phyx-> Guest68217: do not use unsafePerformIO for that, to make those assignments they are really not needed
13:01:10 * ddarius imagines this is Tsunkiet.
13:01:13 <mauke> (you don't know what you're doing because you're here, asking this question, using a nick like "Guest68217")
13:01:29 <Phyx-> loool
13:01:35 <Phyx-> think you scared him off mauke
13:01:43 <kmc> "Java user signed off"
13:01:54 <Phyx-> he did rejoin using another nick :P
13:01:56 <Berengal> :O
13:02:11 <byorgey> come on guys, let's be nice.
13:02:18 <toast-opt> maybe a java irc client?  in the browser?
13:02:58 <toast-opt> ... so, C++ TMP is pure functional code.  wonder if you could compile pure haskell to template metaprograms
13:03:08 <kmc> ugh
13:03:10 <ddarius> toast-opt: Much of it.
13:03:12 <toast-opt> heh
13:03:30 <ddarius> toast-opt: One of the first Haskell programs I wrote converted a Haskell-like functional language to C++ templates.
13:03:32 <toast-opt> i think i hurt kmc emotionally with that thought
13:03:34 <kmc> so sick of C++
13:03:45 <toast-opt> heh
13:03:46 <kmc> ddarius, that's cool
13:03:47 <Berengal> toast-opt: It'd probably run faster if you implemented it in prolog.
13:03:50 <toast-opt> sorry
13:03:57 <ddarius> toast-opt: The similarities are so close that it's basically just fill-in-the-blank.
13:04:11 <toast-opt> berengal - true.  C++ TMP are typically untyped
13:04:44 <toast-opt> ddarius - how do you implement cut?
13:05:20 <Phyx-> so, what's Haskell 2010? a new haskell standard or just proposed changed?
13:05:42 <kmc> Phyx-, standardization of a few of GHC's extensions
13:05:46 <toast-opt> haskell 2010?  wonder if they'll beat the C++0x standard
13:05:54 <Berengal> Phyx-: New standard, but the report hasn't been mended yet.
13:05:56 <c_wraith> does anyone here have any experience with hint?
13:05:58 <mauke> toast-opt: uh, they did
13:06:02 <toast-opt> heh
13:06:02 <c_wraith> Left (WontCompile [GhcError {errMsg = "Not in scope: `+'"}])
13:06:03 <toast-opt> nice
13:06:14 <kmc> c_wraith, you have to import prelude
13:06:17 <c_wraith> How do I tell it to use the prelude?
13:06:25 <kmc> c_wraith, http://code.haskell.org/hint/devel/examples
13:06:31 <toast-opt> mauke, it's fairly clear now that in '0x', 'x' is a prefix, not a variable
13:06:35 <Phyx-> Berengal: ah ok
13:06:36 <toast-opt> 0xa, 0xb, etc
13:06:53 <Phyx-> kmc: ah ok, was reading a few of the proposals, and thinking "doesn't ghc already allow this"
13:06:56 <Phyx-> lol
13:07:03 <toast-opt> my bet it on 0xa -- they're cutting everything they can at this point
13:07:21 <Berengal> Phyx-: Of course, it's only the Haskell2010 commitee's standard. You're free to not acknowledge their authority as you wish.
13:07:21 <toast-opt> before they cut concepts, i was really happy -- 0xc is my lucky hexadecimal number
13:07:38 <toast-opt> and i really liked the notion of compilers with real language experimentation
13:07:42 <kmc> speaking of extensions, anyone know why GHC doesn't have monad comprehensions anymore, even as an extension?
13:08:18 <toast-opt> berengal, heh, is that more or less weight than the Rnrs process?
13:08:23 <Phyx-> Berengal: I thought in general when making a Haskell compiler, everyone tries to support what GHC has anyway no? so I think this is a good thing
13:08:32 <kmc> Phyx-, nobody supports all of it
13:08:35 <ddarius> kmc: Probably because doing them right would require reintroducing failable patterns.
13:08:44 <kmc> ddarius, how so?
13:08:54 <kmc> Phyx-, there are some common extensions -- the most basic is hierarchical module names
13:09:24 <ddarius> Phyx-: As far as I can tell, every (significant) Haskell compiler includes unique extensions.
13:10:21 <Phyx-> hmm
13:10:35 <Berengal> Phyx-: I'm not saying it's not a good thing. I just think it's nice that "Haskell" is as vague a term as it is. There's Haskell98 and now Haskell2010, but they're only points on a plane. Haskell itself isn't standarized, and doesn't even have a de facto standard implementation, which allows people to call their language Haskell without worrying about standards or backwards compatability
13:11:31 <Berengal> This makes it much easier for people who care about the language to improve upon it and fend of stagnation.
13:11:42 <ddarius> Berengal: If your implementation doesn't almost completely support one of the Haskell standards, you are hard-pressed to call it "Haskell."
13:11:52 <Phyx-> sure, but it makes your source files completely compiler specific
13:11:58 <Berengal> Aaaaaand I don't really know where that rant came from...
13:12:00 <Phyx-> makes it harder for people to switch compilers
13:12:37 <Berengal> ddarius: Does lambdabot support any of the standards completely?
13:12:58 <ddarius> lambdabot isn't a Haskell implementation.
13:13:16 <Phyx-> lambdabot: are you haskell?
13:13:27 <Phyx-> why did I expect it to respond..
13:13:42 <Berengal> ddarius: I disagree, even though it outsources most of the work to ghc, but that's just a matter of definition
13:13:48 <toast-opt> i like the slogan "avoid success at all costs".  it's good to experiment somewhere
13:13:50 <Berengal> @vixen are you haskell?
13:13:52 <lambdabot> church is my favourite computer scientist.
13:14:04 <toast-opt> is Haskell 98 good for comercial development?
13:14:18 <kmc> nah
13:14:21 <kmc> you really need a few extensions
13:14:34 <kmc> hopefully those'll be in Haskell2010
13:14:48 <toast-opt> how about 2010?  is 'useful for real work' a goal?
13:14:49 <ddarius> Berengal: Does bash support any of the Haskell standards completely?
13:14:59 <toast-opt> an ffi, a nice set of standard libraries?
13:15:00 <Saizan> 2010 is already fixed no?
13:15:02 <Phyx-> lol, some of those don't seem useful for lamdabot
13:15:04 <lament> kmc: which extensions? The UML->Haskell code generator?
13:15:11 <kmc> haha
13:15:44 <Berengal> ddarius: it would if it had a built-in command to call ghc
13:16:03 <kmc> lambdabot doesn't even support "data" iirc
13:16:04 <kmc> so, no
13:16:05 <Cale> Haskell 98 isn't really all that bad for real work, but extensions are so delicious.
13:16:46 <kmc> ST and ByteString are pretty essential for real work
13:16:48 <Berengal> The only really "bad" thing about Haskell 98 is IMHO the MMR
13:16:52 <lament> Berengal: is it really fair to say that haskell doesn't have a de-facto standard implementation
13:16:55 <kmc> ByteString requires unsafePerformIO
13:17:18 <ddarius> Rank-n types, multiparameter type classes and fundeps, and the various relaxings of class and instance syntax are the main extensions I would really want.
13:17:25 <Cale> Depends what sort of real work. Also, unsafePerformIO is in Haskell 98, because it's in the FFI addendum.
13:17:25 <lament> Berengal: it certainly seems like it has a de-facto standard implementation that's also de-facto only implementation...
13:17:27 <kmc> oh yeah ST requires rank-2 types as well
13:17:37 <kmc> Cale, ah, didn't know that
13:17:50 <ddarius> Berengal: I believe every implementation allows turning off the monomorphism restriction and NHC explicitly doesn't implement it.
13:17:53 <kmc> sure it depends on what sort.  i'm saying these are needed to claim broad applicability
13:17:56 <mauke> Berengal: n+k patterns, unary minus, 'fail' in Monad :-(
13:18:08 <kmc> the whole numeric and monad class hierarchies
13:18:12 <Berengal> lament: I think so. There are haskell compilers that support extentions that GHC doesn't, and Haskell the language family is the sum of these extentions, so you can't derive a standard by looking at just one implementation
13:18:14 <kmc> defaulting
13:18:16 <Cale> unary minus isn't bad
13:18:26 <lament> Berengal: but who uses these compilers.
13:18:34 <Phyx-> are n+k patterns really used that much?
13:18:37 <Berengal> mauke: They're bad, but not as bad for day-to-day coding as the MMR
13:18:42 <Cale> But I think we ought to make the standard clear with regard to things like (-1+)
13:18:51 <kmc> > (-1+)
13:18:51 <toast-opt> berengal, mmr?
13:18:53 <lambdabot>   {-3->-4;-2->-3;-1->-2;0->-1;1->0;2->1;3->2}
13:18:56 <ben> Cale: But the FFI addendum is not in Haskell 98, is it? I thought team 2010 explicitly added the FFI to the standard.
13:18:56 <mauke> unary minus is bad
13:19:02 <Berengal> toast-opt: monomorphism restriction
13:19:11 <ddarius> ben: FFI is a ratified addendum to Haskell 98.
13:19:17 <Cale> ben: It's a separate document, but considered part of the standard.
13:19:35 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
13:19:57 <toast-opt> berengal, oh, that does seem annoying
13:20:08 <toast-opt> but i had a bunch of trouble when i let it infer those things
13:20:33 <Cale> Hugs Hugs> (-1+) 5
13:20:33 <Cale> ERROR - Syntax error in expression (unexpected `)')
13:20:40 <toast-opt> then again, it only caused me trouble because i'm novice, and having to annotate is even more confusing for novice
13:20:51 <ddarius> You can claim Haskell 98 conformance while not claiming FFI conformance though.
13:21:07 <Berengal> toast-opt: programs that are valid with the MMR are valid without it, but some that aren't valid become valid.
13:21:25 <Cale> I prefer the standard to be broken into small capabilities. I think that makes a lot of sense.
13:21:31 <ddarius> Berengal: I'm not sure if that is true.
13:21:39 <Cale> So long as we have a mechanism for abstraction over them ;)
13:22:38 <Cale> We need a way for the standard to continue to undergo homotopy deformation without leaving too many people with code that they can't use.
13:22:44 <Berengal> ddarius: Well, I'm not entirely sure myself, but it does make sense. The MMR forces certain names to be monomorphic, otherwise it won't compile. Remove the MMR, and programs that were valid should still be valid, because monomorphic values are still allowed.
13:23:12 <ddarius> Berengal: Adding polymorphism may lead to ambiguous cases in class constraint resolution.
13:23:35 <ddarius> Cale: What're the properties of the space of Haskell standards?
13:24:13 <Berengal> ddarius: But you're not adding polymorphism. You remove a restriction, but you have to actually change the program to change the, well, program.
13:24:40 <Berengal> ddarius: I might be wrong. I haven't though it through completely
13:25:51 <ddarius> Berengal: I have an example where turning off the monomorphism restriction causes a program to fail to compile.
13:26:13 * mmorrow would like to see it
13:26:20 <ddarius> @paste
13:26:21 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:26:28 <Berengal> ddarius: is the real sinner defaulting?
13:27:17 <ddarius> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5139#a5139
13:27:29 <ddarius> Berengal: I use defaulting in this case for simplicity, but no.  Defaulting is irrelevant.
13:27:43 <ddarius> I could do the same thing with [].
13:28:15 <Berengal> Hmm..
13:28:28 <mmorrow> @type let default (); x = 3 in x {- just checking because i'm too lazy to open annn editor -}
13:28:30 <lambdabot> parse error on input `default'
13:28:32 <ddarius> (Actually, I manipulate defaulting (turn it off).)
13:29:12 <mauke> @type let x = 3 in x
13:29:14 <lambdabot> forall t. (Num t) => t
13:29:19 <Berengal> ddarius: That doesn't compile for me even with the MMR
13:29:24 <mmorrow> what does "default ()" even do?
13:29:30 <Berengal> mmorrow: Turn off defaulting
13:29:34 <mmorrow> makes "x = 3" default to ()?
13:29:37 <mmorrow> ah
13:29:40 <dons> bos: http://code.haskell.org/uvector (project, group, commit access)
13:30:04 <mmorrow> i don't even actually have a clue how the "default Foo" keyword works
13:30:29 <ddarius> Berengal: What error do you get?
13:30:37 <mauke> Berengal: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5139#a5140 ?
13:30:42 <noknok> Hi there. Please could you give me a hint if there is a standard location and way to access the library hierarchy of the say GHC suite? I mean, is there on my local machine a version of what I usually look up online on http://www.haskell.org/ghc/docs/latest/html/libraries/index.html?
13:30:55 <Berengal> ddarius: Ambiguous type variable `a' in the constraint:      `Num a'
13:31:00 <noknok> When I install ghc via synaptic on my ubuntu system, there is the choice of "ghc", but also of "ghc6-doc" (among many other packages). Is the latter this kind of hierarchy?
13:31:05 <bos> dons: thanks!
13:31:15 <ddarius> Berengal: Are you sure you don't have -fno-monomorphism-restriction or equivalent in a .ghci
13:31:27 <bos> dons: there was some flapping of arms over the binary and cereal packages earlier.
13:31:37 <mmorrow> oh. "default" is only wrt Num instances
13:32:37 <dons> bos: here, or on -cafe@ ?
13:32:50 <bos> dons: both
13:32:51 <Jedai> noknok: Probably, along with the user manual and other niceties
13:32:58 <dons> its really easy: one is lazy, async errors; cereal is strict, typed, sync errors.
13:33:03 <Berengal> ddarius: Turns out i did. You're right
13:33:10 <dons> i commented on -cafe@
13:33:24 <mmorrow> wow, i'm going to start doing
13:33:26 <bos> dons: yeah, i know what they are, but they've both got suboptimal interfaces.
13:33:31 <mmorrow> "default (Int,Double)" in all my modules
13:33:33 <dons> ah
13:33:35 <bos> dons: i think that was more the issue.
13:33:44 <ddarius> mmorrow: Why not default () ?
13:33:47 <mmorrow> i think i actually want "Integer" as the default exactly znever
13:33:53 <dons> if anyone has clues on a better interface, send out the design to -cafe@
13:33:55 <dons> or libraries@
13:33:57 <noknok> Jedai: thank you. But what do you mean? Does GHC install the user manual by default? And where is it located then?
13:33:58 <bos> default Peano
13:34:09 <bos> dons: yeah
13:34:12 <mmorrow> ddarius: then
13:34:24 <mmorrow> "default (); x = 3" doesn't compile
13:34:38 <mmorrow> (apparently)
13:34:40 <ben> default (a, b)?
13:34:44 <ddarius> mmorrow: It will without the monomorphism restriction.
13:34:45 <Jedai> noknok: I mean that ghc6-doc probably contains the user manual along with the haddock documentation for the standard hierarchical libraries
13:35:18 <mmorrow> ddarius: aha, ok i understand your example now
13:36:18 <Jedai> noknok: apparently you also have a haskell-doc metapackage
13:36:50 <noknok> Jedai: Thank you again. You are probably right. But what I mean is: is there a standard way to refer to these docs, or do I have to search for it in my local file hierachy?
13:37:09 <Jedai> noknok: but that's mainly the report and a tutorial so you may not want haskell-doc
13:37:12 <djwonk> i'm starting to get my hands around parsec. got a question about parsing compass directions; e.g. N, NE, E, SE, S ...
13:37:17 <mmorrow> ddarius: oh. actually now i see for real
13:37:34 <mmorrow> ddarius: i think that's acceptable
13:37:35 <djwonk> string "S" will match and consume the first part of "SE" but that isn't what I want
13:38:10 <djwonk> so either i have to be careful with order or have a notFollowedBy. is there a way to concisely say "give me the longest match"?
13:38:41 <mauke> djwonk: I doubt it
13:38:58 <Cale> djwonk: You can tokenise things beforehand, or include spaces as part of that parser.
13:39:04 <Cale> djwonk: (and use try)
13:39:06 <mmorrow> ddarius: since if you were to add "z :: Double; z = x + 1", then the fact that print doesn't know what type x is isn't tied to defaulting
13:39:22 <djwonk> mauke: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html recommends using notFollowedBy
13:39:23 <Cale> djwonk: Or you can put a good ordering on the order that the parsers get tries.
13:39:25 <Cale> tried*
13:39:28 <djwonk> Cale: thanks
13:39:52 <noknok> Jedai: yes, I used to look up the report as my standard reference. But then I discovered that the GHC hierarchy has much more to offer. And I wonder if I have the documentation available locally and if there is a standard way to consult it.
13:39:52 <ben> You could parse many (satisfy isUpper) or whatever and manually case...of against all valid strings  :3
13:39:57 <ddarius> mmorrow: I could just do what mauke did and use a type class that isn't related to defaulting.
13:40:04 <djwonk> parsec is really fun though, so far. i've played a little with Treetop in Ruby too
13:40:09 * ben 's parsers are lots of duct tape and prayers
13:40:21 <McManiaC> is it possible to define data structures in ghci?
13:40:40 <djwonk> Cale: wondering about tokenizing things before... you mean, for example, splitting by spaces?
13:40:44 <mauke> McManiaC: no, you need to put them in files and load them
13:40:45 * mmorrow tries to resolve this mauke reference
13:40:45 <Cale> djwonk: yeah
13:40:46 <ddarius> McManiaC: No.
13:40:49 <McManiaC> kk
13:41:17 <ddarius> mmorrow: I believe it was him, who added the annotation to my paste.
13:41:19 <Jedai> noknok: /usr/share/doc/ghc6-doc seems to contain everything
13:41:54 <djwonk> Cale: thanks, i see the benefit of tokenizing first, i'm just not sure of a simple example of how to do that in parsec
13:42:00 <Cale> djwonk: One way to handle writing a parsec parser is to start out by writing a parser which just turns the String into a list of "tokens", and then use Parsec again to parse the list of token values.
13:42:02 <mmorrow> ddarius: ok sure, but both are really just showing that without the monomorphism restriction, you can't non-locally-to-a-var's-definition force its type
13:42:18 <Cale> djwonk: It is a bit more involved than writing the parser directly, I'll admit.
13:42:32 <mmorrow> ddarius: which i think is a questionably useful thing to do in the first place
13:42:33 <ddarius> mmorrow: They both use the same idea, yes.
13:42:35 <Jedai> noknok: open file:///usr/share/doc/ghc6-doc/index.html in your browser
13:42:49 <djwonk> Cale: are you saying that parsec can parse a list of strings just as well as it can parse a string?
13:42:54 <mmorrow> ddarius: but that aside, good point
13:42:55 <Cale> djwonk: yes
13:43:08 <Cale> djwonk: Well, for some values of "just as well as"
13:43:09 <ddarius> mmorrow: This wasn't an argument in favor of the monomorphism restriction.  It was just pointing out that removing it can make working programs stop working.
13:43:29 <Cale> djwonk: There's obviously a bunch of stuff in the Parsec library which is especially for parsing strings.
13:43:32 <mmorrow> ddarius: right, s/good point/interesting observation/
13:43:50 <djwonk> Cale: any suggestions of an example to look at that parses a list of strings?
13:43:52 <Saizan> and you might rely on this behavior without noticing
13:44:39 <mmorrow> Saizan: perhaps
13:44:47 <Cale> djwonk: Well, take a look at the 'token' and 'tokenPrim' functions in Text.Parsec.Prim
13:45:43 <djwonk> Cale: thanks
13:45:52 <Cale> djwonk: If you were parsing a list of strings, you might do something with 'length' to compute the next SourcePos, but it'd be more efficient if your token type included Parsec SourcePos values to begin with
13:45:58 <noknok> Jedai: Thank you, once more. But this directory only contains ANNOUNCE, changelog.Debian.gz, copyright and README on my system. And when I try to install ghc6-doc via synaptic, it complained about some haddock problem. But anyway, my question is proably answered. This seems to be the standard way to refer to the package and module docs.
13:46:22 <djwonk> Cale: this is good to know for future reference, but i think for now i'm going to be careful with ordering
13:47:54 <Cale> While the parser which tokenises reads the initial string, it can use getPosition to get the position of the tokens that it reads as a SourcePos, and store it inside each token.
13:48:28 <Cale> This is mainly important for having sane error messages
13:48:55 <Cale> :t partitionM
13:48:57 <lambdabot> Not in scope: `partitionM'
13:49:03 <Cale> ^^ that ought to exist
13:49:19 <Cale> (just an offhand remark :)
13:49:28 <Jedai> Cale: with which type ?
13:49:53 <Cale> :t partition
13:49:55 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:50:08 <mauke> (a -> m Bool) -> [a] -> m ([a], [a])
13:50:14 <Cale> (Monad m) => (a -> m Bool) -> [a] -> m ([a],[a])
13:50:16 <Cale> yes
13:51:01 <EnglishGent> @hoogle unfold
13:51:02 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
13:51:03 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
13:51:03 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
13:51:42 <Phyx-> @hoogle unfoldr
13:51:43 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
13:51:43 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
13:51:43 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
13:51:51 <aavogt> @type fmap ((map fst *** map fst) . partition snd) . mapM (\x -> (,) x <$> ?p x)
13:51:51 <Phyx-> hmm why didn't that show up
13:51:52 <lambdabot> forall (f :: * -> *) a. (Functor f, ?p::a -> f Bool, Monad f) => [a] -> f ([a], [a])
13:51:55 <Cale> It ought to exist even if the only thing I do with it is  partitionM (const [True,False]) ;)
13:51:57 <Phyx-> lambdabot: must take tope 3
13:52:31 <ddarius> > let partitionM p (x:xs) = do b <- p x; (xs', ys') <- partitionM p xs; if b then return (x:xs',ys') else return (xs', x:ys') in partitionM (const [True,False]) "abc"
13:52:33 <lambdabot>   * Exception: <interactive>:1:137-255: Non-exhaustive patterns in function p...
13:52:33 <aavogt> @let partM p = liftM ((map fst *** map fst) . partition snd) . mapM (\x -> (,) x `liftM` p x)
13:52:34 <lambdabot>  Defined.
13:52:52 <ddarius> > let partitionM p [] = return ([], []); partitionM p (x:xs) = do b <- p x; (xs', ys') <- partitionM p xs; if b then return (x:xs',ys') else return (xs', x:ys') in partitionM (const [True,False]) "abc"
13:52:53 <aavogt> > partM (const [True,False]) "abc"
13:52:54 <lambdabot>   [("abc",""),("ab","c"),("ac","b"),("a","bc"),("bc","a"),("b","ac"),("c","ab...
13:52:54 <lambdabot>   [("abc",""),("ab","c"),("ac","b"),("a","bc"),("bc","a"),("b","ac"),("c","ab...
13:53:10 <aavogt> heh
13:53:44 <aavogt> actually you only need Applicative for it
13:54:33 <aavogt> @type fmap ((map fst *** map fst) . partition snd) . Data.Traversable.traverse (\x -> (,) x <$> ?p x)
13:54:34 <lambdabot> forall (f :: * -> *) a. (Applicative f, ?p::a -> f Bool) => [a] -> f ([a], [a])
13:55:20 <aavogt> of course ddarius' version probably does less list traversals than mine
13:55:34 <ddarius> I would not use my version seriously.
13:56:14 <Jedai> ddarius: Why ?
13:56:23 <ddarius> Jedai: It's not tail recursive.
13:56:55 <Jedai> ddarius: if you put ~(xs', ys') instead, would it works better ?
13:56:58 <djwonk> looks like the Haskell Platform includes editline but not readline or haskeline. would you all recommend editline (I'm new to all 3)
13:57:10 <Jedai> djwonk: No
13:57:40 <djwonk> Jedai: which would you recommend?
13:57:53 <mauke> readline
13:57:59 <Cale> haskeline!
13:58:08 <Jedai> djwonk: readline is probably the more complete and robust, haskeline is not as complete but improving and in Haskell, editline is a pretty bad replacement for readline that doesn't handle Unicode properly
13:58:09 <mauke> readline, because it works
13:58:10 <Phyx-> editline
13:58:13 <Phyx-> :P
13:58:19 <ddarius> Jedai: No, at least not in the way I'm worrying about.
13:58:21 <mauke> Phyx-: editline just sucks
13:58:26 <djwonk> any more opinions? :) haha
13:58:28 <djwonk> thanks!
13:58:34 <Cale> editline has many stupid bugs
13:58:50 <Phyx-> mauke: lol, wasn't readline responsible for the bugs on posix systems in ghc 6.10.3
13:58:54 <Cale> It doesn't handle the backspace or delete keys properly
13:58:58 * bos wonders whether it's better for a function returning Double to return NaN on error or to call error
13:59:00 * ddarius only likes software that has smart bugs.
13:59:14 <ben> haskeline does not handle vi-mode properly :(
13:59:16 <Cale> Phyx-: readline hasn't been used in GHC since 6.8.x
13:59:18 <acowley> bos: depends on the error?
13:59:18 <mauke> Phyx-: ghc-6.10 doesn't use readline
13:59:19 <ddarius> bos: It depends on what the error is, but probably the latter.
13:59:27 <Jedai> djwonk: readline has some license problems from GHC point of view, so they replaced it with haskeline, in my opinion haskeline is the future for this kind of thing in Haskell but there's no denying that readline is still better
13:59:38 <djwonk> well, all I really want is the ability to get a line of text and have backspace and maybe delete work properly
13:59:42 <Cale> Phyx-: Editline was responsible for bugs in 6.10.1 and 6.10.2, but was removed in 6.10.3
13:59:49 <Cale> (replaced by haskeline)
13:59:50 <mauke> djwonk: you don't need a library for that
13:59:54 <Phyx-> mauke: ah ok, I must have it confused with another one
14:00:00 <Jedai> djwonk: haskeline should be fine then, it do more than that
14:00:00 <djwonk> getLine displays ^H when i press backspace
14:00:04 <Phyx-> Cale: oh! ok then yes, editline sucks!
14:00:07 <mauke> djwonk: are you doing thins in ghci?
14:00:14 <djwonk> mauke: yes in ghci
14:00:22 <mauke> djwonk: well, ghci messes with your terminal settings
14:00:28 <Cale> djwonk: That has to do with line buffering.
14:00:28 <djwonk> mauke: oh!
14:00:30 <mauke> try it in a standalone program
14:00:35 <mauke> Cale: no, terminal settings
14:00:39 <Cale> huh?
14:00:40 <bos> ddarius: yeah. in this case, i expect an integer-valued Double, and should fail otherwise.
14:00:55 <mauke> line buffering is in the IO library
14:01:00 <EnglishGent> hmm - is there any way of 'naming' a type in a class definition when it might have component parts - I want to be able to say f@(x -> Bool) is an instance of Filter where filterWith = f
14:01:07 <ddarius> bos: Wouldn't it be better to just take an Integer in that case...
14:01:07 <Jedai> The consensus is that editline sucks, haskeline sucks less and is fast improving (plus it's pure Haskell) and readline is the best but may be annoying from a license point of view
14:01:41 <bos> ddarius: not given the typeclasses by which i'm constrained.
14:01:47 <Cale> ghci> getLine
14:01:47 <Cale> fdhaskjf^?^?^?
14:01:47 <Cale> "fdhaskjf\DEL\DEL\DEL"
14:01:47 <Cale> ghci> :m + System.IO
14:01:48 <Cale> ghci> do hSetBuffering stdin LineBuffering; getLine
14:01:50 <Cale> jfdfdh (backspace works)
14:01:54 <Cale> "jfdfdh (backspace works)"
14:02:10 <bos> ddarius: although arguably i should have separate typeclasses for discrete vs continuous probability distributions.
14:02:26 <djwonk> Cale: sweet, i will try
14:02:28 <mauke> then maybe hSetBuffering does more than just change the buffering mode
14:02:41 <Twey> One would think that getLine would use line-buffering by default
14:03:25 <ddarius> One would think that getLine would just read from the input and not mess with the buffering settings.
14:03:45 <djwonk> Cale: works as advertised, thanks
14:03:48 <Lemmih> mauke: It doesn't.
14:04:07 <Twey> Well, there's no useful application for block- or unbuffered getLine, is there?
14:04:16 <Cale> djwonk: But in a compiled program, you might not have to set it. GHCi does mess with things.
14:05:17 <mauke> Lemmih: it does
14:05:50 <Cale> One thing which always annoys me is that there aren't withBuffering and withEcho functions which set and reset the buffering/echo
14:05:58 <mauke> when (is_tty && isReadableHandleType (haType handle_)) $ case mode of ... _ > setCooked (haFD handle_) True
14:06:02 <djwonk> Cale: and to get the arrow keys working? at that point do I need to move to something more powerful?
14:06:07 <Cale> djwonk: yes
14:06:10 <EnglishGent> is there any way of 'naming' a type in a class definition when it might have component parts - I want to be able to say f@(x -> Bool) is an instance of Filter where filterWith = f
14:06:16 * EnglishGent notes filters form a Lattice
14:06:24 <EnglishGent> and wants to be able to express this somehow
14:06:25 <Cale> djwonk: For that, you need to use a line-editing library like haskeling
14:06:25 <Lemmih> mauke: Oh my.
14:06:26 <Twey> Cale: *nod* I often miss that, too
14:06:28 <Cale> haskeline*
14:06:50 <djwonk> i will probably go a haskling then
14:07:03 <djwonk> haskeline i mean
14:07:08 <Twey> EnglishGent: I think you're mixing types and values there
14:07:18 <Twey> The RHS of filterWith needs to be a value
14:07:25 <Twey> But the instance needs to be a type
14:07:30 <Cale> Funny how we both made that typo
14:07:39 <Twey> Cale: Blame English
14:07:53 <EnglishGent> hey! it's not my fault! :P
14:07:53 <Twey> For an awfully long time, I consistently typo'd ‚Äòmysql‚Äô as ‚Äòmyself‚Äô
14:07:54 <EnglishGent> :)
14:07:57 <Twey> Hehe
14:08:53 <Twey> I embarrassingly typo'd -nb- as -mb- today, too, and couldn't figure out why I was having trouble logging in
14:09:48 <mauke> preflex: quote gbacon
14:09:49 <preflex>  <gbacon> okay, I just tried to type Monday, but it came out Monady.  Assimilation complete.
14:10:16 <Twey> Haha
14:10:48 <Twey> Heh, I read djwonk's line as ‚ÄòI will probably go a-Haskelling, then‚Äô
14:11:00 <Twey> Which sounded like a wonderfully whimsical expression
14:11:06 <djwonk> Twey: indeed!
14:11:47 * Twey abuses English with ‚ÄòYou, O wisher of resumption, must now become a key-presser.‚Äô
14:12:01 <MarcWeber> How to convert from float <-> GLfloat ?
14:12:10 <ddarius> realToFrac
14:12:47 <ddarius> Any question starting with "How do I convert" has the answer of either fromIntegral or realToFrac.
14:13:13 <mauke> how do I convert a string (typed by the user) to a number?
14:13:27 <Twey> Or read, or possibly reads.  ;)
14:13:37 <djwonk> ddarius: how do I convert to scientology?
14:13:40 <Twey> Hehe
14:13:47 <ddarius> djwonk: realToFrac
14:13:48 <Twey> djwonk: realToFrac!
14:13:49 <Cale> How do I convert a monad into the type of its algebras?
14:14:30 <shachaf> "How do I convert a function into its derivative?"
14:14:41 <mauke> how do I convert IO String into String?
14:14:48 <MarcWeber> Thanks, I only was aware of fromIntegral
14:14:49 <Cale> mauke: hehe
14:14:53 <shachaf> @slap mauke
14:14:54 * lambdabot secretly deletes mauke's source code
14:15:08 <shachaf> (The answer to mine was, of course, fromIntegral.)
14:15:20 <Twey> shachaf: *groooan*
14:15:21 <Twey> :-D
14:15:36 <Twey> Took me a while to get that.  :√æ
14:15:48 <Berengal> Puns are the highest artform known to hackers
14:16:12 <Twey> So long as they're not type-puns ;)
14:16:20 <mauke> ‚à´
14:16:45 <shachaf> @let (‚à´) = fromIntegral
14:16:47 <lambdabot>  Defined.
14:16:49 <ben> >:[
14:17:01 <MarcWeber> ddarius: FieldTrip and bloxorz both don't compile because of Float GFloat differences. Do you know whether there has been a change or is my setup broken?
14:17:08 <Twey> > ‚à´ 15 :: Float
14:17:10 <lambdabot>   <no location info>: parse error on input `‚à´'
14:17:12 <djwonk> shachaf: nicely done
14:17:15 <Twey> Ack
14:17:25 <Twey> > (15 ‚à´) :: Float
14:17:26 <ben> MarcWeber: I had a similar problem with another package and glfloats, so I doubt it is your setup.
14:17:27 <lambdabot>   15.0
14:17:29 <Twey> :<
14:17:37 <Twey> Boo to postfix requirements for operators.
14:17:45 <Twey> @let  É = fromIntegral
14:17:47 <lambdabot>  Defined.
14:17:52 <Twey> >  É 15 :: Float
14:17:54 <lambdabot>   15.0
14:18:00 <Twey> Unicode puns!
14:18:05 <MarcWeber> ben: Fine. Then I will clutter the code with realToFrac.
14:18:07 <Berengal> :O
14:18:11 <Berengal> A bit surprised that worked actually
14:18:13 <mauke> haha, you almost got me there
14:18:25 <ben> It's a letter.
14:18:29 <Twey> Esh is a letter
14:18:39 <Twey> Likewise,
14:18:43 <Twey> @let ∆© = sum
14:18:45 <lambdabot>  <local>:23:0: Not in scope: data constructor `∆©'
14:18:47 <Berengal> Ooo
14:18:48 <Twey> Oh, crap
14:18:50 <Twey> Yeah ‚òπ
14:18:56 <ben> @djinn (Num a, Num b) => a -> b
14:18:56 <lambdabot> Error: Class not found: Num
14:19:01 <ben> err.
14:19:02 <shachaf> @let ◊© = id
14:19:03 <lambdabot>   Illegal character ''\1513''
14:19:11 <Berengal> I think I like agda syntax better than haskell's now...
14:19:15 <djwonk> so i did `cabal install haskeline` and it appears to have worked, but my local install of hoogle doesn't find getInputLine
14:19:27 <djwonk> do I need to tell hoogle to reindex or something?
14:19:34 <mauke> http://mauke.ath.cx/stuff/javascript/unicode.html?q=esh
14:20:24 <shachaf> djwonk: Well, that installs it only for your local user, for one.
14:21:25 <Jedai> MarcWeber: It may be better to avoid realToFrac and use something like the convert package alltogether : realToFrac is very inneficient
14:21:30 <Jedai> @src realToFrac
14:21:31 <lambdabot> realToFrac = fromRational . toRational
14:22:07 <ben> hahaha http://mauke.ath.cx/stuff/javascript/unicode.html?q=function%20application
14:22:15 <Cale> djwonk: Probably, but I've never used a locally-installed hoogle.
14:22:15 <MarcWeber> Jedai: What do you mean by "the convert package" ?
14:22:18 <ben> [‚Å°]
14:22:30 <djwonk> shachaf: i'm a fan of local installs when possible.
14:22:33 <mauke> ben: good job! :-)
14:22:46 <Jedai> MarcWeber: whereas GLFloat may be exactly the same as Float underneath
14:22:53 <djwonk> Cale: i recommend it
14:23:08 <mauke> @let (‚Å°) = id
14:23:09 <lambdabot>   Illegal character ''\8289''
14:23:42 <Jedai> MarcWeber: the "convert" package on Hackage provides a Convert Typeclass that allows you to do meaningful conversion in an efficient and easy manner
14:25:19 <MarcWeber> Jedai: convert != convertible?
14:25:42 <Jedai> MarcWeber: convertible rather than convert
14:25:55 <ddarius> Jedai: I'm pretty sure there are quite a few rewrite rules to make realToFrac use better implementations for common types.
14:26:12 <Jedai> MarcWeber: but it don't seem to have the required instance yet, it may be interesting to put them back in
14:26:34 <MarcWeber> Jedai: It doesn't depend on gl* libraries. Anyway I'll have a look at it. There are so many new packages.. Unbelievable
14:26:36 <Jedai> ddarius: I sure hope (and believe) so, but between Float and GLFloat ?...
14:27:22 <MarcWeber> Jedai: I'm not interested in best performance yet. I'm interested in testing hack-nix.
14:28:26 <MarcWeber> So all I want is compiling some packages to see that everything works as expected. I found one package segfaulting : elerea-examples.
14:28:37 <Jedai> MarcWeber: Right, I follow the RSS of Hackage and the rythm of apparition of new packages and new versions of old packages has tremendously improved in the last six months, and when I first tried Haskell there wasn't even a HackageDB !!
14:29:37 <MarcWeber> I only missed about 12 month or so. A way too much for my taste:)
14:31:04 <nolrai_P> @hoogle foldl'
14:31:04 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
14:31:04 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
14:31:04 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
14:32:03 <gexicon> :t 42
14:32:06 <toast-opt> hmm, Sequence has no foldl
14:32:06 <lambdabot> forall t. (Num t) => t
14:33:16 <toast-opt> oh, nm, Foldable Data.Sequence.Seq
14:35:16 <nomeata> Hi. Is there any chance to get the openid package compild on ghc-6.8? It seems that cabal has problems picking a set of package versions that work with base-3
14:35:56 <nomeata> It says "cabal: cannot configure HsOpenSSL-0.5.1. It requires base <3", but 0.5.1 can work with base-3...
14:37:18 <dcoutts> nomeata: it'll be that you're missing bytestring == 0.9.1.* I bet
14:37:36 <dcoutts> nomeata: so it tries the other branch, which is base < 3, but still fails in the end
14:38:23 <nomeata> dcoutts: hmm, it is complaining: cabal: cannot configure HsOpenSSL-0.5.1. It requires ghc-prim -any and integer
14:38:23 <nomeata> -any
14:39:11 <watermind> ah I didn't know Data.Foldable
14:39:12 <watermind> quite nice
14:39:43 <dcoutts> nomeata: apparently it does not work with 6.8 then
14:39:50 <mreh> > 0 * a
14:39:52 <lambdabot>   0 * a
14:39:54 <dcoutts> nomeata: though it claims it works with ghc-6.6
14:39:56 <O_4> How can I go from [IO [a]] to IO [a]?
14:39:59 <mreh> > 0 * a :: Int
14:40:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:40:02 <lambdabot>         against inferred type ...
14:40:06 <watermind> By the way, what do you guys usually use for traversing, folding, etc... monomofic tree like structures?
14:40:15 <Flippeh> Hey, I've got a StateT monad, and I want to call the "puts ( { ...} )" function more conveniently, like "updateState clients listOfClients"..
14:40:16 <O_4> I can use sequence to get an IO [[a]], but I'm not sure how to append those
14:40:18 <Flippeh> How can I do that?
14:40:28 <mreh> (*) is a shortcut when the first argument is 0 surely?
14:40:42 <ben> O_4: fmap concat?
14:40:51 <watermind> I once did my own lib of operations that basically would take a node and operate it with its subtrees
14:41:01 <ben> @type fmap concat
14:41:02 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
14:41:04 <watermind> but not sure if that is very elegant
14:41:15 <watermind> don't know if I should be using generic programming
14:41:33 <watermind> or if there are some H98 standard techniques for that
14:42:39 <O_4> ben: heh, thanks :-p
14:42:50 <O_4> I've been sitting here too long, apparentry
14:45:07 <Flippeh> @hpaste
14:45:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:45:20 <Flippeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5142#a5142
14:45:27 <Flippeh> Can you help me make this.. beautiful?
14:45:51 <c_wraith> those parens are not needed
14:45:59 <mreh> :t .
14:46:01 <lambdabot> parse error on input `.'
14:46:04 <Flippeh> I'd really like to have "updateState handle $ Just han"
14:46:07 <mreh> :t (.)
14:46:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:46:09 <Flippeh> But it won't let me
14:46:14 <c_wraith> record update syntax binds more tightly than function application
14:47:13 <Flippeh> get >>= (\s -> put s { handle = Just han })
14:47:15 <Flippeh> One-lined
14:47:17 <Flippeh> :)
14:47:19 <mreh> i dont understand than type signature
14:47:22 <Flippeh> That's a stard
14:47:25 <mreh> f :: * -> *?!
14:47:25 <Twey> Flippeh: updateHandle h s = s { handle = h }; updateState . updateHandle $ Just han
14:47:33 <mreh> is this miranda?
14:48:03 <Flippeh> Nah twey, you've got me wrong :)
14:48:25 <Flippeh> I want a generic "updateState" function, where the second parameter is the record update function
14:48:30 <Flippeh> first*
14:48:33 <Twey> Oh
14:48:33 <ben> mreh: That is a kind signature :>
14:48:34 <Flippeh> And the second one is the value
14:48:38 <Twey> Isn't there one?
14:48:41 <Flippeh> But it doesn't work, because..
14:48:41 <Twey> ‚Äòmodify‚Äô or some such?
14:49:17 <Flippeh> updateState f v = get >>= (\s -> put s { f = v })
14:49:18 <Twey> Yes, ‚Äòmodify‚Äô
14:49:27 <Flippeh> Can't use f in there
14:49:37 <Twey> No, you can't do that
14:49:41 <idnar> also, that's not the standard (.)
14:49:42 <Twey> You need to define a custom function
14:49:52 <Twey> Or, there's some magic in the Data.Accessor package
14:50:04 <Flippeh> How'd I use the modify function?
14:50:15 <Flippeh> :t modify
14:50:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
14:50:22 <Twey> modify . updateHandle $ Just han
14:50:23 <Flippeh> Doesn't help :(
14:50:42 <Flippeh> So after all I need to write specifiy update functions?
14:50:50 <Twey> Or use Data.Accessor
14:51:31 <Gracenotes> hm. anyone know the gtk2hs equivalent of pango_layout_get_size?
14:52:18 <dcoutts> Gracenotes: that's easy, grep layout_get_size gtk/ -R
14:52:39 <Gracenotes> ooh... right, it didn't occur to me to look the source. Which I have on my computer. heh.
14:52:46 <Gracenotes> I was trying to scavenge the documentation
14:52:57 <dcoutts> Gracenotes: alternatively you can follow the naming convention
14:53:04 <dcoutts> Gracenotes: it'll be called layoutGetSize
14:53:06 <Gracenotes> it doesn't follow it
14:53:50 <dcoutts> Gracenotes: ah, yep, it's not there in Graphics.UI.Gtk.Pango.Layout
14:54:03 <Gracenotes> but.. oddly.. it's in the source
14:54:11 <dcoutts> Gracenotes: different module
14:54:39 <Gracenotes> ooh, it's in Gtk.Layout, not Gtk.Panto.Layout.
14:54:43 <Gracenotes> *pango
14:54:58 <Gracenotes> that's weird, because it's defined in the pango-layout psuedonamespace in C
14:55:15 <Cale> http://14.media.tumblr.com/tumblr_kqjott6c771qa2i2xo1_400.gif - unboxed cat would prefer a uniform representation?
14:55:20 <dcoutts> Gracenotes: ah but it's just a trivial wrapper around layoutGetExtents
14:55:36 <toast-opt> heh, sweet
14:56:59 <Gracenotes> let me.. just see if this compiles and works with the one from Graphics.UI.Gtk.Layout.Layout
14:57:26 <dcoutts> Gracenotes: it will not a Gtk Layout is a totally different object
14:58:05 <dcoutts> Gracenotes: use layoutGetExtents
14:58:08 <Gracenotes> oh. right :/
14:58:10 <dcoutts> from the pango module
14:58:22 <Gracenotes> dcoutts: yeah, that one looks promising. except, which Rectangle is the important one? :)
14:59:13 <Gracenotes> probably the logical rectangle, the second
14:59:23 <dcoutts> Gracenotes: heh, the haddock docs could be better there
14:59:34 <dcoutts> Gracenotes: actually it's the other way around :-)
14:59:39 <dcoutts> (logical, ink)
15:01:22 <Gracenotes> dcoutts: void pango_layout_get_extents(PangoLayout *layout, PangoRectangle *ink_rect, PangoRectangle *logical_rect);
15:01:34 <Gracenotes> so perhaps it keeps the order :)
15:02:07 <dcoutts> Gracenotes: good point, then the code has the wrong parameter names
15:08:49 <Gracenotes> oh, good, Render is MonadIO
15:09:11 <Gracenotes> me needs me my IO
15:10:16 <monochrom> @quote monochrom IO
15:10:17 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
15:10:17 <lambdabot> entire human race would have to be rewritten!
15:10:43 <monochrom> @quote monochrom IO
15:10:43 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
15:10:43 <lambdabot> entire human race would have to be rewritten!
15:10:50 <Gracenotes> krad!
15:11:08 <monochrom> Oh well. I used to have a funny IO quote.
15:11:31 <monochrom> (It is about making IO rhyme with hi ho.
15:12:27 <monochrom> And Bird's book has evaluation order and strictness annotations (seq) too.
15:15:23 <Gracenotes> wooo! It all works! :D and fast! thanks, dcoutts
15:15:56 <Gracenotes> now that I've implemented the example from http://library.gnome.org/devel/pango/stable/pango-Cairo-Rendering.html#rotated-example .. time to actually write my own stuff
15:16:40 <dcoutts> Gracenotes: nice
15:18:38 <Gracenotes> dcoutts: if you've dealt with pango layouts before.. does one generally make them on the fly (while rendering)? or keep them for text that stays the same?
15:18:49 <Gracenotes> between renderings
15:19:09 <dcoutts> Gracenotes: do whichever is easier unless performance is important
15:20:00 <Gracenotes> hm. I'll try keeping them around; after all, the same layout can even be in many places, with just updating needed.
15:20:28 <dcoutts> Gracenotes: the only advantage to caching is if you do not change the text content
15:20:49 <nolrai_P> I want to convert an Integer to an Int? What do I use?
15:20:57 <kmc> :t fromIntegral
15:20:59 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:21:01 <Gracenotes> fromInteger is pretty direct
15:21:09 <kmc> :t fromInteger
15:21:11 <lambdabot> forall a. (Num a) => Integer -> a
15:21:24 <dcoutts> or more generally fromIntegral
15:21:38 <kmc> @check \x -> (fromIntegral x :: Int) == (fromInteger x)
15:21:40 <lambdabot>   "OK, passed 500 tests."
15:22:05 <Gracenotes> fromIntegral is just fromInteger . toInteger.. and toInteger for Integer is just id
15:22:24 <Gracenotes> so they are provably the same, not just according to QuickCheck :
15:22:26 <Gracenotes> :)
15:22:28 <smiler> Is there a dropLast for lists?
15:22:40 <dcoutts> :t init
15:22:41 <smiler> take (length (tail s) - 1) $ tail s feels a a bit lispy
15:22:42 <lambdabot> forall a. [a] -> [a]
15:22:43 <smiler> ah
15:22:54 <dcoutts> > init "foobar"
15:22:55 <lambdabot>   "fooba"
15:23:50 <Gracenotes> init pattern matches on the last element, so it only goes through the list once \o/
15:30:13 <Flippeh> Just h  -> liftIO $ hPutStr h ((render m) ++ "\r\n")
15:30:19 <Flippeh> This doesn't seem to send anything
15:30:21 <Flippeh> What's wrong?
15:30:46 <Flippeh> Ignore the ((render m) ++ "\r\n") part, that just renders my data type to a string and appends newlines
15:31:03 <Flippeh> Just h   -> liftIO $ hPutStr h "Something\r\n"
15:31:35 <Saizan> Flippeh: maybe you need an hFlush ?
15:31:50 <Peaker> Flippeh, Prefix calls like (render m) have higher precedence than infix calls like ++, you don't need () around render m
15:32:06 <Flippeh> Flushing did it, thanks Saizan
15:32:09 <Flippeh> And thanks Peaker :(
15:32:10 <Flippeh> :)
15:32:19 <augur> does anyone know if theres a language like haskell, etc. (in that it's got strong typing, or similar things) but which also does preemptive error detection?
15:32:23 <Peaker> Flippeh, hPutStrLn does the ++"\r\n" for you, I think (in a possibly more portable way though)
15:32:23 <Flippeh> I rather have too many ()'s than too few
15:32:36 <Flippeh> Peaker: what about Linux based OSs?
15:32:38 <Peaker> Flippeh, in Haskell, its unlikely too few () will cause bugs, most of the time
15:32:41 <Flippeh> It should only append \n there
15:33:03 <Flippeh> The protocol wants \r\n :)
15:33:09 <Peaker> Flippeh, There's just one precedence rule to remember here, which is useful in many many situations :)  (prefix calls higher precedence than all infix)
15:33:34 <Saizan> augur: what do you mean by preemptive error detection?
15:33:55 <augur> saizan: well, for instance, as a simple example, detecting use of an unbound variable prior to actual execution
15:34:24 <Saizan> augur: haskell does scope checking at compilation, way before than execution
15:34:31 <mauke> Flippeh: \r\n is not a specific byte sequence; the protocol can't want \r\n
15:34:36 <augur> right, but i mean hardcore checking :p
15:34:56 <augur> because i can imagine a number of other more complicated types of "scope-like" checking that goes beyond just variable scope
15:35:18 <Saizan> well, we use types for that
15:36:05 <Flippeh> Can you pattern match records?
15:36:12 <Flippeh> Or only use the accessor functions?
15:36:15 <Jedai> Flippeh: Yes
15:36:15 <mauke> Flippeh: yes, both by position and by name
15:36:16 <Flippeh> I use them so rarely
15:36:21 <Flippeh> Thanks :)
15:36:42 <monochrom> f MyType{myfield1=x} = x+1
15:36:53 <byorgey> foo (RecordConstructor{ field1 = x, field2 = y }) = ... x ... y ...
15:36:54 <Jedai> Flippeh: You can even match them partially (only on some of their fields) and there are some extension to make them even more useful
15:36:56 <monochrom> @src Complex
15:36:56 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
15:37:13 <monochrom> Err, right, s/MyType/MyCtor/
15:37:40 <mauke> byorgey: (the parens are not required)
15:37:54 <monochrom> As it turns out, from the fine prints, the parens are optional.
15:37:59 <augur> saizan: not for what i mean :p
15:38:12 <augur> unless haskell has some crazy way of defining types that i was unaware of
15:38:20 * monochrom reads the haskell98 report for breakfast
15:38:27 <augur> i just mean some sort of preemptive bug detection
15:38:55 <mauke> .oO( types are some sort of preemptyive bug detection )
15:38:57 <Daimonic> haskell 2010 omg
15:39:04 <augur> samauke, indeed they are
15:39:21 <augur> im thinking of something like that but on steroids for other domains of computation
15:39:35 <Jedai> augur: we lack details to tell you if it can be done with Haskell type system (which is probably much more powerful than anything you've ever seen except if you tried dependent typing)
15:40:01 <ddarius> Dependent typing is orthogonal to parametric polymorphism.
15:40:04 <augur> so for instance consider some function like... foo x = x !! 10
15:40:04 <augur> or whatever
15:40:09 <Saizan> augur: haskell types are more expressive than you'd think, take a look at oleg's site to see how far then can be bent
15:40:10 <augur> if in some other function, bar x = ...; foo []; ...
15:40:30 <augur> you can figure out, prior to execution, that bar will always throw an error
15:40:34 <mauke> augur: that looks like a standard example for dependent types
15:40:45 <monochrom> haskell98 does not mention or require static analysis of this kind. I know of no project that checks array indexes. But there was a project checking safe uses of inexhaustive patterns.
15:40:56 <mauke> @where catch
15:40:57 <lambdabot> http://community.haskell.org/~ndm/catch/
15:41:05 <monochrom> Yeah, catch is the project.
15:41:13 <augur> monochrom, its just an example of what i mean. i can see any number of other things that might look like that
15:41:22 <Jedai> augur: That can be encoded in Haskell type system, though absent dependent typing you have problem dynamically creating data from those types
15:41:24 <Saizan> that just needs lists with their length annotated in their types, you can do that easily with gadts and/or typeclasses
15:41:38 <augur> basically, a thing that takes your code and calculates what could cause an error
15:41:53 <Jedai> augur: That can't exist
15:41:55 <Saizan> Jedai: you'd use existentials when the length is unknown
15:41:55 <mauke> augur: like a total language?
15:41:57 <monochrom> I just feel that if the question is worded "does haskell check ___" then I should take the liberty to interpret it literally: no, the haskell98 report does not say that.
15:42:07 <augur> jedai: why not?
15:42:23 <augur> mauke: not necessarily. it wouldnt even have to catch all bugs preemptively
15:42:24 <Jedai> augur: or at least not if your language is Turing-Complete, that would be equivalent to the halting problem
15:42:31 <augur> jedai: no it wouldnt
15:42:42 <monochrom> I don't actually care about the halting problem.
15:42:45 <augur> i didnt say discover if this input will cause a bug
15:42:49 <augur> thats the halting problem
15:42:55 <augur> sort of.
15:42:59 * ddarius is tired of problems, we need halting solutions!
15:43:04 <augur> this is sort of inverse
15:43:05 <Jedai> Saizan: Sure, but it's still a pain to do
15:43:18 <augur> saying, is there SOME input that will cause a problem
15:44:04 <augur> and im not suggesting that you find all problems, just some reasonably identifiable ones
15:44:20 <mauke> f n | odd n = 3 * n + 1 | otherwise = n `div` 2
15:44:44 <augur> so for instance if you did, like... foo x = x !! (ackermann 100)
15:44:44 <Jedai> augur: Ok, then types can do a lot of things, if you're willing to give them a chance
15:44:56 <monochrom> Imagine if #math keeps mentioning G√∂del incompleteness every week.
15:45:08 <augur> the checker shouldnt spit back yes or not, it should spit back "this causes an error if length x <= ackermann 100
15:45:23 <ddarius> monochrom: Isn't #math mostly like linear algebra problems and such?
15:45:35 <augur> a friend of mine is an op for #math. o.o;
15:45:52 <augur> jedai: so what kinds of types were you thinking could do this?/
15:45:54 <monochrom> Oh even linear algebra problems enjoy much incompleteness :)
15:46:10 <monochrom> But I digress to #haskell-blah
15:46:31 <Jedai> augur: There are some project that tries to do that for various languages : deriving what must be proven (or at least admitted) for the program to run correctly
15:46:41 <ddarius> monochrom: Perhaps it comes up weekly in #logic.
15:46:43 <augur> hm. well!
15:46:55 <Jedai> Some works based on Coq for instance
15:47:06 <allbery_b> augur: those are dependent types.  Haskell doesn't have them but can emulate them to some extent (you were already pointed to Oleg's site)
15:47:09 <augur> i have a desire to design a toy language (maybe a lisp dialect for simplicity) and experiment with a checker for that language
15:47:42 <allbery_b> You might want to play with Agda a bit
15:48:00 <augur> hmm
15:49:12 <allbery_b> practically, dependent types tend to be complex and a bit expensive in my (admittedly limited) experience
15:49:33 <allbery_b> and I think the firld is still evolving
15:49:33 <defn> http://pastie.org/private/21ebzqowf8n4utik68lta -- Could someone tell me how to implement withIM?
15:49:38 <augur> well i wouldnt do this with types, but
15:49:38 <Jedai> augur: Agda would allow you to write that such that the types of foo would be "(n > ackermann 100) => List n a -> a" or equivalent
15:49:43 <augur> nor would i want something complex
15:50:37 <augur> hmm. jedai: im looking at the wiki entry. its quite interesting.
15:50:46 <Jedai> augur: If you don't want to deal with "complex" you should probably forget this kind of thing already, except perhaps in a very restricted framework and with limited usefulness
15:50:59 <allbery_b> agreed
15:51:06 <ddarius> allbery_b: Agda is a total language which adds some burden.  Cayenne may be a better example though you lose much by lacking totality.
15:51:11 <Jedai> augur: At least in the CS landscape as it is now
15:51:13 <augur> well maybe my meaning of complex isnt yours, who knows. :p
15:51:34 <defn> anybody knows what's wrong in my pastie?
15:51:54 <augur> i mean, i would have it track all the way into distant computations as far as it could get
15:52:01 <Jedai> augur: You would have to be very bright indeed for you to handle those problems without complexity... ^^
15:52:02 * ddarius would recommend looking at Dawson Engler's work on metal/xgcc that got turned into Coverity.
15:52:46 <allbery_b> defn:  ask in #xmonad, maybe?
15:53:06 <defn> oh man im sorry
15:53:12 <defn> i thought i was in #xmonad :X
15:53:18 <allbery_b> heh
15:54:21 <ddarius> Dawson Engler's work is interesting as the analyses are application-specific and neither sound nor complete.
15:54:52 <allbery_b> somehow that doesnt sound very Haskelly :)
15:55:22 <ddarius> Lack of completeness is typical; lack of soundness just means you can get false positives.
15:55:37 <monochrom> This is because people in #haskell can only think of "dependent types".
15:56:24 <augur> hm. dependent types seem to imply that values can be seen as have multiple types
15:56:46 <monochrom> Outside this pond, much progress has been made under the umbrellas of static analysis and software model-checking.
15:56:49 <Flippeh> I start loving Haskell again
15:57:01 <allbery_b> that's somewhat inevitable, yes.  a 3-element list belongs to, at minimum: list of *type, 3-element list of *type
15:57:17 <augur> unless you have it so that dependent types are subtypes of some base type
15:57:51 <allbery_b> but if you sweep the dependency under the rug, you don't gain anything from having it
15:57:57 <ddarius> allbery_b: Whether values have unique types or not is orthogonal to dependent typing.
15:58:03 <augur> e.g. List n is the dependent type, and the independent list type is the type forall n. List n
15:58:03 <monochrom> For example look up "Byron Cook" and you will find they are even in the midst of fighting non-termination now.
15:58:27 <ddarius> exists n not forall n
15:58:35 <augur> no, forall n
15:58:47 <augur> List = forall n List n
15:58:56 <augur> or no maybe youre right :)
15:58:58 <augur> whatever :p
15:59:00 <augur> point is!
15:59:18 <augur> that could be a way to get non-dependent types to work on dependent types without having multiple types
15:59:37 <augur> sort of i guess like defining some type as a union of two other types
16:00:01 <ddarius> But a value of List 3 Int is, say, Cons 1 (Cons 2 (Cons 3 Nil)), a value of List Int = exists n. List n Int is pack Cons 1 (Cons 2 (Cons 3 Nil)) as List Int
16:00:15 <augur> yes yes youre right
16:00:16 <augur> hush
16:00:18 <augur> :P
16:04:47 <augur> thank you guys for pointing me to dependent types
16:04:50 <augur> this is very interesting
16:05:04 <Flippeh> A fully working bot with no function with more than 10 lines
16:05:24 <Flippeh> :)
16:06:28 <monochrom> Every extra function costs you just 10 more lines.
16:07:30 <Flippeh> Nooo :(
16:07:36 <watermind> when you want to transverse a monomorphic tree like datatype what do you usually use?
16:07:51 <Saizan> mh, it'd be nice if the termination check in e.g. agda could decide that a certain application of a partial function is actually safe
16:08:06 <Saizan> it'd be "whole program" termination checking
16:08:23 <kmc> watermind, pattern matching?
16:08:30 <monochrom> I usually use recursion.
16:08:31 <kmc> that's how we traverse stuff in general
16:08:32 <watermind> do you stay within H98, or use some generic programming approach, or template haskell?
16:08:53 <watermind> kmc: monochrom: true I didn't explain myself too well...
16:08:56 <kmc> don't forget Traversable and Foldable
16:09:14 <kmc> SYB is slow but can be convenient
16:09:32 <watermind> kmc: don't they need to be polymorphic to use Foldable and Trasversable?
16:10:09 <kmc> hmm maybe
16:10:12 <ddarius> Everyone uses recursion.  It's just a matter of where it is/who wrote it.
16:10:37 <Saizan> yes, it needs to be of kind * -> * to be an instance of those
16:10:59 <watermind> so that's what I meant...
16:11:15 <watermind> I once wrote a big library that I was using for monomorphic stuff
16:11:15 <monochrom> Heh. I usually write my own recursion first. Premature re-factoring is the root of generic programming.
16:11:58 * ddarius wants a practical implementation of the dynamic pattern calculus.
16:12:03 <watermind> and the idea was that I would operate the node with the subtrees
16:12:11 <Saizan> you could write your own fold, or maybe start with Uniplate which has a simpler interface than other SYB approaches
16:12:21 <watermind> and so I had all this "folds" and similar things
16:12:22 <monochrom> My usual second step is to write my own fold.
16:12:49 <watermind> monochrom: sure but what I mean is, you end up writing that for each monomorphic tree like structure
16:12:55 <watermind> that's why I made my library
16:13:04 <watermind> but not sure if it was the best approach
16:13:41 <monochrom> I haven't reached that stage yet.
16:14:15 <monochrom> I am a strong believe of: when I run into that problem for real, a solution will unfold itself.
16:14:35 <Saizan> oO( we could port coq's code for the generation of recursion schemes to TH)
16:14:43 <CalJohn> interesting question: why are unfolds so rare in functional programming?
16:15:09 <augur> hm
16:15:52 <aavogt> part of it is that Enum may often be enough?
16:16:00 <augur> it seems that dependent types and type constructors and type polymorphism and such are all kind of ... implications of a Smalltalk-like language
16:16:04 <augur> where classes are objects too
16:16:21 <CalJohn> I very rarely think of them when I am writing, but I often think I folds.  Is this because unfolds are less useful or because I have not picked up unfolds like I have folds
16:16:32 <augur> i mean, it seems like all this higherorder type stuff is about first-class types
16:16:52 <ddarius> @google underappreciated unfold
16:16:54 <lambdabot> No Result Found.
16:16:55 <augur> and in Smalltalk, classes, being the equivalent of types, are first-class
16:16:57 <augur> hm hm!
16:17:05 <ddarius> http://citeseer.ist.psu.edu/283921.html
16:17:10 <augur> but you cant define a smalltalk class relative to other classes
16:17:11 <CalJohn> @type unfold
16:17:14 <lambdabot> Not in scope: `unfold'
16:17:18 <CalJohn> ^ exactly.
16:17:27 <Saizan> @type unfoldr
16:17:27 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:17:28 <augur> wut
16:17:35 <augur> exactly what
16:17:38 <augur> who are you talking to
16:17:38 <CalJohn> heh
16:17:40 <augur> use pings! :|
16:17:40 <CalJohn> my mistake
16:18:02 <Baughn> Is toForeignPtr . copy a safe way to get a modifiable copy of a bytestring? (Um.. FFI code)
16:18:34 <ddarius> @hoogle foldr
16:18:35 <aavogt> > unfoldr (Just . join (,) . succ) 1
16:18:36 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
16:18:37 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
16:18:37 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
16:18:37 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
16:18:37 <ddarius> @hoogle unfoldr
16:18:38 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
16:18:39 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
16:18:40 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
16:19:06 <Saizan> we lack an Unfoldable
16:19:25 <aavogt> can it be written in terms of Foldable?
16:19:39 <ddarius> CalJohn: There is a sense in which unfolds are closer to OO.
16:19:42 <ddarius> than folds.
16:19:55 <Saizan> Foldable doesn't offer an interface to build things
16:21:45 * CalJohn reads the Gibbons paper
16:23:13 <Optimality> haskell++
16:23:31 <Optimality> I can save the state of the game I'm writing with "writeFile $ show game_state"
16:23:41 <Optimality> with the appropriate path inserted
16:23:46 <Optimality> that's pretty nice
16:24:19 <poe> (Optimality maybe you don't need it but there is a great way to get a system-indipendent application-specific path with System.Directory :))
16:24:36 <Optimality> poe: thanks, I'll look into it :)
16:25:09 <aavogt> if you have lots of state, perhaps binary would be quicker for serialization
16:25:45 <Optimality> is there a fast way to convert it to binary? I do have a lot of state
16:27:36 <MarcWeber> Is anyone interested in a hack-nix demonstration ? I got no fedback on the haskell-cafe mailinglist yet. So I think it's too much work setting up the environment to get started and try it out?
16:28:11 <kmc> poe, cool
16:28:28 <djwonk> does Haskell have sprintf?
16:28:32 <poe> Lemmih++
16:28:33 <djwonk> it has printf
16:28:43 <kmc> @type printf
16:28:45 <lambdabot> forall r. (PrintfType r) => String -> r
16:28:51 <kmc> yeah well that's not too useful actually
16:28:58 <djwonk> "The return value is either http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html#t%3AString or (http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#t%3AIO a)."
16:29:05 <EvilTerran> @type printf :: String -> Int -> String
16:29:06 <lambdabot> String -> Int -> String
16:29:12 <EvilTerran> @type printf :: String -> Char -> IO ()
16:29:13 <lambdabot> String -> Char -> IO ()
16:29:15 <Lemmih> poe: Eh?
16:29:15 <djwonk> either String or (IO a)
16:29:16 <MyCatVerbs> PrintfType is true for String and IO ().
16:29:20 <EvilTerran> it does two things at once
16:29:23 <poe> Lemmih found it in timetracker :)
16:29:29 <djwonk> EvilTerran: that's interesting
16:29:41 <MyCatVerbs> And also for functions from any printf-able type to anything which is PrintfType-able.
16:29:43 <EvilTerran> djwonk, it's a pretty messy hack
16:29:47 <kmc> @type hPrintf
16:29:50 <lambdabot> forall r. (HPrintfType r) => GHC.IOBase.Handle -> String -> r
16:29:51 <mauke> > printf "%s is %d" "the answer" 42 :: String
16:29:53 <lambdabot>   "the answer is 42"
16:29:55 <MyCatVerbs> Lies, it's a neat hack.
16:30:01 <kmc> > printf "%s is %d" :: String
16:30:03 <lambdabot>   "* Exception: Printf.printf: argument list ended prematurely
16:30:07 <kmc> note that's a *runtime* error :/
16:30:19 <aavogt> Optimality: there's a tool called derive which can generate Binary instances
16:30:25 <aavogt> @google haskell derive
16:30:26 <EvilTerran> MyCatVerbs, i won't call it neat if it's partial at runtime
16:30:27 <lambdabot> http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/deriving.html
16:30:27 <lambdabot> Title: 7.5.ÔøΩExtensions to the "deriving" mechanism
16:30:35 <aavogt> hmm, somewhere else
16:30:37 <djwonk> you all recommend printf? what's a good way to build up strings without using ++
16:30:40 <MyCatVerbs> EvilTerran: so are head and tail!
16:30:42 <aavogt> @google ndm derive
16:30:43 <lambdabot> http://community.haskell.org/~ndm/derive/
16:30:43 <lambdabot> Title: Neil Mitchell - Derive
16:30:46 <djwonk> or is ++ just fine. just looks a bit ugly to me
16:30:49 <kmc> djwonk, Text.PrettyPrint
16:30:51 <kmc> ++ is slow too
16:30:55 <MyCatVerbs> djwonk: there's a method nicknamed "functional unparsing".
16:30:59 <MarcWeber> djwonk There is a template haskell based printf library
16:30:59 <Optimality> aavogt: cool, thanks :)
16:31:45 <MyCatVerbs> You write a set of functions, each of which has type String -> String, each of them appends a string onto the *front* of the input string that it is given. Then you combine all of those functions with (.) and then you run them against the empty string and hey presto.
16:32:04 <kmc> that's how ShowS works i'nnit?
16:32:14 <MyCatVerbs> > shows 5 . shows " bacon " . shows 12 $ ""
16:32:15 <lambdabot>   "5\" bacon \"12"
16:32:21 <djwonk> kmc MyCatVerbs MarcWeber thanks
16:32:23 <MyCatVerbs> That is indeed exactly how shows works.
16:32:24 <kmc> there's also that thing i keep forgetting for fast-appendable sequences
16:32:26 <kmc> by the same trick
16:32:30 <kmc> keep forgetting the name of *
16:32:39 <MyCatVerbs> kmc: DList?
16:32:44 <kmc> yes
16:32:57 <kmc> yeah, djwonk also check out dstring on hackage
16:33:49 <kmc> i personally enjoy Text.PrettyPrint
16:33:55 * mauke uses http://hackage.haskell.org/package/printf-mauke
16:33:57 <bos> wow, it took me 6 hours to find and fix a bug in the statistics package just now.
16:34:01 <bos> wheee-yew!
16:34:02 <ddarius> There's no way for printf not to be partial at run-time.
16:34:31 <kmc> sure there is, by making it partial at compile-time ;)
16:34:36 <mauke> ddarius: there are at least two ways, but I don't know if you'd call them printf anymore :-)
16:34:53 <kmc> in gcc C, printf is actually dependently typed
16:35:19 <mauke> __attribute__((__printf__))
16:36:04 * hackagebot upload: statistics 0.4.0 - A library of statistical types, data, and functions (BryanOSullivan)
16:36:58 <ddarius> mauke: Can I do main = do fmt <- getLine; printf fmt x y z with them?
16:37:08 <mauke> ddarius: no
16:37:14 <ddarius> Then they aren't printf.
16:37:30 <mauke> but I consider that code broken, anyway
16:38:15 <mauke> TH printf actually makes a lot of sense, because you should never call printf without a statically known format string
16:38:15 <ddarius> main = do fmt <- getLine; when (good fmt) $ printf fmt x y z
16:38:45 <mauke> ddarius: that looks pointless
16:39:21 * bos agrees with mauke
16:39:28 <mauke> do str <- getLine; case parse str of Just fmt -> fmt x y z; Nothing -> return ()
16:40:07 <kmc> here "parse" presumably includes a safe cast?
16:40:13 <kmc> i.e. parses to a specific format type
16:41:07 <mauke> no cast, it's monomorphic
16:49:24 <toast-opt> :t (.)
16:49:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:50:48 <toast-opt> hmm
16:52:53 <monochrom> confused? :)
16:53:12 <kmc> should be a member of Category
16:53:34 <kmc> can we separate lambdabot commands for "type" and "crazy secret type"
16:53:56 <monochrom> ,type (.)
16:53:57 <lunabot>  luna: parse error on input `type'
16:54:02 <monochrom> ,help
16:54:06 <lunabot>  type of an expression:      , [$ty| \x -> x |]
16:54:06 <lunabot>  get info for a type/class:  , src ''Monad
16:54:06 <lunabot>  get info for a var/con:     , src 'fix
16:54:22 <toast-opt> hmm, i'm looking for a two-arg composition function
16:54:23 <mauke> #type (.)
16:54:24 <lunabot>  luna: Not in scope: `type'
16:54:35 <mauke> :t (.) . (.)
16:54:37 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:54:40 <monochrom> , [$ty| (.)]
16:54:41 <lunabot>  luna: lexical error in string/character literal at end of input
16:54:49 <monochrom> , [$ty| (.) \]
16:54:50 <lunabot>  luna: lexical error in string/character literal at end of input
16:54:52 <kmc> , [$ty| (.) |]
16:54:52 <monochrom> darn
16:54:54 <lunabot>  forall a c b . (b -> c) -> (a -> b) -> a -> c
16:54:56 <monochrom> Yeah
16:55:05 <toast-opt> given f :: a -> b -> c, and g :: c -> d, i want something that will compose f and g to make a -> b -> d
16:55:08 <mauke> #ty (.) . (.)
16:55:10 <lunabot>  forall a1 c b a . (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:55:24 <toast-opt> ... or, i could just make f :: (a,b) -> c, and (g . f)
16:55:26 <monochrom> Anyway, that is your separate command for non-crazy-secret types :)
16:55:31 <kmc> is #x y a shorthand for [$x| y |] ?
16:57:02 <monochrom> lunabot++
16:57:10 <toast-opt> let (g .@ f) = \a b -> g $ f a b
16:57:15 <toast-opt> that might work
16:57:36 <mauke> #ty \g f -> (g .) . f
16:57:39 <lunabot>  forall a1 c b a . (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
16:57:56 <ddarius> toast-opt: (.@) = (.) . (.) as others have sai
16:58:07 <toast-opt> oh, thx
16:58:25 <toast-opt> > (g .) . f
16:58:27 <lambdabot>   No instance for (SimpleReflect.FromExpr (f1 (f a)))
16:58:27 <lambdabot>    arising from a use o...
16:58:32 <monochrom> @djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
16:58:33 <lambdabot> f a b c d = b (a c d)
16:58:37 <monochrom> hehe
16:58:51 <ddarius> @. pl djinn (a -> b -> c) -> (c -> d) -> (a -> b -> d)
16:58:53 <lambdabot> f = flip ((.) . (.))
16:59:03 <monochrom> too many abcd's in campbell letter soup :)
16:59:05 <toast-opt> eh, what is djinn?
16:59:13 <ddarius> @help djinn
16:59:13 <mauke> toast-opt: derives code from types
16:59:14 <lambdabot> djinn <type>.
16:59:14 <lambdabot> Generates Haskell code from a type.
16:59:14 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
16:59:26 <mauke> code inference :-)
16:59:28 <toast-opt> and how did lambdabot figure out exactly what i wanted from just the type?
16:59:33 <toast-opt> heh, code inference
16:59:44 <ddarius> Types can say a lot.
16:59:57 <toast-opt> as discussed yesterday
17:00:13 <monochrom> parametric polymorphism puts a severe restriction on what a function can do.
17:00:27 <mauke> see also http://okmij.org/ftp/Haskell/types.html#de-typechecker
17:00:30 <kmc> what do you call the class of functions which are uniquely determined by their types?
17:00:46 <toast-opt> kmc, heh, don't you mean set?
17:00:58 <monochrom> So for example, if the type is Int->Int, there are too many possibilities. But if the type is a->a, there are only two possibilities left.
17:00:58 <kmc> a set is a class
17:01:29 <toast-opt> kmc, not a math major.  which is more specific?  set?
17:01:33 <ddarius> There are only finitely many Int -> Int functions...
17:01:52 <kmc> toast-opt, yes
17:02:00 <toast-opt> ddarius, heh, arithmetic mod 2^32 is finite
17:02:16 <monochrom> Roughly speaking, since this is not Java, it is not like you can do an instanceof and then do funny things like "if it is an int, I'll decrease it; if it is a string, I'll append something..."
17:02:19 <ray> 5 is too many
17:02:24 <toast-opt> monochrom, what are the two possibilities?  i only know the one
17:02:31 <toast-opt> 'unknown'?
17:02:34 <ray> id or error
17:02:36 <kmc> toast-opt, the class of all sets is not a set
17:02:48 <mauke> I count three
17:02:55 <toast-opt> let f a = a
17:02:58 <toast-opt> and?
17:03:01 <mauke> :t [id, undefined, const undefined]
17:03:03 <lambdabot> forall a. [a -> a]
17:03:12 <toast-opt> undefined, that's right
17:03:29 <monochrom> :t const undefined
17:03:31 <lambdabot> forall a b. b -> a
17:04:10 <ray> putting _|_ aside, which is often smart, there's only one possibility
17:04:14 <eugenn> @quote really
17:04:15 <lambdabot> dons says:  its like you can really see the guy's brain melting
17:04:38 <monochrom> I see, three.
17:04:43 <kmc> @quote brain
17:04:44 <lambdabot> Korollary says: my brain is fried. I cant read any more STM papers
17:04:52 <ray> @quote papers
17:04:54 <lambdabot> dons says: too many papers, not enough code
17:05:04 <eugenn> @quote clean
17:05:05 <lambdabot> vincenz says: why do you want to be dynamically gendered? lexically gendered is cleaner
17:05:16 <toast-opt> what's 'const'?
17:05:18 <toast-opt> :t const
17:05:19 <lambdabot> forall a b. a -> b -> a
17:05:27 <ddarius> The type says it all.
17:05:28 <mauke> @djinn a -> b -> a
17:05:29 <lambdabot> f a _ = a
17:05:32 <ddarius> (almost)
17:05:41 <toast-opt> oh, gotcha
17:05:43 <eugenn> > const 3 4
17:05:45 <lambdabot>   3
17:06:00 <toast-opt> :t undefined
17:06:02 <lambdabot> forall a. a
17:06:06 <mauke> (const k) is the the function that always returns k, no matter what you give it
17:06:14 <toast-opt> undefined isn't a function
17:06:19 <mauke> it totally is
17:06:25 <ddarius> > undefined 3
17:06:25 <toast-opt> oh, yeah
17:06:27 <lambdabot>   * Exception: Prelude.undefined
17:06:29 <toast-opt> a = b -> c
17:06:30 <eugenn> 4 is a function
17:06:31 <mauke> toast-opt: it says forall a, which includes b -> c
17:06:38 <monochrom> (I don't think you want to use the word "totally" so casually...)
17:06:53 <toast-opt> or, i should say, a can unify to b -> c ?
17:07:14 <ray> it totally isn't total
17:07:19 <toast-opt> heh
17:07:20 <mauke> toast-opt: you're doing it right!
17:07:21 <toast-opt> wow
17:07:26 <eugenn> @quote squeak
17:07:27 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
17:07:47 <monochrom> @quote totally
17:07:47 <lambdabot> merus says: Mathematics is totally full of women.
17:07:52 <monochrom> ...
17:08:00 <toast-opt> mauke, i had a C moment, predending that 'a' couldn't match 'b -> c'
17:08:02 <MyCatVerbs> @quote chocolate
17:08:02 <lambdabot> SimonBrenner says: 2kg of chocolate 'thunks' to 'force' really might 'blow your stack' later on.
17:08:05 <toast-opt> that functions aren't values
17:08:10 <toast-opt> such a C thing to say
17:08:29 <monochrom> hahaha
17:08:30 <toast-opt> just like saying 'void/nil isn't a value'
17:08:51 <eugenn> > 0^0
17:08:52 <lambdabot>   1
17:08:58 <monochrom> I am not a value
17:09:00 <akappa> 0^0 = 1?
17:09:03 <toast-opt> > o.o
17:09:05 <lambdabot>   Couldn't match expected type `a -> b'
17:09:05 <lambdabot>         against inferred type `Simple...
17:09:11 <akappa> lol, it isn't undefined?
17:09:17 <toast-opt> > o . o <
17:09:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:09:26 <toast-opt> eh, it would need parens
17:09:37 <mauke> > () -- () <
17:09:39 <lambdabot>   ()
17:09:43 <toast-opt> much better
17:09:53 <monochrom> I refuse to participate in this 348th incarnation of this stupid 0^0 "discussion" hogwash.
17:09:54 <ddarius> akappa: It depends.
17:10:06 <toast-opt> monochrom - is there an archive?
17:10:11 <toast-opt> i'd gladly visit the archive instead
17:10:26 <mauke> I think it's in the topic
17:10:31 <monochrom> I suppose the topic has a url to logs, but I have never used it.
17:10:37 <kmc> @src (^)
17:10:39 <lambdabot> x ^ 0            =  1
17:10:39 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
17:10:39 <lambdabot>   where f _ 0 y = y
17:10:39 <lambdabot>         f x n y = g x n
17:10:39 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
17:10:40 <lambdabot>                       | otherwise = f x (n-1) (x*y)
17:10:43 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
17:10:49 <akappa> ddarius, on what?
17:10:51 <nolrai_P> :t sepBy
17:10:52 <lambdabot> Not in scope: `sepBy'
17:11:03 <nolrai_P> :t Text.Parsec.sepBy
17:11:05 <lambdabot> Couldn't find qualified module.
17:11:17 <kmc> @src (=<<)
17:11:19 <lambdabot> f =<< x = x >>= f
17:11:43 <toast-opt> >  (8:)
17:11:45 <lambdabot>   []->
17:11:45 <lambdabot>    [8]
17:11:45 <lambdabot>  [-2]->
17:11:45 <lambdabot>    [8,-2]
17:11:45 <lambdabot>  [-2,-1]->
17:11:47 <lambdabot> [3 @more lines]
17:11:47 <ddarius> akappa: On the source of the notion of exponentiation.
17:11:57 <monochrom> It depends on whether you are a platonist or not.
17:12:07 <akappa> monochrom, :)
17:12:22 <mauke> platonists did 9/11
17:12:22 <eugenn> > quot 3 2
17:12:24 <lambdabot>   1
17:12:34 <akappa> ddarius, I haven't ever see a fully formal definition of exponentiation, so I trust you
17:12:36 <Baughn> How do I coax cabal into including a given .a file in a library build?
17:13:11 <monochrom> I misread that as "how do I coax cable into including... what? .a files?"
17:13:40 <poe> The point being there are multiple (formal) definitions of exponentiation that agree up to a point, where they then differ.
17:14:31 <eugenn> :t quot
17:14:33 <lambdabot> forall a. (Integral a) => a -> a -> a
17:14:37 <eugenn> :t div
17:14:39 <lambdabot> forall a. (Integral a) => a -> a -> a
17:14:48 <eugenn> @src quot
17:14:48 <lambdabot> Source not found. Maybe you made a typo?
17:14:53 <eugenn> @src div
17:14:54 <lambdabot> Source not found. Sorry.
17:14:58 <eugenn> ???
17:15:08 <Baughn> monochrom: Well, I just about get it to work for ghc --make, but ghci insists on a .so file
17:15:15 <aavogt> > (quot(-3) 2,mod (-3) 2)
17:15:16 <lambdabot>   (-1,1)
17:15:28 <Baughn> monochrom: I can /make/ one, sure.. then I just have to figure out how to get it into ~/.cabal
17:19:22 <eugenn> @check (\x -> quot 3 x) == (\x -> div 3 x)
17:19:24 <lambdabot>   No instance for (GHC.Classes.Eq (t -> t))
17:19:24 <lambdabot>    arising from a use of `GHC.Cla...
17:19:29 <Optimality> aavogt++ # derive works pretty well :)
17:19:47 <mauke> warning: don't drink and derive
17:19:51 <MoALTz> > map 5 [(2<),(<=7)   ,   (1<=),(<=3)]
17:20:04 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:20:04 <lambdabot>    `GHC.Num.Num t' arising ...
17:20:15 <monochrom> don't think and derive.
17:20:22 <idnar> > map ($ 5) [(2<),(<=7)   ,   (1<=),(<=3)]
17:20:23 <lambdabot>   [True,True,True,False]
17:20:26 <mauke> > sequence [(2<),(<=7)   ,   (1<=),(<=3)] 5
17:20:28 <lambdabot>   [True,True,True,False]
17:20:37 <MoALTz> hmm
17:20:37 <idnar> hax
17:21:23 <MoALTz> was from a ranges idea i had the other day (although it's probably not too original)
17:21:35 <toast-opt> > [(0,0) .. (2,3)]
17:21:37 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
17:21:37 <lambdabot>    arising from the arithmetic sequ...
17:22:06 <toast-opt> > [(x,y) | x<-[0..2], y <- [0..3]}
17:22:07 <lambdabot>   <no location info>: parse error on input `}'
17:22:16 <toast-opt> > [(x,y) | x<-[0..2], y <- [0..3]]
17:22:17 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
17:22:36 <mauke> > liftA2 (,) [0..2] [0..3]
17:22:38 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3)]
17:22:41 <Optimality> > [i | i <- [1..]]
17:22:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:22:46 <Optimality> aww
17:22:53 <mauke> > [1..]
17:22:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:23:06 <MoALTz> > zip [1..2] [1..3]
17:23:08 <lambdabot>   [(1,1),(2,2)]
17:23:10 <Optimality> mauke: I know, but I figured that would be easy enough to get around :)
17:23:19 <Optimality> trying to be more obscure
17:23:27 <mauke> > fix error
17:23:29 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
17:23:37 <Optimality> mauke: rofl
17:24:15 <eugenn> > [i/i | i <- [1..]]
17:24:16 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
17:24:31 <mauke> > map (join (/)) [0..]
17:24:33 <lambdabot>   [NaN,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
17:24:36 <MoALTz> > [i`div`1 | i <- [1..]]
17:24:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:24:43 <MoALTz> > [i`div`i | i <- [1..]]
17:24:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:24:55 <toast-opt> > [1,1..]
17:24:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:25:01 <mauke> > repeat 1
17:25:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:25:23 <toast-opt> > let a = 1 : a in a
17:25:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:25:26 <aavogt> > cycle "* Exception: "
17:25:27 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
17:25:30 <MoALTz> > fix (1:)
17:25:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:25:35 <eugenn> > [1%i | i <- [1..]] --the harmonic series
17:25:36 <lambdabot>   [1 % 1,1 % 2,1 % 3,1 % 4,1 % 5,1 % 6,1 % 7,1 % 8,1 % 9,1 % 10,1 % 11,1 % 12...
17:25:38 <toast-opt> :t fix
17:25:40 <lambdabot> forall a. (a -> a) -> a
17:25:44 <watermind> funny it's      Foldable t => Trasversable t    and I expected it the other way around
17:25:44 <mauke> also: cycle [1], fix (1 :), iterate id 1
17:25:45 <ddarius> fix (1:map succ)
17:25:51 <ddarius> > fix (1:map succ)
17:25:53 <lambdabot>   Couldn't match expected type `[t]'
17:25:53 <lambdabot>         against inferred type `[a] -> [a]'
17:26:08 <ddarius> > fix ((1:) . map succ)
17:26:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:26:17 <MoALTz> wow
17:26:38 <toast-opt> i'm writing that one down
17:26:55 <mauke> > fmap fix return [1..]
17:26:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:27:17 <ddarius> > id [1..]
17:27:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:27:25 <kmc> > scanl (+) 0 [1 % (i^2) | i <- [1..]]
17:27:27 <lambdabot>   [0 % 1,1 % 1,5 % 4,49 % 36,205 % 144,5269 % 3600,5369 % 3600,266681 % 17640...
17:27:45 <kmc> > map fromRational $ scanl (+) 0 [1 % (i^2) | i <- [1..]] :: [Double]
17:27:47 <lambdabot>   [0.0,1.0,1.25,1.3611111111111112,1.4236111111111112,1.4636111111111112,1.49...
17:27:58 <kmc> > drop 50 $ map fromRational $ scanl (+) 0 [1 % (i^2) | i <- [1..]] :: [Double]
17:28:00 <lambdabot>   [1.6251327336215293,1.6255172011340244,1.6258870236192315,1.626243022195237...
17:28:31 <aavogt> > 2**(-64)
17:28:32 <MarcWeber> Lemmih: Do you have an updated .cabal file for your berkley db bindings ? I'm getting http://dpaste.com/126088/ . If you don't have I'll try to proide a patch
17:28:32 <lambdabot>   5.421010862427522e-20
17:28:41 <eugenn> > map (\n -> ((1+1/n)^n) [1..]
17:28:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:28:52 <Lemmih> MarcWeber: I do not.
17:28:57 <eugenn> > map (\n -> ((1+1/n)^n)) [1..]
17:28:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:28:59 <lambdabot>    `GHC.Real.Fractional a'
17:28:59 <lambdabot> ...
17:29:10 <mauke> eugenn: **, not ^
17:29:41 <eugenn> > (3%4)^7
17:29:42 <lambdabot>   2187 % 16384
17:29:50 <Lemmih> MarcWeber: I think some of the other BerkeleyDB bindings are more complete than mine.
17:30:14 <eugenn> > map (\n -> ((1+1/n)**n)) [1..]
17:30:15 <lambdabot>   [2.0,2.25,2.37037037037037,2.44140625,2.4883199999999994,2.5216263717421135...
17:30:29 <eugenn> :t (^)
17:30:31 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
17:30:36 <eugenn> :t (**)
17:30:38 <lambdabot> forall a. (Floating a) => a -> a -> a
17:30:53 <MoALTz> > fix ((1:) . map (\x -> x**2 - 1)) -- 1/x = x-1, 1 = x^2 - x, x = x^2 -1
17:30:55 <lambdabot>   [1.0,0.0,-1.0,0.0,-1.0,0.0,-1.0,0.0,-1.0,0.0,-1.0,0.0,-1.0,0.0,-1.0,0.0,-1....
17:31:02 <MarcWeber> Lemmih: I'm trying to package all packages found on hackage. That's it. But hackage should provide a way to add such notes.
17:31:43 <eugenn> > 3.4^2
17:31:45 <lambdabot>   11.559999999999999
17:31:56 <toast-opt> :t ((.).)
17:31:57 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
17:32:11 <toast-opt> :t (..)
17:32:12 <lambdabot> parse error on input `..'
17:32:35 <toast-opt> > (g.).f
17:32:36 <lambdabot>   No instance for (SimpleReflect.FromExpr (f1 (f a)))
17:32:37 <lambdabot>    arising from a use o...
17:32:54 <MoALTz> > fix ((1:) . map (\x -> (x+1)**0.5))
17:32:55 <lambdabot>   [1.0,1.4142135623730951,1.5537739740300374,1.5980531824786175,1.61184775412...
17:33:13 <toast-opt> wait... that's approximating...
17:33:33 <eugenn> > ((head .) . filter) (4>) [6,6,6,6,6,6,3,5,5,5,1,1]
17:33:34 <lambdabot>   3
17:34:41 <eugenn> :t fix
17:34:43 <lambdabot> forall a. (a -> a) -> a
17:35:00 <toast-opt> fix
17:35:03 <toast-opt> oops
17:35:07 <eugenn> > fix (+) 1
17:35:08 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:35:16 <MoALTz> @pl (\x -> (x+1)**0.5))
17:35:17 <lambdabot> (line 1, column 19):
17:35:17 <lambdabot> unexpected ")"
17:35:17 <lambdabot> expecting variable, "(", operator or end of input
17:35:19 <mauke> eugenn: fix only takes one argument
17:35:28 <MoALTz> @pl \x -> (x+1)**0.5)
17:35:29 <lambdabot> (line 1, column 17):
17:35:29 <lambdabot> unexpected ")"
17:35:29 <lambdabot> expecting digit, variable, "(", ".", "`", "!!", "^", "^^", "**", operator or end of input
17:35:31 <chrisdone> @check
17:35:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:35:41 <MoALTz> @pl \x -> (x+1)**0.5
17:35:42 <lambdabot> (** 0 . 5) . (1 +)
17:35:51 <eugenn> .. I'm sleepy at this my local time time
17:35:56 <chrisdone> @check \f xs -> (not . any f) xs == (all (not . f)) xs
17:35:57 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
17:35:57 <lambdabot>    arising fro...
17:36:02 <eugenn> > fix (+)
17:36:04 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:36:20 <mauke> eugenn: (+) doesn't match (a -> a)
17:36:48 <eugenn> > fix abs
17:36:51 <aavogt> > fix succ 0
17:36:52 <lambdabot>   No instance for (GHC.Enum.Enum (t -> a))
17:36:52 <lambdabot>    arising from a use of `GHC.Enum...
17:36:53 <lambdabot>   mueval-core: Time limit exceeded
17:37:05 <aavogt> > fix succ
17:37:06 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
17:37:15 <aavogt> ah defaulting
17:37:28 <eugenn> > fix replicate
17:37:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:37:34 <lambdabot>         against inferred type ...
17:37:52 <eugenn> > fix (1+)
17:37:56 <lambdabot>   mueval-core: Time limit exceeded
17:37:57 <jmcarthur> :t succ
17:37:59 <lambdabot> forall a. (Enum a) => a -> a
17:38:19 <jmcarthur> > fix succ ‚à∑ Natural
17:38:20 <eugenn> > succ 2.1
17:38:21 <lambdabot>   * Exception: stack overflow
17:38:22 <lambdabot>   3.1
17:38:29 <Baughn> > toEnum 0
17:38:31 <lambdabot>   ()
17:39:08 <eugenn> > toEnum 4
17:39:09 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
17:39:10 <jmcarthur> > fix (1+) ‚à∑ Natural
17:39:12 <lambdabot>   * Exception: stack overflow
17:39:33 <MoALTz> > fix ((1:) . map (** 0.5) $ (1+)
17:39:37 <eugenn> > fix (+1) :: Arrow
17:39:37 <idnar> > (fix (1+) ‚à∑ Natural) > 10
17:39:37 <lambdabot>   True
17:39:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:39:39 <lambdabot>   Class `Control.Arrow.Arrow' used as a type
17:39:42 <Baughn> > (fix (1+) :: Natural) > 3
17:39:44 <lambdabot>   True
17:39:46 <chrisdone> (not . any f) xs is faster in some cases than (all (not . f)) xs right?
17:40:10 <Baughn> chrisdone: I shouldn't think so
17:40:14 <idnar> chrisdone: I don't see how
17:40:25 <eugenn> @src fix
17:40:26 <lambdabot> fix f = let x = f x in x
17:40:41 <ddarius> It saves doing not some times, but that's probably free.
17:40:49 <Veinor> o7 Haskell
17:41:14 <idnar> any f returns early if it finds True, ie. if f returns True
17:41:19 <idnar> all (not . f) returns early if it finds False, ie. if f returns True
17:41:29 <idnar> but yeah, you save some not calls
17:41:50 <chrisdone> ok
17:42:00 <Veinor> any even [1, 2, 3, undefined]
17:42:02 <Veinor> whoops
17:42:07 <Veinor> > any even [1, 2, 3, undefined]
17:42:09 <lambdabot>   True
17:42:29 <idnar> > all (not . even) [1, 2, 3, undefined]
17:42:30 <lambdabot>   False
17:42:33 <eugenn> > undefined + 1
17:42:36 <lambdabot>   * Exception: Prelude.undefined
17:42:52 <Baughn> > (undefined + 1 :: Natural) > 0
17:42:54 <lambdabot>   * Exception: Prelude.undefined
17:42:56 <Veinor> > undefined 1 2
17:42:58 <lambdabot>   * Exception: Prelude.undefined
17:43:01 <Baughn> > (1 + undefined :: Natural) > 0
17:43:01 <Veinor> :D
17:43:02 <lambdabot>   True
17:43:10 <toast-opt> hmm, is there any way to break into a long running computation in ghci, without exiting process?
17:43:11 <eugenn> wow
17:43:13 <Veinor> Baughn: wait.... what?
17:43:16 <eugenn> I got that!
17:43:17 <Baughn> toast-opt: ctrl-c?
17:43:21 <toast-opt> like, in python, ^C will bring back to interactive prompt
17:43:33 <mauke> Baughn: ^C doesn't work in some cases
17:43:34 <toast-opt> baughn, that's causing ghci to exit on my box
17:43:39 <Veinor> ah, it uses properties of the natural numbers
17:43:48 <mauke> and by "doesn't work" I mean "has no effect"
17:43:49 <Baughn> Veinor: It's an unary coding, IIUC
17:43:50 <eugenn> > (0 + undefined :: Natural) > 0
17:43:52 <lambdabot>   * Exception: Prelude.undefined
17:44:00 <eugenn> > (0 + undefined :: Natural) > (-2)
17:44:02 <lambdabot>   * Exception: Prelude.undefined
17:44:09 <mauke> > -2 :: Natural
17:44:11 <lambdabot>   * Exception: Natural: (-)
17:44:20 <Baughn> eugenn: There are no negative naturals
17:44:23 <MoALTz> > 0 ^ undefined
17:44:24 <lambdabot>   * Exception: Prelude.undefined
17:44:36 <MoALTz> @src ^
17:44:37 <lambdabot> x ^ 0            =  1
17:44:37 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
17:44:37 <lambdabot>   where f _ 0 y = y
17:44:37 <lambdabot>         f x n y = g x n
17:44:37 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
17:44:39 <lambdabot>                       | otherwise = f x (n-1) (x*y)
17:44:41 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
17:44:45 <MoALTz> > undefined ^ 0
17:44:47 <lambdabot>   1
17:45:09 <Veinor> > heh, it uses recursive squareing for ^
17:45:11 <lambdabot>   <no location info>: parse error on input `,'
17:45:15 <Veinor> whoops
17:45:20 <Veinor> dunno how that > got in there
17:45:30 <eugenn> > undefined / undefined
17:45:31 <lambdabot>   * Exception: Prelude.undefined
17:47:16 <eugenn> > 5**(-1)
17:47:17 <lambdabot>   0.2
17:47:26 <eugenn> > 5^(-1)
17:47:28 <lambdabot>   * Exception: Negative exponent
17:47:37 <mauke> > 5 ^^ (-1)
17:47:38 <lambdabot>   0.2
17:47:57 <eugenn> >(-1)**(1/2)
17:48:06 <eugenn> > (-1)**(1/2)
17:48:08 <lambdabot>   NaN
17:48:13 <mauke> > (-1) ** 0.5 :: Complex Double
17:48:15 <lambdabot>   6.123233995736766e-17 :+ (-1.0)
17:48:49 <eugenn> > sqrt (-1)
17:48:51 <lambdabot>   NaN
17:49:03 <MoALTz> > False && undefined
17:49:05 <lambdabot>   False
17:49:08 <eugenn> > sqrt (-1) :: Complex
17:49:09 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
17:49:10 <lambdabot>  Expected ki...
17:49:12 <MoALTz> > undefined && False
17:49:13 <lambdabot>   * Exception: Prelude.undefined
17:49:17 <Veinor> > .3 + .3 + .3 + .1 == 1.0
17:49:19 <lambdabot>   <no location info>: parse error on input `.'
17:49:22 <Gracenotes> :: Complex Double
17:49:23 <Veinor> ... d'oh
17:49:32 <Veinor> > 0.3 + 0.3 + 0.3 + 0.1 == 1.0
17:49:33 <lambdabot>   False
17:49:36 <Veinor> hooray!
17:49:46 <mauke> > 0.3 + 0.3 + 0.3 + 0.1 == (1.0 :: Rational)
17:49:47 <eugenn> ?? what the
17:49:49 <lambdabot>   True
17:49:49 <lambdabot>  what the
17:49:56 <papna> MoALTz, Scandalous! Haskell must be lazy or something.
17:49:58 <MoALTz> > (0.5 - 0.2) == (0.6 - 0.3)
17:49:59 <chrisdone> spent hours thinking my code was broken because I forgot to re-comment out a line that I commented out and then undo'd without noticing
17:49:59 <Gracenotes> > sqrt (-1) :: Complex Double
17:50:00 <lambdabot>   True
17:50:00 <lambdabot>   (-0.0) :+ 1.0
17:50:02 <chrisdone> ~ _ ~
17:50:15 <Gracenotes> = -0 + i. interesting about the former
17:50:24 <eugenn> > 0.9 + 0.1 == 1
17:50:26 <lambdabot>   True
17:50:38 <Veinor> eugenn: floating point math
17:50:41 <eugenn> > 0.6 + 0.3 + 0.1 == 1
17:50:43 <lambdabot>   False
17:50:44 <MoALTz> yep
17:50:51 <Veinor> you will learn to hate it
17:50:54 <Gracenotes> .1 can't be properly represented in binary. only something close to it
17:51:02 <Veinor> > 0.5 + 0.5 == 1
17:51:03 <lambdabot>   True
17:51:05 <mauke> preflex: calc '2 0.1
17:51:05 <preflex>  0.00011001100110011001100110011001100110011001100110011
17:51:06 <Veinor> > 0.6 + 0.4 == 1
17:51:08 <lambdabot>   True
17:51:10 <Veinor> heh
17:51:11 <Gracenotes> > 0.3 + 0.3 + 0.3 + 0.1 == (1.0 :: CReal) --  <- this is pretty exact
17:51:12 <lambdabot>   True
17:51:37 <Draconx> mauke, wow, that (-1) ** 0.5 is /really/ inaccurate.
17:52:13 <eugenn> > 2 +: i + 3 +: i
17:52:14 <lambdabot>   Not in scope: `+:'Not in scope: `+:'
17:52:25 <Veinor> > 2 :+ 1 + 3 :+ 1
17:52:27 <lambdabot>   Precedence parsing error
17:52:27 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `G...
17:52:35 <Veinor> > 2 :+ 1 :+ 3 :+ 1
17:52:37 <lambdabot>   Precedence parsing error
17:52:37 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `D...
17:52:39 <eugenn> > 2 :+ i + 3 :+ i
17:52:40 <Veinor> ... :/
17:52:41 <lambdabot>   Precedence parsing error
17:52:41 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `G...
17:53:05 <eugenn> > (2 :+ i) + (3 :+ i)
17:53:06 <lambdabot>   No instance for (GHC.Float.RealFloat SimpleReflect.Expr)
17:53:07 <lambdabot>    arising from a ...
17:53:25 <Veinor> > let x = 1 :+ 1; y = 1 :+ 1 in x + y
17:53:27 <lambdabot>   2.0 :+ 2.0
17:53:33 <mauke> > (2 :+ 1) + (3 :+ 1)
17:53:36 <lambdabot>   5.0 :+ 2.0
17:53:39 <Veinor> or that, yes
17:54:53 <MarcWeber> Lemmih: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13276#a13276 I copied this from another packgae. I don't have base < 3 so I didn't test that configuration
17:55:01 <eugenn> > (9^9^9^9^9)/(9^9^9^9^9)
17:55:07 <lambdabot>   mueval: ExitFailure 1
17:55:14 <Veinor> hehe
17:55:22 <Veinor> > (9^9^9) / (9^9^9)
17:55:23 <lambdabot>   NaN
17:55:28 <Veinor> > (9^9^9)
17:55:34 <lambdabot>   mueval: ExitFailure 1
17:55:45 <MoALTz> heh
17:55:57 <eugenn> > 9^9
17:55:58 <lambdabot>   387420489
17:56:01 <MoALTz> how does that get a NaN?
17:56:13 <Draconx> infinity / infinity is NaN.
17:56:29 <MoALTz> Draconx: ahh yes, because it will be Floating
17:57:14 <Draconx> > 9^9^9 :: Double
17:57:15 <lambdabot>   Infinity
17:57:28 <eugenn> It would be good to implement a division operation that attemps to cancel factors fisrt
17:57:51 <aavogt> you can store numbers factorized
17:58:09 <Draconx> eugenn, if you go through Rational first, it will probably work.
17:58:19 <eugenn> so that (9^9^9^9^9)/(9^9^9^9^9) would work
17:58:22 * aavogt wonders if that makes division heavy RationalS quicker
17:59:21 <roconnor> eugenn: that has a lot of factors.
17:59:22 <MoALTz> it would be interesting if you could get (/) to gobble functions with (a -> a) (say, (9^))
18:00:14 <eugenn> It should just see that I'm dividing two identical numbers without calculations
18:00:15 <roconnor> eugenn: in general factorization is much harder than division.
18:00:52 <Draconx> eugenn, except it would need to compute 9^9^9^9^9 to see that, unless you want it to compare syntax.
18:01:14 <MoALTz> isn't this related to the forbidding of   f x x = ...  patterns?
18:01:59 <eugenn> For a first try, take the numerator as a string, take the denominator as a string, compare, if equal then return 1 else do the divition
18:02:28 <Draconx> eugenn, okay, so now what about (9^9^9^9^(4+5))/(9^9^9^9^9) ?
18:02:37 <byorgey> eugenn: you could definitely imagine a numeric type that retains numeric expressions as an AST and tries very hard to simplify things without explicitly calculating it until absolutely necessary.
18:02:48 <byorgey> eugenn: but that would in many cases be a pessimization.
18:03:04 <eugenn> That's why I said "for a first try". That would be solved in a second try :P
18:03:13 <Draconx> I can keep going, if you'd like :P
18:03:20 <byorgey> eugenn: heh, there's a big gap between those two tries =)
18:03:31 <eugenn> hehe that's right
18:04:54 <eugenn> > 34%34
18:04:55 <lambdabot>   1 % 1
18:05:15 <eugenn> > (34+1)%(34+1)
18:05:32 <lambdabot>   1 % 1
18:05:54 <eugenn> > (9^9^9)%(9^9^9)
18:05:59 <lambdabot>   mueval: ExitFailure 1
18:06:49 <Draconx> 9^9^9 is a really, really big number :P
18:07:45 <eugenn> is there an expression I can tell to lambdabot so that it will show me the biggest number it can show?
18:08:03 <eugenn> > 9e15
18:08:05 <lambdabot>   9.0e15
18:08:14 <ddarius> The issue is running out of time.
18:08:21 <osaunders> Hi Guys. I'm using Anki to create a deck of flashcards on Haskell (for learning purposes).
18:08:29 <poe> > (9^9)^9/(9^9)^9
18:08:31 <lambdabot>   1.0
18:08:48 <osaunders> I remember watching a video lecture on lazy data structures and the guy used this visual metaphor with tubes and string. Do you know what I'm talking about?
18:09:43 <osaunders> He pulls the string (data) through the tubes (functions) showing how only as much data as is requested by the last is evaluated.
18:10:08 <eugenn> > 9^(9^9)/9^(9^9)
18:10:10 <lambdabot>   NaN
18:10:13 <osaunders> Anyway, I'm wondering is this has a name or is known commonly by something?
18:10:34 <aavogt> lazy evaluation
18:10:46 <mmorrow> , (pi**pi)/(10^100000000-1) :: MPFR
18:10:47 <lunabot>  3.645663029598785e-99999999
18:10:53 <osaunders> No, a name for the metaphor.
18:11:22 <ddarius> osaunders: You're making flashcards to learn a programming language?
18:11:45 <osaunders> ddarius: Yeah, using spaced repetition (google that).
18:11:56 <ddarius> osaunders: I know what that is.
18:12:05 <osaunders> ddarius: Cool.
18:12:17 <ddarius> I'm not even sure what I would put on flashcards for a programming language...
18:12:46 <kmc> pipeline?
18:12:47 <osaunders> I've done about 10 cards so far and it hasn't been difficult.
18:12:56 <osaunders> kmc: Oh, that's quite nice
18:12:57 <Draconx> ddarius, for Haskell, one could put functions on one side and types on the other.
18:13:20 <ddarius> Draconx: That doesn't seem like it would be useful for me.
18:13:40 <Draconx> I don't think it would be useful for me either, but that doesn't mean it's not useful for someone.
18:13:52 <osaunders> ddarius: I'm using Learn You a Haskell as a reference.
18:15:06 <osaunders> Is Haskell call by value always?
18:15:17 <ddarius> To learn a programming language, I'd just program in it.  That seems a lot more holistic, and practical, and rewarding than random factoids...
18:15:19 <ddarius> osaunders: No.
18:15:26 <ddarius> It's never call-by-value.
18:15:55 <osaunders> Well, sure I'll program in it too.
18:16:04 <Draconx> osaunders, "call by need"
18:16:15 <osaunders> Nice.
18:16:26 <osaunders> I'll make that into a card.
18:16:44 <osaunders> ddarius: Think of it as an experiment, I am.
18:17:57 <osaunders> Do you ever have anything resembling an object is HS?
18:18:34 <osaunders> By which I mean, is call-by-reference purely an optimization or can you take advantage of that semantic?
18:18:50 <osaunders> I'm guessing the answer is no.
18:19:00 <ddarius> You can't do reference equality.
18:19:46 <ddarius> osaunders: So, yes, the answer is no.
18:19:58 <osaunders> Yeah.
18:20:11 <osaunders> I think the real reason why the answer is no is that you can't have any state.
18:20:37 <osaunders> The whole usefulness of call-by-ref in OOP langs hinges on that, as far as my thought process can tell.
18:21:48 <kmc> "call by reference"?
18:22:02 <kmc> i don't see how that's different from "call by value, where the value is a reference"
18:22:37 <poe> osaunders the state as can be done http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
18:22:58 <osaunders> kmc: Yes, I agree. I'm pretty sure the difference becomes academic at that point.
18:23:14 <kmc> then let's not invent new call semantics where we don't have to
18:23:15 * osaunders follows the link
18:23:18 <toast-opt> isn't it really 'call by need'?  or did someone say that already
18:23:21 <kmc> as always, i blame C++
18:23:40 <kmc> osaunders, people mean different things by OO objects.  haskell has features similar to most of them, though they're not lumped together into a single umbrella concept
18:23:53 <papna> toast-opt, Someone said that, but it's hard to see how that can really be dropped in as an answer to the question.
18:24:00 <ddarius> toast-opt: It's not specified.
18:24:21 <papna> The that the question does not make sense in the context of Haskell.
18:24:24 <kmc> you could mean: code/data bundling, encapsulation, code resue, closure over state, polymorphism, interface subtyping, ...
18:24:30 <ddarius> kmc: In call-by-reference, the reference aspect is implicit.
18:24:49 <toast-opt> ddarius, as in, evaluation order is unobservable?
18:24:53 <ddarius> kmc: It's C++'s, void foo(int &x) v. void foo(int *x)
18:24:56 <toast-opt> (except for compute time)
18:25:06 <kmc> yeah, i consider that call-by-value in both cases
18:25:10 <kmc> just with terrible nonlocal syntax
18:25:28 <kmc> though refs in C++ aren't quite first-class
18:25:44 <ddarius> toast-opt: As in sharing is unobservable.  The evaluation is non-strict, but it can be call-by-name, call-by-need, or something else which provides non-strict semantics.
18:25:55 <ddarius> kmc: Most people won't agree with you.
18:26:12 <ddarius> kmc: C#/Java also have similar implicit but observable differences.
18:26:16 <toast-opt> ddarius, i'd think a lot of haskell code would be useless if it was entirely call-by-need
18:26:17 <osaunders> C++ refs are a distinct type aren't they?
18:26:23 <toast-opt> you want _some_ caching at least
18:26:49 <Draconx> toast-opt, call by need is call by name plus memoization.
18:26:50 <ddarius> osaunders: In C++ I can write: int x = 3; foo(x) for the former and the address of x will be passed, not its value.
18:27:12 <toast-opt> draconx, yes.  i know.
18:27:13 <kmc> in Java there are no object types, only reference-to-object types
18:27:26 <Draconx> toast-opt, then your statement about caching makes no sense.
18:27:31 <osaunders> ddarius: Oh right, then that's definitely call-by-refence (for that function)
18:27:35 <dibblego> and 8 primitives
18:27:43 <toast-opt> draconx, ah, you're right.  typo.  i meant it would be useless if all call by name
18:27:48 <toast-opt> too much recomputing same values
18:27:55 <kmc> well semantically it doesn't pass the reference either
18:27:59 <kmc> doesn't pass the address, i mean
18:27:59 <toast-opt> some things might not terminate
18:28:14 <Draconx> toast-opt, ah, ok.
18:28:24 <ddarius> toast-opt: In a pure language, recomputation won't cause things to not terminate.
18:28:36 <osaunders> toast-opt: The whole design of the language would have to change probably.
18:28:39 <toast-opt> draconx, i always have a tough time keeping the names straight, because they don't mean anything to me
18:29:21 <toast-opt> ddarius, well, not non-terminating.  just not in reasonable time.  O(n) algorithms becoming O(2^n) and worse
18:29:27 <osaunders> Oh if I enter cycle [1,2,3] into GHCi is there any way I can get it to stop without terminating the program?
18:29:46 <kmc> ^C
18:29:48 <ddarius> osaunders: If Ctrl-C doesn't do it, then no.
18:29:58 <osaunders> OK.
18:30:20 <osaunders> ^C didn't work for me last time.
18:30:53 <toast-opt> fib x = (fix (\a -> 0 : 1 : (zipWith (+) a $ tail a))) !! x -- becomes exponential time under call-by-name
18:31:34 <ddarius> toast-opt: Call-by-need can lead to exponential memory usage (v. call-by-name) in some cases (which is often worse than exponential time)
18:32:05 <toast-opt> ddarius - exponential in space necessitates exponential in time, so how is it 'worse than'?
18:32:46 <toast-opt> i guess technically O(1) space and O(2^n) time is *technically* better, if space is the bounds you hit first
18:33:19 <toast-opt> i guess it depends on the application
18:33:23 <ddarius> toast-opt: Residence v. total allocation.
18:33:32 <Cale> osaunders: Ctrl-C really ought to work though...
18:34:00 <toast-opt> ddarius - does haskell ever consume space faster than time?
18:34:08 <osaunders> Cale: I held that mofo down and it didn't work. :-(
18:34:11 <toast-opt> pure functional code i mean
18:34:22 <Cale> Does anything ever consume space faster than time?
18:34:34 <ddarius> toast-opt: It's trivial to do that in almost any language.  It's actually doing something with that space that will slow things down.
18:34:37 <monochrom> the big bang did
18:34:42 <toast-opt> cale - yes.  malloc(n) will typically be O(1) under some allocators
18:35:13 <Cale> Ah, I suppose you can allocate memory in that sense faster than you use it.
18:35:31 <toast-opt> for (int i = 0; i < x; ++i) malloc(i*i); -- O(x) time, O(x^2) space
18:36:00 <Cale> But malloc is strange in that regard.
18:36:06 <toast-opt> or malloc(x*x); // for O(x^3) space :)
18:36:18 <monochrom> haskell98 doesn't have malloc(n)
18:36:18 <toast-opt> but that's only where space is mutable
18:36:47 <toast-opt> if i'm consing up lists in pure (not IO monad) haskell, then it doesn't actually allocate any particular node until you observe it, right?
18:37:14 <Cale> toast-opt: Well... depends, but sort of.
18:37:54 <osaunders> Cale: Can you say more?
18:38:05 <Cale> It evaluates expressions outermost first, and most lists will typically be unevaluated expressions until you pattern match on them, that is, unless you defined them with (:) directly.
18:38:40 <Cale> So, suppose you write  map (2^) [1..5]
18:38:54 <Cale> that will just sit there like that until a case comes along and pattern matches on it
18:39:13 <Cale> case map (2^) [1..5] of [] -> foo; (x:xs) -> bar
18:39:50 <Cale> at this point, the map will want to evaluate, but map needs to pattern match on its second parameter according to its definition
18:39:53 <Cale> @src map
18:39:54 <lambdabot> map _ []     = []
18:39:55 <lambdabot> map f (x:xs) = f x : map f xs
18:40:03 <adu> hi Cale
18:40:11 <Cale> So that'll get put on the stack and the [1..5] will evaluate
18:40:16 <Cale> To 1 : [2..5]
18:40:30 <Cale> at which point the map will be able to match x = 1, xs = [2..5]
18:40:52 <monochrom> oops, perhaps haskell98 includes the ffi, which has malloc(n).
18:41:03 <Cale> and the result will be case (2^) 1 : map (2^) [2..5] of [] -> foo; (x:xs) -> bar
18:41:20 <Cale> and that matches, and we produce bar without doing any further evaluation
18:42:13 <Cale> You should almost always think of evaluation of Haskell code as transformation of expressions or expression-graphs.
18:42:22 <adu> pattern match this! (_ : _)
18:42:26 <Cale> Lower level details of how it works are rarely actually useful.
18:43:04 <Cale> (In particular, I don't much care for the words thunk or closure)
18:43:18 <monochrom> lower level details are observationally equivalent to the expression-graph view anyway. including asymptotic time and memory.
18:43:29 <osaunders> Cale: If you define an observation as a pattern match doesn't all that make the answer to toast-opt question yes?
18:44:29 <adu> if lowlevel details don't matter, why do so many language make such a bleak distinction between lists and arrays?
18:44:50 <ddarius> adu: Because those have rather different asymptotics.
18:44:58 <kmc> well, the expression-graph view of a haskell list and a haskell array are vastly different
18:45:29 <osaunders> adu: That's not a detail about evaluation strategy that's a detail about an important data structure.
18:45:41 <monochrom> list-vs-array is another kind of "low level detail" disjoint from this discussion.
18:47:01 <monochrom> It's like there is an English literature prof named Cale and you think he's the Cale here.
18:47:31 <adu> no its not like that at all
18:47:53 <monochrom> They are both named "low level detail" and you mix them up.
18:48:08 <kmc> @quote detail
18:48:10 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
18:48:10 * ddarius doesn't consider the asymptotics of data structures "low level details"
18:48:20 <kmc> @quote detail
18:48:22 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
18:48:44 <osaunders> ddarius: I think they are low level details, just important ones.
18:48:57 <osaunders> Low level details of evaluation aren't important.
18:49:06 <adu> sure they are
18:49:10 <osaunders> (If Cale is correct)
18:49:14 <monochrom> There is no absolute "low" or "high" anyway. Just relative "x is lower than y".
18:49:29 <osaunders> monochrom: Sure.
18:49:54 <osaunders> Perhaps we should say: Not of routine concern instead of unimportant.
18:49:57 <ddarius> osaunders: "Low level details" that changed asymptotic behavior would be important to me and those readily exist.
18:50:12 <adu> If A is a cyclic list and B = unsafeLaunchMissiles, then I would think order of evaluation is very important
18:50:37 <osaunders> OK you're going to have to explain that word to me. I already looked it up and I still don't understand.
18:51:05 <osaunders> I'm referring to "asymptotic".
18:51:14 <ddarius> Big O
18:51:15 <monochrom> which word? "asymptotic"? It means those big-O and big-Theta thingies.
18:51:30 <Cale> Arrays and lists are very different, even at this level.
18:51:41 <adu> my favorite asymptotic: O(1)
18:51:47 <Axman6> what is Big-Theta about anyway?
18:52:01 <Cale> There are a lot of operations which claim to be O(1), but which would never scale like that.
18:52:07 <monochrom> Theta is what you should use instead of O.
18:52:08 <Cale> For example, array access.
18:52:11 <ddarius> Axman6: O is an upper bound, Theta is a tight bound.
18:52:22 <Axman6> tight meaning what?
18:52:24 <Draconx> Axman6, Œò(f) means both O(f) and Œ©(f)
18:52:30 <ddarius> Axman6: Upper and lower.
18:52:34 <adu> as in LUB?
18:52:34 <Axman6> ah
18:52:40 <skorpan> 8 year olds man...
18:52:45 <ddarius> Axman6: So I can say array access is O(n^3) and be correct.
18:52:46 <Axman6> Draconx: and Omega is?
18:53:15 <Axman6> ddarius: big-theta wouldn't apply to some situations right?
18:53:30 <Cale> It's a bit unrealistic to say that accessing an arbitrary element of a structure with n elements of it can be done in an amount of time constant in n.
18:53:33 <monochrom> "sorting is O(n log n)" actually tells you nothing, for "linear search is O(n log n)" is also correct. You should say "sorting is Theta(n log n), linear search is Theta(n)", that will be a correct and informative statement.
18:54:06 <ddarius> monochrom: But matrix multiplication is Theta(n^3) would be incorrect.
18:54:31 <EvanCarroll> where can i read about maybe and just?
18:54:35 <EvanCarroll> Maybe / Just
18:54:43 * Axman6 has been told that smart matrix multiplication is O(n^2.something) before
18:54:50 <adu> EvanCarroll: GHC docs
18:55:07 <Axman6> EvanCarroll: there's not much to read about Maybe/Just/Nothing
18:55:11 <Cale> EvanCarroll: There's not all that much to say about Maybe. If you understand data declarations, then most of what there is to say is:  data Maybe a = Nothing | Just a
18:55:30 <monochrom> Fine, but if you have a specific algorithm and know its complexity, you should say Theta.
18:55:32 <Gracenotes> heh, I was wondering why http://hgbook.red-bean.com/read/ looked so much like RWH's site. Then I realized who the author was :)
18:55:47 <Cale> That is, a value of type Maybe t is either the value Nothing, or it is a value of the form Just x where x :: t
18:55:49 <ddarius> monochrom: Most of the time people do mean Theta, agreed.
18:55:58 <kmc> EvanCarroll, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
18:56:07 <monochrom> O should be used only when you really need its leeway.
18:56:14 <Cale> Examples of values of type Maybe Integer include:  Just 6, Nothing, Just (-12), and so on.
18:56:31 <ddarius> > Just (Just id)
18:56:33 <Cale> EvanCarroll: Make sense?
18:56:33 <lambdabot>   Just (Just {()->()})
18:56:56 <monochrom> Yes, it's really like going into #math and giving answers like "5+3 <= 8".
18:57:40 <ddarius> monochrom: I'll start saying 5+3 <= 8 and 8 <= 5+3.  Let's teach arithmetic and antisymmetry.
18:58:37 <Gracenotes> of course, the abuse of big O notation by computer scientists knows no bounds (it is Œ©(sane))
18:58:38 <adu> EvanCarroll: do you understand data decls?
18:59:11 <Gracenotes> so O(f(n)) tends to be used to describe the theta running time in the context of a specific algorithm :)
18:59:14 <EvanCarroll> adu: nope
18:59:35 <EvanCarroll> Cale: I was reading the RWH and i found them without /any/ real introduction
18:59:35 <poe> I agree with monochrom, many times in analysis one goes away unhappy with an inequality which gives one only partial information. That's reason enough for some to prefer algebra!
18:59:45 <monochrom> So, expression graph and STG tell you the same asymtotic answers for time and memory, but expression graph is simpler, so you should try it first, unless you want to pin down the constant multiple.
18:59:55 <EvanCarroll> isn't Just the default?
18:59:56 <Cale> EvanCarroll: Does my explanation of what that data declaration means make some kind of sense?
19:00:02 <Cale> EvanCarroll: "default"?
19:00:30 <Cale> EvanCarroll: There is no default. If you want to make a value of type Maybe t, you have to use Nothing or Just
19:00:39 <Cale> Just like if you want to make a list, you have to use [] or (:)
19:00:59 <monochrom> (but then benchmarking with ghc gives you an even more accurate answer than STG and is also less work. :) )
19:01:23 <osaunders> Is there a "wordy" version of the [n..n] syntax? I already tried range.
19:01:27 <ddarius> monochrom: Benchmarking has noise and doesn't tell you how things vary.
19:01:35 <Cale> :t enumFromTo
19:01:35 <ddarius> enumFromTo
19:01:38 <lambdabot> forall a. (Enum a) => a -> a -> [a]
19:01:43 <Cale> :t enumFromThenTo
19:01:45 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
19:01:48 <Cale> :t enumFrom
19:01:50 <lambdabot> forall a. (Enum a) => a -> [a]
19:02:07 <Cale> :t enumFromThen
19:02:09 <lambdabot> forall a. (Enum a) => a -> a -> [a]
19:03:06 <osaunders> Thanks.
19:03:08 <adu> EvanCarroll:  do you know C?
19:03:12 <EvanCarroll> adu: a little
19:03:48 <adu> EvanCarroll: data X = X1 | X2 | X3 | X4; is like enum {X1, X2, X3, X4}
19:04:18 <adu> EvanCarroll: and data X = X1 T1 T2 T3 T4; is like struct {T1; T2; T3; T4}
19:04:56 <osaunders> Are the values in lists typically referred to as elements or items in Haskell nomenclature?
19:05:34 <monochrom> I call them items. People call them elements.
19:05:43 <adu> I call them items
19:05:52 <Optimality> "thingys"
19:06:28 <kmc> osaunders, Data.List documentation uses "element"
19:06:34 <EvanCarroll> I think I need to just find out more about these things
19:06:50 <Gracenotes> er. I might consider data X = X1 | X2 | ... a bit closer to type union {int tag; X1 x1; X2 x2; ...} X, where typedef struct {} X1; typedef struct {} X2, etc.
19:06:50 <EvanCarroll> I don't understand what Nothing does
19:06:52 <EvanCarroll> or Just
19:06:59 <osaunders> kmc: TY.
19:07:01 <monochrom> Nothing does nothing.
19:07:05 <EvanCarroll> and defining Maybe in reference to them, isn't much
19:07:05 <kmc> EvanCarroll, you need to understand "data" declarations first
19:07:13 <kmc> EvanCarroll, that statement *defines* Nothing and Just
19:07:16 <kmc> @src Maybe
19:07:18 <lambdabot> data Maybe a = Nothing | Just a
19:07:27 <kmc> EvanCarroll, that ^^^ introduces *three* names: Maybe, Nothing, Just
19:07:30 <monochrom> Just does nothing too.
19:07:34 <adu> EvanCarroll: ok, see my examples above? the X1 | X2 | X3 are all constructors, now that name is a little misleading because they don't DO anything, they just label the kind of data they contain
19:07:53 <kmc> Maybe is in the type namespace; Nothing and Just are in the value namespace
19:08:05 <monochrom> Nothing does nothing. Just just sits there.
19:08:33 <adu> EvanCarroll: "Nothing" and "Just" are not defined before hand. the expression "data Maybe a = Nothing | Just a" defines "Maybe" , "Just" and "Nothing" all at the same time.
19:09:02 <adu> just like "data Bool = False | True" defines "Bool" "False", and "True"
19:09:08 <monochrom> If you came from C, you may be unaware that there are better ways to do union types.
19:10:05 <kmc> EvanCarroll, the meaning of that "data" declaration is: define a new type "Maybe a" for every type a.  you can build a value of type "Maybe a" in two ways (those are separated by |).  "Nothing" is such a value.  and "Just x" is, if x has type a
19:10:15 <Apocalisp> I've seen you guys typing UTF-8 symbols here before. How do you do that?
19:10:22 <adu> EvanCarroll: in C, the Maybe type would be implemented as follows:  NULL represents when something goes wrong, or Nothing, and (TYPE * object) represents the data you really want
19:10:27 <adu> or Just the data
19:10:27 * monochrom still hasn't started writing his "C for Haskell programmers" inverse-tutorial. :)
19:10:33 <kmc> let's not think of this in terms of C
19:10:37 <Apocalisp> I can't even paste them (just see ??)
19:10:38 <adu> so NULL = Nothing, and TYPE * x = Just x
19:10:54 <kmc> EvanCarroll, from that "data" definition we also get these two functions:
19:10:55 <kmc> :t Nothing
19:10:57 <kmc> :t Just
19:10:57 <lambdabot> forall a. Maybe a
19:10:58 <lambdabot> forall a. a -> Maybe a
19:11:03 <monochrom> Set your irc software and whatnot to use UTF-8. Minimum requirement.
19:11:06 <kmc> (okay, Nothing isn't a function)
19:11:17 <Gracenotes> :|
19:11:21 <kmc> > [Nothing, Just 'x', Just 'y']
19:11:21 <adu> Nothing is a function, but it takes no arguments
19:11:23 <lambdabot>   [Nothing,Just 'x',Just 'y']
19:11:31 <kmc> adu, a function always takes one argument
19:11:47 <Apocalisp> Nothing is isomorphic to const
19:11:50 <adu> kmc: then what do you call declarations in Haskell?
19:12:03 <kmc> adu, i don't see how they're related
19:12:10 <kmc> some function values don't have declarations
19:12:11 <EvanCarroll> does anyone have any tutorials detailing nothing/just/maybe?
19:12:11 <Gracenotes> a function takes one argument in the type system alone.
19:12:13 <Cale> adu: things with no parameters are pattern declarations, things with parameters are function declarations
19:12:14 <monochrom> And then I have many common symbols on http://www.vex.net/~trebla/symbols/select.html so you can try them.
19:12:17 <EvanCarroll> other than the shitty prelude thing
19:12:22 <kmc> EvanCarroll, you need to read about "algebraic data types"
19:12:27 <kmc> of which Maybe is a simple example
19:12:29 <Apocalisp> @let nothing = const
19:12:31 <lambdabot>  Defined.
19:12:32 <kmc> EvanCarroll, did the things i said above make sense?
19:12:36 <EvanCarroll> nope
19:12:37 <Gracenotes> :/
19:12:39 <Cale> EvanCarroll: Just use it for a while, you'll get used to it.
19:12:41 <kmc> what part didn't?
19:12:50 <EvanCarroll> all of it.
19:12:57 <Gracenotes> these are these sorts of things where you need concrete examples
19:12:57 <kmc> @src Maybe
19:12:59 <lambdabot> data Maybe a = Nothing | Just a
19:13:00 <adu> kmc: in SML you needed to put "val" in front of things with 0 parameters, and "fun" in front of things with more parameters, and in Haskell there is no difference, so what do you call both things?
19:13:04 <Cale> > zip [0..] (words "here is a bunch of words to pair with their indices")
19:13:06 <lambdabot>   [(0,"here"),(1,"is"),(2,"a"),(3,"bunch"),(4,"of"),(5,"words"),(6,"to"),(7,"...
19:13:08 <EvanCarroll> i've got the bot ignored
19:13:13 <Cale> > lookup 6 (zip [0..] (words "here is a bunch of words to pair with their indices"))
19:13:14 <kmc> adu, declarations?
19:13:15 <Apocalisp> @let just x z f = f x
19:13:15 <lambdabot>   Just "to"
19:13:16 <lambdabot>  Defined.
19:13:24 <Cale> EvanCarroll: ... why?
19:13:26 <adu> kmc: ok, good, we're on the same page
19:13:30 <osaunders> Do you think this question is well-worded / what is your answer? http://gist.github.com/244364
19:13:35 <Draconx> adu, actually, in SML you can define functions with "val", too.
19:13:36 <kmc> EvanCarroll, why?
19:13:57 <kmc> EvanCarroll, why would you come here asking for help and ignore our way of providing it?
19:14:04 <monochrom> You can use the logs url in the topic to recover what lambdabot said.
19:14:05 <osaunders> (I'm trying to test that people understand lazy-eval).
19:14:19 <Gracenotes> osaunders: depending on how the list is translated into STG, 5 elements, possibly
19:14:37 <EvanCarroll> kmc: because often it takes me 5minutes to digest what is going on and lamdabot accounts for probably 50% of this channels traffic
19:14:42 <EvanCarroll> it makes it harder to follow a conversation
19:14:47 <monochrom> strange question.
19:14:59 <Gracenotes> but one would expect 2 individual elements, and two constructors in total
19:15:00 <kmc> EvanCarroll, okay.  good luck
19:15:09 <EvanCarroll> I'll reread the RWH book on datatypes, I just dont remember seeing Just/Nothing/Maybe at all in there except in use
19:15:17 <Cale> osaunders: take 2 oneToFive -> take 2 [1..5] -> take 2 (1:[2..5]) -> 1 : take 1 [2..5] -> 1 : take 1 (2 : [3..5]) -> 1 : 2 : take 0 [3..5] -> 1 : 2 : []
19:15:18 <osaunders> Gracenotes: STG?
19:15:42 <monochrom> STG5 = star gate 5
19:15:45 <Cale> osaunders: does that help? :)
19:15:49 <adu> EvanCarroll: In order to understand datatypes in Haskell you only need to understand 2 symbols: space ' ' and bar '|'
19:15:54 <Gracenotes> Haskell's internal machine. But what monochrom said minly
19:16:07 <monochrom> No, STG is a model of what ghc does.
19:16:09 <EvanCarroll> adu: bar, defines a second value constructor
19:16:09 <adu> EvanCarroll: once you understand those two symbols you will have mastered datatypes
19:16:36 <osaunders> Cale: Yes. I understand the principle now. I'm also trying to ask a question that is good.
19:16:39 <Cale> osaunders: I was assuming of course that we're completely evaluating the take 2 oneToFive in order to display it.
19:16:41 <adu> EvanCarroll: yes
19:16:44 <kmc> adu, a declaration brings zero or more names into scope.  some of them might be bound to function values
19:16:57 <Cale> osaunders: The take 2 oneToFive might actually never get evaluated at all in another context.
19:17:12 <Cale> osaunders: Or if it's evaluated, the evaluation might stop at 1 : take 1 [2..5]
19:17:24 <osaunders> Cale: Yes, that is possibly a problem with the question.
19:17:33 <osaunders> Hm.
19:17:41 <Cale> You have to say what form you want the expression evaluated into.
19:17:46 <adu> EvanCarroll: so what does ' ' mean?
19:17:51 <osaunders> Should I say assuming this is typed into GCHi or something?
19:17:54 <Cale> So, I gave the normal form reduction.
19:17:57 <kmc> adu, there are function bindings and pattern bindings (report 4.4.3.1 and 4.4.3.2 resp).  but you can bind a name to a function value using a pattern binding
19:17:59 <Gracenotes> osaunders: perhaps say that you're printing it
19:18:03 <monochrom> "construct list/cells in order to call" is strange. things happen the other way round. call in order to construct list/cells.
19:18:20 <Gracenotes> printing means that it gets evaluated, if it's just a list of things-that-must-be-evaluated-to-print :)
19:18:28 <Cale> and 1 : take 1 [2..5] would be the weak head normal form (which is basically: do enough evaluation to determine the top-level constructor, and don't evaluate underneath a lambda)
19:18:47 <EvanCarroll> adu: not sure guessing seperates value const name, from value constructor arguments, and other arguments
19:19:14 <Cale> osaunders: WHNF is the smallest positive amount of evaluation which can be done to an expression using GHC.
19:19:19 <adu> no, ' ' just means struct or tuple or Cartesian product
19:19:36 <Gracenotes> ' ' could also denote insignificant whitespace
19:19:50 <adu> so Rect Int Int Int Int means a constructor that contains 4 integers, for x/y/w/h
19:19:56 <Cale> osaunders: And it's also the least amount of evaluation which you'd ever need to do in order to determine which branch of a case expression matches.
19:20:02 <EvanCarroll> isn't that what I just said.
19:20:14 <EvanCarroll> seperates value constructor arguments from other arguments
19:20:21 <EvanCarroll> and from the const name
19:20:36 <osaunders> Cale: What does it stand for?
19:20:42 <adu> EvanCarroll: no, you said arguments, those are not arguments those are being contained by the constructor, they don't go anywhere
19:20:44 <djwonk> i'm trying to find a 'getting started' example for 'haha' the ascii art library but google is utterly perplexed by the 'haha' expression
19:20:46 <monochrom> I haven't heard of "const" as an abbreivation for "constructor". I have only heard of it as "constant".
19:20:54 <Cale> osaunders: Weak head normal form
19:21:02 <EvanCarroll> ah I should have said attributes i suppose
19:21:17 <adu> EvanCarroll: hehe, terminology
19:21:18 <osaunders> Ah, nice.
19:21:50 <EvanCarroll> Is the positional data constructo ever preferred to the record-constructor
19:21:51 <EvanCarroll> ?
19:22:04 <Cale> osaunders: To explain the 'weak' by contrast, head normal form will go digging inside of an unapplied lambda, which is something that GHC will never do. For instance (\x -> 3 + 4) is already in whnf, but the hnf would be (\x -> 7)
19:22:11 <monochrom> Yes when there are only two or three attributes.
19:22:39 <adu> EvanCarroll: oh, like "Rect { x :: Int, y :: Int, width :: Int, height :: Int }"?
19:22:40 <EvanCarroll> fair enoug lol
19:22:44 <EvanCarroll> adu: yar
19:22:49 <EvanCarroll> enough*
19:22:57 <adu> yar?
19:23:06 <monochrom> Ja!
19:23:06 <osaunders> Cale: OK, i'm going to try and phrase all this as a flash card question now. :-S
19:23:09 <Apocalisp> @yarr
19:23:09 <lambdabot> Prepare to be boarded!
19:23:15 <adu> lol
19:23:17 <Gracenotes> EvanCarroll: anyhow, here's a random example, if it helps. safeDivide :: Int -> Int -> Maybe Int; safeDivide x 0 = Nothing; safeDivide x y = div x y. And to use that: do { first <- readLn; second <- readLn; print (case safeDivide first second of { Nothing -> "Tried to divide by zero!"; Just x -> "The result is "++x }) }
19:23:43 <Gracenotes> Nothing is here used to indicate that a result doesn't exist, because if you did 'div 1 0', Haskell would asplode on you
19:24:11 <adu> assplode?
19:24:12 <EvanCarroll> why not error "division by 0"
19:24:14 <ddarius> > div 1 0
19:24:16 <lambdabot>   * Exception: divide by zero
19:24:31 <kmc> the abbreviation for "constructor" is "ctor"
19:24:31 <EvanCarroll> safeDivide _ 0 = error "division by 0"
19:24:41 <Gracenotes> EvanCarroll: then it wouldn't be safe :)
19:24:49 <EvanCarroll> ah!
19:25:10 <EvanCarroll> so there is no way to catch errors because of the pureness, so you can return nothing, and have a mechanism to handle them?
19:25:18 <Gracenotes> similarly, you could make: safeHead [] = Nothing; safeHead (x:xs) = Just x.
19:25:37 <Gracenotes> (this is also called Data.Maybe.listToMaybe)
19:25:50 <Cale> EvanCarroll: yeah
19:26:00 <EvanCarroll> that makes sense, kinda.
19:26:00 <Gracenotes> but.. error-handling is only one application of Maybe. a major one though
19:26:14 <Apocalisp> > let safeDiv _ 0 = Nothing; safeDiv x y = div x y in fmap (+1) (safeDiv 10 2)
19:26:16 <lambdabot>   No instance for (GHC.Real.Integral (Data.Maybe.Maybe a))
19:26:16 <lambdabot>    arising from a ...
19:26:19 <Cale> EvanCarroll: Normally you don't use 'error' unless you really want your program to die in the event that condition happens.
19:26:26 <Apocalisp> > let safeDiv _ 0 = Nothing; safeDiv x y = Just $ div x y in fmap (+1) (safeDiv 10 2)
19:26:28 <lambdabot>   Just 6
19:26:31 <EvanCarroll> So Maybe, permits you to return a, and Nothing?, such that Nothing is a catchable exception
19:26:33 <Apocalisp> > let safeDiv _ 0 = Nothing; safeDiv x y = Just $ div x y in fmap (+1) (safeDiv 10 0)
19:26:34 <lambdabot>   Nothing
19:26:45 <Cale> EvanCarroll: Just a and Nothing
19:26:47 <Gracenotes> the thing is, if you are using a Maybe, you have to check if it's Just or Nothing to continue. which means you have  specific case for Nothing and a specific case for Just
19:27:13 <Gracenotes> or you can use fmap/liftM, so you can apply a function to the result without knowing what it is
19:27:28 <EvanCarroll> what does Just do then? I mean if you just say (Num a) then what does Just a do?
19:27:29 <poe> and if you don't specify both cases you get something like error, unhandled patterns
19:27:41 <kmc> EvanCarroll, Num is a totally different kind of thing
19:27:45 <kmc> Just is just a function
19:27:47 <kmc> Just :: a -> Maybe a
19:28:02 <kmc> it "promotes" a value into the Maybe type
19:28:15 <kmc> you can also pattern match on it (because it's a constructor)
19:28:26 <kmc> i would show you some examples but you won't see them
19:28:26 <Cale> :t Just 6
19:28:28 <lambdabot> forall t. (Num t) => Maybe t
19:28:42 <kmc> Cale, he has lambdabot on ignore
19:28:44 <Cale> oh, right, you can't see that
19:28:48 <Cale> <lambdabot> forall t. (Num t) => Maybe t
19:28:51 <kmc> pretty terrible way to learn haskell imo
19:29:20 <Apocalisp> You make lambdabot sad.
19:29:43 <adu> EvanCarroll: you're making the "do" mistake again. Constructors do NOT do anything... they CONTAIN
19:30:08 <monochrom> they are part of values.
19:30:12 <kmc> adu, well they sort of "do"... they construct
19:30:23 <kmc> EvanCarroll, 3 is an Int.  (Just 3) is a Maybe Int
19:30:51 <EvanCarroll> hrm
19:30:53 <Gracenotes> Either is a type that exists along the same lines. Instead of having one value vs. no value, you can have one value vs. another value, possibly of different types. it's either one or the other, and you pattern match to see what it is.
19:31:07 <kmc> EvanCarroll, does that make sense?
19:31:13 <EvanCarroll> yes, more so than anything thus far.
19:31:19 <EvanCarroll> that doesn't sound like what Just would mean to do
19:31:24 <kmc> from the name?
19:31:34 <EvanCarroll> Just would imply your expressely saying you're not going to return Nothing
19:31:39 <dcoutts> could some people try this out and let me know if it's obviously broken:
19:31:39 <kmc> well yes it does mean that
19:31:40 <dcoutts> http://haskell.org/cabal/release/cabal-install-0.6.4/cabal-install-0.6.4.tar.gz
19:31:45 <kmc> because Nothing /= Just x, for all
19:31:46 <kmc> x
19:31:47 <dcoutts> if it's ok I'll upload to hackage
19:31:48 <EvanCarroll> which is what Maybe sounds like it is hinding it.
19:31:49 <Gracenotes> people have proposed cosmetic surgery to Maybe names
19:32:12 <EvanCarroll> kmc: that doesn't make sense.
19:32:16 <kmc> EvanCarroll, why not?
19:32:28 <kmc> unlike a regular function, a constructor like Just doesn't "compute" anything
19:32:32 <kmc> it couldn't evaluate to Nothing
19:32:42 <EvanCarroll> You just said Maybe permits you to return Nothing, and Just 3 is a Maybe Int, as compaired to 3 which is an Int
19:32:59 <kmc> yes.  "Just 3" is a value which is permitted to be Nothing, but isn't
19:33:17 <SamB_XP> lol
19:33:22 <adu> lol
19:33:24 <Apocalisp> that's a funny way of putting it
19:33:25 <kmc> that is, Just 3 and Nothing have the same type
19:33:28 <kmc> whereas 3 and Nothing do not
19:33:29 <Raevel> LoL
19:33:54 <Raevel> I'm pretty sure Nothing is permitted to be Nothing.
19:34:14 <EvanCarroll> I'm going to go back to looking for this to be described in one central place
19:34:16 <EvanCarroll> like the wiki
19:34:19 <Raevel> i also can't read
19:34:20 <EvanCarroll> Thanks for the effort though
19:34:23 <EvanCarroll> lol
19:34:32 <adu> EvanCarroll: another good example that might make more sense is "Either"
19:34:46 <kmc> EvanCarroll, i'm really not inclined to help as long as you're ignoring the bot
19:34:49 <kmc> you might consider changing that
19:34:59 <adu> "Maybe" can be thought of as a special case of "Either"
19:35:11 <kmc> oh great
19:35:27 <kmc> let's explain this concept by analogy to more complicated concepts
19:35:42 <Raevel> <3
19:35:48 <EvanCarroll> kmc: sorry, while I do appreciate your help, the bot is discouraging, I'm looking for a simple answer here, the bot provides code that I often can't understand and have read before, and obfuscates Cales muliparagraphs and highly clear explainations
19:35:49 <adu> I think Either makes more sense than Maybe
19:36:14 <Apocalisp> EvanCarroll: Not sure how far along you are. Do you understand types?
19:36:46 <poe> dcoutts fine here!
19:36:47 <kmc> EvanCarroll, http://learnyouahaskell.com/making-our-own-types-and-typeclasses
19:36:55 <dcoutts> poe: thanks!
19:36:55 <adu> Apocalisp: the general idea I've been getting is no, he doesn't
19:36:58 <EvanCarroll> Apocalisp: I think I have a fair understanding of the very basics
19:37:05 <osaunders_> Cale: This normal form has nothing to do with database normal form does it?
19:37:21 <pastah_rhymez> adu: consider maybe as being able to have null
19:37:25 <kmc> EvanCarroll, the idea is not to explain what Maybe is, but to explain how datatype declarations work
19:37:27 <EvanCarroll> I've read the first 70 pages of RWH, but I was throw off by Maybe: RWH says this
19:37:29 <pastah_rhymez> but in a nice, safe way
19:37:36 <kmc> then explaining Maybe is as simple as "data Maybe a = Nothing | Just a"
19:37:41 <adu> pastah_rhymez: I know Maybe and Either, I'm trying to explain them
19:37:50 <EvanCarroll> Maybe is a polymorphic or generic type. We give the Maybe type constructor a parameter to create a specific type, such as Maybe Int or Maybe [Bool].
19:38:04 <pastah_rhymez> adu: sorry, nevermind :)
19:38:05 <EvanCarroll> Which didn't say what it was actually doing
19:38:15 <kmc> EvanCarroll, I think LYAH explains it well
19:38:20 <Apocalisp> EvanCarroll: Right, so take just the type Bool.
19:38:23 <adu> EvanCarroll: because it isn't DOING anything
19:38:34 <Apocalisp> EvanCarroll: I'm pretty sure you understand Bool.
19:38:42 <EvanCarroll> kmc: I was reading LYAH until it got to folds, which it tried to explain and failed it took me probably 3 days to get a fair understanding of those
19:38:59 <EvanCarroll> Apocalisp: Yea, I'm pretty sure I understand Bool, and its two constructors True and False
19:39:10 <Vitaeviternus> Hello.
19:39:20 <Apocalisp> EvanCarroll: Right. Bool is defined as: data Bool = True | False
19:39:33 <EvanCarroll> an effective enum of sort
19:39:49 <adu> EvanCarroll: datatypes in Haskell don't DO, they construct, contain, and return.
19:39:52 <Vitaeviternus> This might seem weird, but is this a bad place to ask Scheme questions given that #scheme is dead silent?
19:39:56 <Apocalisp> It's precisely a type with two values (two constructors): True | False.
19:40:06 <adu> Vitaeviternus: yes
19:40:16 <EvanCarroll> adu: whatever, Maybe does in the constructor it is doing in my nomenclature =(
19:40:28 <SamB_XP> Vitaeviternus: try #haskell-blah ;-P
19:40:36 <Vitaeviternus> Thanks.
19:41:32 <Apocalisp> EvanCarroll: Now then... Maybe Bool is a type that has three values. Do you know what those are?
19:41:50 <EvanCarroll> True False and Nothing
19:41:54 <SamB_XP> Apocalisp: only 3?
19:41:54 <Apocalisp> Almost
19:41:55 <adu> no
19:42:08 <adu> Nothing is right
19:42:09 <SamB_XP> I thought it was 5
19:42:36 <Apocalisp> SamB_XP: absurdities and bottoms ignored, thanks
19:42:39 <EvanCarroll> it isn't gang rape if they're only fucking with your head...
19:42:44 <adu> SamB_XP: we're not counting "undefined"
19:42:53 <SamB_XP> okay, okay ...
19:43:16 <Apocalisp> EvanCarroll: Maybe Bool has three values: Just False, Just True, Nothing.
19:43:26 <adu> EvanCarroll: the correct answer was Maybe Bool has 3 values: (Nothing), (Just False), and (Just True).
19:43:32 <EvanCarroll> how is that different from False, True and Nothing
19:43:47 <adu> because False :: Bool, and Just False :: Maybe Bool
19:43:48 <EvanCarroll> or better yet, what would Just Nothing be
19:43:50 <adu> they have different types
19:44:00 <adu> Maybe (Maybe a)
19:44:16 <Apocalisp> Just Nothing :: Maybe (Maybe a), for some type a.
19:44:28 <Berengal> @type Just Nothing
19:44:30 <lambdabot> forall a. Maybe (Maybe a)
19:44:43 <Apocalisp> for all types a, sorry :)
19:44:47 <adu> EvanCarroll: what is the type of 3?
19:44:55 <EvanCarroll> Num
19:45:01 <EvanCarroll> Interger
19:45:07 <adu> ok, then what would be the type of (Just 3)?
19:45:08 <Apocalisp> @type 3
19:45:09 <lambdabot> forall t. (Num t) => t
19:45:26 <EvanCarroll> Maybe and 3
19:45:36 <adu> no, (Maybe Integer)
19:46:10 <EvanCarroll> ok, so Just 3, isn't really Just 3, it is 3 or Nothing?
19:46:14 <adu> ok, suppose "hello" :: String
19:46:20 <adu> what is the type of (Just "hello")?
19:46:27 <EvanCarroll> Maybe String
19:46:31 <adu> YES
19:46:42 <adu> good job
19:46:50 <EvanCarroll> but that's a conditional response.
19:46:54 <EvanCarroll> I don't understand any of it.
19:46:58 <Berengal> Maybe is a list that only has room for one element
19:47:22 <EvanCarroll> Right, and Just a is the item typed to Maybe a, which makes it more permissive, and not really "Just" right?
19:47:31 <Berengal> Just 3 is different from 3 in the same way that  [3] is different from 3
19:47:39 <adu> EvanCarroll: kinda
19:47:48 <EvanCarroll> this is where the confusion sets in.
19:47:55 <EvanCarroll> why not?
19:48:12 <adu> EvanCarroll: what it means is that the "Just" infront of anything allows you to INFER that the type will by "Maybe a" for some type a.
19:48:33 <adu> EvanCarroll: and lots of things in Haskell are the way they are because they allow type inference
19:49:03 <Berengal> data Box a = EmptyBox | FullBox a
19:49:20 <Berengal> That's Maybe, but with different names
19:49:52 <kmc> EvanCarroll, you understand that [3] is different from 3?
19:50:10 <EvanCarroll> yes.
19:50:18 <EvanCarroll> one is an Interger, one is a [Interger]
19:50:21 <kmc> so then you understand that Just 3 is different from 3
19:50:33 <kmc> Maybe is like a list that contains at most one element
19:51:07 <kmc> in Berengal's definition, a box that's either empty or holds one thing
19:51:29 <kmc> EvanCarroll, I suggest you look at that LYAH chapter I linked, even if you haven't read everything before it
19:51:31 <Berengal> And a thing in a box is different from a thing outside a box
19:51:48 <kmc> Berengal, you mean, a box with a thing in it is different from the thing in the box
19:52:21 <EvanCarroll> kmc: will do right now
19:52:24 <Berengal> kmc: words shwords
19:52:32 <kmc> Berengal, i think it's important
19:52:34 <EvanCarroll> I never read this btw.
19:52:41 <kmc> because the value in the Maybe a is still of type a
19:52:46 <kmc> but the box itself isn't
19:53:14 <EvanCarroll> again, let me read that lyah first, and see what I can soak in before I waste more chan time
19:53:36 <Berengal> kmc: Well, it's true, but the english could go either way
19:53:40 <EvanCarroll> I'll be sure to tell what I find confusing about it after I get it straight
19:55:28 * hackagebot upload: cabal-install 0.6.4 - The command-line interface for Cabal and Hackage. (DuncanCoutts)
19:55:37 <dcoutts> @yarr!
19:55:37 <lambdabot> Ahoy mateys
20:00:03 <osaunders_> I'm reading http://en.wikibooks.org/wiki/Haskell/Graph_reduction and I don't understand why "innermost reduction" is called that? What is "innermost" about it?
20:00:54 <osaunders_> (If I appear to have asked this twice it's because I'm not sure it got sent as I lost connection).
20:00:54 <SamB_XP> osaunders: reduces the innermost expressions first?
20:01:16 <osaunders_> SamB_XP: It doesn't though.
20:01:33 <osaunders_> Oh maybe it does.
20:01:55 <osaunders_> Depth-first.
20:02:11 <osaunders_> OK. Thank you :-)
20:02:42 <SamB_XP> there may be more than one "innermost reduction" ;-)
20:05:12 <kmc> "an innermost redex is a redex that has no other redex as subexpression inside"
20:07:26 <path[l]> how do I find the constructor for unboxedarray?
20:08:00 <kmc> path[l], what type? UArray?
20:08:04 <path[l]> yeah
20:08:36 <path[l]> I have imported unboxed array unqualified and boxed array qualified as A. Does that mean to create an unboxed array I use just array ?
20:09:14 <kmc> you create arrays using the IArray or MArray typeclass interfaces
20:09:14 <osaunders> Does this sound right? "What does an innermost reduction do? Evaluates the redexes of each argument to normal form before proceeding to the next."
20:10:03 <path[l]> hmm
20:11:47 <ACSpike[Home]> is it possible to process arrow key presses with getChar?
20:13:06 <Optimality> ACSpike[Home]: I know you can do it with the Vty package, but I'm not sure about getChar
20:13:44 <ACSpike[Home]> the problem is that arrow keys give me something like \ESC[A which isn't a Char
20:14:48 <kmc> ACSpike[Home], usually you have to do something OS-level to get keypresses as they occur rather than per-line
20:15:58 <SamB_XP> kmc: I don't think that's the issue he's complaining of at the moment!
20:17:07 <monochrom> use vty or hsncurses or something
20:18:33 <path[l]> hmm one more dumb question. does haskell use ascii character codes? I mean when I want '0'-'9' and 'a'-'z' to be the indices of an array can I trust that they'll be contiguous?
20:19:05 <path[l]> oh infact
20:19:05 <ACSpike[Home]> well this is just for an exercise, getChar works fine if I use letters instead of arrow keys
20:19:10 <monochrom> You may even assume unicode.
20:19:14 <path[l]> thats not even continuous
20:19:20 <path[l]> monochrom: ah
20:20:09 <osaunders> '0'-'9' and 'a'-'z' are contiguous in ASCII and Unicode.
20:20:22 <osaunders> Unicode being a superset of ASCII.
20:20:52 <path[l]> no I had meant contiguous as in 0-z or a-9. one of those two. But they are two seperate blocks
20:21:36 <path[l]> someone on the haskell-cafe mailing list was helping me speed up my code and he suggested I use a UArray indexed by Char. So I need to look up by char
20:21:45 <osaunders> > ['0'..'z']
20:21:47 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
20:21:55 <path[l]> guess I should convert to int and do some math
20:22:07 * adu <3 math
20:22:12 <path[l]> lol
20:23:07 <path[l]> > ord '0'
20:23:09 <lambdabot>   48
20:23:15 <path[l]> hmm right
20:23:57 <osaunders> > 0x30
20:23:59 <lambdabot>   48
20:24:04 <kmc> > fromEnum '0'
20:24:06 <lambdabot>   48
20:24:25 * osaunders is indicating that 48 is a round number in hex.
20:25:04 <path[l]> umm is that something I can use? or were you just saying :)
20:25:44 <kmc> > toEnum 0x37 :: Char
20:25:46 <lambdabot>   '7'
20:25:53 <osaunders> Basically just saying it. It's not really much use unless your brain works in hex better than base 10.
20:26:24 <path[l]> > map (\x -> x | x <= '9' = ord x - 48 | otherwise = ord x - 88) ['0'..'9']++['a'..'z']
20:26:26 <lambdabot>   <no location info>: parse error on input `|'
20:26:29 <path[l]> grr
20:27:33 <path[l]> huh that seems right
20:27:52 <kmc> you can't guard an expression
20:29:05 <path[l]> > let f x | x <= '9' = ord x - 48 | otherwise = ord x - 88) in map f ['0'..'9']++['a'..'z']
20:29:05 <kmc> > map (\x -> ord x - (if x <= '9' then 48 else 88)) ['0'..'9']++['a'..'z']
20:29:08 <lambdabot>   <no location info>: parse error on input `)'
20:29:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:29:08 <lambdabot>         against inferred type ...
20:29:31 <kmc> > map (\x -> ord x - (if x <= '9' then 48 else 88)) (['0'..'9']++['a'..'z'])
20:29:33 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
20:29:36 <path[l]> > let f x | x <= '9' = ord x - 48 | otherwise = ord x - 88) in map f (['0'..'9']++['a'..'z'])
20:29:38 <lambdabot>   <no location info>: parse error on input `)'
20:29:47 <path[l]> > let f x | x <= '9' = ord x - 48 | otherwise = ord x - 88 in map f (['0'..'9']++['a'..'z'])
20:29:49 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
20:29:52 <path[l]> kmc : ah I see
20:29:55 <path[l]> thanks
20:43:09 <osaunders_> Is it possible to sneeze quietly?
20:43:42 <medfly> define quietly
20:46:22 <osaunders> Below 40db.
20:46:57 <SamB_XP> osaunders: relative to what ?
20:46:59 <medfly> I'd say mine can be pretty quiet sometimes, but I don't have a way to test just how quiet.
20:48:08 <osaunders> nm
20:48:32 <SamB_XP> relative to a nanometer ?
20:58:06 <O_4> What advantage is there in requiring that Data.Trie use Data.ByteString?
20:58:29 <Berengal> Anyone know of a nice medium-sized programming exercise?
20:58:50 <O_4> It seems to just make things more of a pain, since the Word8 pack function won't accept Strings
20:59:16 <osaunders> Berengal: How big is medium sized?
20:59:22 <O_4> Berengal: well, there are many sites which have lists of programming challenges
20:59:30 <Berengal> osaunders: a day or two
21:00:06 <O_4> Berengal: even the Facebook staff have a puzzles section
21:00:11 <Berengal> O_4: Those are too short, mostly
21:00:30 <O_4> Well, some of the facebook ones are longer :-)
21:00:39 <osaunders> Snake, Tetris, Asteroids.
21:01:02 <osaunders> Simple arithmetic expression evaluator.
21:01:18 <Berengal> osaunders: Thanks
21:01:43 <osaunders> Tetris is probably the most complicated of those.
21:01:45 <Berengal> But an arithmetic (postfix-)expression evaluator is a one-liner ;)
21:02:03 <osaunders> With eval or something?
21:02:08 <osaunders> Because that's cheating.
21:02:11 <osaunders> :-)
21:02:15 <Berengal> No, a simple fold
21:02:48 <osaunders> You should have to parse a string and identify numbers from operators, define the operators and have something controlling the order of evaluation. That's what I had in mind when I suggested it.
21:03:26 <osaunders> Maybe add precedence and parenthesis.
21:03:38 <osaunders> Unary operators.
21:04:34 <Berengal> foldl (\stack@(first:second:rest) word -> if isNumber word then word:stack else lookup word operatorMap [...] []
21:05:43 <Berengal> I should try Tetris. It's almost two years since I last wrote it
21:07:21 <O_4> This is silly...  Surely
21:07:43 <O_4> *Surely I don't have to explicitly translate between Word8 and Char?
21:08:15 <aavogt> O_4: Char is unicode
21:08:35 <aavogt> there are more Char than there are Word8
21:08:53 <O_4> Yeah, but where is ByteString.packString?
21:09:14 <aavogt> there's a unicode bytestring fromString function (or similar)
21:09:17 <aavogt> @hoogle fromString
21:09:17 <lambdabot> Data.String fromString :: IsString a => String -> a
21:09:25 <aavogt> damn, it's something else
21:09:55 <aavogt> fromString :: String -> ByteString -- Defined in Data.ByteString.UTF8
21:10:21 <Jafet> Berengal, you make it sound challenging
21:10:48 <Berengal> Jafet: Make what sound challenging?
21:11:16 <Jafet> Tetris
21:11:45 <Berengal> Depends on how you do it.
21:11:51 <Berengal> I already know I want the music in.
21:12:09 <Berengal> doo-do-do-doo-do-do-doo-do-do-doo-do-do-do-do-do-do-do-do-do-doooo
21:13:08 <Berengal> Anyway, it's a nice chance to get to learn some graphics and sound libraries. Haven't used those much.
21:13:16 <Berengal> Also, I need to get the Java out of my system
21:13:20 <Jafet> linux audio is crap, especially MIDI...
21:13:41 <osaunders> Does this statement sound accurate: "There are Haskell interpreters but they aren't used for serious work."?
21:13:49 <Jafet> I guess there's a challenge
21:14:04 <Jafet> osaunders, when is work ever serious?
21:14:13 <Runar> Do you find that writing code in UTF-8 is more trouble than it's worth?
21:14:23 <SamB_XP> osaunders: GHCi sure is!
21:15:05 <Jafet> Runar, only when your tools aren't
21:15:06 <osaunders> Hm, OK.
21:15:14 <osaunders> Points taken
21:18:10 <osaunders> Is Haskell even considered a compiled language?
21:18:11 * SamB_XP pokes osaunders as well
21:18:27 <mauke> osaunders: no, because 'compiled' is not a language property
21:18:44 <osaunders> mauke: It can be.
21:18:47 <SamB_XP> but there is at least one reasonable compiler for it ;-P
21:19:02 <osaunders> mauke: But perhaps not in this case.
21:19:19 <mauke> osaunders: I disagree
21:19:31 <osaunders> mauke: Plese, say why.
21:19:40 <osaunders> *please
21:19:58 <Berengal> So which libraries do I start looking at if I want to capture keyboard input and produce simple graphics?
21:20:01 <O_4> aavogt: thanks for the heads up.  that should be in the standard lib, though :-p
21:20:13 <Jafet> Is there a Haskell interpreter?
21:20:20 <mauke> osaunders: because "compiled language" doesn't make sense to me
21:20:28 <osaunders> Jafet: GCHi is an interpreter.
21:21:15 <osaunders> mauke: It is possible to have languages that cannot be interpreted or, at least, not designed for compilation.
21:21:16 <Cale> Jafet: GHCi, Hugs
21:21:17 <ddarius> Jafet: Hugs.
21:21:55 <ddarius> osaunders: It's always possible to interpret and compile a language.  Compilation may produce really inefficient code, but it can always be done.
21:22:12 <Jafet> You can't paste code into GHCi
21:22:23 <O_4> Of course you can :-p
21:22:25 <Berengal> osaunders: Perl can't be compiled, because the syntax depends on the execution of the previous parts of the program
21:22:35 <Berengal> You can write a perl program that's only syntactically valid on tuesdays
21:22:35 <ddarius> Jafet: You can't paste code into Hugs either, but it is definitely not a compiler.
21:22:36 <Jafet> Never tried Hugs
21:22:38 <mauke> Berengal: so?
21:22:55 <mauke> Berengal: the same applies to lisp, and there are multiple lisp compilers
21:23:15 <osaunders> mauke: So that makes it a language only suitable for interpretation or (for short) an interpreted language.
21:23:37 <ddarius> You can compile Perl.
21:23:40 <Jafet> I don't really understand why GHCi syntax is different to GHC's, anyway, other than to prevent mutual recursive bindings
21:23:49 <mauke> osaunders: I doubt such a language exists
21:23:51 <Jafet> s/GHC's/Haskell's/
21:23:53 <Berengal> mauke: the lisp compilers interpret parts of the code at compile time. I'm not sure if that's possible with perl
21:24:02 <ddarius> Jafet: It isn't different.  It's a subset of.
21:24:14 <mauke> Berengal: uh, that's exactly what the perl compiler does: it executes parts of it in the parsing phase
21:24:25 <Jafet> I suppose you're right
21:24:40 <O_4> aavogt: unfortunately I can't use ByteString.UTF8.fromString anyway, 'cos it still returns the wrong sort of bytestring
21:25:12 <ddarius> Jafet: The only oddity is that it behaves as if you are in an unending do-block.
21:25:19 <mauke> perl already includes a parser/compiler; it just doesn't compile to machine code and the compilation result is not saved anywhere
21:26:01 <aavogt> O_4: then you can use ByteString.Lazy.UTF8?
21:27:01 <osaunders> mauke: OK. You've opened my eyes to the blurriness of the compiled/interpreted distinction.
21:28:34 <osaunders> Perhaps a better way to think of it is a continuum. Languages that can be compiled to machine code on the left and languages that need increasingly more complex runtimes as you move to the right. With Perl probably being one of the rightmost languages (can I say that?).
21:28:57 <O_4> aavogt: yeah, it works if I import Lazy, Lazy.UTF8 and UTF8 :-)
21:29:03 <ddarius> osaunders: Define "need"?
21:29:04 <mauke> osaunders: no
21:29:35 <osaunders> ddarius: Have features that rely on things happening at runtime.
21:29:36 <mauke> osaunders: compiled/interpreted is still an implementation issue
21:29:47 <SamB_XP> osaunders: most of them have that ;-P
21:30:10 <SamB_XP> I think "null" doesn't, but can't really think of any others ...
21:30:14 <osaunders> SamB_XP: Sure, because this is 2009 not 1950, but they have them to varying degrees.
21:30:37 * copumpkin moos
21:31:47 <osaunders> mauke: If a language has a feature that cannot be compiled (runtime reflection for example) then makes the language more oriented towards interpretation than the same language without that feature.
21:32:30 <osaunders> Actually a better example of something that can only be done at runtime is eval().
21:32:42 <mauke> meh, just invoke the compiler at runtime
21:32:47 <mauke> there's your eval
21:32:56 <ddarius> You don't even need that.  eval is just a function.
21:32:59 <osaunders> That not a compiler then is it.
21:33:08 <ddarius> A compiler is not a compiler?
21:33:09 <mauke> osaunders: gcc is not a compiler?
21:33:17 <SamB_XP> osaunders: last I checked, it was!
21:33:28 <osaunders> What language in GCC?
21:33:33 <mauke> C
21:33:42 <osaunders> There's eval() in C?
21:33:52 <mauke> you can easily write one by invoking gcc
21:33:58 <SamB_XP> GHC really does get dragged in, kicking and screaming though it may come, when you include an "eval" function in your Haskell programs ;-P
21:34:05 <osaunders> It'll only work if you have GCC on your system.
21:34:11 <mauke> osaunders: so?
21:34:24 <osaunders> That's the definition of interpretation.
21:34:29 <mauke> no, it isn't
21:34:40 <osaunders> What's the definition of interpretation then?
21:34:46 <copumpkin> a bad one
21:34:57 <Jafet> osaunders, so compile a C compiler into the program.
21:35:13 <SamB_XP> there really isn't a definition ;-P
21:35:21 <osaunders> Jafet: Then you just wrote..... an interpreter!
21:35:34 <SamB_XP> but, generally, whaty command.com does *is* considered interpretation
21:35:46 <mauke> so gcc is an interpreter because it contains a compiled-in C compiler
21:35:47 <SamB_XP> and what nasm does is *not*
21:35:56 <mauke> wat
21:35:58 <Berengal> In my mind, an interpreted program is a program that needs to be fed as input to another program in order to work. A compiler is a program that takes a program as input and produces another program as output
21:36:05 <copumpkin> moo
21:36:10 <Jafet> I consider interpretation to be an application of operational semantics, whereas compilation an application of denotational semantics
21:36:17 <ezyang> What is the secret of fast and dirty Haskell?
21:36:22 <osaunders> http://en.wikipedia.org/wiki/Interpreted_language
21:36:24 <copumpkin> ezyang: no lube
21:36:37 <copumpkin> ezyang: and no protection
21:36:40 <SamB_XP> remember, command.com reads the input .BAT file *one line at a time*
21:36:41 <osaunders> ezyang: I know you from DevNet.
21:36:48 <SamB_XP> then it *closes* the file before executing the line!
21:36:50 <ezyang> copumpkin: But that's the good stuff about Haskell!
21:36:57 <SamB_XP> and reopens it after
21:36:59 <ezyang> oasaunders: Oh, hey there Ollie!
21:37:08 <copumpkin> ezyang: you want it fast and dirty, it needs to be unlubed and unprotected, sorry
21:37:11 <SamB_XP> nevermind if the medium the .BAT was on was removed!
21:37:16 <mauke> SamB_XP: WTF
21:37:22 <Berengal> SamB_XP: O_o
21:37:33 <ezyang> *osaunders
21:37:34 <osaunders> ezyang: Hi :-)
21:37:49 <Jafet> ...to actions, and another computer language, respectively
21:38:18 <osaunders> mauke: Well I'm sorry I can't convince you but I'm done trying now.
21:38:25 <ezyang> copumpkin: I think this will be my quest. Fast and dirty, but still protected Haskell!
21:38:41 <copumpkin> ezyang: well, define dirty
21:38:44 <osaunders> ezyang: What do you mean by fast and dirty?
21:38:54 <ddarius> Interpretation is going from syntax to semantics.  Compilation is translation from one language to another.
21:39:17 <copumpkin> I like that
21:40:08 <ezyang> In more concrete terms, I mean, "Oh hey, there's this short script I need to write. I would write it in Haskell... but it'd be so much quicker to write it in $FOO language, even if it won't be as robust..."
21:40:13 <Berengal> ddarius: Does bytecode have syntax?
21:40:19 <ddarius> Berengal: Yes.
21:40:19 <osaunders> ddarius: Yeah, that's pretty nice.
21:40:26 <ddarius> osaunders: That's the definition of the terms.
21:41:27 <Berengal> ezyang: The trick is Cabal, and knowing what's on hackage
21:41:49 <ezyang> I suspect that goes a long way to it.
21:42:02 <copumpkin> is there a language with an interesting type system that allows infinite types?
21:42:07 <ezyang> I also personally think the current command line parsing libraries are clunky, but I can't quite put my finger on why.
21:42:37 <Berengal> copumpkin: haskell allows infinite types
21:43:00 <copumpkin> Berengal: it does?
21:43:02 <osaunders> copumpkin: What's an infinite type?
21:43:15 <ezyang> Berengal: Hm?
21:43:18 <copumpkin> things like a = [a]
21:43:23 <Berengal> copumpkin: Mu, the Y-combinator for types
21:43:30 <copumpkin> Berengal: that's not an infinite type
21:43:36 <copumpkin> it's just a recursive newtype
21:43:36 <Berengal> Is so!
21:43:40 * ezyang laughs out loud 
21:43:49 <copumpkin> it lets you approximate an infinite type with a lot of cruft :)
21:44:04 <Berengal> We must now fight to the death
21:44:11 <copumpkin> damn, must we?
21:44:12 <ddarius> copumpkin: O'Caml allows equirecursive types with a flag.
21:44:16 <copumpkin> I'm tired
21:44:32 <Berengal> There are infinite types in Haskell, but you have to tag them as such
21:44:37 <ddarius> Haskell allows iso-recursive types but not equi-recursive types.
21:44:58 <copumpkin> -rectypes
21:44:59 <copumpkin> I see
21:45:23 <ddarius> copumpkin: You have to explicitly provide such types though as inferring them tends to make a lot of ill-formed code type correct.
21:45:32 <copumpkin> I see
21:45:50 <copumpkin> thanks :)
21:48:27 <osaunders> What's the use of an infinite type?
21:48:48 <ddarius> Sometimes they are what you want.
21:48:57 <ezyang> "you know it when you see it"
21:48:59 <ddarius> copumpkin: Incidentally, C# also allows some equirecursive types.
21:49:11 <copumpkin> osaunders: I was wondering if there was an ideal (extant) language for playing with fixpoints of functors and fancy recursion schemes on them
21:49:47 <osaunders> Uh huh. That's nice.
21:49:53 <copumpkin> indeed.
21:50:11 <osaunders> :)
21:50:29 * copumpkin had several hours of edwardk exposure the other day and is already exhibiting symptoms
21:50:48 <osaunders> That reminds me, I should probably get that flu-jab.
21:50:53 <Berengal> Oh god! The morphisms!
21:51:04 <ddarius> copumpkin: Obviously not enough.  You aren't yet writing your own language to better be able to express these things.
21:51:17 <copumpkin> ddarius: but I am idling in the channel for that language, at least :)
21:51:28 <copumpkin> even though the author himself does not
21:51:45 <ddarius> You have to be on IRC to idle in a channel.
21:52:13 <copumpkin> he often forgets to even when he's around!
21:52:22 <copumpkin> but I have hope!
21:52:29 <ddarius> I should start a language project (or rather finish one of the ones I've started) and make a channel for it and idle idly in that channel.
21:52:38 * osaunders goes to get soup. Mmm soup. No, there's none for you! Mahahahaha!
21:52:40 <Jafet> Idyllic.
21:53:05 <copumpkin> ddarius: yay! quiet language channels are cool
21:53:22 <Berengal> They're like hippster bars
21:53:25 * ezyang has a single window IRC client. He can't keep #haskell on for too long... 
21:53:38 * copumpkin implemented a bunch of *morphisms in agda
21:53:41 <copumpkin> it was painful
21:53:48 <copumpkin> I should probably just do them in haskell
21:53:49 <SamB_XP> ezrakilty: try getting a *REAL* IRC client
21:54:04 <ezyang> lol!
21:54:10 <Berengal> I thought about implementing CT in agda as I read through this CT book I've got
21:54:16 * ddarius likes how SamB_XP maligns random passers-by.
21:54:26 <SamB_XP> whoops
21:54:32 <SamB_XP> ezyang: ^^^
21:54:37 <m0nkfish> michaelh: flips the arguments of a function
21:55:07 <copumpkin> wow, that's #haskell for you. Answer the question before it's asked
21:55:13 <Berengal> O_o
21:55:25 <medfly> lol
21:55:25 <Berengal> inverted-lazyness
21:55:27 <ezyang> o_O
21:55:38 <m0nkfish> [05:55:57] michaelh ª what does haskell's flip do?
21:55:39 <m0nkfish> ;)
21:55:51 <ezyang> That, my sir, is a "stark"
21:55:58 <SamB_XP> monochrom: that doesn't get asked for almost 5 hours!
21:56:30 <ezyang> SamB_XP: Nick completion just doesn't like you today, hm?
21:56:36 <m0nkfish> SamB_XP: unfortunately my housemate wakes me up in 4:30 hours' time
21:56:40 <SamB_XP> hehehe
21:58:11 <copumpkin> I even have zygomorphisms in agda!
21:58:22 <copumpkin> hylomorphisms, though, are problematic :(
21:58:33 <ddarius> copumpkin: Of course they are.
21:58:39 <Berengal> I wonder how hard it could be to port agda's syntax to haskell...
21:58:54 <ddarius> copumpkin: fix is readily written as a hylomorphism.
21:58:59 <copumpkin> yeah :/
21:59:08 <copumpkin> it's sad
21:59:23 <copumpkin> I mean, I can write it easily, but it obviously doesn't pass the termination check
21:59:49 <ddarius> copumpkin: Maybe start looking into dialgebras.
22:00:01 <Berengal> "As a proof method, general recursion is wholly bogus‚Äîits type, ‚àÄP‚áí(P‚ÜíP)‚ÜíP is a blatant lie."
22:00:53 <copumpkin> lol
22:01:10 <Berengal> I think that was from Ulf's thesis, but I'm not sure
22:01:19 <copumpkin> I like that
22:02:09 <Berengal> ... I just realized that I read PhD thesis papers for fun...
22:02:22 <ddarius> Berengal: Check your logs.  I probably warned you months ago.
22:02:35 <toast-opt> um, why is it a lie?
22:02:57 <Cale> toast-opt: Because it says that from (if P then P), we can infer P
22:03:04 <Berengal> ddarius: but I don't even have a bachelor! I'm a university dropout!
22:03:09 <Cale> toast-opt: for any statement P
22:03:18 <ddarius> Berengal: I don't have a bachelor either.  I never attended university.
22:03:22 <toast-opt> oh, i thought those were -> function type arrows
22:03:28 <Cale> toast-opt: they are
22:03:36 <Berengal> toast-opt: Welcome to the curry-howard isomorphism :)
22:03:37 <toast-opt> oh.  hmm
22:03:39 <ddarius> toast-opt: Look up the Curry-Howard correspondence.
22:03:42 <Cale> toast-opt: Types are theorems, programs are proofs
22:03:52 <ddarius> reductions are proof transformations
22:03:59 <toast-opt> i've looked that up before.  i'm not yet ready for that inner circle yet
22:04:04 <toast-opt> give me a month
22:04:05 <Berengal> ddarius: Either there's something very wrong with us, or something very right.
22:04:10 <copumpkin> toast-opt: it'll improve your understanding ohaskell immensely
22:04:11 <Runar> I didn't attend university either!
22:04:21 <copumpkin> I'm not sure ddarius is the common case
22:04:31 <toast-opt> copumpkin, can i get through type classes and monads first?  or should i start there?
22:04:50 <Cale> toast-opt: If from A we can prove that B, we have a proof of A -> B, if from a value of type A, I can build a value of type B, then (using lambda), I get a function of type A -> B
22:04:50 <copumpkin> toast-opt: understanding types for their own sake will help you with those
22:04:57 <ddarius> toast-opt: The Curry-Howard correspondence is of general CS relevance.
22:05:17 <copumpkin> toast-opt: like being able to reason about types and figure out code that has a given type
22:05:17 <toast-opt> ddarius, i don't doubt it.
22:05:26 <toast-opt> ddarius, but i can't do everything at once!
22:05:35 <Cale> toast-opt: and if I have that (A -> B) is true, and that A is true, I get that B is true. Similarly, if I have a function of type (A -> B) and a value of type A, then I can get a value of type B.
22:05:40 <copumpkin> toast-opt: it'll also help you figure out the only meaningful instances of monads for some types, and so on
22:06:05 <toast-opt> copumkin, i'll give it another shot then
22:06:19 <copumpkin> toast-opt: as always we can help out (and Cale already is)
22:06:28 <toast-opt> heh, thx
22:06:44 <toast-opt> ... man, you guys are too helpful.  maybe i accidentally stepped into a cult of some sort
22:06:50 <copumpkin> toast-opt: I like to think of functions as "I know X, and I need Y"
22:07:16 <toast-opt> copumpkin, so 'fix' is a lie then?
22:07:22 <ddarius> toast-opt: There's a sizable paper on the internet that's somewhat tough going but is probably a very good resource if you work through it heartily.  This should be it: http://citeseer.ist.psu.edu/519604.html
22:07:30 <copumpkin> toast-opt: a fun lie
22:07:44 <toast-opt> copumpkin, thx, i'll print it out and read it at lunch monday
22:07:51 <toast-opt> i'd run out of papers on my list
22:07:56 * copumpkin passes that on to ddarius
22:08:05 * ksf thinks NFData and friend should be moved to Control.Strict
22:08:14 <copumpkin> ksf: it sort of has
22:08:22 <copumpkin> ksf: but to its own package, deepseq
22:08:31 <ddarius> toast-opt: It's 273 pages and it covers quite a bit more territory than just the Curry-Howard isomorphism (which is why it can be potentially very useful)
22:08:31 <ksf> and Data and Control unified into Code
22:08:39 <ksf> or Stuff
22:08:41 <toast-opt> ddarius, doh
22:08:46 <copumpkin> Stuff.Monad
22:08:53 <toast-opt> that's a bit long for lunch
22:08:55 <Cale> Hmm, I know that Integer, and I need to prove that String. Tsk, I already know that String, why should I prove it again?!
22:09:10 <ksf> Fuzzy.Monad, Fuzzy.Either
22:09:31 <copumpkin> lol
22:09:37 <ddarius> Monomorphic types are rather boring.
22:09:39 <toast-opt> i have a list, and i need to prove it, but luckily i have a handy function here that proves a list from itself
22:09:41 <copumpkin> yeah :/
22:09:41 <toast-opt> right?
22:10:00 <copumpkin> toast-opt: yeah, most of the curry-howard isomorphism stuff (in haskell at least) is about polymorphic types
22:10:08 <copumpkin> (the interesting stuff, anyway)
22:10:10 <toast-opt> like, say, the function (\a -> 0 : 1 : (zipWith (+) a (tail a)))
22:10:16 <toast-opt> that proves a list from itself
22:10:34 <toast-opt> or, technicall,y proves one list from another
22:10:44 <toast-opt> but happens to 'work' if it is fed back in on itself
22:11:09 <toast-opt> ... so some lazy evaluation tricks are really circular logic :)
22:11:25 <toast-opt> am i somewhat on track?
22:11:33 <Cale> toast-opt: general recursion is circular logic
22:11:36 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13281 any ideas on making this better?
22:11:37 <Cale> :t fix
22:11:39 <lambdabot> forall a. (a -> a) -> a
22:11:46 <toast-opt> yes, noticed that earlier
22:11:47 <copumpkin> it's a fallacy!
22:11:57 <Jafet> More of a tautology, eh
22:12:05 <Cale> If we had that a, then a would be true. Therefore, a.
22:12:06 <toast-opt> copumpkin, heh, i'm an engineer.  i don't care if it's a lie.  i just care that it works :)
22:12:07 <ddarius> The proposition that a type, such as Int, represents is whether that type is inhabited, e.g. whether there is a value of type Int.  To prove it you just need to provide such a value.
22:12:10 <ddarius> I.e. a number.
22:12:19 <copumpkin> toast-opt: it's still good to understand the lie
22:12:21 <copumpkin> we still use it :)
22:12:27 <toast-opt> of course
22:12:37 <toast-opt> some lies are very helpful
22:12:44 <toast-opt> like "yes, you look wonderful in that dress"
22:12:54 <copumpkin> ezyang: Alumni is plural, Graduate is singular
22:13:05 <ksf> http://www.cis.upenn.edu/~bcpierce/sf/  looks very nice for an intro into proofs in programming
22:13:14 <ezyang> copumpkin: will fix, but "besides that"
22:13:17 * ddarius doesn't believe in helpful lies except for the purposes of competitive deception.
22:13:18 <copumpkin> ezyang: I'd also write ['g', 'a', 's', 'o'] just for clarity, even though it's not as succinct :P
22:13:24 <Cale> toast-opt: But you have to watch out because lies can also lead to nontermination. :)
22:13:31 <toast-opt> > fix fix
22:13:32 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
22:13:35 <copumpkin> like my poor hylomorphism
22:13:36 <Cale> > fix id
22:13:41 <lambdabot>   mueval-core: Time limit exceeded
22:13:53 <copumpkin> :t fix (ap sequence)
22:13:54 <lambdabot> forall a. [[a] -> a] -> [a]
22:14:00 <ddarius> copumpkin: The lie in that case is that codata ~ data.
22:14:03 <copumpkin> :t fix (ap Data.Traversable.sequence)
22:14:05 <lambdabot> forall (t :: * -> *) a. (Data.Traversable.Traversable t) => t (t a -> a) -> t a
22:14:08 <copumpkin> ddarius: yeah
22:14:15 <ksf> ...proving those things with coq is both fun enough and hard enough to make even me do the exercises.
22:14:21 <Jafet> :t iterate
22:14:22 <lambdabot> forall a. (a -> a) -> a -> [a]
22:14:29 <Jafet> > iterate id 1
22:14:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:14:32 <toast-opt> so the non-soundness of recursion is that it doesn't necessarily terminate -- ie, it might be a lie, but you can't tell for sure.  isn't this a variant of the halting problem?
22:14:33 <copumpkin> ddarius: I do have an anamorphism in codata and a catamorphism in data
22:15:19 <ray> what if the type system could tell data and codata apart, though
22:15:20 <toast-opt> saying (a->a)->a is a lie is just another way of saying that you can't tell if some turning machines either halt or not
22:15:31 <copumpkin> toast-opt: it's also just a false logical statement
22:15:33 <ksf> the variant is that it's not termination we're caring about, but doing an finite amount of work for each finite chunk of data we get.
22:15:44 <ray> actually, (a -> a) -> a is the lie
22:15:47 <toast-opt> copumkin - it's only false for some values of 'a'
22:15:49 <ksf> i.e. non-termination induced by infinite input shouldn't be a problem.
22:15:51 <ray> if you read it as a proposition
22:15:54 <ddarius> toast-opt: It's not unsound.
22:16:01 <Rotaerk_> no, the cake is the lie
22:16:09 <copumpkin> toast-opt: yeah, but the type is polymorphic, so if it isn't true for all values, it's false
22:16:19 <ksf> with that notion, the worst that can happen is that our output is infinite, too.
22:16:24 <toast-opt> hmm.. so fix is like a portal
22:17:00 <toast-opt> i was always annoyed i couldn't shoot portals through portals
22:17:04 <ddarius> ksf: That's a property dual to totality called productiveness.
22:17:06 <osaunders> Does type inference mean you can omit all type declarations?
22:17:08 <toast-opt> maybe because it wouldn't necessarily terminate
22:17:12 <ray> osaunders: most
22:17:13 <toast-opt> like fix
22:17:15 <ddarius> osaunders: No.
22:17:26 <ddarius> osaunders: But there are very few cases in Haskell 98 where a type annotation is required.
22:17:36 <osaunders> OK.
22:17:41 <osaunders> Thanks.
22:17:42 <ezyang> osaunders: You should generally include type declarations for top level functions.
22:17:45 <Berengal> ddarius: Actually, I think type inference is total in H98
22:17:49 <ray> toast-opt: you're familiar with reading types as logical propositions, right?
22:17:56 <copumpkin> Berengal: it's required to get the desired behavior, under MR at least
22:17:58 <toast-opt> ray, heh, NO
22:18:04 <toast-opt> i started hacking haskell last week
22:18:06 <osaunders> ezyang: Why?
22:18:16 <toast-opt> and have no formal education in type theory
22:18:19 <copumpkin> osaunders: keeps relevant errors in their place
22:18:22 <ksf> the proof of the argument is in the passing.
22:18:24 <ddarius> Berengal: There are things that won't type check without a type annotation that will with one, but type inference does always terminate.
22:18:27 <Berengal> copumpkin: Well, yes. It is able to manage to infer all types, but that doesn't mean you can't get a type error
22:18:29 <ray> anyway, -> is like "implies"
22:18:52 <ray> so (a -> a) -> a is like "a function a -> a implies a value a"
22:18:53 <toast-opt> ray, well, i picked up on that
22:18:58 <toast-opt> Cale was giving me lessons
22:19:00 <Berengal> ddarius: The same is true for HM, is it not?
22:19:00 <ray> but that's just not true for all a
22:19:07 <ddarius> Berengal: No.
22:19:32 <ezyang> oh noes, is Hoogle down?
22:19:32 <ddarius> The Hindley-Milner type inference system will always find all principal types for the language it covers.
22:19:46 <ray> sometimes you get _|_ from fix
22:19:52 <ray> which is the same as _|_ in logic
22:20:21 <m0nkfish> _|_ isnt defined in haskell is it
22:20:23 <ezyang> "which is not the same as _|_ from A Midsummer's Night Dream"
22:20:29 <ksf> > undefined
22:20:31 <dibblego> m0nkfish, undefined
22:20:31 <lambdabot>   * Exception: Prelude.undefined
22:20:37 <m0nkfish> oh there is actually an undefined
22:20:38 <ddarius> Berengal: There are two classes of programs that require type annotations in Haskell 98.  One is a variant of the earlier monomorphism restriction program, most simply as show . read.  The other class is programs using polymorphic recursion.
22:20:46 <copumpkin> m0nkfish: there are other ways of getting it, too
22:20:48 <m0nkfish> i must inform my haskell lecturer of this
22:20:55 <ksf> > error "bottom"
22:20:56 <ray> well you can't type _|_ into a program
22:20:57 <lambdabot>   * Exception: bottom
22:20:58 <m0nkfish> he recommended (error "_|_")
22:20:59 <m0nkfish> yeah
22:21:03 <copumpkin> > fix id
22:21:07 <ray> > _|_
22:21:08 <lambdabot>   mueval-core: Time limit exceeded
22:21:09 <lambdabot>   <no location info>: parse error on input `|'
22:21:11 <copumpkin> that's _|_ too :P
22:21:17 <ksf> ...those exceptions are deliberately made hard to catch.
22:21:25 <ddarius> ray: _|_ in logic (which I presume you mean falsity) is not even the same sort of thing as _|_ in programming semantics.
22:21:32 <Berengal> ddarius: polymorphic recursion how?
22:21:38 <ksf> > throw NonTermination
22:21:40 <lambdabot>   Not in scope: `throw'Not in scope: data constructor `NonTermination'
22:22:16 <toast-opt> > (_|_)
22:22:17 <lambdabot>   <no location info>: parse error on input `|'
22:22:41 <ddarius> Berengal: I don't understand your question.
22:22:56 <toast-opt> > (f . g) undefined
22:22:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:22:58 <lambdabot>    `SimpleReflect.FromExpr ...
22:22:59 <ray> isn't _|_ "contradiction" in logic
22:23:04 <Berengal> ddarius: Do you have an example of the second class of programs?
22:23:30 <ray> and T is "tautology"
22:23:40 <ray> both of those really being tacks of course
22:24:03 <ddarius> Sure.  The Report also has one as the Report explicitly states that most general types will not be inferred for polymorphically recursive functions and that type signatures are required.
22:25:02 <ddarius> > let f :: Show a => Int -> a -> String; f 0 x = show x; f n x = f (n - 1) (x, x) in f 3 1
22:25:04 <lambdabot>   "(((1,1),(1,1)),((1,1),(1,1)))"
22:25:12 <ddarius> > let f 0 x = show x; f n x = f (n - 1) (x, x) in f 3 1
22:25:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
22:25:42 * Jafet sits on the uppermost turtle
22:25:51 <Berengal> ddarius: Ah, I see
22:26:44 <ddarius> ray: At best, _|_ is the only inhabitant of falsity, but even that's not necessary and at any rate it would be like saying Int and 3 are the same thing.
22:26:44 <Berengal> ddarius: Is infering the types in that case impossible?
22:27:05 <ezyang> hm. Why can't I fmap Parsec's natural.
22:27:33 <ezyang> as in, Undergraduate <$> natural
22:27:42 <ddarius> Berengal: It's undecidable in general, yes.
22:28:07 <Berengal> Undecidability makes me SO MAD >:(
22:28:33 <copumpkin> ezyang: I don't know
22:28:42 <copumpkin> ezyang: what's the type of Undergraduate?
22:28:45 <Jafet> We can't ever be sure of that, Berengal
22:28:53 <ezyang> Undergraduate :: Int -> Undergraduate Int
22:29:08 <copumpkin> what's the type of natural?
22:29:27 <ezyang> natural  :: CharParser st Integer
22:29:50 <Berengal> ezyang: Undergraduate . fromInteger <$> natural
22:29:51 <ezyang> CharParser st is presumably a monad
22:30:16 <ezyang> Oh no, I lied, s/Int/Integer/
22:30:30 <Berengal> Okay then, what error do you get?
22:30:33 <copumpkin> it might help if we knew the error
22:30:41 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13282#a13282
22:30:42 <copumpkin> without having to guess at what's wrong :)
22:30:50 * Saizan bets on a lack of import Control.Applicative
22:30:59 <copumpkin> not this time!
22:31:20 <ezyang> oh, dude, the docs I'm consulting for type of natural are wrong
22:31:29 <ezyang> is actually natural :: GenTokenParser s u m -> ParsecT s u m Integer
22:31:55 <Saizan> ?hoogle natural
22:31:55 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
22:31:55 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
22:31:55 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
22:32:19 <copumpkin> http://snapplr.com/22ah
22:32:22 <ddarius> ezyang: What probably happened is that natural was shadowed as natural is a record selector, but one usually has only one "language" per program.
22:32:29 <copumpkin> is that ugly or what?
22:32:58 <osaunders> Why is the GHCi prompt "Prelude>"?
22:33:11 <ddarius> osaunders: Because the Prelude module is loaded.
22:33:24 <copumpkin> Fugue>
22:33:29 <osaunders> ddarius: Right, OK.
22:33:36 <ezyang> ddarius: huh.
22:33:49 <ezyang> I guess I should pass it an argument then
22:33:53 <Jafet> copumpkin, "Prelude>" is more canonical
22:33:56 <ddarius> TokenParser is a record.  natural is a field of that record.
22:34:28 <copumpkin> Jafet: Fugue exports counterpoint, a method from the Copointed typeclass
22:34:29 <ddarius> It's common to do stuff like: natural = L.natural myTokenParser
22:34:55 <Saizan> copumpkin: Bool is sad?:(
22:35:12 <ezyang> ah, I see
22:35:23 * ddarius can see people livecoding with modules like Overture, Chorale, Intermezzo.
22:35:26 <copumpkin> Saizan: well, the uniformity of my definitions in that module is sad, with lists, bools, maybes, and naturals all being implemented with the same sum type
22:35:50 <ezyang> that's kind of funny
22:36:06 <Jafet> @hoogle Fugue
22:36:07 <lambdabot> No results found
22:36:17 * Jafet fell for it.
22:36:38 <copumpkin> :)
22:36:44 <Berengal> I find it a bit funny that product types are a special case of dependent sum types...
22:37:04 <copumpkin> yeah :)
22:37:11 <copumpkin> and that dependent products are exponentials
22:37:20 <copumpkin> damn dependencies, promoting everything!
22:37:47 <Saizan> well, if you write a summation where you don't use the index in the expression, you get a product too
22:39:08 <ezyang> ddarius: I don't imagine there is a shortcut module that uses all Haskell defs or something?
22:39:14 <ddarius> Berengal: There is a horribly conflicting terminology, dependent function types and dependent products for dependent products and dependent sums respectively, but I think the (seemingly) more common, latter, terminology is more correct.
22:39:58 <ddarius> ezyang: Nope as you rarely would want it.  Usually you want to modify one of the provided languages (perhaps the empty one).
22:40:04 <copumpkin> dependent sums are wonderful
22:40:13 <Berengal> Dependent types are wonderful
22:40:53 <Jafet> They sure fill me with wonder
22:41:37 <Berengal> I wonder how it'd be like to program a larger project in agda...
22:41:49 <Berengal> I think I'm going to try that once I get a bit more familiar with it
22:41:50 <copumpkin> depends on the project
22:42:05 <copumpkin> a daemon of some sort might be painful ;)
22:42:08 <keithshep> hello hoogle is down for me (and i assume everyone since it's "Internal Server Error")
22:42:11 <Peaker> Which is the most mature for general "programming" (as opposed to just theorem proving) of Agda, Coq, Epigram or any other DT thingie
22:42:14 <copumpkin> @hoogle this
22:42:14 <lambdabot> No results found
22:42:32 <Saizan> @hoogle map
22:42:32 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
22:42:32 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
22:42:32 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
22:42:37 <ddarius> (A√ó) ‚ä£ (A ‚Üí) and Œ£ ‚ä£ P ‚ä£ Œ†
22:43:06 <Berengal> Peaker: I've only tried Agda, but from what I've gathered, Epigram is the most suited for general programming, but least mature, while Coq is the least suited to general programming, but most mature
22:43:14 <Saizan> P?
22:43:26 <copumpkin> Berengal: a new epigram is in the works
22:43:31 <Berengal> copumpkin: nifty
22:43:35 <ddarius> Saizan: A variant on the weakening functor.
22:43:36 <copumpkin> Berengal: but the old one seems more or less forgotten
22:43:56 <ddarius> The first adjoint between A√ó and A‚Üí can be factored to more closely match the latter.
22:43:57 <keithshep> is the cafe the right place to notify about hoogle?
22:44:53 <Berengal> One thing I like about dependent types is that they let you prove things about your programs very easily (compared to, say, C), and unlike tests, proofs are complete and compositional
22:44:56 <Peaker> Berengal, Epigram blew me away, I can't wait for it to be ready
22:44:58 <ddarius> Berengal: While least intended for programming, Coq is probably best suited out of those.  There are dependently typed languages that do not try to maintain totality which may be better for programming but lose many of the benefits of dependent typing.
22:45:13 <Peaker> Berengal, Tests can be compositional
22:45:34 <copumpkin> ddarius: agda still makes it pretty obvious if it can't prove your funciton terminates. It just dissociates typechecking from termination checking
22:45:46 <copumpkin> it also refuses to import functions from other modules that don't terminate
22:45:54 <copumpkin> unless you ask it very nicely
22:46:00 <Peaker> ddarius, Epigram lets you decide whether to use general recursion and lose it or not -- do you mean this?
22:46:18 <Berengal> totality is such a wonderful thing, but it's also bothersome at times...
22:47:12 <ddarius> Peaker: There are dependently typed languages that don't even try to maintain totality.
22:47:17 <ddarius> Cayenne is an old example.
22:47:23 <Berengal> One thing I like about Agda is that I can have totality without sprinkling Maybes all over, instead taking a proof that the input is in the domain of the function as input
22:47:45 <ezyang> Berengal: Whoa. That's classy.
22:47:46 <Peaker> ddarius, Ah.. so at compile-time it has to execute proofs to check them?
22:47:53 <Peaker> ddarius, and then give up after a while?
22:48:39 <Berengal> ezyang: Isn't it?
22:48:47 <Peaker> Berengal, You could probably do this in Epigram too, no?  Given a proof that its in the domain, take it out of the Maybe
22:49:02 <copumpkin> sure
22:49:17 <copumpkin> but proofs mean more arguments to functions
22:49:20 <copumpkin> which makes it ugly
22:49:24 <copumpkin> :)
22:49:31 <Berengal> Peaker: I haven't looked at Epigram much. When I say agda, it's because it's basically the only dependently typed language I'm familiar with (yet)
22:50:00 <copumpkin> divide : Rational -> (d : Rational) -> (d /= 0) -> Rational
22:50:03 <sshc> what happened to haskell.org?
22:50:14 <Peaker> How much of GHC work is MS research's and how much is from general population contributions?
22:50:15 <copumpkin> sshc: I don't know, what happened to it?
22:50:30 <Berengal> copumpkin: But it forces the issue of what to do with values that are outside of the domain onto the caller instead. It's nice to be explicit, and I've found it helps me think
22:50:38 <Peaker> copumpkin, unless you get implicit arguments and have the compiler pass them like type classes
22:50:58 <copumpkin> Peaker: it's hard for the compiler to dig up a proof that d /= 0
22:51:12 <Peaker> copumpkin, Maybe :)
22:51:22 <copumpkin> Peaker: but in some cases (and with agda) you can ask it to infer implicit parameters for proofs
22:52:08 <copumpkin> Berengal: well for a while I was working on a type called PredSet which was a type along with a predicate on values of that type, to achieve a kind of subtyping
22:52:11 <ddarius> Peaker: In Cayenne, the type checker can loop.
22:52:15 <copumpkin> turned out PredSet was a dependent sum
22:52:16 <ksf> Peaker, that's easy to find out: File an unsubstituated claim that spj is doing all the work, and thus have him spell out what he didn't contribute.
22:52:35 <Berengal> copumpkin: you could wrap that in a _/_ : Rational -> Rational -> Maybe Rational; a / zero = nothing; a / (succ x) with non-zero (succ x) ... | p = just (divide a (succ x) p)
22:53:01 <copumpkin> Berengal: sure
22:53:12 <Peaker> ddarius, And it probably has to fully normalize all proofs (whereas Epigram can just type-check them)
22:53:20 <ddarius> Peaker: Yes.
22:53:22 <Jafet> Peaker, well, you can be sure they didn't name it
22:53:35 <copumpkin> Berengal: where'd that | p come from?
22:53:47 <Berengal> copumpkin: with-construct
22:53:48 <ddarius> Peaker: None of it is "owned" by MSR.  Most of the compiler is seemingly SPJ and the runtime Simon Marlow, though there are definitely significant (and less significant) contributions by various people.
22:55:08 <ddarius> I don't think either of the Simons worked for MSR when I started using Haskell (or one of them had just started) which was around GHC 5.3.
22:55:28 <copumpkin> old-timer!
22:56:07 <Peaker> ddarius, Yeah, I know its opensource, someone was wrong on the internet, that's all :)
22:56:18 <ddarius> Berengal: When proving some code satisfies some property, it's a lot easier if you can change both the code and the property.
22:56:21 <sshc> what's the oppisite of truncate?
22:56:33 <copumpkin> sshc: append?
22:56:39 <copumpkin> define opposite
22:56:40 <shachaf> sshc: The point is that it doesn't have one. :-)
22:56:45 <mauke> extend
22:56:51 <sshc> the inverse
22:56:59 <sshc> > truncate 3.2
22:57:00 <ddarius> sshc: It definitely doesn't have one.
22:57:00 <lambdabot>   3
22:57:19 <ddarius> > truncate [3.0, 3.1 .. 4]
22:57:19 <sshc> no, actually, I want the decimal part
22:57:20 <copumpkin> sshc: think about it, what would you do to 3 to make it back into 3.2?
22:57:21 <lambdabot>   No instance for (GHC.Real.RealFrac [t])
22:57:21 <lambdabot>    arising from a use of `GHC.Real....
22:57:27 <copumpkin> oh
22:57:33 <sshc> sorry, bad wording on my part
22:57:45 <ddarius> copumpkin: There are plenty of things to do, namely add 0.2.
22:58:14 <ddarius> @src Floating
22:58:20 <lambdabot> class  (Fractional a) => Floating a  where
22:58:24 <lambdabot>     pi                                                      :: a
22:58:28 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
22:58:32 <lambdabot> Plugin `source' failed with: thread killed
22:58:32 <copumpkin> > (-) <*> (fromIntegral . truncate) $ 3.2
22:58:36 <lambdabot>   0.20000000000000018
22:58:47 <copumpkin> :P
22:59:14 <Jafet> MSR produces some of the best CS research these days
22:59:15 <sshc> what do I need to import to use <*>?
22:59:18 <sshc> hoogle is down
22:59:28 <B4R74zy> plz go 2             http://sites.google.com/site/affiliateshope            &  click  on ads
22:59:29 <ezyang> sshc: control.applicative
22:59:36 <shachaf> sshc: Control.Applicative. But I suspect that was a joke.
22:59:40 <ddarius> > snd $ properFraction 3.2
22:59:42 <lambdabot>   0.20000000000000018
22:59:44 <shachaf> There's a function that does that, isn't there?
22:59:52 <copumpkin> @where ops
22:59:52 <shachaf> There.
22:59:52 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
23:00:03 <copumpkin> B4R74zy: really lame
23:00:04 --- mode: ChanServ set +o mauke
23:00:05 --- mode: mauke set +b *!*@71.sub-75-210-111.myvzw.com
23:00:14 <ezyang> although these days I manually define <*> with fixity and set it equal to ap
23:00:42 <ddarius> Jafet: I'm pretty sure MSR has always produced good research, at least while Microsoft was a major commercial entity (which is probably longer than MSR has been around.)
23:00:54 <shachaf> ezyang: You should manually define Monad to be a subclass of Applicative instead. :-)
23:01:05 --- mode: mauke set -o mauke
23:01:34 <ezyang> shachaf: Doing that sucks. A lot.
23:01:42 <ezyang> I should just use galois's monad library...
23:01:42 <shachaf> ezyang: Yes? Why?
23:01:49 <shachaf> Caleskell 2011!
23:02:23 <ezyang> shachaf: Orphaned instances are generally not a good idea maintenance-wise.  Additionally, it's a bit of extra boilerplate to have to write.
23:07:04 <ddarius> @wn supporating
23:07:07 <lambdabot> No match for "supporating".
23:07:26 <ddarius> The 'o' did seem wrong.
23:08:16 <crash[`]> good evening haskellers
23:08:21 <ezyang> evening crash
23:09:16 <Saizan> good morning to you
23:11:50 * mwc checks window, % date
23:11:58 <mwc> good morning crash[`]
23:14:53 <copumpkin> is there a nice way to represent graphs as fixpoints of functors?
23:14:59 <copumpkin> seems hard, in general
23:15:02 <copumpkin> trees are obviously easy
23:18:36 <crash[`]> copumpkin: isn't a tree just a special case of a graph?
23:18:47 <copumpkin> yeah
23:19:40 <crash[`]> what makes it more difficult then?
23:19:52 <procyon112> I have no hoogle
23:20:00 <copumpkin> downforeveryoneorjustme.com
23:20:02 <crash[`]> procyon112: see a doctor about that :P
23:20:15 <copumpkin> crash[`]: um, the fact that it's more general? :P
23:20:36 <crash[`]> :P
23:21:02 <procyon112> I don't care if It's down for everyone... I want to know if someone is fixing it.
23:21:29 <Saizan> none here
23:21:34 <copumpkin> procyon112: it's hard to say, but hoogle is open source and is something you can install on your own computer if you really care about it
23:22:10 <m0nkfish> surely there is a different hoogle
23:22:12 <procyon112> Oh, I care about it :)  Never needed to think about hosting it before though :)
23:22:24 <copumpkin> I mean, you can just run it as a local service
23:22:33 <copumpkin> or just use the one
23:22:34 <crash[`]> procyon112: if it's down for just you, then that doesn't mean it's a problem on their end
23:22:37 <copumpkin> @hoogle unsafeCoerce
23:22:38 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:22:47 <crash[`]> but it is down for everyone it seems
23:22:58 <Saizan> it's an internal server error.
23:23:07 <procyon112> lol.  cabal install hoogle works :)
23:23:16 <procyon112> I love cabal
23:23:27 <Jafet> ...until hackage goes down
23:24:02 <procyon112> Yeah.. and I doubt cabal install hackage works
23:24:11 <Jafet> It's like a charlie chaplin show, someone has to be writhing on the floor at all times
23:24:37 <crash[`]> cabal install cabal
23:24:45 <procyon112> @hoogle (a->b)->m a->m b
23:24:46 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
23:24:46 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
23:24:46 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:25:02 <crash[`]> Will cabal do full updates again sometime?
23:25:19 <crash[`]> er, I guess I mean for Haskell Platform
23:28:08 <procyon112> I doubt it will be able to do anuthing with GHC
23:28:12 <ezyang> "cabal install cabal-install" so meta!
23:28:37 <copumpkin> you'll probably need --reinstall
23:28:56 <crash[`]> I mean with regard to the message from `cabal upgrade`
23:29:06 <ezyang> copumpkin: Doesn't the message say "To upgrade, run: cabal install cabal-install"
23:29:18 <crash[`]> ezyang: you are correct sir
23:29:47 <ezyang> whee I get to revamp both my parsing and error handling models in this app
23:30:27 <crash[`]> you can do it!
23:31:36 <procyon112> Ok... I want fmap for either... Is either an arrow?  Can I (a->b)->Either c a->Either c b with (^<<)?
23:31:51 <Saizan> crash[`]: good question, maybe with the new package db in ghc 6.12 cabal upgrade won't screw your installation so badly anymore :)
23:31:52 <crash[`]> > take 10 $ repeat $ cycle ["You can do it!", "Yeah, dog!", "wooo!"]
23:31:53 <lambdabot>   [["You can do it!","Yeah, dog!","wooo!","You can do it!","Yeah, dog!","wooo...
23:31:54 <ezyang> procyon112: not by default
23:32:29 <procyon112> Well, there's got to me a  (a->b)->Either c a->Either c b  doesn't there?
23:32:43 <kmc> :t (|||)
23:32:45 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
23:32:53 <kmc> :t (+++)
23:32:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:32:55 <Saizan> > fmap (+1) (Left ())
23:32:56 <lambdabot>   Left ()
23:33:03 <Saizan> > fmap (+1) (Right 1)
23:33:05 <lambdabot>   Right 2
23:33:10 <Saizan> procyon112: why not just use fmap?
23:33:14 <kmc> :t (+++) id
23:33:16 <lambdabot> forall b b' c'. (b' -> c') -> Either b b' -> Either b c'
23:33:25 <procyon112> fmap negate (Right 5)
23:33:25 <kmc> :t (id +++)
23:33:27 <lambdabot> forall b b' c'. (b' -> c') -> Either b b' -> Either b c'
23:33:34 <procyon112> > fmap negate (Right 5)
23:33:36 <lambdabot>   Right (-5)
23:33:45 * ezyang hits himself. No /monad/ instance by default 
23:34:09 <procyon112> wtf... been trying that every which way from sunday and it was compile error... going to go look again...
23:34:44 <crash[`]> wtf indeed!
23:35:12 <ezyang> wait, no, you don't a functor instance by default either
23:35:16 <ezyang> lambdabot is just on crack
23:35:21 <Saizan> procyon112: you've to import Control.Monad.Instances
23:35:38 <Saizan> lambdabot simply imports some modules :)
23:35:55 <ezyang> i.e. "on crack" :-P
23:36:10 <Saizan> it'd be boring with only Prelude
23:36:33 <ezyang> it's true.
23:36:52 <ray> > fmap (fmap negate) [Left 5, Right 5]
23:36:54 <lambdabot>   [Left 5,Right (-5)]
23:37:32 <crash[`]> > fmap (fmap (fmap negate)) Left [Left 5, Right 5]
23:37:33 <lambdabot>   No instance for (GHC.Show.Show (f a))
23:37:33 <lambdabot>    arising from a use of `M1333596106...
23:37:55 <procyon112> Control.Monad.Instances did it.  Damn imports.
23:38:16 <procyon112> Thank's much ezyang
23:38:54 <ezyang> (thank Saizan)
23:39:05 <procyon112> Someday Haskell' won't let us have Monads without functors. :(
23:39:08 <ray> @instances or something
23:39:09 <lambdabot> Couldn't find class `or something'. Try @instances-importing
23:39:13 <procyon112> aye.  Thanks Saizan
23:39:16 <ray> @instances Functor
23:39:17 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:39:24 <kmc> i thought Monad was already a subclass of Functor
23:39:24 <crash[`]> @instances-importing
23:39:25 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
23:40:18 <ray> if overlapping instances were allowed, you could have something like instance Monad m => Functor m where
23:40:23 <ray> which is more like the real relationship
23:40:25 <procyon112> How to do that in GHCI though?  Isn't GOA dead?
23:41:27 <procyon112> I really hate having to jump on IRC to use a REPL tool.
23:41:48 <Jafet> cabal install lambdabot
23:43:46 <Jafet> Do you think it's a good idea for languages to require that programs specify the language version?
23:44:02 <ezyang> no.
23:44:02 <Jafet> lilypond does this for example, but I don't know of any programming language that does
23:44:21 <ezyang> Yeah. I find it extremely irritating
23:44:54 <Berengal> HTML and XML does it
23:45:12 <ezyang> "They're doing away with it"
23:45:16 <ezyang> HTML at least.
23:45:31 <Berengal> In 5?
23:45:40 <ezyang> yup
23:45:42 <Jafet> ezyang, why not?
23:45:52 <procyon112> I think it's fine if the language does not want to retain backwards compatibility.  It should maintain shabang aliases though if they do that.
23:45:54 <kmc> we now have a standard way to specify the language features you need, beyond H98
23:46:11 <Jafet> Oh yeah, {- LANGUAGE -} or something
23:46:21 <Berengal> {-# #-}
23:46:56 <Jafet> .oO( So which standard is it from...? )
23:46:56 <ezyang> Actually, I think my irritation with Lilypond's mechanism is their failure to have actually put any thought into the versioning scheme
23:47:06 <trofi> what encoding hscolour expect haskell sources to be?
23:47:14 <trofi> utf-8 of iso-8859-1?
23:47:14 <ezyang> and I don't mind sticking 1.0 in my XML documents, since it happens so damn often
23:47:17 <kmc> {-# LANGUAGE NinjaPatterns, RankInfinityTypes #-}
23:48:19 <Jafet> kmc, but that seems to not further the purpose of compatibility. Like C pragmas
23:48:26 <Berengal> Does Haskell 2010 that LANGUAGE pragmas unknown to the compiler should be ignored? Or was that something else?
23:48:33 * Berengal checks
23:49:11 <kmc> Jafet, it means you have a standard way to ask for an extension no matter what implementation you're using
23:49:21 <Berengal> "An implementation is not required to respect any pragma and any pragma can be ignored if an implementation is not prepared to handle it. However, implementations are strongly encouraged to support the LANGUAGE pragma described below as there are many language extensions being used in practice."
23:49:26 <procyon112> lambdabot failed to build... same as always.  libncurses this time.
23:49:27 <kmc> whereas -fglasgow-exts was ghc-specific obviously
23:50:17 <Berengal> It says "can ignore", which doesn't imply "must ignore". GHC bails on unknown pragmas
23:51:20 <trofi> bails == skips?
23:51:32 <Berengal> No, it refuses to compile the module
23:52:25 <trofi> ah, i thought about '{-#' pragmas in general
23:52:26 <Jafet> I imagined lilypond's use of version strings would be so that it could handle different language versions, but it just didn't do anything when encountering an input file from a different version. It made me sad.
23:54:29 <procyon112> @instances Either
23:54:30 <lambdabot> Couldn't find class `Either'. Try @instances-importing
23:54:38 <Saizan> procyon112: you install ncurses-dev or something like that via your distro, if you're on windows i think you're screwed
23:54:50 <Saizan> however lb responds to private messages
23:54:54 <procyon112> @instances-importing Either
23:54:55 <lambdabot> Couldn't find class `Either'. Try @instances-importing
23:55:09 <ski> @instances Functor
23:55:11 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:55:19 <procyon112> You're always screwed on windows.
23:55:23 <crash[`]> that's ugly :(
23:56:26 <toast-opt> hmm, this doesn't work:  f (x :: Int) = x+1
23:56:41 <ski> enable `PatternSignatures' ?
23:56:47 <toast-opt> where should i put annotations if i only want to annotate some args?
23:56:56 <Saizan> toast-opt: on their use
23:57:04 <Saizan> f x = (x :: Int) + 1
23:57:12 <toast-opt> ok, so just on the first use is fine?
23:57:23 <Saizan> yeah
23:57:24 <toast-opt> thx
23:57:37 <Saizan> or you can enable PatternSignatures and do what you were trying
23:57:55 <Saizan> which now is called ScopedTypeVariables, iirc
