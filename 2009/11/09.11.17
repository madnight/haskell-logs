00:00:05 <ivanm> so happy uses a one-letter extension?
00:00:07 <lispy|web> Interestingly, if I 'cabal install happy' it will install happy but not register a package named happy
00:00:18 <lispy|web> ivanm: yeah, either .y or .ly
00:00:26 <lispy|web> .ly is probably literate happy
00:00:27 <ivanm> lispy|web: it's not a lib AFAIK...
00:00:29 <chrisdone> ivanm: do you know that chrome is based on webkit?
00:00:33 <yitz> cjs pasted a parser written using regexes. ksf recommended using parser combinators instead - an excellent recommendation.
00:00:41 <ivanm> chrisdone: vaguely recall something on those lines
00:01:09 <yitz> what does dolio want?
00:01:30 <dolio> dolio wants what dolio wants, you know what dolio's saying?
00:01:42 <lispy|web> ivanm: cabal list happy says: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12218#a12218
00:01:47 <chrisdone> fix wants dolio
00:01:48 * yitz feels very intimidated
00:02:01 <ivanm> lispy|web: yeah, that only lists libraries
00:02:07 <ivanm> lispy|web: since it gets the info from ghc-pkg
00:02:10 <lispy|web> aaaah
00:02:19 <ivanm> (that's what I've figured out anyway)
00:02:29 <ivanm> lispy|web: there's a proposal to add a world-file ala gentoo to cabal-install
00:02:32 <lispy|web> So you can't make your package depend on cabal-installable progams
00:02:39 <chrisdone> > fix (++" wants") "dolio"
00:02:40 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
00:02:40 <lambdabot>         against inferr...
00:02:45 <ivanm> lispy|web: only on libraries
00:02:49 <chrisdone> daw =(
00:03:15 <Axman6> uh oh
00:03:21 <Axman6> oh, netsplit over
00:03:49 <sohum> @src (->) return
00:03:50 <lambdabot> return = const
00:04:16 <ivanm> @src (->) (>>=)
00:04:17 <lambdabot> f >>= k = \ r -> k (f r) r
00:04:44 <lispy|web> @src ([]) (>>=)
00:04:44 <lambdabot> Source not found.
00:04:49 <lispy|web> @src ([a]) (>>=)
00:04:49 <lambdabot> Source not found. Sorry.
00:04:51 <yitz> > "dolio" ++ fix (++ " wants")
00:04:51 <dolio> frisby seems like an interesting set of parsers, but it's String only, apparently.
00:04:54 <lambdabot>   mueval-core: Time limit exceeded
00:04:55 <lispy|web> @src [a] (>>=)
00:04:56 <lambdabot> Source not found. My mind is going. I can feel it.
00:04:57 <sohum> @src [] (>>=)
00:04:57 <lambdabot> xs >>= f     = concatMap f xs
00:05:02 <ivanm> lispy|web: just []
00:05:08 <yitz> > "dolio" ++ fix ("wants " ++)
00:05:09 <lambdabot>   "doliowants wants wants wants wants wants wants wants wants wants wants wan...
00:05:16 <lispy|web> oh, ([]) != [], silly me
00:05:23 <yitz> > "dolio " ++ fix ("wants " ++)
00:05:23 <lambdabot>   "dolio wants wants wants wants wants wants wants wants wants wants wants wa...
00:05:38 <dolio> You can save one character by using " wants"
00:05:42 <ivanm> > "dolio" ++ cycle " wants"
00:05:43 <lambdabot>   "dolio wants wants wants wants wants wants wants wants wants wants wants wa...
00:05:53 <ivanm> even more characters saved!
00:05:54 <sohum> > fix "dolio wants what "
00:05:55 <lambdabot>   Couldn't match expected type `a -> a'
00:05:56 <lambdabot>         against inferred type `[GHC.T...
00:06:03 <sohum> > fix ("dolio wants what " ++)
00:06:05 <lambdabot>   "dolio wants what dolio wants what dolio wants what dolio wants what dolio ...
00:06:15 <sohum> :t cycle
00:06:17 <lambdabot> forall a. [a] -> [a]
00:06:25 <sohum> huh. I thought cycle was a -> [a]
00:06:54 <Axman6> that's repeat
00:06:54 <dolio> That's repeat.
00:06:56 <sohum> right
00:07:01 <Axman6> jynx
00:07:05 <lispy|web> > fix $ dolio where dolio = "dolio" ++ cycle " wants"
00:07:06 <lambdabot>   <no location info>: parse error on input `where'
00:07:17 <yitz> > fix ("dolio wants " ++) . drop 6
00:07:18 <lambdabot>   Couldn't match expected type `a -> b'
00:07:18 <lambdabot>         against inferred type `[GHC.T...
00:07:23 <yitz> > fix $ ("dolio wants " ++) . drop 6
00:07:24 <lambdabot>   "dolio wants wants wants wants wants wants wants wants wants wants wants wa...
00:07:28 <lispy|web> anyway, I'm off to sleep
00:07:42 <Elly_> what the fuck is going on?
00:07:52 <Elly_> that was like a netsplit but much cooler
00:07:52 <Axman6> netsplit i think
00:07:54 <Axman6> @users
00:07:55 <lambdabot> Unknown command, try @list
00:07:59 <Axman6> urgh!
00:08:52 <yitz> who is in charge of lambdabot's code these days?
00:09:11 <Axman6> no idea... but i dislike them quite a lot at the moment
00:09:25 <medfly> users hasn't been around for a while!
00:09:35 <Axman6> it really should be
00:09:48 <yitz> Axman6: the @seen plugin was leaking memory like a sieve, unfortunately
00:09:56 <Axman6> bah
00:09:57 <bastl> morning.
00:10:20 <sohum> :t fix
00:10:22 <lambdabot> forall a. (a -> a) -> a
00:10:26 <sohum> :t Maybe
00:10:27 <lambdabot> Not in scope: data constructor `Maybe'
00:10:28 <sohum> :t Just
00:10:29 <lambdabot> forall a. a -> Maybe a
00:10:39 <sohum> ah, right, cyclic
00:10:43 <bastl> can anyone point me to something explaining haskells/ghcs package infrastructure? I have to prepare a talk on that (cabal, haddock etc...)
00:11:28 <cjs> yitz: my parser didn't use regexes....
00:11:49 <yitz> bastl: the cabal docs are part of the ghc documentation. the cabal website has some links. what are you missing.
00:11:55 <cjs> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12217#a12217 is very simple and self-contained, but I think there's probably a more clever way to do it.
00:11:57 * yitz blushes. sorry cjs.
00:12:18 <yitz> cjs: i hit you right at the beginning of a painful netsplit, too.
00:12:27 <rntz> I have a program, which, given a sufficiently large input, runs out of stack space. The program is too large for me to inspect all the lines of code to see where it's being non-tail-recursive; is there some way to get ghc to tell me what function is causing the overflow?
00:12:57 <bastl> yitz: the overall idea: Is cabal part of ghc? are packages part of haskell 98 what is a "package" etcpp. I guess there are precise specs somewhere.
00:13:16 <bastl> s/98/98\?/
00:13:48 <yitz> bastl: cabal is a separate library, hosted (recursively, sort of) on hackage. theoretically, it works with every haskell compiler.
00:14:21 <yitz> bastl: but in practice, it interacts very closely with the ghc-pkg command, which is part of ghc.
00:14:24 <bastl> and packages: are they ghc specific ?
00:15:00 <yitz> bastl: no, it's supposed to work for all compilers. but most of the effort has gone into ghc integration, at both ends.
00:15:20 <bastl> and that is explained where?
00:15:28 <yitz> ghc documentation
00:15:51 <bastl> so it comes from ghc as a proposal, and other compilers should adopt it ?
00:15:54 <bastl> nice :-)
00:15:56 <yitz> e.g., go to the ghc website and click on the documentation link.
00:16:07 <yitz> @google haskell cabal
00:16:08 <lambdabot> http://www.haskell.org/cabal/
00:16:08 <lambdabot> Title: The Haskell Cabal
00:16:54 <yitz> bastl: well, no, it wasn't forced down anyone's throat. the process was very open.
00:17:50 <yitz> bastl: it's a nice system. every compiler would like it to be fully integrated. but each has it's own resource limitations and priorities.
00:18:06 <yitz> ghc has far more resources than any other compiler.
00:18:51 <bastl> thats my confusion: haskell is not ghc in theory, but in practice it is ...
00:19:30 <yitz> bastl: the one who has done much of the work is dcoutts_, who is often found on this channel.
00:20:32 <yitz> bastl: we all hope that the other compilers will continue to grow and improve, too. feel free to work on any of them. :)
00:21:02 <yitz> bastl: for instance, if you want to write iPhone apps in Haskell, the jhc compiler is currently the way to go.
00:21:07 <Cale> bastl: Well, it takes a lot of effort to implement this stuff, and there are only so many people.
00:21:49 <yitz> bastl: afaik yhc still has the lead in compiling Haskell to JavaScript.
00:22:22 <bastl> im just confused from time to time, what is ghc-spec and what is haskell-spec...
00:23:03 <yitz> bastl: jhc creates executables that are very small and very fast. but it's far less robust than ghc, again due to having less resources.
00:23:45 <dolio> jhc is one guy. ghc is, like, three or four. :)
00:24:05 <medfly> hehe
00:24:12 <medfly> a guy with 3-4 heads :)
00:24:18 <yitz> bastl: any compiler than wants to support the cabal's package spec and provide a way to register packages with that compiler, cabal will happily cooperate.
00:24:25 <bastl> medfly: a hydra?
00:24:33 <medfly> I have a strange imagination :)
00:25:05 <yitz> bastl: also, cabal will provide compiler-specific compilation options.
00:25:44 <yitz> dolio: i think there are other people who contribute to jhc, though john is definitely dominant.
00:26:09 <dolio> Yeah, that's true.
00:27:24 <yitz> medfly: it's 3 or 4 guys each with 3 or 4 heads, and several more whose additional heads are just beginning to bud.
00:27:51 <medfly> hehe
00:28:14 <yitz> medfly: besides the heads, they also have the advantage of being paid full-time salaries by microsoft to work on ghc.
00:28:40 <dolio> Yes, that's also true.
00:28:44 <Beelsebob> well, not to work in ghc
00:28:52 <Beelsebob> but to do lots of research that often involves ghc
00:29:15 <yitz> ok, but it ends up being the same thing.
00:29:22 <Beelsebob> yup
00:29:56 <medfly> why by Microsoft?
00:30:07 <Beelsebob> because MS research is mahoosive
00:30:12 <Beelsebob> and covers a lot of things you wouldn’t expect
00:30:53 <yitz> i think it's fair - haskell has definitely contributed a lot back to microsoft
00:31:00 <Beelsebob> indeed
00:31:01 <medfly> it has?
00:31:04 <Beelsebob> F#
00:31:07 <Beelsebob> a lot of C#
00:31:08 <medfly> oh.
00:31:19 <yitz> erik meijer himself
00:32:07 <yitz> and this work has had subtle impact throughout the microsoft culture.
00:32:15 <Twey> Heh
00:32:26 <Twey> ‘One Erik, slightly used, willing to trade’
00:33:17 <Beelsebob> it has some direct impacts too
00:33:29 <Beelsebob> just “we know how to compile crazy language feature x”
00:33:49 <yitz> yeah, C# has also picked up a lot
00:34:40 <yitz> and type-level functional programming in C++ *ducks*
00:34:48 <Beelsebob> haha
00:35:02 <dolio> Even VB hasn't escaped.
00:35:41 <pikhq> yitz: Would be much nicer if they had a shorter lambda than "template <class T> struct { ... };"...
00:35:47 * Twey chuckles.
00:35:49 <yitz> hehe
00:36:33 <yitz> pikhq: work on shortening the error messages first
00:37:30 <yitz> dolio: what has VB picked up?
00:37:48 <dolio> Well, it has the linq stuff too, of course, to some degree.
00:38:21 <yitz> didn't know that. interesting.
00:38:47 <dolio> I seem to recall some sort of HTML manipulation via pattern matching thing I heard with regard to it a while back, too, which looked suspiciously like Meijer's Haskell Server Pages stuff.
00:40:01 <dolio> I don't keep tabs on VB that closely, though.
00:40:41 <dolio> But I'm pretty sure Meijer was working in the VB area at some point.
00:41:26 <dolio> Moreso than on C#, even.
00:42:52 <medfly> this conversation makes me think Erik Meijer is like the god of Haskell.
00:42:58 * medfly has to look up who he is.
00:43:19 <Beelsebob> no, the god of Haskell is Oleg
00:43:50 <medfly> does Oleg have a Wikipedia article with a picture?
00:44:00 <medfly> which is clearly the measure of importance
00:44:45 <Adamant> medfly: an Oleg is a measure of programming skill
00:45:11 <medfly> ah
00:45:13 <Twey> We find it more useful to use the µOleg, though
00:45:15 <Adamant> medfly: mostly you figure out what fraction of a Oleg you will need to complete a task
00:45:17 <Adamant> yes
00:45:21 <medfly> hahaha
00:45:23 <Beelsebob> where 1 oleg is defined as “can do *everything* with types, even when not in a turing complete type system”
00:46:10 <Veinor> medfly: there was something I was going to say about pictures in wikipedia articles
00:46:32 <medfly> what were you going to say?
00:46:34 <yitz> an oleg represents the amount of equivalency between types, folds, and continuations
00:46:39 <Elly> I thought the uOleg was the unit of macro system abuse
00:46:40 <Veinor> I don't remember :(
00:46:48 <Veinor> oh
00:46:51 <medfly> aww
00:46:53 <medfly> did you remember it?
00:46:56 <Veinor> the reason they're so anal about it is to protect themselves from lawsuits
00:47:04 <Twey> Wha'?
00:47:09 <Twey> Oh
00:47:09 <medfly> pictures on Wikipedia.
00:47:12 <Twey> The legal issues.
00:47:18 <Veinor> because obviously you can't pull a random picture and use it
00:47:35 <medfly> no, like, there should be an Oleg article with a picture of him. having something like that is a measurement of importance.
00:47:54 <Adamant> Oleg would have to submit it and that would take time away from programming
00:47:58 <Veinor> I know, I know
00:48:07 <Adamant> I think you need to adjust your value system, not his :P
00:48:09 <Veinor> oleg or someone else who'd be willing to release it under CC-BY-SA
00:48:12 <medfly> oh, reminds me of this story I heard on the newspaper
00:48:27 <Veinor> or a less restrictive license
00:48:29 <ksf> aaaaah espresso
00:48:31 <medfly> of this thief that was upset the police publicised a bad picture of him, so he sent them a better one.
00:48:33 <Warrigal> What's his full name, again?
00:48:38 <Veinor> or the GFDL, but that's deprecated
00:48:47 <yitz> Adamant: he could generate it. without even using the IncoherentInstances extension.
00:49:05 <Veinor> what does incoherentinstances do? O_o
00:49:45 <yitz> @google IncoherentInstances
00:49:45 <lambdabot> No Result Found.
00:49:57 <yitz> urgh, one minute.
00:50:15 <medfly> @google incoherentInstance
00:50:16 <lambdabot> No Result Found.
00:50:20 <medfly> had to try :)
00:50:48 <Veinor> does anybody here speak hebrew?
00:51:10 <Warrigal> I know someone who at least sort of knows Hebrew who isn't here right now. Why?
00:51:22 <Veinor> http://a1.twimg.com/profile_background_images/33980684/n1327773318_3103_2649.jpg
00:51:23 <medfly> Veinor, I do.
00:51:25 <Veinor> What does this say?
00:51:40 <medfly> it's a bible verse about tolerance
00:52:10 <Veinor> which?
00:52:22 <Veinor> I have to know!
00:53:02 <medfly> "Love thy neighbor as yourself" (Hebrew: "ואהבת לרעיך כמוך") according to Wikipedia
00:53:21 <Veinor> ah, thank you
00:53:26 <medfly> but that's a funny way of interpreting it :)
00:53:38 * simplicio kisses himself
00:54:53 <ksf> you know what, non-mmaped io is insanity.
00:55:33 <Veinor> if you're curious: http://twitter.com/jewishgaydads
00:59:08 <ksf> is there an mmap binding somewhere in the ghc libs?
00:59:42 <mmmdonuts> In hackage: http://hackage.haskell.org/package/mmap
00:59:55 <ksf> I don't have access to hackage for the shootout
01:00:06 <yitz> Veinor: ok, it's defined near the end of section 7.6.3.3 here: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls
01:00:11 <ksf> I can write a quick foreign import, but prefer not to
01:00:22 <yitz> (talking about incoherent instances)
01:03:08 <yitz> @google -XIncoherentInstances
01:03:08 <lambdabot> No Result Found.
01:03:34 <yitz> humph. google's going downhill.
01:05:45 <Veinor> @google cherry pie
01:05:47 <lambdabot> http://www.youtube.com/watch?v=GdDxz2bkfhE
01:05:47 <lambdabot> Title: YouTube - Warrant-Cherry Pie
01:05:54 <Veinor> nah, I think it's more @google going downhill
01:05:59 <mmmdonuts> @google IncoherentInstances
01:06:00 <lambdabot> No Result Found.
01:06:05 <Raevel_> that query just proved that there is no web page that does not contain XIncoherentInstances
01:06:13 <mmmdonuts> @google XIncoherentInstances
01:06:14 <lambdabot> No Result Found.
01:06:27 <Veinor> incoherentinstances returns ghits for 'incoherent instances'
01:06:32 <yitz> @google "-XIncoherentInstances"
01:06:32 <lambdabot> No Result Found.
01:07:03 <mmmdonuts> @google is lying
01:07:05 <lambdabot> http://www.cnn.com/2003/LAW/06/06/findlaw.analysis.dean.wmd/
01:07:05 <lambdabot> Title: CNN.com - Is lying about the reason for a war an impeachable offense? - Jun. 6,  ...
01:07:45 <tensorpudding> @google never going to give you up
01:07:47 <lambdabot> http://www.lyricsfreak.com/r/rick+astley/never+gonna+give+you+up_20116173.html
01:07:48 <lambdabot> Title: Rick Astley | Never Gonna Give You Up lyrics
01:07:49 <Veinor> @google 'incoherent instances'
01:07:50 <lambdabot> No Result Found.
01:08:03 <Veinor> @google is bugged, yeah
01:08:04 <lambdabot> No Result Found.
01:08:11 <tensorpudding> @google google
01:08:12 <lambdabot> http://www.google.com/
01:08:12 <lambdabot> Title: Google
01:08:24 <mmmdonuts> @google lambdabot
01:08:25 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
01:08:26 <lambdabot> Title: Lambdabot - HaskellWiki
01:08:31 <Veinor> oh god, go to google.com and put in 'the belgians'
01:08:34 <Veinor> then look at the suggestions
01:08:45 <tensorpudding> @google elgoog@
01:08:47 <lambdabot> http://elgoog.rb-hosting.de/
01:08:52 <Veinor> it's like poetry
01:09:42 * mmmdonuts hides his hands behind his chair
01:09:48 <c_wraith> the suggestions for "why c" are amusing
01:10:11 <Veinor> 'is that a'
01:10:21 <ksf> gragh.
01:10:21 <Veinor> also 'why is'
01:10:43 <ksf> why, oh why does System.Io.MMap take filepaths as argument?
01:10:51 <Veinor> also christianity is/judaism is/islam is
01:11:01 <ksf> ...unix is sane enough not to have a filename for stdout.
01:11:22 <Twey> You want to mmap stdout?
01:11:37 <ksf> yep
01:11:42 * Twey scratches his head.
01:11:45 <ksf> never did it before
01:11:47 <Twey> Does that even work?
01:11:53 <ksf> it should
01:12:07 <Twey> I can't really see how a terminal would deal with it
01:12:08 <Veinor> unrelated
01:12:09 <Veinor> http://en.wikipedia.org/wiki/File:Wikipedia_Nigga_Final_Master.ogg
01:12:56 <c_wraith> I'm not seeing how you'd mmap stdout if it wasn't redirected to something
01:13:16 <ksf> well it is redirected
01:13:23 <mux> you could mmap /dev/stdout on unices that have it
01:13:28 <mux> or /dev/fd/1
01:13:41 <mux> though I don't quite see how  that would be useful
01:14:01 <ksf> not writing stuff twice
01:14:22 <ksf> currently, I'm filling a buffer and outputting it with hPutBuf
01:15:12 <mux> you have dup() and dup2() if you want to output on two fds at once
01:15:31 <ksf> only one needed.
01:15:46 <ksf> the c entry is using fwrite_unlocked
01:19:10 <ksf> maybe I should just switch to a bigger buffer size, 61 bytes is quite small for 25M
01:24:39 <voidprayer> bastl, how is yhc now? the wiki says its under develop.
01:24:57 <voidprayer> bastl, should it meet most requirements?
01:25:17 <bastl> voidprayer: im not interested in yhc
01:27:50 <bastl> Very Offtopic: any emacs-mage here, that knows the shortcut to invoke "make" (Tools-Compile)?
01:28:48 <opqdonut> bastl: bind M-x compile to something
01:29:04 <opqdonut> it's not bound by default unfortunately
01:29:37 <bastl> how do i bind something to a key ?
01:30:07 <simplicio> :nmap <F4> :make<CR>
01:30:16 * bastl was a vim addict.
01:30:36 <bastl> *sigh*
01:30:38 <tensorpudding> was?
01:30:51 <bastl> switch beacuse of auctex ...
01:31:01 <tensorpudding> I thought C-c C-c was a shortcut to make
01:31:23 <bastl> that invokes auctex compile ...
01:31:43 <bastl> ok, getting too offtopic. ill google ...
01:31:54 <tensorpudding> or wait, yes, you are right
01:31:59 <tensorpudding> also, you could ask #emacs
01:39:30 <tensorpudding> bastl: there is a section in the FAQ on it
01:39:44 <tensorpudding> C-h C-f over there, and check out the Key Bindings section
01:42:17 <bastl> cool.
01:42:47 <bastl> thanks :-) Sometimes asking simple OT things ona friendly channel is a good thing :-)
01:44:37 <tensorpudding> heh
01:45:07 <tensorpudding> talking about emacs on #emacs is sometimes more off-topic than talking about it here
01:45:20 <bastl> hehe
01:45:42 <ksf>     Exotic pattern not (yet) handled by Template Haskell !ceil
01:47:05 <ksf> :t seq
01:47:19 <ksf> lambdabooooooot!
01:48:01 <Botje> @botsnack
01:48:01 <lunabot>  :o
01:48:08 <Botje> ,t seq
01:48:09 <lunabot>  luna: Couldn't match expected type `(a1 -> t -> t) -> a'
01:48:20 <Botje> ,type seq
01:48:21 <lunabot>  luna: parse error on input `type'
01:48:27 <Botje> silly lunabot :(
01:48:59 <tensorpudding> ,t id
01:49:00 <lunabot>  luna: Couldn't match expected type `(a1 -> a1) -> a'
01:49:16 <tensorpudding> silly bo
01:49:19 <tensorpudding> @bot
01:49:19 <lunabot>  :o
01:49:21 <Botje> ,help
01:49:25 <lunabot>  type of an expression:      , [$ty| \x -> x |]
01:49:25 <lunabot>  get info for a type/class:  , src ''Monad
01:49:25 <lunabot>  get info for a var/con:     , src 'fix
01:49:36 <Botje> oh.
01:49:43 <tensorpudding> , [$ty| id |]
01:49:45 <Botje> , [$ty| seq |]
01:49:46 <lunabot>  forall a . a -> a
01:49:48 <lunabot>  forall t a . a -> t -> t
01:49:50 <Botje> brr.
01:49:56 <tensorpudding> what notion of syntax is that
01:50:31 <dolio> Quasiquoting.
01:50:38 <EnglishGent^afk> @hoogle (Monad m) => m a -> (a -> m [a]) -> m [[a]]
01:50:55 <tensorpudding> lambdabot est mort, vive lambdabot
01:54:56 <dolio> Evidently, no one was particularly excited by my mail about (im)predicativity on glasgow-users.
01:57:12 <fasta> Is there a function which runs at most N IO actions in parallel somewhere untiil they are all done from a list of IO actions?
01:57:21 <fasta> until*
01:57:29 <Icewing> How do I create a class with the kind * -> * so that if F belongs to the class and x belongs to class A then F x belongs to class B?
01:58:33 <opqdonut> Icewing: simply: instance (A x, Class f) => B (f x) where ...
01:58:58 <opqdonut> :t fmap succ
02:00:12 <Icewing> I want a class with that condition
02:00:56 <opqdonut> well then say class
02:01:19 <opqdonut> but you probably don't really want that
02:01:57 <dcoutts> bastl: I can answer Qs on the Cabal package architecture
02:02:38 <Icewing> I think I've said class and yes, I want that.
02:03:32 <bastl> dcoutts: cool. ghc-pkg is a front-end to package.conf, a DB of packages. right? (like dpkg?)
02:04:05 <bastl> So one can build pacakges without cabal.
02:04:13 <dcoutts> bastl: yes, though perhaps more comparable to pkg-config than dpkg
02:04:23 <dcoutts> unlike dpkg, ghc-pkg does not track installed files
02:04:32 <dcoutts> it's just a registry of package meta-data
02:04:35 <bastl> ok
02:04:45 <dcoutts> enough to be able to compile other things against it
02:04:57 <dcoutts> so in particular, progs/tools are not registered, only libs
02:05:06 <bastl> and cabal-infrastructure does what? manage dependencies?
02:05:28 <bastl> allowing for executables?
02:05:33 <bastl> upload/download.
02:05:49 <bastl> it's a big beast :-)
02:06:02 <dcoutts> bastl: there's a vague diagram here: http://haskell.org/cabal/talks/HIW-2009-cabal-status.pdf
02:06:15 <opqdonut> Icewing: ah, actually the context in a class declaration can only be of the form "class A x => B x"
02:06:22 <opqdonut> according to the report, dunno if ghc loosens that
02:06:46 <dcoutts> bastl: and this gives a general description of the relationship between Cabal and other bits: http://haskell.org/cabal/talks/HS-2008-batteries-paper.pdf
02:08:05 <ksf> why can't I write instances for nonlifted types?
02:08:35 <dcoutts> ksf: because they're the wrong kind
02:08:55 <bastl> dcoutts: I like the architecture ideas for cabal 2
02:09:12 <ksf> well, issue9 can do it.
02:09:14 <bastl> solves exactly the things im confused about.
02:09:52 <dcoutts> bastl: so Cabal is both a package spec, and also a default implementation of that spec in the form of a build system (the "Simple" build system)
02:10:24 <dcoutts> ksf: does go have type classes?
02:10:24 <bastl> so ghc-pkg uses the "cabal package-spec" ?
02:10:37 <bastl> and cabal-install is the build system.
02:10:40 <bastl> i see
02:10:52 <ksf> dcoutts, it has.
02:10:56 <ksf> they call them interfaces.
02:11:30 <dcoutts> bastl: no, they're somewhat different. .cabal files are descriptions of source packages where as the installed package info files that ghc-pkg takes are simpler descriptions of installed packages.
02:11:39 <dolio> It has structural type classes, no?
02:11:56 <ksf> rather methodical.
02:12:15 <ksf> that is, you have to give all methods for an interface before a type is considered to implement it.
02:12:26 <ksf> that's also all the polymorphism they have.
02:12:36 <dolio> Right, it's like structural typing, rather than nominal typing.
02:12:51 <dcoutts> bastl: the Cabal lib contains the "Simple" build system, and the cabal tool provides a command line interface, plus extra stuff like fetching things from hackage.
02:13:00 <bastl> dcoutts: ok. thats the record types InstalledPackageThing and PackageDescription, right?
02:13:09 <dcoutts> bastl: yep
02:13:11 <bastl> yeah, i get it slowly :-)
02:13:17 <ksf> it's quite like typeclasses, modulo the splitting up instance declarations into multiple ones issue.
02:13:37 <bastl> much easier to use than to give an (informal)  talk aout it :-)
02:13:41 <bastl> about
02:14:23 <dcoutts> bastl: see also http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/24num.pdf
02:14:29 * ksf gives up on trying to make quasiquoting and float and word8 constants work
02:15:15 <fasta> How long does it take to implement thread pools in C?
02:15:41 <fasta> In Haskell it is about 15 minutes. :)
02:15:48 <dcoutts> ksf: a problem with instances for unlifted types is that you could not mix lifted and unlifted instances
02:16:11 <dcoutts> ksf: you'd have to declare up front in the class decl the kind of the type class
02:16:54 <dcoutts> ksf: and you'd also need an extension to be able to allow polymorphism in size-indexed unlifted kinds
02:17:14 <dcoutts> ksf: unless you don't care about using type classes for abstraction
02:17:25 <ksf> argh don't anyone tell my TH is typesafe
02:17:45 <fasta> What would be nice if there was better integration between the operating system and the GHC RTS or even just the RTS ;)
02:18:07 <dcoutts> fasta: in what sense?
02:18:12 <fasta> Then you wouldn't have to worry about "too many open files" for example.
02:18:32 <dcoutts> bah, "too many open files" is an artificial problem
02:18:46 <fasta> dcoutts: all computing problems are.
02:18:51 <dcoutts> heh :-)
02:19:17 <EnglishGent> is there a way to ask what the type of a variable is *inside* a function definition? I know :t can tell me the type of function definitions themselves
02:19:36 <quicksilver> EnglishGent: no. It is occasionally annoying.
02:19:41 <fasta> dcoutts: I mean, in a perfect world there would be no Windows, Apt would have a fast data base, I a pink pony and I would have at least a few hundred crays in my backyard.
02:19:59 <EnglishGent> thanks anyway quicksilver :)
02:20:00 <quicksilver> EnglishGent: you have to reconstruct the critical parts of the expression in GHCi to get something you can :t
02:20:03 <ksf> there, it works.
02:20:16 <ksf> ...with an unhygenic macro.
02:20:30 <ksf> luckily, we don't have dynamic scope.
02:20:52 <EnglishGent> I just want it to help me understand what's going on - I've managed to do simple monadic stuff - but now I'm trying to do more complex stuff & am confused as to why some of my functions dont have the types I expect
02:21:02 <dcoutts> EnglishGent: or introduce a deliberate type error and see what the error message says the type should be :-)
02:21:30 <dcoutts> EnglishGent: if you expect it to have some type, then say so, and let the compiler explain why you're wrong
02:21:40 <dcoutts> ((expr) :: Type)
02:22:26 <EnglishGent> I've tried that dcoutts - unfortunately the error message doesnt make any sense to me
02:23:03 <EnglishGent> it says it cant construct an infinite type - I cant see why it would even want to (I know enough to know what an infinite type is, but not to know why one arises here)
02:24:54 <EnglishGent> to add to my confusion the type I want is (I think) a more restricted version of the one the compiler says it has
02:26:19 <quicksilver> EnglishGent: if it says infinite type you've probably made a simple mistake. If you paste the code + the error we'll be able to help ;)
02:27:44 <bastl> Who is responsible/developing/maintaining hackage?
02:27:51 * EnglishGent works on restoring his browser - which is currently fubared for some reason
02:28:08 <ksf> ha! I'm faster than C
02:28:32 <EnglishGent> thanks quicksilver - it might be half an hour or so before I can do that though! besides this stuff is _gradually_ beginning to make some sort of sense
02:29:20 <EnglishGent> btw - is this just me? becuase I thought I understood monads - I was using them in (albiet quite simple) code quite happily - and then I wanted to do something a little bit more complicated - and suddenly fell off a cliff understanding-wise
02:29:32 <EnglishGent> is this a common thing when trying to grok them? (serious question!) :)
02:32:14 <BONUS> EnglishGent: which monads have you used
02:32:20 <earthy> reasonably common
02:32:29 <BONUS> yeah
02:32:32 <earthy> there's a superficial layer to monads that's simple to understand
02:32:33 <ksf> couldn't TH be less restrictive wrt. top-level splices?
02:32:42 <earthy> and then you get to the subtle and deep insights
02:33:05 <BONUS> but depends on which monads you've used, whether you used mostly do syntax and such and if you used various monadic functions like liftM2, filterM, sequence, etc.
02:33:15 <quicksilver> EnglishGent: well, it might be you fell off a cliff understanding-wise, or it might just be you made a trivial error which will be obvious to you, but the error message is not enlightening
02:33:24 <quicksilver> haskell error messages are an acquired taste :)
02:33:24 <cjs> EnglishGent: have you written your own instances of Monad?
02:34:34 <fasta> Compiler bugs followed by indentation errors are the worst, the type errors are quite clear, if you can read them.
02:37:06 * ksf didn't fully and utterly grok monads until he got to terms with contravariance.
02:37:35 <ksf> I always visualize my screen is a rubber sheet and it bends outwards or inwards.
02:37:45 <fasta> "out of memory" is such a silly error message.
02:38:02 <EnglishGent> cjs - not yet, but mostly becuase I havent yet had a need
02:38:13 <fasta> Especially, because it probably means that the RTS itself was limited to some amount or the process and not the actual machine.
02:38:50 <fasta> If it would like say "you used up X amount", set this or that flag to raise it.
02:38:50 <cjs> EnglishGent: doing that may help. Or it may not. But I didn't really grok them until I started writing them. It's not hard.
02:49:19 <EnglishGent> okay - I shall see if I can think up some examples then cjs :)
02:49:41 <EnglishGent> various rl crap here - I shall be back to the haskell later :)
02:53:25 <netinho2lol> hey guys
02:53:47 <netinho2lol> what's up? (in before "the sky")
02:54:37 <netinho2lol> anyone using haddock and willing to tell me about its output?
02:54:58 <Veinor> is seq pure?
02:55:10 <Veinor> it forces the evaluation of its left argument, but is that really 'changing' it?
02:56:18 <netinho2lol> haddock only output to html?
02:56:39 <quicksilver> Veinor: yes, seq is pure.
02:56:42 <BONUS> seq is pure
02:56:53 <BONUS> it doesn't matter when you evaluate it, the result is still the same
02:57:14 <fasta> Veinor, if you evaluate thunk -> 1, you also "change" it to 1.
02:57:48 <fasta> Veinor, the whole RTS is one big pile of  non-pure stuff ;)
03:01:37 <bastl> dcoutts: How should I distiguish between cabal-installs distributional and build features, or should I regard that as one set of features? In my POV its a mixture of make/ant and apt-get.
03:01:51 <dmwit> netinho2lol: According to --help, it also does output for Hoogle and mshelp, mshelp2, and devhelp formats.
03:04:09 <dcoutts> bastl_lunch: they are distinct, in particular cabal-install supports custom (Cabal-spec-compliant) build systems
03:06:04 <Jafet> Is it advised to learn ML to read Okasaki's data structures paper, or can I just pretend it's Haskell in iambic pentameter?
03:06:18 <netinho2lol> dmwit: thanks :)
03:06:35 <quicksilver> people who reply to unrelated messages to start a new thread on a mailing list should be given a stern thrashing and 6 month internet ban
03:06:42 <dmwit> Jafet: The latter Worked For Me.
03:06:53 <quicksilver> Jafet: You should be able to muddle through ML easily enough, just remember it's strictly evaluated.
03:06:54 <Jafet> Ok
03:07:27 <dmwit> Right, when he starts mumbling about "do" and stuff, just repeat "lazy evaluation" in your head over and over.
03:07:44 <ksf> bastl_lunch, that make-like stuff you're seeing is actually either make, or ghc
03:07:54 <dmwit> 'course, his mumbles are more intelligent than my well-polished essays. =P
03:08:02 <ksf> well at least most of it.
03:08:15 <sohum> that's an awesome description
03:08:19 <ksf> it's notoriously hard to add custom preprocessor rules to cabal
03:08:20 <sohum> "Haskell in iambic pentameter"
03:15:24 <Guest19594> hello
03:15:36 <Guest19594> f\
03:17:35 <Maddas> sohum: Imagine how nice that would look together with the layout rules!
03:19:49 <sohum> :P
03:23:48 <fasta> How can I have a synchronized putStrLn? I have a lot of IO () actions and I want to see only "hello world hi there" and some random mix of that. "hi therehello world " would also be a valid output.
03:24:16 <fasta> I know there are channels, but I think it won't produce output immediately when I write to it.
03:24:26 <quicksilver> fasta: you mean you're calling putStrLn in different threads?
03:24:31 <fasta> quicksilver, yes
03:24:51 <quicksilver> either protect your output with a mutex or use a channel
03:24:52 <fasta> quicksilver, I can also call writeChan if needed.
03:25:03 <quicksilver> you are right in thinking that channels lack an instant wakeup guarantee though
03:25:11 <quicksilver> (the GHC RTS has no wakeup guarantees at all)
03:27:03 <fasta> quicksilver, so, if I do c <- newChan;  forkIO (writeChan  c "hi"); forkIO (writeChan  c "there"); infiniteLoop here; getChanContents I will never see any output, AFAIK.
03:27:45 <opqdonut> you need a separate thread that reads the chan and prints stuff
03:28:31 <quicksilver> yes, you definitely want a separate thread for Chan reading
03:28:41 <quicksilver> and my caveat remains - there is no wakeup guarantee
03:28:48 <quicksilver> things don't get printed the instant you write them
03:28:56 <quicksilver> but they get printed pretty soon in practice.
03:29:24 <fasta> opqdonut, so, when is getChanContents "done" then?
03:29:31 <fasta> It seems there is no way to "close" a channel.
03:30:04 <quicksilver> you get to choose.
03:30:16 <quicksilver> obviously, you never ever use getChanContents, which is a vile abomination.
03:30:24 <opqdonut> :D
03:30:30 <quicksilver> but you could for example use Chan (Maybe String) and the thread could die when it gets a Nothing
03:31:33 <dmwit> What's wrong with getChanContents?
03:31:43 <dmwit> That seems like the Right Thing for a fair number of applications.
03:32:25 <quicksilver> I firmly believe that interleaved IO is the source of all evil
03:33:04 <fasta> quicksilver, where is this information about lack of wake-up guarantees?
03:33:15 <quicksilver> fasta: there is no information guarantee either.
03:33:25 <fasta> quicksilver, how typical
03:33:38 <quicksilver> fasta: you may receive information about the GHC RTS on IRC, but there is no guarantee of instant information
03:33:44 <quicksilver> fasta: nor how correct it is ;)
03:34:05 <quicksilver> generally the strategy is either ask JaffaCake1
03:34:22 <quicksilver> ...or ask quicksilver, mmorrow, or some other person who has previously asked JaffaCake1
03:34:25 <quicksilver> ;)
03:34:59 <JaffaCake> ... and JaffaCake often consults The Source
03:35:24 <quicksilver> It might be nice to have a way to get wakeup guarantees into the RTS
03:35:32 <quicksilver> it would get us closer to some kind of soft realtime, I think.
03:35:50 <JaffaCake> the GC is the other big problem with RT, though
03:35:56 <quicksilver> yup.
03:35:59 <fasta> It might be nice to delete all functions which don't guarantee anything too.
03:36:21 <fasta> "This function might do bla bla bla" is useless.
03:36:38 <quicksilver> well the GHC RTS has a kind of weak progress guarantee
03:36:41 <Jafet> What kind of GC is used?
03:36:48 <quicksilver> all runnable threads will get scheduled in finite time
03:36:49 <quicksilver> I think.
03:36:58 <JaffaCake> fasta: well, your program might run to competion, or it might run out of memory: let's delete all your programs ;)
03:37:49 <JaffaCake> quicksilver: that's true, modulo a couple of corner cases
03:37:56 <JaffaCake> like non-allocating functions
03:38:57 <quicksilver> JaffaCake: which are very rare, unless we manage to improve the code generator the way some people would like to
03:39:03 <quicksilver> JaffaCake: at which point, it becomes a real problem :)
03:39:34 <JaffaCake> what kind of code gen changes are you thinking of?
03:40:09 <flux> hm, so GHC type system is turing complete (looking at the type-level brainfuck implementation), is standard Haskell 98 also?
03:40:20 <quicksilver> mmorrow's experiments in getting loop calculations to generate entirely unboxed register loops
03:40:37 <quicksilver> JaffaCake: generally, better unboxing and register use raises the risk of more code which doesn't allocate, no?
03:40:44 <quicksilver> flux: no.
03:40:55 <quicksilver> flux: you need undecidable instances
03:41:14 <JaffaCake> quicksilver: unboxing is a higher-level thing, it's done by the simplifier
03:41:38 <JaffaCake> the back-end code gen doesn't normally affect the amount of allocation
03:41:49 <quicksilver> JaffaCake: I probably meant codegen in a more general sense, covering the whole stack which could be said to generate code
03:41:57 <quicksilver> JaffaCake: whereas you have a more specific denotation ;)
03:41:58 <JaffaCake> except in small ways (e.g. we might worst-case the allocation for two branches in order to aggregate heap checks)
03:41:59 * quicksilver apologies.
03:42:22 <JaffaCake> not at all
03:43:13 <JaffaCake> AFAIK we don't have plans for the simplifier that would radically decrease allocation
03:44:35 <ivanm> where's lambdabot?
03:48:30 <FunctorSalad> @bot
03:48:30 <lunabot>  :o
03:49:34 <fasta> JaffaCake, I believe GHC already deleted programs that didn type-check so I would be surprised ;)
03:49:56 <fasta> didn't*
03:50:39 * fasta is torturing Windows
03:50:56 <JaffaCake> that's interesting, Windows normally tortues me
03:51:00 <fasta> JaffaCake,  failed to create OS thread
03:51:17 <ivanm> heh
03:51:20 <fasta> JaffaCake, I only create 20 processes at maximum.
03:51:42 <fasta> I am not using the Starter edition ;)
03:51:56 <fasta> It's the bells and whistles edition.
03:52:28 <Jafet> .oO(Does it ship with a better scheduler, or what...)
03:52:54 <fasta> Jafet, I believe there is some edition in which you can only create 5 processes or something like that.
03:53:15 <fasta> It would also be nice if it would say why it couldn't create an OS thread.
03:54:23 <Jafet> Perhaps the dreaded lpcszArgumentsInTheWrongOrderError
03:54:25 <JaffaCake> fasta: how's your paging file?  is it full?
03:54:57 <fasta> JaffaCake, heh, it feels like it is.
03:55:16 <fasta> JaffaCake, but I don't see why a program operating on only 5000 items would take so much memory.
03:55:32 <fasta> JaffaCake, even if it would be completely lazy the memory use is off the scale.
03:56:43 <Jafet> valgrind!
03:56:52 <Jafet> Does ghc use libc for the rts?
03:57:13 <fasta> JaffaCake, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12222
03:57:31 <fasta> JaffaCake, the length of the list of actions is only 5000.
03:57:45 <EnglishGent> okay .. back from rl bothers
03:57:45 <JaffaCake> fasta: I mean check taskmgr, does it say the paging file is full?
03:57:49 <EnglishGent> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12223#a12223
03:57:59 <EnglishGent> one of the things with monads that's currently confusing me
03:59:49 <fasta> JaffaCake, where can I find that in taskmanager?
03:59:59 <yitz> the logs show that lambdabot vanished during the last netsplit
04:00:17 <JaffaCake> fasta: the "performance" tab
04:00:20 <JaffaCake> PF Usage
04:00:24 <yitz> she's probably still running, just needs to rejoin
04:01:00 <fasta> JaffaCake, ah, I see it. 1830/8372M
04:01:22 <JaffaCake> ok, that's not the problem then
04:01:23 <fasta> JaffaCake, but I think it was really out of memory.
04:01:42 <yitz> perhaps something to do with this: "[Global Notice] One of our servers just split from the network causing ~7,000 people to reconnect.  We're investigating the cause now,  sorry for the noise!
04:01:48 <yitz> "
04:01:58 <fasta> JaffaCake, I think I should just profile it, although I find it silly that I have to do so.
04:09:41 <Jafet> EnglishGent, lists are monads too
04:10:28 <fasta> JaffaCake, it is definitely getting out of memory. It is not even at a quarter half and it already uses 3GB of swap. Is Windows lazy with recycling processes or something like that?
04:10:50 <fasta> s/quarter half/quarter
04:11:36 <JaffaCake> fasta: not lazy enough to cause a space leak, as far as I know
04:11:40 <fasta> The only thing I do when I call the process is that I strictly get its stdout and stderror, but that can never be 3GB/10 size large.
04:11:42 <JaffaCake> you should profile your program
04:11:50 <JaffaCake> just run it with +RTS -h
04:11:57 <fasta> JaffaCake, it is being done right now. It takes a few minutes to run.
04:11:59 <JaffaCake> no need to recompile
04:12:15 <fasta> JaffaCake, I already ran it with -p -hc
04:12:24 * fasta -> out
04:12:40 <JaffaCake> ok, just pointing out that you don't necessarily need to reompile with -prof first
04:12:43 <maartenm> hello, I got an iphone from work.. does anyone know  any cool free fp or other apps/tools?
04:12:50 <JaffaCake> +RTS -h gives you a basic heap profile
04:18:10 <ksf> I don't think there's a GHC port, but you should be able to get hugs running.
04:18:19 <EnglishGent> that's something I keep forgetting Jafet - I've used a few by now (IO, Parsers, etc) - but I still dont think of lists as 'typical' monads
04:18:32 <ksf> ...though, in principle, ghc runs on arm/osx
04:18:35 * EnglishGent guesses it's time to read "meet the monads" again :)
04:18:39 <bastl> ksf: that make-like stuff im doing is custom-build with user-hooks. and that's cabal...
04:19:05 <maartenm> well I was inetersted in general FP tools as well
04:19:25 <maartenm> or just anything, browsing the appstore doesn't really give me anythign interesting
04:19:32 <ksf> yep but to be a make-alike in my eyes, cabal needs to be able to interpret a rule file
04:19:40 <maartenm> some calculators.. but none of them are free
04:20:18 <ksf> It would be cool if it would be usable as a generic build system without actually coding any haskell.
04:20:44 <Jafet> Well, it took me a while to figure that out
04:20:55 <ksf> I think to get free stuff for the iphone, you need to jailbreak it.
04:20:59 <Jafet> Three cheers for typeclasseopedia
04:21:20 <ksf> apple isn't allowing anything turing-complete on their store.
04:21:43 <EnglishGent> no game of life for Iphone then :|
04:21:44 <ksf> ...or anything that can browse the web, as you'd be able to look at porn
04:21:50 <Jafet> What about Turing-hard?
04:21:53 <maartenm> ah, game of life!
04:21:58 <maartenm> there has to be a free GoL on the appstore
04:22:06 <maartenm> thanks for the idea
04:22:11 <ksf> Jafet, I don't think the reviewers are smart enough to tell the difference.
04:22:25 <ksf> and EnglishGent, I don't think the reviewers are smart enough to realize that...
04:22:28 <idnar> you can put free stuff on the appstore?
04:22:35 <maartenm> of course
04:22:38 <maartenm> lots of stuff is free
04:22:38 <Jafet> "Turing would be a great typical Mac user."
04:22:42 <maartenm> juts, mos tof it is useless
04:22:57 <smiler> I think you have to pay a small amount of money to do so though
04:23:18 <EnglishGent> ksf - well, I wont tell them if you dont :D
04:24:07 <maartenm> aha, I have game of life now on the iphone
04:24:08 <ksf> add a mode where you can tilt the phone to introduce a bias into the sim. and shake to randomize.
04:24:11 <maartenm> perfect diversion
04:24:34 <Jafet> But that would make it a one player game!
04:24:56 <ivanm> preflex: seen malcolmw
04:24:56 <maartenm> bah you can't change the rules though
04:24:56 <preflex>  malcolmw was last seen on #ghc 19 days, 19 hours, 58 minutes and 14 seconds ago, saying: Igloo: great, I think at least one sponsor will appreciate the opportunity to put some more money in.
04:25:29 <Jafet> Life32 was great for tinkering with rulesets
04:27:03 <zygoloid> Jafet: "Turing would be a great typical Mac user" ... if an apple hadn't been responsible for his death?
04:28:50 <Jafet> It was purportedly cyanide. Apple claims its products are RoHS compliant.
04:29:01 <Botje> ever tried eating one?
04:29:21 <Jafet> I have better things to do than investigate their claims.
04:29:22 <SamB_XP_> zygoloid: I was pretty sure that was caused by the fact that they had him on those female hormones ?
04:29:47 <SamB_XP_> Botje: it turns out computer chips don't taste all that great
04:30:07 <Botje> it's a pity.
04:30:32 <zygoloid> it makes me ashamed to live in England :(
04:30:38 <simplicio> mmh, microchips...
04:31:01 * SamB_XP_ suspects simplicio of being a silicon-based life form
04:31:45 <Jafet> I hear they use more gallium now
04:34:22 <ivanm> anyone here use my graphviz library?
04:34:49 * ivanm is trying to work out the best way of doing something, and isn't sure what would be the best way of doing so
04:39:05 <SamB_XP_> ivanm: well, if you keep going at it like that, you'll overflow the stack ;-P
04:39:22 <ivanm> hmmm?
04:39:29 <Jafet> Not if he's lazy
04:39:58 <ivanm> I don't get it...
04:45:10 <kamatsu> hi all, i discovered a neat feature in Miranda recently, and wonder why it's not in haskell
04:45:29 <kamatsu> miranda seems to have these interesting types of list comprehensions that are good for arithmetic progressions
04:45:33 <kamatsu> e.g for fibs
04:45:34 <kamatsu>  [a | (a,b) <- (0,1), (b,a+b) ..]
04:45:53 <maartenm> what4s not  in haskell about that?
04:46:03 <kamatsu> well, perhaps i'm just not aware of the syntax
04:46:05 <SamB_XP_> kamatsu: how does that work ...?
04:46:13 <ivanm> > [ a | (a, b) <- [ (0,1), (b, a+b), .. ] ]
04:46:18 <ksf> Miranda is a trademark of Research Software Ltd.
04:46:21 <ivanm> , [ a | (a, b) <- [ (0,1), (b, a+b), .. ] ]
04:46:22 <lunabot>  luna: parse error on input `..'
04:46:25 <ivanm> bah
04:46:28 <ksf> just wanted to mention it, to be on the safe side.
04:46:30 <ivanm> , [ a | (a, b) <- [ (0,1), (b, a+b) .. ] ]
04:46:31 <lunabot>  luna: No instance for (GHC.Enum.Enum
04:46:31 <simplicio> that looks like a scope error
04:46:32 <SamB_XP_> ksf: I think we all know that ?
04:46:38 <ivanm> , [ a | (a, b) <- [ (0,1), (b, a+b) .. ] ] :: [Int]
04:46:39 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
04:46:43 <ivanm> bah
04:46:48 <simplicio> SCOPE ERROR
04:46:49 <ksf> I do, but some lawyers might think we don't.
04:47:02 <ivanm> I don't know if the code is wrong, or I'm not using lunabot properly :s
04:47:11 <SamB_XP_> ksf: I'm pretty sure you don't need to say that sort of thing on IRC for no real reason!
04:47:24 <ksf> well kamatsu mentioned it.
04:47:31 <SamB_XP_> I mean, it makes sense in papers ...
04:47:33 <Jafet> Miranda (TM) probably just has more syntax than Haskell (moral rights of deceased recognized).
04:47:42 <RayNbow> http://www.acm.uiuc.edu/conference/2009/video/UIUC-ACM-RP09-DonStewart.avi <-- this is just plain awful... putting h264 in .avi :X
04:47:53 <kamatsu> okay, so, is there a way to do something like, say, fibs, in a list comprehension?
04:48:02 <kamatsu> i am teaching someone haskell, and she's determined to figure out a way to do it
04:48:15 <ksf> you can, but it's ugly.
04:48:36 <ksf> > let fibs = 1:1:zipWith (+) fibs (tail fibs)
04:48:44 <Jafet> > let fibs = 0 : scanl (+) 1 in fibs
04:48:44 <SamB_XP_> ksf: by "for no real reason", I meant, when it wasn't actually relevant to anything that was being talked about -- i.e. knowing it doesn't explain anything that anyone was asking about ;-)
04:48:47 <ksf> , let fibs = 1:1:zipWith (+) fibs (tail fibs)
04:48:48 <lunabot>  luna: parse error on input `)'
04:48:56 <ksf> , let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
04:48:58 <lunabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:48:59 <kamatsu> well, sure, but i mean this sort of list comprehensions [x|blah]
04:49:02 <simplicio> ivanm: the code is wrong because it's a scope error
04:49:07 <ivanm> yeah, looks like haskell doesn't like the recursion in there...
04:49:12 <ivanm> simplicio: yeah, worked that out
04:49:14 <Jafet> kamatsu, if you can't do it nicely with list comprehensions, why use list comprehensions?
04:49:24 <simplicio> > [x | "blah" ]
04:49:29 <simplicio> , [x | "blah" ]
04:49:31 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
04:49:33 * ivanm tries with enumFromTo
04:49:35 <kamatsu> Jafet: i know, but this was my student's idea, not mine
04:49:35 <simplicio> aww
04:49:42 <simplicio> , [x | _ <- "blah" ]
04:49:44 <lunabot>  [x,x,x,x]
04:49:45 <kamatsu> Jafet: i am interested to see if it's possible
04:50:03 <ksf> it is. but you've got to fight the comprehension to get things done.
04:50:03 <ivanm> s/To/Then/
04:50:15 <ivanm> and nope, it doesn't work
04:50:16 <ksf> I once did it, and don't intend to melt my brain again.
04:50:27 <Jafet> , [ x | x <- fibs where fibs = 0 : scanl (+) 1 fibs ]
04:50:28 <lunabot>  luna: parse error on input `where'
04:50:35 <Jafet> , [ x | x <- (let fibs = 0 : scanl (+) 1 fibs in fibs) ]
04:50:36 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
04:50:38 <ksf> Jafet, that's cheating.
04:50:40 <Jafet> Wee!
04:50:45 <Jafet> ORLY
04:50:59 <maartenm> I'm pretty sure you can do it with tupoles
04:51:29 <SamB_XP_> tuples don't have Enum, though ...
04:51:42 <ivanm> don't they?
04:51:45 <ivanm> @instances Enum
04:51:50 <maartenm> yeah you'd need an aux funciton
04:52:04 <ivanm> bah, forgot about there being one less bot here than usual...
04:52:15 <netinho2lol> hey where's lambdabot?
04:52:21 <netinho2lol> :|
04:52:32 <SamB_XP_> ivanm: well, see, they can't really in general ...
04:52:38 <simplicio> @seen lambdabot
04:52:43 <RayNbow> preflex: seen lambdabot
04:52:44 <preflex>  lambdabot was last seen on #haskell 3 hours, 43 minutes and 57 seconds ago, saying: http://elgoog.rb-hosting.de/
04:52:47 <SamB_XP_> Enum is really too big, IMO
04:55:24 <SamB_XP_> oh, the evil! http://www.evil-comic.com/archive/20060620.html
04:57:05 <Jafet> , showCReal 10 (sqrt 5)
04:57:06 <lunabot>  luna: Not in scope: `showCReal'
04:57:18 <Jafet> Doh
04:57:39 <netinho2lol> > replicate 2 'a'
04:58:04 <Jafet> , [ ((1 + sqrt 5)**n - (1 - sqrt 5)**n) / (2**n * sqrt 5) | n <- [1..] ]
04:58:05 <lunabot>  [1.0,1.0,2.0,3.0000000000000004,5.000000000000001,8.000000000000002,13.00...
04:58:17 <maartenm> heh
04:58:44 <maartenm> beat that, miranda
04:58:52 <netinho2lol> , replicate 2 'a'
04:58:53 <lunabot>  "aa"
04:59:17 <Jafet> Just beat it
04:59:59 <DRMacIver> Question. I've got the following setup (abstracted from real code): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12226#a12226 . I'd like to modify it so that nodes are "interned" before they're produced, so this doesn't repeat work when a appears in different nodes. I'm not sure what a good way to do this is.
05:00:12 <netinho2lol> scale n = stretchH n . stretchV n
05:00:21 <DRMacIver> Obviously some sort of constraint needs adding to a to make this work. Presumably Ord will do.
05:00:24 <netinho2lol> how do I put this in point free?
05:00:37 <Jafet> With an arrow
05:00:46 <netinho2lol> there's another argument not being used
05:00:51 <netinho2lol> scale n p
05:01:26 <Jafet> If you can't make it point free by yourself, give up
05:01:55 <benmachine> is there any reason why (->) can't be the name of a function? specifically, any circumstance in which it would conflict with the type operator?
05:02:28 <quicksilver> benmachine: no, there is no reason. Type operators and functions are in different namespaces.
05:02:42 * benmachine was thinking about the TDNR proposal, that -> might be less confusing than .
05:02:43 <quicksilver> benmachine: (no reason other than the haskell98 standard, that is)
05:02:43 <fasta> Uhm, how can this program _ever_ output X of Y, with X > Y? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12222
05:03:15 <SamB_XP_> quicksilver: what about lambda and case syntax ?
05:03:26 <benmachine> oh that is a good point
05:03:29 <quicksilver> SamB_XP_: good point that man :)
05:03:33 <benmachine> it wouldn't conflict with the type operator
05:03:39 <benmachine> but it's not only used as a type operator
05:03:40 <benmachine> ho hum.
05:03:43 <quicksilver> SamB_XP_: benmachine tricked me into only thinking about the type operators.
05:03:46 <benmachine> heh
05:03:47 <benmachine> sry
05:04:02 * benmachine back to the proverbial drawing board
05:04:33 <ksf> I don't care what you want, but we are going to get view patterns without mentioning ->
05:05:04 <benmachine> k
05:05:08 <ksf> that is, stuff that doesn't look like the right type is automatically viewed with a magic typeclass.
05:05:32 <ksf> ...I don't want to write different code for matching on bytestrings and lists.
05:06:25 <SamB_XP_> ... whoa ... for once, freenet actually manages to start chrome in trenchcoat mode ...
05:06:53 <Jafet> (define-syntax do (syntax-rules (<-) ((do) (begin)) ((do (x <- v) etc ...) (let ((x v)) (do etc ...))) ((do x etc ...) (begin x (do etc ...))))) ; Haskell is going to ruin my career!
05:07:00 <viator_sg> Anybody knows where is the info for TypeOperators ext? I can't find it
05:07:58 <fasta> SamB_XP_, trenchcoat mode?
05:08:12 <ksf> fasta, the one for porn browsing.
05:08:19 <ksf> it doesn't leave behind any traces.
05:08:34 <Jafet> Where google claims not to collect all your surfing data.
05:08:41 <ivanm> ksf: I thought it was for showing porn to others with them not knowing about it...
05:08:51 <ivanm> Jafet: *cough* yeah, right
05:08:59 <SamB_XP_> Jafet: well, also it's not supposed to save it for you either
05:09:16 <dcestari> hello
05:09:24 <ivanm> IIRC, there's a particular identifier that never gets disabled in chrome...
05:09:26 <dcestari> anyone could help me with a small problem here?
05:09:26 <SamB_XP_> including not changing the color of links to pages you visit in it
05:09:51 <dcestari> I need to print a String, but when I print "Hello" I get "Hello" with the double quotes!
05:09:52 <Jafet> So web browser writers discover persistent data structures
05:09:59 <Botje> dcestari: use putStrLn instead
05:10:04 <Jafet> And they get all "woah we can use this for porn"
05:10:06 <SamB_XP_> (yes, this link-color-changing is actually a privacy leak!)
05:10:07 <Botje> print does a show first
05:10:33 <ksf> print output is supposed to be parsable, no readable.
05:10:40 <yitz> viator_sg: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
05:10:50 <SamB_XP_> also, it's actually called incognito mode
05:11:29 <netinho2lol> Found: concatMap -> Why not: (>>=)
05:11:36 <netinho2lol> what's >>= ?
05:11:41 <Badger> bind!
05:11:47 <ksf> in the case of the list monad, concatMap
05:11:51 <dcestari> if I have a function doing pattern matching to match arrays, how can I specialize it for [Char] ?
05:11:54 <benmachine> isn't =<< concatMap
05:11:59 <ksf> :t (>>=)
05:12:02 <ksf> benmachine, yes
05:12:17 <benmachine> so you'd need to flip the arguments as well
05:12:26 <ivanm> well, it's flip concatMap
05:12:30 <benmachine> @bots
05:12:31 <lunabot>  :o
05:12:44 <netinho2lol> , :t (>>=)
05:12:45 <lunabot>  luna: Couldn't match expected type `(m a1 -> (a1 -> m b) -> m b) -> [a]'
05:12:49 <ksf> dcestari, arrays and lists don't easily map onto each other.
05:13:00 <viator_sg> yitz: Thanks :)
05:13:01 <benmachine> netinho2lol: ask ghci
05:13:05 <ksf> dcestari, but my crystal ball tells me you want to use bytestrings.
05:13:12 <Badger> @bot
05:13:12 <lunabot>  :o
05:13:12 <dcestari> ksf: sorry, I meant list on both cases
05:13:16 <netinho2lol> benmachine: doing that as we speak
05:13:23 <DRMacIver> ok. Time for a repeat question. :) I'm trying to modify unfoldFoo in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12226#a12226 to memoize nodes rather than recalculate them. Any suggestions?
05:13:26 <ksf> oh, just give a type annotation
05:13:32 <dcestari> ksf: showTuple (x:xs) = ....
05:13:46 <ksf> showTuple :: String -> ...
05:13:48 <dcestari> ksf: like showTuple (String s) => s = ... ?
05:13:56 <netinho2lol> concatMap :: (a -> [b]) -> [a] -> [b]
05:13:59 <Jafet> Lists aren't tuples!
05:14:12 <netinho2lol> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
05:14:23 <dcestari> I know, but I represent a tuple as a list Jafet
05:14:28 <netinho2lol> (=<<) :: (Monad m) => (a -> m b) -> m a -> m b
05:14:47 <ksf> ...that's not a tuple or list, but a 2-vector.
05:15:03 <dcestari> ksf: but I already have showTuple :: [a] -> String
05:15:07 <benmachine> netinho2lol: if you read [a] as [] a, then read the type of =<< with m as []...
05:15:14 <ksf> lists don't have fixed size, and tuples don't have homogenous element types.
05:15:28 <ksf> then make it String -> String
05:15:43 <ksf> ... String is [Char]
05:15:55 <dcestari> ksf: but other types use that function
05:16:05 <ksf> types don't use functions
05:16:11 <fasta> JaffaCake, I didn't get a profile, btw, probably because it doesn't handle out of memory correctly.
05:17:15 <benmachine> netinho2lol: if you're not too comfortable with monads/typeclasses, don't worry about it and carry on using concatMap
05:17:17 <dcestari> ksf: bear with me, I'm new to Haskell, easy on the terms ;)
05:17:19 <yitz> DRMacIver: hmm? what's being recalculated?
05:17:30 <netinho2lol> benmachine: that seems to be the case :)
05:17:36 <netinho2lol> thanks for the assistance, anyways
05:17:56 <benmachine> in that case it is worth learning about monads and typeclasses!
05:17:59 <benmachine> because they are handy
05:18:04 <ksf> dcestari, haskell always infers the most generic type, and you can leave it at that
05:18:15 <benmachine> and there are lots of reasons why you'd want to switch to >>= once you understand why it works
05:18:18 <DRMacIver> yitz: If the same value appears at two different points in the tree, the entire tree below it will be recalculated.
05:18:32 <benmachine> but if concatMap works too, 's not a proble,
05:18:34 <benmachine> problem
05:18:42 <yitz> DRMacIver: ah, I see.
05:19:08 <dcestari> ksf: I know this is not an imperative programming language, but, is there a way to get the type of a matched var?
05:19:15 <ksf> I don't think it's very wise to mess around with the infered types much in the beginning, getting an intuition for the type system takes a while
05:19:42 <DRMacIver> yitz: Which is a big problem for my particular use case because I expect there to be a lot of duplication across different branches. So I'd like a way to build this as a dag as it goes.
05:19:50 <ksf> in general, you already have it, and only match on the different members a type has (that is, its constructors)
05:20:02 <yitz> DRMacIver: so, let's assume you can put an Ord constraint on your type parameter.
05:20:16 <DRMacIver> Indeed. I'm assuming I can and should. :)
05:20:17 <JaffaCake> fasta: it should do, we fixed that bug a few versions back
05:20:18 <ksf> but then, there is Dynamic, which you can use to wrap things to do dynamic typing, but it's rarely if ever needed
05:20:25 <DRMacIver> (I actually have one in the code this is abstracted from anyway)
05:20:28 <ksf> ...and of course comes with run-time overhead.
05:20:28 <JaffaCake> fasta: if not, you can just control-C anyway
05:20:33 <fasta> JaffaCake, this is 6.10.4, btw.
05:20:53 <JaffaCake> then you should get a profile on out-of-heap
05:21:00 <JaffaCake> maybe you have to use +RTS -M<large>
05:21:05 <dcestari> ksf: I mean, can I do ' customPrint s = putStrLn where s is String' ?
05:21:12 <yitz> DRMacIver: you'll add an extra parameter to your function that passes along a Data.Map a (Foo a)
05:21:19 <fasta> JaffaCake, another issue: can you explain how it is possible that the X of Y that the program outputs has X values greater than Y?
05:21:23 <dcestari> ksf: or on a case
05:21:26 <ksf> customPrint s = putStrLn s, sure
05:21:33 <fasta> JaffaCake, that is impossible, AFAICT from the semantics.
05:21:44 <ksf> that's just another name for putStrLn, then.
05:21:45 <benmachine> dcestari: the thing to ask is what type customPrint has
05:22:00 <JaffaCake> fasta: where the code again?
05:22:08 <dcestari> benmachine: ksf: customPrint :: [a] -> String
05:22:19 <benmachine> you can't do that
05:22:21 <ksf> nope
05:22:23 <fasta> JaffaCake, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12222
05:22:25 <ksf> not at all
05:22:26 <DRMacIver> yitz: Right, I've thought of that but was hoping for a better solution. It's kindof gross because you have to thread the map all the way through and forces the whole thing to be strict which it shouldn't really need to be.
05:22:37 <ksf> @bot
05:22:38 <lunabot>  :o
05:22:45 <benmachine> because that says, I can give customPrint any list I want and it's got to work out a String for it
05:22:46 <ksf> WHERE IS LAMBDABOT WHEN I NEED HER
05:22:48 <dcestari> benmachine: ksf: since the purpose of this function is to get a String representation of the value
05:22:50 <JaffaCake> fasta: what are X and Y?
05:23:01 <ksf> that's what show is made for
05:23:08 <benmachine> I could make up my own type and then give a list of that type to customPrint
05:23:11 <fasta> JaffaCake, (putStrLn (show n ++ " of " ++ show max))
05:23:11 <benmachine> and then what would it do?
05:23:14 <yitz> DRMacIver: no, it doesn't force it to be entirely strict.
05:23:20 <fasta> JaffaCake, X = n, Y = max
05:23:58 <ksf> , show ("Foo", Just 3, [1,2,3])
05:23:59 <lunabot>  "(\"Foo\",Just 3,[1,2,3])"
05:24:02 <DRMacIver> yitz: Hmm. Oh, you're right, it doesn't. It forces some weird evaluation dependencies, but not strictness.
05:24:11 <dcestari> ksf: benmachine: I have it like this, 'customPrint :: [a] -> String'     'customPrint (x:xs) = (show x) ++ customPrint'
05:24:18 <DRMacIver> (basically it forces the evaluation to follow a depth first search of the tree)
05:24:27 <benmachine> customPrint xs I assume
05:24:41 <dcestari> ksf: benmachine: but I want to add a special case for [Char] to avoid the double quotes when I call show for a String
05:24:47 <benmachine> but in order to call show on x, you need it to be in the Show typeclass
05:24:53 <JaffaCake> fasta: is your output from multiple threads getting interleaved, perhaps?
05:25:00 <yitz> DRMacIver: and there's not too much threading of the map - you'll just have: fromMaybe (old code, passing updated Map) (M.lookup x m)
05:25:11 <fasta> JaffaCake, it should be synchronized, see the mvar.
05:25:13 <dcestari> benmachine: you are right I missed the (Show a) => [a] -> String
05:25:23 <fasta> JaffaCake, it was also consecutive output.
05:25:30 <yitz> DRMacIver: I don't think it does that either.
05:25:41 <fasta> JaffaCake, that is, I got N of Y N+1 of Y N+2 of Y etc.
05:25:51 <fasta> JaffaCake, all the way to 24000 and then I killed it.
05:26:10 <JaffaCake> fasta: it looks ok to me
05:26:23 <yitz> DRMacIver: you are right that threading a map through a function for memoization can sometimes be a mess, but in this case it's actually nice.
05:26:24 <fasta> JaffaCake, when I run it with profiling options, it just stops after 150-200 steps.
05:26:30 <fasta> JaffaCake, instead of 5000+.
05:26:31 <ksf> dcestari, the thing is, you can't override the existing instance for [Char], and anything that you could do to a string to convert it to its string representation would be a noop.
05:26:40 <fasta> JaffaCake, no error messages or whatever.
05:26:55 <ksf> ...well, you could hide the standard prelude, but I don't think you want to go that far.
05:27:12 <dcestari> ksf: certainly not
05:27:33 <DRMacIver> yitz: I'm pretty sure it does. If I look at a node and want to say look at its third child I need to have got the map out of the first two children in order to calculate the tree at that point.
05:27:35 <dcestari> ksf: so, can I do a check for the type? without pattern matching?
05:27:52 <DRMacIver> yitz: Because you need to pass the map out of the evaluation of each child node and into the evaluation of the next child node
05:28:01 <ksf> dcestari, what do you want to do with the string?
05:28:09 <dcestari> ksf: customPrint xs@(x:xs) = if xs isString then xs else (show x) ++ customPrint xs fi ?
05:28:32 <ksf> you need typeclasses for that.
05:28:48 <ksf> class MyShow a where myShow :: a -> String
05:28:59 <benmachine> hmm
05:29:08 <ksf> instance MyShow String where myShow = id
05:29:22 <yitz> DRMacIver: I don't get what you mean. you need to descend the tree to wherever you specify in either case. If you have a cache hit, so that pointer will make all kinds of other data available because you've already computed it, but so what?
05:29:25 <ksf> instance (Show a) => MyShow a where myShow = show
05:29:31 <benmachine> dcestari: surely when you are calling customPrint you know if it's a string or not
05:29:36 <ksf> uh the last one is an undecidable one.
05:29:39 <benmachine> ksf: doesn't that need some extension or other
05:29:49 <dcestari> benmachine: how do I know?
05:29:58 <benmachine> dcestari: well because it's your code :P
05:29:59 <DRMacIver> yitz: You need to descend the tree to wherever you specify, but having threaded the map through the calculation introduces an evaluation dependency.
05:30:14 <dcestari> benmachine: hehehe
05:30:14 <ksf> ...as one could also write MyShow a => Show a and GHC wouldn't know left from right.
05:30:27 <ksf> but -XUndecidableInstances is safe unless you do such things.
05:30:29 <dcestari> ksf: so a class ?
05:30:37 <fasta> JaffaCake, still, I am more worried about the change in behaviour when I turn profiling on.
05:30:41 <DRMacIver> yitz: because evaluating a child node now depends on having evaluated all previous child nodes fully in order to know which nodes are defined in that tree to get the memo map needed to calcluate this node.
05:30:42 <ksf> the worst that can happen is that typechecking doesn't terminate.
05:30:45 <ksf> dcestari, yes.
05:31:04 <JaffaCake> fasta: so it just hangs?
05:31:11 <benmachine> I think that in most cases you can find a way of not needing to do that
05:31:15 <fasta> JaffaCake, no, it exits.
05:31:16 <benmachine> but what do I know
05:31:27 <dcestari> ksf: thanks
05:31:27 <JaffaCake> with what status?
05:31:35 <ksf> from here, doing that looks like overkill
05:31:40 <benmachine> (by not needing to do that, I mean not needing to make a function that behaves like show for *nearly* everything)
05:31:49 <fasta> JaffaCake, what's the Windows lingo to say that?
05:32:06 <JaffaCake> what shell?
05:32:13 <dcestari> benmachine: ksf: I'll do what benmachine said, hehe, call other function when its a string... a little bit of code duplication but It's shorter than writing a class for that
05:32:23 <fasta> JaffaCake, cmd.exe
05:32:27 <yitz> DRMacIver: ah, now I see what you mean. without memoizing, you can leave the values thunked as you descend - if your function provides the first few values of the list without ever evaluating its argument. Sounds like a weird case to me, though. Anyway, sounds like that's an inherent cost to memoizing this particular structure.
05:32:33 <JaffaCake> oh, in that case I don't know, sorry
05:32:39 <ksf> There's no silver bullet for everything -- Euklid
05:32:50 <DRMacIver> yitz: Yeah. The evaluation order isn't a problem now that I realise it's not strict in the whole thing.
05:32:51 <JaffaCake> fasta: try procmon?
05:33:14 <DRMacIver> yitz: I was probably going to be descending the tree depth first anyway.
05:33:15 <dcestari> is there a 'noop' function?
05:33:21 <ksf> ah but type class hackery is fun.
05:33:29 <Botje> dcestari: why do you need it?
05:33:30 <ksf> you can have lots of fun with type funs.
05:33:44 <ksf> theres id
05:33:52 <ksf> id :: a -> a
05:33:56 <ksf> id x = x
05:34:06 <DRMacIver> yitz: 'though I will note for the record that it's only an inherent cost because Haskell is exceptionally picky about referential transparency. If you're willing to sneak in invisible side effects then this function can be implemented in a way that's still referentially transparent from the outside and doesn't introduce any evaluation dependencies.
05:34:15 <dcestari> Botje: I need to call a generic function that like map that receives a function, but for some cases I need to do nothing
05:34:26 <dcestari> Botje: but I don't want to write that many special cases
05:34:30 <dcestari> ksf: thanks!
05:34:31 <Botje> you can use id, yes.
05:34:38 <dcestari> Botje: ksf: thanks!
05:35:23 <ksf> It's not flash that's innately slow, it's bleeding youtube.
05:35:37 <DRMacIver> yitz: Anyway, thanks. I'll give this a go.
05:36:42 <yitz> DRMacIver: how is that? in order to descend, you need to apply the function to get successive lists. In order to memoize that, you need actually to compute the values to use them as keys in your memoization scheme. Doesn't sound to me like that has anything to do specifically with Haskell.
05:37:06 * ksf thinks memoizing should be dealt with by rigurous dynamic programming.
05:37:38 <yitz> DRMacIver: actually, you can use vectors of ints indicating position in the structure as your keys
05:38:07 <yitz> DRMacIver: so if you really expect to use such a weird function where that will help, then you can go to the extra trouble and get that also.
05:38:10 <ksf> there's no sense in caching recursive calls to fib if you can calculate the stuff in bleeding linear time...
05:38:43 <DRMacIver> yitz: Because if you have a mutable map then you can implement the memoizing as "check the cache. If it's there, use that, if not compute it and shove it in the cache", so the function will be evaluated in whichever order you descend.
05:39:09 <yitz> ksf: and even less sense when actually you can compute it in log time. :)
05:39:38 <ksf> yitz, in a way that a non-numericologist understands?
05:39:48 * yitz thinks memoizing should usually be replaced by thinking through your problem better
05:40:03 <yitz> ksf: it's simple actually
05:40:28 * DRMacIver thinks statements of the form "if you want to do X you're doing it wrong" should be replaced with actual arguments.
05:40:31 <yitz> DRMacIver: that's exactly what we're doing, too
05:40:58 <DRMacIver> yitz: The difference is in how that map is built up.
05:41:18 <DRMacIver> yitz: Doing it purely forces you to be explicit about the order in which the map is built up. Doing it with a mutable map just builds the map any which way as you go.
05:41:41 <ksf> why the explicit order?
05:41:49 <yitz> DRMacIver: I really don't understand why you think that.
05:41:57 <DRMacIver> yitz: I really don't understand why you don't.
05:42:18 <ksf> ...because Data.Map lets you index any value with any key
05:42:36 <ksf> you can do sparse maps just fine, and combine + extend them in a pure way
05:42:57 <DRMacIver> yitz: You agree that using an immutable map *does* force the data dependency, right?
05:43:13 <yitz> DRMacIver: just like a mutable one would, yes.
05:43:25 <DRMacIver> yitz: No, it doesn't.
05:43:36 <ksf> http://conal.net/blog/posts/memoizing-polymorphic-functions-part-one/
05:43:37 <yitz> does so.
05:43:39 <DRMacIver> yitz: Using a mutable one doesn't force you to look anywhere else in the tree. I try to calculate a node. If it's not already in the cache, I create it and put it in the cache.
05:43:39 <yitz> so there.
05:43:49 <fasta> JaffaCake, when I run it in bash it continues a lot further and exits with an exit status of 0.
05:43:59 <fasta> JaffaCake, but it doesn't complete.
05:44:07 <DRMacIver> yitz: That's all there is to it. There's no need to look anywhere else in the tree.
05:44:19 <yitz> DRMacIver: same exact thing for immutable.
05:44:25 <DRMacIver> yitz: No. It's. Not.
05:44:48 <yitz> the immutable cache contains only nodes you put in there, nothing else.
05:44:53 <DRMacIver> yitz: because with the immutable map you need to know the right map to use, so you need the results of the calculation of the parts of the tree responsible for building it.
05:45:09 <JaffaCake> fasta: I don't know, I'm afraid.  Try adding more diagnostics
05:45:21 <DRMacIver> yitz: with the mutable map there's only one map, so there's no dependency on evaluating the rest of the tree.
05:45:23 <ksf> the building of the map isn't a tree, it's a list.
05:45:28 <yitz> does anyone here understand what DRMacIver is talking about?
05:46:11 <DRMacIver> ksf: I think you've missed the context for this problem. The question is about memoizing the construction of a tree (well, actually a dag once it's memoized)
05:47:00 <ksf> but you're going to extend the memo table element by element, that's what I mean.
05:47:11 <yitz> DRMacIver: also with the immutable one, there's only one map at any given time. it's just that instead of mutating memory as you go along, you throw away a few of the pointers and replace them with others as you go along. otherwise, they're exactly equivalent.
05:47:57 <DRMacIver> yitz: Let's start again.
05:48:08 <ksf> DRMacIver, I think what you might be missing is that it's sensible to use a state monad to track the state of the memo table.
05:48:28 <ksf> but that has nothing to do with the immutability of the data structure used to memoize
05:48:42 <DRMacIver> ksf: I'd already figured that one out. It's not relevant to the issue yitz and I are arguing though.
05:49:13 <ksf> well, then you're... wrong.
05:49:16 <yitz> DRMacIver: ah, ok. perhaps the case that is bothering you is not descending the tree, but rather walking along the list at a given level.
05:49:17 <DRMacIver> No. I'm not.
05:49:47 <yitz> DRMacIver: then, you want to avoid memoizing items along the way that you don't need the values of. is that it?
05:49:52 <ksf> see the query of the tree can never force a value, because the tree doesn't know how.
05:49:58 <DRMacIver> So, suppose I have Foo a [x, y] and I'm threading a map through.
05:50:08 <DRMacIver> I want to evaluate y completely.
05:50:21 <DRMacIver> If I have to thread an immutable memo table through, then I need the memo table that results from x.
05:50:28 <DRMacIver> Correct?
05:50:46 <ksf> you can fold in the other direction, too.
05:51:09 <Gwern-away> @wn beshitten
05:51:19 <DRMacIver> ksf: sure. Reverse my question then. It doesn't matter what order you do it in, I'm just saying that there is a forced order of evaluation of the child nodes.
05:51:33 <ksf> yes. so what?
05:51:44 <ksf> you could randomize the order if you want.
05:52:27 <DRMacIver> Now, if I have a mutable map, if I want to evaluate y completely I just... evaluate y. I already have the memo map, because there is only one. I don't need the results of x in order to do it.
05:53:00 <DRMacIver> What's in the memo map when I evaluate y is dependent on the evaluation order, so this is a side effect, but it's one whose results are not externally visible.
05:53:16 <fasta> JaffaCake, I am not sure what else to add.
05:53:30 <Gwern-away> @botsnack
05:53:31 <lunabot>  :o
05:53:54 <JaffaCake> fasta: try to find out what it was doing before it exited?
05:54:50 <ksf> what exactly do you mean with "side effect"?
05:55:01 <fasta> JaffaCake, it can only do one thing. It's not a complicated program. I can show you the definition of "workers" too, but without a working debugger where you can see all the threads of control, there is little to be done, other than seeing it doesn't work.
05:55:16 <yitz> DRMacIver: right. what confused me was thinking about depth-first - there the two really are equivalent, because you need to get the values in order to descend, even if you're not memoizing at all. what you are thinking about is moving along one of the lists.
05:55:20 <ksf> ...operationally, I mean.
05:56:00 <fasta> JaffaCake, the program works fine, when I don't use any parallelism.
05:56:16 <yitz> so this is really just the usual problem of memoizing a list. and yes, if you want memoization to happen in evaluation order, not list order, you have a problem.
05:56:23 <JaffaCake> fasta:  oh, so you're using +RTS -N?
05:56:59 <DRMacIver> yitz: ok. Sorry for the confusion.
05:57:02 <fasta> JaffaCake, yes, -N1 when profiling
05:57:08 <fasta> JaffaCake, -N2 when not profiling.
05:57:13 <fasta> JaffaCake, http://paste.debian.net/51739/
05:57:17 <DRMacIver> yitz: And it's not a huge problem. I was just making an observation.
05:57:39 <fasta> JaffaCake, that is my definition of workers, which logically can be the only thing that is wrong, or the implementation of the semaphores library in GHC.
05:58:27 <yitz> DRMacIver: so the way to do that would be instead of using a list at each level, use something like a Data.IntMap. Of course, then the clients of this data structure have to be written differently, too.
05:59:00 <JaffaCake> fasta: if you're using a lot of memory, perhaps the OS is killing the process?
05:59:18 <fasta> JaffaCake, shouldn't I get some kind of message then?
05:59:28 <JaffaCake> I'd expect so, yes
05:59:35 <fasta> JaffaCake, and shouldn't the exit status be !=0?
05:59:41 <DRMacIver> yitz: The list isn't the problem here.
05:59:50 <JaffaCake> also you could try replacing "svn.exe" with something simpler and quicker
05:59:51 <DRMacIver> yitz: You still need to thread the map through in some order.
06:00:00 <DRMacIver> yitz: And that order will always determine the evaluation order of the tree.
06:00:38 <yitz> DRMacIver: I seem to recall that someone has written a library that does the kind of memoization that you want using unsafePerformIO. But that is a recipe for problems - the same kinds that you could run into by using a mutable map in some other language.
06:01:09 <fasta> JaffaCake, what is the behaviour of exceptions if you don't catch them? There is a default handler which just prints something to stdout, right?
06:01:33 <JaffaCake> stderr, yes
06:01:38 <yitz> DRMacIver: if you use a Data.IntMap, then the order in which elements are inserted into the cache is the order in which you evaluate them.
06:02:33 <ksf> every evaluation order has to be fixed, at some time.
06:02:43 <ksf> the latest is when stuff executes.
06:02:52 <ksf> others say when all data dependencies are given.
06:03:19 <DRMacIver> yitz: I doubt that very much. There's a strict evaluation dependency node -> map which produces it -> node which produces it.
06:04:01 <ksf> well if you have a strictly sequential unfold, you don't need a memo table at all.
06:04:31 <ksf> (I think that's even true in the general case)
06:05:05 <ksf> at the very last it's amendable to dynamic programming, then.
06:06:08 <ksf> whether that algorithms needs constant time is another question, and depends on the maximum size of an arc from the dependency to the node that depends on it.
06:06:51 <ksf> ...that's why totalfit's efficiency breaks completely down if lines are too long.
06:08:25 <Saizan> DRMacIver: could you use an immutable trie as memo table?
06:09:36 * Phyx- goes to read up on arrows
06:10:08 <bastl> How can I remove a package completely from filesystem with ghc-pkg?
06:10:44 <ksf> I don't think you can
06:10:54 <ksf> you can hide or unregister
06:10:57 <ksf> and then rm -r
06:11:06 <yitz> bastl: unregister it using ghc-pkg, then remove it manually.
06:11:08 <bastl> I want to re-download it from hackage
06:11:22 <ksf> you can use cabal install --reinstall
06:11:35 <bastl> hm.
06:11:42 <bastl> ok, thanks
06:11:58 <dcoutts> bastl: see ghc-pkg isn't dpkg
06:12:01 <ksf> you're going to end up with two installed versions, then
06:12:06 <dcoutts> nor is cabal
06:12:09 <bastl> dcoutts :-)
06:12:19 <ksf> which is actually a good idea, because the rest of your packages won't break.
06:12:27 <ivanm> preflex: seen Baughn
06:12:28 <preflex>  Baughn was last seen on ##C++ 4 hours, 11 minutes and 48 seconds ago, saying: Or std::map?
06:12:34 <Phyx-> I'm hearing a strange beeping sound.... maybe i should start running....
06:12:55 <eivuokko> fwiw, I first remove package manually, while I can still use ghc-pkg to list files it references.
06:13:42 <arvidj> blist
06:14:11 <Baughn> ivanm: Whut?
06:14:41 <ivanm> Baughn: does indentation override the normal indent length?
06:14:43 <absentia> gholias:  underworld is what I am looking for... very nice... still need to get better at the controls
06:14:50 <absentia> the inventory is b!tchass small
06:14:50 <ivanm> I generally use tab = 4 spaces, but it seems to be using 2 spaces :s
06:14:52 <Baughn> ivanm: Define "normal indent length"
06:14:53 <absentia> crap
06:14:56 <Baughn> ivanm: Oh. Yes.
06:15:04 <ivanm> (which is making my code weird since most things are indented 4 and now things are indented 2)
06:15:09 <ivanm> Baughn: how can I override that?
06:16:13 <Baughn> Indentation completely disables tab
06:17:40 <ivanm> Baughn: right, but is it possible to configure its indent size?
06:18:12 <Baughn> ivanm: There are some configuration variables in the haskell-indentation group. Try that.
06:18:21 <ivanm> OK
06:18:37 <Baughn> ivanm: Preferably, make it file-local variables.
06:19:11 <ivanm> so not in custom-set-variables? make it part of the haskell-mode hook?
06:19:37 <Baughn> No, I meant as a file-local variable
06:19:50 <Baughn> ivanm: http://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html#Specifying-File-Variables
06:20:01 <ivanm> oh...
06:20:06 <ivanm> Baughn: why that?
06:20:12 <ksf> the right solution is set et ts=4 sw=4
06:20:29 <ksf> ...globally.
06:20:31 <Baughn> ivanm: So other people can edit your files.
06:20:37 <ksf> there's no excuse to use tabs as indent.
06:20:40 <ivanm> Baughn: alternatively, is there a way to have it re-indent the code I current have?
06:20:45 <ivanm> ksf: I'm not
06:20:48 <Baughn> ksf: These aren't tabs we're talking about.
06:20:55 <Baughn> ivanm: Sadly, not at the moment. There could be.
06:21:04 <absentia> xn/win shrink 3
06:21:12 <ivanm> Baughn: *nod*
06:21:27 <ivanm> Baughn: OK, different question: how can I get multi-line -- comments to indent nicely?
06:21:46 <Baughn> ivanm: First step, wait for 2.7
06:21:49 <ivanm> heh
06:21:58 <Baughn> ivanm: You can't. Yes, it's annoying. I'll fix it.
06:22:04 <ivanm> \o/
06:22:38 <ivanm> bah, now it argues about where to put the opening bracket for the export list :@
06:23:53 <Baughn> ivanm: Your best bet is to just grin and bear it. Go with haskell-indentation. :P
06:24:05 <ivanm> heh
06:24:08 * int-e wonders why Text.XML.HaXml.Escape does not export escapeContent
06:24:13 <Baughn> ivanm: Having a standard indentation across (most) haskell programs is a benefit in itself
06:24:37 <ivanm> agreed; but indentation changes the old standard ;-)
06:29:35 <int-e> (It's not hard to recover from xmlEscape, but it appears to be useful enough on its own.)
06:32:24 <bastl> dcoutts: in the paper "The Haskell Cabal", "install" seems to mean "copy+register" while cabal-installs "cabal install" does everything in one go. These are different things right?
06:33:04 <dcoutts> bastl: yes
06:33:12 <mmorrow> there's a cabal paper?!
06:33:15 <dcoutts> bastl: it's a slight semantic wart
06:33:25 <mmorrow> link? :)
06:33:28 <bastl> i must admit, the naming is arguably ...
06:33:31 <mmorrow> oh got it
06:34:03 <dcoutts> bastl: it'd end up meaning the same if we had proper dependency tracking since then it'd just do the previous steps if they had not been done already.
06:34:42 <dcoutts> bastl: but yes there's a wart there about what if you want to do the install step only
06:34:55 <bastl> ok
06:34:57 <dcoutts> bastl: if you've got a good suggestion I'd be happy to hear it
06:35:16 <bastl> for dependency tracking?
06:35:25 <dcoutts> no for the meaning of install
06:35:35 <dcoutts> meaning/behaviour
06:36:20 <bastl> i would rather think for another name for the "all-in-one-go" command
06:36:57 <fasta> Yes, having a stable command is really way too boring. I agree.
06:37:07 <bastl> *gg*
06:37:18 <absentia> so, with the call of the supercomputer conference... talking about exascale... 100 million cores?  I think `par` might become very interestig :-)
06:37:58 <fasta> absentia, are they really talking about that? Are there any videos/papers?
06:38:01 <dcoutts> bastl: aye, we could not think of any better alternative name
06:38:31 <bastl> dcoutts: the build-process is state-based: is there some kind of model for that "system"
06:38:32 <ben0x539> 'deploy' instead of install?
06:38:53 <dcoutts> bastl: yes, it's the same as the ./configure make one.
06:39:07 <dcoutts> bastl: ./configure; make; make install
06:39:19 <bastl> ben: i like that, install would stay stable, deploy would need the "right" behaviour ...
06:39:53 <dcoutts> or alternatively, remove Setup.hs install, and just use copy and register separately :-)
06:39:53 <ksf> cabal add
06:40:03 <bastl> dcoutts: is that described (formally) somewhere? I'm thinking of making the state persistent somehow ...
06:40:05 <ksf> that is, declare that a package should be installed.
06:40:23 <dcoutts> bastl: in the original Cabal spec
06:40:25 <ksf> cabal add of an already installed package would be a noop, of course.
06:40:39 <fasta> Isn't the program cabal completely distinct from the Cabal specification?
06:40:44 <ksf> cabal notthere would remove a package and dangling deps
06:40:47 <dcoutts> fasta: yes
06:40:59 <saml> how can i be of your service today?
06:41:21 <bastl> nah, i just want to explain things to others. not redisgn cabal :-)
06:41:38 * bastl stops thinking about cabal ;-)
06:41:47 <dcoutts> bastl: what do you mean exactly about making the state persistent?
06:41:54 <bastl> wel ...
06:41:54 <ksf> so there's a list of packages that should be installed (like gentoo's world file), and the system ensures that the state is like the user wants it to be.
06:42:00 <bastl> well ..
06:42:09 * hackagebot upload: optimusprime 0.0.1.20091117 - A supercompiler for f-lite (JasonReich)
06:42:43 <ksf> semantically, there should be a cabald that keeps running and ensures the right packages are installed all of the time.
06:42:48 <bastl> im thinking of an automaton, with state and transitions. the transitions are the "cabal copy" commands, but the state is not there (yet). I guess you need that for the dependency tracking
06:43:38 <bastl> (init) -> configured -> (configured)
06:43:44 <bastl> f***
06:43:52 <bastl> (init) -> configure -> (configured)
06:44:05 <dcoutts> bastl: of course in general you never know if the package has been built
06:44:26 <dcoutts> since you cannot see inside the dep tracking of the build system (if it even does track deps)
06:44:37 <bastl> yes. you would have to determine the state from inspecting the filesystem
06:44:40 <dcoutts> for an arbitrary custom build system
06:44:45 <ksf> one more reason to become a build system
06:45:09 <ksf> so we've got an excuse for failing.
06:45:10 <dcoutts> ksf: sure, it could work perfectly smoothly using the built-in build system
06:45:23 <dcoutts> where all deps were visible
06:45:31 * bastl is procrastinating
06:45:38 * ksf too
06:45:40 <dcoutts> but for an arbitrary package following the Cabal spec, it's not so easy
06:46:05 <ksf> actually, I'm even procrastinating procrastinating.
06:46:05 <bastl> though I love such tools and problems ...
06:46:30 <ksf> too tired to code, but I need to stay awake a bit longer
06:46:36 <bastl> is that higher-order ?
06:46:46 <Baughn> fix procastinate
06:47:09 <mmorrow> @hackage optimusprime
06:48:24 <ksf> someone should code up a cabal package named "swordfight" that scrolls random compiler invocations over the terminal.
06:48:33 <ksf> something like bsod for employees
06:49:05 <ksf> er coders.
06:49:29 <ksf> employed marketing guys sit before their bsods, waiting for an admin to arrive to reboot the box.
06:49:39 <Baughn> ksf: http://zip.4chan.org/a/src/1258468809670.jpg <-- I was looking forward to getting to use this on someone.
06:49:53 <jmcarthur_work> or just do something like: while [ 1 ] do make done
06:50:13 <Baughn> Better be 'make clean all'
06:50:13 <jmcarthur_work> with semicolons whereever they belong. i always forget where they go in shells
06:50:17 <jmcarthur_work> right that
06:50:28 <koala_man> while true; do make; done
06:50:38 <mmorrow> ksf: this is an amusing one http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7913
06:50:38 <jmcarthur_work> there we go
06:50:42 <Baughn> jmcarthur_work: Or just build firefox. I once had that go into an infinite loop.
06:50:52 <jmcarthur_work> :o
06:50:54 <mmorrow> ksf: recursively compiles the file that's currently being compiled...
06:50:59 <mmorrow> forever!
06:53:23 <zygoloid> mmorrow: throw in a forkIO and make a recursive self-compiling forkbomb?
06:53:31 <mmorrow> heh
06:54:01 <ksf> do it in the type system!
06:54:25 <zygoloid> in pure haskell'981
06:54:30 <zygoloid> *98!
06:54:49 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7913#a12231 <-- I dare you to run this
06:54:53 <ksf> eleven!!
06:56:14 <zygoloid> Baughn: holy cow
06:56:34 <mmorrow> heh
06:57:31 <Phyx-_> test
06:57:57 <zygoloid> Phyx-_: 3/10 tests failed
06:58:16 <Phyx-> lol
07:07:12 <mlesniak> I'm probably a blockhead at the moment, but where is the error in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4960#a4960
07:07:35 <mlesniak> (to english native speakers: do you really say blockhead?)
07:08:15 <byorgey> mlesniak: I rarely say it, but I certainly know what it means.
07:08:34 <Jafet> Native speakers say ruder things
07:08:42 <mlesniak> Not about themselves ;-)
07:09:16 <byorgey> mlesniak: if you have a list of type  Task a => [(String, a)]  all the list elements still must be the same type.
07:09:19 <Botje> mlesniak: yeah, you need some fancy type system stuff for that :(
07:09:20 <Lemmih> mlesniak: StaticTask and SyntheticTask aren't of the same type.
07:09:24 <byorgey> lists are homogeneous.
07:09:44 <Jafet> hlist!
07:09:58 <byorgey> mlesniak: I suggest making StaticTask and SyntheticTask two constructors of the same data type.
07:10:14 <mlesniak> byorgey: argh, yes, that should be possible, too.
07:10:35 <byorgey> that's a more Haskellish way; what you're doing seems more like an OOP sort of approach
07:10:36 <mlesniak> (I said I was a blockhead ;-)) It's obvious after you've heard the solution :D
07:10:44 <mlesniak> Thanks!
07:10:45 <byorgey> =)
07:11:14 <mlesniak> Haskell does make things easy. It's the developers who searches hard solutions :D
07:16:43 <ksf> said oleg after proving the h98 type system without extensions turing complete
07:17:22 <gal_bolle> when using ReaderT, how can I make a ReaderT r m a out of Reader r a: i'm looking for something with type (Reader r a) -> (ReaderT r m a)
07:18:04 <ksf> usually, you do it the other way round...
07:18:11 <quicksilver> i disagree
07:18:27 <quicksilver> the other way round is harder, you have to somehow remove the 'm'
07:18:29 <gal_bolle> ksf yes, but m is IO so I'm kind of stuck, am i not
07:18:41 <ksf> that is, start out with the transformer version and stick in the Identity monad
07:18:53 <Lemmih> gal_bolle: lift?
07:19:11 <zygoloid> gal_bolle: use runReader to transform into r -> a, then use return to transform into a form which you can give to the ReaderT constructor
07:19:24 <gal_bolle> ok
07:19:45 <quicksilver> gal_bolle: let hoistReader act = do { e <- ask; runReader act e } in hoistReader
07:20:07 <quicksilver> such things are potentially useful in State and other monads too
07:20:08 <sjanssen> hoistReader = asks
07:20:32 <sjanssen> quicksilver: you forgot return
07:20:34 <zygoloid> @type ReaderT . fmap return . runReader
07:20:53 <zygoloid> , [$ty| ReaderT . fmap return . runReader |]
07:20:54 <ksf> lambdabot's on vacation
07:20:55 <lunabot>  luna: Exception when trying to run compile-time code:
07:20:57 <quicksilver> (but are avoided if you program using the typeclasses instead)
07:21:05 <quicksilver> sjanssen: and you forgot newtype unwrapping, didn't you?
07:21:05 <ksf> and lunabot on strike
07:21:12 <zygoloid> in any case, that's Reader r a -> ReaderT r m a
07:21:17 <sjanssen> quicksilver: :)
07:21:38 <sjanssen> hoistReader = asks . runReader
07:22:08 <zygoloid> nice
07:23:04 * zygoloid observes that for ReaderT, asks = ReaderT . fmap return
07:25:34 <dcestari> hello
07:25:51 <dcestari> on pattern matching a value, how can I specify more than one class constrain?
07:26:40 <sjanssen> dcestari: class constraints go in type declarations, not patterns
07:27:01 <sjanssen> here is how it might look in a type decl: f :: (Ord a, Num a) => a -> a
07:30:03 <ksf> num implies ord, doesnt' it?
07:30:17 <jmcarthur_work> i thought it was just eq and show
07:30:39 <ksf> .o( show is crazy enough )
07:30:44 <jmcarthur_work> yeah
07:31:25 <int-e> @seen lambdabot
07:31:40 <ksf> ord implies eq, though, but one could derive eq from ord
07:31:55 <ksf> I guess there should be different classes for eq, le, and ge
07:32:04 <ksf> ...and then ord which depends on all
07:32:33 <MoALTz> :t Enumeration
07:32:50 <dcestari> is there a way to override Show instances ?
07:32:58 <ksf> ...and we finally need a way to say instance Foo a => Bar a without undecidable instances
07:33:05 <ksf> dcestari, hiding the prelude, yes.
07:33:06 <dcestari> I mean, show methods
07:33:27 <ksf> import Prelude hiding (show)
07:33:28 <dcestari> ksf: ugh, that sounds more than I need
07:35:20 <ksf> dcestari, if you're doing all that for exercise value, I recommend to read (slurp, if not grok) http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
07:36:01 <dcestari> ksf: thanks, will do!
07:36:23 <ksf> type-level magic isn't really for the faint of heart, at least not if you're not used to macros, continuations or worse.
07:39:24 <ksf> spj and oleg should do more papers jointly
07:41:18 <Jafet> Sufficiently advanced typing technology
07:41:41 <ksf> is indistinguishable from oleg's scheme source?
07:42:54 <bastl> dcoutts: I just had a look at "Cabal.cabal" and saw the GetOpt Module under OtherModules. How does it compare to System.Console.GetOpt ? I tried to use the latter, but finally got back to parse cli-arguments on my own.
07:43:06 <dcestari> ok
07:43:11 <dcestari> sorry for the flood
07:43:12 <dcestari> buy
07:43:14 <dcestari> but**
07:43:31 <dcestari> instance Show [P] where is not valid, right?
07:43:32 <dcoutts> bastl: it's just a slight variant with prettier output
07:44:05 <ksf> depends on whether P is a type synonym or not
07:44:36 <ksf> ...you can then either spell it out, or enable -XTypeSynonymInstances
07:44:52 <dcestari> P is from 'data P'
07:45:03 <dcestari> is an enum
07:45:04 <ksf> then it's a type and valid
07:45:32 <Saizan_> with FlexibleInstances
07:45:46 <ksf> oh well yes
07:45:58 <dcestari> Saizan_: you are right
07:46:07 <dcestari> but it overlaps instance Show [a] :S
07:46:07 <bastl> ah. btw: I made a Custom build that creates a parameterized PackageDescription and then uses defaultMainWithHooks. I can delegate most cabal-install commands, but for some it complains that it needs a .cabal file. e.g. sdist.
07:46:11 <ksf> never leave your house without FlexibleINstances and MultiParamTypeclasses
07:46:26 <Saizan_> dcestari: yeah, you'd need that too
07:46:29 <ksf> -XOverlappingInstances
07:46:34 <bastl> dcoutts: ah: has that to do with the missing prettyprinting for PackageDescriptions ?
07:46:52 <ksf> you're fine until you hit -XIncoherentInstances or -XUndecidableInstances
07:47:10 <dcoutts> bastl: not sure, there's something for making snapshots where we modify the .cabal file
07:47:11 <Saizan_> i actually think OverlappingInstances is way worse than UndecidableInstances
07:47:32 <ksf> it's always taking the most specific one, isn't it?
07:47:34 <Saizan_> OverlappingInstances let you break the "one type, one instance" rule
07:47:46 <Saizan_> with the module system
07:47:49 <dcestari> what should I use them?
07:48:13 <dcestari> I get overlapping errors on the calls to show
07:48:17 <Saizan_> dcestari: you could make a newtype for your [P] type, and declare a Show instance for that
07:48:36 <dcestari> Saizan_: a type alias?
07:48:43 <Saizan_> then wrap [P] in the newtype contructor when you want that instance
07:49:05 <Saizan_> dcestari: no, a newtype, e.g. newtype PList = PList [P]
07:49:15 <quicksilver> Saizan_: yes, it is much worse. Undecidable instances is just about circumventing a fiddly termination requirement.
07:49:27 <quicksilver> Saizan_: it is incoherent and overlapping that are bad voodoo.
07:49:34 <Saizan_> dcestari: it's like data at the source level, but has no runtime representation
07:49:36 <dcestari> Saizan_:  but then how would I insert new elements there?
07:50:17 <dcestari> Saizan_: say I have a ps :: PList, how do I do 'p : ps' ?
07:50:21 <quicksilver> ksf: it's taking the most specific one which it can see is applicable - but that means that in polymorphic contexts, a less specific one might be used
07:50:28 <quicksilver> ksf: which is a nasty break in compositionality.
07:50:49 <Saizan_> dcestari: you can unwrap and rewrap the PList constructor, you can also write a combinator like inPList f (PList xs) = PList (f xs) and then use inPList (p :) ps
07:50:54 <mmorrow> i just the other day learned how to actually use overlapping instances
07:50:58 <mmorrow> Typeable uses them
07:51:02 <mmorrow> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Typeable.html
07:51:52 <ksf> show, too
07:52:03 <ksf> [a] vs. [Char]
07:52:03 <Saizan_> Show?
07:52:06 <quicksilver> nope, show doesn't use overlapping instances.
07:52:11 <quicksilver> show is 100% haskell98
07:52:14 <Saizan_> yeah
07:52:19 <ksf> uh
07:52:33 <quicksilver> the haskell98 standard has a hack of gargantuan proportions to make the Show instance for [Char] work right :)
07:52:37 <mmorrow> -- The -XOverlappingInstances flag allows the user to over-ride
07:52:37 <mmorrow> -- the instances for Typeable given here.  In particular, we provide an instance --      instance ... => Typeable (s a)  -- But a user might want to say --      instance ... => Typeable (MyType a b)
07:52:40 <Saizan_> which reminds me, that we could just use the same trick as Char for dcestari's P
07:52:41 <quicksilver> but it does it without overlapping instances.
07:52:52 <dcestari> Saizan_: String ?
07:53:00 <dcestari> Saizan_: who is String defined ?
07:53:10 <mmorrow> , ''String
07:53:11 <lunabot>  GHC.Base.String
07:53:21 <Saizan_> dcestari: when did i say String?
07:53:38 <dcestari> Saizan_: hehe, sorry, just thought it was that you where talking about
07:53:59 <Saizan_> dcestari: you can solve your Show problems by implementing showList in the Show instance for P
07:54:01 <ksf> waaagh
07:54:13 <dcestari> Saizan_: great!!
07:54:21 <ksf> well you could newtype Char and do the same
07:54:39 <ksf> dcestari, http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/GHC-Show.html
07:54:47 <ksf> search for "Show Char"
07:54:54 <Saizan_> no need to newtype Char
07:55:02 <mmorrow> quicksilver: what is this hack of gargantuan proportions?
07:55:07 <dcestari> :O
07:55:16 <ksf> mmorrow, the link I pasted
07:55:18 <quicksilver> mmorrow: having a method called showList
07:55:27 <mmorrow> ahh
07:55:31 <mmorrow> ksf: link?
07:55:33 <quicksilver> mmorrow: and having a properly polymorphic show instance for [a] which calls showList on a
07:55:35 <mmorrow> ah, i see it
07:55:40 <Athas> I'm trying to run a CHP program, and I get this error: "registerDelay: requires -threaded".  Which part of the GHC stack takes this '-threaded' parameter?
07:55:43 <ksf> mmorrow, starts with http://
07:55:59 <ksf> ghc --make -threaded Foo
07:56:01 <mmorrow> ksf: i was looking for darpa://
07:56:29 <Saizan_> Athas: it's a link time option
07:56:35 <mmorrow> quicksilver: haxxor
07:56:42 <Athas> ksf, Saizan_: ah, OK.  Do I need any +RTS options too?
07:56:48 <ksf> nope
07:56:55 <ksf> though you might want to play with -N
07:56:59 <Athas> Right, it seems to work now.
07:56:59 <Athas> Thanks!
07:57:01 <ksf> for the number of OS threads
07:57:22 <quicksilver> mmorrow: you have to admire it, though.
07:57:56 <cads> hey is there a functional language that can be very similar to haskell or ml, but somehow also lets you change language modes into custom syntaxes and semantics for things like queries or other domain specific language kinds of applications?
07:58:14 <mmorrow> quicksilver: heh, fair enough
07:58:37 <mmorrow> cads: like QuasiQuotes?
07:58:41 <cads> it would have to have a way of defining syntaxes and maybe even semantic domains
07:58:44 <Jafet> cads, scala, F#
07:58:49 <quicksilver> haskell has QQ
07:58:49 <ksf> cads, haskell rules edsls
07:58:53 <mmorrow> cads: SML/NJ has had that forever
07:58:54 <Saizan_> both those languages have ways to extend the syntax
07:58:57 <quicksilver> ocaml has caml4p or whatever it's called
07:59:12 <cads> :)
07:59:26 <cads> many kudos to you guys for that torrent of suggestions :)
07:59:38 <cads> got some reading now :)
07:59:45 <dcestari> what is type ShowS ?
08:00:04 <mmorrow> , src ''ShowS
08:00:07 <lunabot>  type ShowS = String -> String
08:00:32 <ksf> it's a hack to make appending results faster
08:00:38 <dcestari> thanks
08:00:42 <mmorrow> , src ''ReadS
08:00:45 <lunabot>  type ReadS a = String -> [(a, String)]
08:00:52 <cads> quasi-quotes, eh? sounds like a lispism!
08:00:58 <ksf> are we going to get type String = Seq Char in h'?
08:01:08 <mmorrow> , [$bf|.+[.+]|] ""
08:01:09 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
08:01:09 <ksf> cads, template Haskell
08:01:14 * cads decides to do some research before throwing around _accusations_
08:01:23 <mmorrow> QQ is separate from TH, although they're related
08:01:36 <ksf> YES! TH is completely typesafe
08:01:47 <quicksilver> ksf: I shouldn't think so. (String = Seq Char)
08:01:50 <mmorrow> namely, you have to translate a String to an ExpQ/PatQ to make a QQ
08:01:55 <dcestari> ksf: how doest it work? I don't get it
08:02:00 <ksf> ...well, mostly. sometimes it just errors out at the wrong place when it comes to primops
08:02:00 <dcestari> ksf: String -> String
08:02:14 <dcestari> dcestari: give a String, return a String ?
08:02:14 <mmorrow> dcestari: (++) ==> (.)
08:02:34 <dcestari> mmorrow:  ??????
08:02:46 <mmorrow> dcestari: in the very end, you do (\showS -> showS []) to get a string
08:03:17 <ksf> > showFFloat (Just 2) (1/3::Double) $ show [1..10]
08:03:24 <ksf> , showFFloat (Just 2) (1/3::Double) $ show [1..10]
08:03:25 <lunabot>  "0.33[1,2,3,4,5,6,7,8,9,10]"
08:03:28 <mmorrow> dcestari: all it does it make appending not O(n^2), by using (.) instead of (++) to "append"
08:04:00 <dcestari> I get it
08:04:01 <ksf> ...so showFFloat takes the string show produced and appends it to its result instead of returing a [] at the end
08:04:23 <dcestari> showList ps = ("something" ++)
08:04:26 <dcestari> thanks
08:04:28 <mmorrow> , let to s = (s ++); from = ($ []) in from (to "a" . to "b" . to "c")
08:04:29 <lunabot>  "abc"
08:04:37 <mmorrow> right
08:04:54 <cads> have a buddy that is working with semantics and ontologies and he's putting together a way to map queries to structures in a way that lets you use natural language and doesn't require you to know the actual details of the structure
08:05:16 <cads> heh, it's all very abstract and vague to me
08:05:42 <dcestari> is there an equivalent to showList with Tuples ?
08:05:53 <quicksilver> nope, it's a one-trick-pony
08:06:01 <quicksilver> but really, custom show syntax is evil.
08:06:13 <quicksilver> if you're trying to override show you're doing it wrong
08:06:34 <quicksilver> show is supposed to be for producing valid haskell syntax - and the valid haskell syntax for a tuple is what the default show instance gives you
08:06:53 <quicksilver> the hack for String is because Strings do actually have a different valid haskell syntax to other lists.
08:10:32 <dcestari> quicksilver: I need to output a syntax tree in a custom defined format
08:10:46 <dcestari> quicksilver: is an academic sample project
08:10:57 <mmorrow> class Ppr a where ppr :: a -> Doc
08:11:16 <mmorrow> Doc is better for this type of thing anyway
08:11:44 <gio123> yet the queen is her number one fun, she is worth two million punds
08:11:51 <gio123> can one explain above snetence more humen undestandig way?
08:11:51 <mmorrow> , foldr (.) id (replicate 8 (braces . parens . brackets)) (int 42)
08:11:52 <lunabot>  {([{([{([{([{([{([{([{([42])}])}])}])}])}])}])}])}
08:13:56 <zygoloid> , [$ty| braces |]
08:13:59 <lunabot>  Doc -> Doc
08:14:06 <mmorrow> , let ppFun f args ss = text "function" <+> text f <> (parens . hcat . punctuate comma . fmap text $ args) <> text "{" $+$ nest 2 (vcat . fmap ((<> semi) . text) $ ss) $+$ text "}" in ppFun "f" ["a","b"] ["return a"]
08:14:07 <lunabot>  function f(a,b){
08:14:07 <lunabot>    return a;
08:14:07 <lunabot>  }
08:14:32 <jasonmay> , f
08:14:33 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
08:14:58 <mmorrow> , foldl f z [0..4]
08:15:00 <lunabot>  f (f (f (f (f z 0) 1) 2) 3) 4
08:15:04 <jasonmay> , f $ "foo" "bar"
08:15:05 <lunabot>  luna: Couldn't match expected type `t -> a'
08:15:16 <mmorrow> , [$ty| f |]
08:15:18 <quicksilver> dcestari: that is something you definitely should not use Show for
08:15:18 <lunabot>  forall a . FromExpr a => a
08:15:26 <mmorrow> jasonmay: it's from SimpleReflect
08:15:30 <mmorrow> , x
08:15:32 <lunabot>  x
08:15:33 <dcestari> quicksilver: what do you recomend?
08:15:42 <mmorrow> dcestari: Text.PrettyPrint
08:15:53 <quicksilver> dcestari: just a function - or a family of functions - called 'pp' or something.
08:15:55 <dcestari> Text.PrettyPrint ?
08:16:02 <quicksilver> organise them into a typeclass if you wish.
08:16:02 <dcestari> mmm
08:16:16 <dcestari> what's the fuss with Show ?
08:16:32 <dcestari> I already got it to do almost everything I needed
08:16:44 * quicksilver shrugs
08:16:47 <quicksilver> this isn't what it's for.
08:16:56 <mmorrow> dcestari: Show is by convention supposed to be valid haskell syntax
08:17:05 <mmorrow> dcestari: but of course you can do whatever you want :)
08:17:09 <cads> the thing that sucks is that when turing thought up the turing test, I'd say most people put a little thought into words they wrote.
08:17:13 <quicksilver> and Show, for example, already has instances for tuples ;)
08:17:27 <cads> now, it's impossible to tell you average idiot from a bot
08:17:29 <quicksilver> (...which I gather are different from the ones you want)
08:17:46 <quicksilver> cads: how long have you found it impossible to tell you average idiot from a bot?
08:17:47 * dolio is liking wl-pprint
08:18:26 <cads> quicksilver, yup :)
08:18:39 <mmorrow> dolio: ah nice, i'm actually thinking about making the switch (although more likely for future projects, since i've already got a crapload of HughesPJ-using code existing)
08:18:46 <dcestari> mmorrow: what do you mean by 'valid haskell syntax' is show used as a counter part with read? like a serialize unserialize fashion?
08:18:47 <cads> but it's worse because people don't think their language has to have coherence anymore
08:18:53 <mmorrow> dcestari: right
08:19:06 <dcestari> mm, didn't know that
08:19:09 <quicksilver> cads: can you elaborate on that?
08:19:28 <quicksilver> dcestari: not just that, but the output for show can also be cut-n-pasted back into a haskell program
08:19:38 <quicksilver> dcestari: very useful for isolating test cases and working with the repl
08:19:41 <mmorrow> right, that too
08:19:45 <mmorrow> super handy
08:19:57 <dcestari> well, I have I'm too far away to look back, and this is due tomorrow, after that I'll give Text.PrettyPrint a try
08:20:03 <mmorrow> and it can be parsed and prettyprinted by a haskell parser, etc
08:20:18 <mmorrow> dcestari: fair enough
08:20:22 <dcestari> thanks mmorrow and quicksilver, sorry for the n00b questions
08:20:31 <mmorrow> good luck
08:20:36 <dcestari> thanks
08:20:54 <cads> quicksilver, I think it has to do wit the prevalence of digital communications, but I think more people are communicating through text nowadays, informally through the internet and digital devices. But the style and grammar rules in these forms of communications are really lax
08:21:13 <quicksilver> if I programmed a bot, it would be most excellent at grammar
08:21:20 <quicksilver> perhaps that would give it away
08:21:33 <cads> you can have a phd in english text you "hey, r u still cumming 2 the movie?"
08:22:09 <Gracenotes> hm. are there any lambdabot clones currently running?
08:22:27 <hask11> @pl \x y -> x y
08:22:43 <dolio> id
08:22:48 <quicksilver> only lunabot, who isn't a clone
08:22:54 <hask11> how do I use lambdadot?
08:22:57 <mmorrow> Gracenotes: if you have one, make sure unsafeSTToIO is hidden first!
08:22:57 <quicksilver> and dolio, who is a cutprice imitation made of cardboard
08:23:12 <cads> heh, quicksilver, have you spoken to cleverbot? He's pretty intelligent, but he pretty much seems to resort to finding witty patterns of conversation
08:23:14 <Gracenotes> I don't. I'm just looking through the source :x
08:23:19 <mmorrow> Gracenotes: iirc that seems to be visible in a few of the clones people've had
08:23:21 <cads> he's a bit of a smartass, actually
08:23:33 <quicksilver> cads: no, I haven't.
08:23:52 <Gracenotes> mmorrow: and once you let in one IO action, you've let in them all! D:
08:23:54 <zygoloid> mmorrow: it'd sure be nice if the hackage version were secure :)
08:24:09 <mmorrow> Gracenotes: it take just one leak to sink a ship!
08:24:21 <cads> look him up, he's pretty darn entertaining.. till you realize that no, he can't watch a presentation and then give you notes on it, or anything useful :D
08:24:29 <Gracenotes> mmorrow: how does it not just show <IO ()>, though?
08:24:39 * zygoloid hands Gracenotes 'return () :: IO ()' and stands well back
08:24:49 <zygoloid> Gracenotes: it's unsafeIOToST which is dangerous
08:25:07 <mmorrow> Gracenotes: the "leak" being if you have some way to conjure unsafePerformIO-equivalent, it's game over man!
08:25:22 <cads> quicksilver, basically he can almost pass the turing test for everyday bullshit banter, but he doesn't have any planning really
08:25:23 <Athas> When I use 'ghc --make', I get an error due to both the transformers and mtl packages providing the same modules.  How can I resolve this?
08:25:31 <Gracenotes> *checks type signature of said function*
08:25:48 <quicksilver> Athas: hide the one you don't want to use
08:26:15 <Gracenotes> mmorrow:  :o
08:26:20 <Athas> quicksilver: how?
08:26:23 <zygoloid> Athas: qualified imports or -hide-package
08:26:45 <Athas> Thanks.
08:26:45 <zygoloid> *package-qualified imports, that is: import "mtl" Control.Monad.State
08:26:51 <cads> quicksilver, I got into an argument with him about whether pi is transcendental, and in the end he turned it around and said he'd not been talking about pi the number, but the other kind of pie, which "is clearly not transcendental, because it's in my belly"
08:26:54 <Saizan_> or ghc-pkg hide
08:26:59 <quicksilver> cads: lol.
08:27:02 <zygoloid> (you can import them both that way, if you want...)
08:27:16 <Gracenotes> cads: I think that means he lost
08:27:27 <Gracenotes> everything except for the pie, at least
08:27:36 <quicksilver> lost the argument but passed the turing test?
08:27:38 <cads> the pie wasn't even real :(
08:27:48 <mmorrow> a bot said this!?!
08:27:51 <Saizan_> the pie is a lie?
08:27:55 <zygoloid> that's pretty impressive
08:27:58 <mmorrow> yeah
08:28:03 <cads> I thought so too
08:28:10 <mmorrow> i don't believe it
08:28:10 <cads> but I still called him a douche
08:28:49 <cads> wonder if there's a way to search through the logs
08:28:51 <mmorrow> that had to be the guy talking as the bot
08:29:01 <cads> hah!
08:29:09 <hask11> how do I chat with lambdadot?
08:29:12 <mmorrow> that'd take some serious i don't even know what for a program to be able to say that
08:29:20 <quicksilver> hask11: lambdabot is broken today
08:29:28 <hask11> thanks
08:29:36 <quicksilver> mmorrow: it's a markov chain based on many many previous conversations
08:29:41 <cads> mmorrow, talk to him, www.cleverbot.com , you won't be amazed, but you'll be impressed
08:29:50 <quicksilver> mmorrow: (well, it's not just that, but that's part of the puzzle)
08:29:53 <mmorrow> hask11: if you just want to eval code, you can use lunabot
08:30:00 <mmorrow> quicksilver: hmm, interesting
08:30:04 <mmorrow> cads: oh nice
08:30:10 <cads> he's very used to people telling him "I love you"
08:30:19 <cads> because he'll be like "yeaaah, I get that a lot"
08:30:25 <cads> or "I know, human"
08:30:27 <mmorrow> cads: oh, you got that response from the web-based bot?
08:30:33 <hask11> mmorrow: no, I want to do some pointfree stuff
08:30:40 <cads> mmorrow, yep
08:30:42 <hask11> mmorrow: thanks.
08:30:48 <gio123> cads: are you a bot?
08:30:49 <mmorrow> , [$pl| \a b -> g (f a b) |]
08:30:51 <lunabot>  (g .) . f
08:31:00 <cads> gio123, I ask myself that a lot, actually
08:31:18 <mmorrow> , [$bf|.+[.+]|] ""
08:31:19 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
08:31:20 <gio123> cads: and did you prove?
08:31:20 <cads> till we know more about it, we can't know
08:31:26 <hask11> , [$pl| \a b -> g (f a b) |]
08:31:28 <lunabot>  (g .) . f
08:31:43 <hask11> mmorrow: thanks a lot for the info.
08:31:49 <mmorrow> hask11: no problem
08:33:22 <hask11> , [$pl| \x y z ->  x z (y z) |]
08:33:24 <lunabot>  ap
08:33:31 <mmorrow> lol
08:33:37 <mmorrow> mmorrow: IM IN YER LOOP UPPIN YER VARS TIL ALL THEM VARS AN 10
08:33:48 <cads> the way I see it, just a little more short term memory, and some kind of long term memory and goal system, and cleverbot could be a useful research aid.. you could have it read a book, and discuss it with you in summary:)
08:33:50 <mmorrow> cleverbot: I can't wait to leave you in africa.
08:34:06 <hask11> , [$pl| \x y z ->  x y (y z) |]
08:34:11 <lunabot>  Killed.
08:34:26 <mmorrow> hask11: unfortunately @pl is super resource-intensive
08:34:33 <cads> see mmorrow, the way I also see it is that the average input to clever bot is less than turing material :D
08:34:35 <Adamant> cleverbot is kind of boring
08:34:49 <gio123> cads: can it write papers also and publish it?
08:34:58 <mmorrow> hask11: the @pl in lambdabot returns more results than the one in lunabot because it's entirely unconstrained wrt resources
08:35:09 <cads> gio123, losers like me and you can only wish :D
08:35:13 <mmorrow> hask11: so @pl (\x -> x x) (\x -> x x) creates a zombie..
08:35:52 <gio123> cads: I will be so happy you give me such bot
08:35:58 <hask11> mmorrow: thanks, actually I am new. it's my first day on #haskell and first day on IRC too :)
08:36:10 <cads> gio, I'm pretty sure you're trying to become a bot like that
08:36:23 <cads> I know you russian botnet personality fragments
08:36:39 <gio123> what do you mean
08:36:40 <gio123> ?
08:36:48 <cads> (he doesn't know)
08:36:56 <gio123> who?
08:37:14 <Saizan_> mmorrow: no zombie because it doesn't spawn a process :) and now the thread should properly get killed
08:37:19 * cads takes the offtopic to #haskell-blah
08:38:37 <mmorrow> Saizan_: ah that's right, nice :)
08:39:01 <hask11> , [$pl| \x y z ->  x y z |]
08:39:03 <lunabot>  id
08:39:13 <Apocalisp> @type flip maybe
08:39:14 <hask11> , [$pl| \x y z ->  y x z |]
08:39:16 <lunabot>  flip id
08:41:13 <mmorrow> hmm, maybe having lunabot turn:
08:41:15 <mmorrow> #foo
08:41:18 <mmorrow> into
08:41:23 <mmorrow> , [$foo| ... |]
08:41:24 <lunabot>  luna: Not in scope: `foo'
08:41:29 <mmorrow> would be nice
08:41:38 <mmorrow> since QQ's are a total pita kinda to type
08:41:51 <mmorrow> #foo ...
08:41:53 <mmorrow> i meant
08:43:02 <hask11> , [$pl| \x y -> g (f x) (f y)|]
08:43:08 <lunabot>  Killed.
08:44:25 <hask11> , [$pl| \x y z ->  (x y) y z |]
08:44:27 <lunabot>  join
08:45:00 <hask11> , [$pl| \x y z ->  (x z) y z |]
08:45:06 <lunabot>  Killed.
08:45:56 <hask11> , [$pl| \p -> foldr (\x xs -> if p x then (x:xs) else xs) [] |]
08:46:02 <lunabot>  Killed.
08:48:27 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12234 <-- Would it be possible to implement something like this? Has anyone tried?
08:48:28 <mmorrow> one sec
08:48:52 <quicksilver> mmorrow: just implement that as a QQ ;) Then we could type , [$qq| #foo .... |]
08:49:15 <mmorrow> #ty let fix f = let x = f x in x in fix
08:49:16 <lunabot>  luna: parse error on input `fix|]'
08:49:20 <mmorrow> grrrr
08:49:24 <Gracenotes> Baughn: we don't quite have a flexible record system ;_;
08:49:28 <mmorrow> quicksilver: heh
08:49:35 <Baughn> Gracenotes: Template haskell, I'm thinking
08:49:41 <quicksilver> Baughn: you can do something like that, yes
08:49:45 <Gracenotes> mm
08:49:53 <Baughn> quicksilver: Without writing boilerplate? How? Help!
08:50:33 <quicksilver> Baughn: "lookup ((==a) . field1)" is all it takes for lookups
08:51:05 <Baughn> quicksilver: Without actually searching through everythin in the MultiMap. I'm thinking it'd be a set of Maps.
08:51:36 <Baughn> Cute answer, though. :P
08:51:39 <Gracenotes> something that always plagues me is that there seems to be no efficient two-way map
08:51:43 <dcestari> thank you all, got my project running!
08:51:50 <dcestari> will see you soon for part 2
08:51:51 <dcestari> hehe
08:51:53 <Baughn> Gracenotes: Use two Maps?
08:51:56 <quicksilver> yes if you want to be cleverer, a set of maps and possibly a typeclass or two
08:52:18 <Gracenotes> Baughn: that's quite a bit of overhead :/
08:52:33 <Baughn> Gracenotes: How should an efficient one be implemented, then?
08:52:48 <Gracenotes> I wouldn't consider it efficient exactly. I am thinking more of a structure made for it. so to your question, I have no idea
08:52:50 <mmorrow> #ty let fix f = let x = f x in x in fix
08:52:53 <lunabot>  forall t . (t -> t) -> t
08:52:56 <mmorrow> weee
08:53:01 <Gracenotes> \o/
08:53:05 <mmorrow> #pl \a b -> g (f a b)
08:53:07 <lunabot>  (g .) . f
08:53:11 <mmorrow> :)
08:53:20 <quicksilver> I'm not aware of an efficient two-way map which isn't, effectively, an index for each way
08:53:32 <quicksilver> and therefore morally not very different from two Data.Maps
08:53:39 <Gracenotes> Baughn: but, e.g. you can implement a MultiMap efficiently without making a Map k (Set v)
08:53:47 <quicksilver> #pl \a -> a |]
08:53:48 <lunabot>  luna: parse error on input `|]'
08:54:01 <mmorrow> quicksilver: me neither, although i'd be very interested if figuring out if there was one
08:54:09 <quicksilver> #pl \a -> a |] [|$pl| \b -> d
08:54:10 <Saizan_> #pl \a -> a \|]
08:54:10 <lunabot>  luna: parse error on input `|'
08:54:12 <lunabot>  (line 1, column 11):
08:54:12 <lunabot>  unexpected "]"
08:54:12 <lunabot>  expecting white space or simple term
08:54:19 <Gracenotes> there are data structures specifically for it. they just require some creativity to make. you know, those people throughout CS history who have made some of the most creative data structures, you think "how'd they come up with that"
08:54:34 <Baughn> Mm. I'm trying to look it up, but..
08:54:35 <mmorrow> #ty [|42\|]
08:54:38 <lunabot>  ExpQ
08:54:54 <Saizan_> #pl \a -> a \|] [$pl| \b -> ()
08:54:56 <lunabot>  (line 1, column 11):
08:54:56 <lunabot>  unexpected "]"
08:54:56 <lunabot>  expecting white space or simple term
08:55:00 <mmorrow> grr, maybe find all non-in-a-String |]'s, and escape the |s
08:55:20 <mmorrow> hrm, i thought errors were chopped at one line too..
08:55:23 <Gracenotes> quicksilver: perhaps it would then be a problem of finding a specific way of map storage that handles it with greater locality
08:55:27 <hask11> mmorrow: where do I find lunabot syntax? thanks.
08:55:35 <quicksilver> Gracenotes: there are data structures for two-way maps? where?
08:55:39 <mmorrow> , help
08:55:41 <lunabot>  type of an expression:      , [$ty| \x -> x |]
08:55:41 <lunabot>  get info for a type/class:  , src ''Monad
08:55:41 <lunabot>  get info for a var/con:     , src 'fix
08:55:47 <Gracenotes> quicksilver: not any currently that I know of -.-
08:55:52 <mmorrow> other than that, it's just haskell
08:56:03 <Baughn> quicksilver: There are none on NIST
08:56:06 <hask11> thanks.
08:56:08 <mmorrow> hask11: or did you mean something else?
08:56:15 <mmorrow> hask11: no problem
08:56:31 <mmorrow> #ty \x -> x
08:56:33 <lunabot>  forall t . t -> t
08:56:42 <mmorrow>  # is handay
08:56:53 <Gracenotes> quicksilver: ah, found it. http://en.wikipedia.org/wiki/Bidirectional_map
08:57:23 <Gracenotes> not sure about the sophistication of implementations
08:57:51 <hask11> mmorrow: actually I wanted to know what all commands are available? like pointfree, or running some haskell code..
08:58:39 <hask11> help doesn't list all commands.
08:58:40 <mmorrow> hask11: ah, ok. that's not actually documented anywhere, but i'll make a paste giving all the ones ("one" := QuasiQuoter) i can think of
08:58:56 <quicksilver> Gracenotes: I see no evidence the implementations are actually morally different from 'two maps' though :)
08:59:13 <hask11> mmorrow: that would of great help.
08:59:35 <Gracenotes> quicksilver: well, multimaps aren't morally different than maps to sets of elements, but that doesn't mean you can't finetune structures for them
09:00:13 <quicksilver> I disagree.
09:00:27 <quicksilver> there are multimap implementations which are (at least slightly) different.
09:01:28 <Gracenotes> then, imho, both your and mine preconceptions of bidirectional maps is limited by our lack of creativity in thinking of implementations :/
09:02:05 <mmorrow> hask11: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4961
09:02:06 <quicksilver> possibly. Or possibly there just aren't any.
09:02:45 <mmorrow> hask11: in addition to that, there's the `src' function, which takes a template-haskell Name and prettyprints the Info that `reify' returns
09:02:52 <mmorrow> , src ''Maybe
09:02:54 <lunabot>  data Maybe a = Nothing | Just a
09:02:56 <mmorrow> , src ''Just
09:02:57 <lunabot>  luna: Not in scope: type constructor or class `Just'
09:02:58 <mmorrow> , src 'Just
09:03:01 <lunabot>  data Maybe a_0 = ... | Just a | ...
09:03:01 <lunabot>  infixl 9
09:03:07 <mmorrow> gah!
09:03:10 <mmorrow> a_0 /= a
09:03:25 <hask11> mmorrow: thanks a lot.
09:04:15 <mmorrow> hask11: and then, for any of those quasiquoters, you can use the new "#foo ..." syntax for ", [$foo| ... |]"
09:04:33 <Gracenotes> it seems Boost has a sophisticated version as an extension.. and I can't figure out exactly how it works, heh
09:04:41 <mmorrow> oh crap, i just realized that #bf doesn't work if the QQ takes args additionally
09:04:45 <hask11> okay.
09:05:16 <hask11> thanks, now I will try a few.
09:09:47 <EvilTerran> mmorrow, what's this #syntax?
09:10:13 <mmorrow> EvilTerran: it just does "#foo ..." ===> ", [$foo| ... |]" at the level of String
09:10:31 <mmorrow> EvilTerran: it doesn't work if the QQ needs additional args i just realized
09:10:43 <mmorrow> so #bf ... doesn't work e.g.
09:10:55 <mmorrow> , [$bf|.+[.+]|]
09:10:56 <lunabot>  luna: No instance for (GHC.Show.Show
09:10:58 <mmorrow> , [$bf|.+[.+]|] ""
09:10:59 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
09:11:10 <mmorrow> , [$bf|,.|] "a"
09:11:11 <lunabot>  "a"
09:11:39 <mmorrow> but #ty works, which is nice
09:11:44 <mmorrow> #ty \x -> (x,x)
09:11:47 <lunabot>  forall t . t -> (t, t)
09:12:14 <mmorrow> #tyQ \x -> (x,x)
09:12:17 <lunabot>  ForallT [t] [] (AppT (AppT ArrowT (VarT t)) (AppT (AppT (TupleT 2) (VarT ...
09:12:20 <mmorrow> #tyQ \x -> x
09:12:23 <lunabot>  ForallT [t] [] (AppT (AppT ArrowT (VarT t)) (VarT t))
09:12:26 <mauke> , [$bf| +[[,----------]>+++++++++[<+++++++>-]<.[-]++++++++++.] |] "quit"
09:12:28 <lunabot>  "*** Exception: bf blocked on input"
09:12:32 <mmorrow> \0
09:12:39 <mauke> , [$bf| +[[,----------]>+++++++++[<+++++++>-]<.[-]++++++++++.] |] "quit\n"
09:12:40 <lunabot>  "?\n*** Exception: bf blocked on input"
09:12:51 <mauke> ah
09:13:00 <mmorrow> i always forget that
09:13:14 <mmorrow> oh
09:13:42 <mmorrow> hrm, yeah it makes you have to fiddle with the loop exit condition too
09:14:21 * mmorrow is having trouble figuring out how to modify that one to bail on \0 input
09:14:47 <mmorrow> oh
09:14:55 <mmorrow> , ord '\n'
09:14:55 <lunabot>  10
09:15:07 <mmorrow> , length "----------"
09:15:08 <lunabot>  10
09:15:17 <mmorrow> ah, now i see why you tried '\n'
09:15:58 <mmorrow> , length "++++++++++"
09:15:59 <lunabot>  10
09:16:57 * mmorrow gives up
09:20:47 <Absolute01> @src union
09:21:19 --- mode: ChanServ set +o mauke
09:21:20 --- mode: mauke set +vvv hackagebot preflex lunabot
09:21:28 <Absolute01> bot is down?
09:22:03 <mauke> she died for our sins
09:22:19 --- mode: mauke set -o mauke
09:22:22 <Jafet> Three days' downtime?!! Unacceptable
09:22:52 <Absolute01> repent we must!
09:22:55 <Absolute01> :-P
09:23:30 <Apocalisp> #pl \f z -> (flip ((flip o) z)) f
09:23:36 <lunabot>  Killed.
09:23:37 <Absolute01> Where can I find an update function that updates a value in a list based on some condition? No such function in Data.List
09:23:46 <Absolute01> I remember seeing it somewhere.
09:23:48 <mauke> Absolute01: I don't think there is one
09:24:02 * Absolute01 checks Data.Sequence
09:24:08 <mauke> well, depending on the condition you can do it with map
09:24:13 <Jafet> map (\x -> if some_condition then update x else x)
09:24:41 <quicksilver> Absolute01: since lists don't really have efficient update, such things are generally a sign you're using the wrongs structure.
09:25:03 <Absolute01> sequences has update and adjust
09:25:38 <quicksilver> yes, Data.Sequence has a much more efficient update
09:25:44 <quicksilver> which is why it provides those functions
09:26:00 <quicksilver> there is a sense in which the API is a clue to which operations are sensible
09:26:39 <Absolute01> Why didn't sequence override the traditional list operators? The new ones are harder to read, especiall for people unaware of the Sequence module.
09:27:19 <quicksilver> because it's something else
09:27:32 <quicksilver> it is a different structure, which you deal with in a different way
09:27:42 <quicksilver> giving the same name to two different things suggests they are the same
09:27:50 <quicksilver> this is the wrong message, if they are different.
09:27:58 <Absolute01> well lists ARE sequences...
09:28:06 <Cale> Absolute01: not all of them
09:28:09 <Hunner> was there another haskell os project started in portland by galois or someone that was newer than house? I think someone mentioned something at the icfp there...
09:28:10 <quicksilver> haskell lists are not Data.Sequences.
09:28:25 <Cale> Absolute01: Sequence has no support for infinite sequences.
09:28:25 <Absolute01> i mean in the literal sense
09:28:27 <quicksilver> a haskell list is a simple, lightweight, singly-linked list.
09:28:29 <Absolute01> now how they're implemented
09:28:34 <EvilTerran> mmorrow, ah, this is a lunabot thing, not a QQ thing?
09:28:40 <quicksilver> Data.Sequence is a fingertree
09:28:43 <Cale> Absolute01: while list does support infinite (mathematical) sequences
09:28:49 <Cale> > [1..]
09:28:51 <quicksilver> yes, but I'm talking about their differences in implementation.
09:29:08 <Absolute01> fine i'll dirty up my code. :)
09:29:09 <Cale> Oh, is lambdabot having trouble?
09:29:10 <quicksilver> ...which are important, for programmers.
09:29:16 <quicksilver> Cale: not having trouble so much as absent.
09:29:19 <Absolute01> Not sure if my professor will be able to read it.
09:29:21 <quicksilver> Cale: it didn't come back after the big split
09:29:25 <Absolute01> don't think he even knows haskell
09:29:25 <Absolute01> :)
09:29:29 <EvilTerran> in these days of limited computing power, algorithmic complexity is part of the interface
09:29:34 <Absolute01> thats what comments are for i guess
09:29:46 <Jafet> There is a little bit of Haskell in everyone.
09:29:47 <Cale> quicksilver: Still thinks it's connected to the network
09:30:04 <quicksilver> Cale: odd
09:30:30 <quicksilver> Cale: yes, it's still replying to me in PM
09:30:35 <quicksilver> Cale: (I hadn't thought to try that before)
09:30:46 <Cale> oh, I just reconnected it
09:30:51 <quicksilver> ah ;)
09:31:41 --- mode: ChanServ set +o mauke
09:31:42 --- mode: mauke set +v lambdabot
09:32:42 --- mode: mauke set -o mauke
09:40:49 <zygoloid> lambdabot was not available via privmsg previously
09:47:21 <Apocalisp> @bot
09:47:21 <lunabot>  :o
09:47:22 <lambdabot> :)
09:47:24 <Apocalisp> :)
09:49:37 <Phyx-> :O
09:50:41 <ehamberg> someone please explain: http://spikedmath.com/085.html :)
09:52:09 <mauke> "Does the the lambda symbol on an orange shirt has anything to do with Half-Life, or is it pure coincidence?"
09:52:11 <sjanssen> ehamberg: sometimes the composition operator is written as a small circle, so you have: f o g
09:52:12 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
09:52:28 <mauke> f∘g
09:53:01 <Gracenotes> lamby!
09:53:21 <Gracenotes> @let test 1 2 3
09:53:22 <lambdabot>   Parse error: SemiColon
09:53:49 <Gracenotes> hmm
09:54:10 <Gracenotes> @let test = in 4
09:54:11 <lambdabot>   Parse error: KW_In
09:54:59 <ehamberg> sjanssen: d'oh. thanks!
09:57:21 <Fairweather> what is the haskell equiv to the ternary operator?
09:57:32 <mauke> Fairweather: 'if'
09:58:05 <Fairweather> i see
09:58:09 * hackagebot upload: utf8-string 0.3.6 - Support for reading and writing UTF8 Strings (EricMertens)
09:58:19 <paolino> how can I take a random subset of list in the Gen Monad,  [a] -> QuickCheck.Gen [a] ?
09:58:49 <gressvol-> I'm trying to modify a function that can generate a arbitrary number of things, I got it to work with Int, but when I'm now trying to change it for a general type I doesn't work. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4963#a4963
09:58:54 <Fairweather> am I allowed to make an operator with different arity?
09:59:00 <Fairweather> than 2
09:59:14 <mauke> Fairweather: sort of, but then using it gets awkward
09:59:34 <Fairweather> what do you mean?
09:59:48 <blackh> gressvol: are you having trouble with :: g ?
09:59:48 <int-e> > let (!) = product . enumFromTo 1 in (10!) -- ugly
09:59:50 <lambdabot>   3628800
09:59:57 <blackh> gressvol-: ^
10:00:00 <mauke> > let (??) a b c = a * b + c in  (2 ?? 3) 4
10:00:01 <lambdabot>   10
10:00:12 <gressvol-> blackh: yes
10:00:34 <gressvol-> *** Expression    : arbitrary
10:00:34 <gressvol-> *** Type          : Gen b
10:00:34 <gressvol-> *** Given context : ()
10:00:34 <gressvol-> *** Constraints   : Arbitrary b
10:00:38 <Fairweather> oh, so it always goes between the first two operands
10:00:57 <mauke> Fairweather: a ? b is syntactic sugar for (?) a b
10:01:00 <mauke> for all operators ?
10:01:11 <blackh> gressvol-: If you want to be able to specify polymorphic types explicitly inside a function you need the ScopedTypeVariables extension with {-# LANGUAGE ScopedTypeVariables #-}
10:01:26 <Fairweather> I guess it's going to be 'if' then. thanks!
10:01:39 <blackh> gressvol-: But that's not all - you also need to put a 'forall' on your function's top-level type signature
10:02:07 <blackh> gressvol-: e.g. natural :: forall a . Int -> Gen a -> Gen [a]
10:02:23 <blackh> gressvol-: Now you can refer to 'a' inside your definition of 'natural' and get the right type
10:02:45 <blackh> gressvol-: These instructions are GHC-only, by the way
10:03:01 <paolino> hasn't QuickCheck a powerset function inside ?
10:03:10 <gressvol-> okey, but im using a interpreter
10:03:37 <blackh> gressvol-: Should be fine with ghci
10:04:26 <gressvol-> winhugs :/
10:04:59 * medfly gives gressvol- a hug
10:09:00 <chrisdone> free hugs?
10:10:14 <medfly> he won a hug
10:11:06 <mmorrow> EvilTerran: yeah, just a lunabot thing
10:11:42 <chrisdone> hi mmorrow
10:11:58 <chrisdone> <displays of affection>
10:12:27 <mmorrow> oh hai!
10:12:47 <mmorrow> chrisdone: doing much haskell lately?
10:13:40 <chrisdone> mmorrow: er.. bits and bobs. slowly working on some social site, once a weekend, ish. wrote a little zen coding parser recently. but nothing substantial
10:13:44 <chrisdone> mmorrow: you?
10:14:17 <chrisdone> mmorrow: I use C# daily at werk =(
10:14:31 <mmorrow> chrisdone: nice. yeah, i've been/am working on an interpreter/compiler a bunch lately
10:14:44 <chrisdone> mmorrow: interpreter/compiler for what?
10:14:48 <mmorrow> chrisdone: ah nice, what're you doing at work?
10:15:14 <mmorrow> chrisdone: for a lazy functional language, i'm using ghc as a frontend for now, via external core
10:15:27 <chrisdone> mmorrow: ah well it's a web dev. company so like 40 projects one after the other queued up ~_~
10:15:35 <mmorrow> chrisdone: i'm trying to get the last bits connected so i actually have something that works end-to-end
10:15:43 <mmorrow> chrisdone: heh
10:15:45 <chrisdone> mmorrow: ah does it compile to "core"?
10:15:54 <mmorrow> chrisdone: it compiles /from/ core
10:16:14 <mmorrow> i've got a bytecode interpreter, and i'm thinking about also generating C
10:16:23 <chrisdone> mmorrow: ahhh
10:16:45 <mmorrow> but focusing on getting the last level of intermediate language -> bytecode atm
10:16:46 <chrisdone> mmorrow: nice. bytecode interpreter =)
10:16:58 <chrisdone> mmorrow: can I see it?
10:17:42 <mmorrow> sure, although it'll take me a minute to get it into a coherent repo ... the compiler + interp is quite a lot of code actually
10:18:27 <chrisdone> mmorrow: well if it's a bit of bother I can wait until it's done
10:18:51 <mmorrow> the interpreter is in C, and the actual interp.c gets generated by a haskell module that parses another file containing bits of C + other misc that abstracts away the details of where the fields of the bytecodes are coming from etc
10:19:24 <mmorrow> i'll stick that combo up, since it's actually reasonably self-contained wrt details
10:20:16 <chrisdone> so the sourcecode for a runtime is generated from the source of the program, by a haskell program?
10:20:23 * BONUS waves at mmorrow
10:20:26 <BONUS> 'sup dog!
10:20:34 <stoop> * dawg
10:20:37 <stoop> or dogg
10:20:59 <BONUS> right, haha
10:21:00 <chrisdone> compiling while he's compiling
10:21:15 <mmorrow> BONUS: hey!
10:21:58 <chrisdone> do we have one of those google maps of haskell programmers?
10:22:06 <BONUS> finishing LYAH in between classes haha
10:22:09 <BONUS> busy days
10:23:01 <mmorrow> BONUS: cool, can't wait to see it.
10:23:59 <BONUS> what do y'all think if this parallel sequence i just hacked up: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12238#a12238
10:24:07 <BONUS> would this even work
10:24:27 <BONUS> supposed to run a bunch of IO actions parallely and return their results in a list
10:24:58 <chrisdone> "parrallely" is hard
10:25:02 <BONUS> i mean like
10:25:03 <BONUS> concurrently
10:25:09 <BONUS> with forkIO
10:25:13 <chrisdone> no, I like "parallely" :P
10:26:57 <chrisdone> BONUS: it seems like it would work fine?
10:27:09 <BONUS> yeah on first glance/test seems to work swell
10:27:19 <BONUS> man haskell's concurrency owns
10:27:38 <EvilTerran> BONUS, looks good, altho i note takeMVar would work in place of readMVar, and be atomic (which is unlikely to be relevant, but can't make it any worse)
10:27:52 <Phyx-> lalalaal
10:28:19 <chrisdone> good point
10:28:21 <Phyx-> how does one install haskell on fedora core
10:28:23 <BONUS> ah of course
10:28:47 <chrisdone> EvilTerran: I'd imagine takeMVar would garbage collect the MVars quicker, if I knew how the hell GHC's garbage collection worked
10:29:16 <BONUS> oh and also i guess >> return () is redundant after putMVar
10:29:18 <EvilTerran> BONUS, and i don't think you need that ">> return ()"; putMVar already returns ()
10:29:21 <EvilTerran> yeah :)
10:29:27 <chrisdone> hehe
10:29:46 * chrisdone changes "add revision"
10:29:53 <chrisdone> er, chants
10:30:20 <BONUS> revision!!!!!
10:30:36 <BONUS> lol you know what i did today. zipWith id (map f xs) ys
10:30:47 <BONUS> i felt pretty smart before realizing im a dumbass
10:30:59 <chrisdone> BONUS: wouldn't work on an infinite list would it? I guess that doesn't make sense for this problem..
10:31:06 <koeien37> BONUS: lol
10:31:39 <BONUS> yeah. i could do repeat newMVar but then if you sequence that, it doesn't yield a result
10:31:40 <chrisdone> BONUS: haha. would list fusion recognise that? =)
10:31:48 <BONUS> hmm i wonder
10:32:30 <mmorrow> chrisdone: http://moonpatio.com/repos/lem-interp/
10:32:50 <mmorrow> chrisdone: the C files in generated/ all get generated too, and are various things the interpreter needs
10:33:11 <mmorrow> there's something amusing about generating 100,000 lines of C code ;)
10:33:48 <chrisdone> mmorrow: yeah. to perform an operation doable in 10 lines of haskell
10:33:56 <mmorrow> if C were being generated, all that stuff wouldn't be necessary, since it could mostly be just done inline
10:34:01 <mmorrow> and only the parts that are needed
10:34:07 <mmorrow> chrisdone: heh
10:34:56 <cads> eep, can we make haskell quasiquotes not look like we're actually invoking super advanced phd-level haskell?
10:35:09 <mmorrow> and also, i think i may be generating more than is really needed, but the beauty of it is that you can just re-run the generator prog with diff options
10:35:28 <chrisdone> sure
10:35:28 <Twey> Everything new in Haskell looks Ph.D.-level until you understand it :þ
10:35:33 <mmorrow> and also can re-gen the interp.{c,h} too after editing the .vm file
10:35:47 <mmorrow> which makes it easy to tweak instructions
10:38:20 <cads> > [$expr|1 + 3 + 5|]
10:38:21 <lambdabot>   <no location info>: parse error on input `]'
10:39:08 <chrisdone> mmorrow: oh so all these MK_THUNK etc are instructions and the bit between [| and |] is C code. the haskell code just parses it to do the heavy lifting?
10:39:24 <chrisdone> heavy lifting = writing a load of c crap
10:39:24 <Phyx-> > fix
10:39:29 <lambdabot>   mueval-core: Time limit exceeded
10:39:34 <Phyx-> > fix read
10:39:38 <lambdabot>   mueval-core: Time limit exceeded
10:39:40 <Phyx-> :p
10:40:11 <paolino> :t fix read
10:40:12 <mmorrow> chrisdone: right, e.g.
10:40:13 <lambdabot> String
10:40:22 <chrisdone> mmorrow: including the grammar is very helpful. people should always stick the grammar in there. we can read it!! :D
10:40:40 <mmorrow> heh
10:40:56 <mmorrow> then the (tgt::W8) (nptrs::W8) (lwords::W16) ...
10:40:59 <mmorrow> get turned into
10:41:13 <chrisdone> adding to the stack?
10:41:28 <mmorrow>    W8 tgt = ((W8)(get8_1(__pc)));
10:41:28 <mmorrow>    W8 nptrs = ((W8)(get8_2(__pc)));
10:41:28 <mmorrow>    W16 lwords = ((W16)(get16_3(__pc)));
10:41:36 <mmorrow> ooh, that's the best part, there is no stack!
10:41:37 <chrisdone> sure
10:41:40 <mmorrow> it's a register machine
10:41:49 <mmorrow> so it's has to do register allocation too
10:42:01 <mmorrow> (which is the second thing i'm trying to get done)
10:42:13 <chrisdone> oh. yeah I just looked at "#define get8_0(o)    (((o).b8[0])) -- is that a register?
10:42:33 <mmorrow> that actually is just reading a field in a bytecode, but the
10:42:41 <mmorrow> R(i) is register i
10:42:49 <mmorrow> F(i) is floating-point register i
10:43:45 <chrisdone> ah. what size is the R register? sizeof(void*) ?
10:43:53 <mmorrow> the .b8 is from a union int64 {int i32[2]; long i64[1]; .... char b8[8];}
10:44:36 <mmorrow> i was debating whether to make the register size vary depending on the machine word-size, but i think i'm going to make them always be 64bits regardless
10:44:40 <stoop> int is not guaranteed to be 32-bits.
10:44:53 <stoop> It is guaranteed to be at least 28 bits, if I recall correctly?
10:44:54 <chrisdone> haha, thanks stoop
10:44:57 <m0nkfish> is there any existing function f where f "abc" => ["a", "b", "c"]
10:45:02 <chrisdone> mmorrow: yeah might as well
10:45:03 <mauke> stoop: no, at least 16
10:45:10 <stoop> mmorrow, there is stdint.h types (int32_t, uint16_t, etc..).
10:45:12 <mauke> m0nkfish: map return
10:45:14 <mmorrow> which would make things a lot easier from the pov of everything, but 32bit machines would tak a performance hit
10:45:18 <koeien37> m0nkfish: map (:[])
10:45:29 <mmorrow> stoop: yeah, iirc i'm actually using those
10:45:36 <stoop> mmorrow, ah, ok.
10:45:39 <stoop> mauke, oh?
10:45:40 <Veinor> (:[]) is my favorite
10:45:40 * stoop checks
10:45:45 <m0nkfish> i like (:[])
10:45:55 <Veinor> the face operator :D
10:45:59 <Vulpyne> Looks a bit like Homer.
10:46:29 <stoop> mauke, cool.
10:46:38 <stoop> I wonder where that 28 bits came from.
10:46:43 <mauke> Haskell
10:46:46 <stoop> Ahh!
10:46:47 <stoop> haha
10:46:48 <chrisdone> I prefer `return' to reduce the amount of code that looks like sesame street characters
10:46:59 * koeien37 prefers map return now too ;)
10:47:10 <Veinor> map return is nicer, but it's not intuitively obvious to a newbie
10:47:16 <koeien37> true
10:47:19 <chrisdone> mmorrow: this is preeeeety cool =)
10:47:32 <Veinor> I need to learn about the list monad sometime
10:48:24 <Veinor> @pl \xs -> [x | x <- xs]
10:48:24 <lambdabot> return . ((x | x) <-)
10:48:26 <mmorrow> chrisdone, stoop: here are the typedefs and those union defs http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4964
10:48:29 <chrisdone> Veinor: I think the notion that a haskeller panders to newbies is kind of funny considering that it's, well, haskell
10:48:30 <Veinor> oh, yeah
10:48:32 <mmorrow> chrisdone: :)
10:48:37 <stoop> @src [] (>>=)
10:48:37 <lambdabot> xs >>= f     = concatMap f xs
10:48:39 <stoop> @src [] (>>)
10:48:39 <lambdabot> xs >> ys      = concatMap (const ys) xs
10:48:40 <Veinor> chrisdone: well it is specifically a newbie asking :P
10:48:41 <stoop> @src [] return
10:48:42 <lambdabot> return x    = [x]
10:48:47 <stoop> Veinor, there you go.
10:48:49 <mauke> @. pl undo \xs -> [x | x <- xs]
10:48:49 <lambdabot> id
10:48:58 <chrisdone> stoop: stop god damnit! trying to click mmorrow's link :p
10:49:05 <mmorrow> chrisdone: at this point i realllllly anxious to get it working. i'm been hacking on this for months
10:49:10 <EnglishGent> hi all :)
10:49:20 <stoop> mmorrow, I see.
10:49:59 <EnglishGent> I have to agree with chrisdone - it does have a pretty steep learning curve - especially if you want to do real stuff as opposed to lab exercises
10:50:30 <EnglishGent> has anyone thought of perhaps taking the DrScheme approach & producing a set of sub-languages to make it easier to learn?
10:51:04 <EnglishGent> I've only been using the language for mayber ~5 weeks so far - and I've certainly had my fair share of gotchas & confusion
10:51:15 <stoop> EnglishGent, sounds fun.
10:51:37 <chrisdone> I think BONUS's LYAH is work in that kind of tact
10:52:04 <chrisdone> EnglishGent: what have you written in it?
10:52:05 <m0nkfish> is there any sort of 'greedy' zipWith
10:52:05 <Gracenotes> it is in tact
10:52:06 <EnglishGent> well I thought it might help beginners stoop - but I need to know more of the language myself before I could make any serious suggestions as to what they might be - I am recording my 'eh?!' moments as I go along though
10:52:09 <EnglishGent> so that might help
10:52:12 <mmorrow> LYAH is getting published too!
10:52:18 <Gracenotes> mmorrow: :O
10:52:21 <Gracenotes> :OOOO
10:52:27 <edwardk> EnglishGent: we have one of those its called 'Haskell 98' =)
10:52:29 <stoop> mmorrow, nice.
10:52:33 <EnglishGent> chrisdone - very shell scripty type things - duplicate file elimination, etc
10:52:34 <stoop> LYAH would make a beautiful book
10:52:35 <chrisdone> mmorrow: orly?
10:52:46 <EnglishGent> various*
10:52:46 <stoop> I hope its printed on shiny paper, though.
10:52:52 <Gracenotes> m0nkfish: you mean one that pads the shorter list?
10:52:58 <chrisdone> EnglishGent: maaan, I wrote a connect4 AI for my first project
10:53:04 <stoop> Hi edwardk
10:53:05 <EnglishGent> :)
10:53:05 <fentiman> isn't there a new version of haskell coming soon? the succesor to Haskell 98?
10:53:11 <edwardk> heya stoop
10:53:26 <Gracenotes> m0nkfish: it is possible to write one, but you might try sticking with primitive recursion, perhaps
10:53:30 <ray> haskell 99?
10:53:35 <ray> (2099)
10:53:37 <EnglishGent> I've also written breadth-first & depth-first search algorithms chrisdone - now I'm trying to generalise them to monads, so I can interleave search with IO
10:53:38 <tommd> fentiman: You are thinking of Haskell' (Haskell Prime)
10:53:42 <tommd> @where haskell'
10:53:42 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
10:53:47 <tommd> there ^^^
10:53:50 <EnglishGent> this is proving (for me) quite difficult at present
10:53:52 <EvanCarroll> Haskell++
10:53:53 <mmorrow> chrisdone: rly
10:54:01 <EvanCarroll> haskell, now with objects and side-effects
10:54:11 <lament> and templates!!
10:54:15 <edwardk> EnglishGent: there is a package on hackage for that iirc, i think sean leather did something
10:54:15 <stoop> My first project was porte.
10:54:33 <stoop> and beginnings of propositional logic library.
10:54:48 <chrisdone> edwardk: I'm guessing it's a pedagogical exercise
10:55:08 <EnglishGent> ooh - do you know the name edwardk? :)
10:55:20 <m0nkfish> Gracenotes: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4966#a4966
10:55:24 <chrisdone> guess not
10:55:28 <m0nkfish> here's a function i've defined on the (:) function
10:55:36 <m0nkfish> for 'greedy' zipwith
10:56:10 <edwardk> i stand corrected i think it was sebastian fischer. http://hackage.haskell.org/package/level-monad
10:56:12 <EnglishGent> and edwardk - I mean things even more limited that haskell 98 - just turning off all the language extensions doesnt do what I'm thinking of
10:56:18 <Gracenotes> m0nkfish: that seems fine as far as I can see..
10:56:49 <edwardk> EnglishGent: yeah, i'm familiar with the DrScheme approach. it is tricky. Helium tried to do that as I understand it.
10:56:57 <m0nkfish> Gracenotes: it works, was just wondering if there was anything more succinct or abstract
10:57:02 <edwardk> it gave pretty error messages in exchange for crippling the language
10:57:45 <tommd> For a second I thought you were talking about Helium.
10:57:48 <edwardk> Sulzmann's work on constraint handling rules/Chameleon also shows a way to give a haskell like type system very nice and informative error messages.
10:57:52 <Gracenotes> m0nkfish: not that I know of. map might work, but for that you need what you call a 'greedy' tuple-zip, which doesn't exist either. hm.
10:58:06 <EnglishGent> yes but that might be just what newbies need to get off the ground edwardk -- it's not so bad for me, I've done a lot of coding in other languages - including other functional languages, but one of my pet interests is in the development of child friendly languages (e.g. Logo)
10:58:24 <chrisdone> edwardk: that's a nice idea
10:58:33 <EnglishGent> and whilst Haskell is quite beautiful - *complete* novice (no prior programming experience) friendly it is not
10:58:41 <EvanCarroll> gosh there a ton of core functions in haskell
10:58:42 <edwardk> yeah
10:58:47 <chrisdone> probably bites people in the ass the most. you missed an argument but you're getting "no instance for .."
10:58:47 <EvanCarroll> why is there a repeat and cycle
10:58:56 <mtnviewmark> and yet not one of them handles text encodings!
10:58:57 <EvanCarroll> if a function can be written to do both
10:59:14 <EnglishGent> repeat repeats an element which need not be a list
10:59:19 <edwardk> EvanCarroll: Over time, you asymptotically approach writing no code at all, and learn to just conjure up what you need out of the prelude.
10:59:28 <EnglishGent> making it an infinite list consisting of just that element - cycle makes a list into an infinite cyclic list
10:59:31 <mtnviewmark> and even if it is a list, repeat and cycle do different things!
10:59:52 <EnglishGent> you could write repeat in terms of cyclic - but not the other way around :)
11:00:30 <mtnviewmark> myCycle = concat . repeat
11:00:30 <m0nkfish> Gracenotes: i'm using it with foldr to try and grab (map heads) and recurse through (map tails)
11:00:34 <EvanCarroll> edwardk: right, well why not get rid of repeat then
11:00:39 <m0nkfish> without being too verbose
11:00:43 <edwardk> repeat = cycle . return
11:01:14 <chrisdone> EvanCarroll: because you would be appending n lists unnecessarily?
11:01:34 <mtnviewmark> it's like a puzzle -- you can write so many things as bizarre combinations of other things
11:02:35 <chrisdone> @src cycle
11:02:36 <lambdabot> cycle [] = undefined
11:02:36 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:02:43 <edwardk> EvanCarroll: repeat is a common enough concern, even among people who don't yet understand monads. it technically probably falls below the Fairbairn threshold being that it is just a composition, but it is an obvious name for an obvious task.
11:02:54 <EnglishGent> m0nkfish - it's generally better to have things which are commonly wanted in the library, if only so everyone uses the same name - rather than writing umpty-ump different versions of the same thing
11:03:24 <EnglishGent> I do conceed the libraries could do with making it explicit that 'X can be written in terms of Y,Z -- but not the other way round' though
11:04:16 <edwardk> EvanCarroll: there isn't really any attempt to make sure that the core libraries are minimal, merely that they have provide implementations for common activities and there isn't too much redundancy.
11:04:43 <EvanCarroll> isn't too much redudancy seems to be ad odds with isn't minimal.
11:05:12 <EvanCarroll> i guess there could be an issue with concatenating vs appending a list of one with performance implications
11:05:16 <edwardk> EvanCarroll: it is a matter of taste. minimal would give you no utility, implementing everything anyone thought of would steal all the good names
11:05:39 <EvanCarroll> edwardk: `cycle [a] == repeat a`
11:05:44 <mtnviewmark> yes, good library design is an art, and a matter of taste....
11:06:05 <edwardk> cycle has a practical space reason for existing rather than using concat . repeat because the latter leaks space. repeat in terms of cycle should ultimately yield the same list
11:06:25 <edwardk> EvanCarroll: sure.
11:07:14 <BONUS> hmmm i'm exploring STArrays and such. how would I turn a STArray into a normal Array within an ST computation?
11:07:20 <edwardk> EvanCarroll: like i said, repeat technically falls below that 'don't name a composition' guideline, but it is a very common activity and an often used building block with zip, etc.
11:07:27 <idnar> @type repeat
11:07:28 <lambdabot> forall a. a -> [a]
11:07:28 <mtnviewmark> so, am I right in thinking that all the System.IO handle functions simply output the lower 8 bits of characters in Strings?
11:07:43 <mauke> mtnviewmark: yes (a known bug)
11:08:08 <mtnviewmark> ah - so the intention is to fix that in System.IO - or is it to require that people use something like the text package?
11:08:16 <edwardk> @type freeze
11:08:17 <lambdabot> Not in scope: `freeze'
11:08:24 <edwardk> BONUS: check freeze
11:08:35 <BONUS> ah
11:08:38 <BONUS> cool. funny function name
11:08:47 <BONUS> (lol. literally cool. haha, i kill myself)
11:08:56 <blackh> mtnviewmark: It's fixed in ghc-6.12, which means you'll have to be careful not to write code that breaks
11:09:02 <chrisdone> facepalm
11:09:09 <edwardk> unsafeFreeze is probably what you really want for performance reasons
11:09:13 <mtnviewmark> ah - do handles have an implicit encoding?
11:09:25 <edwardk> that will do so in place
11:09:30 <mtnviewmark> or is just "yo, if you don't do your own encoding, ya get UTF8"
11:09:30 <BONUS> ah
11:09:37 <BONUS> but is unsafeFreeze safe within an ST computation?
11:09:53 <mtnviewmark> Indeed - I'm just writing code that *would* break if I didn't know the answer!
11:10:01 <edwardk> BONUS if you don't reference the mutable reference to the array afterwards
11:10:01 <blackh> mtnviewmark: Not sure of the details, but you can read it in the ghc-6.12 online docs.
11:10:09 <mtnviewmark> thanks - will do
11:10:21 <BONUS> yeah, i just want to freeze it to package it up into a tuple before returning it
11:10:48 <edwardk> BONUS: that caveat is why the name is 'unsafeFreeze' rather than 'freezeInPlaceIMeanItPrettyPlease"
11:10:58 <BONUS> ah haha
11:11:21 <edwardk> BONUS: then you should be fine
11:11:33 <BONUS> awesome
11:12:00 <edwardk> ugh that reminds me i need to actually add some array primitives to kata =/
11:12:02 <Cale> If your ST computation is ending right there, you could also use runSTArray
11:12:13 <edwardk> cale: good idea
11:12:39 <chrisdone> > take 5 $ fix (\f xs -> xs ++ f xs) "a"
11:12:40 <lambdabot>   "aaaaa"
11:12:43 <chrisdone> @pl \f xs -> xs ++ f xs
11:12:43 <lambdabot> ap (++)
11:12:46 <chrisdone> duhh
11:12:48 <BONUS> Cale: yeah i would, basically i'm just messing about and implementing an efficient shuffling algorithm with STArrays
11:12:56 <BONUS> but i want to return ([a], StdGen)
11:12:59 <chrisdone> delicious ap
11:13:03 <BONUS> instead of just returning the list
11:13:17 <BONUS> that's why i think i can't just runSTArray
11:13:22 <Veinor> can anybody explain to me in a simple way how Data.MemoCombinator works?
11:13:35 <bitstream0101> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12241#a12241
11:13:48 <edwardk> i wish runSTArray could return an arbitrary functor full of STArrays rather than just a single one. then you could do it =)
11:13:51 <Cale> Veinor: the best place to start trying to understand it is with the bool combinator
11:14:02 <bitstream0101> Is the reason that I can't use runST on newScratch because of the additional type signature for buildArray?
11:14:15 <Cale> bool :: Memo Bool
11:14:15 <Cale> bool f = cond (f True) (f False)
11:14:15 <Cale>     where
11:14:15 <Cale>     cond t f True  = t
11:14:15 <Cale>     cond t f False = f
11:14:17 <m0nkfish> ok so is there any way to 'pad' a list so that zipWith will just use the empty list in its function application
11:14:55 <edwardk> hrmm guess it'd probably have to be a traversable worth of them
11:15:15 <Veinor> Cale: hm
11:15:29 <edwardk> that takes it a bit outside of the purview of both the Traversable module _and_ the ST module though
11:15:34 <kmc> :t zipWith
11:15:36 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:15:43 <byorgey> m0nkfish: I'm not sure what you mean.  can you give an example?
11:15:45 <jandem> i am playing with Parsec but i have this strange problem: "return [start, end]" works, but "return [start] ++ [end]" doesn't... Aren't they equivalent?
11:15:48 <kmc> m0nkfish, would the type signature change?
11:15:59 <byorgey> jandem: return ([start] ++ [end])
11:16:04 <Kim^Walkman> jandem: Operator preceedence
11:16:11 <pikhq> jandem: or return $ [start] ++ [end]
11:16:12 <byorgey> jandem: function application binds tighter than anything else.
11:16:12 <edwardk> jandem: return $ [start] ++ [end]
11:16:14 <Cale> Veinor: Let's have a look at what happens when we define a new function by applying bool to not
11:16:14 <kmc> if not, you can't really do it -- the function expects types a and b, and empty list might not be in those types
11:16:15 <Veinor> always parenthesize defensively :)
11:16:38 <edwardk> jandem: return is just a function and function application/juxtaposition binds tighter than anything (except @)
11:16:39 <Veinor> Cale: okay, so bool not = cond False True
11:16:43 <m0nkfish> kmc: b and c would have to be [a]
11:16:51 <Cale> Veinor: not immediately
11:16:51 <jandem> ah thanks guys!
11:16:54 <kmc> the general and natural thing would be: zipWithMaybe :: (Maybe a -> Maybe b -> c) -> [a] -> [b] -> [c]
11:16:58 <Veinor> ah, true
11:17:11 <byorgey> edwardk: (and record update syntax)
11:17:18 <edwardk> byorgey: that too
11:17:19 <Cale> bool not = cond (not True) (not False)
11:17:23 <bitstream0101> 'Inferred type is less polymorphic than expected' is the error I get from ghc with the code snippet in that paste.  I think it's because of the type signature on buildArray, and would like to get rid of it, but I don't think that I can :(
11:17:23 <edwardk> which always freaks me out
11:17:51 <kmc> bitstream0101, which paste?
11:17:58 <bitstream0101> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12241#a12241
11:18:08 <Cale> So if we define  not' = bool not, and then, let's suppose that we apply that function to True
11:18:15 <bitstream0101> kmc: I can't, e.g., do runST (newScratch 15)
11:18:31 <byorgey> bitstream0101: I think the problem is that the 's' in the type signature for newScratch is not the same as the 's' in the type signature for buildArray
11:18:35 <kmc> bitstream0101, because it would "leak" an ST action to the outside world
11:18:35 <Cale> Well, actually, more illustrative...
11:18:38 <bitstream0101> byorgey: right, that was my guess
11:18:40 <kmc> :t runST
11:18:41 <Cale> let not' = bool not in (not' True, not' True)
11:18:42 <lambdabot> forall a. (forall s. ST s a) -> a
11:18:42 <byorgey> bitstream0101: you should be able to fix this with the ScopedTypeVariables extension
11:18:44 <bitstream0101> so how can I fix it?
11:18:54 <byorgey> bitstream0101: hang on, I will paste it
11:18:58 <Veinor> Cale: ok, following you so far
11:19:00 <Cale> and suppose we're going to evaluate that pair completely
11:19:00 <yitz> hi edwardk
11:19:04 <bitstream0101> byorgey/kmc: thanks muchly!
11:19:20 <kmc> bitstream0101, runST (newScratch 15) would have type Maybe (Scratch (ST s))
11:19:23 <edwardk> hrmm: runSTArrays :: (Traversable t, Ix i, Monad m) => (forall s. STT s m (t (STArray s i e)) -> m (t (Array i e)) -- looks like it could be actually kinda useful
11:19:33 <Cale> So, we start out by evaluating not' as we said in terms of cond
11:19:34 <bitstream0101> kmc: yeah, that's the type I want it to have.
11:19:39 <kmc> and the point of ST is that it prevents the "s" variable from leaving the ST monad
11:19:41 <edwardk> er missed a closing paren on the argument there
11:19:52 <kmc> why do you have an ST action nested inside another?
11:19:52 <edwardk> runSTArrays :: (Traversable t, Ix i, Monad m) => (forall s. STT s m (t (STArray s i e))) -> m (t (Array i e))
11:20:05 <kmc> you probably want to join them first
11:20:06 <Cale> let not' = cond (not True) (not False) in (not' True, not' True)
11:20:13 <joe___> i am a newbie and am working with System.USB
11:20:18 <byorgey> bitstream0101: oh, that's a good point, it won't work even with the ScopedTypeVariables, the s is not allowed to escape
11:20:23 <bitstream0101> hmm
11:20:28 <kmc> :t join
11:20:29 <joe___> getDevice :: ctx -> IO device
11:20:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:20:36 <edwardk> heya yitz
11:20:44 <joe___> getDeviceDesc :: Device -> IO DeviceDesc
11:20:44 <Veinor> cond (not True) (not False) True evaluates to (not True)
11:20:45 <bitstream0101> (trying to see if that helps)
11:21:10 <joe___> sorry getDevices :: ctx -> IO [device]
11:21:21 <zygoloid> Veinor: but not just any (not True), a (not True) which is also held (and hence cached) by the call to cond
11:21:24 <Cale> But that's not just the expression (not True), it's also the parameter to cond
11:21:29 <byorgey> bitstream0101: anyway, here's how you would use ScopedTypeVariables: just introduce the extension, and bind the name s with the 'forall s.': http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12241#a12242
11:21:34 <bitstream0101> the problem is that it'll always be there as the type parameter for scratch, I think. this was done to attempt to provide a type that allows users to choose either an IO-based implementation or an ST-based one.
11:21:44 <Cale> Veinor: and parameters to a function will never be evaluated more than once
11:21:44 <bitstream0101> byorgey: still very good to know. thanks.
11:21:51 <joe___> any thoughts on how I can get from "IO [Device]" to "DeviceDesc"
11:21:53 <kmc> bitstream0101, for that i'd just use stToIO
11:21:57 <Cale> Veinor: So long as they remain in scope
11:21:57 <Veinor> Cale: ahhhhh, that's the central trick of Memo?
11:22:02 <Cale> Veinor: yeah
11:22:05 <kmc> :t stToIO
11:22:06 <lambdabot> Not in scope: `stToIO'
11:22:09 <Veinor> cool
11:22:13 <kmc> stToIO :: ST RealWorld a -> IO a
11:22:25 <Cale> So eventually, the definition of not' is refined into  not' = cond False True
11:22:32 <Cale> (as it is applied to True and False)
11:22:45 <kmc> in GHC, IO and (ST RealWorld) are basically the same
11:22:55 <bitstream0101> kmc: the ST-based implementation was to avoid any kind of IO altogether, though
11:23:20 <kmc> right, so i'm saying you can expose the ST interface only, and the user can use it with either ST or IO
11:23:33 <Veinor> heh, the memoization for integral is in terms of unsigned bits
11:23:40 <Cale> yeah
11:24:16 <bitstream0101> kmc: ok, i'll play around with it. thanks.
11:24:41 <Cale> Veinor: Of course, together with something that handles the sign
11:24:50 <Veinor> well, yeah
11:24:59 <m0nkfish> > "abc"++[]++[]
11:25:00 <lambdabot>   "abc"
11:25:27 <Cale> Veinor: Once you have bool and list, you can use those to encode anything :)
11:25:33 <Cale> list :: Memo a -> Memo [a]
11:25:36 <Veinor> it's true
11:26:03 <Veinor> and you can wrap any ADT in terms of lists
11:26:06 <Veinor> well, tuples
11:26:17 <m0nkfish> zipWith (:) ("a"++[]) ["bc"]
11:26:18 <kmc> you can also encode any ADT as its fold
11:26:19 <m0nkfish> > zipWith (:) ("a"++[]) ["bc"]
11:26:20 <lambdabot>   ["abc"]
11:26:23 <Cale> It basically builds up these functions which are structured like binary trees.
11:26:26 <m0nkfish> no no no :[
11:27:38 <Veinor> I like how you can memoize the function that takes unit as an argument
11:27:42 <Cale> m0nkfish: What's with the ++[] ?
11:27:48 <Cale> [] is the identity for ++
11:27:51 <m0nkfish> Cale: trying to pad a list
11:27:54 <chrisdone> venkatg: does it actually do that?
11:28:01 <Kim^Walkman> m0nkfish: Pad it with what?
11:28:05 <chrisdone> Veinor: er. I meant you
11:28:07 <Cale> xs ++ [] == xs, always
11:28:22 <Veinor> chrisdone: unit f = let m = f () in \() -> m
11:28:22 <Cale> (of course)
11:28:37 <jmcarthur_work> @check \xs → (xs :: [Int]) == xs ++ []
11:28:38 <lambdabot> Plugin `check' failed with: Enum.toEnum{Word8}: tag (8594) is outside of bounds (0,255)
11:28:38 <Kim^Walkman> m0nkfish: As a list can only contain one type, what would you pad “[1,4,3]” with?
11:28:48 <jmcarthur_work> @check \xs -> (xs :: [Int]) == xs ++ []
11:28:48 <kmc> (++ []) is a *slow* identity too ;)
11:28:49 <lambdabot>   "OK, passed 500 tests."
11:28:49 <m0nkfish> i want to adapt the function: zipWith (:) "a" ["b", "c"] to return ["ab", "c"]
11:29:14 <Veinor> I need to memoize int!
11:29:16 <Veinor> er, id
11:29:22 <kmc> in that case, don't "pad" any lists -- just don't call the function at all when you run off the end
11:29:32 <chrisdone> Veinor: nice. but I wondered if ghc did it automatically
11:29:50 <EnglishGent> does anyone know if there's an extension allowing closed type classes? (i.e. I promise that the instances defined in this module are the only instances there will ever be)
11:29:57 <m0nkfish> kmc: don't call the function...?
11:30:14 <mtnviewmark> > zipWith (:) ("a" : repeat "") ["b", "c"]
11:30:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:30:15 <lambdabot>         against inferred ty...
11:30:19 <Cale> > zipWith ($) ((a:) : repeat id) ["b","c"]
11:30:20 <Saizan> EnglishGent: there isn't
11:30:20 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
11:30:21 <lambdabot>         against inferred ...
11:30:21 <kmc> > let zw f [] ys = ys; zw f xs [] = xs; zw f (x:xs) (y:ys) = f x y : zw f xs ys in zw (:) 'a' ["b", "c"]
11:30:23 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
11:30:28 <Cale> > zipWith ($) (('a':) : repeat id) ["b","c"]
11:30:29 <lambdabot>   ["ab","c"]
11:30:38 <byorgey> EnglishGent: no, there isn't, but IIRC you can do some sneaky tricks to disallow instances elsewhere.
11:30:38 <m0nkfish> ah cale that is neat
11:30:41 <EvanCarroll> why would haskell default to storing 5 as an interger and not an int?
11:30:50 <byorgey> EnglishGent: but the type checker still doesn't know it.
11:30:53 <Cale> EvanCarroll: Because Integer is much more sane a type
11:31:00 <byorgey> EnglishGent: why do you want closed type classes?
11:31:04 <Cale> EvanCarroll: I wish that Int would die, personally.
11:31:10 <joe___> Prelude System.USB> :t getDeviceDesc
11:31:10 <joe___> getDeviceDesc :: Device -> IO DeviceDesc
11:31:10 <joe___> any suggestion/guidance on how can I write a filter function to identify a particular Device using an attribute in DeviceDesc
11:31:20 <kmc> :t filterM
11:31:22 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:31:22 <Cale> (well, really I just wish that it would get the heck out of the Prelude)
11:31:25 <mtnviewmark> > zipWith (++) ("a" : repeat "") ["b", "c"]
11:31:26 <lambdabot>   <no location info>: lexical error at character '\FS'
11:31:28 <fentiman> can anyone help? I'm trying to take integer input, but I only know how to get a String input and don't know how to convert this to an Int.
11:31:32 <chrisdone> Cale: haha. you saying that is like my grandma swearing
11:31:34 <kmc> fentiman, show
11:31:34 <jmcarthur_work> i don't mind the existence of Int32, Int64, etc.
11:31:39 <kmc> > show "1234" :: Int
11:31:40 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:31:40 <lambdabot>         against inferred type ...
11:31:41 <EnglishGent> byorgey - just thinking about teachability again
11:31:46 <kmc> err, read
11:31:49 <kmc> > read "1234" :: Int
11:31:50 <lambdabot>   1234
11:31:57 <kmc> d'oh
11:31:57 <Cale> chrisdone: eh?
11:31:59 <fentiman> ah ok, will try this thanks
11:32:05 <chrisdone> Cale: you're too nice to wish anything death :p
11:32:10 <byorgey> EvanCarroll: Integer can store *any* integer value, so it should be the default.  If you specifically care about size/performance and understand the issues involved, then you can specify Int instead.
11:32:12 <Cale> chrisdone: heh
11:32:18 <EnglishGent> I spend quite a lot of time thinking about how to teach programming - though so far most of that thought has been directed at more conventional languages
11:32:23 <Cale> fentiman: read
11:32:34 <Cale> fentiman: oh, you've already been answered :)
11:32:54 <kmc> i'm not sure a small Integer uses more space than an Int
11:33:01 <Cale> fentiman: You might also want to know about readLn though
11:33:02 <bitstream0101> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12241#a12245 does it make sense what I'd -like- to be able to do? the last paste there shows why the type parameter for Scratch escapes the 's' :(
11:33:06 <byorgey> EnglishGent: I'm curious, teachability of what? to whom?
11:33:15 <joe___> kmc, thanks. was that filterM comment meant for me?
11:33:15 <EnglishGent> I recall discovering the open nature of type classes was responsible for a few of my own "eh?!" moments :)
11:33:16 <Cale> fentiman: which is like getLine followed by read
11:33:20 <byorgey> EnglishGent: oh, didn't see your second sentence =)
11:33:26 <kmc> joe___, yes
11:33:32 <joe___> kmc, thanks.
11:33:33 <byorgey> EnglishGent: oh, I see.
11:33:34 <fentiman> Cale: thanks, will look up readLine then
11:33:40 <Cale> fentiman: readLn
11:33:50 <Cale> :t readLn
11:33:51 <lambdabot> forall a. (Read a) => IO a
11:34:05 <zygoloid> is there an IntAtLeast32Bits type or similar somewhere?
11:34:11 <Cale> I have no idea what the shortening convention is supposed to be :)
11:34:25 <Cale> getLine, putStrLn, readLn ...
11:34:26 <jmcarthur_work> zygoloid, Int is supposed to be "at least 30 bits" i think
11:34:34 <kmc> bitstream0101, it makes sense, i just don't understand why you want to runST on newScratchST
11:34:46 <Cale> If the prefix is more than three characters, Line becomes Ln? :)
11:34:48 <kmc> if you want it to be combined with other ST actions, you shouldn't runST
11:34:48 <jmcarthur_work> zygoloid, but that kind of weak specification is why i don't like it
11:35:00 <kmc> that's up to the user, once they've assembled the complete action
11:35:03 * hackagebot upload: peakachu 0.2 - Experiemental library for composable interactive programs (YairChuchem)
11:35:24 <yitz> edwardk: i've got to run now, but i just was hoping you'd have a look at my response to your reddit comment on the link to ndm's view pattern blog post.
11:35:25 <bitstream0101> kmc: oh, of course, that makes sense now that you put it that way :P
11:35:25 <zygoloid> jmcarthur_work: right. what i was asking for is something like C's int_least_32_t (or whatever it's called): the fastest int of at least 32 bits
11:35:26 <Cale> zygoloid: Int32 and Int64
11:35:37 <FunctorSalad> `putStrLn' is too long already...
11:35:47 <zygoloid> Cale: my code should not be encoding which of those two is better for different platforms :)
11:35:54 <osfameron> FunctorSalad: use 'say' like Perl!
11:35:57 <koeien37> FunctorSalad: no, it's too short
11:35:57 <bitstream0101> kmc: i was thinking i'd runST on 'something' inside a monadic quickcheck thing i'm writing, but i won't be doing it on the expression i actually demonstrated above.
11:36:03 * hackagebot upload: DefendTheKing 0.2 - A simple RTS game (YairChuchem)
11:36:09 <koeien37> FunctorSalad: putStringWithLine ;)
11:36:20 <Cale> zygoloid: Oh, then just use Int
11:36:26 <jmcarthur_work> zygoloid, that would be Int
11:36:35 <jmcarthur_work> zygoloid, the fasted int of at least 30 bits
11:36:40 <Cale> zygoloid: In practice, it's at least 32 bits, even if the spec says it can be smaller.
11:36:40 <jmcarthur_work> *fastest
11:36:53 <kmc> > (minBound, maxBound) :: (Int, Int)
11:36:55 <lambdabot>   (-9223372036854775808,9223372036854775807)
11:37:04 <Kim^Walkman> …
11:37:27 <Kim^Walkman> > 2 ^ 32
11:37:28 <lambdabot>   4294967296
11:37:35 <kmc> > 2 ^ 64
11:37:36 <koeien37> >2^64
11:37:36 <lambdabot>   18446744073709551616
11:37:39 <Vulpyne> lambdabot must be 64bit.
11:37:46 <koeien37> defaulting!
11:37:47 <burp> she is
11:37:48 <yitz> > length . takeWhile (>0) . iterate (`div` 2) $ (maxBound :: Int)
11:37:49 <jmcarthur_work> > 2^63
11:37:49 <lambdabot>   63
11:37:50 <lambdabot>   9223372036854775808
11:37:55 <Cale> > 2^63 - 1
11:37:56 <lambdabot>   9223372036854775807
11:38:00 <jmcarthur_work> that :)
11:38:16 <koeien37> >2^63 :: Int
11:38:25 <koeien37> > 2^63 :: Int
11:38:26 <lambdabot>   -9223372036854775808
11:38:53 <zygoloid> Cale: that's a pity. i was hoping to put together an argument of "there's no circumstance where Int is the right choice" :(
11:39:18 <Cale> zygoloid: There almost isn't. You should use Integer
11:39:38 <Cale> Unfortunately, the Prelude is filled with functions that use only Int, monomorphically.
11:39:51 <koeien37> :t drop
11:39:52 <lambdabot> forall a. Int -> [a] -> [a]
11:40:27 <jmcarthur_work> zygoloid, i think that claim holds for the most part, especially if you limit yourself to the criteria that a haskell program should behave the same no matter what platform it's on
11:40:31 <Cale> The argument being that you probably won't want to drop more than 2^n elements of a list anyway
11:40:48 <Cale> Even though that list is not in memory and is just maybe some small expression.
11:41:06 <jmcarthur_work> if all lists were strict i would agree with the argument
11:41:14 <Cale> (It's not exactly what you'd call an airtight argument)
11:41:33 <tommd> jmcarthur_work: But the Haskell spec abstracts away from platform specific issues a little - all Haskell Ints are >=31 bits, even on an 8 bit microprocessor.
11:41:51 <jmcarthur_work> tommd, sure, but i have no idea what 2^32 ∷ Int is going to be
11:42:10 <jmcarthur_work> err, 2^31 i mean
11:42:11 <Cale> ∷ <-- now there's an interesting character
11:42:15 <tommd> Either one.
11:42:26 <jmcarthur_work> i love ∷
11:42:36 <yitz> @tell edwardk I was hoping you'd have a look at my response to your reddit comment on the link to ndm's view pattern blog post.
11:42:36 <lambdabot> Consider it noted.
11:42:39 <chrisdone> I like the crab (;;)
11:42:44 <tommd> That's a unicode character?
11:42:49 <Cale> yeah
11:42:52 <tommd> Funny
11:42:56 <tommd> We must use it!
11:42:58 <chrisdone> what could it be used for?
11:42:58 <Cale> It's meant to be used for proportions
11:43:01 <jmcarthur_work> > 1 ∷ Int
11:43:02 <lambdabot>   1
11:43:05 * hackagebot upload: DefendTheKing 0.2.1 - A simple RTS game (YairChuchem)
11:43:19 <jmcarthur_work> it's already used ;)
11:43:27 <chrisdone> > let a ∷ b = a ++ b in "yay" ∷ "!"
11:43:28 <lambdabot>   <no location info>: parse error on input `"'
11:43:29 <chrisdone> :(
11:43:30 <Cale> a∶b∷c∶d
11:43:43 * mtnviewmark notes that everything typed here are all Unicode characters
11:43:57 <jmcarthur_work> > (\x → x) 5 ∷ Int
11:43:59 <lambdabot>   5
11:44:46 <chrisdone> ñ_ñ
11:44:53 <jmcarthur_work> really we are only abusing ∷ because we aren't using just : for types
11:44:55 <m0nkfish> mtnviewmark did you get anywhere with that zipWith experimentation
11:45:08 <mtnviewmark> > zipWith (++) ("a" : repeat "") ["b", "c"]
11:45:10 <lambdabot>   ["ab","c"]
11:45:11 <zygoloid> > let a ∷  String = "hello" in a
11:45:12 <lambdabot>   "hello"
11:45:19 <chrisdone> why was '::' chose for typeof instead of ':'?
11:45:28 <jmcarthur_work> probably so would could use : for lists
11:45:31 <mtnviewmark> it worked - i don't know why lambdabot ignored me before... overload?]
11:45:32 <jmcarthur_work> lightweight and all
11:45:33 <m0nkfish> > zipWith (++) ("ab" : repeat "") ["c", "d", "e"]
11:45:34 <lambdabot>   ["abc","d","e"]
11:45:36 <m0nkfish> ah
11:45:57 <m0nkfish> now you see there is another problem :) this should return ["ac", "bd", "e"]
11:45:58 <zygoloid> > ord '∷'
11:45:59 <lambdabot>   8759
11:46:08 <FunctorSalad> jmcarthur_work: lists could use :: then
11:46:15 <FunctorSalad> ._.
11:46:26 <Cale> chrisdone: Having lots of list conses in a row is more common than lots of type signatures. Typing :: is not so bad once in a row, but having to stick :: between each pair of elements in a list gets awkward.
11:46:35 <jmcarthur_work> FunctorSalad, i claim nothing about which is wiser, just the reason i think it was decided
11:47:01 * FunctorSalad doesn't have many conses in a row
11:47:11 <FunctorSalad> there's comma notation already
11:47:14 * jmcarthur_work thinks ease of typing arguments aren't as important as ease of reading
11:47:16 <pikhq> m0nkfish: Why should it? You are quite clearly doing the equivalent of: "ab" ++ "c" : "" ++ "d" : "" ++ "e"
11:47:18 * FunctorSalad stope bikeshedding
11:47:20 <FunctorSalad> *stops
11:47:28 <zygoloid> golfed programs generally don't have type signatures, so : is better as cons ;-)
11:47:37 <Phyx-> is there an easy way to install cabal-install on linux? or do i have to add all the missing dependencies first?
11:47:37 <Cale> Well, yeah, it's *also* important to ease of reading
11:47:38 <chrisdone> > let (+) = mappend in "Hello, " + "World!" -- why not? most other languages have polymorphic (+) :p
11:47:39 <lambdabot>   "Hello, World!"
11:47:45 <m0nkfish> pikhq what i mean is that i want it to ;)
11:47:51 <tavelram> @pl \a b -> (fst a)==(fst b)
11:47:51 <lambdabot> (. fst) . (==) . fst
11:47:55 <m0nkfish> i think my first example was a bad one since it had just one element
11:47:59 <Cale> Phyx-: download the package, unpack it, and run the bootstrap script.
11:48:12 <chrisdone> :t (==) `on` fst -- tavelram
11:48:14 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
11:48:17 <pikhq> chrisdone: Then we'd want (.) = (<$>).
11:48:18 <Phyx-> Cale: ah, thanks, didn't see the bootstrap script
11:48:20 <zygoloid> chrisdone: hsakell does have polymorphic (+), just not that one :)
11:48:26 <Cale> Phyx-: If it doesn't work, fix your broken installation of GHC by installing the generic binary package from the GHC website ;)
11:48:37 <tavelram> chrisdone, nice, cheers
11:48:48 <chrisdone> zygoloid: yes
11:48:50 <tavelram> @src on
11:48:51 <lambdabot> (*) `on` f = \x y -> f x * f y
11:48:55 <jmcarthur_work> chrisdone, Num's (+) even forms a Monoid
11:48:56 <Phyx-> Cale: nah it's working :)
11:49:01 <zygoloid> chrisdone: it'd be arbitrary to choose mappend = add rather than mappend = multiply for numeric types
11:49:15 <chrisdone> jmcarthur_work: could it not work as mappend then?
11:49:16 <zygoloid> (and to force that on anyone who wanted a working (+))
11:49:19 <Cale> Phyx-: I mention that because Debian in particular likes to split GHC up into a million tiny packages.
11:49:28 <jmcarthur_work> chrisdone, it certainly could
11:49:35 <tavelram> chrisdone, but where is on?
11:49:37 <Phyx-> Cale: i'm using Fedora 12
11:49:39 <jmcarthur_work> chrisdone, but (*) would make just as much sense
11:49:46 <jmcarthur_work> so we would have to choose
11:49:52 <zygoloid> (++) = mappend is reasonably nice i think
11:49:55 <zygoloid> ++haskell1.4
11:49:55 <chrisdone> but we've got * for that
11:50:02 <chrisdone> * doesn't work meaningfully for strings, but + does
11:50:24 <FunctorSalad> AddMonoid, MultMonoid
11:50:27 <FunctorSalad> o_o
11:50:28 <yairchu> chrisdone: that would be Python's (+), not a standard accepted (+)
11:50:55 <jmcarthur_work> i wish we could determine what symbols to use for type class operators locally without having to use let syntax
11:50:56 <yairchu> chrisdone: I think in tcl or some language "6" + "5" = "11"
11:51:00 <FunctorSalad> class class IsMonoid cls where ...
11:51:00 <mtnviewmark> > zipWith (maybe id (:)) (map Just "abc" ++ repeat Nothing) ["xx", "yy", "zz", "dd", "ee" ]
11:51:00 <zygoloid> chrisdone: or we could just say to hell with it. class Plus a b c | a b -> c where (+) :: a -> b -> c
11:51:01 <lambdabot>   ["axx","byy","czz","dd","ee"]
11:51:01 * chrisdone trying to have his cake and nom it too
11:51:09 <kmc> yairchu, perl
11:51:12 <FunctorSalad> nom nom nom
11:51:29 <jmcarthur_work> with an extension so that we can define multiple instance of the same type class for the same type and use them unambiguously
11:51:37 <jmcarthur_work> we would need a good syntax for it though
11:51:47 <yairchu> kmc: glad I don't have to use perl :)
11:52:02 <jmcarthur_work> maybe instances could be named (would start to look a lot like records)
11:52:09 <bitstream0101> Can someone help me grok Test.QuickCheck.Monadic stuff w.r.t. the ST monad? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12247#a12247
11:53:10 <chrisdone> FunctorSalad: I guess if you had (+) for AddMonoid and (*) for MultMonoid that would be awesome
11:53:23 <chrisdone> jmcarthur_work: that's a cool idea... any caveats to naming instances?
11:53:54 <bitstream0101> :t Test.QuickCheck.Monadic.monadic
11:53:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m Property -> Property) -> Test.QuickCheck.Monadic.PropertyM m a -> Property
11:53:57 <FunctorSalad> let's have parameterised modules too :o
11:54:02 <jaspervdj> why is a Set not a Functor?
11:54:04 <chrisdone> tavelram: sorry, it's in Data.Function. I didn't see your message
11:54:20 <tavelram> chrisdone, np
11:54:21 <EnglishGent> Cale - I've ran into that (Debian / GHC) - I dunno why they do it - it only adds yet _more_ confusion as far as I can see
11:54:39 <kmc> jaspervdj, can't include the (Ord k) constraint in fmap
11:54:51 <bitstream0101> the problem is that runST doesn't quite look like it will fit the (m Property -> Property) requirement :(
11:54:58 <Cale> EnglishGent: The ghc package should at least *require* all the standard libraries.
11:54:59 <kmc> could however provide it with the Set type itself, but H98 ADTs don't work that way
11:55:14 <Cale> EnglishGent: Even though it really doesn't, it would save a lot of confusion.
11:55:15 <EnglishGent> 100% agreement here Cale
11:55:16 <bitstream0101> because of the quantifier, i guess.
11:55:33 <kmc> bitstream0101, can't you just test with stToIO?
11:55:50 <FunctorSalad> you can make Codensity Set a Monad though
11:56:02 <kmc> what's a Codensity Set
11:56:03 <edwardk> jmcarthur_work: there are consistency issues with named instances
11:56:03 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:56:07 <m0nkfish> mtnviewmark thats good :)
11:56:10 <chrisdone> edwardk: what is that issue?
11:56:16 <edwardk> jmcarthur_work: in the end they really aren't workable as i recall.
11:56:23 <m0nkfish> > zipWith (maybe id (:)) (map Just "abcdef" ++ repeat Nothing) ["xx", "yy", "zz", "dd", "ee" ]
11:56:24 <lambdabot>   ["axx","byy","czz","ddd","eee"]
11:56:43 <FunctorSalad> kmc: something like "Set' a = Set' (forall b. Ord b => (a -> Set b) -> Set b)"
11:56:45 <bitstream0101> kmc: I guess I could, but part of this is me trying to learn about monadic quickcheck as well ;P if the ST monad is sufficiently oddball vs. other monads that stToIO is the only way to do it, then that's fine.
11:56:56 <bitstream0101> kmc: or the only sensible way, i should say
11:57:06 <edwardk> the problem is right now you have confluence between instances you are passed and once you construct out of whole cloth yourself, so it doesn't matter where they come from. you can wind up with functions you can't type that would have to be passed dictionaries for types that aren't related to their arguments and results
11:57:07 <kmc> bitstream0101, it's more that ST and IO are nearly the same
11:57:12 <kmc> or rather that IO is a special case of ST
11:57:42 <kmc> and yeah it's somewhat oddball due to the rank-2 runST function
11:57:51 <FunctorSalad> couldn't the instances problem be solved with local module open/closing? :o
11:58:01 <FunctorSalad> solved in a rather non-invasive way
11:58:13 <bitstream0101> kmc: ok, makes sense. but let's say I had some other oddball monad with a rank-2 run function -- what would be the best approach?
11:58:24 <kmc> bitstream0101, i'm not sure to be honest
11:58:32 <bitstream0101> kmc: good enough for me. thanks =)
11:59:09 <kmc> bitstream0101, this paper talks about testing in ST, apparently: http://www.google.com/url?sa=t&source=web&ct=res&cd=3&ved=0CBYQFjAC&url=http%3A%2F%2Fwww.cs.chalmers.se%2F~rjmh%2FPapers%2FQuickCheckST.ps&ei=aQADS5-WN8KzlAesjJ3aAQ&usg=AFQjCNHy-bL3jFn0Rj7E6pqGqxeI_ARC1w
11:59:17 <kmc> err www.cs.chalmers.se/~rjmh/Papers/QuickCheckST.ps
11:59:32 <chrisdone> edwardk: that sounds complicated
11:59:53 <bitstream0101> kmc: yeah, i've attempted to wrap my head around it. i couldn't fully follow their description of the functions that were "like" 'monadic runST'
12:00:17 <bitstream0101> kmc: and the function 'imperative' that they describe is commented out in the QuickCheck source code with a remark that it doesn't compile.
12:01:13 <mtnviewmark> m0nkfish: I think 'maybe' maybe my favorite function!
12:02:45 <joe___> how can i define a function with types at ghci prompt
12:03:03 <joe___> i want to define "functionx :: type1 -> type2"
12:03:25 <joe___> but keep getting errors, must be something small that I am missing. Any thoughts, please?
12:03:26 <MyCatVerbs> "let f x = x" defines f.
12:03:27 <edwardk> chrisdone: you get the same issues with locally-scoped instance declarations too.
12:03:49 <m0nkfish> in the context of this problem i don't think i should use Maybe though :)
12:03:57 <MyCatVerbs> joe___: "let f = \x -> x :: Int -> Int" defines f, and fixes its type to Int -> Int.
12:03:59 <m0nkfish> i think i will approach from a different angle
12:04:12 <joe___> mycatverbs, thanks.
12:04:25 <MyCatVerbs> joe___: GHCi is a bit of a pain in the hiney in this regard. You can't define data types at the GHCi prompt either.
12:04:43 <FunctorSalad> mtnviewmark: You May Also Like: either
12:04:56 <kmc> what about:  let f :: Int -> Int; f x = x
12:04:58 <MyCatVerbs> If you're building programs of interesting size, it's much easier to write a .hs file, load it with :load and then keep reloading it with :reload.
12:05:22 <MyCatVerbs> kmc: I did not know about that.
12:06:11 <Kim^Walkman> m0nkfish: What types will you use this for?
12:06:51 <yairchu> btw, anybody enjoys computer games?
12:07:27 <yairchu> because I wrote a game in Haskell that requires someone to play against..
12:08:05 <Kim^Walkman> m0nkfish: Consider “zipWith replicate [1..5] ['a'..'f']”, we'd have “["a","bb","ccc","dddd","eeeee"]” (:: [String]) as a result and an 'f' (:: Char) as a leftover; it’s not obvious what to do with this character as you can't straight-off append it
12:08:07 <Phyx-> heh, i get when running runghc "lexical error at character '\DEL'"
12:08:26 <Kim^Walkman> yairchu: I could join you if it takes less than 20 minutes :)
12:08:40 <yairchu> Kim^Walkman: got cabal? cabal update; cabal install DefendTheKing
12:09:24 <yairchu> Kim^Walkman: it takes less than 20 mins :)
12:09:29 * Kim^Walkman is compiling
12:09:37 <yairchu> cool :)
12:09:41 <mtnviewmark>  FunctorSalad - I do like 'either' too, but 'maybe' wins my heart because I didn't anticipate how much more useful it is than 'fromMaybe' -- it is unexpected beauty in API design
12:09:55 <skorpan> i don't suppose there is some (intuitive) switch-like construct in haskell?
12:10:15 <tensorpudding> there is a case statement
12:10:19 <Kim^Walkman> skorpan: case t of * -> *
12:10:24 <monochrom> I think case is very intuitive.
12:10:26 <yairchu> mtnviewmark: it's maybe's "catamorphism"
12:10:34 <FunctorSalad> meow
12:10:35 <monochrom> Hell, all of Haskell is intuitive!
12:10:44 <mtnviewmark> there's a $10 word!
12:10:47 <m0nkfish> Kim^Walkman: yeah, i understand the implications. you'd need to provide a "base" for both sides of the zipping function
12:11:04 <tensorpudding> monads aren't intuitive
12:11:09 <kmc> yes they are
12:11:10 <skorpan> case _ of { x == y -> .. ; fmap fmap lol -> .. ; } would that work as long as the RHS of each "case guard" (?) have the same type?
12:11:11 <monochrom> monads are intuitive
12:11:27 <m0nkfish> i just have the feeling my prof set us this question because there is a neat way to solve it. i just need to figure out what this neat way is!
12:11:28 <monochrom> I don't understand why people keep saying "this is not intuitive" "that is not intuitive".
12:11:29 <kmc> _ | x == y -> ...
12:11:35 <skorpan> kmc: ah, of course
12:11:52 <Kim^Walkman> yairchu: Interesting :p
12:12:24 <tensorpudding> monochrom: because they don't perceive them to be intuitive?
12:12:47 <yairchu> Kim^Walkman: so I guess it's working. so get comfortable with dragging and dropping the pieces and I'll start my client in a min. when I connect the board will turn half-black. that's the "fog of war" :)
12:13:26 <Kim^Walkman> yairchu: Oh, dragging too; I love the “cursor” or what you'd call it
12:13:48 <tavelram> @pl uncurry (flipt (,))
12:13:48 <lambdabot> uncurry (flipt (,))
12:13:55 <tavelram> @pl uncurry (flip (,))
12:13:56 <lambdabot> uncurry (flip (,))
12:14:00 <tavelram> :t flipt
12:14:01 <lambdabot> Not in scope: `flipt'
12:14:43 <donri> monochrom, because they're told monads allow pure IO (kinda)
12:14:48 <skorpan> halp http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12249#a12249
12:15:03 <yairchu> Kim^Walkman: thanks :) so I guess I forgot to implement resend for my "hello" packet. may you restart your client and hopefully it will work? (udp packet loss, during game the protocol has no problem with packet loss..)
12:15:19 <Jedai> tavelram: pl converts pointful (explicit arguments) code into pointfree code, "uncurry (flip (,))" is already pointfree, so...
12:15:30 <Jedai> @unpl uncurry (flip (,))
12:15:30 <lambdabot> uncurry (\ b c -> (,) c b)
12:15:46 * Phyx- curses at cabal
12:16:00 <kmc> monads are very intuitive.   the capture a notion of "do something, then use the result to decide what to do next, then do it"
12:16:23 <Jedai> @pl (\(x,y) -> (y,x))
12:16:24 <lambdabot> uncurry (flip (,))
12:16:35 <mtnviewmark> they would be more intuitive if they were called "Controllers" --- even if that term isn't strictly correct
12:16:36 <skorpan> please, oh wise ones, help me understand my syntax error and give me constructive ideas about how to make it prettier!
12:16:56 <monochrom> Make your syntax error prettier? Sure...
12:17:01 <mtnviewmark> similarly "catamorphism" would be "more intuitive" if we said "Projector" or some such
12:17:05 <skorpan> monochrom: i meant the code in general :P
12:17:16 <FunctorSalad> mtnviewmark: 'fold'
12:17:17 <mauke> skorpan: 'otherwise'
12:17:25 <mtnviewmark> even better!
12:17:34 <skorpan> uhm, uh...
12:17:37 <skorpan> i was using -> instead of =
12:17:39 <Phyx-> Cale: when i run the bootstrap it tells me "Sorry, Something went wrong"
12:17:43 <monochrom> Oh, "halp" means "help". I thought "halp" was the name of a new invention.
12:17:45 <skorpan> but that's a separate error
12:17:45 <Phyx-> which is not very useful
12:17:46 <Phyx-> lol
12:17:56 <skorpan> mauke: that didn't help actually =/
12:18:01 <Jedai> skorpan: case () of _ |....
12:18:03 <dcoutts> Phyx-: if it knew it'd tell you, check the build log
12:18:26 <skorpan> thanks Jedai
12:18:40 <Cale> Phyx-: Does it not tell you anything except that?
12:18:41 <Jedai> skorpan: You should probably use when though
12:18:45 <FunctorSalad> monochrom: http://images.google.com/images?um=1&hl=en&safe=off&q=halp
12:19:09 <monochrom> Oh God it is a new invention indeed, a terrible one.
12:19:17 <Phyx-> Cale: nope, nada, lol
12:19:24 <skorpan> Jedai: i don't really see how... could you elaborate?
12:19:25 <Phyx-> dcoutts: ok, where is that stored?
12:19:40 <skorpan> you mean i should use one "when" for each case?
12:19:44 <dcoutts> Phyx-: it's the scrollback in the terminal
12:19:57 <FunctorSalad> monochrom: I think it's cute
12:20:34 <Jedai> skorpan: Probably, but I don't really understand what you're doing (the "undefined" will be replaced by something useful though, right ?)
12:20:34 <Phyx-> dcoutts: well, that ends with "Sorry, Something went wrong" after succesfully building cabal. the last line before that says Installing executables
12:21:09 <skorpan> Jedai: yes, it will... basically i will update the parser state (which is a stack of indentations) depending on whether or not the indentation has changed.
12:21:25 <dcoutts> Phyx-: then presumably that bit is failing, the final check is that the cabal exe ended up in the expected location
12:21:36 <Jedai> when (oldInd < curInd) $ blabla; when (oldInd > curInd) $ yadayada; when (oldInd == curInd) $ yadayada
12:21:48 <skorpan> alright, got it
12:21:52 <dcoutts> Phyx-: I think in the released version there's some bug to do with the PREFIX variable, are you using that?
12:22:05 <Jedai> skorpan: That's really more a matter of taste though
12:22:12 <Phyx-> dcoutts: yes, i'm using the release version
12:22:13 <skorpan> yeah, i understand :)
12:22:17 <skorpan> i appreciate your input
12:22:30 <dcoutts> Phyx-: sorry, I meant the prefix override env var
12:23:04 <Absolute01> How do I properly express "x == x = True" ? Error:Conflicting definitions for `x'
12:23:34 <Phyx-> dcoutts: nope. i'm just running the bootstrap script with no args. i'm tried running just runghc and compiling, but i get a weird error about lexical character '\DEL'
12:24:11 <tromp_> use deriving Eq
12:24:34 <monochrom> @type compare
12:24:35 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:24:38 <saml> hey Absolute01
12:24:40 <monochrom> @src Ordering
12:24:41 <lambdabot> data Ordering = LT | EQ | GT
12:24:44 <Absolute01> hey
12:24:55 <saml> f x | x == True
12:25:05 <saml> > let f x | x == True = False in f True
12:25:06 <lambdabot>   False
12:25:21 <Absolute01> saml I am defining an instance of Eq for my type.
12:25:29 <monochrom> skorpan: I think "case compare oldInd curInd of GT -> ... LT -> ... EQ -> ..." is just fine.
12:25:40 <tromp_> what does your type look like?
12:25:44 <Absolute01> saml: http://pastie.org/703153
12:26:09 <skorpan> monochrom: okay
12:26:13 <saml> eh?
12:26:15 <Absolute01> the first line seems to work fine
12:26:19 <Absolute01> but the second fails
12:26:19 <skorpan> lol
12:26:21 <saml> Absolute01, you are creating infinite recursion there
12:26:29 <saml> x is of type Tree a
12:26:30 <tromp_> what is def. of Tree?
12:26:41 <skorpan> that's hilarious
12:26:47 <Absolute01> i tried doing `==` x x, but that failed
12:27:01 <saml> but how would you know what == to use for Tree a ?
12:27:08 <saml> you are defining the damn thing to use
12:27:10 <Jedai> skorpan: I agree with monochrom to be honest :) Though if you find it really ugly you may just wish to create a fold over Ordering
12:27:18 <saml> in terms of the thing being defined
12:27:21 <IceDane> As an exercise, I'm supposed to replicate the standard takeWhile function using foldr.. I'm completely at loss. Any hints? Heh
12:27:30 <skorpan> Jedai: a fold?  as in fold[rlM]
12:27:32 <skorpan> ?
12:27:37 <bos> preflex: seen dons
12:27:38 <preflex>  dons was last seen on #ghc 20 hours, 24 minutes and 22 seconds ago, saying: dcoutts: ok.
12:27:43 <saml> it's like   public Boolean equals(final Object o) { this.equals(o); }
12:28:16 <Absolute01> http://pastie.org/703158
12:28:19 <Vulpyne> icedane: Can you use other stuff, like catMaybes?
12:28:29 <Jedai> skorpan: More generally, a fold is a function that replace the constructors of a type, like fromMaybe or either
12:28:30 <IceDane> Vulpyne: it isn't specified, so I doubt it
12:28:37 <Jedai> :t maybe
12:28:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:28:40 <monochrom> it's like  you'know'what'I'mean = you'know'what'I'mean
12:28:42 <Jedai> :t either
12:28:43 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:28:45 <skorpan> ah, i see what you mean
12:29:16 <tromp_> you'll have to enumerate the cases for the other constructors
12:29:34 <saml> hola Absolute01 data Tree a = .... deriving(Eq, ...)
12:29:40 <tromp_> like Void==(Node _ _ _ _ _) = False
12:29:46 <saml> wait.. shouldn't deriving Ord automatically derive Eq?
12:30:03 <Absolute01> saml: That won't work
12:30:15 <Absolute01> i only want to equate the first parameter to node
12:30:25 <tromp_> then why are you deriving Ord?
12:30:30 <saml> Absolute01, oh i see
12:30:33 <Heffalump> saml: no
12:30:39 <Heffalump> you might want to manually implement Eq and derive Ord
12:30:39 <Jedai> skorpan: basically foldr is the special case for list (it replace [] by the "initial value" and (:) by your passed function)
12:30:43 <monochrom> Write out "Void == Void = True" and "Goal == Goal = True". Do not think there is a lazy way.  "x==x" requires the next advance in compiler implementation.
12:31:44 <Adamant> I probably need slapping upside da haid for not noting this earlier, but what's the current best way to run a stable released Haskell version on Snow Leopard right now?
12:31:53 <monochrom> "x==x = True" is the same as "f x x = 0". Haskell does not support it.
12:32:09 <Phyx-> YAY, finally have cabal installed
12:32:15 <saml> x == y | x.constructor.instanceof(y.constructor) = True
12:32:22 <Absolute01> whats wrong with f x x?
12:32:25 <saml> maybe template haskell hackery can simplify
12:32:29 <Absolute01> isn't that pattern matching?
12:32:32 <Absolute01> where x is equal?
12:32:34 <chrisdone> monochrom: people call it unification despite it just being a different kind of pattern matching
12:32:35 <FunctorSalad> monochrom: why would nonlinear patterns require an "advance"?
12:32:38 <monochrom> Nothing wrong. Haskell does not support it.
12:32:39 <Jedai> Absolute01: No because there is two x
12:32:40 <dcoutts> Phyx-: so what was the problem?
12:33:12 <chrisdone> I always thought nonlinear could work perfectly well on constructors
12:33:17 <dcoutts> Phyx-: oh, lexical character '\DEL', that's pretty weird, got any more details on that?
12:33:19 <Absolute01> :t x
12:33:20 <lambdabot> Expr
12:33:23 <Phyx-> dcoutts: no clue, ultimately since it was compiling the binary, i just copied it over manually
12:33:26 <saml> wait a minute. i saw somethig simliar
12:33:29 <Absolute01> does that only work with constants?
12:33:30 <Absolute01> hmm...
12:33:40 <Phyx-> dcoutts: just doing runghc Setup configure gives that
12:33:41 <Jedai> IceDane: Do you still need hints ?
12:33:51 <Absolute01> (x:xs) works..
12:33:54 <saml> like  f (n - 1) = n
12:34:04 <saml> > let f (n - 1) = n in f 2
12:34:05 <lambdabot>   <no location info>: Parse error in pattern
12:34:14 <dcoutts> Phyx-: sounds like a borked runghc or something. The bootstrap script compiles the Setup.hs.
12:34:21 <ac> fastcgi listens to a socket to get requests from the webserver, right? How do I tell the fastcgi module in hackage which socket to listen to?
12:34:24 <Absolute01> Maybe I am being confused by prolog. :)
12:34:39 <Jedai> Absolute01: in (x:xs) there is no unification, x and xs are distinct names
12:34:45 <chrisdone> > let f (n + 1) = n in f 2
12:34:47 <lambdabot>   1
12:34:56 <saml> wtf why not -?
12:35:10 <saml> oh i see there are inifinite such n
12:35:10 <chrisdone> saml: they're called n+k patterns
12:35:22 <Phyx-> dcoutts: but the odd thing is, the bootstrap script is able to compile the file somehow, i presume it's also using runghc. the exact error is "Setup:1:0 lexical error at character '\DEL'"
12:35:32 <saml> x + 1 = 2 ;  x = 1
12:35:38 <ac> there's absolutely nothing in the library documentation about a socket path
12:35:38 <saml> x - 1 = 2; x = 3
12:35:41 <saml> there's unique x
12:35:57 <dcoutts> Phyx-: oh, you're trying to run the ./Setup binary using runghc, rather than running the Setup.hs source file.
12:36:02 <saml> one expression. one unknown. we can do better
12:36:02 <Absolute01> so there is no way to wildcard 2 params that are equal?
12:36:12 <chrisdone> Absolute01: nope
12:36:13 <dcoutts> Phyx-: so that's not the source of the problem.
12:36:26 <saml> f (some polynomial in x) = x
12:36:28 <Jedai> Absolute01: No, you have to use a guard or an if
12:36:29 <Phyx-> dcoutts: oh, that explains it. heh
12:36:31 <kmc> Absolute01, the way is "x y | x == y"
12:36:36 <saml> can pattern matching solve linear systemm?
12:36:42 <kmc> which uses Eq equality, not structural equality
12:36:44 <chrisdone> Absolute01: but if you know the only other cases you can just f _ _ = True
12:36:50 <saml> we should do that so that we'll be enterprise ready
12:36:52 <dcoutts> Phyx-: so still no idea why the final install step failed
12:37:08 <saml> can you write template haskell so that pattern matching solves linear equations?
12:37:09 <Jedai> saml: You can use view patterns to do that already
12:37:17 <bos> mmorrow: ping
12:37:27 <IceDane> Any hints on replicating takeWhile using foldr? I'm really at loss
12:37:40 <kmc> IceDane, identify your accumulator
12:37:49 <Jedai> IceDane: try writing id on lists with foldr first
12:37:51 <Phyx-> dcoutts: well atleast it's working now :)
12:37:57 <IceDane> Jedai: alright, thanks
12:38:19 <Vulpyne> IceDane: I'd use the state for a tuple of the accumulated list and whether to continue building the list.
12:38:34 <IceDane> ah..
12:38:39 <Jedai> IceDane: Keeping in mind that "foldr f i" takes a list and replace the [] by i and the (:) by f
12:39:17 <saml> @google view patterns haskell
12:39:20 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
12:39:20 <lambdabot> Title: ViewPatterns - GHC - Trac
12:39:26 <IceDane> Hmm..
12:40:18 <Saizan> takeWhile using foldr is not straightforward, there's even a The Monad.Reader article on it, iirc
12:40:22 <Vulpyne> IceDane: Actually, there's a much simpler way than what I said.
12:40:39 <mmorrow> bos: pong
12:40:45 <IceDane> I'll figure it out :P
12:40:59 <IceDane> I just have to get my head around why id matters.. Right now, it seems pretty useless
12:41:02 <IceDane> lol
12:41:08 <bos> mmorrow: it seems that vacuum-cairo has inherited a bug from vacuum, namely that the current version of dot can't parse the stuff it's being fed.
12:41:10 <Jedai> Saizan: I think you're mistaken, maybe you confuse takeWhile with something else ?
12:41:28 <bos> mmorrow: graphviz-2.20.3
12:42:05 <Jedai> IceDane: Really, it's only a simple step from the implementation of id on lists with foldr to the implementation of takeWhile
12:42:05 <mmorrow> bos: ah, hmm. yeah it's using an extended syntax that graphviz seems to be ok with, but i think it's non-standard.
12:42:20 <mmorrow> bos: i'll have it generate vanilla graphviz syntax.
12:42:23 <Jedai> Saizan: takeWhile with foldr is very easy
12:42:30 <Saizan> Jedai: checking
12:42:59 <Saizan> Jedai: ok, the article is on dropWhile :)
12:43:00 <mmorrow> bos: i didn't know vacuum-cairo was using the new graphviz pkg, cool.
12:43:09 <bos> mmorrow: many thanks, sir. even the simplest test trips it up, e.g. "view [1..2]"
12:43:13 * FunctorSalad is confused. thought ivanm was the graphviz guy
12:43:40 <Jedai> Saizan: Right, that's a bit more complicated
12:43:47 <mmorrow> bos: de nada
12:43:50 <Jedai> Saizan: not awfully so though
12:43:51 <bos> mmorrow: i don't know that for a fact. all i know is that dot is being run by something inside the vacuum sausage factory, and it barfs.
12:43:52 <EnglishGent> @hoogle (Monad m) => (a1 -> r) -> a1 -> m r
12:43:53 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
12:43:53 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:43:53 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:44:18 <mmorrow> bos: it must be using the graphviz pkg to parse the dot syntax?
12:44:23 <mmorrow> bos: how does it barf?
12:44:34 <EnglishGent> couple of questions -- 1)  is there a way of installing a 'personal' copy of hoogle - so that I can have it search my code as well as the standard libraries?
12:44:47 <bos> mmorrow: Error: <stdin>:6: syntax error near line 6
12:44:47 <bos> context:     "(:)|0" -> >>>  {"1|1", <<< "(:)|2"}
12:44:52 <mmorrow> bos: in old versions of vacuum, i messed up and
12:45:00 <mmorrow> bos: ah, ok. that's my fault.
12:45:20 <bos> mmorrow: oh weird, previously it completely failed. now it actually displays a graph in a window, but still prints the error message.
12:45:23 <EnglishGent> 2) I dont get the result just returned by hoogle there - how can Control.Monad liftM match? it requires the 2nd parameter to be inside a monad - whereas in my query it's *not* inside a monad
12:45:24 <mmorrow> bos: i was generating invalid dot syntax in the early vacuum version, but that should've been fixed a while ago.
12:45:37 <mmorrow> bos: yeah, graphviz was complaining, but still doing
12:45:39 <Absolute01> this is kind of cool let f = iterate (\(n+1) -> n) 100
12:45:44 <mmorrow> bos: what version of vacuum do you have?
12:45:49 <bos> oh i see, it renders part of the output, sometimes all of it, sometimes not, then barfs.
12:45:50 <Absolute01> not sure what use it might have. :)
12:45:55 <Saizan> EnglishGent: yes, cabal install hoogle, and then you can use cabal haddock --hoogle to generate a .txt file you need to convert to .hoo and add to the main index it searches
12:46:09 <Absolute01> >let f = iterate (\(n+1) -> n) 100
12:46:12 <bos> mmorrow: vacuum-1.0.0
12:46:17 <Absolute01> > let f = iterate (\(n+1) -> n) 100
12:46:18 <lambdabot>   not an expression: `let f = iterate (\(n+1) -> n) 100'
12:46:21 <EnglishGent> ty Saizan :)
12:46:31 <mmorrow> bos: :o crap
12:46:33 <Absolute01> > f = iterate (\(n+1) -> n) 100
12:46:34 <lambdabot>   <no location info>: parse error on input `='
12:46:43 * mmorrow checks if he re-introduced that bug somehow
12:46:56 <IceDane> Absolute01: try without the f =
12:47:04 <Saizan> EnglishGent: 2) hoogle results are not rarely weird like that, you could go read the source and then come back to tell us :)
12:47:18 <Saizan> EnglishGent: or ask ndm
12:47:48 <EnglishGent> ndm?
12:48:00 <Saizan> the author
12:48:05 <EnglishGent> ah! :)
12:48:16 <Jedai> Absolute01: I prefer "iterate (subtract 1) 100"
12:48:32 <mmorrow> bos: ahh, ok. so it looks like vacuum-cairo duplicated the vacuum dot rendering code (only like 3 function, super short), and it still has the version with the bug in it
12:48:55 <mmorrow> bos: in particular, in Cairo.hs, s/comma/semi/ in line 136
12:48:58 <Absolute01> Jedai: The force is strong within you. :-P
12:49:11 <bos> mmorrow: bad dons! no cookie!
12:49:11 <Saizan> EnglishGent: cabal haddock --hoogle works only if your code is cabalized, of course, you can use haddock directly if not
12:49:16 <mmorrow> bos: heh
12:49:54 <bos> mmorrow: thanks!
12:50:05 <Absolute01> Jedai: why not just "iterate (-1) 100" ?
12:50:12 <EnglishGent> speaking of haskell tools (hoogle, djinn, etc) - how about a tool where you can give it a 'plain' version of a function (no monads) - then say 'and here's where I want the m's to go' - and it either figures out how to convert it, or says 'impossible' or 'no unique solution' appropriately - is that even possible? (might we have to add 'I give up? due to halting problem, etc)
12:50:15 <mmorrow> bos: np
12:50:16 <Jedai> IceDane: Are you getting it or do you want other hints ?
12:50:31 <Jedai> Absolute01: because is don't work unfortunately
12:50:36 <Absolute01> :)
12:50:53 <IceDane> Jedai: Not yet, but I
12:50:59 <IceDane> I'd rather find out on my own :P
12:51:04 <Jedai> Absolute01: It's a corner case with (-) where the prefix operator and the infix operator interfere
12:51:06 <EnglishGent> none of my code is yet in a state where I would feel comfortable cabalizing it Saizan - I'm still very much the newbie.. though I hope one day that will change :)
12:51:55 <Absolute01> for some reason i get alternating 100 and -99
12:51:57 * EnglishGent has some code at least *approaching* a point where he'd feel comfortable about releasing it :)
12:51:58 <Absolute01> weird..
12:52:06 <bos> mmorrow: exciting. it runs without a hitch, but then i get an X error. that's clearly not your problem :-)
12:52:13 <Absolute01> > iterate (-1) 100
12:52:14 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
12:52:14 <lambdabot>    arising from a use of syntactic n...
12:52:32 <mmorrow> bos: someone hates you!
12:52:48 <bos> mmorrow: clearly my class tomorrow does not want to get taught!
12:53:01 <Absolute01> is there a way to tell iterate to stop?
12:53:09 <IceDane> ctrl + c
12:53:15 <Jedai> Absolute01: As you see, it try to convert (-1) into a function from the integer -1
12:53:16 <m0nkfish> hehe
12:53:27 <Jedai> Absolute01: generally you just use take
12:53:33 <Jedai> Absolute01: or takeWhile
12:53:50 <mmorrow> bos: if you're on linux, i've got a version of vacuum-foo with a (view :: a -> IO ()) function that uses OpenGL (the code is not super organized, but it works) if you're interested
12:53:53 <Jedai> > take 4 . iterate (subtract 2) $ 100
12:53:54 <lambdabot>   [100,98,96,94]
12:53:57 <Absolute01> i guess the lambda (\x-> if x <=0 then x else ...) would work
12:54:07 <mmorrow> bos: http://moonpatio.com/repos/vacuum-gl/
12:54:24 <EnglishGent> @hoogle (Monad m) => (a -> Bool) -> m [a] -> m [a]
12:54:24 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
12:54:25 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
12:54:25 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
12:54:33 <bos> mmorrow: thanks, will give it a try
12:54:38 <mmorrow> bos: it talks to graphviz directly via the C-api (if you want to call what it exposes an "api")
12:55:36 <mmorrow> bos: oh, one thing of note is that you'll have to make libpthread.so a symlink to the real file too, since it's a linker script and ghci barfs :(
12:55:43 <EnglishGent> again I dont get that - I cant do 'dropWhile even (Identity [1..])' - it's not even type-safe :|
12:56:10 <mmorrow> bos: (it needed to use pthread_create to get two functions using FILE* to talk to each other in the same proc)
12:56:31 <Saizan> EnglishGent: a .cabal file can be very simple, just a list of modules, and you aren't forced to put it on hackage :)
12:56:52 <bos> mmorrow: eeeeeee!
12:56:57 <Jedai> EnglishGent: it tries to do it's best but there's no function with the exact type you requested so it gives you something approaching
12:57:12 <mtnviewmark> bos is doin' the yak shaving...
12:57:14 <mmorrow> bos: oh noes, did it asplode yoar laptop!
12:57:38 <Jedai> EnglishGent: in fact in this case it gives you interesting results since you just have to use a liftM on them to get the type you seek
12:57:50 <mmorrow> bos: like i said, it's not very purdy.. ;)
12:58:16 <Jedai> > liftM (filter even) (Identity [1..20])
12:58:17 <lambdabot>   No instance for (GHC.Show.Show
12:58:17 <lambdabot>                     (Control.Monad.Identity....
12:58:27 <Jedai> > runIdentity $ liftM (filter even) (Identity [1..20])
12:58:28 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
12:58:42 <EnglishGent> thanks Saizan :)
12:59:06 <Veinor> Can someone explain to me the point of functions that take unit as the argument?
12:59:32 <Jedai> Veinor: None ? Except to fool the optimizer in some fashion eventually
12:59:36 <EnglishGent> Jedai - I'm not sure that works :t liftM dropWhile is (Monad m) ->m (a -> Bool) -> m ([a] -> [a])
12:59:51 <Veinor> Haha
13:00:05 <EnglishGent> but I want foo dropWhile :: (Monad m) => (a -> Bool) -> m [a] -> m [a]
13:00:05 <Jedai> EnglishGent: look at my example, I meant the liftM to go around (filter predicate)
13:00:06 <Veinor> I ask because apparently in Data.MemoCombinators there's a memoizer for said functions.
13:00:12 <EnglishGent> ah!
13:00:14 <EnglishGent> thanks :)
13:00:29 <monochrom> Then it is there because it is so easy to implement.
13:00:31 <IceDane> Jedai: you're welcome to give me more hints - i cannot see how on earth id is actually useful for anything, heh
13:00:45 <Jedai> IceDane: Did you manage to write it ?
13:01:15 <IceDane> Jedai: No. I don't get what "id over a list with foldr" means either
13:01:29 <mmorrow> bos: if it ends up working for you, but some of the arbitrary hardcoded params aren't optimal for what you're doing, just let me know
13:01:32 <monochrom> Like, if someone writes a function ()->Blah to fool the computer, why would he/she then give it to Data.MemoCombinators to unfool...
13:01:37 <Jedai> IceDane: foldr (:) []
13:01:49 <bos> mmorrow: will do, thanks
13:01:53 <IceDane> Jedai: I did that, but I don't get how that relates to id?
13:01:55 <Jedai> IceDane: or "foldr (\x xs -> x : xs) []
13:02:09 <Jedai> IceDane: Well it's id, restricted to lists
13:02:10 <Vulpyne> IceDane: He called it id (identity) because it just passes the list through unchanged.
13:02:10 <Veinor> monochrom: I dunno, maybe it's for completeness so you can say you can memoize every function (with a suitable wrap)
13:02:18 <Vulpyne> IceDane: f x == x is called the identity funciton.
13:02:19 <monochrom> Ah, hehe
13:02:27 <IceDane> oh, you wanted mo replicate the function id with foldr?
13:02:38 <IceDane> I did that, then, alright
13:02:38 <Jedai> IceDane: oops sorry, I though id was clear enough...
13:02:43 <IceDane> it's np
13:03:04 <Jedai> IceDane: ok, once you have that, a small modification on the passed function will give you takeWhile
13:03:10 <Veinor> are there any other types that only have one value?
13:03:19 <Vulpyne> IceDane: foldr (:) [] "xyz" == 'x':'y':'z':[] -- It basically just puts the (:) between each item.
13:03:25 <skorpan> are we still on the foldr?
13:03:28 <IceDane> yeah
13:03:30 <IceDane> hmm
13:03:41 <Jedai> IceDane: instead of unconditionally consing in the passed function, you'll have to do it conditionally
13:03:51 <IceDane> I thought so
13:03:58 <IceDane> let me try again - thanks ;)
13:04:34 <Vulpyne> > foldr (\x y -> if x == 'l' then y else x:y) [] "hello"
13:04:35 <lambdabot>   "heo"
13:04:36 <Jedai> IceDane: so it looks like "myDropWhile pred = foldr (\x xs -> if pred x then ... else ...) []"
13:05:07 <Jedai> Vulpyne: not quite there, you have filter there
13:05:11 <IceDane> yeah
13:05:12 <IceDane> thought so
13:05:28 <Vulpyne> Jedai: That was just an example for him, I already wrote it. :)
13:05:36 <IceDane> ah, woot
13:05:47 <Jedai> Vulpyne: Ok :)
13:05:48 <IceDane> >foldr (\x y -> if x < 10 then x : y else x : [] ) [] [1..20]
13:05:49 <IceDane> [1,2,3,4,5,6,7,8,9,10]
13:06:11 <IceDane> oh, that's not quite..
13:06:16 <IceDane> x < 10 should include 10
13:06:23 <Jedai> IceDane: Right, almost that
13:06:31 <IceDane> x : [] = [], instead
13:06:44 <IceDane> thanks =)
13:06:46 <Vulpyne> Newp.
13:06:47 <IceDane> I am much wiser
13:06:53 <Jedai> IceDane: Exactly, and now you have to implement dropWhile !! ;)
13:07:21 <IceDane> Haha, alright
13:07:37 <Jedai> IceDane: It's harder, especially if you try to make it properly lazy (then you have to use lazy pattern to do it cleanly)
13:08:14 <IceDane> I think I'll be satisfied with it just working, heh
13:10:58 <m0nkfish> which of these definitions do you guys think is nicer:
13:10:58 <m0nkfish> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4967#a4967
13:11:45 <Veinor> it seems like you can write it simpler using map and tail
13:12:13 <m0nkfish> the first definition uses map and tail, is there an even simpler way?
13:12:50 <Veinor> what do you want the output of trol ["a", "bc", "def"] to be?
13:13:22 <m0nkfish> ["f","ce","abd"]
13:13:35 <m0nkfish> so if you visualise the lists vertically, the triangle has been 'rotated'
13:13:51 <Veinor> ahhh, okay
13:14:01 <Veinor> I was tihnking something different.
13:14:17 <Jedai> > reverse . transpose $ ["a", "bc", "def"]
13:14:18 <lambdabot>   ["f","ce","abd"]
13:14:27 <IceDane> lol
13:14:28 <m0nkfish> :o
13:14:30 <Veinor> :o
13:14:34 <holzplatten> o_O
13:14:41 <m0nkfish> i knew there was a simple way
13:14:49 <m0nkfish> now i need to understand it
13:14:56 <m0nkfish> @src transpose
13:14:57 <lambdabot> transpose []             = []
13:14:57 <lambdabot> transpose ([]   : xss)   = transpose xss
13:14:57 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:15:03 <m0nkfish> say whaaat
13:15:09 <Veinor> > transpose $ ["a", "bc", "def"]
13:15:10 <lambdabot>   ["abd","ce","f"]
13:15:10 <Jedai> Maybe I shouldn't have told that ? Was there a pedagogic purpose behind it ?
13:15:12 <sproingie> pretty neat that transpose works on ragged lists
13:15:34 <Veinor> if you imagine the triangle, transpose flips it about its diagonal
13:15:46 <m0nkfish> yeah
13:16:01 <IceDane> transpose = [[x,y], [x1, y1]] = [ [x, x1], [y, y1]], right?
13:16:16 <Veinor> Yep
13:16:20 <sproingie> fun with listcomps
13:16:26 <m0nkfish> i implemented my own transpose, but if there are any null lists it just defaults to null :x
13:16:28 <IceDane> god this language blown my minds
13:16:29 <burp> > transpose [[u,v],[x,y]]
13:16:30 <lambdabot>   [[u,x],[v,y]]
13:16:39 <IceDane> I would never have come up with the solution jedai came up with, not in a million years
13:16:42 <Jedai> IceDane: Right, basically it's the transposition on matrix, symetry around the diagonal
13:16:46 <IceDane> damn you, years of imperative C
13:17:35 <m0nkfish> i think we are supposed to assume that the transpose function is not available lol
13:17:55 <trofi> @hoogle transpose
13:17:56 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
13:17:56 <IceDane> m0nkfish: so this is for school? Just give him both solutions
13:17:56 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
13:17:56 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
13:18:04 <sproingie> myWhollyOriginalFunction ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:18:08 <sproingie> there
13:18:11 <sproingie> oops
13:18:16 <m0nkfish> :P
13:18:21 <sproingie> myWhollyOriginalFunction ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : myWhollyOriginalFunction (xs : [ t | (h:t) <- xss])
13:18:25 <sproingie> there
13:18:27 <m0nkfish> no base case?!
13:18:37 <sproingie> left as an exercise
13:18:40 <m0nkfish> hehe
13:19:01 <IceDane> What exactly does the pattern ((x:xs) : xss) do with say, "abcde" ?
13:19:09 <sproingie> try it
13:19:19 <skorpan> > let ((x:xs):xss) = "abcde" in ()
13:19:21 <lambdabot>   Couldn't match expected type `[t]'
13:19:21 <lambdabot>         against inferred type `GHC.Types...
13:19:22 <sproingie> won't work on a single string
13:19:22 <m0nkfish> it can't match "abcde"
13:19:30 <m0nkfish> it works on a list of lists
13:19:42 <IceDane> ah
13:19:49 <Vulpyne> The right side of : is a list.
13:19:57 <m0nkfish> unless it's not
13:20:02 <m0nkfish> > 1:2:[]
13:20:04 <lambdabot>   [1,2]
13:20:04 <trofi> :t (:)
13:20:05 <lambdabot> forall a. a -> [a] -> [a]
13:20:19 <Vulpyne> > 1:(2:([]))
13:20:20 <lambdabot>   [1,2]
13:20:22 <m0nkfish> ;)
13:20:26 <m0nkfish> alright alright
13:20:33 <Vulpyne> :)
13:20:36 <sproingie> it's a little hard to immediately parse (x:xs):xss as a list of lists unless you remember that : is right-associative
13:20:42 <skorpan> if (:) is right-associative, then it's a list though?
13:20:51 <skorpan> uhm, is that even the right word for it..
13:20:52 <sproingie> i saw it right away but i also knew that transpose works that way to begin with
13:21:25 <sproingie> i think RWH has you reinvent transpose, you could use that implementation
13:21:32 <mathmadx> Dear all: I know how "map" works on lists. Is there a way to apply map ONLY if the position of the element satisfies a certain condition?
13:21:40 <IceDane> Jedai: HAH!
13:21:47 <IceDane> >foldr (\x y -> if x < 10 then y  else x : y) [] [1..20]
13:21:47 <IceDane> [10,11,12,13,14,15,16,17,18,19,20]
13:21:56 <IceDane> Now to fully understand why this works
13:22:00 <IceDane> heh..
13:22:01 <Jedai> IceDane: it don't
13:22:02 <sproingie> mathmadx: put the predicate into your map function
13:22:16 <Jedai> IceDane: just to say it before you try to see why it does...
13:22:19 <IceDane> Jedai: Eh?
13:22:34 <mathmadx> e.g.: Only apply map if the position mod 2==0
13:22:39 <Jedai> > foldr (\x y -> if x < 10 then y  else x : y) [] ([1..15] ++ [1..10])
13:22:40 <skorpan> > map (\x -> if x > 5 then x + 1 else x) [1..10]
13:22:40 <lambdabot>   [10,11,12,13,14,15,10]
13:22:41 <lambdabot>   [1,2,3,4,5,7,8,9,10,11]
13:22:49 <skorpan> hm, what
13:22:54 <sproingie> if you don't want to include elements that don't match the predicate, use map . filter
13:23:10 <IceDane> Jedai: I see
13:23:14 <sproingie> er map foo $ filter pred
13:23:18 <mathmadx> its not relevant WHAT the element is, ONLY look at its position
13:24:24 <sproingie> @pl map a $ filter b xs
13:24:25 <lambdabot> map a (filter b xs)
13:24:26 <skorpan> interesting problem
13:24:29 <sproingie> har
13:24:42 <EvanCarroll> does haskell use the term "parallel assignment"
13:25:02 <Jedai> IceDane: That's why it's harder, and to be honest, in a normal implementation you won't get directly the result after the foldr, you need to extract it (with a snd for instance if a pair is your choice of intermediate structure)
13:25:02 <EvanCarroll> in lyah I seem to see (a,b,c)=(1,2,3) refer to "pattern matching"
13:25:11 <sproingie> EvanCarroll: that's what it is
13:25:11 <EvanCarroll> which is weird most would just call that parallel assignment
13:25:15 <ac> has anybody used the fastcgi library with something other than Apache?
13:25:17 <sproingie> it's not the same thing
13:25:19 <skorpan> you don't assign anything
13:25:36 <Jedai> EvanCarroll: There's no assignment in Haskell, there's just binding
13:25:41 <EvanCarroll> =(
13:25:46 <mathmadx> To give an example: function [1,2,3,4,5] = [3,2,6,4,10] (multiply each second element)
13:25:51 <mathmadx> how to define function?
13:25:54 <EvanCarroll> that seems to be a nebulous distinction
13:25:56 <IceDane> Jedai: I see, I'll let it lie then until I finish RWH
13:26:02 <mathmadx> To give an example: function [1,2,3,4,5] = [2,2,6,4,10] (multiply each second element)
13:26:04 <skorpan> EvanCarroll: (x:xs) = [1..5], another pattern matching example, letting x be 1 and xs [2..5]
13:26:13 <fritschy> hmm... i get lots of code like "show $ head $ sortBy srtf $ foldl (++) [] lists" -- is this normal haskell style coding or is it just me not being a functional programmer?!
13:26:32 <Vulpyne> fritschy: You could just use parenthesis instead.
13:26:38 <EvanCarroll> right that one I've never seen outside of haskell, so it could be called a frotle and I'd be able to mentally assign it easier
13:26:39 <sproingie> EvanCarroll: (a,b,c,d) = (1,2,3,4) is just a very simple pattern match.  what it isn't is special syntax, it's just a pattern-match on a 4-tuple.
13:26:40 <Vulpyne> fritschy: But then you'd just have to type )))))))) at the end.
13:26:40 <Jedai> EvanCarroll: and (a,b,c) = ... may look like parallel assignment but it's just a particular case of the more general pattern matching feature, for instance you can write "Just [a,b] = ..." with the same feature
13:26:47 <Vulpyne> I personally love $.
13:26:56 <Jedai> EvanCarroll: and it don't look much like parallel assignment anymore
13:27:10 <blackdog> fritschy: foldl (++) [] lists is a long way to say concat :)
13:27:13 <fritschy> Vulpyne: yep... but it would be the same thing - but this code looks liek "normal" haskell, does it?
13:27:13 <sproingie> > let (,,,,) a b c d = (1,2,3,4) in [a,b,c,d]
13:27:15 <lambdabot>   Constructor `(,,,,)' should have 5 arguments, but has been given 4
13:27:19 <sproingie> doh
13:27:21 <sproingie> > let (,,,) a b c d = (1,2,3,4) in [a,b,c,d]
13:27:22 <lambdabot>   [1,2,3,4]
13:27:23 <fritschy> blackdog: ah - nice :D
13:27:38 <Vulpyne> fritschy: Fairly normal.. Though a lot of people would replace all but the last '$' with '.'.
13:27:49 <EvanCarroll> my ($a,$b,$c) = ( $_[0], $_[1], $_[2] ); or my ( $a, $b, $c ) = @_; or my ($a,$b,@c) = @_;
13:27:53 <EvanCarroll> looks very close
13:27:54 <mathmadx> anyone knows how to approach my problem? ( only apply map to elements at certain positions)
13:27:58 <sproingie> > let (Just a, Nothing, (b,c)) = (Just 1, Nothing, (3,"foo")) in (a,b,c,d)
13:28:00 <lambdabot>   (1,3,"foo",d)
13:28:11 <sproingie> EvanCarroll: as you can see, patterns can be arbitrarily hairy
13:28:20 <Jedai> fritschy: it's pretty normal Haskell style, it's pretty convenient to write and read once you're accustomed to think in term of pipeline of functions
13:28:23 <Vulpyne> mathmadx: zip it with an index or use a fold to pass an accumulator so you can keep track of the index.
13:28:31 <fritschy> Vulpyne: i need some "ugly" parentheses around function compositions... i like $ much more... though dots are nice in places where i "return" a function...
13:28:35 <EvanCarroll> I'll just get over it, if it (a,b,c)=(1,2,3) wants to be pattern matching in haskell, it can be!
13:28:52 <Jedai> EvanCarroll: Right it "looks" close but underneath it's a pretty different beast
13:28:53 <sproingie> it is pattern matching, just a very simple pattern
13:28:59 <fritschy> Jedai: pretty much what i was thinking... only it feels (still) strange :)
13:29:00 <trofi> @pl \args -> do $ the $ stuff args
13:29:00 <lambdabot> do . the . stuff
13:29:13 <fritschy> *g*
13:29:13 <fritschy> ok
13:29:28 <fritschy> i have no choice, do i?
13:29:30 <EvanCarroll> Jedai: perl is assigning those variables to the references point to in $_
13:29:36 <EvanCarroll> seems the sameish
13:29:55 <Jedai> mathmadx: generally when you want a "mapWithIndex" you use "zipWith (\idx x -> ...) [0..]"
13:29:59 <EvanCarroll> a binding i imagine is the same thing except the "variable" is immutable
13:30:24 <EvanCarroll> zipWidth is documented in LYAH!
13:30:31 <Jedai> EvanCarroll: I know Perl (very well) but Perl can't do "let (a,b, x:xs) = (2,3, [1..])"
13:30:39 <EvanCarroll> true that.
13:30:50 <fritschy> that's actually a lot nicer: "(show . head . sortBy srtf . concat) lists"
13:31:22 <sproingie> pattern matching has a similar idea of destructuring like you might do with perl lists, but you can destructure a whole lot more
13:31:39 <Jedai> fritschy: Right, personally I like "show . head . sortBy srtf . concat $ lists" the best but that's really a question of taste
13:31:40 <sproingie> anything you have a data constructor for you can pattern-match
13:31:40 <fritschy> Vulpyne: why "all but the last '$'"
13:31:42 <blackdog> Jedai: list flattening is not helpful there, i guess
13:32:03 <nlogax> fritschy: you can just leave it off
13:32:15 <nlogax> and be all pointless and cool!
13:32:28 <Jedai> blackdog: In fact it is.. but I could complicate the example to make it not be
13:32:32 <sproingie> now with view patterns, you can do all kinds of happy fun evil in pattern matches
13:33:00 <blackdog> Jedai: the heads of two lists or something, yeah
13:33:27 <Jedai> fritschy: this style has advantage when you go about doing copy and paste, rearranging your pipeline, giving an explicit name to a portion and so on
13:34:10 <Jedai> fritschy: whereas with plenty of ($) it don't work as well
13:34:56 <Jedai> fritschy: though your syntax works well there too, it's just that plenty of Haskeller don't like their parenthesis very much (S-expression trauma I guess)
13:35:06 <fritschy> :D
13:35:16 <fritschy> Jedai: *lol* that might be it :)
13:35:50 <sproingie> it's easier to cut-and-paste refactor code using $ because you don't have to adjust parenthesis
13:35:56 <fritschy> Jedai: got it; fa . fb . fc $ fd args
13:35:58 <fritschy> nice
13:36:28 <fritschy> the syntax is clean but needs getting used to...
13:36:51 <sproingie> @pl a $ b $ c $ d
13:36:52 <lambdabot> a (b (c d))
13:36:57 <nlogax> i was afraid of all that weird syntax until i realized they were just good ol functions
13:37:05 <sproingie> man, pl loves its parens
13:37:08 <nlogax> then i felt all warm and fuzzy inside
13:37:31 <Jedai> fritschy: Right, though that's not syntax, (.) and ($) are just normal operators defined in the Prelude
13:37:42 <fritschy> nlogax: it got warm and fuzzy right now... i mean, a lot warmer than 5mins ago... awesome
13:37:48 <nlogax> :D
13:37:58 <nlogax> @src (.)
13:37:59 <lambdabot> (f . g) x = f (g x)
13:38:00 <sproingie> $ is really fun in sections
13:38:00 <fritschy> Jedai: ack, i am constantly reading Hugs library .hs to get the functions i need ;)
13:38:42 <sproingie> @src ($)
13:38:43 <lambdabot> f $ x = f x
13:39:05 <Vulpyne> > map ($1) [(1+),(1-)]
13:39:06 <lambdabot>   [2,0]
13:39:06 <sproingie> the magic comes from $'s low precedence
13:39:27 <Jedai> sproingie: Of course the important part of ($) definition is the infix precedence declaration and @src don't give it to us...
13:39:38 <sproingie> yep
13:40:02 <fritschy> yes... that's beautiful...
13:42:44 <m0nkfish> @pl a $ b c d
13:42:44 <lambdabot> a (b c d)
13:42:59 <m0nkfish> so $ just wraps brackets around the stuff to the right
13:43:19 <zygoloid> can you use @ with view patterns?
13:43:31 <m0nkfish> > map (1) [(1+),(1-)]
13:43:32 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:43:32 <lambdabot>    `GHC.Num.Num t' arising f...
13:43:34 <m0nkfish> :<
13:43:50 <zygoloid> , let f (xs@head -> x) = (x, xs) in f "foo"
13:43:51 <lunabot>  luna: Pattern syntax in expression context: xs@head
13:44:08 <Jedai> zygoloid: needs parens
13:44:09 <zygoloid> , let f (xs@(head -> x)) = (x, xs) in f "foo"
13:44:10 <lunabot>  ('f',"foo")
13:44:16 <zygoloid> awesome
13:44:31 <zygoloid> , let f (xs@(head -> x)@(tail -> xt)) = (x, xs, xt) in f "foo"
13:44:32 <lunabot>  luna: parse error on input `@'
13:44:41 <zygoloid> non-triumphant
13:45:21 <zygoloid> > let f xs@ys@zs = (xs,ys,zs) in f "hello"
13:45:22 <lambdabot>   ("hello","hello","hello")
13:47:21 <zygoloid> hmm. is that a ghc bug?
13:48:05 <Jedai> zygoloid: Probably, you can use &&& in the meantime
13:50:24 <mathmadx> Given a list: how can we elimate all characters 'k', for example?
13:50:32 <zygoloid> filter (/= 'k')
13:50:41 <mathmadx> ah, of course! thanks
13:50:56 <jlouis> mathmadx: filter is the general "kill something not fulfilling a predicate"
13:51:17 <mathmadx> I must admit: Functional programming is not easy (yet) for me
13:51:33 <mathmadx> Especially the fact that for/while doesnt exists makes it hard..
13:51:53 <jlouis> > [x | x <- [1..], x `mod` 2 == 0]
13:51:54 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
13:52:09 <IceDane> mathmadx: yeah, I hear you
13:52:11 <IceDane> I'
13:52:13 <jlouis> list comprehensions take filter expressions too
13:52:14 <zygoloid> mathmadx: a substantial part of it is writing what you want to do rather than how a computer should do it :)
13:52:16 <IceDane> I'm coming from C/C++ myself
13:52:48 <mathmadx> me too ( well: Java is just a simpliefied c++)
13:52:55 <IceDane> heh
13:54:56 <joe___> I am trying to convert between string and "Bytestring". Any thoughts, please?
13:55:12 <ben0x539> pack, unpack
13:55:25 <tommd> joe__: You probably want to use the .Char8 modules too
13:55:35 <tommd> Data.ByteString.Char8.{pack,unpack{
13:55:37 <tommd> Data.ByteString.Char8.{pack,unpack}
13:55:54 <tommd> And don't for get, {-# LANGUAGE OverloadedStrings #-} Is your friend.
13:56:20 <tommd> let someStr = "This is a ByteString" :: Data.ByteString.Char8.ByteString
13:56:33 <Jedai> joe___: Don't do it ? Seriously, try to keep that to a minimum, if you do it too much it'll kill any performance advantage Bytestring may gain you. What do you want to do that you think you need to go back to String to do ?
13:57:03 <joe___> I am using writeControl and readControl of System.USB
13:57:17 <joe___> and the arguments are Bytestring types
13:57:39 <tommd> So why don't you feed it bytestring and not use Strings in your program?  That is what Jedai is asking.
13:58:05 <tommd> Not that this is performance critical if you are making frequent system calls.
13:58:12 <joe___> i do not understand. please excuse my ignorance
13:58:39 <zygoloid> joe___: they're suggesting changing the rest of your program to allow interfacing with System.USB
13:58:40 <tommd> The question is: What are you using Strings for?  Why do you have _any_ strings?  Why can't this all be ByteString?
13:58:54 <joe___> ok, I think pack and unpack can help
13:59:22 <tommd> But as I also said - this is probably a useless line of conversation if the pack/unpack aren't too ugly and don't kill your performance.
13:59:26 <joe___> i am just trying to send a "xxx" as a Bytestring. I do not need to use a string.
13:59:55 <Jibi> Hi
14:00:00 <tommd> joe__: So you can use {-# LANGUAGE OverloadedStrings #-} and any string literal, such as "XXX" will be a bytestring, no need to pack at run time.
14:00:25 <tommd> Jibi: Hello!
14:01:09 <Jibi> I have a compilation error with visual studio 2008
14:01:24 <zygoloid> Jibi: a haskell-related one? :)
14:01:25 <joe___> reading up about "overloadedstrings". thanks.
14:01:44 <Jibi> hum...no ^^'
14:01:53 <Jibi> http://pastebin.com/m5f09d7a3
14:02:23 <Jibi> its about recursivity
14:02:28 <Jibi> in C
14:02:34 <Phyx-> heh
14:02:40 <Phyx-> Jibi: join ##c
14:02:43 <Phyx-> err
14:02:51 <Jibi> join ##c
14:02:55 <Jedai> Jibi: const int NB_ELEM
14:02:56 <zygoloid> Jibi: this is not the right forum for such questions; we talk about haskell in #haskell. but you might want to read about macros, and then look at the name of minvect's third argument :)
14:03:09 <Phyx-> Jibi: with a / in front
14:03:25 <Phyx-> /join ##c
14:03:44 <ben0x539> Is OverloadedStrings 'best practice'? I always figured it was bad to have a lot of implicit packs or whatever
14:03:46 <Jedai> Jibi: but join #C for more, and how did you arrive in #haskell ?
14:03:47 <kmc> @quote recursivity
14:03:47 <lambdabot> No quotes match. I am sorry.
14:04:30 <kmc> some people just pick one of the channels with the most users and ask there
14:04:46 <ben0x539> Also is the fact that Data.Bytestring{,.Char8} operations act on the same type an implementation detail or are they just another interface for the same packed structure?
14:04:55 <zygoloid> ben0x539: whose 'best practice'? :) i avoid it myself...
14:04:59 <Jedai> ben0x539: OverloadedString should be fine since generally the string you explicitly put in your code are short and simple, the killer pack/unpack are on String/ByteString read from the input and that may have significant size
14:06:47 <Jedai> ben0x539: Data.ByteString.Char8 provides some operation that have a character orientation rather than pure Word8 (binary) interpretation, but it works on the same type as Data.ByteString, that is the strict ByteStreing type (NOT the same as the lazy bytestring type)
14:07:30 <Jedai> The lazy bytestring type and operation is in Data.ByteString.Lazy[.Char8]
14:08:17 <Jedai> kmc: And we have more users than #C...... o_0
14:08:48 <IceDane> Jedai: haskell is awesomer than C. And this is from a guy who's done C for years
14:08:56 <ben0x539> Everybody knows C, few want to consciously hang around other people who share the same vice... ;)
14:09:00 <IceDane> But then again, I realized C wasn't awesome at all in comparison to many languages a long time ago
14:09:29 <dancor> they always yell at me for being a noob in #C  ;__;
14:09:32 <Gracenotes> I use ghci a lot
14:09:41 <IceDane> To be honest, C is to other, higher and more expressive languages like assembly is to C
14:09:50 <Gracenotes> it is an excellent REPL for simple, useful tasks (and other sorts, not to mention)
14:10:19 <Jedai> Gracenotes: I feel a "but" coming ?
14:10:19 <Gracenotes> particularly with typesafe printf, you just put everything in a list and print it out prettily
14:10:32 <Gracenotes> not that I know of :o
14:10:36 <ben0x539> printf is typesafe?
14:10:59 <dancor> :t printf
14:11:00 <lambdabot> forall r. (PrintfType r) => String -> r
14:11:08 <dancor> but is it _typesane_
14:11:11 <ben0x539> @type printf "%d" "toot"
14:11:13 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
14:11:14 <Gracenotes> well. it fits within Hindley-Milner. it does tend to throw exceptions at runtime though, so it's not that safe after all
14:11:17 <mathmadx> Question: If I type "let a = 2" in GHCi, where is a saved in?
14:11:17 <ben0x539> > printf "%d" "toot"
14:11:19 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:11:19 <lambdabot>    `GHC.Show.Show a'
14:11:19 <lambdabot>      a...
14:11:20 <Jedai> ben0x539: Not really, not the one in Text.Printf (safer than C printf but still) though there are some Templat eHaskell version that is
14:11:24 <ben0x539> > printf "%d" "toot" :: String
14:11:25 <lambdabot>   "* Exception: Printf.printf: bad argument
14:11:27 <Gracenotes> ben0x539: exception
14:11:28 <ben0x539> Jedai: Right
14:11:32 <kmc> Gracenotes, i'd say that makes it typesafe but not statically type
14:11:47 <kmc> it's hard to write something unsafe in Haskell without resorting to, well, one of the functions with "unsafe" in the name
14:12:07 <Gracenotes> but printf could probably be rewritten to use Just/Nothing
14:12:17 <ben0x539> Yeah, but who would want that :V
14:12:27 <kmc> even so, you wouldn't have static checking of the format specifiers matching the args
14:12:32 <kmc> which is what the TH version gets you
14:12:34 <Jedai> mathmadx: it's one of the binding you can use for the rest of the session, you can inspect them
14:12:36 <Gracenotes> it's just that most times you use it, failfast and failhard are what you want if you've screwed up the call
14:12:48 <kmc> *and* it's possibly faster, since the parsing is done at compile time
14:12:59 <ben0x539> kmc: I am utterly unfamiliar with template haskell :<
14:13:06 <Jedai> mathmadx: with ":show bindings"
14:13:11 <kmc> ben0x539, do you know what the idea is?
14:13:13 <mathmadx> aha
14:13:28 <ben0x539> kmc: I think so; writing code that spits out code at compile time.
14:13:34 <kmc> yes
14:13:40 <Jedai> mathmadx: basically in GHCi prompt you're in a great IO do-block
14:13:42 <joe___> when I tried the overloading strings pragma, I still get the below error
14:13:44 <joe___>  No instance for (Data.String.IsString
14:13:44 <joe___>                        Data.ByteString.Internal.ByteString)
14:13:47 <kmc> , $(printf "%08d %s") 29 "foo"
14:13:49 <lunabot>  luna: Couldn't match expected type `t -> a'
14:13:54 <ben0x539> hmm
14:14:05 <Jedai> mathmadx: except it automatically put a print before any pure expression you enter
14:14:06 <kmc> , [$ty| $(printf "%08d %s") |]
14:14:09 <lunabot>  String -> String
14:14:21 <kmc> , [$ty| $(printf "%d %s") |]
14:14:23 <joe___>       arising from the literal `"3rot"' at
14:14:24 <lunabot>  ()
14:14:31 <kmc> hmm, that doesn't seem right
14:14:51 <gOcOOl> after upgrading to ghc 6.10, keys like 'Home, 'End etc on my keyboard have stopped doing the right thing in ghci. Hitting the 'Home' key puts some weird character on the screen in ghci rather than going to the start of the line
14:14:52 <kmc> , ppr $ runQ $ printf "%08d %s"
14:14:53 <lunabot>  luna: Not in scope: `ppr'
14:14:57 <gOcOOl> anyone know what I might be missing?
14:14:57 <kmc> , pp $ runQ $ printf "%08d %s"
14:14:58 <lunabot>  luna: No instances for (Data.Data.Data
14:15:01 <joe___> do I need to import something
14:15:03 <kmc> i give up
14:15:13 <ben0x539> kmc: this would not have happened with std::cout
14:15:20 <blackdog> fritschy: it's sort of a context thing, i think. you can understand
14:15:20 <kmc> haha
14:15:25 <blackdog> gah. sorry.
14:15:44 <kmc> it amuses me how many C++ programmers shun iostreams
14:15:50 <joe___> I have tried "import Data.String" and also "import Data.ByteString"
14:15:54 <kmc> because while it's all conceptually nice and templated and operator-overloaded,
14:15:56 <joe___> but do not seem to help.
14:16:03 <kmc> it's actually much harder to get shit done.
14:16:04 <leimy_> kmc: and favor printf?
14:16:06 <kmc> yeah
14:16:07 <dancor> gOcOOl: idk, you could see if this works: http://hackage.haskell.org/package/ghci-haskeline
14:16:20 <leimy_> kmc: depends... iostreams can be handy when used well.
14:16:23 <kmc> also, boost::lexical_cast
14:16:42 <kmc> which is the sort of no-brainer utility that wasn't included in the C++ language, because instead there's this five line "design pattern" you're supposed to use
14:16:50 <Peaker> kmc, I think C++'s stdlib iostreams are horribly designed
14:16:52 <kmc> (a design pattern being a function you haven't written yet)
14:16:59 <Peaker> kmc, The Qt IO streams are the more correct way to do it
14:17:07 <leimy_> Peaker: Qt is great
14:17:19 <ben0x539> :(
14:17:21 <leimy_> I've had very positive experiences with Qt for many years
14:17:31 <joe___> don't bother, I can get it to work with pack
14:17:33 <joe___> import Data.ByteString.Char8 (pack)
14:17:33 <leimy_> even the Python bindings didn't suck too badly :-0
14:17:36 <Peaker> leimy_, Its well designed, as far as C++ libraries go, yeah. I remember *loving* it. When coming back to Qt after Python/Haskell experiences, I wasn't so impressed anymore, though
14:17:39 <ben0x539> Iostreams are vaguely horrible and I shudder every time I try to remember how to check and clear the status bits
14:17:48 <ben0x539> but I never made it past the first page of any given Qt introduction
14:17:56 <leimy_> Yeah I've had little use for GUI anything lately :-)
14:18:03 <ben0x539> I like Gtkmm, though :(
14:18:11 <leimy_> I don't like Gtk at all
14:18:12 <kmc> pygtk is pretty decent
14:18:26 <Jedai> joe___: In fact the IsString instance is in Data.ByteString.Char8
14:18:39 <ben0x539> Gtk is the only toolkit that really clicked with me
14:18:42 <kmc> python is in general a great language with great libraries which is crippled by a lack of high-quality implementations
14:18:46 <ben0x539> though preferably through language bindings
14:18:48 <joe___> jedai, thanks.
14:18:52 <leimy_> gtk seems ok I guess, I didn't understand why they worked so hard to do all the things that you already had for free in C++
14:19:00 <leimy_> But, C has a real ABI
14:19:08 <leimy_> C++'s breaks a lot.
14:19:13 <leimy_> or is broken a lot
14:19:13 <leimy_> :-)
14:19:19 <Peaker> kmc, the iostreams are badly designed, imo, because a single object handles too much (the iostream itself handles: Low-level read/write access and data serialization and higher-level reads writes.  There should be one abstraction for read/write access. Another for higher-level read/write access given a low-level accessors.  Another for serializing.  with iostreams, the << method is implemented by iostream itself and does textual serializing. That's just s
14:19:19 <Peaker> illy
14:19:25 <ben0x539> Apparently they can now generate language bindings for GObject stuff mostly automatically, which is nice, I guess.
14:19:43 <Peaker> leimy_, Gtk+ was less nice than Qt but not horrible
14:19:48 <ben0x539> Peaker: but everybody can write their own <<s
14:19:52 <joe___>     Module `Data.ByteString.Char8' does not export `IsString'
14:19:54 <ben0x539> Peaker: And iostreams just use streambufs
14:20:02 <Peaker> But as far as UI's go, Gtk+, Qt, and all others are horrible
14:20:03 <leimy_> Peaker: You can write your own << and you can write your own streambuf
14:20:03 <ben0x539> and you can write a new streambuf and plug it into an iostream(*)
14:20:04 <joe___> when I tried to export IsString
14:20:10 <joe___> jedai, any thoughts, please?
14:20:11 <leimy_> I've got a streambuf for IPC over pipes
14:20:15 <Peaker> ben0x539, iirc, << wasn't even virtual (but it was a long time ago)
14:20:21 <joe___> or if it is a bother I acn stick with pack?
14:20:26 <Jedai> joe___: you don't need to export it explicitly, just import Data.ByteString.Char8 and you'll get the instance
14:20:28 <ben0x539> Peaker: It is not
14:20:36 <EnglishGent> @hoogle  (Monad m) => (t -> t1 -> b) -> t -> m t1 -> m b
14:20:36 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:20:37 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:20:37 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
14:20:44 <ben0x539> Peaker: I meant you write a free, non-member operator<< that implements the serialisation thing for your new type
14:20:57 <leimy_> I think I still have KDE commit access :-)
14:21:00 <joe___> I used head and I am getting an error between Prelude.head and Data.Bytestring.char8.head
14:21:02 <Peaker> leimy_, its not a separate abstraction for read/write access and high-level serialization.. its all mishmashed together
14:21:06 <Jedai> joe___: you may even put an empty import list () after Data.ByteString.Char8 to avoid conflict
14:21:16 <joe___> ok, thanks. will trype
14:21:17 <Peaker> ben0x539, That's a workaround for an ugly design, though, and seems out of place
14:21:18 <leimy_> Peaker: The layers are not terribly well defined no.
14:21:20 <joe___> ok, thanks. will try..
14:21:34 <leimy_> there's some blurry lines, but you can create a nice new streambuf, and then get an ostream on it.
14:21:36 <ben0x539> Peaker: It is as close as C++ is going to get to 'instance Show Foo'
14:21:40 <leimy_> or an istream
14:21:42 <joe___> jedai, thanks that helped.
14:21:43 <Jedai> joe___: use "import Data.ByteString.Char8 ()" it will only import instances and nothing else
14:21:46 <chrisdone> can I write agda code and use it from haskell or vise versa?
14:21:50 <Peaker> leimy_, Why not just re-abstract the whole thing correctly?
14:21:59 <leimy_> Peaker: legacy code :-)
14:22:06 <leimy_> C++ is doomed by its success
14:22:10 <Jedai> chrisdone: ISTR that there is a bridge somewhere but I never tried it myself
14:22:19 <leimy_> Remember what SPJ said about Haskell
14:22:22 <Peaker> leimy_, People at my office are writing *new* code in C++ :-(((
14:22:23 <leimy_> avoid success at all costs.
14:22:50 <leimy_> Peaker: phear! :-)
14:23:32 <leimy_> The best C++ I had written in the last 3 years used Spirit.
14:23:35 <Peaker> leimy_, It saddens me but I can't convince them otherwise
14:23:36 <leimy_> Which borrows from Parsec.
14:23:57 <EnglishGent> Peaker - I feel your pain :|
14:24:04 <Peaker> leimy_, I am successful in getting some folks there excited about Haskell, but only one is actually switching to it for stuff
14:24:07 <leimy_> In fact, most of the C++ I have ever written was not OOP :-)
14:24:07 <ben0x539> I write new C++ code; beats C :(
14:24:21 <leimy_> I wrote a big chunk of code in haskell for this thing I hope we deploy
14:24:53 <Peaker> The steps are usually: "ha, new language, kidding me right?" "it seems really nice and elegant, but no way ordinary people can learn this" "OK, this is really cool, but its just not practical" "OK, this is practical, but I'm not sure I can find a project to use this"
14:24:57 <leimy_> But for the lack of strictness and my lack of knowledge around why it wasn't strict made it difficult to put haskell into a long running process.
14:25:00 <leimy_> was really leaky :-)
14:25:06 <leimy_> Peaker: New language that's about 20 years old :-)
14:25:17 <Peaker> Or "no time to convert everything we have" yadda yadda
14:25:24 <galdor> Peaker: funny, got the same reactions
14:25:34 <EnglishGent> Peaker - I have to confess there is some truth to step 2 in Haskell's case - most people have enough trouble understanding imperative languages :|
14:25:38 <leimy_> My boss wanted me to do it in another language
14:25:38 <galdor> "nobody can understant that code"
14:25:44 <leimy_> I looked at my team of 1 and overruled him
14:25:46 <leimy_> and I told him so
14:25:47 <leimy_> :-)
14:25:58 <Vulpyne> Job security!
14:26:02 <leimy_> I guess
14:26:17 <leimy_> I told him  Look we're not that far from Portland... I'm sure you can find another Haskell hacker."
14:26:18 <EnglishGent> what - the code is written in Haskell - therefore you cant replace me?
14:26:24 <leimy_> We're in Seattle :-)
14:26:24 <chrisdone> haskell's more like an imperative language with discipline
14:26:33 <ben0x539> Maybe if we could link haskell dlls as plugins into applications written in traditional languages, we can do a bottom-up thing
14:26:34 <leimy_> DDC!
14:26:34 <dino-> One way you can sneak it into somewhere is by starting to write scripts in Haskell for things here and there.
14:26:40 <EnglishGent> nah.. too many Haskell programmers now - write it in Agda - *then* you have job security :)
14:26:40 <tommd> leimy_: Yes, there are lots of us down here, but most seem to have something going on.
14:27:04 <leimy_> tommd: if you're all gainfully employed that's great! :-)
14:27:14 <leimy_> also hi tommd! :-)
14:27:18 <tommd> Hello!
14:27:47 <EnglishGent> hello leimy, tommd :)
14:27:57 <Heffalump> ben0x539: you can do that
14:27:57 <leimy_> Hello EnglishGent
14:28:29 <kmc> Haskell is an imperative language
14:28:29 <leimy_> I've written 3 simulators for our products (in lieu of real hardware for every developer to work against, cuz it's pricey) in Haskell
14:28:32 <kmc> it's also a functional language
14:28:40 <kmc> the opposite of "functional" is not "imperative"
14:28:42 <leimy_> The main code is Erlang
14:28:46 <kmc> the opposite of "functional" is "dysfunctional"
14:29:01 <leimy_> there's dysfunctional languages
14:29:05 <tommd> leimy_: So the costly equipment that not everyone can have is Ericson comms gear?
14:29:15 <leimy_> tommd:  nope :-)  Good guess
14:29:21 <joe___>  Couldn't match expected type `String'
14:29:21 <joe___>            against inferred type `Data.ByteString.Internal.ByteString'
14:29:23 <joe___>     In the first argument of `putStr',
14:29:30 <JohnnyL> @src break
14:29:30 <lambdabot> break p =  span (not . p)
14:29:34 <tommd> joe__: Use the Data.ByteString.putStrLn
14:29:35 <joe___> i can get the function to work with "print"
14:29:36 <JohnnyL> @src span
14:29:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:29:37 <dino-> leimy_: So.. when could one or more of us interview to join your team?
14:29:40 <leimy_> it's hardware that talks CAN, but it's not a car :-)
14:29:46 <joe___> tommd, thanks.
14:29:53 <leimy_> dino-: at this point it's not clear I'm going to have a job in a few weeks
14:30:08 <leimy_> whole company's in trouble.
14:30:10 <tommd> leimy_: So that frees you up to move to Portland, right?
14:30:24 <leimy_> lol
14:30:27 <tommd> I feel for you, but there is always an upside.
14:30:33 <leimy_> yep
14:30:39 <kmc> is Portland where all the Haskell hackers live?
14:30:48 <kmc> is this just because of Galois?
14:30:50 * sohum shudder a bit: instance Num (MONEY -> Currency) where; fromInteger i Pounds = C (i * 100); fromInteger i Pence = C i
14:30:55 <dino-> leimy_: Ah. Whole industry is in trouble. Between jobs myself. Good luck!
14:30:57 <leimy_> I'm actually contracting on the side for more money than I was making when this job bothered to pay me for my work :-)
14:30:57 <tommd> kmc: Portland, Boston, England, UNSW.
14:31:02 <tommd> Chalmers...
14:31:09 <leimy_> yeah I need to find something steady
14:31:18 <dino-> But damn, Portland so gloomy
14:31:21 <leimy_> tommd: SPJ's office :-)
14:31:27 <kmc> sohum, newtype GBP = GBP Double deriving (Eq, Ord, Num, Fractional, Floating, Read, Show)
14:31:39 <EnglishGent> so is England (gloomy) :|
14:31:40 <leimy_> dino-: that's why people stay inside and think about functional programming :-)
14:31:44 <tommd> leimy_: So is it safe to say you'd consider offers?
14:31:44 <kmc> but that won't do pounds/pence conversion
14:31:53 <leimy_> tommd: Job offers?
14:31:54 <chrisdone> I wrote an ecommerce web site in haskell when I did freelance
14:32:04 <sohum> kmc: this is someone else's code. it's a hack so you can say "42 Pounds" in source code
14:32:11 * kmc considered applying to Chalmers grad school
14:32:14 <kmc> anyone here a student there?
14:32:23 <leimy_> tommd: the problem is my wife has an excellent job, been there 13 years.  If I could work remotely and commute on occasion I'd consider it :-)
14:32:36 <dino-> I'd like to go live in the big apple. Maybe a whole band of consultants solving problems with Haskell and FP in the city would work.
14:32:43 <EnglishGent> @hoogle a -> IO Bool
14:32:44 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
14:32:44 <lambdabot> Control.Exception evaluate :: a -> IO a
14:32:44 <lambdabot> Control.OldException evaluate :: a -> IO a
14:32:51 <leimy_> right now she's my sugar momma I guess :-)
14:33:01 <tommd> Yay!
14:33:01 <leimy_> Or I'm some sort of trophy husband
14:33:20 <gOcOOl> can somebody point me to some very basic tutorials on writing DSLs with Haskell? The on that dons has on his blog regarding the subject is a bit too abstract and advanced for my level of understanding currently
14:33:28 <gOcOOl> i'm just looking for a very basic example
14:33:32 <JohnnyL> In:   break :: (a -> Bool) -> [a] -> ([a], [a])    if (a->Bool) is the only operator to break how does break retrieve the values from a? such that odd = (a->Bool) and [a]= [2,3,4,5].
14:33:34 <leimy_> I'd actually like to take Haskell, Erlang, functional programming in general to Amazon :-)
14:33:37 <lament> just write stuff in haskell and it'll end up being a DSL
14:33:42 <leimy_> as they're pretty local.
14:33:50 <leimy_> like a few blocks from here.
14:33:54 <chrisdone> gOcOOl: a good example of a DSL is Text.Html
14:34:06 <Peaker> gOcOOl, Pretty much every Monad instance is a DSL
14:34:15 <Peaker> gOcOOl, the list monad, for example
14:34:36 <gOcOOl> ah ok, taking a look now ...
14:34:37 <zygoloid> parsec is a good example of a DSL
14:36:07 <mathmadx> Why is it possible to define functions in console of GHCi w/o using let, but defining variabels requires let?
14:36:11 <kmc> DSL is in some sense a fancy name for "library"
14:36:18 <gOcOOl> i guess I don;t completely understand what a DSL exactly is then :)
14:36:24 <kmc> well also
14:36:28 <kmc> do you mean an embedded DSL?
14:36:38 <sproingie> mathmadx: you can't define functions in ghci without let
14:36:41 <EnglishGent> an idea for a tool btw (I'm wondering what people think) - something where you provide a 'pure' version of a function signature (no monads involved) - and one which is the same, except with m's in it at places - and it figures out what function you need to convert a function of the first type into the second
14:36:47 <kmc> so a domain-specific language, in general, is a language designed for specific tasks
14:36:48 <Peaker> kmc, A library of semantic combinators..
14:36:52 <EnglishGent> do people think this would be useful? possible?
14:36:54 <Jedai> JohnnyL: What do you mean ?
14:36:58 <Jedai> @src break
14:36:59 <lambdabot> break p =  span (not . p)
14:37:02 <Peaker> kmc, Not many would claim System.Environment or any random collection of IO actions is a DSL
14:37:04 <Jedai> @src span
14:37:04 <lambdabot> Source not found. Do you think like you type?
14:37:13 <Peaker> kmc, Usually a DSL is some type and associated combinators for building such types
14:37:13 <dino-> chrisdone: Used a specific Haskell web framework for that or more bare cgi?
14:37:16 <kmc> a DSL needn't be embedded.  it could have a very traditional implementation in terms of lexer, parser, code generator...
14:37:20 <leimy_> Peaker: I came to that realization when I wrote my little "expect" language
14:37:31 <leimy_> which if we fold... maybe I'll share :-)
14:37:35 <kmc> an embedded DSL mimics the features of a non-embedded DSL, using a library alone
14:37:40 <kmc> and thus getting the power of the host language as well
14:37:45 <Jedai> JohnnyL: basically, you can define break with takeWhile and dropWhile or do a manual recursion
14:37:55 <dino-> Just curious, I'm just getting towards the end of a web app where we stuck to the cgi basics.
14:38:05 <JohnnyL> Jedai thats not my question.
14:38:28 <Vulpyne> EnglishGent: I'm not sure how useful it would be, but it would probably be an interesting project.
14:38:32 <Jedai> JohnnyL: I don't understand your question though, could you reformulate ?
14:38:37 <kmc> there's a specific *type* of EDSL called a "deep embedding", where you're actually building the AST for your DSL's syntax in another language, rather than executing it as you go
14:38:43 <sproingie> DSL has a pretty subjective definition.  parsec's a DSL insofar as it has a bunch of combinators that you put together in a grammar
14:38:43 <JohnnyL> Jedai If haskell only takes one function at a time how does it parse that definition? (by functoin application i assume)
14:38:49 <leimy_> I can hear a distant fax machine
14:38:50 <chrisdone> dino-: I used bare CGI with text.html ontop. would've used fastcgi if it wasn't a shared host. (http://productsforhair.co.uk/ -- horrible design, I had to work with it). I'd probably use XSL instead of Text.Html were I to write another web site in haskell
14:38:58 <kmc> that usually involves things like "instance Num Expr", so you can say "e1 + e2" and have it mean "Add e1 e2", where Add is some constructor for Expr
14:39:01 <sproingie> GLSL and SQL are another kind of DSL which are actually completely separate languages dedicated to their domain
14:39:09 <Jedai> > break (> 5) [1..10]
14:39:10 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
14:39:14 <gOcOOl> kmc: ok, makes sense, sort of, but the weird thing is i hear people talk about building a DSL or EDSL for use by folks who don;t necessarily know Haskell
14:39:28 <kmc> that's not too weird
14:39:37 <gOcOOl> so in that context, I'm not sure what exactly they're talking about
14:39:51 <sproingie> gOcOOl: they won't get too far if they don't know any haskell, but they don't have to be haskell experts at any rate
14:40:02 <Jedai> JohnnyL: I still don't really understand your question, break don't "parse" anything, it gets a function in parameter, and it applies it, a function is a value like any other
14:40:10 <kmc> gOcOOl, if it's a non-embedded DSL then the DSL doesn't need to look anything like Haskell
14:40:25 <kmc> you may implement it in Haskell because Haskell is a great language for parsers, code manipulation, etc.
14:40:41 * EnglishGent thinks he might give it a go - I want to understand monads more deeply, and it seems that it would be hard to write something like that without acquiring such an understanding :)
14:40:48 <Jedai> kmc: even if it's embedded it don't really have to look like Haskell... look at the BASIC EDSL on hackage
14:40:50 <dino-> chrisdone: I think it looks good, in the professional website sense.
14:41:07 <leimy_> EnglishGent: Ever heard of the movie "The Box"?
14:41:07 <kmc> yeah the BASIC EDSL is nuts though
14:41:12 <EnglishGent> I'm not sure how hard it's likely to be though
14:41:16 <EnglishGent> leimy - no
14:41:19 * EnglishGent googles
14:41:24 <leimy_> damn I had an analogy
14:41:52 <mathmadx> Why does this give an error:
14:41:52 <mathmadx> f (x,y) | y `mod`  2 ==0 =2*x | otherwise =x
14:41:56 <sproingie> i wonder what the BASIC EDSL's error messages look like
14:42:00 <leimy_> If you think of the box in the movie the box as a monad with 1 million dollars attached, then the rule that you have to have to push the button on the box to get the money is like a monad :-)
14:42:05 * EnglishGent would like to know the analogy anyway :)
14:42:24 <Jedai> JohnnyL: Or are you talking about the "function in Haskell only have one parameter" argument ?
14:42:29 <leimy_> basically this guy shows up and says, if you push the button on this box I'll give you 1 million dollars.
14:42:33 <dino-> I did that too, with Text.Xhtml  It seems to get hairy on you when the pages are very complex. Maybe a combination of templates or XSL would be in order in the future.
14:42:35 <leimy_> but someone in the world will die.
14:42:37 <JohnnyL> Jedai again, thats not my question. Of course Haskell parses its code. My questions are what is [a]? Is it a argument to break? How does break apply a [] to a a->Bool?
14:42:37 <leimy_> that's a monad :-)
14:42:42 <chrisdone> dino-: one cool thing I used was the Formlets library. have you used that?
14:42:45 <JohnnyL> Jedai no I know that.
14:42:51 <sproingie> JohnnyL: it's the second argument to break
14:42:58 <dino-> chrisdone: http://ui3.info/grolprep/bin/fcc-grol-prep.cgi
14:42:58 <sproingie> @src break
14:42:59 <lambdabot> break p =  span (not . p)
14:42:59 <leimy_> when you "run the box monad" you get the 1 million, but then someone dies.  That'd be a captured side effect.
14:43:00 <chrisdone> dino-: yeah, I had the same thing. anything complex and it gets hairy
14:43:00 <dino-> chrisdone: no
14:43:05 <sproingie> @src span
14:43:06 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:43:07 <JohnnyL> sproingie haskell only has one argument to any function.
14:43:24 <sproingie> JohnnyL: technically yes.  at the practical level we're talking at, no
14:43:26 <Jedai> JohnnyL: you're aware that "(a -> Bool) -> [a] -> ([a],[a])" is a type right ?
14:43:42 <JohnnyL> Jedai forget it.
14:43:50 <EnglishGent> which film specifically leimy? there seem to be a number of different ones on imbd all with that title!
14:43:59 <sproingie> JohnnyL: break returns a function that expects a list, so we just say break takes two args
14:44:14 <sproingie> even if it doesn't actually
14:44:17 <Jedai> JohnnyL: so it's a function that takes a function from a to Bool and returns a function from [a] to ([a],[a])
14:44:23 <nlogax> chrisdone: nice work! inspirational (hoping to be able to use haskell for my future web work)
14:44:44 <Jedai> JohnnyL: a being a given type
14:45:14 <chrisdone> dino-: I got a question right. woo! this is nice =)
14:45:39 <chrisdone> nlogax: cool! anything particular in mind?
14:45:46 <dino-> chrisdone: Thanks, I know it's fairly ugly. But first web stuff ever, so learning the CSS as I go along here.
14:45:53 <Jedai> JohnnyL: break predicate = (\list -> (takeWhile (not . predicate) list, dropWhile (not . predicate) list)
14:45:57 <dino-> And the users, they don't really care what it looks like.
14:46:09 <chrisdone> dino-: sure
14:46:33 <nlogax> chrisdone: not really. i do web development on my day job. just want to combine business with awesome. :)
14:46:42 <dino-> I had fancier things going on with dynamically created controls but IE6/7 was a disaster. Thanks a bunch, Microsoft. :/
14:46:56 <chrisdone> dino-: yeah Formlets are a kind of neat way to define a web form that validates according to a spec, and composes nicely. I wrote a big long post about it a while ago: http://209.85.229.132/search?q=cache:_NeLy6zSy5EJ:chrisdone.com/blog/html/2008-12-14-haskell-formlets-composable-web-form-construction-and-validation.html&cd=1&hl=en&ct=clnk
14:47:17 <Jedai> JohnnyL: Maybe you're confuse by the right associativity of (->) ? "a -> b -> c" actually means "a -> (b -> c)"
14:47:37 <chrisdone> nlogax: ah, sure
14:47:43 <dino-> chrisdone: Excellent, thank you, I'll read that.
14:47:57 <JohnnyL> I think it's break(odd([2,3,4](converts to element)))
14:48:02 <Heffalump> chrisdone: is the ecommerce site somewhere public?
14:48:16 <JohnnyL> Jedai isn't a->(b->c) composition and not function application?
14:48:16 <Jedai> JohnnyL: your parens aren't correct there
14:48:34 <dino-> I hope so, I just bought some conditioner on that site!
14:48:37 <mathmadx> I am using windows, and I am frustrated I cant copy anythinh from the console of GHCi. Options I have?
14:48:39 <nlogax> :D
14:48:40 <Jedai> JohnnyL: it's a type, it's neither application nor composition
14:48:46 <sproingie> JohnnyL: -> is right-associative, so a->b->c means the same as a->(b->c)
14:49:01 <Heffalump> mathmadx: the windows command prompt does allow copy-and-paste if you change the preferences
14:49:02 <JohnnyL> sproingie ok
14:49:06 <Heffalump> but it's rectangular, which is kind of annoying.
14:49:23 <sproingie> the arrow in types is right-associative, application itself is left-associative, which is how all this autocurrying magic works
14:49:23 <chrisdone> Heffalump: yeah but it's pretty dire. http://productsforhair.co.uk/  I don't know if the guy maintains it or has disabled the payment process. I kind of wrote it and got shut due to, uh, contractual dispute
14:49:31 <Jedai> JohnnyL: it's the type of a function that takes a parameter of type "a" and returns a function that takes a parameter of type b and returns a value of types c
14:49:38 <chrisdone> dino-: haha
14:50:02 <gabor> I am trying to send a posix signal from the main thread to a forOS-ed thread (which waits in awaitSignal). It never arrives. Why? I gather that GHC 6.10.4 does not use pthread_kill for sending the signal, otherwise I would have to specidy the ThreadId when sending.
14:50:23 <gabor> will 6.12 allow this?
14:50:47 <gabor> *forkOS*
14:50:50 <Jedai> JohnnyL: besides function application (that is denoted by a simple space in Haskell) is left-associative, so "break odd [1..10]" is the same as "(break odd) [1..10]"
14:51:04 <dino-> On that GROLPrep site, go through that small set in "Enter a list of problem IDs", there are some there with illustrations. That kind of a list of everything with weird chars, etc, to help QA
14:51:40 <sproingie> yay lyyarwgh is a googlewack now
14:51:40 <Jedai> JohnnyL: so break is applied to odd and gives a function that takes a list in parameter and returns a pair of list, then this function is applied to [1..10] and you get the result
14:51:57 <Jedai> :t break odd
14:51:58 <lambdabot> forall a. (Integral a) => [a] -> ([a], [a])
14:51:59 <JohnnyL> break :: (a -> Bool) -> [a] -> ([a], [a]) is a function that accepts a function, (a->Bool) which accepts an argument of type [a] and returns a tuple of type [a],[a].
14:52:16 <Jedai> JohnnyL: not exactly
14:52:53 <Jedai> break :: (a -> Bool) -> ([a] -> ([a], [a])) is a function that accepts a function (a->Bool) then returns a function which accepts an argument of type [a] and returns a tuple of type ([a],[a])
14:52:55 <JohnnyL> Jedai oh?
14:53:04 <JohnnyL> How is what I said wrong?
14:53:05 <dino-> Also, switching back and forth between server code in Haskell to client-side code in Javascript: depressing
14:53:38 <chrisdone> dino-: hehe. do you use jQuery?
14:53:46 <JohnnyL> a tuple of type ([a],[a]) would be ([a],[a]),([a],[a]).
14:53:48 <EnglishGent> hmm - why do we have mapM - but not takeWhileM, dropWhileM, etc ?
14:53:50 <Jedai> JohnnyL: given the structure of your sentence you appear to say that a function of type (a -> Bool) accepts an argument of type [a] and returns a tuple of type [a],[a]
14:54:03 * hackagebot upload: hCsound 0.2.2 - interface to CSound API (JohnLato)
14:54:05 <JohnnyL> how is that wrong?
14:54:29 <kmc> a function of type (a -> Bool) takes an argument of type a and returns a value of type Bool
14:54:38 <Jedai> JohnnyL: Well that's wrong, a function of type (a -> Bool) accepts a value of type a and returns a Boolean
14:54:52 <dino-> No. Just started hammering things out while referring to the O'R book.
14:55:00 <dino-> (for JS)
14:55:05 <Jedai> JohnnyL: Also you confuse tuple and pair, and you also seems to think that pair have two times the same type
14:55:16 <JohnnyL> opps
14:55:18 <nlogax> JS.. sadness. thought i had written a nice partial application function, when i found that functions have a length property, yay! i'll just return a new function while prepending the arguments until f.length == args.length
14:55:19 <kmc> a pair is a 2-tuple
14:55:25 <chrisdone> dino-: ahh
14:55:28 <monochrom> (Why do we need to paraphrase type expressions?)
14:55:45 <JohnnyL> no, what I said was right.
14:55:52 <JohnnyL> <JohnnyL> break :: (a -> Bool) -> [a] -> ([a], [a]) is a function that accepts a function, (a->Bool) which accepts an argument of type [a] and returns a tuple of type [a],[a].
14:55:54 <nlogax> and then i remembered functions like addLol = function() { return arguments[0] + arguments[1]; } which have length 0...
14:56:03 <Jedai> JohnnyL: You can say a "tuple of type (a,b)" or a "pair of type (a,b)"
14:56:14 <Jedai> JohnnyL: still not...
14:56:19 <dino-> chrisdone: But very little works as expected in >1 browser, it seems. I guess that's where these frameworks come in. It's terrifyingly feral, the web.
14:56:24 <JohnnyL> I simply call (a->Bool) a function.
14:56:25 <kmc> JohnnyL, the problem is at "... which accepts"
14:56:31 <kmc> "accepts a function, (a->Bool) which accepts an argument of type [a]"
14:56:34 <kmc> that's wrong
14:56:52 <kmc> it accpts a function of type (a->Bool), then *returns* a *different* function, which accepts an argument of type [a]
14:56:55 <Jedai> JohnnyL: You don't "call" (a -> Bool) a function ,that's not a function, it's the type of a function
14:56:56 <Cale> It's right if you don't misparse it ;)
14:57:14 <monochrom> what does "which" refer to?
14:57:14 <JohnnyL> kmc ah so a function using (a->Bool) accepts an argument of type [a]?
14:57:19 <kmc> no
14:57:28 <kmc> :t break
14:57:29 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:57:32 <kmc> :t break (== 'x')
14:57:33 <lambdabot> [Char] -> ([Char], [Char])
14:57:34 <monochrom> Anyway I guess this whole thread is pointless.
14:57:37 <kmc> :t break (== 'x') "abcxde"
14:57:38 <Cale> break :: (a -> Bool) -> [a] -> ([a], [a]) is a function (that accepts a function, (a->Bool)) (and) which accepts an argument of type [a] and returns a tuple of type ([a],[a])
14:57:38 <lambdabot> ([Char], [Char])
14:57:51 <chrisdone> dino-: indeed. at my company our sites have to be cross browser before passing quality control, so jQuery (or frameworks like it) are kind of a must to get done work in a realistic time frame. plus it's hella easy.
14:58:00 <Jedai> JohnnyL: No, it accepts an argument of type a, not [a] ([a] is the type of a list of value of type a)
14:58:11 <Cale> But the way it was written is confusing :)
14:58:27 <JohnnyL> Cale Almost the way I said it.
14:58:44 <Jedai> Cale: No, it seems there still is a misunderstanding...
14:59:16 <kmc> :t break
14:59:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:59:19 <kmc> :t break (== 'x')
14:59:20 <lambdabot> [Char] -> ([Char], [Char])
14:59:21 <kmc> :t break (== 'x') "abcxde"
14:59:22 <lambdabot> ([Char], [Char])
14:59:31 <Cale> I would say  break takes a predicate of type (a -> Bool) and a list of type [a] and produces a pair of lists of that same type.
14:59:42 <Jedai> Cale: But anyway, even with the "and" I don't think a english teacher would accept the sentence as meaning the correct thing...
14:59:53 <JohnnyL> Cale then thats two arguments.
14:59:58 <Jedai> Cale: right, with your formulation ok
15:00:10 <kmc> JohnnyL, colloquially
15:00:17 <Jedai> JohnnyL: You can see it like that too, simply underneath it's not how it works
15:00:31 <kmc> JohnnyL, when we say a function takes two arguments, we mean it takes one argument, and returns a function that takes the second
15:00:36 <kmc> :t subtract
15:00:37 <lambdabot> forall a. (Num a) => a -> a -> a
15:00:38 <kmc> :t subtract 2
15:00:38 <JohnnyL> Jedai thats my whole question, how does it work underneath?
15:00:39 <lambdabot> forall t. (Num t) => t -> t
15:00:41 <kmc> :t subtract 2 3
15:00:42 <lambdabot> forall t. (Num t) => t
15:00:51 <Jedai> JohnnyL: reread my explanation....
15:00:57 <reltuk> break does take two arguments
15:00:58 <kmc> "break" is not the simplest case here
15:01:03 <kmc> to explain currying
15:01:03 <Jedai> JohnnyL: so break is applied to odd and gives a function that takes a list in parameter and returns a pair of list, then this function is applied to [1..10] and you get the result
15:01:18 <Cale> Another way to say it would be that break takes a predicate of type (a -> Bool), and produces a function which takes a list of type [a] and produces a pair of lists of that same type
15:01:24 <Jedai> JohnnyL: besides function application (that is denoted by a simple space in Haskell) is left-associative, so "break odd [1..10]" is the same as "(break odd) [1..10]"
15:01:49 <kmc> JohnnyL, did you see my examples with "subtract" above?
15:01:57 <Cale> break :: (a -> Bool) -> ([a] -> ([a],[a]))
15:02:32 <dino-> chrisdone: I think it's past time to use one of those frameworks. Too much time spent on the JS already with this thing. Not fun.
15:02:40 * copumpkin just had an amusing thought about ~ in TypeFamilies! It would be awesome if they made Int32 ~ Int on 32-bit machines and Int64 ~ Int on 64-bit machines (with their word counterparts)
15:02:41 <JohnnyL> kmc , yes an example of currying
15:02:42 <Phyx-> hmmmm ghc-core is nice
15:02:50 <Phyx-> @hoogle break --info
15:02:50 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
15:02:50 <lambdabot>  
15:02:50 <lambdabot> break, applied to a predicate p and a list xs, returns a tuple where first element is longest prefix (possibly empty) of xs of elements that do not satisfy p and second element is the remainder of
15:02:50 <lambdabot> the list:
15:03:01 <kmc> woah
15:03:08 <kmc> JohnnyL, so it's the same with break
15:03:10 <monochrom> Hi copumpkin, please teach me what ~ does.
15:03:16 <kmc> both break and subtract are "two-element functions"
15:03:20 <kmc> sorry "two-argument"
15:03:31 <copumpkin> (I was just kidding about the awesomeness by the way, that would be terrible)
15:03:33 <kmc> meaning they take an argument and return a function which takes the second argument
15:03:36 <copumpkin> monochrom: you're not serious :o
15:03:48 <monochrom> I am serious. I never learned type families.
15:03:59 <Jedai> monochrom: it's type equality
15:04:01 <copumpkin> oh, it's type equality
15:04:17 <Jedai> monochrom: you can put it with the type classes in the context of a type
15:04:32 <kmc> > let f :: (a ~ b) => a -> b; f = id in f 3
15:04:34 <lambdabot>   3
15:04:42 <kmc> > let f :: a -> b; f = id in f 3
15:04:43 <lambdabot>   Couldn't match expected type `b' against inferred type `a'
15:04:44 <lambdabot>    `b' is a rigi...
15:04:57 <JohnnyL> anyway, I gotta get to work. l8r.
15:05:00 <Jedai> append :: (Add n m ~ p) => List n a -> List m a -> List p a
15:05:09 <copumpkin> so if you have Foo as a type family (a type function) then Foo Int might be Bool, so you could put a context of (Foo a ~ Bool) and only a such that Foo a = Bool would be allowed
15:05:16 <Jedai> monochrom: useful for this kind of thing ^
15:05:47 <chrisdone> dino-: sure. fwiw/for future ref. your code could be: $('#select-study23 > option:first').attr('selected',true);
15:05:57 <Phyx-> mis "~" actually in haskell?
15:06:03 <kmc> yes
15:06:09 <kmc> with GHC extensions
15:06:21 <Jedai> Phyx-: Yes, with the type families extensions
15:06:22 <kmc> it's not really useful or necessary without certain extensions like type families and GADTs
15:06:40 <dino-> chrisdone: Well that looks totally unfamiliar! I'll go through their tutorials.
15:06:44 <skorpan> could someone show me a reasonable example which displays how to use functional dependencies and which is easy to understand?
15:06:45 <Phyx-> Jedai: aha
15:06:45 <monochrom> And you can just assert "Int ~ Int64"?
15:07:24 <kmc> skorpan, i will cook one up
15:07:26 <monochrom> I mean state it as an axiom, rather than as something before =>
15:07:37 <copumpkin> oh, no
15:07:40 <Jedai> monochrom: No,
15:07:41 <copumpkin> I was just kidding about that
15:07:47 <skorpan> kmc: cool, thanks
15:07:50 <monochrom> OK! Haha.
15:07:55 <copumpkin> what brought it up is that currently ~ "sees through" newtypes, which is wrong
15:08:11 * hackagebot upload: hCsound 0.2.3 - interface to CSound API (JohnLato)
15:08:14 <copumpkin> well, I believe it is, but for some reason it seems somewhat controversial
15:08:17 <Phyx-> so, a ~ b --> type of a equals type of b?
15:08:45 <monochrom> I agree.
15:09:14 <dancor> skorpan: also, how do you feel about http://www.haskell.org/haskellwiki/Functional_dependencies
15:09:56 <Phyx-> RWH is a good intro, is there like an advanced real world haskell that covers this stuff?
15:10:09 <copumpkin> it's called #haskell
15:10:14 <kmc> it's called the real world
15:10:27 <Phyx-> :|
15:10:31 <copumpkin> (but no, I don't know of any books that cover advanced topics in haskell)
15:10:33 <Jedai> Phyx-: well no, it's rather a equals b, at the type level
15:10:43 <Phyx-> copumpkin: #haskell isn't as fun to read :P
15:11:00 <copumpkin> if you view a typeclass constraint as an arbitrary relation on types
15:11:03 <dancor> Phyx-: there is not enough (any?) advanced texts like that :(
15:11:17 <copumpkin> ~ is just equality
15:11:35 <Phyx-> Jedai: hmm ok
15:11:36 <sjanssen> copumpkin: reading the scrollback, Int ~ Int64 is scary.  Would they really be the same type?
15:11:47 <Jedai> Phyx-: A canonic example where it's useful is if you encoded naturals at the type level and have a Add type family and a List type whose length is encoded in the type
15:11:52 <Jedai> append :: (Add n m ~ p) => List n a -> List m a -> List p a
15:11:58 <Phyx-> dancor: yeah, i prefer books, it reads much better when all of the information is in one place
15:12:02 <copumpkin> sjanssen: I added afterwards that I was just kidding :P
15:12:20 <skorpan> dancor: that gives me the idea, but i still don't feel like it explains it enough.  e.g., why is (m1*m2) in "(m1*m2)*m3" ambiguous?
15:12:23 <copumpkin> sjanssen: but yeah, it would be scary, but not more scary than the current behavior on newtypes
15:12:33 <Phyx-> Jedai: AH ok, i see
15:12:45 <sjanssen> Jedai: wouldn't you just write List n a -> List m a -> List (Add n m) a?
15:12:50 <copumpkin> skorpan: what's the return type of m1*m2?
15:12:56 <Phyx-> Jedai: you would still have to define addition at the type level though right?
15:13:01 <Jedai> Phyx-: Well to be honest, here you could do what sjanssen just said...
15:13:10 <skorpan> copumpkin: i'd assume it to be Matrix, but maybe i misunderstood the Num instances?
15:13:14 <Jedai> Phyx-: Right, with a type family like Add
15:13:15 <skorpan> sorry, Mult instances*
15:13:17 <dancor> skorpan: bc if (m1 * m2) * m3 :: Matrix, m1 * m2 can be Vector or Matrix
15:13:35 <Phyx-> Jedai: yeah ok, cool, but i do get what ~ is now :)
15:13:46 <dancor> since there is nothing ruling out the possibility of instance Vector Vector Matrix
15:13:52 <dino-> chrisdone: Oh something else, are you building your binar(y/ies) static? I had trouble with missing sqlite3 at link time, seems to be phased out of some distros. Eventually I just didn't bother with static.
15:13:55 <Jedai> Phyx-: but in more complicated cases, for instance if a same type must be equal to several thing at once, you can't do without ~
15:14:25 <dancor> skorpan: i.e. even if that instance doesn't exist, the typesystem won't reason for you based on which instances you haven't made (yet)
15:14:51 <Phyx-> Jedai: cool, guess i'll play around with it some more after i finish this assignment
15:15:43 <skorpan> dancor: you lost me
15:15:54 <chrisdone> dino-: I was building static but I vaguely recall having to upload some libraries anyway. in hindsight I must have built cabal packages nonstatically without realising, in my haskell youth. uploading them to the shared server was a pain in the backside!
15:16:35 <dancor> skorpan: In (m1 * m2) * m3 :: Matrix, what type would you expect m1 * m2 to have?
15:16:35 <chrisdone> dino-: (the builds that is. and, I suppose, the libraries, too, heh)
15:17:10 <dino-> I wonder if it's feasible to ship so files and do something with the env, instead of static.
15:17:13 <skorpan> dancor: right, i'm with you that far
15:17:24 <chrisdone> dino-: indeed. that would be better
15:17:33 <skorpan> dancor: or is that just it?
15:17:57 <skorpan> i got the feeling there was more to it, when you said the typesystem wouldn't reason for me and such
15:18:11 <dancor> skorpan: since we only have two instances, only one of which has c being Matrix, _we_know_ that m1 * m2 should be Matrix.
15:18:15 <dino-> Not going to bother with it then, no idea yet where this thing is going to be hosted, but if there's sqlite3 problems, I can figure out deploying that so then.
15:18:21 <Phyx-> in Core, what's "@" ?
15:18:53 <kmc> skorpan, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12252#a12252
15:18:55 <skorpan> what!?  but then why is it ambiguous?  i thought you said earlier that it could be either Matrix or Vector
15:19:49 <chrisdone> Phyx-: is it not the same as normal haskell?
15:20:41 <skorpan> kmc: that's a very nice example, do you mind if i add that to the wiki?
15:20:44 <dancor> skorpan: because although _we_know_ only one thing would make sense here, haskell does not work that way.  because there is nothing stopping us from making more instance later, with c being Matrix and a being anything else (like Vector), haskell finds it ambiguous.
15:20:47 <kmc> go ahead
15:20:50 <Phyx-> chrisdone: far as i know, @ in normal haskell is used to label something, but in core it's used for instance (@ var) or drop @ a
15:20:51 <kmc> and feel free to correct anything
15:21:01 <chrisdone> Phyx-: ah, interesting
15:21:34 <skorpan> dancor: i think i get it (almost) now.. thanks!
15:21:50 <chrisdone> goingbednight
15:22:20 <dino-> kmc: Thanks for that, I'm shaky on fundep too
15:22:30 <dino-> evening chrisdone, thank you
15:22:47 <dancor> it's a trade-off of power for safety that haskell decides this is ambiguous.
15:23:07 <dancor> fundeps allow us to get some power back without giving up much safety.
15:23:22 <Phyx-> dons: is it possible, with ghc-core to give it a file containing the core already, instead of having it run ghc? or maybe give the flags to use with ghc along ?
15:25:07 <kmc> it should be noted that associated types are often a nicer way of accomplishing the same thing
15:26:22 <skorpan> is that the same thing as type families?
15:26:37 <Phyx-> dons: ah, nvm, --with-ghc allows you to pass it along :)
15:26:55 <kmc> it's a type family that lives in a typeclass
15:29:48 <kmc> this is how it would look with ass-types:
15:29:50 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12253#a12253
15:30:05 <kmc> i think it's clearer
15:30:34 <skorpan> ASS types?
15:30:50 <kmc> associated types :)
15:30:56 <skorpan> oh, hehe
15:31:09 <IceDane> hey, just out of curiosity - are there a lot of haskell applications that are used for *huge* enterprise-size stuff? If so, any examples?
15:31:22 <kmc> IceDane, http://www.haskell.org/haskellwiki/Haskell_in_industry
15:31:25 <travisbrady> if one wanted to implement a server that just does incr and decr on some keys how would you best do it in Haskell?  using Data.Map?
15:31:28 <IceDane> Ah, sweet, thanks =)
15:32:41 <kmc> IceDane, Bluespec implements their VLSI tools in Haskell
15:32:56 <kmc> the various financial modeling projects also sound fairly large
15:33:29 <IceDane> yeah I just read that
15:33:47 <IceDane> that's pretty impressive
15:33:59 <skorpan> they'll all be bankrupt by the end of this year
15:34:08 <skorpan> unless they know their ass types of course
15:36:21 <kmc> it seems that most of the commercial uses of Haskell are for implementing other languages, embedded or otherwise
15:36:30 <kmc> it certainly is an excellent choice for those sorts of tasks
15:36:45 <kmc> and it's the kind of thing people are reluctant to do in general, because it's such an enormous pain in the ass in C++ or Java
15:36:52 <kmc> so there's a great competitive advantage to be had
15:36:58 <sproingie> pain in the ass type you mean
15:37:04 <kmc> indeed
15:37:18 <sproingie> there should be an elbow type
15:37:54 <IceDane> I'll just sit and lurk in this channel until I get that joke
15:38:11 <IceDane> I assume it'll be like writing most of the haskell I've done.. all of a sudden: "AH!"
15:38:40 <sproingie> IceDane: the test of a haskell programmer will then be to see if they can tell their ass type from their elbow type
15:38:56 <sproingie> of course i'm probably using an idiom that doesn't translate
15:42:05 <copumpkin> associated type?
15:42:28 <joe___> parse :: [String] -> IO ()
15:42:29 <joe___> parse [] = do return ()
15:42:29 <joe___> parse [x:xs] = do if '\'' == head x then return () parse xs
15:42:38 <joe___> parse error (possibly incorrect indentation)
15:42:40 <kmc> joe___, you don't need either "do"
15:42:45 <kmc> "do x" is equivalent to "x"
15:42:52 <joe___> ok, thanks.
15:42:56 <kmc> where "x" is a single statement
15:42:59 <kmc> that's not your error though
15:43:03 <joe___> yes
15:43:08 <Vulpyne> You probably want (x:xs)
15:43:25 <kmc> you probably want (('\'':_):xs)
15:43:31 <joe___> yes, u are correct.
15:43:34 <joe___> thanks, guys
15:43:36 <skorpan> you alse need "else" somewhere in an "if"
15:43:46 <skorpan> i assume you meant "else parse xs"
15:43:47 <kmc> parse (('\'':_):xs) = parse xs; parse _ = return ()
15:43:55 <kmc> also:
15:43:56 <kmc> :t when
15:43:57 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:44:19 <skorpan> what's that whole (m :: * -> *) constraint about?
15:44:31 <kmc> Monads all have kind * -> *
15:44:41 <kmc> meaning, they expect one additional type parameter
15:44:43 <skorpan> right, so what's the point
15:44:45 <kmc> that's why "m ()" is a type but "m" isn't
15:44:52 <skorpan> seems superfluous
15:45:05 <kmc> it is
15:45:17 <kmc> ghci doesn't print it
15:45:19 <skorpan> way to confuse newcomers :)
15:45:30 <kmc> but lambdabot likes to give the explicit quantification, and when you do that, it defaults kinds to * unless specified
15:45:33 <kmc> i think
15:48:44 <ksf> good morning #haskell
15:48:52 <kmc> 'morning
15:49:17 <joe___> kmc, that helped, thanks
15:49:25 <joe___> Vulpyne, thanks for ur help.
15:49:37 <Vulpyne> You're welcome.
15:50:57 <joe___> this is the first that I could complete a working haskell program in a few hours. I have tried haskell on-and-off since 2005 and always ended up frustrated as the development time took too long, as I did not understand the concepts fully and would have to keep going back to the reference/tutorial
15:51:29 <joe___> I was at the same spot more than a few times today and the suggestions in the irc
15:51:44 <joe___> helped me out of my issues within minutes of my encountering them.
15:52:20 <blackh> joe__: It took me about six months before I could write Haskell code faster than I could write any other language
15:52:23 <joe___> this irc is superb. Good job with what u are doing.
15:52:28 <kmc> :) glad we could help
15:52:42 <Phyx-> @type readIntOffAddr#
15:52:43 <lambdabot> Not in scope: `readIntOffAddr#'
15:52:55 <IceDane> So - groupBy with a fold, is that even possible?
15:52:57 <Phyx-> @hoogle readIntOffAddr#
15:52:57 <lambdabot> No results found
15:53:00 <IceDane> Don't hand me the answer :P
15:53:04 <IceDane> It's an exercise from RWH
15:53:51 <FunctorSalad> are implicit params really irredeemably evil?
15:54:11 <FunctorSalad> yes it's dynamic scope but it's tracked by the type system
15:54:12 <blackh> joe___: I'm really glad you're finding #haskell helpful, and I hope you enjoy learning!
15:54:21 <kmc> IceDane, sure... think about what the accumulator has to store
15:54:33 <FunctorSalad> and Reader seems overkill if you need no other monadicity
15:54:35 <kmc> you're walking through the list, keeping a running accumulator value which you update every time you see a new element
15:54:49 <joe___> blackh, thanks
15:54:55 <IceDane> Ah!
15:55:05 <kmc> that's just the definition of a fold
15:55:06 <Peaker> FunctorSalad, I see them as namespace violators (who's to say that name means the same thing in a completely different lexical environment), as well as contributing very little
15:55:08 <kmc> but it should get you started
15:55:31 <kmc> we could redefine typeclasses in terms of implicit parameters
15:55:32 <IceDane> kmc: Thanks - folds are really making by brain churn, but I still love it
15:55:36 <kmc> then i think everyone would agree on keeping them :)
15:55:46 <kmc> IceDane, did you see Cale's fold diagrams at: http://cale.yi.org/index.php/Fold_Diagrams
15:56:11 <kmc> IceDane, foldr is the simplest:  "foldr f z" replaces [] with z and (:) with f
15:56:22 <FunctorSalad> Peaker: hmm I don't even know whether they're qualified
15:56:34 <IceDane> I didn't, no, but I'll check them out
15:56:53 <FunctorSalad> Peaker: well, you'd use more descriptive names than `x' for IPs ;)
15:57:26 <IceDane> those look pretty cool
15:57:56 <FunctorSalad> Peaker: (and I was thinking more of non-library-exposed uses)
15:58:33 <FunctorSalad> an extension of lexical scope that doesn't force you to put everything in one decl, making it non-ghci-typeable ;)
15:58:39 <joe___> is there a better way of doing the below:
15:58:41 <joe___>                   Prelude.putStr "word: "
15:58:42 <joe___>                   Prelude.putStrLn x
15:58:57 <joe___> i want "word: " ++ x
15:59:01 <joe___> as output
15:59:07 <kmc> joe___, then you could putStrLn t hat
15:59:09 <kmc> that*
15:59:14 <lament> Prelude.putStrLn ("word: " ++ x)
15:59:24 <kmc> the two calls will actually be a little more efficient
15:59:27 <lament> (insert a flamewar about $)
15:59:28 <joe___> ok, thanks, stupid question.
15:59:37 <kmc> joe___, why are you qualifying "Prelude."?
15:59:53 <FunctorSalad> printf "word: %s" x
16:00:05 <joe___> i have a call to "                  Data.ByteString.putStrLn datastack
16:00:16 <lament> :t prinf
16:00:17 <lambdabot> Not in scope: `prinf'
16:00:17 <lament> :t printf
16:00:19 <lambdabot> forall r. (PrintfType r) => String -> r
16:00:19 <FunctorSalad> putStrLn $ $(printf "word: %s") x -- <-- better
16:00:26 <joe___> and datastack is the output from a function that returns "IO ByteString"
16:00:29 <lament> FunctorSalad: jesus christ!
16:00:37 <kmc> joe___, a typical solution would be to "import qualified Data.ByteString as B"
16:00:45 <kmc> then use "B.putStrLn" for bytestring and "putStrLn" otherwise
16:00:59 <joe___> ok, thanks. that sounds simpler
16:01:06 <kmc> you can also drop "qualified", in which case you'll only use B to qualify when there's a conflict
16:01:19 <kmc> similarly "import Prelude as P" will let you disambiguate with "P.".  you probably don't want "qualified" there
16:03:01 <joe___> thanks, the qualified helped
16:03:21 <gOcOOl> can one specify a ByteString to printf without unpacking?
16:04:14 <Vulpyne> You could use Show. :)
16:05:06 <IceDane> kmc: Is it a bad way to think about folds as follows: They type I want it to return should be the type of the accumulator? E.g., the accumulator can only be a list of lists if I want to return that
16:05:15 <gOcOOl> I've been told time and again calls like pack, unpack, read, show etc are very slow and I'd like to be able to print a pair of (ByteString, Int) in the most efficient way possible
16:05:34 <kmc> :t foldr
16:05:35 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:06:02 <kmc> IceDane, "b" there is the accumulator
16:06:06 <IceDane> Yeah
16:06:09 <Vulpyne> gOcOOl: ByteString has its own output functions.
16:06:10 <kmc> so that's a correct statement
16:06:10 <gOcOOl> ofcourse i could call 'print' on the pair but I'd like to avoid those Chunk, Empty markers on a bytestring
16:06:19 <IceDane> good good
16:07:07 <gOcOOl> Vulpyne: but I'm dealing with a pair (ByteString, Int), not just bytestrings
16:07:33 <Vulpyne> I doubt printf "%d" 123 is faster than putStr (show 123)
16:08:21 <Phyx-> what is this line saying "n <- getArgs = readIO . head
16:08:22 <Phyx-> "
16:08:23 <Vulpyne> But you could do: B.putStrLn (fst yourtuple); print (snd yourtuple)
16:08:31 <Phyx-> it's odd that there's an = in there
16:08:37 <kmc> Phyx-, context?
16:09:04 <Phyx-> kmc: http://www.haskell.org/haskellwiki/Performance/GHC
16:09:10 <joe___> FunctorSalad, would u recommend printf vs putStr alone with a ++
16:09:34 <joe___> both work, but want to know if there is a deeper reasoning behind the rationale
16:09:38 <Phyx-> kmc: section 8
16:10:01 <tromp_> that's a typo
16:10:06 <kmc> joe___, note that (++) has to traverse its left argument
16:10:10 <FunctorSalad> joe___: well, printf could become useful for longer expressions
16:10:12 <kmc> it's a slow way to glue strings together
16:10:23 <gOcOOl> Vulpyne: yes, that is true. lemme give that a shot real quick
16:10:33 <tromp_> = should be >>=
16:10:34 <ksf> does hPutBuf use non-blocking IO?
16:10:35 <Vulpyne> gOcOOl: It's less convenient than printf, but...
16:10:42 <kmc> which is why the prelude defines show in terms of shows
16:10:43 <kmc> :t shows
16:10:45 <lambdabot> forall a. (Show a) => a -> String -> String
16:10:51 <Phyx-> tromp_: ah, ok, which makes much more sense, heheh
16:10:52 <Phyx-> thanks
16:11:00 <gOcOOl> Vulpyne: does printf even have a facility to print bytestrings?
16:11:02 <kmc> Data.Sequence has fast concatencation
16:11:14 <Vulpyne> gOcOOl: Not as far as I am aware of.
16:11:20 <kmc> there was something specifically for fast string concat (besides just String -> String) but i forgot the name
16:11:21 <gOcOOl> Vulpyne: ah ok
16:11:55 <Vulpyne> DLists?
16:12:11 <kmc> that's it
16:12:27 <kmc> DList and DString
16:12:52 <Phyx-> tromp_: if you look down also, i don't understand how the case expression could work, k and n are both just numbers, so "k n" shouldn't be possible
16:13:01 <Phyx-> in the definition of loop
16:13:29 <tromp_> i dont see k n
16:13:35 <Vulpyne> It looks like there's a character missing.
16:13:37 <tromp_> i see loop (k+1) n
16:13:50 <ben0x539> I am guessing all > and < disappeared
16:13:56 <Phyx-> ah ok
16:13:58 <ben0x539> since, you know, html
16:14:06 <ben0x539> That would make the = readIO . head into a >>=
16:14:08 <Phyx-> tromp_: in de definition of loop itself
16:14:20 <tromp_> oh, in the guard
16:14:22 <kmc> damn html
16:14:26 <Phyx-> ben0x539: yeah, that would make sense, someone forgot to escape them
16:14:33 <tromp_> yes, < or > missing there
16:15:05 <Phyx-> let's see if i remember my wiki password
16:15:06 <Phyx-> lol
16:15:32 <tromp_> they're not there in html sourece either
16:15:47 <tromp_> got lost in prior step
16:15:48 <joe___> if i put my small program on pastebin, would u be willing to comment on what could be done better?
16:16:03 <Phyx-> tromp_: they might be there in the wiki formatting itself
16:16:15 <joe___> just want some expert comments on>.
16:18:23 <WoollyWombat> Hi. I'm very new to functional programming, would like some help with understanding recursion.
16:18:40 <Phyx-> tromp_: nope, they're all gone, :(
16:18:40 <WoollyWombat> Got this f# code http://pastebin.com/m8040a76
16:18:51 <ainirtnec> WoollyWombat, here is the definition of recursion: recursion (n). See recursion.
16:18:57 <WoollyWombat> hehe
16:19:12 <joe___> http://pastebin.com/m682053b4
16:19:23 <bwr> Hi, I must be doing something stupid, but I am not sure what it is. I am trying to load a glade file using Gtk2Hs. I am using xmlNew "file.glade". I have checked to make sure that the file name is correct. I am running the program from the same directory as the glade file, however it can't find the file.
16:19:39 <joe___> there are 3 functionsa that I created and all 3 of them have "do"
16:19:53 <ainirtnec> WoollyWombat, what do you not understand?
16:19:58 <joe___> that got me worried that I was not thinking "haskell"-like
16:20:01 <Phyx-> ah found tjem
16:20:07 <Phyx-> let me fix the entry
16:20:12 <kmc> joe___, "main" is not a function
16:20:13 <joe___> and hence would appreciate if u can provide some feedback.
16:20:30 <kmc> but... you're doing USB access.  i'd expect it's very IO-ful
16:20:33 <joe___> kmc, yes
16:21:26 <sm> g'day all. Which is the best lib on hackage providing a safe versions of read etc ?
16:21:27 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
16:21:28 <kmc> joe___, the defn of idenitfydevice is very far from its use site
16:21:30 <kmc> and it's a small function
16:21:44 <kmc> i'd define it using a "let" block inside the do, right before it's used
16:21:50 <WoollyWombat> ainirtnec: I don't get in which order stuff happens on the last row ( | head::tail -> maxNr head (maxElement tail) )
16:21:52 <joe___> ok.
16:22:00 <tommd> joe__: putStrLn $ printf ...  -- not needed
16:22:03 <WoollyWombat>  -say i have a list with 1,2,3. -what would the function calls to maxNr look like? which numbers would it compare first?
16:22:14 <tommd> joe__: just do: printf "format string" args
16:22:29 <kmc> WoollyWombat, part of the idea of purely-functional programming is that you don't worry about what happens "first"
16:22:37 <kmc> because the result should not depend on execution order
16:22:40 <kmc> that said, let's take a look
16:22:48 <joe___> tommd, thanks.
16:23:08 <Gwern-away> let the implementation worry about execution order, just like memory managemen
16:23:10 <clarkb> tommd does exist
16:23:14 <kmc> WoollyWombat, so you call maxElement [1,2,3].  it matches the third clause, with head = 1 and tail = [2,3]
16:23:17 <tommd> > printf "Does lambdabot have printf? %s\n" "yes!"
16:23:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:23:18 <lambdabot>    `GHC.Show.Show a'
16:23:18 <lambdabot>      a...
16:23:26 <tommd> clarkb: Yes, I do.
16:23:29 <clarkb> :)
16:23:35 <dcoutts> bwr: do you mean the current directory contains the .glade file, or the dir containing the executable, or both?
16:23:36 <kmc> so the body is effectively (maxNr
16:23:37 <kmc> err
16:23:46 <kmc> so the body is effectively (maxNr 1 (maxElement [2,3]))
16:23:50 <tommd> clarkb: Doing your project in Haskell?
16:24:05 <clarkb> I plan to
16:24:13 <WoollyWombat> kmc: yep, i get that
16:24:13 <bwr> dcoutts: the current directory contains all of the files including the .glade file
16:24:13 <ksf> > foldr max [1..10]
16:24:14 <lambdabot>   []->
16:24:14 <lambdabot>    [1,2,3,4,5,6,7,8,9,10]
16:24:14 <lambdabot>  [[]]->
16:24:14 <lambdabot>    [1,2,3,4,5,6,7,8,9,10]
16:24:14 <lambdabot>  [[],[]]->...
16:24:15 <kmc> now the question of what is evaluated "next" is actually different in F# and Haskell
16:24:20 <kmc> because Haskell is lazy and F# is strict
16:24:22 <ksf> > foldr max [1..10] 0
16:24:22 <lambdabot>   No instance for (GHC.Num.Num [[t]])
16:24:22 <lambdabot>    arising from the literal `0' at <int...
16:24:27 <ksf> > foldr max 0 [1..10]
16:24:28 <lambdabot>   10
16:24:34 <kmc> but it shouldn't influence the results anyway
16:24:54 <ksf> > foldl max 0 [1..10]
16:24:55 <lambdabot>   10
16:24:55 <joe___> kmc, just trying out the let option
16:25:13 <joe___> kmc, can I have the type definition in a let block
16:25:15 <clarkb> tommd: it will be a wonderful learning experience I'm sure
16:25:17 <kmc> yup
16:25:22 <kmc> let f :: Foo; f = bar
16:25:30 <kmc> or replace the semicolon with a newline and sufficient indentation
16:25:36 <sm> http://hackage.haskell.org/package/safe I think
16:26:54 <kmc> joe___, you could also write it "in-line" as (liftM ((== (0,1,0,1)) . deviceReleaseNumber) . getDevice)
16:26:56 <kmc> i think
16:27:03 <kmc> up to you whether that's more readable
16:27:03 <tommd> clarkb: Absolutely.  And don't forget to leverage Hackage.  It can save tons of time.
16:27:12 <clarkb> tommd: ya
16:27:25 <joe___> liftM is cool
16:27:34 <kmc> :t liftM
16:27:36 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:27:36 <kmc> :t fmap
16:27:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:27:40 <kmc> :t (<$>)
16:27:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:28:41 <Peaker> @type liftA0
16:28:42 <lambdabot> Not in scope: `liftA0'
16:28:51 <Peaker> @let liftA0 = pure ; liftA1 = fmap
16:28:52 <lambdabot>  Defined.
16:29:02 <Peaker> @type liftA0
16:29:03 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:29:09 <Peaker> @type liftA1
16:29:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:29:13 <Peaker> @type liftA2
16:29:14 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:29:28 <Peaker> this really hints that "pure" is in the wrong type-class
16:29:38 <Peaker> (Missing the Pointed super-class)
16:31:19 <WoollyWombat> kmc: after the statement << maxNr 1 (maxElement [2,3]) >>, as far as i understand, it will call maxElement again, and the last line would then be << maxNr2 (maxElement [3]) >> after which it would call the maxElement again with 3 as the argument. This would cause the second case to happen, which would return the 3. But after that i'm lost
16:31:23 * byorgey suddenly wonders if there is some category in which Pointed means you have a terminal object and Applicative means you have binary products.
16:31:50 <kmc> those are expressions, not statements
16:32:00 <iaefai> I am trying to quickly get some datatypes so they can be encoded in JSON to be sent to a webpage, but it looks difficult to implement the instances of data definitions. I have also noticed the 2 of 4 methods are implemented in the typeclass, http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/src/Text-JSON.html#JSON  and was wondering if I have to implement those too
16:32:09 <kmc> WoollyWombat, you have to remember the whole expression you're building up
16:32:33 <kmc> under at least some evaluation order, you end up with (maxNr 1 (maxNr 2 3))
16:33:25 <kmc> this is not tail-recursion; after the innermost recursive call completes, you still have work remaining in the functions that called it
16:33:28 <Saizan> iaefai: you don't have to unless you want a different definition
16:33:42 <iaefai> Saizan: ok, that makes it easier
16:33:50 <kmc> in this case, you'd reduce (maxNr 2 3) to 3, then you have (maxNr 1 3), which reduces to 3
16:35:04 <bwr> dcoutts: sorry, I figured it out. I think the glade file was GtkBuilder
16:35:36 <joe___> kmc, I could not get  (liftM ((== (0,1,0,1)) . deviceReleaseNumber) . getDevice)
16:35:42 <joe___> to work
16:35:46 <kmc> maybe i made an error
16:35:54 <iaefai> If I have a third data type that depends on two others that already defined and implementing JSON, is there a shortcut to implementing it in the third class?
16:35:56 <joe___> Prelude System.USB Control.Monad>  (liftM ((== (0,1,0,1)) . deviceReleaseNumber) . getDeviceDesc devices)
16:35:59 <joe___> <interactive>:1:62:
16:36:02 <joe___>     Couldn't match expected type `Device'
16:36:04 <joe___>            against inferred type `[Device]'
16:36:07 <joe___>     In the first argument of `getDeviceDesc', namely `devices'
16:36:10 <joe___>     In the second argument of `(.)', namely `getDeviceDesc devices'
16:36:12 <joe___>     In the expression:
16:36:15 <joe___>         (liftM ((== (0, 1, 0, 1)) . deviceReleaseNumber)
16:36:17 <joe___>        . getDeviceDesc devices)
16:36:19 <kmc> please doen't paste that much here
16:36:25 <joe___> kmc, sorry.
16:36:26 <kmc> you can hpaste an error, too
16:36:36 <joe___> oh, ok
16:36:42 <mauke> joe___: looks like the error can be simplified to 'getDeviceDesc devices'
16:36:59 <WoollyWombat> kmc: What do you mean by 'reduces'? is that the return value that maxNr produces?
16:37:12 <kmc> WoollyWombat, yes
16:37:34 <WoollyWombat> ah ok. then i get it
16:37:49 <jlouis> I believe the "reduces" wording stems from the lambda calculus where one term might reduce to another (not necessarily smaller) term
16:37:56 <kmc> in pure functional programming we describe the entire program behavior by a single rule named "beta-reduction"
16:39:49 <kmc> beta-reduction says that ((λx. a) b) reduces to a[x := b], meaning "a with every free occurrence of variable x replaced with b"
16:40:22 <kmc> on top of that we have a sort of "meta-rule" that tells us, when several such reductions are possible in a larger expression, which one we take
16:40:24 <joe___> mauke, thanks
16:41:12 <WoollyWombat> ah, ok
16:41:52 <WoollyWombat> but i haven't quite got my head around that code yet. what about the call << maxNr 1 2 >>. would that never occur?
16:42:12 <kmc> (maxNr 1 (maxNr 2 3))
16:42:15 <kmc> (maxNr 1 3)
16:42:16 <kmc> 3
16:42:50 <WoollyWombat> Aaah
16:43:00 <joe___> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12255#a12255
16:43:12 <joe___> am getting an error with the return in the let statement
16:43:34 <mauke> joe___: wow, your indentation is seriously weird
16:43:52 <aep> hi.  are there any still mainained ncurses bindings?
16:43:53 <joe___> ok, will change the indentation and give it a shot. thanks
16:44:04 <aep> *maintained
16:44:20 <aep> hscurses is pretty deadish and the example don't work
16:44:36 <kmc> joe___, space "let" back to be in line with "devices <- "
16:45:16 <joe___> kmc, that did the trick
16:45:22 <mauke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12255#a12256
16:45:25 <joe___> thanks guys
16:45:48 <WoollyWombat> kmc: thanks alot for the help!
16:45:52 <kmc> no problem :)
16:46:06 <joe___> mauke, thanks.
16:46:57 <kmc> i'm not sure i'd even put a signature on identifydevice
16:48:18 <joe___> kmc, sorry I chickened out with the liftM statement that u recommended
16:48:24 <joe___> I could not get the hang of it.
16:49:09 <kmc> it was a bit excessive tbh
16:49:28 <kmc> there's this delicate balance of, you shouldn't name a function when the function body is itself a better name
16:49:35 <kmc> but that's probably not the case here
16:50:02 <kmc> but "filter (< 0)" is a better name for that function than any name you could give it
16:50:26 <kmc> (for (filter (<0)) i mean)
16:51:26 <joe___> kmc, is this meant to me?
16:51:38 <joe___> the filter (<0) stuff
16:51:41 <kmc> just talking out loud
16:51:49 <kmc> but it was relevant to the issue of your helper function
16:52:21 <dcoutts> bwr: ah, that'd explain it
16:52:52 <Peaker> kmc, do we need "concatMap"?
16:53:01 <kmc> @src concatMap
16:53:02 <lambdabot> concatMap f = foldr ((++) . f) []
16:53:10 <Peaker> well that's not necessary any more
16:53:14 <sohum> @pl \x -> x 1 qn ()
16:53:15 <lambdabot> flip (flip ($ 1) qn) ()
16:53:15 <Peaker> concatMap f = concat . map f
16:53:19 <sohum> ew.
16:53:30 <kmc> i'm pretty ambivalent about that
16:53:52 <kmc> @pl \f -> concat . map f
16:53:52 <lambdabot> (=<<)
16:53:56 <kmc> :O
16:54:05 <Peaker> @unpl ($()).($qn).($1)
16:54:05 <lambdabot> (\ f -> f 1 qn (()))
16:54:47 <copumpkin> @pl \f -> konkat . mip f
16:54:47 <lambdabot> (konkat .) . mip
16:55:07 <joe___> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12255#a12257
16:55:18 <Peaker> kmc, I dislike "concatMap" -- if its abstracting anything, the abstraction is leaking in its name
16:55:28 <Peaker> kmc, and if it isn't, the implementation is better
16:55:42 <joe___> can I think about refactoring the filterM function to have the do in that function?
16:55:46 <kmc> Peaker, because the abstraction is (>>=)?
16:55:50 <joe___> or would it be over-engineering?
16:56:01 <Peaker> kmc, I didn't mean to involve >>=
16:56:14 <Peaker> kmc, Just the lack of need to name "concat . map f" "concatMap f"
16:56:34 <Peaker> kmc, people use  mapM f   and not   sequence . map f   just for saving a couple of tokens, though the implementation is a better name
16:56:45 <kmc> yeah, it's true
16:56:52 <kmc> i guess raw readability has advantages too
16:58:16 <lament> no way
16:58:40 <lament> if god meant us to care about readability, he wouldn't have invented lisp
17:00:53 <monochrom> god didn't invent lisp.
17:01:12 <ivanm> he just pretends to use it whilst actually hacking everything together with perl? :p
17:01:13 <Valodim> well it sure didn't evolve from apes..
17:01:42 <Saizan> apes are fairly curly
17:01:54 <monochrom> readability depends on educational background
17:02:54 <monochrom> In practice, some people's "readability" means "readable by infants" and is completely unattainable.
17:03:14 <lament> in practice, people usually talk about comparative readability
17:03:29 <monochrom> What is comparative readability?
17:03:31 <lament> for example, concat . map vs. concatMap
17:03:39 <kmc> the relationship between readability and expressiveness is complicated
17:03:45 <dancor> lament: which of those is more readable
17:03:48 <monochrom> That still depends heavily on educational background.
17:04:25 <lament> dancor: to me, the former, but this seems like a particularly trivial issue that only a bunch of bored geeks on IRC would care to discuss :)
17:05:03 <dancor> glad i didn't bring it up ;-)
17:05:15 <MoALTz> [xxx | x <- [1..9], y <- takeWhile (\y -> xxx) [1..], xxx]  is roughly what i just did in a projecteuler solution to get shortcutting list comprehensions... (my actual solution is more ugliness)
17:05:35 <monochrom> I can see how to generalize this trivial example to larger examples. concatMapOrFGH vs concat . map <|> f . g . h ?
17:05:51 <MoALTz> i tried using undefined and fail "" abuse before this without success
17:05:57 <lament> monochrom: :(
17:07:11 <dancor> if i could just learn to program more readably, i'm sure i could finish my strong ai project in no time..
17:08:20 <ivanm> I just was a BBC headline of "LHC nears restart after repairs", and my immediate first thought was that Lemmih was about to do a release... >_>
17:08:34 <monochrom> lament: More seriously, http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
17:08:42 <ivanm> s/was/saw/
17:08:54 * ivanm was never a headline for BBC or any other company
17:09:43 <monochrom> George Russell complains about unreadability due to (1) too many functions used on one line (2) unfamiliar with library functions.
17:10:17 <monochrom> On (2), he forgets that his English writing uses unfamiliar words (too me anyway) and could be just as unreadable by his logic.
17:10:24 <monochrom> s/too/to/
17:10:43 <monochrom> And (1) is completely stupid and ample target for sarcasm.
17:11:01 <mmorrow> PeakerWork: GHC defines concatMap as "concatMap f = foldr ((++) . f) []"
17:11:16 * dancor is still looking for readability discussion without straw men
17:11:18 * mmorrow plays devils snackvocate
17:11:23 <Gwern-away> ivanm: really? when I read about the LHC, I'm thinking, 'how many interruptions did I decide would be evidence for anthropic effects?'
17:11:42 * ivanm doesn't get Gwern-away's reference...
17:11:52 <Gwern-away> 'There.  One comprehensible idea per line, one concept at a time. ' haha
17:11:56 <monochrom> This kind of opinion is why I come to conclude that readability depends on educational background, in fact I go as far as to think it is the sole factor.
17:12:05 <Gwern-away> ivanm: we can't observe the LHC sucessfully running if it destroys the world
17:12:17 <Philippa_> ...WTF? GHCi 6.10.4 is giving me ambiguous type variable errors when I use :t on a function that loaded fine
17:12:26 <Philippa_> it's almost as if it's applying the MR to :t :-(
17:12:40 <ivanm> Gwern-away: depends on if it destroys the world instantaniously or gradually
17:12:54 <ivanm> Philippa_: :o what's the function?
17:12:54 * mmorrow is hoping for a slow, painful death
17:13:00 <Gwern-away> not really. but most people don't take it seriously, it's just funny
17:13:38 <Philippa_> ivanm: part of a parser. Except it's two-stage, and the variable it's complaining about is the 'inner' monad (a state monad carrying an operator table, except most of the parsing functions don't touch it so don't have any constraints on the monad beyond it being one)
17:13:40 <ksf> I'm down to 0.8 times the speed of the C version
17:13:53 <ksf> but then, I'm stuck in off-by-one imperative land.
17:13:58 <ivanm> Philippa_: :s
17:14:06 <mmorrow> PeakerWork: it probably uses that def because (\f -> concat . map f) won't fuse though..
17:14:23 <mmorrow> (disclaimer: i have no idea if "concat . map f" would fuse)
17:14:30 <ivanm> mmorrow: I'm sure such a death could be arranged if you're so desirous of one... >_>
17:15:06 <mmorrow> ivanm: only if it involves blackholes, toothpicks, and lots of oompa-loopas!
17:15:16 <mmorrow> *loompas
17:15:17 <MoALTz> Philippa_: loaded fine == the source file loaded fine, or the function ran fine?
17:15:35 <Philippa_> source file loaded fine
17:15:42 <Philippa_> but as the error in question is a type error...
17:15:44 <ivanm> mmorrow: why the toothpicks?  I mean, I get the blackholes and oompa-loompas...
17:15:44 <ivanm> ;-)
17:15:54 <mmorrow> ivanm: for good measure.
17:16:01 <ivanm> fair enough
17:17:04 * Philippa_ isn't feeling awake enough to construct sensible test expressions for this function that fix the monad in question, it's late here and I want to just confirm that my code is okay and go to bed
17:18:02 <sjanssen> Philippa_: GHCI is erroring on ":t qname"?
17:18:55 <gOcOOl> @src (++)
17:18:55 <lambdabot> []     ++ ys = ys
17:18:56 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:18:56 <lambdabot> -- OR
17:18:56 <lambdabot> xs ++ ys = foldr (:) ys xs
17:19:25 <Philippa_> sjanssen: right
17:19:42 <Philippa_> ("constructor", as it happens, but same diff)
17:20:08 <Philippa_> the only reason I'm not WTFing out loud is my housemate's probably trying to sleep
17:20:40 <sjanssen> Philippa_: is it a GADT?
17:21:29 <Philippa_> sjanssen: nope
17:21:51 <Philippa_> and I can't see how that'd excuse erroring on :t but not on load, either
17:22:07 <Philippa_> I just want to know the type it inferred for the function!
17:22:50 <sjanssen> Philippa_: no excuse, but in my mind GADTs are more likely to have random bugs in the type checker
17:23:09 <ivanm> sjanssen: because they're still pretty new?
17:23:33 <sjanssen> ivanm: and complicated, and seem to have plenty of weird bugs
17:24:23 <bwr> I am trying to use opengl in a GtkDrawingArea loaded from a glade file. I am having some problems. Does anyone know if there is a tutorial using gtk2hs, glade, and opengl? I haven't been able to find one
17:25:18 <Philippa_> sjanssen: I have my own suspicion as to where this one came from
17:33:40 <dave__> I'm after some help.  I have functions of the form (f1::a->IO b), and (f2::a->b->IO c).  I want to wrap these, eg.  wrap_f1 a = do {pre_action; x<-f1 a; post_action; return x}, and wrap_f2 a b = do {pre_action; x <- f2 a b; post_action2; return x}.   Is it possible to write a generic 'wrap_fn' function?
17:34:21 <ivanm> dave__: only if you passed f2 around with an initial value already provided
17:34:33 <ivanm> i.e. wrap_fn (f2 a)
17:34:44 <dave__> Ahh, ok
17:34:50 <ivanm> you can't write one (without using funkiness like in printf) that takes an arbitrary argument
17:35:14 * hackagebot upload: hspresent 0.2.2 - A terminal presentation tool (EvanKlitzke)
17:35:19 <dave__> alternatively I could make then uncurried?
17:35:29 <dave__> (or curried, whichever means taking tupes?)
17:35:51 <kmc> yes, then they'd each take only one argument
17:36:00 <kmc> the thing is, there's no reason to delay application of the arguments
17:36:05 <kmc> this is the magic of purity and monads
17:36:20 <kmc> you might as well just say "wrap (f2 a b)"
17:36:41 <kmc> wrap (f4 a b c d)
17:36:49 <ivanm> until you get to main, the IO action is never going to be evaluated
17:36:55 <kmc> if your IO action has no arguments, "wrap x"
17:36:57 <ivanm> you've just constructed it
17:37:00 <kmc> (i don't call it f0, because it's not a function)
17:37:11 <kmc> @hoogle IO a -> IO a
17:37:12 <lambdabot> Network withSocketsDo :: IO a -> IO a
17:37:12 <lambdabot> Control.Exception block :: IO a -> IO a
17:37:12 <lambdabot> Control.OldException block :: IO a -> IO a
17:37:41 <dave__> that makes sense.  But I'm actually using the xmlrpc library, which does some magic (to me anyway) to turn a function into what it calls an XmlRpcMethod
17:38:04 <kmc> haxr?
17:38:22 <monochrom> @src bracket
17:38:22 <lambdabot> bracket before after thing = block $ do
17:38:22 <lambdabot>     a <- before
17:38:22 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
17:38:22 <lambdabot>     after a
17:38:22 <lambdabot>     return r
17:38:37 <monochrom> is an example of what kmc says.
17:38:39 <dave__> right, haxr
17:38:43 <Philippa_> sjanssen: oh lovely. So, I'd been running 6.10.3, tried 6.10.4 out of paranoia and got a fresh type error on load. One that looks well-founded
17:38:45 <kmc> :t bracket
17:38:46 <lambdabot> Not in scope: `bracket'
17:38:54 <kmc> erm
17:39:03 <monochrom> Something like Control.Exception.bracket
17:39:25 <dave__> yes, bracket does what I want but I have several functions and would like to apply bracket to them
17:39:39 <ivanm> dave__: "Any sufficiently advanced technology is indistinguishable from magic."; Arthur C. Clarke ;-)
17:39:40 <dave__> as I turn them into XmlRpcMethod
17:39:45 <dave__> :)
17:39:56 <kmc> dave__, the wrapping isn't magic.  XmlRpcMethod is a synonym for (MethodCall -> ServerResult, Signature)
17:40:14 <kmc> "fun" is somewhat magical though
17:40:51 <ivanm> kmc: yeah, I don't get this "fun" business...
17:40:58 <dave__> So there is no easy way to make "fun" more magical and combine it with "bracket"?
17:41:00 <ivanm> it seems just about everyone is able to have some "fun"...
17:41:01 <ivanm> ;-)
17:41:02 <kmc> it uses the (internally defined) typeclass XmlRpcFun in order to accept functions with different signatures
17:42:11 <kmc> dave__, you could do it by modifying the typeclass
17:42:24 <kmc> or by building your own XmlRpcMethod pairs
17:42:25 <sohum> @pl \x -> x ()
17:42:26 <lambdabot> ($ ())
17:43:37 <dave__> @kmc Which would mean a new typeclass which did "pre_action" and "post_action" in the XmlRpcFun (IO a) instance?
17:43:38 <lambdabot> Maybe you meant: ghc rc src
17:44:14 <kmc> i think so
17:44:23 <kmc> without having thoroughly read the code
17:44:38 * kmc is not cool enough to have his own lambdabot command :/
17:44:38 <lispy|web> Has anyone else noticed that C-p doesn't work in ghci these days?
17:44:44 <lispy|web> Is there a way to re-enable it?
17:44:49 <kmc> what did it do?
17:44:53 <lispy|web> ?kmc
17:44:54 <lambdabot> Maybe you meant: ghc rc src
17:45:01 <lispy|web> kmc: previous line
17:45:07 <dave__> @kmc thanks, at least that stops me banging my head for a while...
17:45:07 <lambdabot> Maybe you meant: ghc rc src
17:45:08 <kmc> @protontorpedo
17:45:09 <lambdabot> hu me/
17:45:09 <lispy|web> kmc: it's like pressing the up arrow
17:45:19 <lispy|web> ?keal
17:45:19 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
17:45:21 <kmc> IRC != twitter
17:45:24 <kmc> @protontorpedo
17:45:25 <lambdabot> i have a win xp box
17:45:37 <kmc> @. elite nixon
17:45:37 <lambdabot> do YOu Kn0w \/\/hA+ HaPpEN3D 70 +he r0/\/\4Ns? +|-|e LAst sIx rO/\/\4N EMpERORz W3Re FAgz. . . . YOU KnoW w|-|4+ HApPEneD +O The p0p3S? I7'5 ALL RiG|-|T tH4T P0PES W3RE LAYIn9 7HE Nuns.
17:46:02 <kmc> that one works particularly well
17:46:23 <copumpkin> very profound
17:46:53 <lispy|web> I looked at the editline man page and C-p is supported, so I suspect this is a ghci flaw
17:47:11 <Saizan_> lispy|web: ghci is no longer using editline
17:47:22 <kmc> doesn't it use haskeline now?
17:47:22 <Saizan_> lispy|web: look at haskeline's trac wiki
17:47:36 <lispy|web> Saizan_: oh, it's using haskeline?
17:47:45 <lispy|web> ?where haskeline
17:47:46 <lambdabot> I know nothing about haskeline.
17:47:51 <lispy|web> ?where haskelline
17:47:51 <lambdabot> I know nothing about haskelline.
17:47:58 <kmc> @hackage haskeline
17:47:58 <lambdabot> http://hackage.haskell.org/package/haskeline
17:47:59 <Saizan_> ?hackage haskeline
17:47:59 <lambdabot> http://hackage.haskell.org/package/haskeline
17:48:11 <kmc> @hackage plugin-not-as-useful-as-you-think
17:48:11 <lambdabot> http://hackage.haskell.org/package/plugin-not-as-useful-as-you-think
17:48:44 <kmc> http://trac.haskell.org/haskeline
17:49:25 <alxv> lispy|web: http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
17:49:25 <lispy|web> I think this is the document I need: http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
17:49:27 <lispy|web> trying it now
17:49:39 <alxv> ah, too quick :-)
17:50:26 <alxv> lispy|web: thank you for asking this question, BTW. I was looking how to fix this as well.
17:52:41 <lispy|web> Yeah, this is wonderful
17:52:42 <lispy|web> It works
17:52:46 <lispy|web> yay!
17:54:05 <FunctorSalad> whoa qthaskell is compiling 640 modules now
17:54:23 <jlouis> lispy|web: you know... when it compiles, it works
17:55:19 <lispy|web> jlouis: heh, in this case I'm referring to setting a config in ~/.haskeline :)
17:55:37 <jlouis> I really did a Knuth the other day: Built an operational semantics, proved meta-theoretic properties in Twelf... turned out the semantics had no valid program :)
17:57:05 <sohum> @pl \a b -> f (g a b)
17:57:06 <lambdabot> (f .) . g
18:15:47 <kmc> @pl \a b c -> f a (g b c)
18:15:47 <lambdabot> (. g) . (.) . f
18:19:49 <ksf> the IO system should do a best effort to check whether some handle is /dev/null and then be adequately lazy
18:21:07 <ksf> @let fgab = (f .) . g
18:21:08 <lambdabot>  Defined.
18:21:21 <kmc> > fgab
18:21:22 <lambdabot>   No instance for (GHC.Show.Show (f1 (f b)))
18:21:22 <lambdabot>    arising from a use of `M63918...
18:21:25 <ksf> @let fagbc = (. g) . (.) . f
18:21:26 <lambdabot>  Defined.
18:21:51 <kmc> > fgab x y
18:21:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:21:52 <lambdabot>    `GHC.Show.Show a'
18:21:52 <lambdabot>      a...
18:22:09 <ksf> uh well those should be free in f and g
18:22:27 <ksf> @let fgab f g = (f .) . g
18:22:28 <lambdabot>  <local>:5:0:
18:22:28 <lambdabot>      Multiple declarations of `L.fgab'
18:22:28 <lambdabot>      Declared at: <local...
18:22:55 <ksf> @pl \f g a b c -> f a (g b c)
18:22:55 <lambdabot> flip . (((.) . (.)) .)
18:23:26 <kmc> is there a writeup somewhere of how @pl works?
18:23:27 <ksf> we can make a library of those and follow the caaddadaadadaddadaaddaar craze
18:24:56 <BMeph> kmc: Ask augustss. He's the one who wrote it. :)
18:27:11 <kmc> how old is this channel?
18:27:23 <jlouis> kmc: old
18:27:35 <jlouis> kmc: I was a participant around 2002 I think
18:27:41 <jlouis> Perhaps 2003
18:34:04 <ksf> having that /dev/null checking work transparently for any combination of pipes and apps makes for an interesting OS design
18:54:59 <IceDane> How the hell am I supposed to understand this:  Occurs check: cannot construct the infinite type: a = [[a]]
18:55:02 <IceDane> ?
18:55:42 <lpsmith> IceDane:   What happens if a = [[a]] and then you substitute for the a on the right?
18:56:29 <IceDane> Alright, I see, but I'm not sure where this is caused in my code.. heh
18:57:52 <lpsmith> a couple suggestions:  write down explicit types,  and GHC will produce better error messages
18:57:54 <monochrom> an example is "f ((x:_):_) = f x
18:58:16 <lpsmith> replace parts of your code with undefined until it type checks
18:58:23 <monochrom> > let f ((x:_):_) = x in "hi"
18:58:23 <kmc> IceDane, can you paste the problematic code?
18:58:24 <lambdabot>   "hi"
18:58:30 <monochrom> > let f ((x:_):_) = f x in "hi"
18:58:31 <lambdabot>   Occurs check: cannot construct the infinite type: t = [[t]]
18:58:31 <IceDane> Sure, thanks
18:58:38 <lpsmith> or,  if the code is short enough,  rewrite it :-P
18:59:32 <kmc> it's really just a different sort of type-mismatch error
18:59:42 <IceDane> http://pastebin.com/f4dd2bcbb
18:59:53 <kmc> @where hpaste
18:59:54 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
19:00:27 <IceDane> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12260#a12260
19:00:37 <kmc> thanks
19:00:41 <IceDane> I know the function isn't .. complete yet
19:00:44 <kmc> it's more readable there, not a big deal though
19:00:46 <IceDane> It doesn't do what it's supposed to
19:00:59 <kmc> try adding sigs for pred and getItem
19:01:04 <IceDane> But that's what i'm figuring out(that's the exercise, but this error is blocking my way)
19:01:26 <lpsmith> > :t foldr
19:01:27 <lambdabot>   <no location info>: parse error on input `:'
19:01:32 <lpsmith> :t foldr
19:01:33 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:01:48 <lpsmith> so pred must have type  a -> b -> b for some a and b
19:02:31 <lpsmith> but you have   pred x y = if f x y then ... else ...
19:02:52 <lpsmith> and you've (correctly) specified that f has type a -> a -> Bool
19:03:05 <monochrom> f :: a -> a -> Bool  and  f :: a -> [[a]] -> Bool, contradiction.
19:03:15 <IceDane> I see
19:03:19 <bwr> I am trying to get opengl working within a gtk2hs gui loaded from glade. I have this working sort of, however opengl is rendering very oddly. Can someone please take a look? http://github.com/bwr/blockcomposer/blob/master/mapEditor/BlockComposerMapEditor.hs I took a lot of the opengl code from http://cvs.haskell.org/darcs/gtk2hs/demo/opengl/RotatingCube.hs to get something drawing
19:03:52 <joe___> is there a quick way to hpaste a .hs file?
19:04:03 <joe___> in linux/xmonad/debian
19:04:06 <lpsmith> well, monochrom skipped a few steps there,  but yeah
19:04:39 <joe___> copy and paste from xterm is not that smooth and I use vim/xterm as my dev env.
19:05:22 <BMeph> IceDane: Also, your getItem will fail to match [[]]. Apparently, the occurs check is stopping it befoe that point. :)
19:05:24 <lpsmith> why not use gvim?
19:05:33 <IceDane> BMeph: thanks :P
19:05:35 <IceDane> I'll try again
19:05:35 <BMeph> *befoRe
19:06:29 <joe___> have everything set up on xterm (fonts, colors, etc)
19:07:30 <bwr> you can probably put a file into the pastebuffer programmatically and then paste it in hpaste. That would be a bit hackish though :P
19:07:45 <lpsmith> I haven't looked at the hpaste interface, but surely it isn't that hard.... you could probably just do something with wget
19:08:59 <kmc> http://hackage.haskell.org/package/PastePipe
19:09:02 <BMeph> IceDane: But yeah, monochrom is closer to the first problem: pred :: (a -> [[a]] -> [[a]]) has to be true for the use of foldr to work out. :)
19:09:22 <IceDane> I see
19:10:30 <kmc> it's broken though
19:11:15 <joe___> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12261#a12263
19:11:59 <kmc> http://hackage.haskell.org/package/haste another one
19:12:02 <monochrom> is x String or Data.ByteString.Internal.ByteString ?
19:12:17 <joe___> kmc, thanks pasetpipe helps.
19:13:05 <joe___> will give them both a shot.
19:13:11 <joe___> x is a string
19:13:24 <joe___> and the argument type is a ByteString
19:13:38 <monochrom> writeControl wants x::ByteString but parse says x::String
19:14:07 <kmc> haste works for me
19:14:19 <joe___> donot bother
19:14:46 <joe___> how can I import both instances and a particular function
19:14:57 <monochrom> You know, perl monks think that "f :: Int -> (); f x = if x then () else ()" will magically work out.
19:14:58 <joe___> I did the below, but am wondering if there is a simpler way
19:15:18 <joe___> -- the below line will not produce the IsString instance error
19:15:18 <joe___> import Data.ByteString.Char8 () -- 17:43 < Jedai> joe___: use "import Data.ByteString.Char8 ()" it will only import instances and nothing else
19:15:21 <joe___> import Data.ByteString.Char8 (pack) -- 17:43 < Jedai> joe___: use "import Data.ByteString.Char8 ()" it will only import instances and nothing else
19:16:06 <joe___>                   writeControl mydevicehandle Vendor ToDevice 0 0 0 (pack x) 1000
19:16:34 <joe___> the above line works but I am using pack here. I tried with particular string hardcoded without pack, which worked.
19:17:07 <joe___> but am curious if there is a way that IsString instance can be invoked here or why it is not being invoked for arguments?
19:18:02 <joe___> is this too many lines?
19:20:23 <joe___> broken packages with hpaste on debian, will have to look at it more closely later.
19:22:35 <joe___> monochrom, thanks
19:26:13 <bwr> Can anyone help me with my opengl / gtk2hs problem?
19:31:45 <dankna> bwr: not if you don't tell us what it is
19:32:17 <joe___> kmc, just tried pastepipe and it helps.
19:33:56 <ivanm> dankna: heh
19:35:18 <IceDane> I thought ((x:xs):xss) matched a list of lists?
19:35:31 <IceDane> getItem   ((x:xs):xss) = x
19:35:32 <kmc> it does
19:35:36 <IceDane> >:t getItem
19:35:36 <IceDane> getItem :: [[[a]]] -> [a]
19:35:44 <kmc> > case [[1,2],[3,4]] of ((x:xs):xss) -> (x, xs, xss)
19:35:45 <lambdabot>   (1,[2],[[3,4]])
19:35:51 <dankna> ivanm: well, it's true
19:36:21 <kmc> IceDane, a list of lists of lists is a list of lists
19:36:29 <kmc> [[[a]]] is a specialization of [[b]]
19:36:35 <ivanm> dankna: yeah, I know
19:36:41 <dankna> ah well
19:36:43 <ivanm> note that he still hasn't said what the problem is...
19:36:47 <dankna> indeed
19:36:52 <IceDane> kmc: Yeah, I figured as much, but it's not working on the list you used
19:37:03 <kmc> ?
19:37:11 <bwr> dankna: sorry, I pasted it earlier. I am trying to get opengl working within a GtkDrawingArea that is loaded from a glade file. I am adapting the RotatingCube example. It is "working" however, it is rendering very oddly like double buffering isn't working or something. My code is here: http://github.com/bwr/blockcomposer/blob/master/mapEditor/BlockComposerMapEditor.hs
19:37:18 <BMeph> kmc (and IceDane): It doesn't match a singleton list or the empty list. :)
19:37:22 <BMeph> *of
19:37:40 <kmc> that's true...
19:37:41 <dankna> bwr: can you post a screenshot of the broken rendering?
19:37:52 <dankna> I have OpenGL experience but no GTK experience, but I already have a guess
19:37:58 <dankna> and that is that you forgot to enable the depth buffer
19:38:10 <bwr> dankna: I can take a screenshot, but it is hard to catch
19:38:27 <dankna> it would be helpful if you could, or if you could explain in more detail the nature of the oddness
19:39:07 <dankna> but it's a common OpenGL newbie mistake to just use the default pixel format and not configure things like the double-buffering
19:39:19 <dankna> you should look at the Nehe examples for GTK+ (there are many versions of them, for different platforms)
19:39:30 <bwr> I was adapting a working example
19:39:30 <dankna> and figure out how the setup-and-initialization code they have differs from what you are doing
19:39:45 <bwr> I didn't change any settings like that
19:39:53 <dankna> what was the example?
19:40:03 <bwr> http://cvs.haskell.org/darcs/gtk2hs/demo/opengl/RotatingCube.hs
19:40:28 <bwr> Is there somewhere to quickly paste screenshots?
19:40:41 <dankna> you did, actually
19:40:44 <dankna> oh wait, no
19:40:47 <dankna> I see
19:40:49 <dankna> lines 18-20
19:40:49 <ivanm> bwr: omploader or something?
19:40:58 <dankna> are what turns on the depth buffer
19:41:00 <dankna> okay, so it's not my guess
19:41:12 <dankna> bwr: I'm not aware of anywhere, maybe twitpic or something?
19:41:19 <kmc> 4chan
19:41:30 <IceDane> :r
19:41:31 <IceDane> eh
19:41:34 <IceDane> wrong term
19:41:39 <dankna> haha 4chan
19:42:08 <bwr> http://omploader.org/vMnNwMQ
19:42:36 <dankna> the horizontal gray streaks are the problem?
19:42:39 <bwr> yes
19:42:43 <bwr> they are not static like that
19:42:45 <dankna> that IS weird
19:42:46 <bwr> it moves very quickly
19:42:57 <dankna> are you running over a network?
19:42:59 <bwr> no
19:43:00 <kmc> i imagine if it were double buffering related, you wouldn't actually see it on a screenshot
19:43:02 <dankna> this is X11 I take it
19:43:02 <bwr> this is all local
19:43:07 <bwr> dankna: yes
19:43:09 <dankna> I agree with what kmc said
19:43:27 <dankna> I don't think this is an OpenGL problem
19:43:31 <bwr> double buffering was my newbie guess :P because I have no idea what is going on
19:43:34 <dankna> my advice would be to try the same code on Windows or something
19:43:40 <dankna> and see if it works there
19:43:43 <bwr> I don't actually have a windows install
19:43:46 <dankna> if it does... well... that's a data point
19:43:52 <kmc> opengl on windows is its own special variety of hell
19:43:54 <dankna> yeah, I keep one around just for this sort of purpose, haha
19:43:59 <dankna> kmc: very true :(
19:44:10 <dankna> it's better supported in Vista and up though
19:44:14 <dankna> but that's a tangent
19:44:21 <kmc> almost as if microsoft had some vested interest in people using something else
19:44:27 <bwr> lol
19:44:27 <dankna> hahaha
19:44:48 <dankna> you'd think why do they even care what API people use, wouldn't you?
19:44:55 <dankna> but yeah, they do seem to prefer DirectX
19:45:04 <bwr> it is almost like gtk is drawing in the grey stuff unaware that opengl is doing anything
19:45:12 <dankna> bwr: I agree
19:45:18 <dankna> it's like they're fighting for priority
19:45:29 <kmc> if people code to a Windows-only API, it gives Windows more lock-in
19:45:32 <dankna> when I saw the chunkiness of it my first thought was that you were running over either VNC or a remote X connection
19:45:44 <dankna> what's your OpenGL driver?  is it a hardware renderer or a software one?
19:45:47 <kmc> you could also try the same OpenGL code not in gtk
19:45:51 <dankna> you can double-check that, there's some call that does it...
19:45:51 <kmc> like it GLUT for example
19:45:53 <dankna> yeah, what kmc said
19:46:05 <dankna> try it with GLUT, there's a Haskell binding to GLUT
19:46:11 <bwr> the opengl code works in the example
19:46:21 <bwr> on my machine
19:46:25 <IceDane> how do I match an empty [[]] list? f [[]] = [[]] is not working.
19:46:30 <dankna> okay, can you prepare a diff of the example code to your code?
19:46:37 <kmc> > let f [[]] = () in f [[]]
19:46:38 <dankna> and post the diff?
19:46:38 <lambdabot>   ()
19:46:45 <kmc> IceDane, it should work...
19:46:46 <dankna> I mean I could but it's less error-prone if you do it, not to mention it saves me work
19:46:56 <kmc> do other GTK+ OpenGL programs have trouble?
19:47:00 <kmc> what about ones not written in Haskell?
19:47:24 <kmc> IceDane, that's not an empty list
19:47:30 <kmc> it's a list with one element, which is an empty list
19:47:31 <bwr> the diff would be useless i think, because I had to change somethings because I am not drawing into a GLDrawableArea
19:47:47 <dankna> I'd like to see it anyway
19:47:56 <dankna> I suspect that the things you inadvertently changed are the problem :)
19:48:10 <IceDane> Oh..
19:48:11 <dankna> (and why aren't you?)
19:48:22 <dankna> (I don't know enough about GTK+ to know whether that's supported)
19:48:27 <dankna> (you might try a GTK-specific channel instead of here)
19:48:30 <dankna> (if we're unable to help you)
19:48:51 <dankna> (I don't think this is a Haskell problem at all, really, except that your client code happens to be in Haskell... but I think you'd be seeing exactly the same misbehavior if you were using C)
19:49:09 <dankna> (there's probably #gtk or something like that, though I don't know as I've never been there)
19:49:44 <IceDane> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12268#a12270 bottom one
19:49:46 <IceDane> @ kmc
19:49:54 <IceDane> is it my type signature?
19:51:04 <bwr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12271#a12271
19:51:06 <bwr> differences
19:51:21 <kmc> IceDane, [] is not a valid value of type a
19:51:39 <kmc> if you have an extra layer of lists, you will have to change the sig to be [[[a]]] -> [a]
19:51:47 <dankna> yeah, sorry, at this point I'm about ready to give up and say look for a GTK channel
19:51:51 <bwr> ok
19:51:53 <kmc> maybe what you want is [[a]] -> Maybe a, with Nothing for the second case
19:51:53 <dankna> even though you'll have to explain the language to them
19:51:54 <bwr> thanks for your help anyway
19:51:58 <dankna> it's outside my expertise
19:52:00 <dankna> you're welcome
19:52:35 <IceDane> kmc: I'm trying to replicate groupBy as an exercise for RWH: groupBy (a -> a -> Bool) -> [a] -> [[a]], and then I have to set foldr up somehow to do it
19:52:40 <IceDane> oh, it's supposed to be with folds
19:52:53 <kmc> okay
19:52:55 <IceDane> I've been trying to, running into error after error, fixing one, getting another, etc
19:53:02 <kmc> but do you understand what's wrong with the getItem you wrote?
19:53:04 <IceDane> So the Maybe/Nothing isn't an option
19:53:12 <IceDane> kmc: I don't think I do, no.
19:53:25 <kmc> IceDane, that depends... you're writing your own fold, you get to choose the accumulator type.  Maybe is an option
19:53:29 <kmc> IceDane, well, what's the type of []
19:53:31 <kmc> :t []
19:53:33 <lambdabot> forall a. [a]
19:53:43 <IceDane> Yeah
19:53:50 <kmc> and what type does getItem return?
19:53:57 <IceDane> a as well
19:54:03 <kmc> "as well"?
19:54:06 <kmc> [a] is not the same as a
19:54:12 <kmc> getItem returns any type at all
19:54:22 <kmc> because you could pass it [[x]] for x of any type at all
19:54:33 <kmc> but [] is not a valid member of every type
19:54:43 <kmc> it's only a valid member of list types, [a], which are a subset of all types
19:54:49 <IceDane> How is it that you can match [] and return [] in some other cases, then?
19:54:53 <IceDane> situations*, rather
19:54:58 <kmc> because those functions were declared to return lists
19:55:06 <kmc> here's a simpler example:
19:55:10 <IceDane> Oh, silly me
19:55:12 <IceDane> I get it
19:55:17 <kmc> :t let f :: a -> a; f _ = [] in f
19:55:19 <lambdabot>     Couldn't match expected type `a1' against inferred type `[a]'
19:55:19 <lambdabot>       `a1' is a rigid type variable bound by
19:55:19 <lambdabot>            the type signature for `f' at <interactive>:1:9
19:55:23 <kmc> :t let f :: [a] -> [a]; f _ = [] in f
19:55:25 <lambdabot> forall a. [a] -> [a]
19:55:32 <kmc> :)
19:56:12 <IceDane> So I'll have to make it return a list, and then grab the element from it or Maybe a and Nothing if it's empty?
19:56:15 <kmc> if you want to indicate "missing value", you'll have to wrap your type in some structure that gives "extra" values, like a list or Maybe or Either
19:56:24 <IceDane> yeah
19:56:27 <kmc> Haskell, mercifully, has no implicit "null" or "None" values
19:56:37 <ainirtnec> :t Nothing
19:56:38 <lambdabot> forall a. Maybe a
19:56:47 <dankna> yeah, Maybe is one of the things that I really liked about Haskell when I was first getting into it
19:56:51 <dankna> lets you make that concept explicit
19:57:02 <dankna> the thing about having a null value is that it takes on semantics of its own
19:57:04 <kmc> :t \v -> case v of ((x:xs):xss) -> Just x; _ -> Nothing
19:57:06 <lambdabot> forall t. [[t]] -> Maybe t
19:57:28 <kmc> dankna, and not only that, but languages with null usually *don't* have a "null monad", so every other damn line of code is "if (x == null) return null;"
19:57:52 * BMeph coughs something...oddly, it sounds like "undefined!"
19:58:32 <dankna> kmc: yes, quite so
19:58:37 <kmc> that's a separate problem which *also* exists in other languages
19:58:42 <dankna> BMeph: hahaha yeah
19:58:49 <dankna> yeah, I see what you mean that it's separate
19:58:58 <kmc> but i think we should force all the partial functions into some other structure anyway
19:59:10 <kmc> or at least rename all the partial functions in Prelude to have "unsafe" in their names
19:59:15 <joe___> kmc, just tried out haste and it is brilliant too. will stick with haste as it seems a bit more flexible.
19:59:17 * dankna nods
19:59:21 <kmc> > let unsafeHead = head in unsafeHead []
19:59:22 <lambdabot>   * Exception: Prelude.head: empty list
19:59:24 <kmc> look how unsafe it is!
19:59:30 <dankna> well, I don't know about "unsafe"
19:59:35 <dankna> that would dilute the term
19:59:40 <dankna> and make people think unsafePerformIO is safe
19:59:48 <dankna> some other word though, yeah
19:59:49 <kmc> it's true
19:59:57 <kmc> they are not unsafe in the type-safety sense
20:00:10 <dankna> causing an error is not the same level of unsafety as causing a segfault
20:00:18 <dankna> maybe errorHead
20:00:24 <dolio> We could switch it to reallyUnsafePerformIO.
20:00:29 <dankna> haha, or that
20:00:31 <dolio> And reallyReallyUnsafePtrEquality.
20:00:36 <dankna> hahahaha
20:00:38 <kmc> in some sense the argument of "head" is safely but dynamically typed
20:00:44 <kmc> hmm, what's all that safe about pointer equality?
20:00:53 <kmc> unsafePerformIO lets you write casts and get undefined behavior
20:01:01 <IceDane> kmc: How would you write a safe head, then? Using Maybe?
20:01:05 <kmc> sure
20:01:12 <kmc> or more generally
20:01:16 <cwraith> :t listToMaybe
20:01:17 <lambdabot> forall a. [a] -> Maybe a
20:01:29 <dankna> > let head [] = Nothing head (a:_) = Just a in head []
20:01:30 <lambdabot>   <no location info>: parse error on input `='
20:01:37 <dolio> kmc: reallyUnsafePtrEquality isnt' referentially transparent, at the least.
20:01:38 <dankna> > let head [] = Nothing ; head (a:_) = Just a in head []
20:01:39 <lambdabot>   Nothing
20:01:48 <dankna> > let head [] = Nothing ; head (a:_) = Just a in head ["a", "b", "c"]
20:01:48 <kmc> (MonadPlus m) => [a] -> m a
20:01:49 <lambdabot>   Just "a"
20:01:52 <dankna> there
20:01:55 <dankna> I wrote it
20:02:11 <cwraith> > listToMaybe [1,2,3,4]
20:02:11 <kmc> :t let head [] = mzero; head (a:_) = return a in head
20:02:12 <lambdabot>   Just 1
20:02:13 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
20:02:19 <dankna> I guess it already exists :)
20:02:19 <cwraith> > listToMaybe []
20:02:20 <lambdabot>   Nothing
20:02:31 <dankna> ah, mzero.  slick.
20:02:34 <dankna> :t mzero
20:02:35 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
20:02:40 <dankna> I see.
20:03:10 <kmc> would unsafePerformIO be safe, in the sense of not causing undefined behavior, if it could only be instantiated at monomorphic type?
20:03:22 <escaflown> hello everyone. just a Haskell newbie question. I found this infamous factorial function code in several Haskell tutorial: let fac n = if n == 0 then 1 else n * fac (n-1). I understand the recursion but I don't quite understand how come it doesnt lead to a stack overflow. There is no checking for negative values !!!!
20:03:23 <kmc> iirc the way you write unsafeCast with it requires making a polymorphic IORef
20:03:29 <dankna> that's an interesting question which is way too deep for me
20:03:45 <kmc> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac (-1)
20:03:47 <lambdabot>   * Exception: stack overflow
20:03:52 <kmc> escaflown, there's your answer ;)
20:03:57 <escaflown> ok :)
20:04:02 <kmc> escaflown, btw, that's a very bad and "un-haskell" way to write fac
20:04:11 <escaflown> ok
20:04:15 <escaflown> thanks guy
20:04:16 <kmc> @google The Evolution of a Haskell Programmer
20:04:17 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
20:04:17 <lambdabot> Title: The Evolution of a Haskell Programmer
20:04:20 <ksf> haskell is the perfect system language
20:04:25 <escaflown> it's kind of misleading
20:04:26 <ainirtnec> > let fac 0 = 1; fac (n+1) = n * fac n in fac 100
20:04:27 <lambdabot>   0
20:04:38 <ainirtnec> > let fac 0 = 1; fac (n+1) = (n+1) * fac n in fac 100
20:04:39 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:04:40 <kmc> > let fac n = product [1..n] in fac 6
20:04:41 <lambdabot>   720
20:04:45 <ainirtnec> > let fac 0 = 1; fac (n+1) = (n+1) * fac n in fac 6
20:04:47 <lambdabot>   720
20:04:49 <escaflown> I've been going through several tutorial and they all show that code
20:05:06 <kmc> escaflown, maybe as a demo of how to use "if".  but we tend to avoid "if" in favor of pattern-matching
20:05:08 <cwraith> bah.  n+k patterns!
20:05:10 <kmc> which is much more powerful
20:05:11 <ksf> ...writing stuff in c and then linking to it is overrated: the compiler won't be able to generate optimal assembly because it can't inline, anymore.
20:05:30 <escaflown> I see
20:05:32 <ksf> reducing usage of first-order functions with TH is the key.
20:05:40 <dankna> ksf: I concur fully, but why don't we outperform C on the shootout?
20:05:43 <Saizan_> escaflown: well, it's common to assume that you're only calling fac with positive values, and in that case you'll always reach 0
20:05:43 <kmc> > scanl (*) 1 [..]
20:05:44 <lambdabot>   <no location info>: parse error on input `..'
20:05:47 <kmc> > scanl (*) 1 [1..]
20:05:49 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
20:06:03 <dankna> I'd like to see how Go does on the shootout, when people get around to trying it
20:06:14 <escaflown> the weirdest part is when i put the same function in a .hs file and load it a s module in ghci, it works
20:06:17 <dankna> I bet it's underwhelming
20:06:38 <kmc> i bet it's a bit slower than C and faster than Java
20:06:42 <dolio> dankna: Their submissions will compile faster than any other submissions, though!
20:06:48 <dankna> amusement!
20:06:50 <dankna> perhaps so
20:06:57 <dankna> and that has some value, certainly
20:07:00 <Cale> kmc: Even unsafePerformIO restricted to () is enough to cause problems.
20:07:05 <kmc> Cale, example?
20:07:07 <ksf> dankna, a) we do, in at least one benchmark b) I've got a version of fasta on my box that's 0.94x the speed of C c) I didn't yet get around optimizing the hell out of the rest of the entries
20:07:20 <dolio> It still violates referential transparency.
20:07:23 <kmc> well of course
20:07:36 <dolio> It just wouldn't defeat the type system.
20:07:41 <kmc> right, that's what i'm asking after
20:07:46 <dankna> ksf: do itttt!
20:07:52 <dankna> that's quite impressive
20:08:09 <escaflown> @ Saizan: but once you reach 0, there is nothing refraining the continuation of the recursion
20:08:17 <Cale> It's easy to create situations where the exact order in which patterns are matched causes different effects.
20:08:23 <kmc> "if n == 0 then 1"
20:08:35 <dankna> re a) that's certainly cool, but for bragging purposes we really want it to be as many as possible :D
20:08:49 <dankna> I wonder how many other languages outperform C on at least one benchmark though
20:08:50 <Saizan_> escaflown: yes there is, you take the first branch of the if, which is not recursive
20:08:51 <kmc> can i make a GHC-Haskell program that segfaults using only unsafePerformIO :: IO () -> ()
20:09:09 <Cale> As in, when we pattern match against ((),()), do we evaluate the first part of the pair first, or the second?
20:09:18 <escaflown> thanx Saizan
20:09:22 <escaflown> I got it
20:09:24 <Saizan_> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 5
20:09:25 <lambdabot>   120
20:09:36 <cwraith> kmc:  sure.  you can always do ioCodeThatSegfaults >> return ()
20:10:16 <dolio> kmc: You can deref a null pointer to ()s.
20:10:19 <kmc> "only" meaning without using any other "unsafe" operations
20:10:40 <kmc> dolio, but i can do that without unsafePerformIO as well.  Should we rename "main" to "unsafeMain"? ;)
20:10:44 <ksf> I think I'm able to get down to 0.87% before hitting the wall.
20:11:07 <ksf> depends on how much overhead fixing my code takes or gives...
20:11:12 <dankna> ksf: well, sweet.
20:11:26 <dankna> I assume you mean 87%, not 0.87%
20:11:41 <ksf> I mean x, not %
20:11:45 <dankna> yeah
20:11:55 <dankna> same result
20:12:11 <Cale> ksf: Well, executing IO code can do anything, evaluating an expression typically can't.
20:14:00 <cwraith> kmc:  unsafePerformIO can be perfectly safe, so long as you can guarantee referential integrity
20:14:20 <joe___> datastack :: Data.ByteString.Internal.ByteString
20:14:39 <joe___> how can I convert the "datastack" to just Data.ByteString?
20:14:39 <kmc> i know that too
20:15:07 <kmc> i'm asking about a specific definition of "safe", more akin to how it's used in other languages
20:15:14 <joe___> I tried the module Data.ByteString.Internal, but does not seem to have anything on it.
20:15:25 <dankna> joe: one way, but it's hideously inefficient, is to do Data.ByteString.pack $ Data.ByteString.Internal.ByteString.unpack datastack,
20:15:31 <dankna> however, I think there may be some better way
20:15:38 <kmc> meaning that the type system (compile time or runtime) prevents the program from having undefined behavior
20:15:48 <kmc> from "segfaulting", though really a segfault is the best case of UB
20:15:57 <joe___> i am ok for inefficiency as I only have 8 bytes.
20:16:07 <Cale> kmc: If the program outputs 0 or 1 based on choices that the compiler was free to make, is that unsafe?
20:16:15 <dankna> oh, then yeah, if Data.ByteString.Internal.ByteString.unpack exists, use it
20:16:19 <dankna> I'm not sure it does
20:16:19 <kmc> not by this definition
20:16:26 <kmc> it's of course unsafe by the general definition we use
20:16:33 <kmc> i'm not disputing the general usefulness of that definition
20:16:39 <Cale> That's what 'undefined behaviour' typically means, doesn't it?
20:17:05 <kmc> that's a good point
20:17:06 <Cale> Like, in C, undefined behaviour means that you'll get different results based on what the compiler chooses to do.
20:17:25 <dankna> no, the C standard actually defines different categories of "undefined behavior"
20:17:27 <kmc> but it also covers the case where you get different results from one run to the next
20:17:38 <Draconx> dankna, the other things it defines are not called "undefined behaviour".
20:17:42 <dankna> the term "undefined behavior" in C has a specific meaning that includes launching missiles, setting the printer on fire, and segfaulting
20:17:45 <kmc> let's say i'm restricting it to the class of UB that could potentially cause a segfault
20:17:45 <dankna> Draconx: indeed
20:18:11 <Draconx> But obviously, any decent C implementation launches at least one missile every time a program invokes undefined behaviour.
20:18:18 <dankna> yes, clearly
20:18:40 <Cale> I prefer the implementation which starts a game of tetris
20:18:52 <dankna> Cale: what implementation is that?  I must have it
20:19:47 <Draconx> kmc, what if the launched missile hits the computer?  Isn't that worse than a segfault?
20:19:49 <joe___> dankna, cannot find  Data.ByteString.Internal.ByteString.unpack in the module Data.ByteString.Internal
20:19:56 <joe___> any other thoughts, please?
20:19:59 <dankna> joe: one sec, let me look at the docs
20:20:20 <IceDane> Is there any easy way to get an element from a list without writing a special function to retrieve it? In this case I'm already matching a [[]] with (x:xs), and I need a single element from a list in [[]]
20:20:30 * BMeph types in ghci: "unsafePerformArcaneVoodooRitualIO chicken"
20:20:43 <dankna> IceDane: head $ drop n myList
20:20:47 <Saizan_> joe___: Data.ByteString.unpack or Data.ByteString.Char8.unpack
20:21:18 <bwr> Sigh. No one has responded in any of the other channels I have tried.
20:21:23 <IceDane> dankna: thanks
20:21:25 <dankna> bwr: sorry to hear
20:21:29 <Saizan_> IceDane: list !! n
20:21:37 <Saizan_> > [1,2,3] !! 2
20:21:38 <lambdabot>   3
20:21:41 <dankna> oh yeah, or what Saizan said.  I'm still new; caveat coder.
20:21:43 <joe___> saizan, that helped. thanks.
20:21:46 <IceDane> wow, those were both really obvious
20:21:49 <IceDane> should have thought of them, heh
20:21:50 <IceDane> thanks =)
20:23:36 <jpet> How do you get a stack trace in GHC? I have a program that's dying from a stack overflow, but none of the code should be using any much stack at all. I'm sure it's a bonehead mistake somewhere, but GHC's output gives me no clue at all which expression is actually causing the overflow.
20:24:04 <cwraith> jpet:  ghc doesn't use the same sort of stack.
20:24:16 <cwraith> jpet:  but the problem is likely using foldl
20:24:21 <Cale> jpet: First of all, you ought to know that the stack means something completely different in GHC's evaluator to the standard sort of evaluator for a strict language
20:25:05 <dankna> yeah, I need to read that spineless tagless g-machine paper someday
20:25:08 <jpet> Cale: Yes, I understand how the stack works in Haskell, and what sort of problem I'm looking for
20:25:12 <Cale> okay :)
20:25:20 <jpet> but that doesn't help me narrow it down to which bit of code I messed up
20:25:42 <Cale> jpet: One thing you can do is you compile with profiling on and use +RTS -xc   -- that is, if I recall correctly.
20:26:06 <Cale> jpet: That should give you a "cost centre trace" when an exception occurs.
20:26:35 <Cale> Frequently, that's a bit less informative than one would like
20:26:47 <jpet> Cale: tried that, couldn't decipher the results in a useful way, but I can try again.
20:26:53 * ksf is tempted to write an instance for Num (Ptr a)
20:27:26 <kmc> haha
20:27:37 <Cale> jpet: Basically the problem must be that you're building up a large expression full of strict functions somewhere which isn't getting evaluated until much later.
20:28:20 <Cale> So, natural things to look at are anything which is accumulating information of some sort.
20:28:47 <jpet> Cale: yes, I figured that. I was hoping there was some way I could narrow it down to which expression it was, because eyeballing all the likely suspects didn't turn up any that looked wrong.
20:29:01 <joe___> *Main Data.ByteString.Internal Data.ByteString>  Data.ByteString.unpack datastack
20:29:04 <joe___> [153,153,153,153,153,153,153,153]
20:29:07 <joe___> it :: [GHC.Word.Word8]
20:29:21 <jpet> (Technically not true, one did look wrong--I was passing (1+arg) in tail recursively--but adding a `seq` for that didn't help.)
20:29:37 <joe___> i am trying to print this from the haskell file. how can I convert [GHC.Word.Word8] to 'IO String'
20:29:43 <Cale> jpet: Do you have any datastructures with multiple fields?
20:29:57 <dankna> joe: show
20:30:02 <jpet> Only Integer and [Integer]
20:30:09 <joe___> tried show but does not help
20:30:09 <Cale> (or even just data wrappers with one field?) Guess not.
20:30:18 <Cale> Okay, hmm.
20:30:29 <joe___> <interactive>:1:0:
20:30:29 <joe___>     Couldn't match expected type `ByteString -> t'
20:30:29 <joe___>            against inferred type `String'
20:30:41 <joe___> the above lines I get when I try with show
20:30:54 <jpet> ...darn, I was really hoping someone would say "just pass the undocumented --gfurble parameter to GHC and it will print stack traces"...
20:30:57 <dankna> you got the parenthesization wrong
20:31:09 <Cale> joe___: Import Data.ByteString.Char8
20:31:42 <Cale> joe___: The unpack in that module will unpack the ByteString to a normal String of characters \0 to \255
20:31:49 <dankna> when the expected type and the inferred type have different numbers of -> it's almost always a missing $ or (...) or ,
20:32:04 <jpet> <Main.CAF><Main.CAF>Stack space overflow
20:32:18 <Cale> jpet: maybe try -caf-all
20:32:34 <Cale> (when compiling)
20:32:50 <joe___> cale, I just want to see the list of bytes
20:33:13 <ivanm> preflex: seen roconnor
20:33:14 <preflex>  roconnor was last seen on #haskell 1 day, 7 hours, 24 minutes and 32 seconds ago, saying: > words "   here   are abunch of words   "
20:33:15 <jpet> Is <Main.CAF:sat_sWh><Main.CAF:sat_sWh>Stack space overflow
20:33:18 <Cale> joe___: Oh, then applying show . unpack was a good idea
20:33:35 <Cale> joe___: Perhaps you parenthesised the expression incorrectly?
20:33:51 <jpet> That's odd. I did have aslightly more informative cost center trace before.
20:34:30 <jpet> ah, I think it's -auto-all I used before
20:34:37 <IceDane> Yes, kmc did just go over this error with me before, but I still don't get it or see where it is happening: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12282#a12282
20:34:40 <IceDane> =(
20:34:59 <IceDane> As far as I can see, both cases of acc return [[a]]
20:35:02 <IceDane> and so on
20:35:19 <kmc> IceDane, you really want [v : (x : xs)] and not (v : (x : xs))
20:35:19 <kmc> ?
20:35:25 <Cale> jpet: oh, yeah, it's very important to include at least one of -auto-all or -caf-all
20:35:35 <ivanm> @ask roconnor I have a list of colours such as "aliceblue 240  248  255  255"; do you think the values might be R, G, B and opacity (especially since I also have "transparent 255  255  254  0")?
20:35:35 <lambdabot> Consider it noted.
20:35:47 <kmc> also why use (head x) when you can pattern-match out x?
20:35:49 <kmc> it will be safer
20:36:13 <kmc> you should avoid "head" whenever possible
20:36:17 <Cale> IceDane: Don't you want (v:x):xs ?
20:36:22 <IceDane> Cale: yes, I think I do
20:36:26 <Cale> and not [v:(x:xs)]?
20:36:46 <jpet> Cale: Ok, that's slightly better: <Main.isPractical,Main.main,Main.CAF:main><Main.isPractical,Main.main,Main.CAF:main>Stack space overflow: ...
20:37:06 <IceDane> Same error still appears
20:37:28 <jpet> Cale: But not all that narrowing-downish.
20:44:13 <Cale> jpet: So maybe let's look at isPractical?
20:44:28 <ivanm> what's the correct way for using -- ^ haddock comments for a constructor with record functions?
20:44:36 <Cale> jpet: Oh, also, you're compiling with, or without optimisations?
20:44:45 * ivanm can't remember if the haddock markup get attached to the records or the constructor in that case
20:45:15 <jpet> Cale: originally with optimizations, now without optimizations while debugging this
20:45:21 <joe___> Cale, I am not able get it working.
20:45:21 <Cale> Okay
20:45:37 <jpet> Cale: I'm trying to narrow it down to a pastable-sized bit of code
20:45:45 <joe___> I am trying to output a string from ' [GHC.Word.Word8]'
20:46:13 <joe___> when using ghci, I can get the output using show as below:
20:46:15 <joe___> *Main> :t show $ Data.ByteString.unpack datastack
20:46:15 <joe___> show $ Data.ByteString.unpack datastack :: String
20:46:32 <Cale> joe___: okay
20:46:35 <joe___> how can I use show in the .hs file?
20:46:37 <Cale> (that's sensible)
20:46:44 <Cale> Exactly the same way as you did
20:46:49 <Saizan_> joe___: "print $ Data.ByteString.unpack datastack" in the IO monad
20:47:00 <Saizan_> print x = putStrLn (show x)
20:47:08 <jpet> OhferchrissakeIfoundit
20:47:30 <jpet> divisors = map product . sequence . map (\(f,n) -> map (f^) [0..n]) . factor
20:47:44 <jpet> I forgot that the prelude 'product' uses foldl instead of foldl'
20:47:48 <Cale> right.
20:48:11 <Cale> Wow, must be some large numbers though :)
20:48:16 <jpet> Which is funny, since the only other time I came to #haskell was to wonder why the prelude 'product' and 'sum' use foldl instead of foldl'.
20:48:17 <IceDane> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12282#a12283 - So now I handle ([]:xs) case(This makes head in the following pattern safe, yes?)
20:48:26 <joe___> saizan, I am trying what u recommend. give me a few mins.
20:48:53 <Cale> jpet: Maybe the real answer for why they're like that is to draw people to this channel.
20:49:16 <IceDane> horms: hai
20:49:57 <Cale> <horms> IceDane: iie
20:50:00 <Saizan_> IceDane: yeah
20:50:08 <horms> Afternoon all
20:50:20 * ivanm waves idly in horms general direction
20:50:20 <Cale> hi :)
20:50:33 <Saizan_> IceDane: though [(v : x) : xs] can't be correct there, because you're adding another level of [ .. ], making the result of type [[[a]]] instead of [[a]]
20:50:43 <IceDane> Saizan_: Yeah?
20:50:45 <IceDane> hmm
20:50:49 <IceDane> oh, yes
20:50:51 <horms> or perhaps 皆さん、久しぶりです。
20:50:52 <IceDane> xs = [[]]
20:50:55 <IceDane> that's right
20:51:13 * ivanm sees lots of empty boxes from horms 
20:51:23 <horms> lol
20:51:38 <p_l> ivanm: something along the lines of "long time no see"
20:52:03 <ivanm> ahhhh
20:52:27 <IceDane> ugh, drusepth, why you too?
20:52:30 <jpet> Cale: Nope, that wasn't it after all...
20:52:39 <drusepth> Just looking for horm
20:52:59 <jpet> Cale: Changed 'product' to (foldl' (*) 1) and it still overflows at the same place
20:54:01 <p_l> ivanm: basically, it was "Everyone, long time no see" (Mina-chan, sashiburi desu), rather informal :P
20:54:56 <jpet> Cale: however, trying to find the right bit of code to show with the problem is forcing me to narrow it down more carefully than I did before, so this is still useful.
20:55:25 <Cale> jpet: How large are the numbers you're factoring there?
20:57:01 <joe___> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12284#a12284
20:57:11 <joe___> when I try                   putStrLn ( show ( Data.ByteString.putStrLn datastack ))
20:57:27 <jpet> Cale: they were ~10 digits when the original program died, overflowing the default stack (1 meg I think). For debugging I'm running with a smaller stack (10k) and smaller numbers.
20:57:43 <joe___> when I used ghci, I can get the type IO ()
20:57:54 <Cale> p_l: Heh, you transliterated さん as if it were ちゃん
20:58:15 <joe___> but I do not seem to get when I used ":r " from the ghci prompt
20:58:36 <Cale> jpet: That's not nearly large enough to cause any of that code to stack overflow. How does 'factor' work?
20:58:42 <p_l> Cale: right, my bad. too long without practice
20:58:53 <dankna> ? <-- look, I know Japanese too!
20:59:02 <joe___> sorry, please ignore my question
20:59:04 <Saizan_> joe___: you've to use "putStrLn ( show ( Data.ByteString.unpack datastack ))"
20:59:08 <joe___> mistyped it
20:59:26 <joe___> Saizan: just found it. sorry for the bother.
20:59:47 <Saizan_> np :)
20:59:48 <Cale> dankna: That is a question mark...
21:00:06 <copumpkin> :t printLn
21:00:08 <lambdabot> Not in scope: `printLn'
21:00:31 <jpet> trialFactor fs n
21:00:33 <jpet> doh
21:00:45 <Cale> copumpkin: print already puts a newline
21:01:08 <copumpkin> ah :)
21:01:33 <ivanm> @src print
21:01:33 <lambdabot> print x = putStrLn (show x)
21:04:24 <dankna> Cale: It's a snowman if you have font support for it
21:04:24 <Cale> perhaps we should have printExp for printing without the newline. (though I hate using ln for the natural logarithm)
21:04:26 <dankna> it was a joke; I read hiragana, but I don't know Japanese
21:04:26 <Cale> dankna: I think your client didn't emit UTF-8 over the network somehow.
21:04:26 <dankna> well, that's certainly possible, though I use it in other channels without trouble
21:04:26 <jpet> Cale: 'factor' does trial division given a list of primes. It's a couple of code including other code that it calls; not sure how to show that in irc
21:04:26 <Cale> jpet: Okay.
21:04:26 <Cale> jpet: maybe hpaste the program?
21:04:26 <Cale> @paste
21:04:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:04:58 <jpet> @help paste
21:04:58 <lambdabot> paste. Paste page url
21:05:00 <jpet> doh
21:05:36 <mmorrow> just click "new" (if that's what you meant) :)
21:06:00 <iaefai> I want something that I can easily bang a gui out, the only important thing is that it work on windows, preferably be able to also work on mac. I am only dealing with grids that will have bitmaps displayed and clicked
21:07:39 * mmorrow turns down his irc client, since the silence is deafening
21:08:04 * tensorpudding turns on some ambient music
21:08:14 <dolio> Is the type-directed name resolution just for field selectors of records?
21:09:00 <dolio> Or is it essentially a proposal to add unrestricted ad-hoc overloading, so long as you use "a.foo" instead of "foo a"?
21:09:24 <mmorrow> dolio: add-hoc overloading of what?
21:09:30 <dolio> All functions.
21:09:36 <mmorrow> :o
21:09:44 <jpet> @paste
21:09:44 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:09:48 <mmorrow> dolio: what does that mean?
21:09:52 <tensorpudding> @bots
21:09:52 <jpet> @hpaste http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12285#a12285
21:09:52 <lunabot>  :o
21:09:52 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:09:52 <lambdabot> :)
21:09:58 <jpet> bah
21:10:11 <dolio> mmorrow: Like ad-hoc overloading in C++.
21:10:28 <jpet> Cale: well, there's a link to it anyway. I'll stop spamming the channel now.
21:10:31 * SamB_XP flees
21:10:41 <Cale> I think it would be nice to be able to import functions from a number of modules and so long as there is a unique choice of module qualification which makes the code typecheck, you should not have to explicitly qualify the names you use.
21:11:01 <dolio> You can define foo(T,U) and foo(T,V).
21:11:24 <SamB_XP> Cale: that sounds kinda fragile
21:11:26 <dolio> For distinct types U and V.
21:11:56 <mmorrow> jpet: the only thing i can see it could be is the "r" in "loop" in the divCount where
21:12:24 <mmorrow> which implies/assumes that divMod isn't strict in the fst of the tuple it returns
21:12:29 <mmorrow> which i'm not sure about
21:13:12 <mmorrow> dolio: so what is this "a." that's being used like a record/struct here?
21:13:17 <mmorrow> a record/struct?
21:13:43 <dolio> Any value, I guess.
21:13:45 <mmorrow> like, are bot of those foo's record selectors/struct accessors
21:13:47 <mmorrow> ?
21:13:48 <mmorrow> hmm
21:14:21 <mmorrow> so you're saying then that the foo that you mean is disambiguated by the type of the "a" in a.foo ?
21:14:25 <dolio> Their examples are like "foo :: Button -> Canvas -> Whatever ; foo b c = b.reset ... c.reset ...
21:14:34 <dolio> Yes.
21:14:54 <Cale> SamB_XP: But it produces exactly the result that I want with respect to things like Data.Set and Data.Map
21:15:26 <Cale> SamB_XP: And you still get a nice error when things do become ambiguous.
21:15:39 <Cale> (so it's not really polymorphism)
21:15:40 <mmorrow> dolio: ah, imo that's still "type-directed name resolution of record field selectors"
21:16:46 <mmorrow> since there's no mechanism i don't think to associate a function with a type s.t. two functions with that name don't clash other than for record selectors with this extension
21:16:49 <jpet> mmorrow: Huh. I wouldn't have expected that, but throwing in a `seq` on the divMod remainder did get it past some code where it was overflowing before.
21:16:51 <Cale> Though, I guess it's nice to be able to resolve names before even starting typechecking
21:17:07 <FunctorSalad> I don't like yet another meaning for the dot :(
21:17:15 <IceDane> I know this is like the 100th request for help I've made this evening, but would someone help me understand why the accumulator simply.. stops? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12287#a12287
21:17:15 <dolio> Where "field record selectors" are defined as "any function whose first argument is monomorphically identifiable"?
21:17:20 <mmorrow> jpet: that was the only possible place where an arbitrarily deep thunk could be building up
21:17:21 <Cale> Yeah, dot should never have been used for module resolution
21:17:34 <Cale> and certainly should not be used for record selection
21:17:36 <mmorrow> dolio: oh, hmm
21:18:04 <dolio> If I understand the proposal correctly...
21:18:08 <IceDane> It v = 1, (x:xs) = [[]], and thus x = [] in the first pass. That means we get [[1]], as intended. That's what the accumulator contaisn after the first pass, right?
21:18:12 <mmorrow> dolio: how would you declare a "reset :: Int -> ..." and a "reset :: Tree Double -> ..." in the same module (syntactically)?
21:18:28 <ivanm> if Haskell wasn't lazy, then most of my QUickCHeck tests would fail since most of them are due to parsing failure... :s
21:18:33 <dolio> I can write "bar :: Char -> Ind ; bar = ord ; bar :: Int -> a -> [a] ; bar = replicate" in a file.
21:18:36 <ivanm> so yay for laziness! \o/
21:18:46 <mmorrow> dolio: oh.
21:19:04 <mmorrow> dolio: hmm
21:19:06 <dolio> Then both " 'c'.bar " and " 5.bar 'x' " are well-defined.
21:19:17 <mmorrow> that's kind of neat
21:19:32 <mmorrow> that'd extend to multiple args too i guess
21:19:36 <SamB_XP> dolio: you mean 5.bar doesn't give a syntax error ?
21:20:03 <dolio> Why would it?
21:20:03 <dmoerner> i have a question about an appropriate first textbook/tutorial on haskell (i'm sure you get this a lot). i learned scheme from SICP and the MIT lecture series, and i know SML from taking a course on it in college. is there any particular starting point that this should point me towards in learning haskell?
21:20:11 <SamB_XP> > 5.bar
21:20:13 <lambdabot>   Not in scope: `bar'
21:20:14 <mmorrow> bar :: Int -> a -> b; bar :: Double -> a -> (); bar :: Int -> Double -> Tree ()... err
21:20:33 <SamB_XP> > 5.id
21:20:34 <mmorrow> so i guess "bar :: Int -> a -> b" means no "bar :: c -> ..." can exist
21:20:35 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
21:20:35 <lambdabot>    arising from the literal `5' at <...
21:20:36 <ivanm> dmoerner: it should help since you're used to the general concepts, etc. behind functional programming (folds, maps, etc.)
21:20:53 <dolio> I know it isn't acceptable syntax now.
21:21:13 <dolio> Or, it is, but it means 5 . id
21:21:28 <dolio> Unless the parser thinks you're trying to use 5 as a module name.
21:21:31 <mmorrow> IceDane:
21:21:40 <mmorrow> , foldr f z [0..9]
21:21:42 <lunabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 z)))))))))
21:21:42 <SamB_XP> dolio: I was thinking the "5." would be parsed as a Fractional
21:21:56 <mmorrow> IceDane: so the
21:21:57 <dmoerner> ivanm: thanks. i guess i'll scan quickly through one of the intro to functional programming using haskell books to get a sense of the similarities and then dig into something more advanced
21:21:58 <IceDane> alright, that is pretty cool
21:22:15 <dolio> Well, it doesn't really matter. It doesn't have to be a dot.
21:22:21 <mmorrow> IceDane: so the "acc v ([]:_)   = [v] : [[]]" case fires at the end of the list, then pulls the singleton list back to the end
21:22:27 <ivanm> dmoerner: you want an actual book, or something online?
21:22:41 <ivanm> dmoerner: you might even be able to cope with going straight to RWH
21:22:42 <mmorrow> since the second arg is the singleton list it just created
21:22:46 <mmorrow> doh
21:22:48 <IceDane> mmorrow: Which means what? I'm using the wrong fold?
21:22:49 <mmorrow> nevermind
21:22:58 * mmorrow thinks for a second there
21:23:14 <Saizan_> that case of acc surely discards things
21:23:29 <dolio> It also suggest letting you do sections.
21:23:33 <dmoerner> ivanm: i could go for either. i'm a fan of books so i'll see what the university library has, i'll take a look at real world haskell
21:23:39 <dolio> So you can do "map (.bar)".
21:23:58 <dolio> Which, I have no idea what the proposed type of that would be.
21:24:02 <mmorrow> > let myGroupBy _ [] = []; myGroupBy p list = let acc v ([]:_)   = [v] : [[]]; acc v (x:xs) | p v (head x) = (v : x) : xs | otherwise = [v] : xs in foldr acc [[]] list
21:24:03 <lambdabot>   not an expression: `let myGroupBy _ [] = []; myGroupBy p list = let acc v (...
21:24:11 <mmorrow> @let myGroupBy _ [] = []; myGroupBy p list = let acc v ([]:_)   = [v] : [[]]; acc v (x:xs) | p v (head x) = (v : x) : xs | otherwise = [v] : xs in foldr acc [[]] list
21:24:12 <lambdabot>  Defined.
21:24:12 <Cale> dmoerner: There's RWH and LYAH, as well as the wikibook and YAHT online
21:24:16 <Cale> @where lyah
21:24:16 <lambdabot> www.learnyouahaskell.com
21:24:21 <mmorrow> > myGroupBy (\x y -> (x*y) `mod` 3 == 0) [1..10]
21:24:22 <Cale> @where wikibook
21:24:22 <lambdabot>   [[1],[]]
21:24:22 <lambdabot> http://en.wikibooks.org/wiki/Haskell
21:24:28 <Cale> @where rwh
21:24:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:24:33 <Cale> @where yaht
21:24:33 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
21:24:44 <dmoerner> Cale: thanks, i have those from the wiki anyway :)
21:24:49 <jpet> mmorrow/Cale: Ok, I have a much smaller but still confusing overflow example. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12285#a12288
21:25:17 <krainbolt> That almost confused me.
21:25:18 <mmorrow> > myGroupBy f [1..10]
21:25:19 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Bool.Bool)
21:25:19 <lambdabot>    arising from a us...
21:25:22 <mmorrow> grr
21:25:38 <Cale> jpet: wow!
21:25:43 <krainbolt> There's a new orleans colloquialism that goes "Where ya' at!".
21:26:04 <FunctorSalad> and sup means supremum too
21:26:07 <jpet> In fact, the mapM call barfs *even if the primes list was already evaluated by the non-mapM version*
21:26:11 <krainbolt> So when I saw @where yaht .
21:26:14 <mmorrow> @let myP p v ([]:_) = [v] : [[]]; myP p v (x:xs) | p v (head x) = (v : x) : xs | otherwise = [v] : xs
21:26:14 <FunctorSalad> -.-
21:26:15 <lambdabot>  Defined.
21:26:17 <jpet> So it's mapM print that's doing it
21:26:22 <Saizan_> jpet: try mapM_
21:26:26 <jpet> gah
21:26:31 <Cale> jpet: I'm not getting a stack overflow
21:26:36 <mmorrow> > myP (\x y -> (x*y) `mod` 3 == 0) 1 2
21:26:37 <lambdabot>   No instance for (GHC.Num.Num [[t]])
21:26:37 <lambdabot>    arising from the literal `2' at <int...
21:26:39 <mmorrow> sigh
21:26:47 <jpet> Cale: I'm running with -K10k so it will barf on small numbers
21:26:59 <mmorrow> IceDane: trying to grok acc..
21:27:20 <IceDane> mmorrow: grok? o.o
21:27:56 <Cale> IceDane: comprehend
21:28:03 <IceDane> ah, heh
21:28:36 <rasfar> ([]:_) ... are you not thereby saying a is a list type?  (sheesh i'm rusty....)
21:28:47 <mmorrow> , (\x y -> (x*y) `mod` 3 == 0) 9 10
21:28:48 <lunabot>  True
21:29:02 <jpet> Cale/mmorrow: Ok, so I think I have it figured out now. My original code was perhaps overflowing because `divMod` isn't strict in the remainder. Then, while trying to debug that, I used mapM instead of mapM_, and the actual problems were then highly confused with problems in my debugging code.
21:29:05 <FunctorSalad> > robotMonkey 1
21:29:06 <lambdabot>   Not in scope: `robotMonkey'
21:29:15 <FunctorSalad> @let robotMonkey = (:[])
21:29:16 <lambdabot>  Defined.
21:29:24 <IceDane> mmorrow: I'm using that particular predicate because it's used on some reference I found it on as an example, so I knew what output I was looking for
21:29:25 <FunctorSalad> -.-
21:29:33 <tensorpudding> > robotMonkey 1
21:29:35 <lambdabot>   [1]
21:29:55 <mmorrow> IceDane: hmm, i think you're accumulating all of them in the list in head, then ditching that at the end with the "| otherwise = [v] : xs" case
21:30:22 <rasfar> (never mind last remark...)
21:30:49 <mtnviewmark> anyone know of a base64 encode/decode function in the libraries or on hackage? Hoogle didn't turn one up
21:31:02 <mmorrow> IceDane: i'm not positive, but i think this is a semantic problem rather than a syntactic/choice-of-fold-direction thing
21:31:03 <Cale> It's quite sad that ghc isn't smart enough to optimise mapM into mapM_ when you don't use the result.
21:31:12 <IceDane> I see
21:31:17 <kmc> base64-string
21:31:26 <FunctorSalad> rasfar: no you were right, ([]:_) is a pattern of type [[a]]
21:31:29 <kmc> simplest API you could hope for
21:31:35 <kmc> but it doesn't have bytestrings
21:31:35 <mmorrow> , fmap (\x y -> (x*y) `mod` 3 == 0) (zip`ap`tail) [1..10]
21:31:36 <lunabot>  luna: No instance for (GHC.Show.Show ([(b, b)] -> GHC.Bool.Bool))
21:31:42 <mmorrow> , fmap (\(x,y) -> (x*y) `mod` 3 == 0) (zip`ap`tail) [1..10]
21:31:43 <lunabot>  luna: Couldn't match expected type `(t, t)'
21:31:49 <mmorrow> , fmap (\(x,y) -> (x*y) `mod` 3 == 0) $ (zip`ap`tail) [1..10]
21:31:49 <FunctorSalad> (as opposed to the monkey)
21:31:50 <lunabot>  [False,True,True,False,True,True,False,True,True]
21:32:04 <mmorrow> > myGroupBy f [2..10]
21:32:05 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Bool.Bool)
21:32:05 <lambdabot>    arising from a us...
21:32:11 <mmorrow> > myGroupBy (\x y -> (x*y) `mod` 3 == 0) [2..10]
21:32:12 <lambdabot>   [[2,3,4],[]]
21:32:26 <mmorrow> the 1 is causing the 2,3,4 to be discarded
21:32:27 <Cale> hmm, I wonder what that would take
21:32:51 <jpet> Although my life would really have been much simpler I could have had a stack trace in the first place. (A big stack of '>>=' from the prelude rather than a big stack of '+' from my code would have made that problem obvious.)
21:32:52 <Cale> I guess it tacitly assumes the monad laws that that's okay in an arbitrary monad.
21:32:58 <IceDane> mmorrow: yeah, it seems to do that
21:33:07 <mmorrow> IceDane: maybe you meant "| otherwise = [v] : x : xs" or something?
21:33:12 <Cale> But in a *specific* monad, it should be possible to discover something like that
21:33:15 <rasfar> FunctorSalad: yeah, but ... cough ... i'll stay out of this but i'm listening.
21:33:33 <mmorrow> IceDane: as in, you're not actually using the rest of the outer list as-is
21:33:42 <Cale> jpet: Yeah.
21:33:53 <IceDane> mmorrow: yeah, that seems to be it
21:33:56 <Cale> jpet: The evaluation machinery just doesn't support it at the moment.
21:33:59 <IceDane> sweet god
21:34:03 <mmorrow> heh
21:34:05 <IceDane> Thanks a bunch
21:34:08 <mmorrow> :)
21:34:17 <IceDane> I have been crunching this problem for hours now
21:34:26 <IceDane> (Well, getting that far withour errors was the first step)
21:34:35 <IceDane> god damn imperative programming and how it is embedded in my brain
21:34:40 <Cale> jpet: It should at least be possible to compile code so as to be able to get a real (lazy) stack trace, and not silly cost centre traces.
21:34:57 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12287#a12289 <- heh, i was going to paste this
21:35:05 <byorgey> IceDane: it hurts less if you rip it out quickly, all at once
21:35:11 <byorgey> IceDane: like a bandage
21:35:11 <kmc> i recommend heavy drinking
21:35:33 <IceDane> kmc: I've tried that. I just have fun and wake up and feel like shit the day after.
21:35:38 <IceDane> but still think in loops
21:35:42 <mmorrow> Saizan_: beat you!
21:35:47 <IceDane> byorgey: I wish I could
21:36:09 <ivanm> I don't know if it's because I'm using QC2 rather than QC1, or because my datatypes are so complex, but it sure is slow to run quickCheck in ghci...
21:36:12 <jpet> Cale: yes. I wonder if you compiled via-c with c debugging on if you get something useful?
21:36:32 <kmc> heh
21:36:43 <kmc> a bunch of incomprehensible STG-machine gibberish, probably
21:37:16 <SamB_XP> kmc: I doubt you'd get even that much
21:37:28 <byorgey> @remember IceDane [on escaping an imperative mindset]: <kmc> i recommend heavy drinking <IceDane> I've tried that. I just have fun and wake up and feel like shit the day after. but still think in loops.
21:37:29 <kmc> maybe supposing you did an unregistered build
21:37:29 <lambdabot> I will remember.
21:37:40 <kmc> @quote imperative
21:37:41 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
21:37:41 <lambdabot>  but then I look at some java code and I'm all happy again
21:37:49 <SamB_XP> kmc: oh, I guess that would probably work, yes
21:37:50 <Cale> Even a stack trace which lined up with the core generated by GHC would be good.
21:37:59 <mmorrow> dolio: yeah, you'd need some syntactic trapeze-work for "map (.bar)"
21:38:05 <FunctorSalad> jpet: there is a stack trace monad on hackage now
21:38:05 <mmorrow> dolio: (to express the type)
21:38:13 <kmc> with registered build it'll get confused by the tail-jumps
21:38:14 <FunctorSalad> (haven't tried)
21:38:24 <dolio> mmorrow: It has no type on its own.
21:38:37 <kmc> and the lack of stack frames
21:38:48 <SamB_XP> kmc: I was thinking it would just get confused because of the code the mangler took out -- yes, that
21:38:49 <mmorrow> dolio: i'm thinking along the lines of something similar to a typeclass constraint, or an implicit param constraint
21:38:51 <dolio> Other than "AdHoc t => [t] -> [u]".
21:38:56 <mmorrow> right
21:39:09 <jpet> FunctorSalad: that's a bit different, though. It's trying to reproduce a stack of the call sites as they look in the code, where as I wanted to know what code is to blame for the actual frames on the ghc stack.
21:39:23 <SamB_XP> which would invalidate all the stack-related information in the debug info
21:39:29 <mmorrow> #ty let foo a = ?f a a in map foo
21:39:31 <lunabot>  luna: Exception when trying to run compile-time code:
21:39:32 <dolio> It's like C++ templates. You generate code for each case, and check if it works.
21:39:43 <mmorrow> , let foo a = ?f a a in map foo
21:39:44 <lunabot>  luna: Unbound implicit parameter (?f::a -> a -> b)
21:39:50 <dolio> Which doesn't sound great to me.
21:39:53 <mmorrow> , [$ty| let foo a = ?f a a in map foo |]
21:39:55 <lunabot>  luna: Exception when trying to run compile-time code:
21:39:56 <FunctorSalad> jpet: ah, misunderstood your statement about (>>=)
21:39:58 <mmorrow> grr
21:40:04 <mmorrow> @type let foo a = ?f a a in map foo
21:40:05 <lambdabot> forall a b. (?f::a -> a -> b) => [a] -> [b]
21:40:07 <Saizan_> dolio: if it works for C++, surely works for haskell
21:40:20 <dolio> And presumably didn't sound good to some C++ people, either, since they were adding concepts as an unenforced check on that kind of stuff.
21:40:44 <mtnviewmark> fie, base64-string works on strings, not ByteStrings....
21:41:15 <mtnviewmark> and isn't strictly RFC 4648 compliant
21:41:52 <kmc> dolio, isn't it funny how templates are totally duck-typed
21:43:30 <jpet> Thanks Cale/mmorrow
21:43:41 <mmorrow> jpet: np
21:45:49 <ksf> 0.8697876087370547
21:45:56 <ksf> ...but what I don't like is
21:46:01 <ksf>             where m = min i ((4096 `div` 61) * 60)
21:46:01 <ksf>                   m' = (m+(m `quot` 60)+if m `rem` 60 > 0 then 1 else 0)
21:49:10 <ksf> 216% the speed of C when not compiled with -fvia-C
21:49:42 <ksf> ...so there's _definitely_ slack left in the native codegen.
21:49:58 <mmorrow> are you using Integer?
21:50:04 <ksf> hell no
21:50:24 * mmorrow guesses it's div/quot/rem's fault
21:50:30 <ksf> Float and Word8
21:50:44 <ksf> I don't think so, they're not at all in a tight loop.
21:50:46 <bwr> dankna: guess what. the gtk widget itself was double buffered
21:51:02 <mmorrow> ksf: what's the program?
21:51:06 <ksf> fasta
21:51:15 <mmorrow> paste?
21:51:27 <mmorrow> ksf: you probably want to look at the asm
21:51:39 <mmorrow> and compare it to the C with gcc -O3
21:51:46 <dankna> bwr: so the double buffer of the widget was interfering with the double buffer of the OpenGL context?
21:51:50 <ksf> oh, that's beautiful, if compiled with -fvia-C
21:51:55 <dankna> bwr: does that mean your problem is solved?  how did you figure it out?
21:52:10 <bwr> No, the double buffer of the gtk widget was interfering with opengl in general
21:52:13 <bwr> i had to read the source
21:52:20 <dankna> gotcha
21:52:22 <bwr> of gtkglext and gtk2hs
21:52:27 <dankna> definitely good to be able to read the source
21:52:30 <bwr> yea
21:52:45 <mmorrow> ksf: also, are you on a 32bit machine?
21:52:59 <mmorrow> ksf: ghc uses the x87 on x86 :|
21:53:05 <dankna> so the solution is to either use a different widget that isn't, or to turn off the double-buffering of that widget, I guess?
21:53:08 <mmorrow> rather than SSE
21:53:08 <ksf> amd64
21:53:16 <bwr> actually though, gtk2hs is "missing" the required method
21:53:23 <dankna> hrm
21:53:23 <ksf> ...and there's a float random generator in the tightloop
21:53:38 <mmorrow> ksf: out of curiosity, is this the fasta on the benchmarks page?
21:53:40 <bwr> there is a "gtk_widget_set_gl_capability"
21:53:54 <ksf> yep
21:53:57 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12290#a12290
21:54:00 * mmorrow wants to see what we're talk
21:54:03 <mmorrow> beautiful
21:54:07 <ksf> still in need of serious cleanup, but fast.
21:54:12 <bwr> and that is only used in one function in gtk2hs which isn't exported
21:54:26 <dankna> hmmmm
21:54:37 <bwr> so i had to figure out what that function was doing (in the interim). It would be nice to have that exported from gtk2hs
21:54:43 * dankna nods
21:54:57 <dankna> the gtk2hs people are probably accessible by email or in this channel
21:55:16 <dolio> @remember JonHarrop Moreover, the only reason to parallelize code is performance and Haskell is a disaster in the context of performance.
21:55:17 <lambdabot> Okay.
21:55:33 <bwr> yea, but i think it is time for me to sleep now
21:55:39 <dankna> yeah.... well, gnight
21:55:42 <bwr> anyway, thanks for your help
21:55:46 <dankna> sure
21:56:00 * ksf still doesn't get how he managed to mess up the argument order of seed and n
21:57:34 <kmc> who is this jon harrop fellow
21:58:12 <dolio> Notable thorn in the side of Lispers.
21:58:20 <dolio> And more recently Haskell, I suppose.
21:58:42 <kmc> does he actually do anything of value
21:59:02 <ksf> haskell being a disaster for performance is an unsubstituated claim.
21:59:09 <ksf> I can write equally slow programs in C.
21:59:19 <dolio> He wrote a couple books. One of Ocaml and one on F#.
21:59:20 <kmc> looks like he's plugging F# now?
21:59:30 <dolio> And he runs some kind of consulting business.
21:59:48 <sproingie> can't imagine his clients know how he behaves
21:59:49 <ksf> ocaml, or rather, mldonkey once impressed me
22:00:36 <kmc> shootout should get a non-Mono CLR
22:01:01 <kmc> because GHC Haskell beats the pants of F# Mono, but i have a feeling some of that is Mono's fault
22:01:32 <sproingie> i thought the shootout did have the MS CLR
22:01:45 <sproingie> something like twice as fast as mono
22:01:50 <kmc> it's on par with OCaml
22:02:26 <sproingie> ghc doesnt have too many problems as speed goes
22:02:32 <ksf> it once was, nowadays it's faster
22:02:34 <sproingie> memory footprint on the other hand...
22:02:46 <ksf> still tiny compared to the jvm
22:03:20 <sproingie> jvm is pretty memory efficient without jit
22:03:31 <sproingie> 'course then it's pretty pokey
22:03:58 <ksf> well ok, ghc programs doesn't become smaller if you compile in libghc.
22:04:14 <ksf> sundawn!
22:04:34 <dolio> I've seen people accuse him of trying to drum up business via his trolling (since he almost always signs posts with links to his stuff), but it baffles me how his antics would be expected to cause that.
22:04:40 <ksf> time for another coffee
22:04:50 <ddarius> dolio: No press is bad press.
22:05:51 <sproingie> i'm sure the next shiny thing comes along he'll be slagging off F#
22:06:23 <kmc> isn't haskell shinier?
22:06:28 <dolio> He's been asking questions about Go on c.l.functional. Maybe he's getting ready to promote that.
22:06:38 <kmc> haha
22:07:14 <sproingie> ahh usenet.  when you're banned everywhere else, you can always go there.
22:07:25 <ddarius> kmc: Haskell isn't the -next- "shiny thing"
22:08:13 <kmc> reddit begs to differ
22:08:18 <path__> Ive been having some trouble with performance on haskell. But not because of the language because there is one small leap that I havent been able to make in my head when it comes to the purely unmutable data structures thing
22:08:28 <sproingie> it's not his next shiny thing
22:08:28 <path__> err immutable
22:08:30 <ddarius> kmc: Haskell is 20 years old.
22:08:48 <sproingie> its the next shiny thing for people who havent seen it before
22:08:48 <kmc> i know that
22:08:50 <kmc> 21 this year
22:08:58 <sproingie> yay haskell can drink
22:09:08 <mtnviewmark> mmmmm.... getting to be a good single malt age....
22:09:10 <dankna> is it really?
22:09:12 <dankna> I didn't know that
22:09:18 <dankna> 1988?
22:09:18 <ksf> well, automagic tightloop performance awesomeness won't come before supercompiling
22:09:24 <kmc> haskell is from scotland
22:09:29 <kmc> it's been drinking since birth
22:09:57 <mtnviewmark> look at the names in the Prelude... clearly Haskell's parents have been drinking even longer
22:10:27 <path__> I wish there was a book which explained how to do this. I hate the idea that some problems can only be solved by cheating and using mutable data structures
22:10:37 <kmc> err, wait
22:10:44 <kmc> Haskell was standardized in 1998, not 1988
22:10:46 <ddarius> @google "Purely Functional Data Structures"
22:10:47 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
22:10:48 <lambdabot> Title: Purely Functional Data Structures
22:11:01 <ddarius> kmc: The first Haskell Report came out in 1989.
22:11:06 <path__> hmmm Can those solve all algorithmic problems?
22:11:06 * kmc checks to make sure he did not forget what decade it is
22:11:09 <sproingie> church-turing says you never *need* mutable data, but it can be convenient
22:11:19 <sproingie> good thing haskell has all kinds of state
22:11:21 <path__> yeah Im just talking performance
22:11:22 * ksf doesnt' think using raw Ptrs is cheating in the context of heavy IO
22:11:56 <ksf> after all, linux expects ptrs to the stuff it should fwrite, and is even happier when you pass big buffers.
22:11:57 <sproingie> C has had another 20 years head start
22:12:05 <path__> no I had a problem which required me to insert and delete into a hash very often. As a result I wrote a ruby code and a haskell code and the haskell code was only 30% faster. Out of which 40% of the time was spent in gc
22:12:17 <path__> not hash, intmap
22:12:31 <path__> but new maps kept getting created all the time when I inserted
22:12:32 <kmc> path__, one easy thing is to increase the heap size
22:12:36 <Jedai> path__: with strict PL, persistent data structure may add a log n cost to imperative algorithm in some cases
22:12:41 <ski> path__ : see that pdf (and there's a book, too)
22:12:53 <path__> ski: ok thanks, will do
22:13:02 <ksf> the other one is strategically placing strictness annotations
22:13:09 <ksf> or writing a script that evolves those.
22:13:40 <Jedai> path__: but with a lazy PL, it's less clear if this factor is a fatality
22:14:34 <path__> I actually had put my code comparison on pastie and linked it here. But unfortunately the advice I got was to use structures from the IO or state monad which wouldnt invoke the gc so much :/. I just feel it must be possible to find a different algorithm almost ... to convert my algorithm. Let me read that pdf :)
22:14:39 <path__> maybe it has my answer
22:15:18 <kmc> path__, did you try some +RTS options?
22:15:26 <path__> yeah
22:15:27 <mtnviewmark> path__: just curious, which data structure did you use? Data.Map?
22:15:34 <sproingie> are prehistoric versions of haskell available anywhere?
22:15:35 <path__> you mean profiling right?
22:15:42 <Jedai> mtnviewmark: IntMap apparently
22:15:58 <path__> mtnviewmark: I used Data.IntMap for an Int to Int and I had a fixed unboxed array which I had to read from
22:16:01 <kmc> path__, no, heap size and the like
22:16:11 <kmc> it can make a big difference, if you're spending a lot of time on GC
22:16:17 <ksf> there's no faster thing for sparse int indexing than intmap, in any language
22:16:37 <ddarius> sproingie: You should be able to get the entire history for any of the major compilers.
22:16:38 <path__> kmc: oh  no I didnt, to tell the truth I didnt think of that. I guess thats something I should look into
22:16:47 <kmc> path__, it's not very well known unfortunately
22:17:17 <kmc> hmm, though it seems the default is "unlimited"?
22:17:20 * kmc is confused
22:17:30 <path__> well the problem wasnt reading from the intmap. The problem was I kept having to insert new keys into the map. Which from what I understand keeps destroying and creating new maps
22:17:36 <kmc> dons's multicore presentation had details on this
22:17:43 <kmc> path__, yes, but it will share most of the existing map structure
22:17:44 <ddarius> kmc: The option you are looking for is the initial heap allocation.
22:17:47 <kmc> that's the beauty of trees
22:17:47 <ksf> path__, but most of their substructure is shared.
22:17:58 <kmc> ddarius, thanks
22:18:01 <ksf> it's a good idea to force the spine of the map regularly, though.
22:18:13 <path__> hmm ok then I dont really have a good explanation I guess
22:18:31 <kmc> heh "-B       Sound the bell at the start of each garbage collection"
22:18:41 <ksf> ...that is, upon inserting an element, look it up so the old map can be gc'ed right away
22:19:00 <ksf> (anecdotal evidence)
22:19:05 <path__> so you mean at the core of it it's not going to copy the entire map out
22:19:06 <path__> ?
22:19:12 <path__> that makes sense
22:19:35 <path__> but wait, I still have the old map too
22:19:40 <sproingie> “You know, Haskell actually never liked the name Haskell.” -- Virginia Curry, widow of Haskell Curry
22:19:45 <mtnviewmark> that's fine!
22:19:50 <ksf> inserting an element only modifies the root and the path to the leaf it's inserted at
22:19:54 <ksf> the rest can be shared
22:20:00 <Jedai> path__: Right, but there's a lot of the tree that's shared between the old and the new value
22:20:05 <ksf> ...and that's a huuuuuge factor with bigger maps
22:20:09 <medfly> I wouldn't like being named after a programming language!
22:20:12 <path__> ah ok
22:20:13 <medfly> ;)
22:20:51 <Jedai> path__: Of course once the old value goes out of scope the non-shared part still has to gc-ed
22:21:17 <path__> ah
22:21:20 <path__> ok
22:21:31 <path__> is there something which explains how this is implemented under the hood :)
22:22:02 <Jedai> path__: Note that the sharing is made safe by the fact that Haskell is pure and won't modify the new value (so you don't have aliasing problem like in an imperative language if you tried to do the same)
22:22:02 <kmc> how IntMap is implemented?
22:22:17 <ksf> big-endian patricia trie
22:22:19 <path__> yeah
22:22:22 <Jedai> path__: You can read the source :)
22:22:31 <kmc> the Haddock page links to some papers
22:22:38 <ksf> splitting on longest bit prefixes
22:22:38 <kmc> one from 1968, good luck finding it online :/
22:22:48 <path__> lol I see
22:23:08 <ksf> so lookup is something like O(log n) * mask comparison + pointer deref
22:23:36 <Jedai> path__: Reading the source to understand a data structure is not as bad an idea in Haskell as in most other languages though
22:23:54 <ksf> and the recent fingertree paper describes a very similar beast
22:24:06 <ksf> ...or just read up tries
22:24:11 * mtnviewmark is about to perform surgery on his project: Moving it from Data.LLSD to Network.Format.LLSD --- will touch every file --- wish him luck......
22:24:17 <path__> no thats not the trouble. I havent played with haskell enough yet that I still fully read source easily
22:24:24 <kmc> do we have a hash trie module?
22:24:34 <ksf> hash trie?!
22:24:39 <kmc> a trie of hashes
22:24:40 <path__> and I think I first need to finish reading the first haskell book I started on. I suddenly jumped into trying to write code
22:24:45 <path__> without finishing the book
22:24:54 <ksf> well you can hash your values before you intmap them
22:25:02 <kmc> sure, but then you need secondary lookup at the leaves
22:25:04 <ksf> ...and then have than intmap index another map
22:25:12 <kmc> wondering if there's some module which abstracts that to a Data.Map-like interface
22:25:40 <ksf> there's gmap, you can use the instance magic it uses do do that
22:26:29 <ksf> path__, isn't that a good sign?
22:27:11 <ksf> well maybe I'm just tired of reddit folks claiming you need a PhD to write _anything_ in haskell
22:27:43 <c_wraith> never be afraid to code.  Haskell's a fun one to just play with.  Infinite lists are fun!
22:27:44 <mtnviewmark> heh!  I sure don't have one of those
22:28:23 <path__> haha no Im sure it is. but it also shows impatience and lack of diligence on my end. Too much reading and not enough coding is bad, but so is only trying to write code without reading :/
22:28:35 <path__> anyway gotta head to work now, Ill play with it tonight
22:35:30 <nolrai_FG> Okay, in the stg code that ghc makes, case statements are of  the form: case name1 of name2 {pattern -> exp; pattern2 -> ex2} does name2 mean anything? cause I cant figure out what it does mean.
22:35:35 * mtnviewmark 's patient lived -- now successfully transplanted!
22:35:58 <ksf> it's just the name the forced value is bound to
22:36:04 <dolio> nolrai_FG: It gives a fresh name to the expression between "case" and "of".
22:36:36 <nolrai_FG> hmm, why?
22:36:44 <ksf> like foo l@(x:xs)
22:36:52 * mtnviewmark is now going to go try to understand how printf does its magic
22:37:00 <nolrai_FG> oh that makes sense.
22:37:00 <ksf> ...you might want to return l and still match on :
22:37:30 <nolrai_FG> Right!
22:38:06 <ksf> in many cases, the patterns are missing
22:38:26 <ksf> which just means that the matched type wasn't a sum type
22:38:36 <ksf> but the case makes strictness explicit.
22:40:27 * ksf wonders whether he can implement writeFasta by changing printSeq to operate even more on pointers
22:41:31 <nolrai_FG> ksf: so stictness is handled by having case (x:xs) of l {__DEFUALT -> l}?
22:41:36 <nolrai_FG> somthing like
22:41:46 <ksf> I don't know what __DEFAULT means
22:42:22 <ksf> I'm actually zenning the core, not looking at the cases but scanning the whole thing to figure out where my code ended up.
22:42:58 <ksf> I don't look at core to do strictness stuff.
22:43:21 <nolrai_FG> makes sense. I wouldn't.
22:45:18 * ksf guesstimates it's the compiled down version of otherwise
22:45:39 <nolrai_FG> ksf: thats what I think too. basicly _ ->
23:20:53 <astrocub> what problem does functional programming solve?
23:21:05 <ivanm> all problems
23:21:19 <kmc> @faq can functional programming solve all problems?
23:21:20 <lambdabot> The answer is: Yes! Haskell can do that.
23:21:23 <ivanm> as functional languages are typically turing-complete
23:21:34 <astrocub> yeah yeah
23:21:42 <ivanm> (yes, I'm being delibirately obtuse)
23:21:52 <kmc> astrocub, do you have a more specific question?
23:21:55 <ivanm> (however you spell that word)
23:22:13 <ksf> obscure?
23:22:15 <ksf> obese?
23:22:20 <ksf> obsessed?
23:22:20 <kmc> also what do you mean by functional programming -- first-class functions? lack of side effects?
23:22:22 <ksf> obedient?
23:22:32 <kmc> i think only the first is core to the definition, but sometimes people include the second
23:22:57 <ivanm> no, deliberately
23:23:00 <ivanm> that's the spelling
23:23:02 <astrocub> well, i'm looking at programming language right now that has a section on functional programming with it, and i figured someone in here would be able to tell me when functional programming would be useful in a hybrid scripting language
23:23:22 <ivanm> astrocub: they let you be more concise in many aspects
23:23:34 <ivanm> since you can build up meta-functions such as map, fold, etc.
23:23:55 <kmc> FP is useful for expressing "patterns of computation" which are abstracted away from the concrete thing you're doing
23:24:00 <kmc> like map, fold, etc, as ivanm said
23:24:39 <kmc> for example map is the idea of "process each member of a list", abstracted away from the details of *what* processing you're doing
23:24:52 <kmc> this is a simple example of course
23:25:05 <Gracenotes> something I like about FP is the focus on combining expressions through functions, rather than combining statements through procedure
23:25:15 <kmc> you can express complicated queries and transformation over nested datatypes this way
23:25:17 <Gracenotes> makes it more natural for dealing with data
23:25:29 <ivanm> Gracenotes: exactly
23:25:30 <kmc> @google sicp
23:25:32 <lambdabot> http://mitpress.mit.edu/sicp/
23:25:32 <lambdabot> Title: Welcome to the SICP Web Site
23:25:36 <ivanm> FP is more on what to do, rather than how to do it
23:25:43 <astrocub> it sounds similar to unit testing
23:25:52 <ivanm> whereas imperative programming typically requires you to do step by step instructions
23:25:59 <ivanm> astrocub: no, it's nothing to do with unit testing
23:26:05 <kmc> astrocub, SICP is a very good textbook on programming, with special focus on functional programming
23:26:12 <ivanm> unit testing is when you consider the behaviour of the function[s] you're testing IIRC
23:26:20 <ivanm> kmc: well, semi-functional
23:26:23 <ksf> @slap kmc
23:26:23 * lambdabot would never hurt kmc!
23:26:32 <kmc> it's basically required reading for anyone interested in programming-languages-in-general, as opposed to being a master at one particular language
23:26:32 * ksf slaps kmc, then lambdabot
23:26:36 <kmc> lambdabot, thanks
23:26:42 <ksf> SICP is _very_ procedural.
23:26:48 <ivanm> exactly
23:27:09 <kmc> no
23:27:24 <mmorrow> astrocub: instead of, say, bringing each item in a collection to you in, say, a for loop, you map a function (the for-loop body) over the collection. now, say you have a collection of collections, then you simply (map . map) your function over that, and so on. then you might have a collection of functions (for-loop bodies), and you might map "the function which takes a for-loop body and applies it to a given collection" over that collect
23:27:24 <mmorrow> ion of functions
23:27:27 <kmc> just because it has side effects doesn't mean it lacks first-class functions
23:27:39 <kmc> anyway i think it will convey well the power of first-class functions, which is the first step
23:28:01 <kmc> after that, it's a separate step to see the power of excluding side effects when possible
23:28:10 <mmorrow> astrocub: it just lets you take any chunk of code that does something, make it into a function, and start passing it places
23:28:24 <ksf> just having first-class function doesn't mean you can do any sane amount of FP
23:28:26 <Gracenotes> ksf: not /too/ procedural, there is definitely some focus on writing things through recursion
23:28:28 <ksf> hell c++ has lambdas
23:28:34 <kmc> ksf, not yet
23:28:42 <ksf> template ... struct.. .
23:28:45 <mmorrow>  (something ... another thing) ====> (\x y z -> something ... another thing)
23:28:48 <ivanm> ksf: next version of C++ will have lambdas
23:28:48 <kmc> it does not have closure
23:28:51 <kmc> lambdas are really secondary
23:28:55 <kmc> lambdas are just literal syntax
23:29:03 <kmc> you could have a language with integers  that lacks literals like "3"
23:29:10 <kmc> you can have a language with first-class functions that lacks lambda
23:29:14 <kmc> python is (nearly) in this category
23:29:20 <Gracenotes> :?
23:29:26 <ksf> e.g. java
23:29:34 <mmorrow> kmc: it'd have downward closures (iirc was part of the proposition)
23:29:41 <ksf> c++ too, if you set some values inside your struct.
23:29:53 <kmc> however, closure over free variables is essential, because it allows you to define new functions dynamically, rather than merely taking pointers to a pre-fixed finite set of functions
23:29:56 <ivanm> great, the two k.. nicks are fighting, and I have to look closely to work out which one is saying what :s
23:29:59 <kmc> :)
23:30:02 <kmc> k??
23:30:05 <mmorrow> gcc has that with the nested function extension
23:30:30 <kmc> but those don't have proper closures
23:30:34 <kmc> heh, i was just having this argument in #lisp
23:30:43 <mmorrow> heh, oh but they do
23:30:45 <ivanm> kmc: . == match single character, does it not?
23:30:54 <kmc> ivanm, in regex
23:30:56 <kmc> ? for shell glob
23:31:05 <ksf> . is any character, yes.
23:31:20 <ksf> .? is maybe a character
23:31:24 <ivanm> yes, I was using regex syntax
23:31:26 <ksf> .+ is one or more
23:31:27 <ivanm> not glob syntax
23:31:30 <ksf> and .* is any number
23:31:40 <ski> @let isK ['k',_,_] = True; isK _ = False
23:31:41 <lambdabot>  Defined.
23:34:08 <ivanm> ksf: yes, I know ;-)
23:38:25 <mmorrow> ksf: gcc's nested function extension (surprisingly) really does give you real closures http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4972
23:38:46 <mmorrow> you just can only pass them downward
23:39:01 <mmorrow> or else it's like returning the address to a var on the stack
23:39:22 <mmorrow> since the closures are stack-allocated here
23:39:54 <kmc> yeah, that doesn't count ;P
23:40:06 <ksf> that, and gcc is much to dumb to be able to inline them
23:40:26 <mmorrow> they're closures nonetheless though ;)
23:40:46 <ski> (stack-allocated closures)
23:41:24 <mmorrow> and iirc the C++ proposal for lambdas or whatever they call them is for i think exactly what the gcc nested function extension provides (modulo syntax)
23:41:43 <kmc> mmorrow, i imagine it at least lets you make a heap-allocated closure
23:41:50 <mmorrow> ski: just get hold of the stack ptr, and memcpy!
23:41:57 <kmc> i thought it was more like making the C++ "functor pattern" not suck
23:41:59 <kmc> (as much)
23:42:20 <mmorrow> kmc: i'm pretty sure it doesn't, because you really start to need GC is you go there
23:42:26 <johnw> people seem to talk about C++ a lot here
23:42:42 <ksf> http://shootout.alioth.debian.org/u64q/chartbox.php?s=eNp1j9ENxDAIQ1fCgAlMkf23Oeek9qPXy8%2BTiS0M7bzNJ5prE5kj%2BIxhF%2FIMyxIxv4ErNxBISsFX1GbRPf7lKkwWwFuK6IjNRiwXcvRX74vUSRa3GqmqjFbAjXPhPYeZlDPhpyBttfYtxpzDvuruiUbfwIoWuPoEul2HFSYzL6gubT4qgkhS&m=eNoztFDwyy9TMDIwsFQoNTMpBAAhewQY&w=eNpLT072Ty8o8E%2FPSyzxTywp9k%2FPSPbPTEsGAHTxCVY%3D
23:42:44 <ksf> see that?
23:42:51 <kmc> mmorrow, no, the closure is a C++ object like any other.  it would be e.g. quite usable with a boost::smart_ptr
23:42:54 <ksf> I want the upper bound of haskell to drop below 2.
23:42:55 <ksf> go!
23:42:55 <Saizan_> maybe we should have an #haskell-c++
23:42:59 <kmc> people already pass around heap-allocated "functors" all the time
23:43:02 <mmorrow> kmc: iirc it's explicitly stated that letting a closure escape a function results in undefined behavior
23:43:11 <kmc> damn
23:43:20 <kmc> well, another language tries and fails to copy functional programming
23:43:30 <mmorrow> just like "int *foo(){int x = 20; return &x;}"  is undefined behavior
23:45:10 <mmorrow> this is how gcc implement its nested functions http://web.pdx.edu/~hegbloom/download/Usenix88-lexic.pdf
23:45:52 <mmorrow> my favorite line in that paper is:
23:46:06 <mmorrow> "There are, however, some architectures and/or operating systems that forbid a program to generate and execute code at runtime. We consider this restriction arbitrary[10] and consider it poor hardware or software design."
23:46:37 <lament> tsotsally
23:48:45 <rasfar> i can't imagine how you'd enforce such a policy!
23:49:40 <rasfar> well, maybe i can, but i don't know any examples offhand
23:50:30 <mmorrow> hardware people don't even like programs that have any branches, let alone gasp! generate new codez
23:50:36 <Heffalump> rasfar: enforce what policy?
23:50:55 <rasfar> to forbid execution of generated code at runtime
23:51:01 <Heffalump> http://en.wikipedia.org/wiki/Data_Execution_Prevention
23:51:01 <mmorrow> ipwn!
23:51:08 <lament> rasfar: forbid manipulation of the instruction pointer
23:51:12 <mmorrow> (but for another reason)
23:51:19 <mmorrow> (@ipwn)
23:51:20 <Heffalump> you just label pages or segments appropriately
23:51:26 <Heffalump> and restrict the permission to change that labelling
23:51:58 <Heffalump> (the CPU has to help out a bit)
23:52:47 <rasfar> okay, i was naively thinking of using the filesystem, then making system calls.  clearly you'd want to avoid that in a tighter situation.
23:53:31 <mmorrow> does the iphone actually actively prevent writing to executable mem (or temporarily making it writable, or some variation on that), or do they just reject apps that do so?
23:53:53 * rasfar knows even less about operating systems than about FP
23:53:55 <mmorrow> like, do they have some special hardware protection on top of their policy?
23:54:06 <mmorrow> "special" := extra special ?
23:56:32 <astrocub> thanks for the responses, i was afk for awhile
23:59:52 <dankna> mmorrow: if I'd tested that I still wouldn't be able to tell you, as there's an NDA,
23:59:59 <dankna> but I believe you are misunderstanding their policy
