00:00:06 <josephholsten> kmc: I keep getting distracted while reading real world haskell
00:00:18 <copumpkin> bedtime for me
00:00:23 <copumpkin> this agda proof has defeated me for tonight
00:00:27 <copumpkin> but it will not last long tomorrow
00:00:36 <kmc> copumpkin, how do you think of things to prove?
00:00:51 <copumpkin> kmc: I think up random statements or things I'm interested in and try to prove hem
00:01:06 <copumpkin> right now I'm trying to prove that the standard library Natural type is not finite
00:01:14 <copumpkin> (I've proved that Bool is finite)
00:01:34 <copumpkin> later I'm gonna move on to see if I can write some basic properties of regular languages :)
00:01:39 <kmc> cool
00:01:49 <sjanssen> kmc: actually you need a paramorphism to write that function http://en.wikipedia.org/wiki/Paramorphism
00:01:51 <rasfar> g'nite copumpkin; i'm off to play a tune or two then it's bed for me also.  thanks all ya for the interesting comments!  scanl indeed.
00:02:15 <Cale> Prove the intermediate value theorem! :)
00:02:39 <kmc> hmm now i'm curious how you define "finite" in agda
00:02:43 <kmc> but perhaps that's a question for tomorrow
00:02:48 <rasfar> sjanssen: a ha!
00:02:52 <copumpkin> Cale: don't have anything to build upon yet :/
00:03:16 <copumpkin> kmc: it's rather roundabout:
00:03:16 <copumpkin> Finite : Set → Set Finite A = Σ (∃ (Vec A)) (λ v → ∀ x → x ∈ proj₂ v)
00:03:46 <copumpkin> the ∃ (Vec A) is List a, but I'm abusing it to get ∈, which List doesn't have in the standard library
00:04:22 <Cale> I'm guessing that's not "is not in bijection with a subset of itself."
00:05:10 <copumpkin> yeah, it isn't :)
00:05:23 <sjanssen> > snd $ foldr (\x (xs, ys) -> (x xs, x xs : ys)) (x, [x]) [f, g, h
00:05:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:05:30 <sjanssen> > snd $ foldr (\x (xs, ys) -> (x xs, x xs : ys)) (x, [x]) [f, g, h]
00:05:31 <lambdabot>   [f (g (h x)),g (h x),h x,x]
00:05:36 <sjanssen> kmc: actually, no para required
00:05:42 <copumpkin> it's saying there exists a "list" such that for all values in the type, they are contained in that list
00:05:53 <Cale> copumpkin: ah, I see that now :)
00:05:55 <copumpkin> it seemed like the simplest way to define it
00:06:07 <Cale> That's a much more constructive way to say it
00:06:23 * kmc is not sure what \Sigma means in Agda
00:06:25 <copumpkin> agda is my new lego
00:06:49 <copumpkin> kmc: dependent sum, basically like (,) in haskell except the _type_ of snd depends on the _value_ of fst
00:07:23 <kmc> and said type is bound by the \v ?
00:07:57 <copumpkin> well yeah, here I'm using it to encode a predicate
00:08:30 <copumpkin> \Sigma x (p x) can be read as "there exists an x s.t. p x"
00:09:01 <copumpkin> well
00:09:05 <copumpkin> \Sigma x p rather
00:09:18 <Cale> > map ($ x) . scanr (.) id $ [f,g,h]
00:09:21 <lambdabot>   [f (g (h x)),g (h x),h x,x]
00:09:56 <copumpkin> anyway, really bedtime now :)
00:11:09 <Cale> By the way, the other day I intuited from a discussion that Coq has a really strange syntax for lambda terms. :)
00:11:38 <Cale> (I've never used Coq)
00:11:48 <copumpkin> have you tried any dependently typed languages?
00:11:53 <copumpkin> I'm really enjoying agda a lot
00:11:59 * copumpkin sleeptalks
00:14:00 <Cale> I've only really read code which was written in them.
00:15:12 <copumpkin> ah :) you should try agda! lots of fun, for my noob mind anyway (if you don't mind occasional bugs)
00:16:47 <ezyang> wat http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11919#a11919
00:16:51 <leimy_> wow it's like every list comprehension in my code is causing space leaks
00:16:52 <kmc> agda syntax is approachable if you know haskell
00:17:00 <leimy_> that pretty much sucks
00:17:12 <kmc> and you're actually building GADT-like proof terms rather than writing weird implicit proof script things
00:17:19 <ezyang> weeeird error message
00:17:36 <kmc> "whilst"
00:17:39 <ezyang> Huh, it looks like I'm loading bytestring-0.9.1.4 and bytestring-0.9.1.5
00:17:42 <kmc> way to be pretentious, ghc
00:17:51 <kmc> can you hide one with ghc-pkg?
00:18:04 <ezyang> sure
00:18:11 * hackagebot upload: PTQ 0.0.4 - An implementation of Montague's PTQ. (MasahiroSakai)
00:18:53 <Cale> leimy_: what does your code do?
00:19:07 <ezyang> hmm, it still got linked
00:19:08 <leimy_> poll stuff and build up records into a Data.Map
00:19:46 <leimy_> I've got code that does some parsing based on regular expressions, also based on predefined lists and the space growth for that code is off the charts
00:19:49 <leimy_> no clue why
00:19:50 <Cale> I like how the syntax highlighter somehow highlighted 'whilst'
00:20:12 <Cale> Ah, I guess it looks kind of like a function declaration
00:20:15 <leimy_> I've been removing bad behavior by turning off laziness by sprinkling seq everywhere
00:20:23 <ezyang> excellent, hiding the later version fixed it
00:21:18 <Cale> leimy_: It's best to sprinkle seq very thoughtfully :)
00:21:40 <leimy_> Cale: I'm driving where by profiling
00:21:49 <leimy_> but I'm really new at this.
00:21:55 <leimy_> so I have no idea if I'm doing it correctly
00:21:58 <Cale> leimy_: It's not only possible to make things too lazy, but also possible to make them too strict. In this case though, probably mostly a good idea to apply some strictness.
00:21:59 <ezyang> ok, enough parsec hacking for tonight
00:22:01 <ezyang> bye bye
00:22:15 <leimy_> I pretty much want everything strict by default right now
00:22:17 <Cale> leimy_: You have a Data.Map of lists?
00:22:20 <leimy_> because I'd rather be sleeping
00:22:42 <leimy_> I have a Data.Map of lots of a record type
00:22:51 <leimy_> well not lots
00:22:56 <Cale> Okay, and the record type's fields are marked strict?
00:22:58 <leimy_> really it's like 24 records total
00:23:04 <Cale> oh, so that's not it
00:23:06 <leimy_> how do I mark record fields strict?
00:23:09 <leimy_> bang patterns?
00:23:15 <leimy_> no the problem is I get tons of input
00:23:16 <Cale> By putting ! in front of the types
00:23:19 <leimy_> and I have to parse it :-)
00:23:29 <Cale> okay
00:23:36 <leimy_> and the parsing is based on some really dumb idea I had to use regexps
00:24:04 <leimy_> can I get a strict list comprehension?
00:24:05 <jkff> And let me guess, you've accidentally the whole memory because of bytestrings?
00:24:13 <leimy_> no
00:24:16 <leimy_> I didn't use bytestrings
00:24:18 <leimy_> :-)
00:24:23 <jkff> Okay then :)
00:24:32 <leimy_> I can't figure out how they're easy to use... cuz I'm always fighting with them
00:24:46 <leimy_> too much namespace overlap, never know if I want strict or lazy
00:24:52 <leimy_> don't understand Char8 vs Word8
00:25:04 <kmc> Word8 is just a byte
00:25:09 <leimy_> yeah
00:25:16 <leimy_> but it's the interface
00:25:30 <kmc> Char8 is the same, but converts to/from Char by assuming that none of your unicode points are over 255
00:25:32 <leimy_> I can never remember which module to import.
00:25:33 <leimy_> etc
00:25:40 <kmc> well, it depends on what you want to do
00:25:40 <jkff> Use lazy iff you are going to process a stream, else use strict
00:25:54 <leimy_> kmc: I want my strings to not suck, and work like Haskell's native strings
00:26:05 <leimy_> and I don't want to import 9 different interfaces for that behavior
00:26:08 <kmc> that's a problem because Haskell's native strings suck ;P
00:26:12 <leimy_> that's what I *want* :-)
00:26:15 <kmc> the idea with bytestring is that you import only one of them
00:26:16 <leimy_> right
00:26:25 <kmc> unless you're using them in several different ways in one module
00:26:27 <leimy_> yeah , and I never know which one.
00:26:35 <kmc> and they all have the same interface, so you can switch between then
00:26:37 <leimy_> but that's ok, I've punted anyway
00:27:02 <kmc> use Char8 if you want easy conversion to/from ordinary String
00:27:03 <jkff> If you'd use bytes in an other language, use words. If you'd use chars, use chars
00:27:15 <Cale> leimy_: Is the thing short enough that I can look at it?
00:27:26 <leimy_> Cale: nope
00:27:31 <leimy_> it's pretty effing huge.
00:27:48 <leimy_> I'm mostly bitching because I'm tired
00:27:50 <jkff> How huge?
00:28:08 <leimy_> but more and more of me is feeling like he should have done this in C++, because I've fought those battles and won many many times compared to this.
00:28:22 <jkff> Is the string <100Mb?
00:28:26 <leimy_> no
00:28:32 <leimy_> but the data sizes get that big :-)
00:28:36 <leimy_> due to over-laziness
00:28:41 <Cale> leimy_: You basically want strictness wherever you're collapsing large amounts of data down into a simple result
00:28:43 <jkff> Then use lazy char8 bytestrings and you're done
00:28:51 <leimy_> Cale: that's exactly what I'm doing
00:28:55 <Cale> leimy_: For example: summing over a list of integers
00:28:58 <leimy_> It's a polling CLI like thing
00:29:09 <leimy_> example.. I send a short 10 byte command, and get about 10k back :-)
00:29:19 <leimy_> I need like 1 in every 20 lines
00:29:21 <Cale> leimy_: right, so you want to apply that principle in smaller parts of the code too
00:29:23 <leimy_> and I need to parse them
00:29:26 <jkff> And what eats all the memory?
00:29:38 <leimy_> jkff: only when I run it against my simulator that has no latency or pauses
00:29:41 <Cale> leimy_: List comprehensions you usually want to be lazy, because they go the other way
00:29:58 <leimy_> which means when I deploy this, it'll take a month to crash in the field.
00:30:15 <leimy_> well if it's not the list comprehensions, I can't figure out what it is.
00:30:17 <Cale> leimy_: but the thing which eats the list comprehension and turns it into, say, a single number, or a small summary, that's what needs to be strict
00:30:25 <leimy_> since the constructor that's gone haywire is ":"
00:30:26 <jkff> Have you used the memory profiler?
00:30:28 <jkff> Ah
00:30:31 <leimy_> yep
00:30:35 <leimy_> My problem is :
00:30:37 <Cale> leimy_: maybe something is too strict
00:30:47 <leimy_> Cale: Could be.
00:30:50 <Cale> leimy_: and you're generating lists earlier than you need them
00:30:56 <leimy_> maybe
00:30:57 <jkff> Try replacing stuff with ByteString's. Then at least you'll be sure that it is not the : as in 'a':'b':[]
00:31:16 <jkff> Do you have a lot of pattern matching on String's in the code?
00:31:21 <Cale> leimy_: So the first pass of taking 1 in 20 of the lines, that's really got to be lazy.
00:31:25 <jkff> If not, it will be nearly trivial to use bytestrings
00:32:05 <Cale> leimy_: Could you theoretically product part of your result after each line?
00:32:09 <Cale> produce*
00:32:13 <Cale> (probably not?)
00:32:23 <jkff> Is there any other constructor that occupies memory, apart from :?
00:32:38 <leimy_> nope, only certain lines "count"
00:32:44 <leimy_> and I filter those early on
00:32:51 <Cale> leimy_: right, that's good.
00:32:55 <leimy_> sadly, those filtering functions are causing all the memory chewing :-)
00:33:01 <Cale> hmm
00:33:05 <leimy_> seemingly because the filtering didn't execute yet
00:33:10 <leimy_> and it's all "thunky"
00:33:15 <leimy_> making me think it's too lazy
00:33:19 <Cale> Well, that *should* be better than doing it all at once.
00:33:23 <leimy_> heh
00:33:24 <leimy_> right
00:33:35 <Cale> Oh, how complicated is it to determine if a line is one that you want?
00:33:51 <leimy_> This is where it gets weird.
00:33:52 <Cale> Also, is anything hanging on to the entire string?
00:33:56 <jkff> leimy: Try sprinkling in some trace statements to see when things are evaluated
00:33:56 <leimy_> I accumulate data like "Expect"
00:34:05 <leimy_> then pass it off to a parser when i got what I expected
00:34:14 <leimy_> so I know the bounds when I start
00:34:18 <leimy_> or I timeout
00:34:22 <Cale> leimy_: For instance, from the middle of your algorithm, is it possible to refer to the top of the file?
00:34:30 <leimy_> it's not a file
00:34:32 <leimy_> it's a stream
00:34:39 <Cale> or stream
00:34:47 <leimy_> I don't know how I'd do that.
00:35:04 <Cale> So the variable has gone out of scope, which would be good
00:35:06 <leimy_> I have to compute the bounds
00:35:16 <leimy_> I'm capturing blocks of text
00:35:19 <leimy_> then sending it for parsing
00:36:23 <jkff> leimy_: is the code sufficiently small and open to show it on hpaste?
00:36:24 <Cale> leimy_: okay, so you get a block of text, parse it, and what comes out of the parser?
00:36:36 <leimy_> jkff: sadly no
00:37:00 <leimy_> I get a Maybe Block
00:37:09 <leimy_> and Block is either a record A or Record B
00:37:24 <Cale> okay
00:37:25 <leimy_> then I interpret that block, and update internal Data.Maps
00:37:33 <Cale> aha, okay
00:38:09 <Cale> Oh, just because it's happened before, you are compiling with -O2 of course?
00:38:29 <leimy_> Cale:  nope... should I? :-)
00:38:34 <ray> hmm, someone posted that category theory book on reddit and some cgibbard guy is the only commenter
00:38:40 <Cale> Uh, if you care at all about performance, which you do.
00:38:50 <Cale> ray: That'd be me.
00:38:55 <leimy_> Well performance is fine
00:39:01 <leimy_> till : eats all the memory :-)
00:39:10 <Cale> leimy_: right, memory performance too
00:39:10 <jkff> ray: could you show the link?
00:39:34 <leimy_> Cale: so you're telling me this will do a better job figuring out what should be strict?
00:39:42 <ray> http://www.reddit.com/r/math/comments/a15co/category_theory_steve_awodey_pdf/
00:39:46 <Cale> leimy_: In fact, it has a strictness analyser in it.
00:39:53 <leimy_> oh man
00:39:58 <ray> yeah i don't know any other cgibbards :)
00:40:03 <jkff> Thanks
00:40:11 <Cale> leimy_: (which often doesn't do as well as a human, but is much better than a human that doesn't know what they are doing ;)
00:40:22 <leimy_> Cale: I wan the compiler flag -act-like-ocaml-or-something-strict-plz-k-thx
00:40:50 <jkff> I doubt that a strictness analyzer can fix a purely algorithmic problem with strictness, but it might help.
00:41:13 <Cale> leimy_: Mostly it just takes some getting used to. Eventually it becomes obvious where you need a little extra strictness and how to structure things so that lazy evaluation is good.
00:41:38 <Cale> (often it even results in a nicer decomposition of your problem than the "obvious" strict program)
00:41:50 <leimy_> Cale: so with  -02 memory utilization is down, but it's still growing, and will eventually ruin the runtime.
00:41:56 <Cale> -O2
00:42:00 <Cale> (not 0)
00:42:07 <Cale> okay
00:42:09 <leimy_> Yeah sorry I've been up for like 20+ hours :-)
00:42:19 <leimy_> It just went from 9 to 16 K
00:42:36 <leimy_> in like 3 seconds, and it should have all the data and space it needs to do this right.
00:42:51 <Cale> K?
00:42:52 <leimy_> I don't know why things I'm not looking at are not getting GCd
00:43:01 <leimy_> Kilobytes
00:43:04 <jkff> leimy_: Have you gotten an out-of-memory error?
00:43:11 <jkff> Maybe it's just that the GC does not fire
00:43:17 <leimy_> jkff: no, but this has to run on a small system.
00:43:20 <Cale> I wouldn't even have noticed if my program went from 9 to 16 kilobytes ;)
00:43:22 <jkff> Maybe you've got enough memory.
00:43:32 <ray> 9 to 16 kelvin
00:43:33 <leimy_> OOps
00:43:35 <leimy_> meant MB
00:43:36 <jkff> Try launching your program with a very small memory limit
00:43:38 <Cale> okay
00:43:40 <leimy_> see 20+ hours again working it's magic
00:43:47 <Cale> I suppose that's more reasonable to worry about :)
00:43:50 <leimy_> now it's at 30MB
00:43:54 <Cale> okay
00:44:16 <jkff> Does your program even do a lot of GC'ing? Try launching also with +RTS -s
00:44:39 <Cale> It might be nice to take a look at what's doing the allocation
00:44:49 <Cale> Did you try profiling at all?
00:45:01 <leimy_> I'm constantly profiling
00:45:04 <Cale> okay
00:45:15 <leimy_> but the functions it graphs as the huge wasters don't look like they should be very wasteful
00:45:16 <Cale> Could you hpaste your .prof file?
00:45:35 <jkff> I've seen cases where it turned out that things are OK and just the GC does not bother freeing anything because it's not necessary yet.
00:45:41 <Cale> Or, well, a heap profile graph might be nice
00:45:51 <leimy_> a .hp?
00:45:59 <Cale> That'd do
00:46:08 <Cale> oh, I guess that might be too big to hpaste
00:46:16 <Cale> Just the .prof is okay
00:46:31 <Cale> Or pick something that it says is being wasteful and maybe we could look just at that :)
00:47:12 <leimy_> Hmmm
00:48:02 <leimy_> the formatting on the .prof file is not very uniform
00:48:52 <leimy_> oh weird.
00:48:58 <leimy_> see this program is threaded and dynamic too
00:49:11 <leimy_> like it accepts text commands, and fires off parsing/polling threads
00:49:19 <leimy_> it's got a logging thread
00:49:34 <leimy_> which claims to be using 30.7 %alloc
00:49:55 <Cale> Well, that's interesting :)
00:50:24 <leimy_> kind of
00:50:39 <leimy_> but that's not the function that the diagram seems to show is causing tons of memory allocation.
00:51:10 <mmorrow> leimy_: personally i wouldn't ever use a regular expression in a haskell program. what are you doing?
00:51:28 <leimy_> mmorrow: yeah I'm finding that to suck pretty badly right now.
00:51:50 <jkff> leimy_: Are you even using a decent implementation of regexps, or Text.Regex.Posix?
00:51:52 <leimy_> I will likely have to rewrite all of that.
00:52:00 <leimy_> Text.Regex.Posix
00:52:07 <leimy_> how would I know what's "decent"?
00:52:11 <mmorrow> err, the "what are you doing?" was meant to be a serious question, in hindsight that probably wasn't clear ;)
00:52:20 <jkff> It's about 2 orders of magnitude slower than regex-pcre and regex-tdfa for example
00:52:45 <mmorrow> leimy_: what kind of stuff are you using the regexes for?
00:53:00 <leimy_> parsing :-)
00:53:06 <mmorrow> right, but what?
00:53:18 <leimy_> the whole app has to parse
00:53:28 <leimy_> I can't get into too much detail
00:53:37 <jkff> http://www.haskell.org/haskellwiki/Regular_expressions
00:53:37 <mmorrow> csv, english, tcp packets, .. ?
00:53:47 <leimy_> text from a SMASH CLP console :-)
00:54:01 <mmorrow> @google SMASH CLP
00:54:03 <lambdabot> http://www.networkworld.com/news/tech/2004/110804techupdate.html
00:54:03 <lambdabot> Title: SMASH simplifies server management - Network World
00:55:24 <mmorrow> leimy_: looking at http://www.dmtf.org/standards/published_documents/DSP0214.pdf
00:55:30 <leimy_> yeah
00:55:32 <mmorrow> leimy_: i'd write a parser, personally
00:55:39 <leimy_> I'm wishing I had
00:55:51 <mmorrow> and use happy if i needed it to be super fast on huge amounts of input
00:56:03 <leimy_> it's not really a *huge* amount
00:56:13 <leimy_> which is why I thought regular expressions were going to be ok.
00:56:42 <mmorrow> leimy_: what's a sample chunk of input you'd parse that's of average expected size?
00:56:55 <Cale> leimy_: But yeah, be careful, because what shows up in the .prof is raw allocation, not counting GC.
00:57:30 <leimy_> Can I tell it to GC More often?
00:57:30 <Cale> leimy_: So if some part of the program uses lots of memory but immediately discards everything, it'll show up as large in the .prof, but small in the .hp
00:57:45 <leimy_> the .hp looks like a bomb went off :-)
00:57:47 <Cale> Indeed you can, but it's unlikely to help.
00:57:58 <mmorrow> leimy_: err, does this involve xml, because the spec seems to have it everywhere
00:58:00 <leimy_> speciflcally in 2 functions
00:58:04 <leimy_> both parse using Regexp
00:58:06 <jkff> leimy_: Launch the program with a smaller memory limit if you want it to gc more often
00:58:07 <mmorrow> or are you parsing the actual commands?
00:58:12 <leimy_> mmorrow: nope... no XML
00:58:27 <Cale> In order to get some idea for how often it GCs, try  +RTS -B
00:58:31 <mmorrow> so something like e.g.
00:58:33 <mmorrow> show –display targets –level all –o format=clpxml /hw1/chassis1
00:58:35 <mmorrow> then?
00:58:42 <Cale> (it will make a tiny beep at every GC)
00:59:47 <leimy_> I just learned how to get rid of the greyscale
00:59:52 <leimy_> now I can read these things :-)
01:00:07 <leimy_> mmorrow: show /system1/nsensor1
01:00:09 <leimy_> stuff like that
01:00:17 <leimy_> I send those commands, and then get pages of text back :-)
01:00:26 <mmorrow> leimy_: honestly, i'd never use regular expressions for anything that wasn't a throwaway main-only (haskell) script, and even then i'd use sed/grep/perl/whatever instead
01:00:45 <leimy_> mmorrow: this was my first time with Haskell regexp
01:01:00 <mmorrow> leimy_: but if you've already invested massive amounts of time into this, it may be worth it to try to optimize
01:01:11 <leimy_> yeah
01:01:17 <leimy_> I'm thinking the parser needs a rewrite
01:01:22 <mmorrow> leimy_: but otoh imo it'd be much better in the long term to write a parser
01:01:27 <mmorrow> yeah
01:01:34 <mmorrow> i'd rewrite it
01:01:54 <mmorrow> it's not a total loss, since you know the syntax you need to parse now
01:02:19 <mmorrow> the haskell regex libs just scare me is all :)
01:02:41 <mmorrow> i have no idea what they're doing, and can't control it
01:03:55 <leimy_> Yeah... I think I can swing it.  I'll start by deleting import Text.Regex.Posix, and see what I have to rewrite
01:04:03 <leimy_> I gotta get some sleep... Thanks guys... again! :)
01:04:11 <mmorrow> good luck
01:04:21 <leimy_> thank you!
01:04:33 <leimy_> Lucky for me the hardware i'm trying to manage isn't complete yet :-)
01:16:00 <Cale> huh, I don't understand the quote of the week featuring mauke
01:16:18 <Polarina> How do I convert Int to Num?
01:16:22 <Cale> mauke uses unpl, and lambdabot responds with... a correct response
01:16:30 <Cale> Polarina: fromIntegral
01:16:47 <Cale> :t fromIntegral
01:16:50 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:17:44 <Cale> Polarina: that means if a is any Integral (integer-like) type, and b is any type of number, then fromIntegral converts from a to b
01:21:49 <Polarina> What's wrong with this?
01:21:49 <Polarina> myavg :: (Num a) => [a] -> Double
01:21:49 <Polarina> myavg xs = (sum xs) / (fromIntegral (length xs))
01:22:08 <reltuk> if I'm in ghc is there a way to run an expression so that the "error" it signals has a stack trace or some context or something?
01:22:36 <reltuk> s/ghc/ghci/
01:27:47 <Phyx-> :P
01:31:10 <Botje> stack trace? hah! :)
01:31:35 <Phyx-> ll
01:31:36 <Phyx-> lol
01:31:38 <Phyx-> stack trace
01:31:45 <arcatan> hmm, is the idea of Traversable that you can traverse members in order
01:33:37 <Hunner> jfredett: byorgey: btw thanks for hwn
01:34:46 <kmc> Polarina, xs :: [a] therefore sum xs :: a.  a can be any Num type, not just Double
01:34:56 <kmc> :t \xs -> (sum xs) / (fromIntegral $ length xs)
01:34:57 <lambdabot> forall b. (Fractional b) => [b] -> b
01:35:36 <kmc> that's a more reasonable type for your function
01:35:44 <kmc> if you pass in [Double] you will get Double
01:36:02 <kmc> you can't in general convert any Num to a Double
01:36:07 <kmc> it could be e.g. a complex number or a matrix
01:36:11 <Polarina> Like (Fractional b) => [Double] -> b ?
01:36:30 <kmc> (Fractional b) => [b] -> b
01:36:38 <kmc> that'd be the type of myavg
01:36:47 <kmc> if you then use it with a list of Doubles, you get a Double
01:36:47 <Polarina> Ok.
01:36:59 <reltuk> can I bracket it and try to print some state or something?
01:37:02 <kmc> if you use it with a list of Rationals, you get a Rational
01:37:03 <kmc> etc
01:37:13 <Polarina> kmc: Nice, thanks.
01:37:22 <reltuk> like, what does someone do when they get an error from head...
01:38:18 <kmc> try to not use head
01:38:55 <kmc> you do get the source line, right?
01:39:01 <reltuk> nope
01:39:11 <reltuk> I mean...the source line is Prelude, no?
01:39:15 <kmc> true
01:40:59 <kmc> > assert (not $ null []) 3
01:41:00 <lambdabot>   Not in scope: `assert'
01:41:06 <kmc> it's in Control.Exception
01:41:07 <Cale> reltuk: I go to the one place where I used head in my program and I recheck my assumption that it was really a good idea.
01:41:28 <kmc> partial functions are bad
01:41:30 <Cale> reltuk: head is not a function which I take lightly. It's an assertion that a list will never be empty.
01:41:32 <kmc> it really should be named unsafeHead
01:41:52 <Cale> reltuk: In most cases you should pattern match
01:42:06 <Cale> (and then you won't forget to handle the empty case)
01:42:26 <kmc> anyway, if you did make the assumption that the list is non-empty and need to figure out why it failed, "assert" may be useful.  it gives source lines
01:42:38 <kmc> there's also the GHCi debugger
01:42:48 <Cale> also, Debug.Trace.trace can sometimes be useful for getting good testcases
01:43:00 <kmc> and for that matter QuickCheck
01:43:24 <Cale> Insert a guard at the top which is always False, but put a trace on that False which prints the parameters to your function
01:43:26 <kmc> @check \xs -> all (> 2) xs
01:43:27 <lambdabot>   "Falsifiable, after 0 tests:\n[1,1]\n"
01:44:00 <kmc> heh [1] isn't good enough?
01:44:18 <Cale> I guess shrinking didn't shrink it enough.
01:44:35 <Cale> @scheck \xs -> all (> 2) xs
01:44:37 <lambdabot>   "Falsifiable, after 0 tests:\n[0]\n"
01:45:27 <jfredett> Hunner: No prob. It's fun to do, most weeks.
01:45:30 <Cale> @check \xs ys -> reverse (xs ++ ys) = reverse ys ++ (reverse xs :: [Int])
01:45:31 <lambdabot>   Parse error at "=" (column 30)
01:45:36 <Cale> @check \xs ys -> reverse (xs ++ ys) == reverse ys ++ (reverse xs :: [Int])
01:45:38 <lambdabot>   "OK, passed 500 tests."
01:46:01 <jfredett> Hunner: I'm down with the flu this week, so it was tough to stop coughing long enough to put it together. :)
01:47:00 <kmc> @check \n -> (even n) || (all ((/= 0) . (n `mod`)) [2..n])
01:47:01 <lambdabot>   "Falsifiable, after 13 tests:\n3\n"
01:47:07 <kmc> @check \n -> (even n) || (all ((/= 0) . (n `mod`)) [2..n-1])
01:47:08 <lambdabot>   "Falsifiable, after 71 tests:\n9\n"
01:51:03 <kmc> :t maybe ()
01:51:04 <lambdabot> forall a. (a -> ()) -> Maybe a -> ()
01:51:09 <kmc> :t maybe (return ())
01:51:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
01:57:23 <Polarina> Why is an executable compiled by ghc so large for event the simplest programs?
01:58:59 <Phyx-> hmm
01:59:12 <Phyx-> how do you constrain quickCheck to only generae positive numbers again?
01:59:26 <Axman6> Phyx-: because it;s got a whole runtime system compiled with it.
01:59:43 <Phyx-> Axman6: huh?
01:59:52 <Axman6> sorry, that was for Polarina
02:00:35 <Polarina> Axman6: Thanks.
02:01:06 <Axman6> Polarina: think of having your code, plus the java VM all packaged together. it's going to be rather big
02:02:08 <Phyx-> lol, and using the ghc api slaps on another 22mb or so
02:05:38 <ManateeLazyCat> mmorrow: Hi again!
02:29:59 <ivanm> wtf? bos actually did an ANNOUNCE email?
02:30:06 <ivanm> the world must be ending... :p
02:31:03 <Axman6> heh
02:31:08 <ivanm> heya Axman6
02:35:31 <ivanm> preflex: seen Baughn
02:35:31 <preflex>  Baughn was last seen on #haskell 1 day, 29 minutes and 9 seconds ago, saying: Perhaps. You can get both of those from any ghc program with +RTS -sstderr
02:37:04 <ivanm> @tell Baughn the guy that packages haskell-mode for gentoo (ulm; not a haskell hacker) doesn't like that in 2.6.2 "make all" doesn't build the elisp files, and the VERSION=$(...) line since it doesn't work in a non-darcs environment :s
02:37:05 <lambdabot> Consider it noted.
02:37:06 <Baughn> ivanm: Ya?
02:37:07 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
02:37:10 <ivanm> heh
02:37:29 <Baughn> @clear
02:37:30 <lambdabot> Messages cleared.
02:37:42 <ivanm> Baughn: and the Changelog is missing from the tarball
02:37:50 <Baughn> ivanm: I removed the changelog
02:37:57 <Baughn> It was basically replicating darcs chnages
02:38:02 <ivanm> fair enough
02:38:24 <ivanm> what about the other two?
02:38:33 <skorpan> what's funny about (\ _ c d -> d)?
02:38:44 <ivanm> skorpan: c isn't used
02:39:12 <arcatan> http://article.gmane.org/gmane.comp.lang.haskell.cafe/65857 explanation!
02:39:22 <ivanm> @pl \ _ c d -> d
02:39:23 <lambdabot> const (const id)
02:39:27 <Baughn> ivanm: I dislike building .elc files, as the time saved is absolutely minuscule and it overrides the actual .el files if you change them
02:39:52 <skorpan> "skipped a entirely"?
02:40:18 <Baughn> ivanm: The version line is used specifically for building releases. Actually, the entire makefile is. It wasn't really meant to be used for debian; it'd make more sense to make a specialized Makefile.debian that does whatever they need
02:40:19 <skorpan> Baughn: retroj wrote a library which automagically compiles your .el if it's not up-to-date
02:40:22 <arcatan> "what's an entirely?"
02:40:28 <Baughn> skorpan: Name?
02:40:34 <Baughn> ivanm: Is this ulm fellow on irc? Can I talk to him?
02:40:48 <ivanm> Baughn: yeah, he is
02:40:50 <skorpan> Baughn: i can't recall the name right now
02:41:19 <ivanm> skorpan: I thought you had to say which .el files though...
02:41:28 <Baughn> Well, that's not a problem
02:41:29 <ivanm> and it probably isn't that great for system packages...
02:41:36 <Baughn> ..that is.
02:41:43 <ivanm> Baughn: and it's gentoo, not debian ;-)
02:41:56 <skorpan> ivanm: if so, i must have missed that part
02:42:12 <ivanm> skorpan: unless this is something else entirely *shrug*
02:42:16 * p_l had, for unknown reason, suddenly imagined Elisp version of ASDF
02:42:33 * Baughn laughs maniacally
02:42:37 <Baughn> ..yearight
02:45:27 <ivanm> what's the maniacal laughter for?
02:45:45 <p_l> I guess for ASDF
02:45:50 <ivanm> ahhh
02:54:45 <Baughn> ivanm: The idea of emacs having an asdf-alike. It's just bizarre.
02:55:04 <ivanm> I'm guessing that's the clisp build system?
02:55:13 <ivanm> it's the closest meaning of ASDF I could find on wikipedia...
02:55:15 <Baughn> CL build system
02:55:20 <Baughn> clisp is a particular CL implementation
02:55:42 <ivanm> right
02:56:41 * Axman6 keeps seeing CL and thinking OpenCL, and is terribly disappointed :(
02:56:53 <ivanm> Axman6: heh
02:56:57 <ivanm> ClosedCL :p
02:58:31 <gerry`> hello
02:58:43 <gerry`> yi can't be installed on my box
02:59:07 <ivanm> gerry`: what's the error?
02:59:30 <ivanm> note that there's a known bug when building yi with the latest data-accessor version
02:59:31 <nlogax> something about duplicate instance declarations?
02:59:40 <ivanm> nlogax: yeah, that's my guess ;-)
02:59:50 <gerry`>  Duplicate instance declarations:
02:59:51 <gerry`>       instance Category Accessor.T -- Defined at Yi/Prelude.hs:182:9-38
02:59:51 <gerry`>       instance Category Accessor.T
02:59:51 <gerry`>         -- Defined in data-accessor-0.2.1:Data.Accessor.Private
02:59:54 <gerry`> cabal: Error: some packages failed to install:
02:59:54 <nlogax> :)
02:59:58 <gerry`> yi-0.6.1 failed during the building phase. The exception was:
03:00:01 <ivanm> gerry`: downgrade data-accessor
03:00:02 <gerry`> exit: ExitFailure 1
03:00:06 <gerry`> how to fix it?
03:00:15 <ivanm> gerry`: downgrade data-accessor (*2 :p)
03:00:21 <nlogax> i grabbed a fresh version from darcs and everyone was happy
03:00:29 <gerry`> howto downgrade data-accessor?
03:00:40 <gerry`> i'm new to haskell
03:00:43 <zygoloid> or fix yi's .cabal file to require a sufficiently early version of data-accessor? :)
03:00:44 <ivanm> what are you using? cabal-install?
03:00:52 <gerry`> yes
03:00:53 <ivanm> zygoloid: yeah
03:01:00 <ivanm> let's go with zygoloid's way
03:01:08 <ivanm> gerry`: download the yi tarball and unpack it somewhere
03:01:12 <SmartGuy> any suggestions for www.artlitgames.com
03:01:24 <gerry`> ivanm: and?
03:02:06 <gerry`> i have  installed haskell-platform on ubuntu
03:02:07 <ivanm> gerry`: edit the yi.cabal file, and change the "data-accessor == 0.2.*" to "data-accessor == 0.2.0.2"
03:02:22 <ivanm> I don't think data-accessor is part of the platform, so we shouldn't have any problems
03:03:08 <ivanm> gerry`: actually, don't touch the cabal file
03:03:12 <ivanm> let's just fix the source
03:03:28 <gerry`> great
03:03:48 <ivanm> gerry`: edit Yi/Prelude.hs
03:03:48 <Saizan> --constraint="data-accessor == 0.2.0.2" too
03:04:22 <ivanm> at line 182, remove the thre lines starting with "instance Category Data.Accessor.Basic.T where"
03:04:23 <gerry`> cabal-install put src to where?
03:04:44 <ivanm> gerry`: ~/.cabal/packages/
03:04:55 <Saizan> gerry`: use "cabal unpack yi" it'll upack the tarball for you
03:05:01 <ivanm> Saizan: then he'd have to rebuild data-accessor-template as well; this removes that step
03:05:06 <ivanm> Saizan: oh, didn't know it could do that
03:05:41 <gerry`> ok, can i adjus src from .cabal/packages?
03:05:49 <gerry`> s/adjus/adjust
03:05:53 <Saizan> ivanm: if yi uses data-accessor-template then cabal-install will reinstall it against this other version of data-accessor, but ok
03:06:17 <ivanm> Saizan: it will? didn't know that...
03:06:19 <ivanm> *shrug*
03:06:28 <ivanm> gerry`: no, you need to unpack it first
03:06:42 <SmartGuy> any suggestions
03:06:53 <ivanm> Saizan: and this prevents him from doing "cabal upgrade" and rebuilding data-accessor and breaking yi
03:06:56 <ivanm> SmartGuy: for what?
03:07:08 <Saizan> ivanm: cabal upgrade is disabled :P
03:07:22 <SmartGuy> about the site i gave
03:07:47 <Saizan> SmartGuy: this channel is about the programming language Haskell, not web developement
03:08:11 <ivanm> Saizan: and him following what it says I meant
03:08:18 <ivanm> there was a site? *shrug*
03:08:33 <ivanm> SmartGuy: if you didn't use a haskell web platform, we aren't interested ;-)
03:08:46 <SmartGuy> ok i wish people would help more
03:09:03 <ski> @tell mtnviewmark snd &&& fst
03:09:04 <lambdabot> Consider it noted.
03:09:05 <gerry`>  i have changed yi.cabal, and next?
03:09:16 <gerry`> ivanm: ?
03:09:32 <ivanm> gerry`: heh, I said not to change the cabal file and change Yi/Prelude.hs instead ;-)
03:09:39 <ivanm> sorry for changing mid-stream...
03:09:51 <ivanm> SmartGuy: we help for things that are relevant
03:09:57 <Saizan> you could run "cabal install" at this point, and it should work, though :)
03:10:05 <SmartGuy> ok
03:10:07 <gerry`> do i need repack it to .cabal/package?
03:10:07 <SmartGuy> np
03:10:14 <Saizan> gerry`: no
03:10:18 <ivanm> gerry`: no, run "cabal install" inside that directory
03:10:22 <ivanm> it will use the stuff that's there
03:10:25 <gerry`> ok,thx
03:12:48 <Axman6> SmartGuy: what site? you didn't give us anything
03:13:12 <Saizan> Axman6: further above
03:13:15 <SmartGuy> I gave 5-10 min before but dont want to spam
03:15:24 <gerry`> ivanm: it works
03:15:34 <ivanm> \o/
03:16:14 <gerry`> ok,thx
03:16:34 <Axman6> SmartGuy: few things i'd change: you need some sort of border between the menu on the left and the content, and the buttons in the menu look like you've tried to make a gradient, but well, not been successful
03:16:42 <Axman6> they should also be closer together
03:17:05 <SmartGuy> ok
03:17:31 <SmartGuy> actually there is a border when u take a literature peiece for an example
03:17:33 <Axman6> and the expanding thingos just open then close when clicked on safari
03:17:39 <SmartGuy> oh
03:17:57 <SmartGuy> its actually jquery which i got from dhtml site
03:18:14 <Axman6> well, it's broked :)
03:18:43 <SmartGuy> sorry actually it works fine in mozilla jsut made it 1 month back :(
03:18:58 <SmartGuy> i have not seen in linux actually
03:19:15 <Axman6> well, you should try it with a good broswer >_>
03:19:50 <SmartGuy> ok :) actually to be honest mozilla is good
03:19:59 <Axman6> pfft
03:20:00 <ivanm> with this LLVM backend for GHC that dons linked to on the haskell reddit... wasn't this what LHC was doing?
03:20:15 <Axman6> UHC
03:20:32 <Axman6> the LHC guys decided against LLVM over C--
03:20:50 <ivanm> oh?
03:20:50 <koeien> LHC?
03:21:10 <ivanm> ummm.... doesn't GHC already go to C-- (or did, before the native codegen got good)?
03:21:11 <Saizan> i think lemmih made a LLVM backend just so it could run something without much effort
03:21:23 <ivanm> koeien: initially Lemmih's fork of JHC
03:21:26 <Axman6> ivanm:  it use C-- for the native codegen
03:21:30 <ivanm> Saizan: to start with?
03:21:30 <Saizan> however the point of LHC are the optimization at the GRIN level, afaik
03:21:32 <Baughn> ivanm: GHC goes to a fork of C--
03:21:32 <ivanm> Axman6: oh
03:21:35 <koeien> ivanm: i see
03:21:37 <ivanm> Saizan: *nod*
03:21:40 <SmartGuy> can someone promote the site to their frinds circle @Axman6
03:21:42 <ivanm> Baughn: heh
03:21:45 <Baughn> ivanm: Pretty sure it wouldn't work with the mainline version
03:21:56 <Baughn> ivanm: Oh, and haskell-mode's in portage now
03:21:57 <ivanm> Baughn: which one? this new one or LHC?
03:22:01 <Axman6> SmartGuy: when it's finished, maybe ;)
03:22:05 * Baughn shrugs
03:22:05 <ivanm> Baughn: yes, which is what I was pinging you about ;-)
03:22:09 <SmartGuy> ok :)
03:22:20 <Axman6> needs quite a bit of work first though
03:22:30 <SmartGuy> ok
03:22:35 <ivanm> since I was thanking ulm for getting it in, when he told me about make all not doing as expected, etc.
03:22:55 <SmartGuy> actually i worked on this thing a lot but maybe more is needed
03:24:48 <Baughn> ivanm: Well, I fixed those issues at least. :P
03:25:34 <SmartGuy> pls digg or bookmark if you guys like it I will work on it
03:26:12 <Lemmih> The LLVM backend for GHC is a bit more interesting than the LLVM backend for EHC since the EHC backend didn't deal with exceptions or garbage collection.
03:26:22 <Saizan> SmartGuy: stop making such requests and talking about off topic arguments, please.
03:26:43 <SmartGuy> ok sorry
03:27:33 <Lemmih> But GHC deals with the issues by doing manual stack layout which nullifies many of the advantages of LLVM.
03:27:43 <ttmrichter> Lemmih: What's this about an LLVM backend for GHC?
03:27:57 <Axman6> ttmrichter: work going on at UNSW
03:28:28 <Lemmih> ttmrichter: http://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf
03:28:46 * Axman6 actually met david at SAPLING
03:29:04 <Axman6> or, sae at least, i met some other people though (like blackdog)
03:29:08 <Axman6> saw*
03:38:22 <ivanm> Baughn: what, the makefile not doing anything? :p
03:38:36 <Baughn> ivanm: The makefile existing. ^^;
03:51:10 <jystic> Are there any good resources available for debugging space leaks?
03:51:21 <koeien> the ghc profiler is a start
03:51:58 <jystic> which switch do I need?
03:52:22 <koeien> you need to compile your program with profiling support, and then pass an option to your program at runtime
03:52:22 <jystic> or is it best to just check through the docs for ghc?
03:52:26 <koeien> it is described in the ghc docs
03:52:26 <tristes_tigres> Suppose I want to store a moderately large - million to 10 millions - table os some staff, like web links. Is there an Officially Approved(tm) way of doing this ?
03:52:37 <koeien> jystic: also, take a look at the chapter on optimization in RWH
03:52:39 <koeien> @where RWH
03:52:40 <lambdabot> is http://www.realworldhaskell.org/blog/
03:53:31 <koeien> tristes_tigres: depends on your requirements, but a relational database might be a good idea
03:54:23 <jystic> koeien: thanks :)
03:57:13 <Axman6> tristes_tigres: what sort of data? and what do you need to do with it?
03:57:50 <tristes_tigres> Axman6 and koeien: a graph, with some info for each node
03:58:06 <Axman6> hmm
04:00:08 <jkff> Looks like a perfect fit for a relational database actually :) Probably a purely key-value one, like BerkeleyDB, CouchDB etc
04:30:24 <mmorrow> tristes_tigres: if you mean store as in on-disk, i'd use sqlite
04:30:52 <mmorrow> it's easy-in-easy-out and has a cli for quick queries,
04:31:02 <mmorrow> .
04:31:30 <tristes_tigres> mmorrow: yes, store on-disk
04:31:45 <mmorrow> sqlite ftw
04:33:52 <Axman6> yeah, i highly recommend sqlite. it's insanely fast too, when compared to things like postgres and mysql
04:34:33 <ben_m> sqlite++
04:35:16 <tristes_tigres> if the datasets grows, how far it scales &
04:37:32 <Axman6> quite well, it can have multi gigabyte databases (possibly terabyte, but i can't remember)
04:38:24 <tristes_tigres> Thanks guys, I'll lok it up
04:40:32 <malosh> I need an idea for parallel dynamic programming : I currently use a lazy array, but it is very sparse. I'd like to use a map, but then each expression evaluated in parallel would have its own map, and the benefit of dynamic programming is lost. Any idea ?
04:52:14 <jlouis> malosh: can you do the dynamic programming without a memoizing table_
04:53:07 <malosh> I don't think so. I don't exactly see what dynamic programming without memoization means
04:54:41 <jlouis> malosh: the problem is quite simple: You will need simultaneous access to the table so unless you synchronize that access the benefit seems lost to me
04:55:39 <malosh> It works with a lazy array : any "ghc thread" can evaluate the items in the array, if not evaluated, and any other thread can benefit from this
04:59:52 <refold> guys, what's the status of GHC plugins? are they going to be in 6.12?
05:11:09 <Chaze> hi there
05:11:35 <ben_m> Greetings
05:11:45 <Chaze> i'm wondering if there's no other way to do operations such as simple addition on tuples than writing ugly lambdas:
05:12:03 <Chaze> say, i wanted to add all tuples of a list, i'd write
05:12:06 <Chaze> foldl (\(a,b) (c,d) -> (a+c,b+d)) (0,0) [(7,3),(4,2),(9,2)]
05:12:25 <BONUS> :t join (***) (+)
05:12:26 <lambdabot> forall b. (Num b) => (b, b) -> (b -> b, b -> b)
05:12:31 <koeien> > (+1) *** (+2) $ (1,2)
05:12:32 <lambdabot>   (2,4)
05:12:47 <BONUS> the functions in Control.Arrow are good for tuple magic
05:13:13 <BONUS> > foldl1 (join (***) (+)) [(1,2),(4,4),(2,5)]
05:13:14 <lambdabot>   Couldn't match expected type `(b, b) -> (b, b)'
05:13:15 <lambdabot>         against inferred ty...
05:13:19 <BONUS> ugh wait
05:14:59 <zong_sharo> how does haskell "evaluator" works? what about semantics? is it graph rewriting or what? yeah i know it's "lazy" but it is  intuitive definition, not precise one
05:15:15 <zong_sharo> which papers i should read, to understand this subject?
05:16:24 <Botje> zong_sharo: look into the papers about the G-machine
05:16:31 <Asztal> :t (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .)) -- :(
05:16:32 <lambdabot> forall a a1 a2. (a -> a1 -> a2) -> (a, a) -> (a1, a1) -> (a2, a2)
05:16:35 <koeien> Chaze: sum***sum . unzip
05:17:02 <zong_sharo> Botje: which of?
05:17:16 <koeien> > sum***sum . unzip $ [(1,2),(3,4)]
05:17:17 <lambdabot>   Couldn't match expected type `[a]'
05:17:17 <lambdabot>         against inferred type `([a1], [b...
05:17:40 <koeien> > (sum***sum) . unzip $ [(1,2),(3,4)]
05:17:42 <lambdabot>   (4,6)
05:17:49 <Chaze> BONUS: koeien: Thanks!
05:18:01 <koeien> you need to import Control.Arrow
05:18:19 <BONUS> yeah (sum***sum) . unzip is really neat!
05:18:40 <Botje> http://twitter.com/simonpj # we should pressure this guy to transfer his account to the real simonpj :)
05:18:40 <BONUS> or join (***) sum . unzip
05:19:45 <Botje> okay, perhaps not ..
05:20:03 <Botje> zong_sharo: have you read simonPJs book on implementation of functional programming languages?
05:20:09 <Botje> @where ifp
05:20:09 <lambdabot> I know nothing about ifp.
05:20:45 <Botje> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/V.HTM
05:20:53 <Botje> zong_sharo: it has a couple of chapters on graph reduction
05:20:53 <zong_sharo> Botje: nope, is it best way to understand semantics of haskell?
05:21:22 <Botje> it's /one/ way
05:21:32 <Botje> but that book explains the evaluation process and how to encode it
05:21:55 <refold> refold: answering myself: looks like plugins are not in the repo yet.
05:24:57 <zong_sharo> Botje: thank you
05:25:45 <Botje> hope that helps
05:25:51 <Botje> if you have any questions, fire away :)
05:34:47 * SamB_XP realizes that the default profile picture as seen in Google Reader is googley-eyed ...
05:35:16 * SamB_XP utters an inward groan
05:46:21 <sYFFAN> Lets say I want to make a data type for integers: "data Z = Zero | Succ Z | Neg Z", but I dont want to allow the constructor "Succ (Neg Z)", how can I enforce this?
05:46:59 <koeien> not directly
05:47:04 <koeien> you could create two datatypes
05:47:06 <Lemmih> sYFFAN: data Z = P Nat | N Nat
05:48:14 <sYFFAN> Oh, I see
05:57:32 <CalJohn> What is a smart direction to go in when implementing a simple undirected graph in haskell?
05:57:36 <Pellwurst> is there an easy way to install ghc 6.10.4 on ubuntu via apt?
05:58:51 * hackagebot upload: mps 2009.11.7 - simply oo (JinjingWang)
05:59:51 * hackagebot upload: bamboo-theme-mini-html5 2009.11.7 - bamboo mini html5 theme (JinjingWang)
06:02:08 <BONUS> CalJohn: no direction necessary. it's an undirected graph!!!
06:02:10 <BONUS> haha just kidding
06:02:24 <koeien> there is fgl
06:05:32 <knobo> how can I filter based on type: (filter 'only Just, not Nothing' list) ?
06:05:42 <Asztal> :t catMaybes
06:05:43 <lambdabot> forall a. [Maybe a] -> [a]
06:05:50 <koeien> knobo: that is not based "on type"
06:05:56 <koeien> @src catMaybes
06:05:56 <lambdabot> catMaybes ls = [x | Just x <- ls]
06:05:59 <Asztal> (in Data.Maybe)
06:07:15 <knobo> It works :)
06:07:50 <koeien> good :)
06:16:54 <sYFFAN> is there a function which converts [(a,b),(c,d),...] -> [a,b,c,d,...]?
06:17:15 <koeien> concatMap (\(x,y) -> [x,y])
06:17:28 <sYFFAN> thanks
06:20:27 <BONUS> or if you want it pointfree, you can do concatMap (sequence [fst,snd])
06:22:48 <nlogax> so hot
06:23:06 <sYFFAN> nice
06:29:21 <sYFFAN> I'm so rusty... Is there a function that returns the second value of a tuple when the first value is matched (in a list)? Like if I have c, I want the value d in [(a,b),(c,d),...]
06:29:30 <koeien> :t find
06:29:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
06:29:35 <koeien> :t looup
06:29:37 <lambdabot> Not in scope: `looup'
06:29:40 <koeien> :t lookup
06:29:41 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:30:02 <koeien> > lookup 2 [(1,2), (2,4), (3,6)]
06:30:03 <lambdabot>   Just 4
06:30:18 <koeien> import Data.List -- you will need this for lookup
06:30:35 <jlouis> sYFFAN: if you can guess the type, then Hoogle can answer that kind of question for you
06:31:14 <sYFFAN> great, thanks koeien and jlouis
06:31:38 <sYFFAN> I haven't touched haskell in years, but it's slowly coming back
07:11:25 <cepstrum> Hi. I have installed the HSvm-0.1.0.2.89 binding for the libsvm C library but when I call 'train' from GHCI, I get this error message:  Loading package HSvm-0.1.0.2.89 ... linking ... <interactive>: /home/andreas/.cabal/lib/HSvm-0.1.0.2.89/ghc-6.10.4/HSHSvm-0.1.0.2.89.o: unknown symbol `_ZTV6Kernel'  ghc: unable to load package `HSvm-0.1.0.2.89'. Can anyone help me?
07:12:50 <Saizan> cepstrum: i had the same problem in the past, i think the ghci linker has problems with the symbols in the C svm lib
07:13:40 <Saizan> cepstrum: that _ZTV6Kernel symbol is a V one iirc, which ld just ignores if it's not defined
07:14:05 <Saizan> (you can tell the type of symbol by using nm)
07:14:19 <cepstrum> Saizan: So it cannot be fixed...?
07:14:39 <nlogax> 13
07:14:47 <nlogax> oops
07:15:15 <Saizan> cepstrum: i honestly don't know, i didn't investigate further
07:15:35 <cepstrum> Saizan: All right, thanks
07:16:29 <cepstrum> Saizan: Do you know of any other SVM libraries?
07:18:51 <Saizan> cepstrum: no
07:19:00 <Saizan> it works when you compile though
07:19:22 <cepstrum> Saizan: Ok
07:22:43 <mr_ank> Why is there a foldl' and not a foldr' in Data.List?
07:23:00 <Saizan> foldr' doesn't really make sense
07:23:01 <koeien> would a foldr' make sense?
07:23:11 <mr_ank> yes, why not?
07:23:25 <mr_ank> i mean
07:23:27 <mr_ank> i don't see why not
07:23:32 <koeien> @src foldr
07:23:32 <lambdabot> foldr f z []     = z
07:23:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:23:40 <Saizan> because it'll make it use linear stack
07:23:42 <koeien> where would you add strictness?
07:23:54 <Saizan> if you add it to recursive call
07:23:56 <jkff> I think one'd add strictness like let r = foldr f z xs in r `seq` f x r
07:24:05 <jkff> But I can hardly imagine a situation where that is useful
07:24:41 <Saizan> you lose the nicest thing of foldr that way, i.e. that 'f' can control if and when the recursive call gets evaluated
07:24:51 <koeien> yes, it works for infinite lists now
07:25:05 <koeien> foldl doesn't, and foldl' also doesn't, but at least, foldl' is strict
07:25:13 <mr_ank> hmm i still don't know enough to understand
07:25:29 <mr_ank> i thought it was mostly a matter of grouping
07:25:35 <Saizan> no
07:25:42 <mr_ank> i mean foldr vs. foldl
07:25:42 <koeien> > foldr (\x y -> if x == 37 then 37 else x + y) 0 [1..]
07:25:44 <lambdabot>   703
07:25:50 <zygoloid> foldr' f x xs = foldr (\x y -> f x $! y) x xs
07:26:31 <Saizan> mr_ank: foldl is like doing a loop with an accumulator, while foldr f z is simple structural recursion
07:27:20 <Saizan> where each (:) of the list gets replaced with f and the final [] with z
07:27:51 <mr_ank> ohhh
07:27:59 <mr_ank> hmm
07:28:21 <mr_ank> is there a haskell bot here?
07:28:27 <koeien> lambdabot
07:28:29 <koeien> & lunabot
07:28:36 <mr_ank> cool, how do i try an expression?
07:28:39 <Saizan> you do get different grouping, but the interaction with lazy evaluation is more deep than that
07:28:58 <Saizan> > 1 + 1
07:28:59 <lambdabot>   2
07:29:03 <Saizan> like that ^^
07:29:08 <mr_ank> cool
07:29:13 <mr_ank> > foldl  (+) 0 [1..1000000]
07:29:15 <lambdabot>   * Exception: stack overflow
07:29:17 <mr_ank> > foldr  (+) 0 [1..1000000]
07:29:19 <lambdabot>   * Exception: stack overflow
07:29:21 <mr_ank> both overflow
07:29:24 <Saizan> right
07:29:27 <mr_ank> i didn't expect that
07:29:43 <ACSpike[Home]> folds are something I'm struggling to understand now too. is there a good fold specific tutorial for beginners?
07:29:47 <mr_ank> and since both overflow, i expected to have a ' version of both
07:30:07 <Saizan> mr_ank: you can't cure the foldr overflow with a ' version
07:30:16 <mr_ank> OH
07:30:24 <mr_ank> cause you still have to go all the way to the end of the list?
07:30:24 <Saizan> mr_ank: if youre function is strict on the second argument you shouldn't use foldr in the first place
07:30:52 <Saizan> mr_ank: right, a foldr' will actually cause overflows even when a simple foldr would work because of lazy eval
07:30:54 <mr_ank> i have a lisp background
07:31:18 <mr_ank> so i envision a huge cons structure in the case of foldl
07:31:45 <Saizan> foldl creates a huge thunk made of additions
07:31:55 <mr_ank> yes
07:32:05 <Saizan> and when that gets evaluated it overflows the stack
07:32:06 <mr_ank> which is a data structure, right?
07:32:19 <mr_ank> i assume it's compiled code?
07:32:20 <ehamberg> ACSpike[Home]: i really liked the paper "A tutorial on the universality and expressiveness of fold".
07:32:40 <koeien> > foldl' (+) 0 [1..1000000]
07:32:41 <lambdabot>   500000500000
07:32:44 <koeien> weee
07:32:53 <Saizan> mr_ank: well, they are lowlevel structures used by the runtime system, you can't actually look in them from haskell
07:33:08 <mr_ank> hm
07:33:16 <mr_ank> let me read brb thanks so far!!! you are very helpful
07:33:23 <benmachine> > (\x -> x * succ x `div` 2) 1000000
07:33:24 <lambdabot>   500000500000
07:33:26 <Saizan> ?wiki Stack overflow
07:33:27 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
07:33:34 <Saizan> that's also useful ^^^^
07:34:55 <Saizan> i think of thunks as reducible expressions not yet evaluated, so i don't have to think about the gory bits :)
07:36:01 <jystic> when using ghc rts profiling (via arguments such as "+RTS -hc -p") is it possible to increase the label size of the output? it seems to only allow 25-26 characters
07:36:30 <Saizan> jystic: there's an -L or -l flag
07:36:44 <jystic> Saizan: thanks, i'll look in to that
07:43:12 <ACSpike[Home]> ehamberg: I'll have to see if I can grok that one. thanks.
07:43:47 <ehamberg> you're welcome. :)
07:51:02 <niarium> Can I generate C code from a Haskell code with GHC?
07:51:43 <niarium> I googled this with all different keywords but could't find the option
07:51:47 <Zao> -fviaC -keep-hc-files ?
07:52:52 <niarium> Zao: Thanks!
07:56:46 <benmachine> -fvia-C I think
07:57:06 <benmachine> or
07:57:14 <benmachine> you can apparently do ghc -C
07:57:25 <benmachine> to produce .hc files
08:11:49 <JohnnyL> any erlang converts in here?
08:11:52 <niarium> how can I use .hc files?
08:12:28 <niarium> Like, if I want to compile them for ARM Linux?
08:13:15 <dino-> bah, completely lost track of sending updates to Janis for the HCAR. Hope sending today is not too late.
08:15:22 <byorgey> dino-: might as well try.  It probably takes him a few days to put everything together anyway.
08:21:20 <EvanCarroll> is _ special or just convention for `not going to be used` ?
08:21:41 <benmachine> it's special
08:21:48 <benmachine> > let foo x x = 4 in foo 4 3
08:21:49 <lambdabot>   Conflicting definitions for `x'
08:21:49 <lambdabot>  In the definition of `foo'
08:21:54 <benmachine> > let foo _ _ = 4 in foo 4 3
08:21:55 <lambdabot>   4
08:22:10 <EvanCarroll> hrm
08:22:13 <EvanCarroll> i wish i understood that
08:22:31 <benmachine> well basically, if you have two parameters in a function equation with the same name
08:22:34 <benmachine> it's an error
08:22:36 <benmachine> unless they are _
08:22:38 <benmachine> in which case it isn't
08:23:02 <EvanCarroll> you're creating a functin clalled foo, which accepts two arguments and returns int(4) then you're doing`in foo 4 3`
08:23:23 <benmachine> yes
08:23:24 <EvanCarroll> benmachine: ah, interesting
08:23:30 <EvanCarroll>    1. length' xs = sum [1 | _ <- xs]
08:23:47 <EvanCarroll> what about in that context? does the compiler do anything different than if you assigned xs to a
08:23:57 <benmachine> well, you can't refer to _ later
08:24:03 <benmachine> (because it might be ambiguous)
08:24:09 <benmachine> so the compiler is allowed to discard it
08:24:13 <EvanCarroll> ah
08:24:17 <benmachine> the compiler would probably discard it anyway if it wasn't used
08:24:22 <benmachine> but it's a nice way of making it explicit
08:24:30 <benmachine> which is better for the reader as well
08:24:38 <EvanCarroll> cool deal.
08:47:42 <niarium> I've just heard that GHC can compile to ANSI C. How can I actually do this?
08:48:28 <niarium> (since the -fvia-C -keep-hc-files option generates x86-dependent C)
08:51:52 <byorgey> niarium: try sending an email to glasgow-haskell-users@haskell.org
08:53:06 <niarium> byorgey: thanks. do I have to subscribe or something before I send?
08:53:13 <byorgey> yes, I think you probably do
08:53:22 <niarium> can you tell me how?
08:53:26 <byorgey> http://haskell.org/haskellwiki/Mailing_lists
08:53:51 <byorgey> oh, hmm, I guess that page doesn't mention that list
08:53:53 <byorgey> just a second
08:54:10 <byorgey> http://www.haskell.org/mailman/listinfo/glasgow-haskell-users
08:58:19 <gwern> '-- | Inquire of a certain repository whether another file lies within its ambit.' <-- my best haddock ever?
08:58:32 <byorgey> @wn ambit
08:58:34 <lambdabot> *** "ambit" wn "WordNet (r) 2.0"
08:58:34 <lambdabot> ambit
08:58:34 <lambdabot>      n : an area in which something acts or operates or has power or
08:58:34 <lambdabot>          control: "the range of a supersonic jet"; "the ambit of
08:58:34 <lambdabot>          municipal legislation"; "within the compass of this
08:58:36 <lambdabot> [4 @more lines]
08:58:47 <byorgey> well, I learned a new word today =)
09:04:10 <srush> is there an easy way to read in bitmap images
09:04:15 <srush> like imread in matlab
09:05:49 <gwern> srush: you looked on hackage yet?
09:05:55 <gwern> and what format is meant by bitmap?
09:06:06 <sporkan> in haskell-mode, is there any way to switch the indentation type on the fly?
09:07:11 <srush> BMP
09:07:15 <rupert88> can someone help me with a haskell function
09:07:29 <srush> yeah, nothing really on hackage
09:07:32 <rupert88> dot = sum (zipWith (*)[][])
09:07:38 <rupert88> why doesnt it work
09:07:40 <gwern> sporkan: C-x e a setq expression? :)
09:07:55 <CalJohn> Am I right in saying that there are no finite maps in haskell (IO or otherwise) with constant time operations?
09:08:04 <CalJohn> *for haskell
09:08:18 <sporkan> gwern: so what would that setq expression look like?  i'm inclined to believe there are a whole bunch of hooks that need to be remound
09:08:19 <Saizan> rupert88: i think you wasn "dot xs ys = sum (zipWith (*) xs ys)"
09:08:20 <sporkan> rebound*
09:08:37 <Saizan> rupert88: [] just denotes the empty list, not a placeholder for arguments
09:08:41 <rupert88> i mean i want to do
09:08:45 <gwern> CalJohn: well, in general there are no finite maps period with constant time indexing; but haskell has so many arrays and whatnot I'd be surprised if there were none for your specification
09:09:03 <rupert88> sum (zipWith (*)[1,2,3][3,2,1])
09:09:12 <Pellwurst> is there a function like "filter" that returns not only the filtered elements but also the other elements? for example "filter (>3) [2,3,4,5] ---> ([2,3],[4,5])
09:09:14 <rupert88> something like that
09:09:32 <CalJohn> gwern: ok, i will have to have a look around then, thanks
09:09:46 <Pellwurst> found it ^^
09:09:52 <Saizan> > let dot xs ys = sum (zipWith (*) xs ys) in dot [1,2,3] [3,2,1] -- rupert88
09:09:54 <lambdabot>   10
09:10:23 <gwern> srush: there are 2 packages on hackage which claim to support bmp at least partially
09:10:33 <gwern> perhaps brush up on your investigative skills
09:10:43 <rupert88> thanks
09:10:50 <rupert88> does it have to be xs
09:10:55 <rupert88> or could it just be x
09:11:16 <sporkan> maybe i'm thinking about my problem in the wrong way, but in parsec, is there a "EOF" combinator?  e.g. i want to parse a file and make sure it contains only As or Bs and then nothing else...  many (oneOf "AB") >> what?
09:11:33 <gwern> rupert88: it could be. 'xs' is just convention, sort of hungarian notation; you'll see stuff like (x:xs), where x is the head, 'a', and xs is the tail, '[a]'
09:11:33 <knobo> is there a function like exist in haskel: exist 1 [1,2,3] -> true, exist 0 [1,2,3] -> false
09:11:35 <Saizan> rupert88: it could be any valid variable name
09:11:40 <sporkan> knobo: elem
09:11:45 <knobo> thanx
09:11:45 <sporkan> > 1 `elem` [1,2,3]
09:11:46 <lambdabot>   True
09:11:49 <gwern> @hoogle a -> [a] -> Bool
09:11:51 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
09:11:51 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
09:11:51 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
09:12:16 <rupert88> ok
09:12:19 <rupert88> thanks guys
09:12:21 <Saizan> sporkan: there is an eof, yes
09:12:51 <sporkan> ...ffs, it's called eof.  ...
09:13:07 <gwern> @hoogle eof
09:13:07 <lambdabot> Text.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
09:13:07 <lambdabot> Text.ParserCombinators.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
09:13:07 <lambdabot> Text.Read EOF :: Lexeme
09:14:44 <knobo> Yes! I did it :) My first program in haskell :D
09:14:56 <ehamberg> knobo: yay! congrats. :)
09:16:05 <knobo> I think could use some help to look it through, to make it more haskell ideomatic.
09:16:26 <Botje> put it on hpaste.org, and we'll take a look
09:16:43 <Botje> don't take offense if dons or Cale reduce your program to a oneliner, though :)
09:17:15 <knobo> Botje: I would like that :)
09:17:52 <jmcarthur> me least favorite thing about type composition: newtype wrappers
09:18:46 <jmcarthur> stuff like "Foo . cofree x . Bar . free . Right . O", while not very complicated, just reeks of boilerplate
09:18:57 <jmcarthur> and it's not entirely clear what's going on
09:19:19 <jmcarthur> i suppose i could build more functions over the inner abstractions and use those instead
09:19:29 <jmcarthur> but that's a lot of work
09:19:51 <Saizan> hehe, edwardk made kata for a reason :)
09:19:55 <jmcarthur> yeah
09:21:22 <Saizan> however yeah, more combinators help
09:23:09 <knobo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11922#a11922
09:23:32 <knobo> But there is no comments there.
09:23:38 <jmcarthur> another thing: sometimes it seems like it would be fine to leave a composed type as a type alias instead of a newtype, but then i can't use generalized newtype deriving to statically verify that the type is an instance of the type classes i thought it was
09:23:59 <knobo> Maybe I shold add some comments so you would understand what it is.
09:24:06 <Baughn> Saizan: kata?
09:24:07 <jmcarthur> and i guess i could create throwaway types just for that, but that's silly looking
09:24:18 <jmcarthur> Baughn: #kata
09:24:23 <c_wraith> knobo:  It's pretty standard to supply type annotations for top-level functions
09:24:38 <c_wraith> knobo: or rather, top-level declarations.
09:24:52 <knobo> c_wraith: I don't know how to do that.
09:25:22 <c_wraith> colors :: [Int]
09:25:42 <c_wraith> color :: (Int, Int, Int) -> Int
09:25:47 <c_wraith> for instance, anyway
09:26:05 <c_wraith> it makes it easier to figure out what you're looking at.
09:27:31 <arsenm> hi, I'm having problems getting cabal to build my library and test programs in place without installing
09:28:05 <Botje> knobo: you can make binary functions infix
09:28:21 <Botje> knobo: for example, okNode graph node = color node `notElem` map color graph
09:28:55 <c_wraith> knobo: as a more substantive suggestion, I'd use a type for the colors, instead of a list of ints.
09:29:17 <Saizan> arsenm: do you know about --inplace?
09:30:01 <arsenm> Saizan: I've tried that, but it still isn't happy
09:30:33 <arsenm> I'm doing runghc Setup.hs configure --user; runghc Setup.hs register --inplace --user; runghc Setup.hs build
09:31:02 <Saizan> arsenm: register goes after build
09:32:32 <arsenm> Saizan: that's what I thought, but I have the same problem either way somehow
09:33:28 <Saizan> arsenm: what problem specifically? can you paste the log on hpaste?
09:33:35 <knobo> c_wraith: how do I declare function that takes tupples?
09:33:39 <arsenm> It complains about a bunch of hi files missing (use --force to override), and then finally says it can't find the .a file on library path
09:34:38 <c_wraith> knobo:  my second example there was an example of taking a 3-tuple
09:34:54 <rupert88> in haskell can you apply a function to a function like i lambda calculas?
09:34:58 <rupert88> as far as im aware aka recursion?
09:35:11 <sporkan> :t fix
09:35:12 <knobo> aha, yes it was...
09:35:16 <lambdabot> forall a. (a -> a) -> a
09:35:30 <rupert88> its a rather vague question in an assessment
09:35:50 <sporkan> fix is the Y combinator
09:35:53 <sporkan> @src fix
09:35:53 <rupert88> anyone?
09:35:54 <lambdabot> fix f = let x = f x in x
09:35:59 <arcatan> that's not exactly recursion, but yeah, you can apply a function to a function
09:36:12 <knobo> Then I would like to use names for colors and countries
09:36:14 <Saizan> arsenm: that seems what happens if you do register before build
09:36:15 <rupert88> whats different about it
09:36:20 <knobo> How do I do that?
09:36:22 <sporkan> functions taking functions as arguments or "returning" functions are known as higher-order functions
09:36:29 <knobo> in lisp I use symbols
09:36:41 <c_wraith> knobo:  use a data type
09:36:56 <c_wraith> knobo:  data Colors = Red | Blue | Green | Purple
09:37:40 <c_wraith> knobo:  Probably with a deriving clause.  I'm sure you'd want something like "deriving (Eq, Show, Enum, Bounded)"
09:37:46 <knobo> So, who would the setColor fucntion be like then?
09:37:50 <rupert88> so whats different to recursion then?
09:37:57 <arcatan> rupert88: in recursion, you define the function using the function itself
09:38:06 <arsenm> Saizan: It does this regardless of the order, I've tried both
09:38:17 <c_wraith> knobo: I'm not sure if you'd actually want Enum and Bounded, but they're available, and possibly useful.
09:38:27 <rupert88> it seems the same to me
09:38:46 <sporkan> rupert88: aiui, in lambda calculus you need something like the Y combinator to express recursion, while in haskell you can refer to yourself
09:39:11 <c_wraith> knobo:  If you used your own type for colors, like I suggest with a data declaration, you actually wouldn't change the body of that function at all.  Only its type would change.
09:39:27 <rupert88> can you give examples for me
09:39:35 <rupert88> so i can hopefully understand better
09:40:08 <knobo> What do you call the data inside the Colors type. It looks like symbols for me.
09:40:09 <Cale> In the untyped lambda calculus, you can write yourself a Y combinator, but it won't typecheck.
09:40:21 <eldragon> @google ski
09:40:23 <lambdabot> http://www.ski.com/
09:40:23 <lambdabot> Title: Ski Vacations - Ski Vacation Packages to Ski Resorts
09:40:31 <eldragon> @google ski combinator
09:40:32 <lambdabot> http://en.wikipedia.org/wiki/SKI_combinator_calculus
09:40:32 <lambdabot> Title: SKI combinator calculus - Wikipedia, the free encyclopedia
09:40:49 <sporkan> rupert88: f n = 1 + f (n - 1) <- that's recursion
09:41:03 <c_wraith> knobo: They're referred to as constructors, as they *can* take arguments, if you declare a more complex type.
09:41:11 <Cale> In typed lambda calculi, typically you can just add a combinator for finding fixed points explicitly, and give it the type (a -> a) -> a, but this is akin to adding recursive definitions directly to the language.
09:41:31 <sporkan> rupert88: map (\x -> x + 1) [1..] <- that's applying functions to functions, i.e. map is a higher-order function
09:41:45 <arsenm> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11923#a11923
09:42:03 <c_wraith> knobo:  For instance, Maybe is "data Maybe a = Nothing | Just a".  Nothing doesn't take an argument, but the Just constructor does.
09:42:54 <knobo> c_wraith: so it's like a structure, or object?
09:43:02 <c_wraith> knobo: yes
09:43:12 <Cale> In Haskell, we have the interesting situation that you can use a newtype to effectively write the combinator which you would have used in the untyped lambda calculus too. So even if Haskell didn't have recursion at the value level or explicit fixed points, we could recover recursion through a type like newtype Rec a = In { out :: Rec a -> a }
09:43:20 <knobo> hmm: No instance for (Eq Colors)
09:43:26 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
09:43:45 <c_wraith> knobo:  You need to add "deriving (Eq, Show)" at the end of the data line
09:43:56 <sporkan> deriving (Eq, Show, Read, Data, Typeable) :)
09:44:43 <Saizan> arsenm: what command did you run there?
09:44:43 <c_wraith> knobo:  Eq allows you to use the == operator.  Show allows you to print them.  There are other things you can derive, but don't worry about them until you need them. :)
09:44:53 <Cale> So recursion at the type level is enough to recover recursion at the value level :)
09:45:11 <arsenm> Saizan: runghc Setup.hs configure --user; runghc Setup.hs build; runghc Setup.hs register --inplace --user
09:45:34 <Saizan> arsenm: ok, the problem is that the build step failed because of "Setup.hs: can't find source for Graphics.UI.Clutter in demo,
09:45:47 <Saizan> dist/build/autogen
09:45:53 <Saizan> arsenm: so you've to fix that
09:46:47 <Cale> rupert88: Not sure if that's the explanation you were looking for or not :)
09:47:03 <arsenm> Saizan: I'm pretty sure it should be finding it from my cabal file. I set it for finding the source in dist/build for a while but then It ends up rebuilding the whole library for each executable, which is just wasting too much time
09:47:30 <Cale> rupert88: Of course, if we interpret your question another way, it's just asking if we have higher order functions, and sure, we have lots of those :)
09:48:18 <Saizan> arsenm: dist/build shouldn't ever be the source dir, where is the source file for that module in your tree?
09:48:39 <c_wraith> didn't dcoutts say that a near-future version of cabal is smarter about not rebuilding things for every target if the build options are always the same?
09:48:47 <Saizan> arsenm: however, in Cabal < 1.8 there's no way to avoid rebuilding everything for every executable
09:48:47 <rupert88> hm  i sort of get it
09:49:14 <Saizan> c_wraith: in Cabal-1.8 an executable can depend on library in the same package
09:49:21 <arsenm> Saizan: does it matter that I'm using c2hs, which preprocesses to actual .hs files that ghc uses and puts them in dist?
09:50:15 <Saizan> arsenm: it shouldn't matter, Cabal will preprocess the .chs files for you, though it could go wrong if they import each other
09:50:44 <Saizan> or are you preprocessing the .chs files manually for this reason?
09:50:57 <arsenm> I'm not
09:51:30 <Saizan> so, do you have a demo/Graphics/UI/Clutter.chs ?
09:52:15 <arsenm> Saizan: I have ./Graphics/UI/Clutter has the library stuff, and ./demo has a bunch of test programs
09:52:39 <arsenm> Saizan: and by the library stuff I mean a bunch of .chs files,
09:52:46 <arsenm> the demos are regular .hs
09:52:59 <Saizan> then you should add "." to source-dirs
09:53:27 <Saizan> unless you switch to Cabal-1.8 and use this new feature
09:53:40 <Saizan> that let the executables depend on the library
09:53:45 <arsenm> Saizan: is that the version that will ship with ghc 6.12?
09:53:50 <Saizan> yes
09:54:17 <Saizan> you can install it on older ghc's too
09:54:22 <arsenm> Saizan: thanks
09:54:47 <Saizan> you'd have to add clutterhs to the executables' build-depends
09:55:03 <arsenm> ok
09:56:41 <Saizan> http://www.haskell.org/cabal/code.html
10:09:43 <rupert88> so is map an example of higher order function?
10:09:52 <Vanadium> yes
10:10:32 <rupert88> but it doesnt take a function and apply itself to it
10:10:39 <rupert88> i was wondering if haskell lets you do this
10:10:54 <rupert88> but i was confused as this seems to be simple recursion
10:10:55 <c_wraith> rupert88:  fix does taht
10:11:08 <c_wraith> :t (1:)
10:11:09 <lambdabot> forall t. (Num t) => [t] -> [t]
10:11:16 <c_wraith> > fix (1:)
10:11:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:11:25 <ben_m> :t fix
10:11:26 <lambdabot> forall a. (a -> a) -> a
10:12:57 <kmc> rupert88, HOF means a function that takes another function as an argument
10:13:06 <kmc> which map does
10:13:07 <kmc> :t map
10:13:08 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:13:20 <rupert88> can you make a function which takes itself as an argument
10:13:31 <kmc> no, it would have an infinite type
10:13:33 <sporkan> > id id
10:13:34 <lambdabot>   {()->()}
10:13:37 <sporkan> :OOO
10:13:43 <sporkan> > id id 3
10:13:44 <lambdabot>   3
10:13:55 <sporkan> > const const 3
10:13:56 <lambdabot>   {()->{()->()}}
10:13:56 <rupert88> why would it be inifinite
10:13:57 <kmc> those two ids have different monomorphic types
10:14:02 <rupert88> only if you dont set a limit
10:14:03 * hackagebot upload: pathtype 0.0.1 - Type-safe replacement for System.FilePath etc (BenMoseley)
10:14:04 <Vanadium> Did we just build a show instance for functions?
10:14:22 <rupert88> surely you could have a counter to stop when it has called itself x times
10:14:26 <kmc> rupert88, if f has type A -> B, then its argument has type A.  if f takes itself as an argument, then A = A -> B
10:14:41 <sporkan> rupert88: that's hackish and reminds me of javascript
10:14:41 <kmc> rupert88, "infinite type" has nothing to do with whether the runtime behavior is an infinite loop
10:15:03 <rupert88> explain infinite type?
10:15:05 <kmc> :t \f -> f f
10:15:06 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:15:06 <lambdabot>     Probable cause: `f' is applied to too many arguments
10:15:06 <lambdabot>     In the expression: f f
10:15:10 <rupert88> so it cant be done in haskell
10:15:14 <kmc> rupert88, i just did
10:15:19 <rupert88> and it can be done in lambda
10:15:19 <kmc> it can be done with more effort
10:15:22 <rupert88> callculus
10:15:30 <kmc> it can't be done in the simply typed lambda calculus
10:15:34 <kmc> or in System F
10:15:43 <kmc> it can be done in the untyped lambda calculus
10:15:44 <monochrom> it can be done in untyped lambda calculus. it can't be done in typed lambda calculus.
10:16:01 <Cale> rupert88: You sort of can make a function which takes itself as an argument, but you need an appropriate newtype wrapper to ensure that there are no infinite types.
10:16:13 <Cale> newtype Rec a = In { out :: Rec a -> a }
10:16:17 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
10:16:19 <dolio> @type \(f :: forall a. a -> a) -> f f
10:16:20 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
10:16:45 <kmc> there are lambda calculi with infinite types i think
10:16:57 <Cale> The In and out functions are isomorphisms, and they're removed by compilation anyway.
10:17:10 <Cale> so you're left with the usual y combinator there :)
10:17:12 <dolio> @kind forall a. a -> a
10:17:14 <lambdabot> *
10:17:35 <rupert88> hmm im really confused some say it will generate infinite type so no
10:17:43 <rupert88> and some say yes
10:18:05 <kmc> rupert88, the problem with infinite types is that we need two ways to look at them.  in the case A = A -> B above, any A could also be rewritten to A -> B, arbitrarily deep
10:18:07 <kmc> does that make sense?
10:18:41 <kmc> what Cale is showing is that we can get away with this in Haskell, but only by making explicit when we want to wrap A->B into A, and when we want to unwrap A to A->B
10:18:45 <monochrom> Do you think there is only one lambda calculus?
10:20:17 <rupert88> the question basically says the lambda calculus weve been studying allows functions to be used as their own arguments
10:20:24 <rupert88> can haskell do this
10:20:50 <Twey> @src fix
10:20:50 <lambdabot> fix f = let x = f x in x
10:21:09 <Cale> rupert88: as I've just shown, the answer is "yes, but not directly"
10:21:29 <Cale> rupert88: Since it's typically a stupid thing to do, you have to jump through some hoops to do it
10:21:40 <kmc> and because it'd confuse the type inference system, i believe
10:21:51 <Cale> You can do type inference for infinite types
10:21:56 <dolio> λ(f : Π A:*. A → A) → f@(Π A:*. A → A) f would appear to be an example of passing a function to itself in F2.
10:22:04 <Cale> It's just that most instances of infinite types in real programs are bugs.
10:22:19 <Cale> and so it would be bad for the typechecker not to catch them as errors
10:22:32 <dolio> Of course, there's only one such f.
10:23:06 <mm_freak_> why is 'fix' defined so strangely?
10:23:10 <mm_freak_> fix f = f (fix f)
10:23:30 <dolio> fix f = f (fix f) doesn't build circular structures when applicable.
10:23:31 <Cale> mm_freak_: or   fix f = let x = f x in x
10:23:41 <Cale> mm_freak_: (which is more efficient)
10:23:49 <rupert88> can you find out if something is a particular type in haskell?
10:23:56 <kmc> rupert88, find out how?
10:23:58 <rupert88> or is it assumed by the way you use a function
10:24:02 <mm_freak_> Cale: ah, i understand, thanks
10:24:29 <kmc> in your interactive environment you can ask
10:24:30 <kmc> :t map
10:24:30 <rupert88> can i find out a variable im using is type Int for instance
10:24:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:24:40 <kmc> rupert88, it's known at compile time whether it is
10:24:51 <kmc> if you want to note this fact in your code, add a type signature
10:24:58 <kmc> they're rarely necessary but they serve as machine-checkable documentation
10:25:02 <FunctorSalad> idea: ADT and fold designer, as a website
10:25:16 <FunctorSalad> you could have boxes: [ ] Histo [ ] Zygo [ ] Prepro
10:25:21 <rupert88> so you cant check for type in haskell and use it in an if statement for instance
10:25:28 <kmc> nope
10:25:40 <kmc> what we'd do instead is define a single type with multiple "constructors"
10:25:41 <Cale> rupert88: Types are removed when the program is compiled.
10:25:42 <aavogt> you can use Data.Dynamic
10:25:48 <kmc> @src Maybe
10:25:49 <lambdabot> data Maybe a = Nothing | Just a
10:25:49 <Cale> rupert88: They only exist at compile time.
10:26:04 <kmc> so you know something is of *type* Maybe Int, but the actual value could be either Nothing or Just 7
10:26:10 <kmc> and you can use pattern matching on those
10:26:19 <kmc> (the if statement is not very important in haskell)
10:26:20 <Cale> rupert88: In fact, most Haskell datatypes have an astoundingly similar representation at runtime.
10:26:29 <rupert88> can you say if there is an input do this otherwise do that
10:26:49 <Cale> rupert88: I don't understand the question.
10:26:56 <Cale> "If there is an input"?
10:27:08 <kmc> rupert88, in Haskell we don't define functions in terms of what they "do"
10:27:08 <byorgey> rupert88: you can have a function which takes an input of type  Maybe Int, for example.  is that what you mean?
10:27:18 <kmc> we define a function in terms of the result value for some input value
10:27:22 <kmc> just like in math
10:27:39 <byorgey> then you could pass the function an Int by saying  'Just 3', for example, or if you don't want to give it an input you can pass it 'Nothing'
10:28:23 <rupert88> so i would i do if i get list as input then do x else create the list
10:28:31 <kmc> that makes no sense
10:29:03 <Cale> rupert88: What's the type of your function?
10:29:10 <Cale> rupert88: Think about the type first, then write the code.
10:29:15 <FunctorSalad> you want a "Maybe [Bla]" input
10:29:19 <FunctorSalad> *you'd
10:29:38 <Cale> foo Nothing = [1,2,3]
10:29:41 <Cale> foo (Just x) = x
10:30:07 <Cale> foo :: Maybe [Integer] -> [Integer]
10:30:17 <kmc> rupert88, you should ask yourself "what is the output for this input".  not "what steps does the function perform"
10:30:21 <Cale> Is that the sort of thing you mean?
10:30:44 <Cale> and indeed, I agree with kmc's advice :)
10:30:55 <aavogt> are gread and gshow more or less efficient than the non-generic ones?
10:31:00 <rupert88> hmm i dunno a friend was asking it
10:31:04 <FunctorSalad> hmm... recursive definitions could be understood to fall under "what steps"
10:31:40 <Cale> FunctorSalad: As could functions defined as composites of other functions
10:31:48 <kmc> it's not that we never think about process, but haskell is much less process-oriented than most languages
10:31:55 <Cale> yeah
10:32:04 <kmc> we like to consider "how" to be a detail for the compiler to work out, whenever possible
10:32:04 <monochrom> I have unified "what is the output" and "what are the steps". Example: "what is the output" I want the output to be g(f(h(x))); "what are the steps" the steps are g. f. h.  In fact, see how the steps are more abstract and pointfree!
10:32:28 <FunctorSalad> hehe
10:32:32 <Cale> monochrom: In that order, too ;)
10:33:35 <FunctorSalad> but I don't think kmc meant in this way
10:34:09 <Phyx-> was that a haskell joke monochrom ? or an attempt? :P
10:34:34 <monochrom> At haskell's high level it's pretty hard to distinguish specification and steps, unless you start optimizing your code.
10:34:34 <Cale> It's "ha ha only serious"
10:34:55 <FunctorSalad> specification: I want a pony
10:35:21 <rupert88> im still not getting this
10:35:23 <Cale> http://hackage.haskell.org/package/pony -- you can has pony!
10:35:28 <copumpkin> lol
10:35:43 <FunctorSalad> yes but here the steps are more complicated
10:35:44 <kmc> rupert88, are you a beginner learning haskell?
10:35:52 <kmc> are you working through some tutorial?
10:35:57 <rupert88> yes most definately
10:36:36 <Cale> "definitely"
10:36:57 <monochrom> Well, see http://www.vex.net/~trebla/weblog/pointfree.html and http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351  for how serious I am and why it is right.
10:36:58 <rupert88> so i type function1 function1
10:37:02 <rupert88> the second bit being the input
10:37:16 <kmc> rupert88, what type does "function1" have?
10:37:40 <ehamberg> http://www.d-e-f-i-n-i-t-e-l-y.com/
10:37:50 <kmc> in haskell when you're confused it's absolutely the first question you should ask
10:37:53 <kmc> "what type does this have"
10:38:24 <copumpkin> defininently?
10:38:24 <rupert88> say type is an Int
10:38:35 <kmc> function1 :: Int  ??
10:38:37 <kmc> then it's not a function
10:38:39 <kmc> > 3 3
10:38:40 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:38:40 <lambdabot>    `GHC.Num.Num t' arising f...
10:38:42 <kmc> err
10:38:49 <kmc> > let x = 3 :: Integer in x x
10:38:50 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer -> t'
10:38:50 <lambdabot>         a...
10:38:53 <rupert88> Int -> Int
10:38:57 <kmc> okay
10:39:00 <kmc> function1 has type Int -> Int
10:39:01 <Baughn> kmc: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- Not a function?
10:39:08 <kmc> no definitely not
10:39:13 * Baughn boos
10:39:22 <kmc> therefore function1 wants its argument to have type Int
10:39:23 <rupert88> i want to use the result of function1 as the input for function1
10:39:27 <kmc> ah
10:39:40 <kmc> that's not the same as the function itself being the argument
10:39:43 <Baughn> rupert88: Are you sure that sentence is right?
10:39:46 <Phyx-> :O haskell ponies?
10:39:51 <kmc> (function1 . function1)
10:39:57 <kmc> > let f = succ . succ in f 3
10:39:58 <lambdabot>   5
10:40:12 <Baughn> Or, possibly, fix function1
10:40:12 <Cale> rupert88: That's different from what you're writing
10:40:25 <Baughn> Phyx-: cabal install pony
10:40:28 <kmc> Baughn, why do you want that to be a function?  its type hasn't got a "->" in it.  it has no arguments
10:40:30 <Cale> rupert88: You're passing function1 *itself* as a parameter to function1
10:40:36 <rupert88> thats what i was asking before was it not?
10:40:40 <Cale> rupert88: Which is rarely valid.
10:40:48 <kmc> rupert88, there's a difference between f(g) and f(g(x))
10:40:51 * Phyx- goes to console
10:40:53 <kmc> (in maths notation)
10:40:58 <rupert88> i want to take a function and use the function as the argument of the function
10:41:02 <rupert88> lol
10:41:02 <Cale> rupert88: I showed you a (complicated) way to do it, but it's not something that you'd normally want to do.
10:41:05 <kmc> rupert88, you keep changing your mind
10:41:10 <kmc> <rupert88> i want to use the result of function1 as the input for function1
10:41:14 <kmc> <rupert88> i want to take a function and use the function as the argument of the function
10:41:14 <rupert88> im probably confused
10:41:16 <Baughn> kmc: It doesn't take parameters, but it seems like more than a simple value
10:41:19 <Cale> rupert88: Why do you want to pass the function as an argument to itself?
10:41:27 <Cale> rupert88: What function are you trying to compute?
10:41:31 <kmc> rupert88, those two statements contradict each other
10:41:40 <kmc> do you want f(g), or do you want f(g(x))
10:41:40 <Cale> rupert88: What's  f 0, for starters?
10:41:42 <Baughn> kmc: I like the concept of a "nullary function"
10:41:50 <kmc> Baughn, i don't!  it's a terrible hack from impure languages
10:41:58 <FunctorSalad> ehamberg: heh that guy really doesn't like that "psychic"
10:41:59 <Phyx-> hahahaha, nice "can-i-have-a-pony.exe"
10:42:01 <Baughn> kmc: Well, they're obviously not the same thing
10:42:05 <Cale> rupert88: You said that f :: Int -> Int
10:42:11 <rupert88> i want f(f(x))
10:42:12 <Baughn> Phyx-: But it's sad. I asked for a pony, I got some sillyunicorn.
10:42:18 <kmc> in Haskell we've de-muddled the concepts of "thing that takes arguments", "thing with side effects", and "thing which does computation"
10:42:18 <rupert88> i think
10:42:19 <Cale> rupert88: Oh, then just write f . f
10:42:30 <Cale> rupert88: Or (\x -> f (f x))
10:42:46 <Baughn> kmc: Yeah, except "thing that does compuation" can be either a value or a function. :
10:42:54 <kmc> but functions are values
10:42:56 <Cale> rupert88: That's not at all like f f
10:42:57 <kmc> so that's fine
10:43:03 <Phyx-> Baughn: maybe someone should make a unicorn package, import pony and extend with wings and horn
10:43:03 <monochrom> f(x) is not a function. f is.
10:43:26 <rupert88> surely as i understand it
10:43:28 <Baughn> Phyx-: Aagh! Who made a pegasus/unicorn hybrid? o_O
10:43:39 <burp> hackage spam? :P
10:43:39 <rupert88> x is a value for f the function
10:43:48 <kmc> Baughn, a lambda term is already at whnf.  it doesn't really do any computation
10:43:49 <Cale> Baughn: Don't worry, they're all mules.
10:43:50 <monochrom> f(x) is again a value.
10:43:51 <rupert88> f is the same function but using f(x) as input
10:43:52 <kmc> not until you apply an argument
10:44:11 <monochrom> f(f(x)) is not passing f to f.
10:44:16 <Baughn> kmc: I'm not talking about a lambda term. More, something like the above fibs.
10:44:27 <Phyx-> Baughn: lol, "I did now have, extending relations with that pony"
10:44:32 <Baughn> kmc: It may not be a function, but it sure does arbitrary amounts of computation if you look at it crossways
10:45:13 <FunctorSalad> pegacorn
10:45:24 <kmc> Baughn, agreed
10:45:32 <FunctorSalad> .o ( brittle basepony problem )
10:45:42 <Baughn> FunctorSalad: http://images.elfwood.com/art/m/i/michelle16/pegacorn.jpg <-- ..quite.
10:45:58 <Baughn> " Results 1 - 10 of about 229,000 for pegacorn"
10:46:00 <FunctorSalad> michelle 16? :o
10:46:08 <Phyx-> haahahah
10:46:17 * Phyx- sees the fbi busting down doors
10:46:40 <PetRat> I'm trying to use exp. exp 2.0 2.0 doesn't work. Seems to complain that I'm not using instances of Floating.
10:46:43 <Baughn> FunctorSalad: You mean, if you slightly alter the pony, the hybrids might no longer work?
10:46:52 <FunctorSalad> yes :(
10:46:52 <Cale> PetRat: exp only takes one parameter
10:46:59 <Cale> > exp 1
10:47:00 <lambdabot>   2.718281828459045
10:47:08 <Baughn> > exp 0
10:47:09 <lambdabot>   1.0
10:47:11 <PetRat> oh, what takes x to the power of y?
10:47:14 <SimonRC> do you want (**) instead?
10:47:15 <Baughn> > x ^ y
10:47:16 <c_wraith> > exp (-1)
10:47:17 <lambdabot>   0.36787944117144233
10:47:21 <lambdabot>   mueval: ExitFailure 1
10:47:27 <Cale> PetRat: Either x^y, x^^y, or x**y
10:47:42 <Cale> PetRat: depending on the definition of exponentiation and type of polymorphism you want.
10:47:53 <PetRat> okay thanks
10:47:55 <Phyx-> :t (^^)
10:47:58 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
10:48:03 <Cale> :t (**)
10:48:05 <lambdabot> forall a. (Floating a) => a -> a -> a
10:48:06 <PetRat> looks like ** works on the GHCI prompt with 2.0
10:48:08 <Phyx-> that looks way too much like a smiley
10:48:08 <Cale> :t (^)
10:48:10 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
10:48:38 <Baughn> > (^^) 3 3 -- :3
10:48:39 <PetRat> What is the difference between class Num and class Fractional?
10:48:40 <lambdabot>   27.0
10:48:48 <copumpkin> @src Fractional
10:48:48 <lambdabot> class  (Num a) => Fractional a  where
10:48:48 <lambdabot>     (/)             :: a -> a -> a
10:48:48 <lambdabot>     recip           :: a -> a
10:48:48 <lambdabot>     fromRational    :: Rational -> a
10:48:52 <Baughn> PetRat: Only some number types are fractional
10:48:55 <Cale> PetRat: The ability to perform division
10:48:57 <Phyx-> > (^) 3 3
10:48:58 <Baughn> PetRat: For example, inteers aren't
10:48:59 <lambdabot>   27
10:48:59 <c_wraith> fractional adds division
10:49:10 <Baughn> > :3
10:49:11 <lambdabot>   <no location info>: parse error on input `:'
10:49:15 <PetRat> I see, Num is a "larger" class.
10:49:15 <Cale> > 3 / 4 :: Integer
10:49:17 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
10:49:17 <lambdabot>    aris...
10:49:24 <Baughn> > 3 / 4 :: Ratio
10:49:25 <lambdabot>   `GHC.Real.Ratio' is not applied to enough type arguments
10:49:25 <lambdabot>  Expected kind `?'...
10:49:27 <Cale> > 3 / 4 :: Rational
10:49:29 <lambdabot>   3 % 4
10:49:40 <Cale> > 3 / 4 :: Complex Double
10:49:42 <lambdabot>   0.75 :+ 0.0
10:50:11 <Cale> > 3 `div` 4 :: Integer  -- Integer division is really a different operation
10:50:12 <lambdabot>   0
10:50:28 <Phyx-> :O haskell can do complex numbers?
10:50:29 <Phyx-> yay
10:50:52 <copumpkin> sure
10:50:55 <Cale> Phyx-: they don't even need to be built in :)
10:50:57 <SimonRC> yeah, but you must parameterise over they type of the components
10:51:11 <copumpkin> SimonRC: by design :) it's not an inherent "limitation"
10:51:17 <SimonRC> though it doesn't have the syntax support the some languages have
10:51:21 <SimonRC> copumpkin: I know
10:51:26 <FunctorSalad> is there a breakdown of all the haskell web packages somewhere? I'm confused
10:51:33 <Phyx-> Cale: :)
10:51:48 <copumpkin> muahahahahaha FunctorSalad is confused! our plan of avoiding success is almost complete!
10:51:49 <rupert88> what about a haskell equivalent for a java function like: func(int f){
10:51:49 <rupert88> if (f==NULL){
10:51:49 <rupert88> f=1
10:51:49 <rupert88> }else
10:51:49 <rupert88> (f=f+f);
10:51:49 <rupert88> }
10:51:51 <rupert88> func(f);
10:51:53 <Baughn> > sqrt (-1) :: Complex
10:51:53 <copumpkin> @hpaste
10:51:54 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:51:54 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
10:51:54 <lambdabot>  Expected ki...
10:51:58 <Baughn> > sqrt (-1) :: Complex Int
10:51:59 <rupert88> can that be done in haskell?
10:51:59 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
10:51:59 <lambdabot>    arising from a use o...
10:52:02 <Baughn> > sqrt (-1) :: Complex Double
10:52:03 <lambdabot>   (-0.0) :+ 1.0
10:52:07 <jkff> rupert88: This can't even be done in java
10:52:13 <Cale> rupert88: What's NULL? ;)
10:52:16 <mauke> rupert88: don't paste code in the channel, and that's not java
10:52:19 <rupert88> ok
10:52:24 <Cale> rupert88: That must be an integer which I've never heard of.
10:52:29 <rupert88> NULL can be empty type
10:52:31 <Baughn> rupert88: Haskell doesn't have null
10:52:32 <rupert88> undefined
10:52:37 <rupert88> it works in java
10:52:38 <jkff> int does not have a null value
10:52:39 <mauke> java doesn't have NULL
10:52:54 <Cale> func Nothing = 1
10:52:54 <idnar> it has null, but a value type can't be null
10:53:03 <Phyx-> think he emans javascript
10:53:05 <Phyx-> means*
10:53:09 <Baughn> rupert88: The equivalent would be something like Maybe Int, but using that would be silly if you don't ever want Nothing to actually happen
10:53:11 <mauke> javascript has no NULL either
10:53:14 <Cale> func (Just x) = func (Just (x + x))
10:53:14 <c_wraith> javascript doesn't have "NULL" either
10:53:18 <rupert88> ok so int f
10:53:40 <Phyx-> mauke: sure, but the rest of the syntax is closer to javascript then java
10:53:45 <Baughn> Cale: That looks impressively infinite
10:53:47 <mauke> not really
10:53:53 <Baughn> Cale: Better use a lazy number type.
10:54:11 <Cale> Not any *more* infinite than his original program
10:54:17 <mauke> Phyx-: you can't have func(int f) in javascript
10:54:32 <jkff> rupert88: In Haskell a) there is no null (contrary to java where every type except for value types is nullable), b) nullable types can be modeled with Maybe, and c) people put a lot more thought into whether to use a Maybe or not.
10:54:48 <Phyx-> mauke: but it's also not valid java.. *shrug* lol
10:54:48 <Baughn> rupert88: Generally speaking, your function would be written as (*2)
10:54:54 <jkff> In java people sometimes think, "Oh shit, I don't know what do I return here. Let us return null maybe."
10:54:57 <Cale> Baughn: But it's recursive!
10:55:11 <Baughn> Cale: I'm pretty sure it wasn't meant to be.
10:55:15 <mauke> Phyx-: except for the missing ';' it could be made valid
10:55:16 <rupert88> Baughn: i dont care about that
10:55:18 <jkff> And now go distinguish between an empty list, a null list, and a list of nulls.
10:55:19 <rupert88> thats a minor point
10:55:30 <Baughn> rupert88: So what are you trying to ask, exactly?
10:55:32 <rupert88> im just trying to convey what i was looking to do in haskell
10:55:42 <Cale> rupert88: What problem are you trying to solve?
10:55:47 <Phyx-> mauke: doesn't it also need a return type?
10:55:47 <monochrom> yeah, trying.
10:56:02 <mauke> Phyx-: yes, and a class
10:56:04 <Cale> rupert88: If you approach Haskell from the perspective of translating Java code, you will have a really hard time.
10:56:15 <monochrom> I don't understand why the questions are unclear.
10:56:16 <rupert88> 6. In the version of the lambda calculus discussed in class, functions can be applied to
10:56:16 <rupert88> themselves. Is this possible in Haskell? If it is not possible in Haskell, then use Haskell comments to explain why not. If it is possible then define a function f which allows this, and explain what
10:56:16 <rupert88> f f
10:56:17 <jkff> The answer to your question is: "The way to model nullable types is to use Maybe." But you probably should learn to *not* use it first.
10:56:21 <Cale> rupert88: It's probably better just to forget that you know how to program in another language at all ;)
10:56:22 <rupert88> thats the question
10:56:26 <rupert88> i didnt want to post it directlry
10:56:29 <rupert88> but that is it
10:56:30 <kmc> rupert88, we already answered that question 7 ways from sunday
10:56:41 <kmc> if you want a clean "yes" or "no" to put on your homework, you will have to think for yourself
10:56:58 <Cale> rupert88: The answer to that question is really more subtle than a simple 'yes' or 'no'
10:57:04 <mauke> the answer is "yes"
10:57:15 <rupert88> i realise that
10:57:17 <Twey> > fix fix
10:57:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
10:57:20 <gressvol-> what does it mean to say "depended on representation of ..."? Is it return value of a function? e.g. [Int] instead of [a]
10:57:20 <Cale> rupert88: You can't do it plainly, but there's a way to accomplish it through trickery :)
10:57:24 <Twey> Heh, drat :þ
10:57:26 <mauke> I can do it plainly
10:57:27 <c_wraith> the anser is "yes, but you're doing something wrong"
10:57:38 <mauke> > id id
10:57:40 <lambdabot>   {()->()}
10:57:46 <Phyx-> wtf
10:57:48 <jkff> O_O
10:57:50 <Baughn> > (id id) 2
10:57:50 <Cale> gressvol-: Any more context?
10:57:51 <lambdabot>   2
10:57:52 <Twey> > const const 3 2 1
10:57:52 <kmc> > let f = id in f f
10:57:53 <lambdabot>   {()->()}
10:57:53 <lambdabot>   2
10:57:54 <jkff> What was that?
10:57:59 <Cale> > (+1)
10:57:59 <Phyx-> > (+1)
10:58:00 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
10:58:00 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
10:58:04 <Phyx-> wtf
10:58:05 <mauke> jkff: show (id :: () -> ())
10:58:07 <Phyx-> hahah
10:58:08 <Heffalump> kmc: that shouldn't have worked, does lambdabot have rank-2 types turned on?
10:58:09 <Baughn> > (*2)
10:58:10 <lambdabot>   {-3->-6;-2->-4;-1->-2;0->0;1->2;2->4;3->6}
10:58:10 <Phyx-> who made that?
10:58:11 <Twey> Magic function summary ☺
10:58:12 <Cale> It's the Show instance from smallcheck
10:58:15 <kmc> yeah i was surprised too
10:58:18 <Baughn> Okay, this bot is getting way too smart
10:58:19 <Heffalump> oh, sorry, forget that
10:58:21 <Twey> Haha
10:58:22 <Heffalump> generalisation happens at lets
10:58:26 <Heffalump> it's lambdas you can't do it with
10:58:28 <Baughn> Do we need to fear our new robotic overlords?
10:58:32 <Heffalump> > (\f -> f f) id
10:58:33 <Phyx-> heck yes
10:58:33 <kmc> > (\x -> x x) id
10:58:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
10:58:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
10:58:38 <Phyx-> > fix id
10:58:42 <lambdabot>   mueval-core: Time limit exceeded
10:58:45 <Phyx-> :(
10:58:46 <Cale> :t InR
10:58:47 <Phyx-> lol
10:58:48 <lambdabot> forall a. (Rec a -> a) -> Rec a
10:58:48 <Baughn> @type fix id
10:58:49 <lambdabot> forall a. a
10:58:50 <kmc> > (\(x :: forall a. a -> a) -> x x) id
10:58:51 <jkff> lambdabot: last . iterate (+1)
10:58:51 <lambdabot>   {()->()}
10:58:52 <c_wraith> > fix const
10:58:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
10:58:58 <kmc> @nixon
10:58:59 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
10:58:59 <jkff> > last . iterate (+1)
10:59:03 <lambdabot>   mueval-core: Time limit exceeded
10:59:09 <jkff> What a pity
10:59:13 <Baughn> > id :: Int -> Int
10:59:13 <Cale> > (\x -> outR x x) (InR (\x -> outR x x))
10:59:14 <lambdabot>   {-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}
10:59:18 <lambdabot>   mueval-core: Time limit exceeded
10:59:27 <gressvol-> cale: yes "we should be able to replace the type of parsers by an abstract type, wuthout modifying any of the code in the application. However the definition of digit does depend on the representation type"
10:59:31 <Phyx-> hahaha, it's like everyone discovered a new toy
10:59:32 <Phyx-> :p
10:59:34 <Phyx-> > (^^)
10:59:35 <gressvol-> from a question
10:59:36 <lambdabot>   -0.375->
10:59:36 <lambdabot>    -3->
10:59:36 <lambdabot>      -18.962962962962962
10:59:36 <lambdabot>    -2->
10:59:36 <lambdabot>      7.111111111111111
10:59:38 <lambdabot>   ...
10:59:39 <Phyx-> :O
10:59:41 <jkff> Haha
10:59:56 <Cale> gressvol-: The representation of parsers, that is.
10:59:59 <jkff> > (+)
11:00:01 <lambdabot>   -3->
11:00:01 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
11:00:01 <lambdabot>  -2->
11:00:01 <lambdabot>    {-3->-5;-2->...
11:00:06 <jkff> Oh MY!
11:00:16 <kmc> > (++)
11:00:17 <monochrom> Because of turing-completeness, anything you "can" do in lambda calculus, you "can" do in haskell too. even in assembly.
11:00:17 <lambdabot>   {()->{()->()}}
11:00:23 <Baughn> > (,,,,)
11:00:24 <lambdabot>   {()->{()->{()->{()->{()->((),(),(),(),())}}}}}
11:00:32 <Cale> > (++) :: [a] -> [a] -> [a]
11:00:33 <lambdabot>   []->
11:00:34 <lambdabot>    {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
11:00:34 <lambdabot>  [()]->...
11:00:34 <Twey> Wow, Nixon is scary :þ
11:00:39 <Phyx-> > fmap (,)
11:00:40 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
11:00:40 <lambdabot>                    GHC.Show...
11:00:43 <kmc> :t (++)
11:00:44 <sporkan> why does it show stuff like that instead of something useful, such as the kind?
11:00:45 <lambdabot> forall m. (Monoid m) => m -> m -> m
11:00:48 <kmc> oh snap
11:00:52 <Baughn> > (,,,,) :: Int -> Double -> Rational -> Char -> String -> (Int,Double,Rational,Char,String)
11:00:53 <lambdabot>   No instance for (Test.SmallCheck.Serial
11:00:54 <lambdabot>                     (GHC.Real.Ratio...
11:00:58 <kmc> (): worst monoid ever
11:01:01 <Phyx-> :k
11:01:04 <Phyx-> :k (++)
11:01:05 <lambdabot> Not in scope: type variable `++'
11:01:08 <Phyx-> oops
11:01:10 <Phyx-> :k a
11:01:10 <jkff> @remember kmc: (): worst monoid ever
11:01:10 <sporkan> Phyx-: no, i mean e.g. this:
11:01:11 <lambdabot> It is forever etched in my memory.
11:01:11 <lambdabot> Not in scope: type variable `a'
11:01:12 <sporkan> > (++)
11:01:13 <Baughn> > () `mappend` ()
11:01:13 <lambdabot>   {()->{()->()}}
11:01:14 <lambdabot>   ()
11:01:25 <Baughn> Okay, WHY is () a Monoid?
11:01:25 <sporkan> {()->{()->()}} would be more useful as * -> * -> *
11:01:26 <Phyx-> sporkan: yeah, i know
11:01:30 <FunctorSalad> maybe a table would be readabler?
11:01:38 <Cale> Baughn: Because it can :)
11:01:39 <sporkan> readabler++
11:01:39 <rupert88> ok well thanks for trying but im even more confused than ever
11:01:39 <kmc> Baughn, it's a group too!
11:01:40 <FunctorSalad> yes, only works for two args
11:01:47 <gressvol-> but im confused what it means exactly
11:01:52 <kmc> but i guess not a ring?
11:01:56 <Phyx-> rupert88: try reading RWH, might help
11:02:00 <gressvol-> is it return type form parser?
11:02:06 <jkff> ruper88: sorry, you just got into the middle of lambdabot revealing its demonic essence :)
11:02:21 <FunctorSalad> her
11:02:22 <jkff> I suspect that lambdabot has written this functionality herself.
11:02:23 <jkff> Yeah
11:02:24 <Phyx-> gressvol-: think you're question got lost somewhere, what was it?
11:02:42 <Twey> monochrom: Heh, it's funny when people misinterpret Turing completeness that way
11:02:44 <monochrom> And I thank rupert88 for trying, too.
11:02:45 <Phyx-> jkff: are you saying.. SkyNet was written in Haskell?
11:02:50 <gressvol-> it was what is meant when you state: "representation of parsers"
11:02:56 <SimonRC> Baughn: () is a monoid because sometimes you don't want to accumulate anything
11:03:00 <Baughn> Phyx-: I'm currently writing my master's thesis
11:03:04 <Baughn> Phyx-: In haskell
11:03:04 <Cale> gressvol-: It means the actual type used to represent the parsers. You can wrap an interface around parsers so that users of your library don't know how you're encoding the parsers themselves, but it's saying that how you implement 'digit' will depend on the actual data structure you use.
11:03:06 <jkff> Phyx-: As far as I can tell from the current progress of lambdabot, yes.
11:03:07 <Baughn> Phyx-: It's, um, called Skynet.
11:03:09 <SimonRC> it's a bit like the null object pattern, but not very
11:03:11 <kmc> :t InR
11:03:12 <lambdabot> forall a. (Rec a -> a) -> Rec a
11:03:14 <kmc> :t outR
11:03:15 <lambdabot> forall a. Rec a -> Rec a -> a
11:03:17 <FunctorSalad> advanced unit monoid technolofy
11:03:18 <Phyx-> Baughn: hehehe
11:03:20 <FunctorSalad> *g
11:03:32 <Twey> Turing-completeness means that a language can calculate any value, not do anything — that involves more than just output (also things like intermediate representations and code flow)
11:04:08 <Phyx-> jkff: ah, so you're saying, it got fedup with not having regular updates, and became self aware :P
11:04:13 <Baughn> Twey: No, Turing-completeness means that a language can calculate anything any other Turing-complete language can
11:04:14 <jkff> I wish everything was as simple as the () monoid. However, there is an even simpler one: data Nihil ; instance Monoid Nihil where mzero = undefined; mappend = \_ _ -> undefined
11:04:25 <Baughn> Twey: Not "any value". There are plenty of abstractions allowing more computations
11:04:28 <Twey> Baughn: That was elided sorry
11:04:34 <Twey> s/elided/elided,/
11:04:41 <Baughn> Twey: ..they're a bit messed up by the laws of physics being turing-complete
11:04:42 <Cale> jkff: That is indeed a worse monoid. ;)
11:04:43 <Twey> Urgh, WeeChat :-\
11:04:48 <sporkan> s/sorry/sorrily/
11:04:56 <Twey> Baughn: ‘They’?  The abstractions?
11:05:04 <Twey> sporkan: Heh
11:05:19 <jkff> I wonder what oleg or sigfpe could do with the nihil monoid
11:05:49 <FunctorSalad> jkff: if you allow undefined then undefined has to be the unit of any monoid
11:06:08 <Baughn> Twey: Many of them would allow for cheap implementations of Solomonoff induction.
11:06:09 <FunctorSalad> hmm or wait that's only if the mult uses the arg?
11:06:39 <gwern> @wn leptosome
11:06:41 <Baughn> Twey: As such, yes, they deserve personal pronouns.
11:06:41 <lambdabot> No match for "leptosome".
11:06:57 <gwern> stupid abcedarian wordnet
11:07:14 <Phyx-> > ($!)
11:07:15 <lambdabot>   {{()->()}->{()->()}}
11:07:24 <FunctorSalad> maybe we want monoid objects in some category of domains (but don't ask me which, the variety confuses me to no end)
11:07:41 <Cale> Well, naturally the category of Haskell types
11:07:48 <gwern> wait. how does solomonoff induction come in?
11:07:52 <jkff> Don't forget monoids in the category of endofunctors!
11:08:01 <FunctorSalad> Cale: except nobody seems to know what exactly that is ;)
11:08:30 <Cale> FunctorSalad: It has kind of a complicated and ever evolving definition.
11:08:43 <Baughn> gwern: If your computer is as intelligent as is theoretically possible (never mind physical limits), you'd /better/ consider it a person.
11:08:47 <FunctorSalad> Cale: I don't mean language extensions, just getting the lazyness right
11:09:04 <FunctorSalad> and `seq` breaks the identity law, as has been pointed out to me ;)
11:09:04 <Baughn> gwern: Even if it's actually a googol-death-inducing search algorithm.
11:09:09 <Cale> Baughn: Maybe you should consider it a god? ;)
11:09:11 <gwern> Baughn: but what if it's a... GIANT LOOK UP TABLE??? kekekeke
11:09:28 <Baughn> gwern: You can't compute the lookup table without instantiating the mind it implies
11:09:32 <gwern> Cale: well, i'd call AIXI a god except it's incomputable
11:09:33 <Cale> ALL HAIL THE GREAT LOOKUP TABLE IN THE SKY
11:09:39 <gwern> Baughn: oh, can't I?
11:09:52 <monochrom> Bush is a giant lookup table and we already honour him enough to call him "him".
11:09:56 <Baughn> gwern: Still, Solomonoff induction is about as evil as anything could ever be
11:10:00 <arcatan> but it just MECHANICAL
11:10:01 <monochrom> Hell, Bush is a small lookup table.
11:10:30 <gwern> Baughn: I will assume the multiverse, and use quantum events to generate the giant lookup table! at least one of me will create it without ever instantiating the mind it implies!
11:10:48 <FunctorSalad> Cale: as an example problem, full Hask doesn't even have an initial object
11:11:05 <FunctorSalad> I think the initiality of initial algebras goes wrong too
11:11:10 <FunctorSalad> (not sure)
11:11:27 <Baughn> gwern: I see your multiverse and raise a dragon's torque.
11:11:32 <SimonRC> Baughn: ??
11:11:41 <Phyx-> you guys scared off jkff
11:11:59 <FunctorSalad> really I'd like a decent category
11:12:21 <gwern> Baughn: I seal you and your torque in a Jupiter barrier!
11:12:27 <copumpkin> FunctorSalad: agda!
11:12:38 <Baughn> SimonRC: A hypothetical correction to the laws of physics that, if implemented, causes all timelines to converge into one. Which then disappears.
11:12:54 <SimonRC> gwern: a what?
11:12:56 <copumpkin> FunctorSalad: Agda even lets you put Set1 in Set!! ;)
11:12:57 <Baughn> SimonRC: Personally, I think the "which then disappears" bit to be unfounded hyperbole.
11:12:59 <FunctorSalad> copumpkin: hmm right, totality probably avoids all the complications
11:13:04 <gwern> SimonRC: I thought we were swapping obscure anime devices
11:13:24 <dolio> undefined isn't likely to be the unit of any monoid except Void.
11:13:26 <FunctorSalad> copumpkin: AGD is even a subcategory of Set I guess?
11:13:42 <copumpkin> FunctorSalad: I'd hope so, minus the universe polymorphism bugs that exist right now
11:13:44 <gwern> SimonRC: so I invoked rahxephon's sub-universe creation
11:13:45 <Baughn> gwern: Well, I see your jupiter barrier and raise you a giga drill breaker
11:13:46 <FunctorSalad> dolio: *if* it is a monoid with strict multiplication, then undefined has to be it
11:13:52 <dolio> Unless you use conal's magic unamb.
11:14:01 <copumpkin> FunctorSalad: actually, how do the higher universes fit into that?
11:14:10 <Twey> Void is a monoid?
11:14:10 <gwern> Baughn: you may be able to pierce the heavens, but can you pierce the light of my soul, the Absolute Terror field?
11:14:14 <FunctorSalad> copumpkin: maybe translates to Grothendieck universes
11:14:18 <FunctorSalad> (gues)
11:14:23 <copumpkin> does that make it into one of the fancy n-categories?
11:14:28 <copumpkin> oh, maybe?
11:14:42 <Phyx-> > dataTypeOf (undefined::Void)
11:14:43 <lambdabot>   Not in scope: type constructor or class `Void'
11:14:44 <FunctorSalad> n-categories are something else
11:14:48 <Twey> instance (forall a. a) Void where * = undefined
11:14:54 <copumpkin> they allow morphisms between morphisms don't they?
11:14:58 <FunctorSalad> yes
11:15:06 <Baughn> gwern: Your absolute terror field is helpless against my type-Blue psychic assaults
11:15:08 <FunctorSalad> CAT is a standard example
11:15:10 <SimonRC> now, why did it think "Void" could be a class?
11:15:15 <copumpkin> FunctorSalad: seems like agda allows that though?
11:15:19 <FunctorSalad> (natural transformations = 2-morphisms)
11:15:23 <dolio> FunctorSalad: If the multiplication is strict, then _|_ * a = _|_ = a * _|_, and _|_ annihilates anything in the monoid.
11:15:51 <gwern> Baughn: I withstood mother hutton's little kittons, what makes you think that will work?
11:16:11 <FunctorSalad> awww kittons
11:16:20 <dolio> Or is "strict" not meant as "strict function"?
11:16:27 <Baughn> gwern: If it doesn't, I'll hit you with two stages of a cosmic-string induced supernova. And then the string.
11:16:47 <FunctorSalad> dolio: oh, think I mixed up unit-ness and annihilation :(
11:16:48 * gwern wonders if FunctorSalad has read the story
11:16:51 <FunctorSalad> what was I thinking
11:16:52 <Baughn> gwern: ..actually, "mother hutton"? Reference recognition error. You win. ;_;
11:17:12 <gwern> tsk tsk. you can follow my eva references, but cordwainer smith defeats you?
11:17:48 <Baughn> gwern: I call foul. That's not an obscure anime reference at /all/.
11:18:05 <gwern> evangelion references cordwainer smith enough that it's fair game!
11:18:37 <gwern> (and it's smith's single most popular story in all likelihood, to boot)
11:19:20 <Baughn> Hum. I haven't read anything by him, though.
11:21:42 <gwern> he's pretty good. he also wrote a nice & pioneering psyops manual
11:21:56 <gwern> but avoid the novels; smith was best at the short stories
11:35:06 <mrbluesky> pidgin
11:35:09 <mrbluesky> woops
11:47:56 <Baughn> Say.. unipixel is suggesting they might as well make laptop displays with four or more primary colors - up to eight, without significant price increase
11:48:27 <Baughn> Which would make RGB obsolete.. right? How hard would it be to rework, well, everything, to handle that?
11:48:30 <ray> oh god no the end of modern civilization is upon us
11:49:00 <Baughn> ray: ..I hardly think having better color reproduction will kill off civilization.
11:49:52 <ray> well, just remember that you said that when you and an angry mob are banging on the four foot thick steel door to my shelter as the world burns
11:50:04 <ray> in glorious technicolor
11:50:42 <zygoloid> Baughn: it won't make RGB obsolete i don't think; RGB-to-whatever is easy enough (though obviously it wouldn't take advantage of the full power of the screen)
11:51:16 <ray> it'd be like SGI workstations but cheaper
11:54:18 <Baughn> ray: Mm. I suppose the main difference here is that the same pixel element is used for every color, so the only cost to having more is the cost of the actual side-mounted backlights, and lower refresh frequencies (which are, well, in 100,000s of Hz already)
11:57:10 <sciolizer> data S a = S { contains :: a -> Bool }
11:57:14 <sciolizer> instance Functor S where ???
11:57:50 <aavogt> @type fmap
11:57:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:57:52 <ddarius> sciolizer: That's not a (covariant) functor.
11:57:56 <sciolizer> I can do reverse_fmap f (S has) = S (\a -> has (f a))
11:57:58 <sciolizer> ok
11:58:02 <sciolizer> That's what I thought
11:58:09 <sciolizer> Just wanted to make sure I wasn't missing something.
11:59:07 <sciolizer> What's the difference between a covariant and contravariant functor?
11:59:14 <sciolizer> I'm only familiar with those terms in an OO setting.
11:59:22 <Baughn> instance Functor where fmap f (S a) = S (a . f)?
11:59:57 <Baughn> Looks a bit odd, but shouldn't that be fine?
11:59:58 <ddarius> sciolizer: The terms come from the same place, category theory.
11:59:59 <garrythefish> ScummVM is turning 1.0 today! Finally after 7 years, our favourite open source game project interpreting 2D LucasArts adventure games is going stable. A great day for Open Source! Join the wait, at #scummvm :)
12:00:38 <ddarius> sciolizer: A covariant functor has an fmap :: (a -> b) -> (f a -> f b) and a contravariant functor has an cofmap :: (b -> a) -> (f a -> f b)
12:00:45 <garrythefish> join this great moment, thank the guys for all the good work and show support. i just wanted to say that. :D
12:01:05 <sciolizer> ok
12:01:11 <sciolizer> Baughn: doesn't type check
12:01:11 <ddarius> Baughn: Look at the type of that.
12:01:32 <sciolizer> Baughn: or, yeah, type checks, but has the wrong type
12:01:51 <sciolizer> @index cofmap
12:01:52 <lambdabot> bzzt
12:01:58 <Baughn> @type cofmap
12:01:59 <lambdabot> Not in scope: `cofmap'
12:02:04 <copumpkin> contramap
12:02:09 <ddarius> sciolizer: Another way to say the same thing is a (covariant) functor is a functor C -> D and a contravariant functor is a (covariant) functor C^op -> D
12:02:19 <copumpkin> in categry-extras, anyway
12:02:52 <sciolizer> ^op?
12:03:05 <ddarius> The opposite category of C.
12:03:05 <copumpkin> category with all the arrows inverted
12:03:18 <sciolizer> ah
12:03:40 <Baughn> @type \f (Just (a :: a -> Bool)) -> Just (a . f)
12:03:42 <lambdabot>     A pattern type signature cannot bind scoped type variables `a'
12:03:42 <lambdabot>       unless the pattern has a rigid type context
12:03:42 <lambdabot>     In the pattern: a :: a -> Bool
12:03:59 <Baughn> @type \f (Just a) -> Just (a . f)
12:04:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> Maybe (a -> b) -> Maybe (f b)
12:04:13 * Baughn blinks
12:04:23 <copumpkin> that (.) = fmap is a mindfuck
12:04:32 <copumpkin> not a huge fan
12:04:37 <Baughn> ..no...
12:08:52 <sciolizer> So... data T a = T { pick :: Bool -> a }
12:09:00 <sciolizer> fmap f t = T (\b -> f $ pick t b)
12:09:27 <sciolizer> That's the covariant version?
12:10:19 <copumpkin> might be easier to pattern match on the left
12:10:30 <sciolizer> fmap f (T get) = T (\b -> f (get b))
12:10:37 <copumpkin> but yeah, it's a special case of (r ->)
12:10:45 <sciolizer> ah
12:10:48 <sciolizer> good point
12:11:21 <copumpkin> now if only we could write arbitrary type lambdas and have type sections like that :)
12:11:42 <Baughn> Hum. Couldn't we use lambdabot to invert the function?
12:11:53 <copumpkin> invert the function?
12:11:54 <Baughn> Assuming it's bijective
12:12:03 <Baughn> For that fmap problem
12:12:57 <sciolizer> copumpkin: sameInt = id :: (Int -> Int)
12:13:01 <sciolizer> Is that not what you're talking about?
12:13:18 <copumpkin> hm?
12:13:24 <copumpkin> talking about where?
12:13:24 <sciolizer> What are type sections?
12:13:27 <copumpkin> oh
12:13:31 <copumpkin> a section is (2+)
12:13:34 <copumpkin> or (+3)
12:13:39 <copumpkin> a partially applied operator
12:13:46 <copumpkin> (->) is an operator at the type level
12:13:47 <sciolizer> ah I see
12:14:03 <copumpkin> so ((->) r) is how the (r ->) type constructor is usually expressed
12:14:33 <copumpkin> but (r ->) seems more consistent :) (-> r) is however impossible to get in haskell without newtypes right now
12:14:48 <Baughn> We really need type-level lambdas
12:14:54 <copumpkin> instance ContraFunctor (-> r)
12:15:04 <Baughn> ..wait, newtypes?
12:15:21 <Baughn> type Flip c a b = c b a
12:15:29 <copumpkin> you can't partially apply that
12:15:31 <Baughn> flip (->) r?
12:15:35 <Baughn> ..aww
12:15:49 <copumpkin> newtype FlipArrow a b = FlipArrow (b -> a)
12:16:00 <copumpkin> instance ContraFunctor (FlipArrow a) where ...
12:17:15 <sciolizer> Is it just a syntax feature? Or does the partial application mean that the type checking would have to be modified as well?
12:19:09 <copumpkin> it's not just a synax feature, nope
12:19:18 <sciolizer> k
12:19:21 <monochrom> the type checker does not need modification because it already needs to deal wtih "Either x" which came from "data Either x y = ..."
12:19:43 <Polarina> How do I compile a Haskell program without including all the extra unneeded code into the executable?
12:19:46 <copumpkin> it seems equivalent to making type synonyms partially applicable
12:19:53 <copumpkin> and I thought that was quite difficult
12:20:05 <byorgey> Baughn: type-level lambdas mean undecidable type inference, unfortunately.
12:20:26 <byorgey> and it makes type checking harder too.
12:21:17 <Baughn> byorgey: Undecidable as in "might not terminate", or "is likely not to terminate"?
12:21:40 <Baughn> Polarina: Define "extra, unneeded code"
12:22:10 <Polarina> Baughn: objdump -d executable takes over 5 seconds to write the disassembly to the terminal.
12:22:21 <Baughn> Polarina: And?
12:22:25 <Polarina> Why?
12:22:41 <Baughn> Why not? Is this unexpected? Are we talking about a hello,world program?
12:22:55 <Baughn> Any big program takes time to print; I need more information than this.
12:22:59 <Polarina> Baughn: Something like that.
12:23:09 <Polarina> Baughn: Hello, world like.
12:23:25 <Baughn> Polarina: The main culprit is probably the runtime system, which is linked statically into every program. It's a few hundred kilobytes, and no, you can't get rid of it.
12:23:39 <Baughn> Polarina: FWIW, 6.12 features dynamic linking, which drastically cuts the size of everything
12:23:39 <Polarina> Why is it included?
12:23:47 <mauke> Polarina: so the programs work
12:23:56 <Baughn> If it wasn't, you couldn't have garbage collection, or threads, or I/O, or memory allocation, or.. um. Yeah.
12:24:11 <Polarina> I see.
12:24:19 <Polarina> Thanks.
12:24:33 <Polarina> Baughn: How do I enable that dynamic linking with GHC?
12:25:07 <Baughn> Polarina: Pass --enable-shared to cabal. I'm not sure how to do it with ghc --make.
12:25:10 <Phyx-> Baughn: ack... does that mean we'll get a "GHC Redistributable package" now or something?
12:25:13 <Baughn> Polarina: Um, but it's only in 6.12, which isn't out yet
12:25:31 <Baughn> Phyx-: ..I don't think the interface is stable enough for that yet.
12:25:58 <Phyx-> hehehe
12:25:58 <Polarina> Under what software license is the GHC runtime?
12:25:59 <ddarius> byorgey: We could add some restricted type lambdas (which would allow, e.g. flip) without leading to undecidability.
12:27:16 <Baughn> Polarina: Same as the rest of GHC
12:28:03 <Polarina> Which is?
12:28:19 <Baughn> http://www.haskell.org/ghc/license.html
12:29:13 <Baughn> Basically BSD or so, I guess. I'm no lawyer.
12:29:26 <Baughn> Most haskell code is; it has to be, due to the inlining ghc does
12:29:27 <Polarina> Thanks.
12:29:47 <Baughn> (Or, rather, GPL wouldn"t work without modifications)
12:32:26 <p_l> Polarina: If you don't want to use (L)GPL, be wary of code under those licenses
12:32:49 <p_l> Baughn: afaik even LGPL wouldn't work, maybe LLGPL
12:32:50 <Baughn> GPL works as expected on haskell code, I guess. LGPL has issues.
12:33:02 <Baughn> p_l: That allows static inlining?
12:33:10 <p_l> Baughn: LLGPL allows inlining etc.
12:33:11 <Polarina> Baughn: Why would LGPL have issues?
12:33:32 <Baughn> Polarina: Because that license _requires_ that the program is compiled so that a user can modify/replace the LGPL bits
12:33:41 <p_l> Polarina: Because LGPL kind of assumes dynamic loading
12:33:51 <Baughn> Polarina: That's totally impossible before 6.12 (only static linking), and even 6.12 inlines code
12:34:10 <p_l> LLGPL has fixes to that
12:34:11 <Polarina> I see.
12:34:13 <Baughn> More like, GPL in general assumes hard module/library boundaries
12:34:15 <Polarina> LLGPL?
12:34:19 <Baughn> GHC takes pleasure in blurring those
12:34:43 <p_l> Polarina: Lisp-oriented variant of LGPL, due to similar issues happening in Lisp code
12:40:56 <Cale> I like the BSD license because I can fool myself into thinking that I actually understand what the license means.
12:42:12 <p_l> WTFPL is the most understandable, but only to non-lawyers. Lawyers will get headaches
12:42:53 <Cale> Not that I entirely disagree with the overall sentiment of the *GPL licenses, but there seem to be lots of subtle implications of what they say. They also force people who are writing open source software to care about licensing issues, which seems a waste of brain power.
12:43:31 <ray> i always make sure to be paranoid and never even look at gpl code
12:43:44 <ray> doesn't feel like freedom to me
12:43:46 <gressvol> Im trying to rewrite the digit function to not be depended on the representation of the parser. The digit function should be using the exported functions in the ParserLibrary: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4851 , however I have almost no idea what to do, what I think I need to do is to change the (d, s') part in digit
12:43:49 <BONUS> despite all those licences being really formal and lawyeresque, i think they're not formal enough in the mathematical sense
12:44:00 <gressvol> but I have no idea how
12:44:11 <BONUS> didn't SPJ do something along the lines of using monads to really formalize legal contracts?
12:44:14 <ray> bonus: they probably should be, but then what would lawyers do?
12:44:26 <Cale> gressvol: Naturally, you'd use satisfy.
12:44:26 <BONUS> preferably die out
12:45:03 <gressvol> to make it independent?
12:45:29 <Cale> gressvol: you can use value along with (@@) to get a function  pmap :: (a -> b) -> (Parser a -> Parser b)
12:46:06 <Cale> gressvol: and then  pmap digitval :: Parser Char -> Parser Int
12:47:08 <Cale> gressvol: and then you just need a Parser Char which only accepts the right characters, which you basically already have :)
12:47:19 <Cale> satisfy isDigit does that :)
12:48:04 <gressvol> okey, this will take some time to digest :P
12:48:38 <Phyx-> :t (@@)
12:48:39 <lambdabot> Not in scope: `@@'
12:48:48 <Phyx-> > a
12:48:49 <Cale> gressvol: Basically the idea of the parser  pmap f x  is that it does the same parsing as x does, but then applies f to the result(s)
12:48:49 <lambdabot>   Ambiguous occurrence `a'
12:48:50 <lambdabot>  It could refer to either `L.a', defined at <local...
12:48:58 <Phyx-> > L.a
12:49:00 <lambdabot>   True
12:49:02 <Phyx-> wtf
12:49:06 <Cale> @undefine
12:49:15 <Phyx-> > a :: Expr
12:49:16 <lambdabot>   a
12:49:43 <Cale> Phyx-: we were discussing this library: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4851
12:49:55 <stoop> G is a group with respect to <> and x, a, e are in G (and e is additive identity). I did this, is this valid? a' [] x = a' <> x <> a = a <> a' <> x <> a <> a' = e <> x <> e = x <> e = x
12:50:05 <Phyx-> ah, ok
12:50:15 <Phyx-> that looks familair
12:50:33 <Cale> stoop: is that first [] supposed to be <> ?
12:50:35 <Phyx-> we use a similair backtracking parser based on list to teach parsing
12:50:37 <stoop> I cannot assume <> is commutative, I am not sure if this is too hacky/dacky.
12:50:48 <stoop> Cale, no, [] is defined in terms of <> (operation of group G).
12:50:58 <Cale> stoop: is ' supposed to be inverse?
12:51:02 <stoop> Cale, yes.
12:51:30 <stoop> Cale, trying to show: x [] a' = a' [] x = x.
12:51:52 <Cale> stoop: that seems... unlikely
12:51:53 <stoop> Cale, x [] a' has a simple derivation, my derivation a' [] x doesn't seem clean however.
12:52:12 <Cale> stoop: Unless we know something more about this group?
12:52:27 <stoop> Cale, it is a fact. x [] y = x <> y <> a. We know that a <> a' = e.
12:52:43 <stoop> Cale, and that forall x in G, x <> e = e <> x = x.
12:52:54 <Cale> stoop: Okay, so a' [] x is conjugation of x by a
12:53:01 <stoop> Cale, so, a <> a' = e. x [] 'a = x <> a' <> a = x <> e = x.
12:53:21 <Cale> yep, that much is okay
12:53:22 <stoop> Cale, a' [] x is a' <> x <> a.
12:53:24 <stoop> Cale, ok.
12:53:34 <Cale> But a' [] x will not in general be x
12:53:40 <O_4> Hi all
12:53:52 <O_4> Have any of you used AC-EasyRaster-GTK?
12:54:02 <O_4> I can't find documentation for it anywhere.
12:54:37 <stoop> Cale, can we discuss this in #math, since it's more on-topic?
12:54:59 <Cale> or PM if you prefer
12:55:04 <stoop> Ok, much appreciated.
12:55:55 <int-e> is there any interest in a ghci-readline package?
12:57:38 <burp> `rlwrap ghci`
12:57:42 <burp> and you have readline support ;)
12:57:50 <int-e> without completion support
12:57:55 <burp> it's a readline wrapper
12:58:16 <burp> ok
12:59:35 <int-e> The question is really about whether I should clean up my quick hack (similar to ghci-haskeline really) and put it on hackage.
13:00:44 <pythagumus> Is it possible to create a mutable array that can be passed around to different functions sort of like a global array in C?
13:00:46 <int-e> but perhaps I'm the only one who finds haskeline painful to use.
13:01:35 <SimonRC> pythagumus: yes
13:02:01 <SimonRC> um, wait your quesiotn doesn't make sense completely
13:02:13 <SimonRC> if it's algobal array, you don't have to pas it around
13:02:38 <int-e> pythagumus: an IO array will do; an ST array will do if you stay within the same ST computation.
13:03:15 <pythagumus> what I'm working on is some machine learning algo that uses regret minimization, and the learning function operates on an array
13:03:41 <int-e> e.g. writing  reverse :: STArray s Int e -> ST s (STArray s Int e)  is entirely possible.
13:04:05 <pythagumus> and I have multiple agents that all operate on the same array to speed up convergence so they all need to be able to access the array
13:05:27 <pythagumus> do I create the initial array with something like newArray (1,100) 0?
13:06:32 <int-e> yep
13:06:44 <tavelram_> pythagumus, perhaps you should give something like message passing a thought?
13:08:06 <pythagumus> does newArray also live in the ST monad?  When I try to use it in ghci I get errors.
13:08:31 <Cale> pythagumus: yeah...
13:08:36 <int-e> @type newArray
13:08:37 <lambdabot> Not in scope: `newArray'
13:08:47 <Cale> pythagumus: the array is only 100 elements?
13:08:50 <int-e> @type Data.Array.MArray.newArray
13:08:51 <lambdabot> forall i e (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
13:09:01 <pythagumus> no, it's huge, just an example
13:09:05 <Cale> pythagumus: okay
13:09:35 <tavelram_> pythagumus, is this a small proof of concept or should it be used for real?
13:09:43 <Cale> pythagumus: One option to try before going down the road of mutation insanity is perhaps DiffArray/DiffUArray
13:09:52 <int-e> newArray is _very_ polymorphic. In GHCI, try  (a :: IOArray Int Int) <- newArray (1,100) 0
13:10:07 * int-e thinks DiffArray is never an option.
13:10:27 <Cale> There have been cases where DiffArray was the best choice
13:10:28 <int-e> Use Data.Map if you want something like that.
13:10:40 <Cale> But they're uncommon, I'll grant you that :)
13:10:51 <int-e> maybe, if mutation is really infrequent.
13:11:17 <Cale> Surprisingly, DiffUArray was really effective in a case I had where there was actually quite a bit of backtracking.
13:11:56 <pythagumus> tavelram, it's used for real, the problem is too big for lp so I'm using regret min.
13:13:22 <Cale> pythagumus: You might just write the whole thing in ST (or even IO), though it's obviously a bit sad to have to do that
13:13:37 <Cale> pythagumus: It's no worse than using an imperative language to write the thing anyway ;)
13:13:59 <pythagumus> I shouldn't have to write the actual array, it gets generated after many iterations
13:14:22 <pythagumus> I just need to start with the initial values all set the same
13:14:41 <Cale> pythagumus: So the array ends up having a fixed value?
13:15:00 <pythagumus> eventually it reaches a pseudo-equalibrium
13:15:23 <Cale> pythagumus: Er, the things you're saying seem contradictory. If you're not writing the array, and it starts with initial values all the same, then how...
13:15:40 <pythagumus> basically the regret value that is calculated after each iteration is below a certain threshold then the learning is done
13:15:43 <tavelram_> pythagumus, is it supposed to scale on several cpus/cores? computers? how does it access the data? how many writes vs reads? does the writes need to propagate to all processes atomically?
13:16:39 <pythagumus> the learning stage mutates the values in the array until they have converged on an acceptably small value
13:16:52 <pythagumus> for now it will run on a single machine
13:17:11 <Cale> pythagumus: If you have a part which is mutating an array in order to construct it, you could write that in ST, and then use runSTArray to freeze the array constructed into an immutable one which you use in the rest of your program
13:18:36 <Cale> pythagumus: Does that seem sensible?
13:18:42 <pythagumus> that is what I was thinking, but I don't really get how to get up the initial array
13:19:08 <pythagumus> all the examples build the array in the function using it, I need the array to live outside the learning function
13:19:10 <Cale> Well, the relevant API is in Data.Array.MArray
13:19:18 <Cale> Well...
13:20:15 <Cale> runSTArray (do a <- newArray (1,100) 0.5; ...do lots of mutations on a...)
13:20:45 <Cale> will produce a normal  Array Int Double  (or whatever)
13:20:56 <Cale> and then you can pass that around without using the ST monad.
13:21:07 <Cale> so long as you don't need to mutate it any further.
13:21:31 <pythagumus> that might not work, the learning happens after each stage of simulation
13:21:34 <Cale> The 'a' in that code would be an STArray though, and you use the mutable array API on it
13:21:53 <pythagumus> and the simulator is complex and doesn't live inside the learning function
13:22:34 <Cale> If it happens infrequently enough that taking a copy each time won't be painful, you can use the  thaw  function in the MArray API to convert an Array back into an STArray
13:22:44 <int-e> have we found out whether there's any parallelism involved?
13:22:45 <Cale> You could also try unsafeThaw, but that is unsafe :)
13:23:19 <int-e> because if so you'll be forced into IO or into unsafe areas (including, possibly, unsafeThaw)
13:23:34 <pythagumus> it could be run in parallel
13:23:40 <ezyang> Is there a cute way of trying Haskell's built-in "read" parser in Parsec?
13:23:49 <pythagumus> each simulation is independent
13:24:15 <pythagumus> the learning function will be invoked about 1000 times per second
13:24:45 <int-e> but the simulation uses the array, which is updated when learning?
13:24:57 <pythagumus> no, the simulation doesn't use the array
13:25:09 <pythagumus> actual, yes it kind of does
13:25:27 <Cale> ezyang: I don't think there's a particularly easy way to turn reads into a Parsec parser, if that's what you're asking.
13:25:39 <Cale> (at least, I would be interested if you find one)
13:26:05 <pythagumus> the simulator won't mutate the array, it always assumes the array is "finished learning"
13:26:06 <ezyang> Cale: Ok. I'll try mucking around with the combinators and see if I can do it
13:26:32 <ezyang> Cale: you can "almost" do it with listToMaybe . reads
13:28:29 <Cale> ezyang: You might have to use setInput in general
13:28:49 <int-e> pythagumus: but technically, that means the simulations are not independent of each other.
13:28:51 <Cale> ezyang: I'm fairly certain there's a way to do it, but I'm less certain that there's a pretty way :)
13:29:08 <ezyang> mmm
13:29:16 <ezyang> Well, depends on your standards of "pretty" :-P
13:29:17 <int-e> pythagumus: which may explain your difficulties with expressing this in haskell.
13:29:36 <pythagumus> sort of, they are because they could all be run in at once and then combine the results sort of like map-reduce
13:31:18 <pythagumus> it would work by having multiple copies of the array, run many simulations with independent learning then combine the results for the final array
13:31:24 <Cale> pythagumus: But isn't each simulation step dependent on the previous learning step, and each learning step dependent on the previous simulation?
13:31:35 <int-e> pythagumus: maybe you should actually do that, explicitely: take a snapshot of your array (immutable, i.e. some (U)Array i e), and pass that to a batch of simulations. Collect the result and do a learning step with the combined results - this will yield a new snapshot, and then you can run another batch of simulations, and so on.
13:32:39 <Cale> Yeah, if you're doing so much simulation that the learning phases in which you need to mutate are sufficiently infrequent, don't worry about having to do a thaw on the array (which copies it)
13:33:23 <Cale> because the cost of that copy will be amortised over all the simulation you did
13:33:25 <HugoDaniel> hello
13:33:30 <pythagumus> I might try that instead of mutable arrays.  I'm a little worried about it because the array is going to be >2Gb though
13:33:45 <Cale> ah, that is a bit scary
13:33:50 <burp> lol
13:33:59 <burp> then you'll need 200GB of memory
13:34:16 <Cale> heh
13:34:25 <Cale> If you're not careful, certainly.
13:34:58 <pythagumus> that's why I was thinking about mutable arrays instead
13:34:58 <Cale> But yeah, if you're sufficiently careful that the old array becomes garbage, and you use unboxed arrays, it should be okay.
13:35:51 <Cale> Or if you're not going with unboxed arrays (I don't know how that 2GB is being accounted for), then you should be really cautious that you're not building up large expressions in the array elements
13:36:06 <Cale> (boxed array elements aren't necessarily evaluated)
13:40:02 <ezyang> ew ew ew
13:40:12 <ezyang> readsPrec doesn't tell me how many characters it consumed
13:40:38 <int-e> why would it do that?
13:40:54 <ezyang> So I could make a Parsec version of it conveniently, of course! :o)
13:41:33 <monochrom> Do you need to know how many characters are consumed?
13:41:50 <monochrom> Even when I use Parsec I don't need to know.
13:41:55 <int-e> parsec maintains a character position
13:41:59 <int-e> for error messages
13:42:28 <ezyang> yeah, I'm mucking around low level
13:42:44 <ezyang> maybe tokenPrim is not actually what I want. Fuzzy on the "token" distinction
13:43:11 <monochrom> The short story is "token" = character.
13:43:41 <ezyang> Ok. I need a higher level of abstraction
13:44:06 <aavogt> ezyang: I've done something similar here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11932#a11932
13:44:29 <ezyang> ooh, that might be exactly what I want
13:45:03 <int-e> hmmm. scary. find ((==rest) . snd)
13:45:11 <aavogt> yeah
13:45:45 <aavogt> this was for parsing a very small file
13:46:20 <ezyang> I'm... not sure what that line is doing
13:46:35 <knobo> I have done some fixes to my code pasted some hours ago: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11922#a11922
13:47:10 <knobo> But I have the feeling  that I should make me some more own types.
13:47:12 <ezyang> oh, is that how you're calculating how much was consumed?
13:47:14 <knobo> For example for a node.
13:47:24 <int-e> ezyang: it's attempting to solve your problem the hard way - it looks for the 'rest' string returned by readsPrec in the original input.
13:47:39 <ezyang> ew
13:47:43 <twanvl_> couldn't you do setInput to make parsec only use the rest?
13:47:48 <aavogt> int-e: there's an easy way?
13:47:52 <aavogt> twanvl_: it does that
13:47:53 <int-e> ezyang: it'd probably be better to just compare lengths - but even that means consuming the whole remaining input.
13:48:11 <int-e> aavogt, ezyang: and that's the easiest way I can think of
13:48:23 <ezyang> Yeah, consuming the rest of the input is pretty unacceptable
13:48:27 <c_wraith> knobo: I'd probably name that data type "Color" rather than "Colors"..  Red is a Color, rather than Red is a Colors
13:48:29 <knobo> how do I do that? data Node = (Integer, Colors, [Integer])
13:48:47 <ezyang> but...
13:48:49 <ezyang> wait, wtf
13:49:08 <ezyang> Ok, I guess I don't understand how lazy Haskell is permitted to be in this situation
13:49:26 <aavogt> no, length forces the spine of the list
13:49:30 <c_wraith> knobo: You'd do something like "data Node = Node Integer Colors [Integer]"
13:49:41 <twanvl_> parseRead = do { xs <- getInput ; msum [ setInput ys >> return r | (r,ys) <- reads xs ] ] } -- something like this
13:50:21 <aavogt> and my code probably ends up forcing all the tokens too
13:50:39 <int-e> ezyang: oh, perhaps there's something better ... something like   dropWhile (\xs -> null xs) $ map (\n -> take n input) (map (2*) 1) ... i.e. test prefixes of length 1,2,4,8,... until readsPrec returns a result.
13:50:40 <ezyang> It would probably be reads fault
13:50:50 <ezyang> lol
13:51:19 <knobo> c_wraith: then the "data Node" gives the name, and the second Node would be the constructor?
13:51:19 <twanvl_> you could also do something evil to test how much of the input reads has actually used
13:51:28 <int-e> ezyang: it's very ugly, but can't be helped if you don't want to destroy the SourceLoc information - readsPrec loses an essential bit of information.
13:51:33 <c_wraith> knobo: Correct.  And they are different namespaces.
13:51:56 <ezyang> I think... I'm going to crib aavogt's code, and say "my input strings aren't that long"
13:53:22 * twanvl_ is thinking let ref = newIORef 0 in zipWith (\i x -> unsafePerformIO (modifyIORef ref (max i) >> return x) [1..] =<< getInput  -- note: don't use this
13:53:22 <aavogt> ezyang: if you do use int-e's suggestion, do send a patch to update the definition of readsToParsec in xmobar's Parsers.hs
13:53:45 <ezyang> Ah, that's where this snippet came from :-)
13:55:00 <int-e> hmmm.
13:55:11 <int-e> > read $ take 1 "123"
13:55:13 <lambdabot>   * Exception: Prelude.read: no parse
13:55:20 <int-e> > (read $ take 1 "123") :: Int
13:55:21 <lambdabot>   1
13:55:58 <ezyang> hmm, where does safelast live...
13:56:24 <aavogt> safeLast [] = Nothing
13:56:42 <ezyang> ah, it doesn't live anywhere
13:57:14 <spink> hi, I want to read *fast* ints from stdin. Each line has 1 or 3 ints seperated with a space char. Up to now I used read, isSpace and getChar. I am thinking of the readInt but can't figure out how to use it
13:57:45 <hgb^unix> can someone confirm that this is haskell code: j [(t, _)] = t
13:57:49 <mauke> fmap (map read . words) getContents
13:58:16 <spink> Btw today I played with the ghc profiler using read, getChar and isSpare are consumig all together ~60% of cycle time
13:58:32 <Zao> hgb^unix: Likely.
13:58:33 <spink> and that's a good way to learn the good usage of the profiler :)
13:58:59 <ezyang> Try Parsec?
13:59:03 <Zao> > let j [(t, _)] = t in j [(42, 3)]
13:59:04 <lambdabot>   42
13:59:18 <Zao> > let j [(t, _)] = t in j [(42, 3), (5, 7)]
13:59:19 <lambdabot>   * Exception: <interactive>:1:157-170: Non-exhaustive patterns in function j
13:59:54 <Zao> hgb^unix: That's a pattern to match a one-element list of 2-tuples, binding the first element to t and not caring about the second one.
14:00:44 <ezyang> Just to make sure, readsToParsec doesn't consume any input if it fails
14:01:18 <hgb^unix> can someone please help with the result of this code: http://pastebin.com/m7f159986
14:02:11 <lavish> hgb^unix: prrrr
14:02:17 <lavish> I asked before you did :P
14:02:37 <hgb^unix> :D
14:02:54 <mauke> looks like it builds a tree from a list
14:03:00 <sg> hi
14:03:24 <hgb^unix> what would be the outcome of the code from above?
14:03:30 <mauke> a tree
14:04:55 <hgb^unix> is for this kind of algo a certain name/ method known? something like bubblesort for a certain way of sorting things
14:05:01 <HugoDaniel> is there anyone here interested in doing a 3D rendering application in haskell ?
14:05:21 <hgb^unix> e.g. bubbletree or another name for this code?
14:08:28 <twanvl_> ah, I think I know what that code does
14:08:32 <twanvl_> but maybe I shouldn't tell you, because
14:08:32 <twanvl_> "<lavish> it's a code from an hacking competition"
14:09:12 <int-e> ezyang: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11934#a11934
14:09:37 <lavish> twanvl_: as you whish, I tried all possible resources :D
14:10:00 <Cale> You could get GHC and try the code :)
14:10:14 <lavish> s/whish/wish/
14:10:30 <lavish> Cale: I'm trying... /me is an xmonad user
14:10:36 <ezyang> int-e: Nice!
14:10:44 <Vanadium> I tried getting ghc, now cabal won't work anymore :<
14:10:47 <hgb^unix> twanvl_, too bad :(
14:11:14 <lavish> twanvl_: well well.. wait... I use xmonad, I spread haskell, you *have* to tell me what that code do :P
14:11:23 <int-e> ezyang: it's horrible in the case of parse failures - you end up consuming (and holding on to) the whole input anyway!
14:11:43 <int-e> ezyang: that being said, feel free to use it.
14:11:53 <lavish> twanvl_: in addition we managed to understand it's haskell :P
14:12:00 <ezyang> Looking at it closely, I'm unconvinced that it would handle 12345678 correctly.
14:12:36 <ezyang> since it would try parsing "1234" first, succeed, and return that.
14:12:57 <twanvl_> I could translate it into English. What it does is:
14:12:57 <twanvl_> 1. make a histogram of character frequencies (the b function)
14:12:57 <twanvl_> 2. sort the histogram, least frequent character first
14:12:57 <twanvl_> 3. these become the leafs of the tree
14:12:57 <twanvl_> 4. combine the two two least frequent trees, until a single tree is left
14:13:08 <int-e> ezyang: no, it would parse "1234", get back (1234,"") and decide to go on parsing, because "" has fewer than 2 characters.
14:13:40 <c_wraith> twanvl_:  You couldn't just shorten that to "huffman encoding"?
14:13:55 <twanvl_> c_wraith: that would be cheating :)
14:14:42 <int-e> ezyang: there will likely be cases where 2 characters are not enough though.
14:14:54 <int-e> ezyang: I just couldn't think of any.
14:16:56 <leimy> starting to rewrite some bad code in Regex in Parsec :-)
14:17:14 <leimy> and I've a parer that's passing but I don't know why the value I'm returning isn't emerging.
14:18:59 <ezyang> int-e: Yeah; deriving for algebraic data types, I think
14:19:11 <c_wraith> leimy: post it?
14:19:13 <ezyang> (which is actually the real reason I want this)
14:19:40 <lavish> twanvl_: I still don't get it :P
14:19:52 <int-e> ezyang: ADTs should be fine - there are no optional parts involved there.
14:20:16 <ezyang> Hmm, I guess that's true
14:20:42 <int-e> > read "True {}" :: Bool -- close one :)
14:20:43 <lambdabot>   * Exception: Prelude.read: no parse
14:20:53 <int-e> > True {} || False
14:20:54 <lambdabot>   True
14:22:06 <[BIOS]dnivra> :t &&&
14:22:07 <lambdabot> parse error on input `&&&'
14:22:16 <int-e> :t (&&&)
14:22:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:22:26 <twanvl_> more simply:
14:22:36 <[BIOS]dnivra> what exactly is an arrow?
14:22:41 <twanvl_> (&&&) :: (a -> b) -> (a -> c) -> (a -> (b,c))
14:22:47 <[BIOS]dnivra> @hoogle arrow
14:22:48 <lambdabot> module Control.Arrow
14:22:49 <lambdabot> Control.Arrow class Category a => Arrow a
14:22:49 <lambdabot> Control.Arrow class Arrow a => ArrowApply a
14:23:02 <[BIOS]dnivra> @hoogle Control.Arrow
14:23:02 <lambdabot> module Control.Arrow
14:23:03 <lambdabot> Control.Arrow class Category a => Arrow a
14:23:03 <lambdabot> Control.Arrow class Arrow a => ArrowApply a
14:23:06 <ezyang> dnivra: A generalization of functions and monadic applications
14:23:10 <leimy> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4852#a4852 <--
14:23:18 <int-e> arrows is how serious mathematicians play connect the dots.
14:23:35 <lavish> [BIOS]dnivra: i asked FIRST!!! :P
14:23:36 <leimy> c_wraith: see above :-)
14:23:44 <lavish> you you... cheater!!!
14:23:44 <knobo> data Bar = Bar (Integer,Integer)
14:23:44 <knobo> foo :: Bar -> Integer
14:23:44 <knobo> foo (x,y) = x
14:23:44 <knobo>  
14:23:46 <lavish> :P
14:23:52 <knobo> Does not work.
14:23:57 <knobo> And I don't understan why
14:24:00 <[BIOS]dnivra> @lavish ??
14:24:01 <lambdabot> Unknown command, try @list
14:24:03 <c_wraith> :t manyTill
14:24:05 <lambdabot> Not in scope: `manyTill'
14:24:06 <leimy> could it be my "manyTill"?
14:24:13 <c_wraith> That's what I'd suspect
14:24:21 <[BIOS]dnivra> lavish: what exactly are you referring to?
14:24:22 <leimy> me too
14:24:25 <lavish> [BIOS]dnivra: I'm from c00kies@venice ;)
14:24:27 <leimy> now that I look closer
14:24:35 <[BIOS]dnivra> lavish:so?
14:24:49 <leimy> ah it totally was
14:24:50 <[BIOS]dnivra> lavish: dude i figured out it's haskell with just a glance at it
14:24:54 <leimy> that was breaking everything
14:24:56 <mauke> knobo: because (x,y) doesn't have the type Bar
14:24:59 <leimy> i should totally sleep more often
14:25:02 <leimy> or drink more coffee
14:25:10 <mauke> knobo: foo (Bar (x, y)) = x
14:25:11 <c_wraith> leimy: well, at least you've got it figured out now. :)
14:25:11 <Cale> [BIOS]dnivra: In that context, an arrow (Hughes arrow) is a data type which supports a particular interface of combining functions which make it like an abstraction or enrichment of what functions are.
14:25:16 <knobo> great!
14:25:28 <twanvl_> [BIOS]dnivra: try looking at the channel logs, http://tunes.org/~nef/logs/haskell/
14:25:38 <lavish> [BIOS]dnivra: yeah, but you still have to complete quest n.2 :P
14:25:38 <leimy> c_wraith: yes thank you :-)
14:25:55 <leimy> c_wraith: now if I could figure out why <|> doesn't do what I expect... maybe I need a try?
14:26:15 <[BIOS]dnivra> lavish: dude i'm not here for points; i'm learning haskell and this is a welcome opportunity for me to learn more :P
14:26:15 <c_wraith> leimy: probably.  <|> only does lookahead with a single token.
14:26:24 <leimy> DOH!
14:26:25 <leimy>  :-)
14:26:27 <[BIOS]dnivra> twanvl_: thank you
14:26:28 <ezyang> leimy: Be careful! Lots of people put in too many trys and suffer
14:26:39 <leimy> too many trys, too much strictness
14:26:41 <lavish> [BIOS]dnivra: pfff :P :P :P
14:26:50 <lavish> [BIOS]dnivra: I'm just kidding anyway ;)
14:26:53 <leimy> is this that language where you have to say "please" the magic number of times but can't know in advance?
14:27:15 <Cale> PLEASE REINSTATE NEXTING
14:27:28 <int-e> PLEASE ABSTAIN FROM REINSTATING
14:27:41 <IUTkrasse> http://www.PetiteMarion.com/?id=361583
14:27:44 <Twey> leimy: That's INTERCAL :þ
14:27:51 <Cale> COME FROM 1
14:27:55 <Twey> Hehehe
14:27:59 <Cale> PLEASE ABSTAIN FROM ABSTAINING
14:28:07 * int-e loved the forking idea behind concurrent intercal.
14:28:15 <leimy> Twey: yes :-)
14:28:45 <leimy> Anyway, I got my try's right
14:28:49 <leimy> I actually rather like Parsec
14:28:57 <leimy> Spirit was clearly inspired by it.
14:29:06 <leimy> and i liked spirit when I had to code in C++ :-)
14:30:07 * Cale bets that Control.Monad.Arrow is imported for the instance on (->) more than any other usage of arrows :)
14:30:23 <ezyang> snerk
14:30:27 <c_wraith> also, beware of something like:  try (string "f") <|> try (string "foo")
14:30:29 <ezyang> Prolly :-)
14:30:35 <c_wraith> That'll never work the way you want.
14:30:37 <Cale> er Control.Arrow
14:30:39 <Cale> :P
14:31:10 * int-e thought that's what Control.Monad.Instances is for nowadays, and Control.Monad.Reader historically.
14:31:13 <ezyang> c_wraith: Hm, is the error there the second try?
14:31:20 <int-e> oh.
14:31:24 <Cale> I found it rather nice though that Arrows, like monads, are monoid objects in a particular category :)
14:31:49 <c_wraith> ezyang: no.  It's that the backtracking from try just doesn't work that way.
14:32:03 <Cale> Though, it probably turns out that almost anything is a monoid object in some category :)
14:32:07 <ezyang> hm
14:32:27 <c_wraith> ezyang: reversing the order, so you go from longest to shortest, does work.
14:32:35 <Cale> (not really, but the definition is general enough to catch a lot)
14:32:46 <ezyang> oh, whoops
14:32:55 <ezyang> I didn't notice that :-)
14:33:03 <ezyang> I thought you were talking about a more insidious bug
14:33:16 <c_wraith> no, it's not really a bug.  Just a wrinkle in how it works.
14:33:42 <ezyang> I mean, it totally makes sense if you have reasonably accurate mental model of Parsec flow
14:34:00 <nolrai_FG> What isnt a bug?
14:34:30 <c_wraith> It does mean that something that looks ok ends up being very wrong, if you aren't very clear on how parsec works
14:35:47 <nolrai_FG> Is there a differnce between WriterT w (State s) and StateT s (Writer w) ?
14:36:05 <mauke> @unmtl WriterT w (State s) a
14:36:07 <lambdabot> s -> (a, w, s)
14:36:13 <mauke> @unmtl StateT s (Writer w) a
14:36:14 <lambdabot> s -> (a, s, w)
14:36:26 <mauke> not really, it seems
14:36:37 <nolrai_FG> hmm, thanks!
14:37:05 <Cale> http://simont.livejournal.com/216731.html -- this is amusing :)
14:39:09 <[BIOS]dnivra> guys i really have doubts if this is haskell since it has constructs not in haskell. can you guys confirm my suspicion?
14:39:19 <[BIOS]dnivra> b = j . sortBy (comparing snd) . map (L . head &&& length) . group . sort
14:39:29 <c_wraith> What's not haskell about that?
14:39:34 <[BIOS]dnivra> oops i missed a let before b
14:39:41 <ezyang> j is not a function...
14:39:46 <ezyang> in the standard libraries, at least
14:39:46 <[BIOS]dnivra> i know it's fp; but the function comparing doesn't exist
14:39:53 <c_wraith> comparing is in haskell
14:39:56 <ezyang> but that looks like Haskell ysntax
14:39:57 <[BIOS]dnivra> yes there's more to it ezyang
14:39:59 <c_wraith> @hoogle comparing
14:40:00 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:40:11 <Cale> [BIOS]dnivra: It's in a library
14:40:12 <[BIOS]dnivra> oh!! hoogle didn't return results earlier
14:40:23 <nolrai_FG> @unmtl ErrorT e (RWST r w s) a
14:40:24 <[BIOS]dnivra> i did it from haskell.org/hoogle
14:40:24 <lambdabot> err: `RWST r w s (Either e a)' is not applied to enough arguments, giving `/\A. r -> s -> Either e a (A, s, w)'
14:40:46 <[BIOS]dnivra> @hoogle deriving
14:40:46 <nolrai_FG> ?
14:40:47 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
14:41:00 <c_wraith> deriving is syntax, not a function
14:41:15 <Zao> Cale: I must say that I'm a bit ashamed to not remember which interpretation of if if else is the one commonly used, as I always brace myself.
14:41:17 <nolrai_FG> c_wraith: what about parsec are you talking about?
14:41:29 <[BIOS]dnivra> c_wraith: oh!!
14:41:52 <ksf> Zao, the one that doesn't require additional work to implement.
14:41:54 <c_wraith> nolrai_FG:  I was talking about:  try (string "f") <|> string "foo"
14:42:14 <nolrai_FG> what happens thats wierd?
14:42:19 <c_wraith> nolrai_FG: That it can't ever match "foo" isn't a bug.
14:42:22 <ksf> that is, an else always belongs to the if before it that doesn't already have an else.
14:42:34 <nolrai_FG> Yeah that makes sense.
14:42:51 <c_wraith> nolrai_FG: It's just something you need to be aware of.  There's a not-necessarily-obvious order dependency
14:43:06 <nolrai_FG> Hmm that is true.
14:43:19 <nolrai_FG> Okay less woried now.
14:44:08 <nolrai_FG> Isnt that try unessary?
14:44:46 <ksf> try is always nescessary if any two alternatives can consume a common prefix.
14:44:56 <Cale> Zao: I believe it's maximal munching
14:45:01 <ksf> ...and both f and foo can consume f.
14:45:11 <ezyang> ksf: do you mean unnecessary?
14:45:16 <ezyang> oh, nvm
14:45:23 <nolrai_FG> oh right. over thinking it
14:45:53 <ksf> it's not like it'd be trying "foo", then failing, not consuming anything, it's trying "f", suceeding, consuming the f, then trying "o", failing.
14:46:10 <nolrai_FG> well wait, try isnt nessary on a one chartor things.
14:46:21 <nolrai_FG> typos galor
14:46:21 <ksf> yep.
14:46:24 <c_wraith> anyway, it's something I ran into because I wasn't thinking about the execution model clearly enough.  Once I figured it out, I felt silly, but it took a bit.
14:46:37 <nolrai_FG> yeah I could see that.
14:48:28 <ksf> uu-parsinglib doesn't require trys nor remembers unnescessary things iirc
14:48:39 <ksf> (I've never actually used it, just read the docs)
14:49:03 <nolrai_FG> hmm, never heard of it. What is it like?
14:49:17 <FunctorSalad> censor :: (MonadWriter w m) => (w -> w) -> m a -> m a
14:49:18 <FunctorSalad> :o
14:49:44 <ksf> http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
14:49:47 <FunctorSalad> @unmtl (ErrorT e (RWS r w s) a)
14:49:47 <lambdabot> r -> s -> (Either e a, s, w)
14:50:07 <FunctorSalad> @unmtl RWST r w s (Either e) a
14:50:07 <lambdabot> r -> s -> Either e (a, s, w)
14:50:25 <ksf> it's really, really sophisticated, but hasn't seen widespread usage (yet)
14:50:25 <nolrai_FG> FunctorSalad: Thanks!
14:50:26 <FunctorSalad> what is the difference :(
14:50:50 <FunctorSalad> nolrai_FG: think you meant ksf
14:51:02 <nolrai_FG> No I mean you.
14:51:14 <Cale> Zao: The consequence is that the innermost if always takes the else.
14:51:27 <nolrai_FG> I was tring the same thing and Lambda bot didn't like it
14:51:34 <c_wraith> hmm.  I'm not sold on parsec for my project, but polyparse didn't bowl me over.
14:51:44 <c_wraith> I'll take a look at this one
14:51:54 <ksf> polyparse is cool if you want to do on-line parsing.
14:52:01 <ksf> uu does that too, though.
14:52:09 <ksf> it's primary mode is applicative, btw.
14:52:18 <FunctorSalad> I think the first monad always gives you the writer and state result, while the second doesn't if there's an error
14:52:25 <ksf> and it can actually correct the input.
14:53:07 <nolrai_FG> FunctorSalad: yeah that looks right to me.
14:53:18 <FunctorSalad> nolrai_FG: how strange :O I hadn't read yours, yet it is the exact same obscure thing
14:53:30 <FunctorSalad> nolrai_FG: you had RWST on the inside, should be RWS
14:53:39 <nolrai_FG> Not that obscure.
14:53:46 <nolrai_FG> Oh!
14:53:54 <knobo> Learning haskell in a day (not exactly true), http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11922#a11936
14:54:41 <c_wraith> Part of my complaint with polyparse is that it was like 4 packages in one, without a good explanation of what each one was
14:54:54 <ksf> you want to use records instead of stuff like getName
14:54:57 <knobo> the name of the nodes are Integers, should they be constructors?
14:55:42 <knobo> like data Country = Country Norway | England | Sweeden ....?
14:55:46 <knobo> or strings?
14:55:59 <ksf> depends.
14:56:37 <Baughn> Whatever works. But for what it's worth, constructors usually end up being nicer.
14:56:48 <Baughn> You can always convert them to strings with show, for printing and such
14:56:54 <knobo> These constructors are similar to symbols, except that they belong to certan types??
14:57:01 <ksf> in this case, I'd say stick with Integers. the algorithm is about graphs, not countries, and integers are fine to reference nodes.
14:57:07 <Baughn> c_wraith: If that wasn't the case, it'd be monocase
14:57:15 <Baughn> *monoparse
14:57:39 <c_wraith> Baughn: having a good explanation of the purpose of each doesn't prevent it from being poly. :P
14:58:03 <Sadache> hi there
14:58:08 <knobo> These constructors can be enumerated, if I understand correctly. How is that done?
14:58:10 <Baughn> c_wraith: What would that be called? polyhistoparse?
14:58:31 <Baughn> knobo: deriving(Enum), from/toEnum
14:58:47 <Sadache> I am doing some HOP with f# and I have a question that I am sure if it has an answer it needs to be here
14:59:03 <knobo> Baughn: how are the constructors accessed through enumerations?
14:59:25 <Baughn> knobo: If you have a data Foo = A | B | C deriving(Enum), then..
14:59:26 <Sadache> I am defining a split function in terms of  skip and take like: (lift2>>lift2) tuple take skip
14:59:28 <c_wraith> :t enumFromTo minbound maxbound
14:59:29 <lambdabot> Not in scope: `minbound'
14:59:30 <lambdabot> Not in scope: `maxbound'
14:59:37 <c_wraith> :t enumFromTo minBound maxBound
14:59:38 <lambdabot> forall a. (Bounded a, Enum a) => [a]
14:59:39 <Baughn> knobo: fromEnum B = 1, toEnum 0 = A
14:59:54 <Baughn> Also. That.
15:00:00 <FunctorSalad> I'm getting "    Could not deduce (Typeable a) from the context ()
15:00:00 <FunctorSalad>       arising from the superclasses of an instance declaration" while trying to derive Typeable,Data for a harmless regular type
15:00:06 <Sadache> the problem is that I want to wrap it into an Option  type (Maybe)
15:00:09 <ksf> getNode ns name = head . filter (nameEq name) ns
15:00:15 <ksf> ...well, modulo the maybe
15:00:36 <ksf> make that a listtomaybe.
15:00:50 <Cale> Sadache: what are the types of lift2 and (>>) there?
15:00:59 <Cale> Is (>>) the same thing as in Haskell?
15:01:00 <Sadache> so I define toOption : ('a-> bool)-> 'a ->  'a Option
15:01:01 <FunctorSalad> oh well, standalonederiving does it
15:01:27 <Baughn> Sadache: Probably an F# channel would be better
15:01:28 <Sadache> >> is the function composition `.` in haskell
15:01:32 <Cale> ah
15:01:44 <aavogt> in the same order?
15:01:46 <Cale> and lift2 f g h x = f (g x) (h x) ?
15:01:57 <knobo> ksf: getNode has to use listToMaybe
15:01:59 <Sadache> and let lift2 h f1 f2 a = h (f1 a) (f2 a)
15:02:09 <Cale> good, I guessed right :)
15:02:22 <ksf> knobo, yes, my gripes are with the list comprehension.
15:02:32 <knobo> ok
15:02:50 <knobo> ksf: much better
15:02:51 <Sadache> so now I want to wrap it into an Option and if the passed index is >= to the list length then I produce none
15:03:01 <Cale> > (liftM2 . liftM2) (,) take drop 5 "Hello, World!"
15:03:02 <lambdabot>   ("Hello",", World!")
15:03:09 <Cale> ah, okay
15:03:09 <knobo> ksf: which is most lazy?
15:03:26 <knobo> filter or list comprehension?
15:03:41 <Twey> I'm pretty sure they're equally lazy
15:03:42 <ksf> list comprehensions are just glorified concatMaps.
15:03:53 <Cale> Sadache: Of course, that will require actually checking the length which your current code won't do, will it? Does take or skip fail when given a number larger than the length of the list?
15:04:20 <Sadache> yes they fail, thats the problem
15:04:25 <Cale> ah
15:04:30 <Cale> > (liftM2 . liftM2) (,) take drop 30 "Hello, World!"
15:04:32 <lambdabot>   ("Hello, World!","")
15:04:39 <Cale> It's different in Haskell :)
15:05:14 <knobo> ksf: I had to do:  listToMaybe (filter (nameEq name) ns).
15:05:25 <Sadache> that's why I want to cmpose the previous function with (lift1 (<=)) length
15:05:35 <ksf> knobo, looks fine.
15:05:57 <ksf> a bit more ideomatic would be to have the list as last parameter, though.
15:06:03 <BMeph> Sadache: Your PL is defective; fix that, and it'll be just fine... ;p
15:06:21 <[BIOS]dnivra> can someone please help me out with this code?
15:06:24 <knobo> ok, this was fun, but now I have to get social.
15:06:25 <[BIOS]dnivra> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4853#a4853
15:06:30 <Cale> It's not a language issue, it's a library issue, I guess
15:06:40 <Cale> and we still have the same problem implementing this
15:06:49 <ksf> it's actually findFirst f = listToMaybe . filter f
15:06:50 <Cale> Maybe use the Maybe (Option?) monad?
15:06:57 <Sadache> BMeph: yes, but I need to live with it :)
15:06:58 <[BIOS]dnivra> i've done the second command: it takes a list containing an empty ordered pair and returns the empty ordered pair
15:07:54 <[BIOS]dnivra> and also tried 'j', it takes a list with an ordered pair and returns the first element of the ordered pair.
15:08:08 <Sadache> Cale: yes I want to do so, but I am trying to do it with function composition and I am failing to do so
15:08:09 <[BIOS]dnivra> can anyone please help me out with the others?
15:08:12 <Axman6> [BIOS]dnivra: i would highly suggest giving your functions and types better names
15:08:21 <[BIOS]dnivra> Axman6: it
15:08:27 <[BIOS]dnivra> Axman6: it
15:08:34 <[BIOS]dnivra> Axman6: it is not my code
15:08:38 <[BIOS]dnivra> ;)
15:08:42 <Axman6> ah :)
15:08:50 <knobo> ksf: but then the type signature changes.
15:08:57 <Cale> > (\n xs -> guard (length xs <= n) >> return ((liftM2 . liftM2) (,) take drop n xs)) 30 "Hello, World"
15:08:59 <lambdabot>   No instance for (GHC.Show.Show
15:08:59 <lambdabot>                     (m ([GHC.Types.Char], [G...
15:09:00 <[BIOS]dnivra> thing is that i don't know what 'B' stands for
15:09:01 <Cale> er
15:09:02 <knobo> ksf: do I include the Node then?
15:09:13 <Cale> oh, right
15:09:18 * ksf refuses to help anybody who's using &&& or similar in his code. the next thing I'd be doing is teaching oleg how to typecheck...
15:09:22 <Cale> > (\n xs -> guard (length xs <= n) >> return ((liftM2 . liftM2) (,) take drop n xs)) 30 "Hello, World" :: Maybe (String, String)
15:09:23 <lambdabot>   Just ("Hello, World","")
15:09:42 <ksf> knobo, it's not the same function, but a general pattern that arises quite often.
15:09:50 <knobo> ksf: what's the type signature then?
15:09:51 <Cale> > (\n xs -> guard (length xs > n) >> return ((liftM2 . liftM2) (,) take drop n xs)) 30 "Hello, World" :: Maybe (String, String)
15:09:52 <lambdabot>   Nothing
15:09:52 <[BIOS]dnivra> and i tried b without 'L' it worked just according to the description i gave
15:09:59 <Sadache> Cale: can not I do it without using mondas? just with function composition as in the first version?
15:10:01 <Cale> > (\n xs -> guard (length xs > n) >> return ((liftM2 . liftM2) (,) take drop n xs)) 5 "Hello, World" :: Maybe (String, String)
15:10:02 <lambdabot>   Just ("Hello",", World")
15:10:09 <Axman6> [BIOS]dnivra: B = Branch i'd say
15:10:18 <Cale> Sadache: Well, you certainly need some sort of combinators which work with Maybe
15:10:20 <ksf> ...as you only use getNode once, you can just pass in (nameEq name) from there.
15:10:20 <Axman6> L = Leaf
15:10:32 <[BIOS]dnivra> Axman6: is it an in-built function or a notation or something of that sort?
15:10:39 <Axman6> no
15:10:42 <ksf> (a -> Bool) -> [a] -> Maybe a
15:10:49 <Cale> Sadache: I'm just using the monad ones because they happen to be what I want, but perhaps some other ones would be fine
15:11:04 <aavogt> > 4^4
15:11:04 <lambdabot>   256
15:11:08 <ksf> :t \f -> listToMaybe . filter f
15:11:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:11:10 <[BIOS]dnivra> so it was a wil guess Axman6?
15:11:15 <[BIOS]dnivra> wild*
15:11:21 <FunctorSalad> is there some existing thing in category-extras or so which transforms the functor F to /\ X -> F (Maybe X) ?
15:11:29 <Cale> Sadache: (If you're only using one monad, the fact that you're using a monad is unimportant)
15:11:33 <Axman6> yes, but it's a pretty common data structure (a binary tree)
15:11:34 <FunctorSalad> it pops up often when you do binders
15:11:43 <twanvl_> [BIOS]dnivra: B is defined in the first line as a constructor of the T data type
15:12:10 <Cale> I could points-free this...
15:12:22 <Axman6> don't do it Cale!
15:12:42 <Sadache> Cale: I beleive that if i do it without a monad it will be more concise. And the types tell something like this. The predicate take an int and a list, so does take, drop
15:12:42 <Cale> hehe
15:12:47 <BMeph> Is there a special name for data structures that could be infinite/codata that could be empty?
15:13:10 <ksf> @djinn (a -> Bool) -> [a] -> Maybe a
15:13:10 <lambdabot> Error: Undefined type []
15:13:15 <ksf> gragh.
15:13:18 <Cale> Sadache: Forget the fact that Option is a monad. You just need to find appropriate combinator functions involving Option
15:13:57 <Cale> Sadache: So what combinators already exist in the library?
15:14:03 <Sadache> Cale: so u dont think that it can work simply with lift and composition
15:14:06 <EnglishGent> a question - why is that if I try something like 'data Foo = Bar String | Quix Bar Bar' I get an error about Bar not being in scope, but 'data Foo = Bar String | Quix Foo Foo' compiles without problems?
15:14:06 <ksf> BMeph, finite codata?
15:14:08 <ksf> [a]?
15:14:17 <Cale> Sadache: How is it supposed to return an Option then?
15:14:37 * EnglishGent was surprised & expected all the constructors to be in scope
15:14:40 <ksf> EnglishGent, because Bar isn't a type.
15:15:00 <ksf> ...and you can't put constructors after those constructors.
15:15:25 <[BIOS]dnivra> Axman6: could you elaborate a bit for me "B is defined in the first line as a constructor of the T data type"
15:15:48 <[EF]pm> hi, wth does the &&& operator do?
15:15:49 <Sadache> Cale: toOption takes a predicate that takes an 'a , if I lift it it will take a function that takes a list and a count.
15:15:52 <[BIOS]dnivra> even some material that i could read will do: i'd like to try and understand myself
15:15:52 <EnglishGent> hmm - so how would you go about doing something with that kind of meaning ksf?
15:16:02 <[BIOS]dnivra> oh boy here we go again
15:16:04 <twanvl_> [BIOS]dnivra: the first line defines a data type called "T"
15:16:15 <mauke> > (f &&& g) x
15:16:17 <lambdabot>   Ambiguous type variable `c' in the constraints:
15:16:17 <lambdabot>    `GHC.Show.Show c'
15:16:17 <lambdabot>      a...
15:16:20 <Cale> heh
15:16:22 <[BIOS]dnivra> using the keyword data; got it
15:16:22 <twanvl_> [BIOS]dnivra: the type has two constructors, called "L" and "B"
15:16:28 <Twey> [EF]pm: Duplicates a value, applies the supplied arrows to each copy, then returns the results in a tuple
15:16:31 <Cale> :t (&&&)
15:16:33 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:16:43 <ksf> newtype Bar = Bar String, data Foo = MetaBar Bar | Quux Bar Bar
15:16:44 <Twey> > ((+ 1) &&& (* 3)) 2
15:16:45 <lambdabot>   (3,6)
15:16:52 <mauke> > (f &&& (g :: Expr -> Expr)) x
15:16:53 <Twey> (for the function arrow)
15:16:54 <lambdabot>   Ambiguous type variable `c' in the constraints:
15:16:54 <lambdabot>    `GHC.Show.Show c'
15:16:54 <lambdabot>      a...
15:17:00 <ksf> or something of that ilk.
15:17:05 <Cale> The most common usage is with a = (->), so that complicated type specialises to  (b -> c) -> (b -> c') -> (b -> (c,c'))
15:17:09 <twanvl_> [BIOS]dnivra: so each value of type T is either "L something" or "B something something"
15:17:10 <Axman6> [BIOS]dnivra: data T a = L a | B (T a) (T a) deriving (Show,Eq) is a declaration of a new data type: a T of type 'a' is either an  L with an 'a' in it, or a B with two other T's of type 'a', so you can have: B (L 1) (B (L 2) (L 3))
15:17:15 <EnglishGent> ty :)
15:17:19 <ksf> maybe a data family if that would clean up the rest of the code significantly.
15:18:02 <Cale> [EF]pm: If you're interested... maybe read about arrows here:
15:18:09 <[BIOS]dnivra> Hmmm so it's a declaration eh Axman6 and twanvl_?
15:18:10 <Cale> http://haskell.org/arrows/
15:18:11 <Sadache> Cale: I guess I am a bit confused, But types of the predicate, skip and drop are very similar. so I just doubt it can be done concisely. I can be very mistaken though
15:18:16 <Axman6> [BIOS]dnivra: yes
15:18:28 <Cale> Sadache: Do you have a combinator which turns an exception into an Option value?
15:18:33 <Axman6> [BIOS]dnivra: it's sort of like a struct in C, but far more useful
15:18:43 <Cale> Sadache: Like, does F# have first-class catch?
15:18:45 <[BIOS]dnivra> more like the class in C++ perhaps?
15:18:51 <Sadache> Cale: I dont want the exception to happen...
15:19:02 <Cale> Sadache: yeah, but if you catch it, then it won't.
15:19:04 <Axman6> i've never touched C++
15:19:23 <ksf> adt's are tagged structs in C parlance.
15:19:23 <[BIOS]dnivra> Axman6: ah ok right
15:19:23 <Cale> Sadache: that would be one way to go, anyway
15:19:25 <[EF]pm> Cale: I'm struggeling with the same challenge as dnivra does
15:19:26 <Sadache> Cale: not if i catch it, it did and i catched it...
15:19:27 <EnglishGent> consider yourself lucky Axman6 :)
15:19:39 <ksf> or variant records in pascal-land.
15:19:56 <Sadache> Cale: thank you anyway. I guess I need to get my idea clearer then maybe to come back
15:20:04 <Cale> Sadache: I'm thinking something like  catch (\e -> Nothing) (Just ...)
15:20:25 <Twey> catch on Maybe?
15:20:39 <Twey> Oh, for those weird magical exceptions that don't need to be built into the monad?
15:20:46 <Cale> Twey: I don't know F# syntax all that well, so I'm simulating it with Haskell
15:20:55 <Twey> Hum
15:20:58 <Cale> It's strict so it might have magic catchable exceptions :)
15:21:02 <Sadache> Cale: i am just affected by the myth (or not) that exceptions are expensive
15:21:05 <Twey> I suspect it does
15:21:05 <Axman6> [BIOS]dnivra: probably the most important thing about data constructors is that you can pattern match on them: myFunc (L x) = ...; myFunc (B l r) = ...;
15:21:22 <Cale> Sadache: Surely no more expensive than Option values?
15:21:33 <[BIOS]dnivra> Axman6: right overloading functions
15:21:45 <Axman6> [BIOS]dnivra: it's not overloaded at all
15:21:59 <[BIOS]dnivra> Axman6: no overloading?
15:22:02 <Axman6> so, you can have: sumTree (L x) = x; sumTree (B l r) = sumTree l + sumTree r
15:22:07 <Axman6> this isn't overloading
15:22:12 <[BIOS]dnivra> oh!!
15:22:17 <Cale> Sadache: After all, Option values and the various functions for manipulating them are more or less an explicit implementation of a simple exceptions system.
15:22:20 <[EF]pm> hm since &&& seems to be an arrow opeerator, why does hugs not understand the &&& arrow operator
15:22:20 <Axman6> classes do overloading:
15:22:21 <[BIOS]dnivra> so it's like the two are independent entities
15:22:24 <Axman6> :t (+)
15:22:25 <lambdabot> forall a. (Num a) => a -> a -> a
15:22:27 <Axman6> yes
15:22:28 <ksf> the cost of exception depends. when doing an a* in java I ended up testing outside of the bounds of the map, catching the exceptions instead on generating only valid neighbours for edge fields, as, overall, it was faster.
15:22:45 <Axman6> [BIOS]dnivra: L and B are both exactly the same type
15:22:56 <Axman6> they're just different versions of it
15:22:59 <Axman6> @src Maybe
15:23:00 <lambdabot> data Maybe a = Nothing | Just a
15:23:07 <Cale> [EF]pm: You need to import Control.Arrow
15:23:13 <[BIOS]dnivra> Axman6: Hmmm slowly making sense now; stil pretty vague
15:23:25 <Axman6> the Maybe type is with Just something, or Nothing, but both Just 1 and Nothing have the type Maybe Integer
15:23:31 <Cale> [EF]pm: at the hugs commandline, you can use :also Control.Arrow to load it, or at an import declaration to the top of your program
15:23:39 <[BIOS]dnivra> then again haskell has been difficult to learn thanks to C++ ;(
15:23:50 <Axman6> [BIOS]dnivra: what are you using to learn it?
15:24:04 <[BIOS]dnivra> Axman6: didn't get you?
15:24:06 <Cale> By the way, it's probably a good idea to understand monads rather well before attempting arrows.
15:24:13 <[BIOS]dnivra> Axman6: did you mean which compiler?
15:24:15 <Axman6> [BIOS]dnivra: are you following a tutorial?
15:24:30 <[BIOS]dnivra> Axman6: oh yeah lyah
15:24:31 <Cale> But for this silly contest thing, all you need to know is that (f &&& g) x = (f x, g x)
15:24:34 <Axman6> ah good
15:24:35 * ezyang remembers seeing a comparison of C++ template abusal to Haskell 
15:24:57 <[EF]pm> or import Control.Arrow :-)
15:25:52 <[BIOS]dnivra> @hoogle comparing
15:25:53 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:26:11 <Sadache> Cale: toOption takes 'a->bool then 'a and returns 'a Option. If I can find a way to make it take list -> int -> bool and int -> list -> list*list then I can easily compose it with the split function I guess
15:26:12 <Cale> > sortBy (comparing length) (words "here is a list of words to be sorted by length")
15:26:13 <lambdabot>   ["a","is","of","to","be","by","here","list","words","sorted","length"]
15:26:14 <Axman6> > comparing length "hello" "world"
15:26:15 <lambdabot>   EQ
15:26:52 <Axman6> Cale: sounded almost Shakespearean :P
15:29:05 <Cale> comparing p x y = compare (p x) (p y)
15:29:15 <Cale> > compare 3 5
15:29:17 <lambdabot>   LT
15:29:20 <Cale> > compare 5 5
15:29:22 <lambdabot>   EQ
15:29:24 <Cale> > compare 8 5
15:29:25 <lambdabot>   GT
15:29:49 <Cale> > comparing length "of" "words"
15:29:50 <lambdabot>   LT
15:30:08 <[BIOS]dnivra> Axman6: In the intrepreter, how do i intrepret this line "data T a = L a | B (T a) (T a) deriving (Show,Eq)"
15:30:26 <[BIOS]dnivra> it says "parse error on input data"
15:30:34 <[BIOS]dnivra> `data'
15:30:37 <Cale> [BIOS]dnivra: You can't. The interpreter wants expressions. Declarations go in a file and you load it.
15:30:42 <HugoDaniel> any suggestions on stuff to read about hard real-time haskell applications ?
15:31:17 <[BIOS]dnivra> i did that too cale even with including all library; it complains that the functions are not in scope
15:31:26 <Cale> Which functions?
15:31:52 <[BIOS]dnivra> all functions in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4853#a4853
15:32:02 <[BIOS]dnivra> starting from scratch
15:32:07 <[BIOS]dnivra> @hoogle sortBy
15:32:08 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
15:32:41 <[BIOS]dnivra> @hoogle comparing
15:32:41 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:32:52 <Cale> [EF]pm: I could tell you what it does, but wouldn't that spoil the contest?
15:33:04 <[BIOS]dnivra> Cale: it definitely would
15:33:25 <[EF]pm> would it? I think it's only relevant that you get the info not from where :-)
15:33:34 <[BIOS]dnivra> :t (&&&)
15:33:35 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:33:43 <[BIOS]dnivra> @hoogle &&&
15:33:43 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
15:33:50 <Cale> [EF]pm: I can explain the parts of the code
15:34:06 <Cale> [EF]pm: Let's start with group and sort
15:34:14 <[BIOS]dnivra> @hoogle insertBy
15:34:15 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
15:34:18 <Cale> > sort "abracadabra"
15:34:20 <lambdabot>   "aaaaabbcdrr"
15:34:20 <[EF]pm> I feel I'm interrupting your expanation from dnivra
15:34:46 <[BIOS]dnivra> @hoogle deriving
15:34:47 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
15:34:48 <Cale> [BIOS]dnivra: Add some import declarations to the top of the file to import the modules
15:35:00 <Cale> (deriving is not a function, it's syntax)
15:35:21 <[BIOS]dnivra> Cale: My bad i know; someone told me this already about deriving
15:35:44 <[BIOS]dnivra> Cale: Isn't it enough if i import the libraries at ghci and then load the file
15:35:49 <[BIOS]dnivra> wouldn't that work?
15:35:55 <Cale> No, that doesn't work.
15:36:03 <Cale> They have to be imported into the module where they're used.
15:36:30 <Cale> > group "mississippi"
15:36:32 <lambdabot>   ["m","i","ss","i","ss","i","pp","i"]
15:36:32 <[BIOS]dnivra> oh ok right; that must be why i went wrong.
15:36:38 <Cale> > group . sort $ "mississippi"
15:36:40 <lambdabot>   ["iiii","m","pp","ssss"]
15:37:00 <ray> > group . sort . nub $ "mississippi"
15:37:01 <Cale> > map length . group . sort $ "mississippi"
15:37:01 <lambdabot>   ["i","m","p","s"]
15:37:02 <lambdabot>   [4,1,2,4]
15:37:07 <Cale> > map head . group . sort $ "mississippi"
15:37:09 <lambdabot>   "imps"
15:37:20 <Cale> > map (head &&& length) . group . sort $ "mississippi"
15:37:22 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
15:37:45 <Axman6> [BIOS]dnivra: did you find out how to interpret that data declaration?
15:37:51 <Cale> > sortBy (comparing snd) . map (head &&& length) . group . sort $ "mississippi"
15:37:53 <lambdabot>   [('m',1),('p',2),('i',4),('s',4)]
15:37:59 <[BIOS]dnivra> Cale: data T a = L a | B (T a) (T a) deriving (Show,Eq) caused an error
15:38:00 <[BIOS]dnivra> [1 of 1] Compiling Main             ( try.hs, interpreted )
15:38:00 <[BIOS]dnivra> try.hs:5:69:
15:38:00 <[BIOS]dnivra>     Ambiguous type variable `a' in the constraint:
15:38:00 <[BIOS]dnivra>       `Ord a' arising from a use of `sort' at try.hs:5:69-72
15:38:00 <[BIOS]dnivra>     Possible cause: the monomorphism restriction applied to the following:
15:38:01 <[BIOS]dnivra>       b :: [a] -> T a (bound at try.hs:5:0)
15:38:03 <[BIOS]dnivra>     Probable fix: give these definition(s) an explicit type signature
15:38:05 <[BIOS]dnivra>                   or use -XNoMonomorphismRestriction
15:38:07 <[BIOS]dnivra> Failed, modules loaded: none.
15:38:16 <[BIOS]dnivra> oh no should have paste binned it
15:38:18 <[EF]pm> [BIOS]dnivra:  pastebin is your friend!
15:38:25 <Cale> @hpaste
15:38:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:38:49 <[BIOS]dnivra> sorry thought it'd come in a line my bad sorry
15:39:07 <[BIOS]dnivra> Axman6: No that's what's causing the error!!
15:39:28 <Cale> [BIOS]dnivra: The error doesn't say anything about the data declaration
15:39:32 <[BIOS]dnivra> Axman6: apparantely something that the a isn't defined
15:39:48 <twanvl_> The error is about b
15:39:48 <Cale> pff, figures they'd pick something which triggers the monomorphism restriction
15:39:53 <[BIOS]dnivra> oh!!
15:39:53 <Axman6> [BIOS]dnivra: it isn't actually the data type that's causing the error, it's the function type declaration
15:40:05 <mauke> it doesn't say "a is not defined" anywhere
15:40:07 <twanvl_> You need to add a type signature: b :: Ord a => [a] -> T a
15:40:09 <Cale> s/type//
15:40:20 <Cale> Or a parameter
15:40:33 <[BIOS]dnivra> why is that for?
15:40:36 <Cale> Or switch off the MR with {-# LANGUAGE NoMonomorphismRestriction
15:40:37 <Cale> oops
15:40:39 <Cale> Or switch off the MR with {-# LANGUAGE NoMonomorphismRestriction #-}
15:40:55 <Axman6> [BIOS]dnivra: you can't sort things that don't implement the Ord class
15:40:56 <[BIOS]dnivra> i mean it's because that's not needed for b is it?
15:41:33 <[BIOS]dnivra> Axman6: b has no mention of a and T in it's definition
15:41:40 <Cale> It's a stupid technical restriction that went into the Haskell 98 standard and basically everyone hates it. It forces you to write a type signature on certain polymorphic values.
15:41:47 <Axman6> [BIOS]dnivra: can you paste your code again?
15:41:53 <[BIOS]dnivra> sure thing
15:42:40 <[BIOS]dnivra> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4853#a4854 Axman6
15:43:37 <Axman6> [BIOS]dnivra: try http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4853#a4855 perhaps
15:43:50 <Axman6> subtle change
15:44:28 <[BIOS]dnivra> ok thanks
15:45:28 <[BIOS]dnivra> intrepreted successfully; thanks
15:45:35 <[BIOS]dnivra> not to run it
15:45:39 <[BIOS]dnivra> now*
15:46:28 <Cale> [BIOS]dnivra: It may be more instructive to break it into smaller pieces and run those separately
15:46:32 <Axman6> [BIOS]dnivra: i think iy would be helpful if the code was rewritten a little more. i'll do that for you, and hopefully it'll make the code make a little more sense
15:46:40 <[BIOS]dnivra> Axman6: How do i create an instance of a class?
15:46:56 <Axman6> i'll show you that in these changes if you like
15:46:58 <[BIOS]dnivra> i tried let m = T 4, where 4 is a value for a; no luck
15:46:58 <Cale> [BIOS]dnivra: the (.)'s are just function composition, which is associative, so you can break out anything being combined with dots and use it as a function :)
15:47:06 <[BIOS]dnivra> Axman6: Sure
15:47:13 <[BIOS]dnivra> oh!!
15:47:33 <[BIOS]dnivra> Cale: That's something cool ##I didn't know that!!
15:48:08 <Cale> [BIOS]dnivra: a is a type parameter, and T is a type constructor.
15:48:17 <Cale> [BIOS]dnivra: T takes a type and turns it into another type
15:48:22 <Cale> For example, T Integer is a type
15:48:38 <Cale> T doesn't exist on the value level
15:48:45 <[BIOS]dnivra> oh!!
15:48:47 <Cale> The values of type T are constructed using L and B
15:48:59 <Cale> Well, the values of type T a, for various types a
15:49:30 <Cale> Y'know what, I'm going to load this type definition into lambdabot so we can play with it.
15:49:41 <[BIOS]dnivra> Cale: okay
15:49:49 <Cale> (I can do that because I'm running lambdabot  :)
15:50:04 <[BIOS]dnivra> oh!! :)
15:50:30 <Cale> > L 5
15:50:32 <lambdabot>   L.hs:90:20:
15:50:32 <lambdabot>      Ambiguous occurrence `T'
15:50:32 <lambdabot>      It could refer to either `L....
15:50:35 <Axman6> [BIOS]dnivra: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4853#a4856
15:50:36 <Cale> sigh.
15:50:56 <mauke> @kind T
15:51:00 <lambdabot> *
15:51:03 <Axman6> [BIOS]dnivra: god naming helps with understanding no end ;)
15:51:08 <Cale> okay, your type will be called Tr
15:51:12 <Cale> instead of T
15:51:18 <[BIOS]dnivra> Axman6: ??
15:51:18 <Cale> because T is taken already in lambdabot :)
15:51:22 <mauke> what's that T?
15:51:23 <Axman6> Cale: it's called Tree now
15:51:23 <[BIOS]dnivra> Cale: Ok
15:51:30 <[BIOS]dnivra> ok
15:51:41 <Axman6> [BIOS]dnivra: look at the link i pasted
15:51:46 <Cale> data T a = L a | B (T a) (T a) deriving (Show,Eq)
15:51:48 <Cale> er
15:51:54 <Cale> ... how'd that happen
15:52:03 <Cale> I select the damn thing, and it doesn't...
15:52:14 <Cale> data Tr a = L a | B (Tr a) (Tr a) deriving (Show,Eq)
15:52:16 <Cale> there :)
15:52:17 <Cale> :t L
15:52:19 <lambdabot> forall a. a -> Tr a
15:52:22 <Cale> :t B
15:52:24 <lambdabot> forall a. Tr a -> Tr a -> Tr a
15:52:24 <[BIOS]dnivra> yeah got it it
15:52:27 <Cale> :t L 5
15:52:29 <lambdabot> forall t. (Num t) => Tr t
15:52:34 <Cale> :t L "hello"
15:52:35 <lambdabot> Tr [Char]
15:52:54 <Cale> > B (L 1) (B (L 3) (L 6))
15:52:55 <lambdabot>   B (L 1) (B (L 3) (L 6))
15:53:06 <Cale> This is how we make values of type Tr Integer
15:53:15 <Cale> (or Tr of various other types)
15:53:41 <[BIOS]dnivra> something wrong Axman6
15:53:46 <[BIOS]dnivra> Cale : got it
15:53:52 <Axman6> [BIOS]dnivra: what's wrong?
15:54:19 <[BIOS]dnivra> hold on
15:54:43 <Cale> > map (L . head &&& length) . group . sort $ "abracadabra"
15:54:44 <lambdabot>   [(L 'a',5),(L 'b',2),(L 'c',1),(L 'd',1),(L 'r',2)]
15:55:00 <[BIOS]dnivra> oh it' workin
15:55:05 <[BIOS]dnivra> is's*
15:55:06 <Cale> > sortBy (comparing snd) . map (L . head &&& length) . group . sort $ "abracadabra"
15:55:08 <lambdabot>   [(L 'c',1),(L 'd',1),(L 'b',2),(L 'r',2),(L 'a',5)]
15:56:35 <Cale> So we get a list of pairs of leaf trees containing the elements of the list, together with the number of times they occurred, sorted in ascending order of the number of occurrences.
15:57:38 <Cale> If we focus in on that last part there, the group . sort
15:57:42 <Cale> > group . sort $ "abracadabra"
15:57:44 <lambdabot>   ["aaaaa","bb","c","d","rr"]
15:57:52 <Cale> This is an interesting function in itself
15:58:00 <Cale> > group "mississippi"
15:58:02 <lambdabot>   ["m","i","ss","i","ss","i","pp","i"]
15:58:13 <Cale> group simply collects adjacent equal elements into lists
15:58:19 <Cale> If we sort first...
15:58:23 <Cale> > sort "mississippi"
15:58:24 <lambdabot>   "iiiimppssss"
15:58:35 <Cale> then equal elements will certainly be next to each other
15:58:41 <Cale> > group . sort $ "mississippi"
15:58:43 <lambdabot>   ["iiii","m","pp","ssss"]
15:58:52 <Cale> and so group will group them all correctly
16:00:21 <Cale> [EF]pm, [BIOS]dnivra: Follow all that?
16:00:54 <Cale> The next step is to take each group and get its length and its first element
16:01:21 <Cale> map f applies the function f to each element of a list
16:01:36 <Cale> head is the function for getting the first element of a nonempty list
16:01:45 <Cale> and length counts the length of a list
16:01:51 <Cale> > head "iiii"
16:01:53 <lambdabot>   'i'
16:01:56 <Cale> > lengt "iiii"
16:01:58 <lambdabot>   Not in scope: `lengt'
16:01:59 <Cale> > length "iiii"
16:02:01 <lambdabot>   4
16:02:24 <Cale> We can put them together into a single function which produces a pair of results using &&&
16:02:32 <Cale> > head &&& length $ "iiii"
16:02:34 <lambdabot>   ('i',4)
16:02:46 <[EF]pm> Cale: so far yes'ish
16:03:06 <Cale> > map (head &&& length) . group . sort $ "mississippi"
16:03:08 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
16:03:16 <[EF]pm> I got that before
16:03:22 <Cale> right
16:03:41 <Cale> So, we can take this oppourtunity also to pack each of those into a leaf node
16:03:46 <Cale> > map (L . head &&& length) . group . sort $ "mississippi"
16:03:48 <lambdabot>   [(L 'i',4),(L 'm',1),(L 'p',2),(L 's',4)]
16:04:01 <Cale> and then we sort by frequency
16:04:09 <Cale> (the second element of each pair)
16:04:20 <Cale> > snd (3,5)
16:04:21 <lambdabot>   5
16:04:44 <[BIOS]dnivra> @hoogle sortBy
16:04:45 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
16:04:54 <[EF]pm> Cale lost you their... i see tripples not pairs
16:05:05 <iaefai> Can I get the interpreted layout output from ghc, the thing that would have { } ; added before it tries to compile it?
16:05:06 <Cale> [EF]pm: L 'i' is just one thing
16:05:24 <Cale> [EF]pm: It's a tree which is just a leaf node holding the character 'i'
16:05:28 <[EF]pm> oh I saw a comma where was none
16:05:46 <[BIOS]dnivra> @hoogle comparing
16:05:47 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:06:15 <mauke> > sortBy (comparing length) ["a", "list", "of", "some", "words"]
16:06:16 <lambdabot>   ["a","of","list","some","words"]
16:06:42 <mauke> > sortBy (comparing reverse) ["a", "list", "of", "some", "words"]
16:06:44 <lambdabot>   ["a","some","of","words","list"]
16:08:30 <[BIOS]dnivra> #hoogle
16:08:41 <[BIOS]dnivra> @hoogle comparing
16:08:41 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
16:08:57 <mauke> @src comparing
16:08:58 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:08:59 <mauke> aww
16:09:57 <iaefai> Is there a way to read in a unicode file that may or may not have a BOM and not choke on it?
16:10:37 <copumpkin> YAY
16:10:46 <copumpkin> I just proved that there are infinite naturals
16:10:55 <copumpkin> took me way too long
16:11:32 <Axman6> can't you just say: Assume x is the largest natural, then Succ x is a larger natural, making it the new largest natural?
16:12:06 <copumpkin> Axman6: informally, sure
16:12:13 <mauke> if x is the largest natural, then clearly Succ x == x
16:13:46 <Elly> smallest counterexample is fine
16:13:54 <Elly> once you have shown that S x > x
16:14:37 <copumpkin> I did it in agda
16:16:56 <FunctorSalad> is there anything wrong with defining Eq for Codensity f as (==) = (==) `on` lowerCodensity?
16:17:19 <FunctorSalad> performance-wise
16:17:28 <FunctorSalad> since I have no idea of how this is evaluated ;)
16:18:12 <deech> Hi all, I have a question about Leksah. I have it installed and working but I'd like it to be able to pull up the source of a local package. Right now hitting the "Source" button does nothing. Any ideas?
16:28:41 <tensorpudding> hey, so cabal is preventing me from upgrading base, citing "internal error: impossible", I'm using ghc 6.10.1
16:29:15 <mauke> yes, 'base' is what comes with ghc
16:29:21 <Axman6> base comes with ghc, you can't (or really shouldn't) upgrade it with cabal
16:29:23 <mauke> if you want to upgrade it, get a new ghc
16:29:29 <tensorpudding> ah, darn
16:29:44 <Axman6> if you want a higher base, you need a later ghc
16:29:54 <tensorpudding> this ghc was compiled from source...maybe I'll use the new debian package
16:30:18 <[flux]texer> hi all
16:30:23 <[flux]texer> i have a problem
16:30:25 <Axman6> 'lo [flux]texer
16:30:57 <[flux]texer> tell me something about the following code-junk
16:31:06 <mauke> hah, another one
16:31:34 <iaefai> @hoogle parseFromFile
16:31:34 <lambdabot> Text.Parsec.ByteString parseFromFile :: Parser a -> String -> IO (Either ParseError a)
16:31:35 <lambdabot> Text.Parsec.String parseFromFile :: Parser a -> String -> IO (Either ParseError a)
16:31:35 <lambdabot> Text.Parsec.ByteString.Lazy parseFromFile :: Parser a -> String -> IO (Either ParseError a)
16:31:47 <[flux]texer> data T a = L a | B (T a) (T a) deriving (Show,Eq)
16:31:48 <[flux]texer> b = j . sortBy (comparing snd) . map (L . head &&& length) . group . sort
16:31:50 <[flux]texer> j ((t1,p1) : (t2,p2) : xs) = j $ insertBy (comparing snd) (B t1 t2, p1 + p2) xs
16:31:51 <[flux]texer> j [(t, _)] = t
16:31:52 <Axman6> ha
16:31:55 <iaefai> @src Text.Parsec.String parseFromFile
16:31:56 <lambdabot> Source not found. Do you think like you type?
16:32:01 <[flux]texer> can someone tell me w
16:32:02 <iaefai> @src Text.Parsec.String.parseFromFile
16:32:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:32:03 <mauke> [flux]texer: check the channel logs for the last few hours
16:32:06 <Axman6> [flux]texer: you're the second person with that exact same code in the last hour
16:32:10 <mauke> second?
16:32:16 <mauke> more like 4th
16:32:19 <Axman6> heh
16:32:19 <iaefai> @src parseFromFile
16:32:19 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:32:19 <[flux]texer> indeed? :)
16:32:23 <Axman6> well, second i've seen
16:32:27 <Axman6> [flux]texer: is this homework?
16:32:45 <mauke> Axman6: some kind of contest, I think
16:34:12 <medfly> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-String.html#parseFromFile
16:34:28 <Axman6> [flux]texer: where is the code from?
16:36:26 <sohum> :t foldl'
16:36:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:36:33 <sohum> :t foldl
16:36:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:36:49 <sohum> oh, right, one's the strict variant or somesuch
16:36:52 <sohum> @src foldl'
16:36:53 <lambdabot> foldl' f a []     = a
16:36:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:37:01 <monochrom> ja
16:37:01 <sohum> or parallel variant, my bad
16:37:09 <rgov> I'm trying to use hugs to run some code I did not write but I'm getting back 'undefined variable "sort"'
16:37:13 <sohum> no? strict?
16:37:23 <rgov> disclaimer: first 4 minutes haskell
16:37:25 <rgov> of*
16:37:25 <Axman6> strict
16:37:27 <monochrom> sort is in module List.  "import List"
16:37:37 <rgov> thanks
16:37:48 <Axman6> Data.List is preferred
16:38:18 <sohum> :t Data.Map.insertWith
16:38:19 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
16:38:20 <rgov> ok, now 'undefined &&&'
16:38:36 <sohum> @where (&&&)
16:38:37 <lambdabot> I know nothing about (&&&).
16:38:45 <sohum> hrm, I coulda sworn lambdabot had that
16:38:49 <tensorpudding> @hoogle (&&&)
16:38:50 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
16:38:51 <benmachine> @index (&&&)
16:38:51 <lambdabot> Control.Arrow
16:38:56 <Axman6> rgov: let me guess, this code starts with data T a = L a | B (T a) (T a)?
16:38:57 <sohum> index, danke
16:39:04 <rgov> Axman6:  have many people been in for it :)
16:39:07 <Axman6> yes
16:39:13 <Axman6> you're about the fifth
16:39:15 <rgov> did they walk away with the answer
16:39:19 <Axman6> and none of you will tell us where it's from
16:39:22 <[EF]pm> rgov: no we didnt
16:39:23 <Axman6> some did
16:39:44 <rgov> Axman6:  it's a trivia challenge in a game to figure out what it does
16:39:56 <Axman6> time to learn you some haskell:
16:39:59 <Axman6> @where lyah
16:39:59 <lambdabot> www.learnyouahaskell.com
16:40:05 <mauke> seriously, channel logs
16:40:13 <[EF]pm> Axman6: wrong answer the game ends in 79mns
16:40:18 <[EF]pm> :-)
16:40:27 <Axman6> we're not here to help you win games ;)
16:40:35 <Axman6> we're here to help you learn haskell
16:40:37 <[flux]texer> i will tell you where its from
16:40:39 <rgov> is there an index online
16:40:44 <monochrom> hugs doesn't have the library that contains &&&
16:40:48 <rgov> rather than have to bother the bot
16:40:52 <[flux]texer> when someone can tell me in a pm what this code is about
16:41:07 <mauke> @where hoogle
16:41:07 <lambdabot> http://haskell.org/hoogle
16:41:08 <Axman6> [flux]texer: go and find the channel logs
16:41:22 <[flux]texer> i actually read the channel logs
16:41:39 <Axman6> [BIOS]dnivra got a hell of a lot of help, because he asked nicely
16:41:42 <[EF]pm> well I kinda got what the code does, however, hugs does not 'run' it
16:41:54 <Axman6> Cale practically told him exactly what it did and how it works
16:41:59 <[flux]texer> but my haskel-skills are not good enough to understand the code
16:42:07 <c_wraith> Why do people still use hugs?
16:42:12 <Axman6> [EF]pm: use ghc then (with ghci)
16:42:17 <Axman6> c_wraith: who knows
16:42:17 <mauke> c_wraith: small, easy to build
16:42:30 <c_wraith> ah.  easy to build is actually a huge deal, compared to ghc
16:42:49 <Axman6> there is the haskell platform...
16:42:49 <c_wraith> (ghc's fine if there are binaries for your platform)
16:42:54 <Axman6> @where platform
16:42:54 <lambdabot> http://hackage.haskell.org/platform/
16:43:00 <Axman6> [EF]pm, [flux]texer ^^^^^^^^^^^
16:44:07 <[EF]pm> wait so my apt-get install ghc was in vain?
16:44:21 <Axman6> possibly
16:44:26 <c_wraith> depends on how old of a version it installed
16:44:37 <[EF]pm> ghc6
16:44:41 <Axman6> 6.what
16:44:42 <aavogt> @src (,) (&&&)
16:44:42 <lambdabot> Source not found. :(
16:44:43 <[EF]pm> 6.8
16:44:47 <c_wraith> 6.8 is ancient
16:44:58 <aavogt> it will run that code however
16:45:03 <iaefai> Any idea why when I try to do a cabal install parsec --reinstall it tries to install parsec 2.something when hackage has 3.0.1 here?
16:45:19 <Heffalump> iaefai: because parsec is deliberately pinned to <3 on the hackage server
16:45:33 <Heffalump> because 3.x has various problems like performance, so very few people are using it
16:46:21 <mauke> 6.8 isn't ancient
16:46:29 <tensorpudding> 6.8 is ancient?
16:46:37 <tensorpudding> isn't that what most linux package managers are using?
16:46:51 <Axman6> yes
16:46:52 <c_wraith> 6.8 feels ancient whenever I look at a tutorial and find code that doesn't run on 6.8
16:47:05 <c_wraith> Like RWH
16:47:16 <sohum> debian stable and testing are on 6.8, unstable on 6.10
16:47:25 <Axman6> anyone who's interested in writing haskell uses ghc 6.10 or even 6.12
16:47:46 <mauke> some people use hugs, actually
16:48:10 <aavogt> or any of those other compilers
16:48:22 <Axman6> some people use C++ >_>
16:49:06 <burp> ew, no?
16:49:07 <mauke> "and we ... we kill those people"
16:49:23 <tensorpudding> so how do you know what version of base is available with ghc?
16:49:33 <aavogt> ghc-pkg list base
16:49:39 <benmachine> mauke: euthanasia?
16:49:44 <tensorpudding> i mean, the ones available for download
16:50:01 <Axman6> they shouldn't be available for download
16:50:15 <tensorpudding> i'm talking about ghc
16:50:23 <aavogt> hmm, the version is probably mentioned in the release notes
16:50:30 <Axman6> well, 6.10 comes with base 4.something
16:50:31 <aavogt> which you can find in the ghc manual
16:50:50 <tensorpudding> apparently 6.10.1 isn't new enough
16:50:59 <mauke> for what?
16:51:05 <dons> c_wraith: should only be the exceptions stuff that doesn't work out of the box. and --constraint='base<4' will fix that
16:51:05 <tensorpudding> agda
16:51:06 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:51:08 <tensorpudding> from hackage
16:51:20 <sohum> 4.10, I believe
16:51:40 <tensorpudding> 4.1.0 is what i need but it would appear that it's not available in 6.10.1
16:51:58 <sohum> 4.1.0, my bad
16:52:09 <c_wraith> dons: Doesn't RWH have some regex stuff in it?
16:52:10 <mauke> I have 4.1.0.0 in ghc-6.10.2
16:52:16 <sohum> and I'm on 6.10.4, tensorpudding
16:52:25 <c_wraith> dons: as I recall, the regex stuff in RWH didn't work in 6.8
16:53:17 <tensorpudding> ah
16:53:27 <tensorpudding> apparently they upgraded to 4.1.0 in 6.10.1
16:53:34 <tensorpudding> err, 6.10.2
16:53:41 <sohum> you know, after playing with cpan a bit the other day
16:53:49 <sohum> I have to say I like cabal much better than cpan
16:53:50 <iaefai> Is there no simple way of reading in a UTF8 w/BOM file?
16:54:24 <deech> Is there a current library that allows dynamic loading of modules? I heard that hs-plugins is not really maintained anymore.
16:54:41 <c_wraith> deech: hint
16:54:52 <tensorpudding> cabal has gotten better since i started using it but it still feels kinda fragile
16:55:10 <Draconx> iaefai, the byte order mark is just an ordinary unicode codepoint...
16:55:19 <luite> dons: in uvector Prim/BUArr.hs, why is bOOL_SCALE 0 == 3 ? (on a 32 bit architecture)
16:55:36 <sohum> fragile how?
16:55:57 <iaefai> Draconx: I am trying to read it in with a parser and it chokes on it. Not sure what I can do to fix that.
16:56:10 <tensorpudding> compiles failing for weird reasons
16:56:16 <Draconx> iaefai, fix the parser, because it is broken.
16:56:34 <tensorpudding> and cabal getting confused and not letting you try installing them again
16:57:01 <sohum> *shrug*. never had that, and I believe I've removed packages from cabal's memory simply enough
16:57:01 <tensorpudding> i haven't seen this as much lately
16:57:18 <deech> c_wraith: I have never done this before, do I take a performance hit by dynamically loading a module? Can I "compile" them with optimization flags etc?
16:57:38 <iaefai> Draconx: Woulnd't a byte order mark be something that would translated characters into the right byte order before you try to do any text processing?
16:57:40 <tensorpudding> i had a thing where i had a conflict regarding monad libraries
16:58:01 <c_wraith> deech:  I haven't used it myself.  It's just what I was pointed at when I asked about it, and I filed it away for further research, since it's neat.
16:58:36 <Draconx> iaefai, the byte order mark is the unicode code point U+FEFF, encoded in the usual way.
16:58:49 <deech> c_wraith: thanks!
16:58:54 <tensorpudding> that wasn't so much cabal's fault though
16:59:42 <iaefai> Draconx: so I just have to interpret a character of that value?
16:59:50 <Draconx> iaefai, due to the way code points are assigned, this can identify the byte order in UTF-16 and UTF-32.  In UTF-8 it serves little purpose, but can nevertheless be encoded as a 3 octet sequence: EF, BB, BF.
17:00:38 <FunctorSalad> is it too corny to call the Set codensity 'cosensity'? ;)
17:00:55 <tensorpudding> ah, it involved mtl and monads-fd
17:00:56 <monochrom> codentistry
17:00:59 <tensorpudding> now i remember
17:01:21 <monochrom> code density
17:01:28 <FunctorSalad> seems like it would be useful in situations where you need Set to be a functor
17:01:35 <FunctorSalad> e.g. deriving Functor for type which hold sets
17:01:37 <c_wraith> Is the codentist the guy who keeps giving me candy and stealing my toothbtush?
17:01:52 <monochrom> yeah, and sugar water
17:02:05 <FunctorSalad> c_wraith: ^^
17:02:20 <FunctorSalad> *for a type
17:02:28 <monochrom> what is codensity?
17:02:39 <medfly> codentistry
17:03:03 <FunctorSalad> Codensity f a = Codensity (forall b. (a -> f b) -> f b) -- monochrom
17:03:08 <FunctorSalad> for Set you can make a special one
17:03:21 <FunctorSalad> Cosensity a = Cosensity (forall b. Ord b => (a -> Set b) -> Set b)
17:03:36 <Draconx> iaefai, yes, after decoding the utf-8 sequence with byte order mark, the first decoded code point will be U+FEFF.
17:03:41 <FunctorSalad> which is a Functor, and is sort of isomorphic to Set a in case Ord a
17:04:05 <FunctorSalad> (it's a monad even)
17:04:57 <Cale> medfly: ahaha
17:05:28 <medfly> actually, monochrom said the same thing before me
17:06:04 <Cale> Codentistry is where you sit in a chair and have someone jam teeth into your mouth.
17:06:14 <FunctorSalad> btw the "Cosensity" on the right-hand-side is supposed to be the data constructor
17:06:24 <FunctorSalad> data Cosensity a = Cosensity (forall b. Ord b => (a -> Set b) -> Set b)
17:06:27 <aavogt> a chair sits on you...
17:06:35 <Luke_> i'm trying to install platform but ld cannot find -lHSmtl-1.1.0.2 for happy. I have happy installed. anyone have any ideas?
17:06:38 <monochrom> jam tartar into between teeth
17:06:59 <aavogt> @quote soviet.*russia
17:06:59 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
17:06:59 <c_wraith> FunctorSalad:  I dislike having cutesy names, in general.  Is that what you were initially asking about?  It's a little too cute, but not painfully so.
17:07:19 <aavogt> @quote soviet.*russia
17:07:19 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
17:07:21 <FunctorSalad> c_wraith: got a better one? ;)
17:07:24 <Cale> Luke: are you a package maintainer for a linux distribution?
17:07:33 <Cale> Luke: er, or is this on linux at all?
17:07:35 <Luke> Cale: yes. apt
17:07:44 <c_wraith> FunctorSalad: better?  no.  More boring? SetCodensity   :)
17:07:52 <Luke> Cale: i'm following the instructions on the haskell platform page for Ubuntu
17:07:53 <Cale> Luke: hmm
17:08:09 <Vanadium> How do I get ghci's command line editing to not choke on home/end keys? (linux)
17:08:12 <Luke> Cale: http://davidsiegel.org/haskell-platform-in-karmic-koala/
17:08:16 <FunctorSalad> Codensetity
17:09:09 <Luke> Cale: I had some packages installed via apt and the build succeeded but install failed. I removed everything and started w/ only the deps listen on that page and now build fails on mtl for happy linking
17:09:56 <Cale> Luke: Do you have a log of the build?
17:10:15 <Cale> Luke: I would look to see if something went wrong building the mtl package and it only stopped later.
17:10:47 <Luke> Cale: let me check if make retained the log
17:11:26 <Luke> Cale: doesn't look like it. Want me to start over abd pastebin the build stdout?
17:11:30 <Cale> Or maybe it's because mtl doesn't get properly installed by the time happy is being built for some reason.
17:11:33 <Cale> Actually...
17:11:39 <Cale> why the heck is mtl not installed?
17:11:54 <Cale> Oh, ubuntu splits up the ghc packages super-fine
17:12:02 <Luke> aah i hate it =)
17:12:16 <Luke> they have an mtl package but I removed it because it was blocking the build before
17:12:24 <Luke> in compile. its interesting this is failing to link
17:17:45 <Luke> Cale: http://pastebin.com/da6f847c
17:17:53 <Luke> Cale: configure completed without issue
17:18:22 <Luke> "#
17:18:25 <Luke> Platform package mtl-1.1.0.2 is already installed. Skipping..." wtf
17:18:43 <Cale> lol
17:19:13 <Luke> second line of the make
17:19:23 <Luke> locate doesn't show it being installed...
17:19:36 <Cale> ghc-pkg mtl
17:19:54 <Cale> Maybe it's installed somewhere that you don't expect?
17:20:16 <Cale> (and the locatedb is out of date?)
17:20:26 <Luke> let me update the locatedb
17:20:43 <Luke> ghc-pkg needs a directive
17:22:09 <Cale> oh, list
17:22:12 <Cale> d'oh
17:22:14 <Luke> thanks =)
17:22:16 <Cale> ghc-pkg list mtl
17:22:41 <Luke> /var/lib/ghc-6.10.4/./package.conf: mtl-1.1.0.2
17:23:02 <Cale> okay, so it's installed systemwide, presumably as part of the ghc6 package?
17:23:14 <Luke> oooh could be - yes
17:23:18 <Cale> Or, do you have libghc6-mtl or whatever installed?
17:23:28 <Luke> after updatedb i see it in usr/local/lib
17:23:30 <Cale> Maybe they changed the way that they split up the libraries.
17:23:39 <Cale> ah
17:23:40 <Luke> Cale: no i dont have the package installed
17:23:48 <Luke> there is a package like that though
17:23:50 <Cale> So it was installed globally by a user :)
17:24:03 <Luke> hmm i probably did this in the past
17:24:23 <Luke> hmm today it says =)
17:24:23 <Luke> wtf
17:25:28 <iaefai> If I have a datatype like this: data Config = Config { documentRoot :: String } deriving (Read, Show)   and I have a [(String, string)] map, is there a way to get my map into my config data type in a very simple way? Presume that the Config might add entries later.
17:26:57 <Cale> iaefai: you mean, add a field to the datatype?
17:27:39 <iaefai> Cale, I mean I might add configuration options at a later date - so I don't want to hard code it
17:28:02 <iaefai> I basically want it to automatically convert the map to a Config data type with respect to what entries it has in it already
17:28:10 <iaefai> or raher defined with
17:28:41 <monochrom> So you mean a function of type Map String String -> Config ?
17:28:50 <Cale> iaefai: By encoding it as a string?
17:29:13 <Cale> iaefai: I guess you could write   Config { documentRoot = show myMap }
17:30:15 <iaefai> monochrom: essentially
17:30:41 <iaefai> Cale, that wouldn't get the datatype out ;-(
17:30:54 <aavogt> are the keys the names of the record fields?
17:31:00 <aavogt> (in the map that is)
17:31:11 <iaefai> aavogt: that would be the idea
17:31:22 <iaefai> I am hoping for some magic
17:31:33 <Cale> iaefai: I don't really understand what you're trying to do, and I don't think I have enough context to do so.
17:31:42 <Luke> Cale: I think i had a ton of cruft in /usr/local/lib which was confusing the make. Thanks for helping me track that down
17:31:49 <Cale> iaefai: from the definition, a Config value is just a string
17:32:06 <Cale> iaefai: so you seem to be asking me how to convert a list of pairs of strings to a string
17:32:19 <Cale> and my normal answer to that would be to apply show to it
17:32:24 <aavogt> iaefai: you would like for the function  Map String String -> Config to be generated based on the fields in the Config record?
17:32:37 <aavogt> that can be done with template haskell
17:32:39 <iaefai> aavogt: yes
17:32:40 <monochrom> Examples will help. Concrete examples. Or shall I say test cases and model answers.
17:32:59 <iaefai> aavogt: oh dear, can it be done simply with an example for somebody that has never touched that?
17:33:24 <Heffalump> you can do it with Data.Data, too
17:33:46 <Heffalump> I think
17:34:40 <iaefai> How might one do that?
17:35:23 <kmc> hello everyone
17:35:38 <kmc> iaefai, you're doing the sort of thing that might be done with getattr()/setattr() in Python?
17:35:41 <iaefai> kmc, hi
17:35:48 <iaefai> kmc, I suspect so
17:35:49 <Cale> iaefai: Oh! I see.
17:36:00 <kmc> a record is a map from compile-time names to values; a Map is a map from run-time names to values
17:36:08 <kmc> it's hard to make those two things mesh in Haskell
17:36:25 <Heffalump> iaefai: I'm not entirely sure :-) But basically I think that gives you a way of seeing the elements of a datatype at runtime and constructing/destructing the type.
17:36:30 <Cale> iaefai: So you want a function which looks for a pair whose first element is documentRoot and makes a Config value whose documentRoot value is the second element of that pair?
17:36:54 <Cale> iaefai: Supposing that efficiency isn't a big issue, you can just use a bunch of lookups.
17:37:06 <Cale> :t lookup
17:37:07 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:37:19 <Cale> in the Maybe monad...
17:37:26 <kmc> iaefai, do you know what Template Haskell is?
17:37:49 <iaefai> kmc, I believe it is similar in concept to lisp macros
17:37:52 <kmc> yeah
17:38:08 <iaefai> kmc, something I am not sure I have any business with :P
17:38:13 <kmc> you can have some haskell code executed at compile time, which computes the code to use in your program
17:38:36 <iaefai> Cale, let me show you two functions I am working on - an old one and a new one
17:39:26 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11942#a11942
17:39:58 <iaefai> The first version is using ConfigFile module, the second is using my stolen/modified parsec version
17:40:22 <kmc> Template Haskell error: Can't do `reify' in the IO monad
17:40:23 <kmc> bummer
17:41:09 <iaefai> I remember something about the either monad that would be very helpful, but I am not sure if there is a nice way of getting the config values serially like can be done with the first version with <$> and <*> (<*> not used because there is one value right now)
17:41:38 <iaefai> I am not sure how to tell the difference between the IO and Either monads in this context
17:42:15 <dons> luite: hmm.
17:42:50 <dons> luite: copied from the 'array' package
17:43:57 <kmc> @hoogle lift
17:43:57 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
17:43:57 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
17:43:57 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
17:47:39 <kmc> iaefai, i've been looking for a good project to learn Template Haskell so i think i'll try to do something vaguely along the lines of what you mentioned
17:47:45 <kmc> (unless i misunderstand it, which is possible)
17:47:50 <kmc> i'll let you know how it turns out
17:47:57 <iaefai> kmc, bless you :P
17:49:47 * Vanadium thanks the bytestring gods for the existence of mapAccumL
17:50:00 <monochrom> hehe
17:54:07 <Vanadium> Why is the equivalent of C's | in Data.Bits .|., yet the equivalent of << is `shiftL` and not .<<.? :(
17:55:29 <Lemmih> Vanadium: The names were taken.
17:55:38 <Lemmih> Vanadium: Oh, .<<., hm.
17:57:05 <monochrom> I am not a fan of following C conventions anyway.
17:57:07 <kmc> , 'crazyland
17:57:10 <lunabot>  luna: Not in scope: `crazyland'
17:57:17 <kmc> so i can't name-quote something not defined...
17:59:24 <aavogt> , [$ty| mkName |]
17:59:29 <lunabot>  String -> Name
17:59:42 <aavogt> , mkName "crazyland"
17:59:43 <lunabot>  crazyland
18:00:24 <aavogt> , show $ mkName "crazyland"
18:00:26 <lunabot>  "crazyland"
18:00:48 <aavogt> , $(mkName "head") "hello"
18:00:49 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
18:03:02 <mauke> Vanadium: better question, why is there no .^. ?
18:03:25 <Vanadium> or even ^.^
18:03:43 <aavogt> , $(return $ VarE $ mkName "head") "hello"
18:03:45 <lunabot>  'h'
18:04:23 <ezyang> You can't use _ or 8 or o... which rules out a lot of the smileys :o)
18:05:12 <Twey> > $(return . VarE $ mkName "head") "Hello"
18:05:14 <lambdabot>   <no location info>: parse error on input `$'
18:05:21 <Twey> :-\
18:05:27 <Twey> Oh
18:05:31 <Twey> , $(return . VarE $ mkName "head") "Hello"
18:05:32 <lunabot>  'H'
18:05:33 <Twey> Heh
18:08:51 <SamB_XP> dcoutts_: I may have figured out where that wierd restriction of GDI that windows be messed with in their creating threads ...
18:09:21 <johnbender> https://gist.github.com/8b33c53c248475894eb8 <-- anyone that can help me out here?
18:09:22 <Vanadium> @pl let (a, b) <- f s in g (h a) b
18:09:22 <lambdabot> (line 1, column 5):
18:09:22 <lambdabot> unexpected "("
18:09:22 <lambdabot> expecting "()", natural, identifier or "in"
18:10:05 <c_wraith> Vanadium:  try that in an @undo first
18:10:35 <Vanadium> err
18:10:36 <Twey> @pl let (a, b) = f s in g (h a) b
18:10:37 <lambdabot> (line 1, column 5):
18:10:37 <lambdabot> unexpected "("
18:10:37 <lambdabot> expecting "()", natural, identifier or "in"
18:10:44 <Vanadium> that was supposed to be a =, no monads this time
18:10:45 <Twey> Ah
18:10:50 <Twey>  @pl doesn't do let
18:10:57 <Vanadium> I think I get something like g . h `curry` f s
18:11:12 <Twey> Hm
18:11:17 <Twey> Yeah
18:11:27 <Twey> :t let (a, b) = f s in g (h a) b
18:11:29 <lambdabot> forall t t1 t2 t3. (SimpleReflect.FromExpr (t, t1), SimpleReflect.FromExpr (t -> t2), SimpleReflect.FromExpr (t2 -> t1 -> t3)) => t3
18:11:33 <Vanadium> Except with more braces
18:11:36 <Twey> :t g . h `curry` f s
18:11:38 <lambdabot>     Ambiguous type variable `a' in the constraints:
18:11:38 <lambdabot>       `Show a' arising from a use of `g' at <interactive>:1:0
18:11:38 <lambdabot>       `SimpleReflect.FromExpr a'
18:11:42 <_nickel> https://gist.github.com/8b33c53c248475894eb8 more specifically I'm having trouble compiling and the gist has the compiler output, could use some help as I thought that would work and can't figure out why it doesn't
18:11:44 <Twey> bah
18:11:48 <yitz> _nickel: use null instead of ==[]
18:11:54 <luite> dons: ah, I was trying to find out wat goes wrong when doing memcpyOffMU or memmoveOffMBU on a Bool array. the actual bool data starts at offset 0 of the src pointer passed to memcpy_offset, but the source offset is 3
18:12:59 <luite> dons: (this goes wrong anyway because memcpy does not know about the packing of the data)
18:13:25 <_nickel> yitz: I figured it out at least, it needs to be able to compare the elements in the list to compare the list, but what do you mean use null instead?
18:13:37 <yitz> @type null
18:13:38 <lambdabot> forall a. [a] -> Bool
18:13:39 <ezyang> _nickel: null is a function
18:13:41 <_nickel> yitz: null edges st
18:13:49 <yitz> > null []
18:13:50 <_nickel> yitz: wonderous
18:13:51 <lambdabot>   True
18:14:00 <_nickel> thanks all!
18:14:24 <yitz> @src null
18:14:25 <lambdabot> null []     = True
18:14:25 <lambdabot> null (_:_)  = False
18:15:07 <ezyang> Equality for Haskell lists is, in general, not well-defined, due to the existence of infinite lists.
18:15:26 <Twey> s/lists/data-structures/
18:15:30 <kmc> it's well-defined, but not computable
18:15:37 <yitz> ezyang: it's well-defined. but it may not terminate.
18:15:50 <ezyang> Right
18:16:01 <kmc> i think for any reasonable structure it's co-RE
18:16:09 <kmc> if two things are *not* equal you'll find out in finite time
18:16:27 <dons> luite: ahha
18:20:38 <kmc> @hoogle IO a -> Q a
18:20:39 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
18:20:39 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
18:20:39 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
18:22:08 <kmc> i'm using Language.Haskell.TH.Ppr and it renders a lifted string literal using the notation ['f','o','o','b','a','r']
18:22:23 <kmc> any tips for getting string literals in prettyprinted output?
18:27:58 <Luke> I'm trying to use the haskell pcap package w/ this error when loading: Loading package pcap-0.4.4 ... linking ... <interactive>: cabal/lib/pcap-0.4.4/ghc-6.10.4/HSpcap-0.4.4.o: unknown symbol `pcap_is_swapped'
18:28:16 <Luke> does that mean there's a problem w/ the haskell or the underlying pcap  lib?
18:28:24 <luite> dons: in Base.hs, bOOL_SCALE is only used to calculate lengths, for allocating new arrays. perhaps the wrong one is used in BUArr?
18:28:50 <Axman6> kmc: read . show?
18:29:14 <Axman6> wonder if you can do that within TH
18:32:28 <yitz> luite: the haskell
18:32:35 <yitz> missing binding?
18:32:44 <yitz> luke
18:32:51 <yitz> (sorry luite)
18:32:55 <luite> :)
18:33:03 <Luke> yeah it looks like I have libpcap etc installed OK
18:33:15 <Cale> Luke: I'd guess that the underlying library is missing or a different version than expected
18:33:18 <Luke> does cabal check the version of the library its binding against?
18:33:35 <Cale> I don't believe it does. If so, that would be new.
18:33:40 <dcolish> so i think HXT is much friendlier than HaXml, at least for basic parsing
18:33:53 <Luke> so I potentially have the wrong underlying C library
18:33:55 <Luke> version*
18:34:01 <yitz> dcolish: interesting. in what way?
18:34:50 <dcolish> well i think its a little clearer about how the parse actually happens with HXT
18:34:50 <Luke> anyone know where the version of libpcap as needed by the haskell bindings would be defined?
18:35:01 <dcolish> for me, HaXml appeared to be voodoo
18:35:25 <dcolish> i would like to know how the arrow library works in HXT as well, but i dont know about arrows yet
18:35:49 <yitz> dcolish: yeah, that's the thing about hxt
18:36:54 <yitz> dcolish: what seems like voodoo? i find haxml pretty clear - though a bit unwieldy sometimes. e.g., when walking through the tree
18:37:40 <dcolish> well i could not figure out how to actually match and pull outelements with out using the xmlParseWith function
18:37:54 <dcolish> and that seems to require writing a whole tag parsing fucntion of your own
18:38:14 <dcolish> the documentation for tag matching was kind of minimal too
18:38:15 <yitz> dcolish: no, i don't think you need to parse tags.
18:38:27 <dcolish> s/parse/match/
18:38:38 <yitz> dcolish: but you do need to work to pull out elements, though
18:39:02 <yitz> you mean match tag names?
18:39:06 <dcolish> si
18:39:34 <dcolish> every example i saw used a case to match tag names for exposing the tag's content
18:40:10 <yitz> dcolish: right
18:42:19 <kw317> what was the command to conjure a term of some type?
18:42:40 <kmc> @djinn (a -> (b -> a))
18:42:41 <lambdabot> f a _ = a
18:42:43 <mauke> undefined
18:42:48 <kw317> @djinn (forall b . (a -> b) -> b) -> a
18:42:49 <lambdabot> Cannot parse command
18:42:54 <kw317> @djinn (forall b . (a -> b) -> b)) -> a
18:42:55 <lambdabot> Cannot parse command
18:43:05 <kw317> hmm
18:43:10 <mauke> no foralls
18:43:16 <kw317> ah
18:43:18 <kw317> *sigh*
18:43:27 * kw317 needs a term of this type
18:43:31 <kmc> i'm ass-deep in Template Haskell
18:43:33 <Luke> Cale: I tried installing an earlier version of the library and now i cant reinstall the pcap haskell package
18:44:14 <kmc> i want something like this: [| \spec -> $body |]... that is, I want to compute the body of a lambda term and then use quotation to give it an arg
18:44:18 <byorgey> kw317: \f -> f id
18:44:32 <kmc> but how would i refer to the object-level variable "spec" within the metafunction "body"?
18:44:46 <kw317> different question: forall a . (a -> forall b . (a -> b) -> b) is the same as forall a, b . a -> (a -> b) -> b, right?
18:44:49 <byorgey> @type  (\f -> f id) :: (forall b . (a -> b) -> b) -> a
18:44:51 <lambdabot> forall a. (forall b. (a -> b) -> b) -> a
18:45:08 <yitz> @type id id
18:45:08 <kw317> byorgey: thanks!
18:45:09 <lambdabot> forall a. a -> a
18:45:23 <yitz> @type flip id id
18:45:24 <lambdabot> forall c a. ((a -> a) -> c) -> c
18:45:50 <yitz> @type flip id
18:45:51 <lambdabot> forall b c. b -> (b -> c) -> c
18:46:24 <byorgey> kw317: yes, I think so
18:46:43 <byorgey> kw317: at least, they are isomorphic
18:47:16 <kw317> byorgey: thanks
18:47:54 <JohnnyL> how do you seperate workloads amoungst manyc-ore/processors in Haskell?
18:48:31 <kmc> JohnnyL, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
18:49:50 <JohnnyL> kmc thanks!
18:49:52 <JohnnyL> :)
18:50:11 * Cale notices that Wordpress has a handy "categories" feature to keep track of which categories you're discussing in your blog posts.
18:50:29 <byorgey> Cale: yep =)
18:50:35 * Cale adds Set, Vec, Cat, and Grp
18:50:35 <kmc> JohnnyL, in Haskell unlike most languages, we have a distinction between parallel and concurrent programming
18:50:47 <byorgey> Cale: you have a blog?
18:50:55 <kmc> parallel programs are deterministic and seem like sequential programs, but run faster by using multiple cores
18:50:57 <medfly> Cale haz a blog!
18:51:00 <Cale> byorgey: It's new, I'm making it with a friend of mine.
18:51:12 <Cale> http://analogical-engine.com/wordpress/
18:51:13 <kmc> concurrent programs are ones where the observable behavior, not just the speed, depends on multiple threads of execution
18:51:38 <byorgey> Cale: nice!
18:51:41 <kmc> in fact it can be quite useful to do concurrent programming even with only one core
18:51:45 * byorgey subscribes to it
18:52:36 <Cale> We are hoping to eventually use it to lure people into paying for our tutoring services, but haven't worked on that part yet :)
18:52:43 <ezyang> subbed
18:53:33 <luite> you should charge micropayments for foldl evaluations ;)
18:55:03 <Cale> haha
18:55:14 <luite> but isn't (paid) tutoring something best done locally?
18:55:58 <luite> I think it's a good excuse to start a weblog though :p
18:56:27 <JohnnyL> kmc, interesting thanks!
18:56:31 <JohnnyL> :-)
18:57:08 <Cale> luite: Well, I've done paid tutoring online for money, and managed well with it. It's just hard finding customers.
18:57:19 <Cale> luite: Locally it would be even harder.
18:57:32 <Cale> I don't know how many people there are in Brantford who know what a category is.
18:57:53 <luite> I don't even know where Brantford is ;)
18:58:06 <Vanadium> Cale: Consider yourself lucky, if they all knew you might be out of business entirely.
18:58:07 <Cale> Right. It's a small city in southern Ontario.
18:58:21 <medfly> luite, he just doesn't want to tutor high school kids
18:58:41 <mshaw> it's where torontonians go to die
18:58:49 <medfly> haha
18:58:54 <Cale> ahaha, mostly true
18:58:59 <Luke> is anyone else able to get network.pcap working?
18:59:02 <Cale> I suppose I could tutor highschool kids too, if I got to decide what to teach them. ;)
18:59:10 <FunctorSalad> @unmtl Cont r a
18:59:10 <lambdabot> (a -> r) -> r
18:59:13 <medfly> see? that's his problem, too picky :)
18:59:19 <Cale> But I definitely would not go in for being a highschool teacher.
18:59:25 <FunctorSalad> terminology: is (a -> r) the continuation or is (a -> r) -> r ?
18:59:27 <medfly> tutor!
18:59:50 <LordDoskias> hi
19:00:03 <LordDoskias> http://pastebin.com/d7eb64939
19:00:08 <Cale> I completely disagree with the entire highschool curriculum in mathematics to the extent that it would drive me crazy to have to teach that.
19:00:10 <LordDoskias> can anyone tell me why my code is not working
19:00:21 <byorgey> FunctorSalad: (a -> r) is the continuation.
19:00:23 <LordDoskias> i moans about the assignment operator - largestSoFar = x
19:00:39 <FunctorSalad> byorgey: thanks, makes more sense :)
19:00:45 <Cale> LordDoskias: there are tabs and it's badly indented, but that's not the real problem
19:00:52 <Vanadium> Can I somehow write a lambda \{ field = binding} -> f binding?
19:01:04 <Vanadium> For record-ish types :<
19:01:17 <Cale> The reason the code doesn't work is because you switched to writing C code in the middle of a Haskell function.
19:01:19 <FunctorSalad> "Cont r a" could be called "a computation which has the goal of producing an r, but has only produced an a so far"?
19:01:28 <LordDoskias> Cale:  o_O
19:01:35 * araujo imagines Cale teaching monads to kids: "it is like when you play with legos , one block connected to other to make a figure"
19:01:36 <Cale> LordDoskias: Haskell doesn't have assignment like that
19:01:44 <aavogt> Vanadium: \(Constructor { field = x }) -> f x ?
19:01:59 <Cale> araujo: I have taught how to use monads to 11 year old kids. They picked it up surprisingly well.
19:02:11 <LordDoskias> tried with <- - same result
19:02:34 <Cale> LordDoskias: why not just call  innerLargest x xs ?
19:02:36 <byorgey> FunctorSalad: sure, something like that.  It
19:02:53 <LordDoskias> Cale: i'm trying some stuff
19:02:55 <LordDoskias> and right now
19:02:55 <araujo> Cale, I bet they would ... Haskell is not had language to "grasp" , I still thin most of the impediment is because of the well formed "imperative" thought ....
19:02:59 <Cale> LordDoskias: Configure your text editor such that it converts tabs to spaces automatically.
19:03:00 <byorgey> FunctorSalad: It's a computation which *could* produce an r, if you just got off your butt and told it what to do with the a it has sitting around.
19:03:20 <LordDoskias> i want to just assign x to largestSoFar if largestsofar < x
19:03:34 <araujo> but if you teach a kid how to write a function in haskell , in comparison with most of the languages out there, i bet they would understand the haskell version faster
19:03:35 <Cale> LordDoskias: Not in Haskell you don't. :)
19:03:42 <nolrai_FG> byorgey: talking about the prompt monad?
19:03:57 <byorgey> nolrai_FG: no, just Cont
19:03:58 <medfly> LordDoskias, what you actually want to do is re-run your function with other variables
19:04:03 <nolrai_FG> Ah
19:04:08 <Cale> LordDoskias: In Haskell, variables keep the same value as long as they remain in scope.
19:04:12 <byorgey> nolrai_FG: I have yet to get around to try grokking the Prompt monad yet.
19:04:14 <LordDoskias> i'm doing excercies on recursion
19:04:17 <Cale> LordDoskias: There is no primitive assignment operator.
19:04:22 <byorgey> er, *again
19:04:36 <byorgey> last time I tried (a couple years ago) it was way beyond me =)
19:04:38 <FunctorSalad> byorgey: I was looking at it in the way that it's "less" than a real 'a' because you may only use it for the purpose of making an 'r'
19:04:51 <Cale> LordDoskias: In order to use a different value for largestSoFar, you can call the function again with a different value for it.
19:05:02 <nolrai_FG> Its very usefull for writeing interactive stuff, like game engines.
19:05:08 <Cale> LordDoskias: Does that make sense?
19:05:18 <byorgey> FunctorSalad: well, but you also get to choose what 'r' you want
19:05:30 <byorgey> FunctorSalad: so if you want to know what the 'a' is, you just choose r = a and pass it id =)
19:05:36 <FunctorSalad> byorgey: ah yes, forall r. Cont r Foo is isomorphic to Foo
19:05:40 <byorgey> FunctorSalad: it's isomorphic to a.
19:05:43 <byorgey> right.
19:05:46 <FunctorSalad> I meant for a particular r
19:05:52 <byorgey> yes, for a particular r that's true
19:05:54 <LordDoskias> Cale: not much, i just hate haskell, but i have it in my course
19:06:08 <LordDoskias> as far as i'm concerned i just want to learn the basics .......
19:06:11 <EvanCarroll> can someone declare a simple function with an explicit type annotation
19:06:21 <Cale> LordDoskias: It is different from many other programming languages
19:06:28 <Vanadium> @type map
19:06:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:06:32 <LordDoskias> functional programming is different
19:06:33 <Vanadium> map :: whathesaid
19:06:36 <LordDoskias> i know.......
19:06:39 <Cale> LordDoskias: It's my favourite language out of the 15 or 20 that I've used :)
19:06:56 <FunctorSalad> byorgey: (context: was trying to understand these funny relatives of Cont like Ran, Codensity etc)
19:07:02 <Cale> http://pastebin.com/m3c570ab1
19:07:09 <Cale> ^^ fixed version
19:07:16 <mauke> needs more factoring
19:07:19 <Cale> Note the indentation.
19:07:22 <kmc> i find it encouraging the number of beginners who come here with homework
19:07:23 <nolrai_FG> What's Ran, Codensity?
19:07:32 <kmc> someone out there is forcing people to learn haskell ;)
19:07:33 <FunctorSalad> @hackage monad-ran
19:07:33 <lambdabot> http://hackage.haskell.org/package/monad-ran
19:07:37 <FunctorSalad> @ nolrai_FG
19:07:42 <kmc> @hackage totally-made-up-package
19:07:42 <lambdabot> http://hackage.haskell.org/package/totally-made-up-package
19:07:49 <medfly> kmc, I heard that some universities teach it
19:08:05 <FunctorSalad> I heard you like haskell
19:08:12 <medfly> so you...?
19:08:12 <FunctorSalad> :F
19:08:13 <Cale> actually, there's another bug in that code which I didn't fix.
19:08:21 <skorpan> it bothers me that some newbies seem to think there is assignment in haskell... starting off with that belief makes it hard to explain what they should do *instead*.
19:08:39 <medfly> FunctorSalad, what did you do!!!
19:08:52 <FunctorSalad> medfly: not much :(
19:09:12 <LordDoskias> Cale: yeah, but my main function just raised a lot of errors
19:09:17 <medfly> FunctorSalad, like the meme...
19:09:20 <skorpan> @hackage pony
19:09:21 <lambdabot> http://hackage.haskell.org/package/pony
19:09:21 <Cale> skorpan: Once you learn 5 or 6 languages that all use assignment as a basic operation, it's easy to think that all languages will.
19:09:40 <LordDoskias> http://pastebin.com/d786d524c
19:09:41 <LordDoskias> check this
19:10:16 <FunctorSalad> medfly: ah, you were preparing to apply the "so you can X while you X" meme?
19:10:20 <medfly> yeah
19:10:30 <FunctorSalad> I was alluding to the mudkipz meme
19:10:39 <medfly> oh.
19:10:40 <FunctorSalad> memetic confusion.
19:10:43 <medfly> hahaha
19:10:45 <Cale> LordDoskias: You're still indenting if/then/else incorrectly... though it probably doesn't matter here
19:10:49 <skorpan> LordDoskias: http://pastebin.com/d414639a4 <- better indented...
19:11:04 <medfly> FunctorSalad, I like Haskell :)
19:11:05 <nolrai_FG> ghc inside your ghci, so you can haskell while you haskell.
19:11:21 <Cale> LordDoskias: If the things in your list are numbers, you're going to want to use the show function to turn them into strings before using ++ to concatenate
19:11:53 <medfly> @type (++)
19:11:54 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:12:02 <FunctorSalad> ahhh Caleskell
19:12:05 <FunctorSalad> :)
19:12:06 <medfly> haha
19:12:28 <skorpan> wtf, lambdabot does caleskell now?
19:12:39 <nolrai_FG> has for a while.
19:12:43 <skorpan> why?
19:12:47 <medfly> because he runs it
19:12:48 <Cale> heh, I noticed that hint got better at handling qualified imports
19:12:49 <nolrai_FG> Hasn't it?
19:12:55 <FunctorSalad> (++) = mappend is pretty popular I think
19:12:57 <LordDoskias> it worked, thanks
19:12:58 <skorpan> wow, that's so retarded
19:13:02 <Cale> skorpan: hah
19:13:11 <Cale> skorpan: It's nice
19:13:17 <skorpan> Cale: not for newbies it's not :P
19:13:19 <medfly> Cale, what's the normal (++)?
19:13:26 <Cale> medfly: the one for lists
19:13:27 <FunctorSalad> just for lists
19:13:28 <mauke> :t (Data.List.++)
19:13:30 <lambdabot> forall a. [a] -> [a] -> [a]
19:13:36 <medfly> Cale, no no
19:13:45 <medfly> Cale, how do I use the normal (++) on your Caleskell?
19:13:49 <FunctorSalad> it's not only pretty, it's even useful if you want to drop in say bytestrings for your lists
19:13:53 <medfly> though I think Hascale is better
19:13:54 <skorpan> the normal (++) IS mappend
19:14:11 <Cale> medfly: Well, the normal (++) is a special case of this (++)
19:14:21 <mauke> > "med" ++ "fly"
19:14:21 <medfly> it works better pronunciation wise
19:14:22 <medfly> right?
19:14:22 <lambdabot>   "medfly"
19:14:27 <medfly> oh, okay... cool
19:14:29 <Cale> medfly: yeah
19:14:31 <kmc> if x :: Name, how do i splice x into a quotation?
19:14:39 <kmc> if i write [| foo $x |] it complains that x is not ExpQ
19:14:58 <FunctorSalad> , [| $( ConT '[] ) |]
19:14:59 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
19:15:01 <Cale> LordDoskias: are you reading any Haskell tutorials?
19:15:03 <FunctorSalad> , [| $( ConE '[] ) |]
19:15:04 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
19:15:10 <FunctorSalad> , [| $( conE '[] ) |]
19:15:12 <lunabot>  ConE []
19:15:14 <Cale> LordDoskias: LYAH is rather good
19:15:16 <Cale> @where lyah
19:15:17 <lambdabot> www.learnyouahaskell.com
19:15:36 <Cale> LordDoskias: you can also feel free to ask any questions about Haskell you might have here.
19:15:36 <FunctorSalad> kmc: sorry couldn't think of any better name than '[]
19:15:40 <LordDoskias> Cale: i'm reading my lecture notes, and unfortunately there is nothing about this assignment stuff
19:15:40 <aavogt> , lamE []
19:15:41 <lunabot>  luna: No instance for (GHC.Show.Show
19:15:57 <aavogt> TH abbreviations are funny
19:15:58 <Cale> LordDoskias: That would be because there is no assignment in Haskell.
19:15:59 <medfly> LordDoskias, are they assuming you don't know how to program in another language?
19:16:06 <FunctorSalad> , null $( conE '[] )
19:16:08 <lunabot>  True
19:16:27 <kmc> okay, so i'd use [| $(varE x) |]
19:16:33 <FunctorSalad> , (\x -> $( varE 'x )) 10
19:16:34 <lunabot>  10
19:16:42 <Cale> LordDoskias: Oh, or you mean the lecture notes don't cover the assignment questions, not ":=" assignment ;)
19:16:42 <FunctorSalad> wow didn't expect that to work
19:16:47 <FunctorSalad> that's nice
19:17:01 <LordDoskias> no
19:17:03 <FunctorSalad> kmc: varE 'x
19:17:16 <kmc> FunctorSalad, doesn't that refer to an object-lang x?
19:17:19 <Cale> LordDoskias: Maybe follow along with lyah, and it'll straighten things out for you a bit :)
19:17:26 <LordDoskias> i'm referring to the assignment in haskell like - retaining values in scope, etc
19:17:30 <kmc> i have a meta-variable x :: Name, and i want to use that Name for a variable
19:17:31 <FunctorSalad> kmc: 'x is the name of x
19:17:40 <FunctorSalad> kmc: ah then your version, yes
19:17:42 <kmc> (varE x) is exactly what i wanted
19:17:44 <kmc> thanks all
19:17:54 <Cale> LordDoskias: Variables don't change their values in Haskell. They're like variables in mathematics.
19:18:09 <Cale> LordDoskias: If x = 5, you can't go and say that x = 6 later.
19:18:32 <LordDoskias> yeah, in maths i can say - x =y = z = 6
19:18:40 <Cale> LordDoskias: and of course, x = x + 1, well, there's no defined integer which satisfies that. :)
19:18:49 <medfly> what you say
19:18:50 <tensorpudding> infinity!
19:18:50 <FunctorSalad> , [ty$| lamE |]
19:18:52 <lunabot>  luna: parse error on input `|]'
19:18:52 <medfly> there's one :)
19:18:56 <FunctorSalad> , [$ty| lamE |]
19:18:59 <lunabot>  [] PatQ -> ExpQ -> ExpQ
19:19:05 <Cale> infinity is not an integer ;)
19:19:11 <FunctorSalad> aavogt ^^
19:19:13 <tensorpudding> let's work in the extended natural numbers
19:19:24 <EvanCarroll> LYAH is far from perfect.
19:19:32 <Cale> EvanCarroll: sure, but it's something :)
19:19:42 <tensorpudding> it's a haskell, you can learn it, and it's good
19:19:47 <Cale> It seems pretty friendly and explains the basics well, I think.
19:19:59 <medfly> it has cute drawings and everything!!!!11111
19:20:00 <FunctorSalad> extended natural numbers?
19:20:01 <Cale> If you don't like it, there's also...
19:20:02 <tensorpudding> i need to get back to reading RWH
19:20:04 <Cale> @where rwh
19:20:05 <lambdabot> is http://www.realworldhaskell.org/blog/
19:20:12 <Cale> mmf
19:20:15 <EvanCarroll> yea, but if its /enough/ material for someone who has never done real functional programming to learn haskell, eh not likely
19:20:38 <EvanCarroll> I think I just finished the section on explicit type definitions and I have no idea how to declare one.
19:20:39 <tensorpudding> there is an extended real numbers, but i don't think anyone's ever used the extended natural numbers
19:20:44 <LordDoskias> Cale: if one comes from any other non functional language then haskell is like singularity
19:20:49 <LordDoskias> it just doesn't obey the norms...
19:20:50 <Cale> @where+ rwh http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:20:51 <lambdabot> It is forever etched in my memory.
19:21:20 <Cale> LordDoskias: That's right, but it wouldn't be worth learning if it was just another reskinned version of C# or Java
19:21:21 <EvanCarroll> Cale: nifty, thanks
19:21:34 <tensorpudding> C#, now with lime
19:21:39 <LordDoskias> well yeah
19:21:43 <LordDoskias> so basically
19:21:59 <LordDoskias> if largestSoFar <	 x
19:21:59 <LordDoskias> 		then
19:22:00 <LordDoskias> 			innerLargest x xs
19:22:06 <Cale> (and, this is opinion, but I think the trouble learning it is more than worthwhile)
19:22:13 <LordDoskias> by calling, i'm in effect assigning x to largestsofar
19:22:15 <LordDoskias> right?
19:22:26 <mauke> well, we call it "binding"
19:22:26 <Cale> Kind of, if you'd like to think of it that way
19:22:40 <mauke> and that binding only exists within the inner function call
19:22:45 <SmurfOR> LordDoskias, you could try Graham Hutton's "Programming in Haskell" book, there's a series of lectures on channel 9 relating to the book too which are a good learning tool (albeit only 6 of the 13 lectures are finished)
19:23:10 <Cale> You're really saying that the value of innerLargest largestSoFar (x:xs) in that case is the same as the value of innerLargest x xs
19:23:12 <Cale> er
19:23:16 <Cale> yes
19:23:16 <aavogt> FunctorSalad: what about the lame function?
19:23:39 <Cale> another good thing is the wikibook
19:23:42 <Cale> @where wikibook
19:23:43 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:24:01 <aavogt> is it possible to convert a function   a -> Exp  to an Exp?
19:24:04 <Cale> @where yaht
19:24:05 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
19:24:11 <Cale> ^^ and that one's also not bad
19:24:18 <nolrai_FG> SmurfOR: whats channel 9?
19:24:22 <Cale> aavogt: If you have an a
19:24:34 <SmurfOR> nolrai_FG, http://channel9.msdn.com/
19:24:38 <aavogt> I get stage errors when I try the sensible   [| \x -> $( return $ f x) |]
19:24:55 <kmc> metaprogramming is hard
19:24:55 <aavogt> Cale: no, I don't have an a, but there should be one after running the splice
19:25:29 <SmurfOR> nolrai_FG, more specifically this: http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
19:25:32 <FunctorSalad> , [| \x -> $( return $ f  'x ) |]
19:25:33 <lunabot>  luna: No instance for (Luna.SimpleReflect.FromExpr
19:25:37 <Cale> .oO("If I know that if it were raining then I would be wet, is it possible to tell if I'm wet?")
19:25:50 <FunctorSalad> , [| \x -> $( return ( f  'x )) |]
19:25:51 <nolrai_FG> SmurfOR: thanks!
19:25:53 <lunabot>  luna: No instance for (Luna.SimpleReflect.FromExpr
19:26:04 <FunctorSalad> , [| \x -> $( return ( f  $( varE 'x ))) |]
19:26:06 <lunabot>  luna: Illegal splice at level Splice 1
19:26:13 <FunctorSalad> oh no illegal splice
19:26:16 <Cale> TH is insane ;)
19:26:40 <aavogt> is metaprogramming in other languages easier?
19:26:53 <Cale> Well, in languages with very simple syntax like lisp, it is.
19:26:54 <roconnor> I hear good thing about metaocaml
19:26:56 <roconnor> it is typed
19:27:14 <FunctorSalad> aavogt: maybe try the abstract syntax instead of messing with quotation
19:27:16 <kmc> roconnor, but that also makes it much more limited
19:27:21 <FunctorSalad> (quotation is a bit limited indeed)
19:27:36 <roconnor> kmc: that's what lisp people say about haskell
19:27:47 <kmc> i'm glad haskell has good metaprogramming, i'm also glad that due to laziness, first-class everything, and general awesomeness, we don't have to use it much
19:27:51 <nolrai_FG> > snd . RWS.execRWS
19:27:52 <lambdabot>   Not in scope: `RWS.execRWS'
19:28:01 <kmc> roconnor, but i think there's actually a precise statement here
19:28:02 <Cale> kmc: For some values of good.
19:28:12 <kmc> i.e. a theorem you could prove
19:28:18 <roconnor> kmc: technically the lisp peole are right too
19:28:19 <FunctorSalad> roconnor: TH is typed too
19:28:28 <roconnor> I should stay out of this
19:28:34 <roconnor> I've never used TH or metaocaml
19:28:34 <aavogt> FunctorSalad: well the difficulty with that approach is to make sure that the  x inside the LamE is the same one as the one passed to my function
19:28:49 <LordDoskias> if a have func :: [a] ->[a]
19:29:03 <LordDoskias> and then func [x] = bla
19:29:05 <LordDoskias> what does it mean
19:29:07 <FunctorSalad> well, TH itself is typed. it doesn't typecheck the produced code
19:29:09 <Cale> aavogt: I think what you usually do is generate a name, and then construct the lambda by hand using that name
19:29:14 <kmc> FunctorSalad, it does
19:29:19 <Cale> aavogt: but, I also haven't used TH much
19:29:27 <mmorrow> FunctorSalad: it does if you attempt to splice it
19:29:27 <FunctorSalad> but ghc does that, so I don't see the point of knowing about the object language types in the metalanguage
19:29:30 <LordDoskias> i know the first is the type signature
19:29:33 <kmc> your metaprogram is typechecked, then run, and its output is typechecked
19:29:43 <mauke> LordDoskias: it means func takes a list of a's and returns a list of a's (where 'a' is any type)
19:29:54 <kmc> in metaocaml the type of the metaprogram includes the type of the output
19:30:00 <nolrai_FG> LordDoskias: the second is the deffinition.
19:30:01 <kmc> which excludes a lot of very simple and useful TH metaprograms
19:30:01 <mauke> LordDoskias: it also means when func is called with a list of one element, it returns bla
19:30:06 <Cale> LordDoskias: the func [x] = bla  means that the value of func applied to a list of length 1 is bla
19:30:21 <Cale> (a list of length 1 whose sole element is called x)
19:30:23 <mmorrow> , ppDoc <$> (do x <- newName "x"; let {f = lamE [varP x] (appE (varE x) (varE x))}; f `appE` f)
19:30:24 <lunabot>  (\x_0 -> x_0 x_0) (\x_0 -> x_0 x_0)
19:30:30 <LordDoskias> thanks
19:30:31 <FunctorSalad> aavogt: how are you passed the x?
19:30:33 <mmorrow> , $(do x <- newName "x"; let {f = lamE [varP x] (appE (varE x) (varE x))}; f `appE` f)
19:30:34 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = t -> a
19:30:43 <Cale> LordDoskias: In Haskell, we write lists like [1,2,3], so [x] looks like a list with just one thing in it there.
19:30:46 <mmorrow> , (do x <- newName "x"; let {f = lamE [varP x] (appE (varE x) (varE x))}; f `appE` f)
19:30:47 <lunabot>  AppE (LamE [VarP x_0] (AppE (VarE x_0) (VarE x_0))) (LamE [VarP x_0] (App...
19:31:05 <kmc> we tend to use metaprogramming to get around the lack of dependent types... if we force our metaprogram types to manifest the output type, we're back where we started
19:31:09 <mauke> > let func :: [a] -> [a]; func [x] = [x, x, x]  in  func [42]
19:31:11 <lambdabot>   [42,42,42]
19:31:11 <Cale> LordDoskias: It matches that pattern against the parameter you provide, and if the match succeeds, the result is whatever's on the right hand side of the = sign
19:31:16 <mmorrow> kmc: right
19:31:23 <kmc> however TH does typecheck quotations *before* nested splices are applied, which is not strictly necessary
19:31:45 <FunctorSalad> I didn't mean to say that the produced code isn't typechecked :)
19:31:46 <Cale> LordDoskias: It tries the patterns in order from top to bottom, so it's best to put specific cases before general ones.
19:31:46 <mmorrow> kmc: well, since they can do arbitrary IO to produce their result..
19:31:57 <kmc> but supposedly makes errors manifest earlier
19:31:59 <aavogt> Cale, FunctorSalad: I get stage errors again with   do x <- newName "hahahh"; return $ LamE (VarP x) (f $(VarE x))
19:32:21 <aavogt> actually the LamE takes a list ;)
19:32:29 <mmorrow> , src 'LamE
19:32:31 <lunabot>  data Exp = ... | LamE ([Pat]) Exp | ...
19:32:31 <lunabot>  infixl 9
19:32:34 <Cale> aavogt: I really don't know TH all that well
19:32:40 <mmorrow> , [$ty| LamE |]
19:32:43 <lunabot>  [] Pat -> Exp -> Exp
19:32:44 <mmorrow> , [$ty| lamE |]
19:32:47 <lunabot>  [] PatQ -> ExpQ -> ExpQ
19:32:53 <nolrai_FG> @unmlt RWST m r s w
19:32:53 <lambdabot> Maybe you meant: unmtl unpl
19:32:55 <mmorrow> type ExpQ = Q Exp
19:32:59 <mmorrow> type _Q = Q _
19:33:00 <nolrai_FG> @unmtl RWST m r s w
19:33:00 <lambdabot> err: `RWST m r s w' is not applied to enough arguments, giving `/\A. m -> s -> w (A, s, r)'
19:33:04 <nolrai_FG> @unmtl RWST m r s w a
19:33:04 <lambdabot> m -> s -> w (a, s, r)
19:33:14 <LordDoskias> test (y:x:xs) - y is the first element of list xs and x is the second - right?
19:33:19 <FunctorSalad> aavogt: do x <- newName "haha"; return $ LamE [VarP x] (AppE (VarE 'f) (VarE 'x))
19:33:21 <Cale> LordDoskias: right
19:33:39 <Cale> LordDoskias: and xs is the rest of the list
19:33:41 <aavogt> FunctorSalad: so I need the Name of the Name?
19:33:47 <mauke> LordDoskias: well, xs is the rest of the list. y is not the first element of xs.
19:33:48 <FunctorSalad> aavogt: err no, my fault
19:33:55 <mmorrow> , ppDoc (do x <- newName "ahaha"; lamE [varP x] [|\f -> f $(varE x)|])
19:33:56 <lunabot>  luna: No instances for (Data.Data.Data
19:34:02 <mmorrow> , ppDoc <$> (do x <- newName "ahaha"; lamE [varP x] [|\f -> f $(varE x)|])
19:34:03 <lunabot>  \ahaha_0 -> \f_1 -> f_1 ahaha_0
19:34:08 <FunctorSalad> insanity
19:34:10 <Cale> oh, yeah
19:34:15 <nolrai_FG> @unmtl RWST r w s m a
19:34:15 <lambdabot> r -> s -> m (a, s, w)
19:34:25 <nolrai_FG> Ok
19:34:40 <Cale> LordDoskias: For instance, if we match (y:x:xs) against [1,2,3,4,5], then y = 1, x = 2, and xs = [3,4,5]
19:35:12 <mauke> > case [1,2,3,4,5] of (y:x:xs) -> (y, x, xs)
19:35:14 <lambdabot>   (1,2,[3,4,5])
19:36:01 <mmorrow> , ppDoc <$> (let go n e | n < 1 = e | otherwise = [|\f -> f $(go (n-1) [|show $e|])|] in go 4 [|()|])
19:36:03 <lunabot>  \f_0 -> f_0 (\f_1 -> f_1 (\f_2 -> f_2 (\f_3 -> f_3 (show (show (show (sho...
19:36:07 <mmorrow> , ppDoc <$> (let go n e | n < 1 = e | otherwise = [|\f -> f $(go (n-1) [|show $e|])|] in go 2 [|()|])
19:36:08 <lunabot>  \f_0 -> f_0 (\f_1 -> f_1 (show (show ())))
19:36:40 <aavogt> mmorrow: I want exactly that, except the f is supposed to come from outside of the whole thing
19:36:49 <mmorrow> , ppDoc <$> (let go n e | n < 1 = e | otherwise = [|\f -> show $(go (n-1) [|f $e|])|] in go 2 [|()|])
19:36:51 <lunabot>  \f_0 -> show (\f_1 -> show (f_1 (f_0 ())))
19:37:11 <mmorrow> , ppDoc <$> (do x <- newName "ahaha"; lamE [varP x] [|\f -> f $(varE x)|]) {- ? -}
19:37:12 <lunabot>  \ahaha_0 -> \f_1 -> f_1 ahaha_0
19:37:24 <mmorrow> oh, you want to pre-specify f
19:37:43 <mmorrow> is `f' a (ExpQ -> ExpQ) or an ExpQ that represents a function?
19:38:19 <aavogt>     f :: a -> Exp
19:38:19 <aavogt>     var <- newName "hah"; return $ lamE [varP var] (f $(varE var))
19:39:01 <mmorrow> $(varE var) is trying to splice something that doesn't exist yet though
19:39:52 <mmorrow> the two options you have here, depending on whether f is a /quoted/ function, or a /real function taking a quoted expression to the same/ are:
19:40:01 <aavogt> well, the short (and wrong) thing to do is   [| \x  -> $f x |]
19:40:29 <mmorrow> , ppDoc <$> (let go f = do x <- newName "ahaha"; lamE [varP x] [|$f $(varE x)|] in go [|\x -> (x,x)|])
19:40:31 <lunabot>  \ahaha_0 -> (\x_1 -> (x_1, x_1)) ahaha_0
19:41:13 <nolrai_FG> forM is a permutaion of something right?
19:41:18 <mmorrow> , ppDoc <$> (let go f = do x <- newName "ahaha"; lamE [varP x] (f (varE x)) in go (\x -> [|\f -> ($x, f $x)|]))
19:41:20 <lunabot>  \ahaha_0 -> \f_1 -> (ahaha_0, f_1 ahaha_0)
19:41:25 <aavogt> @src forM
19:41:25 <lambdabot> forM = flip mapM
19:41:50 <mmorrow> (\x -> [|\f -> ($x, f $x)|]) :: ExpQ -> ExpQ
19:42:16 <mmorrow> [|\x -> (x,x)|] :: ExpQ     (clearly)
19:43:40 <mmorrow>  (\x -> ..level_0.. [|..level_1 .. $(.. level_0 .. [|.. level_1 $(.. level_0 .. ) .. |] ..) .. level_1 ..|])
19:44:13 <mmorrow> unfortunately you can't use TH in TH at the moment
19:44:44 <mmorrow> but you can hack around that in various semi-tedious ways :)
19:45:55 <mmorrow>   (\x -> [|\x -> ($x,x)|]) [|()|]
19:46:02 <mmorrow> ,  ppDoc <$> (\x -> [|\x -> ($x,x)|]) [|()|]
19:46:03 <lunabot>  luna: Stage error: `x' is bound at stage 2 but used at stage 1
19:46:21 <mmorrow> ,  ppDoc <$> (\x -> [|\y -> ($x,y)|]) [|()|]
19:46:23 <lunabot>  \y_0 -> ((), y_0)
19:46:42 <mmorrow> thought that that might work for a second (distinguish which `x' by the context..
19:47:09 <mmorrow> ,  ppDoc <$> (\x -> [|\x -> ($(lift =<< x),x)|]) [|()|]
19:47:10 <lunabot>  luna: Stage error: `x' is bound at stage 2 but used at stage 1
19:47:16 <mmorrow> ,  ppDoc <$> (\x -> [|\y -> ($(lift =<< x),y)|]) [|()|]
19:47:18 <lunabot>  \y_0 -> (ConE (Name (packString "()") (NameG DataName (packString "ghc-pr...
19:47:18 <lunabot>           y_0)
19:47:22 <kmc> iaefai & anyone else interested: my TH hack for building records from Map is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11944#a11944
19:47:42 <mmorrow> kmc: sweet
19:47:53 <kmc> this is my first TH code so i'm sure it could be nicer
19:47:58 <kmc> any suggestions are of course welcome
19:48:46 <nolrai_FG> Is it silly to use RWS if none of your computations ever have a return other than ()?
19:50:04 <nolrai_FG> I mean probobly not, but it feels like a monad is overkill.
19:50:34 <mmorrow> without a monad, a function returning () is pretty boring
19:50:49 <BMeph> "ANything worth killing, is worth overkilling." ;)
19:50:58 <mmorrow> BMeph: yeeehaww!
19:51:03 <nolrai_FG> well yeah, but I could just return my log.
19:51:17 <BMeph> mmorrow: :)
19:53:20 <nolrai_FG> Instead of "RWS r w s ()" do "r -> State s w" (especialy cause I only use r once.)
19:54:34 <nolrai_FG> No I guess it makes sense.
19:56:42 <luite> Cale: the pdf version of your matrices post does not work
19:59:25 <Cale> luite: oh, hmm, I'll be sure to tell Robin that
19:59:47 <Axman6> preflex: seen ChilliX
19:59:47 <preflex>  ChilliX was last seen on #ghc 1 day, 21 hours, 28 minutes and 42 seconds ago, saying: copumpkin: :P
19:59:51 <Cale> oh, maybe I can fix it
20:00:56 <luite> the others seem to work fine
20:01:14 <Cale> yeah, I'm just checking the directory to see if the file is there
20:01:50 <Cale> my internet connection is also being really crap atm
20:02:32 <luite> maybe it's an idea to let the user download pdf's for a whole month too? I'd find it useful to copy them to my ebook reader
20:02:53 <Cale> Fixed :)
20:03:04 <Cale> Yeah, that's a good idea
20:03:28 <Cale> We'll be building up the material in an order which is somewhat arbitrary
20:04:07 <jmcarthur> we need a Forest monad so that I can write the runForest function
20:04:17 <Cale> We both have a bunch of stuff planned which fits into a coherent picture (or two coherent pictures anyhow), but the order is going to be however we get around to it :)
20:05:42 <Cale> jmcarthur: forests are a monad
20:06:03 <Cale> but I'm not sure what runForest would do
20:06:04 <jmcarthur> indeed
20:06:16 <jmcarthur> :(
20:06:31 <FunctorSalad> lol
20:06:55 <FunctorSalad> newtype Forest a = Forest { runForest :: [Tree a] } ?
20:07:20 <FunctorSalad> data Trivial = Trivial { runTrivial :: () }
20:07:26 <jmcarthur> i have to give my wife credit for this one
20:07:36 <jmcarthur> because she is demanding that i do so
20:07:44 <FunctorSalad> you wife is into haskell nomenclature jokes? :O
20:07:49 <FunctorSalad> lucky one
20:08:04 <jmcarthur> heh
20:10:27 <luite> Cale: does it show anywhere which posts are made by whom?
20:10:28 <FunctorSalad> *your
20:10:59 <__void__> Cale: do you mind telling me what project are you talking about?
20:11:15 <Cale> luite: I would like it to, but I have no experience with blog software
20:11:22 <Cale> http://analogical-engine.com/wordpress/
20:11:51 <Cale> luite: The blog knows who made each post, but I'm not sure how to get it to display that
20:12:01 <luite> Cale: hmm, I think it must be some setting for the theme you are using
20:12:49 <luite> I've been planning to start a blog for a while (still not started yet, though), and the theme I chose displayed it by default
20:13:10 <nolrai_FG> Cale wouldnt run forest be about choices?
20:13:24 <Cale> nolrai_FG: I guess it could flatten the forest into a list
20:13:41 <nolrai_FG> Cale, no it takes a flatening.
20:13:55 <FunctorSalad> the runX functions are usually the record names of newtypes
20:14:10 <FunctorSalad> newtype Reader e a = { runReader :: e -> a }
20:14:44 <nolrai_FG> so you can write code that programaticly decides between shallow and deep searches. not super useful but..
20:14:47 <nolrai_FG> maybe?
20:14:56 <Cale> FunctorSalad: yeah, but if Reader's representation were different, the run function would be less trivial :)
20:15:14 <__void__1> anyone doing web programming in haskell?
20:15:56 <nolrai_FG> none of the runs do anything do they?
20:16:11 <Cale> In the mtl they don't.
20:16:30 <Cale> Because all the mtl monads have a nice trivial representation in terms of their run functions :)
20:17:22 <FunctorSalad> but forest would fit in too as I wrote... currently, type Forest  a = [Tree a]
20:17:38 <FunctorSalad> you could newtype it and call it runForest :)
20:17:52 <monochrom> "run, Forrest, run"?
20:19:39 <Cale> heh, yeah, it needs to take a function parameter so you can write   runForest run
20:21:25 <nolrai_FG> A forest where the branches have values not just the leaves would be more useful. Not sure if its a monad though.
20:21:43 <Axman6> __void__1: there are a few web programming frameworks, but i don't think any of them are all that active (the main one being happstack)
20:22:09 <__void__1> Axman6: i was looking into hack protocol
20:22:19 <Axman6> i haven't checked out hack
20:23:05 <FunctorSalad> nolrai_FG: don't the nodes have values in Data.Tree?
20:23:09 <Axman6> i think what a lot of the web frameworks lack is nice examples
20:23:09 <FunctorSalad> @src Tree
20:23:09 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:23:13 <FunctorSalad> @src Data.Tree
20:23:13 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:23:15 <FunctorSalad> @src Data.Tree.Tree
20:23:15 <lambdabot> Source not found. :(
20:23:23 <Axman6> ranging from basic, to complex
20:23:48 <__void__1> Axman6: hack has many, in hack-contrib, and bamboo blog and loli dsl
20:23:58 <Axman6> sounds good
20:24:03 <nolrai_FG> FunctorSalad: I didnt think they did.
20:24:16 <Axman6> __void__1: how is it as a framework? do you like it?
20:24:37 <__void__1> Axman6: is more a doit-yourself-framework, is a implementation of the rack specification from ruby (based on wsgi from python)
20:25:03 <Axman6> fair enough
20:25:15 <__void__1> it defines a simple protocol to communicate with a webserver and provides helper functions
20:25:23 <nolrai_FG> FunctorSalad: dont remeber..
20:27:20 <medfly> @src Data.Tree.tree
20:27:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:29:45 <nolrai_FG> hmm yeah each node has a value. Doesnt have a sepreat value for leaves. not sure what that represents monad wise.
20:30:16 <FunctorSalad> leaves are nodes with empty subforest no?
20:30:21 <FunctorSalad> return x = Node x []
20:30:32 <__void__1> Axman6: what i couldn't find in hack is the "uniqueness" of the haskell implementation
20:30:50 <FunctorSalad> for Forest it would be return x = Forest (return x) -- if Forest was a newtype
20:30:54 <Axman6> there may not be any
20:30:56 <FunctorSalad> err
20:31:03 <FunctorSalad> return x = Forest [return x]
20:31:15 <__void__1> basically it mimics the ruby package, that's meant to use with and oo language
20:32:05 <__void__1> but the spec implementation in haskell looks very nice with the addition of types
20:32:52 <nolrai_FG> FuctorSalad: return a = Node a []?
20:33:19 <nolrai_FG> or rather: return a = [Node a []]
20:34:25 <FunctorSalad> nolrai_FG: hmm seems like both would satisfy the laws
20:34:53 <copumpkin> why is there no replicateA in Control.Applicative?
20:35:04 <FunctorSalad> (nevermind my last statement, it's nonsense)
20:35:08 <copumpkin> or sequenceA
20:35:19 <FunctorSalad> copumpkin: latter is in Traversable
20:35:35 <copumpkin> yeah, but why not just a simple version on Control.Applicative to mirror Monad?
20:35:46 <copumpkin> *in
20:36:04 <FunctorSalad> hmm because it would break stuff to add it now? ;)
20:37:04 <Tordek> ok, cabal is driving me to madness
20:37:46 <Tordek> I did "cabal install xmonad". stuff went wrong, so I took the usual linux approach of "rm ~/.cabal -rf" and re-do. now, cabal says xmonad is installed, when it's not
20:39:06 <Axman6> Tordek: does ghc-pkg list say it's instslled?
20:39:36 <Tordek> Axman6: yes
20:39:51 <Axman6> well, then it's installed. try cabal install --reinstall Xmonad
20:40:19 <Tordek> XMonad.hs:44:7: Could not find module `Graphics.X11.Xlib.Extras':
20:41:04 <Axman6> cabal upgrade X11?
20:41:37 <Tordek> "it's installed"
20:41:54 <Axman6> how odd
20:42:34 <Tordek> --reinstall X11 seems to have done the trick
20:42:41 <Axman6> Tordek: can you load Graphics.X11.Xlib.Extras in ghci?
20:42:44 <Axman6> ok, good
20:44:01 <Tordek> thanks ^^
20:45:21 <nolrai_FG> Whats the synonm for binary (-)?
20:45:46 <nolrai_FG> Or do you just have to do (\x->x-1)?
20:45:53 <FunctorSalad> subtract 1
20:49:00 <dcolish> is there a way make something like:  (f) ++ (g) $ arg, where f & g a -> String ?
20:49:25 <__void__> what are the "core" or "common" haskell libraries to use when programming? as i dig deeper into haskell programs i find more and more libraries being used, where most of them provide shortcuts to do common things
20:50:36 <Axman6> __void__: Data.List is pretty common, also Control.Applicative is somewhat
20:50:41 <Cale> __void__: Data.List, Control.Monad/Applicative
20:50:53 <Cale> __void__: Data.Set and Data.Map are really useful
20:50:59 <FunctorSalad> __void__: http://www.haskell.org/ghc/docs/latest/html/libraries/
20:51:05 <Cale> (basic set and map datastructures)
20:51:07 <FunctorSalad> (that's the base package)
20:51:25 <FunctorSalad> oh wait, it's more than base
20:51:42 <__void__> FunctorSalad: that's the whole library :)
20:51:57 <dcolish> heh
20:52:09 <FunctorSalad> Cale mentioned some good ones
20:52:52 <__void__> i suppose that data.bytestring is common also no?
20:53:06 <Axman6> yep
20:53:12 <FunctorSalad> the System.* are important for IO of course
20:53:29 <FunctorSalad> the mtl is important too
20:53:40 <Axman6> one of my favourite packages is the Data.Binary one. very hand for serialising your types into bytestrings
20:57:20 <Gracenotes> are there any good algorithms for checking if a structure is a tree, as opposed to a DAG with undirected cycles?
20:57:48 <Gracenotes> assuming each node has a unique identifier (I can do == on them)
20:58:00 <Cale> Better if they're ordered
20:58:11 <Gracenotes> maybe doing a recursive search, keeping a set of visited nodes
20:58:14 <Cale> Because then you can build up a Data.Set of them as you go
20:59:45 <Gracenotes> the only problem is that it is stored as a graph, not a tree. so I don't exactly know where the root is...
21:00:53 <Gracenotes> there might even be more than one root
21:00:57 <Gracenotes> :/
21:03:14 <Cale> Gracenotes: but if it's a tree, then you'll reach every node from any other
21:05:21 <Gracenotes> Cale: hm. perhaps I should rephrase the problem. I have a directed graph. I need to determine if it is a directed rooted tree, i.e., there is a unique root u and, for every other node v in the graph, there is a unique path from u to v
21:05:42 <Cale> Gracenotes: right
21:05:52 <Cale> Gracenotes: so pick any node
21:05:55 <Gracenotes> maybe I should try backtracking to the root from a given node
21:06:01 <Cale> oh
21:06:04 <Cale> right, yeah
21:06:09 <Cale> It's already directed
21:06:43 <Gracenotes> actually, to make it even simpler: there should be only one way to backtrack from a given node
21:07:07 <Cale> But you do need to make sure to keep track of where you've been anyway
21:07:13 <Cale> Since you might be in a cycle
21:07:22 <Cale> If you end up somewhere that you've been, it's not a tree
21:10:22 <Gracenotes> would this work? having 1. a single node with no predecessors and 2. every other node with exactly one predecessor
21:13:00 <Gracenotes> if the whole thing is one big cycle, every node would have a predecessor. If a predecessor-less node hooks into the cycle somehow, that would require the node it hooks into to have two predecessors... and if there is some DAG joining/splitting, two predecessors would be involved there anyway
21:13:13 <Cale> not *quite*
21:13:25 <Cale> you could have a cycle plus a disconnected node that way
21:13:29 <mmorrow> kindof a handy list http://en.wikipedia.org/wiki/List_of_compilers
21:13:40 <Gracenotes> my imagination is probably limiting the cases this wouldn't work
21:13:41 <mmorrow> :o no Haskell!
21:13:58 <Gracenotes> Cale: the graph should be connected
21:14:45 <SamB_XP> Gracenotes: has that ever stopped it before ?
21:15:05 <Gracenotes> stop?
21:15:27 <SamB_XP> from being disconnected ;-P
21:15:35 <Cale> Gracenotes: yeah, connected + every vertex has a unique predecessor except for one vertex with 0 => tree
21:18:12 <Gracenotes> hm.. actually, the condition that's ensured by this algorithm is that there's no cycle, not that it's disconnected. sigh.
21:18:21 <drhodes> during a breadth first traversal of that tree, all the currently visted node have the same depth - is this sufficient?
21:18:43 <drhodes> crap, no that's not going to work.
21:19:19 <Gracenotes> connectivity-checking will probably require an extra O(|V|)-size data structure, somehow
21:20:43 <Woof> Twey! >: O
21:31:12 <mmorrow> ok, it began to get tedious, if anyone wants to add anything http://en.wikipedia.org/wiki/List_of_compilers#Haskell_compilers
21:31:49 <mmorrow> wasn't sure who to attribute GHC to (didn't want to omit anyone, so just gave no one)
21:32:28 <SamB_XP> mmorrow: just attribute it to Team GHC, as lead by the Simons
21:32:33 <Lemmih> mmorrow: It might be nice to note which compilers are still maintained.
21:34:03 <mmorrow> Lemmih: yeah, good point
21:34:16 * mmorrow adds a new column
21:34:42 <Woof> Twey! >: O
21:35:05 <SamB_XP> mmorrow: what, "last release date"?
21:35:28 <mmorrow> hmm, is nhc "actively maintained"?
21:35:35 <Lemmih> mmorrow: No.
21:35:41 <mmorrow> SamB_XP: just "Actively maintained?"
21:36:20 <SamB_XP> well, all you have to do is look at SPJ to know that it is *extremely* actively maintained ;-P
21:36:24 <SamB_XP> er. GHC
21:36:27 <SamB_XP> is the it
21:36:30 <SamB_XP> sorry ;-P
21:36:31 <mmorrow> yhc otoh i'd call somewhat actively maintained (??)
21:37:05 <SamB_XP> mmorrow: I think it was recently somewhat actively maintained, but I thought I'd read somewhere that it was on hiatus
21:37:17 <copumpkin> what about LHC??
21:37:23 <SamB_XP> looking for a new colorist or something
21:37:23 <mmorrow> (although the darcs yhc fails to build on my x86_64 linux box due to not being able to find a module since it's looking in the wrong place, and it's been in this state for months)
21:37:29 <Lemmih> mmorrow: Neil told me yhc was dead.
21:37:45 <mmorrow> Lemmih: as i somewhat suspected :(
21:37:51 <SubStack> which is a shame
21:38:01 <SubStack> bytecode would be neat
21:38:05 <mjonsson> i'm wondering... is it possible to write (imperative) haskell code that does not generate any garbage at all?
21:38:20 <mjonsson> or at a very low rate
21:38:30 <SamB_XP> mjonsson: only if you don't give it garbage as input ;-P
21:38:53 <copumpkin> lol
21:39:27 <mmorrow> copumpkin, Lemmih: i didn't add LHC since it's less a "haskell" compiler, and more of an optimizing lazy-functional language compiler/backend. do you think i should add it?
21:40:24 <kmc> "Other OSs"
21:40:58 <mmorrow> yeah, like Nintendo!
21:41:05 <kmc> does that mean "runs on", or "targets"?
21:41:07 <mjonsson> I mean is it possible to program in such a way to avoid garbage collection pauses altogether?
21:41:29 <Lemmih> mmorrow: That it uses ghc for parsing and typechecking doesn't make it any less of a Haskell compiler, imo. I'd keep LHC off the list for other reasons.
21:41:47 <kmc> what about UHC
21:42:36 <copumpkin> mjonsson: not with GHC for now
21:42:42 <Lemmih> That almost all compilers implement their own (buggy) parsers and typecheckers is just silly.
21:42:43 <mmorrow> Lemmih: sure, i just picture a "haskell" compiler := maps (haskell98 -> some-"core-like" language with no typeclasses and all types explicitly annotated)
21:42:47 <copumpkin> mjonsson: unless you want to work exclusively with unboxed values
21:43:00 <copumpkin> mjonsson: which is possible, but you basically lose most of the benefits of haskell
21:43:14 <mmorrow> Lemmih: once it's at that point, it's less haskell and more i dunno
21:43:21 <EvanCarroll> is there a way to make a function likst fst, but that works with all length tuples?
21:43:28 <kmc> EvanCarroll, no
21:43:33 <EvanCarroll> why is that?
21:43:39 <kmc> what would its type be?
21:43:50 <EvanCarroll> whatever the type of the first element is/
21:43:50 <copumpkin> mmorrow: it does map haskell98 to all that, it just happens to share its frontend with GHC :P
21:43:54 <kmc> not (a,b) -> a, not (a,b,c) -> a, not (a,b,c,d) -> a
21:43:57 <copumpkin> it is possible
21:43:58 <kmc> EvanCarroll, i mean the type of the function itself
21:44:03 <copumpkin> @hackage tuple
21:44:04 <kmc> you can do it with typeclasses, sort of
21:44:04 <lambdabot> http://hackage.haskell.org/package/tuple
21:44:07 <copumpkin> but it's not generic
21:44:22 <mmorrow> copumpkin: ghc is haskell pre-processor
21:44:30 <EvanCarroll> kmc: I don't know enough about the language to answer that =(
21:44:33 <mjonsson> copumpkin: working with exclusively unboxed values would be a requirement in any language so that's okay
21:44:34 <copumpkin> EvanCarroll: the basic answer is that tuples of different sizes have nothing in common beyond syntax
21:45:01 <copumpkin> EvanCarroll: so there's no unified way of working with them, most of the time
21:45:30 <EvanCarroll> oh
21:46:06 <kmc> Data.Tuple uses the trick of putting each operation in a typeclass, and declaring instances for all the appropriate tuple types up to 15 or so
21:46:21 <kmc> but you still have to write out all that code because the types are unrelated
21:46:47 <kmc> another solution is to use Template Haskell to generate the code for working with your tuple
21:46:56 <mmorrow> i feel like i should note jhc's lack of gc, but whatever
21:47:03 <kmc> if you know the size at compile time, you can write a metafunction that writes the function for that size
21:47:17 <kmc> and if you don't know the size at compile time, you're not using tuples
21:47:31 <kmc> or at least shouldn't be
21:49:05 <copumpkin> you don't have to fully know the size though
21:49:21 <copumpkin> you might just know that two things are the same size
21:50:34 <kmc> if you're working with Data.Tuple-style typeclasses
21:50:34 <mmorrow> Lemmih: what i'm really trying to say is that a backend that starts at core could in principle compile multiple different lazy functional language to whatever, so it's more that a backend that happens to have a haskell frontend is more than just a haskell compiler
21:50:51 <mmorrow> but it's more non-empty intersection than strictly "more"
21:51:35 <kmc> EvanCarroll, tuples are designed as a shorthand for simple cases, instead of declaring your own algebraic types.  if you're trying to do anything complicated with them, it's usually worth defining your own type instead
21:51:38 <kmc> same goes for Either
21:52:15 <kmc> (why are there standard products up to 60+ but sums only to 2?)
21:54:06 <Cale> kmc: Practically speaking we could almost live with just pairs. Personally, I'd take triples too, but higher tuples are unnecessary.
21:54:08 <SamB_XP> kmc: it's what the customers wanted!
21:55:13 <Cale> But I've never wanted an anonymous either-like thing with lots of cases.
21:55:22 <Cale> I'd always name them.
21:55:26 <kmc> perhaps we should do away with fixed sum/product types, and make functions like zip and uncurry be generic
21:55:46 <jmcarthur> i often wish for anonymous either-like things
21:56:18 <jmcarthur> well, not really in the same sense as our tuples
21:56:19 <Cale> Well, if you could go all the way
21:56:41 <kmc> actually, let's get rid of Bool too
21:56:41 <Cale> An arbitrarily extensible variant system to go along with an extensible record system would be nice
21:56:49 <Cale> and a case syntax for matching on it
21:56:51 <Cale> kmc: ?
21:56:54 <jmcarthur> but if our tuples were just associative pairs then i would want a sum type to match
21:56:58 <Cale> Bool seems useful
21:57:11 <kmc> at work there is a C++ class whose ctor has 17 (?) boolean arguments, all with default values, some true, some false
21:57:13 <jmcarthur> i have no idea how that would work, now that i think about it
21:57:21 <copumpkin> we just need ⊤ and ⊥, and we should do away with non-termination too
21:57:41 <Cale> kmc: Yeah, but that's C++ :)
21:57:53 <SamB_XP> copumpkin: so we really just need ⊤ ?
21:57:55 <Cale> kmc: Those guys don't know how to design APIs and they end up with problems :)
21:58:04 <copumpkin> SamB_XP: well, we need false too
21:58:12 <copumpkin> SamB_XP: it's just the empty type
21:58:37 <Cale> ⊤ is the new ()
21:59:05 <kmc> |- x : ⊤  ?
21:59:22 <medfly> T
21:59:25 <medfly> :)
22:00:16 <kmc> Cale, it's true.  there are no keyword arguments, but you can at least use your own enum values instead of true/false
22:00:39 * mmorrow can't wait for the llvm people's response to the just-finished ghc llvm undergrad thesis experiment
22:00:49 <Cale> kmc: Yeah, or construct a record type containing Bools and use that as a parameter
22:00:55 * mmorrow unfortunately google isn't turning up any drama yet
22:01:03 <Cale> (In Haskell)
22:01:04 <mmorrow> err, dunno why i did /me
22:01:06 <kmc> mmorrow, why should the response be dramatic?
22:01:06 <copumpkin> mmorrow: why would there be drama?
22:02:32 <mmorrow> copumpkin, kmc: because most every thread or discussion that that i've seen that seems to be either critical or in competition with llvm gets a barrage of responses from the llvm people
22:02:42 <MachinShin> Error: Target org.macports.fetch returned: ghc is not yet supported on Mac OS X 10.6.x (SnowLeopard)  <-- :( anyone know eta?
22:02:42 <MachinShin>   
22:02:43 <copumpkin> oh
22:02:45 <mmorrow> take lemmih's experience for example
22:02:55 <copumpkin> MachinShin: you should email the macports ghc maintainer
22:02:57 <copumpkin> not sure who it is
22:03:07 <kmc> aha so said thesis was not charitable towards LLVM?
22:03:53 <mmorrow> also, there was this one thread somewhere where this guy was starting a new project that did something vaguely similar to llvm, and the llvm dood gets on there (i think it was this other project's mailing list no less) and starts telling this guy he should rather not start his own project and just write an llvm client
22:03:54 <copumpkin> edwardk said that he spoke to some llvm devs recently and managed to convince them it was worthwhile to make it more FP-friendly
22:04:19 <mmorrow> and finally, anything that's written in C++ must be eradicated from existence :)
22:04:36 <mmorrow> now that i've made probably 20 new enemies, i'll get back to googling :)
22:05:11 <copumpkin> lol
22:05:22 * kmc thinks C++, though flawed, is the best language in a particular narrow niche
22:05:35 * copumpkin gets back to running the CPU in his head at 100% trying to prove trivial things
22:05:37 <SamB_XP> mmorrow: enemies ... no, you've merely solicited 20 LLVM rants in your inbox ;-P
22:05:40 <mmorrow> perhaps, but compilers are not it
22:05:50 <mmorrow> SamB_XP: haha, i wouldn't be surprised!
22:06:01 <kmc> also i think that being a good C++ programmer requires as much intelligence as being a good haskell programmer, but all of that intelligence is wasted in just keeping your head above the bullshit
22:06:19 <copumpkin> template error messages in particular... :(
22:06:46 <SamB_XP> kmc: and then there's the smell!
22:06:54 <SamB_XP> the ... stink
22:07:14 * SamB_XP attempts to channel Agent Smith
22:07:25 <MachinShin> copumpkin: any way to find out who that is?
22:07:38 <kmc> in matrix, Agent Smith channels you
22:07:50 <SamB_XP> kmc: only in Soviet matrix
22:08:22 <copumpkin> MachinShin: maybe port info ghc ?
22:08:35 <MachinShin> copumpkin: will try, thanks
22:08:53 * hackagebot upload: bacteria 1.1 - braindead utility to compose Xinerama backgrounds (DanielWagner)
22:09:10 <mmorrow> copumpkin: oh hehe, and i left out why i'm expected at least a rant or two, in the conclusion of his paper, the guy states:
22:09:21 <mmorrow> (one sec, have to open the pdf, dunno where it is)
22:09:21 <Cale> Being a good Agda programmer requires as much intelligence as being a good Haskell programmer, but all that intelligence is wasted proving that Bool has finitely many elements ;)
22:09:30 <copumpkin> lol
22:09:35 <kmc> if you call that a waste
22:09:43 <copumpkin> it's very profound!
22:09:57 <Cale> Actually, it is, sort of
22:10:02 <MachinShin> hrmm.. looks like the problem is related to ports, you can install haskell manually
22:10:09 <baddog> ;w 19
22:10:12 <baddog> er. failme
22:10:13 <Cale> There are fewer than infinitely many truth values.
22:10:17 <copumpkin> right now I'm trying to prove that if you have a finite type `a`, then Vec `a` n is finite, and if you have an infinite type `a`, Vec `a` n is infinite
22:10:24 <copumpkin> MachinShin: yeah, definitely
22:10:42 <SamB_XP> Cale: well, it's not hard
22:10:53 <Cale> SamB_XP: I know, I'm just poking fun :)
22:11:02 * copumpkin weeps
22:11:05 <mmorrow> "Given the LLVM optimiser is one of LLVM’s most publicised features, its current complete uselessness is surprising."
22:11:07 <SamB_XP> all you need is a list of all Bools and a proof that, given a Bool, you can find it in the list
22:11:07 <copumpkin> granted, that one didn't take me more than 5 minutes
22:11:09 <mmorrow> aha
22:11:21 <copumpkin> proving that Naturals were infinite took me several hours though
22:11:27 <Cale> mmorrow: Yeah, I loved that quote
22:11:34 <mmorrow> Cale: hehe
22:12:06 <Cale> I kind of wonder which version of the NCG he was using...
22:12:12 <SamB_XP> mmorrow: hmm, I think that may be a slight overstatement ;-P
22:12:20 <mmorrow> that took a certain amount of nerve to state outright an directly in his conclusion too, i give him credit for that.
22:12:30 <Cale> Also, I wonder if the GHC guys have any plan to genericise their new work and make it usable for other compilers.
22:12:33 <copumpkin> lol
22:12:35 <SamB_XP> I think it's somewhat useful, at least sometimes
22:12:56 <copumpkin> I'm not sure that's the most productive way to word things if you don't want to get written off as an asshole
22:13:01 <Cale> SamB_XP: It's useless for the LLVM backend in GHC
22:13:11 <kmc> Cale, which work? Hoopl?
22:13:35 <mmorrow> SamB_XP: from my limited understanding of what exactly he's done here so far, he was targeting x86 only, unregisterized, and without tables-next-to-code
22:14:01 <mmorrow> SamB_XP: and llvm apparently is leaving a bunch of extraneous stack manipulation in the code
22:14:02 <Cale> kmc: I'm not sure specifically -- I've just heard that they've been doing lots of backend stuff recently.
22:14:20 <mmorrow> (i don't even think he's using the hardware stack either, but i'm not clear)
22:14:27 <Cale> kmc: ah, I suppose hoopl is fairly generic isn't it?
22:14:33 <kmc> Hoopl is a general framework for writing analysis and transformation based on dataflow
22:14:56 <kmc> from the paper it looks really nice, and is fully parametrized on the code datatype
22:16:05 <mmorrow> SamB_XP: and since GHC's generated code has essentially zero static loops present, pretty much all of LLVM's optims probably don't have much to work with
22:16:17 <copumpkin> now we just need a summer of code project to soup up his work so that we can generate code for any target llvm supports, make it fully optimized/registered, and incorporate llvm bytecode/JIT in ghci
22:17:11 <mmorrow> SamB_XP: ooh, *and* apparently LLVM has an inefficient implem of "indirect goto" (ie jmp *(%rbp)), since "not many compilers do this very often"
22:17:24 <mmorrow> but ghc does it every 10 lines of asm..
22:17:31 <mmorrow> i'm not sure if this plays a part
22:17:32 <copumpkin> lol
22:19:03 <mmorrow> SamB_XP, copumpkin: http://nondot.org/sabre/LLVMNotes/IndirectGoto.txt
22:19:49 <mmorrow> somehow it doesn't just use a single jmp, but i'm not clear on what else it could be doing yet
22:21:08 <copumpkin> most importantly, does llvm generate the bsr instruction? :P
22:21:12 <copumpkin> for IntMap
22:22:25 <kmc> isn't indirect jump also important for virtual functions in C++ or any other language with OO-style polymorphism?
22:22:34 <kmc> or would that be a separate indirect call instruction?
22:23:14 <iaefai> kmc, I was away and my irc client indicated somebody said my name. Was it you?
22:23:19 <kmc> yeah
22:23:29 <kmc> i wrote the TH thing: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11944#a11944
22:23:38 <kmc> it's my first TH program so it's probably not very good
22:23:48 <kmc> and it's questionable when it would be useful, but i had fun writing it :)
22:31:08 <mtnviewmark> I'm confused by a "Ambiguous type variable" error
22:31:08 <lambdabot> mtnviewmark: You have 1 new message. '/msg lambdabot @messages' to read it.
22:31:41 <copumpkin> mtnviewmark: what is it?
22:32:04 <mtnviewmark> I have a type class, Segment
22:32:12 <mtnviewmark> and there are two instances of it, Int and String
22:32:29 <mtnviewmark> there is one function toSeg :: a -> String
22:32:43 <mtnviewmark> toSegment "abc"
22:32:43 <mmorrow> kmc: yeah, i'd have thought so too for vtables and whatnot
22:32:44 <mtnviewmark> works
22:32:51 <mtnviewmark> toSegment 3
22:32:54 <mtnviewmark> fails
22:32:58 <mtnviewmark> toSegment (3::Int)
22:33:00 <mtnviewmark> works
22:33:03 <iaefai> I will keep this in tow, I don't know if I can use it right now, but my next project I will try to use it
22:33:26 <mmorrow> copumpkin: bsr!!@
22:33:27 <mtnviewmark> seems to me that there is only one type satisfying (Segment a, Num a)
22:33:49 <copumpkin> mtnviewmark: it doesn't know that you won't go define another one in another module
22:34:11 <copumpkin> mtnviewmark: if ghc did whole-program compilation, yes, but it does it module-per-module and typeclasses are open
22:34:40 <mtnviewmark> so it won't take the "known set" at that moment in the compilation and use that, huh?
22:34:41 <mtnviewmark> okay
22:34:43 <mtnviewmark> ....
22:34:55 <copumpkin> it can't assume that
22:35:10 <mtnviewmark> Kinda makes it hard to make numbers instances
22:35:14 <copumpkin> it's compiling a module that it won't look inside later, so it must stay general
22:35:22 <copumpkin> why?
22:35:36 <mmorrow> kmc: hmm, maybe it does those with an indirect call, and somehow treats that case differently
22:35:52 <mtnviewmark> I can't use numeric constants with such a class, without explicitly writing the type
22:36:17 <jmcarthur> right
22:36:32 <mtnviewmark> (In this case I'm defining a operatior (./) that builds up a path (think URLs) from such segments
22:36:39 <jmcarthur> a type class constraint still keeps the variable polymorphic
22:36:40 <mtnviewmark> I want the user of the module to be able to write
22:36:53 <mtnviewmark> "abc" ./ 3 ./  "def"
22:37:13 <mtnviewmark> you mean like :   instance (Num a) => Segment a
22:37:14 <mtnviewmark> ?
22:37:22 <mtnviewmark> 'cause that won't compile
22:37:24 <copumpkin> hmm, I'm not sure how that will work
22:37:34 <copumpkin> what type does ./ have?
22:37:39 <jmcarthur> i wasn't really suggesting anything, just explaining how type classes work
22:38:05 <mtnviewmark> (./) :: SPath -> SPath -> SPath
22:38:19 <copumpkin> mtnviewmark: "abc" isn't SPath
22:38:22 <mtnviewmark> and in Segment, there is a toPath :: a -> SPath
22:38:27 <copumpkin> oh
22:38:36 <copumpkin> oh, so SPath is existential?
22:38:43 <mtnviewmark> (the toSegment operation was just simplifying the question)
22:38:48 <jmcarthur> make SPath an instance of Num and FromString (i think?), with the proper string literals extension and you're set, there
22:38:54 <mtnviewmark> I'm not sure what that means   ;-O
22:39:04 <allbery_b> IsString
22:39:04 <jmcarthur> dunno the name of the extension
22:39:09 <copumpkin> oh, SPath is just a sum I guess
22:39:11 <jmcarthur> IsString is the type class, yeah
22:40:10 <allbery_b> and OverloadedStrings
22:40:13 <mtnviewmark> I suppose...... in which case (./) = (+) !!!
22:40:14 <jmcarthur> yes, thank you
22:40:25 <allbery_b> monoid?
22:40:28 <mtnviewmark> but it seems like sort of cheating .. especially since most of Num doesn't apply
22:40:41 <jmcarthur> Num is a very unfortunately type class
22:40:47 <jmcarthur> *unfortunate
22:40:49 <mtnviewmark> well, it could be a monoid, but I don't think that will solve the numeric literal issue
22:41:14 <jmcarthur> it is not uncommon to define some Num functions using error, sometimes...
22:41:28 <jmcarthur> although it's admittedly very ugly
22:42:02 <jmcarthur> the alternative is to have a somewhat different API than the ideal
22:42:26 <kmc> "abc" ./ 3 ./  "def"  is not very haskelly
22:42:29 <kmc> what's the use case?
22:43:08 <mtnviewmark> well....... there is an external format, called LLSD --- think JSON beefed up with a few more data types and more rigorous type conversion semantics
22:43:25 <mtnviewmark> but basically, and tree of maps and arrays and some other simple types
22:43:49 <mtnviewmark> web services get these things and need to extract bits: "part" ./ 34 ./ "size"
22:43:55 <mtnviewmark> for example
22:44:14 <kmc> so the keys at any point in the hierarchy could be either strings or numbers?
22:44:24 <mtnviewmark> right
22:44:32 <jmcarthur> SString "part" ./ SInt 34 ./ SString "size"   ?
22:44:40 <jmcarthur> ugly, sure
22:44:41 <mtnviewmark> and since this data blob comes over the wire, it could really be any structure
22:44:44 <kmc> is the "shape" of the hierarchy known statically?
22:44:47 <kmc> ah bollocks
22:45:26 <mtnviewmark> not only that, empty keys may be just outright missing, or come over with the wrong type
22:45:27 <kmc> it doesn't solve this problem, but i'd use a plain list for a path, instead of making your own (:)-like operator
22:45:31 <mtnviewmark> and things have to "auto convert"
22:45:43 <jmcarthur> ew
22:45:45 <mtnviewmark> (come to think of it, LLSD is sort of the anit-Haskell!)
22:45:59 <jmcarthur> starting to sound like a tag soup like thing
22:46:02 <kmc> funny because D-LSD reminds a lot of people of Haskell
22:46:07 <mtnviewmark> well, it is used for very decoupled systems where there might be a lot of design flux on either end
22:46:11 <kmc> another option is to have the API user specify the shape they expect
22:46:29 <allbery_b> given the way Haskell works, especially the automatic conversion of integer literals to fromInteger calls, I think this is guaranteed to suck one way or another
22:46:29 <mtnviewmark> oh, there is an IDL for that: LLIDL
22:46:42 <kmc> is "flux" the plural of "flaw"?
22:46:44 <mtnviewmark> but, none the less, you have to deal with version skew
22:47:01 <mtnviewmark> no, it is the reality of when you have 40,000 machines out there exchanging data
22:47:09 <mtnviewmark> and you really can't just update them "all at once"
22:47:12 <m3ga> i have a big hairy piece of haskell code that that is unexpectedly dying when i do 'length someList'. any clues on how to debug this?
22:47:19 <kmc> m3ga, dying how?
22:47:25 <mtnviewmark> it takes a week to update the running gird!
22:47:28 <allbery_b> flux is the plural of f***-up :)
22:47:40 <m3ga> kmc: program terminates with no explaination
22:48:12 <m3ga> its not a space leak because it happens pretty fast and doesn't chew up all  my ram
22:48:53 <kmc> are you building with GHC; if so, what version?
22:48:55 <jmcarthur> no explanation meaning exit code 0 and no output?
22:49:16 <m3ga> ghc 6.10.4 from ubuntu
22:49:31 <m3ga> exit code is 1
22:49:37 <kmc> are you doing anything screwy, unsafe ops, etc?
22:49:42 <jmcarthur> what is someList?
22:50:17 <kfish> m3ga, have you tried the ghci debugger?
22:50:43 <kmc> did you try running it in strace?
22:52:23 <m3ga> kfish: i do not want to run the 50k lines of ddc under ghci :-) but strace is a very good idea (don't know why i didn't think of it).
22:52:40 <m3ga> only unsage ops are in the lexer, i'll investigate.
22:52:45 * kmc <3 strace
22:52:51 <kmc> especially strace -p, just learned that a few days ago
22:53:29 <kfish> m3ga, ah :)
22:58:01 <m3ga> kfish, kmc : removing unsafe op from alex generated lexer fixed it but then putting unsafe op  back in and it was still fixed. more investigation needed.
22:59:32 <kmc> eek
22:59:59 <m3ga> eek is right! doing a clean recompile now.
23:01:06 * hackagebot upload: bindings-common 1.3.3 - Preprocessor DSL for low level FFI. (MauricioAntunes)
23:07:48 <aeron> Is there any builtin to print out a real number with a specified precision, or do I have to do it with a string/list function?
23:08:54 <Cale> > showFFloat (Just 2) pi []
23:08:55 <lambdabot>   "3.14"
23:09:00 <dmwit> > printf "%2.3f" pi :: String
23:09:01 <lambdabot>   "3.142"
23:09:41 <Cale> (see also the rest of the Numeric library)
23:09:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v%3AshowEFloat
23:10:01 <aeron> Cale: Thanks very much :)
23:11:50 <aeron> a
23:17:39 * copumpkin 's mind = overheating :(
23:18:11 <Cale> Trying to prove that thing about vectors and finite/infinite types
23:18:12 <Cale> ?
23:18:16 <copumpkin> yep
23:18:26 <Cale> Okay, which part are you stuck on?
23:18:28 <copumpkin> getting closer but feeling slightly loss
23:18:29 <copumpkin> lost
23:18:47 <Cale> (not that I know agda :)
23:18:51 <copumpkin> yeah :)
23:20:05 <copumpkin> well, I'm trying to prove that if you have a vector X of vectors of A and a proof that for any vector, X contains it, and if you have an element of A, then that element is contained in concat X
23:20:06 <copumpkin> :P
23:20:15 <copumpkin> it's rather painful
23:21:02 <Cale> ah
23:21:21 <Cale> And you can't use contradiction?
23:21:35 <copumpkin> not really :/
23:21:52 <copumpkin> unless I can use oleg's universally quantified monad LEM thingy :P
23:21:56 <Cale> Yeah, not being able to use contradiction makes mathematics 10x harder
23:21:57 <copumpkin> which I still don't understand
23:22:32 <Cale> oh, actually, there's a straightforward way, isn't there?
23:22:40 <copumpkin> yeah :) so fun and addictive though
23:22:52 <copumpkin> well, my approach so far has been to
23:23:06 <copumpkin> take my element of A and replicate it enough times to become a vector in X
23:23:14 <Cale> Do you have a proof that if x contains y and y contains a, then concat x contains a?
23:23:25 <Woof> Twey! >: O
23:23:38 <copumpkin> Cale: oh, that'd be a good intermediate step
23:23:54 <copumpkin> I'll work on that :)
23:25:28 <copumpkin> ∈Vec : ∀ {m n a} {x : a} {xs : Vec a m} {xss : Vec (Vec a m) n} → x ∈ xs → xs ∈ xss → x ∈ concat xss
23:25:45 <copumpkin> writing down the type is half the work! :P
23:26:10 <copumpkin> I really enjoy how agda fakes polymorphism
23:26:25 <kmc> by implicit arguments?
23:26:29 <copumpkin> yeah
23:27:05 <kmc> yeah it is nice
23:30:35 <Cale> copumpkin: What counts as a witness of x \elem xs ?
23:31:19 <copumpkin> a data type that is either "here" or "there", with here carrying a proof that the head of the vector is the sought element, and there carrying a proof of \elem for the rest of the list
23:33:13 <Cale> So I guess the way you'll do it is effectively by reconcatenating xss while recursing over your proof of xs in xss, and then when you find the 'here', you use your proof of x in xs
23:33:30 <copumpkin> yeah, hm
23:34:55 <copumpkin> okay, my scaffolding is in place for that
23:36:41 <c_wraith> it's now safe to tear down the wall?
23:36:59 <copumpkin> not quite :)
23:37:09 <copumpkin> wow, time really flies when I'm doing this stuff
23:40:07 * ddarius has considered (again) doing some Agda or Coq programming.
23:40:32 <copumpkin> it's really addictive
23:43:04 <ddarius> copumpkin: I believe it was Pierce who likened that to the "video game effect."
23:43:22 <copumpkin> I can definitely see that
23:43:30 <copumpkin> it's a big puzzle that I can't put down
23:43:31 * Gracenotes captions a picture of Agda code with "invisible polymorphism"
23:47:52 <copumpkin> ddarius: do you know where I can find him saying that? couldn't find anything in google
23:49:33 <ddarius> copumpkin: I'm pretty sure he says it in this video from ICFP: http://www.vimeo.com/6615365
23:49:46 <copumpkin> thanks :)
23:55:55 <copumpkin> I think what I'm trying to prove is false
23:56:00 <copumpkin> ...on a corner case
23:58:10 <copumpkin> yeah it was :P
