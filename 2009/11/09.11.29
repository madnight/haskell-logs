00:32:03 <djahandarie> Ouch, someone needs to make chameneous-redux parallel on the programming language shootout.
00:32:09 <djahandarie> It's only using one core
00:33:54 <shambler> hehe
00:34:02 <shambler> only if I could...
00:47:38 <blackdog> @seen mmorrow
00:47:39 <lambdabot> Unknown command, try @list
00:48:02 <shambler> @botsnack
00:48:02 <lambdabot> :)
00:48:02 <lunabot>  :o
00:48:17 <shambler> lunabot, seen mmorow
00:48:24 <shambler> aww
00:48:26 <shachaf> preflex: seen mmorrow
00:48:26 <preflex>  mmorrow was last seen on #haskell 3 hours, 4 minutes and 20 seconds ago, saying: roconnor: you must not have drank enough then, duh
00:48:28 <qwr> @givemeacookie
00:48:28 <lambdabot> Unknown command, try @list
00:48:45 <blackdog> ah, that's the one. i always forget the prefix. thanks
00:49:10 <shachaf> blackdog: The pref*le*x.
00:50:15 * blackdog groans
00:53:02 <blackdog> preflex: tell mmorrow should haskell-src-meta be working with 6.12? I'm getting errors about TyVarBndr not being the same as Name, which is easily fixed by whacking PlainTV over them, but now i'm getting Types where i expect Preds...
00:53:03 <preflex>  Consider it noted.
00:57:57 <blackdog> preflex: tell, blah, i'm an idiot, you already showed me the repo. sorry.
00:58:05 <blackdog> preflex: tell mmorrow blah, i'm an idiot, you already showed me the repo. sorry.
00:58:05 <preflex>  Consider it noted.
01:03:41 <zsol> 'morning
01:04:02 <teolicy> Hi. Is there a downloadable version of Learn You A Haskell ready for offline browsing?
01:04:53 <Cale> BONUS: ^^
01:05:14 <Cale> (BONUS is the guy who wrote the tutorial, he ought to know)
01:05:33 <medfly> shouldn't wget -r do?
01:05:40 <mmorrow> blackdog: :)
01:05:40 <preflex>  mmorrow: you have 2 new messages. '/msg preflex messages' to read them.
01:09:21 <teolicy> medfly: wget -rk (k -> convert-links), and for some reason -k gives a bus error on my hosts, which I can't be bothered to much with.
01:09:31 <medfly> oh.
01:10:57 <zsol> curl?
01:17:07 <nomeata> Hi. If I have quite a few calls to (B.pack "string-literal") in some code that parses data from ByteStrings, will ghc be smart enough to only pack the string once, or will it be done on every invocation?
01:19:37 <Jedai> nomeata: sorry but it will probably do it every time, common subexpression elimination is a tricky business and can ruin your performance as easily as improve it, thus GHC only do it on some well identified case
01:20:21 <nomeata> Jedai: so I should move all string literals to top-level functions, right?
01:20:22 <Jedai> nomeata: You could just put this ByteString in another binding
01:20:40 <nomeata> Or would OverloadedStrings help here?
01:20:54 <kmc> OverloadedStrings will just desugar to what you have now
01:21:07 <Jedai> nomeata: I don't think OverloadedString will change anything, it's just sugar
01:21:24 <kmc> just move the string up to a top-level binding
01:22:45 <nomeata> hmm. I guess I’m past the point of constant amazement by haskell :-)
01:24:52 <kmc> not a top-level function though
01:25:53 <Cale> It would be nice to have some TH-y way to evaluate arbitrary values at compile time for things like that.
01:26:21 <Cale> Though making that sort of thing work just right is probably very hard.
01:26:31 <kmc> won't lifting a bytestring probably invoke pack anyway?
01:26:50 <Cale> Right. I mean, there should be support in TH for arbitrary values.
01:26:57 <kmc> yeah that'd be hard
01:27:02 <Cale> (as part of the "syntax")
01:27:13 <erikc> especially for cross compiling
01:28:38 <nomeata> kmc: a top level function without arguments, I mean :-)
01:28:40 <Jedai> There should really be support for arbitrary typed constants compiled in... that would be nice
01:28:46 <kmc> nomeata, that's not a function then
01:29:27 <kmc> there are no functions without arguments, it's a nonsensical idea from lesser languages ;)
01:30:40 <Berengal> Functions are just values of a certain type, like ints or strings
01:30:56 <kmc> a value is a function iff its type is of the form A -> B for some A and B
01:31:02 <Jedai> kmc : Though actually some like to think of constants in Haskell like that because a) using them can involve computation b) With typeclasses, some "constants" really take an argument underneath
01:31:25 <kmc> Jedai, very good points
01:31:41 <kmc> a top level bind that's typeclass-polymorphic is not really a CAF at all
01:31:44 <Jedai> I don't like it very much myself but I can understand why they do it ^^
01:34:20 <kmc> (a) is a little bit of a stretch since it's true for almost any value
01:35:10 <kmc> "function" in most languages has at least three roles: value parametricity, side effects, and delayed evaluation
01:35:15 <kmc> and we have separate concepts for each
01:36:39 <kmc> because they're not naturally the same concept at a high level
01:36:58 <kmc> only at lower levels, where a function becomes a "procedure" to be followed
01:47:19 <Gracenotes> kmc: don't forget about my friends ⒜ and ⒝
01:48:28 <kmc> :O
01:48:28 <nomeata> I have a function breakOn c = B.break (==c) in my code, where B = Data.ByteString.Char8. I compile my code with "-O2 -ddump-rules", but I don’t see the rule "ByteString specialise break (==x)" being fired. any idea whats wrong?
01:51:24 <Cale> nomeata: hmm... if for some reason your function doesn't get inlined, then I can imagine why that would be, but it really ought to be.
01:52:01 <nomeata> Cale: why does it have to be inlined to be replaced?
01:53:28 <nomeata> Cale: interestig, with -ddump-inlingings, it seems that the rule did fire:
01:53:50 <Cale> huh :)
01:54:16 <Cale> Oh, I suppose the rule should fire regardless.
01:54:26 <Cale> (now that I look at what the rule is)
01:54:45 <nomeata> Cale: see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13333#a13333
01:55:19 <nomeata> Cale: it inlines Darcs.breakOn (my function) with Bytestring.breakChar
01:57:00 <Cale> yeah
01:57:04 <Cale> so that's good
01:57:18 <Cale> I wonder why it wouldn't have shown up in the list of fired rules
01:58:02 <nomeata> Cale: is it worth filing a bug against ghc?
02:00:33 <Cale> nomeata: Seems suspicious.
02:03:09 <jaspervdj> what would be the proper way to read n lines from input without touching the remaining lines? so i want an IO [String]
02:03:27 <jaspervdj> currently using: sequence $ P.map (const getLine) [1 .. n]
02:03:48 <int-e> @src replicateM
02:03:49 <lambdabot> replicateM n x = sequence (replicate n x)
02:04:03 <ivanm> int-e: yeah, that's better than my suggestion was going to be ;-)
02:04:09 * ivanm keeps forgetting about replicateM
02:04:10 <jaspervdj> kthx :-)
02:05:44 <kmc> what's P?
02:07:16 <jaspervdj> I did: import Prelude as P, hence P
02:07:43 <ivanm> any particular reason for doing that?
02:09:17 <jaspervdj> I also import Data.Set as S
02:09:42 <jaspervdj> it there's a better solution for that as well, i'd be glad to hear it :-)
02:10:34 <muri_one> can I look at the source of a function from ghci?
02:11:08 <shachaf> :!cat Main.hs
02:11:26 <ivanm> muri_one: not really
02:11:51 <ivanm> muri_one: there's limited support for that by using GOA to embed lambdabot into ghci, but it only supports the definitions that lambdabot knows
02:12:56 <nomeata> Cale: http://hackage.haskell.org/trac/ghc/ticket/3703
02:13:36 <muri_one> well I usually peek at hoogle to find a function and it's implementation, but that site seems to be down at the moment :(
02:13:48 <ivanm> muri_one: hayoo
02:13:53 <ivanm> or just look directly at hackage
02:14:44 <muri_one> ivanm: thank you, didn't know about hayoo
02:14:48 <kmc> jaspervdj, i prefer "import qualified Data.Set as S"
02:14:53 <Cale> nomeata: oh, did you try -ddump-simpl-stats ?
02:14:55 <kmc> then use S.map for the Set version and "map" for the prelude one
02:15:02 <nomeata> Cale: no, what does it do?
02:15:02 <kmc> so you've consistently qualified all of one module
02:15:05 <ivanm> agreed
02:15:18 <ivanm> jaspervdj: just using "as X" defines an alias
02:15:23 <ivanm> so X.foo == foo
02:15:39 <ivanm> if you use qualified, then Data.Set.map == S.map /= map
02:16:01 <Cale> nomeata: Probably something closer to what you were expecting -ddump-rules to do, apparently :)
02:16:05 <ivanm> jaspervdj: the normal approach for things like Data.Set is a two-step import: import qualified Data.Set as S; import Data.Set(Set)
02:16:16 <ivanm> because qualifying types is a right royal pain
02:16:18 <muri_one> one thing I miss from the dynamic and interpreted python is the ipython shell. i'm not always online to look at hayoo or hackage
02:16:18 <nomeata> Cale: indeed, the rule is listed there. I guess I close my bug again.. thx
02:16:20 <kmc> i don't mind writing "S.Set"
02:16:31 <Cale> Though...
02:16:39 <Cale> I'm not sure you should close it
02:17:01 <ivanm> muri_one: yes, but in the case of ghc[i], the code from libraries is being read from compiled objects
02:17:02 <Cale> It does seem like a user interface issue.
02:17:08 <jaspervdj> kmc: you're right, qualifiying would make more sense
02:17:13 <ivanm> not from the source code directly or re-translatable bytecode
02:17:56 <muri_one> ivanm: yeah, the limitation makes perfect sense :), it's just unfortunate
02:18:04 <Cale> nomeata: and what is -ddump-rules actually supposed to be doing anyway? That output is nonsense.
02:18:33 <ivanm> muri_one: think about it this way: if the code was readable/printable, then it wouldn't be optimised with ghc magic!
02:18:56 <blackdog> ivanm: no reason you can't have both
02:18:57 <ivanm> muri_one: and large functions don't work well for cases like this where you want lambdabot/ghci to print the code...
02:19:06 <ivanm> blackdog: true, but it would involve extra work
02:19:18 <ivanm> blackdog: and for installation to install the source as well as the compiled libs
02:21:05 <blackdog> ivanm: yeah. It wouldn't necessarily need to be the full source, just the AST. Could be useful for doing interprocedural opts, too.
02:21:16 <ivanm> hmmm...
02:21:24 <ivanm> blackdog: it's a slippery slope though...
02:21:36 <blackdog> how so?
02:21:38 <ivanm> if we're not careful, then that kind of stuff could make Haskell turn into _Lisp_! :p
02:21:49 <blackdog> how terrible.
02:22:02 <ivanm> exactly!
02:22:04 <ivanm> ;-)
02:23:06 <nomeata> I have a function that takes apart ByteStrings, but does not concatenate or change them (uses only stuff like break, tail, etc.) that do not copy data, just set pointers into the data I have. Yet this function turns up to be the biggest memory eater according to hc2ps. Is that an indicator that something is wrong?
02:24:34 <ivanm> probably
02:24:58 <nomeata> Any idea of common pitfalls when doing that?
02:35:19 <Baughn> lambdabot: ping
02:40:54 <Saizan> nomeata: strict bytestrings, right?
02:41:13 <nomeata> Saizan: yes
02:42:07 <nomeata> (Maybe I’m just under-estimating the size of the many PS constructors around, even if they point to the same piece of data in memory :-()
02:44:39 * nomeata feels he will just have to re-programs parts of the program to more oven write data out to disk and read it back when needed.
02:54:54 * hackagebot upload: unicode-symbols 0.1.1 - Unicode alternatives for common functions and operators (RoelVanDijk)
02:55:32 <nomeata> Also strage: hp2ps shows a constant decline of memory usage while the program is running, although all data is referenced from one value, so it can not be due to garbage collection
02:56:53 <nomeata> That sounds like it’s due to thunks whose arguments use up more memory than their result. But large amounts of data are held by Data.Bytestring.Char8.breakChar that definately does not have larger arguments that results.
03:01:09 <Saizan> nomeata: have you tried with -hd ?
03:02:53 <nomeata> Saizan: I get a few entries named "Darcs.sat_...". What does that mean?
03:06:22 <nomeata> Saizan: ah, great, I guess I found a spot where adding seq greatly decreases memory consumption
03:15:45 <nomeata> So, hp2ps says that some closure is taking up memory. Is there a way to find out where in my code that closure is?
03:23:32 <opqdonut> nomeata: add cost centers, do cost-center profiling
03:36:50 <blackdog> this sounds a bit weird, but can a piece of code get access to the ghc command line that it was compiled with?
03:37:25 <blackdog> I'd like to pass the extra-include-dirs parameter into the program
03:38:44 <Baughn> blackdog: You could do that rather more directly, using a postInst hook to write that parameter directly into a file in the datadir
03:40:27 <Baughn> blackdog: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13337#a13337 <-- Um.. something like this, only working. Have fun!
03:40:31 <blackdog> Baughn: ... that would also work:) thanks
03:41:26 <nomeata> I have a cost-center thats a function that returns a tuple that I am immediteally taking apart, so I’d expect that cost-center to not show up. Is that correct? (Probably not, because it shows up)
03:42:32 <Baughn> nomeata: Profiling disables that sort of optimization
03:43:05 <Baughn> (Specialization/inlining, that is)
03:43:16 <nomeata> Baughn: I mean, I’d not expect that cost-center to hold a relevant amount of memory, because it is immeditally evaluated
03:44:50 <Baughn> nomeata: Not at the same time, anyway. What are you actually seeing?
03:45:17 <ivanm> If I have a custom class inside a module which isn't exported, how can I stop Haddock from mentioning that datatypes are instances of that class?
03:46:07 <nomeata> Baughn: I see that this cost-centre is taking up a chunk of memory, and it is not getting less even while I’m sure that the tuple has to be evaluated
03:51:23 <nomeata> what does "stg_ap_1_upd_info" in -hd generated output mean?
03:52:51 <ivanm> stg is the transformation graph thingy, isn't it?
03:53:13 <ivanm> @google haskell stg
03:53:14 <lambdabot> http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler
03:53:14 <lambdabot> Title: Glasgow Haskell Compiler - Wikipedia, the free encyclopedia
04:02:26 <nomeata> Great, after some well-placed stricness annotations my program now uses 93147640 bytes of bytestring for 90898902 bytes of data + 30656520 bytes for : and 26449728 bytes for my data type "PatchInfo". I guess I can not expect more.
04:03:27 <ivanm> heh
04:03:46 <ivanm> nomeata: random suggestion: tried switching between strict and lazy bytestrings?
04:04:58 <nomeata> ivanm: I had lazy bytestrings before, but it was even worse
04:05:08 <ivanm> hmmm....
04:05:16 <ivanm> *shrug* bytestrings are still a magic box to me ;-)
04:05:23 <nomeata> ivanm: and since I avoid concatenating or modifying bytestrings, strict ones are definitely better here
04:05:41 <ivanm> nomeata: maybe try the approach suggested on that Closed Cartesion Comic? :p
04:05:56 <blackdog> nomeata: lazy bytestrings could still be better if you were using them in a streaming sort of way, i guess.
04:06:00 <nomeata> ivanm: whch ones?
04:06:10 <nomeata> blackdog: right, but that’s not the case
04:06:21 <ivanm> nomeata: make it a new shootout entry, and get dons to optimise it :p
04:06:50 <nomeata> ivanm: :-)
04:07:09 <Axman6> heh
04:07:23 <ivanm> heya Axman6
04:07:36 <Axman6> o/
04:07:42 <Axman6> how'd the house hunting go?
04:08:46 <nomeata> hmm. but in production, memory consumption is still too high. I guess I can not avoid some serious refactoring.
04:08:47 <ivanm> eh
04:09:09 <ivanm> Axman6: still difference in opinions on what type of apartment we're actually looking for
04:09:30 <ivanm> Axman6: had a look at some new "Lakeside view" or something place behind belconnen shops; pretty dodgy... >_>
04:09:36 <ivanm> (even their supposed penthouses...)
04:09:53 <Axman6> i still highly recommend that bruce one. i don't think you understand just how well located bruce actually is ;)
04:10:16 <Axman6> (this is from someone whose spent years being dragged to open houses by his parents, and has picked up a lot)
04:10:17 <ivanm> Axman6: the problems with bruce is, its not within walking distance from civic
04:10:30 <ivanm> which my parents think would be advantageous for several reasons
04:10:33 <Axman6> pfft
04:10:40 <ivanm> (not necessarily for me though...)
04:11:08 <nomeata> hmm. code.haskell.org does not have much more memory than my machine, so moving darcswatch there would not help either :-)
04:11:24 <ivanm> heh
04:11:28 <Axman6> well stuff 'em :P it's your house. and if they stay with you, then they can take the damn bus like everyone else. i really like taking the bus here. they're air conditioned, quiet, fast and reliable
04:11:34 <dcoutts> Baughn: are you looking at the darcs version of the cabal-install code then?
04:20:49 <sohum> Axman6: pfff. reddit is not for casual gdays!
04:20:55 <sohum> (by which I mean gday to you too)
04:23:03 <sohum> ivanm: why isn't bruce walking distance from civic?
04:23:12 <Saizan> nomeata: the heap profiling section of the ghc manual explains the various options, there's one to split closures by the module they're coming from, iirc
04:23:13 <sohum> ivanm: (also hey! I didn't know you were a canberranite)
04:24:54 <blackdog> oh, that's priceless. Someone's telling Manuel on reddit that Haskell is more high level than C.
04:25:18 <Cale> blackdog: ahaha, where?
04:25:41 <blackdog> http://www.reddit.com/r/haskell/comments/a929y/haskell_highlights_at_supercomputing_09_addesa/
04:27:06 <Twey> Haha, nice article
04:29:09 <Reshure> Hey, I am going through the LYAH tutorial, but I am stuck at the third code sample of the Where!? section (http://learnyouahaskell.com/syntax-in-functions#where). I keep getting an error: test.hs:8:11: parse error on input '='. That is the line with skinny = 18.5. What am I doing wrong?
04:29:39 <Cale> Reshure: make sure there are no tabs in your source code
04:29:54 <Twey> Reshure: You're running it in GHCi, but the example is meant to be run from a file
04:29:57 <Cale> Reshure: and that you're lining things up the same was as in the example
04:29:58 <Twey> Oh, wait
04:30:04 <Twey> Sorry *facepalm*
04:30:06 <Cale> way*
04:30:48 <Cale> Reshure: If you're using vim, then :set expandtab  (or better yet, add that command to your .vimrc)
04:31:12 <Cale> Reshure: Most editors have a command for expanding tab keypresses into multiple spaces
04:32:19 <Reshure> I tried :set expandtab, and I'm sure I've indented everything correctly, but I still get the error.
04:32:41 <Axman6> Reshure: can you paste your code please?
04:32:58 <Cale> @paste
04:32:59 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:33:05 <reiv> 2 program, compiled with '-threaded', why behavior different. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13341, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13342
04:33:37 <Cale> reiv: The behaviour of those two programs should be identical.
04:34:05 <reiv> Cale: but not
04:35:00 <Reshure> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13343#a13343
04:35:23 <reiv> Cale: the second one, quit instantly.
04:35:43 <Axman6> Reshure: you need to line up skinny, normal and fat with bmi
04:36:31 <Cale> reiv: hmm... perhaps there's something attached to the garbage collection of the input handle.
04:36:44 <Cale> reiv: In any case, that's rather surprising.
04:36:55 <Axman6> time to report a bug!
04:37:07 <Reshure> Sorry, I pasted it wrong. I have it lined up correctly in my code.
04:37:28 * hackagebot upload: haskell-src-exts 1.3.2 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
04:37:30 <Cale> Reshure: there are tabs in this
04:37:40 <Axman6> so there are
04:37:41 <reiv> Cale: I think, sub process should wait for input, I dont'k know why 'cat' quit.
04:38:04 <Cale> reiv: Probably the input handle closes itself when it gets GC'd
04:38:17 <Cale> reiv: and then cat sees that the input handle is closed and exits.
04:38:28 <reiv> Cale: maybe. but without '-threaded', that's ok.
04:38:42 <Reshure> Ok, it works now, thanks.
04:38:55 <Axman6> reiv: i'd try asking in #ghc. sounds like it should be a bug
04:39:19 <Cale> reiv: The garbage collector works differently with and without -threaded, I believe.
04:39:57 <Cale> reiv: But that's just a suspicion. It's definitely something that a GHC developer should look at.
04:40:03 <blackdog> Baughn: ended up using preConf to write Includes.hs into the current directory. I know it's a bit filthy, but I'd like to lock it down at compile time...
04:40:28 <Cale> reiv: The behaviour also changes with -O2
04:41:10 <jkramer_> AHoy
04:41:16 <Cale> hello
04:41:37 <jkramer_> Can someone please explain this to me? http://pastie.org/719090
04:41:49 <jkramer_> Bot versions compile, but only the first one works
04:41:59 <jkramer_> The second one seems to do just nothing
04:42:39 <Berengal> @type liftM2
04:42:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:42:42 <Cale> jkramer_: Where's the rest of the code?
04:42:58 <Cale> jkramer_: The liftM2 will make things happen in a different order than you have there.
04:43:10 <Cale> jkramer_: It should be equivalent to doign the getArgs first
04:43:14 <Berengal> From the code I assume dispatch :: a -> b -> IO c?
04:43:16 <Cale> doing*
04:43:46 <ivanm> sohum: I will be next year, but currently I'm not
04:43:47 <Berengal> In any case, liftM2 dispatch :: IO a -> IO b -> IO (IO c), which does nothing
04:43:54 <jkramer_> dispatch takes the args and returns a IO function that takes the log as argument
04:43:59 <Cale> oh, good catch, yeah
04:44:06 <jkramer_> So dispatch :: a -> (b -> IO ()) or something
04:44:35 <Cale> jkramer_: you need to run the result of that liftM2
04:44:42 <Cale> jkramer_: which you're not doing
04:45:03 <jkramer_> Shouldn't the fact that main = the result of liftM2 and main being run do that?
04:45:05 <Axman6> o/ sohum, missed your g'day, sorry :)
04:45:23 <Cale> jkramer_: you're getting an IO (IO ())
04:45:32 <jkramer_> Oh
04:45:37 <Cale> jkramer_: and only running the outer layer to get another IO action which you're not running
04:45:56 <Cale> You could apply join to the whole thing
04:46:09 <Cale> But to be honest, I would be more likely to keep the first code.
04:46:37 <jkramer_> Just add "join $" before the lift?
04:46:42 <Cale> yeah
04:46:46 <Axman6> -_
04:46:57 <jkramer_> Yay, works :) Thanks a bunch
04:47:11 * Berengal shrugs
04:47:24 * Axman6 highly dislikes that solution
04:47:36 <sohum> ivanm: ah. in that case, welcome to our, uh, fine cityvillagething
04:47:40 <ivanm> heh
04:47:41 <jkramer_> Cale: I'll do that, I was just wondering why the second one didn't work
04:47:52 <sohum> Axman6: :P
04:47:58 <Axman6> the first code, while longer, is more clear and understandable
04:48:11 * blackdog represses a joke about misery loving company out of deference to Axman6.
04:48:25 <Cale> jkramer_: Do you understand why now?
04:48:26 <Twey> sohum: ‘Bleak, soulless hell’?  ;)
04:48:41 <Cale> jkramer_: liftM2 f x y = do v <- x; w <- y; return (f x y)
04:48:45 * Twey tacks a ‘corporate’ in there somewhere.
04:48:48 <Axman6> ivanm: when you move down here, we should go to fp-syd together, and you can meet blackdog
04:48:48 <jkramer_> Yes, I understood it when looking at the type of join :)
04:48:51 <blackdog> Twey: oh, you've visited our fair capital?
04:48:57 <Twey> blackdog: I've had the pleasure :þ
04:49:06 <Twey> Have to say, I prefer Sydney
04:49:09 <Cale> jkramer_: another option is to use ap
04:49:12 <sohum> Twey: oy! it's actually not bad, but it's not for those who want to party down
04:49:16 <Cale> jkramer_: or the Applicative <*>
04:49:37 <Twey> sohum: No kidding :þ
04:49:37 <Axman6> Twey: you're a nut
04:49:37 <blackdog> only place in Australia with legal pot and eye-watering porn, and it's still boring...
04:49:39 <Axman6> how on earth anyone could prefer sydney to canberra i have no idea
04:50:01 <Cale> jkramer_: dispatch <*> getArgs <*> load
04:50:02 * sohum snerk
04:50:06 <Twey> Hahaha
04:50:12 <blackdog> sohum: we took Axman6 out drinking in Glebe and he was witness to a certain amount of ... ah, shall we say domestic high-spirits.
04:50:21 <Axman6> blackdog: so, what do you do in sydney that's so exciting then?
04:50:22 * Twey chuckles.
04:50:24 <Cale> jkramer_: Or equivalently  dispatch `ap` getArgs `ap` load
04:50:30 <blackdog> Axman6: sit on #haskell, obviously:)
04:50:48 <Axman6> pathetic!
04:50:50 <Axman6> :P
04:50:53 <blackdog> but Skunkhour's playing in a week, and the Maladies played a while ago.
04:50:57 <sohum> hahahahah
04:51:08 <jkramer_> Cale: I think I'll stick with the do version :)
04:51:24 * blackdog can't even take care of a bloody puppy
04:51:31 <Axman6> XD
04:52:04 * Baughn wonders if swapping AES encryption and decryption functions affects security
04:53:55 <Baughn> @index unsafeIOToST
04:53:56 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
04:54:10 <Twey> Why is that unsafe?
04:54:15 <Twey> Oh, multiple accesses?
04:54:20 <Axman6> because ST is supposed to be pure
04:54:21 <Baughn> @type unsafeIOToST
04:54:22 <lambdabot> Not in scope: `unsafeIOToST'
04:54:34 <Axman6> IO a -> ST s a
04:54:43 <Axman6> forall s.
04:54:47 <Axman6> or summat
04:54:54 <Twey> IO a -> (forall s. ST s a)
04:54:56 <Twey> IIRC
04:54:59 <Baughn> Yeah. Not what I'd call safe. ^^;
04:55:07 <Twey> Yeah :þ
04:55:25 <Berengal> Perhaps the reason it's called "unsafeIOtoST"?
04:56:03 <Axman6> i think you may be on to something
04:56:44 * Baughn uses it.
04:56:49 <reiv> should I report the problem I ask as a ghc bug?
04:57:01 <Baughn> reiv: Dunno. What problem?
04:58:34 <Axman6> i've used it for debugging using putStrLn
04:58:51 <Twey> Debug.Trace!  Debug.Trace!
04:58:54 <Axman6> reiv: ask in #ghc first, and talk to the developers
04:59:03 <Cale> Baughn: Would you believe that a program with a do-block (the definition for main, in the IO monad) ending in  return foo; return ()  could behave differently from one with just  return () ?
04:59:19 <reiv> Axman6: ok
04:59:23 <Cale> Baughn: that's what reiv has found :)
04:59:33 <Berengal> :O
04:59:42 <Twey> Huh.
05:00:00 <Cale> Of course, lots of other things also change the behaviour, like adding -O2
05:00:25 <Baughn> Cale: My mind. 'tis breaking.
05:00:49 <Baughn> Hm
05:00:55 <Berengal> Wait, I think I've heard of this before
05:00:56 <Cale> In this case, foo is an input handle to a program, and I think the return is preventing it from being GC'd, and there's a finaliser attached.
05:00:56 <Baughn> That particular call.. I've studied a bit.
05:01:02 <Baughn> Yes
05:01:03 <Berengal> Something about IOs return being strict
05:01:18 <Baughn> reiv: Say, what exactly is the difference in behaviour?
05:01:44 <Berengal> Wait, I was thinking of parsec... never mind
05:01:50 <Cale> Baughn: In the version without the extra return, the 'cat' subprocess exits immediately.
05:02:02 <Baughn> Right
05:02:11 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13342
05:02:18 <Baughn> This is somewhat surprising, but I don't think it's a bug, as such
05:02:24 <Cale> In case you didn't see the link
05:02:31 <Baughn> reiv gave it to me. ;)
05:02:34 <Cale> ah
05:02:39 <soiamso> Baughn: if hI call later with return hI, or trace will change the behavior.
05:02:46 <Baughn> Anyhow, cat won't exit until its input is closed; that's part of its contract
05:02:57 <Baughn> And the program /doesn't/ close the input
05:03:16 <Baughn> The only reason it ever works at all is because of a finalizer, but you're not supposed to rely on finalizers; they run unpredictably
05:03:34 <Baughn> So, really, the bug is in reiv's program. ;)
05:04:21 <Baughn> Let's see.. it would be good to change the finalizer for handles to print a warning, so you know you're doing it wrong
05:04:57 <Cale> It would also be good to always do enough optimisation to ensure that the monad laws for the IO monad are valid ;)
05:05:47 <Cale> Though I guess we could claim that the semantics of this program are a bit ill-determined to begin with.
05:06:03 * Baughn would so claim
05:06:22 <Baughn> My preferred solution is to make the handle finalizer stop closing handles - that's what's causing the indeterminacy
05:06:29 <Baughn> ..just make it print a warning instead
05:07:16 <Cale> Still, it's really awkward, regardless of what the remainder of the program is, to ever have a program behave differently because of an extra return foo in the middle of a do-block.
05:07:16 <Berengal> Or at least print a warning in addition to closing
05:07:19 <Baughn> Yeah, I know that's the more likely solution
05:09:28 <blackdog> how do you format the description in a cabal file/
05:09:29 <blackdog> ?
05:11:00 <blazzy>  /topic
05:11:01 <lambdabot> blazzy: You have 1 new message. '/msg lambdabot @messages' to read it.
05:11:13 <dcoutts> blackdog: you mean the markup you see in other packages?
05:11:21 <dcoutts> blackdog: it uses haddock markup
05:11:27 <blackdog> ah, righto. thanks.
05:11:49 <jkramer_> Hmm
05:12:14 <blackdog> dcoutts: hang on - do you mean in the code itself? i'm just talking about the description on the hackage page
05:12:22 <jkramer_> When I have data Foo = Foo Int Int deriving (Ord), how are values of that type ordered=?
05:12:30 <dcoutts> blackdog: yes
05:12:41 <dcoutts> blackdog: the description on the hackage page
05:12:55 <jkramer_> It seems to define the Ord instance for me, but what's the default ordering for this?
05:14:05 <Axman6> jkramer_: should be something like: compare (Foo a b) (Foo c d) = case compare a c of EQ -> compare b d; x -> x
05:14:20 <Axman6> @src Ord
05:14:20 <lambdabot> class  (Eq a) => Ord a  where
05:14:21 <lambdabot>     compare      :: a -> a -> Ordering
05:14:21 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
05:14:21 <lambdabot>     max, min         :: a -> a -> a
05:15:44 <jkramer_> Axman6: That looks exactly like what I wanted to do myself :)
05:15:54 <Axman6> jkramer_: well, good
05:16:07 <Axman6> the defaults are usually very sensible
05:16:30 <reiv> the problem what I ask is not a bug, though the program not work as i think.
05:17:35 <Axman6> it's only when you need to write your own Ord instance is when you don't want order depending on one of the fields of the type
05:18:21 <jkramer_> hoogle is broken :(
05:19:15 <Axman6> sleep time. night all
05:19:31 <blackdog> quitter
05:29:09 <ketil> Is there any way to get a UArray of (# Double, Double #)?
05:29:33 <ketil> (or something similar - use StorableVector and map coordinates myself, perhaps?)
05:29:45 * ketil needs 2D arrays.
05:29:57 <jkramer_> How do I get year and month from a Day?
05:32:08 <muri_one> jkramer_: try Hayoo instead
05:32:42 <jkramer_> I did, doesn't find anything useful for "month" :)
05:37:10 <dancor> jkramer_: you are using old-time?
05:37:55 <jkramer_> I don't think so
05:37:57 <yitz> ketil: I don't remember, is there an IX instance for tuples? you could index it by tuples. or else use the old C trick of encoding (Int, Int) in Int
05:38:31 <ketil> yitz: yes, UArray can use tuple indexing - but I want to *store* tuples, too.
05:38:35 <jkramer_> Data.Time
05:38:35 <soiamso> Baughn: I still have some problem in reiv's wrong code, why GHC not warn us as in pure function like  warning "hI not use later."
05:38:47 <yitz> ketil: use two arrays
05:38:59 <dancor> ah
05:39:01 <ketil> I'm happy with strict, but I don't really want the overhead of indirect pointers.
05:39:42 * hackagebot upload: hubris 0.0.2 - Support library for Hubris, the Ruby <=> Haskell bridge (MarkWotton)
05:39:44 <ketil> yitz, yes - although then I'd need different code for that (ideally, I'd like this to be polymorphic).
05:40:34 <yitz> ketil: anyway, what's so indirect about (x,y) = (a!0,a!1) ?
05:41:04 <dancor> jkramer_: toGregorian?
05:41:05 <yitz> err, (x,y) = (a!(i,0), a!(i,1))
05:41:21 <dancor> http://hackage.haskell.org/packages/archive/time/1.1.3/doc/html/Data-Time-Calendar.html#t%3ADay
05:41:25 <ketil> (yitz: Indirect refers to UArray vs Array.)
05:41:52 <jkramer_> dancor: Ah, nice, thanks
05:41:54 <yitz> ketil: ah. so yeah, index your UArray with a tuple.
05:41:57 <dancor> you have to be careful with timezones too
05:42:17 <dancor> utctDay of getCurrentTime is going to be UTC e.g.
05:43:09 <ketil> yitz, I'm not getting across here, I think :-)  Tuple indexes are okay, but I want my code to be polymorphic in the array contents - specifically, it'd be nice if I could use either Double or (Double,Double).
05:43:29 <yitz> ohhh, now I see
05:43:34 <ketil> I thought there was some kind of trick to make this work also for unboxed arrays, but I don't remember how (and possibly misremember).
05:43:49 <yitz> ketil: so you want to have your cake and eat it too
05:43:56 <ketil> Yes.  Don't we all?
05:44:00 <yitz> indeed
05:44:40 <yitz> so you want UArray Either#
05:44:47 <ketil> Semantically, this shouldn't be a problem - the difference between UArray and Array is just the strictness.  In practice, Unboxing can only be done for old style Array.
05:45:28 <ketil> No!.  I want to write a function that returns Uarray (Int,Int) a.  Where 'a' might be a tuple of some sort.
05:45:56 <yitz> old style? UArrays are by defn arrays of unboxed value in memory, no?
05:46:01 <ketil> Sorry - the last sentence in the second to last comment doesn't make sense (In practice, Unboxing...etc)
05:46:17 <ketil> ..can only be done for predetermined set of types, I meant.
05:46:38 <ketil> Or with StorableVector, which is probably my best bet.
05:47:06 <yitz> ketil: Either (UArray (Int, Int) a) (UArray (Int, Int, Int) a)
05:47:06 <ketil> And I'd need to map indexes to 1D myself,  but that should be doable, I guess...
05:47:24 <ketil> yitz, hmm...yes.
05:47:41 <yitz> ketil: well obviously something more sophisticated than that
05:48:44 <ketil> You know, that might just work.  I'll have to check the drawing board to see if I can fit all the pieces to that model, though.
05:49:00 <yitz> ketil: if the things inside can individually be polymorphic, I'm afraid you'll have to stay boxed, or implement it yourself with pointers
05:49:38 <ketil> (UArray (Int,Int) is just a special case of UArray (Int,Int,Int), with the last index having only one value, so I can still boil it down to a single type)
05:49:52 <yitz> ah, true.
05:50:36 <ketil> The question is if it's still general enough - what if somebody comes along and wants an even "deeper" structure?
05:51:04 <yitz> ketil: no problem use Array
05:51:46 <ketil> BTW, this is for sequence alignments - I'm trying to put together a general framework from which to compose different alignments (local/global, etc) with different "sequence" types (String, arrays, PSSMs) and different algorithms (alignment matrix, iterative, etc).
05:52:14 <ketil> It's surprisingly hard to modularize these aspects.  Or perhaps my brain is just too small :-)
05:52:25 <yitz> alignments (local/global) ?
05:53:02 <ketil> global aligment aligns strings from beginning to end - local alignment finds two substrings that optimally aligns.
05:53:22 <ketil> also: overlap alignment, where the end of one string aligns with the beginning of the other.
05:53:43 <ketil> I guess you could also do prefix and suffix alignments, not sure how useful those are.
05:54:06 <yitz> byte alignments? memory alignments on the heap? ??
05:54:30 <ketil> alignments as in taking two strings and aligning them to each other, minimizing the edit distance.
05:54:37 <yitz> ahh
05:54:39 <ketil> think "diff"
05:55:08 <yitz> that can be hard, in general.
05:55:22 <ketil> (sorry, the context is clear to *me*, but this is what I do all the time.  I forget there is a bigger world out there)
05:55:49 <ketil> the theory is there, speed is the problem.  And clarity of code.
05:56:03 <yitz> anyway, the problem you're describing is not that, just the part about a container that works for various types that you come across. i see
05:56:33 <ketil> The array stuff is for the dynamic programming matrix used to implement the canonical algorithm.
05:57:02 <ketil> I.e. cell (i,j) stores the score of the optimal alignment of x[1..i] to y[1..j].
05:57:34 * yitz nods
05:58:20 <yitz> ketil: this sounds like typeclass territory
05:58:21 <ketil> Pairs are needed for affine gap penalties, where the cost of a gap of length n is a+bn.  I need to keep track of two values in each cell, the score ending with a gap, and the score ending with a substitution (non-gap)
05:58:37 <ketil> yitz, I was afraid you might say something like that.
05:58:42 <yitz> heh
05:58:51 <ketil> yitz, I'm even more afraid to ask:  Oh, how so?
05:59:29 * ketil looks at watch.  Oh, is it that late already?  Gee, I really have to get the animated reindeer mounted on the roof.
05:59:35 <yitz> you define an interface, and instantiate it with the array types that you need for each variation
06:00:46 <ketil> Yes.  Currently everything (score, sequences) is parametric, and the modules are records of functions with appropriate type, but later I might need to restrict the types involved.
06:01:48 <yitz> ketil: with a typeclass (or ADT with functions, if you prefer), you're not restricting that, you just need to write an instance when you want to use a new type.
06:02:23 <ketil> Yes - my records are really a poor mans typeclass, I guess.
06:03:46 <ketil> Currently I do: align :: AlignModel a -> AlignConf a -> a -> a -> AlignResult  a -- where Align* are records and a are sequences.
06:05:11 <ketil> Anyway, I really need to go - guests for dinner soon.  House in a mess and wife still napping.  Either need to clean up the former or wake the latter :-)
06:05:18 <yitz> ketil: well, that's great. you could just include in AlignResult some functions to access the results, then you can vary the underlying array type.
06:05:29 <yitz> ok bye!
06:05:33 <ketil> Either choice will tear me away from the keyboard.
06:05:39 <yitz> go!
06:05:55 <ketil> Yeah, that's the idea.  Different 'align' functions can use different implementations.
06:06:09 <ketil> There will be a blog post if/when I get the pieces to fit together.
06:06:16 <yitz> or wait for her to wake up before you've done either. go!
06:06:23 <ketil> Thanks for the chat.  See you around.
06:06:25 <ketil> :-)
06:06:30 <yitz> bye :)
06:10:35 <benmachine> this is odd, I have a parsec parser which I am running in ghci and it is hanging
06:10:52 <benmachine> ghci> parse skipToForm "<stdin>" "blahblahvlag"
06:10:58 <benmachine> has not given a response
06:11:09 <benmachine> but ghc's memory and CPU usage are normal
06:11:12 <benmachine> it's like it's not trying?
06:11:26 <yitz> benmachine: try typing something in your console
06:11:43 <benmachine> yitz: little effect
06:11:49 <benmachine> I can interrupt it
06:11:55 <yitz> oh well. that's always my mistake. :)
06:11:59 <benmachine> but it seems impervious to EOF
06:12:09 <benmachine> yeah I do it too, but parse shouldn't be watching stdin
06:12:26 <yitz> I just said that because you said <stdin>. :)
06:12:37 <benmachine> oh yeah, that was a lie :)
06:12:48 <yitz> benmachine: it's possible to write loopy code in a parsec parser.
06:13:05 <benmachine> yeah, but I would expect a CPU burn or stack overflow in that case
06:13:22 <benmachine> ghc is currently using 2.5% mem and 0% CPU
06:14:20 <larsko> hi
06:14:26 <benmachine> hi
06:14:30 <yitz> benmachine: cron.daily running?
06:14:33 <larsko> I've got a question about template haskell
06:14:51 <benmachine> yitz: nope
06:15:09 <larsko> I have a data type with several constructors, a list of pattern matches for those constructors and a bit of code to execute in the body for each of them
06:15:43 <larsko> is there a nice way to define something that given the list of constructor pattern matches and the code (which is the same for each of them) will generate the functions?
06:16:01 <benmachine> I guess my parser is looping but in such a way that ghc doesn't really mind
06:16:36 <yitz> benmachine: could very well be, but in that case you'd think it would be pretty obvous where. how big is your parser?
06:17:17 <benmachine> yitz: it's only a one-liner, but it's recursive so it could very easily be looping
06:17:31 <benmachine> if I'm somehow managing to let it succeed on empty input
06:17:32 <yitz> oh, could I see it then?
06:17:39 <benmachine> skipToForm = many (noneOf "<") *> char '<' *> try (string "form") <|> skipToForm
06:17:50 <benmachine> oh wait a sec
06:17:59 <benmachine> *> has higher precedence than <|> doesn't it
06:18:04 <benmachine> maybe hmm
06:18:16 <benmachine> ah
06:18:48 <jkramer_> Where's the config file for ghci settings again?
06:18:55 <benmachine> yeah, parenthising the last two bits makes it not loop
06:18:57 <yitz> .ghci
06:19:02 <jkramer_> Ah, thanks :)
06:20:32 <yitz> benmachine: yay! see, posting the code here always helps. :)
06:20:38 <benmachine> heh
06:20:43 <benmachine> it still doesn't do what it does, mind
06:20:47 <benmachine> just doesn't loop anymore :P
06:20:51 <benmachine> er
06:20:59 <benmachine> s/it does/I want it to do/
06:21:22 <yitz> it returns the word "form", if it's there, or fails.
06:21:39 <benmachine> oh, I am not testing it properly
06:21:55 <benmachine> I forgot that the handling for the failure case was further up the parsey tree
06:22:01 <benmachine> maybe it does work
06:22:55 <yitz> wait, it will still loop if no <form
06:23:30 <benmachine> no it goes, unexpected end of input
06:23:37 <benmachine> because of the char '<'
06:23:52 <yitz> oh, I forgot, the last two are in parens
06:23:55 <benmachine> yeah
06:24:09 <benmachine> before they were in parens it did indeed loop
06:24:15 <benmachine> but apparently without consuming any resources
06:24:18 <benmachine> which is interesting
06:24:25 <yitz> so it will skip all <tag until it gets to <form, or fails
06:24:39 <benmachine> yes
06:24:48 <benmachine> well
06:24:54 <benmachine> it will skip all everything until <form
06:25:11 <benmachine> maybe I can do this simpler
06:25:18 <yitz> i think you can
06:25:24 <benmachine> if I drop the char '<' thing and just make it many1 noneOf
06:27:50 <Cale> benmachine: are you writing a parsec parser to parse html?
06:28:08 <benmachine> Cale: only forms
06:28:30 <benmachine> are you going to tell me who has already done it?
06:28:36 <benmachine> I thought there might be something around
06:28:43 <Cale> Well, there are HTML parsers on Hackage.
06:28:49 <benmachine> hmm
06:29:03 <benmachine> I had a look at a few and they mostly seemed too vague
06:29:16 <benmachine> can you recommend anything?
06:29:30 <benmachine> a lot of the obvious names seemed as much about building HTML as reading it, which I am not interested in
06:29:44 <yitz> benmachine: tagsoup?
06:29:59 * benmachine pokes cabal info
06:30:16 <yitz> benmachine: or Galois' HTML parser, which uses tagsoup I think
06:30:29 <benmachine> yitz: package name?
06:30:51 <benmachine> or should I google
06:31:13 * yitz looks. Hackage is becoming harder and harder to search.
06:34:53 <yitz> benmachine: nah, Galois' is only xml. try tagsoup.
06:35:11 <benmachine> okay
06:35:30 <yitz> benmachine: in your parser, if you roll your own, you don't want to use recursion usually. there are almost always existing combinators you can use.
06:35:51 <yitz> benmachine: in this case, you'd consider skipMany or similar
06:35:52 <benmachine> good point
06:36:01 <benmachine> hadn't thought about it like that
06:38:14 <benmachine> aww I was having fun with this parsing stuff :P
06:38:14 <yitz> benmachine: the problem here is, what if there is the string <form in quotes somewhere (like in JS in the head)? there are a lot of corner cases. makes sense to use an existing full parser, even if you only need the forms.
06:38:24 <benmachine> yeah, true
06:38:41 <benmachine> p.s.
06:39:04 <benmachine> I think that there should be a (*<) with x *< y = const <$> x <*> y
06:39:32 <benmachine> i.e. order things left to right but get the result from the thing on the left
06:40:28 <benmachine> char '"' *> many (noneOf "\"") *< char '"'
06:40:36 <benmachine> it makes sense!
06:42:04 <ben> What is the difference to <*?
06:42:31 <benmachine> putStrLn "foo" <* putStrLn "bar" puts bar and then foo, I think
06:42:43 <benmachine> whereas mine'd put foo and then bar
06:43:11 <ben> Seems to do that already
06:43:19 <gwern> @src undefined
06:43:20 <lambdabot> undefined =  error "Prelude.undefined"
06:43:53 * benmachine tries to think of a suitable pure testcase
06:43:56 <benmachine> @let x *< y = const <$> x <*> y
06:43:59 <lambdabot>  Defined.
06:44:24 <benmachine> Maybe doesn't really work because it doesn't order
06:44:34 <benmachine> I think the same is true of List
06:44:45 <benmachine> :t parse
06:44:47 <lambdabot> Not in scope: `parse'
06:46:01 <benmachine> but I think char '"' *> many (noneOf "\"") <* char '"' would parse two "s and then some other things
06:46:09 <benmachine> and give you the other things
06:46:35 <benmachine> char '"' *> many (noneOf "\"") *< char '"' would parse "fooo" and give you fooo
06:50:24 * hackagebot upload: NoSlow 0.1.1 - Microbenchmarks for various array libraries (RomanLeshchinskiy)
06:53:04 <LouisJB> Hi, I had GHC on my Mac a while ago but since upgrading it doesn't appear to be there on the path, I can't recall how I installed it but I think through mac ports, is this a good way to do it?
06:54:39 <poe> LouisJB the .pkg on ghc's site is better I think (personal opinion)
06:55:05 <LouisJB> ok thanks - that should be 10.6.x compatible right?
06:55:36 <LouisJB> 6.10.4 is on the site, looks like the current version
06:59:08 <LouisJB> it doesn't say it's compatible with SnowLeopard, I guess no harm to try it and see?
07:02:20 <i_am_neuron> Folks, I'm writing a program to process ID3 tags of my music collection (here's the code, hopefully it's not too cryptic), and stumbled upon error message which is indeed cryptic for me: Main.hs:16:0: The equation(s) for `n' have two arguments, but its type `Action' has none. What does this mean?
07:02:27 <trin_cz> hi, I need to traverse STUArray and as indexes I want to use something else then lists. Is there some vector/stream which has mapM_ and enumerator?
07:02:42 <i_am_neuron> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5186#a5186
07:04:45 <koeien37> i_am_neuron: that should be n = Action (\_ _ -> return [])
07:05:37 <koeien37> you should use the constructor Action to make values of type Action
07:05:37 <arjanb> i_am_neuron: or just use type instead of a newtype
07:06:19 <koeien37> that's a reasonable alternative, yes
07:06:28 <i_am_neuron> arjanb: is the syntax same? I.e. type Action = String -> [String] -> IO [String]
07:06:34 <koeien37> yes
07:06:43 <koeien37> that would be correct
07:07:20 <i_am_neuron> I see. That's exactly what I needed, the constructor in the definition of Action confused me since the very beginning
07:08:36 <i_am_neuron> This helped, thanks!
07:09:47 <poe> LouisJB works for me
07:10:07 <poe> LouisJB actually, after a little patch to a script, it's on the haskell wiki
07:12:28 <benmachine> @src find
07:12:29 <lambdabot> find p          = listToMaybe . filter p
07:13:19 <Jafet> @src listToMaybe
07:13:20 <lambdabot> listToMaybe []        =  Nothing
07:13:21 <lambdabot> listToMaybe (a:_)     =  Just a
07:15:46 <cnwdup> @hoogle [Either a b] -> Either [a] b
07:15:47 <lambdabot> No results found
07:18:20 <LouisJB> poe: ok thanks, so I need to patch something once installed right? I'll see if I can find details on the site
07:27:45 <rasfar> @hoogle Monad m => [m a b] -> m [a] b
07:27:47 <lambdabot> No results found
07:28:29 <koeien37> rasfar, monads are * -> *, not * -> * -> *
07:29:33 <wjt> so. i seem to have both monads-fd and mtl installed, which means I can't :m +Control.Monad.Writer in ghci. Is there a better way to get around this than hiding one of the packages with ghc-pkg?
07:29:34 <rasfar> oops. :)
07:29:42 <Baughn> wjt: No. ;)
07:29:45 <wjt> boo :(
07:29:53 <skorpan`> wtf hoogle is down again?
07:29:56 <Baughn> Hiding one should be fine. Cabal doesn't care.
07:30:07 <Baughn> wjt: Actually, try ghci -package mtl, see what happens
07:30:21 <Baughn> wjt: Or maybe -hide mtl, though I've never tried that
07:30:47 <wjt> nah, the former doesn't make it prefer mtl, and the latter fails
07:30:49 <dcoutts> -hide-package
07:30:59 * hackagebot upload: hasktags 0.68 - Produces ctags "tags" and etags "TAGS" files for Haskell programs (MarcWeber)
07:31:48 <wjt> Hmm, I guess I could put -hide-package in my ~/.ghci
07:32:17 <wjt> that works! thanks Baughn and dcoutts :)
07:34:01 <skorpan`> @type intersperse
07:34:03 <lambdabot> forall a. a -> [a] -> [a]
07:35:03 <Baughn> skorpan`: And for this reason, I've cabal install hoogle'd.
07:50:26 <ManateeLazyCat> mmorrow: Hi
07:57:06 <Reshure> Could someone explain LYAH -> Chapter 4 -> Where!? -> code sample 4 to me? I don't get why skinny, normal and fat match to the (skinny, normal, fat) tuple.
07:58:29 <mauke> why not?
07:59:06 <Reshure> Why does skinny match to (skinny, normal, fat)? Skinny isn't a tuple..
07:59:36 <BONUS> um
07:59:51 <BONUS> it says (skinny, normal, fat) = (18.5, 25.0, 30.0), right?
07:59:57 <Reshure> Yes.
08:00:21 <BONUS> (skinny, normal, fat) is a tuple (well, a triple)
08:00:27 <BONUS> and so is (18.5, 25.0, 30.0)
08:01:17 <Reshure> So, that assigns skinny to 18.5, normal to 25.0 and 30.0?
08:01:22 <Reshure> fat to 30.0*
08:01:25 <BONUS> > let (a,b,c,d) = (1,"hey",'c',True) in [d,c,b,a]
08:01:26 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:01:26 <lambdabot>         against inferred type ...
08:01:34 <BONUS> whoops no i mean
08:01:38 <BONUS> > let (a,b,c,d) = (1,"hey",'c',True) in (d,c,b,a)
08:01:39 <lambdabot>   (True,'c',"hey",1)
08:01:40 <BONUS> yeah
08:01:57 <Reshure> Ok, I think I understand. Thanks :)
08:01:57 <BONUS> just like say a = (1,2)
08:02:00 <BONUS> and then you do
08:02:01 <BONUS> (c,d) = a
08:02:10 <BONUS> to pattern match on the construction of a
08:02:15 <BONUS> you can just let go of the intermediate step
08:02:19 <BONUS> and just do (c,d) = (1,2).
08:02:21 <BONUS> ah cool :D
08:03:56 <Polarina> BONUS: :)
08:05:41 <orbitz> BONUS: Don't forget (,) x y = a
08:05:58 <BONUS> of course!
08:06:01 <orbitz> haha
08:06:19 <orbitz> AFAIK though, (,) is not an actual function but it is a special case offered by the compiler. is that correct?
08:06:33 <BONUS> how would you define actual function?
08:06:34 <Polarina> @src (,)
08:06:34 <lambdabot> Source not found. That's something I cannot allow to happen.
08:06:36 <BONUS> :t (,)
08:06:37 <lambdabot> forall a b. a -> b -> (a, b)
08:06:40 <BONUS> it has a type and everything
08:06:44 <BONUS> with -> in it
08:06:47 <mauke> you can't define it yourself
08:06:50 <BONUS> it's a constructor function
08:06:51 <mauke> it has special calling syntax
08:06:56 <BONUS> oh well yeah
08:06:58 <mauke> you can't sect it
08:07:05 <BONUS> yet :)
08:07:06 <orbitz> sect?
08:07:13 <Polarina> Haha!
08:07:21 <BONUS> i think you'll be able to in 6.12
08:07:24 <BONUS> to do (,2) 3
08:07:27 <BONUS> and get (3,2)
08:07:33 <orbitz> ahh
08:07:40 <orbitz> sextual
08:07:49 <BONUS> yeah it's one of those things, like the list syntax
08:07:50 <orbitz> anyone read http://blog.sigfpe.com/2009/11/programming-with-impossible-functions.html
08:08:02 <orbitz> it sounds like it's basically implemented a limited monad in that
08:08:05 <BONUS> i'm reading it now actually. mind = blon
08:08:09 <BONUS> blown*
08:08:36 <orbitz> I have to read it more thoroughly then
08:10:26 * orbitz wanders away naked
08:11:30 * Jafet engages pants
08:11:32 <elly> :O public nudity?
08:12:21 <Jafet> The talk about "interpreter" sounds like the existing denotational semantics, for sure
08:13:17 <mauke> read_example1 looks exactly like monads
08:19:45 <BONUS> looks like CPS to me
08:19:55 <BONUS> (which looks like monads, hehe)
08:20:07 <mauke> yes
08:20:20 <mauke> >>= is all about continuations
08:20:33 * Baughn gets lost in a maze of monad transformers, all alike
08:20:45 <Baughn> ..should I be using mtl, transformers, monads-tf, monads-fd, /what/?
08:21:07 <BONUS> i find mtl good(?)
08:21:25 <Baughn> Well, it'd deprecated though
08:21:28 <Baughn> *it's
08:22:09 <BONUS> oh, is it?
08:22:21 <Baughn> Mm. See discussion on haskell-cafe right about now
08:23:19 <i_am_neuron> Folks, I have a function of type IO String, which is called from the function of type IO [String]. The purpose of the second one is to collect non-empty strings returned after invocations to several functions of the first type. Sometimes I have to write something like 'do failed <- f x y return [failed]' (with appropriate newlines). This looks ugly to me. Is there a better way?
08:24:06 <BONUS> fmap (:[]) (f x y)
08:24:09 <benmachine> @undo do { failed <- f x y; return failed }
08:24:10 <lambdabot> f x y >>= \ failed -> return failed
08:24:19 <benmachine> oops
08:24:23 <benmachine> @undo do { failed <- f x y; return [failed] }
08:24:24 <lambdabot> f x y >>= \ failed -> return [failed]
08:24:34 <benmachine> @pl f x y >>= \ failed -> return [failed]
08:24:35 <lambdabot> return `fmap` f x y
08:24:52 <benmachine> (:[]) is probably better than return
08:25:01 <BONUS> or if you import Control.Arrow then you can do: (:[]) <$> f x y
08:25:08 <benmachine> Control.Applicative
08:25:17 <mauke> pure . f x y
08:25:23 * mauke runs away
08:25:25 <benmachine> heh
08:25:31 <benmachine> :t (.)
08:25:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:25:40 <i_am_neuron> Looks great, thanks guys!
08:25:45 <Jafet> :t pure
08:25:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:25:52 <Jafet> Hah
08:25:54 <Baughn> @unmtl ReaderT AESCtx (WriterT BL.ByteString (ST s (BL.ByteString,a)))
08:25:54 <lambdabot> err: `ReaderT AESCtx (WriterT BL.ByteString (ST s (BL.ByteString, a)))' is not applied to enough arguments, giving `/\A. AESCtx -> ST s (BL.ByteString, a) (A, BL.ByteString)'
08:26:29 <Baughn> @unmtl ReaderT AESCtx (WriterT BL.ByteString (ST s) (BL.ByteString,a)
08:26:30 <lambdabot> err: Parse error
08:26:40 <Baughn> @unmtl ReaderT AESCtx (WriterT BL.ByteString (ST s)) (BL.ByteString,a)
08:26:40 <lambdabot> AESCtx -> ST s (BL.ByteString, a, BL.ByteString)
08:26:52 <Baughn> @unmtl ReaderT AESCtx (WriterT BL.ByteString (ST s)) a
08:26:52 <lambdabot> AESCtx -> ST s (a, BL.ByteString)
08:26:58 <Baughn> ..phew
08:30:59 <Baughn> ..ah, hell. MonadReader includes the ((->) r) monad.
08:31:16 <Twey> Of course?
08:31:46 <Twey> ((->) r) is the Reader monad whose functionality MonadReader attempts to abstract :þ
08:33:43 <Baughn> Twey: Yeah, but actually /having/ that monad as an instance tends to mess up type errors /all over the place/
08:34:19 <Twey> Hehe
08:35:58 <Berengal> Sometimes I wish we had more control over the compile-time environment...
08:36:28 <Berengal> Such as for example removing instances
08:36:34 <Twey> Mm
08:36:45 <Twey> Or just first-class instances in general
08:36:54 <Berengal> Records you mean?
08:41:03 <Twey> Er, no
08:42:42 <Berengal> Then what?
08:43:30 <Berengal> Because type classes look to me very much like compiler-assisted record-passing
08:46:59 <Twey> Berengal: I don't object to instances implemented as first-class records, but that's only one way of achieving the relevant change, which was first-class instances in general
08:47:44 <Berengal> Right
08:55:05 * shepheb re-reads WhyFP
08:56:30 <LouisJB> poe: I'm seeing compilation failures starting with "suffix or operands invalid for `push'" and a whole load more, is that to do with the script you mention? Trying to find on wiki what to patch but not sure what I'm looking for
08:58:15 <benmachine> I'm getting Network.Browser crashing because
08:58:19 <benmachine> *** Exception: debug.log-login.facebook.com: openFile: resource busy (file is locked)
08:58:42 <benmachine> it may be that it is trying to create a new connection when one already exists
08:58:46 <benmachine> I am not sure why it is doing that
08:58:54 <benmachine> I'd paste the logs but they may be sensitive
08:59:03 <benmachine> could alternatively paste the program
09:00:15 <benmachine> hmm it is in two files hmm
09:01:24 <skorpan`> @hoogle u -> Parsec a u ()
09:01:25 <lambdabot> No results found
09:01:30 <skorpan`> @type modifyState
09:01:31 <lambdabot> Not in scope: `modifyState'
09:01:37 <skorpan`> aha...
09:01:47 <benmachine> are you trying to find setState
09:01:52 <skorpan`> yes, that's it
09:01:53 <skorpan`> thanks
09:08:51 <LouisJB> just installed 6.10.4 of GHC but when I make a simple program I get errors like "suffix or operands invalid for `push'" - the platform is 64bit and I'm running on OSX 10.6.2, any ideas on it
09:11:26 <copumpkin> LouisJB: it's all over google
09:11:59 <LouisJB> I've found stuff about passing 32 bit flag to gcc, that's the solution right?
09:12:07 <copumpkin> basically, yeah
09:12:10 <copumpkin> a couple of other flags too
09:12:16 <copumpkin> LouisJB: http://obvioushints.blogspot.com/2009/09/running-haskell-ghc-on-snow-leopard.html
09:12:55 <wzp> i have some problems understanding these two lines of code
09:12:56 <wzp>    1. applyTwice :: (a -> a) -> a -> a
09:12:57 <wzp>    2. applyTwice f x = f (f x)
09:13:03 <LouisJB> ahhh great, that's exactly my issue - thanks!
09:13:07 <copumpkin> Veinor: yo yo! you're in boston aren't you? why didn't you go to the boston HUG last week?!?!
09:13:09 <maurer_> Just curiosity, what's causing the 32/64 bit issue in Snow Leapord?
09:13:23 <Baughn> p_l: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13353 <-- Does this use of Writer look right to you? No horrible stack overflows lurking in my future?
09:13:30 <Baughn> Er. s/p_l: //
09:13:32 <maurer_> wzp: What doesn't make sense?
09:13:35 <Megant> wzp: well, applyTwice applies the function twice
09:13:56 <wzp> doesn't it recurse 'till the end of time ?
09:14:05 <copumpkin> nope
09:14:08 <Megant> it doesn't call applyTwice but f
09:14:09 <copumpkin> it doesn't ever call itself
09:14:17 <maurer_> >let applyTwice f x = f (f x)
09:14:18 <MarcWeber> Can cabal or another tool create a basic project setup such as writing a .cabal file and creating src/Main.hs ?
09:14:27 <maurer_> >applyTwice (+1) 2
09:14:45 <copumpkin> @let applyTwice f x = f (f x)
09:14:47 <lambdabot>  Defined.
09:14:50 <copumpkin> > applyTwice (+1) 2
09:14:52 <lambdabot>   4
09:14:58 <wzp> copumpkin: doesn't it ? i can see a couple of f's there
09:15:09 <copumpkin> f is an argument
09:15:14 <copumpkin> applyTwice is the function itself
09:15:31 <wzp> shitwad, true
09:15:33 <maurer_> copumpkin: Oops, thanks, didn't realize the space was needed, or that let needed to be separated.
09:16:28 <wzp> okay thanks i got i now, stupid me
09:18:27 <maurer_> wzp: Now try
09:18:28 <maurer_> fix f = f (fix f)
09:18:30 <Twey> applyTwice = join (.)
09:18:33 <Twey> >.>
09:18:36 <poe> MarcWeber there is one already
09:19:12 <poe> ?hackage mkcabal
09:19:12 <lambdabot> http://hackage.haskell.org/package/mkcabal
09:20:35 <maurer_> Does whoever is running the hoogle page know that it is spitting out internal server errors? http://haskell.org/hoogle/
09:21:01 <LouisJB> copumpkin: it's working now - thanks
09:30:40 <skorpan`> for some reason the functions i write lately have been returning the result in backwards order...
09:30:56 <skorpan`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13354#a13354
09:31:46 <skorpan`> oh, heh... never mind
09:37:56 <skorpan`> > [1..10] \\ [1..5]
09:37:57 <lambdabot>   [6,7,8,9,10]
09:38:19 <skorpan`> > [1..10] Data.Lst.\\ [1..5]
09:38:21 <lambdabot>   Not in scope: `Data.Lst.\\'
09:38:23 <skorpan`> > [1..10] Data.List.\\ [1..5]
09:38:24 <lambdabot>   [6,7,8,9,10]
09:38:56 <skorpan`> > ['a'..'z'] \\ "aoeui"
09:38:58 <lambdabot>   "bcdfghjklmnpqrstvwxyz"
09:41:46 <rwx> @src Data.List.\\
09:41:46 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:43:05 <maurer_> @src \\
09:43:06 <lambdabot> (\\) = foldl (flip delete)
09:45:10 <centrinia> @src delete
09:45:10 <lambdabot> delete = deleteBy (==)
09:45:15 <centrinia> @src deleteBy
09:45:15 <lambdabot> deleteBy eq x []        = []
09:45:15 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
09:46:29 <Cale> rwx: The @src command just looks things up in a text file. It doesn't actually know where in the libraries the definitions come from (and many are the Report's definitions rather than the GHC ones)
09:46:40 <rwx> Cale, cheers
09:46:52 <Veinor> copumpkin: an annoying thing called 'school'
09:47:03 <copumpkin> Veinor: it was in the evening! and a couple of days before thanksgiving!!
09:47:08 <dcoutts> MarcWeber: yes, the new cabal init in cabal-install version 0.8+
09:47:09 <atp> hi all, quick parsec question: i'm implementing a simple grep like search through a file.  i have a parser that matches the line that i want and extracts the data i need from it.  i want to walk through every line in the file, trying this parser, and on failure simply advancing to the next line and trying again.  if i use something like try won't i be incurring a lookahead penalty unnecessarily?  i don't mind if the parser consumes input, because i'm just
09:47:19 <atp> the reason i'm concerned about this is because the file is quite large
09:47:30 <rwx> regarding accumulator variables: i'm used to having an acc variable, e.g. as is idiomatic in scheme. is the haskell idiom to use zippers and folds?
09:49:07 <EnglishGent> hello :)
09:49:19 <Saizan> atp: why would you use try?
09:49:33 <c_wraith> rwx: accumulators are common enough in haskell code.  Just so long as they aren't mutable
09:49:46 <CalJohn> rwx: the idiom is primarily to use folds, but the state monad is also applicable
09:50:05 <Saizan> rwx: where we can we try to exploit laziness and avoid what looks like tail recursion
09:50:09 <atp> saizan: well, because the parser will fail on most lines (every line, really) until it reaches the line it wants
09:50:16 <atp> Saizan: but i don't want parsing to stop
09:50:31 <Saizan> rwx: though when tail recursion is useful you should probably make sure you're strict in your accumulator
09:50:35 <c_wraith> atp:  that doesn't mean "use try".
09:51:18 <atp> c_wraith: good, what's the alternative?  <|> requires that the parser consume no input before failing, mine won't
09:51:50 <Saizan> you don't really want to backtrack, you want to go to the next line, no?
09:52:00 <atp> Saizan: yes, exactly
09:52:25 <c_wraith> atp: Oh, right.  The reasons I quit using parsec.  Anyway, there are a couple good approaches.  one is to just run the parser on each line.
09:52:50 <benmachine> map parse . lines $ input
09:53:04 <benmachine> hello I have an unrelated question
09:53:26 <atp> that would be exceptionally slow it seems to me
09:53:42 <benmachine> there was what I thought was a bug in a library I used so I downloaded the source and fiddled with it
09:53:54 <c_wraith> Why would you think that would be slow?
09:53:59 <benmachine> how do I test it without installing it
09:54:20 <c_wraith> It does end up copying the entire input, but it does it efficiently
09:54:22 <rwx> c_wraith / CalJohn / Saizan : is it perceived as ugly to have a function f, with an f' defined inside it, that holds the accumulator? i find i feel like that i'm missing the point when i do something like that
09:54:29 <benmachine> I have .o and .a here but I can't work out how to make ghci load them instead of the system version of the same
09:54:32 <c_wraith> rwx: no, that's common
09:54:58 <atp> c_wraith: because it builds the initial parser state again and again only to discard it
09:55:22 <c_wraith> atp:  the parser state is just a function.
09:55:25 <benmachine> don't think building a parser is actually that much overhead
09:55:27 <atp> rwx: lots of haskellers call that function go (i think dons started that)
09:55:30 <benmachine> you can try it and see though
09:56:04 <atp> c_wraith: yes, i realize that.
09:56:15 <Saizan> atp: i'd make your parser not fail at all, but rather return a Maybe, and in case of Nothing i'll consume the chars until the next line and start again
09:56:55 <atp> Saizan: yeah, i thought about that... maybe I'll give it a try. (ha ha)
09:57:18 <Saizan> benmachine: you can install --inplace
09:57:25 <jkff> Holy sh*t, existentials can encode universals.
09:57:28 <jkff> @google Ken-etsu Fujita: Galois Embedding from Polymorphic Types into Existential Types.
09:57:29 <lambdabot> No Result Found.
09:58:00 <jkff> http://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1442-8.pdf
09:58:03 <jkff> I haven't read it yet, though.
09:58:04 <benmachine> Saizan: interesting
09:58:33 <benmachine> ohh, this is redirect looping because facebook wants to make me use https
09:58:51 <copumpkin> Veinor: you should go to the next one!
09:58:59 <jkff> However, the paper talks not just about a System F with existentials or something, but rather about a quite different logic that also has other differences from F other than replacing \forall with \exists.
09:59:04 <Saizan> benmachine: and you can also specify a custom package db, though you've to point ghci to it too
09:59:06 <benmachine> so it is 302ing me to https:// but I think Network.Browser just uses http:// regardless
09:59:41 <benmachine> I guess Network.Browser doesn't support HTTPS?
10:00:15 <benmachine> what's SSL support in Haskell like?
10:09:27 <dankna> benmachine: hs-gnutls works fine
10:09:52 <dankna> benmachine: it's low-level but if you're doing SSL stuff you want it to be
10:10:51 <benmachine> dankna: okay I'll take a look, thanks
10:11:08 <dankna> sure
10:13:19 <rwx> or i could just use folds to make it work, anyway :D
10:14:08 <Saizan> rwx: if you're recursing over lists you can use foldl'
10:14:47 <rwx> Saizan, why strict?
10:15:59 <Saizan> if you use a lazy accumulator you're going to accumulate and huge thunk and get a stack overflow when you later force it
10:17:00 <rwx> Saizan, right--thanks!
10:17:26 <poe> Is there a parser for wikipedia page sources in Haskell already?
10:17:53 <rwx> hoogle is down :-(
10:18:18 <copumpkin> just use @hoogle
10:18:33 <shambler> erm
10:18:37 <shambler> @hoogle map
10:18:38 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:18:38 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
10:18:38 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
10:18:41 <shambler> oh cool
10:18:49 <copumpkin> @hoogle (a -> b) -> [a] -> [b]
10:18:50 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:18:50 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
10:18:50 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
10:23:15 <EnglishGent> how is parmap different from map?
10:23:49 <copumpkin> it maps in parallel, using a particular strategy
10:24:17 <EnglishGent> what's a stratergy? (map seems particularly parallisable to me - especially in a pure functional setting)
10:24:24 <copumpkin> yeah, it is
10:25:01 <copumpkin> a strategy tells it whether you want to reduce to whnf, or nf, or something like that. It also governs whether you want to chunk the list into big chunks, or evaluate individual elements in parallel, and so on
10:25:08 <wzp> i still have a little question about this code: applyTwice f x = f (f x)
10:25:18 <copumpkin> wzp: sure, what is it?
10:25:18 <wzp> does x contain all the arguments ?
10:25:31 <wzp> of the function f
10:25:37 <copumpkin> contain?
10:25:39 <copumpkin> how do you mean?
10:25:52 <copumpkin> :t applyTwice
10:25:53 <lambdabot> forall t. (t -> t) -> t -> t
10:26:12 <wzp> ok i'll put it another way
10:26:14 <wzp> what's x ?
10:26:51 <wzp> doesn't it hold the arguments(s ?) ?
10:27:02 <copumpkin> x is an element of type t
10:27:21 <copumpkin> not really sure what you're asking, still
10:27:31 <wzp> okay, but what is it used for, in that function ?
10:27:44 <copumpkin> it is passed to the function f
10:28:26 <wzp> and it is supposed to hold what ? the first argument of the function f ?
10:28:48 <Botje> wzp: because of the way applyTwice is constructed, f can only take one argument.
10:29:23 <Twey> (but that's okay, because all functions only take one argument anyway)
10:29:57 <wzp> Botje: ok that's what i wanted to know
10:30:12 <wzp> well all this is pretty confusing
10:30:24 <Twey> wzp: applyTwice (+) 3 = (+) ((+) 3) = (+) (+ 3) = (+ (+ 3))
10:30:56 <int-e> that won't type check
10:31:10 <copumpkin> :t applyTwice (+) 3
10:31:11 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t
10:31:11 <lambdabot>     Probable cause: `+' is applied to too few arguments
10:31:11 <lambdabot>     In the first argument of `applyTwice', namely `(+)'
10:31:15 <copumpkin> zomg!
10:31:17 <EnglishGent> klingon(x) -- a function taking one argument _that always wins it_
10:31:18 <EnglishGent> :)
10:31:24 <copumpkin> :t applyTwice (+) ?moo
10:31:25 <Twey> Hahaha
10:31:25 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t
10:31:25 <lambdabot>     Probable cause: `+' is applied to too few arguments
10:31:25 <lambdabot>     In the first argument of `applyTwice', namely `(+)'
10:31:30 <int-e> klingon(borg)
10:31:44 <Twey> int-e: Yeah.  I was just giving an example, because sections are nice for illustration of such things.
10:32:20 <int-e> applyTwice (1+) 3 = (1+) ((1+) 3) = 1 + (1 + 3)
10:32:33 <Twey> Fine, fine :þ
10:36:28 <EnglishGent> hmm - what's an *elegant* way to reduce all runs of more than 1 space in a string to exactly 1 space? in Haskell that is
10:36:50 <Saizan> unwords . words
10:36:52 * EnglishGent can think of ways to do it - but if sure this ought to be some neat 1-liner given all the hofs
10:37:08 <EnglishGent> ah - ty! :)
10:38:58 <bfh6558_> this is the room for the haskell language right?
10:39:02 <EnglishGent> what about generalising that to reducing runs to one element in general?
10:39:04 <Twey> Why yes
10:39:06 <EnglishGent> yes bfh6558_
10:39:06 <Twey> I do believe it is
10:39:09 <bfh6558_> thanks twey
10:39:16 <bfh6558_> and gent
10:39:31 * EnglishGent was sort of looking for something clever with hofs or fold or similar
10:39:38 <Jedai> EnglishGent: A foldr can do that pretty cleanly
10:39:41 <Twey> It's also possible that we're a fan-club for the Haskell Indian Nations University
10:39:43 <copumpkin> EnglishGent: so reducing any repeated element to a single element?
10:39:46 <EnglishGent> though I admit your solution solves my practical problem very nicely Saizan :)
10:39:46 <wzp> damn, it was hard, but now i finally understand f (f x)
10:39:52 <Twey> And I've been horrendously off-topic this whole time
10:40:17 <copumpkin> :t map head . group
10:40:18 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:40:36 <EnglishGent> copumpkin - reducing runs of elements satisfying some predicate say?
10:40:37 <copumpkin> > map head . group $ [1,1,1,2,2,6,2,2,4,1,1,8,3]
10:40:38 <lambdabot>   [1,2,6,2,4,1,8,3]
10:41:02 * EnglishGent adds 'group' to the his mental list of useful Haskell building blocks
10:41:03 <copumpkin> encode your predicate in groupBy instead of  group
10:41:06 <Twey> EnglishGent: groupBy
10:41:08 <Kyssan> hello! Is there some neat way to convert an [IO()] into an IO() ?   ... I'm doing `foldr (>>) (return())`  ... which I am not sure is either straight-forward to read not efficient
10:41:18 <Twey> Kyssan: mapM_
10:41:18 <copumpkin> although groupBy's parameter is a little more painful
10:41:20 <Jedai> > let reduce e = foldr (\x xs -> if x == e then (if null xs or head xs /= e then x:xs else xs) else x:xs) []
10:41:21 <lambdabot>   not an expression: `let reduce e = foldr (\x xs -> if x == e then (if null ...
10:41:27 <Twey> :t mapM_
10:41:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:41:35 <copumpkin> sequence_
10:41:35 <Twey> Oh, sorry
10:41:37 <Twey> sequence_
10:41:38 <Twey> Yeah
10:41:41 <Twey> :t sequence_
10:41:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:42:02 <copumpkin> or mapM_ id ;)
10:42:05 <Twey> @src sequence_
10:42:05 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:42:07 <Jedai> > let reduce e = foldr (\x xs -> if x == e then (if null xs or head xs /= e then x:xs else xs) else x:xs) [] in reduce 1 [1,1,1,2,2,6,2,2,4,1,1,8,3]
10:42:08 <lambdabot>   Couldn't match expected type `([GHC.Bool.Bool] -> GHC.Bool.Bool)
10:42:08 <lambdabot>           ...
10:42:08 <copumpkin> oh actually
10:42:10 <Twey> Ahh.
10:42:11 <copumpkin> mapM_ return
10:42:17 <Twey> @src sequence
10:42:17 <lambdabot> sequence []     = return []
10:42:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:42:17 <lambdabot> --OR
10:42:17 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:42:38 <Twey> :t mapM_ return
10:42:40 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m ()
10:42:44 <bfh6558_> this may be offtopic but is anyone using ghc on os x here?
10:42:45 <copumpkin> oh fail
10:42:45 <Twey> Not quite
10:42:49 <copumpkin> so it was mapM_ id
10:42:53 <copumpkin> :t mapM_ id
10:42:54 <Twey> Yeah
10:42:54 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m ()
10:43:00 <Twey> A.K.A. sequence_ :þ
10:43:11 <copumpkin> yep A.K.A. mapM_ id
10:43:13 <copumpkin> ;)
10:43:14 <Kyssan> confused: is it forall, sequence_ or mapM_ ?
10:44:02 <Kyssan> bfh6558: I am.. on snow leopard (a bit of a pain to get everything -- including cabal) to work
10:44:02 <Jedai> > let reduce e = foldr (\x xs -> if x == e then (if null xs || head xs /= e then x:xs else xs) else x:xs) [] in reduce 1 [1,1,1,2,2,6,2,2,4,1,1,8,3]
10:44:04 <lambdabot>   [1,2,2,6,2,2,4,1,8,3]
10:44:27 <Jedai> EnglishGent: if you want to reduce the run of one particular element
10:44:33 <Saizan> Kyssan: sequence_
10:44:45 <EnglishGent> ty all :)
10:45:01 <Saizan> Kyssan: which is just defined ad foldr (>>) (return ()), anyway
10:45:09 <Kyssan> ahh ok :D cool
10:45:17 <Saizan> forall is a keyword
10:46:27 <Twey> Kyssan: What's that nick?  Finnish?
10:46:40 <Twey> It's pretty
10:46:56 <Kyssan> no.. it's made up on the spot
10:47:01 <Twey> Ah ☺
10:47:33 <Jedai> let reduce e = map head . groupBy (\a b -> a == e && b == e) in reduce 1 [1,1,1,2,2,6,2,2,4,1,1,8,3]
10:47:38 <Jedai> > let reduce e = map head . groupBy (\a b -> a == e && b == e) in reduce 1 [1,1,1,2,2,6,2,2,4,1,1,8,3]
10:47:40 <lambdabot>   [1,2,2,6,2,2,4,1,8,3]
10:49:02 <Jedai> > let reduce e = foldr (\x xs -> if x == e && not (null xs || head xs /= e) then xs else x:xs) [] in reduce 1 [1,1,1,2,2,6,2,2,4,1,1,8,3]
10:49:03 <lambdabot>   [1,2,2,6,2,2,4,1,8,3]
10:50:09 <EnglishGent> @hoogle Char -> Char
10:50:10 <lambdabot> Data.Char toLower :: Char -> Char
10:50:10 <lambdabot> Data.Char toTitle :: Char -> Char
10:50:10 <lambdabot> Data.Char toUpper :: Char -> Char
10:55:34 <EnglishGent> hmm - why does 'unwords $ words "hello world"' work, but let 'clean = unwords $ words' gives a type error?
10:55:58 * EnglishGent not much experience with points-free style
10:56:01 <luite> EnglishGent: try clean = unwords.words instead, it's function composition you're looking for, not application
10:56:16 <EnglishGent> if I add a parameter - it's happy
10:56:27 <copumpkin> @src ($)
10:56:28 <lambdabot> f $ x = f x
10:56:38 <copumpkin> if you write unwords $ words, it means unwords words
10:56:42 <copumpkin> :t unwords
10:56:43 <lambdabot> [String] -> String
10:56:49 <copumpkin> is words a [String]?
10:57:12 <mmx166mhz> hello pumpkin
10:57:14 <rwx> EnglishGent, you can think of $ as just adding a set of parens
10:57:18 <EnglishGent> no - it's a [Char]
10:57:18 <copumpkin> allo mmx166mhz
10:57:27 <copumpkin> EnglishGent: nope, it's a function
10:57:32 <copumpkin> :t words
10:57:34 <lambdabot> String -> [String]
10:58:07 <copumpkin> granted, it's a function that outputs a [String], but if you write unwords words, it has no chance to produce its output
10:58:34 <mmx166mhz> Can someone help me with IO: I can work with it,  but dont understand it.. E.G: What is return good for?
10:59:05 <EnglishGent> mmx166mhz - producing a value of IO (in the case of the IO monad)
10:59:05 <copumpkin> most of the time you shouldn't really need it, but it helps if a function expects an IO a and you only have an a
10:59:25 <Kyssan> EnglishGent: as far as I can tell, $ is only there to remove clutter.  a $ b $ c $ d $ e f  is the same as: a(b(c(d(e f))))   which is the same as: (a.b.c.d.e) f
10:59:35 <gwern> Kyssan: that's right
10:59:37 <FunctorSalad> it makes a bogus IO action which doesn't actually do any IO
10:59:46 <FunctorSalad> instead it returns the value you gave
10:59:51 <mmx166mhz> hmm, ok: So return basically makes IO a out of a ?
10:59:55 <copumpkin> yep
10:59:59 <copumpkin> in the most obvious way
11:00:10 <gwern> Kyssan: haskellers like pretty syntax; it may not be a good situation to have so many ways to express function application tho
11:00:16 <copumpkin> an IO a that when run, provides a value of a
11:00:30 <EnglishGent> yes mmx166mhz
11:00:34 <mmx166mhz> Can someone explain the meaning of ":t return" ?
11:00:53 <EnglishGent> it asks the haskell runtime system what the type of return is
11:00:58 <copumpkin> :t return
11:00:59 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:01:04 <EnglishGent> in general :t <expression> tells you the type of the expression
11:01:09 <stoop> preflex, seen edwardk
11:01:09 <mmx166mhz> I know that
11:01:10 <preflex>  edwardk was last seen on #haskell 4 days, 22 hours, 50 minutes and 54 seconds ago, saying: cale: what i currently do is i allow do foo; bar; baz on one line, but in essence with my layout if you break it across multiple lines (and need indentation control) you need to move it down, since i don't know that the width of space, d, and o are the same.
11:01:11 <EnglishGent> but :t is *not* part of the language itself
11:01:11 <copumpkin> ignore the first bit
11:01:13 <copumpkin> (Monad m) => a -> m a
11:01:39 <mmx166mhz> but in this case: IO=the monad m
11:01:39 <mmx166mhz> ?
11:01:43 <EnglishGent> yes :)
11:01:47 <Kyssan> gwern: I like it.. and always define anotherone : a |> b = b a    .... which I find very natural   ... somelist |> map (..) |> filter (...) |> group (...) |> concat
11:02:04 <EnglishGent> there are other instances of the Monad class
11:02:12 <gwern> Kyssan: there should be one way to do something, usually
11:02:12 <rwx> does anyone know of any good docs to learn ruby, from a functional programming POV?
11:02:20 <rwx> i.e. without all the boilerplate crap
11:02:37 <PeakerWork> Kyssan: why not use >>> ?
11:03:10 <EnglishGent> @hoogle (>>>)
11:03:11 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
11:03:11 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
11:04:01 <EnglishGent> wouldnt that conflict? or is that compatible?
11:04:05 <Kyssan> because then I need to flip stuff around: (map (..) >>> filter (...) >>> group (...) >>> concat) somelist
11:04:11 * EnglishGent was fairly sure he'd seen >>> already defined somewhere
11:04:31 <Kyssan> I don't like the extra parentheses
11:04:40 <aavogt> > ((+2) >>> (*2)) 100
11:04:40 <copumpkin> Control.Arrow just re-exports the Category one
11:04:41 <lambdabot>   204
11:05:22 <aavogt> Kyssan: what do you do to make group take 2 arguments?
11:05:38 <FunctorSalad> @ty group
11:05:39 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
11:05:40 <copumpkin> > runKleisli (Kleisli (+) >>> Kleisli (*)) 100 100
11:05:41 <lambdabot>   20000
11:06:25 <PeakerWork> Kyssan: you can use $ instead of parens
11:06:57 <mmx166mhz> Is it true that you you van use $ for . ?
11:07:04 <FunctorSalad> no
11:07:06 <copumpkin> yes, unfortunately, in some situations
11:07:07 <FunctorSalad> ;)
11:07:14 <copumpkin> well, "yes and no"
11:07:14 <mmx166mhz> hmm :)
11:07:19 <Kyssan> aavogt: sorry.. I meant `groupBy`
11:07:25 <FunctorSalad> yes, in some contexts you can replace $ by .
11:07:34 <FunctorSalad> foo $ bar $ zonk $ 2
11:07:37 <FunctorSalad> foo . bar . zonk $ 2
11:07:53 <aavogt> Kyssan: you're probably just using . then and accepting that you have to read right to left
11:08:02 <mmx166mhz> so if h x=f(g x) than h=f.g right? and h=f $ g x
11:08:26 <Kyssan> aavogt: I have the advantage that no one else has to read my code :-)
11:08:36 <aavogt> h x = f $ g x
11:08:42 <mmx166mhz> yea, typo
11:08:58 <aavogt> other than that typo, it's right mmx166mhz
11:09:10 <mmx166mhz> so basically the advantage of (.) is to avoid the extra "x"
11:09:47 <aavogt> and . is associative, while $ is not
11:10:10 <wzp> i don't get how compareHundred = compare 100 can accept an argument
11:10:11 <mmx166mhz> ok thanks
11:10:27 <BONUS> well, compare 100 can accept an argument, can't it?
11:10:33 <mmx166mhz> it is partially parametrized
11:10:41 <wzp> yeah
11:10:59 <wzp> but it most go through the compareHundred function first
11:11:00 <BONUS> compare 100 takes one argument
11:11:00 <mmx166mhz> so now you have a function of one paramter, instead of 2
11:11:01 <aavogt> so say functorsalad wants to use (bar . zonk) somewhere else, it's less convenient when defined using $
11:11:06 <roconnor> compare 100 returns a function
11:11:38 <roconnor> or more accurately (compare 100) denotes a function
11:11:54 <BONUS> > (compare 100) 20
11:11:55 <lambdabot>   GT
11:12:06 <roconnor> @type (compare 100)
11:12:08 <lambdabot> forall t. (Num t, Ord t) => t -> Ordering
11:12:41 <EnglishGent> Kyssan - but *you* will probably need to read your code -- later! :)
11:12:49 <wzp> but that's like reading backwards
11:13:39 <FunctorSalad> sometimes I do "(foo . bar . zonk) 2" too
11:13:49 <FunctorSalad> not sure which variant is more aesthetic
11:14:08 <Kyssan> EnglishGent: |> is very common in F# so I'm quite used to it.. it's also very similar to piping commands in unix.. I'm sure I will not have trouble
11:14:27 <dqd> Haskell is not a Lisp, we want to exterminate all that parenthesis.
11:14:27 <FunctorSalad> hmm |> is snoc for Data.Sequence in haskell :)
11:14:30 <dqd> Kill them all!
11:14:34 <FunctorSalad> @hoogle (|>)
11:14:34 <lambdabot> Data.Sequence (|>) :: Seq a -> a -> Seq a
11:14:35 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:14:35 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
11:15:06 <EnglishGent> Kyssan - actually it looks a nice operator - I like it!
11:15:27 * EnglishGent hopes you dont mind if he shamelessly steals the idea :)
11:16:00 <visualbasicgui> what exactly does "ghc6-doc" _do_?
11:16:05 <Kyssan> FunctorSalad: that's the trouble with operators... you quickly run out of them
11:16:05 <FunctorSalad> what is it?
11:16:10 <visualbasicgui> I know somewhere on my system is some documentation.
11:16:16 <FunctorSalad> (Kyssan's (|>))
11:16:16 <visualbasicgui> source code and stuff
11:16:21 <visualbasicgui> but how do i access it?
11:16:34 <aavogt> visualbasicgui: it's probably the ghc manual somewhere inside /usr/share/doc
11:16:46 <visualbasicgui> ah
11:17:03 <aavogt> there must be some way to query your package manager which files belong to a given package
11:17:16 <FunctorSalad> Kyssan: left-associtative flip ($) ?
11:17:27 <Kyssan> yes
11:17:34 <visualbasicgui> i wish
11:17:36 <FunctorSalad> hmm
11:17:58 <FunctorSalad> I decided to stick with right-to-left lest I can't read other people's math anymore
11:18:42 <monochrom> dpkg --listfiles ghc6-doc
11:18:51 <monochrom> oops wrong window
11:19:31 <Kyssan> |> is something I stole from F# and brought in because it makes it easy for me the lazy OOP programmer ..    object |> function   is very easy to think about .. "hello" |> map toUpper   reads a lot like "hello".toUpper()
11:19:35 <monochrom> file:///usr/share/doc/ghc6-doc/index.html  oops wrong window too
11:20:37 <Kyssan> ..and with this statement probably acquired enough negative karma that I should shut up for a while :-|
11:21:49 <FunctorSalad> it's alright :) though in my intuition "map" doesn't belong to the list
11:21:56 <cizra> Hmm, people use Eclipse to write Haskell?
11:22:18 <Kyssan> cizra: ther's EclipseFP if you want to try it out
11:22:31 <cizra> Is it any good?
11:22:53 <cizra> Well, I guess this is a dumb question to ask (=
11:23:12 <FunctorSalad> it exists, but not sure how many ppl use it
11:23:44 <Kyssan> I played around with it for a while, went back to screen and nano .. and wrote some syntax coloring for it
11:24:02 <Twey> Haha, nano?
11:24:48 <Kyssan> ooh yeah :D no other editor is simpler :-)
11:25:00 <monochrom> I know CS students who use nano throught their entire 4 years of education.
11:25:09 <Twey> Kyssan: Notepad is :þ
11:25:19 <copumpkin> ed!
11:25:20 <Kyssan> notepad doens't run over ssh
11:25:27 <Kyssan> ed is really hard to use
11:25:45 <cizra> Kyssan: Notepad + wine + X over network!
11:25:56 <monochrom> The programs they write show very chaotic indentation.
11:26:15 <Kyssan> monochrom: lecturer?
11:26:21 <monochrom> Students.
11:27:27 <Twey> monochrom: That was short for ‘are/were you a lecturer?’
11:27:31 <cizra> Uh. I want to try out test-driven Haskelling, but I'm kinda confused. Should I go with quickcheck, hunit, test-framework or what?
11:27:37 * Twey follows a career path as a translator.
11:27:55 <Twey> cizra: QuickCheck is for pure code, whereas HUnit is more general
11:28:02 <monochrom> I won't answer.
11:28:07 <Twey> The others… are new, and I don't know much about them :þ
11:28:12 <byorgey> and test-framework is for combining them.
11:28:23 <byorgey> cizra: start with QuickCheck.
11:28:34 <mmx166mhz> last question b4 i go: What is the use/intuition of sth like " IO(IO Int)"
11:28:36 <cizra> OK. So QuickCheck it is, since this thing I want to test is pure.
11:28:37 <blackh1> cizra: test-framework just allows you to easily run both HUnit and QuickCheck tests
11:28:46 <cizra> Okay, thanks!
11:31:10 <BONUS> mmx166mhz: an IO (IO Int) is an I/O action that, when performed, will yield another I/O action, that you can then perform to yield an Int
11:31:33 <bos> preflex: seen dons
11:31:34 <preflex>  dons was last seen on #haskell 14 hours, 44 minutes and 18 seconds ago, saying: sometimes we get wacky people
11:31:48 <mmorrow> mmx166mhz: imagine a parser that reads the header of a binary format, and the header of this format describes how to parse the rest of the file. then you could have a parser (for the header) that returns another parser as a result
11:31:57 <BONUS> as you can see, the nesting implies that they are sequential, so if you use join on that function (m (m a) -> m a), it will carry them out sequentially
11:33:06 <mmorrow> mmx166mhz: type Parser a = IO (Ptr Word8 -> Ofs -> (a, Ofs)); parseHeader :: Parser (Parser a)
11:33:13 <mmorrow> err
11:33:25 <mmorrow> type Parser a = Ptr Word8 -> Ofs -> IO (a, Ofs); parseHeader :: Parser (Parser a)
11:33:30 <FunctorSalad> mmx166mhz: a recipe on how to interact with the real world to make a recipe on how to interact with the real world to obtain an `a'
11:33:38 <float> getting a parser error with the where keyword http://pastebin.com/d54196c29
11:33:44 <FunctorSalad> err a=Int ;)
11:34:51 <FunctorSalad> mmorrow: heh Ptr Word8?
11:34:59 <FunctorSalad> parsing from memory?
11:35:17 <FunctorSalad> Ofs=Offset?
11:35:22 <Cale> float: tabs
11:35:40 <mmorrow> FunctorSalad: yeah, from the base memory addr
11:35:48 <mmorrow> which is the Ptr
11:36:07 <mmorrow> basically just a ByteString without the constructor
11:36:16 <Kyssan> float: you might need to go explicit there and add braces
11:36:17 <Cale> float: start by converting your tabs to spaces, and configuring your editor not to produce actual tab characters
11:36:20 <EnglishGent> @hoogle (Eq a) => [a] -> a -> Int
11:36:21 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:36:21 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
11:36:21 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
11:36:40 <FunctorSalad> mmorrow: is that used with mmap or something? *low-level linux noob*
11:36:50 <FunctorSalad> to parse from a file
11:38:06 <mmorrow> FunctorSalad: i guess it'd be useful if you wanted to parser anything you have a ptr to, but you can't or don't want to use the ByteString lib, or you need something that it doesn't provide
11:38:52 <mmorrow> like e.g. the ability to scan over, rewind, scan again, go forward, rewind, ... over mem a bunch or something
11:39:01 <bos> uh oh, stream fusion is biting me!
11:39:08 <FunctorSalad> nom nom nom
11:39:08 <copumpkin> oh no!
11:39:11 <mmorrow> ruhroh
11:39:16 <copumpkin> FunctorSalad: you missed the "om"
11:39:29 <FunctorSalad> copumpkin: I don't consider that canon
11:39:41 <copumpkin> it most certainly is
11:39:41 <bos> turns out my current implementation of Data.Text.concat is worse than quadratic in the number of elements to concat.
11:39:46 <bos> and i don't know how to fix it yet.
11:39:56 <bos> this will require actual thought. oh noes!
11:39:58 <copumpkin> bos: crap! maybe you can get inspiration from DPH?
11:40:03 <FunctorSalad> copumpkin: http://4.bp.blogspot.com/_Kac9jxGkbe4/SWnxD_Thm6I/AAAAAAAAASw/aLapUNF-LU8/s400/nom-nom-nom.jpg
11:40:16 <copumpkin> FunctorSalad: crap, proof by cute bunny. QED
11:40:22 * copumpkin concedes
11:40:24 <FunctorSalad> :D
11:40:31 <bos> copumpkin: alas, DPH doesn't have the same interface here.
11:40:39 <copumpkin> oh
11:40:44 * Saizan wonders what's the unicode for cute bunny
11:40:49 <bos> i think i might need to write a unfused concat.
11:40:51 <FunctorSalad> "inductive reasoning is invalid in general, unless a cute bunny is employed"
11:41:17 <FunctorSalad> (the empirical 'inductive', not the type-theoretical ;))
11:41:23 <orbitz> i like bunnies
11:41:38 <bfh6558_> orbitz: I've already been here lurking
11:41:43 <bos> the problem is that concat is basically (append a (append b (append c (append d empty))))
11:41:43 <mmorrow> bos: i guess you'd have to stick em in a Tree or Data.Sequence, then when you're ready to finally do the cat, bottom up compute the total size, allocate that much exactly, and do a bunch of memcpys?
11:41:44 <copumpkin> :O
11:41:51 <orbitz> bfh6558_: sicko
11:41:57 <bfh6558_> haha
11:41:58 <orbitz> hey copumpkin
11:42:11 <orbitz> copumpkin: AHHH I forgot to maek plans with you friday
11:42:15 <copumpkin> allo orbitz! sorry I didn't get in touch
11:42:16 <orbitz> copumpkin: i ended up falling asleep at an unholy hour
11:42:19 <copumpkin> yeah, I was really busy anyway :(
11:42:20 <FunctorSalad> bos: you don't mean quadratic in the total number of elements I suppose?
11:42:24 <bos> mmorrow: yes, that would work, but it's a little unhappy making.
11:42:33 <orbitz> copumpkin: well that owrks out. i take it you will no tbe coming back her eat any point in the near future though
11:42:33 <FunctorSalad> quadratic in "n" where you have n lists of n elements each? bos
11:42:34 <bos> FunctorSalad: quadratic in the number of elements in the input list.
11:42:38 <mmorrow> bos: heh, definitely a little sigh-worthy
11:42:43 <bos> FunctorSalad: concat :: [Text] -> Text
11:42:46 <copumpkin> orbitz: probably not for the next several months, but maybe after that
11:42:55 <FunctorSalad> bos: ah. even with small texts?
11:42:58 <orbitz> copumpkin: gf is moved out of here right?
11:43:00 <bos> FunctorSalad: it's less dependent on the number of actual characters.
11:43:06 <copumpkin> bos: mmorrow's idea fits into the general idea of DPH, with the "compute shape and data separately"
11:43:17 <Cale> float: (though, that may not be your actual problem here... your brackets on the next line are strange
11:43:19 <bos> FunctorSalad: right. try concatting a list of 10,000 length-1 Texts, and it go fail.
11:43:23 <copumpkin> orbitz: yeah, to utah for the winter to work at a ski resort, and then will be back to bmore in april
11:43:43 <orbitz> oh okay
11:43:48 <orbitz> so I've got that o look forward to
11:43:54 <copumpkin> :D
11:43:58 <bos> copumpkin: yeah, sure, it's easy to write a fast concat. i was just hoping to use the fusion machinery, and i think i can't.
11:44:03 <orbitz> and i'll be in Boston during winter, not sure what myschedule will be like thouhg
11:44:24 <FunctorSalad> Text was Bytestring-based?
11:44:28 <bos> FunctorSalad: no.
11:45:50 <FunctorSalad> sorry I'm just asking to be able to follow the discussion, not because I think I could be of any help with a topic I evidently know nothing about :o
11:46:35 <FunctorSalad> :)
11:47:11 <bos> FunctorSalad: no problem
11:48:14 <EnglishGent> does anyone know where I can find the lib-magic bindings for Haskell? there's a link from the haskell wiki - but it's broken http://www.haskell.org/haskellwiki/Applications_and_libraries/Operating_system
11:48:33 * EnglishGent busy googling
11:49:05 <rwx> @hoogle Int
11:49:05 <lambdabot> module Data.Int
11:49:05 <lambdabot> Text.Read Int :: Integer -> Lexeme
11:49:05 <lambdabot> Text.Read.Lex Int :: Integer -> Lexeme
11:49:07 <rwx> @hoogle Integer
11:49:08 <lambdabot> Text.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
11:49:08 <lambdabot> Text.PrettyPrint.HughesPJ integer :: Integer -> Doc
11:49:08 <lambdabot> Language.Haskell.TH.PprLib integer :: Integer -> Doc
11:49:14 <rwx> erm
11:49:17 <rwx> what's the difference?
11:49:42 <Cale> float: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13361#a13361
11:49:44 <copumpkin> Int is a machine integer
11:49:52 <copumpkin> Integer is an arbitrary precision integer
11:50:04 <rwx> so Int is platform dependent?
11:50:15 <copumpkin> yep
11:50:23 <copumpkin> it's guaranteed by the standard to have a minimum size
11:50:26 <rwx> thanks
11:50:30 <Cale> Int is guaranteed to be at least 30 bits, iirc.
11:50:35 <ziman> the spec says Int is at least 29 bits, iirc
11:50:40 <ziman> hm
11:50:43 <copumpkin> fight to the death!
11:50:51 <copumpkin> the only way to resolve it
11:50:52 <c_wraith> 29?  For tagged ints on lisp machines, or something?
11:50:58 <PeakerWork> perhaps it is at least -2^29..2^29 - 1 ?
11:50:58 <h20xt> wouldn't it be the same as int for the c standard?
11:51:23 <c_wraith> h20xt, it'd be more likely to be the same as long from the C standard
11:51:24 <copumpkin> no
11:51:30 <Cale> "The finite-precision integer type Int covers at least the range [- 2^29, 2^29 - 1]."
11:51:39 <PeakerWork> "Int" should be hidden in some Data.Int and not used by the various stdlib functions
11:51:47 <ziman> yes, that's 30 bits, you were right :)
11:51:47 <PeakerWork> Yay, good guess of mine :-)
11:51:49 <Cale> I agree.
11:52:02 <float> Cale: thanks a lot
11:52:05 <PeakerWork> "Int" is a performance hack like unboxed arrays and such
11:52:06 <FunctorSalad> why 30? :o
11:52:18 <Cale> FunctorSalad: Leaves some room for tag bits.
11:52:23 <FunctorSalad> ah :)
11:52:35 <PeakerWork> What's to tag there?
11:52:35 <Tobsan> tagged cat, jumps more predictably
11:52:35 <FunctorSalad> but it isn't used for the box?
11:52:41 <rwx> so in general should I use Integer unless i have some particular reason to use Int?
11:52:43 <FunctorSalad> (in ghc on x86)
11:52:53 <PeakerWork> rwx: or an Integral a
11:52:57 <Cale> Oh, GHC doesn't make use of the limitation
11:53:07 <Cale> I'm not sure what you'd tag, to be honest.
11:53:18 <FunctorSalad> `undefined'?
11:53:28 <rwx> hoogle being down and all, how do i find out what Integral is?
11:53:39 <FunctorSalad> rwx: hayoo?
11:53:39 <ziman> @instances Integral
11:53:41 <lambdabot> Int, Integer
11:53:49 <copumpkin> @src Integral
11:53:49 <FunctorSalad> hayoo is better for name search, anyway
11:53:50 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:53:50 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:53:50 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:53:50 <lambdabot>     toInteger           :: a -> Integer
11:53:53 <FunctorSalad> searches all of hackage
11:53:58 <PeakerWork> Char could be Integral, maybe
11:54:08 <rwx> thanks ziman / copumpkin
11:54:22 <PeakerWork> @src Enum
11:54:23 <lambdabot> class  Enum a   where
11:54:23 <lambdabot>     succ                     :: a -> a
11:54:23 <lambdabot>     pred                     :: a -> a
11:54:23 <lambdabot>     toEnum                   :: Int -> a
11:54:23 <lambdabot>     fromEnum                 :: a -> Int
11:54:25 <lambdabot> [3 @more lines]
11:54:31 <PeakerWork> toEnum/fromEnum  are horrible for using Int
11:54:35 <Cale> I guess what you could do is to use the alignment of pointers to discern when an Int is unevaluated, and once it's computed just smash the whole Int value into the space where the pointer was.
11:54:50 <PeakerWork> there should be a class for succ/pred where you can't just convert-to-index-and-back
11:55:02 <rwx> question related to integers: how do i represent arbitrary-base (radix?) numbers? is that facility provided by the prelue?
11:55:04 <rwx> prelude*
11:55:05 <Cale> (which obviously requires that it be limited in size like that)
11:55:19 <Cale> : showIntAtBase
11:55:21 <Cale> :t showIntAtBase
11:55:23 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
11:55:46 <rwx> (i'm building a factoradics library)
11:56:01 <rwx> @src showIntAtBase
11:56:01 <lambdabot> Source not found. :(
11:56:09 <Cale> It's in Numeric
11:56:14 <c_wraith> Hmm.  I guess that extra String arg is so you can use the function DList-style?
11:56:39 <Cale> c_wraith: It's so that you can concatenate by composition.
11:56:59 <copumpkin> it's still an ugly default
11:57:02 <PeakerWork> The type can be written:   forall a. (Integral a) => a -> (Int -> Char) -> a -> ShowS
11:57:19 <PeakerWork> @src ShowS
11:57:21 <lambdabot> type ShowS = String -> String
11:57:41 <PeakerWork> Using a DList could be nicer -- especially if the operations on a list where mostly in a type-class that worked with DList too
11:58:01 <PeakerWork> then DList's semantic model could be a simple list -- and it could have instances that are mostly just type-class morphisms
11:58:02 <FunctorSalad> hmm
11:58:08 <Cale> Somehow DList strikes me as overweight for what it is.
11:58:27 <PeakerWork> Cale: What do you mean by overweight?  Isn't it a newtype without any runtime weight?
11:58:42 <h20xt> is DList a difference list implemented in the standard?
11:58:55 <PeakerWork> h20xt: no, its in Hackage
11:58:55 <c_wraith> h20xt: it's on hackage, not in the standard
11:59:02 <Cale> As in the weight of an extra dependency and module import
11:59:07 <h20xt> ah, thanks, hoogle is down :(
11:59:17 * ddarius wishes they weren't called "difference" lists.
12:00:01 <PeakerWork> Composition Lists?
12:00:22 <PeakerWork> Quick Appendable lists?
12:00:32 <h20xt> does a data type with a single constructor have the same runtime weight as a newtype? seems like they should
12:00:38 <shachaf> Indifference lists?
12:00:40 <Cale> h20xt: no
12:00:54 <Cale> h20xt: That introduces an extra bit of indirection
12:01:05 <PeakerWork> Anyway, Haskell is missing tons of type-classes to give a standard vocabulary to list operations that are currently re-named/repeated in Data.List, ByteString, ByteString.Lazy, DList, some in Map, some in Set, ...
12:01:20 <c_wraith> List operations in a typeclass would be awesome
12:01:24 <ddarius> PeakerWork: See Edison.
12:01:24 <Cale> h20xt: because if you have data Foo = Foo Integer, say, then  Foo undefined  is not the same value as  undefined
12:01:26 <shachaf> h20xt: data has slightly different behavior with _|_, specifically.
12:01:27 <monochrom> "data X = X ()" has values undefined, X undefined, X ()
12:01:32 <PeakerWork> ddarius: What?
12:01:38 <aavogt> does a data type with a single strict constructor have the same runtime representation as a newtype?
12:01:48 <copumpkin> data X = X !a seems like it could be automatically newtyped
12:01:50 <FunctorSalad> what about strict single-constr data?
12:01:55 <ddarius> Nope.
12:01:55 <monochrom> "newtype X = X ()" has undefined and X ().
12:02:09 <Cale> copumpkin: again, subtly different
12:02:21 <PeakerWork> h20xt: Haskell has "lifted type products" -- basically it assigns a "constructor tag" to values of Algabraic Data Types (types defined with "data") that chooses which constructor is in use -- and it allows the computation of that tag itself to diverge -- even if there are 0 or 1 possible constructors
12:02:45 <Cale> (case undefined of X a -> 0) will succeed for the newtype, and fail for the data.
12:02:52 <copumpkin> ah
12:03:08 <FunctorSalad> strange
12:03:19 <ddarius> @hackage EdisonAPI
12:03:20 <lambdabot> http://hackage.haskell.org/package/EdisonAPI
12:03:39 <PeakerWork> I think "newtype" should be generalized to "product" -- and should allow for unlifted products. I think tuples and other products should be defined that way and be unlifted
12:03:51 <Cale> It's because when you pattern match on data, you evaluate the scrutinee of the case to see if the pattern matches. When you use case to unravel a newtype, it doesn't cause any evaluation.
12:04:35 <Cale> Strict fields just make *more* evaluation happen
12:04:43 <Cale> Rather than less. :)
12:05:12 <FunctorSalad> strictness would solve the part where "Con undefined" != undefined
12:05:19 <FunctorSalad> (hence the mention)
12:05:50 <FunctorSalad> hmm this "case" behaviour doesn't make much sense to me at first glance
12:06:14 <FunctorSalad> I mean, single-alternative datas needn't have constr tags either
12:06:19 <PeakerWork> "newtype" being unlifted, doesn't add any new bottom.  "data" with strict field unites the "inner" bottom with the "outer" one, which means the number of bottoms is the same, but differently located
12:06:28 <monochrom> Yeah, but I grokked it by omitting X.
12:06:39 <ddarius> FunctorSalad: undefined does not match (Foo _) even if Foo only has one constructor.
12:06:43 <monochrom> case undefined of a -> 0
12:06:50 <PeakerWork> FunctorSalad: Yeah -- That's the choice between "lifted" and "unlifted" products. Haskell chose lifted, but I disagree with that :)
12:07:02 <sjanssen> PeakerWork: I'm not sure that unlifted products make sense
12:07:08 <ddarius> Whereas for newtypes the wrapper just doesn't exist at runtime so the case is basically case of a variable like monochrom just wrote.
12:07:30 <ddarius> PeakerWork: You can get unlifted products just by using !.
12:07:38 <FunctorSalad> ddarius: why would one even expect undefined to match (Foo _)?
12:07:43 <FunctorSalad> you mean in the strict-field case?
12:07:54 <PeakerWork> sjanssen: why not?
12:08:19 <ddarius> FunctorSalad: In the data case.  That's why it causes evaluation.  In the newtype case the "Foo" is effectively not there and _ matches anything.
12:08:30 <monochrom> Perhaps buggy code leads to matching undefined against Foo _
12:08:54 <sjanssen> PeakerWork: well, I guess I don't see why they'd be that useful.  Newtypes have a compelling story for efficiency, I don't really see that for products
12:08:55 <FunctorSalad> ddarius: yeah I understand how newtypes just become coercions, but I'm wondering about the design decision for `case'
12:09:11 <PeakerWork> sjanssen: Consider the assymmetry between (a,b) and (a,(b,c)) in terms of bottoms
12:09:11 <FunctorSalad> (that "case undefined of X _ -> foo" isn't bottom for newtypes)
12:09:31 <PeakerWork> sjanssen: Consider the extra work everyone has to go through to justify equational reasoning of instances over tuples or even ()
12:09:41 <FunctorSalad> (it makes sense in that otherwise there would be no non-strict way to "unwrap" the newtype)
12:09:43 <ddarius> FunctorSalad: Again, that's because the X is not there.  It's like writing 'case undefined of _ -> foo' which is not bottom ever.
12:09:46 <PeakerWork> sjanssen: if () really has just 1 value, and not 2 ("values") it simplifies a lot
12:10:29 <PeakerWork> sjanssen: I think that everyone who wants to reason about their code will have an easier job when it comes to their types which happen to be products (or have just 1 constructor)
12:10:34 <sjanssen> PeakerWork: making all products different from sums doesn't seem like a simplification to me
12:10:55 <ddarius> PeakerWork: There's no way to make () have only () without seriously changing some of the semantics of Haskell.
12:10:55 <PeakerWork> sjanssen: newtypes are already different from sums -- just s/newtype/product
12:11:04 <PeakerWork> ddarius: why?
12:11:18 <sjanssen> ddarius: I guess what we'd have is: newtype () = ()
12:11:24 <ddarius> Because undefined :: forall a. a.
12:11:44 <FunctorSalad> you could conceivably still have bottoms without having boxes though
12:11:54 <ddarius> FunctorSalad: No one said anything about boxing.
12:11:58 <FunctorSalad> (nontermination has bottom semantics even without boxes, no?)
12:12:03 <FunctorSalad> ddarius: yeah, just thinking
12:12:05 <PeakerWork> ddarius: well, you could define:  undefined :: () = ()  no?
12:12:31 <ddarius> PeakerWork: Uh, no.  Not without amazingly changing the semantics of Haskell (impossibly most likely)
12:12:33 <ddarius> :t fix id
12:12:35 <lambdabot> forall a. a
12:13:12 <Philonous> To get rid of _|_ you'd need to prove statically that your code doesn't diverge. That seems rather hard to do without a more expressive type system
12:13:13 <ddarius> The best you can do is change function types to take unlifted arguments, but that makes Haskell a strict language.
12:13:47 <PeakerWork> ddarius: I don't understand why defining _|_ :: () == ()  amazingly changes semantics
12:14:06 <PeakerWork> ddarius: can you give an example?
12:14:12 <Philonous> How can you pattern match on bottom?
12:14:13 <sjanssen> PeakerWork: remember that Haskell has seq
12:14:31 <PeakerWork> sjanssen: If by "getting rid of seq" you mean amazing changes, then sure :)
12:14:51 <PeakerWork> sjanssen: "seq" could behave significantly differently
12:15:14 <PeakerWork> sjanssen: (for single-constructor values, just do nothing)
12:15:59 <PeakerWork> Philonous: you don't get rid of _|_, you re-define it to be the single constructor with bottoms in all the fields
12:16:09 <sjanssen> PeakerWork: every thunk would need an extra tag indicating whether it is single constructor
12:16:32 <sjanssen> actually, does polymorphism even make that possible?
12:17:12 <PeakerWork> sjanssen: I think the main problem augustuss showed me w.r.t unlifted products is:  let p = p in (x, y) = p  -- there's no computed runtime entity representing the tuple at any time, so x and y can't just copy ptrs from somewhere, they have to get thunks generated for them that look like (fst p) and (snd p).  But that seems like an implementation detail to me (is this what you mean)?
12:17:46 <Philonous> PeakerWork: Ah, you want to do that only for () (modulo isomorphisms) ?
12:18:04 <sjanssen> PeakerWork: your code sample doesn't seem syntactically valid
12:18:18 <PeakerWork> Philonous: I also want _|_ == (_|_, _|_)
12:18:29 <PeakerWork> oops
12:18:39 <PeakerWork> let p = p ; (x, y) = p in ...
12:18:50 <PeakerWork> > let p = p ; (x, y) = p in x + y
12:18:55 <lambdabot>   mueval-core: Time limit exceeded
12:19:03 <EnglishGent> what's the difference between a lifted & unlifted product?
12:19:18 <PeakerWork> EnglishGent: do you know what a "type product" is?
12:19:24 * EnglishGent knows what products are categorically - but has never heard of this distinction
12:19:52 <sjanssen> PeakerWork: in Haskell we could replace the (x, y) pattern with ~(x, y).  This causes memory leaks, however
12:20:05 <EnglishGent> yes - a type T is a product of X & Y if there are arrows f :: T -> Y, g :: T -> X such that ... blah blah blah
12:20:09 <PeakerWork> EnglishGent: a lifted product like Haskell's (a, b)  have these values:  _|_, (_|_, _|_), (_|_, b), (a, _|_), (a, b)   whereas an unlifted product has:  _|_ == (_|_, _|_), (_|_, b), (a, _|_), (a, b)
12:20:14 * EnglishGent cant be bothered to type out full definition :)
12:20:45 <PeakerWork> sjanssen: that's a succint way to describe the "solution", yeah
12:20:46 <sjanssen> PeakerWork: after thinking about it, I would find unlifted products actively annoying in programming
12:20:55 <PeakerWork> sjanssen: where for example?
12:20:57 <sjanssen> Haskell is a lazy language, most constructs should be lazy
12:21:13 <PeakerWork> sjanssen: I don't think it hinders laziness -- it prevents even more evaluation :)
12:21:56 <FunctorSalad> hmm maybe lifted ones are more naturally implemented? no idea
12:21:58 <sjanssen> PeakerWork: case (x, _|_) of (x, _) -> x -- this should evaluate to x, not bottom
12:22:13 <ddarius> sjanssen: It depends on whether x was bottom or not.
12:22:23 <ddarius> How the implementation is supposed to tell, I don't know.
12:22:46 <Philonous> PeakerWork: THe only argument I could come up with is that it is surprising behaviour. Change from single constructor to multiple constructor or vice versa and suddenly the semantics of your code changes
12:22:49 <PeakerWork> sjanssen: with unlifted products, why wouldn't it?  _|_ == (_|_, _|_)  but _|_ /= (a, _|_)
12:23:06 <sjanssen> PeakerWork: whoa, really?
12:23:08 <PeakerWork> Philonous: then have separate "product" and "data" keywords, rather than "newtype" and "data"
12:23:21 <PeakerWork> sjanssen: that's how I understand it, but maybe I have it wrong
12:23:30 <ddarius> PeakerWork: There is no way to implement _|_ = (_|_, _|_) but _|_ /= (a, _|_) /= (_|_, b)
12:24:01 <FunctorSalad> sjanssen: I think you're thinking of a product which is bottom if *any* field is bottom?
12:24:03 <EnglishGent> wb mmx166mhz :)
12:24:13 <FunctorSalad> Peaker means products which are bottom if all the fields are bottom
12:24:13 <sjanssen> FunctorSalad: that was my understanding
12:24:19 <ddarius> You could have _|_ = (a,_|_) = (_|_, b) (= (_|_, _|_) therefore)  which is just what you would get if you made products strict in their arguments.
12:25:23 <PeakerWork> ddarius: what if all pattern matches on the products are lazy?  case p of (x, y) ->   makes x and y thunks that perform (fst and snd), but no evaluation actually takes place..?
12:25:34 <FunctorSalad> ddarius: th very naive representation "just sequence the representations of the components in memory"
12:25:35 <FunctorSalad> err
12:25:37 <FunctorSalad> hit return
12:25:41 <ddarius> FunctorSalad: That is not implementable.  That means 'case (a,b) of _ -> True' is bottom only if both a and b are bottom.  How are you supposed to check both?
12:25:58 <FunctorSalad> that sentence was not complete but apparently you caught what I meant ;)
12:26:20 <sjanssen> ddarius: it would be annoying, but the evaluator could be made to interleave evaluation of a and b
12:26:26 <Philonous> @type (unamb (l `seq` ()) (r `seq` () )) `seq` (l,r)
12:26:27 <algaiz> exit
12:26:28 <lambdabot> Not in scope: `unamb'
12:26:29 <PeakerWork> ddarius: case (a, b) of _ -> True  would simply always be True, I don't see the issue
12:26:46 <PeakerWork> ddarius: _ would always match the single constructor
12:26:47 <FunctorSalad> case (a,b) of (_,_) ->True ?
12:27:05 <ddarius> sjanssen: I guess that would work in this basic case at least.
12:27:08 <PeakerWork> case (a, b) of _ -> x = case (a, b) of (_, _) -> x = x
12:27:17 <Saizan> ddarius: i think the idea is to always see _|_ as what you currently have with (_|_,_|_), not viceversa
12:27:29 <FunctorSalad> hmm for conjunction you don't need interleaving
12:27:32 <FunctorSalad> just eval both in turn
12:27:37 <ddarius> FunctorSalad: That would not work.
12:27:42 <FunctorSalad> (or eval to whnf here)
12:28:00 <PeakerWork> case PRODUCT of ...   wouldn't evaluate anything -- it would just be a "lazy pattern match" that makes some new thunks, at best
12:28:14 <PeakerWork> it doesn't violate  _|_ /= (a, _|_)  afaiu it
12:28:31 <ddarius> case (a,b) of (True, True) -> True
12:29:10 <PeakerWork> oops, .. of _   or  of CONSTR _ _ _ ...
12:29:17 <PeakerWork> (i.e: the examples given above)
12:29:51 <PeakerWork> btw: Does GHC Core use "case" to pattern-match deeper than WHNF?
12:30:53 <FunctorSalad> I guess my naive imagination of how `data' is represented in memory doesn't match how the continuation-using implementation works...
12:31:03 <sjanssen> PeakerWork: core only matches one level of constructor at a time (yes)
12:31:41 <ddarius> FunctorSalad: Uh, modulo the new tags, data types are represented basically in their Scott-encoding.
12:31:52 <PeakerWork> so in core, my silly mistake above is not a mistake, maybe :)
12:31:59 <PeakerWork> (in a hypothetical unlifted-products core)
12:32:13 <PeakerWork> (in which that wouldn't happen because it would be pointless :)
12:32:27 <FunctorSalad> hmm
12:33:25 <FunctorSalad> ddarius: hmm why isn't it possible to semi-decide "all the fields are non-bottom" by whnf'ing them all in turn then?
12:33:48 <FunctorSalad> (thought that was the task in that 'case' stmt)
12:33:50 <ddarius> FunctorSalad: Because if one is bottom, the whole thing will become bottom.
12:34:05 <ddarius> FunctorSalad: That would violate (_|_, b) /= _|_
12:34:19 <ddarius> You'd have to interleave like sjanssen suggested.
12:34:19 <PeakerWork> its not the way unlifted products have "case" behave, though
12:34:37 <Paczesiowa> what happened to hpaste.org archives? I have a link to some code (1 year old) and I can't view it
12:34:52 <ddarius> sjanssen: newtype Stream a = Stream (a, Stream a); case x of ...
12:35:17 <PeakerWork> with lifted products, you have:  A) _|_   and B)  (_|_, _|_)   and C)  anything else.   You can use "case" on the product itself to differentiate A from B.   Unlifted products don't collapse B into A, they collapse A into B (A will behave like B, not vice versa)
12:36:03 <ddarius> sjanssen: You'd have to diagonalize the evaluation for that type.
12:36:08 <PeakerWork> so you can't differentiate (_|_, _|_) from _|_ so they're equal.  But you can still differentiate (_|_, b) from (_|_, _|_)
12:36:39 <sjanssen> ddarius: you're right.  The evaluator would be some sort of queue
12:37:11 <FunctorSalad> PeakerWork: hmm so "case x of (_,_,_) -> True" would always return True?
12:37:20 <PeakerWork> FunctorSalad: Yeah
12:37:23 <FunctorSalad> (collapse A into B)
12:38:02 <PeakerWork> and hopefully yield a warning about meaningless code or something? :)
12:39:27 <PeakerWork> anyway, I think augustuss (who supports lifted products) explained to me the main reasons behind lifted products is "Don't want a surprise when adding a constructor" (I think this is solvable by s/newtype/product and using that for unlifted products) and "All pattern matches become lazy" (I am not sure this is a big problem. Might make optimizations harder)
12:39:33 <copumpkin> lol, http://snapplr.com/ehb2
12:43:20 <PeakerWork> The real reason I want unlifted type products, is because its a tiny step towards getting rid of bottom entirely :-) (Total languages)
12:44:08 <opqdonut> i'd like an unlifted Void ;)
12:44:48 <pikhq> I'd like a solution to the halting problem, myself.
12:45:18 <FunctorSalad> PeakerWork: that doesn't seem like something you'd achieve in small steps :o
12:45:28 <FunctorSalad> PeakerWork: seems to be more a case for a new language
12:45:32 <FunctorSalad> (e.g. agda)
12:45:35 <sjanssen> PeakerWork: lazy matches cause serious memory leaks
12:45:38 <copumpkin> mmm agda
12:46:21 <pikhq> Lazy matching also breaks things unless you can prove the pattern matches...
12:46:35 * pikhq states the obvious
12:46:37 <sjanssen> PeakerWork: case foo of (_, (_, (_, x))) -> x -- x's thunk takes memory linearly proportional to the depth of nesting
12:47:00 <PeakerWork> sjanssen: with unlifted products, an implementation is free to translate ((a, b), c) to (a, b, c) :)
12:47:13 <PeakerWork> sjanssen: but you still get the nicer composition of 2-tuples
12:47:21 <ddarius> PeakerWork: That doesn't change the memory usage.
12:47:33 <copumpkin> :k (#,#)
12:47:35 <lambdabot> ? -> ? -> (#)
12:47:37 <Paczesiowa> opqdonut: data Foo :: #; ?
12:47:48 <sjanssen> PeakerWork: with polymorphic recursion and other polymorphism that translation can't be done in general, I think
12:47:59 <PeakerWork> ddarius: if ((a, b), c) is translated to (a, b, c)  then an accessor of any of the fields is O(1) memory, no?
12:48:38 <ddarius> I'm pretty sure polymorphic recursion and other cases of higher rank polymorphism could seriously cause issues for this whole scheme.  Not necessarily insurmountable ones (but maybe) but likely costly ones.
12:48:44 <sjanssen> oh, I see what ddarius means: x@((a, b), c) would actually have to be translated into (fst (fst x), snd (fst x), snd x)!
12:48:58 <PeakerWork> sjanssen: true, but it can probably be done in most specific cases
12:49:10 <opqdonut> Paczesiowa: does that actually work?
12:49:29 <PeakerWork> sjanssen: Yeah, that's why I mentioned the translation
12:50:04 <PeakerWork> ddarius: People tend to overlook the disadvantages of the familiar but focus on the disadvantages of the unfamiliar, IME, when evaluating their options :)
12:50:06 <sjanssen> PeakerWork: each component of the translation takes up an extra O(n) memory
12:50:29 <osaunders> Is there a way to do string interpolation or do I have to use ++ for everything?
12:50:36 <PeakerWork> ddarius: My dad's computer, with Vista, breaks down 3 times a week, he can barely use it.  When I install Ubuntu for him, the printer has a few problems -- and he can't handle that -- he's used to the whole computer breaking down all the time :)
12:50:56 <PeakerWork> ddarius: I'm sure there are problems -- but its not like the current scheme is that great
12:51:04 <PeakerWork> ddarius: I really really hate N-tuples
12:51:08 <sjanssen> osaunders: there are a few packages on hackage for that, but I usually just use (++), concat, or unwords/unlines
12:51:14 <Twey> osaunders: There are several.  See the HStringTemplate package, the Text.Printf.printf function, or that typesafe printf on Hackage.
12:51:22 <PeakerWork> sjanssen: btw: I'd rather take these implementation issues over the semantic issues of the current scheme
12:51:39 <osaunders> OK ty.
12:51:49 <sjanssen> PeakerWork: the current scheme has the advantage that it is very easy to understand
12:52:24 <Paczesiowa> opqdonut: I can't make it work. anyway, what's the point?
12:52:29 <PeakerWork> sjanssen: I'm not sure that's true at all. I remember, just 1 year ago, I was struggling to understand this _|_ business in Haskell, and didn't understand how it made any sense that matching (_, _) did any work at all
12:52:34 <mreh> how do I apply a function to part of a tuple
12:52:46 <sjanssen> _|_ breaks reasoning in every corner of the language, but most agree that "fast and loose reasoning is morally correct"
12:52:50 <PeakerWork> mreh: Using "first" and "second", if its a 2-tuple.  Or ugly boilerplate if its an N-tuple
12:53:03 <PeakerWork> sjanssen: I haven't yet read/understood the "fast and loose reasoning" bit
12:53:12 <FunctorSalad> sjanssen: "agree"? it's *proven* ;) (in a small fragment of the language)
12:53:17 * hackagebot upload: file-embed 0.0.3 - Use Template Haskell to embed file contents directly. (MichaelSnoyman)
12:53:37 <FunctorSalad> not sure how this moral equality works with polymorphism
12:53:44 <FunctorSalad> and other extra language features
12:54:04 <mreh> how do you update a tuple then?
12:54:17 <copumpkin> fast and loose reasoning is immoral
12:54:28 <copumpkin> reasoning should be forever
12:54:28 <FunctorSalad> PeakerWork: essentially they define a sensible equivalence relation on haskell terms such that all the categorical properties actually become true
12:54:38 <Botje> loose axioms sink ships
12:54:48 <FunctorSalad> (like fst . (f &&& g) = f, and what not)
12:54:56 <CalJohn> @src unlines
12:54:58 <lambdabot> unlines = concatMap (++ "\n")
12:54:59 <FunctorSalad> up to that equivalence
12:55:04 <PeakerWork> FunctorSalad: even with bottoms in place?
12:55:12 <FunctorSalad> PeakerWork: yes that's the point
12:55:18 <FunctorSalad> err and it's a partial equivalence :)
12:55:21 <Twey> > first (* 2) (3, 4)
12:55:22 <lambdabot>   (6,4)
12:55:31 <netinho2lol> Cale isn't around :(
12:55:40 <Twey> > (* 2) *** (+ 2) $ (3, 3)
12:55:42 <lambdabot>   (6,5)
12:56:06 <copumpkin> Twey: that can be made more succinct
12:56:11 <PeakerWork> FunctorSalad: where does the equivalence break down?
12:56:17 <PeakerWork> FunctorSalad: I mean, in what sense is it partial?
12:56:22 <Twey> copumpkin: How's that?
12:56:25 <PeakerWork> > (6,5)
12:56:26 <netinho2lol> any fold experters to help me?
12:56:27 <lambdabot>   (6,5)
12:56:29 <PeakerWork> ;)
12:56:30 <Twey> Ha!
12:56:33 <copumpkin> PeakerWork: damn you!
12:56:33 <copumpkin> :P
12:56:38 <copumpkin> you could also do
12:56:41 <FunctorSalad> PeakerWork: IIRC bottom isn't equivalent to itself at most types
12:56:52 <opqdonut> Paczesiowa: well the current Void kinda breaks the curry howard correspondence :)
12:56:54 <copumpkin> > ((***) <$> (*) <*> (+) 2) (3, 3)
12:56:55 <lambdabot>   Couldn't match expected type `b' -> c''
12:56:55 <lambdabot>         against inferred type `(t, ...
12:56:58 <copumpkin> damn
12:57:07 <copumpkin> > (((***) <$> (*) <*> (+)) 2) (3, 3)
12:57:08 <lambdabot>   (6,5)
12:57:20 <mreh> :t first
12:57:22 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:57:26 <mreh> oh
12:57:30 <mreh> not fst
12:57:37 <PeakerWork> mreh: "first" lifts a function to a tuple's first
12:57:37 <copumpkin> definitey not
12:57:37 <Paczesiowa> opqdonut: you could not define Void, then it wouldn't have any values
12:57:40 <PeakerWork> @where SEC
12:57:41 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
12:57:47 <PeakerWork> mreh: read this ^^ its a great post
12:58:00 <FunctorSalad> PeakerWork: hmm I meant "partial equivalence" in the sense of "not reflexive" btw
12:58:08 <opqdonut> Paczesiowa: and would also be a type error?-=
12:58:11 <PeakerWork> FunctorSalad: I don't know much maths -- not sure what that means
12:58:13 <opqdonut> *?-)
12:58:39 <Paczesiowa> opqdonut: precisely, you want it to be a type error to use such values
12:59:24 <Baughn> Is there a lazy version of the ST monad?
12:59:32 <Baughn> Er..
12:59:34 <Baughn> Right.
12:59:37 <Twey> Yeah.  :þ
12:59:55 <ddarius> In my view, the Curry-Howard correspondence isn't something that can be broken (at least from the PL side)
13:00:18 <copumpkin> broken?
13:00:39 <copumpkin> Baughn: yes, Control.Monad.ST.Lazy
13:00:52 <PeakerWork> CH specifically talks about non-bottoms, no? values that can be fully normalized?
13:00:56 <Baughn> copumpkin: Duly noted.
13:01:18 <opqdonut> ddarius: well yeah, but the logic isn't useful
13:01:32 <opqdonut> anyway, Void is supposed to be an empty type so what's _|_ doing in it?
13:01:42 <ddarius> PeakerWork: The specific Curry-Howard correspondence talks about a very specific language and logic, but the idea can be stated as "Every programming language induces a logic and proof theory."
13:02:00 <tibbe> @tell bos I'm a bit confused about the documentation (in Criterion) under "Benchmarking pure code". It sounds like you're talking about two types both called B but they're different.: data B a = forall b. B (a -> b) a vs (a -> b, a)
13:02:00 <lambdabot> Consider it noted.
13:02:04 <ddarius> opqdonut: Yes, the logic can be inconsistent, but that doesn't necessarily mean useless especially given a proof theory as well.
13:02:15 <thunderbolt> Ok, I'm making some test cases in HUnit. For each test case I'd like to have a named variable called "packets", which is a set of packets I'm testing. How can I do this for each test declaration? With a "let" clause?
13:02:30 <opqdonut> ok, I'll rephrase: having a really empty void would make the CH more useful in the case of Haskell
13:02:30 <thunderbolt> The variable "packets" varies from test case to test case.
13:02:33 <opqdonut> happy?
13:02:42 <PeakerWork> ddarius: Every language? I'm not sure I see how.. through establishing functional equivalence?
13:03:11 <sjanssen> thunderbolt: as let bindings in the test cases, or function arguments to those test cases
13:03:11 <netinho2lol> can some one confirm me that I'm doing a fold? http://pastebin.com/d71d85c18
13:03:18 <netinho2lol> :|
13:03:33 <Baughn> netinho2lol: Yes, hlint. ;)
13:03:43 <ddarius> PeakerWork: Every language can be given a (perhaps trivial in the case of untyped languages) type system (if it doesn't already have one) and the language itself is the proof theory.
13:03:44 <Baughn> netinho2lol: Also, yes, that looks like a fold to me
13:03:47 <copumpkin> netinho2lol: there's a simpler way to do it
13:03:49 <mauke> foldr (.) id
13:03:49 <thunderbolt> sjanssen: As a function argument to the function being tested in the test case. It's fine if the let case is within the test case.
13:03:57 <netinho2lol> Baughn: I ran hlint and it didn't tell me that it's a fold :P
13:04:09 <sjanssen> netinho2lol: that's a map.  maps also happen to be foldrs
13:04:10 <thunderbolt> Sorry if that's hard to follow, still developing my Haskell vocabulary.
13:04:27 <mauke> netinho2lol: line 2 is redundant
13:04:27 <sjanssen> wait, it isn't a map, nevermind
13:04:39 <Baughn> netinho2lol: Well, it /is/ a fairly unusual fold
13:04:39 <netinho2lol> mauke: fixed that
13:05:10 <Spockz> hmm, hoogle is dead...
13:05:22 <copumpkin> yes, someone reminds us every half hour :)
13:05:30 <netinho2lol> Baughn,mauke: hlint didn't suggested me that it's a fold because of that second line, lol
13:05:37 <thunderbolt> sjanssen: Here's the test case I currently have: http://haskell.pastebin.com/m3d7b08e
13:05:42 <Spockz> copumpkin: glad to keep up the rhytm then :)
13:05:46 <PeakerWork> ddarius: if the type system is too trivial -- what kind of logical propositions can you make with it?
13:06:00 <copumpkin> yay
13:06:07 * Spockz picks some popcorn and waits for the next one
13:06:58 <PeakerWork> Neil Mitchell makes some awesome stuff
13:07:15 <ddarius> PeakerWork: Trivial ones.  For an untyped language there is just one axiom: ⊢ U
13:07:29 <PeakerWork> ddarius: what's that?
13:07:40 <Spockz> is there a function replicate :: Integer -> a -> [a] already?
13:07:57 <ddarius> :t replicate
13:07:58 <lambdabot> forall a. Int -> a -> [a]
13:07:58 <Spockz> yeah, nvm
13:07:59 <ziman> :t Data.List.replicate
13:08:00 <lambdabot> forall a. Int -> a -> [a]
13:08:05 <copumpkin> :t replicate . fromIntegral
13:08:06 <Spockz> genericReplicate
13:08:06 <lambdabot> forall a a1. (Integral a1) => a1 -> a -> [a]
13:08:06 <ddarius> :t genericReplicate
13:08:08 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
13:08:12 <kmc> very few languages are untyped
13:08:16 <kmc> many are dynamically typed
13:08:33 <ddarius> kmc: Dynamically typed = untyped as far as static type systems are concerned.
13:08:36 <PeakerWork> kmc: untyped = "dynamically typed" as I understand it.. confusion resulting from different use of the word "type"
13:08:53 <shambler> is lisp typed? :)
13:08:57 <mtnviewmark> yes
13:09:04 <thunderbolt> In my world, untyped languages are things like Bliss or Assembly.
13:09:06 <copumpkin> just not statically checked typing
13:09:22 <ddarius> thunderbolt: Assembly is extremely typed.
13:09:34 <PeakerWork> ddarius: what does "extremely typed" mean? :)
13:09:54 <mtnviewmark> anyone have some good hints for understanding Haskell profiling? things to read?
13:09:57 <c_wraith> the types are extreme.
13:09:59 <Twey> It's at an extreme end of the type spectrum. ;)
13:10:00 <ddarius> PeakerWork: It's not even physically possible to break its type system.
13:10:06 <PeakerWork> mtnviewmark: there's a chapter about it in the RWH book
13:10:08 <Twey> Ha!
13:10:19 <PeakerWork> ddarius: sure its *physically* possible :)
13:10:20 <mtnviewmark> I'm just stumped: 87% of my time is a tiny function that just decoded a 4 byte int
13:10:23 <ddarius> (Well, I could probably do it with a hammer.)
13:10:28 <mtnviewmark> I read that chapter -- didn't help too much
13:10:36 <PeakerWork> mtnviewmark: tiny functions in inner loops are likely candidates to be time hogs :)
13:10:42 <mtnviewmark> in that I have it all working, but really, that chapter, there is an obvious culprit
13:11:13 <papna> Terms like dynimcally typed, untyped, strongly typed, static typing, weak typing...are all used quite inconsistently by enough people that they are hard to use.
13:11:34 <mtnviewmark> right - no inner loop here - this one is just called once per record -- and the record is a giant XML doc -- so the majority of time should be in there, but the profile attributes it all to this little routine that reads the 4 byte length at th front of the record
13:11:54 <mtnviewmark> ("in there" = in the XML parsing)
13:12:01 <ddarius> mtnviewmark: That might be the function that actually forces work to be done.
13:12:28 <thunderbolt> sjanssen: I figured it out. Thanks for pointing me in the right direction.
13:13:12 <thunderbolt> mtnviewmark: What's the memory usage of the various functions? That may be a better clue.
13:13:24 <thunderbolt> You're using GHC 6.10.something-something right?
13:13:35 <mtnviewmark> yes, 6.10.4
13:13:53 <paolino> I have a problem understanding Traversable, and making a simple instance http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13362#a13362
13:14:00 <mtnviewmark> the memory is all in my routine that drives the XML (hexpat) parser
13:14:14 <mtnviewmark> and, seems to just accumulate for the whole run, never freeing -- which is odd
13:14:24 <mtnviewmark> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13363#a13363
13:14:36 <mtnviewmark> the time is all attributed to hDecode, called from hGetInt32
13:15:02 <thunderbolt> hrrr.
13:15:15 <thunderbolt> Generally the profiler is pretty accurate at showing what's actually taking the longest to calculate.
13:15:25 <mtnviewmark> and the memory is all attributed to this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13364#a13364
13:15:30 <thunderbolt> Not just what function happened to be the last one called to cause all the built of expressions to be evaluated.
13:16:24 <mtnviewmark> I can't even imagine why hDecode would force anything - it only returns an Int from the ByteStream,
13:17:10 <thunderbolt> Are you on Linux?
13:17:17 <mtnviewmark> Mac
13:17:38 <thunderbolt> Can you run it through the "time" command to see how much execution time is spent by kernel calls/
13:17:39 <thunderbolt> ?*
13:17:40 <lambdabot> Maybe you meant: . ? @ v
13:17:48 <thunderbolt> No, but thank you lambdabot.
13:18:05 <thunderbolt> ByteStream is from I/O, right?
13:18:08 <ddarius> thunderbolt: It depends on the distribution of SCCs.
13:18:18 <thunderbolt> What's an SCC?
13:18:32 <mtnviewmark> real	0m4.426s -- user	0m4.057s -- sys	0m0.336s
13:18:41 <copumpkin> set cost centre
13:18:46 <thunderbolt> Ok, so it's not I/O bound.
13:19:53 <Baughn> I've never before been so happy to see eight megabytes of Ts. :D
13:20:11 <Baughn> ..scratch one AES implementation.
13:20:18 <opqdonut> ?
13:20:42 <Baughn> opqdonut: Hang around, and you'll see the hackage upload message in about ten minutes
13:23:17 <mtnviewmark> copumpkin? was that aimed at me?
13:23:48 <copumpkin> the "set cost centre" was for thunderbolt
13:24:25 <mtnviewmark> ah - good - i didn't understand it!  :-)
13:25:04 <mreh> i'm sure I've done this before, but I can't remember the pattern, if i've zipped a list with [1..], how can I get the index of the largest element in the original list?
13:25:21 <copumpkin> snd . last
13:25:22 <copumpkin> - 1
13:25:24 <copumpkin> :P
13:25:46 <mreh> zip [1..] [1,9,8,2,4,5,10]
13:25:50 <mreh> > zip [1..] [1,9,8,2,4,5,10]
13:25:51 <lambdabot>   [(1,1),(2,9),(3,8),(4,2),(5,4),(6,5),(7,10)]
13:25:55 <mreh> that sort of thing
13:26:03 <copumpkin> oh, I see
13:26:30 <mauke> maximumBy (comparing snd)
13:26:33 <mtnviewmark> > snd $ max $ zip [1,9,8,2,4,5,10] [0..]
13:26:39 <opqdonut> > maximumBy (comparing snd) $ zip [1..] [1,9,8,2,4,5,1]
13:26:39 <lambdabot>   (2,9)
13:26:39 <copumpkin> > fst . maximum . zip [0..] $ [1,9,8,2,4,5,10]
13:26:39 <copumpkin> > fst . maximumBy (comparing snd) . zip [0..] $ [1,9,8,2,4,5,10]
13:26:39 <opqdonut> mreh: like that?
13:26:39 <lambdabot>   Couldn't match expected type `(a, b)'
13:26:39 <lambdabot>         against inferred type `[(t, t...
13:26:39 <lambdabot>   6
13:26:40 <lambdabot>   6
13:27:07 <mtnviewmark> > snd $ maximum $ zip [1,9,8,2,4,5,10,3,5] [0..]
13:27:09 <mreh> yes, that
13:27:09 <lambdabot>   6
13:27:43 <mtnviewmark> but, as that uses the property of Ord on (,), it will give you the last index if there are multiples of the max
13:27:50 <mtnviewmark> > snd $ maximum $ zip [1,9,8,2,4,5,10,3,5,10] [0..]
13:27:51 <mtnviewmark> ]
13:27:52 <lambdabot>   9
13:27:53 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
13:27:53 <CalJohn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13365#a13365 <-- I can't see what silly mistake I am making...
13:28:05 <mreh> :t comparing
13:28:17 <mreh> @botsmack
13:28:17 <lunabot>  :o
13:28:28 <kmc> CalJohn, (j:js) instead of [j:js] ?
13:28:28 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:28:28 <lambdabot> :)
13:28:38 <mreh> :t comparing
13:28:40 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:28:51 <CalJohn> kmc: that was stupid.
13:29:08 <mreh> heh
13:29:33 <CalJohn> i often make that mistake...
13:29:59 <mreh> [ ] has several uses
13:30:09 <opqdonut> [j:js] is a bit like prolog syntax
13:30:10 <opqdonut> :)
13:30:36 <ben> @pl \f g x -> f x || g x
13:30:36 <lambdabot> liftM2 (||)
13:30:57 <ben> Oh.
13:31:10 <ben> I keep getting carried away with <*>
13:32:18 <ben> @pl \x -> f x >>= \y -> (x, y)
13:32:18 <lambdabot> liftM2 (>>=) f (,)
13:32:27 <mreh> what does this @pl command do?
13:32:32 <mreh> pointless style?
13:32:35 <ben> Yeah
13:32:43 <ben> It makes my code better!
13:33:02 <mreh> i don't even know what pointless style is
13:33:26 <CalJohn> pointfree...
13:33:38 <Botje> mreh: no explicit parameter names
13:33:54 <mreh> a.k.a pointless style
13:34:21 <mreh> so you have to use (.) alot then
13:34:30 <mreh> that's not pointfree, hur hur
13:34:30 <PeakerWork> No \ lambdas or sugared lambdas like: f x = ...
13:34:43 <monochrom> "point" means parameter, not "."
13:34:52 <mreh> duuur
13:35:04 <monochrom> I think no one pronounces "f . g" as "f point g" anyway.
13:35:14 <mreh> i say "dot"
13:35:27 <monochrom> There you go, even you agree "." is not point.
13:35:30 <mreh> are lambda bad?
13:35:53 <mauke> you should pronounce it "lol"
13:35:58 <ben> Not really, but sometimes code is easier to follow when you do not have to remember as many names
13:36:16 <mreh> i have to use one to make "the function that always returns x"
13:36:28 <holmak> you mean const?
13:36:34 <mreh> ooh
13:36:36 <mreh> :t const
13:36:38 <lambdabot> forall a b. a -> b -> a
13:36:44 <mreh> I like
13:36:46 <holmak> bam!
13:36:57 <holmak> standard library to the rescue
13:37:17 <c_wraith> @src asTypeOf
13:37:18 <lambdabot> asTypeOf = const
13:37:27 <mreh> not difficult to write your own const either
13:37:38 <holmak> certainly not
13:37:39 <benmachine> difficult to write your own const pointfree though
13:38:22 <CalJohn> i pronouce "f o g" as effgee
13:38:28 <mreh> what about the function that adds a function to itself and applies the same argument to each
13:38:36 <CalJohn> *pronounce, even
13:38:44 <benmachine> mreh: what
13:39:04 <holmak> > (curry fst) 42 "whatever"
13:39:06 <lambdabot>   42
13:39:09 <mreh> (\a -> k x a + w a) like that
13:39:21 <benmachine> holmak: hah, not bad
13:39:42 <holmak> I was so happy when I figured that one out
13:39:55 <benmachine> mreh: have a look at the pointfree package on hackage, it might answer your questions
13:40:07 <PeakerWork> @unpl liftA2 (+) (k x) w
13:40:08 <lambdabot> liftA2 (+) (k x) w
13:40:22 <PeakerWork> mreh: that's basically what you wrote
13:40:28 <mreh> i'm training a perceptron
13:40:30 <netinho2lol> I'm having a problem with ghci
13:40:39 <mreh> so i need to keep adding terms to the perceptron, and then return it
13:40:47 <mreh> :t liftA2
13:40:49 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
13:40:53 <poe> Is there a way to find out which hackage packages USE another hackage package?
13:41:04 <netinho2lol> Warning: Defined but not used: `function'
13:41:19 <netinho2lol> function fs p = foldl (\ x f -> f x) p fs
13:41:23 <netinho2lol> it is defined
13:41:30 <copumpkin> but not used...
13:41:36 <mreh> poe: yes, hackage
13:41:53 <netinho2lol> I have other functions not used before that one, copumpkin
13:42:08 <copumpkin> presumably you'll get a warning about those too
13:42:22 <mreh> @paste
13:42:22 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:42:30 <mreh> paste your code so someone can inspect it
13:42:47 <mreh> with the compiler error
13:42:48 <monochrom> paste your code so people can reproduce your problem.
13:42:54 <poe> mreh sorry I can't find such feature
13:43:06 <copumpkin> there isn't one
13:43:19 <netinho2lol> copumpkin: just hidded the function, and it says it's okay :|
13:43:23 <PeakerWork> mreh: liftA2 applies a pure function of 2 args to two "containers" and results in a single "container".  If the container is a function (r->) that works too, as in your example)
13:44:08 <copumpkin> netinho2lol: it's a warning, telling you that you wrote a function but aren't using it. If you don't care, just ignore it
13:45:26 <mreh> @pl \a -> fst . maximumBy (comparing snd) (map ($a) ps)
13:45:27 <lambdabot> (fst .) . maximumBy (comparing snd) . flip map ps . flip id
13:45:32 <mreh> urgh
13:46:03 <mreh> cheers PeakerWork
13:46:26 <benmachine> is there any way to find out from hackage when a package was last updated?
13:46:27 <netinho2lol> copumpkin: I can't ignore it when there are other functions in the same circunstances and it doesn't warn about them :P
13:46:30 <mreh> soon my code with be the envy of every Cambridge professor of computer science
13:46:49 <copumpkin> netinho2lol: if they're exported, it won't give you that warning for obvious reasons
13:46:54 <copumpkin> if they aren't exported and aren't used, then it'll warn you
13:47:21 <netinho2lol> copumpkin: exported as in used in other modules?
13:47:31 <copumpkin> as in made available for other modules to use
13:47:50 <netinho2lol> none of them are available, me thinks
13:48:05 <benmachine> by default everything is
13:48:13 <benmachine> everything at the top-level anyway
13:48:14 <PeakerWork> mreh: if you read the SEC thing you can see a nice way to make the (fst . ) .  thing more readable
13:49:00 <mreh> i suppose the variable is only trapped because of the ordering of args
13:49:17 <mreh> how you shuffle more than two args for a function?
13:49:35 <monochrom> We need #haskell-irreproducible for "discussing" problems that won't be reproduced such as unexplained error messages and missing/abducted error messages.
13:49:48 <copumpkin> lol
13:49:59 <monochrom> Perhaps #haskell-paranormal
13:50:06 <benmachine> @pl \f x y z -> f z x y
13:50:06 <lambdabot> (flip .) . flip
13:50:15 <copumpkin> #haskell-guessmyerror
13:50:16 <lunabot>  luna: A section must be enclosed in parentheses
13:50:19 * mreh brane asplode
13:50:39 <benmachine> @undo ,
13:50:40 <lambdabot> (,)
13:50:44 <benmachine> hmm
13:51:07 <dmwit> What is lunabot complaining about?
13:51:15 <netinho2lol> copumpkin: I just noticed what's going on
13:51:18 <benmachine> that is what I was wondering
13:51:28 * Baughn is having some trouble uploading to hackage. It's not down, but..
13:51:29 <copumpkin> dmwit: it treats # as a special character to query it by
13:51:39 <benmachine> #something-else
13:51:40 <lunabot>  luna: parse error on input `else'
13:51:47 <dmwit> mmm
13:51:53 <benmachine> #1
13:51:54 <lunabot>  luna: parse error on input `]'
13:51:58 * benmachine blinks
13:52:02 <netinho2lol> copumpkin: I have the function in a module like Module Something(blablabla) where ; forgot to include the function there
13:52:04 <netinho2lol> -_-
13:52:07 <shachaf> #random-error-please
13:52:09 <lunabot>  luna: A section must be enclosed in parentheses
13:52:10 <copumpkin> netinho2lol: aha :)
13:52:20 <rwx> in some scheme macros, one can place arguments in an arbitrary order using, e.g. f $1 $3 $2... is there a way to do this in haskell without using `flip`?
13:52:48 <EvanCarroll> hallo!
13:52:57 <ddarius> rwx: Use lambda.
13:53:24 <rwx> ddarius,  e.g.  (\a b c -> f b a c) ?
13:53:29 <EvanCarroll> so i'm tyring to write the examples in the RWH book
13:53:33 <EvanCarroll> I'm encoutering mega fail.
13:53:34 <CalJohn> rwx: yes
13:53:43 <EvanCarroll> I think I'm trying to use concepts i don't understand
13:53:54 <mreh> EvanCarroll: we've all done it
13:54:05 <mreh> practice makes perfect
13:54:19 <rwx> perfect practice does
13:54:30 * benmachine is somewhat concerned to find the third google result for hsgnutls is a release announcement about four years ago
13:54:38 <EvanCarroll> here i have a pastie
13:54:43 <EvanCarroll> when the site pull sup
13:54:43 <a1k0n> speaking of practice, does anyone want to rip apart my second haskell program ever?  http://codepad.org/Lgc7xKRQ
13:54:45 <rwx> i've recently come to believe in that, btw-- you need to build up the right habits (call them neural pathways), which you can then traverse at a greater and greater speed as time goes on
13:55:01 <EvanCarroll> http://pastie.org/719556
13:55:05 <a1k0n> it builds a huffman tree.  not sure how idiomatic it is.
13:55:12 <mreh> alk0n huffman coding?
13:55:14 <EvanCarroll> any idea of why i get len.hs:1:8: malformed class assertion
13:55:16 <mreh> oh okay
13:55:41 <ddarius> rwx: Practice practicing.
13:55:50 <rwx> :-)
13:55:59 <monochrom> replace (a, Num r ) by (Num r).
13:56:17 <EvanCarroll> ah ;)
13:56:28 <FunctorSalad> rwx: aka "learning"? ;)
13:57:20 <FunctorSalad> "we don't understand math, we just get used to it"
13:57:27 <monochrom> strictly speaking yes it's "learning". loosely speaking, people are so sloppy, they claim "I have learned ___" when they mean they spent 30 seconds reading about ___.
13:57:33 <mreh> Von Neuman said that
13:57:35 <EvanCarroll> http://pastie.org/719560
13:57:43 <EvanCarroll> what about that one
13:57:54 <EvanCarroll> I get     Couldn't match expected type `Double' against inferred type `t'
13:57:56 <mreh> i'm still waiting for my pastie
13:58:00 <osaunders> Why do I get this error? "io.hs:3:1: The last statement in a 'do' construct must be an expression" http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13369#a13369
13:58:07 <FunctorSalad> mreh: yeah had him in mind but wasn't certain
13:58:10 <ddarius> monochrom: What if 30 seconds of reading about X is adequate?
13:58:32 <monochrom> I have examples like C++ in mind.
13:58:53 <PeakerWork> ddarius: I doubt you can internalize much of anything in 30 seconds
13:59:00 <mreh> EvanCarroll, the result of sum xs is Double
13:59:08 <mreh> but you've specified a generic type
13:59:28 <mreh> it can't do the division, you've got a Double being divided by a generic type, which isn't implemented
13:59:47 <mreh> it might work if the signature is Num t => [t] -> t
13:59:50 <monochrom> @type (/)
13:59:58 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:00:02 <mreh> but / isn't implemented by Num
14:00:06 <FunctorSalad> 30 seconds of reading will do if it fits into some already-established thinking scheme, I suppose
14:00:19 <EvanCarroll> mreh: when i do `:t sum` it shows the result is generic not of any type
14:00:35 <EvanCarroll> how do i know it is of type double
14:00:41 <benmachine> osaunders: I'm not sure why you get that particular error, but your let statement is odd
14:00:55 <benmachine> not sure why you have a <- on the RHS of a let
14:00:58 <mreh> it's not Double sorry
14:01:15 <osaunders> benmachine: It is odd, yes.
14:01:17 <mreh> but (/) is not implemented by Num
14:01:29 <monochrom> EvanCarroll: Num is insufficient for division. I propose (Fractional t) => [t] -> t .  There are other options.
14:01:31 <mreh> monochrom just showed you
14:02:21 <EvanCarroll> hrm, is there a way to cast those two types to fractional for the division without changing the type sig?
14:02:25 <mreh> is there an integer division, must be
14:02:40 <monochrom> "div" is integer
14:02:46 <monochrom> or rather Integral
14:02:54 <benmachine> osaunders: so what are you trying to do with that let? or are you just saying that it's a weird error?
14:03:34 <monochrom> "Num is insufficient for division" includes that you can't even cast to something that can be divided.
14:03:39 <osaunders> benmachine: Well I thought that the result of something <- getLine should be a null tuple so I wanted to write some code to demonstrate that.
14:03:52 <benmachine> osaunders: something <- getLine doesn't have a result
14:04:00 <osaunders> Right.
14:04:01 <benmachine> not really
14:04:05 <osaunders> That might explain.
14:04:26 <osaunders> :t getLIne
14:04:28 <lambdabot> Not in scope: `getLIne'
14:04:31 <osaunders> :t getLine
14:04:32 <lambdabot> IO String
14:04:37 <benmachine> something <- getLine is syntactically the same as getLine >>= \something ->
14:04:47 <benmachine> i.e. it's not a complete expression
14:04:51 <benmachine> it is part of a do-block
14:05:05 <osaunders> I'm not familiar with >>= or \.
14:05:09 <benmachine> that error is still an odd one though
14:05:16 <benmachine> >>= is a function
14:05:19 <benmachine> :t (>>=)
14:05:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:05:27 <benmachine> it's basically what makes a monad a monad
14:05:29 <benmachine> that and return
14:05:34 <benmachine> \ is lambda
14:05:34 <osaunders> Hm, OK.
14:05:41 * hackagebot upload: AES 0.0.1 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
14:05:43 * hackagebot upload: AES 0.0.2 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
14:05:55 <benmachine> i.e. \x -> x + 3 is a function that takes an argument and adds three
14:05:58 <osaunders> OK, I think I'll leave this for now but thanks fort the info.
14:05:58 <benmachine> it's pretty important
14:06:09 <osaunders> OK, cool.
14:06:13 <benmachine> > (\x -> x == 3) 4
14:06:14 <lambdabot>   False
14:06:19 <ddarius> The basis of Haskell is the lambda calculus.  Understanding lambda is crucial.
14:06:21 <EvanCarroll> monochrom: mreh: Thanks for the help, the :t (/) was useful, know
14:06:33 <EvanCarroll> now I know how to figure out what my type sig needs to be
14:06:40 <monochrom> and takes only 30 seconds
14:07:07 <ddarius> monochrom: All you need is a definition of substitution and the beta rule and you know everything relevant.
14:07:29 <EvanCarroll> I still don't understand this though.
14:07:43 <EvanCarroll> Because I'm dividing the result of two expressoins that return generics
14:07:44 <osaunders> Mmm, \ is nice.
14:07:44 <EvanCarroll> not input directly.
14:08:00 <EvanCarroll> so i need to know how to cast the result of the expressions into Fractional for the division
14:08:10 <monochrom> We made lambda calculus sound too hard. The name and most presentations.
14:08:10 <EvanCarroll> or why I'm stuck on the wrong track
14:08:24 <medfly> it's just syntax for something else
14:08:28 <mauke> Fractional is not a type
14:08:39 <medfly> writing f x = x+2 and then using f 3 is like writing (\x->x+2) 3.
14:09:31 <osaunders> Yes, I get it.
14:09:40 <osaunders> Anonymous function.
14:09:45 <osaunders> Like fn in lisp.
14:09:51 <osaunders> of function() { } in JS.
14:09:57 <osaunders> *or
14:10:11 <ddarius> Like lambda in Lisp or Scheme.
14:10:15 <medfly> hehe
14:10:18 <medfly> that's better, ddarius :)
14:10:32 <osaunders> ddarius: Yeah. Actually I don't know Common Lisp only Clojure, a bit.
14:10:39 <benmachine> and in python
14:10:46 <monochrom> and in haskell
14:10:57 <netinho2lol> fffuuu
14:10:59 <benmachine> when I write python I put lambdas everywhere because that is how I think now
14:10:59 <medfly> of course
14:11:01 <netinho2lol> foldr (\ x -> (:) (x p)) [p] xs isn't working
14:11:10 <mauke> wtf
14:11:10 <benmachine> it irritates me that I have to use eight characters instead of one
14:11:19 <osaunders> Clojure has %(+ % 1) which is (\x->x+1) and also (fn [x] (+ x 1))
14:11:24 <netinho2lol> uhm, it's working
14:11:34 <netinho2lol> but not how I wanted it to work :D
14:11:40 <medfly> > (\(a,b) -> b) (1,2)
14:11:42 <lambdabot>   2
14:11:55 <netinho2lol> > snd (1,2)
14:11:57 <lambdabot>   2
14:12:01 <ddarius> benmachine: Use C#.
14:12:01 <shambler> DrScheme allows me to use λ by hitting ctrl+\
14:12:03 <shambler> \o/
14:12:04 * medfly only uses lambda calculus to do these kind of things.
14:12:07 <mreh> :t second
14:12:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
14:12:18 <benmachine> ddarius: can't I just use haskell? :P
14:12:20 <mauke> netinho2lol: <mauke> foldr (.) id
14:12:44 <ddarius> benmachine: C#, in some ways, has an even lighterweight syntax than Haskell.
14:12:49 <ddarius> \x -> x v. x => x
14:12:53 <netinho2lol> > foldr (.) id
14:12:55 <lambdabot>   []->
14:12:55 <lambdabot>    {()->()}
14:12:55 <lambdabot>  [{()->()}]->
14:12:55 <lambdabot>    {()->()}
14:12:55 <lambdabot>  [{()->()},{()->()}]->
14:12:57 <benmachine> but it has C in the same
14:12:57 <lambdabot>    {()->(...
14:13:01 <benmachine> therefore awful
14:13:04 <netinho2lol> :o
14:13:10 <benmachine> *name
14:13:14 <osaunders> lol
14:13:22 <osaunders> C# is a bad name for a language.
14:13:22 <ddarius> benmachine: C# is probably one of the nicest mainstream languages currently available.
14:13:38 <netinho2lol> mauke: the function is working, but I wanted the last item to become the first :)
14:13:39 <osaunders> Mmm
14:13:41 <benmachine> ddarius: fair enough
14:13:49 <mauke> netinho2lol: oh, ok
14:13:52 <mreh> can someone give me an example of "second" in action
14:13:59 <osaunders> ddarius: Yes, I have no reason to doubt htat.
14:14:03 <monochrom> 1 second
14:14:06 <monochrom> 2 seconds
14:14:08 <dmwit> > second succ ("hey", 32)
14:14:08 <benmachine> > second (+3) (3, 4)
14:14:10 <lambdabot>   (3,7)
14:14:10 <lambdabot>   ("hey",33)
14:14:10 <monochrom> 3 seconds
14:14:18 <monochrom> Oh, that second.
14:15:02 <benmachine> > second fst (4, (2, first snd))
14:15:04 <lambdabot>   (4,2)
14:15:47 * benmachine wonders if he can come up with a Kleisli example
14:15:58 <osaunders> benmachine: Huh, what is that doing?
14:16:15 <monochrom> It is confusing, that's what it's doing.
14:16:21 <osaunders> > (2, first snd)
14:16:22 <benmachine> osaunders: the first snd bit is a total decoy
14:16:23 <lambdabot>   (2,{(((),()),())->((),())})
14:16:34 <kmc> :t first snd
14:16:35 <lambdabot> forall a c d. ((a, c), d) -> (c, d)
14:16:44 <benmachine> all it's doing is applying fst to the (2, _) tuple
14:16:44 <osaunders> > second fst
14:16:46 <lambdabot>   {((),((),()))->((),())}
14:17:08 <dmwit> > second fst (a, (b, c))
14:17:08 <benmachine> > second fst :: (Int, (Int, Int)) -> (Int, Int)
14:17:10 <lambdabot>   (-3,(-3,-3))->
14:17:10 <lambdabot>    (-3,-3)
14:17:10 <lambdabot>  (-3,(-3,-2))->
14:17:10 <lambdabot>    (-3,-3)
14:17:10 <lambdabot>  (-3,(-3,-1))->
14:17:12 <lambdabot>    (-3...
14:17:14 <lambdabot>   (a,b)
14:17:17 <benmachine> heh
14:17:18 * osaunders is too scared and runs back to his friendly Learn a Haskell.
14:17:19 <dmwit> Mine was more enlightening. ;-)
14:17:26 <benmachine> 'twas
14:17:34 <ddarius> @src second
14:17:35 <lambdabot> Source not found. You type like i drive.
14:17:38 <kmc> > succ
14:17:39 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
14:17:46 <ddarius> @src (->) second
14:17:47 <lambdabot> second f = id *** f
14:17:56 <benmachine>  second f = \(x, y) -> (x, f y)
14:18:12 <kmc> @src Maybe (>>=)
14:18:13 <lambdabot> (Just x) >>= k      = k x
14:18:13 <lambdabot> Nothing  >>= _      = Nothing
14:18:15 * benmachine tries to work out why he wrote that instead of second f (x, y)
14:18:22 * Baughn is amazed by the number of people who popped up to send patches to haskell-mode. I'm almost spending more time verifying the patches than writing code of my own..
14:18:39 <kmc> @src [] (>>=)
14:18:40 <lambdabot> xs >>= f     = concatMap f xs
14:18:44 <ddarius> Baughn: That's what emacs users do.
14:18:53 <mreh> is -> a monad?
14:18:55 <EvanCarroll> http://stackoverflow.com/questions/1816993/haskell-dividing-num
14:19:00 <kmc> yes
14:19:04 <kmc> @src (->) (>>=)
14:19:05 <lambdabot> f >>= k = \ r -> k (f r) r
14:19:07 <benmachine> return = const
14:19:10 <copumpkin> (->) isn't a monad
14:19:13 <copumpkin> but ((->) a) is
14:19:15 <benmachine> oh
14:19:16 <benmachine> yes
14:19:18 <benmachine> true
14:19:19 <copumpkin> or more prettily, (a ->)
14:19:20 <Baughn> mreh: It /can/ be. By default it isn't, but those darned ((->) r) instances sneak in everywhere..
14:19:40 <benmachine> copumpkin: is there an extension to make the latter work?
14:19:45 <Twey> Heh, heh.
14:20:07 <Twey> Baughn: People have been hording them for years.  ;)
14:20:14 <medfly> EvanCarroll,
14:20:14 <medfly> len xs = 1 + len ( tail xs )
14:20:15 <copumpkin> benmachine: nope
14:20:17 <medfly> EvanCarroll, it doesn't get smaller.
14:20:25 <medfly> do you mean (x:xs) ?
14:20:43 <Baughn> Twey: So why did nobody else decide to take over first? I'm quite sure a lot of them are more qualified. >_>
14:20:52 <medfly> oh, nvm
14:21:05 * medfly actually realised "oh, he uses tail" then still asked
14:21:06 <benmachine> take over what
14:21:10 <dmwit> InfixTypeOperators ?
14:21:11 * medfly hits head
14:21:34 <benmachine> dmwit: it's not infix type operators that's missing, it's type operator sections
14:21:43 <dmwit> quite
14:21:54 <FunctorSalad> benmachine: haskell-mode
14:22:00 <benmachine> oh
14:22:04 <benmachine> right
14:22:11 * benmachine makes the connection
14:22:24 <benmachine> I thought we were still talking about function monads
14:22:35 <Twey> Heh
14:22:38 <EvanCarroll> medfly: I saw every other implimentation use x:xs, so i wrote it differently
14:22:44 <EvanCarroll> medfly: =)
14:22:52 <monochrom> I use xs:x
14:22:57 <benmachine> hah
14:22:57 <medfly> hehe
14:23:30 <medfly> it might be just me but I rarely write type signatures, I just have ghci figure them out for me
14:23:42 <medfly> everything just works!
14:23:42 <benmachine> I usually write them
14:24:00 <benmachine> because occasionally your function can typecheck but not in the way you wanted
14:24:20 <benmachine> the error messages are sometimes clearer if ghc knew what you meant
14:24:27 <medfly> I think that ghci making sense of it the wrong way is less common than me making sense of it the wrong way =)
14:24:28 <medfly> <- stupid
14:24:33 <EvanCarroll> right, and if you know ho to do the work, it is often second nature and easy
14:25:00 <benmachine> it's not always easy
14:25:13 <benmachine> but if it's hard it is probably also useful
14:25:21 <osaunders> This is how much I love Haskell: http://blogs.warwick.ac.uk/images/msbrackenridge/2007/05/18/i_love_this_thread.jpg
14:25:31 <medfly> awww
14:25:33 <medfly> that's so cute
14:25:42 <Null-A> why is haskell faster than GNU GCC in some benchmarks?
14:25:46 <Null-A> how is that possible
14:25:54 <benmachine> why shouldn't it be?
14:25:55 <osaunders> Lazy-eval?
14:26:01 <Twey> Haha, that made me smile
14:26:06 <benmachine> lazy evaluation doesn't generally help with speed
14:26:09 <ray> you say that like gcc's a good compiler or something, too
14:26:13 <benmachine> it helps with other things but not speed
14:26:28 <akappa> Null-A, because haskell is declarative, so there are (in principle) more chances to make smart optimizations
14:26:33 <osaunders> benmachine: Really, isn't doing less like the core principle of performance?
14:26:35 <Null-A> couldn't the C implementation just mimic lazy eval if it needed to?
14:26:48 <Null-A> akappa: hm
14:26:50 <Twey> Null-A: Not really
14:26:54 <benmachine> osaunders: but if you're doing a program for a benchmark it will probably be doing the minimum possible anyway
14:27:10 <medfly> "how come things aren't as smart as Haskell?"
14:27:13 <Twey> Not without exceedingly ugly and non-idiomatic code (which defeats the point of the benchmark)
14:27:19 <benmachine> the thing with laziness is it makes programs that a sane person would write work together better
14:27:19 <Twey> You could apply Greenspun's to it, I suppose :þ
14:27:20 <shachaf> I undertstand that GHC's optimizer "cheats" in thread-ring.
14:27:33 <Null-A> oh ?
14:27:37 <osaunders> benmachine: http://www.haskell.org//pipermail/haskell/2006-June/018127.html
14:27:37 <Twey> shachaf: How's that?
14:27:50 <shachaf> I don't know; just a vague rumor.
14:28:07 <Twey> I don't think it does…
14:28:19 <Twey> OS threads are never going to be faster than green threads, anyway :þ
14:28:37 <osaunders> benmachine: From that link -> "Then along came GHC, which began achieving enormous wins over the other languages because the lazy nature of the evaluation threw out  the unneeded calculations"
14:28:53 <shachaf> Oh, gcc beats GHC in that benchmark now. It didn't use to.
14:28:57 <osaunders> And this guy was writing benchmarks.
14:29:00 <benmachine> osaunders: yeees, except that we also hear that he's manufacturing deliberately slow programs
14:29:13 <benmachine> so that he can get runtimes in seconds instead of microseconds
14:29:26 <dons> shachaf? i don't believe that is true.
14:29:47 <dons> osaunders: that was back in 2003 or so, at which point they changed the benchmarks.
14:29:48 <shachaf> dons: That it cheats?
14:29:54 <dons> it doesn't.
14:29:57 <shachaf> OK.
14:30:00 * shachaf trusts dons.
14:30:20 <shachaf> It was only something someone said in this channel anyway.
14:30:22 <dons> the lazy eval thing was a long time ago too. 7 years or so, when there were some benchmarks that didn't require output, so ghc didn't do them.
14:30:40 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
14:30:43 <dons> and we still win threadring
14:30:57 <Null-A> wow the go compiler is there =)
14:31:00 <Null-A> that was fast
14:31:23 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=go&box=1
14:31:27 <osaunders> Meh, I don't really care. I used to program in PHP and Ruby which are both mega slow compared to Haskell.
14:31:27 <dons> mwhaha
14:31:30 <c_wraith> someone finally marked that recent gcc threadring as illegal?
14:31:33 <benmachine> we won using only one core, apparently
14:31:58 <benmachine> in fact all the top five used one core
14:32:00 <osaunders> *I'm used to programming
14:32:06 <dons> its not a parallel benchmark, and ghc's runtime is better at not migrating threads unnec.
14:32:10 <benmachine> the sixth used 5% of one other
14:32:11 <dons> the go runtime is a bit naive there.
14:32:15 <c_wraith> Ah, I was looking at http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all&box=1
14:33:11 <dons> oh, that's new.
14:33:19 <dons> the greenthreads C version is pretty new.
14:33:36 <Null-A> ah
14:34:20 <Twey> Green threads in C?
14:35:15 <c_wraith> The thing that strikes me about that C implementation is that it explicitly doesn't bother with thread safety, because it knows it doesn't matter for that benchmark
14:35:56 <nolrai_FG> Is there a way to give type defs a kind anotation?
14:38:56 <i_am_neuron> I'm trying to use taglib library and when setting a dependency in Cabal, the build fails: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5189#a5189 What I'm doing wrong?
14:39:33 <i_am_neuron> Haven't found this pkg-config anywhere
14:39:45 <osaunders> Is () called a 0-tuple or a null-tuple?
14:39:46 <dankna> pkg-config is a gnu project
14:39:56 <Peaker> osaunders, Unit type, maybe?
14:39:56 <osaunders> Or just null?
14:40:08 <osaunders> Oh right, unit.
14:40:10 <osaunders> :t unit
14:40:12 <lambdabot> Not in scope: `unit'
14:40:14 <osaunders> :t Unit
14:40:15 <lambdabot> Unit
14:40:21 <Twey> Generally just ‘unit’
14:40:26 <Twey> It's written (), but read ‘unit’
14:40:30 <Twey> In both type and value
14:40:36 <osaunders> OK.
14:40:40 <osaunders> So what's Unit then?
14:40:45 <Twey> No idea.
14:40:49 <osaunders> lol
14:40:50 <i_am_neuron> dankna: I see, so this is not a Haskell package
14:40:57 <osaunders> @src Unit
14:40:58 <lambdabot> Source not found. Do you think like you type?
14:41:01 <dankna> correct, it's not
14:41:09 <dankna> it's used to configure packages and help them find each other when building
14:42:01 <osaunders> And (t, t1) is a pair and (t, t1, t2) a triple.
14:42:35 <CalJohn> osaunders: i'm not an expert, but I can't see anything intuitively wrong with thinking of () as the 0-tuple
14:42:49 <Twey> There's nothing wrong with it
14:43:34 <EvanCarroll> You know what would be a nifty idea for hackagebot
14:43:39 <CalJohn> i wish i could remember why it's called unit, someone told me once...
14:43:53 <EvanCarroll> itf it used the stackoverflow rss to announce new questions with the haskell tag
14:44:06 <Peaker> CalJohn, because its the 1 type, which has 1 value..
14:44:20 <EvanCarroll> you can get an rss feed for just the haskell tag (I'm subscribed)
14:44:22 <CalJohn> Peaker: the 1 type?
14:44:25 <Twey> http://en.wikipedia.org/wiki/Unit_type
14:44:38 <osaunders> So there's no function to get the size of a tuple. Is that because each size of tuple is a different type?
14:44:48 <CalJohn> osaunders: yes
14:45:05 <shachaf> osaunders: There can be a function if you use a type class.
14:45:10 <shachaf> osaunders: But it wouldn't be very helpful.
14:45:12 <Peaker> CalJohn, Using Either (+) and tuples (*) and 1 ( () )  and 0 (The empty type) and functions (^) -- you can build a type algabraically.. its useful to have "1" and "0" in an arithmetic expression :)
14:45:48 <j2j> Hello gens, I have a beginner question -- is there a function in ghc base library findM, similiar to Data.List.find, which has signature -  Monad m => (a -> m Bool) -> [a] -> m (Maybe a)?
14:46:44 <cnwdup> @ty return . find
14:46:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> m ([a] -> Maybe a)
14:46:51 <bd_> @hoogle  Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
14:46:51 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:46:52 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
14:46:52 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
14:47:04 <BONUS> i don't think there is
14:47:14 <bd_> hmm, hoogle web interface is down
14:47:14 <cnwdup> @ty (\p xs -> return . find p xs)
14:47:17 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> [a] -> Maybe (m a)
14:47:20 <medfly> hayoo
14:47:51 <papna> Hey! It's the lunatic who wrote LYAPFGG!
14:48:03 * BONUS hides under a table!
14:48:03 <osaunders> db_: has been for days.
14:48:03 <Peaker> P?
14:48:06 <medfly> PFGG?
14:48:16 <BONUS> learn you a paskell
14:48:24 <medfly> oh
14:48:26 <BONUS> from ghc 6.12 on, haskell is called paskell
14:48:27 <Peaker> Pascal-Haskell hybrid
14:48:33 <medfly> what
14:48:34 <BONUS> for some added confusion
14:48:38 <osaunders> :/ that sounds bad.
14:48:39 <medfly> why is it called paskell
14:48:51 <medfly> I mispronounce Haskell pretty bad, so this doesn't sound good.
14:49:06 <BONUS> to strenghten its image in the corporate world (and hollywood)
14:49:08 <Twey> Haha
14:49:19 <CalJohn> medfly: they decided to make the people who say "Hascal" halfway
14:49:23 <benmachine> the p is for phunctional
14:49:26 <jlouis> If you are about to succeed, you change the name of the programming language
14:49:34 <benmachine> heh
14:49:39 * papna can't type.
14:49:46 <osaunders> I pronounce Haskell as "OMG that's some funky shit!" and then I had to play that track by the Prodigy.
14:49:46 <medfly> is this an elaborate joke by the way
14:49:48 <benmachine> CalJohn: I have that problem :(
14:49:54 <benmachine> medfly: wouldn't call it elaborate
14:49:55 <BONUS> medfly: yes :)
14:49:58 <medfly> oh, okay
14:50:06 <medfly> had to check
14:50:24 <osaunders> phunctional is a nice word. I'm going to say that now. Thanks benmachine.
14:51:08 <j2j> BONUS: do you know why there is no findM function?
14:51:14 <papna> Haskell : Hacker :: Phunctional : Phreaker ?
14:51:35 <papna> Where :: is standardised-test syntax, not Haskell syntax.
14:51:43 <osaunders> http://www.youtube.com/watch?v=fc07IVuw61o
14:51:54 <Peaker> "Javascript" was a successful rename
14:51:57 <netinho2lol> can someone give me an example of using >>= instead of concatMap
14:52:07 <Botje> netinho2lol: >>= *IS* concatMap :)
14:52:27 <BONUS> j2j: there are a lot of standard functions that could be monadic (like unfoldrM, whenM) but aren't defined in the standard libraries
14:52:30 <medfly> what was javascript before, Peaker?
14:52:33 <EvanCarroll> I'm still looking for a good answer to http://stackoverflow.com/questions/1816993/haskell-dividing-num
14:52:34 <BONUS> so i assume findM is one of them
14:52:37 <CalJohn> Peaker: tell that to ##java
14:52:39 <Peaker> [1,2,3] >>= \x -> [x,x*2]
14:52:51 <CalJohn> medfly: it was scheme ;)
14:52:55 <mauke> medfly: livescript
14:52:57 <medfly> what
14:53:00 <netinho2lol> Botje: I 'know', but i can't seem to make it work :)
14:53:10 <mauke> java was oak
14:53:35 <netinho2lol> java is fine too
14:54:08 <BONUS> findM is easy to define though
14:54:12 <mauke> EvanCarroll: your len is genericLength, btw
14:54:13 <Peaker> "The language's name is the result of a co-marketing deal between Netscape and Sun, in exchange for Netscape bundling Sun's Java runtime with their then-dominant browser"
14:54:17 <jlouis> netinho2lol: yes, and Turing Machines are wonderful for implementing compilers
14:54:19 <j2j> BONUS: So everyone has to write their own? Would not it make sense to create a package of common monadic functions?
14:54:31 <Baughn> j2j: We've got.. a few such packages
14:54:36 <EvanCarroll> mauke: Yea, I'm sure it is in the prelude somewhere
14:54:39 <Baughn> j2j: It would be a good thing to merge them, I suppose. :P
14:54:44 <BONUS> j2j: yeah there are probably some packages out there for that
14:54:54 <BONUS> it would be cool to include one in the standard library
14:55:21 <jmcarthur> Botje: actually, isn't it =<< that's concatMap?
14:55:24 <j2j> But Hayoo does not return any hits when I search for findM. What packages do you have in mind?
14:55:27 <BONUS> @let findM p [] = return Nothing; findM p (x:xs) = p x >>= \t -> if t then return $ Just x else findM p xs
14:55:29 <lambdabot>  Defined.
14:55:42 <BONUS> > findM (const [True, False]) [1,2,3]
14:55:43 <lambdabot>   [Just 1,Just 2,Just 3,Nothing]
14:55:57 <Botje> jmcarthur: true enough. conceptually the same! :)
14:56:03 <jmcarthur> netinho2lol: try reversing the arguments to >>= compared to concatMap
14:56:37 <mauke> EvanCarroll: basically, you can't do that because there's no way to convert an arbitrary instance of Num to Double
14:56:38 <BONUS> > [1,2,3] >>= replicate 3
14:56:39 <lambdabot>   [1,1,1,2,2,2,3,3,3]
14:57:33 <j2j> BONUS: Thanks.
14:57:50 <EvanCarroll> mauke: so what do you do? what is the best solution?
14:57:50 <BONUS> out of interest, which monad are you planning to use it with?
14:58:04 <thunderbolt> Anyone know of a tutorial kicking around on how to do simulations in Haskell? Perhaps using a state monad or some such?
14:58:12 <mauke> EvanCarroll: what's the problem?
14:58:21 <netinho2lol> jmcarthur , BONUS : weird
14:58:49 <jmcarthur> netinho2lol: if you think it's weird, i recommend (=<<) instead of (>>=). it's my preference as well
14:59:01 <EvanCarroll> mauke: obviously trying to "convert an arbitrary instance of Num to Double"
14:59:08 <netinho2lol> what's the difference between them?
14:59:12 <BONUS> [1,2,3] >>= replicate 3 is like: for every number in [1,2,3], replicate it 3 times
14:59:16 <jmcarthur> netinho2lol: argument order
14:59:28 <jmcarthur> > replicate 3 =<< [1,2,3]
14:59:30 <lambdabot>   [1,1,1,2,2,2,3,3,3]
14:59:31 <mauke> EvanCarroll: well, that's impossible, so there is no solution
14:59:46 <EvanCarroll> to write a generic average function that accepts generic types of Num?
14:59:50 <BONUS> > [1,2,3] >>= replicate 3 >>= (\x -> [x,x+1])
14:59:51 <netinho2lol> stretch = concatMap . replicate
14:59:51 <lambdabot>   [1,2,1,2,1,2,2,3,2,3,2,3,3,4,3,4,3,4]
14:59:53 <mauke> EvanCarroll: right
15:00:16 <BONUS> and this is like: for every number in [1,2,3] replicate it 3 times and then for every resulting number, keep it and also add one to it
15:01:01 <EvanCarroll> mauke: so if all the functions are generic in the prelude, then you could never write a generic average function?
15:01:16 <mauke> I don't understand that question
15:01:17 <EvanCarroll> if true, that would seem like an incredbily limiting type system.
15:01:18 <Axman6> huh?
15:01:34 <EvanCarroll> Axman6: http://stackoverflow.com/questions/1816993/haskell-dividing-num
15:01:34 <jmcarthur> what is a generic average?
15:01:51 <nolrai_FG> The problem is that you want to do differnt things to differnt types in a weird way.
15:02:00 <EvanCarroll> jmcarthur: an average functions that accepts anything of typeclass num
15:02:03 <mauke> EvanCarroll: you can't write a generic average function because integers cannot be divided like that
15:02:12 <Axman6> EvanCarroll: and gives you what?
15:02:21 <EvanCarroll> Axman6: a double,
15:02:30 <mauke> EvanCarroll: what if the input is complex numbers?
15:02:30 <jmcarthur> :t \xs → sum xs /  length xs
15:02:31 <lambdabot> parse error on input `???'
15:02:32 <Axman6> well how does that make sense?
15:02:36 <ddarius> mauke: Curse you mauke.
15:02:37 <jmcarthur> :t \xs -> sum xs /  length xs
15:02:38 <lambdabot>     No instance for (Fractional Int)
15:02:39 <lambdabot>       arising from a use of `/' at <interactive>:1:7-25
15:02:39 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
15:02:48 <jmcarthur> :t \xs -> sum xs / fromIntegral (length xs)
15:02:50 <lambdabot> forall a. (Fractional a) => [a] -> a
15:03:01 <BONUS> :t \xs -> sum xs / genericLength xs
15:03:02 <lambdabot> forall a. (Fractional a) => [a] -> a
15:03:28 <nolrai_FG> :t \xs -> fromRational (sum xs % lenght xs)
15:03:30 <lambdabot> Not in scope: `lenght'
15:03:33 <jmcarthur> :t \xs -> fromRational $ sum xs / genericLength xs ∷ Fractional a => [a] -> Double
15:03:34 <nolrai_FG> :t \xs -> fromRational (sum xs % length xs)
15:03:34 <lambdabot> parse error on input `=>'
15:03:35 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
15:03:35 <lambdabot>     In the second argument of `(%)', namely `length xs'
15:03:35 <lambdabot>     In the first argument of `fromRational', namely
15:03:44 <BONUS> also for @pl victory: liftA2 (/) sum genericLength
15:04:02 <jmcarthur> :t \xs -> fromRational $ sum xs / genericLength xs :: Fractional a => [a] -> Double
15:04:03 <nolrai_FG> :t \xs -> length xs
15:04:03 <lambdabot> forall a. [a] -> Int
15:04:04 <lambdabot>     Could not deduce (Fractional ([a] -> Double))
15:04:04 <lambdabot>       from the context (Fractional a)
15:04:04 <lambdabot>       arising from a use of `fromRational' at <interactive>:1:7-18
15:04:26 * jmcarthur destroys his autoreplace macros
15:04:46 <EvanCarroll> how are 40 lines of error messages supposed to help me understand what to do?
15:04:51 <mauke> EvanCarroll: they aren't
15:04:59 <dons> EvanCarroll: are you using ghc?
15:04:59 <mauke> EvanCarroll: and your question was already answered
15:05:08 <EvanCarroll> dons: yes, ghci
15:05:23 <EvanCarroll> mauke: lets go back to not talking to each other =)
15:06:06 <mauke> EvanCarroll: how about no
15:06:08 <dons> do you understand the problem with Num and (/)0 now?
15:06:11 <Axman6> EvanCarroll: i find your way or learning by complaining and not really listening to peoples answers to be quite strange
15:06:25 <dons> :t (/)
15:06:26 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:06:33 <dons> (/) needs Fractional. You've stated that only Num is available.
15:06:35 <dons> hence the type error.
15:07:03 <dons> make sense?
15:07:05 <EvanCarroll> dons: I think I understand the problem.
15:07:11 <ddarius> EvanCarroll: Why not write an even more generic average: average :: [a] -> Double
15:07:17 <mauke> heh
15:07:19 <jmcarthur> :t \xs -> realToFrac $ sum xs / genericLength xs :: Fractional a => [a] -> Double
15:07:20 <lambdabot>     Could not deduce (Fractional ([a] -> Double))
15:07:20 <lambdabot>       from the context (Fractional a)
15:07:20 <lambdabot>       arising from a use of `realToFrac' at <interactive>:1:7-16
15:07:31 <mauke> jmcarthur: please fail in private
15:07:36 * jmcarthur fails
15:07:40 <Axman6> heh
15:07:42 <dons> EvanCarroll: so you need a conversion function that will transform a Num to a Fractional
15:08:03 <jmcarthur> this is something i don't normally do. why would you want to restrict the result to Double?
15:08:04 <dons> in this case, specifically, a Double
15:08:14 <EvanCarroll> right, and my understanding is that it is impossible per the channel, but smeone on stackoverflow just came up with fromRational ((sum xs) % (leng xs))
15:08:26 <monochrom> @type fromRational
15:08:27 <mauke> :t (%)
15:08:28 <lambdabot> forall a. (Fractional a) => Rational -> a
15:08:29 <jmcarthur> it's possible, and easier than i'm making it
15:08:29 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
15:08:37 <mauke> EvanCarroll: % requires integers
15:08:45 <Axman6> RAGE! i want my uni results damnit!
15:08:56 <netinho2lol> okay...
15:08:58 <monochrom> does not transform a Num to a Fractional
15:08:59 <ddarius> Axman6: I want my transcripts.
15:09:04 <kmc> i want a pony
15:09:08 <netinho2lol> this conversation with EvanCarroll about averages and stuff
15:09:08 <dons> or you could just leave the type signatures off
15:09:15 <netinho2lol> we had this conversation before
15:09:17 <monochrom> I mean, gee I didn't know that this channel allows giving wrong/irrelevant answers.
15:09:18 <dons> and then infer: avg :: (Fractional a) => [a] -> a
15:09:31 <netinho2lol> with EvanCarroll
15:09:48 <monochrom> "oh hi you can use fromIntegral to convert numbers to strings"
15:09:52 <netinho2lol> holy crap, dons, the haskell guy from reddit
15:09:56 <benmachine> heh
15:10:07 <benmachine> monochrom: sometimes people are going to make mistakes
15:10:33 <dons> netinho2lol: from reddit?
15:10:44 <ddarius> instance Num [Char] where ...
15:10:45 <Axman6> netinho2lol: he makes his way down from the holy mountain occasionally to help us when we are in need
15:11:06 <Axman6> (the holy mountain being Galois mountain)
15:11:08 <dons> come down and bang some heads together and tell you guys to be nice.
15:11:13 <benmachine> I'd rather people felt okay about giving help when they weren't sure than we had no false advice ever
15:11:15 <netinho2lol> dons: yeah you're like super
15:11:16 <Axman6> heh
15:11:23 <dons> kids these days.
15:11:47 * dons goes back to his vacation
15:11:56 <ddarius> benmachine: Incorrect advice creates more work for everyone.
15:12:07 <benmachine> ddarius: correct advice creates less work for everyone
15:12:14 <benmachine> you can't have the latter without risking the former
15:12:24 <ddarius> benmachine: In most cases you can check your answers.
15:12:43 <benmachine> true
15:13:07 <benmachine> it's not always obvious that you need to, though
15:13:22 <ddarius> benmachine: It becomes obvious pretty quick.
15:13:22 <benmachine> unless you assume that you always should
15:13:35 <benmachine> but if you believe you always need to check everything it's easier to just not say anything
15:13:38 <ddarius> If you are unsure, then certainly it wouldn't hurt for you to do some basic checking.
15:14:12 <benmachine> personally I think that yes you should check your answers, or at least present them with the appropriate(ly low) level of authority
15:14:22 <benmachine> but if you get something wrong it's not the end of the world
15:14:40 <ddarius> benmachine: I agree with both.  People who fail to do both really annoy me.
15:14:41 <benmachine> and probably someone will be around to put you right
15:14:57 <blackh> benmachine: It could be the end of the world if you are working on a machine to destroy the world.
15:15:09 <ddarius> blackh: Not if the advice is incorrect.
15:15:29 <blackh> ddarius: Well, maybe you want to hold the world to random, and you don't want it to go off yet!
15:15:35 <benmachine> heh
15:15:47 <benmachine> if that situation arises I will admit to being wrong
15:15:49 <benmachine> and not a moment sooner
15:16:02 * copumpkin is wrong
15:16:05 <copumpkin> (in general)
15:16:12 * benmachine hugs copumpkin 
15:16:21 <EvanCarroll> dons: i re: on so
15:16:27 <copumpkin> so if you ever make a mistake, just blame it on me and all will be well
15:16:30 <ddarius> benmachine: It's not uncommon for some bad advice (occasionally even appropriately presented advice) to cause a big mess before and after someone steps in to correct it.
15:16:43 <benmachine> ddarius: I assert that it is
15:16:49 <benmachine> without any sort of evidence
15:16:55 <benmachine> because that is how I roll
15:17:19 <ddarius> @remember copumpkin It's my fault.
15:17:20 <lambdabot> I will never forget.
15:17:25 <copumpkin> lol
15:17:47 <benmachine> you can believe what you like but I think #haskell is successful because it is welcoming and should as a consequence be tolerant of error
15:17:57 <kmc> @quote fault
15:17:57 <lambdabot> mmorrow says: gah, i'm so used to haskell i forgot a return stmt in C and was trying to figure out where the  segfault was happening for 20 minutes
15:18:11 <kmc> @quote segfault
15:18:12 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
15:18:39 <kmc> @quote unsafe
15:18:39 <lambdabot> roconnor says: or maybe unsafeHead is even more unsafe than head.
15:18:43 <kmc> @quote unsafe
15:18:43 <lambdabot> Philippa says: plus who wants to get unsafeHead?
15:18:51 <copumpkin> :O
15:18:51 <cnwdup> @pl (\n p -> addItemA (item n p))
15:18:53 <lambdabot> (addItemA .) . item
15:22:04 <cnwdup> Is there a type in the hierarchical libraries to store the a date? I just want to store the date, not the time of the specific day and cannot find anything.
15:22:24 <cnwdup> s/ a//
15:22:33 <osaunders> Do ppl use list comprehensions much?
15:22:40 <ddarius> osaunders: Some.
15:22:47 <ddarius> I tend not to use them that much.
15:22:59 <blackh> osaunders: I've been using them a lot lately.
15:23:12 <dmwit> cnwdup: I looked around recently for something like that and didn't see anything.
15:23:16 <benmachine> list comprehensions are easily translatable into do-notation, and the latter is more powerful
15:23:37 <dmwit> cnwdup: I lied.
15:23:42 <dmwit> cnwdup: I wanted something more specific.
15:23:47 <dmwit> cnwdup: Try this: http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar.html#t%3ADay
15:23:52 <osaunders> benmachine: Can you give an example?
15:24:02 <benmachine> osaunders: give me an example of a list comprehension and I'll do it
15:24:06 <Axman6> holy crap, i just had my best semester ever at uni :D two high distinctions and two distinctions
15:24:08 <cnwdup> dmwit, how would I obtain the current date with that?
15:24:08 <benmachine> uhm, so to speak
15:24:09 <dibblego> filter cannot run on any Monad
15:24:18 <osaunders> I have one here: [ (a,b,c) | c <- [1..3], b <- [1..3], a <- [1..3] ]
15:24:34 <dmwit> dibblego: No, but guard works on any MonadPlus.
15:24:40 <dibblego> dmwit, right
15:24:49 <copumpkin> osaunders: that could be done with liftA3
15:24:52 <dibblego> do c <- [1..3]; b <- [1..3]; a <- [1..3]; return (a, b, c)
15:24:53 <blackh> Axman6: Well, that's very good!
15:25:00 <copumpkin> > liftA3 (,,) [1..3] [1..3] [1..3]
15:25:01 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
15:25:14 <Axman6> > do { a <- [1..3]; b <- [1..3]; c <- [1..3]; return (a,b,c)}
15:25:16 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
15:25:17 <benmachine> dibblego: is right
15:25:27 <Axman6> :t join . join
15:25:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
15:25:29 <jleedev> > replicateM 3 [1..3]
15:25:30 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
15:25:33 <Axman6> blackh: yeah :D
15:25:35 <netinho2lol> jmcarthur: stretch = concatMap . replicate -> stretch = (=<<) . replicate
15:25:38 <netinho2lol> :D
15:25:41 <dmwit> cnwdup: You probably need to roundtrip through String (with formatTime/readTime).
15:25:44 <dmwit> =(
15:25:57 <Axman6> > join . join . liftM3 $ [1..3]
15:25:59 <lambdabot>   Couldn't match expected type `a3 -> a3 -> a3 -> r'
15:25:59 <lambdabot>         against inferred...
15:26:03 <cnwdup> dmwit, ok. Thanks.
15:26:03 <Axman6> > join . join liftM3 $ [1..3]
15:26:05 <lambdabot>   Couldn't match expected type `(a3 -> a3 -> r) -> a3 -> a3 -> r'
15:26:05 <lambdabot>         aga...
15:26:08 <Axman6> :(
15:26:10 <BONUS> :r
15:26:11 <jmcarthur> :t concatMap . replicate
15:26:12 <BONUS> whoops
15:26:12 <lambdabot> forall b. Int -> [b] -> [b]
15:26:13 <benmachine> Axman6: seem to have lost the (,,)
15:26:26 <Axman6> benmachine: oh of course :(
15:26:31 <benmachine> > join . join . liftA3 (,,) $ [1 .. 3]
15:26:33 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m b)
15:26:36 <benmachine> oh bugger it
15:26:37 <Axman6> > join . join (liftM3 (,,)) $ [1..3]
15:26:39 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a3)
15:26:43 <copumpkin> not quite right
15:26:59 * benmachine loses interest
15:27:00 <copumpkin> > (join . join) (liftM3 (,,)) $ [1..3]
15:27:01 <Axman6> blackh: i hear you're giving a talk soon about parallel haskell
15:27:02 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
15:27:27 <jmcarthur> netinho2lol: right! although, unless the goal is more generic code, i like the appearance of the original better ;)
15:28:05 <netinho2lol> jmcarthur: the goal is to stop hlint's bitching :P
15:28:15 <dibblego> > (join . join . liftA3 $ (,,)) [1..3]
15:28:16 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
15:28:23 <jmcarthur> haha
15:28:35 <jmcarthur> netinho2lol: i disagree with hlint sometimes
15:28:52 <benmachine> me too
15:28:52 <mauke> > replicateM 3 [1..3]
15:28:53 <Axman6> yeah hlint suggests some odd stuff
15:28:54 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
15:29:02 <dmwit> mauke: It's been suggested and ignored already. =)
15:29:04 <benmachine> I think they are meant to be suggestions
15:29:10 <benmachine> i.e. it's known that sometimes they are nonsense
15:29:23 <blackh> Axman6: I am! I thought I'd better do it because it'd certainly be a shame to have a talk about parallelism without Haskell.
15:29:40 <netinho2lol> give me an example of nonsense
15:29:40 <Axman6> how the hell did i get 80% in relatio0nal databases. i hated most of that course :D
15:29:48 <Axman6> blackh: yes indeed
15:29:58 <poe> Data.Data is magic.
15:30:01 <blackh> Axman6: I'm sort of doubling up with this guy Paul Bone who's doing research into automatic parallelization in Mercury, which sounds very interesting indeed!
15:30:19 <Axman6> indeed :
15:30:20 <Axman6> )
15:30:22 <netinho2lol> > :type replicateM
15:30:24 <lambdabot>   <no location info>: parse error on input `:'
15:30:28 <netinho2lol> > @type replicateM
15:30:29 <lambdabot>   <no location info>: parse error on input `@'
15:30:33 <Axman6> :t replicateM
15:30:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:30:37 <ddarius> Automatic parallelization in logic languages sounds soo 1970's.
15:30:38 <netinho2lol> fuu
15:30:56 <netinho2lol> that's the deal with replicateM
15:31:33 <PizzaMan420> suppose I have a list of (x,y) pairs, what's the easiest way to calculate (max x - min x, max y - min y)
15:31:38 <blackh> Axman6: I need to see for myself how the "mainstream" approaches parallelism. I can't see why you wouldn't just use a pure language, you see. :)
15:31:52 <dmwit> PizzaMan420: Sounds suspiciously homework-y.
15:32:28 <dmwit> PizzaMan420: But at a high level, I suggest working out how to get the (max x - min x) value just for a single list of values first.
15:32:38 <dmwit> PizzaMan420: It would be a helpful first step in writing the function you want.
15:32:49 <Axman6> blackh: agreed. after doing my concurrent and distributed systems course this semester, it seems that parallelism in C etc. would not be fun (though, OpenMP is supposed ot be somewhat nice)
15:32:57 <PizzaMan420> thanks
15:33:28 <kmc> PizzaMan420, i like your username
15:33:33 <osaunders> "When writing our own functions, we can choose to give them an explicit type declaration. This is generally considered to be good practice except when writing very short functions." Why is that? Omit type declarations makes functions more polymorphic.
15:33:42 <benmachine> no it doesn't
15:33:44 <blackh> Axman6: I'm helping Paul Bone by explaining purity to the audience so he can spend 10 mins talking about his research rather than explaining purity
15:33:54 <kmc> osaunders, not if you give a polymorphic type declaration
15:34:01 <benmachine> you give them a polymorphic type declaration
15:34:02 <Axman6> osaunders: nothing wrong with that
15:34:07 <benmachine> it makes it easier for you to keep track of what they do
15:34:16 <benmachine> and easier for other people to understand
15:34:22 <osaunders> Isn't it just redundant though?
15:34:23 <jleedev> osaunders: Writing a type declaration can prevent a function from being monomorphic.
15:34:27 <Twey> osaunders: It makes sure that the type you think it has is the type the compiler thinks it has.
15:34:28 <ddarius> osaunders: It's typically considered good practice for all (most) top-level declarations regardless of size.
15:34:35 <kmc> osaunders, it's machine-checkable documentation
15:34:40 <Twey> (and serves as documentation)
15:34:41 <Axman6> osaunders: the reason they're often left off for small functions is that it's usually easy to see what the type is anyway
15:34:54 <dmwit> osaunders: It's good practice because it makes it more human-readable; you are correct that it is usually redundant for the compiler.
15:34:56 <kmc> it can result in better type errors
15:35:05 <osaunders> OK.
15:35:10 <osaunders> Thanks for all that.
15:35:15 <mauke> :t join (***) (liftA2 (-) maximum minimum) . unzip
15:35:17 <lambdabot> forall b. (Num b, Ord b) => [(b, b)] -> (b, b)
15:35:50 <benmachine> liftA2 (-) maximum minimum = (abs .) . (-)?
15:35:59 <Axman6> >_<
15:35:59 <Twey> osaunders: If you use a function without a type signature wrongly, the compiler will often infer a wrong type for the function from that, and then error confusingly on a correct usage later on.
15:36:20 <mauke> benmachine: unlikely
15:36:36 <Twey> If you give it a type signature, however, the compiler can tell which usage fails to match the expected type, and highlight that as the incorrect one.
15:36:45 <benmachine> mauke: oh yeah, was thinking of max/min
15:36:53 <osaunders> Twey: Makes sense.
15:37:21 <osaunders> Omit type declarations is sort of like seat-of-pants programming then.
15:37:25 <osaunders> *Omitting
15:37:27 <Twey> A bit, yeah.
15:37:52 <osaunders> Well, maybe I'm that kind of guy! :-)
15:37:56 <Twey> Hehe.
15:38:00 <osaunders> OK, no, I'm really not.
15:38:16 <osaunders> Maybe I am actually.
15:38:19 <osaunders> Hm, whatever.
15:39:11 <Twey> osaunders: You can do what you like when developing.  Just remember to document (this includes types) before forcing anyone else to read it.  ;)
15:39:31 <Axman6> osaunders: i look at type declarations as a) documentation, and b) a way to constrain the types of functions to something more specific if you need it to be for some reason
15:39:42 <Twey> What was it that quit message said?  ‘Always code as if the person who's going to be maintaining your project is a homicidal maniac who *knows where you live*?’
15:39:57 <Axman6> something like that :)
15:40:08 <osaunders> I dont' really believe in that sort of stuff.
15:40:18 <osaunders> I like less code/
15:40:21 <Axman6> what sort of stuff?
15:40:47 <Axman6> i prefer readable and maintainable code (is: usable code, not nonsense :))
15:40:52 <osaunders> I don't believe in assuming the programmers is stupid.
15:40:57 <thunderbolt> Readability counts!
15:40:58 <benmachine> not stupid
15:41:23 <osaunders> Or that they don't know what they are doing.
15:41:27 <Axman6> osaunders: well, i'd never hier you for a programming job then
15:41:33 <benmachine> heh
15:41:56 <papna> osaunders, You don't have to be stupid to have trouble understanding code that doesn't try its hardest to be understandable.
15:42:05 <osaunders> Axman6: My opinion won't be effected by how other judge me only but good reason.
15:42:09 <osaunders> *affected
15:42:11 <benmachine> but it's not even that; if you want to understand how to use a function, the type signature is usually faldway there
15:42:15 <benmachine> faldway?
15:42:18 <benmachine> that is not a word.
15:42:26 <osaunders> :-)
15:42:29 <osaunders> Should be!
15:42:30 <papna> Choosing compactness over clarity (whether or not providing signatures always qualifies can be debated) is ridiculous.
15:42:32 * Axman6 isn't joking. i put redability and maintainability above showing off by writing the shortest code you can. if it takes more time to understand the code then it does to rewrite it again in an understandable way, i don't want to see it
15:42:52 <benmachine> chosing verbosity over clarity is even more insane, though :)
15:42:59 <benmachine> +o
15:43:04 * Twey agrees, though probably has a higher bound for that than Axman6.
15:43:06 <Twey> benmachine: *nod*
15:43:13 <benmachine> generally choosing anything other than clarity, not recommended :P
15:43:34 * Axman6 has a fatwa against needlessly pointfree code
15:43:45 <shachaf> benmachine: Correctness (sometimes).
15:43:47 <Cale> But that's clear to you is a function of what you've read in the past
15:43:53 <Cale> what's*
15:43:54 * Twey has a fatwa against needlessly pointful code.
15:43:55 <osaunders> I like clarity sure just rarely think you get clarity by writing... more.
15:44:08 * papna has a fatwa against the godless West.
15:44:09 <Axman6> osaunders: the reason for writing code signatures is that you should be able to know how to use a functiin without having to look at its source
15:44:17 <osaunders> OK, that's probably wrong (what I said).
15:44:43 <osaunders> Axman6: Do types help that much?
15:44:43 <Axman6> o*
15:44:46 <benmachine> shachaf: I'd prefer a program that was obviously wrong than one that was right in a way no-one could understand :P
15:44:49 <Axman6> yes, a hell of a lot
15:45:02 <Twey> benmachine: o.@  That's crazy talk, son
15:45:02 <osaunders> Well. OK.
15:45:07 <shachaf> benmachine: Yes? What if there's no other way to write it?
15:45:16 <benmachine> well then that is a problem
15:45:29 <benmachine> maybe it wasn't meant to be written!!
15:45:38 <Axman6> benmachine: i agree with you. you can fix broken ones. you can't change ones you don';t understand though
15:45:40 <osaunders> I'm really coming from an imperative background here. I like duck typing.
15:45:54 * copumpkin quacks
15:46:14 <osaunders> Go interfaces seem awesome to me.
15:46:18 <copumpkin> osaunders: you can have duck typing in haskell too ;) just make a bunch of one-method typeclasses
15:46:24 <benmachine> duck typing sounds like a good principle but it pisses me off in python because you don't know anything about anything
15:46:44 <papna> osaunders, Haskell is statically typed, so duck typing isn't possible, as it isn't in statically-typed imperative language.
15:46:54 <papna> Haskell does, however, make polymorphism very easy.
15:47:02 <papna> Type signatures don't detract from this.
15:47:16 <osaunders> benmachine: Hm yeah. I guess the thing I like about duck typing is the polymorphism and you can get that in Haskell with typeclasses and stuff.
15:47:27 * mauke proceeds to use Data.Dynamic
15:47:30 <papna> benmachine, Pffft, so long as the person calling your function does what you tell them to you know all you need to know.
15:47:35 <Axman6> :t lookup
15:47:36 <osaunders> My love of pith isn't so useful here.
15:47:36 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:47:37 <copumpkin> don't follow mauke
15:47:39 <papna> benmachine, And if they don't, there's no hope anyways.
15:47:39 <copumpkin> there be the dragons
15:47:49 <ddarius> papna: Documentation is extra writing.
15:47:56 <benmachine> papna: someone calling your haskell function can't lie to you :P
15:48:00 <Axman6> osaunders: by looking at that type signature, i can already tell exaqctly what that function is l;ikely to do
15:48:10 <copumpkin> exactly
15:48:10 <benmachine> unless it's polymorphic and they write a custom nonsense instance I suppose
15:48:12 <copumpkin> + likely
15:48:14 <copumpkin> mmm
15:48:14 <papna> benmachine, Sure they can. People use Haskell functions wrong all the time.
15:48:30 <PizzaMan420> is there a way to get distinct items from a list?
15:48:35 <Niccus> nub
15:48:37 <mauke> PizzaMan420: nub
15:48:44 <copumpkin> stop calling him a nub
15:48:47 <copumpkin> that's not nice
15:48:49 <osaunders> lol
15:48:53 <mauke> :-)
15:48:53 <benmachine> :P
15:48:58 <papna> ddarius, Writing that's easily as important than the writing of the code for a good library.
15:49:06 <benmachine> @type Data.List.nub
15:49:08 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:49:11 <ddarius> papna: And probably more writing than a type signature.
15:49:19 <ddarius> (and less useful in some respects)
15:49:23 <PizzaMan420> thanks
15:49:31 <Axman6> @src nub
15:49:32 <lambdabot> nub = nubBy (==)
15:49:35 <Axman6> @src nubBy
15:49:36 <lambdabot> nubBy eq []             =  []
15:49:36 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:49:38 <osaunders> Are there things that will generate type declarations and put them in your code for you? That would be cool.
15:49:45 <Axman6> osaunders: yes
15:49:53 <papna> ddarius, A type signature is a bare minimum. It is shocking how frequently people mistake telling-you-the-types for documenting a function.
15:49:59 <copumpkin> osaunders: but then they're just doing what the compiler's type inferrer is doing anyway
15:50:06 <Axman6> i think both vim and emacs will do that
15:50:19 <copumpkin> so you don't gain much by using them, except you can check specifically what haskell thinks your types are and correct it if it's wrong
15:50:19 <papna> ddarius, s/shocking/pitiful
15:50:20 <osaunders> copumpkin: Yeah but you can change them.
15:50:24 <ddarius> papna: I think you are missing the context of my comment.
15:50:37 <osaunders> copumpkin: ...once they have been generated.
15:50:54 <osaunders> Do those tools get a lot of use?
15:50:56 <copumpkin> papna: in agda I could (if I really wanted to) encode a function's specification in its type
15:51:01 <osaunders> (Type declaration generators).
15:51:20 <copumpkin> I've never used one
15:51:30 <copumpkin> but I typically start by writing a type for a function
15:51:35 <copumpkin> then write the code
15:51:36 <bfh6558> super ignorant question: Is haskell purely functional or does it support OOP aswell?
15:51:39 <Axman6> osaunders: you seem to be under the impression that writing types in haskell is a big thing. it's really not :)
15:51:41 <ddarius> osaunders: Typically you start with the type as that is usually much more stable that the code.
15:51:50 <ddarius> bfh6558: It's not OO at all.
15:51:51 <copumpkin> bfh6558: no OOP unless you work hard to squeeze it out
15:52:03 <bfh6558> word thanks for the reply
15:52:07 <Axman6> bfh6558: it is purerly functional, but you can make it act OO if you're a nutjob :)
15:52:07 <copumpkin> sentence
15:52:08 <papna> bfh6558, Haskell does not at all lend itself to OOP
15:52:13 <Axman6> @google oohaskell
15:52:15 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
15:52:15 <lambdabot> Title: Haskell's overlooked object system
15:52:15 <osaunders> Axman6: Yeah, it seems like quite a lot of typing to me.
15:52:22 <copumpkin> you can get some OO-like features easily with some GHC extensions
15:52:36 <mauke> you can get OO as a library :-)
15:52:40 <copumpkin> osaunders: well, you don't need to do it at all, and if you do do it you don't need to do it everywhere
15:52:51 <ddarius> mauke: A useless library and still completely lacking subtyping.
15:53:03 <osaunders> OK.
15:53:04 <Axman6> osaunders: well, you'll change your mind, when you realise you often start your program by writing the types for functions, and then implementing them
15:53:22 <osaunders> Axman6: I get the impression that I will change my mind, yes.
15:53:26 <Axman6> that's how you design good programs. types allow you to think about your program at a much higher level
15:53:27 <nolrai_FG> is there suposed to be a \ETX charater in the middle of GHC.Base.unpackString?
15:54:00 <mauke> you can't use \ETX in identifiers
15:54:04 * osaunders goes for cereal
15:54:10 <bfh6558> I've just been teaching myself c++ for the last ~3 months and I've been looking into other languages to teach myself and I cant really see why I would choose a functional language over a functional and oop language. but thats because I'm lacking in a lot of knowledge about languages
15:54:10 <copumpkin> mmm cereal
15:54:13 <ddarius> @hackage cereal
15:54:13 <nolrai_FG> hmm
15:54:14 <lambdabot> http://hackage.haskell.org/package/cereal
15:54:15 <Axman6> osaunders: we're very big on types, they're one of the most powerful things in haskell, and we love them for very good reason
15:54:28 <copumpkin> osaunders: types give you logic!
15:54:42 <mauke> bfh6558: what other languages do you know?
15:54:53 <copumpkin> latin, french
15:54:57 <ivanm> copumpkin: bah, who needs logic?
15:54:57 <ivanm> ;-)
15:55:11 <copumpkin> pff, yeah
15:55:29 <Axman6> bfh6558: haskell gives you a hell of a lot more safety that your code is correct than most other languages. it also is migh more high level, which lets you think about what you need to do, more than how yo0u ne3ed to do it
15:55:37 <bfh6558> I had a year of C# heavy with WYSISYG gui form visual studio, and I'm currently in a data structures class that i taught myself c++ for
15:55:41 <ivanm> copumpkin: since when are you bfh6558? :p
15:55:56 <copumpkin> not sure!
15:56:13 <copumpkin> Axman6: did your l33t keyboard go haywire?
15:56:15 <mauke> bfh6558: what functional and oop languages do you know/have you heard of?
15:56:32 <Axman6> copumpkin: i hate this keyboard
15:56:34 <copumpkin> " which lets you think about what you need to do, more than how yo0u ne3ed to do it"
15:56:39 <bfh6558> python, c++, c#, java... um ha nothing really beyond that.
15:56:48 <mauke> none of those are functional
15:56:49 <ddarius> bfh6558: None of those are functional languages.
15:56:49 <papna> None of those are especially functional languages.
15:56:50 <copumpkin> see, I wouldn't call any of those functional
15:56:51 <copumpkin> lol
15:56:52 <Axman6> bfh6558: if you're interested in datastructures, you should love haskell.
15:56:52 <mauke> especially not c++
15:56:55 <bfh6558> *facepalm
15:57:08 <bfh6558> time for me to google functional programming languages
15:57:10 <ddarius> bfh6558: If you had said O'Caml/F# and a few others you'd have been better off.
15:57:19 <copumpkin> bfh6558: it's a remarkably misused term
15:57:23 <Axman6> Erlang too
15:57:29 <conal> scala
15:57:35 <copumpkin> eww scala
15:57:36 <ddarius> Axman6: I don't consider Erlang (traditional) OO.
15:57:38 <copumpkin> :P
15:57:43 <conal> :)
15:57:43 <bfh6558> I've heard of most of them but know nothing about any
15:57:51 <copumpkin> scala apparently has typecase!
15:57:55 <Axman6> ddarius: i consider it FP though, and that's all i meant by the comment :)
15:58:31 <Axman6> bfh6558: can i give you some examples of why haskell is awesome for data structures?
15:58:45 <bfh6558> Axman6: I would love that
15:58:59 <ivanm> because you can create a new data structure in one line rather than in a whole file! \o/
15:59:05 <copumpkin> yay!
15:59:16 <copumpkin> @slap copumpkin
15:59:18 <lambdabot> I won't; I want to go get some cookies instead.
15:59:19 <monochrom> If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
15:59:22 <benmachine> aww
15:59:29 <Axman6> ok, binary tree: data Tree a = Node a (Tree a) (Tree a) | Leaf a
15:59:35 <ivanm> copumpkin: I take it you're a masochist?
15:59:38 <papna> monochrom, ...
15:59:44 <copumpkin> ivanm: come into my room and I'll show you
15:59:48 <ddarius> ivanm: Slapping is hardly painful.
15:59:54 <monochrom> Yes, it should make you wonder what advanced things are in chapter 10 of an FP book.
15:59:56 <ivanm> @remember monochrom If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
15:59:56 <lambdabot> It is stored.
15:59:57 <bfh6558> your serious thats all you need for a Bin-Tree?
16:00:04 <ivanm> ddarius: depends on what you get slapped with... >_>
16:00:06 <Axman6> linked list: data List a = Cons a (List a) | Nil
16:00:09 <ddarius> monochrom: Hello World
16:00:11 <Axman6> bfh6558: yup
16:00:15 <Niccus> don't you also need a "| Empty" or something
16:00:19 <copumpkin> bfh6558: depends on what kind of a tree you want, but most trees are more or less that
16:00:20 <monochrom> hahaha ddarius
16:00:21 <ivanm> bfh6558: well, you need functions to _use_ it, but yes, that defines the tree
16:00:29 <ivanm> Axman6: maybe shove a deriving there as well
16:00:38 <copumpkin> functions for balancing and so on will take up another 50 lines
16:00:39 <ivanm> Niccus: it's there!
16:00:40 <benmachine> Niccus: there are lots of ways of doing trees which are mostly pretty similar
16:00:46 <bfh6558> oh my god. I'm going downstairs to find a haskell book right now.
16:00:56 <mauke> Niccus: well, that's what 'Leaf' is supposed to be. I think the last 'a' is wrong
16:00:56 <ivanm> Niccus: oh, wait, a completely empty tree... what's the point of that?
16:01:01 <copumpkin> bfh6558: for balancing, pattern matching is a godsend
16:01:07 <ivanm> mauke: agreed
16:01:07 <benmachine> ivanm: what's the point of an empty list? :P
16:01:08 <Axman6> Niccus: you don't need it, it just depends on what semantics you want your tree to have, ie, do you want to to be able to be empty?
16:01:16 <ivanm> benmachine: ssshhh! :p
16:01:31 <bfh6558> Could anyone give me the name of a well written book? I'm at the library already, I'm seriously going to go find one
16:01:39 <copumpkin> if you like non-empty n-ary trees, just use Cofree []
16:01:39 <mauke> @where rwh
16:01:40 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:01:42 <benmachine> Axman6: also looks to me like that particular tree can't have exactly two elements
16:01:46 <Axman6> how about you try lyah, it's an online tutorial:
16:01:47 <copumpkin> @where lyah
16:01:48 <Axman6> @where lyah
16:01:48 <lambdabot> http://www.learnyouahaskell.com/
16:01:49 <lambdabot> http://www.learnyouahaskell.com/
16:01:53 <CalJohn> rwh is a terrible book for new people
16:01:54 * copumpkin glares at Axman6
16:01:54 <Axman6> bfh6558: ^^^^^^^^^^^^^^^^^666
16:02:02 <skorpan> CalJohn: werrrd
16:02:02 <lambdabot> skorpan: You have 1 new message. '/msg lambdabot @messages' to read it.
16:02:10 * Axman6 throws his keyboard at copumpkin 
16:02:12 <ivanm> @quote stereo
16:02:13 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
16:02:13 <copumpkin> skorpan: parrrrrragrapppph
16:02:13 <CalJohn> i don't even like it for anyone
16:02:15 <bfh6558> I already love this site
16:02:22 <ivanm> @slap CalJohn
16:02:23 * lambdabot would never hurt CalJohn!
16:02:26 <bfh6558> a elephent and a computer, genius
16:02:28 <copumpkin> bfh6558: featuring the List Monster!
16:02:28 <ivanm> grrr....
16:02:37 * Axman6 also thinks RWH is not great for beginners sadly
16:02:40 <ivanm> copumpkin: which one? the shark one?
16:02:46 <copumpkin> http://learnyouahaskell.com/listmonster.png
16:02:46 <copumpkin> that one
16:02:50 <ivanm> Axman6: it's not, but CalJohn then said it was useless for _anyone_
16:02:59 <mauke> that's wiggler
16:03:01 <ivanm> copumpkin: oh, I thought you meant wadler's students' ones
16:03:03 <Axman6> bah, i don't agree with that
16:03:06 <blackdog> Axman6: it depends on the sort of beginner you are, i think. It'd be pretty good for an experienced dev who hadn't used haskell, i think
16:03:17 <EvanCarroll> pCheck :: (Eq a) => [a] -> Bool; pCheck a = take n a == take n $ reverse a where n = floor ( len (a) / 2 )
16:03:29 <EvanCarroll> Axman6: that's what I'm reading now =)
16:03:35 <copumpkin> bfh6558: the other advantage of haskell is that it's practically bottomless, and an awesome path to some seriously deep CS/math if you decide to go deeper
16:03:40 <EvanCarroll> Axman6: page 69 question 4
16:03:41 <Axman6> blackdog: i think it would be best for someone who had used another functional languages and/or pattern matching before
16:03:45 <mauke> EvanCarroll: n = length a `div` 2
16:03:49 <CalJohn> ivanm: sorry, i've always like technical books that explain things before they use them ($), come in a logical order, and that don't needlessly reference earlier chapters
16:03:54 <copumpkin> bfh6558: but the deep math/cs isn't a requirement for writing useful code :)
16:04:00 <ddarius> A potentially empty binary leaf tree = nice MonadPlus instance.
16:04:03 <monochrom> Bird's book: chapter 6 is binary trees, chapter 11 is parsing, chapter 12 is "an automatic calculator".  Hudak's book: chapter 7 is binary trees, chapter 15 is reactive animation, chapter 20-22 is music and MIDI
16:04:04 <ivanm> CalJohn: right, but it's a tutorial on advanced topics
16:04:08 <benmachine> copumpkin: if haskell is anything it is not bottomless :P
16:04:12 <EvanCarroll> mauke: ah, I just defined my own length, but i should use the generic ;)
16:04:18 <copumpkin> lol
16:04:18 <benmachine> possibly topless?
16:04:23 <copumpkin> maybe!
16:04:24 <EvanCarroll> same error
16:04:27 <Axman6> benmachine: hell yes it is
16:04:30 <ivanm> benmachine: you wish? :p
16:04:31 <EvanCarroll>     Couldn't match expected type `[a]'
16:04:31 <EvanCarroll>            against inferred type `[a1] -> [a1]'
16:04:33 <CalJohn> i haven't actually met anyone who likes RWH because it helped them learn anything, most people who I hear liking it, like it because they like the idea of O'Reilly publishing a bestselling haskell book
16:04:39 <copumpkin> Axman6: I think it was a comment about _|_ :)
16:04:43 <Axman6> EvanCarroll: not generic, standard ;)
16:04:47 <mauke> EvanCarroll: pCheck a = a == reverse a
16:05:09 <CalJohn> i went to a summer school for haskell, and of all the people there, not one found RWH helpful
16:05:14 <EvanCarroll> CalJohn: I have to admit, it has some downsides.
16:05:16 <CalJohn> most (like me) found it unhelpful
16:05:36 <mauke> EvanCarroll: that error is probably caused by $
16:05:39 <Axman6> CalJohn: the later chapters are quite informative, and i learnt quite a bit from them
16:05:42 <ddarius> CalJohn: There are plenty of people who've (claimed to have) learned from RWH.
16:05:46 <nolrai_FG> anyone have a clue what sat-only means in stg code?
16:05:46 <mauke> (take n a == take n) (reverse a)
16:05:49 <ivanm> CalJohn: I learnt stuff
16:05:51 <ivanm> so there!
16:06:15 <ivanm> it's a good reference for advanced stuff, such as profiling, optimising, etc.
16:06:17 <ddarius> CalJohn: Also, presumably it is selling so well because people are recommending it to other people.
16:06:21 <CalJohn> ddarius: well, i met 30 other middling haskellers who where all really into FP, and we all disliked it
16:06:29 <nolrai_FG> What do you not like about RWH? Just out of curriosity?
16:06:37 <CalJohn> nolrai_FG: see above
16:06:48 <CalJohn> it's selling well because lots of people want to learn haskell.  that is what book sales measure, not quality
16:06:53 <Kim^Walkman> RWH helped me understand monad transformers and how basic concurrency works :)
16:06:56 <ddarius> CalJohn: Well, I've heard of well more than 30 people that liked it.
16:07:10 <Kim^Walkman> Like many other things, but the “aha” experience was while reading RWH
16:07:11 <osaunders> Dammit I'm trying to catch up on all the missed stuff and it's being written faster than I can read it.
16:07:18 <ddarius> CalJohn: There are other books that you can buy to learn Haskell.
16:07:19 <CalJohn> ddarius: well, i'm not going to have a discussion where we treat anecdotes as data
16:07:25 <osaunders> Everybody just stop, for 5 minutes OK, lol.
16:07:40 <CalJohn> ddarius: there are other books, it's a pity everyone buys RWH and gets turned off
16:07:50 <CalJohn> (Bird, Hutton and so on are _great_ books)
16:07:53 <copumpkin> osaunders: cereal breaks are deadly
16:07:54 <ddarius> CalJohn: I thought we weren't going to treat anecdotes as data?
16:07:59 <ivanm> CalJohn: there's no other mid-to-advanced haskell book that I know of
16:08:01 <ivanm> ddarius: heh
16:08:04 <dons> CalJohn: interesting.
16:08:20 <osaunders> copumpkin: Yeah. Decided not to bother with catching up.
16:08:31 <copumpkin> osaunders: cereal is better than knowledge, anyway
16:08:32 <dons> CalJohn: its a big book. there's certainly things in there to learn. I'd be surprised if it was all known already...
16:08:33 <Axman6> hmm, what are some other interesting data types in haskell?
16:08:34 <CalJohn> dons: hello, loved your talk at london hug a few months ago
16:08:45 <jlouis> I originally learned Haskell from the "short introduction to Haskell"
16:08:49 <Twey> I don't know of anybody who's been turned off by RWH…
16:08:51 * copumpkin learned haskell from #haskell
16:08:57 <osaunders> copumpkin: Why yes. If I had infinite cereal I wouldn't need any knowledge.
16:09:02 * Axman6 did too
16:09:05 <Axman6> and uni
16:09:07 <tessier> RWH seems pretty good to me. I haven't finished it yet though. Just the first couple chapters.
16:09:15 <ddarius> Axman6: newtype HFun a b = HFun (HFun b a -> a)
16:09:18 <c_wraith> My biggest complaint with RWH is that it's linear.  You can't skip chapters without getting lost.
16:09:20 <osaunders> Oh are there Haskell groups in London?
16:09:20 <benmachine> knowledge is only gathered in the pursuit of further cereal
16:09:21 <mauke> haha
16:09:27 <copumpkin> ddarius: that looks useful
16:09:30 <benmachine> osaunders: can I be a group?
16:09:35 <Axman6> ddarius: what's that do?
16:09:37 <dons> c_wraith: to about ch 15. after that they're mostly separate.
16:09:41 <osaunders> benmachine: Sure you can!
16:09:46 <dibblego> data BKTree a = Node a !Int (Map Int, BKTree a) | Tip
16:09:48 <blackdog> c_wraith: hard to go deep without dependencies...
16:09:51 <dons> you can do the stm chapter without having done the gtk2hs chapter, for example.
16:09:52 <jlouis> benmachine: you can be a semi-group :)
16:09:53 <copumpkin> benmachine: what's your operation and identity?
16:10:03 <Twey> I think there are a lot of resources out there that are technically very correct, but virtually impossible to tie into real programming on real-world problems.
16:10:04 <jlouis> **5's copumpkin
16:10:07 <benmachine> hah
16:10:16 <Twey> They teach Haskell as if it were a kind of mathematics, instead of a programming language.
16:10:24 <copumpkin> dibblego: burger king tree? I'd like one of those
16:10:24 <Twey> That's the problem that RWH is attempting to solve.
16:10:28 * benmachine has an identity crisis
16:10:30 <mauke> programming languages are mathematics
16:10:32 <monochrom> And I must share with you my "true meaning of programming book titles" http://www.vex.net/~trebla/humour/programming_books.html  :)
16:10:34 <dibblego> Burkhard-Keller silly
16:10:39 <ddarius> mauke: Shhh!
16:10:43 <Twey> mauke: Programming languages are a lot more than mathematics
16:10:44 <jlouis> programming languages are logics!
16:10:50 <copumpkin> mathematics are programming languages!
16:10:52 <mauke> you misspelt "less"
16:10:58 <Axman6> dons: are there any plans for a second revision of the book? there's a fair bit i'd like to see changed (and a hell of a lot more that's fantastic, don't worry ;))
16:10:59 <c_wraith> the dependencies are exceptionally implicit.  I see a chapter labeled "bloom filters", I see that I don't care about bloom filters, and move on to the next chapter.  Then I lacked all that information from that chapter that wasn't about bloom filters.
16:11:02 <ivanm> mauke: the languages themselves?
16:11:19 <ivanm> Axman6: yeah, I want a darcs patch to fix all the errors! :p
16:11:22 <benmachine> everything in the world is either mathematics or secretly wishes it was
16:11:25 <CalJohn> i have no objection to more "grounded" treatments of FP, it's just that RWH has issues which hinder learning.  to some extent the huge amount of examples obscure the principles
16:11:29 <Axman6> ivanm: ha, yeah :P
16:11:33 <dons> a fair bit you'd like changed? that's prob. more than you can expect. you can expect typos and mistakes fixed though
16:11:35 <ivanm> c_wraith: RWH uses examples to develop topics
16:11:41 <mreh> @paste
16:11:42 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:11:53 <ivanm> so the titles are more on what examples are being covered
16:12:02 <dons> CalJohn: i've not heard that. but remember, its for people who are already familiar with programming, and don't really want to learn underlying theory
16:12:03 <ivanm> CalJohn: and how do you _know_ you don't care about bloom filters? ;-)
16:12:09 <EvanCarroll> ivanm: I would actually consider buying another book that would more foundational than RWH but just as haskell-specific.
16:12:11 <c_wraith> I'd much rather be informed what topics are being covered than what the example is.
16:12:15 <EvanCarroll> if anyone has any suggestions
16:12:19 <dons> rwh is not about teaching foundations.
16:12:28 <ivanm> EvanCarroll: Craft of Functional Programming
16:12:29 <CalJohn> ivanm: ...I do care, I found that chapter helpful
16:12:30 <dons> look at say, TaPL or the haskell road.
16:12:33 <mreh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5190#a5190
16:12:35 <ivanm> EvanCarroll: Haskell School of Expression
16:12:35 <Axman6> dons: well, not all that much needs changing. just making sure things aren't used before they've been intrpoduced (like CalJohn's example of $ appearing without being introduced first), and some errors mainly
16:12:38 <mreh> could someone help me with this?
16:12:38 <EvanCarroll> ivanm: that doesn't sound as haskell-specific.
16:12:45 <ivanm> EvanCarroll: it is, it uses haskell
16:12:47 <dons> yeah, there's wibbles like that to be fixed.
16:13:08 <dibblego> $ was introduced in the introductory books
16:13:14 <EvanCarroll> ivanm: will that teach me the ins-and-outs of haskell's type system, or just illistrate generic functional concepts in haskell?
16:13:20 <ivanm> dons: if a revised version does get released, would people who bought the first version get a discount? >_>
16:13:22 <ben> @pl \a b -> a >>= \a' -> b >>= \b' -> f a b
16:13:23 <lambdabot> liftM2 (.) (>>=) ((const .) . ap (>>=) . (const .) . f)
16:13:24 <ivanm> dibblego: heh
16:13:27 <ben> @pl \a b -> a >>= \a' -> b >>= \b' -> f a' b'
16:13:27 <lambdabot> (. ((. f) . (>>=))) . (>>=)
16:13:29 <Axman6> ivanm: heh
16:13:34 <CalJohn> dons: ok, well, I suppose that makes it not the book for me.  i had some interest in the underlying theory, but my suspicion is that people who don't will find much of haskell incomprehensible
16:13:35 <gwern> > 180 * 0.05
16:13:36 <dons> ivanm: prob. get the patch set. but i'm not sure what o'reilly usually does.
16:13:36 <lambdabot>   9.0
16:13:39 <ivanm> dibblego: IIRC, RWH is also meant to cater to people that have programmed before but not in Haskell
16:13:39 <ben> err.
16:13:45 <ben> @pl \f -> a >>= \a' -> b >>= \b' -> f a' b'
16:13:45 <ivanm> dons: *nod*
16:13:45 <lambdabot> (a >>=) . ((b >>=) .)
16:13:47 <ben> Brr.
16:13:54 <dons> CalJohn: that's not been my experience. people don't know the underlying theory of C either.
16:14:02 <ivanm> EvanCarroll: they teach haskell
16:14:06 <dons> but if you're into the foundations, get a copy of Types and Programming Languages.
16:14:53 <ivanm> EvanCarroll: for most Haskellers, the only other real functional language is probably clean, as it's the only other _purely_ functional language ;-)
16:15:09 <SoleSoul> Hi! where can I find speed comparisons between C++ and Haskell Programs? Thanks!
16:15:10 <Axman6> or agda
16:15:21 <ivanm> @where shootout
16:15:22 <lambdabot> http://shootout.alioth.debian.org/
16:15:32 <ivanm> SoleSoul: ^^ for trivial micro-benchmarks between languages
16:15:40 <ivanm> that don't actually reflect real world stuff
16:15:57 <EvanCarroll> nor do they reflect real-workd haskell from what i'm told.
16:15:58 <Axman6> SoleSoul: i think that's a pretty terrible way to compare languages personally :)
16:16:23 <SoleSoul> I'm thinking about learning haskell but I'm worried about the performance
16:16:25 <dons> EvanCarroll: there's variance.
16:16:28 <Axman6> EvanCarroll: they refplect my real world haskell. but i usually care about speed more than anything :)
16:16:31 <dons> some of the microbenchmarks are very "real world"
16:16:34 <EvanCarroll> I'm told the haskell in those benchmarks is highly scewed and overly optimized to such an extent that it doesn't fairly represent haskell.
16:16:39 <dons> but rumours are remarkably common when it comes to haskell
16:16:41 <Axman6> SoleSoul: performance is up there with C, if you know what you're doing
16:16:46 <ivanm> SoleSoul: haskell is generally up to about 5x slower than C/C++ (depending on how well you write it), but its much faster/easier to write and maintain if you understand Haskell
16:16:47 <EvanCarroll> I've seen a few of them that use goofy things like manually memmory allocation
16:16:48 <tresh> is there a way to check if a list has duplicates? preferably of the form [a] -> Bool?
16:16:51 <ivanm> dons: heh
16:16:52 <dons> EvanCarroll: they're typical of library code in some cases, and concurrent code.
16:17:03 <dons> there's also some obsolete optimization techniques
16:17:03 <ivanm> @remember dons but rumours are remarkably common when it comes to haskell
16:17:03 <lambdabot> Done.
16:17:11 <Axman6> ivanm: 5x? pfft
16:17:11 <dons> tresh: nub
16:17:16 <ivanm> tresh: see the nub function
16:17:19 <ivanm> @src nubBy
16:17:19 <dons> 5x isn't right.
16:17:19 <lambdabot> nubBy eq []             =  []
16:17:20 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:17:21 <dons> i'd say 2x.
16:17:28 <dons> if you're < 2x slower, you're doing ok.
16:17:33 <ivanm> dons: I was being over-cautious
16:17:40 <tresh> dons: thanks
16:17:40 <ivanm> dons: since not everyone is you ;-)
16:17:42 <SoleSoul> [02:22] <Axman6> SoleSoul: performance is up there with C, if you know what you're doing [02:22] <ivanm> SoleSoul: haskell is generally up to about 5x slower than C/C++ (depending on how well you write it), but its much faster/easier to write and maintain if you understand Haskell
16:18:01 <SoleSoul> how am I supposed to decide like that? :)
16:18:06 <Kim^Walkman> Decide after what you need
16:18:10 <ivanm> to decide what?
16:18:11 <Axman6> SoleSoul: i don't agree with the 5x. 2-3x sure
16:18:14 <benmachine> 5x is not actually very much for most purposes :P
16:18:18 <gwern> SoleSoul: they're not contradictory assertions, y'know
16:18:23 <Kim^Walkman> Do you need performance at every cost, even production time of five times more; or do you need speed and ease of development?
16:18:48 <CalJohn> (if you actually do need performance at every cost, there is a C FFI...)
16:18:58 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gpp&box=1
16:19:05 <ivanm> SoleSoul: haskell has the "ease of programming" that dynamic languages like python claim (about why they're better than C or C++), but with speed comporable to C and C++ (which python, etc. don't have)
16:19:11 <Axman6> SoleSoul: you decide by learning haskell, and realising that speed isn't everything, but Haskell can still offer you speed if you want it :)
16:19:13 <dons> CalJohn: its very rare to step into C for speed, at least for the last few years
16:19:18 <Kim^Walkman> Haskell is lean *and* powerful, and *very* fast when you look at it from the perspective of a high-level language
16:19:28 <dons> i've seen people step into C for libraries, but not for rewrriting for performance since at least 2005
16:19:30 <SoleSoul> I want to know for example, if I can create a mail server in haskell and if it would be fast enough to answer thousands of connections.
16:19:41 <bd_> !faq
16:19:42 <dons> SoleSoul: definitely.
16:19:50 <bd_> @faq
16:19:50 <lambdabot> The answer is: Yes! Haskell can do that.
16:19:59 <ivanm> SoleSoul: concurrency would almost definitely be easier/safer in haskell
16:20:05 <dons> SoleSoul: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
16:20:07 <Axman6> SoleSoul: you will be able yo write a concurrent mail server far easier in haskell than in C++
16:20:11 <ivanm> erlang might be another language thats suited for something like that
16:20:21 <luite> hmm, I've rewritten haskell functions in C for speed a few times in the last year... but it might be because I'm not good enough at haskell
16:20:31 <Axman6> SoleSoul: we _love_ concurrency, and haskell is by far one of the nicest languages to use for it
16:20:34 <Kim^Walkman> “Writing High-Performance  Server Applications in Haskell”, SoleSoul; google it
16:20:40 <ivanm> monochrom: with that book title list of yours, I take it we'll never see a "Data Structures using Haskell" book then? ;-)
16:21:12 <ivanm> luite: I've never done the writing in C part, but agreed
16:21:25 * ivanm only knows enough C to try and get the gist of what C code is doing
16:21:28 <ben> Is there a function Monad m => (a -> b -> m c) -> m a -> m b -> m c?
16:21:33 <ben> join . liftM  or something?
16:21:40 <ivanm> @google "Writing High-Performance Server Applications in Haskell"
16:21:41 <lambdabot> http://www.haskell.org/~simonmar/papers/web-server.ps.gz
16:21:57 <ivanm> ben: liftM2 ?
16:21:57 <CalJohn> dons: ok, well, I wouldn't know.  it's interesting what the "fast enough" tolerance is
16:21:58 <ivanm> @type liftM2
16:22:00 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:22:05 <ivanm> yup
16:22:16 <Kim^Walkman> So far, every thing I've read about haskell has more or less given me even more reason to learn it better
16:22:37 <dons> haskell is fast enough for almost everything galois does, except for some specialized crypto code
16:22:49 <dons> that should be good enough for most people, imo.
16:22:58 <Axman6> crypto is usually fairly low level anyway right?
16:23:09 <ivanm> dons: so you drop down to C for that?
16:23:12 <Axman6> lots of bit shifting etc
16:23:14 <ben> ivanm: It should return r and not m r
16:23:15 <dons> right. you want to get the vector instructions and so on. you usually have the asm you need anyway
16:23:19 <BMeph> Mind you, this is just a personal remark from someone very marginally in the programming biz, but I believe that if you aren't into RTOS design, or hard/firmware programming, you should just "chill out" about demands for "performance". But like I said, this is just m opinion, with the caveats concerning opinions applying. :)
16:23:19 <dons> ivanm: cryptol
16:23:34 <ivanm> ben: ahhh
16:23:50 <ivanm> ben: \ f -> liftM2 ((return .) . f)
16:23:51 <ivanm> ;-)
16:24:07 <Axman6> BMeph: or scientific code, where 50% slower code could mean it runs for another week
16:24:13 <ray> nobody ever listens to that advice about premature optimization
16:24:14 <ivanm> oh, wait, sorry, I misunderstood
16:24:17 <ben> I think I am going with join $ liftM2 a b
16:24:28 <ivanm> @hoogle (a -> b -> m c) -> m a -> m b -> m c
16:24:29 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
16:24:29 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
16:24:29 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:24:32 <BMeph> I also believe that if you really need performance, you should be programming in Forth. Or Haskell, if you're using an FPGA. But, again, that's just me. :)
16:24:32 <ddarius> ray: Thankfully.
16:24:39 <ivanm> ben: s/$/./ ;-)
16:24:42 <ivanm> but yeah
16:24:48 <ddarius> BMeph: ASIC
16:24:52 <ivanm> looks like your best bet
16:24:54 <SoleSoul> I am happy to hear that Haskell is fast enough for the task. Now, I know C++ and I don't know Haskell. I guess I sholdn't start coding a mail server right away right? Is there any challenges site or something for checking when I know enough for the task?
16:25:03 <ben> ivanm: That would not work, I need a $ at some place :(
16:25:13 <Axman6> SoleSoul: start with lyah:
16:25:16 <Axman6> @where lyah
16:25:16 <lambdabot> http://www.learnyouahaskell.com/
16:25:19 <ivanm> ray: a couple of years ago, the guy that said that (forget his name) said people misunderstood that quote
16:25:29 <BMeph> Axman6: By that logic, if 50% slower means it runs for another week, it's running for two weeks already! Is two weeks or three THAT much of a deal-breaker? ;)
16:25:32 <Axman6> SoleSoul: after a few weeks (don't rush it!), check out project euler
16:25:34 <ivanm> ben: well, liftM2 takes three args; you supplied _two_ ;-)
16:25:40 <ivanm> Axman6: nooooo!!! :p
16:25:43 <ben> oh, I forgot my f
16:25:51 <ivanm> heh
16:25:53 <luite> SoleSoul: at least if there are some specific performance critical parts (and you can't get your haskell code fast enough), it's quite easy to write those parts in C and call it from haskell
16:25:56 <dons> SoleSoul: make sure you know how to write concurrent code
16:26:13 <dons> you should be able to say, write  a little static web server to handle 5-10k conn/sec
16:26:15 <luite> SoleSoul: (C++ is quite a bit more difficult though)
16:26:16 <EvanCarroll> mauke: that error was caused by $
16:26:17 <dons> if you can do that, you'll be fine.
16:26:19 <copumpkin> I was thinking, the relationship between P(A, B) and P(A | B) seems adjunctionish, but I haven't thought though it yet
16:26:30 <Twey> SoleSoul: Start with RWH.  When you've finished RWH, you're ready.  ;)
16:26:34 <Twey> @where rwh
16:26:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:26:38 <EvanCarroll> if i paren my code right i get a totally different error
16:26:47 <ray> ivanm: knuth?
16:26:57 <ivanm> don't think so...
16:26:59 <ivanm> hoare IIRC
16:27:21 <SoleSoul> Thank you all for your advices! by concurrent you mean "import Control.Parallel" ?
16:27:23 <copumpkin> I like to call him ho'
16:27:39 <ddarius> copumpkin: A conditional probability is probably implicationalish and obviously a joint probability is product-ish and products and exponents are adjoint.
16:27:40 <benmachine> Control.Concurrent
16:27:44 <BMeph> ddarius: Sorry, at my business, they use SoC chips and FPGAs. You may call them ASICs, but our vendors don't. Yet. :)
16:27:44 <gwern> copumpkin: do you think Hoare would've liked Coq?
16:27:44 <ivanm> SoleSoul: parallel /= concurrent
16:27:44 <ray> anyway, optimizing compilers are the root of all good
16:27:47 <benmachine> parallel is different
16:27:47 <ivanm> copumpkin: heh
16:28:03 <copumpkin> gwern: I don't know much about him
16:28:08 <ddarius> BMeph: I was suggesting ASIC not correcting your terminology.  FPGAs are definitely not ASICs.
16:28:09 <copumpkin> gwern: but probably
16:28:28 <copumpkin> ddarius: hmm, so I should keep looking in that direction?
16:28:55 <SoleSoul> ok :) I'll have to read. first lyh, then rwh and project euler, and then mail server. thanks!
16:28:56 <ivanm> ray: oh, right, knuth attributed it to hoare, but hoare said he didn't say it
16:28:58 <ddarius> copumpkin: Possibly, but for an actual categorical adjoint you'd need to start specifying categories and functors.  Perhaps look at Galois connections.
16:29:11 <ray> see, they're both trying to distance themselves from it!
16:29:19 <copumpkin> yeah, I was trying to think what my categories (and in particular the morphisms) would be
16:29:31 <ray> let me show you my morphisms
16:29:35 <ivanm> ray: http://www.acm.org/ubiquity/views/v7i24_fallacy.html
16:29:58 <copumpkin> gwern: do you like coq?
16:30:06 <gwern> copumpkin: I've never tried it
16:30:39 <copumpkin> at least you aren't negative. So many people I ask seem to think they won't like coq, without ever even trying it!
16:31:15 <ray> that's because it looks really obscure
16:32:16 <copumpkin> well in the sad state of the world today, coq tends to be relegated to being used in very restricted situations, but with any luck that will change someday
16:32:22 <Kim^Walkman> How long has hoogle been down?
16:32:30 <Kim^Walkman> And are there any alternatives?
16:32:34 <copumpkin> hayoo
16:32:38 <ddarius> copumpkin: Eventually it won't be use in any situations.
16:32:40 <copumpkin> @hoogle (a -> b) -> [a] -> [b]
16:32:41 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
16:32:41 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
16:32:41 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:33:09 <gwern> ddarius: as long as haskell has bottoms, haskell users will have use for coqs
16:33:15 <copumpkin> lol
16:33:29 <dons> we might have to impose a ban on jokes like  that.
16:33:36 <copumpkin> aw
16:33:44 <EvanCarroll> god, the type system is overwhelmingly complex
16:33:57 <dons> EvanCarroll: you find it complex?
16:34:00 <copumpkin> EvanCarroll: it actually isn't that bad :) you just need to understand it as logic
16:34:08 <ddarius> EvanCarroll: The core of it is on the back of a T-shirt.
16:34:14 <gwern> even if I am banned for that last joke (my best Coq joke, I think, since it's also true), it will have been worth it!
16:34:17 <dons> EvanCarroll: you shouldn't need to actually load the typing axioms into your head to use the language...
16:34:17 <Axman6> EvanCarroll: not if you take the time to learn it
16:34:18 <EvanCarroll> dons: yes.
16:34:29 <EvanCarroll> Possible fix: add an instance declaration for (RealFrac Int) In the expression: floor (length a / 2) In the definition of `n': n = floor (length a / 2)
16:34:47 <EvanCarroll> what does this even mean, how do add an instance declaration for just an expression
16:34:49 <ddarius> http://www.cafepress.com/skicalc.6225368
16:34:51 <dons> oh, that's relatively simple..
16:34:52 <Axman6> that's because you're doing it wrong
16:35:07 <EvanCarroll> I see what it means, kinda, that floor requires its arguments to be members of typeclasses RealFrac Int
16:35:26 <dons> length a is an Int. and you're using (/). which requires Fractional (which Int is not).
16:35:26 <BMeph> Bzzt!
16:35:27 <Axman6> EvanCarroll: the real problem is that you're using / to divide an Int
16:35:41 <EvanCarroll> Axman6: thanks, that what ^Failed usually tells me at the bottom of the error
16:35:43 <dons> so the compiler is helpfully suggesting  that you could make Int a Fractional class, so / worked (not integer `div`)
16:35:51 <dons> but what you really want is fromIntegral (length a)
16:36:00 <copumpkin> or genericLength a
16:36:02 <dons> to convert the Int  to a fractional type, so (/) works.
16:36:08 <copumpkin> (they're slightly different, even)
16:36:12 <copumpkin> (sadly)
16:36:18 <Niccus> sounds more like you want length a `div` 2
16:36:35 <Axman6> Niccus: most likely
16:36:41 <dons> EvanCarroll: its really easy, in this case. pretty much the same as coercions in C. you just have to add the coercion yourself, which is what  the compiler is getting at.
16:36:46 <ddarius> genericLength (fix (():))
16:36:55 <osaunders> What is the factorial of -1?
16:36:57 <dons> i would *not* put this in the overwhelmingly complex basket
16:36:59 <EvanCarroll> pCheck :: (Eq a) => [a] -> Bool;
16:36:59 <EvanCarroll> pCheck a = take n a == ( take n $ reverse a ) where n = floor ( fromIntegral length a / 2 )
16:37:11 <BMeph> dons: Did you notice that part of what makes that error so tough to figure out, is because '2' gets quasi-coerced without warning?
16:37:31 <Axman6> EvanCarroll: i would suggest using: where n = length a `div` 2
16:37:43 <EvanCarroll>   where n = floor $ (toRational $ length $ reverse a) / 2
16:37:47 <EvanCarroll> hrm
16:37:49 <dons> BMeph: that's an interesting consequence of overloaded literals, yes. and people assuming 2 /= 2.0
16:37:51 <ray> osaunders: there isn't one, but take a look at the gamma function
16:38:06 <Axman6> EvanCarroll: div is integral devision, which is exactly what you're emulating
16:38:15 <ddarius> ray: Isn't Γ still undefined for -1?
16:38:15 <ben> What does <<loop>> mean?
16:38:20 <copumpkin> yeah
16:38:25 <BMeph> dons: Well, sometimes 2 /= 2.0, but only sometimes... ;)
16:38:26 <copumpkin> well, on 0
16:38:29 <ray> ddarius: i think so
16:38:39 <benmachine> ben: an attempt to fetch a result that GHC has noticed will not terminate, I think
16:38:41 <CalJohn> it is nice that normally 0.999999999999 == 1
16:38:42 * copumpkin wishes he had gamma on his keyboard
16:38:51 <ddarius> ben: It's GHC solving the Halting Problem.
16:38:56 <copumpkin> CalJohn: I think you forgot a few 9s there
16:39:03 <ddarius> copumpkin: You use it that much?
16:39:03 <Axman6> ddarius: heh
16:39:18 <dons> > 0.999999999999 == 1 :: Rational
16:39:20 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
16:39:20 <lambdabot>         against inferred t...
16:39:26 <dons> > 0.999999999999 == (1 :: Rational)
16:39:28 <lambdabot>   False
16:39:38 <CalJohn> > 0.99999999999999999999 == 1
16:39:39 <copumpkin> ddarius: not really :) but having an agda-mode-like input method systemwide would be nice
16:39:40 <lambdabot>   True
16:40:08 <CalJohn> i'm not sure if that's a feature or a bug, though!
16:40:15 <copumpkin> it's a feature
16:40:16 <Axman6> both!
16:40:21 <BMeph> copumpkin: Whoa, lambdabot agrees! :o
16:40:22 <benmachine> ddarius: it amuses me that the docs for Control.Exception say "Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not."
16:40:26 <Axman6> it's a quantum feature
16:40:30 <EvanCarroll> I think I don't understand what `toRational` does
16:40:40 <Axman6> :t toRational
16:40:41 <lambdabot> forall a. (Real a) => a -> Rational
16:40:47 <EvanCarroll> and why divide, just can't cast its inputs
16:40:49 <copumpkin> > (0.9999999999999999999999999999999 :: CReal) == 1 -- probably still false?
16:40:49 <Axman6> @src Rational
16:40:50 <lambdabot>   False
16:40:50 <lambdabot> type Rational = Ratio Integer
16:40:54 <Asztal> It uses fareys
16:41:02 <Axman6> EvanCarroll: because that's not type safe
16:41:02 <ddarius> copumpkin: Install SCIM.
16:41:36 <Axman6> EvanCarroll: why are you using toRational anyway? you don't need it, i already gave you the code you need to get the answer you want
16:41:42 <copumpkin> ddarius: I'm one of those mac-heads :/
16:42:06 <ddarius> @hoogle isBottom
16:42:07 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
16:42:41 <ddarius> > Test.QuickCheck.Batch.isBottom undefined
16:42:43 <lambdabot>   Not in scope: `Test.QuickCheck.Batch.isBottom'
16:42:59 <EvanCarroll> Axman6: what is the difference between / and div
16:43:04 <Axman6> :t div
16:43:04 <ddarius> :T (/)
16:43:06 <lambdabot> forall a. (Integral a) => a -> a -> a
16:43:06 <roconnor> > fix Test.QuickCheck.Batch.isBottom
16:43:07 <lambdabot>   Not in scope: `Test.QuickCheck.Batch.isBottom'
16:43:08 <ddarius> :t (/)
16:43:08 <Axman6> :t (/)
16:43:09 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:43:10 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:43:11 <EvanCarroll> ah
16:43:17 <EvanCarroll> one is for Int
16:43:30 <Axman6> EvanCarroll: div is integral division, like i said, and (/) is fractional division
16:43:34 <ddarius> roconnor: The solution to that would be False.
16:43:51 <Kim^Walkman> EvanCarroll: Try them out in GHCI, it might clear things up a bit
16:44:01 <roconnor> ddarius: is that what is returned?
16:44:13 <Kim^Walkman> > 5 `div` 2
16:44:15 <lambdabot>   2
16:44:16 <ddarius> roconnor: I have no idea, but I'm pretty confident that is what will be returned.
16:44:18 <Kim^Walkman> > 5 / 2
16:44:20 <lambdabot>   2.5
16:44:26 <Asztal> roconnor: no, that loops
16:44:47 <Axman6> > 5.0 / 2.0 -- clearer what the difference is Kim^Walkman
16:44:49 <lambdabot>   2.5
16:44:55 <benmachine> yeah, isBottom is basically just an unsafePerformIO'd way of catching error calls, if I remember correctly
16:45:10 <copumpkin> isTop
16:45:25 <Asztal> I guess that's why it evaluated to True when I pressed ^C.
16:45:52 <PizzaMan420> is there a way to change an IO String to a String?
16:46:10 <c_wraith> PizzaMan420: yes, but that's probably not what you want to do
16:46:12 * ddarius wonders how many times that exact question occurs in the #haskell logs.
16:46:27 <monochrom> Yes, in the future SYIH module. SYIH = shoot yourself in haskell
16:46:43 <ddarius> :t const "foo" :: IO String -> String
16:46:44 <lambdabot> IO String -> String
16:47:06 <copumpkin> lol
16:47:21 <Axman6> PizzaMan420: sounds like you need my haskell IO tutorial! one sec
16:47:43 <monochrom> PizzaMan420: See http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming for why we don't do that and what we do instead.
16:47:45 <copumpkin> PizzaMan420: if you want a simple answer, you can't, but not all is lost
16:47:45 <Axman6> PizzaMan420: http://random.axman6.com/blog/?page_id=70
16:47:52 <PizzaMan420> most likely, this is my first attempt at IO
16:47:54 <EvanCarroll> how do i find what typeclasses an Int belongs to?
16:47:55 <PizzaMan420> thanks
16:48:05 <osaunders> Can you convert tuples to lists?
16:48:10 <copumpkin> osaunders: painfully
16:48:10 <benmachine> EvanCarroll: :i in ghci
16:48:12 <Axman6> EvanCarroll: :info Int, in ghci
16:48:20 <benmachine> note that it depends on what modules you have imported
16:48:24 <Axman6> osaunders: in general, no
16:48:41 <osaunders> So I can't write fst' :: (a,b,c) -> a
16:48:51 <CalJohn> @src isBottom
16:48:52 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:48:56 <Berengal> osaunders: note that "tuples" isn't a type. It's a collection of types that are somehow related
16:48:57 <Axman6> osaunders: especially since tuples can contain things of different types, and lists can't
16:49:06 <copumpkin> osaunders: the thing about tuples is that despite having a common name and similar syntax, (a,b,c) and (a,b) are completely unrelated
16:49:07 <Axman6> osaunders: you can indeed
16:49:14 <Berengal> osaunders: You can convert any one of them to a list, but you can't convert all of them to a list (with the same function)
16:49:16 <Axman6> :t (\(a,_,_) -> a)
16:49:17 <lambdabot> forall t t1 t2. (t, t1, t2) -> t
16:49:18 <monochrom> fst' (a,b,c) = a
16:49:35 <monochrom> You don't need lists to pick out tuples.
16:49:40 <benmachine> @djinn (a, b, c) -> a
16:49:41 <lambdabot> f (a, _, _) = a
16:49:43 <EvanCarroll> cool, i think I'm starting to get this.
16:49:47 <EvanCarroll> maybe
16:49:51 <PizzaMan420> thanks, Axman6...I'm retarded
16:49:59 <copumpkin> if you want statically sized homogeneous vectors, those are also possible
16:50:23 <Axman6> PizzaMan420: no you're not, IO is somewhat difficult in haskell (it's supposed to be though! to stop you using it more than you have to)
16:50:58 <PizzaMan420> no, I am...I already knew how to do it, but it slipped my mind (even though I've been doing similar stuff for the last hour)
16:51:00 <Berengal> IO isn't especially difficult, just different. But different == difficult until you get it anyway, so yeah...
16:51:13 <Axman6> yup
16:51:22 <Axman6> just like how haskell is difficult :)
16:51:35 <Axman6> man, i haven't actually written anything in haskell for ages :(
16:51:41 <Berengal> Me neither...
16:51:55 <monochrom> You are not retarded because you are like a tennis player switching to bedminton. "what do you mean the ball is no longer allowed to bounce?"
16:51:56 <Berengal> I've been playing with agda, so's all good though
16:51:57 <Axman6> but helping people in here keeps me sharp!
16:52:19 <Axman6> monochrom: they play it in bed now? :O
16:52:23 <ddarius> monochrom: Shuttlecocks don't bounce much...
16:52:53 <c_wraith> ddarius:  play on concrete
16:53:30 <osaunders> Is there any difference between a,b,c and t, t1, t2; or are they just different names?
16:53:48 <Axman6> just different names
16:53:53 <osaunders> OK, cool.
16:53:55 <monochrom> just some algorithm picking names
16:54:16 <Axman6> ... badly >_>
16:54:32 <ddarius> Axman6: It could be far worse.
16:54:38 <Axman6> indeed
16:54:40 <osaunders> It could be random :-/
16:54:45 <ddarius> Axman6: In fact, look at Miranda.
16:54:55 <monochrom> Oh! What did Miranda do?
16:55:08 <Axman6> but, picking from ['a',..] would be nicer imo
16:55:26 <osaunders> The algorithm should generate girls names! elizabeth, mary, rosanne
16:55:27 <Saizan> monochrom: * ** *** **** ...
16:55:46 <Berengal> Saizan: That's horrible!
16:55:52 <monochrom> Hahaha
16:56:07 <monochrom> > drop 26 ['a'..]
16:56:08 <Saizan> it is.
16:56:08 <osaunders> Oh I thought Saizan was swearing!
16:56:09 <ddarius> http://www.cs.kent.ac.uk/people/staff/dat/miranda/Overview.html#Poly
16:56:09 <lambdabot>   "{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\1...
16:57:47 <Axman6> Saizan: ha!
16:58:22 <idnar> that's not really much worse
16:58:22 <Axman6> > text . drop 26 $ ['a'..]
16:58:24 <lambdabot>   {|}~ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂ...
16:58:27 <monochrom> "expected type **********, inferred type ***********
16:58:28 <Axman6> >_>
16:58:36 <Axman6> jesus
16:58:52 <monochrom> You do realize what your suggestion entails. :)
16:59:12 <idnar> haha
16:59:57 <monochrom> expected type ©, inferred type ®
17:01:17 <osaunders> Are there unicode characters for body parts? That would be great. Expected knee, got elbow.
17:01:55 <idnar> Expected knuckle, got ornithopter
17:02:33 <monochrom> expected ☃, inferred ☄
17:02:34 <Berengal> Thank god for descriptive variable names...
17:03:03 <idnar> wat
17:03:12 <idnar> oh, COMET
17:03:25 <monochrom> (expected snowman, inferred asteroid hitting earth and killing everyone)
17:03:39 <ben> "expected snowfall, inferred hailstorm"
17:03:46 <Berengal> I think that means there's a bug in your program
17:03:51 <idnar> hailfall
17:03:52 <tensorpudding> expected expectation, inferred inferences
17:04:03 <monochrom> expected types ar expected
17:04:27 <idnar> unexpected type inferred
17:04:28 <tensorpudding> inferred types are inferred
17:04:35 <Axman6> expected inferred, inferred expected
17:04:42 <tensorpudding> type exceptions are excepted
17:04:59 <Berengal> Expected expected expected expected expected expected expected expected expected expected expected
17:05:06 * osaunders just discovered he can define operators, win!
17:05:08 <idnar> mushroom mushroom
17:05:27 <Berengal> > fix ("expected " ++)
17:05:28 <lambdabot>   "expected expected expected expected expected expected expected expected ex...
17:05:43 <Kim^Walkman> @src fix
17:05:44 <tensorpudding> > fix ("badger" ++)
17:05:45 <lambdabot> fix f = let x = f x in x
17:05:45 <lambdabot>   "badgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerbadgerba...
17:06:02 <ralph> osaunders, are you still looking for (-1)! ?
17:06:07 <shachaf> John, while Jane expected expected expected expected expected expected expected expected the teacher.
17:06:43 <osaunders> ralph: Sure
17:06:59 <idnar> you can take the factorial of a negative number?
17:07:04 * idnar fails at math
17:07:07 <ddarius> idnar: Many of them.
17:07:26 <ddarius> idnar: It's related to the Riemann Hypothesis.
17:07:30 <Axman6> i usuallt define dactorial as: fac n | n < 2 = 1
17:07:37 <osaunders> Is it just -factorial?
17:07:48 <copumpkin> idnar: not the usual factorial, but a certain generalization of the factorial works
17:08:03 <ddarius> idnar: Just a little analytic continuation.
17:08:13 <monochrom> look for the gamma function
17:08:19 <Gracenotes> idnar: can you take the factorial of an arbitrary real number? the answers are a bit related
17:08:22 <copumpkin> unfortunately it's undefined at all negative integers
17:08:31 <ddarius> Gracenotes, idnar: complex number
17:08:31 <ray> also at zero
17:08:37 <Ytinasni> idnar: in short, no. (not the negative integers, anyway)
17:08:55 <Gracenotes> that answer is related too :)
17:08:56 <ray> gracenotes: you can, as long as it's not a negative integer!
17:09:29 <Gracenotes> yeah. the answers aren't the same >_>
17:10:27 <idnar> so you can't take the factorial of -1 then?
17:10:35 <copumpkin> nope
17:10:44 <idnar> wait, is this that captcha thing?
17:10:49 <copumpkin> ?
17:11:12 <ddarius> Γ = M[e^-t]
17:11:28 <EvanCarroll> CalJohn: what was the consensus about the best book for beginers to learn haskell?
17:11:53 <Alpounet> it seems to be lyah, but rwh is nice too
17:12:01 <EvanCarroll> gah
17:12:03 <CalJohn> EvanCarroll: the consensus was the I am wrong
17:12:05 <ddarius> It varies depending on the beginner.
17:12:07 <CalJohn> *that
17:12:11 <EvanCarroll> =(
17:12:29 <CalJohn> i think the Bird book is the best one.  it's clear, simple, logical, but sadly, expensive
17:12:32 <idnar> it looks like the changed it
17:12:42 <EvanCarroll> CalJohn: what is the bird book?
17:12:53 <Alpounet> EvanCarroll, I gave LYAH to a Java developer, it worked nicely ! :)
17:13:01 <idnar> http://www.isotf.org/?page_value=13223
17:13:12 <CalJohn> EvanCarroll: http://www.amazon.co.uk/Introduction-Functional-Programming-Prentice-Computer/dp/0134843460/ref=sr_1_1?ie=UTF8&s=books&qid=1259543912&sr=8-1
17:13:22 <idnar> it used to ask you to "Please enter the first 1150 digits of (1/2)! in reverse order. Starting from the 1st occurrence of the digit sequence, NNNNNNNNN"
17:13:31 <idnar> but now they want digits of e
17:14:26 <benmachine> the digits of e in reverse order?
17:14:27 <PizzaMan420> is there a way to 'debox' something that isn't a monad?
17:14:29 <benmachine> could be a tricky one.
17:14:51 <CalJohn> PizzaMan420: pattern matching?
17:14:54 <tensorpudding> you just need to find the last digit of e first
17:15:05 <benmachine> PizzaMan420: generally things are in boxes because they are different from normal values, so it follows there isn't necessarily a simple way of deboxing them
17:15:09 <idnar> well, it's starting from the first occurrence of a particular sequence
17:15:18 <copumpkin> tensorpudding: in what base?
17:15:22 <idnar> so you have to generate it forwards until you find that sequence, then reverse the last N digits
17:15:26 <tensorpudding> base e!
17:15:29 <benmachine> hah
17:15:37 <idnar> haha
17:15:43 <idnar> they don't specify what base, but I assume it's decimal
17:15:48 <idnar> I'm still not sure whether they're serious
17:16:14 <copumpkin> I wonder what happens if you do
17:16:37 <idnar> that's the "Report a botnet" page, incidentally
17:16:37 <copumpkin> well gamma(1/2) = sqrt(pi)
17:16:43 <idnar> actually, now that I look at it again, the page doesn't do anything
17:16:57 <idnar> there's no <form> or JavaScript
17:17:14 <Gracenotes> copumpkin: very efficient way to calculate pi, incidentally. amirite
17:17:23 <copumpkin> hell yeah
17:17:37 <idnar> haha
17:18:09 <PizzaMan420> you know how you can do something like      value <- getLine, which turns it from IO String -> String, suppose I'm using 'read' to load a constructor, so now instead of MyConstructor, I have IO MyConstructor
17:18:41 <dibblego> PizzaMan420, that doesnt turn IO String -> String (nothing does)
17:18:56 <Alpounet> how would you proceed efficiently to get the prime factors only, from the divisors of a number ?
17:19:04 <copumpkin> filter isPrime
17:19:07 <copumpkin> :P
17:19:07 <benmachine> heh
17:19:17 <CalJohn> PizzaMan420: you have a bit of a conceptual misunderstanding you need to correct, but in the mean time, try x <- read foo
17:19:18 <Alpounet> I'd do that too
17:19:30 <Alpounet> just wondering if there is some more efficient way
17:19:35 <benmachine> CalJohn: eer, what?
17:19:36 <Axman6> CalJohn: uh
17:19:49 <benmachine> fmap read foo, perhaps
17:19:50 <CalJohn> what?
17:19:51 <Berengal> Alpounet: Depends on the efficiency of the isPrime function
17:20:02 <Berengal> Or you could just factorize the number using prime factorization...
17:20:21 <idnar> how do you get IO MyConstructor from read?
17:20:22 <CalJohn> oh, i didn't read his question very carefully...
17:20:35 <benmachine> the fastest way to get a list of factors is to start from the prime factorisation
17:20:43 <benmachine> I think.
17:20:45 <Alpounet> 'k thanks.
17:20:55 <benmachine> if you had a list of prime factors though
17:21:00 <benmachine> err
17:21:02 <benmachine> a list of factors
17:21:26 <idnar> is every number uniquely expressible as a product of powers of prime numbers?
17:21:31 <PizzaMan420> @paste
17:21:31 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:21:35 <benmachine> you could find the prime ones by sorting it into size order, dropping 1, and then filtering all the factors which were divisible by a smaller factor
17:21:43 <ddarius> idnar: Every natural number greater than 1, yes.
17:21:50 <PizzaMan420> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5193#a5193
17:21:56 <idnar> yeah, that's what I meant; thanks
17:21:57 <Gracenotes> idnar: I think a proof for that goes back a ways
17:21:57 <benmachine> 1 is expressive as a product of powers of prime numbers
17:22:08 <benmachine> expressible
17:22:13 <benmachine> i.e. the product of no primes :)
17:22:21 <Axman6> benmachine: in fact, _all_ prime numbers :)
17:22:22 <Gracenotes> may have been one of the Greeks' ones
17:22:38 <idnar> and by "powers" I mean powers with an exponent greater than 0 or something
17:22:38 <benmachine> it's called the fundamental theorem of somethingorother, I think
17:22:47 <ddarius> number theory
17:22:57 <Berengal> benmachine: aren't they all called that?
17:23:03 <benmachine> Berengal: there are a few, yeah
17:23:03 <idnar> anyhow, yeah, I figured that was classic number theory, but wasn't sure if I misremembered
17:23:18 <benmachine> fundamental theorem of calculus and of arithmetic are the two that I remember
17:23:26 <benmachine> err
17:23:29 <benmachine> no, algebra
17:23:35 <PizzaMan420> I guess a better question, is there any way to 'save' the result of a function in a do {...}
17:23:38 <benmachine> that one might be the arithmetic one
17:23:39 <EvanCarroll> I'd love to talk to the guys that wrote RWH
17:23:48 <Axman6> PizzaMan420: save how?
17:23:51 <copumpkin> EvanCarroll: lucky for you all three of them hang out in here
17:23:52 <benmachine> it's in my notes somewhere but I'm too sleepy to go and look it up
17:23:53 <ddarius> benmachine: Algebra's is very handy too.
17:23:55 <Berengal> PizzaMan420: "save" as in give a name to? Use let
17:23:58 <Axman6> EvanCarroll: dons and bos are both here
17:23:59 <EvanCarroll> they have some of the worst `write this program` ideas in the history of orielly books
17:24:02 <ddarius> benmachine: It is.
17:24:03 <EvanCarroll> =(
17:24:06 <copumpkin> EvanCarroll: CosmicRay is the third one
17:24:35 * benmachine thought copumpkin was talking about fundamental theorems still
17:24:41 <CalJohn> PizzaMan420: i don't understand what it is that you mean to ask
17:24:45 <copumpkin> benmachine: fundamental theorems?
17:24:45 <Axman6> EvanCarroll: i think you'd have more fun with haskell is you paid more attention to what you're learning.
17:24:48 <Alpounet> benmachine, haha, me too during few seconds :D
17:24:54 <ray> the fundamental theorem of fundamental theorems
17:25:11 <poe> Is it possible to perform searches in a value of type (Data.Data t) => t looking for a constructor?
17:25:19 <EvanCarroll> Axman6: Well I am learning, sometimes I'm just taking a detour
17:25:40 <CalJohn> PizzaMan420: what is it you want to do?
17:26:07 <CalJohn> oh, answered already
17:26:15 <ddarius> Proving the Fundamental Theorem of Algebra is fun.
17:26:17 <EvanCarroll> “Using the code from the preceding three exercises, impliment Graham's scan algorithm for the convex hull of a set of 2D points. You can find good descriptions of what a convex hull is, and how the Graham scan algorithm should work on Wikipedia.”
17:26:21 <Philonous> What exactly defines a functional programming language? (The exercise just came up in a book to identify "functional" languages )
17:26:22 <EvanCarroll> Wow, thanks guys!
17:26:32 <poe> ddarius which proof do you prefer?
17:26:57 <Axman6> EvanCarroll: they're there for those who afre curious, and actually want to learn how to program in haskell ;)
17:27:00 <EvanCarroll> I think in Learning Perl the third chapter has you count unique works in a file or something
17:27:00 <Berengal> Philonous: first class functions, that's the most fundamental requirement
17:27:05 <ddarius> poe: The one I usually use goes via homotopy.
17:27:14 <idnar> Axman6: except that sounds more like learning unrelated math :P
17:27:23 <EvanCarroll> Axman6: no, I want to do it, I just now have to read about something totally unrelated to learning haskell, in order to beat the challange.
17:27:23 <Philonous> Berengal: When are functions considered "first class"?
17:27:27 <Axman6> it's problem solving
17:27:29 <Berengal> Philonous: But the answer is probably that functional languages aren't exactly defined
17:27:39 <Philonous> Berengal: And is it a sufficient condition ?
17:27:41 <EvanCarroll> Axman6: an almost intentional attempt at raising the learning curve =/
17:27:53 <idnar> Axman6: decyphering some mathematical algorithm is "problem solving" now?
17:27:58 <CalJohn> Philonous: if you want to be really general, you would say "languages that are about functions".  being about functions implies more, but that's a really general def
17:28:13 <Axman6> EvanCarroll: RWH isn't designed as a book to learn from. that's why it's called Real World haskell
17:28:13 <Berengal> Philonous: first-class means that you can treat functions like you treat any other value, and I'd say it's sufficient
17:28:18 <idnar> I mean, I have nothing against problem solving, but that example does seem completely ridiculous
17:28:18 <Philonous> CalJohn: What language then is not about functions?
17:28:23 <ben> Functions are not really first-class if they are not instances of Show and Eq
17:28:24 <copumpkin> EvanCarroll: I agree that's not very helpful
17:28:38 <EvanCarroll> Axman6: ah, maybe this was my own fault for just boying the oreilly labeled book with steller reviews on amazon.
17:28:38 <Axman6> idnar: how is it not? it's not like it's an uncommon thing to do, especially in haskell
17:28:39 <ray> ben: you could write instances if you wanted..
17:28:50 <osaunders> ben: Functions are first-class and they aren't part of show.
17:28:59 <benmachine> show isn't really very interesting
17:29:04 <ray> instance Show (a -> b) where show _ = "<<function>>"
17:29:07 <benmachine> heh
17:29:10 <idnar> Axman6: the time taken to complete the exercise is completely dominated by tasks that have absolutely nothing to do with learning Haskell
17:29:14 <poe> ddarius ah the topological one. I think the complex-analytical one looks quite natural.
17:29:14 <CalJohn> Philonous: you need to understand that functions in the FP sense are proceedures which generally don't have side-effects, and that are somewhat closer to mathematical functions (non-finite ones, at least)
17:29:21 <CalJohn> Philonous: http://www.stanford.edu/class/cs242/readings/backus.pdf
17:29:24 <EvanCarroll> copumpkin: In good humor, these are some pretty mathy-examples for a quiz over a chapter called Defining Types, Streamlining Functions
17:29:27 <ddarius> Berengal: That definition makes almost every extant language a functional one.
17:29:40 <Axman6> EvanCarroll: it's a great book, but not for learning haskell from. it's there mainly for people who have some understanding of haskell, to show them how to use it in the real world
17:29:43 <Philonous> CalJohn: So functions in ML are not functions because they can have side effects?
17:29:59 <idnar> Axman6: and, seriously, implementing "Graham's scan algorithm for the convex hull of a set of 2D points" is "not an uncommon thing to do"?
17:30:05 <Berengal> ddarius: certainly, most modern languages have functional aspects now. Who says a language can't be something other than functional as well?
17:30:13 <ray> first class functions can be passed, returned, created, stamped, indexed, filed, briefed, debriefed, and numbered
17:30:24 <CalJohn> Philonous: well, it's a matter of degree.  in languages like ml and scheme, side effects are not really the convention, whereas with Pascal or C, they are
17:30:25 <copumpkin> they can't be taken apart though
17:30:31 <Axman6> idnar: depends who you are. it may well be an extremely simple algorithm
17:30:31 <copumpkin> since functions have no constructors
17:30:33 <copumpkin> sadly
17:30:36 <ray> their lives are not their own
17:30:38 <ddarius> Berengal: The issue isn't the other language, the issue is the meaning of "functional programming language" then.
17:30:46 <copumpkin> Axman6: it's pretty simple, but not extremely simple
17:30:50 <poe> idnar what about that scan? I've done it in Haskell some time ago!
17:31:04 <CalJohn> Philonous: it's enough to say that functional languages tend to be about applications of functions as a way of working, rather than as an application of side effects
17:31:07 <copumpkin> Axman6: but regardless, it's pretty unrelated to the topic at hand
17:31:13 <idnar> Axman6: if you don't already know a particular algorithm, learning the algorithm is pretty much always going to take longer than actually implementing it
17:31:22 <idnar> I don't think it matters much what the algorithm is
17:31:22 <Axman6> sure
17:31:27 <Berengal> ddarius: Well, "functional programming language" isn't exactly a well defined term. On bad days I have no qualms about calling python functional
17:31:38 <idnar> but I've certainly never even heard of Graham's scan algorithm, and I have only the vaguest clue of what the "convex hull of a set of 2D points" is
17:31:50 <copumpkin> Berengal: one definition strikes me as "best" though :P
17:32:06 <Alpounet> copumpkin, "Haskell" ? :D
17:32:06 <ddarius> Berengal: I agree that it isn't well-defined, but I'm more inclined to lean toward a "porn" like definition than to make "functional programming language" mean "programming language."
17:32:10 <Axman6> idnar: but you seem to disagree that being able to take an algorithm and implement it in a language is not important. and to me, that _is_ what programming is
17:32:18 <EvanCarroll> it is just that I have to read to understand the algotihm that makes it amusing. If it takes me 15 minutes to understand it, and 15minutes to impliment it, I have a yield of 50% on possible haskell-betterment
17:32:35 <idnar> Axman6: no, I don't disagree with that
17:32:47 <ray> if you can't implement al gore in a programming language
17:32:53 <Berengal> ddarius: Usually I require the language to have mathematical (as in pure) functions as well...
17:32:54 <copumpkin> another problem
17:33:02 <copumpkin> is that most algorithm descriptions are not functional
17:33:05 <copumpkin> and are often very stateful, even
17:33:12 <Berengal> ddarius: But that leaves out LISP and... well, most other functional languages...
17:33:16 <ray> well that's just computer scientists for you
17:33:27 <Axman6> EvanCarroll: i think one reason it's ther is that it's a real world problem, ie, the theme of the book
17:33:31 <ray> working with idealized turing or von neumann machines
17:33:32 <PizzaMan420> hmmm, alright I'm trying to change something that was like this: functionName w = abs w, into something like functionName w = do { newV = abs w;
17:33:38 <ddarius> Berengal: Indeed.  It leaves pretty much Clean and Haskell.  Sisal and SAC are first-order purely functional languages though.
17:33:48 <copumpkin> for example, the pseudocode on the referenced wikipedia page is very stateful
17:33:49 <poe> ddarius after mobius transformations they are making videos of everything now :D http://www.youtube.com/watch?v=nRO_4IYOdq8
17:33:57 <ray> berengal: there's functional and purely functional
17:34:02 <ralph> osaunders,  Well, it's a really interesting question involving a lot of cool mathematics, but the short answer is "infinity".
17:34:02 <PizzaMan420> someIO;
17:34:03 <Axman6> copumpkin: doesn't mean the algorithm is
17:34:08 <idnar> Axman6: I just think that if you're trying to learn Haskell, and you're spending most of your time learning some maths that has nothing to do with Haskell, it's probably not a very efficient use of your time
17:34:09 <PizzaMan420> return newV; }
17:34:16 <Saizan> PizzaMan420: you've to use let
17:34:24 <benmachine> it bothers me having learnt haskell how pseudocode is so rarely as inspecific as it claims to be
17:34:32 <idnar> anyhow, that's just one example
17:34:32 <PizzaMan420> alright, I'm trying to use let, but I get an error on the line following it
17:34:35 <copumpkin> Axman6: nope, but it means that not only do the learners need to figure out what the chapter is teaching, but also figure out a new algorithm that they haven't heard of but also implement it in a language they barely know
17:34:39 <Saizan> PizzaMan420: do let newV = abs w; ...
17:34:39 <ray> most pseudocode is algol 68
17:34:47 <copumpkin> Axman6: (using a paradigm it's never described in)
17:35:04 <idnar> but if I was going through the exercises in RWH, I'd definitely skip that one
17:35:04 <Saizan> PizzaMan420: though, why not just "do someIO; return (abs w)" ?
17:35:06 <ray> copumpkin: if you go to the original math papers it's not as bad
17:35:17 <copumpkin> damn CS types have taken over though
17:35:25 <PizzaMan420> sorry, someIO depends on the value, I over generalized
17:35:34 <ray> computer stupids
17:35:37 <EvanCarroll> actually I'm going to skip this
17:35:39 <EvanCarroll> http://en.wikipedia.org/wiki/Convex_hull
17:35:40 <Saizan> PizzaMan420: k, maybe it's an indentation problem, put it on hpaste
17:35:41 <EvanCarroll> jesus christ
17:35:57 <Saizan> @hpaste
17:35:57 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:36:00 <idnar> it also doesn't sound much like a "real world" problem to me
17:36:03 <copumpkin> EvanCarroll: it really isn't that bad, but it looks scary
17:36:13 <ralph> osaunders, longer answer: There's only one function from Complex numbers to Complex numbers which has f n = fact n, for each positive integer.
17:36:22 <idnar> it sounds like something that might be in a library buried a few levels deep in your application stack
17:36:25 <ray> bushwhacking through forests of math notation is the skill you need
17:36:25 <ralph> This function has value +- \infty for every non-positive integer.
17:36:32 <Berengal> ddarius: The definition I used to have, before converting completely to the church of purity and static typing, was a language with first-class functions, lambdas, built-in support for linked lists
17:36:38 <ralph> http://en.wikipedia.org/wiki/Gamma_function
17:36:56 <Saizan> Berengal: linked lists?
17:37:09 <Berengal> Saizan: yes, linked lists.
17:37:33 <PizzaMan420> one min, the error is    "parse error on input 'someIO' "
17:37:34 <copumpkin> seems like the convex hull algorithm could be implemented with filter . groupBy f . sort
17:37:47 <copumpkin> sortBy actually
17:37:48 <CalJohn> Berengal: that does not include python :)
17:37:50 <Berengal> It's more of an observation than a definition, but it's true that most functional languages have built-in support for linked lists
17:37:53 <ray> has anyone implemented the aks primality test in haskell
17:38:03 <poe> copumpkin and also an argument to filter yeah
17:38:05 <copumpkin> ray: I think I might have seen it
17:38:11 <copumpkin> let me see
17:38:16 <Berengal> CalJohn: Right, so python wouldn't be functional by that definition
17:38:26 <idnar> that's a bit ironic; Python passes all of those except the linked lists one
17:38:33 <idnar> but I wouldn't consider Python functional in the slightest
17:38:36 <Saizan> PizzaMan420: don't retype the errors, just copy/paste the real code and the error on the pastebin
17:38:49 <CalJohn> idnar: "python" as a language is almost entirely convention
17:38:58 <Axman6> idnar: after looking at what the convex hull algorithm actually is, i can see it is a very real world problem... sounds like it'd be used in computer graphics and physical simulations all the time
17:38:59 <copumpkin> ray: nope, only miller-rabin in the library I was thinking of
17:39:15 <idnar> Axman6: used, not implemented
17:39:22 <Berengal> idnar: Python can be functional if you want to. It's a laugh to program in after being stuck in Java for a week
17:39:32 <ray> AKS is polynomial-time, but slow :)
17:39:49 <copumpkin> yep
17:39:52 <ray> it's an important result and a terrible algorithm
17:39:54 <Philonous> So "imperative" vs. "functional" is actually a false dichotomy. Well, that's not really news. But I get confused when I read about "functional" languages as if they precisely defined.
17:39:55 <ray> just my kind of thing
17:40:22 <CalJohn> Philonous: why do you think it is false?
17:40:25 <copumpkin> I use functional to mean "expression-based, not statement-based"
17:40:42 <Philonous> copumpkin: Isn't that what "declarative" means?
17:40:44 <idnar> copumpkin: so C is functional? ;)
17:40:45 <Berengal> Philonous: They're not precisely defined, but it's not too hard to spot the difference, unless you start taking a closer look at things.
17:40:54 <idnar> I guess I mean C++, really
17:41:03 <ddarius> Philonous: If someone provides a precise definition, then it is precisely defined.
17:41:06 <ray> C is more functional than you might think
17:41:13 <copumpkin> idnar: nope
17:41:20 <idnar> functions are composed of expressions combined with the ; operator
17:41:27 <Philonous> CalJohn: Because different languages have varying support for handling functions. even java can simulate functional behaviour
17:41:32 <ray> ; is a sequence point
17:41:34 <copumpkin> idnar: not really
17:41:56 <CalJohn> Philonous: no, in practicse, java cannot
17:42:01 <CalJohn> *practice
17:42:13 <idnar> I guess ; isn't an operator after all
17:42:15 <idnar> maybe I'm thinking of ,
17:42:20 <Berengal> CalJohn: With a good enough supporting library it can.
17:42:30 <Saizan> no "java is functional?" please :) it can go on for ages!
17:42:46 <Gracenotes> copumpkin: I also like the expressions vs. statement way of thinking
17:42:47 <CalJohn> Berengal: does that get around the lack of TCO?
17:42:48 <ray> , also is a sequence point
17:42:49 <lunabot>  luna: Not in scope: `also'
17:42:56 <idnar> heh
17:43:04 <ray> , is in fact only useful for side effects
17:43:05 <lunabot>  luna: parse error on input `in'
17:43:12 <Berengal> CalJohn: Dunno. Haven't tried it yet
17:43:16 <copumpkin> Gracenotes: or alternately, "based on lambda calculus as a fundamental model of computation instead of sequential von-neumann-ness"
17:43:24 <Gracenotes> perhaps declarative is a subset of expression-based, just without the ability to modify and evaluate expressions (and with things having a tree-like structure)
17:43:32 <Philonous> CalJohn: Write a little LISP-interpreter in java and you already simulate functional behaviour
17:43:44 <ddarius> How about this definition: If a language claims to be functional, it is; if it doesn't, it's not.  Currently, this is pretty accurate (for one common intuition)
17:43:47 <Berengal> bah... EVERYTHING IS TURING COMPLETE!!!!"
17:43:49 <Berengal> There
17:43:51 <Gracenotes> although that's a bit too strict..
17:43:53 <CalJohn> Philonous: that is more about turing completeness than anything else
17:43:56 * Gracenotes burns Berengal in effigy
17:44:09 <CalJohn> ddarius: python sometimes claims to be functional
17:44:23 <ddarius> CalJohn: Ask Guido.  I'm sure he doesn't.
17:44:23 <CalJohn> Philonous: i don't think it's a false choice so much as it is a matter of degree
17:44:34 <CalJohn> yes, i bet he doesn't
17:44:54 <Gracenotes> nay, functionalness exists on the 12 axes of functionalness
17:45:01 <Gracenotes> (and my sword..)
17:45:04 <Philonous> CalJohn: But that's what "false dichotomy" means (at least that's what I thought), there is not black and white but shades of gray.
17:45:39 <CalJohn> Philonous: i meant that it's a matter of degree within functional langs
17:45:59 <CalJohn> some langs just support the style at all (java is one)
17:46:01 <EvanCarroll> CalJohn: the jvm can get around tco even if java can't, and java can call the code
17:46:03 <CalJohn> *can't
17:46:11 <EvanCarroll> CalJohn: afaik anyway
17:46:14 <Berengal> Functional doesn't mean non-imperative... Haskell has great support for various imperative paradigms as well as functional
17:46:43 <Berengal> And vice-versa, python supports a functional paradigm (on a good day)
17:47:18 <ddarius> http://lambda-the-ultimate.org/node/2410
17:51:39 * hackagebot upload: highlighting-kate 0.2.5.1 - Syntax highlighting (JohnMacFarlane)
17:52:47 <Berengal> And suddenly all was silent
17:52:49 * ivanm wonders if this release of highlighting-kate is lighter to build
17:53:02 * ddarius wishes he hadn't read Imajica so he could read it now.
17:53:08 <ivanm> Berengal: everyone was busy reading the ltu link ddarius provided! ;-)
17:53:47 <Berengal> ivanm: I know I was
17:55:57 <ivanm> by "observable non-determinism", they mean something like the amb operation?
17:56:02 <osaunders> What library is good for creating 2d graphics?
17:56:31 <ivanm> diagrams
17:56:41 <poe> osaunders cairo
17:56:44 <ivanm> (not that I've actually used it...)
17:57:59 <ddarius> ivanm: That would be one source, but concurrency would be the most significant source (though you can have concurrency without observable non-determinism)
17:58:14 <ivanm> right
18:03:17 * BMeph wishes there were a definition of "concurrent" not synonymous with "parallel", that OO advocates would agree to accept...
18:03:52 <ivanm> heh
18:04:46 <Philonous> Well, you don't have much choice but to implement parallelism with concurrent execution
18:05:56 <Saizan> the distinction is not about implementation, in fact
18:06:04 <Axman6> BMeph: what do you mean?
18:06:49 <Axman6> i thought the difference was very clear: parallelism is where you do a lot of the same thing at once, concurrency is where you do lots of things at once (so, parallelism is a subset of concurrency, obviously)
18:07:21 <ivanm> Axman6: right, but most imperative langs seem to implement parallelism with concurrency (or is it vice versa?)
18:07:22 <Axman6> well, concurrency is where you do more than one thing at once
18:07:35 <Axman6> ivanm: nah that's right
18:07:42 <Saizan> it's not same vs. different, it's more about the need of communication/synchronization
18:07:48 <ivanm> I think one of the simons did a post on this recently, with many imperative programmers trying to say he was wrong
18:08:03 <Saizan> i.e. if each thread of execution has to be aware of the others or not
18:08:18 <Axman6> our concurrent systems course used this definition: two things are said to have run concurrently, if to some observer, one cannot be said to have finished before the other has started
18:08:50 <BMeph> Axman6: ...and *that* is what I mean. ;)
18:09:26 <copumpkin> moo
18:09:32 <Axman6> mroww
18:10:46 <papna> The distinction doesn't seem to be clearly, usefully made here.
18:11:04 <Axman6> papna: hmm?
18:12:04 <ivanm> http://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/
18:13:02 <BMeph> ^^ see comment 2 for my complaint. :)
18:13:33 <ivanm> BMeph: yup
18:13:34 <BMeph> Comment 3 is "fun" as well. :)
18:13:51 <ivanm> "Having said that, you should know that concurrency is a superset of parallelism."
18:14:30 <ivanm> the comment by Loup Vaillant is good though
18:14:46 <BMeph> Right. I think he may be using Axman6's prof's definition.
18:15:45 <ivanm> simon's rebuttal comment is also good
18:16:13 <ivanm> but why someone suggests SQL is beyond me...
18:16:34 <Axman6> ... i'm yet to get to SQL... how on earth did that come up o.O
18:17:15 <ivanm> Axman6: apparently its the best/most popular parallel and concurrent language around
18:17:25 <ivanm> even though its debateable whether SQL is a programming language or not
18:17:34 <ivanm> I'd typically classify it as more of a data manipulation language
18:17:40 <sjanssen> SQL databases are often used for applications to sidestep handling concurrency
18:17:53 <ivanm> ahhh
18:18:04 <Saizan> apfelmus++ , actually
18:18:13 <ivanm> since the big brains behind the database must have figured all this out, let the database handle it?
18:18:17 <sjanssen> in your PHP app, you don't worry about concurrency, you let the DB handle it
18:19:04 <Saizan> transactions came out of DBs afterall
18:19:41 <ivanm> so a kind of implicit concurrency?
18:21:30 <dons> a transactional layer that does the work for you.
18:21:39 <Saizan> well, in a PHP app concurrency comes from your server handling multiple requests at once, though each PHP handler just uses the DB to communicate with the others
18:21:43 <ivanm> right
18:21:53 <erikc> SQL is a programming language, it's just guaranteed to terminate
18:22:03 <ivanm> so the PHP app itself doesn't know that its operating in a concurrent fashion
18:22:38 <Axman6> erikc: is it?
18:22:43 <Svrog> would someone be able to tell me what's going on here - it seems arrays beyond a certain size are no longer constructed lazily
18:22:45 <Svrog> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5194#a5194
18:23:17 <erikc> Axman6: yes, that's why it doesnt have recursion (extensions that support recursion require a depth limit)
18:23:28 <Saizan> ivanm: it doesn't spawn threads itself, but that's irrelevant here
18:23:30 <Axman6> hmm
18:23:48 <ivanm> Saizan: right
18:24:05 <ivanm> Axman6: I would have thought to be a "programming langauge", it had to be turing complete
18:24:15 <papna> Pffft.
18:25:07 <Axman6> you can do some pretty messed up stuff in SQL. i've seen the mandelbrot set computed using SQL before
18:25:39 <papna> regex is often called a programming language.
18:26:00 <Axman6> i wouldn't call it one
18:26:31 <sjanssen> > logBase 2 10000000
18:26:32 <lambdabot>   23.25349666421154
18:26:34 <papna> The camel book and lots of other people do.
18:27:00 <sjanssen> Svrog: what exactly are you observing?
18:27:06 <ivanm> ummm.... AFAIK, regexes are always implemented as either a library or a subset of another language
18:27:08 <erikc> Axman6: the Prolog -> Datalog -> SQL connection is pretty interesting, i was so happy when i made the connection in my mind
18:27:13 <byorgey> it depends on your point of view.  You could call regular expressions a programming language for describing certain sets of strings.
18:27:26 <Saizan> ivanm: most dep. typed languages are not turing complete
18:27:29 <ivanm> (or are you calling sed and awk regex interpreters?)
18:27:39 <Axman6> erikc: i'm yet to encounter prolog :(
18:27:43 <ivanm> Saizan: hmmm...
18:28:06 <copumpkin> Axman6: if you've done much type-level programming it isn't that different
18:28:27 <Axman6> well, i haven't (afaik), so...
18:28:36 <papna> ivanm, I'm confused why that controls whether something is a programming language or how it's strictly true. There are many systems that are not programming languages that regex are used with.
18:28:38 <poe> Well usually one does Naturals, I've never seen Complex :D
18:28:39 <Svrog> when n = 1000000 10 values get printed, 1 second apart and the program terminates right away, increasing n by a factor of 10 causes no values to get printed, it seemed like the whole array was being constructed strictly - or that was my suspicion - i guess there could be something else happening that i'm not aware of
18:28:47 <erikc> Axman6: in a nutshell, SQL is logic programming + restrictions that make it guaranteed to terminate and more efficient to execute
18:29:07 <Svrog> err, no 10 values get printed 100ms apart
18:29:25 <papna> ivanm, As Saizan Points out, dependently-typed languages like Epigram aren't.
18:29:31 <Axman6> i quite liked working with relational algebra this semester, especially the query optimisation stuff taught by benl23
18:29:42 <papna> TeX didn't used to be and you could do some pretty programmatic stuff with it.
18:30:31 <Svrog> when i say no values get printed i mean that i have to terminate the program before anything gets printed - i guess something might eventually get printed
18:31:17 <Saizan> Svrog: i'd use trace rather than threadDelay
18:31:40 <Svrog> yeah i suppose - still this should work
18:31:59 <Svrog> or at least i don't understand what is going on
18:32:36 <Saizan> i mean that with trace it might be more easy to figure out what's going on
18:33:09 <kmc> aww man i missed another argument about what "functional language" means
18:33:19 <erikc> i'd really like to productize the ideas from http://www.cs.cornell.edu/bigreddata/games/SGL.php, cause i think relational algebra for video game scripting is a perfect fit
18:34:29 <Svrog> i've just replaced threadDelay with trace and nothing is coming up on screen... odd
18:35:16 <Saizan> so, like "f x = trace (show x) x" ?
18:35:29 <Svrog> Saizan: yes
18:35:47 <Saizan> odd indeed
18:36:05 <Saizan> ah, maybe you need hSetBuffering stderr NoBuffering too
18:36:07 <BMeph> PostSCript: PL or not...GO!
18:36:13 <Svrog> ok - i just got some stuff on screen after 3 minutes
18:36:28 <Svrog> it seems only the first 10 elements got printed
18:36:34 <Svrog> so it is lazy
18:36:47 <osaunders> Does anyone have ideas what I should/could do to fix this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13380#a13380
18:37:07 <Svrog> i'll fiddle with the profiling options a bit, see if i can see what's eating up so much time
18:38:37 <napping> osaunders: that's going to be a bit of a mess. The GL bindings no longer use the plain Float type
18:38:58 <Axman6> osaunders: Frag is old and unmaintained. i'd forget about it personally
18:39:11 <osaunders> Right, OK.
18:39:15 <osaunders> Thanks.
18:40:02 <napping> it's a newtype over plain float and I think in all the same standard classes
18:40:38 <Saizan> Svrog: it might be lazy in the elements and not in the spine of the list
18:40:51 <Svrog> oh hmm
18:40:54 <Svrog> still strange
18:41:03 <napping> a list with an undefined tail would tell that appart
18:41:07 <Svrog> i'm now running it with +RTS -p -hc
18:41:14 <napping> if it doesn't blow up on something like 1:2:3:undefined it's not spine-strict
18:41:20 <copumpkin> tail = bottom
18:41:38 <napping> that's kind of related to what I'm trying to fix
18:41:50 <Axman6> :t let x = y; y = x in x
18:41:52 <lambdabot> forall t. t
18:42:01 <napping> in httpd-shed there's no notification if a connection is lost, and it just grabs the body with hGetContents
18:42:35 <copumpkin> :t let x = x in x
18:42:37 <lambdabot> forall t. t
18:42:39 <Saizan> Svrog: yeah, even with n = 100 it forces the whole spine
18:42:53 <Svrog> hmm
18:42:56 <napping> so I want to make a worker thread that's reading from the socket and passing over data, but also sends an async exception on EOF
18:43:10 <napping> but getChanContents can't send the end of a list
18:43:34 <Axman6> has anyone seen http://lambda-the-ultimate.org/node/3695 ? i went to see Barry Jay his talk about pattern calculus, and i found it fascinating
18:43:51 <napping> I read some of his stuff from a while ago
18:44:00 <napping> Sounds like he's worked out more on the type system
18:44:16 <Svrog> why is that causing such a huge difference in running time though? from a fraction of a second when n = 1000000 to 2 minutes when n = 10000000
18:44:28 <napping> does anyone use httpd-shed?
18:44:56 <dons> napping: you can send Maybe a's down the chan
18:45:12 <Saizan> Svrog: that's because you g is too lazy i think
18:45:12 * Axman6 was just about so suggest that
18:45:14 <dons> Svrog: what's the GC doing?
18:45:16 <Svrog> profiling info doesn't tell me much "total time = 0.10 secs   (5 ticks @ 20 ms)"
18:45:20 <dons> +RTS -sstderr
18:45:30 <Saizan> ..or maybe not
18:45:46 <Saizan> though it's a loop with an accumulator, so i'd make the accumulator strict
18:46:11 <dons> definitely.
18:46:34 <Svrog> i'm still not sure how that explains the time difference
18:47:01 <dons> what's the code for, btw?
18:47:09 <dons> listArrays isn't too common
18:47:17 <Axman6> dons: have you looked at implementing stream fusion using those specialised lists types you wrote about a while ago? i was thinking about it the other day, and i'd be interested in seeing how it performs (i'd be quite happy to look into it myself once i get my macbook pro back)
18:47:32 <dons> with fusion it should be identical to other fused systems
18:47:37 <Svrog> g a x | a `seq` True = (y, y) where y = a + f x
18:47:41 <Svrog> doesn't appear to have made a difference
18:47:54 <Saizan> true
18:48:09 <Axman6> Svrog: you could just use bang patters by the way :)
18:48:21 <Axman6> g !a x = (y,y) where...
18:48:22 <dons> Svrog: this is for the function in the mapAccumL ?
18:48:34 <Svrog> dons: yes
18:48:36 <napping> dons: actually, there's a specified Content-Length, so I'm thinking of just passing strict bytestrings, and using the lazy take on chanContents
18:48:38 <dons> i don't think you can make that tuple strict.
18:48:58 <Svrog> oh hmm
18:49:01 <napping> dons: did you get an example of some approximate string matching array code?
18:49:09 <Axman6> dons: yeah i was thinking the same thing. though the fact that you're uften using unboxed values might make some difference right?
18:49:29 <dons> Axman6: you might see different optimizations fire
18:49:47 <Axman6> i'll have to check it out sometime :)
18:49:48 <dons> Svrog: this looks like a bad use of boxed arrays, btw. uvector or even lists would be more appropriate.
18:49:52 <Saizan> Svrog: it goes from 12mb to 133mb peak use though
18:49:55 <Axman6> (soon)
18:50:02 <dons> Svrog: i imagine you're just experimenting though?
18:50:30 <copumpkin> > groupBy (<=) ([1,4,6,7,2,3,4,1,7,2,5,3]
18:50:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:50:36 <Svrog> dons: sort of - i ran into it with something i've been doing - wanted to see if i could use arrays for caching instead of random access lists i was using before
18:50:45 <copumpkin> > groupBy (<=) [1,4,6,7,2,3,4,1,7,2,5,3]
18:50:47 <lambdabot>   [[1,4,6,7,2,3,4,1,7,2,5,3]]
18:50:54 <copumpkin> > groupBy (>) [1,4,6,7,2,3,4,1,7,2,5,3]
18:50:56 <lambdabot>   [[1],[4],[6],[7,2,3,4,1],[7,2,5,3]]
18:50:58 <dons> a better array type would be one you don't have to convert to and from lists.
18:50:59 <copumpkin> bah
18:51:11 <Niccus> groupBy (<=) [5,4,6,7,2,3,4,1,7,2,5,3]
18:51:15 <Niccus> > groupBy (<=) [5,4,6,7,2,3,4,1,7,2,5,3]
18:51:17 <lambdabot>   [[5],[4,6,7],[2,3,4],[1,7,2,5,3]]
18:51:34 * Axman6 hates groupBy :(
18:51:50 <Axman6> there needs to be another one, that compares adjacent elements
18:51:58 <copumpkin> yeah
18:52:18 <Axman6> would make nice merge sorts really easy
18:53:54 <ivanm> Axman6: define one!
18:54:05 <ivanm> and send it to the libraries list for inclusion into Data.List!
18:54:49 <Svrog> dons: arrays seem to do just what i want and work really well while they are small - but as soon as i increase the size it all falls apart - i need random access so i can't use lists - i've used okasaki's random access lists before and they worked
18:55:18 <ivanm> Svrog: maybe a Map?
18:55:21 <Svrog> so i can go back to those, but i'm still wondering about why arrays aren't working
18:55:34 <Svrog> Map can't be constructed lazily
18:55:37 <PizzaMan420> in windows how do I make the ghci execute a 'main' function
18:55:53 <Saizan> the point is that arrays are not constructed lazily either
18:55:58 <ivanm> PizzaMan420: :main ?
18:56:01 <PizzaMan420> when I double click, right now it starts the interpreter and I have to type    main
18:56:02 <ivanm> or just do main ?
18:56:03 <Axman6> PizzaMan420: load the tile, and run main
18:56:11 <ivanm> PizzaMan420: oh, you want a script?
18:56:16 <ivanm> runhaskell / runghc ?
18:56:38 <PizzaMan420> there isn't a way to just make the interpreter run it?
18:56:51 <medfly> why the interpreter?
18:57:00 * medfly is confused.
18:57:12 <PizzaMan420> since it's associated with double clicking the file
18:57:17 <PizzaMan420> and I'd rather not change that
18:57:26 <ivanm> PizzaMan420: why not compile it?
18:57:26 <PizzaMan420> no worries if I can't do it, just curious
18:57:36 <ivanm> PizzaMan420: this is on windows?
18:57:40 <PizzaMan420> ya
18:57:40 <ivanm> right, you said that
18:57:49 <ivanm> PizzaMan420: look up how to use runghc or runhaskell on windows
18:58:59 <PizzaMan420> thanks
18:59:14 <Saizan> Svrog: try this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5194#a5195 , you'll see that all the elements get printed to screen before the actual print runs, so, while the elements itself are not force by listArray, the structure of the list is
19:00:17 <Svrog> oh hmm
19:00:31 <Svrog> yeah
19:00:58 <Saizan> s/itself are not force/themselves are not forced/
19:00:59 <Svrog> that should be alright though
19:01:08 <Svrog> i think - for what i need anyway
19:01:08 <napping> dons: I was talking to someone at UIUC who had written some edit distance code and was getting at best 2x C or so with various array libraries
19:01:35 <copumpkin> omg the gauntlet has been thrown
19:01:49 <napping> I guess he didn't send the code?
19:03:28 <Svrog> Saizan: just using your example, getting rid of mapAccumL, array construction still takes forever beyond a certain size
19:03:39 <Svrog> is there maybe some rts parameter i could use to help with this?
19:04:22 <Svrog> or is there a more efficient way to construct an array
19:07:43 <Saizan> Svrog: there are options to control the GC, see +RTS --help and the user manual
19:07:55 <Svrog> yeah that's what i'm fiddling with now
19:07:59 <Saizan> Svrog: uvector should have more efficient ways to build arrays too
19:08:21 <Svrog> oh
19:08:53 <napping> That might not fuse so well, but it shouldn't end up strict - total runtime should be O(n)
19:09:12 <Svrog> increasing heap size seems to have solved it - though i had to increase it to something ridiculous
19:09:16 <napping> make that unsafePerformIO print something if you really want to see if stuff is being forced
19:09:56 <BMeph> Is there a tutorial for how to use an UArray
19:09:58 <BMeph> ?
19:10:11 <napping> um, you are making 10M elements. and if it's *not* strict then those are thunks
19:10:29 <napping> are you running with optimizations?
19:10:36 <Svrog> yes, -O2
19:10:55 <Svrog> with -H150M it takes 28 seconds, with -H200M it takes 5 seconds
19:11:33 <napping> sounds like it's being a bit slow to decide to grow the heap
19:11:35 <Svrog> hmm i guess i'll go back to random access lists for this
19:12:03 <napping> why do you want to keep it lazy?
19:12:06 <copumpkin> ack, random access lists?
19:12:15 <copumpkin> that sounds painful
19:12:26 <Svrog> not that painful actually
19:12:36 <Berengal> Nothing's random access, really.
19:12:45 <Svrog> i need to keep it lazy when running mapAccumL over a large file
19:12:53 <Svrog> and then caching the computation at certain intervals
19:13:06 <Svrog> so on the next pass it can be restarted from arbitrary point cheaply
19:14:50 <napping> Well, the array is always constructed all at once
19:15:13 <Svrog> that's not a problem though
19:15:23 <Svrog> the elements of the array are lazy
19:15:37 <Axman6> are you using unboxed arrays?
19:15:41 <Svrog> yes
19:15:45 <Svrog> err
19:15:45 <Axman6> then no, they aren't
19:15:45 <Svrog> no
19:15:48 <Svrog> yeah
19:15:50 <Axman6> ok
19:15:53 <Svrog> not using unboxed arrays
19:16:07 <napping> still, it will have a linear up front cost, before you can start incrementally forcing work
19:16:35 <osaunders> Is there someone we can email about Hoogle?
19:17:10 <napping> allocating the array is one thing, but the work to fill it is another
19:17:27 <napping> but do you really need that many checkpoints?
19:17:28 <byorgey> osaunders: I'm pretty sure Neil (ndm) is aware of the problem by now
19:18:06 <ivanm> there's been at least 2 emails on -cafe about it IIRC
19:18:31 <osaunders> ivanm: What did they say?
19:19:18 <Svrog> filling it with thunks doesn't take that long - i guess the amount of space those thunks take up is
19:19:31 <ivanm> that hoogle was down
19:19:33 <Svrog> is a problem*
19:20:34 <napping> so, would anyone care if shed started your callback with async exceptions blocked?
19:20:35 <osaunders> ivanm: So not that anyone has been notified or is dealing with it?
19:20:46 <ivanm> osaunders: ndm knows about it
19:21:08 <Saizan> napping: what's shed?
19:21:14 <osaunders> According to byorgey.
19:21:54 <atp> quick ffi question: how does one go about writing the foreign import declaration for a C function that takes a call-by-value struct in its arguments?
19:22:39 <napping> Saizan: httpd-shed, a simple http server library. You give it a function from HTTP request to IO of http response, which gets run in a new thread for each connection
19:22:49 <copumpkin> atp: is such a calling convention even standardized?
19:23:15 <napping> except I'm writing some comet stuff with long polling, so I want the worker to be notified if the connection goes away
19:23:51 <Saizan> napping: how is blocking exceptions helping with that?
19:24:19 <napping> Saizan: well, I'm planning on notifying the worker with an async exception. Starting with them blocked gives you a chance to set up an exception handler
19:25:00 <napping> If you didn't do that a client that sends a request and immediately closes the connection might be missed entirely
19:25:05 <Svrog> atp: i'm not sure i understand the question - do you mean to pass a value from haskell to c as a c struct?
19:25:08 <napping> but you can't send a response so maybe it's not so important
19:25:27 <napping> atp: you can't do that, you have to pass structs by reference - so write a wrapper, like for macros
19:25:40 <atp> sigh
19:25:43 <atp> i was afraid of that
19:25:45 <Saizan> atp: i think i'd make a C wrapper that uses call by reference
19:25:58 <atp> copumpkin: it's been part of the C spec since the K&R days
19:26:12 <napping> besides, what would it look like Haskell side? you have to marshall the data into a buffer somehow
19:26:20 <atp> copumpkin: the very early versions of C didn't support it, but it's been widely supported since the 80s
19:26:40 <copumpkin> atp: it seems error-prone, given that the layout of a struct can be affected by pack pragmas and the like
19:26:43 <dankna> you CAN pass structs by value, yes
19:26:57 <copumpkin> but I guess that's the same with anything struct-related
19:27:01 <dankna> I didn't know for the longest time, but it's been there since practically forever
19:27:02 <Svrog> atp: what are you trying to do?
19:27:18 <Axman6> copumpkin: i've done it numerous times
19:27:18 <atp> Saizan: yeah, it's not a big deal, I can write a wrapper, i'm already doing that anyway, since it's to interface with libpng and libpng uses setjmp for error control, making it haskell unfriendly
19:27:46 <napping> If it's really important to you, you might figure out the exact calling
19:27:50 <copumpkin> Axman6: I know it's allowed, I just didn't think there was a particularly standard way of doing it in terms of binary compatibility
19:28:08 <atp> copumpkin: it's really not a big deal, you just push it onto the stack, you don't need to know anything about its internal structure, unless you're working with libraries or something
19:28:28 <napping> IIRC it either ends up passing values in registers, or under the hood you are passing a pointer to a stack allocated value
19:28:47 <atp> copumpkin: if you pass a pointer to a library it also needs to be able to predict the binary layout, you know
19:28:53 <copumpkin> yeah
19:29:03 <dankna> it's the ABI's responsibility to make it work.  on Mac/Intel it acts exactly the same as if you had passed each field of the struct in turn, as a separate parameter.
19:29:16 <copumpkin> I see
19:29:17 <dankna> and returning one does it with a pointer to a stack-allocated struct.
19:29:18 <napping> wait, I'm thinking of structs "returned by value"
19:29:28 <napping> yeah, like dankna says
19:29:37 <atp> napping: that's a different beast, since the return value of a function is usually in %eax
19:29:42 <atp> napping: (on x86)
19:32:00 <dankna> or actually I think returning does something like, the caller passes a pointer to where it wants the value written
19:32:10 <dankna> but it doesn't matter - you can look this up if you really need to know
19:32:20 <dankna> the point is only that it's part of the platform ABI
19:32:31 * Axman6 doesn't think you should have to know
19:33:39 <napping> To make that work you'd need some sort of Haskell-side description of your struct type
19:33:47 <napping> Maybe like NLFFI
19:34:01 <napping> unfortunately I think it would be a bit ugly
19:35:09 <napping> You'd be like foreign import foo :: CInt -> (CStructCons CInt (CStructConst CInt CStructNil)) -> IO () for passing a pair and stuff
19:35:45 <dankna> yes, something like that
19:35:52 <dankna> libffi will take care of the portability details for you
19:42:56 <Axman6> handy: http://i.imgur.com/YjWta.jpg
19:43:45 <EvanCarroll> how come `and []`, evaluates to true, and `or []`, evaluates to false.?
19:43:55 <Axman6> @src and
19:43:55 <lambdabot> and   =  foldr (&&) True
19:43:59 <Axman6> @src or
19:44:00 <lambdabot> or    =  foldr (||) False
19:45:01 <Axman6> EvanCarroll: with and, all of the elements of an empty list are True, where as with or, none of the elements are True. or is for is you need one True, and is for when you need all Ture
19:45:05 <Axman6> rue*
19:45:21 <EvanCarroll> hrm that makes sense knowing implimentation
19:46:18 <EvanCarroll> Axman6++ thanks.
19:46:41 <napping> dankna: I see libffi has a little nicer syntax with the list sugar
19:46:43 <Axman6> basically, it got to do with the identities of (||) and (&&) are
19:48:02 <dibblego> EvanCarroll, read or out aloud as "there exists a True element in..."
19:48:21 <dibblego> EvanCarroll, read and out aloud as "any elements are True in..."
19:48:33 <EvanCarroll> you mean false
19:48:38 <dankna> napping: indeed
19:49:03 <dibblego> EvanCarroll, no
19:49:23 <Axman6> dibblego: i think your second one is wrong
19:49:31 <EvanCarroll> that's what i was correcting
19:49:37 <Axman6> i think you mean all elements are true
19:49:46 <dibblego> s/any/all
19:49:55 <Axman6> :)
19:50:39 <dibblego> s/any/any of the
19:52:58 <sanders_> anyone know of a good explanation of the Reader Monad (not how to use it but how it is implemented)
19:55:02 <copumpkin> sanders_: nope, but it's quite easy to explain if you have any particular questions
19:56:23 <roconnor> > 2/3*20
19:56:24 <lambdabot>   13.333333333333332
19:57:50 <MoALTz> > map (uncurry (+)) (zip ([0]++ps) (ps++[0])) $ [1,4,6,4,1]
19:57:51 <lambdabot>   Not in scope: `ps'Not in scope: `ps'
19:58:04 <MoALTz> > (\ps -> map (uncurry (+)) (zip ([0]++ps) (ps++[0]))) $ [1,4,6,4,1]
19:58:06 <lambdabot>   [1,5,10,10,5,1]
19:59:28 <m0nkfish> @src uncurry
19:59:29 <lambdabot> uncurry f p = f (fst p) (snd p)
20:00:06 <m0nkfish> that is a cute way of thinking
20:00:26 <MoALTz> would have thought that would be more accurate as: uncurry f (a,b) = f a b    ?
20:00:52 <m0nkfish> s/accurate/expressive
20:00:53 <m0nkfish> :P
20:01:06 <ivanm> MoALTz: pattern matching
20:01:08 <m0nkfish> but yeah it's not as immediately obvious as yours
20:01:12 <ivanm> and laziness
20:01:26 <ivanm> MoALTz: what happens for uncurry const (2, undefined) ?
20:01:35 <ivanm> > uncurry const (2, undefined)
20:01:36 <lambdabot>   2
20:01:44 <ivanm> hmmm, I thought that was going to crash...
20:01:57 <MoALTz> (\f (a,b) -> a b) const (2, undefined)
20:02:00 <dibblego> (,) is the top-level constructor
20:02:01 <MoALTz> > (\f (a,b) -> a b) const (2, undefined)
20:02:03 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
20:02:03 <lambdabot>    arising from the literal `2' at <...
20:02:28 <ivanm> seems to work for both...
20:02:35 <MoALTz> heh :)
20:02:41 <ivanm> @type \ f (a,b) -> f a b
20:02:43 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t1) -> t2
20:03:06 <MoALTz> :t const
20:03:08 <ivanm> MoALTz: possibly the same reason they don't pattern match for partition
20:03:08 <lambdabot> forall a b. a -> b -> a
20:03:10 <ivanm> @src partition
20:03:11 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
20:03:11 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
20:03:11 <lambdabot>                               | otherwise = (ts, x:fs)
20:03:32 <ivanm> oh, they do pattern match there...
20:03:36 * ivanm is confused :s
20:03:46 <MoALTz> @src fst
20:03:47 <EvanCarroll> wow...
20:03:47 <lambdabot> fst (x,_) =  x
20:03:59 <MoALTz> i don't see the difference as fst pattern matches anyway?
20:04:32 <EvanCarroll> "Haskell's type system makes it an interesting challenge to write functions that take variable number of arguments". So if we want to zip three lists together, we call zip3 or zipWith3, and so on, up to zip7 and zipWith7"
20:04:37 <EvanCarroll> that's amusing.
20:04:46 <ivanm> MoALTz: if the second arg isn't needed, then snd p won't be evaluated
20:04:48 <rwx> just do a metaZip ;-)
20:04:51 <shachaf> EvanCarroll: It's possible, though.
20:04:54 <dibblego> EvanCarroll, see Control.Applicative
20:04:59 <ivanm> EvanCarroll: why?
20:05:14 <m0nkfish> woah what's ~
20:05:19 <m0nkfish> i've never seen that in haskell before
20:05:21 <m0nkfish> should i be alarmed
20:05:22 <ivanm> irrefutable pattern match IIRC
20:05:29 <ivanm> m0nkfish: it says it _has_ to be a pair
20:05:32 <ivanm> MoALTz: I know why...
20:05:44 <ivanm> because the pair _itself_ could be undefined
20:05:46 <EvanCarroll> ivanm: just that the size of the zip is static
20:05:53 <ivanm> if it tries to pattern match, then it will fail
20:05:56 <Axman6> > (,,,,,,,) <$> [1,2] <*>  [1,2] <*> [1,2] <*> [1,2] <*> [1,2] <*> [1,2] <*> [1,2] <*> [1,2]
20:05:57 <lambdabot>   [(1,1,1,1,1,1,1,1),(1,1,1,1,1,1,1,2),(1,1,1,1,1,1,2,1),(1,1,1,1,1,1,2,2),(1...
20:05:58 <ivanm> EvanCarroll: why is it amusing?
20:06:13 <ivanm> type-wise, it _has_ to be!
20:06:24 <EvanCarroll> ivanm: because there are 7 functions that must have fairly redundant bodies
20:06:37 <ivanm> so?
20:06:40 <ivanm> @src zip
20:06:40 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
20:06:40 <lambdabot> zip _      _      = []
20:06:43 <ivanm> @src zip3
20:06:43 <lambdabot> zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
20:06:44 <lambdabot> zip3 _      _      _      = []
20:06:44 <EvanCarroll> i didn't say you would find it amusing
20:06:45 <dibblego> EvanCarroll, no they mustn't
20:07:01 <copumpkin> EvanCarroll: you could write a generic one too, using type-level naturals, but it's more work and doesn't work on different types
20:07:01 <MoALTz> that is quite a cool definition
20:07:04 <ivanm> EvanCarroll: they _have_ to be separate due to Haskell's strong static typing
20:07:16 <ivanm> you lose some flexibility, but you get a much bigger safety net in exchange
20:07:23 <ivanm> @src zip7
20:07:24 <lambdabot> Source not found. Where did you learn to type?
20:07:24 <copumpkin> EvanCarroll: in the more generic case, it's just transpose
20:07:57 <ivanm> transpose = zipN listFrom
20:07:58 <ivanm> ;-)
20:08:06 <ivanm> copumpkin: s/more/most/
20:08:09 <dibblego> > getZipList ((+) <$> ZipList [1,2,3] <*> ZipList [100..])
20:08:11 <lambdabot>   [101,103,105]
20:08:11 <rwx> MoALTz, did you see that link on lambda the ultimate re: pattern matching data structures or something?
20:08:22 <MoALTz> no
20:08:37 <copumpkin> Cale: is it possible to ask mathematica to substitute complex expressions for me? /. doesn't seem to be doing it for a large fraction I want to factor out of an expression and replace with a single-letter variable
20:08:55 <rwx> imo advances in languages are going to come from theory, not some dude's opinion of being in the trenches and that we need to focus on conciseness ;-)
20:10:25 <copumpkin> ivanm: it's not the most general, unfortunately
20:10:46 <copumpkin> but you could probably coax that most general form out of it with some hlist-like hackery
20:11:06 <roconnor> > 1/3*20
20:11:08 <lambdabot>   6.666666666666666
20:14:49 <EvanCarroll> @src unwords
20:14:50 <lambdabot> unwords [] = ""
20:14:51 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
20:14:56 <EvanCarroll> @src unlines
20:14:57 <lambdabot> unlines = concatMap (++ "\n")
20:15:18 <EvanCarroll> is there a reason why the two are implimented differently?
20:16:10 <copumpkin> unlines adds a newline at the end
20:16:10 <Axman6> good question
20:16:17 <EvanCarroll> copumpkin: right, but why?
20:16:29 <copumpkin> because typical uses of it prefer that
20:16:40 <copumpkin> many things will complain if your file has no newline at the end of it
20:16:53 <copumpkin> it makes cat output ugly ;)
20:17:10 <EvanCarroll> gah. ok.
20:17:49 <idnar> newlines are generally used as line terminators, rather than line separators
20:18:13 <idnar> whereas spaces are used as word separators
20:18:58 <roconnor> ``No compiler other than GHC comes close to supporting enough language features to be able to use many of the packages from Hackage.
20:18:58 <roconnor> is this true?
20:19:11 <EvanCarroll> does ++ in the context of the foldr1 in ws always evaluate its rhs ? how would I find out if it works on an infinate list by reading they :t or :i
20:20:03 <Niccus> > foldr1 (++) $ repeat ""
20:20:07 <roconnor> > [1]++undefined
20:20:08 <lambdabot>   mueval-core: Time limit exceeded
20:20:08 <lambdabot>   [1* Exception: Prelude.undefined
20:20:24 <roconnor> > head ([1]++undefined)
20:20:26 <lambdabot>   1
20:20:34 <idnar> you can't really determine the strictness or productiveness of a function just by examining the type
20:21:00 <sanders_> copumpkin, I didn't really have  a specific question in mind I am just trying to understand how it actually works
20:21:01 <MoALTz> > head $ [1]++undefined
20:21:03 <lambdabot>   1
20:21:33 <mtnviewmark> cabal question: is it normal behavior if I have a .cabal with a lib and an executable for a built to build the library twice - once for the lib, and again for the exec?  why doesn't the exec just use the lib just built?
20:22:46 <EvanCarroll> so because `take 5 $ foldr (++) ""`, fails, we conclude that ++ is evaluating its rhs strictly? is that proper logic, and wording?
20:23:46 <dibblego> no, it's failing because the expression is undefined
20:24:20 <mtnviewmark> I think EC means take 5 $ foldr1 (++) $ repeat ""
20:24:25 <EvanCarroll> yes i did
20:24:27 <EvanCarroll> ;(
20:24:34 <mtnviewmark> > take 5 $ foldr1 (++) $ repeat ""
20:24:35 <EvanCarroll> I typed it right in ghci!
20:24:38 <lambdabot>   mueval-core: Time limit exceeded
20:25:21 <mtnviewmark> but, no, EC, your logic is wrong
20:25:25 <mtnviewmark> consider:
20:25:34 <mtnviewmark> > take 5 $ foldr1 (++) $ repeat "bob"
20:25:36 <lambdabot>   "bobbo"
20:26:01 <mtnviewmark> the first one failed because no amount of computation would ever yield 5 values
20:26:41 <EvanCarroll> right =(
20:27:12 <EvanCarroll> so then I was was right initially, the foldr1, will work on inf lists, because the rhs of ++ is lazy (which can't be determined easily without trial and error)
20:27:20 <mtnviewmark> the second one works, not because (++) is strict or lazy -- but because when the value is finally demanded (by the print-loop) the take 5 basically throws away the lazy, uncomputed infinite computation of foldr (++)
20:28:51 <mtnviewmark> I think you should assume that all functions are lazy in their arguments unless expressly documented otherwise
20:29:39 <rasfar> roconnor: certainly most of them rely on extensions, and browsing info about the other compilers listed on the haskell.org front page it looks doubtful that they achieve sufficient support for those.  GHC pretty much defines contemporary production Haskell by the looks of it.
20:33:17 <Axman6> g'day bfh6558
20:33:48 <bfh6558> why hello
20:34:02 <rasfar> \me reminisces about the days he used hbc...
20:34:20 <rdeshpande> hi all
20:34:34 <rdeshpande> im having trouble understanding this line: mapFold = foldl (\map (k, v) -> Map.insert k v map) Map.empty al
20:35:37 <aavogt> @src M.fromList
20:35:37 <lambdabot> Source not found. Wrong!  You cheating scum!
20:35:57 <Axman6> rdeshpande: what do you not understand about it?
20:36:32 <m3ga> rdeshpande: al is a list of (key, value) pairs, Map.empty is an empty map. the foldl folds all the (k,v) pairs into the map using an insert.
20:37:04 <mtnviewmark> surely that should be foldl'
20:37:09 <rdeshpande> what is the purpose of the initial 'map (k, v)'?
20:37:17 <mtnviewmark> lambda
20:37:28 <mtnviewmark> it is a local function to the expression, those are the arguments
20:37:44 <mtnviewmark> two arguments: a map and a pair or key and value
20:37:59 <Axman6> rdeshpande: do you know about lambdas?
20:38:02 <rdeshpande> oh i was reading that wrong
20:38:08 <Axman6> > (\x -> x^2) 4
20:38:09 <rdeshpande> so map is not actually calling the map function
20:38:10 <lambdabot>   16
20:38:19 <rdeshpande> it's a local variable?
20:38:23 <Axman6> no. rdeshpande it's a bad name imo :)
20:38:25 <Axman6> yes
20:38:30 <rdeshpande> *smacks head*
20:38:37 <rdeshpande> now it makes sense
20:39:13 * Axman6 dislikes it when updated software is more broken than previous versions >_<
20:39:34 <mtnviewmark> if could have been written    foldl (flip $ uncurry Map.insert) Map.empty al
20:39:40 <mtnviewmark> but I'm just being silly
20:40:33 <mtnviewmark> :t flip $  uncurry Data.Map.insert
20:40:34 <lambdabot> forall a b. (Ord a) => M.Map a b -> (a, b) -> M.Map a b
20:40:43 <ivanm> Axman6: what broke?
20:40:58 <Axman6> BlazeHDTV
20:43:28 <Axman6> why can't they just make VLc not suck? :(
20:43:30 <Axman6> VLC*
20:44:36 <mtnviewmark> because it isn't written in Haskell?  ;-P
20:45:24 <Axman6> also, why is there so much crap windows software?
20:45:27 <osaunders> Where are libraries generally stored?
20:45:37 <osaunders> If I want to find out what modules I have, where do I go?
20:45:44 <mtnviewmark> ghc-pkg list
20:46:08 <mtnviewmark> then .... ghc-pkg describe some-package
20:46:14 <osaunders> Oooh. Thanks
20:46:25 <mtnviewmark> will tell you where all its parts are stored (like libs, data, doc, etc.)
20:47:24 <mtnviewmark> note the blessing and curse: since packages are registered, they could be ANYWHERE on your disk -- they don't all have to be in a small number of places
20:48:06 <rdeshpande> sorry guys, but to go to my previous code paste, where does the 'map' variable come from? i don't understand where it is created. i see that it is the last argument passed to Map.insert
20:48:22 <medfly> what's a variable
20:48:28 <mtnviewmark> if I have a function with an equation like:    foo (Thing _ _ _ xs) s = ..... (length xs) ......
20:48:53 <Axman6> rdeshpande: do you know who foldl works?
20:48:54 <mtnviewmark> and I only use xs to get its length... there should be no point  in forcing it with seq, shoudl there?
20:49:14 <Axman6> mtnviewmark: no, why would there be?
20:49:30 <Axman6> length forces the spine of the list anyway
20:49:48 <mtnviewmark> first time optimizing memory behavior of code and trying to understand....
20:49:57 <Axman6> @src length
20:49:58 <lambdabot> Source not found. Maybe you made a typo?
20:50:00 <dons> hey mtnviewmark. sorry it is so busy in here.
20:50:01 <Axman6> :\
20:50:03 <rdeshpande> Axman6: yes, but with simpler usage..
20:50:13 <dons> Cale: happen to be around to help mtnviewmark ?
20:50:15 <dons> ddarius: ?
20:50:19 <Axman6> rdeshpande: well, map in that case is the accumulating parameter
20:50:24 <medfly> dons, no
20:50:56 <mtnviewmark> dons - s'okay - with 600+ people, what can one expect?
20:51:40 <bos> mtnviewmark: wha happen?
20:51:41 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
20:51:41 <rdeshpande> Axman6: how come 'Map.empty' is not the accumulator? e.g. foldl (+) 0 [1,2,3] .. isn't 0 the accumulator?
20:52:07 <rdeshpande> im going to read up on foldl
20:52:10 <mtnviewmark> oh - I'm trying to figure out why my lib is slow - or where
20:52:20 <mtnviewmark> I found the thing that caused it to keep ALL memory until the end
20:52:28 <Axman6> rdeshpande: it is the accumulator. the first time around the fold, Map.empty is the accumulator. the next time, it is Map.empty with the first element of the list inserted into it
20:52:35 <mtnviewmark> foldM isn't strict in the accumulating arg
20:53:03 <bos> mtnviewmark: yeah, foldM is kind of useless.
20:53:29 <Axman6> :t foldM
20:53:30 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:53:40 <mtnviewmark> really? seemed just the ticket for threading a Statistics accumulator through a bunch of file reads....
20:54:23 <bos> mtnviewmark: yeah, but it's a non-strict left fold.
20:54:35 <bos> which is as useful as a smoked fish encased in a ton of glass.
20:55:08 <mtnviewmark> well... not so bad - I just made my accum. fn seq its argument
20:55:16 <mtnviewmark> thus: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13384#a13384
20:55:21 <bos> dons: did you ever try writing a concat with stream fusion?
20:55:37 <bos> mtnviewmark: good for you
20:55:45 <bos> mtnviewmark: what else is biting you?
20:55:57 <Axman6> bos: i believe there is one in the stream fusion library
20:56:06 <mtnviewmark> well - only after I puzzled why it was holding onto tons of memory until the end
20:56:18 <rdeshpande> Axman6: ah, got it. thanks.
20:56:39 <bos> Axman6: there is, but it's got a funny type.
20:56:59 <Axman6> does it? what's the type?
20:57:46 <bos> Axman6: concat :: Stream [a] -> [a]
20:57:58 <mtnviewmark> bos - here is the current profile: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13385#a13385
20:58:06 <bos> Axman6: what i think i need is more like [Stream a] -> Stream a
20:58:14 <mtnviewmark> I don't understand why all the time is in a dinky little function used to read 4 bytes
20:58:20 <Axman6> bos: hmm yeah both are useful though
20:58:24 <mtnviewmark> called relatively infrequently
20:58:36 <bos> i LOVE talking about behaviour by describing a type. haskell still knocks me flat on my back with joy.
20:58:38 <mtnviewmark> that function is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13363#a13363
20:59:11 <Axman6> bos: yeah, i love how we can give types for many things, and clearly see what they do. it's awesome :D
20:59:44 <bos> mtnviewmark: do you have a repo and a test case?
20:59:52 <mtnviewmark> oh yes
20:59:54 <mtnviewmark> and charts
21:00:17 <mtnviewmark> I guess what bites me is this:  Productivity  57.2% of total user, 55.6% of total elapsed
21:00:20 <mtnviewmark> seems really low
21:00:38 <Axman6> yeah :\
21:00:48 <bos> mtnviewmark: yeah, i don't see where all the time is going
21:01:12 <mtnviewmark> I suppose now that my memory profile now only grows to only 100k over the run means I shouldn't worry about that
21:02:19 <mtnviewmark> I can now process 100k XML records (each about 6k) without going into swap
21:02:33 <Axman6> hoorah!
21:02:50 <lispy|web> yay!
21:03:15 <mtnviewmark> BUT - my IntMap -- part of a stats collection, is clearly in need of something -- grows steadly throughout the run
21:03:36 <mtnviewmark> even though it only has 22 elements
21:03:40 <bos> mtnviewmark: where's the IntMap?
21:03:47 <lispy|web> mtnviewmark: isn't that a classic problem with lazily adding values to the map?
21:03:49 <bos> mtnviewmark: values in a Map are not strict
21:03:58 <mtnviewmark> they are stat counters --- counting the number of times a particular length list is seen
21:04:02 <bos> so you're probably accumulating a huge fuck-off thunk.
21:04:10 <bos> in each leaf of the tree.
21:04:21 <mtnviewmark> all of +1s ????   oy vey
21:04:58 * hackagebot upload: UMM 0.1.3 - A small command-line accounting tool: hledger + bugs - features? maybe... (UweHollerbach)
21:05:08 <bos> mtnviewmark: yeah.
21:05:38 <mtnviewmark> perhaps instead of insertWith (+)   I should be using   insertWith (\a b -> a `seq` b `seq` a + b)
21:05:49 <mtnviewmark> but that seems icky....
21:06:09 <Saizan> no that won't do anything
21:06:15 <Saizan> (+) is already strict
21:06:16 <bos> mtnviewmark: that wouldn't even help
21:06:30 <mtnviewmark> see my understanding is ick
21:06:30 <bos> mtnviewmark: use Data.Map instead, and insertWith'
21:07:13 <mtnviewmark> okay - but help me understand -- how would I rewrite this
21:07:28 <mtnviewmark> M.insertWith (+) (length ats) 1  hist
21:07:43 <mtnviewmark> `hist` seq M.insertWith (+) (length ats) 1  hist
21:08:02 <mtnviewmark> or can this not work without lib support because it needs to focre beyond the first constructor for a map?
21:08:36 <Saizan> ?type M.insertWith
21:08:37 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
21:09:02 <Saizan> mtnviewmark: you'd have to rewrite it in terms of lookup and insert
21:09:12 <bos> mtnviewmark: you'd have to pull the value out of the map, `seq` it, then insert the new value
21:09:21 <bos> mtnviewmark: but Data.Map.insertWith' does that for you
21:09:30 <Saizan> seq the new value, actually
21:09:34 <bos> Data.IntMap is just missing that API entry point, which is a shame.
21:09:40 <bos> Saizan: right.
21:10:06 <mtnviewmark> ah, the pulling and seq'ing the value has the effect of forcing the lazy tree update?
21:10:19 <bos> The spine of the tree is actually strict anyway.
21:10:28 <bos> It's the values at the leaves that aren't.
21:10:56 <mtnviewmark> but wouldn't the application of (+) force the value there?
21:11:05 <Saizan> you could also be accumulating a thunk made of insertions into the map, but that's less common
21:11:25 <bos> mtnviewmark: nothing observes the application of +, so there is nothing to force it.
21:11:46 <mtnviewmark> not the next application of (+)?
21:12:02 <Saizan> nothing observes the next application so .. etc..
21:12:05 <bos> No, the next application of + isn't an observer.
21:12:50 <mtnviewmark> ah - (dim light turning on) --- so when we say (+) is strict, we mean that IF someone demands the result of an application of (+), THEN (+) is going to force it's arguments
21:13:02 <Saizan> exactly
21:13:08 <mtnviewmark> BUT, simply applying (+) does nothing -- just THUNKS (which is something, I suppose!)
21:13:23 <bos> right!
21:14:27 <jargonjustin> I've read a couple of times that (>>=) is more powerful than fmap and (<*>) because it can work with intermediate results. Can anyone explain why?
21:14:30 <mtnviewmark> okay- given that, while it would be easier, and no issue to switch to Data.map -- I'm going to try to write my own strict version for IntMap....
21:14:36 <mtnviewmark> hang on.... :-)
21:15:00 <Saizan> jargonjustin: e.g. suppose you want to write an if .. then .. else .. for monads
21:15:25 <Axman6> mtnviewmark: copy and paste the implementation of IntMap, and just change the constructors on IntMap
21:15:47 <Saizan> jargonjustin: without >>= you can't avoid the side-effects of both the then and else branch
21:15:58 <mtnviewmark> well I could but a) I don't think the the constructors are exported and b) I wouldn't be learning anything!
21:16:18 <Saizan> jargonjustin: because you can't decide which action to execute next by looking at the result of the condition
21:16:47 <jargonjustin> Within the function being lifted you mean? Because it's a "pure
21:16:47 <jargonjustin> "
21:16:50 <jargonjustin> computation?
21:17:19 <dons> bos: concat is hard. there's lots of experiments at writing it here:  http://code.haskell.org/~dons/code/stream-fusion/Data/Stream.hs
21:17:23 <Saizan> jargonjustin: ifM :: Monad m => m Bool -> m a -> m a -> m a
21:17:47 <Saizan> jargonjustin: ifM mb mt mf = do b <- mb; if b then mt else mf
21:17:58 <dons> and more comments in http://code.haskell.org/~dons/code/stream-fusion/Data/List/Stream.hs
21:18:12 <jargonjustin> Saizan: that makes a lot of sense, thanks!
21:18:40 <Saizan> jargonjustin: with <*> the best you can do is liftM3 (\b t f -> if b then t else f) mb mt mf, but then you're going to include both mt and mf side-effects
21:18:43 <Saizan> jargonjustin: np :)
21:21:04 <PizzaMan420> how do I compile code?
21:21:35 <Apocalisp> PizzaMan420: GHC
21:21:40 <holmak_> for a single file, "ghc Main.hs"
21:21:46 <PizzaMan420> thanks
21:21:49 <kmc> ghc --make -o foo foo.hs
21:21:56 <PizzaMan420> what if Main.hs imports a bunch of other fikes
21:21:59 <kmc> PizzaMan420, ghc --make will chase dependencies for you.  it is your friend
21:22:01 <holmak> kmc's anser
21:22:04 <holmak> *answer
21:22:05 <PizzaMan420> thanks
21:22:09 <bos> dons: yeah, i saw that code.
21:22:24 <kmc> PizzaMan420, throw in a "-O2" if you need speed
21:22:28 <bos> dons: it's not at all obvious to me how to do an efficient concat in the fusion system
21:22:35 * Axman6 always throws in -O2
21:22:40 <kmc> -O9999
21:23:01 <shachaf> -Ofixsucc
21:23:57 <bos> dons: but it took me by surprise at first that the time complexity was slightly worse than quadratic
21:24:01 <Gracenotes> anything over -0999999 runs through your program with every possible input, running your program even before you start GHC
21:24:10 <dons> hmm
21:24:12 <kmc> supercompilation :)
21:24:50 <mtnviewmark> insertWith' f k v m = let v' = maybe v (f v) $ M.lookup k m in seq v' (M.insert k v' m)
21:24:52 <pikhq> It then replaces your program with the fastest program that can create the possible output.
21:24:54 <dons> dcoutts_ has been thinking about this more recently. worth talking to him about it.
21:24:58 <mtnviewmark> that didn't work... :-P
21:25:11 <Veinor> f $ g x = (f . g) x, correct?
21:25:28 <Axman6> yes
21:25:38 <bos> dons: it's hard to have profound thoughts about the problem with tired hacker daddy mind :-)
21:25:43 <mtnviewmark> not to mention f . g $ x
21:25:48 <Veinor> that too.
21:25:57 <Nafai> dons: I'm finally almost done reading RWH again.  It's got me excited about Haskell programming again!
21:26:08 <Axman6> :)
21:26:09 <Nafai> dons: too bad I can't get a Haskell job now that I'm unemployed :)
21:26:10 <PizzaMan420> is there any way to make it include all files needed to run on a system w/o ghc installed?
21:26:44 <PizzaMan420> ...I get an dll error on my other laptop
21:27:04 <Gracenotes> pikhq: oh, no, it just runs everything for compilation
21:27:20 <mtnviewmark> d'oh - tell me 'bout tired hacker daddy brain: I forgot to call it!
21:27:20 <bos> mtnviewmark: if you want to build an IntMap-alike of your own, do it using a 2,3-finger tree for the lulz.
21:27:36 <Gracenotes> pikhq: chances are, some of the effects for one of the inputs will match the effects of every possible input
21:27:48 <Gracenotes> there's no guarantee of accurate transformation
21:27:53 <bos> mtnviewmark: call what?
21:28:01 <bos> mtnviewmark: your alternate function?
21:28:10 <dmwit> PizzaMan420: I guess you'll need at least libgmp; other than that I thought static linking was the default.
21:28:17 <mtnviewmark> actually, I'm just going to use Data.Map here -- the thing will never have more than 22 entries, so the benefit of Data.IntMap is low.... I'm just trying to see if I understand
21:28:20 <bos> dons: have you played with the new inliner in HEAD?
21:28:23 <mtnviewmark> yes, call my alternate function!
21:28:26 <bos> dons: it's AMAZING the difference it makes.
21:28:38 <mtnviewmark> woot!  worked!
21:28:39 <PizzaMan420> ya, I think its cause of gtk missing files
21:28:46 <dons> i've heard rl saying good things.
21:28:49 <bos> mtnviewmark: yay!
21:28:53 <copumpkin> mmm, I love allcaps AMAZINGs in relation to GHC
21:28:57 <bos> dons: speeds up untouched code by 30x in many cases.
21:29:05 <copumpkin> :O
21:29:08 <dons> wow.
21:29:18 <dmwit> that IS amazing
21:29:24 <bos> yeah, it's the difference between Data.Text being embarrassing and amazing.
21:29:36 <bos> it makes a big difference to bytestring in places, too.
21:29:38 <dons> when the inliner goes bad, everything goes bad. so it is good that it is less likely to now
21:29:43 <mtnviewmark> except for some BIZARRO spikes in my -hd graph, the heap stays under 20k (!) while processing 100k XML records
21:29:53 <dons> yeah, i can imagine it helps Data.Binary too. i should check that.
21:29:53 <bos> there are of course tradeoffs. some straightline code is 2x slower now.
21:30:01 <dons> binary has very specific inlining requirements
21:30:03 <copumpkin> onoes
21:30:37 <bos> so my zippy string search code takes 20µs to run instead of 10µs. but bytestring is still 5000 times slower :-)
21:30:54 <Axman6> bos: any chance of an awesome blogpost about the new inliner?
21:31:05 <bos> Axman6: rl has been writing a bit about it.
21:31:10 <lispy|web> Nafai: http://jobsearch.naukri.com/job-listings-Senior-Engineer-Automotive-Embedded-Eaton-Technologies-Pvt-Ltd-Pune-3-to-7-years-151109000171-
21:31:13 <bos> Axman6: see his NoSlow article.
21:31:16 <dons> eaton hiring.
21:31:39 <copumpkin> eaton?
21:31:45 <dons> prob. get to use the Atom dsl in practice too.
21:31:47 <lispy|web> copumpkin: the link I just pasted
21:31:57 <copumpkin> oh I see
21:31:57 <dons> automotive control systems. haskell + sat solvers.
21:32:24 <medfly> lol, this company just posts a job ad and this channel jumps on it?
21:32:29 <dons> the hyrdaulics in baltimore garbage trucks, powered by haskell, iirc.
21:32:31 <mtnviewmark> that's quite the requirements list: 16bit microcontrollers up through Haskell
21:32:43 <dons> medfly: did you have a haskell question?
21:32:46 <copumpkin> ooh, baltimore!
21:32:47 <copumpkin> I was just there
21:32:49 <lispy|web> medfly: well, I saw it on haskell-cafe to be fair
21:32:50 <bos> text = 10.97824 us, bytestring = 67.58646 ms, list = 104.8172 us
21:32:54 <dons> hehe
21:33:02 <dons> better algorithm... ?
21:33:05 <medfly> are you complaining I'm being off-topic :(
21:33:40 <bos> dons: yeah, better algo.
21:34:07 <bos> i see that chicken scheme picked up my text search code.
21:34:28 <bos> which of course i borrowed from a cast of all-stars.
21:34:30 <dons> oh, that's interesting.
21:34:44 <dons> there are schemers watching us?
21:34:59 <mtnviewmark> okay - spikes vary from run to run, so I'm going to assume they're just sampling skew ---
21:35:21 <junmin> @src $
21:35:21 <bos> mtnviewmark: making progress?
21:35:22 <lambdabot> f $ x = f x
21:35:28 <bos> dons: i guess so.
21:35:36 <junmin> @src .
21:35:37 <lambdabot> (f . g) x = f (g x)
21:35:52 <bos> dons: they're also polite enough to credit the code they borrow.
21:36:09 <lispy|web> I never thought of ($) as being a unary version of (.) before
21:36:12 <bos> one of the other things i love about haskell is references to literature in the haddocks.
21:36:13 <dons> as part of a push to get a unicode string type?
21:36:24 <bos> dons: they're doing it for bytestrings, so far.
21:36:43 <dons> cool
21:36:45 * bos abandons fusion-based concat for now. time to write a brute force version.
21:36:51 <mtnviewmark> well, the heap profiles don't show the dreaded triangle of doom anymore (the one that grows to the right until the cliff at the end
21:37:04 <mtnviewmark> but Productivity  58.1% of total user, 56.1% of total elapsed
21:37:04 * dons doesn't recall the [a] fused concat being a problem.
21:37:10 <mtnviewmark> still seems low -
21:37:20 <dons> a lot of GC eh?
21:37:24 <mtnviewmark> and the speed is still not as good as the Python version
21:37:29 <dons> ok. that's a bug then.
21:37:31 <shachaf> @ty (.)
21:37:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:37:33 <mtnviewmark> (them's fightin' words, I bet!)
21:37:36 <shachaf> Cale...?
21:37:42 <dons> anytime haskell's not at least destroying python, you've got a bug.
21:37:45 <shachaf> I didn't know someone changed that.
21:37:52 <dons> mtnviewmark: assuming you're using ghc -O2 right? not hugs? ghci?
21:37:54 <shachaf> Caleskell++
21:38:06 <Saizan> mtnviewmark: do you just insert in this map without observing it until the end?
21:38:16 <mtnviewmark> yes, GHC -via-C and -O2
21:38:21 <lispy|web> :t (Prelude..)
21:38:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:38:24 <dons> then yep, a bug.
21:38:29 <dons> performance bug, that is.
21:38:34 <dons> keep looking.
21:38:36 <mtnviewmark> Saizan - we got that one licked, it isn't building up any thunks now .....
21:38:37 <shachaf> > succ . [1,2,3]
21:38:39 <lambdabot>   [2,3,4]
21:38:42 <mtnviewmark> the heap profile is nice an flat
21:38:50 <mtnviewmark> over the run of 100k records
21:38:55 <dons> increase the default GC area?
21:39:10 <dons> -A200M or -H200M? does that decrease the GC pressure?
21:39:17 <dons> (or whatever M makes sense)
21:39:21 <Saizan> well, you might be inserting the elements strictly, but not doing the insert itself strictly
21:39:27 <mtnviewmark> this code is parsing moderate XML docs (~6k)
21:39:40 <bos> dons: the Text concat was defined as --- unstream (S.concat (L.map stream ts))
21:39:40 <dons> oh, custom xml lib, or one of the xml packages?
21:39:57 <mtnviewmark> converting that tree into yet a different tree data structure , then accumulating statistics about that data
21:40:02 <bos> dons: and S.concat was --- L.foldr append empty
21:40:23 <bos> dons: so every time a new Char was needed, we had to loop through all the streams of all the little teeny weeny Texts
21:40:27 <muri_one> does hugs use as much memory and cpu as ghci does in its interpreted mode?
21:40:30 <dons> mmm
21:40:41 <dons> muri_one: a little, not much more.
21:40:42 <bos> dons: leading to behaviour that i was unthrilled by.
21:41:00 <dons> muri_one: ghci has the advantage of compiled libs, and a better runtime.
21:41:08 <dons> bos: quite so.
21:41:11 <lispy|web> and being ghc
21:41:15 <mtnviewmark> should I see cost centers from the system libs I linked against (like hexpat) ??
21:41:22 <mtnviewmark> I do have profiled versions of 'em
21:41:27 <bos> mtnviewmark: no.
21:41:35 <bos> mtnviewmark: not unless you compiled them with -auto-all
21:41:51 <bos> mtnviewmark: otherwise all the costs will be accounted for at their caller.
21:41:57 <mtnviewmark> okay - so I get why 84% of the memory allocs are in my parseXML function -- they are all in hexpat....
21:42:01 <bos> yeah.
21:42:30 <mtnviewmark> BUT 72% of the time in my goofy parse 4 bytes from a handle as a network order Int is stumping me
21:42:41 <mtnviewmark> it does use Data.Binary -- but still
21:43:09 <mtnviewmark> side q: is this line at the top of a profile report always wrong:    total time  =        0.36 secs   (18 ticks @ 20 ms)
21:43:20 <mtnviewmark> it ran for 4 seconds, not 0.36....
21:43:39 <dons> mtnviewmark: oh, you can optimize that by hand, i think. its certainly possible to misuse Data.Binary in situations like that (e.g. redundant copying on every package, ...)
21:43:59 <mtnviewmark> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13363#a13363
21:44:10 <mtnviewmark> it's just hGetInt32 in this code
21:44:19 <mtnviewmark> actually the time is attributed to hDecode
21:44:31 <mtnviewmark> but hGetInt32 is the only caller
21:44:45 <mtnviewmark> oh - sorry, I'm using Serialize, not Binary
21:45:26 <mtnviewmark> replacing with a hand built one....
21:54:59 <mtnviewmark> ouch - my handcoded version is .... worse!
21:55:00 <mtnviewmark> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13363#a13388
21:55:12 <mtnviewmark> hGetInt32 --- what could possibly be simpler?
21:55:33 <mtnviewmark> B is Data.ByteString btw
21:56:34 <Saizan> try putting cost centers inside it?
21:57:19 <mtnviewmark> but - here's the deal - in a 10k record run, this gets called 10k times --- and I parse 10k XML documents ----
21:57:36 <mtnviewmark> this gets pegged as 83% of the execution!
21:57:53 <mtnviewmark> seems insane that this little guy would outstrip the XML parsing!
21:58:19 <dons> trying ensuring it gets fully inlined
21:58:22 <dons> {-# INLINE foo #-}
21:59:21 <mtnviewmark> no difference
21:59:50 <bos> mtnviewmark: i just found a happy use for foldM
22:00:20 * mtnviewmark though his was happy .... just needed foldM'....
22:00:59 <bos> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13389#a13389
22:02:06 <copumpkin> nice
22:02:33 <mtnviewmark> bos - text uses UTF16 internally?
22:02:47 <bos> mtnviewmark: yep
22:03:01 <bos> mtnviewmark: but this is hidden by the API
22:03:27 <m3ga> bos: why utf16?
22:03:29 <lispy|web> bos: wouldn't UTF32 be easier for you as a library author?
22:03:39 <bos> UTF32 is easier, but more space expensive.
22:03:48 <lispy|web> Not in asia :)
22:03:50 <m3ga> so why not utf8?
22:03:57 <mtnviewmark> when doing web processing, even when working with asian languages, UTF8 is usually more space efficient
22:04:03 <mtnviewmark> generally, the markup dominates
22:04:13 <bos> UTF16 is a good compromise.
22:04:15 <copumpkin> lispy|web: most things fit in utf16, even in asia
22:04:15 <Draconx> lispy|web, most CJK characters are in the BMP, so yes, even in asia.
22:04:25 <mtnviewmark> well - it depends on your processing domain
22:04:40 <copumpkin> well unless you're dealing with obscure CJK characters in historical texts
22:04:40 <mtnviewmark> for the web, UTF8 is almost always the best choice, for all languages
22:04:45 <Draconx> note that UTF-16 is, at worst, just as bad as UTF-32.
22:04:48 <Draconx> (for space)
22:04:58 <copumpkin> he was talking about complexity though
22:05:17 <copumpkin> using 3 bytes per character might be a decent compromise :P
22:05:30 <copumpkin> since all of unicode's codepoints fit in just under 21 bits
22:05:43 <copumpkin> but might make arithmetic painful with all those threes
22:05:49 <bos> I'm happy with the code that's there now.
22:06:02 <Draconx> copumpkin, not to mention alignment problems.
22:06:06 <copumpkin> yeah :)
22:06:15 <bos> It's quite clean and elegant, and the UTF-16 knowledge is mostly hidden even from the internals.
22:06:23 * stoop always confuses bos with bcos
22:06:24 <copumpkin> cool
22:06:33 <mtnviewmark> so - am I commiting a sin by reading from a handle in a strict ByteString, then reading from the same handle into a Lazy ByteString --- back and forth?
22:06:43 <stoop> Every time I see you in here, I write out "bos from #OSdev?" only to erase the line.
22:07:01 <Axman6> mtnviewmark: i'm sure there must be a way to convert from one to the other
22:07:04 <lispy|web> stoop: yet, you might find that bos here knows a bit about osdev
22:07:08 <mtnviewmark> hGetInt32 h "length" >>= L.hGet h
22:07:20 <mtnviewmark> so that's my code in my "packet reading loop"
22:07:27 <bos> mtnviewmark: that is untroublesome.
22:07:35 <mtnviewmark> and ALL the time gets accredited to hGetInt32
22:07:45 <mtnviewmark> that reads just those four bytes ---
22:08:01 <mtnviewmark> where as the L.hGet reads ~6k per shot and then XML parses it
22:08:28 <Axman6> mtnviewmark: not sure if it might be useful to you or not, but have you seen dons' Data.Binary package?
22:08:33 <Axman6> @hackage binary
22:08:33 <lambdabot> http://hackage.haskell.org/package/binary
22:08:58 <mtnviewmark> yes, indeed
22:09:12 <mtnviewmark> but error handling drove me to cereal
22:09:15 <mtnviewmark> @hackage cereal
22:09:16 <lambdabot> http://hackage.haskell.org/package/cereal
22:09:24 <ivanm> Axman6: well, it isn't _just_ dons' IIRC
22:09:36 <lispy|web> ?hackage breakfast_of_champions
22:09:38 <lambdabot> http://hackage.haskell.org/package/breakfast_of_champions
22:09:41 <Axman6> well, he started it i though
22:09:45 <ivanm> Axman6: in fact, it started off as being just kolmodin's!
22:09:47 <ivanm> so there!
22:09:50 <ivanm> http://hackage.haskell.org/package/binary-0.2
22:10:00 <Axman6> :o didn't know that
22:10:10 <Axman6> it was on dons' site, i assumed it was his
22:10:19 <ivanm> lispy|web: weet-bix?
22:10:20 <osaunders> What's the difference between /usr/includes and /usr/lib?
22:10:28 <ivanm> Axman6: you know what they say about when you assume...
22:10:30 <ivanm> ;-)
22:10:33 <Axman6> osaunders: includes has the header files
22:10:33 <osaunders> I mean, what is it "supposed" to be?
22:10:47 <Axman6> lib has the library binatries
22:10:48 <Axman6> -t
22:11:00 <osaunders> *include, sorry.
22:11:15 <lispy|web> .h vs. .so and .a
22:11:18 <osaunders> Axman6: So you'd never use include for anything not C
22:11:35 <osaunders> I mean would use use lib for .hs?
22:11:36 <Axman6> i guess
22:11:40 <Axman6> no
22:11:45 <lispy|web> osaunders: well....languages besides C can consume C headers and C Libs...Haskell is an example
22:11:54 <Axman6> haskell uses libraries just like anything else (sort of)
22:12:04 <osaunders> lispy|web: OK, sure.
22:12:30 <osaunders> Axman6: but?
22:12:30 <ivanm> haskell stuff gets installed to /usr/lib
22:12:42 * bos declares undying fealty to quickcheck. AGAIN.
22:12:44 <ivanm> the actual .so files, that is
22:12:51 <ivanm> bos: what has it found?
22:13:13 <ivanm> bos: for me, it found heaps of bugs, but most of them were bloody stupid things that probably wouldn't occur in the real world :@
22:13:17 <bos> ivanm: oh, i refactored some code, and it is helping me to fix the refactoring to actually be, you know, correct.
22:13:27 <ivanm> (and resulted in me constraining how the arbitrary values were generated)
22:13:29 * copumpkin is bloody stupid and has occurred in the real world
22:13:39 <Axman6> fark! god damn windows!
22:13:40 <ivanm> bos: you actually _want_ correctness? crazy!
22:13:46 <ivanm> copumpkin: true...
22:13:53 <Axman6> ivanm: quickcheck doesn't give you correctness
22:13:58 <Axman6> just assurance
22:14:00 <ivanm> copumpkin: but I thought graphviz didn't have enough awesome for you?
22:14:09 <ivanm> Axman6: bos said he wanted it to be correct
22:14:10 <copumpkin> ivanm: that's cause I'm bloody stupid
22:14:12 <osaunders> I really hate how files are organized on POSIX systems.
22:14:15 <ivanm> copumpkin: heh
22:14:20 <ivanm> osaunders: why?
22:14:31 <ivanm> tbh, I barely even notice how most of them are located
22:14:39 <Nafai> bos: You know, I've never got the hang of TDD, but after reading the testing chapter of RWH recently, I think QuickCheck would change my mind (after I use it with some code) about testing
22:14:44 <Axman6> god damn it, what do you do with windows when the task bar has frozen?
22:14:48 <ivanm> though maybe /usr/share/doc should be top level; it would save me a lot of typing ;-)
22:14:55 <osaunders> ivanm: Because it's not a good fit for what you want to use it for.
22:14:56 <Axman6> i can't even open the ctrl-alt-delete window
22:15:00 <ivanm> Axman6: heh
22:15:12 <ivanm> Axman6: can you win-r to get the run prompt?
22:15:33 <ivanm> osaunders: how do _you_ know it isn't a good fit for what _I_ want to use it for?
22:15:53 <Asztal> ctrl-shift-esc?
22:15:55 <Axman6> hit ctrl-alt-delete a lot apparently
22:16:02 <mtnviewmark> Install linux on it?
22:16:27 <osaunders> ivanm: Because it's not logical.
22:16:50 <ivanm> so?
22:16:58 <ivanm> (assuming you're correct about it not being logical)
22:17:02 <ivanm> people aren't logical...
22:17:03 <Axman6> mtnviewmark: i'd honestly prefer to use windows over linux
22:17:12 <copumpkin> Axman6: ugh
22:17:12 <osaunders> Whatever. I hate it.
22:17:23 <ivanm> osaunders: then don't use it *shrug*
22:17:30 <ivanm> and thus stop bitching about it! ;-)
22:17:36 <osaunders> I can't not use it.
22:17:40 <Axman6> having spent the last 10+ years using linux, i've grown sick of how pathetic it is, and how it never seems to improve
22:17:47 <copumpkin> Axman6: in linux, even if the GUI freezes there's always a way out
22:18:06 <copumpkin> unlike your windows situation :P
22:18:14 <Axman6> copumpkin: i got out of it fine :)
22:18:33 <nolrai_FG> any idea what a let-no-excape is?
22:18:40 <Axman6> and the reason there's always a way out in linux is because linux keeps failing, and will always need a way out
22:18:53 <Nafai> I've filled up my Windows quota for a while.  Spent 5-6 hours over the holidays updating, cleaning up, defragging, etc my Dad's XP system
22:19:26 * mtnviewmark apologizes for his snarky comment... after all.... even he doesn't use Linux most of the time..... and he didn't want to start an OS war....  :-O
22:19:28 <Axman6> and at least windows is consistent
22:19:37 <Axman6> mostly
22:19:46 <Axman6> at least compared to the linux world
22:19:59 <Nafai> Sure, I should stop denigrating Windows.  I just choose not to use it. :)
22:20:11 <ivanm> Axman6: yes, but most people prefer the inconsistency arising from having a choice...
22:20:13 <holmak> I like Ubuntu, for the six month releases. They alwasy seem to improve.
22:20:14 <kstarr> no, thats the one i wanted you to see http://greener-better.com/
22:20:21 <Axman6> Nafai: oh me too, i'm just stuck with it at the moment :)
22:20:28 <ivanm> releases? bah! who needs releases!
22:20:31 <kmc> knowing things about windows is a liability
22:20:36 <kmc> people will ask you to fix their computer
22:20:36 <mtnviewmark> is the absolute heap size scale in -hd output to be believed?    if so - wow, nice and small!
22:20:45 <Nafai> kmc: well, I don't know enough to help them over the phone anymore :)
22:22:44 <ivanm> kmc: I get that as soon as someone founds out I studied IT...
22:23:16 <ivanm> after all, I've studied how to program... of _course_ I know why windows isn't working!
22:25:06 <medfly> http://xkcd.com/664/
22:25:24 <ivanm> heh
22:25:39 <ivanm> I don't know about a thesis or two though
22:25:53 <dibblego> what's a good example use for traverse?
22:26:16 <medfly> tetris
22:26:32 <dibblego> @type Data.Traversable.traverse
22:26:34 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:26:46 <medfly> oh, wrong one
22:26:46 <Axman6> >_<
22:26:51 <medfly> I read that as transpose
22:28:25 * medfly makes a lot of embarrassing mistakes lately
22:28:55 <mtnviewmark> okay - after hand inserting SCCs I think I get what is going on
22:29:56 <mtnviewmark> when one reads from a handle into a Lazy ByteStream ---- that's all just hanging out.... when you next read from that handle, into a non-lazy ByteStream, all that work must end up attributed to the non-lazy hGet call
22:30:35 <bos> okay, concat on Data.Text has gone from completely insane to slightly slower than bytestring
22:30:46 <kmc> that xkcd is pretty crap
22:31:09 <medfly> it's not funny, just true
22:31:22 <tensorpudding> xkcd has gotten kinda crappy
22:31:54 <kmc> that strip is true for some cases, and in other cases it'd be the exact opposite
22:32:04 <medfly> that's also true
22:32:26 <kmc> it's just another "the real world is full of stupid people who suck, am i rite"
22:32:28 <ivanm> bos: what do you use under-the-hood for text? bytestring or a custom type?
22:32:30 <mtnviewmark> bos - does that make any sense - or am I far off base?
22:32:40 <bos> ivanm: super custom type
22:32:48 <bos> mtnviewmark: sounds reasonable, i think.
22:32:49 <ivanm> oh, a _super_ custom type
22:32:52 <ivanm> my apologies
22:32:52 <ivanm> ;-)
22:33:07 <bos> ivanm: yeah.
22:33:08 <tensorpudding> academics don't know anything practical amirite?
22:34:02 <kmc> "this will be a footnote in the paper the important guy gets to write" vs. "we will use this to start making money right away, here is your bonus"
22:35:26 <Axman6> bos: is it a bad thing that you've got two things imported qualified as S in http://hackage.haskell.org/packages/archive/text/0.5/doc/html/src/Data-Text.html?
22:35:44 <bos> Axman6: no
22:36:03 <ivanm> Axman6: as long as none of the names clash
22:36:11 <Axman6> i would have thought that wouldn't work. but i guess if there's no clashes, it'd be fine
22:36:15 <Axman6> how... confusing :\
22:36:20 <ivanm> Axman6: I've seen people use it to import BS and BS.Char8 for example
22:36:35 <ivanm> so they can just use B. to refer to all bytestring funcs
22:37:23 <bos> mtnviewmark: the profiling tools are pretty nice, but the funnies that the language throws at you can make it tricky to use profiling effectively.
22:37:33 <bos> mtnviewmark: all of which i'm sure you now know quite well :-)
22:39:20 <Saizan> mtnviewmark: s/ByteStream/ByteString/g
22:39:57 <mtnviewmark> er, yes, my fingers have a mind all their own
22:45:51 <rasfar> i need a profiling version of haskell-src-exts, instead of the default library currently installed.
22:45:59 <rasfar> Is cabal install --reinstall -p haskell-src-exts going to work?  Is it safe or will I mess things up?
22:46:21 <mtnviewmark> I just went through this last night
22:46:41 <rasfar> Was it a good experience for you mtnviewmark?
22:46:58 <mtnviewmark> well, aside from having to chase down the recursive things by hand
22:47:09 <mtnviewmark> and having some libs in --user and some in --global
22:47:28 <mtnviewmark> and making sure my .cabal/config pointed --global stuff in a sane place (on a Mac)
22:47:29 <mtnviewmark> sure
22:47:48 <mtnviewmark> cabal install --reinstall --global --root-cmd=sudo
22:47:48 <rasfar> Ah! I was going to ask about that but thought I'd find out if it happened.  As for the latter, eesh....  Okay, here goes!
22:47:54 <mtnviewmark> worked fine for the --global stuff
22:47:57 <mtnviewmark> and nothing broke
22:48:42 <mtnviewmark> I added library-profiling: True to .cabal/config (as per bos) so that I didn't need -p
22:49:05 <mtnviewmark> and I moved my --global prefix in there as well
22:49:22 <mtnviewmark> (so that stuff I upgraded wouldn't clobber stuff installed by Haskell platform)
22:49:23 <rasfar> That seems reasonable; I'll do that as soon as my build is complete.
22:50:12 <nolrai_FG> What is the "let no escape" optimization?! stupid lack of good documetaion on ghc internals. stupid me for doing something that needs to know this.
22:52:07 <Axman6> nolrai_FG: what are you doing anyway? you've been asling strange questions all day
22:54:17 <nolrai_FG> Right now writing a parser for ghc's stg code.  The idea is to eventraly sortof maybe write a compiler from that to java. I'll be duplicating lots of other smarter peoples work.
22:54:24 <osaunders> Is there a nicer way to write this: borderXEdge width = '+':(take (width - 2) (cycle "-")) ++ "+"
22:54:38 <mtnviewmark> cabal question: when I build my package, a lib plus two executables, is it normal that the lib files get built three times - once for the lib, and once again for each executable?  Why doesn't it just link against the one it just built?
22:54:58 <rasfar> I had to reinstall cpphs for the very last (24th) source file of haskell-src-exts.  now surely i don't have to --reinstall the src-exts lib again do I?  what's the proper thing to do now that I've satisfied the cpphs dep, so continue the installation of the src-exts?
22:55:03 <nolrai_FG> Fortunatly for me I dont really have to get a wroking product...
22:55:09 <rasfar> (and thanks very much for the advice btw)
22:55:34 <rasfar> s/ so / to /
22:56:03 <rasfar> s/, so/, to/ even better
22:56:12 <Axman6> osaunders: take n (cycle "x") = replicate n 'x'
22:56:48 <osaunders> Axman6: Thanks
22:58:04 <mtnviewmark> fie - haskell still 20% slower than python in my XML parsing tests
22:58:13 <rasfar> mtnviewmark: recall you asking that earlier (cabal question), and curious myself what the answer could be.
22:58:19 <c_wraith> mtnviewmark:  that is normal.   The next major version of cabal will fix that by allowing you to declare that an executable in the project depends on a library exported by that project
22:58:25 <mtnviewmark> yes - got no answer before
22:58:38 <Axman6> mtnviewmark: yeah, but haskell users still 20% faster at realising that XLM is stupid :P
22:58:57 <nolrai_FG> Axman6: Whats wrong with XML?
22:59:00 <c_wraith> And the answer is:  It currently recompiles everything on each part because you're allowed to set different compile options for each, and it doesn't check to see if you didn't.
22:59:12 * mtnviewmark is not going to take the bait
22:59:16 * nolrai_FG knows nothing about xml
22:59:16 <Axman6> nolrai_FG: what isn't? there's so much overhead
22:59:29 <mtnviewmark> c_wraith - thanks
22:59:40 <malcolmw> mtnviewmark: using which Haskell XML library?
22:59:44 <JohnnyL> JSON is the way to go.
22:59:49 <mtnviewmark> hexpat
22:59:54 <dmwit> lisp
23:00:05 <bos> mtnviewmark: what are you using in python?
23:00:19 <nolrai_FG> dmwit: as a replacement for xml?
23:00:23 <JohnnyL> :p
23:00:29 <dmwit> nolrai_FG: yeah =)
23:00:37 <dmwit> Just the syntax, mind you.
23:00:40 <nolrai_FG> uhh...
23:00:42 <mtnviewmark> cllsd -- which I think is an expat -> LLSD coded in C
23:00:46 <mtnviewmark> (if I recall)
23:00:47 <bos> malcolmw: think you'll ever have time to write a manual for haxml?
23:01:03 <bos> malcolmw: the documentation is too fearsome for me to consider ever using it :-(
23:01:06 <rasfar> ah well, here goes the second round of --reinstall.  if i had more time to read documentation (or follow this channel) i'd know better no doubt.
23:01:07 <malcolmw> mtnviewmark: you might find that other libraries perform better, especially on large data
23:01:33 <mtnviewmark> the data is small: 10k documents, each ~6k
23:01:41 <bos> mtnviewmark: cllsd is a python writer, not a reader.
23:01:49 <ddarius> bos: Ignore the documentation and just start using it.
23:01:50 <malcolmw> bos: it's one of those things - if you haven't written a manual for it after 10 years, can you even remember what it does?
23:02:00 <bos> malcolmw: :-)
23:02:20 <bos> ddarius: that requires an ariadne's thread of "where do I get started"
23:02:50 <malcolmw> bos so what do you want to do with it, and I'll see if I can find a simple recipe to cut-n-paste
23:03:02 <mtnviewmark> ah - elementTree then
23:03:19 <nolrai_FG> dmwit: hmm that wouldn't be that bad acualy.
23:03:28 <rasfar> ...and for some reason cabal of its own accord is rebuilding the whole shebang yet a third time, back-to-back!
23:03:49 <ddarius> bos: Isn't there a paper on HaXml?
23:04:04 <bos> ddarius: yeah, i think so
23:04:27 <rasfar> (oh, these are the _p.o versions now)
23:05:37 <nolrai_FG> Well If I dont understand something it must not be important! Right!? ;)
23:05:43 <ddarius> bos: I don't recall having much trouble with it and the end result is XPath-ish.
23:05:49 <rasfar> * .p_o versions
23:06:06 <mtnviewmark> bos, or rather, the python is using cElementTree --
23:06:46 <mtnviewmark> when I compare Haskell to Python for reading the binary encoding --- Haskel is 8x the speed!
23:06:56 <mtnviewmark> when reading the XML encoidng, Haskell loses
23:07:13 <nolrai_FG> interesting.
23:07:17 <mtnviewmark> I suspect that while hexpat is fast, my use of it may not be.....
23:07:44 <mtnviewmark> but since profiling puts all the time in that dinky ByteString.hGet function --- it is hard to figgure it out
23:11:40 <osaunders> Can you really not overload functions by arity?
23:11:57 <mtnviewmark> nope
23:11:57 <Axman6> you can, look at printf
23:11:57 <ddarius> You can't overload functions at all.
23:12:13 <osaunders> Contradiction!
23:12:16 <c_wraith> all functions in haskell have the same arity
23:12:21 * mtnviewmark wonders if arity really even makes sense as a concept in Haskell....
23:12:24 <dmwit> Classes provide overloading.  Ignore ddarius.
23:12:54 <dmwit> Well, don't ignore him all the time, just this time. =P
23:13:08 <Berengal> Define "overloading"
23:13:36 <mtnviewmark> well... if the python uses elementTree rather than cElementTree, then the Haskell code is 4x faster on XML input
23:13:38 <osaunders> I want to have a function that take 2 args and does one thing and a different thing with 3.
23:13:52 <Berengal> osaunders: Give them different names
23:14:04 <osaunders> Berengal: I don't wanna!
23:14:22 <c_wraith> osaunders: because of currying, that doesn't really make sense.
23:14:26 <Berengal> osaunders: overloading, at least as I know it from Java, is just based on the fact that the "name" of a function consists of the identifier + the number and type of arguments
23:14:36 <dmwit> osaunders: Then let the third argument be a Maybe type, and give Nothing as the third argument when its missing.
23:14:40 <Berengal> In haskell, the name is just the identifier
23:15:12 <c_wraith> osaunders:  all functions in haskell only take one argument.  some of them just return a function
23:15:19 <rasfar> so ... to migrate from Language.Haskell.* to Language.Haskell.Exts.* I need to do a global substitute on all my source files, removing all occurrences of "Hs"?  Sounds like a good time for a backup....
23:15:54 <osaunders> c_wraith: What about when I say foo a b = a + b ?
23:16:15 <ddarius> That means: foo = \a -> \b -> a + b
23:16:32 <osaunders> OK.
23:16:41 <c_wraith> osaunders: it's a function that takes a number, and returns a function from a number to a number
23:17:13 <cnwdup> I cannot fold over function application, can I?
23:17:33 <cnwdup> @paste
23:17:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
23:17:35 <Berengal> cnwdup: you can fold over function composition, if that help
23:17:37 <Berengal> s
23:17:54 <kmc> :t ($)
23:17:55 <lambdabot> forall a b. (a -> b) -> a -> b
23:17:55 <c_wraith> :t foldl (.) id [(+1), (*2)]
23:17:57 <lambdabot> forall a. (Num a) => a -> a
23:18:06 <osaunders> c_wraith: So I could define a function that will appear to take multiple arguments by recursively returning functions.
23:18:09 <ddarius> > foldr ($) 1 [succ, pred]
23:18:11 <lambdabot>   1
23:18:26 <osaunders> c_wraith: Err, I mean, I could make it take different numbers.
23:18:30 <osaunders> Of args.
23:18:35 <kmc> osaunders, it won't typecheck
23:18:37 <kmc> unless you use a typeclass
23:18:40 <kmc> like printf does
23:18:42 <dmwit> :t appEndo . mappend . map Endo
23:18:44 <lambdabot>     Couldn't match expected type `Endo a'
23:18:44 <lambdabot>            against inferred type `a1 -> a1'
23:18:44 <lambdabot>     In the first argument of `(.)', namely `mappend'
23:18:45 <kmc> :t printf
23:18:47 <lambdabot> forall r. (PrintfType r) => String -> r
23:18:57 <kmc> @instances PrintfType
23:18:57 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
23:18:57 <osaunders> What's r?
23:19:01 <c_wraith> osaunders:  if you really want to go down this rabbit hole, printf shows you how...  But it's a nightmare
23:19:04 <kmc> osaunders, a type variable
23:19:05 <dmwit> :t appEndo . mconcat . map Endo
23:19:07 <lambdabot> forall a. [a -> a] -> a -> a
23:19:07 <mtnviewmark> printf's trick is quite gnarly!
23:19:21 <kmc> osaunders, another way to take variable numbers of args is to use Template Haskell to write code that writes code
23:19:32 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5196#a5196 How can I make that function prettier?
23:19:36 <kmc> in which case the number of args for any particular application is fixed at compile time
23:19:38 <kmc> and the args typechecked
23:19:38 <osaunders> kmc: Oh wow.
23:19:48 <osaunders> c_wraith: OK.
23:19:51 <kmc> the TH version of printf is nicer for this reason
23:20:03 <kmc> more statically typed, more efficient, you don't have to parse the format string at runtime
23:20:21 <dmwit> cnwdup: Check out readTime.
23:21:20 <osaunders> cnwdup: readUTCTimePart part = read $ formatTime defaultTimeLocale part utc
23:21:55 <osaunders> cnwdup: Or listen to the other guy who's way more experienced than me.
23:21:58 <osaunders> :-)
23:22:30 <osaunders> c_wraith: I think the fact that this is hard in Haskell is no bad thing.
23:22:49 <osaunders> c_wraith: I'm just going to have the version that takes 3 args always.
23:23:24 <kmc> osaunders, usually when C++ and Java programmers overload by number of args, they should instead use different names
23:23:46 <mtnviewmark> why not just extract the Day from a UTCTime, built in turn from posixSecondsToUTCTime
23:24:34 <osaunders> kmc: Or (as in this case), not have default values when they could just be specified each time.
23:24:43 <dmwit> cnwdup: readTime defaultTimeLocale "%Y %m %d" (formatTime defaultTimeLocale "%Y %m %d" utc) :: Day -- works here
23:24:54 <osaunders> kmc: Because default isn't necessary.
23:25:05 <mtnviewmark> or    getPosixTime >>= return utctDay . posixSecondsToUTCTime
23:25:10 <kmc> your default can be "Nothing" anyway
23:25:12 <cnwdup> dmwit, thanks. It does here, too.
23:25:21 <kmc> or if you're taking a lot of args, take a record and provide a "defaults" record
23:25:33 <mtnviewmark> :t getPosixTime >>= return utctDay . posixSecondsToUTCTime
23:25:35 <lambdabot> Not in scope: `getPosixTime'
23:25:35 <lambdabot> Not in scope: `utctDay'
23:25:35 <lambdabot> Not in scope: `posixSecondsToUTCTime'
23:26:01 <dmwit> oh
23:26:06 <dmwit> mtnviewmark++
23:26:12 <mtnviewmark> :-)
23:26:20 <dmwit> cnwdup: utctDay :: UTCTime -> Day -- =D
23:26:38 <mtnviewmark> <-- has a thing for date/time libraries -- one of the first thing I read in any language
23:26:53 <ddarius> http://web.archive.org/web/20061011094943/http://haskell.org/hawiki/UsingRecords
23:27:04 <cnwdup> dmwit, that's even better. Thank you! :)
23:27:36 <dmwit> mtnviewmark: But, getPosixTime >>= return . posixSecondsToUTCTime is better written as getCurrentTime. ;-)
23:27:57 <dmwit> :t fmap utctDay getCurrentTime
23:27:59 <lambdabot> Not in scope: `utctDay'
23:27:59 <lambdabot> Not in scope: `getCurrentTime'
23:28:01 <dmwit> aw
23:28:37 <mtnviewmark> ah yes -
23:28:51 <mtnviewmark> indeed, didn't remember that variant of getting the current time was available
23:29:32 <mtnviewmark> so,   getCurrentDay = liftM utctDay getCurrentTime
23:46:32 <rasfar> <cringe> not quite as trivial as the global substitution, although that was a good start.
23:49:15 <osaunders> What do people think of my ASCII border drawing code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13391#a13391
23:49:32 <osaunders> Review me! :-)
23:49:47 <kmc> mmm sandwich
23:50:03 <kmc> sandwich with filling
23:50:05 <kmc> this code makes me hungry
23:50:12 <osaunders> :-)
23:50:36 <kmc> osaunders, it looks nice
23:51:33 <osaunders> Yay! That's my first bit of Haskell that isn't just testing the language.
23:51:41 <kmc> if you have a unicode terminal you can replaces those characters with fancy unicode box-drawing characters
23:51:48 <kmc> is there any reason you didn't give type signatures for the later bindings?
23:52:25 <osaunders> kmc: I thought it was sort of obvious without, they just call edge, which has one.
23:52:37 <shambler> http://codepad.org/Jxk7DyOe
23:52:40 <osaunders> border could do with one, I suppose.
23:52:42 <shambler> yay, pretty
23:53:02 <kmc> osaunders, *shrug* i usually put a sig on every toplevel bind, just for consistency
23:53:07 <kmc> ghc with -Wall will warn if you don't
23:53:12 <kmc> but for a small program it doesn't matter anyway
23:53:15 <osaunders> shambler: Nice, I'll just that pastebin from now on.
23:53:32 <osaunders> kmc: OK.
23:56:56 <osaunders> unlines is a pretty funny name for a function.
23:57:07 <ivanm> osaunders: it is the opposite of lines
23:57:42 <osaunders> Yeah, I makes sense.
