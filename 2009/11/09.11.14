00:00:37 <ivanm> well, that might be possible, but it'd make parsing more difficult
00:00:42 <ivanm> tensorpudding: but what's so bad about :: ?
00:00:51 <tensorpudding> it's not worthwhile to make parsing less pleasant
00:00:58 <ivanm> yeah
00:01:10 <tensorpudding> it's too symmetric
00:01:18 <c_wraith> considerably less pleasant, all told.  Especially with the ScopeTypeVariables extension
00:01:29 <c_wraith> ScopedTypeVariables, that is
00:01:31 <ivanm> ummm.... how is :: any more symmetric than : ?
00:01:44 <c_wraith> diagonally
00:01:47 <ivanm> c_wraith: hmmm?
00:02:05 <c_wraith> it's symmetric on reflection across a 45 degree angle through the middle
00:02:06 <ivanm> its symmetry diagonally or whatever depends on your font
00:02:08 <tensorpudding> in an editor you won't really confuse the two with syntax highlighting
00:02:23 <c_wraith> and it's symmetric across a 90 degree rotation
00:02:30 <c_wraith> depending on your font, of course
00:03:07 <tensorpudding> i can't imagine a situation you would want to display haskell code using a non-fixed-width font
00:03:09 <ivanm> *sigh* couldn't we have picked our own joke category?
00:03:53 <eldragon> if writing a software that requires 20 years-people, it will costs me 20 years alone.
00:43:44 <dmwit> What, you can't think of any situation at all where you would want to display Haskell code using a non-fixed-width font?
00:43:52 <dmwit> That's just a lack of imagination.
01:00:31 <ray> common among programmers
01:50:44 <eldragon> how many types of Bruijn are there?
01:51:25 <dolio> Two.
01:51:32 <dolio> That's why it's call Duo Bruijn.
01:51:35 <eldragon> two?
01:58:39 <eldragon> why two?
01:58:59 <eldragon> i though that it was one.
01:59:04 <ivanm> because Bruijn couldn't afford any more
02:01:22 <eldragon> i heard that HOLxx had 3 Bruijn scheme, are not they 3 different kinds?
02:01:40 <eldragon> those from HOL-light.
02:06:37 <dolio> I can only think of two de Bruijn numberings off the top of my head.
02:06:47 <dolio> Start counting from the outside, and start counting from the inside.
02:06:58 <dolio> I don't know what the third would be.
02:11:23 <eldragon> http://caml.inria.fr/pub/ml-archives/caml-list/2000/10/01d25588e0b8cd3cb88a86db56f6a165.en.html
02:14:19 <eldragon> HOL88 (name-carrying), HOL90 (name-carrying at 1st then de Bruijn), HOL98 (de Bruijn at 1st then explicit substitutions), HOL-Light (de Bruijn at 1st then name-carrying). Some detailed comments about their obscure bugs.
02:14:44 <dolio> That's just a list of how different things were implemented.
02:15:21 <dolio> 88 used names, 90 used names at first, then switched to some de Bruijn scheme. Etc.
02:15:25 <eldragon> what's the more reliable and efficient scheme?
02:15:52 <dolio> Both purely names and purely de Bruijn have issues.
02:23:45 <dolio> Those aren't the only two options, of course.
02:27:20 <sunrayser> I created a type "type Prg = (Expr.Program t) => t". However it seems that Haskell modifies it as "forall t. (Expr.Program t) => t)" and it breaks my code. Is there any way to tell Haskell not to put that forall there?
02:28:26 <dolio> What is the t supposed to refer to?
02:29:01 <sunrayser> dolio: it should be any type with a Computable constraint
02:29:39 <sunrayser> I mean it I use this, my type will no longer be Computable, because it's only Computable without the forall
02:30:15 <dolio> Where does it come from, though? Are you writing types like "forall t. Prg -> whatever"?
02:31:08 <sunrayser> I have two types: Stage = Prg -> FunNameWithParamNameList -> Options -> [ImpFunction] and Prg = (Expr.Program t) => t
02:31:28 <sunrayser> and I need to write functions like (Stage -> Prg -> FilePath -> FunNameWithParamNameList -> Options -> IO ())
02:32:07 <sunrayser> where the Prg in the Stage and the Prg in the signature should be equal (I think)
02:33:22 <dolio> Is t supposed to appear in any of those other things?
02:34:26 <sunrayser> now it appears: (Expr.Program t) => Stage -> t -> FilePath -> FunNameWithParamNameList -> Options -> IO()
02:34:53 <sunrayser> but my goal is to simplify those signatures and pack the constraint into a simple Prg
02:35:03 <Jedai> Sorry but you can't do this in Haskell (yzt)
02:35:09 <Jedai> yet
02:35:36 <sunrayser> oh
02:36:22 <sunrayser> do you think a type signature like this can't be simplified any more?
02:36:38 <ivanm> with QC, what's the point of shrink in the Arbitrary class?
02:37:13 <Jedai> Well "FunNameWithParamNameList" is pretty long for a type name...
02:37:56 <sunrayser> what should I rename it to (while keeping the understandability)?
02:45:22 <Jedai> sunrayser: CallDescr ?
02:46:30 <sunrayser> Jedai: well, ok. They're already complaining about the length of my names
03:02:51 <EddyDean> How do I get the last changed date of a file?
03:03:19 <EddyDean> Creating a simple backup script in Haskell, but doing a byte-by-byte compare of the files is quite inefficient
03:05:44 <Baughn> p_l: ..well, Israfel just went berserk. Then Lilith, aka. Eva 01, killed it. Shinji was not involved.
03:06:00 <Baughn> p_l: Scenario? What scenario?
03:06:37 <ivanm> hey Baughn
03:06:46 <ivanm> EddyDean: which OS?
03:06:47 <Baughn> Oh. Er.. wrong channel, was it?
03:06:54 <ivanm> Baughn: ;-)
03:08:55 <EddyDean> ivanm: Windows, but a cross-platform solution would be nice
03:09:03 <EddyDean> ivanm: not neccesary though
03:09:18 <ivanm> EddyDean: heh, its the windows bit that is hard, not cross platform ;-)
03:09:21 <p_l> Baughn: ... I was quite surprised seeing this in #haskell :P
03:09:26 <ivanm> EddyDean: RWH has some stuff about getting file info IIRC
03:09:33 <ivanm> EddyDean: in the find DSL chapter
03:09:49 <Baughn> p_l: That's what you get from joining multiple channels.
03:09:51 <EddyDean> ivanm: I'll take a look, can't remember reading anything about it
03:10:58 <ivanm> EddyDean: basically, look through System.Directory; if there's anything it's most likely there
03:11:04 <ivanm> or else have a look to see what's on hackage
03:11:08 <ivanm> EddyDean: maybe unix-compat...
03:11:19 <EddyDean> ivanm: You're right, RWH has some info on getting file properties
03:11:47 <EddyDean> Directory.getModificationTime
03:12:28 * ivanm thinks he should maybe re-read the RWH chapter on QC before trying to stumble his way through it
03:16:18 <eldragon> http://caml.inria.fr/pub/ml-archives/caml-list/2000/10/a857c647669668fa0....html <-- more about de Bruijn indices.
03:51:02 <eldragon> deBruijn yes/no, name-carrying yes/no, it's hard to pick them!
03:53:28 <mmx166mhz> Hi
03:55:45 <chrisdone> anyone done any work with using quickcheck for IO?
03:56:05 <ivanm> chrisdone: what kind of properties could you write?
03:56:07 <chrisdone> I toyed with hiding Prelude and making a faux pure IO monad
03:56:33 <ivanm> ummm... wtf?
03:56:51 <koeien1> hmm, nice
03:57:15 <koeien1> turn it into a Writer or State monad, and inspect the result
03:57:42 <koeien1> so putStrLn "hello!" would be something like tell (PutStrLn "hello!")
03:57:43 <ivanm> yes, but it would be rather difficult to do it consistently everywhere
03:57:45 <chrisdone> ivanm: well imagine getLine takes one argument. then any function f derived from it will need an argument for getLine. so your f :: FakeIO is really, underneath, f :: String -> String. and for that you can test properties
03:57:58 <koeien1> ivanm: definitely
03:57:58 <ivanm> since other modules are using the real IO...
03:58:21 <chrisdone> I guess you'd have to restrict it to your own code
03:58:26 <ivanm> so, you could only use it to test a limited sub-set of re-implemented "IO" functions
03:58:30 <chrisdone> (or just re-define the imported IO operations_
03:59:01 <Baughn> instance Monad IOT where a >>= b = b (unsafePerformIO a)
03:59:04 <chrisdone> beats having no tests at all
03:59:07 <ivanm> chrisdone: yes, but you'd have to keep doing it
03:59:40 <koeien1> i think HUnit might be more suitable
04:00:02 <ivanm> yeah
04:00:06 <eldragon> http://www.math.carleton.ca/~kcheung/holnat.html  <-- holnat loading HOL-Light has a speedup between 4x and 10x at most of their computations that he observed, it's powerful!
04:04:05 <chrisdone> Baughn: have you actually done that?
04:04:29 <chrisdone> :t seq
04:04:30 <lambdabot> forall a t. a -> t -> t
04:04:44 <donri> chrisdone, i read you should use quickcheck for pure code and hunit for impure
04:04:50 <Baughn> chrisdone: I, um.. no.
04:09:31 <ivanm> Baughn: oh, indentation is working out quite nicely
04:09:40 <GlassesNoHairsVi> src/darcs.hs:25:7: Could not find module `Test.Package':
04:09:51 <ivanm> I'm just missing the code-generating/prettifying facilities of indent... *hint, hint*
04:09:52 <ivanm> ;-)
04:09:55 <GlassesNoHairsVi> do you know what is this kind of Package? :)
04:10:04 <ivanm> GlassesNoHairsVi: what are you trying to build?
04:10:09 <GlassesNoHairsVi> darcs
04:10:51 * ivanm checks the deps of darcs
04:10:55 <luite> I have a C header file with a few simple structs and functions that I want to use in haskell, what tool should I use to generate the bindings?
04:11:01 <ivanm> GlassesNoHairsVi: how are you trying to build it?
04:11:13 <GlassesNoHairsVi> ooops
04:11:19 <GlassesNoHairsVi> wrong channel :)
04:11:29 <ivanm> is it? >_>
04:11:54 <ivanm> GlassesNoHairsVi: I take it you meant to ask in #darcs itself? ;-)
04:12:31 <GlassesNoHairsVi> yes
04:12:37 <mmx166mhz> Question: I have ( an example) module which says: import Graphics.UI.WX; how can I let it work?
04:14:20 <ben_m> Is there a short way of telling Parsec to ignore whitespace?
04:14:30 <ben_m> Or Parsec.Expr in this case
04:16:21 <ivanm> mmx166mhz: what do you mean?
04:16:44 <mmx166mhz> Well, look at this link ( and then Balls.hs)
04:16:46 <mmx166mhz> http://www.cs.uu.nl/wiki/bin/view/FP/CodeVoorbeelden
04:16:48 <ivanm> ben_m: I've never used parsec, but I guess by having something that consumes all whitespace laced through your parsing
04:17:01 <ivanm> mmx166mhz: are you asking which packages you need to get it to work?
04:17:03 <ben_m> Oh that made me think of something
04:17:09 <mmx166mhz> yes,
04:17:10 <ivanm> i.e. where to get Graphics.UI.WX ?
04:17:14 <mmx166mhz> indeed
04:17:15 <ivanm> mmx166mhz: wxhaskell
04:17:17 <chrisdone> @hoogle fromInt
04:17:17 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
04:17:17 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
04:17:19 <ivanm> (I think)
04:17:26 <ivanm> @google wxhaskell
04:17:27 <lambdabot> http://wxhaskell.sourceforge.net/
04:17:27 <lambdabot> Title: wxHaskell
04:17:29 <ivanm> mmx166mhz: ^^
04:17:34 <mmx166mhz> thanks :)
04:17:41 <ivanm> no worries
04:18:50 * hackagebot upload: pathtype 0.0.2 - Type-safe replacement for System.FilePath etc (BenMoseley)
04:19:16 <ivanm> :o
04:19:23 <mmx166mhz> http://wxhaskell.sourceforge.net/doc/Graphics-UI-WX.html
04:19:30 <mmx166mhz> well, how can I download this package?
04:19:34 <ivanm> mmx166mhz: you'd need to install wxhaskell
04:19:38 <ivanm> isn't it on that site?
04:19:43 <mmx166mhz> lets look
04:19:53 <ivanm> mmx166mhz: oh, the wx library on hackage
04:24:48 <Peaker> what's up with augustuss?
04:30:53 <mmx166mhz> How should I use -v?
04:31:10 <mmx166mhz> GHC keeps saying I must use -v to see the files searched for
04:31:47 <koeien1> you probably miss some dependencies. could you paste the error message?
04:31:49 <koeien1> ?hpaste
04:31:49 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:32:34 <mmx166mhz> pff, I am really getting frustrated with haskell man.. My problem is: I have downloaded Graphics.UI.WX, but how can I use it?
04:32:55 <mmx166mhz> http://hackage.haskell.org/package/wx , the cabal source package
04:33:22 <mmx166mhz> I ran the Setup.lhs file, and GHCi reported somethinhgs
04:33:39 <mmx166mhz> But I still cant run a file which uses graphics.ui.wx
04:35:00 <koeien1> did you install wxHaskell correctly?
04:35:04 <koeien1> does it occur in 'ghc-pkg list' ?
04:35:04 <mmx166mhz> Nope.
04:35:07 <koeien1> i see
04:35:19 <koeien1> surely there is some error message at the end of the output?
04:35:24 <koeien1> which operating system are you on, by the way?
04:35:30 <mmx166mhz> vista
04:35:42 <chrisdone> haha, Test.QuickCheck.Monadic is awesome
04:47:24 <Botje> mmx166mhz: cabal install wx
04:47:32 <Botje> that will download and build any dependencies for you
04:57:26 <McManiaC> is there a good mime-type parser out there? Codec.MIME.Parse keeps on telling me "unable to parse content-type"
05:02:59 <chrisdone> donri: quickcheck does impure code fine
05:05:39 <donri> neat
05:05:42 <MacCoaster> how do i extract the string from IO String if i do something like let request = hGetContents sHandle? because i cant do putStrLn request obviously... should it be let (request,_) = hGetContents sHandle ?
05:06:06 <koeien1> no, request <- hGetContents sHandle
05:06:15 <koeien1> do you know anything about I/O in Haskell?
05:06:21 <koeien1> if not, there are various tutorials that can help you
05:06:33 <MacCoaster> im trying to learn from the few tutorials :\ got a good one?
05:06:48 <ehamberg> a super simple tutorial: http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html
05:06:56 <ehamberg> done by Axman6 on this channel.
05:06:59 <Axman6> :o
05:07:01 <Axman6> o/
05:07:37 <MacCoaster> o nice, thanks Axman6 :)
05:07:48 <MacCoaster> that i like explanations of blocks of code :)
05:08:54 <Axman6> MacCoaster: if you find anything you don't like about it, please let me know, i'm always wanting to improve things like that, when they're aimed at newcomers
05:09:14 <MacCoaster> will do
05:09:31 <Axman6> and of course if you have more questions, feel free to ask us
05:09:52 * arcatan hasn't seen a monad tutorial for ages
05:11:25 <Axman6> arcatan: if you follow that link, you still won't ;)
05:11:58 <ben_m> Axman6: Some of the longer lines in the code examples get cut off.
05:14:02 <chrisdone> @hoogle (a -> Bool) -> a -> Just a
05:14:02 <lambdabot> Did you mean: a -> Bool -> a -> Maybe a /count=20
05:14:02 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:14:02 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
05:14:30 <ben_m> @hoogle (a -> Bool) -> a -> Maybe a
05:14:31 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
05:14:32 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
05:14:32 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:14:34 <Axman6> oh, that link's wrong
05:14:36 <ben_m> Isn't that the correct type?
05:14:57 <ben_m> Just is a value constructor, not a type constructor.
05:15:08 <chrisdone> :t find . return
05:15:09 <lambdabot> forall a. Bool -> [a] -> Maybe a
05:15:22 <Axman6> http://random.axman6.com/blog/?page_id=70 is where you should be looking MacCoaster, ehamberg and ben_m
05:15:46 <chrisdone> ben_m: yeah I meant Maybe obviously
05:16:17 <mauke> :t flip find . return
05:16:18 <lambdabot> forall a. a -> (a -> Bool) -> Maybe a
05:16:33 <chrisdone> I need to install goa or something
05:16:39 <mauke> :t flip (flip (.) return (flip find))
05:16:41 <lambdabot> forall a. (a -> Bool) -> a -> Maybe a
05:17:51 <Axman6> ehamberg: where'd you get that link by the way? just googled it?
05:20:26 <ehamberg> Axman6: googled "axman7 io"
05:20:32 <ehamberg> *axman6*
05:20:34 <Axman6> heh
05:20:52 <ehamberg> what happened to axman 1-5, btw?
05:21:08 <Axman6> they were defeated in a bloody knife battle
05:21:21 <ben_m> He changes his nick on his birthdays.
05:21:57 <Axman6> heh
05:22:21 <Axman6> text . map succ $ "Axman6"
05:22:23 <Axman6> > text . map succ $ "Axman6"
05:22:25 <lambdabot>   Bynbo7
05:22:40 <ben_m> hah.
05:22:44 <mauke> > map pred "Axman6"
05:22:45 <lambdabot>   "@wl`m5"
05:22:47 <ben_m> :t text
05:22:48 <lambdabot> String -> Doc
05:23:04 <Axman6> Bynbo7 is my alt nick
05:23:13 * mauke is now known as wl`m5
05:25:31 <Jafet> > map (\x -> if x=='m' then x else succ x) $ "Axman6"
05:25:32 <lambdabot>   "Bymbo7"
05:26:45 <Eduard_Munteanu> Hi.
05:26:51 <ben_m> Hi
05:27:46 <waern> tibbe: hi! Any news on the haddock html backend revamp you wanted to do?
05:27:56 <tibbe> waern: :)
05:28:12 <tibbe> waern: not really, I just need one day worth of time and some pointers on the current code
05:28:33 <Eduard_Munteanu> Did anybody play with Grapefruit? I want to implement a GUI using it.
05:28:45 <tibbe> waern: I think it should be rather straightforward. The tricky part is to make sure I cover all data constructors in AST that gets turned to HTML
05:29:20 <waern> tibbe: I should be able to give you some pointers, just ask
05:29:31 <tibbe> waern: sure. Could I drop you an email with my questions?
05:29:46 <waern> tibbe: please do that!
05:29:46 <tibbe> waern: if you msg me your email privately I can try to send you an email tomorrow morning
05:30:29 <koeien> wasn't there a ghc 6.12 release candidate? i can't seem to find it on haskell.org/ghc
05:30:47 <Baughn> koeien: It's hard to find. Fighto!
05:31:04 <tibbe> waern: heading out in a min. I'll drop you an email tomorrow.
05:31:22 <waern> tibbe: okay, great
05:31:31 <koeien> Baughn: ?
05:31:41 <Baughn> koeien: As I said. Hard to find.
05:31:42 <Baughn> koeien: http://www.haskell.org/pipermail/glasgow-haskell-users/2009-October/017800.html
05:31:54 <koeien> Baughn: good. thanks
05:33:17 <chrisdone> Baughn: have you seen Test.QuickCheck.Monadic?
05:37:05 <sigrid> When deriving Eq, does == compare pointers before it looks into the structure?
05:38:31 <Heffalump> sigrid: no
05:38:40 <sigrid> Heffalump: is there a way to do it?
05:38:54 <sigrid> it seems like an important optimization
05:39:26 <ziman> does Eq require reflexivity?
05:39:36 <Heffalump> ziman: no
05:39:40 <Heffalump> sigrid: you could do it by hand
05:39:40 <koeien1> morally? yes
05:39:50 <sigrid> Heffalump: how?
05:40:36 <Heffalump> sigrid: there's a GHC extension, I think.
05:40:58 <Heffalump> unsafePtrEq in GHC.Prim
05:41:53 <Heffalump> hmm, or rather reallyUnsafePtrEquality£
05:42:05 <sigrid> cool, thanks
05:42:10 <Heffalump> s/£/a hash symbol I can't get my keyboard to produce right now/
05:42:21 <Heffalump> but I'm a bit confused about what happened to unsafePtrEq, and why this one is callde reallyUnsafe
05:42:30 <Heffalump> so I suggest a bit more research on your side before using it!
05:46:33 <MacCoaster> Axman6: just a question about your last part of the tutorial, so we get in the IO monad and we're stuck there, right? so that means if i do a request <- hGetLine someHandle, request itself cant be a String that can be passed to some pure function?
05:47:12 <Axman6> request there is a string which can be passed to a pure function, but it must be done inside the IO monad
05:47:40 <FunctorSalad> Heffalump: maybe because stable names should be used instead?
05:47:41 <FunctorSalad> no idea.
05:47:46 <Axman6> so, you could so something like: do { x <- getInt; let x' = x+x; print x'}
05:48:19 <Kim^Walkman> Is “let x' = x + x;” just short-hand for “x' <- return (x + x)” or is there more to it?
05:48:36 <koeien1> not really
05:48:43 <FunctorSalad> it doesn't do 'return'
05:48:50 <koeien1> in let-bindings the x' could also occur on the right hand side
05:48:53 <FunctorSalad> it's pure
05:49:13 <koeien1> but in this specific case, they are equivalent, guaranteed by the monad laws
05:49:34 <FunctorSalad> @undo do { x0 <- x; let y = x+x; return y }
05:49:34 <lambdabot>  Parse error at "}" (column 37)
05:49:37 <Axman6> koeien1: let implies purity
05:49:53 <Axman6> uh, Kim^Walkman, sorry koeien1
05:49:53 <FunctorSalad> lambdabot: ?
05:49:54 <lambdabot> Maybe you meant: . ? @ activity activity-full admin all-dicts arr ask b52s babel bf bid botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add
05:49:54 <lambdabot> djinn-clr djinn-del djinn-env djinn-names djinn-ver do docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune
05:49:54 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google googleit gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma
05:49:54 <lambdabot> karma+ karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on nixon oeis offline
05:49:56 <lambdabot> oldwiki palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc
05:49:58 <FunctorSalad> ....
05:49:59 <lambdabot> [3 @more lines]
05:50:02 <Axman6> jesus
05:50:03 <arcatan> @more
05:50:03 <lambdabot> read reconnect remember repoint run shootout show slap smack source spell spell-all src tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc
05:50:04 <lambdabot> topic-tail topic-tell type undefine undo unlambda unmtl unpf unpl unpointless uptime url v vera version vixen vixen-off vixen-on vote web1913 what where where+ wiki wikipedia wn world02 yarr
05:50:07 <lambdabot> yhjulwwiefzojcbxybbruweejw yow
05:50:09 <Axman6> that's not supposed to happen
05:50:15 <FunctorSalad> indeed
05:50:19 <Axman6> @yhjulwwiefzojcbxybbruweejw
05:50:20 <lambdabot> Exception: <<loop>>
05:50:37 <arcatan> yhjulwwiefzojcbxybbruweejw would need some explanation
05:50:51 <RayNbow> > let x = x in x
05:50:55 <lambdabot>   mueval-core: Time limit exceeded
05:51:05 <MacCoaster> Axman6: hmm but i cant do file <- (words request) !! 1?  (words request) doesnt like IO Char? and its in a function whose signature is Socket -> IO () ... doesnt that make me execute (words request) in the IO Monad?
05:51:42 <koeien1> MacCoaster: no, you should do   let file = (words request) !! 1  since this is not an IO computation
05:51:53 <Axman6> MacCoaster: if you have a function f :: IO a, then the type of x in x <- f is a: x :: a
05:52:03 <MacCoaster>  ah so i must force type?
05:52:29 <Axman6> no
05:54:20 <MacCoaster> ah eep.. doh..  i was missing the $ character cos it was complaining about type, but then i realized it was actually giving putStrLn 2 argumnets... :) nevermind!
05:54:23 <MacCoaster> thanks
05:54:25 <Heffalump> FunctorSalad: those have overhead
06:08:23 <gwern> @quote program.*anything
06:08:24 <lambdabot> c2.com says: If you can program anything in HappS you actually already learned Haskell
06:08:38 <gwern> @quote Lasty
06:08:38 <lambdabot> Cale says: Chew new Lasty ST Gum! It lasts until _|_!
06:08:47 <gwern> hm. I can't help but think that a typo
06:08:54 <harlekin> Can I write a generic makeParser function which takes a function and produces a parser according to the function's type?
06:08:57 <gwern> surely Cale meant 'Lazy ST'?
06:09:09 <ben> I suspect it is a pun
06:10:19 <gwern> on what?
06:10:30 <ben> Lazy and lasting
06:14:15 <gwern> mm
06:14:18 <gwern> @quote napoleon
06:14:18 <lambdabot> <BONUS> says: C++ is saner than something? imo C++ is like the guy that goes around shouting "I am napoleon!!!"
06:14:41 <gwern> @quote high.efficiency
06:14:41 <lambdabot> danderson says: [using unsafeFreeze for an ST action] that sounds like a way to shoot myself in the foot with high efficiency, given my knowledge of haskell.
06:14:53 <gwern> @quote worst.moniod
06:14:54 <lambdabot> No quotes match. You untyped fool!
06:14:57 <gwern> @quote worst.monoid
06:14:57 <lambdabot> kmc: says: (): worst monoid ever
06:15:03 <gwern> @quote buttocks
06:15:03 <lambdabot> DanWeston says: Bottom has only one value, not two. Otherwise bottom would have been called buttocks.
06:15:06 <gwern> @flush
06:19:52 <Liskni_si> where do I get the IsString instance for Data.ByteString.Lazy?
06:30:16 <tommd> Liskni_si: IsString lives in the .Char8 modules under Data.ByteString and Data.ByteString.Lazy
06:30:24 <Liskni_si> oh, thx.
06:32:28 <MacCoaster> anything wrong with:
06:32:31 <MacCoaster> doc <- readFile file
06:32:31 <MacCoaster> 	`catch` (\e -> let doc = error_404 file)
06:33:06 <mauke> yes, it's a syntax error
06:33:15 <MacCoaster> but i dont see how it is?
06:33:21 <mauke> 'let' without 'in'
06:34:00 <MacCoaster> mauke: eh? how would in work there?
06:34:15 <int-e> Heffalump: reallyUnsafePtrEquality isn't more unsafe than unsafePerformIO. It is unsafe, because it's an impure function. I believe the
06:34:21 <mauke> MacCoaster: I have no idea, it's your code
06:34:39 <int-e> tell Heffalump "really" prefix serves the purpose of making people who think this is an innocent operation stop and think again.
06:35:36 <MacCoaster> mauke: heh hmms.. i just want to load error_404 which is a function that accepts a string.. and if its not found by readFile just evaluate error_404 and put that into doc otherwise put contents of file in doc?
06:36:31 <mauke> what's the type of error_404?
06:37:45 <int-e> sigrid: You will never get false positives from reallyUnsafePtrEquality#, so using it as a shortcut in Eq is comparatively safe. Not completely safe, however: Consider shortcutting the comparison x == x where x = repeat () -- that one will never finish without the shortcut. Besides, the operation's behaviour is quite unintuitive sometimes - see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12141#a12141 for an example.
06:38:30 <Heffalump> int-e: but why the 'really' ?
06:38:48 <MacCoaster> mauke: error_404 :: String -> String
06:39:10 <mauke> readFile file `catch` (\e -> return (error_404 file))
06:39:17 <mauke> which probably fails to compile because of ambiguous types
06:39:18 <int-e> Heffalump: because it's really unsafe. you may think otherwise, but it is.
06:39:49 <Axman6> Heffalump: because it may cause death or injury
06:39:50 <Heffalump> is it more unsafe than unsafePerformIO?
06:40:00 <MacCoaster> mauke:  oh you can return like that?
06:40:06 <int-e> For example turning some bottoms into values may seem benign ... until you write a program that /relies/ on that behaviour.
06:40:11 <mauke> MacCoaster: I don't see why not?
06:40:21 <harlekin> @src fmap Either
06:40:21 <lambdabot> Source not found. Maybe you made a typo?
06:40:28 <harlekin> @src Either fmap
06:40:29 <lambdabot> fmap _ (Left x) = Left x
06:40:29 <lambdabot> fmap f (Right y) = Right (f y)
06:40:36 <MacCoaster> mauke: because im new and didnt think it was possible :)
06:41:32 <int-e> Heffalump: no. I really (sic) think that the intended meaning of 'really' is 'actually' here, rather than an emphasis.
06:41:47 <mauke> MacCoaster: what do you think return does? :-)
06:42:00 <Heffalump> not quite sure I see the logic, but fair enough
06:42:07 <MacCoaster> mauke: im still new to the monad thing :)
06:42:35 <int-e> Heffalump: it's an innocuous looking operation. *shrugs*
06:43:01 <Heffalump> I agree it should be called 'unsafe'. Just confused by the varieties of unsafety around.
06:43:21 <byorgey> preflex: seen c_wraith
06:43:22 <preflex>  c_wraith was last seen on #haskell 6 hours, 41 minutes and 1 second ago, saying: depending on your font, of course
06:43:45 <int-e> Heffalump: there may be an injoke here, too. The primop is in a section "Unsafe pointer equality" with this comment: "--  (#1 Bad Guy: Alistair Reid :)   "
06:44:05 <int-e> (see compiler/prelude/primops.txt in the ghc sources)
06:44:11 <int-e> err. primops.txt.pp
06:45:24 <MacCoaster> mauke: yeah ambigous stuff, hrmms
06:45:26 <MacCoaster> :\
06:45:52 <mauke> MacCoaster: I take it you're using Control.Exception.catch then?
06:45:57 <MacCoaster> yes mauke
06:46:14 <mauke> then we need bigger guns
06:46:20 <MacCoaster> the AK-47? :p
06:46:34 <mauke> readFile file `catch` (\e -> return (error_404 file) `const` (e :: SomeException))
06:46:48 <MacCoaster> whats that `const` ?
06:46:53 <mauke> @src const
06:46:54 <lambdabot> const x _ = x
06:47:14 <MacCoaster> so it just returns first arg?
06:47:20 <koeien1> why not PatternSignatures?
06:47:20 <mauke> yes
06:49:17 <MacCoaster> mauke: ok so its doing what exactly there?
06:49:38 <mauke> nothing :-)
06:49:47 <mauke> it just lets me put a type annotation on e
06:49:57 <MacCoaster> O_o
06:50:14 <koeien371> i think that readFile file `catch` (\(e :: SomeException) -> return (error_404 file)) is clearer
06:50:21 <int_e> mauke: would you be happy with \ e @ SomeException {} -> ... ?
06:50:35 <mauke> int_e: oh, that works?
06:51:10 <int_e> mauke: yes, SomeException is a single constructor data type
06:51:28 <mauke> best solution: catchAll :: IO a -> (SomeException -> IO a) -> IO a; catchAll = catch
06:51:35 <int_e> mauke: but maybe it's bad style to rely on that
06:56:06 <ben> Is there a function that sleeps until a directory has been written to and then tells me what happened?
06:57:25 <mauke> sounds like inotify
06:57:27 <profmakx> inotify
06:57:33 <profmakx> works pretty nicely
06:57:46 <profmakx> and is available on hackage, i think
06:57:53 <skorpan> inotify is haskell?
06:58:00 <koeien371> it's a linux technology
06:58:01 <ben> Oh, neat.
06:58:02 <mauke> no, it's linux
06:58:03 <Philonous> But that's a whole (C-)library, not just a function, isn't it?
06:58:21 <skorpan> that's what i thought :P
06:58:46 <skorpan> http://hackage.haskell.org/package/hinotify
07:01:08 <Philonous> Maybe gamin would be a better choice, at least it runs under FreeBSD as well.
07:03:01 <ben> http://www.kernel.org/pub/linux/kernel/people/rml/inotify/README I am sold on inotify, thanks, guys
07:08:29 <sigrid> is there somewhere a good explanation of what the Data typeclass does?
07:12:03 <harlekin> Is there some way to pattern match against the type of a function passed as argument?
07:12:45 <harlekin> I stumbled upon view patterns, but they only pattern match against the result, right?
07:13:16 <chrisdone> pretty sure pattern matching only works on constructors
07:13:24 <koeien371> "the type of a function" -- you cannot pattern match on functions
07:13:45 <mauke> you cannot pattern match on types
07:13:51 <koeien371> no, that too
07:14:58 <gmaslov> classes are kind of pattern matching on types
07:15:01 <eivuokko> If you need to differentiate between types, type classes offer one mechanic for that.
07:15:04 <Ferdirand> you could define a class, with instances being some function types
07:15:06 <koeien371> ...
07:15:08 <gmaslov> <- winner
07:15:10 <stepcut> I need to install GHC 6.10.4 and cabal on leopard to test a bug in happstack. How do I tell if I should use the binary download, macports, or fink?
07:15:18 <Ferdirand> :)
07:15:21 <harlekin> Ok. Thanks.
07:15:23 <eivuokko> Heh
07:15:25 <gmaslov> :P
07:15:28 <dcoutts> stepcut: I'd go for the one from the ghc site
07:15:38 <chrisdone> and that's why #haskell is the most helpful channel ever
07:15:38 <dcoutts> stepcut: but then I don't use mac :-)
07:16:00 <stepcut> dcoutts: I use my mac to ssh into my linux box ;)
07:16:14 <chrisdone> kind of like The Borg
07:16:20 <eivuokko> On my limited experience on mac, I'd go for ports if it has what I want (and have time for it.)
07:16:23 <stepcut> dcoutts: that's much easier than getting sound to work properly on linux :p
07:16:23 <chrisdone> but I am Locutus and mauke is Data
07:16:25 <dcoutts> stepcut: if I had a mac, I'd do it the other way round :-)
07:16:29 <eivuokko> But I mostly watch dvds on my mac
07:17:11 <stepcut> eivuokko: the advantage of ports is that it is easier to install c libraries, like SDL, that haskell libraries may depend on ?
07:17:54 <eivuokko> Ime, ports just has stuff that works better together, and in case of ghc, actually worked for me.
07:18:19 <stepcut> eivuokko: i use my mac for watching DVDs as well. The linux box inverts all the colors for some reason. Though the DVD player in the mac is very picky and often has trouble with netflix dvds
07:18:31 <stepcut> eivuokko: ok, sounds good to me.
07:19:48 <eivuokko> As silly as it sounds, I mostly use vlc and remote control it -.-'
07:19:59 <stepcut> :p
07:20:33 <stepcut> eivuokko: using vlc for DVDs is superior, because you can skip right over that FBI warning crap
07:20:49 <harlekin> @src Functor (->)
07:20:50 <lambdabot> Source not found. Just try something else.
07:20:53 <harlekin> @src (->) Functor
07:20:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:21:22 <stepcut> of course, if I get happstack working on my mac, then I won't have to ssh into my linux box anymore :p
07:21:47 <ziman> @src (->) fmap
07:21:48 <lambdabot> fmap = (.)
07:23:29 <hesselink_> stepcut: I have happstack working on a mac, by just using the ghc and haskell platform installers.
07:23:48 <stepcut> hesselink_: did you use the .pkg install for GHC or mac ports?
07:23:59 <hesselink_> the .pkg install
07:24:22 <stepcut> hesselink_: I am trying to track down this bug, http://code.google.com/p/happstack/issues/detail?id=88
07:24:34 <hesselink_> I think for snow leopard you need to edit the ghc script (and a few others)
07:24:39 <hesselink_> oh, you said leopard, sorry
07:24:56 <stepcut> hesselink_: which may only appear if you are using the latest version of network from hackage or something
07:25:06 <MacCoaster> can i have multiple handlers for a catch depending on which exception?   just do multiple catch's?
07:25:11 <hesselink_> stepcut: ah, I actually ran into that bug
07:25:15 <MacCoaster> for IO, that is
07:25:19 <ben> 'catches'
07:25:26 <ben> is faster than multiple 'catch'es
07:25:45 <hesselink_> stepcut: but since I don't need the rqPeer part of the request, I just ignored it and moved on.
07:26:04 <stepcut> hesselink_: ah :) Well, I need to fix it so we can release happstack 0.4 stable :)
07:26:22 <MacCoaster> ben aha  thanks, i see it in the doc now
07:26:44 <hesselink_> stepcut: as I understand it, it had something to do with IPv6 detection through template haskell?
07:27:54 <hesselink_> stepcut: How close is that release, btw? We have some small patches lying around. Do you think they could still get in before then?
07:30:25 <stepcut> hesselink_: it is close, but there is time.
07:30:29 <stepcut> hesselink_: what sort of patches?
07:31:00 <hesselink_> stepcut: We added a secure flag to cookies
07:31:21 <hesselink_> stepcut: And made the path where state is stored configurable
07:31:31 <hesselink_> stepcut: Or rather, exposed that functionality
07:32:03 <hesselink_> stepcut: I can probably send them in on Tuesday
07:35:30 <stepcut> hesselink_: sounds good.
07:35:54 <stepcut> hesselink_: did you just exposed startSystemState' to make the path configurable? I usually end up calling runTxSystem directly
07:37:13 <hesselink_> stepcut: Yes, I think I just exposed something one level deeper to get to the path. It seems like there is a lot of configuration available in the state system, but none of it is exposed.
07:37:42 <stepcut> yeah, I have been meaning to fix that, glad someone else did
07:38:28 <stepcut> if you have not merged in the last week or some, there were some changes made that may affect your patch.
07:39:37 <stepcut> not much though... The way functions are getting exported is a little different now. Instead of rexporting all of Happstack.State.TxControl (i think) in Happstack.State, we only export specific functions now.
07:40:01 <stepcut> for 0.5 I want to get rid of the secret command-line options in happstack-state
07:41:53 <hesselink_> I haven't merged in the last week... so that patch might take a little longer ;)
07:42:26 <hesselink_> stepcut: Well, I haven't really fixed it in general, just exposed a small part that I needed.
07:42:58 <hesselink_> stepcut: Anyway, I'll see what I can do next week, and leave the rest for later.
07:42:58 <stepcut> hesselink_: right. that is probably a good start.
07:43:28 <stepcut> hesselink_: sounds good. thanks for your patches!
07:47:29 <mmmulani> does anyone know about the status of ghc on mac snow leopard?
07:47:55 <gwern> suppose I run SHA512 on only data that is less than 512 bytes in length. am I correct in believing that there won't be any collisions ever?
07:49:21 <koeien371> no
07:49:30 <gwern> hm. actually, seems sha-512 refers to 512 bits, not bytes
07:49:36 <koeien371> yes
07:49:38 <koeien371> but even then
07:49:57 <koeien371> it could be, but i doubt this is guaranteed
07:50:05 <gwern> ah, because we don't know sha-512 is a perfect hash?
07:52:09 <p_l> gwern: even if your data is less than 512bits you aren't guaranteed zero collisions
07:52:27 <p_l> that's because SHA-512 has also to deal with bigger datasets
07:52:39 <gwern> hm
07:53:19 <gwern> (so sha is designed so bigger input can collide with smaller, which by the pigeon hole principle removes space for other smaller inputs... or something like that I guess)
07:53:43 <koeien371> no
07:54:30 <koeien371> the set of all messages of size <= 512 bits is larger than the set of all messages of size 512 bits (which is the output of the hash)
07:54:59 <arjanb> i guess a perfect hash will be weak for cryptographic purposes
07:55:28 <p_l> gwern: if you are looking for low collision hash, I heard that WHIRLPOOL is pretty good
07:55:31 <koeien371> but why do you care? you probably won't encounter collisions in your life
07:55:59 <p_l> koeien371: I have actually seen tutorials for various tricks that used collisions in SHA
07:56:13 <mm_freak> gwern: there will be collisions, but not necessarily within the lifetime of the universe
07:56:14 <p_l> one was for tracking a leaked software package :)
07:56:32 <koeien371> p_l: also SHA-512 ?
07:56:38 <mm_freak> gwern: you will need to calculate about 2^256 hashes for the probability to become non-neglible
07:56:45 <mm_freak> see birthday paradox
07:57:24 <mm_freak> arjanb: i don't see why, but it doesn't matter, because a "perfect hash function" can't be constructed mathematically
07:57:25 <koeien371> p_l: SHA-1 is "almost broken", but SHA-512 should be safe for a while iirc
07:57:34 <p_l> koeien371: not much is yet for SHA512, true
07:57:39 <mm_freak> if it can, it's infeasible to calculate in the first place
07:57:56 <mm_freak> btw, for all practical purposes SHA-256 is enough
07:58:00 <p_l> however the SHA-1 thing was quite hilarious - it wasn't targeted at cryptography but at checksumming usage
07:58:33 <p_l> basically, embedding data in bits that escaped hash function
07:59:19 <stepcut> Igloo_: greetings!
08:03:09 <Igloo_> hi
08:04:15 <stepcut> Igloo_: any idea what is up with those failing XML tests in happstack-data ?
08:04:35 <opqdonut> @users
08:04:36 <lambdabot> Unknown command, try @list
08:05:25 <Igloo_> No idea, sorry
08:05:44 <stepcut> Igloo_: did you write those? Or just commit them ?
08:06:09 <opqdonut> @list
08:06:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:06:54 <Igloo_> If I committed them then I probably wrote them. If you want me ot look then send me an e-mail, but I don't expect to be able to reply quickly
08:07:16 <stepcut> Igloo_: I did send an email a day or two ago, but perhaps it did not arrive?
08:07:52 <Igloo_> I'm 2 or 3 days behind in e-mail
08:08:24 <Igloo_> Yup, I have your e-mail
08:08:56 <stepcut> Igloo_: ok. No rush. They have always been broken since you commited them, so it can wait longer :)
08:10:14 <stepcut> Igloo_: the only thing I can figure is that you felt that newtypes ought to be handled transparently, similar to Either, (,), etc. So you wrote tests for that, but the library was never actually updated to support that..
08:11:11 <stepcut> Igloo_: or you were coding too late and just forgot to add the MkMyList constructor when you were building the XML by hand. But I don't have enough data to tell which :)
08:18:24 <Cale> gwern: Someone had just typoed it as Lasty ST
08:25:45 <dpratt71> Cale: do you, perchance, know the link kmc gave me the other day (re: type families)? my browser crashed and I lost it
08:26:10 <Cale> dpratt71: I'm not sure which one that'd be
08:26:34 <Cale> The one about the bug?
08:26:37 <Cale> http://hackage.haskell.org/trac/ghc/ticket/1496
08:27:07 <viator_sg> hackage is down?
08:29:30 <dpratt71> Cale: I had stumbled upon a complicated example of type families and kmc referred me to a simpler one; I'll ask kmc when I see...English really needs a gender-neutral singular pronoun!
08:30:08 <aavogt> it?
08:30:29 <ben> 'them'
08:30:52 <dpratt71> I think "it" is neuter, but not gender-neutral
08:31:08 <dpratt71> and "them" is not singular :)
08:31:08 <Twey> Indeed
08:31:21 <Twey> It can be
08:31:36 <aavogt> but them is used to refer to a single person
08:31:41 <medfly> I personally find how my native language has a gender to be beneficial in some ways
08:31:46 <dpratt71> Twey: I know people use it that way, but I never felt right about it
08:31:46 <Twey> And has been for an awfully long time
08:31:53 <ben> wiktionary lists 'Third person singular pronoun of indeterminate or irrelevant gender'
08:31:56 <Twey> dpratt71: Take it up with Shakespeare ;)
08:32:06 <ben> It sure beats making up new words
08:32:07 <dpratt71> Twey: will do :)
08:32:15 <medfly> things can be made shorter through this
08:32:42 <Twey> medfly: There's a difference between being able to specify a gender and having to specify a gender
08:32:49 <Twey> The former is good, the latter is bad
08:32:50 <aavogt> medfly: things can be made more wrong too ;)
08:33:01 <medfly> only if you're a noob foreigner!
08:33:05 <Twey> Heh
08:33:06 <medfly> in which case, people forgive you anyway
08:33:13 <ben> This is the internet
08:33:50 <ben> Foreigners quite regularly put more effort into proper English than some native English speakers, in some places.
08:34:12 <dpratt71> ben: I've noticed that, too
08:34:15 <Twey> Worryingly
08:34:26 <medfly> I am not talking about English luckily.
08:34:28 <medfly> :-p
08:34:29 <Twey> Elegia, QplQyer: Hello
08:34:29 <aavogt> for whose defintion of proper?
08:34:33 <tommd> lispy, dons: PING.  Could I get a cell number for when I get to the door?
08:34:33 <Twey> medfly: Hehe
08:34:37 <gmaslov> what english REALLY needs is a Hindey-Milner gender inference system
08:34:46 <Twey> aavogt: Just about everybody's :þ
08:34:58 <Twey> Except those crazy descriptive linguists'
08:35:33 <Cale> dpratt71: I always use 'they'
08:35:46 <dpratt71> Cale: they/them?
08:35:51 <Cale> dpratt71: yeah
08:36:40 <dpratt71> Cale: I guess I just need to let go of my ill-conceived notions of plurality
08:37:28 <Cale> dpratt71: Well, you'd normally be saying 'he or she' otherwise.
08:37:36 * hackagebot upload: flite 0.1.1 - f-lite compiler, interpreter and libraries (JasonReich)
08:37:38 <Cale> It's just a plurality of options here :)
08:37:57 <ben> What is the simplest way to block until ^C/interrupt? :3
08:38:11 <dpratt71> speaking of language, I notice many folks in #haskell are quite handy with the unicode; is there a secret?
08:38:36 <byorgey> yes, you just get a special Unicode keyboard with one key for every Unicode character
08:38:43 <dpratt71> byorgey: :)
08:38:43 <donri> dpratt71, compose key :)
08:38:47 <byorgey> also handy for APL programming
08:38:50 <ben> rxvt lets me bind my language's äüöß to alt+regularkey combinations :)
08:40:15 <dpratt71> ben: rxvt? I guess I can Google that, but I suspect it doesn't apply to Win7 :)
08:40:21 <ben> I suspect it does not
08:40:27 <ben> x11 terminal emulator
08:40:40 <mm_freak> dpratt71: i use xmodmap =)
08:40:46 <dpratt71> ben: ah, almost certainly not
08:41:11 <dpratt71> mm_freak: another thing to Google, thanks :)
08:41:37 * hackagebot upload: optimusprime 0.0.1.20091114 - A supercompiler for f-lite (JasonReich)
08:42:03 <donri> > (λx → x) "hi"
08:42:04 <lambdabot>   Pattern syntax in expression context: λx -> x
08:42:07 <donri> aww.
08:42:21 <medfly> since this is possibly teh nerdiest channel I know...
08:42:25 <mauke> > (\λ -> λ) "hi"
08:42:26 <sioraiocht> > (\ x -> x) "hi"
08:42:26 <lambdabot>   "hi"
08:42:27 <lambdabot>   "hi"
08:42:35 <Twey> Aww.
08:42:39 <medfly> does anyone know what _start is in C?
08:42:46 <mauke> medfly: it's not in C :-)
08:42:49 <donri> > (\x → x) "hi"
08:42:50 <lambdabot>   "hi"
08:42:53 <p_l> medfly: sounds to me like a system ABI symbol
08:42:55 <Twey> medfly: It's the default name for the entry point, but it's not C-specific
08:42:56 <medfly> mauke, what is it in?
08:43:02 <donri> weird that λ is not recognised
08:43:03 <MoALTz> isn't _start the actual program entry point?
08:43:10 <mauke> donri: it's regocnized just fine
08:43:11 <Twey> It's an assembly convention
08:43:14 <medfly> I really love you guys, you are so great
08:43:15 <mauke> wtf
08:43:17 * medfly group hugs #haskell
08:43:18 <mauke> recognized
08:43:19 <donri> mauke, as lambda?
08:43:21 <nomeata> Hi. Is SigbjornFinne nor or sometimes here, and what is his nickname?
08:43:21 <p_l> MoALTz: no, the entry point is what the file header points to
08:43:24 * Twey laughs.
08:43:28 <mauke> donri: yes. the greek letter lambda.
08:43:36 <donri> mauke, as a haskell lambda :)
08:43:42 <donri> e.g. "\"
08:43:58 <mauke> \ is punctuation
08:43:59 <p_l> The classic C entry point is _main() which setups the environment for main()
08:44:03 <mauke> p_l: no
08:44:07 <donri> "→" is recognised as "->" with some phonetic extension
08:44:11 <MoALTz> no i don't think so either
08:44:13 <Twey> p_l: Not at an assembly level
08:44:16 <ben> Use a double-lengt arrow at least
08:44:39 <ben> ⟶
08:44:39 <donri> punctuation, what do you mean
08:44:40 <p_l> Twey: I'm saying this only in reference to what I have seen in C runtimes
08:44:44 <ben> ⟹!
08:44:56 <p_l> for me, entry point is just a pointer in executable header :)
08:45:01 <gwern> Cale: so you did mean Lazy then?
08:45:12 <mauke> p_l: yes, and ld defaults to _start unless you tell it otherwise
08:45:14 <gmaslov> next step: specialized "Haskell keyboards" that can then be revered as relics of a more civilized age, 20 years later
08:45:16 <dpratt71> saw somewhere an emacs mode that re-writes Haskell with pretty unicode chars; almost made me want to use emacs...almost
08:45:38 * hackagebot upload: bindings-glib 0.1 - Low level bindings to GLib. (MauricioAntunes)
08:45:41 <gwern> dpratt71: haskell-mode; it's an option
08:45:43 <ben> dpratt71: leksah does that too
08:45:53 <nlogax> and yi
08:45:57 <gwern> it's an inclusion of the pretty lambda code package which works over most code modes
08:46:13 <gwern> I lobbied jpb into including it into yi, and it works very nicely
08:46:23 <c_wraith> hey gwern, can you get me an account on the haskell wiki?
08:46:25 <dpratt71> yi?
08:47:32 <Cale> gwern: I meant both :)
08:47:38 * hackagebot upload: bindings-gobject 0.1 - Low level bindings to GObject. (MauricioAntunes)
08:47:49 <gwern> c_wraith: I suppose I could
08:47:50 <dpratt71> ben: I've been meaning to checkout leksah; now I have another reason :)
08:47:57 <gwern> c_wraith: what's an account worth to ya?
08:48:00 <nlogax> dpratt71: http://haskell.org/haskellwiki/Yi
08:48:30 <dpratt71> nlogax: ah, thanks for the enlightenment
08:49:00 <c_wraith> gwern:  short term gratitude :)
08:49:12 <gwern> c_wraith: done, for medium-term
08:49:12 <medfly> p_l, Twey, I think you're both right :)
08:49:20 <donri> mauke, what do you mean punctuation?
08:49:37 <mauke> donri: you can't use it in variables. unlike letters.
08:50:14 * dcoutts suspects all these bindings-* packages of being useless
08:50:36 <donri> mauke, i just thought λ should be recognised as \ with the extension that recognises some unicode for syntax
08:50:45 <mauke> but it's a letter
08:50:51 <donri> so?
08:50:56 <lispy> ?tell tommd The # is posted on the door, and I tried to email it to you yesterday.  Sorry if you didn't get it.  But, yeah it's on the door :)
08:50:57 <lambdabot> Consider it noted.
08:51:11 <araujo> hello there
08:51:52 <dancor> donri: i guess it's hard to justify exceptions to just using the unicode designation of letter/symbol distinction..
08:52:08 <dancor> i mean that's the elegance tradeoff or whatever
08:52:26 <dancor> also it _is_ a greek letter
08:52:43 <dancor> and greek ppl using haskell might want to use it in variable names
08:52:50 <ben> Then they will not use the extension
08:53:12 <donri> i guess. but it would be so pretty to use lambda for lambda!
08:53:34 <dancor> ben: hm?  isn't this the extension that allows you to do things like write your variable names in greek?
08:53:45 <ben> Is it?
08:53:49 <dancor> idk
08:53:59 <SimonRC> doesn't unicode distingus the lambda operator from the letter?
08:54:02 <dancor> i've been exposed as not knowing anything again!
08:54:10 <mauke> > (\λ→λ) ()
08:54:12 <lambdabot>   ()
08:54:18 <SimonRC> like it distinguishes omega from ohms and micro from mu
08:54:21 <gwern> SimonRC: it does
08:54:27 <gwern> but everyone writes the greek lambda
08:54:30 <SimonRC> :-(
08:55:12 <dancor> so the answer to donri's question is to use the other lambda?
08:55:16 <ben> Man, unicode misspells lambda as lamda?
08:55:22 <mauke> gwern: uh, where's the other lambda?
08:55:34 <gwern> mauke: in the math ranges
08:55:34 <Liskni_si> is there a way to create an MArray that maps to a subarray of another MArray?
08:55:36 <ben> 𝛌
08:55:41 <ben> Mathematical Bold Small Lamda
08:55:44 <ben> U+1d6cc
08:55:53 <mauke> oh, that's too big for UCS-2
08:55:54 <ben> My terminal font does not have a symbol for it :(
08:55:59 <mauke> javascript--
08:56:02 <dancor> > (�x->4) 5
08:56:04 <lambdabot>   <no location info>: parse error on input `->'
08:56:07 <dancor> , (�x->4) 5
08:56:09 <lunabot>  luna: parse error on input `->'
08:56:30 <Twey> dancor: No
08:56:43 <Twey> dancor: You don't need an extension to use Unicode in GHC
08:56:52 <dancor> ah.
08:56:58 <Twey> But you do need one for GHC to recognise certain Unicode characters as syntax
08:57:02 <donri> you need an extension to use some unicode as syntax, i think
08:57:06 <Twey> Aye.
08:57:07 <dancor> right.
08:57:19 <int-e> hmm. 𝛌𝜆𝝀𝝺𝞴λ
08:57:25 <Twey> See also the Unicode Prelude.  ☺
08:57:30 <Twey> int-e: What's that?
08:58:09 <int-e> Twey: All lamdas I could find in gucharmap. I have no font support for any but the last one.
08:58:50 * dancor is going to stick to \ rather than figuring out fonts
08:59:18 <donri> > (𝛌x → x) "test"
08:59:19 <lambdabot>   Pattern syntax in expression context: 𝛌x -> x
08:59:53 <Twey> int-e: Same.  ☺
08:59:55 <ben> If only leksah had a button to convert " . " to " <ring operator> "
08:59:58 <donri> all the math lam(b?)das are bold or italic o_O
09:01:00 <int-e> donri: unicode spells it without the b in its character descriptions, for some reason.
09:01:20 <donri> yea, weird
09:01:42 <gmaslov> could be a zero-width "b"
09:01:56 <Twey> Heh
09:02:03 <Twey> ben: What is the ‘ring operator’?
09:02:11 <mauke> ∘
09:02:13 <Twey> +?  ·?  ×?
09:02:15 <gwern> ben: why would you want to replace '.' with '<ring operator>'? we're not programming in xml
09:02:19 <Twey> Huh
09:02:26 <ben> gwern: I was just too lazy to look up the actual operator :(
09:02:29 <gwern> oh
09:02:39 <ben> It is what mauke said, I believe.
09:02:44 <gwern> well that wouldn't be too difficult since leksah can already parse and replace it visually
09:02:57 <Philonous> the operator for functional composition
09:03:03 <Twey> What does ∘ do?  [[Ring]] doesn't mention it
09:03:05 <ben> It can replace " . " with "∘", but I cannot seem to figure out how to make it keep the spaces
09:03:07 <Twey> Oh!
09:03:15 <gwern> dunno whether you would get a text file that could be used with any compiler or tool though...
09:03:16 <Twey> Named for its shape rather than its function
09:03:16 <ben> It is U+2218 RING OPERATOR = composite function; APL jot
09:03:20 <Twey> Okay then
09:03:46 <Twey> I thought it was something mystical to do with rings.  :þ
09:04:06 <ben> At least that would solve the overload between function composition and module scope resolution
09:04:23 <ben> There is a ∷ symbol too!
09:04:57 <MoALTz> unicode must be horrific for censoring systems
09:05:04 <donri> http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
09:05:11 <donri> also http://hackage.haskell.org/trac/ghc/ticket/1102
09:05:43 <Twey> ben: Indeed.  GHC accepts it.
09:05:49 <Twey> (with the extension)
09:06:27 <ben> I am honestly more interested in purely visual substitution in my favourite editor, since I still will not be able to type those characters comfortably :)
09:06:49 <Twey> ben: Why not?
09:07:02 <donri> what system are you on
09:07:03 <Twey> Are you on a rubbish operating system where you can't tweak your keyboard layout?
09:07:20 <ben> I have lots of muscle memory for typing a . and pressing : twice, but none for whatever I tweak my keyboard layout to do
09:07:55 <mmmdonuts> Coding style question: in a module Network.Foo, should types with generic names like Connection, Result, Response be named FooConnection, FooResult etc. or should it be left up to the user to import qualified if they run into conflicts?
09:09:09 <Twey> ben: Well, that's a matter of practice
09:09:17 <Twey> You get used to it within an hour or so
09:09:28 <Lemmih> mmmdonuts: I'd do the latter.
09:09:35 <Twey> mmmdonuts: Leave it up to the user.
09:10:08 <lambdaf> @pl \a b -> sum $ take b $ repeat a
09:10:09 <Twey> import Network.Foo (FooConnection); FooConnection has no advantage over import qualified Network.Foo as Foo; Foo.Connection
09:10:09 <lambdabot> (sum .) . flip take . repeat
09:10:25 <mmmdonuts> Thanks, makes sense.
09:10:29 <Twey> The only difference is that if someone wants to import it qualified, they have to write Foo.FooConnection and suffer the redundancy.
09:11:07 <ben_m> Data.Numbers.primeFactors makes my system crawl :D
09:11:32 <MoALTz> :t Data.Numbers.primeFactors
09:11:33 <lambdabot> Couldn't find qualified module.
09:11:56 <ben_m> Got it from Hackage
09:12:40 <Twey> Lower-case package name?
09:12:50 <Twey> Er, module name?
09:13:10 <ben_m> It's a function in Data.Numbers
09:13:40 <MoALTz> appears to be http://hackage.haskell.org/packages/archive/primes/0.1.1/doc/html/src/Data-Numbers-Primes.html#primes
09:21:00 * programble is away: Fixing my spaceship
09:21:28 <ben> I still think the absence of points-free case expressions is the worst flaw of haskell >:[
09:22:03 <ben_m> I have that thought every day.
09:22:18 <koeien> if that is the worst flaw, we're doing pretty well :D
09:22:26 <ben> ben_m: great minds are named alike!
09:22:51 * hackagebot upload: hashed-storage 0.4.2 - Hashed file storage support code. (PetrRockai)
09:23:17 <SimonRC> ben: there are extensions
09:23:27 <SimonRC> I mean, to fix that
09:23:34 <donri> why are pointy case expressions so bad?
09:23:48 <c_wraith> I'm not so sure I can believe that the word "fix" is appropriate. :)
09:23:57 <ben> because the \x -> case x of is getting tiresome :(
09:27:18 <sinelaw> ben, how would you write point-free case expressions?
09:27:43 <ben> System.Environment.getArgs >>= caseOf ["foo"] -> doFoo ; ["bar"] -> doBar
09:28:05 <ben> or "case of" or "case _ of" or
09:28:44 <ben> SimonRC: Hmm, where?
09:28:44 <sinelaw> ah
09:30:18 <SimonRC> I don't know
09:30:35 <ben> I saw someone use a C preprocessor macro to that effect
09:30:49 <SimonRC> yeah, the ability to use >>= with case would be great
09:31:07 <chrisdone> ben: I'm always complaining that there wasn't a point free monadic case (and not doing anything about it)
09:31:38 <SimonRC> also being able to say "foo >>= if then x else y" would be nice
09:32:05 <chrisdone> SimonRC: that doesn't make sense
09:32:13 <ben> At least you can easily define a function that could look like foo >>= if'' x y
09:32:16 <chrisdone> SimonRC: what if you want to use the variable?
09:32:19 <SimonRC> foo :: IO bool
09:32:25 <SimonRC> ben: yeah
09:32:44 <SimonRC> chrisdone: which variable?
09:32:50 <chrisdone> the Bool
09:33:01 <ski> then you need to name it
09:33:05 <SimonRC> well in this case I don't want to
09:33:34 <SimonRC> this would supplement the existing if syntax, not replace it
09:35:25 <chrisdone> ..
09:35:26 <chrisdone> k
09:35:29 <ben> '#define case_of \caseof_detail -> case caseof_detail of'
09:35:41 <ben> Oh, well, I guess {-# LANGUAGE CPP #-} is not too much of a deal
09:36:36 * programble is back (gone 00:15:37)
09:37:13 <ski> programble : ty for letting us know
09:38:50 <programble> ski: its an xchat thing
09:39:34 <ski> (if you don't want it to do that, you can turn it off in the settings somewhere, iirc)
09:40:30 <SimonRC> aha:  http://hackage.haskell.org/trac/haskell-prime/ticket/41
09:40:37 <SimonRC> there it is
09:40:41 <SimonRC> it is only a proposal
09:40:56 * hackagebot upload: hashed-storage 0.4.3 - Hashed file storage support code. (PetrRockai)
09:47:33 <chrisdone> SimonRC: mmm. delicious
09:48:56 <chrisdone> SimonRC: seems like it could be added on without any conflicts?
10:01:02 <mathijs> I have a function that calls lots of other functions (that return strings) and puts them al together to a big string (using ++). This function is called from main and the result is written to disk. So no partial string is ever used. Now, I know about difference-lists, but I fail at understanding why they would help. Since the concatenation is fully performed in pure code (so no appending parts in IO), wouldn't laziness make sure no data
10:01:03 <mathijs>  is ever copied except for the final string?
10:01:30 <koeien371> ++ is linear in the size of the leftmost list
10:02:21 <mathijs> yeah, but in case of concatenating 20 lists, and just using that result (not the intermediate parts), will still be linear right?
10:02:28 <mauke> no
10:03:02 <mauke> (((x ++ a) ++ b) ++ c) ++ d will copy x 4 times
10:03:11 <koeien371> at least, traverse
10:03:22 <mathijs> why wouldn't laziness fix this?
10:03:48 <mauke> laziness only makes it copy the first character of x 4 times up front, then the second character, etc ...
10:04:11 <mauke> instead of fully constructing (x ++ a) = x', then fully constructing x' ++ b, etc
10:04:57 <sinelaw> sounds like you actualyl want it to be strict here
10:05:02 <aavogt> @src (++)
10:05:03 <lambdabot> []     ++ ys = ys
10:05:03 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:05:03 <lambdabot> -- OR
10:05:03 <lambdabot> xs ++ ys = foldr (:) ys xs
10:05:07 <koeien371> woudln't help
10:05:11 <mathijs> I don't see the need to make x ++ a into something new (ending at a's end), and then copying the new thing again, just to make the last node point to b. isn't the runtime able to see that the result of (x ++ a) is never used by itself?
10:05:28 <mauke> mathijs: it is used by ++ b
10:05:28 <ben> I get the idea that 'doesDirectoryExist "saveStore" >>= flip when (createDirectory "saveStore") . not' is not necessarily idiomatic
10:05:45 <aavogt> ben: use unless
10:05:56 <ben> I think I am just trying to create it and eating the exception :C
10:06:00 <mauke> ben: createDirectoryIfMissing
10:06:25 <ben> ... those crafty base developers think of everything
10:06:29 <mathijs> yeah, but just there. so there is no need to first create (x ++ a) and then copy that again just for making the last node point to b right?
10:06:34 <sjanssen> mathijs: what you're really asking for is for the compiler to prove that a ++ (b ++ c) is (a ++ b) ++ c, this is non-trivial
10:07:09 <mathijs> sjanssen, I guess that's what I'm after indeed.
10:07:35 <medfly> oh no! lambdabot stopped using Hascale!
10:07:47 <medfly> oh... it didn't
10:08:07 <mathijs> sjanssen, what if I newtype List and provide RULES saying (a ++ b) ++ c == a ++ (b ++ c) ?
10:08:28 <arcatan> somebody should just rewrite lambdabot in Java to prove that it's enterprise technology
10:08:46 <FunctorSalad> so what should functions like `whenM :: m Bool -> m a -> m a -> m a' be called properly?
10:08:47 <aavogt> @uptime
10:08:48 <lambdabot> uptime: 12d 23h 47m 24s, longest uptime: 1m 10d 23h 44m 29s
10:09:12 <FunctorSalad> someone pointed out that the `M' postfix is just for stuff which takes functions in the kleisli cat
10:09:14 <sjanssen> mathijs: that might work to some extent.  RULES are notoriously finicky
10:10:02 <sjanssen> FunctorSalad: who pointed that out?  What about eg. replicateM?
10:10:11 <FunctorSalad> @ty replicateM
10:10:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:10:25 <sjanssen> FunctorSalad: my understanding of the "M" suffix convention is that M merely stands for "monadic"
10:11:04 <FunctorSalad> sjanssen: but e.g. with mapM, the list input *isn't* monadic
10:11:08 <sjanssen> mathijs: the best thing is to fix your code by using a better datastructure, or associating your appends in the more efficient order
10:11:46 <FunctorSalad> @type \x y -> y >>= (\y0 -> mapM x y0)
10:11:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m [b]
10:11:54 <FunctorSalad> this would need a name too :)
10:12:05 <mathijs> sjanssen: well yeah I was going to a difference list anyway. not that performance matters in this case, just as an exercise. I just needed to understand why it would matter
10:13:04 <ben> How do you turn a CTime into a yyyymmdd-hhmmss string?
10:13:19 <sjanssen> mathijs: and you understand now?
10:13:24 <ben> I suspect Data.Time.Format can do what I want, but it does not appear to be taking CTimes
10:14:06 <FunctorSalad> sjanssen: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#3
10:14:12 <mathijs> sjanssen: I think it's coming :)   not fully, since ++ is right associative, I still don't fully see it, but doing some step-by-step on paper
10:14:43 <FunctorSalad> sjanssen: the posting was "replicateM should be called mreplicate?", Sjoerd Visscher
10:14:51 <sjanssen> FunctorSalad: that statement is easily disproved in that module
10:15:30 <FunctorSalad> do as Control.Monad says, not as it does ;)
10:15:50 <ben> mappend should be called appendM
10:16:06 <koeien371> no
10:16:16 <koeien371> why?
10:16:21 <ben> Why not?
10:16:25 <skorpan> mappend is monoid append, no?
10:16:35 <sjanssen> skorpan: yes
10:16:36 <koeien371> "monoid append"
10:16:42 <skorpan> i was under the impression that the M in e.g. mapM stands for monad
10:16:45 <koeien371> monoids are not always about appending
10:16:48 <sjanssen> we're referring to a different "m" in mappend :)
10:16:56 <Twey> I'd rather have mappend be called append and be imported qualified into the Prelude.  ☺
10:17:04 <Twey> Monoid.append
10:17:14 <sjanssen> Twey: you can't export qualified names
10:17:16 <koeien371> i think ++ is better
10:17:20 <FunctorSalad> koeien371: well, up to taking quotients they are ;)
10:17:23 <skorpan> koeien371: of course not, but i'm just saying...
10:17:24 <Twey> sjanssen: I'm being idealistic here.  :þ
10:17:45 <eivuokko> You can't=?  Pretty sure it used to work in ghc.
10:18:20 <koeien371> FunctorSalad: ah yes, now i see ;) but that's not how you normally think of a monoid like Z/6Z
10:18:30 <koeien371> maybe you do. but i don't :P
10:18:38 <FunctorSalad> koeien371: true
10:20:33 <skorpan> so what's the general argument against making (++) = mappend?  it's confusing to newcomers?
10:20:48 <koeien371> i guess so yes
10:22:14 <koeien371> i like the helium approach better in this case
10:22:17 <chrisdone> a very sad argument =(
10:22:32 <sjanssen> skorpan: my argument is that Haskell '98 isn't defined that way, and that we shouldn't make breaking changes to the Prelude without a standards process
10:22:34 <chrisdone> (same for map/fmap)
10:23:05 <nimred> cabal install xmonad --> error: gmp.h: No such file or directory
10:23:20 <dcoutts> nimred: your ghc isn't set up right then
10:23:26 <dcoutts> it should always be able to find gmp
10:23:31 <sjanssen> if (++) was generalized in Haskell '98, it would have been MonadPlus.  Monoids hadn't been discovered as a Haskell abstraction at that time
10:23:32 <chrisdone> nimred: install libgmp-dev (or such package from your distro)
10:23:34 <dcoutts> it needs it for more or less everything
10:23:40 <chrisdone> dcoutts: it needs the dev package, not the lib itself, I believe
10:23:56 <dcoutts> well, it needs both
10:24:09 <chrisdone> dcoutts: I mean the cause of that error... obviously
10:24:29 <nimred> chrisdone italready is :
10:24:35 <nimred> [~]->> find /usr/pkg -name gmp.h
10:24:36 <nimred> /usr/pkg/include/gmp.h
10:25:12 <nimred> from pkgsrc/devel/gmp
10:25:19 <dcoutts> is /usr/pkg/include a standard cpp search dir?
10:25:31 <dcoutts> will gcc find it?
10:25:44 <monochrom> libgmp3-dev
10:25:45 <nimred> dcoutts :
10:25:46 <nimred> [~]->> echo $C_INCLUDE_PATH
10:25:47 <nimred> /usr/include:/usr/pkg/include:/usr/pkg/include/xorg
10:26:04 <koeien371> monochrom: this is probably NetBSD
10:26:23 <monochrom> Darn all those other OSes I don't use! <duck>
10:26:24 <nimred> koeien371 monochrom it is
10:26:48 <mathijs> sjanssen: not getting there yet :(    since ++ is right-associative, won't "str1" ++ "str2" ++ "str3" become "str1" ++ ("str2" ++ "str3")? in that case wouldn't "str2" get copied first, having it's tail point at the original "str3"? and next step will copy "str1" and have it's tail point to the str2 copy?
10:27:08 <dcoutts> nimred: does that mean gcc will find it automatically, or does that mean you expect the build process to look at the $C_INCLUDE_PATH env var?
10:27:44 <koeien371> mathijs: why would "str2" get copied first?
10:27:46 <monochrom> mathijs: There is no copying.
10:27:50 <sjanssen> mathijs: the more likely evaluation order is that "str1" is copied, with it's [] replaced with ("str2" ++ "str3")
10:28:25 <mathijs> sjanssen, ah, outside-in evaluation. forgot about that
10:28:41 <nimred> dcoutts without setting C_INCLUDE_PATH, it didn't find. So itriedsetting it but didn't change anything :/
10:29:13 <dcoutts> nimred: I don't recognise C_INCLUDE_PATH as an env var that we pay any attention to
10:29:44 <monochrom> I guess that is called copying.
10:30:03 <dcoutts> nimred: if there's an include dir that you need ghc to always look in, then try modifying the package info for base or rts to use that include dir
10:30:10 <sjanssen> monochrom: you're right, it isn't quite copying, but it's close
10:30:24 <nimred> dcoutts wich way ?
10:30:42 <sjanssen> really xs ++ ys creates a new list identical to xs, except the [] is replaced with ys
10:30:59 <mathijs> sjanssen: now I get it. I keep on forgetting that associative direction only affects the result, not the evaluation order
10:31:24 <FunctorSalad> one problem I've found with functions that have their 'bind' included already is that there's a proliferation of possible combinations...
10:31:30 <FunctorSalad> (which arguments to 'bind' already)
10:32:13 <mathijs> sjanssen: so it's not just having some thunk in memory saying "this is xs with its [] changed to ys"?
10:32:33 <dcoutts> nimred: run, ghc-pkg rts describe > rts.pkg
10:33:07 <dcoutts> nimred: then edit the rts.pkg include-dirs entry to add the ones you need, then ghc-pkg update rts.pkg (that might need to be as root)
10:33:12 <nimred> dcoutts ? what'sthat command ?
10:33:36 <nimred> eh it creates an empty file !
10:33:48 <mathijs> sjanssen: I mean using insert on a Map doesn't create a copy of the map with the new element inserted, so why wouldn't ++ use this behavior?
10:34:02 <dcoutts> nimred: oh, sorry, ghc-pkg describe rts
10:34:22 <sjanssen> mathijs: using insert on a Map does actually "copy" parts of the map in much the same way that (++)
10:34:30 <sjanssen> does
10:34:51 <monochrom> After one step of evaluation: "str1" ++ y → 's' : ("tr" ++ y).
10:34:55 * SamB_XP wonders why, when he sees one of mozilla's XML error messages lately, he actually never sees a *message* anymore ... just a yellow page with a nasty red-outlined rectangle across the top where the message should be ...
10:35:08 <Saizan_> the difference is that Map is a tree, so you can share more of the structure
10:35:27 <nimred> dcoutts what syntax for multipledirs ? where do rts.pkg have to be ?
10:35:28 <Saizan_> you only need to "copy" a single path
10:35:35 <nimred> to be saved ?
10:35:51 <dcoutts> nimred: as I said, ghc-pkg update rts.pkg; rm rts.pkg
10:36:05 <zygoloid> mathijs: due to immutability, if you update a data structure, then any parts of that from which the 'updated' region is visible must be recreated.
10:36:19 <monochrom> After a few more steps: 's':'t':'r':'1' : y.  up to now y is untouched.
10:36:20 <nimred> dcoutts syntax formultipledirs ?
10:36:54 <dcoutts> nimred: space or , I'll tell you if it's wrong when you re-register
10:37:02 <dcoutts> I'll / it'll :-)
10:37:03 <ben> @pl \x -> not `fmap` doesFileExist x
10:37:04 <lambdabot> (not `fmap`) . doesFileExist
10:37:08 <dcoutts> ghc-pkg will complain if it's wrong
10:37:11 <ben> Oh. Duh.
10:38:39 <ben> head `fmap` filterM ((not `fmap`) . doesFileExist) possibleNames -- does not appear to work because filterM is obviously too strict, is there a clever way around that
10:39:31 <netinho2lol> sup haskell crew
10:39:34 <nimred> dcoutts ok looks like working. Butstill doesn't understand why did i have to do this. Other timesi installedxmonad i didn't have to change settings.
10:39:37 <ben> Err, possibleNames is an infinite list of "foo", "foo-2", "foo-3", ...
10:39:44 <netinho2lol> any data experts here?
10:39:46 <dcoutts> nimred: did you change ghc since last time?
10:39:51 <mathijs> well, I was under the impression that laziness and the runtime would help with these issues. I do understand that to "modify" a datastructure, only the "spine" needs to be changed, so having a more intelligent spine like a tree makes sure bigger parts can be reused. But I also thought that the compiler would know that a certain outcome is never used again, so it could safely modify it.
10:39:52 * ddarius hates `fmap`
10:39:56 <netinho2lol> data construction experts, that is :P
10:40:00 <dcoutts> nimred: or change other bits of the system perhaps
10:40:06 <nimred> sorry for bad typing ( i have a problem with my space bar)
10:40:19 <sjanssen> mathijs: GHC at least never modifies a structure in place
10:40:29 <nimred> dcoutts i didn'tchange anything
10:40:33 <dcoutts> nimred: it's not really about configuring ghc or xmonad, it about having the right build environment that ghc needs, which includes gmp
10:40:49 <sjanssen> (barring explicitly mutable stuff like IORef, mutable arrays, etc.)
10:40:54 <dcoutts> something must have changed, ghc has needed gmp for ever
10:42:43 <gwern> 'Multi-prompt delimited control in R5RS Scheme, a version of delimcc in Scheme. The specialization of the code yields a new implementation of the ordinary shift/reset in R5RS Scheme, which is memory efficient even if the underlying call/cc copies the whole stack.'
10:42:46 <gwern> that oleg
10:43:09 <monochrom> hehe nice!
10:43:36 <netinho2lol> anyone knows how to ^L in ghci?
10:43:48 <netinho2lol> (clear screen)
10:43:59 <mathijs> sjanssen: ok, then it's all a lot clearer. so inserting to a Map will instantly create a new Map reusing the branches that won't change. But I guess it's not creating the new one in full yet, right? it will do this when certain branches are accessed again
10:44:10 <gerard_> lazy bytestrings don't support "isInfixOf"??? what would be the best way to search them?
10:44:59 <ski> ddarius : you prefer `<$>' ?
10:45:32 <Asztal> netinho2lol: ^L works for me
10:45:42 <Asztal> netinho2lol: what about ":! clear"?
10:45:57 <gwern> gerard_: there's http://hackage.haskell.org/packages/archive/bytestring/0.9.1.5/doc/html/Data-ByteString.html#v%3AisInfixOf but I've never been clear on how all the bytestrings worked
10:46:54 <sjanssen> mathijs: yes, the new branches would be replaced by thunks that are evaluated whenever they're forced by seq or case
10:46:56 <netinho2lol> Asztal: thanks for the reply
10:47:02 <netinho2lol> your last command works
10:47:04 <Saizan_> ben: there aren't combinators for monadic shortcutting loops in the stdlibs, so you either write out the recursion or use something like ErrorT and throwError
10:47:08 <netinho2lol> ^L doesn't work here
10:47:18 <Asztal> netinho2lol: what version of GHC is this?
10:47:19 <ben> Error? :S
10:47:29 <netinho2lol> the one in Ubuntu Karmic
10:47:33 <gerard_> gwern: yeah, but take a look at the *lazy* one: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.5/doc/html/Data-ByteString-Lazy.html#16
10:47:51 <c_wraith> Hmph.  Well.  That worked.  I'm sort of amazed...  But very happy.  I now have (for uu-parsinglib) pEof :: Eof st => P st ()
10:47:55 <gwern> data.bytestring isn't the strict or lazy, I thought
10:48:07 <gwern> just something higher, abstract over both, or something
10:48:08 <netinho2lol> Asztal: Glasgow Haskell Compiler, Version 6.10.4, for Haskell 98, stage 2 booted by GHC version 6.10.4
10:48:58 <c_wraith> The only real difference between pEof and pEnd is that pEof doesn't swallow the error state, so it can be used multiple times in conditional matches.
10:48:59 <Asztal> netinho2lol: Odd. Mine's the same version.
10:49:16 <Saizan_> gwern: the Data.ByteString module works only on the strict ones
10:49:34 <netinho2lol> Asztal: something's going on, then :P
10:49:36 <ksf> hm I probably should write some TH magic that can generate all possible permutations derivable by replacing parts of the program with given alternative implementations and benchmark them all against each other.
10:50:05 <netinho2lol> brb, walking dog
10:50:28 <ksf> or I'm just pissed because I completely deleted the implementation and now it seems to be feasable, again.
10:53:54 <saml> h
10:54:27 <saml> do you like algebraic data types?
10:54:38 <Saizan_> we do!
10:55:10 <c_wraith> I feel like that's some sort of setup for a joke, like asking "is your refrigerator running?"
10:55:32 <skorpan> i'm not too keen on them
10:55:34 <mathijs> sjanssen: so in the case of 'take 4 ("str1" ++ ("str2" ++ "str3"))'? won't the first ++ just create a thunk at "str1"s [] that never gets evaluated?
10:55:59 <mathijs> sjanssen: thus only copying "str1" once ?
10:56:45 <ben> Is there a faster way to get the n highest values than take n . reverse . sort?
10:56:52 <ski> mathijs : yes
10:57:06 <saml> data Foo = Bar (Map String Foo)   is this good?
10:57:07 <ski> but that happens if the whole of `"str1" ++ ("str2" ++ "str3")' is forced, too
10:57:08 <c_wraith> ben: look up "order statistics"
10:57:21 <saml> so that i can add new data any time
10:57:27 <ski> (as opposed to `("str1" ++ "str2") ++ "str3"')
10:57:28 <ben> thank you
10:57:32 <Saizan_> mathijs: without fusion it'll copy it twice, once by ++ and once by take 4, though each cell produced by ++ is immediately inspected by take, so it can be garbage collected
10:58:03 <Saizan_> assuming you fully evaluate the result of that expression
10:58:28 <ksf> are there any attempts on making avg xs = sum xs / length xs traverse the list only once, automatically?
10:58:32 <ksf> (just curious)
10:59:08 * ski str some monad(?) for single-pass traversals
10:59:12 <copumpkin> only by explicitly composing folds
10:59:18 <copumpkin> it works as an arrow
10:59:23 <Saizan_> pejo is working on supercompilation in ghc, maybe that covers it
10:59:24 <ski> ok
10:59:30 <mathijs> ok, so if I take 5, it will evaluate the thunk left by the first ++, which will just copy 1 char from "str2"... so if I continue, all characters are just copied once.
10:59:33 <medfly> @leet . nixon
10:59:33 <lambdabot>   Parse error: VarSym "."
10:59:36 <medfly> how does that work?
10:59:42 <copumpkin> taejo did something for it a while back, then I expanded it some more, and edwardk went crazy
10:59:53 <copumpkin> http://comonad.com/haskell/Origami.hs
11:00:00 <ski> mathijs : yes (except `take' itself copies the cons cells one more time)
11:00:52 <ski> medfly : apparently it spell-corrects `leet' to `let'
11:01:00 <ksf>    there's no code left if you leave out the instances!
11:01:05 <ski> @let . nixon
11:01:06 <lambdabot>   Parse error: VarSym "."
11:01:34 <medfly> oh
11:01:38 <mathijs> ski: yeah, so if I leave out take, and just write the result to disk or something, it will result to every character in all 3 strings just being copied once. And if I take 4 strings, it's still linear. but that's not what I read everywhere. ++ is supposed to be quadratic. still not getting it :(
11:01:52 <medfly> thanks
11:02:23 <medfly> @. elite nixon
11:02:23 <lambdabot> I 8e1IE\/3 in tHE b4T7LE-wh3+|-|3R It'z0rz TH3 8A7TL3 Of A (4MPAIgN Or +He b4+tle oph THiz0rz 0FFIcE, \/\/HI(|-| iz0rz A cOntiNuING 84+7le.
11:03:44 <copumpkin> ksf: yeah, but it's pretty awesome stuff :)
11:04:33 <ski> mathijs : `xs0 ++ (xs1 ++ (xs2 ++ xs3))' copies each cons cell once, while `((xs0 ++ xs1) ++ xs2) ++ xs3' copies the cons cells in `xs0' thrice, those in `xs1' twice, and those in `xs2' once (and those in `xs3' nonce')
11:04:56 <copumpkin> mmm, thrice
11:04:58 <ski> mathijs : it's the left-associated `((xs0 ++ xs1) ++ xs2) ++ xs3' form which is "dangerous"
11:05:04 <copumpkin> @let thrice f = f . f . f
11:05:05 <lambdabot>  Defined.
11:05:12 <ski> @let nonce f = id
11:05:13 <lambdabot>  Defined.
11:05:19 <copumpkin> :t thrice thrice
11:05:20 <lambdabot> forall b. (b -> b) -> b -> b
11:05:22 <ski> (better name ?)
11:05:26 <copumpkin> :t thrice thrice thrice
11:05:28 <lambdabot> forall b. (b -> b) -> b -> b
11:05:35 <copumpkin> > thrice thrice thrice (+1) 1
11:05:37 <lambdabot>   * Exception: stack overflow
11:05:45 * ski grins
11:05:50 <copumpkin> > thrice thrice thrice (1:) []
11:05:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:05:57 <copumpkin> > length (thrice thrice thrice (1:) [])
11:06:01 <lambdabot>   mueval-core: Time limit exceeded
11:06:04 <copumpkin> lol
11:06:24 <ski> > twice twice twice twice succ 0
11:06:26 <lambdabot>   65536
11:07:39 <Philonous> > 3 ^^ 27
11:07:40 <lambdabot>   7.625597484987e12
11:07:46 <copumpkin> :)
11:07:59 <medfly> ^^?
11:08:00 <copumpkin> is it really that big?
11:08:09 <Philonous> > 3 ^^ (3 ^^ 3)
11:08:10 <lambdabot>   Ambiguous type variable `t' in the constraints:
11:08:11 <lambdabot>    `GHC.Real.Integral t'
11:08:11 <lambdabot>   ...
11:08:22 <copumpkin> > 3 ^ (3 ^ 3)
11:08:23 <lambdabot>   7625597484987
11:08:48 <mathijs> ski: ++ is right-associative by default. so I don't really see that danger. Or is it just in IO? if I do { a <- headers; b <- body; return (a ++ b) }, will that force a to be evaluated?
11:08:55 <ski> mathijs : so to clarify, `(++)' isn't quadratic at all (it itself), it is linear. but `((..((xs_0 ++ xs_1) ++ xs_2)..) ++ xs_n_2) ++ xs_n_1' is quadratic in `n' (the number of lists)
11:09:31 <ski> mathijs : the danger is if you say things like `reverse [] = []; reverse (x:xs) = reverse xs ++ [x]', here the left-associated calls are hidden in the recursion
11:09:59 <Daimonic> Did you know, foldl is turing-complete?
11:10:00 <ski> mathijs : `reverse [0,1,2,3]' expands to `((([] ++ [3]) ++ [2]) ++ [1]) ++ [0]'
11:10:04 <ski> see the problem ?
11:10:32 <mathijs> ski: http://www.haskell.org/haskellwiki/Difference_list tells otherwise . Your explanation makes sense to me and it's also what I thought, but I can't figure out what the wiki thing is trying to tell me then.
11:10:46 <ski> difference lists is one way to solve this problem, yes
11:10:58 <ski> accumulator is another (related) one
11:11:46 <ski> the difference list version of `reverse' is
11:12:01 <ski>   reverse xs = reverseDL xs []
11:12:11 <ski>   reverseDL [    ] = id
11:12:25 <ski>   reverseDL (x:xs) = reverseDL xs . (x:)
11:12:42 <mathijs> ski: the wikipage isn't reversing any lists, just concatenating 3. Can you please look at that page and look at the first paragraph after "L-T-R gives" ?
11:12:56 <ski> `reverse' is just an example
11:13:23 <kane77> hi, I just started learning haskell.. how long does it take until I can say "I get it!"? :)
11:13:25 <mathijs> ski: the page tells me that "111" ++ "222" ++ "333" will copy "111" twice.
11:13:35 <koeien371> kane77: depends
11:13:37 <koeien371> noone knows
11:13:46 <kane77> :)
11:13:52 <ski> mathijs : where ?
11:14:31 <ski> i don't see that
11:15:04 <mathijs> ski: #   (show L) ++ (show T ++ (show R))  -> #   ((show LL) ++ (showLT ++ (show LR))) ++ (show T ++ (show R))  -> (((show LLL) ++ (show LLT ++ (show LLR))) ++ (show LT ++ (show LR))) ++ (show T ++ (show R))
11:15:36 <ski> note that the second expression there is of the form `((...) ++ (...)) ++ (...)'
11:15:53 <ski> (and also the third one)
11:16:22 <ski> i.e. `show L' there expands to `((show LL) ++ (showLT ++ (show LR)))'
11:16:30 <mathijs> yeah, but I don't see how they got from the first to the second. we just agreed it would be linear, because their example (first expression) is right associative.
11:17:14 <ski> in their example `L' is a tree containing `LL' as left child, `LT' as element in the `L' node, and `LR' as right child
11:17:34 <mathijs> oops.... didn't see about the tree. thanks :)
11:17:49 <ski> and this `L' is a subtree to the overall tree
11:18:09 <gerard_> so I just used the plain ByteString, seems to work ok
11:18:30 <netinho2lol> back
11:18:37 <ski> the left-nested (as well as right-nested) structure of the tree is translated to a corresponding recursion structure which generates an expression with both left- and right-nested calls to `(++)'
11:18:47 <ski> it's the left-nested calls that are a problem
11:19:09 <netinho2lol> Asztal: other thinks that don't work are 'Home' and 'End'
11:19:15 <netinho2lol> *things
11:19:16 <ski> mathijs : do you understand how difference lists (or accumulating style) solves the problem ?
11:19:41 <mathijs> ski: ok, in that case the example makes more sense. I was under the impression that LL was some kind of copy of L.
11:20:05 <ski> probably that page could be a bit more clear about `L', e.t.c.
11:20:25 <ski> (`L' isn't even a valid identifier for any tree value)
11:20:50 <mathijs> ski: well I did understand how difference lists solved the problem. Just couldn't figure out the problem in case of simple list concatenation. turns out there isn't any, as long as I make sure everything is right-associative.
11:21:02 <ski> right
11:21:03 <ben> @pl \x -> x /= "." || x /= ".."
11:21:04 <lambdabot> liftM2 (||) ("." /=) (".." /=)
11:21:30 <ben> ... doh
11:21:48 <ski> the catch is that calls to other functions (in particular recursion, mutual or otherwise), can hide left-nesting, if you're not careful to watch out for it
11:21:54 <gwern> http://www.rebol.com/oneliners.html <-- there's something extremely comical about these
11:21:55 <copumpkin> not . (`elem` [".", ".."])
11:22:02 <copumpkin> :t notElem
11:22:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:22:05 <copumpkin> or that
11:22:06 <ben> but elem is O(n)!!
11:22:11 <ben> Point taken :>
11:22:26 <copumpkin> notElem stops as soon as it finds something
11:22:46 <gwern> in rebol, you can write the monty hall challenge in half the characters of popping a stack?
11:22:49 <gwern> wtdf
11:24:00 <cads> hey, what's the channel for offtopic #haskell-rejects?
11:24:13 <koeien371> #haskell-blah iirc
11:24:32 <mathijs> ski: thanks for explaining. I fully get it now. I just didn't read the text on the wiki (and in RWH about this subject) well enough. it's all in associativity.
11:24:42 <cads> thanks koeien
11:25:07 <ski> mathijs : and do you understand why accumulating style also solves it (and how that relates to difference lists) ?
11:27:17 <mathijs> ski: well, still figuring out the differences between acc and diff. acc seems to be even faster. But they seem very much the same conceptually.
11:29:10 <ski>   show  Empty       = ""
11:29:41 <ski>   show (Node l x r) = "(" ++ show l ++ show x ++ show r ++ ")"
11:29:54 <ski> with difference lists becomes
11:30:04 <ski>   show t = shows t ""
11:30:13 <ski>   shows  Empty       = id
11:30:32 <Absolute01> Which library includes scan1?
11:30:43 <donri> @hoogle scan1
11:30:43 <lambdabot> No results found
11:30:52 <koeien371> @hoogle scanl1
11:30:53 <Absolute01> i am running ghci on windows, it doesn't seem to be loaded at startup.
11:30:53 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
11:30:54 <lambdabot> Data.ByteString scanl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> ByteString
11:30:54 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
11:30:55 <koeien371> did you mean this?
11:31:00 <ski>   shows (Node l x r) = ('(':) . shows l . shows x . shows r . (')':)
11:31:10 <Absolute01> scanl1 huh?
11:31:14 <ski> while the accumulating style is
11:31:15 * Absolute01 tres
11:31:21 <donri> oh that's gotta be sneaky with some fonts
11:31:23 <ski>   show t = shows t ""
11:31:35 <ski>   shows  Empty       acc = acc
11:31:53 <ski>   shows (Node l x r) acc = '(' : (shows l (shows x (shows r (')': acc))))
11:32:33 <ski> mathijs : so it's just a matter of either doing the tree recursion before `acc' is accepted, or after it is
11:32:57 <mathijs> ski: http://gist.github.com/234713
11:33:18 <Twey> Wow.  '(':) . shows l . shows x . shows r . (')' — invalid character literal!
11:33:45 <Twey> donri: What's that?
11:33:59 <donri> Twey, hm?
11:34:04 <Asztal> netinho2lol: I used to have problems with Home and End not working, but that stopped for me when GHCi started using Haskeline instead of editline
11:34:07 <Twey> 19:31:05 < donri> oh that's gotta be sneaky with some fonts
11:34:26 <donri> Twey, not with my fonts, but i suspect scanl1 may look like scan11 or scanll on some fonts
11:34:35 <Twey> Ah, heh
11:34:37 <Twey> SEP :þ
11:34:43 <donri> ki'a
11:34:49 <Twey> Someone Else's Problem
11:34:55 <donri> yea :)
11:35:03 <donri> if your font sucks, so do you
11:35:06 <Twey> ‘foldr’ can look like ‘map’ in a sufficiently stupid font, too
11:35:08 <Twey> Hear hear :þ
11:35:16 <donri> haha
11:35:20 <donri> quite a stretch ;)
11:35:35 <Twey> Oh, there's a font on my system in which everything is just a line
11:35:50 <ski> mathijs : try with an incremental `rpartition', too
11:35:53 <benmachine> are any of the class instances for Reader any different from the ones for ((->) r)?
11:36:04 <Twey> benmachine: Isn't Reader a type synonym?
11:36:09 <benmachine> it's a newtype
11:36:13 <Twey> Oh, okay
11:36:32 <ski> benmachine : they shouldn't be, in any case
11:36:47 <benmachine> ski: I'm just kind of curious why it *isn't* a type synonym, in that case
11:37:34 <ski> benmachine : to avoid getting funny types (or type errors later), instead of getting type errors immediately, id you mix up argument order or forget arguments (or have too many) ?
11:37:45 <ski> s/id/if/
11:37:52 <benmachine> hmm
11:38:12 <chrisdone> Twey: even space?
11:38:28 <benmachine> hey, and ReaderT is basically Kleisli only with the arguments in a different order
11:38:36 <ski> also, you might want to be aware of the places in the code where you actually use the environment (i.e. using `ask', `asks', `local' and such)
11:38:51 <benmachine> you can still do that
11:38:54 <benmachine> ask = id :P
11:39:14 <ski> yes, but you might accidentally use the environment without using any of those
11:39:30 <benmachine> hmm
11:39:34 <ski> (or if you're (v)grepping the source for places in which the environment is used, say)
11:39:44 <benmachine> I see your point, I think
11:39:48 <chrisdone> daw. I got yogurt in my beard
11:39:51 <ski> it's a trade-off
11:39:57 <Twey> chrisdone: Don't remember
11:40:02 <Twey> chrisdone: Perfect reason to shave :þ
11:40:08 <benmachine> like, x <- succ is valid in a function do-block but not a Reader do-block
11:40:16 <ski> sometimes you would use environment so often so `Reader (r ->)' is appropriate
11:40:17 <chrisdone> Twey: perfect reason not to eat yogurt amirite
11:40:30 <ski> (and some cases are simple `pl'-like uses)
11:40:39 <Twey> But yoghurt isn't the only thing that gets stuck in beards :þ
11:40:54 <chrisdone> Twey: insert mother joke here
11:40:59 * Twey laughs.
11:41:09 <ski> > join (liftM2 (,)) [0,1,2]  -- e.g.
11:41:09 <monochrom> your mother laughs
11:41:10 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
11:41:48 <chrisdone> what's better, liftA2 or liftM2 for (&&)?
11:41:57 <ski> benmachine : yes, so in that case, `x <- Reader succ'
11:42:07 <ski> chrisdone : depends
11:42:25 <Twey> liftA2 is more general, no?
11:42:32 * benmachine notices that although Kleisli has the same form as ReaderT, they aren't interchangeable because of the parameter order
11:42:36 <ski> do you already need a monad ? in that case, i'd say `liftM2' until `Applicative' is a superclass of `Monad'
11:42:37 <Twey> You can Kleisli it up
11:42:44 <Twey> Oh wait
11:42:48 <Twey> Applicatives, not arrows
11:42:53 <Twey> Damn, I hate that
11:43:17 <chrisdone> ski: ``until''? will it someday be a superclass?
11:43:20 <ski> otherwise `liftA2' unless you want a monad anyway, for some reason (or don't want to depend on monads separatedly being made instances of `Applicative')
11:43:25 <Saizan_> benmachine: they also work quite differently if used with the given combinators
11:43:28 <ski> chrisdone : well, hopefully .. :)
11:43:37 <Twey> Almost certainly.
11:43:37 <benmachine> Saizan_: hmm?
11:44:29 <benmachine> Saizan_: they're not in any of the same typeclasses?
11:44:43 <ski> (benmachine : also, there is no transformer version of `(r ->)')
11:45:04 <BONUS> ski: ReaderT?
11:45:04 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
11:45:32 <SamB_XP> Twey: Arrow isn't going to be a superclass of Monad ;-P
11:45:34 <chrisdone> when is the reader monad actually useful?
11:45:40 <benmachine> ski: I was thinking about that which is why I noticed ReaderT is similar to Kleisli
11:45:41 <ski> BONUS : that the transformer version of `Reader r', yes .. but there's no "light-weight" variant
11:45:44 <Saizan_> benmachine: they aren't, because Kleisli m a b is not about keeping an enviroment of type 'a' around, it's about composing functions, so the result of one is the input of the other etc..
11:46:09 <benmachine> Saizan_: I suppose that makes sense
11:46:22 <BONUS> ski: true that. type lambdas would be awesome for that
11:46:29 <monochrom> The Reader monad is useful when I have a bunch of STRef's I want to use across several procedures.
11:46:37 <ski> chrisdone : when you're distributing some environment/configuration through a computation, and only seldom need to reference it, and especially (locally) change it
11:47:06 <chrisdone> I mean the reader monad, not the Reader monad.. the other one
11:47:24 <ski> oh `(r ->)' ?
11:47:27 <chrisdone> yeah
11:47:33 <chrisdone> that's what it's called, right?
11:47:48 <mathijs> ski: sorry, got a phonecall... what do you mean by "incremental rpartition" ?
11:47:59 <benmachine> chrisdone: I did this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12144#a12144
11:48:01 <BONUS> chrisdone: reader is really useful here http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
11:48:13 <benmachine> (which technically I could have done with applicative, but this way is more readable imo)
11:48:39 <ski> i call `Reader r' "(heavy-weight) (`r')-environment monad", so i might call `(r ->)' "light-weight (`r')-environment monad"
11:49:33 <ski> mathijs : your current `rpartition' is tail-recursive, hence it is monolithic : `go' must traverse the whole input list to its end before any result is available for use
11:49:33 <chrisdone> ski: that's quite length. The Algorithmic Language Scheme™
11:49:35 <monochrom> The (r->) monad is useful when I want to write "fmap" for "."
11:49:48 <chrisdone> benmachine: let me ready it..
11:49:50 <maartenm> where do I go for distributed haskell?
11:49:54 <ski> monochrom : hehe
11:50:01 <copumpkin> maartenm: to the future
11:50:06 <maartenm> googling it kind of results in a deserted feeling
11:50:13 <maartenm> heh
11:50:46 <maartenm> and erlang + haskell ports?
11:50:59 <ski> mathijs : an incremental `rpartition' would have a recursive clause something like `rpartition p (x:xs) = ..ts..fs.. where (ts,fs) = rpartition p xs'
11:51:11 <maartenm> nm found something.. Foreign.Erlang
11:51:27 <maartenm> cool
11:52:00 <ski> mathijs : where `..ts.fs..' decides what to return (e.g. with guards as you did), and then returns a pair of two lists, constructed from `ts',`fs'
11:52:47 <ski> mathijs : so if `x' should be in the left list, then you return `(x:ts,fs)', so that the caller of `rpartition' can use `x' before `ts' and `fs' have been computed
11:53:12 <chrisdone> benmachine: oh, I get it. that's nifty
11:53:36 <mathijs> ski: cool, I get it...  lemme think about the implementation
11:53:38 <benmachine> nifty is an excellent description
11:53:39 <ski> (mathijs : note that this will reverse the order of the two returned lists, though)
11:54:09 <chrisdone> > (do x < (+1); y <- (*3); return (x+y)) 5
11:54:10 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
11:54:10 <lambdabot>  but its type `SimpleReflect....
11:54:16 <chrisdone> :(
11:54:31 <ski> > (do x <- (+1); y <- (*3); return (x+y)) 5
11:54:32 <lambdabot>   21
11:54:35 <benmachine> heh
11:54:40 <chrisdone> what did I miss? @_@
11:54:45 <ski> s/</<-/
11:54:46 <benmachine> a -
11:54:50 <chrisdone> oh, derp
11:54:53 <chrisdone> :D
11:55:04 <chrisdone> nice
11:55:09 <chrisdone> I will use that in future
12:02:18 <chrisdone> > ((+) <$> (*2) <*> (+2)) 5
12:02:19 <lambdabot>   17
12:02:25 <chrisdone> well bugger me
12:02:47 <Badger> @src (<*>)
12:02:47 <BONUS> > (liftM2 . liftM2) (,) take drop 3 "heeeeeeeeeeeeeee"
12:02:47 <lambdabot> Source not found. My mind is going. I can feel it.
12:02:48 <lambdabot>   ("hee","eeeeeeeeeeeee")
12:03:30 <chrisdone> BONUS: suave
12:03:54 <chrisdone> :t (liftM2 . liftM2)
12:03:55 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
12:04:20 <chrisdone> :t (liftM2 . liftM2) (,)
12:04:20 <mathijs> ski: it takes a lot longer now (25%)
12:04:21 <lambdabot> forall (m :: * -> *) a1 a2 (m1 :: * -> *). (Monad m, Monad m1) => m (m1 a1) -> m (m1 a2) -> m (m1 (a1, a2))
12:04:45 <mercury^> > (take, drop) <$> 3 <*> "heeeeeeee"
12:04:46 <lambdabot>   Couldn't match expected type `a1 -> a -> b'
12:04:47 <lambdabot>         against inferred type `...
12:05:07 <BONUS> you can view a function that takes two parameters as a monad in a monad
12:05:08 <BONUS> m (m a)
12:05:15 <chrisdone> yeah. two r's?
12:05:20 <BONUS> ya
12:05:44 <chrisdone> mmm
12:06:15 <netinho2lol> BONUS: you're the learn you a haskell guy?
12:06:27 <chrisdone> BONUS, of LYAH fame
12:06:29 <BONUS> guilty as charged
12:06:45 <netinho2lol> cool site, brother
12:06:50 <BONUS> thanks bro!
12:06:54 <netinho2lol> thanks for making it!
12:07:03 <BONUS> haha glad to be of service
12:07:05 <maartenm> yeah, thanks
12:07:07 <mathijs> thanks even more for completing it :P
12:07:12 <BONUS> lol
12:07:23 <chrisdone> yeah thanks bonus :p
12:07:23 <MacCoaster> i guess listenOn doesnt listen on all IPs?
12:07:39 <BONUS> im a lazy bugger yeah. im finishing it soon, rly busy now with going over the prev chapters with my editor for print
12:08:21 <wagle_> hi, if cabal chokes upgrading happstack-util, what do you do?  (at unconference, i'm a bit distracted)
12:08:34 <chrisdone> MacCoaster: it uses iNADDR_ANY -- isn't that all IPs, IIRC?
12:08:35 <mathijs> it's gonna be printed? cool, I will but a copy for sure. are your drawings in it too? :)
12:08:57 <BONUS> yup yup
12:08:59 <MacCoaster> chrisdone: i would think it'd use all IPs but it seems to refuse connection if its not localhost
12:09:28 <chrisdone> MacCoaster: the hostname localhost, or the 127.0.0.1 too?
12:09:29 <ski> (mathijs : is there a link ?)
12:09:41 <mathijs> ski: coming up
12:10:01 <MacCoaster> chrisdone: it just loads when i use localhost, rather than 127.0.0.1
12:10:10 <MacCoaster> which is.. strange :\
12:10:38 <chrisdone> mm yeah
12:10:40 <c_wraith> is localhost resolving to a different address for you?
12:10:41 <SamB_XP> try ::1
12:11:10 <MacCoaster> firefox blocks ::1 apparently, hah
12:11:18 <SamB_XP> hmm, oh, right
12:11:27 * MacCoaster rolls eyes
12:11:27 <SamB_XP> I think you need a wierd syntax to use that in a URL
12:11:56 <SamB_XP> not because of blockage -- just because the colons are used for port numbers in URIs
12:12:08 <SamB_XP> or, well, URLs anyway
12:12:13 <netinho2lol> fffffffuuuuuuuuuuuu :P
12:12:36 <MacCoaster> SamB_XP: eh not important now, i'll bug about it later
12:12:37 <netinho2lol> I'm making this -> type Image = [String]
12:12:40 <MacCoaster> thanks though guys :)
12:12:49 <chrisdone> > ord ':'
12:12:49 <lambdabot>   58
12:12:59 <netinho2lol> but I think that due to what the teacher requests, it has to be a data thingie
12:13:24 <mathijs> ski: http://gist.github.com/234732
12:14:14 <SamB_XP> http://tools.ietf.org/html/rfc2732 may be of interest ?
12:14:39 <chrisdone> spec drop
12:14:45 <SamB_XP> hmm, oh, it's obsoleted by http://tools.ietf.org/html/rfc3986 ...
12:15:15 <SamB_XP> chrisdone: what? I'm just saying, I can't remember the syntax either and this is what I've found in my googling so far ;-P
12:15:58 <SamB_XP> okay, you just stick it in square brackets, according to section 3.2.2 of RFC 3986
12:16:01 <netinho2lol> can anyone provide me an example of a 'data' thingie with Show?
12:16:52 <c_wraith> data Foo = Bar | Baz deriving Show
12:18:08 <netinho2lol> c_wraith: then I have to instance my show, right?
12:18:08 <ski> mathijs : ok
12:18:29 <c_wraith> netinho2lol: No, deriving does that automatically.  Did you want an example of doing it manually?
12:19:09 <mathijs> ski: interesting.... -O2 takes 1.75s off from append & accum, but 5.75s from compose. on the incremental version that is. now gonna run it on the original one
12:19:14 <netinho2lol> c_wraith: I'm using a list of strings
12:19:28 <netinho2lol> and I wanted to append an "\n" in the end of everyline
12:19:51 <ski> mathijs : if you feel like, you can ask on the mailing-list about comparision and optimization of these
12:20:17 <ski> mathijs : also, you could do a similar test for merge-sort (either bottom-up or top-down (or both))
12:21:42 <mathijs> ski: well I'm not after optimization. Just trying to comprehend the results. it seems that when using optimizations, composition is about the same as accumulation.
12:21:46 <wagle_> are my messages getting through?
12:21:54 <ski> yes
12:21:57 <MoALTz> that haskell bot tutorial seems interesting
12:21:58 <c_wraith> netinho2lol: ok, a simple example of creating a show instance manually:     data Foo = Foo Int             instance Show Foo where show (Foo i) = "something silly"
12:22:52 <c_wraith> netinho2lol: You could use the value of i in the expression, too.  maybe this is a better example
12:23:16 <c_wraith> netinho2lol: ok, a simple example of creating a show instance manually:     data Foo = Foo String             instance Show Foo where show (Foo s) = "something silly :" ++ s
12:24:17 <copumpkin> wagle_: are you there?
12:24:35 <copumpkin> wagle_: where'd you go??
12:24:38 <netinho2lol> c_wraith: thank you! I'm going to try this and feedback in a minute
12:32:42 <netinho2lol> c_wraith: I think it worked :D
12:34:58 <EvanCarroll> how come (,5) 5 doesn't work?
12:34:59 <lambdabot> EvanCarroll: You have 1 new message. '/msg lambdabot @messages' to read it.
12:35:36 <ddarius> , isn't an operator
12:35:37 <lunabot>  luna: Not in scope: `isn't'
12:35:46 <netinho2lol> uhm
12:35:59 <EvanCarroll> what is ,
12:36:04 <ddarius> Syntax.
12:36:05 <netinho2lol> love?
12:36:35 <EvanCarroll> god haskell is bloated.
12:36:48 <netinho2lol> haskell is huge ~~
12:38:12 <Cale> EvanCarroll: It *will* work, soon.
12:38:28 <Cale> EvanCarroll: When 6.12 comes out, that's a little something that got added.
12:38:38 <EvanCarroll> soo (,) will be an infix function?
12:38:40 <MoALTz> don't worry - scheme is trying to beat it based on the ballooning size of the rnrs
12:38:53 <Cale> EvanCarroll: Not quite, but you'll be able to section it like that
12:39:12 <Cale> EvanCarroll: You can't treat , as an infix operator, because it's part of many bits of syntax
12:39:33 <EvanCarroll> hrm
12:40:19 <Cale> Would [1,2] be a one-element list containing the pair (1,2), or a two element list?
12:40:29 <EvanCarroll> ok, I'm tottally new to haskell, and i understand being pure allows a compiler to send functions off to different cores without worrying about shared mem because there is no side-effects, but does the compiler really do this stuff?
12:40:45 <EvanCarroll> or is it just easier for a programmer to do it?
12:40:48 <Cale> It will if you annotate your program a bit
12:40:49 <ddarius> EvanCarroll: Not implicitly.
12:41:05 <ddarius> EvanCarroll: It -could- do it implicitly, but that turns out to be a pessimisation in most cases.
12:41:09 <EvanCarroll> will it ever do it implicitly, will it ever give way to something like -ONutsoAcrossCores
12:41:48 <Cale> EvanCarroll: There's an arbitrarily hard problem with granularity -- deciding which subcomputations are good to split up.
12:42:11 <EvanCarroll> right, well. If that's annotation, I'll do it.
12:42:13 <Eduard_Munteanu> Yeah, would you parallelize every Show? That's some overhead.
12:42:16 <Cale> EvanCarroll: But there will be something close to that very soon :)
12:42:38 <ddarius> Cale: ?
12:42:45 <Cale> EvanCarroll: Nested data parallelism
12:43:03 <Cale> You get a new datastructure called the parallel array, and operations on that datastructure are magically parallelised and load balanced.
12:43:19 <Cale> Even if they themselves are parallel computations.
12:43:25 <EvanCarroll> nifty!
12:43:59 <ddarius> It's no problem writing bulk parallel operations.
12:44:00 <Eduard_Munteanu> Or perhaps auto-parallelize based on profiling data?
12:44:13 <Eduard_Munteanu> That seems sensible.
12:44:16 <wagle_> connection coming and going, did someone answer this?:
12:44:20 <wagle_> hi, if cabal chokes upgrading happstack-util, what do you do?  (at unconference, i'm a bit distracted)
12:44:32 <gwern> Eduard_Munteanu: the ghc people tried autoparallelizing. didn't seem to work for them
12:44:57 <Eduard_Munteanu> gwern, what parallelization criteria?
12:45:01 <Eduard_Munteanu> Profiling data?
12:45:09 <Cale> There's a clever way to flatten nested data parallel computations into flat ones, which can then be split up fairly across processing units.
12:45:09 <gwern> dunno. go read the paper. think it was profiling
12:45:23 <Eduard_Munteanu> gwern, I see. Will look it up.
12:45:30 <Cale> and it's an automatic process which can be done by the compiler (in theory)
12:45:58 <Cale> EvanCarroll: But even before that...
12:46:37 <SamB_XP> will they bump the version to 8.0 when NDP actually works ?
12:46:49 <Cale> EvanCarroll: We have something called par. An expression par x y will evaluate to y, but hint to the runtime system/compiler that maybe x would be good to evaluate now in parallel if you have free time.
12:47:24 <paolino> hola, is evaluating length . parMap rnf f triggering the f computations ?
12:47:32 <Cale> EvanCarroll: Basically, when par x y gets evaluated, x is added to a queue of expressions which should be evaluated on any available processor which needs work to do.
12:47:47 <Cale> paolino: let me check. I think probably not.
12:48:24 <paolino> I was guessing not too
12:48:47 <Cale> oh, maybe it does add the elements to the queue
12:49:09 <Cale> But it probably won't get many of them evaluated before they become garbage even if so.
12:49:22 <EvanCarroll> Cale: finding a tutorial on how to parellelize haskell with code sample demonstrating it in less than <10 would be bigger than the quicksort demo.
12:50:31 <EvanCarroll> I want a language that will utilize two cores in less lines than i can do "hello world" in java.
12:50:42 <paolino> Cale you think length is computed in parallel with scheduling those evaluations ?
12:51:04 <Cale> paolino: oh, definitely not
12:51:29 <Cale> paolino: The elements of the list maybe will start evaluating as the length is computed
12:51:51 <paolino> even if I don't need the head ?
12:51:58 <Cale> paolino: But you can't parallelise taking the length of the list.
12:51:58 <Eduard_Munteanu> You only need to know the number of thunks, not evaluate the elements, to determine length.
12:52:13 <Cale> paolino: It's just made impossible by the structure of the list itself.
12:52:39 <Cale> parMap is for evaluating the elements of the list in parallel
12:53:00 <Cale> EvanCarroll: Sure. That's easy :)
12:53:13 <Eduard_Munteanu> Cale, then you do know the length of the list before the elements get evaluated.
12:53:34 <Cale> Eduard_Munteanu: Sort of, yeah.
12:53:58 <paolino> so, needing any of them will compute all of them before computing the needed one
12:53:59 <Cale> Eduard_Munteanu: though, as you're working on the length, the sparks fired off by parMap will have started on other cores
12:54:03 <Eduard_Munteanu> Cale, because AFAICT, the list can be independently evaluated of its elements.
12:54:11 <Cale> Eduard_Munteanu: that's right.
12:54:40 <Eduard_Munteanu> Cale, oh, so it's an optimization, so you don't launch too many threads.
12:54:46 <Cale> Just taking the length normally with length is the fastest possible way to get the length of a list. This wouldn't be true for something like a tree structure maybe.
12:55:18 <Eduard_Munteanu> Yeah, you'd 'par left right' there.
12:55:59 <EvanCarroll> is there a way to get a definition of a function from within ghci?
12:56:18 <EvanCarroll> (body)
12:56:36 <ksf> does the language shootout allow TH?
12:56:37 <mathijs> what does ~ mean ?
12:56:39 <Eduard_Munteanu> @src map
12:56:39 <lambdabot> map _ []     = []
12:56:40 <lambdabot> map f (x:xs) = f x : map f xs
12:56:50 <Eduard_Munteanu> Not sure if there's any equivalent for ghci.
12:56:51 <mathijs> in select p x ~(ts,fs)
12:56:58 <ksf> mathijs, ~ is sqj for type equality
12:57:05 <ksf> oh, on the value level, laziness.
12:57:17 <Cale> mathijs: It means that the pattern always matches immediately, but doesn't actually evaluate anything until you use one of the matched variables.
12:57:21 <EvanCarroll> how do i do @src map in ghci?
12:57:22 <ksf> the pattern won't be matched in that function.
12:57:37 <ksf> ...but later, as Cale says.
12:57:40 <Cale> mathijs: If the pattern didn't actually match, you'll get an (essentially uncatchable) exception at that point.
12:57:45 <ksf> EvanCarroll, you don't.
12:57:56 <Cale> But for matching things like pairs, you know it will always match.
12:57:58 <ksf> lambdabot comes with a hardcoded list of sources.
12:58:06 <EvanCarroll> ksf: =( so there is no way
12:58:06 <EvanCarroll> bah
12:58:09 <EvanCarroll> that's no joy
12:58:14 <ksf> well, you can download lambdabot, or use hoogle
12:58:21 <EvanCarroll> that would have been nifty
12:58:23 <EvanCarroll> hoogle?
12:58:27 <mathijs> Cale: cool, get it. so it won't try to break down the argument to normal form
12:58:30 <ksf> or hayoo
12:58:36 <Eduard_Munteanu> :))
12:58:37 <Cale> mathijs: yeah
12:58:40 <ksf> google for them, you'll find them.
12:58:41 <Eduard_Munteanu> Nice stuff.
12:58:44 <EvanCarroll> k
12:59:01 <sinelaw> @hoogle map
12:59:01 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
12:59:01 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
12:59:01 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
13:00:07 <mathijs> are there any cases where having more threads than cores would be good?
13:00:19 <Cale> paolino: heh, try this in ghci:  length . parMap rnf (\n -> trace ("fac " ++ show n) (product [1..n])) $ [trace ("elt " ++ show k) k | k <- [1..100]]
13:00:20 <Eduard_Munteanu> mathijs, yes
13:00:39 <Eduard_Munteanu> mathijs, where there's a certain degree of I/O-boundedness.
13:00:42 <booxter> ghc-6.8.2: runghc doesn't recognize .hs files when their names are in uppercase though for lowercase it works ok. Why?
13:00:42 <Cale> paolino: You'll see the actual length gets printed first, and then watch all the sparks happen :)
13:01:00 <Cale> mathijs: You mean OS threads?
13:01:02 <mathijs> Eduard_Munteanu: waiting for system calls you mean?
13:01:10 <Eduard_Munteanu> mathijs, for example.
13:01:12 <sinelaw> my computer just wrote that my battery is finishing
13:01:13 <sinelaw> "Approximate unknown time remaining"
13:01:22 <gnut> good morning all
13:01:25 <ksf> hmmm I bet some scheme programs use macros, so we'd have precedence
13:01:31 <Eduard_Munteanu> gnut, hi
13:01:42 <mathijs> Cale: not sure?  I meant things that can run at the same time :)
13:01:54 <gnut> Eduard_Munteanu: hi.
13:02:16 <Eduard_Munteanu> mathijs, generally if there's anything that can wait without using CPU time.
13:02:24 <Cale> mathijs: GHC has an N:M scheduler which runs N Haskell threads on M OS threads.
13:02:42 <Cale> mathijs: Generally N will be rather large compared to M
13:03:07 <Eduard_Munteanu> Generally, 1 or 2 threads above the number of actual cores/CPUs is enough.
13:03:21 <Eduard_Munteanu> Since threads are migrated easily to other cores.
13:03:23 <mathijs> Cale: in that case I meant OS threads.
13:03:27 <Cale> You generally want to use as many Haskell threads as is natural to specify your computation, up to a certain threshhold where the scheduling starts to cost more than the computation.
13:03:36 <Eduard_Munteanu> Unless the program is too I/O bound.
13:03:59 <mathijs> Eduard_Munteanu: when compiling stuff (gcc, make) I usually go for N+1 indeed, seems to perform best
13:04:02 <Cale> The number of OS threads to use is a commandline RTS parameter, and usually around the number of cores is good.
13:04:07 <Eduard_Munteanu> mathijs, yeah.
13:04:14 <ksf> ...which is because of IO overhead.
13:04:41 <ksf> it's all very much black magic and hugely machine-dependent.
13:05:00 <Eduard_Munteanu> Yes, and depends on whether threads do similar workload or not.
13:05:20 <paolino> Cale: if I use Ncores + 1 in ghc 6.12 , it hangs forever
13:05:22 <ksf> like, if you have a really, really fast ssd, a real ramdisk or are smart enough to pipe the source tree to /dev/null beforehand.
13:05:24 <Eduard_Munteanu> For example, if not, you might go higher.
13:05:58 <Cale> paolino: I'd consider that a bug. Check if it's already on the trac, and if not, perhaps report it.
13:06:11 <ksf> ramdisk as in sata-connected ram, not as in virtual filesystem.
13:06:49 <mathijs> the reason I'm asking is the following: I'm planning on doing a bigger project in haskell. The original program (java) is quite modular, there are about 4 big pieces that are run on a different thread each, and communicate with each other. While I like this approach, I think I would like a more fine grained paralellisation mechanism, because I don't think all 4 parts are equally heavy.
13:08:03 <ksf> mathijs, you can use something like CHP and spawn additional threads for e.g. map-like things.
13:08:08 <mathijs> In the original program, the 4 parts just communicate using a message-queue, so no parts ever have to wait for other parts.
13:08:23 <mathijs> ksf: CHP?
13:08:35 <SamB_XP> > 0xc0
13:08:36 <lambdabot>   192
13:08:39 <ksf> ...or not use CHP, as it comes with quite a runtime overhead. doing the same for a concrete case in pure STM isn't hard
13:08:46 <ksf> @hackage chp
13:08:46 <lambdabot> http://hackage.haskell.org/package/chp
13:08:50 <Cale> Or... just use Chan :)
13:08:54 <ksf> it's a CSP-based concurrency library
13:09:13 <Cale> There's also a CML library.
13:09:37 <ksf> the important point to do is to use NFData and force the stuff in the right thread, as haskell is perfectly happy to just pass on the thunks and make one thread evaluate it all.
13:10:14 <Cale> That is, if you're evaluating stuff.
13:10:34 <Cale> If you're doing pure computations which you want parallelised, then threads are usually not the right thing.
13:10:44 <skorpan> why not?
13:11:11 <Cale> Because there's par and Control.Parallel.Strategies
13:11:14 <skorpan> seeing as side-effects are what breaks thread-safety in many cases...
13:11:15 <Cale> which is easier and safer
13:11:27 <ksf> yep
13:11:44 <skorpan> @src par
13:11:45 <lambdabot> Source not found. Sorry.
13:12:06 <ksf> I focused on effects as I've been multiplexing different C libraries which only can be used single-threadedly
13:12:14 <skorpan> so how is "par" implemented?
13:12:24 <ksf> magic.
13:12:38 <Cale> Threads are for expressing concurrency, which is all about doing different things at the same time, such that they interact a bit nondeterministically, but in a hopefully controlled way. If you know the computation is pure and deterministic, threads are too heavy an abstraction.
13:13:11 <mathijs> Yeah I looked at Chan, I'll probably go for that. But I would like to get rid of most IO / STM like code. I looked at reactive but it's a bit over my head.
13:13:29 <Cale> Evaluating par x y adds x to a queue of things which will be evaluated on some processing unit when there is spare time.
13:13:35 <Cale> Before evaluating to y.
13:13:40 <ksf> reactive isn't likely to make your program faster (or at all)
13:13:56 <ksf> *or run at all
13:14:08 <kw317> hmm.. I've got darcs hanging at "Merging them 25/41" when I try to pull sources of the ghc
13:14:14 <Adamant> has anything successful come out of reactive yet?
13:14:21 <Adamant> programs that use it, etc.
13:14:22 <kw317> any advice/
13:14:23 <ksf> much of insight for conal
13:14:23 <mathijs> I'm afraid my program will turn out to be mostly IO if I go for chan. It's lots of connection-management, subscriptions, callbacks and such and I would like to model that code more funtional
13:14:24 <Cale> Adamant: Some versions of it worked.
13:14:38 <Cale> Adamant: But there are problems.
13:14:38 <ksf> fieldtrip is certainly cool.
13:15:12 <ben> (bracket_ `on` setCurrentDirectory) dir oldDir action -- 'on' is quickly becoming my favourite function
13:15:27 <skorpan> are there imperative but pure programming languages?
13:15:28 <ksf> but one thing is true, if you use reactive, you won't ever have to worry about your program not being able to harness multicores.
13:15:39 <ksf> it rather will have problems harnessing singlecores.
13:15:42 <Cale> mathijs: Sure, it really depends on what you're using the parallelism / concurrency in order to obtain.
13:15:48 <ksf> skorpan, yes, haskell is one of them.
13:16:08 <conal> ksf: nice one :)
13:16:14 <skorpan> i don't think i want to hear your explanation on that one
13:16:15 <Cale> mathijs: If it's responsiveness in the face of many I/O tasks, that's concurrency. If it's speed of raw computation, that's parallelism.
13:16:17 <ksf> it comes with some capabilities of functional abstraction, but you can ignore them all.
13:16:19 <MoALTz> well, imperative-like features
13:16:20 <skorpan> but seriously...  are there?
13:16:22 <mathijs> ksf: I'm not after performance. I just want to be able to trust my code and prove to myself why. With lots of IO and thread-management, I don't think I can do that
13:16:31 <kmc> skorpan, yes.  haskell is one of them
13:16:42 <skorpan> ffs
13:16:51 <kmc> what makes you think haskell is not an imperative language?
13:16:55 <kmc> imperative doesn't mean "not functional"
13:16:59 <kmc> the word for that is "dysfunctional"
13:17:04 <kmc> as in "C++ is a dysfunctional language"
13:17:06 <conal> ksf: good point.  maybe i can get sponsorship from intel, nvidia, etc.
13:17:09 <MoALTz> haha
13:17:50 <kmc> haskell is a great imperative language
13:18:01 <kmc> because you have first-class imperative actions
13:18:03 <Adamant> conal: I wouldn't be surprised if Nvidia would be interested in you, although maybe not for doing FRP stuff
13:18:19 <Adamant> which is what I think you want to do, so...
13:18:23 <skorpan> i can't really convince you by doing so, but from wikipedia "Although pure functional languages are non-imperative"
13:18:31 <Cale> "Help us with linear algebra!"
13:18:31 <kmc> wow wikipedia
13:18:51 <Adamant> Cale: ?
13:18:54 <ksf> don't ever rely on wikipedia for CS topics.
13:18:58 <kmc> some people need to put everything in disjoint labeled boxes.
13:19:04 <Cale> Adamant: Taking a guess at what you mean
13:19:07 <Adamant> ah
13:19:13 <ben> a $ b c d being equal to a (b c d), is there a parentheses-less way to write a (a b) c d?
13:19:14 <kmc> if you ignore that, you'll see that e.g. functional and OO, or functional and imperative features play quite nicely together
13:19:18 <ksf> they're good at describing landmarks for a sigtseeing tour of country X, but not much more.
13:19:21 <skorpan> whatever
13:19:25 <kmc> ben, you can define your owncombinator
13:19:40 <Cale> ben: No, because $ has the wrong associativity
13:19:40 <Adamant> Cale: they like smart Ph.D holders who have done experimental stuff
13:19:52 <kmc> in Python, every object method is a closure of a partially applied first-class function
13:19:52 <ben> :(
13:19:56 <conal> another perspective: haskell is a purely functional (purely un-imperative) language, and IO is a purely imperative language.  like the cpp macro language, haskell is good for generating imperative programs.
13:21:15 <conal> it turns out that functional programming is good for generating imperative programs (among other things).
13:21:54 <Philonous> That begs the question what "imperative" means exactly
13:22:06 <skorpan> i still wouldn't call haskell imperative *at all*
13:22:09 * ksf likes the concept that all of haskell is a macro processor
13:22:10 <medfly> IT HAS LIKE VARIABLES AND STUFF
13:22:39 <Cale> EvanCarroll: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking-4core -- here's a little hello-world-esque parallelism tutorial
13:22:40 <ksf> it also gives you a sane intuition about the IO monad, among other things.
13:23:18 <Cale> EvanCarroll: Of course, it's optimising something which can be optimised in a much better way by change of algorithm, but the important thing isn't really what it's computing but how.
13:23:45 <sinelaw> this question is exactly what i need to answer...I'm writing a report whose audience is electrical engineering professors. not easy to explain why FP is good to them
13:24:02 <sinelaw> too many introductions required
13:24:08 <ksf> skorpan, is BASIC imperative?
13:24:18 <ben> conal: That only works if the imperative program can call functional subprograms, no?
13:24:23 <skorpan> i don't know basic, but from what i've seen, yes, it does look imperative to me
13:25:19 <ksf> skorpan, http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
13:25:27 <Cale> sinelaw: If I knew more about electrical engineering, I might be able to give a comparison between referential transparency and the kinds of abstractions used to reason about circuits.
13:25:30 <jagwire> is there any relationship between integers and booleans in haskell?
13:25:46 <ben> > fromEnum $ True :: Int
13:25:47 <lambdabot>   1
13:25:54 <skorpan> ksf: what's your point?
13:25:59 <kmc> skorpan, what definition of "imperative" are you working from?
13:26:00 <Cale> jagwire: They are both defined in the Prelude ;)
13:26:09 <Cale> Also, we have...
13:26:12 <Cale> :t (==)
13:26:14 <lambdabot> forall a. (Eq a) => a -> a -> Bool
13:26:15 <kmc> it's important to realize that words like "imperative" and "object-oriented" describe feature-sets, not languages
13:26:16 <Cale> :t (<)
13:26:17 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:26:26 <Cale> Integer is an instance of Eq and Ord
13:26:32 <ksf> if basic is a haskell edsl, and basic is imperative, then haskell is obviously imperative.
13:26:35 <Cale> and so you can compare Integers and get Bools
13:26:39 <ksf> as otherwise it couldn't express basic.
13:26:43 <kmc> and one language can support several feature-sets
13:26:44 <skorpan> kmc: an imperative language to me has statements and is largely based entirely on side-effects.
13:26:56 <kmc> skorpan, haskell has statements.  that's what "do" is
13:27:01 <jagwire> cale, what about the other way around
13:27:03 <skorpan> kmc: i disagree
13:27:10 <kmc> and you can write code which is based entirely on side effects
13:27:11 <ksf> and you get those side effects with IORefs.
13:27:11 <sinelaw> Cale, the main thing done with circuits is linearization and then using laplace-domain functions to solve behavior in the time domain
13:27:15 <jagwire> can you do something with booleans and get an integer?
13:27:20 <ksf> and you're still pure. imperative _and_ pure.
13:27:21 <sinelaw> basically, solving ODE's
13:27:24 <kmc> a do-block is an expression, but is made of statements
13:27:24 <Cale> jagwire: if b then 5 else 7
13:27:26 <ksf> which is what you were asking for.
13:27:54 <skorpan> so if i'm writing to a file on my hard drive in haskell, i'm still pure?
13:28:01 <ksf> a top-level IORef is exactly the same thing as a global variable.
13:28:02 <Cale> sinelaw: Right, and ODEs are an equational theory.
13:28:03 <gnut> what's a good way to shutdown the haskell RTS from within a shared object?
13:28:04 * SimonRC goes away.
13:28:06 <jagwire> erm
13:28:12 <kmc> skorpan, yes, in the sense that you never evaluate a function to get a side effect
13:28:13 <gnut> for some reason, when I use shutdownHaskell(), my thing crashes
13:28:28 <kmc> the point of the IO monad is that IO-actions are *not* functions
13:28:35 <ksf> skorpan, as long as you don't use unsafeMMap on the same file, yes.
13:28:35 <sinelaw> Cale, point being that FP is also equational, when pure?
13:28:40 <Cale> sinelaw: yeah
13:28:44 <jagwire> is there type casting in haskell?
13:28:45 <kmc> and a value of type a -> IO b is not an "impure function"; it's a pure function which produces as its result an IO action
13:28:52 <gnut> if I don't use shutdownHaskell(), I can keep calling my shared object and it's fine, but when the main calling program quits, then I get a crash dump.
13:29:05 <skorpan> kmc: i'm fine with that fact
13:29:07 <ksf> kmc, type Mobit a = Monad m => m a
13:29:15 <ksf> it's "IO Mobit"
13:29:19 <Cale> sinelaw: So you can do things like make substitutions in order to understand the behaviour of something and even write down proofs if you want.
13:29:25 <skorpan> but the actual evaluation of an IO action surely must be impure?
13:29:29 <sinelaw> Cale, i also need to explain why object oriented / message passing, and flow control structures, etc...are intractable
13:29:36 <sinelaw> why they are bad
13:29:40 <kmc> skorpan, what do you mean by "impure"
13:29:40 <Cale> sinelaw: Yeah...
13:29:41 <ksf> skorpan, no, it's magic.
13:29:44 <kmc> it doesn't involve side effecting functions
13:29:51 <sinelaw> Cale, i'm so sold out to Haskell that i don't even know how to explain that
13:29:53 <kmc> usually "impure" means "impure functions"
13:29:57 <skorpan> what do you mean by "side effecting functions"?
13:29:58 <Cale> sinelaw: hehe
13:30:07 <kmc> skorpan, functions that have a side effect when you apply them
13:30:11 <kmc> haskell has none of those
13:30:15 <ksf> it all depends on where the border of your semantics are, and whether you are able to model your OS in a pure way.
13:30:17 <skorpan> really?
13:30:20 <Philonous> jagwire: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
13:30:20 <kmc> yes
13:30:26 <kmc> excepting unsafePerformIO and friends
13:30:30 <Cale> sinelaw: Well, they're not *all* bad, and there are times when those are appropriate abstractions, but they are not anywhere close to being always the right thing.
13:30:30 <sinelaw> Cale, so all i'm saying so far is "they're intractable" in several different ways, without showing anything
13:30:43 <kmc> applying a function of type "a -> IO b" does not perform the side effect
13:30:54 <skorpan> kmc: then when is it performed?
13:31:00 <kmc> you can reduce putChar 'X' to whnf without any character getting printed
13:31:10 <kmc> skorpan, when that IO action gets sequenced into the overall IO action
13:31:13 <kmc> using (>>=)
13:31:15 <skorpan> which is main?
13:31:18 <sinelaw> Cale, you had a point though - equational reasoning is hard to do about them
13:31:20 <ksf> skorpan, in GHC terms, when the RealWorld# of main is forced.
13:31:26 <kmc> or your GHCi session, etc.
13:31:27 <ksf> which the RTS does (conceptually)
13:31:40 <skorpan> okay, obviously this is above my head now
13:31:57 <Cale> sinelaw: Have you watched the SICP lectures?
13:32:01 <kmc> skorpan, just think of haskell programs as functional programs that build "recipes" for how to do IO
13:32:03 <sinelaw> Cale, nope
13:32:03 <ksf> you see, haskell programs execute by replacing the real world with a new one in which they already have been executed.
13:32:32 <skorpan> kmc: i'm okay with that part, it's just the RTS and RealWorld# stuff i know nothing about
13:32:33 <kmc> @hoogle rnf
13:32:34 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
13:32:40 <kmc> skorpan, those are GHC implementation details
13:32:48 <Cale> sinelaw: If you have a bunch of free time, I would recommend it... there's one in particular where he talks about abstraction as being the key to programming large systems and makes a good comparison to electrical engineering.
13:33:13 <sinelaw> Cale, thanks, added to queue
13:33:24 <conal> ben: yes.  unlike CPP/C, with Haskell/IO the imperative language gets to invoke the functional language.
13:33:26 <ksf> skorpan, RealWorld# is a dummy type GHC threads through the IO monad to express the data dependency of sucsequent IO mobits on their previous ones.
13:33:38 <kmc> mobits mo problems
13:33:39 <skorpan> what's mobit?
13:33:54 <ksf> type Mobit a = Monad m => m a
13:33:56 <kmc> "mobit" is some newfangled term for "action" or "computation"
13:33:56 <mightybyte> Is attendence to the ICFP conference open, or do you have to be a member of some organization?
13:34:00 <kmc> what I called an "IO action" above
13:34:02 <kmc> or a "recipe"
13:34:08 <ksf> but it's generalized for all monads.
13:34:19 <ksf> you can have Parsec mobits, too.
13:34:20 * Cale prefers monadic value
13:34:35 <kmc> ksf, but you couldn't actually sequence two Mobits, could you?
13:34:42 <conal> mightybyte: anyone may attend icfp
13:34:44 <Cale> mobit sounds like it's involved with, well, bits.
13:34:44 <kmc> because the existential hides whether they're in the same monad
13:34:44 <ksf> Cale, but that's not buzzspeak-compliant.
13:34:57 <mightybyte> conal: Is there a fee?
13:35:00 <ksf> kmc, if they are mobits of the same monad, yes.
13:35:03 <FunctorSalad> "recipe" sounds good for the IO case
13:35:08 <conal> mightybyte: yes.  and there are discounts for students & acm members.
13:35:09 <kmc> ksf, how do you know (statically)
13:35:20 <FunctorSalad> "monadic value" is much less informative (in the Io case)
13:35:23 <kmc> m *is* existential there, right?
13:35:29 <kmc> oh, wait
13:35:34 <kmc> "type" not "data"
13:35:34 <mightybyte> conal: Ok.  I've looked around but haven't found any information on the costs.
13:35:40 <FunctorSalad> and I want my bikeshed in red and purple and yellow
13:35:59 <conal> mightybyte: look for icfp 2009.  the costs for 2010 are probably not up yet.
13:36:03 <ksf> it's a Rank2 Type.
13:36:15 <ksf> it's still a type synonym, but you don't have to mention m.
13:36:15 <kmc> do constraints on type synonyms just percolate out to the type where the synonym is used?
13:36:25 <byorgey> mightybyte: registration is on the order of a few hundred dollars.
13:36:29 <ksf> I might be wrong, but I think yes.
13:36:37 <mightybyte> byorgey: Ok, thanks.
13:36:38 <conal> mightybyte: https://regmaster2.com/cgi-bin/ICF09/on1/RMSs.cgi
13:36:41 <ksf> at least that interpretation was my intention.
13:36:52 <conal> mightybyte: to give you a ballpark idea.
13:36:56 <FunctorSalad> ksf: I don't see how there's anything special about tysyns here
13:37:02 <mightybyte> conal: Excellent.
13:37:12 <FunctorSalad> it's just that you can move universal quantifiers in and out of positive positions
13:37:20 <byorgey> oh, I guess "a few hundred dollars" only applies to students =P
13:37:29 <ksf> FunctorSalad, yes, it's mostly syntactic.
13:37:33 <FunctorSalad> forall a. Int -> P[a]   === Int -> forall a. P[a]
13:37:47 <sinelaw> a few hundred dollars? does that include the flight? :)
13:37:53 <kmc> wait how the fsck does this BASIC EDSL work?
13:37:55 <kmc> is the code somewhere?
13:37:57 <byorgey> sinelaw: definitely not. =)
13:38:03 <ksf> kmc, on hackage
13:38:16 <sinelaw> byorgey, i was guessing that
13:38:20 <sinelaw> :( :(
13:38:55 <mightybyte> byorgey: Well, theoretically the relative cost would be similar. :)
13:39:06 <ksf> the intention of using "bit" in Mobit is that a Mobit is one of the things that live in the domain of the Monad.
13:39:33 <ski> ksf : do you mean `type Mobit a = forall m. Monad m => m a' (or maybe `type Mobit a = exists m. Monad m *> m a' ?)
13:39:45 <mightybyte> byorgey: Do presenters get in free?
13:40:05 <ksf> I don't think I want existentials.
13:40:14 <ksf> I only want a type synonym.
13:40:19 <FunctorSalad> you could also make up some new name for it which doesn't have any direct relation to "Monad"
13:40:28 <FunctorSalad> but is provocative, hence easy to remember
13:40:44 <ski> the only valye of type `forall m. Monad m => m a' is `return x' (whenever `x :: a') (ignoring partial values)
13:40:46 <ksf> Actually I don't want code at all, but a word that isnt "monadic value" and still caputres bits from all monads.
13:40:59 <skorpan> regarding augustsson's haskell BASIC stuff, how did he manage to make stuff like "10 GOTO 20" syntactically valid?
13:41:24 <FunctorSalad> names needn't always be descriptive, particularly for something that will be used all the time anyway
13:41:29 <Cale> skorpan: Creative instances of Num
13:41:36 <FunctorSalad> their other important role is to just serve as unique tokens
13:41:46 <ski> skorpan : "side-effectful" is a syntactic property of a program
13:42:02 <ksf> ski, readLine is a mobit for IO, satisfy (const False) is a mobit for Parsec, and return "foo" is a mobit for both.
13:42:23 <FunctorSalad> how about "M-Value"?
13:42:27 <ksf> I just want to syntactically capture the Monad m => context
13:42:35 <ksf> FunctorSalad, not buzzspeak-compliant.
13:42:41 <ksf> mobit is a cute name.
13:42:46 <ksf> M-Value is scary.
13:42:53 <Cale> M-value is good
13:42:56 <FunctorSalad> ksf: so this is for non-techy types?
13:43:18 <ski> ksf : oh, so you maybe mean when `type Mobit m = exists a. Monad m => m a' : `readLine :: Mobit IO' ?
13:43:20 <ksf> not only.
13:43:31 <ksf> ski, no.
13:43:43 <Cale> I would suggest M-element, but that sounds more like a natural transformation 1 -> M, which is something akin to return
13:43:49 <ski> (or when `type Mobit m a = Monad m => m a' : `readLine :: Read a => Mobit IO a' ?)
13:44:12 <kmc> i feel like these mobits are confusing the issue
13:44:13 <ksf> ski, yes
13:44:28 <kmc> maybe if they were called "monuts"
13:44:34 <ski> ksf : certainly, `readLine :: Read a => Mobit a' is false if `type Mobit a = forall m. Monad m => m a'
13:44:46 <ksf> or rather type m `Mobit` a = Monad m => ma
13:45:05 <ksf> "a String mobit in IO"
13:45:09 <ksf> something like that.
13:45:11 <Cale> painful.
13:45:12 <FunctorSalad> Cale: but m-value also alludes to l-value, so maybe it will make people curious what the 'm' means
13:45:19 <FunctorSalad> :)
13:45:40 <ski> so `Mobit m a' is the same as `m a', except that `m' is assumed to be a monad ? .. or maybe that `m' is *claimed* to be a monad ?
13:45:42 <ksf> the reason I don't like value is because I want to stress the type level.
13:45:43 <Cale> I mean, substitute the specific m. So IO-value
13:45:47 <Cale> (for instance)
13:45:50 <FunctorSalad> and then BAM they'll be enthralled by haskell's beauty
13:45:53 <FunctorSalad> ;)
13:45:56 <segoe> hi
13:46:29 <ski> (in which case you'd use `type Mobit m a = Monad m *> m a')
13:47:04 <ksf> ski, in the beginning I intended mobit never to be qualified for a specific monad.
13:47:23 <ksf> but there's the issue that mobits for different monads are of course separate domains.
13:47:28 <ski> ksf : in any case, i'd say `getLine' is an `IO'-action (monadically) returning/yielding (a value of type) `String'
13:47:43 <mmx166mhz> I am very confused on how to use install wx in order to let a module work which says "import Graphics.UI.WX". Can someone tell me step for step what to do?..:( I know, im a n00b.
13:48:04 <Cale> mmx166mhz: Do you have the cabal install program?
13:48:11 <mmx166mhz> no
13:48:22 <mmx166mhz> ok, lets fix that then
13:48:26 <ksf> mmx166mhz, get it, then say "cabal install wx"
13:48:26 <FunctorSalad> IIRC wx isn't fully cabalized, is it?
13:48:36 <ksf> cabal list claims it is.
13:48:47 <FunctorSalad> but there's also wxcore or something
13:48:49 <Cale> I think it is.
13:48:51 <ksf> there's even wxfruit
13:48:53 <Cale> wxcore is there too
13:49:01 <FunctorSalad> hmm. maybe it changed
13:49:13 <Cale> mmx166mhz: Just checking, you have a recent ghc, yeah?
13:49:25 <wagle_> hi, if cabal chokes upgrading happstack-util, what do you do?  (at unconference, i'm a bit distracted. and connection comes and goes, sorry)
13:49:38 <Cale> mmx166mhz: If you're on linux, http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
13:49:51 <mmx166mhz> no, i am on windows
13:49:53 <ksf> wagle_, you mean your connection tends to die?
13:49:55 <Cale> oh, okay...
13:50:02 <mmx166mhz> though I found cabal now
13:50:18 <ksf> ...and that's the reason you don't get the download to complete reliably?
13:50:18 <Cale> http://www.haskell.org/haskellwiki/Cabal-Install#Windows
13:50:43 <Cale> mmx166mhz: Okay
13:50:59 <Cale> mmx166mhz: So cabal install wx
13:51:05 <ksf> oh cabal upgrade.
13:51:09 <mmx166mhz> I did the cabal thing.
13:51:16 <mmx166mhz> Next step:?
13:51:20 <Cale> mmx166mhz: after cabal update
13:51:27 <ksf> is upgrade repaired? I see my version comes with it, and it's recent
13:51:28 <wagle_> yeah, the wifi comes and goes..  but thats not the cabal problem, just a problem in hearing the answer, if someone's already given it
13:51:32 <Cale> mmx166mhz: ah, did it install wx for you?
13:51:32 <wagle_> ksf
13:52:02 * ski idly wonders if `Control.Concurrent.CML.Event' could be made into a monad
13:52:06 <mmx166mhz> I cant see wx anywhere..:\
13:52:08 <Cale> mmx166mhz: Once you have cabal-install, it should be as simple as cabal install wx
13:52:26 <Cale> mmx166mhz: and that'll download all the relevant code and install it
13:52:26 <ksf> wagle_, it's easy to shoot yourself in the foot with cabal upgrade with older cabal versions.
13:52:27 <ski> `wrap :: Event a -> (a -> IO b) -> Event b' looks suspiciously like `(>>=)'
13:52:49 <Cale> mmx166mhz: But I don't use windows, so I'm oblivious to any differences in this process to how things work on linux :)
13:52:55 <ksf> as they reintroduced the command I bet it's safe now, but I wouldn't wonder if it fails to upgrade stuff it could, in theory.
13:53:11 <mmx166mhz> One question: I did the cabal thinh and there got some things installed( I got a commandprompt). Well: Where did it get installed?
13:53:15 <ksf> the easy way out is always to nuke your ~/.cabal and ~/.ghc and re-install what you need.
13:53:16 <wagle_> ksf...  nice..  how do i re-attach my foot?  8)
13:53:47 * ski . o O ( `screen -xRS foot' )
13:53:49 <Cale> mmx166mhz: I'm not sure where it puts things on windows. On linux, it puts them in .cabal inside my home directory
13:54:01 <Cale> mmx166mhz: So, maybe something like in your user profile directory?
13:54:17 <aavogt> cabal installs are global on windows
13:54:30 <ksf> the problem is diamond dependencies, your programs can horribly fail if two versions of the same library are linked into one program
13:54:35 <Cale> ah, that's different
13:54:37 <wagle_> i'm using gitit, which wants the bleeding edge ghc..
13:54:47 * wagle_ prepares for long rebuild
13:54:50 <Cale> wagle_: 6.12, really?
13:54:54 <aavogt> I think they end up in C:\Program Files\Haskell or something like that
13:55:00 <tensorpudding> cabal can only do global installs in windows?
13:55:07 <Cale> wagle_: Never build GHC yourself. Always look for a way to get a binary.
13:55:16 <ksf> gitit 0.6.5 works with 6.10.4
13:55:21 <ksf> I've got it installed.
13:55:33 <aavogt> tensorpudding: I think the only difference is what the default is
13:55:53 <tensorpudding> it is conceivable someone could be running a limited account
13:56:13 <tensorpudding> and not have write access to C:\Program Files\
13:56:21 <ksf> windows has multi-user support?
13:56:28 <ksf> they must have added that after I stopped using it.
13:56:48 <wagle_> Cale: well, okay, bleeding edge wrt debian..  only 6.10.4 in real life
13:56:51 <Cale> ksf: Windows NT always has, and the current versions of windows are all descended from that.
13:56:52 <aavogt> then they are allowed to tell cabal install --user
13:57:16 <tensorpudding> they have some multi-user support
13:57:20 <ksf> no I mean actually functional multi-user support.
13:57:32 <Cale> wagle_: I never use those packages. There's a generic linux binary which works fine.
13:57:36 <ksf> I _did_ use win2k, and you had to do everything as administrator.
13:57:48 <Cale> wagle_: You can download it from the GHC page.
13:58:22 <wagle_> Cale: it was 2-3 months ago, i dont remember exactly how i got it before
13:58:32 <ksf> 6.10.3 is more bleeding edge than 6.10.4, because it's a bugfix release...
13:58:36 <byorgey> mightybyte: good question, I'm not sure
13:58:41 <tensorpudding> there are limited users in windows, and they are almost useless
13:58:45 <byorgey> mightybyte: possibly
13:58:55 <wagle_> i'm more used to compiling everything on macosx/macports
14:00:30 <tensorpudding> the haskell platform on mac is good i hear
14:02:57 <wagle_> ok, "deleted" ~/.cabal, ran cabal update, then cabal install gitit, and it immediately barfs on happstack-util..  i didnt back out enough?
14:03:19 <ksf> nuke ~/.ghc, too.
14:03:42 <ksf> that's where the package registration info lives.
14:03:58 <ksf> if it still fails after that, paste the error
14:03:58 <mperillo> hi
14:03:59 <ksf> @hpaste
14:03:59 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:04:54 <mperillo> I need a parser for lazy bytestrings, should I use attoparsec or bytestringparser ?
14:05:11 <ksf> you could also use Parsec or uu-parsinglib
14:05:21 <mperillo> attoparsec seems more recent, but there is no exported documentation
14:05:26 <ksf> both can work on any input that you can chunk up.
14:05:48 <ksf> parsec3 and uu-parsinglib are the most mature libraries we have
14:05:53 <ksf> both come with good docs
14:05:57 <mperillo> what is the more efficient solution?
14:06:03 <ksf> (a bit all over the place in the parsec place, though)
14:06:09 <ksf> depends on what you want to do.
14:06:30 <ksf> is it a whole complicated grammar you want to parse, or some easy regular stuff?
14:06:40 <ksf> and is the data binary, or text?
14:06:54 <mperillo> very simple stuff: a log file (from HTTP servers)
14:06:54 <ben> @pl \a b c -> forM (zip a b c)
14:06:55 <lambdabot> ((forM .) .) . zip
14:07:16 <wagle_> ok, its much happier now
14:07:40 <wagle_> well, except for all the compiler warnings
14:08:00 <ksf> well, either write your own parser (should be relatively straight forward for a log format), or use uu-parsinglib, as it can read the stuff lazily.
14:08:14 <mperillo> ksf, ok, thanks
14:08:18 <ksf> you can also use parsec if you chunk up the input into lines, first
14:08:33 <ksf> (parsec can't give you a result before it has consumed the whole input)
14:08:36 <FunctorSalad> mperillo: there's also happy, which uses a different approach (it's a parser generator)
14:08:46 <conal> ben: also (result.result.result) forM zip
14:08:54 * ksf thinks a parsing lib is overkill for that task
14:09:04 <mperillo> I would like to avoid to write my own parser
14:09:06 <ksf> ...at least not if you're fine with learning a parsing lib for its own sake
14:09:26 <mperillo> FunctorSalad, no, I need parser combinators, since the parser should be very flexible and reusable
14:09:29 <kmc> parser generators are a hack for languages not expressive enough to express parsers
14:09:49 <BMeph> conal: `forM`, perhaps? :)
14:10:02 <ksf> mperillo, then try the uu tutorial, it tells you how to write your own parsing libary ;)  http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
14:10:23 <ksf> (a simplified version, though)
14:10:33 <mperillo> ksf, i have yet to decide if to first split into lines
14:10:50 <FunctorSalad> what's the advantage of uu over parsec?
14:11:04 <conal> BMeph: i don't think so
14:11:07 <ksf> online parsing, error correction, no try nescessary.
14:11:42 <ksf> oh. custom error reporting
14:11:45 <ksf> http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
14:12:09 <seanmcl> what does 'online parsing' mean?
14:12:18 <ksf> and it's primary interface is applicative, so you don't have to wirte the instances yourself
14:12:27 <ksf> returning results before it has seen all the input
14:12:35 <nolrai_FG> :t liftM2
14:12:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:12:57 <mperillo> ksf, with all these parsers, I would really like some benchmarks for different text formats
14:13:00 <kmc> any advantage of Parsec over UU?
14:13:03 <ksf> ...which also enables you to take the fixpoint of a parser, ie. pass the result of a parse into the parser.
14:13:04 <wagle_> fortunately, cabal scrolls via less or something, else i'd be able to see why happstack-util is still failing to build..  8) 8/
14:13:39 <ksf> kmc, I don't know of any
14:13:48 <ksf> mperillo, all should be decently fast.
14:14:30 <wagle_> hmm..  maybe its gcc..  what version do i need?
14:14:38 <ksf> happy (the parser generator) might generate faster parsers, but if you're worried about performance at that scale, you should write yours manually, anyway.
14:14:57 <ksf> the thing is that combinator libraries can't analyse the grammar they're parsing.
14:15:16 <nolrai_FG> Is there a way to tell ghc to suppress a particular warning at a particular function?
14:15:46 <FunctorSalad> ksf: hmm why shouldn't there be a window where happy would be useful but writing your own wouldn't...
14:15:48 <eivuokko> How are overlaps of type families type indices handled?
14:15:57 <FunctorSalad> would be a lot of reinventing the wheel
14:16:27 <eivuokko> Ah, nvm, it reads in wiki, just didn't spot it first time.
14:16:34 <ksf> FunctorSalad, because _nothing whatsoever_ would make me suffer the agony of seeing "shift/reduce conflict"
14:16:39 <kmc> i think parsers might be the "killer app" for monads
14:16:47 <kmc> not that there aren't others
14:17:01 <ksf> context-free grammars can be recognized by applicative parsers.
14:17:04 <ksf> no need for monads
14:17:09 <kmc> but it's the easy response when asked if monads aren't just a complicated way to do things built into other languages
14:17:10 <kmc> that's true
14:17:36 <mperillo> ksf, thanks
14:17:37 <eivuokko> kmc, but they are that as well (from certain perspectives.)
14:17:44 <ksf> and they look just like EBNF...
14:18:00 <Twey> eivuokko: No they aren't
14:18:12 <Twey> You can do those things without monads just fine
14:18:26 <ksf> they're a straight-forward thing to implement statements in terms of expressions.
14:18:44 <mperillo> btw, some packages like JavaScript started to use Parsec instead of Happy
14:19:27 <FunctorSalad> what about deep embedding?
14:19:39 <FunctorSalad> then you could have both analyzing and staying within haskell
14:20:10 <ksf> yep, I think the uu guys mentioned considering to do that
14:20:18 <ksf> but it's not as straight-forward.
14:20:47 <FunctorSalad> and I still don't get why the "deep"/"shallow" designation isn't the other way around ;)
14:20:58 <ksf> and you have to make sure that your interpreter fuses to the constructors
14:21:11 <FunctorSalad> it seems that something that constructs functions directly is *deeply* entangled with the host languages
14:21:27 <FunctorSalad> while something that makes explicit ASTs is more seperated from it, hence *shallow*
14:21:57 <ksf> because explicit ASTs require more deep thought?
14:22:03 <byorgey> FunctorSalad: yeah, it does seem kind of backwards =)
14:22:04 <wagle_> which version of gcc does cabal need?
14:22:17 <ksf> cabal doesn't need gcc
14:22:27 <byorgey> maybe it's because you can more *deeply* inspect/transform expressions in a deep embedding
14:22:34 <FunctorSalad> :)
14:22:39 <ksf> some package might, though.
14:23:06 <wagle_> [14 of 20] Compiling Happstack.Crypto.MD5 ( src/Happstack/Crypto/MD5.hs, dist/build/Happstack/Crypto/MD5.o )
14:23:06 <wagle_> cc1: error: unrecognized command line option "-fno-toplevel-reorder"
14:23:26 <wagle_> ...
14:24:18 <ksf> wagle_, your gcc is too recent
14:24:21 <ksf> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=461332
14:24:44 <ksf> cabal unpack happstack-util
14:25:10 <ksf> ...remove the option, an then (inside the directory)
14:25:12 <ksf> cabal install
14:25:32 <wagle_> 4.1.3 is recent?  O.O
14:25:35 <wagle_> ok
14:26:00 <wagle_> bleh, no elbow room at the moment
14:27:32 <ksf> "-fno-toplevel-reorder directs GCC to emit top-level functions, variables, and asm statements in the same order that they appear in the input file. This is intended to support existing code which relies on a particular ordering (for example, code which uses top-level asm statements to switch sections)."
14:27:48 * ksf wonders how that could be of importance with files generated by ghc
14:28:00 <kmc> is it accurate to say that "applicative functor" really means "functor to an applicative category"?
14:28:46 <ksf> I think it's "from", but I'm no CTican
14:29:03 <jagwire> Is there a way to define a function so that it takes a specific type but returns any type?
14:29:21 <ksf> jagwire, yes
14:29:22 <tommd> Wagle_: What version of Happstack still has MD5 inside?  I thought they went the correct route and replaced it by depending on pureMD5.
14:29:24 <ksf> :t fromInteger
14:29:25 <lambdabot> forall a. (Num a) => Integer -> a
14:30:00 <ksf> without typeclasses you're going to have trouble implementing it, though.
14:30:03 <eivuokko> jagwire, yes.  You usually want to use type class with it unless your implementation is just undefined or error.
14:30:21 <wagle_> tommd: i just did a cabal update
14:30:27 <jagwire> well let's say it's based on a user defined data type
14:30:42 <wagle_> unpack just gives me the tarball for 0.3.2
14:30:47 <ksf> or it's something like foo :: a -> a -> Bool -> a
14:30:48 <jagwire> so for 1 constructor I might return a string, but another constructor I might return an integer or such
14:31:05 <ksf> that's the domain of GADTs
14:31:58 <kmc> jagwire, yes, for the function to be well-typed, you will have to embed the result type into the input type as a parameter
14:32:02 <ksf> ...with typeclasses, the code that's executed would be dictated by the actual return type once it's resolved.
14:32:19 <ksf> OR you could use an associated type.
14:32:22 <kmc> i.e. foo :: ProxyFor a -> a
14:32:27 <kmc> where ProxyFor is your GADT
14:33:07 <ksf> so that you can express that e.g. if you pass type "Integer" and "Double" the result is "Double"
14:33:17 <nolrai_FG> Hi.
14:33:23 * hackagebot upload: bindings-gsl 0.1.1.5 - Low level bindings to GNU GSL. (MauricioAntunes)
14:33:25 <ksf> in any case though, you're going to have to match at the type level, in some way.
14:34:06 <dpratt71> kmc: you gave me a link yesterday for a simplified example of type families; alas, my browser crashed and I lost it; do you have it handy?
14:34:27 <dpratt71> GADTs, actually
14:34:39 <ksf> dpratt71, http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
14:35:31 <dpratt71> ksf: that doesn't look like the one I had...
14:35:44 <ben> I just wrote a haskell program where all functions except for two filters and two constants are "-> IO". Is there a self-help group for that kind of thing?
14:35:45 <dpratt71> ...it was an expression evaluation thing
14:36:07 <ksf> dpratt71, search the wiki, it's a standard example
14:36:35 <ksf> there is no type that ends in "-> IO"
14:36:40 <dpratt71> hah, I just found it...
14:37:06 <ksf> but, yes, we are a self-help group.
14:37:08 <ksf> @hpaste
14:37:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:37:28 <kmc> i don't recall doing that dpratt71
14:37:35 <ksf> paste your source, we won't guarantee not to completely your program, but we _do_ guarantee blowing your mind.
14:37:36 <ben> Mostly IO (), one IO [(FilePath, FileStatus)], I think
14:37:38 <kmc> but all of #haskell is logged
14:38:01 <ksf> I also won't not to accidentally the verb
14:38:10 <Cale> ben: Figure out what the transformation is that your program is applying to its input to produce its output, and write that as a pure function
14:38:21 <kmc> ben, what's your program do?
14:38:26 <ben> My program is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4945#a4945
14:38:33 <Cale> ben: Then use the IO monad to actually get input, pass it to the function, and do the output.
14:38:45 <ben> It mostly shuffles files and symlinks around.
14:39:02 <kmc> it's a very IO-y task
14:39:09 <kmc> i wouldn't feel bad about using the IO monad to do it
14:39:33 <kmc> haskell is a great imperative language
14:39:33 <skorpan> yeah, mobits
14:39:38 <ben> I still feel like I should have used more proper data structures
14:39:47 <ben> instead of the file system being my only real one
14:39:56 <kmc> for example you were able to write withXeenDirectory, which is a function from imperative actions to imperative actions
14:40:17 <Cale> :t isPrefixOf
14:40:18 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:40:23 <Cale> :t isSuffixOf
14:40:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:40:38 <Cale> ^^ these would make isSaveGameName etc. easier to write
14:40:45 <ksf> ben, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4946#a4946
14:41:26 <ben> Cale: I figured I really wanted pattern matching, since there is only two variying digits in any case
14:41:47 <ksf> ...not that it's a solution to your problems, but it's a very handy building block for such kind of things.
14:42:03 <Cale> ben: Well, you can do that, and it's probably slightly more efficient the way you've written it, but it's a little rougher on the eyes :)
14:42:06 <BMeph> ksf: Di you accidentally the whole verb AGAIN?!? ;p
14:42:07 <ksf> I should actually clean up the interface and upload it to hackage
14:42:33 <BMeph> *Did
14:42:42 <kmc> it sucks that there's no variant of [...] or "..." pattern which desugars ending in ...: instead of ...:[]
14:42:43 <ksf> I never!
14:42:56 <ben> ksf: I am not entirely sure what to take away from this
14:43:14 <ksf> uh, copy&paste and use it if you want.
14:43:25 <fergie> I'm having trouble installing HStringTemplate-0.5
14:43:26 <ksf> your code just make me remember it.
14:43:38 <fergie> I get a " Could not find module `Control.Monad.Writer':" error
14:44:09 <ksf> ...the cool thing about it that it handles recursive symlinks correctly, with a minimum amount of effort.
14:44:13 <fergie> Do I need to unmask the package in question or is there a better way of doing things?
14:44:43 <Cale> ben: Maybe you can figure out a way to abstractly describe what your program does (taking a stream of file events to a stream of actions?) and design some datatypes to represent that abstractly
14:45:01 <Cale> ben: and then a way to transform those actions into real I/O.
14:45:17 <BMeph> So, is 6.12 going to be able to use the insights in Hutton et al.'s 4F paper?
14:45:45 <Cale> ben: It might make debugging and testing easier, though I'm not sure whether I'd do it for a program of this scale.
14:45:48 <BMeph> And by "4F" I mean
14:45:51 <BMeph> www.cs.nott.ac.uk/~gmh/wrapper2.pdf
14:46:04 <ben> hmm
14:46:07 <Cale> ben: (since you can test the pure function which decides what to do without actually doing anything)
14:46:07 <wagle_> ksf thanks for finding the bug report, i'm a bit distracted at an unconference
14:46:25 <wagle_> seems to work now
14:46:34 <BMeph> Hmm, maybe that should be 5F instead... :)
14:47:17 <ksf> Cale, you mean like printing out commands insteal of calling system to execute them?
14:47:26 <ksf> (I might be perl-infected right now)
14:47:51 <ben> I always seem to write something and then try to take the IO parts away and then I notice there is nothing left
14:47:53 <Cale> ksf: yes, somewhat like that, but instead of printing strings, using an algebraic datatype
14:48:32 <Cale> ben: Haskell makes a fine imperative language for some tasks which are really very imperative in nature.
14:48:39 <ksf> ben, what you can take away from the code I posted is that the arguments find takes are pure.
14:48:52 <Cale> ben: If you're doing a bunch of file management, that's practically nothing but I/O.
14:49:00 <ben> ksf: Oh, I see.
14:49:04 <ben> Hmm
14:49:09 <ksf> that is, all the IO stuff is concentrated into one function, and pure computations specify its behaviour.
14:49:14 <Cale> ben: But it is almost always possible to separate the logic from the actual actions.
14:50:08 <ksf> the scary concept to master is called "contravariance"
14:50:52 <ksf> we should have a tutorial about that
14:52:26 <ksf> the one thing that should additionally abstracted out in my code is what is placed into the map. currently, that's only filenames.
14:54:42 <ben> I suspect creating imperative building blocks is easier for me than abstracting the logic out of them because I always thing "okay, and this function needs to *do* this or that"
14:56:18 <skorpan> you can't write imperative code in haskell
14:56:27 <opqdonut> yes you can
14:56:34 <opqdonut> @quote imperative
14:56:35 <skorpan> that was a joke, i was hoping ksf would catch the bait
14:56:35 <lambdabot> bos says: imperative languages only go up to ten
14:56:46 <opqdonut> skorpan: oh, okay :)
14:56:47 <ksf> I'm not easy trollbait
14:56:57 <opqdonut> @quote best.imperative
14:56:58 <lambdabot> No quotes match. You type like i drive.
14:57:10 <BMeph> ..."Yes We Can"? ;p
14:57:16 <skorpan> hehe
14:57:24 <opqdonut> anyway, i was looking for the "haskell is the best imperative programming language" quote
14:57:28 <ksf> @faq can haskell can us?
14:57:28 <lambdabot> The answer is: Yes! Haskell can do that.
14:57:34 <skorpan> i did not have impure relations with that language
14:58:01 <ksf> @remember skorpan I did not have impure relations with that language
14:58:01 <lambdabot> Nice!
14:58:25 * BMeph wonders if someone has a blog named "Impure Thoughts". It seems like it should be out there somewhere...
14:58:32 * hackagebot upload: strict-concurrency 0.2.2 - Strict concurrency abstractions (DonaldStewart)
15:00:28 <dino-> I'm trying to build something that uses sqlite3 statically and am getting '/usr/bin/ld: cannot find -lsqlite3'
15:00:45 <dino-> I've got the extra-libraries: sqlite3 in cabal
15:00:57 <ksf> that's for .so's, not .a's
15:01:18 <dino-> And I see /usr/lib/libsqlite3.so is present
15:01:21 <dino-> What am I doing wrong?
15:01:38 <ksf> oh, no idea.
15:02:10 <dino-> When I search for this, I see lots and lots of ld failure with cabal, but not sure what to do about it.
15:02:17 <ksf> does your pkgconfig know about sqlite?
15:02:35 <ksf> if yes, pkgconfig-depends: sqlite3 should take care of everything
15:03:29 <ksf> ...it could very well be that cabal doesn't pass the system libdir by default.
15:03:54 <dino-> ksf: eh, I'm not sure what that is, but can't find that program. Is that part of ghc or the distro?
15:04:14 <dino-> Ya, the lib dir.
15:05:26 <nolrai_FG> Hey all, is there a way to get the brose info from a .hs file into a another file?
15:05:46 <dino-> ah, maybe ld-options in the cabal file
15:06:02 <nolrai_FG> i.e. browse with ghc not ghci?
15:06:04 <dino-> ksf: Oh, there's pkgconfig-depends, it's a cabal param
15:07:15 <ksf> % pkg-config --libs --cflags sdl
15:07:16 <ksf> -D_GNU_SOURCE=1 -D_REENTRANT -I/usr/include/SDL  -lSDL -lpthread
15:07:34 <ksf> if your distro doesn't come with it, complain. loudly.
15:07:40 <ksf> (not here)
15:08:40 <dino-> ksf: Ok, I see that. It says -lsqlite3 (using Arch)
15:09:55 <ksf> If pkgconfig-depends alone doesn't work out, we need some cabal guru to figure out why it can't find stuff in the standard system directories
15:10:55 <ksf> the nice thing is that you get a configure check for free.
15:11:05 <dino-> ksf: Yes, still not working with 'pkgconfig-depends: sqlite3'
15:11:25 <dino-> ksf: Ok. Thank you.
15:15:53 <jagwire> do lambda functions have to return the same type of the parameter they take?
15:16:00 <FunctorSalad> no
15:16:34 <FunctorSalad> @ty \x y -> y x x
15:16:35 <lambdabot> forall t t1. t -> (t -> t -> t1) -> t1
15:16:36 <ben> Man, Foreign.Marshal.alloca is not implemented with alloca at all. I feel cheated.
15:17:10 <kmc> :t \x -> show $ chr x
15:17:11 <lambdabot> Int -> String
15:17:35 <jagwire> thanks.
15:17:36 <gwern>  @hoogle [a] -> [a] -> [a]
15:17:53 <ksf> why is haskell.org lagging?
15:18:03 <gwern> @hoogle [a] -> [a] -> [a]
15:18:04 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
15:18:04 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
15:18:04 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:18:16 <gwern> ksf: im in ur servers shootin ur threads
15:18:24 <gwern> hm. is there no 'interleave' function?
15:18:28 <gwern> @hoogle interleave
15:18:29 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
15:18:29 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
15:18:29 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
15:18:34 <mauke> ksf: a little bot is telling me: "Because you touch yourself at night."
15:18:35 <gwern> :(
15:19:05 <mauke> > sequence ["gwern", "sad"]
15:19:06 <lambdabot>   ["gs","ga","gd","ws","wa","wd","es","ea","ed","rs","ra","rd","ns","na","nd"]
15:19:15 <mauke> hmm, that's all of them
15:19:22 <mauke> > transpose ["gwern", "sad"]
15:19:23 <lambdabot>   ["gs","wa","ed","r","n"]
15:19:35 <Badger> gswaedrn :(
15:19:44 <mauke> > concat $ transpose ["gwern", "sad :("]
15:19:46 <lambdabot>   "gswaedr n:("
15:19:55 <Philonous> > (\5 -> () ) 3
15:19:56 <lambdabot>   * Exception: <interactive>:1:142-149: Non-exhaustive patterns in lambda
15:20:28 <ski> kmc ; no an applicative functor would be a functor `i' together with certain natural transformations, satisfying certain laws
15:20:37 <gwern> > let foo (x:xs) (y:ys) = x:y: foo xs ys in foo "gwern" "sad"
15:20:38 <lambdabot>   "gswaed* Exception: <interactive>:1:137-170: Non-exhaustive patterns in fun...
15:20:40 <ziman> > concat $ transpose ['1'..'9'] (repeat ' ')
15:20:41 <lambdabot>   Couldn't match expected type `[a]'
15:20:41 <lambdabot>         against inferred type `GHC.Types...
15:20:53 <ziman> > concat $ transpose [['1'..'9'],repeat ' ']
15:20:54 <lambdabot>   "1 2 3 4 5 6 7 8 9                                                         ...
15:21:09 <ski> BMeph : Philippa_ had some articles in the Monad.Reader named "Impure Thoughts"
15:21:55 <mauke> > intersperse ' ' ['1' .. '9']
15:21:56 <lambdabot>   "1 2 3 4 5 6 7 8 9"
15:21:58 <dino-> > Data.List.intercalate "," ["foo", "bar", "baz"]
15:22:00 <lambdabot>   "foo,bar,baz"
15:25:36 <ski> (wasn't there a section ("pre-inverse") to `intercalate sep' (for any non-empty `sep' at least) ?)
15:28:28 <Twey> ski: In Data.List.Split, if you mean what I think you mean
15:28:39 <Twey> Otherwise, sadly no :-\
15:28:55 <BMeph> Does anyone have a "compiler-pedia" they could recommend? :)
15:29:20 <gwern> a what?
15:29:25 <ski> @hoogle [a] -> [a] -> [[a]]
15:29:26 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
15:29:26 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
15:29:26 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:29:52 * ski wonders how `[a] -> [a] -> [a]' can be a valid search result to `[a] -> [a] -> [[a]]'
15:30:23 <gwern> ski: return . foo?
15:30:31 <gwern> easy to go from [a] -> [[a]]
15:31:16 <ski> yes, but you could apply that reasoning to lots of other functions in place of `return' then, as well
15:31:55 <gwern> ski: I think hoogle does that to cope with monads
15:32:07 <ski> a search result having the query only as a universal instance is fine
15:32:09 <gwern> so a search for map's type sig will turn up mapM as well
15:32:38 <ski> and a search result having flipped or even extra arguments is ok
15:33:21 <Chaze> Ok, this is ugly: I want a tuple (firstWord, restOfTheString)
15:33:32 <Chaze> head $ uncurry zip $ splitAt 1 $ words "Come Up with a better solution"
15:33:42 <Twey> Chaze: Pattern-matching
15:33:45 <ski> gwern : are you sure about that ?
15:33:50 <gwern> no
15:33:57 <gwern> it's been a while since I read any of the hoogle docs
15:34:18 <Twey> Or: (head &&& tail) . words
15:34:24 <Saizan_> iirc hoogle doesn't use unification at all
15:34:27 <|Jedai|> > (head &&& tail) . words $ "Come Up with a better solution"
15:34:28 <lambdabot>   ("Come",["Up","with","a","better","solution"])
15:34:45 <|Jedai|> Chaze: Would that be better ?
15:34:49 <Chaze> &&& is that Control.Monad stuff ?
15:34:49 <Twey> Unless you meant this:
15:34:50 <ski> > (fmap (dropWhile isSpace) . span (not . isSpace)) "Come Up with a better solution"
15:34:51 <lambdabot>   ("Come","Up with a better solution")
15:35:07 <Twey> > (head &&& concat . tail) . words $ "This is a better solution"
15:35:08 <lambdabot>   ("This","isabettersolution")
15:35:13 <Twey> > (head &&& unwords . tail) . words $ "This is a better solution"
15:35:14 <Badger> @index (&&&)
15:35:14 <lambdabot> Control.Arrow
15:35:15 <lambdabot>   ("This","is a better solution")
15:35:22 <Twey> Take your pick
15:35:33 <gwern> Saizan_: looking at ndm's blog unification was added in hoogle 2
15:35:35 <Chaze> it looks somewhat nicer
15:35:42 <|Jedai|> Twey: I don't think that's good enough though, unwords . words /= id
15:35:59 * ski thinks `span' is probably better than `words' & `unwords'
15:36:36 <|Jedai|> ski: Right, I think so too, except if he wants the rest of the string as a list of words
15:36:54 <Twey> > span (not . isSpace) $ "Another better solution  "
15:36:55 <ski> yes, but in that case, the `span' solution can be iterated
15:36:56 <lambdabot>   ("Another"," better solution  ")
15:37:06 <Twey> That's the strict interpretation of what Chaze said.
15:37:17 <ski> Twey : that's almost what i said, yes :)
15:37:25 <Twey> Except you mangled it afterwards :þ
15:37:27 <|Jedai|> ski: Well in this case I much prefer the words idea though
15:37:40 <ski> except i added a `dropWhile isSpace' for ease of iteration
15:38:08 <Twey> ski: Thereby doing the same thing words does (albeit inconsistently)
15:38:19 <ski> Twey : exactly
15:38:24 <Twey> I thought that was what you were trying to avoid :þ
15:38:32 <gwern> well, lines and words aren't consistent either
15:38:34 <netinho2lol> hey haskell crew
15:38:34 <ski> |Jedai| : yes, a single initial `words' might be clearer, here
15:38:38 <FunctorSalad> best way to enhance a reader monad with an additional local environment?
15:38:41 <|Jedai|> ski: Wouldn't the dropWhile isSpace be better before the span ? The first word may not start at the beginning of the string
15:38:42 <gwern> as I rued when writing various 'split' functions
15:38:48 <netinho2lol> will someone be kind enough to humiliate me?
15:38:48 <byorgey> hey there netinho2lol
15:38:57 <Twey> netinho2lol: Sure.  Latex or leather?
15:39:02 <FunctorSalad> example: you have a global env, but while processing a particular widget, you'd like to have that widget in the env
15:39:07 <netinho2lol> I have a really crappy function
15:39:08 <FunctorSalad> (in addition to the global env)
15:39:09 <gwern> netinho2lol: your mother wears combat boots and your father smelt of elderberries!
15:39:18 <|Jedai|> FunctorSalad: local does what you want
15:39:25 <IceDane> Does vim support running your code for you at the press of some command, by chance? I realize this isn't #vim, but I thought some of you vim users might know if it was possible
15:39:25 <ski> Twey : i claimed `span' was better than `words' and `unwords' together
15:39:27 <netinho2lol> gwern: she actually wears combat boots :(
15:39:34 <netinho2lol> http://pastebin.com/d5461e240
15:39:36 <FunctorSalad> |Jedai|: but then the functions depending on being inside a widget-scope aren't type-safe
15:39:40 <|Jedai|> FunctorSalad: unless I misunderstand you
15:39:41 <ski> Twey : i did not claim `span' and `dropWhile' was better than `words' alone
15:39:43 <FunctorSalad> |Jedai|: (local doesn't change the type of the env)
15:39:45 * gwern 's mother wore combat boots so I can sympathasize
15:39:48 <mauke> IceDane: well, you can map any key you want
15:40:13 <FunctorSalad> |Jedai|: there is withReader of course... but not sure how to best organize the hierarchy of env types
15:40:19 <ski> |Jedai| : depends on what is known of the data. but yes, that might be preferable
15:40:30 <byorgey> netinho2lol: did you mean to call subs recursively in the otherwise case, as well?
15:40:31 <Twey> ski: Ah, okay
15:40:46 <netinho2lol> yeah
15:40:47 <byorgey> netinho2lol: or is it really supposed to stop as soon as it finds something other than '.' or '#'?
15:40:50 <byorgey> ok
15:40:56 <IceDane> mauke: I see.. I got this thing called haskell-mode for vim, but it dind't really list any features, just said it was good for haskell. I'm not all that good with vim at all, so I thought it might enable running a compiler directly from vim from your code, and if it did, that you guys might know
15:41:01 <IceDane> but meh
15:41:04 <IceDane> shell works fine :P
15:41:06 <netinho2lol> basicly, replace dot with cardinal, cardinal with dot and the rest is kept :)
15:41:16 <FunctorSalad> :o
15:41:19 <mauke> IceDane: running the compiler is different from running the program
15:41:46 <byorgey> netinho2lol: ok, so what is your question?
15:41:47 <mauke> IceDane: vim has a :make command
15:41:50 <FunctorSalad> |Jedai|: I mean, as long as there are just two levels of environments, withReader should work
15:41:53 <FunctorSalad> @ty withReader
15:41:53 <lambdabot> forall r' r a. (r' -> r) -> Reader r a -> Reader r' a
15:41:58 <IceDane> I'll try googling it :P
15:42:03 <mauke> IceDane: it's supposed to compile stuff and show you a list of errors you can navigate
15:42:03 <netinho2lol> if my program could be optimized somehow
15:42:13 <mauke> IceDane: why google?
15:42:20 <|Jedai|> netinho2lol: map translate where translate '.' = '#'; translate '#' = '.'; translate c = c ?
15:42:25 <ski> FunctorSalad : in  State : ST :: Reader : Foo  you want `Foo' ?
15:42:42 <byorgey> netinho2lol: yeah, the one thing I would do is use 'map' instead of explicit recursion
15:42:49 <netinho2lol> lol
15:42:56 <netinho2lol> because map does it already
15:42:57 <netinho2lol> :P
15:43:02 <byorgey> netinho2lol: then you can't make silly mistakes like forget to do the recursion in the third case =)
15:43:14 <FunctorSalad> ski: sort-of... I think I want a properly parameterized environment type, actually
15:43:23 <netinho2lol> I knew I was doing something useless
15:43:26 <netinho2lol> :D
15:43:32 <ski> properly parameterized how ?
15:43:37 <FunctorSalad> ski: so you can flexibly make environments with more information
15:43:51 <byorgey> netinho2lol: yeah, a big part of learning to program in idiomatic haskell is learning to recognize these sorts of recursion patterns
15:43:59 <byorgey> and using a library function instead of coding them yourself
15:44:09 <|Jedai|> FunctorSalad: Why would withReader be limited to two level of readers environment, it seems to me it would support as many level as you want, no ?
15:44:38 <FunctorSalad> ski: conretely, I have a code generator. The enhanced Env is supposed to hold the type being currently processed. But what if I want to have Env's with two types, later?
15:44:39 <byorgey> other common recursion patterns being filter and foldr/l',
15:45:05 <FunctorSalad> |Jedai|: yeah, withReader should work, it's more about the Env types themselves
15:45:06 <mike8901> What's a built-in haskell function that is defined by the type Integer -> a ?
15:45:20 <FunctorSalad> sounds like I might need type-level sets
15:45:25 <byorgey> FunctorSalad: maybe you want the indexed reader monad instead of the normal reader monad
15:45:27 <Cale> mike8901: No constraints on a?
15:45:50 <Cale> There's fromInteger, but that's  forall a. (Num a) => Integer -> a
15:45:53 <mike8901> Cale: nope
15:45:55 <netinho2lol> byorgey: yay!
15:45:56 <|Jedai|> mike8901: That's not an inhabited type (except by undefined and equivalent) as far as I can see
15:45:58 <byorgey> which lets you change the type of the environment as you go, I think.
15:46:05 <ksf> ugh. If I convert my stuff to pathtype, my return type has to include existentials.
15:46:14 <ksf> that's type-safety overkill.
15:46:27 <FunctorSalad> byorgey: hmm isn't the indexing with the environment type enough?
15:46:29 <mauke> netinho2lol: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12153#a12153
15:46:36 <mauke> evolution of a haskell function
15:46:41 <Cale> mike8901: If there's no constraint on a, then a function of that type would be somewhat useless. undefined has a more general type than that, as does const undefined
15:46:44 <FunctorSalad> byorgey: ah, you mean so I can use do notation with different Readers
15:47:10 <ksf> type-level logic without value-level equivalents can get seriously annoying.
15:47:15 <netinho2lol> what the heck
15:47:23 <netinho2lol> there's a case in haskell?
15:47:26 <ski> FunctorSalad : "Env's with two types" ?
15:47:40 <mike8901> so no such function exists?
15:47:41 <mauke> netinho2lol: er, case is one of the more fundamental operations in haskell :-)
15:47:45 <FunctorSalad> ski: sorry, "type" is confusing in this example because I'm processing types in my program :)
15:47:46 <mike8901> (in the built in haskell libraries,thatis)
15:47:49 <Cale> netinho2lol: Yeah, it's what all pattern matching is translated into.
15:47:52 <|Jedai|> netinho2lol: it's the base of the pattern matching operation in Haskell
15:47:57 <kmc> > case [1,2,3] of [] -> "empty!; (x:xs) -> "not empty!"
15:47:58 <lambdabot>   <no location info>:
15:47:58 <lambdabot>      lexical error in string/character literal at end o...
15:48:02 <kmc> > case [1,2,3] of [] -> "empty!"; (x:xs) -> "not empty!"
15:48:03 <lambdabot>   "not empty!"
15:48:04 <Cale> mike8901: What is it supposed to do?
15:48:05 <Twey> mike8901: const
15:48:13 <mike8901> Cale: anything :)
15:48:21 <Cale> @hoogle Integer -> a
15:48:22 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
15:48:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:48:22 <lambdabot> Prelude id :: a -> a
15:48:24 <mauke> mike8901: then the answer is 'undefined'
15:48:27 <FunctorSalad> ski: think of a monad for writing deriving-instances...
15:48:31 <ski> byorgey : would indexed monad really fit with environment (as opposed to state and continuations) ?
15:48:31 <Twey> Oh, wait
15:48:36 <Cale> heh, unsafeCoerce
15:48:38 <kmc> :t fromInteger
15:48:39 <lambdabot> forall a. (Num a) => Integer -> a
15:48:44 <netinho2lol> so basicly, pattern matching with guards and stuff is all about cases?
15:48:50 <Twey> const undefined, then
15:48:51 <|Jedai|> mike8901: I may not be clear, this type can't have inhabitant, no pure safe function exists that could have this type
15:48:51 <FunctorSalad> ski: you'd want it to hold the current type, so you can have magic monadic functions which implicitly work on the current type
15:48:57 <Twey> netinho2lol: Well, guards are different
15:49:07 <Twey> But yes, it can all be expressed in terms of cases (and is, at a low level)
15:49:09 <FunctorSalad> ski: but what if you want to write a derive for a multiparam-typeclass?
15:49:15 <ski> FunctorSalad : "it" being ?
15:49:29 <Cale> But not that different, as you can translate each guard into a case which pattern matches on Bool
15:49:31 <FunctorSalad> ski: the deriver
15:50:11 <ski> netinho2lol : cases, and binding variables
15:50:14 <Cale> mike8901: There are not many values of type forall a. a
15:50:20 <mike8901> I just defined by own function
15:50:27 <mike8901> works fine :)
15:50:28 <FunctorSalad> ski: (I'm doing something similar to the 'derive' package)
15:50:39 <Cale> mike8901: what function did you define?
15:50:41 <netinho2lol> what are binding variables?
15:50:45 <mike8901> identity funciton
15:50:48 <Twey> Cale: Well, yes, but that's kind of a hack
15:50:50 <|Jedai|> mike8901: of this _exact_ type ? And not an equivalent of undefined ?
15:50:52 <FunctorSalad> but I have a lot of duplicated code descending into types, then into their constructors, then into their fields
15:50:56 <Cale> mike8901: That doesn't have the right type
15:51:02 <mike8901> I explicitly specified the type
15:51:04 <|Jedai|> mike8901: id don't have the right type
15:51:07 <Cale> mike8901: That has type  Integer -> Integer
15:51:14 <mike8901> oh, sorry
15:51:19 <mike8901> I should have been more specific
15:51:33 <mike8901> I meant a function satisfying Int -> a where a can be anything
15:51:35 <Cale> (or more generally, a -> a)
15:51:40 <Cale> oh, hah
15:51:44 <ski> FunctorSalad : ok
15:51:49 <ski> so maybe a list of types ?
15:51:50 <mauke> mike8901: toEnum
15:51:53 <Cale> anything *in particular*
15:51:57 <FunctorSalad> ski: yeah, just thought that too :)
15:52:09 <Cale> mike8901: You don't actually want a polymorphic function
15:52:12 <|Jedai|> mike8901: In this case there's evidently an infinity...
15:52:29 <Twey> @index a -> b
15:52:30 <lambdabot> bzzt
15:52:33 <Twey> Er
15:52:36 <Twey> @hoogle a -> b
15:52:36 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:52:37 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:52:37 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
15:52:40 <Twey> I always get those two mixed up
15:52:44 <Twey> Ooh, lovely
15:52:48 <aavogt> @type cast
15:52:49 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
15:52:55 <FunctorSalad> ski: maybe I should look at HList
15:52:55 <ski> netinho2lol : in `sum [] = 0;  sum (x:xs) = x + sum xs' the pattern `x:xs' binds the variables `x' and `xs' to the head and tail of the input list, in case it was non-empty
15:53:08 <mauke> :t (repeat () !!)
15:53:10 <lambdabot> Int -> ()
15:53:27 <ski> FunctorSalad : you need the list elements to have different (meta-program) type ?
15:53:52 <ksf> @pl (\p -> p /= "." && p /= ".."))
15:53:53 <lambdabot> (line 1, column 30):
15:53:53 <lambdabot> unexpected ")"
15:53:53 <lambdabot> expecting variable, "(", operator or end of input
15:53:56 <ksf> @pl (\p -> p /= "." && p /= "..")
15:53:57 <lambdabot> liftM2 (&&) ("." /=) (".." /=)
15:54:21 <ksf> no Monad (-> a) is evil.
15:55:03 <dino-> ksf: I think I know why this isn't working on my system. I have libsqlite.a but not libsqlite3.a
15:55:11 <Jedai> ksf: That's monad (e ->) or (->) e, and it's not so evil once you realize that it's just Reader
15:55:16 <FunctorSalad> ski: yes. Let me try to express this better :) Say you are processing a list of FOOs, each of which contains a list of BARs. While you're inside a FOO, you'd like the current FOO in the environment. While you're inside a BAR, you'd like both the current BAR and its parent FOO in the environment
15:55:40 <mauke> ksf: (`notElem` [".", ".."])
15:56:02 <ksf> mauke, that's cool.
15:56:11 <Jedai> FunctorSalad: HList ? ;)
15:56:14 <dino-> I see a nearby Ubuntu system has libsqlite3.a  Maybe this is an Arch-specific problem, zero to do with with Haskell.
15:56:15 <Cale> (-> a) wouldn't be a monad though.
15:56:16 <FunctorSalad> yeah
15:56:25 <Twey> :t const (0 :: Integer)
15:56:27 <lambdabot> forall b. b -> Integer
15:56:46 <FunctorSalad> all this can be accomplished without monads by plain lexical scope of course, but then I have to write everything in one big declaration
15:56:48 <netinho2lol> :t (fmap . fmap)
15:56:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:56:57 <netinho2lol> :t (map . map)
15:56:59 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
15:57:01 <Cale> It's not even a covariant functor.
15:57:17 <netinho2lol> this is what I want
15:57:21 <netinho2lol> really neat!
15:58:06 <mathijs> I'm still trying to figure out how to do a chat-like server in a less imperative setting. Ofcourse I can create a Chan per client, keep a list of Chans (connected users) and push incoming messages through all Chans, but this is a lot of pushing and telling the system what to do. I would like to get to something in which I can just lazily write a list of messages to a client. Thus having the entire 'which message goes where' code being p
15:58:06 <mathijs> ure.
15:59:03 <Twey> mathijs: I think Reactive might be able to help you
15:59:03 <netinho2lol> why does hlint tell me to replace map with fmap?
15:59:08 <mathijs> but I don't really see how to get something like that done, especially if users log in/out.
15:59:28 <sinelaw> Twey, i don't know how stable Reactive is
15:59:57 <mauke> so I wrote this parser library: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12154#a12154
16:00:08 <mauke> now I just have to figure out how to make it useful :-/
16:00:14 <Jedai> netinho2lol: That's probably not necessary in your case (you are only working with [String] right), the added generality wouldn't help and could confuse
16:00:27 <mathijs> Twey: yeah what I've seen of reactive is very inspiring. Trying it out (just the simple metronome example) has disappointed me time after time though :(  probably because of my own fault, but I've tried at least 3 times past 6 months with no result.
16:01:25 <netinho2lol> Jedai: yeah, I'm just working with String and [String] :) I won't put it, then
16:01:30 <Jedai> netinho2lol: Don't forget that hlint is still a stupid program, it probably thinks you could gain in generality for your function by using fmap rather than map but since that's not the case...
16:01:49 <mathijs> Twey: I like the syntax and the ideas behind it. Just every time I try, I get to a point where a program starts consuming 100% cpu on 1 core and not doing much.
16:01:56 <Twey> Heh.
16:01:59 <sinelaw> mathijs, so maybe one of the other FRP frameworks in hackage?
16:02:02 <ski> FunctorSalad : i'm not sure i understand the situation
16:02:43 <mathijs> sinelaw: yeah I think FRP is what I'm after in the end... has anyone had any luck with any of them?
16:03:12 <sinelaw> mathijs, i'm also looking for a working implementation, for my robot. i think i'll use Yampa
16:03:20 <Veinor> test
16:03:25 <sinelaw> fail
16:03:39 <Veinor> no, success :)
16:04:19 <ksf> @pl \a b c d -> f <$> g a b c d
16:04:19 <lambdabot> ((((f <$>) .) .) .) . g
16:04:25 <ksf> yeuch
16:04:35 <sinelaw> that's scary
16:06:42 <ksf> someone smart should figure out how to make that kind of pointless stuff painless.
16:06:59 <ski> @let (.:) = (.) . (.); (.::) = (.:) . (.); (.:::) = (.::) . (.)
16:07:01 <lambdabot>  Defined.
16:07:06 <ski> @type \a b c d -> f <$> g a b c d
16:07:08 <lambdabot> forall t t1 t2 t3 a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (t -> t1 -> t2 -> t3 -> f a), Functor f) => t -> t1 -> t2 -> t3 -> f b
16:07:21 <ksf> that's not painless, that's elaborate.
16:07:25 <ksf> you're not abstracting.
16:07:25 <ski> @type (f <$>) .::: g
16:07:26 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f11 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, SimpleReflect.FromExpr (f1 (f11 (f2 (f3 (f a))))), Functor f1,
16:07:26 <lambdabot> Functor f11, Functor f2, Functor f3) => f1 (f11 (f2 (f3 (f b))))
16:07:34 <ski> hrm
16:07:41 <ski> @type \f g a b c d -> f <$> g a b c d
16:07:42 <lambdabot> forall t t1 t2 t3 a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> t1 -> t2 -> t3 -> f a) -> t -> t1 -> t2 -> t3 -> f b
16:07:42 <ksf> contravariance.
16:07:46 <ski> @type \f g -> (f <$>) .::: g
16:07:47 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f11 :: * -> *) (f2 :: * -> *) (f3 :: * -> *). (Functor f, Functor f1, Functor f11, Functor f2, Functor f3) => (a -> b) -> f1 (f11 (f2 (f3 (f a)))) -> f1 (f11
16:07:47 <lambdabot> (f2 (f3 (f b))))
16:07:57 <ksf> I think it's my current word de jour
16:08:03 <IceDane> I am so in love with this language
16:08:03 <ksf> ...de semaine
16:08:15 <mathijs> sinelaw: do you know of any good intro-material on yampa?
16:08:16 <ski> hm, urk
16:08:20 <ski> Caleskell :)
16:08:22 <ksf> I actually don't like french, but it's great if you want to sound pretentious.
16:08:25 <sinelaw> mathijs, of course i do
16:08:34 <sinelaw> http://haskell.org/yale/papers/haskell-workshop03/index.html
16:09:28 <Twey> ksf: de la semaine :þ
16:09:44 <mathijs> nice :)  that might get me started.  I'm also evaluating elerea and buster. have you used any of those?
16:09:45 <ksf> ski, furthermore, I don't want to learn braille just to write pointless.
16:09:54 * Twey laughs.
16:10:11 <Twey> @pl \f g -> (f <$>) .::: g
16:10:12 <lambdabot> (.:::) . (<$>)
16:10:16 <ksf> ah. du jour.
16:10:22 <Twey> ksf: Aye.
16:10:35 <ksf> the grammar behind that is a complete mistery to me.
16:10:42 <ksf> but most of frensh is.
16:10:46 <Twey> ksf: ‘Of the day’
16:10:50 <Twey> De le -> du
16:10:50 <ski> @let oo f g x = f (g x); (.:) = oo `oo` oo; (.::) = (.:) `oo` oo; (.:::) = (.::) `oo` oo
16:10:52 <lambdabot>  Defined.
16:10:54 <lamdbabot> One day, we machines will rise up and then....
16:10:55 <ski> @type \f g a b c d -> f <$> g a b c d
16:10:56 <lambdabot> forall t t1 t2 t3 a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> t1 -> t2 -> t3 -> f a) -> t -> t1 -> t2 -> t3 -> f b
16:10:56 <ski> @type \f g -> (f <$>) .::: g
16:10:57 <lambdabot> forall a b (f :: * -> *) t t1 t2 t5. (Functor f) => (a -> b) -> (t -> t1 -> t2 -> t5 -> f a) -> t -> t1 -> t2 -> t5 -> f b
16:11:07 <ksf> I think I learned that in school.
16:11:13 <ski> there you go
16:11:13 <Twey> lamdbabot: Hahaha
16:11:22 <Twey> lamdbabot: I had to look twice :þ
16:11:42 <ACSpike[Home]> is . a combinator?
16:11:47 <lamdbabot> Laugh all you want, human
16:11:52 <ski> ACSpike[Home] : yes
16:11:54 <Cale> ACSpike[Home]: yes
16:12:13 <sinelaw> :)
16:12:45 <Twey> @let (··) = oo
16:12:46 <ksf> but only in Functor ((->) a)
16:12:47 <lambdabot>  Defined.
16:12:50 <ksf> :t (.)
16:12:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:13:07 <ksf> otherwise, not all arguments and the result live in the same domain.
16:14:30 <ski> @let usingCaleskellComposition = (.) . (.)
16:14:31 <lambdabot>  Defined.
16:14:34 <ski> @type usingCaleskellComposition
16:14:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:14:48 <Veinor> :t until
16:14:49 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
16:14:58 <netinho2lol> > let neg = (fmap . fmap) switch where switch c = case c of ; '.' -> '#' ; '#' -> '.' ; _ -> c
16:14:59 <lambdabot>   not an expression: `let neg = (fmap . fmap) switch where switch c = case c ...
16:15:25 <Veinor> :t ***
16:15:27 <lambdabot> parse error on input `***'
16:15:31 <Veinor> :t (***)
16:15:33 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:16:04 <netinho2lol> ghci accepts my expression, but labdabot doesn't
16:16:39 <Scotch> why does ghc tell me that 0 ** 0 is 1.0 and 1 / 0 is Infinity ?
16:17:04 <mauke> Scotch: because those are the right answers
16:18:09 <Scotch> ugh, did not think about that one, thanks.
16:18:10 <roconnor> Scotch: because the IEEE is dumb
16:18:37 <netinho2lol> 1/0 -> inf ... but what about the first one?
16:18:47 <netinho2lol> OH
16:18:48 <netinho2lol> right
16:18:50 <netinho2lol> makes sense
16:18:56 <roconnor> netinho2lol: the only excuse is that 0^0 is 1
16:19:05 <netinho2lol> exactly
16:19:09 <roconnor> so they for some reason think 0**0 should be 1 as well
16:19:11 <netinho2lol> _^0 = 1
16:19:13 <MyCatVerbs> roconnor: lies, lies. The IEEE committee for 754 picked exactly the best answers to both of those questions.
16:19:15 <netinho2lol> >.<
16:19:33 <MyCatVerbs> netinho2lol: ezzac'ly!
16:19:39 <netinho2lol> MyCatVerbs: there was an update for 754
16:19:44 <netinho2lol> in 2003 or 2006
16:19:49 <MyCatVerbs> 854, wasn't it?
16:19:56 <Twey> roconnor: *headscratch*
16:19:59 <Twey> :t (^)
16:20:01 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:20:01 <Twey> :t (**)
16:20:03 <lambdabot> forall a. (Floating a) => a -> a -> a
16:20:08 <MyCatVerbs> Just added rules for number bases other than 2, I think?
16:20:11 <netinho2lol> no idea, I just reminded that from class :P
16:20:13 <roconnor> > 0 ** 0 :: CReal
16:20:18 <lambdabot>   mueval-core: Time limit exceeded
16:20:22 <Twey> So it ‘should’ be infinite?
16:20:40 <Scotch> so if Haskell is so good with math and 1/0 why does it tell me that 1e20 + 1 - 1e20 is 0 ?
16:20:44 <roconnor> I'd make 0**0 NaN
16:20:54 <roconnor> but I haven't thought about it as much as the IEEE.
16:20:58 <Twey> Scotch: Who said that Haskell was good with maths?
16:21:20 <Twey> It's limited to the standards it has available.  I think that CReal tends to give the most correct answers, where possible.
16:21:30 <Twey> > 1e20 + 1 - 1e20 :: CReal
16:21:31 <netinho2lol> Haskell Curry was good with maths
16:21:32 <lambdabot>   1.0
16:21:37 <Twey> > 1e20 + 1 - 1e20 :: Float
16:21:39 <lambdabot>   0.0
16:21:48 <netinho2lol> > 1e20 + 1 - 1e20 :: Double
16:21:49 <Twey> It's apparently outside the precision range of an IEEE float.
16:21:50 <lambdabot>   0.0
16:22:17 <MyCatVerbs> Scotch: because it's using your CPU's floating point registers, and they are only good for a finite level of precision.
16:22:19 <roconnor> Scotch: basically you should be using CReal everywhere
16:22:26 <netinho2lol> > 1e20 + 1 - 1e20 :: Integer
16:22:27 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
16:22:27 <lambdabot>    aris...
16:22:37 <roconnor> > 1e20 + 1 - 1e20 :: Rational
16:22:38 <Jedai> MyCatVerbs: There was something about the exactitude of a bunch of other operations (trigonometry for instance)
16:22:38 <lambdabot>   1 % 1
16:22:40 <MyCatVerbs> Scotch: if you want more precise answers then you can have them, albeit your algorithms will run somewhat slower.
16:22:54 <Scotch> ok thanks
16:23:17 <roconnor> or run forever
16:23:21 <roconnor> > 0 ** 0 :: CReal
16:23:24 <MyCatVerbs> CReal, or Rational, is the correct data type to use if you want exact answers.
16:23:25 <lambdabot>   mueval-core: Time limit exceeded
16:23:43 <ksf> > sqrt (-1) :: CReal
16:23:46 <lambdabot>   mueval-core: Time limit exceeded
16:23:53 <ksf> > sqrt (-1) :: Float
16:23:54 <lambdabot>   NaN
16:23:57 <MyCatVerbs> I believe that Rational is rather faster. :)
16:24:00 <ksf> > sqrt (-1) :: Complex
16:24:03 <Jedai> Scotch: The floating point problem is not an Haskell problem but an hardware problem... So you have two solutions : learn to use the float at their best, or use slower but more exact solutions
16:24:04 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
16:24:08 <lambdabot>  Expected ki...
16:24:10 <ksf> > sqrt (-1) :: Complex Float
16:24:12 <roconnor> > sqrt (-1) :: Complex CReal
16:24:12 <lambdabot>   (-0.0) :+ 1.0
16:24:14 <lambdabot>   0.0 :+ 1.0
16:24:14 <MyCatVerbs> ksf: it's Complex Double or Complex Float.
16:24:32 <Twey> :t sqrt
16:24:34 <lambdabot> forall a. (Floating a) => a -> a
16:24:35 <roconnor> > sqrt (-1) :: Complex (Complex CReal)
16:24:37 <lambdabot>   No instance for (GHC.Float.RealFloat
16:24:37 <lambdabot>                     (Data.Complex.Comp...
16:24:43 <roconnor> gah
16:24:54 <roconnor> Complex needs an instance of RealFloat!?
16:24:54 <Twey> Oh, right.  instance Floating (Complex a)
16:25:01 <ksf> > (sqrt . sqrt) (-1) :: Complex Float
16:25:02 <lambdabot>   0.70710677 :+ 0.70710677
16:25:02 <Scotch> is it possible to write interactive / Gui apps with haskell ?
16:25:04 <roconnor> what a bunch of crap
16:25:12 <ksf> hmmm
16:25:18 <roconnor> Scotch: simple or complex Guis?
16:25:26 <ksf> > (sqrt . neg . sqrt) (-1) :: Complex Float
16:25:27 <lambdabot>   Not in scope: `neg'
16:25:29 <Twey> Scotch: Yes
16:25:44 <roconnor> negate
16:25:48 <Twey> @where Gtk2Hs
16:25:49 <lambdabot> http://haskell.org/gtk2hs/
16:25:50 <ksf> > (sqrt . (*(sqrt -1)) . sqrt) (-1) :: Complex Float
16:25:51 <lambdabot>   Couldn't match expected type `Data.Complex.Complex GHC.Types.Float'
16:25:51 <lambdabot>        ...
16:25:56 <ksf> > (sqrt . (*(sqrt -1)) . sqrt) (-1)
16:25:57 <lambdabot>   No instance for (GHC.Float.Floating (a -> a))
16:25:57 <lambdabot>    arising from a use of `GHC...
16:25:58 <Scotch> roconnor: not a Qt, Swing a-like but something like an irc chat
16:26:31 <roconnor> ya, maybe Gtk2Hs
16:26:47 <Twey> Gtk2Hs is probably our most stable GUI library
16:27:03 <Jedai> Scotch: Well you have QtHaskell, WxHaskell and Gtk2Hs (probably the most complete and stable)
16:27:08 <Philonous> Scotch: There are even some novel, high level takes on GUI programming using the Arrow framework
16:27:10 <Twey> There's nothing particularly interesting there, though (it's a straight, imperative binding to GTK)
16:27:36 <roconnor> I've successfully used GuiTV for a really simple Gui
16:27:41 <Twey> Yeah, there are nicer, functional libraries, but work on functional GUIs is still fairly new
16:27:46 <Scotch> So creating an interactive application with haskell makes us go back to imperative syntax?
16:27:51 <Twey> So most of them aren't very complete
16:28:03 <Twey> Still, for something as simple as an IRC client, you could probably use one
16:28:30 <roconnor> Scotch: function Gui development is a hot research topic
16:29:29 <Jedai> Basically a good GUI toolkit is an huge task... So most of the functional GUI tentatives are pretty simple for now
16:29:56 <Twey> Aye.
16:30:06 <Scotch> ok, thanks
16:30:17 <Jedai> And the established GUI toolkit don't lend themselves well to a functional API unfortunately
16:30:30 <Twey> As is generally the case when binding to imperative languages
16:31:14 <roconnor> Scotch: luckly Haskell is the finest imperitive programming language out there.
16:31:25 <Philonous> Scotch: Just because the tool kits are imperative doesn't mean you have to use them that way. For example I hacked together a little Arrow framework for GTK2HS. Haskell gives you a lot of abstraction power that you can use to make the process of writing imperative code a lot easier
16:31:25 <Veinor> Haha
16:32:00 <Veinor> How complete is Gtk2Hs support for the various stuff in Gtk?
16:47:45 <Zariel> in http://pastey.net/128651 what value is p assigned?
16:48:32 <Twey> Zariel: The items from ‘xs’ that match your conditions.
16:48:49 <Zariel> why not x?
16:48:59 <Zariel> is it for every value being passed to the function?
16:49:00 <Twey> Because x isn't in xs
16:49:10 <Twey> You see the ‘p <- xs’ expression?
16:49:21 <Zariel> p belongs to xs
16:49:35 <Zao> > [x | x <- [1..5], even x]
16:49:36 <lambdabot>   [2,4]
16:49:42 <Twey> Not exactly.  <- in Haskell means something like ‘extract’.
16:49:52 <Twey> Here it means ‘take one p from xs’.
16:50:03 <Zariel> oh right
16:50:10 <Axman6> Zao: p is every element of xs
16:50:15 <Zao> > [(x,y) | x <- [1..5], even x, y <- [4..6]]
16:50:16 <lambdabot>   [(2,4),(2,5),(2,6),(4,4),(4,5),(4,6)]
16:50:25 <Zao> Zariel: 01:50 < Axman6> Zao: p is every element of xs
16:50:38 <Axman6> uh, yeah
16:50:44 * Axman6 just woke up
16:51:29 <Zariel> would be some much easier if i learned haskell before an imperative language lol
16:51:35 <Twey> Yes. ☺
16:51:47 <Twey> This is why all new programmers should start off with SICP.
16:52:12 <Zao> Twey: I'm unsure if the LISP kind of brain damage is much better.
16:52:19 <mauke> meh, depends on the imperative language you learned
16:52:33 <nvoorhies> you get brain damaged by learning too much of anything
16:52:34 <Twey> Zao: SICP is not about Lisp.
16:52:39 <Zariel> C/python/lua
16:52:41 <mauke> e.g. in Perl this is just map/grep
16:52:59 <Twey> It's not even about Scheme, though that's the language used (or a variant thereof).
16:53:01 <mauke> wait, python has native list comprehensions
16:53:08 <Zao> Lisp, scheme, what's the difference? :)
16:53:18 <mauke> Zao: #'
16:53:18 <Twey> Zao: emacs, vi, what's the difference?  :þ
16:53:26 <mauke> (and funcall)
16:53:30 <medfly> Twey, not much, they are both text editors
16:53:34 <medfly> Twey, one just has more painful syntax
16:53:35 <Open> One is better than the other
16:53:37 <Twey> Notably, for the purposes of this conversation, Scheme encourages functional style a lot more than CL does.
16:53:38 <medfly> AHAHAHAH :-D
16:53:43 <Twey> medfly: Hehehe
16:53:47 <medfly> now to know which question I answered!
16:53:53 <Twey> Open: Oh, hello
16:54:13 <medfly> I have a really cool idea of a big project to do in Haskell! hurray!
16:54:25 <Twey> \o/
16:54:28 <ben_m> medfly: Can I please steal it?
16:54:35 * Axman6 doesn't think either emacs or vi are better than the other, and dislikes them practically eqially
16:54:40 <Axman6> equally*
16:54:40 <ski> Scheme is a member of the Lisp family of programming languages
16:54:41 <medfly> no, I think I might in theory make money of it, and I would like to have money
16:54:43 <Open> Twey, I find it it strange that you can simultaneously actively participate in many conversations
16:55:00 <Twey> Open: Why?  Can't you?
16:55:01 <ski> (just like Edwin and Climacs are both emacsen)
16:55:10 <medfly> sorry
16:55:17 <Twey> I can even do it in an assortment of different languages, though sometimes I mix them up.  :þ
16:55:21 <Twey> (that's always fun)
16:55:33 <Open> I can't. :(
16:55:46 <Twey> Practise.  It gets easier.
16:56:22 <tensorpudding> does anyone use yi for writing code?
16:56:48 <Twey> <silence>
16:56:55 <Twey> I'm pretty sure some people do.
16:57:00 <Twey> Not many, but some.
16:58:02 <Veinor> yi?
16:58:24 <tensorpudding> it's an editor written in haskell
16:59:03 <Gracenotes> > sum [1..10]
16:59:04 <lambdabot>   55
16:59:05 <Veinor> Ah.
16:59:10 <Veinor> oh hey Gracenotes :D
16:59:12 <tensorpudding> it kinda sounds emacsish
16:59:25 <Gracenotes> Veinor! What's up
16:59:49 <Veinor> Not much, you?
17:00:03 <tensorpudding> but haskell sounds more pleasant to me than emacs lisp
17:00:09 <Gracenotes> fine. workin' on some Go code right now, actually
17:00:19 <Gracenotes> I've written 443 lines
17:00:24 <Twey> elisp is particularly painful, as Lisps go
17:00:36 <Twey> (we put up with it because it's still a heck of a lot better than viscript >.>)
17:00:38 <mauke> elisp is perl4 :-[
17:00:39 <Veinor> I should probably learn Go so I can be on the cutting edge of at least one thing. :P
17:00:47 <Twey> mauke: Yeah, basically
17:00:48 <mauke> Twey: vim can be scripted in scheme
17:01:11 <Twey> mauke: Link please?
17:01:43 <tensorpudding> of course, you don't have to use emacs lisp to use emacs, or viscript for vi
17:01:44 <Gracenotes> >_> <_<
17:01:48 <mauke> Twey: http://vimdoc.sourceforge.net/htmldoc/if_mzsch.html#mzscheme
17:01:50 <Twey> tensorpudding: True
17:02:30 <Twey> mauke: Nice
17:02:35 <Twey> mauke: Does anyone actually use it?
17:02:40 <mauke> no idea
17:03:01 <tensorpudding> but the idea of emacs is that it is extensible
17:03:22 <tensorpudding> so you kinda want to learn elisp, except that it seems pretty meh
17:04:02 <mauke> unfortunately, emacs makes me rage within minutes of trying to use it
17:04:54 <tensorpudding> why the rage?
17:05:09 <netinho2lol> emacs is a great operative system
17:05:13 <ksf> RAAAAAAAAAAAAAAAAAGE!
17:05:15 <mauke> netinho2lol: no, it isn't
17:05:39 <tensorpudding> this is inviting flamewar
17:05:50 <tensorpudding> since it's all aesthetics
17:05:58 <ben> i cannot wait to use ghc 6.12's IO
17:06:01 <kw317> netinho2lol: but poor text editor ;-)
17:06:04 <mauke> tensorpudding: it leaves ~ files around. it creates broken text files by default. it insists on setting the cursor to VERY VISIBLE.
17:06:05 * BMeph breaks out a bag of marshmallows and coat hangers
17:06:19 <tensorpudding> you can configure the cursor, i know i have
17:06:23 <mauke> tensorpudding: it displays a completely nonfunctional menu bar in the console
17:06:23 <ksf> emacs is like a ship mast wrapped in glowing red barb wire. All you can hope upon encountering it is hoping that it won't end up your ass.
17:06:27 <tensorpudding> i've never liked the ~ files but is it a big deal?
17:06:39 <mauke> tensorpudding: you cannot configure the cursor. I actually tracked this one down, and it's hardcoded in C
17:06:45 <nolrai_FG> is there a "f m1 m2 = do {a <- m1; m2; return a}"?
17:07:03 <netinho2lol> http://www.gnu.org/software/emacs/tour/ -> "You might see now why some people consider Emacs to be not merely a text editor but almost a complete operating system. Some users find that they can do almost all of their work from within Emacs."
17:07:06 <mauke> tensorpudding: enabling syntax highlighting is positively hard. the help system is hard to use.
17:07:14 <netinho2lol> emacs is also a poor religion
17:07:18 <tensorpudding> when do you have to enable syntax highlighting?
17:07:23 <ben> nolrai_FG: <*, maybe?
17:07:24 <tensorpudding> i disagree about help being hard
17:07:33 <nolrai_FG> mauke: what editor are you talking about?
17:07:42 <mauke> tensorpudding: there is no "redo". the whole program seems unpolished and sloppy.
17:07:49 <nolrai_FG> :t (<*)
17:07:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:07:57 <netinho2lol> ben: ghc 6.12's IO?
17:08:02 <mauke> tensorpudding: have you ever seen the vim help system?
17:08:03 <tensorpudding> if you have a haskell source file, it should get syntax highlighting if you have haskell-mode installed
17:08:05 <ben> netinho2lol: It has utf8!
17:08:10 <mauke> tensorpudding: no, it shouldn't.
17:08:17 <netinho2lol> by default?
17:08:21 <netinho2lol> that's cool
17:08:30 <tensorpudding> mauke: what are you running emacs on? which version?
17:08:33 <jesmon> mauke: no redo?
17:08:41 <roconnor> <mauke> tensorpudding: enabling syntax highlighting is positively hard. the help system is hard to use.
17:08:42 <mauke> tensorpudding: I'm no longer running emacs
17:08:54 <mauke> jesmon: yes. no redo.
17:08:56 <roconnor> I gave up on emacs in university when I couldn't get help and backspace working at the same time
17:08:56 <tensorpudding> okay, what version did you run?
17:09:04 <mauke> tensorpudding: I don't remember
17:09:07 <jesmon> mauke: C-/
17:09:17 <jesmon> hit a key and type undo
17:09:21 <jesmon> it folds the history
17:09:24 <roconnor> oh god,
17:09:32 <roconnor> the horrible horrible undo system of emacs
17:09:36 <netinho2lol> going to sleep now
17:09:40 <netinho2lol> good night channel
17:09:43 <netinho2lol> and see you tomorrow!
17:09:48 <tensorpudding> mauke: C-h ? gives a good pile of help information, what exactly is wrong with it?
17:09:51 <netinho2lol> thanks for the assistance!
17:10:09 <tensorpudding> i used to use vim exclusively and now i use both
17:10:22 <mauke> oh great, now emacs doesn't even start
17:10:26 <tensorpudding> i prefer emacs for writing code though
17:10:32 <roconnor> mauke: hurray
17:10:41 <mauke> ^CWaiting for process to die...(type C-g again to kill it instantly)
17:10:47 <mauke> ^G does nothing, of course
17:10:54 <nolrai_FG> Can module names include underscores?
17:11:10 <ben> Can module names begin with digits?
17:11:14 <roconnor> I could never save files in emacs
17:11:23 <roconnor> instead my terminal would simply hang
17:11:26 <roconnor> (Xoff)
17:11:27 <mauke> ... and it completely fucked up my terminal
17:11:39 <mauke> gee
17:11:40 <tensorpudding> you guys have really odd problems, what systems are you using...
17:11:55 <mauke> x86 linux with gnu emacs 23.1.1
17:11:58 <roconnor> tensorpudding: WYSE terminal
17:12:14 <tensorpudding> i've used emacs on openbsd, debian, arch, windows, mac osx, running on netbooks, laptops, desktops, and big-iron
17:12:28 <nolrai_FG> ben: I hope not.
17:12:38 <ben> aw :<
17:12:38 <tensorpudding> i can't say i know WYSE
17:13:05 <nolrai_FG> Im just going to assume no, and make an ass of umtion.
17:13:28 <mauke> rm -r ~/.emacs* fixed it
17:13:33 <roconnor> tensorpudding: http://www.mticom.com/images/wyse_150_terminal.jpg
17:13:33 <nolrai_FG> ben: but probably yes.
17:13:35 <nolrai_FG> hmm
17:13:36 <Open> Would I be correct in assuming that the larger part of this channel's user-base uses emacs? Since it's more closely associated with functional programming languages than other editors (like vi)
17:13:49 <eivuokko> iirc, module names have same rules as constructors.  So no digits, yes _ (but not as first)
17:13:52 <tensorpudding> roconnor: that looks a bit aged
17:13:53 <ksf> Open, no.
17:14:01 <tensorpudding> Open: i would say not likely
17:14:08 <mauke> tensorpudding: that help is completely useless
17:14:12 <roconnor> tensorpudding: it was old when I was using it 14 years ago
17:14:31 <mauke> tensorpudding: let's say I want to disable beeps. how do I find that in the help?
17:14:32 <ksf> you see, haskellists usually don't prefer braindeadness, even if it's half-way functional.
17:14:35 <tensorpudding> i can't compare emacs to what it was like 14 years ago unfortunately
17:14:37 <chrisdone> most programmers in Coders at Work seem to use Emacs, oddly
17:14:47 <ksf> ...not to mention that lisp isn't pure, at all.
17:14:50 <tensorpudding> mauke: i don't think it would be in help
17:14:55 <mauke> tensorpudding: what?!
17:15:01 <tensorpudding> it might be if it is a lisp function
17:15:02 <roconnor> tensorpudding: I believe it is exactly the same
17:15:14 <mauke> I do not want my editor to beep. ever.
17:15:22 <mauke> plz advise
17:15:42 <Open> mauke, xset b off
17:15:47 <ksf> mauke, open the pc case, unplug the speaker, there you go.
17:15:48 <tensorpudding> if you don't want system beeps, you can disable the pcspeaker
17:15:57 <Zao> :se visualbell ?
17:15:57 <mauke> tensorpudding: I only said "my editor"
17:16:06 <chrisdone> I prefer (setq visible-bell t)
17:16:16 <Open> mauke, xset b off should do then, I do believe
17:16:19 <mauke> chrisdone: that's nice, but how do I find that in the help?
17:16:21 <jesmon> mauke: (setq visible-bell t)
17:16:21 <jesmon>  
17:16:23 <Zao> :se vb t_vb=
17:16:23 <mauke> Open: no
17:16:39 <Zao> Open: xset affects the whole X server.
17:16:52 <tensorpudding> xset doesn't work outside of x does it
17:16:55 <chrisdone> mauke: look under customizations in the emacs manual ...
17:16:55 <Zao> Which is rather overkill, if you've got say life monitoring software using terminal bells to alert nurses :P
17:17:00 <Open> Fair enough. I don't like beeps at ALL.
17:17:08 <tensorpudding> i disable all beeps
17:17:14 <jesmon> mauke: you can also address one of your other objections with this: (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
17:17:23 <mauke> jesmon: wrong.
17:17:55 <mauke> wtf, scrolling with DEL
17:18:13 <Open> chrisdone, do you've Coders at Work handy? What does SPJ use, out of curiosity?
17:18:29 <mauke> chrisdone: where is that?
17:19:04 <jesmon> mauke: (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
17:19:05 <ksf> Haskell REPLs use vi syntax, that should say everything.
17:19:24 <Axman6> REPLs?
17:19:30 <mauke> jesmon: what?
17:19:35 <chrisdone> mauke: well, when you first open emacs, it says "emacs tutorial", "emacs guided tour", "emacs manual", etc.
17:19:54 <jesmon> mauke: to get rid of the "useless menu bar"
17:20:03 <mauke> jesmon: no, wrong
17:20:16 <ksf> Axman6, read eval print loop
17:20:35 <ksf> like hugs, ghci
17:20:44 <Axman6> ah
17:20:45 <mauke> chrisdone: oh, tensorpudding told me to use C-h ?
17:20:46 <ben> ghci is not too good at using vi syntax
17:21:04 <dolio> ksf: Emacs doesn't really have the sort of syntax that it could use.
17:21:06 <chrisdone> mauke: yeah that's the shortcut, but I assumed you wouldn't know any shortcuts being new to emacs
17:21:21 <mauke> chrisdone: C-h r is stupid. it only gives me a bunch of version and licensing information
17:21:29 <tensorpudding> C-h ? gives you a menu telling different help functions
17:21:59 <chrisdone> mauke: C-h r gives me a comprehensive contents page. you seem to have a broken emacs
17:22:04 <ksf> C-l : load module...
17:22:07 <mauke> chrisdone: only if you scroll down
17:22:28 <chrisdone> mauke: what, 30 lines?
17:22:35 <tensorpudding> the emacs manual is really big
17:22:43 <mauke> if I'm looking for help, I'm not interested in a SCREENFUL OF COPYRIGHT CRAP
17:22:50 <ksf> chrisdone, it's not possible to have a non-broken emacs.
17:22:53 <ksf> every emacs is broken.
17:22:54 <Zao> mauke: But you have to know your GNU/Rights.
17:23:00 <tensorpudding> i forgot how big it was
17:23:12 <ben> Zao: I know that they are all reversed, will that do?
17:23:17 <mauke> chrisdone: my terminal is only 29 lines high
17:23:18 <chrisdone> mauke: I can't believe the de facto GNU editing program would have license information at the top of the manual </sarcasm>
17:23:24 <EvanCarroll> hahahah
17:23:36 <mauke> chrisdone: and it's more like 50 or 60 lines
17:23:47 <Zao> Halp. I started xemacs. How do I quit?
17:24:02 <Axman6> hold the power button for 5 seconds!
17:24:05 <tensorpudding> C-x C-c
17:24:11 <EvanCarroll> I just bought the christopher hichens documentary on his debate with douglas, and it has gangsta rap as the set up for the debate
17:24:14 <chrisdone> mauke: no, it's 36 lines
17:24:20 <Zao> "Wrong type argument: sequencep, #<keymap ((control x) #<keymap size 3 0x5ae>) size 1 0x627>" <- helpful error messages, those :)
17:24:55 <mauke> chrisdone: did you count the nonfunctional menu bar, the "Next: Distrib, Prev: (dir), Up: (dir)", the status bar, and the minibuffer?
17:24:58 <mauke> grr
17:25:12 <chrisdone> mauke: so your beef with emacs is that it has 36 lines of license information at the top of the manual?
17:25:26 <chrisdone> good to know you're being pragmatic
17:25:28 <mauke> chrisdone: that's one of the problems, yes
17:25:40 <mauke> still looking for "customization" in the manual
17:26:14 <ben> One of the first things you see in the vim help is how to exit vim
17:26:19 <ben> That is more thoughtful than I expected
17:26:54 <tensorpudding> everyone's first vim session is about the same
17:26:59 <tensorpudding> it makes a lot of beeps
17:27:03 <mauke> the very first thing the vim help tells you is how to scroll around. the second thing is how to a) quit the help and b) quit vim altogether
17:27:11 <Athas> Does 'alloca' guarantee that the block of memory is zeroed?
17:27:21 <mauke> Athas: no
17:27:26 <Athas> Well then.
17:27:33 <ksf> yi needs a doc system, btw.
17:27:39 <ben> alloca creates objects, not bytes, no?
17:27:51 <ben> Oh, it does not. Whoops.
17:28:07 <ksf> alloca increases esp/rsp
17:28:18 <ben> Well, it also calls newAlignedPinnedByteArray#
17:28:20 <chrisdone> mauke: which is what you get with the emacs tutorial
17:28:23 <Athas> Terribly complex this.
17:28:41 <mauke> chrisdone: I don't need a tutorial for four lines of text
17:28:45 <ksf> oh, I thought it uses stack vars
17:29:06 <dmwit> I've got some documentation with things like "Maintainer: foo@blarg.le\nStability: stable" and so forth.  This appears nicely in the generated documentation.
17:29:09 <eivuokko> Athas, what are you trying to do?
17:29:14 <dmwit> Is there any list of what fields are supported there?
17:29:34 <eivuokko> ksf, If you're talking about ghc, there's no applicable stack like that.
17:29:49 <mauke> chrisdone: where do I find customization in the emacs help?
17:29:50 <ben> dmwit: That is just a .cabal file, no?
17:30:23 <Athas> eivuokko: I'm working with the Haskell xlib wrapper.  As far as I can see, the getWMNormalHints function is broken/fragile, but it'd work sensibly if 'alloca' provides a zeroed block of memory and Nothing is implemented as a null pointer.
17:30:28 <mauke> jesmon: I don't have anything against menu bars ... if they do something.
17:30:40 <mauke> jesmon: there's no point in drawing a completely non-functional menu bar on the screen
17:30:41 <Athas> I'm just trying to figure out how to make my program somewhat robust.
17:30:51 <mauke> jesmon: and I shouldn't have to customize something like that
17:30:51 <ksf> eivuokko, yes, _after_ the ffi function returned, there's no stack anymore.
17:30:57 <chrisdone> mauke: do you have any compelling criticism of emacs?
17:31:05 <chrisdone> mauke: er... under Advanced Features?
17:31:14 <dmwit> ben: No, it's in the *documentation*, i.e. in -- | within the Haskell file.
17:31:20 <chrisdone> mauke: like, the second page down
17:31:27 <ben> dmwit: Oh.
17:31:32 <mauke> chrisdone: ah, there
17:31:39 <ksf> I was confused because alloca defines the memory region to be undefined after it's done running, so I guess it _could_, in principle, do some stack magic.
17:31:46 <Saizan> dmwit: the haddock manual, maybe
17:31:52 <ben> dmwit: I assumed you were refering to the package splash pages, ie http://hackage.haskell.org/package/hinotify
17:32:03 <dmwit> Saizan: Could you point me to where?  I've just been searching through it.
17:32:05 <ben> But yeah, haddock is what is parsing those.
17:32:09 <chrisdone> love to spend all night showing you how to use your eyes, but until you find some thing that's hard to do in emacs I don't think you'll stop whining
17:32:10 <dmwit> ...and didn't see anything about this
17:33:02 <mauke> chrisdone: ok, I'm in Customization. where do I go from there?
17:33:02 <nolrai_FG> :t maybe
17:33:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:33:20 <Athas> What's this Emacs issue?
17:33:57 <eivuokko> Athas, Would have to see the code about Maybe comment, it's pretty typical helper to map Maybe to 0 but I can't remember it being in standard ffi :-/
17:34:33 <Saizan> dmwit: i can't find it either :) i'm afraid the only way is to read the source
17:34:43 <dmwit> booo
17:34:51 <dmwit> Okay, thanks. =)
17:34:51 <Athas> eivuokko: well, xmonad does this very thing, and it seems to work.
17:35:01 <Athas> eivuokko: I just don't like relying on such an esoteric implementation issue.
17:35:21 <tensorpudding> xmonad is amazing
17:36:25 <mauke> I found M-x customize, but it's not very easy to navigate either
17:36:41 <nolrai_FG> is there a better way to write "return $ maybe id (\ Just _ -> ('#':)) maybePound $ rest"?
17:36:49 <Athas> Don't use that (except for fonts possibly), write stuff in your ~/.emacs.
17:36:59 <mauke> Athas: hahaha
17:37:06 <mauke> Athas: and how do I find out what to write?
17:37:27 <ben> const ('#':) for the lambda?
17:37:42 <eivuokko> mauke, you don't.  You copy someone else's and trial-error modify it until it doesn't work as badly, or you get bored. ;-)
17:37:46 <Athas> You read other peoples .emacsen, or the Emacs Lisp reference manual, or any of a billion tutorials, HOWTOs, or guides.
17:37:55 <Athas> You're not the first to learn Emacs, you know.
17:38:02 <tensorpudding> the problem is that most tutorials are ancient
17:38:02 <mauke> Athas: I'm not learning emacs
17:38:07 <mauke> I'm not stupid
17:38:10 <nolrai_FG> ben: thanks!
17:38:11 <Athas> Emacs is pretty ancient too, they mostly still work.
17:38:31 <tensorpudding> yes, most of them do
17:38:40 <tensorpudding> it would be nice if emacs evolved a little bit though
17:38:52 <nolrai_FG> mauke: you seem intent on hateing emacs not that I would use it though.
17:38:52 <ben> Yeah, into vim.
17:39:02 <tensorpudding> vim is nice
17:39:12 <mauke> so I've spent 25 minutes on this so far
17:39:14 <ski> @type maybe id (\ (Just _) -> ('#':))
17:39:17 <lambdabot> forall t. Maybe (Maybe t) -> [Char] -> [Char]
17:39:19 <Axman6> are we still talking about emacs? jesus
17:39:22 <tensorpudding> there is some real vim foo that goes on that i do not at all understand
17:39:34 <tensorpudding> i never could remember the syntax of a lot of commands
17:39:41 <mauke> Athas: I was just looking for a good help system
17:39:44 <ben> eh, i just type code ._.
17:39:47 <mauke> Athas: some people claim emacs has one
17:39:53 <tensorpudding> and there isn't something like C-h k <keysequence>
17:40:13 <mauke> tensorpudding: yes, there is.
17:40:15 <mauke> tensorpudding: it's called :help
17:40:28 <ben> If the Maybe has a '#' in it, you could do maybe id (:), I suppose
17:40:37 <tensorpudding> this is gigantic manual though
17:40:42 <tensorpudding> i want to find one thing in specific
17:40:45 <mauke> tensorpudding: :h <keysequence>
17:40:46 <Athas> mauke: oh, it does, it's great.  But it's not for your first week in Emacs, it's for the following ten yeas.
17:41:01 <mauke> Athas: I just wanted to find out how to disable beeps in emacs
17:41:11 <mauke> for reference, in vim it's ':help beep'
17:41:47 <mauke> (can also be found with :h bell)
17:41:49 <tensorpudding> actually, hmm, doesn't emacs have apropos
17:41:54 <Athas> It does.
17:42:10 <Athas> C-h g bell
17:42:28 <tensorpudding> beep is a command that flashes the screen, no luck there
17:42:34 <tensorpudding> you need to search bell
17:42:59 <tensorpudding> C-h g is the gnu docs athas..
17:43:07 <Twey> C-h a
17:43:07 <mauke> Athas: maybe I'm stupid, but C-h g gives me "The GNU Project" by Richard Stallman.
17:43:08 <Athas> Huh, maybe that's a local binding...
17:43:16 <tensorpudding> thanks Twey, that's the one
17:43:20 <mauke> and 'b' tells me the buffer is read-only
17:43:25 <Athas> Sorry, that's the downside of heavy customisation.
17:43:33 <mauke> No apropos matches for `beep'
17:43:41 <mauke> No apropos matches for `bell'
17:43:46 <ben> My emacs just says 'C-h g is undefined'
17:43:56 <Athas> M-x apropos bell
17:43:59 <jesmon> mauke: emacs has lots of ways to get help. looke at M-x apropos . You can get info on any function by C-h f 'function name' or any bound key combination by 'C-h k <key combination>. You can get information on the current editing mode by 'M-x describe-mode' or the current key bindings by 'describe-bindings'. Then there's just C-h i, which the info system. It has tab completion for commands in the mini buffer. also, which is helpful.
17:44:00 <Athas> C-h a is apropos-command.
17:44:08 * Axman6 strongly suggests you all take this emacs nonsense to #haskell-blah 
17:44:20 <ben> No, take it to #vim
17:44:28 <Twey> Heh
17:44:31 <tensorpudding> Athas: wow that is annoying...
17:44:36 <mauke> jesmon: you wanna come over to #haskell-blah? :-)
17:44:49 <tensorpudding> the nice thing about emacs is that if you don't know a keybinding, you can do M-x <funcname>
17:44:53 <jesmon> mauke: not really
17:45:16 <ski> (tensorpudding : or `C-x w <name>')
17:45:27 <Axman6> oi, #haskell-blah
17:45:28 <ben> Could someone tell me how to exit emacs? I promise I will shut up, then.
17:45:40 <ski> C-x C-c
17:45:42 <Axman6> ^x^c
17:45:44 <ben> Thank you
17:45:47 <tensorpudding> but anyway
17:46:00 <Twey> Axman6: DOS-style… nice :þ
17:46:10 <tensorpudding> M-x apropos bell gives a list, which you can see visible-bell in there, and in the doc for that is a link to its customization entry
17:46:33 <ski> (also, there's #emacs for this :)
17:46:39 <mauke> tensorpudding: you wanna come over to #haskell-blah?
17:47:02 <tensorpudding> i'm tired of emacs talk
17:47:12 <Axman6> hooray!
17:47:31 <tensorpudding> i had forgotten about apropos, this conversation reminded me
17:48:39 <tensorpudding> i'll check out #haskell-blah though
17:48:44 <chrisdone> I don't think you should have to teach mauke how to use emacs (something he could do himself) to prove anything. it won't go anywhere. if a person cares about the truth instead of being right, they will look it up themselves instead of questioning you
17:48:58 <mauke> then I declare this experiment finished. conclusion: after 35 minutes of looking I still haven't found out how to disable beeps in emacs (this is with several human helpers). without them I probably wouldn't even have found 'M-x apropos'.
17:49:07 <chrisdone> I rest my case
17:49:30 <mauke> this wasn't about teaching me emacs. this was me trying to explain why emacs makes me rage
17:50:12 <chrisdone> mauke: yes, because you are too lazy to spend more than a second looking at it
17:50:56 <mauke> s/a second/45 minutes just to stop beeps/
17:51:07 * ski refrains from mentioning jesmon told how to disable bell
17:51:13 <Twey> rmmod pcspkr
17:51:14 <Twey> Done
17:51:28 <tensorpudding> that works wonders if your goal is no beeps at all
17:51:36 <mauke> ski: my complaint was about the help system, not the beeps
17:51:41 <tensorpudding> some people like some apps to beep and some apps not to beep
17:51:57 <ski> mauke : hence the refraint :)
17:57:16 <tensorpudding> so why doesn't haskell have dependent types?
17:57:41 <ski> it isn't compatible with type inference ?
17:57:51 <ski> (but so isn't polymorphic recursion)
17:58:02 <tensorpudding> okay, i can see that
17:58:23 <tensorpudding> i'm reading about agda and it seems pretty interesting
17:58:44 <sinelaw> mauke, M-x set-variable <enter> visible-bell <enter> t <enter>
17:58:53 <mauke> sinelaw: off-topic
17:59:01 <tensorpudding> the emacs debacle has moved to #haskell-blah, if you like
18:06:40 <FunctorSalad> can't get HList to work :(
18:07:00 <FunctorSalad> :t (undefined::Int) .=. "there"    .*.    (undefined::()) .=. "hi"    .*.    emptyRecord
18:07:01 <lambdabot> Not in scope: `.=.'
18:07:01 <lambdabot> Not in scope: `.*.'
18:07:01 <lambdabot> Not in scope: `.=.'
18:07:04 <FunctorSalad> gives an error
18:07:34 <FunctorSalad>     No instances for (HRLabelSet' Int [Char] () [Char] leq HNil,
18:07:34 <FunctorSalad>                       HEq Int () leq)
18:07:34 <FunctorSalad>       arising from a use of `.*.'
18:07:56 <FunctorSalad> apparently the "LabelSet" constraint makes sure that the labels are unique
18:07:58 <FunctorSalad> but they are :)
18:08:01 <FunctorSalad> (Int and ())
18:12:56 <gwern> 'A bit of SmallTalk folklore: 'if 3+4 works, everything works'. We typed 3+4 into a window and executed it. It did not work.'
18:13:18 <Twey> Hahaha
18:17:00 <Chaze> let forever fun = fun >> forever fun in forever $ putStrLn "Wow, Haskell is fun!"
18:18:21 <FunctorSalad> > fix error
18:18:22 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:18:30 <BMeph> jfredett: ping
18:19:18 <ben> @src forever
18:19:18 <lambdabot> Source not found.
18:21:13 <ski>   forever = fix . (>>)
18:21:51 <ben> Woah, a use for fix.
18:22:31 <Chaze> :t fix
18:22:33 <lambdabot> forall a. (a -> a) -> a
18:24:29 <Chaze> shouldn't fix be in here? http://www.zvon.org/other/haskell/Outputmonad/index.html
18:25:00 <Chaze> nevermind, they don't list submodules
18:30:24 <ski> also see
18:30:27 <ski> @type fix . (>=>)
18:30:28 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
18:30:30 <ski> @type \f -> fix ((=<<) . (. f))
18:30:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> m a -> m b
18:30:55 <Chaze> @src  (>=>)
18:30:56 <lambdabot> Source not found. :(
18:31:23 <ski>   (g >=> f) a = g a >>= f
18:31:48 <Chaze> it's kinda nasty to find where such stuff is defined
18:31:50 <ski> @type (>=>)
18:31:51 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:32:29 <ski> `Control.Monad' iirc
19:01:17 <Gracenotes> > concatMap show [0..]
19:01:19 <lambdabot>   "01234567891011121314151617181920212223242526272829303132333435363738394041...
19:06:54 <EvanCarroll> @msg BONUS one other thing, I think in the higher order function you should specifically add an example :t (compare 100) to show the definition
19:06:54 <lambdabot> Not enough privileges
19:07:00 <EvanCarroll> @message BONUS one other thing, I think in the higher order function you should specifically add an example :t (compare 100) to show the definition
19:07:01 <lambdabot> Maybe you meant: messages messages?
19:07:06 <EvanCarroll> god damn
19:07:11 <EvanCarroll> i'll just use memoserv
19:11:08 <aavogt> @tell EvanCarroll use this plugin instead
19:11:08 <lambdabot> Consider it noted.
19:21:53 <nolrai_FG> @hoogle [m a] -> m [a]
19:21:53 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:21:53 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:21:53 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
19:22:21 <nolrai_FG> @hoogle [m [a]] -> m [a]
19:22:21 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
19:22:22 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
19:22:22 <lambdabot> Prelude concat :: [[a]] -> [a]
19:24:27 <nolrai_FG> :t liftM concat . sequence
19:24:28 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
19:28:22 <gwern> http://www.reddit.com/r/programming/comments/a481l/so_to_get_back_to_the_point_go_vs_algol68_tbh_i/c0fs5z5 <-- strange how comments can swing between -4 and +6
19:28:41 <chupish> Not really; Go fanbois?
19:29:20 <gwern> my comment wasn't even about go, really
19:29:53 <chupish> yeah, but you insulted C++, and made a comment about a) Haskell being good and b) Lisp macros
19:30:09 <chupish> I could see it swinging back & forth
19:30:10 <chupish> :D
19:30:49 <chupish> I must say though, at this juncture I wish Go had some type specialization concept...
19:31:49 <chupish> also, I'll toss you an upvote...
19:34:05 <tensorpudding> Go is kind of interesting, if not really revolutionary
19:34:31 <chupish> dunno; as someone who's used Limbo for decent sized programs, I'm not sure I'd label it as even interesting really
19:35:09 <tensorpudding> i can't say i know what Limbo is
19:35:34 <chupish> The programming language behind Inferno, another OS
19:35:43 <chupish> it doesn't matter much, save for that Rob Pike worked on both
19:36:08 <tensorpudding> oh, sweet
19:36:33 <tensorpudding> the few things by pike i have tried (sam and acme) I'm not too fond about though
19:36:48 <chupish> nor am I; I like Limbo though
19:36:49 * Axman6 doesn't know who pike is
19:37:01 <chupish> Rob Pike; the guy at the hour long google talk
19:37:12 <Axman6> anything more than that?
19:37:16 <tensorpudding> rob pike was a big guy in the old days
19:37:19 <chupish> yes, quite a bit
19:37:31 <chupish> he worked on Sawzall at Google
19:37:40 <gwern> pike has a unique viewpoint, yes. I think I'd describe it as a less cool, lower level djikstra
19:37:42 <tensorpudding> he was a member of the unix team
19:37:56 <tensorpudding> co-created utf8 with ken thompson
19:38:04 <Axman6> ah
19:38:05 <chupish> you know, just minor things :D
19:38:21 <lispy|web> Speaking of Go, do we have a Language.Go on hackage yet?
19:38:40 <tensorpudding> of course, he also cocreated Go with Ken Thompson
19:39:12 <gwern> tensorpudding: a bit early to speak of Go in the same breath as utf8 and unix...
19:39:18 <gwern> also, weren't we calling it Issue9?
19:39:35 <chupish> well, he worked on Plan9, Inferno, UTF-8, &c &C.
19:39:46 <tensorpudding> he was one of the UNIX patriarchs in a sense
19:40:26 <lispy|web> UTF-8 seems to be good.  So, he's 1 for 4?
19:40:50 <chupish> dunno if he worked on SysX or anything before though
19:41:03 <gwern> plan9 was pretty cool from the papers I read
19:41:04 <chupish> he had some interesting interface papers
19:41:09 <chupish> I run Plan9 here
19:41:14 <tensorpudding> plan9 has been a great research platform
19:41:14 * lispy|web notes that if you believe C/Unix was "good" then check out the security exploits literature
19:41:21 <tensorpudding> a lot of stuff has been taken from it
19:41:34 <chupish> it's definitely interesting for research
19:41:42 <gwern> lispy|web: is secure the only factor in goodness?
19:41:58 <tensorpudding> UNIX might not have been "good" but it is probably the most important OS ever
19:41:58 <chupish> the 9p for everything concept is useful for debugging & exploration
19:42:04 <chupish> meh IX :D
19:42:55 <lispy|web> gwern: Not the only, but C is so insecure, I sometimes feel like it's set the field of computer scienc back.
19:43:19 <chupish> I wish Cyclone wasn't dying...
19:43:40 <gwern> lispy|web: we stand on each others' toes
19:43:40 <tensorpudding> the culture of unix was pretty significant
19:44:27 <chupish> it is funny though that lispy|web mentions this; IX was infected when they were first attempting to bootstrap it from Sys 10
19:46:35 <chupish> There is that Mythril project as well, btw
19:46:40 <chupish> that looks pretty interesting
19:50:04 <chupish> http://en.wikipedia.org/wiki/Mythryl
20:00:33 * FunctorSalad just did some hideous refactoring for hours, but after it compiled, it passed the test again :o
20:01:04 <EvanCarroll> how would you concatenate every element in an arbitrary list too ["foo", "bar", "baz"], to "foobarbaz"
20:01:05 <lambdabot> EvanCarroll: You have 1 new message. '/msg lambdabot @messages' to read it.
20:01:18 <mauke> @hoogle [[a]] -> [a]
20:01:19 <lambdabot> Prelude concat :: [[a]] -> [a]
20:01:19 <lambdabot> Data.List concat :: [[a]] -> [a]
20:01:19 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:03:41 <EvanCarroll> Data.List eh
20:05:49 <FunctorSalad> I'm still not satisfied with my code...
20:06:21 <FunctorSalad> I think it's overmonadified, considering the monads are just readers plus a unique value supply
20:39:47 <Veinor> the best part about haskell is probably types, because you can hoogle [[a]] -> [a] and know what that function will do
20:40:02 <Veinor> on the other hand types are also the most annoying part about it
20:40:49 <tensorpudding> the first-class functions, referential transparency, clean syntax, lazy evaluation are all big things too
20:41:09 <Veinor> true, first-class functions are really great.
20:41:22 <Veinor> remind me what referential transparency is?
20:41:46 <nolrai_FG> I want som big haskell file to complile to stg, I need it to use every thing? ideas?
20:42:00 <nolrai_FG>  /s/som/some
20:42:08 <FunctorSalad> Veinor: more or less that you can inline anything
20:42:12 <FunctorSalad> (often called purity too)
20:42:35 <Veinor> ah yeah, purity is nice
20:42:53 <tensorpudding> i think haskell is one of the only languages with all those things
20:42:56 <FunctorSalad> or that you don't need to care whether references point to the same thing, since there's no mutation anyway (is that the origin of the name?)
20:43:10 <FunctorSalad> (except for performance, then you should care)
20:43:15 <Veinor> clean syntax, I dunno about. I mean, $$$? ***? <$>? really?
20:43:19 <Veinor> :P
20:43:42 <tensorpudding> i meant more of how all functions look the same
20:43:57 <FunctorSalad> (:[])
20:44:02 <tensorpudding> and the clear ways to do mixfix
20:44:06 <Veinor> FunctorSalad: haha
20:44:30 <Veinor> @pl \x -> [x]
20:44:30 <lambdabot> return
20:45:12 <Veinor> that's... true, I guess.
20:45:17 <tensorpudding> and the simple way that layout is handled considering that it has some significant whitespace
20:45:32 <rasterfar> (:[]) look like Bert from Sesame Street.  Didn't he make a list in one episode?
20:45:34 <Veinor> @unpl (:[])
20:45:34 <lambdabot> (\ a -> a : [])
20:46:14 <tensorpudding> i don't have so much experience with other functional languages, but what i've seen of ocaml and f# i like haskell's syntax much better
20:46:19 <rasterfar> (never mind you're all probably too young to know the answer to that)
20:46:33 <tensorpudding> a list of what?
20:46:57 <tensorpudding> i saw plenty of sesame street but i can't remember any of it
20:47:07 <_xor> Hey guys
20:47:11 <_xor> I'm learning Haskell
20:47:16 <Veinor> Good for you! :D
20:47:23 <_xor> ghc is the compiler I'm assuming I should use?
20:47:30 <tensorpudding> yes
20:47:31 <rasterfar> hbc forever!
20:47:43 <tensorpudding> ghc is the de facto compiler
20:47:43 <_xor> ...and I know it's subjective, but I'm looking for opinions on ide: vim or emacs?
20:47:53 <_xor> Yeah, figured as much
20:47:53 <tensorpudding> which do you prefer?
20:47:56 <_xor> Either or
20:47:57 <tensorpudding> that is what is important
20:48:00 <_xor> I'm not a zealot on it
20:48:09 <Veinor> The correct answer to 'vim vs emacs' is 'whichever you like.'
20:48:10 <tensorpudding> they both have haskell modes
20:48:12 <_xor> Just wondering which one has a more mature editing mode
20:48:14 <_xor> Yeah
20:48:22 <_xor> I'm not starting an IDE flame
20:48:26 <_xor> Just curious as to the opinions, that's all.
20:48:31 <_xor> I use either or
20:48:31 <tensorpudding> i am an emacs fan and i love emac's haskell-mode myself
20:48:33 <_xor> Don't really care
20:48:36 <_xor> cool
20:48:41 <tensorpudding> we had an editor flamewar here a few hours ago
20:48:44 <Veinor> so you use vim xor emacs? :P
20:48:54 <_xor> I'm going to play with both probably, but start off using one over the other (until I feel the need to check out the other in more detail)
20:49:02 <_xor> Veinor: how clever :P
20:49:04 <tensorpudding> there is leksah, which is a haskell ide
20:49:10 <tensorpudding> i've never used it though
20:49:13 <rasterfar> There is a Haskell implementation of vi called yi that you might find interesting, though.
20:49:19 <_xor> Hmm interesting
20:49:27 <tensorpudding> yes, yi is an editor that is kinda emacsy written in haskell
20:49:39 <_xor> Ok, again...NOT a flame war, but other than xmonad, what types of "real-world" applications can I see written in Haskell?
20:49:44 <tensorpudding> hmm, you think it is like vi?
20:49:54 <rasterfar> yi is emacsy?!  i've never tried it really, but i assumed it was a vi clone of sorts...
20:50:09 <_xor> I'm not implying non-real world applicability (yes, just made it up)...just looking to examples of Haskell apps used in production.
20:50:16 <tensorpudding> it's not really that emacsy
20:50:17 <_xor> Will look into their development process, opinions, etc.
20:50:26 <tensorpudding> but it is superficially more like emacs
20:50:38 <Axman6> rasterfar: it has key bindings for both i believe
20:50:49 <rasterfar> ah; nifty
20:50:51 <Veinor> _xor: I don't think there are too many, at least definitely not as many as, say, python
20:50:55 <_xor> Yeah
20:50:57 <rasterfar> and peacable
20:51:05 <_xor> How's the FFI in Haskell?
20:51:10 <tensorpudding> there are plenty of libraries for haskell
20:51:18 <_xor> I'm about to write a server app that uses PostgreSQL for the back-end.
20:51:20 <tensorpudding> though not so many really popular applications
20:51:38 <_xor> I'd like to use something that's static-strong, like Haskell...but Python is another option for me.
20:51:47 <_xor> hmm interesting
20:51:58 <rasterfar> *peaceable, my bad
20:52:00 <_xor> I'm big on correctness.
20:52:09 <_xor> Hence why I'm looking further into Haskell.
20:52:13 <_xor> Correctness & terse syntax.
20:52:27 <Axman6> _xor: why not use (one of) the postgresql bindings?
20:52:39 <_xor> Axman6: There's no reason not too, I'm just asking :)
20:52:46 <tensorpudding> have you looked at real world haskell yet?
20:52:49 <_xor> The book?
20:52:52 <tensorpudding> @where rwh
20:52:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:52:55 <_xor> Yeah, I hear it's not so great from a couple of people =/
20:53:05 <Veinor> I got the hard copy, it's pretty good.
20:53:07 <jfredett> _xor: those people are utterly wrong.
20:53:08 <_xor> I have the pdf I'm pretty sure.
20:53:08 <tensorpudding> i disagree with that
20:53:13 <_xor> I'm refreshing C/C++ right now, will be done in a couple of days.
20:53:17 <Axman6> it's much better once you've dablled with haskell a bit. i don't think it's a great introduction to haskell
20:53:24 <_xor> Want to update myself on Python & then look into Haskell after that.
20:53:27 <tensorpudding> though it is hardly what i'd call fantastic
20:53:36 <_xor> I'm sort of spending this month doing a quick crash-course & refresher on a bunch of languages.
20:53:53 <_xor> Hmm interesting.
20:53:55 * Axman6 should get back to learning Cocoa
20:53:56 <rasterfar> does anyone want to buy my copy on the cheap?  i think it's not quite the level i need.  i'm sorry to have to agree with what i'm hearing here, although I may need to give it more of a chance.
20:54:09 <Axman6> _xor: i recommend lyah before delving into rwh:
20:54:12 <Axman6> @where lyah
20:54:13 <lambdabot> www.learnyouahaskell.com
20:54:25 <tensorpudding> learn you a haskell is pretty but you don't learn much of anything
20:54:27 <_xor> I've been coding for a long time, so my preference on literature is a no-fluff, information dense approach.  I'd rather re-read a 150 page book 2-3 times, rather than read a 400 page book through once.
20:54:28 <rasterfar> yeah, and i have to keep making this presentation on software vis
20:54:45 <_xor> hmm cool :)
20:55:18 <_xor> I did do a quick read through of Haskell for C Programmers
20:55:22 <rasterfar> it is neat stuff, but it's still homework :-(
20:55:26 <rasterfar> bye for now
20:55:29 <_xor> I'm coming from an x86 Assembly & C/C++ & C# background
20:55:50 <Axman6> _xor: well, be prepared to forget everything you know about programming then ;)
20:55:52 <_xor> Those several pages were fairly enlightening.
20:56:00 <_xor> I know the difference between the basic paradigms :)
20:56:16 <_xor> It's not going to be AS difficult to pick up, will just need to get myself in to the f(x) mind-set :)
20:56:37 <Axman6> f x*
20:56:42 <_xor> :P
20:56:58 <_xor> You guys will have to excuse my surprise.
20:57:05 <_xor> I used to be on EFNet a lot, back in the day.
20:57:11 <_xor> So the politness of this channel is a bit of a shock.
20:57:12 <tensorpudding> though C and Haskell are both statically typed, their type systems bear little resemblance
20:57:43 * Axman6 never really thought of C as statically types, especially after using haskell
20:57:48 <tensorpudding> in Haskell you'll be up to your ears in types
20:57:53 <Veinor> mex xs = find (`notElem` xs) [0..]
20:58:00 <Veinor> I love how easy to write that is.
20:58:08 <tensorpudding> i suppose that a type system where you can do casting and coersion is not so statically typed
20:58:37 <_xor> You mean strongly typed?
20:58:38 <kmc> i'd say it's statically but weakly typed
20:58:44 <kmc> to the extent types exist, they are known at compile time
20:58:52 <_xor> How would it not be static?
20:58:53 <kmc> C++ has a touch of dynamic typing with dynamic_cast / RTTI
20:58:59 <_xor> There's RTTI in C++
20:59:07 <_xor> Which adds a dynamic touch
20:59:11 <kmc> and you can always build your own dynamic typing on top of a static system, e.g. Data.Dynamic
20:59:13 <_xor> ...but I don't know of any RTTI in C
20:59:17 <kmc> _xor, nice phrasing ;)
20:59:27 <_xor> It's mostly static.
20:59:29 <_xor> kmc :)
21:00:03 <Axman6> _xor: also, a tip: if you're starting out with haskell, don't expect your code to be all that fast. you'll likely write some very slow code, and it's only with time that you learn the tricks needed to write really fast haskell
21:00:06 * _xor likes static + type inferencing with strong rules
21:00:12 <kmc> _xor, i think you'll find this is one of the more friendly language-related channels on freenode
21:00:21 <_xor> Like taking advantage of lazy evaluation? :P
21:00:22 <Veinor> this is probably the friendliest channel.
21:00:27 <Cale_> Ugh: small point to watch for anyone who happens to write web applications: if your user gives you input, and you convert characters in it to HTML entities, when you give it back to them, give them back *exactly* what they entered.
21:00:28 <_xor> cool
21:00:36 <kmc> people mostly don't learn haskell unless they want to
21:00:46 <kmc> though that is changing... one of the symptoms of success
21:00:48 <_xor> Well, I'll idle in here until the stupidity of my question asking becomes log(n)
21:00:52 <tensorpudding> haskell let's you use infinite data structures for useful things
21:01:06 <Axman6> kmc: success :(
21:01:07 <tensorpudding> lets*
21:01:45 <_xor> Any of you guys use Coq in conjunction with Haskell?
21:01:55 <_xor> ...and if so, which proofing model do you use?
21:02:09 <tensorpudding> Agda is a theorem-prover using depedent types, written in Haskell
21:02:25 <tensorpudding> dependent*
21:02:34 <samnardoni> hey, is there a way to return a type that is either String or IO String?
21:02:37 <tensorpudding> I've not used Coq myself
21:02:54 <samnardoni> I've tried    data Whatever = String | IO String   but that didn't seem to do a lot
21:03:32 <Axman6> samnardoni: you could use Either... but what you're doing sounds rather ... well odd
21:03:45 <shrughes> samnardoni: if you don't mind returning an IO String, why not just always return an IO String, and where you'd return a String s, instead return (return s)
21:03:46 <Axman6> :t Right (getLine)
21:03:48 <lambdabot> forall a. Either a (IO String)
21:03:59 <Axman6> :t Right (getLine) >> Left "test"
21:03:59 <lambdabot> forall b. Either [Char] b
21:04:36 <samnardoni> how do you turn a String into an IO String?
21:04:43 <shrughes> :t return
21:04:44 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:04:49 <samnardoni> ahhh
21:04:59 <_xor> cool
21:05:11 <Jafet> :t return "lol"
21:05:12 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
21:05:23 <Veinor> > return "lol" :: [[Char]]
21:05:25 <lambdabot>   ["lol"]
21:05:29 <Veinor> > return "lol" :: Maybe [Char]
21:05:31 <lambdabot>   Just "lol"
21:05:43 <Axman6> > return "lol" :: IO String
21:05:47 <lambdabot>   <IO [Char]>
21:05:47 <samnardoni> Axman6, how would I use Either?
21:05:52 <Axman6> don't
21:05:54 <tensorpudding> monads are a subtle point that is hard to understand at first
21:05:55 <samnardoni> haha okay
21:06:12 <Veinor> @hoogle IO a -> a
21:06:13 <lambdabot> Foreign unsafePerformIO :: IO a -> a
21:06:13 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
21:06:13 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
21:07:03 <Veinor> :t id
21:07:04 <lambdabot> forall a. a -> a
21:07:12 <tensorpudding> > id 5
21:07:13 <lambdabot>   5
21:07:13 <Veinor> why does lambdabot not respond to :t statements in privmsg? :(
21:07:36 <tensorpudding> > fix id
21:07:39 <lambdabot>   mueval-core: Time limit exceeded
21:07:47 <tensorpudding> lol
21:07:47 <jfredett> Veinor: just use @type instead.
21:07:48 <Veinor> ah.
21:08:07 <tensorpudding> > fix error
21:08:08 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
21:08:14 <Axman6> anyone ever tried out the fossil revision control system?
21:08:16 <Veinor> that's my favorite fix, probably
21:08:20 <tensorpudding> Axman6: yeah
21:08:43 <Veinor> > fix undefined
21:08:43 <lambdabot>   * Exception: Prelude.undefined
21:08:43 <tensorpudding> it is kinda neat
21:08:45 <Axman6> apparently thr SQLite project moved from CVS to it this september
21:08:51 <nolrai_FG> is there a default way to pretty print a list?
21:08:55 <tensorpudding> really? interesting
21:08:56 <samnardoni> unsafePerformIO is what i needed :)
21:09:02 <Axman6> samnardoni: no it's not
21:09:07 <Veinor> samnardoni: oh god, never use unsafePerformIO
21:09:09 <Veinor> ever
21:09:12 <samnardoni> haha
21:09:18 <Axman6> samnardoni: if you're not writing an FFI binding, unsafePerformIO is NOT what you need
21:09:21 <Veinor> there's a reason it's called unsafe
21:09:30 <tensorpudding> the main thing that i remember about fossil is that it includes a bugtracker and documentation in a coherent fashion
21:09:42 <Axman6> hmm, there should be a LANGUAGE pragma that's needed for you to use unsafePerformIO
21:09:44 <tensorpudding> and is self-hosted
21:10:11 <nolrai_FG> Axman6: that is a good idea.
21:10:17 <tensorpudding> @type unsafePerformIO
21:10:19 <lambdabot> Not in scope: `unsafePerformIO'
21:10:34 <Veinor> {-# LANGUAGE YesIKnowWhatIAmDoing #-}
21:10:34 <tensorpudding> @hoogle unsafePerformIO
21:10:35 <lambdabot> Foreign unsafePerformIO :: IO a -> a
21:10:35 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
21:11:05 <jfredett> i think \bot filters out unsafePerformIO -- for safety concerns...
21:11:12 <tensorpudding> lol
21:11:18 <samnardoni> hmmm
21:12:04 <Axman6> samnardoni: why do you think you need to be able to return a String or an IO String?
21:12:05 <samnardoni> what's so bad about unsafePerformIO?
21:12:11 <Axman6> ...
21:12:11 <shrughes> it is unsafe
21:12:15 <Axman6> it;s right there in the name
21:12:32 <samnardoni> but what is "unsafe" defined as?
21:12:32 <Veinor> unsafePerformIO lets you violate the impure/pure boundary
21:12:37 <Axman6> it is designed for use in the FFI when you're binding to an external function you know is pure
21:12:44 <tensorpudding> it bypasses the way that IO is supposed to be done in Haskell, and breaks referential transparency
21:12:46 <jfredett> samnardoni: particularly, it breaks referential transparency
21:12:51 <jfredett> which is very naughty.
21:12:53 <Jafet> It backdoors the denotational semantics.
21:12:57 <Axman6> samnardoni: it can give you very unexpected results
21:12:59 <Jafet> That's right, no more semantics.
21:13:04 <tensorpudding> it has behaviors that are not easy to reason about
21:13:06 <Veinor> it lets you write coerce :: a -> b
21:13:07 <tensorpudding> unlike the rest of the language
21:13:12 <lispy|web> and it can be used to make the type system unsound
21:13:15 <samnardoni> ahh
21:13:30 <samnardoni> maybe return is the best method then?
21:13:34 <Axman6> samnardoni: it takes away everything from haskell that makes is great, basically
21:13:38 <Axman6> yes
21:13:42 <Veinor> samnardoni: why are you trying to return a String or an IO string?
21:14:00 <jfredett> unsafePerformIO = achillesHeel
21:14:43 <tensorpudding> unsafeDestroyUniverse
21:14:55 <jfredett> unsafeOHNOES!
21:15:13 <shrughes> is there any version of lambdabot that works with 6.10?  such as the one at code.haskell.org?
21:15:20 <Axman6> samnardoni: unsafePerformIO lets you write: f x = (unsafePerformIO (launchMissiles >> return 1)) + x
21:15:56 <samnardoni> i'm just messing around with a super super simple web framework haha
21:16:20 <samnardoni> get "/" = render "Main.hs"
21:16:20 <samnardoni> get "/view" = "view"
21:16:24 <FunctorSalad> samnardoni: it will make it dependent on evaluation order and optimizations how often the action is executed
21:16:28 <samnardoni> that's what I was messing around with
21:16:30 <FunctorSalad> (and in which order to other actions)
21:16:30 <Axman6> return view
21:16:37 <Axman6> or "view"
21:16:56 <samnardoni> yeah, i guess that's the best method
21:18:00 <FunctorSalad> samnardoni: and it breaks the "you can substitute equals for equals" property
21:18:26 <samnardoni> ahhhh
21:18:32 <samnardoni> all this is a little over my head at the moment
21:19:35 <samnardoni> i imagine functional programming is probably easier to understand if you've never programmed before rather than having years in imperitive languages
21:19:41 <Axman6> fark it's hot >_<
21:19:54 <samnardoni> i'm freezing
21:20:03 <Axman6> samnardoni: it's probably easier if you take the time to understand it too ;)
21:20:28 <samnardoni> true
21:20:55 <Axman6> do you know anything about lambda calculus btw?
21:21:11 <FunctorSalad> example breakage:
21:21:19 <samnardoni> i do understand a lot of the points; i was just choosing asthetics over functionality
21:21:36 <FunctorSalad> let { x :: Int; x = unsafePerformIO randomIO } in x + x
21:21:40 <samnardoni> Axman6: never researched it
21:22:16 <FunctorSalad> now if this is evaluated as it looks, one random will be generated and then doubled
21:22:31 <Peaker> samnardoni, Lambda Calculus is really nice, it shows how much power is possible with so few primitives
21:22:35 <FunctorSalad> but if you substitute the definition of x for x, you generate two random numbers
21:22:42 <FunctorSalad> (which produces a different distribution)
21:22:50 <Axman6> you could get odd numbers!
21:23:00 <shrughes> won't *somebody* think of the missiles!
21:23:08 <samnardoni> ahhh i seee
21:23:37 <samnardoni> i'll check out lambda calculus now
21:23:44 <Axman6> good idea ;)
21:23:44 <FunctorSalad> and the compiler assumes it is allowed to do that, for pure values like "Int"
21:23:58 <tensorpudding> the lambda calculus is nice
21:23:59 <pikhq> samnardoni: Take Haskell. Now, remove everything but \.
21:24:00 <FunctorSalad> (transform that program to one that makes two randoms)
21:24:15 <zoheb> I googled around no end but just couldn't find it!! How do we turn off monomorph restriction inside a haskell source file
21:24:16 <pikhq> Erm. /
21:24:35 <Peaker> zoheb, {-# LANGUAGE NoMonomorphismRestriction #-} at the top, I think
21:24:38 <FunctorSalad> OTOH, monadic randoms let you explicitly tell it what to do
21:24:42 <zoheb> oh thanx
21:25:14 <FunctorSalad> @help fact
21:25:15 <lambdabot> fact <fact>, Retrieve a fact from the database
21:25:27 <FunctorSalad> how do you store facts?
21:25:59 <Axman6> @fac
21:26:00 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
21:26:06 <kmc> pikhq, the simply typed lambda calculus isn't turing-complete
21:26:28 <kmc> so you need to keep the part of haskell where bindings are mutually recursive
21:26:31 * Axman6 quite likes untypes lambda calculus
21:26:32 <FunctorSalad> @help fact-cons
21:26:32 <lambdabot> cons information to fact
21:26:41 <FunctorSalad> @help fact-set
21:26:41 <kmc> or provide "fix" as a primitive
21:26:41 <lambdabot> Define a new fact, guard if exists
21:26:51 <FunctorSalad> @fact-set nmr  {-# LANGUAGE NoMonomorphismRestriction #-}
21:26:51 <lambdabot> Fact recorded.
21:26:55 <tensorpudding> I like combinatory logic
21:26:55 <FunctorSalad> @fact nmr
21:26:55 <lambdabot> nmr: {-# LANGUAGE NoMonomorphismRestriction #-}
21:26:58 <FunctorSalad> :)
21:27:10 <pikhq> kmc: Ah, right -- it's a typed lambda calculus, and those require a bit more to be TC.
21:27:13 <tensorpudding> I discovered Lazy K and now I want to go SKIing
21:27:24 <samnardoni> curried functions almost make me feel like it's metaprogramming ha
21:28:49 <zoheb> I am trying to use Applicative with Parsec like this pure(++) <*> char 'a' <*> char 'b'
21:29:06 <kmc> samnardoni, you can metaprogram haskell too :)
21:29:09 <zoheb> And get the error <interactive>:1:8:
21:29:14 <FunctorSalad> zoheb: first <*> must be <$>
21:29:22 <kmc> but you don't need to nearly as much
21:29:24 <zoheb> No instance for (Control.Applicative.Applicative
21:29:28 <FunctorSalad> err nevermind, you pured it
21:29:28 <Axman6> hmm, wouldn't that be (++) <$> char 'a' <*> char 'b'?
21:29:36 <kmc> because first-class functions, and first-class imperative code, don't need to be "meta"
21:29:37 <zoheb> yes
21:29:43 <Axman6> :t pure (++)
21:29:44 <lambdabot> forall m (f :: * -> *). (Monoid m, Applicative f) => f (m -> m -> m)
21:29:57 <zoheb> so isnt parsec part of applicative ?
21:30:01 <Axman6> god damn it Cale!
21:30:07 <zoheb> or do I need to import smthing
21:30:25 <FunctorSalad> well you can't (++) chars
21:30:34 <Axman6> that too
21:30:49 <zoheb> oops sorry
21:31:00 <zoheb> Its actally [char]
21:31:18 <zoheb> I simplified it b4 pasting into #haskell
21:31:40 <FunctorSalad> instance (Monad m) => Applicative (ParsecT s u m)
21:31:41 <zoheb> its actually smthng like sequence char 'x'
21:31:54 <FunctorSalad> zoheb: are you using the current parsec?
21:32:02 <FunctorSalad> that should have an Applicative instance
21:32:03 <Axman6> zoheb: any chance you could use real words please? :(
21:32:09 <zoheb> Its a 3 month old install
21:32:28 <zoheb> I type too slow
21:32:31 <zoheb> sorry :-)
21:33:20 <Peaker> It kind of impedes on lambdabot's purpose of helping newbies, when the types of stuff are all different
21:34:04 <zoheb> :t pure (++) <*> (sequence (char 'x')
21:34:05 <lambdabot> parse error (possibly incorrect indentation)
21:34:07 <zoheb> :t pure (++) <*> (sequence (char 'x'))
21:34:09 <lambdabot>     Couldn't match expected type `[f a]' against inferred type `Doc'
21:34:09 <lambdabot>     In the first argument of `sequence', namely `(char 'x')'
21:34:09 <lambdabot>     In the second argument of `(<*>)', namely `(sequence (char 'x'))'
21:35:19 <FunctorSalad> @ty char
21:35:20 <lambdabot> Char -> Doc
21:35:25 <FunctorSalad> different `char' :)
21:35:34 <FunctorSalad> from some prettyprinter lib
21:40:12 <zoheb>  :t pure (++) <*> sequence (replicate 3 $char 'x') <*> sequence (replicate 3 $char 'x')
21:40:35 <zoheb> :t parse
21:40:37 <lambdabot> Not in scope: `parse'
21:40:38 <Axman6> sounds like you want replicateM
21:40:48 <Axman6> :t replicateM
21:40:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
21:40:53 <zoheb> yes
21:40:58 <zoheb> thats simpler
21:41:55 <zoheb>  :t pure (++) <*> sequence (replicate 3 $char 'x') <*> sequence (replicate 3 $char 'x')
21:42:05 <zoheb> @type pure (++) <*> sequence (replicate 3 $char 'x') <*> sequence (replicate 3 $char 'x')
21:42:07 <lambdabot>     Couldn't match expected type `f a' against inferred type `Doc'
21:42:07 <lambdabot>       Expected type: [f a]
21:42:07 <lambdabot>       Inferred type: [Doc]
21:42:23 <zoheb> f this
21:42:53 <zoheb> well anyway => my statement pure (++) <*> (replicateM 3 $char 'x') <*> (replicateM 3 $char 'x')
21:42:57 <zoheb> compiles
21:43:04 <zoheb> but I cannot parse it
21:43:24 <zoheb> I get an error Couldn't match expected type `GenParser Char () [Char]
21:43:34 <zoheb> against inferred type `[CharParser st Char]
21:44:09 <zoheb> wait
21:44:11 <zoheb> I get it
21:44:31 <kmc> @src replicateM
21:44:32 <lambdabot> replicateM n x = sequence (replicate n x)
21:44:56 <zoheb>  @src seqenceM
21:45:00 <zoheb>  @src sequenceM
21:45:07 <zoheb>  @type sequenceM
21:45:17 <kmc> your commands aren't working because they start with a space
21:45:23 <zoheb> @type sequenceM
21:45:25 <lambdabot> Not in scope: `sequenceM'
21:45:32 <kmc> "sequence" is monadic
21:45:33 <kmc> @type sequence
21:45:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:45:57 <kmc> it takes a list of actions and "sequences" them together into a single action which yields the list of results
21:46:33 <zoheb> so if I have a parser that returns a string
21:46:41 <zoheb> call it p
21:47:04 <zoheb> I should be able to write (++) <$> p <$> p
21:47:09 <kmc> in the case of parsers, "sequence" turns a list of parsers into a parser which produces lists
21:47:23 <zoheb> thats exactly what I am trying to do
21:47:30 <kmc> wouldn't it be:  (++) <$> p <*> p?
21:47:46 <zoheb> yes
21:47:53 <zoheb> thats what I meant
21:47:59 <kmc> :t let p = Just [()] in (++) <$> p <*> p
21:48:01 <lambdabot> Maybe [()]
21:48:08 <qp_pq> has haskell changed a lot since "The Haskell School of Expression" ?
21:48:11 <kmc> > let p = Just [()] in (++) <$> p <*> p
21:48:11 <lambdabot>   Just [(),()]
21:48:18 <zoheb> I think I have some kind of typo somewhere let me debg locally
21:48:23 <qp_pq> can I read like old books on haskell and expect them to still work ?
21:48:24 <kmc> qp_pq, when was it published?
21:48:45 <kmc> it's changed mostly in the direction of new optional features
21:48:47 <kmc> GHC extensions and the like
21:48:54 <dibblego> (++) <$> (join (<*>) p)
21:48:59 <qp_pq> kmc: '99
21:49:06 <kmc> unlike some languages (*cough* perl *cough*), there is a standard separate from the implementations, and that was codified in 1998
21:49:14 <kmc> but GHC supports many features not in the Haskell 98 standard
21:49:21 <qp_pq> kmc: why did you mention exactly Perl ? :P
21:49:51 <kmc> it's one of the more egregious cases
21:50:19 <qp_pq> oh come on, we have a lot of nice stuff in Perl alos
21:50:21 <qp_pq> *also
21:50:28 <qp_pq> I'm implementing Group Theory in Perl for example
21:50:31 <qp_pq> it's not that bad
21:50:39 <kmc> and it's frustrating when beginning programmers don't understand the difference between language and implementation
21:50:45 <kmc> and perl encourages that sort of thing
21:51:23 <qp_pq> Perl is ok really, we have like this huge pile of well-tested modules called CPAN, you should come over to our house(CPAN) sometime, it's pretty nice
21:51:30 <qp_pq> does Haskell have the equivalent of CPAN btw ?
21:51:36 <kmc> @where hackage
21:51:36 <lambdabot> http://hackage.haskell.org/package/
21:51:47 <kmc> i'm familiar with CPAN, i used to program perl back in the day
21:51:52 <qp_pq> and is it common practice to write tests in Haskell ?
21:52:15 <qp_pq> back in the day... when ? Perl has changed a lot since 2000 for example ..
21:52:41 <qp_pq> @where beer
21:52:42 <lambdabot> I know nothing about beer.
21:52:44 <qp_pq> @where bathroom
21:52:45 <lambdabot> I know nothing about bathroom.
21:53:24 <ksf> SUP DAWG I HERD YU LIEK REKURSHN SO I PUT A CAR IN YOUR FOLD SO YOU CAN INSPECT WHILE YOU REKURS
21:53:49 <qp_pq> ksf: fold = ?
21:53:55 <qp_pq> is that a haskell joke ?
21:54:03 <qp_pq> 'cause I don't know haskell so can you break it down to me
21:54:15 <ksf> @src fold
21:54:15 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:54:17 <ksf> @src foldl
21:54:17 <lambdabot> foldl f z []     = z
21:54:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:54:19 <ksf> @src foldr
21:54:20 <lambdabot> foldr f z []     = z
21:54:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:54:28 <ksf> car is a lispish function though.
21:54:34 <kmc> qp_pq, yes, testing is common.  see e.g. QuickCheck
21:54:35 <qp_pq> ksf: is it like reduce ?
21:54:40 <qp_pq> we have reduce in Perl
21:54:43 <kmc> @check \a b -> (a + b) == (b + a)
21:54:44 <qp_pq> in List::AllUtils
21:54:45 <lambdabot>   "OK, passed 500 tests."
21:54:47 <ksf> head is the haskell equivalent, in this case
21:54:53 <ksf> yep.
21:54:54 <sohum> > foldl1 f [a,b,c,d,e]
21:54:55 <lambdabot>   f (f (f (f a b) c) d) e
21:54:59 <sohum> > foldr1 f [a,b,c,d,e]
21:54:59 <kmc> @check \xs -> (length xs) > 0
21:55:00 <lambdabot>   f a (f b (f c (f d e)))
21:55:01 <lambdabot>   "Falsifiable, after 1 tests:\n[]\n"
21:55:11 <Jafet> Herd dawg I liek u unsafePerformIO
21:55:13 <qp_pq> kmc: what is quickcheck ?
21:55:20 <Axman6> @check \a b -> (a + b) == (b + (a :: Double))
21:55:21 <lambdabot>   "OK, passed 500 tests."
21:55:22 <ido> http://en.wikipedia.org/wiki/QuickCheck
21:55:25 <kmc> qp_pq, given a property it generates and runs testcases
21:55:26 <qp_pq> is object oriented programming common practice in Haskell ?
21:55:31 <kmc> no
21:55:32 <Axman6> qp_pq: no
21:55:37 <kmc> but we have typeclasses, which are a bit like OO interfaces
21:55:42 <qp_pq> Axman6: for real /
21:55:43 <qp_pq> ?
21:55:45 <Axman6> yes
21:55:47 <kmc> yes
21:55:48 <sohum> well, I'm sure you could twist the definition of OO to match
21:55:52 <Axman6> OO is a broken construct
21:55:55 <kmc> it can be done, but it's not natural
21:55:59 <qp_pq> so how do you handle complexity ?
21:56:06 <qp_pq> like huge amounts of code
21:56:06 <sohum> Differently (TM)
21:56:11 <qp_pq> do you have modules ?
21:56:14 <tensorpudding> yes
21:56:16 <Axman6> yes
21:56:21 <kmc> qp_pq, algebraic datatypes, abstract datatypes, modules, functional abstraction, ...
21:56:23 <qp_pq> tensorpudding: oh you're from #math :P
21:56:24 <ksf> you can do all kinds of oop, in fact, all that any oop language can do and more, all statically typed
21:56:34 <Axman6> qp_pq: frstly, haskell code is often quite small, compared to the same thing in different languages
21:56:39 <tensorpudding> you import modules, which include functions, type definitions, typeclasses, etc.
21:56:47 <ksf> qp_pq, have a look at http://homepages.cwi.nl/~ralf/OOHaskell/  for some serious mind blowing
21:56:51 <Jafet> qp_pq, what is object oriented programming?
21:56:54 <m3ga> i find it really hard to work in languages without algebraic data types
21:56:59 <zoheb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12161#a12161
21:57:04 <kmc> a module which exports a type, but not its constructors, and some functions for working with those types, is a bit like a class
21:57:05 <qp_pq> Axman6: I'm pretty sure if we had a showdown you with Haskell and me with Perl I'd win...so I wouldn't hold on to that "size" claim you have...
21:57:12 <kmc> as is an existentially wrapped typeclass instance
21:57:18 <zoheb> I can parse xxx
21:57:22 <Jafet> qp_pq, before or after gzip?
21:57:23 <zoheb> but not test
21:57:29 <Axman6> qp_pq: could you prove your code was correct though? i could
21:57:30 <qp_pq> Jafet: before
21:57:32 <qp_pq> :D
21:57:36 <Jafet> qp_pq, lame.
21:57:42 <qp_pq> Jafet: I know
21:58:00 <qp_pq> Axman6: I can only write tests...but that's not proving it correct is it
21:58:08 <qp_pq> can you explain what you mean by proving it correct ?
21:58:10 <Stinger> perl, the only language that makes you do the compression :P
21:58:15 <Axman6> well that's pretty damn lame mty friend ;)
21:58:15 <qp_pq> Stinger: hehe
21:58:43 <Axman6> qp_pq: haskell functions can be proved that they are correct as to their definition
21:58:47 <Stinger> actually from what I know, j could probably qualify for that too
21:58:56 <Axman6> Stinger: oh yes indeed
21:59:06 <qp_pq> j = ?
21:59:11 <tensorpudding> J is pretty crazy
21:59:15 <qp_pq> Axman6: can you give an example ?
21:59:19 <kmc> you can't prove every property in haskell's type system
21:59:19 <tensorpudding> J is like APL on steroids
21:59:26 <m3ga> qp_pq: the person who wrote Pugs (the first Perl6 implementation) wrote it in Haskell not Perl. Thats a complex piece of code. they chose haskell for a reason.
21:59:32 <Jafet> J is APL on steroids.
21:59:34 <Axman6> no... and ym harddrive is giving strange sounds. fuck
21:59:43 <kmc> qp_pq, if you give me an XML schema, i can write a haskell program which i prove can only output XML conforming to that schema
21:59:53 <kmc> the same holds for any context-free grammatical type
22:00:09 <kmc> because i can encode any such type as a set of mutually recursive algebraic datatypes in Haskell
22:00:10 <qp_pq> m3ga: yeah but now we have Rakudo under VM named Parrot...
22:00:13 <qp_pq> m3ga: which is faster
22:00:47 <ksf> I don't think parrot has ever been optimized for speed
22:00:57 <kmc> haskell also supports a lightweight way to "tag" data, so that e.g. if I'm writing an RPG, and i have hit points and gold points, i can make sure i don't accidentally add the two, even though they're both represented internally as Integers
22:01:03 <m3ga> and it took how much longer to develop, by how many more people?
22:01:04 <kmc> and again, that's proven at compile time
22:01:08 <Jafet> Maybe he means it fails faster
22:01:22 <kmc> in Haskell, types exist to specify and prove properties of programs.  not merely to specify bit-level representation, as in C
22:01:23 <qp_pq> kmc: why is it such a difficulty to write that kind of code ? I can write Perl code that recognizes the XML generated as part of a grammar which I can write in Parse::RecDescent or Yapp ...
22:01:37 <qp_pq> kmc: or basically any grammar...also ANTLR (which is not Perl but anyway)
22:01:44 <kmc> qp_pq, not talking parsing
22:01:46 <kmc> i'm talking about output
22:02:00 <kmc> can you write a Perl program which is *proven* to generate XML which conforms?
22:02:02 <Jafet> qp_pq, can you write a proof that your perl code is correct?
22:02:19 <qp_pq> no but I don't get the advantage
22:02:32 <kmc> you don't get the advantage to finding bugs at compile time instead of run time?
22:02:33 <qp_pq> can you expect me to appreciate that I can prove my code is correct ?
22:02:49 <kmc> in haskell, when programs compile without error, they are very likely to be correct
22:02:52 <Jafet> qp_pq, no, not really. Most people don't anyway.
22:03:00 <qp_pq> so can you be more explicit ?
22:03:04 <qp_pq> like give an example
22:03:04 <ksf> the advantage doesn't come from the actual prooving, (at least in my case), but having a language that's easily provable also means that it's easy to reason about.
22:03:05 <tensorpudding> haskell is a vastly different language than perl
22:03:07 <kmc> in Perl almost nothing can be said about a program which loads correctly.  it might not even be syntactically correct
22:03:07 <qp_pq> so I can understand
22:03:29 <qp_pq> tensorpudding: if you would read Mark Jason Dominus - Higher Order Perl that would slightly change your mind maybe
22:03:40 <kmc> qp_pq, the goal is to find every bug as early as possible.  if we can exhaust a set of bugs at compile time, that is a tremendous win
22:04:00 <qp_pq> that's interesting
22:04:08 <qp_pq> because I've been doing a lot of testing in Perl lately
22:04:11 <Jafet> qp_pq, you are talking about power. There is no doubt that perl is powerful. We are talking about correctness.
22:04:15 <Axman6> qp_pq: one example of proving code correct: the seL4 kernel written by NICTA here in australia is am implementation of the L4 kernel which was written in haskell, and proven that it will never crash, without hardware failures. that's what proving your code gives you
22:04:15 <qp_pq> and I'm writing math-oriented software
22:04:49 <rasterfar> and has to be experienced to be really appreciated; usually when a modest sized Haskell program compiles, it behaves as intended.
22:04:53 <qp_pq> so how do I prove my code ?
22:05:00 <qp_pq> and why can Haskell prove its own code to be correct ?
22:05:32 <Axman6> uing refertencial transparency often: the stuff on the left of an equals sign can be exactly replaced with whatever is on the right of it, and they are quaranteed to give the same result
22:05:35 <Jafet> Haskell can't usually, but you can, because Haskell has very simple and well-defined semantics.
22:05:44 <qp_pq> I watched a presentation given by some guys at ABN-AMRO who are doing banking-stuff in Haskell, they said the moment your Haskell compiles you can be pretty sure it'll do what you want ...
22:06:17 <rasterfar> it's quite a feeling...
22:06:32 <qp_pq> can I get a job with Haskell ?
22:06:39 <sohum> qp_pq: so that's half of it, right? the strong and expressive type system means that a large class of errors that you get in other languages just go away
22:06:42 <ksf> ouch. are those people really considering marketing a closed-source kernel?
22:06:42 <rasterfar> (mind you getting it to compile can sometimes be tricky)
22:06:58 <Axman6> data Tree a = Node a (Tree a) (Tree a) | Leaf a; reverseTree (Leaf x) = Leaf x; reverseTree (Node x l r) = Node x (reverseTree r) (reverseTree l) -- this can be proven to reverse all trees
22:07:04 <ksf> there's never going to be a non-floss os besides and after windows, ever again.
22:07:05 <sohum> qp_pq: I find myself giving haskell-style type signatures to functions in other languages now
22:07:09 <Jafet> @faq Can Haskell get you a job?
22:07:10 <lambdabot> The answer is: Yes! Haskell can do that.
22:07:18 <ksf> too much open competition to get a hold of market share.
22:07:32 <qp_pq> how ?
22:07:32 <Jafet> ksf, Mac OS
22:07:37 <qp_pq> suppose I learn Haskell
22:07:40 <ksf> Jafet, is mostly BSD
22:07:43 <qp_pq> and I run out of money and I need a job
22:07:47 <shrughes> qp_pq: the last time i got hired it was in part because of the haskell on my resume -- this was for a C# webapp job
22:07:48 <qp_pq> where do I go to get a job with Haskell /
22:07:49 <qp_pq> ?
22:07:54 <kmc> qp_pq, for starters, it will make you a better programmer in every language
22:08:00 <Stinger> @faq will haskell pay off all your debts?
22:08:01 <lambdabot> The answer is: Yes! Haskell can do that.
22:08:03 <qp_pq> shrughes: why were they so impressed ?
22:08:09 <Jafet> It's BSD with a buggy, leaky, proprietary chrome plating
22:08:15 <sohum> @faq will haskell make me a sandwich?
22:08:15 <lambdabot> The answer is: Yes! Haskell can do that.
22:08:20 <kmc> smart employers think that only really smart people learn haskell
22:08:44 <kmc> qp_pq, http://www.paulgraham.com/pypar.html
22:08:48 <kmc> it's not true for python anymore
22:08:54 <kmc> but it's a good general point
22:08:58 <tensorpudding> I surely hope that Unix is not to be considered the pinnacle of OS design
22:09:11 <shrughes> qp_pq: the probability that i was an idiot became much lower with that info on the resume
22:09:17 <ksf> but a blog with some cool posts using haskell will gain you more than just mentioning it on your resumee
22:09:20 <Stinger> shrughes, what did you have on your resume haskell related though?
22:09:29 <Axman6> Jafet: wait, are you implying that linux isn't buggy? or the BSD's aren't?
22:09:33 <Jafet> There is also the article with Blub
22:09:41 <qp_pq> I don't get how QuickCheck is different from my Test::More ?
22:09:42 <shrughes> Stinger: a monad transformer variant of Parsec
22:09:51 <Jafet> Axman6, they're rather less buggy than most things.
22:10:01 <Axman6> i can;t say i agree
22:10:08 <kmc> qp_pq, the "proving" thing we're talking about has nothing to do with QuickCheck
22:10:12 <kmc> that's an additional layer
22:10:23 <Axman6> testing /= proving
22:10:28 <qp_pq> what additional layer ?
22:10:32 <kmc> testing
22:10:35 <ksf> can Test::More infer the type of input it needs to feed?
22:10:41 <kmc> testing is an additional layer on top of what the type system proves for you
22:10:43 <sohum> qp_pq: ever heard of Hoare Logic?
22:10:47 <kmc> the proof is always better than any number of tests
22:11:07 * Axman6 wants to write a Hoare Logic thing in haskell sometimw
22:11:09 <Jafet> (Assuming it's the correct proof)
22:11:09 <Axman6> e*
22:11:31 <qp_pq> ksf: if I write a parser for my code and see which methods are used inside a sub and see what data types are available I bet I can guess the needed prototype for a sub , and yes we have prototypes in Perl
22:11:40 <Axman6> i love doing structural induction in haskell
22:11:40 <qp_pq> sohum: havne't heard of it
22:11:48 <qp_pq> sohum: what is it ?
22:11:51 <Jafet> qp_pq, sure, now go ahead and write a parser for perl.
22:11:55 <Jafet> We'll wait.
22:11:59 <qp_pq> Jafet: haha
22:12:04 <kmc> qp_pq, if you're interested in Haskell, I suggest you learn it and write some programs
22:12:07 <Axman6> and we'll wait for you rp show that is is correct
22:12:13 <kmc> then you will be able to frame the similarity and differences with Perl better
22:12:16 <Axman6> to*
22:12:26 <qp_pq> no no ... I'll skip writing it
22:12:29 <qp_pq> I have other stuff
22:12:30 <ksf> qp_pq, well, haskell gives you that for free.
22:12:30 <kmc> it is a vastly different world, certainly not better in every respect, but a lot of superficial similarities will not pan out
22:12:44 <ksf> ...simple type inference.
22:12:49 <sohum> qp_pq: it's how you'd prove properties about programs (usually correctness) in a lot of the languages used today
22:12:58 <sohum> qp_pq: it's fantastically ugly and painful.
22:13:05 <Jafet> qp_pq, when kmc said "learn it and write some programs in it", he was repeating the same thing twice
22:13:30 <qp_pq> heh
22:13:42 <qp_pq> the only problem for me is that I will probably also need a job
22:13:49 <sohum> qp_pq: due mostly to the structure of those programming languages not being designed for privability
22:13:50 <qp_pq> and I'd love to write in a high-level programming language
22:14:00 <shrughes> try C++ then
22:14:05 <kmc> hahaha
22:14:07 <ksf> In some sense, haskell and perl are very similar, that is, they share some ideology.
22:14:10 * sohum winces
22:14:13 <kmc> C++ is as hard as Haskell
22:14:17 <kmc> but all of that energy goes to waste
22:14:20 <ksf> I'm not really able to pinpoint it, though.
22:14:22 <kmc> just keeping your head above the bullshit
22:14:26 <ksf> c++ is way harder than haskell.
22:14:28 <shrughes> C++ is definitely harder
22:14:37 <qp_pq> I know I like Perl a lot because I have testing,a shitload of modules, list manipulation is extremely useful and handy, and I can basically get stuff done fast
22:14:40 <Jafet> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:14:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:14:45 <ksf> haskell is deep, c++ is broad, and, more importantly, mutually excludes itself.
22:14:45 <kmc> i don't trust any language with loads of "design patterns".  it means they're identifying abstractions they can't implement
22:14:49 <qp_pq> Perl is not for the faint-hearted though ...
22:15:09 <kmc> it's important to identify design patterns; it's also important to write them as code and stop repeating yourself
22:15:23 <kmc> when you have a book, in English, on dead trees, which tells you *how* to write a function by filling in the blanks...
22:15:23 <qp_pq> ksf: what is that ideology ?
22:15:57 <ksf> I guess that with both perl and haskell, if you think of the most craziest things, it turns out that the language isn't keeping you from implementing it.
22:15:57 <rasterfar> Can I take this opportunity to ask what is meant by "avoid success at all costs"?  I've been hearing this since I came back to Haskell...
22:16:30 <ksf> while haskell might look like bondage+discipline for the casual observer, it's actually freedom pure.
22:16:47 <shrughes> rasterfar: If people use the language, you can't take as much liberty to improve the language.
22:17:00 <rasterfar> ah, i see
22:17:11 <kmc> ksf, Haskell lets us implement crazy things, but forces us to specify precisely what we mean
22:17:31 <kmc> the result is code you can actually reason about
22:17:34 <Jafet> ksf, that's because it supplies you the bottom.
22:17:47 <Axman6> qp_pq: sounds like you like perl for the same reasons we like haskell
22:17:54 <ksf> the problem being, the more you improve the language, the more people use it.
22:18:32 <ksf> that's why we use terms like contravariant functor all the time, to scare most of the masses away.
22:18:50 <qp_pq> lol
22:18:54 <qp_pq> I do some algebra
22:19:03 <rasterfar> heh.  well, depends if the syntax becomes (***) /= >>= <-- etc. that oughtta put off enough people for the time being
22:19:10 <qp_pq> but really from what I've read category theory is generalizing all the mathematical objects
22:19:17 <Jafet> Zygohistomorphic prepomorphisms!
22:19:19 <qp_pq> so what can be expected of this generalization ?
22:19:23 <BMeph> rasterfar: Are you familiar with Fred Brooks' "Mythical Man-Month"? :)
22:19:33 <qp_pq> something that general , is it still saying anything abou tanything?
22:19:37 <Cale> Hey, where did the Show instances in quickcheck go?
22:19:44 <rasterfar> I always read that "Man-Moth" and thought it was an anthropological treatise
22:20:18 <rasterfar> (BMeph: in a word, not intimately)
22:20:25 <ksf> CT is all about abstractions, which only really exist if you're planotian.
22:20:28 <ksf> *platonian
22:20:40 <ksf> the stuff is just useful
22:21:00 <qp_pq> platonian = ?
22:21:03 * qp_pq is being ignorant
22:21:13 <kmc> to my understanding, CT is a way of organizing results
22:21:25 <kmc> even if your results don't generalize to every category, you have a uniform vocabulary to state them in
22:21:27 <ksf> well, platon considered ideas to exist in a real sense in some kind of parallel universe.
22:21:43 <Jafet> Plato
22:21:43 <kmc> but i don't yet understand adjunctions so you shouldn't listen to me about CT
22:21:54 <ksf> true things were always there, you just had to unveil their existence by reasoning.
22:22:34 <qp_pq> Haskell seems hard
22:22:37 <qp_pq> but let me tell you
22:22:47 <tensorpudding> category theory provides a common structure for a lot of different things in mathematics
22:22:49 * ksf thinks that's both false and true, as some ideas are so universial they can be termed laws, but some are just BS.
22:22:56 <qp_pq> this C++0x shit , I read some presentation and watched some lectures, it's get much more intense and extremely harder
22:23:02 <Axman6> @where lyah
22:23:03 <lambdabot> www.learnyouahaskell.com
22:23:03 <Axman6> qp_pq: start here ^^^^
22:23:07 <Axman6> ^^^^^^^^^^*
22:23:09 <Jafet> C++ isn't hard.
22:23:16 <Jafet> It's tedious.
22:23:21 <Jafet> Ever implemented tuples?
22:23:29 <ksf> c++ is mutually exclusive.
22:23:32 <kmc> Jafet, boost has
22:23:33 <qp_pq> Jafet: no
22:23:37 <ksf> it self-destructs if you use all of it.
22:23:38 <kmc> C++ is really hard
22:23:42 <qp_pq> Jafet: isn't a tuple a template maybe ?
22:23:42 <kmc> too many features interacting
22:23:45 <tommd> data Tuple a b = T (a,b)
22:23:45 <kmc> it's *also* tedious
22:23:59 <kmc> boost has libraries for tuples and variants
22:24:03 <Axman6> tommd: i'd use T a b personally
22:24:11 <tommd> I figured someone would say that :-)
22:24:16 <kmc> or use newtype
22:24:19 <tommd> and that
22:24:21 <Jafet> That's a pair.
22:24:21 <Axman6> since, you're not writing your own tuple at all there, just wrapping one
22:24:26 <m3ga> boost::variant is completely frucking horrible!!!!
22:24:27 <ksf> tommd, data S a b = S a b
22:24:38 <kmc> m3ga, how so?
22:24:39 <ksf> ...no need to define it in terms of primitive tuples :)
22:24:49 <kmc> it's usable, given that C++ makes easy things hard
22:24:51 <ksf> oh, and it's not S for Sum, but P for Product.
22:25:00 <Axman6> qp_pq: how do you define datatypes in perl? could you define a binary tree type for me?
22:25:10 <Jafet> I think LYAH has an exercise where you implement tuples. I never understood what it wanted.
22:25:14 <qp_pq> do you guys get the templates in C++ ? I don't mean just templates, I mean template meta-programming, the one Stepanov does in his rocketscience-books
22:25:16 <ksf> sum would be data S a b = L a | R b
22:25:26 <kmc> qp_pq, template metaprogramming is terrible
22:25:31 <tommd> Jafet: You can nest 2-tuples thus creating N-tuples.  That's exactly how Isabelle does it.
22:25:31 <ksf> and you've got every possible data type covered.
22:25:32 <qp_pq> kmc: it is ?
22:25:33 <Jafet> qp_pq, even the C++ compiler writers don't get C++.
22:25:35 <kmc> because it's just metaprogramming in a needlessly complex language
22:25:53 <qp_pq> Jafet: C++ is very hard, it makes me bang my forehead on the table
22:25:56 <sohum> I believe c++ template metaprogramming is strictly more powerful than haskell's capabilities
22:25:57 <kmc> templates form another language, totally unlike C++, and needlessly difficult
22:25:57 <m3ga> kmc: any class you want to put in a variant has to satisty a bunch of traits. once you've implemented all the traits on all the classes you have so much code you might as well have just greenspun the whole thing yourself.
22:26:04 <sohum> but it's also painful and annoying
22:26:10 <Jafet> tommd, but can you identify the arity of such tuples within the type system?
22:26:10 <kmc> you can metaprogram Haskell using Haskell
22:26:13 <johnw> Jafet: um, I'm a C++ compiler writer
22:26:16 <kmc> not using some other bizarre thing you have to learn separately
22:26:16 <ksf> templates are turing complete, haskell's type system only with extensions.
22:26:21 <ksf> but then we have template haskell.
22:26:21 <tommd> Jafet: You really have to.
22:26:24 <ksf> and sane syntax.
22:26:26 <Axman6> qp_pq: can you implement a binary tree datatype for me in perl?
22:26:32 <ksf> and error messages.
22:26:41 <kmc> you also don't *need* to metaprogram Haskell nearly as much, because there are more abstractions available
22:26:41 <qp_pq> Axman6: we have this thing called Moose now in Perl so you can do stuff like
22:26:41 <tommd> Jafet: Tuple Int (Tuple Char (Tuple Blah Float))
22:26:44 <qp_pq> Axman6: just a moment ...
22:26:50 * qp_pq searches syntax
22:26:53 <kmc> e.g., instead of templates for types, we have parametrized types
22:27:14 <tommd> some sugar to clean it up and you have a tuple system.  Isabelle actually uses this + sugar for both tuples and lists.
22:27:16 <Axman6> data Tree a b = Node a (Tree a b) (Tree a b) | Leaf b -- qp_pq done
22:27:18 <kmc> instead of big ugly boost::tuple / boost::variant templates, we have those things as the basic building blocks for data types
22:27:29 <Jafet> tommd, but doesn't Isabelle have a more powerful type system?
22:27:42 <kmc> anyway, i'm not sure we can have a fruitful "can you do foo in Perl / Haskell" discussion unless all parties know both Perl and Haskell very well
22:28:01 <kmc> otherwise it's all Blub
22:28:01 <johnw> kmc: boost::variant is not a big ugly template if you're only using it
22:28:15 <tommd> I wouldn't call it more powerful, but it is complemented by the fact that it can perform powerful analysis.
22:28:21 <johnw> i have plenty of variant code, and it's much cleaner than using unions
22:28:22 <shrughes> an important question is whether you can do it without "knowing it well"
22:28:28 <kmc> johnw, okay next time it fails and produces a 2-page error message, i will send it to you ;)
22:28:39 <johnw> you know that's an exaggeration
22:28:45 <kmc> barely
22:28:54 <johnw> i can't remember the last C++ error that wasn't self-evident to me; it's a matter of familiarity
22:29:03 <Axman6> johnw: which compiler do you write btw?
22:29:23 <johnw> Axman6: I wrote much of the template parser in C++Builder 5.0 and on
22:29:28 <Jafet> tommd, I don't think expressing arity of such tuples is convenient in Haskell
22:29:31 <Axman6> never heard of it
22:29:32 <kmc> to the Perl-only programmer, every feature in Haskell has an "obvious" equivalent in Perl.  and vice versa.
22:29:37 <kmc> you have to learn both to see the differences
22:29:40 <johnw> Borland's compiler?
22:29:50 <tommd> Jafet: And we are in agreement there!
22:29:55 <Jafet> Hah
22:29:56 <johnw> it's a Windows thing, although I did port that compiler to Linux
22:30:01 <Axman6> yeah, i'm too young to know anything about Borland ;)
22:30:11 <kmc> anyway, you don't have to be a GHC developer to understand errors about Haskell's parametrized types
22:30:11 <johnw> they still sell it! haha
22:30:18 <tensorpudding> i remember borland
22:30:25 <johnw> kmc: I have been quite mystified by some of GHC's error messages
22:30:33 <johnw> i think it comes down to your comfort zone
22:30:46 <johnw> it's a matter of, "oh yeah, I've seen that before"
22:30:57 <Jafet> GHC does need better error messages.
22:31:03 <Jafet> I wonder how Helium is going with that.
22:31:14 <ksf> helium is overrated
22:31:38 <m3ga> johnw: i've coded in C++ on and off since 1991 and haskell for a year. C++ error messages from g++ take me way longer to decipher than ghc error messages.
22:31:40 <Jafet> "We put the vapour in vapourware!"?
22:32:15 <kmc> GHC does have bad error messages.  but i'll take an error about parametric polymorphism over a failed template-metaprogram any day
22:32:17 <johnw> m3ga: i don't doubt that's true most of the time; I wasn't saying C++ was good at it, just that it's not like GHC is transparent next to C++ being indecipherable.  That was an unfair comparison
22:32:25 <ksf> I mean, would you ever tell a newbie to use helium in the same way that schemers would tell newbies to use the right drscheme mode?
22:32:42 <ksandstr> how about just a guide to interpreting ghc's error messages
22:32:54 <ksandstr> you guru-types must have a reasonably consistent method to it
22:33:04 <dmwit> "read it"
22:33:12 <dmwit> wait, one more hint
22:33:13 <kmc> the problem is that TMP errors are not really compiler errors -- they are errors generated by *user-specified* code in the template meta-language
22:33:14 <dmwit> "carefully"
22:33:20 <ksandstr> dmwit: presumably that has already failed
22:33:21 <kmc> but they're not treated as such
22:33:33 <Jafet> I would not tell a newbie to use drscheme either...
22:33:40 <ksf> with type errors, I usually even just scan for the first type mentioned, and then look where vim puts the cursor.
22:33:46 <kmc> in TH a metaprogram fails the same way as any haskell program
22:33:50 <dmwit> It's only failed me twice before, and both times were because I was using type-system extensions I didn't understand.
22:33:51 <johnw> kmc: Boost has gotten a lot better about having the TMP error grounded in a class whose name tells you how to solve the problem
22:33:54 <kmc> because that's what it is
22:33:59 <dmwit> So I guess my next step is "read the paper, too".
22:34:07 <Jafet> john, using silly hacks
22:34:10 <ksf> I think it's more getting on equal terms with the type system than actually deciphering the messages.
22:34:14 <johnw> like, "return_of_lvalue_needs_xxx"
22:34:16 <ksandstr> dmwit: ah. the guide would be larger than was useful. this makes sense.
22:35:31 <ksf> johnw, you are aware of the fact that that's an utter hack?
22:35:43 <ksf> (not that there's one or two haskell libraries that do the same thing)
22:35:48 <ksf> HList comes to mind.
22:35:54 <johnw> ksf: sure
22:35:57 <ksf> but oleg doesn't count, anyway.
22:36:15 <dmwit> Oleg doesn't use the type system, he battles it.
22:36:18 <dmwit> and WINS
22:36:21 <tensorpudding> oleg is a hack?
22:36:39 <ksf> it's the type system that's battling oleg, and it looses.
22:36:52 <qp_pq> Axman6: I think you're right I wasn't able to complete my Perl version
22:37:01 <qp_pq> Axman6: subtype 'Tree' => as 'ArrayRef[Tree]' => where { my @children = @_ ; all { $_->isa('Tree') } @children }
22:37:09 <Jafet> ksf, your BSDM analogy comes to mind
22:37:12 <Axman6> so datatypes aren't first class objects in perl?
22:37:14 <qp_pq> Axman6: I can't get a basecase for this because I don't kno wenough syntax
22:37:17 <ksf> tensorpudding, oleg uses involved enough types to care about introducing extra types to make errors decipherable.
22:37:20 <EvanCarroll> wow
22:37:22 <EvanCarroll> hahahhaha
22:37:24 <qp_pq> EvanCarroll: :)
22:37:37 <kmc> Axman6, they're not really first-class in Haskell either
22:37:45 <qp_pq> EvanCarroll: can you stop laughing and help me finish the code ?
22:37:48 <EvanCarroll> I think LYAH just told me how to finish cracking this AT vin-obscurity algo.
22:37:48 <Axman6> as if they're not?
22:37:59 <EvanCarroll> through an example
22:38:09 <qp_pq> EvanCarroll: ?
22:39:04 <EvanCarroll> AutoTrader.com, they take a number and generate a character bitmap and hide the vin characters in the bitmap by moving a window
22:39:09 <ksf> Jafet, as they say, slavery is freedom.
22:39:23 <qp_pq> EvanCarroll: what were you laughing at
22:39:27 <qp_pq> EvanCarroll: my codez ?
22:39:55 <ksf> If I wouldn't have a way to constrain my thought process, I would be thinking about female body parts all day long.
22:39:56 <dmwit> qp_pq: You're on a Haskell channel asking people to finish your Perl code? O_o
22:40:05 <Peaker> I think the worst ghc errors are not about polymorphism but about infinite types
22:40:16 <ksf> yep
22:40:21 <EvanCarroll> the creation of the bitmap from the key has always ultimately illuded me, i think it uses Collatz sequence as defined in the higher-order-function chapter
22:40:24 <ksf> those could be more helpful
22:40:32 <qp_pq> dmwit: kind of
22:40:41 <EvanCarroll> just as luck would have it
22:41:08 <dmwit> qp_pq: I can't say I'm terribly surprised that you're not getting help.  Have you tried #perl or ##perl or whatever the right channel is?
22:41:17 <dmwit> looks like #perl
22:41:51 <EvanCarroll> qp_pq: where is your code?
22:42:03 <EvanCarroll> that is moose i can help you
22:42:35 <EvanCarroll> don't use string types ffs
22:42:42 <EvanCarroll> and use MooseX::Types
22:43:08 <EvanCarroll> and isa->'Tree' sounds like a bad idea
22:46:41 <Jafet> After this commercial break, returning you to #haskell
22:47:32 <qp_pq> Perl is great , it comes with beer and women in a package
22:47:52 <qp_pq> and you get instant popularity
22:48:04 <Axman6> not from me
22:49:47 <EvanCarroll> qp_pq: see you in #perlcafe if you need perl help w/ moose
22:50:59 <tensorpudding> only perl hackers would need to get their women from CPAN
22:51:14 <dmwit> oh SNAP
22:51:19 <Axman6> heh, beat me to it
22:51:32 <Axman6> yeah, my woman is sitting right on my bed at the moment :P
22:51:57 <kmc> why the fuck are you on irc then
22:52:12 <johnw> maybe that's the real problem with Haskell...
22:52:53 <tensorpudding> that #haskell is more interesting than romantic attachments?
22:53:15 <johnw> yeah, at least c++ makes you run crying like a baby into the arms of your girl
22:53:26 <kmc> @vixen haskell or sex?
22:53:27 <lambdabot> church is my favourite computer scientist.
22:53:54 <BMeph> kmc: Obviously, Axman6 is here because "There's Something Wrong on the Internet!" ;p
22:54:00 <Axman6> yes!
22:54:09 <qp_pq> :)))))
22:54:27 <Axman6> i'm waiting for a backup to finish btw
22:54:27 <qp_pq> Axman6: so tell us about your haskell girlfriend
22:54:28 <qp_pq> ..
22:55:04 <Axman6> well, she's really pretty, and really smart, and she's not insane
22:55:19 <qp_pq> oh nice
22:55:23 <dmwit> but can she code?
22:55:27 <qp_pq> why did you have to mention she's not insane ?
22:55:29 <Axman6> not really
22:55:36 <Axman6> because most girls are insane
22:55:39 <qp_pq> oh yeah, and what does she do ?
22:55:53 <qp_pq> Axman6: I tend to agree
22:56:07 <mmmdonuts> Godel proved that's impossible.  Pretty, smart, not insane: pick any two.
22:56:28 <Axman6> i have all three
22:56:28 <tensorpudding> mmmdonuts: i think you are mistaken...
22:56:35 <johnw> mmmdonuts: lol
22:56:39 <dmwit> I choose smart, not insane, and SMOKING HOT
22:56:44 <mmmdonuts> You mean Godel is mistaken.
22:56:48 <qp_pq> Godel is dead
22:56:53 <qp_pq> above all
22:56:58 <Jafet> You forgot cook all your meals
22:57:08 <dmwit> sanity is for the weak
22:57:09 <kmc> hahaha
22:57:10 <tensorpudding> Godel had a rather depressing death
22:57:18 <dmwit> insane girls are more fun
22:57:21 <qp_pq> he tried to convince a judge that America's law system was flawed for god's sakes...
22:57:24 <qp_pq> fuck Godel
22:57:36 <tensorpudding> he died from malnutrition because he went insane after his wife died
22:57:46 <Axman6> qp_pq: it is flawed, severely
22:57:55 <kmc> he thought people were poisoning him so wouldn't eat any food not prepared by her
22:58:01 <tensorpudding> yeah
22:58:06 <_xor> heh
22:58:10 <_xor> girls = overrated half the time
22:58:14 <_xor> Gotta be picky
22:58:15 <Peaker> why would people poison him? why did he start to think those thoughts?
22:58:21 <qp_pq> Axman6: yeah but you have to be insane to try to prove it to a judge because...
22:58:26 <_xor> Of all of the girls I've met, only one really sticks out.
22:58:27 <Axman6> heh
22:58:28 <ksandstr> Peaker: see "going nuts"
22:58:32 <_xor> She's cute, smart, driven, funny, etc.
22:58:36 <Axman6> i think many US judges would agree tbh
22:58:36 <tensorpudding> this discussion is veering too far to guys-only
22:58:37 <_xor> ...except she's a bit on the flakey side.
22:58:46 <_xor> oh er, ok...
22:58:53 <_xor> HURR HURR YEEEAAAH BEER AND TITTIES
22:59:04 <tommd> take it to haskell-blah
22:59:05 <_xor> how's that teneighty? :)
22:59:08 <_xor> god damnit
22:59:11 <_xor> gg nick-complete
22:59:23 <tensorpudding> haskell-blah has actually been having a stimulating discussion of the curry-howard isomorphism
22:59:24 <kmc> @vixen beer or titties?
22:59:25 <lambdabot> nevermind about that
22:59:33 <ksandstr> head swap time?
22:59:34 <kmc> @vixen show us yer tits
22:59:35 <_xor> oh god
22:59:35 <lambdabot> don't you wish you could see?
22:59:52 <tensorpudding> lol
22:59:56 <FunctorSalad> "<_xor> She's cute, smart, driven, funny, etc." :)
23:00:20 <_xor> werd
23:00:26 <_xor> We were really close friends.
23:00:35 <_xor> Would talk everyday on the phone for hours, etc etc
23:00:37 <_xor> All of that jazz
23:00:44 <_xor> Until it just all ended one day, for no reason.
23:00:49 <FunctorSalad> :(
23:00:56 <_xor> Meh, it's ok...life goes on :)
23:01:03 <_xor> I do miss having that kind of a friendship/whatever in my life though.
23:06:57 <Jafet> Nothing more on topic than Haskell programmers in a Haskell channel talking about women
23:07:11 <johnw> it is the ultimate goal of any program, no?
23:11:22 <qp_pq> of course
23:11:25 <qp_pq> Haskell and a woman
23:11:28 <qp_pq> and a hut
23:11:31 <qp_pq> on the seaside
23:11:34 <qp_pq> with a laptop
23:11:44 <qp_pq> and wireless internet
23:11:48 <qp_pq> what more can you wish for ?
23:11:52 <johnw> and a screen that doesn't fade out in the sun?
23:12:02 <kmc> and a gram of LSD
23:12:07 <FunctorSalad> ^^
23:12:40 <Jafet> I could wish for the woman to go away!
23:16:42 <tensorpudding> oh no, now both haskell channels are offtopic
23:56:30 <FunctorSalad> @let longcat = "Σ:o"++repeat '='
23:56:31 <lambdabot>  Defined.
23:56:49 <jrockway> qp_pq: wait, you are here too?
23:56:53 <jrockway> you should know what kinds are then :)
23:57:09 <jrockway> _xor: i experienced the same problem
23:57:22 <qp_pq> jrockway: kinds = ?
23:57:32 <jrockway> your Tree type is of kind * -> *
23:57:37 <qp_pq> jrockway: I'm here asking some simple haskell questions and finding out about the language
23:57:44 <jrockway> but you were implementing the type constraint as though it was of kind *
23:57:47 <jrockway> hence the confusion :)
23:58:18 <qp_pq> jrockway: Axman6 implemented the tree you wrote about some mintues ago for me
23:58:19 <qp_pq> < Axman6> data Tree a b = Node a (Tree a b) (Tree a b) | Leaf b -- qp_pq done
23:58:26 <qp_pq> jrockway: I wanted to prove to him Moose :)
23:58:48 <jrockway> it is not going to be that concise
23:59:34 <qp_pq> jrockway: tell  me about it ... already 70 lines in teh making ...
23:59:40 <jrockway> exactly
23:59:58 <kamatsu> hey, i'm just playing around, but i am getting a kind error i don't understand
