00:00:01 <ski> `each' returns each element in a list, with the intention to finally check that a boolean result is `True' for each of them
00:00:49 <ivanm> :o
00:01:03 <ivanm> how are we meant to work out what new packages are available now? :s
00:01:05 <kmc> why you gotta go turn a perfectly good code inside out like that
00:01:12 <iaefai> Does haskell platform get updated in such a way I can build a new version with possible bug fixes?
00:01:26 <ski> kmc : it's how i be :)
00:01:37 <ivanm> iaefai: not really
00:01:44 <ivanm> once it's out, it's out until the next release
00:02:05 <kmc> you can use cabal-install to upgrade individual packages, or get new ones
00:02:15 <iaefai> ivanm: My documentation is broken in several spots, the latest being 'ghc-mtl' is what is linked and 'mtl' is what it really is in the file system.
00:02:24 <ivanm> iaefai: yeah, ignore that
00:02:37 <iaefai> ivanm: I rather needed to view mtl just now
00:02:38 <ivanm> there's a couple of dodgy bits in the GHC documentation
00:02:44 <ivanm> iaefai: how'd you install it?
00:02:49 <iaefai> pkg file
00:02:51 <ivanm> each separate package will have it's own documentation...
00:03:10 <ivanm> probably /usr/share/doc/packagename-version/html/index.html or something
00:03:35 <iaefai> Everything is in the framework
00:04:19 <ivanm> "framework"?
00:04:24 <ski> (mmorrow : i realized i didn't need `ContT2' and thus not `Identity' either, in this case ..)
00:04:44 <iaefai> lrwxr-xr-x   1 root  wheel    68 12 Oct 17:35 ghc -> /Library/Frameworks/GHC.framework/Versions/Current/usr/share/doc/ghc
00:05:21 <ivanm> wtf is that from? :s
00:05:31 <ivanm> iaefai: well, ghc docs are only ghc docs, not HP docs AFAIK
00:05:34 <ski> presumably MaxOSX ?
00:05:38 <ivanm> unless your pkgs do something funcy
00:05:40 <ivanm> *funky
00:05:42 <ivanm> ski: yeah
00:05:43 <iaefai> $ ls -l /usr/share/doc/
00:06:11 <ivanm> but I have no idea what this whole "framework" thing is :s
00:06:24 <mmorrow> kmc: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.6/doc/html/src/Language-Haskell-Meta-QQ-SKI.html
00:06:50 <iaefai> :t runErrorT
00:06:51 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
00:07:21 <iaefai> so would this mean that runErrorT $ do ...   would make the do block in an ErrorT monad?
00:07:28 <ski> yes
00:07:50 <iaefai> :t runEitherT
00:07:51 <lambdabot> Not in scope: `runEitherT'
00:07:55 <iaefai> ;-(
00:07:59 <p_l> ivanm: kind of a package of libraries etc.
00:08:07 <ski> @type either
00:08:08 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:08:18 <ivanm> p_l: hmmmm
00:08:38 <iaefai> ski, does that mean that either $ do would be similar but with Either monad?
00:08:51 * p_l never really bothered, doesn't plan on having anything to do with Apple products
00:09:01 <ski> iaefai:
00:09:07 <ski>   either foo bar $ do
00:09:09 <ski>     ...
00:09:14 <iaefai> p_l: What do you use?
00:09:49 <iaefai> ski: I can't see much use in that function.
00:10:24 <ski> if you want to handle "errors" directly, that can sometimes be nice
00:11:17 <iaefai> oh wait a sec, I think I missed part of  the definition in there.
00:12:06 <p_l> iaefai: mostly Linux, sometimes Windows. Even VMS gets more attention from me than OSX :P
00:14:06 <iaefai> p_l: most interesting. I use mac for most of the stuff I do. I find the hardware is great, the operating system lets me get things done. Can't really ask for more. I have had limited success on Linux - used it for years, but there were always great annoyances (used gnome primarily - KDE was evil to me). I use windows xp on my netbook, and love the looks of 7. Never used VMS :p
00:15:44 <p_l> iaefai: I truly switched to linux because it was the only system that managed to play my anime collection without stuttering or requiring better hardware (I've been using linux before that, but haven't switched full time)
00:15:55 * p_l was converted by MPlayer xD
00:15:55 <tensorpudding> OSX is a fine OS even if I'll never use it.
00:16:13 <iaefai> p_l, could never stand mplayer, it uses some wierd interface
00:16:43 <elbar> there are frontends for mplayer
00:17:05 <p_l> iaefai: I was raised seeing DOS command line, then OS/2 & Win3.11 before seeing NT4. I wasn't scared of CLI :D
00:17:06 <ivanm> gnome-mplayer, smplayer, kmplayer, etc.
00:17:20 <p_l> gmplayer being the oldest (built-in)
00:18:04 <iaefai> p_l:  does 3.3, 6, then win3.11 (best windows they ever made btw), win95, 98, Me, 2000, XP, Linux, Vista, 7   is a linearized order
00:18:04 <ivanm> p_l: and deprecated
00:18:08 <ivanm> but still the best IMHO
00:18:11 <iaefai> OSX being somewhere after vista
00:18:14 <ivanm> despite being an absolute pain...
00:18:25 <ivanm> iaefai: you missed NT...
00:18:54 <iaefai> ivanm: I assure you, I didn't miss NT. I tried it out sometime after 2000, and it was a piece of garbage compared to 2000.
00:19:09 <p_l> iaefai: because 2000 is NT5.0, duh
00:19:18 <ivanm> iaefai: oh, I thought you were listing all of the versions of Windows...
00:19:23 <iaefai> NT4 rather
00:19:27 <ivanm> (well, major versions anyway as opposed to service packs, etc.)
00:19:33 <iaefai> ivanm: nah, only my major use
00:19:50 <iaefai> Now if NT4 had built-in and decent usb support, it would be useable now!
00:20:09 <p_l> I remember that my father switched to windows only after NT4, before that it was mostly OS/2 + DOS
00:21:09 <p_l> before NT4, windows didn't have much to offer for us :D
00:21:24 <tensorpudding> I remember Windows 3.1.
00:21:46 <iaefai> I don't think any linux DE has gotten the usability as good as win31
00:21:51 <tensorpudding> That was back when Windows was only good for word documents and spreadsheets, and games.
00:21:55 <elbar> i remember window 2.0 ;)
00:22:00 <elbar> *windows
00:23:42 <aavogt> what is this window you discuss?
00:23:55 <tensorpudding> Windows 3.1 was pretty lacking in usability.
00:24:07 <tensorpudding> It had a consistent interface though.
00:24:38 <mr_ank> I miss GE/OS
00:24:49 <iaefai> tensorpudding: It was good for its time, and a bit after.
00:26:01 <tensorpudding> Windows didn't change as much from Windows 95 to Windows XP, than it did from Windows 3.1 to Windows 95
00:26:42 <iaefai> tensorpudding: That statement is so very wrong.
00:26:56 <iaefai> Windows 95 was actually more like win 3.1 in plumbing than winxp was to 95
00:27:28 <tensorpudding> I mean, there is the advance of the NT kernel, and the use of NTFS for a filesystem, and the advent of Internet Explorer
00:27:49 <tensorpudding> But what changes occured to the UI?
00:28:01 <p_l> tensorpudding: the only thing that 9x and NT share is the API + the fact that NT got most of its advanced stuff broken to maintain compatibility :-(
00:28:44 <tensorpudding> Hmm, there was the registry added at some point.
00:28:48 <iaefai> 95
00:28:55 <p_l> as for the UI... corporate clients want consistency
00:28:58 <iaefai> That registry has been a big big mistake :p
00:29:08 <p_l> iaefai: earlier, it was introduced back with NT I think
00:29:51 <p_l> and the usage of registry sounds consistent with NT ancestor :)
00:29:59 <tensorpudding> Windows 95 was like Windows 3.1 underneath, but it hid it better
00:30:23 <iaefai> From an article: "THE REGISTRY WAS FIRST INTRODUCED TOWARDS THE END OF WINDOWS 3.1 AS A WAY TO CENTRAL MANAGE CONFIGURATION CHANGES AND GET AWAY FROM THE ENDLESS .INI FILES THAT PLAGUED THE WINDOWS 3.X ENVIRONMENT."
00:30:37 <Jeb> hello
00:31:10 <iaefai> Now this is an interesting discussion - because the mac always had preference files for its applications as win3.1 had ini files, why did windows 'need' to develop a registry?
00:32:31 <Jeb> I'm trying to use parsec to parse "expression AND expression", any tips for going about this?
00:32:51 <Jeb> I know I need to make two seperate parsers, but not sure how
00:34:05 <iaefai> Jeb, I know very little about parsec, but I have something that works on simple config files if you want to look at that
00:34:16 <Jeb> sure
00:34:37 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11967#a11967
00:34:41 <Jeb> I'm just learning how to use parsec
00:34:45 <iaefai> Note the url at top, where it came from, with some things changed
00:35:23 <Jeb> thanks
00:38:30 <iaefai> @src fromJust
00:38:31 <lambdabot> fromJust Nothing  = undefined
00:38:31 <lambdabot> fromJust (Just x) = x
00:38:51 <iaefai> Jeb: np
00:45:20 <Twey> Why doesn't Eq a => IO a have an Eq instance?  ☹
00:45:38 <copumpkin> are you joking? :P
00:50:58 <Kim^Walkman> Is there a data structure similar to a Map where the order of keys have a significance?
00:51:18 <copumpkin> you mean order of insertion?
00:51:44 <Kim^Walkman> More the order of traversal if one decides to map over it
00:51:58 <copumpkin> Map already requires an Ordering on its keys
00:52:09 <copumpkin> and uses that internally and for traversal
00:52:29 <Kim^Walkman> Maybe I should describe the problem instead :p
00:52:39 <copumpkin> probably a better idea :)
00:53:48 <Kim^Walkman> I've broken down a pre-existing network protocol, and it'd be nice to have an easy way of getting and setting members. For example a packet might have a “name”, “count” and a “PID”
00:54:10 <Kim^Walkman> They don't nessecarily appear in that order; another packet might have the same fields but in another order
00:54:50 <Kim^Walkman> The record syntax is nice, but it's a lot of packets and making a new data constructor for each type would make a lot of duplicate code for the binary encoding instances
00:56:04 <Kim^Walkman> So I'm trying to generalize in some way and write less code ^^
00:56:33 <copumpkin> hm
00:56:39 <earthy> you mean you want to parse the 'name' 'count' and 'PID' in any permutation, generating one and the same data structure each time?
00:57:08 <Kim^Walkman> I'll pastebin some of the existing code I have, just a mo'
01:02:28 <Kim^Walkman> http://pastebin.com/d76b59a77 — it's quite a lot of code and it feels unnecessary and duplicated
01:03:20 <Kim^Walkman> I have a basic set of data types; that all can be composed to form larger structures where each “field” in these structures can be named
01:04:27 <dibblego> Kim^Walkman, return . Short =<< getWord16le is better written fmap Short getWord16le
01:04:43 <Candlejac> http://bit.ly/19dPM7
01:04:49 <Kim^Walkman> dibblego: Thanks :)
01:05:00 <dibblego> Kim^Walkman, all the (put $) is duplicated unnecessarily
01:05:42 <Kim^Walkman> dibblego: I used to have the record syntax expanded but it lowered readability quite a bit
01:06:39 --- mode: ChanServ set +o dibblego
01:06:43 --- kick: Candlejac was kicked by dibblego (dibblego)
01:06:49 --- mode: dibblego set +b *!*n=lol@*.hsd1.ma.comcast.net
01:06:53 --- kick: Candlejac was kicked by dibblego (dibblego)
01:06:57 --- mode: dibblego set -o dibblego
01:07:27 <Kim^Walkman> I guess the real problem is making it managable
01:09:38 <binrapt> http://haskell.pastebin.com/d5db02661 <- why is that last () pattern illegal? I thought Haskell wasn't white space sensitive. If I move the if and the last ) up one line it works just fine :( but I am not satisfied with that syntax honestly
01:10:51 <Twey> Woah
01:10:53 <copumpkin> I don't blame you, you've made it look like an imperative language :P
01:10:58 <Twey> Yeah :þ
01:10:59 <byorgey> binrapt: whoever told you haskell wasn't white space sensitive was lying. =)
01:11:12 <copumpkin> it's optionally not whitespace sensitive, but nobody writes it like that
01:11:19 <binrapt> :((
01:11:38 <Twey> Arrgh, and used tabs
01:11:43 <binrapt> Yay!
01:11:43 <copumpkin> aw don't get discouraged!
01:11:47 <byorgey> binrapt: just follow this simple rule: the first thing after 'do' determines the indentation for that do block
01:11:47 <binrapt> Long live \t
01:11:51 <copumpkin> lol
01:11:58 <byorgey> binrapt: everything else in the do block should be lined up in exactly that column.
01:12:12 <dibblego> element = (listToMaybe .) <$> flip drop
01:12:18 <byorgey> so the 'if' should be exactly under 'putStrLn'
01:12:24 <byorgey> and you don't need parentheses
01:12:31 <byorgey> oh wait
01:12:35 <byorgey> ignore me =)
01:12:40 <binrapt> It failed for me without them
01:12:41 <Twey> :t show
01:12:43 <lambdabot> forall a. (Show a) => a -> String
01:12:46 <Twey> :t maybe
01:12:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:12:51 <byorgey> binrapt: yes, I'm sorry, I was confused
01:12:59 * byorgey shouldn't try to help people while sick
01:14:01 <Kim^Walkman> binrapt: maybe "Error" show result
01:14:20 <binrapt> Twey I looked into that one
01:14:29 <Twey> binrapt: http://haskell.pastebin.com/m4b5f4dc6
01:14:29 <binrapt> But it didn't look useful to me
01:15:08 <copumpkin> I'd use pattern matching in element
01:15:09 <copumpkin> and guards
01:15:15 <dibblego> http://haskell.pastebin.com/m40e9dc34
01:15:18 * copumpkin wants to abolish if
01:15:22 <binrapt> Haha it still says array
01:15:25 <copumpkin> lol
01:15:34 <binrapt> I C++ed you
01:15:39 <Twey> Oops, yeah :þ
01:15:49 <binrapt> Successfully imperialised
01:15:50 <copumpkin> not sure dibblego's solution will be very obvious to you at this point
01:16:04 <Twey> http://haskell.pastebin.com/m16e3c993 — unnecessary brackets away!
01:16:11 <binrapt> I have no idea what <$> does
01:16:18 <binrapt> :t listToMaybe
01:16:19 <lambdabot> forall a. [a] -> Maybe a
01:16:23 * copumpkin is an indicative programmer, not an imperative one. Any subjunctive or conditional programmers around?
01:16:48 <dibblego> http://haskell.pastebin.com/m57f4d4af
01:17:03 <copumpkin> lol
01:17:27 <Twey> dibblego's is the better solution for ‘element’, but probably not so clear for a beginner
01:17:37 <Twey> copumpkin: I'm a hortative programmer!
01:17:41 <copumpkin> :O
01:17:58 <dibblego> http://haskell.pastebin.com/m12d27fc1
01:18:03 <Twey> I just sort of write things as I wish they were :þ
01:18:04 <copumpkin> how about a hortative horticulturalist
01:18:09 <Twey> Heh
01:18:09 <yakov> hello
01:18:21 <Twey> ‘May this cabbage sprout!’
01:18:26 <Twey> yakov: Hullo
01:21:34 <binrapt> @src listToMaybe
01:21:35 <lambdabot> listToMaybe []        =  Nothing
01:21:35 <lambdabot> listToMaybe (a:_)     =  Just a
01:22:31 <binrapt> @src flip
01:22:32 <lambdabot> flip f x y = f y x
01:24:56 <binrapt> copumpkin it's not quite obvious yet
01:25:33 <binrapt> . is the composition operator, right? Sooo there's only partial application of a binary infix operator in that first parenthesis
01:25:58 <binrapt> And he doesn't even bother with passing arguments manually and just returns a ternary function it seems
01:27:23 <Twey> Weeell, yeah… and no
01:27:53 <Twey> . lifts a function to operate on the result of a function
01:28:03 <Twey> Unarily
01:28:12 <binrapt> O_O
01:28:21 <binrapt> @src (.)
01:28:22 <lambdabot> (f . g) x = f (g x)
01:30:06 <binrapt> Oh right, do only makes sense if I was going to perform further operations like that
01:30:11 <binrapt> :t putStrLn
01:30:12 <lambdabot> String -> IO ()
01:30:18 <binrapt> Further IO stuff?
01:31:56 <binrapt> Oh now I get it, the indentation actually has to be greater than the do line
01:32:11 <binrapt> Oh man, this is quite the mess with \t
01:32:38 <ivanm> preflex: seen quicksilver
01:32:38 <preflex>  quicksilver was last seen 2 hours, 28 minutes and 57 seconds ago, saying: <private message>
01:32:45 <binrapt> I don't quite grasp the thought behind this decision but whatever, I'll be satisfied if I ever get anything done in Haskell
01:34:03 <binrapt> I have a dislike for where because I really want to define the things before I use them
01:34:19 <binrapt> And a text I read stated that it can only be used in the top level of a function or something like that
01:34:28 <binrapt> So it doesn't sound like a yummy general solution to me
01:36:04 <Twey> binrapt: You should become used to a more top-down design process
01:36:19 <MoALTz> @src ($)
01:36:20 <lambdabot> f $ x = f x
01:37:06 <binrapt> Twey but then I have to go through the section remembering all the names I invented again :(
01:37:16 <binrapt> That's more like down-top to me
01:37:33 <Twey> If they're not obvious to you, you need better names
01:37:44 <binrapt> Then I would miss one in the scanning process
01:37:47 <binrapt> And compilation would fail
01:37:56 <quicksilver> ivanm: hi
01:38:02 <quicksilver> ivanm: hope you got my comments in time
01:38:09 <ivanm> quicksilver: yeah, going through them now ;-)
01:38:19 <Twey> binrapt: Well, that's what the compiler is for :þ
01:38:20 <quicksilver> ivanm: oh, I thought you needed that for sunday?
01:38:24 <ivanm> the final submission date was put back by a couple of days, which was lucky since I was busy over the weekend :s
01:38:27 <Twey> You'll get used to it
01:38:47 <ivanm> quicksilver: when you say that the correct name for "class function" is "method", do you mean "class method" or just method?
01:38:55 <ivanm> (or are the two synonomous)
01:38:56 <quicksilver> just method.
01:39:09 <quicksilver> in haskell, method only has one meaning, so ti doesn't need qualification.
01:39:13 <ivanm> *nod*
01:39:26 <quicksilver> (contrast java, where a 'class method' is what C++ calls a 'static' method. Damn terminology)
01:39:35 <ivanm> damn, so I have to re-word my summary of what type classes are since I say they're a method of providing ad-hoc polymorphism ;-)
01:39:56 <ivanm> quicksilver: heh... then there's the issue of return....
01:40:01 <quicksilver> that is true, though.
01:40:16 <quicksilver> oh I see, you don't like the double use of the word 'method'
01:40:17 * quicksilver nods
01:40:21 * ivanm read something earlier today that talked about the "if-then-else ambiguity"... then worked out that it was a non-issue in Haskell! \o/
01:40:27 <ivanm> quicksilver: yeah
01:40:40 <ivanm> and "provides a way" sounds tacky
01:40:49 <Twey> ivanm: What's this ambiguity?
01:40:56 <binrapt> @src if
01:40:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:41:08 <binrapt> passwd? Now, now.
01:41:20 <ivanm> Twey: if foo then if bar then foobar else fds else tadrsd
01:41:23 <quicksilver> ivanm: "typeclasses provide a form of adhoc polymorphism" ?
01:41:26 <ivanm> ummm, drop the second else
01:41:30 <fasta> I installed the 6.12 RC, but how do I actually use cabal install with it?
01:41:38 <ivanm> Twey: the ambiguity is: which if does the second else belong to?
01:41:45 <dcoutts> fasta: gotta get it from darcs
01:41:47 <binrapt> Can the if/else construct even be :t'ed or @src'ed?
01:41:50 <Twey> It's always the inner one first
01:41:54 <Twey> In every language I know
01:41:55 <ivanm> quicksilver: think I'm going to go with "means"
01:42:07 <quicksilver> :t \p x y -> if p then x else y
01:42:08 <lambdabot> forall t. Bool -> t -> t -> t
01:42:21 <ivanm> Twey: well, without knowing how different langs work, can you guarantee that that's the only way of parsing it?
01:42:21 <quicksilver> binrapt: it is language syntax, it doesn't have any @src
01:42:22 <fasta> dcoutts: thanks, stable or head?
01:42:29 <binrapt> Ok
01:42:32 <ivanm> the ambiguity is that as written, there's two ways of parsing it
01:43:10 <ivanm> to have "proper" resolution (i.e. make it extremely obvious even to non-programmers), you have to use brackets or indentation or something to indicate where it belongs
01:43:13 <dcoutts> fasta: head (the stable 0.6.x branch will not compile with Cabal-1.8)
01:43:22 <ivanm> or do what haskell does, and state that all if statements require an else ;-)
01:43:54 <ivanm> dcoutts: oh, do you envisage 1.8 coming out before 6.12? otherwise I've stuffed myself up too much by updating my code to use 1.8 before it's even released :s
01:43:55 <Twey> ivanm: Well, it's not *perfectly* clear, but that's the only reasonable way of doing it, and anybody should be able to figure that out
01:44:09 <dcoutts> ivanm: it's semi-released :-)
01:44:09 <ivanm> Twey: agreed
01:44:22 <quicksilver> dcoutts: ack, is that like semi-closed?
01:44:34 <ivanm> dcoutts: as in "it will be released in this form unless a huge bug turns up"?
01:44:36 <quicksilver> dcoutts: has unsafe lazy IO infected our release process?
01:44:56 <dcoutts> quicksilver: hah, it's released with the 6.12 RC tarball, there's no proper release on hackage yet
01:45:06 <sohum> ivanm: that's a shift/reduce conflict in the parser, no?
01:45:18 <binrapt> Man, I always read "runhaskell" as "runahaskell" for some reason
01:45:22 <yakov> hm.. ./darcs-all pull -a stuck on Mac OS X..
01:45:24 <binrapt> I suspect it is because of "learnyouahaskell"
01:45:44 <yakov> dcoutts, is it possible to get HEAD through git? or it's still experimental (whatever it means)
01:45:46 <ivanm> sohum: something like that
01:45:55 <dcoutts> yakov: you mean of ghc?
01:46:09 <sohum> ivanm: I need to be precise, I'm doing an exam on that in two days ;)
01:46:24 <ivanm> sohum: it came up IIRC from someone relating a story about some similar possible ambiguity in a dodgily implemented in-house scripting language they were re-writing to use yacc + co.
01:46:42 <ivanm> sohum: heh, no idea (tbh, I'm guessing what "shift/reduce conflict" means :p )
01:46:43 <yakov> dcolish, yup, ghc.
01:47:01 <ivanm> yakov: yeah, you should be able to use git
01:47:11 <ivanm> IIRC, they're keeping both repos in sync with each other
01:47:55 <dcoutts> well, really it's just keeping the git mirror in sync. The git one is read-only.
01:48:01 <ivanm> quicksilver: so what else can a method be apart from a function/variable?
01:48:49 <sohum> ivanm: if a then if b then c else d < that can be parsed as either if a then (if b then c else d) or if a then (if b then c) else d. that is, in the LALR parser, after it's reached c, a shift of else or a reduction of "if b then c".
01:49:03 <ivanm> yeah
01:49:09 <ivanm> that's what I was getting at
01:49:25 <ivanm> I haven't really done much parsing, and none in a formal sense
01:49:27 <Twey> ivanm: Haskell's solution isn't perfectly clear, either
01:49:42 <ivanm> (the closest I came to it at uni was just tokenising input strings :s)
01:49:47 <ivanm> Twey: in what sense?
01:49:51 <sohum> Twey: how so?
01:49:56 <Twey> if foo then if bar then baz else quux else arthur
01:50:11 <Twey> The right-most ‘else’ could belong to the right-most ‘if’
01:50:18 <ivanm> Twey: it does...
01:50:24 <ivanm> *n't
01:50:27 <Twey> It would be stupid, but it's possible
01:50:34 <ivanm> if foo then (if bar then baz else quux) else arthur
01:50:35 <sohum> no, it couldn't, because that'd leave the final else free
01:50:37 <Twey> Right
01:50:38 <ivanm> Twey: how could it type-check?
01:50:38 <ray> shifting is a common default in shift/reduce conflicts
01:50:44 <Twey> sohum: That *is* the final else
01:50:57 <Twey> ivanm: I thought you were talking about non-programmers?
01:51:08 <ivanm> Twey: heh, fair enough
01:51:19 <sohum> ray: yep, which is why that normally parses to if a then (if b then c else d)
01:51:26 <Twey> ray: *nod*
01:51:48 <sohum> Twey: ah, right. no, it's an unambiguous parse, which is what I mean.
01:52:30 <Twey> Aye
01:55:06 <bastl> Hi all.
01:55:38 <bastl> Can I "pipe" the output of ":info" to some file ? From inside ghci ?
01:55:48 <ivanm> doubt it
01:55:55 <ivanm> sorry :s
01:58:59 <dschoepe> bastl: echo ":info <something>" | ghci > foo.txt should work, but that's not quite from inside ghci
02:00:45 <bastl> dschoepe: works, but I also get all other stuff (Loading package ... etc)
02:01:18 <ivanm> pipe it through tail -1 as well?
02:02:08 <Cale> ghc -e ":info map"
02:02:24 <bastl> Cale: yup. figured out that just now.
02:02:29 <ivanm> heh
02:02:46 <copumpkin> why am I still up?
02:03:08 <ivanm> copumpkin: because you're not down?
02:03:10 <ivanm> duh ;-)
02:03:27 <bastl> not yet down ...
02:05:08 <bastl> I want to learn how to program with multirec. e.g. the data2tree function from SYB. How would that work ?
02:07:25 <binrapt> Is there something like ifThenElse conditional thenTerm elseTerm = if conditional then thenTerm else elseTerm? A ternay version?
02:08:02 <Twey> @let (y ?? n) p = if p then y else n
02:08:03 <lambdabot>  Defined.
02:08:27 <binrapt> *ternary
02:08:34 <Twey> That's defined in Data.Bool.HigherOrder on Hackage
02:08:38 <binrapt> :O
02:08:52 <binrapt> Strange syntax
02:08:59 <binrapt> Somebody who loved ? : much?
02:09:13 <binrapt> Wait
02:09:20 <binrapt> That's not ?:ish
02:09:49 <ray> not at all
02:10:29 <ray> ?: is no different from regular if then else
02:10:30 <lambdabot> Maybe you meant: . ? @ v
02:10:34 <ray> if p then t else f
02:10:39 <ray> p ? t : f
02:10:42 <ray> BORING
02:10:52 <Twey> Also annoying argument order
02:10:58 <ray> we're talking yawnapalooza here
02:11:02 <Twey> Heheh
02:11:34 <dreixel> bastl: doesn't the paper help with programming with multirec?
02:11:53 <ray> yeah you want to be able to partially apply the predicate last
02:12:01 <Twey> Yeah
02:12:08 <ray> switching out the predicate is useful
02:12:57 <bastl> dreixel: i must admit, that I dont understand it fully ... :-/
02:13:34 <copumpkin> ray: up early or late?
02:15:19 <quicksilver> ivanm: I'm not really sure what your question means. methods can be any haskell type which mentions the type of the class somewhere.
02:15:30 <quicksilver> ivanm: all types are either (functions) or (not functions) ;)
02:15:38 <quicksilver> I mean either you are of the form (a -> b) or you are not.
02:15:46 <ManateeLazyCat> I use `Data.ByteString.Lazy.readFile` get file content, then use `Data.ByteString.Lazy.UTF8.toString` to transform it, file size is 42M, but it eat 1.5GB memory in 1 min! Crazy....
02:15:46 <ray> early?
02:15:52 <ray> it's midday
02:16:03 <ivanm> quicksilver: well, I'm including constants as functions to make the terminology easier (rather than saying "function or variable" everywhere)
02:16:08 <ManateeLazyCat> Any idea?
02:16:22 <ivanm> ManateeLazyCat: then you're doing something wrong
02:16:30 <ivanm> i.e. keeping the value around after you need it
02:16:30 <fasta> dcoutts: Setup.exe: ghc version >=6.4 is required but it could not be found.   during ./Setup configure --user, but  ghc --version -> 6.12.0.2009....
02:16:39 <ManateeLazyCat> ivanm: Right way?
02:16:55 <ivanm> ManateeLazyCat: without knowing what or how you're doing it... ;-)
02:17:25 <dcoutts> fasta: if you run with -v3 it'll give more info on that
02:17:51 * hackagebot upload: acme-dont 1.0 - A don't construct (GracjanPolak)
02:17:55 <ManateeLazyCat> ivanm: I use `Data.ByteString.Lazy.readFile` read file as ByteString, then use `Data.ByteString.Lazy.UTF8.toString` to transform ByteString to String.
02:18:08 <ivanm> "how you're doing it" == code ;-)
02:18:18 <ivanm> and I haven't used bytestrings that much anyway...
02:18:20 <fasta> dcooutts: Creating dist (and its parents)
02:18:20 <fasta> searching for ghc in path.
02:18:20 <fasta> Cannot find ghc on the path
02:18:25 <ManateeLazyCat> ivanm: Okay.
02:18:27 <ivanm> ManateeLazyCat: is there a readFile in the UTF8 module you can call?
02:18:39 <fasta> dcoutts: but when I echo $PATH, it is there.
02:19:13 <quicksilver> ivanm: I don't think, in general, that "constant" is really the correct thing to use in apposition to "function" but given the audience of your paper, stick to some simple terminology you're happy with.
02:19:19 <fasta> dcoutts: In cmd.exe it does work, though.
02:19:26 <ivanm> quicksilver: *nod*
02:19:32 <ivanm> quicksilver: constant == :: a
02:19:33 * ManateeLazyCat pasted "Test" at http://paste2.org/get/506670
02:19:37 <ManateeLazyCat> ivanm: Looks above
02:19:45 <ManateeLazyCat> ivanm: In function `textViewLoadFile`.
02:19:48 <dreixel> bastl: well, multirec might not be the easiest GP library to understand
02:20:00 <dreixel> bastl: for starters: do you *need* to use multirec?
02:20:05 <ivanm> what's <<<= ?
02:20:15 <ManateeLazyCat> ivanm: In code i paste.
02:20:16 <ivanm> oh, (.) . fmap
02:20:19 <ManateeLazyCat> ivanm: At below.
02:20:20 <dcoutts> fasta: is this cygwin again?
02:20:26 <ManateeLazyCat> ivanm: ory
02:20:32 <quicksilver> ivanm: what about IO (a -> a), though. Is that a constant? What about StateT a IO (a -> a -> IO (a,a)), is that a constant? You take my point? ;)
02:20:33 <dreixel> bastl: do you need a fixed-point view on families of datatypes? or could you do with a single datatype? or could you do without the fixed-point view?
02:20:33 <byorgey> haha, acme-dont =)
02:20:42 <ivanm> @unpl textViewSetText tv =<< ((.) . fmap) U.toString B.readFile path
02:20:43 <lambdabot> ((fmap U.toString (B.readFile path)) >>= (textViewSetText tv))
02:20:47 <ManateeLazyCat> ivanm: <<<= mix `pure` and `functor` .
02:21:07 <bastl> dreixel: dreixel i want to do GP for real things like java, xml ... It seems the fixed-point thing is the right one since it scales well ..
02:21:11 <ivanm> ManateeLazyCat: IIRC, it's usually a bad idea to get the String out of the ByteString
02:22:05 <fasta> dcoutts: no, I dumped Cygwin. Msys seems to work better.
02:22:17 <ManateeLazyCat> ivanm: I can't understand "get the String out of the ByteString".
02:22:35 <bastl> dreixel: though, a 12-page paper is not good to learn :-)
02:22:41 <dcoutts> fasta: I'm not sure if updating the $PATH in msys updates the windows env var or not
02:22:47 <ManateeLazyCat> ivanm: Or better solution?
02:22:51 <ivanm> ManateeLazyCat: "ByteString -> String" considered harmful ;-)
02:22:55 <fasta> dcoutts: it does the other way around.
02:23:05 <fasta> dcoutts: which is what I was depending on.
02:23:12 <bastl> but OTOH, the renameVar thing from the paper does exactly the kind of thing im looking for...
02:23:35 <ManateeLazyCat> ivanm: I need do decode file content with UTF8.
02:24:01 <ManateeLazyCat> ivanm: Otherwise i can't see UTF8 character (such as Chinese) in TextView widget.
02:24:24 <ivanm> ManateeLazyCat: any particular reason for using ByteString then if you're only reading a file?
02:24:59 <ManateeLazyCat> ivanm: No, just heard others people said ByteString is faster to read file.
02:25:20 <dreixel> bastl: uhm, well, I'd say you need fixed-points if you want to have folds or the zipper
02:25:49 <dreixel> multirec doesn't even scale that well for large families (though using a balanced encoding helps)
02:26:14 <dreixel> but there is not much more written about multirec other than that 12-page paper
02:26:25 <dreixel> there is another 12-page paper on a similar thing, though simpler
02:26:33 <bastl> yeah, i came there initially by asking for a zipper for SYB. then i got pointed to multirec.
02:27:03 <ivanm> ManateeLazyCat: it's faster to do file-based processing on it
02:27:04 <dreixel> uhm, yeah, I don't think SYB is the way to go for zippers.
02:27:10 <ivanm> but _not_ if you're then going to get the STring out of it IIRC
02:27:16 <dreixel> the paper I was mentioning: http://www.cs.uu.nl/wiki/bin/view/Alexey/ALightweightApproachToDatatype-GenericRewriting
02:27:18 <bastl> dreixel: i have tutorials for polyp on my desk. If i got it for easy datatypes. i will transfer to mutal-recursives
02:27:54 <ManateeLazyCat> ivanm: I try to test `System.IO.UTF8.readFile`.
02:27:56 <dreixel> polyp is a bit older. I think this paper is better for understanding multirec too
02:28:19 <bastl> ok, thanks ill have a look at it.
02:28:22 <dreixel> it is using a library which is now called 'regular' (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regular)
02:28:51 <dreixel> and is very similar to multirec, just that it uses the "normal" fixed-point (instead of a higher-order fixed-point) and has no tagging (because it's not necessary)
02:35:11 <cathper> I want to create { n in |N^r : for all i, n_i <= m } for some m. Any hints?
02:38:25 <ManateeLazyCat> ivanm: Crazy thing happened again, i have use `Prelude.readFile` test, get string is fast and memory is normal, but handle those `string`, memory is eating.
02:39:01 <ivanm> ManateeLazyCat: right, it's whatever you're doing with the String that is the issue
02:39:01 <ManateeLazyCat> ivanm: You can test `ss <- readFile "HugeFile" ` in terminal, then type `ss` to show string,
02:39:04 <ivanm> profile!
02:39:19 <ivanm> ManateeLazyCat: the memory problem is that the string is being evaluated and kept in memory rather than garbage collected
02:39:21 <ManateeLazyCat> ivanm: Then you can get that crazy thing.
02:40:00 <netinho> hey guys, just a quick question. would filter et al be better defined with folds?
02:40:36 <ivanm> netinho: it is!
02:40:37 <ManateeLazyCat> ivanm: My file is 42MB, you mean Haskell won't GC those `String` until evaluation end?
02:40:38 <ivanm> @src filter
02:40:39 <lambdabot> filter _ []     = []
02:40:39 <lambdabot> filter p (x:xs)
02:40:39 <lambdabot>     | p x       = x : filter p xs
02:40:39 <lambdabot>     | otherwise = filter p xs
02:40:58 <ivanm> ManateeLazyCat: if you're keeping that STring in memory by having a variable that is still using it, then it won't GC it
02:41:09 <ivanm> netinho: OK, it _can_ be defined with a foldr
02:41:09 <netinho> ivanm: is it? :P
02:41:27 <ivanm> netinho: maybe it isn't for efficiency purposes... >_>
02:41:30 <binrapt> @src read
02:41:31 <lambdabot> read s = either error id (readEither s)
02:41:32 <ManateeLazyCat> ivanm: So Haskell is copy 42MB string manay times?
02:41:34 <netinho> foldl or foldr?
02:41:36 <dibblego> does lambdabot have a function to convert loopy spaghetti code in an imperative language to clean functional code (yet)?
02:41:50 <ivanm> dibblego: doubt it...
02:41:56 <dibblego> netinho, foldr
02:41:56 <netinho> dibblego: spaghetti code is delicious
02:41:56 <ivanm> netinho: foldr keeps the list structure the same
02:42:03 <ivanm> netinho: foldl would reverse it
02:42:05 <ivanm> ManateeLazyCat: no
02:42:06 <binrapt> Loops <3 I love them
02:42:07 <Botje> foldr f where f x xs = if (p x) then x:xs else xs
02:42:20 <ivanm> ManateeLazyCat: you'd have to profile your app to see what it's doing; if you're passing the entire thing a few times maybe that's it
02:42:21 <fasta> Isn't there some bootstrap script for Cabal install based on Cabal 1.8 for Windows?
02:42:36 <netinho> I love Java, and I cannot lie. -_-
02:42:37 <ivanm> fasta: since there's no official release yet, there might not be
02:42:46 <ivanm> fasta: you might be able to hack the current bootstrap script
02:42:47 <MoALTz> i wonder if there is a repository of (working) spaghetti code somewhere...
02:42:49 <dibblego> netinho, filter is written using foldr, but depending on what you mean by "et. al."
02:42:51 <ivanm> quicksilver: still around?
02:42:57 <dcoutts> fasta: the bootstrap.sh did get updated for 1.8
02:43:10 <dcoutts> fasta: I've not tested it on windows, lemme know if it works
02:43:10 <dibblego> ivanm, I was just dreaming aloud, I didn't expect such a function
02:43:13 <ivanm> filter p = foldr (\ x ys -> if p x then x : ys else ys) []
02:43:19 <ivanm> dibblego: heh
02:43:25 <ManateeLazyCat> ivanm: Just show string in terminal will eat memory.
02:43:28 <ivanm> dibblego: well, there's @undo ...
02:43:29 <ivanm> ;-)
02:43:39 <ivanm> ManateeLazyCat: *shrug* profile!
02:43:51 <dibblego> ivanm, I could write it with IORef but it would be fugly
02:44:06 <ManateeLazyCat> ivanm: Okay.
02:44:16 <fasta> dcoutts: it required parsec and network, so, it doesn't completely bootstrap.
02:44:29 <netinho> ivanm: is this version better than the defined one?
02:44:41 <ManateeLazyCat> ivanm: But i think this don't need profile anymore.
02:44:48 <ivanm> netinho: there might be funky optimization stuff going on under the hood, so who knows
02:44:51 <dcoutts> fasta: ah yes, it was based on the assumption of the old ghc + extralibs
02:45:13 <ivanm> dcoutts: did it? IIRC it downloaded the libs of hackage when I did a bootstrap for current cabal-install...
02:45:26 <dcoutts> ivanm: you had network already
02:45:28 <ivanm> oh, wait, that was for ghc on fedora, so it probably had extralibs :s
02:45:28 <netinho> dibblego: filter isn't written with fold, et al, it means other high-order jazz, like map
02:45:56 <dibblego> netinho, I've no idea what you just said, but map is written with foldr as well
02:45:57 <ivanm> netinho: map can be written with foldr as well
02:46:09 <ivanm> netinho: don't forget, lambdabot's @src doesn't always have the code found in GHC...
02:46:20 <ivanm> I would think that folded versions would be easier to fuse though...
02:47:02 <fasta> dcoutts: and the other issue is probably just because MSys does better integration that just Console2 with bash as shell.
02:47:43 <dcoutts> fasta: which other issue?
02:48:04 <fasta> dcoutts: about ghc not being found (like I said earlier).
02:49:43 <dcoutts> fasta: do you know what is going on there?
02:49:57 <netinho> labdabot is probably the best invention ever
02:50:02 <netinho> he's so friendly
02:50:04 <dcoutts> fasta: what does ghci think the actual %PATH% is?
02:50:11 <fasta> dcoutts: I had no time to analyze it.
02:50:31 <ivanm> netinho: lambdabot is female...
02:50:34 <ivanm> ;-)
02:50:37 <fasta> dcoutts: I just want to get the dll working as quickly as possible, time for polishing is later.
02:50:50 <jlouis> @vixen a/s/l
02:50:51 <lambdabot> 19/f/California
02:51:03 <netinho> it's a trap
02:51:05 <netinho> a good one
02:51:18 <gio123> @vixen a/s/l
02:51:19 <lambdabot> 19/f/California
02:51:29 <quicksilver> ivanm: yes
02:51:29 <gio123> @fasta a/s/l
02:51:30 <lambdabot> Maybe you meant: fact paste
02:51:38 <jlouis> Oh, yes she is. And she does better at converting expressions to point free style
02:51:53 <jlouis> than most of us :)
02:51:54 <ivanm> quicksilver: with records, so it's a record function in a data type using record syntax?
02:52:05 <quicksilver> ivanm: selector function
02:52:09 <quicksilver> (or field name)
02:52:09 <gio123> @ivanm a/s/l
02:52:10 <lambdabot> Unknown command, try @list
02:52:20 <ivanm> quicksilver: I meant selector function ;-)
02:52:21 <quicksilver> the fieldname is used as a selector function
02:52:25 <quicksilver> yes.
02:54:04 * ivanm has always called them "record functions" :s
02:54:12 <fasta> On which parsec does network depend?
02:54:27 <fasta> I installed parsec2, but it doesn't find it.
02:56:17 <ivanm> I would think parsec 2...
02:56:27 <ivanm> fasta: "ghc-pkg list parsec" has it?
02:56:34 <rwmjones> I'm not a huge Haskell expert, but I have a quick question.  In this file: http://annexia.org/tmp/Guestfs.hs.txt
02:56:40 <rwmjones> compiling it gives me the following error:
02:56:41 <rwmjones> [1 of 2] Compiling Guestfs          ( Guestfs.hs, Guestfs.o )
02:56:41 <rwmjones> Guestfs.hs:172:2:
02:56:41 <rwmjones>     Ambiguous occurrence `truncate'
02:56:41 <rwmjones>     It could refer to either `Guestfs.truncate', defined at Guestfs.hs:1976:0
02:56:41 <rwmjones>                           or `Prelude.truncate', imported from Prelude
02:56:55 <rwmjones> how can I disambiguate that?
02:57:12 <ivanm> quicksilver: oh, and I treated constructors/selector functions differently to highlight them mainly ;-)
02:57:28 <ivanm> rwmjones: "import Prelude hiding (truncate)"
02:57:36 <ivanm> or call your truncate in Guestfs something else
02:57:48 <ivanm> > truncate 2.3
02:57:49 <lambdabot>   2
02:57:49 <rwmjones> ivanm, thanks .. I'll try "hiding" first
02:58:11 <ivanm> rwmjones: it's generally poor form to override something in the prelude though
02:58:57 <rwmjones> ivanm, doesn't that define a completely separate symbol (Guestfs.truncate)?  Would this cause any problems in programs using the code?
02:59:15 <fasta> ivanm, no.
02:59:27 <fasta> ivanm, I installed parsec, though. It said "registering".
02:59:40 <ivanm> rwmjones: if your module isn't imported qualified, then people reading code that uses it might think it's using the Prelude truncate
02:59:51 <ivanm> fasta: well, if ghc-pkg doesn't know it, it isn't registered ;-)
02:59:59 <ivanm> fasta: did you install it with the same user?
03:00:05 <rwmjones> I guess they'd never accidentally call it ... it has completely different arg types
03:00:11 <fasta> ivanm, I also tried --user
03:00:12 <ivanm> if it was a user install and you're doing that with root, then it won't know about it...
03:00:23 <ivanm> rwmjones: I'm talking about people _reading_ your code
03:00:24 <fasta> ivanm, I didn't change user in the process.
03:00:28 <ivanm> for debug purposes, etc.
03:00:33 <ivanm> fasta: right, then something stuffed up
03:00:38 <rwmjones> if anyone fancies completing the libguestfs haskell bindings, let me know :-)
03:01:33 <binrapt> How would you convert a string to an integer?
03:01:42 <quicksilver> read
03:01:49 <quicksilver> or reads, if you need to handle errors
03:02:02 <hristo> hi everyone
03:02:03 <binrapt> I've only seen this being done in :: ... -> Int functions which use read
03:02:34 <binrapt> Lacks type signature otherwise?
03:02:43 <binrapt> @src reads
03:02:44 <lambdabot> reads = readsPrec minPrec
03:02:49 <quicksilver> I don't understand your question, binrapt.
03:03:05 <binrapt> Well you can't just read "1" in ghci for example
03:03:07 <fasta> I get from runghc Setup.hs install: Registering mtl-1.1.0.2.., but afterwards it's not displayed in ghc-pkg output.
03:03:36 <quicksilver> binrapt: sure, because it don't know what type you mean.
03:03:38 <eevar2> @hoogle [Char] -> Integer
03:03:39 <lambdabot> Prelude error :: [Char] -> a
03:03:39 <lambdabot> Prelude read :: Read a => String -> a
03:03:39 <lambdabot> Text.Read read :: Read a => String -> a
03:03:52 <quicksilver> binrapt: in a real program though there is generally some other information to pin down the type and its fine
03:03:54 <Cale> > read "1" :: Int
03:03:55 <lambdabot>   1
03:03:58 <quicksilver> binrapt: if there isn't, you can always annotate it.
03:04:16 <Cale> > read "1" + read "6"
03:04:17 <lambdabot>   7
03:04:25 <Cale> (numeric defaulting ;)
03:04:26 <binrapt> Ah I wasn't sure how to do that without declaring a new function with =
03:04:44 <Cale> binrapt: yeah, you can annotate any expression with a type
03:04:47 <binrapt> > read "1" + 0
03:04:48 <lambdabot>   1
03:05:00 <Cale> binrapt: Just be careful, because :: scopes over the largest expression it can find
03:05:12 <Cale> So sometimes you have to add parens
03:05:14 <binrapt> ()
03:06:21 <fasta> ivanm, ok, I solved it. It seems that you cannot have two versions of GHC installed somehow.
03:06:30 <ivanm> fasta: heh
03:06:38 <fasta> ivanm, I did verify the version of ghc-pkg in my path.
03:06:48 <fasta> ivanm, so, I am not sure what went wrong.
03:07:08 <fasta> On Linux I have about 6 versions of GHC installed ;)
03:07:14 <ivanm> fasta: it could be that it was using the "old" ghc-pkg still (or the new one for the case of installation)
03:07:17 <ivanm> or something like that
03:07:19 <ivanm> fasta: heh
03:07:24 <ivanm> let's just blame windows :p
03:07:33 <fasta> ivanm, yeah, boohh!
03:08:32 <binrapt> :t reads
03:08:33 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:09:07 <binrapt> I am puzzled, where is the error handling?
03:09:15 <binrapt> I expected String -> Maybe a
03:09:22 <binrapt> Or something along those lines
03:09:25 <Twey> If there are no valid parses, it just returns []
03:09:33 <binrapt> :(
03:09:45 <Twey> If there are multiple valid parses (it's ambiguous) it can return more than one item in the list
03:09:46 <fasta> binrapt, uhm, that's a good design.
03:09:52 <binrapt> What a hack
03:09:57 <fasta> binrapt, a hack?
03:10:00 <Twey> How is it a hack?
03:10:03 <fasta> binrapt, what is wrong with it?
03:10:15 <Twey> You can have zero to many returns — that's what lists are for
03:10:18 <fasta> binrapt, it is perfectly well defined behaviour.
03:10:27 <Kim^Walkman> The nice thing is that you can write your own function using reads that does what you thought reads did, binrapt ;)
03:10:33 <fasta> binrapt, no exceptions, no extra error types or indirections.
03:10:53 <Twey> Sure, readsMaybe = fst <$> listToMaybe
03:10:55 <binrapt> Is there a read function which returns something like a Maybe a?
03:11:05 <fasta> ivanm, it seems that now doing --user doesn't do anything useful.
03:11:07 <Twey> binrapt: But why would you want to?
03:11:23 <binrapt> Well I'd have to check the size on this one with constants all the time :( ugly
03:11:27 <Twey> binrapt: That way you lose other possible parses
03:11:31 <Twey> Eh?  No…
03:11:33 <binrapt> I'd prefer to know a native function which solves my problems
03:11:35 <quicksilver> let maybeRead a = case reads a of [(x,"")] -> Just x; _ -> Nothing.
03:11:36 <ivanm> fasta: :s
03:11:38 <binrapt> Haskell has like tons of those usually
03:11:39 <fasta> ivanm,  that is running ghc-pkg -list -user returns nothing after I run installation as normal user (that is with --user)
03:11:51 <Twey> binrapt: There's nothing wrong with this one
03:11:58 <Twey> binrapt: What does it not do that a Maybe function would?
03:11:59 <Kim^Walkman> Parsing user input, using a default value if unparsable is one use
03:12:06 <fasta> ivanm, so, I think I will just install everything as administrator :/
03:12:28 <ivanm> @src [] (==)
03:12:29 <lambdabot> []     == []     = True
03:12:29 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
03:12:29 <lambdabot> _      == _        = False
03:12:43 <Twey> Lists are less restrictive than Maybe, by definition (Maybe is zero or one, [] is zero, one, or many)
03:13:20 <Twey> Anything you can do with a Maybe, you can do with a list (ignoring all but the first argument where appropriate)
03:13:24 <binrapt> Twey: I don't know how to check this one as quickly for errors (which is if (length returnValue) != 1)
03:13:42 <Twey> binrapt: Pattern-match, the same as you would with a Maybe
03:14:15 <binrapt> Seems clumsy to me :(
03:14:18 <cathper> How to do something like [ [a1..ar] | a1 <- [1..m1], ..., ar <-[1..mr] ] for given r and m = [m1..mr]?
03:14:21 * hackagebot upload: acme-dont 1.1 - A don't construct (GracjanPolak)
03:14:39 <binrapt> Usually you don't want stuff like "1a1" to be considered valid input
03:14:48 <Twey> ‘case readsMaybe str of Just foo -> bar; Nothing -> baz’ becomes ‘case map fst $ reads str of [foo] -> bar; _ = baz’
03:14:59 <Twey> Oh, so you don't want to ignore additional input
03:15:17 <Twey> ‘case readsMaybe str of Just foo -> bar; Nothing -> baz’ becomes ‘case reads str of [(foo, "")] -> bar; _ = baz’, then
03:15:19 <binrapt> I don't want to ignore it, I want that to be an error
03:15:27 <quicksilver> binrapt: you have been shown several one line solutions. stop bitching and use one.
03:15:50 <Cale> that last = in Twey's code should be ->
03:16:08 <Twey> Er, yes
03:16:11 <Twey> Sorry
03:16:16 <Twey> « The Acme.Dont module provides a don't command, which is the opposite of Haskell's built-in do. It is used exactly like the do monadic construct except that, instead of executing the block it controls, it... well... doesn't. »
03:16:17 <Twey> Hahaha
03:16:27 <Twey> GracjanPolak++
03:17:02 <fasta> ivanm, ok, the latest conclusion is that there is a difference between runghc and runhaskell.
03:17:21 <ToRA> That right there is why upvote and downvote arrows on hackage would be a bad idea :p
03:17:28 <Twey> :-D
03:17:35 <ivanm> fasta: there is? :o
03:17:51 <fasta> ivanm, yes, Windows seems to defy all logic.
03:17:56 <ivanm> Twey: someone's been reading too many perl-based reddit submissions, have they? ;-)
03:18:11 <Twey> ivanm: Ay, I think I missed that reference
03:18:14 <ivanm> ToRA: because everyone would upvote that for the novelty rather than use factor?
03:18:24 <ToRA> ivanm: tis what I fear
03:18:28 <ivanm> Twey: someone put up the ACME::Don't package in proggit IIRC
03:18:36 <Twey> Haha, oh
03:18:38 <ivanm> or I read it somewhere today, anyway
03:18:49 <ivanm> what's the type of dont?
03:18:56 <Twey> We should introduce a convention that joke packages go under Acme.*
03:18:56 <ToRA> m a -> m ()
03:19:00 <ivanm> m () ?
03:19:07 <ivanm> Twey: heh
03:19:10 <ToRA> thing is, I actually downloaded it and looked at the source
03:19:13 <ivanm> can't we get our own?
03:19:20 <ivanm> Twey: let's put them under Java.* ! :p
03:19:26 <ivanm> ToRA: and?
03:19:27 <ToRA> and I want to critique it, It's defined as done _action = return ()
03:19:34 <ToRA> *don't _action = return ()
03:19:44 <ToRA> it should be don't _ = return ()
03:19:48 <ivanm> ToRA: const (return ()) ;-)
03:19:53 <ivanm> ToRA: I figured it'd be something like that
03:20:23 <ToRA> also, are we allowed ''s in module names?
03:20:24 <Twey> ToRA: Yeah :<
03:20:26 <Twey> No
03:20:27 <Twey> :-\
03:20:28 <fasta> Network\Socket.hsc:757:3: Not in scope: `readRawBufferPtr
03:20:34 <Twey> They have to be filesystem-friendly
03:20:39 <fasta> That's what I get when I try to build the network package.
03:20:41 <Twey> (blame Windows)
03:20:51 <ToRA> Twey: I do...for everything
03:20:52 <ToRA> :p
03:20:54 <Twey> Heh
03:23:49 <ivanm> quicksilver: with not including a sample diagram... there is a word limit, but the biggest problem is that any "interesting" diagram is too damn big :@
03:27:36 <quicksilver> ivanm: *nod*
03:33:31 <fasta> Does anyone here know which msys package contains autoreconf?
03:34:00 <fasta> Ah, never mind. hash -r, didn't work.
03:34:08 <fasta> It is already there with autoconf :)
03:34:14 <harlekin> How can I pass linker flags to ghc?
03:34:27 <fasta> harlekin, -optl
03:35:00 * cathper realized that sequence . map (\n -> [0..n]) did the job.
03:35:46 <fasta> Kind of interesting how we all make jokes about Perl, yet we stil depend on it ;)
03:35:57 * fasta installs perl
03:36:08 <Peaker> fasta, depend on it for what?
03:36:24 <Peaker> cathper, sequence . map f  = mapM f
03:36:39 <fasta> Peaker: The mangler is still there, the network package depends on autoconf, which depends on perl.
03:36:55 <Peaker> fasta, 2 horrible things :)
03:36:56 <Axman6> fasta: the only perl i've ever depended on was an irssi script
03:37:33 <fasta> Axman6, and you depend on it every single compile ;)
03:37:51 <Axman6> compile of what?
03:38:05 <fasta> @google evil mangler ghc
03:38:07 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
03:38:07 <lambdabot> Title: Commentary/EvilMangler - GHC - Trac
03:38:08 <harlekin> fasta, so it would be ghc -optl --dynamic-linker=/lib64/linker?
03:38:46 <fasta> harlekin, I am still in the process of building my dll. I don't have all the answers. This is some kind of Linux?
03:38:58 <harlekin> fasta, yes.
03:39:17 <Axman6> i haven't compikled ghc for a long time
03:39:54 <fasta> harlekin, if you are just building an application, using Cabal is maybe better.
03:40:17 <harlekin> I am linking xmonad and want to run the binary on a machine where the linker is in a different place.
03:42:11 <Peaker> fasta, Only if you use -fvia-c no?
03:42:33 <fasta> Peake, that's implied, IIRC.
03:43:51 <binrapt> My first day with Haskell: http://haskell.pastebin.com/m226b8284 (this took me like 8 hours to write, I probably would have done better writing ELF 64-bit x86 binaries for Linux in a hex editor)
03:44:09 <Twey> binrapt: Painful
03:44:32 <binrapt> Yeah tell me about it
03:44:41 <binrapt> I am already hating Haskell with a passion now
03:44:53 <Twey> You really need to get rid of those tabs and that weird-ass formatting style of yours :þ  It obscures everything terribly
03:45:18 <medfly> what are you trying to do? :o
03:45:37 <Twey> Just . head = listToMaybe (but not as safe)
03:46:04 <binrapt> medfly I am writing a fast CGI service in Haskell
03:46:11 <binrapt> But I'm not quite there yet, as you can see
03:46:35 <medfly> o.O
03:46:37 * Twey laughs.
03:46:52 <binrapt> Maybe I should just use C++ for web development
03:47:29 <medfly> maybe you shouldn't expect to do super complicated things on your first day with a new language
03:47:39 <medfly> then it wouldn't hurt so much
03:50:33 <harlekin> fasta, can you tell me how I would pass flags to collect2?
03:51:06 <fasta> harlekin, I think that's just the linker, no?
03:51:10 <yakov> what is GUI FRP library of choice at the present?
03:51:16 <harlekin> fasta, I thought the linker was ld.
03:51:22 <fasta> harlekin, That is collect2 does some extra stuff and then calls ld.
03:51:34 <medfly> binrapt, I get the feeling there are so much less painful ways to do what you're doing
03:51:42 <fasta> harlekin, I read the manual on it before the weekend.
03:51:47 <binrapt> medfly of course there are
03:51:54 <medfly> except I'm not sure what it is you're doing
03:52:00 <binrapt> I have already written all of this in PHP for example
03:52:27 <binrapt> But I hate PHP so much that I wanted to replace all of it
03:52:32 <medfly> what's result in line 15?
03:52:51 <medfly> oh, the thing defined later? :o
03:52:56 <binrapt> Yeah
03:53:02 <binrapt> Apparently this is legal in ghc
03:53:09 <binrapt> Is this illegal according to the standard?
03:53:43 <binrapt> I thought Haskellers loved using names before actually defining them
03:53:50 <binrapt> (I hate the where clause already)
03:54:24 <medfly> I'm a bit of a noob too
03:54:39 <koeien37> i didn't look at the source code, but the order of definitions in a haskell file does not matter
03:54:41 <quicksilver> binrapt: is what illegal?
03:54:55 <koeien37> this is a feature
03:55:11 <medfly> it's just I didn't see it first
03:55:13 <binrapt> koeien37 so some may argue!
03:55:18 <Axman6> binrapt: where clauses make code a lot more readable imo
03:55:23 <koeien37> i don't think this is controversial
03:56:10 <Axman6> binrapt: languages that require to declare something before it's used or defined are designed for lazy compiler writers ;)
03:56:15 <binrapt> It requires me to jump down and up in the code all the time to see how things actually work :(
03:56:26 <quicksilver> binrapt: so, don't write it that way then.
03:56:33 <quicksilver> binrapt: it's your choice what order to put things in
03:56:35 <binrapt> quicksilver I do but people give me shit for it
03:56:43 <quicksilver> ignore them, they're idiots.
03:56:44 <Twey> binrapt: http://haskell.pastebin.com/m7018f07e
03:56:54 <binrapt> Oh boy
03:56:55 <quicksilver> there is certainly some virtue on being consistent to yourself
03:57:09 <quicksilver> pick a style which works well and reads well and try to stick to it
03:57:15 <Axman6> binrapt: haskell functions are usually short enough (and well named) so that you can easily remember what they do
03:57:36 <medfly> Twey, it finally looks like Haskell
03:57:49 <binrapt> What's {-# LANGUAGE ViewPatterns #-} good for?
03:57:52 <Twey> Well actually, I think that the end checks are unnecessary
03:57:57 <Twey> listToMaybe does that for you
03:58:05 <koeien37> binrapt: now you can use view patterns :)
03:58:07 <Twey> binrapt: To enable the (foo -> bar) syntax in patterns
03:58:17 <koeien37> f (g -> x) = ...
03:58:23 <Twey> It lets you match an argument to a pattern, *after a function has been applied to it*
03:58:27 <Twey> They're very useful
03:58:39 <binrapt> Comments actually contain instructions for the compiler? :(
03:58:41 <koeien37> yes, especially for some Data.Map-like functions
03:58:45 <Twey> Spares us a case here, for example ☺
03:58:52 <medfly> hi Twey :)
03:58:57 <medfly> ☺
03:58:58 <Twey> Hey medfly
03:58:59 <koeien37> binrapt: things between {-# and #-} are called "pragmas"
03:58:59 <Axman6> what does f (x -> y) mean? o.O
03:59:07 <gio123> > ☺
03:59:08 <lambdabot>   <no location info>: parse error on input `☺'
03:59:11 <binrapt> Oh, so {- is not {-#
03:59:13 <gio123>  ☺
03:59:14 <Twey> Axman6: ‘Apply x to the first argument, then match it against y’
03:59:18 <Twey> binrapt: Right
03:59:25 <Axman6> >_<
03:59:29 <koeien37> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
03:59:34 <gio123>  ☺
03:59:39 <binrapt> > "卍"
03:59:41 <lambdabot>   "\21325"
03:59:53 <Axman6> you buddhist!
03:59:57 <medfly> you buddhist!
04:00:39 <Twey> Yay buddhism
04:00:44 <Axman6> indeed
04:00:54 <Twey> Yay shower *vanishes*
04:03:02 <vegai> > "☯"
04:03:03 <lambdabot>   "\9775"
04:03:48 <binrapt> No, I'm an atheist!
04:03:54 <binrapt> I am deeply insulted
04:04:07 <binrapt> Also I've been up for 21 hours, time to hit the floor
04:04:49 <binrapt> Test.Twey.hs shall be examined further in 9 hours, perhaps
04:08:58 * hackagebot upload: regular-xmlpickler 0.1 - Generic generation of HXT XmlPickler instances using Regular. (ErikHesselink)
04:11:24 <sinelaw> is writing an FFI a big deal?
04:11:53 <Peaker> sinelaw, pretty easy
04:12:00 <Peaker> at least for basic stuff
04:12:04 <luite> as long as you just link with C
04:12:24 <sinelaw> ok i may not need it at all, if haskell already has a USB interface for linux
04:12:46 <sinelaw> seems like it does
04:13:18 <koeien37> yeah i believe that there was an announcement for that on -cafe
04:15:12 <cathper> Peaker: Cool. Thanks.
04:15:32 <fasta> C -> Haskell is easy, the other way around requires some work.
04:16:16 <Axman6> fasta: calling C from Haskell?
04:17:00 <fasta> Axman6, calling C from Haskell is easy.
04:17:10 <Axman6> yes
04:17:30 <Axman6> your C -> Haskell notation was confusing, i would have read that as calling haskell from C
04:17:43 <Axman6> 'binding C to Haskell'
04:18:45 <luite> C++ is a pain though, ghci's linker doesn't seem to support it
04:19:12 <fasta> Basically for any foreign language X, you just write bindings to C and call that.
04:19:55 <luite> fasta: well yes, but then the libraries or object files contain all kinds of C++ sections that ghci refuses to load
04:19:56 <fasta> Or you hack up the compiler and add another FFI backend ;)
04:20:00 <medfly> is it possible to make C code out of Haskell, I wonder?
04:20:21 <luite> medfly: isn't that just what -fvia-C does?
04:20:31 <luite> I hope you don't mean actually readable C code ;)
04:20:46 <fasta> Has anyone been able to compile network on Windows?
04:20:47 <medfly> I just wanted to compare it!
04:20:54 <fasta> That is, network from darcs?
04:21:15 <medfly> thanks
04:21:16 <Peaker> medfly, if you convert it automatically it won't be readable and the comparison silly. makes more sense to compare idiomatic C to idiomatic Haskell
04:21:45 <medfly> :)
04:25:41 <Twey> luite: Contradiction in terms!  :þ
04:26:04 <drhodes> medfly, this is the best guide I've found: http://blog.haskell.cz/pivnik/building-a-shared-library-in-haskell/
04:26:47 <luite> ?faq can haskell generate actually readable C code?
04:26:48 <lambdabot> The answer is: Yes! Haskell can do that.
04:26:56 <medfly> oh... it's not this important, but thanks a lot!
04:27:04 <Axman6> i'm still waiting for a C compiler written in haskell
04:27:56 <pao> @hpaste
04:27:56 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:28:26 <benmachine> haskell *can* do that, it just refuses to out of spite
04:28:37 <pao> hi all, is anything wrong with this implementation of a strict mapM? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4868#a4868
04:30:56 <zygoloid> pao: i think the last line should be 'y `seq` ys `seq` return (y:ys)'
04:31:38 <zygoloid> otherwise in the Identity monad i think it'll always produce (Identity (<thunk>:<thunk>))
04:32:00 <koeien37> zygoloid: y is seq'd in the previous line
04:32:13 <zygoloid> koeien37: right, but >>= isn't necessarily left-strict
04:32:35 <koeien37> hmm
04:32:41 <zygoloid> or at least not in the sense you'd need for that to be enough
04:32:59 <pao> zygoloid: I'm woorking in IO and there everything happens as expected... but I'm trying to see your point
04:34:00 <koeien37> a non-left-strict >>= would be perverse (right?), but maybe it is not strict enough (e.g. Maybe monad matching on Just x, not evaluating the x)? is this your point?
04:34:32 <benmachine> a non-left-strict >>= wouldn't be peverse
04:34:38 <zygoloid> > let mapM' _ [] = return []; mapM' f (x:xs) = do y <- f x; ys <- y `seq` mapM' f xs; return (y:ys) in head $ runIdentity (mapM' (\True -> return True) [True, False])
04:34:38 <lambdabot>   True
04:34:40 <benmachine> > undefined >>= Nothing
04:34:41 <lambdabot>   Couldn't match expected type `a -> m b'
04:34:41 <lambdabot>         against inferred type `Data...
04:34:45 <benmachine> err
04:34:48 <benmachine> > undefined >>= const Nothing
04:34:49 <lambdabot>   * Exception: Prelude.undefined
04:34:49 <koeien37> > undefined >> Nothing -- you mean
04:34:51 <lambdabot>   * Exception: Prelude.undefined
04:34:52 <benmachine> oh
04:34:56 <benmachine> weird
04:35:01 <koeien37> this is not weird
04:35:22 * benmachine goes and looks up Maybe.>>=
04:35:25 <koeien37> the >>= in Maybe must use the left argument, otherwise there is nothing to apply to the function
04:35:28 <pao> koeien37: why >>= has to be left strict?
04:35:39 <zygoloid> > runIdentity (undefined >> return 42)
04:35:40 <lambdabot>   42
04:35:43 <koeien37> pao: i cannot think of a nontrivial counterexample :P
04:36:10 <benmachine> koeien37: yeah I was thinking of something else
04:36:56 <koeien37> zygoloid: are there any other examples?
04:37:18 <zygoloid> > Control.Monad.ST.Lazy.runST (undefined >> return 42)
04:37:19 <lambdabot>   Not in scope: `Control.Monad.ST.Lazy.runST'
04:37:21 <Twey> Just a >>= f = f a; Nothing >>= _ = Nothing
04:37:27 <zygoloid> ^^ that'd be an example, if it were in scope
04:37:33 <koeien37> ok
04:37:36 <zygoloid> and you can't really accuse ST of being a trivial monad :)
04:37:38 <Twey> It has to investigate the LHS to determine which equation to use
04:37:39 <koeien37> no :)
04:37:52 <quicksilver> writer is sort of not left-strict
04:37:53 <koeien37> Twey: yeah, the maybe monad has left-strict >>=
04:37:55 <zygoloid> Control.Monad.State.Lazy too i think
04:37:57 <benmachine> > runState (undefined >> put () >> return 4) undefined
04:37:57 <quicksilver> if you don't examine the log
04:37:58 <lambdabot>   (4,())
04:37:58 <benmachine> tada
04:38:15 <quicksilver> reader is not left-strict
04:38:22 <FuriousJoe> hi, I'm trying to create a module with a list of items, each of which is part of a class, but are not necessarily the same type. I'm doing it with forall, so I was wondering if this is the right way to do it
04:39:05 <zygoloid> pao: if you only care about IO, your one is probably fine; IO's >> is left-strict.
04:39:31 <pao> zygoloid: clear
04:39:40 <quicksilver> well of course, that's not even true.
04:39:49 <quicksilver> it's some kind of execution-strictness you're talking about.
04:40:00 <zygoloid> right, but in a handwaving sense... ;-)
04:40:12 <pao> I'm loosing myself :-)
04:40:12 <quicksilver> > (undefined >> System.IO.putStrLn "hi") `seq` ()
04:40:13 <lambdabot>   Not in scope: `System.IO.putStrLn'
04:40:36 <quicksilver> try it in GHCi
04:40:40 <MoALTz> > putStrLn "test"
04:40:42 <lambdabot>   <IO ()>
04:40:43 <zygoloid> quicksilver: is there a term for strictness-as-percieved-after-executing-a-hypothetical-run-function-for-the-monad ?
04:40:52 <quicksilver> > (undefined >> putStrLn "hi") `seq` ()
04:40:53 <lambdabot>   ()
04:40:57 <quicksilver> MoALTz: thanks
04:40:59 <burp> > fmap fst $ filter (\(_,i) -> even i) $ zip [10,11,12,13,17,100] [1..] -- any better aproch for getting every second element of a list?
04:41:01 <lambdabot>   [11,13,100]
04:41:03 <koeien> FuriousJoe: you mean using an existential type?
04:41:04 <MoALTz> was checking something
04:41:08 <quicksilver> zygoloid: not that I know of.
04:41:35 <pao> zygoloid: the run monad function is usually non strict too :-)
04:42:00 <FuriousJoe> yes... I think so
04:42:02 <quicksilver> I don't think that's true, pao
04:42:19 <koeien> FuriousJoe: this is a way to do this, yes
04:42:20 <quicksilver> runFoo _|_ is always _|_ for interesting monads, isn't it?
04:42:45 <benmachine> I'd've thought it was pretty often _|_ for boring monads
04:43:08 <zygoloid> pao: i think it's fair to say that the run function is usually strict but usually not hyperstrict (is that the right word?)
04:43:19 <FuriousJoe> ok, well I'll go read up on how to do that, atm it compiles without ExistentialQuantification but with RankNTypes, so maybe I've forgotten something. Thanks for the help
04:44:16 <quicksilver> zygoloid: hyperstrict?
04:44:26 <zygoloid> quicksilver: RNF-strict
04:44:34 <koeien> burp: i would probably write something like seconds [] = []; seconds [x] = [x]; seconds (x:y:xs) = x: seconds xs
04:44:54 <zygoloid> quicksilver: isn't Control.Monad.State.Lazy.runState _|_ = (_|_, _|_)?
04:45:00 <burp> koeien: yes, that's probably better
04:45:05 <koeien> but there is probably a better approach using the standard functions
04:45:35 <quicksilver> zygoloid: I think you'll struggle to make the notion of rnf-strict precise.
04:45:38 <koeien> burp: my solution is not correct, you wanted every second element instead. easily adapted
04:45:45 <quicksilver> zygoloid: f is strict IFF f _|_ is _|_
04:46:33 <quicksilver> zygoloid: and, no, runState undefined 0 appears to be undefined, not (undefined...
04:46:40 <burp> > let seconds [] = []; seconds [x] = [x]; seconds (x:y:xs) = y: seconds xs  in [1..10]
04:46:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:46:46 <burp> > let seconds [] = []; seconds [x] = [x]; seconds (x:y:xs) = y: seconds xs  in seconds [1..10]
04:46:48 <lambdabot>   [2,4,6,8,10]
04:46:56 <koeien> burp: now you are lucky
04:47:00 <koeien> burp: try it with [1..11]
04:47:05 <burp> > let seconds [] = []; seconds [x] = [x]; seconds (x:y:xs) = y: seconds xs  in seconds [1..11]
04:47:06 <lambdabot>   [2,4,6,8,10,11]
04:47:06 <Axman6> burp: i think seconds [x] should be []
04:47:13 <ivanm> how would you call the definition of Haskell language found in the report? is "definition" the correct term?
04:47:14 <koeien> Axman6: right
04:47:15 <zygoloid> quicksilver: i didn't invent the notion of hyperstrictness; i read it in a paper a while back (but i may be misrecalling the name). f is hyperstrict iff (rnf x is _|_) => f x is _|_
04:47:16 <burp> oh, yup
04:47:52 <ivanm> Axman6: oh, and I won't be going down to le capitol this week; maybe next week though
04:47:58 <Axman6> zygoloid: sounds like strictness to me
04:48:15 <Axman6> well, i'll be done with exams, so we might be able to meet up then
04:48:27 <quicksilver> Axman6: no, it's stronger
04:48:35 <quicksilver> since rnf x can easily be _|_ even if x is not _|_
04:48:43 <Axman6> :\
04:48:48 <Axman6> how's that work?
04:48:57 <quicksilver> Axman6: well, (_|_,_|_) say
04:49:01 <quicksilver> or [1..]
04:49:09 <Axman6> hmm
04:49:34 <quicksilver> zygoloid: ok but that's not what you have here :) You were suggesting that the result of runState might be (_|_,_|_); that's not strict.
04:49:54 <quicksilver> zygoloid: your proposed notion of hyperstrictness is stronger than strictness not weaker than it
04:50:16 <koeien> that was probably his/her intention?
04:50:35 <zygoloid> quicksilver: right, it's not strict. i was presenting a counterexample to your claim that monad run functions are always strict
04:52:06 <quicksilver> zygoloid: OK. Anyhow it's not true :)
04:52:22 <zygoloid> i think the more interesting claim is that a monadic extraction function :: forall a. m a -> a must be strict (by parametricity)
04:52:44 <zygoloid> quicksilver: right, but with a different State implementation it could be
04:53:42 <zygoloid> "runState' a b = let (c,d) = runState a b in (c,d)" is non-strict
04:54:07 <quicksilver> true enough :)
04:54:22 <ivanm> quicksilver: heh, went to go and add some sample conclusions drawn... but it went over the 4-page limit :s
04:54:32 <ivanm> and I don't want to pay USD$200 to get an extra page :s
04:54:56 * ivanm blames the extra references he had to put in to satisfy the referees
04:55:04 <ivanm> s/referees/reviewers/
05:43:16 <Axman6> win 22
05:50:54 <ivanm> anyone know of a way to work out which paper size a particular pdf is using?
05:51:27 <Axman6> set it to 100%, and then measure the screen
05:51:28 <Axman6> :P
05:51:33 <ivanm> @slap Axman6
05:51:34 <lambdabot> I don't perform such side effects on command!
05:51:51 <Axman6> @vixen you tell 'em girl!
05:51:51 <lambdabot> do i seem  un-feminine to you?
05:52:00 <fasta> ivanm, right click and I can see the size in Gnome, I think.
05:52:08 <ivanm> yeah, evince shows it in properties
05:52:12 <ivanm> xpdf doesn't...
05:52:14 <ToRA> $ pdfinfo foo.pdf
05:52:35 <Axman6> get info in finder
05:52:37 <Axman6> >_>
05:52:42 * fasta acknowledges ToRA's more unixy answer
05:52:57 <ivanm> oohhh, didn't know about pdfinfo
05:53:00 <ivanm> thanks ToRA
05:53:49 <ToRA> :)
05:54:53 <fasta> ivanm, but 4 pages? What kind of craziness is that? I also don't suspect anyone to read printed papers anymore, these days. They download them, and then they might print them.
05:55:25 <ivanm> fasta: it's for a conference proceedings
05:55:38 <ivanm> and because I'm only doing a tool paper, they only let me have 4 pages
05:56:51 <fasta> ivanm, still, nobody is going to read the whole book, so putting everything just on the Internet is a lot easier. Just a waste of paper and space.
05:57:18 <fasta> ivanm, the only reason those things are still there is because the publishers wish to remain relevant.
05:57:27 <ivanm> yeah
05:57:37 <ivanm> but, that's what I'm allowed to have, so *shrug*
05:57:51 <dancor> i look forward to the day that a reflowable format is used in academia
05:58:05 <fasta> dancor, why is that?
05:58:08 <ivanm> "reflowable"?
05:58:20 <dancor> because it is more flexible in a way that i value.
05:58:41 <fasta> It's kind of nice to be able to say that something is on a particular page in an email for example.
05:58:43 <p_l> fasta: it's also for conferences where you might want people to have something in hand during your talk that they can reference (though usually it's powerpoint slides...)
05:59:29 <dancor> i suppose.  but sufficiently divided sections handle that as well.
05:59:39 <fasta> p_l, well, I don't see that as a valid reason.
05:59:51 <fasta> dancor, yes, I suppose.
06:00:06 <Saizan_> i've wanted to scroll text wrt figures several times
06:00:12 <fasta> What I do find terribly annoying is papers that are only available in ps format.
06:00:22 <fasta> So, they have thrown away the search index.
06:00:39 * p_l sometimes manually helped preparing those conference booklets with presentation slides and place for notes... worst was when we received a presentation as a series of JPEGs...
06:01:22 <fasta> Some people even manage to do this with PDFs. Sometimes people are so smart that they didn't sell their sole to the devil and so I told them how they could produce better PDFs with search capability.
06:02:01 <p_l> and sometime people use cmaps to make sure their PDFs are not mechanically readable...
06:03:31 <fasta> Ah, please put a list of people on the web who do that.
06:03:35 <ivanm> dancor: what are you referring to by "reflowable"?
06:03:42 <fasta> Then we can boycot those papers.
06:03:51 <fasta> ivanm, something like HTML
06:03:58 <ivanm> *shudder*
06:04:02 <fasta> ivanm, where you can resize fonts, etc.
06:04:14 <fasta> ivanm, and then the images, "reflow".
06:04:18 <ivanm> I prefer pdf for actual papers; especially because they're easier to print
06:04:35 <fasta> ivanm, it doesn't have to he HTML of course. I suppose TeXMacs format would also qualify.
06:04:53 <fasta> ivanm, that's a mere technical distinction.
06:04:56 <ivanm> except that TeXMacs fails as an app ;-)
06:05:18 <fasta> ivanm, well, it's not perfect.
06:05:31 <ivanm> (mainly due to their widgets :p )
06:08:06 <fasta> Where is writeRawBufferPtr in 6.12.1?
06:08:24 <ivanm> fasta: well, you need 6.12.1 first... ;-)
06:08:42 <fasta> ivanm, ok, well 6.12.2009* then.
06:08:46 <fasta> ivanm, I have that one.
06:08:56 <ivanm> since I haven't managed to build+install it yet, I don't know ;-)
06:09:33 <ivanm> quicksilver: you still around?
06:15:36 <Sadache> can anyone suggest an improvement to the following code http://snipt.org/pro ? It is an implementation of splitAt in f# that uses some Haskell idioms and higher order functions. I am sure there is room for improvement.
06:16:25 <fasta> It used to be in GHC.Handle.
06:16:32 <Twey> Sadache: That doesn't look like Haskell to me
06:16:57 <fasta> Twey, that's why it says F# in the title.
06:17:11 <fasta> Sadache, rewriting it in Haskell will make it better ;)
06:17:25 <Sadache> it is not haskell, but it uses lifts and ap. And I thought you guys rock at higher order programming
06:17:47 <Twey> We don't rock at F#, on the whole
06:17:56 <Twey> #fsharp do, though
06:18:14 <Sadache> isn't there a way for removing some of the lifts using functions like ap or other hof?
06:18:42 <saml> @type ap
06:18:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:18:49 <saml> @type lift
06:18:50 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
06:19:22 <saml> those two look different
06:19:41 <saml> wait... what if... maybe it's possible
06:20:03 <Sadache> you can imagine it in haskell, i'll do the translation and the necessary functions implementations
06:20:33 <saml> when (a -> b) is lifting...
06:20:41 <PeakerWork> Sadache: you only need "lift" for Monads. In Applicative you can use (liftAn . liftAn) for example to compose multiple Applicatives
06:20:52 <PeakerWork> Sadache: (Monads don't compose naturally)
06:20:57 <Sadache> I am just guessing that there is a function that i am not aware of that could improve my code
06:21:21 <PeakerWork> Sadache: Look at the type:
06:21:22 <ivanm> the magic dwim function? :p
06:21:23 <PeakerWork> @type (liftA2 . liftA2) (+)
06:21:25 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *). (Applicative f, Applicative f1, Num b) => f (f1 b) -> f (f1 b) -> f (f1 b)
06:21:39 <PeakerWork> Sadache: no lifting necessary here (no transformers either)
06:22:48 <Sadache> PeakerWork: yes, I used lift2 >> lift2 which is the equivelant of liftA2 . liftA2 in haskell
06:23:23 <PeakerWork> Sadache: (>>) is composition of functions in F#?
06:23:31 <Sadache> PeakerWork: yes
06:26:37 <jmcarthur_work> ew
06:27:32 <GNU\colossus> I got a list of lists representing the adjacency matrix of a given directed, unweighted graph. now I need to implement a function that lists all nodes in that graph that are "reachable" (by following the graph's edges) from a given starting node. I'd highly appreciate a small hint on how to tackle that problem, as (I at least hope so!) seem to think too complicated once again…
06:27:33 <quicksilver> ivanm: and and off as always :)
06:27:38 * hackagebot upload: monadloc 0.4 - A class for monads which can keep a monadic call trace (PepeIborra)
06:28:11 <ivanm> quicksilver: heh, ended up emailing you anyway ;-)
06:28:30 <quicksilver> ivanm: got it. Won't be able to have a serious look until I leave work (3-4 hours)
06:28:39 * hackagebot upload: control-monad-failure 0.2 - A class for monads which can fail with an error. (PepeIborra)
06:28:42 <ivanm> that's OK
06:29:00 <ivanm> anytime within the next 20 hours or so would be great!
06:30:04 <saml> GNU\colossus, what's the type of the list?
06:30:15 <saml> [[1,2], [2,3], ...]  ?
06:30:27 <zygoloid> GNU\colossus: if v is a vector where v_i is 1 iff node i is in your starting step, and A is your adjacency matrix, then Av is nonzero for nodes which are one step from v, and A^n v is nonzero for nodes which are n steps from v.
06:30:28 <GNU\colossus> saml: it's [[Int]], with only zeroes and ones in there
06:30:30 * ivanm should get some sleep...
06:30:32 <saml> do you have to represent it that way?
06:30:33 <fasta> Which symbols does GHC define to define the GHC version which I can use in cpp?
06:30:46 <GNU\colossus> saml: yes, that's a requirement
06:30:48 <saml> oh i see. adjacensy matris
06:30:57 <GNU\colossus> exactly.
06:31:05 <ivanm> GNU\colossus: if it's only 1s and 0s, why not a Bool?
06:31:16 <saml> data Graph a = Object a | Edge (Graph a) (Graph a)
06:31:17 <GNU\colossus> ivanm: it says [[Int]] in the assignment.
06:31:21 <saml> parse that list to that
06:31:22 <Jeb> does anyone know any good tutorials on parsec?
06:31:34 <ivanm> GNU\colossus: fair enough
06:31:42 <ivanm> Jeb: RWH has one IIRC
06:31:49 <Jeb> I'm trying to impliment something like       Expression AND Expression, and keep getting stack overflow
06:31:52 <ehamberg> Jeb: http://book.realworldhaskell.org/read/using-parsec.html
06:31:53 <Jeb> RWH?
06:32:00 <Jeb> thanks
06:32:05 <ehamberg> np:)
06:32:09 <GNU\colossus> saml: I'll give that some thought, thanks!
06:32:25 <ivanm> @where rwh
06:32:25 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:32:27 <zygoloid> GNU\colossus: "(A+I)^n v" is nonzero on the nodes which are reachable in n steps from v; when n = dim (A+I) that's all such nodes
06:32:32 <saml> no you asked about that parsing the list part.
06:33:26 <saml> i think you should enumerate the list and get row,column number
06:33:33 <saml> > enumerate [1,2,3]
06:33:35 <lambdabot>   Not in scope: `enumerate'
06:34:09 <sinelaw> > repeat (repeat repeat) $ "repeat"
06:34:10 <lambdabot>   Couldn't match expected type `a -> b'
06:34:10 <lambdabot>         against inferred type `[[a1 -...
06:34:12 <saml> @hoogle [a] -> [(Int,a)]
06:34:12 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
06:34:13 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
06:34:13 <lambdabot> Data.Graph.Inductive.NodeMap mkNodes_ :: Ord a => NodeMap a -> [a] -> [LNode a]
06:34:56 * hackagebot upload: safe-failure 0.2 - Partial functions from the prelude with a MonadFailure interface (PepeIborra)
06:36:03 <saml> how would you do [[1,2,3], [4,5,6]] ==> [(0, [(0, 1), (1, 2), (2, 3)]), (1, (0,4), (1,5), (2,6))] ?
06:36:15 <saml> oh i can zip
06:36:39 <saml> > zip [[0,1], [1,0]] [0,1..]
06:36:41 <lambdabot>   [([0,1],0),([1,0],1)]
06:37:16 <zygoloid> > let f = zip [0..] in f . fmap f $ [[1,2,3], [4,5,6]]
06:37:17 <lambdabot>   [(0,[(0,1),(1,2),(2,3)]),(1,[(0,4),(1,5),(2,6)])]
06:37:36 <poucet> Who's coming to zurihac?
06:38:14 <saml> > let mat = [[0,1], [1,0]]; enum = [0,1..] in zip enum $ map (\row -> zip enum row) mat
06:38:15 <lambdabot>   [(0,[(0,0),(1,1)]),(1,[(0,1),(1,0)])]
06:38:19 <saml> success!
06:38:44 <saml> zygoloid, you are so skilled
06:38:46 <Polarina> How do I pattern match (x:xs) so that xs contains only the last element in the list and x the rest?
06:39:05 <poucet> Polarina: you can't, lists are only deconstructivble on head.
06:39:09 <saml> f (x:xs) | length xs == 1
06:39:10 <Polarina> :(
06:39:21 <poucet> saml: she does not mean that, she wants 'x' to be a list
06:39:24 <poucet> Polarina: what about
06:39:31 <poucet> case reverse l of
06:39:44 <poucet>   (t:ts) -> let x = reverse ts
06:39:50 <poucet> in ..
06:39:55 <zygoloid> Polarina: you can use 'f ys = ... where x = init ys; xs = tail ys', or 'f (reverse -> (x:xs)) = ...' if you're OK with view patterns
06:40:05 <zygoloid> hmm
06:40:08 <Polarina> Ok.
06:40:09 <poucet> zygoloid: is that new?
06:40:20 <zygoloid> 'f (reverse -> (x:reverse -> xs)) = ...'
06:40:29 <zygoloid> poucet: yeah. -XViewPatterns
06:40:35 <poucet> spiffy
06:41:23 <zygoloid> , let f (reverse -> (x:reverse -> xs)) = (x, xs) in f "hello"
06:41:25 <lunabot>  luna: Couldn't match expected type `[Luna.SimpleReflect.Expr]'
06:41:28 <camio> All these extensions seem great until Oleg writes a paper on it where he shows how to do it in Haskell 98, yet again.
06:41:42 <zygoloid> , let f (reverse -> (x:(reverse -> xs))) = (x, xs) in f "hello"
06:41:44 <lunabot>  ('o',"hell")
06:41:54 <poucet> zygoloid: 6.10 or 6.12 is the first?
06:42:01 <zygoloid> 6.10 i think
06:42:13 <ToRA> > (last &&& init) "hello"
06:42:14 <lambdabot>   ('o',"hell")
06:42:23 <quicksilver> camio: most of oleg's papers involve overlapping, incoherent or undecidable instances, which are distinctly not haskell 98 ;)
06:42:28 <quicksilver> camio: occasionaly, though, yes.
06:42:49 <camio> quicksilver: I just finished reading the tagless interpreter paper. Facinating H98 stuff.
06:43:09 <camio> quicksilver: Pretty much pulling the carpet out of GADTs.
06:43:21 <poucet> zygoloid: it's interesting it complains about overlapping patterns
06:43:24 <zygoloid> poucet: though in 6.10 it seems somewhat unpolished. 'let f (reverse -> xs) = ...' gives a 'Pattern match(es) are overlapped' warning!
06:43:31 <zygoloid> poucet: hehe :)
06:43:55 <poucet> coming to zurihac?
06:44:10 <jmcarthur_work> oleg seems to make a point of sticking with haskell 98 whenever at all possible
06:45:31 <zygoloid> jmcarthur_work: in much the same way that a magician performs tricks blindfolded, handcuffed, straitjacketed and upside-down in a locked tank of water whenever possible :)
06:46:27 <jmcarthur_work> zygoloid, exactly! :)
06:47:13 <poucet> I think it is an interesting exercise, because while his solutions are usually very verbose, it does imply that a lot can be done with syntactic sugar.
06:47:56 <camio> The tagless paper isn't characterized by that. It looks more like he's pointing out the obvious thing that everyone missed.
06:48:00 * poucet wonders who owns the haskellwiki since he wants to change his username.
06:48:22 <jmcarthur_work> i think a lot of what he does implies that a lot of haskell extensions are themselves a strange form of "sugar"
06:48:34 <poucet> shapr: ping
06:48:59 <camio> jmcarthur_work, agreed
06:50:10 <camio> I like how it opens up the question of what exactly are we getting by bloating the language with x feature. Is it really worth the loss of simplicity?
06:51:41 <jmcarthur_work> i like that the question is brought up, but i think my answer is usually "yes" anyway
06:51:56 <jmcarthur_work> for most of the common extensions we currently have, i mean
06:52:14 * burp agrees
06:52:47 <camio> I like some, dislike others. Implicit parameters, for example, definite -1 in my book.
06:53:04 <camio> Type families +1, fun deps -1.
06:53:27 <quicksilver> camio: Yes. Important questions absolutely.
06:54:04 <jmcarthur_work> i prefer type fams, but fun deps have some distinct advantages over type fams
06:54:18 <jmcarthur_work> mostly syntactic, i suppose
06:54:33 <jmcarthur_work> i might not feel the same if we had type fams before we had fun deps
06:54:38 <camio> It reminds me of congress, it is a lot easier to add something than it is to take it away. That is an unsustainable system.
06:54:43 <jmcarthur_work> or if type fams was more mature
06:55:02 <fasta> Haskell98 feels like a whole. Haskell98 + random bunch of extensions, not really.
06:55:08 <camio> Results in things like C++.
06:56:14 <jmcarthur_work> yeah, the complexity of the language as a function of features is probably something like n^2
06:56:24 <quicksilver> that seems intuitively correct
06:56:27 <poucet> I think that haskell98 + ${random()} is mostly a playing ground to find the next haskellXX, and hopefully then it will be minmized to its core
06:56:32 <quicksilver> since in general they all interact.
06:57:01 <poucet> type families, fundeps, all experiments in finding the right system that subsumes them all (just like the ring)
06:58:46 <camio> I wonder if haskell' will remove n+k pattern matching. That'll sort of indicate which direction it's headed.
06:59:28 <fasta> I doubt it. What will removing it buy us?
06:59:48 <poucet> n+k patterns are a horrible hack
07:00:00 <fasta> The code is already there, and it is not like it will break anything.
07:00:15 <fasta> Yes, but those are mostly theoretical concerns.
07:00:48 <Saizan_> n+k patterns are quite tame, oleg couldn't find anything weird to do with them :)
07:01:08 <fasta> If you want a really clean system, you build it out of gates from the ground up.
07:01:22 <fasta> Then you have no "dependency issues" either.
07:01:39 <camio> Well, if it continues in this direction where we leave in stuff that we think sucks, we won't be using haskell in the next 15 years, we'll be using something new and clean.
07:01:52 <camio> Which may be better, I don't know.
07:01:54 <Saizan> camio: what's the problem with that?
07:02:52 <camio> Saizan: I'm not sure. Good question.
07:03:25 <koeien37> and then we can really avoid success at all costs :)
07:04:09 <camio> Haskell' announcement: We've decided to leave in all the cruft to ensure future failure.
07:06:15 <jystic> camio: I'm not sure that will work, look at C++
07:06:18 <jystic> :)
07:06:53 <camio> jystic: good point, but I sense c++'s days are numbered. C# seems to be overshadowing ATM.
07:07:01 <quicksilver> camio: n+k is certainly being considered for removal.
07:08:03 <camio> quicksilver: Yeah, I knew it was being considered. The final decision will be telling. I certainly hope it gets removed, mostly because I like programming in small clean languages.
07:08:24 <camio> s//that are actively maintained.
07:08:28 <koeien37> i wouldn't call haskell "small"
07:08:33 <camio> s//by someone other than me.
07:10:10 <eevar2> camio: yay for cruft
07:35:23 <profmakx> @users
07:35:23 <lambdabot> Unknown command, try @list
07:38:35 <RayNbow> profmakx: the seen plugin is disabled
07:38:41 <Polarina> How do I factorize a number using trail division?
07:39:20 <benmachine> there are a few ways
07:39:24 <benmachine> of varying efficiency
07:39:51 <RayNbow> also, do you want all factors or only the prime factors?
07:39:56 <Polarina> Preferably the simple way.
07:40:01 <benmachine> the obvious one is factors n = filter (\x -> n `mod` x == 0) [1 .. n]
07:40:02 <Polarina> All factor.
07:40:07 <benmachine> but that is very slow on large inputs
07:40:13 <benmachine> well, slow anyway
07:40:25 <benmachine> it's faster if you do prime factors, and then assemble the list of factors from that afterwards
07:40:36 <benmachine> which you can do with maths
07:41:50 <RayNbow> benmachine: hmm, I tried that once... but I can't remember whether the resulting code was elegant
07:42:08 <benmachine> RayNbow: matter of opinion, I suppose
07:42:09 <poucet> @tell shapr How would I change my username on haskellwiki?
07:42:10 <lambdabot> Consider it noted.
07:42:24 <benmachine> but I think the way I have it is pretty simple
07:42:25 <RayNbow> benmachine: lemme see if I can find the old code snippet :p
07:42:28 <Polarina> benmachine: Your function doesn't quite work.
07:42:42 <FunctorSalad> how about the "open pipe to gp-pari" algorithm? ;)
07:42:45 <benmachine> Polarina: how does it break?
07:42:46 <Polarina> benmachine: factors 8 gives [1,2,4,8].
07:42:53 <benmachine> that isn't right?
07:42:58 <Polarina> No, it's not. :P
07:43:00 <FunctorSalad> (AIUI efficient factoring is hard)
07:43:04 <Polarina> Supposed to be [2, 2, 2]
07:43:17 <benmachine> we have a different idea of what factors are, then
07:43:29 <Polarina> prime factors then.
07:43:39 <RayNbow> Polarina: oh, those are easy to find
07:43:41 <benmachine> well then when someone asked if you wanted prime factors or all factors
07:43:45 <benmachine> and you said all factors... :P
07:43:49 <Polarina> :P
07:43:55 <FunctorSalad> RayNbow: nope
07:43:57 <benmachine> prime factors are fun
07:44:18 <RayNbow> FunctorSalad: ok ok... depending on the definition of easy :p
07:44:19 <benmachine> there are a few ways of doing that as well, some of which involve calculating a list of primes and some don't
07:44:31 <Polarina> trail division.
07:44:47 <benmachine> whether you want to calculate a list of primes probably depends on the size of the input/number of times you use the function
07:45:02 <benmachine> trial division works fine
07:45:19 <FunctorSalad> there are probably very sophisticated algorithms, considering RSA depends on it being impossible :p
07:45:34 <FunctorSalad> (to do efficiently)
07:45:38 <benmachine> FunctorSalad: RSA depends on it taking ages for very large things
07:45:52 <oteren> the whole idea is that making primes is very easy
07:46:02 <oteren> and that it takes long time to factor them
07:46:18 <benmachine> it doesn't take a long time to factor primes :P
07:46:24 <benmachine> er, if you know they're prime
07:46:24 <oteren> hehe
07:46:26 <FunctorSalad> oteren: sure, we were talking about factoring
07:46:32 <FunctorSalad> ^^
07:46:32 <benmachine> it takes a long time to factor products of large primes
07:46:39 <oteren> i was extrapolating the RSA statement FunctorSalad
07:46:43 <oteren> sorry, forgot to say that p
07:46:44 <oteren> :å
07:46:46 <oteren> oops
07:46:48 <oteren> " :P "
07:46:53 <benmachine> right okay
07:47:07 <red-agent> Does haskell has literals for maps (also called hashes, hastables, dictionaries)? Data.Map seems like the only thing there is and it does not seem to have a literal, does it?
07:47:17 <benmachine> no literals
07:47:22 <red-agent> *have
07:47:26 <benmachine> well it depends what you need for a literal
07:47:31 <red-agent> So, fromList is the only way?
07:47:32 <benmachine> does fromList [(...)]
07:47:36 <benmachine> count as a literal
07:47:44 <red-agent> I see. thanks.
07:47:50 <FunctorSalad> I'm just thinking that if the best known complexity bound is something like exp(n^(1/3) * blah)  or whatever it was, then the algorithms must be sophisticated
07:47:55 <ToRA> > let (-->) = (,) in Data.Map.fromList [ 1 --> True, 2 --> False ]
07:47:57 <lambdabot>   Not in scope: `Data.Map.fromList'
07:48:00 <ToRA> grr
07:48:01 <FunctorSalad> :)
07:48:10 <benmachine> :t M.fromList
07:48:12 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
07:48:20 <ToRA> > let (-->) = (,) in M.fromList [ 1 --> True, 2 --> False ]
07:48:21 <lambdabot>   fromList [(1,True),(2,False)]
07:48:23 <ToRA> :)
07:48:27 <benmachine> very good
07:48:56 <FunctorSalad> (n being the number of digits of the number, not the number to be factored)
07:50:13 <RayNbow> > let f n = g n 2 where {g 1 _ = []; g n d = let (n',r) = divMod n d in case r of {0 -> d : g n' d; _ -> g n (d+1)}}    in    f 8
07:50:14 <lambdabot>   [2,2,2]
07:54:41 <zygoloid> > let f n = g n 2; g 1 _ = []; g a b | (c,0) <- a`divMod`b = b:g c b | otherwise = g a (b + 2 - fromEnum (even b)) in f 8
07:54:42 <lambdabot>   [2,2,2]
07:55:42 <RayNbow> pattern guards? :)
07:56:28 <jystic> I have some code with a space leak but I'm not sure where to apply strictness to fix it, anyone able to help? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11982#a11982
07:56:36 <FunctorSalad> aaahhh letter salad
07:56:45 <zygoloid> RayNbow: plus an evil use of fromEnum :)
07:57:07 <RayNbow> I once did something like that in Python... converting a boolean to a int :p
07:57:24 <FunctorSalad> instance Enum Foo where fromEnum = unsafePerformIO randomsIO ?
07:57:38 <benmachine> I did 2 + (x > 9) in C once
07:58:02 <FunctorSalad> @type fromEnum
07:58:03 <lambdabot> forall a. (Enum a) => a -> Int
07:58:04 <benmachine> but then that *is* C so doesn't really count
07:58:11 <MoALTz> that's fine in C
07:58:31 <zygoloid> > let f n=n!2;1!_=[];a!b|(c,0)<-a`divMod`b=b:c!b;a!b=a!(b+1) in f 2813
07:58:32 <lambdabot>   [29,97]
07:58:33 <FunctorSalad> but evil (as a language feature)
07:58:52 <FunctorSalad> it mandates Superstitious Use Of Parentheses, for one thing
07:58:55 <zygoloid> > iterate (\b -> b + 2 - fromEnum (enum b)) 2
07:58:56 <lambdabot>   Not in scope: `enum'
07:58:59 <zygoloid> > iterate (\b -> b + 2 - fromEnum (even b)) 2
07:59:00 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:59:05 <zygoloid> :)
07:59:08 <benmachine> it's fine in syntax/behaviour terms but if you do it in an actual program anyone else working on the project glares at you
07:59:19 * RayNbow wonders what 2 + (x > 9) evaluate to in VB6...
07:59:29 <RayNbow> ah, as I expected... :)
07:59:50 <RayNbow> (True = -1 in VB6 :p)
07:59:57 <benmachine> :eek:
08:00:08 <Polarina> How do I do flooring division on Integer?
08:00:10 <quicksilver> jystic: if you never read from the lists in 'values', you're just building up big thunks there.
08:00:14 <benmachine> :t div
08:00:14 <quicksilver> jystic: that could be a space leak
08:00:15 <lambdabot> forall a. (Integral a) => a -> a -> a
08:00:20 <FunctorSalad> well True=-1 is safer against cosmic rays isn't it?
08:00:22 <benmachine> > div 9 4
08:00:23 <FunctorSalad> ;)
08:00:24 <lambdabot>   2
08:00:32 <quicksilver> jystic: having sadi that, how have you observed the space leak?
08:00:44 <FunctorSalad> assuming you store the bool in a whole word for whatever reason
08:01:27 <RayNbow> ints in VB6 were 16 bit iirc
08:01:32 <Polarina> Thanks.
08:01:47 <zygoloid> RayNbow: from a hypothetical 'guess my number' game: ((x<k)+2*(x>k))["=<>"]
08:02:00 <red-agent> Is there an analogue for Python's join? Like ','.join((1, 2, 3)) will produce '1,2,3'? I've googled some join in Monad, but that does not seem to support specifing a separator? Sorry for the noob-ish questions..
08:02:13 <zygoloid> *evil grin*
08:02:19 <quicksilver> red-agent: concat + intersperse, or intercalate
08:02:26 <zygoloid> > intercalate "," ["1", "2", "3"]
08:02:27 <lambdabot>   "1,2,3"
08:02:34 <yakov> hm.. why there's no gconf on Windows while libgconf.dll does exist :-/
08:02:38 <red-agent> Thanks, that's it.
08:03:20 <yakov> also no support for GIO.. which blocks me from using Grapefruit and networking in same application
08:03:28 <RayNbow> zygoloid: hmm... is that C?
08:04:24 <zygoloid> > let join = (. map show) . intercalate in ","`join`([1,2,3])
08:04:24 <benmachine> ahaha
08:04:25 <lambdabot>   "1,2,3"
08:04:31 <zygoloid> RayNbow: sadly, yes. :)
08:04:44 <benmachine> (in C, a[b] = *(a + b) = *(b + a) = b[a])
08:04:51 <benmachine> (bizarrely)
08:04:59 * RayNbow just figured it out
08:06:16 <benmachine> ((x<k)|(x>k)<<1)["=<>"] // nastier or nicer?
08:07:12 <int-e> using the commutativity of a[b] is nasty.
08:07:17 <zygoloid> it's more <><<<>ier
08:07:29 <zygoloid> int-e: it's nastier for 2-d arrays ;-)
08:07:38 * benmachine cringes
08:10:05 <dcolish> whats the usual time for new cabal passwords to be issued?
08:17:24 <iaefai> Can anyone tell me where the Either monad is defined? I know it is somewhere in mtl, but I am not sure where.
08:17:47 <camio> Data.Either?
08:18:39 <iaefai> A guy on the mailing list said "In fact the Either Monad instance is defined in the 'transformers' (or 'mtl') packages"
08:18:49 <ToRA> Control.Monad.Error
08:19:29 * int-e doesn't like that instance.
08:19:33 <ToRA> oh, no maybe not
08:19:56 <iaefai> the person goes on to say, "However for this reason among others you may want to use the 'attempt'[1] package instead of Either."
08:19:58 * ToRA wakes up
08:20:02 <ToRA> yes it is
08:20:13 <ToRA> (given a monad instance in CME)
08:28:17 <jystic> how can I write "increment xs = map (+ 1) xs" in such a way that it doesn't cause a space leak if applied to itself over and over again?
08:30:09 <int-e> I think you can't. increment (increment (.... (increment xs) ...)) will always cause a space leak, no matter how increment is defined.
08:30:43 * hackagebot upload: Lucu 0.4 - HTTP Daemonic Library (MasatakeDaimon)
08:30:52 <doublethink_work> providing that increment is marked to be INLINEd, the calls to map would probably be rewritten, e.g. 'increment . increment . increment $ xs' == 'map (+1) . map (+1) . map (+1) $ xs' == 'map ((+1) . (+1) . (+1)) xs'
08:30:59 <MoALTz> maybe as a datatype?
08:31:01 <doublethink_work> at least my intuition tells me that
08:31:19 <poucet> jystic: what do you maen by "over and over again"?
08:31:40 <quicksilver> he pasted the code earlier
08:31:47 <int-e> you can resort to some data structure like  data IncFunctor f a = IncList { increment :: a, contents :: f a } and define a strict composistion for such increments ... which will actually work for any monoid.
08:31:49 <quicksilver> I made some comments, which he ignored.
08:32:04 <jystic> quicksilver: sorry, I didn't see those
08:32:53 <quicksilver> you need to change increment to use rnf to force the whole list
08:32:54 <int-e> doublethink_work: for that to work this will need to happen at compile time. I guess that the number of increment application is not known from the start.
08:33:13 <int-e> right, that will work ... if the list is small.
08:33:14 <quicksilver> and then change your call writeTVar to make sure it forces the result of increment
08:33:27 <quicksilver> before storing it in the tvar
08:33:41 * int-e imagined that xs = [1..] would be allowed.
08:33:43 <quicksilver> the $! you already have is probably enough for the latter.
08:33:48 <quicksilver> int-e: his list has length 10
08:34:02 <quicksilver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11982#a11982
08:34:06 <int-e> quicksilver: that makes quite a difference. yes, rnf is probably best then.
08:34:06 <roconnor> isn't there a way of using continuations to increment the amount that map is incrementing by?
08:34:37 <roconnor> You'll need to add some sort of "go" function / expression at the end to actually run the map.
08:35:14 <int-e> roconnor: you'll need some sort of generalised associativity law to do that. (i.e.  f a (f b x) = f (g a b) x)
08:35:32 <jystic> quicksilver: so if I change increment to "increment t = t { values = rnf $ map (+ 1) (values t) }" that should do the trick?
08:35:33 <int-e> roconnor: and I believe that means the transformation has to be explicit.
08:35:39 <conal> there's mitch wand's paper on "Continuation-based program transformation strategies"
08:35:50 <conal> one of my all-time favorite papers
08:36:50 <quicksilver> jystic: no.
08:36:56 <jystic> quicksilver: :)
08:36:59 <quicksilver> :t rnf
08:37:00 <lambdabot> forall a. (NFData a) => a -> Done
08:37:08 <quicksilver> (a) that doesn't type check
08:37:23 <quicksilver> (b) even if it did, burying the rnf *inside* the thunk would be no good.
08:38:13 <quicksilver> increment t = let newvalues = map (+1) values t in rnf newvalues `seq` t { values = newvalues}
08:38:16 <quicksilver> I think.
08:38:35 <int-e> and writeTVar $! increment blah
08:38:42 <jystic> quicksilver: thanks, i'll give that a try
08:38:51 <int-e> (plus the TVar argument that I forgot)
08:39:50 <quicksilver> int-e: yes, but he already has the $! on his writeTVar
08:39:51 <quicksilver> ;)
08:40:16 <int-e> sorry, I didn't look at the paste. (which was probably obvious by now)
08:42:47 <jystic> quicksilver: thanks, that worked, sorry for missing your reply earlier
08:43:25 <quicksilver> jystic: good. the problem was made particularly bad by the fact you never actually read the TVar, which is an unusual (unrealistc?) situation
08:43:35 <quicksilver> jystic: if you'd been reading it regularly the space leak would have been controlled.
08:43:58 <quicksilver> having said that, this is still an annoying problem in large haskell system
08:44:00 <int-e> hmm, not that unusual for statistics counters
08:44:11 <quicksilver> "disabling" code can cause a space leak elsewhere
08:44:21 <quicksilver> if that code had the effect of regularly forcing some thunk
08:44:27 <jystic> quicksilver: ahh I see, in practice I will be reading the TVar, this was just the simplest bite size example I could make of a problem I'm having in a larger program
08:44:35 <quicksilver> it is, unfortunately, a failure of conmpositionality.
08:44:49 <int-e> Consider the classical  modifyIORef steps (+1)
08:44:56 <quicksilver> it's good to know how to identify these things.
08:45:25 <quicksilver> I wonder if in large systems our MVars/TVars/IORefs should be paired with 'Strategy a's which delcare how much to force every time they are written
08:45:34 <quicksilver> (I have thought the same about Events, in a reactive system)
08:46:16 <int-e> Hmm, interesting thought. of course that can be done with suitable newtypes on top of the bare MVar, etc.
08:46:42 <int-e> i.e. it's a matter of building yet another small library.
08:47:05 <jystic> it's been a good little Haskell learning experience :)
08:53:47 <quicksilver> int-e: it is a curious kind of composablity failure, too
08:54:03 <quicksilver> int-e: "*remove* this component and your program will still work, but will gain a space leak"
08:54:16 <quicksilver> int-e: normally composability failures are about addition not removal.
08:54:22 <quicksilver> laziness is a strange beast.
08:55:53 <Saizan> i.e. laziness let you decouple generation and consuption in code but not in runtime
08:56:28 <Saizan> s/runtime/evaluation/
08:57:39 <gressvol-> hi i have a datatype that looks like this: data Hand = Empty | Add Card Hand, and the problem I have is that I want to append 2 hands. However I can only append the reversed Hand1 onto Hand2
08:58:45 <Zao> gressvol-: You could reverse it before-hand maybe?
08:59:13 <Zao> How does your hand++hand code look?
08:59:38 <ziman> you might find inspiration in how lists are usually appended
09:00:52 <zygoloid> @src (++)
09:00:52 <lambdabot> []     ++ ys = ys
09:00:52 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:00:52 <lambdabot> -- OR
09:00:52 <lambdabot> xs ++ ys = foldr (:) ys xs
09:01:04 <gressvol-> (Add c1 h1) h2 = append (Add c1 h2) h2 something like this
09:01:11 <zygoloid> gressvol-: ^^ look at the first of those two, and imagine Empty for [], and Add for (:)
09:01:18 <gressvol-> then base case is when first hand is Empty
09:02:40 <int-e> quicksilver: yes. laziness is Haskell's biggest virtue, and its curse.
09:03:35 <zygoloid> is there any research going on into speculative evaluation in the GC for such cases?
09:04:33 <int-e> Dunno. I know that the GC shortcuts field selectors. (e.g. snd (a,b) --> b)
09:05:23 <int-e> "the" GC being ghc's GC
09:09:09 <fasta> int-e, did you manage to get cabal-install to work on 6.12?
09:09:28 <fasta> Or anyone for that matter?
09:09:37 <int-e> fasta: the darcs version seemed to work fine, at least without user installed packaged
09:09:40 <int-e> *packages
09:09:53 <int-e> on linux though
09:10:01 <fasta> int-e, ah, that must be it.
09:10:17 <fasta> int-e, on mingw32 it takes a different code branch.
09:16:01 <jacobian_> How do you define a data with no constructors?
09:16:06 <jacobian_> data False = ...
09:16:26 <byorgey> jacobian_: just   data False
09:16:34 <byorgey> and you have to enable  EmptyDataDecls
09:16:43 <byorgey> i.e.  {-# LANGUAGE EmptyDataDecls #-} at the top
09:17:05 <jacobian_> k
09:17:10 <poucet> byorgey: you coming to the hackathon?
09:17:14 <jacobian_> Thanks byorgey
09:19:35 <byorgey> poucet: the one in Zurich?
09:19:39 <poucet> yes
09:19:49 <saml> no i can't come. sorry.
09:19:50 <byorgey> poucet: I'd love to, but I doubt it
09:20:11 <byorgey> poucet: maybe if people want to take up a collection to pay for my plane ticket... ;)
09:20:25 <poucet> byorgey: start a paypal and put it on your blog ;)
09:20:31 <byorgey> hehe
09:20:40 <int-e> newtype False = F False -- Haskell98, but perhaps too clever.
09:21:15 <ziman> i thought it was 'no constructors', not 'empty type'
09:21:30 <mjrosenb> ziman: you cannot use that constructor ever
09:21:37 <mjrosenb> so, same thing in effect
09:21:37 <jacobian_> It has no inhabitants which are terminating
09:21:46 <roconnor> int-e: nice
09:21:55 <poucet> nice trick :)
09:22:06 <poucet> at first I was going to say 'wait', but then noticed it's newtype and not data
09:22:39 <ziman> is F not a function False -> False?
09:22:39 <roconnor> abort (F x) = abort x
09:22:41 <zygoloid> jacobian_: and yet you can pattern-match on it as deeply as you like :)
09:22:50 <roconnor> abort :: False -> a
09:22:52 <int-e> ziman: yes, but fix F = bottom
09:23:03 <Cale> ziman: It is, but there are no (non-bottom) values of type False to apply it to
09:23:11 <jacobian_> clever
09:23:34 * int-e wonders where he saw that.
09:23:42 <roconnor> F is the identity function!
09:23:48 <zygoloid> int-e: it's been mentioned here a few times before
09:24:09 <jacobian_> hehe
09:24:31 <zygoloid> roconnor: so is const undefined :: False -> False ;-)
09:25:08 <roconnor> zygoloid: sort of
09:25:44 <roconnor> const undefined (error "I'm zygoloid") is kinda sorta different from F (error "I'm zygoloid") and id (error "I'm zygoloid")
09:25:55 <roconnor> sort of kinda under some intensional equality
09:26:09 <zygoloid> roconnor: right, but they're extensionally equivalent
09:26:15 <roconnor> yep
09:26:44 <zygoloid> but interestingly, undefined :: False -> False is not
09:27:05 <roconnor> seq is dumb
09:27:10 <zygoloid> yeah
09:27:25 <roconnor> I'd be happer if seq reduced things to hnf instead of whnf
09:27:32 <int-e> but without seq, how would we fix our space leaks?
09:27:36 <roconnor> I think that solves a bunch of problems.
09:27:50 <roconnor> int-e: use case x of x -> x
09:27:56 <roconnor> er
09:28:02 <roconnor> stupid lazy case
09:28:11 <roconnor> int-e: use case x of  { 0 -> 0;  x -> x }
09:28:15 <int-e> ok, let's pretend it's STG.
09:28:23 <int-e> err
09:28:24 <int-e> core.
09:29:15 <zygoloid> roconnor: i'm not sure on the difference between whnf and hnf. does hnf reduce across lambdas?
09:29:17 <roconnor> int-e: I offer "seq reducing to hnf" as a compromise.
09:29:38 <roconnor> zygoloid: ya, I'd advocate seq reducing under lambdas.
09:30:00 <int-e> roconnor: does that mean it can't be applied to functions or that it doesn't do anything when applied to functions?
09:30:16 <roconnor> zygoloid: Cale and I looked at this a while back and preliminary findings was this fixed the semantics, but we didn't look at it in detail.
09:30:18 <int-e> mmm
09:30:33 <zygoloid> int-e: it means that (\x -> undefined) `seq` foo is _|_, presumably
09:30:43 <roconnor> int-e: my proposal means that seq would do stuff when applied to lambdas.
09:31:09 <roconnor> zygoloid: yes, I beleive so.
09:31:49 <poucet> roconnor: what about (\x -> a `seq` b)?
09:32:07 <Cale> There were still some problems with it in the end, I think, (involving, say, where you had a function containing a case whose scrutinee depended on the parameter to the function, but all of whose branches didn't terminate)
09:32:13 <zygoloid> roconnor: it makes me slightly uneasy to reduce inside the lambda in "\x -> arbitraryFunctionOf x"
09:32:31 <Cale> But it was much more sensible than the existing seq about things.
09:32:31 <zygoloid> Cale: yikes!
09:33:40 <roconnor> poucet: what about it?
09:33:58 <poucet> roconnor: You would only apply seq to functions, but not go into functions and reduce seq's there?
09:34:07 <noknok> Hi there! I have written a package and I am about to finish and publish it, but this cabal is making me desparate (and the recommended darcs I don't even see what it is supposed to contribute). I have written the Foo.cabal file of my Foo package and the call of (./Setup.lhs configure -ghc) seems to work and answers with (Building Foo-1.0...). But when I try to (./Setup.lhs build) then it complaints that (Bar.hs:7:19:  Could not find module `
09:34:07 <noknok> List': it is a member of the hidden package `haskell98'). But then I try to add haskell98 or List to "build-depends", then the configuration returns and error "Setup.lhs: At least the following dependencies are missing: List -any".
09:34:20 <zygoloid> Cale: given "\x -> case x of a | f a -> g a; _ -> a", you'd need seq to analyze whether g a halts on all inputs which satisfy f a. that sounds uncomputable to me.
09:34:41 <zygoloid> Cale: "\x -> case x of a | f a -> g a; _ -> undefined", rather
09:34:45 <Cale> yeah
09:34:55 <dcoutts> noknok: it'll work if you add haskell98 to build-depends
09:35:08 <dcoutts> noknok: List is a module, not a package
09:35:25 <Cale> Well, actually, it's not so terrible -- you don't care about what f does when x is defined
09:35:28 <dcoutts> noknok: packages are collections of modules
09:35:40 <Cale> only what it does with an undefined value
09:36:24 <byorgey> noknok: also, it's recommended to use  Data.List  instead of  List
09:36:33 <noknok> dcoutts: wow, you are right! I thought I tried to add haskell98 and that it failed. But I did it again and it works! Thank you!
09:36:59 <byorgey> List was the old H98 non-hierarchical module name
09:38:01 <dcoutts> noknok: for reference, there's the cabal user guide and FAQ on the cabal website. You can also look at loads of example .cabal files from hackage.
09:38:29 <dcoutts> noknok: and if you're really stuck there's still #haskell :-)
09:39:34 <zygoloid> Cale: i don't follow why that's the case
09:40:19 <noknok> Dear people: Thanks for your help. I think I can continue from here. But does anybody point me to a nice article on the whole cabal etc? The cabal user guide is overwhelming and the standard paper of Jones, Peyton Jones, Marlow et al is full of inconsistencies..
09:40:24 <zygoloid> Cale: although, we only need it to be semi-decidable, given that it's seq we're implementing :)
09:41:11 <dcoutts> noknok: sadly there isn't a simple tutorial. The first chapter of the user guide is not too bad though.
09:42:17 <juturna> I've been using a Data.Map of Ints to my data type to manage a bunch of unique pieces of data that a lot of different things need to refer to
09:42:25 <noknok> dcoutts: thanks. You are right, the user guide isn't too bad and with my obstacle solved, I should be able to continue.
09:42:36 <juturna> but i need to do thousands of lookups/updates per second
09:42:43 <juturna> and I want to move to a more efficient container
09:43:13 <juturna> I think I should go with IOArrays
09:43:37 <juturna> but it seems like there are quite a few options
09:43:46 <juturna> any suggestions?
09:44:00 <dcoutts> noknok: or there's a 2-page overview here: http://haskell.org/cabal/talks/HS-2008-batteries-paper.pdf
09:44:11 <dcoutts> noknok: it's not a "how to" on making package descriptions though
09:46:03 <mightybyte> @pl \f (x,y) -> x:(f y)
09:46:03 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (:))
09:46:12 <noknok> dcoutts: Thank you, again. You helped me a lot.
09:46:31 <mightybyte> @pl \(x,y) f -> x:(f y)
09:46:31 <lambdabot> uncurry ((. flip id) . (.) . (:))
09:46:33 <dcoutts> np
09:47:34 <zygoloid> @pl \x f y -> x:f y
09:47:34 <lambdabot> (.) . (:)
09:48:11 <saml> almost boobie
09:48:33 <kmc_> triple nipple
09:57:13 <Nafai> Has anyone done any work with the GData APIs, specifically contacts?  I haven't found anything on Hackage.
09:57:35 <Nafai> I'd like to write a small app I had in mind with Haskell, but if there isn't a library, I'll just go back to Python for convenience :(
09:57:46 <Raevel> or write a gdata library!
09:58:49 <Nafai> Raevel: I'm too lazy to do that for a script that will probably take an hour or two to write :(
09:59:27 <Raevel> is it just xml?
10:00:28 <saml> Nafai, why do you want to do it in haskell?
10:00:50 <Raevel> topic change: i thought parsec 3 had an applicative instance, was I mistaken?
10:01:10 <saml> parsec3 isn't recommended i think
10:02:03 <byorgey> Raevel: you are not mistaken.
10:02:15 <Nafai> saml: It's starting to be my language of choice
10:02:18 <Raevel> hmmmm
10:02:34 <byorgey> http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Prim.html#t%3AParsecT
10:02:54 <saml> Nafai, ah so it's personal.
10:04:11 <Raevel> oh thanks
10:04:57 <Nafai> saml: Yes.
10:07:42 <paolino> Nafai: maybe an RDF lib could help
10:18:01 <pkrumins> Hi guys, can anyone take a look at this simple function - http://pastebin.ca/1663705 - I am getting an error that I have a syntax error, but I can't see the mistake.
10:18:50 <byorgey> pkrumins: you're missing an  =  after otherwise
10:20:24 <red-agent> Is there an analogue to Python's enumerate? Basically `zip lst [0..length lst]`
10:20:32 <PeakerWork> red-agent: enumerate = zip [0..]
10:20:38 <int-e> pkrumins: it may help to know that 'otherwise' is not part of the Haskell syntax; it's a normal value that evaluates to True.
10:20:39 <PeakerWork> red-agent: I don't think that line is in any library
10:20:46 <int-e> > otherwise
10:20:47 <lambdabot>   True
10:21:37 <red-agent> Peaker: Haven't used to the lazyness yet. So I take is as no? The zip lst [0..] is the shortest way?
10:22:15 <PeakerWork> red-agent: the [0..] should be on the left for "enumerate" :)
10:22:31 <idnar> "zip [0..]" and "enumerate" are exactly the same length anyway :P
10:22:31 <PeakerWork> red-agent: you can define:  enumerate = zip [0..]        and then use enumerate
10:22:43 <PeakerWork> idnar: token-wise, enumerate is 1 token :)
10:22:49 <Cale> <Cale> I think the physicists' convention might just be flipped left to right
10:22:49 <Cale> <linimoo> I think every physicist has their own convention
10:22:49 <Cale> <Cale> ehehe
10:22:49 <Cale> <linimoo> and the most difficult part of their job is trying to remember what it was
10:22:53 <CalJohn> int-e: heh, that reminds me of the Little Schemer: "else?"  "of course!"
10:23:00 <pkrumins> byorgey, oh, thanks a lot!
10:23:04 <pkrumins> byorgey, works now :)
10:23:14 <pkrumins> int-e, thanks for the valuable comment, I dodn't know this!
10:23:25 <thebloggu> can someone tell me how can i run a command through haskell? and read the output?
10:23:33 <kmeyer> > head 10 (zip [0..])
10:23:35 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:23:35 <lambdabot>    `GHC.Num.Num t' arising ...
10:23:51 <red-agent> PeakerWork: Yes, I know it should be on the left, thanks =) I've just used it in the code other way.
10:23:51 <koeien37> kmeyer: you need an extra argument to zip [0..]
10:23:52 <kmeyer> > head 10 (zip [0..]) :: [Int]
10:23:53 <lambdabot>   No instance for (GHC.Num.Num
10:23:53 <lambdabot>                     [([b] -> [(t, b)]) -> [GHC...
10:23:58 <kmeyer> koeien37: ah, I see
10:24:03 <idnar> > head 10 (zip [0..] "foo")
10:24:05 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:24:05 <lambdabot>    `GHC.Num.Num t' arising ...
10:24:12 <koeien37> head 10 (zip [0..] (repeat "foo"))
10:24:14 <PeakerWork> head 10? :)
10:24:16 <red-agent> *already
10:24:18 <idnar> err
10:24:20 <PeakerWork> > zip [0..] "hello"
10:24:21 * idnar facepalms
10:24:22 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
10:24:23 <koeien37> > take 10 (zip [0..] (repeat "foo"))
10:24:25 <lambdabot>   [(0,"foo"),(1,"foo"),(2,"foo"),(3,"foo"),(4,"foo"),(5,"foo"),(6,"foo"),(7,"...
10:24:35 <kmeyer> whoops
10:24:38 <PeakerWork> @let enumerate = zip [0..]
10:24:39 <lambdabot>  Defined.
10:24:45 <PeakerWork> > enumerate (repeat "foo")
10:24:46 <lambdabot>   [(0,"foo"),(1,"foo"),(2,"foo"),(3,"foo"),(4,"foo"),(5,"foo"),(6,"foo"),(7,"...
10:25:32 <saml> finally enumerate is included to Prelude
10:25:57 <thebloggu> can someone tell me how can i run a command through haskell? and read the output?
10:26:26 <saml> System.Cmd i think
10:26:36 <PeakerWork> thebloggu: what do you mean? In a Haskell program? In the shell?
10:26:42 <saml> > system "ls --larth"
10:26:43 <lambdabot>   Not in scope: `system'
10:26:55 <PeakerWork> Oh.. "system" sucks
10:26:57 <saml> > System.Cmd.system "ls --larth"
10:26:58 <PeakerWork> @hoogle popen
10:26:58 <lambdabot>   Not in scope: `System.Cmd.system'
10:26:59 <lambdabot> No results found
10:27:05 <PeakerWork> @hoogle spawn
10:27:06 <lambdabot> No results found
10:27:08 <PeakerWork> @hoogle execute
10:27:09 <lambdabot> Text.Regex.Posix.ByteString execute :: Regex -> ByteString -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))
10:27:09 <lambdabot> Text.Regex.Posix.Sequence execute :: Regex -> Seq Char -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))
10:27:09 <lambdabot> Text.Regex.Posix.String execute :: Regex -> String -> IO (Either WrapError (Maybe (Array Int (MatchOffset, MatchLength))))
10:27:31 <thebloggu> placing the question better: is there a way i can find the current resolution in haskell? alternatively running a command in the shell it's ok, if i can read the ouput
10:27:39 <thebloggu> PeakerWork, yes
10:28:06 <PeakerWork> thebloggu: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=exec#0:popen
10:29:34 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
10:29:46 <thebloggu> Peaker,
10:29:56 <Cale> ^^ if you need to read the output of a program you run, or interactively pass it input, then the stuff in that module is what you want
10:30:25 <Zao> Or give HSH a spin.
10:30:55 <PeakerWork> thebloggu: http://hackage.haskell.org/packages/archive/popenhs/1.0.0/doc/html/System-Posix-POpen.html#v:popen
10:30:59 <thebloggu> Cale, thank you very much. it seems to be what i need
10:31:57 <PeakerWork> http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html#v%3AreadProcessWithExitCode -- seems to do the trick
10:32:13 <Cale> System.Process is the cross-platform way to do it :)
10:32:42 <thebloggu> PeakerWork, Cale yes. thank you :)
10:33:21 <thebloggu> i believe i have to install a library, am i right? if yes, can you please tell me how? i only worked with prelude in the past
10:33:38 <Cale> oh, this is in the libraries usually included with ghc
10:33:44 <Cale> so you should be able to just write
10:33:48 <Cale> import System.Process
10:33:54 <Cale> at the top of your module
10:34:00 <thebloggu> Cale, cool. even better. thank you very much
10:34:01 <PeakerWork> thebloggu: its in the "process" library which I believe comes installed with ghc
10:34:36 <PeakerWork> You might want to write:   import System.Process(readProcessWithExitCode) -- closed import means less potential for name clashing, and more names clarity
10:34:40 * hackagebot upload: control-monad-exception 0.6 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
10:35:40 <thebloggu> PeakerWork, thank you
10:42:42 <pkrumins> Suppose I have a function like `foo (x:xs) | some_cond <need to pass the whole (x:xs) to another function>`. What's the most idiomatic way to pass (x:xs) to another function? I wrote something like [x] ++ xs to reconstruct the original list, but that seems too ugly.
10:43:01 * hackagebot upload: iteratee 0.3.1 - Iteratee-based I/O (JohnLato)
10:43:19 <pkrumins> hmm, maybe just (x:xs) :)
10:44:02 <zygoloid> pkrumins: foo xs@(x:xt) | some_cond = ...
10:44:14 <zygoloid> pkrumins: that binds the name xs to the whole list, and binds x and xt to the head and tail respectively
10:44:24 <pkrumins> excellent!
10:44:26 <pkrumins> :)
10:44:28 <pkrumins> thanks zygoloid
10:45:39 <dpratt71> where's a good place to read up on Haskell's catalog of numeric types (and how they relate to each other)?
10:46:16 <Botje> pkrumins: of course, if you don't need to inspect x or xs in your condition or you code, you could simply match it as a list
10:46:32 <pkrumins> have to inspect.
10:46:54 <pkrumins> and you are right, if i didn't need to inspect, I could do that.
10:47:23 <Botje> dpratt71: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Prelude.html#5 N
10:47:35 <pkrumins> but something still doesn't work in my code, I'll create a paste.
10:47:44 <jthing> Where do I find information on the Haskell debugger?
10:47:48 <thebloggu> PeakerWork, Cale i dont work with haskell in a long time. i just need the stdout string (whci is the second). the type is IO (ExitCode,String,String)
10:48:03 <Botje> dpratt71: if you skip the huge instance lists, that gives a pretty good overview of the numbers.
10:48:08 <dpratt71> Botje: thanks
10:48:09 <thebloggu> can i define a function parser IO(_,a_) = .. process a?
10:48:19 <thebloggu> s/IO(_,a_)(IO(_,a,_) sorry
10:48:32 <Botje> thebloggu: no .. you can only create a function that returns an IO (something)
10:48:37 <Cale> thebloggu: actually, you could just use readProcess
10:49:05 <Cale> But suppose you wanted to use readProcessWithExitCode, you'd write
10:49:06 <pkrumins> I wrote a merge' function, but I get the error at the bottom of the paste, any ideas what's wrong? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4869#a4869
10:49:07 <Cale>  do ...
10:49:22 <Cale>     (exitCode, out, err) <- readProcessWithExitCode ...
10:49:32 <Botje> pkrumins: you use ++ to append lists :)
10:49:36 <Cale>     ... use out as a String here ...
10:49:42 <pkrumins> oops, that's a typo :)
10:49:46 <pkrumins> Botje, thanks for catching.
10:49:53 <Cale> thebloggu: make sense?
10:50:00 <thebloggu> Botje, Cale hmm thanks
10:50:03 <Cale> thebloggu: and that whole do-block would be all one IO action
10:50:10 <thebloggu> Cale, yes, abslolutely
10:50:17 <Cale> Okay, cool :)
10:50:24 <thebloggu> Cale, absolutely*
10:50:32 <thebloggu> thank yoo once again
10:50:55 <thebloggu> you* (tucking fypos :P)
10:53:35 <PeakerWork> thebloggu, Cale: I wouldn't like my stdout and stderr to be garbled together :)
10:54:30 <PeakerWork> @type snd3
10:54:34 <lambdabot> Not in scope: `snd3'
10:54:40 <PeakerWork> @hoogle (a,b,c) -> b
10:54:41 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
10:54:42 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
10:54:53 <PeakerWork> I hate N-tuples! :-(
10:55:03 <thebloggu> PeakerWork, :P
10:55:38 <PeakerWork> > snd3 (1,2,3)
10:55:39 <lambdabot>   Not in scope: `snd3'
10:55:42 <pkrumins> Can haskell operate on bits of Int?
10:55:45 <PeakerWork> @let snd3 (x,y,z) = y
10:55:47 <lambdabot>  Defined.
10:55:54 <PeakerWork> pkrumins: yeah, it can operate on the Bits of any instance of Bits
10:56:13 <pkrumins> Like `is_even n | n & 1 == 0 = True`
10:56:18 <PeakerWork> thebloggu: you can use "fmap snd3" to convert   IO (a,b,c)   to IO b
10:56:21 <pkrumins> this doesn't quite work, because there is no &
10:56:28 <PeakerWork> pkrumins: .&.
10:56:30 <PeakerWork> @type (.&.)
10:56:32 <pkrumins> oh
10:56:32 <lambdabot>     Ambiguous occurrence `.&.'
10:56:32 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
10:56:32 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
10:56:40 <PeakerWork> @type (Data.Bits..&.)
10:56:42 <Botje> pkrumins: look dat Data.Bits
10:56:42 <lambdabot> forall a. (Bits a) => a -> a -> a
10:56:46 <Botje> bah, too late
10:56:50 <pkrumins> :)
10:56:59 <PeakerWork> > 7 Data.Bits..&. 11
10:57:00 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:57:01 <lambdabot>    `Data.Bits.Bits t'
10:57:01 <lambdabot>      a...
10:57:06 <PeakerWork> > 7 Data.Bits..&. 11 :: Int
10:57:08 <lambdabot>   3
10:57:10 <PeakerWork> > 7 Data.Bits..&. 11 :: Integer
10:57:11 <lambdabot>   3
10:57:21 <PeakerWork> @hoogle .~.
10:57:21 <lambdabot> No results found
10:57:28 <int-e> > 3 .|. 7 :: Int
10:57:30 <lambdabot>   7
10:57:39 <int-e> > 3 .|. -8 :: Int
10:57:40 <lambdabot>   -5
10:57:43 <PeakerWork> I wonder if Bits, like Python, negates to represent bitwise not on Integer
10:57:44 <pkrumins> hmm
10:57:48 <int-e> > 3 .|. -8 :: Integer
10:57:49 <lambdabot>   -5
10:57:58 <thebloggu> PeakerWork, thanks :)
10:58:08 <int-e> > not 0 :: Integer
10:58:09 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
10:58:10 <lambdabot>         agains...
10:58:15 <int-e> uhm
10:58:25 <PeakerWork> @hoogle Bits a => a -> a
10:58:26 <lambdabot> Data.Bits complement :: Bits a => a -> a
10:58:26 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
10:58:26 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
10:58:28 <aavogt> > complement 0
10:58:29 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:58:29 <lambdabot>    `Data.Bits.Bits t'
10:58:29 <lambdabot>      a...
10:58:35 <PeakerWork> > complement 0 :: Integer
10:58:35 <int-e> > complement 0 :: Integer
10:58:36 <lambdabot>   -1
10:58:36 <lambdabot>   -1
10:59:02 <pkrumins> > 5/2 :: Integer
10:59:03 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
10:59:04 <lambdabot>    aris...
10:59:23 <int-e> > 5 `div` 2 :: Integer
10:59:24 <lambdabot>   2
11:00:14 <PeakerWork> > 5 `divMod` 2
11:00:15 <lambdabot>   (2,1)
11:00:17 <PeakerWork> > 5 `remQuot` 2
11:00:18 <lambdabot>   Not in scope: `remQuot'
11:00:22 <pkrumins> nice
11:00:25 <PeakerWork> > 5 `quotRem` 2
11:00:27 <lambdabot>   (2,1)
11:00:42 <jlouis> > 5 % 2
11:00:44 <lambdabot>   5 % 2
11:01:20 <int-e> @type (%)
11:01:22 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
11:02:42 <GNU\colossus> how would I best go about calculating all substrings of a given String?
11:03:41 <aavogt> > inits =<< tails "like this"
11:03:42 <lambdabot>   ["","l","li","lik","like","like ","like t","like th","like thi","like this"...
11:04:03 <aavogt> > drop 10 $ inits =<< tails "like this"
11:04:04 <lambdabot>   ["","i","ik","ike","ike ","ike t","ike th","ike thi","ike this","","k","ke"...
11:04:15 <Polarina> What does $ do?
11:04:15 <int-e> please use inits first
11:05:11 <aavogt> > inits "abcde"
11:05:12 <lambdabot>   ["","a","ab","abc","abcd","abcde"]
11:05:33 <aavogt> int-e: just a question of efficiency?
11:05:40 <int-e> with map tails . inits, you get maximum sharing and O(n^2) complexity
11:06:01 <int-e> aavogt: yes.
11:06:09 <aavogt> good to know
11:06:55 <GNU\colossus> aavogt: please forgive my being somewhat haskell-illiterate, but what does the "=<<" do?
11:06:59 <jlouis> GNU\colossus: to understand that one, try int-e's variant: Figure out what inits, tails and map does and see how they are combined
11:07:08 <int-e> =<< is another name for concatMap in this context
11:07:22 <GNU\colossus> thanks, I guess I can work with that
11:08:06 <aavogt> , vacuum (inits =<< tails "hai")
11:08:09 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[5,1]),(4,[6,7]),(5,[]),(6,[5,8]),(7,[10,1...
11:08:17 <aavogt> , length $ vacuum (inits =<< tails "hai")
11:08:19 <lunabot>  24
11:08:21 <Twey> GNU\colossus: It does >>=, backwards.  ☺
11:08:28 <aavogt> , length $ vacuum (tails =<< inits "hai")
11:08:30 <lunabot>  20
11:09:21 <aavogt> interesting how that changes the sharing
11:09:43 <int-e> @src tails
11:09:43 <lambdabot> tails []         = [[]]
11:09:43 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
11:09:48 <int-e> @src inits
11:09:49 <lambdabot> inits []     =  [[]]
11:09:49 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
11:11:19 <jlouis> @src (=<<)
11:11:20 <lambdabot> f =<< x = x >>= f
11:11:38 <thebloggu> PeakerWork, wouldn't do (_,stdout,_) <- readProcessWithExitCode "xrandr" ["-q"] "" work?
11:12:34 <int-e> aavogt: well I guess the basic insight is that only tails of lists can be shared, so init has to create all the result lists from scratch.
11:14:15 <int-e> > let rinits = scanl (flip (:)) [] in rinits [1..4] -- reversed initial segments would also have good sharing
11:14:16 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1]]
11:14:53 <aavogt> so inits is n^2 complexity?
11:14:57 <PeakerWork> thebloggu: yeah, sure
11:14:58 <int-e> aavogt: yep
11:16:06 <thebloggu> PeakerWork, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4870#a4870
11:17:54 <fentiman> quick question: intercalate is not working for me for some reason, I've imported Data.List? That's not really a question, but help please anyway
11:18:07 <PeakerWork> @index intercalate
11:18:08 <lambdabot> bzzt
11:18:15 <PeakerWork> @type Data.List.intercalate
11:18:17 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:18:19 <PeakerWork> weird
11:18:22 <zygoloid> fentiman: can you expand on your question? what's not working properly, and how?
11:18:37 <aavogt> question: is it inter-calate or intercal-ate or interc-alate
11:18:38 <zygoloid> fentiman: (what did you try, what did you expect, what actually happened?)
11:18:51 <zygoloid> in-ter-ca-late
11:19:07 <fentiman> typed in this on WinHugs after loading Data.List: intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]], but I get ERROR - Undefined variable "intercalate"
11:19:29 <jeltsch> Who is responsible for the Haskell Community Server?
11:19:33 <thebloggu> PeakerWork, what's weird?
11:19:41 <byorgey> fentiman: what version of the base package do you have?
11:19:57 <byorgey> fentiman: intercalate is somwhat new
11:20:19 <fentiman> I don't know how to find out, I downloaded winhugs about 2 months ago
11:20:20 <zygoloid> also somewhat poorly named unless it's being used on lists of days i'd say :)
11:20:35 <jeltsch> I’ve sent two e-mails to the support 4 weeks ago, which weren’t answered until know.
11:21:02 <byorgey> fentiman: hmm, I don't know how to find out with winhugs either, but I'm guessing that's probably why.
11:21:17 <jeltsch> Is someone of the community.haskell.org admins listening?
11:22:14 <fentiman> byorgey: thanks anyway
11:22:37 <fentiman> is WinHugs not as well supported as GHC?
11:22:45 <PeakerWork> thebloggu: that @index failed to find intercalate
11:23:06 <byorgey> fentiman: no, it isn't.
11:23:09 <thebloggu> PeakerWork, what does that mean?
11:23:19 <PeakerWork> thebloggu: @index is supposed to tell you what modules export a name
11:23:20 <byorgey> fentiman: you may want to consider installing the Haskell Platform
11:23:22 <PeakerWork> @index sort
11:23:22 <lambdabot> Data.List
11:23:35 <byorgey> which includes ghc/ghci, cabal, and a bunch of standard libraries
11:23:39 <PeakerWork> thebloggu: lambdabot knows Data.List.intercalate (@type does) but @index doesn't
11:23:54 <thebloggu> PeakerWork, hmm, ok
11:23:58 <helge> Is it possible to mix read-only and writable data in a state monad, like with private/public in OOP?
11:24:03 <GNU\colossus> int-e: OK, I understand what bith inits and tails do, and I also know (intuitively) how to generate all substrings of a given string byu sing the result of those functions, but I fail to see how I could use "map" to actually built that list. could you give me ahint once more?
11:24:07 <GNU\colossus> both*
11:24:25 <opqdonut> helge: read-only data is usually represented by the Reader monad
11:24:31 <opqdonut> aka the environment monad
11:24:45 <PeakerWork> helge: just mix ReaderT with StateT
11:24:47 <helge> yeah, so I should mix the two?
11:24:53 <helge> ok..
11:24:57 <opqdonut> RWS is a nice monad too
11:25:28 <opqdonut> reader isn't strictly read-only tho
11:25:38 <roconnor> opqdonut: oh?
11:25:44 <opqdonut> one can replace the environment in a call
11:25:49 <thebloggu> PeakerWork, do you have any idea what could be causing my error?
11:25:54 <opqdonut> but a node in the call tree can
11:26:03 <fentiman> byorgey: I'll look into that thanks, my lecturer wanted us to start with WinHugs though
11:26:11 <opqdonut> *can't affect the enviroments elsewhere than "below" it
11:26:14 <opqdonut> if you see what i mean
11:26:25 <roconnor> not really
11:26:30 <roconnor> are you talking about local?
11:26:47 <opqdonut> yes
11:26:52 <roconnor> @type local
11:26:53 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
11:27:07 <pkrumins> is there a pattern that matches a list with just one element? so that I didn't have to do something like `foo (x:xs) = if xs == [] then ... else <xs is not empty>`
11:27:08 <PeakerWork> thebloggu: I didn't see you pasted, oops
11:27:09 * roconnor ponders
11:27:14 <opqdonut> one can run a sub-action in a modified environment
11:27:17 <opqdonut> but the modification doesn
11:27:21 <opqdonut> 't propagate
11:27:22 <zygoloid> local doesn't replace the environment. it runs a separate action in a different environment
11:27:28 <thebloggu> PeakerWork, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4870#a4870
11:27:36 <thebloggu> PeakerWork, np
11:27:44 <opqdonut> zygoloid: that's a different way of putting it
11:27:44 <zygoloid> it's a more convenient form of runReader, is all
11:27:47 <Raevel> aiia
11:27:48 <Raevel> openFile: hardware fault (Input/output error)
11:27:53 <Raevel> canNotReproduce
11:28:00 <roconnor> @djinn (Not (a -> Not b)) -> a
11:28:01 <lambdabot> -- f cannot be realized.
11:28:05 <roconnor> @djinn (Not (a -> Not b)) -> b
11:28:06 <lambdabot> -- f cannot be realized.
11:28:25 <roconnor> @djinn (Not (Not b)) -> b -> (Not (a -> Not b)) -> b
11:28:26 <lambdabot> f _ a _ = a
11:28:29 <Botje> pkrumins: x:[] or [x]
11:28:31 <jlouis> pkrumins: you are searching for a match on the pattern [x]
11:28:36 <roconnor> @djinn ((Not (Not b)) -> b) -> (Not (a -> Not b)) -> b
11:28:37 <lambdabot> f a b = a (\ c -> void (b (\ _ d -> c d)))
11:28:44 <roconnor> @djinn ((Not (Not a)) -> a) -> (Not (a -> Not b)) -> a
11:28:45 <lambdabot> f a b = a (\ c -> void (b (\ d -> void (c d))))
11:28:47 <copumpkin> ooh
11:29:07 <pkrumins> aha!
11:29:08 <pkrumins> thank you!
11:29:24 <zygoloid> @type (\f a -> ask >>= return . runReader a . f) :: (r -> r) -> (Reader r a) -> (Reader r a)
11:29:25 <lambdabot> forall r a. (r -> r) -> Reader r a -> Reader r a
11:29:30 <jlouis> pkrumins: of course that can be generalized to 2,3,4 element matches in the obvious way
11:30:03 <PeakerWork> thebloggu: where's the code itself?
11:30:13 <roconnor> ah, there is no way to prevent local from existing in the plain Reader Monad.
11:30:29 * leimy_ is still fighting wherever the waste is in his program
11:30:36 <thebloggu> PeakerWork, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4871
11:30:50 <leimy_> It occurs to me that now that I've rewritten a parser, that it's not likely the parser that's the problem, tbu the result.
11:30:59 <leimy_> and what I'm doing with it.
11:31:17 <roconnor> @check \ x-> if x then true else false == x
11:31:19 <lambdabot>   Not in scope: `true'Not in scope: `false'
11:31:34 <roconnor> @check \ x-> if x then True else False == x
11:31:35 <lambdabot>   "OK, passed 500 tests."
11:31:55 <mightybyte> Is there a way to make ghc statically link libraries like libgmp?
11:31:56 <PeakerWork> thebloggu: ghc inferred that the "do" of "run" is the List Monad's do, because the type is String=[Char]
11:32:08 <PeakerWork> thebloggu: the type of run should be IO String
11:32:40 <PeakerWork> thebloggu: if "run" was a String, it would be a single immutable string, not something that can make many strings
11:32:44 <leimy_> it's as if I'm building up a ton of closures that never get evaluated.
11:32:50 <leimy_> are insertions to Data.Map lazy?
11:32:56 <leimy_> unless looked up again?
11:32:58 <zygoloid> it seems somewhat wrong for 'local' to be part of MonadState; it unnecessarily restricts its generality
11:33:01 <PeakerWork> thebloggu: main should have type IO (), not Int
11:33:19 <thebloggu> PeakerWork, can i convert IO String to String?
11:33:59 <pkrumins> I wrote the merge-sort algorithm in Haskell. Could anyone comment on its style? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4872#a4872
11:34:26 <mauke> thebloggu: can you convert [String] to String?
11:35:08 <roconnor> mauke: that isn't a very helpful answer
11:35:15 <thebloggu> mauke, knowing [String] only has one String i would use head
11:35:22 <mauke> thebloggu: yeah, but you don't know that
11:35:33 <PeakerWork> thebloggu: in a sense, you can..  when you "bind" (>>=) IO String to a lambda, that lambda gets the "String" inside the IO, but the result of (>>=) is again in IO, so you can't really have   IO String -> String.      But you have:  IO String -> (String -> IO a) -> IO a   or if you want:  (String -> a) -> IO String -> IO a
11:35:46 <zygoloid> > (\s -> (if read s then True else False, read s)) "True"
11:35:48 <lambdabot>   (True,* Exception: Prelude.read: no parse
11:35:57 <mauke> the point is that IO String is not a box containing a String, just like [String]
11:36:34 <mauke> but while [String] is a (potentially empty) list of multiple Strings, IO String is an action that (when run) produces a String
11:36:39 <roconnor> zygoloid: polymorphism tricks
11:36:40 <thebloggu> PeakerWork, mauke how can i use lines, for instance with IO String then? do i have to define it?
11:36:46 <zygoloid> roconnor: :)
11:36:56 <roconnor> zygoloid: nice example though.
11:37:09 <mauke> thebloggu: you can't get the String out, but you can get yourself in
11:37:16 <mauke> with (>>=)
11:37:22 <zygoloid> roconnor: defaulting makes me sad sometimes
11:37:28 <roconnor> ya
11:37:30 <thebloggu> mauke, hmm, ok
11:38:36 <thebloggu> PeakerWork, mauke thank you very much
11:40:09 <thebloggu> PeakerWork, mauke can you show me an example of how it works?
11:41:56 <mauke> getContents >>= (\x -> return (lines x))
11:43:00 <bnijk_> how do you do linear regression in haskell
11:43:01 <bnijk_> !
11:44:34 <saml> data Gate = Gate [Input] [Output] | Connection Gate Gate    -- does it make sense? if i want to make a circuit designer
11:44:37 <thebloggu> mauke, i define it like a function?
11:44:37 <Gracenotes> with a linear regression algorithm
11:45:19 <Gracenotes> least squares is one of the simpler algorithms.. and perhaps there are libraries that implement it already... dunno.
11:48:36 <binrapt> @src (>>=)
11:48:37 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:48:38 <sproingie> saml: i think you want two different types, unless you want a connection to *be* a gate
11:48:43 <dancor> bnijk_: http://en.wikipedia.org/wiki/Ordinary_least_squares
11:48:49 <thebloggu> mauke, can you show me an example in my run function: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4871 ? i am not following, sorry
11:48:50 <PeakerWork> @src Monad
11:48:51 <lambdabot> class  Monad m  where
11:48:51 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:48:51 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:48:51 <lambdabot>     return      :: a -> m a
11:48:51 <lambdabot>     fail        :: String -> m a
11:48:58 <Cale> saml: Presumably you will also need gates to keep track of what sort of gate they happen to be :)
11:49:00 <bnijk_> hmph
11:49:12 <bnijk_> anybody know where i can find it in C?
11:49:36 <saml> Gate [] [Int]  -- something that always outputs an Int
11:49:39 <dancor> bnijk_: http://www.haskell.org/pipermail/haskell-cafe/2007-November/034122.html
11:49:41 <sproingie> saml: if you're defining some kind of DSL and you want all the components as one type, then it makes a bit more sense
11:50:02 <bnijk_> i love computers
11:50:09 <sproingie> then you can use newtypes to differentiate them again
11:50:20 <bnijk_> the only part i'm having trouble with is the 'minimize' part
11:50:39 <sproingie> tho then i'd say "data Component = ..blah.." instead
11:50:42 <bnijk_> nevermind
11:50:43 <bnijk_> thanks
11:51:54 <saml> Connection (Gate [] [Int]) (Connection (Gate [] [Int]) (Gate [Int, Int] [Int])) -- trying to do 1 + 1
11:52:14 <kmc_> saml, what do you mean by [Int] there?  that's a type, not a value
11:52:15 <sproingie> one would think digital logic would be Bool, not Int
11:52:37 <thebloggu> PeakerWork, can you show me an example in my run function: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4871 ? i am not following, sorry
11:52:52 <saml> data Input = Int | Bool | Char | UserDefined;    type Output = Input
11:52:52 <Cale> saml: so gates are adders?
11:53:38 <saml> i'm confused. ("F" ++ repeate "U")
11:53:54 <kmc_> :t repeat "U"
11:53:56 <lambdabot> [[Char]]
11:54:01 <kmc_> :t repeat 'U'
11:54:02 <lambdabot> [Char]
11:54:45 <binrapt> Why does ghc -o Test.exe Test.hs produce a PE which imports WSOCK32 recv/send but not even WSAStartup? Mind you, this is like a Haskell hello world, I am puzzled as to why it would import the Windows networking API (even though it couldn't be used without GetProcAddress or similar stuff due to the absence of WSAStartup)
11:55:00 <sproingie> weird how lambdabot responds to :t here but not in private message
11:55:16 <PeakerWork> thebloggu: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4874
11:55:41 <kmc_> yeah, in PM it only accepts commands like @type
11:57:51 <thebloggu> PeakerWork, Couldn't match expected type `String'
11:57:51 <thebloggu>            against inferred type `IO String'
11:58:01 <thebloggu> in main's parse run
11:59:37 <PeakerWork> thebloggu: oops, that should be parse result
12:01:09 <PeakerWork> thebloggu: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4876 -- do note I don't run it before pasting ;)
12:01:20 <PeakerWork> (or compile)
12:01:27 <PeakerWork> thebloggu: I used a points-free one in the last paste
12:03:52 <thebloggu> PeakerWork, ok, thank you very much :)
12:04:10 <thebloggu> PeakerWork, Couldn't match expected type `IO Int' against inferred type `Int'
12:04:10 <thebloggu>     In the first argument of `(=<<)', namely `boolToInt . parse'
12:04:11 <thebloggu> :P
12:04:14 <PeakerWork> thebloggu: If you want, I can explain the points-free versions.. you see I left out the simpler-to-understand ones in comments
12:04:53 <PeakerWork> thebloggu: oops, replace =<< with `fmap` :-)
12:05:12 <PeakerWork> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4877
12:05:20 <thebloggu> Peaker, i already got a sneak-a-peek of point-free, although i am not totally confortable with it yet, but i can understande it :)
12:05:41 <PeakerWork> thebloggu: cool :)
12:05:48 <PeakerWork> thebloggu: do you understand the difference between `fmap` and =<< ?
12:05:49 <thebloggu> PeakerWork, Precedence parsing error
12:05:49 <thebloggu>         cannot mix `.' [infixr 9] and `fmap' [infixl 9] in the same infix expression
12:05:59 <thebloggu> PeakerWork, not really :P
12:06:05 <kmc_> instead using fmap (especially infix) some people use <$>
12:06:20 <PeakerWork> thebloggu: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4878
12:06:51 <Cale> PeakerWork: see... with fmap = (.), we wouldn't have that problem ;)
12:06:54 <thebloggu> PeakerWork, Ok, modules loaded: Main. :P
12:08:13 <kmc_> can fmap actually be subsumed by the generalized (.)?
12:08:15 <kmc_> :t (.)
12:08:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:08:22 <Cale> That's actually kind of an interesting problem. There's no way to express in Haskell that (.) associates over fmap and so it doesn't matter which way it parenthesises the expression.
12:08:30 <kmc_> oh heh
12:08:46 <kmc_> i thought (.) was a class member of Control.Category.Category these days
12:08:57 <Cale> Oh, it is, but I don't have that imported
12:08:57 <copumpkin> it is, too
12:09:01 <copumpkin> but nobody uses that :)
12:09:07 <copumpkin> well, only fclabels :P
12:09:11 <PeakerWork> Cale: its the first point for (.)=fmap and against (.)=Control.Category.. I've seen yet, iiuc
12:09:25 <kmc_> so you can generalize either way but not both?
12:09:39 <Cale> kmc_: If you try to do both, it gets hairy quickly.
12:10:00 <Cale> But I won't say that it can't be done
12:10:01 <PeakerWork> Unless we use the Kleisli arrow around IO instead of IO then Category's (.) is fine
12:10:24 <kmc_> the Category one seems better
12:10:34 <thebloggu> PeakerWork, what does fmap really do? i couldn't understand it, sorry
12:10:35 <kmc_> it seems more fundamental that (->) is a Category than that ((->) a) is a Functor
12:10:40 <Cale> kmc_: Except how many decent instances of that class are there?
12:10:49 <kmc_> especially because "Functor" is really only "endofunctor of Hask"
12:11:02 <Cale> kmc_: If the Category class was really a good representation of what categories were, I would say go for it.
12:11:09 <kmc_> why isn't it?
12:11:19 <Cale> But instead, it's this weird thing of which there are not many instances
12:11:42 <Cale> It's not because the composition has to be a natural transfomation in the object types.
12:11:46 <PeakerWork> thebloggu: fmap applies a function inside a type constructor like IO.    f `fmap` someIOValue    applies f to the result of someIOValue.    For example,  fmap lets you modify  IO String   to    IO Int    if you give it a (String->Int)
12:11:51 <PeakerWork> @type (=<<)
12:11:51 <Cale> (because it's polymorphic)
12:11:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:11:57 <PeakerWork> @type liftM
12:11:59 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:12:27 <thebloggu> PeakerWork, hmm, i understand
12:12:58 <thebloggu> Peaker, thank you very very much as well as mauke and Cale
12:13:10 <thebloggu> PeakerWork, sorry
12:13:17 <PeakerWork> thebloggu: fmap=liftM, and its similar to =<<  except that fmap applies a pure function like (Int -> String) and doesn't add any new effect to the computation.   =<< requires the function to return an EFFECT and not a result, and then "sequences" or "fuses" that effect into the original effect
12:13:46 <thebloggu> PeakerWork, hmm, ok
12:13:50 <PeakerWork> thebloggu: so our (boolToInt . parse)  is (String -> Int)  and we use fmap to apply it to   IO String, which gives us   IO Int
12:14:12 <Cale> Another way to say that is that f =<< x is the program which runs x, then passes its result to f, and runs the result
12:14:50 <Cale> (so the result of f must be another action/program)
12:14:57 <thebloggu> PeakerWork, Cale ok
12:15:24 <thebloggu> Peaker, Cale mauke thank you very much once again :)
12:15:49 <thebloggu> PeakerWork, sorry once again :P
12:18:27 <PeakerWork> thebloggu: sorry about what? )
12:25:05 <stoop> Cale appreciation day.
12:25:42 <zygoloid> in #haskell every day is Cale appreciation day :)
12:25:46 <sproingie> Cale is good with mushrooms and some feta cheese
12:25:51 <sproingie> oh wait that's kale
12:28:59 <samnardoni> Hey, is this the best way to implement this (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11989#a11989)?
12:29:49 <jkff> Why do you need "Empty"?
12:30:19 <samnardoni> true
12:30:40 <samnardoni> the bit i don't like is...  entries (Dir _ x) = 1 + (sum $ map entries x)
12:30:47 <jkff> Why not?
12:30:59 <samnardoni> is there a way to do it as....  entries (Dir _ x:xs)    sort of way?
12:31:06 <jkff> Well, you may use some kind of generic programming, but that will only let you squeeze 2 lines to 1
12:31:19 <jkff> Why would you want to?
12:31:29 <samnardoni> i personally think it reads better
12:31:33 <chrisdone> do you think type classes are like a formal safe way to do duck typing?
12:31:51 <jkff> Explicit recursion nearly never reads better than usage of a recursive operator
12:32:03 <jkff> You're basically going to inline "sum"
12:32:18 <samnardoni> ahhh very true
12:32:42 <sohum> chrisdone: it isn't really ducktyping
12:32:42 <samnardoni> probably just cus i've been reading LYAH so much, and it's everywhere in there
12:32:56 <chrisdone> I'm trying to think of why hierarchical type systems are inflexible which was clear in my mind at work and now I seem to believe multiple inheritence solves any problems
12:33:09 <sohum> chrisdone: calling it anything not a member of the typeclass is disallowed at runtime
12:33:14 <sohum> *with
12:33:25 <jkff> count (File _) = 1; count (Dir _ xs) = 1+sum (count`map`xs)
12:33:31 <jkff> Probably that reads slightly better.
12:34:31 <Polarina> How do I find the square root of an Integer in an Integer, floored?
12:34:34 <chrisdone> sohum: quack :: (Wings a, Feathers a, Beak a) => a -> DuckAction a -- isn't this duck typing?
12:35:37 <jkff> Polarina: You mean that you need more precision than is available in floating-point types?
12:35:53 <Polarina> jkff: No.
12:35:58 <chrisdone> > floor . sqrt . fromIntegral $ 37
12:35:59 <lambdabot>   6
12:36:02 <Polarina> jkff: I don't want the part after the decimal point.
12:36:08 <jkff> Then convert to a floating-point type, take square root and truncate.
12:36:18 <Polarina> jkff: I need to handle large numbers.
12:36:42 <jkff> So large that floating-point types are not big enough to handle them with sufficient precision of the square root?
12:36:50 <byorgey> Polarina: there is some code here: http://haskell.org/haskellwiki/Lambda_lifting
12:37:02 <sohum> chrisdone: nope. it's related, but ducktyping is about implicit specification of required methods
12:37:10 <byorgey> the basic idea is to use a variant of newton's method, but only with integer arithmetic
12:37:36 <jkff> Funny that it is at a page on lambda lifting
12:37:48 <sohum> chrisdone: and I believe it's solely in the context of dynamic typing, where you don't bother checking type because when you call foo.quack your runtime system's going to throw an error anyway
12:38:23 <Polarina> byorgey: I cannot understand that code.
12:38:29 <sohum> chrisdone: haskell's static - you can't try to call a f foo, parse the error, determine what you want, and open f and add that method and then call f foo again
12:38:44 <jkff> Polarina: Well, you'll have to
12:39:02 <jkff> It uses only the basic syntax. What in particular is unclear?
12:39:08 <byorgey> Polarina: it starts by guessing  (n+1) `div` 2  as the square root pf n
12:39:23 <jkff> Try googling for "Newton's method square root"
12:39:28 <byorgey> Polarina: then it iterates the map   s -> (s + n/s)/2
12:39:33 <jkff> And then make parallels with the code
12:39:36 <byorgey> which converges to the square root of n
12:39:46 <Polarina> jkff: Parallels?
12:39:54 <jkff> Well.. Analogies
12:40:00 <Polarina> ?
12:40:00 <jkff> See how the code corresponds to the method.
12:40:20 <leimy_> What's the difference between manyTill and endBy?
12:41:10 <jkff> Polarina: You can try reading the chapter of SICP at http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.7
12:41:19 <jkff> :t endBy
12:41:21 <leimy_> ooh manyTill has a <|> in it.
12:41:21 <lambdabot> Not in scope: `endBy'
12:42:53 <chrisdone> sohum: well if you are going to restrict "duck typing" specifically to dynamic languages then my question is meaningless
12:42:57 <kmeyer> why is hlint telling me to use when instead of if? what's the difference?
12:43:13 <sohum> chrisdone: true. hm.
12:43:44 <sohum> lessee... chrisdone: "In computer programming with object-oriented programming languages, duck typing is a style of dynamic typing in which an object's current set of methods and properties determines the valid semantics, rather than its inheritance from a particular class or implementation of a specific interface"
12:43:57 <sohum> so yea, you have to make the distinction
12:44:08 <sohum> haskell's typeclasses are about specifying an interface
12:44:20 <jkff> kmeyer: Show the code where it complains
12:44:31 <sohum> ducktyping enables more namby pamby at runtime
12:44:34 <PeakerWork> does (,) have a Monoid instance?
12:44:40 <jkff> If it is like "if foo then bar else return ()", then that can be abbreviated to "when foo bar"
12:44:40 <PeakerWork> (a,b) of course
12:44:53 <chrisdone> sohum: nevermind
12:45:00 <copumpkin> PeakerWork: I believe so
12:45:07 <copumpkin> PeakerWork: if both a and b are monoid instances
12:45:10 <sohum> chrisdone: sorry?
12:45:12 <kmeyer> jkff: it's exactly that
12:45:17 <Vanadium> instance (Monoid a, Monoid b) => Monoid (a, b) -- Defined in Data.Monoid
12:45:27 <copumpkin> > (Sum 5, Product 7) `mappend` (Sum 7, Product 3)
12:45:28 <lambdabot>   (Sum {getSum = 12},Product {getProduct = 21})
12:46:36 <lispy> That created a record?
12:46:58 <lispy> :t Sum
12:46:59 <lambdabot> forall a. a -> Sum a
12:46:59 <copumpkin> Sum and Product are both defined with record syntax
12:47:00 <stoop> copumpkin, that's really cool.
12:47:27 <lispy> :k Sum
12:47:28 <lambdabot> * -> *
12:47:34 <copumpkin> but you can still construct elements of recordy types using regular constructor syntax
12:47:39 <copumpkin> stoop: :)
12:47:55 <sohum> > mappend (Sum 5) (Sum 10)
12:47:56 <lambdabot>   Sum {getSum = 15}
12:48:04 <sohum> > mappend (Product 5) (Product 10)
12:48:05 <lambdabot>   Product {getProduct = 50}
12:48:22 <copumpkin> > mconcat . map Sum . enumFromTo 1 $ 10
12:48:23 <lambdabot>   Sum {getSum = 55}
12:48:24 <lispy> > mappend (Sum 5) (Product 10) -- Oh no!
12:48:25 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum t'
12:48:25 <lambdabot>         against inferred t...
12:48:34 <copumpkin> > mconcat . map Product . enumFromTo 1 $ 10
12:48:35 <lambdabot>   Product {getProduct = 3628800}
12:48:42 <thebloggu> PeakerWork, mispelling your name :P
12:49:04 <PeakerWork> does (a, b) have a Monoid instance?
12:49:11 <copumpkin> yes
12:49:14 <PeakerWork> oh, sorry, I missed the response above
12:49:15 <copumpkin> > (Sum 5, Product 7) `mappend` (Sum 7, Product 3)
12:49:16 <lambdabot>   (Sum {getSum = 12},Product {getProduct = 21})
12:49:18 <copumpkin> :)
12:49:22 <PeakerWork> I thought my disc meant it was lost
12:49:27 <PeakerWork> cool, thanks
12:57:06 <Baughn> Shouldn't there be a function to look up the Nth element of a Data.Map?
12:57:13 <Baughn> From my reading of the source, it would be easy to write
12:57:16 <matthew-_> @seen drmaciver
12:57:17 <lambdabot> Unknown command, try @list
12:57:50 <Baughn> ..aand, I'm apparently blind. Yeah, there we go.
12:59:59 <Baughn> preflex: seen drmaciver
12:59:59 <preflex>  drmaciver was last seen on #haskell 39 days, 7 hours, 1 minute and 18 seconds ago, saying: Not that a basic amount of galois theory is hard to grasp
13:00:09 <Baughn> matthew-_: Good luck with that one.
13:01:01 <zygoloid> Baughn: (!!n) . toList? :)
13:01:02 * Baughn notes that Haskell makes a much better imperative, mutable-state language than any other he's used. STM FTW!
13:01:29 <Baughn> zygoloid: Since Map subtrees have attached sizes, the operation should be O(lg n). Which is what elemAt in fact is. ;)
13:01:30 <Vulpyne> findIndex.
13:01:32 <zygoloid> Baughn: ... until you want to do deep updates
13:01:49 <matthew-_> Baughn: ahh, I remember the days when λbot used to be helpful...
13:01:59 <Baughn> zygoloid: Not really. Lenses handle that nicely.
13:02:42 <zygoloid> Baughn: not if you have multiple references to the 'same' object that you want to update
13:02:45 <Baughn> zygoloid: Though I don't know if there are any specifically dealing with STM, I could make one at need. So far I haven't had a need; my data structures tend to be shallow, SQL-like structures of maps.
13:02:49 <zygoloid> (unless you scatter STRefs everywhere)
13:03:11 <tromp_> i wished ghc --help would mention the option to allow other module names than Main
13:03:15 <chrisdone> anyone use yasnippet for emacs? seriously recommended for increasing code producing speed
13:03:17 <tromp_> i can never remember:(
13:03:18 <Baughn> zygoloid: In that case, scatter TVars everywhere.
13:03:37 <Baughn> zygoloid: Specifically, the same TVar. It's probably bad design, but it's still better than java has.
13:03:38 <zygoloid> Baughn: then the code is uglier than typical imperative code in other languages, i find :(
13:03:53 <sproingie> chrisdone: yasnippet is real nice
13:04:28 <Twey> Why does Hackage no longer have docs?  :-\
13:04:43 <zygoloid> Baughn: basically my observation is that for the type of imperative programming i do in other languages, i'm much better off rephrasing the program into a functional one than trying to implement the imperative version in haskell
13:04:48 <Baughn> Twey: Does too?
13:05:07 <Twey> Baughn: http://hackage.haskell.org/package/dbus-core — no Haddock links on the modules…
13:05:20 <Baughn> zygoloid: That's fine in most cases. Unfortunately, my code is inherently IO-centric - lots of networking.
13:05:40 <sproingie> you can always write imperative code then break it out into functional bits
13:05:42 <Baughn> Twey: That's because it failed to build
13:05:50 <knobo> How can I benchmark this program to see where I need to improve the lazy evaluation? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11922#a11999
13:05:58 <zygoloid> Baughn: unlucky :(
13:05:58 <MyCatVerbs> zygoloid: Or putting the whole thing into the ST monad. ;)
13:05:59 <sproingie> the lovely thing about the type system means that such refactoring can rarely go wrong
13:06:07 <knobo> (head (colorMap theMap)) should be fast, but it's not.
13:06:07 <Baughn> zygoloid: It's *still* nicer than other languages
13:06:12 <sproingie> at least except for that you can blow up your heap with space leaks
13:06:27 <Twey> Baughn: Oo-er.  :-\
13:06:28 <Baughn> zygoloid: Writing fine-grained thread-safe code like this would barely even be *possible* without STM
13:06:44 <luite> knobo: compile with profiling, insert extra  cost centers where necessary
13:07:09 <chrisdone> hpaste is screwed up in opera
13:08:00 <zygoloid> Baughn: i've admittedly not tried much deeply-imperative stuff in haskell, but what i tried ended up messier and uglier than the equivalent thing in an imperative language
13:08:18 <Baughn> zygoloid: That could be why. :P
13:08:24 <zygoloid> Baughn: threading STRefs or TVars or whatever through my ADTs means i can't use them from pure code any more
13:08:41 <chrisdone> I wrote an ircd in ``idiomatic'' Haskell and it was imperative, and it was lovely
13:08:56 <zygoloid> chrisdone: can i see the code? maybe you can change my mind :)
13:08:57 <Baughn> zygoloid: It would. That's not how I do it..
13:09:22 <chrisdone> zygoloid: maybe...
13:09:39 <Baughn> zygoloid: I've got some semi-global state which is held in TVars, yes, but I try to avoid having TVars inside TVars if at all possible
13:09:49 <zygoloid> Baughn: right. tand that's why it doesn't resonate with me when people say haskell is a good imperative language
13:10:04 <zygoloid> Baughn: (because if you write code in a normal imperative style it ends up not-so-nice)
13:11:13 <chrisdone> zygoloid: well I don't have the ircd code anymore but I have an irc bouncer at least: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12000#a12000
13:11:14 <zygoloid> Baughn: what i have seen, and do think is true, is that haskell is a great language for writing mostly-pure code with some imperative bits
13:11:20 <knobo> it was actualy slow in ghci, but compiling it, then it's fast.
13:11:23 <chrisdone> I should really have used literate programming support instead of embedding comments
13:11:46 <luite> knobo: I guess the even the first element of that list requires lots of recursion
13:11:57 <chrisdone> I wrote that like a year ago so it's probably rubbish. but it was fun to write a complete program fully commented
13:11:57 <luite> knobo: ah that's often the case, optimization makes a huge difference
13:12:06 <copumpkin> preflex: seen luqui
13:12:06 <preflex>  luqui was last seen on #haskell 7 days and 2 minutes ago, saying: maybe that's the way to go
13:12:10 <chrisdone> it's very theraputic. no wonder Knuth's so damn relaxed all the time
13:12:28 <Twey> Heh
13:12:36 <luite> knobo: okNode may be slow, because notElem requires the program to check the whole list
13:12:43 <luite> knobo: and you have lots of calls to okNode
13:13:06 <Cale> One of the nice things about using Haskell as an imperative language is that IO actions are first class and you can write your own control structures.
13:13:37 <chrisdone> Cale: indeed. that's something I really miss when not in Haskell!
13:14:00 <knobo> luite: shouldnt' notElem just stop when it finds the first one?
13:14:41 <Cale> It totally makes up for the inconvenience of not having the notation where using an action as a parameter to a function will run the action first.
13:14:41 <luite> knobo: yes, but only if it does find one
13:14:56 <Cale> (and pass the result, like in most imperative languages)
13:14:58 <jlouis> knobo: sometimes, ghc --make -O2 really shines
13:15:22 <jlouis> It improves both space and time.
13:15:26 <zygoloid> chrisdone: i do have to admit, that code is nice and very readable :)
13:15:44 <Cale> If you are having problems with performance, first check that you're passing -O2 to the compiler, *then* look at the code and profile :)
13:15:47 <chrisdone> Cale: I really wish for a monadic form of `case' but I seem to be the only one. don't you get sick of writing notused <- action; case notused of Pattern actualusedvar -> ...
13:15:56 <luite> knobo: I think you might get better performance if you use a Data.Set for the graph and lookup of neighbours
13:16:11 <Cale> chrisdone: a bit, sometimes
13:16:19 <Cale> chrisdone: But mostly I'm used to it
13:16:41 <mauke> action >>= \case of ->
13:16:53 <luite> knobo: each time you get a node, you have to potentially search the whole list
13:17:05 <chrisdone> mauke: is that actually valid syntax?
13:17:11 <zygoloid> no
13:17:12 <mauke> chrisdone: no
13:17:13 <Cale> If leaving the scrutinee blank made a function, then that would be good
13:17:16 <chrisdone> ;_;
13:17:18 <mauke> I think lambdacase is a proposed extension
13:17:21 <Cale> I don't think I would like the \ there
13:17:25 <sohum> :t case
13:17:26 <lambdabot> parse error (possibly incorrect indentation)
13:17:26 <Cale> (syntax-wise)
13:17:42 <knobo> Cale: the point is not to get "fast enough" code, but to learn how to make it fast.
13:17:42 <sohum> case and if need to be functions, so we can liftM them.
13:17:45 <zygoloid> Cale: i think the proposal to write it \{pat1 -> foo; pat2 -> foo} is nicer
13:18:01 <kmc_> case as a function would require first-class patterns
13:18:04 <mauke> zygoloid: but that requires { }
13:18:07 <kmc_> which would be awesome but a fairly major extension
13:18:12 <zygoloid> mauke: sadly, yeah.
13:18:22 * Baughn wonders how to put the TID of a thread into a data structure passed to said thread
13:18:29 <Twey> First-class patterns would be awesome.
13:18:30 <Baughn> There should be some solution..
13:18:35 <Cale> Baughn: MVar it
13:18:36 <sohum> but first class patters would be awesome.
13:18:38 <zygoloid> Baughn: use teh power of teh lazy
13:18:41 <chrisdone> Baughn: blocking mvar?
13:18:41 <Baughn> Cale: Not that solution
13:18:50 <Baughn> Why does everyone suggest mvars? ;_;
13:18:54 <zygoloid> Baughn: mfix
13:19:00 <Baughn> Ooh
13:19:00 <Cale> Baughn: are you thinking of some weird fixpoint solution?
13:19:02 <Twey> Ooh, yes, the power of the lazy.
13:19:05 <Baughn> Cale: Yes.
13:19:06 <Baughn> @type mfix
13:19:07 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:19:22 <sohum> @instances MonadFix
13:19:23 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:19:31 <Twey> (retVal, threadID) <- makeThread threadID
13:19:34 <sohum> impressive.
13:19:40 <Baughn> Twey: That's legal?
13:19:41 <Twey> And makeThread returns its own ID
13:19:43 <Twey> Yeah
13:19:43 <sohum> > mfix Left
13:19:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:19:45 <lambdabot>    `GHC.Show.Show a'
13:19:45 <lambdabot>      a...
13:19:48 <Twey> Call-by-need FTW
13:19:54 <sohum> > mfix Left :: Either Char
13:19:55 <lambdabot>   `Data.Either.Either GHC.Types.Char' is not applied to enough type arguments...
13:19:57 <Twey> There was a post on it a while back… head-exploding stuff
13:20:00 <Cale> Uh, it is inside recursive do-notation
13:20:11 <Cale> Or in the new syntax, rec { ... }
13:20:12 <chrisdone> so.. mdo?
13:20:16 <Twey> No, without it too
13:20:17 <Baughn> mdo it is.
13:20:18 <Cale> yeah, mdo
13:20:36 <sohum> :t mfix Left
13:20:37 <lambdabot> forall a. (Error a) => Either a a
13:20:43 <thebloggu> PeakerWork, are you there?
13:20:45 <Baughn> Twey: I actually need to define the data structure I pass on the line after I pass it, so.. yeah. mdo.
13:20:46 <sohum> Error a?
13:20:49 <copumpkin> ugh
13:20:50 <sohum> :t mfix Right
13:20:51 <lambdabot> forall a a1. (Error a1) => Either a1 a
13:21:02 <copumpkin> I hate that instance :P
13:21:07 <Twey> http://obfuscatedcode.wordpress.com/2008/02/16/functional-pearl-trees/
13:21:09 <Twey> Here it is
13:21:26 <sohum> :t mfix Maybe
13:21:27 <lambdabot> Not in scope: data constructor `Maybe'
13:21:31 <sohum> :t mfix Just
13:21:32 <lambdabot> forall a. Maybe a
13:21:35 <sohum> bah at that.
13:21:38 <sohum> whoa
13:21:43 <Cale> Twey: where is the do-notation?
13:21:51 <copumpkin> sohum: looks useful, eh ;)
13:21:58 <chrisdone> > do x <- return $ 1 : x; return $ head x
13:21:59 <lambdabot>   Couldn't match expected type `[t]'
13:21:59 <lambdabot>         against inferred type `SimpleRef...
13:22:01 <Cale> Twey: I just see let...
13:22:04 <sohum> :t mfix Just :: Maybe Int
13:22:04 <lambdabot> Maybe Int
13:22:10 <sohum> > mfix Just :: Maybe Int
13:22:12 <chrisdone> bloody lambdabot and it's insane extensions
13:22:14 <lambdabot>   mueval-core: Time limit exceeded
13:22:24 <sohum> what did I just ask it to do?
13:22:35 <Twey> Cale: Ah, I see — that's what you meant :-\  Hmn.
13:22:52 <Cale> Twey: It takes some trickery to make do-notation recursive like let
13:23:00 <Cale> Twey: and that's what mdo/rec are.
13:23:03 <copumpkin> > case mfix Just of Nothing -> 5
13:23:04 <lambdabot>   * Exception: <interactive>:1:137-166: Non-exhaustive patterns in case
13:23:16 <sohum> :t mfix (1:)
13:23:17 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
13:23:17 <lambdabot>       Expected type: t
13:23:17 <lambdabot>       Inferred type: [t]
13:23:23 <Twey> Cale: *nod*
13:23:23 <PeakerWork> thebloggu: barely :)
13:23:34 <sohum> :t mfix return
13:23:35 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a
13:23:42 <sohum> :t mfix return :: [Int]
13:23:43 <lambdabot> [Int]
13:23:47 <sohum> > mfix return :: [Int]
13:23:51 <lambdabot>   mueval-core: Time limit exceeded
13:23:56 <thebloggu> Peaker, :P can you take a look at this? it only prints 1 not changing the resolution: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4879
13:24:05 <copumpkin> > mfix (\x -> x:[1])
13:24:09 <lambdabot>   mueval-core: Time limit exceeded
13:24:25 <idnar> @type mfix
13:24:27 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:25:11 <sohum> :t fix (1:)
13:25:12 <lambdabot> forall t. (Num t) => [t]
13:25:28 <zygoloid> Cale: is it just 'rec' or is it 'rec do' like 'rec proc'?
13:25:33 <sohum> my favourite way of getting an infinite one-numbered list ;)
13:25:51 <Cale> zygoloid: rec has a syntax similar to let inside a do-block
13:26:01 <Cale> except that you use <- instead of =
13:26:57 <Cale> It's coming in 6.12 :)
13:27:23 <zygoloid> Cale: ah, i see, it is just like rec inside proc, only i misrecalled how rec inside proc works :)
13:31:31 <chrisdone> fix squashes my brain every time I look into it. much like the abyss
13:32:47 <Baughn> p_l: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12003#a12003 <-- Escher, eat your heart out
13:32:59 <kmeyer> what's rec mean?
13:33:02 <kmeyer> record?
13:33:07 <Baughn> recursive
13:33:14 <Baughn> This is #haskell. rec means recursive. ;)
13:33:23 <knobo> getNode and getName has 33% of the time used.
13:33:32 <chrisdone> > take 10 $ fix (\x -> 1 : 1 : zipWith (+) x (tail x))
13:33:33 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
13:33:33 <kmeyer> ah
13:33:37 <kmeyer> :t rec
13:33:39 <lambdabot> Not in scope: `rec'
13:33:42 <kmeyer> hrm
13:34:04 <byorgey> kmeyer: it's a keyword, not a function
13:34:13 <chrisdone> that's the first thing Baughn showed me of Haskell
13:34:40 <kmeyer> byorgey: I see
13:35:12 <chrisdone> I'm just a simple c programmer, and Baughn gives me a taste of Haskell by showing me a lazy fibonacci definition
13:35:16 <kmeyer> :t fix
13:35:17 <lambdabot> forall a. (a -> a) -> a
13:35:22 <Baughn> chrisdone: It worked, didn't it?
13:35:22 * chrisdone shakes fist
13:35:43 <chrisdone> Baughn: haha. touché
13:35:47 <kmc_> @pl (\x -> 1 : 1 : zipWith (+) x (tail x))
13:35:48 <lambdabot> (1 :) . (1 :) . ap (zipWith (+)) tail
13:35:50 <Twey> I think that might be in the Gentle Introduction, isn't it?
13:36:01 <kmc_> > fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
13:36:02 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
13:36:08 <luite> knobo: doesn't really surprise me, you can replace the getNode function by a Data.Map lookup if you first convert the graph
13:36:40 <knobo> luite: if I use Data.Set?
13:36:58 <luite> knobo: if you use Data.Map :p
13:37:18 <Twey> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
13:37:19 <lambdabot> ap (. join id) (. join id)
13:37:22 <Twey> Woah
13:37:24 <Twey> Seriously?
13:37:28 <Twey> Point-free Y.
13:37:38 <knobo> aha,
13:37:58 <Twey> > ap (. join id) (. join id) $ error
13:37:59 <mauke> @unpl join id
13:37:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
13:38:00 <lambdabot> ((\ a -> a) >>= \ b -> b)
13:38:12 <mauke> (it's self apply)
13:38:12 <luite> knobo: you could map Name to [Name], or to Data.Set Name, and keep another Name -> Color map
13:38:19 <copumpkin> Twey: you probably just killed lambdabot :P
13:38:23 <thebloggu> Cale,  can you take a look at this? it only prints 1 not changing the resolution: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4871#a4879
13:38:25 <copumpkin> in a slow and painful way
13:38:39 <copumpkin> actually, that one looks fine
13:39:08 <leimy_> anyone know how to use ReadP?
13:39:20 <lilac> @type join id
13:39:22 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
13:39:22 <lambdabot>     Probable cause: `id' is applied to too few arguments
13:39:22 <lambdabot>     In the first argument of `join', namely `id'
13:39:32 <chrisdone> copumpkin: moar liek lambdabot killed Twey's unification amirite
13:39:43 <copumpkin> lol
13:40:01 <copumpkin> well, something very close to what he wrote is a pretty good way of DOSing lambdabot
13:40:06 <copumpkin> until someone restarts it
13:40:23 <Cale> uh, hang on, why are you using readProcessWithExitCode if you don't care about the exit code?
13:40:40 <PeakerWork> Cale: I think because readProcess mangles stdout and stderr
13:40:41 <Twey> copumpkin: Really?  o.@
13:40:46 <knobo> But it actualy looks like it is lazy enough, as when I do I compiled version of the program, and solving only one solution (with (head colorMap theMap)). It solves it in "real 0m0.052s"
13:40:48 <PeakerWork> Cale: at least, that's why I'd use it
13:40:55 <copumpkin> Twey: unless someone fixed it recently :)
13:41:06 <Cale> Oh, I see
13:41:55 <chrisdone> I found this in old code and I wonder why I thought it was a good idea:
13:41:55 <chrisdone> -- Nice monad utility
13:41:55 <chrisdone> (<>) = liftM2 (>>)
13:42:17 <Botje> :t liftM2 (>>)
13:42:18 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
13:42:27 <PeakerWork> chrisdone: that's really in Applicative
13:42:32 <Botje> it looks very .. funky
13:42:35 <PeakerWork> @type (*>)
13:42:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:42:48 <copumpkin> I can see it being useful for threading maybes through IO or something
13:42:50 <PeakerWork> @type liftA2 (*>)
13:42:51 <knobo> no, actualy full vs. head : 0.033 <-> 0.091
13:42:52 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Applicative f1) => f1 (f a) -> f1 (f b) -> f1 (f b)
13:43:05 <luite> knobo: I may not have looked at your code in enough detail, but if there are partial solutions that are used more than once (and shouldn't need to be recalculated), you can probably gain a lot more by using some memoization data structure (the compiler does not magically share or cache the results, at least in general)
13:43:43 <chrisdone> copumpkin: yeah I think so
13:43:54 <Cale> thebloggu: does select work?
13:43:55 <chrisdone> PeakerWork: that's a nicer generaller definition
13:46:23 <PeakerWork> chrisdone: yeah, I prefer to use liftA* over liftM* for generality, and (*>) over (>>)
13:46:35 <knobo> ok. Thank you luite :) atleast getNode could be memoized.
13:46:39 <PeakerWork> chrisdone: if you use those, its a sign you don't need transformers too, you can just compose the applicatives naturally
13:46:42 <Cale> thebloggu: maybe it's a problem with your xrandr command?
13:46:51 <chrisdone> PeakerWork: do you use fmap or <$>?
13:47:23 <knobo> So, I think I'm done with that project. Now over to something usefull :)
13:47:36 <lispy> Has anyone worked out a way to automatically add a local hoogle index whenever packages are cabal installed?
13:47:57 <lispy> I have hoogle installed, and GoA uses it
13:47:59 <PeakerWork> chrisdone: `fmap` normally, <$> only in the context of Applicatives
13:48:15 <c_wraith> :t (<$>)
13:48:16 <lispy> But, when I install things they don't get included in my local hoogle
13:48:17 <PeakerWork> chrisdone: I tend to consider <$> to be Applicative f => ... rather than Functor f => ..
13:48:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:48:32 <c_wraith> There's no additional restriction on <$> though
13:48:42 <chrisdone> c_wraith: yeah I think he means conceptually
13:49:02 <PeakerWork> Yeah, I feel that by introducing <$> I introduce the world of Applicatives, and if I'm not using them, it seems like an unnecessary price to pay... :)
13:49:24 <hyuma> hi all
13:49:28 <chrisdone> hi there
13:49:29 <PeakerWork> even the import...
13:49:34 <knobo> that I probably could do much faster in a language I know (:, but less funn ):
13:49:38 <lispy> dcoutts: is it possible to get cabal to run a custom action on every 'cabal install' or do I need something like a shell alias/function to make this work?
13:50:03 <jeltsch> PeakerWork: I consider <$> also a good replacement for fmap in the case of non-applicatives.
13:50:20 <hyuma> guys i need a little help please
13:50:26 <hyuma> I need to write a fuction that
13:50:37 * chrisdone looks at a haskell (hobby) code buffer and a c# (work) code buffer and sighs
13:50:51 <hyuma> applied to an interger n, count how many 1's in the binary conversion there are
13:50:53 <PeakerWork> jeltsch: not annoyed by the extra import? :)
13:51:08 <jeltsch> Not really. ☺
13:51:19 <PeakerWork> chrisdone: Haskell makes us all less motivated, and thus worse, programmers of other languages :-(
13:51:47 <chrisdone> hyuma: there is Data.Bits but I'm guessing if it's homework you need to do it manually
13:51:58 <Twey> Strategic comma-insertion!
13:52:22 <Twey> hyuma: Do you know how to convert a number's base?
13:52:33 <hyuma> yes this is my partial solution wait:
13:52:37 <jeltsch> hyuma: Split the problem. First, convert the integer to its bit representation, then count the 1s in that representation.
13:52:47 <chrisdone> PeakerWork: uh huh *sniffle* ;_;
13:52:56 <Cale> thebloggu: Are you sure you have an output called LVDS0?
13:53:00 <Twey> Easier, since converting the integer to its bit representation requires counting ones anyway.
13:53:18 <Twey> Or at least checking ones.  You just have to modify it slightly to count them as you go.
13:53:45 <jeltsch> Twey: But I would consider your approach bad style.
13:53:47 <mauke> > length . filter ('1' ==) . showIntAtBase 2 intToDigit 13 $ ""
13:53:49 <lambdabot>   3
13:53:53 <Twey> jeltsch: Why's that?
13:53:56 <jeltsch> Mine is more modular.
13:54:05 <Twey> True, but one pass is often nicer than two passes
13:54:11 <hyuma> chrisdone: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4880#a4880
13:54:17 <hyuma> jeltsch: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4880#a4880
13:54:20 <jeltsch> Twey: Why?
13:54:28 <hyuma> but doesn't work well
13:54:43 <Twey> In practice, I'd probably write your two passes, and then implement a single-pass special case.
13:54:50 <Twey> jeltsch: Performance
13:55:14 <jeltsch> Twey: Performance usually isn’t a problem because the two-pass thing will be optimized away, I think.
13:55:25 <jeltsch> Twey: Deforestation.
13:55:34 <Twey> Only if you return a list from the first function
13:55:44 <Twey> Oh, I suppose it would be a string anyway
13:55:50 <Twey> Yeah, go ahead, then :þ
13:57:12 <leimy_> hmmm is Parsec known to consume a lot of memory if it's running for a long time?
13:57:31 <lament> it's a Haskell program so... :)
13:57:33 <jeltsch> hyuma: I don’t understand the purpose of the last “`mod` 2”.
13:57:40 <leimy_> Wonerding if I should be using ReadP everywhere :-)
13:57:50 <leimy_> I just figured out how to write part of what I care about with it.
13:58:02 <aluink> where might I find a good explaination on the advantages of purely functional langages/programming?
13:58:17 <copumpkin> aluink: in here!
13:58:20 * aluink lacks google-fu to find his query
13:58:35 <hyuma> jetish: to apply recursive the division on the other n/2 value
13:58:36 <aluink> yes, but i'd like to share an article or something with a friend
13:59:00 <jeltsch> aluink: Classic text: http://haskell.org/haskellwiki/Introduction
13:59:01 <chrisdone> leimy_: I would guess memory would be consumed by the nested tries and temporary value constructions. I doubt the parse string itself is duplicated with it being pure...
13:59:17 <leimy_> right
13:59:36 <leimy_> At this point I'm thinking I've been going about the design of this part of the application the wrong way.
14:01:13 <jeltsch> aluink: And the introduction of Real World Haskell: http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
14:01:41 <hyuma> jeltsch: can you help me?
14:01:53 <hyuma> i don't understand what i'm wrong
14:02:43 <jeltsch> hyuma: What is your intention with this expression: ((n`div`2) `mod`2)
14:03:16 <jeltsch> hyuma: This gives you the second-last bit, doesn’t it?
14:03:25 <hyuma> yes
14:03:51 <jeltsch> Why do you apply count to the second-last bit only?
14:04:46 <hyuma> it must be recursive
14:04:56 <jeltsch> :-)
14:05:02 <hyuma> no
14:05:03 <hyuma> '
14:05:04 <hyuma> ?
14:05:29 <jeltsch> Did some instructor tell you that it must be recursive?
14:05:52 <m3ga> is there a web interface to the darcs repos on code.haskell.org?
14:06:32 <hyuma> yes when I call count on the rest of n/2
14:06:40 <ezracooper> hi folks; seems like installing GHC on Snow Leopard is surprisingly difficult. anyone try it before?
14:06:41 <jeltsch> hyuma: You have to count all the remaining 1s so you shouldn’t apply count to only one of them.
14:07:22 <jeltsch> hyuma: When you call count on the rest of n/2…?
14:07:39 <hyuma> count ((n`div`2) `mod`2) <---- here
14:07:48 <hyuma> n div 2 = n/2
14:07:54 * Baughn is annoyed by the prevalence of withFoo forms that do no actual deinitialization. withNetwork, withOpenSSL.. the list goes on
14:08:06 <hyuma> I can't use n/2 because function is Int -> Int
14:08:12 <hyuma> gave me error
14:08:15 <jeltsch> Of course.
14:08:21 <Vulpyne> x `div` 2
14:08:31 <Vulpyne> Or div x 2 if you prefer.
14:08:34 <m3ga> Baughn: +1
14:08:40 <hyuma> yes i use `
14:08:49 <copumpkin> okay, psykotic's bayes topos code is pretty neat
14:08:50 <kmc_> :t withForeignPtr
14:08:51 <lambdabot> Not in scope: `withForeignPtr'
14:09:04 <copumpkin> (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9423#a9423)
14:09:05 <Baughn> kmc_: Okay, so there are those that do, too
14:09:14 <kmc_> but that doesn't do deinitialization either
14:09:18 <kmc_> but it's still important
14:09:22 <Baughn> kmc_: WHich just adds to the annoyance. It's not good to encourage people to say "withFoo return".
14:09:47 <hyuma> jeltsch: i can't understand
14:10:28 <jeltsch> hyuma: You only count the number of 1s in the last two digits.
14:10:39 <Baughn> kmc_: If it doesn't do deinitialization.. seriously, what would've been wrong with newForeignPtr?
14:10:57 <kmc_> it's not that either
14:11:11 <kmc_> it takes a ForeignPtr and allows you to use it as a Ptr within a block of code
14:11:23 <Baughn> ..well, then.
14:11:25 <jeltsch> Don’t recursivery apply count to just the second-last digit but to a number with all remaining digits.
14:11:46 <PeakerWork> withForeignPtr does do something after the code (verifies its still reachable) but its not necessarily "deinitialization"
14:12:06 <Baughn> PeakerWork: It's still necessary for it to have that type, then.
14:12:11 <jeltsch> hyuma: It should be easy to calculate such a number.
14:12:23 <PeakerWork> Baughn: yeah. withOpenSSL/withNetwork theoretically finalize the network
14:12:24 * hackagebot upload: control-monad-failure 0.3 - A class for monads which can fail with an error. (PepeIborra)
14:12:36 <Baughn> PeakerWork: Yeah, but they actually /don't/
14:12:41 <PeakerWork> Baughn: I like that pattern. I want "forkIO" to be withForkIO too, so that people stop leaking threads
14:12:54 <jeltsch> hyuma: Especially, since I constantly asked you what the last `mod` 2 should be for.
14:12:57 <PeakerWork> Baughn: its good that they leave the option to finalize open :)
14:13:02 <PeakerWork> Baughn: in a new library version without breaking anyone
14:13:21 <kmc_> it annoyed me that it's not trivial to wait for a bunch of forkIO'd threads to finish
14:13:24 <kmc_> it's easy, but not trivial
14:13:26 <jeltsch> hyuma: Since this seems to be homework, I don’t wanna give more hints.
14:13:26 * hackagebot upload: monadloc 0.5 - A class for monads which can keep a monadic call trace (PepeIborra)
14:13:38 <Vulpyne> hyuma: One of the easiest ways would be to take 2 arguments, one is the value, one is the number of bits and just recurse dividing the value by 2 each time and adding value `mod` 2 to the counter each time until the value is 0.
14:13:41 <jeltsch> hyuma: And I have to go to bed.
14:13:42 <Baughn> PeakerWork: True, but in that case they should just have both with_ and start_ variants
14:13:57 <jeltsch> Vulpyne: Not easy.
14:14:01 <Baughn> PeakerWork: Most of the time I don't ever want to shut down the network
14:14:38 <hyuma> Vulpyne: is what my function do
14:14:52 <hyuma> but I need to do with only 1 argument
14:14:54 <PeakerWork> Baughn: withNetwork on the whole program then?
14:14:59 <Baughn> PeakerWork: Oh, and withForkIO (inThread? forked?), how would you deal with a situation where an IO Context function needs to create a maintenance thread whose ID should just be stuck in the Context?
14:15:12 <Baughn> PeakerWork: Doesn't work too well in GHCi. :P
14:15:22 <jeltsch> Vulpyne: hyuma’s approach is better: no accumulator argument, increment during “going up”, out of the recursion.
14:15:30 <Vulpyne> hyuma: myfunc arg1 = let helper harg1 harg2 in helper arg1 20
14:15:35 <PeakerWork> Baughn: you could still have normal forkIO for cases like that
14:15:44 <Vulpyne> hyuma: As an example of using a helper function that may need more arguments.
14:15:44 <Baughn> PeakerWork: Okay, then
14:16:09 <Vulpyne> jeltsch: I didn't see his approach.
14:16:22 <hyuma> this Vulpyne
14:16:23 <hyuma> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4880#a4880
14:16:27 <Baughn> PeakerWork: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12003 <-- Incidentally, I like that Haskell lets me do this. Pay close attention to the what is passed to that runReaderT. :)
14:17:03 <jeltsch> Vulpyne: hyuma at 22:54:16: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4880#a4880
14:17:27 <dcoutts> lispy: there's no support yet for regenerating a hoogle index but it should be easy to add, it's pretty similar to the support for maintaining the haddock index.
14:17:28 <Baughn> PeakerWork: (Oh, and haskell-mode now supports mdo. It's good to be the king.)
14:17:50 <dcoutts> lispy: we accept patches :-)
14:18:39 <jeltsch> hyuma, Vulpyne: Okay, good night.
14:18:48 <Vulpyne> hyuma: If you `mod` 2 when you recurse into count, then you're only going to call count with a 0 or 1.
14:19:02 <hyuma> night jeltsch
14:19:02 <Vulpyne> jeltsch: You were right about his version being better. See you.
14:19:26 <lispy> dcoutts: Sure :)  Right now I'm just trying to figure out if this is a solved problem.
14:19:34 <hyuma> Vulpyne i don't udnerstand :s
14:20:01 <hyuma> i need fresh air
14:20:08 <Vulpyne> Let's say you do "count 200"
14:21:14 <Vulpyne> The first step of that is going to evaluate to: (200 `mod` 2) + count ((200 `div` 2) `mod` 2) --> 0 + count 0
14:21:46 <Vulpyne> And recursion will stop.
14:21:59 <hyuma> yes because find 0
14:22:03 <hyuma> maybe base case is wrong
14:22:09 <hyuma> need other
14:22:15 <Vulpyne> What purpose is the last `mod` 2 serving?
14:22:35 <hyuma> to continue recursion on n/2
14:22:44 <Vulpyne> `mod` 2 isn't the same as /2
14:22:52 <PeakerWork> Baughn: btw, the indentation mode thing annoys me because it doesn't put the name of the function when you <tab>
14:22:56 <PeakerWork> Baughn: like the old one did
14:22:56 <Vulpyne> The `div` 2 is accomplishing that part.
14:23:05 <PeakerWork> Baughn: the old one put it and then disappeared it if you tabbed again that was nice
14:23:17 <Baughn> PeakerWork: That would be nice, yes. Give me time. :)
14:23:21 <Vulpyne> Without the `mod` 2 you would be calling count with (200 `div` 2)
14:23:26 <hyuma> Vulpyne: n div 2 is like n/2 right?
14:23:31 <Vulpyne> Yes.
14:23:36 <hyuma> ok so i apply
14:23:37 <Vulpyne> I was talking about the mod.
14:23:39 <hyuma> n/2 mod 2
14:23:42 <Baughn> PeakerWork: I fully intend to make this one obviously superior in every way, even if I have to break the old one to do it.
14:23:44 <mauke> hyuma: WHY
14:24:04 <dcoutts> lispy: the first problem is to generate and install the hoogle files
14:24:20 <dcoutts> lispy: then re-generating a combined index is easy
14:24:36 <Vulpyne> hyuma: The question is, what was your reasoning for the *second* `mod`2. The first one makes sense.
14:24:39 <hyuma> mauke: because i need apply the mod on the rest
14:24:46 <mauke> hyuma: no, you don't
14:24:51 <dcoutts> lispy: I don't think a shell alias/wrapper will help much with the first problem and once you've solved the first then the second is easy.
14:24:52 <Vulpyne> hyuma: What does the mod do?
14:25:05 <hyuma> mod give me the rest
14:25:18 <glguy> dcoutts has quit (reason: K-line: "we accept patches")
14:25:20 <Vulpyne> x `mod` 2 is going to ensure that it's either a 0 or a 1.
14:25:28 <dcoutts> glguy: heh :-)
14:25:30 <hyuma> yes
14:25:33 <Vulpyne> Can your function ever work if you only call it again with a 0 or 1?
14:26:58 <dcoutts> lispy: my suggestion is to persuade your colleagues that these productivity things are worth spending IHG money on ;-)
14:27:04 <dcoutts> lispy: or send patches of course
14:27:05 <Saizan> dcoutts: a limiting factor is that we usually don't have hoogle files nor a way to produce them for core libs, unlike haddock interfaces
14:27:07 * leimy_ is wondering where the garbage collector went.  It also seems to be quite lazy in my code.
14:27:18 <dcoutts> Saizan: indeed.
14:27:36 <Baughn> leimy_: Haskell is a lazy language, so a lazy garbage collector is only to be expected. It'll do its work whenever you're low on memory.
14:27:39 <dcoutts> Saizan: my preferred design would not have separate hoogle and haddock files
14:27:55 <leimy_> Baughn: I'd like to tell it I'm low on memory a lot.
14:27:56 <copumpkin> leimy_: it's on strike
14:28:01 <hyuma> Vulpyne: with 0 i suppose
14:28:04 <lispy> dcoutts: There has been discussion of how much to fund this, etc
14:28:06 <leimy_> so Should i just decrease heap size and see if my program crashes?
14:28:10 <dcoutts> Saizan: we should have one tool, probably rather tightly integrated with ghc (like haddock is now) that extracts the API and machine readable documentation.
14:28:15 <Vulpyne> hyuma: But it has to work with whatever number you give it. :)
14:28:19 <lispy> dcoutts: but the previous proposal was not as easy as this one ( I think )
14:28:27 <Baughn> leimy_: You could do that. There are also options to initiate collections more frequently, which may be preferable.
14:28:34 <Vulpyne> So if you can only pass it a 1 or 0, the maximum it could ever recurse is 3 iterations (with the last one terminating it and not doing anything.)
14:28:34 <dcoutts> Saizan: then haddock, hoogle, tags etc would read those and produce various format output
14:28:35 <leimy_> how do you do that?
14:28:38 <lispy> dcoutts: the other proposal involved parsing .hi files
14:28:42 <Vulpyne> hyuma: So there's no way that could work.
14:28:42 <hyuma> Vulpyne: dunno how
14:28:45 <leimy_> looking for RTS flags I suppose
14:28:51 <Baughn> leimy_: +RTS --help
14:28:56 <leimy_> well dang
14:29:03 <dcoutts> lispy: what previous proposal?
14:29:19 <lispy> Saizan: according to the hoogle docks you can cabal haddock --hoogle
14:29:25 <Vulpyne> hyuma: When you do `mod` 2 you are getting the value of the lowest bit. When you do `div` 2, you are shifting everything right 1 bit.
14:29:27 <lispy> Saizan:  and get a hoogle index file
14:29:38 <Saizan> lispy: not for alredy installed libraries
14:29:48 <lispy> dcoutts: I don't think it was published.  The goal is the same, just the way to do it was totally different
14:30:01 <Saizan> lispy: i'm thinking of base, containers, etc.. that come with ghc
14:30:17 <lispy> Saizan: so, cabal haddock them :)
14:30:18 <dcoutts> lispy: yes you can run cabal haddock --hoogle, but there's no way to say "do this for all my packages and install the hoogle file"
14:30:30 <Vulpyne> hyuma: So, what you want to do is: count x = lowest_bit_value x + count (shift_right x) -- Correct?
14:30:42 <lispy> dcoutts: right.  So that's why I started with asking about scripts that already do it :)
14:30:48 <dcoutts> Saizan: you see what I mean with the design I'm suggesting?
14:30:49 <Vulpyne> And of course also exit once you have run out of bits, ie x is 0.
14:30:57 <Saizan> lispy: yeah, the easy way out is to tweak the ghc build system
14:31:01 <Saizan> dcoutts: yup
14:31:07 <dcoutts> lispy: I'd suggest doing it properly rather than hacking scripts
14:31:16 <hyuma> otherwise = (n`div`2) + count ((n`div`2) `mod`2)
14:31:20 <Saizan> dcoutts: it'll double as the source of the data for sanity checking hackage
14:31:35 <dcoutts> Saizan: right, that's the easy way out but of course then people will ask for the same for ctags, etc etc
14:31:39 <lispy> dcoutts: implementation details :-)
14:31:46 <Vulpyne> lowest_bit_value x + count (lowest_bit_value (shift_right x)) -- Does that make sense?
14:31:59 <dcoutts> Saizan: yes, that too
14:32:21 <dcoutts> Saizan: and perhaps for online docs in IDEs or ghci
14:32:43 <dcoutts> the way to do it should be to cleave haddock in two
14:33:03 <Vulpyne> It sounds more dramatic if you say "CLEAVE HADDOCK IN TWAIN!"
14:33:24 <dcoutts> then smoke it, and have it for breakfast
14:33:49 <chrisdone> it needs to do way instain document. because it can't frith back?
14:34:30 <Vulpyne> Frigth.
14:35:02 <thebloggu> Cale, yes,no,yes :)
14:38:19 <fxr> what is the meaning of this class declaration "class VarsToExps v e | v -> e, e -> v where ..."?
14:38:21 <copumpkin> chrisdone: was that in the news this mroing a mother in ar? I must have miss it
14:38:37 <copumpkin> fxr: for any value of v, there is one value of e, and vice versa
14:38:50 <fxr> hmm
14:38:51 <copumpkin> basically making it a bijection
14:39:15 <Saizan> VarsToExps is a bijection at the typelevel yup
14:39:29 <Saizan> the things after the | are called functional dependencies
14:39:35 <BONUS> of course, the value here is a type
14:39:58 <copumpkin> which are values of kinds
14:40:37 <fxr> hmm, I'm trying to declare a function which gets a string and a function, using hjscript but couldn't figure out the types...
14:43:32 <fxr> I think it's not easy to express such a function "var fun = function (a, callback) {...}" in hjavascript syntax
14:45:03 <copumpkin> wow, this is pretty intense: (Relation r2, Topos m t, Eq b1, Relation r1, Eq b, Eq a, Relation r) => r m a b -> r1 m b b1 -> r2 m a b1
14:45:23 <copumpkin> we need a topos-extras next
14:45:31 <leimy_> Hmm looks like I must have some kind of bug in my app, as it does not appear that it wants to do garbage collection, it would rather grow or die :-)
14:45:57 <Vulpyne> fxr: http://hackage.haskell.org/packages/archive/HJScript/0.4.4/doc/html/src/HJScript-Ajax.html
14:46:09 <Vulpyne> fxr: Does that help at all? (First function defined there seems to take a callback.)
14:46:14 <byorgey> copumpkin: wow.
14:46:39 <copumpkin> byorgey: unsurprisingly, that's the work of psykotic :P
14:46:46 <Saizan> leimy_: what structures are you allocating? foreign pointers don't trigger the GC
14:46:51 <copumpkin> byorgey: it's pretty interesting, I'm still trying to soak it in
14:47:03 <leimy_> Saizan: as far as I know, there's no foreign pointers
14:47:30 <leimy_> I've got predominantly list structures according to the profiling I'm doing
14:47:37 <leimy_> lots of ":" going on
14:47:38 <fxr> Vulpyne: yeah it get's a callback in haskell side, I wanna declare a function which get's callback in javascript side...
14:47:52 <byorgey> copumpkin: what are the definitions of Relation and Topos?
14:48:06 <copumpkin> byorgey: the whole thing is in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9423#a9423
14:48:09 <Vulpyne> fxr: I'm afraid I've never used hjscript, so I don't know.
14:48:17 <leimy_> The surprising areas of growth are in a parser sub-function that takes input from an earlier stage of parsing, and updates it.
14:48:21 <leimy_> That's probably a mistake.
14:48:26 <leimy_> but it's growing a lot
14:48:33 <fxr> Vulpyne: thanks anyway
14:49:27 <leimy_> Basically I have a Data.Map in a State monad that does some IO
14:49:37 <leimy_> And I loop around, polling a device, updating the Data.Map
14:49:41 <leimy_> there's maybe 22 entries in the map
14:49:55 <leimy_> but each field is a string.  The strings are no more than like 8 characters each
14:50:12 <leimy_> I don't ask for the value of anything in the map except interactively with the program
14:50:32 <leimy_> this leaves me awfully uncertain as to what the heck is going on :-)
14:53:03 <leimy_> actually I take it back... I do access the map regularly :-(
14:54:21 <siki> Sorry for the spam, but anyone out there looking for a job in NYC where you can use Haskell? ps: I'm not a recruiter.
14:54:59 <copumpkin> oh my, haskell jobs
14:55:10 <copumpkin> siki: have you tried haskell-cafe by the way?
14:55:20 <lament> probably a bunch of people, and a bunch more people would move to NYC for it :)
14:55:23 <siki> yes I have. no response.
14:55:38 <gOcOOl> can someone tell me what exactly does this annotation do? {-# LANGUAGE OverloadedStrings #-}
14:55:40 <copumpkin> siki: oh wow, I'd think people would be jumping at the opportunity :)
14:55:47 <copumpkin> gOcOOl: it means that "abc" is no longer [Char]
14:55:52 <copumpkin> but is IsString a => a
14:56:06 <ivanm> copumpkin: oh, same as 1 :: (Num a) => a ?
14:56:10 <copumpkin> yep
14:56:24 <siki> yeah me too. but got nothing. I think it would be a great opportunity for the right person.
14:56:30 <kmc_> http://www.haskell.org/pipermail/haskell-cafe/2009-September/066956.html ?
14:56:35 <JohnnyL> lament i'm from ny.
14:56:37 <JohnnyL> :)
14:56:41 <kmc_> Java is not an acronym
14:57:08 <gOcOOl> copumpkin: so it means that "abc is no longer than a list of 3 chars? is that what it is?
14:57:27 <siki> kmc_: that's it.
14:57:30 <copumpkin> gOcOOl: it allows you to use string literals (like "abc") for other types
14:57:42 <ivanm> gOcOOl: other string-like types
14:57:43 <kmc_> also that makes it sound like a Java dev job with some vague promise of "you might use Haskell eventually"
14:57:46 <ivanm> copumpkin: like Bytestring?
14:57:55 <copumpkin> ivanm: yep, or Text (potentially)
14:58:00 <copumpkin> I hate the name of that typeclass
14:58:05 <ivanm> heh
14:58:16 <ivanm> copumpkin: oh wise master of the gourds, what would you have called it?
14:58:23 <lament> kmc_: probably the effect would have been better if HASKELL was capitalized instead
14:58:27 <kmc_> haha
14:58:40 <copumpkin> ivanm: Strang
14:58:43 <siki> not really. I'm the only developer and I use Haskell. but we just started with that and most of our existing code is written in Java so that needs to be maintained and added to as well.
14:58:44 <ivanm> heh
14:58:48 <copumpkin> Stryng
14:59:01 <ivanm> String-y ?
14:59:01 <kmc_> GString
14:59:04 <kmc_> (generalized string)
14:59:10 <ivanm> heh
14:59:13 <copumpkin> lol
14:59:32 <copumpkin> class Thong a where fromString :: String -> a
15:00:10 <kmc_> Strïng
15:00:57 <Saizan> siki: maybe reply clarifying that
15:01:17 <dancor> JAVA: acronyms very awkwardly
15:01:36 <ivanm> heh
15:01:37 <shepheb> Just A Verbose Artifice?
15:02:00 <sproingie> Just Another Verbose Aggravation
15:02:04 <shepheb> latter A could use some work
15:02:23 <m0nkfish> 'annoyance
15:02:23 <shepheb> sproingie: ooh, better
15:02:30 <lament> Java: Apparently, Viable Acronym
15:02:32 <sproingie> Annoyance, Abomination
15:02:43 <dancor> i'm not contributing to your acronym in progress without license information
15:03:07 <dancor> and if you are using a license without an acronym, well god help you
15:03:21 <ivanm> heh
15:03:35 <ivanm> dancor: do you mean an acronym without a license?
15:03:45 <sproingie> it's GPL4.  if you use any of the words in the acronym, you have to have RMS come over and sing the free software song at the birthdays of your children and your childrens children
15:03:53 <lament> dancor: IANALBXRPNXRQHTNSURCGFXHTDO
15:04:12 <ivanm> sproingie: at your expense?
15:04:26 <sproingie> of course
15:04:28 <ivanm> that must be tough on RMS with all the constant flying, etc.
15:04:41 <kmc_> that's the life of a software hobo
15:04:42 <dancor> it will certainly be at the expense of the children's social lives
15:05:04 <sproingie> "daddy make the hairy man go away:
15:05:04 <kmc_> he came to talk at my school, and was much more interested in the free food we gave him than in the talk he was supposed to give
15:05:04 <Axman6> gah, not more RMS talk >_<
15:05:09 <dancor> rm rms
15:05:10 <siki> Listen guys, the job description might be too Java specific I agree, but I just wanted to convey in the post that there'll be a fair amount of Java involved as well. But being a small firm, eg you would be the 2nd developer you have a lot of freedom in what to use and right now we're going in the direction of Haskell.
15:05:18 <kmc_> i bet the CS department drew straws to see whose desk he'd sleep under that night
15:06:01 <kmc_> siki, i think the point that there's only one dev is important, and you might want to say something to that effect in the ad
15:06:10 <ivanm> Axman6: what, had a bad experience?
15:06:20 <Axman6> just last night, twice
15:06:22 <Axman6> >_<
15:06:32 <kmc_> in a company with a lot of devs who know a language, it's hard to make the business case for introducing an unknown language, even when there's a strong technical case
15:07:03 <gOcOOl> is there a way to sort a pair in *decreasing* order here: "sortBy (comparing snd)" without calling "reverse" on the result set?
15:07:15 <kmc_> @hoogle Ordering -> Ordering
15:07:16 <lambdabot> Prelude pred :: Enum a => a -> a
15:07:16 <lambdabot> Prelude succ :: Enum a => a -> a
15:07:16 <lambdabot> Prelude id :: a -> a
15:07:18 <glguy> gOcOOl, flip (comparing snd)
15:07:27 <kmc_> ha, nice
15:07:32 <siki> kmc_: should I just repost it or reply to the old post?
15:07:37 <kmc_> *shrug*
15:07:40 <kmc_> the old post is old
15:07:53 <kmc_> i dunno i'm just some random guy, no reason to listen to me
15:08:22 <Polarina> Is there a Haskell binding for C#?
15:08:48 <skorpan> Polarina: http://www.haskell.org/haskellwiki/Salsa#C.23_in_Haskell
15:10:10 <Saizan> http://hackage.haskell.org/package/hs-dotnet <- also
15:10:36 <skorpan> i just googled for haskell .net :P
15:11:14 <Polarina> skorpan: And the other way around? That is, C# invokes Haskell.
15:11:33 <jorick> how do i clear out a handle of possibly waiting input? i'm using a hReady and hGetChar loop now ... or is there a way to abstract out this while loop?
15:11:54 <skorpan> Polarina: no idea
15:12:19 <gOcOOl> glguy: don;t think I completely understand that. so if i have: let x = [("foo", 3), ("bar", 2), ("baz", 4)]
15:12:40 <gOcOOl> sortBy (comparing snd) x returns increasing order
15:12:55 <skorpan> comparing is so awesome
15:13:01 <skorpan> :t comparing
15:13:03 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
15:13:19 <glguy> gOcOOl, so you use "flip (comparing snd)" instead
15:13:36 <Axman6> :t flip . comparing . snd
15:13:37 <lambdabot> forall b a a1. (Ord a) => (a1, b -> a) -> b -> b -> Ordering
15:13:41 <glguy> > sortBy (flip (comparing snd)) [("foo", 3), ("bar", 2), ("baz", 4)]
15:13:43 <lambdabot>   [("baz",4),("foo",3),("bar",2)]
15:13:43 <Axman6> maybe not...
15:13:47 <centrinia> > sortBy (on (flip comparing) snd) [("foo", 3), ("bar", 2), ("baz", 4)]
15:13:49 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> a
15:14:05 <centrinia> > sortBy (on (flip compare) snd) [("foo", 3), ("bar", 2), ("baz", 4)]
15:14:07 <lambdabot>   [("baz",4),("foo",3),("bar",2)]
15:14:13 <centrinia> > sortBy (on (compare) snd) [("foo", 3), ("bar", 2), ("baz", 4)]
15:14:13 <skorpan> :t flip `fmap` (comparing . snd)
15:14:15 <lambdabot>   [("bar",2),("foo",3),("baz",4)]
15:14:15 <lambdabot> forall b a a1. (Ord a) => (a1, b -> a) -> b -> b -> Ordering
15:14:30 <glguy> You guys need point-free rehab
15:14:38 <glguy> gOcOOl, did you see my example?
15:14:39 <Axman6> no!
15:14:51 <Axman6> unless... you mean they need less pointfree...
15:14:55 <centrinia> @unpl on (flip comparing) snd
15:14:56 <lambdabot> on (\ b c -> comparing c b) snd
15:14:56 <Axman6> then, yes!
15:15:43 <dancor> > sortBy (comparing snd) [("foo", 3), ("bar", 2), ("baz", 4)]
15:15:44 <lambdabot>   [("bar",2),("foo",3),("baz",4)]
15:15:59 <sproingie> @pointy flip `fmap` (comparing . snd)
15:16:00 <lambdabot> (fmap (\ a b c -> a c b) (\ f -> comparing (snd f)))
15:16:05 <sproingie> ew
15:16:59 <dancor> is there a not for Ord
15:17:07 <dancor> might be clearest to do that?
15:17:46 <Saizan> "flip compare `on` snd" looks pretty clear
15:18:18 <dancor> @let reverseOrd o = case o of LT -> GT; GT -> LT; EQ -> EQ
15:18:20 <lambdabot>  Defined.
15:18:29 <gOcOOl> glguy: yes. i was just pklaying around with it on ghci to see how exactly that works, it makes sense now.
15:19:06 <gOcOOl> (comparing snd) takes 2 pairs and returns an ordering on it
15:19:37 <gOcOOl> i'm guessing (flip (comparing snd)) takes 2 pairs in the reverse order and returns an ordering on them
15:21:22 <dancor> > sortBy ((reverseOrd .) . comparing snd) [("foo", 3), ("bar", 2), ("baz", 4)]
15:21:24 <lambdabot>   [("baz",4),("foo",3),("bar",2)]
15:23:43 <dancor> it's kind of lame for (comparing), which has no reason to exist if you accept (compare `on`), to need to revert to (compare `on`) to get to (flip compare `on` snd) for this simple request
15:24:15 <dancor> comparing comes off as uncomposable and overspecific
15:24:26 <Kruppe> I'm looking to fiddle around with genetic programming, can anyone recommend a data structure/type for representing simple programs/functions?
15:25:14 <Vulpyne> Kruppe: http://en.wikipedia.org/wiki/Brainfuck :)
15:25:50 <Kruppe> Vulpyne: maaaaaaaaaaaaaybe not
15:25:58 <jlouis> Lambda calculus is also a possibility
15:25:59 <Kruppe> Vulpyne: might just use lisp
15:26:03 <Vulpyne> Kruppe: http://hackage.haskell.org/package/hgalib
15:26:07 <jlouis> and Neil Jones WHILE
15:26:17 <Vulpyne> Kruppe: http://www.haskell.org/haskellwiki/Applications_and_libraries/Genetic_programming
15:26:47 <Vulpyne> Kruppe: You could make a DSL representing BF and manipulate it quite easily, but it's probably not that great for GA.
15:27:20 <jlouis> Kruppe: WHILE is described in http://www.diku.dk/~neil/comp2book2007/book-whole.pdf -- you might like it if you like lisp
15:27:30 <jlouis> page 29
15:28:13 <Kruppe> Vulpyne, jlouis, thanks for the suggestions, I'll check those out
15:35:33 <damkor> hi, I'm having a problem creating an msi with bamse: when I set the target of a shortcut, it points to the path of the file in my machine, instead of targetdir. Any clues?
15:36:39 <dancor> you may as well use Forth instead of BF at least
15:38:32 <SimonRC> dancor: ??
15:38:53 <SimonRC> dancor: I understood that second one, but it doesn't make sense in context]
15:39:44 <dancor> SimonRC: i came in late, but when they were recommending brainfuck for genetic programming,
15:39:59 <dancor> it seemed like you might as well use a more serious minimal lang
15:40:25 <SimonRC> actually, something more robust would be a better choice, like some form of scheme
15:40:34 <SimonRC> I think scheme has actualyl been used for such
15:40:43 <dancor> ya
15:43:13 * SimonRC goes
15:43:58 <jlouis> scheme is a good choice as well
15:46:03 <lament> as i understand, nothing is a really good choice for genetic programming, because genetic programming just isn't such a great idea
15:50:35 <Giarome> hi
15:50:53 <Giarome> i need help!
15:50:53 <Giarome> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=12005#a12005
15:51:29 <Giarome> i get error
15:51:30 <glguy> Giarome, your two definitions of del overlap
15:52:53 <byorgey> Giarome: you will have to say something like   del (a,xs) | a == x = ...    | otherwise = ...
15:53:14 <byorgey> Giarome: I see what you're trying to do, but you can't test in a pattern whether the first thing is equal to x
15:53:27 <byorgey> it just makes a new name x which shadows the old one
15:53:52 <byorgey> Giarome: also, [xs] is a pattern which only matches lists with a single element, is that really what you mean?
15:54:05 <Strangerr> HASKELL IS SHITTER THAN SHIT
15:54:07 <Strangerr> TRUTH
15:54:10 <Strangerr> FUCK IT'S SO FUCKING BAD
15:54:13 <Strangerr> HOLY SHIT
15:54:16 --- mode: ChanServ set +o glguy
15:54:20 <FauxFaux> The man has a point.
15:54:21 --- mode: glguy set +b *!*n=usesec@*.dynamic.swissvpn.net
15:54:21 --- kick: Strangerr was kicked by glguy (glguy)
15:54:23 <jmcarthur> :)
15:54:26 <Giarome> cannot construct infinity type [a]
15:54:39 <FauxFaux> See, Giarome has just found one of my favourite errors.
15:55:03 --- mode: glguy set +b *!*@80-254-73-139.dynamic.swissvpn.net
15:55:05 --- mode: glguy set -o glguy
15:55:13 <byorgey> Giarome: what does your code look like now?  have you fixed the things glguy and I pointed out?
15:55:25 <Giarome> yes
15:55:37 <byorgey> ok, can you paste the new version?
15:55:42 <jlouis> inifity type is the occurs check?
15:55:48 <byorgey> oh, you already did
15:55:49 <Giarome> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=12005#a12005
15:56:00 <byorgey> jlouis: yes.
15:56:09 <jlouis> infinity, better lrn2spell :)
15:56:15 <jlouis> byorgey: okie. Thanks.
15:56:25 <byorgey> Giarome: you still have [as] which only matches lists with a single element
15:56:42 <byorgey> Giarome: I think you mean to have just  as
15:57:01 <byorgey> since you later use 'as'  as if it is a list
15:57:03 <jlouis> I am falling more and more in love with dependent types. Any chance of Haskell getting those without nasty hacks?
15:58:11 <byorgey> jlouis: pretty much no chance of Haskell getting full-out dependent types. However, there is lots of work on getting as much dependence into the type system as possible.
15:58:13 <Giarome> thx guys
15:58:39 <byorgey> for example, GADTs, and see Conor McBride's recent work on the Strathclyde Haskell Extension, etc.
15:58:44 <jlouis> byorgey: due to termination of the type checker?
15:58:46 <Giarome> but still got the infinity type error
15:59:19 <byorgey> jlouis: well, termination is one issue; more important, I think, is the issue of type inference.
15:59:22 <jlouis> byorgey: I definitely need to check GADTs out some more. They seem to give much of the pleasantry of lambda-P and friends
15:59:29 <jlouis> byorgey: oh, yes
15:59:46 <byorgey> full-out dependent types pretty much means type inference goes out the window.  and Haskellers do love their type inference so.
15:59:55 <jlouis> yeah
16:00:20 <tommd> Wahoo.  Converting Haskellers one at a time via parMap.
16:01:02 <byorgey> Giarome: hmm, can you paste what the code looks like now?
16:01:49 <idnar> tommd: shouldn't you be doing more than one at a time with parMap?
16:01:58 <Giarome> server error on hpaste :(
16:02:01 <tommd> idnar: I'm but just one core
16:02:13 <tommd> errr, I am just one core.
16:03:13 <tommd> parMap rnf (convert :: Programmer a -> IO (Programmer Haskell)) [p | p <- worldPopulation , isProgrammer p]
16:03:43 <byorgey> Giarome: you broke it!!! ;-)
16:03:44 <kmc_> @pl (\a b -> a >> return b)
16:03:44 <lambdabot> (. return) . (>>)
16:03:44 <Giarome> 58030 5: database is locked
16:03:44 <Giarome> 500 Internal Server Error
16:03:44 <Giarome> lool
16:03:50 <byorgey> yeah, I get the same error
16:04:06 <Giarome> is there another pasting site?
16:04:21 <byorgey> sure, try pastebin.com
16:04:22 <tommd> Nope, you found the only one on the internet.
16:05:06 <Giarome> thx
16:05:07 <Giarome> ok
16:05:08 <Giarome> http://pastebin.com/m21acafc
16:05:13 <Giarome> here is my final code
16:06:29 <byorgey> Giarome: That code compiles fine for me.  Are you still getting an infinite type error?
16:06:39 <Giarome> nope
16:06:40 <Giarome> ;)
16:06:44 <Giarome> thx for da help!
16:07:10 <byorgey> Giarome: I think there's still a small bug: you have  [e | e <- bs, a /= x ]
16:07:25 <Giarome> yep
16:07:33 <Giarome> corrected
16:07:41 <byorgey> ok =)
16:09:21 <Giarome> nice, it works
16:27:30 <kw317> hmm, I've got this type: (forall c . (a -> c) -> c) -> (a -> b) -> b.. does it look familiar to anyone?
16:28:20 <copumpkin> hmm
16:28:26 <copumpkin> doesn't look very useful :)
16:28:37 <kw317> I know.. can't figure out what's the point of it LOL
16:28:40 <copumpkin> @djinn (forall c . (a -> c) -> c) -> (a -> b) -> b
16:28:40 <lambdabot> Cannot parse command
16:28:44 <copumpkin> where'd you get it?
16:28:52 <kw317> (it's from some homework assignment in System F)
16:29:18 <kw317> usually we get some useful stuff, but can't figure out the point of this term
16:29:20 <kw317> nvm ;-)
16:29:23 <copumpkin> forall r. Cont r a seems odd
16:31:58 <question> new to hexadecimal i have a question
16:32:26 <ivanm> question: but you _are_ a question! :p
16:32:30 <inimino> s/have/am/
16:32:39 <question> true
16:33:06 <Saizan> copumpkin: that's Codensity Id
16:33:18 <copumpkin> :O
16:33:21 <copumpkin> what can one do with it?
16:33:47 <ivanm> copumpkin: confuse people is my guess
16:33:47 <ivanm> ;-)
16:34:17 <question> does anybody know something about hex?
16:34:31 <centrinia> What about hex?
16:34:32 <ivanm> question: it's not really that relevant to this channel...
16:34:39 <ivanm> but if it's relatively short, just ask
16:34:45 <Saizan> copumpkin: fuse uses of >>= for the identity monad :)
16:34:53 <lament> careful, don't jinx anyone...
16:35:50 <tommd> Was that a chat bot?
16:36:13 <lament> it was a question
16:36:14 <ivanm> doubt it
16:36:17 <ivanm> lament: heh
16:36:43 <copumpkin> Saizan: :O
16:39:07 * Saizan wonders if it can make an observable difference
16:41:12 <Giarome> hey, i have another issue
16:41:13 <Giarome> http://pastebin.com/m6a88f32c
16:41:27 <Giarome> kind error
16:41:40 <Giarome> didn't know this yet
16:42:10 <jlouis> Giarome: you use `mod` when you want mod to be infix
16:42:21 <jlouis> you just use mod alone when you want it to be prefix
16:42:33 <jlouis> enclosing a prefix operator in backticks makes it infix
16:42:45 <Saizan> Giarome: Integer is a proper type, it doesn't take any parameters
16:42:59 <Saizan> Giarome: so you're not allowed to pass it an 'a' there
16:44:24 <jlouis> Giarome: and check you function for something simple like 8 to eradicate the final errors :)
16:47:00 <Giarome> sorry, i don't get it
16:47:47 <Ampix0> yo
16:47:51 <Giarome> Class "Integral" used as a class
16:47:54 <Giarome> hmm
16:47:57 <Ampix0> anyone got a google wave?
16:48:01 <Giarome> Class "Integral" used as a type
16:48:02 <FuriousJoe> hi, i am trying to write a summable type class for a variety of data structures i.e linked list, binary tree (just as an example).
16:48:10 <ivanm> Ampix0: does anyone care?
16:48:38 <FuriousJoe> but i want the data structures to contain any Num type, and the sum function to return a type which is the same as the one in the data structure passed into it
16:48:41 <Ampix0> ivanm well asking if anyone HAS google wave and are a FAN of google might care
16:48:44 <FuriousJoe> it doesn't seem to be possible :/
16:49:04 <Ampix0> Maybe instead of asking for an invite i was going to tell a grand secret about it
16:49:12 <ivanm> Ampix0: did you join this channel just to try and get a google wave invite?
16:49:16 <Ampix0> or i just lied and yes im asking if anyone has a google wave invite
16:49:20 <ivanm> because last I checked, this wasn't #googlewave ...
16:49:26 <Ampix0> no its not
16:49:38 <Ampix0> that channle is dead
16:49:41 <ivanm> good, I haven't stepped into an alternate dimension
16:50:13 <Ampix0> *twilight zone music*
16:54:35 <Giarome> whats wrong with this?
16:54:35 <Giarome> http://pastebin.com/m78163b3c
16:54:53 <Giarome> cannot construct infinite type
16:55:14 <ivanm> Giarome: you're using mod wrong
16:55:17 <ddvlad> Giarome: maybe try x `mod` e?
16:55:19 <ivanm> either x `mod` e
16:55:22 <ivanm> or e `mod` x
16:55:24 <ivanm> or mod x e
16:55:31 <ivanm> depends on what you want
16:57:37 <Giarome> can you correct this?
16:58:59 <ivanm> Giarome: we already told you how!
17:00:34 <Giarome> thx!
17:04:20 <Giarome> i got it
17:04:31 <Giarome> thx for help!
17:04:33 <Giarome> a lot
17:05:21 <ivanm> no worries
17:20:17 <kmc_> @src Ratio
17:20:18 <lambdabot> data (Integral a) => Ratio a = !a :% !a
17:20:29 <kmc_> @type (%)
17:20:30 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
17:20:42 <kmc_> @src (%)
17:20:42 <lambdabot> x % y = reduce (x * signum y) (abs y)
17:22:37 <Draconx> @src reduce
17:22:38 <lambdabot> reduce _ 0 = undefined
17:22:38 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
17:22:38 <lambdabot>     where d = gcd x y
17:23:23 <Giarome> have one last question
17:23:23 <Giarome> http://pastebin.com/m4e61d4c1
17:23:39 <Giarome> how to bring the elements in scope?
17:24:29 <jlouis> Giarome: you need to use a generator pattern on a,b,c
17:24:39 <Giarome> i.e.?
17:24:46 <jlouis> ie, [a | a <- [1..n]] etc
17:24:54 <Giarome> ahh ok
17:24:55 <Giarome> thx
17:24:57 <Giarome> again ;)
17:24:59 <byorgey> Giarome: for example  a <- [1..100], b <- [1..100] and so on
17:25:11 <byorgey> Giarome: also, odd a = True  is not right
17:25:15 <Giarome> ==
17:25:16 <byorgey> == is for comparison
17:25:21 <Giarome> k
17:25:29 <byorgey> and saying == True is useless, might as well just say 'odd a' =)
17:26:07 <jlouis> it is the same thing with the old classic of if x then True else False which can replaced with just x :)
17:26:26 <byorgey> indeed =)
17:42:48 <kmc_> @hoogle m a -> m b -> m a
17:42:49 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
17:42:49 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
17:42:49 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
17:44:01 <ivanm> @type flip (>>)
17:44:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
17:50:01 <byorgey> anyone know how to tell lhs2TeX what font to use to typeset code?
17:50:04 <gOcOOl> when i try to reinstall bytestring to get the profiling libs for it like so: "cabal install bytestring --reinstall -p", it keeps failing with the following error message: "Perhaps you haven't installed the profiling libraries for package `base'?"
17:50:10 <gOcOOl> anyone know how to fix that?
17:51:11 <ivanm> gOcOOl: you shouldn't really be using a separate bytestring package
17:51:25 <ivanm> and just stick with the one that comes with your version of GHC if you can
17:51:29 <ivanm> byorgey: same as for normal tex?
17:51:31 <ivanm> *latex
17:51:41 <ivanm> oh, for code...
17:51:48 <ivanm> preflex: seen kosmikus
17:51:48 <preflex>  kosmikus was last seen on #haskell 6 days, 3 hours, 8 minutes and 52 seconds ago, saying: sproingie: LambdaHack doesn't compile out of the box?
17:52:07 <gOcOOl> ivanm: ah ok, makes sense. since i have it already installed, how do I *not* use it and use the one bundled with ghc?
17:52:31 <ivanm> gOcOOl: ghc-pkg unregister bytestring-<whichever version you already have>
17:52:44 <gOcOOl> ok, let me give that a shot, thanks
17:52:51 <ivanm> or uninstall it if it was a system package
17:53:02 <ivanm> by "already have", I mean "you installed yourself"
18:00:37 <kmc_> @pl (\a b -> a >>= (\x -> b >> return x))
18:00:37 <lambdabot> (. ((. return) . (>>))) . (>>=)
18:01:08 <copumpkin> eww
18:01:33 <copumpkin> :t (\a b -> a >>= (\x -> b >> return x))
18:01:34 <kmc_> ivanm, i wanted to use the result of the left action but bind the right one after it
18:01:34 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m a
18:01:55 <gOcOOl> ivanm: still the same problem, i unregistered the version of bytestring i had installed and then tried to reinstall bytestring with profiling libs, still same issue
18:01:55 <copumpkin> @type (<*)
18:01:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
18:01:59 <EvanCarroll> does haskell support recursion in an anon function?
18:02:05 <kmc_> EvanCarroll, through "fix"
18:02:05 <kmc_> :t fix
18:02:07 <lambdabot> forall a. (a -> a) -> a
18:02:07 <copumpkin> kmc_: does it need to be specifically in that order?
18:02:17 <kmc_> > fix (3:)
18:02:18 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
18:02:36 <copumpkin> EvanCarroll: apart from fix, nope
18:02:37 <kmc_> copumpkin, the args? don't care as much
18:02:44 <copumpkin> kmc_: then <* does it
18:02:49 <kmc_> but the monad binding should be in that order
18:02:50 <kmc_> hmm
18:03:01 <kmc_> > [1,2,3] <* [4,5]
18:03:02 <lambdabot>   [1,1,2,2,3,3]
18:03:18 <copumpkin> :t flip (>>)
18:03:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
18:03:30 <kmc_> @src (<*)
18:03:31 <lambdabot> (<*) = liftA2 const
18:03:35 <gOcOOl> "ghc-pkg list bytestring" returns this: "/var/lib/ghc-6.10.4/./package.conf: bytestring-0.9.1.4"
18:04:39 <kmc_> > runState ((put 1 >> get) <* put 2) 0
18:04:40 <lambdabot>   No instance for (Control.Applicative.Applicative
18:04:41 <lambdabot>                     (Contr...
18:04:41 <gOcOOl> when i do "ghc --make A.hs -prof", it returns: "Could not find module `Data.ByteString.Lazy.Char8': Perhaps you haven't installed the profiling libraries for package `bytestring-0.9.1.4'?"
18:07:48 <lispy> gOcOOl: do you have the same issue if you use a .cabal file?
18:07:55 <lispy> Oh
18:08:14 <lispy> gOcOOl: actually, it looks like you are missing the profiling enabled version of the library
18:08:25 <Cale> The libraries you're using need to be installed for profiling... I'm not sure what the most convenient way to update the installation is.
18:08:34 <lispy> gOcOOl: does your make command work without the "-prof" part?
18:08:39 <copumpkin> from the wikipedia article on topos, "Constructivists will be interested to work in a topos without the law of excluded middle."
18:08:51 <Cale> copumpkin: indeed
18:09:03 <gOcOOl> lispy: when i do "ghc --make A.hs -prof", it returns: "Could not find module `Data.ByteString.Lazy.Char8': Perhaps you haven't installed the profiling libraries for package `bytestring-0.9.1.4'?"
18:09:13 <copumpkin> how does one incorporate the lack of LEM in a topos?
18:09:24 <gOcOOl> lispy: oops, sorry, it does workl just finw without -prof
18:09:32 <gOcOOl> *fine
18:09:45 <lispy> gOcOOl: okay, so then your bytestring-0.9.1.4 doesn't enable profiling
18:10:19 <gOcOOl> how do i fix it, i see a whole bunch of lighc6-xxx-prof packages in ubuntu repository
18:10:26 <gOcOOl> maybe i should install one of those?
18:10:33 <gOcOOl> not sure which though
18:10:37 <lispy> cabal install --reinstall --enable-library-profiling bytestring-0.9.1.4
18:11:10 <lispy> Yeah, you might want one of those
18:11:20 <lispy> I really don't trust debian or ubuntu haskell packages
18:11:25 <lispy> I've been bitten too many times
18:11:33 <gOcOOl> do you know which one though?
18:11:47 <lispy> one that mentions bytestring?
18:12:10 <lispy> I don't use apt to manage haskell packages... that way leads to madness
18:12:19 <lispy> You really want cabal-install
18:12:58 <gOcOOl> I already tried cabal resintalling bytestring for profiling libs, it fails with the following message:
18:13:01 <Cale> copumpkin: Well, I'm not certain that this is the way that the article intends it, and there may be a deeper interpretation, but...
18:13:14 <gOcOOl> "Could not find module `GHC.ST': Perhaps you haven't installed the profiling libraries for package `base'?"
18:13:21 <gOcOOl> not sure what the deal is
18:14:42 <lispy> gOcOOl: well, you may need the ubuntu version of that one
18:14:48 <lispy> libghc-XXX-prof
18:14:48 <copumpkin> I imagine it has something to do with the subobject classifier
18:14:59 <Cale> copumpkin: If you take essentially any reasonable sort of logic whatsoever, you can turn it into a category whose objects are statements, and where there is a unique arrow A -> B if and only if B logically follows from A.
18:15:10 <lispy> gOcOOl: something with base in the name?
18:15:25 <lispy> gOcOOl: It's hard to say without seeing the list of packages
18:15:53 <Cale> If there are products, then you have an equivalent of "and" and if there are coproducts, you have "or", exponentials are like implication.
18:16:01 <gOcOOl> i don;t see any for base or bytestring, arghhhh
18:16:25 <lispy> gOcOOl: and now you know why I install ghc outside of apt :(
18:16:26 <Peaker> Cale, what about statements that are true but cannot be proven true?
18:16:36 <copumpkin> Cale: makes sense so far
18:16:43 <gOcOOl> lispy: yeah, no kidding ;)
18:16:44 <lispy> gOcOOl: whoever is packaging it doesn't understand typical haskell user neds
18:17:15 <Cale> The statement A is true if there is an arrow 1 -> A, and false if there is an arrow A -> 0
18:17:32 <Cale> (assuming we have an initial and terminal object)
18:17:47 <Peaker> Cale, what about Godel?
18:17:55 <Cale> A statement is undecidable if there is neither arrow
18:18:00 <gOcOOl> i think i found it, seems like it is:  linghc6-binary-prof
18:18:52 <Cale> If there are both, 1 -> A and A -> 0 (a contradiction), then we have a map 1 -> 0, and by composing that with the unique maps A -> 1 and 0 -> A for each A, we get that everything becomes both true and false.
18:20:46 <byorgey> preflex: seen kosmikus
18:20:47 <preflex>  kosmikus was last seen on #haskell 6 days, 3 hours, 37 minutes and 51 seconds ago, saying: sproingie: LambdaHack doesn't compile out of the box?
18:21:06 <Cale> Of course, every arrow in such a category is a monomorphism.
18:21:46 <Cale> (because there's at most one arrow between any two objects, so equations hold trivially)
18:21:57 <byorgey> @ask kosmikus is there a way to tell lhs2TeX to use a particular font for typesetting code?
18:21:57 <lambdabot> Consider it noted.
18:22:35 <Cale> The negation of a statement A is the same as the exponential object 0^A
18:22:59 <Cale> (there is an arrow 1 -> 0^A if and only if there is an arrow A -> 0, meaning a proof that A is false)
18:23:25 <Cale> So LEM can be phrased as the statement that for every A, there is an arrow 1 -> A + 0^A
18:23:38 <Cale> and nothing categorical forces that arrow to exist
18:24:42 <Cale> There's something a bit unsettling about this interpretation though, since our subobject classifier won't be too interesting.
18:25:29 <Gracenotes> okay, I think I've solved the problem of seq nicely enough: just make a "Seq" case alt
18:25:29 <Cale> oh, hmm
18:25:40 <Gracenotes> STG-ly-speaking
18:26:25 <copumpkin> Cale: I see, thanks
18:26:37 <Cale> So, I'm not sure if this is what they were thinking of.
18:26:49 <Cale> Maybe there's something like Set, but where LEM is somehow missing
18:26:55 <Cale> But I'm not sure how it works :)
18:28:19 <Cale> Wait, will there be a subobject classifier? Maybe that doesn't work.
18:28:31 <ivanm> gOcOOl: my point was, _don't_ reinstall bytestring!
18:28:37 <ivanm> bytestring comes with GHC!
18:29:05 <reltuk> can I create an instance of Typeable without -XDeriveDataTypeable?
18:29:13 <reltuk> I can't find any constructors for TypeRep...
18:29:23 <gOcOOl> ivanm: i did *not* reinstall bvytestring
18:29:30 <copumpkin> this statement also seems relevant: "Suppose you're a constructivist and you only want to work with "effectively constructible" sets and "effectively computable" functions. Then you want to work in the "effective topos" developed by Martin Hyland."
18:29:46 <Cale> ah, yeah, maybe I see what it is
18:29:58 <ivanm> <gOcOOl> ivanm: still the same problem, i unregistered the version of bytestring i had installed and then tried to reinstall bytestring with profiling libs, still same issue
18:30:07 <byorgey> reltuk: sure, you can declare your own instance
18:30:12 <ivanm> gOcOOl: ^^ you just said you did ;-)
18:30:23 <gOcOOl> yeah, what I meant was, i unregistered the one i had manually cabal installed, then tried profiling
18:30:25 <ivanm> gOcOOl: how did you install GHC? did you build/install its profiling libraries?
18:30:26 <gOcOOl> still no luck
18:30:32 <rasfar> hey Cale, first it's great to come back here after a long hiatus and still be able to pick up some category theory.  (Last I was on here you gave me some help with the cat. th. class I was in.)  But I just noticed, I think we now live in the same city.  Would be nifty to meet you sometime.
18:30:38 <byorgey> reltuk: you can use the provided functions like  mkTyCon, mkTyConApp, etc. for constructing TypeReps
18:30:50 <Cale> rasfar: You live in Brantford?
18:30:53 <gOcOOl> so I tried resinatlling the one that comes with ghc with profiling libs enabled, and that was failing
18:31:04 <byorgey> reltuk: see the documentation here: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
18:31:14 <rasfar> um, no.  Kitchener-Waterloo.  Seeing as I'm not from Ontario I'll have to see where Brantford is....
18:31:22 <gOcOOl> ivanm: I then finally fixed it by installing "libghc6-binary-prof" for my distro (ubuntu)
18:31:32 <reltuk> byorgey: how can I construct a TypeRep though?
18:31:35 <Cale> rasfar: ah, it's a 45 minute drive if you know the right way
18:31:39 <ivanm> gOcOOl: as I said, you needed the profiling libs for GHC ;-)
18:31:46 <reltuk> in order to implement typeOf
18:31:58 <copumpkin> what the hell is up with the CT books in my library getting lost??
18:32:10 <gOcOOl> ivanm: yeah, i wasn;t sure how to install profiling libs for it
18:32:15 <ivanm> copumpkin: it's the Set Theory gremlins!
18:32:21 <copumpkin> ivanm: must be!
18:32:59 <Cale> copumpkin: Perhaps since the subobjects of your sets effectively tell you which properties you can inquire about, you can prohibit LEM from being used in that way
18:33:09 <gOcOOl> ivanm: anyways, that seemed to do it although the profile output that i'm getting now doesn;t make much sense, it says 100% of time and alloc is spent in main ;)
18:33:14 <byorgey> reltuk: well, you can use typeOf to get a TypeRep for types which already implement Typeable
18:33:15 <rasfar> oh, I see!  not so bad...  maybe beverages one day!
18:33:20 <byorgey> reltuk: and you can use  mkTyCon
18:33:21 <ivanm> gOcOOl: overall, it is...
18:33:46 <Cale> rasfar: yeah, it would be cool to find other people from around here who were into category theory and Haskell :)
18:33:49 <byorgey> reltuk: why do you need to write your own Typeable instance?
18:33:57 <gOcOOl> ivanm: yeah but there isn't any granular reporting other than that
18:34:08 <gOcOOl> ivanm: let me hpaste the output
18:34:19 <ivanm> gOcOOl: if you built the profiling properly, there would be
18:34:48 <ivanm> gOcOOl: this is what I use for profiling apps: ghc -O2 -Wall -funbox-strict-fields -prof -auto-all -caf-all --force-recomp --make Foo.hs
18:34:50 <reltuk> byorgey : I will just derive it...was wondering what it would look up.  using typeOf on existing types...
18:34:55 <ivanm> then run it with +RTS -p
18:35:50 * copumpkin wishes psykotic came on IRC more often
18:36:11 <ivanm> why?
18:36:22 <copumpkin> I have a few questions for him from random reddit postings of his
18:36:27 <ivanm> ahhh
18:36:33 <gOcOOl> ivanm: that's exactly what I'm doing, check this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4882#a4882
18:36:48 <copumpkin> or if not IRC, he should at least have a permanent internet abode that his random thoughts can appear on, other than reddit comments
18:36:56 <ivanm> gOcOOl: well, what is your code?
18:36:57 <copumpkin> lest they be lost forever
18:37:04 <ivanm> if it's just a main function, there's nothing else there to profile...
18:37:07 <gOcOOl> ivanm: ok, 1 sec
18:37:44 <gOcOOl> ivanm: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4883#a4883
18:38:00 <ivanm> gOcOOl: well, you only have a main function!
18:38:05 <ivanm> what else is it meant to profile?
18:38:24 <ivanm> if you want more granular results, give names to the CAFs, or else split main up into separate functions
18:39:03 <gOcOOl> ivanm: it wont tell me how much time it spent in "unpack, f, g" etc?
18:39:11 <ivanm> gOcOOl: no
18:39:22 <gOcOOl> ivanm: is there some annotations required to get it to show that info?
18:39:36 <ivanm> gOcOOl: yes, but I don't know them ;-)
18:39:45 <ivanm> gOcOOl: easier way: give them separate named functions
18:40:00 <copumpkin> {-# SCC "moo" #-}
18:40:13 <copumpkin> set cost cent(er|re)
18:40:20 <ivanm> that's the one
18:40:23 <copumpkin> it'll omnom the entire surrounding expression
18:40:34 <copumpkin> so add parentheses if you want to limit its scope
18:40:35 <ivanm> copumpkin: it's spelt "centre"
18:40:35 <ivanm> ;-)
18:40:46 <gOcOOl> ah ok, let me try that real wquick
18:40:49 <gOcOOl> *quick
18:43:15 <gOcOOl> is this right? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4883#a4884
18:43:41 <gOcOOl> {-# SCC filtertokens #-} annotation fails to compile
18:44:28 <Gracenotes> okay.. it is rather odd that I'm coming up with Prelude.undefined when I can't actually find the string "undefined" anywhere in my text file
18:44:39 <Gracenotes> I thought the libraries generally defined their own errors
18:45:02 <ivanm> Gracenotes: one of your calculations has reached [rock-] bottom?
18:45:23 <Gracenotes> I do use error calls, but never undefined
18:45:34 <Gracenotes> it must be explicitly invoked
18:45:57 <ivanm> must it? can't you get _|_ == undefined for any boxed type?
18:46:31 <Gracenotes> you can, if you explicitly invoke it
18:47:08 <ivanm> Gracenotes: my point is, you might get it anyway even if you don't explicitly invoke it
18:47:09 <gOcOOl> nvm, the annotation is supposed to be inline and the function name needs to be quoted ;)
18:47:55 <Gracenotes> yes... and it's not coming from anywhere in my code, and I know the libraries like to define their own errors, so.. let me see where I call things I'm not so sure about
18:48:58 <ivanm> Gracenotes: my point is, some calculations might unintentionally return undefined
18:49:03 <ivanm> rather than explicitly
18:50:06 <Gracenotes> unintentional on whose part? perhaps mine, but not the people who wrote what I'm using:)
18:50:36 <ivanm> Gracenotes: e.g. a numeric overflow or something (not quite sure how they're treated)
18:50:56 <Gracenotes> mm. those all have their own errors
18:51:00 <ivanm> my point is, IIRC undefined can sometimes magically appear due to some missing assumption or something
18:51:27 <Gracenotes> > minBound `div` negate 1 :: Int
18:51:28 <lambdabot>   * Exception: arithmetic overflow
18:52:14 <Asztal> This is why undefined should include a file and line number in its message :(
18:52:33 <ivanm> Gracenotes: so, put trace statements everywhere until you track down where the undefined occurs!
18:52:59 <Gracenotes> the program I'm working on now it heavily output-oriented. so the time at which something occurs is interesting
18:53:25 <Gracenotes> *is
18:53:48 <Gracenotes> here, it prints out a constructor, but throws undefined before printing its int value.. hm
18:55:03 <Gracenotes> okay, if I seq the constructor to the argument before returning it, then the constructor doesn't show
18:58:40 <Gracenotes> okay.. I found the culprit!
18:58:51 <Gracenotes> Text.Printf, for some reason, uses undefined somewhere
18:59:41 <tommd> And you're sure it isn't just forcing the evaluation of an undefined thunk that isn't part of printf?
19:00:45 <Gracenotes> well.. I have no doubt whatsoever it is entirely my fault for using it in an unsafePerformIO... ugh I don't want to do make everything IO though :/ so I'll add a top-level flag for the trampolining evaluator, which does use IO
19:01:45 <Gracenotes> oddly enough, the printf call goes flawlessly
19:02:48 <Gracenotes> but after seq'ing the unsafePerformIO'd IO () returned from it, it yields an undefined.. perhaps there is magic involved somewhere after all.
19:03:06 <Gracenotes> either way, I've gotten into deep-magic-before-the-dawn-of-time territory -_-
19:03:43 <Gracenotes> by the way, it works flawlessly with trace, but the problem there is that trace uses stderr, not stdout
19:06:34 <Jedi_Stannis> how does the haskell parser know where one declaration ends and the next one starts?
19:06:40 <ivanm> magic!
19:07:23 <byorgey> Jedi_Stannis: whitespace does play a role; you can't run two declarations together on a line, for instance
19:07:43 <Jedi_Stannis> lol
19:07:53 <Jedi_Stannis> yeah, but a decleration can run on multiple lines
19:08:00 <Gracenotes> for multi-line declarations (pattern matching), those have to be consecutive. or else GHC complains about multiple definitions
19:08:04 <byorgey> f 0 = 1 f n = n * f (n - 1)   -- illegal
19:08:06 <Gracenotes> try it and see, if you like
19:08:29 <byorgey> Jedi_Stannis: yes, but continuation lines have to be indented
19:08:50 <byorgey> f n = n *
19:08:55 <byorgey> f (n - 1)  -- also illegal
19:09:14 <Gracenotes> > let fib 0 = 0; fib 1 = 1; plus a b = a+b; fib n = plus (fib $ n-1) (fib $ n-2) in fib 5
19:09:15 <lambdabot>   Conflicting definitions for `fib'
19:09:16 <lambdabot>  In the binding group for: fib, plus, fib
19:09:51 <Gracenotes> slightly different error message if you do that for top-level declarations
19:10:29 <Jedi_Stannis> hmm interesting
19:10:39 <Gracenotes> if you mean a single declaration (just one of the fib cases), well, exactly what byorgey said
19:10:41 <Jedi_Stannis> was just thinking about how it always just seems to do the right thing
19:13:09 <kmc> Jedi_Stannis, the Haskell Report spells out the rules for how whitespace is used to infer invisible { } ;
19:13:16 <kmc> in fact, it specifies it essentially as a haskell function
19:13:34 <kmc> and you can always put those characters in yourself if it's not doing what you want
19:13:50 <kmc> it's a really nice system compared to e.g. python
19:14:55 <Jedi_Stannis> yeah, exactly, but I've never needed to put them in.  it's a very nice system
19:58:44 * byorgey sautees some fresh lambda in olive oil with rosemary and garlic
19:59:05 <medfly> hmm :)
20:02:20 * bos31337 sings the inliner-makes-me-sad song.
20:02:41 <Gracenotes> and those allergic to olive oil... hm.. canola oil, maybe?
20:02:50 <tommd> Using OS X I'm guessing
20:04:10 <Cale> You could parametrise the recipe using a lambda abstraction, and the people who eat it just have to input whatever type of oil they'd like to have been used to cook it.
20:06:16 <Gracenotes> @hackage haskell-src-exts
20:06:16 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
20:07:07 <tommd> @hackage affordable-portland-housing -- hackage has everything
20:07:08 <lambdabot> http://hackage.haskell.org/package/affordable-portland-housing -- hackage has everything
20:10:27 <ivanm> tommd: heh
20:10:59 <ivanm> Cale: a lambda abstraction of how to cook lambdas?
20:11:53 <monadwar> hmm
20:13:21 <ido> kmc_: which is better, haskell or sex?
20:13:50 <bos> hmm, we need a better supply of late-night haskell hackers around.
20:14:56 <rasfar> thought we were international.  is there still a map showing locations?  i remember putting myself on it, but now i forget where it is.  and where i am....
20:15:27 <ivanm> bos: waddaya mean?
20:15:35 <ivanm> it's barely mid-afternoon here!
20:15:36 <ivanm> ;-)
20:15:52 <ivanm> rasfar: there is, but I'm not sure how up-to-date it is
20:15:59 * ivanm never bothered putting himself on it
20:16:03 <ivanm> @map bos
20:16:03 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:16:09 <ivanm> rasfar: ^^
20:16:19 <SamB_XP> ivanm: where the heck are you? hawaii ?
20:16:35 <ivanm> SamB_XP: do a /whois on me and guess!
20:16:57 <SamB_XP> ivanm: oh, australia?
20:17:01 <ivanm> yup
20:17:06 <SamB_XP> it's mid-afternoon there already ???
20:17:13 <ivanm> @time
20:17:13 <rasfar> @map
20:17:14 <lambdabot> Local time for ivanm is Tue Nov 10 14:17:13
20:17:15 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:17:22 <ivanm> samulihs: depends on how you define mid-afternoon I suppose...
20:17:33 <rasfar> (oh)  link is down though
20:17:49 * SamB_XP hates when he does that ...
20:17:55 <byorgey> the link is old, is the problem
20:18:21 <byorgey> try this instead: http://haskell.org/haskellwiki/Haskell_user_locations
20:18:50 <ivanm> heh
20:18:59 <rasfar> oh crap my real name's on there! haha
20:19:01 <ivanm> SamB_XP: then don't do it!
20:19:13 <SamB_XP> ivanm: I do it by accident, silly!
20:19:26 <ivanm> yeah, right...
20:19:57 <SamB_XP> lol
20:20:11 <SamB_XP> google toolbar claims that http://www.cse.unsw.edu.au/~dons/haskell-planet is written in romanian!
20:20:23 <SamB_XP> when it's clearly written in #!/bin/sh
20:20:37 <ivanm> SamB_XP: well, it's incomprehensible to most people...
20:20:47 <ivanm> doesn't that make it related to romanian? :p
20:20:54 <SamB_XP> not really
20:21:03 <ivanm> oh, wait, I'm thinking of hungarian...
20:21:23 <SamB_XP> oh, you mean that microsoft thing ?
20:21:33 <ivanm> hmmm?
20:21:52 <SamB_XP> with stuff like hInst or lpCmdLine
20:23:12 <SamB_XP> the "h" indicating a handle, and the latter indicating a "long pointer"
20:24:09 <SamB_XP> (which is actually just a normal one, nowadays -- the difference only applied to win16, since win32 doesn't support or use segmented memory models)
20:24:33 <byorgey> wait a minute, my latitude and longitude differ from SamB_XP's by only a few hundredths of a degree.
20:24:41 * byorgey looks over his shoulder quickly
20:24:46 <ivanm> heh
20:24:47 <SamB_XP> byorgey: hehehehe
20:25:01 <byorgey> SamB_XP: I didn't know you lived in Philly.
20:25:14 <SamB_XP> byorgey: I don't -- I'm in Upper Darby
20:25:35 <SamB_XP> but I'm not sure I've got enough digits there to show that
20:25:42 <byorgey> well, ok, I guess a few hundredths of a degree is still a mile or two =)
20:26:10 <ivanm> well, AFAIK dibblego is the closest regular in here to where I live...
20:26:20 <ivanm> and he's on the other side fo town IIRC
20:26:53 <byorgey> SamB_XP: well, if you're ever around Penn, we should grab a [insert social drink/foodstuff of choice here]
20:27:13 <SamB_XP> hehehe
20:32:13 <jfhall> Can anyone point me in the right direction to figure out why `let f = (>)` doesn't have a polymorphic type, but `let f a b = a > b` -- at least in ghci
20:32:36 <dmead> @hoogle exception
20:32:37 <lambdabot> module Control.Exception
20:32:37 <lambdabot> Control.Exception class (Typeable e, Show e) => Exception e
20:32:37 <lambdabot> Control.OldException data Exception
20:32:38 <jfhall> meant to say `let f a b = a > b` does have a polymorphic type
20:32:48 <dmead> hey channel
20:32:59 <dmead> how would one catch a pattern match failure exception?
20:33:05 <Lemmih> jfhall: See the monomorphic restriction.
20:33:12 <jfhall> Lemmih: thank you
20:33:32 * shapr hugs Lemmih 
20:33:44 <ivanm> dmead: by not doing so? ;-)
20:33:55 <ivanm> shapr: why? because you didn't have to answer? :p
20:34:11 <Lemmih> Hello shapr. It's been awhile.
20:34:15 <dmead> ivanm, if i want to have a list of lambdas, i'll need to deal with pattern match failure
20:34:28 <shapr> ivanm: I like Lemmih!
20:34:50 <shapr> I think Lemmih is the only person in the world that I've met on three subcontinents.
20:34:51 <ivanm> dmead: you mean what someone did on -cafe as an alternative to the whole "case of Foo -> ... " proposal?
20:34:57 <ivanm> shapr: heh
20:35:31 <ivanm> shapr: coincidentally, or because you were at the same conferences, etc.?
20:35:48 <shapr> Er, all of them were on purpose!
20:36:06 <dmead> ivanm, probably not
20:36:19 <ivanm> dmead: well, why are you trying to pattern-match in a lambda?
20:36:21 <tommd> dmead: Control.Exception.catch and have your catch function catch errors :: ErrorCall
20:36:32 <dmead> i need to fail if a pattern doesn't match, not just go to the next case
20:36:38 <dmead> i'm making a rule system
20:36:42 <ivanm> ahhh
20:36:43 <tommd> for the prelude "pattern match failures" which are unfortunately manual "error "foo"" calls
20:36:58 <dmead> ivanm, so i can mark that function failing etc etc
20:37:02 <tommd> Test it for others
20:37:18 <ivanm> tommd: you mean they have "foo _ = error ... " ?
20:37:29 <tommd> yeah, it will catch any call to "error"
20:37:33 <ivanm> dmead: well, it'd be IO Errors I think
20:37:45 <ivanm> well, just error
20:38:45 <tommd> I really wish something like CATCH made it into the standard GHC tool set.
20:38:57 <dmead> hmm
20:40:26 <sohum> jfhall: -XNoMonomorphismRestriction wooo :P
20:40:43 <tommd> dmead: It looks like "SomeException" is thrown for pattern match failures.
20:41:07 <tommd> :-)
20:41:08 <dmead> theres also the patternmatchfail
20:41:10 <dmead> hmm
20:41:13 <tommd> Where?
20:41:29 <dmead> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#t%3APatternMatchFail
20:41:31 <dmead> brb
20:41:46 <tommd> dmead: Yeah, right there in the list, I just didn't see it.
20:41:56 <tommd> I was wondering why something so obvious wasn't showing up :-)
20:47:52 * hackagebot upload: attempt 0.0.1 - Error handling using extensible exceptions outside the IO monad. (MichaelSnoyman)
21:05:54 <copumpkin> lol, this just about sums it up: http://snapplr.com/w87y
21:08:56 <ENOERROR> lol
21:10:02 <copumpkin> there is actually another group with all of 95 people in it
21:11:11 <medfly> #haskell is retty big
21:11:22 <medfly> not need for some kind of reassurance :/
21:37:21 <O_4> Hmm, I have a function that evaluates to a Maybe [Point]
21:37:53 <O_4> And it's going to be built up with a recursive function
21:38:33 <O_4> Is there a clean way to have the whole thing evaluate to Nothing if the recursive function decides to bail?
21:38:41 <mtnviewmark> question: would the result of Maybe [] (a list of no points) be different than Nothing in this case?
21:38:59 <O_4> Logically, yes.
21:39:57 <O_4> Though in practice I could just use [] in place of the Nothing and a non-empty list for the Maybe [Point]
21:40:01 <nornagon> f = do { x <- f; let myCalc = calcThisElement; return (myCalc : x) }
21:40:31 <nornagon> if any call to f returns Nothing, that x <- f will make the whole thing return Nothing
21:40:55 <nornagon> but i haven't written any haskell in months :)
21:59:32 <ski> O_4 : yes, it sounds like you want the `Maybe' monad
21:59:54 <ski> nornagon : that left-recursion looks problematic :)
22:00:16 <O_4> Yeah, I'm fairly certain the Maybe monad will do what I want, I just don't understand how it works well enough to use it yet.
22:00:18 <nornagon> ski: maybe :)
22:00:25 <nornagon> @source Maybe (>>=)
22:00:26 <lambdabot> Maybe (>>=) not available
22:00:30 <nornagon> @source (>>=) Maybe
22:00:31 <lambdabot> (>>=) Maybe not available
22:00:33 <nornagon> :(
22:00:33 <O_4> Where is the source for the Maybe monad?
22:00:34 <ski> @src Maybe >>=
22:00:34 <lambdabot> Source not found. Maybe you made a typo?
22:00:37 <O_4> I can't find it :-/
22:00:41 <ski> @src Maybe (>>=)
22:00:42 <lambdabot> (Just x) >>= k      = k x
22:00:42 <lambdabot> Nothing  >>= _      = Nothing
22:00:46 <ski> there you go
22:00:47 <nornagon> what
22:00:57 <ski> @src Maybe return
22:00:58 <lambdabot> return              = Just
22:01:00 <nornagon> @src Maybe (>>=)
22:01:00 <lambdabot> (Just x) >>= k      = k x
22:01:00 <lambdabot> Nothing  >>= _      = Nothing
22:01:05 <nornagon> @source Maybe (>>=)
22:01:06 <lambdabot> Maybe (>>=) not available
22:01:09 <nornagon> .................
22:01:31 <ski> O_4 : if you want, you can write it without `return' and `(>>=)', using `case',`Nothing', and `Just' instead, to begin with
22:03:29 <ski> O_4 : you could also check the beginning of <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> for possible hints and ideas for what the `Maybe' monad does
22:04:52 <stoop> > Just 4
22:04:53 <lambdabot>   Just 4
22:05:03 <stoop> > Just 4 >> Nothing
22:05:05 <lambdabot>   Nothing
22:05:07 <stoop> > Nothing >> Just 4
22:05:09 <lambdabot>   Nothing
22:05:19 <stoop> > Just 4 >> Nothing >> Just 1 >> Just 2
22:05:20 <lambdabot>   Nothing
22:05:26 <O_4> ski, nornagon: thanks for the tips
22:05:47 <Thyssen> > Just Stop
22:05:48 <lambdabot>   Not in scope: data constructor `Stop'
22:07:39 <jekor> I'm using UrlDisp which has a combinator that attempts to read the next component of the path as a given type. I'd like to make sure that the next part of the path is a valid username, but that requires doing I/O. I suspect that that rules out making a username an instance of read (and verifying that the username exists in the database). Am I stuck writing a new combinator?
22:17:39 <copumpkin> > Just Nothing `mplus` Just (Just Nothing)
22:17:41 <lambdabot>   Just Nothing
22:17:44 <copumpkin> > Just Nothing `mappend` Just (Just Nothing)
22:17:46 <lambdabot>   Just (Just Nothing)
22:18:18 <copumpkin> > join (Just (Just Nothing))
22:18:20 <lambdabot>   Just Nothing
22:21:15 <ivanm> copumpkin: are you having fun yet? :p
22:21:23 <copumpkin> nope
22:21:29 <ivanm> :(
22:22:04 <Gracenotes> if a garbage collector looked at every single stack frame, then for all references therein to the heap it looked at interheap references, and junked everything else.. that would be about as good as you can get in terms of correctness, right?
22:22:24 <copumpkin> > (runKleisli $ Kleisli (const (Just Nothing)) >>> (Kleisli (const (Just (Just Nothing))))) ()
22:22:26 <lambdabot>   Just (Just Nothing)
22:22:30 <Gracenotes> certainly not efficiency, but.. correctness, at least
22:22:56 <Gracenotes> as even reference cycles would get cut out if they're not referred to by anything
22:23:34 * Gracenotes is looking at GHC's way of doing generations
22:24:43 <dmead> hey channel
22:24:51 <dmead> does anyone have a good example of how to catch exceptions?
22:25:07 <dmead> the snipets on the standard libs page is pretty vauge
22:25:46 <ivanm> exceptions == error "foo" ?
22:26:21 <dmead> o0
22:29:52 <mtnviewmark> anyone have a nomination for an excellent example of Haddock documentation for a library? I'm looking to learn by imitating!  :-)
22:31:13 <gjl> How can I create a three-dimensional array using the array function in the Ix library?
22:31:16 <mtnviewmark> Gracenotes - that is the basic mark-and-sweep algo. for GC --- the stack frames in this case act as the "root set"
22:31:39 <dmead> :t catch
22:31:40 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
22:31:52 <mmorrow> Gracenotes: if you're using copying gc, you have to visit and copy exactly the live nodes, and the dead ones you conveniently never deal with
22:32:09 <dmead> :t unsafeperformIO
22:32:11 <lambdabot> Not in scope: `unsafeperformIO'
22:32:12 <mmorrow> so it's O(live nodes)
22:32:14 <dmead> :t unsafePerformIO
22:32:15 <lambdabot> Not in scope: `unsafePerformIO'
22:32:25 <dmead> @hoogle unsafeperformio
22:32:25 <lambdabot> Foreign unsafePerformIO :: IO a -> a
22:32:26 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
22:32:28 <mmorrow> @type System.IO.Unsa
22:32:29 <lambdabot> Not in scope: data constructor `System.IO.Unsa'
22:32:30 <mmorrow> beat me
22:32:31 <mmorrow> :)
22:32:37 <dmead> xD
22:32:38 <mmorrow> oh
22:32:48 <mmorrow> @type System.IO.Unsafe.unsafePerformIO
22:32:49 <lambdabot> forall a. IO a -> a
22:32:51 <Gracenotes> I saw something along those lines on Wikipedia. I suppose cycle detection is mainly an issue with reference counting, along the lines of python
22:32:51 <Veinor> I heard you can use unsafePerformIO to write a function of type a -> b
22:33:17 <dmead> :t catch
22:33:18 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
22:33:32 <Gracenotes> but some basic familiarity with garbage collection does seem involved in the Haskell GC :)
22:33:36 <mmorrow> Gracenotes: the cheney algo is the basic standard copying method
22:34:11 <mmorrow> Gracenotes: i've got a toy reference cheney in haskell http://moonpatio.com/repos/Cheney.hs
22:34:28 <Veinor> does it shoot whatever it copies in the face?
22:34:29 <dmead> > unsafePerformIO ( catch (head [])  (\_ -> "hello"))
22:34:30 <lambdabot>   Not in scope: `unsafePerformIO'
22:34:42 <mmorrow> Gracenotes: how do you mean?
22:34:44 <Gracenotes> Heap is the top-level part?
22:34:58 <Gracenotes> mmorrow: well, reading the code, documentation, etc.
22:35:04 <dmead> > System.IO.Unsafe unsafePerformIO ( catch (head [])  (\_ -> "hello"))
22:35:05 <lambdabot>   Not in scope: data constructor `System.IO.Unsafe'Not in scope: `unsafePerfo...
22:35:17 <dmead> :m System.IO.Unsafe
22:35:22 <dmead> err
22:35:29 <dmead> how do you get lambdabot to load a module?
22:35:44 <Gracenotes> it has what it has
22:35:52 <dmead> oh yea
22:35:55 <dmead> io is disabled
22:36:00 <Veinor> I just tried loading system.io.unsafe and then running that and it failed.
22:36:11 <Veinor>     Couldn't match expected type `IO a' against inferred type `[Char]'
22:36:21 <Gracenotes> dmead: it's sandboxing! ... sort of
22:36:27 <dmead> xD
22:36:44 <gjl> what's the simplest way of implementing multi dimensional arrays?
22:36:51 <mmorrow> Gracenotes: it's a generational copying collector, that is stop-the-world for generation 2, during which it distributes work among multiple threads, and the generation 1 fits in the cache so never misses, and once the gc has copied the remnants of the first gen, it's in the cache again
22:36:56 <Gracenotes> gjl: oh, there's a tuple instance for Ix
22:37:22 <Veinor> wouldn't it just be, like, [[Int]]?
22:37:38 <Gracenotes> for (Ix a, Ix b) => Ix (a, b) and up. does index calculations and whatnot. if you want jagged arrays you'll have to actually have them nested
22:37:55 <mmorrow> so basically generational is just "promoting" data that survives some number of first-generations to an older generation, or variation of that
22:38:08 <Gracenotes> Array (Int, Int) e: index calculations. Array Int (Array Int e): nested, allowing jagged arrays
22:38:15 <gjl> I see. Thanks. The latter won't be necessary.
22:38:15 <mmorrow> and once you fill the first generation, you need to collect the older one(s)
22:40:40 <Gracenotes> mmorrow: hm. What is a generation, conceptually? I understand if contains means to access the data somehow. What is it fundamentally, though?
22:41:12 <mmorrow> it's just a logical (and maybe physical) partition of the heap
22:41:30 <Gracenotes> gjl: access for tuples are like 'arr ! (3, 2)'. To create them, a range like ((0, 0), (9, 9)) should be specified. using an operation like // requires copying all n*m(*...) elements
22:41:47 <mtnviewmark> a generation is all the objects created after a certain time, but before the time of the next lower generation
22:42:26 <mmorrow> Gracenotes: and if everything is immutable, you know that there can't be any pointers from an older gen into a newer gen
22:42:42 <Gracenotes> hm. so it *is* the heap? how can it operate without physical partitioning?
22:42:43 <mmorrow> you need to track mutable things
22:42:58 <Gracenotes> mmorrow: hm, not even with lazy updates?
22:43:09 <Gracenotes> hm, I suppose those would count as mutable
22:43:45 <mtnviewmark> one normall *does* track it by partitioning the address space
22:43:59 <mmorrow> void *heap = malloc(SIZE_OF_GEN_0 + SIZE_OF_GEN_1); #define GEN_1(off) (heap+SIZE_OF_GEN_0+off) ..
22:44:41 <mmorrow> also you might have a place (logical, physical, or both) for large objects too
22:44:54 <mmorrow> like 100000 element arrays
22:45:03 <mmorrow> and you don't copy those
22:45:14 <mtnviewmark> and, sometimes separate areas for very common small sizes
22:45:36 * mtnviewmark has written several GCs
22:46:09 <Gracenotes> neat. I'm a bit fuzzy on the generation-copying steps, and even when they happen, but that's what the algorithm's about, I should think :)
22:46:15 <mmorrow> mtnviewmark: neat, for what?
22:46:31 <mmorrow> Gracenotes: you should get the gc book by jones
22:46:37 <mtnviewmark> worked on the GC for Smalltalk on mac w/Dan Ingalls
22:46:56 <dblhelix> morning #haskell
22:47:02 <mtnviewmark> then worked on GC for Glyphic Script (a little known langauge)
22:47:26 <mmorrow> mtnviewmark: oh cool, i've browsed through the gnu smalltalk compiler now and again, smalltalk is pretty neat
22:47:37 <mtnviewmark> worked on the design of a HW assisted GC for Java
22:47:50 <mmorrow> mtnviewmark: hardware-assisted how?
22:48:00 <mtnviewmark> write-barriers
22:48:01 * Gracenotes looks at the book details
22:48:05 <mmorrow> like protecting
22:48:06 <mmorrow> ah cool
22:48:11 <mtnviewmark> read-barriers
22:48:40 <Gracenotes> oh, this seems like a nice glossary. http://www.iecc.com/gclist/GC-algorithms.html
22:48:42 <mmorrow> mtnviewmark: for tracking writes to arrays and stuff?
22:49:14 <mtnviewmark> well, any writes - lets you know if you need to re-scan blocks
22:49:23 <mtnviewmark> if you're running GC and mutator at same time
22:49:59 <mtnviewmark> twas almost a decade ago, I've probably forgotten all the details  :-(
22:51:21 <mmorrow> mtnviewmark, Gracenotes: i've got this txt file up here (since i couldn't find it online anywhere, it's in the code for this jvm), it's a description of their gc, i find it interesting http://moonpatio.com/repos/gc-intf.txt
22:52:11 <mtnviewmark> Yes, the Train
22:52:18 <mmorrow> ah cool
22:52:57 <mtnviewmark> There is a classic overview of GC techniques from U.Texas
22:53:14 <Gracenotes> this JVM as in current JRE?
22:53:16 <mtnviewmark> available online as PDF - worth reading, if this stuff interests you
22:53:23 <kmc> "using an operation like // requires copying all n*m(*...) elements" gjl, Gracenotes if you're doing this a lot, DiffArray may perform better
22:54:03 <Gracenotes> in those cases, I tend to just go for STArray or IOArray
22:54:13 <kmc> if you're doing it a lot *and* don't care about persistence of old versions, a mutable array like STArray is a good choice
22:55:09 <mmorrow> mtnviewmark: nice, i'll check that out
22:55:25 <Gracenotes> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays has a good summary of performance tips and tricks for array manipulation (e.g., freezing and thawing)
22:55:46 <jmcarthur> DiffArray doesn't really give you many of the advantages of pure code. e.g. using old versions requires reconstructing the whole array, just as if you had reconstructed it upon mutating it in the first place
22:56:01 <mmorrow> Gracenotes: not the/a sun jvm
22:56:32 <jmcarthur> and if you are never going to use old versions you almost might as well have just used ST or IO in the first place
22:56:35 <Gracenotes> ah. there are several..
22:57:08 <Gracenotes> and even if you do use the old versions, maybe ST or IO with freezing/thawing is worth a shot ;)
22:57:27 <Gracenotes> mtnviewmark: would it be "Uniprocessor Garbage Collection Techniques"?
22:57:35 <mtnviewmark> bingo - that's the one
22:57:58 <Gracenotes> they have an entire folder full of garbage! ftp://ftp.cs.utexas.edu/pub/garbage/
22:58:16 <jmcarthur> wait, thawing?
22:58:32 <copumpkin> what about it?
22:58:41 * jmcarthur has never once used ST enough to learn everything about it
22:58:56 <copumpkin> it's very unsafe unless you provide guarantees in some other way :)
22:59:04 <jmcarthur> okay, that's what i was thinking
22:59:04 <kmc> "everything" is probably a lot
22:59:19 <Gracenotes> thawing is quite nice. it's explicitly unsafe thawing that is, uh, unsafe.
22:59:20 <jmcarthur> i had never even heard about thawing
22:59:43 * jmcarthur checks the docs
22:59:55 <Gracenotes> all it is is converting mutable -> immutable and immutable -> mutable. You can do that unsafely, without copying, if you can make some guarantees.. but this is the odd case out
23:00:51 * jmcarthur can't find the relevant function(s)
23:01:14 <jmcarthur> ah, found it
23:01:27 <jmcarthur> oh, safe thawing is just making a copy
23:01:37 <mtnviewmark> at the risk of repeating myself: anyone have a nomination for an excellent example of Haddock documentation for a library? I'm looking to learn by imitating!
23:01:41 * jmcarthur isn't even sure he would call that "thaw"
23:05:19 <kmc> @hoogle newIOURef
23:05:19 <lambdabot> No results found
23:06:22 <jmcarthur> in my opinion, the best documentation is a good semantic model
23:06:38 <jmcarthur> if that can really be called documentation at all
23:07:07 <jmcarthur> examples are really underused in a lot of documentation
23:07:13 <jmcarthur> *also
23:07:16 <mtnviewmark> well, yes, but I was after a good example of the mechanics with Haddock!
23:07:22 <jmcarthur> ah, i see
23:07:40 <jmcarthur> so you mean typographically good documentation
23:07:46 <mtnviewmark> That is, I know how to say it - the question is, what is a good example of how to pour it into Haddock
23:07:48 <c_wraith> prelude might be your best bet
23:08:02 <jmcarthur> yeah, prelude
23:08:39 <c_wraith> err, Prelude's short, since it's mostly imports
23:08:45 <c_wraith> but something in the standard lib
23:09:38 <c_wraith> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
23:09:42 <c_wraith> that, for instance
23:11:13 <mtnviewmark> ugh - do people like that the comment for each function starts "The 'fooFunc' ..."
23:12:37 <copumpkin> nope
23:12:39 <copumpkin> I don't
23:18:47 <travisbrady> what sort of function would I have to write if i want to wrap a few different functions in an Either where Left is an error and right might be a string, an int or a list of strings
23:19:17 <travisbrady> i'm parsing a simple string like "error: blah" or "stringlist: a,b,c" or "int: 99"
23:20:30 <travisbrady> i have functions that parse the 3 separate types, but i want to wrap it in an Either but can't think how to do it in one function w/o making a new type to which all result types belong. or maybe with a typeclass
23:21:06 <mtnviewmark> meaning you have   f :: a -> b    and you want f' :: (Either String a) -> (Either String b)
23:21:06 <mtnviewmark> ?
23:21:47 <copumpkin> @type \f -> id +++ f
23:21:49 <lambdabot> forall b b' c'. (b' -> c') -> Either b b' -> Either b c'
23:22:13 <travisbrady> I think i want f1 :: String -> Int, f2: String -> [String]
23:22:31 <mtnviewmark> oh no, here we go again with the magical triplet operators....
23:22:40 <travisbrady> and i want: String -> Either (the above stuff)
23:23:17 <travisbrady> @hoogle +++
23:23:17 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
23:23:18 <lambdabot> Text.Html (+++) :: (HTML a, HTML b) => a -> b -> Html
23:23:18 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
23:23:18 <copumpkin> oh wait
23:23:24 <copumpkin> @type right
23:23:26 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
23:23:31 <copumpkin> even simpler
23:23:42 <mtnviewmark> so you have f :: String -> a   and you want f :: String -> Either String a
23:23:52 <copumpkin> @type right :: (a -> b) -> (Either String a) -> (Either String b)
23:23:54 <lambdabot> forall a b. (a -> b) -> Either String a -> Either String b
23:24:22 <travisbrady> mtnviewmark: yes
23:24:38 <mtnviewmark> why isn't it just    Right . f
23:24:39 <mtnviewmark> ?
23:24:49 <copumpkin> that doesn't accept a Right
23:24:59 <copumpkin> oh, you mean the function he actually wants :)
23:25:00 <mtnviewmark> i don't think he wants to
23:25:14 <copumpkin> :t \f -> Right . f
23:25:16 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f a -> f (Either a1 a)
23:26:13 <kmc> :t (+++)
23:26:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:27:37 <kmc> isn't "\f -> id +++ f" just fmap?
23:29:04 <tensorpudding> @pl \f -> id +++ f
23:29:05 <lambdabot> (id +++)
23:29:40 <travisbrady> gosh, what does +++ do?
23:29:53 <tensorpudding> @type (id +++)
23:29:54 <lambdabot> forall b b' c'. (b' -> c') -> Either b b' -> Either b c'
23:30:31 <Asztal> :t (+++) -- that says enough
23:30:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:30:51 <GNU\colossus> I have a list of Int, and want to know the _positions_ of all instances of one specific Int in that list. can anyone of you help me doing that?
23:33:13 <kmc> GNU\colossus, pair each element with its position.  then filter the pairs where the value matches.  then extract the positions.
23:33:58 <travisbrady> > map fst . filter (\(x,y) -> x==1) $zip [1,2,1,2,1,2,3,4,1,2,1] [0..]
23:33:59 <lambdabot>   [1,1,1,1,1]
23:34:15 <travisbrady> > map snd . filter (\(x,y) -> x==1) $zip [1,2,1,2,1,2,3,4,1,2,1] [0..]
23:34:16 <lambdabot>   [0,2,4,8,10]
23:34:16 <mtnviewmark> snd.
23:34:20 <travisbrady> yep
23:35:17 <GNU\colossus> ah, neat. I was suspecting that I'd have to do sth. like that, but had no idea how to pull it off :)
23:35:21 <tensorpudding> laziness is nice
23:35:54 <GNU\colossus> what does "$" do in the above example?
23:36:12 <tensorpudding> @src ($)
23:36:13 <lambdabot> f $ x = f x
23:36:18 <GNU\colossus> ah
23:36:49 <tensorpudding> basically, it applies the thing on the left to the thing on the right, but it has very low precedence
23:37:20 <mtnviewmark> > let select bs as = map snd (filter fst (zip bs as)) in select (map (=1) [1,2,1,2,1,2,3,4,1,2,1] ) [0..]
23:37:21 <lambdabot>   <no location info>: parse error on input `='
23:37:21 <tensorpudding> it allows you to avoid using parentheses in some places, and makes things more readable
23:38:21 <mtnviewmark> > let select bs as = map snd (filter fst (zip bs as)) in select (map (==1) [1,2,1,2,1,2,3,4,1,2,1] ) [0..]
23:38:23 <lambdabot>   [0,2,4,8,10]
23:38:34 <mtnviewmark> I was assuming that there was a select like function
23:38:41 <mtnviewmark> but couldn't find one
23:40:38 <BMeph> > findIndices 1  [1,2,1,2,1,2,3,4,1,2,1]
23:40:39 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
23:40:39 <lambdabot>    arising from the lite...
23:40:47 <BMeph> > findIndices  [1,2,1,2,1,2,3,4,1,2,1] 1
23:40:48 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
23:40:48 <lambdabot>         against inferred ...
23:41:21 <mtnviewmark> :t findindices
23:41:22 <lambdabot> Not in scope: `findindices'
23:41:34 <mtnviewmark> :t findIndices
23:41:35 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
23:41:46 <BMeph> > findIndices (==1)  [1,2,1,2,1,2,3,4,1,2,1]
23:41:47 <lambdabot>   [0,2,4,8,10]
23:42:12 <BMeph> Much better. Thanks. :)
23:42:21 <mtnviewmark> @hoogle (a -> Bool) -> [a] -> [Int]
23:42:21 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
23:42:22 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
23:42:22 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
23:42:34 <mtnviewmark> guess hoogle would have found it!
23:44:31 <BMeph> :t (<$>(?fa))
23:44:32 <lambdabot> forall a b (f :: * -> *). (?fa::f a, Functor f) => (a -> b) -> f b
23:44:53 <BMeph> Look, it's Perl6! ;p
23:45:33 <dmead> @hoogle catch
23:45:33 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
23:45:33 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
23:45:33 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
23:45:35 <tensorpudding> pugs?
23:45:40 <dmead> @hoogle evaluate
23:45:40 <lambdabot> Control.Exception evaluate :: a -> IO a
23:45:41 <lambdabot> Control.OldException evaluate :: a -> IO a
23:45:41 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
23:47:38 <tensorpudding> it's possible to produce obfuscated haskell too
23:49:09 <dmead> anybody know a decent way to catch an pattern match exception?
23:49:17 <dmead> i think my method is getting to convoluted
23:49:54 <Gracenotes> tensorpudding: although for true obfuscation, a combinator approach is limited, since you can just substitute the combinators :)
23:53:36 <mtnviewmark> Is there no simple way to specify my tests for my library in the .cabal file?
23:54:10 <mtnviewmark> the cabal doc for setup test is somewhat terse!
