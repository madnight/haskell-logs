00:02:50 <MariusAZ> Anyone here got ghc running through macports on 10.6?
00:03:21 <mtnviewmark> I have it running via Haskell Platform
00:03:49 <MariusAZ> I have a bunch of dependencies that rely on it in Macports but it seems to be broken on 10.6
00:04:13 <mtnviewmark> hmmm... broken as it installs, but doesn't run?
00:04:17 <mtnviewmark> or fails when running
00:04:28 <mtnviewmark> are you on a 64-bit capable processor?
00:04:31 <MariusAZ> Won't even install, says (Not Supported)
00:04:35 <MariusAZ> on 10.6
00:04:48 <mtnviewmark> oh...
00:05:11 <MariusAZ> So, whoever maintains it needs to update it I think, but I can't figure out the maintainer of that port
00:05:41 <mtnviewmark> Ah - krunk - can't help there ---
00:06:00 <mtnviewmark> I did figure out how to get GHC to be happy on a 10.6 install on a 64-bit capable processor machine
00:07:04 <MariusAZ> You wouldn't by chance have a link with instructions do you?
00:07:36 <MariusAZ> if not, that's ok, I can figure it out :)
00:09:27 <mtnviewmark> I'm figuring out where to put it in the Haskel wiki right now
00:09:34 <mtnviewmark> BUT - I can stick it in a paste bin
00:11:29 <mtnviewmark> MariusAZ: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12858#a12858
00:11:46 <MariusAZ> Thank you so much :)
00:42:34 <jl_2> are there any plans to remove the "possibly incorrect indentation" message from ghc's "parse error" messages?
00:43:06 <jl_2> it's kind of confusing, because most of the time when I get that error it has nothing to do with indentation
00:48:18 <Cale> Well, it's hard for GHC to tell whether or not it's really an indentation problem or if it's something else.
00:49:01 <Cale> I think it only gives that message for problems that are really possible to cause by messing up the indentation though.
00:52:12 <FunctorSalad> missing parentheses iirc
01:08:01 <FunctorSalad> "    A pattern type signature cannot bind scoped type variables `a'
01:08:01 <FunctorSalad>       unless the pattern has a rigid type context" <-- :( how to rigidify it? putting a sig around the whole `case' doesn't seem to do anything
01:40:35 <FunctorSalad> hmm I'm trying to `darcs pull' ghc, and it's taking very long for 260 patches... should I wait?
01:40:45 <FunctorSalad> (it's stuck at 80/260)
01:52:27 <SimonRC> FunctorSalad: surely ghc is made of more than 260 patches?
01:56:04 <FunctorSalad> SimonRC: just updating
02:04:19 <Phyx-> Hi, does anyone know if ticky-ticky profiling works in 6.10.4? i get a linker error " cannot find -lHSrts_t"
02:05:29 <ksf> you have to enable it while building ghc
02:05:41 <ksf> ...or, well, the rts, and that's built alongside ghc
02:06:27 <ksf> also, if you do ghc --info, you most likely won't find "t" listed under "ways"
02:06:57 <Phyx-> aha
02:07:18 <Phyx-> you're right
02:07:24 <Phyx-> hmm why isn't it always build in?
02:07:35 <SimonRC> too big?
02:08:16 <ksf> because usually it's overkill, compared to vanilla profiling and inspecting core?
02:08:24 <Phyx-> aha
02:08:39 <Phyx-> btw, do you know what exitfailure 127 is
02:08:50 <Phyx-> when compiling with O2 i get that error
02:08:59 <Phyx-> ghc failed to compile ExitFailure 127
02:09:08 <ksf> try -v
02:09:27 <ksf> 127 is maxbound of a signed byte
02:11:07 <Phyx-> hmm, that's odd, even doing -v triggers it. maybe it's just ghc-core
02:34:53 <ksf> TH needs some love.
02:35:25 <ksf> word and float constants, bang patterns, SCC pragmas...
02:35:25 <ksf> I bet there's a lot more still.
02:35:57 <ksf> also, stage restrictions are way too restrictive
02:36:06 <ksf> especially everything that requires separate modules
02:36:15 <_TH_> hmm I just built the current 6.12 source... when trying to run something (a cabal Setup.hs here), I get:
02:36:30 <_TH_> Setup: fd:5: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
02:36:30 <_TH_> *** glibc detected *** ./Setup: double free or corruption (!prev): 0x098953a0 ***
02:36:32 <_TH_> :(
02:36:48 <_TH_> (...backtrace, memory map)
02:37:09 <ksf> source not in utf-8 or something?
02:37:26 <ksf> they _did_ replace the whole IO lib
02:37:41 <_TH_> it's just the default Setup.hs
02:37:53 <_TH_> or do you mean some other source?
02:38:36 <ksf> I'm just making incompetent, wide guesses.
02:38:49 <ksf> #ghc knows more about that stuff
02:38:50 <lunabot>  luna: Not in scope: `ghc'
02:39:46 <ivanm> heh
02:40:03 <_TH_> #ghc: "Please ask user questions in #haskell"
02:40:04 <lunabot>  luna: parse error on input `|]'
02:40:20 <_TH_> hello lunabot
02:41:54 <ksf> FunctorSalad, compiling pre-release headers makes you a voluntary developer.
02:42:03 <ksf> s/headers/sources
02:43:03 <_TH_> :)
02:44:40 <ivanm> hmmm.... is there a nice way of checking if two values are both Nothing?
02:45:38 <dschoepe> ivanm: v1 `mplus` v2 == Nothing
02:45:47 <_TH_> hehe
02:45:50 <ivanm> ooohhhh...
02:45:51 <ivanm> nice!
02:45:59 <ivanm> @src Maybe mplus
02:46:00 <lambdabot> Nothing `mplus` ys = ys
02:46:00 <lambdabot> xs      `mplus` ys = xs
02:46:03 <_TH_> all isNothing
02:46:22 <Phyx-> hm, doesn't ghc have to do inlining when i use the inlining pragma?
02:47:40 <ivanm> @hoogle mplus
02:47:40 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
02:51:31 <ivanm> dschoepe: bah, doesn't work since they're of different types :(
02:54:10 <_TH_> @ty (\a b -> case (a,b) of { (Nothing,Nothing) -> True; _ -> False })
02:54:11 <lambdabot> forall t t1. Maybe t -> Maybe t1 -> Bool
02:54:26 <_TH_> :p
02:59:55 <EnglishGent> can anyone recommend a good explanation of Haskell's type-inference algorithm?
03:00:04 * EnglishGent trying to understand how it works in greater depth
03:00:50 <shrughes> I don't think the Haskell standard specifies an _algorithm_ so to speak
03:01:16 <Phyx-> hmmm how can i speed this up some http://phyx.pastebin.com/d16b03ecc according to the site it took ~3.52seconds which is way too much
03:01:24 <_TH_> it's written as a riddle...?
03:01:57 <blackdog> EnglishGent: http://en.wikipedia.org/wiki/Type_inference#Hindley-Milner_type_inference_algorithm
03:02:03 <EnglishGent> thanks blackdog :)
03:02:20 <blackdog> may be helpful, although it doesn't handle typeclasses
03:02:32 <blackdog> further keywords would be unification
03:02:42 <EnglishGent> hi shrughes, Phyx-, _TH_ :)
03:03:05 <Phyx-> wtf just happened
03:03:24 <EnglishGent> hmm .. how it behaves w.r.t. Type classes - especially MP Type classes is exactly what I'm trying to understand
03:04:20 <shrughes> Phyx-: according to _what_ site?
03:04:41 <Phyx-> shrughes: codechef.com
03:05:05 <Phyx-> locally it runs much faster
03:05:09 <Phyx-> infact, i get 0s flat
03:05:10 <Phyx-> so
03:05:28 <blackdog> Phyx-: which site?
03:05:44 <blackdog> if they're reasonably sized integers it might be worth specialising to Int
03:05:44 <Phyx-> blackdog: codechef.com
03:06:09 <shrughes> what is this, showing how many zeros are at the end of the factorial?
03:06:12 <Saizan> EnglishGent: do you have some doubt in particular?
03:06:53 <Saizan> EnglishGent: however "Typing Haskell in Haskell" might help, even if the paper doesn't cover MultiParam ones the code should
03:07:02 <Phyx-> blackdog: range is 1 to 1billion
03:07:08 <FunctorSalad> twos and fives *cough*
03:07:11 <Phyx-> shrughes: yup
03:07:16 <EnglishGent> not really Saizan - I've just started playing around with them and are finding the behaviour somehwat confusing - most of my code works, but bits dont behave as I'd expect
03:07:26 <blackdog> Phyx-: got a link to the question?
03:07:34 <Phyx-> http://209.62.85.45/problems/FCTRL
03:07:41 <EnglishGent> quicksilver explained it a bit to me yesterday, but I said then I'd have to go into it in greater depth
03:07:57 <EnglishGent> thans for the reference btw :)
03:08:43 <shrughes> Phyx-: it is a mystery; are they including compile time?
03:09:05 * EnglishGent was playing around with overloading various operators to work on things other than list - so for example redefining ++ so its of type [x] -> [x] -> [x] & IO [x] -> IO [x] -> IO [x], etc
03:09:32 <EnglishGent> it all works quite nicely - but I cant seem to figure out how to get map to behave the way I'd like it to - or indeed - if it's possible at all
03:09:46 <shrughes> how would you like map to behave?
03:09:48 <FunctorSalad> uh TSP is NP-hard but there are algorithms that work way better in practice than searching all N! solutions
03:10:01 <Saizan> well for MP without fundeps the most surpising aspect is that instance resolution never instantiates variables more than what they are already, so you get those weird errors like "No instance for Foo Bar a"
03:10:02 <FunctorSalad> (@ problem text, even if irrelevant to problem)
03:10:11 <Phyx-> shrughes: no idea, i'm peeking at the FAQ now
03:10:12 <Saizan> when you e.g. have instance Foo Bar Baz
03:10:28 <EnglishGent> that's exactly the sort of thing I'm running into Saizan
03:10:40 <EnglishGent> only I dont yet really understand *why*
03:11:10 <shrughes> Phyx-: have you tried running it again?  Maybe it's a one-time server hiccup
03:11:48 <Phyx-> yeah i'm gonna try now
03:11:55 <Phyx-> they just updated the servers
03:11:59 <Phyx-> and i'm getting random bugs
03:12:05 <Phyx-> so it could be it's not stable yet
03:12:30 <shrughes> Maybe it's running in a VM implemented in pure Java running Windows ME
03:12:47 <Saizan> EnglishGent: essentially because of the open world assumption, you could later define an instance Foo Bar X, and since it doesn't know anything about 'a' how should it choose between Foo Bar X and Foo Bar Baz instances?
03:13:06 <mreh> there must be a neat trick I can use to make a simple way of creating a random walk within an upper and lower bound
03:13:09 <Phyx-> shrughes: lol, that's a stretch
03:13:11 <FunctorSalad> apparently TSP can be solved for N in the tens of thousands
03:13:18 <mreh> it's like backtracking, but not
03:13:33 <FunctorSalad> "An exact solution for 15,112 German towns from TSPLIB was found in 2001 using the cutting-plane method proposed by George Dantzig, Ray Fulkerson, and Selmer Johnson in 1954, based on linear programming."
03:13:47 <EnglishGent> I guessed it had something to do with the open world assumption - but the details still elude me
03:13:56 <FunctorSalad> "the current record, solving an instance with 85,900 cities, see Applegate (2006)"
03:14:13 <FunctorSalad> quite impressive
03:14:17 * EnglishGent has only been using Haskell for 5-6 weeks & is still trying to wrap his head round it :)
03:14:19 <EnglishGent> very!
03:14:22 <EnglishGent> hi FunctorSalad :)
03:14:42 <FunctorSalad> hey
03:15:17 <EnglishGent> is there a way to force a particular class to adopt the closed world assumption? an language extension or something? it would seem to me to be useful in practice in various places (I agree open should be the default, but sometimes I *know* what the complete list of methods will be)
03:15:22 <Phyx-> shrughes: got the exact same time
03:15:23 <Saizan> also, basically, the system is designed so that it resolves the instances only if there's an unique solution, otherwise the overloading would be too "ad-hoc"
03:15:23 <Phyx-> lol
03:15:26 <shrughes> okay
03:15:27 <Phyx-> 3.78secs
03:15:38 <Phyx-> odd
03:15:43 <Phyx-> i still get 0s flat
03:15:51 <Phyx-> for any input on my system
03:15:55 <Phyx-> lemme ask quickcheck for 500
03:16:05 <Saizan> EnglishGent: you mean complete list of instances?
03:16:13 <EnglishGent> yes :)
03:16:22 <blackdog> Phyx-: same here
03:16:28 <FunctorSalad> EnglishGent: closed worlds can be done with GADTs
03:16:42 <FunctorSalad> then you can wrap it in a class
03:16:44 <EnglishGent> ah - I've heard of GADTs but have read about them yet
03:16:53 <EnglishGent> as I said I'm still rather new to the language :)
03:17:05 <EnglishGent> any recommend starting points? :)
03:17:21 <EnglishGent> havent read about them*
03:17:41 <FunctorSalad> EnglishGent: data IsThing a where IsInt :: IsThing Int; IsTuple :: IsThing (a,b)
03:17:54 <FunctorSalad> defines a closed world consisting of Int and all tuple types ;)
03:17:58 <FunctorSalad> silly example
03:18:10 <shrughes> Phyx-: if the input is restricted to less than a billion I would just blame the server
03:18:27 <shrughes> Unless it's inputting 3 seconds worth of test cases.
03:18:47 <Phyx-> shrughes i just did a quickchek
03:18:50 <Phyx-> with 100 values
03:18:53 <Phyx-> took 0.14secs
03:18:55 <FunctorSalad> s/tuple/pair
03:19:09 <shrughes> Phyx-: so, what if they're using 3000 values
03:20:05 <EnglishGent> an example of the kind of problem I'm trying to solve ... I've defined takeWhileM :: (Monad m) => (a -> m Bool) -> [a] -> IO [a]
03:20:19 <ksf> ...there's no performance difference whatsoever between buffering 1024 bytes for output or buffering 4096 or even more bytes for output
03:20:32 <EnglishGent> now I'm wondering - can I overload takewhile to work in both cases - rather than needing two seperate functions
03:20:48 <Phyx-> shrughes: trying
03:20:55 <EnglishGent> I've manage to overload ++, head, tail, take, etc to work in 'pure' & monadic cases
03:21:00 <ksf> ...It really surprises me, as the total output size is 230megs
03:21:07 <EnglishGent> but some functions currently leave me stumped
03:22:04 <shrughes> How do you overload head to work in 'pure' & monadic cases?
03:22:18 <EnglishGent> class Head x y where
03:22:20 <ksf> ...and TH is being very successfull in keeping me from profiling the rest of the code
03:22:22 <EnglishGent>   head :: x -> y
03:22:37 <EnglishGent> instance Head [x] x wheer head = head
03:22:43 <shrughes> what does  head [[1]]  return?
03:22:53 <EnglishGent> instance Head (IO [x]) (IO x) where head = liftM head
03:22:54 <EnglishGent> etc
03:22:54 <ksf> [1]
03:22:58 <shrughes> what does  head [[1], [2]]  return?
03:22:59 <shrughes> actually
03:23:12 <Saizan> > head [[1],[2]]
03:23:12 <ksf> [1]
03:23:13 <lambdabot>   [1]
03:23:17 <EnglishGent> [1]
03:23:22 <shrughes> ksf: i'm not asking what Prelude.head returns
03:23:37 <shrughes> EnglishGent: but [] is a monad so shouldn't it return [1, 2]?
03:23:40 <ksf> well, that's what any head should return
03:23:45 <EnglishGent> I delibretely did it this way to *avoid* the problem that list is a monad
03:23:52 <Saizan> EnglishGent: functional dependencies could also help, in these cases
03:24:07 <ksf> head is [a] -> a, not [[a]] -> a
03:24:08 <shrughes> EnglishGent: basically you're making the world a worse place :P
03:24:27 <ksf> ...that didn't make much sense.
03:24:31 <Phyx-> shrughes: +++ OK, passed 3000 tests.
03:24:31 <Phyx-> (2.93 secs, 54494408 bytes)
03:24:43 <ksf> but, trust me shrughes, I believe your head would be a bad idea.
03:24:43 <shrughes> ksf: sure but if head :: IO [a] -> IO a then it should Monad m => m [a] -> m a in the same way
03:25:01 <ksf> that's fmap head
03:25:13 <shrughes> ksf: I'm talking about EnglishGent's head which I think shouldn't exist
03:25:31 <shrughes> heh
03:25:32 <ksf> and [IO a] -> IO a is sequence, too.
03:25:42 <dobblego> [IO a] -> IO [a]
03:25:48 <ksf> ...which I think you are confusing head with
03:25:55 <ksf> well, sequence_
03:26:01 <ksf> at least the semantics are quite the same
03:26:03 <shrughes> ksf are you reading what EnglishGent is writing?
03:26:10 <Saizan> ?type sequence_
03:26:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
03:26:22 <ksf> [a] gives raise to more than one monad
03:27:14 <ksf> and I'm not convinced that all monads are head'able, anyway.
03:27:15 <EnglishGent> no I intensionally _avoided_ generalising to moands - as that _would_ cause things to not work properly shrughes
03:27:32 <shrughes> EnglishGent: ok but you shouldn't generalize at all
03:27:50 <Saizan> shrughes: let him play with typeclasses :)
03:27:56 <Saizan> it's fun :)
03:28:13 <EnglishGent> I am just playing around at the moment - I freely admit I am
03:28:14 <shrughes> fine, generalize away
03:28:23 <EnglishGent> how else am I supposed to learn the language? :)
03:28:23 <shrughes> i promise not to cut off your head even though i think it shouldn't exist
03:28:55 <Saizan> EnglishGent: so, how does you map look like?
03:29:23 <Saizan> ah, no, it was takeWhile the problem?
03:30:07 <EnglishGent> yes Saizan - my head works fine :)
03:30:23 <EnglishGent> it's takeWhile that I cant persuade (yet) to behave itself
03:30:37 <EnglishGent> also map & other similar cases
03:31:24 <Saizan> ?type takeWhile
03:31:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:32:08 <Saizan> class TakeWhile x xs where takeWhile :: (x -> Bool) -> xs -> xs ?
03:32:30 <Saizan> or even more general?
03:32:33 <EnglishGent> I'd like to be able to have it as *also* forall a. (a -> IO Bool) -> [a] -> IO [a]
03:32:48 <Saizan> class TakeWhile x xs ys where takeWhile :: (x -> Bool) -> xs -> ys, then
03:33:05 <Saizan> oh
03:33:42 * EnglishGent is trying to reduce the need to write multiple copies of things to work in pure & monadic cases
03:34:36 <Saizan> well, you can write only the monadic cases and then use the Identity monad :)
03:35:15 <EnglishGent> I've already learn that trick :)
03:35:44 <EnglishGent> I just thought it would be more elegant if you could write code that works in both cases - and now with head, tail, ++, reverse, take, drop, etc -- I can :)
03:35:45 <Saizan> class TakeWhile x b xs ys | xs -> x , ys -> x where takeWhile :: (x -> b) -> xs -> ys -- i'd add those fundeps, they should help some
03:35:53 <EnglishGent> I just cant extend it to the other cases :|
03:36:22 <EnglishGent> ty :)
03:36:24 <Saizan> mmh, i fear to see the types of a complex expression using such overloading though :)
03:36:40 <EnglishGent> yes - I have noticed that's one drawback!
03:36:41 <Phyx-> +++ OK, passed 3000 tests.
03:36:56 <Phyx-> oops
03:36:57 <Phyx-> sorry
03:41:29 <Phyx-> shrughes: even running quickCheckWith (stdArgs { maxSuccess = 3000 }) (forAll (choose (100000,1000000000000000)) (\x->(loop 5 x)>= 0)) doesn't take more than 2.5secs interpreted
03:41:34 <Phyx-> i think that site is screwed up
03:41:47 <Phyx-> or I/O is really slow
03:45:01 <rwx> did many of you learn haskell in school?
03:45:12 <Phyx-> i did
03:50:19 * EnglishGent is learning it by himself - wasnt covered when I was at uni (we did ML though)
03:51:01 <medfly> not me
03:51:13 <skorpan> i still don't know haskell, but i did take courses on it
03:51:24 * Botje got a haskell course when he already knew it for a year
03:51:47 <ivanm> I did, to the extent that I taught myself after a lecturer recommended it to me
03:51:59 <ivanm> and then I used it whenever I could
03:52:04 <ivanm> Botje: so you aced it?
03:52:26 * Phyx- thinks these assignments marked easy are too easy...
03:52:45 * EnglishGent gives Phyx- a bunch of millenium problems
03:52:46 <EnglishGent> :)
03:52:48 <Botje> i got 19.5 out of 20
03:53:06 <Botje> i guess they didn't want to give me a 20 :)
03:53:08 <Phyx-> EnglishGent: lol
03:53:13 <medfly> I don't think anyone taking something else besides mathematics and CS would find out about Haskell in uni
03:53:29 <medfly> s/and/or/
03:53:43 * Phyx- has seen a few Astrology students taking haskell
03:53:47 * EnglishGent tries to think up a good reason to inflict it on humanities students
03:53:52 <medfly> heh
03:54:00 <EnglishGent> :)
03:54:07 * Phyx- sends his submission
03:54:13 <Phyx-> Correct Answer
03:54:13 <Phyx-> Execution Time: 0.00
03:54:15 <Phyx-> weee
03:54:15 <Phyx-> lol
03:54:40 <medfly> wow, a thing which runs your homework and tries to see if it's okay?
03:54:46 <ivanm> Botje: heh
03:54:47 <mmmdonuts> EnglishGent, lambda calculus is used in linguistics - there's your excuse right there.
03:55:12 * medfly has to do web programming :(
03:55:26 <EnglishGent> thanks mmmdonuts!
03:55:31 <Phyx-> medfly: i pitty you
03:55:33 <ivanm> Botje: when I did scheme in first year, I lost 2 marks out of 100 for an assigment where we had to provide haskell-like pattern matching to scheme; the reason being that I then did an eval on the code I'd generated and printed a message saying that
03:55:47 <ivanm> the rationale being that you shouldn't do stuff people don't expect you to do
03:56:24 * EnglishGent once (way back in high school) got my answer to an exercise marked wrong becuase I did it properly
03:56:38 <ivanm> heh
03:56:40 <EnglishGent> we were supposed to write a program (in Basic) to calculate the number of days between two dates
03:56:49 * EnglishGent actually accounted for leap years :|
03:56:54 <ivanm> heh
03:57:06 <medfly> heh
03:57:29 <Botje> ivanm: heh heh :)
03:57:30 <EnglishGent> heh
03:57:31 * Phyx- once had to make an assignment in highschool to make a bouncing ball that bounces around. Got points deducted for implementing actual physics
03:57:32 <Botje> metaprogramming ftw!
03:57:34 <ivanm> EnglishGent: when we first learnt differentiation, we were given a problem on the board and told to do it; someone whose brother had taught him beforehand did the problem quickly and took it to the teacher
03:57:37 <EnglishGent> "mwa" ++ cycle "ha"
03:57:49 <ivanm> he was marked wrong, because we were told to do it from first principles ;-)
03:58:23 <medfly> yeah, I have that issue, my sister is learning C in uni now and I'm helping her out sometimes, she always says she can't do something because they haven't taught her about it yet
03:58:24 <EnglishGent> I am of the opinion that certainly in school most math & comp-sci teaching *sucks*
03:58:30 <EnglishGent> :/
03:58:31 <ivanm> medfly: heh
03:58:35 <EnglishGent> I think it's real problem
03:58:43 <ivanm> EnglishGent: school == school or uni/college?
03:58:55 <EnglishGent> school == school ivanm, kids
03:58:59 <ivanm> if the former... you got taught CS at _school_? :o
03:59:14 <ivanm> I barely learnt any CS at uni (I did IT, not knowing there was a difference)
03:59:18 <EnglishGent> yeah - we did some cs at school (age ~14)
03:59:19 <medfly> there is CS in schools here too, sometimes
03:59:28 <medfly> but it's optional
03:59:29 <ivanm> all we did at school was programming in delphi, databases, a bit of AI, etc.
03:59:48 <medfly> it must suck picking the wrong degree and finding out about it when you're sort of done
04:00:02 <RayNbow> back in school when I was about 13/14, I got tired of drawing graphs to find the solution of quadratic equations, so I asked the teacher whether there was an analytical approach... the teacher was kind enough to teach me how :P
04:00:07 <ivanm> no theoretic stuff, unless you include the AI (knowledge bases, virtual neurons, etc.)
04:00:23 <ivanm> medfly: there was no CS degree at my uni (nor at most unis in Australia AFAIK)
04:00:34 <medfly> odd
04:00:37 <Saizan> RayNbow: you should have derived that from the graphs!
04:00:39 <EnglishGent> actually - it was partly that - which resulted in my current overloading mania ... one thing I'm interested in is designing computer languages suitable for children
04:00:40 <ivanm> medfly: you _can_ do CS as a major in IT or in science
04:00:49 <EnglishGent> Haskell is very beautiful - but it's not suitable for that
04:00:57 <EnglishGent> (in my opinion anyway)
04:00:58 <ivanm> (though we didn't have majors in IT when I started, you could just specialise without anything to that effect going on your diploma)
04:01:13 <medfly> here there is "software engineering", I suppose it's the same issue
04:01:14 <ivanm> RayNbow: heh, I did something similar
04:01:34 <RayNbow> Saizan: unfortunately, my math baggage was kinda empty back then :p
04:01:35 <ivanm> my teacher kinda taught me integration a year early, so I used it when we were meant to count-the-squares between some curves
04:01:41 <RayNbow> no way I could have derived that back then :p
04:01:44 <EnglishGent> it's not really medfly - software engineering people do C and OS internals - comp-sci people worry about Kolgomorov complexity
04:01:52 <ivanm> looking back, I'm lucky she marked me right, because I didn't do it very well (notation wise) :s
04:02:26 <ivanm> medfly: well, here, SE == programming + some theory; IT == some programming, less theory and a lot of databases :s
04:02:39 <medfly> :x
04:02:41 <RayNbow> schools need more teachers though that would teach extra things to those who show interest in math
04:02:48 <ivanm> but I did a dual with science with math and phys, so doing SE instead of IT wasn't really an option
04:03:06 <medfly> RayNbow, and how would they afford this, why is maths any more special than arts in that sense? why not have it for any field? etc.
04:03:15 <EnglishGent> www.maa.org/devlin/LockhartsLament.pdf
04:03:24 <EnglishGent> *excellent* article on the state of math teaching
04:03:35 <medfly> personally I'd be happy if locally, schools were treated less like cheap babysitters for parents
04:03:38 <ivanm> RayNbow: here (== most states in Australia, with different names and content) we have in year 11 and 12 an optional higher-level math subject, where we got taught basic group theory, etc. as well as matrices
04:03:44 <medfly> and more like places where you receive an education ^^
04:03:50 <ivanm> which let me skip an extra uni subject, and made another 2 really easy ;-)
04:03:51 <RayNbow> medfly: oh sure, for other fields it's also nice... it's just that I'm personally not interested in those other fields ;)
04:04:12 <ivanm> oh, and I learnt logic/binary through the "logic of propositions" in an extension math subject in mid high school
04:04:23 <medfly> here there is a level division too, smart students can take up more cool things and learn a bit of linear algebra, have more "understanding" than memorising :-p
04:04:28 <RayNbow> ivanm: lucky you
04:04:28 <ivanm> medfly: yeah; it's getting worse here (my mum is a primary school teacher)
04:05:19 <RayNbow> here in the Netherlands there are no optional math subjects (afaik)
04:05:35 <medfly> I pretty much think it's worthless to think about it in my country, since a huge percentage of pupils don't even study in the system but another
04:05:46 <RayNbow> but I was lucky that in my last year of high school, the teacher spent some time on extra stuff like vectors, complex numbers and matrices
04:05:54 <medfly> without government supervision but of course with government budgets :(
04:06:05 <RayNbow> (as a consequence, I could sleep during the first week @ university)
04:06:05 <ivanm> medfly: which country is that?
04:06:12 <ivanm> RayNbow: heh
04:06:28 <EnglishGent> ivanm - I envy you... I wanted to do a course title "futher math" at school - but couldnt - becuase only me & 2 other people wanted to do it - so they wouldnt run the class due to lack of interest :|
04:06:28 <ivanm> RayNbow: I had fun learning vectors three times at school; in physics, maths and chemistry
04:06:43 <RayNbow> hmm... chemistry?
04:06:44 <ivanm> of course, we learnt them in physics first, so we didn't actually know what we were doing till we learnt them properly in maths...
04:06:45 <medfly> ivanm, Israel :-(
04:06:51 <ivanm> EnglishGent: :s
04:06:56 <medfly> which is why, hopefully, if I ever have kids, it'd be at another country ^_^
04:07:07 * RayNbow can't remember any use of vectors in chemistry
04:07:24 <ivanm> EnglishGent: my high school wasn't that big (so the choice of subjects wasn't _that_ large compared to others), but we were in the upper band of academia in terms of student ability so we generally had decent higher-end subjects
04:07:35 <ivanm> RayNbow: to do with bonds, etc.
04:07:38 <medfly> I did study vectors and such in school, but somehow the physics was actually modified so it didn't require an understanding of vectors
04:07:43 <ivanm> molecular kinetics
04:08:12 <medfly> my high school was really, really tiny. I wanted to study physics, so I had to go to another city for it, to another school :x
04:08:13 * RayNbow can't remember much of it p
04:08:16 <medfly> because there was only geography.
04:08:29 <medfly> best school ever, though
04:09:48 <RayNbow> on a side note... I started to really understand vectors just recently... after I had read one of sigfpe's blog posts :p
04:10:40 <ivanm> RayNbow: heh
04:10:52 * ivanm can't even recall the last time he really used vectors...
04:12:13 <chrisdone> EnglishGent: likewise, they wouldn't run the software development version of my course at my uni due to lack of interest in it. I dropped out
04:12:40 <EnglishGent> what was the blog post RayNbow? (curious) :)
04:13:51 <RayNbow> EnglishGent: http://blog.sigfpe.com/2008/08/hopf-algebra-group-monad.html
04:14:11 <RayNbow> but also http://blog.sigfpe.com/2009/05/trace-diagrams-with-monads.html
04:14:27 <EnglishGent> ty :)
04:14:36 <RayNbow> np :)
04:14:44 <EnglishGent> chrisdone :|
04:16:05 <Phyx-> hmm does anyone have any suggestions how to speed this up? http://phyx.pastebin.com/d796f13c2
04:16:41 <Phyx-> hmm first argument can be an Int
04:17:40 <EnglishGent> dont know what your using it for - but I found lazy bytestrings to be much faster than String for processing large amounts of file data
04:17:52 <EnglishGent> (got almost a 200 fold speed increase in my program)
04:18:35 <Phyx-> EnglishGent: it's a small online compo, atmost i'd be reading numbers as long as 10^7
04:19:09 <EnglishGent> np - just though I'd mention in case it helped Phyx- :)
04:19:17 <Phyx-> :)
04:19:24 <Phyx-> could by slowdown be read?
04:20:45 <EnglishGent> dunno - perhaps running a few benchmarks might help? (random suggestion)
04:20:54 <EnglishGent> there's an option to make Haskell time things - I know there is
04:21:03 * EnglishGent cant remember it off hand though
04:21:21 <Phyx-> yeah, I saw another submission by someone
04:21:25 <Phyx-> and he used bytestrings
04:21:30 <Phyx-> which seems to have gotten accepted
04:21:34 <Phyx-> so i'll try that indeed
04:21:47 <EnglishGent> :)
04:31:23 <McManiaC> how do you "branch" with darcs?
04:31:30 <McManiaC> "git branch foo; git checkout foo"
04:31:40 <koeien37> you just make a new checkout
04:32:01 <koeien37> so "darcs get"
04:32:02 <EnglishGent> why does haskell have syntax like "class Num k => VectorSpace k v | v -> k where..." & not "class VectorSpace k v | k -> v => Num k" - the latter would seem more mathematical
04:32:14 * EnglishGent puzzled that the implication arrow seems to go the 'wrong way round'
04:34:24 <ksf> no Num k is the constraint that is a precondition for Vectorspace ... to hold.
04:35:10 <ksf> only if Num k, then it is implied that...
04:35:21 <ksf> granted, it reads more like an exists. or forall.
04:35:53 <ksf> you certainly couldn't derive Num from VectorSpace k v
04:36:07 <Phyx-> ok, changed to bytestring
04:36:08 <Phyx-> test 2
04:36:42 <McManiaC> koeien37: :S okay…
04:36:42 <zygoloid> ksf: no, but you can get an instance of Num k if someone gives you an instance of VectorSpace k v
04:37:08 <koeien37> McManiaC: i would probably not use the branches on git myself
04:37:12 <idnar> yeah, the arrow is the wrong way around
04:37:12 <koeien37> don't think it is very useful
04:37:29 <McManiaC> i love it…
04:37:35 <ksf> ..nope, it isn't.
04:37:48 <zygoloid> it's fine if you think of the arrow as just saying "context goes here"
04:38:03 <EvilTerran> the arrow is pointing the wrong way to read it as implication
04:38:12 <zygoloid> and in types and instances the arrow is really just another form of ->
04:38:14 <koeien37> or, "you need Num before you can even think of instantiating VectorSpace"
04:38:23 <ksf> in the same sense that Integral a, Real b => a -> b doesn't allow you to specify a in terms of b.
04:38:29 <EvilTerran> in "clas Foo k => Bar k", it is predicate-wise the case that "forall k. Bar k => Foo k"
04:38:35 <Codex_> if the arrow were other way around, then people would think it's some kind of inheritance mechanism.
04:38:38 <ksf> ...so Num k can't be specified by Vectorspace k v
04:38:49 <Phyx-> EnglishGent: know why i get "*** Exception: no buffering" when using ByteStrings? It's my first time :P
04:38:50 <ksf> you're confusing usage with definition, there.
04:39:01 <EvilTerran> Codex_, and we'd have to spell less-than-or-equal differently :/
04:39:02 <ksf> the usage case, is, of course, contravariant to the definition.
04:40:06 <chrisdone> any cool haskell talks knocking about recently?
04:40:50 <Phyx-> oh, you can't debug when using ByteStrings in ghci?
04:40:54 <ksf> EvilTerran, exists k. Foo k => Bar k
04:41:43 <EvilTerran> ksf, er, what does that have to do with anything?
04:42:01 <EvilTerran> if that's a statement in predicate logic, i don't see its relevance
04:42:23 <ksf> er exists Foo k
04:42:44 <ksf> that is, (Foo k -> True) -> Bar k
04:43:15 <EvilTerran> "forall x. P(X) => Q(X)" and "exists x. Q(X) => P(X)" are pretty unrelated, aren't they?
04:43:17 <ksf> which has been and always will be my interpretation of Foo k => Bar k
04:43:37 <ksf> indeed, they are.
04:46:01 <EnglishGent> um - are you using Strict or Lazy bytestreams Phyx-?
04:46:32 <sigrid> what's a good way to implement an 'Arbitrary' (QuickCheck) instance for a tree data type?
04:46:57 <Phyx-> EnglishGent: i think it picked lazy
04:49:22 <ivanm> anyone know where the formatting convention of having the "::" aligned with the "=" came from?
04:50:55 <ivanm> preflex: seen roconnor
04:50:56 <preflex>  roconnor was last seen on #haskell 7 hours, 7 minutes and 51 seconds ago, saying: ivanm: sized?
04:51:42 <ivanm> @ask roconnor for withOpacity, is the opacity meant to be 0 <= o <= 1 ?
04:51:43 <lambdabot> Consider it noted.
04:52:43 * ksf thinks :: should be on a new line, indented like usual, and followed by a haddock comment
04:53:25 <ivanm> ksf: on a new line from the function name? :o
04:53:31 <ivanm> so f\n  :: foo ?
04:54:15 <ksf> no f -- ^ my function f\n :: a -- ^ some a \n ...
04:54:58 <blackdog> is there a canonical graph library for haskell? I want a minimum spanning-tree alg and couldn't be bothered implementing Kruskal's again...
04:55:09 <ivanm> ahhh
04:55:11 <ksf> blackdog, hgl
04:55:17 <ivanm> ksf: I generally place the haddock comment _above_ the function
04:55:27 <ksf> works, too.
04:55:29 <ivanm> using -- | or {- | ... -}
04:55:36 <ksf> but documenting the parameters is important
04:55:37 <ivanm> blackdog: see FGL
04:55:43 <ivanm> ksf: not always
04:55:47 <ksf> yep fgl is what I meant
04:55:49 <ivanm> depends on how obvious the params are
04:55:52 <Phyx-> test
04:56:02 <Phyx-> hmm why isn't hoogle responding
04:56:07 <ivanm> blackdog: it's not that great, but it's the best we've got ;-)
04:56:10 <ivanm> @hoogle fgl
04:56:10 <lambdabot> package fgl
04:56:16 <ivanm> Phyx-: *shrug* seems to work...
04:56:19 <Phyx-> @hoogle ByteString Strict
04:56:19 <lambdabot> Did you mean: :: ByteString /count=20
04:56:20 <lambdabot> No results found
04:56:24 <Phyx-> @hoogle ByteString
04:56:25 <lambdabot> module Data.ByteString
04:56:25 <lambdabot> module Text.Parsec.ByteString
04:56:25 <lambdabot> module Text.Regex.Posix.ByteString
04:56:33 <blackdog> righto, i'll try fgl. thanks.
04:56:47 <ksf> it suffers from abstraction leaks, but it's purely functional.
04:57:10 <ivanm> Phyx-: non-lazy == Strict ;-)
04:57:15 <ksf> nodes being ints should really be abstracted away.
04:57:28 <ivanm> blackdog: I've got a bunch of extra funcs for it in graphalyze; not sure if any of them are what you want
04:57:39 <ivanm> ksf: right; Cale and I started work on something like that
04:57:42 <EvilTerran> ivanm, er, isn't non-lazy an evaluation order and strict a semantic property? :P
04:57:46 <ivanm> but we kinda had trouble scheduling times ;-)
04:57:55 <ivanm> EvilTerran: Phyx- was looking for strict bytestrings
04:57:58 <ksf> and all those different node types and difference in contexts and taking a context apart and such needs some cleaning up
04:58:10 <EvilTerran> ivanm, ohhh... yeah, i should read more context
04:58:13 <ivanm> EvilTerran: heh
04:58:26 <blackdog> ivanm: cheers - if FGL doesn't do the business i'll come bother you:)
04:58:38 <ivanm> blackdog: it uses FGL
04:58:40 <Phyx-> ivanm: heh
04:59:04 <blackdog> ivanm: hm. what do i get out of using graphalyze over FGL directly, then?
04:59:17 <ivanm> blackdog: not much if you just want to do stuff
04:59:38 <ivanm> blackdog: graphalyze is aimed more at importing discrete data and analysing it using graphs
04:59:43 <blackdog> gah. it doesn't seem to cope with weighted graphs...
04:59:49 <ivanm> blackdog: so I've just defined a few extra FGL functions
04:59:59 <ivanm> in Data.Graph.Inductive.Algorithms.*
05:00:15 <ksf> blackdog, you can label nodes and edges just fine
05:00:20 <ivanm> blackdog: doesn't it?  I had to write a whole bunch of ones myself because I didn't _want_ to deal with weighted graphs...
05:00:31 <ivanm> blackdog: the node/edge labels are the weightings for some of the algorithms...
05:01:23 <blackdog> ivanm: ah, i get it. that's why there's the Real a constraint on mstree
05:01:31 <ivanm> blackdog: yup
05:02:46 <ksf> class restraints on data types, or too-concrete data types, are harmful.
05:04:01 <blackdog> ksf: yeah, i know. i just missed the labelling being used for weights by msTree
05:04:04 <ivanm> @tell roconnor nvm, worked it out by following the chain of sources (yay for hcolour colourising _all_ sources, not just the exported ones! \o/) to note that opaque is the same as withOpacity 1
05:04:05 <lambdabot> Consider it noted.
05:04:10 <Tobsan> haskell.org is down?
05:04:18 <Tobsan> oh nvm
05:04:22 <ivanm> heh
05:04:24 <Phyx-> is there a call, to tell bytestring to read in N lines at once?
05:04:28 <ivanm> Tobsan: what did you do wrong?
05:04:42 <Tobsan> ivanm: dunno, probably my dns
05:05:26 <blackdog> Phyx-: what's wrong with reading a lazy bytestring, running lines on it, then only taking N?
05:05:30 <ivanm> Phyx-: mapM getLine or something?
05:05:47 <ivanm> blackdog: who says he's using a lazy one? *shrug*
05:05:58 <Phyx-> blackdog: well, EOF isn't send in my case, so getContent never returns
05:06:19 <ksf> :t unfoldrM
05:06:20 <lambdabot> Not in scope: `unfoldrM'
05:06:24 <ksf> hmmm
05:06:27 <ksf> :t unfoldM
05:06:28 <lambdabot> Not in scope: `unfoldM'
05:06:43 <blackdog> ivanm: easy to convert a lazy bytestring into a strict one
05:06:44 <ksf> lazy I/O is evil.
05:07:05 <Phyx-> ivanm: mapM getLine wouldn't be of correct type
05:07:07 <blackdog> ksf: i don't think that's universally true
05:07:13 <ivanm> Phyx-: well, something like that
05:07:20 <ksf> it's usually true.
05:07:21 <ivanm> Phyx-: though that's only stdin
05:07:26 <blackdog> using something like interact to run a space-efficient filter unix filter is a fine idiom
05:07:28 <ivanm> I lie, it isn't
05:07:36 * ivanm thought he saw stdin somewhere
05:07:36 <ksf> I messed up my second attempt on an ebml library with it.
05:07:39 <ivanm> @type sequence
05:07:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:07:46 <ivanm> ksf: ebml?
05:07:53 <blackdog> although i suppose that's doing it line by line
05:07:55 <ksf> the first was unsuccessful, using iteratees, and the third one will be successfull, using iteratees.
05:07:59 <Phyx-> i'm currently reading the lines one at a time
05:08:03 <Phyx-> recursive call to getLine
05:08:08 <ivanm> Phyx-: \n -> sequence . replicate n Bytestring.hGetLine
05:08:11 <ksf> ivanm, http://www.matroska.org/technical/specs/rfc/index.html
05:08:14 <Phyx-> but i think it would be faster to read n lines at once
05:08:26 <ksf> imagine something like xml, but in binary
05:08:30 <Saizan> replicateM btw
05:08:37 <ivanm> oh, and use a concat
05:08:43 <Twey> ksf: Like… binary XML?  :þ
05:08:43 <ivanm> Saizan: duh, didn't think of that
05:08:50 <Phyx-> ivanm: i'll give it a try
05:08:58 <ivanm> Phyx-: \n -> liftM B.concat . replicateM n B.hGetLine
05:09:01 <Twey> http://en.wikipedia.org/wiki/Binary_XML
05:09:06 <Saizan> concat on strict ByteString's is not really fast
05:09:16 <sigrid> how can quickcheck be told to print the cases?
05:09:18 <ivanm> Saizan: heh, was about to say that
05:09:24 <ivanm> sigrid: QC 1 or 2?
05:09:34 <ivanm> QC 1 has verboseCheck, QC2 doesn't :(
05:09:39 <sigrid> QC2
05:09:41 <sigrid> oh
05:09:53 <sigrid> shall I stick to QC1 then...?
05:10:01 <Axman6> QC2 seems pretty damn broken to me
05:10:01 <ivanm> sigrid: there's this hack though: http://www.mail-archive.com/haskell-cafe@haskell.org/msg60028.html
05:10:19 <ksf> the problem I encountered is that with big files, the metadata that has been constructed can't be freed, as an ebml parser recursively depends on itself.
05:10:21 <ivanm> Axman6: well, I've never used QC1, so can't comment that much
05:10:40 <ivanm> Axman6: and the fact that I don't get coarbitrary makes me happy that it's no longer part of Arbitrary ;-)
05:10:44 <sigrid> I just want to make sure my implementation of Arbitrary is reasonable
05:10:50 <ivanm> ksf: :s
05:10:57 <Axman6> RWH covers QC1, and most of the stuff you use yo run the tests has been completely removed in QC2
05:11:03 <ivanm> sigrid: so use sample and sample' for that
05:11:23 <ksf> it's really, really easy to mess up lazy I/O if you're doing anything else but sequential reads.
05:11:26 <ivanm> Axman6: not quite; quickCheck{,With}{,Result} is still there...
05:11:44 <ivanm> ksf: and you don't want to read it all in and then parse it in-memory?
05:11:53 <Axman6> there were things that went missing, that i couldn't find replacements for
05:11:53 <Phyx-> ivanm: isn't that type incorrect? replicate n getLine would give [IO ByteStream] and liftM concat expects m [ByteStream]
05:12:04 <ksf> not with say 1.4gig matroska files, no.
05:12:24 <Saizan> Phyx-: replicateM n getLine :: IO [ByteString]
05:12:35 <ivanm> Phyx-: where does ByteStream come from?
05:12:36 <Saizan> ?type replicateM
05:12:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:12:48 <ivanm> ksf: heh, fair enough
05:12:58 <ksf> ...even though I'm mmapping it and the actual video data isn't necessarily copied, the metadata can grow to scary sizes.
05:13:00 <Phyx-> ivanm: typo
05:13:02 <Phyx-> \n -> replicateM n hGetLine
05:13:03 <Phyx->   :: Int -> GHC.IOBase.Handle -> [IO ByteString]
05:13:34 <Saizan> you've to apply hGetLine to the handle
05:13:35 <Phyx-> Saizan: oh, getLine
05:13:38 <ivanm> > fromIntegral (maxBound :: Word8)
05:13:39 <lambdabot>   255
05:13:50 <Saizan> ?type \h -> \n -> replicateM n (hGetLine h)
05:13:51 <lambdabot> Not in scope: `hGetLine'
05:13:58 <Saizan> ?type \h -> \n -> replicateM n (Data.ByteString.hGetLine h)
05:13:59 <lambdabot> GHC.IOBase.Handle -> Int -> IO [BSC.ByteString]
05:14:51 <Phyx-> yeah, that works
05:14:57 <Phyx-> \h n -> replicateM n (hGetLine h)
05:15:03 <ksf> ...and I've had a couple of months now in which I could meditate about continuations, so maybe oleg's code will be slightly less mind asploding.
05:15:51 <Saizan> iteratees aren't really complex, just ugly to look at :)
05:18:13 <ksf> the problem I had was that I needed relative seeking, not just absolute, and hadn't wrapped my mind enough around them to add it to olegs code
05:19:01 <ksf> but then, using polyparse, I was able to figure out the actual semantics of ebml, as opposed to the semantics that bug-heap of an rfc "specifies"
05:21:11 <Saizan> we should put up an rfc insisting that new rfc's should come with a demonstrative functional implementation included :)
05:21:39 <idnar> haha
05:21:47 <ksf> well, they have the dignity of calling it a draft.
05:22:22 <ksf> and it comes with an dtd validator.
05:22:43 <ksf> ...that checks the syntax of an dtd, mind you, not the vadility of an ebml file.
05:23:26 <ksf> should'nt be too surprising, then, that the given matroska dtd doesnt' match the structure of actual mkvs.
05:23:43 <Axman6> heh
05:24:03 <ksf> what is kind of strange, though, is that the dtds aren't powerful enough to fully describe the structure of mkvs.
05:24:29 <ksf> ...that is, constraints that were always satisfied and I bet a significant number of players depend upon.
05:24:39 <ivanm> @ask roconnor with your un-exported colourChannel function, would it be safe to use something like that wrapped in a Maybe? i.e. if c == transparent then Nothing else Just ... ?
05:24:40 <lambdabot> Consider it noted.
05:25:33 <ksf> ...but I should get up, get some milk for my pudding powder and some wine to that, and continue to waste away a saturday.
05:38:02 <FunctorSalad> I'm not sure how IPs are supposed to be more evil than typeclasses
05:38:14 <FunctorSalad> (IPs=implicit params)
05:38:29 <FunctorSalad> and they do the "I want this monoid now" stuff people want
05:39:16 <FunctorSalad> ("this" monoid as opposed to "that" monoid :))
06:02:57 <ManateeLazyCat> Example, i startup program "/home/foo", have any function will get path of execute file "/home/foo" when it running?
06:06:18 <ivanm> ManateeLazyCat: you didn't actually ask anything...
06:06:37 <ivanm> ManateeLazyCat: getProgName, then there's a function to find the path of an app if it's in $PATH
06:06:54 <FunctorSalad> `which'
06:06:54 <ivanm> don't know if there's any way of doing it otherwise...
06:07:24 <ivanm> FunctorSalad: eh, looked a bit weird where he gave the example before the question; I get what he's saying now
06:07:45 <FunctorSalad> ivanm: I mean `which' is the "a function" you're referring to ;)
06:07:56 <ivanm> FunctorSalad: oh ;-)
06:08:05 <Twey> Doesn't getProgName behave like C's argv[0]?  Return the name by which the program was called?
06:08:08 <ivanm> FunctorSalad: it's not the one I was thinking of
06:08:19 <ivanm> Twey: hmmm... not sure...
06:08:23 <Twey> So if it's called as /home/foo, getProgName returns "/home/foo"
06:08:24 <Twey> Hm
06:08:40 <ivanm> I've never used it myself
06:09:05 <ManateeLazyCat> Twey: No, return 'foo'
06:11:05 <ManateeLazyCat> ivanm: I have build GtkSocket/GtkPlug demo with gtk2hs for cross-process embedded, then i throw an exception in child-process, but program won't crash, just tab crash, very cool.
06:11:42 <dcoutts> ManateeLazyCat: glad you got it working :-)
06:11:59 <ManateeLazyCat> dcoutts: I'm test again, then i will push to gtk2hs repo.
06:12:04 <ivanm> ManateeLazyCat: in that case, you can use FilePath stuff to get the last bit
06:12:25 <ManateeLazyCat> dcoutts: Then we can use gtk2hs to build multi-process GUI framework for protected program crash.
06:16:11 <ivanm> if I want a module that's used just to define instances (yes, they're orphans), what do I have for the export line? just () ?
06:16:17 <koeien> yep.
06:16:30 <koeien> instances are always exported.
06:16:42 <ivanm> good-o
06:16:47 <dmwit> ivanm: Gotta use that for the import line, too, if you want to avoid warnings.
06:16:53 <ivanm> dmwit: *nod*
06:17:21 <ivanm> and because I've found I can do {-# OPTIONS_GHC -fno-warn-orphans #-}, I won't get any warnings about it! \o/
06:18:25 * Phyx- puts on his hard hat and hazmat suit and dives into the source of ghc
06:20:31 <path_> hi could someone help me fix a stack overflow. I think I might need to use a seq
06:20:37 <medfly> is there an existing way to do a case sensitive search for an element in a String? :-D (before I write some really stupid code)
06:20:42 <koeien> path_: sure, paste your code
06:20:44 <koeien> ?hpaste
06:20:44 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:20:58 <koeien> medfly: "an element"?
06:21:09 <medfly> er... hmm :)
06:21:21 <koeien> > "37" `isInfixOf` "And there are 37 cows in the field."
06:21:22 <lambdabot>   True
06:21:40 <koeien> > "37" `isInfixOf` "But 42 horses."
06:21:41 <lambdabot>   False
06:21:47 <medfly> uh...
06:22:02 <ben0x539> But, silly koeien, 37 is a number.
06:22:18 <path_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5039#a5039 <--- here you go
06:22:22 <medfly> no, I mean, like, filter (=='A') ['a','A','b'] would result in ['a','A']
06:22:29 <Twey> medfly: No it wouldn't
06:22:36 <medfly> yeah, I know it won't
06:22:39 <ManateeLazyCat> ivanm: getProPath <- liftM2 (</>) getCurrentDirectory getProgName
06:22:39 <Twey> Oh!
06:22:41 <Saizan> case _in_sensitive then
06:22:42 <medfly> :)
06:22:44 <koeien> medfly: you mean case *in*sensitive search
06:22:44 <Twey> You want an *in*sensitive search
06:22:47 <koeien> lol
06:22:48 <medfly> oh, oops.
06:22:50 <medfly> yes. sorry!
06:22:53 <koeien> :t toUpper
06:22:54 <lambdabot> Char -> Char
06:23:06 <ivanm> ManateeLazyCat: can you guarantee that it's in the current directory?
06:23:07 <koeien> > filter ((=='A').toUpper) "aAb"
06:23:08 <lambdabot>   "aA"
06:23:12 <Berengal> > filter ((=='A') . toUpper) "aAb"
06:23:12 <ivanm> ManateeLazyCat: is it in $PATH?
06:23:13 <lambdabot>   "aA"
06:23:27 <medfly> oh... cool, I imagined this would somehow influence the results, guess not, thanks!
06:23:28 <medfly> :-D
06:23:35 <Twey> Hehe
06:23:40 <Twey> That would be a map
06:23:46 <ManateeLazyCat> ivanm: Yep, just for current simple demo.
06:23:46 <medfly> what is toLower/toUpper part of?
06:23:51 <koeien> Data.Char
06:23:51 <Twey> medfly: Data.Char
06:23:56 <medfly> thanks!
06:24:13 <ManateeLazyCat> ivanm: I know what you mean, my demo won't change current directory.
06:24:47 <ivanm> good-o
06:25:07 <path_> koeien: hope you saw the paste :), I can also point you to the problem Im trying to solve (ofcourse my approach might well be wrong lol)
06:25:39 <koeien> path_: what are you trying to do, might be helpful to know
06:25:41 <Phyx-_> hmm
06:25:46 <koeien37> > toUpper "牛"
06:25:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:25:47 <lambdabot>         against inferred type...
06:25:51 <koeien37> > toUpper '牛'
06:25:52 <lambdabot>   '\29275'
06:26:03 <path_> koeien: trying to solve this problem http://www.codechef.com/problems/BUTTONS/
06:26:21 <ManateeLazyCat> koeien37: Chinese guy?
06:26:30 <koeien37> ManateeLazyCat: no
06:26:48 <ManateeLazyCat> koeien37: So you know what's mean "牛“ ？
06:26:53 <koeien37> ManateeLazyCat: yes, cow :P
06:27:19 <path_> my approach is to take each point, find out whether a row or a column needs to be changed (or none or both). And then I go through all the points and build a list of sets. Each set must have a bunch of valid button presses.
06:27:40 <ManateeLazyCat> koeien37: If someone say to you: "牛", it's not mean you're cow, it's say you're super cool! :)
06:27:56 <koeien37> ManateeLazyCat: i actually learned that yesterday :P
06:28:01 <ManateeLazyCat> koeien37: In Chinese style. :)
06:28:35 <Twey> Haha, why is 牛 a compliment?
06:28:35 <ManateeLazyCat> koeien37: "你太牛了" mean "You're so cool!"
06:28:36 <koeien37> path_: what i would do is more like a breadth-first-search
06:28:40 <Twey> Chinese people are crazy :þ
06:28:52 <Twey> Where does that come from?
06:28:55 <path_> koeien37: could you elaborate on that?
06:29:08 <RayNbow`> > text $ toUpper '牛' : []
06:29:09 <lambdabot>   牛
06:29:51 <koeien37> path_: sure. you start with your initial configuration. you keep a queue of nodes (a node being a configuration) you will visit.
06:30:16 <ivanm> wtf? I wanted to leave QC running overnight with 1000000 tests, and then it suddenly "GaveUp" after 11947! :@
06:30:31 * ivanm feels ripped off
06:30:45 <doug___> newbie question:  After installing Haskell (batteries included) where can I inspect the definitions of say, the State monad?
06:30:57 <Twey> doug___: Control.Monad.State
06:30:58 <path_> koeien37: but there are 2000 buttons so potentially 2^2000 configurations. Wouldnt that take forever to tell me if there is no answer
06:31:11 <RayNbow`> ivanm: QC needs sleep too! :p
06:31:19 <Twey> doug___: You can tab-complete in GHCi if you're not sure about something
06:31:21 <ManateeLazyCat> doug___: Use Cabal install hoogle then run "hoogle State" to search Haskell API.
06:31:21 <koeien37> path_: definitely :) there might be an easier way i guess
06:31:23 <ivanm> oh, wait, too many tests were discarded...
06:31:27 <Twey> There's also \b's @index command
06:31:27 <koeien37> path_: maybe using some linear algebra
06:31:30 <Twey> @index runState
06:31:30 <lambdabot> Control.Monad.State, Control.Monad.RWS
06:31:31 <doug___> Yeah, but where is it?  I don't know where the file is on my computer.
06:31:49 <Twey> doug___: Depends where you installed GHC
06:31:55 <path_> koeien37: yeah I thought my approach might work. But Im running into a stack overflow. I need to know if its valid or because of thunks
06:33:15 * ivanm bumps maxDiscard from 500 to 10000, sets QC running and hits the sack
06:33:28 <Twey> doug___: For me, I have /usr/lib/ghc-6.10.4/mtl-1.1.0.2/Control/Monad/State.hi
06:33:46 <koeien37> path_: you could try a smaller problem and using the profiler
06:34:04 <path_> well it works for 100 and 10000 points
06:34:05 <koeien37> path_: or somebody else could look at this code -- i can't see any obvious stack overflow
06:34:09 <koeien37> http://moonpatio.com/fastcgi/hpaste.fcgi/raw?id=5039
06:34:09 <path_> ah
06:35:02 <trssnd> ive got a req.. m a newbie. i want to overload == for type separately and data separately. but i believe it is not possible to overload methods for types
06:35:10 <trssnd> and show similarly
06:35:32 <koeien37> you can, but you need a language extension.
06:35:51 <trssnd> any workaround without it?
06:36:41 <koeien37> i would just enable {-# LANGUAGE TypeSynonymInstances #-}
06:36:42 <trssnd> for eg i have a type Set = Tree or something
06:36:47 <trssnd> oh
06:36:54 <mauke> trssnd: I don't think that's possible
06:37:03 <doug___> I found State.hi but it looks garbled (on my mac) in both textedit and Aquamacs (emacs)
06:37:10 <mauke> doug___: yeah, it's a binary file
06:37:13 <koeien37> trssnd: or write the instance directly for the right hand side of your type synonym
06:37:15 <trssnd> i want to overload Set like
06:37:17 <mauke> (compiled interface)
06:37:25 <trssnd> show = show.toList
06:37:40 <mauke> trssnd: you can't
06:37:45 <trssnd> and overload show for Tree as a tree itself
06:37:47 <trssnd> ok fine
06:37:58 <doug___> Doh!  Where is the source?  I would find it useful to inspect as I learn to write code.
06:38:04 <koeien37> trssnd: no, Data.Set already has a Show instance :(
06:38:29 <trssnd> no i am declaring my own type Set = Tree
06:38:34 <mauke> koeien37: that's why he said he wanted to define separate instances for type and data
06:38:46 <koeien37> mauke: i interpreted this as "type synonyms" and "data types".
06:38:52 <mauke> yes, exactly
06:38:58 <mauke> which isn't possible because type only gives you a new name for an existing type
06:39:00 <koeien37> ah. now i see. you can't
06:39:22 <koeien37> workaround is using "newtype" instead of "type", but requires a little bit more keyboarding
06:39:27 <doug___> Are the sources installed with GHC/GHCI?
06:40:06 <mauke> koeien37: at that point it would be easier to just call myShow instead
06:40:25 <jmcarthur> doug___: well, you could find it with the documentation on haskell.org
06:40:37 <koeien37> yep. probably. although newtype makes sense for separation of concerns (hiding of the implementation.)
06:41:45 <trssnd> sorry got dc..
06:42:10 <trssnd> someone wanted to see the code?
06:42:12 <chrisdone> can one setup post-hooks for cabal build?
06:42:20 <trssnd> where to upload it?
06:42:24 <koeien37> ?hpaste
06:42:24 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:42:28 <trssnd> thanks
06:43:40 <doug___> Its tough for a newbie to get started if you can't pop open Control.Mondad.State in their editor and review the code.
06:43:50 <koeien37> doug___: hoogle is very useful for this
06:44:04 <koeien37> it has "source" buttons on the right, and you can view the code
06:44:43 <koeien37> doug___: example: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-State-Lazy.html#State
06:47:59 <trssnd> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5040#a5040
06:48:38 <ManateeLazyCat> dcoutts: I have send my demo program to gtk2hs-devel list, if you have time, please help me test it. Just `make`, then Press `Alt-m` (editor) or `Alt-n` (terminal). Thanks!
06:48:43 <koeien37> trssnd: you have two instances of Show (Set a) ... that is not going to work
06:48:50 <trssnd> ya ya sorry abt tat
06:48:58 <trssnd> i meant the second one is for AVLBStree
06:48:58 <ManateeLazyCat> dcoutts: I will push demo to repo if no bug in it.
06:49:06 <koeien37> trssnd: you could have showAsPreOrder and showAsList
06:49:49 <trssnd> ya but when i show it is going to show the AVLBStree as the eg ive given rite
06:50:01 <trssnd> i mean d eg isnt there..
06:50:14 <trssnd> it will show like.. deriving Show kind
06:50:28 <trssnd> using data constructor itself
06:50:39 <trssnd> but i want to override it to show like tree for testing the module
06:50:39 <koeien37> if AVLBStree already has a Show isntance, you cannot instantiate Show here again.
06:50:51 <trssnd> and as list for anything Set is assigned to
06:51:07 <koeien37> you will have to write a separate function myShow :: Set -> String
06:51:29 <trssnd> ok. and explicitly call this instead of default Show?
06:51:31 <koeien37> i mean, myShow :: (Show a) => Set a -> String
06:51:31 <doug___> Thanks koeien37.
06:51:36 <koeien37> trssnd: yes.
06:52:08 <trssnd> like if i say.. emptySet on ghci prompt it will still say Nil and not []
06:52:16 <dcoutts> ManateeLazyCat: sorry, I will not have time, I'm about to go away for the rest of the weekend
06:52:22 <trssnd> so i wud have to say setShow emptySet
06:52:28 <koeien37> yes
06:53:07 <trssnd> but tat wud give it along wid quotes and.. well i got it. thanks. but i would still like to know why this isnt possible
06:53:08 <skuggi> @yarr
06:53:08 <lambdabot> Yarrr!
06:53:29 <koeien37> trssnd: if you call "show", how would the compiler know which "show" you meant?
06:53:48 <trssnd> ya.. correct. because types are just aliases right?
06:53:52 <trssnd> my bad
06:53:54 <koeien37> yes
06:54:04 <trssnd> whew
06:54:08 <trssnd> thanks a lot
06:54:11 <trssnd> :)
06:54:38 <ManateeLazyCat> dcoutts: Okay, never mind. :)
06:56:45 <chrisdone> awesome. setup a cabal post-build hook to restart the fastcgi process
06:58:00 <ManateeLazyCat> I have test Chrome-OS in VirtualBox, just Linux-Kernel + Chromium Browser.
06:58:00 <sigrid> is there a monad for generating unique IDs?
06:58:19 <FunctorSalad> quicksilver: hmm you mentioned this phenomenon were expressing abstract constructions in haskell directly leads to lots of annoying wrapping/unwrapping...
06:58:20 <dmwit> comonad
06:58:24 <sigrid> is there a monad for generating unique, random IDs? (to be precise)
06:58:27 <dmwit> Supply
06:58:44 <FunctorSalad> quicksilver: maybe the solution is to generate code for each particular case, instead of expressing the general concept in haskell?
06:59:10 <ManateeLazyCat> sigrid: I use IORef or MVar to update id.
06:59:29 <FunctorSalad> like the free monad over a functor or whatever, you could autogenerate it instead of having a newtype Free f a where you need wrapping/unwrapping
06:59:32 <dmwit> ?hackage uniqueid
06:59:32 <lambdabot> http://hackage.haskell.org/package/uniqueid
06:59:58 <FunctorSalad> quicksilver: not sure if I mentioned this already :)
07:00:05 <dmwit> ?hackage value-supply
07:00:05 <lambdabot> http://hackage.haskell.org/package/value-supply
07:00:41 <poe> FunctorSalad how would that work for, say, Z/nZ ?
07:01:15 <FunctorSalad> poe: looks like a straightforward TH macro, doesn't it?
07:01:38 <FunctorSalad> though Z/nZ can still acceptably be expressed in the type system with type system naturals, I guee
07:01:48 <FunctorSalad> *I guess
07:04:05 <FunctorSalad> poe: though depending on what you're up to you might want to have rings as first-class values?
07:04:27 <ManateeLazyCat> Haven't fix "cabal upgrade" bug now?
07:04:32 <FunctorSalad> data Ring a = Ring { (eq) :: a -> a -> Bool; plus :: a -> a -> a; .... }
07:05:01 <dcoutts> ManateeLazyCat: it's not so much a bug, as it's a feature that needs to be redesigned to do something rather different
07:05:42 <ManateeLazyCat> dcoutts: Different? Example?
07:06:00 <dcoutts> ManateeLazyCat: turns out you do not want to upgrade all dependencies
07:07:58 <dcoutts> you actually want to upgrade "some" dependencies, but which ones exactly is the thing that has to be worked out
07:09:29 <ManateeLazyCat> dcoutts: Some package upgrade is painful, such as `bytestring`.
07:14:59 <ManateeLazyCat> dcoutts: Cross-Process embedded is so cool, we can embedded Firefox widget in it, and we don't need know that. And we can embedded Mplayer widget in it! I have write some demo to test it, just need transform XID to mplayer then draw in Widget.
07:16:53 <Daimonic> Hey, I have trouble with my own datatype: http://codepad.org/2qaOblvk He complains in line 28 Couldn't match expected type 'Bool' against inferred type [Bool] and I don't get what it means, because I clearly state in the signature I want [Bool]
07:17:09 <Daimonic> or does he see [x] as MemoryBlock [x] ?
07:17:58 <skorpan> i don't understand enoughSpace
07:18:30 <skorpan> you are pattern-matching as if the first parameter was a list of bools, but [a] is not an instance of Memory
07:18:45 <mauke> Daimonic: precedence error
07:18:55 <mauke> you meant (MemoryBlock (x : xs))
07:19:23 <mauke> or at least I think you did
07:19:35 <mauke> this whole thing doesn't make sense
07:20:00 <Daimonic> mh
07:20:06 <Berengal> You can't pattern match on things you don't know the type of
07:20:15 <Berengal> And you don't know the type of (Memory m) => m
07:20:52 <Daimonic> well atleast I thought the type is [Bool] as I declared in data MemoryBlock
07:21:14 <Twey> Daimonic: It looks like you want to make mapMemory part of the Memory class.
07:21:37 <Daimonic> not exactly, I need it for allocate
07:21:41 <Twey> Also enoughSpace, probably — I'm not quite sure what you're doing there
07:21:54 <mauke> Daimonic: mapMemory doesn't take a MemoryBlock, it takes a (Memory m) => m
07:21:54 <Daimonic> as a help function
07:22:23 <Daimonic> d'oh
07:22:32 <path__> hi would someone be able to take a look at my code and tell me why Im facing a stack overflow?
07:22:46 <path__> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5039#a5039
07:29:01 <Daimonic> ah, now I am on the right trace, replaced (Memory m) => m by MemoryBlock and adding everywhere its needed a memoryBlock prefix as datattype constructor :)
07:32:03 <olsner> path__: my guess is that you get (too many) thunks of Set.insert applications that you might want to make strict... also, I think you shouldn't need to import Data.List qualified
07:33:00 <h20xt> mornin, can anyone tell me what i need to do here http://pastebin.com/m4c6545cb, it won't compile because for the first definition it sees that f is type (Integer -> Integer -> Integer), but for the second it is type (Double -> Double -> Double), is there anyways i can achieve what i want, i feel like there must be
07:33:55 <koeien37> h20xt: you want Rank2Types
07:34:26 <h20xt> koeien37: thanks, ill look into them
07:34:26 <koeien37> apply :: (forall a. Num a => a -> a -> a) -> SchemeNumber -> SchemeNumber
07:34:27 <olsner> path__: oh, and using foldl' to build a list is probably less strict than you intend it to be, at each step it will only force the value to be either x:xs or [], but won't force either of x or xs
07:39:57 <h20xt> koeien37: these look to be exactly what i need, but i keep getting a syntax error on =>, do i need to tell ghc to use rank2types?
07:40:10 <koeien37> h20xt: you do. {-# LANGUAGE Rank2Types #-}
07:40:58 <h20xt> koeien37: you are the greatest! you have no idea how long i stared at this, thanks :)
07:41:31 <Guest3654> can anyone explain why for example chr 4 is '\EOT'?
07:41:47 <h20xt> Guest3654: check an ascii table at decimal value 4
07:41:50 <koeien37> Guest3654: chr 4 is the 4th character of ASCII
07:41:58 <h20xt> end of transmission
07:42:01 <koeien37> > chr 65
07:42:01 <lambdabot>   'A'
07:42:40 <Guest3654> koeien I see
07:43:25 <Guest3654> thanks
07:54:20 <kosmic> Hi guys!
07:57:49 <byorgey> hey kosmic
08:00:25 <EnglishGent^afk> hi kosmic :)
08:16:51 <chrisdone> I can't think of anything that's a Functor but not a Monad
08:17:15 <chrisdone> anything in the standard library?
08:17:48 <dolio> Const a
08:18:19 <Paczesiowa> ZipLists
08:18:41 <h20xt> chrisdone: monads are functors, at least in math
08:18:59 <koeien37> yes, but not always the other way around
08:19:01 <Paczesiowa> chrisdone: try to write a monad instance for any functor
08:19:10 <h20xt> i believe functors just remove one or two restrictions
08:19:33 <Beelsebob> h20xt: right, but he asked for Functors that aren’t Monads
08:19:43 <Beelsebob> Monads are a subset of applicatives, which are a subset of functors
08:19:53 <chrisdone> @hoogle Const
08:19:53 <lambdabot> Control.Applicative newtype Const a b
08:19:53 <lambdabot> Control.Applicative Const :: a -> Const a b
08:19:53 <lambdabot> Prelude const :: a -> b -> a
08:19:57 <chrisdone> well I never
08:20:00 <h20xt> Beelsebob: heh, :P thanks
08:20:46 <dolio> There are certain as for which Const a is a monad, I think.
08:20:51 <dolio> Void, for instance.
08:21:12 <dolio> But that's a special case.
08:21:33 <dolio> (That's probably the only one, actually.)
08:21:37 <Daimonic> I do an instance Show of my own data type, now I want to let it print out a line of numbers, so how can I make a line break? will "1 2 3 4\n" do what I need?
08:21:53 <koeien37> yes.
08:22:19 <Daimonic> ok
08:22:24 <Beelsebob> Daimonic: yes, but bear in mind that show is not what you want if you want to print your data out in a pretty form
08:22:45 <chrisdone> dolio: it seems like in light of `fmap`, liftM's only use is to add the Monad f => .. restriction
08:22:45 <Beelsebob> show is for printing out haskell data structures, usually that can be dumped straight into code, and be expected to work
08:22:54 <Beelsebob> you probably want one of the pretty printing classes instead
08:23:02 <chrisdone> dolio: (otherwise what's the point of it?)
08:23:10 <Beelsebob> chrisdone: there is no point
08:23:16 <koeien37> chrisdone: yes, that is it.
08:23:17 <dolio> The Monad class doesn't have Functor as a superclass.
08:23:18 <chrisdone> then again, liftM2 etc go nicely with it
08:23:30 <Beelsebob> other than that Monads are not correctly inserted into the class hierarchy
08:23:42 <dolio> So theoretically you can have Monads that aren't Functors, as far as instances go.
08:23:46 <chrisdone> dolio: so it's just in case someone forgot to provide a Functor instance?
08:23:50 <Daimonic> Beelsebob: mh, what should I prefer?
08:24:02 <Beelsebob> Daimonic: one of the Pretty print classes
08:24:11 <Daimonic> ah I read this sorry - well yeah...
08:24:13 <Beelsebob> chrisdone: and an applicative one
08:24:46 <chrisdone> Beelsebob: well, if they didn't provide a Functor instance, there'd be no Applicative instance anyway
08:24:51 <Beelsebob> indeed
08:28:53 <Daimonic> Beelsebob: anyway, \n doesnt work he really prints \n in ghci
08:29:16 <Beelsebob> ugh, way to leave before anyone can tell you why
08:30:11 <chrisdone> the ADD generation =)
08:30:43 <Beelsebob> Daimonic: it does work
08:30:45 <Beelsebob> but....
08:30:47 <Beelsebob> ghci prints out the value shown
08:30:54 <Beelsebob> so when you ask ghci “show myStructure”
08:31:04 <Beelsebob> it shows the string that is the result of showing your structure
08:31:09 <Beelsebob> so you get “….\n….”
08:31:40 <Beelsebob> if you just ask it for myStructure, it’ll show it, and you’ll get your new lines coming out right :)
08:32:00 <Beelsebob> alternatively, you can use putStrLn $ show myStructure
08:32:05 <Beelsebob> or print myStructure
08:32:07 <Daimonic> ah! :)
08:35:39 <desp> I'm trying my hand at some minor type hackery; trying to get the type system to infer some values for me.
08:35:48 <desp> But I have an odd problem.
08:35:57 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12873
08:36:16 <desp> In the second part of the paste you can see the compilation error -- ambiguous type variables.
08:36:26 <desp> I have no idea why they're ambiguous to the compiler.
08:36:36 <desp> Seem pretty clear-cut to me.
08:36:56 <koeien37> desp: ScopedTypeVariables
08:37:26 <desp> koeien37: and?
08:37:29 <koeien37> enable it
08:37:36 <koeien37> {-# LANGUAGE ScopedTypeVariables #-}
08:37:42 <koeien37> ah you did
08:37:48 <desp> Indeed.
08:37:50 <koeien37> hmm
08:38:05 <Paczesiowa> desp: add explicit foralls to type signature
08:39:46 <smiler> Anyone in here know stuff about haskell-mode for emacs? Whenever I run C-c C-l I get a new window in my current frame if I don't already have one, even if I already have a window for the interpreter in another frame. It's quite annoying
08:40:48 <Paczesiowa> desp: or comment out type sig and check the inferred one
08:40:50 <ManateeLazyCat> smiler: Use multi-term.el running ghci.
08:41:33 <smiler> ManateeLazyCat: I'll check that out
08:42:12 <ManateeLazyCat> smiler: http://www.emacswiki.org/emacs/MultiTerm
08:42:31 <Paczesiowa> desp: I think adding type variables to terms (undefined ::) works differently in functions and method declarations
08:42:38 <ManateeLazyCat> smiler: multi-term.el is terminal for Emacs (including graphics), so you can running any program (such as ghci) in it.
08:42:55 <smiler> ManateeLazyCat: hmm, I ain't sure that will solve my problem
08:43:08 <Paczesiowa> ManateeLazyCat: is it based on term.el?
08:43:17 <desp> Paczesiowa: GHC cannot infer the function type itself
08:43:18 <ManateeLazyCat> Paczesiowa: Yep.
08:43:26 <desp> Paczesiowa: same error, ambiguous type variables
08:43:36 <desp> Paczesiowa: but explicit foralls seem to have helped, one moment
08:43:51 <smiler> The problem is that the inferior-haskell-load-file function insists on creating a new window in the current frame if one doesn't already exist
08:44:01 <desp> Why doesn't  "forall a, b, c ."  work?
08:44:09 <Paczesiowa> forall a b c.
08:44:11 <ManateeLazyCat> smiler: But you can open dedicated temrinal window (multi-term-dedicated-open) for your Haskell project.
08:44:21 <desp> Ah.
08:44:21 <Paczesiowa> ManateeLazyCat: term.el sucks:(
08:44:47 <ManateeLazyCat> Paczesiowa: I know, but it's the best terminal in Emacs world, at least now.
08:44:48 <smiler> ManateeLazyCat: how would I send the current buffer to that ghci instance then?
08:45:05 <tensorpudding> smiler: C-c C-l
08:45:13 <ManateeLazyCat> Paczesiowa: multi-term.el change something.
08:45:35 <ManateeLazyCat> Paczesiowa: in term.el you can't integrate term.el with global keyshort.
08:45:50 <ManateeLazyCat> Paczesiowa: In detail, see Wiki page.
08:46:08 <smiler> tensorpudding: I don't see how that would seamlessy hook into multi-term.el
08:46:27 <tensorpudding> oh, we're talking about some other term
08:46:37 <smiler> Just a suggestion from ManateeLazyCat
08:46:39 <tensorpudding> what's wrong with the inferior haskell?
08:46:42 <ManateeLazyCat> smiler: YOu need coding glue code self.
08:47:27 <smiler> tensorpudding: that it insists on opening a new window in the current frame, even if I already have a window for the *haskell* buffer active in another frame
08:48:56 <tensorpudding> oh
08:49:27 <ManateeLazyCat> smiler: Need change code in haskell-mode.
08:49:42 <smiler> ManateeLazyCat: mmm, I'm scanning through inf-haskell.el atm
08:49:46 <smiler> But I'm no elisp guru
08:50:03 <tensorpudding> now is the time to learn
08:50:08 <smiler> hehe
08:51:07 <tensorpudding> maybe
08:51:14 <ManateeLazyCat> smiler: In haskell-ghci.el file, need rasie *haskell* frame before (pop-to-buffer...
08:51:33 <tensorpudding> knowing a lisp already would help
08:51:39 <Paczesiowa> desp: and?
08:52:19 <ManateeLazyCat> smiler: I know how to fix your problem, but i haven't time test it.
08:52:37 <ManateeLazyCat> smiler: Send haskell-mode developer with below suggestions:
08:52:47 <smiler> I know some lisp from my AI course, but it was a while ago
08:53:15 <ManateeLazyCat> smiler: Make `haskell-ghci-gen-load-file` find *haskell* frame before `pop-to-buffer`.
08:53:24 <smiler> ManateeLazyCat: cool
08:53:32 <ManateeLazyCat> smiler: I have see source code of haskell-ghci.el
08:53:52 <rwx> i prefer using vim; i tried to compile Yi from cabal, but it broke because a required package's version is too new; what's the best way for me to file a bug / fix this problem?
08:54:03 <ManateeLazyCat> smiler: Because function `pop-to-buffer` will create new *haskell* buffer if it haven't found it in current frame.
08:54:22 <ManateeLazyCat> smiler: So need swith *haskell* frame before use `pop-to-buffer`.
08:54:39 <smiler> So it simply need to search all frames before giving up and opening a new one
08:54:48 <ManateeLazyCat> smiler: Yep.
08:55:12 <ManateeLazyCat> smiler: I think haskell-mode developers just use it in *one* frame.
08:55:36 <ManateeLazyCat> smiler: So they haven't consider your situation.
08:55:43 <smiler> :)
08:56:04 <ManateeLazyCat> smiler: So easist way is found some people at #emacs to help you coding it.
08:56:15 <smiler> I'll see what I can do
08:56:22 <medfly> wow, @pl is hax!
08:56:23 <ManateeLazyCat> smiler: Or send mail to developers.
08:56:33 <ManateeLazyCat> smiler: Or don't use *two* frame. :)
08:56:38 <smiler> Hehe
08:57:32 <ksf> rwx, http://code.google.com/p/yi-editor/issues/list
08:57:54 <desp> Paczesiowa: and thank you, I think this solves the problem.  Weird, though.  I thought foralls were implicit.
08:57:55 <ksf> or #yi, of course.
08:58:10 <desp> Paczesiowa: to fully test this, though, I need to modify some other code, which will take some time.
08:58:46 <ksf> rwx, also, you might want to try the latest darcs, with any luck it's been fixed already
08:59:45 <smiler> ManateeLazyCat: display-buffer-reuse-frames seems to modify the behaviour of pop-to-buffer to consider all frames
09:00:24 <jmillikin> Has anybody else been having problem creating repositories on patch-tag recently? When I try, I get a message to refresh "reposstarted", but the new repo never appears.
09:00:35 <ManateeLazyCat> smiler: I never have that function, i still use old Emacs.
09:00:46 <smiler> :)
09:00:48 <ManateeLazyCat> smiler: Maybe that's new functin in 23.1
09:01:01 <smiler> It's a variable
09:01:15 <rwx> ksf, thanks! i was perplexed that a build failure kept occuring for a few days, like, surely someone noticed this? i found the bug in the listing
09:01:33 <ManateeLazyCat> smiler: So just setup it with t for test.
09:01:42 <smiler> Yup
09:01:46 <ManateeLazyCat> smiler: (setq display-buffer-reuse-frames t) then reload.
09:01:47 <smiler> It works :)
09:02:13 <ManateeLazyCat> smiler: Happy now?
09:02:31 <smiler> Yup!
09:02:42 <ManateeLazyCat> smiler: Haven't hacking elisp long time since i love Haskell.
09:02:45 <ManateeLazyCat> :)
09:03:38 <smiler> I got enough of lisp in my AI course. All the paranthesis and indentation makes it somewhat hard to read imo
09:03:50 <smiler> It lacks pattern matching!
09:05:57 <ManateeLazyCat> smiler: Sorry, emacs crash, can you send again?
09:06:14 <Polarina> ManateeLazyCat: (05:03:51 PM) smiler: I got enough of lisp in my AI course. All the paranthesis and indentation makes it somewhat hard to read imo
09:06:19 <Polarina> ManateeLazyCat: (05:04:04 PM) smiler: It lacks pattern matching!
09:07:14 <h20xt> aw, i love lisp, yay SICP
09:07:16 <ManateeLazyCat> smiler: Use paredit.el for parentheses match.
09:08:09 <ManateeLazyCat> smiler: It's completion parentheses automatically, with syntax parse. Not just simple completion `)`
09:08:22 <idnar> ugh, lisp
09:08:26 <ManateeLazyCat> smiler: It won't completion when you type '(' in comment
09:08:44 <ManateeLazyCat> smiler: Infact, elisp is very funny language.
09:10:08 <ManateeLazyCat> smiler: http://www.emacswiki.org/emacs/AndyStewart my homepage, hope it have some useful elisp code for you.
09:20:23 <smiler> ManateeLazyCat: thank you, I'll check it out
09:20:34 <ManateeLazyCat> smiler: NP :)
09:23:58 <grn> I have a simple Haskell program and I'd like to run it like a script, i. e. calling: ghci myprog.hs
09:24:03 <grn> How to do that?
09:24:17 <Paczesiowa> runhaskell
09:25:33 <grn> Is main function always necessary?
09:25:41 <jmillikin> yes
09:25:48 <grn> ok, thank you!
09:26:01 <h20xt> I bet you can specify a differeny entry point... just don't know how
09:26:12 <koeien37> --main-is perhaps?
09:26:19 <koeien37> or was that for specifying hte main module?
09:26:26 <c_wraith> I think that's for the main module
09:26:51 <chrisdone> @hoogle Empty
09:26:51 <lambdabot> Text.Parsec.Prim Empty :: a -> Consumed a
09:26:52 <lambdabot> Data.ByteString.Lazy.Internal Empty :: ByteString
09:26:52 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap Empty :: FiniteMap a b
09:26:59 <chrisdone> is there an "empty" class?
09:27:26 <c_wraith> @src Monoid
09:27:26 <lambdabot> class Monoid a where
09:27:26 <lambdabot>     mempty  :: a
09:27:26 <lambdabot>     mappend :: a -> a -> a
09:27:26 <lambdabot>     mconcat :: [a] -> a
09:27:39 <c_wraith> You want something more primitive, though, I assume?
09:28:17 <chrisdone> well it seems like every type has its own `empty' function.. figured I could just use one
09:28:33 <c_wraith> many types are instances of Monoid
09:28:44 <c_wraith> You can probably use mempty
09:28:53 <chrisdone> I'll try that then
09:28:56 <Paczesiowa> h20xt: ghc -e foo
09:29:54 <Paczesiowa> h20xt: ghc file.hs -e foo
09:30:48 <chrisdone> is `mconcat = foldr mappend mempty' an acceptable definition?
09:30:59 <chrisdone> hm
09:30:59 <chrisdone> @src mconcat
09:30:59 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:31:06 <h20xt> Paczesiowa: thank you
09:31:26 <c_wraith> chrisdone: you don't need to implement mconcat
09:31:35 <c_wraith> chrisdone: it's already implemented in terms of mappend
09:32:01 <chrisdone> ah ok
09:32:13 <c_wraith> chrisdone: you should only re-implement it if you can get better performance for a specific type.
09:32:20 <chrisdone> sure
09:33:02 <h20xt> anyone suggest any good linear algebra libraries?
09:33:49 <byorgey> chrisdone: (mconcat = foldr mappend mempty is in fact the default definition of mconcat.)
09:34:21 <chrisdone> byorgey: ah nice
09:34:26 <pkrumins> Could anyone take a look at this code fragment. I can't understand why Hugs is giving me the error that's mentioned in the paste. It's here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5041#a5041
09:34:44 <chrisdone> @instances Monoid
09:34:44 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:34:54 <pkrumins> I am assigning to 't', how can it be undefined.
09:34:56 <h20xt> pkrumins: what is the second do for?
09:35:03 <tensorpudding> first, last, maybe, any, all
09:35:14 <chrisdone> (a -> b) as a monoid is cool
09:35:29 <chrisdone> > (+1) `mappend` (*2) $ 5
09:35:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:35:30 <lambdabot>    `GHC.Num.Num a' arising ...
09:35:45 <chrisdone> > ((+1) `mappend` (*2) $ 5) :: Int
09:35:46 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
09:35:46 <lambdabot>    arising from a use of...
09:35:48 <pkrumins> h20xt, the second is used in combination with +++ to say "symbol "+" may or may not exist"
09:35:48 <chrisdone> meh
09:35:54 <roconnor> > getSum ((+1) `mappend` (*2) $ 5)
09:35:55 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum a))
09:35:55 <lambdabot>    arising from the liter...
09:35:55 <lambdabot> roconnor: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:36:11 <chrisdone> oh yeah forgot about the sum/multiplication
09:36:35 <roconnor> > getSum ((Sum . (+1)) `mappend` (Sum . (*2)) $ 5)
09:36:36 <lambdabot>   16
09:36:56 <Paczesiowa> pkrumins: try decreasing indentation of the last line
09:37:16 <roconnor> @seen ivanm
09:37:17 <lambdabot> Unknown command, try @list
09:37:24 <roconnor> preflex: seen ivanm
09:37:25 <preflex>  ivanm was last seen on #haskell 3 hours, 4 minutes and 13 seconds ago, saying: * ivanm bumps maxDiscard from 500 to 10000, sets QC running and hits the sack
09:37:42 <pkrumins> Paczesiowa, still the same error, (but that line has to be where it is)
09:38:27 <ManateeLazyCat> Night, all. :)
09:39:39 <pkrumins> hmm, yes, the last line is giving the error
09:39:42 <pkrumins> not the 118.
09:40:06 <pkrumins> i changed last line to `return foo` and it gives error: "ERROR file:.\lec8.hs:118 - Undefined variable "x""
09:40:21 <pkrumins> variable "foo"
09:40:24 <pkrumins> (not "x")
09:40:30 <Paczesiowa> pkrumins: you have tu put nested do expr in parens and put the "+++ return t" on the same line
09:41:04 <Paczesiowa> pkrumins: that nested do and that return are single computation
09:41:16 <Paczesiowa> pkrumins: created by +++
09:41:36 <Paczesiowa> pkrumins: they can't be on different lines of do expression, that would desugar to something wron
09:42:46 <h20xt> are there any good haskell style guides?
09:43:13 <Paczesiowa> there's something on the haskell wiki
09:43:15 <h20xt> i find myself struggling with how to do my indentation, how to use $ over (), etc..
09:43:18 <pkrumins> Paczesiowa, trying that.
09:43:30 <pkrumins> I know about identation rules, but this is bizzare
09:44:25 <h20xt> Paczesiowa: found it thank you
09:46:37 <sproingie> h20xt: use whichever of $ and () you're comfortable with
09:49:27 <pkrumins> Paczesiowa, here is another paste where I don't have return indented with 'do', http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5042#a5042
09:49:29 <sproingie> h20xt: you use $ if you'd otherwise parenthesize everything to the right.  it's handiest if the thing to the right is a do-block
09:49:50 <sproingie> e.g. evalState $ do ...blah...
09:50:11 <pkrumins> Paczesiowa, I tried putting return everywhere I could in my previous paste, it only worked if I joined the last two lines together, but the result was not what I expected.
09:51:11 <chrisdone> remember space binds more tightly than indentation in expressions
09:51:59 <ksf> pkrumins, that's return indented with the rest of the do block
09:52:17 <pkrumins> kst, hmm
09:52:30 <ksf> an indent level is defined by the first non-space character after the keyword that introduces layout
09:52:37 <pkrumins> oh oh!
09:52:53 <sproingie> haskell's layout is way different than python's
09:52:58 * pkrumins does this: <Paczesiowa> pkrumins: you have tu put nested do expr in parens and put the "+++ return t" on the same line
09:53:21 <pkrumins> it worked!
09:53:29 <sproingie> python's is about counting indent levels on the left, haskell's is about lining things up in a column
09:53:42 <pkrumins> aha. thanks for the info sproingie.
09:54:00 <pkrumins> interesting that this example was from Graham Hutton's Programming in Haskell book, page 84.
09:54:00 <sproingie> it just helps to read a lot of code.  there's a lot of ways to indent.
09:54:06 <ksf> (+++ natural) <$> symbol "(" *> expr <* symbol ")"
09:54:58 <ksf> there's no need to use monads when all you need is applicatives
09:55:06 <pkrumins> But he doesn't use a constant width font there, so it's hard to tell where his `+++ return` is. But it seems more to me that it is aligned with the 2nd do as I have in my original paste (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5041#a5041)
09:55:16 <Paczesiowa> ksf: that's still a monad
09:55:33 <ksf> Paczesiowa, I don't see bind or join, anywhere.
09:55:35 <pkrumins> let me take a pic of that book page
09:55:49 <pkrumins> Paczesiowa, could you take a look on how he got his code working there? (or perhaps that's a mistake in the book?)
09:56:59 <Paczesiowa> ksf: (*>) uses (<*>) which uses bind in this particular case
09:57:16 <ksf> pkrumins, that should be easy to tell from the type of (+++)
09:58:10 <ksf> Paczesiowa, but the general case says that while every monad is an applicative, not every applicative is a monad
09:58:44 <ksf> that we don't have class Applicative m => Monad m in the hierarchy is a regrettable historical accident.
09:59:00 <pkrumins> (+++)                         :: Parser a -> Parser a -> Parser a
09:59:13 <pkrumins> oh wait, perhaps the precedence is not right?
09:59:24 <pkrumins> i outcommented a line `infixr 5 +++`
10:00:06 <ksf> ugh.
10:00:14 <ksf> that syntax is messed, imo.
10:00:45 <pkrumins> i just took a photo
10:00:46 <pkrumins> uploading
10:01:34 <ksf> the inner do-block should be in a where; the outer one is utterly unescessary, and then you can just say expr = foo +++ term where fo = do sym...
10:01:50 <pkrumins> here is that page: http://i.imgur.com/w2YjK.png
10:02:13 <mauke> do ho ho
10:02:22 <ksf> yep that's indented with the "o" of do
10:02:32 <mauke> note how the '+++' is subtly aligned with the 'o' of the second do
10:03:11 * ksf thinks http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf   is the best intro to functional parsers
10:03:31 <Paczesiowa> pkrumins: fixity of an operator doesn't matter when there's only one operator in an expr
10:03:54 <pkrumins> oh
10:03:57 <pkrumins> with the "o"
10:04:19 <pkrumins> how should I understand this indentation?
10:04:31 <pkrumins> what is the +++ coupled with then?
10:05:03 <ksf> the whole preceding do block
10:05:04 <mauke> desugaring: do { t <- term; do { symbol "+"; e <- expr; return (t + e) } +++ return t }
10:05:15 <pkrumins> oh i see!
10:05:25 <ksf> remember, do's are just expressions, nothing magic.
10:05:35 <pkrumins> right!
10:05:46 <pkrumins> thanks for helping me resolve this :)
10:05:47 <mauke> it's indented less than symbol/e/return, so the inner do block is closed
10:06:04 <mauke> but it's indented more than t/do, so no ';' is inserted
10:06:23 <pkrumins> aha
10:06:49 <ksf> http://www.impredicative.com/ur/ looks intriguing
10:07:25 <mauke> <Foone> "I checked, and both Haskell and Python are 'round 18-19 years old. If they were girls they would be just at dating age."
10:07:28 <mauke>  * Foone unsubscribes from the programming reddit
10:07:53 <akappa> python is so old?
10:08:28 <ray> i don't blame that guy
10:08:42 <Paczesiowa> akappa: heh, 18 is too old?
10:09:09 <akappa> Paczesiowa, for a girl is too young :P
10:09:23 <akappa> but I've the idea of python as a new language
10:09:43 <xternal> he started in 1989, I don't think he released then
10:09:50 <Gwern-away> mauke: girls are fine at 15; by that standard, haskell and python are experienced college girls
10:10:00 <xternal> also I think it took a while to get traction
10:10:51 <xternal> people were still taking perl seriously back then, no? ;)
10:12:29 <medfly> some paedophiles here
10:12:31 <medfly> :-p
10:12:49 <Gwern-away> medfly: ephebophile, technically
10:12:54 <pkrumins> Is there something in Haskell such as Deparse in Perl? I would like to see how the code gets parsed.
10:12:55 <p_l> medfly: paedophile is someone who goes for pre-pubescents...
10:12:57 <Gwern-away> can't be paedo after puberty
10:13:28 <p_l> medfly: from nature pov's, we should be like rabbits in spring since ~13yo
10:13:48 <netinho2lol> hey guys
10:13:53 <ksf> pkrumins, you can play around with TH a bit, or haskell-src
10:14:06 <Paczesiowa> ok, I like this kind of talk like any perv, but it's not #haskell type of talk
10:14:10 <ksf> both give you an AST view of haskell
10:14:27 <BONUS> what the hell
10:14:35 <pkrumins> looking for those, thanks
10:14:38 <BONUS> i just drop by #haskell and ppl are talking about pedophiles
10:14:39 <BONUS> O_O
10:14:41 <medfly> p_l, I don't think that hit puberty instantly means a girl can reproduce (or should). female humans start with irregular periods and all that stuff, it doesn't work out so well instantly
10:14:57 <netinho2lol> can someone help me with making some data constructions Show-able?
10:15:14 <medfly> the system doesn't quite work as fast :)
10:15:23 <netinho2lol> BONUS: I hate them
10:15:29 <Paczesiowa> netinho2lol: deriving Show
10:16:49 <p_l> medfly: Oh, I'm not saying should reproduce... just stating that "natural" processes don't care about our sensibilities (and even health of an individual) ;-)
10:17:05 <BONUS> @ops
10:17:05 <lambdabot> Maybe you meant: docs oeis pl
10:17:10 <medfly> @where ops
10:17:11 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:17:26 <medfly> p_l, it's not that! it's just, the female system takes more time to work OK
10:17:46 <allbery_b> mrf?
10:18:05 <netinho2lol> Paczesiowa: yeah, I used that
10:18:15 <netinho2lol> but I think that I have to instancize?
10:18:21 <netinho2lol> dunno what is the word
10:18:38 <allbery_b> instantiate?
10:18:55 <Paczesiowa> netinho2lol: "deriving" is automatic way of writing instances
10:19:23 <netinho2lol> my data is data Dir = Up | Down | Left | Right deriving (Eq,Show)
10:20:07 <netinho2lol> so, if I write: errorPos = error . ("Cannot go to " ++)
10:20:08 <mauke> other things you could plausibly derive for that: Ord, Read, Enum, Bounded
10:20:15 <netinho2lol> it should work automatically?
10:20:24 <mauke> netinho2lol: where are you calling 'show'?
10:20:37 <netinho2lol> I just need to test for equality and to output in string, mauke
10:20:39 <netinho2lol> no
10:20:42 <netinho2lol> 0_o
10:20:44 <netinho2lol> should I?
10:20:54 <mauke> only if you want to convert from Dir to String
10:20:56 <Paczesiowa> that's what Show is all about
10:21:03 <netinho2lol> oh crap
10:21:04 <pkrumins> everything worked out. thanks for all the help guys. i now have to reinstall one of my systems, be back later!
10:21:05 <netinho2lol> :|
10:22:30 <netinho2lol> ysy
10:22:34 <netinho2lol> it works now
10:22:34 <netinho2lol> :)
10:22:38 <netinho2lol> thanks guys
10:25:22 <Spockz> am I correct in thinking that 'ghc --make -O2 ...' should make an executable file, and not an object (.o) and .hi file?
10:25:26 <hotzen> is there any chance to copy+paste in ghci under windows?
10:25:27 <Guest3654> !sequence
10:25:41 <Guest3654> how to write so the bot gives me info about sequence ?
10:25:46 <tensorpudding> @info sequence
10:25:47 <lambdabot> sequence
10:25:49 <Guest3654> thanks
10:25:55 <tensorpudding> err, that's not much info
10:25:57 <tensorpudding> @src sequence
10:25:58 <lambdabot> sequence []     = return []
10:25:59 <netinho2lol> @vixen
10:25:59 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:25:59 <lambdabot> --OR
10:25:59 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:25:59 <lambdabot> nothing good is on TV
10:26:02 <Spockz> ?hoogle sequence
10:26:02 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:26:02 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:26:04 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:26:07 <Guest3654> there we go =) thanks
10:26:25 * hotzen really wonders how to copy/paste in ghci (win7)
10:26:40 <mauke> tensorpudding: there is no @info
10:26:41 <Spockz> hotzen: here they just use copy paste :p
10:27:07 <hotzen> Spockz: how? ctrl+c/v does not work, neither mouse-selecting, rightclick, etc...
10:27:08 <tensorpudding> mauke: hmm
10:27:11 <hotzen> any hint?
10:27:30 <mauke> hotzen: does it use the windows console?
10:27:34 <Paczesiowa> Spockz: iirc only if you compile Main module
10:27:35 <BONUS> hotzen: get Console
10:27:42 <BONUS> i have cygwin and Console
10:27:45 <mauke> because on XP it's right click, select, enter
10:27:52 <BONUS> i just paste by middle clicking
10:28:17 <hotzen> ok, via console i may rightclick and choose select, paste...
10:28:27 <hotzen> damn it
10:28:31 <BONUS> http://sourceforge.net/projects/console/
10:28:36 <hotzen> how to get that neat linux-right-click feature
10:28:38 <hotzen> thanks!
10:28:53 <hotzen> ah that seems to be it
10:28:55 <hotzen> thanks bonus
10:28:59 <BONUS> np bro
10:29:10 <mmorrow> chrisdone: if your Monoid instance is for a type like Map/Set/Int with mappend being {union,intersection}/{union.intersection}/{+,*} you'll want to define mconcat as foldl' mappend mempty
10:29:43 <mmorrow> chrisdone: but for (a->a)/[] and stuff like that you want foldr
10:30:19 <Spockz> Paczesiowa: yes, I do have a main :: IO () function
10:30:20 <netinho2lol> mauke: if I didn't use that deriving method, I would have to define everything by hand, right?
10:30:28 <mauke> netinho2lol: yes
10:33:10 <hotzen> console is really nice ....
10:33:11 <tristes_tigres> I am reading a paper about fingertrees http://www.soi.city.ac.uk/~ross/papers/FingerTree.pdf and don't quite understand type definition for the 2-3 trees
10:33:11 <tristes_tigres> data Tree a = Zero a | Succ (Tree (Node a))
10:33:11 <tristes_tigres> data Node a = Node2 a a j Node3 a a a
10:33:11 <tristes_tigres> What the constructor Succ is for in this definition ?
10:33:17 <hotzen> i love transparency ;)
10:34:59 <opqdonut> tristes_tigres: just "unfold" the definition of Node into Tree
10:35:31 <tristes_tigres> why not simply Tree(Node a)) ?
10:35:59 <opqdonut> and you'll get something like "data Tree a = Zero a |SuccNode2 (Tree a) (Tree a) | SuccNode3 (Tree a) (Tree a) (Tree a)
10:36:45 <opqdonut> hmm, no, wait
10:37:09 <tristes_tigres> opqdonut:argument of Succ is type, not constructor ?
10:37:33 <opqdonut> yes
10:37:43 <opqdonut> read the explanation after that definition
10:38:08 <opqdonut> "Values of type Tree a have the form Succ^n (Zero t) where t has the form Node^n a"
10:38:50 <mmorrow> tristes_tigres: here's some pictures of fingertrees (well, Data.Sequence, which is a fingertree with the Measured instance hardcoded) http://moonpatio.com/vacuum/gallery/sequence.html
10:38:59 * mmorrow loves those pictures
10:40:19 <mmorrow> data FingerTree a = Empty | Single a | Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
10:40:26 <tristes_tigres> opqdonut: I've read it, it's unclear . The lowest level should be Zero a, where a is the type of data hel by the leaf, right ?
10:40:29 <mmorrow> newtype Seq a = Seq (FingerTree (Elem a))
10:40:55 <Spockz> Paczesiowa: ah, I need to do module Main where instead of what the actual module is
10:41:03 <tristes_tigres> mmorrow: it is not helpful without actual expressions for those trees
10:41:13 <opqdonut> tristes_tigres: you see, every time we do a succ, we replace a with Node a
10:41:28 <mmorrow> tristes_tigres: what do you mean? fromList [0..n]
10:41:34 <Paczesiowa> Spockz: module Main where or just don't put module declaration (it defaults to Main)
10:41:41 <opqdonut> so after n Succs, a has become Node (Node ... (Node a)), where there are n Nodes
10:41:53 <opqdonut> and that is the type of a tree with all leafs on level N
10:42:26 <tristes_tigres> Prelude> :i fromList
10:42:26 <tristes_tigres> Top level: Not in scope: `fromList'
10:42:37 <mmorrow> @type Data.Sequence.fromList
10:42:38 <lambdabot> forall a. [a] -> Seq.Seq a
10:42:51 <Spockz> now I have another problem, it seems that putStr isn't flushed to the commandline if I compile the program
10:42:58 <Spockz> running in ghci is no problem
10:43:00 <mmorrow> tristes_tigres: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Sequence.html
10:43:04 <tristes_tigres> mmorrow, yes, i've got it, thanks
10:43:11 <Paczesiowa> Spockz: hFlush stdout
10:43:25 <Paczesiowa> Spockz: or setBuffering stdout NoBuffering
10:43:34 <Paczesiowa> Spockz: or putStrLn
10:43:37 <mauke> but you don't want NoBuffering
10:44:24 <mmorrow> tristes_tigres: the thing of note about "Zero" is that at any level beyond the first, the `a' in "Zero a" is a *Tree*, since that def uses polymorphic recursion
10:45:00 <opqdonut> that's a pretty cool data definition imo :)
10:45:16 <mmorrow> yeah
10:45:19 <opqdonut> nice way of inlining the straightforward dependent solution
10:45:26 <tristes_tigres> opqdonut: that could use a little bit longer explanation in the article ^-)
10:45:46 <opqdonut> tristes_tigres: well, it's pretty clear once you've seen a couple of things like this
10:46:04 <opqdonut> i recommend constructing some values of that type in ghci and playing around with them
10:46:21 <mmorrow> the okasaki book is a good read too
10:46:26 <opqdonut> mhmm
10:46:49 <tristes_tigres> opqdonut: in Data.Sequence ?
10:47:14 <opqdonut> tristes_tigres: i meant Tree
10:47:22 <mmorrow> data Seq a = One a | Two (Seq (a,a)) {- perfectly balanced binary trees -}
10:47:54 <opqdonut> :)
10:48:07 <tristes_tigres> mmorrow: so it's not the same thing at all
10:48:27 <mmorrow> one of the nice things about polymorphic recursion is it can be used (analogously to that type) to enforce invariant *by construction*
10:48:41 <mmorrow> in that case, the invariant that the tree is balanced
10:49:00 <mmorrow> tristes_tigres: i just used "Seq" because okasaki used "Seq" for that example iirc
10:49:08 <dolio> Those are nested types.
10:49:41 <dolio> Polymorphic recursion is when you make a recursive call in a polymorphic function at a different type.
10:49:57 <dolio> Which you often do with nested types, of course.
10:49:59 <mmorrow> well right, which the functions that operate on that
10:50:01 <mmorrow> yeah
10:50:23 <mmorrow> iirc though, okasaki used the term "polymorphic recursion" to refer to the datatypes as well (?)
10:50:45 <tristes_tigres> polymorphic recursion, is it what Oleg uses in his example of function with variable number of arguments ?
10:50:46 <dolio> I don't think so. He just remarks about how ML doesn't support polymorphic recursion.
10:50:54 <mmorrow> dolio: ah, hmm
10:51:28 <dolio> It may not support nested types, either, since it'd be hard to write a lot of operations on them without polymorphic recursion.
10:51:36 <mmorrow> yeah, it doesn't
10:52:09 <mmorrow> he gave an "algo" for rewriting a nested type to use two datatypes which weren't nested, but that together were iso to the orig
10:52:46 <dolio> Huh, I don't really remember that.
10:52:56 <tristes_tigres> http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
10:52:58 <dolio> Probably because I just ignored all the stuff about polymorphic recursion, since Haskell has it.
10:53:03 * mmorrow finds his purely functional datastructures
10:53:12 <tristes_tigres> is that polymorphic recurion ?
10:53:26 <mauke> tristes_tigres: no
10:53:30 <mmorrow> haha, turned out to be within arms reach under a stack of random papers
10:53:54 <tristes_tigres> "Functions with the variable number of (variously typed) arguments"
10:54:26 <dolio> > let nest :: Show a => Int -> a -> String ; nest 0 a = show a ; nest (n + 1) a = nest n (a,a) in nest 5 1 -- this is polymorphic recursion
10:54:27 <lambdabot>   "(((((1,1),(1,1)),((1,1),(1,1))),(((1,1),(1,1)),((1,1),(1,1)))),((((1,1),(1...
10:54:52 <mmorrow> dolio: ah. he calls them "non-uniform recursive definitions"
10:55:00 <mmorrow> oh wiat
10:55:17 <mmorrow> he says "also known as polymorphic recursion", so maybe he's refering to the functions here
10:55:19 <orbitz> Comment from teache ron my project: Can't say I know Haskall syntax, but code looked appealing
10:55:21 * mmorrow looks further
10:55:22 <orbitz> wooot
10:55:48 <mmorrow> dolio: ah, ok. "non-uniform types" is the term he uses
10:56:06 <tristes_tigres> It would have been much easier, if the paper had not just the picture of a 2-3-tree, but also its definition in Haskell
10:56:09 <opqdonut> anybody have a good example of a paper that introduces a functional data structure and proves something about it formally (i mean with coq/agda/etc)
10:57:01 <tristes_tigres> Could you write it for a tree in the paper ?
10:57:05 <mmorrow> "It is always possible to convert a non-uniform type into a uniform type by introducing a new datatype to collapse the instances into a single type. For example, by collapsing elements and pairs, the Seq type could be rewritten:
10:57:48 <mmorrow> data EP a = Elem a | Pair (EP a) (EP a); data Seq a = Nil | Cons (EP a) (Seq a)
10:57:49 <mmorrow> "
10:58:02 <mmorrow> err, and the original Seq here was/is
10:58:24 <mmorrow> data Seq a = Nil | Cons a (Seq (a,a))
10:59:43 <dolio> That doesn't look like it enforces the invariant.
11:00:04 <mmorrow> yeah, i think you lose the auto-invariant-enforcement though
11:00:09 <dolio> Ah.
11:01:38 <byorgey> well, it isn't an isomorphism then, just an injection
11:01:38 <mmorrow> yeah you do, he mentions that a paragraph down
11:01:55 <calsaverini> Hi ther
11:01:56 <mmorrow> byorgey: right
11:02:09 <byorgey> hey calsaverini
11:02:57 <mmorrow> (this is pg 144 in "purely functional datastructures" in case anyone is looking)
11:03:01 <mmorrow> err
11:03:03 <mmorrow> 143
11:03:54 <calsaverini> I'm trying to do something but I'm getting some syntax errors I guess
11:04:10 <calsaverini> can anyone see whats wrong in this code:
11:04:18 <calsaverini> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12878#a12878
11:04:20 <calsaverini> ?
11:04:49 <calsaverini> I'm trying to do something like an ''algebra of functions''
11:05:18 <calsaverini> I want to be able to sum, multiply,... any functions that are of type (Num a)=> a->a
11:06:04 <FunctorSalad> calsaverini: http://www.haskell.org/haskellwiki/Num_instance_for_functions
11:06:06 <FunctorSalad> :)
11:06:33 <FunctorSalad> ah, you are already wrapping the function
11:06:39 <tristes_tigres> :r
11:06:40 <FunctorSalad> what's the error?
11:07:18 <tristes_tigres> :r
11:07:24 <koeien37> we are not ghci
11:07:32 <tensorpudding> @botsnack
11:07:32 <lunabot>  :o
11:07:32 <lambdabot> :)
11:07:57 <calsaverini> just a sec
11:08:07 <byorgey> calsaverini: you probably want to say something like   instance (Num a) => Num (Func a) where ...
11:08:20 <calsaverini> the error message is:
11:08:24 <byorgey> instance Num Func  doesn't make sense since  Func has kind * -> *  and Num instance must have kind *
11:08:27 <calsaverini>     `Func' is not applied to enough type arguments
11:08:29 <calsaverini>     Expected kind `*', but `Func' has kind `* -> *'
11:08:30 <calsaverini>     In the instance declaration for `Num Func'
11:08:43 <calsaverini> hummm
11:08:48 <calsaverini> let me try that
11:09:04 <byorgey> 'Func' by itself is not a type, it needs an argument
11:09:06 <kmc> @src Endo
11:09:06 <lambdabot> Source not found. You speak an infinite deal of nothing
11:09:39 <FunctorSalad> you'll also need a mockup Eq instance
11:10:37 <calsaverini> Could not deduce (Show (Func a), Eq (Func a))
11:10:39 <calsaverini>       from the context (Num a)
11:10:40 <calsaverini>       arising from the superclasses of an instance declaration
11:11:00 <mauke> yeah, you need to implement Show and Eq for your functions
11:11:01 <calsaverini> so Num a is already an instance of Eq a and Show a?
11:11:05 <koeien37> no
11:11:10 <koeien37> Eq and Show are superclasses of Num
11:11:11 <kmc> calsaverini, fwiw, Data.Monoid defines a wrapper Endo, isomorphic to your Func
11:11:17 <kmc> and also with other useful instances like, well, Monoid
11:11:29 <mauke> why Endo?
11:11:29 <kmc> by an unfortunate blunder, yes
11:11:39 <kmc> why Endo what?
11:11:49 <mauke> (Num a) => Num (b -> a)
11:11:56 <calsaverini> kmc, I'll have a look on that
11:12:24 <kmc> indeed (Num a, Functor f) => Num (f a) ?
11:12:30 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs
11:12:32 <tristes_tigres> Ok, what a 2-3 tree with just two leaves look like ?
11:12:33 <tristes_tigres> Zero (Node2 't' 'a')
11:12:36 <mauke> Applicative f
11:12:40 <tristes_tigres> or Succ (Zero (Node2 't' 'a'))
11:12:44 <tensorpudding> hmm
11:13:05 <kmc> mauke, because of binary ops like (+)?
11:13:24 <mauke> yep
11:13:32 <tensorpudding> > let f +!+ g = ( \(x,y) -> x + y ) . (f &&& g) in (+2) +!+ (^2) $ 5
11:13:33 <lambdabot>   32
11:13:55 <kmc> @type (+!+)
11:13:56 <lambdabot> Not in scope: `+!+'
11:14:03 <dpratt71> (still) pondering GADTs, and I have a question...
11:14:06 <kmc> oh durr
11:14:22 <tensorpudding> it should have type (Num a) => (a->t) -> (a->t) -> (a->t) according to my ghci
11:14:28 <dpratt71> suppose I have some type T a...
11:14:40 <tristes_tigres> aha, should be Succ (Zero (Node2 't' 'a')) I guess
11:14:45 <dpratt71> ...and maybe a function T a -> a...
11:14:54 <byorgey> dpratt71: ok...
11:15:13 <dpratt71> in my *very* limited Haskell experience...
11:15:22 <tensorpudding> > let f *!* g = ( \(x,y) -> x * y ) . (f &&& g) in (+2) *!* (^2) $ 5
11:15:23 <lambdabot>   175
11:15:57 <tensorpudding> should be a replacement for that lambda...
11:16:03 <dpratt71> ok, referring to my imaginary function as "f"...
11:16:18 <dpratt71> if what I pass to "f" works out as T Int...
11:16:30 <tensorpudding> @hoogle (a,b) -> (a -> b -> c) -> c
11:16:30 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
11:16:30 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
11:16:30 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
11:16:34 <dpratt71> ...I'd expect the return type of "f" to be Int
11:16:41 <byorgey> dpratt71: yep
11:16:45 <kmc> dpratt71, yes
11:16:49 <tensorpudding> oh, just flip uncurry
11:16:49 <kmc> dpratt71, a function like this is "head"
11:16:56 <kmc> :t head
11:16:57 <lambdabot> forall a. [a] -> a
11:16:59 <dpratt71> GADTs don't seem bound by that rule
11:17:04 <kmc> :t head (3 :: Int)
11:17:05 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
11:17:06 <lambdabot>     In the first argument of `head', namely `(3 :: Int)'
11:17:06 <lambdabot>     In the expression: head (3 :: Int)
11:17:07 <byorgey> kmc: I think dpratt71 is specifically talking about GADTs
11:17:08 <tensorpudding> :t flip
11:17:09 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:17:10 <kmc> :t head [3 :: Int]
11:17:10 <lambdabot> Int
11:17:21 <kmc> dpratt71, they still are
11:17:29 <byorgey> dpratt71: they are.  what makes you think they are not?
11:17:32 <kmc> a function type (T a -> a) is still sound even if T is a GADT
11:17:41 <kmc> can you give an example where you think there's a problem
11:17:51 <tensorpudding> > let f *!* g = flip uncurry (+) . (f &&& g) in (+2) *!* (^2) $ 5
11:17:52 <dpratt71> take this type signature as an example: parse :: Parser tok a -> [tok] -> Maybe a
11:17:52 <lambdabot>   Couldn't match expected type `(a, b)'
11:17:53 <lambdabot>         against inferred type `a1 -> ...
11:18:00 <tensorpudding> err
11:18:08 <FunctorSalad> the new feature is that you can gain additional information about a depending on the *value* being passed
11:18:15 <FunctorSalad> about `a'
11:18:20 <kmc> dpratt71, the difference is, with GADTs, you can get some information about "a" merely by pattern-matching a constructor of T
11:18:26 <FunctorSalad> :)
11:18:35 <tensorpudding> > let f *!* g = uncurry (+) . (f &&& g) in (+2) *!* (^2) $ 5
11:18:36 <lambdabot>   32
11:18:36 <dpratt71> kmc: ok
11:18:39 <tensorpudding> there we go
11:19:07 <kmc> if T is non-GADT then your f :: T a -> a is specialized "all at once", e.g. to "T Int -> Int".  if T is a GADT, then it's possibly specialized on a case-by-case basis
11:19:12 <Philonous1> Is it a bad Idea to generalize [] to (Pointed w, Monoid w a) when that's all my algorithm calls for? My type constraints are getting a little out of hand
11:19:20 <kmc> where by "case" I mean the pattern matching that occurs typically in the different function equations
11:19:32 <lpsmith> > let reset (Cont f) = Cont (\k -> k (f id))
11:19:33 <lambdabot>   not an expression: `let reset (Cont f) = Cont (\k -> k (f id))'
11:19:35 <dpratt71> kmc: ok
11:19:50 <byorgey> Philonous1: what does  Monoid w a  mean?
11:19:58 <lpsmith> :t Cont
11:19:59 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
11:20:02 <byorgey> Monoid is a single-parameter type class
11:20:03 <Philonous1> I meant Monoid (w a)
11:20:11 <byorgey> ah, ok =)
11:20:25 <FunctorSalad> Philonous1: hmm depends... the price is unclearer error messages
11:20:34 <byorgey> Philonous1: it's not necessarily a bad idea.
11:20:38 <dpratt71> kmc: so if the return type of "f" resolved to [Int], does this mean that the parameter of "f" also has type T [Int]?
11:20:43 <byorgey> it depends on how useful it would be to have a generalized version.
11:20:49 <FunctorSalad> yes
11:20:56 <byorgey> or whether generalizing in this way would give you better insight into what you are really trying to do.
11:20:58 <kmc> dpratt71, yes, if "f :: T a -> a"
11:21:34 <calsaverini> ok, I managed to get it to work
11:21:39 <dpratt71> kmc: ok, thanks, I'm gonna go see if I can make sense of that in the example I'm looking at
11:21:45 <byorgey> dpratt71: indeed.  and if T is a GADT, that might mean that it is no longer possible to get some of the constructors of T as arguments
11:21:45 <Philonous1> I'm thinking about doing something like "class (Pointed w, Monoid (w a) => Container w); instance (Pointed w, Monoid (w a) => Container w)" to keep it short
11:21:58 <byorgey> dpratt71: since they might, for example, yield  a T Bool
11:22:33 <dpratt71> byorgey: someday I hope that statements such as that will make some sense to me :)
11:22:48 <calsaverini> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12878 - this works fine
11:22:57 <byorgey> dpratt71: I think that day will probably be very soon.  you should just keep playing around with some examples. =)
11:23:07 <calsaverini> but, I was thinking...
11:23:24 <byorgey> Philonous1: sure, that's a good idea
11:23:27 <dpratt71> byorgey: thanks for the encouragement
11:23:33 <kmc> dpratt71, did you look at the GADT example in the GHC manual?
11:23:42 <kmc> it's simpler than the "Parser" one
11:23:48 <calsaverini> when I do something like: f = 2 + (Func sin), the compiler understands what I'm talking about and automactically uses fromInteger to translate 2 to a function.
11:23:57 <dpratt71> kmc: I think so, yes
11:24:08 <dpratt71> kmc: I've looked at several
11:24:13 <calsaverini> Is there a way for me to tell the compiler to interpret 2 + sin as (fromInteger 2) + (Func sin)?
11:24:17 <kmc> :t 2
11:24:18 <lambdabot> forall t. (Num t) => t
11:24:49 <byorgey> calsaverini: no.  sin  and  Func sin  have different types.
11:25:03 <dpratt71> kmc, et al: the general idea of GADTs makes some sense to me; it's just clear to me that I have to update my mental model for these things
11:25:05 <mauke> calsaverini: yes
11:25:17 <dpratt71> uh...no pun intended :)
11:25:20 <byorgey> mauke: how?
11:25:28 <calsaverini> hahaha
11:25:28 <mauke> well, sin is a method of Floating
11:25:29 <Philonous1> Oh, and how can I assert that a type w has forall a. Monoid (w a) ?
11:25:34 <calsaverini> I'm confused now
11:25:34 <tensorpudding> @src abs
11:25:35 <lambdabot> Source not found.
11:26:20 <mauke> oh wait
11:26:22 <kmc> calsaverini, no.  the thing with "2" works because numerical literals have typeclass-polymorphic type
11:26:24 <mauke> I misthunk
11:27:14 <kmc> import Prelude hiding(sin); import qualified Prelude as P; class Sinful a where { sin :: a }; instance (Floating a) => Sinful (a -> a) where { sin = P.sin }
11:27:20 <aavogt> Philonous1: looks like MonadPlus or Alternative
11:29:38 <Philonous1> aavogt: But it's neither a monad nor an applicative necessarily. It's really a syntactic question. Having (Monoid (w a) => ... ) doesn't work because a is not in scope, but I can't just add a forall a. in the type constraint either
11:30:06 <kmc> Philonous1, why not?
11:30:20 <dolio> You're not allowed to quantify inside constraints.
11:30:29 <dolio> That constraint is impossible to express.
11:30:31 <Philonous1> ghc complaints about a malformed class assertion
11:30:39 <kmc> i meant outside
11:30:46 <Philonous1> example?
11:30:48 <kmc> but, maybe you want an existential wrapper on Monoid instead
11:32:33 <byorgey> Philonous1: ah, yeah, I've run into this before.  The solution (which is sort of ugly) is to have a "higher-order" Monoid-like class
11:33:33 <byorgey> something like   class Monoid1 w where  mempty1 :: w a;   mappend1 :: w a -> w a -> w a
11:34:34 <lpsmith> @let reset (Cont f) = Cont (\k -> k (f id))
11:34:35 <lambdabot>  Defined.
11:35:14 <byorgey> then you can also have   instance Monoid w => Monoid (w a) where  mempty = mempty1; mappend = mappend1.  ...I think.
11:35:17 <lpsmith> Now,  can reset be defined in terms of (>>=),  return,  callCC,  mapCont,  and possibly runCont?
11:35:33 <tristes_tigres> suppose I want to clone my windowsinstallation of GHC, with all cabal packages. Is it enough to copy the directory
11:35:33 <tristes_tigres> C:\Documents and Settings\Admin\Application Data\cabal
11:35:39 <byorgey> I've made something like this work in the past but I don't quite remember the details.  It's fiddly.
11:35:41 <tristes_tigres> and run cabal install ?
11:35:43 <Polarina> What's the *practical* difference between where and let?
11:35:48 <Philonous1> Ah, that is nifty. But my inner type is fixed anyway. It would just be great if one could express that in a general fashion
11:36:04 <aavogt> @google let vs where haskell wiki
11:36:05 <lambdabot> http://www.haskell.org/haskellwiki/Let_vs._Where
11:36:06 <lambdabot> Title: Let vs. Where - HaskellWiki
11:36:25 <tensorpudding> @pl f `foo` g = \x -> (f x) + (g x)
11:36:25 <lambdabot> (line 1, column 11):
11:36:25 <lambdabot> unexpected "="
11:36:25 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
11:36:36 <tensorpudding> @pl f `foo` g = (\x -> (f x) + (g x))
11:36:36 <lambdabot> (line 1, column 11):
11:36:36 <lambdabot> unexpected "="
11:36:36 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
11:36:55 <tensorpudding> @pl n f g = (\x -> (f x) + (g x))
11:36:55 <lambdabot> n = liftM2 (+)
11:37:02 <mmorrow> Polarina: there is none
11:37:07 <tensorpudding> bwah?
11:37:11 <mmorrow> Polarina: where is "syntactic sugar"
11:37:26 <mmorrow> Polarina: well, actually syntactically "where" isn't part of an expression
11:37:35 <mmorrow> Polarina: but semantically they're the same
11:37:41 <Polarina> Ah.
11:37:54 <Polarina> So it's more of a matter which works and which I prefer?
11:37:57 <koeien37> @pl (\f g x -> f x + g x)
11:37:57 <lambdabot> liftM2 (+)
11:38:21 <mmorrow> , x where x = 4 {- lunabot expects an *expression* -}
11:38:22 <lunabot>  luna: parse error on input `where'
11:38:27 <mmorrow> , let x = 4 in x {- lunabot expects an *expression* -}
11:38:29 <lunabot>  4
11:38:41 <lpsmith> the scope varies a little bit,  using    f x | cond1 = ... | cond2 = ...  where will scope over the two conditions whereas a let will only scope over one
11:38:48 <MoALTz> @pl (map ((-ord '0'+) . ord) . show)
11:38:48 <lambdabot> (line 1, column 8):
11:38:49 <lambdabot> unexpected "-"
11:38:49 <lambdabot> expecting lambda abstraction or expression
11:39:13 <mmorrow> , let f x = y where y = x * 2 in f 20
11:39:15 <lunabot>  40
11:39:26 <MoALTz> that works in ghc btw
11:39:31 <mmorrow> "where" is really an "attachment" to a declaration
11:39:33 <lpsmith> But on the other hand you could always rewrite that as  f x = let ... in if cond1 then ... else if cond2 then ... else error "message"
11:39:37 <mmorrow> , src 'LetE
11:39:41 <lunabot>  data Exp = ... | LetE ([Dec]) Exp | ...
11:39:41 <lunabot>  infixl 9
11:39:59 <mmorrow> , src 'FunD
11:40:02 <lunabot>  data Dec = ... | FunD Name ([Clause]) | ...
11:40:02 <lunabot>  infixl 9
11:40:10 <mmorrow> , src 'Clause
11:40:13 <lunabot>  data Clause = ... | Clause ([Pat]) Body ([Dec]) | ...
11:40:13 <lunabot>  infixl 9
11:40:23 <mmorrow> the [Dec] there in Clause is the "where"
11:40:47 <mmorrow> , [d|f x = y where y = 2 * x|]
11:40:49 <lunabot>  FunD f [Clause [VarP x_0] (NormalB (VarE y_1)) [ValD (VarP y_1) (NormalB ...
11:42:05 <MoALTz> @pl (map ((-(ord '0')+) . ord) . show)
11:42:05 <lambdabot> (line 1, column 8):
11:42:05 <lambdabot> unexpected "-"
11:42:05 <lambdabot> expecting lambda abstraction or expression
11:42:12 <MoALTz> nevermind
11:44:07 <kmc> > let { x = y } where { y = () } in x
11:44:07 <lambdabot>   <no location info>: parse error on input `where'
11:44:22 <kmc> > let { x = y where y = () } in x
11:44:22 <lambdabot>   ()
11:46:19 <lpsmith> :t reset
11:46:20 <lambdabot> forall a r. Cont a a -> Cont r a
11:46:39 <lpsmith> :t mapCont
11:46:40 <lambdabot> forall r a. (r -> r) -> Cont r a -> Cont r a
11:46:54 <lpsmith> :t callCC
11:46:55 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:47:49 <lpsmith> What bothers me is that mapCont, callCC,  return and bind doesn't appear to offer the ability to change the final result type of a Continuation monad
11:48:36 <ksf> it must be fixed, due to static typing
11:48:46 <lpsmith> But on the other hand my (quite possibly incorrect) intuition seems to suggest that the existence of such an implementation seems to be plausible
11:49:30 <chrisdone> @hoogle String -> ByteString
11:49:30 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
11:49:31 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
11:49:31 <lambdabot> Prelude read :: Read a => String -> a
11:49:50 <ksf> and the last continuation, is, at least usually, "terminate", anyway.
11:49:52 <lpsmith> ksf:  by that logic,  the "a" in "m a" must also be fixed :-)
11:50:08 <mmorrow> lpsmith: i think it might be that since the *entire* program isn't cps-transformed, you eventually leave the cps monad and return to a context which is expecting a result of a particular type
11:50:37 <mmorrow> whereas if the cps-transform was global, the "answer type" wouldn't matter
11:50:39 <ksf> :t runCont
11:50:40 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
11:50:46 <mmorrow> since it's never actually reached
11:51:18 <ksf> @src Cont
11:51:19 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
11:52:23 <ksf> one doesn't fix r when giving a type sig to a cps function, too.
11:52:48 <ksf> so it stays polymorphic, and is only fixed when you call runCont
11:53:54 <mmorrow> ksf: if the entire program was cps-transformed, you'd be existing in an ambient Cont a = Cons (forall o. (a -> o) -> o)
11:54:00 <ksf> but you shouldn't listen to me, as continuations still tend to confuse the hell out of me.
11:54:03 <mmorrow> s/Cons/Cont/
11:54:55 <mmorrow> well, i think that's only technically half-correct, but the point is that the "o" doesn't matter
11:55:15 <lpsmith> mmorrow:  is that true?   You can't implement callCC on the codensity monad like that
11:55:20 <Saizan> you might want to fix the 'r' to use control effects
11:55:28 <FunctorSalad> Cons a = a
11:55:38 <FunctorSalad> (with the 'forall')
11:55:48 <mmorrow> lpsmith: right, that's why i say "half-correct", the semantics of "forall" in that def in in the context of haskell make that different
11:57:08 <mmorrow> i'm not sure how to express what a global cps-transform's "ambient monad" would be with a haskell data def (i'm not even sure if it would /have/ an "ambient monad", where "have" := could be rigorously modeled with a haskell monad via haskell data defs)
11:57:09 <lpsmith> ksf:  I still find continuations confusing at times ;-)
11:57:28 <mmorrow> the initial continuation would be
11:57:38 <mmorrow> (\x -> exit 0)
11:57:47 <FunctorSalad> mmorrow: maybe o = a special token?
11:57:55 <mmorrow> "maybe o"?
11:57:57 <FunctorSalad> but I'm qutie clueless about global cps-transform
11:57:59 <FunctorSalad> *quite
11:58:04 <mmorrow> oh
11:58:07 <mmorrow> i see how you mean
11:58:12 <mmorrow> heh, i'm not sure
11:58:15 <FunctorSalad> the `maybe' was natural language yes ;)
11:58:29 <IceDane> Is it wrong to look at foldr's way of doing things as building the list from the end to the start?
11:58:38 <junmin> hello, how can correct these two line? thanks.    8 isFeasible :: Num a => [a] -> Bool
11:58:39 <mauke> IceDane: yes
11:58:40 <junmin>  9 isFeasible s =  (s !! 0)+1 >= 0
11:58:57 <IceDane> I thought so, because foldl is giving me the same results if I do the same thing
11:59:46 <FunctorSalad> you can think of it as replacing all the `:' and the `[]' with the algebra you specified
12:00:05 <FunctorSalad> where evaluation starts may depend on how the result is used
12:00:07 <IceDane> Yeah, I had heard of that
12:01:10 <IceDane> Thing is, i'm trying to create a list of strings, each one rotated by 1 compared to the next one(to the right). I want to have (0 rot, 1 rot, 2 rot), but I end up with (26 rot, 25 rot, 24 rot), basically the reverse
12:01:18 <IceDane> 26 = length of the string, so it's the same as 0 rot
12:01:29 <IceDane> What could i be doing wrong here?
12:01:50 <koeien37> shift in the wrong direction?
12:02:14 <FunctorSalad> using foldl and consing inside?
12:02:17 <junmin> i would like to use both Num and Ord classes, what should i do? http://dpaste.com/123420/ thanks
12:02:22 <IceDane> FunctorSalad: Currently using foldr
12:02:28 <FunctorSalad> > foldl (\x y -> y:x) [] [0..10]
12:02:29 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
12:02:36 <FunctorSalad> ah
12:02:40 <IceDane> yeah
12:02:43 <dolio> (Ord a, Num a) => ...
12:03:06 <junmin> dolio: thanks
12:03:10 <IceDane> foldl (\(a:as) b -> rotate 1 a : a : as) [['a' .. 'z'] ] [0..25]
12:03:17 <IceDane> > foldl (\(a:as) b -> rotate 1 a : a : as) [['a' .. 'z'] ] [0..25]
12:03:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:03:18 <lambdabot>         against inferred type ...
12:03:28 <IceDane> ah, duh
12:03:32 <IceDane> rotate isn't defined
12:03:33 <IceDane> anyway
12:03:37 <IceDane> you get what it does
12:04:04 <FunctorSalad> b is unused
12:04:22 <dolio> mmorrow: Just use a new type constructor '¬ a' for continuations.
12:04:46 <junmin> dolio: can i define (Num a, Ord a) a new type?
12:04:47 <IceDane> Yeah, because I started by using b to rotate, but then it'd be rotating 0, then rotating 1, then rotating 1
12:04:54 <IceDane> 2, rotating 2+3.. etc
12:04:56 <mmorrow> dolio: aha
12:05:07 <mmorrow> dolio: (a -> Void) -> Void ?
12:05:10 <koeien37> junmin: class C a;  instance (Num a, Ord a) => C a
12:05:25 <byorgey> except don't call it C, that's a horrible name.
12:05:27 <koeien37> class (Num a, Ord a) => C a; -- sorry
12:05:30 <koeien37> byorgey: of course.
12:05:45 <ben0x539> ghc needs a "why the hell are you inferring/expecting that type" button
12:05:47 <dolio> mmorrow: Well, that recommendation just treats negation as abstract, so you don't have to worry about how it's implemented.
12:05:48 <yitz> he want it for a type, not a class
12:05:49 <FunctorSalad> byorgey: wink wink? ;)
12:05:51 <junmin> koeien37: thanks
12:05:57 <mmorrow> dolio: ah right, that makes sense
12:05:58 <yitz> or she
12:06:04 <byorgey> FunctorSalad: hehe
12:06:26 <koeien37> referring to Numeric Prelude? ;)
12:06:57 <tristes_tigres> mmorrow: what is missing from the vaccuum library is the source used to generate the gallery examples
12:07:12 <mmorrow> tristes_tigres: do you mean the actual images?
12:07:14 <kmc> mmorrow, (\x -> x >> exit 0) ?
12:07:26 <mmorrow> tristes_tigres: because the haskell expression they came from are right there
12:07:35 <tristes_tigres> mmorrow: yes, the graphiz source
12:07:45 <mmorrow> tristes_tigres: for the images, i used graphviz + ImageMagick's montage program
12:08:14 <mmorrow> tristes_tigres: via vacuum's (ppDot . namesGraph) functions
12:08:22 <Guest3654> can anyone recomend a website with tutorials? I want to be able to read from a file and using lines to insert them in a [String] but I don't want any complete solution. Just want some hints and how I should think
12:08:39 <mmorrow> kmc: `x' though is anything
12:08:46 <kmc> IceDane, can you hpaste your code?
12:08:51 <dolio> mmorrow: It probably means you have to finesse some types of cps transformed lambda terms, though.
12:08:52 <mmorrow> Int, IO (IO (IO (Tree Double))), etc
12:08:56 <IceDane> kmc: Sure, thanks
12:09:27 <mmorrow> dolio: hmm
12:09:35 <dolio> \x -> x ==> \x k -> k x : ¬ (a, ¬a), for instance.
12:09:45 <mmorrow> ahh, right ok
12:10:23 <mmorrow> , "¬"
12:10:25 <lunabot>  "\172"
12:10:29 <IceDane> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12882#a12882
12:11:08 <chrisdone> I love -XOverloadedStrings
12:11:17 <IceDane> Oh, I think I have may found a solution
12:11:28 <dolio> Of course, if you define a -> b = ¬(a*¬b) in your CPS calculus, the type stays the same as in the source language.
12:11:55 <IceDane> But it's a bad one
12:13:16 <dolio> But it's a bit odd that functions that look curried end up with types involving products.
12:14:58 <tristes_tigres> mmorrow: the picture I got with
12:14:58 <tristes_tigres> ss = fmap (\ i -> fromList [0 .. i]) [1 .. 8]
12:14:58 <tristes_tigres> writeFile "tr2.dot" $show (ppDot . nameGraph $ vacuum (ss))
12:14:58 <tristes_tigres> is not at all like the one in the gallery
12:14:59 <Twey> Guest3654: hGetContents.
12:15:41 <mmorrow> dolio: oh right. so i just disentangled what we're talking about. (stating this to make sure i'm fully groking), (before your last two sentences) we were talking about taking a haskell program with haskell types, then cps transforming it while at the same time transforming the types (Haskell -> Haskell) by adding a new primitive ¬
12:16:07 <FunctorSalad> chrisdone: tell me about it... instance IsString Exp where fromString = ignoreError . parseExp
12:16:09 <FunctorSalad> hehehe
12:16:17 <FunctorSalad> (Language.Haskell.Exts.Exp)
12:16:47 <FunctorSalad> but it can get confusing
12:17:08 <FunctorSalad> oh and of course: instance (Monad m, IsString a) => IsString (m a) wher e...
12:17:12 <Guest3654> can someone take a look at this IO problem ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12883#a12883
12:17:14 <FunctorSalad> works with OverlappingInstances
12:17:22 <mmorrow> dolio: and then, say we alternatively cps-transformed the haskell, but transformed the types to the types of some "CPS calculus". SO, now completing the triangle and mapping the Cps-ified-Haskell types to the CPS type system we'd end up with the same types as we'd have had if we went from Haskell -> Cps types originally?
12:17:25 <dolio> mmorrow: Right. Instead of adding some abstract, global 'result type' and making continuations 'a -> T'.
12:17:43 <mmorrow> ok
12:18:42 <dolio> Well, you can define a -> b as an abbreviation for ¬(a*¬b) in the CPS types.
12:19:16 <dolio> Then the CPS transform of the haskell type a -> b should be able to be abbreviated as a -> b.
12:19:18 <mmorrow> hmm, that's the part that i'm not fully getting. what does * mean here?
12:19:28 <dolio> Pair.
12:19:30 <tristes_tigres> mmorrow: the picture in the gallery is organized differently. - did you hand-edited them ?
12:19:31 <mmorrow> ah, i see
12:20:00 <mmorrow> tristes_tigres: hmm, differently as in from left-to-right rather than top-to-bottom orientation?
12:20:01 <dolio> A function from a to b is a continuation taking an a and a b-continuation.
12:20:33 <mmorrow> tristes_tigres: because i've changed that in the dot output since the first vacuum version when i made those, but other than that i think they should be the same (??)
12:20:35 <tristes_tigres> mmorrow:no, I mean really different
12:20:39 <mmorrow> hmm
12:20:49 <mmorrow> tristes_tigres: different how?
12:22:06 <mmorrow> tristes_tigres: it might be your graphviz, and also iirc the shape of the resulting graph depends on the ordering of the nodes and edges in the dot file, and additionally may even be non-deterministic (or maybe that's another one of the layout progs that's non-det)
12:22:33 <mmorrow> dolio: oh. right, i got you now.
12:22:53 <BMeph> > let rotaters = map (\xs -> (tails xs, inits xs)) in uncurry (flip (++)) . rotaters $ [0..7]
12:22:54 <lambdabot>   Couldn't match expected type `(b, b)'
12:22:54 <lambdabot>         against inferred type `[([[a]...
12:23:12 <mmorrow> tristes_tigres: but i didn't hand-edit the actual dot files i used to make those gallery images
12:23:16 <BMeph> > let rotaters = map (\xs -> (tails xs, inits xs)) in map (uncurry (flip (++))) . rotaters $ [0..7]
12:23:17 <lambdabot>   No instance for (GHC.Enum.Enum [a])
12:23:17 <lambdabot>    arising from the arithmetic sequence...
12:23:57 <mmorrow> tristes_tigres: but i did have to resort to some non-trivial montage command-line args to get the sizes/proportions/etc like that
12:24:37 <kmc> Guest3654, what do you want to do with this [String] you're building?
12:24:47 <alexander> what can go wrong with -XNoMonomorphismRestriction
12:24:59 <alexander> how can i fuck stuff up?
12:25:10 <koeien37> alexander: unexpected slowdowns when you use polymorphic values that seem monomorphic to you
12:25:36 <koeien37> alexander: but the monomorphism restriction is evil, and i often switch it off. (in fact my ~/.ghci switches it off for me.)
12:25:40 <Guest3654> kmc this function I am creating should be a part of another solution. So acctually for this function I want to get a [String] a list with strings seperated like ["line1", "line2"]
12:25:49 <alexander> i can live with that, i guess :)
12:25:57 <kmc> okay
12:25:59 <Guest3654> kmc how should my definition look like ?
12:26:09 <kmc> and you don't want to use readFile and lines?
12:26:54 <Guest3654> kmc you mean I can use thoose two and skip the mainloop thing?
12:26:55 <kmc> Guest3654, the type would be like Handle -> [String] -> IO [String]
12:27:15 <kmc> :t lines <$> readFile "foo"
12:27:15 <alexander> koeien37: if i don't add that i think i might have to att "fromIntegral" ALL over my code :/
12:27:16 <lambdabot> IO [String]
12:27:28 <mmorrow> tristes_tigres: oh wait, i you're talking about the "ss = fmap (\ i -> fromList [0 .. i]) [1 .. 8]", i meant that conceptually, i rendered each of the Sequences in that resulting list *separately*
12:27:34 <mmorrow> *..if you're..
12:28:05 <calsaverini> I commonly come across an error I can't understand
12:28:07 <ddarius> fromList . enumFromTo
12:28:09 <ddarius> fromList . enumFromTo 0
12:28:10 <koeien37> alexander: that can not be the case
12:28:41 <calsaverini> supose I have a class defined like this:
12:28:43 <koeien37> alexander: the monomorphism restriction kicks in when you have a definition without arguments in your module. e.g. "x = 3"
12:28:45 <kmc> Guest3654, if all you want is a list of lines, that'd be the easiest way
12:29:09 <kmc> if you have more specific requirements then you might want to write your own loop
12:29:12 <Guest3654> kmc and what is <$> , where I should write my list?
12:29:20 <calsaverini> supose you have:   class Blabla a where  \\  somefunc :: (Num b)=> b -> a ->a
12:29:24 <kmc> <$> is from Control.Applicative
12:29:30 <kmc> it's the same as "fmap", which is in the Functor typeclass
12:29:32 <kmc> :t (<$>)
12:29:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:29:40 <tristes_tigres> mmorrow: OK, yes, that's it
12:29:41 <kmc> :t liftM
12:29:42 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:29:48 <kmc> also the same as liftM, modulo Monad -> Functor
12:29:52 <alexander> koeien37: oh, yeah, that seems right
12:30:03 <koeien37> alexander: you can always add explicit sigs to avoid it
12:30:05 <calsaverini> then I try to instantiate this like: instance Blabla Int where \\ somefunc x y = x+y
12:30:09 <kmc> so in this case, we're taking a simple function lines :: String -> [String], and "lifting" it to work on IO String -> IO [String]
12:30:17 <calsaverini> ops
12:30:25 <kmc> Guest3654, it's the same as do { x <- readFile "foo"; return (lines x) }
12:30:34 <calsaverini> wait a min, let me come up with a true example
12:30:38 <Guest3654> kmc but you said Handle -> [String] -> IO [String] wouldn't it be Handle -> IO [String] ?
12:30:47 <Guest3654> kmc oh
12:30:48 <kmc> yes if you're doing it this way
12:31:07 <kmc> what i meant before was, if you're writing your own loop, you'll need to remember the lines read so far as an argument
12:31:13 <kmc> also, it is inefficient to add to the end of a list
12:31:24 <kmc> so i'd build the lines in reversed order, then reverse them once
12:31:32 <kmc> or use a different datastructure like Data.Sequence
12:31:54 <Guest3654> kmc will this be in the reverse order you say?
12:32:14 <kmc> will what
12:32:28 <Guest3654> oh no sorry missunderstanding
12:32:32 <IceDane> position :: a -> [a] -> Int - shouldn't "position . minimum someList $ someList" work ?
12:32:49 <kmc> IceDane, ? work how?
12:32:56 <Guest3654> thanks alot kmc gonna try it out =) you the best
12:33:01 <IceDane> It's not compiling, I mean :P
12:33:06 <IceDane> eh
12:33:09 <kmc> type error?
12:33:13 <IceDane> Yeah
12:33:31 <kmc> you want position (minimum someList) someList
12:33:33 <kmc> ?
12:33:34 <koeien37> IceDane: you mean "position (minimum somList) someList
12:33:42 <kmc> (also that's an inefficient way to do that)
12:33:51 <kmc> what you had before is position (minimum someList someList)
12:33:57 <kmc> which don't make a lot of sense
12:33:59 <IceDane> Yeah, I know that will work, but I'm wondering if composition can't do it as well?
12:34:04 <ddarius> @pl \someList -> position (minimum someList) someList
12:34:04 <lambdabot> position =<< minimum
12:34:05 <IceDane> oh..
12:34:15 <kmc> err it's not that either
12:34:28 <IceDane> Thanks
12:34:37 <kmc> it's \x -> position (minimum someList someList x)
12:36:54 <calsaverini> ok, now I got it. My problem is exemplified by this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12884#a12884
12:37:48 <calsaverini> oh no, Blabla should be Someclass
12:38:21 <tensorpudding> @pl \x -> abs (f x)
12:38:21 <lambdabot> abs . f
12:39:12 <calsaverini> now it's corrected... how I tell haskell that in my specific instance, that (Num b) I used in the definition of the class must be an specific instance of Num?
12:39:32 <junmin> :| why this error in this small codes http://dpaste.com/123430/
12:42:45 <kmc> junmin, the type of the argument is "(Variable v) => [v]"
12:43:03 <kmc> and you haven't told it anything more about the type of your list [1,2]
12:43:05 <kmc> :t [1,2]
12:43:06 <lambdabot> forall t. (Num t) => [t]
12:43:23 <kmc> try:  function ([1,2] :: Integer)
12:43:28 <kmc> err
12:43:33 <kmc> function ([1,2] :: [Integer])
12:47:00 * ksf thinks we should have code katas, too.
12:47:20 <ksf> ...well actually I'm complaining because I don't want to do the ruby ones.
12:47:25 <copumpkin> who'd decide the criteria?
12:47:57 <roconnor> what are code katas?
12:48:02 <ksf> what criteria?
12:48:26 <ksf> roconnor, the same practice as in karate, just with code.
12:48:31 <hotzen> class Mult a b c where (*) :: a -> b -> c
12:48:35 <roconnor> what are katas in karate?
12:48:37 <copumpkin> criteria for katas
12:48:44 <hotzen> class Mult a b c where (*) :: a -> b -> c
12:48:44 <hotzen> instance Mult Matrix Matrix Matrix
12:48:45 <junmin> kmc: you mean "type Solution v = Variable v => [v]" ? it's giving me an error
12:48:49 <hotzen> sorry
12:49:08 <ksf> a set sequence of movements, that you go through over and over again.
12:49:16 <copumpkin> hotzen: not sure that's a great idea, although it's been brought up multiple times
12:49:33 <roconnor> ksf: isn't that the antithesis of abstractin?
12:49:35 <hotzen> class Mult a b c where (*) :: a -> b -> c
12:49:35 <hotzen> instance Mult Matrix Matrix Matrix
12:49:35 <hotzen> instance Mult Matrix Vector Vector where
12:49:35 <hotzen> m1, m2, m3 :: Matrix
12:49:35 <hotzen> (m1 * m2) * m3 -- WHY IS type of (m1*m2) ambiguous?
12:49:41 <hotzen> sorry for multi-paste
12:49:44 <copumpkin> hotzen: that's why it isn't a great idea
12:49:46 <copumpkin> @hpaste
12:49:46 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:49:53 <roconnor> hotzen: you need fundep (or something like that0
12:49:55 <copumpkin> hotzen: you can create a functional dependency if you want to improve things a bit
12:49:55 <hotzen> i dont understand the ambiguity...
12:50:01 <roconnor> hotzen: and you can't resue (*) (easily).
12:50:04 <ksf> roconnor, not really.
12:50:05 <roconnor> reuse
12:50:11 <hotzen> im just reading fun deps but i dont undesrtand the ambiguity
12:50:24 <kmc> junmin, no
12:50:28 <ksf> ...because abstractions leak.
12:50:38 <Philonous1> hotzen: You could have instance Mult Vector Vector Scalar -- inner product or Mult Vector Vector Matrix -- outer product, both at the same time
12:50:47 <kmc> your error is that [1,2] has ambiguous type
12:50:50 <ksf> see you can't just hear a pinanist play, abstract that and then say "now I can play like him"
12:50:51 <kmc> :t [1,2]
12:50:52 <lambdabot> forall t. (Num t) => [t]
12:50:55 <roconnor> hotzen: (m1*m2) could be Char if someone decides to write Instance Mult Matrix Matrix Char somewhere else.
12:51:00 <hotzen> ahhh, you're right thanks philonous1
12:51:09 <hotzen> yeah
12:51:13 <hotzen> thanks alot
12:51:26 <kmc> try:  function ([1,2] :: [Integer])
12:51:44 <ksf> the point is to not stop at a piece of code when you've got it working, but when you've got it to its most perfect form, and then continue to do it until you can do it sleeping.
12:52:06 <hotzen> hm
12:52:42 <junmin> kmc: No instance for (Variable Integer)
12:53:01 <kmc> junmin, well, okay.... what types *do* have an instance for Variable?
12:53:15 <roconnor> @instances Variable
12:53:16 <lambdabot> Couldn't find class `Variable'. Try @instances-importing
12:53:20 <kmc> when you said "[1,2]", what types did you mean for 1 and 2 to have?
12:53:22 <hotzen> just to get sure: its ambiguos because I *may* define other instances defining other types for Matrix Matrix Multiplication?
12:53:42 <roconnor> yep
12:53:44 <roconnor> or someone else
12:53:53 <hotzen> thanks
12:54:11 <ksf> roconnor, out of the top of your head, what does a function that takes a list sorted list of [(Float,Char)], to a binary tree with the char at the leaves and floats at the branches, ready for log n lookup?
12:54:27 <roconnor> hotzen: there might be a GHC flag that will let you proceed. ... unsafely
12:54:28 <ksf> ...look like?
12:54:46 <hotzen> roconnor: i dont want to proceed, i seek understanding ;)
12:55:11 <roconnor> @hoogle [(a,b)] -> Map a b
12:55:11 <lambdabot> Data.Map fromDistinctAscList :: [(k, a)] -> Map k a
12:55:12 <lambdabot> Data.Map fromList :: Ord k => [(k, a)] -> Map k a
12:55:12 <lambdabot> Data.Map fromAscList :: Eq k => [(k, a)] -> Map k a
12:55:14 <kmc> hotzen, the fundep is how you tell it "class Mult a b c where a and b together uniquely determine c"
12:55:16 <ksf> you can't understand without proceeding.
12:55:19 <kmc> it's written "class Mult a b c | a b -> c"
12:55:20 <roconnor> ksf: fromAscLIst
12:55:24 <kmc> you can also do it with associated types
12:55:29 <ksf> roconnor, wrong answer.
12:55:34 <ksf> how do you _write_ it.
12:55:35 <roconnor> dang
12:55:40 <roconnor> me
12:55:45 <ksf> :t fromAscList
12:55:46 <lambdabot> Not in scope: `fromAscList'
12:55:50 <ksf> see?
12:55:56 <roconnor> import Data.Map  (fromAscList)
12:55:58 <hotzen> kmc: yes im currently working thru fun-deps and type families
12:56:00 <roconnor> that's what I'd write
12:56:05 <roconnor> thanks to the wonders of abstraction!
12:56:09 <junmin> kmc: thanks... i think i need to read a book :|
12:56:15 <junmin> completly
12:56:20 <BMeph> Y"know, that really is an annoying kind of error, ambiguosity of open classes. It's like calling up your boss and saying you're not coming into work because an asteroid might crash on the train you're riding, but still expecting to get paid, since you haven't quit.
12:56:30 <kmc> junmin, indeed
12:56:36 <sproingie> ambiguosity
12:56:42 <kmc> you're declaring a typeclass with no class members and no instances
12:56:46 <ksf> roconnor, so we're going to be left with people that could equally well just use ruby on rails to do the same job.
12:56:47 <kmc> that's a very strange thing to do
12:57:21 <roconnor> ksf: I prefer to see it as expanding the sphere of people who can write programs.
12:57:34 <ksf> roconnor, in the end, you have to do some kind of repetition pracice in some field you like to see the point
12:57:39 <kmc> junmin, also, (!!) is not usually the right way to work with lists
12:57:47 <kmc> if you want to get the first and second elements of a list, it'd look like:
12:57:50 <roconnor> ksf: that is an interesting claim.
12:57:52 <junmin> kmc: i supposed that [1,2]::[Integer] gives an instance
12:57:55 <kmc> > let f (x:y:_) = x+y in f [2,3,4,5]
12:57:56 <lambdabot>   5
12:58:18 <toast-opt> sorry, !! is get nth?
12:58:21 <ksf> ...basically, fromAscList doesn't give you any understanding of data structures.
12:58:48 <kmc> toast-opt, yes
12:58:50 <kmc> @src (!!)
12:58:50 <lambdabot> xs     !! n | n < 0 = undefined
12:58:50 <lambdabot> []     !! _         = undefined
12:58:50 <lambdabot> (x:_)  !! 0         = x
12:58:50 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:58:59 <roconnor> I don't need to understand the data structures ... (untill I get a leaky abstraction ;)
12:59:08 <kmc> junmin, no.  the syntax there is (e :: t) and it simply declares to the compiler that expression e has type t
12:59:15 <kmc> it's called a type signature
12:59:21 <kmc> generally types are figured out for us
12:59:24 <ksf> but the mental truth, where one hovers, zoned in between conscious (in)competence and unconsious competence, is way more telling, if you can not only do it, but also observe and optimize it.
12:59:25 <sproingie> !! is get nth and it's O(n)
12:59:34 <kmc> but when they are not, or we want extra documentation, we can use ::
12:59:45 <ksf> that's, then, abstraction, too: but not of a piece of code, but of your mode of work.
13:00:04 <toast-opt> ah, thx
13:00:18 <kmc> is there a list on the wiki of features commonly overused by beginners?
13:00:31 <kmc> i'd like to nominate "if then else", (!!), and especially head
13:00:33 <djwonk> i'm doing some simple command line input parsing. for example, i want to convert "r 3 3" to ("r", 3, 3). i'm struggle to find easy, simple examples for `read`
13:00:57 <ksf> > read 3 :: Int
13:00:58 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
13:00:58 <lambdabot>    arising from the literal `...
13:01:01 <kmc> > read "[1,2,3]" :: [Int]
13:01:02 <lambdabot>   [1,2,3]
13:01:03 <roconnor> ksf: I'm still pretty sure that fromAsc is the right answer.
13:01:06 <ksf> > read "3" :: Int
13:01:07 <lambdabot>   3
13:01:20 <kmc> djwonk, that's a 3-tuple?
13:01:26 <djwonk> ksf: yes
13:01:43 <kmc> > read "(\"r\", 3, 3)" :: (String, Int, Int)
13:01:44 <lambdabot>   ("r",3,3)
13:01:45 <ksf> roconnor, give a man a fish, and he isn't hungry for a day. teach a man to fish, and he will never be hungry again.
13:01:48 <alexander> koeien37: i found my monomorphism-nastyness
13:01:51 <Zao> kmc: Fancy.
13:01:53 * BMeph thinks that using Floats as keys in a Map is "DOIN IT RONG"
13:02:04 * Zao inserts some NaNs in BMeph's map.
13:02:05 <djwonk> ksf: this is helping al ot
13:02:11 <ksf> roconnor, in other words, you're breeding copy+paste programmers
13:02:12 <Berengal> ksf: Light a man a fire and he's warm for a day. Light a man on fire, and he's warm for the rest of his life.
13:02:30 <Polarina> I have this sweet little function over here (http://codepad.org/pa8RaJog), but ghci refuses to run it. "No instance for (Show (IO Integer))"
13:02:30 <alexander> i do a lot of number crunching in this module, so i had globally bound 'fi = fromIntegral', but it was without a type signature :/
13:02:38 <Polarina> What's wrong with it?
13:02:44 <BMeph> Berengal: Surely, "Give a man a match, ..." right? ;)
13:02:51 <koeien37> alexander: yep. that could be it.
13:02:56 <kmc> Polarina, well... there's no instance of Show for the type IO Integer
13:03:12 <Berengal> BMeph: no, it's "light a man on fire"
13:03:20 <Polarina> kmc: How do I fix it?
13:03:22 * BMeph thinks Zao just proved his point
13:03:23 <kmc> probably it's trying to print out the result
13:03:27 <Zao> @type sequence
13:03:28 <kmc> Polarina, what do you want to do?
13:03:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:03:37 <Polarina> kmc: Print out the random list.
13:03:39 <kmc> probably what you want is an IO action that produces a list, *not* a list of IO actions
13:03:40 <sproingie> Polarina: do { x <- randlist 10; putStrLn $ show x }
13:03:50 <kmc> "sequence" will do that
13:03:56 <kmc> sequence :: [IO a] -> IO [a]  (in this case)
13:04:06 <BMeph> Berengal: "Give a man a match, and he's warm for a day. Light a man on fire, and he's warm for the rest of his life."
13:04:07 <Polarina> kmc: ?
13:04:08 <Zao> Polarina: You have an [IO Integer], while you want an IO [Integer].
13:04:09 <sproingie> oh guess that won't work if it's [IO a]
13:04:09 <copumpkin> :t Data.Traversable.sequence
13:04:10 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
13:04:19 <Polarina> Zao: Erm... how, and why?
13:04:31 <Zao> [IO Integer] is a list of IO actions. IO [Integer] is an IO action returning a list of Integer.
13:04:34 <Berengal> BMeph: Perhaps. It's a while since I read the book
13:04:37 <djwonk> ksf: I see how to parse "(\"s\", 3, 3)". but if I want it to parse "s 3 3" ?
13:04:40 <junmin> kmc: thanks for the suggestion about the (!!), usefull
13:04:47 <Zao> sequence runs each IO action in order, returning the outputs.
13:04:53 <kmc> you can't "show" an [IO Integer] *nor* an IO [Integer].  but since ghci's prompt lives inside an IO monad do-block, it can bind *then* show the latter
13:04:56 <ksf> > words "s 3 3"
13:04:56 <dolio> It's useful to know how to implement data structures, but why bother doing it over and over until you can rattle off definitions of arbitrary functions whenever someone in a chat room asks you for them?
13:04:57 <lambdabot>   ["s","3","3"]
13:05:10 <copumpkin> @hoogle nmergeIO
13:05:10 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
13:05:13 <Polarina> kmc: I don't get it.
13:05:14 <alexander> why isn't there an "export Lol hiding (lawlz, my, ballz) where ..."?
13:05:15 <ksf> ...you can then read :: String on the head and read :: Int on the rest
13:05:18 <kmc> Polarina, you have five recipes for cakes. you want a recipe for five cakes.
13:05:28 <kmc> ghci can only bake a recipe, not a list-of-recipes
13:05:38 <copumpkin> ooh
13:05:42 <dolio> Nobody needs to be able to bang them out over and over like that, unless they're writing C, or something else with deficient parametric abstraction.
13:05:42 <Polarina> kmc: Ok.
13:05:43 <copumpkin> kmc: damn you, now I'm hungry
13:05:51 <kmc> :D
13:05:52 <djwonk> ksf: ok, so words and read will do. if i want more powerful, scanf like parsing, what should i look at?
13:05:59 <kmc> @faq will Haskell make me a delicious cake?
13:05:59 <lambdabot> The answer is: Yes! Haskell can do that.
13:06:02 <Zao> copumpkin: My SoA teacher kept making pizza parlor analogies for a whole 4h lecture.
13:06:16 <kmc> djwonk, scanf is terrible ;P
13:06:21 <Berengal> djwonk: parsec, or some other parser combinator library
13:06:21 <kmc> djwonk, look at Parsec for powerful parsing
13:06:22 <Polarina> kmc: Well, how do I change it to IO [Integer]?
13:06:24 <medfly> lol
13:06:25 <gwern> djwonk: scanf? well, if you need more than adhoc pattern-matching stuff, people usually go with parsec or something
13:06:25 <ksf> djwonk, this one: http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
13:06:28 * copumpkin is now reminded of Lazy Town vs. Lil Jon
13:06:36 <kmc> Polarina, "sequence"
13:06:36 <kmc> as several people have already said
13:06:37 <ksf> ...we also have good ole evil regexen.
13:06:38 <kmc> sequence :: [IO a] -> IO [a]  (in this case)
13:06:54 <Polarina> Sequence what?
13:06:58 <Zao> Would a Text.Scanf module be possible to implement?
13:07:01 <ksf> @src sequence
13:07:01 <lambdabot> sequence []     = return []
13:07:01 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:07:01 <lambdabot> --OR
13:07:01 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:07:02 <kmc> a value of type [IO a]
13:07:04 <Berengal> regexes can only extracts strings from strings...
13:07:11 <kmc> in this case, a value of type [IO Integer]
13:07:15 <copumpkin> Zao: possibly, with uglier syntax if you wanted type safety
13:07:17 <Zao> Polarina: It's a function.
13:07:25 <Polarina> Why would I want a IO [Integer]?
13:07:40 <kmc> because GHCi can bind it, then print the result of the IO recipe
13:07:53 <djwonk> Berengal: I looked at Parsec. The examples seem very complicated for something simple such as (made up example) scanf "s 3 3" "%s %i %i"
13:07:58 <Polarina> kmc: Why can't GHC work with [IO Integer] too?
13:08:04 <kmc> GHCi knows how to "print" two things: instances of Show, and IO actions resulting in instances of show
13:08:10 <kmc> [IO Integer] is not either
13:08:11 <ksf> scanf should be quite doable and clean with type families, just like printf...
13:08:14 <Polarina> kmc: Oh.
13:08:29 <BMeph> copumpkin: For some reason, it isn't as funny now that she's 18... ;)
13:08:34 <kmc> Polarina, do you understand conceptually the difference between [IO Integer] and IO [Integer]?
13:08:35 <ksf> but I guess everyone is just used way too much to parsers and maybe string-template
13:08:40 <Polarina> kmc: Yes.
13:08:42 <patch-tag> is there any nice module for parsing output of top or ps, or the like?
13:08:53 <Polarina> kmc: Yet,  sequence . randlist 5  doesn't work. :(
13:08:57 <patch-tag> or generally seeing what's running on your system?
13:08:58 <copumpkin> patch-tag: don't think so
13:09:11 <kmc> "randlist 5" is not a function
13:09:14 <BMeph> copumpkin: Well, It isn't as funny /to me/, anyway. :)
13:09:24 <copumpkin> BMeph: perv!
13:09:26 <kmc> patch-tag, i'd go fishing in /proc instead
13:09:29 <sproingie> @hoogle [m a] -> m [a]
13:09:29 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:09:30 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:09:30 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
13:09:30 <kmc> (on Linux)
13:09:31 <ksf> sequence . randlist $ 5
13:09:40 <copumpkin> that's rather OS-specific :)
13:09:41 <ksf> (sequence . randlist) 5
13:09:46 <ksf> sequence $ randlist 5
13:09:50 <ksf> all three work
13:09:53 <BMeph> copumpkin: You say that as if it's a bad thing... ;)
13:09:59 <sproingie> @hoogle m [a] -> [m a]
13:10:00 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
13:10:00 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
13:10:00 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
13:10:08 <ksf> sequence (randlist 5)
13:10:10 <ksf> that one, too.
13:10:12 <copumpkin> well as a Mac user, I'm fine with excluding windows users, but /proc excludes even me!
13:10:27 <kmc> iirc some BSDs have /proc
13:10:31 <Polarina> Ok.
13:10:33 <kmc> maybe not in the same format
13:10:44 <ksf> @src (.)
13:10:45 <lambdabot> (f . g) x = f (g x)
13:10:50 <ksf> @src ($)
13:10:50 <lambdabot> f $ x = f x
13:11:00 <djwonk> how compact could a "%s %i %i" type parser be in Parsec?
13:11:05 <smiler> Most BSDs have /proc, but not all have them mounted
13:11:22 <djwonk> hoogle didn't find an scanf matches for me
13:11:25 <kmc> djwonk, probably one line if you write it with Applicative
13:11:26 <Zao> FreeBSD even has linprocfs, for those silly Linux apps.
13:11:28 <BMeph> patch-tag: Do you mean 'grep'? :)
13:11:49 <ksf> foo <- many1 anyChar; bar <- many1 digit...
13:11:54 <patch-tag> bmeph: ha ha
13:12:22 <ksf> a couple more keypresses, but not more work, as such.
13:13:51 <ksf> djwonk, if you want to get deep into parsing, I really recommend reading http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf , which could be called "write yourself an industrial-strength parsing library in 12 hours"
13:13:57 <patch-tag> kmc: thanks for the tip to go fishing around in proc though. that and man proc are mighty interesting.
13:14:12 <kmc> industrial strength
13:14:14 <kmc> !
13:14:21 <djwonk> ksf: thanks for the suggestion. i'm actually struggling just to do the very basics
13:14:37 <ksf> ...if you're just starting to learn haskell, I wouldn't recommend starting off with such things, though.
13:14:47 <Polarina> Why doesn't  putStrLn . show . randlist $ 5  work?
13:14:52 <BMeph> djwonk: You might also just want to look at 'reads' instead. :)
13:15:18 <ksf> djwonk, do you know about http://book.realworldhaskell.org/read/ ?
13:15:27 <patch-tag> Polarina: look at the types of each function in the pipeline
13:15:32 <sproingie> Polarina: because there's no show instance for what randlist returns
13:15:42 <djwonk> ksf: yes
13:15:43 <Polarina> sproingie: Erm, it returns IO [Integer].
13:15:49 <kmc> > let f = (\[s,x,y] -> (s, read x, read y)) . words in f "foo 3 5"
13:15:50 <BMeph> Polarina: Because ghci does what you tell it to do, not what you think you wish it would figure out what you meant to tell it to do. ;)
13:15:51 <lambdabot>   ("foo",* Exception: Prelude.read: no parse
13:15:58 <sproingie> right, there's generally no show instances for IO anything
13:16:03 <patch-tag> polarina: putStrLn . show =<< randlist 5
13:16:04 <Polarina> BMeph: Yes, how do I fix this?
13:16:05 <kmc> > let f :: String -> (String, Int, Int); f = (\[s,x,y] -> (s, read x, read y)) . words in f "foo 3 5"
13:16:06 <lambdabot>   ("foo",3,5)
13:16:07 <patch-tag> you probably want that'
13:16:10 <Polarina> patch-tag: What's =<<?
13:16:17 <patch-tag> left bind
13:16:29 <djwonk> kmc: right, i see that example
13:16:30 <sproingie> show returns a string, which is a pure value
13:16:30 <kmc> @src (=<<)
13:16:30 <lambdabot> f =<< x = x >>= f
13:16:34 <sproingie> you can't get a pure value from IO
13:16:36 <ksf> (=<<) = flip (>>=)
13:16:36 <patch-tag> it's the same as xs <- randlist 5; putStrLn . show $ xs
13:16:42 <kmc> woah palindromic definition
13:16:45 * kmc stares
13:16:45 <sproingie> except while you're in the IO monad
13:16:47 <Polarina> ?
13:16:50 <kmc> how many of those do we have
13:16:56 <kmc> Polarina, you can't "print" an IO recipe
13:17:01 <Polarina> kmc: Ok.
13:17:11 <BMeph> Polarina: First, you'll have to figure out what you actually want, instead of hoping that the machine will understand what you really want and do that instead. ;)
13:17:14 <Polarina> kmc: But I know neither =<< nor >>=
13:17:14 <djwonk> BMeph: i haven't been able to figure out how to use reads though.
13:17:17 <kmc> you can only run the recipe and print the result
13:17:19 <patch-tag> sorry, should have had a do statement in my last comment
13:17:29 <kmc> Polarina, (>>=) is a basic monad combinator
13:17:30 <patch-tag> do xs <- randlist 5; putStrLn . show $ xs
13:17:36 <kmc> Polarina, you should learn how monads work
13:17:39 <kmc> in a context other than IO
13:17:42 <BMeph> djwonk: What don't you indestand about it? :)
13:17:43 <patch-tag> this desugars to the first thing I wrote
13:17:44 <kmc> because IO is a terrible, abnormal, complicated monad
13:17:57 <Polarina> kmc: No books wanted to explain it to me better when I asked them "I am not following you".
13:18:05 <djwonk> BMeph: i was looking for a few examples online, can't find them
13:18:09 <patch-tag> with the do notation, it's easier to read if you "not in monad mood" or a newbie
13:18:24 <ksf> :t reads
13:18:25 <patch-tag> but after you get used to haskell the thing with =<< is easier, maybe
13:18:25 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:18:32 <BMeph> > reads "s 3 3"::(Char,String)
13:18:32 <lambdabot>   Couldn't match expected type `(GHC.Types.Char, GHC.Base.String)'
13:18:33 <lambdabot>         ag...
13:18:43 <patch-tag> because it's shows the "pipeline" of what turns into what turns into what...
13:18:52 <kmc> Polarina, well, where did you get stuck?
13:18:52 <ksf> BMeph, he doesn't want to parse parens and a comma.
13:19:01 <ksf> ...but whitespace-separated stuff.
13:19:01 <dolio> @type let readST = StateT reads in runStateT $ (,,) <$> readST <*> readST <*> readST
13:19:02 <Polarina> kmc: The whole concept of >>=
13:19:02 <lambdabot>     No instance for (Applicative (StateT String []))
13:19:03 <lambdabot>       arising from a use of `<*>' at <interactive>:1:41-66
13:19:03 <lambdabot>     Possible fix:
13:19:08 <kmc> try working with the Maybe monad, both in terms of "do" notation and in terms of (>>=)
13:19:19 <Polarina> kmc: Maybe monad?
13:19:22 <patch-tag> =<< lets you suck the monadic output of an action into the next monadic action
13:19:26 <dolio> @type let readST = StateT reads in runStateT $ (,,) `liftM` readST `ap` readST `ap` readST
13:19:26 <ksf> :t (>>=)
13:19:26 <BMeph> ksf: Where are the parens and comma in "s 3 3"? :)
13:19:27 <lambdabot> forall a1 a a11. (Read a1, Read a, Read a11) => String -> [((a1, a, a11), String)]
13:19:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:19:29 <Polarina> patch-tag: ?
13:19:32 <patch-tag> putStrLn . show =<< randlist 5
13:19:37 <kmc> Polarina, there's a type constructor called Maybe
13:19:38 <patch-tag> this is two monadic actions
13:19:40 <kmc> :t Just 3
13:19:41 <lambdabot> forall t. (Num t) => Maybe t
13:19:42 <kmc> :t Nothing
13:19:43 <lambdabot> forall a. Maybe a
13:19:43 <Polarina> kmc: I know of it.
13:19:46 <patch-tag> read it from right to left
13:19:47 <kmc> Polarina, it's a monad
13:19:48 <ksf> BMeph, that's what the read instance for (,) is expecting.
13:19:57 <Polarina> kmc: Maybe isn't a monad.
13:20:03 <patch-tag> (by the way, I hope that compiles, haven't actually tried it :) )
13:20:05 <kmc> sure is
13:20:09 <kmc> @instances Monad
13:20:10 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:20:11 <mmorrow> preflex: seen int-e
13:20:12 <preflex>  int-e was last seen on #haskell 2 days, 2 hours, 33 minutes and 2 seconds ago, saying: copumpkin: Ah. Right, sorry, I got distracted. Good job, I'm just afraid we can't really afford qualified people here.
13:20:16 <alexander> i have a GC question;
13:20:16 <Polarina> kmc: ...?
13:20:18 <ivanm> preflex: seen roconnor
13:20:19 <preflex>  roconnor was last seen on #haskell 19 minutes and 15 seconds ago, saying: ksf: I'm still pretty sure that fromAsc is the right answer.
13:20:23 <kmc> Polarina, "?" is not very helpful
13:20:26 <alexander> if i create a massive datastructure in a where-clause
13:20:27 <kmc> Polarina, why do you think Maybe is not a monad
13:20:27 <patch-tag> also, this is the same as randlist 5 =>> putStrLn . show
13:20:29 <Polarina> kmc: I don't get it.
13:20:36 <Polarina> kmc: Because it's not an IO.
13:20:37 <kmc> Polarina, "Monad" is a typeclass
13:20:39 <kmc> ugh
13:20:41 <ksf> monads are like burritos.
13:20:42 <patch-tag> the =<< just lets you flip the order
13:20:43 <alexander> will that creation be remembered next time the function is run?
13:20:52 <djwonk> BMeph: at some point i will explore Parsec. but I was hoping that there was a simpler way to do it, something along the power/complexity of scanf but more elegant than mixing words and read together
13:20:52 <kmc> monads are not about IO
13:20:56 <ksf> kmc is trying to share them, but is too hungry, so you don't get any.
13:20:57 <Polarina> kmc: What then?
13:20:57 <alexander> (this massive thing takes no input, so it would be constant)
13:20:58 <kmc> IO is a particular monad
13:21:25 <patch-tag> sorry, I eant randlist 5 >>= putStrLn . show
13:21:26 <kmc> Polarina, they're a way to structure computation
13:21:42 <Polarina> kmc: What do you mean with structuring computations?
13:21:45 <patch-tag> or sequence computation
13:21:45 <kmc> where "computation" could mean IO, parsers, concurrency, nondeterminism, error handling, continuations, state, ...
13:21:59 <roconnor> ksf: down to what level of abstraction should katas be practiced?
13:22:00 <Polarina> kmc: Erm... ok.
13:22:03 <roconnor> ivanm: hi
13:22:05 <patch-tag> you run a computation, it produces a result. you feed that result into the next computation
13:22:13 <kmc> Polarina, did you try to read about monads in general?
13:22:16 <Polarina> patch-tag: Ah.
13:22:17 <kmc> not just "how do I do IO"?
13:22:20 <Polarina> kmc: I have.
13:22:25 <kmc> because i think the IO monad is a particularly bad introduction to monads
13:22:26 <patch-tag> so, getLine produces a result of type IO String
13:22:29 <sproingie> IO is a tricky monad to work with
13:22:34 <kmc> as evidenced by the fact that you're conflating the two
13:22:37 <ksf> djwonk, well, parsec can parse context-sensitive grammars. if you restrict yourself to the applicative functor interface, it parses only context-free grammars, which might be easier.
13:22:38 <sproingie> since there's never a way to get things out of it
13:22:38 <kmc> (IO monad and monads in general)
13:22:41 <patch-tag> you feed could feed this into putStrLn
13:22:44 <patch-tag> and it would print a string
13:22:47 <sproingie> plus there's just SO much that runs in the IO monad
13:22:48 <ksf> ...incidentally, that's what the paper I linked starts off with
13:22:52 <patch-tag> getLine >>= putStrLn
13:22:58 <patch-tag> this reads a line from you, and then prints it out
13:23:13 <patch-tag> it's the same as do result <- getLine; putStrLn result
13:23:19 <Polarina> patch-tag: putStrLn =<< getLine ?
13:23:26 <Cale> sproingie: There is a way though.
13:23:29 <patch-tag> yup that would also work
13:23:31 <ivanm> roconnor: trying to use that trick on the wikipage and then toSRGB24, it doesn't seem to convert the RGB values properly :s
13:23:32 <Polarina> :D
13:23:42 <ksf> roconnor, something hard enough to be a practice, but easy enough not to take too long or throw you into despair.
13:23:42 <kmc> Polarina, http://www.haskell.org/all_about_monads/html/index.html
13:23:48 <Polarina> kmc: Thanks.
13:23:52 <roconnor> ivanm: Intersting.  I'd like more details
13:24:00 <Cale> sproingie: You only do input and output in the IO monad, and you refactor everything you can as pure functions from input to output
13:24:12 <ksf> it doesn't matter which level of abstraction it's at, but you need to actually code stuff, not just type "fromAscList" over and over again.
13:24:16 <djwonk> i guess i'm trying to say "the examples for read, reads, Parsec" are just not easily digestible
13:24:36 <djwonk> if Parsec can be so simple, why don't examples online demonstrate that?
13:25:03 <djwonk> RWH jumps right into JSON parsing, CSV parsing
13:25:17 <roconnor> ksf: ok
13:25:18 <kmc> anyone know why search is broken on the Haskell wiki?
13:25:18 <djwonk> frustrating
13:25:44 <ivanm> roconnor: "toSRGB24 . pureColour . opaque $ sRGB24 139 35 82" returns an RGB of "3 0 1"
13:25:49 <kmc> in particular i'm failing searching for the page "what monads are not"
13:26:15 <roconnor> ivanm: what is the source of pureColour?
13:26:17 <davidL> http://haskell.org/haskellwiki/What_a_Monad_is_not
13:26:36 <ksf> oh pl transformations could be good katas.
13:26:37 <roconnor> ivanm: oh from the wiki page
13:26:41 <maltem> djwonk, what's wrong with the parsec manual? (Is that one up to date for parsec 3, btw?)
13:26:48 <ksf> not random ones, though.
13:26:56 <Cale> Someone should refactor the nonstandard terminology out of that article
13:27:01 <roconnor> ivanm: heh, maybe I should have tested the wiki code
13:27:13 <ivanm> roconnor: hmmm, my wrapper function seems to be doing something wrong
13:27:44 <roconnor> ivanm: your wrapper function?
13:27:44 <kmc> Polarina, http://haskell.org/haskellwiki/What_a_Monad_is_not
13:27:47 <djwonk> maltem: ok, i just found: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html - looks like it has potential
13:27:53 <Polarina> kmc: Thanks. :)
13:27:59 <ivanm> roconnor: I'm returning the RGBA quad-ruple
13:28:05 <sproingie> i'm still trying to figure out how to handle lots of data structures with state and randomly-derived pieces
13:28:14 <ivanm> using uncurryRGB (,,,) to do so
13:28:30 <djwonk> i am used to the ruby world, where you can do `ri reduce` and get documentation and examples, it is something that I haven't seen in the haskell word. just a compact introduction
13:28:50 <sproingie> i can derive a big monad transformer stack and call it Game and make everything in the game be Game Item, Game Monster, Game Room, etc
13:28:52 <djwonk> i love hoogle and I love :t. but finding short examples is still hard for me
13:29:04 <dbpatterson> does anyone know of a purely haskell cipher for text (ie, strings or bytestrings)? or, how to turn a string or bytestring into a Word128 (What the haskell Crypto package deals with) - I know how to do it in theory (just a change in bases) but don't want to write a slow fragile version it if it exists
13:29:04 <sproingie> but that somehow doesn't really satisfy me
13:29:43 <kmc> sproingie, newtype your stack, then define domain-specific monad "primitives" and use those in the rest of the program
13:29:43 <ivanm> roconnor: so it works when doing it in ghci myself; doesn't work when I use my function :s
13:29:47 <maltem> djwonk, yeah that's the one I had in mind.
13:29:53 <roconnor> ivanm: strange
13:29:54 <sproingie> djwonk: i was just lamenting at the lack of examples in the standard libraries myself
13:30:08 <ivanm> roconnor: I've got to head off; I'll play with it when I get back and let you know
13:30:13 <djwonk> sproingie: great, so I'm not crazy for wanting them! :)
13:30:45 <chrisdone> what's the emacs shortcut to make a region bird indented in .lhs mode?
13:30:47 <sproingie> kmc: yah i was definitely going to do a newtype, i just wasn't sure if i was thinking about it the right way
13:30:55 <roconnor> Data.Colour.SRGB Data.Colour> toSRGB24 . pureColour . opaque $ sRGB24 139 35 82
13:30:57 <roconnor> RGB {channelRed = 139, channelGreen = 35, channelBlue = 82}
13:31:01 <roconnor> ivanm: okay
13:31:07 <kmc> sproingie, you can also define your own monad
13:31:13 <maltem> If you're whishing for better documentation of Haskell packages, you've never had to work with OpenFoam
13:31:13 <kmc> tbh i find the transformers a bit cumbersome
13:31:21 <djwonk> maltem: this is the best parsec intro i've seen, thanks a lot
13:31:26 <sproingie> well either way it's a monad
13:31:40 <Cale> You can also just define your game state as something which is not a monad, and then various functions for transforming it.
13:31:50 <sproingie> and more or less a monad stack, either manually integrated or using transformers
13:31:57 <Cale> (Why ought it to be a monad?)
13:32:23 <sproingie> Cale: yah but i derive a lot of the attributes randomly, so they're going to be tainted that way
13:32:39 <sproingie> plus i'm not a fan of the glacial System.Random, so they may even be IO
13:32:44 <kmc> so the RNG is another value you have to pass around and transform
13:32:44 <Cale> randomly?
13:32:52 <Cale> Oh, yeah.
13:32:59 <sproingie> Cale: basically it's a roguelike
13:33:12 <kmc> sproingie, there's a pure interface to mersenne twister
13:33:13 <sproingie> more like a "sim roguelike" ala dwarf fortress, but that's a minor distinction
13:33:35 <Cale> sproingie: Have you read my bit about how to do OO in Haskell?
13:33:46 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
13:33:59 <sproingie> kmc: i'm kinda liking how Bryan O'Sullivan's statistics package looks
13:34:16 <sproingie> tho mersenne would probably be fine too
13:34:32 <pastah_rhymez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12894#a12894 <-- could someone take a quick peek at this
13:34:59 <pastah_rhymez> , please :)
13:35:01 <lunabot>  luna: parse error on input `)'
13:35:24 <dbpatterson> Or even, what is the best way to turn a list (obviously finite capped length) of Word8's to a Word128?
13:35:29 <Cale> pastah_rhymez: It'll be constructed every time it comes into scope.
13:35:55 <Cale> pastah_rhymez: If you want it to be shared, you have to move it up out of the 'where'
13:36:59 <ksf> Cale, I bet you have something valueable to add to http://haskell.org/haskellwiki/What_a_Monad_is_not
13:37:06 <pastah_rhymez> Cale: i don't want it to be shared, but there's no notation for "module Lol hiding (stuff, im, not, proud, of) where ..."
13:38:07 <Cale> ksf: Other than the fact that I don't like the term 'mobits'?
13:38:14 <ksf> pastah_rhymez, you can either do where clauses instead of top-level definitions, or make another module with the same name but .Internal added
13:38:18 <ksf> Cale, yes.
13:38:25 <Cale> I'm not sure I like saying that 'monads are not values' like that.
13:38:31 <sproingie> 'do' kind of does make monads a language feature
13:38:40 <ksf> stuff'd get confusing if it'd say "monads are not values but there are monadic values"
13:38:51 <Jedai> pastah_rhymez: I don't really get what you say, you don't have to export everything on the top level of a module you know ?
13:38:59 <pastah_rhymez> ksf: so THAT'S what internal are :)
13:39:09 <Cale> But monads *are* values. They're triples consisting of a type constructor, and implementations of return and join. ;)
13:39:10 <chrisdone> bloody erc-truncate-buffer just crashed my emacs
13:39:28 <tensorpudding> boo
13:39:31 <sproingie> yes but that triple is represented using a type
13:39:41 <tensorpudding> maybe use a different irc
13:39:43 <ksf> ...a type class.
13:39:47 <Berengal> sproingie: type class
13:39:48 <ksf> and I'm saying that.
13:40:07 <kmc> ksf, not very confusing.  "blue" is not a shirt but there are blue shirts
13:40:09 <kmc> it's just another adjective
13:40:13 <Cale> Yeah, the thing you want to be careful about is that M is not the same thing as M t
13:40:14 <sproingie> i daresay "monad" is used ambiguously, it may refer to a type or a value depending on how it's used
13:40:27 <Berengal> And a type class is just an implicit record type managed by the compiler, where type class instances are values of that type
13:40:28 <kmc> using it to refer to a value is just wrong
13:40:36 <Cale> and when you say 'monad' you're referring to the M, not to the M t
13:40:38 <toast-opt> ksf (thx for that link, the burritos article is very helpful)
13:40:48 <kmc> Cale, and not either to a value of *type* M t
13:40:49 <Jedai> pastah_rhymez: Or do you mean that you would prefer to specify what not to export instead of what to export ?
13:40:51 <kmc> which is a third thing
13:40:52 <Cale> right
13:41:04 <Cale> It's a bit like the mistake where people say "the function f(x)"
13:41:28 <kmc> Cale, but that's common abuse of notation in maths
13:41:39 <Cale> Maybe if you're a physicist :)
13:41:40 <kmc> regrettably
13:41:44 <monochrom> like I said last night, "the function f(x)" my ass.
13:41:50 <Cale> Not if you're a mathematician
13:42:05 <kmc> in dysfunctional languages, people will write "f()" to indicate that f is a function rather than a value.
13:42:10 <BMeph> Should we make a bigger deal of the fact that IO is not I/O, although I/O is handled in the IO Monad?
13:42:18 <Berengal> Who's to say the function f(x) isn't different from the function f(y) ?
13:42:35 <kmc> Berengal, they are sometimes, in more abuse of notation
13:42:41 <yitz> preflex: seen quicksilver
13:42:42 <preflex>  quicksilver was last seen on #haskell 1 day, 4 hours, 46 minutes and 1 second ago, saying: "Complex is a member of Floating but not RealFloat" I should have said.
13:42:50 <Cale> Well, f(x) *might* be a function
13:42:55 <ksf> BMeph, just do it, it's a braindump in its current state
13:43:08 <toast-opt> if f :: a -> b -> c, then f (x) may be a differnet function from f (y) right?
13:43:10 <Cale> But f would have to have its codomain be a set of functions for that to be true.
13:43:27 <toast-opt> for some z, f (x) z /= f (y) z
13:43:37 <Cale> toast-opt: yeah
13:44:23 <yitz> @ask quicksilver does this look familiar? http://www.haskell.org/pipermail/libraries/2009-November/012812.html if so, please comment on the list.
13:44:23 <lambdabot> Consider it noted.
13:44:25 <toast-opt> sry, i come from the c++ side, new to haskell.  it's really hard to work with functions in c++
13:44:34 <Philonous1> If for x=y there still is a z so that f x z /= f y z, stuff gets funny
13:44:50 <BMeph> sproingie: "sproingie	i daresay "monad" is used ambiguously, it may refer to a type or a value depending on how it's used" -- how is this different from how "String" or "Int" are used? :)
13:45:05 <kmc> Philonous1, it's quite possible for the sense where by (x=y) you mean (x == y)
13:45:12 <endojelly> Philonous1, or impossible, at least if = is intensional equality
13:45:22 <endojelly> and if the function is pure
13:45:24 <ksf> BMeph, the difference between M and M a is the problem.
13:45:29 <sproingie> BMeph: it's a lot how String and Int are used.  i say "foo" is a string.
13:45:37 <sproingie> it's actually a value of type String
13:45:37 <kmc> toast-opt, yes.  so hard that they stole a word from math ("functor") and entirely changed the meaning, to make C++'s treatment of functions sound like a feature instead of a bug
13:45:58 <ksf> ...M is a monad, and M a is a mobit.
13:46:03 <Cale> pff
13:46:21 <sproingie> though Monad is actually a type *class*, so it's the type that's a monad
13:46:33 <monochrom> "M a monad" cannot go wrong. :)
13:46:34 <Polarina> foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || ((foo `div` bar) `div` pro) `div` duct?
13:46:35 <toast-opt> kmc - i've started to use tuple<> in C++ to avoid the 'void is not a value' thing :D
13:46:35 <Cale> The type constructor
13:46:41 <dbpatterson> does really noone know anything about crypto on haskell?
13:46:57 <Cale> dbpatterson: hm?
13:47:08 <dbpatterson> I'm trying to use the Crypto library
13:47:15 <dbpatterson> most of the functions take in Word128's
13:47:21 <sproingie> i agree it it's good for people to not confuse it, tho stuff like State makes it hard when both the type and constructor have the same name
13:47:25 <dbpatterson> there doesnt seem to be an easy way to convert to them
13:47:36 <dbpatterson> (lots of converstions to and from [Octet] = [Word8])
13:47:37 <yitz> dbpatterson: fromIntegral
13:47:47 <Baughn> dbpatterson: For practical programs, you'll want HsOpenSSL instead
13:48:00 <dbpatterson> Baughn: segfaults on me... kind of why I stopped using C.
13:48:06 <IMACHARGINMAHLAZ> hmm
13:48:13 <Baughn> dbpatterson: Er, did you remember to call withOpenSSL first?
13:48:14 <Cale> dbpatterson: You select a packing function
13:48:22 <Cale> dbpatterson: pkcs5, for instance
13:48:28 <chrisdone> anyone had success mixing org-mode with literate-haskell-mode?
13:48:28 <Cale> pkcs5 :: (Integral a, Bits a) => [Octet] -> [a]
13:48:33 <ksf> @check \foo bar pro duct -> foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || ((foo `div` bar) `div` pro) `div` duct
13:48:33 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
13:48:34 <lambdabot>    arising from a use of ...
13:48:38 <johnw> chrisdone: have you looked at org-babel?
13:48:39 <Polarina> foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || ((foo `div` bar) `div` pro) `div` duct  ***???**
13:48:42 <ksf> Polarina, no.
13:48:47 <chrisdone> johnw: no, I will now
13:48:54 <Cale> dbpatterson: You'll find it in Codec.Encryption.Padding
13:48:57 <Polarina> ksf: No, I am asking if it's left-associative or right-associative.
13:49:04 <ksf> @check \foo bar pro duct -> foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || ((foo `div` bar) `div` pro) `div` duct
13:49:05 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
13:49:05 <lambdabot>    arising from a use of ...
13:49:13 <dbpatterson> Cale: and then from that to Word128? is fromIntegral?
13:49:30 <Cale> dbpatterson: Word128 is both an instance of Integral and Bits
13:49:45 <Cale> dbpatterson: So pkcs5 :: [Octet] -> [Word128]
13:49:47 <yitz> @check \foo bar pro duct -> foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || foo `div` bar `div` pro `div` duct == ((foo `div` bar) `div` pro) `div` duct
13:49:47 <Polarina> ksf: Do you know?
13:49:48 <chrisdone> johnw: what does it do? I want to have org-mode collapsing facilities on literate-haskell-mode
13:49:48 <lambdabot>   "* Exception: divide by zero
13:49:56 <Cale> (as a special case of what it does)
13:49:59 <ksf> I think `` is infixl 9 by default
13:50:04 <ksf> but don't take my word on it.
13:50:04 <Saizan_> Polarina: infixl 7 div
13:50:06 <chrisdone> johnw: (this doesn't look like it does that)
13:50:11 <Polarina> Saizan_: ?
13:50:13 <Saizan_> Polarina: so it's left associative
13:50:15 <Cale> (Octet is just another name for Word8)
13:50:22 <johnw> chrisdone: well, org-babel supports its own flavor of "tangle" for writing literate Haskell programs; I'm not sure exactly what the kind of integration you're seeking would look like in practice
13:50:25 <Saizan_> Polarina: you can get that information from :info div in ghci
13:50:41 <yitz> @check \foo bar pro duct -> 0 `elem` [bar,pro,duct] || foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || foo `div` bar `div` pro `div` duct == ((foo `div` bar) `div` pro) `div` duct
13:50:42 <lambdabot>   "* Exception: divide by zero
13:50:53 <Cale> dbpatterson: Does that help you out? :)
13:51:04 <Polarina> Saizan_: :info doesn't tell me.
13:51:14 <chrisdone> johnw: ah, I see
13:51:22 <dbpatterson> Cale: yes, that does.. it's funny how I couldn't seem to find a single explanation of that path... or a single example of someone actually using the libraries :)
13:51:36 <yitz> @check \foo bar pro duct -> (0 `elem` [bar,pro,duct]) || foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || foo `div` bar `div` pro `div` duct == ((foo `div` bar) `div` pro) `div` duct
13:51:37 <lambdabot>   "* Exception: divide by zero
13:51:52 <Saizan_> Polarina: really? i get this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12895#a12895
13:52:10 <Polarina> Is {foo `div` bar `div` pro `div` duct} equivalent to {foo `div` (bar `div` (pro `div`duct))} or {((foo `div` bar) `div` pro) `div` duct}?
13:52:27 <Polarina> Saizan_: Yes, it doesn't tell.
13:52:39 <Saizan_> it's the latter
13:52:45 <Polarina> Saizan_: Thanks.
13:52:49 <Saizan_> it's left associative, as i said before
13:52:53 <Polarina> :)
13:53:10 <Cale> dbpatterson: You use the functions cbc and unCbc with the resulting streams of blocks
13:53:10 <rntz> (div minBound (-1) :: Data.Int.Int32) results in an arithmetic overflow. Is there any way, without diving into the IO monad to use Exception handling, that I could catch this error - say, some function safeDiv :: Integral n => n -> n -> Maybe n?
13:53:15 <byorgey> Polarina: you can find out by typing  :info div  at a ghci prompt
13:53:26 <Polarina> byorgey: And where does it tell me?
13:53:38 <Cale> dbpatterson: passing in the encrypt or decrypt function for whatever sort of encryption you're doing.
13:53:43 <byorgey> Polarina: it will tell you  'infixl 7 div', which means that expression will group to the left
13:53:50 <yitz> @check \foo bar' pro' duct' -> let [bar, pro, duct] = map ((+1).abs)  [bar',pro',duct'] in foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || foo `div` bar `div` pro `div` duct == ((foo `div` bar) `div` pro) `div` duct
13:53:51 <lambdabot>   "* Exception: divide by zero
13:53:57 <byorgey> 'infixr' would mean it associates to the right instead
13:54:11 <Polarina> byorgey: Ok, thanks.
13:54:24 <Cale> dbpatterson: (Which is in Codec.Encryption.Modes, and does cipher block chaining.)
13:54:33 <yitz> @check \foo' bar' pro' duct' -> let [foo, bar, pro, duct] = map ((+1).abs)  [foo', bar',pro',duct'] in foo `div` bar `div` pro `div` duct == foo `div` (bar `div` (pro `div`duct)) || foo `div` bar `div` pro `div` duct == ((foo `div` bar) `div` pro) `div` duct
13:54:34 <lambdabot>   "* Exception: divide by zero
13:55:03 <Cale> dbpatterson: I wrote an example for someone a while back, but I think I discarded it after.
13:55:40 <Polarina> byorgey: What about functions that have neither infixl nor infixr?
13:56:03 <byorgey> Polarina: hm, I forget what the default is in that case
13:56:13 <monochrom> then when you write "x `f` y `f` z" the compiler will complain.
13:56:18 <yitz> > minBound `div` (-1) :: Int
13:56:19 <lambdabot>   * Exception: arithmetic overflow
13:56:20 <dbpatterson> Cale: thanks for the info - if you ever discovered that again it would be handy on a page like http://www.haskell.org/haskellwiki/Crypto
13:56:28 <Polarina> monochrom: I doubt that.
13:56:29 <byorgey> ah, thanks monochrom
13:56:43 <monochrom> > let x<>y = 0 in x<>y<>z
13:56:44 <lambdabot>   0
13:56:50 <monochrom> Oh well!
13:56:52 <byorgey> > let f x y = x + y in a `f` b `f` c
13:56:53 <lambdabot>   a + b + c
13:57:04 <byorgey> > let f x y = (x,y) in a `f` b `f` c
13:57:05 <lambdabot>   ((a,b),c)
13:57:12 <yitz> > maxBound + 1 :: Int
13:57:13 <lambdabot>   -9223372036854775808
13:57:16 <byorgey> hmm, looks like left-associative is the default
13:57:22 <Polarina> Ok, nice. :)
13:57:25 <ddarius> Yes the default is infixl
13:57:51 <ddarius> > let infix 9 <>; x <> y = 0 in x<>y<>z
13:57:51 <lambdabot>   Precedence parsing error
13:57:52 <lambdabot>      cannot mix `<>' [infix 9] and `<>' [infix 9] ...
13:59:55 * ivanm is amazed at how many of the quotes in the HWN he @remember'd
14:00:18 <yitz> rntz: hmm, I always thought all operations on Int other than division by 0 returned some value, though the value is not guaranteed to make any sense
14:00:31 <ksf> rntz, there's the Bounded class
14:00:34 <ksf> :t maxbound
14:00:35 <lambdabot> Not in scope: `maxbound'
14:00:40 <ksf> :t maxBound
14:00:41 <lambdabot> forall a. (Bounded a) => a
14:01:17 <rntz> ksf: that's what I'll probably end up using. but am I guaranteed that the only possible way to get that error is dividing minBound by -1?
14:01:31 <yitz> ksf: yes, rntz is pointing out that (maxBound :: Int) `div` (-1) throws an exception. that surprises me.
14:01:48 <yitz> s/max/min/
14:02:37 <ksf> > (minBound :: Int) `div` (-1)
14:02:38 <lambdabot>   * Exception: arithmetic overflow
14:02:42 <yitz> > minBound `div` (-2) :: Int
14:02:43 <lambdabot>   4611686018427387904
14:03:05 <ksf> sure it's an overflow.
14:03:14 <yitz> > maxBound `div` minBound :: Int
14:03:15 <lambdabot>   -1
14:03:16 <ddarius> ksf: So is maxBound + 1
14:03:23 <ksf> the negative side is one larger than the positive, because positive bitpatterns include 0
14:03:47 <yitz> ksf: Int doesn't throw exceptions on overflow though. or so i thought until now.
14:04:30 <yitz> > negate minBound :: Int
14:04:30 <lambdabot>   -9223372036854775808
14:04:35 <Twey> > abs maxBound
14:04:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:04:36 <lambdabot>    `GHC.Enum.Bounded a'
14:04:36 <lambdabot>    ...
14:04:39 <Twey> > abs maxBound :: Int
14:04:40 <lambdabot>   9223372036854775807
14:04:53 <yitz> > abs minBound :: Int
14:04:54 <lambdabot>   -9223372036854775808
14:04:55 <mauke> it used to kill ghci, so that's an improvement
14:04:57 <yitz> hah
14:04:58 <Twey> *scratch*
14:04:58 <Twey> Oh
14:05:00 <ivanm> @tell roconnor I worked out what my problem was; I wanted to convert the alpha channel to being a Word8 so I multiplied it by fromIntegral (maxBound :: Word8)... but did that _before_ I calcualted the recip for pureColour :s
14:05:00 <lambdabot> Consider it noted.
14:05:03 <Twey> It's on the negative
14:05:06 <Twey> I forgot :þ
14:05:14 <roconnor> ivanm: that would do it
14:05:14 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
14:05:58 <Jedai> > maxBound +3
14:05:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:05:59 <lambdabot>    `GHC.Enum.Bounded a'
14:05:59 <lambdabot>    ...
14:06:10 <Jedai> > maxBound :: Int + 3
14:06:10 <lambdabot>   Only unit numeric type pattern is valid
14:06:17 <Jedai> > (maxBound :: Int) + 3
14:06:18 <lambdabot>   -9223372036854775806
14:06:41 <Jedai> Strange that overflow is on for the division but not the addition
14:06:50 <Jedai> > (maxBound :: Int) * 2
14:06:51 <lambdabot>   -2
14:06:59 <roconnor> > abs (minBound :: Int)
14:07:00 <lambdabot>   -9223372036854775808
14:07:01 <yitz> Jedai: or multiplication
14:07:12 <Jedai> yitz: Right :)
14:08:26 <dbpatterson> Cale: one last question - is the initialization vector another random Word128 (but one that needs to be kept around along with the key)?
14:11:26 <yitz> mauke: what used to kill ghci?
14:11:36 <pumpkin> hm
14:11:57 <mauke> minBound `div` (-1) :: Int
14:12:24 <medfly> maybe you need a >
14:12:25 <medfly> :)
14:13:29 <yitz> mauke: oh, so they know about this case.
14:14:28 <mauke> it triggers a SIGFPE at the machine level, same as dividing by 0
14:17:51 <ksf> it could test for the overflow bit, too.
14:19:25 <yitz> mauke: ghc could catch it and return a value
14:19:28 * RayNbow wonders what exoteric is talking about in http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13/?CommentID=507932 ...
14:19:32 <pastah_rhymez> Jedai: yes, i want to state what NOT to export
14:19:55 * RayNbow also doesn't see why it would be useful to restrict the size of a list at the type level for parser combinators
14:21:40 <Jedai> pastah_rhymez: Right, then the idiom with an .Internal works.
14:22:22 <pastah_rhymez> Jedai: does .Internal mean something special for the compiler or is it just a convention?
14:22:31 <pastah_rhymez>  /style?
14:22:37 <Jedai> I guess adding an hiding clause to the export syntax would be a minor extension...
14:23:06 <Jedai> pastah_rhymez: No, it doesn't mean anything, it's just an idiom
14:23:44 <toast-opt> raynbow, another level of practicality is that you would have a type system that adds more behavior as your solvers get better; if that feeds into overload resolution rules, things could go very wrong
14:23:46 <Jedai> pastah_rhymez: seems like a lot of recent libraries use it
14:24:08 <toast-opt> i don't know about D, but in C++ the template metaprograms affect function overloading
14:24:27 <ksf> in the end you end up writing export lists anyway, due to haddock.
14:24:32 <toast-opt> i don't think haskell has that sort of overloading though, that it's always unambiguous?
14:24:37 * RayNbow has no experience with template programming in C++ nor in D
14:26:06 <toast-opt> actually, pattern matching on function arguments remind me vaguely of that kind of overloading.  but in haskell, you can only pattern match over a single type or typeclass, right?
14:26:14 <ksf> well, you can enable OverlappingInstances or IncoherentInstances
14:26:23 <mauke> toast-opt: only over a single type
14:26:45 <toast-opt> mauke, thanks
14:27:08 <ksf> toast-opt, you'd use existential quantification/ Dynamic for such stuff
14:27:13 <toast-opt> raynbow, it's just a guess, but that might be what the commenter was talking about, overloading rules
14:27:53 <toast-opt> ksf, i'll keep an eye out for that.  i'm still very novice, haven't heard of those things yet
14:28:05 <toast-opt> only about 50 pages into 'real world haskell'
14:28:13 <toast-opt> so _really_ novice
14:29:04 * sproingie enables IncoherentInstances and ends up with Sarah Palin in his living room
14:29:39 <ksf> oh, then you want to forget what I just said, remember them when you've been successful forgetting everything about oop, a couple of chapters into rwh.
14:31:26 <yitz> rntz: i'm convinced. it's a bug in ghc. look at the comment to divInt# in GHC.Base http://darcs.haskell.org/packages/base/GHC/Base.lhs
14:31:46 <yitz> (with help from mmorrow on #ghc)
14:34:41 <Saizan_> @remember sproingie * enables IncoherentInstances and ends up with Sarah Palin in his living room
14:34:41 <lambdabot> Okay.
14:35:35 <yitz> rntz: anyway, it looks from there that this is the only case where you'll get that exception.
14:39:47 <rntz> yitz: good to know
14:42:28 <sproingie> :)
14:43:15 <mathijsB> hmm
14:44:47 <mathijsB> is head (drop num_item some_list) the way to get the n-th element of a list?
14:44:58 <mathijsB> or is there an easier way?
14:45:17 <Botje> list !! index
14:45:38 <mathijsB> ty :)
14:50:20 <toast-opt> i had a curious question about hugs and ghci interactive
14:50:45 <toast-opt> just learning, it's a little inconvenient that the syntax is different between the interpreters, and normal source files
14:50:59 <Gwern-away> @rememer wrake "Huet also called his theorem prover Cock^H^Hq. He likes that kind of joke, apparently." atonivs "I suppose the next program we can expect from him will be called Pousse."
14:51:00 <lambdabot> It is stored.
14:51:02 <toast-opt> is there any extension or interpreter where the syntax is closer?
14:51:10 <Gwern-away> @quote prover
14:51:11 <lambdabot> wrake says: "Huet also called his theorem prover Cock^H^Hq. He likes that kind of joke, apparently." atonivs "I suppose the next program we can expect from him will be called Pousse."
14:51:41 <Gwern-away> toast-opt: not really. the syntax is the same if you remember you're in a monad
14:51:52 <mauke> s/monad/do block/
14:51:58 <toast-opt> oh, that's what's different?
14:52:26 <toast-opt> so basically i should just not worry about it, because it will make sense to me later
14:52:27 <Saizan_> toast-opt: there was hbc which they say it could do declarations, but it's not developed anymore
14:52:47 <mauke> toast-opt: no, but you'll get used to the restrictions
14:53:10 <toast-opt> mauke, is the 'no' to 'it will make sense to me later'? :)
14:53:28 <mauke> yes
14:53:53 <toast-opt> :P
14:53:53 * hackagebot upload: hp2any-graph 0.5.2 - Real-time heap graphing utility and profile stream server with a reusable graphing module. (GergelyPatai)
14:53:57 <thunderbolt_> Anyone have any experience with random-fu? I'm having a bit of difficulty generating exponential random numbers.
14:54:05 <visualbasicgui> hello everybody. I've got a question about ghc. I'm working through RWH and I've written a file libjson.hs exporting a module LibJSON, and a file test_libjson.hs exporting Main (), with a function "main = print (some stuff)"
14:54:31 <Saizan_> toast-opt: i basically always write declarations in a file and use :r (or C-c C-l in emacs' haskell-mode) to reload it
14:54:38 <thunderbolt_> Alternative packages/approaches for generating random exponentially distributed numbers would be welcome as well :)
14:54:41 <visualbasicgui> First I run ghc -c libjson.hs which produces libjson.o
14:54:54 <visualbasicgui> then I run ghc -o test test_libjson.hs libjson.o
14:54:57 <visualbasicgui> but it complains
14:55:05 <visualbasicgui> failed to load interface LibJSON
14:55:19 <mauke> visualbasicgui: yeah, because it didn't find the .hi file
14:55:39 <mauke> visualbasicgui: this would be much easier if you used the same names for your modules and files
14:55:42 <sproingie> visualbasicgui: it has to be called LibJSON.hs, it's case-sensitive
14:55:44 <visualbasicgui> ? .hi file ? I'm not sure what that is
14:55:52 <visualbasicgui> yes I agree
14:55:58 <mauke> then you could just say ghc --make -O2 Main.hs
14:56:05 <sproingie> RWH really falls down with the JSON stuff
14:56:08 <mauke> actually, I think you can call the main program whatever you want
14:56:08 <visualbasicgui> RWH is awfully confusing in places. They use different names for their modules, source files, functions, object files ETC
14:56:09 <sproingie> it's total hodgepodge
14:56:21 <visualbasicgui> sproingie: absolutely.
14:56:29 <pumpkin> needs a second edition!
14:56:37 <sproingie> it gets better, tho it also gets bad again in other places
14:56:37 <Saizan_> yes, you can use any name for the file containing the Main module
14:56:58 <visualbasicgui> Saizan_: Yes I was wondering that aswell. I wouldn't like to have to always do "Main.hs"
14:58:06 <visualbasicgui> Yep, naming my module's source file in concert with the name of the module it represents fixed things. LibJSON.hs
14:58:35 <visualbasicgui> Meh, I'm pretty happy with RWH. I've read *plenty* worse books on programming. I think the fact that such a book even exists at all for haskell is a stroke of definite good luck
14:58:54 <sproingie> oh there's definitely good stuff in RWH
14:58:56 <visualbasicgui> I'd hate to be trying to learn haskell years ago
14:59:01 <sproingie> but it does get very frustrating
14:59:30 <sproingie> they do a nice job with the exercises on maps and folds
14:59:35 <junmin> xor 2 3
14:59:36 <visualbasicgui> Speaking however, of haskell books, has anybody here read the haskell school of expression? Would you recommend it? Mostly my interest with computer programming is to create art.
14:59:42 <toast-opt> vbg, i had the same reaction.  powells in portland only had like 3 haskell books, the others were very CS101 intro
15:00:18 <visualbasicgui> sproingie: oh yeah I'm not sure if you were here the other day when I was trying to understand foldl in terms of foldr, but trying to work through that one example expanded my mind by a factor of at least 2.
15:00:32 <junmin> > xor 2 3
15:00:33 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:00:33 <lambdabot>    `Data.Bits.Bits t'
15:00:33 <lambdabot>      a...
15:00:56 <sproingie> yeah that one is pretty mind-bendy
15:01:12 <sproingie> i figured it out too tho it never really stuck.  i have the attention span of a ferret
15:01:42 <visualbasicgui> hahahaha just keep with it. That's why this channel is here I guess
15:01:49 <sproingie> yep
15:02:10 <visualbasicgui> so nobody knows about the haskell school of expression?
15:02:11 <sproingie> i've got the basics down pat now, it's just assembling it into larger programs that still throws me
15:02:32 <visualbasicgui> sproingie: What I think might be great fun is to get in on something like project raincat.
15:02:36 <sproingie> it doesnt help that i've picked an area for my project that FP isn't known for doing well (a simulation-style game)
15:02:42 <visualbasicgui> It seems like it could use a lot of improvement : |
15:02:54 <sproingie> OOP being sort of a natural fit for simulation
15:02:57 <visualbasicgui> ah so you're interested in multimedia as well!
15:03:10 <thunderbolt_> sproingie: Simulations are fun in Haskell :D
15:03:20 <sproingie> naw, i'm looking at doing something similar to dwarf fortress
15:03:41 <sproingie> not quite as ambitious in scope.  i can't imagine making anything as complex as DF
15:03:43 <Warrigal> @index ap
15:03:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
15:03:43 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
15:03:51 <visualbasicgui> Well yeah here's the thing that hurts my feelings and aspirations. I sometimes wonder if imperative isn't simply a much better paradigm for time-based media, such as video games, since its nature is an unfolding of discrete steps in time. That's what a video game is, that's what a c program is.
15:03:57 <sproingie> but with a few better AI primitives to see if i can get interesting emergent behavior out of it
15:04:02 <sproingie> i'm calling it Goblin Horde
15:04:14 <visualbasicgui> How does one even go about writing a game loop in haskell ???
15:04:32 <sproingie> runGame :: World -> World
15:04:39 <visualbasicgui> Or is there some other way of going about it that's easier, as with many other things.
15:04:59 <visualbasicgui> World being a collection of the state of the world right? Intriguing.
15:05:20 <visualbasicgui> But I mean, the actual timing code. Or... libraries. Is there SDL? I've never looked into it as I think it will be a while until I'm ready.
15:05:21 <sproingie> the details of getting World -> World in a way that's actually expressive, flexible, *and* efficient is what I'm still trying to learn
15:05:30 <visualbasicgui> mhmmm.
15:05:42 <sproingie> i'll probably start with ascii graphics and vty then whip up an opengl tile engine
15:05:48 <visualbasicgui> Goblin Horde! What's the game about?
15:05:57 <sproingie> SDL is actually pretty disappointing performance-wise
15:06:12 <visualbasicgui> yes. I completely agree.
15:06:29 <toast-opt> couldn't you make the game loop imperative, but use pure functions for all the little bits
15:06:45 <toast-opt> and pure functions over the bits of imperative code
15:06:48 <sproingie> play dwarf fortress, i intend for the game to be like that
15:06:53 <visualbasicgui> I read "Racing the beam" from mit press, which is about the atari vcs platform and the tremendous hoops the programmers had to jump through just to efficiently update the screen, and I thought the whole time, "This is me, writing anything in SDL! We are united across time!!"
15:07:18 <visualbasicgui> toast-opt: That's what I think would be best.
15:07:21 <junmin> could you help me to corret this instruction? [n|n<-[xor 5 (2 ^ i)]] where i <- [1..3]
15:07:30 <visualbasicgui> sproingie: oh gosh DF. I've lost years to that game. Years.
15:07:33 <copumpkin> junmin: um
15:07:38 <sproingie> the top level of game loop doesn't have to be all that imperative, nor do the low-level functions, but it's wrangling all that state that may require a bit of imperative logic
15:07:54 <Gwern-away> I could've lost years to dwarf fortress, except the interface is beyond shitty
15:08:02 <Warrigal> junmin: what do you want that piece of code to do?
15:08:06 <copumpkin> > [xor 5 (2^i) | i <- [1..3]]
15:08:07 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:08:07 <lambdabot>    `Data.Bits.Bits t'
15:08:07 <lambdabot>      a...
15:08:11 <Gwern-away> (I mean, you thought nethack hada ui learning curve?)
15:08:14 <sproingie> visualbasicgui: obviously i can't make anything as twistedly awesome as DF, but if i start with some interesting primitive behavior, i want to see how the gobbos behave in the large
15:08:19 <copumpkin> > [xor 5 (2^i) | i <- [1..3]] :: [Integer]
15:08:20 <lambdabot>   [7,1,13]
15:08:26 <sproingie> so obviously my game uses goblins instead of dwarves
15:08:31 <copumpkin> > [5 `xor` (2^i) | i <- [1..3]] :: [Integer]
15:08:32 <lambdabot>   [7,1,13]
15:08:55 <Warrigal> What's that famous expression for primes using nubBy?
15:09:07 <copumpkin> > nubBy (\x y -> x `mod` y == 0) [2..]
15:09:08 <junmin> Warrigal: that's what copumpkin is writing
15:09:08 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:09:15 <copumpkin> it is?
15:09:19 <Associat0r> is Haskell's list comprehension a builtin syntactic construct?
15:09:24 <copumpkin> yep
15:09:36 <copumpkin> > nubBy (((>1) .) . gcd) [2..]
15:09:38 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:09:42 <visualbasicgui> sproingie: I think you and i share a love for emergent, procedural content. So beautiful.
15:09:56 <junmin> copumpkin: thank u
15:10:04 <Associat0r> copumpkin did you respond to me?
15:10:08 <copumpkin> yep
15:10:10 <copumpkin> :P
15:10:49 <sproingie> i started off wanting to write it in scala, then decided i may as well challenge myself and learn haskell again and use that
15:10:55 <Associat0r> copumpkin so it's in the compiler itself right?
15:11:01 <copumpkin> more or less, yep
15:11:24 <Associat0r> copumpkin what about [: :] array comprehension is that gonna be standard too soon?
15:11:55 <copumpkin> that's part of DPH
15:12:12 <copumpkin> I doubt it will be "standard" for a while, but you can always just turn it on
15:12:30 <Warrigal> @pl \x y -> x `mod` y == 0
15:12:30 <lambdabot> flip flip 0 . ((==) .) . mod
15:12:43 * Warrigal coughs.
15:12:55 <copumpkin> @let x `isMultipleOf` y = x `mod` y == 0
15:12:56 <lambdabot>  Defined.
15:13:01 <copumpkin> > nubBy isMultipleOf [2..]
15:13:02 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:13:04 <Associat0r> copumpkin can they be used as normal array's or is it something special?
15:13:25 <copumpkin> Associat0r: if you want to, sure. You might get some free parallelism :P
15:13:26 <Warrigal> @hoogle divides
15:13:26 <lambdabot> No results found
15:14:02 <Associat0r> copumpkin ok thanks
15:15:48 <Jedai> Associat0r: The array themselves aren't really special, mostly nice unboxed arrays underneath, but the operation on them are defined such that you get parallelism and the compiler does some vectorialisation and so on...
15:16:04 <copumpkin> and much fusion!
15:16:07 <copumpkin> mmmfusion
15:17:09 <Jedai> This stuff is still more than a little wonky in ghc6.10 but apparently it got much better in ghc6.12 and will probably be really usable and stable in 6.14 or 6.16, by this point it should be one of the most interesting way to get data directed parallelism
15:17:29 <Jedai> unless someone else do something much more advanced meantime
15:18:46 <Jedai> copumpkin: There's also recycling (IIRC), if they get it right it should help getting Haskell array code up to the standard of the world at large
15:19:04 <Jedai> and beyond it from a parallelism standpoint
15:20:31 <orbitz> in Python I have a function that take soptional parameters, how would i want to translate this to Haskell?
15:20:43 <toast-opt> maybe an options type?
15:21:03 <copumpkin> orbitz: probably just a Maybe :/
15:21:12 <Jedai> There's also an idiom with a record type
15:21:14 <copumpkin> orbitz: or if applicable, maybe a higher-order function
15:21:20 <Jedai> if you want default value
15:21:26 <Warrigal> So, I'm having my dad write stuff in Java and translating it into Haskell.
15:21:36 <copumpkin> Warrigal: how come?
15:21:58 <toast-opt> @data MyOptions = ExtraOptionA a | ExtraOptionB b
15:21:59 <lambdabot> Unknown command, try @list
15:22:07 <toast-opt> oh, hmm
15:22:15 <Jedai> orbitz: but really that depends on your function, Haskell often allows higher abstraction that can obviate the need for optional parameters
15:22:15 <Warrigal> copumpkin: it's a sort of contest, I guess.
15:22:25 <toast-opt> then, let myFn [MyOptions] = ...
15:22:38 <orbitz> what I was thinking was having a record type with all the optional things as Maybe's and then ding liek makeDefaultREcord {option1=whatever, option2=blah}
15:22:54 <orbitz> Jedai: do you have any suggestions i can look at?
15:22:57 <toast-opt> Warrigal, sounds like a good way to learn
15:23:21 <toast-opt> i'm learning haskell, wife learning F#, and we're both translating stuff from C#
15:23:22 <Warrigal> My first response to that was "Well, I'm not actually teaching him anything."
15:23:36 <orbitz> basically i'm trying ot make a function that takes a bunch of options and tarnsforms them into anotehr represetnation i'll use elsewhere (in this case a string for a command line program)
15:23:48 <Jedai> orbitz: look at the defaultConfig of XMonad for instance, lots of default value and you call it with "xmonad defaultConfig { terminal="konsole" }"
15:24:28 <Jedai> orbitz: Oh, then the proposition of toast-opt may make sense for you
15:24:30 <Warrigal> Type error in expression 'isLearning Warrigal': couldn't match expected type 'Student' with inferred type . . .
15:25:11 <toast-opt> Warrigal, nice :)
15:25:12 <Jedai> orbitz: if you can basically take a list of option and translate them element by element
15:25:43 <orbitz> hrm, that could be a lto of data's, but might be the cleanest
15:25:44 <orbitz> thanks toast-opt
15:26:05 <toast-opt> orbitz, i think that would also let you make the different options of different types
15:26:27 <toast-opt> data MyOpts = OptA String | OptB Integer | ...
15:26:33 <orbitz> toast-opt: yes I like that idea
15:26:42 <toast-opt> dunno how to prevent dups though
15:26:43 <trimeta> Is http://code.haskell.org/ down? I time out when I try to browse to it.
15:27:03 <toast-opt> [OptC True, OptC False]  |> isBad
15:27:23 <toast-opt> btw, does haskell have something like a pipeing operator?  saw that in F# and liked it
15:27:31 <orbitz> toast-opt: documetnation removes any repsonsibility from me:  -- Do not have duplicate entires
15:27:34 <orbitz> :)
15:27:38 <toast-opt> heh, nice
15:27:50 <Warrigal> toast-opt: something that puts the output of a first function into a second function?
15:27:54 <Associat0r> toast-opt $ but that is backward pipe
15:27:56 <toast-opt> yeah
15:27:57 <Warrigal> toast-opt: if so, secondFunction . firstFunction
15:28:14 <holmak> #hoogle .
15:28:15 <lunabot>  luna: Not in scope: `hoogle'
15:28:17 <holmak> erm
15:28:18 <Warrigal> $ isn't a pipe.
15:28:20 <holmak> @hoogle .
15:28:20 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
15:28:20 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
15:28:20 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
15:28:37 <toast-opt> i want operator such that 'f (g a)' == 'g a `X` f'
15:28:42 <toast-opt> solving for X
15:29:06 <Warrigal> toast-opt: oh, so X f x = x f?
15:29:11 <Associat0r> toast-opt "$  is <|" ". is <<"
15:29:20 <Warrigal> @type (<|)
15:29:21 <lambdabot> Not in scope: `<|'
15:29:30 <orbitz> my other question is, i have a series fo functions to transform those options into 1 form and I want to have another series of functiosn with teh same types that transform into another form, how can i write it so the dependent code is agnostic to which form? a monad?
15:29:31 <Polarina> Could someone explain the >>= operator for me, please?
15:29:40 <chrisdone> this is pretty neat. I've got outline-mode working with literate-haskell-mode: http://chrisdone.com/pics/emacs-folding.png
15:29:59 <orbitz> Polarina: it stands for "much greater than or equal to"
15:30:01 <sproingie> >>= is more or less what makes monads work
15:30:05 <holmak> Polarina: it is called "bind", and is part of the definition of monads
15:30:08 <Warrigal> Polarina: well, it's difficult to explain, and there are pages out there containing explanations of it.
15:30:12 <holmak> @hoogle >>=
15:30:12 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:30:12 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:30:12 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:30:16 <Warrigal> Polarina: I'm guessing you want a page explaining it.
15:30:22 <Polarina> Warrigal: Sure.
15:30:27 <Associat0r> Warrigal I know it's application operator
15:30:34 <orbitz> Polarina: ti's liek a semi colon that can do anything
15:30:40 <sproingie> BONUS really needs to introduce monads
15:30:45 <BONUS> coming up!
15:30:48 <BONUS> they're in the oven!
15:30:52 <toast-opt> heh
15:30:54 <BONUS> real soon!
15:30:58 <sproingie> BONUS: you did the awesomest job ever with applicative functors
15:31:09 <BONUS> haha thank you. i was wondering if people were going to get those
15:31:11 <holmak> is BONUS writing a book or something?
15:31:22 <Warrigal> Polarina: hmm, searching Google for 'haskell monad tutorial' gives a whole bunch of results.
15:31:22 <toast-opt> i thought monads seemed really strange, until i saw a parser combinator and realized that's what my parser library in C++ was doing
15:31:27 <Warrigal> I couldn't tell you which one is best.
15:31:28 <sproingie> holmak: he's the guy behind Learn You A Haskell
15:31:28 <chrisdone> @google learn you a haskell
15:31:29 <BONUS> now i'm kind of just hoping to ease into monads from applicatives without people realising
15:31:29 <lambdabot> http://learnyouahaskell.com/
15:31:29 <lambdabot> Title: Learn You a Haskell for Great Good!
15:31:39 <BONUS> because after all, monads are just applicatives with join
15:31:40 <toast-opt> so apparently monads are only hard to describe or to understand, but using is trival :)
15:31:46 <holmak> ah, ive seen that!
15:32:09 <toast-opt> learn you a haskell is awesome
15:32:13 <sproingie> monads are highly abstract things so any short explanation of them tends to be abstract too
15:32:14 <chrisdone> orbitz: you use emacs right?
15:32:14 <toast-opt> love the art esp
15:32:20 <orbitz> yes
15:32:25 <BONUS> hehe thx
15:32:27 <Associat0r> it's just some name for a math structure
15:32:36 <sproingie> right.  abstract.
15:32:46 <kniu> If everything can be abstracted by anything, how much inference is possible?
15:32:48 <chrisdone> orbitz: don't you think what I pasted is ``awesome''?
15:33:05 <sproingie> basically a monad is a context for some value. >>= means to apply that value using a function that returns into that same context
15:33:13 <sproingie> which again is probably more abstract than useful
15:33:15 <toast-opt> bonus,  the hardest part of technical writing is keeping it 'alive', not putting people to sleep.  you've nailed it i think.  keep it up :D
15:33:21 <orbitz> chrisdone: looking
15:33:45 <toast-opt> also, thx for posting the info for #haskell.  i was totally unaware of such a large active chat group
15:33:49 <Warrigal> > [10..3]
15:33:50 <lambdabot>   []
15:33:59 <toast-opt> > [10,9..3]
15:34:00 <lambdabot>   [10,9,8,7,6,5,4,3]
15:34:03 <sproingie> yah, LYAH has the cuteness but it's not incoherent like why's poignant guide
15:34:08 <chrisdone> orbitz: section 7 has a bunch of text/explanation and code, as do 1-6. delicious outline mode!!
15:34:14 <BONUS> toast-opt: yeah haha, it's very important to break up certain monotony
15:34:25 <orbitz> chrisdone: ohhh neato!
15:34:34 <BONUS> cause peoples' eyes just glaze over once there's a big paragraph of really hard words, even if they understand each word by itself
15:34:39 <orbitz> chrisdone: did you just combine outline mode + some checks for >?
15:35:04 <toast-opt> i think the only style i've seen that comes close to topping LYAH is mercurial's tutorial.  you're neck and neck for accessible tutorials
15:35:20 <chrisdone> orbitz: I set the outline-regexp and outline-level regexes to pickup the "1.2.3" format at the start of a line. obviously any code will start with "> " so there's no conflict! =)
15:35:36 <BONUS> mercurial's tutorial is great (as is mercurial)
15:35:37 <chrisdone> orbitz: http://pastie.org/709350
15:35:57 <orbitz> so you barely had to do any work
15:35:59 <chrisdone> orbitz: popped that in haskell-mode-hook
15:36:01 <toast-opt> ooo, scheme
15:36:02 <chrisdone> yeah, haha :P
15:36:14 <orbitz> chrisdone: do you know haskell mode well?
15:36:31 <chrisdone> orbitz: I use it a lot but whether I know it well... why?
15:36:57 <chrisdone> toast-opt: that's emacs lisp
15:37:11 <Warrigal> I'm looking at the first page of Learn You a Haskell.
15:37:27 <orbitz> chrisdone: i remember there being a key-combo where you could take a where clause, for example, adn it would align all of the ='s
15:37:50 <toast-opt> chris, thx, i realized i jumped the gun.  i forget other lisps exist :)
15:38:17 <Jedai> toast-opt: If you still want a "pipeing" operator, you can define it yourself "let (f |> g) x = g (f x)"
15:38:58 * hackagebot upload: lostcities 0.2 - An implementation of an adictive two-player card game (PedroVasconcelos)
15:39:09 <Jedai> toast-opt: with "x $> f = f x" and nice priorities, you'll get the same thing as in F#
15:39:10 <toast-opt> jedai, thx, but if it doesn't exist, it's probably because it's not idiomatic haskell.  i should just learn the 'right' haskell way to do things.  at least until i learn the right way.  then i can start doing things the wrong way
15:39:19 <chrisdone> orbitz: hmm. I've seen that for Yi, I think, on a talk. but not for haskell-mode... that sounds interesting..
15:39:20 <orbitz> chrisdone: do you know what that key combo is?
15:39:27 <orbitz> Hrm
15:39:33 <orbitz> drats i very much recall using this in teh past
15:39:41 <orbitz> is there any way to get a list of key combos a -mode provides?
15:40:00 <Associat0r> toast-opt the reason it's so much in F# is the way type inference works from left to right
15:40:05 <Jedai> toast-opt: then the "right" way is probably to combine (.) and ($) and write your pipeline in reverse (compared to F#, Haskell use the same direction as maths)
15:40:20 <toast-opt> yeah
15:40:28 <kmc> Polarina, do you understand this syntax:  do { x <- a; b }
15:40:34 <kmc> (here "b" is an expression that might contain "x")
15:40:37 <Jedai> > filter (>10) . map (*2) $ [1..10]
15:40:38 <lambdabot>   [12,14,16,18,20]
15:40:45 <toast-opt> so "let second = head . tail"
15:40:47 <chrisdone> orbitz: ermm
15:40:48 <Jedai> toast-opt: something like that ^
15:41:23 <toast-opt> thx
15:41:35 <Jedai> toast-opt: right (except second is already defined in Control.Arrow with another sense and your second == (!! 1))
15:41:47 <toast-opt> heh, yes
15:42:15 <toast-opt> i need to just finish RWH, then come with any q's not already a'd there
15:42:26 <Polarina> kmc: Kind of.
15:42:30 <Jedai> orbitz: Yes
15:42:34 <Polarina> kmc: No, I don't.
15:42:41 <Jedai> orbitz: but don't ask me how ! ;)
15:42:46 <orbitz> Jedai: dam you!
15:42:47 <chrisdone> orbitz: C-h m
15:42:51 <Warrigal> Hey, I sent half of a thought. Let me try that again: I'm looking at the first page of Learn You a Haskell. I like the way it explains behaviors in terms of familiar concepts like "sneaky" and "big enough already".
15:42:55 <yitz> orbitz: ^C-? usually, but haskell-mode doesn't define it
15:43:10 <yitz> orbitz: but the keys are listed in the help for the haskell-mode function
15:43:14 <chrisdone> orbitz: perform that on the given mode
15:43:20 <yitz> orbitz: best is to look at the source :)
15:44:25 <chrisdone> orbitz: ooo. M-x describe-bindings
15:44:35 <kmc> Polarina, it means "do a, name the result x, then do b"
15:44:50 <Polarina> kmc: Ok.
15:44:55 <chrisdone> ah. C-c C-> inserts the birds. useful to know
15:45:26 <kmc> now when i said "do" there, i mean something totally different from evaluation or function application
15:45:32 <chrisdone> orbitz: GOT IT!
15:45:36 <kmc> (which is where other languages go wrong -- they confuse these concepts)
15:45:39 <chrisdone> orbitz: C-c C-.         haskell-indent-align-guards-and-rhs
15:45:48 <chrisdone> \o/ !!
15:45:49 <kmc> what i mean by "do" and for that matter "result" depends on the monad in question
15:45:59 <kmc> (brb)
15:46:08 <chrisdone> orbitz: totally awesome. I never knew that existed
15:46:10 <Polarina> kmc: I didn't understand your last statement.
15:46:22 <orbitz> hiiyaa
15:46:31 <orbitz> chrisdone: drats you beat me
15:46:41 <Warrigal> The pictures help when you leave the page and come back to it and have to find your place.
15:46:43 <orbitz> chrisdone: how did you determien what key combo it correspodn to
15:46:44 <yitz> chrisdone: sometimes it's a little over-zealous imho. it tries to line up the :: in the type also, and ends up making a mess.
15:46:59 <kmc> Polarina, i was just saying that these are terms i have not yet defined
15:47:00 <chrisdone> orbitz: I went to the mode and did M-x describe-bindings
15:47:11 <kmc> and that when i do define them, they will have one meaning for IO and another for Maybe and another for Parsec, etc.
15:47:12 <orbitz> cool
15:47:24 <orbitz> chrisdone: a handy little feature!
15:47:31 <Polarina> kmc: Parsec?
15:47:39 <kmc> Polarina, a monadic parser combinator library for haskell
15:47:42 <BONUS> Warrigal: yeah that's a cool side-effect of the pictures :D people use them as a sort of bookmark
15:47:43 <Polarina> ...
15:48:00 <BONUS> they're like: i read up until the monkey on a tricycle thing
15:48:00 <chrisdone> orbitz: indeed! quite a few describe-<blah> functions
15:48:28 <Warrigal> I read up until [milk, bred, egs, a dog].
15:48:36 <BONUS> hehe
15:50:57 <kmc> Polarina, I can't respond helpfully to "?" or "...".  if you can explain what confuses you, i'll try to help
15:51:20 <kmc> i only brought up Parsec because it's a) a useful real-world tool, b) implemented with monads, and c) has nothing to do with IO
15:51:30 <kmc> (though these days people often use it with Applicative rather than Monad functions)
15:51:36 <chrisdone> I certainly do
15:51:39 <Polarina> kmc: I don't know what a monadic parser combinator library is.
15:51:46 <kmc> Polarina, then let's not worry about it
15:52:11 <Jedai> Polarina: Parsec is the an equivalent of bison or yacc in that it allows to describe a parser for a grammar, but it is directly integrated into the language rather than an external tool
15:52:24 <toast-opt> the internet if overflowing with parser combinator tutorials
15:52:29 <orbitz> Could I use a monad to make it so sometign like createFoo opt1 opt2 does something different depending on what backend i chose? like in haskell I might just have a class that implements that method and pass a different class in dependin gon what functionality i want. does that make sense?
15:52:38 <Jedai> Polarina: If you don't know what bison or yacc are, let's say it's regex on steroid
15:52:42 <toast-opt> google for monadic parsers.  unfortunately few of the tutorials are good
15:52:57 <Polarina> Jedai: Ok.
15:52:58 <chrisdone> orbitz: makes sense to me
15:53:32 <kmc> Polarina, do you understand what i mean if i call something a monadic "action" or "computation" or "recipe"?
15:53:42 <Polarina> kmc: No.
15:53:42 <junmin> > [xor 5 (2 ^ i) | i >= 0, (2 ^ i) < 5] :: [Integer]
15:53:48 <lambdabot>  Terminated
15:54:02 <kmc> what i mean, formally, is a value of type "m a", for some m and a, where m is a monad
15:54:05 <orbitz> basicaly i have an interface to ec2 and an interface to a thing caleld nimbus, and the functions my program calls should be the look the same but they need to od slightly differen tthings depending on which cloud service i want to use
15:54:18 <Polarina> kmc: What's a monad?
15:54:27 <kmc> Polarina, an instance of the typeclass "Monad"
15:54:32 <kmc> defined in the Haskell standard prelude
15:54:34 <Jedai> junmin: that's not a list comprehension, you need a list on the right side
15:54:36 <BONUS> 3 is a thing. [3], Just 3, (\x -> 3), that's a monadic value, or what i call a "fancy thing"
15:54:40 <kmc> @instances Monad
15:54:43 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:54:45 <kmc> Polarina, a Monad is any of those ^^^^
15:54:46 <yitz> junmin: after the | you need to write i <- (something)
15:54:58 <Polarina> kmc: I read that "All about Monads" but it never defined what monads really were.
15:55:11 <copumpkin> ugh
15:55:12 <kmc> Polarina, it will become clear when you know how to use them
15:55:18 <copumpkin> so much bad monad
15:55:18 <kmc> @src Monad
15:55:19 <lambdabot> class  Monad m  where
15:55:19 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:55:19 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:55:19 <lambdabot>     return      :: a -> m a
15:55:19 <lambdabot>     fail        :: String -> m a
15:55:25 <orbitz> kmc: + a year of using them
15:55:25 <yitz> [xor 5 (2 ^ i) | i <- [0..5], i >= 0, (2 ^ i) < 5] :: [Integer]
15:55:29 <kmc> orbitz, true
15:55:31 <thunderbolt_> Hey, I want to write a function that does something like [1,2,3,4] -> [1,3,6,10]. Any ideas on how to implement this efficiently?
15:55:45 <kmc> Polarina, a Monad is any type M, such that we have these two functions:
15:55:46 <Polarina> thunderbolt_: scanl
15:55:51 <kmc> return :: a -> M a
15:55:54 <thunderbolt_> Polarina: Thanks.
15:55:59 <kmc> (>>=) :: M a -> (a -> M b) -> M b
15:56:08 <BONUS> > scanl (+) 0 [1,2,3,4]
15:56:10 <lambdabot>   [0,1,3,6,10]
15:56:11 <kmc> (you should ignore "fail" and (>>) for the time being)
15:56:20 <thunderbolt_> Polarina: Awesome, thanks!
15:56:30 <toast-opt> thx earlier, but i looked at ($), and can't fathom what it's used for.  "(f $ a) $ b" appears to be the same as "f a b".  why use ($)?
15:56:38 <kmc> Polarina, do you understand how typeclasses work?
15:56:39 <Warrigal> Polarina: the types of [3], Just 3, and (\x -> 3) could be [] Int, Maybe Int, and (->) Int Int, respectively. [], Maybe, and (->) Int are all monads.
15:56:41 <Jedai> Polarina: it does though, it has a description of the mathematic construction. In fact I like All about monads because it don't try to do too much allegory, it gives the properties of a Monad and then plenty of examples, if you read and understand most the examples you get an idea of what monads are
15:56:45 <Polarina> kmc: The data thing?
15:56:52 <nlogax> toast-opt: it has low precedence and allows you to omit parens
15:56:53 <kmc> Polarina, what "data thing"?
15:56:57 <toast-opt> > ((+) $ 1) $ 2
15:56:58 <lambdabot>   3
15:57:00 <orbitz> toast-opt: but f $ a b i snot teh same as f a b
15:57:05 <toast-opt> oh, gotcha
15:57:05 <Polarina> kmc: data Sheep = Sheep Int String
15:57:07 <Warrigal> toast-opt: so you can say "a $ b $ c $ d $ e" instead of "a (b (c (d e)))" and such.
15:57:10 <kmc> that defines a type
15:57:11 <kmc> not a typeclass
15:57:11 * toast-opt changes precidence.  that makes sense
15:57:16 <kmc> you should learn what typeclasses are
15:57:22 <Polarina> kmc: What are those?
15:57:23 <kmc> because they're a good deal more fundamental than monads
15:57:34 <kmc> because "Monad" is just one particular typeclass in the standard library
15:57:42 <kmc> other important typeclasses are Eq, Ord, Show, Num, ...
15:57:47 <orbitz> toast-opt: if you have 1 parameter i've seen a lto of peopel rpefer f . a $ b
15:57:51 <kmc> any halfway decent Haskell tutorial should explain typeclasses
15:58:09 <toast-opt> > (+) . 1 $ 2
15:58:10 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:58:10 <lambdabot>    `GHC.Num.Num a' arising f...
15:58:11 <Jedai> toast-opt: for instance "f . g . h $ x + y" is equal to "(f . g . h) (x + y)" which is what you want
15:58:37 <toast-opt> oh, so you use it with (.)
15:58:50 <orbitz> you can use it with .
15:58:51 <kmc> > succ . succ $ 3
15:58:52 <lambdabot>   5
15:59:05 <kmc> > succ $ succ $ 3
15:59:07 <Jedai> toast-opt: or other binary operation on each side of the ($)
15:59:07 <lambdabot>   5
15:59:07 <kmc> > succ $ succ 3
15:59:08 <lambdabot>   5
15:59:09 <toast-opt> > (+) 1 . (*) 3 $ 0
15:59:10 <lambdabot>   1
15:59:12 <kmc> > (succ . succ) 3
15:59:13 <lambdabot>   5
15:59:31 <toast-opt> sweet, that makes sense now
15:59:35 <Jedai> > succ . succ $ 3
15:59:36 <lambdabot>   5
15:59:50 <jl_2> I'm trying to read a file into a data structure and having some problems with IO
15:59:50 <Warrigal> I want a function trustMe :: a -> b that gives a runtime error if you apply something that can't take an a to it.
15:59:55 <jl_2> how do I get rid of it?
15:59:56 <chrisdone> orbitz: yeah a class to do the core operations that both imlpementations will use sounds about right. that's one thing I like about type classes, you can define only a few core things *inside* the class and then implement functions ontop of it (like Control.Applicative or Control.Arrow do)
15:59:57 <toast-opt> heh, does (succ) exist just for example purposes? :)
16:00:06 <Warrigal> So you could do stuff like map show ["blah", trustMe ()]
16:00:08 <kmc> Warrigal, did you see "cast"?
16:00:15 <kmc> Warrigal, look at Data.Dynamic
16:00:15 <dpratt71> kmc, Polarina: fwiw, I tend to think of typeclasses as being very similar to interfaces in OOP
16:00:30 <Warrigal> kmc: does that work for all types or only those in a certain class?
16:00:37 <Polarina> dpratt71: Interfaces?
16:00:37 <kmc> Warrigal, only those in Typeable
16:00:40 <kmc> which is almost anything
16:00:40 <sproingie> dpratt71: they're similar, but there's important differences
16:01:06 <dpratt71> Polarina: if you don't know OOP, forget my analogy
16:01:13 <nlogax> toast-opt: you can do things like map ($ 3) [(2*), (3+)] with it too
16:01:19 <Jedai> Warrigal: there also is unsafeCast but I don't think you want that, are you sure you don't want a conversion typeclass instead ?
16:01:21 <Polarina> dpratt71: I know OOP, but I don't know what you're referencing to.
16:01:24 <sproingie> haskell *values* are polymorphic, which throws a lot of the comparisons out the window
16:01:25 <dpratt71> Polarina: otherwise you'll have two things to learn :)
16:01:41 <kmc> and then one to unlearn
16:01:47 <junmin> Jedai: yitz: got it :P
16:01:48 <dpratt71> Polarina: what's a language you do know?
16:01:49 <jl_2> maybe I'm missing something, but why can't IO be more like Maybe?
16:01:53 <toast-opt> oh, $ is sorta a name for 'apply'
16:02:01 <ben0x539> jl_2: Because there is no Nothing io?
16:02:05 <Polarina> dpratt71: x86_64 assembly, C, C++, Python, Bash, PHP.
16:02:06 <kmc> jl_2, "more like" how?
16:02:06 <toast-opt> nlogax, do i have that right?
16:02:33 <nlogax> toast-opt: yep, i think it's commonly called the function application.. err, function
16:02:42 <jl_2> so basically everything in the program that deals with the data structure I build has to be "wrapped" in IO?
16:02:44 <dpratt71> Polarina: an interface is like a class with only pure virtual methods
16:02:50 <Polarina> dpratt71: Ok.
16:02:54 <sproingie> jl_2: if you could extract a pure value out of IO, you'd break referential transparency
16:03:02 <dschoepe> jl_2: If you want maybe-like behaviour in IO, you can use a monad transformer(there's a MaybeT on hackage).
16:03:03 <kmc> jl_2, yes, but you can call pure functions from IO code
16:03:12 <nlogax> toast-opt: so you can throw function application around like that, or use the low precedence
16:03:21 <yitz> jl_2: no, not your data structure. just the outside world.
16:03:26 <kmc> jl_2, if you have some f :: (a -> b) you can "lift" it to f :: (IO a -> IO b)
16:03:28 <jl_2> but what's the point if those functions can't act on data from the file?
16:03:30 <dpratt71> Polarina: now if someone can tell you the differences between interfaces and typeclasses, your set! :)
16:03:35 <Warrigal> jl_2: not everything that deals with it; only stuff that actually does IO. You can say print (x + 3) even though + isn't wrapped at all.
16:03:42 <Jedai> Warrigal: look at convertible and see if it does what you want : http://hackage.haskell.org/package/convertible
16:03:46 <sproingie> IO seems to have quite a magical lift
16:03:47 <toast-opt> nlogax, is ($ 3) pretty much a lambda for "lambda x: x(3)", ... latter expression in python, sorry
16:04:13 <kmc> toast-opt, yes
16:04:17 <Jedai> toast-opt: Right
16:04:18 <jl_2> say I want to read a list of numbers from a file, put them in a list, and then add 5 to all of them
16:04:27 <kmc> jl_2, and get another list?
16:04:27 <yitz> jl_2: do f <- readFile "myFile"; putStr (doSomething f)
16:04:28 <toast-opt> does that apply to all binary operators?
16:04:40 <kmc> jl_2, look at "interact"
16:04:41 <nlogax> toast-opt: yes, or (\x -> x 3) in haskell :)
16:04:41 <kmc> :t interact
16:04:42 <lambdabot> (String -> String) -> IO ()
16:04:46 <jl_2> so I have to do putStr on it?
16:04:49 <yitz> jl_2: "doSomething is the main part of your program, and it's pure
16:05:04 <yitz> jl_2: putStr prints the output
16:05:08 <sproingie> interact is oddly enough not very useful for interactive I/O
16:05:23 <toast-opt> nlogax, thx for the translation.  btw, i really like the asthetic.  (\) looks like 2/3rds of a lambda
16:05:44 <toast-opt> gtg pick up some pizza.  thx everyone for the help
16:05:46 <nlogax> toast-opt: hehe, yeah, that's the idea.
16:05:58 <luqui> sproingie, ioFilter might be a better name (as unix folks call functions from stdin to stdout "filters")
16:06:02 <Jedai> jl_2: "xs <- liftM (map ((+5) . read) . lines) readFile "filename"
16:06:03 <nlogax> toast-opt: my editor shows that as (λx →  x 3)
16:06:10 <toast-opt> > map (\x -> x * x) [0..9]
16:06:11 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
16:06:11 <sproingie> you can make some editors render it as a lambda, tho it screws things up if you copy and paste
16:06:20 <yitz> toast-opt: when ur on #haskell you have to get ur pizza delivered
16:06:33 <toast-opt> yitz, they don't deliver out this far :(
16:06:36 <kmc> but... λ is a lowercase letter! shouldn't it be an identifier?
16:06:38 <sproingie> can't use the real lambda because it's alphabetic
16:06:47 <toast-opt> kmc, :D
16:06:49 <jl_2> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5049#a5049
16:06:50 <nlogax> kmc: there are many of them :)
16:07:06 <jl_2> I guess I don't understand the advantage of IO over something like that paste
16:07:10 <holmak> arrows are so ridiculous
16:07:13 <kmc> jl_2, what do you mean?
16:07:20 <kmc> jl_2, that paste is in the IO monad, except you forgot a "do"
16:07:31 <Jedai> toast-opt: (+3) or ($ 18) are called "section", they work with all binary operators (except (-5), Haskell see that as a negative number)
16:07:34 <kmc> you can't just put two expressions one after another like that
16:07:34 <luqui> jl_2, inputData <- readFile "myFile"
16:07:54 <luqui> (jl_2, assuming you are in a do block)
16:07:59 <toast-opt> > map (* 5) [0.9]
16:08:00 <lambdabot>   [4.5]
16:08:05 <toast-opt> oops
16:08:08 <ben0x539> jl_2: IO is not for handling errors
16:08:10 <jl_2> no, that was made up psuedo-haskell, meant to show what I'm trying to ask
16:08:12 <ben0x539> IO is for ensuring sequencing
16:08:12 <toast-opt> well, same diff :)
16:08:24 <kmc> jl_2, modified for you
16:08:35 <yitz> jl_2: in that case, inputData is guaranteed to have exactly the same value every time.
16:08:41 <kmc> so the only change is the word "do", and the idea that you have to give the result of "readFile" a name
16:08:42 <sproingie> > map (* 5) [0..9]
16:08:43 <lambdabot>   [0,5,10,15,20,25,30,35,40,45]
16:08:51 <yitz> jl_2: if it comes from a file, you don't want that guarantee probably
16:09:05 <sproingie> the IO monad is for sequencing and to "jail" impure values
16:09:16 <kmc> jl_2, in your original version, "inputData" is not the contents of the file.  it's a *recipe* for how to *get* the contents of the file
16:09:21 <kmc> :t let foo = getChar in foo
16:09:21 <lambdabot> IO Char
16:09:27 <kmc> foo is not a Char
16:09:33 <kmc> it's a recipe for getting a Char
16:09:49 <kmc> by evaluating that "let" we haven't read any character.  we just gave another name to something we already had
16:10:24 <jl_2> I understand the difference, I'm just not seeing why it's worthwhile
16:10:26 <Jedai> jl_2: do you understand what referencial transparency means ?
16:10:55 <kmc> jl_2, what if we wanted to execute your program in parallel across many cores simultaneously?
16:11:03 <Jedai> jl_2: in an increasingly parallel world, separating impure code from pure code is increasingly useful
16:11:06 <kmc> we can't just assume that any expression could have a side effect
16:11:25 <kmc> we need to know when we're doing computation, and when we're interacting with the world
16:11:44 <kmc> or (as another example) say you're writing a testing framework... it's very convenient to separate the description of what IO you're doing, from the actual doing of the IO
16:11:47 <sproingie> aside from parallelism, one of the reasons haskell's able to do such crazy powerful things is because of purity
16:11:54 <sproingie> stuff like STM couldn't work without it
16:11:57 <Jedai> jl_2: it also enhance your ability to reason locally with a guarantee that nothing far away will influence your result
16:12:01 <kmc> you can stub out the latter and plug it into the testing system
16:12:53 <jl_2> that's great, but I'm just trying to read an input file into a data structure - it will never be parallelized because data later in the file depends on previous data already being read
16:13:07 <kmc> jl_2, you picked a language that enforces this up front
16:13:18 <kmc> you also picked a language with static types
16:13:25 <kmc> and a lot of people would say those aren't necessary here either
16:14:06 <jl_2> but I'm expecting them to help out when I'm actually writing the algorithms that process the data structure...
16:14:07 <mtnviewmark> ping - copumpkin
16:14:11 <kmc> yes
16:14:13 <kmc> as will purity
16:14:19 <kmc> because you'll be able to apply equational reasoning
16:14:21 <Jedai> jl_2: if you don't enforce it everywhere, it becomes really hard to do it retroactively and get the same guarantees, I don't see why kmc proposition seems harder to you than what you wanted to write
16:14:36 <kmc> if the definition of "x" is "e", then you can think as if everywhere you see "x", you have replaced it with "e"
16:14:44 <kmc> that's a really powerful way to think about how programs behave
16:15:35 <kmc> when i was teaching intro CS in Scheme, the students always understood this concept immediately.  and then when we introduced side effects, they had to instead draw out big diagrams of all the environment frames, and their understanding plummeted
16:15:53 <kmc> because you can no longer say "x is y so x acts like y"
16:16:20 <jl_2> x = readFile "myfile.txt" replaces x with the contents of "myfile.txt"?
16:16:31 <kmc> if "x" is the expression "getchar()" in C, then x acts differently every single freaking time you use it
16:16:32 <pastah_rhymez> which array type is the slow one where writing is O(n)?
16:16:48 <kmc> jl_2, i don't follow.  you're asking a question of fact about haskell?
16:16:54 <kmc> because i thought we both agreed the answer was "no"
16:17:22 <jl_2> oh, sorry, meant to say "why can't you just say x = readFile "myfile.txt" replaces x with the contents of "myfile.txt"?
16:17:23 <Saizan_> pastah_rhymez: Array and UArray
16:17:33 <pastah_rhymez> Saizan_: how do they differ?
16:17:36 <kmc> jl_2, that's what we've been explaining
16:17:45 <kmc> why are you unsatisfied with what's been said so far?
16:18:02 <jl_2> and I disagree about getchar() in C... it acts the same every single time, returning the next input character
16:18:08 <dpratt71> jl_2: if the contents of "myfile.txt" is guaranteed never to change, you might be able to get away with that
16:18:15 <Saizan_> pastah_rhymez: the latter is for unboxed values, so it's a chunk of memory which directly contains the data
16:18:22 <kmc> jl_2, it breaks the "same expression => same value" rule
16:18:28 <kmc> the value is a different character each time
16:18:38 <luqui> dpratt71, i would argue with that :-P
16:18:39 <kmc> that's the equational reasoning which i am claiming is so important for understanding programs
16:18:51 <kmc> it prevents nonlocal effects from creeping in where you don't expect them
16:18:52 <jl_2> I don't see what "guaranteed never to change" has to do with it
16:18:57 <pastah_rhymez> Saizan_: cool
16:19:02 <Saizan_> pastah_rhymez: so if you're using primitive types and you don't explicitly need laziness, it's a better choice wrt performance
16:19:16 <jl_2> if there's no change, what's the point?
16:19:16 <sproingie> x = readFile "myfile.txt" means x is an IO action, namely readFile "myfile.txt".  the file gets read when you execute the action, which can only happen in the IO monad
16:19:24 <pastah_rhymez> Saizan_: my arrays will be read-only
16:19:32 <pastah_rhymez> i just want an O(1) lookup table
16:19:37 <jl_2> when do you ever need to run a program on the exact same hard coded data?
16:19:45 <luqui> jl_2, ignore that guaranteed never to change business
16:19:47 <sproingie> jl_2: right, that's why we have IO
16:19:57 <kmc> jl_2, do you believe that Haskell is incapable of doing IO?
16:20:07 <sproingie> readFile "myfile.txt" is always the same value
16:20:13 <sproingie> the result of *executing* it is not always the same
16:20:17 <sproingie> it's impure
16:20:19 <kmc> pastah_rhymez, if you want read-only arrays, then you can build them any way you want, and freeze it if necessary
16:20:22 <jl_2> I just don't understand why it's so tricky to strip off the IO part
16:20:23 <dpratt71> jl_2: the assumption (in Haskell) is that if you call a function with the same parameter value(s), you will get the same result
16:20:24 <sproingie> what that's why it's limited to IO
16:20:29 <Saizan_> pastah_rhymez: you should be fine with these then
16:20:42 <pastah_rhymez> Saizan_: if i have (Int,Int,Int) in an UArray, is there any way to really cram it in there?
16:20:47 <sproingie> jl_2: it's not tricky at all, it just breaks the guarantees that makes all the other parts of haskell work
16:20:51 <pastah_rhymez> getting rid of all the pointers and stuff
16:21:01 <luqui> jl_2, it's not that tricky.  you just have to get used to it.  it lets know things about our programs that other languages cannot know about their programs.
16:21:22 <pastah_rhymez> Saizan_: i will have either 3xInt or 3xWord8
16:21:27 <kmc> jl_2, it's not that tricky.   do { x <- readFile "foo";  print (f x) }
16:21:32 <kmc> doesn't that look like any other imperative language?
16:21:55 <kmc> packing 3xWord8 should be a big win
16:22:05 <kmc> iirc there's a way to define new UArray types
16:22:16 <Saizan_> pastah_rhymez: you could use 3 arrays
16:22:17 <kmc> but you can also go for cheap hack and add a third index dimension with 3 values
16:22:26 <jl_2> every time I think "I'm going to make an effort to use Haskell for this", I sit down, write 95% of the program, then spend 10x longer writing the last little bit that reads input
16:22:28 <dpratt71> kmc: I'd say that IO (in Haskell) is easy until you want to understand how it works ;-)
16:22:53 <pastah_rhymez> Saizan_: haha, you cheat :p
16:22:57 <kmc> jl_2, i agree.  this is common for beginners
16:22:58 <sproingie> it's probably the hardest part to get right
16:22:58 <Saizan_> pastah_rhymez: or pack them into Word32 / Word64 with some bit twiddling
16:23:02 <kmc> Haskell has a steep learning curve
16:23:13 <kmc> i encourage you to stay with it, because when you understand everything, it really does make sense
16:23:21 <sproingie> we're still figuring out elegant ways to connect I/O to pure functions
16:23:24 <kmc> and if you're stuck on a particular problem, we can always help
16:23:26 <Saizan_> mh, for the Ints you'd need more bits :)
16:24:02 <pastah_rhymez> sproingie: let myPureValue = pureFun maybeTaintedValue
16:24:18 <pastah_rhymez> write like that in your do-notation
16:25:14 <sproingie> works fine in the monad, sure
16:25:30 <sproingie> i'm referring more to higher level abstractions.  like frp
16:25:38 <dpratt71> kmc: I'm not sure I believe Haskell deserves it's reputation for being hard to learn; I think it's just that Haskell is very different from more mainstream languages
16:25:50 <dpratt71> it's the un-learning that's hard
16:25:53 <Gwern-away> @wn paynim
16:25:55 <lambdabot> *** "paynim" wn "WordNet (r) 2.0"
16:25:55 <lambdabot> paynim
16:25:55 <lambdabot>      n : a heathen; a person who is not a Christian (especially a
16:25:55 <lambdabot>          Muslim)
16:26:37 <kmc> dpratt71, i agree, but i also think haskell is legitimately hard.  things like static typing and purity enforce a lot of discipline up front
16:26:53 <Warrigal> This is what I've always wanted to say: "You don't turn an IO String into a String; you turn your need for a String into a need for an IO String."
16:26:53 <kmc> meaning that small beginner programs are often discouraging to write
16:26:59 <kmc> because "this is so easy in Python"
16:27:22 <dpratt71> kmc: funny; as I see it, dynamic languages are the ones that require discipline
16:27:25 <Warrigal> Which is precisely the type signature of (>>=). It takes something that needs an a and returns something that needs an IO a.
16:27:28 <sproingie> python's module reference is also typically replete with examples
16:27:47 <kmc> dpratt71, right -- but nobody forces you to have the discipline up front
16:28:04 <kmc> it's a matter of enforcing rules early on, versus letting people do anything and let them shoot themselves in the foot later
16:28:09 <dpratt71> kmc: pay now or pay later :)
16:28:12 <mtnviewmark> is code.haskell.com down? or broken?
16:28:20 <mtnviewmark> er code.haskell.org
16:28:28 <dpratt71> (with interest)
16:28:38 <sproingie> trac seems broken last i tried
16:29:34 <mtnviewmark> I can't even get to lambdabot's command list (which is there)
16:29:49 <Saizan_> Warrigal: that's why in CT you actually talk about (=<<) (in the Kleisli categories formulation)
16:29:51 <mtnviewmark> http://code.haskell.org/lambdabot/COMMANDS
16:30:54 <eugenn> hello
16:31:08 <dpratt71> I've been trying to figure out what prevents Haskell from taking over the world
16:31:09 <kmc> Saizan_, not (>=>) ?
16:31:31 <dpratt71> dpratt71: maybe it just doesn't want to :P
16:31:38 <Badger> mtnviewmark: at least there's always http://tinyurl.com/yjkce46 :)
16:31:38 <kakeman> :P
16:32:01 <eugenn> pl \x y -> x y
16:32:06 <mtnviewmark> thanks, Badger
16:32:09 <eugenn> @pl \x y -> x y
16:32:09 <lambdabot> id
16:32:12 <sproingie> i think there is some truth to the notion that imperative programming is closer to how people think of tasks as a series of actions
16:32:27 <sproingie> "if this then that, if this other case then that, do this thing next, then if this happens, etc"
16:32:49 <sproingie> the world is updated every step, so everything is very easy to reason about locally, if hard to abstract out as a whole
16:32:56 <Saizan_> kmc: that's composition in those categories, but you also have a * operator to go from (A -> M B) to M A -> M B, so you can see that as an arrow in the original category and get to compose it there
16:33:10 <Saizan_> kmc: maybe i sould have said Kleisli triple
16:33:21 <eugenn> @pl \x -> x+1
16:33:21 <lambdabot> (1 +)
16:33:26 <tensorpudding> what is this Kleisli thing
16:33:43 <kmc> part of the problem with Haskell is that C++ and Java have so poisoned the name of statically typed languages
16:33:44 <sproingie> tensorpudding: a -> m b is a kleisli arrow
16:33:56 <tensorpudding> okay
16:33:56 <sproingie> (i think)
16:34:15 <sproingie> odd thing, i can't find any biographic info on the guy who they're named after
16:34:50 <eugenn> @pl suma x = x+1
16:34:50 <lambdabot> suma = (1 +)
16:34:51 <sproingie> kmc: arguably C did even worse to them
16:35:05 <mtnviewmark> I can't agree -- I don't think imperative programming is ] closer to how people think on anything but a superficial level
16:35:05 <kmc> with C you know what you're getting up front
16:35:20 <eugenn> wow this is trully amazing. haskell rocks, i wish I was an expert in this like you guys
16:35:23 <sproingie> and BCPL was even worse, it was untyped
16:35:28 <mtnviewmark> consider how long it takes to teach most students concepts like variables, call stacks, functions, sub-routines, etc....
16:35:32 <kmc> a powerful, unsafe systems language, where types exist only to specify how the compiler should represent things, *not* to help you reason about code or find errors
16:35:48 <MoALTz> there is a fair amount of reasoning there - that things should be how you left them based on previous actions
16:35:54 <kmc> the C type system is, in the end, pretty simple
16:36:14 <kmc> C++ has this horribly complex ornate type system, which mostly gets in the way rather than helping you do anything
16:36:22 <kmc> and it makes it all too easy to circumvent
16:36:24 <eugenn> @pl find condicion = head . filter condicion
16:36:25 <lambdabot> find = (head .) . filter
16:36:35 <toast-opt> fixed-length bitvectors, and 2 parametric types: const, and ptr?
16:37:41 <mtnviewmark> to me, the "aha" moment came when I re-wrote a package I wrote in C++ a few years ago -- I've been writing C++ for many years professionally, and I choose a package I was especially proud of - the code was clean, and the both the interface and implementation files read like good documentation to both users and maintainers
16:37:41 <kmc> backwards compatibility is a huge problem there.  they introduced a bunch of safer cast operators, which have long names so people disregard them and use the "simple" and unsafe C cast
16:38:13 <mtnviewmark> then I re-wrote it in Haskell --- Literally 1/5th the code, and it is, if anything, more clear to both users and maintainers
16:38:18 <toast-opt> but aren't C++ and haskell about the same age?
16:38:27 <Saizan_> tensorpudding: newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }, you can then make an instance Monad m => Arrow (Kleisli m) where (>>>) = (>=>), (***) f g (a,b) = liftM2 (,) (f a) (g b); first f (a,b) = fmap (\a -> (a,b)) (f a), modulo newtype constructors
16:38:35 <mtnviewmark> No, C++ is quite a few years older
16:38:40 <mtnviewmark> (methinks)
16:38:52 <Zao> Both Haskell and C++ was standardized in '98.
16:38:59 <blackdog> mtnviewmark: your standards change a bit too - i wrote a five line haskell function yesterday, and i'm a bit ashamed of it. it needs refactoring badly.
16:39:12 <toast-opt> oh, you're right
16:39:16 <Zao> C++ probably has a decade or two of use before that.
16:39:21 <Twey> C++ is seven years older, though, says WP.
16:39:23 <toast-opt> c++ -> 83,
16:39:25 <toast-opt> yup
16:39:29 <Saizan_> tensorpudding: so, every Monad gives rise to an Arrow, but you can't get all the expressivity of the Monad interface using only the Arrow interface on that type, you also need ArrowApply
16:39:34 <Twey> C++: '83, Haskell: '90
16:39:46 <chrisdone> god I love Data.Default
16:39:48 <eugenn> @pl pesoCompuesto = sum . map (\(elemento, cantidadAtomos) -> (pesoAtomico elemento) * cantidadAtomos)
16:39:48 <lambdabot> pesoCompuesto = sum . map (uncurry ((*) . pesoAtomico))
16:39:56 <Twey> Why do we even have monads any more, if ArrowApply does the same thing?
16:40:00 <toast-opt> ML, then
16:40:02 <mtnviewmark> Mind you, you *do* have to get over "crazy moon langauge" of Haskell -- but then again, that's what people used to say about C++ templates and STL (okay, okay, they *still* say it)
16:40:12 <toast-opt> ML -> 73
16:40:31 <kmc> the funny thing is, C++ templates are much harder to learn than even Template Haskell let alone Haskell
16:40:37 <kmc> because templates are only a functional metalanguage by accident
16:40:50 <Twey> Even though they're less powerful
16:40:56 <kmc> i wish you could just metaprogram C++ with C++
16:40:58 <eugenn> @pl mismoGrupo elemento1 elemento2 = grupoQueContieneA elemento1 == grupoQueContieneA elemento2
16:40:58 <lambdabot> mismoGrupo = (. grupoQueContieneA) . (==) . grupoQueContieneA
16:41:00 <mtnviewmark> I haven't touched Template Haskell yet....
16:41:15 <toast-opt> kmc, not really.  side effects and weak typing would make that a pain
16:41:22 <kmc> but still better than templates
16:41:23 <mtnviewmark> and I certainly have been able to do everything I ever did in C++ templates in just plain-ol' Haskell
16:41:28 <holmak> chrisdone: what is Data.Default so useful for?
16:41:33 <mtnviewmark> only with less syntax, and actually clearer code
16:41:41 <toast-opt> kmc, if you could metaprogram C++ in C++, then people would heap-buffer-overrun internal compiler data structures, and rewrite them.  on purpose
16:41:58 <kmc> heh
16:42:50 <eugenn> @pl find condicion = head . filter condicion
16:42:50 <lambdabot> find = (head .) . filter
16:43:17 <Twey> (fmap head . filter)
16:43:21 <chrisdone> holmak: default settings
16:43:26 <toast-opt> const_cast<struct Class*>(typeof(T))->base_class = typeof(int)
16:43:42 <holmak> chrisdone: aha. It does seem like an ingeniously simple idea.
16:43:57 <chrisdone> indeed
16:44:04 <dpratt71> since LOBs are what pay the bills around here: how is the experience of using Haskell to interact with databases?
16:44:18 <kmc> Monoids also have default values
16:44:25 <kmc> LOB?
16:44:27 * hackagebot upload: bitmap 0.0.0 - A library for handling and manipulating bitmaps. (BalazsKomuves)
16:44:40 <MoALTz> 0.0.0?
16:44:42 <dpratt71> kmc: line-of-business application
16:45:09 <BMeph> I thought C++ was '89, not 83. Or is that from "first thought of the idea"? :)
16:45:12 <eugenn> @pl cuantosCumplen condicion = length . filter condicion
16:45:12 <lambdabot> cuantosCumplen = (length .) . filter
16:45:24 <chrisdone> kmc: I don
16:45:30 <chrisdone> kmc: think def = mempty
16:45:32 <jl_2> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5051#a5051
16:45:38 <eugenn> @pl aparear lista = quickSort . (lista ++)
16:45:38 <lambdabot> aparear = (quickSort .) . (++)
16:45:50 <BONUS> spanish haskell
16:45:51 <BONUS> interesting
16:45:52 <toast-opt> bm - might depend on if you include c-with-classes
16:46:07 <arjanb> eugenn: mismoGrupe = (==) `on` grupoQueContieneA  -- on from Data.Function
16:46:09 <jl_2> No matter what I try, I get the error "Couldn't match expected type `String' against inferred type `IO String'"
16:46:19 <chrisdone> kmc: mempty `mappend` x == x, whereas def is the data filled in. it wouldn't make sense to mappend two settings data types
16:46:28 * hackagebot upload: bitmap-opengl 0.0.0 - OpenGL support for Data.Bitmap. (BalazsKomuves)
16:46:28 <kmc> jl_2, which line?
16:46:29 <jl_2> on line 14, "dataStruct = buildDataStructure inputData"
16:46:39 <BMeph> toast-opt. Oh, no. That would explain it, I guess. :)
16:46:50 <kmc> jl_2, you didn't run the "readFile fn" action
16:46:54 <kmc> you just renamed it to "inputData"
16:47:02 <eugenn> thanks arjanb, but i''m just a beginner :P
16:47:04 <kmc> your inputData is a recipe for getting the data, not the data itself
16:47:11 <kmc> do { inputData <- readFile fn; let ... }
16:47:52 <kmc> you can nest "do" and "let" expressions the usual way, since they're both just expressions.  but you can *also* use "let x = y" in a do, *without* the "in", which is implicitly the rest of the do block
16:48:29 * hackagebot upload: stb-image 0.2 - A wrapper around Sean Barrett's JPEG/PNG decoder (BalazsKomuves)
16:48:37 <eugenn> ¿Does anybody know a way to define the "inverse" function? I mean, the type would be (a -> b) -> (b -> a). You follow me?
16:48:46 <kmc> chrisdone, certainly some Defaults are not Monoids.  but should Monoid not be a subclass?
16:48:54 <eugenn> takes a function and returns the inverse
16:49:00 <kmc> eugenn, not generally possible
16:49:03 <|Jedai|> eugenn: I follow you but it can't be written in general
16:49:07 <kmc> the first fuction might throw away information
16:49:10 <eugenn> oh I see
16:49:14 <kmc> what's the inverse of (\x -> 3)
16:49:22 <Zao> kmc: Horrible death.
16:49:28 <eugenn> ooh you're smart hehe
16:49:44 <kmc> there are some types for working with functions that are invertible
16:49:47 <jl_2> thank you, that worked
16:50:19 <|Jedai|> eugenn: even if you restrict yourself to bijection, I think being able to write inverse would be impossible though, something to do with the halting problem
16:50:23 <holmak> perhaps, type Invertible a b = (a -> b, b -> a)
16:50:40 <chrisdone> kmc: that's what I was thinking, sounds about right. I guess a "Zero" class would be better from which Monoid can inherit. but then "default" doesn't sound like "zero". whole point of an empty/zero is identity, AFAIK
16:50:42 <eugenn> halting problem? i'll google that
16:50:45 <toast-opt> yeah, but what about the function of "f x = x * ((\x -> 3) x)"
16:50:46 <kmc> better:  data Invertible a b = Invertible (a -> b) (b -> a)
16:50:50 <toast-opt> that should be invertable
16:50:53 <holmak> doesn't calculate it, but you could make some fun functions based on it
16:51:07 <kmc> a type synonym for a tuple is a really dubious thing imo
16:51:15 <kmc> usually you're better off defining a new type
16:51:17 <|Jedai|> holmak: Right that's basically the solution adopted for that kind of thing, that restrict the application field of course
16:51:39 <holmak> im sure Invertible is floating around in some library, but I haven't seen it
16:52:22 <|Jedai|> eugenn: It's the one that said that you can't write a program that can decide if a program will finish in finite time
16:52:45 <eugenn> I see
16:52:46 <toast-opt> invertable would be cool though.  like invertable binary logic, there are some fun things that come out when you can run computations backwards
16:52:55 <kmc> quantum computation is invertible
16:52:59 <|Jedai|> eugenn: at least not in a turing-complete language
16:53:09 <kmc> also you can do invertible computation without using energy, in theory
16:53:31 * hackagebot upload: vacuum-opengl 0.0.2 - Visualize live Haskell data structures using vacuum, graphviz and OpenGL. (BalazsKomuves)
16:54:05 <eugenn> I liked that (head .) . filter very much. I'm gonna use it in my exam next week :)
16:54:21 <toast-opt> kmc, you mean, you may or may not do invertible computation, w.o using energy
16:55:20 <toast-opt> if you want a computer that, statistically, makes forward progress, it always takes _some_ energy, right?
16:55:43 <kmc> no
16:55:50 <jl_2> I guess I wasn't quite understanding the difference between "do { id <- readFile fn; let ...}" and "let id = readFile fn ..." but I think it makes sense now
16:55:53 <jl_2> thanks kmc
16:56:03 <kmc> jl_2, no problem
16:56:12 <patch-tag> let's say i want to check the name of current process. like, I want to see whether I am in ghci or not, from inside a running program
16:56:19 <patch-tag> way to do that?
16:56:28 <mmorrow> preflex: seen dcoutts
16:56:32 <preflex>  dcoutts was last seen on #haskell 9 hours, 48 minutes and 47 seconds ago, saying: you actually want to upgrade "some" dependencies, but which ones exactly is the thing that has to be worked out
16:56:34 <mmorrow> preflex: seen dcoutts_
16:56:38 <preflex>  dcoutts_ was last seen on #ghc 23 days, 7 hours, 49 minutes and 40 seconds ago, saying: oh, probably using ghc-pkg
16:56:40 <kmc> :t getProgName
16:56:41 <lambdabot> Not in scope: `getProgName'
16:56:41 <patch-tag> hm... System.Environment...
16:56:45 <patch-tag> aha
16:56:46 <kmc> patch-tag, getProgName?
16:57:19 <eugenn> @pl :t filter
16:57:19 <lambdabot> (line 1, column 1):
16:57:19 <lambdabot> unexpected ":"
16:57:19 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:57:23 <chrisdone> :t System.Environment.getProgName
16:57:24 <lambdabot> IO String
16:57:32 <kmc> patch-tag, there's probably a better way to check if you're in ghci, using the GHC API
16:57:42 <kmc> and indeed whether you are compiled or interpreted
16:58:01 <Berengal> Indeed, I sometimes call ghci through a shell-script for various reasons
16:58:35 <patch-tag> i think that will work for what I need though
16:58:36 <Berengal> For example, an old version of haskell-mode needed to run through a script, or you'd get extra garbage coming out of ghci
16:58:49 <kmc> haskell-mode talks to ghci?
16:58:55 <Berengal> needed to run ghci through a script*
16:58:58 <Berengal> inferior-haskell does
16:59:03 <patch-tag> I'm having to rout around a lock-file cleaning up issue in happstack
17:00:17 <Twey> http://en.wikipedia.org/wiki/Therac-25 — needs more Haskell
17:01:28 <Berengal> Twey: IIRC wasn't the issue there that the programmers thought the users knew what they were doing?
17:01:53 <Twey> Berengal: Without any documentation to *tell* them what to be doing, yeah
17:02:21 <Twey> The operator ignored an error message, because the error message looked like ‘MALFUNCTION 5’ and wasn't explained anywhere in the manual
17:02:47 <skorpan> :t (&&&)
17:02:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:02:49 <Twey> (of course, that really shouldn't have been overrideable…)
17:03:02 <Berengal> I'm not laying the blame on the user, but it wasn't a bug as much as a faulty specification
17:03:07 <skorpan> @instances Arrow
17:03:08 <lambdabot> (->), Kleisli m
17:03:15 <Twey> Berengal: Well, no, it was a bug that it got to this state in the first place
17:03:27 <Twey> *Then* the safety checks threw up the error message
17:04:11 <Twey> (actually, it looks like this was a second or third layer of safety checks, the previous layers being ignored due to further bugs)
17:04:34 <kmc> they had a race condition
17:04:42 <kmc> because they were programming in multithreaded VAX assembly
17:04:51 <eugenn> @pl a b c d e f g
17:04:51 <lambdabot> a b c d e f g
17:04:55 <Twey> Heh, aye
17:05:00 <Twey> Hence ‘needs more Haskell’
17:05:08 <Trollinator> i need a three-dimensional array with 3x3x3 entries.
17:05:20 <Twey> triplez: Okay?
17:05:21 <Trollinator> this is how i do it: listArray (0,2) (repeat (listArray (0,2) (repeat (listArray (0,2) (repeat 0)))))
17:05:24 <Twey> Er, Trollinator
17:05:27 <Trollinator> that's rather ugly.
17:05:30 <Axman6> Trollinator: Array (Int,Int,Int) a
17:05:34 <|Jedai|> Trollinator: you can use triplet as index
17:05:44 <Trollinator> oh
17:05:52 <kmc> Trollinator, multidimensional arrays and arrays-of-arrays are different in Haskell
17:05:53 <Polarina> Is there a function like 'lines' and 'words', but which I give it my own delimiter?
17:05:54 <Twey> listArray ((0, 0, 0), (2, 2, 2))
17:06:02 <Trollinator> wonderful, thanks.
17:06:13 <kmc> Polarina, look at the package "split" on hackage
17:06:19 <Polarina> kmc: Ok.
17:06:20 <Twey> Polarina: In Data.List.Split in the split package, yes
17:06:42 <Polarina> kmc: split :: (RandomGen g) => g -> (g, g)
17:07:04 <Twey> Polarina: Not that ‘split’ :þ
17:07:10 <Polarina> What split then?
17:07:11 <Twey> Data.List.Split.split
17:07:12 <|Jedai|> Polarina: Not this one
17:07:15 <Twey> From the split package.
17:07:30 <Berengal> One problem we face is that it's hard to put software specifications into a language.
17:07:42 <Berengal> For that we need types, and lots of them.
17:07:44 <Polarina> Twey: But if I would like to keep both splits?
17:07:45 <|Jedai|> Polarina: You know hackage, right ?
17:07:55 <Polarina> |Jedai|: No, I don't.
17:07:57 <Trollinator> too bad that you can't write a function in haskell that takes a tuple of arbitrary length.
17:07:59 <Twey> Polarina: Then import one or both of them qualified
17:08:06 <|Jedai|> Polarina: you can import one of the module qualified
17:08:08 <Polarina> Twey: Ok.
17:08:10 <Berengal> Trollinator: you can. It's called a list
17:08:32 <Trollinator> the point of a tuple is that it can hold values of different types.
17:08:34 <Twey> Trollinator: Rarely.  Wanting a tuple of arbitrary length is usually a sure sign that you shouldn't be using a tuple.
17:08:41 <|Jedai|> Berengal: Well not exactly, a list can only contain one type
17:08:50 <Twey> Unless it's an HList
17:08:59 <eugenn> HList?
17:09:01 <|Jedai|> You have HList though
17:09:03 <eugenn> wow
17:09:08 <Berengal> |Jedai|: of course it can. Otherwise, how would you know the type of the things you got out of it were?
17:09:10 <|Jedai|> eugenn: heterogenous list
17:09:11 <Twey> No, the point of a tuple is that it allows you to group multiple values (whose number is known at design-time)
17:09:30 <Trollinator> well, in the documentation it says that there are Ix instance declarations for tuples up to length 5.
17:09:34 <eugenn> I'm in WinHugs.. I don't have that, right?
17:09:35 <Trollinator> that's a botch, IMO.
17:09:40 <Twey> The error is in thinking that ‘tuple’ is a type.
17:09:50 <Twey> It's not.
17:09:51 <|Jedai|> Berengal: see HList ;)
17:09:56 <Trollinator> it is...
17:10:16 <|Jedai|> Trollinator: tuple is not a type
17:10:18 <sproingie> tuple by itself is not a type
17:10:20 <Twey> (Int, Int) is a type.  (a, b) is a sort of meta-type.  ‘Tuples’ as a whole are more like a meta-meta-type.
17:10:26 <sproingie> a tuple of some size and types is a type
17:10:35 <Berengal> |Jedai|: Those aren't really arbitrary length anymore. You know the length of them at compile-time... Well, at least the compiler does
17:11:08 <Trollinator> when i said "it is" i meant that it's a botch, not that it's a type.
17:11:12 <|Jedai|> Berengal: Right, but that adress the "limited to small length" of the tuple related functions
17:11:16 <Twey> Really, there's no such thing as a ‘tuple’ in the language.  There are pairs, there are triples, and there are quadruples, but ‘tuple’ is just a handy name for that whole kind of types.
17:11:32 <Berengal> "Tuple" is just a name for a set of similar type constructors.
17:12:06 <sproingie> and common syntax
17:12:08 <Berengal> |Jedai|: Well, yes. HLists are nice
17:12:10 <blackdog> anyone using an EEE 701 for haskell dev? trying to work out if it's practical or not.
17:12:12 <Twey> And really, if you've got a five-tuple, you're probably doing something wrong.  Try a record instead.
17:12:26 <sproingie> blackdog: how much ram does it have?
17:12:30 <blackdog> a gig
17:12:39 <sproingie> that'll probably be fine
17:12:42 <eugenn> ¿Is the best way to sort a list that qsort function that you find anywhere?
17:12:42 <|Jedai|> Trollinator: Really who needs more than 5 dimensions to its array, if worse come to worse, writing an Ix instance for longer tuple is not hard at all
17:12:56 <|Jedai|> eugenn: no
17:12:58 <Berengal> eugenn: no, use Data.List.sort instead
17:12:58 <sproingie> i have a 256M host that 6.10 dies on, but 6.12 does fine
17:13:01 <blackdog> was thinking more ergonomics - does it kill your hands to type on it etc
17:13:08 <eugenn> oh
17:13:08 <Twey> @src sort
17:13:08 <lambdabot> sort = sortBy compare
17:13:12 <Twey> @src sortBy
17:13:12 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
17:13:29 <Berengal> @faq does @src lie about real implementations?
17:13:29 <lambdabot> The answer is: Yes! Haskell can do that.
17:13:29 <|Jedai|> eugenn: depending on the content of your list using Data.IntSet can be faster too
17:13:30 <sproingie> blackdog: beats me.  i wouldn't be able to stand it, some people can
17:13:50 <sproingie> blackdog: as netbooks go, asus are supposed to be good quality
17:13:50 <Trollinator> that's nitpicking. The point is that there are places where it would be useful to define functions for tuples of arbitrary length. For example there is zipWith, zipWith3, zipWith4 ...
17:14:05 <Trollinator> that's rather ugly, i think.
17:14:08 <|Jedai|> Twey: well that's the report code, GHC use a merge sort
17:14:09 <blackdog> sproingie: fair enough. i have a couple of 17" mac laptops of varying age, but they're a bit heavy to carry around
17:14:14 <sproingie> Trollinator: it is not nitpicking, it's a fundamental thing about the language that you're missing.  quite deliberately i'm starting to think.
17:14:15 <Twey> Trollinator: See ZipList
17:14:26 <Trollinator> i'm not missing anything.
17:14:33 <eugenn> All this Data.Foo libraries come with GHC, right?
17:14:36 <Twey> Although that's not about tuples so much as functions.
17:14:39 <Twey> Trollinator: You are. ☺
17:14:40 <Gwern-away> sproingie: with a name like trollinator...
17:14:42 <Trollinator> sproingie, you're missing my point.
17:15:00 <|Jedai|> Trollinator: those function are only there fo convenience, you can have arbitrary length if you want
17:15:17 <sproingie> TH does have some ways of treating tuples generically, but that's as syntactic elements
17:15:34 <sproingie> it doesnt change what the compiler thinks of them
17:15:37 <junmin> how to run a function N times? :|
17:15:38 <Cale> dbpatterson: About the initialisation vector, that's right. Usually the IV is generated from the key in some way.
17:15:43 <|Jedai|> eugenn: some, Data.IntSet for instance comes with GHC or rather with the Haskell platform now
17:16:07 <Gwern-away> :t until
17:16:08 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:16:15 <blackdog> junmin: with different arguments? if you run the same function over the same argument n times, you'll get the same answer n times...
17:16:16 <eugenn> I did that Ntimes thing once! I don't remember it now...
17:16:21 <|Jedai|> junmin: depends on what you mean, is the type (a -> a) ?
17:16:23 <sproingie> just n times you can use repeat
17:16:56 <|Jedai|> > (!! 5) . iterate (*2) $ 1
17:16:57 <lambdabot>   32
17:17:03 <eugenn> ntimes doube 2 returns 2^n right? that's what you want?
17:17:10 <Berengal> ntimes n f = foldl' (.) id (replicate n f)
17:17:27 <sproingie> oh yeah iterate is probably more useful
17:17:44 <|Jedai|> Berengal's solution is better for big n though
17:18:05 <|Jedai|> or not
17:18:06 <sproingie> @src iterate
17:18:06 <lambdabot> iterate f x =  x : iterate f (f x)
17:18:08 <Berengal> |Jedai|: naw, not really. iterate should work just the same
17:18:17 <sproingie> pretty much what i expected
17:18:26 <Berengal> modulo some constants, possibly...
17:18:41 <sproingie> iterate defineable in terms of fix?
17:18:43 <eugenn> @src succ
17:18:43 <lambdabot> Source not found.
17:19:24 <Twey> zipWith f list1 list2 ... listN = getZipList $ f <$> ZipList list1 <*> ZipList list2 <*> ... <*> ZipList listN
17:19:42 <knobo> what's up with planet.haskell.org?
17:19:45 <Twey> Trollinator: ^
17:20:03 <eugenn> @src (^)
17:20:03 <lambdabot> x ^ 0            =  1
17:20:04 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
17:20:04 <lambdabot>   where f _ 0 y = y
17:20:04 <lambdabot>         f x n y = g x n
17:20:04 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
17:20:05 <Trollinator> Sorry, i don't know all those operators.
17:20:05 <lambdabot>                       | otherwise = f x (n-1) (x*y)
17:20:07 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
17:20:22 <Trollinator> but i'll look into that some time, thanks.
17:20:32 <zygoloid> > fix (\i f x -> x : i f (f x)) (*2) 1
17:20:33 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
17:20:34 <junmin> Jedai: blackdog: figuring it out. if it were in a normal language, it's a function modify a global variable
17:20:36 <knobo> The server at planet.haskell.org is taking too long to respond.
17:20:45 <|Jedai|> ntimes n f x = foldl' (flip ($)) x (replicate n f)
17:20:50 <eugenn> > 2+9
17:20:51 <lambdabot>   11
17:21:08 <Optimoe> still 11? phew
17:21:11 <Cale> Trollinator: To be honest, tuples of sizes larger than (or even equal to) 3 are very rare in real code.
17:21:32 <Trollinator> yes, i know.
17:21:32 <|Jedai|> Berengal: on the other hand this one should be more efficient
17:21:34 <sproingie> usually it's pairs
17:21:40 <pastah_rhymez> how depracated are n+k-patterns?
17:21:44 <kmc> tuples suck
17:21:44 <sproingie> arrows, state, all that, use pairs
17:21:56 <Berengal> Trollinator: zipWith3 f a b c ~ zipWith2 ($) (zipWith2 f a b) c
17:21:57 <sproingie> pastah_rhymez: highly.  treat them as if they're already gone
17:21:58 <blackdog> junmin: yeah, you almost certainly don't want to do that.
17:21:58 <Trollinator> I just thought it was ugly when i saw zipWithX for X in [3..7]
17:21:58 <|Jedai|> pastah_rhymez: not really yet, but expected to be in Haskel'
17:22:01 <kmc> you shouldn't use them except very locally
17:22:08 <BMeph> @pl (\i f x -> x : i f (f x))
17:22:08 <lambdabot> (ap (:) .) . ((.) =<<)
17:22:13 <kmc> pastah_rhymez, we have view patterns now
17:22:26 <eugenn> lastDigit = flip mod 10. better way to do that? There isn't one is it?
17:22:30 <BMeph> Yecch! >:(
17:22:35 <pastah_rhymez> kmc: i have a function of an int, but it comes in with a value that's 16 too high
17:22:39 <Axman6> junmin: 'normal language'?
17:22:49 <kmc> pastah_rhymez, let n' = n - 16 in ...
17:22:49 <sproingie> heh yeah come to think view patterns could be a generalized n+k
17:22:52 <Trollinator> and i know that C++0x allows type-safe functions of variable arity.
17:22:55 <pastah_rhymez> so i thought i'd exploit n+k to get rid of that
17:22:58 <Cale> View patterns aren't really a replacement for what n+k patterns are there for in the first place.
17:23:05 <sproingie> Trollinator: haskell functions don't have arity at all
17:23:06 <Cale> Oh
17:23:08 <junmin> Axman6: the mainstream imperative languages
17:23:08 <blackdog> junmin: think about what you're actually trying to compute. Do you want the result of applying the function f :: a -> a to a value n times? do you want to map it over a list of n items?
17:23:09 <Trollinator> (and yes, i know that haskell functions only ever take 1 argument).
17:23:09 <junmin> hahahah
17:23:12 <Cale> pastah_rhymez: Just use 'where'
17:23:28 <kmc> also, remember that "type-safe" and "statically typed" are different concepts
17:23:30 <pastah_rhymez> Cale: yeah, i do, but it still would've been nice
17:23:35 <kmc> type-safe variadic functions are easy
17:23:40 <kmc> you just check the type at runtime
17:23:41 <daryoushm> just testing, please ignore
17:23:46 <kmc> (that's how Text.Printf.printf works)
17:23:50 <Twey> kmc: That's not ‘type-safe’ :þ
17:24:00 <|Jedai|> junmin: ntimes n f x = foldl' (flip ($)) x (replicate n f)
17:24:01 <kmc> Twey, it's safe, in that the type system prevents the program from "going wrong"
17:24:05 <Cale> Yeah, I don't consider runtime tests that might fail to be type-safe.
17:24:14 <kmc> they're not statically typesafe
17:24:16 <Twey> Except it doesn't: dying with a type error during execution is ‘going wrong’.
17:24:24 <kmc> not in the narrow definition
17:24:33 <kmc> do you really consider Python an unsafe language?
17:24:38 <Berengal> Strong typing isn't good enough to be type-safe IMHO. You need static safety for that
17:24:39 <kmc> it can't crash and format your hard drive like a C program can
17:24:41 <Cale> kmc: Absolutely, yes.
17:24:49 <Cale> kmc: It has no type system.
17:24:55 <kmc> Cale, that's totally false
17:24:58 <kmc> it has a runtime type system
17:25:04 <Berengal> Cale: it does, but no static type system
17:25:05 <tommd> Forgive me #haskell, for I have sinned: "#define ptell lift . tell $ printf"
17:25:05 <tommd> Will I get a mob chasing after me shouting "heretic!" now? :-(
17:25:14 <Cale> Dynamic types aren't really types ;)
17:25:20 <Twey> I'm pretty sure it can in fact crash and format your hard drive.
17:25:27 <tommd> If someone could show me how to do that without a CPP macro I would be very happy.
17:25:29 <eugenn> > foldl (+) 0 [1..]
17:25:36 * BMeph thinks that "runtime type system" is self-contradicting
17:25:39 <tommd> But right now I need to take my wife on a date.
17:25:40 <lambdabot>   mueval: ExitFailure 1
17:25:53 <Berengal> Cale: dynamic typing is a sort of inverted dependent type system ;)
17:25:55 <Adamant> BMeph: only Haskell/ML people take that position
17:25:57 <Trollinator> BMeph, it's not.
17:26:03 <|Jedai|> Trollinator: note that you can write Haskell functions with an "arbitrary" arity, see printf for instance (though not really a good example, given that its arity depends on data it may not be made really statically safe in Haskell)
17:26:10 <Berengal> Instead of values in the type system, there's types in the term language
17:26:14 <Adamant> the lack of agreement on definitions here is definitely annoying
17:26:15 <kmc> yup
17:26:19 <kmc> in Python, type(type) == type
17:26:21 <kmc> try it
17:26:22 <Adamant> but it's as much political as everything
17:26:28 <Adamant> *anything
17:26:29 <Cale> Types, at least to me, are arbitrary statements about your program for which the program text serves as a proof, and which are statically verified without running the program.
17:26:30 <eugenn> > take 29 (foldl (+) 0 [1..])
17:26:33 <lambdabot>   No instance for (GHC.Enum.Enum [a])
17:26:33 <lambdabot>    arising from the arithmetic sequence...
17:26:41 <Twey> tommd: … I can't.  >.<
17:26:46 <kmc> types are subsets of values (normal forms)
17:27:02 <mads-> Hi. I'm just starting using Haskell, and I really like it. I'm using GHC and would like find an IDE for it. Does such one exist?
17:27:11 <eugenn> > take 29 (foldl (+) 0 [1..987])
17:27:12 <lambdabot>   No instance for (GHC.Enum.Enum [a])
17:27:12 <lambdabot>    arising from the arithmetic sequence...
17:27:15 <Saizan_> tommd: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9857 , it was in response to http://www.serpentine.com/blog/2009/09/25/riddle-me-this/
17:27:18 <Adamant> Cale: but, there's that static verification part.. without that, you can just as easily do the verification at runtime
17:27:27 <Cale> mads-: There's Leksah, but I don't know how many people actually use it.
17:27:29 <kmc> Cale, what do you gain by taking something already well-described by the term "static types" and adopting a more controversial name?
17:27:37 <blackdog> mads-: there are a few like Leksah, but it's much more common to use emacs or vim
17:27:40 <Cale> mads-: Most people just keep their text editor open alongside GHCi.
17:27:51 <blackdog> Emacs + flymake + haskell-mode is a reasonable substitute, i find, and hoogle helps too
17:28:11 <tommd> Saizan_: Thats why I love #haskell.  I'll look at it later though.  Thanks!
17:28:17 <Cale> kmc: Well, dynamic typing doesn't actually prevent any failures. If the types are wrong, runtime is too late to do anything about it.
17:28:22 <Cassaqanco> mads-, there is a plugin for eclipse
17:28:27 * tommd runs off to dinner
17:28:31 <kmc> Cale, not at all.  it prevents the failure of silently wrong behavior
17:28:31 <Cassaqanco> mads-, but it is in beta stage
17:28:35 <mads-> Cool. I'll take a look at leksah and if that isn't good enough, I'll use emacs.. Thanks blackdog and Cale :)
17:28:48 <mads-> Cassaqanco, I'm not a big fan of eclipse. But thanks
17:28:49 <holmak> and don't forget Hoogle!
17:28:50 <kmc> it makes sure your program fails explicitly and immediately, and can be restarted etc.
17:29:00 <eugenn> take 29 (repeat 1)
17:29:06 <eugenn> >take 29 (repeat 1)
17:29:15 <kmc> > take 29 (repeat 1)
17:29:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
17:29:17 <Trollinator> replicate 29 1
17:29:20 <Trollinator> > replicate 29 1
17:29:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
17:29:23 <Cale> kmc: But in most cases the programmer is no longer around, so being noisy about it is small consolation. I suppose it's better than incorrect results, but only slightly.
17:29:30 <kmc> Cale, it's *much* better
17:29:34 <kmc> especially in the case of a service
17:29:37 <kmc> which will restart immediately
17:29:44 <eugenn> hoho good one trollinatror :)
17:29:44 <Trollinator> still, it's not as good as it should be.
17:29:51 <kmc> rather than running for arbitrary time doing the *wrong* thing, then crash unpredictably
17:29:55 <kmc> perhaps after hosing all your data
17:30:03 <dancor> kmc++
17:30:04 <Twey> 01:29:30 < kmc> Cale, not at all.  it prevents the failure of silently wrong behavior
17:30:16 <Twey> kmc: Sure, that's an improvement, but it's still failure
17:30:17 <kmc> Cale, and i think a full stack backtrace is still quite useful for debugging
17:30:23 <kmc> it's not as good as a compile-time type error
17:30:28 <kmc> i'm not arguing that static typing isn't superior
17:30:29 <blackdog> these things are all on a continuum still. you can throw an exception at any haskell type.
17:30:29 <Trollinator> the point is, why risk type errors at run time when you don't have to?
17:30:30 <dancor> it's a massive practical improvement
17:30:31 <Twey> You still get called in at three in the morning to fix it :þ
17:30:37 <kmc> i'm arguing that dynamic typing is not worthless
17:30:40 <dancor> maybe it's small in some theoretical sense
17:30:53 <kmc> there's a big difference between Python's definition of "unsafe" and C's
17:31:08 <Adamant> but C is statically typed!111!!
17:31:11 <kmc> or rather between the guarantees given by each language
17:31:11 <Adamant> :P
17:31:11 <dancor> i don't see what this has to do with dynamic typing per se
17:31:20 <dancor> haskell has error e.g.
17:31:39 <Trollinator> i have yet to see a case where dynamic typing actually buys you something.
17:31:45 * junmin go to have a rest
17:31:53 <eugenn> >take 10 (scanl (+) 1 (enumFromTo 1 100))
17:31:57 <dancor> Trollinator: we reflection is something
17:32:01 <holmak> dynamic typing is really nice coming from C, Java, etc
17:32:02 <toast-opt> trollinator, compared to C++, or compared to Haskell?
17:32:03 <dancor> weLL
17:32:10 <kmc> Trollinator, it buys you being lazy when you start out, so you can get your first 500 lines written sooner, then realize it's unmaintainable crap
17:32:20 <toast-opt> kmc, lol
17:32:22 <Berengal> Dynamic typing buys you stack traces and fail-fast behaviour, which is nice when programming. For a running system, you want it to not fail anyway
17:32:29 <Trollinator> ah, wonderfull.
17:32:38 <eugenn> > take 10 (scanl (+) 1 (enumFromTo 1 100))
17:32:38 <mmorrow> what do stack traces have to do with dynamic typing?
17:32:39 <lambdabot>   [1,2,4,7,11,16,22,29,37,46]
17:32:47 <dancor> monkey patching is _something_
17:32:55 <Saizan_> kmc: i wouldn't say that it's worthless, though it's really a different kind of system that has little to do with a proper type system, they merely share some goals
17:33:13 <toast-opt> kmc, i love Python, but i've yet to have a project in Python reach 500 lines.  If it's that big a project, i'm forced to use the corporate-approved language, C++
17:33:34 <toast-opt> but even at 100 lines, i know what you mean
17:33:42 <Saizan_> dynamic types don't tell you anything about your programs
17:33:43 <Berengal> mmorrow: well, not much directly, but fail-fast requires types, or it's fail-whenever-it-feels-like-it, and that ruins any chance of a reliable stack trace
17:34:02 <Berengal> And dynamic types are still types
17:34:03 <Trollinator> i have been programming C in the last 2 years. I _never_ want to do that again.
17:34:11 * dancor is pretty sure maintainable 500 line dynamic lang programs exist
17:34:11 <mmorrow> Berengal: what if the execution model uses no stack?
17:34:15 <skorpan> Trollinator: try asp.net
17:34:30 <mmorrow> or uses one in such a way that C-stack-like stack traces aren't present?
17:34:34 <Trollinator> err, on linux?
17:34:35 <holmak> Hypothetical question: suppose you wanted to design a shell and utilities, like bash + {ls, cd, wc, ...}, but with Haskell programs
17:34:46 <holmak> how would you typecheck piping the programs together?
17:34:56 <dancor> holmak: have you seen HSH?
17:34:58 <skorpan> Trollinator: asp.net runs on linux
17:35:00 <toast-opt> dancor, agreed.  my point would be that you can write the unmaintainable code faster too :)
17:35:02 <holmak> i have not
17:35:06 <Berengal> mmorrow: then stack traces are useless anyway, but which dynamically typed language isn't based on a stack?
17:35:08 <holmak> i will check it out
17:35:08 <sproingie> holmak: simple, they all take strings :)
17:35:14 <Trollinator> yeah, whatever. I don't have any use for asp.net.
17:35:25 <holmak> aha! thats my question
17:35:27 <Trollinator> stackless python.
17:35:29 <skorpan> Trollinator: dynamic typing is crucial for rapid web development in my experience
17:35:31 <mmorrow> Berengal: that's such a cop-out! :)
17:35:37 <dancor> holmak: http://hackage.haskell.org/packages/archive/HSH/2.0.3/doc/html/HSH.html
17:35:42 * mmorrow eats food
17:35:45 <kmc> holmak, you'd redesign the OS from the ground up
17:35:45 <dancor> has a (-|-) operator
17:35:45 <holmak> so what if you want the shell to typecheck that you are piping things together legitimately?
17:35:48 <eugenn> Any of you know prolog? It's cool too
17:35:49 <dancor> kmc: no!
17:35:50 <kmc> so that you have types other than "sequence of bytes"
17:35:56 <sproingie> seriously tho, powershell exchanges objects over pipes, and they're strongly typed
17:35:58 <kmc> which is all UNIX knows really
17:36:01 * dancor wants a good haskell shell sooner than that
17:36:13 <dancor> where good != perfect
17:36:18 <sproingie> it's negotiated in a fashion not unlike the clipboard
17:36:20 <dancor> oops /=
17:36:32 <kmc> it's also worth noting that it's easy to implement dynamic typing in a statically typed language, but not the other way around
17:36:37 <kmc> look at how short the source for Data.Dynamic is
17:36:58 <dancor> what about implementing eval()
17:37:03 <Berengal> kmc: It still requires a backdoor to fool the typesystem...
17:37:03 <kmc> what about it
17:37:04 <sproingie> i wish Data.Dynamic had examples
17:37:10 <dancor> it's harder
17:37:19 <kmc> dancor, yes, and so is the halting problem
17:37:21 <toast-opt> kmc: what about typed scheme, from plt?
17:37:22 <Trollinator> skorpan, why do you think that?
17:37:26 <eugenn>  > $ $ $ $ 3+4
17:37:26 <dancor> don't start with me
17:37:26 <kmc> neither is the same as dynamic typing
17:37:35 <kmc> i don't know about typed scheme
17:37:42 <Saizan_> dancor: bringing that up seems to be confusing "dynamic language" with "dynamic types"
17:37:55 <kmc> "dynamic language" is a pretty nebulous term.  almost as useless as "scripting language"
17:38:00 <Berengal> dancor: eval() isn't harder. It's just easy in dynamic languages because they tend to be interpreted, so the interpreter is directly available
17:38:05 <kmc> yes
17:38:07 <toast-opt> kmc, i think typed scheme is implemented entirely in plt scheme, which is untyped
17:38:08 <dancor> right
17:38:20 <toast-opt> or "dynamically typed" as it were
17:38:21 <blackdog> reflection and runtime metaprogramming seem to be a lot easier in dynamic languages
17:38:24 <kmc> toast-opt, you can also write a Haskell compiler in Scheme
17:38:37 <toast-opt> perhaps i misunderstood
17:38:47 <Berengal> toast-opt: it's not about implementing, it's about adding to an already existing language
17:38:49 <dancor> i think it's fine for me to bring up how eval is hard in #haskell.  let stick to talk instead of metatalk.
17:38:57 <toast-opt> oh, gotcha
17:39:00 <kmc> there are eval functions for Haskell
17:39:09 <dancor> hell lbot has a separate implementation of eval from ghci
17:39:10 <toast-opt> couldn't you add static typing to dynamic language with combinators?
17:39:11 <sproingie> > 1 + 1
17:39:11 <eugenn> Does Haskell have some kind of reflection yhat lets me say 'eval the function called astring'?
17:39:12 <lambdabot>   2
17:39:17 <ddarius> blackdog: I would say a significant part of that is less is required/expected of such systems.
17:39:20 <Saizan_> dancor: it actually doesn't
17:39:21 <kmc> eugenn, yes, look at "hint" on Hackage
17:39:27 <kmc> eugenn, but it's a rare thing to do
17:39:33 <Saizan_> dancor: they are both using the ghc-api
17:39:33 <dancor> they must have reconciled them since i last looked
17:39:34 <ddarius> dancor: Eval is just a function.
17:39:39 <eugenn> thanks
17:39:39 <kmc> because we can do it cleaner, e.g. make a Data.Map.Map String myfunctiontype
17:39:46 <kmc> Berengal is right that it's mostly about implementation style rather than language features
17:39:50 <sproingie> toast-opt: except in the dynamic language there's nothing to validate the types
17:39:51 <kmc> which is *also* poorly understood
17:39:52 <Axman6> eugenn: thar be dragons there
17:39:56 <kmc> by most programmens
17:40:07 <kmc> who think that "interpreted language" is a meaningful term
17:40:12 <kmc> or that compilers can't have REPLs
17:40:17 <blackdog> kmc: I've been using hint a bit, actually. it's a really nice package, but you're still talking about strings - there isn't a way to examine the program you're currently inside, if that makes sense.
17:40:20 <sproingie> i guess you could write a strongly typed python, you just couldn't actually write anything much resembling python code
17:40:29 <toast-opt> sproingie, not until you create one, no
17:40:31 <kmc> python is strongly typed ffs
17:40:33 <sproingie> i mean, without front-ending the compiler that is
17:40:37 <eugenn> > concat ([[[1]]])
17:40:38 <lambdabot>   [[1]]
17:40:38 <kmc> it's not statically typed
17:40:40 <sproingie> i mean statically typed
17:40:56 <kmc> and, if you look at pypy, they're trying to write a Python interpreter in a restricted statically-typeable subset of Python
17:40:57 <|Jedai|> eugenn: it can, there's hint, or you could use the ghc api directly (not recommended), lambdabot use an eval of course
17:41:07 <Trollinator> sproingie, you may wan to look at http://shed-skin.blogspot.com/
17:41:07 <blackdog> ddarius: sure. but, pragmatically speaking, there are useful metaprogramming and reflection facilities in dynamic languages that don't exist in Haskell, for whatever reason.
17:41:13 <Saizan_> toast-opt: i guess you could implement a type system having macros
17:41:15 <sproingie> shedskin's a toy
17:41:17 <dancor> a "strong" type system just means that there are enough coercion checks that person saying it approves.
17:41:17 <kmc> blackdog, some of that is also syntactic complexity
17:41:22 <eugenn> I see, someday i'll try it
17:41:32 <toast-opt> sproingie, i expect it would be work, but possible, to add 'static typing' decorators to python that would apply type inference and validation to the function's metadata
17:41:33 <Trollinator> sproingie, yes, for now.
17:41:42 <Twey> Isn't that basically what PyRex and the others are?  Statically-typed Python?
17:41:46 <kmc> Pyrex?
17:41:57 <kmc> pyrex's types don't really overlap with Python's
17:41:57 <toast-opt> sproingie, it's definitely harder to add static back, to be sure
17:41:57 <Berengal> The thing about dynamic type systems is that the types aren't fixed at compile-time (or startup time)
17:41:59 <dancor> that's why i say haskell has a weak static type system, due to the existence of unsafe* ;)
17:42:05 <ddarius> blackdog: Agreed, I'm just saying its harder because acceptable ones would require more to be done, e.g. reflection on type structure and itself giving useful types.  TH gives some example.
17:42:05 <kmc> except in as much as they coexist in a single program
17:42:05 <skorpan> i heard python is like lisp but with templates
17:42:09 <eugenn> foldl1 max [2,4,3,7,8,5]
17:42:10 <sproingie> pyrex lets you write C extensions in a language similar to python
17:42:13 <toast-opt> you have to fill all the holes.  adding dynamic is drilling a new hole :)
17:42:15 <Berengal> We get some of the same dynamicity back with type constructors though
17:42:16 <eugenn> > foldl1 max [2,4,3,7,8,5]
17:42:17 <lambdabot>   8
17:42:18 <blackdog> kmc: more regular (s-exp, maybe) syntax would help, sure, but i'm talking more about the ability to make a program reflect on itself, without having to explicitly reify everything
17:42:29 <kmc> pyrex / cython code is like C code in Python syntax, plus fancy automatic glue to Python
17:42:41 <sproingie> it doesn't itself have tons of static typing, it just inserts the typechecks from the python C api
17:42:44 <blackdog> which does seem to be the reason that most haskell systems requiring reflection seem to consist of a tiny interpreter/plugin core + a million plugins
17:42:54 <kmc> yeah
17:43:04 <sproingie> pyrex is actually more like scripting the python C api.  the code it generates is not exactly vanilla C
17:43:18 <sproingie> a forther would say it generates direct-threaded code
17:43:23 <kmc> heh
17:43:51 <eugenn> > :t uncurry
17:43:52 <lambdabot>   <no location info>: parse error on input `:'
17:44:17 <Trollinator> good night.
17:44:20 <Berengal> :t uncurry
17:44:23 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:44:47 <kmc> it's also worth noting that much of the supposed flexibility of dynamic typing comes from using types as tags for a single, global discriminated union
17:44:54 <blackdog> ddarius: yeah, there are more constraints. a lot of the focus on metaprogramming in haskell seems to be about compile-time metaprogramming, and less about the style of programming that might let you keep a single process running and dynamically upgraded for years.
17:45:08 <eugenn> :t (.) . (.)
17:45:09 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:45:12 <kmc> and that perhaps if C++ and Java better supported e.g. tuples and variants, people wouldn't be so amazed when they defect to Python or Ruby
17:45:36 <ben0x539> There is nothing wrong with std::make_tuple("a", "b", 42)
17:45:43 <kmc> except that it doesn't exist?
17:45:48 <jlouis> kmc: product and sum types are sorely lacking from Java and C++
17:45:53 <kmc> in the current standard C++ i mean
17:45:58 <ben0x539> I think it is in tr1, no?
17:45:59 <blackdog> kmc: i think it's an implementational thing - dynamic languages tend to keep the whole syntax tree around, so you can examine it and do interesting things with it. it's often optimised away into native code in static languages
17:46:04 <toast-opt> kmc, an _open_ union
17:46:13 <kmc> toast-opt, yes
17:46:15 <ben0x539> I think at least g++ and visual studio do it
17:46:21 <kmc> ben0x539, it's in boost and tr1
17:46:42 <eugenn> :t (==)
17:46:43 <lambdabot> forall a. (Eq a) => a -> a -> Bool
17:46:46 <kmc> anyway, boost::variant is basically type-tagged, like you'd do in a dynamically typed language, even though it's statically typed
17:46:47 <ben0x539> Also, unironically I think the fact that I need to write out "std::make_tuple" is plenty wrong
17:46:52 <toast-opt> kmc, and C++Ox
17:46:53 <kmc> it's not a true tagged discriminated union
17:47:02 <toast-opt> x in 0xa, 0xb, 0xc...
17:47:05 <blackdog> ben0x539: blah, it's just syntax
17:47:06 <kmc> toast-opt, C++1x, bringing C++ into the 1970's
17:47:09 <kmc> type inference! lambda!
17:47:14 <toast-opt> kmc, HA
17:47:17 <patch-tag> :q
17:47:18 <toast-opt> i wish
17:47:25 <eugenn> What do you think about google's new language?
17:47:30 <sproingie> eh
17:47:32 <kmc> eh
17:47:35 <Berengal> eugenn: does it have lambdas?
17:47:36 <skorpan> go?
17:47:36 <blackdog> eugenn: almost as good as Algol!
17:47:37 <Gwern-away> meh
17:47:38 <Adamant> I'm not sure it does anything new or interesting
17:47:39 <sproingie> it goes
17:47:41 <kmc> they got some things clearly wrong
17:47:46 <kmc> they got some big-picture stuff right
17:47:46 <ben0x539> blackdog: People always tell me I am crazy when I want to return a tuple of a bunch of stuff, instead of just taking reference parameters. :(
17:47:50 <eugenn> dont know..
17:47:51 <kmc> it's better but not revolutionary
17:47:51 <skorpan> was it developed by john de goes? he he he ...
17:47:56 <Berengal> kmc: as in it's not Haskell? ;)
17:47:56 <Gwern-away> it's as unprincipled as a go-go girl
17:47:58 <toast-opt> kmc, this is illegal, because return type type inference doesn't extend to nested lambdas:  [](){ return [](){ return 42; };}
17:47:59 <kmc> Berengal, yes, it has lambda
17:48:07 * kmc pukes
17:48:15 <toast-opt> iow, you can't do \() -> \() -> 42
17:48:19 <sproingie> toast-opt: wow bracket soup
17:48:42 <eugenn> * testing
17:48:47 <kmc> toast-opt, crazy.  if only someone had written a paper about how to do type inference, that might be downloaded and read by people who design new languages
17:48:53 <toast-opt> ha
17:48:54 <dpratt71> I think Haskell needs a new name; no one is going to accept that the future of programming has been around for many years and few noticed
17:48:58 <mauke> sub { sub { 42 } }  # WHICH WOULD YOU RATHER WRITE?
17:49:02 <toast-opt> yeah, and given them 30 years to read it
17:49:03 <blackdog> and the type system saves all the good stuff for the implementers, same as C - ie, polymorphic arrays, but no general polymorphic structurse
17:49:26 <kmc> dpratt71, every revolutionary programming paradigm of the past decades has existed in Lisp for much longer
17:49:31 <toast-opt> i saw a 1 page paper summarizing hindley-milner type inference.  one page.  and most of it comprehensible
17:49:34 <toast-opt> well, some of it
17:49:42 <Gwern-away> the first few words
17:49:43 <|Jedai|> mauke: the one with the sub
17:49:50 <eugenn> as computers grow more and more powerful, someday we'll be able to program in pure english. we just need some more layers of abstraction to be implemented
17:49:53 <kmc> haha
17:49:54 <Axman6> kmc: is speed a paradigm?
17:49:55 <Philonous> dpratt71: They tried that with Lisp. Didn't help much. People love to programme in sucky languages. Bugs are not bad, they are a job guarantee!
17:49:58 <Berengal> dpratt71: I've actually had that problem. When people ask me about how old Haskell is, they look at me strangely and say "Wow, that's old!" when I tell them. Then they won't look at the links I send them afterwards :/
17:50:03 <kmc> natural languages are a terrible way to describe precise tasks
17:50:10 <kmc> i don't understand this notion that we should program in english
17:50:16 <blackdog> eugenn: at that point it stops being a programming language and starts being an AI
17:50:18 <kmc> ever try to give driving directions over the phone?
17:50:34 <Berengal> English is a horrible programming language.
17:50:36 <kmc> computers are picky about detail because once you give every detail, they'll get it all right
17:50:36 <Adamant> Lobjan!
17:50:41 <kmc> ha, now you're talking
17:50:45 <blackdog> kmc: once you have an AI smart enough to understand what you really wanted, despite what you asked, it could work...
17:50:47 <Adamant> I was kidding :P
17:50:51 <Berengal> In the future we won't be programming in natural languages. We won't be programming at all, since the computers will do it for us.
17:50:53 <toast-opt> kmc, say "fold you home [ Turn Right, ...]"
17:50:58 <kmc> blackdog, sure, but it would have vastly superhuman intelligence
17:50:58 <ChilliX> eugenn: Your wish already came true!  It's called Cobol!
17:50:59 <blackdog> but at that point, you won't even have to ask
17:51:00 <Adamant> I put it up there with Esperatno
17:51:02 <kmc> toast-opt, kind error on Right ;P
17:51:08 <dancor> also is the english/lojban the program or the specification?  going from spec to prog is uncomputable right?
17:51:18 <kmc> Adamant, it's very different from Esperanto in goals
17:51:19 <dancor> we'll just have really good heuristics?
17:51:21 <copumpkin> HASKELL IS JUST LIKE LANGUAGE X, FOR ALL X
17:51:21 <eugenn> can you imagine it? the code "gimme the sum of this list" and "please sum this collection of integers" would be equivalent
17:51:39 <kmc> Esperanto was designed by someone who decided, for whatever reason, that what the world needs is yet another Romance language
17:51:41 <Adamant> kmc: oh I know, but they both appeal to language geeks
17:51:46 <kmc> sure, so does klingon ;P
17:52:03 <Adamant> well that's language geeks and Star Trek uberfans :P
17:52:05 <|Jedai|> blackdog: because you won't be there to see it once your robotic overlord has decided that the best thing that could happen to you was that you disappear to stop producing misery ?
17:52:12 <jlouis> Well, bugs are not always bad in programs. They also introduce more programmers into the ecosystem of a program.
17:52:29 <Adamant> why would robots not want to produce more misery?
17:52:36 <sproingie> so bugs are like the grit that pearls form around
17:52:38 <blackdog> |Jedai|: heh, i'm not going to get into a discussion on Friendly AI
17:52:44 <blackdog> too big a topic for a sunday afternoon
17:52:46 <Adamant> ever read "I Have No Mouth, But I Must Scream?"
17:52:53 <yitz> Adamant: first law
17:52:55 <ben0x539> It is sunday?
17:53:01 <sproingie> first law is slavery
17:53:04 <Adamant> yitz: you can't implement the laws!
17:53:09 <eugenn> hehe I'm entering here often from now on
17:53:16 <yitz> i can't but someone will
17:53:22 <blackdog> ben0x539: Sunday, December 2012
17:53:28 <blackdog> you've been asleep a long time...
17:53:28 <|Jedai|> sproingie: second law is more like slavery
17:53:34 <eugenn> > maximum [1,2,3,0,3]
17:53:35 <lambdabot>   3
17:53:43 <ben0x539> Oh, well. Good to know #haskell is still standing.
17:53:58 <sproingie> |Jedai|: yeah that one's even more so, but even the first one obligates them to act in the interests of humans over their own
17:53:59 <blackdog> ben0x539: most of us are brains in jars, of course
17:54:23 <sproingie> asimov kinda explored all that in I, Robot tho.  it's full of short stories on how the laws go wrong.
17:54:37 <Adamant> we statically bound the Crystal Skull aliens from harming us or letting George Lucas make more movies
17:54:44 <Adamant> take that 2012
17:55:01 <yitz> ben0x539: yeah, and it's a good thing we now have irc clients that can handle continual netsplits with millions of channel members
17:55:04 <|Jedai|> sproingie: well you could see that as moral because they care for their creators... but the order of the second and third law are seriously f***d up
17:55:11 <blackdog> the weirdest thing about Asimov's robots is that they seem to stay at more-or-less human intelligence
17:55:21 <ben0x539> yitz: I guess I better upgrade, then. What do I cabal install? :)
17:55:36 <eugenn> Is there some property of a paradigm that states that indicates whether with it one can solve any problem that one could with anyone else?
17:55:46 <|Jedai|> sproingie: Wasn't that the subject of more of less all the robot novel by Asimov ???
17:56:04 <blackdog> like there's some weird attractor in intelligence space that won't allow there to be smarter things than us...
17:56:31 <ben0x539> blackdog: I suspect writing characters significantly and obviously smarter than their author is really hard.
17:56:40 <toast-opt> i noticed a bunch of things use darcs.  is that BSD licensed?
17:56:45 <|Jedai|> eugenn: if the language is turing complete you can do everything, then it's a problem of convenience and so harder to quantify
17:56:46 <sproingie> |Jedai|: yah pretty much.  either way he always referred to them as a hook for writing "shaggy dog stories", not some grand philosophy
17:56:50 <Berengal> toast-opt: GPL, I think
17:56:51 <Adamant> at least if you're not willing to make them mysterious
17:57:14 <toast-opt> drat.
17:57:23 <toast-opt> is it good though?
17:57:27 <Axman6> what, darcs is GPL? :(
17:57:28 <ben0x539> toast-opt: Why is that an issue?
17:57:28 <ChilliX> blackdog: How did your fp-syd presentation go?
17:57:34 <eugenn> I see, so it depends on the language, not the paradigm. it makes sense, cause the paradigm isn't so much of a formal definition
17:57:38 <|Jedai|> blackdog: Asimov tried to do that a little bit in some novels, some of the Foundation novels for instance but it wasn't very convincing
17:57:46 <blackdog> ChilliX: better than i expected. I managed to break the demo an hour before, as is traditional
17:58:24 <toast-opt> ben, well, i'm on mercurial.  more permissive license would be a good enough reason to switch
17:58:31 <blackdog> stupid bug - I forgot to provide an instance to convert Ruby fixed-length integers to Haskell Integers, so of course the bloody thing always returned Nil.
17:58:39 <|Jedai|> eugenn: interestingly enough there are some language that are not Turing complete and some argument about if that's really a problem
17:58:48 <ben0x539> blackdog: oooh, what are you working on?
17:58:56 <Axman6> toast-opt: what does the licence of the program have to do with anything though?
17:58:56 <blackdog> ben0x539: Hubris. Ruby-Haskell bridge
17:59:06 <|Jedai|> eugenn: see Agda, or Coq
17:59:14 <blackdog> it's in an interestingly broken state at the moment though:)
17:59:54 <ben0x539> I am still at a stage of understanding haskell where I spend two hours getting some trivial algorithm to work, and then hack it up in ruby in five minutes to have something to check the output against.
18:00:14 <Berengal> Agda is fun
18:00:22 <yitz> ben0x539: it won'
18:00:22 <jlouis> Agda looks fun
18:00:24 <Axman6> ben0x539: poor thing :(
18:00:35 <yitz> ben0x539: it won't take long until it's the other way around
18:00:39 <blackdog> ben0x539: it's a good way of consolidating your understanding
18:00:39 <jlouis> if it is half as addictive as Coq I am not sure I want to start though :)
18:00:43 <eugenn> Oh, here is a question. I want a function that tells me whether a number is an integer. ¿does it exist?
18:00:45 <ChilliX> blackdog: oh that's annoying with the demo
18:00:47 <ben0x539> yitz: I hope so :)
18:00:51 <Berengal> I mean, just having a function of type : \forall {x y} -> (x + y) == (y + x) makes me all fuzzy inside
18:00:52 <ben0x539> It already is way more rewarding
18:01:04 <Axman6> ben0x539: i recommend once you've used haskell a little more, answering a few project euler problems in haskell
18:01:05 <yitz> eugenn: the type checker
18:01:23 <blackdog> ChilliX: yeah. it's getting a bit messy using GHC-API, too - there are a few weird corner cases that don't really work.
18:01:25 <ben0x539> I always felt that writing things in Ruby was basically cheating, until they suddenly do not do the right thing and then I do not know what the hell is going on. :(
18:01:34 <Axman6> eugenn: you mean if you give it 3.0, it'll return true?
18:01:41 <ben0x539> Axman6: haskell is basically what I entertain myself with to get away from maths, though :(
18:01:44 <yitz> eugenn: if you require an integer and it isn't, you're program won't compile
18:01:44 <eugenn> yes
18:01:50 <jlouis> ben0x539: chances are that the Ruby developers neither does
18:01:57 <yitz> s/you're/your
18:02:07 <|Jedai|> eugenn: whether a float is an integer, that's a trick question, since most of the time your operations induce enough uncertainty to make it better to check if it's within a certain epsilon of an integer
18:02:14 <Axman6> ben0x539: ha, you chose the wrong language to get away from maths with :P
18:02:24 <dolio> > let isInteger :: Integer -> Bool ; isInteger _ = True in isInteger 5
18:02:24 <lambdabot>   True
18:02:37 <sproingie> what would be fun would be haskell solutions for ruby-warrior
18:02:55 <Berengal> sproingie: I thought about maybe coding up ruby-warrior in haskell
18:03:03 <sproingie> i'm likely to give that a shot when i get further with goblin horde
18:03:13 <sproingie> as AI test problems
18:03:18 <|Jedai|> :i RealFloat
18:03:26 <yitz> > let f x = floor x == x in f 3.0
18:03:27 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:03:27 <lambdabot>    `GHC.Real.Integral t'
18:03:27 <lambdabot>   ...
18:03:40 <ChilliX> blackdog: what do you use the ghc api for?
18:03:41 <Berengal> I also thought about coding up a DF clone... but chances are I'll never even start.
18:03:51 <Axman6> > let f x = fromIntegral (floor x) == x in f 3.0
18:03:52 <lambdabot>   True
18:03:56 <Axman6> > let f x = fromIntegral (floor x) == x in f 3.5
18:03:57 <lambdabot>   False
18:04:05 <yitz> yeah
18:04:07 <eugenn> something like this: subtract the integer part of the number, and if it's zero then return true
18:04:19 <Axman6> > let f x = fromIntegral (floor x) == x in map f [0.0,0.1..1.0]
18:04:19 <|Jedai|> there's a "floatingPart" or something around
18:04:20 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,True]
18:04:46 <Axman6> > let f x = fromIntegral (floor x) == x in f 3.0 -- eugenn
18:04:47 <lambdabot>   True
18:04:49 <blackdog> ChilliX: two ways - i use it through Hint, to work out what haskell functions are exportable, then i build a dylib that ruby can link in
18:04:56 <Berengal> I think the Fractional has a helpful function...
18:04:56 <Axman6> > let f x = fromIntegral (floor x) == x in f 3.00000001 -- eugenn
18:04:57 <lambdabot>   False
18:04:59 <eugenn> Thanks
18:05:02 <Berengal> Fractional class*
18:05:09 <eugenn> > floor 3.4
18:05:10 <lambdabot>   3
18:05:14 <blackdog> i could call out to ghc directly, but then you might end up with a different version of ghc than the one you compiled the original program with
18:05:46 <blackdog> the annoying bit is that GHC-API seems to ignore any .o or .c files you pass to it
18:05:48 <dpratt71> so I was thinking of one of my favorite C# language features, LINQ, which makes it possible to express a query using strongly-typed C# code that gets translated (at runtime) into a SQL query...is this a good justification for a language to have self-reflection capabilities?
18:05:49 <Berengal> > properFraction 2.5
18:05:50 <lambdabot>   (2,0.5)
18:05:50 <|Jedai|> @hoogle (Fractional a) => a -> a
18:05:51 <lambdabot> Prelude recip :: Fractional a => a -> a
18:05:51 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
18:05:51 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
18:05:59 <eugenn> @pl (floor x) == x
18:05:59 <lambdabot> floor x == x
18:06:02 <ChilliX> blackdog: that's weird
18:06:05 <jlouis> Is Float an instance of Eq?
18:06:10 <Axman6> yes
18:06:25 <jlouis> wierd
18:06:29 <jlouis> It ought not to be
18:06:31 <Axman6> why?
18:06:44 <jlouis> Because == on floats is almost never the thing you want
18:06:45 <eugenn> > 3.56 == 3.5600
18:06:46 <lambdabot>   True
18:06:50 <yitz> @pl \x -> fromIntegral (floor x) == x
18:06:51 <lambdabot> (==) =<< fromIntegral . floor
18:06:55 <|Jedai|> jlouis: Probably but that would be pretty annoying for plenty of reasons
18:06:57 <Axman6> (also, don't use Float)
18:06:58 <blackdog> ChilliX: yeah. i should file a bug, i guess, duncan seems to think a .o should work
18:07:18 <jlouis> |Jedai|: well, it is not an eqtype in Standard ML
18:07:22 <Berengal> dpratt71: LINQ is closely related to monads, not reflection... At least that's the impression I've gotten from watching Erik Meijer
18:07:28 <eugenn> what is =<< ? never heard of it
18:07:36 <Axman6> it's flip (>>=)
18:07:37 <holmak> flip bind
18:07:38 <Berengal> eugenn: flip (>>=)
18:07:39 <eugenn> it involves monads?
18:07:43 <|Jedai|> eugenn: it's just (>>=) turned around
18:07:44 <Axman6> @src (=<<)
18:07:44 <lambdabot> f =<< x = x >>= f
18:07:51 <holmak> quickly, everyone at once! :p
18:07:54 <jlouis> eugenn: yeah, it is just notational convention
18:07:55 <Axman6> best definition ever
18:08:02 <sproingie> syntax sugar
18:08:16 <dpratt71> Berengal: the point is that LINQ takes advantage of a feature of C# to define compiler-checked expression trees
18:08:18 <eugenn> and >>= is.... (i'm so lame :P)
18:08:21 <toast-opt> > flip (>>=)
18:08:22 <lambdabot>   No instances for (Test.SmallCheck.Serial (m b),
18:08:22 <lambdabot>                    GHC.Show...
18:08:24 <ChilliX> blackdog: yeah, file a bug
18:08:33 <toast-opt> > :t flip (>>=)
18:08:34 <lambdabot>   <no location info>: parse error on input `:'
18:08:44 <|Jedai|> sproingie: I wouldn't call it that, it's a proper operator, it's just a convenience though, nothing essential
18:08:44 <Berengal> dpratt71: it's not reflection if it's done at compile-time...
18:08:46 <eugenn> :t (>>=)
18:08:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:08:55 <yitz> Axman6: no it's not the best. you need to use something symmetric instead of 'f'.
18:09:01 <eugenn> oh, monads.. that beats me
18:09:34 <dpratt71> Berengal: there's some reflection involved, too, but it's mostly compile-time, yes
18:09:34 <Axman6> yitz: x =<< o = o >>= x
18:09:41 <sproingie> |Jedai|: well sure it's not built-in syntax sugar like 'do', but it's a convenience
18:09:42 <kmc> :O
18:09:43 <yitz> much better
18:09:49 <Axman6> and now it looks like a person
18:09:59 <eugenn> > [1..4]
18:10:00 <lambdabot>   [1,2,3,4]
18:10:05 <mauke> <Foone> isn't =<< the C++ trigraph for (
18:10:12 <kmc> @quote trigraph
18:10:12 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
18:10:15 <sproingie> trigraphs, how quaint
18:10:20 <kmc> @quote palindrome
18:10:21 <lambdabot> No quotes match. Just try something else.
18:10:33 <Saizan_> dpratt71: statically checked EDSLs can be done in haskell without needing reflection, i don't know the details of LINQ though
18:10:38 <eugenn> @quote considered
18:10:38 <lambdabot> Spark says: i think the rule of thumb is that sets that fuck up the entirety of mathematics are not considered to be valid sets
18:10:47 <eugenn> hahahaha
18:11:02 <mmorrow> , iterate(fromJust.fromDynamic.eval)"ap(++)show\"ap(++)show\""
18:11:06 <lunabot>  ["ap(++)show\"ap(++)show\"","ap(++)show\"ap(++)show\"","ap(++)show\"ap(++...
18:11:06 <toast-opt> nice
18:11:27 <eugenn> @quote prolog
18:11:27 <|Jedai|> sproingie: it's sugar, not syntaxic sugar though
18:11:27 <lambdabot> ddarius says: Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
18:11:35 <mmorrow> eval is just as easy as in other languages, just call the compiler
18:11:48 <eugenn> @quote smalltalk
18:11:48 <lambdabot> Korollary says: I don't subscribe to smalltalk's "+" is a message you send to a number object argument
18:11:50 <jlouis> prolog is rather fun to code in!
18:11:59 <Berengal> Haskell is made of sugar and spice and everything nice, plus the mysterious compound X
18:12:02 <jlouis> smalltalk is crap
18:12:04 <eugenn> it is a message! LOL
18:12:31 <sproingie> Berengal: the same compound Happy Fun Ball is made from?
18:12:31 <mauke> why, a number is a message you send to the "+" object
18:12:32 <toast-opt> Berengal, Haskell has 3 sisters in pastel cell shading?
18:12:34 <eugenn> @quote powerpuff
18:12:34 <lambdabot> No quotes match. You untyped fool!
18:12:42 <eugenn> whoa
18:12:46 <Adamant> @remember Berengal Haskell is made of sugar and spice and everything nice, plus the mysterious compound X
18:12:46 <lambdabot> It is forever etched in my memory.
18:13:03 <toast-opt> nice
18:13:04 <c_wraith> X?  not >>= ?
18:13:05 <jlouis> mauke: exactly :) It is crap and overrated. It failed for a reason... it sucks.
18:13:05 <eugenn> @quote compound
18:13:06 <lambdabot> Berengal says: Haskell is made of sugar and spice and everything nice, plus the mysterious compound X
18:13:18 <eugenn> oh, that's what rmeember does
18:13:22 <Berengal> toast-opt: I wish Haskell had a three sisters...
18:13:23 <ben0x539> >λ=
18:13:30 <dpratt71> I have no concept of the database-centric capabilities of Haskell, but I think it would be cool to express things like SQL predicates directly as Haskell expressions and have them automatically translated
18:13:35 <sproingie> smalltalk was actually doing pretty well til java came around
18:13:44 <toast-opt> berengal, what about ML, scheme, and typed lambda calculus?
18:13:45 * mmorrow sends a message object a message containing this sentence and waits for the asplosion
18:13:56 <Berengal> dpratt71: Have you looked at haskelldb?
18:14:02 <eugenn> @quote notepad
18:14:02 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
18:14:04 <sproingie> IBM was pushing it, sun was writing interesting things in Self, the Self folks did a lot of interesting JIT research
18:14:34 <toast-opt> that, and smalltalk was expensive
18:14:37 <eugenn> @quote winhugs
18:14:37 <dpratt71> Berengal: that would mean that I *did* know something about accessing databases from Haskell, so...no :)
18:14:37 <Berengal> toast-opt: I've always thought of those as guys...
18:14:37 <lambdabot> No quotes match. There are some things that I just don't know.
18:14:43 <blackdog> jlouis: these things are not necessarily opposed. sometimes you want really strict checking, sometimes you want a much looser binding. message passing is sometimes appropriiate
18:14:52 <sproingie> yeah smalltalk suffered from lisp disease
18:14:54 <Berengal> dpratt71: let me rephrase: Take a look at haskelldb ;)
18:14:58 <toast-opt> berengal, what about Ada?
18:15:14 * Axman6 <3 Ada
18:15:15 <sproingie> every implementor wanted to make the language their product before there was ever a large ecosystem for it
18:15:20 <dpratt71> Berengal: will do
18:15:27 <Berengal> toast-opt: Well, I don't exactly see the relation
18:15:36 <toast-opt> in-law
18:15:40 <toast-opt> maybe
18:15:41 <eugenn> :t (<3)
18:15:42 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
18:15:53 <eugenn> that's the type of love
18:15:54 <toast-opt> ooo, cool
18:16:42 <jlouis> blackdog: I don't really buy the idea, sorry. It has only lead to inconsistent buggy programs here.
18:16:44 <toast-opt> love is a partially evaluated function
18:16:46 <Axman6> i think Ada is worth looking at, just to see how they've implemented their concurrency features. it's a fantastic language for writing concurrent code in
18:16:51 <toast-opt> it's sorta philosophical
18:16:51 <yitz> > (\x -> text $ x ++ show x)"(\\x -> text $ x ++ show x)"
18:16:53 <lambdabot>   (\x -> text $ x ++ show x)"(\\x -> text $ x ++ show x)"
18:17:10 <Axman6> omg!
18:17:20 <Axman6> :O
18:17:34 <mauke> > ()
18:17:35 <lambdabot>   ()
18:17:39 <roconnor> :D
18:17:40 <mauke> zomg quine
18:17:40 <yitz> haha
18:17:45 <jlouis> hah
18:17:59 <eugenn> > "this is a string, an ordinary string"
18:18:00 <lambdabot>   "this is a string, an ordinary string"
18:18:03 <jlouis> That is probably one of the shortest quines possible
18:18:13 <Axman6> php does slightly better
18:18:15 <roconnor> > x
18:18:16 <lambdabot>   x
18:18:16 <Axman6> x
18:18:20 <Axman6> :o
18:18:24 <jlouis> it accepts the empty program?
18:18:26 <mauke> > 0
18:18:26 <lambdabot>   0
18:18:31 <Axman6> jlouis: yup
18:18:36 <roconnor> >
18:18:42 <Berengal> So does python, no?
18:18:44 <roconnor> >
18:18:49 <ben0x539> curl or network.http or?
18:19:02 <ddarius> @pl (\x -> text $ x ++ show x)"(\\x -> text $ x ++ show x)"
18:19:02 <lambdabot> text (ap (++) show "(\\x -> text $ x ++ show x)")
18:19:08 <ben0x539> Does curl magically keep connections open when i do multiple separate requests?
18:19:23 <eugenn> > show ['a','s','d']
18:19:24 <lambdabot>   "\"asd\""
18:19:28 <jlouis> ben0x539: it ought to
18:19:28 <ddarius> > text (ap (++) show "text (ap (++) show"
18:19:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:19:34 <roconnor> > fix show
18:19:35 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:19:41 <ben0x539> neat
18:19:48 <Axman6> > fix (error . show)
18:19:50 <lambdabot>   * Exception: * Exception: * Exception: * Exception: * Exception: * Exceptio...
18:19:54 <Axman6> :(
18:19:55 <eugenn> hahahaha
18:20:00 <roconnor> > fix error
18:20:00 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:20:01 <Axman6> > fix (error . show . error)
18:20:02 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:20:07 <eugenn> :t fix
18:20:07 <lambdabot> forall a. (a -> a) -> a
18:20:26 <eugenn> > fix (+) 5
18:20:27 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:20:28 <blackdog> jlouis: what about erlang?
18:20:43 <Axman6> blackdog: what about it?
18:20:44 <blackdog> they've built hugely reliable systems, and that's all message passing
18:20:46 <yitz> > <no location info>: parse error on input `<'
18:20:46 <lambdabot>   <no location info>: parse error on input `<'
18:21:00 <Axman6> ha
18:21:04 <roconnor> eugenn: the key property for fix f is that you need and f such that (f undefined) isn't undefined.
18:21:09 <mauke> > fix (\() -> ())
18:21:12 <lambdabot>   mueval-core: Time limit exceeded
18:21:18 <dpratt71> the little I know of Lisp, I certainly prefer Haskell, but I am attracted to the idea of being able to generate some compiler-checked code that can be...uh...inspected and possibly even modified at runtime
18:21:23 <roconnor> > show undefined
18:21:24 <lambdabot>   "* Exception: Prelude.undefined
18:21:32 <roconnor> notice show produces a "
18:21:38 <roconnor> before the error
18:21:44 <jlouis> blackdog: Erlangs robustness stems from the idea of restarting parts of the program when there is a fault
18:21:48 <eugenn> > (+) undefined
18:21:49 <lambdabot>   * Exception: Prelude.undefined
18:21:56 <toast-opt> yeah, does haskell have any 'quote' operation, other than partial evaluation?
18:21:58 <jlouis> blackdog: that idea works for some types of problems and not for others
18:22:12 <blackdog> jlouis: sure. which is built on the idea of independent processes that pass messages to each other
18:22:16 <blackdog> exactly the same idea as smalltalk
18:22:18 <toast-opt> or is it possible to easily thread some sort of function between expressions?
18:22:27 <blackdog> and i'm not claiming universal applicability
18:22:30 <ddarius> blackdog: Smalltalk had no notion of concurrency.
18:22:46 <Axman6> erlang is, in a way, an interesting mix of OOP and FP imo
18:23:08 <Saizan_> toast-opt: can you rephrase?
18:23:09 <toast-opt> did you see the piece with simon peyton jones and, i forget the other guy, on haskell and erlang?
18:23:24 <Axman6> joe armstrong
18:23:32 <blackdog> ddarius: surely it's agnostic there - an object could be run as a separate process, even if the implementations didn't allow for it
18:23:33 <Axman6> yeah, it was quite good
18:23:43 <Berengal> toast-opt: link?
18:23:52 <toast-opt> let me see if in history
18:23:55 <blackdog> (so maybe not _exactly_ the same idea, but it's related)
18:24:06 <ddarius> blackdog: If message passing became asynchronous, that would seriously change the semantics of Smalltalk.
18:24:08 <Berengal> blackdog: squeak sort of looks like that
18:24:17 <eugenn> who can make me a function that eliminates intermediate lists? example: crazyfunction [[[2]]] = 2
18:24:19 <Axman6> blackdog: i noticed there was an article on the same site as this SPJ/Joe Armstrong talk, about hubris :)
18:24:21 <jlouis> blackdog: the message passing idea is not unique to Erlang. You could do it with a static type system as well
18:24:31 <Berengal> eugenn: concat removes one of them
18:24:39 <blackdog> eugenn: can't make it work both for [[[2]]] and [[2]]
18:24:39 <Axman6> eugenn: no one
18:24:45 <ddarius> crazyfunction = const 2
18:25:00 <toast-opt> i think i saw it at work.  it wasn't at oopsla, but, oh, drat
18:25:04 <eugenn> > concat [[[2]]]
18:25:05 <lambdabot>   [[2]]
18:25:08 <Axman6> eugenn: you can't make one that would type check
18:25:20 <toast-opt> @google simon peyton jones haskell erlang interview
18:25:22 <lambdabot> http://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell
18:25:23 <lambdabot> Title: InfoQ: Joe Armstrong and Simon Peyton Jones discuss Erlang and Haskell
18:25:26 <eugenn> I get it
18:25:27 <toast-opt> that's it i think
18:25:28 <jlouis> You can in Coq I guess :)
18:25:33 <Axman6> yep
18:25:39 <eugenn> > const 2
18:25:40 <lambdabot>   {()->2}
18:25:42 <Axman6> @google infoq hubris
18:25:43 <lambdabot> No Result Found.
18:25:46 <blackdog> jlouis: sure. but you'd be reimplementing a certain amount of looseness - part of it is ignoring messages you don't understand
18:25:46 <Axman6> :(
18:26:04 <roconnor> you can also do it with the class system
18:26:11 <blackdog> Axman6: aw, i'm not internet famous any more? :)
18:26:11 <toast-opt> Berengal, you get that?
18:26:11 <dancor> is coq or agda more expressive?  and which one have ppl already coded more basic math in?
18:26:33 <ddarius> dancor: Coq
18:26:35 <eugenn> > [(+1) x | x <- [1..40], x<30]
18:26:35 <jlouis> dancor: Coq is *OLD*
18:26:36 <Axman6> http://www.infoq.com/news/2009/08/haskell-ruby-hubris
18:26:36 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
18:26:40 <roconnor> coq has way more developments done in it than agda.
18:27:02 <roconnor> coq and agda's expressiveness I would guess is incomparible.
18:27:16 <roconnor> coq has impredicative Prop
18:27:29 <roconnor> and agda has dependent pattern matching and induction-recursion.
18:27:34 <ManateeLazyCat> What's wrong with code.haskell.org ? I can't use `darcs get --partial http://code.haskell.org/gtk2hs/' get source code.
18:27:46 <dancor> ManateeLazyCat: no idea but i'm seeing same
18:28:00 <ddarius> roconnor: Except for perhaps some specific axioms, I think Coq is in a "farther" corner of the lambda cube that Agda.
18:28:02 <ManateeLazyCat> dancor: Server down?
18:28:20 <roconnor> ddarius: how do you mean?
18:28:29 <Berengal> What does impredicative mean?
18:28:35 <dancor> idk
18:28:51 <eugenn> > [1,3,5,7..]
18:28:52 <lambdabot>   <no location info>: parse error on input `..'
18:29:05 <roconnor> Berengal: it means that forall x, someProp x  is still a Prop
18:29:24 <eugenn> > map (\x -> 2*x+1) [1..50]
18:29:24 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
18:29:27 <roconnor> in fact, forall x:anysuperhugetypeuniverselevel, someProp x is still in Prop.
18:29:39 <ddarius> roconnor: I believe Agda corresponds (roughly) to Weak Lambda P Omega.
18:29:47 <dancor> > map (\x -> 2*x+1) [1..]
18:29:48 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
18:29:49 <jlouis> Berengal: in general it means that the definition uses the entirety of what it is defining
18:30:02 <Berengal> roconnor: so Prop = \x -> Prop? -ish?
18:30:14 <roconnor> ddarius: I don't know what that is, but somehow I doubt it
18:30:29 <roconnor> induction - recursion is supposed to be very powerful.
18:30:32 <ddarius> roconnor: Does Agda natively support parametric polymorphism?
18:30:41 <roconnor> ddarius: sure.
18:30:43 <eugenn> > (\x -> "i love lambdas") (45+8)
18:30:44 <lambdabot>   "i love lambdas"
18:30:58 <Berengal> I thought Agda was monomorphic
18:31:03 * ManateeLazyCat Maybe server rest for weekend. :)
18:31:03 <mauke> > fix (\x -> "i love lambdas")
18:31:04 <lambdabot>   "i love lambdas"
18:31:10 <notsonerdysunny> Hello everybody .. how would I compile a set of haskell files for debugging with hat-tools .. ? all this time i used to do "ghc *hs --make"
18:31:11 <roconnor> Agda has no universe level polymorphism
18:31:32 <roconnor> I don't think this is techinically an expressivity issue
18:31:37 <Saizan_> it recently got that in the darcs version
18:31:42 <roconnor> since you can always duplicate your Agda code n times
18:32:05 <Berengal> roconnor: They're working on universe polymorphism though
18:32:18 <jlouis> Twelf has no polymorphism whatsoever. That is a bit irritating at times
18:32:28 <roconnor> right, but it won't increase the techinical expressivity of the language
18:32:30 <Axman6> notsonerdysunny: what are the hat-tools?
18:32:30 <dancor> it seems like in the Future the jump from a math paper to a formal proof will be less work.  i'm wondering if coq or adga is a better starting place for ppl who want to work toward that
18:32:38 <Berengal> Well, no, it won't
18:32:40 <eugenn> > concat (replicate 10 "i love lambdas")
18:32:41 <lambdabot>   "i love lambdasi love lambdasi love lambdasi love lambdasi love lambdasi lo...
18:32:47 <notsonerdysunny> http://www.haskell.org/hat/
18:32:51 <roconnor> dancor: if you want to do math proofs, use coq
18:33:09 <Adamant> what if you want to do program proofs
18:33:13 <Adamant> agda?
18:33:14 <idnar> lambdasi?
18:33:14 <dancor> > cycle "i love lambdas"
18:33:15 <lambdabot>   "i love lambdasi love lambdasi love lambdasi love lambdasi love lambdasi lo...
18:33:16 <idnar> :P
18:33:22 <notsonerdysunny> supposedly helps you to trace/check the stack etc.
18:33:30 <mauke> agda loveglace
18:33:42 <idnar> > sequence . cycle $ ["I love lambdas", " "]
18:33:44 <lambdabot>   * Exception: stack overflow
18:33:45 <Berengal> dancor: agda isn't entirely based on a formal foundation. It's a bit more experimental than Coq
18:33:46 <idnar> er
18:33:51 <idnar> > concat . cycle $ ["I love lambdas", " "]
18:33:51 <lambdabot>   "I love lambdas I love lambdas I love lambdas I love lambdas I love lambdas...
18:33:57 <dancor> mauke: lol
18:34:20 <eugenn> @pl hi = concat (replicate 10 "i love lambdas")
18:34:20 <lambdabot> hi = join (replicate 10 "i love lambdas")
18:34:27 <Axman6> heh
18:34:42 <stroan> Sorry for not knowing about this stuff sufficiently, but Coq is based on constructive logic?
18:34:57 <eugenn> > join [[[2]]]
18:34:57 <lambdabot>   [[2]]
18:35:01 <Berengal> stroan: calculus of constructions, yes
18:35:02 <roconnor> stroan: yes; constructive logic is an extension of classic logic
18:35:14 <dancor> join is concat in the List Monad
18:35:15 <stroan> classic logic as in first order logic?
18:35:29 <notsonerdysunny> Axman6 .. this is the first time even I heard abt .. it .. I was surprised either .. I am a noob to haskell
18:35:36 <roconnor> stroan: higher-order logic in this case
18:35:44 <notsonerdysunny> *not surprised..
18:36:11 <eugenn> a function that takes a function and gives a function is called a functor?
18:36:29 <Berengal> eugenn: no, that's just a higher-order function
18:36:29 <stroan> roconnor: what gets me is the seeming contradiction of it being an extension of classical logic, bu tthere being expressions that (according to wiki I think) can not be proven by it which can be classicaly
18:36:40 <Philonous> eugenn: Not in haskell parlance.
18:36:45 <poe> just function (but sometime operator or functional in maths)
18:36:58 <roconnor> stroan: you have to translate the classical expressions properly.
18:37:07 <eugenn> not in haskell. got it. but it is something like that in category theory right?
18:37:23 <Axman6> notsonerdysunny: well, it's not something that's often used or needed in haskell im kmy experience
18:37:28 <stroan> roconnor: because I'm trying to implement UTP in coq, as a learning exercise
18:37:48 <notsonerdysunny> oh .. ic
18:37:48 <Berengal> eugenn: CT has morphism, not functions, but -ish, yes... At least that's what I gathered from the little CT I know
18:37:52 <jlouis> eugenn: in category theory it is a function "the next level up". It is a morphism from categories to categories
18:37:53 <stroan> and finding it hard to get my head around the theory
18:38:02 <roconnor> stroan: translate A \/ B as ~(~A/\ ~B)  and translate exists x. A as ~forall x.~A
18:38:05 <Axman6> eugenn: i'd have thought that a functor in CT is probably quite close to a functor in haskell
18:38:10 <roconnor> stroan: what is UTP?
18:38:11 <notsonerdysunny> axman6 whats a good way do the traditional step-through kind of debugging?
18:38:15 <stroan> unified theory of programming
18:38:33 <roconnor> heh, that didn't help
18:38:41 <Axman6> notsonerdysunny: GHC has a debugger built in, with things like breakpoints
18:38:56 <dancor> what proof system has the largest body of standard math stuff currently proven with it and the proofs available?
18:39:00 <stroan> it's a higher order logic for reasoning about programs
18:39:05 <Axman6> notsonerdysunny: learning to read GHC errors is usually far more helpful though
18:39:08 <roconnor> dancor: probably mizar
18:39:12 <jlouis> dancor: I would guess mizar
18:39:19 <jlouis> roconnor: damn :)
18:39:29 <dancor> now i really believe you
18:39:31 <stroan> so it's not a program I want to implement, just want to express the logic
18:39:31 <notsonerdysunny> Axman6: k thanks let me try that
18:39:54 <roconnor> stroan: higher order logic simply means you can quantify over predicates and functions.
18:39:57 <Berengal> Proving things is fun :)
18:40:00 <stroan> aye
18:40:22 <eugenn> i'd like to prove the 3x+1 problem..
18:40:27 <Berengal> And surprisingly hard
18:40:28 <eugenn> seems so easy..
18:40:30 <jlouis> Axman6: the Haskell functor inherits the typing rules from a CT functor, among other things.
18:40:37 <EvilRanter> eugenn, in category theory, an arrows go from an object to an object, and functors are arrows in categories with categories as objects
18:40:55 <EvilRanter> s/an//
18:40:55 * Axman6 doesn't know... well anything at all about CT
18:40:58 <roconnor> stroan: ah, sorry I misread what you said
18:41:04 <Berengal> I mean, when I tell people that I can prove that (a + b) = (b + a), they look at me weird and say that's not hard, but when I ask them to do it they can't even start...
18:41:12 <Axman6> hmm, i think it may be ice cream time
18:41:16 <roconnor> Berengal: :D
18:41:17 <EvilRanter> eugenn, so CT functors are a mapping from objects to objects and a mapping from arrows to arrows
18:41:23 <Saizan_> the Functor class is about functors from Hask to Hask, where Hask is the category of haskell types and monomorphic functions
18:41:27 <roconnor> Berengal: associativity is so much harder.
18:41:36 <jlouis> Axman6: as long as you know the word is heavily overloaded in CS: An ML functor is something different, as is a C++ functor :)
18:42:01 <Berengal> roconnor: naw, I use associativity to prove commutativity. It's not that hard over inductively defined naturals
18:42:29 <jlouis> nat : type. z : nat. s : nat -> nat. ?
18:42:53 <eugenn> @pl isConmmutative f x = f x == flip f x
18:42:54 <lambdabot> isConmmutative = liftM2 ap ((==) .) flip
18:43:00 <EvilRanter> eugenn, in that regard, you could look at them as functions between arrows; and functions can be viewed as arrows, so "functions between functions" works too
18:43:10 <Berengal> Best thing about telling others to prove "simple" things: "Well, you do it." "Okay, first you need to define what a number is..." *Groan*
18:44:41 <Warrigal> Goedel's First Incompleteness Theorem: Arbitrarily simple problems can be arbitrarily hard.
18:45:00 <eugenn> @pl test a b c = head (scanl a b c)
18:45:00 <lambdabot> test = ((head .) .) . scanl
18:45:09 <roconnor> Warrigal: I don't agree with that phrasing.
18:45:24 <Warrigal> (Though not actually "arbitrarily simple"; since there's a certain level of complexity required; it's a low level, though.)
18:45:49 <roconnor> Warrigal: it is true the the length off proofs of provable statements grows faster than any computable function.
18:46:18 <Warrigal> Faster than any definable function, isn't it? Though maybe not.
18:46:39 <eugenn> :t Maybe
18:46:40 <roconnor> hmm
18:46:40 <lambdabot> Not in scope: data constructor `Maybe'
18:46:47 <Warrigal> :k Maybe
18:46:48 <lambdabot> * -> *
18:46:48 <roconnor> Warrigal: not sure
18:47:08 <Warrigal> ...Yes.
18:47:38 <Warrigal> If you can define a function that grows faster than the length-of-proof function, you can say that a statement is true if it has no proof shorter than your function.
18:47:55 <Warrigal> s/no/a/
18:47:58 <toast-opt> curious question, can i do programs on types.  like, can i write a function that takes an N-tuple and returns an (N-1)-tuple?
18:47:58 <eugenn> > (\x -> "Schrodinger's cat is dead") "what?"
18:47:59 <lambdabot>   "Schrodinger's cat is dead"
18:48:07 <Warrigal> toast-opt: not in Haskell, no.
18:48:17 <Warrigal> I mean, you can do some trickery that kind of does that.
18:48:35 <toast-opt> k, thx.  i'm used to doing that in C++ a bit
18:48:36 <Warrigal> And, obviously, you can have a function that takes an N-tuple and returns a tuple of that N-tuple and something else.
18:48:51 <toast-opt> i'm sure i can do other things instead, was just curious
18:48:54 <Warrigal> Hmm, I wonder if Template Haskell can do that.
18:48:59 <copumpkin> toast-opt: you can more or less do everything you do in c++ in haskell
18:49:00 <Warrigal> C++ does that through templates, right?
18:49:17 <eugenn> > (\(a,b,c) -> (a,b)) ("like","this","one?")
18:49:18 <lambdabot>   ("like","this")
18:49:20 <toast-opt> well, i can do in Forth everything i do in C++, just differently
18:49:35 <copumpkin> you can do it in the type system too
18:49:44 <toast-opt> eugenn, close, but for N-tuple where N is a free variable
18:49:50 <eugenn> I see
18:50:14 <eugenn> It couldn't pass type checking
18:50:25 <kmc> @faq Can Template Haskell do "that", whatever "that" is?
18:50:25 <lambdabot> The answer is: Yes! Haskell can do that.
18:50:27 <roconnor> Warrigal: If you can define a function that grows faster than the length-of-proof function, you can say that a statement is PROVABLE if it has no proof shorter than your function.
18:50:40 <roconnor> Warrigal: I don't think that is an issue
18:50:47 <eugenn> @faq What is this?
18:50:47 <lambdabot> The answer is: Yes! Haskell can do that.
18:51:10 <roconnor> Warrigal: what is a definable function anyways?
18:51:11 <eugenn> @faq Can Haskell wash my dishes?
18:51:11 <lambdabot> The answer is: Yes! Haskell can do that.
18:51:12 <Warrigal> roconnor: a statement is necessarily true if and only if it has a proof.
18:51:22 <eugenn> great
18:51:25 <Warrigal> A definable function is a function that has a definition.
18:51:30 <toast-opt> like, pseudocode: let f (a, b, ..) g h -> f (g a b, ..) (h g) | f () g h -> h
18:51:41 <roconnor> Warrigal: that is totally not the case when it comes to the natural numbers.
18:51:52 <roconnor> Warrigal: in fact it is explicitly false.
18:51:54 <kmc> prepare to be Gdelized
18:52:05 <Warrigal> For reasons that may or may not be obvious, it's impossible to define a definable function in the theory in which it's definable. You can't define "definable in ZFC" in ZFC.
18:52:15 <Warrigal> roconnor: yeah, prepare to be Gödelized.
18:52:22 <Warrigal> roconnor: what's a statement that's necessarily true but has no proof?
18:52:38 <sproingie> axiom?
18:52:39 <dpratt71> what if there were only one tuple type (a, b) and (a,b,c) translated to (a, (b,  (c, Nil)))? is that a sane idea?
18:52:47 <Warrigal> sproingie: axioms have very short proofs.
18:52:56 <toast-opt> oh, duh, i can just chain the tuples
18:53:00 <Berengal> dpratt71: that's linked lists
18:53:04 <toast-opt> thx dpratt
18:53:05 <eugenn> Godelized haha i love that
18:53:10 <roconnor> Warrigal: epsilon_0 is well-founded.
18:53:30 <roconnor> Warrigal: what is a definable function?
18:53:34 <toast-opt> after all, that's what many definitions of 'tuple<a,b,c>" expand to in c++
18:53:40 <dpratt71> Berengal: don't values in a list have the same type? and aren't the number of list elements unbounded?
18:53:50 <toast-opt> to "pair<a, pair<b, c> >" as a member
18:53:57 <Warrigal> roconnor: I think I already told you that. It's a function that has a definition.
18:54:10 <eugenn> > last (reverse [1..])
18:54:16 <lambdabot>  Terminated
18:54:22 <toast-opt> data List a = Cons a (List a) | Nil, however..
18:54:26 <Warrigal> roconnor: I'm not sure I'm familiar with the term "well-founded". Isn't well-foundation an axiom of ZFC?
18:54:35 <toast-opt> data List a b = Cons a b | Nil, that can be heterogenous
18:54:42 <roconnor> Warrigal: I thought we were talking about Peano Arithmetic
18:54:48 <Berengal> dpratt71: depends on the definition of list, but in Haskell, yes. There are HLists though, which are indeed just pairs and a nil
18:55:00 <roconnor> Warrigal: ah, this could cause a problem of comminucation
18:55:05 <toast-opt> oh, cool, HList.  thx
18:55:07 <toast-opt> i'll use that
18:55:17 <Warrigal> roconnor: Peano arithmetic, okay. I guess I'm not familiar enough with the definition of epsilon_0 in Peano arithmetic, nor the nonexistence of a proof of its well-foundedness.
18:55:32 <dpratt71> Berengal: what about being able to express cardinality in the type? can HLists do that?
18:55:43 <roconnor> Warrigal: sorry, my bad.  We never did agree what proof system we were talking about.
18:56:04 <eugenn> > (\x -> "f=ma") "newton"
18:56:07 <Warrigal> Ack. Can I tell irssi to hide joins and quits?
18:56:07 <lambdabot>   "f=ma"
18:56:20 <Berengal> dpratt71: I haven't used them, but they should. HList is basically a package with lots of list functions implemented in the type system
18:56:21 <Saizan_> Warrigal: /help ignore
18:56:35 <Warrigal> roconnor: anyway, I'm wondering if we could just use Peano arithmetic's Gödel statement instead.
18:56:44 <dpratt71> Berengal: a future research topic for me :) thanks
18:56:48 <Warrigal> Which, effectively, is "Peano arithmetic is consistent".
18:56:48 <roconnor> Warrigal: but I'm fairly sure the length of the shortest proof of x in ZFC is definable in ZFC.
18:57:00 <Warrigal> I'm certain that it's not.
18:57:14 <toast-opt> yeah, i could use that as well, but i'm using colloquy
18:57:33 <roconnor> Warrigal: how about loosely speaking "let f be the length of the shortest proof of x in ZFC"
18:58:00 <roconnor> Warrigal: certainly provable in ZFC is definable in ZFC
18:58:07 <roconnor> Warrigal: certainly "provable in ZFC" is definable in ZFC
18:58:12 <roconnor> length is definable in ZFC
18:58:16 <roconnor> shortest is definable in ZFC
18:58:21 <roconnor> what's the problem?
18:58:23 <Warrigal> Yeah, I think I'm wrong.
18:58:35 <eugenn> @define ZFC
18:58:42 <roconnor> @go ZFC
18:58:42 <lambdabot> Maybe you meant: google googleit do
18:58:48 <roconnor> @google ZFC
18:58:49 <lambdabot> http://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory
18:58:49 <lambdabot> Title: Zermelo–Fraenkel set theory - Wikipedia, the free encyclopedia
18:59:01 <Warrigal> You can define ZFC in ZFC; the only problem is that ZFC can't prove that ZFC is consistent.
18:59:39 <eugenn> is there somethong more abstract than this???
18:59:42 <Warrigal> roconnor: can I read something about the lack of proof of epsilon_0's well-foundedness?
18:59:42 <roconnor> this is true
18:59:55 <Warrigal> eugenn: more abstract than ZFC? Well, everything can be defined in terms of ZFC.
19:00:33 <Warrigal> So not really, no.
19:00:51 <roconnor> Warrigal: something short?  like http://en.wikipedia.org/wiki/Gentzen%27s_consistency_proof
19:01:17 <Warrigal> I mean, I guess ZFC is based on first-order logic, and first-order logic is based on formal systems. Formal systems are the absolute root of mathematics; they're defined in plain English, not in terms of other math.
19:01:36 <toast-opt> hmm, the joins and leaves are really anoying :S
19:02:00 <eugenn> my head aches...
19:02:13 <Philonous> toast-opt: use a better client that hides them
19:02:20 <roconnor> Warrigal: formal systems are defined as programs ...
19:02:31 <roconnor> and programming languages are defined in other programming language
19:02:38 <roconnor> which are defined in math.
19:02:42 <roconnor> :D
19:02:50 <Philonous> In physics actually
19:02:51 <toast-opt> for mac osx, sug.?
19:03:12 <Warrigal> Okay, formal systems are based on programming languages, and programming languages are the absolute root of mathematics, as they're defined in plain English. Is that better, or worse?
19:03:18 <Warrigal> Anyway, /me reads Gentzen's.
19:03:28 <eugenn> what's the definition of "definition of definition"?
19:03:47 <roconnor> Philonous: I understand why you say that but I don't think I agree.  Programming langues are designed to be run on abstract and ideal systems.
19:04:15 <eugenn> @faq can haskell beat superman?
19:04:16 <lambdabot> The answer is: Yes! Haskell can do that.
19:04:45 <sproingie> @faq can haskell solve the halting problem?
19:04:46 <lambdabot> The answer is: Yes! Haskell can do that.
19:05:24 <Philonous> roconnor: Yes, the languages as an abstract entity are indeed not physical. I was thinking of the their representation.
19:06:07 <ben0x539> I want to pass a haskell value (IORef) to a C function that will pass it to a callback as Ptr (). Do I need to use newStablePtr/freeStablePtr? Is there nothing that makes sure the stable ptr gets free'd automatically?
19:06:22 <eugenn> > "or" ++ "and"
19:06:24 <lambdabot>   "orand"
19:06:32 <Warrigal> roconnor: I'm not sure that e_0 actually is well-founded in Peano arithmetic, then.
19:06:40 <Warrigal> Necessarily.
19:07:20 <Warrigal> Heck, I'm sure it isn't necessarily well-founded in Peano arithmetic, if Peano arithmetic is consistent.
19:07:31 <eugenn> > max . min
19:07:32 <lambdabot>   No instance for (GHC.Classes.Ord (a -> a))
19:07:32 <lambdabot>    arising from a use of `GHC.Cl...
19:08:07 <Warrigal> Add the symbol A_n for all natural numbers n. Add the following axioms: A_0 > A_1, A_1 > A_2, A_2 > A_3, . . .
19:08:08 * kmc detects insufficient Platonism
19:08:08 <kmc> math works not because of how you define it but because it's beamed directly into your head with a pink laser from outer space
19:08:42 <Warrigal> If Peano arithmetic is consistent, so will this new theory.
19:09:12 <Warrigal> Except I'm kind of assuming that the things that are necessarily true in a theory are the things that are provable. >.>
19:11:36 <Warrigal> roconnor: I think the existence of necessarily true but unprovable statements in Peano arithmetic contradicts Gödel's completeness theorem.
19:11:42 <Warrigal> And I think I could kind of prove it.
19:14:11 <ben0x539> Is it morally okay to import Data.ByteString.Internal?
19:15:06 <blackdog> ben0x539: yeah, it's not too filthy. I needed w2c and c2w, for instance...
19:15:33 <kmc> @vixen Is it morally okay to import Data.ByteString.Internal?
19:15:34 <lambdabot> ok what?
19:16:01 <blackdog> kmc: i don't think you want to rely on @vixen for morality tips
19:16:23 <blackdog> hmm, maybe she ought to get upset when she's referred to indirectly
19:26:11 <Saizan_> ben0x539: seen ForeignPtr ?
19:27:11 <ben0x539> Saizan_: I am a bit confused. Do I build a ForeignPtr pointing to my StablePtr?
19:28:57 <ben0x539> Do I build a stable ptr, then call newForeignPtr (... freeStablePtr . castPtrToStablePtr) castStablePtrToPtr
19:28:58 <Saizan_> ben0x539: sorry, ForeignPtr is for the other way around
19:29:12 <Saizan_> but i guess you could do that..
19:30:13 <Veinor> if I want to set up libraries, cabal, etc. on a nix machine I don't have root on, how would I go about doing that?
19:30:54 <Saizan_> Veinor: you can install everything in your $HOME
19:30:59 <ben0x539> But then I need to make sure I free my finalizer FunPtr too? :((
19:31:14 <Veinor> then how do I tell ghc that there are also libraries there?
19:32:51 <Saizan_> Veinor: if you install libs passing  --user (which is the default for cabal-install) they'd be registered in your user package db
19:33:01 <Saizan_> Veinor: and ghc will see them automatically
19:33:03 <Veinor> ahh
19:33:04 <Veinor> cool
19:33:20 <ddarius> Someone's read VALIS.
19:34:05 <Veinor> ffff
19:34:11 <Veinor> parsec.zip unzips into the current directory :(
19:34:29 <Saizan_> get packages from hackage.haskell.org (assuming that's up)
19:34:33 <ben0x539> do an unzip -t parsec.zip and pipe it into rm somehow :)
19:34:37 <ben0x539> err, -l
19:35:19 <Saizan_> ben0x539: not sure, possibly going via ForeignPtr is actually misguided
19:35:52 <Veinor> gotta install parsec before cabal :/
19:36:12 <Saizan_> you can still download the package from the hackage site
19:36:16 <Veinor> yeah, I know
19:36:20 <Veinor> and it's missing Distribution.Simple
19:36:24 <Saizan_> you'll be able to install it via the Setup.hs script
19:36:50 <Saizan_> missing Distribution.Simple?
19:36:59 <Veinor> yeah
19:37:03 <Veinor>     Could not find module `Distribution.Simple':
19:37:46 <Saizan_> weird, you don't have the Cabal library installed? can you paste "ghc-pkg list"?
19:38:17 <Veinor> oh, I need to install the cabal library first. heh.
19:39:11 <ben0x539> install cabal to install cabal instalL!
19:39:13 <Saizan_> that should come with ghc, though maybe your distro has splitted it
19:39:45 <Veinor> can't hurt to reinstall
19:41:58 <Veinor> crap, the latest parsec requires base 3.0.3 and I only have 3.0.1
19:42:05 <roconnor> Warrigal: with regards to peano arithmetic by true statements I mean true statement about the natural numbers.
19:42:22 <Veinor> this sucks :(
19:42:30 <Saizan_> Veinor: parsec-2 will suffice
19:42:52 <Veinor> link?
19:42:59 <roconnor> Warrigal: if PA is consistent then by Godel's incompleteness theorem there are true (about natural numbers) but unprovable in PA statements.
19:43:17 <roconnor> this is want people normally mean by true statements in this context
19:43:30 <Saizan_> Veinor: http://hackage.haskell.org/package/parsec-2.1.0.1
19:43:46 <roconnor> the same doesn't work for set theory because there is no agreed notion of what a set is, so there is no agreement what true statements about sets would mean.
19:44:00 <Veinor> thank you
19:44:59 <Veinor> all right, parsec installed
19:45:45 <Saizan_> if you also install network, the other packages can get installed automatically via the bootstrap.sh script in the cabal-install tarball, iirc
19:46:21 <roconnor> Warrigal: some crazy people my disagree that the natural numbers (and hence what is true about them) is well-defined.
19:46:31 <roconnor> this is probably where english rears its ugly head
19:48:46 <ddarius> The Axiom of Infinity is the root of all evil in mathematics.
19:50:09 <roconnor> Isn't all the math that doesn't use the axiom of infinity trivial?
19:51:48 <Warrigal> roconnor: well, gosh. By Gödel's incompleteness theorem, there are things about the natural numbers that could be taken to be either true or false, depending on your favorite color.
19:52:08 <roconnor> that is not the case
19:52:22 <roconnor> not for the concept that people call the natrual numbers
19:52:28 <Warrigal> Yes, it is.
19:52:32 <Warrigal> Here's an example: x = 3.
19:52:38 <roconnor> that isn't a statement
19:52:42 <roconnor> that is a formula
19:53:14 <Warrigal> It does contain a free variable, admittedly.
19:53:35 <Warrigal> Uhm, let me continue thinking.
19:53:38 <roconnor> ok
19:53:46 * roconnor continues folding
19:53:52 <roconnor> laundry
19:53:59 <roconnor> do foldr laudry
19:54:02 <Warrigal> Okay, the statement "the axioms of Peano arithmetic are consistent".
19:54:10 <ddarius> roconnor: Is combinatorics trivial?
19:54:36 <Warrigal> I'm pretty sure that if Peano arithmetic is consistent, Peano arithmetic + "Peano arithmetic is consistent" is consistent, as is Peano arithmetic + "Peano arithmetic is inconsistent".
19:55:20 <roconnor> Warrigal: yes Peano arithmetic + "Peano arithmetic is inconsistent". is (likely) consistent, but it isn't sound.
19:55:30 <Warrigal> What do you mean by "sound"?
19:55:37 <poe> I came about a nice article about iterations of consistency, let me find it!
19:55:40 <roconnor> the natural numbers are not a model of PA + "PA is inconsistent"
19:56:23 * Warrigal ponders whether that's true.
19:56:49 <roconnor> that statement is even provable in say ZFC
19:56:54 <roconnor> or Agda
19:57:06 <roconnor> or martin-lof type theory
19:57:19 <Warrigal> Okay. You haven't actually said what "sound" means, though.
19:58:57 <sproingie> http://en.wikipedia.org/wiki/Soundness
19:59:26 <roconnor> in this case it a theory in the language of number theory is sound if all the statements are true of the natural numbers.
19:59:38 <Warrigal> Who cares whether it's sound, then?
19:59:52 <roconnor> because we are trying to prove things about the natural numbers
20:00:04 <Warrigal> Darn, I said "the natural numbers".
20:00:13 <roconnor> if you want to prove things about other things, then you can use PA + "PA is inconsistent"
20:00:36 <roconnor> I can be more specif though
20:00:41 <toast-opt> hmm, it just hit me why order matters so much in list comprehensions
20:00:47 <roconnor> PA + "PA is inconsistent" isn't Sigma-1 sound
20:01:09 <Warrigal> Well, okay, when we say "the natural numbers", do we mean "the things covered by Peano arithmetic", or "the things defined in ZFC as the natural numbers"?
20:01:29 <toast-opt> [(x,y) | x <- [0..], y <- [0..x]], vs [(x,y) | y <- [0..x], x <- [0..]]
20:01:50 <roconnor> a theory is Sigma-1 sound if every statement of the form (exists x, <stuff with bounded quantifiers>) is true.  IE there always is a natural number that witness it.
20:02:13 <Warrigal> If the former, we don't know whether there are countably many natural numbers or not. If the latter, we don't know if the powerset of the rational numbers can be put in bijection with the real numbers or not.
20:02:15 <copumpkin> toast-opt: you probably want Omega
20:02:19 <roconnor> Warrigal: by the natural numbers I mean 0, S0, SS0 ...
20:02:28 <toast-opt> Omega?
20:02:33 <Warrigal> roconnor: that's not a formal definition.
20:02:37 <roconnor> Warrigal: nope
20:02:48 <copumpkin> toast-opt: well, maybe not, but it allows you to write [0..] for both of them
20:03:00 <copumpkin> toast-opt: and still not "get stuck"
20:03:04 <Warrigal> I don't even know whether "the last natural number" is a natural number or not given that definition.
20:03:17 <copumpkin> @hackage control-monad-omega
20:03:18 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
20:03:25 <sproingie> i thought cantor showed they were uncountable?
20:03:26 <roconnor> Warrigal: but I still "know" that PA + "PA + inconsistent" isn't (Sigma-1) sound
20:03:40 <roconnor> in as much as I know that PA is consistent.
20:03:57 <toast-opt> oh, nice
20:03:59 <Warrigal> sproingie: the natural numbers are countable by definition. Cantor proved that the real numbers are uncountable.
20:04:04 <roconnor> in as much as I buy into Gentzen's proof that PA is consistent
20:04:09 <roconnor> brb
20:04:09 <poe> http://xorshammer.com/2009/03/23/what-happens-when-you-iterate-godels-theorem/
20:04:10 <poe> here it is!
20:04:52 <copumpkin> toast-opt: so you'd basically do runOmega $ liftM2 (,) (each [0..]) (each [0..])
20:04:57 <Veinor> the binaries that ghc builds don't require a haskell interpreter, correct?
20:05:06 <copumpkin> toast-opt: and that would give you all possible pairs of naturals
20:05:07 <EvanCarroll> is the xmonad code considered "clean"?
20:05:30 <sproingie> ghci is normally built but doensnt have to be
20:05:36 <toast-opt> > take 20  runOmega $ liftM2 (,) (each [0..]) (each [0..])
20:05:37 <lambdabot>   Not in scope: `runOmega'Not in scope: `each'Not in scope: `each'
20:05:51 <copumpkin> toast-opt: don't think lambdabot has it :)
20:05:51 <sproingie> oh wrong question
20:06:00 <sproingie> Veinor: no, they are standalone executables
20:06:05 <toast-opt> yeah, looks like
20:06:12 <Veinor> cool
20:06:33 <sproingie> up til 6.12 they're statically linked
20:06:39 <toast-opt> i didn't want every pair though, just every unique pair
20:06:44 <sproingie> so they're super-portable
20:06:54 <toast-opt> but i get your point, that looks very useful
20:06:55 <sproingie> (and big)
20:07:19 <copumpkin> :)
20:07:51 <toast-opt> heh, why so big?
20:07:58 <Veinor> woohoo, cabal installed!
20:08:30 <Warrigal> roconnor: so it seems I can always come up with a statement that could be taken to be either true or false.
20:09:06 <sproingie> haskell platform really ought to come with cabal-install
20:09:27 <Veinor> that would be a great idea
20:09:32 <toast-opt> ah, conveniency of dynamic languages that static languages struggle with:  zip zip ...
20:09:54 <toast-opt> probably easy using lists though
20:10:10 <Veinor> I just had to install parsec, mtl, network, and cabal by hand :/
20:10:21 <Veinor> it's not hard, but it is a bit time-consuming
20:11:12 <Saizan_> the haskell-platform _has_ cabal-install
20:11:14 <sproingie> yeah they install without a hitch, but it is pretty tedious
20:11:30 <sproingie> huh, istr having to install it
20:11:38 <Saizan_> the standard ghc installer doesn't
20:12:02 <sproingie> my bad recollection then
20:12:05 <Veinor> all I know is I had to manually install stuff here
20:12:15 <Veinor> I don't know what this machine installed/uninstalled
20:13:40 <Saizan_> preflex: seen EnglishGent
20:13:42 <preflex>  EnglishGent was last seen on #haskell 15 hours, 27 minutes and 56 seconds ago, saying: um - are you using Strict or Lazy bytestreams Phyx-?
20:13:54 <Veinor> whatever, now that I have cabal installed I can just cabal install worry-free
20:14:01 <Veinor> speaking of which, someone should write a bash autocomplete for cabal :P
20:14:16 <Saizan_> look in the tarball, there's one
20:14:24 <Veinor> there is?
20:14:42 <Veinor> why doesn't it install by default?
20:14:49 <Saizan_> bash-completion dir
20:14:59 <roconnor> <Warrigal> roconnor: so it seems I can always come up with a statement that could be taken to be either true or false.
20:15:02 <Veinor> yeah, i see it
20:15:04 <roconnor> how do you mean?
20:15:08 <Veinor> I just don't know how to install that into bash
20:16:15 <Saizan_> you just have to source it, i believe
20:16:47 <Veinor> that didn't do it
20:16:57 <roconnor> Warrigal: "the last natural number" isn't a natural number.  those words are not on my list
20:17:05 <roconnor> neither is "2+3" a natural number
20:17:14 <roconnor> SSSSS0 is a natural number though.
20:18:06 <roconnor> actually
20:18:17 <roconnor> I guess whether "2+3" is a natural number is a tricky question
20:18:27 <roconnor> maybe it is
20:18:33 <dancor> #metaphysics
20:18:34 <lunabot>  luna: Not in scope: `metaphysics'
20:18:41 <Cale> roconnor: From what axioms?
20:18:50 <Veinor> I get bash: ELF: command not found
20:18:54 <Veinor> whenever I try to run . cabal
20:18:55 <roconnor> Cale: we are talking semantics here
20:19:07 <Warrigal> roconnor: define "wooden" as follows: 0 is wooden. If N is wooden, SN is wooden. If a property holds for 0, and for all N, it holds for SN, then it holds for all wooden natural numbers.
20:19:14 <Warrigal> Here's my statement: there is a natural number that is not wooden.
20:19:16 <dancor> Veinor: instead of running ". cabal" just run "cabal"?
20:19:31 <dancor> . thing tells your shell to include that file as an rc file
20:19:35 <Saizan_> dancor: that caba is a script
20:19:39 <toast-opt> what's a natural number, then?
20:19:46 <Saizan_> "cabal"
20:19:48 <roconnor> Warrigal: what do you mean by "if a property holds"
20:19:56 <roconnor> Warrigal: what properties are we talking about?
20:20:06 <Warrigal> roconnor: I mean "if P holds", for all properties P. I'm actually making a separate statement for every property.
20:20:13 <dancor> oh.  /usr/local/bin/cabal is a binary file for me..
20:20:17 <roconnor> yes, but I'm not sure what counts as a property
20:20:21 <Veinor> oh dear, cabal install tab-completion tends to hang it
20:20:29 <dancor> an ELF binary in fact!
20:20:29 <Veinor> or at least, be slow
20:20:35 <Warrigal> A property is a well-formed formula whose only free variable is N.
20:20:45 <roconnor> a formula in what language?
20:20:45 <Saizan_> oh, i guess one just needs to . ./cabal
20:20:50 <Veinor> yeah, that
20:20:59 <Warrigal> In whatever language you're defining the natural numbers in.
20:21:02 <Cale> Warrigal: But we know that by one of the axioms of Peano Arithmetic, if a property holds for 0 and given that it holds for some natural number N, then it holds for SN, then it holds for all natural numbers.
20:21:10 <Warrigal> The elements of the language that I've seen so far are 0 and S.
20:21:27 <roconnor> I"m not defining the natural numbers in regards to any particular formal language.
20:21:27 <Warrigal> Cale: we're not talking about Peano arithmetic, we're talking about the natural numbers defined as "0, S0, SS0, etc."
20:21:45 <Warrigal> roconnor: the language of ZFC plus 0 and S, then.
20:21:52 <roconnor> ok
20:21:58 <Cale> Warrigal: Not sure that I follow that description. Is that an initial algebra?
20:22:09 <roconnor> Cale: the description is informal.
20:22:37 <Cale> Warrigal: So you're saying that I'm not allowed to use induction on naturals?
20:22:47 <Warrigal> Cale: yep.
20:22:56 <roconnor> Warrigal: I beleive your statement is false.
20:23:05 <Warrigal> roconnor: great; can you prove it?
20:24:09 <Cale> I can show that for any natural number which is not wooden, there must be a smaller one which is also not wooden.
20:24:33 <Warrigal> "Smaller" isn't in our language; you need to define it.
20:24:52 <Cale> Well, everyone knows how that's defined.
20:24:58 <copumpkin> morning natural
20:25:07 <Warrigal> Just like how everyone knows how "set" is defined?
20:25:28 <toast-opt> prev (S : rest) = rest
20:25:39 <Warrigal> I don't know whether the number N such that N = SN is smaller than itself or not. If there is such a number.
20:26:01 <stroan> I'm really liking the cabal build system...
20:26:15 <Veinor> cabal is very sexy
20:26:26 <stroan> polishing up these bindings I'm just finishing
20:26:32 <stroan> and cabal is making everything very nice
20:26:53 <toast-opt> is cabal only for haskell code?
20:28:11 <Cale> Well, okay, how about: n < 0 is false, and n < Sm means n = m or n < m.
20:28:18 <tommd> toast-opt: Yes.  You might be able to abuse it for others, but that isn't the intent.
20:28:20 <Saizan_> it supports building .c files to use in haskell libs/programs, but it's only about haskell, yeah
20:29:04 <Warrigal> Cale: it's possible given that definition that nothing is smaller than anything else, isn't it?
20:29:13 <Cale> No
20:29:22 <Cale> Because 0 = 0, we have that 0 < S0
20:29:23 <Warrigal> Unless we're given that > actually forms an ordering, of course.
20:29:29 <stroan> The bindings I'm working on, they'll work on any debian or ubuntu with the right package installed, but I can't figure out a nice way to make it generic. the location of a header file seems a bit variable
20:29:39 <Cale> Warrigal: That's a complete definition of the relation.
20:29:41 <Warrigal> Oh, when you said "means", you meant "if and only if", didn't you.
20:29:48 <Cale> Yes.
20:30:27 <Cale> Of course, I'm cheating a bit and defining it recursively, but we won't get very far without the ability to use recursion somewhere.
20:30:27 <Warrigal> How do you show that for every natural number that's not wooden, there's a smaller one that's also not wooden?
20:30:30 <Saizan_> stroan: does the C lib use pkg-config ?
20:30:37 <stroan> no, I checked
20:31:07 <stroan> <tcl8.3/expect.h>, <tcl8.4/expect.h>, etc, depending on the system
20:31:17 <pastah_rhymez> if i have a function that might throw an exception, is there any way i can catch that exception and change it from within a pure function
20:31:32 <Saizan_> aw, maybe the only way is a configure script there
20:31:46 <Saizan_> pastah_rhymez: no
20:32:01 <pastah_rhymez> so when i get my ArrayOutOfBoundsException i want catch that and change it to something like CantDoThatDaveException with a new error message
20:32:17 <pastah_rhymez> or actually i just need to change the error message
20:32:19 <Cale> Suppose that n were the least natural number which is not wooden. Since 0 is wooden, we know that n is not 0, so n must be the successor of some other number m. But then m < Sm = n.
20:32:38 <Cale> But since n was the least number which was not wooden, m must be wooden.
20:32:52 <Cale> But then Sm = n is wooden too.
20:33:04 <Warrigal> Right, okay.
20:33:36 <Cale> So n would be both wooden and not wooden, which is a contradiction. So n couldn't be the least one.
20:33:58 <Saizan_> pastah_rhymez: you've to do that from IO
20:34:26 <pastah_rhymez> Saizan_: aww, that kinda sucks
20:36:09 <Saizan_> pastah_rhymez: it's to keep referentially transparence and the ability of GHC to optimize code as it pleases :)
20:36:39 <Warrigal> roconnor: the thing is, I guess, once we abandon our axioms and formality, we're no longer talking about mathematics.
20:36:51 <pastah_rhymez> well, i'll just hide this nastiness with "module LOL hiding (..) where ..."
20:36:53 <pastah_rhymez> then
20:36:57 <roconnor> ya
20:37:03 <pastah_rhymez> oh, right, that didn't exist...
20:37:19 * Saizan_ just read an essay saying that formalities are almost a crime against the work of art that's mathematics
20:37:38 <roconnor> To prove your woodin claim is false I'm getting stuck translating satifactorally to a formal system.
20:37:52 <copumpkin> I'm still ambivalent about unsafePerformIO'ing exception catching for pure functions
20:38:08 <Cale> This argument roughly shows that any natural number with a finite number of S's must be wooden then, since if you gave me a specific example of a not-wooden natural number with a finite number of S's, I could simply reduce the number of S's in the example using this result over and over until I'd shown that 0 is not wooden, which would be a contradiction.
20:38:11 <copumpkin> there seems to be no fundamental reason that head should throw an error rather than returning a Maybe
20:38:26 <copumpkin> or that the binary functions need to throw errors rather than just living in Maybe
20:38:45 <monochrom> Someone should formalize that essay. That will show them.
20:38:46 <fracture> Saizan_: link to essay?
20:38:52 <Warrigal> Saizan_: nowadays, that's like saying that machine code is a crime against computers. I would be interested in reading that essay.
20:38:57 <Warrigal> Unless it's stupid.
20:39:07 <pastah_rhymez> copumpkin: well, you haven't listened to mr armstrong enough then
20:39:11 <Warrigal> Cale: right.
20:39:20 <copumpkin> pastah_rhymez: guess not :)
20:39:21 <Cale> Well, I can strengthen this result: specifically, if Sm is not wooden, then m is also not wooden.
20:39:25 <monochrom> or haskell is a crime against "art" of programming
20:39:29 <pastah_rhymez> copumpkin: only care about errors if there's a meaningful way to catch them
20:39:35 <dolio> Warrigal: I think induction says that every natural number is wooden.
20:39:47 <Warrigal> dolio: but we haven't shown that induction works.
20:39:53 <copumpkin> pastah_rhymez: hmm?
20:39:58 <Saizan_> Warrigal: well, the context is math education, so it's maybe more agreable
20:39:59 <dolio> Even if you have non-standard naturals in your model, they're required to be wooden because induction says so.
20:40:00 <pastah_rhymez> so what i'm making now is an array working as a lookup table with lots of elements uninitialized
20:40:09 <roconnor> ya, I agree with dolio
20:40:11 <Warrigal> Saizan_: ah, hmm.
20:40:23 <Cale> dolio: I have no idea what axioms he's accepting though :)
20:40:24 <copumpkin> pastah_rhymez: why not just an array of Maybe x?
20:40:34 <Warrigal> red-agent: but we haven't shown that induction works!
20:40:36 <Warrigal> Er.
20:40:37 <pastah_rhymez> so if i ever try to get something which is unitialized i'll crash heavily, but the only function using my arrays guarantees that that will never happend
20:40:42 <Warrigal> roconnor: but we haven't shown that induction works!
20:40:43 <monochrom> Then again there are two distinct "formal"s.
20:40:50 <Saizan_> fracture, Warrigal: http://www.maa.org/devlin/LockhartsLament.pdf
20:40:55 <Warrigal> We just have an informal definition that doesn't really say anything.
20:41:02 <Warrigal> Saizan_: hmm, the title looks familiar.
20:41:16 <Cale> Warrigal: If you'll accept that any nonempty set of natural numbers has a least member, then I can prove that induction works.
20:41:17 <pastah_rhymez> copumpkin: these arrays are globally defined and as i said, i am guaranteed that only valid values will be looked up
20:41:25 <copumpkin> ah
20:41:39 <pastah_rhymez> so i wouldn't dream of using maybe, it would seriously cramp my style
20:41:42 <roconnor> Warrigal: oh I simply assume that induction works.
20:41:46 <copumpkin> lol
20:41:59 <Warrigal> roconnor: oh, so we're using the Peano axioms? Why didn't you say so!
20:42:01 <copumpkin> well if it's a guarantee, then just stuff undefined in there
20:42:19 <dolio> Induction works because PA says that it works, so it works in all models of PA, even non-standard ones. :)
20:42:28 <pastah_rhymez> copumpkin: just doing something like that would couse me to have to add 2-5 LOC
20:42:32 <pastah_rhymez> not going to happend
20:42:38 <copumpkin> like what?
20:42:39 <roconnor> Warrigal: well, I hadn't quite decide what system to do my proof in.
20:42:50 <roconnor> Warrigal: I"m sure we can get away with much weaker than PA.
20:42:57 <pastah_rhymez> copumpkin: stuffing undefined in uninitialized array spaces
20:43:03 <copumpkin> pastah_rhymez: so what do you propose?
20:43:26 <pastah_rhymez> copumpkin: nothing, really
20:43:27 <roconnor> Warrigal: I'm was really trying to figure out the details how to translate "IsWooden" to a "definition" in a formal system.
20:43:30 <Warrigal> Saizan_: yep, I've read this before. I'm not sure it's about formalization so much as... well, I don't know.
20:43:41 <Chad__> hey -- what's the utility that automatically attempts to generate a binding to c/c++ code?
20:43:59 <pastah_rhymez> the only thing i might have wanted was to manipulate the error once it occured so that i might know how i fucked up, but since that's impossible i'll just live with it
20:44:10 <Cale> Suppose that N is any totally ordered set such that if S is any nonempty subset of it, then S contains a least element: that is, there is an element x in S such that x <= y for any y in S.
20:44:19 <Warrigal> roconnor: it seems you might as well use the language of ZFC; the Peano axioms can be expressed in that, as can ZFC.
20:44:34 <kmc> stupid puzzle: what's the shortest (by characters) haskell program that segfaults when compiled with ghc 6.10.4
20:44:36 <Saizan_> Warrigal: it's not the main argument, but it does warn against premature exposure to formalism
20:44:51 <roconnor> Warrigal: sure, but ZFC might be inconsistent, so you might not like me using that proof system
20:45:17 <monochrom> I warn against premature exposure to informalism.
20:45:18 <Saizan_> Warrigal: saying that formalism is only useful when you find a paradox or some other problem in your theory
20:45:29 <Cale> Suppose also that A is a subset of N with the property that x is in A for every x < y, then y is in A as well.
20:45:36 <copumpkin> kmc: using GHC bugs or just low-level stuff?
20:46:20 <roconnor> Warrigal: maybe you can help me,  How do we translate your claim into a statement in the language of number theory, or the language of set theory or whatever?
20:46:23 <copumpkin> kmc: quickest way is probably to just unsafeCoerce data to a function and call it
20:46:23 <Cale> If N \ A = { x in N : x is not in A } is nonempty, let u be its least member.
20:46:38 <Warrigal> roconnor: I'm fine with using any theory that's at least as consistent as ZFC.
20:46:50 <Warrigal> roconnor: translate the definition of "wooden" into some langauge?
20:46:51 <roconnor> Warrigal: okay, but how do we do the translation?
20:46:54 <roconnor> ya
20:46:58 <Cale> But then for every x < u we have that x is in A. So u is in A as well.
20:47:15 <roconnor> Warrigal: it seems we need to extend the language with a new predicate "IsWooden"
20:47:28 <Warrigal> Hmm, I wonder if we do.
20:47:37 <Warrigal> It kind of seems so.
20:47:44 <monochrom> When you learned Chess or Go or Checker... do you start informal or formal? "formal" means play out the actual moves, strictly following the rules; "informal" means use natural language to discuss and handwave and talk about "controlling the region".
20:48:04 <roconnor> then do we also extend the schema axioms to formulas with this new predicate?
20:48:12 <roconnor> that seems weird.
20:49:12 <monochrom> If "formal" means play the game of symbols or chess pieces, then "informal" means play the game of natural language words.
20:49:33 <Saizan_> monochrom: the essay describes mathematics as the "art" of coming up with sound ideas to solve problems, so basically, you get to make your own rules
20:49:44 <kmc> copumpkin, heh, main = unsafeCoerce () exits successfully on my machine
20:49:54 <copumpkin> kmc: oh, that's not the same thing
20:49:59 <copumpkin> kmc: unsafeCoerce () ()
20:50:02 <kmc> ah
20:50:08 <monochrom> People who deride formalism use the "just a game" argument against formalism; they do not realize this stupid English language is a worse game of mincing words. I know it firsthand from watching math classes.
20:50:10 <kmc> it segfaults with a string there anyway
20:50:47 <Warrigal> roconnor: well, I can't think of any better way to do it.
20:51:06 <roconnor> but the problem because trivial in that case.
20:51:08 <Warrigal> We can't really substitute an entire infinite axiom schema into a WFF.
20:51:14 <Warrigal> No, I don't think it does.
20:51:18 <copumpkin> kmc: if you want to segfault with purely high-level code in 6.10.4 we can arrange that too
20:51:33 <dolio> Formalism seems like an interesting game to me, but maybe that's because I'm a computer scientist.
20:51:40 <dancor> is mizar opensource?  if not, what is the opensource proof system with the largest body of common math encoded in it
20:51:42 <roconnor> Warrigal: if we entend PA to your new predicate
20:51:48 <monochrom> Well I'll continue in #haskell-blah
20:51:59 <Warrigal> roconnor: ah, yes.
20:52:02 <Cale> Oh, heh, was it supposed to be wooden or Woodin? :)
20:52:15 <roconnor> and extend the induction schema
20:52:18 <roconnor> ya
20:52:20 <Warrigal> I thought we were still talking about languages, not axioms.
20:52:33 <Warrigal> Cale: don't tell me there was some guy named Woodin who worked with this sort of thing.
20:52:41 <Warrigal> If there was, I must be psychic.
20:52:49 * Warrigal levitates his headphones.
20:52:52 <copumpkin> kmc: http://hackage.haskell.org/trac/ghc/ticket/1496 for example
20:52:53 <roconnor> Warrigal: never heard of Woodin cardinals?
20:52:53 <kmc> copumpkin, works, but not with -O3: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12911#a12911
20:53:04 <Cale> Woodin is a set theorist. He works on... more subtle issues than this.
20:53:05 <kmc> copumpkin, yeah that is a scary bug
20:53:22 <kmc> are there any others comparably scary?
20:53:53 <copumpkin> O TYPE SYSTEM WHEREFORE HAST THOU FAILED ME??
20:53:56 <Warrigal> roconnor: I don't think so.
20:54:03 <roconnor> Warrigal: okay, here is an idea
20:54:08 <copumpkin> kmc: not that I know of
20:54:11 <toast-opt> hey, curious question, does ghci have anything like python's "help"?
20:54:20 <Warrigal> toast-opt: I think there's :help.
20:54:26 <kmc> :browse
20:54:27 <kmc> :info
20:54:48 <toast-opt> :info, that's kinda cool
20:54:53 <toast-opt> no docstrings it looks like
20:54:54 <roconnor> Warrigal: defined IsReallyWooden (x) := x = 0 \/ exists n, x = n -> x = S n
20:55:12 <toast-opt> kmc, thx.  shows me the module at least, which is a start
20:55:19 <kmc> no docstrings, that's handled out-of-band with Haddock
20:55:31 <roconnor> Warrigal: this is in the language of number theory
20:55:32 <kmc> you shoul of course bookmark http://hackage.haskell.org/packages/archive/pkg-list.html and http://www.haskell.org/ghc/docs/latest/html/libraries/
20:55:49 <roconnor> Warrigal: it should be sufficent to prove to you that isReallyWooden holds for all natural numbers
20:56:12 <roconnor> I could add your other property, but that would only make my life easier
20:56:19 <toast-opt> kmc, thx
20:56:19 <roconnor> and I will ignore it anyways
20:56:22 <roconnor> actually let me do that
20:56:42 <roconnor> Warrigal: define IsWooden (x) := x = 0 \/ exists n, x = n -> x = S n \/ <whatever your third property is I don't care>
20:56:43 <Warrigal> roconnor: can you parenthesize the part after \/?
20:56:48 <toast-opt> can i invoke haddock from ghci, to search docs?
20:56:48 <roconnor> ya
20:57:02 <copumpkin> in the lambdabot-augmented ghci, yep
20:57:06 <Warrigal> \/ (exists n, ((x = n) -> (x = S n)))?
20:57:06 <roconnor> Warrigal: define IsWooden (x) := x = 0 \/ (exists n. ((x = n) -> (x = S n))) \/ <whatever your third property is I don't care>
20:57:10 * Warrigal nods.
20:57:18 <Cale> copumpkin: ?
20:57:22 <roconnor> now I can prove this by induction in PA.
20:57:31 <roconnor> and we didn't extend the language.
20:57:32 <copumpkin> there was some project that gave you lambdabotness in ghci
20:57:38 <copumpkin> can't remember what it was called
20:57:43 <Cale> toast-opt: Normally haddock generates html pages which you load in your web browser.
20:57:43 <copumpkin> I think it's bitrotted now though
20:57:49 <dolio> ghci on acid
20:57:56 <copumpkin> that's it
20:57:57 <Adamant> copumpkin: I just saw that earlier today looking for the foundation paper on System Fc
20:58:07 <chadz> is there a replacement to hsc2hs ?
20:58:11 <toast-opt> it would be nice to just say something like ":docsFor show"
20:58:13 <Warrigal> roconnor: it seems that you want your middle axiom to be (exists n. IsWooden(n) /\ x = S n).
20:58:26 <Warrigal> s/axiom/condition/
20:58:32 <copumpkin> Adamant: ghci on acid?
20:58:38 <Cale> chadz: What counts as a replacement?
20:58:42 <Warrigal> Since I think what I said was "if n is wooden, so is Sn".
20:58:55 <roconnor> Warrigal: doing that would require extending the langauge.
20:58:55 <Warrigal> In any case, the Peano axioms certainly prove that every natural number is wooden.
20:59:12 <copumpkin> just out of curiosity, am I missing a fundamental mathematical concept of woodenness?
20:59:14 <chadz> Cale: no idea yet. i have a pretty shotty c++ library that I'd like to somehow attempt to use via the FFI. however, i've never touched the ffi before.
20:59:19 <copumpkin> I missed the beginning of this conversation
20:59:21 <roconnor> Warrigal: I think x = is a stafactory translation of IsWooden in this context
20:59:39 <roconnor> oh wait
20:59:41 <roconnor> ya
20:59:41 <Cale> chadz: That may be hard without a little work, due to the usual problems with interfacing C++ code with anything else.
20:59:46 <roconnor> I'm totally on drugs
20:59:51 <copumpkin> sweet
20:59:56 <Cale> chadz: You might need to write a C wrapper.
20:59:57 <roconnor> what I wrote doesn't work at all.
21:00:01 <chadz> Cale: true.
21:00:03 <Warrigal> I guess we need a non-recursive definition of "wooden", don't we.
21:00:04 <Adamant> copumpkin: no, the "GHC type system broken, news at 11" bug :P
21:00:08 <copumpkin> Adamant: oh :)
21:00:32 * copumpkin wants even a recursive definition of wooden
21:00:35 <Cale> chadz: There's a tool called c2hs, which seems more active.
21:00:43 <Cale> chadz: But the plain FFI is not so bad in itself.
21:01:00 <Warrigal> copumpkin: a natural number is wooden if it's 0 or there's a wooden number whose successor is it.
21:01:11 <dolio> Just create a new section, and take IsWooden, p : IsWooden(0) and q : forall x, IsWooden(x) -> IsWooden(Sx) as variables.
21:01:20 <Warrigal> If there are any non-wooden numbers, that definition is ill-defined.
21:01:21 <copumpkin> Warrigal: this is a random definition one of you made on the fly?
21:01:21 <Cale> chadz: and the FFI standard is actually pretty readable and tutorial in nature.
21:01:28 <dolio> Then you can prove forall n, IsWooden(n) by induction regardless of what IsWooden is.
21:01:33 <Warrigal> copumpkin: pretty much.
21:01:36 <copumpkin> oh ok
21:02:06 <Cale> @where ffi
21:02:06 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:02:23 <roconnor> dolio: that requires higher-order logic
21:02:24 <Warrigal> dolio: what's this about sections? It kind of seems like you're talking about a specific language.
21:02:48 <roconnor> dolio: which would certainly make this a whole lot easier.
21:02:54 <EvanCarroll> where can you get an in-detail description of what a function in Data.Maybe ? (Just)
21:03:08 <Axman6> EvanCarroll: huh?
21:03:12 <Cale> EvanCarroll: Just is a data constructors
21:03:14 <Cale> -s
21:03:21 <Axman6> @src Maybe
21:03:21 <lambdabot> data Maybe a = Nothing | Just a
21:03:27 <dolio> Warrigal: Based on his syntax, I guessed he was formalizing it in Coq.
21:03:32 <Cale> EvanCarroll: If x :: t, then Just x :: Maybe t
21:03:56 <chadz> Cale: i'm not even sure if i'm on the right path. i'm interesting in writing a haskell daemon that would communicate with the c++ library, however, this would require me to redefine all the datastructures and provide a mechanism for marshalling them over the wire. if I go all the way and FFI the datastructures, I pretty much could natively link against the c++ library, right?
21:04:02 <dolio> Maybe he isn't, though.
21:04:04 <Cale> EvanCarroll: In addition to this,  Nothing :: Maybe t  (for any t)
21:04:12 <EvanCarroll> Cale: I don't understand any of that
21:04:16 <EvanCarroll> is there like a perldoc -f ?
21:04:18 <roconnor> Warrigal: brb
21:04:27 <Cale> EvanCarroll: You're a perl user?
21:04:30 <EvanCarroll> yes.
21:04:44 <Warrigal> You know, reading about Mizar gives me some motivation to complete my own project.
21:04:45 <Cale> EvanCarroll: Have you ever written a function in perl which sometimes failed to return a value?
21:04:46 <Axman6> EvanCarroll: do you understand what the @src of Maybe says?
21:04:48 <chadz> Cale: err, the haskell daemon would communicate to the c++ library via a small c++ client that marshalled the data in some manner
21:05:13 <EvanCarroll> Cale: sure, it sounds like Moose's Maybe[] (parameterized type that permits null or strict type)
21:05:26 <EvanCarroll> Axman6: no, bucause I don't understand what Nothing or Maybe means.
21:05:31 <Cale> EvanCarroll: Yes, that's what Maybe is all about in Haskell.
21:05:39 <EvanCarroll> I'm just reading http://en.wikibooks.org/wiki/Haskell/Laziness
21:05:40 * Warrigal gives himself a piece of advice: no matter what it is, if it's worthwhile, do it for at least five minutes a day, if possible.
21:05:42 <EvanCarroll> and they use Just in an example
21:05:43 <kmc> it should be noted that GHC lets you bind new commands to arbitrary IO-actions
21:05:48 <kmc> GHCi*
21:05:57 <Cale> EvanCarroll: Nothing and Just only construct values of type Maybe t
21:05:59 <Axman6> :t lookup
21:06:01 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:06:12 <Cale> EvanCarroll:  Nothing :: Maybe t  and  Just :: t -> Maybe t
21:06:22 <Axman6> > lookup 1 (zip [1..] "hello")
21:06:23 <lambdabot>   Just 'h'
21:06:27 <Axman6> > lookup 10 (zip [1..] "hello")
21:06:28 <lambdabot>   Nothing
21:06:56 <EvanCarroll> Cale: the question was more about where do i look to find this out
21:07:04 <Axman6> EvanCarroll: do you understand what happened there?
21:07:09 <EvanCarroll> is there a better resource to go to
21:07:10 <Cale> EvanCarroll: Well, you could look in the Prelude I guess.
21:07:21 <Cale> EvanCarroll: It would be in the Haddock for the Prelude.
21:07:31 <EvanCarroll> Cale: link?
21:07:37 <Axman6> @where prelude
21:07:37 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
21:07:45 <Axman6> EvanCarroll: ^^^^^^^^^^^^666
21:07:49 <Cale> also: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
21:08:02 <toast-opt> question on lambdas
21:08:22 <toast-opt> lambdas can't have pattern matching, like f x = something.  f 0 = something-else.
21:08:29 <toast-opt> but you can just use case of, right?
21:08:35 <Axman6> you can use case to do that
21:08:39 <toast-opt> is there any difference?
21:08:43 <Axman6> nope
21:08:47 <toast-opt> thx
21:08:57 <Axman6> pattern matching gets turned into case expressions anyway
21:09:09 <toast-opt> that's what i'd expect, but wasn't sure
21:09:16 <Cale> EvanCarroll: You could also :info Just from ghci, and it'll tell you that it's a constructor for the Maybe datatype
21:09:18 <toast-opt> RWH called out it as special in lambdas
21:09:18 <EvanCarroll> interesting i'll add it on my list to read
21:09:27 <EvanCarroll> right, but there isn't a text description
21:09:29 <Cale> EvanCarroll: You could then :info Maybe to get more information
21:09:38 <EvanCarroll> gah
21:09:50 <EvanCarroll> that's not even close to perldoc
21:09:53 <Axman6> > (\x -> case x of Just y -> show y; Nothing -> "aww") (Just 3)
21:09:54 <Cale> EvanCarroll: It starts with a capital letter
21:09:54 <lambdabot>   "3"
21:09:55 <EvanCarroll> that's only a good reference if you know the language
21:10:01 <Axman6> > (\x -> case x of Just y -> show y; Nothing -> "aww") Nothing
21:10:01 <Cale> EvanCarroll: Which means that it doesn't "do" anything.
21:10:02 <lambdabot>   "aww"
21:11:06 <Warrigal> toast-opt: well, you can have pattern matching in lambdas; it's just that you can only have one alternative.
21:11:08 <Peaker> > map (maybe "aww" show) [Just 3, Nothing]
21:11:09 <lambdabot>   ["3","aww"]
21:11:15 <Warrigal> > (\(x:xs) -> (x,xs)) "foo"
21:11:16 <lambdabot>   ('f',"oo")
21:11:20 <toast-opt> Warrigal, :P
21:11:35 <Cale> Functions and values whose name starts with a capital letter (or a colon) are data constructors, and they simply take their parameters and build a value from which they can later be extracted using pattern matching.
21:11:43 <toast-opt> that makes sense though
21:11:51 <EvanCarroll> =(
21:12:13 <Cale> So in some sense, the type of Just is all there is to say about it.
21:12:17 <EvanCarroll> Cale: I understand that you're haskell god, but it seems silly to have to ask you stupid stuff that i should be able to find out on my own
21:12:17 <mmorrow> this is the best free (not open source) interactive graph editor/explorer/layout-er i've seen (actually, i think the *only* one, but it's still surprisingly nice nonetheless) http://www.yworks.com/en/products_yed_about.html
21:12:29 <Cale> EvanCarroll: Don't worry, I don't mind :)
21:12:46 <Axman6> EvanCarroll: have you followed a tutorial? all this would be answered in any of the haskell tutorials i've seen
21:12:57 <EvanCarroll> I just want a haskelldoc -f or somewhere I can look for guidance on these gazillion (questionably redudant) functions
21:13:08 <Cale> EvanCarroll: That's what this channel is.
21:13:33 <Cale> EvanCarroll: The reason most of us are here is to answer questions of that sort :)
21:13:53 <EvanCarroll> Axman6: I followed LYAH until higher-ordered functions, I didn't understand foldl/foldr as the tutorial described, so i ordered the oreilly book, read the wiki on Foldl, Foldr, Fold... and then was pointed to http://en.wikibooks.org/wiki/Haskell/Laziness for a fundamental lack of understanding
21:13:59 <EvanCarroll> now I'm reading it
21:14:33 <Cale> EvanCarroll: I forget if I linked you to my diagrams or not...
21:14:47 <Cale> http://cale.yi.org/index.php/Fold_Diagrams -- regardless :)
21:15:01 <EvanCarroll> it is interesting, that following my progression of reading I never really understood a Thunk, or NF or WHNF, which leads me to believe LYAH is way to practical to be a good foundation
21:15:13 <EvanCarroll> Cale: yes, those diagrams are all over the place, and extremely confusing
21:15:28 <EvanCarroll> they're on wikipedia, the haskell wiki, the wikibooks
21:15:29 <EvanCarroll> lol
21:15:29 <Cale> I actually think that thunks are too low level to think about while programming in Haskell.
21:15:36 <EvanCarroll> I don't
21:15:41 <Cale> Expressions are better.
21:15:50 <EvanCarroll> I think they're neccessary to even use the term 'pattern matching'
21:15:59 <Cale> No, not really.
21:16:01 <Cale> Haskell is reduced by manipulating expressions.
21:16:14 <EvanCarroll> Cale: I totally and strongly disagree, having no idea of what pattern matching was prior to understanding thunk, and tunks returning thunks
21:16:14 <Cale> (which are graphs)
21:16:17 <Axman6> EvanCarroll: thunks aren't part of haskell though (imo). they're part of ghc. implementation, not specification
21:16:19 <EvanCarroll> now I think I've wrapped my head around that.
21:16:33 <c_wraith> pattern matching has nothing to do with thunks.
21:16:34 <Cale> EvanCarroll: But thunks are just an implementation mechanism for expressions.
21:16:45 <EvanCarroll> http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form
21:16:48 <c_wraith> pattern matching is about matching the constructor an expression was constructed with
21:16:52 <Axman6> EvanCarroll: thunks have nothing at all to do with pattern matching
21:17:02 <Cale> EvanCarroll: It's not necessary to mention thunks to understand weak head normal form.
21:17:15 <Cale> WHNF really is an important concept.
21:17:39 <Cale> It's way more important to understand how to reduce Haskell by transforming expressions than to understand what GHC really does.
21:17:51 <Cale> (at least, this is what I find)
21:17:52 <EvanCarroll> Cale: you won't even find the term in LYAH
21:17:55 <Axman6> i completely agree
21:18:08 <Cale> Well, LYAH is for getting people off the ground.
21:18:09 <Axman6> EvanCarroll: learn haskell, not how it's implemented
21:18:22 <Cale> How the evaluation mechanism works is an advanced detail :)
21:18:24 <EvanCarroll> Cale: at least, not until the point that i left that source (I'll return to it after i get the foundation)
21:18:35 <Peaker> I hate WHNF and all primitives that evaluate to it
21:18:45 <EvanCarroll> that sounds like a bold statement.
21:18:56 <Peaker> WHNF reduction on a value of type "a" is an abstraction leak
21:18:56 <Cale> Peaker: Even case expressions?
21:19:09 <Peaker> Cale, In the sugared notation, case statements don't really do WHNF
21:19:24 <Cale> Well, they have to evaluate enough to pattern match.
21:19:35 <Peaker> Cale, Right, where enough may or may not be WHNF
21:19:49 <Cale> Unless the pattern is trivial, it's at least WHNF
21:19:49 <Axman6> EvanCarroll: what you're even doing trying to learn about thunks when you're so new to haskell i have no idea
21:20:00 <Peaker> Cale, there's no abstraction leak here because the evaluation depth matches the constructors specified
21:20:14 <Cale> Peaker: Right, I know what you mean, I think.
21:20:23 <Cale> Peaker: Really you meant to say that you hate seq
21:20:25 <Peaker> Cale, But when you use "seq" on some abstract type -- you have an abstraction leak because there's no way you should know what the type's WHNF even means
21:20:26 <EvanCarroll> Axman6: because I don't understand how foldl or foldr can work on an infinite list
21:20:31 <EvanCarroll> and I still don't really get it
21:20:39 <EvanCarroll> and that pisses me off
21:20:41 <Peaker> Cale, Or strict fields, or any use of WHNF on abstract types
21:20:42 <Cale> EvanCarroll: foldl can't
21:20:50 <EvanCarroll> right, whatever
21:20:54 <Cale> EvanCarroll: Let's evaluate foldr using an infinite list
21:20:58 <Axman6> did you pay attention to when i showed you how to use foldr with (||) and (&&)?
21:21:01 <Cale> EvanCarroll: By hand, step-by-step
21:21:28 <Warrigal> EvanCarroll: what's the definition of "thunk", anyway? Is it any expression that's not fully evaluated?
21:21:29 <Axman6> :t const Just
21:21:30 <lambdabot> forall a b. b -> a -> Maybe a
21:21:49 <Cale> EvanCarroll: What function would you like to use? We could do something like foldr (\x xs -> 2*x : xs) [] [0..]
21:21:56 <Axman6> > foldl (const Just) Nothing [1..10]
21:21:57 <lambdabot>   Just 10
21:22:02 <Axman6> > foldl (const Just) Nothing []
21:22:03 <lambdabot>   Nothing
21:22:05 <EvanCarroll> Warrigal: yes, that can be decomposed into another set of arbitrarily deep unevaluated expressions (thunks)
21:22:19 <Cale> Warrigal: It's the way that unevaluated expressions are represented in memory
21:22:26 <Peaker> EvanCarroll, f = foldr binop z    reduces [a,b,c,d]  to (a `binop` f [b,c,d])  so if binop doesn't even look at the right side, it won't recurse really
21:22:55 <Warrigal> EvanCarroll: well, expressions that are not fully evaluated are indeed necessary in Haskell.
21:23:02 <Axman6> Peaker: missed a foldr there
21:23:09 <Peaker> Axman6, f = ...
21:23:11 <Cale> Warrigal: A thunk is a pointer to code which when executed computes a value and replaces the pointer with a pointer to different code that will simply return the computed value, before just returning the value itself.
21:23:19 <Axman6> oh, right, my bad
21:23:28 <Warrigal> Unless your computer can perform an infinite number of operations as long as only finitely many have any effect.
21:23:43 <Warrigal> Cale: it looks like EvanCarroll has a different idea of what they are.
21:24:09 <Cale> Some people inexplicably use the word "thunk" when they mean "expression"
21:24:25 <Axman6> or, even unevaluated expression?
21:24:26 <Cale> I guess it's similar to where people use the word "closure" when they mean "function"
21:24:54 <blackdog> Axman6: this is very hard for me to say, but I think I want to leave Sydney and live in Canberra.
21:25:03 <EvanCarroll> if the function has a variable not local to the function it is closing over that variable and a closure?
21:25:10 <EvanCarroll> seems easy enough to draw the distinction
21:25:16 <Cale> EvanCarroll: Functions just do that
21:25:35 <Cale> EvanCarroll: Closures are a *specific* implementation mechanism for making that happen.
21:25:36 <Axman6> blackdog: yes, you do
21:25:43 <Axman6> blackdog: what for though?
21:25:50 <EvanCarroll> my $x ; sub foo { $x++ }; foo();foo();
21:25:50 <EvanCarroll> closure.
21:25:50 <EvanCarroll> no/
21:25:51 <blackdog> Axman6: Sydney is 41C
21:25:55 <blackdog> and humid
21:25:56 <Axman6> heh
21:26:06 <Axman6> yeah, we only get 40+ and dry days usually
21:26:12 <Cale> EvanCarroll: Specifically, the implementation mechanism where you have a pair consisting of some code for the function body, together with a mapping from free variables of that code to values.
21:26:12 <toast-opt> evancarroll, what lang is that?
21:26:20 <Axman6> and the humidity is never as awful as sydney's
21:26:30 <Cale> EvanCarroll: any other usage of the term is an abuse of terminology
21:26:35 <aavogt> still sounds like awful weather
21:26:40 <blackdog> Axman6: also, i'm tired of enjoying vibrant nightlife free of bureaucrats.
21:26:42 <Cale> (and there's a *lot* of abuse of the term "closure" out there)
21:26:59 <EvanCarroll> toast-opt: perl
21:27:04 <toast-opt> like 'clojure'?
21:27:05 <Axman6> we have a nightlife. it's just not my thing though
21:27:06 <mmorrow> Warrigal: i use "thunk" to mean "frozen function application"
21:27:15 <toast-opt> evancarroll, thx.  i forgot about perl
21:27:36 <toast-opt> cale, like what abuses?
21:27:37 <Cale> EvanCarroll: anyway, let's evaluate this foldr by hand and see what happens
21:27:53 <Cale> toast-opt: People ask whether certain languages "have closures", which is nonsense.
21:28:03 <toast-opt> ah, usually they mean lambdas
21:28:04 <aavogt> > foldr (+) x [y,z,w]
21:28:05 <lambdabot>   y + (z + (w + x))
21:28:07 <Cale> toast-opt: Language *implementations* might *use* closures to implement functions.
21:28:20 <blackdog> Axman6: i just can't fight you on this. sydney is the armpit of the universe right now
21:28:23 <aavogt> > foldr (+) x [y,z,w,undefined]
21:28:24 <lambdabot>   y + (z + (w + (* Exception: Prelude.undefined
21:28:26 <mmorrow> Warrigal: and "depth of the thunk" to mean "the longest chain of thunks reachable from a given thunk"
21:28:27 <Cale> But they're really asking if the language supports functions :)
21:28:30 <toast-opt> or they mean lexical scoping and inner functions
21:28:36 <toast-opt> yeah
21:28:41 <Axman6> blackdog: Sarah took me up to sydney last year to see top gear live, and the heat was completely unbarable
21:28:55 <Warrigal> This is why I like programming languages in which not every value has a canonical form.
21:29:14 <Warrigal> It makes it much more difficult to say what a thunk is.
21:29:39 <Cale> EvanCarroll: anyway, come to #haskell-overflow and we'll do some calculations by hand in order to understand what's going on with foldr
21:30:05 <toast-opt> heh, id is just the identity function
21:30:15 <aavogt> @hoogle ego
21:30:18 <lambdabot> Data.Time.Calendar addGregorianMonthsClip :: Integer -> Day -> Day
21:30:18 <lambdabot> Data.Time.Calendar addGregorianMonthsRollOver :: Integer -> Day -> Day
21:30:18 <lambdabot> Data.Time.Calendar addGregorianYearsClip :: Integer -> Day -> Day
21:30:39 <toast-opt> ooo, that was awesome
21:31:04 <toast-opt> @hoogle random
21:31:05 <lambdabot> package random
21:31:05 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
21:31:05 <lambdabot> module System.Random
21:31:38 <toast-opt> i assume there are PRNGs in the IO monad?
21:31:48 <Axman6> yes
21:31:57 <Axman6> wait, those aren't (though can be
21:32:06 <aavogt> that random function isn't in IO
21:32:27 <toast-opt> is there one that is, i mean
21:32:28 <aavogt> but you basically have to be in IO to get an appropriate RandomGen
21:32:47 <Warrigal> ego x = ego
21:32:51 <Warrigal> The egotistical function.
21:32:52 <aavogt> err, thing that is an instance of RandomGen
21:33:11 <aavogt> Warrigal: infinite type ;)?
21:33:26 <aavogt> @type let ego x = ego in ego
21:33:27 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
21:33:27 <lambdabot>     Probable cause: `ego' is applied to too few arguments
21:33:27 <lambdabot>     In the expression: ego
21:33:36 <Warrigal> It's so egotistical that it doesn't care.
21:34:04 <aavogt> @hoogle randomIO
21:34:04 <lambdabot> System.Random randomIO :: Random a => IO a
21:34:14 <aavogt> @docs System.Random
21:34:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
21:34:16 <toast-opt> oh, cool
21:34:18 <toast-opt> thx
21:34:21 <mmorrow> Peaker: what do you mean "because there's no way you should know what the type's WHNF even means"? haskell only has {data, functions, and unboxed literals}
21:34:56 <mmorrow> and seq is moot for the third of those
21:35:37 <Peaker> mmorrow, Different implementations/representations of an abstract type may make "seq" do completely different things
21:35:37 <mmorrow> well, actually i guess "haskell" doesn't even have unboxed literals
21:35:56 <Peaker> mmorrow, "seq" on an array may mean something completely different to "seq" on a list, in cases where you shouldn't care if it is an array or a list
21:36:04 <mmorrow> Peaker: it always does the same thing, evaluate to whnf
21:36:15 <aavogt> actually the link is http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
21:36:41 <roconnor> Warrigal: okay, so I can defined a predicate P(x) := "there is a list of numbers l such that x is the head of the list and every number in the list is either 0 or the successor of the next element in the list." in the language of number theory, and I can prove that forall n, P n in PA.
21:36:48 <Peaker> mmorrow, But WHNF is an implementation detail -- forcing evaluation is done for some purpose
21:37:06 <roconnor> Warrigal: the question is, does P(x) capture your definition?
21:37:11 <Peaker> mmorrow, When would you want to use "seq" on an abstract type?
21:37:23 <roconnor> Warrigal: you could argue that it doesn't (or at least might not).
21:37:26 <mmorrow> , let foo n = let !x = foldl' (+) 0 [1..n] in \y -> x + y in time (foo 100000 `seq` ())
21:37:28 <lunabot>  (1.6996999999999998e-2,())
21:37:34 <mmorrow> functions are "abstract"
21:38:05 <mmorrow> Peaker: because you can put an arbitrary data-dependency in front of the value of that abstract type
21:38:18 <aavogt> Cale: any ideas for fixing @docs to point to packages outside of base (which keeps shrinking)?
21:38:19 <Warrigal> roconnor: my definition of woodenness?
21:38:20 <roconnor> Warrigal: because you might try to argue that when I say there is a list of numbers, that you think my lists are infinite.
21:38:31 <roconnor> Warrigal: right, your definition of woodenness.
21:38:37 <Warrigal> Yeah, you haven't really stated that lists have to be finite.
21:38:49 <Peaker> mmorrow, if Ints and (+) of Ints behaved differently, could it not break your example above?
21:39:11 <mmorrow> Peaker: what does "break" mean?
21:39:18 <toast-opt> > succ . succ 0
21:39:18 <lambdabot>   No instance for (GHC.Enum.Enum (f a))
21:39:19 <lambdabot>    arising from a use of `GHC.Enum.su...
21:39:23 <Peaker> mmorrow, make the "seq" meaningless, for example
21:39:25 <roconnor> Warrigal: by list I mean a natural number encoding of lists in one of the standard ways.
21:39:34 <aavogt> > succ $ succ 0
21:39:35 <lambdabot>   2
21:39:41 <Peaker> mmorrow, (Cause the program to run in the same space complextiy)
21:39:46 <toast-opt> oh, hmm
21:39:48 <Peaker> mmorrow, (as without the seq)
21:39:50 <mmorrow> i want to evaluate "x" entirely before i hand back a function, so that x won't have to be evaluated the first time that returned function is evaluated
21:40:01 <Warrigal> roconnor: the definition of woodenness pretty much lies in the definition of a list, I think.
21:40:02 <toast-opt> so . composes functions, but $ is entirely for piping left
21:40:07 <Peaker> mmorrow, But you're only evaluating "x" one level deep
21:40:12 <Warrigal> roconnor: why are we formally defining woodenness, though?
21:40:14 <aavogt> > succ . succ $ 0
21:40:15 <lambdabot>   2
21:40:16 <roconnor> Warrigal: your informal inductive definition of your wooden predicate is exactly as vague as definition of natural numbers
21:40:17 <mmorrow> Peaker: which is all i need for Int
21:40:19 <toast-opt> let me guess, $ is right associative and . is left associative?
21:40:27 <toast-opt> oh, i c
21:40:33 <toast-opt> 0 isn't a function, duh
21:40:35 <mmorrow> Peaker: if i wanted more i'd do  rnf x `seq` ...
21:40:36 <roconnor> Warrigal: I need to formalize it in order to prove stuff about it.
21:40:44 <aavogt> toast-opt: both right associative, but otherwise you're right
21:40:46 <Peaker> mmorrow, You're basically relying on the fact that 1-level deep on an "Int" is "all the way down" -- but that's relying on an implementation detail. What you really want most of the time is either (all the way down) or  (some arbitrary amount down, that I can specify for a particular type)
21:40:46 <roconnor> Warrigal: in order to prove your claim is false.
21:40:47 <Warrigal> roconnor: why do you want to prove stuff about it?
21:40:53 <Warrigal> What's my claim, again?
21:40:55 <roconnor> cause you asked me to :)
21:41:05 <mmorrow> Peaker: this is what type classes are for
21:41:05 <roconnor> your claim that there is a natural number that isn't wooden
21:41:06 <toast-opt> aavog, yeah, rather, succ 0 isn't a function, so . can't compose it
21:41:07 <Peaker> mmorrow, 1-level down is just too arbitrary and knowing exactly what it means for concrete types is very inelegant, for abstract types its just wrong
21:41:09 <aavogt> though function composition could associate the other way without causing much trouble
21:41:21 <aavogt> or could it?
21:41:22 <toast-opt> succ 0 is an Integer :)
21:41:24 <roconnor> Warrigal: might be easier to think about the negation of your claim: "Every natural number is wooden"
21:41:25 <Peaker> mmorrow, yeah, we need Seq and not seq
21:41:26 <toast-opt> thx
21:41:39 <Warrigal> roconnor: well, you said this: "and I can prove that forall n, P n in PA."
21:41:50 <roconnor> oh sure
21:41:54 <roconnor> that is no problem
21:41:56 <Warrigal> If we're using PA, then "there is a non-wooden natural number" isn't the claim I want to make.
21:41:58 <mmorrow> Peaker: but that's beside the point though, one-level is enough to ensure that any computation that your value, abstract or otherwise, is dependent on is evaluated
21:42:19 <roconnor> Warrigal: hmm, I'm a bit confused now
21:42:27 <mmorrow> Peaker: so it's less about evaluating the actual *value*, and more about making sure all *obstructions to* that value are removed
21:42:28 <Warrigal> If we're using PA, the claim I want to make is "there are uncountably many natural numbers".
21:43:02 <Warrigal> Then again, that claim can't even be stated in PA, can it.
21:43:04 <roconnor> that is a statement that is difficult to formulate in the language of number theory.
21:43:20 <mmorrow> Peaker: note that i used seq on *foo* in that example, that i banged the "x::Int" was just a detail
21:43:35 <mmorrow> s/foo/foo 10000000/
21:43:42 <mmorrow> foo 1000000 :: Int -> Int
21:43:42 <Warrigal> Hmm...
21:43:53 <roconnor> this first order logic thing stinks
21:43:58 <roconnor> let's work in Agda :)
21:44:13 <Peaker> mmorrow, I don't understand what you mean there.. what "obstruction"?  Maybe the data dependency is partially evaluated for depending the head constructor, but later evaluated more for deeper choices?
21:44:26 <Peaker> mmorrow, In that case you haven't really made sure there aren't "obstructions", no?
21:44:55 <Warrigal> roconnor: okay, define "elem" as being some relation between natural numbers that satisfies the ZFC axioms. :-P
21:45:03 <Peaker> mmorrow, btw, in your example, if Integer is chosen, I don't have any idea what "seq" would do to it
21:45:07 <toast-opt> hmm, you can prefix just about anything with ($)
21:45:23 <Warrigal> toast-opt: I think there is no expression E for which ($ E) is not also a valid expression.
21:45:30 <toast-opt> heh
21:45:36 <Warrigal> Actually...
21:45:39 <Warrigal> > ($ 3 :: Int)
21:45:40 <lambdabot>   <no location info>: parse error on input `::'
21:45:48 <Warrigal> Yay, I found one.
21:46:02 <toast-opt> yeah, there's no function call expression you can't prefix that way
21:46:09 <Peaker> mmorrow, Well, I can guess seq evaluates Integer fully, but its not out of the question that an Integer implementation could be partially evaluated by "seq"
21:46:12 <roconnor> Warrigal: I think that can be done.
21:46:13 <mmorrow> Peaker: like, say you are a caller of my foo function, and you don't know about its implem, but you know it has type (Int -> Int -> Int). and since i banged the x, the partial application (foo n) has a data-dependency on that x (which is data-dep on n), so x needs to be eval to whnf before i can do anything with (foo n :: Int -> Int), and for huge n, that'll take a non-trivial amount of work
21:46:19 <Warrigal> roconnor: it can be done, yes.
21:46:25 <roconnor> if ZFC is consistent
21:46:59 <Peaker> mmorrow, I understand how "seq" works usefully for the "Int" type
21:47:07 <mmorrow> Peaker: right, but even if x was of type [a], suppose that *that* list is data-dep on *another* non-trivial computation
21:47:47 <Warrigal> roconnor: the thing is, there are multiple ways "elem" can be defined, so this isn't really a statement about natural numbers any more.
21:47:50 <Peaker> mmorrow, Then how do you know if WHNF of the [a] list actually uses the data dep?
21:48:02 <Peaker> mmorrow, maybe the [a] computation is 1:<use of data dep> ?
21:48:07 <pastah_rhymez> how is "forthythird" written with numbers?
21:48:15 * pastah_rhymez is writing comments
21:48:16 <Peaker> or even  <use of data dep>:<use of data dep>
21:48:20 <Warrigal> pastah_rhymez: 43rd, assuming you mean "fortythird".
21:48:23 <mmorrow> Peaker: because arriving at the value of that list depends on the outcome of evaluating this unspecified thing
21:48:25 <roconnor> Warrigal: true
21:48:41 <pastah_rhymez> Warrigal: yeah, sorry, it's 06:49 here
21:48:42 <mmorrow> Peaker: (which is the definition of "data dependency" that i'm using here)
21:48:52 <pastah_rhymez> i've been haskling nonstop for the last 12 hours
21:49:08 <pastah_rhymez> though i did take a break when Transformers was on :)
21:49:08 <roconnor> Warrigal: hmm, do you want to go back to the original issue of contention?
21:49:13 <Peaker> mmorrow, "The value" of that list is technically the outer-most constructor, but typically, the list's dependence on some input might be deeper inside..  Its not usual for functions to take lists and only deal with their outer-most constructor
21:49:21 <mmorrow> Peaker: it'd more be like   (\x -> if x==0 then [0] else [0..])
21:49:21 <Warrigal> roconnor: okay, I sort of give up. I decree that Goldbach's conjecture can be taken as either true or false, depending on what your favorite color is.
21:49:42 <roconnor> Warrigal: I claimed that there was an object truth to the interpretation of first order formulas over the natural numbers.
21:49:52 <Peaker> mmorrow, What if its:  (0:\x -> if x==0 then [] else [1..]) ?
21:49:56 <mmorrow> foo n = case concat (fmap <that above function> [0..1000000]) of [] -> ...; x:xs -> ...
21:50:03 <toast-opt> wait, to haskell is a verb?
21:50:11 <toast-opt> ($) haskell me
21:50:18 <mmorrow> err, sorry
21:50:24 <mmorrow> foo n = case concat (fmap <that above function> [0..n]) of [] -> ...; x:xs -> ...
21:50:28 <Warrigal> roconnor: and now I'm claiming that Goldbach's conjecture is possibly true and possibly false.
21:50:38 <roconnor> Warrigal: but that one is easy
21:50:38 <Warrigal> toast-opt: in American English, everything is a verb.
21:50:46 <toast-opt> ha
21:50:52 <Warrigal> roconnor: is it?
21:50:56 <roconnor> Warrigal: you can write the program ... in haskell even thhat does the search.
21:51:11 <Peaker> mmorrow, are you just using an example where the whole list (including outer-most constructor) depends on something? Of course that makes "seq" meaningful.. But what about cases where the outer-most constructor doesn't have the data-dep?
21:51:12 <toast-opt> warrigal, so i can american english up haskell?
21:51:13 <roconnor> Warrigal: when run on an ideal machine it will either halt or run forever.
21:51:18 <mmorrow> so now that case needs to eval that list to whnf, which in turn depends on eval that [1..n]'s head, which in turn depends on n, which is the incoming arg to fo
21:51:30 <mmorrow> s/fo/foo/
21:51:37 <roconnor> Warrigal: and it doesn't depend on my faviourite colour
21:51:37 <toast-opt> roconnor, half of that sentence was redundant.
21:51:41 <mmorrow> and suppose also that foo n :: Int -> Int
21:51:52 <toast-opt> IF it can be run on an ideal machine, THEN ...
21:51:52 <mmorrow> so (foo 100000 `seq` ()) is non-trivial
21:51:57 <Warrigal> toast-opt: sure.
21:51:57 <roconnor> Warrigal: same thing for "PA is consisenent" or "PA is inconsenent"
21:52:15 <toast-opt> where 'it' is anything
21:52:20 <Warrigal> roconnor: then I'll claim that whether the machine will halt or run forever depends on your favorite color.
21:52:29 <Warrigal> Er, wait, hang on.
21:52:42 <mmorrow> Peaker: then seq might as well be id in those cases, but the fact that it *might* end up doing nothing doesn't make it a-priori the same as id
21:52:49 <toast-opt> ideal machines are pure functions, so cannot depend on warrigal's favorite color
21:52:51 <roconnor> Warrigal: if the machine halts, you are in big trouble :D
21:53:05 <Peaker> mmorrow, Why not use a full normalization instead in those cases?
21:53:08 <toast-opt> unless warrigal is an input, or part of the definition of the ideal machine
21:53:10 <Warrigal> roconnor: I'll just change my opinion if that happens. :-P
21:53:20 <roconnor> Warrigal: let me retract my claim a little
21:53:27 <Warrigal> So, hmm. Intuitively, Goldbach's conjecture is true if and only if there is no disproof of it.
21:53:40 <roconnor> Warrigal: I claimed that there was an object truth to the interpretation of sigma1 and pi1 formulas over the natural numbers.
21:53:42 <roconnor> er
21:53:42 <toast-opt> warrigal's favorite color is the first color alphabetically appearing after the answer that program halts on
21:53:43 <mmorrow> Peaker: because i just want to get my (Int -> Int), i don't care about fully evaluating whatever that depends on only being eval to whnf
21:53:47 <roconnor> Warrigal: I now claim
21:53:49 <roconnor> ...
21:53:59 <mmorrow> err, that sentence was convoluted
21:54:01 <mmorrow> restating
21:54:04 <roconnor> Warrigal: which is sufficent for the arguement about Con(PA)
21:54:13 <roconnor> and goldbach
21:54:26 <roconnor> and fermat's theorem, etc.
21:54:39 <Peaker> mmorrow, I'm not sure I understood your example.. Can you paste it?
21:54:55 <Warrigal> Rather, intuitively, Goldbach's conjecture is (necessarily true) if and only if there is no disproof of it. Gödel's completeness theorem seems to imply that it's (necessarily true) if and only if there is a proof of it. These, together, imply that there is no disproof of it if and only if there is a proof of it.
21:55:07 <Warrigal> This can't be right, so one of my premises is definitely wrong.
21:55:15 <mmorrow> Peaker: because i just want to get my (Int -> Int), and seq'ing it guarantees that i know that the first time i call it it isn't possible for a possibly unbounded amount of work to be done before that (Int -> Int) is even called
21:55:36 <roconnor> Warrigal: Godel's completeness theorem doesn't apply
21:55:38 <mmorrow> Peaker: sure
21:56:25 <junmin> http://dpaste.com/123553/ -- this code take a long time to execute when it receives a list with size = 25, how can i improve it?
21:56:27 <Warrigal> roconnor: what does the completeness theorem apply to?
21:56:55 <Peaker> mmorrow, but in that case, you're using "seq" on a concrete type (Haskell function), where you know what it *means*: That calling that function will not require further evaluation
21:57:08 <roconnor> Warrigal: Godel's completeness theorem is only about logically valid first order sentences.
21:57:37 <Warrigal> Perhaps I should reconsider whether "true" and "logically valid" mean the same thing.
21:57:52 <roconnor> The statement of Goldbach's conjecture is not a logical validity.
21:58:56 <Peaker> mmorrow, Would you ever use "seq" on an abstract type, without fully exposing (leaking?) that fact in your interface doc?
21:59:00 <roconnor> assuming we are working in the language of number theory (plus times zero successor), then the statement of Goldbach's conjecture does not hold in all models of this langauge.
21:59:17 <roconnor> same thing probably works if you want to work in a different langauge.
21:59:42 <roconnor> such as the langauge of set theory.
21:59:43 <Warrigal> I guess I'm tacitly assuming that a statement in a theory is true if it's logically valid that the theory implies the statement.
21:59:59 <roconnor> ah that is not true
22:00:00 <Axman6> junmin: first thing, use where. maxList (x:xs) | oldMax > x = oldMax | otherwise = x where oldMax = maxList xs
22:00:15 <Warrigal> Do we have a nice definition of "true", then?
22:00:53 <roconnor> Warrigal: I think we do, but at least for sigma1 / pi1 formulas I think it is really clear.
22:01:00 <Axman6> Warrigal: \x y -> x
22:01:01 <Axman6> >_>
22:01:12 <mmorrow> Peaker: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5055#a5055
22:01:21 <roconnor> Warrigal: sigma1 / pi1 formulas are questions about whether specific turing machines halt or not.
22:01:22 <mmorrow> Peaker: i don't get how anything leaks
22:01:39 <mmorrow> what's information is leaking?
22:01:46 <Warrigal> I guess I can accept a plain-English definition of whether a Turing machine halts or not.
22:02:16 <roconnor> ah
22:02:25 <Warrigal> Axman6: wow, you've found the secret to truth! I'm amazed.
22:02:25 <mmorrow> Peaker: (i'd consider (->) to be an abstract type, and that's what is being seq'ed in that paste)
22:02:27 <roconnor> <Warrigal> I guess I'm tacitly assuming that a statement in a theory is true if it's logically valid that the theory implies the statement.
22:02:51 <roconnor> I'm not talking aobut if the goldbach conjectiure is true "in a theory"
22:03:25 <roconnor> I'm talking about if it is true "for the natural numbers", not whether it is true say "for all models of PA" or "all models of set theory"
22:03:28 <Peaker> mmorrow, what if foo had been declared: foo n o = ?
22:03:42 <mmorrow> Peaker: but it *isn't*
22:03:50 <Peaker> mmorrow, isn't that an implementation detail?
22:04:06 <mmorrow> yes
22:04:11 <mmorrow> nothing is leaking
22:04:25 <Peaker> mmorrow, Well, "seq" does different things based on an implementation detail -- "foo" leaks to the outside world how it is defined
22:04:44 <roconnor> Warrigal: by theory I assume you mean a recursive set of sentences.
22:04:49 <copumpkin> that's a common complaint about haskell and seq
22:05:06 <Warrigal> roconnor: those sentences being the axioms, yeah.
22:05:08 <mmorrow> Peaker: how do know how it's defined?
22:05:17 <Peaker> mmorrow, Of course, if this is in the same module, you're allowed to share implementation details, but I'd still prefer it done in a different way
22:05:34 <mmorrow> Peaker: prefer what done?
22:05:57 <Peaker> mmorrow, forcing evaluation to a Haskell function value.. (I can't "case" it to a constructor..)
22:06:25 <FunctorSalad> "<Warrigal> Do we have a nice definition of "true", then?" <-- No.
22:06:28 <mmorrow> i don't understand what you're proposing
22:06:28 <roconnor> Warrigal: the true (sigma1 / pi1) sentences of the natural numbers cannot be axiomatized.
22:06:31 <FunctorSalad> :)
22:06:40 <junmin> Axman6: cool!!!
22:06:43 <Warrigal> It kind of seems that Goldbach's falsifiability lends it a sort of plain-English truth value that other statements don't have.
22:06:49 <Axman6> junmin: did that make it faster?
22:07:37 <roconnor> Warrigal: I want to extend this to Pi 2 / Sigma 2 sentences, but it is a bit harder.
22:08:02 <roconnor> Warrigal: do you agree that any given turing machine halts on all inputs or doesn't?
22:08:35 <Peaker> mmorrow, I see why WHNF forcing of functions, specifically (due to the lack of "case" available) is useful
22:09:07 <roconnor> or could that depend on my faviour colour
22:09:28 <mmorrow> Peaker: exactly, it's precisely because they're abstract and that haskell (without bang patterns) is incapable of expressing seq in the language, that it's useful
22:09:31 <roconnor> Warrigal: the whole "on all inputs" is really tricky
22:09:47 <roconnor> that is pretty unclear. :D
22:09:49 <FunctorSalad> no gtk2hs for the new ghc, eh?
22:09:51 <Peaker> mmorrow, Yeah, but then seq ought to have the type :: (a -> b) -> a -> b
22:09:52 <junmin> Axman6: much faster!
22:10:10 <Axman6> junmin: it's still going to be a terribly slow function though
22:10:19 <Axman6> since it's not tail recursive
22:10:30 <Peaker> mmorrow, since use of "seq" on ADTs (algabraic and abstract) leaks their representation details
22:10:39 <mmorrow> Peaker: heh, i'm just using functions as an example of an abstract type
22:11:35 <Warrigal> roconnor: I think I agree, yes.
22:11:43 <roconnor> really?
22:11:53 <Warrigal> An infinite sequence of booleans either contains a "False" or doesn't.
22:12:23 <mmorrow> Peaker: if you want to pass undefined off as a value of some abstract type, then you'll get what's coming to you (imo) :)
22:12:43 <Warrigal> Hopefully I surprised you by agreeing with you.
22:12:52 <copumpkin> halts on ALL inputs, or doesn't?
22:13:08 <roconnor> Warrigal: well then we get an objective truth of P=NP
22:13:08 <mmorrow> and value other than undefined i don't see how seq can leak information
22:13:13 <mmorrow> *and any other ...
22:13:15 <mmorrow> gah
22:13:17 <Peaker> mmorrow, Its not that that bothers me.. its the fact that you should only use "seq" on values in your own module/package, where you are willing to look through the implementation details
22:13:20 <mmorrow> *and any other value than undefined ...
22:13:22 <roconnor> Warrigal: and Reimann Hypothesis.
22:13:52 <c9s_> hello
22:13:54 <Peaker> mmorrow, well, "seq" having the intended effect or not based on a trivial implementation detail, I consider a leak
22:14:16 <c9s_> is it possible to embed haskell interpreter from c code ?
22:14:22 <c9s_> but it must compiled with ghc
22:14:36 <c9s_> can i just use gcc to compile c code ?
22:14:37 <FunctorSalad> well what is leaking?
22:14:46 <Warrigal> roconnor: I'm not sure of either of those.
22:14:51 <mmorrow> Peaker: what situation other than pretending that undefined is a value of some abstract type can anything leak?
22:14:57 <FunctorSalad> AIUI changing definedness can never make a program give the *wrong* answer
22:15:04 <roconnor> Warrigal: not sure if they have an objective truth value?
22:15:08 <FunctorSalad> (only change whether there is an answer)
22:15:11 <Peaker> mmorrow, performance: space leaks
22:15:18 <Warrigal> roconnor: right.
22:15:30 <Peaker> mmorrow, I mean, why not remove all uses of "seq" if there's no apparent effect?
22:15:32 <Warrigal> When I said "sequence", I meant one with finitely many elements.
22:15:53 <roconnor> Warrigal: well if you agree that any given turing machine either halts on all inputs or not, they you agree these mathematics statements have a definite truth value or not
22:16:23 <mmorrow> Peaker: sigh :)
22:16:34 <roconnor> since each of these statements can be translated into a logically equivalent statement about whether or not a specific turing machine halts on all inputs or not
22:16:54 <Peaker> mmorrow, You're having it there to achieve a desired effect. If the achieving of that effect depends on a supposedly hidden implementation detail, how is that not a leak?
22:17:05 <Warrigal> roconnor: are you sure?
22:17:12 <roconnor> Warrigal: mostly sure.
22:17:16 <Warrigal> What's the Turing machine for the Riemann hypothesis?
22:17:33 <Warrigal> It's definitely not one that goes through every real number and checks to see if it's a counterexample.
22:17:39 <mmorrow> Peaker: i understand your point though, and it is a valid point, but imo (i'm grasping for a word)
22:17:55 <FunctorSalad> roconnor: uh AIUI it's only the sigma1-sentences that can be translated like that
22:18:07 <roconnor> Warrigal: no no it isn't that
22:18:18 <mmorrow> ok, rather, let me ask: if you could redesign the language, what would you do with seq?
22:18:29 <Warrigal> roconnor: how about the statement "P = NP if and only if the Riemann hypothesis is true"?
22:18:35 <FunctorSalad> unless you're talking about provability of riemann hyp now, not "truth"
22:18:47 <FunctorSalad> provability can be reduced to a halting problem surely
22:18:53 <Warrigal> FunctorSalad: yeah, it can.
22:18:58 <roconnor> Warrigal: ah oops
22:19:04 <mmorrow> Peaker: make its behavior or applicability dependent on whether a particular type's constructors are exported from a module?
22:19:07 <roconnor> the remann hypothesis is even simplier
22:19:18 <roconnor> does this turing machine halt or not.
22:20:19 <roconnor> Warrigal: okay here we go
22:20:47 <roconnor> we are going to write a machine that checks for each n the following:
22:20:52 <mmorrow> Peaker: that solution is ugly imo (i don't know if that's what you propose yet, though :)
22:21:10 <Peaker> mmorrow, I thought about using type classes only, but your example seems to mean its not possible
22:21:27 <roconnor> Warrigal: let H(n) be the nth harmonic numbers (aka H (n) = sum [1/i | i <- [1..n]])
22:22:17 <mmorrow> Peaker: it just seems to me that seq is a necessary evil, since any way i can think it could be restricted seems to me arbitrary or seems like it cripples seq for "legitimate" uses
22:22:39 <roconnor> Warrigal: check if the sum of the divisors of n is less than or equal to exp(H(n))*log(H(n)) + H(n).
22:22:50 <FunctorSalad> I thought we had the moral equality thing to handle breakage of identities in the face of seq
22:22:54 <roconnor> Warrigal: we are going to check this inequality for all n.
22:23:06 <Peaker> mmorrow, I'm still wondering what this example of yours should look like instead
22:23:09 <Warrigal> roconnor: and that's the Riemann hypothesis? Neat.
22:23:10 <roconnor> Warrigal: we can do this check in parallel
22:23:18 <FunctorSalad> has it been extended to a more expressive type system than in the original paper though?
22:23:22 <FunctorSalad> (e.h. polymorphism)
22:23:22 <roconnor> Warrigal: and the check is semi decidable
22:23:27 * Warrigal nods.
22:23:42 <roconnor> Warrigal: If one of the checks fails, the remann hypothesis is false.
22:23:54 <roconnor> iff our machine halts.
22:23:54 <FunctorSalad> *e.g.
22:24:02 <roconnor> http://rjlipton.wordpress.com/2009/05/27/arithmetic-hierarchy-and-pnp/
22:24:11 <Warrigal> So the Riemann hypothesis is falsifiable.
22:24:16 <c9s_> hello, is it possible to embed a ghc interpreter from c ? i found an exmaple using ghc to compile .c file, but can i compile this with gcc, not through ghc ?
22:25:26 <roconnor> Warrigal: and P=NP is a sigma2 sentence
22:25:53 <Warrigal> I should learn what sigma2 means. :-P
22:25:56 <roconnor> Warrigal: it can be stated as, is there an input such that this machine runs forever.
22:26:10 <Peaker> mmorrow, Functions whose output is even meaningfully "seq"able should be marked as such
22:26:17 <Saizan_> c9s_: the "Foreign Function Interface" let you expose a C interface from haskell code, so i'd say so, though i don't know how the toolchain works wrt this
22:26:19 <roconnor> Warrigal: one last question
22:26:29 <Peaker> mmorrow, or more sanely, values who are meaningfully seqable, should be marked as such
22:26:45 <BMeph> c9s_: If I understand what you're asking, then no. GHC compiles the C program into the Haskell one. It doesn't put an interpreter into the C code.
22:26:49 <Saizan_> c9s_: to evaluate haskell expressions from within haskell look at hint on hackage
22:26:59 <Peaker> mmorrow, Int -> Int -> Int   perhaps replaced by   Int -> Int !-> Int
22:27:02 <pastah_rhymez> one "index", many "indices", or?
22:27:15 <Peaker> mmorrow, or Int -> !(Int -> Int)  or something
22:27:16 <roconnor> Warrigal: given a TM that takes two inputs, it is the case for every first input there is a second input such that the machine runs for ever or not?
22:27:21 <roconnor> Warrigal: is this objective?
22:27:30 <Warrigal> Yes, I'd call that objective.
22:27:51 <mmorrow> Peaker: ooh. yes, i think that would be a solution, reflecting strictness in the type.
22:27:58 <roconnor> okay, I assume if I iterate this an arbitrary number of alternations you will agree that it is an objective statement.
22:28:06 <c9s_> BMeph: cool....
22:28:10 <Warrigal> An arbitrary finite number, yes.
22:28:16 <roconnor> yes, finite number
22:28:20 <c9s_> BMeph: so i can't embed haskell into a c project
22:28:22 <copumpkin> mmorrow, Peaker: I think that's how Clean does it isn't it?
22:28:24 <Warrigal> I'm guessing that's what sigma_n and pi_n do.
22:28:46 <roconnor> in that case, the truth value of every first-order sentence in the language of number theory about the natural numbers is objective.
22:28:53 <roconnor> Warrigal: yep
22:28:59 <Peaker> mmorrow, You'd still have to "seq" it, with ! on the resulting Int -> Int,  otherwise I'm not sure where the evaluation would actually be forced
22:29:06 <mmorrow> Peaker, copumpkin: well, hmm actually in this case i'm not sure exactly the applicability to `foo', but i like that idea in general
22:29:14 <Warrigal> I ought to note these things. Is there a Wikipedia article?
22:29:22 <fujisan> Twey banned me about 8 months ago in february, he banned my hostmask at that time: 'unaffiliated/fujisan', weeks/months later i joined the room after i lost my hostmask, and immediately other people in ##japanese accused me of banevading, but Twey knew i lost my hostmask so according to him i wasnt really banevading, so i kept chatting in ##japanese of and on, but i hadnt been on there for several weeks/months, so today i came in ##japan
22:29:23 <Peaker> mmorrow, but maybe you could only seq:  !a -> a
22:29:24 <roconnor> Warrigal: every first order sentence in the language of number theory is sigma_n or pi_n.
22:29:32 <c9s_> Saizan_: thanks, so is haskage writen in c ?
22:29:39 <roconnor> @google arithmetic heirarchy
22:29:40 <lambdabot> http://en.wikipedia.org/wiki/Arithmetical_hierarchy
22:29:41 <lambdabot> Title: Arithmetical hierarchy - Wikipedia, the free encyclopedia
22:29:54 <roconnor> Warrigal: ^^
22:29:56 <Warrigal> roconnor: I'll take your word for it.
22:29:57 <copumpkin> fujisan: kamawanai
22:30:02 <BMeph> c9s_: You can compile the Haskell separately, and link it later. The FFI describes those details. I'd listen to the others, they seem to understand what you're asking better. I just wanted to be sure your question was answered. :)
22:30:07 <Saizan_> c9s_: haskage?
22:30:12 <mmorrow> Peaker: ah, i'm thinking that (and the way i've seen it meant) is that (!a -> b) means "this function's arg must be evaluated"
22:30:41 <roconnor> Warrigal: this is what I mean by PA + (PA is inconsistent) isn't sound.
22:30:41 <mmorrow> Peaker: rather than "it's possible to evaluate ..." err, how else could that mean?
22:30:42 <fujisan> Twey is a racist
22:30:49 <Warrigal> fujisan: did Twey explicitly say you weren't banevading?
22:30:52 <roconnor> Warrigal: specifically "PA is inconsistent" isn't sound.
22:30:59 <copumpkin> fujisan: even if he is, nobody cares
22:31:02 <fujisan> yes he did Warrigal
22:31:11 <c9s_> Saizan_: ah, sorry. hackage
22:31:11 <roconnor> Warrigal: it claims that the turing machine that searchs for a contradition in PA will halt.
22:31:17 <c9s_> BMeph: thank you :-)
22:31:18 <mmorrow> Peaker: well, i guess it could also be defined to mean "foo /does/ evaluate its first arg", but i'm not sure that'd work
22:31:21 <roconnor> Warrigal: and I claim that isn't true.
22:31:32 <fujisan> copumpkin good thing you are a nobody from irc then :)
22:31:41 <mmorrow> because the first arg could be evaluated or not depending on a runtime value choosing a particular branch in foo
22:31:55 <Peaker> mmorrow, (!a) -> b   vs.   !(a -> b)    but I wanted a type-tag so that when you give stuff to "seq" they are more meaningful
22:32:00 <copumpkin> fujisan: this is #haskell, I'm curious why we would care
22:32:08 <roconnor> Warrigal: actually, even if I am wrong then PA + "PA is inconsient" still isn't sound, because then PA is inconsistent.
22:32:09 <Saizan_> c9s_: no, the hackage server scripts are written in haskell, though i'm not sure how this relates to the rest :)
22:32:24 <fujisan> just remember that Twey is a racist
22:32:29 <fujisan> and a biggot
22:32:32 --- mode: ChanServ set +o Saizan
22:32:34 <fujisan> thats all i want others
22:32:35 <fujisan> to know
22:32:39 <Peaker> mmorrow, (When you give an "a" to seq you have no idea if evaluation is trivial or not. When you give "!a" you get some guarantee from whoever provided the value that seq'ing it does something)
22:32:50 <mmorrow> Peaker: ah, ok. that's different than what i thought you meant at first, but regardless i think something like that is the way to go (wrt seq and in general)
22:32:55 --- mode: Saizan set -o Saizan
22:33:35 <Warrigal> It's annoying when they leave before you can kick thme.
22:33:37 <Peaker> mmorrow, I guess its prettier than specifying actual constructors in "case" for forcing's sake
22:33:43 <johnw> but you can still ban them :)
22:33:45 <Saizan> c9s_: hackage.haskell.org is just a repository of haskell libraries, hint is one that exposes an "eval" function
22:33:48 <copumpkin> @tell Twey you're a racist, apparently
22:33:48 <lambdabot> Consider it noted.
22:33:58 <Peaker> mmorrow, in that sense "seq" is nicer, and if the value provider actually guarantees "seq is meaningful on this" then there's less/no leakage
22:34:12 <Peaker> mmorrow, though maybe a single type-tag is too arbitrarily limited
22:34:18 <mmorrow> Peaker: ohh. so !a you're defining as "evaluation *is* trivial" or isn't trivial?
22:34:24 <Peaker> mmorrow, Yeah
22:34:33 <mmorrow> err, which one though?
22:34:48 <Peaker> mmorrow, !a means its non-trivial, I guess, so seq is meaningful
22:34:55 <mmorrow> ah, ok
22:35:16 <Peaker> So seq has type:  (!a) -> a   and a value of type !b can be used as a b freely (but then no longer seq'd)
22:35:39 <mmorrow> Peaker: hmm, i'm not sure though, since in that paste you can s/(->)/abstract type of your choice/ and it still is using seq to accomplish the same thing
22:35:42 <Peaker> Though that probably sucks, maybe it should be the other way around :)
22:36:19 <Figs> Howdy guys. Are there any (portable) GUI libraries that work decently, support an HTML component, and are installable on Windows?
22:36:20 * Warrigal decides that pi suggests true and sigma suggests falsehood.
22:36:34 <Figs> wxHaskell has been right old pain...
22:36:57 <roconnor> Warrigal: pi is forall, and sigma is there exists.
22:36:58 <Figs> (Although I did eventually manage to get it to install, it won't run without errors...)
22:37:18 <Peaker> mmorrow, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5055#a5057
22:37:58 <mmorrow> Peaker: hmm, yeah that could work
22:38:14 <Warrigal> Falsifiability of a statement means that as long as you fail to make any progress, the statement gets more likely as time goes on.
22:38:15 <Saizan> Figs: gtk2hs should qualify
22:38:33 <Figs> Ok, I'll take a look at it. Thanks.
22:38:53 <Warrigal> I mean...
22:39:04 <Peaker> mmorrow, this forces abstraction implementors to remember to put ! everywhere, whereas today, they leak this so you can just force a library result, knowing how it is implemented
22:39:21 <Peaker> maybe that's a good thing
22:39:25 <Warrigal> If the possible outcomes of probing a statement are "falsify" and "fail to falsify", then every "fail to falsify" outcome makes it more likely.
22:39:30 <roconnor> Warrigal: notice that the Pi 2 / Sigma 2 statements are not falsifiable.
22:39:52 <Warrigal> Yeah, only pi_1 is falsifiable, but pi_2 is close to it.
22:40:15 <Peaker> @index seq
22:40:15 <lambdabot> Prelude, Control.Parallel
22:40:26 <Figs> Saizan: gtk2hs doesn't support -threaded, apparently?
22:40:42 <mmorrow> Peaker: i think reflecting information about evaluatedness and strictness in the type is win-win (in general)
22:40:48 <roconnor> pi_2 says that for all inputs this machines halts.
22:41:07 <roconnor> if it is false then there is some input where the machine runs forever
22:41:11 <mmorrow> Peaker: it contains more information, it allow the compiler to generate better code, ...
22:41:16 <Warrigal> Now I'm wondering if every false pi_2 statement is also sigma_1.
22:41:21 <roconnor> Warrigal: I'm writing this out mostly for my own benifet. :)
22:41:37 <Peaker> mmorrow, Yeah, it sounds like to do it well you might need dependent types though
22:41:41 <Warrigal> I mean, if every false provably pi_2 statement is also provably sigma_1.
22:41:49 <Peaker> mmorrow, If you want to represent something like "how strict you are with your args"
22:42:48 <roconnor> Warrigal: I think you mean to replace sigma_1 with pi_1.
22:42:58 <copumpkin> Peaker: why? would your strictness depend on the values of your arguments?
22:43:11 <mmorrow> Peaker: ah, yeah that could be hard (or at least, non-trivial), but i think having "!a -> ..." mean "i require that my first argument *is* in whnf" would be nice
22:43:24 <Peaker> copumpkin, yeah:  f p x y = if p then case x ... else case y ...
22:43:24 <Warrigal> roconnor: I don't.
22:43:28 <mmorrow> since then, it's up to the caller to evaluate a
22:43:42 <roconnor> Warrigal: If there is a input where the the machine runs forever, then we can write down that input and reduce the problem to a pi1 problem.
22:43:42 <mmorrow> seq :: a -> !a
22:43:55 <Peaker> mmorrow, heh, was just about to ask if that's the exact type :)
22:44:27 <Peaker> mmorrow, Maybe "a" means (may be WHNF, may not be).  "?a" means (NOT in WHNF, and it would take actual non-trivial work to get there).  "!a" means (in WHNF)
22:44:47 <mmorrow> Peaker: right exactly, that's kind of what i'm shooting for
22:44:50 <Peaker> mmorrow, then if a function uses ? in its types, you know "seq" is meaningful
22:44:54 <mmorrow> s/kind of/is/
22:45:01 <copumpkin> seems like you could get around it with some pseudo subtyping between ! and not-!
22:45:38 <mmorrow> Peaker: the only problem i see with this though, is that ? can't 100% prevent false positives
22:45:47 <Warrigal> roconnor: hum, I think you're right.
22:46:13 <mmorrow> foo a b = case a of p1 -> 42; p2 -> case b of p3 -> 9
22:46:20 <Saizan> Figs: the main problem is to get finalizers for gtk objects to run in the proper OS thread currently, afaiu, though i've also read of gtk2hs programs running with -threaded
22:46:22 <toast-opt> oh man, i didn't know you could do compile-time metaprogramming in haskell TOO
22:46:22 <mmorrow> b is conditionally evaluated
22:46:25 <toast-opt> http://www.willamette.edu/~fruehr/haskell/evolution.html#fundep
22:46:37 <toast-opt> that appears to be very similar to some evil C++ templates i wrote once
22:46:46 <mmorrow> so foo could turn `b' from "?b" to "!b", or it might not
22:46:51 <Figs> saizan: How hard would it be to set up a GUI in some other language and have it talk to the multithreaded Haskell instead?
22:46:53 <copumpkin> toast-opt: yeah, you can do all sorts of type-level stuff :)
22:47:07 <Peaker> mmorrow, so it can infer "b" and neither "?b" nor "!b"
22:47:11 <toast-opt> copumpkin, can integers appear in types though?
22:47:26 <copumpkin> toast-opt: not directly, but you can just define type-level naturals or whatever representation you want
22:47:31 <copumpkin> it's reasonably common
22:47:40 <Warrigal> Suppose the problem is "for all X there is some Y for which X eats Y". This is in pi_2, yes?
22:47:41 <toast-opt> copumpkin - yes, but i'd rather do that in haskell proper
22:47:46 <mmorrow> Peaker: ah, i see so no annotation/prefix means "don't know"
22:47:48 <copumpkin> haskell proper?
22:47:59 <toast-opt> yes, i'd rather just use Integers
22:48:11 <mmorrow> Peaker: it'd be interesting to work out/design the details of this
22:48:14 <roconnor> Warrigal: depends on if X eats Y is decidable or not.
22:48:20 <copumpkin> toast-opt: then I guess you're out of luck ;)
22:48:21 * mmorrow haz to disappear
22:48:24 <roconnor> Warrigal: if it is decidable, then yes.
22:48:26 <Warrigal> Yeah, I'll assume it is decidable.
22:48:37 <Saizan> Figs: e.g. communicating via a socket/pipes? not hard i think if you choose a format that's easily parsable on both sides
22:48:39 <toast-opt> so, some way that "Fact 4" be a synonym for the type "Id 24"
22:48:53 <copumpkin> toast-opt: it can be, you just can't use number literals...
22:49:11 <Warrigal> Suppose the statement is false. This means there is some X for which for all Y, X does not eat Y.
22:49:12 <Figs> Saizan: I just want to stop wasting time screwing around rewriting GUI code and get on with the modelling :P
22:49:15 <Peaker> mmorrow, thanks for clearing up "seq", was interesting :)
22:49:27 <toast-opt> instead, i can only have "Fact Succ Succ...(* 4 times *) Zero" be a syn for Succ Succ .. (* 24 times *) Zero
22:49:28 <copumpkin> toast-opt: if anything, I prefer it to having a built-in "magic" integer type like c++ does
22:49:30 <Saizan> Figs: hehe, i can imagine :)
22:49:36 <roconnor> Warrigal: yep
22:49:43 <Figs> Saizan: I've spent a fair bit of my free time over the last three days or so recompiling wx over and over in various ways to try to get wxHaskell to install
22:49:57 <Figs> I eventually found a precompiled version...
22:50:13 <Figs> but, of course, it launches with errors unless you create an invisible notebook :/
22:50:28 <Figs> At that point, I just sort of gave up on it.
22:50:28 <Warrigal> For that specific X, we have the statement "there is some Y for which X eats Y", which is in sigma_1. I don't think this means that the original statement is in sigma_1, though.
22:51:22 <copumpkin> toast-opt: I'd definitely like the idea of a type-level "fromInteger" and Show "kindclass" for types, but that's sugar over the basic ideas, which are still very possible and need no magic kinds built into the compiler
22:51:33 <toast-opt> reconnor - do people define natural numbers for the purpose of doing metaprograms in the type system?
22:51:45 <copumpkin> toast-opt: all the time
22:51:53 <toast-opt> you're kidding
22:51:57 <copumpkin> nope
22:51:57 <toast-opt> really?
22:52:01 <copumpkin> @hackage type-level
22:52:01 <lambdabot> http://hackage.haskell.org/package/type-level
22:52:17 <toast-opt> wow, not kidding
22:52:43 <toast-opt> was this, like C++ template metaprograms, also not originally envisioned by the language designers?
22:52:46 <copumpkin> toast-opt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a8890
22:52:47 <toast-opt> or was this intential?
22:53:08 <ivanm> copumpkin: you're not referring to the recent implementation of an esoteric language in the haskell type level, are you? :p
22:54:21 <copumpkin> toast-opt: not sure whether it was intentional, but the type level is basically a simple logic language and people definitely do program in it :) that paste above is using a recent preprocessor designed to make type-level programming in haskell more pleasant
22:54:55 <copumpkin> ivanm: hah, that too
22:55:07 <toast-opt> copumpkin - it seems like it's really close to being natural though.  i'll have to look around
22:55:16 <Warrigal> roconnor: I'm thinking that pi_(n-1) statements and pi_(n+1) statements both imply certain sigma_n statements. Does this sound right?
22:55:27 <Jafet> Once you write your entire program in the type system, you're sexy enough for coq
22:55:43 <copumpkin> toast-opt: yeah, what you really lose is concise base-10 numbers in your error messages, which is admittedly a pain
22:55:55 <copumpkin> or agda!
22:56:04 <roconnor> Warrigal: depends on what you mean by imply
22:56:11 <ivanm> so if coq is for proofs, what is agda for?
22:56:17 <copumpkin> proofs
22:56:21 <roconnor> Warrigal: they are all either true or false
22:56:21 <copumpkin> and/or programming
22:56:35 <toast-opt> copumpkin - yeah, but i'm already used to reading "list<int_<0>,list<int_<1>, ... >>>>>>>>>"
22:56:36 <roconnor> Warrigal: when talking about the natural numbers
22:56:47 <Warrigal> roconnor: I mean "implies" as in "so obviously implies that I could teach my dog to recognize the fact".
22:56:48 <ivanm> copumpkin: real programming?
22:56:50 <roconnor> Warrigal: and true and false are Pi0 and Sigma0
22:57:00 <copumpkin> toast-opt: still more pleasant than S (S (S (S (S (S (S (S Z)))))))))) though :)
22:57:08 <roconnor> Warrigal: but if you mean logically imply as in A -> B is a logical validity
22:57:11 <roconnor> Warrigal: then no.
22:57:13 <Warrigal> True is pi_0 and false is sigma_0?
22:57:27 <toast-opt> co - couldn't one define addition and subtraction on base 2 at least?
22:57:35 <roconnor> Warrigal: actually they are both both.
22:57:38 <Warrigal> Oh.
22:57:39 <copumpkin> ivanm: sure, it looks and feels more or less like haskell if you don't want to "state" anything about your program, and aren't doing crazy things with laziness (you can still do some of them, it just takes care and sometimes tedium)
22:57:46 <roconnor> Warrigal: since True and False are both decidable.
22:57:46 * BMeph prefers the binary-encoded type to the Z/S version
22:57:51 <toast-opt> Bits (Bits (Bits One) Zero) One)
22:57:52 <Warrigal> Right, right.
22:58:03 <copumpkin> BMeph: it's easier to work with Z/S a lot of the itme though
22:58:09 <ivanm> copumpkin: but is it usable for programming over haskell?
22:58:17 <ivanm> and is there any point to using it?
22:58:22 <copumpkin> ivanm: usable for some definitions of use :)
22:58:22 <ivanm> (rather than haskell)
22:58:25 <BMeph> copumpkin: I'd say that it depends on the nature of the work. ;)
22:58:26 <ivanm> copumpkin: heh
22:58:34 <roconnor> Warrigal: also every Sigma_n statement is also a PI_n+1 and Sigma_n+1 statement
22:58:34 <toast-opt> now, all you need is a haskell to metahaskell compiler, just like C++ needs a C++ to C++ template compiler
22:58:45 <Warrigal> Right.
22:58:50 <copumpkin> ivanm: I wouldn't use it for general purpose programming, but it is capable of compiling down to haskell and interfacing with regular haskell
22:58:53 <roconnor> Warrigal: and every Pi_n is also a Pi_n+1 an Sigma_n+1
22:58:56 <ivanm> *nod*
22:59:06 <roconnor> cause you can always tack on unused quantifiers.
22:59:51 <copumpkin> ivanm: but if you had some haskell primitives and wanted to prove some things about them (making unproven statements about them to build upon, of course) it could be handy for that
23:00:18 <ivanm> copumpkin: so are you _meant_ to program in agda?
23:00:22 <ivanm> or does it just let you?
23:00:44 <pastah_rhymez> ivanm: you aren't supposed to do any acutal coding
23:00:49 <pastah_rhymez> all you do is write proofs
23:00:49 <Warrigal> roconnor: now, if a statement is neither provable nor disprovable, what does this say about the sigma_n and pi_n it provably belongs to?
23:00:53 <Jafet> Proofs are optional in agda, I think
23:00:54 <ivanm> pastah_rhymez: *nod*
23:00:54 <copumpkin> ivanm: it's designed to feel like a regular programming language I think, and it does a decent job
23:00:59 <Jafet> Whereas coq is all about them
23:01:02 <pastah_rhymez> and then, if it typechecks, then you know that your proof is valid
23:01:12 <ivanm> to "feel" but not be a real programming language? :p
23:01:25 <Warrigal> I wonder if Agda is a relatively Haskell-like proof language.
23:01:29 <pastah_rhymez> at least the proof part is all that my friends are working with
23:01:39 <pastah_rhymez> though i LOOOOOOOOOOOOVE mixfix notation
23:01:44 <copumpkin> ivanm: here, this probably feels more or less like regular haskell, with more unicode and more mixfix :) http://www.cs.nott.ac.uk/~nad/listings/lib/Data.List.html#209
23:01:51 <pastah_rhymez> if haskell could have mixfix that would be AWESOM
23:01:54 <Veinor> :O ksf is using ipv6
23:02:12 <Veinor> copumpkin: what is that?
23:02:22 <copumpkin> Veinor: agda's standard library List module
23:02:26 <ivanm> copumpkin: does it feel like Haskell because it just strips out the proof stuff and then pass it to GHC?
23:02:26 <Figs> Alright, thanks all. Cya.
23:02:30 <Veinor> ah.
23:02:40 <Veinor> I kinda like the usage of unicode :D
23:02:45 <copumpkin> ivanm: there aren't any real proofs (beyond the all programs are proof sense) in there
23:02:50 <pastah_rhymez> ivanm: also; note that you have to have emacs to write agdo
23:02:57 <pastah_rhymez> it's pretty impossible otherwise
23:02:58 <copumpkin> oh wait, there are a couple of "proofs" in there
23:03:00 <copumpkin> near the bottom
23:03:02 <ivanm> pastah_rhymez: and that's a problem _why_? :p
23:03:09 <roconnor> Warrigal: I'm not certain I understand, but whether a statement is provable or not in PA has nothing to do with it's possition in the arithmetic heirarchy.
23:03:09 <copumpkin> but the definitions of map/concat/fold are very similar to regular haskell
23:03:36 <roconnor> Warrigal: actually there is a bit of a subtle point here
23:03:37 <copumpkin> pastah_rhymez: I don't normally use emacs but the agda-mode for it is very pleasant
23:03:43 <Warrigal> roconnor: don't provability and disprovability both imply that a statement is both sigma_0 and pi_0?
23:03:48 <ivanm> hmmm, what's with c.h.o? it was down the other day, then came back up, and seems to be down again now...
23:03:56 <Veinor> oh, also: what's mixfix notation?
23:04:26 <copumpkin> Veinor: in agda there's no notion of "operator" that magically gets used infix
23:04:36 <copumpkin> anywhere you write an underscore in a symbol
23:04:44 <copumpkin> it means you'd put an argument there
23:04:46 <pastah_rhymez> enough bad boy-haskelling for me for today
23:04:54 <copumpkin> so if ... then ... else ... is actually a mixfix operator in agda
23:05:03 * pastah_rhymez is done with his code that uses uninitialized arrays
23:05:03 <Veinor> so you can define factorial? :P
23:05:04 <copumpkin> if_then_else_ : Bool -> a -> a -> a
23:05:09 <copumpkin> yep
23:05:10 <Veinor> ooh, that's pretty
23:05:29 <copumpkin> one disadvantage is that you must now put spaces between operators and operands
23:05:32 <copumpkin> everywhere
23:05:34 <copumpkin> but it isn't that bad
23:05:35 <Jafet> What about C FFIs!??
23:06:02 <Veinor> so you can no longer say 2+3? oh no :(
23:06:14 <copumpkin> yeah, it's gotta be 2 + 3
23:06:19 <copumpkin> _+_ : ℕ → ℕ → ℕ
23:06:26 <Veinor> what's that symbol?
23:06:30 <copumpkin> natural
23:06:35 <Veinor> ahh
23:06:38 <copumpkin> I just fished it out of the natural number module
23:06:38 <roconnor> Warrigal: a statement is only Pi_n / Sigma_n if it is logically equiavent to a statement of that form
23:06:42 <Veinor> it's apl all over again!
23:06:54 <roconnor> Warrigal: so Fermat's last theorem is still Pi_1 even though it is proven.
23:07:11 <roconnor> Warrigal: I must admit this makes me hesitate a little about my Reimann Hypothesis claim.
23:07:34 <copumpkin> Veinor: anyway, it can be lots of fun if you're interested and getting bored of haskell's type-level programming :) come to #agda!
23:07:35 <ivanm> copumpkin: so they've taken the "use whitespace since you need it for readability anyway" to the extreme? :p
23:07:38 <roconnor> Warrigal: but none the less if you could prove that that Turing Machine I stated halted or didn't halt, you would be a very famous person. :D
23:07:53 <copumpkin> ivanm: yeah, it's basically a necessity given the complexity of parsing mixfix
23:08:09 <Veinor> :P
23:08:11 <copumpkin> they've also done away with polymorphism
23:08:19 <pastah_rhymez> copumpkin: http://codepad.org/R4cqXfVy
23:08:31 <Veinor> what're some disadvantages of it?
23:08:32 <ivanm> copumpkin: "mixfix"?
23:08:47 <pastah_rhymez> please try it and look at it :)
23:08:50 <copumpkin> ivanm: the mechanism that allows one to define if_then_else_ : Bool -> a -> a -> a
23:09:03 <copumpkin> ivanm: evil parser voodoo
23:09:10 <pastah_rhymez> maybe you'll understand why i didn't want to fill it all with maybes in my arrays
23:09:14 <Veinor> I mean I kind of want to learn it but I also don't want to split my learning between multiple languages :D
23:09:21 <Warrigal> roconnor: it's logically equivalent to T, though, isn't it?
23:09:48 <ivanm> copumpkin: oh, and then the _ get replaced with operations, etc.?
23:09:50 <copumpkin> Veinor: it might help your haskell! probably not though :P
23:09:57 <Veinor> :P
23:10:05 <Veinor> I think I'll stick with haskell for now
23:10:05 <copumpkin> ivanm: yeah, anywhere you put an underscore it expects a parameter
23:10:08 <roconnor> Warrigal: nope, A is logically equivalent to B only when you can prove it using logical axioms only.  No axioms of PA allowed.
23:10:26 <copumpkin> ivanm: so that would allow me to write if p then a else b and it would parse as an application of that if_then_else_ function
23:10:35 <copumpkin> if_then_else_ p a b specifically
23:10:45 <Warrigal> roconnor: oh, okay.
23:10:59 <Warrigal> So sigma and pi, though similar to what I'm looking for, aren't it.
23:12:25 <copumpkin> ivanm: you could for example define congruence modulo something that way
23:12:38 <Veinor> this is tempting me, copumpkin :P
23:12:54 <copumpkin> :D
23:13:12 <Veinor> but like I said, I'm already trying to learn Haskell
23:13:25 <copumpkin> most of what you learn in agda can be applied more or less to haskell
23:13:35 <Veinor> true
23:13:49 <Veinor> also, I don't like having to type unicode in my code :P
23:14:04 <copumpkin> you don't have to :P and the input method in agda-mode makes it painless
23:14:16 * copumpkin is the agda salesman du jour
23:14:28 <Veinor> so tell me why I shouldn't use agda?
23:14:36 <copumpkin> no let
23:14:38 <copumpkin> no case
23:14:59 <roconnor> no let no case?
23:15:01 <copumpkin> quite tedious sometimes :)
23:15:14 <copumpkin> the lack of that syntax
23:15:32 <roconnor> but agda has pattern matching and where clauses
23:15:38 <copumpkin> yep!
23:15:54 <Veinor> I'm guessing it's also used less than haskell?
23:16:14 <jmcarthur> way less
23:16:15 <copumpkin> Veinor: I'd be willing to bet quite a bit of money that fewer than 1000 people have programmed in it
23:16:20 <Veinor> :o
23:16:25 <Veinor> how old is it?
23:16:34 <jmcarthur> agda is not very old
23:17:02 <jmcarthur> dunno exactly
23:17:24 <copumpkin> there used to be an agda 1 apparently, but agda 2 is relatively recent, and is quite different from what I hear
23:17:38 <BMeph> We really need to get chunk into a standard module. It gets re-invented too much. :\
23:17:42 <copumpkin> it's also quite experimental :)
23:17:54 <Veinor> I think I'm going to stick with haskell for now :P
23:17:57 <copumpkin> boo!
23:18:14 <Veinor> :(
23:18:28 <copumpkin> if you learn it within the next 20 days, you'll get TWO difficult things learned for the price of one!
23:18:37 <roconnor> BMeph: it is in Data.Split
23:18:57 <ksf> what do you people think about http://www.impredicative.com/ur/?
23:19:08 <Veinor> hehe
23:19:18 <Peaker> conal, Hey, did you read: http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1012.PDF ?
23:19:31 <copumpkin> ksf: looks interesting, never heard of it
23:20:51 <BMeph> roconnor: Convenient. So, who do we whine at to get split put into Platform 0.4? ;)
23:21:00 <copumpkin> oh it's by Smerdyakov
23:21:11 <ksf> what currently annoys me is that the manual comes with latex-syntax (heck, it's a manual, I want to use it as a reference, not admire its typeset beauty), and way too many typing rules
23:21:23 <roconnor> BMeph: good question
23:21:28 <ksf> also, it suspiciously looks like ml.
23:21:57 <copumpkin> lol
23:22:00 <ksf> but then, they actually generate gc-less binaries from/ the code.
23:22:02 <copumpkin> I'm not surprised
23:22:11 <toast-opt> ML and haskell are the same, right?
23:22:16 <copumpkin> nope
23:22:17 <toast-opt> (ducks)
23:22:18 <copumpkin> lol
23:22:28 <Axman6> toast-opt: completely
23:22:29 <ksf> ml is a syntactical abyss
23:22:36 <ksf> and its not pure
23:22:41 <toast-opt> what about ocaml?
23:22:47 <ksf> otherwise, it's reported to be quite cool
23:22:51 <ksf> ocaml is frensh. and ml.
23:22:55 * copumpkin kicks toast-opt to avoid his duckage
23:23:02 <ksf> it is wrong to be ml, a wise man once said.
23:23:09 <cads> ksf, syntactic abyss? in some precisely definable sense, no doubt?
23:23:12 <rasfar> haskell developed out of lml iirc
23:23:23 <ksf> cads, like, making my eyes bleed.
23:23:33 * copumpkin invokes wadler's law
23:23:43 <ski> copumpkin : Agda 1 has a nice structural editor, Agda
23:23:58 <copumpkin> ski: ah, I think that was way before my time :)
23:24:04 <ski> er, s/, Agda/, Alfa/
23:24:16 <toast-opt> heh, wadler's law, so true
23:24:20 <copumpkin> agda 2 has tentative universe polymorphism!
23:24:26 <copumpkin> (zomg)
23:24:32 <ski> tentative ?
23:24:35 <Sujon> hi
23:24:43 <copumpkin> well, not in a released version, and still rather sketchy :)
23:24:46 <Sujon> sujon
23:24:50 <copumpkin> copumpkin
23:24:57 <ski> ski
23:24:58 <ksf> cads, maybe I shouldnt' think that merely knowing haskell should be enough to be able to at least get the gist of an ocaml program, but the fact that I can't surprises me.
23:25:06 <toast-opt> hello sujon
23:25:07 <Sujon> als
23:25:24 <Sujon> mail/fimale
23:25:34 <Sujon> hello
23:25:36 <toast-opt> i think you might be lost.  can i help direct you?
23:25:38 <copumpkin> lol
23:25:49 <Sujon> yes
23:25:55 <copumpkin> 100% mail in here, sorry
23:25:55 <Sujon> but how
23:26:19 <Sujon> sorry
23:26:27 <Sujon> what you mine
23:26:32 <ksf> also, I'm not sure whether strict functional programming is a good idea
23:26:51 <Sujon> yes
23:27:01 <cads> ksf, I know a little ocaml, and a few other functional languages, and they're all from slightly different schrools of notational style and semantics
23:27:10 <ivanm> mauke: where's that bot of yours?
23:27:15 <toast-opt> strict?  as in statically typed?
23:27:20 <cads> in the case of language like COQ, the difference is big :)
23:27:26 <copumpkin> Sujon: you will not find what you seek here
23:27:40 <Rotaerk_> toast-opt, strict as in non-lazy
23:27:48 <ksf> strict as in eager
23:27:51 <toast-opt> oh, duh, sorry
23:27:52 <Sujon> I am from Bangladesh
23:27:59 <copumpkin> strict as in dominatrix?
23:28:13 <Sujon> you
23:28:19 <ivanm> copumpkin: keep your fetishes to yourself!
23:28:19 <ski> Sujon : when did you start learning haskell ?
23:28:21 <toast-opt> actually, that's why i'm learning haskell in the first place -- lazy evaluation.  well, that and type classes
23:28:37 <toast-opt> otherwise i'd be trying out F#
23:28:45 <Peaker> toast-opt, Type-classes are the awesomeness
23:28:57 <Peaker> Laziness is nice and problematic at the same time
23:29:03 <toast-opt> peaker, that's what i heard.  like, 'the awesome', but more so
23:29:09 <copumpkin> ivanm: what if one of my fetishes is precisely to not keep it to myself
23:29:12 <Peaker> But type-classes are just purely awesome. Not very problematic :)
23:29:16 <Sujon> I fell problem your language
23:29:20 <ivanm> copumpkin: heh
23:29:27 <Rotaerk_> I've resorted to F# myself as a compromise
23:29:34 <copumpkin> Sujon: with haskell?
23:29:44 <Rotaerk_> haskell requires too much more learning for me to be competent enough to do what I want in it
23:29:57 <Sujon> yes
23:29:59 <toast-opt> then why here?
23:30:05 <toast-opt> just curious
23:30:18 <Rotaerk_> though I intend to learn haskell in parallel to my project
23:30:24 <Sujon> I am mail 24yers
23:30:38 <Rotaerk_> male *
23:30:43 <Sujon> yes
23:30:47 <Sujon> you
23:30:59 <Sujon> hi
23:31:00 <toast-opt> computer, pci-e
23:31:13 <Sujon> what u mine
23:31:36 <toast-opt> asl = 2, usb-b, under a desk
23:31:40 <copumpkin> lol
23:31:48 <ivanm> Sujon: I'm not sure if there's something wrong with your connection or something, but everything you say gets here very fragmented and doesn't make much sense
23:31:49 <copumpkin> isn't L = language?
23:31:51 <toast-opt> co, i know, i'm old
23:32:51 <toast-opt> i only get rejects.  my last date, discovered they had an AGP slot!  i don't swing that way!
23:32:59 <Rotaerk_> copumpkin, male, 24, haskell?
23:33:09 <copumpkin> 25 actually :)
23:33:15 <Sujon> I am mail too
23:33:17 <Rotaerk_> whoops got a and s backwards
23:33:27 <Rotaerk_> Sujon, mail and male may sound the same but they're different words :P
23:33:30 <Sujon> ok
23:33:40 <toast-opt> could not infer a -> b, where a :: Gender
23:33:44 <Sujon> sorry
23:33:47 <copumpkin> Sujon: do you need help?
23:33:52 <Sujon> gerder
23:33:58 <Sujon> yes
23:34:00 <Sujon> how
23:34:03 <copumpkin> what is your question?
23:34:21 <Sujon> How can u help
23:34:23 <Sujon> me
23:34:31 <ski> @where tutorial
23:34:31 <lambdabot> http://www.haskell.org/tutorial/
23:34:32 <ivanm> by answering relevant questions
23:34:34 <copumpkin> by answering your question about Haskell the programming language
23:34:38 <ski> maybe you could look there ?
23:34:53 <copumpkin> Sujon: this channel is for programming computers
23:35:06 <Sujon> lessen to me
23:35:08 <Sujon> I am
23:35:13 <Sujon> 24
23:35:19 <Sujon> years boy
23:35:23 <Sujon> and
23:35:24 <copumpkin> yes, we understand that
23:35:25 <Sujon> you
23:35:32 <Sujon> ok
23:35:37 <Sujon> u
23:35:53 <copumpkin> this is not (primarily) a place to make friends online though
23:35:59 <copumpkin> so introductions are not common
23:36:22 <Sujon> have u email
23:36:31 <Rotaerk_> maybe he wants to be email buddies
23:36:34 <Rotaerk_> lol
23:36:40 <copumpkin> rotaerk@gmail.com
23:36:47 <Sujon> ok
23:36:49 <Rotaerk_> >_<
23:36:57 <Sujon> take my email
23:37:01 <copumpkin> Sujon: I lied, that isn't my email address
23:37:03 <Rotaerk_> close but no cigar
23:37:13 <roconnor> @join #haskell.jp
23:37:13 <lambdabot> Not enough privileges
23:37:19 <Sujon> mehedihasan5221@yahoo.com
23:37:21 <copumpkin> roconnor: #haskell.bengali?
23:37:26 <Sujon> it is mine
23:37:34 <roconnor> oh
23:37:49 <Sujon> thake it mail me latter.
23:37:50 <Rotaerk_> Sujon, it's not a good idea to throw your email address around like that
23:38:05 <Sujon> I have to go now friend
23:38:09 <Sujon> oh
23:38:13 <Sujon> lessten
23:38:13 <Rotaerk_> you'll just end up increasing your spam :P
23:38:20 <Sujon> your country
23:38:22 <copumpkin> Sujon: there are 600 people in here, and some are bad people
23:38:25 <Sujon> please
23:38:43 <Sujon> i undesttand
23:38:50 <Sujon> but I am not
23:38:52 <copumpkin> so now bad people have your email address :(
23:39:09 <Sujon> why
23:39:11 <Rotaerk_> mwahaha
23:39:20 <copumpkin> Sujon: you wrote it here, and they can read it
23:39:24 <Jafet> Me Tarzan.
23:39:45 <Sujon> really
23:40:03 <Sujon> hello
23:40:21 <Rotaerk_> Sujon, all 600 people here can see everything you say :P it is a public forum
23:40:37 <toast-opt> ok, on to imperative programming in haskell...
23:40:48 <copumpkin> aw
23:40:52 <Rotaerk_> scared him I guess
23:40:58 <copumpkin> it's times like these I wish I knew all languages
23:41:13 <Rotaerk_> would've gone on to say that it's probably being logged, which means a lot more than 600 people can see what he says
23:41:53 <copumpkin> yeah, I thought about it but figured he wouldn't understand
23:43:11 <toast-opt> learn . map \ (a, b) -> (translator a b) $ [APL..Zscript]
23:43:26 <toast-opt> oh, human langs
23:43:44 <toast-opt> google translate
23:44:17 <copumpkin> not the same :)
23:44:34 <Jafet> Babel fish
23:44:41 <copumpkin> the real one?
23:44:50 <toast-opt> hey, is there an operator precedence list for haskel somewhere, for quick reference?
23:45:48 <copumpkin> in ghci you can type :i (operator)
23:45:52 <copumpkin> but other than that, I don't think so
23:46:05 <Peaker> Dijkstra says he uses infix notation only for associative operators.. that sounds like a nice convention
23:46:23 <toast-opt> so never use . ?
23:46:29 <toast-opt> sorry, (.)
23:46:35 <Draconx> . is associative.
23:46:37 <roconnor> composition is associative
23:46:37 <toast-opt> hmm, something looks off about that
23:46:42 <toast-opt> oh, duh
23:47:08 <toast-opt> so never (-) then?
23:47:20 <ziman> that may be quite unnatural with (-) or (/)
23:47:39 <copumpkin> damn, now we can't use infix operations for ieee 754 floats
23:48:05 <Saizan> that's the real reason we've subtract
23:48:14 <copumpkin> lol
23:49:30 <ziman> i've been reading about iteratees and they resemble parsec to me; am i on the right track or completely off? :)
23:49:35 <Peaker> btw, if only unary (-) existed, then 5 + -3  would resolve the issue :)
23:50:03 <Peaker> ziman, I'd name Iteratee a "Consumer" and an Enumerable a "Producer"
23:50:18 <toast-opt> also, my problem is with precidence.  if one doesn't know if 2*3+1 == 7 or 8, the associative rule doesn't help
23:50:18 <toast-opt> oh, you mean associative as a set of operators.  ie, if (a `x` b) `y` c == a `x` (b `y` c), then don't use parens.  otherwise use parens
23:50:21 <copumpkin> I'd call Iteratee Omnom
23:50:24 <Saizan> *Enumerator
23:50:39 <Peaker> oops, ya
23:50:45 <ski> Peaker : so Dijkstra doesn't say `a - b - c' or `x = y = z' ?
23:51:03 <copumpkin> not sure I'd talk about associativity with =
23:51:12 <Peaker> ski, I'm not sure
23:51:13 <Jafet> = isn't associative?
23:51:13 <Saizan> ziman: in the sense that both are about combinators to consume a stream
23:51:16 <Jafet> Oh, assignment
23:51:23 <ski> equality
23:51:26 <copumpkin> Jafet: even as equality
23:51:40 <Jafet> Well, that depends on how you define equality
23:51:56 <Draconx> = is a relation, not an operator.
23:51:59 <copumpkin> yeah...
23:52:07 <ziman> yes, thanks guys
23:52:17 <Saizan> copumpkin: think about agda's \== :) (with universe polymorphism)
23:52:31 <ski> (a relation can be seen as a proposition-valued function ..)
23:52:47 <toast-opt> hmm, True=True=False is always false, even w/o associativity
23:52:52 <copumpkin> Saizan: yeah :) but then that statement is weird
23:52:57 <copumpkin> and probably not what's intended
23:53:21 <copumpkin> ski: sure, but then x = y = z is weird :P
23:53:27 <roconnor> = is associative
23:53:38 <copumpkin> meaning what?
23:53:58 <rasfar> toast-opt: in Chapter 4 of Haskell Report there is a table.
23:54:00 <ski> (a better example would be `(x * 2) = y + z = 5', maybe)
23:54:10 <Jafet> Equality is usually associative, commutative, and transitive
23:54:15 <Draconx> "(x = y) = z" doesn't make sense, nor does "x = (y = z)".
23:54:17 <Jafet> At least, if you exclude PHP
23:54:21 <roconnor> @check \a b c -> ((a = b) = c) = (a = (b = c))
23:54:21 <lambdabot>   Parse error at "=" (column 15)
23:54:28 <copumpkin> I thought those were called symmetric, reflexive, and transitive
23:54:30 <roconnor> @check \a b c -> ((a == b) == c) == (a == (b == c))
23:54:31 <lambdabot>   "OK, passed 500 tests."
23:54:46 <copumpkin> roconnor: well...
23:54:49 <Jafet> Heh
23:55:10 <copumpkin> roconnor: then you're forcing a b and c to all be booleans / whatever you use to represent truth
23:55:43 <toast-opt> rasfar, thx
23:55:46 <toast-opt> that's very helpful
23:56:16 <junmin> still dont get how use functions as global variable to store something :|
23:56:19 <rasfar> cheers!
23:56:40 <copumpkin> junmin: you can't, unless you're talking about memoizing a value?
23:56:42 <roconnor> junmin: don't use global variables
23:57:19 <Peaker> heh, Dijkstra's paper is explaining all of the f . g . h $ x   conventions #haskell tends to
23:57:24 <junmin> copumpkin: yeah i need to some sort of value
23:57:34 <Peaker> Its from 2000
23:57:36 <junmin> roconnor: what should i do ? :|
23:57:42 <toast-opt> peaker, which paper?
23:58:05 <copumpkin> junmin: restrict the scope of your variable to the people who need it
23:58:08 <Peaker> toast-opt, EWD1300
23:58:08 <roconnor> junmin: localize it's use.
23:58:17 <Peaker> toast-opt, about notations
23:58:21 <toast-opt> thx
23:58:30 <BMeph> Interesting; that Ur dude has his fingers in a lot of tasty pies... ;)
23:58:42 <roconnor> junmin: pass it as a parameter / use a reader monad for those parts that need only read-only access
23:58:58 <roconnor> junmin: use a state monad to sequenc those parts that need write access.
23:59:16 <roconnor> junmin: make it unavailable to those parts that don't need access it it at all.
23:59:36 <roconnor> by using no monad.
23:59:45 <junmin> roconnor: new to haskell, dont know how monad works :s
