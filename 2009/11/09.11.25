00:02:10 <vy> Is it possible to early return from a fold recursion? E.g., consider foldr implementation of takeWhile. It applies predicate over every element of the list even while loop were been broken previously.
00:02:28 <path[l]> Saizan: do you recommend a particular kind of heap profile? hc?
00:03:38 <Saizan> path[l]: you could also add manual {-# SCC annotations to subexpressions of main
00:04:16 <Saizan> path[l]: and yeah, hc is a good start, though hd is also good to find if you've huge thunks sitting around
00:04:42 <Saizan> vy: you can shortcircuit from foldr
00:05:02 <Saizan> > foldr (\x _ -> x) undefined [1..]
00:05:02 <Veinor> vy: yes, if f x y is not dependent on y for certain values of x, then foldr f z xs will short-circuit as soon as it reaches such an x in xs
00:05:03 <lambdabot>   1
00:06:10 <path[l]> Saizan: Ive updated it with the hc profile, could you tell me how to interpret it?
00:06:11 <Polarina> Nice Haskell 2010 is out. :P
00:06:12 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5096
00:07:21 <Saizan> path[l]: it should have produced an .hp file, that you can convert to a graph with hp2ps -c
00:07:33 <path[l]> ah I see
00:07:43 <vy> beibmozoi: Saizan: For instance, will foldr short circuit in here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13147
00:09:03 <Saizan> vy: yes
00:09:20 <Saizan> ?src foldr
00:09:20 <lambdabot> foldr f z []     = z
00:09:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:09:48 <Saizan> the recusive call gets passed as second argument to f, so it won't ever be evaluated unless f uses it
00:10:09 <vy> Saizan: I see! Awesome!
00:10:55 <Saizan> yeah, it is :)
00:11:24 <vy> Ugh! BTW, it is not trivial to see that.
00:12:03 <Saizan> well, it's simple once you get how lazy evaluation works
00:12:20 <Saizan> or do you mean that you need to know how foldr is implemented?
00:14:30 <vy> The former one. Actually, I've always been a lazy student (ofcourse lying), laziness should be an easy concept for me to grasp. Apperantly, this assumption doesn't hold.
00:16:12 <Saizan> ok, lazy evaluation is outermost-first + sharing
00:16:49 <Saizan> we can use double x = x + x to get an example of what that means as opposed to eager evaluation
00:17:02 <Saizan> in the latter:
00:17:10 <Saizan> double (double 5)
00:17:16 <Saizan> -> double (5 + 5)
00:17:21 <Saizan> -> double 10
00:17:29 <Saizan> -> 10 + 10
00:17:31 <Saizan> -> 20
00:17:44 <Saizan> this is when you evaluate the arguments first
00:17:55 <Saizan> now, if you go outermost-first instead:
00:18:01 <Saizan> double (double 5)
00:18:13 <Saizan> -> double 5 + double 5
00:18:32 <Saizan> -> (5 + 5) + double 5
00:18:37 <Saizan> -> 10 + double 5
00:18:42 <Saizan> -> 10 + (5 + 5)
00:18:46 <Saizan> -> 10 + 10
00:18:47 <Saizan> -> 20
00:19:25 <Saizan> you see that we have delayed the computations, but we've also duplicated the evaluation of double 5
00:19:45 <c_wraith> hmm.  I wasn't aware haskell was designed by committee from the very beginning.
00:19:47 <vy> Yup. Same results make people to also assume the same evaluation order, which is not true.
00:19:59 <path[l]> Saizan: is there a place I can upload the two .ps files?
00:20:26 <Saizan> now, lazy eval also has sharing, so it looks more like this:
00:20:36 <Saizan> path[l]: i don't know
00:20:42 <Saizan> double (double 5)
00:20:52 <Saizan> -> let x = double 5 in x + x
00:20:58 <noteventime> path[l]: If you convert it to a pdf you could use google docs
00:20:59 <Saizan> -> let x = 5 + 5 in x + x
00:20:59 <noteventime> I think
00:21:08 <path[l]> hmm
00:21:21 <Saizan> > let 10 in x + x -> 10 + 10 -> 20
00:21:22 <lambdabot>   <no location info>: parse error on input `in'
00:23:18 <noteventime> path[l]: If you're on something modern unixy you probably have something like ps2pdf in your repos
00:23:20 <Saizan> x is basically a place on the heap (or what have you) where to store an unevaluated expression, so all the references can point to it and share the result once it's evaluated
00:23:32 <path[l]> Im on mac os, so I have them in pdf
00:23:37 <path[l]> looking at google docs :)
00:24:05 <vy> path[l]: What do you want to do ps2pdf, or pdf2ps, or?
00:24:35 <kmc> fffej, did you see Data.Sequence?
00:24:50 <noteventime> path[l]: You should be able to upload it there and then turn on document sharing, or something like that
00:25:15 <noteventime> Got to run, bye
00:25:26 <path[l]> ah thanks
00:25:40 <path[l]> wtf google docs wasnt able to upload it
00:34:20 <cathper> I have a list [i1,i2,...,im] and [s1,s2,...,sm], and I want to check if the i's are inside a m-dimensional "stairs shape" with n steps meaning the following: for each pair of ik,il from the i list it must hold that "not ((ik > 1*sk and il > (m-1)*sl) or (ik > 2*sk and il > (m-2)*sl) or ... or (ik > (m-1)*sk and il > 1*sl))".
00:34:30 <cathper> Hints are more than welcome :-)
00:35:50 <cathper> I was thinking about finding the maximum sum of a pair of ik,il since if this pair doesn't make the check false, then none does.
00:37:38 <cathper> If the max-pair is outside, then we're outside. It the max-pair is inside, then we should check the second largest pair etc.
01:05:31 <cathper> Uhm, given a list, how do I get a list of all distinct pairs?
01:05:55 <cathper> distinct in the sense of not distinct content, but distinct position ...
01:06:36 <cathper> sequence gives everything; then, I could just drop and take ... but that's not very elegant.
01:06:40 <dibblego> > liftA2 (,) [1,2,3] [4,5,6]
01:06:42 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:07:18 * cathper is looking at liftA2.
01:08:34 <cathper> > liftA2 (,) [1,1,1] [1,1,1]
01:08:50 <lambdabot>   [(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1)]
01:09:47 <LeCamarade> Raise your hand if you refresh http://haskell.org/ghc every five seconds to see if GHC 6.12 has come out yet. Raise your hand, and I'll count.
01:09:53 <cathper> That's just like sequence or (\l -> [(a,b)|a<-l,b<-l])
01:10:12 <cathper> Well, sequence-sih.
01:10:18 <cathper> s/sih/ish/
01:10:40 * LeCamarade awaiteth the coming of the Unicode-Happy GHC to redeem us from éßðfßðfßð-garbling.
01:10:46 <cathper> > (\l -> [(a,b)|a<-l,b<-l]) [1,2,3]
01:10:48 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
01:10:49 * LeCamarade ... Amen.
01:12:32 <Saizan> LeCamarade: cabal install utf8-string or text-icu and stop hammering the server :P
01:12:58 <LeCamarade> Saizan, Those may require me to muck in the code, which I want to avoid.
01:13:08 <dcoutts> LeCamarade: or just wait for the announce email :-)
01:13:09 <LeCamarade> It's a production system.
01:13:46 <LeCamarade> I grep the Haskell Sequence for it, and the IRC logs, and ... the mails (which I'm terrible at following).
01:23:33 <cathper> let seqOther xs = [(snd a,snd b) | a <- xs', b <- xs', fst a /= fst b] where xs' = zip [1..] xs in seqOther [1,2,1]
01:23:37 <cathper> > let seqOther xs = [(snd a,snd b) | a <- xs', b <- xs', fst a /= fst b] where xs' = zip [1..] xs in seqOther [1,2,1]
01:23:39 <lambdabot>   [(1,2),(1,1),(2,1),(2,1),(1,1),(1,2)]
01:24:14 <cathper> Simplifications and beautifications are welcome :-)
01:37:23 <Saizan> > let seqOther xs = [(snd a,snd b) | (a:bs) <- tails xs , b <- bs] where xs' = zip [1..] xs in seqOther [1,2,1]
01:37:24 <lambdabot>   No instance for (GHC.Num.Num (a, b))
01:37:24 <lambdabot>    arising from the literal `1' at <in...
01:38:04 <Saizan> > let seqOther xs = [(snd a,snd b) | (a:bs) <- tails xs' , b <- bs] where xs' = zip [1..] xs in seqOther [1,2,1]
01:38:05 <lambdabot>   [(1,2),(1,1),(2,1)]
01:41:55 <cathper> > let seqOther xs = [(snd a,snd b) | (a:bs) <- tails xs' , b <- bs] where xs' = zip [1..] xs in seqOther [1,0,1,2]
01:41:57 <lambdabot>   [(1,0),(1,1),(1,2),(0,1),(0,2),(1,2)]
01:42:21 <cathper> Then (2,1) and (2,0) are missing ...
01:46:12 <quicksilver> cathper: you want everything except the diagonal?
01:46:41 <janLome> @ty (//)
01:46:48 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
01:47:06 <cathper> quicksilver: Yes.
01:47:37 <quicksilver> > let seqOther xs = [ (a,b) | a <- xs, b <- xs \\ [a] ] in seqOther [1,0,1,2]
01:47:39 <lambdabot>   [(1,0),(1,1),(1,2),(0,1),(0,1),(0,2),(1,0),(1,1),(1,2),(2,1),(2,0),(2,1)]
01:48:01 <Saizan> > let seqOther xs = concat $ [[(a,b),(b,a)] | (a:bs) <- tails xs , b <- bs] in seqOther [1,0,1,2]
01:48:02 <lambdabot>   [(1,0),(0,1),(1,1),(1,1),(1,2),(2,1),(0,1),(1,0),(0,2),(2,0),(1,2),(2,1)]
01:48:42 <janLome> > (\xs -> liftM2 (,) xs xs \\ map (\x -> (x,x)) xs) [1,2,1]
01:48:44 <lambdabot>   [(1,2),(2,1),(2,1),(1,1),(1,2),(1,1)]
01:50:47 <cathper> Oh, cool. I didn't know \\.
01:52:22 <janLome> But this is not efficient.
01:54:48 <Saizan> @let select [x] = (x,[]); select (x:xs) = (x,xs) : map (fmap (x:)) (select xs)
01:54:49 <lambdabot>  <local>:18:63:
01:54:49 <lambdabot>      Couldn't match expected type `[(t, [t])]'
01:54:49 <lambdabot>             ag...
01:55:19 <Saizan> @let select [x] = [(x,[])]; select (x:xs) = (x,xs) : map (fmap (x:)) (select xs)
01:55:20 <lambdabot>  Defined.
01:55:55 <Saizan> > let seqOther xs = [ (a,b) | (a,bs) <- select xs , b <- bs ] in seqOther [1,0,1,2]
01:55:56 <lambdabot>   [(1,0),(1,1),(1,2),(0,1),(0,1),(0,2),(1,1),(1,0),(1,2),(2,1),(2,0),(2,1)]
01:56:14 <Saizan> oh, ops
01:56:49 <Saizan> @let select' [x] = [(x,[])]; select' (x:xs) = (x,xs) : select xs
01:56:50 <lambdabot>  Defined.
01:56:56 <Saizan> > let seqOther xs = [ (a,b) | (a,bs) <- select' xs , b <- bs ] in seqOther [1,0,1,2]
01:56:57 <lambdabot>   [(1,0),(1,1),(1,2),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
01:57:22 * Saizan stops randomly permuting haskell code around
01:57:32 <cathper> Hehe :-)
01:57:51 <cathper> It's nice!
01:58:13 <cathper> I'm trying to learn as much as I can, and alternatives helps a lot :-)
01:59:20 <cathper> janLome: Because of the list comprehension?
01:59:45 <cathper> Or, do you mean that the liftM2 version is not efficient?
02:12:36 <fasta> Is there a way on Windows to say that you want to overwrite a file _without_ caring whether or not someone is already reading it, etc?
02:13:20 <path[l]> wow that took long. Anyone here? I have profile graphs and I want help interpreting it =p
02:13:22 <path[l]> http://rapidshare.de/files/48736714/buttonshc.pdf.html
02:13:37 <path[l]> http://ul9.rapidshare.de/cgi-bin/upload.cgi?rsuploadid=205874794247336911
02:13:47 <path[l]> http://rapidshare.de/files/48736718/buttonshd.ps.html
02:14:48 <dcoutts> fasta: it depends on how the other program has the file opened I think
02:14:56 <prof_nimnul> fasta: it's an offtopic question. If everybody opens the file in SHARE_WRITE mode, you can still write.
02:15:31 <dcoutts> fasta: if they've specified the SHARE_DELETE (or similar flag name) then you can delete or rename another file on top it while they still got it open
02:15:37 <cathper> My "outside" function: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5097#a5097
02:15:40 <prof_nimnul> fasta: The problem here is that people either don't care or just cannot control the mode from within their language
02:15:48 <dcoutts> SHARE_DELETE is distinct from SHARE_WRITE
02:15:49 <fasta> dcoutts: In this case I want to overwrite a dynamic library, currently in use.
02:15:59 <cathper> (Regarding the stairs thingy ...)
02:16:10 <dcoutts> fasta: my guess is you probably cannot
02:16:13 <prof_nimnul> fasta: You can look at Vista restart manager API
02:16:24 <fasta> dcoutts: that way I can keep the application running, and reload the dll.
02:16:36 <prof_nimnul> fasta: sometimes you can rename original library and put new file with the same name
02:17:19 <dcoutts> prof_nimnul: I think that relies on the SHARE_DELETE thing
02:17:20 <fasta> prof_nimnul, not in this case.
02:18:06 <fasta> prof_nimnul, thanks for the SHARE_DELETE information.
02:18:22 <prof_nimnul> fasta: It wasn't me but dcoutts
02:19:01 <prof_nimnul> fasta: Oh, if you wrote application yourself, there's special API for live patching
02:19:30 <prof_nimnul> fasta: Designed for cases like yours when you need to patch app while it's up and running
02:21:29 <prof_nimnul> fasta: it's called hotpatching and available since win2003 (and xp x64 of course)
02:21:32 <prof_nimnul> http://technet.microsoft.com/en-us/library/cc781109%28WS.10%29.aspx
02:24:18 <path[l]> anyone? I really need to find a way to reduce my gc time from 60%
02:24:34 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5096
02:25:18 <Saizan> path[l]: the graphs are the memory use over time
02:26:17 <path[l]> ah I see. But Im not sure how to use that to start narrowing down the issue
02:27:57 <Saizan> mh, hd tells us that all your memory is made of lists, it seems
02:28:33 <path[l]> really?
02:28:40 <path[l]> oh
02:28:43 <path[l]> black is :
02:28:44 <path[l]> ok
02:28:46 <path[l]> so no thunks
02:29:16 <fasta> prof_nimnul, I don't see SHARE_DELETE defined anywhere as an argument to something opening a file.  I would have expected it to be documented near fopen.
02:29:52 <path[l]> hmm so in that case whats the next obvious step? Am I creating temporary objects?
02:29:59 <quicksilver> path[l]: make your nursery bigger.
02:30:15 <path[l]> whats that? Is it a compilation flag?
02:30:20 <quicksilver> no, a runtime flag.
02:30:20 <path[l]> or can it be done in code
02:30:46 <path[l]> is there a directive I can use in the code? Im submitting this code to an online contest thing that compiles and runs it
02:30:47 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
02:30:48 <Saizan> how big are the test cases? maybe you should use ByteString
02:30:57 <quicksilver> path[l]: no. You're screwed in that case.
02:30:57 <path[l]> hmm good point
02:31:09 <quicksilver> path[l]: online contests are all hopelessly biased and broken.
02:31:21 <path[l]> the test cases are upto a million bits
02:31:41 <path[l]> quicksilver: heh what do you mean specifically?
02:31:53 <quicksilver> online contests have arbitrary rules
02:32:15 <quicksilver> the arbitrary rules, by their very arbitrary-ness, always affect some compilers / interpreters / runtime systems in different ways to others
02:32:24 <quicksilver> so they develop bias, intended or otherwise.
02:32:34 <path[l]> ah
02:32:55 <quicksilver> then, often, the rules get altered by lobbyists, so the bias slants in favour of the most vocal groups :)
02:33:10 <nvoorhies> what about contests to write compilers that generate unbiased contest rule set?
02:33:17 * medfly notes that it still is an online contest
02:33:18 <path[l]> lol
02:33:27 <quicksilver> still, I think it's fair to say that a million-item-list is fairly memory inefficient in haskell
02:33:37 <quicksilver> you may want to consider other approaches
02:33:46 <quicksilver> it also depends what you are actually doing with the list - I didn't look hard at your code.
02:34:02 <nvoorhies> yeah, just find the fixed point of that baby and bam, we achieve justice for all mankind in our time
02:34:26 <path[l]> well essentially I pick up row by row (so 1000 items at a time) and then I have to compare it against a different thousand items
02:34:32 <nvoorhies> yet another thing haskell can do, which should no doubt be added to the FAQ
02:34:43 <path[l]> will I gain by switching from List of Int to List of something else?
02:34:51 <RAndrew> path, btw, (\y -> do a <- getLine ;return a) = getLine ^^
02:34:52 <path[l]> List of byte maybe
02:35:11 <quicksilver> path[l]: no.
02:35:26 <path[l]> huh? sorry could you explain that a bit more please RA?
02:35:32 <path[l]> RAndrew
02:35:51 <Saizan> path[l]: btw, you're reading everything in memory up front, maybe it'd help to read as needed
02:35:59 <RAndrew> look in ur code str 93-96
02:36:08 <Saizan> RAndrew: (\y -> do a <- getLine ;return a) = \y -> getLine, actually
02:36:41 <Saizan> path[l]: "do x <- m; return x" is always the same as just "m" by the monad laws
02:36:41 <RAndrew> \y -> getLine = \_->getLine = getLine ?
02:36:56 <Saizan> \_ -> x is never equal to x
02:36:57 <quicksilver> RAndrew: no, because \_->getLine takes a parameter and getLine doesn/t
02:37:10 <quicksilver> :t \_->System.IO.getLine
02:37:12 <lambdabot> forall t. t -> IO String
02:37:18 <quicksilver> :t System.IO.getLine
02:37:20 <quicksilver> different types :)
02:37:20 <lambdabot> IO String
02:37:53 <Saizan> (well, maybe with enough polymorphism it might be the same)
02:37:53 <path[l]> Saizan: huh? how do I read as needed? I thought that would happen automatically because of laziness
02:38:14 <RAndrew> oh, write
02:38:22 <RAndrew> right evem :)
02:39:06 <sohum> :t return 1 :: a -> b
02:39:06 <Saizan> path[l]: IO effects are not lazy by default, hGetContents is lazy because it uses unsafeInterleaveIO
02:39:08 <lambdabot>     Could not deduce (Num b) from the context ()
02:39:08 <lambdabot>       arising from the literal `1' at <interactive>:1:7
02:39:08 <lambdabot>     Possible fix:
02:39:15 <Veinor> :t return 1
02:39:18 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
02:39:47 <sohum> :t return 1 :: a -> Int
02:39:48 <prof_nimnul> path[l]: You can also try newer GHC :-) IO module is not in 6.10.4, so you are obviously using an older one
02:39:49 <lambdabot> forall a. a -> Int
02:40:04 <sohum> :t return 1 :: Int
02:40:05 <lambdabot>     Couldn't match expected type `Int' against inferred type `m t'
02:40:05 <lambdabot>     In the expression: return 1 :: Int
02:40:12 * sohum nod
02:40:25 <sohum> is (->) the reader monad?
02:40:28 <Saizan> prof_nimnul: it is! http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/IO.html
02:40:43 <Saizan> ((->) r) is
02:40:54 <sohum> right, makes sense
02:42:14 <EnglishGent^afk> http://developers.slashdot.org/story/09/11/24/2120246/Haskell-2010-Announced?art_pos=12 -- Haskell 2010 officially announced
02:42:15 <EnglishGent^afk> :)
02:43:24 <medfly> yeepie
02:43:27 <path[l]> I have to code towards ghc 6.10.1
02:43:30 <sohum> is it just me, or is Haskell '10 not that big a change?
02:43:35 <quicksilver> path[l]: that thing you call laziness is not laziness.
02:43:45 <medfly> well
02:43:47 <medfly> Wed Nov 25 12:46:24 IST 2009
02:43:48 <quicksilver> path[l]: that thing is "interleaving of IO actions with evaluation"
02:43:52 <medfly> I can see why...
02:43:59 <medfly> ^^
02:44:00 <quicksilver> the analogy with laziness is strong, of course, which is why the word is used.
02:44:02 <path[l]> quicksilver:  ah I see
02:44:04 <quicksilver> but it's a different thing.
02:44:07 <prof_nimnul> sohum: backward compatibility is broken with each release
02:44:20 <mercury^> sohum: a disappointment, yes (but that was clear early on)
02:44:21 <Saizan> path[l]: i'd probably use Data.ByteString.Lazy.getContents to get the full input "lazily" as a single bytestring and split it up with lines/words/etc.. as needed
02:44:29 <fasta> quicksilver, everyone calls it lazy I/O, no?
02:44:38 <prof_nimnul> sohum: IO seems to be renamed to System.IO
02:44:42 <sohum> prof_nimnul: right, with things like no n+k patterns, but still, there's /not/ that many changes
02:44:48 <sohum> mercury^: it was?
02:44:52 <path[l]> medfly huh?
02:45:02 <quicksilver> fasta: I am a one-man campaign to change terminology.
02:45:04 <mercury^> sohum: if you visited trac a few times, yeah
02:45:08 <quicksilver> fasta: my life would be so dull without crusading.
02:45:09 <netinho2lol> sup people from haskelland
02:45:09 <mux> haskell 2010 is a good starting point I say
02:45:11 <path[l]> Saizan: hmm ok, I guess I need to look it up and see how it work
02:45:21 <sohum> mercury^: *nod*
02:45:30 <fasta> quicksilver, you should start at a DDOS attack on wikipedia then and some infiltration.
02:45:32 <prof_nimnul> sohum: not many, but my programs and I believe most non-trivial programs break with each release :)
02:45:42 <EnglishGent> hello :)
02:46:02 <path[l]> Saizan: I dont understand. That thing isnt in the IO monad?
02:46:04 <netinho2lol> I am reading the hutton book and it says that to clear the screen you have to do putStr "\ESC[2J"
02:46:51 <netinho2lol> this works everywhere?
02:47:23 <Veinor> I dunno if it works on cmd.exe, but I know it works on any reasonable modern terminal
02:47:44 <Saizan> path[l]: getContents :: IO ByteString
02:47:46 <prof_nimnul> path[l]: try to cabal install hlint and run hlint against your source. It found 15 things worth to refactor.
02:47:55 <medfly> path[l], I'm just making a joke. Haskell 2010 isn't so different because it's almost 2010. ;)
02:48:17 <Saizan> path[l]: but it delays the reading via unsafeInterleaveIO, so the input is read in as your program demands it
02:48:35 <path[l]> ah I see. ok let me try both those things
02:48:44 <path[l]> hlint and then getContents with ByteString
02:48:48 <mercury^> What does it use "under the hood" by the way?
02:48:50 <prof_nimnul> path[l]: things like replacing concat . map with concatMap can help a lot
02:48:53 <mercury^> mmap or read?
02:50:09 <netinho2lol> Veinor: what is the story of that escape character? [2J ?
02:50:16 <Veinor> netinho2lol: vOv
02:50:33 <Veinor> well, i dunno if it's that specific one, but it looks about right
02:50:43 <mux> it looks like an ANSI escape sequence
02:51:05 <quicksilver> fasta: good idea.
02:51:33 <quicksilver> prof_nimnul: I really hope not.
02:51:40 <quicksilver> prof_nimnul: that should never make any difference surely.
02:52:07 <prof_nimnul> quicksilver: optimizer may have a rewrite rule for shorter sequence
02:52:43 <path[l]> ok installing hlint
02:52:53 <mux> concat . map and concatMap really should end up generating the same code
02:53:39 <quicksilver> prof_nimnul: they inline to the same thing though
02:53:59 <quicksilver> under GHC fusion I think they inline to a foldr/build
02:54:09 <quicksilver> presumably something else under stream fusion.
02:55:38 <prof_nimnul> path[l]: unfortunately hlint doesn't help in your case
02:55:58 <prof_nimnul> path[l]: doesn't offer anything significant
02:56:45 <path[l]> :/
02:57:30 <fasta> It is amazing that GHC on x86 runs as fast as the rest (or as slow as the rest) given that it only has one register free for inner loops.
02:58:34 <path[l]> so my options are lazy io and memory footprint. let me start reading up on lazy io then
02:58:37 <path[l]> thanks prof_nimnul
02:59:24 <quicksilver> I doubt it's the IO
02:59:30 <quicksilver> you say you're 60% GC time
02:59:30 <fasta> path[l], the thing is: if you want any piece of code (in any language) to run fast, you have to get rid of indirections.
02:59:47 <fasta> path[l], so, lists are more indirect than arrays for example.
03:00:00 <path[l]> hmm
03:00:28 <path[l]> so you're suggesting I create an unboxed array at start and do everything using that?
03:00:30 <fasta> path[l], now, in GHC mutable arrays don't go well together with GC, but I have the impression they try to improve on that.
03:00:38 <fasta> path[l], it just depends on the goals.
03:01:09 <fasta> path[l], if you want the absolute fastests program, you might better just implement your own code-generator ;)
03:01:12 <path[l]> quicksilver: well I only operate on 1000 things at a time in a million such pieces. So if I do IO, operate on the 1000 and then don't use it, I guess the gc could collect it?
03:01:27 <path[l]> nah I just wanna pass the contest =p
03:01:47 <fasta> path[l], well, first fix your algorithm, then do cache optimisations.
03:01:53 <prof_nimnul> fasta: lists don't necessarily mean indirections as they may be fused out
03:02:24 <fasta> prof_nimnul, I know that, but it is not obvious to know that without looking at the core output (which I think is hideous).
03:02:34 <path[l]> yeah true, but I think the algorithm is the right one. I mean it seems like what I'd use.
03:02:49 <path[l]> The only thing is I dont have to hold all million pieces in memory
03:02:49 <fasta> prof_nimnul, in _principle_ you can write everything with LogicT. In practice nobody does that.
03:02:52 <prof_nimnul> fasta: I doubt anyone besides mr. Marlow can optimize haskell progs to the point where cache optimizations are needed
03:02:52 <path[l]> just 1000 at a time
03:03:40 <path[l]> after all I do rows = chunks 1000 string and then operate on the head of rows and then I map across the tail
03:03:59 <path[l]> so if there's a way rows could be loaded through lazy IO and the gc could collect old rows maybe
03:04:21 <Saizan> that's what you should get with getContents
03:04:45 <Saizan> the String version should already help
03:04:55 <Saizan> the ByteString one should use even less memory
03:06:02 <path[l]> hmm
03:06:14 <Saizan> what's your doubt?
03:06:16 <path[l]> also since my lists only have 0s and 1s
03:06:20 <path[l]> can I use a list of something
03:06:30 <path[l]> no its just syntax, Im new to haskell =p
03:08:49 <Saizan> you could convert those to Bool, or your own Bit datatype, not sure if it'd save memory
03:09:14 <path[l]> yeah
03:10:28 <Saizan> you could use an UArray of Bool, they are bit-packed so 1-million elements will only use 1mb
03:11:26 <Saizan> but any update is O(n), unless you use IOUArray, but then you're stuck in the IO monad
03:12:21 <path[l]> ah I see
03:12:29 <fasta> For complete control and safety, use ST.
03:12:36 <path[l]> Ill try it anyway. First with a list of Bool
03:12:40 <path[l]> and then see how things go
03:12:42 <fasta> But I doubt you actually need it in these competitions.
03:12:51 <fasta> path[l], which competition is it?
03:13:08 <path[l]> codechef.com which is based on spoj
03:13:22 <path[l]> Im solving the "buttons" problem
03:13:31 <path[l]> which is actually supposed to be really easy
03:14:35 <fasta> path[l], do you have a direct link?
03:14:48 <path[l]> sure sec
03:15:09 <path[l]> http://www.codechef.com/problems/BUTTONS
03:15:16 <fasta> path[l], google already found it.
03:15:27 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5096 <--- this has my code and an explanation of my algorithm
03:17:32 <fasta> path[l], what does time-limit "s" mean?
03:17:48 <path[l]> isnt that 5 seconds
03:18:04 <path[l]> oh
03:18:06 <path[l]> its a typo
03:18:09 <path[l]> it should be 5
03:18:45 <path[l]> I actually have the testcase downloaded. And on my machine it runs in 2.5 But on their machine it goes over since the specs are much lower. P3 or something
03:24:19 <ketil> What is the currently recommended way to have a fast 2d-array in Haskell?  Is it still (ST,IO)UArray?
03:28:26 <fasta> path[l], the actual problem can be solved in a greedy way, right?
03:29:06 <path[l]> umm Im not sure. This is the only solution I know.
03:29:44 <fasta> path[l], I haven't seen your code, but otherwise it would never be possible to get it to run in 5 seconds.
03:30:14 <path[l]> oh well um I have an O(n^2) algorithm (where n is one side)
03:30:20 <path[l]> so its not exponential or anything
03:30:36 <path[l]> so it's the order of the number of points
03:31:45 <lavish> sohum: np :P
03:33:46 <path[l]> Saizan: so I just replace readLine with hgetContents?
03:33:56 <fasta> path[l], if I understand the problem correctly, you solved the wrong problem.
03:34:08 <path[l]> huh really?
03:34:18 <fasta> path[l], but submit it, and if it works, I am wrong.
03:34:37 <path[l]> well it gives me the right answer on all the tests people have posted
03:34:45 <path[l]> it just loses on time
03:34:47 <path[l]> it takes too long
03:34:52 <Saizan> path[l]: getContents will give you the whole input to the program, not just a line, but you can use "lines" to chop it up
03:35:24 <path[l]> oh I see ok
03:35:24 <path[l]> got it
03:35:40 <fasta> path[l], why would the minimum number start with pressing
03:36:17 <fasta> path[l], ignore that last, why would this strategy lead to the minimum amount of flips? "Take the first row, flip all columns till the row is right. "
03:36:47 <path[l]> fasta: no it's like this. Either the first row is flipped or it's not. I first find the number of flips if the row is flipped
03:37:02 <path[l]> at the end once I know that I can calculate the number of flips if the first row is not flipped
03:37:20 <path[l]> which is why I calculate min of flips and rflips. Where rflips is calculated using flips
03:37:26 <fasta> path[l], ah, so you are doing dynamic programming?
03:38:14 <path[l]> well I guess, Im bad with terminology =p. But this idea makes perfect sense.
03:42:55 <path[l]> @ hgetContents
03:44:17 <path[l]> oh I need a handle first
03:44:27 <Axman6> use getContents
03:45:02 <ksf> ketil, getting ghc 6.12 and using dph?
03:51:04 <path[l]> is there a string to Int cast?
03:51:48 <Saizan> if you want "123" -> 123 then there's read
03:51:52 <path[l]> ah yes
03:51:53 <path[l]> thanks
03:52:40 <Axman6> there is no casting in haskell!
03:52:56 <Axman6> (unless you play with messed up libraries
03:53:17 <path[l]> yeah sorry, wrong term
03:54:23 <fasta> path[l], what does your program do on input: 111111111111111111111111111111111<newline> just as many zeros? It seems that your solution will switch all the columns, while there is a solution requiring only one switch.
03:55:16 <path[l]> fasta: umm its always a square matrix. So is that the entire thing or one row?
03:55:56 <fasta> path[l], ok, then take a square matrix where the first row consists of ones and the rest are zeros.
03:56:27 <path[l]> on (1 1 1, 0 0 0, 0 0 0) -> (0 0 0, 0 0 0, 0 0 0) it will detect 1 instead of 5
03:56:51 <fasta> path[l], that is not what you comment states.
03:57:17 <path[l]> it'll first find 5, but then from 5 it detects that it can solve it in 1. So it finds 1
03:57:45 <path[l]> this happens in the totalFlips function where I do a minimumBy
03:58:08 <fasta> path[l], and this minimumBy is done over what?
03:59:18 <path[l]> so Id have 5 as ([1, 1, 1], [0, 1, 1]). From which it generates ([0,0,0],[1,0,0]) and it takes the minimum of the two tuples by the one where the number of 1s is least
03:59:28 <path[l]> it just sums it up really
03:59:53 <path[l]> it calculates its 3 + 2 compared with 0 + 1
04:17:41 <aleator> Hi. If I'm making a cabal package that contains ffi and c header foo.h, I should add "includes: foo.h" to cabal file, right?
04:18:09 <ivanm> I think so
04:18:39 <ksf> as a rule of thumb, do whatever makes it compile+run without rolling a custom Setup.hs and you're fine.
04:18:56 <aleator> It says "missing header file: foo.h". foo.h should be in the same path that .cabal, right?
04:19:14 <aleator> ksf: ah, thats my problem :) It doesn't.
04:19:20 <int-e> aleator: you can specify a directory with include-dirs:
04:19:22 <ksf> I think includes takes a directory
04:19:31 <ksf> listen to int-e.
04:19:36 <ketil> ksf: that is an option.  I'll take a look.
04:20:22 <ksf> but I think you want to use includes, anyway, or cabal sdist won't work right.
04:20:43 <ketil> Currently, I've been trying to sort out {u,storable,}vector, but they appear to be 1D and/or designed for streaming.
04:21:43 <aleator> int-e: Ah. I probably got my directory structure wrong. If I place the .h and .cabal in same dir, what should I put in includes or include-dirs?
04:22:08 <ksf> you should be able to make anything that takes an Ix n-dimensional, but granted the array api is a pita.
04:22:19 <dcoutts> aleator: if the .h is in the top level dir then use "include-dirs: ."
04:23:25 <dcoutts> aleator: includes says what headers are needed by the package (which might be local headers, or from the system)
04:23:26 <aleator> dcoutts: Hmm. Does not work either. (Missing header..)
04:23:45 <dcoutts> include-dirs says where to find them, again, on the system or within the build tree
04:23:56 <dcoutts> aleator: it'll also say that if the .h file cannot be compiled
04:24:09 <dcoutts> the error message is misleading in that situation
04:24:38 <aleator> Hmm.. I do compile it manually ok. Does cabal have any verbose flag to let me see if that is happening and how it is trying to compile it?
04:24:50 <dcoutts> yes -v3
04:25:18 <path[l]> Saizan: that made no difference Im afraid. I still take the same time http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5098
04:25:36 <dcoutts> aleator: it makes a .c file that #includes the files you specify in the includes field from the .cabal file
04:25:59 <dv_> has anybody ever tried to use haskell as a scripting language?
04:26:34 <aleator> dcoutts: Thanks! I couldn't have made it work without your help!
04:27:05 <path[l]> gc time came to about 45 seconds thats about it
04:27:11 <int-e> aleator: . ? But I would expect that to be included by default actually.
04:27:22 * int-e reads what dcoutts wrote
04:28:07 <path[l]> hmm wow my memory graph is wayyy different
04:28:23 <path[l]> instead of one big spike I have a super saiyan hairstyle as a graph
04:28:25 <dcoutts> int-e: no, '.' is not on the include path by default
04:28:25 <path[l]> all spiky
04:30:15 <int-e> dcoutts: yes. that's reasonable, just not what I expected.
04:30:56 <ksf> dv_, works fine.
04:31:07 <ksf> add #!/usr/bin/runhaskell
04:31:19 <ksf> ...or /usr/bin/runghc or runhugs
04:31:30 <aleator> dcoutts: One more silly question if I may. What is the preferred way to specify .h files for .chs sources in cabal?
04:31:46 <path[l]> http://rapidshare.de/files/48737313/buttonshclazyio.pdf.html
04:31:56 <path[l]> http://rapidshare.de/files/48737317/buttonshdlazyio.pdf.html
04:32:33 <ksf> aleator, include-dirs should be enough.
04:33:05 <dcoutts> aleator: inside the .chs files themselves
04:33:45 <ksf> ...It appears I'm using include-dirs and then extra-source files
04:34:08 * ksf wonders why his header is suffixed .in.h
04:34:51 <benmachine> so I'm wondering what surfaceGetPixels in SDL is for - it returns IO Pixels, where Pixels is not an exported datatype nor can I find any functions to manipulate it
04:36:09 * benmachine is trying to write a program which does interesting things to each pixel and would be interested in any suggestions for a better graphics library, too
04:37:52 * ksf makes a mental note to make less unessesary hacks, anymore.
04:38:05 <ksf> like, not decrufting trivial things.
04:38:09 <nvoorhies> Pixels is probably a pointer to a section of memory that means different things in different pixel formats, if it's like the way I remember SDL's c api working
04:38:22 <benmachine> nvoorhies: yeah, sounds about right
04:38:34 <nvoorhies> but they're in scanline order and tightly packed I think
04:38:41 <benmachine> looks like I can lock and unlock the surface too
04:38:48 <benmachine> buuut then what
04:39:03 <aleator> dcoutts: Thanks. And there is no reasonable way of having more than one cabal package per dir?
04:39:04 <benmachine> (from haskell, I mean)
04:39:10 <ksf> you should be able to get a Ptr out of the surface.
04:39:21 <dcoutts> aleator: no, that's not supported currently
04:40:00 * ksf recommends against using SDL surface to manage your pixels
04:40:11 <benmachine> what do you recommend?
04:40:29 <benmachine> this is not something I've done before really
04:40:35 <benmachine> apart from silly things in C with allegro
04:41:02 <ksf> depends on what you need to do
04:41:19 <ksf> sdl is quite limited when it comes to e.g. proper blending and stuff
04:41:28 <benmachine> well I'm just making a toy as it were
04:41:37 <ksf> ...and the algos to do that are quite easy to write
04:42:10 <ksf> (provided you're comfortable with working with Ptrs)
04:42:24 <benmachine> I'm not, yet
04:42:56 <benmachine> all I want is some pixels to fiddle with
04:43:03 <benmachine> doesn't have to be fast or anything
04:43:59 <benmachine> if there is no easy way to do that then I suppose I will learn about Ptr and so forth
04:44:03 * ksf wonders whether vanilla arrays would have the right layout to be used as surfaces
04:44:03 <benmachine> which I should probably do anyway
04:45:16 <dv_> ksf, what other layout is there?
04:45:16 <ksf> there's malloc/alloc, plusPtr, peek and poke, and that's all there is to it.
04:45:27 <dv_> packed pixels are the most comfortable layout there is.
04:46:20 <ksf> well, I couldn't use the data freetype gave me directly, because of negative row strides and such punk.
04:46:44 <dv_> that said, its wise to put a layer above that for pixel manipulation. kinda like the adobe GIL package that allows for different traversal types and metaprogramming extras
04:46:46 <ksf> that is, I don't know how eg. a UArray is layed out in memory.
04:47:09 <dv_> the freetype data isnt easy to use
04:47:16 <dv_> because fonts in general arent easy
04:48:19 <ksf> createRGBSurfaceFrom takes data in virtually every form a sane person would want to use.
04:48:29 <dv_> ksf, look at this: http://dmedia.dprogramming.com/?n=Tutorials.TextRendering1  the code is for the D language, but it might just as well have been pseudo code; the freetype info applies anyway
04:51:53 <ksf> ...my code is quite naive atm, I wanted to get basic text rendering up fast with a haskellish-enough interface and performance.
04:51:55 <dv_> btw. a theoretical question: see this code snippet from the article http://codepad.org/22fmSgYo  a purely functional way would be to move out the if (ratio > bestRatio) block, use map instead on the rest of the code inside the for loop, and for each result, store a (ratio, line) tuple,
04:52:16 <dv_> and in a second step, successively reduce the list of tuples, until you get the one with the smallest ratio
04:52:18 <dv_> right?
04:54:11 <ksf> almost
04:54:38 <ksf> you're tussing out values.
04:55:43 <dv_> just a sec, using pseudocode
04:55:54 <ksf> [ (ratio, line) | page <- pages, line <- lines, guard y >= size y ...]
04:56:44 <ksf> uh wait that inner foreach translates to a concat.
04:57:02 <ksf> concat (map lines pages)
04:57:08 <ksf> :t concatMap
04:57:09 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
04:57:48 <dv_> like this: http://codepad.org/2Xx0cPC1
04:57:56 <ksf> which is concatMap lines pages which is pages >>= lines
04:57:56 <ksf> :t guard
04:57:58 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:58:23 <dv_> ah, (infinity, null) not (null, null)
04:58:52 <dv_> its more of a conceptual question, not directly how to write that in haskell. thats why I use pseudocode
04:59:00 <ksf> but there's no need to return a tuple with invalid data.
04:59:32 <dv_> ah just dont return anything in that case?
04:59:49 <dv_> like a Maybe type?
05:00:02 <ksf> ...or lists.
05:00:15 <dv_> hmm yeah
05:00:16 <ksf> the list monad does exactly what you want.
05:00:46 <dv_> after years of imperative coding, I need a while to get into pure functional stuff in general and haskell in particular :)
05:00:56 <Kaidelong> dv what language are you using in there?
05:01:04 <ksf> [1..10] >>= (\x -> if x == 2 then [12,23] else if x == 4 then [] else [x])
05:01:09 <dv_> Kaidelong, this is pseudo code
05:01:12 <Kaidelong> ah
05:01:15 <ksf> > [1..10] >>= (\x -> if x == 2 then [12,23] else if x == 4 then [] else [x])
05:01:16 <lambdabot>   [1,12,23,3,5,6,7,8,9,10]
05:01:25 <Kaidelong> yeah I was thinking it looked C like but like nothing I saw before
05:01:32 <dv_> reminds me a bit of Scala though
05:01:48 <medfly> heh
05:01:49 <netinho2lol> what's >>= ?
05:01:54 <medfly> there's a language called pseudocode?
05:01:56 <ksf> :t (>>=)
05:01:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:02:04 <dv_> anyway, I am continually amazed how much imperative code can be translated to a functional equivalent
05:02:05 <ksf> it's called bind and the magic sauce of monads.
05:02:05 <mux> > [1..10] >>= \x -> guard x == 4 >> if x == 2 then [12,23] else return x
05:02:08 <lambdabot>   Couldn't match expected type `[a]'
05:02:08 <lambdabot>         against inferred type `GHC.Bool....
05:02:25 <mux> > [1..10] >>= (\x -> guard x == 4 >> if x == 2 then [12,23] else return x)
05:02:28 <lambdabot>   Couldn't match expected type `[a]'
05:02:28 <lambdabot>         against inferred type `GHC.Bool....
05:02:33 <netinho2lol> > putStr "\ESC[2J"
05:02:34 <mux> stupid me.
05:02:35 <lambdabot>   <IO ()>
05:02:42 <mux> > [1..10] >>= \x -> guard (x == 4) >> if x == 2 then [12,23] else return x
05:02:45 <lambdabot>   [4]
05:02:46 <centrinia> @let maximumOrNothing [] = Nothing; maximumOrNothing xs = Just (maximum xs)
05:02:46 <Kaidelong> dv if there wasn't a way to translate between the two functional languages would not be useful
05:02:47 <lambdabot>  Defined.
05:02:52 <netinho2lol> > putStr "\BEL"
05:02:53 <mux> > [1..10] >>= \x -> guard (x /= 4) >> if x == 2 then [12,23] else return x
05:02:54 <lambdabot>   <IO ()>
05:02:55 <lambdabot>   [1,12,23,3,5,6,7,8,9,10]
05:03:14 <centrinia> dv_, use maximumOrNothing and an appropriate list comprehension.
05:03:31 * ksf doesn't like list comprehensions.
05:03:56 <ksf> they don't gain you a thing over do-notation. too much sugar.
05:04:37 <dv_> Kaidelong, I meant translate without inhuman efforts
05:05:04 <dv_> Kaidelong, in other words, how often side effects arent really necessary
05:05:36 <Kaidelong> dv_ generally because of the features provided by functional languages, you don't really need side effects except when talking to imperative code
05:05:43 <ivanm> ksf: they're shorter than do notation
05:05:57 <ivanm> ksf: and don't require an explicit guard
05:05:59 <dv_> Kaidelong, there are certain things where they are unavoidable. like user input
05:06:22 <ivanm> > [ (a,b) | a <- [1..10], b <- [1..10], a + b == 6 ]
05:06:22 <ksf> well, possibly I'm not using Monad [a] enough.
05:06:24 <lambdabot>   [(1,5),(2,4),(3,3),(4,2),(5,1)]
05:06:45 <Kaidelong> user input can be visualized as being a sequence
05:07:26 <dv_> Kaidelong, and how do you model the MVC pattern in a pure functional way?
05:07:35 <ksf> > [ (x,a,b) | x <- [2..12], a <- [1..6], b <- [1..6], a + b == x ]
05:07:36 <lambdabot>   [(2,1,1),(3,1,2),(3,2,1),(4,1,3),(4,2,2),(4,3,1),(5,1,4),(5,2,3),(5,3,2),(5...
05:07:49 <dv_> Kaidelong, I'm used to implement mvc using the observer pattern. that is, a list of callbacks for each event
05:08:32 <ksf> > [ r | x <- [2..12], r <- [(a,b) | a <- [1..6], b <- [1..6], a + b == x ]]
05:08:33 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3...
05:08:49 <Kaidelong> you'd use some kind of explicit state I suppose
05:08:52 <ksf> > [ r | x <- [2..12], r <- [[(a,b)] | a <- [1..6], b <- [1..6], a + b == x ]]
05:08:53 <lambdabot>   [[(1,1)],[(1,2)],[(2,1)],[(1,3)],[(2,2)],[(3,1)],[(1,4)],[(2,3)],[(3,2)],[(...
05:09:01 * ksf is getting confused.
05:09:45 <centrinia> >  [ (x,r) | x <- [2..12], r <- [[(a,b)] | a <- [1..6], b <- [1..6], a + b == x ]]
05:09:47 <lambdabot>   [(2,[(1,1)]),(3,[(1,2)]),(3,[(2,1)]),(4,[(1,3)]),(4,[(2,2)]),(4,[(3,1)]),(5...
05:10:54 <ksf> ...I want all equal r's to be in a list.
05:11:32 <ksf> ...so I can length them and give the propability distribution for 2D6
05:11:55 <bastl> filter?
05:12:11 <centrinia> >  groupBy (on (==) fst) [ (x,r) | x <- [2..12], r <- [(a,b) | a <- [1..6], b <- [1..6], a + b == x ]]
05:12:12 <lambdabot>   [[(2,(1,1))],[(3,(1,2)),(3,(2,1))],[(4,(1,3)),(4,(2,2)),(4,(3,1))],[(5,(1,4...
05:12:40 <ksf> ...meaning "I want to generate those in the comprehension".
05:12:48 <centrinia> Oh.
05:12:53 <Trin> [(x,r) | x <- [2..12], r <- [ [(a,b) | a<- [1..6], b <- [1..6], a+b == x ] ]
05:13:03 <Trin> > [(x,r) | x <- [2..12], r <- [ [(a,b) | a<- [1..6], b <- [1..6], a+b == x ] ]
05:13:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:13:34 <ksf> > [(x,r) | x <- [2..12], r <- [ [(a,b) | a<- [1..6], b <- [1..6], a+b == x ] ] ]
05:13:35 <lambdabot>   [(2,[(1,1)]),(3,[(1,2),(2,1)]),(4,[(1,3),(2,2),(3,1)]),(5,[(1,4),(2,3),(3,2...
05:13:57 <ksf> > [(x,length r) | x <- [2..12], r <- [ [(a,b) | a<- [1..6], b <- [1..6], a+b == x ] ] ]
05:13:58 <lambdabot>   [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,5),(9,4),(10,3),(11,2),(12,1)]
05:14:02 <otherdude> Hey guys, can you recommend any good beginners guides that let you jump straight into the coding?
05:14:33 <ksf> @where lyah
05:14:33 <lambdabot> www.learnyouahaskell.com
05:14:37 <Trin> otherdude: lets all shout in unisone: realworldhaskell.com
05:14:43 <bastl> @where rwh
05:14:44 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:14:55 <otherdude> nice one, thanks all <3
05:15:16 <bastl> who wrote learnyouahaskell ?
05:15:38 <ksf> bonus iirc
05:15:39 <blackdog> BONUS
05:16:29 <Saizan> > [(x,r) | x <- [2..12], let r = length [(a,b) | a<- [1..6], b <- [1..6], a+b == x ] ]
05:16:30 <lambdabot>   [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,5),(9,4),(10,3),(11,2),(12,1)]
05:16:38 <bastl> well written. very nice style ... easy but precise enough to learn.
05:18:16 <ksf> > sum . map fst $  [(x,r) | x <- [2..12], let r = length [(a,b) | a<- [1..6], b <- [1..6], a+b == x ] ]
05:18:17 <lambdabot>   77
05:19:15 <ksf> > 6/77
05:19:17 <lambdabot>   7.792207792207792e-2
05:19:24 <ksf> that's still bad odds.
05:21:16 <centrinia> > [(n,1-(1-6/77)^n) | n <- [1..]]
05:21:17 <lambdabot>   [(1,7.792207792207795e-2),(2,0.1497723056164615),(3,0.21602381426972428),(4...
05:21:54 <centrinia> Hmm, doing three of them at the same time still leads to unfavorable odds.
05:22:08 <centrinia> > [(n,floor 100*(1-(1-6/77)^n)) | n <- [1..]]
05:22:09 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:22:09 <lambdabot>    `GHC.Real.Fractional b'
05:22:09 <lambdabot> ...
05:22:19 <centrinia> > [(n,floor $ 100.0*(1-(1-6/77)^n)) | n <- [1..]]
05:22:20 <lambdabot>   [(1,7),(2,14),(3,21),(4,27),(5,33),(6,38),(7,43),(8,47),(9,51),(10,55),(11,...
05:23:02 <prof_nimnul> otherdude: well, you can't jump into coding, unfortunately :)
05:24:09 * hackagebot upload: ls-usb 0.1.0.1 - List USB devices (RoelVanDijk)
05:27:08 <HaskellCoder_> could anyone help me with this: http://pastebin.com/d68f53778 , http://pastebin.com/m52936f5e ? thks
05:28:01 <koeien37> HaskellCoder_: do you get an error message?
05:28:05 <HaskellCoder_> yes
05:28:12 <koeien37> it being
05:28:25 <koeien37> you have two "main" functions. that can be a problem
05:28:31 <Botje> argh
05:28:33 <koeien37> i.e. the C one, and the Haskell one
05:28:38 <Botje> why are pastebin's fonts so horribly thin
05:28:43 <Botje> i can't read them :(
05:28:51 <koeien37> Botje: it's OK for me
05:29:03 <koeien37> but then my OS doesn't have decent fonts :P (debian)
05:29:32 <HaskellCoder_> it looks nice on pastebin (windows os)
05:29:44 <Botje> koeien37: i'm on ubuntu
05:29:48 <Botje> must be the font i set up for monospace
05:30:36 <benmachine> that's a browser setting isn't it?
05:31:18 <koeien37> iceweasel says that my font is 'monospace', which is probably a gnome setting then
05:31:21 <Botje> hmm, nope.it's default
05:34:49 <HaskellCoder_> so... i get rid of the main function in the c file... then i still have the error in the hs file ("Could not match expected type 'CInt' against inferred type 'm a ")
05:35:26 <koeien37> HaskellCoder_: ah, i didn't see that that was the error.
05:35:31 <koeien37> chinge line 11 into "let y = fibC x"
05:35:35 <koeien37> change*
05:36:17 <koeien37> you have said to the Haskell type system that fibC has no side effects (which it hasn't, so it's ok). that means that fibC is a pure function
05:36:40 <koeien37> (not an IO action which you need to get a value from with <- )
05:38:35 <HaskellCoder_> understood that - that error is gone... but when compiling the source "ghc -o test callCFromHaskell.hs Fibonacci.c" i get an error "undefined reference to fibC" (i am new to haskell, so...)
05:38:35 <bastl> I try to add a List-Functor to multirec for learning purposes. But I dont get it to type-check. What am I missing? I tried to follow the examples of :*: and :+: closely: here's my experiment: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5099#a5099 Can anyone help ? dreixel, perhaps?
05:39:13 <koeien37> HaskellCoder_: maybe reverse the order of the .hs and the .c file on the command line?
05:39:17 <koeien37> or try --make
05:39:24 * koeien37 is not really an FFI expert :)
05:42:02 <bastl> or kosmikus? :-)
05:44:09 <HaskellCoder_> now, i get the errors "undefined reference to  _stginit_ZCMain"  "undefined reference to ZC_main_closure" :(
05:44:37 <koeien37> i think yo uneed to add --make
05:45:05 <koeien37> probably some package that you need is not linked in, but GHC can figure this out if you pass --make
05:45:24 <koeien37> (i consider it a bug that this often-occurring error does not have a better error message.)
05:45:49 <HaskellCoder_> yes, i forgot the --make flag
05:46:02 <HaskellCoder_> it was so frustating this code than i simple forgot
05:46:22 <HaskellCoder_> it works; thanks koeien37
05:46:50 <ivanm> heh, that's a common mistake
05:54:01 <nothingmuch> is there any resource that surveys the various IRs used in haskell compilers? core/stg/grin/silly/c-- etc and how they interact?
05:55:28 <Lemmih> A fair amount has been written about their properties.
05:55:53 <nothingmuch> yes, separately, but I'm still sort of lost in the taxonomy
05:57:32 <Saizan> well, ghc goes core -> stg -> c--, afaiu, there's more on the trac wiki
05:58:09 <path[l]> is there anyone here who can help me with a problem where Im taking too long probably because of gc?
05:58:33 <path[l]> I have the code and the output of the memory profile
06:01:57 <ksf> getting rid of stg is a c-- transform, iirc.
06:02:22 <ksf> or at least of its higher-orderedness
06:02:37 <Cale> path[l]: Possibly. Stick it on hpaste and people will have a look :)
06:03:00 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5098
06:03:06 <path[l]> http://rapidshare.de/files/48737313/buttonshclazyio.pdf.html
06:03:09 <path[l]> http://rapidshare.de/files/48737313/buttonshclazyio.pdf.html
06:03:23 <path[l]> those are the memory profiles with hd and hc
06:03:28 <orbitz> @quote orbitz
06:03:29 <lambdabot> copumpkin says: orbitz makes [##C++] especially brutal to make people appreciate #haskell more
06:07:24 <path[l]> The input is 10 cases. it starts with a (491)^2 array and reaches a 500^2 array
06:08:10 <Cale> path[l]: Actually, can I have a copy of the input?
06:08:21 <path[l]> yeah
06:08:25 <path[l]> thinking of how to share it
06:08:37 <path[l]> rapidshare I guess
06:11:55 <ksf> what's that word again one uses for made-up code examples? something along the lines arbitrary/constructed/non-real-world
06:12:06 <benmachine> contriveD?
06:12:08 <benmachine> d
06:12:14 <ksf> that works
06:12:26 <ksf> but I vaguely remember one beginning with a
06:12:57 <Saizan> abstract?
06:12:58 <path[l]> http://rapidshare.de/files/48737819/BUTTONS_2.in.zip.html
06:13:09 * ksf goes for contrived
06:13:14 <path[l]> artificial ?
06:13:36 <ksf> artificial works good, too, but not if you want to suffix an -ness.
06:13:50 <benmachine> artificiality
06:14:00 <ksf> that might be the reason.
06:14:02 <benmachine> is probably how that would work
06:15:33 * ksf wonders whether "The artificiality of code examples grows exponentiall with the length of a reddit thread" is going to be filed under "ksf's law"
06:16:19 <benmachine> heh, I hope so
06:17:04 * Saizan goes to look at the code example at the end of the "dark secret" thread
06:27:30 <path[l]> Cale: Im trying to get it to compete with the code people write in C++ or C. Im just wondering if my current solution ends up holding the ENTIRE n^2 array in memory
06:30:02 <Cale> path[l]: I'm not certain, but I think you're being killed by all the small tuples being created and destroyed.
06:32:00 <Cale> oh, apparently not
06:32:05 <Cale> It's all list cells.
06:35:46 <Cale> > "abc def ghi" >>= words
06:35:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:35:48 <lambdabot>         against inferred type...
06:36:10 <ivanm> wtf? Cale made a mistake? :o
06:36:16 <Cale> > ["abc def ghi","jkl mno"] >>= words
06:36:18 <lambdabot>   ["abc","def","ghi","jkl","mno"]
06:36:18 * ivanm 's world is shattered...
06:36:37 <Cale> ivanm: That's what the typechecker is for ;)
06:36:49 <ivanm> heh
06:36:57 <path[l]> teag
06:37:01 <path[l]> yeah*
06:37:14 <path[l]> should I be moving to a list of something other than int maybe?
06:37:28 <path[l]> reduce ram is the quickest thing I can think of
06:37:46 <path[l]> or I can move to a fixed size container like an array, but I lose all the list methods
06:38:46 <Cale> Well, an unboxed array of Bool will pack everything nicely into bits, but I don't understand what your program is doing well enough yet to say if that would be a good thing.
06:39:19 <Cale> Er, I guess it's not really bools after all
06:39:31 <path[l]> bool would work. Its just 1s and 0s
06:41:30 <quicksilver> I thought there were some minus 1s?
06:41:55 <path[l]> only in the score bit
06:42:02 <path[l]> but not in the input arrays
06:44:22 <dreixel> bastl: hmapA f p (ListOf xs) = ListOf <$> sequenceA (map (hmapA f p) xs)
06:44:39 <dreixel> (sequenceA comes from Data.Traversable)
06:44:42 * ksf wonders whether it makes sense to speculatively upload a gazillion of vertices to the gpu so I can emulate geometry shaders
06:45:51 <bastl> dreixel: thanks.
06:46:47 <dreixel> bastl: you're welcome
06:47:18 <ksf> ...actually, what I want is a gazillion, or rather, 1280x1024, _points_, not vertices.
06:47:20 <saml> hey, teach me audio synthesis
06:47:32 <ksf> then do an orthographic projection and the rest in glsl.
06:48:25 <ksf> that's completely inside-out, but it might just work.
06:49:15 <ksf> ...but I'd be doing everything in fragment shaders.
06:49:51 <ksf> but then, according to conal, that's exactly what an image is, a function (Int,Int) -> Colour.
06:49:59 <ksf> (he'd say "color", though)
06:52:23 <path[l]> is there a xor for Bool?
06:52:37 <ksf> > True `xor` False
06:52:38 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
06:52:38 <lambdabot>    arising from a use of `Da...
06:52:43 <ksf> uh.
06:52:56 <ksf> > (fromEnum True) `xor` (fromEnum False)
06:52:57 <lambdabot>   1
06:53:07 <ksf> > toEnum ((fromEnum True) `xor` (fromEnum False)) :: Bool
06:53:09 <lambdabot>   True
06:53:12 <ksf> there you go.
06:53:18 <ksf> but I guess you want to write your own.
06:53:22 <path[l]> heh thanks =p
06:53:51 <Cale> Uh, /= ?
06:53:57 <ksf> although... that fromEnum thing should actually be faster than pattern matching.
06:54:04 <path[l]> yeah /= seems easier
06:54:09 <Cale> ;)
06:54:49 <roconnor> @src fromEnum Bool
06:54:50 <lambdabot> Source not found. It can only be attributed to human error.
06:55:16 <path[l]> Im just switching my solution from Ints to Bool on the input for now. So I assume a list of bool takes less space
06:55:23 <path[l]> if that makes a difference I can try a uarray
06:55:55 <notweebl> what's the difference between Integral and Integer?
06:55:55 <path[l]> but I hope I wont have to. Its easier to work with lists. Arrays less so lol
06:56:26 <Cale> notweebl: Only one of them is a type
06:56:35 <Cale> notweebl: Integer is a type, Integral is a class
06:56:39 * hackagebot upload: MonadCatchIO-transformers 0.0.2.0 - Monad-transformer compatible version of the Control.Exception module (AriePeterson)
06:56:46 <Botje> and integral is a person
06:56:52 <Cale> ?
06:56:54 <Botje> or so he claims to be
06:56:59 <ezrakilty> @quote integral
06:57:00 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:57:24 <ezrakilty> can lambdabot quote arbitrary people?
06:57:39 <Botje> no, it searches the list of stored quotes
06:57:42 <Botje> @quote buildings
06:57:44 <lambdabot> bos says: * bos is 6 months old, and can lift small buildings (after a bottle of milk) // Botje> bos: .. into what monad?
06:57:54 <roconnor> @vixen can you quote arbitrary people?
06:57:55 <lambdabot> i sure can
06:58:10 <path[l]> > Not True
06:58:12 <lambdabot>   Not in scope: data constructor `Not'
06:58:17 <ezrakilty> when does it store a quote? just when someone orders it to?
06:58:18 <path[l]> > not True
06:58:19 <lambdabot>   False
06:58:30 <Cale> ezrakilty: yes
06:58:40 <Cale> The @remember command does that
06:58:43 <Cale> @help remember
06:58:44 <lambdabot> quote <nick>
06:58:44 <lambdabot> remember <nick> <quote>
06:58:44 <lambdabot> Quote somebody, a random person, or save a memorable quote
06:59:08 <ezrakilty> i see
06:59:27 <roconnor> after giving an @remember command lambdabot will say "it is forever etched into my memory" and then forget the quote by tomorrow.
06:59:31 <jd10> @quote lambdabot
06:59:32 <lambdabot> lambdabot says: Done.
06:59:40 <Cale> path[l]: Just a style point: learn to use pattern matching instead of head/tail
06:59:56 <path[l]> hmm ok
07:00:03 <path[l]> yeah I see what you mean
07:00:12 <benmachine> 14:24:20 < Who-[Soup]> :p
07:00:12 <benmachine> 14:24:33 <@Timbo> that you can't tell us?
07:00:12 <benmachine> 14:24:59 < Who-[Soup]>  O f F   l I m I t S
07:00:12 <benmachine> 14:25:18 < Who-[Soup]> when did you get so nosy!
07:00:15 <Cale> path[l]: head and tail are scary functions which you should almost never need, because they throw exceptions which are hard to track down
07:00:29 <Cale> benmachine: ?
07:00:29 <path[l]> ah
07:00:35 <benmachine> oh
07:00:40 <benmachine> er
07:00:42 <benmachine> don't know
07:00:48 <benmachine> I was about to blame middle click paste
07:00:51 <benmachine> but it's not even enabled
07:00:53 <osfameron> Cale: why hard to track down?  don't the error messages point out exactly where they are?
07:00:57 <path[l]> what operation is True False -> False, True True -> True, False True -> False, False False -> True ....
07:01:15 <benmachine> path[l]: not xor?
07:01:15 <Cale> osfameron: no, not really
07:01:18 <path[l]> oh thats /=
07:01:21 <benmachine> heh
07:01:24 <benmachine> that too!
07:01:36 <Cale> *** Exception: Prelude.head: empty list
07:01:39 <path[l]> or rather ==
07:01:42 <Cale> ^^ that's what the error looks like
07:01:43 <opqdonut> indeed
07:01:53 <path[l]> Cale: ah
07:01:58 <osfameron> Cale: handy...
07:02:12 <benmachine> oh it was middle-click paste
07:02:20 <Cale> Good luck finding it if you have a million calls to head in your code. Safer to use pattern matching and always match both cases.
07:02:31 <benmachine> how do people cope with that without going slightly bonkers
07:02:34 <benmachine> I can't work it out
07:02:38 <osfameron> that's arguably a bug in ghc, no?
07:02:47 <opqdonut> benmachine: i like it :)
07:02:50 <benmachine> missing feature, perhaps
07:02:51 <Cale> benmachine: huh? Don't hit the middle mouse button unless you want to paste.
07:03:00 <Cale> osfameron: what is?
07:03:04 <osfameron> ah no, haskell is compiled without runtime source debugging features by default?
07:03:13 <Cale> I like middle button paste :)
07:03:25 <osfameron> Cale: I'm just used to dynamic languages where runtime errors know what line threw them :D
07:03:27 <benmachine> Cale: yeah I suppose it's not a problem for most people, but I only have one mouse button so I use triple-finger tap
07:03:31 <BONUS> > map (head &&& length) . group . sort $ [1,2,5,9,3,2,5,3,2,1,3,2,4,5]
07:03:32 <lambdabot>   [(1,2),(2,4),(3,3),(4,1),(5,3),(9,1)]
07:03:33 <benmachine> on the touchpad
07:03:39 <benmachine> hence doing it just now without noticing
07:03:40 <needhelp> Sir any one would help he
07:03:44 <needhelp> Sir any one would help he
07:03:55 <BONUS> head and tail is alright when you're using it on a list you just created and know is not empty
07:04:01 <Cale> osfameron: The problem is that where the (head xs) expression gets evaluated is usually far away from the line on which head was used in the first place.
07:04:04 <BONUS> and even then you're usually mapping head/tail
07:04:26 <osfameron> Cale: ah!
07:04:32 <needhelp> i make javascript for my assignment
07:04:38 <osfameron> interesting
07:04:39 <needhelp> yuhu
07:04:45 <quicksilver> needhelp: this is a haskell channel, we won't help you out with javascript.
07:04:50 <Botje> needhelp: i think you want #javascript, then.
07:04:55 <osfameron> unless you're generating javascript with haskell, I suppose
07:04:55 <needhelp> anyone would like to help me please
07:05:03 <quicksilver> there is a ##javascript I think.
07:05:14 <path[l]> needhelp: with what? There's a javascript irc channel for javascript
07:05:19 <HaskellCoder_> has anybody used gcjni?
07:05:26 <needhelp> ok thanks
07:05:29 <BONUS> ugh ... the time around finals
07:05:42 <path[l]> ?
07:05:53 <path[l]> does freenode get flooded with students around then?
07:05:58 <BONUS> i get like one email per day of people asking me to do their homework :)
07:06:05 <Botje> what do you mean finals?
07:06:06 <opqdonut> hehe
07:06:07 <BONUS> and yeah lately #haskell has been flooded with homework too
07:06:09 <Botje> we have finals in june :/
07:06:12 <BONUS> or midterms
07:06:13 <BONUS> or something
07:06:18 <Botje> those are in january ;)
07:06:19 <BONUS> idk
07:06:24 <path[l]> why do you get flooded? what do you do
07:06:32 <osfameron> people doing *finals* want homework help?
07:06:40 <Botje> BONUS: i'm going to print out your list monster to an A2 and hang it on my wall, btw :)
07:06:41 <quicksilver> BONUS is internationally known as a helpful chap.
07:06:48 <path[l]> haha
07:06:52 * osfameron can understand (ish) a newbie student being htat needie, but if you can't study by yourself on finals, you should just quit
07:07:00 <path[l]> osfameron:  close to finals people need to submit their assignments too Im guessing
07:07:02 <quicksilver> if you google search for HALP HALP IM STUCK IN A COLOURFUL TUTORIAL he is the first result.
07:07:04 <BONUS> Botje: haha awesome :D if you need a high res version i can provide that
07:07:08 <blackdog> international man of hospitality?
07:07:16 <BONUS> quicksilver: lol
07:07:17 <Botje> BONUS: i'll try to vectorize it myself first :)
07:07:38 <path[l]> hah what about the students who wake up when the course is almost over
07:07:41 <path[l]> and decide they need that grade after all
07:08:08 <osfameron> path[l]: I guess it happens, yeah... I'm just saying I don't *understand* it ;-)
07:08:15 <path[l]> heh ok
07:08:47 <BONUS> http://dl.dropbox.com/u/665999/listmonster.png
07:09:25 <path[l]> hahaha
07:09:25 <path[l]> nice
07:10:34 <Botje> BONUS++ #thanks!
07:10:41 <saml> what is uut ?
07:10:41 <BONUS> np :D
07:10:46 <saml> below head
07:11:10 <Cale> Should probably scale the line width
07:11:17 <saml> first?
07:11:23 <BONUS> uut = init
07:11:27 <BONUS> Cale: yeah hmm
07:11:52 * hackagebot upload: full-sessions 0.6.1 - a monad for protocol-typed network programming (KeigoImai)
07:11:57 <saml> > init []
07:11:57 <Cale> BONUS: If it's an inkscape thing, there's a toggle button on the toolbar for that
07:11:59 <lambdabot>   * Exception: Prelude.init: empty list
07:12:06 <saml> > init "hellow"
07:12:08 <lambdabot>   "hello"
07:12:12 <saml> oh coolz
07:12:18 <saml> > init [1..]
07:12:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:12:24 <benmachine> heh
07:12:43 <nlogax> BONUS: better watch out for nintendo lawyers
07:12:49 <BONUS> there, scaled the line width. actually made it thicker: http://dl.dropbox.com/u/665999/listmonster.png
07:13:02 <BONUS> nlogax: yeah gonna have to, i think i saw one following me yesterday
07:13:10 <nlogax> BONUS: they're everywhere!
07:13:27 <saml> that list isn't homogenius
07:14:01 <BONUS> hehe
07:14:05 <quicksilver> inkscape++ # clumsy, but awesome
07:14:12 <saml> oh it is. i just chopped a head and a body . they taste the same
07:14:13 <opqdonut> :)
07:14:43 <notweebl> I have something which is Integer -> Bool, we should use Integer because Int is too small (2^32 in this case). Why should I not use Integral a => a
07:15:22 <saml> notweebl, Int is instance of Integral
07:15:27 <BONUS> so is Integer
07:15:28 <opqdonut> notweebl: well if you only apply the function to Integers, no reason to generalize it
07:15:32 <benmachine> (so I remembered out what it is that bothers me about middle-click paste: I can't copy a URL, select the text in my address bar, and paste to replace it)
07:15:44 <benmachine> rembered out? a cross between worked out and remembered.
07:15:47 <notweebl> but would Integral work the same as Integer?
07:16:05 <opqdonut> benmachine: browsers should support paste-n-go
07:16:05 <notweebl> would it be possible to use it
07:16:13 <ezrakilty> is there a lambdabot command for fetching the definition of a type class?
07:16:16 <saml> give us an example
07:16:21 <BONUS> you could use Integral a => a with Integers
07:16:29 <BONUS> but then someone could also give that function an Int
07:16:31 <opqdonut> ezrakilty: yeah
07:16:32 <BONUS> so depends on what you want
07:16:32 <benmachine> ezrakilty: sometimes @src works, but more often it's better to use :i in ghci
07:16:38 <opqdonut> @src (->) (>>=)
07:16:39 <lambdabot> f >>= k = \ r -> k (f r) r
07:16:44 <opqdonut> there for example
07:16:47 <saml> you might have to sprinlke fromInteger or something
07:16:49 <benmachine> oh, unless you mean instances
07:16:51 * benmachine shrugs
07:16:54 <notweebl> So if I use Integral, I can enter both an Int and an Integer?
07:17:00 <ezrakilty> ... just wanted to show the methods of Integral, for notweebl's benefit
07:17:03 <BONUS> notweebl: ya
07:17:07 <notweebl> alright thanks
07:17:49 <ezrakilty> @src Integral
07:17:49 <lambdabot> class  (Real a, Enum a) => Integral a  where
07:17:49 <lambdabot>     quot, rem, div, mod :: a -> a -> a
07:17:49 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
07:17:49 <lambdabot>     toInteger           :: a -> Integer
07:17:55 <ezrakilty> ah! it does work
07:18:09 <benmachine> :i is more reliable and also gives a list of instances
07:18:15 <benmachine> and is generally useful to know
07:18:43 <ezrakilty> so, notweebl, it will work if those are the only functions you use on the integral type
07:18:46 <ezrakilty> @src Real
07:18:47 <lambdabot> class  (Num a, Ord a) => Real a  where
07:18:47 <lambdabot>     toRational      ::  a -> Rational
07:18:54 <ezrakilty> @src Num
07:18:54 <lambdabot> class  (Eq a, Show a) => Num a  where
07:18:55 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:18:55 <lambdabot>     negate, abs, signum     :: a -> a
07:18:55 <lambdabot>     fromInteger             :: Integer -> a
07:18:56 <path[l]> > fromEnum True
07:18:57 <lambdabot>   1
07:18:58 <ezrakilty> those too
07:19:25 <opqdonut> it really bothers me that the class _Real_ has a method _toRational_
07:19:34 <benmachine> opqdonut: yeah, it's pretty odd
07:20:06 <BONUS> am i the only one who finds dealing with the numeric classes the most boring part of haskell
07:20:10 <saml> i think all Real number on a computer is rational
07:20:20 <ezrakilty> saml not so!
07:20:35 <BONUS> also yeah i don't think there should be a class called Real
07:20:37 <saml> i mean except Inf NaN
07:20:40 <ezrakilty> @google Exact Real Arithmetic
07:20:42 <lambdabot> http://www.haskell.org/haskellwiki/Exact_real_arithmetic
07:20:42 <lambdabot> Title: Exact real arithmetic - HaskellWiki
07:21:21 <opqdonut> yeah, what ezrakilty pasted
07:21:25 <benmachine> anything that can be written on a finite amount of paper can also be stored in a computer :P
07:21:54 <BONUS> benmachine: that depends ... do you have an infinitely sharp pencil?
07:22:13 <quicksilver> BONUS: sure, do you need to borrow it?
07:22:20 <BONUS> lol
07:22:26 <BONUS> my mom won't let me play with them
07:22:32 <Polarina> BONUS: Hello.
07:22:32 <saml> i don't get it. memory is limited. 3.143495735793847598379384579345 is rational
07:22:34 <ezrakilty> don't run with them!
07:22:38 <needhelp> yuhu what channel is this\
07:22:38 <BONUS> Polarina: hello
07:22:40 <quicksilver> you'll need to provide an infinite tough envelope to mail it, because the end is very sharp.
07:22:40 <opqdonut> well you'd need a special paper
07:22:43 <opqdonut> too
07:22:52 <needhelp> yhuh
07:22:53 <Polarina> BONUS: I'd like to thank you for taking your time to make that awesome book. :)
07:22:53 <needhelp> haiz
07:22:57 <needhelp> mga pota kayo
07:23:01 <needhelp> suntukan gago pota
07:23:03 <benmachine> saml: but you can store data which represents multiples of pi
07:23:03 <opqdonut> saml: but the algorithm to generate the digits of pi is finite
07:23:04 <BONUS> thank you :) very nice of you to say that
07:23:08 <quicksilver> needhelp: this is #haskell, again, or still.
07:23:08 <benmachine> and that
07:23:20 <Polarina> BONUS: You're welcome. I hope you'll finish it someday. :)
07:23:24 <benmachine> so you could store an infinite list of pi's digits so long as it was lazy :P
07:23:25 <quicksilver> saml: google "computable real"
07:23:32 <needhelp> pota mga ulol kayo
07:23:42 <BONUS> sure will, working on it
07:23:50 <Polarina> BONUS: Thanks.
07:23:51 <needhelp> sir
07:23:59 <needhelp> help me in java script
07:24:02 <quicksilver> needhelp: use your IRC program's ability to join other channels. Perhaps you should read the documentation.
07:24:07 <needhelp> java i mean
07:24:10 <centrinia> needhelp, Go to #javascript or something.
07:24:19 <centrinia> Go to ##java
07:24:26 <needhelp> whta is this/
07:24:27 <ksf> even with the infinitely sharp pencil, you won't be able to draw a circle for which 2pi r^2 holds.
07:24:31 <int-e> Oh. Those colons are feet? I wonder what [] is then :-)
07:24:31 <BONUS> first type in /part and then type in /join #javascript
07:24:40 <centrinia> needhelp, just enter "/join ##java"
07:25:32 <ezrakilty> saml: the idea, as I understand it, is to treat reals as computations that produce infinite (lazy) lists of digits. you can only ever produce finitely many digits, but you can still do arithmetic and never lose precision...
07:25:55 * ksf wonders how people manage to implement that kind of level of cliche.
07:26:15 <saml> yah turing machine has infinite tape in theory
07:26:48 <benmachine> am I right in thinking that some real numbers aren't the result of a finite computation or description, though?
07:26:53 <quicksilver> yes
07:26:58 <quicksilver> not all real numbers are computable
07:27:07 <quicksilver> computable reals are themselves only countable
07:27:15 <quicksilver> so ""most"" real numbers are, therefore, uncomputable
07:27:17 <benmachine> heh
07:27:27 <BONUS> yeah. there are more uncomputable than computable reals
07:27:52 <quicksilver> but, lots of interesting irrational numbers are eminently computable.
07:27:59 <quicksilver> so it's a concept which has value
07:28:02 <centrinia> There are a lot of uncomputable reals near every computable real.
07:28:23 <benmachine> well yes, a number which isn't the result of any finite computation doesn't tend to be very useful, I'd assume
07:28:26 <quicksilver> sqrt(2) is computable (as are all algebraic numbers), so is pi (and in some lose sense "all geometric construcions")
07:28:42 <benmachine> wait why do I keep saying finite
07:28:46 <benmachine> I suppose I mean finitely complex
07:28:48 <benmachine> or something
07:28:54 * benmachine in over his head a little
07:28:54 <quicksilver> finitely describable.
07:28:57 <benmachine> mm
07:29:05 <quicksilver> the computer program to compute them must be finite
07:29:15 <quicksilver> the computation, itself, will normally not be.
07:29:25 <centrinia> Digits that are output of some Turing machine.
07:29:56 <centrinia> Chaitin's constant is not a computable real.
07:31:52 <EvilTerran> of note is the countability of programs in any given language
07:32:17 <EvilTerran> and hence the countability of the set of computable numbers (or, in general, computable problems)
07:33:49 <quicksilver> chatin's constant is a fiarly
07:33:55 <path[l]> anyone have an idea of how I can map "1" to True and "0" to False?
07:33:56 <quicksilver> contrived construction, I was going to say.
07:34:18 <quicksilver> path[l]: define a function "foo 1 = True; foo 0 = False"
07:34:27 <koeien37> > let f 1 = True; f 0 = False in f 1
07:34:29 <lambdabot>   True
07:34:38 <quicksilver> actually you can use 'toEnum' but I think that's ugly and you might as well define your own for clarity.
07:34:59 <saml> > map (\x -> case x of "0" -> True; "1" -> False) "010010111101"
07:35:01 <path[l]> yeah fair enough. Besides it needs to operate on the string "1" so I might as well write the function
07:35:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:35:02 <lambdabot>         against inferred ty...
07:35:20 <saml> > map (\x -> case x of '0' -> False; '1' -> True) "010010111101"
07:35:22 <lambdabot>   [False,True,False,False,True,False,True,True,True,True,False,True]
07:35:38 <benmachine> > map (== '1') "010010111101"
07:35:40 <lambdabot>   [False,True,False,False,True,False,True,True,True,True,False,True]
07:35:42 <koeien37> beware the partial functions
07:36:06 <saml> > map (!= '0') "2300324010234"
07:36:09 <lambdabot>   Not in scope: `!='
07:36:17 <opqdonut> it's /=
07:36:18 <saml> > map (/= '0') "2300324010234"
07:36:20 <lambdabot>   [True,True,False,False,True,True,True,False,True,False,True,True,True]
07:36:22 <centrinia> > map (== '1') "010010foobar111101"
07:36:24 <lambdabot>   [False,True,False,False,True,False,False,False,False,False,False,False,True...
07:36:54 <path[l]> neat I like it
07:37:01 <path[l]> map (== "1")
07:37:28 <benmachine> hold on
07:37:30 <koeien37> == '1' you presumably mean
07:37:30 <koeien37> :t "1"
07:37:30 <koeien37> :t '1'
07:37:32 <lambdabot> Char
07:37:32 <lambdabot> [Char]
07:37:51 <benmachine> you probably don't need to map it
07:37:55 <saml> how can I do [Bool] -> Integer ?
07:38:03 <benmachine> const 4
07:38:03 <saml> [True,False] -> 2
07:38:10 <benmachine> oh
07:38:10 <opqdonut> binary?
07:38:13 <saml> yes
07:38:17 <opqdonut> define a fold
07:38:18 <koeien37> this is a fold
07:38:52 <path[l]> holy crap. Moving from Int to Bool made it slower not faster
07:39:37 <saml> > foldr (\a b -> if a then b + 1 else b) 0 [True, False]
07:39:39 <lambdabot>   1
07:39:47 <benmachine> need some doubling in there
07:40:06 <saml> > foldr (\a b -> if a then 2 * b else b) 0 [True, False]
07:40:08 <lambdabot>   0
07:40:13 <saml> > foldr (\a b -> if a then 2 * b else b) 1 [True, False]
07:40:15 <lambdabot>   2
07:40:17 <benmachine> not quite :P
07:40:21 <centrinia> > foldl (\b a -> (if a then 1 else 0)+b*2) 0 [True,True,True,False]
07:40:23 <lambdabot>   14
07:40:31 <benmachine> that's more like it
07:40:37 <koeien37> yes
07:41:02 <centrinia> That's big endian. :|
07:41:14 <koeien37> true, that was what saml asked
07:41:26 <saml> > foldr (\a b -> (if a then 1 else 0) + b*2) 0 [False]
07:41:28 <lambdabot>   0
07:41:57 <EvanCarroll> what is the purpose of folding over a list of 1?
07:42:12 <centrinia> EvanCarroll, because we can!
07:42:27 <saml> > length [1,1,1,1..]
07:42:29 <lambdabot>   <no location info>: parse error on input `..'
07:42:31 <koeien37> EvanCarroll: what is the purpose of folding over a list of length n, where n is fixed? nothing
07:42:42 <koeien37> you could have written it out
07:43:11 <int-e> > map fromEnum [True, False]
07:43:13 <lambdabot>   [1,0]
07:43:42 <saml> > foldr (\a b -> fromEnum a + b*2) 0 [False,True,True]
07:43:44 <lambdabot>   6
07:43:52 <saml> eh?
07:43:57 <saml> it should be 3
07:44:03 <saml> oh that's what you mean by big endian
07:44:04 <sproingie> path[l]: individual Bools are probably stored in a machine word anyway
07:44:22 <benmachine> saml: also, foldr/foldl
07:44:23 <quicksilver> path[l]: I did try to tell you that.
07:44:28 <path[l]> oh? not in a byte?
07:44:34 <quicksilver> path[l]: changing the type of your lists is not going to make the blindest bit of difference.
07:44:47 <quicksilver> path[l]: if you believe memory usage is the problem, you need to stop using lists.
07:45:02 <quicksilver> list of Ints = 24 bytes per item
07:45:07 <quicksilver> list of Bools = 24 bytes per item
07:45:12 <quicksilver> list of Word8s = 24 bytes per item
07:45:17 <path[l]> ah
07:45:33 <path[l]> hmm I dont know if its the problem. quicksilver does the graph suggest that ?
07:45:38 <quicksilver> (16 on a 32-bit platform, to be fair)
07:45:43 <saml> array of Ints = priceless
07:46:36 <Botje> quicksilver: is there a strict list where the elements are strict but the spine is lazy?
07:47:00 <Botje> (does that even make sense, he asks)
07:47:09 <saml> no it does not make sense
07:47:22 <sproingie> where would it know where to put them?
07:47:29 <saml> if all elements are strict.. then spine must be strict
07:47:37 <saml> wait maybe not
07:47:44 <path[l]> it looks like I spend most of time in IO
07:47:45 <saml> [[a]]
07:47:50 <benmachine> you could have a list where forcing evaluation of the spine forced evaluation of the elements
07:48:03 <koeien37> like [!a]
07:48:03 <koeien37> ?
07:48:05 <saml> element itself can be a strict list but outer list is lazy
07:48:07 <roconnor> I wonder if it makes any sense to put a darcs repository into subvesion.
07:48:09 <benmachine> something like that
07:48:16 <sproingie> just not primitive datatypes
07:48:47 <path[l]> or atleast half my time
07:48:47 <path[l]> but it also says a lot of time is spent in gc
07:48:57 <saml> should't we have only one monad, IO ?
07:49:30 <sproingie> monads are useful
07:49:54 <benmachine> we should only have six syntax elements, -, +, [, ], ,, ..
07:50:02 <benmachine> then it'd be simpler.
07:50:36 <sproingie> not bad, it takes brainfuck eight
07:50:39 <saml> no, syntax elements should be [,],(,),{,},:  7 of them
07:51:04 <sproingie> unlambda only needs three
07:51:16 <centrinia> Jot only has 2.
07:51:18 <ezrakilty> whitespace needs just three as well
07:51:46 <Botje> saml: oh, but we MUST include ⟨ and ⟩!
07:51:48 <saml> you can have only 1. a white space.
07:51:48 <benmachine> oh, I forgot > and <
07:51:49 <centrinia> Iota also has 2.
07:52:04 <sproingie> i suspect jot is a binary encoding of more than two operators
07:52:06 <benmachine> I believe there's a language where the entire program is a single integer
07:52:12 <saml> white space delimited tokens
07:52:19 <benmachine> it is um quite large, typically
07:52:31 <saml> each token is a word like forth
07:52:48 <c_wraith> benmachine: that's one interpretation of compiled code you can enjoy
07:53:03 <quicksilver> Botje: no, although there could be
07:53:12 <Botje> quicksilver: ah, yay
07:53:20 <quicksilver> Botje: data StrictList a = Nil | Cons !a (StrictList a)
07:53:42 <quicksilver> I dont' know what the performance problem is in path[l]'s code, but I doubt it's that.
07:53:53 <centrinia> Jot is the binary encoding of just \f -> f S K and \f x y -> f (x y) respectively for 0 and 1. The empty string corresponds to I.
07:57:51 <path[l]> hmm what did I miss?
07:58:47 <centrinia> You missed the proof of the Riemann hypothesis.
07:59:00 <path[l]> lol
08:00:24 <Botje> the butler did it, in the end.
08:02:09 <quicksilver> Botje: I knew it was the butler but I couldn't fit him into the margin of this proof.
08:02:21 <guza> hello :D
08:02:23 <Botje> :)
08:02:28 <Botje> guza: hi!
08:02:30 <guza> a question :)
08:02:41 <sproingie> marvelous theorem, which the margin of this proof is too small to contain
08:02:53 <guza> is there a way to see the haskell genereated code when using "deriving Eq,Ord,Show" on some data type?
08:03:26 <Botje> i wouldn't know. it's probably boring.
08:03:48 <quicksilver> guza: strangely there is not.
08:03:51 <sproingie> don't think it generates haskell source.  maybe core.
08:04:03 <quicksilver> yes I think it cheats and generates core directly
08:04:20 <guza> the thing is I need to implement instance Eq
08:04:22 <Cale> The Report specifies the generated code though
08:04:38 <guza> and it would be very helpful to see the haskell stuff genereated automaticly when using deriving
08:04:48 <guza> and then just add to it some extra functionality
08:04:54 <Botje> guza: for Eq, all you have to define is (==) OR (/=)
08:05:01 <guza> yes but the thing is
08:05:19 <sproingie> do it by hand a bunch of times, it'll probably be similar
08:05:36 <guza> when defining (==) I need to define is the structure of that data the same and if that fails if the value evaled is the same
08:05:44 <guza> the thing is when using this data type
08:06:04 <guza> data Expr = Val Int | Add Expr Expr
08:06:08 <guza> this is an example of the data
08:06:12 <guza> the thing is
08:06:15 <guza> when implementing Ord later
08:06:18 <guza> for <
08:06:45 <guza> i first have to check if the first Expr is a subExpr of the Expr2
08:06:52 <guza> then if that fails to check the value
08:07:03 <guza> the thing is haskells auto gen Eq compares structure
08:07:06 <Cale> Weird.
08:07:11 <Cale> Why that ordering?
08:07:24 <sproingie> you need something other than == then, like an evaluator
08:07:29 <guza> its not up to me its a fucking assigment at my Uni
08:07:37 <guza> they needed to make some new thing up
08:07:38 <sproingie> Eq is not intended to add extra evaluation semantics
08:07:57 <guza> yeah but the thing is normally (==) just checks the value
08:08:20 <quicksilver> what else is there to check other than the value?
08:08:20 <guza> but when using (<=) I should first check if Expr1 is contained in the struct of Expr2
08:08:46 <quicksilver> well it's easier to understand a non-standard Ord instance than a non-standard Eq instance.
08:09:01 <guza> ex (Add (Val 5) (Val 3)) (Add (Add (Val 5) (Val 3)) (Val (-10))
08:09:03 <quicksilver> the standard Ord instance is pretty arbitrary while the standard Eq instance is in a natural way canonical.
08:09:12 <guza> in this example the value of first Expr1 is bigger then Expr2
08:09:25 <guza> but it is containted in the Expr2 therefore should return its smaller then Expr2
08:09:49 <guza> (Add (Val 5) (Val 3))  (<) (Add (Add (Val 5) (Val 3)) (Val (-10))
08:10:04 <Cale> guza: Is this homework?
08:10:07 <sproingie> interesting definition of <
08:10:09 <Cale> (I'm guessing yes :)
08:10:11 <guza> yeah dude
08:10:15 <guza> i said that before :D
08:10:23 <guza> its not a thing where i want someone to do it for me
08:10:27 <sproingie> 8 < -2
08:10:29 <sproingie> go fig
08:10:31 <guza> yeah
08:10:35 <guza> weird i know
08:10:40 <guza> but its specified like that
08:10:52 <m0nkfish> looks like you should be studying scheme :p
08:10:54 <guza> because the first struct is a substruct of second struct
08:10:56 <Cale> guza: Yeah, that's okay. I was just trying to figure out why you're defining such silly instances of Eq and Ord
08:11:00 <sproingie> i guess as long as you don't treat the numbers as, well, numbers
08:11:01 <guza> yeah :D
08:11:09 <sproingie> then it's a reasonable ordering.  kinda.
08:11:12 <guza> lol
08:11:15 <sproingie> partial ordering anyway
08:11:20 <guza> well the thing is
08:11:31 <quicksilver> guza: but then you don't want to use haskell's default definition of Ord at all
08:11:34 <guza> if I could see the code that haskell generates with deriving Eq,Ord
08:11:36 <quicksilver> it's completely unrelated, surely
08:11:37 <guza> yes
08:11:41 <quicksilver> the code for it would be uninteresting
08:11:43 <quicksilver> why do you want to see it?
08:11:43 <guza> but would love to see the code behind it
08:11:57 <sproingie> the code ghc generates is core
08:12:03 <guza> to copy that code into a new func calle checkStruct
08:12:12 <sproingie> the report specifies the code as semantics it has to follow, not the actual code it has to generate
08:12:12 <guza> because haskells Eq,Ord checks structure
08:12:19 <eivuokko> It is specified in report how default Ord instance is derived
08:12:47 <guza> kk wait to find it :P
08:12:57 <bastl> dreixel: wow, finally I get it. Just extended hData2Tree to ListOf ...
08:13:00 <quicksilver> (Val a) < (Val b) = a < b; Val _ < Add _ _ = True; Add a b < Add c d = a < c || (a == c && b < d)
08:13:05 <quicksilver> guza: there is the code, I think.
08:13:15 * bastl is happy.
08:13:16 <quicksilver> I don't think it is relevant to what you're trying to do.
08:13:47 <guza> can someone give me a link to the haskell report for eq and ord?
08:13:52 <quicksilver> missing a few () around the constructors in the second and third cases.
08:14:37 <dreixel> bastl: all works as expected
08:14:39 <dreixel> ?
08:14:53 <eivuokko> guza, http://haskell.org/onlinereport/derived.html
08:15:02 <bastl> yes, had to add Constructor instances to my types. but then it worked :-)
08:15:17 <bastl> and add ListOf to the the Data2Tree class
08:15:22 <dreixel> yep, you
08:15:36 <dreixel> you'll have to add that to every generic function you want to use
08:15:44 <bastl> yes.
08:15:50 <guza> @eivuokko ty
08:15:52 <lambdabot> Unknown command, try @list
08:16:19 <bastl> still. there are some bits that I dont understand yet. But I follow the imitate-adapt-innovate paradigm :-)
08:16:30 <bastl> This was inbetween imitate and adapt ...
08:16:30 <dreixel> extending multirec to work with lists is not very hard. but what we want is to extend it to work with functor composition in general (imagine, for instance, datatypes containing trees instead of lists, or maybes), but that's much trickier.
08:16:37 <eivuokko> guza, it's the "usual" way to do it, if you have to just invent one.
08:16:48 <eivuokko> (ie need ordering, but don't care which)
08:17:20 <bastl> dreixel: yeah sounds complicated. I jsut wanmt to use it on Blocks of statements in various languages ...
08:17:51 <bastl> ill try that now with some languages ..
08:17:58 <dreixel> good luck ;-)
08:34:36 <Optimality> o/
08:34:44 <Optimality> anybody got a second to answer a noob question?
08:34:53 <Botje> go ahead
08:35:02 <Optimality> I have a function, thus:
08:35:07 <Optimality> square_to_char :: Square -> Image
08:35:07 <Optimality> square_to_char s =
08:35:07 <Optimality>     let creature_list = sq_creatures s
08:35:08 <Optimality>     in case creature_list of h :: t -> let (a, c) = lookup_creature_display $ cr_type h
08:35:08 <Optimality>                                        in char a c
08:35:08 <Optimality>                              []     -> let (a, c) = lookup_terrain_display $ te_type $ sq_terrain $ s
08:35:10 <Optimality>                                        in char a c
08:35:14 <sproingie> @paste
08:35:15 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:35:17 <sproingie> use that next time please
08:35:20 <Botje> Optimality: that's a bit big. mind putting it on hpaste.org?
08:35:26 <Botje> that way we can refer to it without it scrolling by
08:35:41 <sproingie> doing a roguelike?
08:35:54 <sproingie> looks a bit like mage
08:35:57 <Optimality> sproingie: indeed :)
08:35:58 <Botje> could be Thud! as well ;)
08:35:58 <Optimality> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5101#a5101
08:36:04 <sproingie> Botje: Thud!?
08:36:09 <Optimality> apologies for the spam - there's the link
08:36:23 <Optimality> in particular, I get a syntax error on the 4th line
08:36:23 <Botje> sproingie: it's a game devised by terry pratchett
08:36:35 <sproingie> mage is all right, but LambdaHack looks a little better written
08:36:35 <Optimality> "parse error on input `let'"
08:37:02 <Botje> Optimality: did you mean (h:t) ?
08:37:04 <sproingie> then there's MazesOfMonad which has bunches of tests but it's very idiosyncratic
08:37:09 <Optimality> Botje: most likely I did
08:37:10 <Botje> :: is the "type of" operator
08:37:17 <Botje> but it's cons in ml
08:37:29 <Optimality> guess which language I used prior to Haskell? :)
08:37:42 <Optimality> thanks, apologies for the sillyness
08:37:51 <Optimality> that fixes it
08:38:01 <Botje> no problem. have fun!
08:38:05 * Optimality beats head against table
08:39:33 <Optimality> yeah, I'm working on a Haskell roguelike - I'm at the "@ walking around an empty room" stage
08:40:16 <c_wraith> what are you using for output?
08:40:24 <sproingie> heh me too
08:40:31 <Optimality> vty
08:40:49 <Optimality> the two curses libraries wouldn't install for some reason, I didn't bother tracking it down
08:40:57 <Optimality> Graphics.Vty seems to work nicely
08:41:08 <sproingie> yah i had problems with curses, vty just works
08:41:21 * Optimality curses curses
08:41:33 <sproingie> like i always say, there's a reason it's called curses
08:41:33 <c_wraith> Hmm.  I just wish vty didn't depend on mtl.
08:41:40 <Optimality> I'm going to wind up doing some UI engineering, but I'm okay with that
08:41:47 <Optimality> c_wraith: mtl?
08:41:55 <sproingie> c_wraith: zillions of things depend on mtl anyway
08:42:09 <c_wraith> it's nice when they can depend on mtl or transformers
08:42:22 <sproingie> more than meets the eye
08:42:37 <Optimality> why is depending on mtl bad?
08:43:15 <c_wraith> mostly because mtl and transformers have overlapping, but slightly incompatible functionality.
08:43:32 <Optimality> oic
08:43:32 <mmorrow> because satan kills a kitten every time you use Reader, and four puppies for every use of Cont (iirc)
08:43:50 <c_wraith> And so any package that depends on one, but breaks with the other, requires your whole project to go with that specific option
08:44:25 <c_wraith> And sometimes you have to judge which of two packages is more important to you, because they have incompatible dependencies
08:55:22 * hackagebot upload: hpage 0.4.7 - A scrapbook for Haskell developers (FernandoBenavides)
08:56:40 <aditya> evening gentlemen
08:56:59 <aditya> am new to haskell and happstack.. Need some help
08:57:32 <aditya> cabal: cannot configure time-1.1.4. It requires base ==4.*
08:57:41 <aditya> what does that mean?
08:57:49 <aditya> and how do i solve it
08:58:29 * hackagebot upload: full-sessions 0.6.1.1 - a monad for protocol-typed network programming (KeigoImai)
08:58:33 <sproingie> means it needs a bleeding-edge ghc version
08:58:44 <dcoutts> not very bleeding edge
08:58:51 <sproingie> ohwait, 4 is in 6.10
08:58:54 <dcoutts> ghc-6.10.x has been out for over a year
08:59:33 * sproingie did a ghc-pkg list | grep base and stopped at base-3.0.3.1
08:59:47 <sproingie> i have 6.12 elsewhere so i get confused as to what's in 6.10
09:00:24 <sproingie> aditya: basically means you need to upgrade your haskell version.  what version do you have now?
09:01:23 <aditya> 6.8.2 i guess. The Glorious Glasgow Haskell Compilation System, version 6.8.2
09:01:41 <aditya> ghc --version
09:01:46 <sproingie> yeah that's old
09:02:01 <sproingie> what OS are you on?
09:02:08 <aditya> ubuntu
09:02:12 <aditya> 8.04 i guess
09:02:22 <notweebl> no ghc in repos?
09:02:56 <sproingie> 8.04 is also fairly old
09:03:06 <aditya> sproingie, how do i upgrade? an apt-get install would do ? or do i need to download?
09:03:14 <notweebl> apt-get dist-upgrade
09:03:15 <notweebl> ?
09:03:18 <sproingie> you'd have to upgrade your ubuntu version
09:03:28 <aditya> that will take ages for me
09:03:43 <c_wraith> You can download the binary release of ghc
09:03:44 <sproingie> you could install the haskell platform and put it first in your PATH
09:03:58 <sproingie> not sure if there are debs of the platform
09:04:14 <c_wraith> platform on linux doesn't include GHC, so you'd need to start with just ghc
09:04:18 <sproingie> probably not, defeats the purpose of debs
09:04:56 <nomeata> sproingie: http://packages.debian.org/sid/haskell-platform
09:05:18 <sproingie> oh neat
09:05:46 <sproingie> is it a virtual package?
09:05:50 <kwos> what should I do with this error: cabal: failed to parse output of 'ghc-pkg dump'?
09:06:01 <sproingie> package size 2.4K so i'm inclined to say it is
09:06:09 <nomeata> sproingie: not virtual, but meta. it just depends on the library packges
09:06:37 <dcoutts> kwos: you need to upgrade cabal-install if you're using ghc-6.12
09:06:57 <kwos> oh.. I didn't know that
09:07:03 <kwos> yeah, makes sense ;-)
09:07:30 <kwos> uhm, it must be version from haskell platform that lingers in my system
09:09:42 <haskell_n00b> can some one help me with a small haskell problem
09:10:15 <nomeata> haskell_n00b: it’s hard without knowing it, so you should tell us about it
09:10:35 <quicksilver> @faq can haskell solve haskell_n00b's small haskell problem?
09:10:36 <lambdabot> The answer is: Yes! Haskell can do that.
09:11:12 <haskell_n00b> I'm would like to have a function that turns a file data into a list of strings
09:11:29 <haskell_n00b> I'm = I*
09:12:10 <sproingie> :t unlines
09:12:12 <lambdabot> [String] -> String
09:12:12 <quicksilver> do strs <- fmap lines (readFile "foo.txt")
09:12:16 <sproingie> oops
09:12:18 <quicksilver> something like that, perhaps.
09:12:22 <jkff> haskell_n00b: So, you need the lines of the read file?
09:12:37 <jkff> haskell_n00b: How about hoogling for "lines" and "readFile"?
09:12:42 <haskell_n00b> yes jkff
09:12:53 <haskell_n00b> I did
09:13:14 <haskell_n00b> but it didn't helped me
09:13:15 <jkff> Well, you read the file with readFile and split the result into lines with lines.
09:13:35 <jkff> Show your program and tell in what sense it doesn't fulfill your expectations
09:13:42 <quicksilver> as my short example illustrated :)
09:13:47 <jkff> Yep
09:14:04 <haskell_n00b> just a sec
09:14:30 <quicksilver> I wonder if there would be value in a repository of small, compilable code examples for obvious tasks like this.
09:14:37 <quicksilver> For people who rather learn from examples than documentation.
09:17:44 <Botje> modules in CPAN have a nice synopsis that shows how to use the module
09:18:59 <quicksilver> sure, but I was thinking of more basic stuff than that
09:19:29 <quicksilver> "Read a file and count the lines" "Read a file and output it, translating spaces to _s" "Input two numbers and add them"
09:23:12 <haskell_n00b> is it possible to get the data of a file and to use it as a string in lines st.
09:23:28 <haskell_n00b> somthing like st = readFile "foo.txt"
09:23:38 <haskell_n00b> lines st
09:24:03 <jkff> st <- readFile "foo.txt"
09:24:03 <jkff> lines st
09:24:20 <haskell_n00b> tnx
09:24:21 <jkff> haskell_n00b: you need to read about the "do syntax" for monads
09:24:35 <haskell_n00b> I will tnx
09:24:48 <sproingie> quicksilver: rosetta code is pretty close to that
09:24:59 <jkff> Or simply read any code dealing with files at all. For example, try reading "Real World Haskell" http://book.realworldhaskell.org/read/
09:25:02 <sproingie> quicksilver: it'd be nice if more modules came with example docs
09:28:55 <quicksilver> sproingie: that's certainly true.
09:42:01 <ksf> zomg. 2 days, 75 up votes, zero (0) downvotes.
09:42:09 <notweebl> for what
09:42:31 <ksf> and geezusfreak stole my karma by posting the same thing to the progit.
09:42:38 <ksf> http://www.reddit.com/r/haskell/comments/a7ceg/what_monads_are_not/
09:45:09 <Froc> msg NickServ identify 1rcus3r
09:45:24 <lament> Froc: your password passes the security check
09:45:34 <lament> but it would be even more secure if you used some punctuation and capital letters
09:45:43 <medfly> it's just an IRC password though
09:45:46 <medfly> :-)
09:45:52 <quicksilver> also, it would be more secure if ou didn't share it with a public channel
09:45:53 <danderson> and right now, it would also be more secure if it were different
09:45:57 <medfly> hahaha
09:46:01 <medfly> very true :-)
09:46:03 <Froc> ah dammit - now i have to chage it anyways
09:46:16 <quicksilver> unfortunately, Froc used the same password for his online bank
09:46:27 <quicksilver> well, unfortunately for him, but fortunately for me. See you in barbados.
09:46:46 <medfly> hehe
09:46:57 <notweebl> i almost thought this was quakenet
09:47:18 <notweebl> i blame medfly
09:47:43 <lament> :-)
09:47:58 <medfly> hi notweebl! :)
09:51:53 <kosmikus> sproingie: thanks for saying that LambdaHack is (relatively speaking) better written, but I'm actually not very happy with the way it's written
09:52:25 <kosmikus> sproingie: all this talk about roguelikes here motivates me to make some changes to it again
09:53:14 <lament> It is pitch black. You are likely to be eaten by a bind.
09:55:55 <Apocalisp> http://www.cafepress.com/angband.64831168
09:56:04 <eugenn> Hi everyone :), does anyone know witch function can I use to do this? ('a','b') `someFunction` ('d','c') and returns [('a','b'),('d','c')] ?
09:56:42 <BONUS> \a b -> a:b:[]
09:56:46 <Lemmih> eugenn: someFunction a b = [a,b]?
09:57:14 <kosmikus> Apocalisp: :)
09:57:17 <eugenn> of course! I'm so stupid :P thanks!
09:57:34 <Apocalisp> kosmikus: You know you want one.
09:59:13 <Apocalisp> http://www.cafepress.com/0x1de.64802017#
09:59:14 <BONUS> @pl \a b -> [a,b]
09:59:15 <lambdabot> (. return) . (:)
10:00:35 <BONUS> > let (+) = curry (sequence [fst,snd]) in ('a','b') + ('d','c')
10:00:36 <lambdabot>   [('a','b'),('d','c')]
10:01:37 <ksf> > ('a','b') `mplus` ('d','c')
10:01:39 <lambdabot>   No instance for (Control.Monad.MonadPlus ((,) GHC.Types.Char))
10:01:39 <lambdabot>    arising f...
10:01:48 <ksf> arguably, that _could_ work.
10:02:08 <fritschy_> is there a function that transforms a value into a tuple which contains he value twice? i.e. a -> (a,a) like \x -> (x, x)?
10:02:14 <ksf> but I guess Seq would be a better choice for a generic sequence monoid.
10:02:29 <ksf> @pl \x -> (x,x)
10:02:30 <lambdabot> join (,)
10:02:39 <fritschy_> hmm...
10:02:44 <fritschy_> ksf: hank you :)
10:02:45 <ksf> that's... quite evil.
10:02:48 <BONUS> > (liftM2 . liftM2) (++) return return ('a','b') ('d','c')
10:02:49 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
10:02:49 <lambdabot>    arising from a use o...
10:02:49 <fritschy_> is it?
10:02:51 <ksf> on a pointless scale, that is.
10:02:56 <fritschy_> :D
10:03:05 <BONUS> > liftM2 (++) return return ('a','b') ('d','c')
10:03:05 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
10:03:05 <lambdabot>    arising from a use o...
10:03:08 <BONUS> eh
10:04:22 <ksf> my favourite pointless function is still
10:04:31 <kosmikus> Apocalisp: I like this one: http://www.cafepress.com/+322799800
10:04:34 <ksf> :t uncurry (flip (,))
10:04:35 <lambdabot> forall b a. (a, b) -> (b, a)
10:05:27 <Apocalisp> kosmikus: Brilliant.
10:11:28 <ski> @type snd &&& fst
10:11:31 <lambdabot> forall a c. (a, c) -> (c, a)
10:11:44 <ystael> :t (&&&)
10:11:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:12:05 <ski> @type Right ||| Left
10:12:07 <lambdabot> forall b a. Either b a -> Either a b
10:13:50 <ksf> :t (|||)
10:13:51 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
10:14:15 <ksf> yep, arrows are all the rage when it comes to tuples.
10:14:35 <ksf> they hold the standard for generalisations being abused for mundane tasks.
10:15:28 <sshc> why is ghc failing by a parse error with "import System.FilePath.Posix (</>)" ?
10:15:44 <ksf> add another pair of parens.
10:15:55 <sshc> ksf: thanks
10:16:14 <ksf> ...as the outer one are interpreted as those delimiting the import list
10:19:26 <helmut> Hi. I'm thinking about how to implement the group Z/nZ in haskell. The tricky part here is that this is not one group, but infinitely many ones. And if I don't want to choose the group at compile time I get less checks.
10:19:38 <helmut> Any ideas on that?
10:19:45 <koeien37> yes, i've been thinking about a similar problem (but the field GF(q))
10:19:53 <helmut> :-)
10:19:57 <koeien37> i didn't see any solution except for some TH. would love ideas too
10:20:37 <helmut> and the bad part is that some algorithms I'd like to implement depend on the group order.
10:21:56 <helmut> koeien37: could you show me parts of your th solution?
10:22:16 <koeien37> let me see if i can find it
10:23:00 <helmut> and do you know whether I need extra packages on debian?
10:23:15 <ksf> helmut, you could always do the TH part manually, that is, generate different code at run-time and link to it.
10:23:20 <koeien37> ah i have it. the code is pretty horrible, though, so beware (if you only want Z/nZ, your job is easier :) )
10:23:31 <koeien37> helmut: extra packages for what?
10:23:35 <helmut> for th
10:23:46 <koeien37> no
10:23:49 <koeien37> it's in GHC
10:23:50 <ksf> ...we really should go JIT.
10:24:02 <helmut> hmmm.
10:24:06 <koeien37> helmut: http://functor.nl/~jochem/FiniteFields.hs
10:24:15 <koeien37> but i warned you :P
10:24:29 <koeien37> ksf: something like that would be very useful for applications like Yi and xmonad, too
10:25:05 <helmut> hmmm. your warning is appropriate
10:25:14 <ksf> the llvm backend will ease that trendemously, most likely.
10:25:26 <koeien37> helmut: i doubt i can read the code myself now. i've never actually *used* it
10:25:39 <ksf> porting, too, as llvm runs on virtually everything.
10:25:42 <helmut> can I simultaneously construct Integer many types?
10:26:11 <helmut> (so I'd have a type for every group, this is acceptable for me)
10:26:26 <ksf> with TH you can construct whatever you want.
10:26:29 <koeien37> the idea was that you could do something like $(createGF 'GF4 2 [1,1,1]) to create the field with 4 elements
10:26:34 <helmut> and without? ;-)
10:26:50 <ksf> do you have a sturdy keyboard?
10:27:01 <Twey> Heh
10:27:04 * ksf recommends IBM Model m.
10:27:43 <burp> sure
10:28:03 <ksf> there's always some idiots selling them under-price at ebay, not knowing their worth.
10:28:41 <ksf> (at least that's where I bought 5 of those. together with 10 bunk keyboards, all in all 7 euros+shipping)
10:28:45 <nomeata> Hi. Is there a gtk2hs IRC channel somewhere?
10:28:58 <EnglishGent> hi!
10:29:02 <m0nkfish> ksf what is so great about them
10:29:03 <helmut> hmm. I can do data Foo a = ... but can I somehow make that a be an Integer instance?
10:29:16 <ksf> oh the buckling spring.
10:29:18 <EnglishGent> is there a standard class in one of the libraries for representing *partial* orders?
10:29:20 <burp> I prefer writing on laptop like keyboards
10:29:20 <koeien37> helmut: Integer is a type, not a class?
10:29:22 <ksf> oh their weight.
10:29:29 <EnglishGent> (not lattices, that would be too specific for what I'm doing)
10:29:30 <koeien37> helmut: what do you mean?
10:29:42 <helmut> koeien37: oh. I'm often confusing terms. I probably meant value, sorry.
10:29:51 <ksf> they are used by several army programmers as side-arm.
10:30:03 <ksf> you can slay velociraptors with them.
10:30:05 <helmut> koeien37: in many other languages values of types are called instances, sorry.
10:30:06 <dcoutts> nomeata: not any dedicated one
10:30:09 <nomeata> Or maybe someone can me help with this problem: GUI: user error (Pattern match failure in do expression at gtk/Graphics/UI/Gtk/MenuComboToolbar/ComboBox.chs.pp:244:2-13)
10:30:16 <ksf> http://en.wikipedia.org/wiki/Model_M_keyboard
10:30:21 <koeien37> helmut: then why is your type parametrized?
10:30:41 <helmut> koeien37: because I'd like to have a type for every Integer.
10:30:51 <tensorpudding> it has a shortage of modifier keys though
10:31:15 <koeien37> helmut: ah, now i see what you mean. you want Foo 1 = some type, Foo 2 = some other type, ... ?
10:31:17 <dcoutts> nomeata: looking at the source will give you a strong hint
10:31:17 <ksf> I've got more than I regularily use.
10:31:35 <dcoutts> nomeata: and the docs too "Retrieve the model that was created with 'comboBoxSetModelText'"
10:31:36 <tensorpudding> well,i use emacs and xmonad, so i need at least three distinct ones
10:31:40 <helmut> ksf: yeah and the number should be the n in Z/nZ.
10:31:40 <nomeata> I’m not calling comboBoxGetModelText, AFAIK.
10:31:41 <ksf> left alt is virtually unused, as are both right alt and control.
10:31:47 <helmut> err koeien37 .. sorry
10:31:49 <ksf> ...and xmonad uses capslock.
10:32:01 <tensorpudding> eh
10:32:01 <nomeata> (And the code was working with a previous version of gtk2hs, I’m just trying to make it compile again)
10:32:03 <ksf> and you using emacs is your own responsibility.
10:32:05 <dcoutts> nomeata: oh ok, lines do not match up with the version I'm looking at then
10:32:07 <koeien37> helmut: eh no, not directly. you could use type-level numerals though
10:32:13 <tensorpudding> i can't stand using the regular ctrl key on keyboards
10:32:25 <tensorpudding> i don't want an emacs pinky
10:32:28 <koeien37> http://developers.slashdot.org/story/09/11/24/2120246/Haskell-2010-Announced # wee
10:32:34 <helmut> koeien37: right. I did that before.
10:32:38 <burp> http://www.logitech.com/index.cfm/keyboards/keyboard/devices/4740&cl=us,en I plan to buy this one
10:32:45 <nomeata> dcoutts: I think they do, I’m just not calling comboBoxGetModelText directly.
10:32:47 <helmut> koeien37: so I just define the group order in one place and change it there.
10:33:02 <koeien37> helmut: you could, but it will not be efficient
10:33:03 <dcoutts> nomeata: ok, well the problem will be that there is no text model
10:33:19 <koeien37> helmut: at least. i think you could
10:33:24 <nomeata> dcoutts: thx, I’ll see if that hint gets me going
10:33:30 <dcoutts> nomeata: that function is called by the other *Text variants
10:33:51 <koeien37> i'd definitely use TH if you can live with only finitely many statically determined instantiations
10:33:56 <dcoutts> nomeata: the *Text versions are a "convenience" so you do not have to set up your own model
10:34:15 <dcoutts> nomeata: but they only work with comboBoxNewText
10:34:20 <dcoutts> as it says in the docs
10:35:02 <helmut> koeien37: I know type level numerals and yes that would work.
10:35:32 <helmut> koeien37: but my integers will not be representable as int.
10:35:53 <nomeata> dcoutts: so not with a comboBox I got from glade?
10:35:59 <helmut> thanks for all your thoughts. :-)
10:36:11 <nomeata> dcoutts: ah, thanks, it works now
10:37:03 <koeien37> so, why not use TH?
10:37:49 <koeien37> do you need to change your number n at run time?
10:39:22 <helmut> koeien37: probably not.
10:39:41 <helmut> koeien37: it would just be a nice feature not to recompile for changing it.
10:40:26 <koeien37> i don't know ML, but didn't ML have something like "parametrized modules" that would solve this entirely?
10:40:46 <helmut> next question: when writing a class Group a where ... I'd need the group order. as it depends on nothing I could write it like order :: Integer *except* that it needs to depend on the actual group in use!
10:41:20 <helmut> I probably need a throw-away parameter here, right?
10:41:21 <koeien37> order :: a -> Integer would work, and then call like  order (undefined :: Z37)
10:41:31 <helmut> hmmmm
10:41:34 <koeien37> a bit ugly
10:41:44 <helmut> probably doing this. :-/
10:43:00 <helmut> uh wait. I can return the order of the created (? german term is "erzeugt") subgroup of the given element then. :-)
10:43:27 <koeien37> you mean the order of the element itself. i.e. ord <g>
10:43:34 <helmut> s/created/generated/
10:43:37 <helmut> yes
10:44:05 <helmut> this actually makes much more sense in my application.
10:44:05 <koeien37> well, order-finding in general is hard. in Z/nZ it's easier
10:44:24 <ski> koeien37 : yes, functors would allow instantiating a structure (~= module) many times, parameterized with different integers each time .. some implementations even allow run-time functor application, iirc
10:44:50 <koeien37> hmm, that is actually pretty neat
10:46:15 <ski> (each instantiation would generate a new distinct type for each type abstractly exported by the structure (returned by the functor), though)
10:56:43 <CalJohn> Aside from GHC and Happstack, can anyone think of some haskell (or FP in general) projects that are likely to enter Google Summer of Code?
11:00:53 <Cale> Heh, perhaps we need a cohackage to tell us.
11:01:17 <opqdonut> heh
11:02:09 <CalJohn> Cale: I'm not at an intellectual stage where I get that joke, yet...
11:03:06 <tensorpudding> in cohackages, packages download you!
11:03:16 <koeien37> lol
11:03:37 <maltem> ey algebra is not Chuck Norris
11:04:14 <trofi> @help remember
11:04:20 <kwos> uhmm.. I'm trying to build cabal and I get Setup: failed to parse output of 'ghc-pkg dump'
11:04:32 <kwos> this error is chasing me whole day :-/
11:04:42 <trofi> kwos: what distro/ghc version?
11:05:22 <lambdabot> quote <nick>
11:05:22 <lambdabot> remember <nick> <quote>
11:05:22 <lambdabot> Quote somebody, a random person, or save a memorable quote
11:05:22 <lambdabot> trofi: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:05:36 <kwos> trofi: ghc 6.12 on snow leopard
11:05:40 <dcoutts> kwos: since you're using ghc-6.12 you need Cabal-1.8 (which comes with 6.12) and if you want to use cabal-install then you need the darcs version of cabal-install
11:06:52 <kwos> dcoutts: should newer version of cabal get installed with the RC2 of 6.12?
11:07:24 <trofi> kwos: it's already installed (bundled with ghc)
11:07:24 <dcoutts> kwos: ghc itself does not come with the cabal program
11:07:37 <dcoutts> trofi: ghc comes with the Cabal library
11:07:42 <trofi> oh sorry
11:07:55 <trofi> i always think of the library
11:08:18 * trofi used to treat cabal binary as cabal-install package
11:09:33 <kwos> O_o I have no idea where this version I've got comes from
11:09:50 <kwos> find / -name cabal does not find anything LOL
11:09:58 <trofi> cabal -v
11:10:03 <sproingie> @vixen LOL
11:10:04 <lambdabot> what's the last book you read?
11:10:07 <trofi> cabal -V
11:10:25 <kwos> 1.6.0.3
11:10:30 <sproingie> ironically enough, "Idiot America" was the last book i read
11:10:42 <dcoutts> kwos: if you're not using the cabal program then don't worry about it
11:11:06 <kwos> yeah, but I want cabal program to work
11:11:38 <lament> sproingie: that book seems like one giant troll
11:11:47 <lament> i wish i were a good enough troll to get published
11:12:45 <koeien37> is it written by an idiot american, a smug european or somebody else?
11:13:12 <sproingie> it's a book version of what was originally an essay in Esquire
11:13:14 <sproingie> and it shows
11:13:20 <sproingie> lots of irrelevant filler
11:13:54 <thebloggu> does anyone knows a library which allows me to easily deal with gmail?
11:14:09 <sproingie> the book adds one new idea, that it's just fine that America's full of cranks and kooks, because it always has been
11:14:19 <sproingie> just that there wasn't previously an industry dedicated to elevating them to experts
11:14:44 <sproingie> but overall it's kind of a hodgepodge book
11:15:50 <lament> sproingie: the reviews suggest that the book is politically biased, with examples of stupidity taken only from the right and not the left
11:16:12 <sproingie> lament: it wears its bias pretty openly
11:16:19 <sproingie> the left ain't putting saddles on dinosaurs
11:16:48 <sproingie> splitty splitty
11:17:48 <sproingie> lament: dunno if you got that.  the bias is pretty open.  the need for equivalency is kind of a big part of the problem.
11:21:15 <wzp> hello
11:21:28 <wzp> i have a problem understandin the <- 'thing'
11:21:40 <wzp> understanding*
11:21:43 <tommd> "bind"
11:21:54 <tommd> x <- recvFromNetwork
11:22:03 <tommd> x binds to the value from recvFromNetwork
11:22:10 <tommd> its like "=" but monadic.
11:22:25 <wzp> alright i haven't been that far
11:22:32 <wzp> for monads and stuff
11:22:43 <ben0x539> wzp: It is syntax sugar involving the >>= function of monads
11:22:48 <tommd> wzp: You'll get there.
11:23:36 <wzp> ok i'll put it another way, [x*2 | x <- [1..10]] what does that x <- [1..10] mean there ? (from learnyouahaskell.com)
11:23:36 <tommd> right, so if you understand the true bind operator of >>= then <- should make sense as:  x <- fromNetwork  becomes
11:23:37 <tommd> fromNetwork >>= x -> ... rest of code ...
11:23:41 <tommd> fromNetwork >>= \x -> ... rest of code ...
11:23:47 <tommd> needed the lambda.
11:24:26 <tommd> wzp: So that means for each value from 1..10 you will get a list of those values multiplied by 2.
11:24:50 <wzp> i know it's something like 'take x from 1..10', but i guess it's too early to understand how the <- really works
11:24:51 <tommd> I always say "for the list of x*2 where x draws from the list of 1 to 10"
11:26:38 <wzp> ok, i guess that's what i understood. i'll look more in depth at it later
11:27:00 <ben0x539> wzp: Well, it is exactly what <- does here. It is special syntax pretty much exactly for that case.
11:27:12 <ben0x539> More generally, you can express it as [1 .. 10] >>= \x -> return (x*2) if you want...
11:27:41 <tommd> Thats the list monad.  See the "meet the monads" explanation, I always liked that.
11:27:45 <tommd> @where meet the monads
11:27:47 <lambdabot> I know nothing about meet.
11:27:48 <tommd> @where mtm
11:27:50 <lambdabot> I know nothing about mtm.
11:27:52 <tommd> damn you
11:28:16 <tommd> @where+ mtm http://www.haskell.org/all_about_monads/html/meet.html
11:28:17 <lambdabot> Done.
11:28:37 <tommd> @where+ mtm http://www.haskell.org/all_about_monads/html/introduction.html
11:28:38 <lambdabot> Good to know.
11:28:40 <tommd> Even better
11:28:49 <tommd> Double where+ will overwrite the old, right?
11:30:12 <wzp> isn't it a bit too early to look at monads (and god knows what they are) atm ? i started reading learning haskell as my first functionnal language yesterday, so i'm quite new to this, i'll take it easy
11:30:28 <koeien37> a bit too early, yes
11:30:33 <koeien37> you will need to understand typeclasses first
11:30:40 <mauke> yeah, monads are too trivial to understand
11:30:40 <koeien37> (because in Haskell, a Monad is a typeclass)
11:31:18 <koeien37> spj is right :( we should call them warm fuzzy things :(
11:34:13 <Rotaerk> monads aren't a hard concept, though they're not particularly easy to learn without a high-level explanation of them
11:34:32 <lament> Concepts which aren't easy to learn are hard.
11:34:37 <Rotaerk> just looking at the definition of the typeclass and the do expressions... can be confusing
11:34:52 <tommd> wzp: For now yes.  Getting an intuitive feel for the list comprehension you showed is sufficient.
11:34:57 <Rotaerk> primarily because it obfuscates a lot of the work that's actually being done
11:35:25 <koeien37> s/obfuscates/abstracts from
11:35:53 <Rotaerk> koeien37, that abstraction can make things unclear to a beginner though
11:35:53 <lament> Monads are easy to understand, but in order to understand them you need to write a tutorial on understanding monads.
11:35:58 <koeien37> Rotaerk: sure
11:36:35 <Rotaerk> lament, heh, that's how most tutorials are written... by beginners trying to learn the topic of the tutorial
11:37:19 <wzp> damn recursion is twisting my mind
11:37:45 <wzp> it's quite a radical change, my brain is getting tortured
11:37:57 <Polarina> wzp: :)
11:38:14 <wzp> i'll get used to it, right ?
11:38:15 <mmorrow> wzp: think of the function arguments as the variables you're modifying in the for loop
11:38:28 <lament> wzp: why are you recursing? :)
11:38:29 <mmorrow> because that's essentially the translation
11:38:36 <Polarina> wzp: Try not to think as a programmer, think as you were underwater.
11:38:41 <Polarina> wzp: Of course.
11:38:56 <Cale> wtf, Xorg seems to be leaking memory like crazy
11:39:07 <lament> half of the haskell standard libraries is there to help you avoid recursion
11:39:18 <Cale> It's grown by > 300MB in one day.
11:39:44 <koeien37> wzp: recursion is in fact a very natural thing to do
11:39:50 <Cale> (and at the moment I have nothing but my desktop and IRC client running)
11:40:03 <wzp> lament: i don't want to avoid it, i want to get used to it and understand it and be able to solve problems with it o/
11:40:33 <lament> wzp: one good exercise is reimplementing things like map, filter, etc
11:40:45 <wzp> koeien37: some people are ready to argue against that
11:40:47 <Polarina> lament: map can be implemented without recursion.
11:40:54 <lament> possibly peeking at their source first
11:41:08 <koeien37> wzp: you do it everyday when you count! :)
11:41:14 <mmorrow> , let fromTo m n | n < m = [] | otherwise = m : fromTo (m+1) n in fromTo 0 9
11:41:16 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
11:41:21 <Rotaerk> wzp, I used to be confused by recursion because my mind would attempt to execute the recursion and overflow.  I find it easier to understand conceptually the purpose of the function, and whenever I see the call to f from within f, I just think of it symbolically rather than mentally recursing into it
11:41:28 <Polarina> map f xs = [f x | x <- xs]
11:41:40 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1
11:41:42 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
11:41:49 <mauke> Polarina: list comprehensions are concatMap; that doesn't count
11:41:49 <koeien37> Polarina: your list comprehension is defined in terms of map...
11:42:08 <wzp> Rotaerk: damn, that's exactly me, i'm recursing mentally like hell
11:42:17 <wzp> and i get stack overflow
11:42:29 <mauke> you need to think inductively
11:42:39 <mmorrow> @undo [[x*y | y <- xs] | xs <- xss, x <- xs]
11:42:40 <lambdabot> concatMap (\ xs -> concatMap (\ x -> [concatMap (\ y -> [x * y]) xs]) xs) xss
11:43:02 <koeien37> the correct mindset is, suppose f(P ) gives a solution to P. How can I get this solution from a slightly smaller problem , given the fact that f works correctly for smaller inputs. (iow, thinking inductively as mauke said)
11:43:31 <koeien37> e.g., suppose that we want to sum all numbers from 0 to n. f n = n + f (n-1), since f(n-1) is the sum of all numbers from 0 to n-1 by assumption.
11:43:52 <koeien37> to guarantee termination, you will often need a base case, in this case f 0 = 0 will do
11:44:00 <mauke> I prefer starting with the base case
11:44:04 <mmorrow> also, a bunch of the time you have to make use of your eventual solution (via a recursion) before you've actually finished figuring out how to solve the problem
11:44:07 <mauke> it's easy because there's no recursion there
11:44:28 <mmorrow> which happens a lot with mutually recursive functions
11:44:48 <koeien37> mauke: sometimes you need more than 1 base case
11:44:55 <koeien37> i don't have a particular preference
11:45:05 <mauke> all your base case are belong to us.
11:45:17 * mmorrow usually defines a function with the type he needs as `undefined', works out the types, finishes one function under the assumption the currently "undefined"'ed one works, then writes that one
11:45:58 <wzp> koeien37: oh yeah, i see, i'm starting to get it
11:46:38 <wzp> it'll take some time to get used to it
11:46:45 <Rotaerk> wzp, take the fibonacci sequence for instance.  you start with 0 and 1, and then every number after that, let's call it the nth number, is equal to the previous number (n-1)th plus the one before that (n-2)th
11:46:50 <mauke> oh, also tail recursion is a lot easier because you can derive it mechanically from a loop version
11:47:05 <Rotaerk> which is precisely what:  f 0 = 0; f 1 = 1; f n = f (n-1) + f (n-2)
11:47:06 <Rotaerk> says
11:47:14 <mauke> so if you can write the algorithm with loops, you can write it with recursive functions
11:47:36 <koeien37> mauke: and not even in the "most programming languages we know are Turing complete!"-sense
11:47:36 <mmorrow> mauke: well, with goto and labeled blocks for the non-trivial cases
11:47:42 <Rotaerk> at this point I find recursion easier than loops sometimes
11:48:55 <mmorrow> "loop" in the for/while/do/etc sense is just a single tail-recursive function
11:49:13 <ben0x539> How do I tell whether a function call is tail-recursive again?
11:49:18 <ben0x539> Or more generally a tail call?
11:49:27 <lament> it feels like a loop :)
11:49:33 <sproingie> if it doesn't have to evaluate anything after the recursive call
11:49:40 <mmorrow> once you get more than one function involved in the tail-recursion, you'd need goto to model it
11:49:43 <ben0x539> Yeah, sure, it feels like a loop all the way until suddenly my stack explodes :(
11:50:01 <Rotaerk> f 0 = 0; f x = f (x - 1) + 1
11:50:06 <Rotaerk> is not tail-recursive
11:50:08 <sproingie> with haskell it can be tricky to know what it has to evaluate
11:50:15 <mauke> ben0x539: well, tail recursion in haskell can lead to stack overflows
11:50:16 <sproingie> lots of things that don't look tail recursive are
11:50:16 <Rotaerk> because it has to add 1 after it's called f (x - 1)
11:50:19 <Philonous1> @type \f xs -> foldr (\a b -> f a : b ) [] xs
11:50:25 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
11:50:43 <Rotaerk> lazy evaluation changes a lot of rules
11:50:48 <Rotaerk> with recursion
11:51:03 <sproingie> in general you kind of have to eyeball it and get a feel for it
11:51:12 <sproingie> that's one reason primitive recursion isn't all that nice
11:51:19 <ben0x539> is forever tail recursive?
11:51:21 <sproingie> and maps and folds are easier to reason about
11:52:02 <mmorrow> , let mapT f (Node x xs) = Node (f x) (mapF f xs); mapF xs = fmap (mapT f) xs in mapT (*2) (Node 1 [Node 2 [], Node 3 []])
11:52:03 <lunabot>  luna: Couldn't match expected type `[Data.Tree.Tree a]'
11:52:22 <mmorrow> umm
11:52:37 <phf> why does map on Data.Set maps to a set, as opposed to a list. (as in (a->b)->Set a->Set b instead of ->[b]). is there some deep reason for that?
11:52:47 <EnglishGent_> eh? how can tail recursion blow the stack in Haskell? it cant do that in Scheme
11:52:52 <sproingie> because it's a set and not a list?
11:52:53 <Rotaerk> mmorrow, why'd lunabot address luna instead of you
11:53:07 <Botje> phf: converting from a set to a list is less work than the other way round.
11:53:08 <mmorrow> oh
11:53:08 <Cale> EnglishGent_: The stack is used for something *entirely* different
11:53:10 <Daimonic> hey, I have two IO () functions and I want to conc. the string output in another IO () function, something like: out :: IO()
11:53:10 <Daimonic> out = out1 ++ out2. How can I append them to each other?
11:53:11 <mauke> EnglishGent_: because laziness
11:53:13 <mmorrow> , let mapT f (Node x xs) = Node (f x) (mapF f xs); mapF f xs = fmap (mapT f) xs in mapT (*2) (Node 1 [Node 2 [], Node 3 []])
11:53:14 <lunabot>  Node {rootLabel = 2, subForest = [Node {rootLabel = 4, subForest = []},No...
11:53:27 <mauke> Daimonic: huh?
11:53:33 <Rotaerk> Daimonic, lift concatenation
11:53:36 <mmorrow> Rotaerk: that's the name of the evaluator's executable
11:53:38 <Botje> Daimonic: IO () functions don't return anythin useful.
11:53:41 <Cale> The Haskell evaluator looks nothing like a Scheme interpreter because it uses (something close to) lazy evaluation.
11:53:43 <Rotaerk> mmorrow, ah
11:53:54 <Daimonic> yeah... that's what I guessed
11:54:00 <sproingie> EnglishGent_: haskell puts thunks on the stack.  if you accumulate enough thunks without forcing them, you blow the stack
11:54:16 <Cale> sproingie: that's...
11:54:17 <Daimonic> so is it even possible without writing them down in a main function ?
11:54:29 <phf> Botje: oh, Set->[] before mapping is less work then converting Set->[]->Set
11:54:37 <jmcarthur_work> Daimonic, i think your terminology is a bit off
11:54:40 <Rotaerk> Daimonic, main expression *
11:54:43 <Daimonic> yes it is
11:54:43 <mmorrow> it puts a frame on the stack that represents the fact that that thunk's under evaluation, and needs to be updated when it finishes
11:54:43 <Cale> Thunks go on the heap, but that's not really the right level of abstraction anyway
11:54:50 <path[l]> could someone show me how I can memoize a 2 parameter function in haskell
11:54:56 <jmcarthur_work> Daimonic, you mean you have out1 ∷ IO String and out2 ∷ IO String?
11:55:01 <Cale> path[l]: Data.MemoCombinators :)
11:55:10 <path[l]> thanks
11:55:27 <path[l]> Cale did anything in those graphs earlier suggest any obvious thing I missed?
11:55:50 <sproingie> thunk, frame pointing to thunk, whatever ... i sort of oversimplified all the way into "wrong"
11:55:51 <Daimonic> jmcarthur_work: that would be to get an input line, wouldn't it? my out1 = putStr "la la la"
11:56:08 <Cale> path[l]: It looks to me like you're just generating lots of intermediate lists which are immediately garbage. It might be possible if you refactor things enough to eliminate some of them.
11:56:08 <jmcarthur_work> Daimonic, oh, you're outputting
11:56:16 <jmcarthur_work> Daimonic, you could just use >>
11:56:47 <Daimonic> ah... I knew this operator once... well once :P
11:56:55 * mmorrow remembers why he just wrote mapT/mapF
11:56:57 <path[l]> Cale: hmm oh ok .... I have to think about that. I mean its an algorithmic problem so I dunno if its possible, but let me think
11:56:57 <jmcarthur_work> :t (>>)
11:57:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:57:12 <path[l]> hmm is Data.memocombinators something that comes with ghc
11:57:25 <jmcarthur_work> nurp
11:57:33 <Cale> path[l]: no, http://hackage.haskell.org/package/data-memocombinators
11:57:46 <path[l]> aww then I cant use it
11:57:54 <path[l]> guess Ill need to see the source
11:57:55 <path[l]> lol
11:57:58 <jmcarthur_work> why not?
11:57:58 <mmorrow> that mapT/mapF mutually recursive pair is the smallest-possible multiple-entry/multiple-exit graph, that compiler-books/papers/whatever usually refer to as an "irreducible" control-flow graph
11:58:16 <path[l]> Im doing stuff for an online contest site that only uses ghc
11:58:20 <jmcarthur_work> ah
11:58:21 <Daimonic> jmcarthur_work: works fine, what can i google to learn more about this operator? monads it is?
11:58:32 <Cale> path[l]: You could also just do something like define an array of the values of your function, and then define a function which just looks things up in the array
11:58:36 <mmorrow> and you can't form irreducible graphs with "structured" control-flow constructs, like for/while/do
11:58:38 <sproingie> any limit to what you can paste into your code?
11:58:50 <mmorrow> (which is actually exactly what their purpose is)
11:58:54 <jmcarthur_work> Daimonic, that operator can actually be implemented with just Applicative, but you should probably just keep on with a tutorial until it covers monads
11:58:55 <path[l]> nope, I can steal the source Im sure lol
11:59:17 <path[l]> Cale: yeah I saw the fib example. I wasnt quite sure how to extend that to 2 parameters
11:59:17 <jmcarthur_work> Daimonic, if you are not following a tutorial i recommend learn you a haskell
11:59:22 <jmcarthur_work> @where lyah
11:59:23 <lambdabot> www.learnyouahaskell.com
11:59:24 <helmut> Is there a nicer way to embed a let x=stuff in a list comprehension than [ .. | ..., x <- [stuff]]?
11:59:30 <Cale> I really ought to get around to writing that stepwise simplified-Haskell evaluator sometime.
11:59:39 <mauke> helmut: yes, let x = stuff
11:59:59 <jmcarthur_work> Cale, yeah you always have to reimplement your usual tour here ;)
11:59:59 <helmut> mauke: so like [ .. | ..., let x = stuf, ...]  works?
12:00:07 <Daimonic> jmcarthur_work: learn you a haskell is most definetly awesome - but the monad chapter is not written yet
12:00:13 <Cale> Everyone always talks about thunks and low-level stuff like that when discussing how Haskell is evaluated, and I think that's the wrong way to look at it.
12:00:14 <jmcarthur_work> oh really? i did not know that
12:00:14 <mauke> helmut: yes
12:00:20 <helmut> mauke: nice, thanks!
12:00:34 <jmcarthur_work> Daimonic, looked at real world haskell any?
12:00:40 <Daimonic> yeah :) but I worked with that tutorial 1 year ago, gave me the jump on functional programming
12:00:57 <Daimonic> no, is that good?
12:01:01 <Daimonic> (O'Reilly?)
12:01:07 <Cale> We really ought to talk about how expressions are transformed. There's a nice connection between heap and stack usage and the structure of the expression being evaluated.
12:01:09 <jmcarthur_work> @where rwh
12:01:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:01:16 <jmcarthur_work> Daimonic, ^^
12:01:39 <jmcarthur_work> yeah, o'reilly
12:01:41 <Cale> The stack is composed of case expressions which are waiting for their scrutinees to be evaluated enough so that they can pattern match.
12:01:51 <sproingie> that it?
12:01:59 <jmcarthur_work> Daimonic, it's not as beginner friendly, but goes into a lot more depth than lyah
12:01:59 <Cale> yep
12:02:04 <Cale> The heap is composed of bindings made by let expressions.
12:02:06 <mmorrow> you could also heap-allocate "stack frames" as a linked-list, in which case stack-overflow and heap-exhaustion coincide
12:02:12 <sproingie> huh.  very different picture than usually painted
12:02:45 <mmorrow> also, you could have more interesting shapes of "control stacks" that way too
12:02:53 <mmorrow> (like with callcc)
12:02:53 <benmachine> hi, what's a simple way to generate sequences of random Word32s?
12:02:58 <Daimonic> jmcarthur_work: I think of myself as a already improved haskell programmer
12:02:59 <sproingie> what about bytecode?  does the VM keep a stack on the C stack?
12:03:02 <mmorrow> it'd be an inward-directed tree
12:03:03 <benmachine> preferably uniform between minBound and maxBound
12:03:05 <Daimonic> I forgot alot, though
12:03:42 <mmorrow> haskell doesn't use the stack that C functions in the rts happen to use
12:03:52 <Daimonic> I just helped a college out, but out prof explains the concept of data abstraction and data structures, besides java also on haskell, so we learn the concept and not cling to much on the syntax
12:03:53 <mmorrow> (@sproingie)
12:03:53 <jmcarthur_work> Daimonic, rwh shouldn't be too difficult then
12:04:06 <sproingie> more generally, is there any documentation lying around for the STG machine?
12:04:14 <jmcarthur_work> @where stg
12:04:16 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:04:24 <roconnor> *GHC* doesn't use the stack that ...
12:04:25 <mmorrow> sproingie: you mean the STG machine in the abstract? or ghc's evaluation model?
12:04:41 <mmorrow> roconnor: that's what i meant, yes
12:04:48 <sproingie> mmorrow: either would be informative, i'm interested mostly in how the STG machine works in the abstract
12:05:02 <sproingie> yay citeseer is back
12:05:12 <mmorrow> sproingie: there's an "the STG machine" paper, but it's outdated
12:05:13 <jmcarthur_work> <3 citeseer
12:05:32 <Cale> ^^ backwards netsplit? Did a server drop all its clients on the floor?
12:07:11 <mmorrow> sproingie: this is a good one http://www.haskell.org/~simonmar/papers/evalapplyjfp06.pdf
12:07:11 <Cale> EnglishGent_: anyway, you were interested in why tail-recursion isn't necessarily a good thing in Haskell. Let's take a look at an example
12:07:32 <Cale> EnglishGent_: (if you'd like)
12:07:36 <mmorrow> sproingie: (not about STG per se, but very informative)
12:08:35 <Cale> EnglishGent_: still here?
12:08:36 <Lemmih> Cale: I'm interested.
12:09:06 <Cale> okay
12:09:08 <Cale> @src foldl
12:09:10 <lambdabot> foldl f z []     = z
12:09:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:09:31 <Lemmih> (I may be missing some context, though)
12:09:35 <Cale> foldl is tail recursive, as you can see that in the nonempty list case, it just calls itself with the same parameters
12:09:43 <Lemmih> Right.
12:10:03 <Cale> So, suppose we evaluate something like:
12:10:09 <Cale> foldl (+) 0 [1,2,3]
12:10:18 <Cale> -> foldl (+) (0 + 1) [2,3]
12:10:23 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
12:10:28 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
12:10:33 <Cale> -> ((0 + 1) + 2) + 3
12:11:01 <Cale> All of this so far has been done with constant stack usage.
12:11:45 <Cale> However, we now have an expression in which the outermost reducible subexpression, namely the (0 + 1) is buried a few levels deep
12:12:08 <Cale> It will require stack space to dig that expression out so we can reduce it.
12:12:12 <EnglishGent_> yes - sorry Cale
12:12:18 <EnglishGent_> was busy debugging some code :)
12:12:37 <EnglishGent_> (in elisp I'm sad to say... )
12:13:02 <EnglishGent_> though if it's a consolation - my comments now include the Haskell type signature (where applicable) :)
12:13:20 <Cale> EnglishGent_: I'll give you a moment to catch up then :)
12:13:21 <sproingie> code i have to work with every day is perl.  and not even perl i wrote
12:13:33 <sproingie> it's a hairball of state and misused inheritance and virtually impossible to test
12:14:09 <EnglishGent_> actually - gonna get a drink as well - brb!
12:14:13 <EnglishGent_> and thanks Cale :)
12:14:20 <Cale> (...) + 3  can't pattern match until we evaluate the left parameter to (+), so it goes on the stack
12:14:23 * sproingie could use some very stiff drinks after dealing with this perl
12:14:31 <Cale> and then (...) + 2 for the same reason
12:14:33 <zygoloid> it's ironic really. tail recursion is about keeping the distance from yourself to the code which does the work small, in some sense, but laziness means that you want to force things as early as possible to achieve that
12:14:54 <sproingie> there's foldl' but i'm kind of mystified how it actually works
12:15:09 <sproingie> it uses seq which i only vaguely grok
12:15:36 <Cale> foldl' is what fixes this issue by causing the evaluation of the expression to occur as we walk down the list, so a large expression isn't built up
12:15:53 <tommd> Is 'system' the preferred way to run commands these days?  I see runCommand, but want/need the blocking behavior of system so I know the command has finished.
12:16:02 <tensorpu`> don't give foldl an infinite list
12:16:37 <Baughn> tommd: If system does what you want, then use syste.
12:16:53 <sproingie> this is why i like #haskell
12:17:03 <Cale> Well, that's another problem with tail recursive functions. They never give anything else a chance to evaluate, so they tend to fall down when you give them an infinite structure.
12:17:05 <sproingie> #python would be screaming with apoplexy at the mention of using os.system
12:17:06 <lunabot>  luna: Not in scope: `python'
12:17:20 <Cale> sproingie: why?
12:17:33 <Baughn> tommd: You are, of course, aware of the potential downsides - it's interpreted by the shell, etc.
12:17:52 <zygoloid> Cale: oh noes string injection attack insecure escaping difficult execvp!
12:17:55 <sproingie> Cale: it's the culture of the channel
12:18:24 <zygoloid> Cale: and then the guy who suggests execvp gets flamed by someone who likes popen2, and he gets flamed by the guy who likes subprocess
12:18:27 <sproingie> granted system does suck for reasons of the shell
12:18:51 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html -- well, we have lots of cool stuff in here if you don't like system.
12:18:56 <EnglishGent_> back
12:18:58 <zygoloid> and the guy who likes subprocess gets flamed by the guy who likes twisted but can't quite explain how to get async subprocesses to work properly with twisted :)
12:19:00 <tommd> Baughn: yes, that isn't a downside in my particular case.  Thank you.
12:19:10 * EnglishGent_ returns armed with a hot chocolate :D
12:19:28 <Baughn> tommd: FWIW, when it is, to get blocking behaviour use waitForProcess
12:19:35 <sproingie> zygoloid: god forbid one brings up threads
12:19:46 <tommd> Makes sense, thanks for the tip.
12:19:50 <zygoloid> *shudder*
12:20:06 <sproingie> i mean the dogmas there aren't actually wrong ones, they're just ... strident.
12:20:39 <EnglishGent_> hmm - I think that makes sense Cale` - though it surprised me
12:20:41 <zygoloid> sproingie: i once asked in #python how to get subprocess to work with asyncore. the answer was 'learn a new library and paradigm and rewrite your whole project using twisted'
12:20:50 * EnglishGent_ finds lazy evalauation often seems to do that :|
12:21:03 <mmorrow> Cale: in the "-> foldl (+) (((0 + 1) + 2) + 3) [] ..." example, i think it's also worth noting that every "a + b" there is being heap-allocated
12:21:15 <sproingie> zygoloid: which is funny because deep in the guts of twisted, it pretty much behaves like asyncore
12:21:17 <Baughn> tommd: Oh, and note that GHC does not close (most) file handles before forking. It does close the remote end of pipes used for stdin/out/err, after forking, though this is a recent development. ^^;
12:21:31 <sproingie> zygoloid: in fact you can see remnnants of code style that could have come from nowhere else
12:21:45 <zygoloid> sproingie: that and, it doesn't actually solve the using-subprocesses-at-the-same-time problem :D
12:22:07 <Baughn> zygoloid: Well, do you know how to do it in C?
12:22:11 <Baughn> zygoloid: Or, rather, POSIX?
12:22:28 <mmorrow> EnglishGent_: whereas with foldl' nothing is heap allocated (in the case of Int), and in the case of, say, Set with union, the union operation is done immediately (to the extent it needs to be to arrive at a constructor)
12:22:37 <zygoloid> Baughn: yes. however, the python subprocess module leaks file descriptors if it gets a SIGCHLD at the wrong moment.
12:22:47 <mmorrow> rather than heap-allocating a frozen function application of "union" to two sets
12:23:02 <Baughn> zygoloid: Ahh.
12:23:25 <Baughn> zygoloid: I seriously think posix needs a create-pipe-and-mark-one-end-as-close-on-exec call. ^^;
12:23:33 <zygoloid> in the end i grabbed a copy of subprocess's source, fixed the EINTR bugs and now it works :D
12:23:48 <zygoloid> Baughn: yeah, that'd be nice :)
12:24:29 <mmorrow> EnglishGent_: which is why, if you're recursing tail-recursively, you'll most likely want to be forcing the args that you're propagating at regular intervals, so you're not building up some massive structure in the heap composed only of frozen function applications
12:24:32 <zygoloid> Baughn: or a 'forkpipe' which on fork splits the FD into a read end for one side and a write end for the other?
12:24:32 <sproingie> zygoloid: these days there's deferToProcess, back then you could have used deferToThread, but of course they hate the mention of even managed threads.  oh well, is why i'm no longer there
12:25:09 <EnglishGent_> yeah - I've actually discovered the need for $! in real code at least once so far
12:25:21 <Baughn> zygoloid: Both would be useful, for different things. FDs for files, you don'twant to leak at all.
12:25:29 <mmorrow> EnglishGent_: i.e., you'll want to actually be /doing/ work along the way, rather than building up a representation of the work you /want to be done/
12:26:27 <jmcarthur_work> i must just write a much larger amount of inherently lazy code than anybody else
12:26:37 <sproingie> i didn't write it at all
12:26:39 <sproingie> mine's lazier
12:26:48 <EnglishGent_> out of interest (a daft question) what would be the semantics of language that made no gurantees about evaluation order? (i.e. may reduce expressions in any order, without requiring that the order be fixed)
12:27:12 <jmcarthur_work> EnglishGent_, haskell is actually "nonstrict" which doesn't actually make many guarantees
12:27:18 <Baughn> jmcarthur_work: Because it doesn't fail? I think that's "inherently pull", not "inherently lazy". Pull works with lazy, push works with strict, but GHC isn't smart enough to tell which is which
12:27:29 <Baughn> jmcarthur_work: Nobody writes code as if it were merely nonstrict
12:27:37 <EnglishGent_> example - if you said (and x y z) - might result in x,y & z being evaluated in any order at all, and in fact it's entirely possible only 1 of them will be fully evaluated
12:27:40 <mmorrow> EnglishGent_: well, haskell's order of evaluation is defined precisely, it's the order that parts of your expression graph are demanded
12:27:48 <jmcarthur_work> Baughn, because i don't use foldl', seq, or ($!) very often at all
12:28:09 <mmorrow> jmcarthur_work: do you ever union a list of Sets?
12:28:13 <Baughn> jmcarthur_work: Which works when the code is made to be pulled, not pushed
12:28:16 * EnglishGent_ is thinking of the mathematical properties of 'and' here - the order doesnt matter, and as soon as I know one sub-expression yields false - there's no point computing the rest
12:28:34 <jmcarthur_work> mmorrow, when i do something like that it's usually in maybe one place in the entire program
12:28:41 <EnglishGent_> that actually makes some expressions terminate that wouldnt otherwise do so doesnt it?
12:28:44 <mmorrow> jmcarthur_work: or sum a list of numbers, or M.unionWith (S.intersectionWith M.union)
12:28:47 <EnglishGent_> x = x and False
12:28:48 <mmorrow> jmcarthur_work: ah
12:28:51 <EnglishGent_> now has an answer
12:28:54 <sshc> is there a function that behaves similarily to PHP's explode?
12:29:07 <mmorrow> sshc: unsafeFireZeMissiles?
12:29:21 <mmorrow> sshc: (what does explode do?)
12:29:25 <jmcarthur_work> of course there must be some strictness just for things to happen, but i seem to usually have that rather localized
12:29:29 <ben> The inverse of intercalate
12:29:41 <jmcarthur_work> or perhaps hidden away with strictness annotations in data types
12:29:54 <mmorrow> ah, so like split of a particular character?
12:30:02 <mmorrow> s/of/on/
12:30:06 <ben> string, rather
12:30:17 <mmorrow> right, split a string on..
12:30:20 <Asztal> http://hackage.haskell.org/package/split
12:30:22 <ben> a substring!
12:30:22 <jmcarthur_work> Baughn, you're right. much of my code is pull-based
12:30:23 <ben> welp
12:30:42 <sshc> mmorrow: it's similar to lines.  if the delimiter is first, then explode '3' "aoeu3ueoa" will return ["aoeu","ueoa"]
12:31:29 <Baughn> jmcarthur_work: I've been pondering lately, if it should be possible to explicitly encode that in the type-system and switch between lazy and strict semantics automatically, without risking mismatches
12:31:38 <mmorrow> jmcarthur_work: sure, a list of anything is pull based, but that doesn't necessarily say anything about the individual elements of the list
12:32:05 <mmorrow> > repeat (foldl' (+) 0 [0..10000])
12:32:07 <lambdabot>   [50005000,50005000,50005000,50005000,50005000,50005000,50005000,50005000,50...
12:32:48 <mmorrow> > repeat (foldl' S.union mempty (replicate 100 (S.fromList [0..100]))
12:32:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:33:03 <chrisdone> i can haskell
12:33:05 * mmorrow takes bets on whether this'll finish
12:33:07 <mmorrow> > repeat (foldl' S.union mempty (replicate 100 (S.fromList [0..100])))
12:33:16 <mmorrow> (finish := enough to print)
12:33:29 <mmorrow> err, wait that's just one i guess
12:33:31 <lambdabot>   [fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24...
12:33:43 <Peaker> sproingie, I don't think it's that horrible that #python denounces system, Python's threads, and other things that have alternatives that are better for pretty much every purpose (but it is nice to say it nicely)
12:33:51 <mmorrow> (i didn't mean that question as a joke ;)
12:34:25 <Peaker> sproingie, I now say the same about Python, Haskell is better for almost any purpose I can think of :-)
12:35:09 <Peaker> (Python has easier "eval", runtime imports, better tracebacks, and easier runtime hooking to allow various cool tricks like RPyc)
12:35:11 <sproingie> Peaker: oh they're correct 99% of the time, they just aim at being the next ##c with the attitude they bring with it
12:35:26 * hackagebot upload: atom 0.1.2 - A DSL for embedded hard realtime applications. (TomHawkins)
12:35:40 <mmorrow> @let explode _ [] = []; explode p xs = let (ys,zs) = break p xs in ys : explode p (drop 1 zs)
12:35:50 <lambdabot>  Defined.
12:35:54 <Peaker> But all these things are not as important as purity, laziness, strong types, performance, scalability, etc
12:35:59 <mmorrow> > explode (=='.') "127.0.0.1"
12:36:01 <lambdabot>   ["127","0","0","1"]
12:36:14 <mmorrow> sshc: no pre-defined function (unfortunately)
12:36:27 <Peaker> mmorrow, maybe etalacretni ?
12:36:33 <mmorrow> :o
12:36:46 <mmorrow> hah
12:36:52 * mmorrow just reversed
12:36:57 <Peaker> @let etalacretni = explode . (==)
12:36:59 <lambdabot>  Defined.
12:37:09 <Peaker> > etalacretni '.' "127.0.0.1
12:37:11 <lambdabot>   <no location info>:
12:37:11 <lambdabot>      lexical error in string/character literal at end o...
12:37:12 <Peaker> > etalacretni '.' "127.0.0.1"
12:37:15 <lambdabot>   ["127","0","0","1"]
12:37:32 <Peaker> > intercalate '.' . etalacretni '.' $ "127.0.0.1"
12:37:34 <lambdabot>   Couldn't match expected type `[a]'
12:37:34 <lambdabot>         against inferred type `GHC.Types...
12:37:47 <Peaker> > intercalate "." . etalacretni '.' $ "127.0.0.1"
12:37:49 <lambdabot>   "127.0.0.1"
12:37:52 <Peaker> oh that's not quite right
12:38:00 <Peaker> need explode based on substrings
12:38:02 <mmorrow> yeah, splitting on a sub
12:38:07 <mmorrow> string is harder
12:38:20 <mmorrow> (computationally)
12:38:32 <ben> Should it not be wordsBy or something
12:38:32 <mmorrow> (s/ly// complexity-wise)
12:38:35 <Twey> ‘Etalacretni’ could almost be Estonian or something
12:38:40 <Peaker> does Haskell have std libs for fast substring searching?
12:38:55 <mmorrow> iirc there's a kmp on hackage?
12:38:59 <Twey> Haskell doesn't have stdlibs for fast anything to do with strings
12:39:12 <Twey> If you want speed, you need something other than String
12:39:31 <Peaker> Twey, forget fast, good complexity :)
12:39:43 <sproingie> BMH on ByteString would be nice
12:39:43 <Twey> :t isInfixOf
12:39:45 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
12:40:07 <Peaker> building an FSM for searching a substring of length m is O(m) isn't it?  So substring search is really O(m+n) as you'd expect?
12:40:07 <Baughn> isInfixOf is hardly the fastest around
12:40:25 <Twey> Baughn: In the standard libraries?
12:40:31 <sm> how would I match "1 to n occurrences of a char" in parsec ?
12:40:31 <Baughn> Peaker: It can be O(n) if it doesn't actually match
12:40:44 <Twey> sm: many1 (char 'c')
12:40:45 <Peaker> Baughn, m is usually smaller than n anyway
12:40:48 <Baughn> Peaker: If it matches, then yes, obviously you have to read the entire string you match /agains/..
12:40:50 <sm> ie 1 or 2, but not 3
12:40:52 <sproingie> these days i have to say DFA or NFA, because FSM makes me think of His Noodliness
12:40:52 <Peaker> Baughn, so O(n+m) = O(n)
12:40:57 <Baughn> Twey: Hm
12:41:26 <Baughn> Peaker: That's not how it works. You don't have a guarantee that m < n, so you have to say m+n.
12:41:28 <Peaker> Baughn, if you have the string length, and can build a FSM in O(substring) then search is always O(string)
12:41:31 <sproingie> clearly Thanksgiving with its traditional lack of pasta, must deeply offend the FSM
12:41:52 <Peaker> Baughn, a long string can't be a substring of a short one :)
12:42:08 <lament> the tradition of lack of pasta goes back centuries
12:42:11 <Baughn> Peaker: I didn't say it'd succeed
12:42:29 <Twey> sm: Or ‘count n (char 'c')’ if you meant the ‘n’ to be a constant
12:42:29 <Peaker> Baughn, If you have the string length (Using a linked-list type that keeps the length around)
12:42:30 <Baughn> Peaker: It's O(m+n) if you read m strictly, or build the FSM strictly
12:42:52 <sm> Twey, I think that will match exactly n, but I need 1..n
12:43:10 <Polarina> Is there a serie of exercises to do in Haskell, listed gradually and linearly increasing in difficulty?
12:44:03 <Baughn> Polarina: Not haskell, exactly, but the Euler problems have this approximate nature
12:44:05 <akappa> Polarina, try with the exercises in "real world haskell"
12:44:06 <Baughn> Polarina: You can use those
12:44:23 <Polarina> Baughn: Thanks.
12:44:31 <akappa> Baughn, euler's problem are more of a mathematical nature
12:44:35 <Twey> sm: Well, string $ replicate n 'c'
12:44:42 <akappa> they are fun, but they are essentially mathematics
12:44:51 <Baughn> akappa: Computer-aided mathematics. ;)
12:44:54 <Twey> Er
12:44:58 <Twey> Sorry, still being stupid :þ
12:45:03 <Baughn> They are at least somewhat helpful in learning haskell
12:45:04 <sproingie> ruby-warrior might be a fun problem set for less math-minded folks
12:45:05 <sm> np
12:45:17 <akappa> Baughn, yes, but IMHO there are better exercises to try if one wants to improve their programming skills
12:45:29 <Baughn> akappa: If that's /all/ you want to do, then yes.
12:45:42 <sproingie> ruby-warrior is largely a decision tree thing from what i can see
12:45:51 <sm> I'm trying to match a date, but only one or two digits; so that the parser error message doesn't say expecting another digit, when that wouldn't be correct
12:45:59 <sm> not to worry
12:46:05 <akappa> Baughn, I assume that when someone wants some exercises for learning a language, yes
12:46:10 <kwos> what's the shortest code to parse CSV file?
12:46:19 <sproingie> surprisingly long
12:46:23 <akappa> kwos, code golf?
12:46:26 <sproingie> to parse it correctly that is
12:46:56 <kwos> I'm wondering if I need a proper parser
12:47:09 <Polarina> kwos: map (split ",") . unlines $ csvfile
12:47:16 <Polarina> kwos: You get the idea.
12:47:17 <Baughn> kwos: Depends. There's actually a standard for CSV.
12:47:18 <sm> try (count 2 digit) <|> count 1 digit seems ok
12:47:22 <Twey> Ummm… many1 (char 'c') >>= flip when (fail "too many chars") . (> n) . length
12:47:24 <Baughn> kwos: Almost nobody follow it.
12:47:29 <mauke> Polarina: fails on fields with embedded commas
12:47:36 <Polarina> mauke: ;)
12:47:39 <sproingie> there's standards and there's excel
12:47:40 <Twey> Maybe?
12:48:21 <akappa> mauke, how a field can contain a comma?
12:48:31 <mauke> akappa: by putting it in quotes
12:48:39 <akappa> mauke, right
12:48:46 <akappa> escaping it
12:49:07 <Twey> foo,bar,"baz,quux",arthur
12:49:16 <wzp> could somebody explain me what's this 'xs' thing about ? why xs ?
12:49:23 <sproingie> wzp: the plural of x
12:49:30 <Twey> wzp: xs is the plural of x.
12:49:34 <Twey> Really, we should call it x's.
12:49:34 <akappa> in c a parser is a really trivial thing, you have to write an automaton substantially
12:49:38 <Twey> Hm, maybe I should start doing that.
12:49:40 <akappa> in haskell I don't know
12:49:43 <sproingie> Twey: noisy
12:49:50 <akappa> there's a good idiom to code automaton in haskell?
12:49:54 <Twey> akappa: It's more trivial.  ☺
12:50:01 <wzp> oh ok, well thanks for that information
12:50:10 <akappa> Twey, "more" refers to what?
12:50:12 <Twey> akappa: And doesn't necessarily involve code generation.
12:57:11 <Twey> csvValue = quotedString <|> manyTill (string ","); quotedString = between (symbol "\"") (symbol "\"") (sepBy $ string ",")
12:57:20 <Twey> CSV parser (I think)
12:57:21 <Twey> Oh
12:58:34 * hackagebot upload: mecha 0.0.4 - Mecha is a solid modeling language geared for machine design. (TomHawkins)
12:59:10 <Twey> quotedString = between (symbol "\"") (symbol "\"") $ manyTill "\"" ("\\\"" <|> anyChar); csvRow = sepBy $ string ","
12:59:17 <Twey> Something like that
12:59:28 * Twey goes to sleep in the hopes of clearing his fuzzy head.
13:04:42 <mmorrow> here's a (real) CSV parser http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724
13:04:48 <mmorrow> (supar fast too!@)
13:05:46 <mmorrow> akappa: you write an automaton in haskell with one or more (mutually)-recursive functions
13:06:04 <mmorrow> where each function corresponds to a different state
13:06:35 <Twey> Parsec works on bytestrings these days, I hear…
13:06:38 <mmorrow> (that CSV parser has a state datatype, but ghc actually turns that single function with four possible values of the state datatype into four separate functions as an optimization)
13:07:06 <pastah_rhymez> exactly what is a bytestring? a cool array hack?
13:07:27 <chrisdone> I've got a record, Word. it has a field "wrd_pos". I have a function Position -> Position, how do I express this easier? let Position{wrd_pos=pos} = word in word { wrd_pos=f pos }?
13:07:28 <Twey> pastah_rhymez: A speedy string of bytes.  ☺
13:07:35 <chrisdone> I swear there was some kind of short-hand
13:07:46 <mmorrow> pastah_rhymez: a ptr to an array (in the C sense) of bytes
13:07:53 <pastah_rhymez> chrisdone: no :p
13:07:57 <pastah_rhymez> well, fclabels
13:08:20 <pastah_rhymez> chrisdone: make a paste:
13:08:22 <pastah_rhymez> @paste
13:08:22 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:08:23 <Twey> chrisdone: word { wrd_pos = f $ wrd_pos word }
13:08:57 <chrisdone> oh yeah
13:09:04 <chrisdone> however, I do not like it
13:09:10 <Twey> Looks like a job for Semantic Editor Combinator Man, too
13:09:17 <chrisdone> did we get views yet or should I ask again in a year?
13:09:32 <Twey> View patterns are fine, but not so useful here
13:09:39 <chrisdone> not view patterns
13:09:41 <mmorrow> Twey: you could use Parsec for a CSV parser, but it'd be pretty pokey
13:09:56 <chrisdone> functional reference views
13:09:59 <chrisdone> bah
13:10:09 <byorgey> conal: looking for me?
13:10:14 <mmorrow> (also, it'd be un-usable for non-trivially large csv files)
13:10:36 <mmorrow> since parsec can't return any result until it's seen all the input
13:10:48 <conal> byorgey: yeah, i was.  then i sent you email (i think)
13:10:55 <mmorrow> well, you could do line-by-line, but it'd still be pokey ;)
13:10:57 <Twey> mmorrow: Ar.  :-\
13:11:07 <conal> byorgey: about formatting in a reddit comment
13:11:12 <byorgey> conal: ah, so you did, I haven't read it yet
13:11:31 <byorgey> conal: ah, I see, thanks.
13:11:40 <byorgey> I noticed that but didn't know how to fix it.  I am a reddit n00b.
13:11:48 <mmorrow> Twey: that hard-coded state-machine CSV parser does 100,000 lines in 0.346 seconds
13:11:54 <mmorrow> Twey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724#a2726
13:11:58 <Twey> Nice
13:12:00 <conal> byorgey: i can send you a working version you can just cut & paste.
13:12:09 <byorgey> conal: that would be nice, thanks =)
13:12:10 <mmorrow> Twey: bytestring-csv (which uses alex) takes 6+ seconds
13:12:13 <Twey> But it's also several pages long for a ridiculously simple format consisting of a total of four states :þ
13:12:14 <conal> byorgey: you bet.
13:12:30 <mmorrow> Twey: that's because there's also an incremental version
13:12:46 <conal> byorgey: i also just noticed another suggestion on your "collecting attributes" post.
13:13:14 <mmorrow> Twey: (and the parsec implementation is probably longer than that ;)
13:13:21 <byorgey> conal: yes, the recent one about transforming parent attributes or something like that?
13:13:27 <Twey> Ah!  Semantic Editor Combinator Man has arrived!
13:13:32 <mmorrow> Twey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724#a5103
13:13:33 <Twey> conal: How would you use SECs for ‘word { wrd_pos = f $ wrd_pos word }’?
13:13:34 <conal> :)
13:13:39 <conal> byorgey: yeah.
13:14:03 <Twey> mmorrow: Ah, that's… better ☺
13:14:08 <byorgey> Bitten by a radioactive semantic editor combinator, he now has the powers of a semantic editor combinator!!
13:14:17 <conal> Twey: analogous to first & second, right?
13:14:25 <akappa> mmorrow, thanks
13:14:39 <Twey> conal: No idea — it's just an accessor in a record
13:14:59 <Twey> byorgey: Hahaha
13:15:06 <jmcarthur_work> data-accessor ?
13:15:09 <conal> Twey: i mean that pattern does the same kind of job that first & second does
13:15:12 <jmcarthur_work> or lenses?
13:15:13 <Twey> Ah, yeah
13:15:24 <Twey> But on records, which I don't think works so well with first/second
13:15:34 <conal> Twey: so i'd write functions analogous to first & second for that type.
13:15:38 <jmcarthur_work> i haven't tried lenses, but it reminds me of SECs
13:15:39 <Twey> *nod*
13:15:41 <conal> Twey: those hofs are SECs
13:15:47 <Twey> Data.Accessor might be able to help
13:16:10 <Baughn> Cale: Oh god. 2011 is the year of Caleskell?
13:16:15 <Baughn> Cale: This scares me
13:16:22 <jmcarthur_work> or maybe i'm thinking a different one
13:17:02 <PetRat> Can someone point me to a web page that describes all the combinations of importing and exporting syntax---like how to control what you export, whether to export all constructors with a type or just the type, etc.
13:17:37 <Twey> Anyway, sleep, really
13:17:43 <ddarius> Baughn: ?
13:17:43 <byorgey> conal: did you have any thoughts on the new suggestion?
13:18:17 <Baughn> ddarius: <roconnor> "Right now, we will start forming a Caleskell 2011 committee to mange the process of deciding on changes for the new Caleskell revision."
13:18:45 <lament> I read that as "Caleskell religion" and it still makes sense
13:18:58 <jmcarthur_work> PetRat, the haskell 98 specification?
13:19:17 <ddarius> @where report
13:19:18 <lambdabot> http://www.haskell.org/onlinereport/
13:19:37 <jmcarthur_work> PetRat, and i think imports/exports are also affected by type families, so if you use that extension you will want to read up on it in the ghc documentation
13:19:47 <conal> byorgey: a few thoughts.  i like that he's loosened up from replacements to transformations.  still mired in representation and hence arbitrary.  and transforming parent context makes for a more complex model than is probably necessary.
13:20:09 <conal> byorgey: "exponentially" more complicated (in a literal sense)
13:20:32 <Cale> Baughn: what?
13:20:39 <PetRat> I was hoping for more a tutorial rather than Backus-??? notation.
13:20:43 <conal> byorgey: and it's probably a relic of state-machine thinking.
13:20:43 <byorgey> conal: hehe, yeah
13:21:08 <mmorrow> PetRat: Naur
13:21:13 <Baughn> Cale: http://www.reddit.com/r/haskell/comments/a7mfr/announcing_haskell_2010/c0g8hv3
13:21:17 <Philonous1> Why can't I implement fmap like this: "fmap _ x@(SName _) = x" (Where SName :: String -> Foo a)
13:21:27 * Cale looks
13:21:32 <byorgey> conal: honestly at this point I have a sense that this whole "how to override attributes" question is the wrong question.
13:21:40 <byorgey> conal: I am not sure what the right question is, though.
13:21:51 <ddarius> Philonous1: Because it has the wrong type.
13:21:53 <conal> byorgey: that's wonderful progress!
13:21:55 <mmorrow> Philonous1: because ghc considers x to still have the original type
13:21:56 <byorgey> =)
13:21:59 <jmcarthur_work> Philonous1, x has a different type from fmap f x
13:22:14 <Philonous1> But x is Forall a => Foo a.
13:22:27 <mmorrow> Philippa: right, and not Foo b
13:22:28 <ddarius> x, of course, has the type of x
13:22:36 <mmorrow> s/Phillipa/Philonious/
13:22:50 <Cale> Huh, I can ping reddit.com, but my browser isn't connecting.
13:22:54 <jmcarthur_work> i do think it is unfortunate that you can't write it that way
13:22:57 <mwc> @pl \x -> join . fmap compilers . confHook autoconfUserHooks x
13:22:58 <lambdabot> ((compilers =<<) .) . confHook autoconfUserHooks
13:23:00 <Philonous1> mmorrow: No, a is _not_ the type variable of my Type constructor
13:23:10 <jmcarthur_work> :t fmap
13:23:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:23:19 <jmcarthur_work> f a /= f b
13:23:22 <mmorrow> Foo a /= Foo b
13:23:24 <mmorrow> yeah
13:23:35 <conal> byorgey: how about the question: "what does it mean"
13:23:54 <mmorrow> Philonous1: not to say that it isn't annoying when you have to completely rebuild constructors on account of this
13:23:54 <jmcarthur_work> when you apply (fmap f) to x, the type checker unifies the type of x to f a, and it can't be reunified with f b
13:24:12 <jmcarthur_work> which, i say again, is just a shame
13:24:16 * ddarius whispers unsafeCoerce into mmorrow's ear.
13:24:26 <mmorrow> Philonous1: ghc /could/ tell that that's ok if it was slightly smarter
13:24:33 <jmcarthur_work> ddarius, you spread the evil among us
13:24:35 <Baughn> Cale: "<roconnor> Right now, we will start forming a Caleskell 2011 committee to mange the process of deciding on changes for the new Caleskell revision. No committee will discuss how to go about finding a Caleskell committee (the plan is to have Cale appoint members directly). Don't expect more details very soon."
13:24:40 * mmorrow suddenly feels the urge to unsafeCoerce something
13:24:42 <Baughn> Cale: "Not everyone can participate in the Caleskell 2011 process. Before you can be considered for appoint you must be able to correctly infer the type of fmap fmap fmap fmap fmap by hand. Solutions should be posted to http://haskell.org/haskellwiki/fmap-fmap-fmap-fmap-fmap"
13:24:43 <Philonous1> mmorrow: Ah so basically it forgets that it is polymorphic
13:25:00 <Cale> Baughn: hehe
13:25:10 <Philonous1> OK thanks. Makes sense. Kind of.
13:25:28 <jmcarthur_work> Philonous1, the forall you spoke of earlier is like a lambda abstraction, and the type checker applies that a type, so in a sense everything is monomorphic
13:25:50 <jmcarthur_work> *to a type
13:25:52 <mmorrow> Philippa: rather, since you actually /are/ going from (Foo a -> Foo b), it's not recognizing the fact that for that particular constructor, there isn't any remnant of the type `a' in it
13:25:57 <eldragon> polymorphic = many morphics? yeah!
13:26:28 <byorgey> conal: hehe, yes, of course =)
13:26:54 <Philonous1> I should consider using a different Nick. Poor Philippa always get's highlightet for naught
13:26:59 <mmorrow> hah
13:27:01 <mmorrow> oops
13:27:39 <Cale> I wonder why I can connect to everything but reddit, even though apparently reddit is up.
13:27:54 * hackagebot upload: hinotify 0.3 - Haskell binding to INotify (LennartKolmodin)
13:28:42 <eldragon> a typed system fully polymorphic should be unconstrained, the polymorphism never restrict anything.
13:28:57 <ddarius> Actually, nowadays especially, and potentially even before, the conversion from Foo a -> Foo b might be non-trivial even for constructors that make no use of type argument.
13:29:16 <mmorrow> yeah, that too
13:29:39 <jmcarthur_work> eldragon, we can do things like that with extensions, but only if you hide the type... which is the point, i think
13:30:02 <mmorrow> ddarius: hmm, actually though i don't see how that would complicate this particular case (??)
13:30:15 <mmorrow> fmap _ x@Nothing = x
13:31:32 <eldragon> i think that the static nature of the types limits too the dynamic nature of the types during the runtime.
13:32:09 <Twey> fmap fmap fmap :: (Functor f, Functor f', Functor f'') => (((a -> b) -> (f a -> f b)) -> (f' (a -> b) -> f' (f a -> f b)) -> (((a -> b) -> (f a -> f b)) -> (f' (a -> b) -> f' (f a -> f b))) -> f'' ((a -> b) -> (f a -> f b)) ARGH.
13:32:10 <jmcarthur_work> eldragon, what do you mean?
13:32:27 <jmcarthur_work> Twey, beautiful!
13:32:39 <Twey> I got to three places, but my head exploded.  ;)
13:32:41 <roconnor> Twey: hint: import Control.Monad.Instances
13:32:50 <idnar> @type fmap fmap fmap
13:32:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:32:54 <eldragon> i want to say that it's better to leave it dynamicly typed.
13:32:59 <roconnor> Twey: that's why you have to do it by hand.
13:33:01 <jmcarthur_work> eldragon, why?
13:33:03 <Twey> *headscratch*
13:33:07 <centrinia> @type id id id
13:33:09 <lambdabot> forall a. a -> a
13:33:19 <Botje> one of those fmaps is the fmap for functions
13:33:20 <roconnor> Twey: if you use GHCi you will get the "wrong" answer.  (by Caleskell standards).
13:33:56 <mmorrow> eldragon: the types don't exist at runtime though
13:34:11 <eldragon> jmcarthur_work, because sometimes, the system requires higher order typed functions that can't be statically typed.
13:34:17 <mmorrow> eldragon: so aren't checked dynamically, if you mess up you just segfault
13:34:18 <jmcarthur_work> eldragon, like what?
13:34:54 <mmorrow> eldragon: (not to say haskell's type system can type all functions that "work")
13:34:57 <Philonous> eldragon: The type system is indeed somewhat limited. But the answer is not to throw types away, but to use an even scarier type system
13:35:10 <jmcarthur_work> not scarier
13:35:13 <mmorrow> @type (\f -> (\x -> f (x x)) (\x -> f (x x)))
13:35:15 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:35:15 <jmcarthur_work> that is never the answer
13:35:15 <lambdabot>     Probable cause: `x' is applied to too many arguments
13:35:15 <lambdabot>     In the first argument of `f', namely `(x x)'
13:35:34 <mmorrow> @type (\f -> (\x -> f (Unsafe.Coerce.unsafeCoerce x x)) (\x -> f (Unsafe.Coerce.unsafeCoerce x x)))
13:35:36 <lambdabot> forall t t1. (t1 -> t) -> t
13:35:56 <mmorrow> (it works just like fix)
13:36:05 <jmcarthur_work> mmorrow, the simply typed lambda calculus can't do that, but of course the ability to do that is given to us as a primitive.
13:36:07 <mmorrow> actually, you can also do this
13:36:26 <mmorrow> , fix (const "foo" :: Int -> String)
13:36:27 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
13:36:30 <mmorrow> "foo"
13:36:42 <ddarius> mmorrow: There's nothing that keeps the compiler from using a different representation for Maybe A v. Maybe B.  Also, for type families, you can readily have different representations.
13:36:49 <mmorrow> jmcarthur: the simply typed lambda calc is pretty inexpressive though
13:36:53 <jmcarthur_work> agreed
13:36:58 <jmcarthur_work> which is why we aren't using it
13:37:01 <roconnor>  <eldragon> jmcarthur_work, because sometimes, the system requires higher order typed functions that can't be statically typed.
13:37:05 <mmorrow> ddarius: ah, true
13:37:08 * roconnor hasn't encountered this situation yet
13:37:26 <jmcarthur_work> roconnor, they exist, but i'm not sure how useful they are, given a powerful enough type system
13:37:36 <roconnor> I once heard of someone who was in that situation once.
13:37:50 <roconnor> friend of a friend of a friend.
13:38:53 <roconnor> jmcarthur_work: oh, ya, if you have a powerful enough type system, the cases because so obtuse, they are insane.
13:39:04 <jmcarthur_work> mmorrow, is there some reason i would ever write anything like (fix (const "foo" :: Int -> String))?
13:39:11 <ddarius> "higher order typed functions that can't be statically typed" is an internal contradiction
13:39:13 <roconnor> jmcarthur_work: basically you can only not type those programs that you don't know how to prove work.
13:39:32 <jmcarthur_work> i realize that it would be safe to unsafeCoerce, but applying fix to something like that doesn't make much sense to me anyway
13:39:49 <roconnor> ddarius: I droped the first "typed" in an attempt to parse that.
13:39:55 <roconnor> ddarius: perhaps I should have asked.
13:39:56 <ddarius> roconnor: On a vaguely related note, you may want to look at the class of sequentially realizable functionals.
13:39:57 <jmcarthur_work> roconnor, exactly
13:39:58 <eldragon> the unboxing operation is a premature optimization that should be abstracted internally of the lambda calculus
13:40:23 <Gracenotes> you can do more things with higher order untyped functions. both good and bad things :x
13:40:29 <jmcarthur_work> eldragon, boxed types is not a part of the lambda calculus...
13:40:41 <ddarius> jmcarthur: Your code may reduce to fix (const "foo") in some cases.
13:40:41 <roconnor> ddarius: I'm not sure I understand what your last three words mean together.
13:40:54 <ddarius> roconnor: That's because it's effectively a name.
13:41:34 <mmorrow> jmcarthur: i just meant that example to be wrt-the-type-of-the-arg-of-fix
13:41:48 <jmcarthur_work> ah
13:41:52 <jmcarthur_work> :t fix
13:41:56 <lambdabot> forall a. (a -> a) -> a
13:41:59 <roconnor> ddarius: so what does it mean? It sounds like another way of saying turing machines to me
13:42:07 <mmorrow> jmcarthur_work: i'm not sure off hand, but i'd be willing to bet there's at least *some* useful use of the more general type (a -> b) -> b
13:42:24 <roconnor> ddarius: oh wait, they are higher order
13:42:42 <mmorrow> @type (\f -> (\x -> f (Unsafe.Coerce.unsafeCoerce x x)) (\x -> f (Unsafe.Coerce.unsafeCoerce x x))) :: (a -> b) -> b
13:42:44 <lambdabot> forall a b. (a -> b) -> b
13:43:11 <mmorrow> hmm, actually maybe not, because you can't feed-back unless a==b
13:43:14 <eldragon> for me, types are justly annotations in the forest of expressions with sparse annotated types.
13:43:23 <roconnor> ddarius: in that case I still don't know exactly what class it is.
13:43:35 <mmorrow> so any function that uses the extra-generality, couldn't make use of feed-back
13:43:46 <mmorrow> which makes it useless?
13:43:48 <roconnor> eldragon: types are static proofs of invariants.
13:44:01 <eldragon> i wanna static proofs of invariants
13:44:29 <ddarius> roconnor: Its purely functional programs that can't be implemented in a purely functional language.
13:45:07 <roconnor> ddarius: that doesn't sound at all like what you said.
13:45:14 <ddarius> @google "sequentially realizable functionals"
13:45:18 <lambdabot> http://doi.ieeecomputersociety.org/10.1109/LICS.2002.1029834
13:45:18 <lambdabot> Title: Games on Graphs and Sequentially Realizable Functionals Extended Abstract
13:45:30 <ddarius> @google "when is a functional program not a functional program"
13:45:33 <lambdabot> http://citeseer.ist.psu.edu/253319.html
13:46:20 <roconnor> ddarius: does it have to do with partial functional programs?
13:46:23 <ddarius> roconnor: Well, actually the class includes all (sequential) purely functional programs including some that can't be implemented in a functional program.
13:47:32 <roconnor> ``We then consider two possible programming applications for these functions: the implementation of a search algorithm, and an algorithm for exact real-number integration.
13:47:36 <roconnor> from the abstract
13:47:56 <roconnor> are these exactly the functions that Escardo wrote in Haskell?
13:48:00 <ddarius> I don't know if it requires partiality, though the examples I'm aware of use it and it may be crucial.
13:48:42 <roconnor> (which require laziness and hence couldn't be written in the pure fragment of ML)
13:48:56 <ddarius> roconnor: No.  Laziness is irrelevant.
13:49:11 <jmcarthur_work> laziness can be simulated in a pure strict languages, afaik
13:49:16 <jmcarthur_work> *language
13:49:16 <roconnor> ddarius: I don't believe you.
13:49:27 <roconnor> jmcarthur_work: not tying-the-knot laziness
13:49:28 <mmorrow> jmcarthur_work: not the destructive update part
13:49:46 <jmcarthur_work> mmorrow, err, well, maybe not call-by-need
13:49:52 * roconnor downloads the paper
13:50:12 <mmorrow> jmcarthur_work: right, you couldn't get the "evaluated at most once" part
13:51:31 <ddarius> roconnor: Consider this function: F : ((() -> ()) -> ()) -> Bool; Define top, mid, bot as: top _ = (); mid x = x (); bot x = bot x;  Then F(top) = False; F(mid) = True; F(bot) = _|_ is, obviously, a function, but not one that you can write in Haskell.  It's pretty clear how to write it using exceptions/mutable state/etc.
13:51:49 <ddarius> Essentially F returns True if the passed in function uses its argument or not.
13:52:03 <roconnor> I see this
13:52:10 <roconnor> it is a non-monotonic functional.
13:52:25 <roconnor> that's lame.
13:52:35 <ddarius> roconnor: It's readily implementable in ML.
13:52:53 <ddarius> It's not like f _|_ = True; f _ = False.
13:52:59 * mmorrow is just reminded of the throwDyn/catchDyn "purified" functions in lunabot
13:53:06 <ddarius> (which is not implementable in ML)
13:53:06 <mmorrow> trying to remember the names..
13:53:13 <mmorrow> , toss (42::Int)
13:53:16 <lunabot>  luna: <<Int>>
13:53:50 <eugenn> is camelCase a convention in Haskell for naming functions?
13:54:03 <jmcarthur_work> most of us do camelCase, yes
13:54:03 <ddarius> eugenn: It's the convention for naming all values.
13:54:04 <mmorrow> , snag (foldl' (\a b -> if b==0 then toss (0::Int) else a*b) (0::Int) ([1..10]++[0]++[1..])) id :: Int
13:54:06 <lunabot>  0
13:54:10 <mmorrow> woo!
13:54:19 <mmorrow> snag and toss
13:54:25 <mmorrow> , snag (foldl' (\a b -> if b==0 then toss (0::Int) else a*b) (0::Int) ([1..10]++[0]++[1..])) id
13:54:27 <lunabot>  0
13:54:34 <mmorrow> , snag (foldl' (\a b -> if b==0 then toss 0 else a*b) (0::Int) ([1..10]++[0]++[1..])) id
13:54:36 <lunabot>  luna: <<Integer>>
13:55:11 <mmorrow> you need to annotate s.t. the toss'ed value's type is explicit though (or equivalent)
13:55:23 <mmorrow> (and it has to be Typeable)
13:56:38 <roconnor> let { f = if x then top else bot; x = F x } in x -- daruis: what does this denote?
13:56:46 <mmorrow> , let callcc f = let x = f toss in snag (x `seq` toss x) id in callcc (\k -> foldl' (\a b -> if b==0 then k(0::Int) else a*b) (0::Int) [0..])
13:56:48 <lunabot>  luna: <<Int>>
13:56:52 <mmorrow> , let callcc f = let x = f toss in snag (x `seq` toss x) id in callcc (\k -> foldl' (\a b -> if b==0 then k(0::Int) else a*b) (0::Int) [0..]) :: Int
13:56:54 <lunabot>  0
13:57:09 <roconnor> er
13:57:12 <roconnor> let { f = if x then top else bot; x = F f } in x -- daruis: what does this denote?
13:57:49 <mmorrow> roconnor: x :: () ?
13:57:50 <roconnor> oh crap
13:57:53 <roconnor> it is just bottom.
13:58:04 <roconnor> mmorrow: x :: Bool
13:58:13 <mmorrow> F :: (() -> ()) -> () i thought
13:59:14 <roconnor> F :: ((() -> ()) -> ()) -> Bool
13:59:23 <mmorrow> ahh
14:00:10 <roconnor> let me think some more
14:00:23 <roconnor> I still think there is something wrong with considering non-monotonic functionals.
14:00:33 <mmorrow> why?
14:00:54 <lpsmith> they are verboten in domain theory :-P
14:01:00 <roconnor> mmorrow: because they are not morphsisms in the category of Scott domains.
14:01:04 <mmorrow> plenty of functors map initial object to terminal, and vice-versa
14:01:06 <roconnor> mmorrow: and Scott is one smart cookie.
14:01:20 <mmorrow> maps x to dual x, etc
14:01:42 <mmorrow> roconnor: why are we restricting ourselves to this categories
14:01:43 <mmorrow> ?
14:01:47 <mmorrow> *category
14:02:25 <mmorrow> initial object := bot
14:02:29 <mmorrow> terminal object := top
14:02:41 <mmorrow> err, rather the other way around (wrt the :=)
14:02:54 <mmorrow> bot and top are defined in terms of initial and terminal
14:03:54 <mmorrow> what isn't clear to me though, is, in F(top) = False; F(mid) = True; F(bot) = _|_
14:04:02 <mmorrow> what False and _|_ are
14:04:54 <mmorrow> is False the initial object, _|_ the terminal, and True the single other object?
14:05:08 <roconnor> mmorrow: because Scott's solution to the domain equiation U = U -> U requires that the -> mean monotonic functions IIUC.
14:05:15 <tensorpudding> why does _|_ have to exist?
14:05:34 <mmorrow> roconnor: ok, but i don't get how domains and scott came up here
14:05:44 <roconnor> mmorrow: so if we start considering non-monotic funcitons like F we ought to be able to make non-denoting terms.
14:05:53 <mmorrow> tensorpudding: you mean an initial object? they don't have to exist
14:06:01 <tensorpudding> i know
14:06:09 <roconnor> mmorrow: it's in the paper that ddarius cited.
14:06:13 <tensorpudding> but why does hask have one?
14:06:14 <mmorrow> tensorpudding: ah, i see how you meant that now :)
14:06:31 <tensorpudding> do they need them to represent non-halting programs?
14:06:59 <mmorrow> roconnor: oh
14:07:03 * mmorrow rtfa's
14:07:23 <roconnor> tensorpudding: _|_ is a tool for giving denotations to partial computable higher-order functions.
14:09:41 <sshc> what's wrong with http://pastebin.com/f76079dff ?  The error is "Occurs check: cannot construct the infinite type: a = [a]      When generalising the type(s) for `explode'"
14:10:04 <mmorrow> so a "scott domain" is a category with at most a single morphism between any two objects, an initial object, and no terminal object?
14:10:23 <Botje> :t break
14:10:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:10:28 <sshc> explode is the inverse of intercalate
14:10:31 <Botje> :t isPrefixOf ""
14:10:33 <lambdabot> [Char] -> Bool
14:10:57 <Botje> sshc: you can't use isPrefixOf there, i think
14:11:38 <sshc> Botje: why not?
14:11:48 <roconnor> mmorrow: where did you get that definition from?
14:11:48 <mmorrow> roconnor: so a "scott domain" is a category with at most a single morphism between any two objects, an initial object, and no terminal object?
14:11:54 <mmorrow> roconnor: i made it up
14:12:01 <roconnor> that doesn't sound right at all.
14:12:10 <mmorrow> roconnor: what is it?
14:12:21 <Botje> :t break ([] isPrefixOf)
14:12:23 <lambdabot>     Couldn't match expected type `([a1] -> [a1] -> Bool) -> a -> Bool'
14:12:23 <lambdabot>            against inferred type `[a2]'
14:12:23 <lambdabot>     In the first argument of `break', namely `([] isPrefixOf)'
14:12:25 <roconnor> It is the category of domains with monotonic (or continuous) functions between them.
14:12:26 <Botje> :t break (isPrefixOf [])
14:12:28 <lambdabot> forall a. (Eq a) => [[a]] -> ([[a]], [[a]])
14:12:37 <mmorrow> roconnor: ok, what's the definition of domain?
14:12:50 <Botje> sshc: because you're using isPrefixOf there, it thinks s' is of type [[a]]
14:12:59 <mmorrow> roconnor: (i'm asking, not driving to some eventual point)
14:13:00 <roconnor> mmorrow: let's see, its a dcpo
14:13:07 <Botje> sshc: but then you call explode with s'', so that it's trying to unify [a] with [[a]]
14:13:11 <roconnor> directed continout partial order
14:13:15 <Botje> which can only work if a = [a]
14:13:17 <Botje> which is an error
14:13:18 <roconnor> maybe with some other nice properties.
14:13:25 <roconnor> continuous
14:13:42 <mmorrow> ah right, wrt a particular topology, being the "scott topology"
14:13:52 <roconnor> the dcpo induces a topology
14:13:58 <roconnor> time for me to go
14:14:02 <mmorrow> oh noes
14:14:31 <sshc> > break ("t" `isPrefixOf`) "foobarquuxtest"
14:14:33 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:14:33 <lambdabot>         against inferred ty...
14:15:11 <sshc> > break (`isPrefixOf` "t") "foobarquuxtest"
14:15:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:15:13 <lambdabot>         against inferred ty...
14:15:29 <Botje> sshc: have you looked at the methods in Data.List.Split?
14:15:33 <Botje> there's probably one you can steal
14:16:50 <sshc> > "t" `isPrefixOf` "test"
14:16:52 <lambdabot>   True
14:17:25 <sshc> oh, break behaves like that
14:17:56 <sshc> Botje: nothing in Data.List performs the inverse of intercalate
14:18:51 <mmorrow> i think that definition for "scott domain" above makes sense (not positive though, maybe another detail or two), because:
14:18:59 <mmorrow> _|_ := initial object
14:19:16 <mmorrow> at most one morphism between any two objects := follows from it being a partial order
14:19:39 <mmorrow> and that only monotonic functors make sense := follows from there not existing a terminal object for the initial object to map to
14:20:31 <mmorrow> "monotonic" := not contravariant
14:20:50 <mmorrow> (a -> b) := (a < b)
14:21:10 <lpsmith> mmorrow: so how did you learn category theory?
14:21:40 <mmorrow> lpsmith: in connection with abstract algebra/topology (was a math major)
14:21:51 <tensorpudding> woo math majors
14:21:55 <mmorrow> heh
14:21:56 <tensorpudding> ^5
14:23:02 <EnglishGent> haskell is ruining my lisp - I keep forgetting to put the function arguments in brackets!
14:23:07 <EnglishGent> :S
14:23:14 <mmorrow> lpsmith: but also read about it in addition to what was directly used in any course out of interest
14:23:21 <lpsmith> sweet, I never took topology,  and my abstract algebra courses were fairly traditional
14:23:59 <zygoloid> > head . snd . break (("t" `isPrefixOf`) . snd) . uncurry zip .  (inits &&& tails) $ "foobarquuxtest"
14:24:01 <lambdabot>   ("foobarquux","test")
14:24:10 <lpsmith> The problem I have with category theory is that there seem to be lots of definitions before you get to an interesting theorem that I can really latch on to
14:24:57 <mmorrow> lpsmith: yeah, i think connecting various bits with things you know in algebra and/or topology helps
14:25:28 <ddarius> lpsmith: There are no interesting theorems.
14:26:04 * ddarius thinks non-monotonic functions are non-computable functions and the sequentially realizable functionals are all computable.
14:26:11 <mmorrow> yeah, it's mostly just giving a language to describe situations in math in a non-particular-to-any-one-subfield-of-math way
14:27:31 * ddarius incidentally, doesn't know of any mathematical field where you don't have a lot of definitions before you get to interesting theorems.
14:27:37 <ddarius> Most of mathematics seems to be definitions.
14:28:04 <sshc> thanks, zygoloid
14:28:39 <monochrom> Most of a haskell program is definitions. :)
14:29:18 <ddarius> Where "most" = "all" ?
14:29:40 <idnar> there might be some comments
14:30:43 <camio> It seems like there are two pieces of knowledge that really go along with Haskell. Denotational semantics and category theory. Without those things I really felt like I was missing something. I wonder if there are more.
14:31:00 <monochrom> You know how to reduce the number of definitions. Heavy inlining. Right after stating the Peano axioms and the real axioms, I could just go ahead and state the prime number theorem without any intermediate definition, you know; it would just be very long.
14:31:19 <ddarius> camio: Logic, abstract algebra, universal algebra, coalgebra, automata theory, ...
14:31:47 <ddarius> monochrom: Using definitions increases robustness.
14:31:52 <ddarius> and generality.
14:32:31 <monochrom> That explains why mathematics spends so much on definitions. It is well spent.
14:32:32 <camio> ddarius: Automata theory? I'm familiar with it, but it doesn't seem very connected to haskell.
14:32:37 <PetRat> When I run ghci, it consumes about 6% CPU continuously while idling, sometimes more. I'm on laptop with battery life; is there a way to reduce this?
14:33:58 <jmcarthur_work> i don't see the same behavior
14:34:34 <PetRat> Windows XP laptop, 6 years old so relatively slow
14:34:40 <PetRat> GHC 6.10
14:34:44 <seanmcl> I'm puzzled by when a monadic value is forced in IO.  For instance, if I ask for the first element of qs :: IO [Int] = mapM (\n -> putStrLn ("q" ++ show n) >> return n) [1 .. 10]  from within IO, it prints all q1..q10 and then returns 1.  If I ask for the first element of rs :: State Int [Int] = mapM (\n -> State.modify (+ n) >> return n) [1 .. 10] in the state monad, it just returns 1 and doesn't do any addition (I checked with the deb
14:34:44 <seanmcl>   Is IO the only monad that forces unneeded computation?  How can I tell?
14:35:49 <ddarius> seanmcl: What if putStrLn throws an exception?
14:36:02 <EnglishGent> hmm - would it be possible to express 'take' & 'drop' *without* using explicit recursion?
14:36:13 <ddarius> EnglishGent: Sure.
14:36:16 <seanmcl> I'm not arguing that it shouldn't print.  I think it should.  I'm just asking how I can tell.
14:36:20 <seanmcl> In other monads
14:36:21 <EnglishGent> how?
14:36:31 <ddarius> fst . splitAt
14:36:44 <monochrom> You can't, short of two ways: the docs say it, or the source code says it.
14:36:46 <Philonous> IO actions with lazy semantics are a scary thing. Suddenly your pure functions get observable side effects
14:36:51 <ddarius> EnglishGent: Ultimately you are going to have to use recursion somewhere.
14:37:10 <EnglishGent> I know ddarius - I'm just wondering what's the smallest core I can squeeze it into
14:37:30 <lpsmith> fix f = f (fix f) :-)
14:37:36 <ddarius> seanmcl: You can intuitively tell if you need to whether the effects occurred or not to know the answer.
14:37:43 * EnglishGent is re-implementing some of the standard prelude functions in lisp - simply so I can use the same function names everywhere
14:37:43 <PetRat> Does the GC run continuously even while GHCI is not doing anything?
14:37:45 <Philonous> seanmcl: If you can, look at the definition of (>>=). It determines the strictness of the monad
14:38:02 <EnglishGent> but - doing so is making me look at some of the definitions & going 'hmmm' :)
14:38:05 <ddarius> seanmcl: So, Maybe/Error and similar will always require all actions to "do" something
14:39:32 <jmcarthur_work> PetRat, the GC only runs when it has to
14:39:48 <monochrom> IO does not always force things either. Even in Haskell98.  return (x+y) :: IO Int  does not force x+y.
14:39:49 <lpsmith> @ let mytake = fix (\take n xs -> if n > 0 then case xs of { (x:xs) -> take (n-1); [] -> [] } else [])
14:39:53 <lpsmith> @let mytake = fix (\take n xs -> if n > 0 then case xs of { (x:xs) -> take (n-1); [] -> [] } else [])
14:39:56 <jmcarthur_work> (when the allocator sees that it might have to get more memory from the OS)
14:39:56 <lambdabot>  <local>:23:65:
14:39:56 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t...
14:40:03 <EnglishGent> ah! I was just about to ask for an example
14:40:06 <lpsmith> @let mytake = fix (\take n xs -> if n > 0 then case xs of { (x:xs) -> take (n-1) xs; [] -> [] } else [])
14:40:08 <lambdabot>  Defined.
14:40:10 <EnglishGent> thanks ddarius, lpsmith :)
14:40:24 <lpsmith> > mytake 10 [1..]
14:40:27 <lambdabot>   []
14:40:29 <jmcarthur_work> :t mytake
14:40:31 <lambdabot> forall a t a1. (Num a, Ord a) => a -> [t] -> [a1]
14:40:38 <lpsmith> doh
14:40:43 <monochrom> print x  may end up not forcing x either if x's Show instance doesn't force x.
14:40:48 <mmorrow> ddarius: i'm saving that paper you linked to to look at later since i don't have time currently (about to close the window), but if you had to sum up its "punchline" or whatever in a sentence or two, what would you say? ("When is a functional program not a functional program?")
14:40:49 <lpsmith> @let mytake = fix (\take n xs -> if n > 0 then case xs of { (x:xs) -> x : take (n-1) xs; [] -> [] } else [])
14:40:50 <lambdabot>  <local>:24:0:
14:40:50 <lambdabot>      Multiple declarations of `L.mytake'
14:40:50 <lambdabot>      Declared at: <lo...
14:40:57 <lpsmith> @let mytake2 = fix (\take n xs -> if n > 0 then case xs of { (x:xs) -> x : take (n-1) xs; [] -> [] } else [])
14:40:58 <eldragon> are every these higher abstracted "*'s algebra" the frontier of our current knowledge on the Earth?
14:41:00 <lambdabot>  Defined.
14:41:03 <lpsmith> > mytake 10 [1..]
14:41:05 <lambdabot>   []
14:41:06 <lpsmith> > mytake2 10 [1..]
14:41:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:41:31 <mmorrow> @let mystake = fix error
14:41:34 <lambdabot>  Defined.
14:41:41 <mmorrow> :)
14:41:41 <ddarius> mmorrow: That there are purely functional programs that aren't implementable in a purely functional language, and I don't think this has terribly much practical significance/application but I could be wrong.
14:42:15 <mmorrow> ddarius: what's the definition (or something of that sort) of this class of functions though?
14:42:40 <sshc> mystake?
14:42:43 <lpsmith> EnglishGent:  of course,  you could argue that mytake2 is "cheating" a little bit:  it's not "directly" recursive,  but the structure is exactly the same as a recursive definition
14:42:44 <eldragon> how much is unstable and fucked such fuzzy frontier?
14:42:45 <monochrom> Yeah, are such programs constructible, or are they just axiom-of-choice kind of "exists"?
14:42:46 <mjrosenb> assuming that f :: a->a->a, is foldr f equivalent to foldl (flip f)?
14:42:49 <sshc> > mystake
14:42:51 <mmorrow> sshc: "mistake" ;)
14:42:51 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:43:03 <ddarius> monochrom: It gives an example in the first page or two.
14:43:32 <monochrom> fun
14:43:38 <mmorrow> ddarius: heh, exactly what i was trying to avoid.. :)
14:43:43 * mmorrow reads the first page
14:43:58 <ddarius> It's the function I was talking about with roconnor.
14:44:25 <lispy> mmorrow: hey.  I didn't mean to be a jerk the other day!  (just wanted to say sorry, since I didn't get to before)
14:44:51 <ddarius> But watch out for those other other days when lispy does mean to be a jerk.
14:44:52 <mmorrow> lispy: :o what are you talking about?
14:45:10 <mmorrow> lispy: (as in, did you mean to say mmorrow?)
14:45:11 <lispy> mmorrow: oh, I started the conversation off wrong by teasing you about a rant
14:45:25 <mmorrow> lispy: hah, i don't recall
14:45:26 <eldragon> the fuzzyness can be decreased in the time but you'll discover newer problems what will increase its fuzzyness, hahaha, it's the stucken way of our lives as forever.
14:45:35 <lispy> mmorrow: oh, okay.  Never mind then ;)
14:45:39 <mmorrow> lispy: heh :)
14:45:59 <lispy> mmorrow: I thought you were annoyed and left.  IRC is funny like that
14:46:03 <ddarius> mjrosenb: No.
14:46:28 <mmorrow> lispy: heh, lack of body language makes things ambiguous
14:46:34 <ddarius> mjrosenb: If f is associative and you restrict yourself to finite lists, then yes.
14:46:59 <ddarius> s/makes/makes more/
14:47:16 <mjrosenb> ddarius: f is not associative, which is why i am confused
14:47:27 <mmorrow> ddarius: ah ok, so something like "using unsafePerformIO + debauchery to implement something that's referentially transparent and functional, but not implementable with only that"
14:47:29 <mmorrow> ?
14:47:32 <ddarius> mjrosenb: If f is not associative then they are definitely not equal.
14:47:48 <ddarius> mmorrow: Yes. (I think.)
14:48:02 <mjrosenb> ddarius: ahh.
14:48:13 <ddarius> Functions easy to implement in, say, SML, but impossible in (non-cheating) Haskell.
14:48:15 <mjrosenb> ddarius: as it turns out, i was getting recursion from somewhere else
14:50:43 <eldragon> @google "Lamping GRS"
14:50:44 <lambdabot> No Result Found.
14:51:04 <eldragon> @google "Lamping Graph Reduction System"
14:51:05 <lambdabot> No Result Found.
14:52:07 <eldragon> http://www.brics.dk/MC/99/GraphReduction/index.html
14:52:59 <Philonous> ddarius: Wouldn't f even have to be commutative for foldr f and foldl (flip f) to be the same?
14:54:00 <mmorrow> , foldl (flip f) z [0..9]
14:54:02 <lunabot>  f 9 (f 8 (f 7 (f 6 (f 5 (f 4 (f 3 (f 2 (f 1 (f 0 z)))))))))
14:54:07 <mmorrow> , foldr f z [0..9]
14:54:09 <lunabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 z)))))))))
14:54:54 <mmorrow> Philonous: i guess so (err, right?)
14:55:13 <zygoloid> i thought you could implement foldl using foldr but not vice versa? so they can't be the same...
14:55:31 <zygoloid> principally because foldl _ _ xs = _|_ when xs is infinite
14:55:41 <mmorrow> yeah, i'm taking "the same" to be wrt equality of the result
14:55:52 <mmorrow> (should a result be produced)
14:56:34 <mmorrow> , foldr (\a b -> "("++a++"<>"++b++")") "0" (fmap show [1..4])
14:56:35 <lunabot>  "(1<>(2<>(3<>(4<>0))))"
14:56:45 <mmorrow> , foldl (flip (\a b -> "("++a++"<>"++b++")")) "0" (fmap show [1..4])
14:56:46 <lunabot>  "(4<>(3<>(2<>(1<>0))))"
14:56:49 <EvanCarroll> let r = [1..10] in [ (a,b,c) | a <- r, b <- r, c <- r, a^2 + b^2 == c^2 ]
14:56:51 <ddarius> Philonous: No.
14:56:59 <EvanCarroll> how would you move the let into the list comprehension
14:57:25 <mmorrow> , [ (a,b,c) | let r = [1..10], a <- r, b <- r, c <- r, a^2 + b^2 == c^2 ]
14:57:26 <lunabot>  [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
14:57:27 <zygoloid> , foldl (flip f) z . foldl (flip (:)) [] $ [0..9]
14:57:29 <lunabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 z)))))))))
14:57:43 <zygoloid> , foldr f z [0..9]
14:57:45 <lunabot>  f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 z)))))))))
14:58:13 <EvanCarroll> cool
14:58:14 <EvanCarroll> nifty
14:58:15 <Itkovian> What would be the most efficient way to define f [a1 ... an] = [[a1-1,a2, ... an], [a1, a2-1, ..., an] ... [a1 ... an-1]] ?
14:58:20 <ddarius> Philonous: Well, I guess with the flip in there, it would need to be more than associative.
14:58:43 <mmorrow> Itkovian: hmmm
14:59:26 <ddarius> I've decided that I don't really like berries.
14:59:40 <ivanm> ddarius: any particular type of berries?
14:59:45 <mmorrow> ddarius: your loss
14:59:45 <ivanm> or just berries in general?
14:59:46 * zygoloid imagine's there's no foldl-foldl fusion rule
14:59:53 <zygoloid> s/'//
15:00:07 * ivanm points out that strawberries aren't technically berries, just in case ddarius was unaware of that...
15:00:51 <mmorrow> , let go xs = fmap (zipWith (-) xs) (fmap (\n -> replicate n id ++ [(-1)] ++ repeat id) [0..]) in go [1..3]
15:00:52 <lunabot>  luna: No instance for (GHC.Num.Num (a -> a))
15:01:00 <mmorrow> , let go xs = fmap (zipWith ($) xs) (fmap (\n -> replicate n id ++ [(-1)] ++ repeat id) [0..]) in go [1..3]
15:01:01 <lunabot>  luna: No instance for (GHC.Enum.Enum ((a -> a) -> b))
15:01:19 <mmorrow> umm
15:01:21 <Philonous> Neither are raspberries and blackberries, but tomatoes, bananas and melons are.
15:01:34 * osfameron bludgeons ivanm to death with a banana (technically a berry)
15:01:36 <ivanm> Philonous: wtf?
15:01:44 <ivanm> osfameron: I thought they were a type of fish...
15:01:47 <ivanm> ;-)
15:02:07 <osfameron> culinary definitions don't really map to biological ones... how inconvenient :-(
15:02:10 <Philonous> blackberries and raspberries are aggregate fruits
15:02:26 <mmorrow> gah, (-) messing with me again
15:02:41 <mmorrow> , let go xs = fmap (flip (zipWith ($)) xs) (fmap (\n -> replicate n id ++ [subtract 1] ++ repeat id) [0..]) in go [1..3]
15:02:42 <lunabot>  [[0,2,3],[1,1,3],[1,2,2],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],...
15:02:53 <ivanm> mmorrow: heh
15:02:58 <mmorrow> , let go xs = take (length xs) $ fmap (flip (zipWith ($)) xs) (fmap (\n -> replicate n id ++ [subtract 1] ++ repeat id) [0..]) in go [1..3]
15:02:59 <lunabot>  [[0,2,3],[1,1,3],[1,2,2]]
15:03:04 <shachaf> @ty (- ?x)
15:03:06 <lambdabot> forall a. (Num a, ?x::a) => a
15:03:09 <zygoloid> mmorrow: i was gonna say, shouldn't it be flip ($)? :)
15:03:12 <mmorrow> i dunno about the *most* efficient though
15:03:19 <mmorrow> zygoloid: hehe
15:03:34 * shachaf thought it only did that with constants for some reason. Huh.
15:03:35 <Itkovian> ok, I'll try that and compare it to what I fabricated
15:03:47 <zygoloid> but yeah, damned unary negate strikes again
15:04:23 <ivanm> aha! bananas and melons _aren't_ berries according to wikipedia! they're _false_ berries, same as blueberrys and cranberrys!
15:04:41 <mmorrow> Itkovian: a directly recursive function would always be equally-as or more efficient (modulo compiler optimizations) than any function that uses pre-packaged functions of course
15:04:42 <lispy> unary negate is the black sheep of the arithmetic family :)
15:05:09 <ivanm> lispy: because its the only unary operator, or because the same symbol does two jobs?
15:05:28 <mmorrow> zygoloid: it's the oddest thing, i've decided it's impossible to determine when you can use it and when you can't
15:05:34 <lispy> ivanm: yup
15:05:52 <lispy> ivanm: I'm not sure which is better, but both seem reasonable reasons
15:06:03 <ivanm> heh
15:06:19 <shachaf> ivanm: Blueberries aren't berries?!
15:07:08 <zygoloid> mmorrow: it's simple: it's subtraction when there's an expression on the left. in all other cases GHC analyzes the semantics of your code and picks whichever interpretation it thinks is most surprising.
15:07:18 <Philonous> It seems that containing the word "berry" in the name reliably indicates that something is in fact not a berry.
15:07:38 <mmorrow> zygoloid: exactly!
15:07:49 <zygoloid> Philonous: it seems to me that our classification system for what is- and what is not - a berry is silly
15:08:14 <zygoloid> i vote that a thing is a berry iff its name contains 'berry'
15:08:29 <Apocalisp> bananaberry
15:08:47 <zygoloid> Gene Roddenberry? a berry.
15:08:50 <Apocalisp> Monadberry Crunch
15:09:03 <eldragon> 1. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.2386
15:09:19 * shachaf will be sure to tell that to Mr. Finn.
15:09:21 <eldragon> 2. http://www2.parc.com/csl/groups/sda/publications/papers/Lamping-POPL90/for-web.pdf
15:09:23 <zygoloid> snobbery? a berry.
15:09:31 <shachaf> Huh. Apparently eggplants and tomatoes are "true berries", but not cranberries or blueberries.
15:09:34 <zygoloid> hmm
15:09:34 <eldragon> i found it, google can't!
15:09:57 <lament> that's rather emberryssing
15:10:58 * FauxFaux slaps lament.
15:12:38 <Itkovian> mmorrow: I had something like iterate (\((front, h:ts), reduced) -> ((h:front, ts), ((h-1):front ++ ts) : reduced)) (([],[1,2,3]),[])
15:31:03 <necroforest> Has anyone in here used simulated annealing to train neural networks?
15:32:46 <lament> necroforest: yes.
15:32:52 <SamB_XP> why settle for simulation?
15:33:03 <roconnor> ddarius: I have decided that the claimed ocaml implementaion of F is not correct, and is not pure.
15:33:46 <roconnor> ddarius: wait
15:33:50 <roconnor> damn strictness
15:34:16 <necroforest> lament, what type of algorithm do you use for generating a new solution based on the current one?
15:34:33 <necroforest> Right now, i'm just going through all the weights/biases (for a MLP) and adding random numbers to them
15:34:37 <augur> quick! i need someone i can talk logic with! :|
15:34:55 <lament> necroforest: backpropagation. I used hfann and didn't worry about the details of the network itself
15:35:04 <necroforest> But when I do the SA algorithm on it, the error increases
15:35:32 <necroforest> err, backpropagation?
15:36:01 <augur> oh man, neural networks?
15:36:09 <augur> check out Marcus' Algebraic Mind
15:36:34 <lament> necroforest: yeah... i didn't really play with the internals of the network, i just used whatever training function hfann had
15:36:39 <lament> (which uses backpropagation)
15:37:05 <necroforest> oh
15:37:20 <necroforest> i was asking about simulated annealing
15:37:20 <necroforest> alright
15:37:35 <lament> sorry, i guess i misunderstood
15:37:54 <lament> I just decreased the factor by which the weight changed
15:37:58 <lament> *weights
15:38:10 <lament> (as training progressed)
15:38:20 <lament> which i suppose makes it SA, but probably not in the specific sense you mean
15:39:48 <dv_> hi
15:39:56 <dv_> how can I get "ghc-prim -any" ?
15:40:02 <dv_> through cabal?
15:41:16 <dv_> oh wow
15:41:22 <dv_> cabal install base gives me "cabal: internal error: impossible"
15:44:14 <MarcWeber> dv_: I'm no longer that sure. But I think it's an internal package. I'd grep the ghc sources.
15:47:04 <dv_> ok no clue at all.
15:47:10 <dv_> ghc-prim is impossible to install.
15:47:19 <dv_> let alone find
15:49:01 <byorgey> dv_: what is ghc-prim, and why do you want it?
15:49:10 <byorgey> are you getting some sort of error that refers to it?
15:49:23 <dv_> trying to cabal-install fieldtrip
15:49:29 <dv_> and it depends on it
15:49:37 <dv_> googling just added to the confusion
15:50:15 <byorgey> dv_: the FieldTrip Hackage page (http://hackage.haskell.org/package/FieldTrip) doesn't list ghc-prim.
15:50:23 <byorgey> dv_: what is the exact error message you're getting?
15:50:39 <dv_> oh well
15:50:47 <dv_> its only indirectly dependent
15:50:49 <dv_> cabal: cannot configure OpenGLRaw-1.1.0.1. It requires ghc-prim -any
15:50:54 <dv_> fieldtrip depends on openglraw
15:51:02 <dv_> There is no available version of ghc-prim that satisfies -any
15:51:16 <byorgey> hmm, strange
15:51:21 <dv_> what is ghc-prim?
15:51:22 <byorgey> there is no such package as 'ghc-prim'
15:51:25 <dv_> is it iincluded in ghc?
15:51:34 <byorgey> and OpenGLRaw doesn't list ghc-prim as a dependency.
15:51:46 <byorgey> perhaps some sort of Cabal bug, what version of cabal-install do you have?
15:52:02 <dv_> 0.6.2
15:52:13 <byorgey> dv_: hmm, I have to go, but the people you should ask are dcoutts_ and conal
15:53:25 <dv_> well I'll just try to manually install ghc 6.10 here
15:54:32 <roconnor> ddarius: I give up
15:54:35 <dv_> oh the whole thing seems to be broken
15:54:42 <roconnor> ddarius: your reference has defeated me.
15:55:31 <roconnor> ddarius: all because I can't define a function G such that G False = top ; G True = mid ; G undefined = mid.
15:56:01 <roconnor> ddarius: I henceforth declaire that monotonicity be part of the definition of a pure function!
15:56:06 <roconnor> thus banishing your example.
15:56:19 <roconnor> declare
15:56:22 <ivanm> roconnor: G False = top; G _ = mid
15:56:49 <roconnor> ivanm: doesn't work
15:57:01 <roconnor> G undefined = undefined with that def
15:57:06 <ivanm> :/
15:57:14 <ivanm> not enough laziness?
15:57:17 <ivanm> @hoogle isUndefined
15:57:18 <roconnor> I think I need parallel or
15:57:23 <chrisdone> last year I brought you Haskell word clouds http://img514.imageshack.us/img514/9206/algosxh9.png .. this year I bring you.. Haskell word clouds, but where the words can fit inside eachother! ^_^ http://chrisdone.com/wordclouds/output.png
15:57:25 <lambdabot> No results found
15:57:27 <ivanm> lambdabot: wakey, wakey!
15:57:53 <ivanm> chrisdone: you're making this a yearly event, are you?
15:57:58 <chrisdone> ivanm: :D
15:58:06 * jlouis volunteered to formalize a subset of LLVM. I deeply regret that :)
15:58:13 <jlouis> ouch it hurts.
15:58:20 <mmorrow> chrisdone: ooh, nice
15:58:20 <monochrom> Oh bloody hell, the whole enterprise of denotational semantics assume functions to be continuous even. much stronger than mere monotonic.
15:58:25 <mmorrow> jlouis: hehe
15:58:47 <jlouis> mmorrow: somehow the demand that it be done in Twelf doesn't really help either
15:58:47 <mmorrow> jlouis: do elaborate
15:59:42 <jlouis> mmorrow: Well I have this 1500 line Twelf signature that won't admit type preservation for my system
15:59:43 <MarcWeber> dv_: Try hack-nix. It finds a solution. However I don't know yet wether it can compile all dependencies..
15:59:46 <conal> dv_: i don't know of a ghc-prim package.
15:59:51 <jlouis> i.e., it is buggy as hell :)
16:00:10 <dv_> cabal 0.6.2 seems to be utterly broken here.
16:00:21 <conal> :/
16:00:40 <MarcWeber> dv_: Maybe use cabal-install to intsall a newer cabal-install and try again?
16:00:41 <dv_> hmm ghc-pkg says base is version 3.x
16:01:15 <dv_> ah hm didnt try that one yet
16:02:10 <sshc> how do I cast a Char to a Word8?
16:02:44 <mmorrow> jlouis: heh. did you somehow auto-generate the twelf code from some part of llvm?
16:03:00 <jlouis> mmorrow: some of the problem is due to me being aggresive and wanting to use HOAS all over the place and abuse the regular worlds feature of Twelf
16:03:06 <mmorrow> jlouis: (i don't know what a twelf signature entails exactly..)(
16:03:22 <MarcWeber> dv_: Maybe try getting rid of base-3.
16:03:37 <mmorrow> jlouis: ah, the old "feature creep" coming back to haunt you thing :)
16:03:55 <MarcWeber> dv_: hack-nix has installed it ;-) joy.
16:04:04 <jlouis> mmorrow: well the signature is an encoding of syntax, semantics, type system and proofs in the LF variant of the lambda calculus
16:04:15 <dv_> what is hack-nix?
16:04:20 <dv_> apt-cache search hack-nix says nothing.
16:04:57 <mmorrow> jlaire: ahh, for some reason i was picturing "signature" in an ML-module system sense or something (like a header-file/class declaration/whatnot equivalent)
16:05:16 <dv_> didnt help. cabal install base -> "cabal: internal error: impossible"
16:05:17 <jlouis> mmorrow: I think the name stems from term rewriting or prolog actually
16:05:22 <jlaire> mmorrow: ;)
16:05:24 <Saizan> dv_: so you've an old version of ghc where ghc-pkg list ghc-prim doesn't list any module?
16:05:26 <dv_> and the ghc-prim -any error still comes
16:05:32 <MarcWeber> dv_:  http://www.haskell.org/pipermail/haskell-cafe/2009-November/069614.html
16:05:55 <dv_> Saizan, using ghc 6.8.2 here
16:06:03 <dv_> and cabal 0.6.2
16:06:17 <mmorrow> jlouis: so is the pain stemming from the content of llvm itself, or from the way you've gone about encoding things in twelf?
16:06:23 <jlouis> mmorrow: if you are curious as to how such a thing looks it is online at http://github.com/jlouis/jlouis-tvm/tree/master/src/
16:06:32 <jlouis> Currently it is Twelf that hurts
16:06:35 <mmorrow> ah sweet, i am
16:06:39 <mmorrow> ah
16:06:42 <Saizan> dv_: there was a bug where cabal-install looked for ghc-prim even if it wasn't necessary, ghc-prim is in new versions of ghc
16:06:58 <Saizan> dv_: not sure if that's fixed in some released version or only in the darcs one
16:07:01 <dv_> so I just manually install ghc 6.10 and thats it?
16:07:20 <mmorrow> jlouis: oh cool (repo).
16:07:38 <Saizan> dv_: or you could install the darcs version of cabal install
16:07:48 <Saizan> dv_: you also need the darcs version of Cabal
16:07:52 <jlouis> mmorrow: the report is utter crap at the moment. And I have to hand it in in a little over a week, oh well :)
16:08:00 <dv_> I see this will require a lot of time to fix
16:08:09 <dv_> postponed to tomorrow.
16:08:10 <Saizan> not really
16:08:17 <MarcWeber> dv_: http://hackage.haskell.org/packages/archive/FieldTrip/0.2.7/logs/failure/ghc-6.10 I'm getting this failure as well
16:08:36 <dv_> well I hardly ever did anything with haskell and just wanted to see a fieldtrip example
16:08:51 <dv_> so I have a hard time figuring out what all that stuff actually is and does
16:09:21 <roconnor> ddarius: What I don't like is that the implementation of F in ocaml is not pure when passed (\x -> x () `par` ()) even though (\x -> x () `par` ()) is a "pure" function.
16:09:54 <roconnor> ddarius: how can we say that F is pure when it returns different results on equivalent inputs?
16:10:38 <mmorrow> jlouis: hah, the fact that that i recognize the function in AppelTest.sml from the "ssa is functional programming paper" i guess gives a good hint as to why this is interesting to me :)
16:11:15 <jlouis> mmorrow: well our basic idea is to utilize that Appel paper to transform the LLVM IL into a first-order functional language
16:11:32 <jlouis> Appel had a bug in his example btw with lots of dead code
16:11:44 <mmorrow> jlouis: oh, interesting.
16:12:16 <jlouis> mmorrow: the report is probably a better place to start. It has a more ordinary syntax/semantics
16:12:17 <mmorrow> jlouis: yeah, i remember being like "wtf" working through that example with pencil-and-paper
16:12:25 <dv_> Saizan, how do I put ghc in cabal?
16:12:29 <dv_> err
16:12:32 <mmorrow> jlaire: report?
16:12:34 <dv_> forget it
16:14:15 <mmorrow> jlouis: this is a really good one too http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.6773
16:14:40 <jlouis> ah, yes, Kelseys paper is gold as well
16:14:44 <mmorrow> totally
16:15:08 <dv_> so. base-4 does not work at all with cabal? is this a known issue? googling about anything related to this yields no results
16:15:29 <mmorrow> jlouis: ahhh, the report is one directory up
16:15:49 <Saizan> dv_: base-4 works fine with cabal
16:16:01 <dv_> then I just dont know what to do.
16:16:05 <Saizan> dv_: but you can't upgrade your base version indipendently of your compiler version
16:16:06 <jlouis> mmorrow: yup, give me a hint if you want the master.pdf
16:16:14 <Saizan> dv_: if you want base-4 you've to upgrade ghc
16:16:19 <jlouis> it is very drafty at the moment though
16:16:20 <dv_> Saizan, and how do I tell cabal that there is ghc 6.10?
16:16:33 <dv_> I downloaded the ghc 6.10 tarball
16:16:40 <Saizan> and installed it?
16:16:46 <mmorrow> jlouis: sure, that'd be great (was planning on building from the .tex)
16:17:38 <jlouis> mmorrow: http://dl.dropbox.com/u/196031/master.pdf should be it
16:17:41 <dv_> yeah
16:17:48 <mmorrow> jlouis: great, thanks
16:17:54 <dv_> does cabal autodetect ghc?
16:18:04 <jlouis> mmorrow: handling anything like Heap and stack prooved too evil, unfortunately
16:18:09 <Saizan> dv_: it just looks for "ghc" on your $PATH
16:18:23 <Saizan> dv_: you can use the -w option to specify a specific path
16:18:32 <dv_> oh wait
16:18:36 <dv_> cabal install base still fails
16:18:41 <dv_> but cabal install fieldtrip works now
16:18:51 <Saizan> you don't "cabal install base", ever :)
16:18:58 <dv_> what is base anyway?
16:19:19 <dv_> I need to get those terms straight someday. cabal, hackage, hugs, darcs, mtl, ...
16:19:22 <Saizan> it's the core library
16:19:41 <Saizan> where Prelude, System.IO, Control.Monad etc.. are defined
16:20:25 <Saizan> and it's tightly tied to the compiler, since it also exports the primitive types etc..
16:20:27 <dv_> hmmk
16:20:43 <dv_> similar to libc for c
16:21:31 <Saizan> probably, but i don't know much about C infrastructure, i must admit :)
16:22:03 <dv_> well if you mess with libc, you take down half the system
16:23:07 <Saizan> if you mess with base you can no longer compile anything :)
16:23:32 <Saizan> hackage is just hackage.haskell.org which is where cabal-install finds the packages by default
16:24:54 <Saizan> hugs is another haskell implementation, mtl is a library where the standard monad transformers are defined (though there are competing libs on hackage for this), and when i say "darcs version" of something i mean the one that you can find in the developers' repository
16:26:36 <dv_> alright
16:26:41 <dv_> thanks for your patience guys!
16:26:44 <dv_> thinks work now.
16:26:46 * dv_ is happy
16:26:52 <Saizan> np :)
16:35:50 <Philonous> Curious. I have "data Widget = forall a. (GTK.WidgetClass a) => Widget a", but GHC complains "No instance for (GTK.WidgetClass Widget"
16:39:38 <Philonous> Ah snap. How silly of my.
16:40:58 <MarcWeber> dv_: Do you mind pasting ghc-pkg list somewhere ?
16:42:37 <dv_> http://codepad.org/MBsdCtZN
16:47:41 <dv_> is darcs just a de-facto standard for haskell repositories?
16:48:05 <dv_> ah ok its written in haskell
16:48:30 <MarcWeber> dv_: Yes. However darcs is slow for very large repositories. Also tracking branches is more cumbersome compared to git / mercurial
16:48:31 <kynky> darcs is in haskell, some ppl like git reps too
16:50:14 <MarcWeber> dv_: Which ghc version are you using now ?
16:50:22 <dv_> 6.10
16:50:34 <dv_> fieldtrip doesnt work here
16:50:39 <dv_> but reactive does
16:50:52 <dv_> and thats ok for me, just wanted to try out examples of FRP
17:04:20 <EvilTerran> hm... I have an abstract data structure in mind that is fundamentally a sequence, but each element other than the first has a "parent element" associated with it, in the part of the list before the element
17:04:49 <pastah_rhymez> EvilTerran: a double linked list?
17:04:50 <centrinia> snoc list?
17:04:50 <sshc> how do I print the line that's causing the Prelude.emptyList exception?
17:04:51 <EvilTerran> so it's kinda an n-tree as well as a sequence
17:05:36 <pastah_rhymez> or can the element point to more elements to that just before it in the sequence?
17:06:03 <pastah_rhymez> sshc: what function are you trying to print with?
17:06:27 <pastah_rhymez> EvilTerran: data DLL a = { fromBottam :: [a], fromTop :: [a] } ?
17:06:38 <sshc> pastah_rhymez: somewhere in my code, it causes "Prelude.head: empty list"
17:06:59 <sshc> can I pass a flag to GHC?
17:07:02 <pastah_rhymez> sshc: well, that's helpful...
17:07:05 <Philonous> Don't use head
17:07:25 <shachaf> sshc: Maybe the ghci debugger?
17:07:30 <pastah_rhymez> sshc: yeah, what Philonous said, use 'take 1' instead
17:07:53 <shachaf> pastah_rhymez: I can't see where that solves any problems that head does.
17:07:55 <sshc> ok.  What should I use for tail?
17:07:57 <EvilTerran> you could think of it as thing::[(T,Int)], where the i'th element's parent is the snd(thing!!i)'th element
17:08:22 <EvilTerran> and forall relevant i. i > snd(thing!!i)
17:08:27 <shachaf> sshc: You should use neither head nor tail. Because of empty lists.
17:08:57 <EvilTerran> pastah_rhymez, if that helps?
17:09:08 <shachaf> EvilTerran: What's the context of this data structure, out of curiosity?
17:09:14 <pastah_rhymez> EvilTerran: yeah, i get it
17:10:13 <shachaf> EvilTerran: Does it just need to be associated with the element, or with the element's position in the sequence?
17:11:12 <EvilTerran> shachaf, it's a play in a Game, more-or-less
17:11:20 <EvilTerran> the position, not just the element
17:11:38 <pastah_rhymez> EvilTerran: what can you say obout T?
17:11:45 <pastah_rhymez> Enum? Ord?
17:11:47 <EvilTerran> effectively, it's a sequence of moves
17:11:58 <EvilTerran> pastah_rhymez, it's a finite set
17:12:03 <shachaf> pastah_rhymez: How would that help?
17:12:12 <EvilTerran> Enum, Bounded; Ord, if you ike
17:12:45 <pastah_rhymez> EvilTerran: data Lol = { elemToPar :: Map T Int, parents :: IntMap T }
17:12:55 <pastah_rhymez> that should be somewhat efficient
17:12:59 <Philonous> sshc: http://www.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
17:14:10 <EvilTerran> hm... i think i might sleep on it, it's pretty late here
17:16:34 <KRTac> hi
17:17:29 <pastah_rhymez> hello :)
17:17:38 <KRTac> aaah...it works
17:17:40 <KRTac> :P
17:17:48 <KRTac> i have a quick question
17:17:54 <pastah_rhymez> shoot!
17:18:42 <sshc> Philonous: :hist reports "Empty history. Perhaps you forgot to use :trace?"
17:18:44 <KRTac> inverse (x:xs) = (inverse xs):x:[]
17:18:54 <KRTac> why doesn't this work?
17:19:14 <Philonous> Yes, I think you need to set breakpoints and start your programme with :trace <yourfunction>
17:19:18 <shachaf> KRTac: Why do you think? :-)
17:19:26 <shachaf> KRTac: Try evaluating it by hand.
17:19:31 <shachaf> Er, actually, two reasons.
17:19:32 <KRTac> hmmm
17:19:32 <sshc> Philonous: I did
17:19:41 <tensorpudding> > let inverse (x:xs) = (inverse xs):x:[] in inverse [1..10]
17:19:41 <KRTac> ok
17:19:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:19:52 <shachaf> KRTac: Look at the definition of [] carefully.
17:20:05 <Philonous> KRTac: Look at the type of (:)
17:20:09 <KRTac> ok
17:20:11 <tensorpudding> > []:[]
17:20:13 <lambdabot>   [[]]
17:20:28 <tensorpudding> @type (:)
17:20:31 <shachaf> > let inverse = foldl (flip (:)) [] in inverse [1..10]
17:20:32 <lambdabot> forall a. a -> [a] -> [a]
17:20:33 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
17:20:41 <pastah_rhymez> > []:[]:[]
17:20:41 <monochrom> Yeah, do not think; calculate.
17:20:43 <lambdabot>   [[],[]]
17:20:51 <pastah_rhymez> > []:[]:[]:[]
17:20:52 <lambdabot>   [[],[],[]]
17:21:40 <blueonyx_> hi, can someone help me with these lists of lists? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13196#a13196
17:21:51 <KRTac> and I can't just write (inverse xs):x becouse x isn't a list, right?
17:22:19 <shachaf> > fmap fmap fmap fmap fmap (:[]) (:[]) (:[]) []
17:22:22 <lambdabot>   [[[[]]]]
17:22:37 <pastah_rhymez> blueonyx_: whaoh
17:22:49 <blueonyx_> :)
17:22:50 <pastah_rhymez> *whoah*
17:22:54 <monochrom> > (:[]) (:[])
17:22:56 <lambdabot>   [{()->[()]}]
17:22:59 <monochrom> hehe
17:23:04 <monochrom> > (:[]) (:[]) (:[])
17:23:06 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
17:23:13 * shachaf keeps forgetting about that Show instance.
17:23:15 <byorgey> KRTac: well, right, (:) takes an element and a list as arguments and prepends the element to the front of the list.
17:23:15 <monochrom> Oh well. Two is enough. \o/
17:23:24 <byorgey> KRTac: so you can't append an element to the end of a list using :  .
17:23:26 <shachaf> > (+1)
17:23:26 <sshc> Philonous: ... [<exception thrown>] Prelude Main> :history 3
17:23:28 <sshc> Empty history. Perhaps you forgot to use :trace?
17:23:28 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
17:23:40 <pastah_rhymez> blueonyx_: how is this supposed to work? if x is the same then it can't
17:23:41 <byorgey> KRTac: to append to the end of a list you can use  list ++ [x]
17:23:45 <shachaf> blueonyx_: What do you mean, exactly?
17:23:48 <sshc> Philonous: I tried it without a number initially
17:23:56 <byorgey> KRTac: but note that it is inefficient (it must traverse the entire list to get to the end)
17:24:01 <shachaf> blueonyx_: Your "x" gets different numbers of arguments.
17:24:02 <sshc> Philonous: I used -fbreak-on-exception
17:24:12 <shachaf> blueonyx_: Don't you mean for it to be getting a list as the second argument?
17:24:15 <blueonyx_> pastah_rhymez: yea the accelerations must be someone iteratively added to the particles
17:24:15 <KRTac> ok
17:24:18 <KRTac> got it
17:24:29 <monochrom> I use -fusb-to-brain
17:24:34 <KRTac> i'm just trying to get the thing to work for now
17:24:51 <pastah_rhymez> blueonyx_: the first element in 'f pas' would cause (x :: p -> a), the second would be (x :: p -> a12 -> a) etc
17:24:58 <KRTac> i see how it can get a bit heavy on 1..1000000
17:25:18 <sshc> Philonous: I follow the instructions exactily on the link you gave me under 2.5.6.�Debugging exceptions
17:25:36 <Philonous> sshc: Did you add breakpoints?
17:25:43 <kyagrd> anyone using OTT (one true tool)?
17:25:46 <blueonyx_> yea i know x is not really a haskell function, it should just show that p2 needs to be combined with a12, p3 with a13 and a23,...
17:25:48 <pastah_rhymez> blueonyx_: so as you're writing it, you cause x to have one type per element
17:25:54 <shachaf> blueonyx_: I think f = map (uncurry x).
17:25:58 <shachaf> blueonyx_: Or something like that.
17:26:11 <shachaf> blueonyx_: If x gets two arguments, the second of which is a list.
17:26:22 <Philonous> sshc: Actually I can't really help you, just found that by googling. I never used the ghci debugger before (didn't have to)
17:26:23 <pastah_rhymez> ok, but if you could wrap all these values from a list into some data type, then it might work
17:26:41 <pastah_rhymez> data A n = A1 n | A2 n n | A3 n n n ...
17:26:48 <sshc> Philonous: The instructions told me that -fbreak-on-exception can be used instead
17:26:54 <sshc> Philonous: no, I didn't set any breakpoints
17:27:10 <shachaf> pastah_rhymez: That seems silly, given that the values are coming from lists in the first place.
17:27:14 <pastah_rhymez> THEN x could be a real function, elegantly solved with a nice case expression
17:27:53 <pastah_rhymez> shachaf: well, you could make this into a state computation where you would store a stack of results, and then have x be functions like
17:28:01 <pastah_rhymez> consumeOne, consumeTwo etc
17:30:21 <blueonyx_> pastah_rhymez, shachaf: i thought about something like a fold, in the first iteration p2' = x p2 a12, p3' = x p3 a23,... thats easy, every element of pas gets combined with its predecessor, but in the second step p3'' = x p3' a13, so every element gets combined with is pre-predecessor in pas :(
17:30:24 <Philonous> sshc: As I understand it, history will just tell you which breakpoints are hit before the exception was caught. So  you might want to add breakpoints in front of every call to head and try that again.
17:31:54 <Philonous> Alternatively you can replace head with pattern matches. ghci will tell you which one caused the the inexhaustive pattern match
17:32:35 <Philonous> (Just find-and-replace s/head/(\(x:_) -> x)/
17:33:13 <mrbluesky> Someone mind looking at this real fast for me and telling me what's wrong with my function type declaration?
17:33:16 <mrbluesky> http://pastebin.com/d44cf5e07
17:33:38 <ivanm> mrbluesky: what's the error?
17:33:38 <pastah_rhymez> blueonyx_: mapAccumL
17:33:44 <pastah_rhymez> @type mapAccumL
17:33:44 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:33:49 <ivanm> and that's a very ugly definition
17:33:54 <ivanm> oh, I know why
17:33:57 <mrbluesky> Couldn't match expected type `t' against inferred type `Float'
17:33:58 <mrbluesky>       `t' is a rigid type variable bound by
17:33:58 <mrbluesky>           the type signature for `add' at Main.hs:3:12
17:33:58 <mrbluesky>     In the second argument of `(+)', namely `add (init x)'
17:34:00 <mrbluesky>     In the expression: x !! ((length x) - 1) + add (init x)
17:34:02 <mrbluesky>     In the definition of `add':
17:34:03 <ivanm> mrbluesky: why do you suddenly have the Float constraint?
17:34:05 <mrbluesky>         add x = x !! ((length x) - 1) + add (init x)
17:34:10 <ivanm> mrbluesky: all the numbers are of some arbitrary type
17:34:23 <Berengal> mrbluesky: you need to convert the t to a Float before returning, or just return a t
17:34:38 <ivanm> so if I have x :: Int, and y :: Int, why should sum [x,y] be a Float?
17:34:38 <blueonyx_> pastah_rhymez: thanks, lookin into it
17:34:57 <ivanm> mrbluesky: note that unless you're dealing with C code using the FFI, Double is usually better than Float
17:34:58 <pastah_rhymez> blueonyx_: not sure that it will help, bet yeah
17:35:14 <mrbluesky> Ok
17:35:37 <mrbluesky> so it should look like      add :: (Num t) => [t] -> t
17:35:37 <mrbluesky> ?
17:35:59 <ivanm> yes
17:36:11 <blueonyx_> pastah_rhymez: combination of map and foldl sounds good ^^
17:36:13 <mrbluesky> Thanks, types are really breakin' my balls here.
17:36:17 <sshc> Prelude Main> :l Main.hs
17:36:17 <sshc> Ok, modules loaded: Main.
17:36:17 <sshc> Prelude Main> :break 148
17:36:17 <sshc> Cannot find default module for breakpoint.
17:36:17 <sshc> Perhaps no modules are loaded for debugging?
17:37:47 <sshc> why am I getting this error?
17:38:08 <sshc> I loaded Main.hs, so :break 148 should set a breakpoint on line 148
17:40:08 <Philonous> "<EvilTerran> you may have to delete the compiled version from wherever ghc put it "
17:41:04 * hackagebot upload: MemoTrie 0.4.7 - Trie-based memo functions (ConalElliott)
17:43:10 <market_hacker> hello? I'm looking for haskell interfaces to read HDF5 files, is anyone aware of such a thing?
17:43:23 <ivanm> what's an HDF5 file
17:43:25 <ivanm> ?
17:43:46 <market_hacker> http://www.hdfgroup.org/HDF5/whatishdf5.html
17:43:48 <shachaf> Apparently, "HDF5 is a data model, library, and file format for storing and managing data."
17:43:56 <market_hacker> its a good file format for storing lots of data
17:43:59 <shachaf> What a useful description. :-)
17:44:13 <market_hacker> an alternative to a database, more efficient if you read long blocks
17:44:21 <monochrom> If hackage doesn't have it, it is not written yet.
17:44:33 <market_hacker> ok yeah i didn't see it in there
17:44:49 <ivanm> ahhh, Java-based by the looks of things
17:45:15 <market_hacker> there's a c interface too
17:45:16 <monochrom> someone should write a paper on "the next 400 file formats"
17:45:21 <market_hacker> that's what python libraries wrap
17:45:21 <ivanm> monochrom: heh
17:45:37 <m3ga> There is a HDF5 library (probably C or C++) called libhdf5. What you need is an FFI interface to that.
17:45:54 <market_hacker> yes, i'm new to haskell, FFI might be beyond me
17:46:03 <ivanm> basically, Haskell bindings won't exist until someone actually cares enough to write them
17:46:08 <market_hacker> i was looking for an excuse to use it in a data processing task
17:46:09 <ivanm> @google haskell hdf5
17:46:10 <lambdabot> No Result Found.
17:46:26 <shachaf> lambdabot: Huh?
17:46:29 <shachaf> @google papaya
17:46:29 <monochrom> writing in native haskell using bytestring may be a good bargain too. bytestring is also for long blocks.
17:46:31 <lambdabot> http://www.papayaclothing.com/
17:46:31 <lambdabot> Title: Papaya Clothing Online
17:46:49 <market_hacker> i already have the data in hdf5
17:47:40 <market_hacker> thanks everyone for the help.
17:53:04 <blueonyx_> > zipWith (+) [1,2,3,23] [4,5,6]
17:53:08 <lambdabot>   [5,7,9]
17:54:10 <blueonyx_> is there a function which keeps the 23? or how can i effciently fill the second list with zeros to match lengths?
17:55:37 <idnar> > zipWith (+) [1,2,3,23] ([4,5,6] ++ cycle [0])
17:55:38 <lambdabot>   [5,7,9,23]
17:55:56 <tensorpudding> repeat would also work i think
17:56:05 <idnar> oh, of course
17:56:09 <idnar> > zipWith (+) [1,2,3,23] ([4,5,6] ++ repeat 0)
17:56:10 <lambdabot>   [5,7,9,23]
17:56:50 <tensorpudding> this only works if the second list is the one that is shorter
17:56:55 <blueonyx_> but i dont consider ++ efficient :/
17:57:37 <blueonyx_> so i'll roll my own, thanks anyhow
17:58:28 <tensorpudding> let f x y = takeWhile (/= 0) $ zipWith (+) (x ++ repeat 0) (y ++ repeat 0) in f [1,2,3,23] [4,5,6]
17:58:45 <tensorpudding> whoopse
17:58:48 <tensorpudding> > let f x y = takeWhile (/= 0) $ zipWith (+) (x ++ repeat 0) (y ++ repeat 0) in f [1,2,3,23] [4,5,6]
17:58:50 <lambdabot>   [5,7,9,23]
17:59:01 <tensorpudding> probably a nicer way to write that
17:59:09 <byorgey> blueonyx_: ++ is perfectly efficient.
17:59:21 <blueonyx_> O(n)?
17:59:30 <amz> won't that just expand to 4 : 5 : 6 : repeat 0?
17:59:38 <byorgey> blueonyx_: it's not that straightforward, due to lazy evaluation.
18:00:04 <byorgey> blueonyx_: to do the zip takes O(n) anyway.
18:00:42 <blueonyx_> is it equal to zipWith' as [] = as; zipWith' (a:as) (a':as') = (a+a'):zipWith as as' ?
18:01:06 <byorgey> blueonyx_: yes, it has exactly the same efficiency as that.
18:01:27 <blueonyx_> @src (++)
18:01:29 <lambdabot> []     ++ ys = ys
18:01:29 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:01:29 <lambdabot> -- OR
18:01:29 <lambdabot> xs ++ ys = foldr (:) ys xs
18:01:45 <blueonyx_> ah thanks :)
18:01:46 <Cale> blueonyx_: (xs ++ ys) is O(length xs) *if* you evaluate that many elements, but it's a constant cost for each list cell you look at.
18:02:17 <Cale> blueonyx_: Of course, if you use that left-recursively, it builds up and you can end up with linear costs per element, which is bad.
18:02:52 <Cale> But concatting a bunch of small lists in a right-associated manner is fine.
18:03:13 <Cale> (or even not-so-small lists)
18:04:08 <blueonyx_> xs ++ ys = foldr (:) ys xs
18:04:48 <Cale> I like that definition. xs ++ ys is the same as xs with the [] at the end replaced with ys
18:05:05 <Cale> (and each (:) replaced with (:))
18:05:18 <medfly> it's the same thing cale
18:05:36 <Cale> What is?
18:05:57 <pastah_rhymez> blueonyx_: you can easily write zipWithAndRest
18:06:08 <medfly> (:) and (:)...
18:06:13 <Cale> medfly: Right.
18:06:28 <Cale> medfly: foldr f z in general replaces each (:) in a list with f and the [] at the end with z
18:06:42 <medfly> I'm not really following, I just read <Cale> (and each (:) replaced with (:))
18:06:50 <Cale> medfly: So foldr (:) ys replaces each (:) with (:) and the [] at the end with ys
18:06:53 <medfly> which is a very strange thing to say
18:07:00 <Cale> see?
18:07:29 <Philonous> If you are so worried about performance, maybe [] is the wrong data type?
18:07:32 <medfly> that sounds inefficient
18:07:49 <Cale> medfly: It's as efficient as it can be.
18:08:14 <Cale> (there's no faster implementation of concatenation for lists)
18:08:47 <blueonyx_> hm, my zipWith' does not need the additions with 0
18:10:25 <medfly> it's just Haskell then
18:10:31 <Cale> medfly: However, there are other datastructures which permit faster concatenation.
18:10:52 <medfly> I'm not really asking for help, someone else is.
18:11:29 <Cale> For example, Data.Sequence defines a sequence type which is internally a sort of tree structure, and uses time and allocation on the order of the logarithm of the length of the shorter of the two lists.
18:11:53 <Cale> (well, to be precise s/lists/sequences/)
18:12:11 <medfly> whatever...
18:12:42 <Cale> And if you represent lists instead as functions [a] -> [a] which add elements to the beginning of another list, then "concatenation" is just composition of functions, which is constant time.
18:13:00 <Cale> (but other operations become more roundabout)
18:15:52 <gwern> maybe he could use arrays?
18:16:15 <gwern> (concatenating arrays is easy & fast, after all)
18:19:29 <Saizan> fast?
18:19:42 <Saizan> concatenating arrays is O(n) and not lazy
18:19:50 <gwern> Saizan: sure; at least, if you don't mind a layer of indirection
18:20:07 <gwern> (obviously physically copying & adjoining 2 arrays is going to be slow)
18:20:32 <Saizan> ah, well, then you can use the same technique with lists
18:21:19 <gwern> not lazy lists, I don't think, because then you don't know what offset/length to use
18:23:02 <Saizan> true, you've to measure the sizes (this is basically what you get with Data.Sequence + balancing)
18:24:27 <gwern> hm, I wouldn't be surprised if that's how Seq handled balancing. you'd still be paying the price for the tree though
18:24:46 * gwern hasn't looked at Seq too hard; wonder how it stacks up against an array
18:26:45 <c_wraith> http://images.damncrows.com/image/1246562643/dead-lock
18:27:48 <c_wraith> that brings up an interesting question.  Can you get STM to deadlock?  I don't think you can end up in a true circular wait, can you?
18:28:24 <sjanssen> c_wraith: one can create transactions that will never succeed
18:28:29 <Philonous> c_wraith: No, transactions are only reset when the resources are actually written to
18:28:39 <Philonous> But you can starve transactions
18:28:51 <c_wraith> Right.  You can starve something trivially.
18:28:57 <c_wraith> But you can't end up in circular waits
18:29:12 <gwern> does it matter if the shock kills you or the bloodloss?
18:29:24 <Philonous> I think that's was point of STM in the first place
18:34:33 <Saizan> i mean that Seq also has balancing implemented
18:53:10 <drhodes> From the logs I see there is a general opinion that Num is bad. Why is that?
18:53:32 <ivanm> drhodes: most people want to split it up further
18:53:45 <ivanm> problem is, not enough can agree on _how_ to split it up
18:53:49 <ivanm> @src Num
18:53:49 <drhodes> I see.
18:53:50 <lambdabot> class  (Eq a, Show a) => Num a  where
18:53:51 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:53:51 <lambdabot>     negate, abs, signum     :: a -> a
18:53:51 <lambdabot>     fromInteger             :: Integer -> a
18:54:27 <ivanm> drhodes: e.g. (*) makes sense for vector * matrix or matrix * vector (if the sizes are right); (+) doesn't
18:54:38 <ivanm> so the suggestions include breaking it down into Ring, SemiRing, etc.
18:55:11 <drhodes> this would mean all the current libraries which depend on Num would need reworking, right?
18:55:49 <Berengal> Of course, you can do that already, and making such "advanced" concepts makes Haskell more inaccessible to the "common man"
18:56:01 <Berengal> concepts default*
18:56:43 <Berengal> I vote for context synonyms
18:57:03 <monochrom> programming is inaccessible to the common man
18:57:24 <Berengal> monochrom: Not in the context of programmers
18:57:46 <gwern> drhodes: probably. if you just deleted 'Num' any type sig or instance breaks, to mention the obvious issues.
18:58:18 <Philonous> There are a lot of cases where you can define (+) sensibly, but not (*). Also, having Eq and Show as a requirement is just silly
18:58:37 <drhodes> gwern: and if it wasn't deleted libraries that should work well together in the future would not?
18:58:58 <Berengal> Would it be possible to implement context synonyms as a preprocessor?
18:59:08 <Berengal> And perhaps even better, indexed contexts?
18:59:25 <gwern> Philonous: what's silly about Show? read . show == id isn't enforced, and what's the use of a number you can't even specify?
19:00:20 <Berengal> gwern: You don't need to be able to print a number just because it's a number
19:00:21 <monochrom> My friend has seen code written by someone 70 years old, or maybe just 50 years old. The code is written fairly recently. It is hundreds of boilerplate repetition. The old man doesn't even use any of the c++ abstractions. Not even a refactoring of, say, x; y(0); z; x; y(1); z; x; y(2); z; ...
19:00:25 <Philonous> gwern: How do you show an infinite Stream of numbers?
19:00:38 <gwern> Philonous: how do you Show an infinite list?
19:01:00 <monochrom> The conclusion is that even procedural abstraction is inaccessible to the comman man. In the context of programmers.
19:01:10 <tensorpudding> you just keep going and going
19:01:29 <Philonous> gwern: Point taken. Still, Show and Num are semantically distinct.
19:01:41 <tensorpudding> until you hit the hard limits of your computer, Haskell, and the universe
19:01:48 <Berengal> monochrom: right, and making understanding numbers a matter of knowing what rings, groups and monoids are won't help any
19:02:34 <monochrom> Wrong. won't hurt any, will help those in the know.
19:02:51 <Philonous> gwern: And if your num type contains functions, there is just nothing interesting to show
19:02:56 <tensorpudding> i wonder which of those is the smallest
19:03:15 <monochrom> To the comman man who don't even procedurally abstract, what is there to lose? But to those of us who appreciate it, we will have something less annoying to use.
19:03:18 <Berengal> monochrom: I'm not saying we shouldn't do it, I'm saying it's one of the arguments against doing it.
19:03:23 <tensorpudding> haskell integers have a pretty high ceiling
19:03:29 <Berengal> Personally, I don't know enough about numbers to make an informed argument myself
19:03:34 <hs12> hi, why does this not work? let h = foldr (\x y xs -> [x]++xs) []
19:04:02 <Berengal> monochrom: I'd also claim that procedural abstraction is harder than functional...
19:04:05 <tensorpudding> the function in foldr takes two arguments, not three
19:04:22 <tensorpudding> so that lambda has the wrong type
19:04:33 <Berengal> hs12: foldr takes a two-argument function. You're giving it one with three arguments
19:04:41 <idnar> if you don't care about understanding the abstraction, why would it make any difference to you that it's changed to be more sensible?
19:04:52 <hs12> hi thanks
19:04:57 <tensorpudding> @type \x y xs -> [x]++xs
19:04:59 <lambdabot> forall t t1. t1 -> t -> [t1] -> [t1]
19:05:35 <monochrom> And imperative programming (the mainstream one) is full of procedural abstraction. Conclusion: common programming is already inaccessible to the common man, nay, the common programmer.
19:05:43 <idnar> it's not like anybody knows what a Num is
19:05:52 <idnar> why should it matter that they don't know what a Ring or a Monoid is?
19:05:56 <tensorpudding> @src Num
19:05:58 <lambdabot> class  (Eq a, Show a) => Num a  where
19:05:58 <lambdabot>     (+), (-), (*)           :: a -> a -> a
19:05:58 <lambdabot>     negate, abs, signum     :: a -> a
19:05:58 <lambdabot>     fromInteger             :: Integer -> a
19:06:11 <Berengal> idnar: because they already have an intuition for what a number is
19:06:23 <idnar> Berengal: they can keep that intuition (for what it's worth)
19:06:26 <sshc> how do I pattern match against a singleton list?
19:06:28 <tensorpudding> instances of num don't have to correspond to numbers, but they do a lot of things that numbers do
19:06:38 <monochrom> The lesson I learn from this conclusion is that we shouldn't care about the common programmer at all. Elitism doesn't hurt anyone, and it helps some of us.
19:06:39 <tensorpudding> sshc: (x:[])?
19:06:48 <sshc> tensorpudding: yes, thanks
19:06:52 <Philonous> Or even simpler: [x]
19:06:55 <tensorpudding> or possibly even [x]
19:07:06 <tensorpudding> but i like the symmetry of (x:xs) with (x:[])
19:07:15 <Adamant> monochrom: I think you're using one unrepresentative sample to draw some very weird conclusions
19:07:22 <sshc> tensorpudding: possibly?
19:07:26 <sshc> tensorpudding: does it only work sometimes?
19:07:28 <tensorpudding> definitely
19:07:30 <tensorpudding> sorry
19:07:41 <tensorpudding> [x] is just syntactic sugar for x:[]
19:07:51 <tensorpudding> they mean the same thing
19:07:52 <Berengal> idnar: but they've never even heard of them before. When teaching haskell, we already postpone the meaning of (Num a) => a until a few chapters out in whatever book or tutorial we're writing. With Num replaced by Ring and friends, this would require our tutorials to also cover those concepts
19:07:53 <sshc> ok.
19:08:11 <hs12> this has correct type but still can't be used:---    let h = foldr (\(x,y) xs -> [x+y]++xs) []
19:08:16 <tensorpudding> x:[] is more explicit: (:) is the constructor for the list type
19:08:20 <hs12> when I say h [1,2,34]
19:08:20 <idnar> Berengal: I don't see why
19:08:23 <Berengal> idnar: context synonyms would alleviate that problem though
19:08:39 <idnar> Berengal: our tutorials don't explain the Curry-Howard isomorphism either
19:08:46 <Philonous> hs12: What are you trying to do?
19:08:48 <tensorpudding> but most people don't like writing :'s all over the place
19:09:17 <Berengal> idnar: because everyone knows what a number is. I wouldn't know what a ring is if I hadn't studied it myself, and I've studied university level programming
19:09:22 <tensorpudding> the Curry-Howard isomorphism has little relevance to real-world programming though...
19:09:27 <hs12> Philonous: hi, I am trying to eliminate every second element of the list...
19:09:36 <Berengal> (well, so would most other programmers, but the point is, rings aren't part of the programming curriculum (even if it should be))
19:09:39 <ivanm> pattern matching!
19:09:46 <idnar> Berengal: instead of saying "(Num a) => a is the thing you need to do (+)", you say "(Ring a) => a is the thing you need to do (+)"
19:10:11 <idnar> (or whatever)
19:10:19 <ivanm> Berengal: right, but presumably we'd have an overall Num class that would have Ring, etc. as dependencies
19:10:21 <sshc> how would I write the inverse of intercalate? (this is similar to php's explode)
19:10:21 <Berengal> idnar: but then people would ask "Ring? What is a ring? Why do I need it to add?" instead of going "Oooo, Num as in number, I get it".
19:11:01 <Berengal> ivanm: ref. my previous calls for context synonyms
19:11:07 <monochrom> Perlers go "what is Num" + "why do I need it to add" :)
19:11:18 <Philonous> hs12: Do you have to use fold? Explicit recursion would be easier I think
19:11:25 <ivanm> Berengal: which are?
19:11:30 <sshc> I'm trying to write the inverse of intercalate
19:11:30 <Cale> I actually don't like the name Ring because it implies laws which are too strong.
19:11:37 <Berengal> ivanm: like type synonyms, but for contexts
19:11:41 <idnar> Berengal: I seriously doubt that "Num" is any less "confusing" than "Ring", but I suppose I can't offer any concrete evidence to support that
19:11:47 <Cale> Num doesn't imply anything
19:11:48 <ivanm> monochrom: was the `+' there on purpose? :p
19:11:49 <tensorpudding> Cale: why are the ring axioms too strong?
19:11:52 <monochrom> Yes!
19:12:00 <Cale> tensorpudding: Because associativity fails for floating point
19:12:00 <ivanm> Berengal: hmmm...
19:12:15 <tensorpudding> why is that?
19:12:16 <sshc> num is an abbv. for number
19:12:16 <Cale> (and distributivity)
19:12:30 <Philonous> hs12: With a fold you get exactly one element a time
19:12:38 <monochrom> And of course, there is also "what is Monad, why should I learn it" vs "Oooo, computation, I think I know what you mean!"
19:12:41 <Berengal> ivanm: and even better, there'd be indexed contexts, so we could have 'class Monad m where; context C m' and 'instance Monad Set where; context C Set = (Ord a)'
19:12:42 <hs12> Philonous: hi, but I am trying to study foldr and this one is giving me more trouble....even a simple like this h = foldr (\(x,y) xs -> [x]++xs) [] won't work
19:12:54 <idnar> wat
19:12:57 <idnar> oh, netjoin
19:12:58 <sshc> how would I write the inverse of intercalate? (this is similar to php's explode).  I'm trying to write this
19:13:06 <monochrom> Damn this netsplit that scrolleth away my witty saying!
19:13:09 <monochrom> And of course, there is also "what is Monad, why should I learn it" vs "Oooo, computation, I think I know what you mean!"
19:13:10 <idnar> @type intercalate
19:13:11 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:13:27 <Philonous> hs12: Yes, it can't because, as I said, foldr gives you exactly one element a time
19:13:34 <Cale> sshc: span/break might be useful
19:13:54 <sshc> explode "t" "footbar" would output ["foo","bar"]
19:14:16 <Cale> @check (\x y z -> (x + y) + z == x + (y + z :: Float))
19:14:18 <lambdabot>   "Falsifiable, after 25 tests:\n-1.3333333\n-3.0\n1.0\n"
19:14:18 <ivanm> sshc: see the split library as well
19:14:21 <Berengal> sshc: check out the split package
19:14:28 <monochrom> join :: (Computation c) => c (c a) -> c a
19:14:31 <ivanm> Cale: :o
19:14:33 <Cale> @check (\x y z -> (x + y) + z == x + (y + z :: Double))
19:14:35 <lambdabot>   "Falsifiable, after 19 tests:\n-10.8\n10.833333333333334\n6.0\n"
19:14:42 <ivanm> is this because of truncation/rounding/etc. ?
19:14:49 <Cale> Yeah.
19:14:50 <ivanm> (as in the limitations of storing a floating point number)
19:14:54 <monochrom> (>>=) :: (Container c) => c a -> (a -> c b) -> c b
19:15:01 <Berengal> monochrom: C# does that
19:15:13 <monochrom> oooo, computation!
19:15:20 <Cale> @check (\x y z -> (x + y) * z == x*z + (y*z :: Double))
19:15:22 <lambdabot>   "Falsifiable, after 28 tests:\n-6.5\n2.333333333333333\n-10.555555555555555...
19:15:33 <ivanm> Cale: I was wondering wtf you were talking about with associativity failing for floating point ;-)
19:15:36 <monochrom> I wonder how vague we can go down this path.
19:15:38 <hs12> Philonous: but then let's suppose I want to find something like all prefixes of a string using foldr...is it possible?
19:15:40 <ivanm> (since I was initially thinking "floating point" == R)
19:16:06 <ivanm> (>>=) :: (Burritto b) => b a -> (a -> b c) -> b c
19:16:11 <ivanm> ;-)
19:16:15 <Cale> Yeah, floating point numbers are nowhere near as nice as real numbers.
19:16:16 <Berengal> monochrom: (>>=) :: (TypeConstructor1 tc) => tc a -> (a -> tc b) -> b
19:16:19 <Philonous> hs12: Yes, that's possible
19:16:21 <Cale> But they are cheap.
19:16:27 <ivanm> Cale: how about CReal?
19:16:36 <Cale> CReal satisfies the laws
19:16:48 <Philonous> > foldr (\a (xs,ys)  -> (ys,a:xs)) ([],[]) [1..12]
19:16:50 <lambdabot>   ([2,4,6,8,10,12],[1,3,5,7,9,11])
19:16:52 <Cale> At least to the extent that you can observe that it does.
19:16:53 <ivanm> Cale: \o/
19:17:00 <ACSpike[Home]> for the record, I'm a commoner and I would love to know about categories and morphisms and natural transformations etc.
19:17:03 <monochrom> TypeConstructor is not vague, just general. vague requires everyone has his fetish interpretation.
19:17:03 <ivanm> Cale: it's just a tad... slow... :p
19:17:04 <Cale> The equality tests will generally take forever.
19:17:10 <ivanm> Cale: yeah :(
19:17:12 <Cale> @check (\x y z -> (x + y) * z == x*z + (y*z :: CReal))
19:17:14 <lambdabot>   Not in scope: type constructor or class `CReal'
19:17:14 <hs12> Philonous: thanks, but isn't this strange, as there you have to access more than two elements ?
19:17:16 <Cale> oh
19:17:37 <Cale> Right, that doesn't use L.hs. It would time out anyway.
19:17:54 <Philonous> hs12: No I don't. I have two lists and swapped them at every element
19:18:22 <Cale> ACSpike[Home]: Awesome. I can give you a book, one moment.
19:18:28 <monochrom> return :: (ItWorks m) => a -> m a
19:18:30 <Philonous> hs12: And I didn't mean to say it's impossible to do it, it's just hard.
19:18:36 <BMeph> > partition even [1..12]
19:18:38 <lambdabot>   ([2,4,6,8,10,12],[1,3,5,7,9,11])
19:18:44 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
19:19:26 <Cale> ACSpike[Home]: Of course, any questions you might have about that stuff, just ask :)
19:19:45 <ivanm> Cale: maybe you should @where+ the link so others can give it to them as well...
19:20:14 <ACSpike[Home]> Cale: thanks, I'm still at the level below question formulation
19:20:51 <monochrom> sequence :: (EnterpriseFramework m) => [m a] -> m [a]
19:20:56 <ivanm> heh
19:21:00 <Cale> Googling "Awodey Category Theory Reddit" will quickly reveal another place to get a PDF :)
19:21:27 <ivanm> yes, but "@where awodey" is easier ;-)
19:21:32 <hs12> Philonous: thanks, but even if we have a single list like [1,2,3] can we get output like [[1], [1,2], [1,2,3]] using foldr?
19:21:49 <Cale> @where+ awodey http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
19:21:50 <lambdabot> Nice!
19:21:53 <Philonous> @src inits
19:21:54 <lambdabot> inits []     =  [[]]
19:21:54 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
19:21:55 <Cale> @flush
19:22:25 <Cale> ACSpike[Home]: You might also like to watch the Catsters' lectures on YouTube
19:22:28 <Cale> @where catesters
19:22:29 <lambdabot> I know nothing about catesters.
19:22:29 <Cale> @where catsters
19:22:31 <lambdabot> I know nothing about catsters.
19:22:31 <Philonous> hs12: Yes, I think you can do that
19:22:48 <Cale> @where+ catsters http://www.youtube.com/user/TheCatsters
19:22:50 <lambdabot> Okay.
19:23:13 <ACSpike[Home]> I started watching a monad video on youtube today that I found on LtU. lost in under 1 minute :-)
19:23:35 <monochrom> haha
19:23:40 <Cale> ACSpike[Home]: Well, if you don't know what a natural transformation is, you'll be lost in that one.
19:23:50 <ACSpike[Home]> lost
19:24:04 <monochrom> I am easily lost in enterprise lectures too.
19:24:06 <hs12> Philonous: thanks, i didn't know about the inits.
19:24:40 <Philonous> hs12: You can actually implement inits as a foldr.
19:25:05 <Cale> ACSpike[Home]: I haven't covered the basic definition of category on the blog that my friend and I are doing yet either, but there are some articles there starting on natural transformations.
19:25:11 <Cale> http://analogical-engine.com/
19:25:34 <Gracenotes> analogical derived from analogy?
19:25:38 <Cale> yeah
19:26:08 <BMeph> I had the funniest experience at work today. I was looking up De Bruijn sequences when it suddenly occured to me that he's still alive! :o
19:26:23 <hs12> Philonous: but inits is not in the prelude?
19:26:32 <Saizan> is there going to be a natural transformations 6?
19:26:35 <eldragon> hi guys, i've a question very important
19:26:36 <Gracenotes> Cale: it seems like you're going over somewhat disparate things
19:26:54 <Philonous> hs12 It's in Data.List
19:26:58 <monochrom> De Bruijn and his sequences never end!
19:27:01 <Cale> Gracenotes: I promise that there will be some concordance eventually :)
19:27:10 <Gracenotes> :x
19:27:12 <eldragon> how is optimized the concurrent pi-calculus system for a confluent system?
19:28:04 <BMeph> monochrom: :)
19:28:11 <hs12> Philonous: thanks, a lot. This has helped me understand it.
19:28:26 <ACSpike[Home]> huh, I can't find the monad tutorial that was discussing natural transformations that lost me last
19:28:33 <Cale> Gracenotes: Robin has been studying combinatorial things, and particularly stuff in combinatorial group theory and representation theory, but there's a categorical perspective on a lot of that stuff, and hopefully there will be some crosstalk. :)
19:28:49 <eldragon> the main problem of a confluent system is that it explodes exponentially the resources.
19:29:07 <Cale> ACSpike[Home]: It would have been their very first video
19:29:15 <Cale> ACSpike[Home]: Monads 1
19:29:25 <eldragon> and that it's hard to accept its soundness/completeness.
19:32:23 <Cale> Grr, I tried to install adobe's .deb for the flash player, and it installed halfway and failed, and now trying to uninstall it tells me that the package is in an inconsistent state and I should reinstall it first
19:33:10 <path[l]> hi could someone suggest an elegant way to take "qwertyuiop" and get the hash fromList [('q',"w"),('w',"qe"),('e',"wr") ....
19:33:17 <path[l]> right now I have it in about 5 lines
19:33:42 <path[l]> I do a zip3 s (tail s) (drop 2 s)
19:33:50 <path[l]> but then adding the edge cases makes it big
19:33:59 <Gracenotes> path[l]: adjacent things?
19:34:13 <path[l]> yeah
19:34:16 <Gracenotes> you might consider doing a scanl
19:34:38 <path[l]> looking it up
19:35:04 <Gracenotes> hm, although I'm not too sure about the start and end cases.
19:36:36 <Gracenotes> no, scanl is too restrictive. a better combinator would would mapAccumL. But at that point, you might be better off with primitive recursion whooa
19:37:04 --- mode: irc.freenode.net set +o ChanServ
19:41:18 <eldragon> i've a confluent graph reduction of e.g. [0] (2+3)*5 ; [0]->[1.1] 5*5 ; [0]->[1.2] (2*5)+(3*5) ; [1.1]->[2.1] 25 ; [1.2]->[2.2] 10+(3*5) ; [1.2]->[2.3] (2*5)+15 ; [2.2]->[3.1] 10+15 ; [2.3]->[3.1] 10+15 ; [3.1]->[2.1] 25 ; how can i model the engine for predicting the optimal shortest way that avoids the explosion of resources of this confluent reduction? can topology, many abstract algebras, categorical theories give any answers to it?
19:42:24 <Philonous> > (\xs -> zip (map (:[]) xs) (zipWith (++) ([]: xs) (drop 1 xs) )) $ map show [1..9]
19:42:26 <lambdabot>   [(["1"],"2"),(["2"],"13"),(["3"],"24"),(["4"],"35"),(["5"],"46"),(["6"],"57...
19:42:36 <path[l]> ooh nice
19:43:53 <path[l]> I like that []:xs I didnt think of that
19:44:03 <path[l]> drop 1 xs is the same as tail right
19:44:29 <Philonous> > (\xs -> zip (map (:[]) xs) (zipWith (++) ([]: xs) ((drop 1 xs):[]) )) $ map show [1..4] -- forgot the last element
19:44:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:44:55 <Philonous> > (\xs -> zip (map (:[]) xs) (zipWith (++) ([]: xs) ((drop 1 xs)++[[]]) )) $ map show [1..4]
19:44:57 <lambdabot>   [(["1"],"2"),(["2"],"13"),(["3"],"24"),(["4"],"3")]
19:46:16 <path[l]>  > (\xs -> zipWith (++) ([]:xs)((tail xs)++[])) "abcd"
19:46:49 <Philonous> appending an empty list won't do much
19:47:30 <tensorpudding> > [] ++ []
19:47:33 <lambdabot>   []
19:48:23 <path[l]> oh
19:48:23 <eldragon> lambda calculus is confluent reduction too
19:48:43 <Saizan> path[l]: maybe you want drop 1 instead of tail?
19:48:52 <m0nkfish> Philonous: drop 1 xs = tail xs?
19:48:59 <idnar> > drop 1 []
19:49:00 <lambdabot>   []
19:49:01 <idnar> > drop 1 [1,2]
19:49:02 <lambdabot>   [2]
19:49:05 <idnar> > tail []
19:49:06 <lambdabot>   * Exception: Prelude.tail: empty list
19:49:07 <idnar> > tail [1,2]
19:49:08 <lambdabot>   [2]
19:49:11 <m0nkfish> ah. :)
19:49:38 <path[l]> so drop 1 only prevents the error right?
19:49:41 <path[l]> otherwise its the same
19:49:48 <path[l]> if I know the list has atleast 1 element
19:50:14 <m0nkfish> if it has at least 1 element they are identical
19:51:29 <path[l]> > (\xs -> zipWith (++) ([]:xs)((tail xs)++[])) "abcd"
19:51:33 <path[l]> why isnt that executing
19:52:14 <Philonous> @botsnack
19:52:15 <lunabot>  :o
19:52:16 <lambdabot> :)
19:53:03 <Philonous> Anyways. I'm off to sleep. It's 5am here.
19:53:09 <path[l]> night and thanks
19:53:34 <path[l]> > let xs = "abcd" in  zipWith (++) ([]:xs)((tail xs)++[])
19:53:59 <path[l]> grr what am I missing
19:54:17 <path[l]> > let xs = "abcd" in xs
19:54:22 <tensorpudding> path[l]: have you tried it in ghci first?
19:54:27 <tensorpudding> it doesn't type-check
19:54:31 <path[l]> hmmm ok
19:55:15 <path[l]> ah
19:55:17 <path[l]> right
19:55:55 <Philonous_> (path[l]: your ">" appears garbles in my irc client. Encoding problem?)
19:56:00 <Philonous_> garbled*
19:56:18 <path[l]> hmm bah I need to change my client
19:56:20 <path[l]> lol
20:01:41 <path[l]> > []:[1,2]
20:01:43 <lambdabot>   No instance for (GHC.Num.Num [a])
20:01:43 <lambdabot>    arising from the literal `1' at <inter...
20:01:49 <eldragon> people is sleeping, good bye.
20:01:52 <path[l]> oh
20:01:53 <path[l]> doh
20:14:21 <path[l]> > (\xs -> zip (map head xs) $  zipWith (++) ([]:xs) ((tail xs)++[[]])) $ map (:[])"abcd"
20:14:23 <lambdabot>   [('a',"b"),('b',"ac"),('c',"bd"),('d',"c")]
20:15:19 <ni|> hi
20:15:33 <BMeph> Hello
20:16:30 <BMeph> > (\xs -> zip (join xs) $ zipWith (++) ([]:xs) ((tail xs)++[[]])) $ map (:[])"abcd"
20:16:32 <lambdabot>   [('a',"b"),('b',"ac"),('c',"bd"),('d',"c")]
20:16:42 <BMeph> @bs
20:16:43 <lambdabot>  Done.
20:16:46 <BMeph> @bo
20:16:47 <lambdabot> :)
20:19:58 <path[l]> ah join
20:20:08 <path[l]> whats o?
20:26:09 <pragma_> Haskell is dumb.
20:27:48 <ivanm> @slap pragma_
20:27:49 * lambdabot decomposes pragma_ into several parts using the Banach-Tarski theorem and reassembles them to get two copies of pragma_!
20:28:11 <pragma_> Now you have twice as much of me to deal with.
20:28:19 <pragma_> That's how dumb Haskell is.
20:28:20 <pastah_rhymez> pragma_: http://arcanux.org/lambdacats/dumb.jpg
20:28:56 <jasonmay> hahaha
20:30:46 <pastah_rhymez> > forkIO runPragma_
20:30:47 <lambdabot>   Not in scope: `forkIO'Not in scope: `runPragma_'
20:30:57 <BMeph> @botsnack
20:30:58 <lunabot>  :o
20:30:59 <lambdabot> :)
20:31:41 <pastah_rhymez> pragma_: what are you working on?
21:10:35 <ivanm> preflex: seen Axman6
21:10:36 <preflex>  Axman6 was last seen on #haskell 17 hours, 18 minutes and 6 seconds ago, saying: (unless you play with messed up libraries
21:22:19 <rasfar> pastah_rhymez: thanks for the image, lol
21:34:08 <mwc> dcoutts_: thanks for your email sketch on how to bend cabal to this stupid compiler wrapper. Have it working perfectly now
21:34:55 <mwc> @tell dcoutts_ thanks for your email sketch on how to bend cabal to this stupid compiler wrapper. Have it working perfectly now
21:34:56 <lambdabot> Consider it noted.
22:29:11 <pastah_rhymez> rasfar: http://arcanux.org/lambdacats.html
22:29:26 <pastah_rhymez> i have the "trapd in io monad" as my desktop background on my laptop :)
22:34:06 <osaunders> Is there any place to download the standard library reference as a PDF?
22:34:30 <osaunders> Or maybe runtime reflection?
22:36:07 <Saizan_> the standard ghc installation installs it as .html
22:37:03 <osaunders> Oh, that's great.
22:39:31 <osaunders> If I could find it! :-S
22:40:44 <Saizan_> $prefix/share/doc/ghc/index.html
22:41:19 <Saizan_> the standard prefix is /usr/local
22:41:37 <osaunders> I'm using GHC from Macports
22:41:45 <osaunders> I've got a /opt/local/share/doc
22:41:49 <osaunders> but no ghc in there.
22:42:02 <Gracenotes> Ubuntu doesn't use /usr/local too much. /usr, though
22:42:42 <osaunders> OK I'll have to find it later. Thanks for the help Saizan_
22:44:35 <Saizan_> at worst you can download the tarball and copy just the docs :)
22:44:43 <Gracenotes> or, you can always run find on your whole file system :)
22:47:05 <Saizan_> locate ftw
22:57:37 <Milo-> I got to ask, what are the most costy basic operations in haskell? other than accessing a list through index.
22:58:10 <sjanssen> I'm not sure that I'd call (!!) a basic operation
22:58:20 <Milo-> oh
22:58:37 <Milo-> accessing a certain index in a list sounds like a basic operation
22:59:06 <sjanssen> depends on how you look at it, I suppose.  (!!) in Haskell is certainly less fundamental than [] in (say) Java
23:00:10 <blackdog> Are there any basic operations which aren't constant time?
23:00:30 <blackdog> Milo-: well, it's defined as a recursive procedure in Haskell code
23:00:59 <Milo-> already know it's a costy operation
23:01:26 <Saizan_> Integer operations are not constant time, are they "basic"?
23:01:38 <blackdog> Milo-: sure, I'm not really talking about cost - just that "basic" means you can't break it down any further
23:01:40 <sjanssen> blackdog: depends on where one assigns the cost, eg. seq can do any amount of work
23:01:40 <Milo-> just don't really know how one would go without it in some situationss
23:02:08 <Milo-> okay, definition of 'basic' doesn't work ehre
23:02:09 <Milo-> here*
23:02:10 <blackdog> sjanssen: that's a good point. I guess taking the strict equivalent makes some sense?
23:02:29 <blackdog> Saizan_: yeah, that's a good example.
23:02:51 <blackdog> Milo-: if you find you're indexing into a list a lot, you're probably using the wrong data structure
23:02:56 <Milo-> lets call them `common built-in` features then
23:02:58 <kosmikus> Milo-: if you really need (!!) frequently, you should either consider rewriting your program in a different style, or you're using the wrong data structure and should consider finite maps instead
23:03:23 <sjanssen> Milo-: lets say "functions in Prelude" instead
23:03:25 <blackdog> kosmikus: synchronicity high-five!
23:03:38 <Saizan_> Data.Sequence too
23:03:44 <kosmikus> blackdog: :)
23:04:23 <kosmikus> Saizan_: true
23:04:55 <sjanssen> Milo-: anything that needs to traverse an entire list is O(n): sum, product, last, (!!)
23:06:03 <blackdog> (!!) and last are probably the most surprising ones - it's pretty obvious that you need to look at every element of a list to get its sum
23:06:46 <Milo-> how about sieving a certain number range, lets say sieving how many factors each number between 1..n has
23:06:59 <kmc> @logs
23:07:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
23:07:18 <Milo-> in C/Java I would go around looping through the numbers and adding a +1 to each index in an array size of n
23:07:30 <Milo-> when a new factor has found
23:07:54 <Milo-> sieving works very quickly and obviously it's slightly O(n^2) (by O's definition)
23:08:00 <kmc> ... those are not IRC logs
23:08:05 <kmc> @where logs
23:08:06 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
23:08:18 <Milo-> but how would one go around doing that in haskell?
23:08:33 <kmc> what does "to sieve" mean here?
23:08:43 <kmc> does it just mean to apply some function to each element of a list?
23:08:57 <sjanssen> Milo-: you want to know the number of factors, or prime factors?
23:09:06 <Milo-> that doesn't matter
23:09:32 <Milo-> either way you'll need to access the index of a certain number directly
23:09:42 <kmc> Milo-, you mean you increment every 1st number, then every 2nd, then every 3rd, etc?
23:10:05 <sjanssen> Milo-: no, there are smarter ways to do it
23:10:07 <Milo-> in c: for (i=0; i < n; ++i) { for (j = i; j < n; j += i) { ++array[j]; } }
23:10:07 <kmc> Milo-, you wouldn't use a linked list in Java either
23:10:09 <kmc> you'd use an array
23:10:15 <kmc> Haskell has several flavors of array
23:10:46 <kmc> we also have Data.Sequence, with indexing nearly as efficient as arrays, and more convenient list-like ops
23:11:06 <sjanssen> this would be an okay job for accumArray
23:11:07 <kmc> Milo-, i can write that in Haskell with O(n^2) as well
23:11:11 <kmc> using lists
23:11:18 <kmc> because you're iterating linearly
23:11:22 <Milo-> without !! ?
23:11:23 <kmc> not "randomly"
23:11:25 <kmc> yeah
23:11:33 <kmc> well i can define !! myself too and give it a different name ;P
23:11:41 <Milo-> ._
23:11:42 <kmc> !! is just a function in the standard library
23:11:46 <kmc> but i wouldn't do it that way
23:12:54 <Milo-> so how would one do that without (!!)?
23:13:01 <kmc> gimme a minute to write it
23:13:05 <Milo-> sure
23:13:10 <kmc> Milo-, what's your level of Haskell knowledge?
23:13:20 <Milo-> too low
23:13:33 <lament> @src (!!)
23:13:34 <lambdabot> xs     !! n | n < 0 = undefined
23:13:34 <lambdabot> []     !! _         = undefined
23:13:34 <lambdabot> (x:_)  !! 0         = x
23:13:34 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:13:52 <Milo-> I can do stuff, but I can't put them together to do anything real
23:14:14 <Veinor> couldn't you do it with replicate and cycle?
23:14:44 <Veinor> create lists [0,1,0,1], [0,0,1,0,0,1...], [0,0,0,1,0,0,0,1...] and then add them all up
23:14:58 <kmc> ah clever
23:15:07 <Milo-> o_O
23:15:23 <Milo-> n lists
23:15:42 <Veinor> taking the first n so you don't wind up adding an infinite list :P
23:15:42 <Milo-> and each list has to be gone through?
23:15:51 <sjanssen> Milo-: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13208#a13208
23:16:35 <sjanssen> Milo-: usually the solution in Haskell is to stop looking at the problem as a series of for loops and array accesses, and instead find an operation that applies to all your data at once
23:17:12 <pastah_rhymez> sjanssen: what's arrays doing in there?
23:17:21 <pastah_rhymez> @type accumArray
23:17:22 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
23:17:25 <sjanssen> pastah_rhymez: accumArray
23:17:26 <Milo-> sjanssen ah, clever, was hoping to see it done by list comprehension
23:17:30 <pastah_rhymez> nevermind...
23:17:31 <kmc> > take 100 $ map sum $ transpose $ map (\n -> cycle (replicate n 0 ++ [1])) [1..100]
23:17:33 <lambdabot>   [0,1,1,2,1,3,1,3,2,3,1,5,1,3,3,4,1,5,1,5,3,3,1,7,2,3,3,5,1,7,1,5,3,3,3,8,1,...
23:17:44 <Raynes> Milo-: You might be surprised to find out that a lot of the things that Haskell does that have to be built into other languages, are actually just libraries and such.
23:18:02 <Milo-> kmc where is 'transpose'?
23:18:05 <kmc> Data.List
23:18:08 <Milo-> thanks
23:18:10 <sjanssen> Milo-: the list comprehension gets you halfway there, the array is just an efficient way to summarize the data
23:18:22 <Veinor> kmc: that's what I was thinking, yeah
23:19:26 <kmc> > map fst $ filter ((== 1) . snd) $ zip [1..] $ take 100 $ map sum $ transpose $ map (\n -> cycle (replicate n 0 ++ [1])) [1..100]
23:19:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
23:19:32 <kmc> :D
23:19:44 <kmc> primes
23:20:06 <kmc> > map fst $ filter (even . snd) $ zip [1..] $ take 100 $ map sum $ transpose $ map (\n -> cycle (replicate n 0 ++ [1])) [1..100]
23:20:08 <Saizan_> > let n = 100 in take n $ map sum $ transpose $ take n $ iterate (0:) [0,1]
23:20:08 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
23:20:09 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:20:10 <sjanssen> does anybody have an efficient n-way merge implementation sitting around?
23:20:12 <kmc> perfect squares :D
23:20:29 <Veinor> sorry, sjanssen, I left it in my other pants :(
23:20:31 <Milo-> kmc the prime one isn't very quick, if you do it up to 1000
23:20:43 <ski> ("n-way" ?)
23:20:45 <Saizan_> > let n = 100 in take n . map sum . transpose . take n . map cycle . iterate (0:) $ [0,1]
23:20:47 <lambdabot>   [0,1,1,2,1,3,1,3,2,3,1,5,1,3,3,4,1,5,1,5,3,3,1,7,2,3,3,5,1,7,1,5,3,3,3,8,1,...
23:20:56 <Milo-> you could actually sense the slowness in the range 1..100
23:21:48 <kmc> Saizan_, very nice
23:22:15 <Milo-> kmc you sure that's O(n^2) operation?
23:22:19 <kmc> not at all
23:22:40 <kmc> i don't propose that it is
23:22:43 <Veinor> Saizan_: very pretty
23:23:04 <kmc> i thought someone already gave an efficient solution
23:23:18 <Milo-> map goes through a list, transpose goes a list, map goes through a list, and then there are different lists generated n times
23:23:23 <Milo-> kmc yes
23:23:33 <Milo-> sjanssen gave an efficient looking solution
23:23:41 <kmc> with an array, too
23:23:55 <kmc> which matches the datastructure you'd use in C or Java
23:24:25 <Milo-> not as static though?
23:24:30 <kmc> static?
23:24:34 <Saizan_> you can go any bounded amount of times through a list without adding to the complexity if it's already more than linear
23:24:45 <Veinor> on the other hand, one of the advantages of Haskell is that it's lazy, which means that you don't need to actually compute stuff until you need it
23:24:53 <Milo-> as in it can't be resized without re-initialization.
23:25:12 <kmc> i don't follow
23:25:12 <ski> > fix $ \ns -> 0 : tail (ns /\/ map (1+) ns)
23:25:14 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
23:25:22 <Milo-> fixed size array.
23:25:27 <Milo-> static in that way
23:25:27 <Veinor> ski: heh, nice
23:25:28 <kmc> :t (/\/)
23:25:30 <lambdabot> forall a. [a] -> [a] -> [a]
23:25:35 <Veinor> @src (/\/)
23:25:36 <kmc> @src (/\/)
23:25:36 <lambdabot> Source not found. Sorry.
23:25:37 <lambdabot> Source not found. Just try something else.
23:25:44 <ski> <ski> @let (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs)
23:25:50 <Milo-> @src (/\/)
23:25:51 <lambdabot> Source not found. There are some things that I just don't know.
23:25:57 <kmc> interleave?
23:25:58 * ski grins
23:26:02 <ski> aye
23:26:12 <kmc> > "abcde" /\/ "12345"
23:26:14 <lambdabot>   "a1b2c3d4e5"
23:26:19 <Veinor> ahhh.
23:26:26 <ski> > fix $ \ns -> repeat 0 /\/ map (1+) ns
23:26:28 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
23:26:40 <Veinor> if only I understood how that generates the list :P
23:27:17 <kmc> it folds the list into itself, unto infinitely
23:28:34 <kmc> that is absolutely nuts
23:29:07 <Veinor> yeah, I don't get how the math behind it works O_O
23:29:25 <Veinor> > (map (\n -> cycle (replicate n 0 ++ [1])) [1..100]
23:29:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:29:28 <Veinor> whoops
23:29:32 <Veinor> > (map (\n -> cycle (replicate n 0 ++ [1])) [1..100]) !! 1000
23:29:34 <lambdabot>   * Exception: Prelude.(!!): index too large
23:29:38 <Veinor> ... doh
23:29:43 <Veinor> > (map (\n -> cycle (replicate n 0 ++ [1]))) !! 1000
23:29:45 <lambdabot>   Couldn't match expected type `[a]'
23:29:45 <lambdabot>         against inferred type `[GHC.Type...
23:29:54 <Veinor> > (map (\n -> cycle (replicate n 0 ++ [1])) [1..1000]) !! 1000
23:29:55 <kmc> > fix $ \ns -> 0 : (ns /\/ map (1+) ns)
23:29:56 <lambdabot>   * Exception: Prelude.(!!): index too large
23:29:57 <lambdabot>   [0,0,1,0,1,1,2,0,1,1,2,1,2,2,3,0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,0,1,1,2,1,2,...
23:30:00 <Veinor> I can't brain now I have the dumb :<
23:30:16 <Veinor> > (map (\n -> cycle (replicate n 0 ++ [1])) [1..1000]) !! 999
23:30:18 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:30:26 <Veinor> ...
23:30:29 <Veinor> I give up.
23:30:42 <Veinor> I'm obviously doing something wrong, I'm just too distracted by fideo games to figure it out :P
23:30:50 <Milo-> fideo games
23:31:04 <kmc> but lambdabot is a fideo game!
23:31:05 <Saizan_> what are you trying to do, actually?
23:31:32 <MoALTz> time to horrify
23:31:38 <MoALTz> > let { primes = 2 : 3 : primegen 1 primes; term n | n`mod`2 == 0 = 3*n+1; term n = 3*n+2; primegen n (l:ls) | l^2 > (term n) = term n : primegen (n+1) primes; primegen n (l:ls) | (term n)`mod`l == 0 = primegen (n+1) primes; primegen n (l:ls) = primegen n ls } in primes
23:31:40 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:31:59 <kmc> ski, can your code be explained or did it come to you in some kind of visionary trance
23:35:32 <kmc> > map abs [n^2 + n + 41 | n <- [0..39]]
23:35:34 <lambdabot>   [41,43,47,53,61,71,83,97,113,131,151,173,197,223,251,281,313,347,383,421,46...
23:36:56 <Veinor> it generates primes! ;)
23:41:40 <ski> kmc : hm .. which of them ?
23:43:23 <Cale> > fix ([0..] /\/)
23:43:25 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
23:43:27 <kmc> the interleaving one that finds the number of factors
23:43:50 <ski> factors of two ?
23:44:19 <kmc> oh, it's not the same sequence
23:44:24 <ski> @let factorsOfTwo = fix $ \ns -> repeat 0 /\/ map (1+) ns
23:44:26 <lambdabot>  Defined.
23:44:42 <ski> kmc : not the same as Saizan_ generated, no
23:45:03 <ski> (it just reminded me of `fix $ \ns -> 0 : tail (ns /\/ map (1+) ns)')
23:45:18 <ski> > factorsOfTwo
23:45:20 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
23:45:31 <ski> > [ factorsOfTwo !! i | i <- [0,2..] ]
23:45:32 <kmc> you should add it to A000120
23:45:33 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:45:34 <ski> > [ factorsOfTwo !! i | i <- [1,3..] ]
23:45:37 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,...
23:45:43 <ski> > [ factorsOfTwo !! i - 1| i <- [1,3..] ]
23:45:45 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
23:45:49 <kmc> ah
23:45:59 <kmc> every other number has one more factor of two
23:46:11 <ski> so `factorsOfTwo = repeat 0 /\/ map (1+) factorsOfTwo'
23:46:39 <ski> ("A000120" ?)
23:47:12 <ski> @let somethingElse = fix $ \ns -> 0 : tail (ns /\/ map (1+) ns)
23:47:14 <lambdabot>  Defined.
23:47:16 <kmc> @where OEIS
23:47:17 <lambdabot> I know nothing about oeis.
23:47:18 <ski> > somethingElse
23:47:20 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
23:47:35 <ski> > [ somethingElse !! i | i <- [0,2..] ]
23:47:37 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
23:47:40 <ski> > [ somethingElse !! i | i <- [1,3..] ]
23:47:40 <kmc> @google oeis
23:47:42 <lambdabot>   [1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,...
23:47:42 <lambdabot> http://www.research.att.com/~njas/sequences/
23:47:43 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
23:47:44 <ski> > [ somethingElse !! i - 1 | i <- [1,3..] ]
23:47:46 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
23:47:49 <kmc> thought there was a a plugin
23:48:12 <ski> so `somethingElse = somethingElse /\/ map (1+) somethingElse'
23:48:23 <ski> but this doesn't determine the sequence completely
23:48:35 <ski> (e.g. it doesn't determine that `somethingElse !! 0 = 0')
23:48:51 <ski> so the `(0 :) . tail' part forces that
23:49:09 <kmc> ah, cool
23:49:12 <kmc> thanks for explaining
23:49:17 <ski> @help OEIS
23:49:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:49:28 <ski> maybe that was in the later version of lambdabot ..
23:51:24 <jkff> Hi. Am I understanding correctly that, although (+) :: Num a => a -> a -> a and plus=(+) :: Num a => a -> a -> a, (+) has ad-hoc polymorphism and plus has bounded parametric polymorphism?
23:51:58 <kmc> :t let plus = (+) in plus
23:52:00 <lambdabot> forall a. (Num a) => a -> a -> a
23:52:07 <kmc> you're just giving another name?
23:52:11 <ski> both are bounded parametric polymorphism
23:52:28 <jkff> But what is an example of an ad-hoc polymorphic function, then?
23:52:30 <ski> which is like ad hoc ditto, but less ad hoc
23:52:39 <ski> (ideally)
23:52:58 <Saizan_> ad-hoc polymorphism would be like java method overloading
23:52:59 <jkff> Or is the distinction really informal?
23:53:08 <kmc> well, the ad-hockery of it is that different types can implement Num differently
23:53:12 <jkff> Yes
23:53:18 <jkff> That's why I thought that (+) is ad-hoc polymorphic
23:53:20 <kmc> so in some sense any bounded parametric polymorphism becomes ad-hoc
23:53:27 <jkff> And vice versa?
23:53:30 <kmc> because our bounds also influence behavior
23:53:40 <ski> in ad hoc polymorphism, usually an overloaded operation can be overloaded on any types
23:53:56 <kmc> so if you had something of that type, but didn't use any Num members (directly or indirectly), it'd be non-ad-hoc bounded para-poly
23:54:08 <ski> with parametric polymorphism, `(+)' is constrained to have type of shape `a -> a -> a', for some type `a'
23:54:08 <Saizan_> well, we can give formal definitions in terms of bounded quantification and intersection types
23:54:19 <jkff> Let's say "a function is ad-hoc polymorphic if its definition can be extended"?
23:54:28 <Saizan_> no
23:54:30 <kmc> extended?
23:54:32 <ski> (but if you define `class Foo a where operation :: a', then you could say that `operation' is ad hoc polymorphic)
23:54:41 <jkff> kmc: Yes, by defining another instance of Num
23:54:48 <jkff> Saizan_: Will there be any difference between (+) and plus under those definitions?
23:55:13 <Saizan_> jkff: no
23:55:17 <kmc> jkff, that doesn't extend the defn of your function, *if* you model the semantics of typeclasses by passing instance dictionaries
23:55:31 <kmc> in any case, there's no difference between (+) and plus = (+)
23:55:49 <Saizan_> jkff: (+) and plus can't really be distiguished by any sane definition, because of referentially transparence
23:55:49 <jkff> I'm trying to understand whose property is polymorphism: the property of a term, of a definition, of a type?
23:55:56 <kmc> a type
23:56:06 <kmc> a type is polymorphic iff it contains quantifiers
23:56:21 <jkff> So, a distinction between ad-hoc polymorphism and bounded para-poly cant be made?
23:56:40 <Saizan_> it can be made, looking at the types
23:56:50 <Saizan_> there's no ad-hoc polymorphism in haskell though
23:57:00 <jkff> Saizan_: Can you then give an example contrasting them? Perhaps not in Haskell, then
23:57:38 <Saizan_> jkff: say, in java, you can make methods with the same name and completely unrelated arguments, right?
23:57:42 <jkff> OK, for example, say I have an OO interface Foo with a virtual method foo(). What is the polymorphism of foo() and of a function void bar(Foo x)?
23:57:58 <jkff> I'd say that foo() has late-bound ad-hoc polymorphism
23:58:15 <jkff> And bar has subtyping-bounded parametric polymorphism
23:58:20 <kmc> jkff, because it's dynamically overloaded on its "this" argument
23:58:39 <jkff> Yes, that's why I called it late-bound ad-hoc :)
23:58:53 <kmc> cool, just making sure i understand
23:59:13 <jkff> Well, but what about the case where bar(Foo x) is defined as x.foo()?
23:59:14 <Saizan_> OO usually doesn't have polymorphim, just subtyping
23:59:39 <kmc> i think bar is not parametric -- at least, it's just as extensible as (+)
23:59:41 <Saizan_> they are quite different concepts
23:59:55 <Saizan_> generics add polymorphism
