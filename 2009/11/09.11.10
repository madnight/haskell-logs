00:08:42 <BMeph> mtnviewmark: It's so terse it's downright testy! Hey, wait a minute,... ;)
00:09:14 <Traveler5> Does somebody here know how to run ghc from a usb drive?
00:13:20 <Traveler5> I'm trying to compile and run some simple haskell programs from a computer at school, but it seems like ghc needs some registry entries :(
00:13:45 <Traveler5> Does anyone know a workaround?
00:15:50 <soiamso> Traveler5: which system?
00:17:56 <dmead> >  catch (head []) (\e -> print "that sir, was a pattern match exception")
00:17:57 <lambdabot>   <IO ()>
00:20:33 <dibblego> @type let f t u a = t a >>= \p -> if u p then return p else f t u $! p in f -- is this in the standard library, or something like it?
00:20:34 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> (a -> Bool) -> a -> m a
00:21:41 <Traveler5> soiamso: Windows XP
00:22:53 <soiamso> Traveler5: I think some user space lib are missing?
00:23:35 <Traveler5> if that is the case, how can i solve it?
00:24:13 <Traveler5> my installation works fine at my own computer, but not anywhere else
00:24:40 <soiamso> Traveler5: you have install some cabal package?
00:26:04 <soiamso> Traveler5: try compile with -optl-static
00:27:52 <Traveler5> im not sure what version i have
00:28:00 <Traveler5> picked one at random
00:32:15 <Vortex> Hello any expert with DUKPT encryption/decryption ? i am looking for experimented people only , i pay alot of $ .
00:32:57 <medfly> surely you mean experienced :)
00:33:11 <Vortex> im french
00:33:12 <Vortex> :P
00:48:34 <sanxiyn> Hello,
00:48:46 <sanxiyn> Where can I find code for "using LLVM as a back end for GHC" mentioned in http://hackage.haskell.org/trac/ghc/wiki/Status/Oct09 ?
00:52:41 <fasta> Why is the Trac for the network package closed? Even if you login, you cannot add new tickets.
00:54:09 <m3ga> fasta: a couple of the haskell.org tracs were hit by spammers recently. it might have been closed to prevent spam.
00:54:26 <fasta> m3ga, wonderful.
00:54:30 <m3ga> you might need to login to add anew ticket
00:54:38 <pantsd_home> Anyone know if SeaFUNC is still active?
00:54:39 <fasta> m3ga, I already logged in.
00:54:55 <m3ga> well then i don't know :-)
00:55:14 <fasta> Well, it's certainly a good way to keep the bug-count low.
00:55:51 <m3ga> maybe ask on the haskell-libraries list
00:58:25 <dmead> > !True
00:58:26 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
00:58:33 <dmead> > (not True)
00:58:34 <lambdabot>   False
01:02:51 <dmead> ?src not
01:02:51 <lambdabot> not True   =  False
01:02:51 <lambdabot> not False  =  True
01:06:59 <cathper> The story of my day: I rewrote some Maple code in Haskell. The example speed-up I ran was from > 6 minutes to ~1 sec.
01:07:14 <cathper> Maybe I'm just an exceptional bad Maple programmer.
01:09:21 <Botje> add in some delay loops and tell your boss you got the runtime down to five minutes
01:09:24 <atollena> what's wrong with this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4885#a4885 ?
01:10:10 <Botje> what error do you get?
01:10:55 <atollena> yes sorry http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4885#a4886
01:11:22 <int-e> you're using an unboxed array for arbitrary types
01:11:40 <int-e> try STArray instead of STUArray?
01:12:05 <cathper> Botje: :-D
01:13:32 <atollena> int-e: right, setting the type solved the issue. thanks
01:30:06 <fasta> Can I safely cast a Ptr Word8 to a Ptr CChar with castPtr?
01:31:19 <maltem> cathper, I'm not sure if there are exceptional good Maple programmers at all ;)
01:31:50 <dmead> @hoogle justof
01:31:50 <lambdabot> No results found
01:31:52 <dmead> @hoogle just
01:31:52 <lambdabot> Prelude Just :: a -> Maybe a
01:31:53 <lambdabot> Data.Maybe Just :: a -> Maybe a
01:31:53 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
01:32:06 <quicksilver> fasta: as long as their sizeofs are both 1, which I'm sure they are, that should be fine
01:32:11 <Gracenotes> how does GHC know where to find cabal-installed modules?
01:32:36 <Gracenotes> assuming root was not required to install them -- they seem local
01:33:21 <Gracenotes> I knew the 9.10 upgrade wouldn't be all peaches and cream :/ in fact, it's hardly been..
01:34:06 <dmead> if i'm sure a function that returns a maybe WILL return Just a
01:34:19 <dmead> is there a built in function to extract the value?
01:34:28 <fasta> Gracenotes, tell me about it. It was a nightmare to upgrade. Ubuntu QA is a failure.
01:34:30 <dmead> ie justof
01:34:33 <dmead> or justin
01:34:58 <dmead> Gracenotes, if you install 8.10 and press upgrade its alot nicer
01:35:00 <dmead> no bugs
01:35:03 <Gracenotes> I'm trying to upgrade cabal.. I think I should just move the directory and start from scratch
01:35:28 <fasta> dmead, I suppose that's one of those LTS releases?
01:35:30 <Gracenotes> dmead: there are no bugs per se. Just QA with programs, as you said
01:35:35 <dmead> ah
01:35:50 <dmead> fasta, not sure
01:36:01 <dcoutts> Gracenotes: there's no need to blow away existing installed packages just to upgrade cabal
01:36:06 <Gracenotes> if I wanted a fresh install on all my programs, I'd do a fresh install
01:36:29 <Gracenotes> but that's not going to help me get GHC/Cabal/Firefox/etc. running. So that's pointless
01:36:59 <dcoutts> Gracenotes: what version of cabal are you upgrading from?
01:37:06 <fasta> Any OS maker that expects people to do a "fresh install" would be long bankrupt if there were any kind of meaningful competition.
01:37:26 <fasta> \end rant
01:38:07 <Gracenotes> from your point I've deduced that there is, never has been, nor never will be meaningful competition with OSes
01:38:53 <Gracenotes> dcoutts 0.6.0, using Cabal 0.6.0.1
01:39:17 <dcoutts> Gracenotes: ok, so just: cabal install Cabal cabal-install
01:39:54 <Gracenotes> okay, and that won't cause the universe to implode in on itself?
01:39:57 <dcoutts> Gracenotes: nope
01:40:04 <fasta> @hoogle CInt -> FD
01:40:06 <lambdabot> Prelude abs :: Num a => a -> a
01:40:06 <lambdabot> Prelude negate :: Num a => a -> a
01:40:06 <lambdabot> Prelude signum :: Num a => a -> a
01:40:20 <Gracenotes> I should cabal update first
01:40:50 <dcoutts> Gracenotes: there's some new stuff in the config file, you might like to let it create you a default config and then merge back your local changes.
01:41:12 <dcoutts> but it'll continue to work fine with your existing config
01:41:29 <fasta> dcoutts: you didn't happen to already have fixed network for Windows, did you?
01:42:15 <dcoutts> fasta: no. there was a thread about that on the libs list recently (or maybe it was -cafe)
01:42:33 * dcoutts is still using 6.10 on windows
01:42:36 <fasta> dcoutts: yes, and it was fixed for Linux. That basically closed the thread.
01:43:11 <Gracenotes> ugh. zlib has a ByteString dependency? :/ cabal should make dealing with HTTP and Zlib a bit more.. elegant, I think. first thing that bit me when I first installed it, too.
01:43:49 <dcoutts> Gracenotes: what's the problem there?
01:44:22 <Gracenotes> Codec/Compression/GZip.hs:71:7: Could not find module `Data.ByteString.Lazy': There are files missing in the `bytestring-0.9.1.5' package
01:44:36 <Gracenotes> incidentally, when I run ghci normally, it can't find any of the cabal packages I installed with 6.8
01:44:46 <dcoutts> Gracenotes: if that's what it says then it's probably true
01:44:50 <Botje> @tell bos Did Luke get in touch with you about Pcap? If not, it won't work properly on recent GHCs unless you use autoconfUserHooks in Setup.lhs
01:44:51 <lambdabot> Consider it noted.
01:44:52 <fasta> What is fdIsSocket_  in a FD?
01:44:58 <Gracenotes> truth is not useful :/
01:45:00 <dcoutts> Gracenotes: you probably deleted the files without unregistering the package
01:45:05 <dcoutts> Gracenotes: see ghc-pkg check
01:45:29 <fasta> It is a !Int, but it doesn't say how it is different from just a fdFD.
01:45:37 <dcoutts> Gracenotes: easy way to fix it is to unregister the broken packages, cabal will install them again if they're deps of the things you need
01:46:54 <Gracenotes> okay, I'm doing a --reinstall
01:48:56 <tau> hi, does someone appoint to me one good book to introduct me to haskell ?
01:49:02 <fasta> Is there any kind of better documentation for the network package?
01:49:08 <medfly> @where lyah
01:49:09 <lambdabot> www.learnyouahaskell.com
01:49:48 <fasta> Ah, ok, it could be deduced from use. It basically is a hack how it is done now.
01:50:13 <tau> medfly: hum
01:50:27 <Gracenotes> dcoutts: excellent! bootstapping (indirect, at least) went as planned
01:50:49 <Gracenotes> except GHC still can't see the packages. so, eh, may as well reinstall all of them
01:51:31 <MacCoaster> hi guys, im trying to understand how to define classes and make instances of them, what are the best resources for those because i'm encountering errors in my code im not sure if i understand them?
01:51:37 <dcoutts> Gracenotes: you mean ghc-pkg list does not show them?
01:51:59 <dcoutts> Gracenotes: if ghc-pkg check doesn't report any problems then you're fine
01:52:26 <Gracenotes> I did not even know of the existence of ghc-pkg. but no, it doesn't show anything in .cabal/lib
01:52:40 <Gracenotes> which I had installed with 6.8
01:53:07 <Gracenotes> except what I just installed now to fix the problems ghc-pkg reported :)
01:53:11 <dcoutts> Gracenotes: the packages registered with one ghc version are separate from those registered with another ghc version
01:54:11 <Gracenotes> ah. but cabal registers as you install, it seems. So I'll just delete my current cabal packages and reinstall them.
01:54:55 <Gracenotes> ..and I assume the packages registered locally have precedence over those registered globally
01:55:50 <dcoutts> Gracenotes: if you're blowing away all of ~/.cabal/lib then you must also unregister the packages or you'll end up with loads of broken packages
01:56:07 <dcoutts> Gracenotes: so you'd have to also rm ~/.ghc/$arch/package.conf
01:56:41 <Gracenotes> hm.. why do I need to unregister packages ghc-pkg doesn't seem to see in the first place?
01:57:38 <dcoutts> Gracenotes: then there's no need to delete them! :-)
01:58:13 <dcoutts> cabal does not care one jot about packages that are not registered (it never sees them)
01:59:31 <Gracenotes> hm. so I'll probably end up installing over them.
02:00:30 <dcoutts> that's fine
02:01:24 <Gracenotes> actually, wait.. it seems I'm confusing the old .cabal directory with the new .cabal directory. there are two of them. oh well, fair riddance to the old one
02:01:45 <Gracenotes> through some accident, old is in .cabal/.cabal/bin, and new is in ./cabal/bin. *blames mv*
02:02:00 <Gracenotes> well, that clears things up
02:02:06 <dcoutts> Gracenotes: ah, so that's why you had the broken packages
02:02:46 <Gracenotes> I did this mv right before I bootstrapped cabal. I ran into the error when everything was one directory.. but eh.. it's better this way
02:05:09 <GNU\colossus> I have a recursive function, and need its subsequent calls to itself NOT include parameters I've already fed into the former calls to the function - how can I do that?
02:05:18 <fasta> Is there any kind of accepted policy for supporting older versions of GHC?
02:05:34 <Gracenotes> now, let me make sure I install it with profiling support, so I don't have to worry about it down the road
02:05:52 <GNU\colossus> (in other languages I know, I'd just keep track of the values in some data structure, and would skip the calculation if the argument to my function was found in said structure)
02:06:14 <fasta> With the amount of changes you see in GHC, there will be more version conditionals that normal source lines.
02:06:28 <fasta> than*
02:06:32 <cathper> maltem: You're probably right :-)
02:08:02 <Gracenotes> GNU\colossus: something along the lines of memoization?
02:09:57 <GNU\colossus> Gracenotes: I'm unfamiliar with the concept. my problem is that, given a certain setup of input, my function rund infinetly long, bouncing between two computed values ("func 1" calls "func 2" calls "func 1" etc.)
02:10:12 <GNU\colossus> would memoization help me stop it from doing that? ;)
02:10:32 <Gracenotes> hm.. memoization is more for things that aren't cyclic
02:11:13 <Gracenotes> if you have an infinite loop, that's probably a problem with the function, right? you need a base case of sorts
02:11:21 <Gracenotes> or possibly several :)
02:11:36 <GNU\colossus> what do you mean by "base case"?
02:11:54 <GNU\colossus> I'm sorry, but I'm both beginning with functional programming, and not a native english speaker :/
02:14:20 <fasta> GNU\colossus, base case to stop a recursive process.
02:14:38 <fasta> GNU\colossus, the sum of an empty list of numbers is 0 for example.
02:15:13 <GNU\colossus> fasta: yeah, I see. I'm actually trying to implement that by what I'm doing (or rather, trying to do)
02:15:20 <fasta> GNU\colossus, on the right side of the equation there is no reference to the recursive function being defined, so a base case.
02:16:05 <fasta> GNU\colossus, basically it's induction and then you also have structural induction and some other kinds of induction that are fairly uncommon.
02:16:41 <Jedai> GNU\colossus: It would be easier to help you if you told us what you're trying to do concretely
02:17:19 <fasta> GNU\colossus, I guess you just want to deconstruct a compound value. That is turn for example a list in to (x:xs)?
02:17:20 <GNU\colossus> Jedai: ok, I'll try to do that. please bear with me while I'M trying to paraphrase into english...
02:18:49 <GNU\colossus> I've got a directed graph's adjacency matrix in the form of http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int. my task is to write a function that determines all the nodes in the graph that could be used to reach a given node by following edges directed towards the target node. (no did that make any sense?)
02:19:11 <GNU\colossus> ah, sorry. my client's wikipedia auto expansion ruined the List of List of Int
02:19:30 <GNU\colossus> [[Int]]
02:20:06 <fasta> Can someone tell me the type of writeRawBufferPtr in 6.10.4?
02:20:32 <cathper> Is there a built in function that changes a given index of a given list to a given value?
02:20:32 <fasta> I don't have it running here. It should be in GHC.Handle or somewhere like that.
02:20:43 <fasta> cathper, yes, see Data.List
02:20:52 <cathper> fasta: I will. Thanks.
02:21:34 <fasta> cathper, or actually, maybe not, but it will be trivial to define and almost always the wrong thing to do.
02:23:01 <cathper> I couldn't find one.
02:24:04 <cathper> I'm going to iterate over a [a1,...,0,...,an], [a1,...,1,...,an], ..., [a1,...,q,...,an] for some index i and some q.
02:24:14 <cathper> fasta: What would a better solution be?
02:24:48 <cathper> s/over a/over ai/
02:25:35 <fasta> cathper, needs more context, and I am quite busy, sorry.
02:27:01 <quicksilver> cathper: map (\x -> [a1...ak] ++ x ++ [aj...an]) ?
02:27:07 <quicksilver> missing last paramenter
02:27:14 <quicksilver> map (\x -> [a1...ak] ++ x ++ [aj...an]) [0..q]
02:27:38 <quicksilver> the "..." is pseudo sytanx for your real list fragments, but the .. is real syntax. Poor choice of notation.
02:27:45 <fasta> Is there something like Github, but which works for darcs?
02:27:55 <vegai> fasta: patchtag
02:28:07 <vegai> patch-tag.com that is
02:28:13 <fasta> vegai, so, you can point at a remote repo and say "clone it"?
02:28:39 <fasta> That would sort of get rid of any delays people have with applying patches and all that.
02:28:39 <vegai> that's the most basic feature, isn't it
02:28:53 <fasta> vegai, well, I am not very demanding in this particular area ;)\
02:28:57 <vegai> oh, you mean the workprocess where people pull from other repos
02:29:14 <Jedai> GNU\colossus: The end didn't really make sense, do you mean all the node from which you can get to the target by following an edge *or* by following a path
02:29:30 <vegai> yeah, I guess you can do that with darcs, cannot you?
02:29:43 <Jedai> GNU\colossus: ??
02:29:53 <vegai> actually quite a bit nicer than with git, because of the default cherrypicking feature
02:31:04 <GNU\colossus> Jedai: by following one or more edges (I think that's what a path is, right? :))
02:31:21 <GNU\colossus> so not just the immediate neighbors of the node in question
02:31:57 <Jedai> GNU\colossus: Ok, so you want all ancestors of a node and you have the classical problem of not wanting to visit the same node several times
02:32:51 <GNU\colossus> Jedai: yup, that neatly sums it up, I think.
02:33:03 <cathper> quicksilver: I did the following: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4890#a4890
02:33:11 <Jedai> GNU\colossus: In fact your problem is to be able to make a traversal of the graph
02:35:35 <quicksilver> cathper: sure just be aware that in general it's a bad idea.
02:35:42 <Jedai> GNU\colossus: Note that you have the exact same problem in other languages, you somehow have to keep track of which node you already visited. In other languages you have the option of adding a mutable field to your node record to flag it as visited or not but in Haskell, doing that would force you to use the ST or the IO monad, so you have to use the other method
02:36:35 <cathper> quicksilver: I am.
02:36:46 <Jedai> GNU\colossus: that is you have to keep a Set (or an IntSet rather, if you use Int as Id of your nodes) of the traversed nodes
02:37:14 <GNU\colossus> Jedai: OK, since I haven't used IO in haskell yet, I guess I'll stay away from that option
02:37:18 <GNU\colossus> and rather pursue the other one
02:37:21 <quicksilver> IntSet of visited, IntSet of not-yet visited, on each iteration you build an IntSet of "newly visited on this iteration"
02:37:38 <quicksilver> when the "newly visited" set has size zero, you're done.
02:37:55 * hackagebot upload: matsuri 0.0.1 -  (OlegIvanov)
02:38:34 <GNU\colossus> I don't think that I can pull that of within the next 3 hours
02:39:26 <quicksilver> should take about 10-15 minutes.
02:39:35 <Jedai> GNU\colossus: you probably don't need much time
02:39:54 <quicksilver> newly visited is all nodes from the "not-yet-visited" set which are neighbours of nodes form the "visited" set
02:40:14 <quicksilver> you can do that with a filter.
02:40:41 <GNU\colossus> I don't know how to create and maintain those sets of nodes though
02:41:10 <Jedai> GNU\colossus: Just use Data.IntSet, it's rather easy to use
02:41:32 <Jedai> GNU\colossus: The documentation should be enough to get it
02:41:32 <GNU\colossus> I'll take a look at it. thanks.
02:42:54 <fasta> It would be kind of nice to have IntSet translate to ST under the hood if you only use it in a single threaded way. Those are things a FP language compiler should do, imho. High-level interfaces, low-level performance.
02:50:38 <Jedai> fasta: Yeah, it would be nice but it's pretty hard to guarantee a posteriori that something is used in a single-threaded way except in the simpliest of cases. That's why ST was invented after all, to guarantee the single-threadness of the operation and so allow for efficient operations
02:54:06 <Jedai> quicksilver: I think it would be nicer to work on the "n-shell" basis, that is start by coding how to find all the nodes at distance n of the original node and then by simple transformation of the code get an infinite list of those efficiently and keep the not empty prefix then do the union
02:54:28 <quicksilver> Jedai: sure I was just suggesting a fairly simple to understand and effective algorithm.
02:54:42 <quicksilver> Jedai: there are probably cleverer ways
02:56:16 <Jedai> quicksilver: Right, I like the n-shell approach because it's not too complicated, leads to clear code and isn't too inefficient (which your suggestion is :P )
02:57:37 <Jedai> quicksilver: but if he manage it correctly with your suggestion, he should already have progressed in his understanding of Haskell greatly ^^
03:01:13 * Baughn builds a Carnot engine, and sets it to filter bottoms
03:04:25 <fasta> dcoutts: what versions do you want to support with cabal install?
03:04:55 <fasta> dcoutts: I.e. some exception e needs to be changed to  (e::SomeException) to work on 6.12.
03:05:06 <dcoutts> fasta: from 6.6 to 6.12, though currently it does not build with 6.6
03:05:20 <dcoutts> fasta: are you using the darcs version?
03:05:24 <fasta> dcoutts: yes
03:05:58 <fasta> dcoutss: I am using the bootstrap script.
03:06:09 <fasta> dcoutts: (from the darcs repository)
03:06:27 <fasta> dcoutts: I almost got it to work.
03:06:31 <dcoutts> fasta: works for me using ghc-6.12.0.20091007
03:06:46 <dcoutts> are you sure you're using the latest darcs version?
03:06:52 <fasta> dcoutts: on Windows?
03:07:08 <dcoutts> shouldn't make a difference to whether it compiles
03:07:32 <dcoutts> I don't have 6.12 on windows, but I can check it builds with base 4 using 6.10
03:07:37 <dcoutts> on windows
03:07:45 <fasta> dcoutts: I use 6.12.0.20091010
03:07:46 <dcoutts> and that's what the (e::SomeException) is about, base 4
03:08:02 <dcoutts> fasta: what file, what line is the error
03:08:18 <fasta> HttpUtils, line 49
03:08:40 <fasta> dcoutts: In Distribution/Client
03:09:51 <dcoutts> fasta: ah hah, you're right
03:09:56 <dcoutts> that's a #ifdef Win32 bit
03:10:14 <dcoutts> so windows does make a difference :-)
03:12:09 <fasta> dcoutts: I know how to fix it with CPP magic. The question is should I or can you do it and push it to the repo? I mean you have the file open already.
03:12:45 <dcoutts> fasta: thanks, I'll fix it
03:13:13 <fasta> dcoutts: can you tell me when it is on the repo?
03:13:33 <fasta> dcoutts: then I can test whether the whole thing works and send my network patches too.
03:14:09 <fasta> dcoutts: and then hopefully the shared library support actually works on Windows (the make a big DLL thing).
03:15:23 <^cicciuzzo^> Un Saluto a tutti «  #haskell » [Þrison-ßreak][§cript]       
03:15:25 <^cicciuzzo^> ÇÏÅØøØø
03:15:30 <^cicciuzzo^> !list
03:15:31 <Optimo> I syndicate the following:
03:15:31 <Optimo> iPodTVNova_Movies iPodTVNova_Television
03:15:47 <^cicciuzzo^> ÇÏÅØøØø
03:15:54 <^cicciuzzo^> !list
03:15:55 <Optimo> I syndicate the following:
03:15:55 <Optimo> iPodTVNova_Movies iPodTVNova_Television
03:16:14 <fasta> Kick/ban please.
03:16:43 --- mode: ChanServ set +o dibblego
03:16:57 --- kick: ^cicciuzzo^ was kicked by dibblego (dibblego)
03:17:02 <^cicciuzzo^> Un Saluto a tutti «  #haskell » [Þrison-ßreak][§cript]       
03:17:03 --- mode: dibblego set +b *!*n=enzo71@94.162.62.*
03:17:05 --- kick: ^cicciuzzo^ was kicked by dibblego (dibblego)
03:17:30 <Zao> I've always wanted some Thrison-ssreak.
03:18:08 <Zao> Optimo: Care to explain your response to the trigger?
03:18:12 --- mode: dibblego set -o dibblego
03:19:05 <marcot> Good morning.  How do I modify alex monad-bytestring template?  Should I copy the generated code inside the .x file and remove the %wrapper line?
03:24:07 <dcoutts> marcot: that'd work
03:24:43 <marcot> dcoutts: But is there a better way?
03:24:54 <marcot> dcoutts: In my case I'd like only to replace the alexError function.
03:27:23 <GNU\colossus> I just don't get it :( my head hurts, and I'm slowly starting to hate this world :(
03:27:35 <Axman6> :\
03:27:49 <cathper> I have a whole lot of list of lists, which can be interpreted as matrices. Any hints on how to pretty-print it?
03:28:03 <dcoutts> marcot: see the alex user guide
03:28:09 <cathper> I consider importing the data into a spreadsheet ...
03:28:33 * medfly hugs GNU\colossus 
03:28:50 <marcot> dcoutts: I've read it.  Maybe I've missed something, but I've looked there before asking here.  Can you point me out where in the user guide?
03:28:51 <medfly> I had a thing for that, cathper
03:28:51 <Axman6> cathper: mapM_ print?
03:29:06 <cathper> medfly: Really?
03:29:13 <medfly> well, sort of
03:29:31 <medfly> I had a list of lists for my tetris game, and I had a way to display it...
03:29:35 <dcoutts> marcot: the bit on the most general interface, rather than using a template
03:30:35 <medfly> I used something like 'putStr . unlines . map unwords $ (list of lists)'.
03:30:47 <medfly> it did some other things then, though :)
03:30:47 <marcot> dcoutts: Thanks.  My point is to get a slightly modified version of monad-bytestring, so I guess the better option is to include the monad-bytestring code in my .x and change the bits I want to change.
03:31:04 <cathper> medfly: I see.
03:31:18 <cathper> I think I'll follow Axman6's advice.
03:31:19 <medfly> I hope this helps. :)
03:31:24 <medfly> hurray Axman6!
03:31:36 * Axman6 hurrays
03:31:36 <cathper> OO.org will ask how to interpret pasted multiline content.
03:31:42 <cathper> :-)
03:38:12 <dcoutts> fasta: pull
03:40:35 <fasta> dcoutts: it compiles. Thanks. I just have to add it to my Windows path and it should work. Thanks.
03:48:06 <maartenm> haskell makes me happy when my job stinks
03:49:00 <Axman6> heh
03:53:22 <sohum> oh dear
03:53:24 <sohum> :t mapM
03:53:25 <sohum> :t mapM_
03:53:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:53:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:53:40 <sohum> that's what the _ versions are?
03:54:01 <sohum> meant for IO and IO only?
03:54:07 <Axman6> > mapM return [1..10] :: [Int]
03:54:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:54:09 <lambdabot>         against inferred type ...
03:54:16 <Taejo> @pl filter1 p = foldr (\x xs -> (if (p x) then (x:xs) else xs))  []
03:54:17 <lambdabot> filter1 = flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
03:54:17 <Axman6> > mapM return [1..10] :: [[Int]]
03:54:19 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
03:54:30 <Axman6> > mapM_ return [1..10] :: [()]
03:54:32 <lambdabot>   [()]
03:54:48 <sohum> :t mapM_ return [1..9]
03:54:50 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
03:55:03 <Baughn> @pl \p -> foldr (\x xs -> (if (p x) then (x:xs) else xs))  []
03:55:03 <lambdabot> flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
03:55:26 <Axman6> sohum: mapM_ is very useful for doing things like printing everything in a list with mapM_ print, becayse it doesn't build up a list of ()'s
03:55:37 <Axman6> :t mapM_ print [1..10]
03:55:39 <lambdabot> IO ()
03:55:44 <Axman6> :t mapM print [1..10]
03:55:46 <lambdabot> IO [()]
03:56:14 <sohum> Axman6: right, so I suppose it's only useful in a monad where it doesn't matter if you get the return value or not
03:56:27 <sohum> *with a function where it ...
03:56:52 <Axman6> well, what about mapM_ (modify . (+))?
03:56:59 <Axman6> or something...
03:57:03 <sohum> :t modify
03:57:05 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:57:13 <sohum> yep, returns m ()
03:57:14 <Axman6> man, State still confuses me. i get how it works, just not how to use it >_<
03:57:20 <sohum> so should be useful
03:57:21 <sohum> same!
03:57:33 <sohum> I just end up writing my own half-assed versions, it looks like
03:57:34 <Axman6> :t mapM_ (modify . (+))
03:57:36 <lambdabot> forall s (m :: * -> *). (MonadState s m, Num s) => [s] -> m ()
03:57:45 <quicksilver> Axman6: State is just a convenient way to construct functions (s -> s)
03:57:52 <quicksilver> [... and also s -> (a,s) ]
03:58:00 <quicksilver> if you didn't want one of those, you don't need State.
03:58:01 <sohum> ...don't do that, quicksilver
03:58:14 <sohum> you make me think of the enum notation :P
03:58:17 * Axman6 prefers to use explicit state passing, makes code more readable
03:58:36 <quicksilver> Axman6: yes, you think that
03:58:41 <Taejo> Axman6: but then you can't use monad abstractions like mapM
03:58:52 <quicksilver> Axman6: until the 3rd or fourth time you've switched a "s'" for an "s''" and broken the code
03:58:57 <quicksilver> Axman6: and then you see the point of the monad
03:59:04 <quicksilver> but that's fine. That's a very good way to make the journey.
03:59:07 <sohum> Axman6: I suppose it's another case where understanding the higher level abstraction pays off overall
03:59:24 <Axman6> quicksilver: i pick better names than that :)
04:00:10 <quicksilver> sure, but when you have let new_s = ... s; newer_s = .... new_s; really_really_new_s = .... newer_s ...
04:00:19 <quicksilver> eventually you will wish you didn't have the name the states.
04:00:28 <fasta> dcoutts: is there some msys distribution that doesn't contain _ancient_ versions of the various tools?
04:00:39 <quicksilver> a GHC version in the 6.8 series had an optimisation which didn't fire because SPJ used s'' when he meant s'''
04:00:50 <sohum> I think my issue with the state monad is that I usually think of monadic computations as a strict chain, but using State requires branches and what appears to be destroying data at first glance
04:01:46 <dcoutts> fasta: the one recommended on the ghc windows wiki page
04:01:48 <Taejo> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8774#a8775 is (I think) an example where State is nice (if I wasn't golfing, I'd have written symtable a little differently, but the same State ideas
04:02:41 <Axman6> ...
04:02:53 <Axman6> i have no idea wtf that code is doing
04:03:00 <sohum> ...yea, yay gold
04:03:00 <Axman6> and i don't care to :P
04:03:02 <sohum> *golf
04:03:25 * Axman6 dislikes code golf almost as much as pointfree style misuse
04:04:15 <sohum> no pointfree use is pointfree misuse, comrade!
04:04:53 <Taejo> Axman6: fair enough, but the idea is simple enough: symtable parses each command into a State action, and then uses mapM to run each line in turn
04:05:07 <Axman6> fair enough
04:06:13 <sohum> actually, I'm interested. what would you consider pointfree misuse?
04:06:31 <Taejo> filter = flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
04:06:41 <Taejo> I would consider that pointfree misuse
04:07:07 * sohum snerk
04:07:12 <sohum> barring pathological cases
04:07:22 <Axman6> sohum: is there's more than one unnammed variable being left out, or more than any of {flip, const, ap, etc.}, then you're misusing it imo
04:07:33 <sohum> why const?
04:07:38 <sohum> const is really useful
04:07:42 <sohum> heck, so is flip
04:07:46 <sohum> I'll agree re: ap
04:08:25 <Axman6> sohum: if there's more than one, you're probably doing it wrong. unless it's a typical use for const
04:08:29 <Taejo> in simple cases I do use ap
04:08:40 <Axman6> :t ap
04:08:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:08:44 <Taejo> but more than one ap is pretty much a nono
04:08:50 <Axman6> yeah
04:09:08 <sohum> I still don't see how consts are an issue, though.
04:09:11 <Taejo> at least in ((->) r)
04:09:19 <Axman6> sohum: const is the lowest on my range of stay away from functions in  pointfree though ;)
04:09:24 <GNU\colossus> how can I "subtract" on list from another, so that the resulting list contains only hose items from the first list that aren't present in the second?
04:09:27 <sohum> they're just constant functions
04:09:33 <sohum> Axman6: heh, fair enough
04:09:38 <Botje> GNU\colossus: look into \\ from Data.List
04:09:38 <sohum> GNU\colossus: (\\)
04:09:40 <Axman6> > [1..10] \\ [1..3]
04:09:42 <lambdabot>   [4,5,6,7,8,9,10]
04:09:57 <Axman6> ok, goodnight all
04:10:10 <medfly> good night!
04:10:16 <GNU\colossus> thanks, will try!
04:10:40 <Taejo> GNU\colossus: note that (\\) takes quadratic time. You might prefer to use a set than a list
04:10:51 <sohum> @unpl  flip foldr [] . flip flip id . (ap .) . (`ap` (:)) . (((.) . if') .)
04:10:51 <lambdabot> (\ s -> foldr (\ i -> (((\ ar n o -> if' (s ar) (n o)) >>= \ at -> ((:)) >>= \ as -> return (at as)) i) >>= \ aa -> (\ j -> j) >>= \ z -> return (aa z)) [])
04:11:09 <sohum> ...unpl: not so good
04:12:11 <sohum> Taejo: what's the cost for building the sets, diffing them, and then toListing them? is it better than quadratic?
04:12:20 <Botje> \j -> j is kind of useless :)
04:13:03 <quicksilver> GNU\colossus: use IntSet as we advised, and that has 'difference' AFAIK
04:13:07 <quicksilver> @hoogle difference
04:13:07 <lambdabot> Data.IntMap difference :: IntMap a -> IntMap b -> IntMap a
04:13:08 <lambdabot> Data.IntSet difference :: IntSet -> IntSet -> IntSet
04:13:08 <lambdabot> Data.Map difference :: Ord k => Map k a -> Map k b -> Map k a
04:13:10 <quicksilver> ]yup
04:13:12 <lunabot>  luna: Not in scope: `yup'
04:13:21 <sohum> ...wut
04:13:25 <Taejo> sohum: sure. it's O(n log n), but if you're going to convert them back to lists right away, you're probably better off sorting and using a sorted-list difference
04:13:26 <sohum> ]help
04:13:29 <lunabot>  type of an expression:      , [$ty| \x -> x |]
04:13:29 <lunabot>  get info for a type/class:  , src ''Monad
04:13:29 <lunabot>  get info for a var/con:     , src 'fix
04:13:58 <sohum> Taejo: *nod*
04:14:29 <sohum> I still don't know why mfix exists
04:14:33 <sohum> what is it useful for?
04:14:53 <fasta> sohum, tying monadic knots.
04:15:09 <sohum> ...?
04:15:09 <fasta> sohum, it takes some time to understand why that might be useful. There are papers, as always.
04:15:24 <sohum> huzzah :P
04:15:28 <fasta> sohum, it's not in RWH, so you don't need it :P
04:17:20 <sohum> hehehe
04:44:55 <ivanm> preflex: seen byorgey
04:44:55 <preflex>  byorgey was last seen on #haskell-blah 8 hours, 16 minutes and 37 seconds ago, saying: * byorgey hugs shapr
04:45:03 <poucet> @seen shapr
04:45:04 <lambdabot> Unknown command, try @list
04:45:47 <ivanm> @tell byorgey thanks for getting mkcabal functionality into cabal-install! it's been rather irritating having to work out how to write a .cabal file from scratch since mkcabal doesn't work anymore :s
04:45:47 <lambdabot> Consider it noted.
04:45:52 <ivanm> poucet: use preflex
04:45:57 <ivanm> preflex: seen shachaf
04:45:58 <preflex>  shachaf was last seen on #haskell-blah 4 days, 17 hours, 3 minutes and 36 seconds ago, saying: What do you mean by "validity"?
04:45:59 <poucet> preflex: help
04:45:59 <preflex>  try 'help help' or see 'list' for available commands
04:46:00 <ivanm> preflex: seen shapr
04:46:00 <preflex>  shapr was last seen on #haskell-blah 8 hours, 7 minutes and 39 seconds ago, saying: My favorite charset.
04:46:04 <ivanm> preflex: ^^
04:46:16 <dcoutts> ivanm: have you tried cabal init? does it work well?
04:46:34 <ivanm> dcoutts: I haven't, just saw your email in -cafe that mentioned it ;-)
04:51:34 <sohum> hm.
04:51:41 <sohum> "preflex: seen someone"
04:51:45 <sohum> no?
04:51:45 <sohum> aww.
04:51:55 <ivanm> preflex: seen someone
04:51:55 <preflex>  someone was last seen on ##c++ 61 days, 16 hours, 28 minutes and 47 seconds ago, saying: roxlu: oh.. ok then :)
04:52:15 <sohum> yea, I wanted to know if I could use the > text stuff
04:56:39 <GNU\colossus> can I make a function evaluate its own result?
04:58:26 <GNU\colossus> probably a dumb question
04:58:35 <ivanm> GNU\colossus: recursively?
04:58:54 <SamB_XP> GNU\colossus: you mean like with fix ?
04:58:54 <ivanm> or something like let (a,b) = foo a c ?
04:59:08 <ivanm> tying the knot ftw!
04:59:16 <GNU\colossus> ivanm: well, I've got a recursive function, and I'd need to have the subsequent call made with an argument that's the result of the current computation
04:59:27 * ivanm has used tying the knot in code where he'd have no idea how to implement it so elegantly in a non-lazy language
04:59:53 <ivanm> GNU\colossus: so a recursive call?
04:59:55 <ivanm> just do it?
05:01:28 <GNU\colossus> ivanm: I'm calling it recursively, but I'm passing a value to the function when calling it. I need that value to be the result of the present calculation.
05:01:46 <ivanm> @google tying the knokt
05:01:47 <lambdabot> http://www.1049films.com/
05:01:47 <lambdabot> Title: Tying the Knot - The Movie
05:01:47 <ivanm> @google tying the knot
05:01:48 <lambdabot> http://www.1049films.com/
05:01:48 <lambdabot> Title: Tying the Knot - The Movie
05:01:51 <ivanm> @google tying the knot haskell
05:01:52 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
05:01:52 <lambdabot> Title: Tying the Knot - HaskellWiki
05:02:00 <ivanm> GNU\colossus: ^^ I _think_ that's what you want
05:02:48 <Lycurgus> GNU\colossus, does your nick refer to a movie?
05:03:09 <Jedai> GNU\colossus: Think on it a little bit, in a traditional language what you just said would have been absurd (do you see why ?)... But in a lazy evaluation language like Haskell it can work if the part of the result you use in your recursive call don't depend on this recursive call
05:03:11 <ivanm> quicksilver: did you get a chance to read through my updated paper?
05:03:58 <Jedai> GNU\colossus: for instance if the result is a list and you use the head in a recursive call that will only yield the tail
05:05:01 <GNU\colossus> Jedai: of course I see how it's absurd in a traditional language, that's why my mind is screeching whenever I make it think about what I'm trying to do ;)
05:05:11 <Jedai> > let fibs = 0 : 0 : zipWith (+) fibs (tail fibs) in take 15 fibs
05:05:13 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
05:05:20 <Jedai> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 15 fibs
05:05:21 <sohum> "mkDList xs = let (first,last) = go last xs first" < where is the last in "go last xs first" defined?
05:05:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377]
05:06:19 <Baughn> GNU\colossus: Here's a cutie: "mdo threadid <- forkIO (foo threadId)"...
05:06:27 <ivanm> sohum: are you asking, or prompting GNU\colossus?
05:06:28 <Baughn> GNU\colossus: And yeah, that works across multiple statements, and with I/O
05:06:34 <Jedai> GNU\colossus: Right, but Haskell still don't do magic so there's ways to think about it without going insane, see my definition of the fibonacci sequence for an example
05:06:37 <ivanm> Baughn: :o
05:06:44 <ivanm> Baughn: even though mdo is deprecated? :p
05:07:01 <Baughn> ivanm: It is? It doesn't say so in the 6.10 documentation.
05:07:05 <sohum> ivanm: can I say both ? :P I'm asking.
05:07:08 <ivanm> Baughn: for 6.12
05:07:11 <ivanm> sohum: in the result
05:07:20 <ivanm> GNU\colossus: http://www.haskell.org/haskellwiki/Tying_the_Knot
05:07:27 <SamB_XP> ivanm: deprecated by whut ?
05:07:37 <Baughn> ivanm: Deprecated isn't removed, and 6.12 isn't out yet
05:07:41 <Jedai> SamB_XP: rec-block in do-notation
05:07:48 <Baughn> ivanm: Besides, haskell-mode /just/ got support for mdo
05:07:49 <ivanm> SamB_XP: letrec IIRC
05:07:52 <sohum> ivanm: that's ... so, a recursive definition?
05:08:16 <ivanm> sohum: well, the value of last isn't evaluated until it's been forced, etc. ...
05:08:18 <ivanm> sohum: so yes
05:08:22 <ivanm> Baughn: heh
05:08:44 <sohum> ivanm: whoa. I assume fixpoints come into the theoretical treatment of it somewhere...
05:08:44 <Jedai> ivanm: it looks like that : do { blabla; rec { doSomethingWith stuff; stuff <- yadayada }; return stuff }
05:08:59 <SamB_XP> I don't think they can deprecate something by something else that hasn't seen the light of day yet!
05:09:19 <Baughn> Of course, in the I/O monad that would block nastily if doSomethingWith actually /needs/ "stuff"
05:09:35 <ivanm> sohum: well, it returns let but hasn't actually evaluated yet
05:09:43 <ivanm> s/let/last/
05:09:50 <ivanm> *it yet
05:09:50 <Jedai> Baughn: Well it works as well as mdo worked, that is it still doesn't do magic...
05:09:51 <ivanm> bah
05:10:01 <ivanm> Jedai: awwww....
05:10:34 <Jedai> ivanm: Yeah, sorry the time machine will come with ghc 8.6 though, so don't worry, we're getting there
05:10:45 <ivanm> heh
05:11:28 <Baughn> Jedai: Ah, but if you use FRP-based commutative I/O, it can make progress even in that case
05:11:36 <Baughn> Jedai: ..to the degree that it'd work in pure code, anyhow
05:12:01 <maartenm> yesterday I tried installing ghc (haskell platform) on my mac at home -I only play with it at work
05:12:03 <maartenm> on Tiger
05:12:08 <maartenm> it wasn't possible
05:12:16 <maartenm> is it ok againw ith Snow Leopard?
05:13:05 <Baughn> maartenm: IIRC there's some kind of messup with the platform, but you can install GHC and cabal-install well enough, and then you don't need it
05:13:22 <maartenm> hmm, ok.. I liked the consolidation done by the platform
05:13:27 <maartenm> don't give up on mac guys
05:14:09 <Baughn> maartenm: There just aren't that many mac developers, but it's still in a much better state than the windows variant
05:14:18 <maartenm> ?
05:14:24 <maartenm> installing on windows is a no-brainer
05:14:28 <maartenm> with the platform, at least
05:14:31 <Baughn> Yeah?
05:14:37 <maartenm> I was surprised to not find the same ease with mac
05:14:42 <Baughn> Try installing any nontrivial program from hackage on windows
05:15:01 <maartenm> dependency hell, you mean?
05:15:16 <Baughn> For values of "dependency" meaning "unix", sure
05:15:19 <maartenm> well I have to say, I once tried installing haskore and it wasn't easy
05:15:27 <maartenm> on windows, at least
05:16:07 <Jedai> The main problem is the C part, the pure Haskell solutions works and install themselves well enough
05:16:25 <Baughn> That's.. mostly true.
05:16:46 <maartenm> well anyway, it would be nice if ghci/ghc was easier to install on mac than it is now.. regardless of the maturity of hackage
05:17:25 <maartenm> it's possible many young programmers have been turned off from haskell by the installation problems
05:17:35 <maartenm> *because of
05:17:54 <Zao> Well, if they use macs, I'm unsure if we want them :P
05:18:04 <maartenm> maybe their parents use macs :)
05:18:57 <Zao> Never forget the Haskell motto -- avoid success at all costs
05:19:00 <maartenm> and I do think the problems are accidental and not some kind of devious scheme of etnic cleansing
05:19:07 <Baughn> @quote failed
05:19:07 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
05:19:16 <maartenm> heh
05:19:29 <Baughn> maartenm: The haskell platform is still young. You can be fairly certain these problems won't last.
05:20:00 <Baughn> maartenm: Actually, I think the current problem was something along the lines of apple altering their linker.. -_-
05:20:08 <maartenm> yeah, the usual
05:20:36 <MichaelGG> Is Leksah pretty much it as far as Haskell IDEs go?
05:21:05 <maartenm> still it doesn't make sense to have things like H# and not even be able to install ghc.exe, it's just something that needs to be cleaned up
05:21:11 <Baughn> MichaelGG: There's also eclipse-fp and my personal favorite, emacs' haskell-mode
05:21:16 <sohum> emacs!
05:21:29 <sohum> there's an eclipse plugin?
05:21:39 <maartenm> I never could install that one, the eclips eplugin
05:21:43 <netinho> will some one evaluate this, please?
05:21:43 <maartenm> it's badly maintained
05:21:49 <netinho> @let duplicate xs = concat [replicate 2 x | x <- xs]
05:21:51 <lambdabot>  <local>:9:0:
05:21:51 <lambdabot>      Warning: Pattern match(es) are overlapped
05:21:51 <lambdabot>               In...
05:21:53 <Baughn> It's seen a lot of work lately
05:22:05 <maartenm> ok, don't take my word for it
05:22:11 <netinho> > duplicate [0..5]
05:22:13 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5]
05:22:21 <netinho> it works :D
05:22:28 <Baughn> maartenm: If you last checked before summer, you're outdated. :P
05:22:51 <Baughn> @undefine
05:23:07 <Baughn> @let duplicate = join . map (replicate 2)
05:23:07 <lambdabot>  Defined.
05:23:16 <Baughn> > duplicate "Hey there"
05:23:17 <lambdabot>   "HHeeyy  tthheerree"
05:23:26 <maartenm> Baughn: http://eclipsefp.wordpress.com/
05:23:28 <MichaelGG> Baughn: is the eclipse plugin more stable/complete than leksah?
05:23:30 <maartenm> that's what I read
05:23:39 <Baughn> MichaelGG: I have no idea. I only use emacs.
05:23:43 <MichaelGG> ok
05:23:44 <SamB_XP> maartenm: ooh nooo! we'll have to be replacing you, then, if you're outdated!
05:23:47 <Baughn> maartenm: Ah.
05:24:09 <MichaelGG> can you debug in the emacs one?
05:24:11 <maartenm> so the community nursed it?
05:24:15 <maartenm> I didn't know,s orry
05:24:19 <Baughn> MichaelGG: Debug? Haskell?
05:24:20 <maartenm> forget what I said
05:24:21 <SamB_XP> MichaelGG: what's this word, "debug"?
05:24:31 <ivanm> SamB_XP: yeah, I was wondering that as well...
05:24:40 <ivanm> doesn't the type system guarantee no bugs? :p
05:24:40 <Baughn> MichaelGG: Haskell programs work the first time. Which is good, because you can't debug them.
05:24:50 <sohum> tying the knot makes my head hurt, but it makes sense! kinda!
05:24:51 <maartenm> I think it's based on ancient greek
05:24:58 <MichaelGG> I am thinking of putting aside my strict ways for a bit
05:25:19 <SamB_XP> in all seriousness, the GHCi debugger is horrifying to look upon
05:25:30 <sohum> yea, don't use the debugger
05:25:37 <netinho> there's a debugger for GHCI?
05:25:42 <ivanm> sohum: in SourceGraph, I use it to find all exported functions from all modules its analysing to analyse all the other modules!
05:25:50 <sohum> use stuff like quickcheck and in an pinch trace instead
05:26:10 <sohum> ivanm: please... have mercy :P
05:26:15 <ivanm> heh
05:26:19 <MichaelGG> I just saw a Debug menu on Leksah and wondered.
05:26:33 <ivanm> actually, I use tying-the-knot on the module itself to get all the classes it defines IIRC...
05:26:46 <maartenm> there's also Yi, btw
05:26:48 <ivanm> it's hell-a cool! (in a mind-breaking-kind-of-way :s)
05:28:15 <sohum> netinho: there is one, I believe. I've tried to use it.
05:29:57 <netinho> sohum: it looks aweful :|
05:30:37 <netinho> is my function okay for the haskell channel's standards? duplicate xs = concat [replicate 2 x | x <- xs]
05:30:53 <Baughn> netinho: duplicate = join . map (replicate 2)
05:31:04 <opqdonut> concatMap replicate2
05:31:08 <netinho> -_- party pooping
05:31:21 <opqdonut> err, concatMap (replicate 2)
05:31:46 <opqdonut> Baughn: if you use join, use liftM instead of map
05:31:49 <sohum> yea, [f x | x <- xs] is pretty much exactly map
05:32:06 <Baughn> opqdonut: I actually meant to use concat this time, but somehow didn't
05:32:18 <opqdonut> anyway, concatMap is perfectly fine
05:32:43 <sohum> even better:
05:32:48 <Baughn> duplicate = join . (replicate 2 <$>)
05:33:00 <sohum> @let nplicate = concatMap . replicate
05:33:01 <lambdabot>  Defined.
05:33:12 <Baughn> @type nplicate
05:33:13 <lambdabot> forall b. Int -> [b] -> [b]
05:33:17 <netinho> > nplicate [0..10]
05:33:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:33:18 <lambdabot>         against inferred type ...
05:33:30 <sohum> > nplicate 2 [0..10]
05:33:30 <netinho> > nplicate ([0..10]::[Int])
05:33:31 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
05:33:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:33:32 <lambdabot>         against inferred type ...
05:33:35 <netinho> > nplicate 2 ([0..10]::[Int])
05:33:37 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
05:33:49 <Baughn> > nplicate <$> [0..10]
05:33:50 <lambdabot>   [{[]->[];[()]->[];[(),()]->[];[(),(),()]->[]},{[]->[];[()]->[()];[(),()]->[...
05:34:11 <netinho> dudes, I always leave haskell irc completely depressed
05:34:13 <Baughn> > nplicate <$> [0..10] :: [Bool] -> [Bool]
05:34:13 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
05:34:14 <lambdabot>         against inferred typ...
05:34:20 <maartenm> nplicate 0 [0..10]
05:34:29 <maartenm> > nplicate 0 [0..10]
05:34:31 <lambdabot>   []
05:35:14 <sohum> :t (<$>)
05:35:14 <Baughn> netinho: I'm still learning new things myself. I've got programs where I significantly change style over the course of two hundred lines.. usually to the weirder.
05:35:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:35:19 <Baughn> netinho: So don't worry. It never stops.
05:35:25 <sohum> netinho: NEVER
05:35:39 <sohum> what on earth
05:35:56 <Baughn> Hm?
05:35:57 <sohum> :t nplicate <$> [0..10]
05:35:58 <lambdabot> forall b. [[b] -> [b]]
05:36:24 <sohum> :t (<$>) nplicate
05:36:26 <lambdabot> forall b (f :: * -> *). (Functor f) => f Int -> f ([b] -> [b])
05:36:52 * sohum gives up for now
05:36:56 <Baughn> > nplicate <$> [0..10] :: [[Bool] -> [Bool]]
05:36:57 <lambdabot>   [[]->
05:36:57 <lambdabot>    []
05:36:57 <lambdabot>  [True]->
05:36:57 <lambdabot>    []
05:36:57 <lambdabot>  [True,True]->
05:36:59 <lambdabot> [4 @more lines]
05:37:03 <Baughn> @more
05:37:03 <lambdabot>    []
05:37:04 <lambdabot>  [True,True,True]->
05:37:05 <lambdabot>    []
05:37:07 <lambdabot> ...
05:37:26 <maartenm> what is that?
05:37:27 <Baughn> ..geez
05:37:35 <Baughn> > (+1)
05:37:36 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
05:37:41 <Baughn> maartenm: \bot likes printing functions.
05:38:16 <maartenm> (length)
05:38:21 <maartenm> > (length)
05:38:23 <lambdabot>   {[]->0;[()]->1;[(),()]->2;[(),(),()]->3}
05:38:23 <Messi> juego de boxeo online http://www.kobox.org/kobox-fande-Nourine.html
05:38:28 <arcatan> huh
05:38:44 <maartenm> how does it do that
05:38:45 <opqdonut> spam
05:38:53 <ivanm> *sigh* why do spammers think we want to look at a boxing website?
05:39:00 <maartenm> > (nub)
05:39:02 <lambdabot>   {[]->[];[()]->[()];[(),()]->[()];[(),(),()]->[()]}
05:39:03 <ivanm> we have all the boxed types we want/need here!
05:39:13 <opqdonut> maartenm: magic show instance
05:39:26 <opqdonut> > subtract 1
05:39:28 <lambdabot>   {-3->-4;-2->-3;-1->-2;0->-1;1->0;2->1;3->2}
05:39:37 <sohum> > (// [1])
05:39:39 <lambdabot>   No instance for (GHC.Num.Num (i, e))
05:39:39 <lambdabot>    arising from the literal `1' at <in...
05:39:40 <maartenm> > map $ substract 1
05:39:42 <lambdabot>   Not in scope: `substract'
05:39:48 <sohum> :t (// [1])
05:39:49 <maartenm> > map $ subtract 1
05:39:50 <lambdabot>   []->
05:39:50 <lambdabot>    []
05:39:50 <lambdabot>  [-2]->
05:39:50 <lambdabot>    [-3]
05:39:50 <lambdabot>  [-2,-1]->
05:39:52 <lambdabot> [3 @more lines]
05:39:54 <lambdabot> forall i e. (Num (i, e), Ix i) => Array i e -> Array i e
05:40:06 <sohum> ...what
05:40:11 <sohum> :t (//)
05:40:12 <Baughn> > join (,)
05:40:13 <lambdabot>   {()->((),())}
05:40:13 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
05:40:21 <Baughn> > join
05:40:22 <lambdabot>   No instances for (Test.SmallCheck.Serial (m (m a)),
05:40:22 <lambdabot>                    GHC....
05:40:24 <sohum> @instances Array
05:40:25 <lambdabot> Couldn't find class `Array'. Try @instances-importing
05:48:20 <voidprayer> excuse me. i hope it is okay to ask yi-editor's problem here. i have a problem while building yi.
05:48:22 <voidprayer> [ 30 of 119] Compiling Yi.Buffer.Basic  ( Yi/Buffer/Basic.hs, dist/build/Yi/Buffer/Basic.o )
05:48:22 <voidprayer> ghc: /usr/lib/ghc-6.10.4/ghc-prim-0.1.0.0/HSghc-prim-0.1.0.0.o: unknown symbol `_GLOBAL_OFFSET_TABLE_'
05:48:22 <voidprayer> Loading package ghc-prim ... linking ... ghc: unable to load package `ghc-prim'
05:48:52 <voidprayer> gentoo friends told me this might be caused by a broken toolchain, but have no solution currently.
05:56:59 <Saizan> voidprayer: does compiling an "hello world" test program work for you?
05:57:24 <voidprayer> Saizan, is there any existing sample? -_-|||
05:57:44 <Saizan> voidprayer: just make a file with "main = print ()" in it
05:58:02 <Saizan> and then "ghc --make thatfile.hs"
05:58:03 <voidprayer> Saizan, thank you very much. i do not know haskell before, and its my first time touch it.
05:58:20 <Saizan> voidprayer: k, welcome here then :)
05:58:52 <voidprayer> only a link warning:  warning: creating a DT_TEXTREL in object.
05:59:08 <voidprayer> and the binary works well.
05:59:30 <Saizan> uhm, never seen that warning before
06:00:05 <voidprayer> Saizan, i forgot to say. I am using a hardened toolchain of gcc
06:01:21 <Saizan> that might be the problem, ghci has its own linker, which is not as robust as ld, so i've had problems with unusual kinds of symbols before
06:01:59 <voidprayer> i see, i will talk to gentoo guys about this.
06:02:04 <voidprayer> thank you.
06:02:09 <Saizan> np
06:02:49 <scree> does anyone know if any work's been done on automatic detection of (potential) stack overflows in haskell?
06:03:15 <sohum> @pl \s -> "Hello " ++ s ++ "!"
06:03:16 <lambdabot> ("Hello " ++) . (++ "!")
06:03:22 <sohum> ...right
06:04:12 <scree> i.e. getting an authoritative "your code runs in bounded stack" as often as possible
06:05:49 <Saizan> voidprayer: btw, the ghc-users mailing list might also be helpful
06:06:29 <copumpkin> scree: not as far as I know
06:06:47 <ivanm> voidprayer: oh, and #ghc
06:07:33 <scree> copumpkin: ok.  seems odd really
06:08:01 <voidprayer> thank you.
06:08:26 <copumpkin> scree: I think it could be helpful, but would be difficult, and most people learn to avoid space leaks (or find them if they do occur) after a while programming haskell
06:13:29 * hackagebot upload: chp 1.5.1 - An implementation of concurrency ideas from Communicating Sequential Processes (NeilBrown)
06:13:29 <scree> copumpkin: sure. I still find the sequence "> f 100" giving "n" and "> f 1000000" giving stack overflow relatively common
06:13:29 <scree> copumpkin: so I guess I'd like an extra level of certainty that a stack overflow isn't hiding somewhere
06:13:29 <scree> copumpkin: it does also appear to be quite hard
06:13:29 <scree> copumpkin: is the lemma "runs in bounded stack using graph reduction" <=> "runs in bounded stack using outermost reduction" true?
06:13:29 <copumpkin> scree: you aren't shelby moore are you?
06:13:40 <scree> copumpkin: no...
06:13:41 <copumpkin> scree: but, I don't know about your question
06:13:58 <scree> copumpkin: ok thanks.  who's shelby moore?
06:14:24 <copumpkin> someone on haskell-cafe who's been writing a lot of stuff about more or less what you're asking on the mailing list
06:14:42 <ivanm> copumpkin: you can actually understand what shelby-moore writes? :o
06:14:44 <copumpkin> more or less as a monologue, which is a little awkward
06:14:58 <ivanm> heh
06:15:10 <copumpkin> ivanm: nope, and I think that if he just took the time to write out a serious proposal rather than a stream of consciousness on a public mailing list, he might get a much better response
06:15:16 <ivanm> especially when [s]he responds to h[im,er]self? :p
06:15:45 <Cale> scree: at least one of those directions is true ;)
06:15:45 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
06:16:03 <scree> Cale: indeed...
06:16:32 * scree will go away and try to formulate some serious proposals
06:16:39 <Cale> Actually, I think we can be reasonably confident about both
06:17:09 <Cale> Oh, but maybe not for a fixed bound
06:17:27 <Cale> which is what you're really after isn't it?
06:17:47 <copumpkin> http://en.wikipedia.org/wiki/Rice's_theorem !!!
06:17:54 <scree> Cale: so, in each case I want a universal bound to exist; the universal bound need not be the same in each case
06:17:54 <copumpkin> (just kidding, but only sort of)
06:18:38 <Cale> You probably have to prove this by induction on the structure of terms.
06:19:50 <scree> Is the heuristic argument: if I'm n deep in a tree and have to repeat a calculation to depth m, then I can only go m+n deep in total, which is still bounded (?)
06:20:09 <scree> that seems like it ought to work, but I don't convince myself very easily
06:20:19 <Cale> But the basic idea should be that if graph reduction reduces some subterm x by entering the scrutinees of k case-expressions, then outermost-first reduction might enter x multiple times, but it will require the same amount of work each time.
06:20:32 <Cale> yeah
06:20:44 <scree> cool
06:21:16 <scree> I think my next step is to formulate some toy languages
06:22:09 <scree> so y'all will probably hear from we again next time I get stuck :)
06:22:16 <Cale> It might be that you don't get a very good bound in some pathological worst case.
06:22:42 <scree> I don't especially care what the finite bound is
06:22:51 <scree> just that it exists
06:22:57 <Cale> Like, it might turn out to be the product over all subterms of the stack depth or something ridiculous like that.
06:23:51 <Cale> But I don't have a very good feel for how outermost-first reduction works with regard to stack space
06:24:31 <scree> It seems sort of obvious that stuff that runs in bounded stack runs in not very much stack (with any type of reduction)
06:25:00 <Cale> hmmm
06:25:01 <scree> but yes, I can't guarantee that weird cases don't exist
06:27:01 <scree> anyway, thanks all
06:35:18 <ivanm> I forget; how does one create a .ps file from latex source?  I generally only produce pdfs...
06:36:35 <fasta> Where are the cabal packages being stored on Windows?
06:36:40 <copumpkin> just use regular latex and then dvips
06:37:12 <dcoutts> fasta: under the per-user cabal dir, like on unix
06:37:24 <ivanm> copumpkin: that's the one, ta
06:37:35 <dcoutts> fasta: or the default global location is prog files\haskell
06:38:41 <fasta> dcoutts: all I see are installed packages, (that is the binary libraries), not the sources.
06:39:13 <fasta> dcoutts: looking in AppData/Roaming/cabal
06:39:29 <dcoutts> fasta: it's there, under packages/$server/
06:39:56 <fasta> dcoutts: ah, right, forgot about that.
06:40:43 <ivanm> copumpkin: uh, plain ol' latex produced a pdf here :s
06:41:10 <copumpkin> try -output-format=dvi
06:41:36 <koeien> i have a program called `pslatex`
06:41:49 <copumpkin> ah, that sounds right too
06:42:10 <ivanm> copumpkin: _still_ produces pdf :s
06:42:18 <copumpkin> then I guess pslatex it is :P
06:42:31 <koeien> ivanm: maybe this is some \usepackage{} in your file
06:42:40 <ivanm> koeien: hmmm...
06:43:05 <ivanm> bah, didn't notice that I had unconditionally used pdftex as the option to graphicx :s
06:45:25 <copumpkin> :)
06:45:49 * fasta gets urge to shoot people specifiying exact base depends. 
06:46:25 <ivanm> fasta: as in == 4.0.etc. ?
06:46:27 <fasta> specifying*
06:46:29 <fasta> ivanm, yes
06:47:00 <ivanm> copumpkin: I had forgotten that I needed pdfpages for the pre-print, and also graphicx since I was attaching some pdfs at the end... :s
06:47:11 <copumpkin> ah
06:47:15 <ivanm> fasta: well, don's approach of using "base < 10" isn't that great either... :s
06:47:17 <copumpkin> why do you need .ps in the first place?
06:47:25 <sohum> ivanm: what about pdftops?
06:47:29 <ivanm> copumpkin: in case I stuff up the pdf apparently ;-)
06:47:49 <fasta> ivanm, it's really because everything is setup to be pessimistic.
06:47:49 <ivanm> "A ps file is NOT mandatory for Word submissions, but needed for LaTex submissions because of the extremely low percentage of properly created pdf from tex to pdf."
06:48:11 <copumpkin> o.O
06:48:11 <sohum> what if you're using xelatex?
06:48:20 <copumpkin> xelatex is awesome
06:48:25 <copumpkin> and I've never had any issues with pdfs and latex
06:48:43 <ivanm> copumpkin: *shrug* apparently they're picky
06:48:47 <copumpkin> weird :)
06:48:58 <sohum> I don't think xelatex /can/ create ps
06:49:00 <koeien> copumpkin: what makes it awesome, or should i rtfm?
06:49:29 <copumpkin> koeien: native unicode/truetype/opentype support, mostly
06:49:36 <copumpkin> can do all sorts of fun things with the typography
06:49:43 <copumpkin> as well as just use regular CM fonts if you prefer that
06:49:46 <sohum> koeien: and ligatures and other typographical awesomeness
06:50:03 <sohum> (which I haven't figured out how to use yet, but :) )
06:50:11 <copumpkin> there are lots of examples
06:50:14 <koeien> cool, i'll check it out
06:50:20 <sohum> I know, I don't mean mechanically
06:50:28 <copumpkin> it's also a must if you want to typeset papers using non-roman scripts
06:50:34 <copumpkin> the cjk module for regular latex is a pain
06:50:39 <sohum> I mean, when would I use these typographical stuff from a design perspective
06:50:43 <copumpkin> ah
06:50:45 <koeien> copumpkin: yeah, i may want chinese characters
06:51:22 <copumpkin> another thing is that it obviously supports non-BMP characters too
06:51:42 <koeien> yeah, that's a must-have ;)
06:51:52 <copumpkin> lol, it was helpful for me
06:52:34 <ivanm> preflex: seen quicksilver
06:52:34 <preflex>  quicksilver was last seen on #haskell 2 hours, 39 minutes and 24 seconds ago, saying: ]yup
06:52:39 <sohum> I haven't been able to get xelatex and the beton fonts to work nicely together, though
06:54:27 <sohum> more accurately, beton and fontspec
06:54:36 <sohum> which is more than a tad annoying
07:01:15 <yairchu> @pl (\(a, b, _) -> blah a b)
07:01:16 <lambdabot> (line 1, column 8):
07:01:17 <lambdabot> unexpected ","
07:01:17 <lambdabot> expecting letter or digit, operator or ")"
07:01:17 <lambdabot> ambiguous use of a non associative operator
07:01:36 <yairchu> @pl \(a, b, _) -> blah a b
07:01:37 <lambdabot> (line 1, column 7):
07:01:37 <lambdabot> unexpected ","
07:01:37 <lambdabot> expecting letter or digit, operator or ")"
07:01:37 <lambdabot> ambiguous use of a non associative operator
07:01:50 <Saizan_> yairchu: @pl doesn't understand 3-tuples
07:02:05 <yairchu> oh, thanks :)
07:02:22 <copumpkin> it's not like there are any convenience functions for them anyway, even if it did understand them
07:03:38 <Saizan_> yeah, i mostly meant the rewrite engine, the parser reflects that, though a more explicit error message wouldn't make people think they just have some syntax wrong
07:09:16 <sieni> argh, qthaskell's build.bat is horribly broken
07:09:44 <sieni> it does not abort if something fails and then afterwards you are left to wonder if something went wrong
07:10:41 <sieni> can someone actually build qthaskell on windows?
07:14:03 <sior|oifig_> so one can write map (+1) for (\x -> x + 1), but (-1) doesn't play nice, but is there a nice way to show decrement without (\x -> x - 1)
07:16:01 <copumpkin> :t subtract
07:16:03 <lambdabot> forall a. (Num a) => a -> a -> a
07:16:03 <copumpkin> sadly
07:16:53 <sior|oifig_> that's a bit disappointing =p but oh well
07:17:44 <sior|oifig_> Also, random question, CSP and CSS, there's a simulation relationship but I can't remember wehat it is, anyone know?
07:17:50 <sior|oifig_> i know they aren't bisimulatable
07:19:37 <Cale> sior|oifig_: another option (+(-1))
07:20:06 <Cale> or even...
07:20:11 <Cale> > (-1+) 5
07:20:12 <lambdabot>   4
07:21:49 <zygoloid> Cale: that's... that's horrible! :)
07:22:15 <int-e> Cale: try it in hugs
07:22:25 <sohum> @let (--) = subtract 1
07:22:27 <lambdabot>   Parse error: SemiColon
07:22:37 <sohum> what?
07:22:40 <Cale> ahaha
07:22:40 <int-e> no redefining comments
07:22:43 <Cale> unexpected )
07:22:45 <sohum> oooh
07:22:49 <sohum> hhahaha
07:22:55 <sohum> didn't expect that
07:23:01 <Cale> Hugs> (-1+) 5
07:23:02 <Cale> ERROR - Syntax error in expression (unexpected `)')
07:23:16 <Cale> So the question becomes whose parser is broken :)
07:23:45 <int-e> Cale: hugs' I believe. Btw, ghc and hugs also disagree on (+ -1) 5
07:25:49 <sohum> I wonder if ghc distinguishes...
07:25:54 <sohum> @let (---) = subtract 1
07:25:54 <lambdabot>   Parse error: SemiColon
07:25:57 <sohum> nope.
07:26:20 <copumpkin> @let (â) = (-) in map (â5) [1..10]
07:26:21 <lambdabot>   Parse error: KW_In
07:26:36 <copumpkin> I could've sworn that used to work
07:26:41 <copumpkin> oh whoops
07:26:44 <copumpkin> > let (â) = (-) in map (â5) [1..10]
07:26:45 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4,5]
07:27:02 <copumpkin> @let (â) = (-)
07:27:03 <lambdabot>  Defined.
07:27:05 <fasta> Now release a very interesting package with a license which states that you cannot modify it with very interesting functionality that only works in Hugs ;)
07:27:06 <sohum> :t (-)
07:27:07 <lambdabot> forall a. (Num a) => a -> a -> a
07:27:22 <sohum> yay unicode
07:27:35 <lilac> > let (--+) = (*) in 4--+5
07:27:37 <lambdabot>   20
07:27:43 <lilac> @let (--+) = (*)
07:27:44 <lambdabot>  Defined.
07:27:53 <copumpkin> > let (???????????????) = (+) in 5 ??????????????? 6
07:27:55 <lambdabot>   11
07:29:44 <Cale> sohum: It's not a good idea to trust lambdabot when determining what ghc is okay with parsing-wise
07:29:52 <burp> @let â¥ = odd . length
07:29:52 <lambdabot>   Parse error: VarSym "\9829"
07:30:03 <copumpkin> needs moar parentheses
07:30:05 <Cale> sohum: because lambdabot has its own parser which is applied before ghc gets it
07:30:21 <medfly> almbdabot uses Hascale
07:30:26 <Cale> heh
07:30:26 <copumpkin> @let (â¥) = odd . length
07:30:27 <lambdabot>  <local>:6:0:
07:30:28 <lambdabot>      Multiple declarations of `L.â¥'
07:30:28 <lambdabot>      Declared at: <local>...
07:30:31 <copumpkin> aw
07:30:32 <Cale> lol
07:30:40 <burp> > (â¥) "Haskell"
07:30:40 <copumpkin> :t (â¥)
07:30:41 <lambdabot>   True
07:30:41 <lambdabot> Not in scope: `???'
07:30:46 <Cale> Multiple declarations of love!
07:30:57 <copumpkin> gotta love how some parts of lambdabot know unicode and others don't
07:31:20 <Cale> Yeah. All I can say is patches welcome ;)
07:31:25 <burp> I already defined it in lambdabots query..
07:31:51 <burp> > (â¥) "Hugs"
07:31:53 <lambdabot>   False
07:31:53 <copumpkin> one day I shall submit a patch! for something, somewhere
07:32:02 <medfly> haha
07:32:13 <ziman> > (â¥) "GHC"
07:32:14 <lambdabot>   True
07:33:41 <zygoloid> > all (â¥) ["Haskell", "GHC", "C++"]
07:33:42 <lambdabot>   True
07:34:19 <lilac> one of these things is not like the others?
07:34:52 <Cale> clearly the neural network needs some more tuning
07:34:53 <koeien37> yes, one is an implementation of a programming language, the others arent ;)
07:35:01 <cathper> > (â¥) "HC#"
07:35:02 <lambdabot>   True
07:35:08 <cathper> Damn.
07:35:12 <cathper> > (â¥) "C#"
07:35:14 <lambdabot>   False
07:35:28 <zygoloid> koeien37: one of them is 7 letters long, the others aren't? :)
07:35:46 <Cale> That's more relevant given the definition of (â¥)
07:36:28 <Cale> > map (â¥) [replicate k 'A' | k <- [0..]]
07:36:29 <jelly12gen> sad, the irc bot source doesnt compile
07:36:30 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
07:36:31 <jelly12gen> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
07:36:38 <jelly12gen>     Ambiguous type variable `b' in the constraint:
07:36:49 * Cale bets exception library switch problem
07:36:58 <jelly12gen>       `Exception b' arising from a use of `catch' at bot.hs:45:17-61
07:37:02 <Cale> yep :)
07:37:02 <jelly12gen> probaly that :D
07:37:03 <koeien37> yes
07:37:05 <zygoloid> we have winner
07:37:16 <sm> copumpkin: why not today, and now!
07:37:19 <saml> i 'd like to thank zygoloid
07:37:25 <copumpkin> :o
07:37:29 <sm> carpe diem!
07:37:43 <Cale> jelly12gen: Replace (\e -> ...) with (\(SomeException e) -> ...)
07:37:48 <sm> I will if you will
07:38:00 <koeien37> or s/Exception/OldException ?
07:38:09 <Cale> yeah, that's another option
07:38:24 <jelly12gen> aha got it
07:38:28 <Cale> unfortunately my web browser is not available to look at the source of the bot, but that should do it
07:38:39 * Cale is upgrading Ubuntu :)
07:38:45 <koeien37> to 9.10?
07:38:48 <Cale> yeah
07:40:14 <roconnor> Cale: if it break, you can always switch to nixOS :)
07:40:18 <roconnor> breaks
07:40:32 <Cale> jelly12gen: The new exception library is a little more syntactically annoying, but lets you add your own new exception types, so it's mostly worthwhile.
07:40:50 <jelly12gen> ok
07:41:03 <jelly12gen> first learn how the bot works :)
07:41:05 <Cale> Someone should probably edit the page :)
07:41:08 <sohum> Cale: ah, fair enough
07:43:17 <jelly12gen> does lambdabot log #haskell ?
07:43:33 <Cale> I love how after installing every single package related to TeX, it runs the same damn commands rather than waiting and running them all at the end.
07:43:52 <Cale> It doesn't, but another bot does.
07:44:03 <jelly12gen> ooh is that source around?
07:44:10 <Cale> (though last I heard there was some problem with that)
07:44:40 <Cale> I'm not sure it's in Haskell.
07:44:46 <jelly12gen> i was just looking for something to log a channel but not an irc client , so i thought of making it in haskell :)
07:45:23 <fasta> Can someone shine light on Cabal mystery error messages? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12011#a12011
07:45:32 <Cale> Yeah, the IRC bot from "roll your own" there should be good. Just have it join a channel and save everything into a file.
07:45:50 <fasta> roconnor, are you using nixOS?
07:45:53 <jelly12gen> Cale: the problem is the nicks though
07:45:58 <roconnor> fasta: yep
07:46:06 <Cale> jelly12gen: They should be part of each line.
07:46:10 <koeien37> roconner: isn't everything statically linked?
07:46:18 <roconnor> koeien37: nope, not at all.
07:46:20 <mreh> does anyone here do mathematica?
07:46:24 <dcoutts> fasta: the "dependency base -any" really means "I want an installed version of base, not one from hackage".
07:46:28 <jelly12gen> Cale: yeah the too log ip, dunno if i make ppl happy with that
07:46:31 <Cale> mreh: I do.
07:46:32 <koeien37> roconnor: good. i don't know why i thought this
07:46:35 <dcoutts> fasta: it looks like your installed base is broken
07:46:41 <dcoutts> fasta: check with ghc-pkg check
07:46:51 <roconnor> koeien37: well, it is set up in such a way that things are almost effectively statically linked.
07:47:02 <roconnor> koeien37: none the less shared libraries are shared.
07:47:02 <fasta> dcoutts: returns an empty output
07:47:18 <dcoutts> fasta: what ghc version is this?
07:47:31 <roconnor> koeien37: it would be interesting to compare statically linked and dynamically linked versions of the same system.
07:47:31 <fasta> dcoutts: the same as earlier.
07:47:45 <fasta> 6.12.0.20091010
07:48:11 <roconnor> koeien37: which would be smaller, removing unneeded code by statically linking, or sharing code with dynamic linking?
07:48:28 <koeien37> roconnor: i would prefer dynamic linking in most cases
07:48:40 <dcoutts> fasta: can you paste the output of ghc-pkg list
07:48:41 <koeien37> but for other reasons
07:49:12 <roconnor> koeien37: someone said that ELF is optimized for dynamic linking, so perhaps to be fair you'd want to use a different binary format for the staticly linked version.
07:49:28 <roconnor> koeien37: what are the reasons to prefer dynamic linking?
07:49:41 <roconnor> koeien37: I fear the reasons may be lost with nixos
07:49:55 <koeien37> mostly security/preventing code duplication and sanity
07:50:55 <roconnor> koeien37: I don't follow.  Sure we don't want to share code duplication at the source level, but I don't see way we care at the object code level (other than perhaps space reasons as I was saying).
07:51:07 <roconnor> koeien37: I don't really understand security
07:51:28 <roconnor> koeien37: and normally dynamic libraries are considered to cause insanity (aka DLL hell).
07:51:57 <koeien37> roconnor: that depends. if you have a "rolling release" system, this might be true, but i prefer stable releases with some time in between
07:52:24 <koeien37> if you upgrade an often-used library, you have to reinstall lots of software?
07:52:59 <roconnor> koeien37: yes, under nixos upgrading a library will force a resintallation of all software that uses that library.
07:53:21 <roconnor> well, you can keep the old software, but it will continue to use the old library.
07:53:23 <koeien37> i might try it in a VM sometime
07:54:01 <roconnor> koeien37: people on #nixos seemed to think it was unusual to not be running nixos in a vm.
07:54:14 <roconnor> I found that kinda surprising.
07:54:22 <koeien37> you use it as your primary system?
07:54:25 <roconnor> yes
07:54:35 <koeien37> so it is at least somewhat stable ;)
07:54:35 <roconnor> it is running on my bare laptop.
07:54:59 <roconnor> well, if your upgrade is totally borked you just rollback.
07:55:05 <roconnor> upgrading doesn't delete anything.
07:55:40 <roconnor> all packaged software is immutable.
07:56:51 <roconnor> when I did a upgrade last week
07:56:52 <fasta> roconnor, but that doesn't defend against maintainers destroying your grub configuration. E.g. hd0/hd1 differences.
07:57:03 <roconnor> I spent a bit of time going back and forth between the two configurations.
07:57:20 <koeien37> i don't like the fact that there are continuous upgrades though :(
07:57:44 <roconnor> koeien37: I don't think I'd say there are continuous upgrades
07:57:48 <roconnor> there are stable releases.
07:58:05 <roconnor> however, it is currently recommended to follow trunk
07:58:05 <koeien37> good
07:58:12 <roconnor> which is effectively a cotninuous upgrade
07:58:14 <koeien37> what about security?
07:58:25 <koeien37> i guess that is not much of a problem since there are not *that* many packages
07:58:33 <fasta> koeien37, consumers don't have any meaningful security anyway.
07:58:37 <roconnor> I think that is a temporarly phenomon due to nixOS being young and progressing somewhat quickly.
07:58:44 <koeien37> roconnor: oh sure
07:59:01 <fasta> koeien37, even Ubuntu does its security stuff incorrectly.
07:59:06 <Cale> What is the idea behind nixOS?
07:59:13 <roconnor> fasta: you are talking about say upgrading grub to say grub 2, for example?
07:59:13 <koeien37> fasta: in what respect?
07:59:28 <roconnor> koeien37: what do you mean by security?
07:59:36 <roconnor> oh, you mean security upgrades?
07:59:41 <koeien37> roconnor: well, mostly that packages with known vulnerabilities get upgraded
08:00:05 <roconnor> ya, I suppose they ought to have branches off their stable relases for security upgrades.
08:00:05 <fasta> roconnor, no, I am talking about installing a new kernel and that the maintainer modifies your grub file incorrectly. Ubuntu used to do that two years ago.
08:00:39 <fasta> koeien37, well, keeping secrets and protecting data, which is what security is all about.
08:00:47 <roconnor> fasta: Hmm, I'm not sure I understand.  Perhaps I should note that each time you do a system update, you get a new grub entry.
08:00:50 <saml> hey, would you use selenium for your website?
08:00:55 <roconnor> fasta: and you can always boot into an older entry.
08:00:57 <saml> haskell website
08:01:11 <maartenm> what do you mean, to do automated tests?
08:01:11 <koeien37> saml: sure, why not? the back-end doesn't matter for selenium right?
08:01:17 <saml> oh that was surprizingly off-topic. sorry
08:01:32 <roconnor> Cale: nixOS is a distribution that uses entirely the nix package manager, a "purely functional" package manager
08:01:43 <Cale> roconnor: ah, okay :)
08:01:54 <Cale> roconnor: So it's still a linux kernel presumably?
08:02:00 <maartenm> some backends allow you to generate selenium tests from their innards though
08:02:02 <fasta> roconnor, yes, that's what most OSs do these days.
08:02:07 <roconnor> ``Nix is a purely functional package manager. It allows multiple versions of a package to be installed side-by-side, ensures that dependency specifications are complete, supports atomic upgrades and rollbacks
08:02:59 <roconnor> fasta: so I guess I'm not sure how installing a new kernel would break anything wrt to grub.
08:03:28 <koeien37> roconnor: easiest/best way is to install fedora and then build nixos?
08:03:44 <Cale> Hmm, that's interesting. How can it ensure that dependency specifications are complete? Is the package manager integrated with the compiler and linker or something?
08:03:47 <roconnor> koeien37: I'm not sure.
08:03:50 <fasta> roconnor, I suppose it doesn't anymore indeed.
08:03:52 <roconnor> koeien37: I used a nixOS live CD.
08:03:58 <wferi> Hi! I've got an HDBC question, hope somebody can answer it....
08:04:01 <wferi> print (fromSql $ SqlString "\245" :: B.ByteString)
08:04:10 <wferi> outputs "\195\181"
08:04:25 <roconnor> koeien37: actually I had quite a bit of trouble getting my network working on the live CD, and installing without a network is almost impossible.
08:04:27 <fasta> roconnor, nixOS is nice though. In general everything which gives us more solid systems, is.
08:04:35 <wferi> Looks like it does a latin1->utf8 conversion while converting to bytestring
08:04:51 <koeien37> roconnor: ok, i'll try it in a VM, and if it works, i'll try it on my spare laptop :)
08:04:55 <Cale> wferi: curious
08:05:04 <wferi> Is this expected? Or is this a bug in the unofficial mysql backend?
08:05:10 <roconnor> fasta: the biggest downside is that is is young, and I have to learn a lot about linux stuff to configure things when they don't work properly.
08:05:16 <wferi> Or in HDBC itself?
08:05:28 <fasta> roconnor, yes, and probably a lack of fast mirrors.
08:05:33 <Cale> wferi: I'm not sure. I would start by looking at the implementation of fromSql
08:05:33 <roconnor> fasta: I also have to package any missing software that I might want.
08:05:36 <jelly12gen> ok, hmm i dont understand how i could display getCurrentTime as a string
08:05:49 <roconnor> fasta: heh, fast mirrors hasn't been a big problem for me :P
08:05:51 <fasta> roconnor, I can only get Ubuntu with about 300KB/s for example.
08:06:01 <wferi> Yeah, that's what I'll do unless somebody provides a definite answer.
08:06:05 <Cale> wferi: The general handling of text encodings is presently a bit of a mess which 6.12 should start to clean up.
08:06:15 <jelly12gen> or really how could i show time with haskell
08:06:17 <fasta> roconnor, if they would have a decent system, they would direct me to the fastest one automatically.
08:06:23 <wferi> Cale: or mess it up even more...
08:06:37 <Cale> wferi: Heh, yeah, possibly :)
08:06:54 <wferi> It can't be much worse, anyway.
08:06:57 <Cale> wferi: But at least there will be a sensible answer about where it should be handled.
08:07:03 <roconnor> fasta: actually the nixOS central build system (hydra) is only used to get prebuilt binaries.
08:07:11 <wferi> I'm looking forward to it.
08:07:20 <wferi> So let's see that fromSql thingie...
08:07:20 <zygoloid> fasta: "only [...] 300KB/s"? i'm lucky if i get 80KB/s :(
08:07:22 <roconnor> fasta: everything else is downloaded by source from wherever the project is.
08:07:42 <roconnor> fasta: and everything that hydra builds can also be built from source.
08:08:12 <Cale> wferi: hmm, is that SqlString taking a plain String parameter?
08:08:22 <fasta> roconnor, sounds great in theory. Momentum is really a bad thing.
08:08:29 <wferi> Cale: Yes, AFAIK
08:08:37 <roconnor> fasta: what do you mean by Momentum?
08:08:49 <Cale> wferi: String is capable of representing Unicode code points directly
08:09:03 <fasta> roconnor, lots of inferior approaches have lots of users and thus infrastructure, while this system is in principle better.
08:09:12 <wferi> Cale: sure. That's what I'd like to see.
08:09:31 <roconnor> fasta: ya, and it is hard to really recommend nixOS without it becoming more mature first.
08:09:32 <koeien37> fasta: yep. but momentum is also a good thing, because it gives maturity ;)
08:09:56 <wferi> But I got confused, and distilled this problem as the root of my confusion.
08:09:57 <roconnor> koeien37: :D
08:10:03 <Cale> wferi: So the \245 there is the actual unicode Char, and then I suppose that when you convert to ByteString, fromSql is probably being smart and doing a UTF-8 representation in order not to lose information.
08:10:04 <fasta> koeien37, well, Ubuntu has momentum, I just wouldn't call it mature ;)
08:10:16 <koeien37> fasta: Ubuntu releases every 6 months. bad idea imho
08:10:27 <fasta> The release notes list for karmic is really _way_ too long.
08:10:29 <koeien37> LTS releases should be better (no experience myself)
08:10:29 <Cale> (because ByteString doesn't allow characters larger than a byte)
08:10:44 <roconnor> I'm using nixOS because I beleive in the approach and figure it needs trailblazers if it is going to get off the ground.
08:10:56 <hdevalence> can anyone here reccommend a good and accessible book on category theory?
08:10:56 <wferi> Cale: Hmm, yes, that might explain this behaviour.
08:11:00 <roconnor> and I know enough about linux that, with some help, I can get it to do what I want.
08:11:12 <roconnor> heck, I'm even running with encrypted root under nixOS.
08:11:18 <Cale> hdevalence: Steve Awodey's text
08:11:28 <koeien37> roconnor: yes. although i too believe in noobfriendliness, it might not be best to start from that
08:11:29 <Cale> hdevalence: called simply "Category Theory"
08:11:41 <fasta> roconnor, ok, you get bonus points for that.
08:11:52 <roconnor> koeien37: definitely not noobifrendly yet, but I think it will get there.
08:12:00 <Cale> hdevalence: I would link you to a pdf on my webserver, but that's probably down atm. I saw a link on reddit the other day. If you search for Awodey you should find it.
08:12:22 <koeien37> roconnor: not a problem for me, but i like to be able to be noob with respect to my system. i understand fully that this is not a focus at all
08:13:31 <hdevalence> how frustrating
08:13:36 <hdevalence> it's not in the library
08:13:44 <Cale> hdevalence: It's specifically designed to be somewhat more accessible to nonmathematicians by avoiding unnecessary prerequisites, and developing the most important examples internally to the book.
08:14:03 <Cale> hdevalence: There's a nice PDF online
08:14:39 <hdevalence> yes, but a book is more convenient
08:14:41 <Cale> (I'd get you a link, but I'm upgrading my OS and so my web browser is not installed at the moment)
08:15:35 <hdevalence> thanks for the tip
08:15:39 <hdevalence> have to go to class
08:17:35 <Pellwurst> can somebody help me with the handling of a monad example (http://pellwurst.pastebin.com/mfa3ed03)? i need an example for writing in the memory....
08:19:49 <koeien37> Pellwurst: a bit more specific? what is your problem/question?
08:20:15 <koeien37> you probably want to add   "import Prelude hiding ((>>=), return)"    at the top
08:20:37 <koeien37> these functions are already predefined, so their names will clash if you try to use them
08:20:44 <jelly12gen> hmmi am confused, isnt there a simple way to get the time of the clock and put it in a String
08:20:53 <Pellwurst> koeien37: i don't know how to write into the memory and read that afterwards
08:21:23 <koeien37> are you reading some tutorial or text?
08:22:36 <Pellwurst> koeien37: it's a lesson in one of my courses and the code has been given to us
08:22:42 <koeien37> jelly12gen: import System.Time; main = getClockTime >>= print; -- seems to work for me
08:22:48 <Pellwurst> now i'm trying to understand how to use it
08:22:49 <Cale> jelly12gen: Sure, import Data.Time and run getCurrentTime, and then apply show to the result.
08:22:57 <jelly12gen> Cale: yeah but that's IO
08:23:04 <Cale> jelly12gen: of course it is
08:23:06 <koeien37> jelly12gen: yep, that's the point!
08:23:14 <jelly12gen> i want it to be a string :(
08:23:45 <koeien37> Pellwurst: i see. do you understand some of the code? the purpose?
08:23:53 <Cale> jelly12gen: If you want a String value which is always the current time, you could say "This string is the current time, just imagine it." or something. But the time changes, and string values do not.
08:24:24 <jelly12gen> Cale: ok, i think i am not clear enough
08:24:35 <Pellwurst> koeien37: we've just started with monads and all that stuff and i'm beginning to have an idea what it means :P
08:24:36 <jelly12gen> i want the `time` ++ "mystring"
08:24:52 <koeien37> Pellwurst: good. this is an example of a monad.
08:25:10 <Cale> do t <- getCurrentTime; return (show t ++ "mystring)
08:25:20 <jelly12gen> hmm ok
08:25:25 <Cale> er, with the "
08:25:28 <jelly12gen> oh wait
08:25:32 <Cale> that I obviously missed there
08:25:34 <jelly12gen> :t show
08:25:35 <lambdabot> forall a. (Show a) => a -> String
08:25:37 <Cale> the result is an IO String
08:25:37 <Pellwurst> koeien37: i just know how to read in a new reference
08:25:42 <jelly12gen> yeah
08:26:00 <jelly12gen> Cale: i haven't done much haskell for months
08:26:01 <Pellwurst> koeien37: but what is the syntax for writing into one and reading it afterwards
08:26:20 <koeien37> Pellwurst: the top part is the definition of our monad. the last part is an example of usage of said monad
08:26:47 <Pellwurst> koeien37: understood that, yes
08:27:19 <dfrey|work> Let's say I have a file that consists of a bunch of lines in the format "Color x y" for example "Red 12 35".  I have defined a color data type like this data Color = Red | Green | Blue.  How would I parse a line of this file into a tuple :: (Color, Int, Int) using parsec?  I have sort of figured out how to parse it into 3 strings and convert the strings into the types I want, but it seems like there should be a more direct me
08:27:26 <koeien37> Pellwurst: good. then we are working with type Mem = ST [String]. This means that we are working with a state consisting of a list of strings
08:27:42 <koeien37> Pellwurst: do you understand the newRef function?
08:28:00 <jelly12gen> Cale: well actually that doesnt work here
08:28:47 <Pellwurst> the list of strings should be our memory.... so it just adds a new reference (a new element to the list of strings) and returns the memory and the reference itself
08:28:50 <koeien37> dfrey|work: you could use parsec, but this seems overkill.
08:28:56 <byorgey> @seen ivanm
08:28:56 <lambdabot> Unknown command, try @list
08:29:03 <byorgey> preflex: seen ivanm
08:29:04 <preflex>  ivanm was last seen on #haskell 1 hour, 36 minutes and 30 seconds ago, saying: preflex: seen quicksilver
08:29:04 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:29:21 <dfrey|work> koeien37: Yes, it's probably overkill, but I want to learn a bit about how parsec works.
08:29:21 <koeien37> Pellwurst: it returns the reference (an integer.) the state is updated by concatenating an empty string to the current state
08:29:43 <koeien37> dfrey|work: do you have anything so far?
08:29:44 <Pellwurst> ok
08:29:51 <Cale> dfrey|work: start by writing a parser which parses a value of type Color
08:30:19 <Pellwurst> koeien37: so i should be able to read in that empty reference with readRef....
08:30:22 <byorgey> @tell ivanm you're welcome!  Have you actually tried it out yet?  Let me know if you have suggestions for feaatures or improvements.
08:30:23 <lambdabot> Consider it noted.
08:30:24 <koeien37> Pellwurst: ST (\s -> (length s, s ++ [""])) means a computation in the ST monad that returns "length s", and modifies the state to be "s ++ [""] "
08:30:29 <Cale> dfrey|work: (by checking for the appropriate string, and returning the appropriate value of type Color)
08:30:30 <koeien37> Pellwurst: yes. correct.
08:30:51 <Pellwurst> koeien37: thats the comment, i added to the code
08:30:52 <dfrey|work> Cale: I figured that would be the first step.  What would the type of a function like that be?
08:30:54 <koeien37> Pellwurst: so readRef >>= (\newRefId -> readRef newRefId)    is an example of a program in this monad
08:31:09 <Cale> dfrey|work: Something like  Parser Color
08:31:18 <koeien37> Pellwurst: yep. this works, doesn't it? It returns the contents of the new reference, which is an empty string
08:31:28 <Pellwurst> yes
08:31:34 <jelly12gen> Cale: it was me being the problem
08:31:42 <Cale> dfrey|work: (parsec has lots of extra parameters in the types these days though, so depending on which libraries you're importing...)
08:31:51 <Pellwurst> but i can't figure out how to write in a reference and read it afterwards
08:32:21 <Pellwurst> i will need a new reference as well....
08:32:31 <koeien37> Pellwurst: there is another function, writeRef. You can use it as    writeRef refId "newValue"
08:33:01 <koeien37> Pellwurst: try, for example,    newRef >>= (\refId -> writeRef refId "Hello world!" >>= (\_ -> readRef refId))
08:33:51 <Cale> hmm, is this like the original paper's version of ST or something? :)
08:34:08 <Pellwurst> koeien37: hmm... i am afraid that works *G*
08:34:09 <koeien37> Cale: maybe, this is homework, so it could very well be
08:34:20 <koeien37> Pellwurst: more importantly, do you understand how it works?
08:34:30 <Pellwurst> give me a sec :)
08:34:49 <Cale> It's probably easier to read if you translate it to do-notation first.
08:35:21 <koeien37> Cale: that is true, but 1. >>= is not Prelude's >>=, and 2. i think learning this chaining more explicitly using >>= is better. do you agree?
08:35:37 <Cale> oh, okay
08:36:06 <Cale> I actually don't have much of a preference for which way to teach first.
08:36:28 <Cale> You can start from do-notation, or from >>= or from fmap/return/join :)
08:37:04 <koeien37> hmm, i myself found the join somewhat strange in the beginning
08:37:17 <Pellwurst> koeien37: newRef returns the refId?
08:37:18 <Cale> It's strange for monads like this
08:37:47 <koeien37> Cale: yeah, the kind i was subjected to in the beginning :)
08:38:14 <koeien37> Pellwurst: yes, it changes the state and returns a Ref. I can use this Ref with the bind function >>=
08:38:29 <koeien37> this makes sense if you look at the type of >>=
08:38:31 <dfrey|work> Cale: It seems to me that I need something that consumes a String and generates a Color, but I don't understand the building blocks that are used to create that.
08:39:04 <Cale> dfrey|work: something like  (do string "Red"; return Red)  is a good first building block :)
08:39:06 <fasta> Can anyone interpret this great cabal-install error message?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12012#a12012
08:39:18 <Cale> dfrey|work: Of course, you can also write that (string "Red" >> return Red)
08:39:40 <Cale> dfrey|work: and then you need to combine parsers for each of the cases
08:39:46 <roconnor> @type string
08:39:47 <lambdabot> Not in scope: `string'
08:39:51 <roconnor> @hoogle string
08:39:52 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
08:39:52 <lambdabot> Text.ParserCombinators.ReadP string :: String -> ReadP String
08:39:52 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
08:39:58 <Pellwurst> koeien37: the part i don't understand is "(\_ -> readRef refId)".... why do i need a lambda expression for that?
08:40:08 <koeien37> koeien37: what is the result of writeRef ?
08:40:14 <koeien37> Pellwurst: *
08:40:25 <fasta> It says the package is there, but it is not "available". It would be nice if it said why it was not "available" or how to make it "available".
08:40:39 <Pellwurst> seems to me that there is no result :/
08:40:45 <koeien37> Pellwurst: there is, a ()
08:40:50 <Cale> Pellwurst: The result is an empty tuple :)
08:41:10 <koeien37> Pellwurst: this is a type that has only one value, an empty tuple   (and a nonending computation, but forget this for now)
08:41:12 <roconnor> do {"Red" <- string "Red"; return Red } -- ^_^
08:41:13 <Cale> So that could also have been written \() -> ...
08:41:15 <koeien37> :t ()
08:41:16 <lambdabot> ()
08:41:17 <jmcarthur_work> i would teach from either join or extend, personally
08:41:47 <Pellwurst> ok, and thats the "input" for the lambda expression
08:41:50 <Cale> Oh, there's another way too.
08:41:52 <koeien37> Pellwurst: yes
08:41:54 <Pellwurst> if you can call that an input
08:41:56 <Cale> return and (<=<)  :)
08:42:05 <jmcarthur_work> yeah, i was about to say kleisli would be a nice way
08:42:10 <Pellwurst> ok
08:42:11 <jmcarthur_work> makes the laws very intuitive
08:42:15 <Cale> That way has the advantage that the laws are simple and natural, yeah
08:42:27 <Pellwurst> think i got it now
08:42:31 <koeien37> Pellwurst: There is normally also a function (>>), with definition m >> n = m >>= (\_ -> n)
08:42:44 <jmcarthur_work> i don't like >> for teaching monads
08:43:05 <Pellwurst> koeien37: yes, i recognize that function from IO
08:43:06 <koeien37> that makes them too monoidic? :)
08:43:13 <koeien37> Pellwurst: it is not an IO function per se
08:43:26 <koeien37> > Just 37 >> return 42
08:43:27 <lambdabot>   Just 42
08:43:37 <Cale> > [1,2] >> [3,4,5]
08:43:39 <lambdabot>   [3,4,5,3,4,5]
08:43:42 <koeien37> > Nothing >> return 42
08:43:44 <lambdabot>   Nothing
08:43:45 <Pellwurst> yes but you can use it with the IO monad, cant you?
08:43:47 <Cale> yes
08:43:51 <koeien37> you can use it with any Monad
08:44:00 <Cale> (and it's monads like IO where it makes the most sense)
08:44:00 <Pellwurst> yepp
08:44:02 <koeien37> including IO
08:44:07 <Pellwurst> ok
08:44:52 <Pellwurst> koeien37: thanks very much for your help.... i would like to stay but my battery is low ^^
08:45:01 <koeien37> Pellwurst: good luck with your homework
08:45:04 <jmcarthur_work> Cale, well, i use *> and <* a lot in applicative code, though
08:45:04 * Cale wonders how many times mktexlsr has run since he started upgrading Ubuntu.
08:45:09 <jmcarthur_work> non IO code, i mean
08:45:46 <Cale> They really couldn't come up with a way to wait until all the TeX packages had been installed to run that?
08:45:46 <jmcarthur_work> > [1,2] *> [3,4,5]
08:45:48 <lambdabot>   [3,4,5,3,4,5]
08:45:52 <jmcarthur_work> > [1,2] <* [3,4,5]
08:45:53 <lambdabot>   [1,1,1,2,2,2]
08:46:20 <koeien37> yeah >=> makes more sense to learn monads than >>= maybe
08:46:34 <jmcarthur_work> <=< more than >=>  :)
08:46:37 <koeien37> erm, <=<
08:46:41 <koeien37> yes, thanks
08:46:47 <jmcarthur_work> =<< more than >>=, imo
08:47:09 <Cale> But it depends which monads you're interested in.
08:47:12 <jmcarthur_work> except for certain monads
08:47:15 <jmcarthur_work> like IO
08:47:17 <jasonmay> is there a library I can look at for getting the hostname of your computer in haskell?
08:47:24 <jmcarthur_work> but i hate teaching IO as an early monad
08:47:45 <koeien37> jmcarthur_work: yes. i agree
08:48:02 <jmcarthur_work> i prefer to emphasize the declarative aspects of monads and that they are far more general than mere sequential concepts
08:49:18 <jmcarthur_work> although there is an element of sequencing in the fact that <=< is not commutative
08:49:34 <jmcarthur_work> in general
08:49:42 <koeien37> well, not all groups are commutative either
08:49:53 <Cale> Well, it can't be, because the types wouldn't line up ;)
08:50:17 <Cale> But I know what you're saying ;)
08:50:59 <jmcarthur_work> Cale, of course i just mean in the same sense that monoids are (or arrows generally when the types line up)
08:51:02 <Cale> x >>= \v -> y >>= \w -> return (v,w) is not always the same as y >>= \w -> x >>= \v -> return (v,w)
08:51:20 <jmcarthur_work> s/arrows/categories/
08:52:00 <Cale> There are monads for which this is true (like the identity monad), but for which (<=<) still isn't commutative when the types line up
08:54:02 * Cale bets that he will be re-uninstalling pulseaudio shortly. :)
08:54:22 <koeien37> i heard lots of horror stories about that yeah
08:54:48 <jmcarthur_work> they keep saying PA is the future of linux audio, but i don't even know the differences
08:54:57 <Cale> It's just stupid. Alsa works fine. Whenever pulseaudio is running it screws up my volume controls horribly.
08:55:47 <Cale> and random applications disobey things like the fact that I have my speakers muted
09:07:04 <byorgey> jasonmay: if you're on a posix system, you can use System.Posix.Unistd
09:07:17 <jasonmay> oh cool thanks
09:13:11 <jmcejuela> If I define, data Point a = Pt a a, and x is a Point variable, how to get the "first parameter" of x ?
09:13:46 <PeakerWork> jmcejuela: you can use pattern-matching
09:13:54 <ChipperChap> @src lookup
09:13:55 <lambdabot> lookup _key []          =  Nothing
09:13:55 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
09:13:55 <lambdabot>                         | otherwise = lookup key xys
09:14:02 <PeakerWork> jmcejuela: let Pt xfst xsnd = x in ...
09:14:12 <koeien37> jmcejuela: e.g.   f (Pt x y) = ... x ...
09:14:17 <jmcejuela> ah, nice nice
09:14:19 <jmcejuela> thx
09:14:20 <PeakerWork> jmcejuela: Whereever you've bound x, you can bind  (Pt x y) instead
09:14:48 <tommd> jmcejuela: You could also use record field names, but that is uglier than pattern matching (most of the time) so don't do it if it isn't needed.
09:15:17 <tommd> data Point a = Pt { x :: a, y :: a)
09:15:17 <tommd> func pnt = x pnt
09:15:34 <PeakerWork> @hoogle safeHead
09:15:35 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
09:15:40 <PeakerWork> @type \x -> listToMaybe . filter (fst . (==x))
09:15:42 <lambdabot>     Couldn't match expected type `(Bool, b)'
09:15:42 <lambdabot>            against inferred type `Bool'
09:15:42 <lambdabot>     In the second argument of `(.)', namely `(== x)'
09:15:47 <PeakerWork> @type \x -> listToMaybe . filter ((==x) . fst)
09:15:48 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe (a, b)
09:15:53 <PeakerWork> @type lookup
09:15:54 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
09:16:05 <PeakerWork> @type \x -> listToMaybe . map snd . filter ((==x) . fst)
09:16:06 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
09:24:23 * hackagebot upload: hpage 0.4.1 - A scrapbook for Haskell developers (FernandoBenavides)
09:25:01 <jmcarthur_work> @users
09:25:01 <lambdabot> Unknown command, try @list
09:25:05 <jmcarthur_work> ?
09:25:40 <jmcarthur_work> are @users and @seen disabled?
09:25:51 <medfly> preflex, users
09:25:58 <medfly> maybe not
09:26:01 <medfly> preflex, seen Cale
09:26:02 <preflex>  Cale was last seen on #haskell 30 minutes and 14 seconds ago, saying: and random applications disobey things like the fact that I have my speakers muted
09:26:11 <jmcarthur_work> @seen Cale
09:26:11 <lambdabot> Unknown command, try @list
09:26:18 <copumpkin> jmcarthur_work: yep
09:27:22 <dfrey|work> Cale: Thanks.  I made some progress.
09:59:04 <chrisdone> it's haskell life for us
10:03:12 <ben_m> Does anyone use the Emacs Starter Kit and haskell-mode? I can't find haskell-mode in the package list
10:06:19 <chrisdone> pulseaudio has been great for me on ubuntu
10:06:32 <chrisdone> it messed up skype previously, but the latest upgrade sorted that out
10:06:42 <chrisdone> delicious application-specific volume control
10:08:54 <chrisdone> > '^' : replicate 5 '_' ++ "^"
10:08:55 <lambdabot>   "^_____^"
10:10:46 * hackagebot upload: hpage 0.4.2 - A scrapbook for Haskell developers (FernandoBenavides)
10:12:53 <ztjuri> Napi0105 text sem...hi must see ! http://www.youtube.com/watch?v=eQLbMJmzi9E
10:13:18 <ztjuri> http://www.youtube.com/watch?v=eQLbMJmzi9E
10:28:13 <Cale> Fellow Haskellers on Ubuntu: What did you do about the stupidly simplistic volume controls? Surely I am not the only one who needs to control the volume of his speakers and headphones separately? :)
10:28:22 <Cale> (in karmic)
10:28:38 <kmc_> Cale, i'm not sure that's possible on most hardware
10:29:42 <Cale> I can control the volume separately from the alsamixer terminal program, but that's inconvenient.
10:29:42 <ben_m> I just tried to import Parsec in ghci, but it says that it can't find it.
10:29:49 <ben_m> It is installed thoug. What could be the problem?
10:29:53 <ben_m> though*
10:30:08 <Cale> In Jaunty I could just put a few volume control applets in my panel and it was good.
10:30:13 <path[l]> hello, can anyone point me to an easy to understand resource for memoization in haskell?
10:30:30 <Cale> path[l]: data-memocombinators is great for that
10:30:45 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html
10:30:49 <Cale> http://hackage.haskell.org/package/data-memocombinators
10:31:14 <kmc_> ben_m, did you run something like this:  :m + Text.ParserCombinators.Parsec
10:31:17 <Cale> ben_m: How did you try to import it?
10:31:23 <ben_m> import Parsec, like in the tutorial
10:31:25 <path[l]> ah thanks .... but is there something that explains how it works too?
10:31:31 <path[l]> Im trying to understand this http://www.haskell.org/haskellwiki/Memoization
10:31:31 <Cale> ben_m: ah,  import Text.Parsec
10:31:38 <ben_m> yep, works. Thanks :)
10:31:45 <path[l]> and I dont understand even the "memoization without recursion" bit
10:31:50 <ben_m> I figured it was something like this, but all tutorials simply said import Parsec
10:32:05 <kmc_> ben_m, they're probably old
10:32:16 <kmc_> from before Parsec was assimilated into the standard library
10:33:09 <Cale> (possibly even before there were hierarchical modules)
10:33:13 <kmc_> path[l], most of the code under (1) is not Haskell
10:33:25 <path[l]> ah
10:33:32 <path[l]> that probably explains it
10:33:37 <kmc_> this document doesn't look that useful tbh
10:33:51 <kmc_> maybe parts of it
10:34:49 <path[l]> I was wondering how memoize itself worked. What sort of structure it stored stuff in
10:35:09 <leimy_> I have a record style datatype, and I'd like to define a Functor instance for it.  Do I need to wrap this in a functor data type first, or is there a way to just define fmap for it?
10:35:21 <Cale> path[l]: It depends. You can use lots of different structures depending on what sort of function you're memoising.
10:35:23 <kmc_> you can view the source to Data.MemoCombinators: http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/src/Data-MemoCombinators.html
10:35:39 <kmc_> it stores the values basically just by using "let" and relying on laziness
10:35:54 <kmc_> leimy, instance Functor MyDatatype where ...
10:36:04 <kmc_> you fill in the definition of fmap
10:36:32 <path[l]> hmm
10:36:38 <kmc_> MyDatatype must have kind * -> *, i.e. it must have one type variable
10:36:45 <Cale> The MemoCombinators library actually mostly uses a really neat trick which you can see exemplified in http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/src/Data-MemoCombinators.html#bool
10:36:48 <kmc_> (if you have more than one, you'll have to partially apply the type constructor in the instance head)
10:36:51 <leimy_> kmc_: That'd be the problem :-)
10:36:52 <Cale> (the definition of bool)
10:36:58 <kmc_> what'd be?
10:36:58 <leimy_> It's not the right kind
10:37:03 <kmc_> ah
10:37:05 <leimy_> kind is *
10:37:06 <kmc_> well, what kind is it?
10:37:20 <Cale> Because the parameters to a function are not recomputed, the results for True and False will effectively be remembered.
10:37:21 <kmc_> it's probably not a functor then
10:37:21 <leimy_> It doesn't "contain" another type
10:37:32 <leimy_> it probably isn't
10:37:38 <kmc_> at least not usefully
10:37:57 <Cale> and then from the memoiser for bool, more complicated ones can be built.
10:38:15 <kmc_> what do you want fmap for?
10:38:41 <Cale> (like integral, which works on integer-like types by converting the numbers into sequences of boolean values which it memoises over)
10:38:42 <path[l]> hmmm
10:38:46 <path[l]> whoa
10:41:19 <leimy_> kmc_: wanted a nice way to apply it for a "show" instance
10:41:26 <leimy_> basically clean up an instance of Show with fmap :-)
10:41:53 <leimy_> That's ok though, I don't really need it, and I think it is a case of muddying the water to make one function look clearer.
10:42:10 <chrisdone> Cale: install pavucontrol
10:42:55 <kmc_> there's probably some kind of mapping scheme you can generalize out even if it's not as general as fmap
10:44:22 <leimy_> thanks anyway
10:44:24 <chrisdone> Cale: from that you can just move the volume slider bar for each device (Output devices), same thing too for Input Devices tab, and move the slider bar for each application on input/output, and select from a drop down for each application for which sound device it outputs to in the Playback tab (same for input in the Recording tab)
10:44:27 <chrisdone> Cale: it's pretty awesome
10:45:53 <chrisdone> Cale: the latest ubuntu comes with a sound control dialog that's similar to pavucontrol but lacking per-device volume and per-application sound devices (for some reason)
10:46:37 <path[l]> sorry how do I install something like data.memocombinators
10:46:45 <kmc_> cabal install data-memocombinators
10:46:52 <kmc_> from the command line
10:47:00 <dpratt71> chrisdone: or you could install Vista/Windows 7 ;-)
10:47:02 <kmc_> that's the name of the package which provides that module
10:47:07 <kmc_> as listed on hackage
10:47:23 <kmc_> (in general packages need not be named after the module(s) they provide)
10:47:27 <path[l]> ah first I need to cabal update I see
10:47:43 <sproingie> can cabal install and use multiple versions of a package?
10:48:00 <sproingie> i have an app that wants vtk 3.x, which is incompatible with 4.x
10:48:05 <sproingie> er vty
10:48:38 <chrisdone> dpratt71: it would be just as much trouble getting something to compile on windows
10:49:15 <chrisdone> dpratt71: ubuntu: apt-get install <blah>. apt-get build-dep <blah>, apt-get source <blah>, make
10:49:53 <chrisdone> dpratt71: windows: er... let's just play games
10:50:41 <dpratt71> chrisdone: I was referring to the per-app volume control goodness; although I heart Win7, it was not a serious suggestion
10:50:47 * sproingie boots to windows exclusively these days to play Torchlight :)
10:51:44 <chrisdone> dpratt71: mkay =)
10:54:09 <path[l]> thanks kmc_
10:54:45 * sieni is getting _really_ irritated with installing qthaskell
10:55:13 <blackh> sproingie: cabal install can't but 'runhaskell Setup' can
10:56:14 <dcoutts> blackh: cabal configure can too
10:56:23 <dcoutts> sproingie: it depends on exactly what you mean
10:56:52 <dcoutts> sproingie: packages cannot directly depend on multiple different versions of a package
10:57:13 <skorpan> i'm trying to write a parser using parsec to read my own super cool language.  i'm trying to figure out a good way to ignore any comments (C-style, // and /**/) in the source code.  what's the best way to accomplish this?
10:57:21 <dcoutts> sproingie: indirectly it is possible, though cabal install tries very hard to avoid it
10:57:36 <dcoutts> sproingie: and cabal can install multiple versions of a package, that's no problem
10:58:37 <dcoutts> sproingie: so in your vty example, it's fine to have multiple versions of vty installed simultaneously, but your app can only use one at once
10:59:02 <dcoutts> skorpan: a lexer?
10:59:34 <skorpan> don't know why i thought that was impossible...
10:59:36 <sproingie> dcoutts: oh sure, i only need one version at a time.  just wasn't sure how to keep multiple versions installed, but using Setup directly sounds like a simple way
10:59:38 <shachaf> preflex: seen ivanm
10:59:38 <preflex>  ivanm was last seen on #haskell 4 hours, 7 minutes and 4 seconds ago, saying: preflex: seen quicksilver
10:59:54 <dcoutts> sproingie: no, just use cabal
11:00:15 <dcoutts> sproingie: the thing blackh was talking about was an much more tricky case
11:00:29 <sproingie> dcoutts: download the old version and 'cabal install'?
11:01:00 <dcoutts> sproingie: or if it's on hackage then just cabal install 'vty ==3.*'
11:01:11 <sproingie> ah, perfect :)
11:01:48 <blackh> dcoutts: Does't cabal install <package> work differently (with the requirement that no two versions of the same package can exist in the dependency tree) vs. cabal install with no package name (which doesn't enforce this)?
11:02:09 <dcoutts> blackh: no
11:02:40 <dcoutts> blackh: what's slightly special is that cabal configure, will first try the solver but if it fails then it falls back to the stupid method Setup configure uses
11:02:46 <sproingie> i just followed dcoutts's advice and got both versions of vty installed no prob :)
11:02:55 <Cale> chrisdone: thanks! I'll try that
11:02:58 <dcoutts> blackh: but cabal install always uses the solver
11:03:02 * DrSyzygy is starting to understand what the ana/cata/...-morphisms are about.
11:03:09 <DrSyzygy> It's a somewhat vertiginous and scary feeling.
11:03:13 <sproingie> now to fix lambdahack's dependencies
11:03:23 <sproingie> DrSyzygy: scary names for simple ideas
11:03:27 <dcoutts> DrSyzygy: it's much less scary if you call them folds and unfolds :-)
11:03:29 <blackh> dcoutts: OK - cool.  I like the "private dependencies" idea for things like QuickCheck.  Did you get my patch, btw?
11:03:35 <DrSyzygy> dcoutts: No. It really isn't. :-)
11:03:48 <sproingie> what's the non-scary name for a zygomorphism?
11:04:01 <dcoutts> blackh: yep, got it
11:04:01 <kw317> is there one?
11:04:03 <DrSyzygy> dcoutts: I don't understand unfolds. I kinda understand folds. But I _REALLY_ understand 'unique morphism from the initial algebra' now.
11:04:17 <sproingie> an unfold is basically a generator
11:04:19 <camio> DrSyzygy: How are you learning?
11:04:30 <DrSyzygy> camio: By producing lecture notes for my category theory class.
11:04:40 <dcoutts> DrSyzygy: ah :-)
11:04:57 <dcoutts> DrSyzygy: well the unfold is "just" the dual :-)
11:05:05 <dcoutts> (which I never found very helpful)
11:05:07 <koeien37> i had some CT in a algebraic geometry class
11:05:07 <koeien37> nice
11:05:18 <DrSyzygy> dcoutts: Yup. Which is my level of understanding of that so far.. That's the half I still need to digest.
11:05:21 <blackh> dcoutts: Thanks. I'm not badgering you. I have no urgent need for it - I'm just trying to achieve that sense of completion with ticket #89. :)
11:05:30 * kw317 struggles with his homework (System F)
11:05:32 <DrSyzygy> dcoutts: Such as, for instance, what does it mean to be a terminal coalgebra...
11:05:36 <dcoutts> blackh: yeah, it's been open long enough :-)
11:05:40 <sproingie> seeing CT here is funny since another place on the internets i frequent, CT stands for "Conspiracy Theory"
11:05:52 <sproingie> then we go talking about cabals etc
11:06:16 <dpratt71> sproingie: :)
11:06:34 <blackh> They say that there is no Haskell cabal, but of course they *would* say that.
11:06:59 <dcoutts> DrSyzygy: my intuition about that comes from applying the property of being a terminal co-algebra to the list functor and deriving the universal property of unfoldr
11:07:02 <Cale> chrisdone: er, this is supposed to have more than one output volume control?
11:07:11 <sproingie> the meeting for the cabal that doesn't exist won't happen at the usual place it isn't at the usual time it isn't scheduled
11:07:18 <DrSyzygy> dcoutts: I probably should do that before I lecture on it then. :-)
11:07:28 <dcoutts> DrSyzygy: and similarly for the universal property of foldr
11:07:49 <sproingie> holy cow.  never roll around on an office chair on carpet while wearing earphones
11:08:31 <Cale> chrisdone: I installed pavucontrol and ran it, and it displays sliders for Front Left and Front Right, but not much else. There's a dropdown for Port with options of Amplifier and No Amplifier (whatever that means), but swapping it doesn't seem to let me control anything but the master volume setting.
11:08:35 <DrSyzygy> sproingie: Electruc shock to your ears?
11:08:41 <sproingie> DrSyzygy: zappy zappy
11:08:57 <sproingie> DIY electroshock treatment
11:09:35 <camio> DrSyzygy: Are you the one putting up the lecture notes on CT?
11:09:41 <DrSyzygy> camio: Yup.
11:09:44 <DrSyzygy> The MATH198 one.
11:10:04 <camio> DrSyzygy: Thanks for that. I've used them in my own learning of CT. Though, still having lots of trouble.
11:10:13 <DrSyzygy> I'm glad you find them useful.
11:10:17 <DrSyzygy> What kind of trouble?
11:10:29 * kw317 recommends algebra of programming for CT-inclined programmers
11:10:49 <camio> DrSyzygy: I'm working through Asperti and Longo and having lots of trouble with the proofs, etc. Going very slowly.
11:11:01 <DrSyzygy> Asperti and Longo? What's the title of that one?
11:11:12 <camio> Categories Types and Structures.
11:11:25 <DrSyzygy> Ah.
11:11:29 <camio> I've read that some Canadian book is the best one for learning. The name escapes me.
11:11:44 <ve_> Hey. I seem to run into a bug with pipes. I compiled all the ways I tested this into http://sprunge.us/VEiZ --could I be mistaken about the intended behaviour in the first place?
11:11:50 <ve_> to have*
11:12:31 <DrSyzygy> camio: CT for the computing sciences?
11:12:32 <camio> DrSyzygy, Category Theory for Computing Science is the name of the canadian book. Any recommendations?
11:12:39 <camio> yep
11:12:45 * FunctorSalad thinks `mep' is a great name if you need a map but all the other names are already taken
11:12:51 <FunctorSalad> ;)
11:12:55 <path[l]> lol
11:12:59 * DrSyzygy has found 'FP with bananas, lenses, envelopes and barbed wire' and 'dual of substitution is redecoration'... Anything else I should digest before I lecture on the ana/cata/zygo/hylo-zoo and comonads for corecursion?
11:13:10 <DrSyzygy> camio: That's my favourite, and the basis for my notes. ;-)
11:13:21 <DrSyzygy> camio: I like Awodey very much, though he's VERY expensive, and much more algebraic.
11:13:26 <chrisdone> Cale: it's supposed to have a load of tabs
11:13:40 <FunctorSalad> DrSyzygy: algebraic in contrast to unique-existence?
11:13:42 <kw317> camio: check algebra of programming by richard bird, it's more about programming in categorical setting rather than pure category theory
11:14:00 <kw317> camio: thus I found it much more accessible
11:14:01 <Cale> chrisdone: I see "Playback", "Recording", "Output Devices", "Input Devices" and "Configuration"
11:14:13 <blackh> ve_: I know a bug in pipes, and like a good citizen I haven't reported it. (I think it's fixed in ghc 6.12 but I'm not sure.)  Yours doesn't look like the same bug as mine.
11:14:14 <DrSyzygy> FunctorSalad: Algebraic in the sense of where he picks motivating examples and how he interprets it. Though possibly I hsould rather say 'logical' for Awodey.
11:14:17 <FunctorSalad> DrSyzygy: I think that approach is way underhyped. IMHO all the unique-existential-quantifiers obscure everything
11:14:29 <FunctorSalad> DrSyzygy: ah
11:14:42 <chrisdone> Cale: right. so in Output Devices there should be a volume control for each sound device. is there only one?
11:14:51 <Botje> ve_: when do you read from the pipe?
11:14:54 <Cale> There's just the one.
11:14:55 <DrSyzygy> kw317: I'm not teaching programming in a categorical setting, I'm teaching pure category theory in a way to make it accessible for functional programmers. :-)
11:14:58 <FunctorSalad> I just mean introducing skolem conatants for all the existential quantifiers
11:15:02 <DrSyzygy> kw317: Subtle but important difference.
11:15:07 <Botje> ve_: when the pipe buffers are full it stops  accepting data
11:15:10 <DrSyzygy> FunctorSalad: Skolem conatants?
11:15:12 <Cale> (Well, two which are locked together because they control the left and right channel of the master volume)
11:15:21 <FunctorSalad> (give the morphism out of the coequaliser a fixed name, dammit)
11:15:26 <Cale> I have an Audigy 2
11:15:35 <ve_> Botje: fdRead rd 100 should read from it. It caused identical behaviour so I left it commented
11:15:38 <FunctorSalad> DrSyzygy: o_O Skolem constants, sorry
11:15:38 <Cale> There should be like a million volume settings :P
11:15:40 <camio> DrSyzygy, kw317: Thanks for the recommendations! Time to buy some books ;)
11:15:47 <kw317> DrSyzygy: fair enough, but for self-learning I found the former much more accessible, especially since I have cs background
11:15:53 <DrSyzygy> FunctorSalad: Okay, Skolem constants then. What are they?
11:15:58 <kw317> DrSyzygy: where do you teach that course?
11:16:01 <ve_> Botje, otherwise I just assume dupTo would just >/dev/null it
11:16:01 <FunctorSalad> ah you mean that ;)
11:16:07 <blackh> ve_: My bug is this: fdRead is an unsafe FFI call, which means that in some cases if it blocks, the whole GHC runtime blocks.  I worked around it by copying the code for fdRead and replacing the FFI declaration with a safe one.
11:16:24 * kw317 remembers skolemization from his logic class..
11:16:25 <FunctorSalad> DrSyzygy: say you have a proposition "â x, P(x)"
11:16:28 <DrSyzygy> kw317: Fair enough. I'm writing the lecture notes and teaching the course to try (currently failing somewhat) and form a bridge between mathematically inclined programmers and the more mathematical exposition in CT for the comp. sci.
11:16:28 <chrisdone> Cale: this is what I see: http://chrisdone.com/pics/Screenshot.png
11:16:33 <DrSyzygy> FunctorSalad: Yah.
11:16:50 <FunctorSalad> DrSyzygy: err or even better â w, â x, P(w,x)
11:16:54 <Botje> i'm not familiar with GHC.Handle. if you tested it and it works differently, it's a bug
11:16:58 <dcoutts> DrSyzygy: in my humble opinion, if you're teaching category theory to functional programmers then you need to keep relating the abstract with the concrete FP examples that they will be familiar with.
11:17:07 <chrisdone> Cale: is the other device being detected properly, I wonder. I don't know anything else
11:17:15 <DrSyzygy> dcoutts: I believe I _am_ trying to do just that.
11:17:27 <Cale> chrisdone: Both my speakers and headphones are plugged into my Audigy card.
11:17:38 <dcoutts> DrSyzygy: personally it's the only way I keep a grasp of it. When I started CT they used too many categories I knew nothing about :-)
11:17:39 <DrSyzygy> dcoutts: Again, though, I've identified at least three ways in which I've failed what I set out to do with this course. :-)
11:17:52 <FunctorSalad> DrSyzygy: then you can introduce a new function symbol, say "f", with the rule "â w, P(w,f(w))". the resulting theory is essentially the same as the old one, assuming axiom of choice on the metalevel
11:17:59 <Cale> chrisdone: So it's the same hardware device, but the Audigy has a lot of volume settings which I'd normally use to control the headphone volume separately from the speakers.
11:18:05 <camio> kw317, where do I find that book. The algebra of programming?
11:18:08 <FunctorSalad> DrSyzygy: but you have named the thing that is supposed to exist once and for all
11:18:15 <chrisdone> Cale: ahh. I see. beats me
11:18:23 <DrSyzygy> FunctorSalad: So your f picks one of the things that are supposed to exist?
11:18:38 <dcoutts> DrSyzygy: I derived the definitions of foldr and unfoldr from the universal properties for my thesis, it's really very nice to see them drop out from the very abstract definitions.
11:18:40 <Cale> chrisdone: I just see the "Internal Audio Analog Stereo" the same as you, but no other device.
11:18:43 <FunctorSalad> DrSyzygy: yeah. less messing with existential elimination
11:18:51 <ve_> blackh, the same behaviour with mine (if it's different?) occurs e.g. when you execute some command to pipe stuff through. Basically it's a reduced version (I think) of a bug I've been struggling with in xmonad code for a while. Neither explicitly uses fdRead though..
11:19:36 <FunctorSalad> but anyway, my point wasn't the formal aspect, but simply that I find "let foo be the unique morphism into ..." proofs harder to read than if this morphism is just specified as a *term*
11:19:55 <DrSyzygy> FunctorSalad: So instead of saying, say, â! foldInstance: I -> A, for some initial T-algebra I, and some T-algebra A, you just GIVE the thing in a generic manner as the Skolemized f(B)?
11:20:03 <blackh> ve_: As written I'd expect your code to stall but if you read from the pipe in the forked process, it should not stall.  Is that what you're expecting?
11:20:15 <FunctorSalad> DrSyzygy: exactly
11:20:27 <DrSyzygy> FunctorSalad: Do the isomorphism-proofs work out cleanly with this?
11:20:29 <Botje> ve_: have you run your program through strace to find out where it's stalling?
11:21:03 <FunctorSalad> DrSyzygy: the formalism is already there, it's the "Hom(FA,B) ~ Hom(A,UB)" definition of adjunctions
11:21:15 <FunctorSalad> (which doesn't involve existentials)
11:21:39 <FunctorSalad> the uniqueness is captured by the fact that this iso cancel with its inverse
11:21:39 <dcoutts> DrSyzygy: another good reference is http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
11:21:53 <DrSyzygy> Oooooooh, so once you _have_ the machinery of adjunctions, all the â!-formalisms of all other universal properties REALLY are about some things being adjunctions, and then you can go for the skolemized â!-free approach?
11:22:16 <blackh> ve_: With the "forever (fdRead rd 100 >> return ()) " is fdRead actually receiving anything?
11:22:18 <dcoutts> DrSyzygy: particularly for the greatest fixedpoints
11:22:31 <ve_> blackh, haven't tried that yet.
11:22:42 <Botje> uh, good question.
11:22:46 <Botje> how lazy is fdRead :)
11:23:31 <FunctorSalad> DrSyzygy: yes (btw did one need choice to go from the universal property formulation to the adjunction formulation?)
11:24:05 * DrSyzygy hummms....
11:24:07 <FunctorSalad> DrSyzygy: the universal property can still be useful because it's easier to prove
11:24:23 <FunctorSalad> but for *using* a given adjunction I think I'd prefer something without existentials
11:24:26 <Cale> Huh, moreover, it seems my headphones are not getting any sound anymore.
11:24:30 <DrSyzygy> Let me take a look at Awodey.
11:24:36 * lispy just realized hackage should have release notes
11:24:42 <Cale> Even if I use alsamixer to adjust the volume controls which ought to control that.
11:24:47 <lispy> I think it would be relatively easy to support
11:24:52 <lispy> But, what do I know :)
11:24:59 <koeien37> yeah or a changelog
11:25:02 <zygoloid> lispy: i have wanted that on several occasions
11:25:02 <blackh> ve_: http://upcycle.it/~blackh/Server.hs <- Try using this version of fdRead - it uses a safe FFI call
11:25:04 <dmead> > head []
11:25:04 <lambdabot>   * Exception: Prelude.head: empty list
11:25:05 <FunctorSalad> Cale: I hate that
11:25:15 <DrSyzygy> FunctorSalad: I don't think you use choice for that.
11:25:19 <dmead> catch (head []) (\e -> [])
11:25:23 <dmead> > catch (head []) (\e -> [])
11:25:24 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO a'
11:25:24 <lambdabot>         against inferred typ...
11:25:28 <FunctorSalad> somehow my headphones have broken all these fragile 3.5mm jacks
11:25:29 <zygoloid> Cale: you could try either installing or uninstalling pulseaudio ;-)
11:25:33 <dmead> > catch (head []) (\e -> return [])
11:25:34 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:25:34 <lambdabot>    `Data.Typeable.Typeable a...
11:25:38 <dmead> hmm
11:25:43 <koeien37> dmead: catching exceptions from pure code is possible with Control.Exception
11:25:52 <dmead> > catch (do head []) (\e -> return [])
11:25:53 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:25:53 <lambdabot>    `Data.Typeable.Typeable a...
11:25:58 <dmead> hmm
11:26:00 <Cale> I tried uninstalling pulse audio, but then I had no gnome volume controls at all.
11:26:17 <Cale> and the sound configuration control panel just hung.
11:26:17 <dmead> is it possible to catch pattern match exceptions?
11:26:19 <DrSyzygy> If you have eta: 1_C -> UF w/ universal property, then you get the isomorphism D(FC,D)=C(C,UD) by just setting i(g) = U(g) . eta_C and verifying all requirements.
11:26:20 <dmead> or is that the domain of the compiler
11:26:35 <DrSyzygy> And if you have the isomorphism i, then you just set eta_C = i(1_FC).
11:26:40 <DrSyzygy> And again verify that this is enough.
11:26:54 <koeien37> > catch (head [] `seq` return ()) (\(SomeException _) -> putStrLn "nooo")
11:26:55 <lambdabot>   Not in scope: data constructor `SomeException'
11:26:57 <ve_> uh, with (do (s,c) <- fdRead rd 100; hPutStrLn stderr $"Read "++(show c)++"bytes: "++s; return ()), it actually does print stuff forever... Back to attempting to reduce the xmonad bug...
11:27:24 <FunctorSalad> DrSyzygy: ah right, I meant the even weaker universal property "for all X, there exists Y, ..."
11:27:38 <saml> Y is X
11:27:46 <FunctorSalad> (where Y will be the F X)
11:28:58 <blackh> ve_: Look at the code that reads from the pipe and make sure the C call it's ultimately using is a "safe" type.
11:29:08 <dmead> koeien, oh shit that did it
11:29:10 <dmead> thanks man
11:29:27 <blackh> ve_: This definite affects multi-threaded code but it could possibly affect single-threaded.
11:29:28 <dmead> i would have never thought of the (exception _) syntax
11:29:30 <zygoloid> Cale: hmm, if you're using gnome you'd probably need to install esound after removing pulse
11:29:35 <dmead> koeien++
11:29:39 <dmead> koeien37++
11:29:45 <Cale> zygoloid: I actually just want to use alsa directly.
11:30:43 <Cale> Jaunty at least gave me the option.
11:30:44 <zygoloid> yeah, that'd be nice. but 2009 is the Year of Broken Audio in Linux... :(
11:30:46 <koeien37> dmead: you have to be careful though, if there is an exception somewhere in pure code, it has to be thrown within the execution of the "catch" block. this is not always obvious due to lazy eval
11:30:54 <DrSyzygy> FunctorSalad: Wait.... I'm slow and distracted today.
11:30:57 <DrSyzygy> FunctorSalad: Which UP is this?
11:31:30 <dmead> hmm
11:31:33 <dmead> it doesn't work still
11:31:41 <tensorpudding> I thought the year they introduced Pulseaudio to Ubuntu was the year of broken linux audio
11:31:46 <dmead> koeien37, thats the thing.. i'm trying to catch a pattern match exception
11:31:54 <dmead> i'm not sure of that means it's pure code or not
11:32:06 <Cale> I can't believe that someone actually thought it would be a good idea to take away the separate volume control applets and just smash it down to an icon in the notification area (?!) which has only one volume setting.
11:32:25 <koeien37> dmead: unfortunately i have to leave now :( it helps if you can post (a simplified version of) your code
11:32:27 <dmead> pulseaudio is just ARTS with a new finish
11:32:36 <dmead> koeien37 alright
11:32:53 <Cale> and then have none of the other programs for controlling volume settings actually give more than one working control for a sound card that's supposed to have a few dozen.
11:33:01 * DrSyzygy hummmsm.
11:33:06 <dmead> anybody else know how to catch a pattern match failure?
11:33:29 <tensorpudding> the pulseaudio volume controller has some better controls
11:33:32 <Dr-Horrible> I am looking for a way to split a string on a char. Any tips?
11:33:36 <tensorpudding> if you're using pulseaudio
11:33:44 <dmead> @hoogle splitby
11:33:44 <lambdabot> No results found
11:33:49 <FunctorSalad> DrSyzygy: like "forall (X1,X2), exists product, ... property of product ..."
11:33:51 <dmead> @hoogle split
11:33:51 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
11:33:52 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
11:33:52 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
11:34:00 <DrSyzygy> If the algebraic/monadic approach is "You can always collapse levels of a tree", the coalgebraic/comonadic should be something like "You can always expand your things into a bigger tree"? Something like infinite binary trees, where you ALWAYS have the guarantee you can split your tree at the root and get two new trees?
11:34:04 <shapr> gbacon: y0
11:34:04 <zygoloid> Dr-Horrible: Data.List.Split: for all your list splitting needs(tm)
11:34:19 <DrSyzygy> FunctorSalad: So forall A,B http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
11:34:22 <DrSyzygy> Hrm.
11:34:26 <gbacon> shapr: hollaaaaaa!
11:34:32 <Cale> DrSyzygy: yes
11:34:33 <DrSyzygy> The \exists dropped out of my clipboard I see...
11:34:40 <zygoloid> > break (==' ') "hello world"
11:34:41 <lambdabot>   ("hello"," world")
11:34:50 <jmcarthur_work> gbacon, shapr: oy!
11:34:55 <zygoloid> Dr-Horrible: ^^ but in this case 'break' would work i guess :)
11:35:09 <jmcarthur_work> omegix_work, wee!
11:35:10 <dmead> > head []
11:35:11 <lambdabot>   * Exception: Prelude.head: empty list
11:35:12 <DrSyzygy> Cale: Hmmmm..... That's nice... And a terminal infinite binary tree then is one with minimal restraints, thus one with as much formal construction of things as possible?
11:35:23 <sproingie> Cale: that's the way gnome works: any functionality that's useful must be replaced with something simpler that isn't
11:35:29 <FunctorSalad> accidental /part
11:35:46 <ve_> blackh, hm, maybe there's some subtle or not-so-subtle difference from the xmonad bug. Basically for some instances (30%?) when you write to the pipe, the first byte will freeze the process and apparently not even timeout'ing the writes helps there.
11:35:53 <shapr> Ok, so... Birmingham and Huntsville Haskell und Multicore Bxx User's Group? BAH HUMBUG?
11:35:54 <jmcarthur_work> by any mere coincidence, are there any other haskellers here in huntsville, al?
11:36:00 <jmcarthur_work> or surrounding area?
11:36:05 <DrSyzygy> FunctorSalad: So forall A,B exists AxB w/ AxB -> A, AxB -> B s.t. any other T w/ T->A, T->B has unique T -> AxB. That formulation?
11:36:15 <shapr> Yeah, looking for Haskellers in North Alabama, or southeast TN!
11:36:24 * omegix_work raises his hand as a huntsviller interested in haskell
11:36:26 <absentia> what for ?
11:36:33 <FunctorSalad> DrSyzygy: yes
11:36:34 * absentia is in NYC
11:36:37 <tensorpudding> Seems like there are a lot of Haskell programmers in the South, judging by how often I hear that question
11:36:37 <lament> slaughter
11:36:39 <jmcarthur_work> user's group
11:36:39 <dmead> > catch (head [])  (
11:36:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:36:41 <dmead> err
11:36:43 <absentia> ha!
11:36:47 <shapr> Actually, I might know some guys in southeast TN.
11:36:52 * DrSyzygy needs to figure out somewhere in his swiftly vanishing remaining lectures to talk about things like "Oh, and here's how to frame ALL limits as adjunctions. And here are some other cool adjunctions..." 
11:36:59 <gbacon> jmcarthur_work: does Pikewerks overlap much with the work they do at Galois?
11:37:18 <blackh> ve_: Do you want me to explain why the "unsafe" causes the problem (in my case)?
11:37:19 <dmead> > catch (head [])  (\ (SomeException _ ) -> [])
11:37:20 <lambdabot>   Not in scope: data constructor `SomeException'
11:37:29 <dmead> > catch (head [])  (\ ( _ ) -> [])
11:37:30 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO a'
11:37:30 <lambdabot>         against inferred typ...
11:37:43 <blackh> ve_: unsafe writing could potentially cause trouble too
11:37:43 <jmcarthur_work> gbacon, i'm still not very sure about the answer to that. it might be indicative that i haven't had much success finding applications for haskell here yet
11:37:45 <gbacon> shapr: that's very clever.. how's that working out for you?
11:37:58 <Saizan_> dmead: the first argument has to be an IO action
11:38:10 <shapr> gbacon: The cheesy acronym? Not so well akshually...
11:38:11 <dmead> > catch (return $ head [])  (\ ( _ ) -> [])
11:38:12 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO a'
11:38:12 <lambdabot>         against inferred typ...
11:38:16 <Saizan_> dmead: and make sure you evaluate it enough inside the scope of catch
11:38:20 <jmcarthur_work> gbacon, we mostly do kernel level stuff
11:38:33 <Saizan_> dmead: the handler has to be an IO action too, and lambdabot won't run it anyhow
11:38:46 <dmead> Saizan_, what do you mean
11:38:56 <jmcarthur_work> shapr, oh i just now realized that was an acronym
11:38:57 <gbacon> tensorpudding: well, so far we're up to four.. is that an outlier in terms of density? :-)
11:38:58 <dmead> i'm trying to figure out how to catch a pattern match failure
11:39:01 <poucet> shapr: hey
11:39:01 <Saizan_> > catch (return $! head ()) (\_ -> return [])
11:39:03 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
11:39:09 <poucet> shapr: did you get my @tell?
11:39:09 <Saizan_> > catch (return $! head []) (\_ -> return [])
11:39:11 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:39:11 <lambdabot>    `Data.Typeable.Typeable a...
11:39:11 <shapr> poucet: bonjour! No, I have no idea!
11:39:17 <shapr> poucet: Talk to Ashley Yakely probably?
11:39:20 <jmcarthur_work> gbacon, there's also somebody in eldrige, but that's like a 2.5 hour drive
11:39:22 <poucet> Is he on IRC?
11:39:26 <shapr> I don't think so.
11:39:28 <jmcarthur_work> Raynes i think
11:39:37 <Saizan_> dmead: it's like catch (return $! head []) (\ (SomeException _) -> return []), but do it in ghci
11:39:39 <gbacon> crazy.. and shapr's in the Shoals, right?
11:39:47 <jmcarthur_work> yeah, 1.5 hour i think
11:39:52 <gbacon> Eldridge.. wow!
11:39:54 * Raynes lives in Eldridge.
11:40:01 <jmcarthur_work> hello :)
11:40:14 <dmead> Saizan_, seems to work correctly
11:40:19 <Raynes> The home of Dial up internet connections.
11:40:19 <dmead> it returns []
11:40:33 <dmead> Saizan_, why did you use the ! operator?
11:40:38 <Saizan_> dmead: and in general it's something you should avoid though
11:40:39 <gbacon> Raynes: Eldridge, Alabama?
11:40:41 <shapr> jmcarthur_work, gbacon, omegix_work: http://groups.google.com/group/alabamahaskell
11:40:46 <Raynes> gbacon: Yep.
11:40:49 <Saizan_> dmead: to force th evaluation of head [] there
11:40:50 <shapr> Raynes: http://groups.google.com/group/alabamahaskell
11:40:53 * gbacon boggles
11:41:16 <lilac> my mind! the boggles! they do nothing!
11:41:19 <dmead> Saizan_, do you think catching pattern match failures is a good idea?
11:41:32 <absentia> alabama black snake?
11:41:46 <omegix_work> shapr: awesome
11:41:46 <zygoloid> dmead: it'd be better to write the code so that you don't get pattern match failures in the first place
11:42:10 <dmead> zygoloid, i'm trying to do a production system just using haskell's built in pattern matching
11:42:22 <dmead> and i need to fail and move to the next rule
11:42:37 <Saizan_> dmead: i think it isn't, i'd rather change the function with the incomplete patterns to report a proper error, e.g. using a  Maybe type
11:42:52 <zygoloid> dmead: you don't want to add 'foo _ = fail' to each rule?
11:43:00 <dmead> zygoloid, correct
11:43:01 <zygoloid> for some value of 'fail'
11:43:06 <dmead> yea
11:43:31 <dmead> i saw the library that does first class patterns, but thats too extensive
11:44:06 <jmcarthur_work> would it be worth sending a little notice to -cafe about this?
11:44:19 <dmead> i have, not much response
11:44:28 <zygoloid> well, you'll need to be aware of inexact exceptions; if your code could fail with a pattern match failure or something else, you'll get one or the other but there's no guarantee as to which (or even that the choice is deterministic)
11:44:38 <zygoloid> so you should probably not let the result escape from IO
11:44:54 <jmcarthur_work> dmead, if that was in response to me, i wasn't talking to you :P sorry
11:45:15 <dmead> jmcarthur_work, ah sry
11:45:34 <dmead> zygoloid, i return a failure state and throw it away
11:45:51 <dmead> that is, i would if i could get my lambdas to fail properly
11:47:37 <dmead> oh
11:47:40 <dmead> it works
11:47:46 <zygoloid> dmead: take a look at GHC.Exception, specifically the catchException function and the PatternMatchFail constructor. that's how i'd do it if i decided to do it. but catching a pattern match failure is icky...
11:48:11 <dmead> i got it working properly
11:48:26 <dmead> i was missing the ! operator to make the exception throw in the scope of catch
11:48:29 <dmead> like one of you said earlier
11:49:33 <dmead> zygoloid, i agree it's icky but writting my own pattern matcher when haskell has one already seems even worse
11:50:25 <dmead> zygoloid, if patterns were first class as like this:
11:50:31 <dmead> http://hackage.haskell.org/package/first-class-patterns
11:50:34 <dmead> i wouldn't have to do this
11:51:16 <ben_m> For parsing a simple polynomal "5 * (3 + 1)" would Parsec be overkill?
11:51:41 <camio> ben_m: I use Parsec often for small parsers like that.
11:51:50 <ben_m> Alright :)
11:52:08 <ben_m> I wanted to learn Parsec anyways, just wanted to know if it might not be the right time to do so.
11:52:17 <camio> ben_m: For my own programming, parsec has outright supersceded regular expressions.
11:52:17 <leimy_> forever $ forkIO $ return ()
11:52:41 <leimy_> Parsec is great
11:52:55 <leimy_> The Regex stuff is nice too, but Parsec seems a bit leaner
11:53:05 <leimy_> I've also done some stuff in the ReadP combinator
11:53:29 <kmc_> Parsec can be quite tricky though
11:53:43 <kmc_> e.g. getting "try" in the right places
11:53:52 <leimy_> I don't know, never had trouble with try
11:54:01 <leimy_> try applies only to the left hand side of an alternative <|>
11:54:21 <leimy_> the trick is certain pre-made combinator thingies already use <|>
11:54:57 <camio> me neither, not once I understood how the parser works. My biggest gripe is the choice between translating my languages to LLR form or just using try.
11:55:33 <leimy_> I think no matter what you use for a parser, you're in for a lot of testing :-)
11:55:42 <leimy_> and tuning as you go
11:55:55 <leimy_> Parsec makes some things very easy
11:56:03 <leimy_> and makes other things kind of tricky.
11:56:33 <leimy_> example would be "many anyChar" is almost never something to put in the middle of another set of expressions, I almost always have to get really specific.
11:56:51 <leimy_> at least, that's what I've found from experience.
11:56:55 <nominolo> @seen bos
11:56:55 <lambdabot> Unknown command, try @list
11:57:03 <saml> @saw  bos
11:57:04 <lambdabot> Maybe you meant: faq map show slap src yow
11:57:12 <leimy_> @slap leimy_
11:57:13 * lambdabot is overcome by a sudden desire to hurt leimy_
11:57:16 <nominolo> it's some other bot whose name I always forget
11:57:17 <gbacon> ?ty fap
11:57:18 <lambdabot> Not in scope: `fap'
11:57:27 <nominolo> preflex: @seen bos
11:57:27 <preflex>  bos was last seen on #haskell 15 hours, 43 minutes and 37 seconds ago, saying: hmm, we need a better supply of late-night haskell hackers around.
11:57:28 <leimy_> @yow
11:57:28 <lambdabot> Couldn't find fortune file
11:57:37 <nominolo> preflex: @seen edwardk
11:57:38 <preflex>  edwardk was last seen on ##logic 8 days, 37 minutes and 3 seconds ago, saying:  /j #lock-free
11:58:24 <shapr> adept: Thanks for the transcription help!
12:00:03 <Vulpyne> Hmm, when uploading a package to Hackage, how can I make the documentation all nice and linky? I don't see any information on that.
12:00:35 <nominolo> Vulpyne: It takes a while.  Just wait
12:00:45 <Vulpyne> nominolo: So it wouldn't show up when you do "check"?
12:01:23 <nominolo> Vulpyne: hm, not sure actually.  I don't think so.
12:01:32 <nominolo> Vulpyne: you can run "cabal haddock" locally to test it.
12:02:00 <nominolo> The build report (on the hackage site) should say if there were errors
12:02:16 <Vulpyne> nominolo: It shows the tree of modules, but no links to the docs when I do check. cabal haddock and stuff works, so I'll just hope that when I actually upload it, everything will work. :)
12:02:19 <Vulpyne> Thanks for the information.
12:02:56 <nominolo> Vulpyne: sorry, what do you mean by "check".  Do you mean running "cabal check" locally?
12:03:18 <Vulpyne> nominolo: Using the check option at http://hackage.haskell.org/packages/upload.html
12:03:58 <nominolo> ah, that's new.  Yeah, upload is probably the way to go
12:04:14 <Vulpyne> I'm not quite ready to upload yet. :)
12:04:39 <nominolo> Vulpyne: this is just a web interface to the "cabal check" command which you can run locally if you want.
12:05:07 <Vulpyne> It doesn't seem like I can tell if the documentation will be there either way though.
12:05:09 <nominolo> Vulpyne: also note the second bullet point under Notes: "Documentation for library packages will be generated by a batch run, though not immediately after your upload. You don't have to do anything special to make it happen. "
12:05:36 <Vulpyne> nominolo: Ohh, I somehow missed that. Sorry.
12:11:20 <kmc_> @. pl undo do { x <- m; n; return x }
12:11:21 <lambdabot> (n >>) . return =<< m
12:11:40 <kmc_> i feel like it should be simpler than that
12:11:52 <kmc_> to bind an action after another, but use the first action's result
12:21:06 <Axman6> hmm, is it possible to prove that a particular (context free) grammer is unambiguous?
12:21:50 <Axman6> i know how to prove it is ambiguous (give two parse trees for the same expression), but the opposite seems less than trivial
12:23:05 <Cale> Hmm, at least with pulseaudio removed my headphones work and I can control the volume using alsamixer. Maybe I can work out how to install a gnome volume control applet by hand.
12:23:57 <dancor> Axman6: surely you can prove it for at least some particularly trivial grammar
12:24:14 <dancor> like S -> e
12:24:37 <dancor> so yes it is possible ;)
12:25:00 <kmc_> the question is whether the set of unambiguous CFGs is recursive?
12:25:02 <Axman6> but in general?
12:25:03 <kmc_> (i.e, computable)
12:26:21 <kmc_> http://www.springerlink.com/content/9k73219367t32q47/
12:26:49 <kw317> Axman6: structural induction on the structure of derivations?
12:26:50 <kmc_> http://people.cis.ksu.edu/~rhowell/770s03/lectures/23-twoup.pdf It's not decidable
12:27:01 <Axman6> hooray
12:27:14 <Axman6> i can use that in my exam today :)
12:27:27 <kw317> algorithmically, but that does not mean that it's not possible
12:27:37 <kmc_> kw317, haha
12:27:49 <kmc_> you're opening up a mighty big can of philosophical worms there
12:28:03 <kw317> kmc_: I mean it's undecideable in general
12:28:11 <kw317> but might be possible for his particular grammar
12:28:27 <dancor> Axman6 made it seem like it's easy to find two parse trees for some expression if you know the grammar is ambiguous
12:28:33 <kmc_> it might be possible for *every* grammar
12:28:33 <dancor> but that is also undecideable right?
12:28:53 <Axman6> dancor: most likely
12:29:08 <iaefai> Axman6: nice reddit post the other day about cocoa
12:29:10 <dancor> if it's worth doing, it's probably impossible
12:29:18 * Axman6 learns how to create pda's again
12:29:32 <kmc_> is it not the case that F(G,x) = { parse trees for x in CFG G } is RE?
12:29:38 <kmc_> it seems that it should be
12:29:56 <Axman6> iaefai: ta :) i've been using the tutorial for a week or so and it's extremely clear
12:30:13 <iaefai> Axman6: I can imagine
12:30:15 <dancor> kmc_: ya can't you just generate every possible string
12:30:26 <iaefai> It would have been useful to me a long time ago
12:30:26 <kmc_> you'd have to generate every possible tree
12:30:49 <kmc_> but anyway if that's the case then given x which parses ambiguously in G you can find the ambiguity
12:31:03 <kmc_> if you just know G has some ambiguity it's still the case by parallel simulation for all x
12:31:57 <dancor> for CFG, because the strings get larger as you go, i think you can find all the strings/trees corresponding to some x
12:32:17 <dancor> just generate every production with size <= |x|
12:32:59 <dancor> so ya determining if a grammar is ambiguous is RE then.
12:33:35 <dancor> or some more formal/correct statement like that
12:33:55 <kmc_> and thus not co-RE
12:34:43 <sinelaw> hey, i need a list of abstractions commonly used in software design (as opposed to electronic hardware design) - for example, data structures, message passing, ??? what else?
12:35:05 <dancor> that's an abstract question..
12:35:21 <Axman6> sinelaw: locking?
12:35:30 <sinelaw> dancor, just looking for common things people think abuot when designing software
12:35:33 <sinelaw> Axman6, that's good
12:35:42 <Axman6> oops?
12:35:45 <Axman6> l*
12:36:09 <sinelaw> ?
12:36:16 <Axman6> looping
12:36:32 <sinelaw> heh, locking is good. i translated that to "processes and synchronization"
12:36:39 <kmc_> in most OO languages, your main way to build abstractions is defining classes and instantiating them to objects
12:36:39 <sinelaw> looping is also good
12:36:53 <dancor> information hiding
12:36:53 <Axman6> looping?
12:36:56 <sinelaw> kmc_, yes, that's message passing between objects
12:37:01 <Axman6> argh! damn up arrow
12:37:05 <Axman6> threading?
12:37:30 <kmc_> which gets you modularity, interface with hidden implementation, and transparent substitution of different behaviors on the same interface (i.e. polymorphism)
12:37:50 <Axman6> monads!
12:37:59 <dancor> http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
12:38:01 <skorpan> monads and strife
12:38:06 <kmc_> in functional languages your main abstractions are functions, which can save context from their definition site and use it later
12:38:11 <kmc_> (thus also hiding information in a sense)
12:38:11 <dancor> there are lots of OO ones
12:38:16 <dancor> factoryfactories
12:38:18 <kmc_> there are also algebraic data types
12:38:28 <Axman6> dancor: gross
12:38:38 <kmc_> and abstract data types, which are sort of (but not totally) like objects -- you hide the implementation using the module system but you export stuff for working with it
12:38:45 <dancor> lots of things are abstractions
12:38:56 <dancor> i guess it's just a popularity contest
12:38:57 <PeakerWork> factories are just OO's boilerplate around function pointers that create things
12:39:10 <sinelaw> well, all the FP/haskell approach abstractions is what i'm trying not to mention at this point
12:39:19 <kmc_> monads are important but as we all know, they're an application of first-class functions, not a fundamental language feature
12:39:39 <sinelaw> PeakerWork, no, they do have a slightly more abstract meaning. people don't think of them as function pointer instantiators
12:39:56 <kmc_> (also there's no reason a language can't have both the functional and OO abstraction features)
12:39:59 <PeakerWork> sinelaw: Its what they are though :)
12:40:12 <sinelaw> PeakerWork, operationally
12:41:12 <PeakerWork> sinelaw: and semantically
12:41:17 <PeakerWork> sinelaw: denotationally, that is
12:41:39 <PeakerWork> sinelaw: A factory is a wrapper around a function that creates objects of some kind
12:41:40 <sinelaw> PeakerWork, why? you can express the denotation without mentioning function pointers. you can mention "object creation" instead
12:41:44 <PeakerWork> sinelaw: its basically just that function
12:41:53 <PeakerWork> sinelaw: s/function pointer/function for the "semantics"
12:42:36 * dancor is feeling nihilistic now
12:42:44 <kmc_> there should be almost no situation where you need function *pointers* in your semantics
12:43:52 <dancor> is memoization an "abstraction"?
12:44:12 <kmc_> lambda is the only abstraction :)
12:44:18 <ben_m> Is there no shorter way of formatting time than first converting it to CalendarTime and then calling formatCalendartime defaultTimeLocale "format here"?
12:44:21 <PeakerWork> sinelaw: More accurately, the semantics of a factory are those of an action yielding some object
12:44:35 <sinelaw> that's better
12:44:51 <sinelaw> PeakerWork, "Indeed, higher-level controlling logic that is normally *implemented* in software, is also *designed* using appropriately higher-level abstractions - such as data structures, objects and message passing, processes and synchronization, looping, etc. These abstractions seem well suited for designing software, but they lack the important property of a *simple mathematical meaning*."
12:44:54 <dancor> ben_m: idk but i would believe there isn't.. make a function?
12:45:18 <sinelaw> s/designing software/designing systems/
12:45:20 <ben_m> dancor: Just seems so verbose for the usually terse Haskell
12:45:27 <dancor> my experience with the time stuff has been that way
12:45:54 <dancor> and also haskell is missing all kinds of tersities like a split function
12:46:07 <PeakerWork> sinelaw: nice, who said that?
12:46:08 <sinelaw> PeakerWork, and s/simple/tractable/
12:46:14 <ben_m> It has several split functions?
12:46:23 <sinelaw> PeakerWork, i did. I'm writing my report now. that will be in the "motivation"
12:46:28 <PeakerWork> sinelaw: cool :)
12:46:41 <PeakerWork> sinelaw: but why "appropriately"?
12:46:41 <dancor> ben_m: i mean it doesn't have split-a-list-on-a-list
12:46:47 <ben_m> dancor: Oh
12:46:57 <kmc_> what about Data.List.Split?
12:47:02 <kmc_> not built in, granted
12:47:03 <ben_m> There's a splitOn in Hackage
12:47:17 <dancor> ya and one day there will be Data.Time.Tersities
12:47:21 <ben_m> heh
12:47:26 <dancor> will that day be today
12:47:32 <sinelaw> PeakerWork, yes i'm asking myself too, but it's because the previous sentence was about how hardware is designed using almost exclusively numerical functions (scalars, vectors, etc..) and that indeed for higher level logic that is not enough
12:47:42 <dancor> today :: IO YourTypeHere
12:47:45 <kmc_> only Haskell would have a library for splitting strings based on an abstract datatype and a combinator algebra of splitters ;P
12:47:55 <kmc_> > now
12:47:56 <lambdabot>   Not in scope: `now'
12:48:12 <sinelaw> i can erase "appropriately"
12:48:23 <sinelaw> and i did.
12:49:15 <sproingie> the one Acme module in hackage is about having a 'now' value
12:49:20 <kmc_> i actually used Acme.Time.Now in a serious program
12:49:24 <kmc_> sproingie, there's now a second
12:49:36 <kmc_> acme-dont
12:49:55 <sproingie> yah it's a sign of a true perl hacker to actually use an Acme:: module in serious code
12:50:12 <sproingie> i've seen Acme::Bleach recommended as a trivial obfuscator
12:50:54 <dancor> i think about acme-now sometimes
12:51:20 <kmc_> "now" is useful if you want a top-level value representing the current day
12:51:33 <knobo> I must realy say I have fallen in love with what I've seen of haskell so far. But I still got the fealing that it is actually not as shining as it appers. I have been disapointet so many times before...
12:51:36 <dancor> is acme-dont purely a joke or intended to be faster than {- -} sometimes
12:51:39 <kmc_> and your program terminates before the next day ;)
12:51:45 <sproingie> gotta love how simple Acme.Dont is in a lazy language
12:52:05 <dancor> kmc_: if the day changes, you'll have no idea if the compiler memoizes or recomputes right?
12:52:22 <knobo> Anyone have any corner cases for haskell?
12:52:32 <kmc_> knobo, what do you mean?
12:52:33 <sproingie> > fix error
12:52:35 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:52:39 <dancor> knobo: cases where haskell sucks?
12:52:43 <kmc_> dancor, in practice it should always remember
12:52:55 <kmc_> dancor, i don't think we have a formal semantics for unsafePerformIO
12:53:11 <dancor> kmc_: only if the compiler was really short on memory it would possibly drop the value and recompute it right?
12:53:14 <sproingie> kmc_: it's not as though other languages differ there
12:53:49 <sproingie> haskell error messages could do with a "defined here" line
12:54:02 <sproingie> as opposed to "used here"
12:54:06 <kmc_> i thought we sort of required that implementations have the same runtime characteristics as a lazy implementation
12:54:12 <byorgey> knobo: hmm, let's see... (+1) and (-1) mean completely different things.  Sometimes monad transformers don't.  aaaaand... oh yes, records suck.
12:54:15 <byorgey> have I missed anything?
12:54:19 <sproingie> (-1) is a definite wart
12:54:21 <kmc_> also it wouldn't be the compiler that's low on memory
12:54:23 <kmc_> but the RTS
12:54:36 <kmc_> fixity declarators and defaulting
12:54:37 <sproingie> Monad not deriving Functor is a silly oversight
12:54:40 <kmc_> are both stupid hacks
12:54:52 <kmc_> yeah more generally, a lot of stuff in the std lib can be done nicer now
12:54:56 <dibblego> Monad should derive Applicative should derive Pointed should derive Functor
12:54:58 <kmc_> (.), id in Category
12:55:09 <kmc_> Functor should be generalized to cover more than endofunctors in Hask
12:55:17 <sproingie> sure, derive Functor however indirectly
12:55:22 <knobo> byorgey: yes things like that (+1) (-1) mean different tings. What do they mean?
12:55:24 <byorgey> kmc_: hear, hear!
12:55:26 <kmc_> more radically, i'd like to replace typeclasses with default arguments
12:55:31 <kmc_> err implicit arguments
12:55:33 <PeakerWork> dibblego: I'd want that kind of derivation to be done independently of the class
12:55:35 <kmc_> like those ?x things
12:55:36 <byorgey> knobo: (+1) is a function which adds one to a number.  (-1) is negative one.
12:55:40 <kmc_> so we can locally redefine instances
12:55:54 <JohnnyL> what structure (link list,etc) does Haskell GHC use to find a function?
12:56:00 <kmc_> i'd also like more ways to specify strictness
12:56:03 <kmc_> JohnnyL, find how?
12:56:23 <knobo> cases where stupid design makes strange behavior
12:56:38 <tommd> That is a different question.
12:56:48 <knobo> python is full of them. Looks to me like python is almost as bad as php
12:56:53 <sproingie> ardly
12:56:55 <sproingie> hardly
12:57:02 <nlogax> nothing can be that bad
12:57:07 <sproingie> every language has warts.  php has oozing pustules
12:57:10 <Vulpyne> Perl?
12:58:21 <byorgey> JohnnyL: it probably uses a hash table internally.  But once it actually generates machine code, "finding" a function consists of simply jumping directly to it.
12:58:31 <knobo> Funny thing about perl is that I grew up with it, so even if it has many many many strange things, I'm not able to hate it. Like a friend with bad habbits, but it's a funny guy anyway.
12:58:40 <byorgey> JohnnyL: so unless I've misunderstood your questions it's not really something you need to worry about.
12:59:03 <Vulpyne> I'll hate it enough for both of us. :)
13:00:09 <knobo> Vulpyne: do you hate bash?
13:00:36 <Vulpyne> Bash scripting? I can't say I like it, but it's tolerable for really small scripts.
13:00:53 <sproingie> pipes are handy
13:00:57 <ben_m> Perl is great.
13:01:02 <ben_m> It has CPAN!
13:01:16 <ben_m> Perl has just been plagued by lots of bad programmers, giving it a bad reputation.
13:01:27 <tommd> CSPAN?
13:01:42 <knobo> Vulpyne: like perl.
13:01:47 <sproingie> i'm not particularly a fan of perl's highly noisy syntax
13:02:09 <Vulpyne> knobo: I suppose. I'd use Python or Haskell for anything that couldn't be a really tiny shell script.
13:02:35 <dancor> i've been meaning to try life-without-bash
13:02:40 <knobo> In cases where I would make a shell script with lot's of mixing grep sed awk etc. I sometimes do it in perl.
13:02:47 <sproingie> dancor: sure, it's called zsh :)
13:02:48 <knobo> If not, then common lisp.
13:02:58 <knobo> how about fish?
13:03:06 <dancor> sproingie: i'm there, i mean without-ksh-derivatives
13:03:18 <camio> I dislike perl in the same way I dislike Haskell's infix operator precedence rules/syntax.
13:03:34 <dancor> i think FP is well-suited for prompt-foo..
13:03:47 <sproingie> scala does even sillier things with infix
13:03:59 <camio> I don't like having to look somewhere else to parse the code mentally.
13:04:05 <Vulpyne> I don't have to write shell scripts much these days.
13:04:12 <sproingie> it has no way to declare associativity, so it relies on syntax.  so any method ending with a colon is right-associative
13:04:12 <knobo> what is stillier?
13:04:20 <knobo> sillier.. aha.
13:04:27 <knobo> dyslexia
13:04:27 <dancor> it's ironic.
13:05:04 <sproingie> i kinda like how scala can otherwise do infix without extra noise, but that'd be impossible in haskell
13:05:24 <kmc_> i think python is not nearly as bad as php or perl
13:05:34 <kmc_> because there's far less magic
13:05:44 <kmc_> in perl every variable can have like 29 different special properties set for it
13:05:45 <PeakerWork> ben_m: I dislike Perl a lot, for things like lacking proper function signatures (my $blah, $bleh = $_ etc I find very bad). Sigils are really annoying.  The $_ context var is ugly.  The <BLAH> syntax horror is horrible, etc etc
13:06:01 <kmc_> everything in python is basically sugar on a string lookup in a dictionary
13:06:11 <sproingie> kmc_: and its performance suffers for it
13:06:21 <kmc_> well, you mean, the performance of CPython
13:06:29 <kmc_> you could make an implementation that optimizes out most of the lookups
13:06:31 <dancor> oh, we have a believer ;)
13:06:36 <Vulpyne> Is Perl actually a lot faster than Python?
13:06:42 <sproingie> with some things
13:06:44 <kmc_> "Python" has no speed
13:06:46 <kmc_> "Python" is a language
13:06:50 <kmc_> CPython is a Python implementation
13:06:50 <Vulpyne> Okay "CPython".
13:07:01 <dancor> how about "pedantry"
13:07:02 <sproingie> so is perl, but no one gets persnickety about that
13:07:03 <kmc_> "Perl" is unfortunately the name of both a language and an implementation of that language
13:07:16 <dancor> there is one main python implementation as well
13:07:27 <kmc_> dancor, Jython and IronPython are both significant
13:07:30 <kmc_> Google is making another one
13:07:31 <dancor> unladen swallow is still quite laden
13:07:35 <sproingie> sure, and they're even more glacial
13:08:01 <kmc_> yeah but it's not pedantry
13:08:09 <dancor> they are even slower
13:08:12 <kmc_> if i say "Haskell is slow" and I mean "Hugs is slow", it's not pedantic to correct me
13:08:17 <dancor> so it's not relevant to the point
13:08:28 <PeakerWork> kmc_: Python has lots of type-tagging on values, so its not really "sugar over string lookups"
13:08:52 <kmc_> well i don't mean that string dicts are the one and only feature
13:09:18 <kmc_> but much of the "structure" (classes, objects, modules, operator overloading) is that under the hood
13:10:11 <kmc_> if Hugs were slow and were the only Haskell implementation on the planet, it would still be a major error to say "Haskell is slow"
13:10:17 <kmc_> because as we've seen it needn't be
13:10:32 <kmc_> and the same is true of Python, though there are certainly many challenges
13:10:38 <dancor> if ghc is slow at something and someone says haskell is slow as a result, it's not very important to point out that hugs is even slower.
13:11:04 <iaefai> Is there a way evaluate haskell code step by step up until an error to see what types it thinks it is dealing with, inferred and real?
13:11:23 <Vulpyne> iaefai: You can set breakpoints and such in ghci.
13:11:23 <kmc_> iaefai, there will never be a type error during evaluation
13:11:35 <opqdonut> iaefai: the ghci debugger is great
13:11:40 <lament> saying a programming language is slow is correct in some contexts and wrong in others. It all depends on whom you talk to.
13:11:43 <sproingie> technically turing machines are infinitely fast and have infinite memory, so no computation can be slow except for infinite loops
13:11:49 <roconnor> I think iaefai wants to step through the type checking.
13:11:49 <opqdonut> iaefai: but run-time, there is no difference between inferred and "real" types
13:11:52 <sproingie> not all that useful tho
13:11:56 <iaefai> roconnor: is right
13:12:11 <roconnor> I remember long ago there was a research tool that did something like that
13:12:15 <dancor> sproingie: are they infinitely fast?
13:12:23 <kmc_> turing machines don't have a notion of external time
13:12:25 <kmc_> so no
13:12:31 <dancor> i thought they were of finite but unspecified speed
13:12:33 <iaefai> I have  a function that is a pain in the ass to get typed right
13:12:44 <kmc_> iaefai, let GHC infer it and use :t ?
13:12:50 <roconnor> iaefai: sadly we we do today (or what I do) is add type annotations until I figure out what is going wrong.
13:13:14 <kmc_> you can replace bits you don't have yet with "undefined"
13:13:31 <iaefai> kmc_: won't compile
13:14:25 <sproingie> i guess infinitely fast would be an oracle, not a real turing machine
13:14:28 <Vulpyne> You could put the function on hpaste and let people look at it.
13:14:36 <sproingie> "real turing machine", oxymoron of the day
13:14:59 <roconnor> Vulpyne: good suggestion
13:15:27 <dancor> you could also read the error messages you do get ::duck::
13:16:50 <iaefai> Vulpyne, quite true...  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12015#a12015
13:17:11 <iaefai> This code is based on code given on the beginner's list
13:17:38 <iaefai> Also of note: readConfig :: SourceName -> IO (Either ParseError ConfigMap)
13:17:59 <iaefai> data Config = Config { documentRoot :: String } deriving (Read, Show)
13:18:02 <Vulpyne> That second do is in the Error monad.
13:18:12 <Vulpyne> That's why it wants ParseError to have an Error instance.
13:18:38 <iaefai> The second do is supposed to be in the Either monad
13:18:44 <roconnor> iaefai: sadly (Either a) is not always a monad
13:19:23 <roconnor> because of mistakes in the standard libary
13:19:40 <iaefai> Why hasn't the standard library been fixed?
13:19:56 <Vulpyne> instance Error ParseError where noMsg _ = "blah"
13:20:00 <Vulpyne> Try that, and it'll probably compile.
13:20:32 <Vulpyne> Actually, not "blah" but something of a ParseError.
13:20:59 <roconnor> ah
13:21:08 <roconnor> it is only some error in the MTL
13:21:20 <roconnor> iaefai: stop using the MTL, and use a better transformer lib
13:21:35 <roconnor> iaefai: last I check MonadLib was good, but there maybe be newer even better ones
13:21:46 <roconnor> iaefai: are you using the haskell platform?
13:21:50 <iaefai> roconnor: yes
13:22:07 <roconnor> then also blame dons et al for including the broken MTL in the platform.
13:22:18 <iaefai> roconnor: The docs are broken for mtl too
13:22:32 <roconnor> I'm hoping with enough flack the MTL will be removed from the platform
13:22:49 <roconnor> the MTL was a great step forward when it was written
13:22:55 <roconnor> but we can do better today.
13:23:15 <iaefai> ok, monadlib is new as of march
13:23:19 <iaefai> so not too bad
13:25:32 <HugoDaniel> hi
13:25:52 <HugoDaniel> when is the next version of ghc planed to be release ?
13:26:02 <HugoDaniel> "when its ready" ? :)
13:26:25 <kmc_> HugoDaniel, this month or next
13:26:43 <kmc_> but the next Haskell Platform won't be ready for another 6 months or so
13:26:50 <camio> roconnor: If we stop using MTL, most stuff breaks, no?
13:26:52 <byorgey> HugoDaniel: there is a release candidate of it already. the only problem is cabal-install which doesn't work with it.
13:26:54 <kmc_> the idea being that library developers
13:26:59 <kmc_> need time to get their stuff to work
13:27:06 <byorgey> HugoDaniel: although darcs cabal-install does now, just a matter of time for it to be released.
13:27:15 <HugoDaniel> ah nice
13:27:19 <roconnor> hmm
13:27:35 <HugoDaniel> why are ghc releases always so disruptive ?
13:27:51 <kmc_> because the language and libraries are rapidly evolving
13:28:02 <roconnor> (Either a) doesn't seem to be an instance of ExceptionM in the monadLib
13:28:03 <HugoDaniel> hmm ok
13:28:19 <roconnor> are there any monad libraries that make (Either a) an instance of Monad for all a?
13:28:26 <dcoutts> byorgey: the darcs version now works btw
13:28:43 <dcoutts> byorgey: oh, you said that :-)
13:28:48 <iaefai> Is there a way I can write something with http://hackage.haskell.org/packages/archive/monadLib/3.5.2/doc/html/MonadLib.html#v%3ArunExceptionT
13:28:48 <iaefai> I just don't know how to use these functions
13:29:06 <byorgey> dcoutts: =)
13:29:19 <kmc_> the names for Either's constructors are symmetric
13:29:30 <kmc_> shouldn't we have another type if we want different behavior for Left vs. Right?
13:29:36 <kmc_> i.e., the monad instance, errors or not
13:30:10 <dcoutts> roconnor: what would the fail method do if it has to work for all 'a' ?
13:30:47 <kmc_> i could really do without Either and tuples
13:30:49 <roconnor> dcoutts: same as the fail method for Identity and State a and Writer a
13:31:02 <iaefai> kmc_: tuples are amazing!
13:31:06 <kmc_> this isn't like C++ where defining your own datatype is 60 lines of boilerplate
13:31:16 <kmc_> iaefai, what about them?
13:31:21 <Gracenotes> even though exceptions involve failing, 'fail' calling shouldn't be involved..
13:31:35 <iaefai> kmc_: I can't see how to do some things without them
13:31:43 <kmc_> tuples are particular examples of product types with special and (imo) worse syntax
13:31:45 <roconnor> kmc_: obviously Right is used for the right answers
13:31:59 <roconnor> and the other one is used for the wrong answers.
13:32:10 <skorpan> who chose the name "Left" anyways?
13:32:12 <Vulpyne> Left isn't Right, so it obviously must be Wrong.
13:32:38 <kmc_> iaefai, like what?
13:33:29 <iaefai> kmc_: [(String, Int)]  for exmaple
13:33:32 <jelly12gen> today i made an irc logging bot in haskell <3
13:33:44 <kmc_> iaefai, well, what do the String and the Int represent?
13:34:23 <iaefai> kmc, let us be [(string, string)] for a map
13:34:36 <iaefai> very easy to make a Map from this
13:35:09 <kmc_> in my tuple-less world, Data.Map would define "data MapElem k v = MapElem k v"
13:35:10 <Vulpyne> You could just do: data KV = KV String Int
13:35:26 <kmc_> this is clearly isomorphic to (a,b), but it makes it more clear *why* these values are paired
13:35:51 <roconnor> iaefai: If you want to use monadLib it seems you with either have to write an Instance Exception i (Either i), or probably better write a function foo (ExceptionM m i) => Either i a -> m a.
13:36:03 <kmc_> functions like "zip" would be made generic, so they'd work on any product type
13:36:06 <roconnor> or you can stick with the MTL and write an Error instance for ParseError.
13:36:22 <Saizan> kmc_: it'd be quite annoying, because you wouldn't have any combinators defined for MapElem, or you'd have to duplicate the tuple ones
13:36:28 <roconnor> foo (Left x) = raise x; foo (Right x) = return x
13:36:52 <kmc_> Saizan, not with combinators that are generic on the structure of algebraic data
13:36:53 <Pellwurst> can someone help me with this code: http://pastebin.com/m874bc11... i thought there should be an error in line 43, but there is not
13:37:13 <kmc_> why would there be?
13:37:27 <roconnor> iaefai: if you are a beginner it might be easier to write the Error instance for ParseError
13:37:27 <iaefai> roconnor: my use of Either is my own choice. readConfig :: SourceName -> IO (Either ParseError ConfigMap)  is my own function
13:37:35 <roconnor> ah
13:37:47 <kmc_> Pellwurst, you're trying to reimplement the ST monad as a "pure" state-threading monad?
13:37:53 <Saizan> kmc_: ah, ok, i didn't think you were proposing that :)
13:37:54 <roconnor> then you can replace it with IO (Exception ParseError CongfigMap)
13:38:03 <bos> nominolo: hi?
13:38:03 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:09 <iaefai> I am kind of sick of this function being left like this, so I am willing to do anything that works :P
13:38:26 <Pellwurst> kmc_: it's an exercise for a course of mine....
13:38:47 <nominolo> bos: I was wondering whether you had any ideas regarding http://code.google.com/p/scion-lib/issues/detail?id=37#c1
13:38:48 <sproingie> i've seen Right used for errors before, so it's not always about right/wrong.  Left short-circuits, Right does not, that's all
13:38:49 <iaefai> @hoogle Exception
13:38:50 <lambdabot> module Control.Exception
13:38:50 <lambdabot> Control.Exception class (Typeable e, Show e) => Exception e
13:38:50 <lambdabot> Control.OldException data Exception
13:39:07 <Saizan> iaefai: Exception from monadLib
13:39:12 <roconnor> iaefai: If you are looking for easy, write an Error instance for ParseError
13:39:19 <roconnor> heh
13:39:26 <roconnor> well
13:39:28 <Vulpyne> iaefai: What's the type of readConfig?
13:39:31 <roconnor> Saizan might be right.
13:39:40 <Pellwurst> i'm trying to implement a "polymorphic memory"
13:39:54 <roconnor> @hoogle ParseError
13:39:55 <lambdabot> Text.Parsec data ParseError
13:39:55 <lambdabot> Text.Parsec.Error data ParseError
13:39:55 <lambdabot> Text.ParserCombinators.Parsec data ParseError
13:39:57 <kmc_> sproingie, so:  data ShortCircuit a b = Short a | Don'tShort b
13:39:59 <Saizan> "ExceptionT ParseError IO ConfigMap" might be an even nicer type
13:40:00 <iaefai> Vulpyne: Pick one: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12016#a12016   :-)
13:40:00 <kmc_> much more descriptive
13:40:06 <bos> nominolo: i might have time to look at it tonight
13:40:13 <sproingie> kmc_: Short a | Long b :)
13:40:20 <Saizan> roconnor: the one from Control.Exception has no way to work :)
13:40:23 <nominolo> bos: sure, no hurry
13:40:30 <nominolo> I have other stuff to do as well
13:40:30 <kmc_> if the ctor names are "Left" and "Right" i should hope that by flipping everything my program stays the same
13:40:33 <sproingie> data ShortLong.  mistah jones!
13:40:44 <Vulpyne> iaefai: But it was originally Either?
13:41:10 <roconnor> Saizan: why do you say that?
13:41:18 <kmc_> Pellwurst, okay, so why did you expuect an error on line 43?
13:41:19 <iaefai> Vulpyne: yes, very little was changed  source: http://www.serpentine.com/blog/2007/01/31/parsing-a-simple-config-file-in-haskell/
13:41:30 <roconnor> Saizan: by the way ExceptionT ParseError IO ConfigMap is very nice
13:41:42 <sproingie> it's like Maybe but with a custom type instead of None
13:41:46 <sproingie> data Perhaps ...
13:41:48 <roconnor> It might even be possible to avoid the nested do with that.
13:41:52 <Saizan> roconnor: it's either a class (in base-4) or a type of kind *
13:41:59 <Saizan> roconnor: in base-3
13:42:17 <roconnor> oh yes
13:42:22 <iaefai> I am getting a little lost in the sea of suggestions, so bear with me :-)
13:42:40 <Pellwurst> kmc_: because i have an reference of type Ref Int (line 41) and i am writing a string into that (line 43)
13:42:44 <roconnor> iaefai: heh, sorry.
13:42:47 <sproingie> data Perhaps a b = Definitely a | Probably b
13:43:05 <kmc_> nice
13:43:14 <Saizan> iaefai: we're talking about this transformer http://hackage.haskell.org/packages/archive/monadLib/3.5.2/doc/html/MonadLib.html#t%3AExceptionT
13:43:27 <kmc_> Pellwurst, wait, by "error" you mean runtime?
13:43:27 <dons> project raincat!!
13:43:28 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:43:34 <Pellwurst> kmc_: my intention is, that the reference has a type and if there is a writeRef with the wrong type, it should produce an error
13:43:44 <Pellwurst> kmc_: yes, sry
13:43:49 <dons> http://raincat.bysusanlin.com/
13:43:51 <dons> omg omg omg
13:43:52 <Vulpyne> iaefai: You could just do: do { r <- readConfig filePath; case r of { Left err -> return $ Left err; Right ok -> return . Right . Config $ findWithDefault "web" "Document-Root" ok } couldn't you?
13:44:20 <iaefai> Vulpyne: let me try to translate that code...
13:44:34 <dons> shapr: check out project raincat.
13:44:36 <kmc_> Pellwurst, any reason to use your own monad instead of the standard State monad?
13:44:45 <kmc_> (There's also a monad named ST, but it's not very much like yours)
13:44:49 <Vulpyne> Or: readConfig filePath >>= either (return . Left) (return . Right . Config . findWithDefault "web" "Document-Root")
13:44:49 <Saizan> ?hackage raincat
13:44:50 <lambdabot> http://hackage.haskell.org/package/raincat
13:45:11 <kmc_> it also defines helpers that will make this code easier to write
13:45:26 <Pellwurst> kmc_: we got that in the course... i have to use it for the excerise
13:45:32 <kmc_> okay
13:45:45 <Vulpyne> iaefai: The examples I show were from when it was still just using Either.
13:46:00 <iaefai> That could work Vulpyne
13:46:13 <kmc_> Pellwurst, can you paste to a better bin like hpaste?  i can't copy from pastebin without line numbers
13:46:15 <iaefai> Another goal of this code is to be able to add values easily to my config type
13:46:40 <kmc_> it really loks like line 43 should be a *compile-time* error so i'm confused
13:46:49 <Vulpyne> iae: The error monad is nice if you want to do a whole bunch of things where it could fail at any point, but kind of overkill for what you're doing in that function (in my opinion at least)
13:46:55 <roconnor> iaefai: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12015#a12018
13:47:06 <Pellwurst> kmc_: yes, wait a sec.... (but there should be a second frame under the first one....without line numbers)
13:47:23 <kmc_> data Refinement a b = Finished a | Continue b
13:47:30 <kmc_> oh duh
13:47:31 <kmc_> thanks
13:47:34 * hackagebot upload: pcap 0.4.5 - A system-independent interface for user-level packet capture (BryanOSullivan)
13:47:35 <jmcarthur_work> huh sweet
13:47:57 <Botje> bos++
13:48:13 <iaefai> roconnor: Now would I need to get my readConfig to return an ExceptionT or something else?
13:48:23 <roconnor> iaefai: yes
13:48:27 <toki78> is a 3d physics engine available for haskell ?
13:48:29 <iaefai> Because this really doesn't speak to me as to what it is doing
13:48:36 <roconnor> iaefai: in your readConfig instead of return (left foo)
13:48:45 <roconnor> iaefai: you say raise foo
13:48:53 <Pellwurst> kmc_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4897#a4897
13:49:01 <kmc_> thanks
13:49:29 <dons> toki78: there are some alpha-status pure haskell ones
13:49:36 <dons> and bindings to external ones.
13:49:37 <roconnor> iaefai: unless I'm mistaken.
13:49:45 <toki78> hey cool - for ODE ?
13:50:10 <iaefai> roconnor: My readConfig calls return with a case expression with Left and Right in it
13:50:35 <toki78> dons, for ODE ?
13:50:36 <jmcarthur_work> raincat isn't cabalized :(
13:50:58 <camio> raincat makes Haskell look shiny.
13:51:07 <roconnor> iaefai: what type are you casing on?
13:51:13 <jmcarthur_work> <3 raincat
13:51:15 <iaefai> Either
13:51:16 <jmcarthur_work> just from the art
13:51:23 <roconnor> iaefai: is the code small enough to paste?
13:51:35 <roconnor> iaefai: I have some suggestions, but it'd be easier to look at it.
13:51:47 <mtnviewmark> sort of icky that they have two forks of the code - one for windows, one for linux --
13:52:06 <roconnor> iaefai: even just pasting the return statement might be enough if the whole function is too big
13:52:13 <kmc_> Pellwurst, i see the problem
13:52:17 <kmc_> your types "Ref a" are all the sam
13:52:20 <kmc_> they're all Int
13:52:21 <iaefai> roconnor: Two versions at the bottom: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12020#a12020    The first is the one I am using, the second one is something that is closer to understanding
13:52:25 <kmc_> thus they're fungible
13:52:52 <kmc_> you have a phantom (unused) type parameter, which is correct for this task, but since it's a type synonym it gets you nothing
13:53:01 <kmc_> you should probably use "newtype Ref a = Ref Int"
13:53:01 <roconnor> iaefai: excellent
13:53:25 <roconnor> iaefai: Left err -> Left err is a classic sign that the case statement should be replace by bind.
13:53:42 <Pellwurst> kmc_: but then they have all the same tyme again, havent they?
13:53:45 <Vulpyne> There's no OS X Raincat. :(
13:53:49 <kmc_> no
13:53:56 <kmc_> with the newtype, Ref Int and Ref () are different types
13:53:59 <iaefai> roconnor: I am not with the Monad game quite yet, just going through what I can so far
13:54:03 <kmc_> even though they have the same representation
13:54:07 <dibblego> roconnor, fmap in this case
13:54:20 <kmc_> (types exist to state and prove correctness properties of programs, not to specify representation)
13:54:30 <kmc_> with "type" they are both synonyms for "Int"
13:54:32 <dibblego> iaefai, fmap (Map.fromList . reverse) result
13:54:46 <roconnor> iaefai: I finally groked monads when I replaced my nested series of Nothing -> Nothing case satements with nice clean do notation.
13:55:17 <roconnor> dibblego, we have to be careful here because Either ParseError isn't a monad.
13:55:30 <Pellwurst> kmc_: ah, ok.... so if i would use type, it had to be "type Ref a = (Int, a) or something.....
13:55:36 <roconnor> iaefai: do you have control over parseFromFile?
13:55:39 <kmc_> that'd be totally different
13:55:42 <dibblego> roconnor, yeah bit annoying
13:55:47 <iaefai> roconnor: Not directly
13:55:50 <kmc_> because now you're actually storing a value of type a
13:55:53 <iaefai> It is a parsec function
13:56:04 <kmc_> with "newtype Ref a = Ref Int" you do not store a value of type a
13:56:11 <kmc_> "a" is a "phantom" type parameter; it's not used on the RHS
13:56:12 <roconnor> iaefai: okay, we will leave be and interface between Either and Excpetion right here.
13:56:23 <kmc_> also i don't know if you care but the (!!) operator on lists is quite inefficient.  your memory will get slower as more things are added
13:56:28 <iaefai> roconnor: Awesome
13:56:30 <kmc_> i'd use an IntMap
13:56:31 <roconnor> iaefai: we will do transformations to your code
13:56:34 <kmc_> instead of a list
13:56:37 <Pellwurst> kmc_: k, i see the difference and i'll giv it a try. thanky for your help
13:56:37 <roconnor> iaefai: aka refactoring
13:56:50 <roconnor> iaefai: step 1, push the return into each brach of the case statement.
13:57:01 <iaefai> ok, I shall do so
13:57:25 <roconnor> iaefai: step 2, now we have suitable control over the branches to change our return type
13:57:35 <roconnor> iaefai: replace return (Left err) with raise err
13:57:39 <iaefai> Step 1: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12020#a12021
13:57:50 <roconnor> iaefai: replace return (Right foo) with return foo.
13:58:15 <iaefai> roconnor: ok, I need to import the right lib now, one moment
13:58:19 <roconnor> np
13:59:37 <iaefai> Parsec's try and Monadlib's try do not like each other
13:59:52 <iaefai> I will do an import qualified on monadlib
14:00:30 <iaefai> SimpleConfig.hs:1:0:
14:00:30 <iaefai>     Couldn't match expected type `ParseError'
14:00:30 <iaefai>            against inferred type `GHC.Exception.SomeException'
14:00:33 <mulletron> does anyone know where cabal info package-name gets its information from?
14:00:34 <iaefai> Not sure what to make of that
14:00:49 <mulletron> or perhaps why it would claim the installed version is 'unknown'
14:00:49 <roconnor> iaefai: use MonadLib.raise
14:00:50 <mulletron> ?
14:00:51 <kmc_> @hoogle (Monad m) => m a -> m b -> m c -> m b
14:00:52 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
14:00:52 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
14:00:52 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
14:01:07 <kmc_> oh good suggestion
14:01:12 <iaefai> roconnor: I certainly am
14:01:13 <dcoutts> mulletron: the hackage index
14:01:18 <kmc_> :t liftM3 (\_ x _ -> x)
14:01:19 <lambdabot> forall a1 a2 a3 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a3 -> m a2
14:01:23 <iaefai> roconnor: Can we move into #haskell-in-depth
14:01:26 <HugoDaniel> is the next version of ghc going to feature the gcc 4.3 runtime ? :D
14:01:26 <dcoutts> mulletron: which is the thing it downloads when you run cabal update
14:01:29 <kmc_> @pl (\_ x _ -> x)
14:01:30 <lambdabot> const const
14:01:35 <roconnor> iaefai: #haskell-overflow
14:01:47 <mulletron> dcoutts: where is that located?
14:02:10 <dcoutts> mulletron: under ~/.cabal/packages/$server/00-index.tar
14:02:32 <mulletron> dcouts++
14:03:12 <dcoutts> mulletron: do you have any particular application in mind?
14:04:11 <mulletron> well, I'm trying to compile lambdabot
14:04:19 <mulletron> which requires happy
14:04:26 <mulletron> which doesn't seem to install via cabal
14:04:39 <mulletron> but I managed to compile happy from source
14:04:49 <mulletron> but it lists my installed version as unknown :(
14:05:10 <dcoutts> mulletron: it will install via cabal, but you probably do not have its bin dir on your $PATH
14:05:34 <dcoutts> mulletron: it's really a bug that it lists it as unknown
14:05:49 <dcoutts> it should not list it's installed state at all, since it does not track executables
14:06:32 <mulletron> hmm, can I convinced cabal that its installed at all?
14:06:43 <mulletron> for the purpose of satisfying the dependancy in lambdabot?
14:06:47 <HugoDaniel> i know this is not entirely haskell related, but has anyone seen this: http://lambda-the-ultimate.org/node/3674 ?
14:06:55 <HugoDaniel> there are some great optimization tricks in that presentation
14:07:17 <HugoDaniel> i was wondering to what extent might that help out, if ghc shipped with gcc 4.3 runtime :P
14:07:27 <dcoutts> mulletron: it'll be in your ~/.cabal/bin, either put that on your path, or if you only want it as a one-off then use cabal install blah --with-happy=$HOME/.cabal/bin/happy
14:07:40 <kmc_> the point of the talk is mostly that you shouldn't worry about the tricks
14:07:44 <kmc_> unless you are writing a compiler
14:07:47 <mulletron> I'll try that, thanks a lot dcoutts
14:08:02 <kmc_> they show how "clever" C code produces counterproductive results
14:08:25 <HugoDaniel> kmc_: yes, but i was amazed by how smart gcc 4.3 really is
14:08:30 <kmc_> also i don't know what you mean by the gcc 4.3 runtime
14:08:39 <kmc_> it's pretty good.  icc is still better i think
14:08:40 <skorpan> is readFile lazy?
14:08:40 <HugoDaniel> i mean, the other compilers didn't reach the same level of optimizations that gcc did
14:08:49 <HugoDaniel> kmc_: not according to that presentation
14:08:55 <HugoDaniel> gcc 4.3 really wipes the floor
14:11:42 <skorpan> i'm writing a lexer for an indentation-dependent language i made up.  do i make indentation a token itself?
14:12:31 <PeakerWork> skorpan: that's what Python does.  INDENT and DEDENT
14:12:36 <PeakerWork> skorpan: as easy as { and }
14:12:50 <skorpan> cool...
14:13:19 <periodic> Basically every time you see a new indent level you add a '{' and when it dedents you add a '}'.  It's basically just desugaring.
14:13:39 <skorpan> but i also have to keep track of what the latest level of indentation was, don't i?
14:14:17 <skorpan> i guess i do
14:14:20 <skorpan> this will be interesting
14:15:12 <skorpan> :t lex
14:15:13 <lambdabot> String -> [(String, String)]
14:15:15 <Cale> You have to keep track of all the levels of indentation
14:15:15 <skorpan> wtf
14:15:28 <Cale> (in a stack)
14:15:30 <ben_m> > lex "woo"
14:15:32 <lambdabot>   [("woo","")]
14:15:40 <centrinia> > lex "woo hoo"
14:15:41 <lambdabot>   [("woo"," hoo")]
14:16:10 <skorpan> Cale: but not while lexing, do i?
14:16:44 <Cale> skorpan: not while lexing, but depending on whether you do lexing or indentation first...
14:17:08 <skorpan> i don't follow
14:18:25 <Cale> You could make indentation a token while lexing, and then work out how to insert braces and semicolons from that information in your stream of lexed tokens, or you can translate away indentation first, inserting braces and semicolons, and then do lexing after that.
14:18:25 <skorpan> what would "doing indentation first" mean?
14:18:36 <skorpan> aha, i see
14:19:08 <skorpan> but i still don't see how that would require me to use a stack :(
14:19:32 <Cale> While translating indentation, you need to keep a stack of the previously entered indentation levels
14:19:39 <skorpan> oh, right
14:19:51 <Cale> So that you know how many closing braces to insert when your indentation level drops
14:20:14 <skorpan> if something
14:20:14 <skorpan>     do_something()
14:20:14 <skorpan>   freak_out()
14:20:16 <JohnnyL> in:     isPrefixOf :: (Eq a) => [a] -> [a] -> Bool     what is 1) Eq and 2) => ?
14:21:03 <skorpan> JohnnyL: Eq is a typeclass, Eq a => means "to the right of this arrow, a must be a type which is an instance of Eq"
14:21:03 <Cale> JohnnyL: Eq is the class for types for which we can compare equality
14:21:19 <Cale> and => is a bit of syntax which separates typeclass constraints from the rest of the type
14:21:31 <Cale> :t (==)
14:21:32 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:22:49 <JohnnyL> skorpan, Cale much thanks!
14:22:50 <JohnnyL> :)
14:23:57 <gerard_1> `par` + infinite lists + recursion..... anyone has some tips&tricks for staying sane?
14:26:11 <Polarina> foldl (+) 0 [1.0..] == Inf
14:27:02 <__JN> Hello, I'm trying to patternmatch a textfile, I want to catch a sequence of: "char (not a digit):8 digits:arbitrary number of digits:char" is there a smart way to do that? The result I want is the 8 first digits in that sequence.
14:27:16 <mulletron> dcoutts: if I want to compile lambdabot to use it on another network, do I just edit the online.rc file and recompile?
14:27:59 <dcoutts> mulletron: I know almost nothing about the internals of lambdabot :-)
14:28:10 <mulletron> ahh
14:28:23 <mulletron> ohloh listed you as having made commits to it ;)
14:28:43 * mulletron realises that was 3 years ago!
14:28:48 <mulletron> but thanks anyhow
14:29:37 <dcoutts> mulletron: all I did was add the right strings for:
14:29:40 <dcoutts> @yarr!
14:29:40 <lambdabot> What be a priate's favourite cheese?
14:29:40 <lambdabot> Yarrlsburg!
14:29:44 <dcoutts> and
14:29:46 <dcoutts> @arr!
14:29:46 <lambdabot> I want me grog!
14:30:04 <mulletron> heh
14:30:07 <mulletron> awesome
14:30:12 <wdonnelly> __JN: the best solution is probably to use Parsec to parse your file
14:30:16 <mulletron> tbh, I'm still trying to figure out how to run it !
14:33:06 <Saizan_> mulletron: you don't need to recompile it to change what's in online.rc
14:33:34 <Saizan_> mulletron: you just invoke it like "lambdabot -e 'rc online.rc'" and it loads the commands in there
14:35:03 <__JN> wdonnelly: Ok, then off to Parsec it is.
14:35:05 <mulletron> Saizan_: thanks, yeah I've just realised that!
14:38:26 <llayland> rebuilding an old laptop here. Is there a prefered linux distro for the Haskell platform?
14:38:43 <ivanm> llayland: a few distros have it
14:39:05 <ivanm> in terms of packages not in the platform installed at the system level, arch and gentoo are probably the top two
14:39:55 <m3ga> llayland: debian unstable also has it. you can run a debian testing machine and just pull haskell packages from unstable
14:40:16 <m3ga> it should also be in ubuntu 10.4
14:43:07 <llayland> is 10.4 unstable?
14:43:48 <mulletron> is there any viable reason why lambdabot would connect to a network, but not join a channel?
14:44:47 <jthing> no
14:45:12 <jthing> But I can see that the logic is simper that way
14:45:33 <Vulpyne> The channel could be invite only or have a key.
14:45:39 <jthing> Not that I'm a expert
14:45:47 <saml> do { let io = $(IO); let io2 = $(IO);  let state = $(State Int Int); state.put 1; x <- state.get; io2.putStrLn (show x) }   can i do this?
14:46:45 <jthing> Vulpyne, I doubt it
14:46:49 <PeakerWork> saml: are you asking if you can compose multiple monads together?
14:46:54 <PeakerWork> saml: Like State and IO?
14:47:05 <saml> PeakerWork, yes and name them so that i don't have to lift . lift . lift .lift
14:47:12 <mlesniak> What was the name of the benchmarking tool/utlity which released a new version a few days ago? Can't remember its name? Cer...?
14:47:34 <sm> criterion
14:47:37 <jthing> Vulpyne, ti could but it wouldnt serve much of a purpose for a aspiring language
14:47:48 <mlesniak> sm: Right, Thanks!
14:48:14 <saml> like, using template haskell to generate trasformer easily
14:48:51 <PeakerWork> saml: you can use:  newtype MyMonad a = MyMonad { StateT Int IO a } deriving (Monad, MonadIO, ...) ; liftState = MyMonad        then use: do { liftState $ put 1; x <- liftState get ; liftIO $ putStrLn (show x) }
14:48:59 <PeakerWork> saml: btw: putStrLn . show = print
14:49:15 <PeakerWork> saml: I don't think there's a lot of need for that. Just define a newtype and give your lifters names
14:49:39 <PeakerWork> saml: a newtype around your stack and then:  liftLayerA = MyNewType ; liftLayerB = MyNewType . lift ; liftLayerC = MyNewType . lift . lift
14:49:49 <PeakerWork> saml: then you have:  liftLayerA $ <operation>
14:50:05 <PeakerWork> saml: maybe even s/lift// so its   layerA $ <operation>  ; layerB $ <operation>
14:50:45 <saml> PeakerWork, oh you are so smart.
14:51:00 <PeakerWork> saml: EvilTerran taught me that...
14:51:55 <jthing> I'm mostly as Lisper. Got any recomended doc's?
14:52:30 <jthing> I have laready read 'Real world Haskell'
14:53:31 <jthing> What bothers me (as usual) is the mathematical foundtions of Monads.
14:53:50 <PeakerWork> jthing: what about them?
14:53:50 <jthing> Which I don't fully understand.
14:54:22 <PeakerWork> jthing: do you understand the monad laws? (return is the neutral element at left and right, and >>= is associative)
14:55:03 <jthing> PeakerWork, Yeah, iI got the law, very topologically
14:55:22 <jthing> I am having trouble with it's ramifications
14:55:56 <ddarius> jthing: The ramifications are not the "foundation" of monads, the laws are.
14:56:14 <jthing> right
14:56:25 <ddarius> Perhaps you meant "intuitive motivation" as opposed to "foundation."
14:56:44 <Vulpyne> The way I ended up understanding them was to use them for practical stuff.
14:56:47 <jthing> That's more what I meant,yes.
14:58:19 <PeakerWork> jthing: basically, the meaning of the laws is really that "return" cannot create an (m a) where the "m" has any effects.  And that there's no difference between:  (a >> b) >> c  and (a >> (b >> c)) (with >>= too but more cumbersome syntax)
14:58:42 <reltuk> I think if you just write programs in haskell they will become more clear
14:58:42 <PeakerWork> jthing: the "ramifications" of associativity are really that whether a "do" block calls another do block or inlines that do block within it doesn't matter
14:58:52 <PeakerWork> s/are really/some of them are :)
14:59:17 <jthing> PeakerWork, That much I got
14:59:48 <PeakerWork> jthing: do you understand why it is important for do blocks to be right-associative for the Maybe monad?
15:00:00 <PeakerWork> s/it is/it may be
15:04:32 <jthing> I've been reading Simon Jones work in Software Transational Memory and I've got kinda hooked..
15:04:46 <jthing> What a great idea
15:05:45 <jthing> It's basically how sound Monads are for isolating critical sectors I am interested in
15:05:48 <mulletron> @run 1 + 2
15:05:49 <lambdabot>   3
15:06:17 <PeakerWork> jthing: what about monads like list?
15:07:27 <jthing> PeakerWork, If you had said queues, I would know what you wrere talking about
15:08:57 <PeakerWork> jthing: I am talking about the list monad
15:09:19 <PeakerWork> instance Monad [] where return x = [x] ; (>>=) = flip concatMap
15:09:40 <PeakerWork> > filterM (\x -> [True,False]) [1..3]
15:09:41 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
15:10:53 <PeakerWork> jthing: The list monad allows me to have a computation that chooses multiple things, and the whole computation takes all possible paths, yielding all possible results.  So here, I filter the list [1,2,3] with a monadic predicate -- which is allowed to return both "filter element", and "don't filter element". So you get all possible lists where each element is both filtered and not
15:12:37 <kmc_> skorpan, did you see how the Haskell Report does indentation?
15:12:57 <skorpan> kmc_: i'm not sure i know what the haskell report is
15:13:06 <kmc_> it's the standard that defines the Haskell language
15:13:12 <skorpan> haskell 98?
15:13:25 <kmc_> http://www.haskell.org/onlinereport/ see 2.7 and 9.3
15:13:26 <kmc_> yes
15:14:05 <kmc_> anyway they basically give the algorithm to interpret indentation as a haskell function
15:14:57 <skorpan> cool
15:16:12 <leimy_> if I have a ReaderT StateT stack, in that order.  Do I want to do runReader then execState or execState and runReader?
15:16:33 <kmc_> runStateT i think
15:16:37 <kmc_> err runReaderT
15:16:40 <kmc_> then runStateT on that
15:16:43 <skorpan> NO WAIT
15:16:52 <BONUS> umm is it ReaderT r (StateT s m)
15:17:00 <BONUS> or StateT s (ReaderT r m)
15:17:36 <m0nkfish> man.. i tried to load the triangle in problem 67 of project euler and haskell broke :(
15:17:45 <leimy_> It's ReaderT r (StateT s IO ())
15:17:47 <leimy_> actually :-)
15:17:56 <PeakerWork> leimy_: if the outer layer is a ReaderT, you have to runReaderT first, to get a StateT result
15:18:00 <kmc_> skorpan, i've implemented this and the basic idea was i) parse "actual" tokens along with column info ii) strip the column info but insert begin-of-line markers (the <n> and [n] tokens from 9.3) iii) apply the function from 9.3 iv) Parsec parser on those tokens as the primitive type
15:18:09 <BONUS> so ReaderT r (StateT s IO) () :)
15:18:18 <leimy_> yeah :-)
15:18:19 <leimy_> thanks
15:18:35 <leimy_> Anyway, I've got all my state updates internally, running the Monad in an infinite loop
15:18:37 <kmc_> so i invoked parsec twice, once as a CharParser () Token, then once as a Parser Token () a
15:18:44 <m0nkfish> i have a list with 100 elements, each of those elements is a list with range 1-100
15:18:51 <kmc_> with the translation in between
15:18:52 <m0nkfish> how might this break ghci
15:18:53 <leimy_> I need to re-run with new states, because I'm exhausting memory
15:18:54 <leimy_> it's bad :-)
15:19:02 <kmc_> m0nkfish, that's a very vague question
15:19:05 <kmc_> what do you mean
15:19:09 <kmc_> > replicate 100 [1..100]
15:19:11 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:19:15 <m0nkfish> : panic! (the 'impossible' happened)
15:19:15 <m0nkfish> (GHC version 6.10.1 for i386-unknown-mingw32):
15:19:15 <m0nkfish> linkBCO: >= 64k insns in BCO
15:19:15 <m0nkfish> Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug
15:19:18 <kmc_> > length $ concat $ replicate 100 [1..100]
15:19:19 <lambdabot>   10000
15:19:20 <kmc_> oh jesus
15:19:20 <skorpan> kmc_: got it, thanks
15:19:23 <m0nkfish> apparently the impossible happened
15:19:25 <BONUS> yeah you furst runReaderT and apply the r to it and you get a StateT
15:19:30 <skorpan> > length $ concat $ replicate 100 [1..10000]
15:19:31 <lambdabot>   1000000
15:19:33 <skorpan> > length $ concat $ replicate 100 [1..100000]
15:19:35 <lambdabot>   10000000
15:19:37 <BONUS> then you runStateT that and apply the s and you get IO (a, s)
15:19:42 <BONUS> imo
15:19:44 <m0nkfish> think of a pascal's triangle
15:19:45 <kmc_> m0nkfish, wow
15:19:47 <skorpan> > length $ concat $ replicate 100 [1..100000000]
15:19:47 <m0nkfish> with height 100
15:19:52 <kmc_> m0nkfish, can you isolate the code?
15:19:54 <lambdabot>   mueval: ExitFailure 1
15:20:01 <m0nkfish> http://projecteuler.net/project/triangle.txt
15:20:06 <m0nkfish> i have this, but in list form
15:20:12 <m0nkfish> so with , and [] where necessary
15:20:16 <kmc_> oh in your source?
15:20:20 <m0nkfish> yus
15:20:21 <kmc_> it might not like large literals like that
15:20:24 <m0nkfish> :[
15:20:28 <m0nkfish> can i import them then?
15:20:29 <kmc_> you can parse it easily
15:20:42 <m0nkfish> cool, how?
15:21:20 <kmc_> > (map (map read . words) $ lines "1\n2 3\n4 5 6\n") :: [[Int]]
15:21:25 <lambdabot>   mueval-core: Time limit exceeded
15:21:30 <kmc_> uhm
15:21:38 <m0nkfish> :[
15:21:46 <kmc_> it works in my ghci
15:21:51 <kmc_> i think lambdabot is still constipated
15:21:55 <Cale> odd
15:21:58 <Cale> > ()
15:22:00 <lambdabot>   ()
15:22:03 <kmc_> @bot
15:22:03 <lunabot>  :o
15:22:04 <lambdabot> :)
15:22:06 <leimy_> It seems like if you loop forever inside an evalStateT, and you're doing lazy Data.Map insertions, you exhaust memroy
15:22:08 <Cale> > (map (map read . words) $ lines "1\n2 3\n4 5 6\n") :: [[Int]]
15:22:10 <lambdabot>   [[1],[2,3],[4,5,6]]
15:22:10 <leimy_> er memory
15:22:15 <Cale> huh
15:22:18 <leimy_> even if you're using the same keys over and over
15:22:22 <Cale> random bad luck, I guess
15:22:23 <leimy_> because the thunks just build up.
15:22:31 <mulletron> if I'm running a lambdabot instance, and everytime I try to @run something, and all I get is 'terminated' - is that a common error at all?
15:22:32 <BONUS> fmap ((map . map) read . map words . lines) getContents :: IO [[Int]]
15:22:42 <Vulpyne> Probably want to use insertWith'
15:22:44 <kmc_> :t (map . map)
15:22:45 <Cale> mulletron: that means you don't have mueval working usually
15:22:46 <mulletron> I have mueval installed fyi
15:22:47 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
15:22:59 <m0nkfish> so how do i take my input of triangle.txt and load it into a list
15:23:28 <mulletron> Cale: is there any way to test mueval?
15:23:52 <kmc_> m0nkfish, you're testing stuff in ghci?
15:24:25 <Cale> mueval -e "2 + 2"
15:25:04 <ivanm> I thought running lambdabot here in #haskell was the test suite for mueval...
15:25:06 <ivanm> ;-)
15:25:06 <m0nkfish> kmc_ yeah
15:25:10 <kmc_> one sect
15:25:11 <kmc_> sec*
15:25:31 <ezyang> kitties in Haskell! http://raincat.bysusanlin.com/
15:25:32 <m0nkfish> if i could just import this list then i can apply my function to it and solve the problem :)
15:25:35 <Cale> xs <- readFile "triangle.txt"
15:25:40 <ezyang> but the code looks procedural... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12027#a12027
15:26:02 <mulletron> yeah that looks like it Cale, thanks
15:26:08 <m0nkfish> Cale, what will the type of xs be
15:26:20 <Cale> m0nkfish: String
15:26:27 <jmcarthur_work> wow that is very imperative
15:26:33 <aavogt> ezyang: you're aware that you don't need to write 'let' as many times as you did?
15:26:38 <kmc_> m0nkfish, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12028#a12028
15:26:38 <m0nkfish> and then i use (map (map read . words) $ lines "1\n2 3\n4 5 6\n") :: [[Int]]
15:26:49 <ezyang> aavogt: I'm quoting some code from Raincat
15:26:52 <kmc_> in GHCi "t <- getTri"
15:26:57 <kmc_> now t is your triangle as [[Int]]
15:27:01 <SimonRC> ezyang: do you suppose that qualifies for going on Lambdacats?
15:27:03 <ezyang> They get + points for using Haskell, but - points for using so many lets
15:27:16 <BONUS> haha nice redundancy
15:27:19 <ezyang> SimonRC: Oh, definitely.
15:27:26 <sproingie> haskell's a perfectly good imperative language
15:27:29 <leimy_> If I'm profiling with -hy, what is PAP?
15:28:00 <SimonRC> my preferred phrasing is "Haskell: also the world's best imperative language".
15:28:18 <ezyang> Haha :-)
15:28:35 <ivanm> ezyang: well, IMHO if it isn't on hackage it doesn't exist! (barring old pre-hackage libs/apps like gtk2hs, of course)
15:28:36 <ivanm> ;-)
15:28:38 <SimonRC> things are final by default
15:28:39 <kmc_> m0nkfish, which pe problem is this?
15:29:02 <leimy_> ah, a partial function application
15:29:07 <kmc_> SimonRC, indeed, separating functions and imperative actions improves both worlds *and* the cooperation between them
15:29:15 <jmcarthur_work> sproingie, sure, but that doesn't mean everything you do in haskell should be imperative :P
15:29:19 <leimy_> I'm being killed by laziness... :-(
15:29:22 <SimonRC> and things STM and all those combinators and first-class refs are nice too
15:29:40 <kmc_> @hoogle IO a -> IO a
15:29:40 <lambdabot> Network withSocketsDo :: IO a -> IO a
15:29:41 <lambdabot> Control.Exception block :: IO a -> IO a
15:29:41 <lambdabot> Control.OldException block :: IO a -> IO a
15:30:19 <BONUS> @hoogle (a -> IO r) -> IO r
15:30:20 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
15:30:20 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
15:30:20 <lambdabot> Foreign.Marshal.Pool withPool :: (Pool -> IO b) -> IO b
15:30:23 <kmc_> "while", "for", "try", "with" are all extensible library functions rather than magic
15:30:31 <kmc_> defining and spawning a thread is one line of code
15:30:36 <sinelaw> Do You Capitalize Your Section Titles?
15:30:40 <SimonRC> kmc_: yeah
15:30:58 <leimy_> like I have 300+ KB of PAP
15:31:04 <leimy_> in 25 seconds
15:31:33 <SimonRC> I find the parallel evaluation stratergies' use of laziness to split evaluation order from definition really neat-looking (I haven't used it yet)
15:32:21 <ezyang> wow... lambdacats are qwality :3
15:32:51 <kmc_> > foldl' f e [x,y,z]
15:32:52 <lambdabot>   f (f (f e x) y) z
15:33:05 <kmc_> > foldl' (flip f) e [x,y,z]
15:33:06 <lambdabot>   f z (f y (f x e))
15:33:12 <kmc_> > foldr f e [x,y,z]
15:33:14 <lambdabot>   f x (f y (f z e))
15:33:40 <m0nkfish> kmc_ it was #67
15:33:48 <m0nkfish> i solved it for #18 and #67 is just a larger version
15:34:00 <m0nkfish> so my only obstacle was actually loading the damn triangle!
15:34:08 <kmc_> haha
15:34:12 <kmc_> are you using memoization?
15:34:26 <m0nkfish> i don't know x)
15:34:34 <m0nkfish> count = foldr1 (\xs ys -> zipWith (+) xs (maxPairs ys))
15:34:35 <m0nkfish> where
15:34:35 <m0nkfish> maxPairs xs = zipWith max xs (tail xs)
15:34:50 <m0nkfish> this was my function, pretty simple!
15:35:44 <m0nkfish> i am basically using project euler as a way to practice my haskell-fu
15:35:49 <kmc_> yeah it's good for that
15:35:53 <kmc_> i'm not sure i could explain how your solution works
15:36:47 <m0nkfish> the key is to start from the base
15:36:53 <SimonRC> I get a bit stuck with problems that require summing the first 2000000 primes or whatever
15:37:06 <SimonRC> I can't get the speed
15:37:21 <kmc_> in Haskell?
15:37:30 <PeakerWork> @let x `divides` y = x `mod` y == 0
15:37:31 <m0nkfish> zipWith max xs (tail xs) finds the max of each pair in a list to form a list with length n-1
15:37:32 <lambdabot>  Defined.
15:37:45 <m0nkfish> then zipWith (+) just adds it to the next highest row
15:37:49 <m0nkfish> foldr1 folds it all up to the top
15:37:50 <PeakerWork> > nubBy divides [2..]
15:37:52 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:38:01 <kmc_> keep in mind that GHCi bytecode-interprets your input, so it may be much faster to put it in a file and build with: ghc --make -O3 -o myprog myprog.hs
15:38:12 <PeakerWork> > sum . take 2000000 . nubBy divides $ [2..]
15:38:16 <kmc_> iirc you can still load that code in ghci and it will use the compiled version as long as it's up to date
15:38:16 <lambdabot>   mueval-core: Time limit exceeded
15:38:22 <PeakerWork> > foldl' (+) 0 . take 2000000 . nubBy divides $ [2..]
15:38:24 <m0nkfish> cool
15:38:26 <lambdabot>   mueval-core: Time limit exceeded
15:38:39 <kmc_> :t nubBy
15:38:41 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
15:38:43 <tromp_> nubBy is quadratic time...
15:38:53 <jlouis> m0nkfish: yeah, solving it by a dynamic programming approach is the way to go
15:38:58 <PeakerWork> tromp_: how do you do primes easily at better than that?
15:39:00 <m0nkfish> this gives a list of primes?: nubBy divides [2..]
15:39:07 <PeakerWork> m0nkfish: yeah
15:39:12 <m0nkfish> jlouis yeah dynamic programming is just so neat :)
15:39:36 <jlouis> ... when it works :)
15:39:42 <m0nkfish> haha of course
15:39:52 <kmc_> i find it's easiest to write DP as memoized recursion
15:39:54 <tromp_> google for Primes.hs ?
15:39:58 <kmc_> but that's a lot shorter and more clever
15:40:10 <m0nkfish> memoized is using an accumulator?
15:40:21 <mulletron> @type 1
15:40:22 <lambdabot> forall t. (Num t) => t
15:40:28 <kmc_> memoized is "transparently" remembering the results of a previous call with the same argument
15:40:46 <kmc_> see Data.MemoCombinators from the data-memocombinators package
15:40:49 <tromp_> @let primes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x)primes)]
15:40:51 <lambdabot>  Defined.
15:41:01 <tromp_> > primes
15:41:02 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:41:18 <m0nkfish> tromp surely x<-[3,5..]
15:41:23 <jasonmay> > take 5 (primes)
15:41:24 <lambdabot>   [2,3,5,7,11]
15:41:27 <jasonmay> > take 5 primes
15:41:29 <lambdabot>   [2,3,5,7,11]
15:41:36 <gOcOOl> given this list: [(ByteString, Int)], is there anyway of printing this list other than by calling unpack on fst? The requirement is to not have those "chunk, empty" markers associated with ByteStrings in the output
15:41:37 <SimonRC> I wrote a naive implementation of infinte-heap-of-queues to help merge streams of all multiples of all primes, before finding that paper about how the usual haskell sieve of erasthonese isn't the sieve at all gives a much better infinite in the form of a finite heap plus an infinite list
15:41:42 <SimonRC> d'oh
15:41:55 <m0nkfish> O_O
15:42:06 <SimonRC> *finding that that paper
15:42:15 <jasonmay> primes !! 10
15:42:17 <tromp_> > primes!!2000000
15:42:18 <jasonmay> > primes !! 10
15:42:19 <lambdabot>   31
15:42:21 <lambdabot>   mueval-core: Time limit exceeded
15:42:28 <SimonRC> hey, what's the point of a fully-recursive grammar if you aren't going to abuse it occasionally
15:42:30 <jmcarthur_work> gOcOOl, if you want pretty printing you should probably write your own function for it
15:42:31 <tromp_> > primes!!200000
15:42:32 <SimonRC> ?
15:42:36 <lambdabot>   mueval-core: Time limit exceeded
15:42:38 <tromp_> > primes!!20000
15:42:42 <lambdabot>   mueval-core: Time limit exceeded
15:42:52 <tromp_> > primes!!2000
15:42:53 <lambdabot>   17393
15:42:57 <tromp_> ouch
15:43:26 <yairchu> > primes!!2
15:43:28 <lambdabot>   5
15:43:33 <gOcOOl> jmcarthur_work: I just want something that unpack does but without the penalties in speed asscoiated with calling unpack on a huge list
15:43:36 <jasonmay> > take 5 fibs
15:43:37 <lambdabot>   Not in scope: `fibs'
15:43:52 <Saizan_> gOcOOl: you can use putStr directy from Data.ByteString.Char8 on the ByteString's, but you'd also need to deal with properly printing the rest, instead of calling a single show
15:44:38 <Saizan_> gOcOOl: or, make a newtype of ByteString with the desired Show instance
15:45:23 <Saizan_> (btw, Data.ByteString.Lazy.Char8 if you're using lazy bytestrings)
15:45:31 <jmcarthur_work> but the Show instance would imply unpacking anyway
15:45:39 <Saizan_> gOcOOl: ah, actually, this second option won't really work
15:45:48 <Saizan_> because of what jmcarthur_work said :)
15:46:14 <kmc_> @instances Floating
15:46:15 <lambdabot> Double, Float
15:46:21 <gOcOOl> hmmm ok
15:46:33 <jmcarthur_work> could instead write something like [(ByteString, Int)] â ByteString and then print that using the appropriate putStr action
15:46:46 <jmcarthur_work> if it's lazy, at least
15:47:41 <Saizan_> gOcOOl: this seems exactly what you need  http://hackage.haskell.org/package/bytestring-show
15:48:08 <stroan> anyone use haskell-mode in emacs?
15:48:15 <Saizan_> and if you don't like the instance you can use the newtype trick here
15:48:15 <narens> i use haskell-mode
15:48:23 <kmc_> is there an easy way to get the decimal digits of a Rational number?
15:48:37 <stroan> trying to set the active directory of ghci to the directory the file is in. it's defaulting to somewhere else altogether
15:49:09 <narens> (load "/usr/share/emacs/site-lisp/haskell-mode/haskell-site-file")
15:49:20 <Saizan_> stroan: i think that bug has been fixed in later versions
15:49:33 <Saizan_> stroan: or you can always use :cd inside ghci
15:49:59 <stroan> cheers all
15:50:50 <Cale> Heh, the stage complete animation in Raincat is pretty silly :)
15:51:30 * hackagebot upload: hint 0.3.2.0 - Runtime Haskell interpreter (GHC API wrapper) (DanielGorin)
15:51:51 <Saizan_> Raincat is buggy here, something about coordinates i think, maybe it's not used to tiling wms :)
15:55:50 * kmc_ <3 hint
15:57:10 <aavogt> I notice the same thing as Saizan
16:02:33 <Vanadium> Can someone help me by telling what I can do to avoid getting the error that I am getting in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12029#a12029 and optionally explaining me just why I was getting the error in case that would not be clear once I know what I am actually supposed to be doing?
16:02:54 <ddarius> Who's behind raincat?
16:03:43 <ksf> hey wait why is Reader a monad?
16:04:03 <SimonRC> there is also a Reader comonad
16:04:09 <SimonRC> which makes more sense in a way
16:04:16 <ksf> the thing ask returns is always going to be the same thing.
16:04:26 <Vanadium> welp, stuck in an ST monad while all my type variables are escaping
16:04:47 <ksf> ...which makes enabling reacting to changes in it quite pointless.
16:05:04 <BONUS> Vanadium: try just changing return $ mapM readSTRef refs
16:05:06 <BONUS> to
16:05:09 <BONUS> mapM readSTRef refs
16:05:19 <Vanadium> oh duh
16:05:23 <ksf> should be an Identity monad transformed by an applicative...
16:05:32 <Vanadium> Thanks :<
16:05:33 <BONUS> cause mapM already produces a monadic value
16:05:35 <BONUS> haha np
16:06:13 <BONUS> so you have ST s [Maybe Int]. if you return that you have ST s (ST s [Maybe Int]) and the s is in the a part of the outside monad, which is unacceptable
16:06:16 <BONUS> because of the forall
16:06:17 <BONUS> :]
16:06:49 * SimonRC goes to bed
16:09:39 <Vanadium> I would not know what to do without you, bonus :<
16:10:30 <BONUS> :')
16:11:03 <kmc_> > primes
16:11:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:11:47 <Vanadium> > primes !! 10000
16:11:50 <lambdabot>   104743
16:11:56 <Saizan_> ksf: yeah, with laziness the Monad interface doesn't offer anything above the Applicative one, though ReaderT is convenient in transformers stack
16:14:16 <m0nkfish> > primes !! 20000
16:14:20 <lambdabot>   mueval-core: Time limit exceeded
16:14:23 <m0nkfish> ;[
16:16:42 <ivanm> ddarius: looks like a student project
16:22:55 <iaefai> How does runExceptionT (X m) = m   have a type of runExceptionT :: ExceptionT i m a -> m (Either i a)  ?  Wouldn't m :: i m a?
16:24:02 <kmc_> well, what's the definition of ExceptionT look like?
16:24:12 <kmc_> @unmtl ExceptionT i m a
16:24:14 <lambdabot> ExceptionT i m a
16:24:20 <iaefai> newtype ExceptionT i m a  = X (m (Either i a))
16:24:51 <kmc_> so m :: m (Either i a)
16:24:56 <kmc_> just what's inside the X
16:25:07 <iaefai> I guess that works
16:25:15 <kmc_> it's confusing but totally valid that m is used in two roles, as a type and a value variable
16:25:31 <iaefai> oh the two ms are fine, I understand the difference
16:25:47 <iaefai> Could that mean that we could say newtype ExceptionT m i a   or a m i  or any combo?
16:26:01 <kmc_> yeah
16:26:06 <iaefai> awesoe
16:26:08 <iaefai> meric
16:26:23 <kmc_> the order that type variables are given to the type constructor doesn't have anything to do with the order in which they're used by value constructor(s)
16:26:30 <kmc_> indeed some may be used more than once, or not at all
16:26:46 <kmc_> i think the typeclasses Monad and MonadTrans will put some constraints on the order
16:26:52 <kmc_> @instances MonadTrans
16:26:52 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
16:26:57 <Saizan_> yeah
16:27:12 <Gracenotes> @pl \x -> guard ((<=) 0 x) >> return x
16:27:13 <lambdabot> ap ((>>) . guard . (0 <=)) return
16:27:25 <kmc_> so the inner monad has to come second-to-last, and the monad action result type last
16:27:30 <Saizan_> a transformer has to be of kind (* -> *) -> * -> *
16:41:01 <FunctorSalad> lol this generated code compiles! awesome!! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12036#a12036
16:41:12 <FunctorSalad> (gadt folding)
16:41:36 <FunctorSalad> CoZonk and Zonk are example types testing most GADT specialities...
16:43:38 <stroan> Saizan_: cheers, updating to the newest haskell-mode fixed the problem.
16:43:45 <stroan> had been using the ones from the debian repos
16:43:50 <FunctorSalad> it translates them into open recursion first (the underscore postfixed ones)
16:44:57 <FunctorSalad> I'm unsure whether I should higher-orderify the mutual recursion, multirec-style
16:45:26 <FunctorSalad> since the proliferation of type parameters even with 2 mutually recursive types makes it a bit hard to read
16:45:55 <ksf> can we get this http://prometheus.frii.com/~gnat/yapc/2000-stages/slide1.html  for haskell?
16:46:19 <Saizan_> we already have!
16:46:34 <iaefai> Wizard Saizan_
16:46:37 <Saizan_> oh, this one is serious?
16:47:45 <ksf> Wizard level should be "Your code makes Oleg blink", /me thinks.
16:48:41 <Saizan_> http://www.willamette.edu/~fruehr/haskell/evolution.html <- i was thinking of this one
16:49:26 <mtnviewmark> does anyone have reccomendation about which of the o-so-numerous XML packages I should use? I just need to parse a given XML format and generate it -- it's pretty simple
16:53:43 <aavogt> is there some way to attach haddock documentation to reexported functions?
16:54:54 <Gracenotes> wow. using single-entry updates in STG *really* clears up the heap.. quite fast
16:55:02 <ksf> aavogt, if the module it's coded in doesn't get docs generated, haddock propagetes them.
16:55:13 <ksf> ...for other usages, read the docs
16:55:36 <ksf> mtnviewmark, do you have a dtd?
16:55:44 <Gracenotes> now, to combine the update stack and return stack...
16:55:50 <aavogt> ah, so I can't attach some usage notes on a reexported function
16:55:56 <mtnviewmark> yes
16:56:07 <Saizan_> Gracenotes: are you implementing your own STG?
16:56:12 <ksf> If you do, haxml is great because you can auto-generate an haskell adt from the dtd.
16:56:29 <Saizan_> +machine
16:56:32 <ksf> ...and only use two functions to serialize and deserialize it.
16:57:02 <mtnviewmark> though, in other languages I haven't bothered to use it -- I wrote the parsers for this using expat and just used the SAX-like events that expat gives to build up the language native structure
16:58:05 <mtnviewmark> ah, I already have the Haskell adt written and tested
16:58:09 <mtnviewmark> so I don't need that
16:58:24 <Saizan_> tagsoup spits a stream of tags which is much like a series of SAX events
16:58:31 <mtnviewmark> (and the adt has some bizarre semantics, so auto-generated wouldn't likely to be enough)
16:58:56 <eldragon> hi guys, what's the maximum decidable system that can use haskell?
16:59:01 <mtnviewmark> I'm not enamoured of doing it the SAX way - in C++, sure, but in Haskell - I'm open
16:59:07 <ksf> haxml also gives you sax. but doing that automatic adt and then translating it in haskell might be easier.
16:59:15 <ksf> ...or, at least, more convinient.
16:59:51 <Saizan_> if you feel like learning arrows doing it in HXT would be quite a different experience
17:00:00 <mtnviewmark> ksf - hmmmm..... quite possibly --- do you think that would be easier than working with the lazy Node Tree that hexpat gives?
17:00:17 <ksf> I've got no Idea, haxml is the only thing I ever used.
17:00:30 <mtnviewmark> I realize that at some point I will need to explode my head by learning Arrows.....
17:00:35 <Saizan_> http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml
17:01:01 <ksf> otoh, matching on Foo vs. (Node "Foo") should'nt be that much of a difference.
17:01:25 <ksf> maybe in error handling and stuff, as you don't have to check against the dtd, manually.
17:01:53 <Gracenotes> Saizan_: yes, I am working on one :)
17:02:09 <Gracenotes> Saizan_: here is the result of what I just implemented: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12037
17:02:17 <Gracenotes> hm.. title got borked
17:02:52 <Gracenotes> reachable, anyway,in a sort of mark+sweep garbage collection kind of way
17:03:10 <Peaker> @type newSTRef
17:03:11 <lambdabot> forall a s. a -> ST s (STRef s a)
17:03:31 <Gracenotes> actually, I don't even think I've made everything single-entry that /can/ be
17:04:05 <Peaker> @type runST
17:04:06 <lambdabot> forall a. (forall s. ST s a) -> a
17:05:25 <Peaker> @type readSTRef
17:05:27 <lambdabot> forall s a. STRef s a -> ST s a
17:05:57 <Gracenotes> anyway, next step is combining return and update stacks :)
17:07:22 <Gracenotes> while still keeping everything reasonably abstract
17:14:41 * ksf thinks h' should come with a powerful enough type system to encode a Reference monad without doing the oleg.
17:15:10 <Cale> ksf: Implement it in GHC first, and there's a chance ;)
17:15:34 <Peaker> a reference monad?
17:15:46 <Cale> (the type system he's talking about)
17:15:55 <mpiechotka> @pl \f -> fmap (fmap f)
17:15:56 <lambdabot> fmap . fmap
17:15:58 <ksf> something like ST, but not based on unsafePerformIO.
17:16:05 <ksf> ...a pure implementation.
17:16:18 <ksf> ideally, we could drop IORefs alltogether.
17:16:39 <ksf> and making haskell just that much more pure and that much more dirty, because people won't be ashamed to use refs, anymore.
17:17:36 <Peaker> ksf, I don't understand
17:17:47 <Peaker> ksf, Why do you mind how ST is implemented?
17:18:53 <ksf> it's not pure, but that's not the main reason. the main reason is the existential it uses.
17:18:58 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10687
17:19:08 <ksf> ...that implementation is incomplete, though.
17:19:34 <PetRat> Is there something like "record modify" syntax? Like record update syntax, but takes a function to apply to a field.
17:19:34 <Peaker> ksf, It is pure
17:19:36 <ksf> (and vastly too agda for my taste)
17:19:41 <Gracenotes> personally, it is nice that the type system ensures that ST variable sets cannot overlap or escape, but I certainly wouldn't mind an implementation that checks this at runtime
17:19:45 <Peaker> ksf, Using impure primitives to implement pure things is fine
17:20:00 <ksf> I've seen it a month ago and forgot about it until you mentioned STRefs
17:20:06 <Peaker> Gracenotes, It would still break referential transparency, I think
17:20:07 <Gracenotes> and allows us to forgo the existential business/annoying type variables
17:20:15 <Peaker> Gracenotes, (Failures at runtime, based on evaluation order)
17:20:18 <Cale> ksf: What existential?
17:20:19 <dibblego> @index Id
17:20:20 <lambdabot> bzzt
17:20:30 <dibblego> where does newtype Id a = Id a live?
17:20:32 <Peaker> Gracenotes, Why do you mind the existential there?
17:20:33 <Cale> ksf: Are you talking about the higher-rank type of runST?
17:20:48 <aavogt> PetRat: not built into the language, there are a bunch of libraries which make it pretty painless
17:20:51 <Gracenotes> existential is fine. keeping track of it with a ghost parametric type... eh...
17:21:03 <Gracenotes> PetRat: there is a way to update fields by name, but no function-passing, sadly
17:21:05 <aavogt> I'm not sure whether you should use data-accessor lenses or something else
17:21:10 <Cale> whaaat
17:21:12 <ksf> Cale, yes, the s.
17:21:21 <Cale> Yeah, that's not an existential, is it?
17:21:37 <kmc_> anyone have a good comparison of fclabels, data-accessor, and lenses?
17:21:37 <dolio> It's a universal.
17:21:39 <Cale> It's a universal :)
17:21:40 <Cale> yeah
17:21:59 <Gracenotes> eh, everything that exists is universal ;)
17:22:06 <Gracenotes> (perhaps not the other way around)
17:22:08 <ksf> Cale, http://www.reddit.com/r/haskell/comments/9u9h9/someone_implemented_references_using_indexed/c0ehsma
17:22:25 <Gracenotes> PetRat: obj { foo = bar (foo obj) }
17:22:26 <aavogt> kmc_: time to make one!
17:22:56 <aavogt> they all seem to do the same thing
17:23:11 <Gracenotes> obj is the object that has record field foo. bar is the function that, from an old foo, gives the new one. A simpler example: myDataTree { rootLabel = 4 }. changes tree's value to 4 without touching its subtree(s)
17:23:18 <kmc_> i don't feel qualified, since i haven't used any of them
17:23:19 <aavogt> data-accessor is annoying in that underneath, all the types are named C, the classes ar T
17:23:28 <aavogt> err, the other way around
17:23:44 <kmc_> fclabels looks nice and has the TH support
17:23:58 <aavogt> but you don't usually have to mess with that
17:24:09 <aavogt> kmc_: there's a data-accessor-template
17:24:11 <ksf> you could use Hlist. or OOHaskell, while you're at it.
17:24:19 <kmc_> okay and lenses has it too...
17:24:59 <dolio> I've seen a formulation of ST that doesn't use "runST :: (forall s. ST s r) -> r". Instead it uses some higher-order type operator that I don't understand.
17:25:45 <Peaker> dolio, where?
17:26:00 <dolio> I don't remember. I'm trying to find the paper now.
17:26:24 <dolio> I wouldn't recommend getting your hopes up, though.
17:26:36 * ksf doesn't know why he would want to pass a reference out of a ST, but it would be cool if it'd be possible, in a safe way.
17:26:56 <PetRat> Gracenotes: thanks. I was hoping there was syntactical sugar to avoid repeating obj and foo.
17:26:59 <dolio> You can do it, by wrapping it in an existential.
17:27:06 <dolio> And then you'll never be able to use it.
17:27:52 <Gracenotes> me too..
17:30:35 <aavogt> PetRat: there is in some libraries as I mentioned...
17:33:17 <Gracenotes> hm.. something that's not necessarily single-entry in a particular function could be in whole-program analysis
17:34:55 <edushka> @type map
17:34:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:35:56 <Gracenotes> in my simple map function, I made both x and xs in (x:xs) single-update.. which is fine, because when xs is evaluated, it's not really needed beyond the thunks representing its head and tail, which are stored separately on the heap
17:36:15 <Gracenotes> and handed directly to the case statement
17:37:26 <Gracenotes> technically, there are still references on the stack to them. which is dangerous >_>
17:38:16 <dolio> Peaker: Well, citseer is still down, but it's called: Monadic Encapsulation of Effects: A Revised Approach (Extended Version)
17:38:32 <Peaker> dolio, thanks
17:50:40 <ksf> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.78.3975&rep=rep1&type=pdf
17:50:49 <ksf> google scholar beats all of them.
18:20:25 <sileni> hello everyone
18:20:45 <sileni> i know this is not the channel , but where would i go to ask about backus's fp language
18:23:34 <sileni> does anyone know how to define a function in backus's fp language?
18:29:08 <iaefai> Can I import specific functions from a module instead of hiding specific ones?
18:30:12 <Saizan_> yes
18:30:25 <Saizan_> import Foo (func1,func2)
18:30:25 <iaefai> import module(function) sort of thing?
18:30:47 <iaefai> merci
18:31:02 <Saizan_> ksf: did you try that STRefIx?
18:31:07 <Saizan_> ksf: it doesn't typecheck here
18:36:33 <iaefai> Does Message !String mean strict evaluation?
18:36:57 <aavogt> yes
18:37:15 <MacCoaster> maybe a very elementary question, but how do i extract values from tuples from a list of tuples in a list comprehension?
18:37:34 <bnijk_> does somebody have written into haskell, the function that turns a z-score into a probability
18:37:43 <bnijk_> or at the very least, know what it is
18:37:49 <aavogt> > [ a | (a,b) <- zip "hello" " MacCoaster"]
18:37:50 <lambdabot>   "hello"
18:39:29 <MacCoaster> aavogt: ahh, simpler than i thought :) thanks
18:41:02 <aavogt> bnijk_: you have to numerically calculate the integral of the normal distribution to that z-score
18:41:10 <bnijk_> i know i do
18:41:29 <bnijk_> am i going to have to integrate it
18:41:29 <bnijk_> ok
18:42:20 <aavogt> @hoogle normal
18:42:20 <lambdabot> Language.Haskell.TH NormalB :: Exp -> Body
18:42:20 <lambdabot> Language.Haskell.TH.Syntax NormalB :: Exp -> Body
18:42:20 <lambdabot> Language.Haskell.TH normalB :: ExpQ -> BodyQ
18:42:49 <BMeph> @hooglr something
18:42:49 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
18:43:06 * BMeph loves how that works...
18:43:41 <bnijk_> is that the normal cdf?
18:43:41 <aavogt> bnijk_: probably best to just use something like here: http://hackage.haskell.org/packages/archive/hmatrix/0.5.2.2/doc/html/Numeric-GSL-Integration.html
18:43:50 <aavogt> not at all
18:46:19 <bnijk_> ...you sure?
18:46:43 <bnijk_> this function seems to do exactly what i expect
18:47:27 <sileni> does anyone in here know how to define a function in backus's FP language?
18:52:54 <JohnnyL> can someone tell me why ghc takes 2% cpu power at idle?
18:53:36 <aavogt> bnijk_: which function? the ones lambdabot printed are all haskell abstract syntax trees for compile-time metaprogramming library
18:53:56 <sileni> aavogt, hey have you ever used backus's FP language?
18:54:07 <aavogt> I have not
18:54:14 <sileni> aavogt, ok
18:54:36 <sileni> aavogt, do you know what channel i should go to to ask questions on that subject?
18:55:02 <aavogt> perhaps #lisp?
18:57:01 <sjanssen> sileni: I doubt there's an IRC channel for FP
18:57:28 <sileni> sjanssen, :\
18:57:36 <sileni> sjanssen, have you used it before?
18:57:41 <ksf> JohnnyL, what's "idle"? threadDelay?
18:57:49 <ksf> ...and what does your time profile say?
18:58:14 <sjanssen> sileni: I've only heard of it.  Is there a compiler/interpreter for it?
18:58:26 <sileni> sjanssen, yes there is
18:58:37 <sileni> sjanssen,http://www.cse.sc.edu/~bays/group9/index1.html
18:58:41 <sjanssen> sileni: what's it called? I'm curious now
18:59:06 <sileni> sjanssen, http://www.cse.sc.edu/~bays/group9/help.html
18:59:12 <sileni> that is the language description
18:59:21 <sjanssen> Java applet?  That's a bit less than desirable
18:59:33 <sileni> sjanssen, its light
18:59:46 <ksf> JohnnyL, no idea.
19:00:16 <copumpkin> wow
19:00:33 <ksf> ...but ghci 6.10.4/linux doesn't do that kind of thing.
19:01:51 <BMeph> It reminds me of K/Q, in a way. :)
19:02:55 <sjanssen> BMeph: yeah, from my limited searches on Wikipedia they're in the same family
19:04:50 <mmorrow> my favorite quote (well, the only one in my QUOTES.txt, so i'll just call it my favorite) from that backus fp paper is
19:04:55 <mmorrow> "Yet another is the existence of function level definitions that are not the lifted (that is, lifted from a lower value-level to a higher function-level) image of any existing value-level one: these (often terse) function-level definitions represent a more powerful style of programming not available at the value-level and, arguably, are often easier to understand and reason about."
19:05:44 <JohnnyL> kst ok
19:05:54 <mmorrow> JohnnyL: what OS are you on?
19:06:59 <mmorrow> JohnnyL: the rts has a timer interrupt fire continually, so maybe 2% is the overhead of servicing that on your system
19:07:05 <mmorrow> JohnnyL: you can see it with strace
19:07:10 <JohnnyL> ok
19:15:30 <BMeph> Why don't we have an RTS that puts output on a web browser? For those that ask, "Which browser," I (pre-)reply, "a" browser, i.e., at least one. :)
19:16:23 <Axman6> as in Firefox/Safari/..Opera?
19:16:58 <daswerth> Is this the place for a beginner to ask questions about code?
19:17:12 <Lemmih> daswerth: yes.
19:17:14 <sjanssen> daswerth: Haskell code?  Yes
19:17:15 <Axman6> daswerth: if it's haskell code, then yes!
19:17:24 <daswerth> haha, Fantastic!
19:17:27 <sjanssen> @quote stereo
19:17:27 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
19:17:35 <gbacon_> ?seen yrlnry
19:17:36 <lambdabot> Unknown command, try @list
19:17:51 <gbacon_> ?last yrlnry
19:17:53 <lambdabot> No module "yrlnry" loaded
19:18:02 <ksf> BMeph, because there are terminal implementations running in browsers?
19:18:02 <gbacon_> @help seen
19:18:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:18:06 <Axman6> preflex: seen yrlnry
19:18:07 <preflex>  yrlnry was last seen on #perl 5 days, 9 hours, 58 minutes and 12 seconds ago, saying: Must be going.
19:18:12 <ivanm> BMeph: what do you mean by that?
19:18:15 <ivanm> heya Axman6
19:18:19 <Axman6> o/
19:18:23 <gbacon_> Axman6: thanks
19:18:28 <Axman6> just finished my formal methods exam
19:18:51 <ivanm> how'd it go?
19:18:54 <Axman6> got a little raped by hoare logic and weakest precondition calculus
19:19:20 <ivanm> :s
19:19:25 <Axman6> but i manages to get all the natural deduction proofs, which i didn't understand at all until yesterday
19:19:37 <Axman6> and finally really understood them in the exam :P
19:19:53 <Axman6> aced the structural induction stuff ;)
19:19:54 <iaefai> So has anyone ever implemented an operating system with agda?
19:20:42 <Axman6> none that i know of... there's a few haskell ones though
19:20:50 <ksf> it'd look quite strange, considering that agda compiles down to haskell with a lot of unsafeCoerces inserted.
19:20:55 <Axman6> is haskell `elem` agda?
19:20:55 <ivanm> isn't agda just for proofs?
19:21:16 <Axman6> copumpkin: you know about agda...
19:21:23 <copumpkin> ?
19:21:30 <ksf> I would say no, at least not without human assistance.
19:21:38 <copumpkin> the syntax is quite similar, but there are a few differences
19:21:47 <ksf> it's going to be hard to make a turing-complete language be eaten by a beast that demands termination proof.
19:21:56 <Axman6> copumpkin: what's good about it?
19:22:06 <copumpkin> no case expressions, no inline type annotations, no type inference a lot of the time
19:22:10 <copumpkin> oh, what's good about it?
19:22:15 <copumpkin> it's amazing!
19:22:16 <mmorrow> ksf: the termination checker is separate from agda's type system
19:22:17 <copumpkin> lol
19:22:24 <copumpkin> most mind-opening experience I've had, learning it
19:22:29 <mmorrow> ksf: as in, it's optional
19:22:32 <copumpkin> maybe even more than haskell
19:22:36 <Axman6> :o
19:22:38 <Axman6> how so?
19:23:03 <ksf> well yes, but a translation that won't terminate because agda won't terminate type-checking wouldn't be of much use.
19:23:22 <ksf> well.
19:23:30 <Adamant> Axman6: what are some good web resources on formal methods? I'd like to do my own kind of course on that since it isn't offered
19:23:32 <copumpkin> well I enjoyed proofs in math courses, but discovering that I enjoyed proofs because in many senses they're like programming was awesome. A lot of it can be tedious but the satisfaction of getting your program to typecheck is second to none :)
19:23:33 <ksf> maybe you can type sufficiently coarse.
19:23:42 <mmorrow> ksf: termination checker has to do with whether the /program/ will terminate, not the checker
19:24:00 <copumpkin> agda always terminates
19:24:11 <Axman6> Adamant: you should check out our course: http://cs.anu.edu.au/students/comp2600/
19:24:21 <Axman6> Adamant: you should check out our course: http://cs.anu.edu.au/students/comp2600/lectures.php *
19:24:21 <ksf> either I'm missing something very important about dependent types or you're all wrong.
19:24:26 <copumpkin> ksf: ?
19:24:32 <iaefai> "All new languages that are not sufficiently exotic are assumed to be Python."
19:24:39 <Adamant> Axman6: thanks!
19:24:45 <mmorrow> ksf: cayenne's type checker can not terminate however, so it aborts after a given amount of effort
19:24:53 <ivanm> Axman6: heh, to the penguin comic
19:25:01 <Axman6> Adamant: the natural deduction stuff might be difficult without help, unless you've done some related stuff before (i found it extremely hard)
19:25:12 <aavogt> copumpkin: but you can make one that terminates in a finite but practically infinite time?
19:25:16 <Adamant> Axman6: I'll work on it at some point
19:25:18 <Axman6> ivanm: clem's got an awesome sense of humour ;)
19:25:28 <ivanm> Axman6: did you use B or Z for that course? or was it just theory?
19:25:39 <Axman6> Adamant: the structural deduction stuff should be very easy if you can evaluate haskell by hand
19:25:41 <copumpkin> aavogt: don't know, never encountered any issues with agda's typechecker not terminating or even taking a particularly long time
19:25:48 <Axman6> ivanm: B or Z?
19:25:50 <copumpkin> it's definitely a lot slower than haskell
19:26:04 <nvoorhies> B and Z are langs for formal specification
19:26:11 <copumpkin> another thing is that I don't think I've ever run an agda program
19:26:12 <Axman6> nope
19:26:47 <ivanm> nvoorhies: yeah, them
19:26:48 <copumpkin> I guess I occasionally ask it to normalize terms for me, which is roughly equivalent to running it
19:26:54 <ksf> copumpkin, I can tell you what I mean as soon as I eradicated an assumption about how the value level propagates into the type level from my brain.
19:26:56 <ivanm> trying to find a wikipedia page on them and failing :(
19:27:09 <ksf> ...as it's stopping me from grokking anything right now, and is most likely false.
19:27:21 <ivanm> Axman6: you use it to specify constraints and prove validity of your reasoning and logic
19:27:30 <copumpkin> anyway, I highly recommend it to anyone who enjoys playing with type-level haskell programming
19:27:42 <ivanm> kinda like QC in a sense, except from a logic point of view rather than "let's bombard it with values and see if it works!" ;-)
19:27:44 <nvoorhies> http://en.wikipedia.org/wiki/Z_notation
19:27:48 <copumpkin> as it's like that and so much more powerful and less tedious
19:28:07 <ivanm> nvoorhies: bah, the Z disambiguation page didn't seem to mention it
19:28:21 <ivanm> B-Method is what I used
19:28:28 <ksf> copumpkin, does that mean that you have real-life examples to share?
19:28:36 <nvoorhies> yeah I've never used it, just rad about it in a book
19:28:43 <copumpkin> ksf: I have a few ugly proofs I've written if you're interested
19:31:07 <ksf> well, I'm _interested_ in the stuff, but didn't see any real practical value yet (that is, over just proving my code by staring suffiently long at it), so I never went through much more than the definitions of languages, and yet have to write my first proof.
19:31:16 <ksf> otoh, type-level programming is great fun.
19:33:17 <Axman6> anyone see Google's new language, Go: http://arstechnica.com/open-source/news/2009/11/go-new-open-source-programming-language-from-google.ars?utm_source=rss&utm_medium=rss&utm_campaign=rss ?
19:34:00 <ivanm> Axman6: too many braces :p
19:34:38 <jmelesky> Go didn't look terribly interesting to me
19:34:51 <jmelesky> there are plenty of "better C than C"s out there
19:35:00 <sproingie> "s := sum(&[3]int{1,2,3}); // a slice of the array is passed to sum"
19:35:08 <sproingie> that's all i needed to see.  blech.
19:35:36 <copumpkin> ksf, Axman6: here's a really boring proof of properties about parity: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12043#a12043
19:35:36 <Axman6> yeah, that is quite ugly...
19:35:49 <sproingie> does look like it does something like type classes tho
19:35:53 <sproingie> or at least structural subtyping
19:36:38 <sproingie> decent ideas, too much c baggage.  even keeps the semicolons.
19:36:40 * Axman6 had to implement a turing machine today that added a parity bit to a string of 1's and 0's
19:39:14 <copumpkin> I have some more involved proofs but they're mid-refactoring :)
19:39:23 <copumpkin> none of them are proving particularly interesting statements though
19:39:29 <copumpkin> since I'm still pretty noobish :P
19:39:56 <ksf> those implicit interfaces may be convinient, but also a good way to shoot yourself in the foot.
19:40:00 <bnijk_> everyone is noobish until they're not
19:40:34 <copumpkin> the implicit arguments?
19:40:41 <copumpkin> they're awesome!
19:40:48 <copumpkin> who needs polymorphism when you have implicit arguments!
19:40:59 <ksf> that is, I might have two different interfaces that only consist of the method "suck", one for vacuum cleaners, and one for people.
19:41:08 <copumpkin> interfaces?
19:41:15 <ksf> it's umpossible to match those up without additional info.
19:41:27 * ksf is talking about go
19:41:30 <copumpkin> oh :)
19:41:54 <iaefai> Anyone know of a good & free editor on macosx that is preferably written in cocoa with haskell language syntax highlighting? I am using TextWrangler and it has an issue with that feature, although it is otherwise good.
19:42:13 <copumpkin> iaefai: I usually use textmate, but its haskell bundle isn't the greatest
19:42:26 <ksf> ...and even then, there might be specific vacuums and people that implement both meanings of sucks.
19:42:27 <iaefai> and it isn't free, in fact it is expensive for an editor
19:42:34 <copumpkin> true
19:42:39 <copumpkin> I thought it was worth it :)
19:42:57 <Axman6> hmm, looks like Go gets rid of some of the real nastiness of C (no pointer arith)
19:43:02 <ksf> as editor choice, there's vi, vi, vi and vi.
19:43:19 <iaefai> vi sucks and emacs is evil
19:43:29 <impl> but at least it doesn't suck
19:43:44 <ksf> ...then grab yi and roll your own.
19:43:48 <iaefai> impl: it blows :p
19:43:57 <iaefai> ksf, I like full gui
19:43:57 <copumpkin> one thing about agda is that you're almost forced to use emacs with it
19:44:07 <copumpkin> which is fine by me, although I don't normally use emacs
19:44:12 <ksf> hell it's a _text_ editor
19:44:18 <ksf> what do you need buttons for?
19:44:41 <ksf> they're just things mouse manufacturers invented to drive sales.
19:44:42 <iaefai> I need to be able to click my mouse in a location to go there, or select text
19:44:48 <ksf> don't listen to their propaganda.
19:44:51 <Axman6> iaefai: i highly recommend forking out the cash for TextMate
19:44:52 <copumpkin> lol
19:45:27 * ksf thinks iaefai should spend a week in xmonad
19:45:37 <ksf> warm, fuzzy, and not using a mouse.
19:45:42 <iaefai> ksf, thank fsm I use a mac
19:45:52 <iaefai> I have actually tried a xmonad before
19:45:55 <ksf> that shouldn't stop you.
19:46:11 <voidprayer> excuse me, i have a problem while compiling yi-editor: [ 30 of 119] Compiling Yi.Buffer.Basic  ( Yi/Buffer/Basic.hs, dist/build/Yi/Buffer/Basic.o )
19:46:11 <voidprayer> ghc: /usr/lib/ghc-6.10.4/ghc-prim-0.1.0.0/HSghc-prim-0.1.0.0.o: unknown symbol `_GLOBAL_OFFSET_TABLE_'
19:46:11 <voidprayer> Loading package ghc-prim ... linking ... ghc: unable to load package `ghc-prim'
19:46:12 <Nafai> I ran screaming from a mac back to Linux and to xmonad
19:46:15 <iaefai> ksf, it does :p
19:46:23 <voidprayer> should this be a toolchain problem?
19:46:25 <Nafai> sooooo much better :)
19:46:31 <ksf> or maybe it's because you don't have a proper model-m.
19:46:32 <iaefai> Nafai, I pity you :p
19:46:35 <Axman6> iaefai: there are gui vim and emacs version for OS X if you want them
19:46:47 <iaefai> Axman6: evil++
19:46:53 <Axman6> Nafai: you're doing it wrong
19:47:05 <Nafai> yes, I know
19:47:15 <Nafai> I should say a few hail steves, right?
19:47:24 * sjanssen is surprised to see smug mac fans :)
19:47:31 <ksf> voidprayer, yep, it is. looks like ghc is trying to start up TH and fails.
19:47:34 <Axman6> no, but how you can prefer linux over OS X i have no idea ;)
19:47:49 <Nafai> Axman6: I tried so hard to get used to OS X.  just couldn't
19:48:00 <sproingie> aptitude install ghc6
19:48:02 <Axman6> what's there to get used to?
19:48:04 <sproingie> that's why i prefer linux
19:48:08 <ksf> voidprayer, can you compile simple (non-th) programs and run them?
19:48:18 <Axman6> sproingie: ghc6.8.2 awww :(
19:48:19 <Nafai> the window manager is a pain and can't be configured very much -- at least not for things other than cocoa apps
19:48:26 <sproingie> not for me
19:48:29 <voidprayer> ksf, yes i can, like main = print()
19:48:33 <Nafai> installing and maintaining software is a pain in the butt
19:48:35 <Axman6> you get 6.8.3? :o
19:48:37 <Nafai> apt for the win
19:48:42 * BMeph still lights a candle for NeXTStep...
19:48:47 <sproingie> ubuntu and sid are on 6.10
19:48:51 <Nafai> BMeph: :)
19:49:05 <Axman6> Nafai: installing and maintaining linux software is a pain in the butt*, and i still disagree with that
19:49:13 <Axman6> sproingie: when did that happen?
19:49:19 <sproingie> beats me
19:49:22 <Axman6> they're just in time for 6.12!
19:49:22 <ksf> voidprayer, what does ghc --info say about stage and haveinterpreter?
19:49:32 <mmorrow> voidprayer: GOT is used in position indep code, and i'm pretty sure that ghc doesn't by default compile libs that are to-be-loaded-by-ghci as PIC
19:49:38 * BMeph is watching Haiku's development with crossed fingers and warm (and fuzzy!) wishes
19:49:46 <mmorrow> voidprayer: how did you build that HSghc-prim-0.1.0.0.o ?
19:49:47 <Nafai> Axman6: oh really?  with exception of the haskell stuff (which is improving) most everything I need is in the ubuntu repositories
19:49:48 <sproingie> i suspect 6.12 will hit unstable when it's released
19:50:04 <Axman6> Nafai: it's all in macports too
19:50:04 <mmorrow> voidprayer: (my HSghc-prim-0.1.0.0.o doesn't appear to be PIC, judging from the relocations)
19:50:08 <voidprayer> mmorrow, i am using gentoo and just emerge haskell.
19:50:13 <sproingie> ubuntu will have to wait til 10.4
19:50:14 <voidprayer> mmorrow, while i am using hardened gcc.
19:50:15 <kmeyer> :t mapM_
19:50:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
19:50:26 <ksf> oh.
19:50:30 <ksf> don't use hardened.
19:50:30 <voidprayer> ksf, should i use wgetpaste to show ghc --info or just paste it here?
19:50:31 <Nafai> Axman6: macports is a pain, I always had a problem with it, perhaps I'm dumb.  Especially in regard to, say Python libraries
19:50:42 <ksf> ghc uses executable stacks.
19:50:44 <Nafai> regardless, I gave it a 6 month try
19:50:49 <ksf> ask mmorrow why.
19:50:54 <Nafai> everything works for me in Linux
19:51:02 * Axman6 doesn't use python, so has never run into problems with it
19:51:03 <Nafai> less pain points for me than in OS X
19:51:05 <sproingie> thunks on the stack i'd imagine
19:51:23 <Nafai> Axman6: with macports the problem was between system python and mac ports python.  perhaps the situation has improved
19:51:25 <voidprayer> ksf, oh, thanks for the answer. but "ask mmorrow why"?
19:51:28 * BMeph thinks Shuttleworth should skip some letters and name 10.4 "Tumultuous Trucker"! ;p
19:51:31 <Axman6> UseOfPython -> MacportsPain
19:51:31 <sjanssen> Nafai: I had lots of problems with macports a couple years ago when I used OS X.  It's a source-based package manager that's worse than even Gentoo
19:51:40 <Nafai> sjanssen: Indeed :)
19:51:48 <voidprayer> mmorrow, why? -_-b
19:51:59 <iaefai> sjanssen: you can get worse than gentoo?
19:52:03 <sproingie> well the next one he could name Leapin' Lizards
19:52:21 <Nafai> Axman6: needless to say, I find it funny whenever a mac user finds out I don't like OS X
19:52:26 <Nafai> like I don't have taste
19:52:30 <mmorrow> voidprayer: heh. it doesn't need executable /C/ stacks though. ghc's whole heap is read/write/execute however
19:52:32 <Nafai> or I didn't give it an honest try or something
19:52:33 <copumpkin> you don't!
19:52:35 <Axman6> sjanssen: well, what would expect? the community who use macports is probably not much larger than the community who use haskell, and it's a hell of a lot harder to maintain than all the haskell stuff ;)
19:52:40 <sjanssen> iaefai: as far as packages failing to build, yes.  I had a high failure rate with the macports I tried
19:52:40 <copumpkin> you didn't!
19:52:50 <copumpkin> :P
19:52:51 <iaefai> Nafai, 'like I don't have taste' is closest perhaps :P
19:52:57 * Axman6 agrees with copumpkin!
19:52:59 <Axman6> :P
19:53:03 <iaefai> sjanssen: Have you seen the code for how macports is written?
19:53:06 <sproingie> osx is ... pretty, and i guess things work, but nothing grabs me as functionality goes
19:53:12 <ksf> well, one answer is that haskell doesnt' need that kind of protection because you have to go _parsecs_ out of your way to get a executable buffer overflow.
19:53:13 <sjanssen> iaefai: is it still in TCL?
19:53:19 <voidprayer> mmorrow, i see. maybe i should suggest to filter those PIC option while compiling ghc.
19:53:19 <iaefai> sjanssen: yes
19:53:21 <Axman6> i just find linux painful. that why i can't understand it, not because i think OS X is perfect
19:53:25 <mmorrow> voidprayer: but i don't see why exactly this could be a problem with the gcc used, unless that gcc/ld is somehow adding PIC
19:53:28 <voidprayer> thank you, mmorrow & ksf.
19:53:31 <iaefai> They know something needs to be done, but the volume of code is out of this world
19:53:45 <mmorrow> voidprayer: yeah, possibly, and hope that that doesn't break something else.. :)
19:53:54 * BMeph has to work hard at it not to follow references to 10.4 with "Good Buddy!"
19:54:08 <Nafai> Axman6: Perhaps it is what I'm used to.  Using Debian/Ubuntu for almost a decade now.
19:54:26 <sproingie> i certainly find linux painful in other places.  audio is always a fun little adventure.
19:54:31 <Axman6> sjanssen: i've tried making a haskell version, but it's so TCL tied :( (ie; the portfiles are executable TCL i believe)
19:55:12 <Nafai> sproingie: Yes, audio sucks.  bluetooth sucks.  I avoid anything complicated in that area.  but most everything else I need
19:55:17 <Nafai> sproingie: just works.
19:55:18 <sproingie> i'd also rather be on windows for doing my opengl learning stuff, because when i inevitably screw up the video mode, windows recovers, linux locks.
19:55:32 <Axman6> i'd really like to write a nice haskell package manager for OS X, but i think it would be far too much work for one person, and can't find anyone to help
19:55:45 <sjanssen> Axman6: I don't really understand your comment about Linux software installation, then.  From my experience Debian and such do a much better job than ports
19:55:48 <sproingie> really ironic that windows is the more robust platform in that instance
19:56:04 <Axman6> sjanssen: which comment?
19:56:11 <sjanssen> Axman6: drag-n-drop applications from .dmg's is cute, but it doesn't come close to solving the same problem that eg. apt does
19:56:26 <Axman6> sjanssen: OS X survives that sort of thing pretty well ;)
19:56:35 <sjanssen> Axman6: " installing and maintaining linux software is a pain in the butt"
19:56:38 <Axman6> sjanssen: yes, it eliminates it :P
19:56:40 * ksf never managed to lock up his X with gl, much less the whole box
19:57:02 <Axman6> sjanssen: if it's more complex than drag and drop, you get an installer. simple
19:57:16 <sproingie> well it's less than stable drivers, everyone points the finger at nvidia, ati, whatever
19:57:24 <sproingie> whose fault it is doesnt concern me when the outcome is the same
19:57:32 <Axman6> anyway, i have to go, later all
19:57:34 <Axman6> o/
19:57:36 <Nafai> Axman6: but then you have to manually go to a website to find out if a program has been updated, figure out how to update it, etc.
19:57:40 <ksf> Axman6, there's cabal, already, which should already do most of the job.
19:58:11 <Nafai> Axman6: And besides, most of the installer programs I could never figure out how to uninstall.  even when finding the receipts or whatever OS X calls them, I had to manaully rm everything
19:58:16 <sjanssen> Nafai: actually, every single app will use their own slightly different update detection/notification system
19:58:18 <ksf> packaging should actually be one of the main design topics of OS research.
19:58:27 <Nafai> sjanssen: if any at all
19:58:28 <ksf> forget about kernels.
19:58:41 <Nafai> give me apt
19:58:59 <iaefai> I have a function returning IO Config, and I have a function (it is id) that returns Config. I need them to return the same thing, so I thought I would try liftM id, but it actually needs to be Config -> IO Config, not IO Config -> IO Config. Any ideas?
19:59:23 * ksf let gladly go of apt because it's a pain to build yourself a custom package
19:59:58 <dibblego> @type (return .) -- iaefai
20:00:00 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
20:00:07 <Nafai> ksf: debian packaging takes a bit to learn, but I don't mind
20:00:37 <iaefai> dibblego: Now I kind of feel silly :P
20:00:56 <dibblego> iaefai, eh?
20:01:02 <ksf> ...and then there's those other goodies that make gentoo superiour to other distros. like init scripts without numbers, but with dependencies.
20:01:07 <iaefai> dibblego: I should have figured that one
20:01:12 <dibblego> ok
20:02:23 <sjanssen> ksf: the other distros are starting to move towards that, with upstart.  You're right though, the init system was probably my favorite part of Gentoo
20:02:41 <medfly> hi guys, I want to write something that does magic to text, I want to know if it's unreasonable to ask from an application to tell me the maximum length of a line (after which it'd have a newline)?
20:03:21 <medfly> I know it'
20:03:28 <ksf> the maximum length of a line is 80 characters.
20:03:30 <medfly> I know it's not very Haskell related, but I don't know where to ask :)
20:03:33 <medfly> oh?
20:04:08 <ksf> well, at least if you ask a terminal.
20:04:29 <medfly> :)
20:06:03 <sproingie> you could use curses or vty to query screen size
20:06:21 <copumpkin> is it sad that whenever I see the word 'coffee' I read it as a cofree?
20:06:32 <medfly> copumpkin, very.
20:06:38 <copumpkin> (not being a drinker of coffee might help with that)
20:06:44 <sproingie> that's probably why
20:07:58 <ksf> @let coffe = - 0xffe
20:07:59 <lambdabot>  Defined.
20:08:18 <ksf> > coffe
20:08:19 <lambdabot>   -4094
20:08:33 <medfly> I suppose I could use that...
20:08:52 <ksf> oh.
20:08:56 <ksf> @unlet coffe
20:08:56 <lambdabot>   Parse error: SemiColon
20:08:57 <medfly> thanks
20:09:04 <ksf> @let coffee = - 0xffee
20:09:05 <lambdabot>  Defined.
20:09:09 <ksf> @help let
20:09:10 <lambdabot> let <x> = <e>. Add a binding
20:09:18 <ksf> @undef coffe
20:09:26 <ksf> @bot
20:09:26 <lambdabot> :)
20:09:26 <lunabot>  :o
20:09:29 <ksf> hum.
20:09:59 <ksf> @help unlet
20:09:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:10:31 <medfly> @un
20:10:31 <lambdabot> Maybe you meant: undefine undo unlambda unmtl unpf unpl unpointless run wn
20:10:56 <copumpkin> ho hum
20:11:14 <copumpkin> @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
20:11:15 <lambdabot>   Hello world
20:20:00 <bos> preflex: seen dons
20:20:01 <preflex>  dons was last seen on #haskell 6 hours, 30 minutes and 25 seconds ago, saying: and bindings to external ones.
20:20:07 <bos> boo, hiss.
20:20:27 <copumpkin> May I suggest the dons-summoning dance?
20:20:32 <copumpkin> It's worked for me in the past
20:21:38 <bos> we need a #ghc_inliner channel populated by wizards
20:28:18 <MacCoaster> what does the @ symbol do?
20:29:18 <medfly> magicness
20:29:39 <medfly> @let magic list@(x:xs) = x : list
20:29:39 <lambdabot>  Defined.
20:29:44 <medfly> > magic [1,2,3]
20:29:45 <lambdabot>   [1,1,2,3]
20:29:49 <medfly> hurrah!
20:30:52 <medfly> (hopefully you meant that. otherwise, I'm sorry)
20:31:11 <MacCoaster> haha im still not sure if i follow
20:31:46 <tensorpudding> the definition matches the input for (x:xs), and assigns list to refer to it
20:31:48 <MacCoaster> it just binds a variable name toa pattern?
20:32:06 <MacCoaster> well, argument
20:32:35 <MacCoaster> so like if i did foo bar@(X y z) = ...
20:33:02 <MacCoaster> that means bar will take in something that matches X y z and assigns it to g?
20:33:06 <MacCoaster> er bar
20:33:18 <MacCoaster> blah, i cant type today
20:33:56 <medfly> it doesn't do much except give you a nicer way to refer to (X y z)
20:34:20 <MacCoaster> i see, so its really just renaming it in a way?
20:34:36 <MacCoaster> thanks medfly, tensorpudding
20:37:09 <mmorrow> , let foo x@(y,z) = (z,y,z) in foo (0,1)
20:37:11 <lunabot>  (1,0,1)
20:37:14 <mmorrow> oops
20:37:17 <mmorrow> , let foo x@(y,z) = (x,y,z) in foo (0,1)
20:37:18 <lunabot>  ((0,1),0,1)
20:37:57 <mmorrow> i'd say the place i use it most is like
20:38:08 <mmorrow> foo xs@(x:_) = ...
20:39:06 <mmorrow> oh, and for stuff like
20:39:25 <mmorrow> foo a@(Foo _ (Bar _ (Baz{}) _) = .... a ...
20:40:00 <medfly> I just use it to make more readable code:)
20:40:50 <mmorrow> well, sure that too, but both of those also make more efficient code
20:41:09 <mmorrow> well, s/more efficient/more memory efficient/
20:48:53 <iaefai> When I have a data Config = Config ...  is it possible to export a Config that can be used in a type signature only?
20:49:28 <medfly> is (x:xs) less efficient than xs@(x:_)?
20:50:50 <medfly> memory efficient
20:51:22 <mmorrow> medfly: (\(x:xs) -> x:xs) will build a new (:) cell
20:54:14 <byorgey> iaefai: yes, just export Config, as opposed to  Config(..) which would export the type and all its constructors
20:54:15 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
20:54:59 <iaefai> byorgey: So somebody exporting the whole type would just say   Module Blah(Config(...)) where...
20:55:44 <bnijk_> what is "raincat"
20:56:13 <mmorrow> medfly: so i should have qualified that with "if you might need to recurse with (x:xs)"
20:56:20 <mmorrow> medfly: like with `merge' or something
20:56:33 <medfly> okay :)
20:56:43 <iaefai> we need raincat screenshotsâ¦
20:56:54 <mmorrow> medfly: and in the case of foo a@(Foo _ (Bar _ (Baz{}) _) _) = ... a ...
20:57:09 <sereven> bnijk_: a thoroughly cute surprisingly addictive game (written in haskell) from CMU
20:57:20 <bnijk_> this game is awesome
20:57:20 <mmorrow> doing s/a/Foo x (Bar y (Bax.....)/ in place of `a' would rebuild that
20:57:21 <bnijk_> wow
20:57:26 <byorgey> iaefai: right
20:57:31 <medfly> :-)
20:58:22 <byorgey> I played raincat for a bit earlier today (after finally getting it to build) and the cat walked too slow so I stopped.
20:58:41 <byorgey> I had to wait forEVER each time I ran it.
20:59:26 <bnijk_> it's a little buggy
20:59:36 <bnijk_> or maybe just awkward
21:01:56 <ksf> go's interfaces seem to be quite entirely like typeclasses.
21:02:12 <byorgey> but it sure was cute =)
21:02:33 <bnijk_> i have a bad feeling about that language
21:02:52 <ksf> well, it's another ken thompson spawn.
21:03:46 <iaefai> What is the best way to do depends in cabal? Right now I am just taking the version I have and doing a >= like:  containers>=0.2.0.1, network>=2.2.1.4
21:03:50 <bnijk_> what?
21:03:53 <bnijk_> he works for google?
21:04:01 <ksf> appears so, yes.
21:04:10 <bnijk_> sad
21:04:43 <ksf> it looks more well-rounded that d, though, and anything is better than c++.
21:05:22 <Nafai> and rob pike
21:05:35 <Nafai> I'm tired of braces and semi-colon languages
21:06:08 <bnijk_> i'm tired of the roman alphabet
21:06:28 <bnijk_> programming languages should be some
21:06:39 <bnijk_> floating circles and
21:06:42 <bnijk_> trees
21:06:44 <bnijk_> in mid-air
21:06:54 <bnijk_> well, i've overstayed my welcome
21:07:33 <ksf> visual languages are overrated. methaphors breaks down to easily, and having a visual representation keeps you from doing your own visualisation.
21:08:16 <lambdaf> @let f = (==0) . flip mod 2
21:08:17 <lambdabot>  Defined.
21:08:20 <lambdaf> @let g = (==0) . flip mod 3
21:08:22 <lambdabot>  Defined.
21:08:31 <lambdaf> @pl \a -> f a && g a
21:08:32 <lambdabot> liftM2 (&&) f g
21:08:38 <ksf> text, especially non-ideogram but word-based text has utterly low bandwidth and high processing costs, but then it forces you to piece together everything in your head.
21:09:56 <lambdaf> @t f
21:09:57 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:10:06 <lambdaf> :t f
21:10:07 <lambdabot>     Ambiguous occurrence `f'
21:10:08 <lambdabot>     It could refer to either `L.f', defined at <local>:2:0
21:10:08 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:75:0-32
21:10:13 <lambdaf> :2 L.f
21:10:17 <lambdaf> :t L.f
21:10:19 <lambdabot> forall a. (Integral a) => a -> Bool
21:13:15 <lambdaf> @pl \a -> filter (f a && g a) a
21:13:16 <lambdabot> filter =<< liftM2 (&&) f g
21:13:24 <jmcarthur> i think the best "visual" language would be one that is really just an AST which can be viewed in many different ways, most of which don't follow any sense of "metaphor"
21:13:47 <ksf> yep
21:14:14 <dolio> You're just re-creating lisp!
21:14:28 <jmcarthur> however, i do hold to my belief that such an idea can be very *useful* with graphical representations
21:14:56 <jmcarthur> and the ability to use graphics in inline documentation would be awesome
21:15:31 <JohnnyL> take 15 primes
21:15:43 <jmcarthur> > take 15 primes
21:15:45 <lambdabot>   Not in scope: `primes'
21:15:49 <jmcarthur> define primes :)
21:15:55 <ksf> I'm rather thinking into the direction of refactorings. like telling my editor to expand that fold to see the whole structure, and offer me to transform it into a fold if it sees it can reduce it.
21:15:57 <JohnnyL> well, it was here before!
21:16:23 <ksf> ...the second one gives plenty of jobs to researchers, /me thinks.
21:16:42 <jmcarthur> ksf: yes, another strong benefit of a language that is represented with its raw AST :)
21:17:03 <roconnor> > nubBy((gcd.).(>1))[2..]
21:17:04 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:17:04 <lambdabot>         against inferred type ...
21:17:23 <jmcarthur> ksf: i would love "automatic fold detection" (?)!
21:17:37 <roconnor> > nubBy((>1).(.gcd))[2..]
21:17:39 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
21:17:39 <lambdabot>         against inferred ...
21:17:39 <jmcarthur> and unfold, and all the other fancy morphisms
21:17:46 <jmcarthur> especially the ones that fuse well :)
21:17:46 <roconnor> @quote gcd
21:17:47 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
21:17:54 <dmwit> zygohistoprepromorphisms?
21:18:10 <jmcarthur> cata+ana=hylo  love that one
21:18:13 <dolio> > nubBy (((>1).).gcd)[2..]
21:18:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:18:37 <jmcarthur> s/fuse/deforest/ ?
21:19:04 <jmcarthur> i don't think i truly understand the difference. i think fusion is a special case of deforestation, right?
21:20:03 <dmwit> Does haddock have a way to give a short name to a URL?
21:20:11 <dmwit> i.e. I'm linking to the spec a lot of places.
21:20:17 <jmcarthur> byorgey: what platform did you build for? 64 bit linux? if so, does the mouse and keyboard work for you?
21:20:43 <dmwit> It would be friendly for the text to say, "see the AP property" rather than "see http://blahblahblah.com/reallylongurl/AP".
21:20:46 <MacCoaster> so its not possible to do var1 <- foo    var2 <- bar  where foo returns [Int] and bar returns Int ?  in other words, everything on the left of the <- arrow must be same type in do notation?
21:21:00 <dmwit> (...but link to blahblahblah.com.)
21:21:35 <dmwit> MacCoaster: If bar returns an Int, it's not possible to do "var2 <- bar" period.
21:21:46 <dmwit> MacCoaster: However, if bar is an IO Int, that's a totally different story.
21:21:53 <ksf> everything must have the same Monad.
21:21:57 <roconnor> if bar *is* an int , it's not possible ...
21:22:00 <dmwit> MacCoaster: If (foo :: IO [Int]) and (bar :: IO Int), then what you wrote is perfectly legal.
21:22:02 <ksf> ...that is, not the whole type has to be equal.
21:22:07 <MacCoaster> i see
21:22:17 <MacCoaster> so this has to do with the way monads work?
21:22:20 <dmwit> MacCoaster: However, it does have to be followed by something that is in the IO monad.
21:22:27 <dmwit> s/monad/type/
21:22:33 <ksf> monads are just syntactic sugar.
21:23:04 <ksf> :t (>>=)
21:23:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:23:29 <dmwit> :t (>>=) :: IO a -> (a -> IO b) -> IO b -- the most common form for new Haskellers to use it in
21:23:30 <ksf> that's the operator that's used to implement a do-block, and as you see, all m's have to be equal.
21:23:30 <lambdabot> forall a b. IO a -> (a -> IO b) -> IO b
21:23:37 <MacCoaster> ah so thats what do is all? linking them up with >>= ?
21:23:43 <dmwit> MacCoaster: exactly!
21:24:00 <dmwit> MacCoaster: And sometimes (>>), but even that is just (>>=) under the hood. ;-)
21:24:44 <MacCoaster> interesting, so i have to perhaps do a State monad to do what i want?
21:24:52 <dmwit> uh
21:24:57 <dmwit> Well, what is it that you want?
21:24:57 <ksf> nope.
21:25:11 <MacCoaster> modified BFS for bipartite testing
21:25:21 <ksf> you don't have to use a monad to implement state, but you can use it to hide some stuff and make the surface syntax nicer.
21:25:39 <dmwit> That doesn't sound particularly stateful, but if same state would be helpful, then by all means go for it.
21:26:02 <dmwit> s/same/some/, of course
21:26:14 <MacCoaster> hmms
21:26:18 <MacCoaster> are ther eany examples of BFS in haskell?
21:26:31 <ksf> bfs always tends to be stateful, at least in comparison to dfs.
21:26:42 <narens> is comparing a small array of ints faster than comparing a list with the same number of ints?
21:26:44 <MacCoaster> ksf: thats what i thought, keeps track of color, pi, etc.
21:27:07 * ksf has recently seen one in continuation-passing style, but he doubts that's what MacCoaster is looking for
21:27:22 <roconnor> what is BFS?
21:27:24 <dmwit> Well, fgl has an entire BFS module...
21:27:27 <MacCoaster> breadth first search, ro
21:27:28 <dmwit> breadth-first search
21:27:29 <MacCoaster> roconnor:
21:27:36 * MacCoaster cant type today, still
21:27:44 <dmwit> narens: That sounds like something that some testing could answer.
21:27:54 <ksf> narens, if "small" is smaller than 10000, don't worry until you've profiled your code.
21:27:57 <dmwit> narens: And probably more accurately than any guess that #haskell could make, too.
21:28:07 <ksf> ...and even then, first code, then optimize.
21:28:08 <c_wraith> > runState (modify (+1) >> modify (*3) >> replicateM 4 (modify (^2)) >> return "foo") 5
21:28:09 <lambdabot>   ("foo",121439531096594251776)
21:28:19 <narens> dmwit: i tried but i didn't improve anything... i profiled it too, but there seems to be an inefficieny i can't figure out
21:28:55 <dmwit> narens: You should just ask your real question, instead.
21:29:13 <jmcarthur> byorgey: oh nevermind, got it to work by not allowing xmonad to resize it
21:29:16 <dmwit> Post the profiling information and some code, and if somebody knows something about profiling, they'll give you a hand.
21:29:26 <narens> dmwit: basically, i am reading a text file with columns and rows on ints into a list of lists. so that each row is a record of ints.... and then I want a fast way of counting the number of times a particular row occurs
21:29:55 <narens> with 500 rows and 8 columsn i get about 4.5 seconds... which is too slow
21:30:23 <dmwit> For text operations, the most likely culprit is reading in Strings.
21:30:37 <dmwit> Without looking at code, I'm going to guess you can improve by a factor of 10 just by switching to ByteString.
21:30:37 <ksf> ...use bytestrings, instead.
21:30:37 <mmorrow> MacCoaster: here's a graph bfs http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4899#a4899
21:30:39 <narens> even if i convert it to ints?
21:31:05 <narens> profiling shows 44% time in the counting part
21:31:08 <ksf> read also tends to be a bottleneck, as it's doing a lot of processing to be that versitile.
21:31:13 <narens> 8% for doing the == test
21:31:30 <MacCoaster> mmorrow: O_o can use \in character as a function name? cool.
21:31:34 <jmcarthur> narens: hpaste?
21:31:36 <c_wraith> narens: are you using an O(n^2) algorithm?
21:31:43 <mmorrow> MacCoaster: haskell supports full unicode :)
21:31:44 <narens> no just a linear search
21:32:08 <narens> count :: (Eq b) => Transactions a -> b -> (a -> b) -> Int
21:32:08 <narens> count transactions item project =
21:32:08 <narens>     foldl' (\acc x -> acc + if project x==item then 1 else 0) 0 transactions
21:32:17 <mmorrow> MacCoaster: oops, that's Data.Sequence
21:32:21 <mtnviewmark> my brain must be foggy: Is there a Monad instance that is like Either: a "short circuiting" error string, and a value?
21:32:38 <dmwit> mtnviewmark: Yep, (Either String) is just like that.
21:32:48 <mtnviewmark> only it isn't a monad
21:32:54 <MacCoaster> mmorrow: whats mempty?
21:32:54 <jmcarthur> mtnviewmark: sure it is
21:33:03 <jmcarthur> mtnviewmark: Control.Monad.Error or somesuch
21:33:04 <c_wraith> mtnviewmark: import Control.Monad.Instances ()
21:33:04 <dmwit> > Left "foo" >> Right "are you sure?"
21:33:06 <lambdabot>   Left "foo"
21:33:09 <mtnviewmark> urk - okay - why is my doc failing me?
21:33:11 <jmcarthur> i don't think it's in Instances
21:33:11 <ksf> narens, use foldr, that works in constant space.
21:33:12 <mtnviewmark> aha
21:33:29 <mmorrow> MacCoaster: it's from Monoid
21:33:31 <narens> ksf: well that shouldn't change speed right
21:33:32 <ksf> ...as it dosn't have to unroll the spine of the list.
21:33:40 <jmcarthur> what stinks is that the Monad and Applicative instances for Either don't agree
21:33:43 <ksf> it does.
21:33:53 <mmorrow> MacCoaster: e.g. (+,0),(*,1),(++,[]),((.),id),(union,empty),(intersection,all),...
21:33:57 <mmorrow> MacCoaster: are monoids
21:34:10 <mmorrow> mempty in those being 0,1,[],id,empty,all
21:34:11 <MacCoaster> ah, thanks, i'll look up .. Data.Monoid right?
21:34:32 <ksf> it also changes the way the production and consumption of the list fuses, and might offer better optimizing opportunities for ghc.
21:34:52 <mmorrow> MacCoaster: so mempty in that code is the mempty for IntSet
21:34:53 <narens> ksf: trying it out
21:35:23 <iaefai> Thank you everyone - my server config code works great on windows as well as mac after getting rid of a ConfigFile dependency (it requires Posix)
21:35:35 <narens> ksf: 1 second faster!
21:35:42 <narens> ksf: well 0.7
21:35:49 <jmcarthur> narens: can you paste the whole program in hpaste?
21:36:04 <mtnviewmark> er, nope, Control.Monad.Instances only defines Either a as a Functor, not a Monad
21:36:15 <jmcarthur> mtnviewmark: i think it's Control.Monad.Error
21:36:29 <ksf> Error is Either String, though.
21:36:39 <jmcarthur> that's what he's after, i thought
21:36:46 <ksf> > Left "Foo" >> Left "Bar"
21:36:46 <lambdabot>   Left "Foo"
21:36:49 <ksf> hey.
21:36:58 <ksf> > Right "Foo" >> Right "Bar"
21:36:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:37:00 <lambdabot>    `GHC.Show.Show a'
21:37:00 <lambdabot>      a...
21:37:09 <ksf> > Right "Foo" >> Right "Bar" :: Either String String
21:37:10 <lambdabot>   Right "Bar"
21:37:15 <mmorrow> MacCoaster: err sorry, the /first/ mempty is the empty Data.Sequence, the second mempty is the empty IntSet
21:37:26 <jmcarthur> oh
21:37:30 <mmorrow> MacCoaster: which nicely illustrates its usefulness
21:37:42 <MacCoaster> got it, i think :) thanks!
21:37:53 <narens> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12045#a12045
21:38:03 <narens> jmarthur: i am trying to speed up the count function
21:38:04 <ksf> ...there's no way to define Monad Either, after all. wrong kind.
21:38:05 <mmorrow> > (mempty,mempty,mempty) :: ([a],IS.IntSet,IM.IntMap b)
21:38:06 <lambdabot>   ([],fromList [],fromList [])
21:38:18 <mmorrow> > (mempty,mempty,mempty) :: ([a],IS.IntSet,[b])
21:38:19 <lambdabot>   ([],fromList [],[])
21:39:29 <jmcarthur> narens: i take it from the lack of a main function that you are testing in ghci?
21:39:38 <jmcarthur> narens: have you tried compiling with optimizations?
21:39:45 <narens> jmarthur: well, there are a bunch more files that are using it
21:39:49 <jmcarthur> ah
21:39:51 <narens> jmarthur: yea -O2 and things
21:39:58 <jmcarthur> okay
21:40:12 <narens> jmarthur: I am just wondering if there are standard optimizations for matching lists of integers quickly
21:40:28 <mtnviewmark> It is what I'm after, --- and I have to say, I looked at the doc for Control.Monad.Error(.Class) -- and it really didn't make it clear that importing it would make Either String do what I want.....
21:40:31 <narens> jmarthur: without using indices and things... just simple counting.
21:40:42 <jmcarthur> narens: i'm gonna idiomize it for my own sake and see if that leads to a discovery
21:40:51 <mtnviewmark> seems to be a common issue that Haddock doesn't ever seem to tell me enough information about the instnaces
21:41:03 <jmcarthur> can you paste a couple lines to that page of sample input, please?
21:41:10 <mtnviewmark> "okay, so Foo is an instance of Bar.... what strategy is it using?...."
21:41:22 <jmcarthur> or is it really just space separated Ints with newlines every once in a while?
21:41:30 * jmcarthur actually looks at the code
21:41:43 <narens> jmcarthur: tab separated and newlines between records
21:41:53 <jmcarthur> okay
21:42:33 <narens> jmcarthur: the reason i want it to be fast is that typical datasets will have over 100,000 rows and maybe > 100 columns
21:42:43 <jmcarthur> okay
21:42:45 <narens> jmcarthur: and i need to repeatedly calculate probabiliteis
21:44:08 <dmwit> > intercalate "\t" ["a", "b", "c"]
21:44:09 <lambdabot>   "a\tb\tc"
21:44:12 <mmorrow> narens: you should be using foldl' for anything like summing Ints or union/intersecting lists of sets/maps, etc
21:44:40 <narens> mmorrow: i aggree... i actually did, someone here suggested using foldr
21:44:47 <ksf> and it got faster!
21:44:53 <narens> mmorrow: ksf did and it was faster ;-)
21:45:00 <mmorrow> narens: urg, foldr would be slower and a space leak
21:45:04 <mmorrow> for Int?!
21:45:27 <mmorrow> foldr (\x acc -> acc + if project x==item then 1 else 0) 0 transactions ?
21:45:28 <narens> mmorrow: i might change it back... maybe if i use bigger input leak may show up
21:45:30 <ksf> for [Int]
21:45:47 <narens> obviously, i want that addition to be strict too
21:45:55 <mmorrow> which foldr are we talking about here
21:45:56 <mmorrow> ?
21:46:00 <ksf> primitive addition is strict.
21:46:19 <dmwit> toStr = unlines . map printt where printt t = intercalate "\t" . map show . (classAttr t:) . attrs $ t
21:46:41 <iaefai> Anyone know what the term for the default document in an httpd serving is? (say when you request / and normally it gives you index.html)
21:46:54 <narens> dmwit: thanks, that file is rough...
21:47:31 <c_wraith> iaefai: in servlet-land, they call it a welcome page.  Who knows about the rest of the world.
21:47:44 <dmwit> I can't say I understand why Transaction/Transactions exist at all.
21:47:54 <iaefai> c_wraith: well I suppose I can take that as a name
21:48:00 <narens> well, if i could go back to my original question. Can speed improvements be gained by not using a list to store all the numbers read from the input in terms of comparisons?
21:49:12 <ksf> If you can do it in one pass, lists are your best bet because the garbage collector can clean up as you traverse your file.
21:49:41 <dmwit> count transactions item project = length . filter (==item) . map project $ transactions
21:49:44 <narens> ksf: i am going to keep it in mem and do more comparisons... so i have to keep it around
21:49:49 <ksf> if you need access from both sides, use a Sequence, if you need random access, use a map.
21:49:55 <jmcarthur> narens: what kind of parameters are you giving count? i'm trying to set up a reasonable performance test
21:50:06 <narens> ksf: nope, just need a left to right traversal
21:50:13 <mmorrow> , time (foldr (+) 0 [0..100000])
21:50:15 <lunabot>  (6.799e-2,5000050000)
21:50:17 <mmorrow> , time (foldl' (+) 0 [0..100000])
21:50:19 <lunabot>  (9.998e-3,5000050000)
21:50:41 <ksf> mmorrow, spine unrolling.
21:50:41 <mmorrow> saying nothing about the memory usage of the two
21:50:53 <narens> jmcarthur: 500 rows of integers and 7 columns and run it 7 times and count any record
21:51:27 <mmorrow> > foldl' S.union mempty (fmap S.fromList (replicate 1000 [0..999]))
21:51:28 <lambdabot>   fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,...
21:51:32 <mmorrow> > foldr S.union mempty (fmap S.fromList (replicate 1000 [0..999]))
21:51:35 <lambdabot>   fromList [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,...
21:51:41 <mmorrow> > foldr S.union mempty (fmap S.fromList (replicate 1000000 [0..999]))
21:51:44 <jmcarthur> narens: no i mean what specifically are you using as "transactions", "item", and "project"?
21:51:46 <lambdabot>   mueval: ExitFailure 1
21:51:50 <mmorrow> > foldl' S.union mempty (fmap S.fromList (replicate 1000000 [0..999]))
21:51:54 <lambdabot>   mueval-core: Time limit exceeded
21:52:18 <jmcarthur> especially the latter two parameters
21:52:23 <narens> jmcarthur: project = attrs, item = [list of ints], transactions = list of Transaction Int
21:52:50 <c_wraith> I should learn the new version of Criterion.  Apparently you don't need the + n - n trick anymore.
21:52:54 <dmwit> I strongly suspect that the two easiest ways to speed this up are 1. use ByteString for your IO 2. compare raw ByteStrings rather than converting to [Int] and then back into String.
21:53:14 * ksf challenges the second.
21:53:25 <narens> dmwit: 1. I can use, 2. I cannot because i eventually need to read that number
21:53:39 <narens> dmwit: 1. i know will reduce setup time
21:53:49 <dmwit> 1. is more important, anyway
21:54:08 <dmwit> 3. of minor importance: use fewer wrapper data types
21:54:12 <ksf> comparing on bytestrings is bound to use byte-by-byte comparisons, unless ghc has become much smarter lately.
21:54:20 <dmwit> I've had this matter... but not often.
21:55:03 <narens> dmwit: gotcha, i actually converting Transaction to a newtype... no improvment
21:55:10 <jmcarthur> meh, this is getting too hard to rig up
21:55:16 <copumpkin> ksf: really?
21:55:17 <ksf> also look at a memory breakdown by type, and, especially if you see lots of cons cells, use stream fusion.
21:55:22 <narens> jmcarthur: don't worry about it...
21:55:27 <narens> jmcarthur: thanks though
21:55:33 <jmcarthur> narens: are you sure the problem is counts and not how many times you are calling it or something?
21:55:38 <mmorrow> iirc the ByteString lib does an ffi call to memcmp
21:56:15 <ksf> copumpkin, now that you ask, I bet dons uses memcmp in case ghc doesn't vectorize...
21:56:21 <narens> jmcarthur: i guess the problem here I don't know how fast it should be... I might just end up using an index to get counts directly
21:56:35 <jmcarthur> narens: is this a n^2 algorithm you are using or something, perhaps?
21:56:44 <narens> jmcarthur: n being?
21:56:54 <jmcarthur> number of rows, or something?
21:57:01 <copumpkin> yeah, it does use memcmp
21:57:04 <narens> jmcarthur: linear in number of rows
21:57:08 <jmcarthur> calls to count?
21:57:26 <narens> jmcarthur: calls to count = number of columns
21:57:32 <jmcarthur> oh, okay
21:57:36 <narens> jmcarthur: which is the killer
21:58:22 <narens> jmcarthur: but, as a general rule of thumb how fast can you generally compare a million ints?
21:58:32 <dmwit> fast
21:58:39 <iaefai> It appears that this page: http://www.haskell.org/debugging/  was last updated 2000. So what is the best way  to debug an application nine years down the road? I specifically want to see what a certain variable contains at a certain point.
21:58:47 <narens> dmwit: less than a second?
21:58:48 <dmwit> > [0..1000000] == [0..1000000]
21:58:50 <lambdabot>   True
21:58:52 <dmwit> narens: easy
21:58:56 <jmcarthur> > all $ map (>0) [1..1000000]
21:58:58 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
21:58:58 <lambdabot>         against inferred ...
21:59:08 <dmwit> > [0..100000000] == [0..100000000] -- 100 million
21:59:10 <c_wraith> @hoogle trace
21:59:11 <lambdabot> Debug.Trace trace :: String -> a -> a
21:59:11 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
21:59:11 <lambdabot> module Debug.Trace
21:59:13 <lambdabot>   mueval-core: Time limit exceeded
21:59:27 <c_wraith> iaefai:  I'd use Debug.Trace trace...  But I don't know if it's the best approach
21:59:37 <mmorrow> iaefai: do you want the real value it might contain at some point, or the value it would evaluate to if it were forced at that point?
21:59:47 <jmcarthur> , time ([0..999999] == [0..999999])
21:59:49 <lunabot>  (0.112983,True)
22:00:04 <narens> nice
22:00:13 <mmorrow> iaefai: ie it's not as cut-and-dry as it would be in eg C
22:00:13 <iaefai> mmorrow: it really wouldn't be different (afaik) in my case
22:00:14 <narens> can you actually run that on ghci?
22:00:21 <jmcarthur> afaik, no
22:00:49 <c_wraith> , time ([0..999999] == [(0::Int)..999999])
22:00:51 <lunabot>  (6.0991e-2,True)
22:01:04 <jmcarthur> huh, was defaulting to Integer i guess?
22:01:12 <mmorrow> narens: if you're interested in that `time' function, it's just a wrapper over a function in timeit from hackage
22:01:12 <c_wraith> jmcarthur:  remember that int-likes default to integer
22:01:17 <jmcarthur> yeah
22:01:26 <mmorrow> err, or whatever that package is called
22:01:27 <narens> kewl
22:01:33 <mmorrow> @hackage timeit
22:01:33 <lambdabot> http://hackage.haskell.org/package/timeit
22:01:41 <jmcarthur> i never pay attention to such things because i have such a habit of putting type signatures in my source files
22:01:56 <dmwit> I can compare 1e8 Integers in 5s in ghci here; that'll be even faster when compiled.
22:01:59 <mmorrow> (lunabot's `time' is using unsafePerformIO of course, since it can't do IO)
22:02:25 <mmorrow> iirc
22:02:32 <c_wraith> isn't there a flag for ghci that will turn on timing and a short memory use summary for each line you execute?
22:03:00 <mmorrow> time a = let (t,!o) = timeItT a in (t,o)
22:03:02 <mmorrow> or something
22:03:05 <mmorrow> oops
22:03:39 <mmorrow> bah. i can't remember
22:04:23 <mmorrow> time a = unsafePerformIO (timeItT (return $! a))
22:04:43 <narens> jmcarthur: just thought of something. I can just sort the list of records based on the head of each record and then modify count to stop when the first num is bigger... should prune out a lot.
22:05:37 <jmcarthur> narens: so let me make sure i understand 100% what's going on here. perhaps i can just whip up my own solution. you have what is essentially [[Int]] and you are looking for... all duplicate rows?
22:05:40 <dmwit> > 3:undefined == 4:undefined
22:05:42 <lambdabot>   False
22:06:06 <mmorrow> > zipWith (==) (3:undefined) (4:undefined)
22:06:07 <lambdabot>   [False* Exception: Prelude.undefined
22:06:10 <narens> jmcarthur: given item = [Int]; count how many times item is in [[Int]]
22:06:18 <jmcarthur> ah
22:06:31 <nolrai_FG> So how does one debug a parser writen in parsec, stepping through with ghci doesn't seem to be super useful?
22:06:54 <jmcarthur> sounds like some sort of a, err, multitrie would be the nicest solution
22:06:59 <mmorrow> > and (zipWith (==) (3:undefined) (4:undefined))
22:07:00 <lambdabot>   False
22:07:04 <mmorrow> :o
22:07:11 <narens> anyway, thanks for the help. I'm off.
22:07:26 <mmorrow> i wonder what (==) for list is doing
22:07:46 <jmcarthur> i am not very familiar with the various trie libraries, but one which basically gives you a map from [Int] to Int and looking up the Int value for some item would be nice
22:07:51 <jmcarthur> dang, he left
22:08:20 <c_wraith> nolrai_FG:  try to isolate the failure to a specific sub-part of the parser by running the various sub-parts independently, working from the bottom up?
22:08:45 <nolrai_FG> That makes sense. Thanks!
22:10:31 <nolrai_FG> :t zipWith
22:10:32 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
22:11:13 <nolrai_FG> (3:undefined) == (4:undefined)
22:11:17 <nolrai_FG> > (3:undefined) == (4:undefined)
22:11:19 <lambdabot>   False
22:11:28 <mmorrow> ahah
22:11:32 <mmorrow> i just realized
22:11:40 <mmorrow> > 3:undefined == 4:undefined
22:11:40 <lambdabot>   False
22:11:44 <mmorrow> :!!
22:11:50 <mmorrow> <dmwit> > 3:undefined == 4:undefined
22:11:51 <mmorrow> <lambdabot>   False
22:11:59 <mmorrow> wait
22:12:02 <jmcarthur> huh?
22:12:08 <nolrai_FG> That is expected, right?
22:12:09 <mmorrow> whoa, for some reason i read that as undefined
22:12:10 <jmcarthur> i don't understand what's so shocking here
22:12:17 <jmcarthur> haha
22:12:24 <mmorrow> weird, i could of sworn that the result from dmwits was undefined
22:12:29 <mmorrow> until right after i pasted that
22:12:31 <mmorrow> :)
22:13:04 <nolrai_FG> brains are strange and wonderus things.
22:13:58 <dmwit> The point of that was to show narens that sorting a list before comparing it is probably silly from an optimization standpoint.
22:14:08 <c_wraith> nolrai_FG:  the fact that parsec works by composing small parser bits into larger parser bits is why I like monadic combinator parsers so much.  it makes testing various parts so nice.
22:14:54 <nolrai_FG> Okay yeah that is good.  I just need better tests.
22:15:14 <ksf> guy on reddit claims monadic parsers are 20 times slower than c++ even with bytestring and fusion.
22:15:27 <ksf> I guess someone's wrong on the internet.
22:16:09 <nolrai_FG> Then what in c++ would be my question. Yacc?
22:16:22 <ksf> heck surely parsec can't compete with parser generators, but 20 times is a figure reserved for abdominations like ruby.
22:16:25 <c_wraith> honestly, how fast does your parser need to be?  Most applications don't read 200MB files with complicated parsing schemes.
22:17:21 <jmcarthur> parsec is typically faster than most homerolled ad hoc c++ parsers
22:17:34 <jmcarthur> unless you *really* know what you're doing
22:17:47 <ksf> waaagh do people _have_ to be allowed to delete their posts?
22:18:22 <dmwit> ksf: I agree, that is really annoying.
22:18:33 <dmwit> ksf: (But I think it makes sense to allow moderators to have that power.)
22:18:35 <jmcarthur> would be nice if not only could you see "deleted" posts but you could also see all versions of posts after they have been edited
22:18:44 <mmorrow> ksf: but then you would need to think twice before making unsubstantiated claims
22:19:03 <mmorrow> and no one wants that!
22:19:35 <nolrai_FG> jmcarthur: that would be nice
22:21:30 <BMeph> mmorrow: Right, because everyone always triple-checks to reliable sources, and tones down any overly-opinionated words before they put it on te Internet...right? Right?!? 8D
22:22:14 <mmorrow> BMeph: the simply deletes the post when they turn out to be wrong, convenience for TW!!
22:22:32 <ksf> mmorrow, your claims are both wrong and unsubstititated. both of them.
22:22:54 * mmorrow furiously presses delete
22:22:57 <ksf> mine, too. in fact, all of your claims are unsubstituated
22:23:12 <nolrai_FG> funnnnnnnnnnn
22:23:17 <ksf> additionally, there are no flames here, anywhere.
22:24:54 * ksf decides that it's time to divorce myself even further from reality. i.e. go to bed.
22:25:43 <nolrai_FG> Dream of electric sheep!
22:26:02 <BMeph> ksf: Aw, no need for a divorse; just a little time apart will do you both good! ;)
22:26:13 <BMeph> *divorce
22:27:10 <ksf> nolrai_FG, now see what you've made me do. I'm going to listen to http://www.lastfm.de/music/Blackmail/Do%2520Robots%2520Dream%2520of%2520Electric%2520Sheep%253F?ac=do%20robots%20dream%20of%20elect , now.
22:28:34 <iaefai> If somebody referred to something as 'point-free' with the context of haskell, what might that mean?
22:28:51 <sproingie> it means removing parameters from function definitions
22:29:10 <ksf> @ pl \f g x = g f x
22:29:15 <sproingie> those being the "points"
22:29:16 <ksf> @pl \f g x = g f x
22:29:17 <lambdabot> (line 1, column 8):
22:29:17 <lambdabot> unexpected "="
22:29:17 <lambdabot> expecting pattern or "->"
22:29:25 <ksf> @pl \f g x -> g f x
22:29:26 <lambdabot> flip id
22:29:33 <sproingie> ironically point-free definitions in haskell tend to use a lot of dots
22:29:41 <ksf> ...where f, g, and x are points.
22:29:43 <sieni> sproingie: haha :-)
22:29:56 <nolrai_FG> That confused me at first.
22:30:16 <sproingie> "point" in this case is a term from topology
22:30:22 <reltuk> are monoid laws stronger or weaker than monad laws?
22:30:41 <sproingie> eta-reduced might be another term you could use
22:30:45 <roconnor> @quote Kleisli
22:30:46 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
22:30:58 <ksf> reltuk, they're natural laws.
22:31:05 <ksf> they've got infinite strength.
22:31:12 <iaefai> sproingie: they look like a good way to confuse novices :p
22:31:13 <BMeph> reltuk: Since they're the same laws, I'm not sure what answer you'd like best. How about, "Mu!" :)
22:31:22 <roconnor> reltuk: a monad is just a monoid in the category of endofunctors
22:31:25 <sieni> iaefai: The term comes from topology and/or category theory, where it is useful to express some properties without explicitly referring to the points of the underlying space
22:31:27 <roconnor> what's the problem?
22:31:39 <sproingie> 299,792,458 m/sec.  it's not just a good idea, it's THE LAW
22:31:42 <reltuk> ksf: they looked the same...I thought maybe there was a subtle different :-p
22:32:53 <reltuk> roconnor: ahhh, ok
22:33:22 <BMeph> "Gravity: It's not just a Good Idea, it's THE LAW!" -- get the right quote, and the quote right. ;)
22:33:24 <copumpkin> that's a monoid object by the way
22:33:25 <mrd> sproingie: in a vacuum
22:33:40 <copumpkin> not one's typical monoidness
22:34:58 <sproingie> BMeph: meh, gravity is "just a theory"
22:35:08 <sproingie> i like throwing that one at the ID folks
22:35:08 <copumpkin> I'm a newtonist
22:36:51 <sproingie> the way haskell leverages monads is obvious, what with do-notation and all.  does the standard lib leverage the common properties of monoids?
22:37:19 <jmcarthur> not as much as it could
22:37:30 <jmcarthur> but check out the monoids package for some of what's lacking
22:37:45 <sproingie> Foldable looks like one possibility i suppose
22:37:56 <sproingie> but then i don't know anything using Foldable in anger
22:38:24 <iaefai> hey roconnor, with your help today I devised a way of simplifying my other function
22:39:13 <iaefai> respond n str = (return . Response n []) str   along with   ok = respond 200   allows me to do readFile ((documentRoot config) ++ uri) >>= ok
22:53:11 <cathper> Yesterday evening I couldn't sleep because I was thinking about some Haskell program. And this morning I woke up before the alarm clock started, and was thinking about the same Haskell program.
22:53:26 <cathper> This never happened with any other programming language :-)
22:53:31 <medfly> hehe
22:53:39 <mauke> OH GOD IT'S IN MY BRAIN GET IT OUT GET IT OUT
22:53:47 <medfly> "clearly, Haskell must suck. I can't think off a solution for this!"
22:54:01 <medfly> of*
22:56:24 <mtnviewmark> "clearly, Haskell must suck. My expat based parser for this XML format is only 86 lines.  It is over 600 in C++...."
22:56:32 <dolio> That mostly happens to me with Agda these days.
22:57:35 * mtnviewmark <-- is astounded, actually
22:57:54 <nolrai_FG> :t foldr
22:57:56 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:58:01 <nolrai_FG> :t foldl
22:58:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:00:26 <nolrai_FG> :t foldl (+)
23:00:28 <lambdabot> forall a. (Num a) => a -> [a] -> a
23:00:33 <nolrai_FG> :t foldr (+)
23:00:34 <lambdabot> forall a. (Num a) => a -> [a] -> a
23:00:38 <dolio> That type for foldl still throws me off.
23:00:39 <nolrai_FG> hmm
23:01:30 <nolrai_FG> I asume theres a way to write "foldr [] ($) (reverse items)" with foldl?
23:01:45 <dmwit> That doesn't look well-typed.
23:01:55 <nolrai_FG> its not
23:02:14 <dmwit> :t foldr (.) id
23:02:15 <lambdabot> forall b. [b -> b] -> b -> b
23:02:24 <dmwit> :t mconcat
23:02:25 <lambdabot> forall a. (Monoid a) => [a] -> a
23:02:32 <dmwit> :t mconcat . map Endo
23:02:34 <lambdabot> forall a. [a -> a] -> Endo a
23:02:39 <dolio> @type foldl (flip ($))
23:02:41 <lambdabot> forall b. b -> [b -> b] -> b
23:02:42 <dmwit> :t unEndo . mconcat . map Endo
23:02:44 <lambdabot> Not in scope: `unEndo'
23:02:50 <copumpkin> runEndo ?
23:02:55 <dmwit> :t runEndo . mconcat . map Endo
23:02:56 <lambdabot> Not in scope: `runEndo'
23:02:59 <dmwit> nope
23:02:59 <copumpkin> guess not :)
23:03:01 <nolrai_FG> I meant "foldr ($) [] (reverse items)"
23:03:02 <copumpkin> @src Endo
23:03:02 <lambdabot> Source not found. Are you on drugs?
23:03:03 <dolio> appEndo
23:03:09 <copumpkin> ah, of course ;)
23:03:12 <dmwit> :t appEndo . mconcat . map Endo
23:03:14 <lambdabot> forall a. [a -> a] -> a -> a
23:03:15 <copumpkin> yay for consistent names
23:03:20 <mauke> :t foldr ($) [] (reverse ?items)
23:03:21 <lambdabot> forall a. (?items::[[a] -> [a]]) => [a]
23:03:48 <nolrai_FG> really?
23:03:53 <mauke> yes
23:03:55 <dmwit> nolrai_FG: really
23:03:57 <nolrai_FG> that doesnt look right to me.
23:04:00 <nolrai_FG> hmm
23:04:06 <mauke> what are you trying to do?
23:04:08 <dmwit> Is [] really your base case?
23:05:05 <nolrai_FG> Yes it is, okay now that makes sense.
23:05:55 <nolrai_FG> I was just thrown cause my functions are only dealing with the fronts of the lists.
23:08:21 <mtnviewmark> OMG: It worked!
23:08:40 <mtnviewmark> that is, my 86 line hexpat parser really parses the same thing my 600+ line version in C++ does
23:09:01 <jmcarthur> i bet it can be made smaller :)
23:10:33 <copumpkin> yeah, let the golfing commence!
23:10:43 <copumpkin> need moar arrows and (a ->) monadz
23:11:18 <Gracenotes> and import statements :/
23:11:48 <jmcarthur> import TheEverythingPrelude -- we need this :P
23:13:09 <dibblego> when working on two cabal projects where one depends on the other, what is a typical set up?
23:13:22 <mauke> http://search.cpan.org/~adamk/Acme-Everything-1.01/lib/Acme/Everything.pm
23:15:05 <Jeb> hello
23:33:07 <reltuk> anyone know a tutorial for the monoids package?
23:33:24 <c_wraith> Um.   Monoids need a tutorial?
23:33:33 <copumpkin> the monoids package is enormou
23:33:33 <copumpkin> s
23:33:35 <copumpkin> and nope
23:33:45 <jmcarthur> it's not as enormous as it used to be
23:33:52 <jmcarthur> a lot of it got cut out
23:34:12 <c_wraith> moved elsewhere, or just eviscerated?
23:47:30 <Jeb> lamdabot
23:47:39 <copumpkin> indeed
23:49:36 <dibblego> if I have a MPTC with two type variables, which will always appear together, how can I tighten up the need to appease the inferencers?
23:50:11 <dmwit> FDs?
23:50:21 <dmwit> class Foo a b | a -> b where ...
23:50:41 <ray> i'm pretty sure that is what fundeps are for
23:50:43 <dmwit> (which means there is a type function that can give me the second type of the type class given the first)
23:51:15 <dibblego> of course, thanks
23:57:51 <Jeb> hello
23:58:22 <Jeb> suppose I have a constructor that takes two parameters, and I want to combine this with a list using foldr1
23:58:54 <Jeb> wait nevermind, think I figured it out
