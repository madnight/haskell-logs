00:00:14 <junmin> roconnor: is there any good tutorial about this?
00:00:37 <copumpkin> spend more time learning to think in the haskell way :)
00:01:06 <copumpkin> eventually the concept of a global variable will be so foreign to you that you won't even think of it as an option
00:01:12 <junmin> copumpkin: yeah, that's what i should do..
00:01:27 <copumpkin> (even though it is an option in haskell, but a very very naughty one)
00:02:45 <junmin> copumpkin: how to restrict the scope?
00:03:00 <toast-opt> thx for the dijkstra
00:21:58 <mike8901> I'm trying to construct a semi-efficient LCS algorithm using a self-referential table, but I'm a little confused
00:22:46 <mike8901> right now, I have lcsTable:: Int -> Int -> [[Int]]
00:22:52 <mike8901> er, sorry
00:22:59 <ksf> so, either you people are now going to tell me what the holy grail of IO is, or.... or.... I'm going to re-read the iteratee papers!
00:23:09 <mike8901> lcsTable -> [Char] -> [Char] -> [[Int]]
00:24:38 <mike8901> I'm getting unification would give infinite type, however
00:24:54 <mike8901> I'm not quite sure I'm approaching the problem correctly...
00:25:54 <ksf> ...that usually means that you have a = [a], which usually is a mistake, because you can't do much with that type.
00:26:15 <ksf> if you want to have it, though, you can introduce a datatype to break the recursion.
00:26:53 <mike8901> I have a feeling I'm doing something wrong -- does it make sense to have a single function generating a table of all lcs?
00:26:54 <ksf> ...the question is: what do you mean with self-referential table?
00:27:53 <mike8901> ok, what I was thinking was to have a table where ((myTable !! i) !! j) would give me the lcs for strings starting at index i in the first string, and j in the second string.
00:28:14 <ksf> you can do things like fibs = 1:1:zipWith (+) fibs (tail fibs) just fine, that's self-referential
00:29:21 <ksf> using !! is usually a sign that your code will be both slow and quite verbose...
00:29:37 <Jedai> mike8901: for lcs or others dynamic programming algorithm arrays are better than lists
00:31:01 <Jedai> mike8901: I'm speaking about immutable lazy array, so don't think I'm advocating an imperative algorithm, in fact Haskell is one of the few language where you can express DP like that thanks to lazyness
00:31:38 <mike8901> Jedai: That's what I'm trying to do - make a table that will find the lcs's of all substrings, so that I can evaluate it lazily
00:32:04 <mike8901> I'm trying to implement an algorithm similar to http://cs.wellesley.edu/~cs231/fall01/memoization.pdf
00:35:24 <Jedai> mike8901: for Haskell-style DP, you just have to write the recursive version and then place it into a lazy arrays and just replacing the recursive calls by index into the table
00:39:15 <Jedai> mike8901: ok, this paper gives you the algorithm and even the table, with this example, maybe you'll understand how to stick the pieces together : http://www.haskell.org/haskellwiki/Dynamic_programming_example
00:43:15 <Jedai> mike8901: if you still don't get it, I can give you parts of the code, but I guess it would be more satisfying to do it by yourself ^^
00:43:21 <mike8901> yeah
00:43:26 <mike8901> I'll give it a try
00:43:47 <mike8901> I'm probably gonna head to bed for now though
01:18:52 <mwc> Shit. Cabal doesn't like that I have a circular dependency between a module and an hsc2hs derived module
01:19:17 <mwc> I have A.hs and B.hsc. I tried creating B.hs-boot, no joy, so I tried B.hsc-boot, no joy
01:19:46 <mwc> I suppose I could create an A.hs-boot, but A uses one thing from B and B uses a dozen from A ;)
01:19:55 <mwc> any alternatives?
01:23:01 * Saizan wonders why the B.hs-boot doesn't work
01:23:22 <Saizan> maybe because it won't be alongside the B.hs?
01:23:48 <ksf> circular dependencies are trivially resolvable in all cases
01:23:56 <ksf> just copy everything into one module
01:24:29 <Saizan> or abstract some things
01:24:30 <ksf> then, to calm your inner perfectionist, move stuff out again, unless it would introduce a circular dependency.
01:25:34 <ksf> it's e.g. entirely possible to code a non-terminating circular mutual recursion across 5 perl modules.
01:25:37 <ksf> I've done it.
01:25:58 <ksf> it figures, stuff that's close together usually doesn't mind depending on each other, as much.
01:29:23 <mwc> ksf: I'd like to avoid keeping everything in one module
01:29:37 <mwc> I'm binding a C library, and I have modules for each subsystem of the library
01:29:52 <mwc> and now I want to create a monad to carry around the state for using subsystems
01:30:45 <mwc> so I have a Foo.Monad library which is needed by Foo.Frobinator, Foo.Wozzler, etc. but Foo.Monad needs a few items of state from the various modules
01:30:55 <mwc> Foo.Monad is pure haskell (.hs), the others are .hscs
01:31:54 <Jewbacca> Hello #haskell.  I'm here this evening to ask about the Reader Monad example at http://www.haskell.org/all_about_monads/html/readermonad.html, where the bind part of the first definition copied verbatim returns an error
01:32:19 <Jewbacca> This is confusing, since it seems to be the official literature
01:32:43 <mwc> Jewbacca: check your whitespace
01:32:50 <Jewbacca> It's a type error
01:33:03 <mwc> Ah, alright then, what is it
01:33:13 <ziman> Jewbacca, could you paste the code together with the error message to hpaste.org?
01:33:25 <Jewbacca> Couldn't match expected type `e -> a'      against inferred type `Reader e b'         In the expression: f (r e) e
01:33:41 <Jewbacca> Sure
01:33:42 <copumpkin> oh
01:33:54 <mwc> you need an unReader in there
01:33:58 <copumpkin> Reader and -> are very similar :)
01:34:08 <Jewbacca> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12918#a12918
01:34:14 <mwc> (runReader r e) I believe
01:34:27 <ksf> mwc, then split up Foo.Frobinator into that and Foo.Frobinator.Prim, the Monad module importing all the Prim modules, and the non-prim modules importing Monad and Prim
01:34:31 <Jewbacca> I'm not using it at all, I've just typed out what I see exactly
01:34:59 <ksf> ...that collapse all modules is just a technique to break the cycle, not the end result.
01:35:06 <mwc> ksf:  good thinking, but goddamn, my .cabal file just gained 5 pounds in Other-Modules ;)
01:35:37 <Jewbacca> Any guidance?
01:35:57 <ksf> @unmtl Reader e b
01:35:57 <lambdabot> e -> b
01:36:12 <ksf> uh. you've got an a but want an b.
01:36:19 <Jewbacca> There is no b
01:36:21 <Jewbacca> But I'll try
01:36:29 <Jewbacca> Again, this is verbatim from haskell.org
01:36:34 <ksf> there is, because you haven't constrained stuff enough.
01:36:46 <Jewbacca> So perhaps that should be clarified there
01:37:00 <ksf> well, it's a wiki
01:37:14 <Zao> Well, it's a guide.
01:37:37 <Zao> It would probably have been on the wiki if it hadn't predated it, I reckon.
01:37:50 <Jewbacca> So what would make those two defitions in the first little brown box do what they are attempting to explain without an error?
01:39:06 <ziman> Jewbacca, this works here: Reader $ λe → runReader (f (r e)) e
01:39:22 <ziman> (line 8)
01:39:37 <Jewbacca> Ah, thank you
01:39:47 <ziman> because f returns a Reader, you need to run it to obtain the function that can be applied to e
01:40:26 <ziman> well, `run' could be better described as `unwrap' here :)
01:40:35 <Jewbacca> If anyone here has the power to change this or knows someone who can, I would suggest it.  Monads are hard enough to wrap an unenlightened head around when what are put forth as basic examples don't actually work.
01:41:14 <ksf> hmm. these days, people usually learn from lyah or rwh
01:41:31 <ksf> ...witnessed by the fact that you seem to be the first one to notice it.
01:41:33 <Jewbacca> I'll take a look, thanks
01:41:39 <Jewbacca> Weird
01:41:40 <ziman> Please send any comments, corrections, or suggestions to Jeff Newbern
01:42:02 <ziman> ^^ there's his e-mail address on the titlepage
01:43:06 <Jewbacca> Will do, thanks
01:43:16 <ksf> we should probably add a lhs mode to gitit, and host such stuff with that once the new server goes into production
01:43:25 <ksf> so things at least compile.
01:44:14 <ksf> even better, lhs could be extended by ghci-like print statements, so you can intertwine code and running the code.
01:44:50 <ziman> $src ((->) e) (>>=)
01:44:53 <ziman> @src ((->) e) (>>=)
01:44:53 <lambdabot> Source not found. My mind is going. I can feel it.
01:45:12 <ksf> @src (->) (>>=)
01:45:12 <lambdabot> f >>= k = \ r -> k (f r) r
01:45:21 <ziman> thanks
01:45:37 <ziman> @pl f >>= k = \ r -> k (f r) r
01:45:37 <lambdabot> (line 1, column 9):
01:45:38 <lambdabot> unexpected "="
01:45:38 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
01:45:47 <ksf> yes, that's 100% iso to Reader
01:46:13 <ziman> @pl (>==) f k = \ r -> k (f r) r
01:46:14 <lambdabot> (line 1, column 11):
01:46:14 <lambdabot> unexpected "="
01:46:14 <lambdabot> expecting variable, "(", operator or end of input
01:46:21 <ziman> okay, i'll stop flooding :)
01:46:40 <ksf> @pl \f k r -> k (f r) r
01:46:40 <lambdabot> flip flip id . (ap .) . flip (.)
01:46:54 <ksf> heh. and ap is defined in terms of >>=
01:47:04 <ziman> that's ugly
01:47:21 <ziman> @pl \f r k -> k (f r) r
01:47:21 <lambdabot> (flip . flip id =<<)
01:54:09 <endojelly> ugh, I still have to study for an interview on tuesday
01:54:18 <endojelly> it would have been last thursday, but the interviewer got ill
01:55:05 <endojelly> it's not about functional languages, I had to forget the haskell I've done almost exclusively for the past 2 years or so and get myself re-accustomed to C, python and Java... well, ok, wasn't that hard
01:55:12 <endojelly> but now it's all about algorithms, algorithms, algorithms.
01:55:31 <endojelly> which data structure would you choose? given that problem, what would be the naive approach? how can you improve it? is that an optimal solution?
01:56:03 <endojelly> quite frankly, sometimes I wonder how much time others take to find out algorithms to somewhat not too hard problems?
01:56:43 <endojelly> it's satisfying once you've got a working, optimal solution, but I simply don't know if I was too slow or not
01:57:22 <ksf> there's no "too slow", there.
01:57:23 * hackagebot upload: GPipe 1.1.0 - A functional graphics API for programmable GPUs (TobiasBexelius)
01:57:55 <ksf> speed only increases with the amount of code you can pull out of your hat-library.
01:58:23 <ksf> ...or, well, having done 10000 dynamic programming problems, you're bound to be quite fast at it.
01:58:24 <endojelly> ksf, hmm. that actually sounds really good, and right
01:58:35 <ksf> but generally, it takes time to transform everything.
01:58:36 <endojelly> heheh, yeah, I'm really getting better at dynamic programming
01:58:53 <endojelly> I always liked it, though
01:59:03 * ksf adds dynamic programming to his kata-list
01:59:08 <endojelly> it's so elegant.
02:00:01 <endojelly> I think the problems that involved dynamic programming were my favorites so far. I like it more than greedy algorithms, because with greedy algorithms you sometimes have the nagging feeling of not being sure if that greedy approach really gives you an optimal solution in the general case
02:00:50 <ksf> yep, never be too greedy.
02:01:02 <ksf> a good example of that is a*, where you have to get the heuristic right.
02:01:12 <endojelly> dijkstra is one of the simplest greedy algorithms I know (that aren't totally awfully trivial like a knapsack problem with real numbers instead of integers), and the argument for why it's greedy is pretty clear, but at first I still was reaaally suspicious.
02:01:20 <ksf> that is, it must never underestimate.
02:01:44 <ksf> oh that kind of greedy
02:02:08 <endojelly> oh you meant another kind of greey? I was talking about greedy as a special case of dynamic programming, yes
02:02:49 <endojelly> where instead of keeping a table of possible optimal subsolutions (huh, how do you say that in english?) you just keep the "best" one at that time
02:03:18 <ksf> it's "optimal subsolution", yes
02:03:59 <ivanm> what's the term for when something should always hold true?
02:04:15 * ivanm is writing documentation for his module with QC properties
02:04:16 <endojelly> ok. just looked at wikipedia and it only seems to talk about "solutions of subproblems", but I like "subsolutions" better.
02:04:30 <ksf> ivanm, invariant?
02:04:36 <ivanm> thanks ksf
02:05:47 <ivanm> dammit, that doesn't match what I wanted... :(
02:06:12 <ksf> Is there really no existing code to automatically insert the results of running code into lhs output?
02:06:30 * ksf thinks it should be a standard feature
02:06:45 <dancor> ivanm: tautology?
02:06:49 <ivanm> ksf: there is
02:06:51 <dancor> theorem
02:06:52 <ksf> ...using mueval, so gitit can use it.
02:06:55 <ivanm> ksf: lhs2tex
02:07:04 <ivanm> dancor: yeah, tautology is more like it
02:07:19 <ivanm> thinks like read . show == id; does tautology work for that?
02:07:29 <ivanm> (i.e. that it should always hold)
02:08:27 <ski> (ivanm : `retractSituation' ?)
02:08:51 <ivanm> retract situation? what does that mean?
02:09:12 <ksf> that's an axiom
02:09:21 <ksf> or, rather, law.
02:09:26 <dancor> haddock docs tend to have lots of them
02:09:45 <dancor> but idk what's best to call them..
02:09:47 <ksf> oh, that \eval stuff would be cool for haddock, too.
02:09:55 <ski> in a category, given objects `A',`B', and morphisms `r : A >-> B',`s : B >-> A', that `r' and `s' forms a retract situation means that `r . s = id_B'
02:10:09 <ivanm> hmmm.... google's 6th result for "retract situation" is a chat log featuring ski...
02:10:10 <ivanm> ;-)
02:10:12 <dancor> the monad laws are a prominent example in haddock of whatever-that's-called
02:10:19 <dancor> so ya maybe laws..
02:10:41 <ski> `r' is said to be a retraction of `s' (sometimes "left-inverse"), while `s' is said to be a section of `r' (sometimes "right-inverse")
02:11:18 <ivanm> ski: right, but that's not the only kind of thing I'm talking about
02:11:26 <dancor> ya not just where = id
02:11:27 <ivanm> is there a "formal" term for "properties that should always hold true"?
02:11:32 <dancor> lawsssss
02:11:35 <ksf> "These laws have to be kept as invariant by any code"
02:11:48 <ski> `law' sounds good to me
02:12:10 <ivanm> feels weird to be talking about laws of my functions, that's all... >_>
02:12:36 <ski> `invariant' is something that an instance of a datastructure can satisfy, and which operations might preserve
02:12:43 <dancor> well law implies that you can violate them but you shouldn't
02:12:49 <dancor> there are also like properties
02:12:54 <dancor> which stuff happens to have
02:13:01 * ski nods
02:13:29 <ksf> property sounds good, too.
02:13:43 <ksf> though maybe does'nt sound formal enough.
02:13:52 <ski> (isn't there a convention to start most names of QC .. er .. properties, with `prop' ?)
02:14:03 <ivanm> yeah, it's a property... but even calling them laws sounds wierd "laws that should be always held true by the relevant data structures" :s
02:14:14 <ivanm> ski: well, RWH ends them in _prop IIRC
02:14:21 <dancor> i think Data.Map doc might speak of properties
02:14:34 <dancor> eh they just say "we have:"
02:14:37 <ski> ivanm : example ?
02:14:50 <ski> (re data structures)
02:15:13 <dancor> if the "properties" are specific enough they are called "examples"
02:15:29 <ivanm> ski: this is for my graphviz library
02:16:06 <ivanm> I'm wanting to say that for all of them that have printing and parsing support, parse . print = id, and then a few specific to the overall DotGraph datatype
02:16:29 <copumpkin> wow, that's an intense property for a parser
02:16:52 <dancor> is it?
02:17:06 <ski> `parse' and `print' are in classes ?
02:17:10 <copumpkin> they usually forget whitespace and things that aren't significant
02:17:27 <copumpkin> oh wait, I read it backwards :)
02:17:30 <dancor> depends what ur doing, they can be significant
02:17:38 <dancor> and ya :)
02:17:55 <ivanm> copumpkin: I haven't!
02:18:00 <ivanm> ski: yes
02:18:45 <ski> ivanm : maybe it is a good idea to have a combined class which expects the `parse . print = id' law, even if it doesn't add any new operations
02:19:01 <dancor> don't classes have to add operations?
02:19:05 <ski> no
02:19:15 <dancor> where {} ?
02:19:23 <ivanm> ski: then I have to go through and add instances for every data structure for it... :(
02:19:30 <ivanm> dancor: no where
02:19:32 <ivanm> class Foo a
02:19:36 <dancor> ok
02:19:52 <ski> (hypothetical scenario : person A adds `T' to `Parsable', person B adds `T' to `Printable', person C assumes `parse . print = id' holds)
02:20:37 <dancor> good old boilerplate trade-off decisions
02:20:48 <ivanm> ski: realistic scenario: the Printing and Parsing modules aren't exported by default; the only reason they'd be used is for someone wants to use a custom type for node IDs
02:21:02 <ivanm> *by someone who wants to
02:21:05 <ski> ok
02:24:15 <mwc> @pl \a -> liftIO world >>= \c -> runMPIT c a
02:24:15 <lambdabot> (liftIO world >>=) . flip runMPIT
02:24:35 <ksf> mwc, you can also define a monad transformer for every module, and then stack them into one somewhere.
02:24:44 <mwc> that's kind of what I'm doing
02:25:14 <mwc> this is a convenience function which grabs an IO global and injects it into the transformer-stacked computation
02:25:27 <ivanm> ski: and my test suite won't be using other peoples instances ;-)
02:34:42 <vy> Hi! I have list of Point2Ds (data Point2D = Point2D { xOf :: Double, yOf :: Double }) sorted according to y coordinates. In this list, how can I take _head_ elements in the list that have same x values?
02:42:44 <Zao> vy: I do not quite follow what you need.
02:42:57 <Kim^Walkman>  vy: I'm not sure I understand your question, but would the “group” functtion in Data.List be something you are looking for?
02:43:06 <Zao> Are they sorted on y,x or just y?
02:44:13 <Kim^Walkman> Or, well, groupBy together with “comparing” from Data.Ord and “on” from Data.Function
02:45:14 <vy> Zao: On just y.
02:45:17 <Kim^Walkman> > groupBy (comparing `on` snd) [(5, 3), (5, 3), (5, 4)]
02:45:18 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> a
02:45:21 <vy> Kim^Walkman: I'll check that.
02:45:51 * hackagebot upload: arrows 0.4.1.2 - Arrow classes and transformers (RossPaterson)
02:46:24 <vy> I'm trying to follow exercies on RWH, and last question of Chap. 3 appears to be quite hard. Authors assume that we are able to use filtering/grouping/mapping/sorting/comparing without any prior knowledge of them.
02:47:17 <vy> How can I issue an "import" in ghci prelude?
02:47:44 <eivuokko> If I understood right, it's :m + Module
02:48:39 <vy> eivuokko: For instance, I want to use Data.List.sortBy in the "*Main>" prelude without a Data.List prefix.
02:48:53 <eivuokko> :m + Data.List
02:49:22 <Kim^Walkman> Ah, there it was
02:49:46 <Kim^Walkman> > groupBy ((==) `on` snd) [(5, 4), (5, 4), (5, 3), (5, 4)]
02:49:47 <lambdabot>   [[(5,4),(5,4)],[(5,3)],[(5,4)]]
02:50:37 <vy> Kim^Walkman: I typed ":m + Data.List" to be able to use groupBy, but this time it complains that "Not in scope: `on'".
02:50:47 <Kim^Walkman> vy: It's from “Data.Function”
02:51:24 <Kim^Walkman> vy: However, something that works even better: just use group :)
02:51:34 <Kim^Walkman> vy: No, wait, you had your own data type, never mind
03:04:42 <mwc> applicative functors are fucking awesome
03:11:52 <Veinor> oh dear, I seem to have a function that takes O(2^(2^(1+floor lg lg n))) to compute
03:12:13 <smiler> cabal: cannot configure haskell-src-exts-0.3.12. It requires base >=4
03:12:13 <smiler> For the dependency on base >=4 there are these packages: base-4.0.0.0 and
03:12:13 <smiler> base-4.1.0.0. However none of them are available.
03:12:20 <smiler> Can someone assist me on this matter?
03:14:05 <mwc> Veinor: huh, that's a very interesting curve
03:14:32 <Veinor> it is
03:14:38 <Veinor> basically it's the next largest fermat power
03:15:18 <Veinor> although the function's still being rather oddly slow, not sure why
03:17:09 <Veinor> either that, or something's messed up
03:17:30 <|Jedai|> Veinor: basically under O(2^(2n)) isn't it ?
03:18:12 <|Jedai|> Veinor: I don't think anything with such a complexity can be called "oddly" slow...
03:18:27 <Veinor> where n is the length of the argument, yeah
03:18:35 <Veinor> better known as O(4^n) :P
03:18:52 * smiler slaps cabal around a bit with a large trout
03:19:10 <Veinor> I think I might just have to put a note in here: 'do not call this function with arguments greater than 16'
03:20:57 <Veinor> on the other hand, I think that if you call it once for any n, all the results (or many of them, at least) up to the next fermat power will be cached
03:21:12 <Veinor> so if you call f 16, f 1 through f 255 will probably be computed
03:21:31 <A1kmm> Hi, does anyone know the most idiomatic way to write a function with the signature (ReaderT a (IO b) -> ReaderT a (Maybe (IO b))) such that Just is applied to the IO monad?
03:21:59 <dancor> djinn isn't cool enough to do that is it
03:22:17 <dancor> @djinn (ReaderT a (IO b) -> ReaderT a (Maybe (IO b)))
03:22:17 <lambdabot> Error: Undefined type ReaderT
03:22:33 <dancor> @kind ReaderT
03:22:35 <lambdabot> * -> (* -> *) -> * -> *
03:23:02 <ski> `liftM Just' ?
03:23:53 <ski> though actually that signature is ill-kinded
03:24:39 <dancor> A1kmm: ya i think you actually meant like (Maybe b) or need a MaybeT in there..
03:24:50 <ski> @kind forall a b. ReaderT a (IO b) -> ReaderT a (Maybe (IO b))
03:24:51 <lambdabot>     Kind mis-match
03:24:52 <lambdabot>     Expected kind `* -> *', but `IO b' has kind `*'
03:24:52 <lambdabot>     In the type `ReaderT a (IO b)'
03:25:14 <ski> `ReaderT' wants another argument
03:25:25 <dancor> @unmtl ReaderT a IO b
03:25:25 <lambdabot> a -> IO b
03:25:33 <dancor> @unmtl ReaderT a MaybeT IO b
03:25:33 <lambdabot> err: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
03:25:45 <dancor> @kind MaybeT
03:25:46 <lambdabot> Not in scope: type constructor or class `MaybeT'
03:25:47 <ski> @unmtl ReaderT a (MaybeT IO) b
03:25:47 <lambdabot> a -> IO (Maybe b)
03:26:07 <ski>   MaybeT :: (* -> *) -> * -> *
03:26:23 <dancor> A1kmm: did you mean: ReaderT a IO b -> ReaderT a (MaybeT IO) b
03:26:34 <A1kmm> That
03:26:56 <A1kmm> 's not the signature I was looking for... but I think I mis-read the type I am looking for, which is why I'm struggling actually.
03:27:38 <mxc> i've got a sorta nitpicky question.. I've got a project with lots of modules > 60 and in many of them i have a lot of repetitive imports...
03:27:39 <mxc> import Data.Map as DM
03:27:39 <mxc> import Data.Bytestring.Char8 as BS..  etc.  is there a way to have implicit, qualified imports, or better yet a preprocessor whcih will scan code and if a file contains any qualified references, as in DM.empty (as in Data.Map.empty) automatically add the right import, given a mapping  (DM -> Data.Map, BS -> Data.Bytestring.Char8)..
03:28:46 <blackdog> mxc: you can reexport modules from another module, so you only have to import one module in client code... might help
03:29:01 <dancor> mxc: right, you can't get qualified imports under one like "import MyUtils", so you would need an actually preprocessing step i think
03:29:08 <mxc> yeah
03:29:12 <dancor> blackdog: doesn't work with qualification right
03:29:27 <mxc> especially for modules with duplicate names
03:29:33 <mxc> Data.Set, Data.Map, etc etc
03:30:06 <dancor> mxc: well any simple preprocess will do
03:30:35 <mxc> you could have something like #define IMP_DM import qualified Data.Map as DM
03:30:42 <dancor> but then your like error line numbers will be off
03:30:56 <mxc> true
03:32:07 <dancor> mxc: ah here's a hack, you can do all on one line: import qualified Data.Set as Set; import qualified Data.Map as Map
03:32:20 <dancor> so your preprocessor can replace a single line
03:32:34 <mxc> dancor: yeah, but, just putting that in eveyrthing will give a lot of unused import warnings
03:32:37 <dancor> you can even use like sed or whatever for your preprocessor
03:33:13 <dancor> well.. you can scan for uses of the things but to do that correctly requires parsing haskell
03:33:13 <mxc> true
03:33:18 <hotzen> hey all, regarding fun-deps: they are "just" a hint for the compiler that there may only be "one" resulttype but in constrast to fam-types they are not functionally computed?
03:33:25 <dancor> which you can do
03:33:29 <mxc> yeah, was just looking at the Language.Haskell.Syntax module
03:33:54 <mxc> was thinkign that i'm probably not the only one that's had this issue,
03:33:55 <dancor> mxc: seems like a lot of work heh
03:34:03 <mxc> dancor: yes, it does.
03:34:07 <dancor> how many qualified imports do you have
03:34:10 <Saizan_> hotzen: not "may" but "must"
03:34:30 <hotzen> saizan_: ok, thanks
03:35:12 <mxc> about 10-20 per file
03:35:20 <dancor> that is a lot
03:35:35 <A1kmm> dancor: Let me state my original problem to clarify what I mean:
03:35:46 <A1kmm> I have: f1 :: (MonadIO m, MonadReader ([(String, Input)], [(String, Cookie)]) m) => ServerContext -> m FBSession
03:35:48 <A1kmm> Also: f2 :: (ServerMonad m) => ReaderT ([(String, Input)], [(String, Cookie)]) Maybe a -> m (Maybe a)
03:35:49 <A1kmm> I want to use f2 to get something of type: (ServerMonad m, MonadIO m) => m (Maybe FBSession), so I somehow need to insert Maybe into the transformer.
03:35:59 <mxc> a lot of them are my own modules thad i've written.  i've gotten pretty good at yank/inserting them in vim
03:36:03 <smiler> When trying to install haskell-src-exts through cabal I get the error "Module `System.Process' does not export `rawSystem'". Any idea on how to solve this?
03:36:30 <dancor> mxc: i think the haskell way is to just do that.  but maybe a crazy preprocessor would be interesting
03:36:39 <mxc> yeah
03:36:46 <dancor> i feel like compiles take too long already tho heh
03:36:52 <dancor> it would prob be pretty fast
03:37:25 <mxc> also, is there a way to reexport an entire module or is the only way to explicitly put every export from the original module into the where cluase of the module reexporting it?
03:37:51 <Saizan_> mxc: put module Foo in the export list
03:38:01 <mxc> ty
03:38:36 <dancor> A1kmm: this is crazy happs stuff eh?
03:38:39 <dancor> happstack
03:38:47 <A1kmm> dancor: Yes.
03:39:54 <dancor> A1kmm: just to be clear, f1 is irrelevant for the question at hand right?
03:40:25 <dancor> f1 is just what you are sticking f2 into right
03:40:32 <A1kmm> dancor: yes.
03:50:50 <Botje> i think it's too early to be sticking things into other things ..
03:50:54 <Botje> hello, everyone!
03:51:35 <ivanm> hey Botje
03:51:39 <skorpan> @remember Botje i think it's too early to be sticking things into other things ..
03:51:40 <lambdabot> I will never forget.
03:52:32 <Jafet> That's unfunny without context
03:55:24 <ivanm> Jafet: agreed
03:57:03 <dancor> i think it's only funny without context
03:57:49 <dancor> anyway i'm terrible at mtl and at happstack
03:58:33 <ivanm> dancor: I thought most people were...
03:58:43 <mxc> jafet: disagree..  its probably better w/out context
03:58:43 <dancor> funny?  no, not at all.
03:59:47 <ivanm> dancor: heh
03:59:52 <ivanm> dancor: I meant at your latter comment
04:00:14 <dancor> djinn should be able to do this mtl q..
04:00:55 <dancor> happstack prowess however might call for an actually genie
04:02:20 <Saizan_> A1kmm: so something like (f2 f1) ?
04:02:37 <Saizan_> f2 (f1 context)
04:03:09 <Saizan_> ah, no, you want to keep m polymorphic
04:03:25 <A1kmm> Yes... I ended up having to explicitly rewrite it, I think I'm almost there with:
04:03:28 <Saizan_> well, it'd work
04:03:53 <A1kmm> runRqDataT :: (ServerMonad m, MonadIO m) => ReaderT ([(String, Input)], [(String, Cookie)]) m a -> m a
04:03:55 <A1kmm> runRqDataT rdr =
04:03:56 <A1kmm>   do
04:03:57 <A1kmm>     d <- getDataFn ask
04:04:00 <A1kmm>     runReaderT rdr (fromJust d)
04:04:04 <hotzen> is there any nice example for fundeps besides Matrix/Vector and Odd/Even, perhaps in a library or so?
04:04:22 <BONUS> hotzen: MonadState is nice
04:04:27 <A1kmm> (f2 = getDataFn)
04:06:16 <Saizan_> it's debatable wheter MonadState should have that fundep
04:06:41 <hotzen> BONUS: in which file is the class-declaration?
04:07:13 <BONUS> i have it in ghc/ghc-6.10.1/doc/libraries/mtl/src/Control-Monad-State-Class.html
04:07:49 <hotzen> thank you
04:17:14 <ivanm> Baughn: you around?
04:18:06 <hotzen> sorry for newbish question: what do i have to import to use a HashMap
04:18:07 <hotzen> ?
04:18:41 <Heffalump> Data.HashTable, but I wouldn't recommend it, because the performance is pretty poor.
04:18:46 <Heffalump> and it's not a very functional structure
04:18:56 <ivanm> hotzen: use Data.Map or something instead
04:19:06 <Twey> Aw, boo
04:19:06 <lambdabot> Twey: You have 1 new message. '/msg lambdabot @messages' to read it.
04:19:15 <Twey> @messages
04:19:15 <lambdabot> copumpkin said 5h 45m 36s ago: you're a racist, apparently
04:19:18 <hotzen> ah ok, thanks
04:19:20 <ivanm> *sigh* yet another imperative programmer led astray by the lure of supposed O(1) operations...
04:19:30 <ivanm> copumpkin: proof! :p
04:19:45 <Twey> I saw all my windows lit up and thought that a whole load of really interesting things had happened whilst I was asleep
04:19:52 <ivanm> hotzen: http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
04:19:57 <Twey> Not yet another disgruntled-troll barrage :þ
04:20:05 <ivanm> @where+ hash-tables http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
04:20:05 <lambdabot> I will never forget.
04:20:09 <hotzen> ivanm: thanks
04:20:11 <ivanm> Twey: heh
04:20:24 <Jedai> hotzen: You can use Data.IntMap if your keys are Int (there is an EnumMap on Hackage too)
04:20:47 <hotzen> i use to construct a Collections class-example for fundeps
04:20:53 <Jedai> hotzen: IntMap is better than Map if you can use it
04:21:20 <hotzen> i just need a generic map, thank you guys
04:21:25 <endojelly> hmm... is O(V + V*E) in O(V + E)?
04:21:26 <Twey> Data.Map is a tree, isn't it?
04:21:31 <ivanm> Twey: yes
04:21:36 <Twey> Phew
04:21:37 <Twey> Heh
04:21:41 <Jafet> endojelly, no
04:21:47 <endojelly> Jafet, that's what I thought...
04:21:54 <Jafet> Of course you did.
04:21:56 <ivanm> Twey: IIRC, internally it's the same as the tree in Set but with a pair of values (and the key value being strict)
04:21:57 <endojelly> but then I find no solution :/
04:22:07 <ivanm> Twey: which is why there's the keysSet function in Data.Map
04:22:18 <Jafet> There is no problem.
04:22:18 <endojelly> Jafet, O(V + V*E) is really the best I can come up with for a particular problem
04:22:35 <Twey> ivanm: Ah, interesting
04:22:50 <Twey> ivanm: Er, wait, how does that work for lookups?
04:23:06 <ivanm> Twey: I'm trying to remember something I read once ;-)
04:23:20 <ivanm> but it basically does the same as looking for an element in the Set, but returns the second value
04:23:30 <Twey> Yeah, but that's the problem
04:23:31 <ivanm> Twey: so it's a similar tree structure, but not an actual Set
04:23:36 <endojelly> Jafet, given an adjacency-list representation of a multigraph G = (V,E) describe an O(V + E)-time algorithm to compute the adjacency list representation of the "equivalent" undirected graph G' = (V, E'), where E' consists of the edges in E with all multiple edges between two vertices replaces by a single edge and with all self-loops removed
04:23:41 <endojelly> solutions I can come up with:
04:23:50 <Twey> When looking for an element in the set, it uses the value of the elements to find it
04:23:51 <endojelly> O(V^2), O(V + E log E), O(V + V*E)
04:24:15 <Twey> If you use a pair as the element, the value contributes to the ord-value, but you only want the key
04:24:25 <endojelly> I really don't see how O(V + E) is possible, with the assumption that the adjacency lists are unsorted linked lists
04:24:33 <ivanm> Twey: yeah, it's not exactly a pair
04:24:41 <ivanm> I forget the exact implementation specifics
04:25:18 <ivanm> but I read something a few weeks back (I think I was actually looking through the source for Data.Map), and the internal structure is almost identical to that of Data.Set, just that a pair-like structure is used rather than a single value
04:25:30 <endojelly> I have tried the following: use an adjacency matrix. trivial, but immediately V^2 due to the size of the matrix
04:25:41 <hotzen> I want to construct an example "class Collection collType elemType". anyone an idea what to use besides List for collType to show the usage of fundeps?
04:25:45 <ivanm> Twey: so it's something like Set (KeyVal k v) with the Ord instance of KeyVal being Ord on k
04:25:58 <endojelly> 2. sort the adjacency list of each vertex, easily filter out duplicates. easy, but V + V*E
04:25:59 <ivanm> hotzen: depends on what you're wanting to do
04:26:01 <Jafet> Why V^2?
04:26:09 <endojelly> sorry
04:26:10 <Twey> ivanm: *nod*
04:26:14 <endojelly> it's V + E log E
04:26:21 <Twey> Makes sense
04:26:37 <endojelly> V + V*E is the trivially filtering out duplicates without sorting
04:26:46 <hotzen> ivanm: i want to show that you may need a constrain on the multitype class parameters
04:26:47 <endojelly> Jafet, the size of an adjacency matrix is V^2
04:27:01 <ivanm> Twey: I'm probably getting the specifics wrong, but IIRC its something like that
04:27:06 <Jafet> Why is the size of the adjacency matrix V^2? That is the maximum size.
04:27:15 <ivanm> hotzen: but what is this Collection class going to do?
04:27:27 <endojelly> Jafet, it has V^2 elements?
04:27:40 <endojelly> Jafet, I don't get what you mean? sparse matrices?
04:27:42 <Jafet> No, it has E elements, silly. One per edge.
04:27:45 <hotzen> abstracting from arbritray collections, like instance Collection [a] a ?
04:27:51 <endojelly> Jafet, ... no. no it hasn't
04:28:14 <ivanm> hotzen: what kind of functions are you wanting to do on that?
04:28:29 <ivanm> hotzen: note that Foldable, etc. don't need the extra class param there or a fundep IIRC...
04:28:30 <Jafet> What an arbitrary refutation
04:28:33 <ivanm> @src Foldable
04:28:33 <lambdabot> Source not found. You speak an infinite deal of nothing
04:28:36 <hotzen> hm, one thats problematic... ;)
04:28:43 <endojelly> Jafet, it has one element for every (i,j) where i,j in V and for a non-multigraph it's 1 if there is an edge and 0 if not
04:28:43 <ivanm> @src Traversable
04:28:43 <lambdabot> class (Functor t, Foldable t) => Traversable t where
04:28:44 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
04:28:44 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
04:28:44 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
04:28:44 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
04:28:48 <hotzen> ivanm: but im looking for a good example for fundeps :(
04:28:50 <ivanm> hotzen: ^^
04:29:27 <hotzen> ivanm: any idea for a good fundep example?
04:29:28 <endojelly> Jafet, since it has one element, its value being 0 or 1, for every element of the relation VxV it has... |V|x|V| elements!
04:29:31 <Jafet> endojelly, why create the zeroes?
04:29:33 <ivanm> hotzen: OK, here's one that I had (which I since replaced with a type family:
04:29:50 <Jafet> endojelly, stop being extra stupid on purpose
04:29:55 <endojelly> Jafet, enlighten me
04:29:59 <Jafet> It's annoying
04:30:12 <ivanm> hotzen: I was using FGL graphs, and I wanted a way of using the node labels to indicate which cluster a node was in
04:30:21 <ivanm> hotzen: and I wanted a class for the types of clusters
04:30:38 <endojelly> Jafet, okay, if I don't create the zeros, how do I access random elements in constant time?
04:30:45 <ivanm> so I had something like: class ClusterLabel l c | l -> c
04:30:54 <ivanm> that is, given a specific label type, it has a specific cluster type
04:31:02 <ivanm> I could then have Int-based clusters, etc.
04:31:12 <hotzen> what are the pipes for??
04:31:20 <hotzen> ClusterLabel | c || -> c ?
04:31:29 <ivanm> hotzen: there's an l there...
04:31:39 <ivanm> L c | L -> c
04:31:40 <hotzen> oh ...
04:31:47 <hotzen> that makes sense
04:31:48 <Veinor> Heh. I think calculating this function from the definition is going to be slower than brute-forcing it
04:31:48 <ivanm> hotzen: and the | is used to specify the fundep
04:31:56 <hotzen> so the label-type determines the cluster-type?
04:32:02 <ivanm> hotzen: right
04:32:04 <ivanm> hotzen: I wouldn't make up an excuse just to use fundeps
04:32:09 <endojelly> Jafet, because if the answer is "you don't" then that sparse representation of my adjacency matrix is useless for the running time of the algorithm, or am I missing something very obvious?
04:32:11 <ivanm> if you need fundeps, _then_ learn about them
04:32:22 <ivanm> but I find type families nicer to play with
04:32:50 <hotzen> ivanm: but i have to talk about fundeps and type families. i understand the latter but i am missing a nice example for fundeps besides vector/matrix operations
04:33:02 <Veinor> just remember: you can't spell fundeps without fun.
04:33:09 <endojelly> Jafet, hello?
04:33:12 <hotzen> everybody is stating that they have replaced fundeps for type fams ... ;)
04:33:22 <ivanm> hotzen: if you're using a type family within a class, then you can usually convert it to using a fundep AFAIK
04:33:24 <Botje> unless you're a bad speller.
04:33:35 <ivanm> @remember Veinor just remember: you can't spell fundeps without fun.
04:33:36 <lambdabot> It is forever etched in my memory.
04:33:43 <ivanm> Botje: sorry, you already got a quote remembered ;-)
04:33:47 <ivanm> * tonight
04:33:51 <Jafet> endojelly, well, I have no idea.
04:34:04 <endojelly> Jafet, where was I being stupid?
04:34:18 <hotzen> ivanm: thank you.
04:34:22 <ivanm> @tell Baughn it looks like haskell-mode needs to be updated to work with latest emacs-from-cvs: http://old.nabble.com/called-interactively-p-td25704073.html
04:34:22 <lambdabot> Consider it noted.
04:34:24 <ivanm> hotzen: no worries
04:34:25 <Veinor> (I don't even know what a fundep is >_>)
04:34:47 <Botje> it's a crutch for the type inferencer
04:34:51 <ivanm> Veinor: you have two type variables in a class, and so to avoid ambiguity you usually need to specify a relationship between them
04:34:54 <Jafet> Where you said that a matrix containing fewer than O(V^2) elements would require O(V^2) storage, in a Haskell channel
04:35:00 <ivanm> Veinor: fundep == functional dependency
04:35:01 <endojelly> Jafet, ... I didn't
04:35:05 <ivanm> @google functional dependency
04:35:06 <lambdabot> http://en.wikipedia.org/wiki/Functional_dependency
04:35:06 <lambdabot> Title: Functional dependency - Wikipedia, the free encyclopedia
04:35:10 <ivanm> @google functional dependency haskell
04:35:11 <lambdabot> http://www.haskell.org/haskellwiki/Functional_dependencies
04:35:11 <lambdabot> Title: Functional dependencies - HaskellWiki
04:35:17 <ivanm> Veinor: ^^
04:35:19 <Veinor> ah
04:35:24 <ivanm> hotzen: might be something there for you as well ^^
04:35:43 <endojelly> Jafet, I said using an adjacency matrix for the algorithm would lead the TIME OF THE ALGORITHM to being at least O(V^2)
04:36:03 <hotzen> ivanm: one more question: if you have  your ClusterLabel l c | l -> c, this does only forbid to instanciate more than  c-types for one l-type. it does not "compute" the c-type as a type-fam would do, doesn't it ?
04:36:14 <hotzen> already read those, thanks ;)
04:36:18 <Jafet> Same difference. It's not O(V^2), it's O(V + E * access_time)
04:36:29 <ivanm> hotzen: given a specific l-type, then it knows what the c-type must be
04:36:57 <endojelly> Jafet, I implied "matrix representation". because, for example, the linked list representation of the adjacency matrix is called... an adjacency list!
04:36:57 <hotzen> does it really know? i thought it would only constrain the instance-declarations without "knowing" the resulting c-type?
04:37:04 <endojelly> anyway, that is not helping
04:37:07 <endojelly> anyone else having any clue?
04:37:31 <endojelly> I think I'm missing something really obvious, there
04:37:35 <blackdog> Jafet: if you use an adjacency matrix, presumably you have to collect all of the edges at the end. That's going to involve looking at at least half of the matrix.
04:37:35 <Jafet> A matrix is a two dimensional array of stuff, and can be represented any way you like.
04:37:47 <endojelly> blackdog, thank you
04:38:02 <hotzen> ivanm: does it really know? i thought it would only constrain the instance-declarations without "knowing" the resulting c-type?
04:38:18 <ivanm> hotzen: I think it does, but I could be wrong
04:38:37 <Jafet> blackdog, I collect all the edges by successively looking at all the edges and collecting each one. How do you do it?
04:39:29 <endojelly> Jafet, so how does transforming the adjacency list into an adjacency matrix help there, then?
04:39:41 <blackdog> how do you do that with an adjacency matrix, though? it's an array-based data structure. It's entirely possible to represent it with lists, but then you're using the adjacency list representation.
04:39:50 <endojelly> Jafet, and, by your argument, isn't an adjacency list just another representation of an adjacency matrix?
04:40:22 <endojelly> Jafet, so cormen must be the one who's "being stupid on purpose" for using those terms as disjoint data structures
04:41:08 * Botje hands out lambda swords and omega shields
04:41:09 <Botje> FIGHT
04:41:10 <Botje> !
04:41:17 <Jafet> I was not talking about adjacency matrices, blackdog
04:41:29 <endojelly> ...
04:41:38 <blackdog> Jafet: that's probably the source of your disagreement then:)
04:41:52 <Veinor> what's the opposite of lift?
04:42:09 <endojelly> Jafet, that's interesting, because I used the expression "adjacency matrix" in *every single sentence*
04:42:19 <endojelly> Jafet, so what were you talking about?
04:42:24 <Botje> Veinor: drop?
04:42:45 <endojelly> 13:27 < Jafet> Why is the size of the adjacency matrix V^2? That is the maximum size.
04:42:51 <Veinor> oh wait, never mind
04:43:34 <Jafet> It seems that you are not interested in my ideas but in nitpicking. Have a nice day
04:43:47 <endojelly> okay, moving on
04:43:54 <endojelly> blackdog, you don't have, per chance, any idea?
04:44:04 <blackdog> endojelly: thinking about it
04:44:23 <blackdog> I can't see how to do it, but i can't prove it's impossible either
04:44:41 <endojelly> blackdog, it's in the section about elementary graph algorithms under "exercises", not even under "problems", so it must be really easy
04:44:46 <EnglishGent> hello :)
04:45:00 <IceDane> Does haskell have any standard types or something similar that works like a hashtable?
04:45:06 * Botje greets EnglishGent 
04:45:11 <Botje> IceDane: there's Data.Map
04:45:13 <EnglishGent> hi Botje
04:45:17 <IceDane> Botje: thanks
04:45:31 <Botje> IceDane: hashtables in haskell are generally not wanted because they are very poor at sharing
04:46:20 <EnglishGent> lots of problems do naturally translate to alists / maps though - how else would you deal with such things Botje? (serious question)
04:46:22 <IceDane> Botje: what do you mean?
04:46:33 <blackdog> endojelly: yeah, my graph algs are rusty.
04:46:51 <blackdog> and some bastard has my copy of coremn
04:46:53 <Botje> EnglishGent: Data.Map is based on trees
04:47:04 * EnglishGent reads scroll & wonders what Jafet's ideas were :)
04:47:07 <endojelly> blackdog, mine are just starting out 8)
04:47:17 <IceDane> I'm afraid I have to use a hashmap for this. Otherwise it's O(n^2) on a gigantic set
04:47:17 <Botje> so if you add an element, you only change the spine leading to that element, and everything else stays the same
04:47:40 <Botje> which means that haskell can reuse a lot of the old tree
04:47:46 <Botje> IceDane: if you must, there's a data.hashtable.
04:47:51 <Botje> but try with maps first
04:47:55 <Jafet> You can't really implement hash tables in haskell satisfactorily, since their usefulness depends on a different memory model
04:48:09 <Saizan_> IceDane: Data.Map is O(log n) for insert and lookup
04:48:21 <IceDane> Oh, I was satisfied with map
04:48:30 <IceDane> I thought it was the only thing
04:48:31 <IceDane> but it's cool
04:48:32 <EnglishGent> I guess that depends if on by 'hashtable' you mean something *logically* behaving as if it were a hash table - or something *implemented* as one
04:48:42 <EnglishGent> computer science lacks clear rules here
04:49:18 <Jafet> Haskell doesn't have the idea of linear random access memory, I wouldn't think
04:49:21 <Saizan_> i've generally seen the term "dictionary" for the abstract structure
04:49:24 <EnglishGent> think for example [x] (a data type) vs doubly-linked-list-of x (a data structure)
04:49:39 <IceDane> I just need a data-structure that behaves like one. Need to be able to insert a value into the data-structure using another value as an index. E.g, the number of x in my set is hashtable['x'].. so to speak
04:49:40 <EnglishGent> I've seen map use for it as well Saizan_
04:49:46 <flux> call it 'associative array' or 'associative map' instead of 'hashtable', if you want to refer to the concept of mapping objects to other objects?
04:49:47 <Saizan_> Jafet: we've mutable arrays as primitives, like any other lang
04:49:57 <EnglishGent> heck you could even consider it to be a special cases of a binary relation
04:51:02 <Jafet> Saizan, in the language standard?
04:52:02 <Jafet> EnglishGent, this special case is normally called a function
04:52:32 <Saizan_> Jafet: only immutable ones in the report, still O(1) indexing though
04:54:23 <blackdog> endojelly: think i got it
04:54:59 <endojelly> blackdog, oh?
04:55:04 <ivanm> what's the term for a function like fromJust? partial function?
04:55:10 <IceDane> Where can I find an example of using Data.Map? The official specification is somewhat.. hard to understand for me
04:55:19 <Saizan_> ivanm: yup
04:55:37 <blackdog> you need some scratch space equal to the number of nodes
04:55:44 <blackdog> starts off all zero
04:56:14 <Kim^Walkman> IceDane: This might help a bit http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Maps
04:56:15 <blackdog> for each entry in the adjacency list for the first node, check if the corresponding node in your scratch space is 0
04:56:16 <endojelly> blackdog, I tried that. don't you need to zero it out every time you move on to the next vertices adjacency list?
04:56:30 <Botje> IceDane: import qualified Data.Map as M; you take an M.empty and use "M.insert k v map" to insert stuff
04:56:32 <blackdog> endojelly: yes, you do. but you don't need to spend V time doing that
04:56:44 <endojelly> blackdog, I don't?
04:56:48 <blackdog> you can go over the list of edges again, setting it back to 0
04:57:02 <blackdog> so you're just going over each edge twice
04:57:05 <endojelly> blackdog, wouldn't that be O(V + V*E)?
04:57:09 <blackdog> which is fine, asymptotically speaking
04:57:11 <blackdog> no
04:57:13 <IceDane> Botje: Thanks. To construct it, it's just "myMap = fromlist [ tuple, tuple, tuple] " ?
04:57:36 <endojelly> blackdog, hmm, I see
04:57:39 <Botje> for example.
04:57:40 <blackdog> think about it - E is the total number of edges.
04:58:09 <Baughn> ivanm: I don't see why. We don't use called-interactively-p.
04:58:09 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
04:58:16 <endojelly> blackdog, yeah, that's good... thank you!
04:58:20 <blackdog> it's a sneaky example, because you're used to taking worst cases
04:58:36 <Baughn> ivanm: (And interactive-p still works)
04:58:39 <blackdog> no worries
04:58:55 <blackdog> endojelly: it's too hot to do real work here anyway:)
04:59:01 <Baughn> ivanm: I'm not about to break compatibility with older emacses just because its developers want me to.
04:59:04 <Baughn> @clear
04:59:04 <lambdabot> Messages cleared.
04:59:07 <hotzen> whut?? why is there no fundep-error declaring multiple instances?
04:59:07 <hotzen> class Container contType elemType | contType -> elemType where
04:59:07 <hotzen> insert :: contType -> elemType -> contType
04:59:07 <hotzen> instance Container (a,b) a where insert (elemA,elemB) newElemA = (newElemA, elemB)
04:59:07 <hotzen> instance Container (a,b) b where insert (elemA,elemB) newElemB = (elemA, newElemB)
04:59:17 <ivanm> Baughn: well, I get a bug whenever I try to open a haskell file
04:59:28 <Baughn> ivanm: Define "bug"
04:59:30 <ivanm> other files work
04:59:51 <ivanm> Baughn: it throws up error messages, and some of my customisations for haskell mode don't work
05:00:02 <endojelly> blackdog, heheh
05:00:05 <ivanm> and it says something about interactive-p having wrong arguments, so I thought you used it
05:00:28 <Baughn> ivanm: We do use it, but the email you linked me to says nothing about interactive-p changing
05:00:29 <Saizan_> hotzen: the error might get triggered only by an use of insert that'll match those instances
05:00:34 <endojelly> blackdog, heh. a friend just gave me a list of solutions for the cormen exercices. this one is left out %)
05:00:34 * ivanm should have saved the warning messages, etc. from emacs before starting stable emacs instead :s
05:00:48 <endojelly> blackdog, but your solution seems sound
05:01:06 <hotzen> saizan_: i thought that would be the fundeps purpose?!?! to forbid those instances at compile-time??
05:01:34 <Saizan_> hotzen: it forbids you to use them at least, still at compile time
05:01:40 <ivanm> Baughn: hmmm.... lemme change emacs version and restart it to see if it still occurs
05:01:57 <hotzen> ah ok, that could be an interactive problem.... thanks!
05:02:20 <blackdog> endojelly: for bonus points, find an equivalently fast functional method :)
05:02:28 <endojelly> blackdog, :D
05:02:48 <Botje> unsafeSolveProblem ?
05:04:01 <ivanm> Baughn: bah, maybe I was mistaken
05:04:17 <ivanm> I just rebuilt emacs-cvs, daemon mode doesn't work, other things are fubared, etc.
05:04:25 <Baughn> Heh
05:04:56 <ivanm> Baughn: duh, I think I know what the "problem" was... I was using haskell-mode built with cvs emacs; when I had daemon, etc. problems I switched to stable, but it must have been using cvs elisp
05:09:12 <smiler> I'm trying to install lambdabot through cabal but I'm having difficulties: http://pastebin.com/m4836689b
05:10:33 <i_am_neuron> Hi Haskellers! When installing mkcabal, the build fails on pcre-light-0.3.1 (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5058#a5058). Any idea why?
05:10:57 <ivanm> smiler: lambdabot has never built sanely
05:10:59 <ivanm> ;-)
05:11:04 <ivanm> i_am_neuron: mkcabal is deprecated
05:11:09 <Saizan_> the one on hackage builds fine
05:11:19 <Saizan_> smiler: you need a newer ghc
05:11:23 <i_am_neuron> ivanm: oh! what replaces it?
05:11:27 <smiler> Saizan_: never than 6.8.2?
05:11:38 <shrughes> smiler: i got it running on 6.10 without much hassle  -- see http://www.haskell.org/haskellwiki/Lambdabot/Building
05:11:41 <ivanm> i_am_neuron: (the answer is probably due to linker scripts for pcre; if /usr/lib/libpcre.so is a text file, then this is the problem)
05:11:51 <shrughes> you won't have to apply the patch though
05:12:01 <ivanm> i_am_neuron: the current development version of cabal-install will have similar functionality thanks to byorgey_ (IIRC)
05:12:04 <shrughes> since it's already applied
05:12:09 <ivanm> but dons has told me he no longer cares about mkcabal
05:12:25 <ivanm> smiler: yes, you need 6.10.* for base-4
05:12:28 <i_am_neuron> ivanm: great, thanks, I'll look into cabal-install then
05:12:40 <ivanm> i_am_neuron: the stable release doesn't have it though
05:12:58 <shrughes> I have one problem with lambdabot: whenever I have it running connected to an IRC channel, it works for a while and eventually silently ping timeouts from the channel
05:13:00 <ivanm> i_am_neuron: the development release uses Cabal 1.8, which won't be released until 6.12 is released AFAIK
05:13:30 <ivanm> bah, there's no fromRight function :(
05:14:14 <i_am_neuron> ivanm: anyway, thanks for the info about deprecation
05:15:03 <ivanm> i_am_neuron: no worries
05:15:20 <ivanm> i_am_neuron: I think I managed to get it working by specifying that it needed to use base<3
05:15:39 <ivanm> if using cabal-install, this is done by cabal install mkcabal --constraint="base<4" I think
05:15:59 <i_am_neuron> ivanm: <3 or <4?
05:16:29 <smiler> It's actually haskell-src-exts that's depending on base >=4, not lambdabot
05:16:31 <Veinor> how common are functions that take more than 3 parameters?
05:16:41 <ivanm> i_am_neuron: <4
05:16:47 <ivanm> it works with base-3
05:16:54 <Botje> Veinor: three is about right..
05:16:59 <ivanm> Veinor: I have a few
05:17:06 <ivanm> Veinor: depends on what you're doing
05:17:21 <i_am_neuron> ivanm: cabal install mkcabal --constraint="base<4" failed with the same message
05:17:25 <Botje> Veinor: a quick look through hoogle shows mostly TH stuff
05:17:48 <i_am_neuron> ivanm: forget it, I guess I'll just create a project stub manually
05:17:55 <ivanm> i_am_neuron: yeah
05:18:21 <i_am_neuron> ivanm: :)
05:18:32 <FunctorSalad> is there some simple way to get arbtt to show your periods of activity?
05:18:38 <FunctorSalad> (in the last n days)
05:20:29 <ivanm> @hoogle evaluate
05:20:29 <lambdabot> Control.Exception evaluate :: a -> IO a
05:20:29 <lambdabot> Control.OldException evaluate :: a -> IO a
05:20:29 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
05:21:10 <IceDane> Why is it that readList returns a list of tuples of the requested type and String?
05:21:35 <Baughn> @type readList
05:21:36 <ivanm> IceDane: the list is for each possible choice
05:21:36 <lambdabot> forall a. (Read a) => String -> [([a], String)]
05:21:57 <ivanm> IceDane: since there might be more than one possible way of parsing the String
05:22:03 <Baughn> > readList "4242 44" :: [([Int],String)]
05:22:04 <lambdabot>   []
05:22:10 <ivanm> (note that the libraries shipped with GHC only ever return one)
05:22:12 <ivanm> Baughn: :o
05:22:18 <Veinor> ... :o
05:22:21 * Baughn blinks
05:22:24 <ivanm> IceDane: the String is for the rest of the String that isn't parsed
05:22:28 <shrughes> > readList "[4242,44]" :: [([Int],String)]
05:22:28 <IceDane> I see
05:22:29 <lambdabot>   [([4242,44],"")]
05:22:32 <IceDane> thanks
05:22:40 <ivanm> > readList "12a" :: [(Int, String)]
05:22:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:22:41 <lambdabot>         against inferred type ...
05:22:51 <Baughn> Oh, so that sort of list
05:23:08 <shrughes> readList doesn't read a list, it returns a list
05:23:09 <ivanm> duh, read_LIST_
05:23:17 <Twey> It does both :þ
05:23:22 <ivanm> shrughes: nope, it reads a list
05:23:39 <ivanm> its for String needing different (possible) syntax
05:23:41 <Baughn> ivanm: The type makes little sense if the input has to be valid, unambigious haskell list syntax..
05:23:41 <Twey> > reads "[12, 10]" :: [([Int], String)]
05:23:42 <lambdabot>   [([12,10],"")]
05:23:45 <shrughes> ivanm: oh that sort of list
05:23:48 <Veinor> > readList "[1,2]sdfsdf" :: [([Int], String)]
05:23:49 <lambdabot>   [([1,2],"sdfsdf")]
05:23:51 <Twey> What's the use of readList, then?
05:23:53 <ivanm> > readList "\"blah\"d" :: [([Char], String)]
05:23:54 <lambdabot>   [("blah","d")]
05:24:05 <Twey> > reads "[[12], [10]]" :: [([[Int]], String)]
05:24:06 <lambdabot>   [([[12],[10]],"")]
05:24:07 <shrughes> agh reads, I completely forget reads
05:24:08 <ivanm> Baughn: well, its for dodgy parsing as well
05:24:33 <ivanm> Baughn: rather than the whole Show/Read being valid code output/intput stuff
05:24:38 <ivanm> (AFAIK, anyway)
05:24:43 <ivanm> @type reads
05:24:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:24:52 <Twey> readList seems fairly redundant
05:24:53 <Axman6> > readList "[1,2] hello" :: [([Int],String)]
05:24:54 <lambdabot>   [([1,2]," hello")]
05:24:55 <ivanm> shrughes: it returns a list of possible parse + rest of string
05:25:00 <ivanm> Twey: it's needed for strings
05:25:08 <ivanm> Twey: see my example above
05:25:13 <IceDane> Would you use readList to parse a file of comma-separated integers into a list?
05:25:18 <ivanm> heya, southerner!
05:25:21 <Twey> > reads "[1, 2] hello" :: [([Int], String)]
05:25:22 <lambdabot>   [([1,2]," hello")]
05:25:23 <ivanm> IceDane: I wouldn't
05:25:31 <Twey> Ah
05:25:45 <Twey> > reads "\"blah\"d" :: [([Char], String)]
05:25:46 <lambdabot>   [("blah","d")]
05:25:49 <Twey> Nope
05:25:51 <Axman6> IceDane: there are libraries for that
05:25:53 <IceDane> how would you go about it, ivanm?
05:25:58 <ivanm> IceDane: either use a parsing library, or if you're definite what they are, use a splitting function on ',' and map read or something
05:26:03 <Veinor> I love the existence of Memo.unit
05:26:07 <Veinor> it's so useless
05:26:07 <ivanm> polyparse, parsec, etc.
05:26:11 <ivanm> Veinor: heh
05:26:16 <IceDane> Hmm.. I guess I can do that yeah
05:26:21 <Twey> ivanm: reads can do strings, too.
05:26:30 <smiler> I got a bit further, but now I get the following error: http://pastebin.com/m16ebfb2
05:26:37 <dixie_> is something like parsec in imperative languages (java,c...) ? I like parsec so much
05:26:38 <Veinor> Memo.bool is kinda silly too
05:26:44 <ivanm> Twey: it uses readList
05:26:48 <ivanm> @src Read
05:26:48 <lambdabot> class Read a where
05:26:49 <lambdabot>   readsPrec    :: Int -> ReadS a
05:26:49 <lambdabot>   readList     :: ReadS [a]
05:26:49 <lambdabot>   readPrec     :: ReadPrec a
05:26:49 <lambdabot>   readListPrec :: ReadPrec [a]
05:26:56 <Twey> > reads "[\"foo\", \"bar\"]d" :: [([[Char]], String)]
05:26:57 <lambdabot>   [(["foo","bar"],"d")]
05:27:03 <ivanm> @src [] Read
05:27:03 <lambdabot> Source not found. My pet ferret can type better than you!
05:27:05 <Twey> ivanm: Ah, I see
05:27:07 <ivanm> @src [] reads
05:27:08 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:27:11 <Twey> So it's not really meant to be used
05:27:16 <Twey> It's an implementation detail
05:27:19 <ivanm> Twey: right
05:27:33 <ivanm> Twey: its the hack to avoid using overlapping isntances
05:27:41 <Twey> Aye
05:27:48 <ivanm> which is handy, because I'm sure OverlappingINstances wasn't available when they wrote Haskell 1.0 ...
05:27:48 <ivanm> ;-)
05:27:57 <Twey> Hehe
05:35:37 <yitz> I usually use read[s].
05:35:50 <yitz> parsing libraries are really nice, i love them.
05:36:04 <aug_triad> ilovedsp
05:36:17 <yitz> but when i can get my job done in under 15 seconds and it works perfectly, it's pretty tempting.
05:38:32 <smiler> Is code.haskell.org down?
05:38:51 <aug_triad> Hmm... I am doing some set operations, and import the library list as import qualified List as L. Now I would like to do set difference with \\, and use L.(\\). I get the error Cremo/Harmony.hs:93:74: Not in scope: data constructor `L'; Cremo/Harmony.hs:93:76: Not in scope: `\\'
05:38:51 <ivanm> smiler: was before
05:39:20 <Axman6> aug_triad: L.\\
05:39:36 <Axman6> or (L.\\)
05:40:08 <aug_triad> Ah, than you, the last worked!
05:40:14 <aug_triad> *thank!
05:40:15 <zygoloid> aug_triad: or wait for haskell' :)
05:40:34 <smiler> Meh
05:41:14 <IceDane> Data.List.Map = Data.Map ?
05:41:18 <yitz> > let parse = unfoldr $ listToMaybe . concatMap reads . tails in parse "You can be 100% sure that reads can fulfill 90% of your parsing needs." :: [Int]
05:41:19 <lambdabot>   [100,90]
05:42:02 <skorpan> :t reads
05:42:03 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:45:21 <yitz> Shows is a pretty good pretty-printer, too.
05:46:50 <yitz> preflex: seen preflex
05:46:51 <preflex>  what
05:47:10 <yitz> preflex: seen yitz
05:47:11 <preflex>  yitz was last seen on #haskell 20 seconds ago, saying: preflex: seen preflex
05:47:19 <IceDane> lol
05:47:27 <Jafet> @seen lambdabot
05:47:27 <lambdabot> Unknown command, try @list
05:47:34 <IceDane> @list
05:47:34 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:47:35 <Jafet> Oh, right.
05:47:46 <yitz> preflex: seen lambdabot
05:47:47 <preflex>  lambdabot was last seen on #haskell 12 seconds ago, saying: http://code.haskell.org/lambdabot/COMMANDS
05:52:33 <aug_triad> I can see that the first argument to \\ is the set that the operator is doing set difference w.r.t. Are there an easy way of just finding the set difference between two sets?
05:53:24 <Jafet> Why is \\ hard?
05:53:43 <Jafet> .oO(Because it met your mom)
05:54:23 <Botje> a \\ b `union` b \\ a ?
05:55:03 <Botje> if you're using Data.Map or Data.Set there's also a difference
05:55:15 <aug_triad> Yes, that would work :). But it's a little ugly ?
05:55:33 <Botje> wrap it in a function ;)
05:56:39 <Jafet> You can also take the difference of the intersection from the union
06:01:33 <Twey> flip =<< ((//) .) . join . (update .) . (//), hmm
06:01:45 <Twey> It feels like that should be easy to pl
06:01:55 <Twey> (and nice)
06:02:53 <yitz> @unpl flip =<< ((//) .) . join . (update .) . (//)
06:02:53 <lambdabot> (\ h -> ((\ d v -> (//) (d v)) >>= \ a b c -> a c b) ((\ y -> update (h // y)) >>= \ l -> l))
06:03:38 <smiler> wow, linenoise
06:03:55 * Botje should take the time to figure out how (f .) . g works
06:03:56 <Jafet> @type flip =<< ((//) .) . join . (update .) . (//)
06:03:57 <lambdabot> Not in scope: `update'
06:04:43 <yitz> @type \update -> flip =<< ((//) .) . join . (update .) . (//)
06:04:44 <lambdabot>     Couldn't match expected type `[(i, e)]'
06:04:44 <lambdabot>            against inferred type `Array i1 e1'
06:04:44 <lambdabot>     In the second argument of `(.)', namely `(//)'
06:10:01 <IceDane> Will I have to be executing IO actions inside main? I'm trying to debug my program, and having the stuff inside main makes it harder to test pieces of code by themselves
06:10:19 <Axman6> use ghci
06:10:21 <koeien1> you can use ghci
06:10:33 <ivanm> IceDane: you can put them into other functions and use ghci on them
06:10:36 <Axman6> main should usually be very small
06:11:26 <IceDane> I am - i'm basically doing "fileContents = readFile "file"", but then in a another function I'm trying to use the result, but the result is an "IO String", instead of just String because i'm not doing it in an IO action, I reckon?
06:11:48 <koeien1> you mean, fileContents <- readFile "file"
06:12:04 <IceDane> Nope - fileContens is a function, not inside main
06:12:05 <mauke> what do you mean "in", readFile "file" _is_ an IO action
06:12:23 <IceDane> fileContents = readFile "cipher1.txt"
06:12:24 <IceDane> integerList = map (\x -> read x :: Int) $ splitString ',' fileContents
06:12:44 <mauke> well, you can't do that
06:12:54 <Axman6> IceDane: take a look at this if you're new to IO in haskell: http://random.axman6.com/blog/?page_id=70
06:12:55 <IceDane> Yes, so the compiler has told me
06:13:14 <ivanm> gah! I'm trying to make Arbitrary instances for FGL graphs, but ghci says it needs FlexibleInstances; but if I add that then some of my other instances of Arbitrary don't work! :@
06:13:15 <Axman6> what's the type of fileContents IceDane?
06:13:26 <mokus_> IceDane: you are correct that you need to do that IO within main or anohter IO function called by main
06:13:37 <IceDane> Oh.. I'll have to wrap it in a do as well?
06:13:46 <IceDane> I guess I automatically assumed 'do' was a 'main thing'
06:13:46 <IceDane> heh
06:13:50 <IceDane> don't ask me why
06:13:52 <Axman6> IceDane: read that link, then come back
06:13:54 <mokus_> yea, if you want to avoid the (>>=) line noise
06:14:24 <ivanm> Axman6: how's being exam-free feeling? :p
06:14:46 <Axman6> alright. the joy is counteracted by being MBP free also
06:15:04 <ivanm> MBP?
06:15:10 <Axman6> macbook pro
06:16:09 <mokus_> when you say in Haskell "fileContents = readFile "cipher1.txt"", it takes you quite literally - fileContents is defined to be the action on the LHS, so you could also start your main with "do foo <- fileContents"
06:16:56 <IceDane> yeah, I thought as much
06:17:11 <Axman6> IceDane: did you read that link?
06:17:33 <IceDane> I'm reading it
06:21:25 <IceDane> IO in haskell is really annoying. I understand that purity and all that stuff is very important, but it doesn't change that it is
06:21:38 <skorpan> what's annoying about it?
06:21:41 <mauke> meh, you couldn't do this in C either
06:22:09 <BONUS> it's just that you aren't used to it imo
06:22:12 <Axman6> IceDane: that statement tells me you don't understand IO in haskell yet
06:22:35 <Axman6> once you understand it, it's just as natural as writing IO code in any other language, just safer
06:22:35 <BONUS> once you really understand it you see how it's actually really great
06:22:57 <BONUS> because it frees you from thinking about a lot of stuff in your pure code
06:23:32 <ben0x539> IO in Haskell is terrible because getting a Ptr to a haskell object is way too much effort
06:23:43 <mauke> heh
06:23:59 <Axman6> ben0x539: i do hope that was a joke :)
06:24:31 <ben0x539> I suspect passing a Ptr (IORef ByteString) to a C callback thing is not necessarily best practice
06:25:58 <ben0x539> Axman6: I do not think that haskell's IO is terrible because of what I described, but I was a bit frustrated that it is not easier
06:26:28 <mauke> ben0x539: I think it's impossible
06:26:28 <ben0x539> I was trying to write my own curl write function that would build a bytestring
06:26:37 <mauke> because Haskell objects move around in memory
06:26:39 <ben0x539> mauke: It somehow works with a stableptr
06:26:47 <mauke> yeah, ok
06:27:03 <ben0x539> but I was not certain whether I was losing memory
06:27:18 <ben0x539> because apparently i need to free stable ptrs explicitly
06:27:28 <ben0x539> so I thought maybe I attach a foreign ptr
06:27:32 <IceDane> So, if I want to get the result from an IO action, I need to wrap in a "do" construct, use the "<-" operator to retrieve the result, and then do whatever I want with it? So this basically makes it impossible for me to define a couple of functions in ghci I might want to call on the result of the IO operation, without wrapping it in a function that uses do?
06:27:38 <ben0x539> but then I need a finalizer and then I need to free that explicitly too and
06:28:05 <mauke> IceDane: 'do' is not magic
06:28:08 <Axman6> IceDane: you can always use fmap
06:28:21 <Axman6> <- is magic though >_>
06:28:26 <mauke> no
06:28:51 <Axman6> where magic = syntax
06:29:08 <mauke> syntax is not magic (as any Perl programmer should know)
06:29:10 <IceDane> I understand that, but I don't understand why I can't just get the result of the IO operation directly, without wrapping it in a do, whether it be using normal assignment or the <- operator.
06:29:25 <mauke> (<- is not an operator)
06:29:27 <ben0x539> because <- is part of the 'do' syntactic sugar
06:29:35 <ben0x539> and because normal assignment assigns the action, it does not execute it
06:29:58 <mauke> IceDane: because Haskell generally doesn't execute IO actions
06:30:13 <mokus_> IceDane: you can, but then the function that does so will itself be an IO action
06:30:15 <dolio> What does "get the result ... directly" mean?
06:30:19 <Axman6> IceDane: you'd break purity if you didn't have to do that
06:30:36 <dolio> If you're in ghci, you can write "s <- m" on a line.
06:31:28 <IceDane> Why can't I do that outside a do construct in code, then?
06:31:39 <ben0x539> because ghci is not code
06:31:42 <dolio> Because ghci is a do construct.
06:31:43 <Axman6> because it wouldn't be pute
06:31:46 <Axman6> pure*
06:31:50 <ben0x539> it is a magical environment that simulates a do-block
06:32:08 <mauke> IceDane: what would it desugar to?
06:32:22 <IceDane> .. What?
06:32:31 <Axman6> do blocks are sugar
06:32:36 <Axman6> they need to be desugared
06:32:40 <mauke> 'do' is not magic in that it's simply translated to other functions and operators
06:33:14 <mauke> it's simply a convenience for the programmer, but you don't really need it to write Haskell
06:33:17 <Axman6> IceDane: would this function be pure? f x = do y <- askTheUserForANumber; x + y?
06:33:26 <mauke> purity is irrelevant
06:33:44 <Baughn> Axman6: Also, missing a return
06:33:59 <Axman6> that was on purpose :)
06:34:29 <mauke> IceDane: do { x <- foo; bar } is equivalent to (foo >>= \x -> bar)
06:34:30 <eivuokko> You could have a Num instance for it -.-'
06:35:19 <IceDane> mauke: I don't even know what >>= does yet. I guess I'll just have to march on until I get an epiphany about haskell IO being awesome
06:35:35 <koeien1> good!
06:35:52 <ski> (there is no "normal assignment" in haskell)
06:35:59 <Axman6> IO is awesome in haskell because there is a very clear separation between IO and pure code
06:36:27 <Heffalump> actually doing side-effecting operations is rather syntactically heavy, though
06:36:27 <mauke> IceDane: (>>=) takes an action and a callback. it attaches the callback to the action, returning a new action
06:36:34 <|Jedai|> eivuokko: instance (Num a) => Num (IO a) where (+) = liftM2 (+); (*) = liftM2 (*)
06:36:48 <Baughn> That, and because everything is first-class, and you can pass around parts of control structures or procedures just like anything else
06:36:50 <mauke> IceDane: if you run the new action, it first executes the old action and then invokes the callback on the result of that
06:36:50 * ben0x539 just realises his ugly bytestring hack is backwards
06:36:56 <IceDane> I see
06:37:07 <IceDane> Is that not similar to function composition?
06:37:10 <mauke> note that >>= doesn't actually run anything itself
06:37:13 <IceDane> sounds like f(g(x))
06:37:13 <mokus_> it seems to me the difficulty that a lot of people have learning about Haskell IO comes not really from the perception that "do" is magic, but from the fact that haskell IO is *not* magic in the way many other languages IO is
06:37:14 <koeien1> IceDane: somewhat, yes
06:37:28 <ski> @type ($)@type (=<<)
06:37:29 <lambdabot> parse error on input `type'
06:37:31 <ski> @type ($)
06:37:31 <ski> @type (=<<)
06:37:32 <lambdabot> forall a b. (a -> b) -> a -> b
06:37:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:37:39 <mokus_> specifically, in other languages, the "IO"ness is macically stripped away when you use an IO action
06:38:07 <mokus_> in haskell, it's not, so you actually have to start thinking about whether your functions use IO
06:38:21 <mokus_> and treat them differently when they do
06:38:21 <Axman6> hmm, good point
06:38:57 <mokus_> btw Axman6, I liked your intro you linked him to
06:39:06 <mokus_> I'll be showing that to a couple friends :)
06:39:21 <Axman6> cheers :)
06:39:47 <Axman6> got any suggestions? i'm always looking to improve it (it needs work, but i'm not sure what exactly)
06:40:10 <jav_> hi there! is there something like Data.Map.mapM ?
06:40:34 <mokus_> not really, I think it's a good insight into the way people tend to think when they take the haskell plunge
06:40:37 <BrianB04> Morning all.
06:40:50 <Axman6> jav_: mapM f . fromList?
06:40:54 <Axman6> uh, toList
06:41:33 <jav_> Axman6: yes, but I want a Map in the and again... I mean I can do toList, fromList of course.. but is that the right way to go?
06:41:48 <BrianB04> Is there any sites out there that let you look at the Haskell source to various functions (Namely reverse)
06:42:02 <Axman6> Baughn: why yes...
06:42:04 <Axman6> @src reverse
06:42:04 <lambdabot> reverse = foldl (flip (:)) []
06:42:12 <Axman6> bah, where'd the other one go
06:42:20 <mokus_> the 'echo' example is particularly good, because I know it took me a while to get past wondering how it could possibly work and remember that at one time i'd have expected it to work
06:42:43 <BrianB04> @src (++)
06:42:44 <lambdabot> []     ++ ys = ys
06:42:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
06:42:44 <lambdabot> -- OR
06:42:44 <lambdabot> xs ++ ys = foldr (:) ys xs
06:43:07 <BrianB04> That's kinda nifty.
06:43:15 <EvilTerran> reverse = go [] where go out (this:in) = go (this:out) in; go out [] = out
06:43:26 <Axman6> Baughn: there's also the Prelude source online of course
06:43:48 <Baughn> Axman6: Wha?
06:43:56 <EvilTerran> > (let go [] where go out (this:in) = go (this:out) in; go out [] = out in go []) "Abracadabra!"
06:43:57 <lambdabot>   <no location info>: parse error on input `where'
06:44:04 <EvilTerran> > (let go out (this:in) = go (this:out) in; go out [] = out in go []) "Abracadabra!"
06:44:05 <lambdabot>   <no location info>: parse error on input `in'
06:44:19 <EvilTerran> oh, wait, you can't call a variable "in", can you? <.<  >.>
06:44:38 <EvilTerran> > (let go ys (this:xs) = go (this:ys) xs; go out [] = out in go []) "Abracadabra!"
06:44:38 <lambdabot>   "!arbadacarbA"
06:44:47 <Axman6> BrianB04: sec
06:44:54 <Baughn> EvilTerran: Sure you can, but the /name/ of the variable must not be "in".
06:45:06 <Baughn> EvilTerran: You can call the name "in" too, though, if you like
06:45:08 <jystic> if I want to format some Doubles in to a String and have control over the number of decimal places, is printf my best bet? or is there something safer?
06:45:16 <Axman6> BrianB04: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html and there are links to the source of everything defined there (well, mostly)
06:45:23 <Baughn> jystic: printf isn't exactly unsafe. It should be fine.
06:45:30 <Jafet> Haskell has variables?
06:45:36 <Baughn> Jafet: IORef
06:45:38 <jystic> Baughn:  great :) just checking
06:45:43 <Baughn> Jafet: And TVar, and..
06:45:52 <EvilTerran> jystic, thre's something in Numeric, iirc
06:45:54 <Axman6> AVars >_>
06:46:09 <Axman6> which, i realised i totally fucked up the hackage distribution :'(
06:46:09 <EvilTerran> ?hoogle show Float
06:46:09 <lambdabot> Numeric showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
06:46:09 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
06:46:09 <lambdabot> Numeric showFloat :: RealFloat a => a -> ShowS
06:46:11 * Jafet unsafe-writes over Baughn
06:46:13 <EvilTerran> jystic, ^
06:46:24 <EvilTerran> (also showGFloat, iirc)
06:46:34 <jystic> EvilTerran: cool, i'll take a look at those too
06:46:50 <jystic> do haskellers generally use printf for string formatting?
06:46:59 <Axman6> depends
06:47:42 <Heffalump> jystic: ++ is more common I think
06:47:49 <EvilTerran> > [f (Just 10) 123.45 "" | f <- [showEFloat, showFFloat, showGFloat]]
06:47:50 <lambdabot>   ["1.2345000000e2","123.4500000000","123.4500000000"]
06:48:08 <EvilTerran> > [f Nothing (12345*10^10) "" | f <- [showEFloat, showFFloat, showGFloat]]
06:48:09 <lambdabot>   ["1.2345e14","123450000000000.0","1.2345e14"]
06:48:30 <mokus_> jystic: for myself it depends on my mood: is it easier at the moment to type a bunch of ++'s or to go to the top of the file and type "import Text.Printf"? ;)
06:48:41 <jystic> lol
06:49:36 <EvilTerran> jystic, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v%3AshowEFloat
06:50:05 <jystic> in my situation i need to calculate the number of decimal places arbitrarily so i'm build a format string using ++ first, it doesn't look very nice! I think I might have a look at the Numeric classes for this
06:50:06 <Cyneox> hi there! whats wrong about this: http://pastebin.com/m3abe21cf ? thank you
06:50:28 <jystic> s/build/building/
06:50:29 <Axman6> Cyneox: that's a terribly rude way to ask for help ;)
06:50:54 <Cyneox> Axman6: ok..but you still need more details.. so i thought i should paste sth
06:51:06 <Cyneox> its about importing modules..
06:51:10 <Axman6> Cyneox: you need to export Menge(..), not just Menge
06:51:11 <eugenn> how to cunt the digits of a number without using explicit recursion?
06:51:26 <EvilTerran> Cyneox, when you export the type "Menge" in "module Mengen (Menge, ...", you're exporting it abstractly
06:51:31 <Axman6> eugenn: what an unfortunate typo :P
06:51:33 <Cyneox> Axman6: what should i write?
06:51:39 <eugenn> hehe
06:51:39 <EvilTerran> Cyneox, you're only exporting the type, not its constructors
06:51:44 <eugenn> count i mean
06:51:47 <Axman6> you should write Menge(..) instead of Menge
06:51:53 <jystic> Axman6: lol, yes I think perhaps eugenn was even ruder :P
06:51:58 <EvilTerran> Cyneox, if you make that "module Mengen (Menge(..), ...", that will export all the constructors as well
06:51:58 <Cyneox> Axman6: i'll give it a try
06:52:01 <Baughn> jystic: Main problem with printf is, of course, that it effectively relies on dynamic typing and so isn't nearly total. Ideally this wouldn"t be the case..
06:52:05 <Baughn> > printf "%d" "foo"
06:52:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:52:06 <lambdabot>    `GHC.Show.Show a'
06:52:06 <lambdabot>      a...
06:52:09 <Baughn> > printf "%d" "foo" :: String
06:52:10 <lambdabot>   "* Exception: Printf.printf: bad argument
06:52:22 <Cyneox> EvilTerran, Axman6: thank you guys
06:52:57 <Axman6> Cyneox: module Blah (Foo,..) where, exports the type, but not the constructors. you need to add (..) to export the constructors
06:53:03 <eugenn> > (length . show) 3521
06:53:04 <lambdabot>   4
06:53:13 <eugenn> woa, did it!
06:53:21 <byorgey> eugenn: you can use 'show' to... indeed =)
06:53:24 <Cyneox> Axman6: what if i write "newtype Menge a = ..." insteaf of data ?
06:53:25 <Axman6> eugenn: length . show . abs might be a bit more accurate
06:53:40 <eugenn> right axman
06:53:42 <eugenn> lets try
06:53:46 <EvilTerran> Cyneox, also, if you only want to export some of a type's constructors, you could write "module Mengen (Menge(Menge), ...". this wouldn't be necessary here, as there's only one constructor, but it could be useful in future
06:53:52 <Axman6> Cyneox: then i think Menge should just work., but i've never tried
06:53:53 <eugenn> (length . show . abs) 24679
06:54:01 <eugenn> > (length . show . abs) 24679
06:54:02 <lambdabot>   5
06:54:06 <EvilTerran> Cyneox, newtype works the same way as data for exporting
06:54:14 <Cyneox> EvilTerran: ok..
06:54:20 <Axman6> > (length . show . abs) (-123)
06:54:21 <lambdabot>   3
06:54:35 <Cyneox> thank you for your support! have a nice day!
06:55:34 <eugenn> thanks, so efficient
06:56:06 <eugenn> > pred 4
06:56:06 <lambdabot>   3
06:58:47 <eugenn> is there a better way? nthDigitr c = (flip mod 10) . flip div (10 ^ pred c)
06:59:19 <eugenn> @pl nthDigitr c = (flip mod 10) . flip div (10 ^ pred c)
06:59:19 <lambdabot> nthDigitr = (flip mod 10 .) . flip div . (10 ^) . pred
06:59:19 <Daimonic> http://codepad.org/GijGCW9k Compiler says, couldn't match expected type FreeMemoryBlocks against inferred type [a] in the [] = [] pattenr, but I don't know what to write instead
07:00:18 <eugenn> > succ 4
07:00:19 <lambdabot>   5
07:00:20 <Lemmih> Daimonic: purge (FreeMemoryBlocks []) = FreeMemoryBlocks []
07:00:27 <Axman6> Daimonic: you need purge (FreeMemoryBlocks []) = ..
07:00:40 <Lemmih> Daimonic: Why don't you make FreeMemoryBlocks a type synonym?
07:00:56 <Daimonic> ah jesus christ, I forgot it again
07:01:06 <Axman6> heh
07:01:15 <Daimonic> thanks man :)
07:01:20 <Daimonic> you mean type FreeMemoryBlocks = mb ?
07:01:30 <Axman6> i'd use type FreeMemoryBlocks = [(Int,Int)] personally
07:01:43 <eugenn> :t toInteger
07:01:43 <lambdabot> forall a. (Integral a) => a -> Integer
07:01:50 <Daimonic> you mean instead of an own data type?
07:02:05 <eugenn> is there a way to convert the char '5' to integer?
07:02:11 <Axman6> yes
07:02:12 <Botje> Daimonic: purge (FreeMemoryBlocks []) = FreeMemoryBlocks []
07:02:16 <Axman6> though, i don
07:02:21 <Daimonic> Ou
07:02:30 <Axman6> don't think you can implement instances of classes for types...
07:02:36 <Lemmih> eugenn: digitToInt
07:02:41 <Botje> Daimonic: and likewise for the other case
07:02:50 <Lemmih> > digitToInt '5'
07:02:50 <eugenn> > digitToInt '5'
07:02:51 <lambdabot>   5
07:02:51 <lambdabot>   5
07:02:57 <eugenn> great!
07:02:57 <Daimonic> Our prof gave as a a class Memory with 2 functions - and we had to implement that
07:03:09 <Daimonic> as a kind of interface
07:04:13 <hugov> @src zipWith
07:04:13 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:04:14 <lambdabot> zipWith _ _      _      = []
07:04:15 <Daimonic> and to instanciate this, I have to use data types - it is laborious, but this is more about the concept than the technic
07:04:54 <Axman6> well, get to it then!
07:04:58 <eugenn> > zipWith (+) [1..20] [1..25]
07:04:59 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40]
07:05:25 <Daimonic> :)
07:05:25 <Lemmih> Daimonic: How about you write 'purge' on lists and then pack it in FreeMemoryBlocks afterwards?
07:05:39 <dixie_> zipWith (+) [-1..-20] [1..20]
07:05:40 <Daimonic> yeah I was thinking about this, too
07:05:47 <dixie_> > zipWith (+) [-1..-20] [1..20]
07:05:48 <lambdabot>   Not in scope: `..-'
07:05:57 <Lemmih> Daimonic: pack fn (FreeMemoryBlocks list) = FreeMemoryBlocks (fn list)
07:06:06 <Daimonic> but I was also wondering about, if this is avoiding the concept
07:06:14 <eugenn> > zipWith (+) [(-1)..(-20)] [1..20]
07:06:15 <lambdabot>   []
07:06:21 <eugenn> there :)
07:06:22 <Daimonic> yeah this is the typical box, unbox idea :D love it
07:07:30 <sticazzi> Hello! I'm learning Haskell and porting an old program I did in Java some time ago to Haskell. What can I use for agent-like message-passing concurrency (a la Erlang)?
07:07:52 <Axman6> well.. you could use the erlang library ;)
07:07:56 <Lemmih> sticazzi: Threads and channels?
07:08:02 <Axman6> which lets you use haskell as an erlang node
07:08:07 <sticazzi> ok
07:08:13 <sticazzi> I'd seen Channels
07:08:14 <Axman6> but threads and Chans would be more more practical
07:08:15 <eugenn> [0,0,0]
07:08:19 <eugenn> > [0,0,0]
07:08:20 <lambdabot>   [0,0,0]
07:09:08 <sticazzi> Not that I have high-concurrency requirements (It's just that the problem is easier to express in an Agent programming style)
07:09:24 <sticazzi> ..but is forkIO a pooled thread or a native thread?
07:09:33 <Berengal> pooled'
07:09:50 <Axman6> well, Chans use MVars, which are very fast, and can be used basically exactly the same as the mailboxes in erlang
07:10:04 <Axman6> sticazzi: forkOS is for OS threads
07:10:07 <Lemmih> sticazzi: They're even cheaper than pooled threads.
07:10:10 <Berengal> Axman6: lacks the pattern matching...
07:10:21 <eugenn> > [1,3..]
07:10:22 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:10:26 <Axman6> Berengal: it doesn't have to
07:10:33 <Twey> sticazzi: Generally Chans.
07:10:42 <Berengal> Axman6: well, no, but it doesn't come with it out of the box
07:10:45 <sticazzi> Lemmih, confused.. how can native threads be cheaper than pooled?
07:10:48 <Axman6> there's an unGetChan function (or something along those lines)
07:10:54 <sticazzi> It takes some time to allocate a stack, right?
07:11:04 <Berengal> I think I wrote a function that added it in about 5 lines once though
07:11:07 <Axman6> sticazzi: no
07:11:09 <eugenn> take 8 (scanl1 (+) [1,3..])
07:11:14 <eugenn> > take 8 (scanl1 (+) [1,3..])
07:11:16 <lambdabot>   [1,4,9,16,25,36,49,64]
07:11:19 <Lemmih> sticazzi: GHC uses green threads which are cheaper than pooled threads.
07:11:22 <Axman6> haskell threads are extremely light weight (think erlang lightweight)
07:11:29 <eugenn> behold, perfect squares in polynomial time :)
07:11:30 <sticazzi> oh, cool :-)
07:11:35 <Twey> Haskell threads are much more lightweight than Erlang threads.
07:11:36 <Berengal> useage was basically 'receive $ \m -> case m of [...]'
07:12:01 <Axman6> Twey: yeah, couldn't remember which was lighter :)
07:13:53 <Twey> http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all&box=1
07:14:01 <eugenn> how do I get the nth digit from left as an integer given a number?
07:14:23 <mauke> (!! n) . show
07:14:23 <Twey> About a quarter of the time and a third of the memory
07:14:45 <eugenn> > ((!! n) . show) 456
07:14:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:14:46 <Twey> > (!! 3) . show $ 12345
07:14:46 <lambdabot>         against inferred type ...
07:14:47 <lambdabot>   '4'
07:15:06 <c_wraith> Huh.  That C++ program is still listed as valid.  strange.
07:15:16 <Twey> c_wraith: Which one?
07:15:27 <c_wraith> http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=gcc&id=3
07:15:44 <c_wraith> the comments in that program explicitly say they use a custom scheduler
07:15:56 <c_wraith> which the rules for the test explicitly say doesn't qualify
07:16:01 <Twey> c_wraith: Ah
07:16:19 <eugenn> but thats a char.. and I don't have digitToInt in winhugs :(
07:16:30 <novns> hi
07:16:35 <Twey> eugenn: So ord and subtract '0'
07:16:36 <novns> what happened to http://code.haskell.org/ ?
07:16:41 <Lemmih> eugenn: You do. It's in Data.Char.
07:16:49 <novns> it doesnot respond now
07:16:52 <Lemmih> Twey: That's evil.
07:17:05 <Twey> > let d2i c = ord c - ord '0' in d2i '4'
07:17:06 <lambdabot>   4
07:17:14 <koeien1> why is this evil?
07:17:22 <Twey> Because the encoding isn't guaranteed to have numbers in order
07:17:29 <mauke> C guarantees it
07:17:32 <Lemmih> > let d2i c = ord c - ord '0' in d2i 'o'
07:17:33 <lambdabot>   63
07:17:35 <Twey> This isn't C :þ
07:17:35 <mauke> that's good enough for me
07:17:45 <Twey> Yeah, boundary checks are good too, of course
07:17:46 <mauke> Twey: yes, we actually have stronger guarantees
07:17:48 <mauke> like UNICODE
07:17:55 <Twey> Point
07:18:00 <Twey> How smart is digitToInt?
07:18:06 <mauke> not very
07:18:08 <eugenn> let ... in ... is the same as where?
07:18:09 <Twey> > digitToInt '０'
07:18:09 <lambdabot>   * Exception: Char.digitToInt: not a digit '\65296'
07:18:15 <Twey> Not very, indeed
07:18:25 <koeien1> eugenn: not completely
07:18:26 <Twey> eugenn: In this case, mostly.
07:18:34 <koeien1> @google haskell let vs. where
07:18:35 <lambdabot> No Result Found.
07:18:35 <Lemmih> eugenn: They're both ways of introducing new bindings.
07:18:44 <koeien1> grmbl
07:18:50 <koeien1> http://www.haskell.org/haskellwiki/Let_vs._Where
07:19:09 <c_wraith> yikes.  I wasn't aware of any difference.  off to read the link!
07:19:31 <Lemmih> eugenn: But 'let-in' is an expression while 'where' is part of a function declaration.
07:20:04 <c_wraith> Oh, I see.  I guess I knew that, but wasn't really consciously aware of the difference
07:22:42 <Axman6> lets can be used to reference variables on the left of <- in do blocks, whereas where can't
07:23:06 <eugenn> can you explain briefly and with a simple example what a monad is?
07:23:45 <mauke> @quote endofu
07:23:45 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
07:24:09 <Twey> eugenn: A monad is like a dinosaur in a radioactive space-suit that needs to get rid of its waste.  Just 3 >>= return . (* 2) ==> Just 6; Nothing >>= return . (* 2) ==> Nothing
07:24:13 <mauke> eugenn: a Monad is a type constructor that implements the functions 'return' and '>>='
07:24:26 <c_wraith> eugenn:  I'm not sure it's worth worrying about when you're just learning haskell.  Just use "do" for IO, and don't worry about other uses until you're trying to understand some code you've found
07:24:41 <mauke> monads have nothing to do with IO
07:24:50 <Axman6> except the IO monad
07:24:55 <mauke> that's an accident
07:25:05 <koeien1> you don't need to implement IO using monads
07:25:06 * Twey . o O (… monad metaphor Chinese Whispers …)
07:25:07 <mauke> you could use IO without its monadicity
07:25:19 <eugenn> Yes you're right, I would need too much time to deeply learn that
07:25:33 <mauke> there's no point in learning it
07:25:44 <eugenn> :t do
07:25:45 <lambdabot> Empty 'do' construct
07:25:53 <Axman6> eugenn: i've been using haskell for almost 2 years now, and i still can't accurately describe what monads are
07:25:56 <koeien1> eugenn: "do" is syntactic sugar for >>= and return
07:26:04 <mauke> s/and return//
07:26:14 <koeien1> > do { x <- Just 5; return (x + 1) }
07:26:15 <lambdabot>   Just 6
07:26:15 <c_wraith> koeien:  it's >>= and >>, not >>= and return
07:26:22 <koeien1> c_wraith: yep. and fail.
07:26:41 <mauke> 'fail' has a very appropriate name :-(
07:26:49 <c_wraith> Anyway.  Monads are cool when you get the hang of using them.  But don't worry too much about them initially.
07:26:52 <koeien1> > Just 5 >>= (\x -> return (x+1) )
07:26:53 <lambdabot>   Just 6
07:27:02 <mauke> "monads" are overrated
07:27:04 <eugenn> > do {return 3}
07:27:05 <lambdabot>   No instance for (GHC.Show.Show (m t))
07:27:05 <lambdabot>    arising from a use of `M1694221585...
07:27:16 <mauke> just use IO, Maybe, [], and possibly Reader and State
07:27:18 <koeien1> eugenn: you need to specify which monad you want
07:27:19 <centrinia> > do { return 3 } :: Maybe Int
07:27:20 <lambdabot>   Just 3
07:27:24 <koeien1> > do { return 3 } :: Maybe Integer
07:27:25 <lambdabot>   Just 3
07:27:27 <Axman6> screw Reader and State
07:27:32 <koeien1> > do { return 3 } :: [Integer]
07:27:33 <lambdabot>   [3]
07:27:35 <mauke> aw
07:27:36 <tensorpudding> what about Parsec?
07:27:49 <Axman6> i need to learn how to use parsec
07:27:51 <koeien1> > do { return 3 } :: IO Integer
07:27:52 <lambdabot>   <IO Integer>
07:27:57 <mauke> tensorpudding: Parsec has complicateder internals
07:28:00 <c_wraith> tensorpudding:  I've decided I like uu-parsinglib more.  and it's used in mostly applicative style
07:28:05 <Twey> And applicative interfaces
07:28:15 <Jafet> Axman6, class Monad m where { return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b; }
07:28:25 <Axman6> Jafet: ?
07:28:33 <koeien1> Jafet: you forgot fail and >>
07:28:34 <tensorpudding> i've never heard of uu-parsinglib, parsec is a lot more well known
07:28:36 <c_wraith> The applicative parser interface is sufficient for context-free grammars.  Which means it's usually good enough
07:28:51 <tensorpudding> i'm sure that applicatives do the job well too..
07:28:56 <Jafet> Pfft. Details.
07:29:09 <Rayne> how should the following function be written that it will work? shift (string) = last (string) ++ init (string)
07:29:10 <tensorpudding> but applicatives don't have the notoriety that monads do
07:29:10 <Axman6> @src Monad
07:29:10 <lambdabot> class  Monad m  where
07:29:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
07:29:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
07:29:10 <lambdabot>     return      :: a -> m a
07:29:10 <lambdabot>     fail        :: String -> m a
07:29:11 <koeien1> c_wraith: so uu-parsinglib > parsec for you? maybe i'll check it out sometime :)
07:29:24 <koeien1> Rayne: look at the types!
07:29:28 <Axman6> Rayne: s/++/:
07:29:34 <Rayne> ah!
07:29:50 <eugenn> > (((((+). ) (-). ) (*). ) (/). ) 4
07:29:51 <lambdabot>   No instance for (GHC.Show.Show
07:29:51 <lambdabot>                     (f ((((a -> a) -> a -> a...
07:30:01 <Rayne> thanks a lot koeien and Axman6
07:30:03 <c_wraith> koeien:  It doesn't have nearly as many built-in pieces as parsec, so you have to do more yourself.  But I really like the built-in backtracking
07:30:12 <eugenn> > (((((+). ) (-). ) (*). ) (/). ) 4 6
07:30:13 <lambdabot>   Ambiguous type variable `t' in the constraint:
07:30:13 <lambdabot>    `GHC.Num.Num t' arising f...
07:30:20 <tensorpudding> i'd be more likely to check out parsec because more people use it
07:30:32 <koeien1> tensorpudding: i've been using that int he past
07:30:36 <c_wraith> koeien:  the erorr-correcting is also an awesome feature once you understand how it works
07:30:41 <tensorpudding> and because you get to see it in RWH for a little bit
07:30:46 <koeien1> c_wraith: "error correction" ?
07:30:50 <koeien1> maybe i need to RTFM
07:31:11 <tensorpudding> uu-parsinglib has a much less catchy name
07:31:21 <Jafet> I like take (length string) $ tail (cycle string)
07:31:23 <c_wraith> koeien:  It will make a best guess at what the parse result should be, and will spit out a list of "corrections" it made to the input to get that result
07:31:25 <mauke> eugenn: you have 5 inputs in that monstrosity
07:31:28 <koeien1> yeah, i like the name "parsec"
07:31:37 <mauke> eugenn: calling it with only 2 numbers can't work
07:31:38 <Polarina> Why is Learn You A Haskell licensed under a non-commercial license?
07:31:46 <eugenn> > (((((+). ) (-). ) (*). ) (/). ) 4 6 7 8 9
07:31:47 <lambdabot>   Ambiguous type variable `t' in the constraint:
07:31:47 <lambdabot>    `GHC.Num.Num t' arising f...
07:32:02 <koeien1> c_wraith: i see. useful for feedback to a human user
07:32:09 <c_wraith> koeien: exactly
07:32:25 <eugenn> (((((+). ) (-). ) (*). ) (/) ) 4 6
07:32:30 <eugenn> > (((((+). ) (-). ) (*). ) (/). ) 4 6 7 8 9
07:32:31 <lambdabot>   Ambiguous type variable `t' in the constraint:
07:32:31 <lambdabot>    `GHC.Num.Num t' arising f...
07:32:44 <eugenn> > (((((+). ) (-). ) (*). ) (/) ) 4 6
07:32:45 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:32:45 <lambdabot>    arising from a use of `GHC.Num.*'...
07:32:45 <koeien1> > (((((+). ) (-). ) (*). ) (/). ) 4 6 7 8 9 :: Float
07:32:46 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
07:32:46 <lambdabot>         against inferred typ...
07:32:56 <koeien1> ;)
07:33:08 <koeien1> eugenn: maybe try to write down what you mean, and then @pl it?
07:33:19 <koeien1> @pl (\x y -> (x+y)/y)
07:33:20 <lambdabot> join . ((/) .) . (+)
07:33:24 <eugenn> yes, i'll try
07:34:35 <eugenn> @pl crazy n1 n2 = ((((n1+n2)*n2)-n2)/n2)
07:34:36 <lambdabot> crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+)
07:35:32 <c_wraith> this is why point-free style isn't always better :)
07:35:40 * Twey explode
07:36:00 * Polarina chain reacts from Twey's explosion.
07:36:00 <|Jedai|> c_wraith: this one is clearly pointless style...
07:36:13 <Twey> @unpl crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+)
07:36:13 <lambdabot> crazy f = (\ ad -> (/) (((\ ag -> (-) (((\ aj -> (*) (f + aj)) >>= \ w -> w) ag)) >>= \ o -> o) ad)) >>= \ g -> g
07:36:21 <Twey> Well
07:36:24 <Twey> That's certainly better
07:36:54 <eugenn> @unpl find = (head .) . filter
07:36:54 <lambdabot> find d g = head (filter d g)
07:37:01 <centrinia> @pl crazy f = (\ ad -> (/) (((\ ag -> (-) (((\ aj -> (*) (f + aj)) >>= \ w -> w) ag)) >>= \ o -> o) ad)) >>= \ g -> g
07:37:02 <eugenn> whoa great
07:37:02 <lambdabot> crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+)
07:37:12 <|Jedai|> @pl (\ ad -> (/) (((\ ag -> (-) (((\ aj -> (*) (f + aj)) >>= \ w -> w) ag)) >>= \ o -> o) ad)) >>= \ g -> g
07:37:13 <lambdabot> id =<< (/) . ((-) =<< (*) =<< (f +))
07:37:48 <tensorpudding> why is there an unpl command
07:38:03 <skorpan> to make stuff understandable
07:38:06 <|Jedai|> tensorpudding: why not ?
07:38:08 <tensorpudding> you could just add the points in by hand
07:38:15 <Twey> tensorpudding: To get back the energy wasted by using @pl.
07:38:19 <|Jedai|> skorpan: Not really...
07:38:31 <zygoloid> @@ @redo @unpl crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+)
07:38:31 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
07:38:47 <tensorpudding> though i guess you could use it to get rid of the tons of flip, . and uncurry you introduced with @pl
07:38:48 <c_wraith> @. unpl pl \x -> x * x
07:38:48 <lambdabot> ((*) >>= \ a -> a)
07:39:03 <eugenn> @quote lambda
07:39:03 <lambdabot> vincenz says: [talking about lambdabot] cause it really is a grand development tool
07:39:07 <|Jedai|> tensorpudding: you could also remove the points by hand, unpl try to do some idiomatic simplification I guess (and seems to fail in complex cases)
07:39:10 <zygoloid> @@ @do @unpl crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+)
07:39:10 <lambdabot>  crazy f = do { g <- (\ ad -> (/) ((do { o <- (\ ag -> (-) ((do { w <- (\ aj -> (*) (f + aj)); w}) ag)); o}) ad)); g}
07:39:31 <tensorpudding> you can't always easily remove the points though
07:39:48 <zygoloid> > let crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+) in crazy x y
07:39:49 <lambdabot>   ((x + y) * y - y) / y
07:39:52 <tensorpudding> @pl \x -> x^2 + x + sin x
07:39:53 <zygoloid> win!
07:39:53 <lambdabot> liftM2 (+) ((+) =<< (^ 2)) sin
07:40:04 <tensorpudding> wow
07:40:08 <|Jedai|> @do  id =<< (/) . ((-) =<< (*) =<< (f +))
07:40:08 <lambdabot> id =<< (/) . ((-) =<< (*) =<< (f +))
07:40:09 <tensorpudding> that's pretty opaque
07:40:32 <Veinor> it looks like ascii art
07:40:36 <Polarina> Why is Learn You A Haskell licensed under a non-commercial license?
07:40:39 <zygoloid> @check let crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+) in  \a b -> crazy a b == a + b - 1
07:40:40 <lambdabot>   "Falsifiable, after 2 tests:\n-0.75\n1.3333333333333333\n"
07:40:49 <tensorpudding> Veinor: sometimes haskell does look a lot like ascii art
07:40:49 <|Jedai|> do doesn't know about =<< ! that's pretty bad :(
07:40:51 <eugenn> @pl (.) (.)
07:40:51 <lambdabot> ((.) .)
07:40:57 <Veinor> Polarina: the guy didn't want it to be sold?
07:41:05 <zygoloid> @check let crazy = join . ((/) .) . join . ((-) .) . join . ((*) .) . (+) in  \a b -> crazy a b == a + b - (1 :: CReal)
07:41:05 <Berengal> Polarina: ask BONUS
07:41:06 <lambdabot>   Not in scope: type constructor or class `CReal'
07:41:10 <tensorpudding> isn't LYAH written by BONUS...
07:41:14 <Polarina> Berengal: Ok.
07:41:17 <tensorpudding> s/he hangs out here
07:41:24 <|Jedai|> tensorpudding: Especially when the pointfree fans get free reign
07:41:31 <|Jedai|> s/reign/rein
07:41:37 <tensorpudding> |Jedai|: sometimes pointfree is a lot nicer
07:41:50 <Axman6> death to pointfree!
07:41:58 <eugenn> only with a lot of effort can I see why (head .) . filter works...
07:42:25 <|Jedai|> tensorpudding: I love pointfree myself but this channel sees a lot more of its more grotesque excess than real Haskell code ^^
07:42:27 <Twey> eugenn: ‘fmap head . filter’ is easier to read, for me at least
07:42:40 <Axman6> eugenn: it's something that once you know what it does, you'll understand it from then on (((f .) . g) that is)
07:42:42 <Polarina> BONUS, BONUS_: Why is your book Learn You A Haskell For Great Good licensed under a commercial license? I understand that you wouldn't like it sold, but it restricts its usage much greater than that, for example teachers that teach Haskell in non-governmental run schools can't use it.
07:42:45 <mauke> well, ((head .) . filter) X == head . (filter X) by the definition of (.)
07:43:08 <|Jedai|> Twey: I much prefer "find p = head . filter p" myself
07:43:22 <eugenn> me too jedai
07:43:27 <Veinor> Polarina: does it really restrict it like that? I mean I'm fairly sure teachers can still say 'go to lyah.com and click the X link'
07:43:29 <Twey> I prefer ‘fmap head . filter p’ here
07:43:33 <Twey> Er
07:43:36 <Twey> ‘fmap head . filter’
07:43:43 <tensorpudding> rule of thumb: if you have at least two uncurry's in a @pl output, don't use it
07:43:45 <Twey> It's just too simple a case to be worth pointifying
07:43:52 <|Jedai|> eugenn: And I prefer it to "find p xs = head (filter p xs)" too :)
07:43:56 <Twey> tensorpudding: Or more than two flips :þ
07:44:02 <Polarina> Veinor: Perhaps, but they can't like project it on a projector and read it for the poor little students.
07:44:06 <koeien1> Polarina: "non-commercial" would include academic usage, (IANAL)
07:44:15 <tensorpudding> i have falled in love with (&&&)
07:44:18 <tensorpudding> fallen*
07:44:20 <Twey> Hear hear
07:44:25 <eugenn> well only one point can I understand
07:44:36 <eugenn> with two it messes me up :P
07:44:46 <Veinor> yeah, IANAL but I'm fairly sure that academic usage is non-commercial; that specific use case would also be fair use
07:44:51 <Twey> eugenn: You'll get over that :þ
07:44:52 <eugenn> :t &&&
07:44:53 <lambdabot> parse error on input `&&&'
07:44:55 <tensorpudding> i don't understand arrows so much beyond that though
07:44:58 <Veinor> :t (&&&)
07:44:59 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:45:01 <tensorpudding> :t (&&&)
07:45:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:45:10 <|Jedai|> Twey: I refuse to use "fmap f" for "(f .)", if I find it useful in my code I just define a (.:) combinator
07:45:16 <Twey> Veinor: That's only the case with official government-sponsored schools, I think
07:45:17 <Berengal> If you're mixing the function instances for Monoid, Monad, Applicative and Arrow in the same expression, it's probably worth it to name a few points
07:45:19 <eugenn> Arrow? whoa, this has no limits
07:45:22 <tensorpudding> the type signature of (&&&) is hard to read because it uses arrows
07:45:34 <tensorpudding> but (->) is an arrow
07:45:45 <eugenn> :t (->)
07:45:46 <lambdabot> parse error on input `->'
07:45:49 <Veinor> > ((+1) &&& (+2)) 4
07:45:50 <lambdabot>   (5,6)
07:45:51 <idnar> here's an easier-to-read version:
07:45:57 <Twey> Veinor: Private schools are considered businesses
07:45:57 <tensorpudding> (->) a b == a -> b
07:46:09 <Axman6> @instances Arrow
07:46:10 <lambdabot> (->), Kleisli m
07:46:15 <idnar> (Arrow a) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
07:46:15 <Veinor> Twey: ah. I would still say it falls under fair use
07:46:22 <mauke> idnar: fail
07:46:25 <idnar> er
07:46:26 <tensorpudding> it's really insane to think of the functions as having a constructor
07:46:28 <idnar> whoops
07:46:31 <tensorpudding> at first anyway
07:46:32 <idnar> (Arrow (~>)) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
07:46:33 <|Jedai|> @type let (f .: g) x y = f (g x y) in head .: filter
07:46:34 <lambdabot> forall a. (a -> Bool) -> [a] -> a
07:46:37 <Veinor> because it wouldn't affect the 'market' to transiently display a website
07:46:47 <Axman6> so, (&&&) :: (->) b c -> (->) b c') -> (->) b (c,c')
07:46:54 <Axman6> ->
07:47:01 <idnar> mauke: well, to be fair, both version are easier to read, the first one was just wrong ;P
07:47:09 <Veinor> (&&&) :: (b -> c) -> (b -> c') -> (b -> (c, c'))
07:47:23 <Berengal> tensorpudding: not if you take the graph-reduction route to thinking about evaluation
07:47:24 <|Jedai|> tensorpudding: I really like it though, and it makes perfect sense and allows you to define pretty useful typeclass instance over them
07:47:45 <tensorpudding> Berengal: i haven't thought much about that one
07:48:37 <tensorpudding> |Jedai|: yeah, it's really neat
07:48:40 <Berengal> I'm pretty certain it's possible to create a drag-n-drop front-end for the haskell language
07:48:58 <tensorpudding> but it's one more thing that is going to hang up noobies until they have an ahah! moment and fall in love with them forever
07:49:00 <Berengal> Make labels, connect edges
07:49:27 <rickz__> could someone explain how "sequence" works?
07:49:33 <Berengal> @src sequence
07:49:33 <lambdabot> sequence []     = return []
07:49:34 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:49:34 <lambdabot> --OR
07:49:34 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:49:34 <tensorpudding> that occurred for me too many times learning haskell
07:50:01 <Polarina> @src liftM2
07:50:01 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:50:31 <tensorpudding> @type sequence
07:50:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:50:34 <rickz__> hm
07:50:44 <tensorpudding> the type says a lot
07:50:54 <rickz__> for me it doesn't :/
07:51:01 <tensorpudding> sequence takes a list of monadically wrapped values, and returns a monadically wrapped list of values
07:51:02 <Berengal> rickz__: it just performs each action in turn, and gathers the results up in a list
07:51:02 <rickz__> could you explain when to use sequence and why?
07:51:21 <mauke> when you need to turn a list of actions into a single action returning a list
07:51:29 <opqdonut> sequencing monadic parsers means running them one after another
07:51:35 <Polarina> rickz__: When you wish to do [IO a] -> IO [a]
07:51:37 <c_wraith> > sequence [Just 1, Just 4, Nothing]
07:51:38 <lambdabot>   Nothing
07:51:46 <c_wraith> > sequence [Just 1, Just 4, Just 29837]
07:51:47 <lambdabot>   Just [1,4,29837]
07:51:49 <opqdonut> sequencing a bunch of putstrings might be useful too
07:52:01 <Berengal> rickz__: mapM uses sequence
07:52:01 <tensorpudding> > sequence [putStrLn "foo", putStrLn "bar"]
07:52:03 <lambdabot>   <IO [()]>
07:52:04 <Berengal> @src mapM
07:52:04 <lambdabot> mapM f as = sequence (map f as)
07:52:07 <opqdonut> yeah, sequence in the Maybe monad is quite handy also
07:52:16 <tensorpudding> there is also sequence_
07:52:21 <tensorpudding> @type sequence_
07:52:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
07:52:27 <Polarina> @src sequence_
07:52:27 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:52:47 <tensorpudding> this one performs all the actions in order, and ignores the output
07:53:02 <|Jedai|> rickz__: you can also use it in the list monad to do a cartesian product
07:53:02 <Polarina> Why would someone wish to do that?
07:53:15 <|Jedai|> > sequence [[1..5], [1,2]]
07:53:16 <lambdabot>   [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2]]
07:53:16 <tensorpudding> > sequence_ [putStrLn "foo", putStrLn "bar"]
07:53:17 <lambdabot>   <IO ()>
07:53:22 <rickz__> ah okey thanks gonna test some stuff out with it. thanks
07:53:25 <Polarina> tensorpudding: Ah.
07:53:59 <tensorpudding> some IO actions are not interesting for their return values, but for their side effects
07:54:27 <tensorpudding> so a lot of monad actions have foo_ equivalents, like mapM_ and sequence_
07:54:32 <|Jedai|> tensorpudding: some State action too, or Writer or ST
07:54:33 <tensorpudding> @type mapM_
07:54:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:57:07 <Veinor> I can't decide whether to bring my code up to hackage standards or whether to make parts of it actually work.
07:57:22 <Polarina> Veinor: Both. .)
07:57:24 <Polarina> :)
07:57:44 <Veinor> :P
07:57:47 <poe> ksf do you have the url to the document of swiestra about parsers?
07:58:37 <dixie_> What is good visualation tool for Map.Tree if it doesn't have string labels ?
07:58:37 <Veinor> yeah, but to make those parts actually work I'll have to think about how to implement an algorithm
07:58:40 <Veinor> thinking is hard :(
07:59:14 <tensorpudding> let's go shopping
07:59:49 <poe> dixie_ what about vacuum?
08:00:08 <kynky> graphviz ?
08:00:18 <poe> dixie_ http://moonpatio.com/vacuum/#gallery
08:00:55 <tensorpudding> i wanted to try vacuum but i'm afraid that it might suck
08:01:44 <c_wraith> that pun hurts
08:02:03 <tensorpudding> yeah
08:02:43 <i_am_neuron> Folks, I'm fighting with Cabal and can't get the simplest thing: how to build more than one file with it. I hooked the file with the main function via Main-Is, and have no idea about how to add other source files. Could anyone help me?
08:03:17 <dankna> do you have a .cabal file?
08:03:31 <i_am_neuron> Adding Other-Modules (with the modules defined in other sources) didn't help: cabal just can't find the source
08:03:32 <dixie_> poe: I'm not sure if that is what i need. But I think it would be worth to make from Data.Tree some Graph type and there seems to be graphviz tooling.
08:03:35 <dankna> I guess you do, since that's where you set Main-Is
08:03:50 <i_am_neuron> dankna: sure, want to have a look? It's really simple though
08:03:59 <dankna> sure, you can hpaste it
08:04:07 <i_am_neuron> dankna: Nothing apart from Main-Is
08:04:16 <dankna> are the modules in appropriate locations?  if you have a module called, say, Network.FruitTart, it needs to be in a directory called Network in a file called FruitTart.hs.
08:04:37 <dankna> Network in my example needs to be a direct subdirectory of the directory you're in when you run Cabal
08:05:20 <i_am_neuron> dankna: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5059#a5059
08:05:38 <Baughn> Apocalisp: ..what did you do to your baby?
08:05:46 <dankna> okay, so do you have a directory Pskov?
08:05:55 <dankna> (What does pskov stand for?  is that Russian?)
08:06:09 <Rayne> i wonder how i could support "shift  ['f']" which would return ['f']. my current function is `shift (string) = last (string) : init (string)`
08:06:32 <i_am_neuron> dankna: Oh, I thought modules do not depend on the dirs (I swear I read some explicit mention of this somewhere on Haskell Wiki)
08:06:40 <Baughn> Rayne: Don't do that. It'd be O(n) in the length of the string.
08:06:48 <i_am_neuron> dankna: Yeah, Pskov is the city in Northwest Russia :)
08:06:53 <dankna> this is technically true if you're calling ghc directly and set the proper options, I think
08:07:01 <dankna> which is probably the context you heard it in
08:07:08 <dankna> but Cabal wants everything to be in its place
08:07:18 <dankna> since Cabal makes life simpler in general, you should do things its way
08:07:21 <dankna> I see :)
08:07:23 <Baughn> Rayne: You'd be better off using a list replacement such as Sequence, and wrap it with what you want
08:07:34 <i_am_neuron> dankna: Great, this explains a lot. I'll reorganize this and try again. Thanks for your help!
08:07:38 <dankna> sure thing!
08:08:15 <Baughn> Rayne: ..though even with lists, you could just use cycle if the resulting lack of an end isn't a problem
08:08:16 <Rayne> Baughn, where can i read about that? i am new to haskell and it is still quite confusing
08:08:34 <Baughn> Rayne: It's in the standard library, Data.Sequence
08:08:53 <Baughn> Rayne: Watch out, a lot of the functions you'd expect are provided via instances of various type-classes
08:09:00 <Rayne> Baughn, i am "not allowed" to use libraries
08:09:15 <Rayne> only prelude
08:09:26 <Baughn> Rayne: In that case, see if you can make do with using cycle
08:09:41 <Rayne> i will look for it, thanks for that hint Baughn
08:10:17 <Baughn> Rayne: You can have something like "shiftablify list = (length list, cycle list)", and then shift (len,list) = (len, drop 1 list)
08:11:10 <Baughn> s/drop 1/tail/
08:15:02 <Rayne> Baughn, that looks confusing. i will try to get that function to work and if i fail i will ask you guys for help :)
08:15:08 <i_am_neuron> dankna: worked, thanks!
08:15:43 <i_am_neuron> another question: I want to "republish" function from my own module to avoid importing two modules with the very similar functionality, and doing this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5060#a5060. ghc complains about duplicated 'trace' when compiling Debug.hs, is there a way to fix that?
08:15:59 <dankna> Neuron: welcome
08:16:20 <dankna> import Debug.Trace hiding (trace)
08:16:24 <koeien1> i_am_neuron: you can just export trace without the last two lines.
08:16:34 <dankna> import qualified Debug.Trace
08:16:36 <koeien1> dankna: that would be valid, although the definition of trace would be _|_
08:16:42 <dankna> er, true
08:16:47 <dankna> trace = Debug.trace
08:16:48 <dankna> yeah
08:16:55 <dankna> I gave this three-line answer before actually reading the code
08:17:01 <dankna> do what koeien said instead
08:17:15 <dankna> I didn't realize that your trace doesn't actually add any semantics
08:18:45 <eugenn> I want a list with all prime numbers
08:18:52 <i_am_neuron> Worked, thanks again guys :)
08:18:56 <Rayne> my rewrite Baughn http://pastie.org/710016 :)
08:18:57 <koeien1> eugenn: hackage has the package 'primes'
08:21:03 <eugenn> @pl until n = [1..n]
08:21:03 <lambdabot> until = enumFromTo 1
08:21:22 <eugenn> @pl until n = [1,3..n]
08:21:22 <lambdabot> until = enumFromThenTo 1 3
08:21:43 <Baughn> Rayne: Oh, you definitely don't want that
08:22:00 <Rayne> that is sad :/
08:22:07 <eugenn> @pl until n = [n..1]
08:22:07 <lambdabot> until = flip enumFromTo 1
08:22:29 <eugenn> > [4..1]
08:22:30 <lambdabot>   []
08:22:39 <Baughn> Rayne: My instincts may be getting the better of me, though. The entire 'shift' function is insane, on lists..
08:23:06 <Baughn> Rayne: Using what you have there is no worse than the improvement I had in mind would be
08:23:45 <Baughn> Rayne: There are stylistic improvements to make, though. Let's see..
08:23:46 <Rayne> Baughn, it is my homework so i have to write such a function (and some weird others)
08:24:07 <eugenn> @pl until n m = [1,n..m]
08:24:07 <lambdabot> until = enumFromThenTo 1
08:24:43 <eugenn> @pl until m n = [1,n..m]
08:24:44 <lambdabot> until = flip (enumFromThenTo 1)
08:24:55 <Baughn> Rayne: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12936#a12936 <-- This does the exact same as yours, but I hope you'll agree that it looks nicer
08:25:01 <|Jedai|> eugenn: list range are just syntaxic sugar for the Enum methods
08:25:01 <Rayne> what is about http://pastie.org/710022 Baughn ? a friend of mine wrote it
08:25:29 <eugenn> I see, I didn´t know about the enumFromThenTo. it's handy
08:25:32 <Baughn> Rayne: Far worse. Yours is better. :P
08:25:34 <Rayne> yeah, that looks sweet Baughn
08:25:59 <Baughn> Rayne: The (length k) would likely be factored out by the optimizer, but a ++ b is O(length a)..
08:26:12 <Baughn> Rayne: Although both yours and his are O(n), yours would be noticably faster
08:26:24 <|Jedai|> Baughn: why do you need
08:26:28 <|Jedai|> shift [x] = [x]
08:26:31 <Baughn> Rayne: Oh, and do remember - you don't need parantheses
08:26:45 <Baughn> Jedai: You don't
08:27:24 <|Jedai|> So, I prefer your version, minus this line
08:27:31 <Baughn> Rayne: That's another point. I added the second clause because your version had it, but it's redundant; the last would work.
08:27:58 <lpsmith> Baugh's version is objectively better because it only does two passes over the list,  not one.  :-)
08:28:15 <lpsmith> err  Baughn*
08:28:21 * Baughn snorts
08:28:32 <|Jedai|> there's also : "shift xs = take (length xs) . tail . cycle $ xs
08:28:37 <lpsmith> err,  not three
08:28:42 <Baughn> Yeah, ideally you'd use a function that copies the list while checking for the last element
08:29:11 <Rayne> why did you call the variable xs Baughn ?
08:29:31 <ski_> tradition
08:29:32 <Baughn> Rayne: It's more than one x. We have no idea what x is, but there's more than one of it.
08:29:36 <lpsmith> you could get it down to one pass using a tuple as a result,  my intuition is that would be a good optimization on GHC-6.10 but not 6.8
08:29:49 <Baughn> Rayne: That's how you usually name something about which the /only/ thing you know is that it's a list of something
08:29:57 <|Jedai|> It can be done in one traversal if you use an auxiliary function
08:30:23 <Rayne> just an idea: would it be wrong to call it for instance xx?
08:30:53 <Baughn> Yes, that would break tradition
08:31:03 <|Jedai|> Rayne: not wrong per se, just not traditional (and xx denotes a big size in plenty of country, not a plural)
08:31:15 <eugenn> > (\list -> last list : init list) [2,3,4,5]
08:31:16 <lambdabot>   [5,2,3,4]
08:31:23 <Rayne> as expected, thanks for those great hints :)
08:31:39 <eugenn> is that it?
08:32:10 <Twey> > liftM2 (:) last init $ [2, 3, 4, 5]
08:32:11 <lambdabot>   [5,2,3,4]
08:32:21 <Baughn> Rayne: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12936#a12937 <-- Also, have a look at splitLast here
08:32:28 <Baughn> Twey: That's no better than my first one. -_-
08:32:33 <Twey> :-D
08:32:46 <ben0x539> Does lambdabot do IO?
08:32:49 <Twey> No
08:32:53 <Baughn> > putStrLn "foo" -- Sort of
08:32:54 <Twey> > print 5
08:32:54 <lambdabot>   <IO ()>
08:32:54 <lambdabot>   <IO ()>
08:32:58 <ben0x539> :<
08:33:02 <ben0x539> > unsafePerformIO $ print 5
08:33:03 <lambdabot>   Not in scope: `unsafePerformIO'
08:33:04 <junmin> help, receiving an unknown size [[a]]  (every sublist has the same size), and need to generate pairs/lists formed by one elemente of every sublist. list comprenhension can do it?
08:33:04 <Twey> She can return an IO
08:33:08 <Twey> But she doesn't *do* IO :þ
08:33:29 <ben0x539> I was trying to figure out whether bracket (and consequently catch) would be able to deal with IO's fail
08:33:30 <|Jedai|> junmin: list monad rather
08:33:38 <Baughn> junmin: Sounds like transpose
08:33:44 <Baughn> > transpose [[1,2],[3,4]]
08:33:45 <lambdabot>   [[1,3],[2,4]]
08:34:12 <|Jedai|> junmin: if you're speaking about the cartesian product of every lists
08:34:31 <Twey> > transpose [[1, 2, 3], [4, 5, 6, 7], [8, 9, 10]]
08:34:32 <lambdabot>   [[1,4,8],[2,5,9],[3,6,10],[7]]
08:34:36 <junmin> Baughn: in that example, i need [1,4], [2,3] too
08:34:40 <|Jedai|> > sequence [[1,2],[3,4]]
08:34:41 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
08:34:44 <Twey> Sounds like sequence
08:34:45 <Rayne> hehe, that confuses me. i have to read more about haskell
08:34:57 <Twey> |Jedai|: ☺
08:34:57 <junmin> @src sequence
08:34:57 <lambdabot> sequence []     = return []
08:34:58 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:34:58 <lambdabot> --OR
08:34:58 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:35:07 <ski> > let shift = uncurry (:) . loop where loop [x0] = (x0,[]); loop (x:xs) = fmap (x:) (loop xs) in shift [2,3,4,5]  -- fwiw
08:35:08 <lambdabot>   [5,2,3,4]
08:35:19 <|Jedai|> junmin: so cartesian product, see my example with sequence :) It's the list monad at work
08:35:22 <eugenn> in what library is sequence and traspose?
08:35:30 <ski> @index sequence
08:35:30 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:35:31 <Twey> Control.Monad and Data.List
08:35:40 <Twey> Respectivel
08:35:41 <Twey> y
08:35:48 <|Jedai|> eugenn: transpose in Data.List, sequence in Control.Monad
08:36:13 <eugenn> how can I make winhugs to always import all the libraries? because I have them in program files
08:36:18 <|Jedai|> apparently sequence is also in the Prelude
08:36:30 <junmin> thanks guys
08:36:35 <Rayne> this is not possible:
08:36:36 <Baughn> Rayne: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12936#a12940 <-- Well, if you use this I'm not sure they'd believe you wrote it. :P
08:36:56 <Rayne> shiftN :: Int -> [Char] -> [Char]
08:36:56 <Rayne> shiftN 0 xs = xs
08:37:05 <Twey> Something I miss sometimes is first [] = return (); first (x:xs) = x >>= flip when (first xs) . not
08:37:16 <Twey> Hm, is there a fold for that?
08:37:34 <Rayne> hehe, no Baughn
08:37:54 <Rayne> is this an anynomous function?
08:37:58 <ski> Baughn : s/(,)/(:)/ ?
08:38:00 <Rayne> after = let
08:38:06 <eugenn> > loop 4
08:38:07 <Baughn> ski: I noticed.
08:38:07 <lambdabot>   No instance for (GHC.Show.Show (a b c))
08:38:07 <lambdabot>    arising from a use of `M69654175...
08:38:26 <eugenn> > loop [1,2]
08:38:27 <lambdabot>   Couldn't match expected type `a (b, d) (c, d)'
08:38:27 <lambdabot>         against inferred typ...
08:38:32 <ben0x539> Are there any 'best practices' when ordering import statements?
08:38:43 <donri> Twey, what is "when"?
08:38:57 <Twey> donri: when cond action = if cond then action else return ()
08:39:06 <donri> ah
08:39:11 <Twey> @src when
08:39:12 <lambdabot> when p s = if p then s else return ()
08:39:15 <Twey> Heh
08:39:18 <Baughn> ski: I wonder if my code actually works
08:39:19 <Twey> Practically to the letter
08:39:29 <donri> :)
08:39:32 <junmin> in ghci/ghc can do something like @src here with lambdabot?
08:39:38 <koeien1> no :(
08:40:00 <ski> Baughn : it looks almost the same as mine, so i suppose so :)
08:40:07 <koeien1> lambdabot's sources are not real but chosen for educational purposes
08:40:21 <Twey> junmin: You can with GOA
08:40:22 <eugenn> @faq can Haskell manage quantum functions?
08:40:23 <lambdabot> The answer is: Yes! Haskell can do that.
08:40:30 <ben0x539> Does lambdabot have a fallback to show the real sources?
08:40:31 <koeien1> of course! :)
08:40:34 <Baughn> ski: Well, the last one doesn't. :P
08:40:44 <pastah_rhymez> @src map
08:40:45 <lambdabot> map _ []     = []
08:40:45 <lambdabot> map f (x:xs) = f x : map f xs
08:40:45 <koeien1> eugenn: quantum computations can be seen as an arrow, i guess
08:40:50 <junmin> hehe, which would be the fastest way get into the src?
08:40:58 * junmin googling GOA
08:41:02 <koeien1> junmin: hoogle.
08:41:04 <ben0x539> junmin: hayoo
08:41:08 <Baughn> junmin: hackage
08:41:15 * Twey laughs.
08:41:19 <Twey> Haddock!
08:41:20 * koeien1 wonders why they all start with an 'h'
08:41:27 <eugenn> map can also be defined with a comprehension list
08:41:28 * Baughn is working on "hermes"
08:41:28 <ben0x539> hoogle only works for stuff that ships with ghc, right?
08:41:42 <pastah_rhymez> junmin: i tried to install goa once, but it didn't work, so i usually just query lambdabot
08:41:42 <Baughn> ben0x539: By default.
08:42:03 <path__> hmm can someone explain to me how to use seq? When I do f(g) and I want g evaluated before its passed to f
08:42:14 <koeien1> g `seq` f g
08:42:23 <ben0x539> You could use f $! g, too
08:42:25 <junmin> Offers an interface to be able to call Lambdabot commands within GHCi; this is broken with recent Lambdabots.  pastah_rhymez you are right
08:42:35 <koeien1> > let f = const 37; x = undefined in x `seq` f x
08:42:36 <lambdabot>   * Exception: Prelude.undefined
08:42:37 <path__> ah
08:42:43 <ski> Baughn : `second' instead of `fmap' doesn't make that big a difference (but `second' is probably better, if `splitLast' is to be used outside of `shift')
08:42:44 <Rayne> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12943#a12943 <- any hints?
08:42:51 <path__> how does g `seq` f g work. Wouldnt it evaluate g twice
08:43:16 <koeien1> path_: it may, or it may not. in practice not
08:43:29 <path__> ah
08:43:39 <koeien1> path_: the only thing that 'seq' says that seq a b is _|_ if a is _|_. otherwise it returns b
08:43:43 <hugov> what happened to http://projects.haskell.org/haskellmode-vim? is the server broken?
08:43:55 <koeien1> > seq 138123 1
08:43:56 <lambdabot>   1
08:44:02 <koeien1> > seq (undefined,undefined) 1
08:44:03 <lambdabot>   1
08:44:12 <eugenn> > seq 34
08:44:13 <lambdabot>   {()->()}
08:44:14 <koeien1> because (_|_,_|_) is not _|_
08:44:26 <eugenn> > seq 34 2
08:44:28 <lambdabot>   2
08:44:38 <tensorpudding> two bottoms are different than one!
08:44:52 <path__> I dont understand. if I do b `seq` a b. It evauates b, but then to evaluate a(b) does it cache b
08:44:58 <Twey> map = flip foldr [] . (((. (:)) .)
08:45:09 <ben0x539> path__: yes.
08:45:12 <koeien1> path__: yes, in practice. but this is not a guarantee by the haskell standard
08:45:20 <koeien1> [iirc]
08:45:22 <path__> ah
08:45:30 <path__> so $! is better?
08:45:35 <ben0x539> no, it is the same thing
08:45:39 <koeien1> path__: no, $! is defined in terms of seq
08:45:39 <path__> oh
08:45:41 <path__> hmmm
08:45:41 <koeien1> @src ($!)
08:45:42 <lambdabot> f $! x = x `seq` f x
08:45:42 <ben0x539> @src $!
08:45:42 <lambdabot> f $! x = x `seq` f x
08:45:46 <path__> lol
08:45:46 <path__> ok
08:45:48 <eugenn> what does fmap do?
08:45:51 <path__> but I can trust it I hope
08:45:53 <Heffalump> every implementation does it that way, and it'd be a very odd implementation that didn't
08:45:56 <koeien1> path__: sure, we all do :)
08:45:57 <Heffalump> path__: yes.
08:46:04 <Twey> eugenn: Applies an operation to the value inside a functor
08:46:11 <ben0x539> path__: in 'practice', as far as I am aware, before seq, 'b' is not actually an object but a function that knows how to get the object. Evaluating 'b' basically runs that function and replaces it with the result.
08:46:14 <Twey> > fmap (* 2) $ Just 3
08:46:15 <lambdabot>   Just 6
08:46:17 <koeien1> eugenn: for functors f, apply a function to a value "inside" the functor
08:46:25 <Twey> > fmap (* 2) $ Nothing
08:46:25 <koeien1> > fmap (^2) [1..10]
08:46:26 <lambdabot>   Nothing
08:46:27 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
08:46:34 <ben0x539> path__: At least that is my intuition.
08:46:36 <theclaw> @src seq
08:46:36 <lambdabot> Source not found. My mind is going. I can feel it.
08:46:44 <rwx> hugov, i'm trying to set up vim for haskell currently, but i am trying to use Yi actually now (since it's written in haskell), although that didn't install without errors using cabal
08:46:45 <Twey> koeien1: You went to all the trouble of defining ‘f’ and then never reüsed it :þ
08:46:50 <ben0x539> function in the C/assembly sense, anyway... nevermind
08:47:06 <path__> hmm
08:47:15 <theclaw> what does 'seq' stand for, btw?
08:47:21 <koeien1> "sequential" i guess
08:47:27 <Twey> ‘Sequence’, no?
08:47:27 <eugenn> > [1,2] == [1,2]
08:47:28 <lambdabot>   True
08:47:40 <eugenn> > (fmap (^2) [1..10]) == (map (^2) [1..10])
08:47:41 <lambdabot>   True
08:47:41 <Twey> ben0x539: Close, but no cigar, since seq only reduces to WHNF
08:47:43 <Polarina> @src seq
08:47:43 <lambdabot> Source not found. stty: unknown mode: doofus
08:47:44 <eugenn> odd
08:47:52 <ben0x539> Twey: I figured that WHNF is an object
08:47:53 <koeien1> Polarina: seq is special. it requires compiler support
08:48:00 * Vq thought the *nf names were better
08:48:04 <Twey> ben0x539: Which means that in most cases you won't get a complete ‘object’
08:48:06 <ben0x539> sure, it might contain more unevaluated sub-objects, but you can pattern match on it :)
08:48:26 <Twey> Aye
08:48:34 <ben0x539> They have r0, rwhnf and rnf in control.parallel.something
08:48:49 <ski>   seq !_ x = x
08:49:03 <koeien1> ski: yeah, bangpatterns are defined in terms of seq
08:49:07 <Vq> Control.Parallel.Strategies
08:49:11 <koeien1> or the other way around of course :)
08:49:20 <ski> of course :)
08:49:23 <Twey> Hehe
08:49:32 * Twey prefers having the magic syntax be magical.
08:49:35 <eugenn> > (uncurry (curry (+)) 4 6) == 4+6
08:49:36 <lambdabot>   No instance for (GHC.Num.Num (a, b))
08:49:36 <lambdabot>    arising from a use of `GHC.Num.+' a...
08:49:45 <Twey> (although !_ threw me for a moment)
08:49:52 <koeien1> eugenn: you mixed up uncurry and curry
08:49:57 <eugenn> > (curry (uncurry (+)) 4 6) == 4+6
08:49:58 <lambdabot>   True
08:49:59 <koeien1> > curry (uncurry (+)) 4 6
08:50:00 <lambdabot>   10
08:50:11 <ben0x539> I was all "but you cannot have a !_ operator, no _ in operator names" :v
08:50:17 <Vq> Twey: it looks plenty magical :)
08:50:19 <Twey> Yeah :þ
08:50:36 <ben0x539> Maybe it should be called seq#
08:50:36 <Twey> curry converts from uncurried form (a -> b -> c) to curried form ((a, b) -> c), and uncurry vice versa
08:50:39 <ben0x539> then it is magic syntax
08:50:44 <ski> > curry (uncurry const) undefined ()
08:50:45 <lambdabot>   * Exception: Prelude.undefined
08:50:55 <path__> hmm koeien1 the other day you were suggesting I run my program with a profiler to find out where memory is being used up. Could you elaborate on that
08:51:16 <idnar> @type curry
08:51:17 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
08:51:22 <idnar> Twey: other way around?
08:51:30 <koeien1> path__: the GHC documentation has information about how to use the profiler. Also, there is a chapter in RWH about it
08:51:30 <Twey> Yes >.<
08:51:32 <Twey> Hahaha
08:51:46 <koeien1> path__: you can see where your memory and time are going
08:51:49 <Twey> uncurry converts from curried form (a -> b -> c) to uncurried form ((a, b) -> c), and curry vice versa
08:51:53 <path__> hmm
08:52:15 <koeien1> i think the example in RWH is quite illustrative
08:52:24 <eugenn> > reverse "sadbmal evol I"
08:52:25 <lambdabot>   "I love lambdas"
08:52:40 <koeien1> or is it "illuminating" and i just uttered a nice expression in Dunglish? ;)
08:52:45 <path__> cool thanks
08:52:53 <i_am_neuron> Folks, how to specify Main module in Cabal? I'm getting this output: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5061#a5061 for this Cabal file: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5059 Any idea why?
08:52:55 <Twey> > let add = uncurry (+) in add(3, 5); -- It's just like Java!
08:52:56 <lambdabot>   <no location info>: parse error on input `;'
08:53:03 <Twey> Aw, no trailing semicolons
08:53:06 <Twey> > let add = uncurry (+) in add(3, 5) -- It's just like Java!
08:53:07 <lambdabot>   8
08:53:14 <ben0x539> @src concatMap
08:53:14 <lambdabot> concatMap f = foldr ((++) . f) []
08:53:44 <eugenn> oooh the uncurried form lets you pass the parameters as a tuple. I get it know! thanks!
08:54:51 <ben0x539> Waiting for uncurryN before I am impressed
08:54:57 <IceDane-giefnick> Any takers? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12944#a12944 :P
08:55:00 <koeien1> each Haskell function takes only 1 parameter
08:55:24 <mmorrow> @type (unzip . uncurry zip)
08:55:25 <lambdabot> forall a b. ([a], [b]) -> ([a], [b])
08:55:38 <mmorrow> > (unzip . uncurry zip) ([0..4],[5..])
08:55:40 <lambdabot>   ([0,1,2,3,4],[5,6,7,8,9])
08:55:53 <mmorrow> > (uncurry (++) . unzip . uncurry zip) ([0..4],[5..])
08:55:54 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
08:56:16 <koeien1> IceDane: i think you should leave out the "map" there, or change : into ++
08:56:17 <mmorrow> > (uncurry (++) . uncurry (flip (,)) . unzip . uncurry zip) ([0..4],[5..])
08:56:18 <lambdabot>   [5,6,7,8,9,0,1,2,3,4]
08:56:25 <IceDane> koeien1: I need to map it
08:56:34 <IceDane> or wait
08:56:35 <IceDane> lol
08:56:58 <koeien1> IceDane: yeah, your applyToGroups *is* basiclaly a map, so it is better to write it that way
08:57:22 <eugenn> > (uncurry foldl) ((+),0,[1..7])
08:57:22 <IceDane> I guess it is, yeah
08:57:23 <lambdabot>   Couldn't match expected type `(b -> b1 -> b, b)'
08:57:23 <lambdabot>         against inferred t...
08:57:54 <eugenn> > (uncurry foldl1) ((+),[1..7])
08:57:55 <lambdabot>   28
08:58:00 <eugenn> okay!+
08:58:23 <jmcarthur> wow, steve yeggie wrote this long article on the expression problem without even identifying it
08:58:33 <koeien1> jmcarthur: i didn't like the article
08:58:37 <jmcarthur> me either
08:58:44 <i_am_neuron> Once again: does anybody know how to specify Main module in Cabal? I'm getting this output: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5061#a5061 for this Cabal file: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5059 Any idea why?
08:58:44 <eugenn> > (uncurry uncurry foldl) ((+),0.[1..20])
08:58:45 <lambdabot>   Couldn't match expected type `(a -> b -> c, (a, b))'
08:58:45 <lambdabot>         against inferr...
08:59:12 <koeien1> eugenn > (uncurry (uncurry foldl)) (( (+), 0), [1..20]
08:59:18 <koeien1> > (uncurry (uncurry foldl)) (( (+), 0), [1..20]
08:59:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:59:21 <eugenn> > (uncurry . uncurry) foldl) ((+),0.[1..20])
08:59:22 <lambdabot>   <no location info>: parse error on input `)'
08:59:27 <koeien1> eugenn > (uncurry (uncurry foldl)) (( (+), 0), [1..20])
08:59:32 <koeien1> > (uncurry (uncurry foldl)) (( (+), 0), [1..20]) -- apologies for the spam
08:59:33 <lambdabot>   210
09:00:28 <eugenn> > (uncurry . uncurry) foldl) ((+),0,[1..20])
09:00:29 <lambdabot>   <no location info>: parse error on input `)'
09:00:45 <koeien1> eugenn: two problems with this, the tuple is incorrect, and you should add an extra (
09:00:56 <i_am_neuron> jmcarthur: could you drop a link to yeggie's?
09:00:59 <koeien1> :t ((uncurry.uncurry) foldl)
09:00:59 <lambdabot> forall b b1. ((b -> b1 -> b, b), [b1]) -> b
09:01:25 <eugenn> what if i want the tuple to be a 3-uple with the parameters?
09:01:35 <koeien1> :t uncurry3
09:01:36 <lambdabot> Not in scope: `uncurry3'
09:01:41 <jmcarthur> i_am_neuron: http://steve.yegge.googlepages.com/when-polymorphism-fails
09:01:45 <koeien1> you'd have to write your own uncurry3
09:01:49 <koeien1> @src uncurry
09:01:52 <lambdabot> uncurry f p = f (fst p) (snd p)
09:01:57 <eugenn> > (uncurry . uncurry) foldl)) ((+),0,[1..20])
09:01:58 <lambdabot>   <no location info>: parse error on input `)'
09:02:38 <koeien1> @let balance ((a,b),c) = (a,b,c)
09:02:39 <lambdabot>  Defined.
09:02:53 <koeien1> :t (balance.uncurry.uncurry) foldl
09:02:53 <lambdabot>     Couldn't match expected type `((t, t1), t2)'
09:02:54 <lambdabot>            against inferred type `(a, b) -> c'
09:02:54 <lambdabot>     In the first argument of `(.)', namely `uncurry'
09:03:04 <jmcarthur> i love how the article implies that OO polymorphism is the only kind of polymorphism
09:03:15 <jmcarthur> or, rather, i hate how it does that
09:03:52 <eugenn> > (uncurry3 foldl) ((+),0,[1..20]) where uncurry3 f p = f (fst p) (snd p) (trd p) where trd(_,_,c) = c
09:03:58 <lambdabot>   <no location info>: parse error on input `where'
09:03:59 <Rayne> is my solution for 5d) worse? http://pastie.org/710065
09:04:19 <koeien1> Rayne: use pattern matching instead
09:04:46 <koeien1> also, suppose that you forgot about 'elem', i'd make and use some higher order functions instead
09:05:46 <eugenn> > (uncurry3 foldl) ((+),0,[1..20]) where uncurry3 f p = f (fst p) (snd p) (trd p) where trd (_,_,c) = c
09:05:47 <lambdabot>   <no location info>: parse error on input `where'
09:05:55 <Rayne> koeien, elem would be too easy i think, but it is a good idea to write a elem version - thanks for that hint
09:05:58 <koeien1> eugenn: "where" is not an expression
09:06:38 <eugenn> :t balance
09:06:39 <lambdabot> forall t t1 t2. ((t, t1), t2) -> (t, t1, t2)
09:06:49 <telofy> Hi, I have a little problem: In our current assignment we have a class given: "class Memory m where allocate :: m -> Int -> (m, Int)" Now this Memory m can either be a list of Bool or a List of tuples (Int,Int), so I wanted to define the "instance Memory [Bool] where ..." but hugs doesn't like that: "Syntax error in instance head (variable expected)" What am I doing wrong? Thanks!
09:07:10 <eugenn> > balance ((1,2),3)
09:07:11 <lambdabot>   (1,2,3)
09:07:24 <Rayne> ( koeien, no i did not know about elem)
09:07:42 <koeien1> Rayne: ok, but even then it's better to abstract away over the iteration of the list
09:08:01 <koeien1> you could also use (or invent) a function like "any"
09:08:16 <Rayne> i will note that, thanks
09:08:39 <Rayne> so, good bye and thanks for the fish :)
09:08:41 <ski> @type uncurry (uncurry . foldl) . disturb  -- koeien1 ?
09:08:42 <lambdabot> forall a b. (a -> b -> a, a, [b]) -> a
09:08:59 <eugenn> :t disturb
09:09:00 <lambdabot> forall t t1 t2. (t, t1, t2) -> (t, (t1, t2))
09:09:23 <koeien1> ski: ah yes
09:09:24 <eugenn> > (balance . disturb) (1,2,3)
09:09:25 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
09:09:25 <lambdabot>    arising from the literal `1' at <i...
09:10:10 <ski> > let uncurry3 f ~(x,y,z) = f x y z in (uncurry3 foldl) ((+),0,[1..20])  -- eugenn ?
09:10:10 <lambdabot>   210
09:10:16 <koeien1> @let balance (a,(b,c)) = (a,b,c)
09:10:17 <lambdabot>  <local>:3:0:
09:10:17 <lambdabot>      Multiple declarations of `L.balance'
09:10:17 <lambdabot>      Declared at: <lo...
09:10:26 <koeien1> @let balance' (a,(b,c)) = (a,b,c)
09:10:27 <lambdabot>  Defined.
09:10:29 <eugenn> great
09:10:35 <koeien1> > (balance'.disturb) (1,2,3)
09:10:36 <lambdabot>   (1,2,3)
09:10:43 <eugenn> what's ~?
09:10:48 <koeien1> lazy pattern matching
09:10:53 <ski> irrefutable pattern
09:11:11 <eugenn> lazy pattern matching? w-h-o-a. i want to learn that
09:11:27 <koeien1> it's not very often useful ime
09:12:52 <eugenn> @let plusOne = (1+)
09:12:53 <lambdabot>  Defined.
09:13:08 <eugenn> > plusOne 3 == succ 3
09:13:09 <lambdabot>   True
09:13:19 <ski> > let f (Just x) = Right x; f Nothing = Left "is wrong" in map f [Just 42,Nothing]
09:13:20 <lambdabot>   [Right 42,Left "is wrong"]
09:13:22 <ski> > let f ~(Just x) = Right x; f Nothing = Left "is wrong" in map f [Just 42,Nothing]
09:13:23 <lambdabot>   [Right 42,Right * Exception: <interactive>:1:141-190: Irrefutable pattern f...
09:13:47 <h20xt> > succ == plusOne
09:13:48 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
09:13:48 <lambdabot>    arising from a use of `GHC.Cla...
09:13:51 <h20xt> :(
09:14:00 <eugenn> functions are not Eq
09:14:02 <koeien1> h20xt: this would be a very hard problem to solve
09:14:04 <h20xt> i know
09:14:09 <h20xt> i was just dreaming
09:14:13 <eugenn> hehe i know you know
09:14:23 <ski> @check let plusOne = (1+) in \x -> succ x == plusOne x
09:14:24 <lambdabot>   "OK, passed 500 tests."
09:14:56 <eugenn> @check succ x = x+1
09:14:56 <lambdabot>   Parse error at "=" (column 8)
09:15:02 <eugenn> @check succ x == x+1
09:15:03 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:15:11 <ski> that's using
09:15:13 <ski> > x
09:15:14 <lambdabot>   x
09:15:15 <koeien1> @check \x -> succ x == x +1
09:15:15 <h20xt> is that even possible? i mean if it is linear you can show they do the same things to basis, which would work in this case
09:15:16 <lambdabot>   "OK, passed 500 tests."
09:15:23 <h20xt> but i guess in general it is totally impossible
09:15:25 <eugenn> ah I get it
09:15:42 <koeien1> h20xt: in general? yes
09:16:19 <koeien1> h20xt: what if your vector space is infinite dimensional? then your problem may not be a finite number of cases to check
09:16:28 <ski> > uncurry (==) `graph` (x,x+1)
09:16:29 <lambdabot>   ((x,x + 1),False)
09:16:50 <eugenn> @check \(a,b,c) -> (a,b,c) == (balance' . disturb) (a,b,c)
09:16:50 <lambdabot>   Not in scope: `balance''Not in scope: `disturb'
09:16:51 <h20xt> koeien1: of course, i always forget about infinite dimensional vector spaces, never worked with them before
09:18:39 <eugenn> > sequence ""lambda","lambda""
09:18:40 <lambdabot>   Not in scope: `lambda'Not in scope: `lambda'
09:18:53 <koeien1> > sequence ["lambda","lambda"]
09:18:54 <lambdabot>   ["ll","la","lm","lb","ld","la","al","aa","am","ab","ad","aa","ml","ma","mm"...
09:19:03 <Botje> > cycle "Badger "
09:19:03 <lambdabot>   "Badger Badger Badger Badger Badger Badger Badger Badger Badger Badger Badg...
09:19:06 <eugenn> > sequence ["lambda","lambda"]
09:19:07 <lambdabot>   ["ll","la","lm","lb","ld","la","al","aa","am","ab","ad","aa","ml","ma","mm"...
09:19:16 <koeien1> don't forget that "lambda" = 'l':'a':'m':'b':'d':'a':[]
09:19:25 <koeien1> > sequence [[1,2],[3,4]]
09:19:26 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
09:20:00 <eugenn> somehow we could define 'combinations' with sequence and zipwith
09:21:02 <m0nkfish> > inits "abc"
09:21:03 <lambdabot>   ["","a","ab","abc"]
09:21:29 <eugenn> > lasts "abc"
09:21:30 <lambdabot>   Not in scope: `lasts'
09:21:35 <eugenn> oh hehe
09:21:40 <m0nkfish> that's tails i think
09:21:50 <eugenn> > tails "abc"
09:21:50 <lambdabot>   ["abc","bc","c",""]
09:22:22 <eugenn> that's the definitions of prefix and suffix in formal grammars!
09:23:54 <eugenn> :t graph
09:23:54 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
09:25:19 <eugenn> @quote omega
09:25:19 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
09:25:19 <lambdabot> sing with me?
09:25:41 <eugenn> hahaha
09:25:51 <h20xt> > sequence $ replicate 8 "01"
09:25:52 <lambdabot>   ["00000000","00000001","00000010","00000011","00000100","00000101","0000011...
09:25:58 <h20xt> is there a shorter way to do this?
09:26:05 <h20xt> i am thinking back to an interview question
09:26:08 <h20xt> i came up with
09:26:29 <byorgey> > replicateM 8 "01"
09:26:30 <lambdabot>   ["00000000","00000001","00000010","00000011","00000100","00000101","0000011...
09:26:30 <h20xt> echo {0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}
09:26:37 <h20xt> but that was bash
09:26:43 <h20xt> ah thanks byorgey
09:27:05 <h20xt> neat
09:27:08 <byorgey> of course replicateM is just (sequence .) . replicate
09:27:13 <byorgey> @src replicateM
09:27:13 <lambdabot> replicateM n x = sequence (replicate n x)
09:27:31 <byorgey> it comes up often enough to warrant its own name =)
09:27:45 <m0nkfish> what is the M for
09:27:51 <h20xt> Monad
09:27:53 <byorgey> M is for Monadic
09:28:16 <byorgey> hmm, someone ought to write a book entitled "My First Haskell Alphabet"
09:28:30 <byorgey> "A is for Applicative, B is for .... ummm...
09:28:37 <koeien1> beards?
09:28:39 <h20xt> Binary Tree
09:28:43 <h20xt> or beards
09:28:49 <byorgey> beards!?
09:28:51 <eugenn> @quote algorithm
09:28:52 <lambdabot> PaulGraham says: An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers
09:28:52 <lambdabot> you should have cited.
09:29:05 <h20xt> @quote beards
09:29:05 <lambdabot> Igloo says: * shapr is desperately trying to grow a beard at this point... // <Igloo> You normally grow beards over partial non-Euclidean planes, not at points
09:29:36 <h20xt> oh wow
09:29:38 <koeien1> and A is for Arrow instead :(
09:29:49 <dixie_> is there somewhere hoogle with index of all libraries in hackage ?
09:29:51 <eugenn> B is for Bool
09:29:58 <Cale> B is for `backquotes`
09:30:25 <byorgey> ah, both good suggestions =)
09:30:30 <koeien1> now C
09:30:34 <koeien1> Cont ?
09:30:34 <Cale> Category!
09:30:45 <Cale> (theory)
09:30:52 <koeien1> yeah, CT is better
09:31:08 <Draconx> dixie_, there's hayoo!
09:31:38 <eugenn> @quote awesome
09:31:38 <lambdabot> Berengal says: I just can't get over how awesome it [referential transparency] is. I feel like instituting a holiday or something...
09:31:54 <EvanCarroll> are pattern matches just case statements?
09:32:08 <Cale> EvanCarroll: case expressions, yeah
09:32:09 <dixie_> Draconx: Thanks.
09:32:37 <Cale> EvanCarroll: You can imagine that the compiler transforms all pattern matches into case expressions.
09:32:46 <eugenn> @quote love
09:32:46 <lambdabot> <copumpkin> says: I love: Warning: Due to a known bug, the default Linux document viewer evince prints N*N copies of a PDF file when N copies requested. As a workaround, use Adobe Reader acroread
09:32:46 <lambdabot> for printing multiple copies of PDF documents, or use the fact that every natural number is a sum of at most four squares.
09:32:47 <koeien1> that's probably what Core is like, right?
09:32:52 <Cale> koeien1: yeah
09:33:36 <EvanCarroll> so i can use explicit styles if i want and write my haskell however i'd like?
09:33:48 <EvanCarroll> using semicolons and brackets
09:34:02 <eugenn> @quote topology
09:34:02 <lambdabot> No quotes match. The more you drive -- the dumber you get.
09:34:03 <koeien1> you can
09:34:10 <EvanCarroll> nifty.
09:34:14 <Cale> EvanCarroll: You can, though it's a bit socially awkward to write Haskell code with braces and semicolons.
09:34:22 <Berengal> EvanCarroll: yes, but note that not everything is subject to layout. If-then-else, for example, isn't
09:34:23 <eugenn> @quote point-free
09:34:23 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
09:34:28 <EvanCarroll> Cale: Got to maintain my reputation
09:34:31 <EvanCarroll> ;)
09:34:48 <koeien1> Cale: try reading the UHC sources for a change :P
09:34:55 <EvanCarroll> Berengal: what do you mean at that?
09:35:07 <Cale> Braces and semicolons are handy when you need to squish things on to one line for lambdabot or ghci though
09:35:16 <Berengal> EvanCarroll: if-then-else constructs don't pay attention to indentation. You can indent them however you like.
09:35:37 <Cale> (as long as you don't break other indentation rules while you're at it)
09:35:47 <Berengal> Unless I'm mistaken, layout only affects case, let, where and do constructs
09:35:49 <eugenn> @quote maxwell
09:35:49 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
09:35:59 <EvanCarroll> but the other indention rules can be ignored if you use explicit brackets/semi-colons
09:36:12 <Twey> Berengal: Eh?
09:36:21 <eugenn> @quote replicate
09:36:22 <lambdabot> faxathisia says:  > (fun $ intercalate (map chr [0x0d, 0x0a])$ map (concat.map (\(e,r) -> replicate e ' ' ++ replicate r '@'))[[(0,3)],[(3,2)],[(3,3)],[(2,2),(1,2)],[(0,2),(3,2)]]) :: Expr
09:36:36 <Berengal> > (fun $ intercalate (map chr [0x0d, 0x0a])$ map (concat.map (\(e,r) -> replicate e ' ' ++ replicate r '@'))[[(0,3)],[(3,2)],[(3,3)],[(2,2),(1,2)],[(0,2),(3,2)]]) :: Expr
09:36:37 <lambdabot>   @@@
09:36:37 <lambdabot>     @@
09:36:37 <lambdabot>     @@@
09:36:37 <lambdabot>    @@ @@
09:36:37 <lambdabot>  @@   @@
09:36:42 <Twey> Berengal: There's a famous issue with if/then/else where people write if cond then\n\tfoo\nelse\n\tbar
09:36:46 <eugenn> hahahah
09:36:48 <Cale> But there are really only a few good ways to indent an if-expression
09:36:49 <Twey> Berengal: Cute :þ
09:37:05 <Cale> You should always align the 'then' with the 'else'
09:37:16 <Cale> Unless they are on the same line
09:37:23 <Cale> So either:
09:37:28 <Cale> if foo then bar else quux
09:37:33 <Cale> if foo then bar
09:37:37 <Cale>        else quux
09:37:41 <Berengal> Twey: Only inside blocks that _are_ affected by layout, especially do
09:37:46 <Cale> if foo
09:37:48 <Cale>    then bar
09:37:51 <Cale>    else quux
09:38:00 <fritschy_> Sooo... /me being new to haskell and monads... am i right, that when i have a function that is not pure called - this can never happen from a pure function?! Uh... rather poor wording, I'll reconsider that one in a moment ;)
09:38:14 <IceDane> so, guys.. >head (head lol)
09:38:14 <Berengal> fritschy_: that's right
09:38:15 <IceDane> [79,59,12]
09:38:15 <eugenn> @quote dream
09:38:15 <lambdabot> dons says: not all programmers dream about type erasure :)
09:38:16 <IceDane> yet
09:38:24 <Cale> fritschy_: Which monad are you talking about?
09:38:28 <IceDane> >getAllIndices [75,59,12] (head lol)
09:38:28 <IceDane> []
09:38:29 <fritschy_> IO
09:38:41 <IceDane> getAllIndices = findIndicies with a predicate, basically
09:38:44 <Berengal> fritschy_: note that monads can be pure. There's nothing inherently impure about them
09:38:50 <Cale> fritschy_: IO is rather different from most monads
09:38:59 <eugenn> > filter odd [2,4..]
09:39:03 <lambdabot>   mueval-core: Time limit exceeded
09:39:15 <Cale> Well, the IO monad can be pure too, it's just that *executing* IO actions isn't.
09:39:58 <Berengal> purity isn't well-defined anyway... I sometimes consider big state-monadic actions to be impure, but small ones to be pure.
09:40:05 <rwx> why are the monad rules not enforced?
09:40:08 <eugenn> @quote google
09:40:08 <lambdabot> Korollary says: Google employees suck. [some time later] I bet my search history has been made public right now
09:40:12 <fritschy_> hm... ok... the thing is, i have a function that does use IO actions, and i want some not "IO ..." value from it
09:40:32 <Berengal> fritschy_: this is what (>>=) is for
09:40:34 <Cale> rwx: Too awkward with Haskell's type system
09:40:46 <fritschy_> Berengal: ok, need to read further about it :)
09:40:49 <Draconx> rwx, probably something about undecidability.
09:40:53 <rwx> are there changes in Haskell' to make that feasible?
09:41:00 <fritschy_> Thanks very much, bbl ;)
09:41:02 <Berengal> fritschy_: Just look at the type:
09:41:06 <Berengal> @type (>>=)
09:41:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:41:12 <Cale> fritschy_: If you have x :: IO t, and inside a do-block you write v <- x, it means to run x and name the result v, which means that v :: t
09:41:17 <gwern> wonder if one could define quickcheck instances for monads
09:41:22 <rwx> Draconx, i figured docs would've said that if that were the case, instead of saying "the programmer needs to figure it out"
09:41:41 <IceDane> does this make sense to anyone? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12952#a12952
09:41:42 <eugenn> @quote list
09:41:43 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
09:41:43 <lambdabot>  what you just said?"
09:41:57 <Cale> fritschy_: And v remains in scope for the remainder of the do-block, where you can pass it off to some pure function which wants it.
09:42:12 <Cale> fritschy_: and then perhaps do some output with the result
09:42:34 <eugenn> @quote lisa
09:42:34 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
09:42:47 <MoALTz> heh
09:44:07 <eugenn> @quote hello
09:44:08 <lambdabot> <erg0t> says: @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>. <lambdabot>  Hello World!
09:44:25 <Cale> :t elemIndices
09:44:26 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
09:44:35 <RayNbow> @faq Can Haskell fix my car problems?
09:44:35 <lambdabot> The answer is: Yes! Haskell can do that.
09:44:39 <tommd> @quote hackage
09:44:39 <lambdabot> int-e says: I propose that all of f, g, h and i be made illegal. (referring to http://hackage.haskell.org/trac/haskell-prime/wiki/StricterLabelledFieldSyntax as it existed on 2009-10-05)
09:44:49 <h20xt> so i've been doing some binary file output lately, and it is *slow*, i have tried multiple methods, the Foreign interface, Data.Binary, and ByteString. Foreign was the slowest, Binary.Data is faster, but still takes ~2 seconds to dump out 4096*4096*3 bytes, where as a c version takes .015 seconds, also the Haskell version cranks the CPU up to 99% when it should definently be bounded by the disk IO if anything, that is all it even does, a
09:44:54 <Cale> IceDane: Makes sense to me.
09:45:03 <IceDane> Cale: that it fails?
09:45:07 <Cale> Fails?
09:45:19 <IceDane> I mean, that it shows inconsistent results
09:45:31 <Cale> What's lol?
09:45:39 <IceDane> [[Int]]
09:45:45 <Cale> I mean, what list is it?
09:45:45 <eugenn> @quote lol
09:45:45 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
09:46:04 <IceDane> It's a very long list, but you can see me doing head (head lol) which returns the list i'm looking for
09:46:10 <IceDane> but it doesn't even give me the index of it
09:46:17 <IceDane> I didn't know about elemIndices btw
09:46:20 <IceDane> That might solve the issue
09:46:27 <eugenn> @quote mensa
09:46:27 <lambdabot> No quotes match.
09:47:26 <eugenn> @quote month
09:47:27 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
09:47:51 <h20xt> for instance, this code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12953#a12953, just took 1 minute to run
09:47:51 <Cale> IceDane: I find it strange that getAllIndices gives an empty list when the list so be searched for is empty
09:48:14 <IceDane> Cale: What do you think it should give?
09:48:27 <Cale> IceDane: The list of positions where an empty list occurs
09:48:38 <IceDane> oh, right
09:48:41 <IceDane> forgot about that
09:49:06 <Cale> @src elemIndices
09:49:06 <lambdabot> elemIndices x   = findIndices (x==)
09:49:27 <eugenn> @quote complicated
09:49:28 <lambdabot> No quotes match. My pet ferret can type better than you!
09:49:57 <IceDane> Cale: yeah, I didn't know about it, I guess
09:50:24 <eugenn> @quote small
09:50:24 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
09:50:29 <Cale> IceDane: Well, the main thing I'm pointing out there is that it doesn't need to handle the small cases specially :)
09:50:47 <IceDane> Not sure what you mean.. The empty list thing?
09:50:51 <Cale> Yeah
09:51:00 <Daimonic> what is the negation operator for booleans? > True -> False > False -> True?
09:51:07 <RayNbow> :t not
09:51:08 <lambdabot> Bool -> Bool
09:51:13 <Daimonic> ah :)
09:51:18 <tommd> :t not . not
09:51:19 <lambdabot> Bool -> Bool
09:51:23 <Cale> You have two equations for managing the empty list case in either argument, one of which is strange and the other of which is redundant. I'm still not sure it explains what you're seeing.
09:51:25 <MoALTz> :i not
09:51:38 <Cale> IceDane: What's the type of lol as reported by ghci?
09:51:43 <RayNbow> :t foldl id (.) [not,not,not,not]
09:51:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
09:51:45 <lambdabot>     Probable cause: `id' is applied to too many arguments
09:51:45 <lambdabot>     In the first argument of `foldl', namely `id'
09:51:49 <RayNbow> hmm
09:52:02 <Cale> :t foldr (.) id [not,not,not,not]
09:52:03 <lambdabot> Bool -> Bool
09:52:15 <IceDane> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12952#a12956 @ Cale
09:52:18 <RayNbow> ah crap
09:52:23 <h20xt> yeah this is ridiculous, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12954#a12954, this runs in .1 seconds if anything it should be slower, not many many times faster
09:52:24 <RayNbow> flipped the f and z
09:52:38 <Cale> IceDane: What's the type of lol as reported by ghci?
09:52:40 <eugenn> > not True
09:52:41 <lambdabot>   False
09:52:47 <Cale> IceDane: Is it polymorphic?
09:52:59 <IceDane> Cale: You can see the type in the new revision
09:53:09 <IceDane> it's [[[Int]]]
09:53:25 <Cale> IceDane: That's what  :t lol  reports?
09:53:29 <IceDane> Yes.
09:53:32 <Cale> okay
09:53:35 <eugenn> :t lol
09:53:36 <lambdabot> Not in scope: `lol'
09:53:59 <Cale> Well, this latest result seems consistent.
09:54:07 <Cale> [75,59,12] isn't there.
09:54:14 <IceDane> ah
09:54:15 <IceDane> typo
09:54:20 <eugenn> > take 5 (concat (replicate 6 9))
09:54:21 <lambdabot>   No instance for (GHC.Num.Num [a])
09:54:21 <lambdabot>    arising from the literal `9' at <inter...
09:54:42 <eugenn> > take 5 (concat (replicate 6 [9]))
09:54:43 <lambdabot>   [9,9,9,9,9]
09:55:01 <IceDane> I thought elemIndices had the same problem - my getAllIndices was probably broken then, then I tried elemIndices with a typo
09:55:04 <IceDane> thanks =)
09:55:10 <IceDane> Can finally continue x.x
09:55:22 <Cale> Actually, you were searching for the wrong list before too it seems
09:55:32 <IceDane> Oh
09:55:34 <IceDane> that's even better
09:55:40 <IceDane> I just spent an hour not noticing a typo
09:55:41 <IceDane> lol
09:55:50 <IceDane> thanks.
09:56:47 <rmoss> can anyone explain a generic equals using a fixed point combinator to me because this is blowing my mind?
09:57:12 <eugenn> :t 5
09:57:13 <lambdabot> forall t. (Num t) => t
09:57:24 <koeien1> > 5 :: Complex Double
09:57:25 <lambdabot>   5.0 :+ 0.0
09:57:30 <koeien1> > 5 :: Int
09:57:31 <lambdabot>   5
09:57:35 <koeien1> > 5 :: Word8
09:57:36 <lambdabot>   5
09:58:06 <eugenn> > 5 :: Monad
09:58:06 <lambdabot>   Class `GHC.Base.Monad' used as a type
09:58:30 <koeien1> eugenn: Monad is a type class, not a type itself
09:58:43 <eugenn> > 5 :: Functor
09:58:44 <lambdabot>   Class `GHC.Base.Functor' used as a type
09:58:47 <koeien1> Functor too
09:58:51 <eugenn> oh
09:59:03 <koeien1> types can be Functors
09:59:24 <koeien1> e.g. [] is a Functor (and a Monad), but there are more
09:59:30 <koeien1> Num is also a typeclass
09:59:44 <koeien1> Int, Integer and Complex Double are all *instances* of this type class
10:00:25 <koeien1> :t fmap
10:00:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:00:37 <koeien1> > fmap (+1) (Just 2) -- Maybe is a Functor
10:00:38 <lambdabot>   Just 3
10:00:47 <koeien1> > fmap (+1) [2,3] -- [] is a Functor
10:00:48 <lambdabot>   [3,4]
10:01:38 <eugenn> > Just 2 + Just 4
10:01:38 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
10:01:39 <lambdabot>    arising from a use of...
10:01:55 <koeien1> > liftM2 (+) (Just 2) (Just 4)
10:01:56 <lambdabot>   Just 6
10:02:26 <eugenn> liftM2 (+) (Maybe 3) (Maybe 1)
10:02:38 <eugenn> > liftM2 (+) (Maybe 3) (Maybe 1)
10:02:39 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe'
10:02:47 <koeien1> Maybe is not a constructor
10:02:49 <koeien1> @src Maybe
10:02:49 <lambdabot> data Maybe a = Nothing | Just a
10:03:02 <koeien1> (not a data constructor)
10:04:38 <koeien1> > liftM2 (+) (Just 37) Nothing
10:04:38 <lambdabot>   Nothing
10:05:22 <eugenn> > 9^(9^(9^(9)))
10:05:28 <lambdabot>   mueval: ExitFailure 1
10:05:47 <koeien1> must be out of memory
10:06:20 <eugenn> @quote recursion
10:06:21 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
10:06:21 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
10:06:21 <lambdabot> still
10:08:45 <Twey> Crikey.
10:08:47 <eugenn> @quote true
10:08:48 <lambdabot> thetallguy says: Using and advocating Haskell is like being Calvin (and Hobbes). To you, it's alive, real, a true delight. To those who know better, it's a stuffed tiger.
10:09:35 <eugenn> @quote total
10:09:35 <lambdabot> qwe1234 says: being garbage collected pretty much ensures that any and all multi-core implementation will get totally ruined and become unusable.
10:09:55 * Twey chuckles.
10:10:30 <eugenn> @quote semantics
10:10:31 <lambdabot> scook0 says: real men don't need semantics, they pipe meaning directly into their compilers!
10:10:40 <newsham> quote sunday?
10:10:59 <eugenn> @quote sunday
10:10:59 <lambdabot> No quotes match. It can only be attributed to human error.
10:11:34 <Apocalisp> @quote banana
10:11:34 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
10:11:50 <eugenn> @quote java
10:11:50 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
10:11:50 <lambdabot>  but then I look at some java code and I'm all happy again
10:12:06 <newsham> whats with all the quoting?
10:12:26 <Apocalisp> Quiet sunday
10:12:37 <Apocalisp> @quote quote
10:12:37 <lambdabot> psykotic says: monochrom, I'm reminded me of that Alan Kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
10:13:02 <eugenn> @listusersconnected
10:13:02 <lambdabot> Unknown command, try @list
10:13:08 <drdozer> hi - is one of the lambdacube devs in here?
10:13:30 <eugenn> > "hello earth"
10:13:31 <lambdabot>   "hello earth"
10:14:12 <IceDane> @list
10:14:12 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:14:29 <eugenn> > reverse "sadbmal evol I"
10:14:29 <lambdabot>   "I love lambdas"
10:14:48 <drdozer> Graphics/LambdaCube/Loader/StbImage.hs:19:19: Not in scope: `STB.withImage'
10:14:57 <drdozer> happens when doing a cabal install :(
10:15:38 <eugenn> :t reduce
10:15:39 <lambdabot> Expr -> Expr
10:16:00 <eugenn> > reduce (2/4)
10:16:00 <lambdabot>   0.5
10:16:16 <eugenn> > reduce (2%4)
10:16:17 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:16:18 <lambdabot>         against inferred ...
10:16:48 <h20xt> eugenn: where does reduce come from?
10:17:15 <eugenn> probably to reduce fractions. i don't know
10:17:20 <Cale> No
10:17:34 <Cale> It's to reduce Expr values from the simplereflect package
10:17:41 <eugenn> @src reduce
10:17:41 <Cale> > x + x + x
10:17:41 <lambdabot> reduce _ 0 = undefined
10:17:41 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
10:17:41 <lambdabot>     where d = gcd x y
10:17:42 <lambdabot>   x + x + x
10:17:55 <Cale> > reduce (x + x + x)
10:17:56 <lambdabot>   x + x + x
10:18:01 <Cale> hmm
10:18:06 <eugenn> > reduce (36:%72)
10:18:07 <lambdabot>   Not in scope: data constructor `:%'
10:18:14 <Cale> > 3 + 4 :: Expr
10:18:15 <lambdabot>   3 + 4
10:18:21 <Cale> > reduce (3 + 4 :: Expr)
10:18:22 <lambdabot>   7
10:18:35 <eugenn> ooh
10:18:41 <Cale> The reduce which is reported by @src isn't even exported from Data.Ratio
10:18:50 <h20xt> reduce (head [4, 5] :: Expr)
10:18:56 <h20xt> > reduce (head [4, 5] :: Expr)
10:18:57 <lambdabot>   4
10:18:57 <Cale> Rational numbers reduce themselves automatically
10:19:03 <h20xt> :)
10:19:14 <Cale> > head [4,5] :: Expr
10:19:15 <lambdabot>   4
10:19:19 <h20xt> :(
10:19:21 <h20xt> hehe
10:19:29 <eugenn> > (36/72) :: Fractional
10:19:30 <lambdabot>   Class `GHC.Real.Fractional' used as a type
10:19:30 <h20xt> good point
10:19:35 <Cale> Expr values only hold up numerical computations
10:19:47 <eugenn> > (36/72) :: Fraction
10:19:48 <lambdabot>   Not in scope: type constructor or class `Fraction'
10:19:54 <koeien1> :: Ratio
10:20:01 <koeien1> :: Rational
10:20:02 <eugenn> > (36/72) :: Ratio
10:20:03 <lambdabot>   `GHC.Real.Ratio' is not applied to enough type arguments
10:20:03 <lambdabot>  Expected kind `?'...
10:20:10 <koeien1> > (36/72) :: Rational
10:20:11 <lambdabot>   1 % 2
10:20:11 <h20xt> > 36 :% 37
10:20:12 <lambdabot>   Not in scope: data constructor `:%'
10:20:19 <koeien1> > (36/72) :: Ratio Double
10:20:20 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
10:20:20 <lambdabot>    arising from a use ...
10:20:25 <koeien1> > (36/72) :: Ratio Word8
10:20:25 <centrinia> > 36 % 72
10:20:26 <lambdabot>   1 % 2
10:20:26 <lambdabot>   1 % 2
10:20:32 <Cale> > (36/72) :: Rational
10:20:33 <lambdabot>   1 % 2
10:20:36 <Cale> > (36/72) :: Ratio Integer
10:20:37 <lambdabot>   1 % 2
10:20:43 <koeien1> type Rational = Ratio Integer
10:20:46 <koeien1> @src Rational
10:20:46 <lambdabot> type Rational = Ratio Integer
10:20:51 <Cale> Yep
10:20:54 <centrinia> > (36 % 72)+(37%73)
10:20:55 <lambdabot>   147 % 146
10:21:00 <eugenn> whoa
10:21:03 <h20xt> > 2 % 4
10:21:04 <lambdabot>   1 % 2
10:21:08 <h20xt> neat
10:21:12 <eugenn> > 2%4
10:21:12 <centrinia> > 1%0
10:21:13 <lambdabot>   1 % 2
10:21:13 <lambdabot>   * Exception: Ratio.%: zero denominator
10:21:17 <h20xt> hah
10:21:25 <koeien1> can't divide by zero, no
10:21:52 <h20xt> > let ~x = 1 % 0
10:21:53 <lambdabot>   not an expression: `let ~x = 1 % 0'
10:21:59 <eugenn> > take 4 [1,2,3,4,(6/0)]
10:22:00 <lambdabot>   [1.0,2.0,3.0,4.0]
10:22:16 <eugenn> praise lazyness
10:22:23 <koeien1> curse laziness
10:22:37 <koeien1> it's Haskell's greatest strength but also one of its weaknesses imo
10:22:48 <h20xt> i don't know how to deal with it yet
10:22:54 <h20xt> i can't reason about performance at all
10:22:56 <koeien1> (well -- not the greatest strength, i would say purity is more important, but it is one of its strengths)
10:24:41 <eugenn> is Expr a subclass of anything?
10:25:19 <tensorpudding> laziness is good
10:25:51 <eugenn> > True && False
10:25:51 <lambdabot>   False
10:26:47 <tensorpudding> > False || undefined
10:26:48 <lambdabot>   * Exception: Prelude.undefined
10:26:53 <tensorpudding> err
10:26:57 <tensorpudding> > True || undefined
10:26:57 <lambdabot>   True
10:27:15 <shrughes> psh
10:27:22 <tensorpudding> short-circuiting for the hmm
10:27:23 <shrughes> > True || unsafePerformIO cureCancer
10:27:24 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `cureCancer'
10:28:21 <shrughes> memory safety is haskell's greatest strength
10:28:44 <shrughes> a popular strength, but nevertheless...
10:29:14 <Cale> type safety is better than memory safety
10:30:35 <rwx> how do i find documentation on ~ ?
10:30:43 <eugenn> @pl xor a b = ((a && b) == False) && ((a || b) == True)
10:30:44 <lambdabot> xor = ap (ap . ((&&) .) . flip flip False . ((==) .) . (&&)) (flip flip True . ((==) .) . (||))
10:31:15 <Cale> rwx: ~ occurs in the syntax in a few places, are you talking about the one which occurs in patterns?
10:31:38 <rwx> i'd like to see all of them, sure, but i'm thinking of: <h20xt> > let ~x = 1 % 0
10:31:51 <Cale> Oh, that ~ was completely unnecessary
10:31:56 <rwx> ah
10:32:00 <eugenn> @pl xor a b = (not (a && b)) && ((a || b))
10:32:01 <lambdabot> xor = ap (ap . (((&&) . not) .) . (&&)) (||)
10:32:04 <rwx> Cale, ok then yes in pattern matching :-)
10:32:56 <Cale> rwx: What ~ normally does is to make the matching of a pattern "lazy" in that it will always immediately succeed and the actual matching will be deferred until a variable in that pattern is used later.
10:33:17 <Cale> rwx: Of course, if the pattern doesn't match, you get an exception at that point, so it's best to be careful.
10:33:38 <rwx> Cale, ah, so it saves time if you just want to destructure something?
10:33:46 <ben0x539> > let ~(a, b) = 42 in b
10:33:47 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
10:33:47 <Cale> Well, it's more about semantics.
10:33:47 <lambdabot>    arising from the literal `42' at <...
10:34:14 <rwx> Cale, lost me :-)
10:34:21 <ben0x539> welp, i suppose types are different business
10:34:31 <ben0x539> > let ~(Just a) = Nothing in a
10:34:32 <lambdabot>   * Exception: <interactive>:1:137-155: Irrefutable pattern failed for patter...
10:34:54 <mmorrow> > (\x -> case x of ~(Left y) -> 4:5:6:case y of [] -> undefined) (Right 42)
10:34:55 <lambdabot>   [4,5,6* Exception: <interactive>:1:160-213: Irrefutable pattern failed for ...
10:35:21 <mmorrow> > (\x -> case x of Left y -> 4:5:6:case y of [] -> undefined) (Right 42)
10:35:22 <lambdabot>   * Exception: <interactive>:1:160-210: Non-exhaustive patterns in case
10:35:34 <eugenn> > 4 :: Undefined
10:35:35 <theclaw> when I have an "IO a" variable, how do I extract the "a"?
10:35:35 <lambdabot>   Not in scope: type constructor or class `Undefined'
10:35:47 <theclaw> not that I would use that in practice
10:35:56 <theclaw> foo (IO a) = a doesn't work
10:36:02 <mmorrow> theclaw: by shoving your function that does something with the a inside the IO
10:36:11 <kmc> theclaw, the IO data constructor is not exported usually
10:36:15 <mmorrow> foo <$> io
10:36:31 <eugenn> :t <$>
10:36:32 <lambdabot> parse error on input `<$>'
10:36:40 <eugenn> :t $
10:36:41 <lambdabot> parse error on input `$'
10:36:41 <mmorrow> @type (\f -> f <$> getContents)
10:36:42 <lambdabot> forall b. (String -> b) -> IO b
10:36:46 <mmorrow> @type (<$>)
10:36:47 <Cale> > let f x (y:ys) = x : f (y+1) ys in f 0 [1..]
10:36:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:36:47 <lambdabot>   [0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:36:59 <drdozer> ah, lambdacube wouldn't build because stb has changed API in version 0.2
10:37:01 <theclaw> kmc: if IO _was_ exported, that would work?
10:37:07 <Cale> er, hmm
10:37:16 <kmc> theclaw, it probably would not do what you want
10:37:27 <theclaw> kmc: why?
10:37:30 <IceDane> How would you guys write a fold to give you a list with the difference between each pair of element in anohter list? I'm failing hard at getting my fold to work. E.g, [1,2,3,4] should become (with 0 as the starting element): 1, 1, 1, 1
10:37:31 <mmorrow> theclaw: you need to know what was actually in there to use it
10:37:37 <mmorrow> *you'd need ..
10:37:43 <kmc> it's implementation-dependent
10:37:53 <kmc> how values of IO-monad type are represented
10:37:55 <mmorrow> theclaw: in ghc's case there's a function in there
10:37:56 <Cale> > let f x (y:ys) = x : f (y+1) ys; xs = f 0 xs in xs
10:38:00 <lambdabot>   mueval-core: Time limit exceeded
10:38:02 <Cale> > let f x ~(y:ys) = x : f (y+1) ys; xs = f 0 xs in xs
10:38:03 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:38:12 <Cale> ^^ there we go :)
10:38:16 <ben0x539> > let x = [1..10] in zipWith (-) x (tail x)
10:38:17 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1]
10:38:20 <ben0x539> woops!!
10:38:25 <mmorrow> theclaw: so it's not just an `a' stashed away in a data constructor
10:38:37 <theclaw> mmorrow, kmc - what else than "data IO" could it be?
10:38:37 <gwern> Cale: but that's not using the fold
10:38:45 <Cale> "the fold"?
10:38:51 <Cale> I was illustrating what ~ does
10:38:52 <kmc> theclaw, you're confusing the type and value constructors
10:38:54 <IceDane> That's not right either, me thinks.
10:38:55 <mmorrow> @src IO
10:38:56 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:38:57 <IceDane> oh
10:39:12 <IceDane> that wasn't @ me, Cale ?
10:39:15 <gwern> Cale: I understood IceDane as wanting a foldr
10:39:17 <kmc> theclaw, there's no rule that the data constructor has to be named "IO" either
10:39:21 <Cale> I was writing this for rwx
10:39:27 <IceDane> ah, alright
10:39:35 <ben0x539> zipWith is a fold, right?
10:39:36 <kmc> theclaw, if you want to unsafely pull values out of the IO monad, there's unsafePerformIO
10:39:38 <ben0x539> @src zipWith
10:39:38 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:39:38 <lambdabot> zipWith _ _      _      = []
10:39:42 <ben0x539> :[
10:39:45 <kmc> but it's not anything like a common thing to do
10:39:54 <lysgaard> I need help with making a datatype. Anyone up for the task
10:40:09 * Twey likes the fact that the ‘real world’ represented by RealWorld is an abstraction.
10:40:16 <theclaw> kmc: hmm. type and value constructors? :) (sorry)
10:40:17 <drdozer> I've a cabal question
10:40:23 <kmc> theclaw, data Foo = Bar Int
10:40:27 <gwern> .09s with parsec-2, .19s with parsec-3. ouch
10:40:29 <kmc> theclaw, Foo is the type, Bar is a data constructor
10:40:31 <gwern> doubling = bad
10:40:41 <kmc> it's also true if you do:  data Foo a = Bar a
10:40:50 <kmc> you can pattern match on Bar, not on Foo
10:40:56 <kmc> they don't even live in the same namespace
10:41:02 <drdozer> I have cabal unpack'ed, edited the cabal file for and then cabal install'ed lambdacube-engine
10:41:16 <Twey> Which makes the whole ‘=’ thing highly confusin
10:41:17 <Twey> g
10:41:25 <Twey> GADT syntax for the win.
10:41:31 <rwx> Cale, thanks for writing those examples, but what is going on there?
10:41:33 <drdozer> when I try to cabal install lamdbdacube-example it tries to re-install lambdacube-engine from scratch
10:41:35 <kmc> data Foo a where { Bar :: a -> Foo a }
10:41:41 <IceDane> thanks to whoever pointed out the zipwith - got it now :P
10:41:42 <theclaw> kmc: so Bar is a data/value constructor I guess, what's a type constructor?
10:41:44 <drdozer> as if it doesn't know that -engine has already been installed
10:41:49 <kmc> theclaw, Foo
10:41:52 <kmc> or IO or Maybe
10:41:59 <Cale> rwx: If f tries to determine what its parameter is too soon, it will fail.
10:42:09 <hoffa> hello, could somebody tell me why this extremely simple code is producing a (NaN, NaN) with 'roots 2 3 4' for example ? (with ghci) http://pastebin.com/m19c9a78a
10:42:17 <lysgaard> I need to make a datatype that includes a graph from the package http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Graph.html#v%3Agelem How do i do that, the class and types are confusing me a bit
10:42:20 <kmc> because they're not types -- you can't have something of type "Maybe" -- but you can apply them to types and get a type, like "Maybe Int"
10:42:27 <kmc> :k Maybe
10:42:28 <lambdabot> * -> *
10:42:32 <kmc> :k Char
10:42:33 <lambdabot> *
10:42:37 <Cale> rwx: But if it assumes that the pattern will match, the first element of its result becomes defined, and by the time the variables from that pattern are needed, the pattern match succeeds.
10:43:58 <drdozer> Cale, any ideas about my cabal problem?
10:44:10 <theclaw> kmc: sorry, so what am I confusing? data IO = ... isn't wrong then?
10:44:17 <theclaw> kmc: i.e., it's defined that way?
10:44:18 <kmc> @src IO
10:44:18 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:44:35 <kmc> theclaw, the question is whether it's "data IO = IO ..." or "data IO = SomethingElse ..."
10:44:36 <gwern> drdozer: could be the -example depends on an older -engine
10:44:41 <kmc> in the latter case, you couldn't pattern match on "IO"
10:44:56 <gwern> drdozer: or it could be you are installing to different users
10:44:58 <kmc> in GHC haskell, the data constructor is also called IO
10:45:02 <kmc> this needn't be the case
10:45:13 <kmc> an implementation does not need to expose the data constructor at all
10:45:27 <drdozer> gwern: I grabbed it all from hackage today, and the verison numbers all match as far as i can see - everything is talking about 0.1.1
10:45:34 <kmc> theclaw, it's as if you'd written "f (Maybe a) = a"
10:45:43 <kmc> > let f (Maybe a) = a in f (Just 3)
10:45:44 <lambdabot>   Not in scope: data constructor `Maybe'
10:46:02 <gwern> drdozer: then maybe you used --user for some and installed as root for others
10:46:39 <drdozer> gwern: everything is installed in my local ~/.cabal directory as far as I know - I've not built anything as root
10:46:50 <mpwd> Why does everyone care about computational complexity theory so much past polynomial time?  Like, is it the same reason that cohomologists care about their crazy branch of mathematics or is there a *good* reason beyond theory?
10:47:03 <drdozer> gwern: and all the dependencies that it built on the way have ended up under ~/.cabal/lib
10:47:21 <theclaw> kmc: hmm,
10:47:30 <gwern> mpwd: ?
10:47:44 <drdozer> gwern: and I can see lambdacube-engine-0.1.1 in there :(
10:47:55 <kmc> mpwd, NP and PSPACE have lots of complete problems that are important in practice
10:48:21 <mpwd> kmc: Who cares that they can't be converted to one another in polynomial time other than theorists?
10:48:54 <kmc> mpwd, we don't know whether NP or PSPACE is equal to P
10:49:06 <kmc> and if they were, it would have huge practical implications
10:49:44 <mpwd> Well, I guess it's an open question, but it's fairly clear that it's not possible, like the Reimann Hypothesis or the Kepler Conjecture, right?
10:50:02 <mpwd> So who cares besides theorists?  Like, is google working on this problem?
10:50:13 <kmc> mpwd, it's fairly clear?
10:50:34 <eugenn> @faq is P=NP?
10:50:34 <lambdabot> The answer is: Yes! Haskell can do that.
10:50:41 <gwern> I thought Kepler had been solved
10:51:05 <mpwd> gwern: Hales doesn't feel it's *really* proved.
10:51:13 <eugenn> @quote prepare
10:51:13 <lambdabot> No quotes match. I've seen penguins that can type better than that.
10:51:32 <gwern> mpwd: bah. I'll bet you're not happy with the map coloring proof, or the finite groups
10:51:35 <roconnor> mpwd: Kepler Conjecture?!
10:51:37 <kmc> mpwd, you are confusing "cares" with "works on"
10:51:41 <Jedai> mpwd: Well, we believe it not to be the case but that's not a certitude... If we were wrong it would have enormous consequences (benefits and catastrophes) and if we were right it is very plausible that the proof would improve our understanding of complexity theory which usually have pretty practical consequences
10:51:45 <roconnor> mpwd: there is a sort of proof of that
10:52:09 <gwern> * either
10:52:14 <mpwd> gwern: I'm happy with Gonthier's proof.  I know that the Kepler Conjecture isn't at the level of the 4-color theorem proof.
10:52:32 <kmc> also i can't find the link but i remember a survey of CS researchers about their gut feelings on P ?= NP, and there wasn't any kind of widespread agreement
10:53:09 * mpwd works on the Kepler conjecture
10:53:28 <kmc> P != NP is definitely the majority view, but there were quite a few who thought P = NP, or who thought it'd end up being independent of the axioms of mathematics
10:53:42 <eugenn> @list
10:53:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:54:17 <eugenn> @dice
10:54:17 <lambdabot> unexpected end of input: expecting number
10:54:21 <mpwd> kmc: I heard once that Newton de Costa proved that if some crazy set theory axiom held, P=NP.  I doubt there's an independence result lurking here.
10:54:26 <eugenn> @dice 6
10:54:26 <lambdabot> 6 => 6
10:54:34 <kmc> how can you talk about whether an axioms holds?
10:54:43 <gwern> I always wonder, what would it mean to be independent? would that be taken as yes, there is a physical matter of the fact where either P=NP or P!=NP, but it's just not answerable in our formalism?
10:54:58 <eugenn> @dice 6
10:54:59 <lambdabot> 6 => 6
10:55:07 <mpwd> kmc: Easily.  You just take ZF and add in some assumption.
10:55:15 <drdozer> this is very strange
10:55:21 <kmc> but it clearly holds... because you added it as an assumption
10:55:56 <mpwd> Yup.  So under some set theory assumptions, he proved P=MP
10:56:00 <mpwd> P=NP rather
10:56:07 <drdozer> I've unpacked lambdacube-engine and built it manually, unpacked lambdacube-examples and tried to build manually, and the first thing it does is download lambdacube-engine and try to build it :(
10:56:50 <mpwd> kmc: Anyway, this is not convincing me that bonafide engineers care about higher complexity theory.
10:57:18 <drdozer> mpwd: they probably do not, but if/when these questions are answered, it will have practical implications for engineers
10:57:52 <roconnor> gwern: you are correct.
10:58:01 <eugenn> @time
10:58:03 <lambdabot> Local time for eugenn is Sun Nov 22 15:58:55 2009
10:58:05 <mpwd> So the legend goes.  I'll have to remember to play that card when I become a researcher.
10:58:42 <roconnor> gwern: it would be somewhat like how Con(PA) is independent of PA.
10:59:15 <eugenn> @karma
10:59:15 <lambdabot> You have a karma of 0
10:59:48 <mpwd> gwern: I don't believe the classification of finite abelian groups, though.
10:59:57 <eugenn> @sleen
10:59:57 <lambdabot> Unknown command, try @list
11:00:08 <mpwd> But I hear Gonthier is working on it which is awesome.
11:00:14 <eugenn> @seen
11:00:14 <lambdabot> Unknown command, try @list
11:00:28 <roconnor> mpwd: do I know you?
11:00:36 <mpwd> Maybe
11:00:47 <mpwd> These are my initials.
11:00:55 <eugenn> @topic
11:00:55 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join oeis todo type
11:03:05 <eugenn> @quote difficult
11:03:05 <lambdabot> qwe1234 says: never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult.
11:03:18 <koeien1> mpwd: what's not to believe?
11:03:26 <smiler> hehe, nice quote
11:03:55 <eugenn> @quote lazy
11:03:55 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
11:04:01 <mpwd> koeien1: Well, how about the correctness of the solutions to 2000+ linear programming problems.
11:04:15 <koeien1> mpwd: did you by accident mean the classification of finite simple groups?
11:04:51 <Cale> drdozer: Sorry, what was your cabal problem?
11:05:00 <mpwd> koeien1: Oh, yeah, I don't believe it because I don't believe that people can reason validly for 5000 pages about abstract nonsense without error.
11:05:12 * mpwd doesn't believe most things.
11:05:16 <mauke> @time
11:05:19 <lambdabot> Local time for mauke is 25:12:62 AM
11:05:26 <koeien1> interesting
11:05:54 <Cale> mpwd: I don't believe a single person could do it, but a group of people working together surely can.
11:06:03 <mauke> whoops, time for dinner
11:06:09 * roconnor beleives the proof is wrong and the theorem is still true.
11:06:11 <koeien1> i don't have an informed opinion about the classification
11:06:25 <mpwd> Cale: I don't believe a group of people can either.
11:06:36 <Cale> It's not really one long 5000 page proof
11:06:39 <eugenn> * eugenn wonders how to do the asterisc thingy
11:06:41 <Cale> It's actually a lot of smaller results.
11:06:50 <kmc> eugenn, /me foo
11:06:51 <Peaker> roconnor, doesn't it get degraded back to hypothesis then?
11:06:54 <koeien1> well, true/interesting mathematics is what mathematicians define as true/interesting
11:07:08 * eugenn thanks you
11:07:12 <kmc> :)
11:07:20 <mpwd> koeien1: Whatever they feel like, as far as I can tell.
11:07:25 <Cale> I think that simple groups are probably a red herring, at least for now.
11:07:47 <koeien1> mpwd: in some sense, yes
11:07:57 <roconnor> Peaker: what do you mean?
11:08:03 <Cale> Sure, we can factor a group into finite simple groups, and its list of finite simple groups is an invariant of it, but it's not uniquely determined by those.
11:08:33 <Cale> and we have no really good explanation about what other information is required to pin the group down after that
11:08:51 <koeien1> Cale: so, in other words, group theory isn't finished? :P
11:09:01 <eugenn> @slap
11:09:02 * lambdabot decomposes  into several parts using the Banach-Tarski theorem and reassembles them to get two copies of !
11:09:03 <roconnor> Cale: is every group a twisted product of simple groups?
11:09:48 <kmc> @slap lambdabot
11:09:48 * lambdabot places her fist firmly on lambdabot's jaw
11:09:57 <Peaker> roconnor, I am not sure what you were talking about, actually :-)  Just if the last sentence: "The proof is wrong" means there's no longer a valid proof, its no longer a theorem, no?
11:10:00 <m0nkfish> > concatM 6 [9]
11:10:01 <lambdabot>   Not in scope: `concatM'
11:10:09 <voker57> /usr/bin/ld: cannot find -lHSregex-posix-0.93.1
11:10:09 <MoALTz> what is an  appropriate naming scheme where x is?:    x@(d:ds)
11:10:13 <Peaker> > replicateM 6 [9]
11:10:14 <lambdabot>   [[9,9,9,9,9,9]]
11:10:21 <koeien1> Peaker: yeah but the result might still be true
11:10:21 <voker57> why can that happen?
11:10:23 <roconnor> Peaker: the truth of the statement is independent of the existance of a proof.
11:10:39 <Peaker> roconnor, of course.. but whether it is a "theorem" depends on a proof, not on truthness, no?
11:10:43 <mpwd> roconnor: 'Cept when its formally undecidable.
11:10:51 <Cale> roconnor: I don't think I've heard that term with respect to groups before.
11:11:01 <koeien1> maybe twisted = semidirect?
11:11:02 <eugenn> @slap mpwd
11:11:02 <lambdabot> stop telling me what to do
11:11:12 <mpwd> lol
11:11:13 <Peaker> koeien1, I thought its not enough for a hypothesis to be true to be called "theorem", it also had to be proven
11:11:14 <mpwd> win
11:11:20 <roconnor> Peaker: ya, by "theorem is true" I mean "statement of the theorem is true"
11:11:21 <roconnor> sorry
11:11:22 <Cale> You can form any finite group by taking group extensions to combine the finite simple groups it's built from.
11:11:23 <koeien1> Peaker: yes. (at least, "considered proven")
11:11:30 <roconnor> koeien1: yes, semi-direct.
11:11:32 <roconnor> I forgot that word
11:11:43 <Cale> But, at least as far as I know, the classification of group extensions isn't well-known.
11:11:45 <eugenn> @elite
11:11:45 <lambdabot> Say again?
11:11:46 <roconnor> Cale: is every group a semi-direct product of simple groups?
11:11:49 <rwx> a statement may or may not be true; you can have a proof to that effect, or not
11:11:52 <Cale> roconnor: no.
11:12:00 <roconnor> Cale: really?
11:12:05 <rwx> (disregarding undecidability)
11:12:08 <roconnor> what is the point of simple groups then?
11:12:10 <koeien1> roconnor: you mean finite group, certainly
11:12:18 <roconnor> er
11:12:18 <roconnor> right finite
11:12:22 <Cale> roconnor: Not much, unfortunately.
11:12:30 <drdozer> cabal: At least the following dependencies are missing: stb-image >=0.1.3 && <0.2 && ==0.2
11:12:34 <eugenn> @quote impossible
11:12:34 <drdozer> how would I debug this?
11:12:34 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
11:12:36 <tensorpudding> every you can do a jordan-holder series
11:12:47 <roconnor> Cale: can you give an example of such a group?
11:12:59 <tensorpudding> err, remove the every
11:13:01 <rwx> @quote strict
11:13:01 <lambdabot> vincenz says: strict evaluation is premature optimization
11:13:10 <Cale> We can put it this way: a group G is called an extension of groups K and H if there is an exact sequence 1 -> K -> G -> H -> 1
11:14:17 <Cale> That is, these arrows are homomorphisms such that the image of one is the kernel of the next.
11:14:52 <Cale> So the map K -> G must be a monomorphism because its kernel is the image of the map 1 -> K
11:15:11 <Cale> and the map G -> H must be an epimorphism because its image is the kernel of the map H -> 1
11:15:14 <koeien1> and G -> H is an surjective morphism, right? :)
11:15:18 <Cale> yeah
11:15:29 <drdozer> selecting stb-image-0.2 (installed or hackage) and discarding stb-image-0.1.3 <-- this is where it's getting in trouble
11:15:38 <mpwd> Peaker: "Considered proven" is typically a sociological thing - it means that the society of mathematicians have been convinced of the correctness of something, or more often have been lead to believe that other mathematicians have accepted the correctness of something.
11:16:24 <koeien1> mpwd: yes. mathematicians do this all the time. do you think mathematics is useless, or that we should strive for more formalism and computer-verified proofs?
11:16:26 <Saizan_> drdozer: can you paste the log of the commad you're running, adding -v, to hpaste?
11:16:53 <mpwd> Peaker: There's a sociologist named McKinsey who has been chronicling the rise of automated proof.  In the 90s, the British military actually intervened on a court case where someone what challenging whether a computer chip had been "proven" to perform correctly using automated proof techniques.
11:17:01 <Cale> If this happens, it means that K is isomorphic to a normal subgroup K* of G, and H is isomorphic to G/K*
11:17:11 <eugenn> @pl rew= f g (h i k) j s
11:17:11 <lambdabot> rew = f g (h i k) j s
11:17:34 <mpwd> koeien1: Well, I think people should do whatever they want with their lives.  But I hate myself every time I prove something with pencil and paper and I don't believe any of it anymore, honestly.
11:17:39 <eugenn> @pl rew a b = f g b (h a i k) j s
11:17:47 <lambdabot> rew = flip flip s . flip flip j . flip (f g) . flip (flip h i) k
11:17:49 <drdozer> Saizan_: http://www.pasteall.org/9334
11:18:09 <Cale> and so this means G has a normal series with quotients isomorphic to H and K
11:18:31 <mpwd> I don't really consider it proof at all when it's just pencil and paper.
11:18:48 <Cale> 1 <| K <| G
11:18:54 <Cale> Yeah?
11:19:02 <koeien1> <| = normal subgroup of?
11:19:05 <Cale> yeah
11:19:16 <fracture> mpwd: but despite the sociological component of mathematical proof, the standards of proof and required level of argument to convince is still higher than virtually any other domain of inquiry...
11:19:19 <Cale> (it's bad ascii art for a leftward pointing triangle)
11:19:21 <Peaker> mpwd, How did it get to a court?
11:19:30 <koeien1> Cale: guessed so, yes :)
11:19:44 <fracture> so if you throw that out of "things you believe", you need to throw out most empirical science too, no?
11:19:50 <Peaker> mpwd, what automated proof tools do you use?
11:20:20 <koeien1> ⊴ if you have unicode
11:20:22 <mpwd> Peaker: HOL-Light and Isabelle (HOL-Light is the best theoretically in my opinion but super-hard to use)
11:20:24 <Cale> So, it turns out that we can go the other way as well, and whenever we can form a normal series for G like that, we get a similar exact sequence.
11:20:42 <Cale> However, this isn't quite enough to get us that G is the semidirect product of K and H
11:21:03 <mpwd> Peaker: It didn't make it to court, the government intervened and declared that computer assisted proof is, well mathematical proof.  I forget some details - let me dig up the paper.
11:21:07 <koeien1> for that , the sequence must split?
11:21:15 <Cale> right
11:21:42 <Cale> There must be a homomorphism s: H -> G such that going from H to G by that, and then back to H will be the identity map.
11:22:12 <Cale> and there's a result that an extension is split if and only if G is a semidirect product of H and K.
11:22:18 <Peaker> mpwd, I have never used any automated proof thingies (and barely proved things on paper, too)
11:22:25 <eugenn> > map id [1..32]
11:22:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:23:08 <koeien1> but classification theorems are often very beautiful imo. it describes precisely all objects with a certain property
11:23:40 <mpwd> Peaker: Well, I have a newfound appreciation for actual engineers who know how to make stuff work... I wouldn't say that you are missing out on anything in the pencil and paper side of things.
11:24:02 <Cale> That's true.
11:25:01 <Cale> It's just that people have a tendency to describe simple groups as if they were the atoms from which groups are built. That my be true, but we have little idea of what the "bonds" look like in that case.
11:25:58 <koeien1> they are not prime numbers or root systems
11:26:16 <roconnor> Cale: interesting
11:26:27 <Cale> may*
11:26:38 <tensorpudding> the classification of FSG's is not really what i'd call beautiful
11:26:58 <koeien1> tensorpudding: the statement is somewhat messy, and the proof probably is, too (i have no idea)
11:27:00 <Saizan_> drdozer: i'm looking at lambdacube-engine.cabal and i don't get where the stb-image <0.2 constraint would come from
11:27:07 <tensorpudding> the sporadic groups are not really beautiful
11:27:11 <roconnor> Cale: I assumed the "bonds" were semi-direct products
11:27:19 <roconnor> apparenlty not
11:27:20 <roconnor> that's lame :)
11:27:33 <drdozer> Saizan_: I had to add it myself, as there is an API change in version 0.2 that breaks it
11:27:35 <tensorpudding> in the sense of having any obvious symmetries
11:27:39 <tensorpudding> or metasymmetries
11:27:48 <Cale> roconnor: I don't have a good example of a group which is not a semidirect product of simple groups. I could ask Robin, she probably knows one.
11:27:57 <roconnor> no that's okay
11:28:08 <roconnor> I glanced at the wikipedia page on the extension problem
11:28:11 <Peaker> mpwd, I read some about Epigram -- and absolutely loved it
11:28:17 <roconnor> which was enough to inform me that I don't know enough about this.
11:28:47 <Cale> Discrete structure is hard :(
11:28:50 <Peaker> mpwd, The facilitation of C.H in there for practical and elegant proofs blew me away
11:29:23 <Saizan_> drdozer: where did you add it?
11:29:24 <theclaw> kmc: thanks - I thikn I finally got it
11:29:57 <theclaw> kmc: so one can only pattern match with the right side of "data =" statement?
11:30:06 <Saizan_> drdozer: inside the tarball in ~/.cabal/packages/? that would surely confuse cabal-install :)
11:30:15 <drdozer> Saizan_ I used cabal to unpack -engine, and edited the cabal file to say <0.2 rather than <2
11:30:48 <drdozer> Saizan_: and then used cabal sdist to make a tarball that I copied into packages over the top of the old one
11:30:55 <drdozer> Saizan_: was that bad of me?
11:31:01 <Saizan_> drdozer: yup
11:31:17 <drdozer> ah, what /should/ I have done?
11:31:18 <Saizan_> drdozer: cabal has a separate index of .cabal files that's supposed to be in-sync with the packages
11:31:29 <Cale> I wish that environment variables somehow remembered who set them.
11:31:51 <Saizan_> drdozer: you could have just "cabal install lambdacube-engine --constraint="stb-image < 0.2"" in this case
11:32:11 <tensorpudding> lambdacube?
11:32:39 <drdozer> ah, rgr
11:32:49 <Saizan_> drdozer: or in general, if you unpack a package and edit it's .cabal file, you should also bump the version inside the .cabal file, and run "cabal install" from the same directory
11:33:08 <Saizan_> "cabal install" just finds a .cabal file in the current directory and installs it
11:33:08 <tensorpudding> ah, a 3d renderer, not the other lambda cube
11:33:23 <koeien1> theclaw: yes, more or less. you can pattern match on data constructors.
11:33:56 <koeien1> theclaw: this also includes the RHS of "newtype", if you have encountered this before. (if not, you can disregard it -- not very important at this stage)
11:34:10 <pastah_rhymez> Lemmih: hello, you there?
11:34:18 <drdozer> Saizan_: so where does cabal keep magic stuff? If I delete ~/.cabal will that get it all?
11:34:30 <pastah_rhymez> i have a question about the sdl bindings
11:35:00 <Saizan_> drdozer: you just need to delete your modified lambdacube-engine tarball now
11:35:32 <Saizan_> drdozer: deleting ~/.cabal would also delete all your user-installed packages
11:35:40 <theclaw> koeien1: yes, thanks
11:36:00 <EvanCarroll> f.g x is the same as f( g(x) ), then why doesn't `putStrLn . unlines $ ["foo","bar"]` work?
11:36:20 <EvanCarroll> but putStrLn $ unlines ["foo","bar"] does
11:36:21 <koeien1> EvanCarroll: it does?
11:36:28 <Saizan_> drdozer: the separate index is in ~/.cabal/packages/hackage.haskell.org/00-index.tar btw
11:36:29 <Peaker> EvanCarroll, f.g$x btw
11:36:42 <EvanCarroll> Peaker: that's what I did right?
11:36:44 <koeien1> EvanCarroll: i don't know, they should be the same.
11:36:45 <Peaker> @type unlines
11:36:46 <lambdabot> [String] -> String
11:37:01 <Peaker> @type putStrLn . unlines $ ["foo", "bar"]
11:37:02 <lambdabot> IO ()
11:37:07 <Peaker> EvanCarroll, that "works"
11:37:13 <Lemmih> pastah_rhymez: I am.
11:37:15 <Peaker> > lines "foo\nbar\n"
11:37:16 <lambdabot>   ["foo","bar"]
11:37:20 <Peaker> > unline . lines $ "foo\nbar\n"
11:37:21 <lambdabot>   Not in scope: `unline'
11:37:24 <Peaker> > unlines . lines $ "foo\nbar\n"
11:37:25 <lambdabot>   "foo\nbar\n"
11:37:45 <EvanCarroll> oh wait
11:37:48 <pastah_rhymez> Lemmih: i'm writing a little tetris clone for terminals
11:37:51 <EvanCarroll>  must have been doing this wrong
11:37:53 <EvanCarroll> it is working
11:38:07 <pastah_rhymez> but i want to be able to get multiple key inputs, so getChar is out :/
11:38:34 <drdozer> Saizan_: I think the .cabal surgery I did earlier has confused ghc-pkg
11:38:38 <pastah_rhymez> so i was thinking about sdl; is it possible to use the keyboard bindings in SDL for a program only running in a terminal?
11:39:28 <Lemmih> pastah_rhymez: I don't think so. You would probably be better off with ncurses.
11:39:44 <pastah_rhymez> Lemmih: yeah, that or VTY
11:39:45 <Saizan_> drdozer: really? what are the symptoms? (there's also "ghc-pkg check" that catches some problems)
11:40:03 <pastah_rhymez> Lemmih: could i use its sound bindings though?
11:40:35 <drdozer> Saizan_: Ah, manually ghc-pkg unregister'ing the affected libs is fixing it
11:40:49 <Lemmih> pastah_rhymez: You might.
11:44:10 <pastah_rhymez> Lemmih: maybe i should use alsa bindings instead :/
11:44:49 <Twey> The ALSA interface is kind of horrible… try OpenAL or something
11:45:07 <pastah_rhymez> Twey: thanks for the tip :)
11:45:19 <Twey> I believe you can use the SDL sound subsystem independently of its other subsystems, though
11:46:27 * Cale switches back to SCIM from iBus. Everything new in Ubuntu Karmic seems to suck.
11:47:31 <koeien1> what do you use SCIM for?
11:48:30 <Cale> 日本語で書く
11:48:30 <theclaw> I tried to do the an exercise from YAHT, but I'm stuck with an type error on the line "printFacs (numbers facNums)": http://paste.ubuntu.com/325567/
11:48:33 <theclaw> any hint?
11:48:39 <theclaw> *a type error
11:48:43 <triyo> Is there anything special I have to do to get Haskell platform to work on Snow Leopard?
11:48:53 <pastah_rhymez> Cale: Nihongo *lol* de *lol* ku?
11:49:06 <Twey> Cale: +こと
11:49:13 <Twey> Or ため, rather
11:49:23 <koeien1> my japanese is a bit rusty
11:49:33 <Cale> Twey: those would work, yeah :)
11:49:47 <Botje> theclaw: can you add the error you get?
11:49:52 <Twey> Cale: Nay, you need them
11:49:56 <Cale> Twey: I figured "(I) write in Japanese." wasn't bad on its own.
11:50:09 <Twey> Ah, I see what you mean
11:50:17 <Botje> theclaw: actually. i already see it.
11:50:18 <Twey> For that meaning, you should use んだ or something
11:50:19 <kmc> theclaw, printFacs takes two args
11:50:41 <kmc> you're calling it with one arg, the application (numbers facNums)
11:50:47 <kmc> and that application is invalid
11:50:48 <theclaw> kmc: MEH
11:50:57 <kmc> because numbers is [Int], not a function
11:51:17 <drdozer> Saizan_: Thanks for your help - I appear to have resurrected my system *and* got that library built
11:51:39 <Twey> Why do people always have to overdo shadow effects?
11:51:45 <theclaw> kmc: thanks a lot :)
11:51:56 <Cale> Twey: shadow effects?
11:52:02 <Twey> The ones on paste.ubuntu.com make my head spin
11:52:21 <Cale> heh
11:52:26 <Twey> Cale: Some newbie web designer has gone ‘OOH SHADOWS’ and stuck css-shadow everywhere
11:52:34 <Cale> That's a pretty heavy shadow for such light text.
11:52:36 <Twey> Yeah.
11:53:05 <Twey> Shadows need to be very close to the text and/or much closer to the background colour than to that of the text
11:54:18 <kmc> yeah that pastebin looks like a bag of smashed assholes
11:55:31 <theclaw> as long as there aren't shadow effects on the source it's fine IMO :)
11:55:39 <Twey> Ha
11:56:07 <Twey> Peeve #2: epiphany insists on viewing page source with wine's NOTEPAD.EXE.
11:57:06 <Cale> ahahaha
11:57:23 <Cale> I used to use epiphany until it started to suck too much.
11:57:26 <theclaw> Twey: epiphany on linux?
11:57:32 <Twey> Aye
11:57:33 <koeien1> this is ubuntu 9.10 ?
11:57:35 <Botje> when did epiphany ever not suck? :)
11:57:51 <Twey> Epiphany is small, fast, and doesn't freeze like Opera or crash like Firefox
11:57:57 <theclaw> hahaha
11:58:05 <theclaw> *try*
11:58:13 <kmc> that's hilarious
11:58:16 <theclaw> I can't quite believe that ;)
11:58:36 <theclaw> Twey: it uses gedit here
11:58:38 <koeien1> what rendering engine does it use?
11:58:42 <Cale> I wish that Google Chrome was more practical
11:58:43 <Twey> Webkit
11:58:51 <Cale> Eh?
11:58:53 <conal> Peaker: thanks for the Dijkstra paper (http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1012.PDF).  i haven't read it.  will soon.
11:58:58 <theclaw> Twey: maybe you set notepad.exe somewhere as your default?
11:59:00 <koeien1> Cale: the last time i tried it on linux it was not really useable. maybe in the future
11:59:01 <Twey> theclaw: I kid you not.  Firefox crashes if it sees Flash.  Opera likes to freeze up whilst loading pages.
11:59:06 <Twey> theclaw: I'm pretty sure I didn't.  :þ
11:59:15 <theclaw> Twey: it uses gedit on ubuntu 9.10 here:p
11:59:18 <Cale> Oh, I guess they switched. I thought it used Gecko.
11:59:23 <Twey> Yeah, it used to.
11:59:37 <Botje> Twey: use flashblock; be happy
11:59:46 <Cale> koeien1: It seems usable apart from the lack of AdBlock and various other essential things.
11:59:58 <Twey> Botje: Doesn't help — it just crashes as soon as I unblock something to look at it :þ
12:00:05 <Twey> Epiphany is definitely rather light on features
12:00:09 <Botje> don't look at flash, then!
12:00:15 <Twey> Botje: Problem solved!
12:00:22 <koeien1> Cale: on my system, it somehow insisted on using a proxy that i couldn't change
12:00:23 <Peaker> conal, seems to me to be making a distinction between denotational and operational semantics (apparently he made up his own name for denotational semantics)
12:00:23 <Botje> and it's semi-stable here
12:00:31 <Twey> Excuse me, I'm a bit hungry.  I think I'll go and cut out my stomach.
12:00:55 <conal> oh!  looking forward to it.
12:00:58 <roconnor> @free id
12:00:59 <lambdabot> f . id = id . f
12:01:32 <Polarina> @src id
12:01:32 <lambdabot> id x = x
12:01:37 <Polarina> Lame.
12:01:44 <koeien1> but useful!
12:01:46 <Polarina> Nope.
12:01:51 <koeien1> id is very useful
12:01:51 <roconnor> it should be id =
12:01:57 <Polarina> How so?
12:01:58 <roconnor> why the eta-expansion?
12:02:06 <koeien1> it is the identity w.r.t. (.)
12:02:14 <skorpan> id as at least as useful as 0 or 1
12:02:17 <skorpan> is at least*
12:02:23 <Polarina> Please explain.
12:02:28 <skorpan> 21:03 <koeien1> it is the identity w.r.t. (.)
12:02:30 <roconnor> as in foldr (.) id
12:02:38 <roconnor> @type foldr (.) id
12:02:39 <lambdabot> forall b. [b -> b] -> b -> b
12:02:49 <Polarina> Erm...
12:03:21 <conal> id is useful in the same way 0 is.  which the romans didn't realize either.
12:03:34 <Polarina> Ok...
12:03:35 <roconnor> granted I do prefer flip (foldr ($))
12:03:42 <Polarina> roconnor: ?
12:03:49 <Polarina> What's $?
12:03:51 <roconnor> @type flip (foldr ($))
12:03:52 <lambdabot> forall b. [b -> b] -> b -> b
12:04:00 <roconnor> @src ($)
12:04:01 <lambdabot> f $ x = f x
12:04:04 <roconnor> :D
12:04:08 <Polarina> o.O
12:04:09 <skorpan> $ has the lowest fixity
12:04:13 <skorpan> or whatever that stuff was called
12:04:18 <byorgey> Polarina: suppose you have a function which wibbles the result of applying some function to some foos.  Now what if you only want to wibble the foos directly?  what function will you pass it as an argument?
12:04:24 <roconnor> $ is function application
12:04:30 <roconnor> but at a different precidence level
12:04:39 <conal> i always wonder.  when someone says something isn't useful, do they really mean they don't yet know its usefulness?  or somehow that they know no usefulness can exist?
12:04:57 <Polarina> byorgey: I don't understand you question.
12:05:01 <roconnor> conal: usually they mean the latter while the former is the case.
12:05:18 <conal> roconnor: that's my guess also.
12:05:35 <byorgey> Polarina: sorry, just trying to give an example scenario in which id is useful --- in order to pass it as an argument to a higher-order function.
12:05:40 <Polarina> @type foldr
12:05:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:06:23 <Polarina> foldr (.) (\x <- x)
12:06:25 <roconnor> conal: I used to think that the theorem that every natural number number is the sum of four squares was a useless theorem.
12:06:45 <koeien1> roconnor: today we saw a practical application :P
12:06:47 <roconnor> conal: then I learned about Matiyasevich's solution to Hilbert's 10th problem
12:06:53 <koeien1> @quote four squares
12:06:53 <lambdabot> No quotes for this person.
12:06:57 <koeien1> @quote squares
12:06:57 <Polarina> I seriously cannot think of any scenario of which x is useful.
12:06:57 <lambdabot> <copumpkin> says: I love: Warning: Due to a known bug, the default Linux document viewer evince prints N*N copies of a PDF file when N copies requested. As a workaround, use Adobe Reader acroread
12:06:57 <lambdabot> for printing multiple copies of PDF documents, or use the fact that every natural number is a sum of at most four squares.
12:06:59 <byorgey> conal: I think there has to be something in between: "Given my knowledge and experience of the world, I believe that X is not useful/interesting."
12:07:13 <Polarina> s/x/id/
12:07:21 <roconnor> koeien1: what was the application today?
12:07:28 <koeien1> roconnor: see the quote :)
12:07:37 <conal> byorgey: still speaking on the basis of ignorance, not knowledge.
12:07:59 <roconnor> koeien1: :O
12:08:16 <conal> byorgey: more accurate might be:  "Given my ignorance and inexperience of the world, I don't yet believe that X is useful/interesting."
12:08:22 <Philonous1> @type (id &&& (+1) ) -- id is useful after all
12:08:23 <lambdabot> forall b. (Num b) => b -> (b, b)
12:08:33 <Polarina> What's &&&?
12:08:43 <Philonous1> @src (&&&)
12:08:43 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
12:08:48 <Polarina> Erm?
12:08:48 <skorpan> easy, just look at its type!
12:08:51 <skorpan> :t (&&&)
12:08:51 <Polarina> What's ***?
12:08:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:08:58 <skorpan> makes so much sense...!
12:09:03 <Polarina> Or * for that matter.
12:09:44 <Polarina> Or >>>, what's that?
12:09:46 <pastah_rhymez> Polarina: read 'a' in the type signature as "a function from"
12:09:55 <Polarina> pastah_rhymez: Huh?
12:10:03 <roconnor> > (head (***) succ) ("string",17)
12:10:04 <lambdabot>   Couldn't match expected type `[a]'
12:10:04 <lambdabot>         against inferred type `a1 b c ->...
12:10:12 <roconnor> ah ooops
12:10:13 <koeien1> why the ( ) ?
12:10:18 <roconnor> > (head (***) tail) "string"
12:10:19 <lambdabot>   Couldn't match expected type `[a]'
12:10:19 <lambdabot>         against inferred type `a1 b c ->...
12:10:19 <poe> anybody knows a precise date for the next GHC release?
12:10:28 <skorpan> poe: 2012
12:10:29 <drdozer> skorpan, it is in the spirit of combining a=f(x) and b=g(x) and producing (a,b)=c(x) where c is a &&& b
12:10:30 <pastah_rhymez> @type (***)
12:10:31 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:10:44 <Polarina> ...
12:10:46 <koeien1> > ( (+1) *** (*2) ) (1,2)
12:10:47 <lambdabot>   (2,4)
12:10:53 <roconnor> > (head *** succ) ("string",17)
12:10:53 <koeien1> > ( (+1) &&& (*2) ) 3
12:10:54 <lambdabot>   ('s',18)
12:10:54 <lambdabot>   (4,6)
12:11:00 <Philonous1> > (init &&& tail) "lambda"
12:11:01 <lambdabot>   ("lambd","ambda")
12:11:09 <poe> skorpan hehe trac says november
12:11:11 <skorpan> lambdambdambdambd
12:11:15 <pastah_rhymez> Polarina: ^^ as i said, when you read the type singature, read 'a' as "a function from" "to"
12:11:21 <Polarina> Philonous1: Oh, nice!
12:11:26 <conal> further, if someone else is investing their energy in a question, that's pretty strong evidence for me that the question is interesting & useful.  they demonstrating interest, and they're likely getting some use out of it.
12:11:39 <roconnor> @free id
12:11:40 <lambdabot> f . id = id . f
12:11:41 <koeien1> poe: check the glasgow-haskell-users mailing list by the post of SPJ
12:11:44 <Polarina> pastah_rhymez: I am having problems with just about everything you said.
12:11:45 <skorpan> what's @free?
12:11:54 <Heffalump> free theorem, I guess
12:11:58 <Philonous1> Polarina: Actually it's much more general than that. But you can use the Arrow instance of (->) for very concise syntax
12:12:09 <Polarina> Philonous1: The arrow what?
12:12:11 <roconnor> so this other guy says the free theorem for id says that forall R, R x y -> R (id x) (id y).
12:12:13 <pastah_rhymez> f :: (Arrow a) => a b c <--- this reads as "a funcion from b to c"
12:12:20 <roconnor> is that the same as lambdabot's free theorem?
12:12:51 <kmc> (b -> c)  is a specialization of ((Arrow a) => a b c)
12:13:21 <drdozer> where in that case, a is function application?
12:13:27 <Philonous1> Polarina: Arrows generalize functions just like Monads generalize return values. They have their own do-notation and you can use them to model networks. Pretty cool and powerful stuff really.
12:13:32 <kmc> (***) :: (b -> c) -> (b' -> c') -> ((b, b') -> (c, c'))
12:13:46 <Polarina> Philonous1: Erm, ok...
12:13:54 <kmc> (&&&) :: (b -> c) -> (b -> c') -> (b -> (c, c'))
12:13:57 <Polarina> If I knew what monads were. :(
12:13:59 <kmc> Polarina, are those types more comprehensible?
12:14:13 <Polarina> kmc: Yes.
12:14:33 <kmc> > (('x':) &&& ('y':)) "foo"
12:14:34 <lambdabot>   ("xfoo","yfoo")
12:15:04 <kmc> Polarina, did you learn about typeclasses?
12:15:15 <Polarina> kmc: I think I have, not sure.
12:16:59 <Philonous1> Polarina: Oh, I thought you knew about monads already. (They are partly what makes Haskell cool) Sorry then. The point really was that when you get to higher levels, seemingly pointless functions like id become useful.
12:17:16 <Polarina> Ok, thanks.
12:17:28 <kmc> Philonous1, though you can implement monads in many languages.  They're not a Haskell language feature, aside from some syntactic sugar
12:17:35 <Polarina> I'm still trying to find something on the internet that explain monads.
12:17:40 <Polarina> Never found anything.
12:18:00 <Draconx> there are about 50 bajillion monad tutorials.
12:18:17 <Philippa> Draconx: that's kinda the problem, they tend to fail at actually explaining
12:18:20 <Draconx> of varying levels of quality.
12:18:27 <kmc> Polarina, so you know typeclasses
12:18:30 <kmc> "Monad" is a typeclass
12:18:36 <Philonous1> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
12:18:36 <kmc> @src Monad
12:18:37 <lambdabot> class  Monad m  where
12:18:37 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:18:37 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:18:37 <lambdabot>     return      :: a -> m a
12:18:37 <lambdabot>     fail        :: String -> m a
12:18:54 <Polarina> kmc: Like Maybe?
12:18:57 <kmc> Polarina, no
12:18:58 <koeien1> no.
12:19:00 <kmc> Maybe is not a typeclass
12:19:02 <kmc> it's a type
12:19:05 <kmc> (actually, a type constructor)
12:19:07 <Botje> Polarina: wrestle with IO and state. one day the type errors will make sense, and you'll "get" monads.
12:19:07 <copumpkin> Maybe is an instance of Monad
12:19:09 <Polarina> What's a typeclass then?
12:19:12 <kmc> Polarina, you should read about typeclasses
12:19:13 <drdozer> @src Maybe
12:19:14 <lambdabot> data Maybe a = Nothing | Just a
12:19:14 <sproingie> forget about fail, and the three remaining functions are what makes a monad a monad
12:19:16 <kmc> they're super important
12:19:20 <Peaker> Are there examples of (>>) being implemented in specific instances for efficiency purposes?
12:19:38 <Peaker> I dislike default methods that are there for "efficiency"..
12:19:44 <kmc> Polarina, typeclasses are a good deal more fundamental than monads
12:19:50 <Philippa> Peaker: I'm pretty sure I've seen some
12:19:53 <kmc> because "Monad" is just one particular typeclass that lives in the standard library
12:19:56 <drdozer> Polarina: a typeclass is a bit like a Java interface - it says there are a load of functions guaranteed to be defined on some type
12:20:02 <copumpkin> Peaker: IIRC IO has a function waiting to be slotted in there, but they didn't put it in for some reason
12:20:03 <sproingie> oh yah you dont even need to know about >> really, so it's just two functions
12:20:04 <kmc> @src Eq
12:20:04 <lambdabot> class  Eq a  where
12:20:04 <lambdabot>     (==), (/=)   :: a -> a -> Bool
12:20:10 <Polarina> kmc: I am sure I've learnt about them, I just am unable to link the name to it.
12:20:23 <kmc> well, there's a keyword "class" that introduces a new typeclass
12:20:26 <Peaker> Philippa, I think its too arbitrary, pretty much every typeclass-restricted function can have optimized specialized implementations
12:20:32 <Philippa> Peaker: that, and one of the potential optimisations you can do with it is /very/ nice for parsing purposes - it allows you to pick up a form of context-insensitivity
12:20:33 <skorpan> i still don't understand what the big deal about monads is...  what is it?
12:20:39 <kmc> and a keyword "instance" which declares that a given type is a member of a given class
12:20:39 <Peaker> Philippa, I don't think default type-class methods are the correct/general way to solve this optimization problem
12:20:53 <Polarina> kmc: Ok, I haven't learnt about it.
12:20:58 <kmc> Polarina, start there
12:21:04 <Polarina> Ok. :)
12:21:15 <kmc> learn about Eq, Ord, Show, and friends
12:21:19 <Peaker> Philippa, btw, I know that Applicative came later, but if you have it, you can have the efficient implementation of (>>) in Applicative's <*> instead (If the efficiency stems from the fact the effects are pre-determined)
12:21:24 <Polarina> kmc: I know those three.
12:21:27 <Philippa> Peaker: they beat having to reimplement for every instance, though
12:21:28 <sproingie> skorpan: sequencing is one of the big deals.  unlike imperative languages, haskell doesn't really have a built-in notion of control flow
12:21:35 <kmc> Polarina, well, they're typeclasses
12:21:46 <kmc> Could you define your own typeclass and add some instances to it?
12:21:48 <sproingie> skorpan: >>= provides a polymorphic way of saying "do the next thing"
12:21:55 <Peaker> Philippa, what about having (>>) as a simple function, not a method, and then using rewrite rules for optimized implementations of (>>) ?
12:21:58 <Polarina> kmc: No, I could not.
12:22:00 <drdozer> Polarin: so you can say show "bob" and show 21 and show (Maybe 2.3)
12:22:01 <sproingie> skorpan: not all monads are about sequencing, but a lot are
12:22:13 <Philippa> Peaker: amongst other things, not portable
12:22:19 <Twey> Well, they're about ‘sequencing’
12:22:24 <skorpan> sproingie: what about applicative?  can applicative express sequencing?
12:22:34 <skorpan> well,  <*> is exactly that, isn't it?
12:22:38 <Twey> Whether the result of that ‘sequencing’ is actually sequential is up to the monad
12:22:47 <drdozer> Polarin: so this makes it look as if show :: a -> String
12:22:49 <Philippa> sure, in a sufficiently powerful environment we don't need defaulting baked into the core language because we can generate it all on-demand and implement our own defaulting mechanism...
12:22:52 <sproingie> skorpan: yes.  in fact applicatives can express most of what monads currently do
12:23:10 <Polarina> drdozer: Ah.
12:23:14 <drdozer> Polarin: but we need to chose a particular implementation of show for each a - it is different for String or Int or whatever
12:23:28 <sproingie> skorpan: where monads come in handy is with inescapable ones like IO and ST
12:23:32 <skorpan> i just get the feeling now that i understand more about haskell in general that "monads" has become haskell's PR guy
12:23:35 <Peaker> Philippa, well, there's the Ord-style use of defaulting, which is nicer IMO
12:23:37 <skorpan> sproingie: indeed
12:23:46 <sproingie> well ST is kinda escapable, just not totally
12:23:52 <ben0x539> With the Haskell logo being >>=...
12:24:05 <sproingie> haskell didn't always use monads for IO
12:24:07 <koeien1> monads are useful if you want new computations to depend on previous results
12:24:12 <koeien1> an "if", more or less
12:24:14 <skorpan> ben0x539: right
12:24:29 <sproingie> it really fell in love with monads in 1.4 with monad comprehensions
12:24:35 <Peaker> skorpan, Applicative can express sequencing, yeah, but between pre-determined "effects". Monads can express sequencing between effects that are themselves generated by effects
12:24:38 <drdozer> Polarin: So classes are how you tell Haskell that the code for a function is going to depend upon the types of one or more of the arguments
12:25:17 <skorpan> has anyone ever made a serious attempt at replacing the "return" function name by something else?
12:25:28 <mercury^> skorpan: pure
12:25:32 <sproingie> there's 'pure'
12:25:35 <tensorpudding> @src foldr
12:25:35 <lambdabot> foldr f z []     = z
12:25:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:25:40 <Peaker> skorpan, Applicative doesn't need to "unwrap" the container to figure out which containers to sequence together, while Monad does
12:25:40 <skorpan> i can use pure today?
12:25:51 <sproingie> unless the monad hierarchy gets fixed, i doubt it'll ever change in monads
12:25:54 <mercury^> skorpan: yes.
12:25:57 <Peaker> skorpan, For well-behaving Monad instances, yeah (they should have an Applicative instance too)
12:26:14 <sproingie> skorpan: if you're using applicatives, yes, but monad doesn't inherit applicative
12:26:23 <skorpan> i see
12:26:28 <skorpan> > pure 3 :: Maybe Int
12:26:29 <lambdabot>   Just 3
12:26:38 <sproingie> tho nice monads implement it anyway
12:26:41 <Polarina> > pure 3
12:26:41 <lambdabot>   No instance for (GHC.Show.Show (f t))
12:26:42 <lambdabot>    arising from a use of `M8149093976...
12:26:46 <Polarina> > Just 3
12:26:47 <lambdabot>   Just 3
12:26:53 <Polarina> Much simpler than 'pure'!
12:27:02 <sproingie> not very polymorphioc
12:27:08 <kmc> > Just 3 :: [Int]
12:27:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
12:27:09 <lambdabot>         against inferred typ...
12:27:11 <sproingie> -o
12:27:11 <kmc> > pure 3 :: [Int]
12:27:12 <lambdabot>   [3]
12:27:17 <Polarina> WTH?
12:27:25 <kmc> @type Just
12:27:26 <lambdabot> forall a. a -> Maybe a
12:27:27 <kmc> @type pure
12:27:28 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
12:27:29 <sproingie> > pure 3 :: State Int Int
12:27:30 <lambdabot>   No instance for (Control.Applicative.Applicative
12:27:30 <lambdabot>                     (Contr...
12:27:31 <Polarina> pure 3 :: String
12:27:38 <Polarina> > pure 3 :: String
12:27:39 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
12:27:39 <lambdabot>    arising from the literal `3...
12:27:40 <sproingie> fooey
12:27:40 <kmc> > pure 'x' :: String
12:27:41 <lambdabot>   "x"
12:27:49 <sproingie> oh duh state is a function :p
12:27:50 <Polarina> Lame.
12:27:55 <Philonous1> skorpan: To illustrate the difference in power between monads and applicatives consider that a parser library that uses an applicative interface can parse context free, a monadic one can parse context-sensitive grammers.
12:28:34 <skorpan> Philonous1: exactly what does that mean in layman terms?
12:28:49 <Polarina> skorpan: If I could understand it, so can you. :)
12:29:00 <Heffalump> what kind of layman, one that knows about grammars?
12:29:00 <skorpan> Polarina: understand what?
12:29:09 <Polarina> skorpan: (08:28:52 PM) Philonous1: skorpan: To illustrate the difference in power between monads and applicatives consider that a parser library that uses an applicative interface can parse context free, a monadic one can parse context-sensitive grammers.
12:29:19 <skorpan> Heffalump: one who never really paid that much attention in school :P
12:29:25 <Philippa> skorpan: it means that what's recognised can depend on what's already been recognised. For example, a parser than only lets you use names you've already declared
12:29:34 <skorpan> Polarina: uh-huh, but i'm talking context-free vs. context-sensitive
12:29:39 <sproingie> i think the actual question being asked was "how so?"
12:29:45 <Polarina> skorpan: Self-explaining...
12:29:49 <skorpan> Philippa: i see, so it's basically what it sounds like
12:30:09 <skorpan> Polarina: i don't think you're in a position to tell me what is obvious and what is not :)
12:30:17 <sproingie> let's be nice
12:30:22 <Polarina> skorpan: Ok. :)
12:30:34 <Cale> Oh, nice, Google Chrome has a proper implementation of AdBlock+ which uses the same lists of blocking rules.
12:30:46 <sproingie> no kidding
12:30:53 <sproingie> now i just need noscript and i'm all set
12:31:37 <poe> Cale wonderful
12:32:01 <roconnor> with monads you can write mIf a b c = do { x <- a; if x then b else c }
12:32:08 <roconnor> can't do that with applicative functors
12:32:32 <stroan> hmm, is anyone else having trouble with terminfo-0.3.1.1 ? it won't install here, which means no darcs
12:32:39 <Philippa> Cale: that's interesting considering where all their money comes from
12:33:09 <Cale> Philippa: Well, it's not built in, it's an extension someone wrote.
12:33:09 <Heffalump> presumably they want to block everyone else's ads :-)
12:33:17 <Philonous1> Philippa: Firefox is google-sponsored, too.
12:33:20 <sproingie> roconnor: i suspect you could laboriously simulate it
12:33:23 <skorpan> Cale: there are extensions now?
12:33:27 <Philippa> Cale: ah
12:33:34 <Cale> Philippa: But even so, yeah, AdBlock usually doesn't actually block google ads, so it eliminates their competition :)
12:33:45 <Cale> skorpan: Yeah.
12:33:55 <sproingie> adblock usually blocks doubleclick which google owns
12:33:59 <Cale> skorpan: In the Linux/development version anyway.
12:34:00 <skorpan> do you code them in "GO"? :P
12:34:12 <roconnor> sproingie: I don't think so.
12:34:27 <sproingie> huh.  they end up being the first ones i block
12:35:06 <sproingie> i don't even get the big filtersets and i let most ads through, but inevitably there's some scumbag ad i can't stand on the doubleclick network
12:37:02 <jl_2> is there a rule forbidding examples in the official haskell documentation?
12:37:06 <rdeshpande> hi all
12:37:18 <jl_2> or, ghc documentation, at least?
12:37:33 <rdeshpande> what exactly does the 'const' function do? i'm trying to look through docs but hoogle says 'constant function'. i see it has a type a -> b -> a, but not sure what the intent of the function is?
12:37:45 <roconnor> > const 6 7
12:37:46 <lambdabot>   6
12:37:46 <visualbasicgui> Hey guys. Got a question about ghc. Does the source file containing my Main module and main function have to be "Main.hs"? Because it seems as though the rule is that a file with "module Name..." must be "Name.hs"
12:37:49 <ben0x539> rdeshpande: It ignores its first argument.
12:37:51 <visualbasicgui> is Main the exception?
12:37:53 <roconnor> > const 6 "apple"
12:37:54 <ben0x539> Then it returns the second.
12:37:54 <lambdabot>   6
12:38:01 <poe> ben0x539 the other way around
12:38:06 <ben0x539> well... yeah.
12:38:13 <roconnor> rdeshpande: generally it is used as a parameter to a higher order function
12:38:28 <roconnor> > map (const 3) "rdeshpande|
12:38:29 <lambdabot>   <no location info>:
12:38:29 <lambdabot>      lexical error in string/character literal at end o...
12:38:29 <ben0x539> Basically it is when you are too lazy to write \ _ -> 42, you just write const 42
12:38:33 <roconnor> > map (const 3) "rdeshpande"
12:38:34 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
12:38:39 <IceDane> If I have a list, how would I go about splitting it into n lists where each list holds every nth element from the original list?
12:39:11 <visualbasicgui> > const 1 2
12:39:12 <lambdabot>   1
12:39:17 <rdeshpande> roconnor: but what is the use of such a function? why not just pass in the single argument if you are goign to ignore it anyway
12:39:23 <ben0x539> > const 2 undefined
12:39:30 <poe> > unfoldr (\xs -> if null xs then Nothing else Just ([head xs], tail xs)) [1..]
12:39:31 <lambdabot>   2
12:39:33 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
12:39:34 <roconnor> rdeshpande: see my map example
12:39:37 <roconnor> > map (const 3) "rdeshpande"
12:39:38 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
12:39:52 <ben0x539> rdeshpande: You pass the result of 'const something' to another function that wants to give you an argument, in the case that you do not care for the argument
12:40:04 <poe> IceDane quite a strange thing to do anyway (:
12:40:10 * hackagebot upload: filestore 0.3.3.1 - Interface for versioning file stores. (JohnMacFarlane)
12:40:24 <visualbasicgui> Can anybody answer me on the ghc question?
12:40:32 <visualbasicgui> Does the file containing the Main module have to be Main.hs?
12:40:38 <ben0x539> no
12:40:38 <jl_2> no
12:40:46 <visualbasicgui> Because elsewhere the rules is a file containing module X must be X.hs
12:40:50 <IceDane> poe: WHy ? :P
12:40:53 <visualbasicgui> alright, so Main is the exception
12:40:55 <jl_2> yeah, but main is different
12:40:58 <jl_2> I guess
12:40:59 <visualbasicgui> okay thank you
12:41:05 <sproingie> const is like a functional version of fst
12:41:05 <copumpkin> it doesn't enforce the file name
12:41:08 <rdeshpande> ok, im starting to understand, but still hazy
12:41:13 <Polarina> > [1..]
12:41:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:41:20 <visualbasicgui> copumpkin: aah
12:41:26 <copumpkin> ever
12:41:34 <visualbasicgui> Polarina: !!! I always wanted to try that
12:41:36 <poe> rdeshpande a -> b -> a is a -> (b -> a)
12:41:46 <visualbasicgui> Polarina: but i was afraid it would explode the channel
12:42:02 <visualbasicgui> copumpkin: wait, so the filename is never enforced???
12:42:09 <Polarina> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
12:42:10 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:42:13 <ben0x539> > const 42 `map` [1..]
12:42:14 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
12:42:37 <visualbasicgui> copumpkin: That's strange because I was encountering an error the other day when a module and its file were not named identically
12:42:38 <poe> rdeshpande and then fer every type a, for every value x :: a, the type of const says that  const x :: b -> a  is the function that ignores its argument.
12:42:57 <sproingie> visualbasicgui: ghc --make does assume the filenames match the module names.  if they don't, it can still work but you have to do more work
12:42:59 <copumpkin> visualbasicgui: it uses the filename to know where to look for external modules, but on individual modules it doens't care
12:43:15 <sproingie> ghci pretty much demands they match up when it loads modules
12:43:26 <zachk> > not (5==6)
12:43:26 <lambdabot>   True
12:43:38 <sproingie> except for ones you load yourself with :load
12:43:42 <zachk> whats the operator for not == in haskell, i forget what it is
12:43:43 <EnglishGent> hello :)
12:43:48 <zachk> hi englishgent
12:43:51 <Twey> zachk: /=
12:43:54 <Twey> Think ≠
12:43:58 <zachk> ty twey
12:44:02 <Polarina> Twey: Why not =/= ?
12:44:05 <Twey> (that's probably in the Unicode Prelude)
12:44:09 <Twey> Polarina: Because.
12:44:14 <visualbasicgui> zachk: /= (it's meant to mimic the look of the mathematical notation)
12:44:29 <visualbasicgui> zachk: sort of like \ for lambda. You have to squint. Hard.
12:44:34 <blackh> What ho EnglishGent!
12:44:49 <EnglishGent> hello blackh :)
12:45:06 <monochrom> /= and == have the same length, great for alignment.
12:45:15 <visualbasicgui> EnglishGent: Wot wot old chap old bean i do say by george good chap
12:45:26 <copumpkin>  monochromas opposed to != and ==?
12:45:36 <jfredett> copumpkin: or <> and == :)
12:45:36 <visualbasicgui> EnglishGent: *sigh* now that I've gotten that out of my system we can go on as we were.
12:45:42 <Twey> copumpkin: No, as opposed to =/= and ==
12:45:47 <monochrom> I don't oppose. I agree with 0!=1.
12:45:51 <copumpkin> Twey: did you get the @tell?
12:45:57 <Twey> copumpkin: Yes :þ  Thanks
12:46:03 <copumpkin> no problem!
12:46:27 <visualbasicgui> > let scramble = (unwords . concat . transpose . splitEvery 2 . words)
12:46:28 <lambdabot>   not an expression: `let scramble = (unwords . concat . transpose . splitEve...
12:46:49 <copumpkin> fujisan came in here and told us about how he got banned, and then all of a sudden started going on about how you were a racist
12:46:51 <visualbasicgui> let splitEvery _ []   = []
12:46:58 <visualbasicgui> > splitEvery _ []   = []
12:46:59 <lambdabot>   <no location info>: parse error on input `='
12:47:01 <copumpkin> it didn't really follow since it doesn't appear that you banned him
12:47:09 <visualbasicgui> AAH nevermind
12:47:19 <sproingie> didn't know "asshole" was a race
12:47:20 <visualbasicgui> :( it does a funny thing.
12:49:18 <smiler> How do one configure which plugins to load in lambdabot?
12:52:40 <eugenn> @quote anyone
12:52:41 <lambdabot> AshleyYakeley says: If anyone gives you any lip, ask them how to find the square-root of a string. Everything else follows on from that.
12:52:52 <leimy> @quote dons
12:52:52 <lambdabot> dons says: the result: pretty things.
12:52:57 <leimy> @quote leimy
12:52:58 <lambdabot> No quotes match. My brain just exploded
12:53:01 <leimy> yay!
12:53:44 <Twey> @quote Twey
12:53:44 <lambdabot> Twey says: <idnar> O(1) is a lie anyway <Twey> I just can't stand the constant lies!
12:53:49 <Twey> Argh
12:54:00 * Twey didn't say that.  It's a lie!  >.>
12:54:15 <idnar> haha
12:54:25 <eugenn> I just put the haskell logo as my msn picture
12:54:37 <smiler> @help
12:54:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:54:41 <Botje> 08:59 < Twey> I just can't stand the constant lies!
12:54:45 <smiler> @list
12:54:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:54:53 <Twey> @quote Twey
12:54:53 <lambdabot> Twey says: Tuple tipple — alcohol made from fermented pairs
12:54:56 <eugenn> @help quote
12:54:56 <lambdabot> quote <nick>
12:54:57 <lambdabot> remember <nick> <quote>
12:54:57 <lambdabot> Quote somebody, a random person, or save a memorable quote
12:55:00 <Twey> Oh, that's a better one
12:55:12 <Twey> They can at least be *good* puns :þ
12:55:39 <sproingie> @quote oleg
12:55:39 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
12:55:40 <eugenn> @help pl
12:55:41 <lambdabot> pointless <expr>. Play with pointfree code.
12:56:04 <eugenn> @quote eugenn
12:56:04 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:56:24 <eugenn> @quote adamant
12:56:25 <lambdabot> No quotes match. My pet ferret can type better than you!
12:56:55 <Adamant> I definitely don't belong in a quote spree with Oleg
12:57:24 <Twey> Haha
12:57:27 <eugenn> all the nicks in the right column are the connected ones?
12:57:42 <skorpan> yes....
12:58:15 <skorpan> @elite
12:58:15 <lambdabot> Say again?
12:58:18 <skorpan> @elite what
12:58:19 <lambdabot> \/\/|-|at
12:58:28 <eugenn> @elite lambda
12:58:29 <lambdabot> L4/\/\Bda
12:58:47 <skorpan> @elite =<< @pl \a b c d e f g h i j k l m -> m l k j i h g f e d c b a
12:58:47 <lambdabot> =<< @pL \a 8 C D 3 F 9 |-| i J x l M -> m l k J I H g ph E d ( B A
12:58:55 <skorpan> would be cool if that worked
12:59:07 <copumpkin> it can
12:59:17 <skorpan> how?
12:59:23 <copumpkin> @@ @elite @pl \a b c d e f g h i j k l m -> m l k j i h g f e d c b a
12:59:27 <lambdabot>  fLip (fLip . (phLIp .) . ((FLiP .) .) . (((FliP .) .) .) . ((((F1Ip .) .) .) .) . (((((phlip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((ph|iP .) .) .) .) .) .) .) . ((((((((phlIp .) .) .
12:59:27 <lambdabot> ) .) .) .) .) .) . (((((((((F1iP .) .) .) .) .) .) .) .) .) . ((((((((((flIp .) .) .) .) .) .) .) .) .) .) . F1ip (f1ip . (FlIP .) . ((f1ip .) .) . (((F1iP .) .) .) . ((((ph1Ip .) .) .) .) . (((((F|
12:59:27 <lambdabot> Ip .) .) .) .) .) . ((((((Flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((phlIP .) .) .) .) .) .) .) .) . (((((((((phLIP .) .) .) .) .) .) .) .) .) . phlIp (FLIP . (ph|Ip .) . ((
12:59:27 <lambdabot> FLIp .) .) . (((FlIp .) .) .) . ((((FLIp .) .) .) .) . (((((f1Ip .) .) .) .) .) . ((((((fLIP .) .) .) .) .) .) . (((((((ph1iP .) .) .) .) .) .) .) . ((((((((Flip .) .) .) .) .) .) .) .) . flIP (f|iP
12:59:29 <lambdabot> . (phliP .) . ((F|ip .) .) . (((FlIp .) .) .) . ((((phliP .) .) .) .) . (((((F1Ip .) .) .) .) .) . ((((((F|IP .) .) .) .) .) .) . (((((((F|Ip .) .) .) .) .) .) .) . ph1ip (FlIp . (ph|Ip .) . ((phLIp
12:59:32 <lambdabot> [3 @more lines]
12:59:34 <skorpan> sorry dude, ... haha
12:59:35 <eugenn> hahahaha awesome
12:59:37 <aavogt> @more
12:59:37 <lambdabot> .) .) . (((ph1Ip .) .) .) . ((((FlIp .) .) .) .) . (((((F1ip .) .) .) .) .) . ((((((FLIp .) .) .) .) .) .) . phLIP (f|IP . (ph|IP .) . ((ph1ip .) .) . (((phlIP .) .) .) . ((((F|Ip .) .) .) .) . (((((
12:59:37 <lambdabot> F1ip .) .) .) .) .) . F1ip (ph|IP . (F1iP .) . ((flip .) .) . (((phlIP .) .) .) . ((((F1Ip .) .) .) .) . F|Ip (FLiP . (f1Ip .) . ((f1ip .) .) . (((f|Ip .) .) .) . F1ip (ph1iP . (phlIp .) . ((phliP .)
12:59:40 <lambdabot>  .) . Flip (ph1IP . (f1Ip .) . fLIp (ph|iP . ph1iP id))))))))))) oPTImIsA+ioN SUspENDeD, UzE @p|-R35uM3 To COn7InUE.
12:59:53 <Botje> MY EYES
13:00:04 <Botje> ZE GOGGLES, ZEY ARE ID!
13:00:05 <Polarina> What the hell?
13:00:20 <eugenn> I applaud you
13:00:21 <skorpan> Polarina: this is a demonstration of how useful pointlessness is
13:00:27 <Polarina> skorpan: I see.
13:00:28 <eugenn> hahaha
13:01:04 <holmak> has lambdabot lost its mind?
13:01:06 <aavogt> @pl-resume?
13:01:13 <lambdabot> flip (flip . ((flip . (flip .)) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .)
13:01:13 <lambdabot>  .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .)
13:01:13 <lambdabot> .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (
13:01:13 <lambdabot> ((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((
13:01:15 <lambdabot> flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .
13:01:18 <lambdabot> [3 @more lines]
13:01:22 <lambdabot> optimization suspended, use @pl-resume to continue.
13:01:24 <aavogt> sorry ;)
13:01:34 <EnglishGent> holmak - probably not - it's almost certainly due to human error
13:01:40 <eugenn> how come there are so many people connected and so little chat?
13:01:48 <EnglishGent> this sort of thing has happened before - and it has always been due to human error
13:01:48 <EnglishGent> :)
13:01:51 <Twey> Hooooly crap
13:01:55 <Twey> @help elide
13:01:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:02:03 <EnglishGent> hi Twey :)
13:02:05 <skorpan> i think this is the third time i trigger such chaos with @pl
13:02:06 <Twey> Oh, right
13:02:09 <Twey> Hey, EnglishGent ☺
13:02:09 <eugenn> @help elite
13:02:10 <lambdabot> elite <phrase>. Translate English to elitespeak
13:02:15 <holmak> @help pl
13:02:15 <lambdabot> pointless <expr>. Play with pointfree code.
13:02:23 <holmak> i see what you did there
13:02:46 <aavogt> @help @
13:02:47 <lambdabot>  @ [args].
13:02:47 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
13:02:47 <lambdabot>  The commands are right associative.
13:02:47 <lambdabot>  For example:    @ @pl @undo code
13:02:47 <lambdabot>  is the same as: @ (@pl (@undo code))
13:02:47 <skorpan> wait a minute... that's a bug in lambdabot.  he didn't leet the rest of the result!
13:02:59 <Twey> Arguably
13:03:05 <aavogt> I don't think so
13:03:14 <Twey> @pl-resume is a separate command
13:03:16 <copumpkin> not a bug
13:03:18 <eugenn> @elite [1..20]
13:03:28 <copumpkin> you should @@ @elite @pl-resume
13:03:31 <skorpan> well, i'd expect him to leet the whole thing
13:03:32 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .)
13:03:34 <Twey> Aye
13:03:35 <lambdabot> Plugin `pl' failed with: thread killed
13:03:37 <lambdabot> [1..20]
13:04:01 <aavogt> so @pl is still a DoS vulnerability?
13:04:07 <eugenn> @@ @elite >[1..20]
13:04:08 <lambdabot>  >[1..20]
13:04:28 <Heffalump> aavogt: not really, given that it does kill threads
13:04:36 <aavogt> @@ @elite @run ['a'..'z']
13:04:37 <lambdabot>  "4b(dEF9hIjK1mNoPqrS+uvWXyZ"
13:04:49 <Heffalump> > length [1..]
13:04:53 <lambdabot>   mueval-core: Time limit exceeded
13:04:56 <chrisdone> data Boo_ = Boo Int Char; type Boo a = Boo -- can I do this so that I can define a Functor instance?
13:05:08 <chrisdone> er, type Boo a = Boo_
13:05:19 <chrisdone> actually newtype
13:05:21 * junmin finished the implementation of tabu search in Haskell, thank all guys who helped him
13:05:28 <chrisdone> data Boo_ = Boo Int Char; newtype Boo a = Boo_
13:05:29 <koeien1> wouldn't be a useful instance, even if you could
13:05:31 <ddarius> chrisdone: With a newtype, yes.
13:05:36 <chrisdone> koeien1: why?
13:05:40 <chrisdone> ddarius: ah nice one
13:05:40 <ddarius> You need a constructor in the newtype.
13:05:43 <skorpan> chrisdone: you need a constructor
13:05:49 <chrisdone> right
13:06:07 <aavogt> well only the phantom type gets modified when you fmap
13:06:53 <eugenn> @elite "I love lambdas"
13:06:54 <lambdabot> "I Lo\/3 L4mBDA$"
13:07:12 <poe> @@ (@run (@elite ['a'..'z']) == (@elite ['a'..'z']))
13:07:13 <lambdabot>   True
13:07:38 <poe> argh, lucky :)
13:07:41 <eugenn> good one poe
13:07:55 <poe> (not referentially transparent)
13:08:14 <Twey> Truly
13:08:19 <Twey> Perhaps it's shared?
13:08:23 <poe> @@ (@run (@elite ['a'..'z']) == (@elite ['a'..'z']))
13:08:24 <lambdabot>   False
13:08:30 <Twey> Maybe not
13:08:39 <chrisdone> haha, convinced by one case
13:08:43 <chrisdone> scientist!
13:09:01 <eugenn> how come now is false??
13:09:09 <poe> russian roulette!
13:09:31 <eugenn> oh, elite must not be referentially transparent
13:09:39 <krainbolt> FOR SCIENCE!
13:09:53 <Twey> eugenn: Yeah, it applies random transformations
13:10:01 <Twey> @elite "I love lambdas"
13:10:01 <lambdabot> "I love L4MBdaS"
13:10:06 <Twey> @elite "I love lambdas"
13:10:06 <lambdabot> "I loVe |ambDas"
13:10:08 <eugenn> oh hehe
13:11:57 <eugenn> @help dice
13:11:58 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
13:13:07 <eugenn> @dice 48
13:13:08 <lambdabot> 48 => 48
13:14:28 <roconnor> @dice 1d48
13:14:28 <lambdabot> 1d48 => 42
13:14:39 <roconnor> @dice 1d48 - 24
13:14:39 <lambdabot> unexpected "-": expecting digit, "+" or end
13:14:45 <mauke> @dice 48d1
13:14:45 <lambdabot> 48d1 => 48
13:14:48 <roconnor> @dice 1d48  + (-24)
13:14:48 <lambdabot> unexpected "(": expecting number
13:14:54 <roconnor> @dice 1d48  + -24
13:14:54 <lambdabot> unexpected "-": expecting number
13:15:18 <eugenn> @dice 2d10
13:15:18 <lambdabot> 2d10 => 15
13:16:40 <eugenn> > iterate 10
13:16:41 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
13:16:41 <lambdabot>    arising from the literal `10' at ...
13:16:44 <mauke> preflex: karma eugenn
13:16:45 <preflex>  eugenn has no karma
13:17:09 <eugenn> preflex: karma mauke
13:17:10 <preflex>  mauke: 168
13:17:18 <koeien1> mauke++
13:17:30 <eugenn> how do you gain karma?
13:17:50 <mauke> preflex: karma mauke
13:17:51 <preflex>  mauke: 169
13:17:53 <mauke> like this
13:17:57 <eugenn> ooh
13:18:35 <mauke> @time eugenn
13:18:37 <lambdabot> Local time for eugenn is Sun Nov 22 18:19:32 2009
13:18:47 <eugenn> @time mauke
13:18:49 <lambdabot> Local time for mauke is 25:12:62 AM
13:19:06 <eugenn> 25 hours??
13:19:19 <copumpkin> lol
13:19:25 <copumpkin> preflex: 6st 25
13:19:27 <preflex>  25th
13:19:31 <copumpkin> damn
13:19:38 <krainbolt> Yay dice game.
13:19:53 <mauke> @time
13:19:56 <lambdabot> Local time for mauke is ablinking if you're using irssia
13:20:09 <copumpkin> lol
13:20:09 <Elly> :P
13:20:11 <andrewsw> argh my eyes!!
13:20:14 <Elly> other clients support that too
13:20:15 <endojelly> great %)
13:20:59 <eugenn> @karma _Jedai_
13:21:00 <lambdabot> _Jedai_ has a karma of 0
13:21:20 <mauke> preflex: nickr _Jedai_
13:21:21 <preflex>  Jedaj_
13:21:37 <eugenn> @time lambdabot
13:21:37 <lambdabot> I live on the internet, do you expect me to have a local time?
13:21:43 <eugenn> hahahaha
13:22:36 <Rayne> hilarious :)
13:22:56 <koeien1> @time koeien1
13:24:42 <Botje> mauke: my text isn't blinking.. I WANT MY MONEY BACK!
13:25:32 <mauke> does cbold textc work?
13:25:48 <Botje> yes.
13:25:55 <mauke> I blame your terminal
13:26:53 <Jedai> karma Jedai
13:27:02 <Jedai> @karma Jedai
13:27:02 <lambdabot> You have a karma of 0
13:27:23 <mauke> preflex: karma Jedai
13:27:24 <preflex>  Jedai has no karma
13:27:26 <mauke> it's true!
13:28:14 <Jedai> Well at least I'm a blank slate
13:28:22 <koeien1> Jedai--
13:28:33 <koeien1> @karma Jedai
13:28:33 <lambdabot> Jedai has a karma of -1
13:28:38 <koeien1> Jedai++
13:28:39 <Jedai> And.... not anymore ! ;)
13:28:50 <Raynes> Rayne: Imposter!
13:28:57 <Rayne> \o/
13:29:16 <Rayne> u r me?
13:29:29 <Raynes> Every time you say something, my highlighter goes off. :|
13:29:45 <Raynes> So you're the guy who has registered the name Rayne. :<
13:29:52 <Rayne> long time ago :)
13:29:59 <Raynes> v_v
13:30:42 <Rayne> i never said a word since i join haskell till  today! *lightning flashes*
13:31:02 <Raynes> :o
13:33:41 <Raynes> @src (||)
13:33:42 <lambdabot> True  || _ =  True
13:33:42 <lambdabot> False || x =  x
13:34:58 <Cale> http://hackage.haskell.org/packages/archive/acme-dont/1.1/doc/html/Acme-Dont.html
13:47:15 <Twey> Is there an extension to bring monad comprehensions back to GHC?
13:47:45 <Rayne> is _ equal to otherwise?
13:47:56 <monochrom> No. otherwise is equal to True
13:48:06 <monochrom> @src otherwise
13:48:06 <lambdabot> otherwise = True
13:48:12 <Heffalump> _ is only valid in a pattern
13:48:17 <Heffalump> if you use otherwise in a pattern it just binds a name
13:48:29 <monochrom> And you really need True for guards. An arbitrary variable won't do.
13:48:40 <koeien1> > let f (Just otherwise) = otherwise + 1 in f (Just 37)
13:48:41 <lambdabot>   38
13:48:49 <koeien1> note: do not do this
13:48:59 <koeien1> > let f x | otherwise = x + 1 in f 37
13:49:00 <lambdabot>   38
13:49:44 <Heffalump> > let f otherwise = let g | otherwise = 3 in g in f True
13:49:45 <lambdabot>   3
13:49:48 <Heffalump> > let f otherwise = let g | otherwise = 3 in g in f False
13:49:49 <lambdabot>   * Exception: <interactive>:1:159-175: Non-exhaustive patterns in function g
13:50:03 <koeien1> haha, evil
13:50:51 <monochrom> hehe
13:51:00 <Paczesiowa> what? shadowing variables is evil?
13:51:18 <Paczesiowa> come on, even -Wall knows that...
13:51:20 <mauke> > let 2 + 2 = "yes" in 2 + 2
13:51:21 <lambdabot>   "yes"
13:51:25 <monochrom> No. Abuse is evil. (But you know that already.)
13:51:54 <Paczesiowa> what's that suppose to mean:)
13:52:08 <koeien1> it certainly covers examples like
13:52:09 <Paczesiowa> *d
13:52:11 <monochrom> It means shadowing again.
13:52:13 <koeien1> > let 2 + 2 = 5 in 2 + 2
13:52:14 <lambdabot>   5
13:52:23 <koeien1> or Heffalump's example
13:53:06 <roconnor> at least it isn't as bad as in lisp
13:53:26 <monochrom> Oh, dynamic scoping adds another kind of fun.
13:53:28 <Paczesiowa> shadowing should be banned by iso standard
13:53:48 <Paczesiowa> it gives bad name to other types of abuse!
13:54:22 <monochrom> standards are shadowed by corporate practice anyway
13:55:21 <Paczesiowa> we avoid success, so we don't have to care about corporate practice
13:55:46 <lpsmith> Shadowing names isn't evil;  I'd daresay it's evil not to support it :-)
13:56:48 <lpsmith> Problem is,  if you produce an error whenever a name gets shadowed,  you can break code that you aren't looking at by just introducing a new name
13:57:48 <Paczesiowa> lpsmith: actually, if you get an error - it's ok. I'm worried about those case where you don't get any errors
13:58:20 <Paczesiowa> lpsmith: then you have to think (!) why it doesn't work
13:59:04 <Paczesiowa> I believe thinking process should be finished before running program
13:59:24 <monochrom> Just produce an error message whenever a program is compiled.
13:59:38 <lpsmith> Paczesiowa:   you will never break anything by introducing a variable,  say x,  at the top level and then have it shadowed elsewhere in a long module
14:00:07 <lpsmith> Now if you prohibit shadowing,  you can break most modules by introducing a top-level variable named x
14:00:20 <lpsmith> And honestly,  I rarely run into shadowing bugs
14:00:28 <lpsmith> I don't think it's something to worry about
14:00:42 <Paczesiowa> lpsmith: usually you break things by adding new values at the bottom, not at the top
14:01:08 <koeien1> i run programs through -Wall anyway
14:01:32 <Paczesiowa> lpsmith: people rarely run into many other types of bugs - that's not the reason to allow them to exist
14:02:00 <monochrom> module ConfoundItAll where all names of 5 letters or less are defined.
14:02:01 <lpsmith> Much more often I run into unexpected trouble by accidentally writing something like "let x = x + 1 in ... x ..."
14:02:06 <Paczesiowa> lpsmith: I've never run into a unsafeCoerce# bug, let's add it to haskell'
14:02:20 <lpsmith> It'd be nice to have a construct that wasn't recursively scoped
14:02:42 * hackagebot upload: tkhs 0.2.2 - Simple Presentation Utility (YusakuHashimoto)
14:02:43 * hackagebot upload: ansi-wl-pprint 0.5.1 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output (MaxBolingbroke)
14:03:28 <monochrom> Oh noes, coloured!
14:04:08 * monochrom conceives rich-text-format output so you can have fonts too.
14:04:33 <lpsmith> You also won't run into shadowing trouble by adding new code at the very bottom of the syntax tree
14:04:52 <lpsmith> The only way you'd actually run into trouble is by modifying something in the middle
14:05:14 <lpsmith> and then it suggests that maybe you don't understand the code you are trying to modify...
14:05:41 <lpsmith> monochrom:   what about mathematica :-)
14:06:02 <monochrom> expensive
14:06:04 <cads> mathematica needs some standardization work
14:06:11 <cads> an some static types
14:06:21 <cads> and theorem proving :P
14:06:48 <cads> bullshit thing doesn't do anything but like algebraic satisfiability stuff
14:06:58 <cads> *kicks mathematica*
14:07:26 <cads> t me it's this hulking machine with pipes and tubing going everywhere and no schematic
14:07:26 <MisterN> cads: generally mathematica should become haskell?
14:07:36 <ddarius> lpsmith: You can use do.
14:07:59 <MisterN> cads: but i guess using haskell as a CAD would be pretty neat :)
14:08:16 <MisterN> -CAD+i'm not sure which is the correct abbrevation
14:08:21 <MisterN> your nickname confused me
14:08:43 <monochrom> canadian dollar
14:08:51 <ddarius> lpsmith: Or just lambda.
14:09:21 <lpsmith> ddarius: of course :-)
14:10:02 <cads> well i think it would be nice to type   plot f -10 10  in the ghci prompt and then an interactive plot window pops up of the function f
14:10:52 <ddarius> Except that that doesn't parse in the way you intend, you can easily do that.
14:11:40 <koeien1> CAS, you mean
14:11:44 <koeien1> computer algebra system
14:11:54 <cads> hehe, python has a CAS
14:11:54 <Philonous> cads: Is "plotFunc [] (linearScale 1000 (-10,10)) sin" simple enough?
14:11:59 <koeien1> cads: you mean SAGE?
14:12:18 <koeien1> SAGE is actually quite neat
14:12:36 <cads> Philonous, that's pretty nice, actually
14:12:40 <Philonous> http://hackage.haskell.org/package/gnuplot
14:14:36 <sohum> :k (->)
14:14:37 <lambdabot> ?? -> ? -> *
14:14:56 <cads> for theorem proving we drop into a shell featuring one of the many written in haskell :)
14:15:14 <ddarius> "many" == "two" ?
14:15:39 <Botje> two is a kind of many.
14:16:02 <cads> I've read more than two papers for different provers written in haskell :)
14:16:11 <centrinia> > "many" == "two"
14:16:12 <lambdabot>   False
14:16:28 <cads> people write toy provers for their disserations and then go work in the real world
14:16:29 <ddarius> cads: Reasonably practical systems?  And if so, name them.
14:16:31 <koeien1> > let "many" == "two" in "many" == "two"
14:16:32 <lambdabot>   <no location info>: parse error on input `in'
14:16:51 <monochrom> = True
14:16:54 <sohum> > let "many" == "two" = True in "many" == "two"
14:16:55 <lambdabot>   True
14:16:55 <cads> ddarius, heh, all I know are agda 2 and cayenne
14:17:07 <cads> so you might be right about the two :P
14:17:12 <sohum> is that a useful shortcut to add to the language?
14:17:22 <ddarius> I wouldn't count Cayenne.  I barely count Agda 2.  See also Yarrow.
14:17:32 <sohum> let x == y in ... expands to let x == y = True in ... ?
14:17:40 <monochrom> I know prufrock
14:17:40 <koeien1> nee
14:17:43 <koeien1> no*
14:17:45 <koeien1> sorry, that was Dutch
14:17:47 <skorpan> nää
14:18:10 <koeien1> that shadows the function (==), which is not something you'd normally do
14:18:19 <monochrom> In google, enter prufrock prover to get to it.
14:18:35 <sohum> in some cases, though, yea? defining (==) instances for Eq comes to mind
14:18:40 <monochrom> Did you know that they use typeclasses?
14:19:05 <koeien1> sohum: that is about the only place where it would make sense, but such a special case is very ugly
14:19:17 <sohum> koeien1: fair enough
14:22:02 <Philonous> cads: Maybe this one is even better: http://hackage.haskell.org/package/Chart
14:22:49 <cads> man I've pimped out my firefox so sweet.. it lists similar pages and suggestions on a little bar on the left, publishes an offline stream of trimmed down versions of sites I'm interested in but didn't have time to read, has individual little loading bars for each tab, and like 10 other cool addons that are now draining the hell out of my computer and I hate them.
14:23:30 <skorpan> sounds like windows me
14:23:32 <Botje> cads: i was an addon-oholic as well.
14:23:36 <cads> there's got to be a way to transform that mess into one thing that gives me those features but uses only a small core set of code
14:23:51 <koeien1> cads: the problem is that everyone wants a different core set of code
14:24:19 <djwonk> koeien: yes, multi-core. that's the problem
14:24:27 <koeien1> i have 15 add-ons installed currently
14:25:15 <cads> sure, how do you splice together 15 different little daemons that are all doing a million things concurrently in their own cute little ways
14:25:40 <cads> and then one of them hangs your whole browser and crashes it and all your currently opened tabs
14:26:40 <cads> I wonder how stuff like these are against hol and coq
14:26:53 <cads> (back to the theorem provers heh)
14:27:41 <cads> like, do they do tptp?
14:27:54 <ddarius> cads: Agda 2 and Cayenne have significantly different goals than HOL or Coq.  Yarrow uses a totally different basis.
14:29:06 <rgr> is it naive to think that (during tutorial) that n::[[Char]] is the same as n::[String] ?
14:29:20 <ddarius> Prufrock also looks to have a totally different basis than Yarrow or Coq.
14:29:36 <ddarius> rgr: Those are completely equivalent.
14:29:48 <koeien1> rgr: it is not naive, they are the same
14:29:56 <rgr> thank you.
14:31:58 <eugenn> i have a list of numbers. How do I get the average?
14:32:04 <cads> ddarius, so adga and cayenne are less useful for interactive theorem proving than they are for writing programs that do actual computations with dependent types?
14:32:31 <mauke> sum / (fromIntegral . length)
14:32:51 <ddarius> cads: Agda and Cayenne are intended to be dependently typed programming languages rather than proof systems, yes.  Cayenne, in particular, is unsuitable for proving.
14:32:51 <koeien1> eugenn: sum xs % length xs . Beware: this is not space-efficient
14:33:08 <koeien1> > let avg xs = sum xs % length xs in avg [1,2,3]
14:33:09 <lambdabot>   2 % 1
14:33:42 <eugenn> Ok, but I want it decimal
14:33:53 <koeien1> then / fromIntegral (length xs)
14:34:00 <eugenn> Let me be more specific. wait a second
14:34:04 <koeien1> > let avg xs = sum xs / fromIntegral (length xs) in avg [1,2,3]
14:34:04 <lambdabot>   2.0
14:34:11 <ivanm> koeien1: need fromIntegral sum as well probably
14:34:55 <ivanm> or else there's dons blog posts with efficient one-pass mean functions
14:35:10 <koeien1> yeah, or the chapter in RWH
14:35:43 <Paczesiowa> oh, come on - zipping two folds doesn't require reading dons's blog...
14:35:49 <eugenn> well nevermind..
14:35:54 <ivanm> Paczesiowa: it wasn't
14:36:06 <ivanm> koeien1: I don't recall the mean function in RWH...
14:36:15 <eugenn> it's some course mate having an issue with fromInteger and toInteger
14:36:20 <koeien1> ivanm: it is in the chapter on profiling & optimization
14:36:28 * ivanm goes off to look
14:36:36 <ddarius> eugenn: One should never be using either of those functions.
14:36:46 <koeien1> well, almost never
14:36:49 <koeien1> :t fromInteger
14:36:50 <lambdabot> forall a. (Num a) => Integer -> a
14:36:54 <koeien1> :t toInteger
14:36:55 <lambdabot> forall a. (Integral a) => a -> Integer
14:37:05 <koeien1> fromIntegral is often necessary
14:37:34 <eugenn> If I use toInteger on a float, does it round the number?
14:37:50 <mauke> > toInteger (1.23 :: Float)
14:37:51 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Float)
14:37:51 <koeien1> you can't
14:37:51 <lambdabot>    arising from a use o...
14:37:52 <ddarius> eugenn: You get a type error.
14:37:59 <koeien1> if you want rounding, use round
14:38:00 <ivanm> koeien1: in his blog post, dons says that using explicit recursion > folds IIRC
14:38:07 <eugenn> > round 3.4
14:38:07 <lambdabot>   3
14:38:13 <dixie_> I'm not able to figure out how to use treeCtrl from wx haskell :( how to put items into it. Can somebody help ?
14:38:14 <eugenn> > round 3.5
14:38:15 <lambdabot>   4
14:42:15 <lpsmith> hey,  has anybody come up with a nice way to have ghc-6.12 and previous versions of ghc co-exist on the same machine?
14:42:29 <lpsmith> I seem to be running into some kind of issue with the package file format having been changed
14:42:39 <ivanm> lpsmith: dcoutts does it IIRC
14:42:48 <ivanm> don't recall how though
14:43:22 <Paczesiowa> nix?
14:44:53 <ivanm> Paczesiowa: nope, he uses gentoo and ubuntu
14:44:56 <ivanm> but nix might do it
14:45:17 <Paczesiowa> ivanm: gentoo AND ubuntu is a nice way to use two versions of ghc:)
14:45:34 <ivanm> Paczesiowa: different machines
14:45:55 <ivanm> IIRC, on his gentoo desktop he had 3 or 4 different versions of GHC to test cabal on
14:46:01 <Paczesiowa> ivanm: another great way:)
14:46:08 <ivanm> ubuntu is on his laptop; don't know if he has multiple versions there or not
14:48:23 <dcoutts> ivanm: 5 versions
14:48:36 <ivanm> see? I was under estimating!
14:48:46 <copumpkin> misunderestimated!
14:48:56 <skorpan> undermistemated
14:50:23 <monochrom> If you use the generic binary tarball, it is very easy. http://groups.google.com/group/comp.lang.haskell/msg/a38908521c5a6e6b tells you what is going on.
14:50:37 <ivanm> skorpan: heh
14:56:43 <cads> hey how's free bsd for haskell?
14:56:49 <eugenn> I have google wave invitatios. since you all seem very nice, feel free to ask for one
14:57:22 <jlouis> ..oO(Wave federation server in Haskell)
14:57:43 <cads> I second that.
14:58:05 <cads> an interactive haskell bot living on wave
14:58:54 <cads> eugenn, do you really have an invite?
14:59:40 <halcyon10> hi, i get a compile-error from ghc, probably because i have some false understanding of the type system. Could anyone have a look at my code and tell me what's wrong with it? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12973
14:59:55 <eugenn> yes I do. The next day after that historic keynote I applied for one, and they gave me
15:00:21 * Berengal wonders if you can do haskell development on the wave
15:00:27 <Berengal> Hmm... wave-based Haskell IDE?
15:01:07 <eugenn> Most of wave gadgets will probably be programmed in Go
15:01:25 <Berengal> With the spelling correction and whatnot they demoed in the keynote, an IDE doesn't seem too far fetched
15:01:31 <Paczesiowa> halcyon10: you can't patternmatch on anything inside DirectionSampler
15:01:50 <Berengal> ... would it be possible to emulate emacs on the wave?
15:02:04 <Paczesiowa> halcyon10: you can only pattern match that to a variable (like x) and call methods from Sampleable on x
15:02:08 <eugenn> A syntax highlighter for many languages would be awesome in Wave.
15:02:33 <eugenn> and version control.. don't get me started. All the future it has..
15:02:35 <Paczesiowa> Berengal: emacs on the wave? there's already wave mode for emacs
15:02:46 <Berengal> Paczesiowa: there is? :O
15:02:56 <Paczesiowa> Berengal: emacs people don't roll the other way...
15:03:09 <eugenn> and something like our lambdabot hehe
15:03:29 <Paczesiowa> Berengal: I think I've seen some code on /r/emacs
15:03:54 <halcyon10> Paczesiowa: ok, i see, then i'll try adding another type class, perhaps that'll work
15:04:03 <Paczesiowa> Berengal: but it could be just a question or proof of concept
15:04:18 <Paczesiowa> halcyon10: have you seen classic Showable example?
15:04:53 <Berengal> Paczesiowa: I have no doubt there will be an emacs wave client in the near future
15:05:06 <Paczesiowa> halcyon10: anyway, I think you want to add method returning origin to Sampleable.
15:05:11 <Paczesiowa> halcyon10: whatever that is
15:05:31 <halcyon10> Paczesiowa: do you have a link to the Showable example?
15:06:46 <stroan> how does one go about getting a hackage username/pass?
15:07:02 <stroan> wait
15:07:02 <halcyon10> Paczesiowa: the Problem is, that Sampleable is really more general than that, so i'd rather don't want to contaminate it with a function that i wouldn't use elsewhere, is there another way instead?
15:07:02 <stroan> sorry
15:07:07 <stroan> just found it
15:07:32 <Paczesiowa> halcyon10: http://www.haskell.org/haskellwiki/Heterogenous_collections
15:07:49 <Paczesiowa> halcyon10: grep existential
15:08:36 <halcyon10> Paczesiowa: thanks for the link, i'll read that now
15:09:20 <Paczesiowa> halcyon10: looks like you have to create new class Origin
15:09:28 <Paczesiowa> halcyon10: how many types do you have?
15:10:03 <tensorpudding`> > foldr (+) [1..10]
15:10:04 <lambdabot>   No instance for (GHC.Num.Num [t])
15:10:04 <lambdabot>    arising from a use of `GHC.Num.+' at <...
15:10:14 <tensorpudding`> > foldr (+) 0 [1..10]
15:10:15 <lambdabot>   55
15:10:28 <eugenn> > foldr (+) 0 [1..10]
15:10:29 <lambdabot>   55
15:10:52 <halcyon10> Paczesiowa: i only have three types from which i want the origin, instances of Sampleable i have uncountable...
15:11:29 <cads> eugenn, I was imagining an environment almost like an ide, but a lighter and mostly server side
15:11:32 <Paczesiowa> halcyon10: oh, then Origin class seems easy
15:12:15 <Paczesiowa> cads: and what would it do? and why that would be a better way than emacs/vi?
15:12:25 <cads> kind of streams documentation and stuff at you in realtime as you need it while coding
15:12:52 <cads> and you could do it concurrently with a few people at time and it would be quick
15:12:55 <halcyon10> Paczesiowa: yeah, i'll write the Origin type class then, thanks for your help!
15:13:16 <cads> Paczesiowa, have you watched videos about what wave is?
15:13:21 <eugenn> that would be great cads, and how about including some case tools? whoa
15:13:34 <Paczesiowa> wow, that sounds just like all the other post web 2.0 mumbojumbo. I have no idea what you mean. back to emacs for me.
15:13:51 <Paczesiowa> cads: no, I hate google
15:14:26 <tensorpudding> concurrent editing would be interesting
15:16:07 <Paczesiowa> do you want to edit code just like google tells you to? google? the company that tells people to use gmail web interface - the most uncomfortable thing in the world?
15:16:52 <cads> Paczesiowa, did you use hotmail?
15:17:09 <ivanm> Paczesiowa: I would say that Hotmail is a more uncomfortable web email client, let alone the most uncomfortable thing in the world
15:17:18 <ivanm> Paczesiowa: and that's even before the new "live mail" :s
15:17:22 <tensorpudding> hotmail still exists?
15:17:34 <tensorpudding> i thought they died a while ago
15:17:37 <cads> thought I guess if someone that uses emacs/vi is talking about the most uncomfortable interface in the world, I better listen
15:18:07 <cads> heh, man, it's not the way google tells you to code
15:18:37 <cads> whatever way the stoner coder kids playing with this stuff  concoct
15:18:55 <cads> is whatever we'll be playing with
15:19:15 <Paczesiowa> cads: have you ever seen someone proficient with emacs/vi code? have you ever see someone using gmail reading mail?
15:20:22 <cads> heh, wonder if gmail is supports encrypted messages.. with automatic server side decryption ;)
15:20:24 <Paczesiowa> emacs user will remember command name and type it in with all those ctrls and metas before gmail user will find his mouse on the desk
15:20:35 <cads> look i'm not saying google is not evil
15:20:53 <cads> google is evil.
15:20:58 <Paczesiowa> they're not evil, they just dumb people down
15:21:10 <blackdog> it's even the right choice to dumb it down most of the time
15:21:14 <cads> stalman's evil too
15:21:19 <cads> and he has less money than google
15:21:39 <blackdog> we use emacs and vi because it's worth spending the time for something you basically live in
15:21:43 <cads> and google makes plenty of free code to play with
15:21:53 <blackdog> but for an email client, good enough is fine
15:22:17 <cads> right
15:22:21 <Botje> Paczesiowa: actually, gmail has vi shortcut keys.
15:22:29 <Botje> Paczesiowa: so do google reader and google calendar
15:22:45 <Botje> (which is why i now use google calendar even though i hate webapps)
15:22:55 <cads> i've got my client here, anyways, but still, remember that for a web based interface gmail is not bad
15:23:05 <visualbasicgui> my only issue with emacs is that the built-in shell is terrible
15:23:15 <visualbasicgui> no bash tab completion
15:23:20 <Paczesiowa> Botje: I suspect that anything that isn't vi but provides vi key bindings is just annoying in the end.
15:23:23 <visualbasicgui> no ncurses or "less" or any of that
15:23:33 <visualbasicgui> i hate having to open a terminal beside my emacs while developing
15:23:39 <Paczesiowa> visualbasicgui: term has pager builtin
15:23:57 <visualbasicgui> Paczesiowa: please go on???
15:24:06 <Paczesiowa> visualbasicgui: but I agree, term sucks
15:24:08 <Twey> Try ansi-term.
15:24:10 <Botje> Paczesiowa: eh, it works for me :) and I've been living in vim for close to ten years now
15:24:39 <visualbasicgui> Twey: OH DEAR
15:24:45 <Paczesiowa> Botje: I'm not vi person, I just still can't get over emacs key bindings in eclipse
15:24:46 <visualbasicgui> Twey: This is fantastic. This is just what I needed.
15:24:54 <Twey> visualbasicgui: ☺
15:25:01 <visualbasicgui> brb all, going to finish RWH in one epic push otnight
15:25:02 <MoALTz> i find it funny that something like let 1+1 = 3  leaves no clues in ghci. :t and :i fail to show being in effect for example :)
15:25:13 <visualbasicgui> *tonight
15:25:23 <Botje> visualbasicgui: woah. careful now
15:25:26 <jl_2> I'm writing some code that uses large bit strings, using Bits Integer from Data.Bits
15:25:29 <Botje> don't want your brains coating the wall
15:25:34 <Twey> Lambda overdose!
15:25:46 <chrisdone> he's got gonads!
15:25:52 <jl_2> I'm trying to find the most significant bit
15:25:55 * Twey chuckles.
15:25:56 <Botje> a b-reduction too far
15:26:04 <Twey> Hehe
15:26:18 <jl_2> right now I'm using the O(N) method on this page: http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup
15:26:21 <Paczesiowa> goodbye crueal world....(starts reading rwh)
15:26:28 <blackdog> Twey: hm, does yank not work in ansi-term?
15:26:34 <Twey> blackdog: I have no idea.
15:26:44 <Twey> Personally, I use screen with a separate zsh window.
15:26:55 <Paczesiowa> blackdog: in term.el you can switch between char-mode and line mode
15:27:31 <jl_2> any advice on whether the lookup table or O(lg N) methods from that page would be easiest to implement in Haskell?
15:27:57 <jl_2> "large bit strings" => 50000 bits
15:27:57 <blackdog> Twey: yeah, me too - I've repeatedly tried to shift to a terminal package in emacs, but they all seem to have something slightly screwy
15:28:12 <Twey> I've never really bothered
15:28:22 <chrisdone> shell-mode is sufficient for me
15:28:27 <Twey> I'm quite happy having emacs in screen
15:28:47 <Paczesiowa> Twey: don't you miss xft fonts ?
15:28:55 <blackdog> Twey: oh, you use terminals for emacs too? fair enough.
15:28:58 <Twey> Yes
15:29:08 <Twey> I have pretty much everything inside screen
15:29:11 <cads> it's just, the whole world is moving onto all sorts of new interface technologies... and emacs/vi are stuck with terminal emulation, pretty much
15:29:17 <Twey> irssi, zsh, emacs, rtorrent
15:29:25 <blackdog> jl_2: it looks like a static table - an array should do fine
15:29:37 <blackdog> listArray $ blah blah blah
15:29:38 <Twey> cads: emacs supports all sorts of fancy GUI stuff.
15:29:45 <Twey> It's just totally useless for a text editor.
15:29:47 <chrisdone> Paczesiowa: well, if your terminal emulator has xft then emacs will have it by running in it
15:30:20 <Twey> I use GUIs for: PDF-viewing, web-browsing, video-playing
15:30:37 <Paczesiowa> chrisdone: rxvt?
15:30:43 <Twey> Graphical things, where they actually offer an advantage, rather than just being hard-to-use bloat
15:30:49 <visualbasicgui> I use urxvt
15:30:55 <chrisdone> Paczesiowa: several do it; [u]rxvt, gnome-terminal, xterm
15:31:03 <cads> like, say, how hard would it be to embed a tiny little dasher screen into a corner of your emacs, to allow typing common phrases or commands for people that can't use keyboards
15:31:05 <visualbasicgui> but sometimes the cursor will sort of
15:31:10 <visualbasicgui> extend too far
15:31:10 <Paczesiowa> chrisdone: xterm does xft?
15:31:14 <visualbasicgui> and cover like 8 characters.
15:31:14 <chrisdone> Paczesiowa: yep
15:31:15 <Twey> I use Terminal.  rxvt doesn't support GTK or Qt IM modules.
15:31:27 <visualbasicgui> This happens a lot in emacs -nw. I used to use screen and emacs in it.
15:31:33 <visualbasicgui> But now I use emacs with a terminal in it :P
15:31:47 <Twey> I'd rather not be stuck with XIM.  Also, it's really annoying to configure.
15:32:10 <blackdog> cads: probably doable. Emacs has been extended rather a lot for accessibility purposes, like emacspeak
15:32:12 <Paczesiowa> I like emacs ideas, but I hate its bugs. I wish yi would take over
15:32:20 <chrisdone> I stopped using emacs in the terminal when I got sick of pasting
15:32:21 <ivanm> Paczesiowa: what bugs?
15:32:26 <chrisdone> emacs with gtk copy/paste integration is really nice
15:32:34 <chrisdone> *copy from firefox* C-y in emacs
15:32:37 <Paczesiowa> ivanm: term.el is one big bug
15:32:45 <Twey> Hence ansi-term, I guess
15:32:45 <visualbasicgui> i'm pretty sure its like
15:32:54 <blackdog> ivanm: and writing robust elisp is not that easy. at least for me.
15:32:58 <visualbasicgui> 1 line in your .emacs file to get the kill ring to play nice with x-clipboard
15:33:00 <cads> is there a web based emacs interface?
15:33:01 <Twey> elisp is not nice
15:33:03 <Paczesiowa> ivanm: but the idea to have two modes for using terminal, and working with text is great
15:33:05 <ivanm> chrisdone: I'm having some bugs with that, where sometimes I have to select some text with the cursor in another window to let emacs close a frame, etc. :s
15:33:07 <visualbasicgui> i hate to say it guys
15:33:09 <Twey> But it's the best we've got for the moment
15:33:10 <visualbasicgui> but lisp isn't nice
15:33:12 <jl_2> thanks, I was kinda hoping somebody would point out it's already implemented in the std lib, but oh well ;-)
15:33:14 <Paczesiowa> Twey: ansi-term still doesn't let me use ssh
15:33:14 <Twey> Maybe when Yi matures
15:33:16 <ivanm> blackdog: yeah, the lang is weird
15:33:21 <Twey> visualbasicgui: ‘Lisp’ is not a language
15:33:26 <Twey> Paczesiowa: Really?
15:33:32 <ivanm> Paczesiowa: well, I don't use term inside emacs much
15:33:33 <visualbasicgui> Twey: yeah yeah yeah
15:33:34 <cads> visualbasicgui, s-expressions get old
15:33:43 <visualbasicgui> Twey: They share a syntax. I suppose that's what I mean to say.
15:33:48 <Paczesiowa> Twey: or just small bugs like cursor moving to random places
15:33:49 <Twey> Paczesiowa: Works for me.
15:33:58 <Twey> I can even run emacs inside it.
15:34:00 <Paczesiowa> Twey: I'm glad:)
15:34:00 <Twey> ☺
15:34:02 <visualbasicgui> cads: yes s-expressions are hideous. I used to love them, but, once you go haskell you never go back
15:34:08 <jl_2> just about the most powerful thing in the world is tying together elisp and Perl
15:34:19 <Twey> Nothing wrong with S-expressions.
15:34:25 <visualbasicgui> I used common lisp for almost 2 years
15:34:31 <visualbasicgui> I can't bring myself to do it anymore
15:34:33 <MoALTz> s-expressions are fine
15:34:34 <Paczesiowa> jl_2: don't you mean the most ugly/ugliest?
15:34:41 <blackdog> jl_2: oh,i didn't actually look at what you were trying to do:) i think there's logBase, but not sure if it's specialised to log2
15:34:42 <chrisdone> sure is opinionated in here
15:34:49 <visualbasicgui> so much historical crust
15:34:54 <cads> eh, once you go to math notation, you're secretly rewriting everything in your programing notes with math notation and translating when you code :_
15:35:09 <Twey> And mathematical notation is basically crap.
15:35:18 <Twey> I'd prefer S-expressions to that.
15:35:20 <visualbasicgui> Twey: sometimes.
15:35:35 <Twey> visualbasicgui: It's hugely irregular.  It's like the Common Lisp of syntaxes.
15:35:36 <ivanm> Twey: :o
15:35:39 <cads> nah there are some nice expressions from stuff like category theory, semantic domains, and the like
15:35:44 <monochrom> I secretly write math in programming-inspired notation.
15:35:46 <Twey> Everybody's just tacked bits on over the course of several centuries.
15:35:49 <blackdog> visualbasicgui: lot of historical crust on common lisp and elisp, sure. doesn't mean s-exps are a bad idea
15:35:50 <cads> it's basically where haskell syntax comes from
15:35:52 <visualbasicgui> monochrom: me too
15:35:57 <chrisdone> I don't mind math notation when it's accompanied with a grammar
15:36:00 <visualbasicgui> monochrom: i barely make the distinction
15:36:01 <chrisdone> (i.e. never)
15:36:18 <jl_2> it can be a little ugly, but it lets me use all of CPAN and Perl, from keyboard macros and functions in emacs
15:36:32 <Twey> And it lacks things like a simple ‘repeat’ directive.
15:36:36 <tensorpudding> scheme syntax has some anachronisms in it
15:36:40 <ivanm> hang on, you're complaining about the vagaraties, etc. in mathematical notation/grammar/etc. in that most f-ed up language of all, ENGLISH? :o
15:36:44 <tensorpudding> like car/cdr
15:36:45 <monochrom> category theory is recent and gets CS participation too. its notation is more intelligently designed than evolved.
15:36:53 <chrisdone> ivanm: go'i
15:36:55 <Twey> ivanm: .e'u ma'a co'a pilno la .lojban.
15:36:58 <chrisdone> u'i
15:37:03 <Twey> .u'i .i'i
15:37:04 <chrisdone> a'o dai a'o
15:37:13 <chrisdone> si o'a
15:37:32 <ivanm> @slap chrisdone
15:37:32 <lambdabot> stop telling me what to do
15:37:34 * chrisdone facepalms on behalf of himself and Twey
15:37:34 <tensorpudding> lojban is one of the purist languages
15:37:34 <ivanm> @slap Twey
15:37:34 * lambdabot slaps Twey with a slab of concrete
15:37:35 <ivanm> ;-)
15:37:41 <visualbasicgui> blackdog: they're sort of hideous, though. I'm just saying. There's a lot of noise. On the other hand perhaps I'm just reacting to a bad experience with common lisp. At any rate, the reason I decided to learn haskell is because I liked functional programming, but lisp is ... dying, tbh. At the very least, you can't find anybody to talk to about it without scouring deep into some mailing list or something, and h
15:37:41 <visualbasicgui> askell just forces you to use functional programming, where in common lisp I found myself basically living off of loop, do, and defparameter
15:38:06 <monochrom> I would gladly use Chinese if you understood it.
15:38:11 * ivanm passes
15:38:26 <visualbasicgui> @slap visualbasicgui
15:38:27 * lambdabot pulls visualbasicgui through the Evil Mangler
15:38:31 <blackdog> visualbasicgui: seen liskell? it's perfectly possible to use s-exps for haskell without losing power or concision
15:38:36 <ivanm> visualbasicgui: :/
15:38:45 <blackdog> visualbasicgui: hee hee, you have perl on you now:)
15:38:55 <chrisdone> blackdog: I had some problems with that. like it not being up to date with the latest ghc
15:38:56 <tensorpudding> i wish scheme had partial application
15:38:56 <visualbasicgui> ivanm: :\
15:38:57 <cads> twey; by math notation I mean working within formal theories and using their equational symbols -- you can write expressions representing concurrent processes for example, and reason about them with pen and paper.. and then there's a isomorphism between what you were doing and an implementation in a functional lanugage
15:39:04 <h20xt> tensorpudding: yes!
15:39:11 <ivanm> visualbasicgui: are you a masochist or something?
15:39:23 <tensorpudding> i'm trying to implement some haskell in scheme today
15:39:31 <visualbasicgui> @slap lambdabot
15:39:31 * lambdabot would never hurt lambdabot!
15:39:34 <ivanm> tensorpudding: in what sense?
15:39:35 <visualbasicgui> :(
15:39:38 <ivanm> @slap visualbasicgui
15:39:39 * lambdabot locks up visualbasicgui in a Monad
15:39:39 <blackdog> chrisdone: yeah. wasn't really suggesting it as a practical option, just as a gedankenexperiment
15:39:46 <chrisdone> when I look at Clojure code, for some reason it seems beautiful
15:39:46 <visualbasicgui> nooooooooooo
15:39:51 <ivanm> how dare you try and get lambdabot to slap herself!
15:39:57 <blackdog> chrisdone: just for social reasons, you're better off writing more idiomatic haskell
15:40:04 <sieni> @slap sieni
15:40:04 * lambdabot pulls sieni through the Evil Mangler
15:40:09 <chrisdone> blackdog: indeed
15:40:20 <chrisdone> haskell always seems concise to non-haskellers, I've noticed
15:40:23 <sieni> I guess I was asking for it
15:40:24 <ivanm> blackdog: social == "if you ever expect anyone to help you debug your code..." ? :p
15:40:31 <rasfar> i'm seeing scheme for the first time in an undergrad course i'm TAing, and it's very frustrating to read...  (We get black-and-white printouts of the source code, opaque autotest results, and nothing more.)
15:40:52 <cads> performance optimized haskell is pretty gnarly
15:40:56 <tensorpudding> is lambda the only way to define functions in scheme?
15:41:01 <chrisdone> rasfar: on the upside you learn to become epic at parenthesis balancing mentally
15:41:02 <ivanm> cads: yeah :(
15:41:06 <blackdog> ivanm: got it in one:)
15:41:09 <ivanm> tensorpudding: nope, you have def IIRC
15:41:27 <monochrom> I think (define (f x) x) works too.
15:41:29 <Twey> tensorpudding: No, there's also defun, but I think it's defined in terms of lambda
15:41:37 <rasfar> chrisdone: ([(( :/ )]))
15:41:37 <ivanm> monochrom: yeah, that's what I meant
15:41:42 <tensorpudding> i thought defun was CL
15:41:43 <chrisdone> I was watching some programming talk the other day, and there was a compile error on-screen, audience were suggesting adding more parens. I saw instantly, too many parens. took them a couple minutes to figure it out. I was outraged
15:41:48 <sieni> rasfar: You just hasn't reached the Lisp enlightenment
15:41:59 <monochrom> I am not sure whether it is called define or defun for this.
15:42:05 <Twey> rasfar: LISP SENSE… TINGLING…
15:42:06 <tensorpudding> anyway my functions are all (define somefunc (lambda (x) (foooo)))
15:42:13 <tensorpudding> at the moment
15:42:16 <blackdog> chrisdone: who codes lisp in an editor without parenthesis balancing?
15:42:19 <chrisdone> tensorpudding: well it should be (define (somefunc x) ...)
15:42:19 <sieni> rasfar: haven't
15:42:20 <ivanm> tensorpudding: you can do (define (soimefunc x) (foo))
15:42:31 <ivanm> blackdog: exactly
15:42:38 <tensorpudding> ivanm: oh..
15:42:52 <chrisdone> blackdog: not just coding
15:42:56 <tensorpudding> it would help if i had a source for learning scheme but the plt-scheme help isn't useful
15:42:57 <chrisdone> you've got to, you know, read it
15:43:01 <ivanm> chrisdone: from when I did scheme for a semester way back, isn't there some semantic difference between the two forms?
15:43:03 <rasfar> Well, I've had some discussion with a certain faculty member about reviving a project written in Common Lisp, so I may be on the Path soon...
15:43:09 <ivanm> tensorpudding: SICP
15:43:21 <chrisdone> ivanm: no, one's syntactic sugar for the other
15:43:22 <tensorpudding> I have SICP somewhere...
15:43:27 <ivanm> chrisdone: right
15:43:28 <blackdog> chrisdone: what, on paper? how barbaric:)
15:43:43 <blackdog> not to mention ecologically unsound
15:43:52 <blackdog> save a tree, hug your editor today
15:44:07 <ivanm> heh
15:44:14 <visualbasicgui> tensorpudding: SICP is mandatory for life on planet earth.
15:44:26 <ivanm> visualbasicgui: is it?
15:44:27 <visualbasicgui> tensorpudding: It's available online.
15:44:38 <visualbasicgui> ivanm: YOU MUST LEARNS IT. NOW.
15:44:40 <ivanm> visualbasicgui: so all those people that, you know, can't read or anything... what are they all doing?
15:44:48 <visualbasicgui> ivanm: Unhumans.
15:44:50 <chrisdone> ivanm: dying .... slowly
15:44:54 <ivanm> like the lost tribes in the amazon...
15:45:01 <ivanm> visualbasicgui: you never mentioned humanity, just life
15:45:05 <ivanm> chrisdone: aren't we all?
15:45:06 <visualbasicgui> Oh yes.
15:45:10 <monochrom> save the planet. use a desert for your calculations.
15:45:15 <ivanm> who wants to die _quickly_?
15:45:28 <ivanm> monochrom: so we're going to make more deserts when we need more computational power?
15:45:34 <monochrom> yes!
15:45:43 <visualbasicgui> What computational model describes a brain?
15:45:47 <ivanm> so we're going to save the planet by ruining it...
15:45:53 <chrisdone> can we make desserts instead? ._.
15:45:57 <ivanm> visualbasicgui: the thinking one? :p
15:46:03 <ivanm> chrisdone: Just Desserts? :p
15:46:11 <chrisdone> maybe some tensor puddings
15:46:55 <ivanm> how do you make a tensor pudding? get a plum pudding recipe and s/plum/tensor/g it? :p
15:47:11 <poe> is there any documentation on the things that can go in .cabal/config?
15:47:18 <chrisdone> hehe
15:47:32 <ivanm> poe: with new cabal-install, the auto-generated config is self documenting
15:47:32 * hackagebot upload: UMM 0.1.1 - A small command-line accounting tool:  hledger + bugs - features? maybe... (UweHollerbach)
15:47:39 <roconnor> http://s3.amazonaws.com/neilbartlett.name/hug_paradise.flv <-- dead link
15:47:50 <ivanm> that is, all possible options are contained within it
15:47:51 <poe> ivanm sorry, when does it auto-generate the config file?
15:47:56 <roconnor> anyone have a copy of Lennart's talk on Paradise?
15:47:59 <ivanm> poe: first time you use it
15:48:06 <ivanm> if there isn't a config already there
15:48:08 <chrisdone> does anyone else ever click and drag an image in Firefox and move it slightly around the original image to make a blurred effect?
15:48:14 <ivanm> @google lennart's talk on paradise
15:48:15 <lambdabot> No Result Found.
15:48:24 <ivanm> roconnor: well, google doesn't seem to... ;-)
15:48:26 <dcoutts> poe: beyond all the comments already in .cabal/config, the options correspond to the flags which are documented by --help and most of those are also documented in the Cabal user guide
15:48:47 <poe> ivanm uh the docs says to create a config file if you don't want .cabal/bin/ but already have some $HOME/bin/
15:49:03 <monochrom> Is this some kind of recursion joke? "To understand cabal, you must first cabalize a package"...
15:49:11 <poe> so now it sees the config, and doesn't generate it, I guess
15:49:44 <dcoutts> poe: you don't want to make a new one yourself, let it make a default one and then edit that
15:51:31 <tensorpudding> the problem with SICP is that it's too introductory and slow moving
15:51:39 <dcoutts> poe: eg, I edited mine to use "symlink-bindir: /home/duncan/bin" since ~/bin is on my $PATH
15:51:40 <poe> dcoutts OK I was just following orders from bootstrap.hs :)
15:51:47 <tensorpudding> at least, for me
15:52:15 <dcoutts> poe: aye, I think we've tweaked the wording for the next release
15:53:36 <poe> there they are! and there are all the prefixes I wanted to adjust. thanks.
15:57:19 <akappa> what's the difference between f x | case x... | otherwise and f x = case x of  .... ?
15:57:41 <shachaf> akappa: f x | case x? What does that do?
15:58:27 <akappa> shachaf, wait, I'll try to be more precise
15:58:47 <tensorpudding> > let f x | x == 0 = 5; f x | otherwise = 6 in f 6
15:58:48 <lambdabot>   6
15:59:04 <blackdog> akappa: it's just syntax.
15:59:06 <tensorpudding> it allows you to inline guards
15:59:19 <tensorpudding> though i am not sure why you'd do that with a case statement
15:59:19 <rwx> <tensorpudding> it would help if i had a source for learning scheme but the plt-scheme help isn't useful <-- the plt scheme docs are amazing imo
15:59:46 <tensorpudding> rwx: the docs for lambda were pretty inscrutable, maybe if i knew what the terms meant...
15:59:59 <rwx> tensorpudding, it seems you've forgotten what it's like to learn haskell
16:00:01 <tensorpudding> i'm sure it'd be clearer if i started at the beginning
16:00:02 <rwx> ZING
16:00:03 <rwx> :-)
16:00:16 <tensorpudding> hey, haskell at least you can reason about type signatures
16:00:54 <Berengal> Haskell has pretty good tutorials covering the basics IMHO
16:00:57 <akappa> blackdog, but, if I'm not wrong, with the '|' you could not match the rule if none of the branchs matchs, with "case" you always match
16:01:00 <akappa> I'm wrong?
16:01:21 <tensorpudding> i feel lost sometimes in dynamic languages
16:01:32 <tensorpudding> without the helpful type signatures
16:01:39 <blackdog> tensorpudding: it's weird, crappily documented haskell is still easier for me to read than elaborately documented ruby stuff just for that reason. "Oh, it takes a few things and returns a thing. maybe it takes a block too (which is almost a function argument but not quite)"
16:01:43 <tensorpudding> how do i know what type the function will return?
16:02:19 <monochrom> I write the types in comments.
16:02:20 <blackdog> akappa: you can leave out possible cases in both the pattern syntax or the case syntax
16:02:21 <rwx> i agree re: typing
16:02:51 <akappa> blackdog, and if the case fails to match something, you pass on the next rule?
16:02:57 <tensorpudding> dynamic types feels handwavy
16:02:58 <blackdog> akappa: yep
16:03:09 <akappa> blackdog, oh, they are equivalent, so
16:03:11 <tensorpudding> i know that there are good reasons for them
16:03:17 <akappa> blackdog, but the "case" syntax is uglier
16:03:32 <blackdog> i like static types for libraries. i'm willing to tolerate a bit of dynamism at the application level.
16:03:34 <akappa> why there are two ways to say the same thing?
16:03:36 <Berengal> In dynamically typed languages, types are just a set of operations on values
16:03:40 <monochrom> dynamic type is poor man's dependent type
16:03:59 <monochrom> they are so poor they can't buy a theorem prover.
16:04:11 <akappa> dynamic type is confusing and error prone, imho
16:04:19 <Berengal> monochrom: it's sort of the inverse of dependent types. Instead of values at the type level, there's types at the value level
16:04:32 <rwx> blackdog, nice distinction. plt scheme provides contracts i think for just that reason
16:04:54 <tensorpudding> contracts?
16:05:00 <blackdog> akappa: partly historical accident, i guess. also, the pattern syntax has to be done on a named function, where you can have an anonymous case statement
16:05:22 <akappa> blackdog, oh, thanks a lot :)
16:05:28 <akappa> clear and precise
16:05:33 <blackdog> so you can bury a case statement in a series of function compositions
16:05:42 <akappa> indeed
16:06:50 <Veinor> http://www.amateurtopologist.com/2009/11/22/data-memocombinators-and-you/
16:06:52 <Veinor> that is all >_>
16:07:07 <monochrom> Why >_> ?
16:07:13 <Saizan_> @remember monochrom dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
16:07:14 <lambdabot> Good to know.
16:07:45 <tensorpudding> mm, amateur topologist
16:07:55 <tensorpudding> looks good
16:08:10 <Veinor> self-promotion makes me feel icky
16:08:21 <copumpkin> Veinor: didn't stop you
16:08:24 <Veinor> :P
16:08:29 <Veinor> well, I do think it's useful
16:08:39 <copumpkin> Veinor: there's talk of ordinals in #agda ;)
16:08:42 * copumpkin nudges and winks
16:08:47 <Veinor> tempter!
16:09:00 * roconnor wants to know more about ordinals
16:09:08 <monochrom> it is not self-promotion, since you don't over-do it. don't worry.
16:09:39 <monochrom> talk of ordinals tend to make it more profound than it is.
16:09:48 <Veinor> I wish I understood memocombinators.
16:11:27 <rwx> Veinor, nice post
16:11:55 <Veinor> thank you :D
16:12:00 <rwx> Veinor, but it seems awkward to have to define a new combinator for each type you use
16:12:14 <monochrom> http://www.cs.toronto.edu/~trebla/transfinite.txt  is a good start on ordinals. Yeah yeah self-promotion...
16:12:19 <rwx> why not `Memo2 Int Char` or something?
16:12:38 <Veinor> I was using that as an example for using Memo.wrap
16:13:02 <rwx> i know
16:13:11 <rwx> but i want a better way to memoize :-)
16:13:16 <Veinor> :P
16:13:30 <cads> roconnor, what do you mean? large ordinals?
16:13:31 <rwx> monochrom, what's your preferred set theory text?
16:13:40 <tensorpudding> inaccessible ordinals are the best
16:13:47 <monochrom> I have none.
16:13:48 <Veinor> well, the point of memo.wrap is so that you can memoize any function
16:14:02 <Veinor> well, many functions
16:14:21 <Veinor> I don't think you can memoize combinators.
16:14:23 <roconnor> cads: I mean recursive ordinal notations.
16:14:27 <rwx> monochrom, i recommend "introduction to set theory" by hrbacek and jech
16:14:49 <tensorpudding> what level of set theory?
16:15:02 <tensorpudding> is it focused on ZFC?
16:15:09 <Veinor> rwx: so like, with the (*) example, I use memo.wrap because it's more natural to define (*!) and therefore (*) on Nimbers
16:15:13 <akappa> Memoization is usually implemented as an associative array (or a plain array in the common case where the function takes a single non-negative integer as an argument)
16:15:21 <rwx> tensorpudding, primarily, yes, but there's talk of others. i think it's on google books
16:15:31 <akappa> Veinor, in the case of "sparse" arguments you still have to use an array
16:15:40 <Veinor> right.
16:17:36 <kniu> What's the difference between efficient type inference and type inference that's not efficient?
16:17:55 <copumpkin> type inference is always exponential!
16:17:56 <copumpkin> yay
16:18:06 <Veinor> one's faster!
16:18:20 <tensorpudding> type inference sounds slow
16:18:59 <roconnor> there are unrealistic cases where it is.
16:19:28 <jmcarthur> it may be slow, but the alternative is to run the algorithm in your own head
16:19:50 <rwx> Qi has turing-complete types
16:19:57 <rwx> which sounds either awesome or useless
16:22:47 <chrisdone> rwx: I'd completely forgotten about Qi as one of the "interesting languages I'd like to learn". I chose Haskell over it as which to learn first and then forgot about it
16:23:14 <ben0x539> I have a Ptr CChar, is there a way to write it to a handle without having to convert it to a [Char] or copy it into a ByteString?
16:24:47 <mathijsB> hm
16:24:58 <mathijsB> should I always prefer to use $ and . over ( ) in haskell?
16:25:09 <ben0x539> Only if it makes the code more readable
16:25:14 <ClaudiusMaximus> @hoogle hPutBuf
16:25:14 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
16:25:14 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
16:27:57 <chrisdone> one thing that sucks about not using haskell is worrying about recursion
16:28:51 <chrisdone> primitive concerns
16:29:12 <chrisdone> on the other hand, Haskell generated this: http://chrisdone.com/wordclouds/output.png
16:29:17 <chrisdone> so think about that~
16:32:03 <tensorpudding> i like how you can write so many recursive things using folds and unfolds
16:32:43 <ben0x539> @pl \f a b c -> f b c a
16:32:43 <lambdabot> flip . (flip .)
16:33:39 <tensorpudding> :t (.) (.)
16:33:40 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
16:33:51 <eugenn> :t unfold
16:33:52 <lambdabot> Not in scope: `unfold'
16:34:00 <eugenn> :t unfoldl
16:34:01 <lambdabot> Not in scope: `unfoldl'
16:34:30 <ben0x539> How do I make exceptions propagate from a thread to the thread that created it?
16:35:29 <tensorpudding> @hoogle unfold
16:35:29 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
16:35:29 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
16:35:29 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
16:35:34 <tensorpudding> huh, not defined
16:35:57 <Saizan_> ben0x539: you've to explicitly catch them in the forked thread and throwTo them back to the other one
16:36:00 <ben0x539> Okay.
16:36:03 <ben0x539> Sounds easy enough.
16:36:22 <tensorpudding> @define unfold r p x = if p x then [] else a : unfold r p b where (a,b) = r x
16:36:26 <dschoepe> @hoogle unfoldr
16:36:26 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
16:36:27 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
16:36:27 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
16:36:41 <tensorpudding> oh, there it is
16:37:07 <tensorpudding> @undefine unfold
16:37:21 <Saizan_> do id <- myThreadId; forkIO (catch foo (\e -> throwTo id (e :: SomeException))
16:37:50 <Veinor> chrisdone: what is that?
16:37:52 <Veinor> 19:30:16 < chrisdone> on the other hand, Haskell generated this: http://chrisdone.com/wordclouds/output.png
16:38:21 <eugenn> > sum [1,2,3] $
16:38:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:38:34 <eugenn> > sum $ [1,2,3]
16:38:34 <lambdabot>   6
16:38:46 <eugenn> what's the point of $?
16:39:04 <ivanm> Veinor: an image
16:39:08 <Veinor> ohohohoho
16:39:10 <ivanm> specifically, one in PNG format
16:39:16 <roconnor> > succ $ succ 0
16:39:17 <lambdabot>   2
16:39:20 <ivanm> eugenn: usually used to end the chain of function compositions
16:39:20 <roconnor> > succ succ 0
16:39:21 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
16:39:21 <lambdabot>    arising from a use of `GHC.Enum...
16:39:25 <Veinor> > sum $ zipWith (+) [0, 1] [0, 1]
16:39:26 <lambdabot>   2
16:39:30 <Veinor> > sum  zipWith (+) [0, 1] [0, 1]
16:39:30 <lambdabot>   Couldn't match expected type `[a]'
16:39:31 <lambdabot>         against inferred type `(a1 -> b ...
16:39:31 <ivanm> > succ . (*2) . (-4) $ 10
16:39:32 <lambdabot>   No instance for (GHC.Num.Num (a1 -> a))
16:39:32 <lambdabot>    arising from a use of syntactic ...
16:39:41 <ivanm> bah
16:39:42 <ivanm> > succ . (*2) . (-4) $ 10 :: Int
16:39:43 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Types.Int))
16:39:43 <lambdabot>    arising from a use of...
16:39:48 <poe> minus sign :(
16:39:50 <roconnor> ivanm: no - sectios
16:39:54 <ivanm> yeah, just worked that out
16:39:58 <ivanm> > succ . (*2) . (subtract 4) $ 10 :: Int
16:39:59 <lambdabot>   13
16:40:04 <ivanm> eugenn: ^^
16:40:06 <Veinor> that's always been the silliest part of haskell for me
16:40:14 <ivanm> Veinor: there's a reason to the madness
16:40:20 <ivanm> but yes, it gets irritating
16:40:22 <Veinor> yes, I know why
16:40:30 <eugenn> (head $ filter) (<4) [5,3,6]
16:40:38 <eugenn> > (head $ filter) (<4) [5,3,6]
16:40:39 <lambdabot>   Couldn't match expected type `[a]'
16:40:39 <lambdabot>         against inferred type `(a1 -> GH...
16:40:49 <ivanm> eugenn: you need . there, not $
16:41:00 <ivanm> or no brackets
16:41:01 <Veinor> just out of curiosity, why does (-4) work?
16:41:10 <ivanm> > head $ filter (<4) [5,3,6]
16:41:11 <lambdabot>   3
16:41:20 <ivanm> Veinor: it's negative 4
16:41:20 <eugenn> okay yea I know (head .) . filter works
16:41:44 <kniu> @hoogle runST
16:41:44 <lambdabot> Control.Monad.ST runST :: ST s a -> a
16:41:45 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
16:41:45 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
16:41:52 <eugenn> I don't quite get the difference, but I sure know there is a big one between . and $
16:42:07 <ivanm> eugenn: . is for function composition, $ is for function application
16:42:20 <ivanm> eugenn: so . lets you chain functions together, $ lets you apply a value to a function
16:42:32 <ivanm> > map ($2) [succ, pred, (*2), (^3)]
16:42:33 <lambdabot>   [3,1,4,8]
16:42:37 <eugenn> so $ is like saying "apply this"
16:42:42 <ivanm> eugenn: yes, exactly
16:42:44 <ivanm> @src ($)
16:42:44 <tensorpudding> the main reason ($) is around is for tidying things up
16:42:45 <lambdabot> f $ x = f x
16:42:45 <rwx> x $ y z == x (y z) ?
16:42:54 <ivanm> rwx: yes
16:43:06 <rwx> x . y z == (x y) z ?
16:43:22 <ivanm> tensorpudding: yeah, for either avoiding parens or in the map case I did for avoiding a lambda
16:43:24 <ivanm> rwx: no
16:43:31 <ivanm> x . y z = \ a -> x (y z) a
16:43:37 <ivanm> @type x . y z
16:43:37 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
16:43:38 <lambdabot>     In the first argument of `(.)', namely `x'
16:43:38 <lambdabot>     In the expression: x . y z
16:43:42 <Veinor> @src (.)
16:43:42 <lambdabot> (f . g) x = f (g x)
16:43:44 <ivanm> @type \x y z -> x . y z
16:43:45 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> f a) -> t -> f b
16:43:50 <ivanm> grrr...
16:43:53 <ivanm> @slap Caleskell
16:43:53 * lambdabot hits Caleskell with an assortment of kitchen utensils
16:43:54 <eugenn> seeing the definition of $, I would say that any function that has $ can be defined equivalently using proper parenthesis
16:43:59 <eugenn> is that right?
16:44:04 <ivanm> eugenn: usually
16:44:14 <ivanm> eugenn: see the map example I did before
16:44:18 <rwx> eugenn, coming from scheme, i was at first annoyed with $. now i like it a lot
16:44:22 <ivanm> > map ($2) [succ, pred, (*2), (^3)] -- again
16:44:23 <lambdabot>   [3,1,4,8]
16:44:24 <Veinor> > zipWith ($) [succ, pred] [0,0]
16:44:24 <ivanm> eugenn: ^^
16:44:24 <Jedai> rwx: x . y z == (\a -> x (y z a))
16:44:24 <lambdabot>   [1,-1]
16:44:29 <poe> eugenn yeah you put ( in place of $, and ) at the end of the line.
16:44:38 <ivanm> right, Veinor's is another good example
16:44:41 <ivanm> Jedai: oh, yeah, you're right
16:44:47 <rwx> Jedai, thanks
16:44:47 <ivanm> I put the parens in the wrong spot
16:44:56 <eugenn> > ($2) 4
16:44:57 <lambdabot>   Ambiguous type variable `a' in the constraint:
16:44:57 <lambdabot>    `GHC.Num.Num a' arising f...
16:44:57 <ivanm> poe: _usually_
16:45:04 <ivanm> eugenn: 4 isn't a function
16:45:12 <ivanm> > ($2) (*4)
16:45:13 <lambdabot>   8
16:45:21 <eugenn> uh sorry for that, my bad
16:45:47 <Jedai> ivanm: I think the choice of name is a little bit distracting there, with "f . g x" you would probably not have been confused
16:45:52 <BMeph> @type ($(?x))
16:45:52 <lambdabot> forall a b. (?x::a) => (a -> b) -> b
16:46:01 <ivanm> Jedai: maybe
16:46:25 <ivanm> BMeph: that's an implicit param, right?
16:46:45 <Jedai> naming conventions are important for this kind of things I find (or it may be my own particular affectation ;)
16:46:54 <poe> ivanm for example?
16:46:56 <rwx> f . g x = f g x -- ?
16:47:05 <Jedai> rwx: No
16:47:26 <ivanm> poe: all the examples that Veinor and I did with map, zipWith, etc
16:47:30 <rwx> i'm leaving out the parens, i'm still thinking that (f . g) = f . g
16:47:40 <ivanm> poe: even "($2) (*4)"
16:47:41 <Jedai> rwx: "f . g x" == "x . y z" up to renaming (often called alpha-conversion in CS circles)
16:47:43 <eugenn> f . g x = f (g x) -- there
16:47:55 <ivanm> eugenn: nope
16:47:59 <Jedai> eugenn: No
16:48:05 <poe> ivanm eheh I was talking about $ not ($), sure!
16:48:07 <ivanm> f . g x = \ a -> f (g x a)
16:48:22 <rwx> Jedai, alpha reduction?
16:48:27 <ivanm> poe: right, so putting parens isn't the same as using ($) or a section involving $
16:48:44 <roconnor> > succ `id` succ 0
16:48:45 <lambdabot>   2
16:49:10 <Jedai> rwx: not really a reduction per se, not like beta-reduction or others kinds, alpha conversion is just consistent renaming of variables
16:49:18 <Veinor> if you want to distinguish between $ and ($), then I suppos $ is only useful for parentheses :P
16:49:27 <tensorpudding> > (succ . succ) 0
16:49:27 <rwx> Jedai, thanks
16:49:28 <lambdabot>   2
16:49:48 <poe> ivanm but you got me thinking, it also doesn't work for f = g $ do ... if you break the line, you still put ( in place of $, but ) goes at the end of the do block. I guess if we correct the rule for ") goes at the end of the expression" we're good.
16:50:01 <tensorpudding> > succ . succ . succ . succ $ 0
16:50:02 <lambdabot>   4
16:51:05 <ivanm> poe: no, it works for do blocks IIRC
16:51:09 <ivanm> since they get de-sugared all together
16:51:32 <ivanm> but do _not_ use $ on one side of an `f`; that's caught me a lot
16:51:38 <eugenn> nTimes 1 f = f  ,  nTimes n f = f . nTimes (pred n) f     nice, is it?
16:51:41 <ivanm> if you want to use $, you have to put parens around the whole thing
16:52:24 <ivanm> eugenn: need to catch the < 1 case
16:52:27 <Veinor> @src (*)
16:52:27 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:52:40 <ivanm> eugenn: what you've done there is basically a church numeral
16:52:47 <ivanm> Veinor: its specific to each Num instance
16:52:58 <ivanm> Veinor: and they usually use hidden functions
16:53:04 <eugenn> really? a church numeral? I red about that!
16:53:47 <eugenn> nTimes 4 succ 0 would give 4
16:54:11 <roconnor> eugenn: what about nTimes 0 succ 0 ?
16:54:32 <eugenn> I guess that should remain undefined.. right?
16:54:38 <roconnor> nope
16:54:42 <eugenn> it makes no sense
16:54:49 <ivanm> it should return 0
16:54:54 <ivanm> which a church numeral will do
16:54:55 <roconnor> what would it mean to apply 0 copies of succ to 0?
16:55:04 <eugenn> oh
16:55:07 <ivanm> now, nTimes (-1) succ 0 is undefined
16:55:23 <eugenn> so nTimes 0 f = n
16:55:28 <ivanm> since there's no invertFunction :: (a -> a) -> (a -> a) :s
16:55:36 <ivanm> eugenn: nTimes 0 f n = n
16:55:38 <eugenn> and if I wnt it point free?
16:55:47 <roconnor> eugenn: that isn't right (and doesn't typecheck)
16:56:10 <roconnor> see what ivanm said
16:56:15 <eugenn> @pl nTimes 0 f n = n
16:56:15 <lambdabot> nTimes = const (const id)
16:56:25 <ivanm> eugenn: if you want it point-free, use nTimes 0 f = id
16:56:39 <ivanm> eugenn: but point-free is bad for when you do pattern matching (usually)
16:57:17 <eugenn> Is this function in any common library?
16:57:28 <ivanm> not really
16:57:41 <ivanm> which is a pity, as it turns up quite often
16:57:47 <eugenn> weird, it seems preety useful
16:57:48 <ivanm> the only other approach I can think of is to abuse fix for it
16:59:22 <tensorpudding> wow, this Data.MemoCombinators is neat
16:59:37 <copumpkin> Veinor's self-promotion worked!
17:00:07 <ivanm> tensorpudding: what does it actually do? I had trouble reading his post...
17:02:18 <kniu> What are Qualified Types?
17:02:37 <eugenn> > ((\x -> x) (\x -> x)) 8
17:02:37 <lambdabot>   8
17:02:50 <eugenn> yay! I predicted that
17:04:43 <byorgey> eugenn: well done =)
17:04:54 <ivanm> \o/
17:05:56 <tensorpudding> ivanm: it's kinda subtle in the fib example
17:06:10 <ivanm> usage of the Y combinator?
17:06:20 <tensorpudding> i don't know exactly what it uses
17:06:37 <ivanm> fix == Y combinator for Haskell
17:06:49 <ivanm> oh, wait, you're talking about Data.MemoCombinators
17:06:57 <ivanm> I thought you were talking about what eugenn was doing...
17:06:58 <eugenn> really? fix is the Y combimator?!
17:07:00 <tensorpudding> yes
17:07:06 <eugenn> :t fix
17:07:06 <lambdabot> forall a. (a -> a) -> a
17:07:15 <ivanm> eugenn: not quite, the types aren't quite right for it to be the real Y combinator IIRC
17:07:18 <tensorpudding> the Y combinator only works in the untyped lambda calculus doesn't it?
17:07:34 <monochrom> I think qualified type is a special case of qualified anything.  If you have a module Prelude that provides the function id, the data constructor Just, and the type Int, then Prelude.id is a qualified function, Prelude.Just qualified data constructor, and Prelude.Int qualified type.
17:09:01 <eugenn> can you do integrals, derivatives etc with lambda calculus? can in 'manage' continuity?
17:09:32 <eugenn> cause church numerals are like natural numbers
17:09:42 <ivanm> eugenn: lambda calculus /= integral calculus
17:09:58 <copumpkin> people just append calculus onto something to make it sound fancier
17:10:03 <ivanm> copumpkin: not quite
17:10:09 <tensorpudding> there's a pi calculus and a sigma calculus too, also different
17:10:11 <eugenn> oh, so there's a perfectly defined big difference
17:10:11 <ivanm> @wn calculus
17:10:12 <lambdabot> *** "calculus" wn "WordNet (r) 2.0"
17:10:12 <lambdabot> calculus
17:10:12 <lambdabot>      n 1: a hard lump produced by the concretion of mineral salts;
17:10:12 <lambdabot>           found in hollow organs or ducts of the body; "renal
17:10:12 <lambdabot>           calculi can be very painful" [syn: {concretion}]
17:10:14 <lambdabot> [6 @more lines]
17:10:18 <ivanm> @more
17:10:18 <lambdabot>      2: an incrustation that forms on the teeth and gums [syn: {tartar},
17:10:18 <lambdabot>          {tophus}]
17:10:20 <lambdabot>      3: the branch of mathematics that is concerned with limits and
17:10:22 <lambdabot>         with the differentiation and integration of functions
17:10:24 <lambdabot>         [syn: {the calculus}, {infinitesimal calculus}]
17:10:26 <lambdabot>      [also: {calculi} (pl)]
17:10:29 <ivanm> bah, all three are wrong!
17:10:31 <monochrom> That is like "can you display analog pictures on digital LCD monitors"
17:10:35 <ivanm> copumpkin: calculus is to do with computing
17:10:40 <ivanm> monochrom: heh
17:10:43 <copumpkin> I thought it had to do with stones
17:10:46 <ivanm> wtf is an analog picture?
17:10:51 <tensorpudding> also not to be confused with the predicate calculus
17:11:05 <monochrom> for example taking using film
17:11:10 <monochrom> s/taking/taken/
17:11:29 <eugenn> @google y combinator
17:11:30 <lambdabot> http://ycombinator.com/
17:11:30 <lambdabot> Title: Y Combinator
17:11:34 <monochrom> for example straight from TV air signal
17:11:37 <ivanm> monochrom: ahhh, right
17:11:42 <tensorpudding> curse you paul graham
17:11:44 <ivanm> @google wikipedia Y combinator
17:11:45 <lambdabot> http://en.wikipedia.org/wiki/Fixed_point_combinator
17:11:45 <lambdabot> Title: Fixed point combinator - Wikipedia, the free encyclopedia
17:11:46 <ivanm> tensorpudding: heh
17:15:36 <eugenn> withoutDuplicates [] = [] , withoutDuplicates (x:xs) = |elem x xs = withoutDuplicates xs   |otherwise = x:withoutDuplicates xs.    better way?
17:15:48 <ivanm> eugenn: nub
17:16:18 <ivanm> > nub [1,5,6,3,4,6,3,1,6,3]
17:16:19 <lambdabot>   [1,5,6,3,4]
17:16:31 <eugenn> :t nub
17:16:31 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:16:41 <ivanm> eugenn: oh, if you know the values are an instance of Ord and you don't care about ordering of the final list...
17:16:42 <eugenn> why is it called 'nub'?
17:16:56 <ivanm> > Data.Set.toList . Data.Set.fromList $ [1,5,6,3,4,6,3,1,6,3]
17:16:57 <lambdabot>   Not in scope: `Data.Set.toList'Not in scope: `Data.Set.fromList'
17:17:00 <ivanm> bah
17:17:08 <ivanm> > S.toList . S.fromList $ [1,5,6,3,4,6,3,1,6,3]
17:17:09 <lambdabot>   [1,3,4,5,6]
17:17:32 <ivanm> the problem with this is that the values are not in the same order they were in in the original list
17:17:49 <eugenn> ah yes, I saw that once
17:17:56 <eugenn> nub works this out?
17:18:03 <ivanm> eugenn: no
17:18:05 <ivanm> @src nub
17:18:05 <lambdabot> nub = nubBy (==)
17:18:09 <ivanm> @src nubBy
17:18:10 <lambdabot> nubBy eq []             =  []
17:18:10 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:18:26 <ivanm> eugenn: basically the same as what you were calling withoutDuplicates, but it keeps the first value rather than the last one
17:18:30 <stroan> where in the module tree should I place my libexpect bindings? System.Expect?
17:18:33 <ivanm> eugenn: this means that nub is lazy
17:18:39 <ivanm> stroan: what is libexpect?
17:18:52 <ivanm> eugenn: however, nub is O(n^2)
17:18:59 <stroan> it's opens pseudoterminals for interacting with programs
17:19:01 <tensorpudding> lazy nubs ask lame questions on irc
17:19:04 <jl_2> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5062#a5062
17:19:10 <ivanm> stroan: sounds reasonable
17:19:20 <ivanm> tensorpudding: I believe the spelling is noobs or n00bs, not nubs
17:19:30 <tensorpudding> i've seen it as nubs sometimes
17:19:45 <ivanm> jl_2: why "module Main () where" (i.e. why explicitly export nothing)?
17:19:50 <jl_2> When I run that code on large input files, it allocates a ton of memory (> 8GB), starts swapping, and has to be killed
17:19:58 <ivanm> jl_2: also, see the split library on hackage
17:20:01 <jl_2> oh, I dunno, bad style I guess
17:20:28 * ivanm vaguely guesses that jl_2 is keeping onto a named value and going through a large list twice rather than once
17:20:32 <eugenn> @check (reverse . reverse) x = id x
17:20:32 <lambdabot>   Parse error at "=" (column 23)
17:20:36 <ivanm> jl_2: try profiling?
17:20:41 <eugenn> @check (reverse . reverse) x == id x
17:20:41 <lambdabot>   Couldn't match expected type `[a]'
17:20:51 <ivanm> @check \ xs (reverse . reverse) xs == xs
17:20:51 <lambdabot>   Parse error in pattern at "xs" (column 26)
17:20:58 <ivanm> @check \ xs -> (reverse . reverse) xs == xs
17:20:59 <lambdabot>   "OK, passed 500 tests."
17:21:02 <ivanm> eugenn: ^^
17:21:08 <ivanm> need to make it a function ;-)
17:21:11 <eugenn> hehe thanks
17:21:28 <jl_2> haha, guess I should have tried profiling
17:21:31 <ivanm> > @check \ n -> succ n == n + 1
17:21:31 <lambdabot>   <no location info>: parse error on input `@'
17:21:36 <ivanm> @check \ n -> succ n == n + 1
17:21:37 <jl_2> funny thing is, I was using it earlier for something else
17:21:37 <lambdabot>   "OK, passed 500 tests."
17:22:11 <ivanm> jl_2: I'd be tempted to do: case (map read $ StringUtil.split line ';') of
17:22:25 <ivanm> jl_2: oh, Sets aren't lazy AFAIK
17:22:29 <ivanm> so that's probably your problem
17:22:38 * hackagebot upload: uuid 1.1.1 - For creating, comparing, parsing and printing Universally Unique Identifiers (AntoineLatter)
17:22:43 <eugenn> > (flip . flip) mod 100 10
17:22:44 <lambdabot>   0
17:23:01 <ivanm> flip . flip == id
17:23:53 <eugenn> nTimes (2*n) flip == id
17:24:35 <ivanm> well, not quite
17:24:46 <ivanm> the type of flip doesn't really work
17:24:50 <ivanm> @type flip . flip
17:24:50 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
17:25:01 <ivanm> @type flip . flip . flip . flip
17:25:02 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
17:25:17 <ivanm> hmmm, maybe you can say it == id
17:25:28 <ivanm> @type \ f -> flip . flip . flip . flip $ f
17:25:29 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
17:25:32 <eugenn> I think so
17:26:22 <eugenn> @src replicate
17:26:22 <lambdabot> replicate n x = take n (repeat x)
17:28:40 <eugenn> @time alvarezp
17:28:41 <lambdabot> Local time for alvarezp is Sun Nov 22 17:29:46
17:29:03 <eugenn> @time cads
17:29:04 <lambdabot> Local time for cads is Sun Nov 22 20:30:08
17:31:10 <EvanCarroll> does uppercase, lowercase :: String -> String
17:31:16 <eugenn> @quote calculus
17:31:16 <lambdabot> Cale says: Woo! Lambda Calculus and lots of pretty colours!
17:31:19 <EvanCarroll> effictively just set the signature for both uppercase and lowercase
17:31:29 <Axman6> yep
17:31:42 <EvanCarroll> cool
17:32:38 <idnar> Lambda Colourculus?
17:32:46 <idnar> @quote algebra
17:32:46 <lambdabot> monochrom says: If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
17:32:57 <ivanm> EvanCarroll: map toUpper/map toLower
17:33:02 <eugenn> @karma Bleadof
17:33:02 <lambdabot> Bleadof has a karma of 0
17:33:19 <ivanm> eugenn: are you having fun yet playing with lambdabot's plugins? ;-)
17:33:39 <eugenn> indeed
17:34:37 <eugenn> @@ @elite @run take 6 (repeat "lamda")
17:34:37 <lambdabot>  ["14/\/\dA","l4mD4","1amdA","LAmDa","|4/\/\d4","|AmDa"]
17:34:38 <copumpkin>  Veinor: failtweet
17:36:54 <dancor> the @quote and such should be avail in lbot's pure haskell
17:37:22 <BMeph> So, how come Haskell doesn't use apos to separate words in identifiers? :)
17:37:33 <dancor> showing a quote and vixen's reply e.g. isn't really possible currently
17:38:07 <idnar> @. vixen quote
17:38:07 <lambdabot> i'll hafta plead the fifth on that one.
17:38:38 <eugenn> @@ @elite @run [1..50]
17:38:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:39:07 <ivanm> eugenn: elite wouldn't do anything...
17:39:09 <idnar> @. elite quote
17:39:10 <lambdabot> 5c0Ox0 SAYz: R34l MEn D0n'+ NE3d S3M4N7i(z, Th3y pip3 M3ANINg dirE(71y INTo TH3IR cOMPil3Rs!
17:39:21 <eugenn> @@ @elite @run replicate "Haskell rocks"
17:39:22 <lambdabot>  (Ou|DN'7 MAtcH expEc7eD +ypE `9Hc.+YPes.IN7' agAiNSt INpherr3D 7Yp3 ...
17:39:29 <eugenn> hahah
17:39:47 <eugenn> @@ @elite @run repeat "Haskell rocks"
17:39:48 <ivanm> eugenn: you know you can play with these plugins using /msg lambdabot ?
17:39:49 <lambdabot>  ["|-|4zxE|l ROcx5","|-|asKElL r0CKz","HAsxe|| R0xx5","ha5x31L rOxxs","|-|4$K3|1 r...
17:39:58 <Veinor> copumpkin: ?
17:40:20 <copumpkin> Veinor: oh, you fixed it? the link you provided before said it prevented hotlinking
17:40:47 <Veinor> it does
17:41:00 <Veinor> just open it in a new tab or something :P
17:41:32 <Veinor> it's a SA-only imagehost
17:42:17 <copumpkin> SA?
17:42:38 <Veinor> something awful
17:42:58 <copumpkin> oh
17:43:09 <jl_2> http://jlarocco.com/images/prof1.png
17:43:19 <Veinor> course, that makes sharing images harder since you can't transload onto imageshack or whatever
17:43:20 <jl_2> What does "Bin" mean on the profiler output?
17:43:38 <copumpkin> it's the name of a constructor you can't see
17:43:46 <copumpkin> probably in Data.Map or something similar
17:43:56 <ivanm> Data.Set I think
17:44:10 <ivanm> jl_2: yeah, so you probably don't want to be using Data.Set there
17:44:25 <eugenn> > halt
17:44:26 <lambdabot>   Not in scope: `halt'
17:44:29 <ivanm> jl_2: what's your rationale for using a Set, or at least for continually adding elements rather than creating it in one go?
17:45:16 <copumpkin> Veinor: fail, people are complaining to me now about the faillink
17:45:26 <copumpkin> that'll teach me to retweet things of yours!
17:45:35 <Veinor> haha
17:45:35 <Veinor> :P
17:45:49 <ben0x539> The link worked for me :<
17:45:53 <eugenn> @quote plugin
17:45:53 <lambdabot> lambdabot says: Plugin `quote' failed with: getRandItem: empty list
17:45:56 <Veinor> you have to open it in a new tab or something
17:46:01 <jl_2> well, earlier I had tried using Data.Bits and Integers, but that didn't seem to help
17:46:01 <Veinor> @quote quote
17:46:01 <lambdabot> LoganCapaldo says: that quote is so awesome I'd @remember it again if it weren't already remembered
17:46:14 <idnar> haha
17:47:28 <jl_2> the algorithm I want to implement refers to sets, so Data.Set/Data.IntSet seemed like the obvious choice
17:47:42 <eugenn> @quote recursion
17:47:42 <lambdabot> anonymous says: Primitive recursion is the goto of functional programming.
17:49:04 <eugenn> can I check in polynomial time if a number is a perfect square without using explicit recursion?
17:49:29 <eugenn> or floating point arithmetics?
17:49:43 <ivanm> probably not
17:49:49 <idnar> how would you write it using explicit recursion?
17:49:56 <eugenn> I did it but with recursion
17:50:06 <eugenn> hold on
17:50:07 <idnar> (I'm too tired to do math)
17:50:20 <ivanm> well, you can just do: isSquare n = any (\x -> x^2 == n) [0..n]
17:51:23 <eugenn> yes, but I don't want the ^. by the way is that floating point?
17:51:46 <ivanm> no
17:51:48 <ivanm> @type (^)
17:51:49 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
17:51:50 <idnar> \x -> x * x == n)
17:51:57 <ivanm> well, it's floating point if a is
17:52:03 <ivanm> eugenn: fine
17:52:10 <ivanm> well, you can just do: isSquare n = any (\x -> x*x == n) [0..n]
17:52:11 <ivanm> ;-)
17:52:16 <ivanm> idnar: yeah
17:52:24 <Veinor> I wrote a recurisve isPowerOf2 :D
17:52:35 <tensorpudding> whoops, i tried to calculate fib 1000000 using the memoized fib
17:52:39 <ben0x539> aaah how do I avoid my code slowly creeping to the right when I keep case'ing on stuff
17:52:49 <Veinor> tensorpudding: yeah, even with memoization fib 1000000 will still be slow
17:52:52 <tensorpudding> and before i noticed ghc ate all my memory
17:52:53 <ivanm> ben0x539: RWH had some discussions on that IIRC
17:52:56 <eugenn> here's how I did it
17:53:02 <eugenn> isPerfectSquare = aux 1 where aux acum num   |numero == 0 = True   |numero < 0 = False   |otherwise = aux (acum + 2) (num - acum)
17:53:07 <ben0x539> Yeah but they just put everything into a monad :|
17:53:08 <ivanm> ben0x539: either stop using case, or sub-functions is the simpler answers
17:53:08 <copumpkin> numero?
17:53:12 <ben0x539> Hmm
17:53:14 <ivanm> ben0x539: yup
17:53:18 <eugenn> sorry, num
17:53:19 <tensorpudding> it's not just slow, it's that the memoization takes up gigantic quantities of mememory
17:53:26 <Veinor> that too, heh
17:53:30 <ivanm> tensorpudding: heh
17:53:37 <eugenn> isPerfectSquare = aux 1 where aux acum num   |num == 0 = True   |num < 0 = False   |otherwise = aux (acum + 2) (num - acum)
17:53:46 <tensorpudding> because when you get to fibs 10000, the numbers are huuuuuuge
17:53:55 <tensorpudding> and haskell Integer's are huuuuuuuge in general
17:54:16 <tensorpudding> and you're storing every single one
17:54:54 <Veinor> I think it'll take something like O(k^2) to store the tables for fib k and that's assuming Integers are stored in lg k bits
17:55:06 <Veinor> (where by lg k  I mean the bit-length of the integer k)
17:55:16 <PopeDavid> Hi guys (newb here). i'm having a problem getting a function to return an [[Int]], I'm running into problems with the type inferrer.
17:55:29 <eugenn> let's hear it
17:56:12 <PopeDavid> I've got a function segments which is meant to return a list of lists of int: a set of subsets of an input list
17:56:13 <ivanm> hmmm... going by PopeDavid's hostname, not only does he consider himself to be the leader of the world's catholics, but also the president of something... :p
17:56:38 <PopeDavid> my other nick is PresidentDavid
17:56:56 <PopeDavid> this is the first time I've used XChat, I don't know why some users' text is red, others have red lines under them
17:57:18 <Veinor> I think the red line is the last line you read
17:57:43 <thunderbolt> Yup.
17:57:43 <PopeDavid> did ivanm post something publically in channel? it appeared in red, was it a PM?
17:57:48 <Veinor> that is, the lowest line that was present when you last switched focus
17:58:00 <Veinor> I think the text coloring is a way to break up monotony
17:58:05 <Veinor> and yes, he did say something
17:58:07 <thunderbolt> PopeDavid: people's text may be highlighted when your name is in their reply.
17:58:13 <Veinor> ah, that too
17:58:18 <copumpkin> moo
17:58:23 <Veinor> cowpumpkin
17:58:41 <PopeDavid> ahh :) I was paranoid I was writing sometihng everyone could see without knowing what I was going on about
17:58:45 <PopeDavid> ANYWAY about this 'ere Haskell
17:58:51 <PopeDavid> I'll nopaste it, just a sec
17:58:59 <Veinor> use hpaste, it has syntax highlighting :D
17:59:15 <idnar> @where hpaste
17:59:15 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
17:59:22 <PopeDavid> http://pastebin.com/m2fa72f9c
17:59:34 <PopeDavid> pastebin has Haskell highlighting too
17:59:38 <Veinor> ooh, pastebin doe shaskell too
17:59:43 <copumpkin> pastie.org also does haskell now
18:00:08 <PopeDavid> this is part of an exercise I'm doing. I've identified a subtask myself which is to build a list of 'segments' of an input list
18:00:13 <Veinor> we're going mainstream!
18:00:26 <copumpkin> we're failing to fail to achieve success
18:00:31 <PopeDavid> (you went mainstream the moment someone sarted the Haskell reddit)
18:00:48 <eugenn> > (\x -> (x!!3,x!!5)) [1..10]
18:00:49 <lambdabot>   (4,6)
18:01:03 <copumpkin> eugenn: so pointful
18:01:09 <PopeDavid> in this context, the definition of a segment is a list comprised of consecutive elements of the input list
18:01:16 <copumpkin> > ((!!3) &&& (!!5)) [1..10]
18:01:17 <lambdabot>   (4,6)
18:01:31 * thunderbolt feels his brain melt slightly.
18:01:52 <PopeDavid> but anyway, I can't use my code because of a syntax/compilation error I can't figure out
18:01:58 <PopeDavid> can anyone get mine to load?
18:02:28 <thunderbolt> PopeDavid: You may get it to run in Helium, that has nice error messages.
18:02:42 <eugenn> > (\x -> (x!!3,x!!5)) [1..]
18:02:43 <lambdabot>   (4,6)
18:02:52 <thunderbolt> Er, attempt to execute it in Helium,, that will give more understandable error messages :)
18:03:14 <PopeDavid> Helium? right now I'm using GHCi
18:03:21 <ben0x539> What error are you getting?
18:03:22 <eugenn> > 3 &&& 9
18:03:23 <lambdabot>   No instance for (GHC.Show.Show (a b (c, c')))
18:03:23 <lambdabot>    arising from a use of `M58...
18:03:58 <thunderbolt> Yes, Helium is a subset of Haskell designed for teaching/learning. It has better error messages than GHC
18:04:00 <PopeDavid> ben0x539, "Couldn't match expected type `Int` against inferred type `[Int]`"
18:04:15 <thunderbolt> Oh, that's simpler than what I thought.
18:04:16 <copumpkin> thunderbolt: are you sure?
18:04:18 <akappa> goodnight (for those of you that live in europe ;))
18:04:22 <ben0x539> Where?
18:04:28 <thunderbolt> copumpkin: It's supposed to have better error messages :)
18:04:37 <copumpkin> thunderbolt: "when"?
18:05:09 <junmin> > data Variable = [a..z]
18:05:10 <lambdabot>   <no location info>: parse error on input `data'
18:05:33 <eugenn> :t sort
18:05:34 <lambdabot> forall a. (Ord a) => [a] -> [a]
18:05:37 <thunderbolt> copumpkin: I'm not sure I understand the question.
18:05:48 <BMeph> PopeDavid: Just a helpful hint: "childSegments x:xs" means: " (childSegments x) : xs" :)
18:05:48 <eugenn> @src sort
18:05:49 <lambdabot> sort = sortBy compare
18:06:00 <copumpkin> thunderbolt: I haven't heard much about it recently. Are you sure it's not better than some ancient version of GHC? :P
18:06:02 <EvanCarroll> there is no way to do @src through ghci right?
18:06:06 <ben0x539> no
18:06:12 <EvanCarroll> =(
18:06:17 <eugenn> > sort [1,3,2,4,3,5,4,6,5,7]
18:06:18 <lambdabot>   [1,2,3,3,4,4,5,5,6,7]
18:06:33 <eugenn> @src compare
18:06:33 <lambdabot> compare x y | x == y    = EQ
18:06:34 <lambdabot>             | x <= y    = LT
18:06:34 <lambdabot>             | otherwise = GT
18:06:35 <thunderbolt> copumpkin: Nope, I'm not sure.
18:06:36 <PopeDavid> BMeph: that sounds suspiciously silly to me. I'd love it if someone could make a Haskell variant with C-style syntax and a more popular operator precedence
18:07:00 <copumpkin> PopeDavid: why??
18:07:07 <eugenn> @src sortBy
18:07:07 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:07:09 <tensorpudding> you could probably write a DSL in Haskell that was like that
18:07:21 <junmin> data Variable = [a..z] it's giving an error :P
18:07:21 <BMeph> PopeDavid: I'd like it if someone re-wrote  to have a sane syntax, but I don't see that happening any time soon either. ;)
18:07:23 <copumpkin> PopeDavid: just to decrease the signal to noise ratio?
18:07:25 <tensorpudding> but why would you want C-style syntax?
18:07:34 <PopeDavid> familarity, I guess
18:07:44 <Veinor> junmin: hehew
18:07:45 <BMeph> re-wrote *C, that is. :)
18:07:51 <copumpkin> PopeDavid: it's an unfamiliar language with unfamiliar semantics. Why give yourself false friends with syntax?
18:07:52 <holmak> PopeDavid: fyi, your myCons is equal to "init" in the Prelude
18:08:07 <junmin> Veinor: any tips?
18:08:15 <tensorpudding> how do you handle partial function application cleanly in C syntax?
18:08:20 <eugenn> @src init
18:08:21 <lambdabot> init [x]    = []
18:08:21 <lambdabot> init (x:xs) = x : init xs
18:08:21 <lambdabot> init []     = undefined
18:08:24 <PopeDavid> holmak: yeah, I was worried about that, hence why I called it 'my' first :p
18:08:26 <Veinor> junmin: what're you trying to do?
18:08:33 <thunderbolt> tensorpudding: With a partial application function, of course!
18:08:37 <BMeph> junmin: Regarding your use of data: "UR DOIN IT RONG!" ;)
18:08:42 <tensorpudding> yuck
18:08:44 <thunderbolt> partial(func, param, param)
18:08:51 <holmak> just want to make sure you are aware of standard functions! :D
18:09:10 <holmak> there are many
18:09:12 <PopeDavid> holmak: I've got a godawful lecturer/professor, it's not all my own fault :p
18:09:14 <junmin> BMeph: hahaha
18:09:17 <tensorpudding> where is that sexp variant of Haskell?
18:09:24 <Veinor> sexy haskell?
18:09:25 <tensorpudding> I'm curious to see what that looks like
18:09:35 <eugenn> :t sexp
18:09:36 <lambdabot> Not in scope: `sexp'
18:09:39 <Saizan_> liskell?
18:09:42 <tensorpudding> yeah that one
18:09:43 <junmin> Veinor: Variable can only be named with one letter
18:09:44 <Saizan_> ?google liskell
18:09:51 <copumpkin> PopeDavid: I learned through this channel, just do that :)
18:09:55 <BMeph> tensorpudding: Look for "Liskell". :)
18:10:01 <Veinor> it seems to me that data isn't the thing you're looking for
18:10:04 <holmak> PopeDavid: you should also take a look at the "break" function
18:10:07 <idnar> PopeDavid: I don't think operator precedence is the issue
18:10:08 <eugenn> @google liskell
18:10:10 <Veinor> but someone else will have to tell you what it is
18:10:11 <copumpkin> These are not the droids you seek
18:10:13 <dancor> @bot
18:10:14 <lunabot>  :o
18:10:18 <Saizan_> (lb just died?)
18:10:21 <EvanCarroll> ok, so I'm on monads!
18:10:23 <tensorpudding> hmm, sexp is more appropriate for macros and metaprogramming, if people actually wanted to do much of either in haskell
18:10:24 * EvanCarroll horrahs
18:10:26 <idnar> function application just isn't an operator at all in C
18:10:27 <Cale> @bot
18:10:27 <lunabot>  :o
18:10:29 <holmak> @src break
18:10:32 <Cale> hum
18:10:44 <junmin> Veinor: :|
18:10:47 <tensorpudding> @botsnack
18:10:48 <lunabot>  :o
18:10:48 <idnar> well, I suppose according to C++, it's an operator; but syntactically, it's something special
18:10:48 <lambdabot> :)
18:10:56 <Cale> ah, it's just lagged
18:10:57 <copumpkin> I bet someone did the evil @pl trick
18:11:05 <Veinor> evil pl trick?
18:11:19 * copumpkin whistles
18:11:24 <Veinor> sounds.... evil :o
18:11:25 <PopeDavid> BMeph, I paranthesied the arguments for childSegments on line 32, but I still get the same error
18:11:29 <EvanCarroll> oh shitty
18:11:38 <EvanCarroll> the tutorial isn't going to explain them
18:11:39 <copumpkin> > text "allo"
18:11:40 <lambdabot>   allo
18:11:47 <Veinor> :t text
18:11:48 <lambdabot> String -> Doc
18:11:57 <copumpkin> > text "alô"
18:11:58 <lambdabot>   alô
18:12:04 <eugenn> Doc?
18:12:06 <junmin> Veinor: you are right
18:12:06 <Veinor> I need to set up a hoogle keyword search in firefox
18:12:10 <copumpkin> pretty printing
18:12:12 <junmin> out of mind :|
18:12:18 <junmin> here
18:12:25 <Veinor> so I can type 'hoogle doc'
18:12:51 <holmak> PopeDavid: I think your problem is line 32
18:12:55 <Veinor> oh, you can do it faster now!
18:13:12 <tensorpudding> whoops
18:13:35 <eugenn> @quote world
18:13:35 <lambdabot> sorear says: unsafePerformIO is dangerous only because it shows you the world as it really is, and your mind won't be able to take it.
18:13:37 <holmak> PopeDavid: Specifically, that your recursion is going to build a list like [1, [2, [3, [...]]]
18:14:13 <copumpkin> Mu []!
18:14:21 <copumpkin> not quite though :)
18:14:22 <holmak> PopeDavid: You see what I mean? you are putting myJoins inside of myJoins recursively
18:14:35 <eugenn> > foldl1 (:) [1,[2,[3,[4,5]]]]
18:14:36 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:14:41 <PopeDavid> holmak: the idea is that I'd input [1,2,3] into segments and get out [ [1,2,3], [1,2], [1], [2,3], [2], [3] ]
18:15:02 <BMeph> PopeDavid: Also: Your myJoin should _NEVER_ have the result of childSegments; the types don't match. :)
18:15:04 <PopeDavid> holmak: myJoin exists because I forgot the syntax for adding a list to another list isntead of concatenatingit
18:15:11 <copumpkin> > map inits . tails $ [1..3]
18:15:12 <lambdabot>   [[[],[1],[1,2],[1,2,3]],[[],[2],[2,3]],[[],[3]],[[]]]
18:15:23 <copumpkin> > filter (not . null) . concatMap inits . tails $ [1..3]
18:15:24 <lambdabot>   [[1],[1,2],[1,2,3],[2],[2,3],[3]]
18:15:31 <holmak> PopeDavid: You should try "segments (x:xs) = [childSegments (x:xs)] ++ [segments xs]"
18:15:38 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..3]
18:15:39 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3]]
18:15:43 <holmak> er
18:15:49 <BMeph> PopeDavid: Rather, the results ... *as an argument;
18:16:11 <PopeDavid> holmak, BMeph : thanks, I'll try it now
18:16:11 <holmak>  PopeDavid: I meant "segments (x:xs) = [[childSegments (x:xs)]] ++ [[segments xs]]"; double brackets
18:16:43 <eugenn> > sequence [1,[2,[3,4]]]
18:16:44 <lambdabot>   No instance for (GHC.Num.Num [t])
18:16:44 <lambdabot>    arising from the literal `2' at <inter...
18:16:57 <PopeDavid> holmak, : just aobut to say, I just got a syntax error from the first one you gave me :p
18:17:06 <copumpkin> eugenn: it's not a valid list
18:17:24 <PopeDavid> holmak: argh, that didn't work either. gimmie a sec
18:17:29 <holmak> PopeDavid, i think im still wrong
18:17:31 <eugenn> oh right, it's heterogeneus
18:17:57 <PopeDavid> holmak: here's my code: http://pastebin.com/m253172e4 and the error: http://pastebin.com/m7ec096b7
18:19:36 <holmak> PopeDavid: Yeah, I am making a mess. I think what you really want in "[[child ...]] ++ (segments xs)"
18:19:53 <eugenn> > zipWith ($) [succ,pred] [4,6]
18:19:54 <lambdabot>   [5,5]
18:20:03 <PopeDavid> holmak: no :p that didn't work either
18:20:13 <holmak> PopeDavid, hang on, i think im wrong again
18:20:53 <holmak> PopeDavid: So "(child ...)" is of type http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int, and so is "segments ..."
18:21:07 <copumpkin> > runZipList $ ZipList [succ, pred] <*> ZipList [4, 6]
18:21:07 <lambdabot>   Not in scope: `runZipList'
18:21:12 <copumpkin> @hoogle ziplist
18:21:13 <lambdabot> Control.Applicative newtype ZipList a
18:21:13 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
18:21:13 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
18:21:14 <holmak> PopeDavid, whoa, autoformatting problem
18:21:19 <copumpkin> > getZipList $ ZipList [succ, pred] <*> ZipList [4, 6]
18:21:20 <lambdabot>   [5,5]
18:21:22 <PopeDavid> lol, this ain't mediawiki :)
18:21:34 <holmak> PopeDavid: So "(child ...)" is of type [[ Int ]], and so is "segments ..."
18:21:48 <holmak> PopeDavid, so you ought to be able to just ++ them together
18:21:58 <PopeDavid> in that they both return a list of a list of ints, yes
18:22:03 <eugenn> @type <*>
18:22:04 <lambdabot> parse error on input `<*>'
18:22:10 <junmin> incorret indention errorrr... http://dpaste.com/123881/  :s
18:22:23 <tensorpudding> @type (<*>)
18:22:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:22:31 <PopeDavid> holmak: yep, that worked. Now I'm going to give it a whirl
18:23:39 <BMeph> junmin: Is that Helium? 'Cause it surely isn't Haskell... :)
18:24:07 <holmak> So apparently wrapping something in [[ ]] in my client makes it link to wikipedia
18:24:09 <holmak> How strange
18:24:25 <junmin> BMeph: -_-
18:25:18 <PopeDavid> so does typing [[]] in wikipedia give you GHCi error messages when you hit 'show preview'?
18:25:38 <eugenn> :t random
18:25:39 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
18:26:04 <eugenn> > random 5
18:26:05 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:26:05 <lambdabot>    `System.Random.RandomGen...
18:28:22 <eugenn> :t True
18:28:23 <lambdabot> Bool
18:29:11 <holmak> PopeDavid: did that end up doing what you wanted?
18:29:31 <eugenn> > (head . last) [[1,2,2,2,3],[33,9]]
18:29:32 <lambdabot>   33
18:29:58 <PopeDavid> holmak: well sort-of. My code doesn't work, but that's due to logic errors elsewhere in the program.
18:29:58 <PopeDavid> but the help you gave me means it at least runs now
18:30:31 <eugenn> > p =<< q
18:30:32 <lambdabot>   Couldn't match expected type `a -> m b'
18:30:32 <lambdabot>         against inferred type `Simp...
18:32:02 <holmak> PopeDavid: You want help with anything else?
18:32:13 <PopeDavid> holmak: if it isn't too much trouble?
18:32:21 <holmak> sure, why not
18:32:29 <PopeDavid> well, it is 0235h right now :p
18:32:49 <holmak> Europe?
18:32:52 <eugenn> > (\n -> drop n [1..n+1]) 9
18:32:53 <lambdabot>   [10]
18:32:54 <holmak> @help time
18:32:55 <PopeDavid> yeah
18:32:55 <lambdabot> time <user>. Print a user's local time. User's client must support ctcp pings.
18:33:03 <holmak> time holmak
18:33:05 <holmak> @time holmak
18:33:06 <lambdabot> Local time for holmak is Sun Nov 22 21:34:12 2009
18:33:15 <PopeDavid> @time PopeDavid
18:33:17 <lambdabot> Local time for PopeDavid is Mon Nov 23 02:36:00
18:33:20 <holmak> It is early for me!
18:33:24 <PopeDavid> heh
18:33:35 <eugenn> > drop 5 [1..10]
18:33:36 <lambdabot>   [6,7,8,9,10]
18:33:54 <holmak> so you are trying to break a list of ints into sequences of consecutive, equal ints?
18:33:57 <PopeDavid> the overarching assignment question is to write a Haskell program that accepts a 1-dimensional list of ints and returns the length of the longest 'flat' segment
18:34:34 <eugenn> > (length . show . abs) 6432
18:34:35 <lambdabot>   4
18:34:36 <PopeDavid> I've broken it down into a bunch of sub-problems. I've already written my 'isFlat' function that works. Right now I'm working on the big that gives the 'segments'
18:34:38 <holmak> so you want to go [1, 1, 2, 2, 2, 3] ==> [[1, 1], [2, 2, 2], [3]] ==> 3
18:34:49 <holmak> yes?
18:35:08 <copumpkin> > group [1, 1, 2, 2, 2, 3]
18:35:09 <lambdabot>   [[1,1],[2,2,2],[3]]
18:35:15 <holmak> huzzah!
18:35:25 <PopeDavid> well for this sub-problem an input would be [1,2,3] and it should return [ [1,2,3], [1,2], [1], [2,3], [2], [3] ]
18:35:27 <Guest34274> I thought I understood monads and then I started watching this Youtube series
18:35:50 <copumpkin> PopeDavid: in that order? I gave something that gave those same subsequences but in a different order a little while ago
18:35:50 <PopeDavid> if you arrange them vertically you see a pattern emerge
18:36:08 <PopeDavid> cpumpkin: sorry, I must have missed that. I'll scrollback now.
18:36:24 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..3]
18:36:25 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3]]
18:36:35 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..]
18:36:36 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
18:36:54 <copumpkin> the other order doesn't cover infinite lists nicely
18:37:09 <PopeDavid> the problem domain are finite lists, so that's fine
18:37:14 <PopeDavid> wow, that's a pretty nice solution
18:37:31 <PopeDavid> but I don't want you to do my work for me, otherwise I wouldn't be learning :)
18:37:38 <copumpkin> that's the spirit!
18:37:40 <copumpkin> carry on :D
18:37:45 <PopeDavid> what does the '.' syntax mean?
18:37:55 <holmak> How does the saying go? "Programming Haskell consists of an hour of meditation, followed by the emission of a single fold expression." ?
18:38:05 <tensorpudding> :t (.)
18:38:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:38:13 <copumpkin> PopeDavid: function composition: (f . g) x = f (g x)
18:38:25 <tensorpudding> it's just like maths
18:38:25 <PopeDavid> and I could be earning how much writing this for a living? :p they'd ask why I'm writing so little code
18:38:31 <roconnor> tries not to filterM [minBound..] [1..3]
18:38:32 <tensorpudding> where you have that little circle
18:38:53 <holmak> Just show results! It'll work...totally...
18:38:55 <PopeDavid> oh we covered function composition and list comprehension last week, at that point the prof had lost me entirely
18:38:56 <copumpkin> > filterM [minBound..] [1..3]
18:38:57 <lambdabot>   Couldn't match expected type `a -> m GHC.Bool.Bool'
18:38:57 <lambdabot>         against inferre...
18:39:06 <copumpkin> > filterM (const [minBound..]) [1..3]
18:39:06 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:39:09 <thunderbolt> PopeDavid: Code is a liability, not an asset :)
18:39:11 <copumpkin> not quite the same though :)
18:39:29 <holmak> copumpkin, you are on a one-liner rampage
18:39:39 <copumpkin> holmak: that was roconnor!
18:39:50 <roconnor> holmak: you haven't been around #haskell much have you?
18:40:02 <copumpkin> my favorite one-liner is fix (ap sequence)
18:40:17 * roconnor like zip`ap`tail
18:40:27 <holmak> some. The one liners do not always fly so rapidly
18:40:27 <aavogt> @type fix (ap sequence)
18:40:27 <thunderbolt> :t (ap)
18:40:28 <lambdabot> forall a. [[a] -> a] -> [a]
18:40:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:40:31 <PopeDavid> y'know, for a channel with 618 people in it it's awfully quiet and everyone's giving my attention
18:40:35 <copumpkin> aavogt: yay
18:41:10 <holmak> The other 630 are bots
18:41:15 <roconnor> @free (fix (ap sequence))
18:41:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
18:41:16 <holmak> Waiting for the right input
18:41:23 <copumpkin> > fix (ap sequence) [(!!3), const 3, (+1) . (!!0), (*3) . (!!2)]
18:41:28 <lambdabot>   mueval: ExitFailure 1
18:41:29 <copumpkin> whoops
18:41:36 <aavogt> > 618 - 630
18:41:36 <roconnor> copumpkin: is that your excel in one line of haskell program?
18:41:37 <lambdabot>   -12
18:41:43 <copumpkin> roconnor: yeah
18:41:48 <holmak> erm, there were 660 in here last i looked :/
18:41:54 <copumpkin> it's more specific than loeb but shorter
18:42:08 <BMeph> Sweet! "fix (ap sequence) == loeb! I did not know that! :)
18:42:31 <copumpkin> > fix (ap sequence) [(!!3), const 3, (+1) . (!!0), const 5, liftA2 (+) (!!0) (!!2)]
18:42:32 <lambdabot>   [5,3,6,5,11]
18:42:57 <aavogt> > ap sequence `fix` [(!!1),(!!0)]
18:43:02 <lambdabot>   mueval-core: Time limit exceeded
18:43:04 <roconnor> copumpkin: I figured that mfix would have been used.
18:43:23 <copumpkin> hmm, I wonder how that would work
18:43:37 <copumpkin> :t mfix
18:43:38 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:43:55 * thunderbolt needs more work on monads.
18:43:57 <roconnor> perhaps it isn't approriate here
18:44:24 <holmak> monads, ha! *Arrows* are what you want.
18:44:35 <copumpkin> we need to write a super loeb with loop
18:44:37 <thunderbolt> Arrows?
18:44:43 <copumpkin> :t loop
18:44:43 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
18:44:45 <thunderbolt> I'm a math major, and I don't know what those means...
18:44:50 <holmak> Generalization of monads, sort of
18:44:56 <holmak> I don't think its a math term
18:45:01 <thunderbolt> Ok.
18:45:09 <copumpkin> it is
18:45:17 <holmak> I was reading one of the arrow papers, its wild stuff. I certainly don't follow
18:45:43 <copumpkin> apparently they have something to do with freyd categories
18:45:48 <copumpkin> but I'm not sure what those are :)
18:45:59 <roconnor> thunderbolt: imagine you have a monad and a comonad that distributes over it.
18:46:03 <rwx> is there a standard function to find the inverse of an algebraic expression?
18:46:10 <roconnor> thunderbolt: that is like an arror
18:46:15 <copumpkin> rwx: nope
18:46:25 <roconnor> arrow
18:46:31 <thunderbolt> roconnor: Ah.
18:46:37 <h20xt> how do i take a Word32 to a Word8, for instance after (.&. 0xFF)
18:46:44 <copumpkin> h20xt: fromIntegral
18:46:50 <h20xt> thanks
18:47:00 * roconnor worries that that mike make sense to thunderbolt
18:47:01 <BMeph> thundebolt: Think Freyd. :)  -- Oh, yeah, NM, I type slow.
18:47:05 <roconnor> might
18:47:06 <roconnor> ugh
18:47:18 <thunderbolt> :d
18:47:19 <thunderbolt> :D
18:47:24 * roconnor shuts up
18:47:42 <BMeph> roconnor What, like a difunctor? :)
18:47:50 * ivanm passes roconnor some wide masking tape
18:48:29 <copumpkin> I don't think the math major here even mentions category theory
18:48:46 <copumpkin> I've noticed a brief mention of it in a graduate algebra syllabus, but not much more :/
18:48:47 * BMeph remembers the adage: "Silence is Golden; Duct Tape is Silver!" ;)
18:49:08 <ivanm> heh
18:49:16 <thunderbolt> copumpkin: Yeah, my emphasis was in probability and analysis, so not much category theory for me.
18:49:32 <thunderbolt> One of my former coworkers had her Ph.D in category theory and combinatorics, though.
18:49:42 <ivanm> a double PhD?
18:50:14 <Saizan> Arrow is basically a way to define a subcategory of Hask, though with some additional requirements
18:50:28 <Cale> Lots of additional requirements :)
18:50:48 <holmak> double PhD: basic qualification for using Haskell
18:50:49 <Cale> Well, actually...
18:51:10 <Saizan> mh, maybe subcategory is not even correct?
18:51:12 <Cale> "Subcategory" isn't quite right, since you're defining the composition map.
18:51:14 <thunderbolt> ivanm: straddling the border between the two subjects :)
18:51:22 <copumpkin> holmak: damn right
18:51:30 <Cale> But the composition map must be a natural transformation.
18:52:04 <holmak> I got that from some paper, that started by saying something like "Typical functional languages require a PhD to write effectively!*"
18:52:15 <holmak> * Except for Haskell, which requires two.
18:52:25 <ivanm> holmak: to write the language or to write code in that language?
18:52:38 <tensorpudding> haskell doesn't require a ph.d
18:52:43 <tensorpudding> though it might require a math minor
18:52:44 <holmak> I think just in the langugage? It was a long time ago.
18:52:59 <holmak> Hyperbole, certainly, but entertaining
18:53:01 <thunderbolt> holmak: Does it count if one Ph.D. is in biology and the other in electrical engineering ;-)
18:53:08 <holmak> haha
18:53:11 <Saizan> ah, subcategory seem to require the morphisms are a subset of the morphisms in the original category, here we're changing them completely
18:53:38 <Cale> Saizan: right
18:54:06 <PopeDavid> holmak: can I PM you?
18:55:19 <junmin> @src &&
18:55:19 <lambdabot> True  && x = x
18:55:20 <lambdabot> False && _ = False
18:55:52 <MoALTz> those are fun when the 2nd parameter is undefined
18:55:55 <sileni> hello everyone :D
18:56:07 <holmak> PopeDavid: sure
18:57:01 <copumpkin> the best is the symmetrically strict versions of that in unamb
18:57:04 <orbitz> If I want to do something where I have a common interface to doing things but th eunderlying implementation differs, would I wan to make a typeclass with the functions i wan to differ?
18:57:28 <orbitz> in this case I am trying to have an interface to controlling a cluster, but the backend software my program commincates wiht will have slightly different protocosl
18:57:36 <copumpkin> orbitz: probably, and maybe an associated type to deal with differing underlying data representations too
18:57:48 <Saizan> orbitz: you might just want to use a record of functions
18:58:13 <Saizan> orbitz: unless the type-indexing that typeclasses offer is natural for the situation
18:58:41 <orbitz> copumpkin: associated type == record?
18:59:04 <copumpkin> class Moo a where data Oink a :: *; ...
18:59:11 <ivanm> copumpkin: :o
18:59:23 <ivanm> why do moo-ing as need to know how to oink?
19:01:21 <sileni> no one says hi to me i'm going to go cry
19:01:29 <copumpkin> sileni: hi!
19:01:34 * ivanm waves aimlessly in sileni's general direction
19:01:36 <orbitz> I guess a record type would probably work fine
19:01:38 <sileni> copumpkin: thank you
19:02:05 * sileni waves back in the opposite direction of ivanm... i hates you!
19:02:14 * sileni was just kidding 
19:02:23 <ivanm> *shrug* you can hate me, doesn't bother me
19:02:35 <sileni> ivanm: ok i will continue to hate
19:02:38 <luqui> ivanm, how can you wave aimlessly in a direction?
19:03:05 <orbitz> I also am intersted in an asynchronous interface ot this. so i can do like inst1 <- startInstance options; inst2 <- startInstance otheropations and they will happen concurrently, any suggestiosn to wher eto look to wrap my mind around thi sn haskell?
19:03:23 <ivanm> luqui: "waving aimlessly" is a description of how I wave, not where I wave
19:03:28 <ivanm> @wn aimlessly
19:03:30 <lambdabot> *** "aimlessly" wn "WordNet (r) 2.0"
19:03:31 <lambdabot> aimlessly
19:03:31 <lambdabot>      adv : in an aimless manner; "he wandered around aimlessly" [syn: {without
19:03:31 <lambdabot>            aim}]
19:03:42 <luqui> wow what an enlightening definition :-P
19:03:45 <ivanm> heh
19:03:56 <ivanm> kinda "lazily", as in I can't be bothered waving properly
19:04:14 <luqui> maybe apathetically
19:04:27 <luqui> hmm... that makes me want to design an apathetic programming language
19:05:05 <kniu> would a pure type system subsume qualified types?
19:05:08 <thunderbolt> luqui: would that be like Java2000?
19:05:10 <BMeph> luqui: Eh. Why bother? ;p
19:05:38 <luqui> no no no BMeph, the *language* is apathetic so you don't have to be
19:08:07 <ivanm> luqui: could be
19:08:37 <tensorpudding> i'd prefer a misanthropic language
19:08:42 <ivanm> what's the difference between ignorance and apathy? "I don't know and I don't care."
19:08:43 <ivanm> ;-)
19:09:06 <EvanCarroll> god the default haskell style is wtf
19:09:11 <copumpkin> ?
19:09:13 <toast-opt> ?
19:09:15 <EvanCarroll> how come else, is indented further than if
19:09:23 <toast-opt> it is?
19:09:32 <ivanm> EvanCarroll: in monadic blocks, then and else have to be indented further
19:09:34 <toast-opt> wait, why are you writing 'if'? ;)
19:09:39 <EvanCarroll> http://pastie.org/710715
19:09:41 <ivanm> toast-opt: why not?
19:09:50 <ivanm> EvanCarroll: otherwise, they could be seen as being 3 separate statements
19:10:02 <EvanCarroll> eck
19:10:03 <ivanm> by indenting the then and else, the parser can tell that they're part of the if statement
19:10:11 <ivanm> for non-monadic code, they don't have to be
19:10:22 <toast-opt> ivanm, sorry, i'm a beginner and really ought not to be reading it, but i found the "evolution of a haskell programmer" really funny
19:10:24 <ivanm> EvanCarroll: right, you're writing monadic code
19:10:28 <idnar> s/monadic code/code in a do block/
19:10:31 <ivanm> toast-opt: heh
19:10:36 <ivanm> idnar: right
19:10:36 <EvanCarroll> it looks shitty
19:10:43 <ivanm> EvanCarroll: *shrug*
19:11:01 <ivanm> idnar: the latter implies the former, but not the other way round :s
19:11:01 <EvanCarroll> else if / else, is an alternative to if
19:11:06 <idnar> ivanm: indeed
19:11:13 <ivanm> toast-opt: I still don't get most of those "examples" ;-)
19:11:17 <toast-opt> heh
19:11:23 <ivanm> EvanCarroll: hmmm?
19:11:32 <toast-opt> half of them really want to be C++ template metaprograms
19:11:32 <ivanm> you want to use / to mean then?
19:11:35 <ivanm> but it means division!
19:11:39 <toast-opt> then they could use built in operator + instead
19:11:51 <MoALTz> `div` for integer division
19:11:53 <ivanm> EvanCarroll: and your code is wrong
19:12:01 <EvanCarroll> ?
19:12:04 <EvanCarroll> it isn't my code
19:12:07 <ivanm> EvanCarroll: "return" in Haskell isn't the same as return in imperative langs
19:12:18 <ivanm> fine, that code is wrong
19:12:21 <EvanCarroll> right that is the lesson of the wiki
19:12:28 <EvanCarroll> it is right to be wrong, when that is the lesson
19:12:29 <ivanm> and what happens if compare (read guess) num /= EQ?
19:12:31 <jmcarthur> why the if instead of just using the case?
19:12:33 <toast-opt> return :: a -> IO a, right?
19:12:41 <EvanCarroll> First of all, if you guess correctly, it will first print "You win!," but it won't exit, and it will check whether guess is less than num. Of course it is not, so the else branch is taken, and it will print "Too high!" and then ask you to guess again.
19:12:42 <copumpkin> a -> m a
19:12:42 <ivanm> they should have the LT and GT cases there rather than the if statement?
19:12:46 <ivanm> jmcarthur: exactly
19:12:50 <EvanCarroll> On the other hand, if you guess incorrectly, it will try to evaluate the case statement and get either LT or GT as the result of the compare. In either case, it won't have a pattern that matches, and the program will fail immediately with an exception.
19:12:52 <ivanm> toast-opt: well, not quite
19:12:55 <toast-opt> co, oh, so it can become any monad?
19:12:55 <ivanm> copumpkin: even that is wrong!
19:13:00 <ivanm> toast-opt: yup
19:13:05 <copumpkin> ivanm: I was too lazy to write the constraint
19:13:21 <ivanm> copumpkin: heh
19:13:24 <copumpkin> :P
19:13:28 <toast-opt> i heard there were monads that can run backwards, implement backtracking and continuations, and even implement ambi
19:13:31 <ivanm> toast-opt: but it has to be the same monad as the surrounding monad...
19:13:45 <ivanm> toast-opt: well, to an extent I think...
19:13:50 <toast-opt> ivanm, that's useful to know.  is it part of 'do' then?
19:13:57 <ivanm> toast-opt: the parsers usually have a form of backtracking for example
19:14:02 <ivanm> toast-opt: part of the definition of a monad
19:14:04 <ivanm> @src Monad
19:14:04 <lambdabot> class  Monad m  where
19:14:04 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:14:04 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:14:04 <lambdabot>     return      :: a -> m a
19:14:04 <lambdabot>     fail        :: String -> m a
19:14:16 <ivanm> in general, you should never use fail
19:14:24 <toast-opt> oh, hey, that's what i was looking for the other day
19:14:26 <ivanm> since many monads cheat and have fail = error
19:14:43 <toast-opt> >>= is what you use to separate two 'statements' on a single line, right?
19:14:46 <tensorpudding> fail is fail
19:14:52 <aavogt> > fail "but sometimes it's ok" :: []
19:14:53 <lambdabot>   `[]' is not applied to enough type arguments
19:14:53 <lambdabot>  Expected kind `?', but `[]' h...
19:15:00 <aavogt> > fail "but sometimes it's ok" :: [] a
19:15:00 <tensorpudding> >>= is for binding
19:15:01 <lambdabot>   []
19:15:05 <toast-opt> wait, the type of >> looks more right
19:15:25 <toast-opt> i have two statements... statements are really 'm a' values
19:15:26 <tensorpudding> it takes the result from the left, unwraps it and uses it as input on the right
19:15:33 <ivanm> toast-opt: >>= takes the result of the monad value on the left and feeds it into the monadic function on the right
19:15:36 <MoALTz> i wonder if >> cheats sometimes (modifies b)
19:15:36 <toast-opt> like, 'IO String' for read functions
19:15:37 <tensorpudding> @type (>>=)
19:15:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:15:43 <ivanm> toast-opt: >> just sequences two monadic statements/actions
19:15:46 <ivanm> MoALTz: nope
19:15:51 <ivanm> MoALTz: how can it in general?
19:16:05 <MoALTz> @src >>
19:16:05 <lambdabot> m >> k      = m >>= \_ -> k
19:16:18 <tensorpudding> >> is like >>= but it ignores the value of the input to the second function
19:16:22 <MoALTz> cannot overload that?
19:16:23 <toast-opt> ivanm, thx, i was looking for that last night.  i wrote a pure function that could operate on things, and then needed 'loop' to run through its output
19:16:37 <ivanm> MoALTz: you can in the monad instance definition
19:16:45 <toast-opt> ivanm, but i couldn't figure out how to write multiple statements when defining functions in the ghci prompt
19:16:46 <ivanm> tensorpudding: well, the second arg isn't a function usually...
19:17:00 <ivanm> you also have sequence...
19:17:03 <pastah_rhymez> if i make a type (data Letter = A | B | C ... deriving Enum) and then call fromEnum, at what speed will fromEnum run?
19:17:09 <tensorpudding> > [1..10] >>= return
19:17:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:17:36 <pastah_rhymez> O(1) or O(n)? (n = |Letter|)
19:17:48 <toast-opt> tensorpudding, thx
19:18:15 <toast-opt> oh, oh, >>= is like F#'s |>  operator
19:18:19 <tensorpudding> > [1..10] >>= return . (: [])
19:18:20 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
19:18:28 <ivanm> pastah_rhymez: I think O(n)
19:18:36 <ivanm> > [1..10] >>= return . return
19:18:36 <pastah_rhymez> ivanm: awww man, that sucks
19:18:37 <lambdabot>   No instance for (GHC.Show.Show (m t))
19:18:37 <lambdabot>    arising from a use of `M3051624731...
19:18:46 <Axman6> pastah_rhymez: i'd expect O(1), but even so, you'd need a hell of a lot of constructors for it to make a difference (think thousands)
19:18:51 <ivanm> > [1..10] >>= return . return :: [Maybe Int]
19:18:52 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
19:19:03 <tensorpudding> (:[]) is the monkeyface operator
19:19:28 <pastah_rhymez> Axman6: i was thinking along the lines of having 10~20, but having thousands of values running through the same function
19:19:40 <Axman6> it shouldn't cost very much
19:19:51 <ivanm> yeah
19:19:54 <Axman6> pastah_rhymez: optimise after writing your code
19:20:01 <pastah_rhymez> and for speed, the best thing i can come up with is (funArray ! fromEnum myType)
19:20:02 <ivanm> pastah_rhymez: ghc _might_ do fancy stuff under the hood
19:20:08 <tensorpudding> ivanm: oh man two monads at once
19:20:13 <ivanm> note that modules with really large data structures take a _long_ time to compile :(
19:20:25 <Axman6> pastah_rhymez: why not have the index type of funArray be Letter?
19:20:29 <toast-opt> ivanm, why's that?
19:20:30 <ivanm> > [1..10] >>= return . return :: [Either String Int]
19:20:31 <lambdabot>   [Right 1,Right 2,Right 3,Right 4,Right 5,Right 6,Right 7,Right 8,Right 9,Ri...
19:20:37 <Axman6> funArray :: Array Letter a
19:20:40 <pastah_rhymez> Axman6: true
19:20:40 <tensorpudding> @src mapM
19:20:40 <lambdabot> mapM f as = sequence (map f as)
19:20:42 <ivanm> toast-opt: presumably because it has to make a large dictionary or something
19:20:44 <ivanm> dunno why
19:20:50 <toast-opt> mm
19:21:09 <ivanm> hmmm... we need (.) and ($) on the type-level! :p
19:21:10 <tensorpudding> @type mapM
19:21:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:21:17 <pastah_rhymez> Axman6: but that doesn't change that conversion from Letter to some Int-y structure should be O(1)
19:21:19 <toast-opt> hmm, maybe it's dealing with environment p-lists instead of something like a hash table -- because a mutable hash table is less pure
19:21:19 <ivanm> rather than doing Foo (Bar (Baz a))
19:21:32 <Axman6> pastah_rhymez: it probably is
19:21:40 <tensorpudding> mapM (return . toUpper) [1..10]
19:21:50 <tensorpudding> wait whoops
19:21:59 <tensorpudding> mapM (return . toUpper) ['a','b','c']
19:22:00 <Axman6> toUpper on numbers? o.O
19:22:04 <tensorpudding> > mapM (return . toUpper) ['a','b','c']
19:22:05 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
19:22:05 <lambdabot>    arising from a use ...
19:22:12 <dancor> for which natural numbers k is it known that there exists some decision problem which is O(n^k) and not O(n^(k-1)).  does it depend what kind of turning machines you are using?
19:22:25 <EvanCarroll> return returns an io object that returns the value specified
19:22:27 <EvanCarroll> wtf does that mean
19:22:35 <EvanCarroll> Cale: !!! elegant definition man
19:22:36 <pastah_rhymez> Axman6, ivanm: have you seen this yet? http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
19:22:37 <ivanm> EvanCarroll: it just wraps a value in the monad
19:22:40 <EvanCarroll> gah
19:22:47 <Cale> EvanCarroll: IO actions have results, yeah?
19:22:49 <ivanm> EvanCarroll: it doesn't actually exit the function like C, etc. do
19:22:52 <tensorpudding> > return "foo" >>= putStrLn
19:22:53 <lambdabot>   <IO ()>
19:22:54 <EvanCarroll> yea.
19:23:07 <ivanm> pastah_rhymez: don't think so
19:23:09 <EvanCarroll> not sure what a monad is
19:23:10 <Cale> EvanCarroll: (return v) is the IO action which does nothing when executed, and results in v.
19:23:15 <tensorpudding> that should write "foo" normally
19:23:20 <EvanCarroll> this tutorial dodges the definition of it, and just tells me were using it
19:23:26 <Cale> EvanCarroll: That's okay, you don't need to :)
19:23:29 <ivanm> pastah_rhymez: I haven't had to think of Haskell from an OO perspective ;-)
19:23:29 <toast-opt> > print "hello world"
19:23:30 <lambdabot>   <IO ()>
19:23:33 <Axman6> EvanCarroll: the definition of IO isn't important
19:23:37 <pastah_rhymez> it talks about efficient ways to write code for state-y structures
19:23:39 <EvanCarroll> you know, someone needs to write a haskell tutorial that doesn't pussy foot lol
19:23:41 <ivanm> toast-opt: lambdabot doesnt' like IO
19:23:43 <Axman6> since it's different in each compiler
19:23:52 <toast-opt> ivanm, that's very much in character, i think
19:23:56 <Cale> EvanCarroll: http://www.haskell.org/haskellwiki/Introduction_to_IO
19:24:13 <Axman6> EvanCarroll: you need to learn to stoip thinking so low level, and pay attention to what those tutorials are saying ;)
19:24:14 <Cale> EvanCarroll: That doesn't explain monads, but explains how we put IO actions together.
19:24:58 <toast-opt> wait.. because haskell is non-strict, shouldn't it be possible to write for, while, etc... all my favorite loops?
19:25:06 <Cale> toast-opt: nonsense :)
19:25:09 <BMeph> tensorpudding   That's the "left identity" of a Monad. Well, it's the form of it, anyway. :)
19:25:21 <toast-opt> cale, um, i didn't let out an important secret did i?
19:25:21 <Cale> toast-opt: er, "shouldn't it" not "it shouldn't" :)
19:25:29 <tensorpudding> BMeph: yes, a lot of the things i wrote are pretty trivial
19:25:31 <Cale> toast-opt: Yes, it's possible.
19:25:42 <Axman6> @src mapM
19:25:43 <lambdabot> mapM f as = sequence (map f as)
19:25:44 <tensorpudding> return x >>= f = f x
19:25:52 <Cale> toast-opt: And it's possible to write them generally so that they work in any monad.
19:25:54 <toast-opt> cale, thx.  and no worries.  i'll try to avoid using my newfound powers for evil.
19:26:07 <Cale> toast-opt: It's not evil. Go for it :)
19:26:10 <toast-opt> cale, that was going to be my next question, thx.
19:26:30 <Saizan> forM is done :)
19:26:36 <Cale> :t forM
19:26:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
19:27:14 <toast-opt> oh, hey, i wrote that the other day
19:27:19 <toast-opt> or tried
19:27:22 <Cale> Takes a list of things to iterate over, and a loop-body which is a function from the things being iterated over to actions to be performed, and produces an action which collects the results of the iterations.
19:27:33 <thunderbolt> Silly question. In the Haskell culture are map/filter preferred or list comprehensions? In general...
19:27:53 <copumpkin> thunderbolt: whichever is shorter for what you need to do ;)
19:27:53 <Cale> thunderbolt: Either. Whatever seems clearest in the situation.
19:27:54 <EvanCarroll> Cale++
19:28:17 <thunderbolt> copumpkin, Cale, thanks. That's the answer I was looking for :)
19:28:31 <Cale> If you have a lot of nested concatMaps, consider using a list comprehension or do-notation.
19:28:45 <BMeph> Other languages tell you that there are many ways to skin a cat. Haskell programmers prefer petting cats and letting them run free. ;p
19:28:53 <copumpkin> :O
19:28:55 <copumpkin> meow
19:29:04 <thunderbolt> BMeph: hehe :)
19:29:14 <BMeph> :)
19:30:50 <toast-opt> i hope these questions aren't getting monotonous... one more, on ghci this time
19:31:07 <toast-opt> is there a way to disable readline.  using on windows, and its readline isn't as smart as i'd like
19:31:20 <Cale> toast-opt: What version of GHC are you using?
19:31:27 <aavogt> the newest ghc doesn't use readline
19:31:30 <toast-opt> 6.10.4
19:31:37 <Cale> toast-opt: GHC hasn't used readline since 6.8.x
19:31:39 <toast-opt> oh, it has its own built-in logic?
19:31:40 <tra26> Hello, I am creating a program to play Pentago using a bitboard. Profiling shows most of the time is spent in the commonBits method (and functions that call it) show here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12978#a12978 is there anything obviously wrong with this or am I just profiling incorrectly
19:31:46 <Cale> It uses Haskeline.
19:31:54 <toast-opt> heh.  can i disable that?
19:32:00 <toast-opt> it seems to eat ctrl-arrow
19:32:08 <Cale> ctrl-arrow?
19:32:10 <toast-opt> makes it harder to navigate the line i'm editing
19:32:27 <toast-opt> ctrl+left and ctrl+right.  left one word, right one word
19:32:44 <Cale> There might be a way to bind those keys
19:33:05 <pastah_rhymez> toast-opt: yeah, CTRL-*arrow* is great for hacking
19:33:18 * pastah_rhymez uses it all the time in gnome-terminal
19:33:34 <Axman6> tra26: i'd use guards instead of nested ifs
19:33:46 <Cale> http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
19:33:53 <toast-opt> hmm, hugs doesn't seem to have this problem
19:33:58 <MoALTz> didn't think that worked in ghci
19:34:08 <tra26> Axman6: I will give that a try
19:34:12 <Twey> Try M-b and M-f
19:34:34 <Cale> That page actually tells you exactly how to configure Ctrl-left and Ctrl-right to skip words as an example.
19:34:36 <Axman6> tra26: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12978#a12980
19:34:37 <Twey> Windows-style keybindings generally don't work in console apps
19:35:06 <tra26> Axman6: thanks
19:35:17 <toast-opt> twey, really?  not my experience.
19:35:19 <Axman6> tra26: also, is the 1* needed?
19:35:29 <toast-opt> i think if you use the right console apis, doskey provides history too
19:35:49 <toast-opt> (or, pseudo doskey.  these days that's built into cmd i'm sure)
19:36:09 <toast-opt> i really should get around and learn all the unix console hotkeys
19:36:31 <tra26> Axman6: hm.. Probably not
19:37:51 <Axman6> tra26: you should also try putting cost centers into the code to see what's being called the most
19:38:16 <tra26> Axman6: Thanks, changed it to (bit 63) and commonBits dropped and I will try that also
19:38:33 <Axman6> oo, good plan
19:38:41 <Axman6> i'm not used to working with Bits
19:39:40 <pastah_rhymez> Cale, toast-opt: i'm reading that keybindings-page but i don't understand were to put my stuff :(
19:39:41 <tra26> I tried using 2^x to arbitrary values and haskell doesn't seem to like it very much (performance wise)
19:40:19 <Cale> I'm not sure where the .haskeline file goes on windows, but on linux, it goes in your home directory
19:40:46 <toast-opt> typically that means %USERPROFILE% on windows
19:41:08 <junmin> type M = ([a],[b]) , how can get [a] returned in hakell?
19:41:18 <copumpkin> junmin: fst
19:41:21 <Axman6> :t fst
19:41:22 <lambdabot> forall a b. (a, b) -> a
19:41:23 <toast-opt> .haskeline you said?
19:41:34 <Cale> toast-opt: you didn't see that?
19:41:39 <Cale> http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
19:41:40 <pastah_rhymez> hoho!! It works!!
19:41:41 <toast-opt> cale, call it .haskeline?
19:41:45 <Cale> toast-opt: yeah
19:41:50 <pastah_rhymez> .paste
19:41:55 <pastah_rhymez> @paste
19:41:55 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:42:01 <junmin> :P how about [b]? snd ?
19:42:06 <junmin> :t snd
19:42:07 <lambdabot> forall a b. (a, b) -> b
19:42:11 <junmin> yeah
19:42:20 <junmin> thanks
19:42:33 <junmin> @src fst
19:42:33 <lambdabot> fst (x,_) =  x
19:42:57 <pastah_rhymez> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5063#a5063
19:43:13 <toast-opt> cale, that worked
19:43:21 <toast-opt> %USERPROFILE%/.haskeline
19:43:41 <toast-opt> that would be a useful default on windows
19:44:09 <mgsloan> hello! I am trying to use haskell llvm bindings.  I have installed llvm using pacman -S llvm, but i get this when I do ghci -package llvm:
19:44:10 <mgsloan> Loading package llvm-0.7.0.0 ... <command line>: can't load .so/.DLL for: LLVMSystem (libLLVMSystem.so: cannot open shared object file: No such file or directory)
19:44:47 <Axman6> mgsloan: do you habe libLLVMSystem.so on your system? (locaye libLL...)
19:45:59 <mgsloan> I have /usr/lib/llvm/LLVMSystem.a
19:46:47 <Axman6> then you probably need to tell cabalo-install where to find it, using --extra-lib-dirs and --extra-include-dirs
19:48:33 <ivanm> Axman6: "cabalo-install"? is that the italian version or something? :p
19:49:09 <Axman6> it's the thinkpad version
19:50:34 <ivanm> why thinkpad?
19:50:51 <copumpkin> :O
19:51:11 <Axman6> because that's what i'[m on atm, and i hate the keyboard
19:51:47 <ivanm> preflex: seen Baughn
19:51:48 <preflex>  Baughn was last seen on #haskell 11 hours, 10 minutes and 22 seconds ago, saying: ben0x539: By default.
19:51:50 <mgsloan> i'm on my thinkpad x61
19:51:55 <mgsloan> shift key is broken :/
19:52:25 <ivanm> @ask Baughn would you have any idea why indentation finds | to be an illegal token when defining a class method instance?
19:52:25 <lambdabot> Consider it noted.
19:52:43 <ivanm> Axman6: so you were key mashing?
19:52:46 <ivanm> ;-)
19:56:35 <tra26> so... strictness. I defined some cost centres as suggested by Axman6 (thanks again) and found that the board evaluation function (possibly combined with commonBits) is causing the problem.  I have pasted the evaluate function at :http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12983#a12984 if someone would be kind enough to point me in the right direction again, it would be very appreciated
19:57:05 <Axman6> i'll take a look in a sec, just replying to an email
19:57:44 * mgsloan svn checks out llvm and builds
19:59:52 <Axman6> tra26: add more cost centres to the let'd stuff
20:00:03 <iaefai> My friends! Does anyone know of a basic example of wrapping a C function in an existing project that I can find? Specifically, I need to write a function that accesses some windows api (that is easier to write a simple C function to handle the details), and be able to integrate it in the cabalized project.
20:00:04 <tra26> Axman6: aye aye
20:00:42 <Axman6> ivanm: give me a sec, and i might have something useful for you
20:00:56 <ivanm> Axman6: for me? :o
20:01:07 <Axman6> uh, yeah
20:01:09 <Axman6> no
20:01:10 <ivanm> Axman6: you mean iaefai?
20:01:11 <Axman6> >_<
20:01:13 <Axman6> for iaefai
20:01:17 <copumpkin> same thing
20:01:21 <Axman6> quit confusing me and change your nick
20:01:23 <Axman6> !
20:01:23 <ivanm> @slap copumpkin
20:01:23 * lambdabot clobbers copumpkin with an untyped language
20:01:30 <copumpkin> ouch
20:01:47 <byorgey> woah, that's below the belt
20:01:50 <iaefai> Muhahahahaha, changes nick
20:02:08 <holmak> @help slap
20:02:08 <lambdabot> slap <nick>. Slap someone amusingly.
20:02:14 <holmak> amazing!
20:02:15 <copumpkin> @slap slap
20:02:15 <lambdabot> stop telling me what to do
20:02:16 <Axman6> iaefai: i found this quite useful, but it may not be all that helpful for you: http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
20:02:23 <centrinia> @slap copumpkin
20:02:23 * lambdabot places her fist firmly on copumpkin's jaw
20:02:35 <ivanm> obviously copumpkin isn't lambdabot's favourite today...
20:02:39 <copumpkin> :(
20:02:47 <Axman6> @slap ivanm
20:02:48 * lambdabot hits ivanm with an assortment of kitchen utensils
20:03:27 <iaefai> Axman6, it will help with everything but the integration with cabal
20:03:45 <toast-opt> bonus, is there a traditional index for LYAHFGG?
20:04:01 <Axman6> looks welsh
20:04:11 <copumpkin> CYMRU
20:04:36 <Axman6> good timing BONUS
20:04:39 <toast-opt> oh, didn't mean to wake you up
20:04:48 <toast-opt> or, wait, weird coincidence?
20:04:59 <Axman6> nah, you work him up
20:05:00 <Axman6> jerk
20:05:02 <Axman6> ::P
20:05:13 <Axman6> yes, jerk :: P
20:05:21 <ivanm> s/work/woke/
20:05:26 <toast-opt> what is the type P?
20:05:34 <Axman6> you tell me
20:06:12 <ivanm> @hoogle P
20:06:13 <lambdabot> Language.Haskell.ParseMonad data P a
20:06:13 <lambdabot> Text.Html p :: Html -> Html
20:06:13 <lambdabot> Text.XHtml.Frameset p :: Html -> Html
20:06:14 <Axman6> tra26: i'd start by makings less strict. also, you may find that using the Data.List.Fusion stuff might make things faster
20:07:11 <tra26> Axman6: added the cost centres and posted the results at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12983#a12985 I will try the stream fusion stuff next Thanks again
20:07:20 <Axman6> tra26: and length $! filter... won't do much
20:07:47 <centrinia> :t p
20:07:48 <lambdabot> Expr
20:07:53 <tra26> Axman6: I was scraping at walls
20:08:49 <Axman6> tra26: I assume you tried to write the code, then speed it up later right?
20:10:19 <tra26> Axman6: How did you guess
20:10:34 <Axman6> well, i was hoping :)
20:10:43 <mike8901> Can someone explain to me exactly how to *use* monads? I've made up a Monad equivalent to the State monad, but I'm a little confused about how to put it all together in a toyinterpreter I'm writing.
20:11:08 <Axman6> i'd remove the seq from the evaluate0 line. it's useless since commonBits is already strict in its arguments
20:11:15 <copumpkin> mike8901: I feel like you're jumping in the deep end with monads
20:11:23 <Axman6> me too
20:11:38 <Axman6> i still can't use the State monad. it confuses me >_<
20:11:48 <Axman6> not that i've ever tried too hard
20:12:00 <tra26> Aye, Axman6
20:12:01 <ivanm> Axman6: I've used it, mainly to avoid having to pass extra variables around
20:12:07 <ivanm> (well, a custom State monad)
20:12:47 <mike8901> It's not the idea of Monads that is confusing, it's just the syntax.
20:12:47 <Axman6> i don't have a problem passing things around explicitly
20:13:17 <Axman6> mike8901: i find that State is a rather confusiong monad
20:13:29 <ivanm> I had 5 or 6 different vars, all but one of which were constant
20:13:32 <holmak> State is a serious monad for deadly serious people
20:13:38 <mike8901> :P
20:13:43 <ivanm> for recursive data structure stuff
20:13:57 <mike8901> the issue is that I have a toy interpreter that takes in a "store" parameter, and potentially modifies the "store" and returns it back
20:14:04 <ivanm> mike8901: :o I find the syntax to be the easiest bit!
20:14:34 <holmak> mike8901: I had the same problem; have you tried using fold?
20:14:43 <mike8901> I'd like to learn the State monad :)
20:15:04 <Axman6> tra26: i also wonder if you could write a more efficient maxChain function (one that's O(n*log n) instead of O(n))
20:15:15 <ivanm> IIRC, RWH has good coverage of State
20:15:32 <ivanm> Axman6: ummm.... O(n) is better than O(n*log n) ...
20:17:37 <Axman6> wait, hmm
20:18:06 <Axman6> well, what i was thinking of would involve less work than foldl' max 0 xs
20:18:58 <Axman6> this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12986#a12986
20:19:02 <luqui> Axman6, that's impossible, no?
20:19:16 <Axman6> hmm, maybe it is
20:19:20 <Axman6> i dunno
20:19:47 <luqui> got to touch every number at least once
20:19:50 <luqui> otherwise you might miss one
20:20:24 <Axman6> yeah, maybe what i posted is slower
20:20:41 <luqui> techniques like that are good if you need to parallelize
20:21:09 <Axman6> true
20:21:26 <tra26> Axman6: haskell complains about infinite types
20:21:41 <Axman6> yeah, i can see why, heh
20:21:42 <tra26> and I need to learn to scrol
20:21:48 <tra26> with two l's
20:22:21 <byorgey> mike8901: so instead of your interpreter having type   Store -> (Result, Store), give it type  State Store Result
20:22:25 <byorgey> (which is isomorphic)
20:22:25 <Axman6> try http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12986#a12987
20:22:47 <Axman6> @unmtl State Store Result
20:22:48 <lambdabot> Store -> (Result, Store)
20:23:55 <byorgey> mike8901: also, is there a particular reason you made your own version of the state monad instead of using the standard one?
20:24:06 <mike8901> just to understand what was going on under the covers
20:24:30 <byorgey> mike8901: ok.  Have you implemented combinators like 'get', 'put', and 'modify'?
20:24:41 <mike8901> no
20:24:52 <byorgey> get :: State s s,  put :: s -> State s (),  modify :: (s -> s) -> State s ()
20:25:15 <byorgey> you don't really want to program directly in the details of the State monad
20:25:26 <byorgey> just implement those combinators and then use them for dealing with the state.
20:25:35 <mike8901> http://pastebin.ca/1683223
20:25:40 <mike8901> does that look good for the state monad
20:25:42 <mike8901> ?
20:26:31 <byorgey> mike8901: looks good to me.
20:27:19 <byorgey> mike8901: so now implement 'get' to return the current state, 'put' to replace the current state, and 'modify' to apply a function to the current state
20:27:45 <mike8901> can't I just do that inline in my interpreter?
20:27:54 <Axman6> tra26: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12986#a12988 is what i was after, but i have a feelingt it probaby will be slower than your foldl' max 0
20:28:19 <byorgey> mike8901: of course you could.  but (a) it's a good exercise to implement such combinators, and (b) much more convenient to work in terms of those than directly in terms of the underlying State functions.
20:28:44 <mike8901> hrmph, HUGS/GHCI are both giving me weird errors about  parse error on input `|' :/
20:28:51 <byorgey> they let you forget about how State is actually implemented and just work in terms of the intended semantics.
20:28:56 <mike8901> which is bizzare - the code was working before earlier
20:28:58 <mike8901> hmm ok
20:29:17 <narens> So I have a very simple typeclass of the form class Cache c where
20:29:18 <narens>     remove :: Ord k => c -> k -> c
20:29:38 <byorgey> mike8901: maybe an indentation issue?  you aren't using tabs in your code, are you?
20:29:46 <narens> and I have an instance data DCache k = DCache (M.Map k Dynamic)
20:29:47 <narens>  
20:29:47 <narens> instance Ord k => Cache (DCache k) where
20:29:47 <narens>     remove (DCache ch) k = DCache (M.delete k ch)
20:29:55 <mike8901> I am, but I'm using emacs haskell-mode which *should* take care of everything, right?
20:30:01 <ivanm> mike8901: what are you doing in ghci/hugs that it complains?
20:30:10 <narens> but haskell is complaining about k being a rigid type variable and i don't understnad why
20:30:11 <ivanm> mike8901: not automagically
20:30:15 <iaefai> So has anyone taken a serious look at this 'google go'?
20:30:18 <ivanm> it just helps you indent, doesn't do it for you
20:30:24 <byorgey> narens: that won't work, because the type of 'remove' says that it will work for *any* type k
20:30:26 <mike8901> I'm just declaring a data type
20:30:28 <Cale> mike8901: If it's putting hard tabs in your source files, that's still bad.
20:30:33 <byorgey> narens: that is, the *caller* of 'remove' gets to choose the type k
20:30:38 <mike8901> Cale: I don't think it is...
20:30:42 <Cale> mike8901: (you want spaces only)
20:30:44 <Cale> okay
20:30:47 <byorgey> narens: but your implementation only works for one specific type, depending on the type of the DCache
20:30:51 <ivanm> Cale: I think it re-binds the tab key to do space stuff
20:30:56 <tra26> Axman6: gotcha, I am making commonBits ugly (examining 8 bits at a time) and hoping it will do some good
20:31:01 <Cale> ivanm: Yeah, I'd hope so :)
20:31:05 <ivanm> but you can still do C-q <tab> to insert a literal tab character...
20:31:16 <narens> byorgey: so, you are saying that the problem is because the instance is putting a restriction on k?
20:31:31 <ivanm> narens: the problem is that the instance _isn't_ putting a restriction on k
20:31:39 <ivanm> or at least a sufficient restriction on k
20:31:45 <narens> byorgey: but, I have defined it to be Ord
20:31:53 <ivanm> narens: you have to restrict what k is based upon what c is
20:32:24 <byorgey> narens: you have two options, multi-parameter type classes + functional dependencies, or associated types
20:32:31 <ivanm> narens: redefine your class to be something like: class Cache (c k) where
20:32:44 <byorgey> ivanm: I think you mean  class Cache c k where ...
20:32:50 <narens> ivanm: I still don't seem to understand the problem
20:33:14 <ivanm> narens: when you talk about c, is there a particular key type that it can have?
20:33:17 <byorgey> narens: it's a bit subtle.  did you understand my sentences above about the type of 'remove' saying it will work for *any* k, that the caller gets to choose?
20:33:18 <ivanm> because your class doesn't say so
20:33:44 <narens> well i wanted it to be any key type for the map
20:33:47 <byorgey> narens: but any given cache can only remove things of one type: the type of things it happens to contain.
20:33:56 <ivanm> oh, wait
20:34:06 <ivanm> class Cache c where... remove :: c k -> k -> c k
20:34:20 <ivanm> maybe look at how FGL does its classes, etc.
20:34:31 <byorgey> oh, yeah, that's a much better solution, actually =)
20:34:39 <ivanm> narens: look at your DCache type; do you store the key type in there?
20:34:45 <ivanm> (hint: you do!)
20:34:54 <narens> really? how
20:34:56 <ivanm> narens: so you have to let the _class_ know about that key type
20:35:06 <mike8901> byorgey: Issue turned out to be a capitalized "Data" ;)
20:35:08 <ivanm> narens: ummm, wait
20:35:15 <ivanm> narens: you use Map k for your DCache type
20:35:19 <narens> yea
20:35:32 <ivanm> data DCache k = DCache (M.Map k Dynamic)
20:35:36 <narens> yes
20:35:41 <ivanm> narens: so what you have to do is let the class know about that k
20:35:53 <mike8901> byorgey: So what exactly do those methods do?
20:35:56 <narens> what do you mean by let it know?
20:36:06 <ivanm> byorgey: its what I was wanting before with the class Foo (c k)
20:36:20 <byorgey> ivanm: ?
20:36:34 <ivanm> narens: http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Graph.html#4
20:36:40 <byorgey> are we talking about something like   class Cache c where  remove :: Ord k => c k -> k -> c k  ?
20:37:02 <byorgey> it seems like that should work since DCache is polymorphic in the type of the key
20:37:03 <ivanm> byorgey: when I did class Cache (c k), I was aiming towards having remove :: c k -> k -> c k
20:37:09 <ivanm> just couldn't remember how to specify it properly
20:37:13 <byorgey> ok, right
20:37:37 <narens> ah, so you saying the restriction on k has to be at the class level?
20:37:38 <ivanm> narens: see how the Graph class lets its functions know what the node and edge labels (a and b respectively) are?
20:37:42 <ivanm> narens: YES!
20:37:47 <narens> gotcha!
20:38:12 <ivanm> narens: so you have your class: class Cache c where ...
20:38:22 <ivanm> and then the function is: remove :: c k -> k -> c k
20:38:27 <ivanm> well, put the Ord there
20:38:32 <ivanm> in remove
20:39:05 <Veinor> blah, i didn't know that MemoTrie existed
20:39:05 <byorgey> what??  the k is not at the class level.  I don't understand what you're saying.
20:39:07 <ivanm> narens: otherwise, you could be using (DCache Int), but the remove function would think that using a key type of Bool would be valid
20:39:18 <ivanm> byorgey: you have to mention the relevant k in the class
20:39:23 <ivanm> (I think that's what narens is saying)
20:39:28 <narens> i was trying to follow this from gentle introcution to haskell: Class methods may have additional class constraints on any type variable except the one defining the current class. For example, in this class:
20:39:28 <narens>  
20:39:28 <narens> class C a where
20:39:28 <narens>   m                     :: Show b => a -> b
20:39:49 <byorgey> ivanm: what do you mean by 'mention the relevant k in the class'?
20:40:07 <ivanm> byorgey: he has to relate the k to the data type he's instantiating the class on
20:40:23 <ivanm> byorgey: I think all three of us are confusing each other by our own terminology :p
20:41:01 <junmin> data Xdata = A String | B string .... in a function which receives a Xdata as parameter how to verify if it's A String or B String?
20:41:41 <BMeph> junmin: That's what we call "pattern matching". :)
20:41:55 <ivanm> foo (A s) = ...; foo (B s) = ...
20:42:03 <Axman6> OM NOMNOMNOM MI GORENG!
20:42:15 <ivanm> "goreng"?
20:42:25 <narens> thats malaysian noodles
20:42:35 <Axman6> that's what oit says on the packet
20:43:24 <junmin> BMeph: ivanm: thanks!! hahah here a newbie :P
20:43:41 <junmin> I read that before...:|
20:43:52 <junmin> but forgotten
20:44:01 <ivanm> Axman6: "oit"? :p
20:44:04 <Axman6> it
20:44:17 <Axman6> quit nitpicking
20:44:30 <ivanm> I thought you were going Kath-and-Kim-y on us or something...
20:44:31 <ivanm> ;-)
20:46:02 <narens> thanks people!
20:47:08 <mike8901> byorgey: So what exactly were the methods you suggested I define?
20:49:43 <byorgey> mike8901: get :: State s s  returns the current state
20:49:53 <byorgey> put :: s -> State s ()  replaces the current state
20:49:56 <mike8901> "current" state?
20:50:18 <byorgey> ok, forget the word "current"
20:50:24 <Axman6> takes whatever the state is when it
20:50:37 <mike8901> so what are its inputs?
20:50:38 <Axman6> it's called, and replaces it with the first argument to put
20:50:49 <byorgey> mike8901: what are what's inputs?
20:51:05 <mike8901> the "get" function - as listed it doesn't have any inputs
20:51:18 <byorgey> mike8901: right, it doesn't have any.
20:51:19 <ivanm> so it's technically a State action, not a function
20:51:30 <byorgey> but remember,  'State s s'  is actually a function underneath which takes the state as a parameter
20:51:34 <mike8901> now I'm confused...
20:51:34 * ivanm thought it was his job to nitpick, not mike8901's...
20:52:08 <Axman6> see, i told you state was confusing
20:52:15 <byorgey> mike8901: things of type  'State s a'  are compuatations which return a value of type 'a' and have implicit access to an underlying state, right?
20:52:36 <ivanm> Axman6: once you get your head around it, it isn't
20:52:37 <mike8901> sure
20:52:55 <byorgey> mike8901: so  'get' is an action which returns the implicit underlying state.
20:53:06 <mike8901> ok, that makes sense
20:53:17 <byorgey> it doesn't have any inputs because there aren't any -- you just say 'please get me the state'.
20:53:23 <ivanm> State s a <-- s is the value stored inside the state, a is the value you're currently dealing with/returning, etc. (i.e. the monadic value)
20:53:44 <ivanm> OH HAI, I CAN HAZ STATE PLZ? KTHNX BYE!
20:53:50 <ivanm> byorgey: like that ^^ ? :p
20:53:56 <byorgey> ivanm: yes, precisely
20:54:00 <byorgey> mike8901: so, how would you implement 'get'?
20:54:29 <ivanm> hint: what function converts a pure value into a monadic one?
20:54:35 <mike8901> so would it be: get State s = s ?
20:54:49 <byorgey> mike8901: no, get doesn't take arguments
20:54:51 * Twey almost answered that before seeing the ‘hint:’ in front of it.
20:55:04 <ivanm> Twey: heh
20:55:10 <byorgey> ivanm: I don't see what that has to do with 'get'
20:55:22 <Twey> mike8901: get :: State s
20:55:30 <byorgey> State s s
20:55:37 <Twey> Really?
20:55:41 <Twey> Oh, right, yeah
20:55:41 <byorgey> really
20:55:45 <Twey> Heh
20:55:47 <byorgey> =)
20:55:49 <ivanm> byorgey: well, I never said the hint would be helpful....
20:55:54 <byorgey> =P
20:55:56 <Twey> One for the internal state, one for the return value.
20:56:01 <byorgey> right.
20:56:01 * Twey laughs.
20:56:02 * ivanm had forgotten how to do get
20:56:03 <ivanm> ;-)
20:56:14 <ivanm> Twey: evil laugh?
20:56:16 <mike8901> so I'm still confused about "get"
20:56:17 <EvanCarroll> is there a documentation on haskell style?
20:56:25 <ivanm> EvanCarroll: as in a style guide?
20:56:29 <ivanm> @google haskell style guide
20:56:29 <lambdabot> No Result Found.
20:56:31 <mike8901> what does it *make*?
20:56:32 <ivanm> bah
20:56:38 <ivanm> mike8901: you have an internal hidden state value
20:56:48 <ivanm> but whats the point if you can't get it out to use?
20:56:50 <Twey> ivanm: Yes.  ‘I shall master this State monad, and then I shall RULE THE WORLD!  MUHAHAHAHAHA!’
20:56:53 <EvanCarroll> yea
20:56:56 <mike8901> ivanm: I understand that
20:56:57 <byorgey> mike8901: remember,  State s a  is a State constructor wrapped around a function  s -> (a, s)
20:57:07 <mike8901> yes, I understand all of that
20:57:10 <ivanm> mike8901: so the get action provides you with the state value
20:57:23 <mike8901> but how can it provide any information about the state if it doesn't take anything as input?
20:57:24 <byorgey> so what function would correspond to this idea of returning the current state?
20:57:42 <Axman6> EvanCarroll: my biggest style rule is don't use pointfree code where pointful code is clearer
20:57:42 <aavogt> you eventually have to provide that state
20:57:42 <byorgey> mike8901: it implicitly takes the state as an input
20:57:44 <mike8901> i.e. unless you give it a State, how can it tell what the hidden state is?
20:57:47 <mike8901> how?
20:57:48 <byorgey> mike8901: like every State action
20:57:51 <aavogt> @type runState
20:57:52 <lambdabot> forall s a. State s a -> s -> (a, s)
20:58:00 <ivanm> EvanCarroll: http://urchin.earth.li/~ian/style/haskell.html
20:58:14 <byorgey> mike8901: every State action is really a function  s -> (a,s) which takes the current state and gives you a computed value and a new state
20:58:23 <mike8901> byorgey: yes, I understand that completely
20:58:36 <byorgey> so  get :: State s s  is really like   get :: s -> (s,s)
20:58:57 <ivanm> EvanCarroll: http://www.cs.caltech.edu/courses/cs11/material/haskell/misc/haskell_style_guide.html
20:59:05 <byorgey> mike8901: with all due respect, I don't think you do =)
20:59:22 <ivanm> EvanCarroll: there's also hlint for hints on the programmatic-style (that is, use of functions rather than indentation, etc.)
20:59:23 <iaefai> I was meaning to ask people - I am shortly going to be needing to manipulate some form of state in my program and it occurred to me that I have never done it. Is there a simple example that would be able to demonstrate something that is akin to a command line interface that changes the state using the state monad or similar?
20:59:44 <mike8901> byorgey: I'm not having trouble understanding that a monad takes in a state, and produces a (value, state)
20:59:45 <Twey> iaefai: You don't need State for something as simple as that
20:59:48 <ivanm> command-line interface?
20:59:53 <Twey> iaefai: Just use ‘recursive state’
21:00:04 <byorgey> mike8901: ok.  so I'm trying to understand what it is you're confused about with 'get'
21:00:07 <mike8901> what I _am_ having trouble understanding is what "get" is
21:00:11 <iaefai> Twey, another thread might need to use this at some point (I am planning on using STM)
21:00:26 <Twey> iaefai: Then you want STM, and not State
21:00:29 <byorgey> mike8901: "get" is something which takes in a state, and produces the state itself as the value (and doesn't change the state)
21:00:35 <Twey> State has a fairly specific use case.
21:00:39 <mike8901> byorgey: right - "takes in"
21:00:43 <mike8901> where's the argument?
21:00:50 <byorgey> mike8901: it will be provided later.
21:01:00 <mike8901> ok, so it's supposed to be a lambda then
21:01:05 <byorgey> mike8901: at some point when you actually get around to "running" the state computation by providing it with an initial state
21:01:06 <Axman6> iaefai: i'd consider using MVars before using STM, as it's far less oferhead
21:01:08 <Axman6> v*
21:01:15 <byorgey> mike8901: right, every State computation is a lambda =)
21:01:24 <byorgey> ...which takes in a state and blah blah =)
21:02:10 <byorgey> you can think of a State compuation as something that says,  "IF I had a state, here's what I would do with it"
21:02:30 <byorgey> well, or better, "WHEN I get a state, here's what I will do with it"
21:02:55 <mtnviewmark> "If I had a sta-ate, I'd compute it in the morning.... I'd compute it in the evening.... All over this la-and!"
21:03:24 <byorgey> @remember mtnviewmark [on the State monad] "If I had a sta-ate, I'd compute it in the morning.... I'd compute it in the evening.... All over this la-and!"
21:03:24 <lambdabot> Nice!
21:03:27 <byorgey> hehe
21:03:38 <EvanCarroll> ivanm: thanks
21:03:44 <ivanm> no worries
21:04:07 <mtnviewmark> I'm really not the kind of lurker you want in a channel....  :-)
21:04:08 <EvanCarroll> ivanm: not really what i was looking for at all
21:04:10 <EvanCarroll> but ok
21:04:11 <EvanCarroll> ;)
21:04:15 <byorgey> mike8901: so, does that make sense?
21:04:20 <ivanm> OK, what _were_ you looking for?
21:04:26 <EvanCarroll> I'm looking more for information on how ghc deals indentation for if statements
21:04:32 <EvanCarroll> the mandated style
21:04:32 <mike8901> byorgey: so would it be get = State (\s -> (s,s)) ?
21:04:40 <byorgey> mike8901: yes!!
21:04:55 <Axman6> EvanCarroll: time to read the haskell report then
21:04:59 <EvanCarroll> how are sane people to supposed to learn to indent else_if and else
21:05:08 <EvanCarroll> that to me is awkwardly non-intuitive
21:05:19 <ivanm> EvanCarroll: if its in a do-block, the then should be indented wrt the if and the else aligned with the then
21:05:30 <ivanm> elsewhere, all three can be aligned together
21:05:41 * ivanm believes he's already said this...
21:05:46 <Axman6> EvanCarroll: the than and else must be indented as much as the if, or more, and must be indented the same if they are on different lines i think
21:05:47 <mike8901> byorgey: ok, so onto put :)
21:05:50 <ivanm> EvanCarroll: what is this else_if you're talking about?
21:06:07 <EvanCarroll> http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output
21:06:08 <byorgey> mike8901: right =)
21:06:11 <Axman6> if blah
21:06:13 <Axman6> then foo
21:06:13 <EvanCarroll> the doguessing
21:06:15 <Axman6> else bar
21:06:18 <Axman6> or
21:06:31 <Axman6> if blah
21:06:33 <Axman6>   then foo
21:06:36 <Axman6>   else bar
21:06:43 <Axman6> is how i prefer to do it
21:06:52 <ivanm> EvanCarroll: ^^ you need the second one for do blocks
21:07:02 <ivanm> but I prefer the former (all lined up) for normal code
21:07:11 <ivanm> EvanCarroll: or else you can put it all on one line if its short enough
21:07:20 <mike8901> byorgey: so what does put do again?
21:07:34 <Axman6> i treat an if block as a block of code, so i indent the then and else. makes it easier to read
21:07:42 <byorgey> mike8901: it takes a new state as a parameter and overwrites the old state.
21:07:53 <Axman6> :t pout
21:07:54 <lambdabot> Not in scope: `pout'
21:07:55 <Axman6> :t put
21:07:56 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
21:08:07 <byorgey> put :: s -> State s ()
21:08:07 <ivanm> Axman6: whereas I treat them as magic extras in the lang ;-)
21:08:15 <Axman6> pfft
21:08:24 <byorgey> oh yes, and it returns () since it doesn't actually compute a useful value
21:08:26 <ivanm> EvanCarroll: OK, style guide addition: in Haskell, you don't have nested if-then-else statemetns, if that's what you were talking about with your else_if
21:08:32 <Cale> EvanCarroll: The golden rule of Haskell indentation is that siblings line up and start on a deeper column than their parents. Since 'then' and 'else' are both part of the 'if', they should each start in a deeper column, and since neither contains the other, they should be aligned.
21:08:32 <byorgey> it just has a side effect (of changing the state)
21:08:47 <ivanm> if you have more than one Bool value/function to test, use guards
21:09:26 <pastah_rhymez> what's the name of the funciton that gives me [x, f x, f f x, f f f x...]?
21:09:34 <byorgey> pastah_rhymez: iterate
21:09:39 <Axman6> i was reading about Agda last night, and you can define if_then_else :: A -> Bool -> A -> A -> A, and then write if x then y else z, because you use _'s as place holdetrs for arguments
21:09:42 <pastah_rhymez> byorgey: cool, thanks :)
21:09:49 <EvanCarroll> ivanm: no i'm talking about the else being indented further than the if
21:09:52 <EvanCarroll> that seems retarded.
21:09:54 <byorgey> > iterate (*2) 1
21:09:54 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
21:10:06 <Cale> pastah_rhymez: However, note that f f x is not the same as f (f x), which is what iterate will give you
21:10:06 <Axman6> EvanCarroll: the else is a sibling of the if
21:10:06 <ivanm> EvanCarroll: as I said before, you have to in do-blocks
21:10:09 <EvanCarroll> why is else if, indented further the parent if
21:10:10 <pastah_rhymez> Axman6: yeah! that's what i'm saying! haskell needs mixfix right about NOW
21:10:15 <EvanCarroll> yea, but it doesn't make sense.
21:10:15 <ivanm> EvanCarroll: to indicate that it's part of the previous statement
21:10:24 <ivanm> EvanCarroll: what do you mean by "else if"?
21:10:29 <Axman6> pastah_rhymez: i don't think it does :P
21:10:30 <Cale> EvanCarroll: 'else' is part of the 'if'
21:10:35 <pastah_rhymez> Cale: i'm just gonna use it for (+5) or something
21:10:40 <EvanCarroll>        if (read guess) < num
21:10:40 <EvanCarroll>          then do putStrLn "Too low!"
21:10:40 <EvanCarroll>                  doGuessing num
21:10:40 <EvanCarroll>          else if (read guess) > num
21:10:40 <EvanCarroll>                 then do putStrLn "Too high!"
21:10:43 <EvanCarroll>                         doGuessing num
21:10:45 <EvanCarroll>                 else do putStrLn "You Win!"
21:10:51 <byorgey> IF IS NOT A STATEMENT IT IS AN EXPRESSION
21:10:52 <pastah_rhymez> Axman6: think about all the cool DSLs you could make
21:10:53 <byorgey> </rant>
21:10:54 <Axman6> EvanCarroll: the if in else if ... is a sibling of the else, which is a sibling of the first if
21:11:11 <Cale> byorgey: I TOTALLY AGREE AND IT WAS STARTING TO BUG ME TOO
21:11:11 <Axman6> pastah_rhymez: yeah, maybe it would be quite cool
21:11:22 <mike8901> byorgey: I'm almost certain this is wrong, but what I've come up with so far: put a = State (\s -> (get a, ()))
21:11:23 <byorgey> =)
21:11:40 <Cale> EvanCarroll: That looks correctly indented.
21:11:43 <byorgey> mike8901: that's close, but not quite right
21:11:53 <Axman6> there's also redundant do's there
21:11:55 <Cale> EvanCarroll: However, if/then/else is a bit silly there.
21:11:58 <Twey> But horrible.
21:12:01 <ivanm> EvanCarroll: as I said, don't use nested if-else
21:12:01 <ivanm> use a guard
21:12:01 <byorgey> mike8901: in particular there's no need to use 'get', and that wouldn't typecheck anyway (since 'get' doesn't take an argument)
21:12:01 <ivanm> or a case statement
21:12:10 <Cale> EvanCarroll: You should use case compare (read guess) num of ...
21:12:12 <Axman6> not case
21:12:17 <Axman6> or maybe case
21:12:19 <ivanm> EvanCarroll: in your case, I'd do: case compare (read guess) num of ...
21:12:21 <byorgey> mike8901: there's no need to use 'get', becuase who cares what the state USED to be?  you are just going to overwrite it.
21:12:21 <Axman6> hmm
21:12:29 <Cale> There's no such thing as a case statement in Haskell.
21:12:31 <EvanCarroll> I'm not writing the code, I'm just admiring the style.
21:12:36 <Cale> There are case expressions.
21:12:45 <Axman6> EvanCarroll: it's not good style imo :)
21:12:53 <pastah_rhymez> Axman6: just think about it; you could write 'length xs' as '| xs |'
21:13:00 <Cale> EvanCarroll: The indentation style is good at least :)
21:13:03 <pastah_rhymez> that would be sooooooo sweet
21:13:05 <ivanm> byorgey: what's the difference between a statement and an expresion?
21:13:08 <ivanm> pastah_rhymez: except | is reserved...
21:13:14 <ivanm> || xs || maybe...
21:13:16 <byorgey> ivanm: statements have side effects.  expressions evaluate to a value.
21:13:17 <Axman6> pastah_rhymez: hmm, that could be quite sweet
21:13:18 <Twey> ivanm: An expression returns a value and can be used as part of a bigger expression.
21:13:24 <ivanm> byorgey: right
21:13:42 <ivanm> Twey: doesn't everything return a value, even if its () ? :p
21:13:53 <Twey> ivanm: = doesn't, for example
21:13:58 <byorgey> it may seem like pedantry, but I think making a careful distinction between those words is actually really important when teaching Haskell.
21:14:04 <ivanm> Twey: oh, right
21:14:08 <Cale> In Haskell, the only things which are referred to as "statements" are the individual lines of a do-block.
21:14:09 <byorgey> because everyone is so used to side-effecting statements in other languages.
21:14:11 <ivanm> byorgey: *nod*
21:14:26 <EvanCarroll> I'm just confused at `else if`, i don't udnerstand why it is indented more than if, or why a sibling is indented in from the other sibling
21:14:34 <Cale> EvanCarroll: "else if" is not one word
21:14:51 <Cale> EvanCarroll: That's the start of another if-expression inside the 'else' part of the first if-expression.
21:14:55 <Twey> EvanCarroll: The ‘else’ is indented more than the ‘if’ because it is part of the expression introduced by the ‘if’.
21:15:01 <ivanm> EvanCarroll: and you should never use nested if statements!
21:15:04 <Axman6> it is literally if x then y else (if a then b else c)
21:15:09 <Cale> ivanm: EXPRESSIONS!
21:15:10 * ivanm is getting sick of telling EvanCarroll that
21:15:15 <Cale> ;)
21:15:15 * Twey laughs.
21:15:19 <ivanm> Cale: I thought they were called if-statements?
21:15:20 <mike8901> byorgey: so do you even care about what a is?
21:15:23 <Cale> ivanm: No!
21:15:29 <Cale> They are if expressions
21:15:32 <ivanm> OK, fair enough
21:15:32 <byorgey> mike8901: what is a?  the argument of put?
21:15:34 <Cale> because they evaluate to a value :)
21:15:35 <mike8901> yes
21:15:37 <ivanm> if-expression sounds weird though...
21:15:48 <byorgey> mike8901: yes, that is what the new state should be
21:15:52 <EvanCarroll> why doe sit matter if they are if-expressions or language statements
21:16:01 <EvanCarroll> i'm not understanding /why/ that would matter
21:16:03 <Cale> EvanCarroll: Expressions have values.
21:16:09 <ivanm> Cale: better fix the wikibook up then, it uses the term "if-statement"...
21:16:21 <Cale> ivanm: I thought I did, though that was a long time ago.
21:16:25 <mike8901> ok, so basically it's a transformation (x,y) -> (a,y) right?
21:16:46 <EvanCarroll> I'll figure it out eventially
21:16:55 <ivanm> Haskell /= imperative language
21:16:57 <byorgey> mike8901: almost, except there's no 'y' on the left-hand side
21:17:12 <byorgey> mike8901: you only get the previous state as an argument
21:17:14 <ivanm> even in an imperative language, it's usually bad to have nested if-statements (they're statements in imperative languages, right?)
21:17:22 <Cale> ivanm: generally, yeah
21:17:25 <EvanCarroll> wtf does this have to do with nested if statements
21:17:30 <mike8901> byorgey: I'm confused then - where does the old state matter?
21:17:30 <Cale> ivanm: Except for C's  ? :  thing
21:17:36 <EvanCarroll> isn't this just an if/else if/ else
21:17:44 <Axman6> no
21:17:44 <EvanCarroll> or the logical equiv
21:17:49 <Axman6> there is no else if
21:17:56 <EvanCarroll> so, it is the logical equiv
21:17:58 <Axman6> it's if x then y else (if a then b else c)
21:18:02 <byorgey> mike8901: are you asking about the 'put' function specifically? or in general?
21:18:07 <ivanm> Cale: right
21:18:14 <EvanCarroll> i don't see why this construct is catagorically bad.
21:18:15 <mike8901> the put function
21:18:20 <Cale> EvanCarroll: It's not.
21:18:24 <byorgey> mike8901: the put function ignores the previous state
21:18:25 <ivanm> OK, the report calls if-then-else a conditional under the expression section
21:18:28 <Cale> EvanCarroll: It's just there's something clearer you could put here.
21:18:35 <mike8901> so then why does it take in an argument?
21:18:43 <Cale> EvanCarroll: Guards and/or case expressions are usually better.
21:18:48 <byorgey> mike8901: the argument is supposed to be the NEW state
21:18:58 <Cale> EvanCarroll: If you start nesting the if expressions, that is.
21:19:18 <mike8901> oh
21:19:22 <ivanm> Cale: I've already told him that; he obviously wants to keep ranting about indentation
21:19:24 <ivanm> *shrug*
21:19:31 <mike8901> so would it be put a = State(\s -> (a, ())) ?
21:19:45 <Cale> EvanCarroll: It's not that nesting if/then/else is all that bad in itself, it's just we have clearer options to choose from.
21:19:53 <byorgey> mike8901: exactly, or maybe the tuple is supposed to be the other way aroud, I forget
21:20:02 <byorgey> but that's exactly the right idea =)
21:20:07 <ivanm> mike8901: or you can have just \ _ -> (a, ())
21:20:12 <c_wraith> mike8901: I'd write it using const, though
21:20:13 <ivanm> or even just const (a, ())
21:20:20 <toast-opt> curious question.  in a do block, how do i get back to normal syntax.  i would like to define a pure function in a do block
21:20:21 <Cale> EvanCarroll: Still confusing?
21:20:24 <ivanm> c_wraith: though the lambda makes it more obvious that it's a function
21:20:30 <byorgey> toast-opt: use 'let'
21:20:33 <Axman6> @pl put a = const (a,())
21:20:33 <lambdabot> put = const . flip (,) ()
21:20:42 <mike8901> so put a = State(const (a, ())) ?
21:20:46 <byorgey> toast-opt: do blah; let pureFunc = blah blah; x <- z ...
21:20:50 <toast-opt> like "do \n  let f x = \n if x then 1 else 2"
21:20:59 <Axman6> mike8901: i'd stick with \_ -> (a,())
21:20:59 <mtnviewmark> or
21:21:02 <toast-opt> how do i wrap it across lines?
21:21:04 <byorgey> mike8901: yep
21:21:13 <BMeph> Technically, it's called an "if/then/else construction".
21:21:18 <Cale> toast-opt: Just make sure that the stuff inside the let lines up with the first line of the let.
21:21:26 <ivanm> toast-opt: it's better to put it into an external function IMHO
21:21:38 <Cale> toast-opt: That is, the first non-whitespace character after 'let' sets the indentation level.
21:21:42 <ivanm> BMeph: nope: "A conditional expression has the form if e1 then e2 else e"
21:21:43 <mtnviewmark> actually, in this case, I like the lambda  - because most of my monadic functions all take input, and I like to keep them in the same form
21:21:45 <mtnviewmark> I'd write
21:21:48 <mike8901> byorgey: hmm, HUGS doesn't like get :: State s s
21:21:49 <ivanm> no mention of the word "construction" there
21:21:54 <ivanm> this is section 3.6 of the report
21:21:56 <mtnviewmark> put a = State $ \s -> (a, ())
21:22:05 <mike8901> "Illegal type "State a a" in constructor application"
21:22:05 <byorgey> mike8901: actually  const ((), a)  the way you defined it in your paste
21:22:19 <Axman6> mtnviewmark: i prefer using _ to explicitly say 'i am not using this argument'
21:22:25 <EvanCarroll> Cale: yes, why does an if .. else have to be indented awkwardly. why make the else an if-expression rather than just making it the logical equivelent of || and having the if evaluate to True or False
21:22:27 <toast-opt> oh, indentation
21:22:29 <toast-opt> got it, thx!
21:22:34 <ivanm> Axman6: as that stops some of ghc's bitching ;-)
21:22:38 <mtnviewmark> is _s as good?
21:22:41 <Cale> EvanCarroll: I don't understand.
21:22:47 <ivanm> mtnviewmark: that works as well
21:23:00 <ivanm> mtnviewmark: since starting with an underscore makes GHC ignore it in terms of the warning
21:23:09 <Cale> EvanCarroll: Do you get why every 'if' *must* have both a 'then' and an 'else'?
21:23:09 <ivanm> mtnviewmark: but as you're still not using it, I'd just use _
21:23:15 <mtnviewmark> I once got bitten by a _ that was really a -   and, ho boy, that was a whopper to find, 'cuase I was accidentailly redefining (-) in a where clause
21:23:20 <byorgey> mike8901: hmm... did you type something at the HUGS prompt?  or try loading a file?
21:23:25 <Axman6> mtnviewmark: i try not to name things i'm not using, unless you end up with functions that look like f x _ _ _ _ blah = foo
21:23:29 <c_wraith> mtnviewmark:  use -Wall  :P
21:23:32 <Cale> EvanCarroll: if-expressions are not like if-statements in C, they are instead like the ?: operators.
21:23:54 <Cale> (If you're a C person)
21:23:57 <mike8901> GHCi is fine with that, but gives an error for the put type declaration: `State' is applied to ttoo many type arguments
21:23:58 <ivanm> mtnviewmark: ?
21:24:00 * mtnviewmark timidly turns on -Wall on his current project.....
21:24:06 <BMeph> ivanm: ON THE WIKIBOOK SITE, 'it's called an "if/then/else construction".' I said 'technically,' to distinguish whether it was being called something else ==> on that site <==, not that it was an official term.
21:24:26 <ivanm> BMeph: hmmm...
21:24:30 <ivanm> got ya
21:24:33 <Axman6> mike8901: you'll need put a = State (\_ -> ((),a)) i believe
21:24:33 <mtnviewmark> ivanm: I had something like:    where localfun - x = ....
21:24:41 <mtnviewmark> instead of     where localfun _ x = .....
21:24:42 <ivanm> :o
21:24:42 * BMeph sighs in relief
21:24:47 <ivanm> BMeph: heh
21:25:13 <mike8901> still get "Kind error: `State' is applied to too many type arguments"
21:25:21 <byorgey> mike8901: what type did you write for put?
21:25:21 <EvanCarroll> Cale: not fully
21:25:30 <mike8901> put :: s -> State s ()
21:25:31 <Cale> EvanCarroll: if foo then bar else quux  is syntax sugar for   case foo of True -> bar; False -> quux
21:25:35 <EvanCarroll> Cale: though i'll guess the else, is to require exhaustive matching
21:25:42 <Cale> EvanCarroll: Right.
21:25:50 <byorgey> mike8901: and what is on the line after that?
21:25:56 <EvanCarroll> C# does that too iirc.
21:26:02 <mike8901> put a = State(\_ -> ((), 0))
21:26:14 <byorgey> 0?
21:26:21 <Axman6> EvanCarroll: in haskell, if x then y; doesn't make any sense, because it doesn't return if x is false
21:26:30 <mike8901> no, ( )  with no space in between
21:26:38 <byorgey> mike8901: the   put a = State(..) is not indented at all, is it?
21:26:45 <mike8901> no
21:26:52 <Axman6> mike8901: paste the code?
21:26:57 <Axman6> @where hpaste
21:26:58 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
21:27:12 <byorgey> yeah, I would have to see it
21:27:46 <mike8901> http://stupidhaskell.pastebin.com/d62699516
21:28:04 <Cale> (if ... then ... else ...) is supposed to be a value, not a description of stuff to be possibly done.
21:28:27 <Cale> So it doesn't make sense to leave one branch out, because there's no obvious value you could choose.
21:28:28 <mtnviewmark> 0?
21:28:39 <mtnviewmark> not a?
21:28:45 <mike8901> oh goddamnit
21:28:46 <Cale> (except possibly something like nontermination or an error/exception of some sort)
21:28:50 <mtnviewmark> heh
21:29:14 <mike8901> but the error remains...
21:29:29 <mtnviewmark> mind you - that would be one maniacal State monad: "Any state you like.... So long as it's zero!!!"
21:29:57 <Cale> EvanCarroll: It's confusing here, because the branches of your if-expression really do contain actions to be performed. But in general that won't be the case :)
21:30:08 <mtnviewmark> is your State monad defined as    State s a :: State s -> (a, s)
21:30:16 <mtnviewmark> or State s a :: State s -> (s, a)
21:30:23 <mtnviewmark> (note swap in final pair)
21:30:39 <Cale> EvanCarroll: If you want the equivalent of an if-without-else, we have 'when' in Control.Monad
21:30:41 <Cale> :t when
21:30:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:30:53 <Cale> Which has a stupid type, apparently.
21:30:55 <mike8901> data State a = State (Store -> (a, Store))
21:31:01 <ivanm> mike8901: :o what's with that pastebin you're using?
21:31:07 <ivanm> why "stupid haskell" ?
21:31:08 <mike8901> ?
21:31:09 <Cale> (ought to be:  Bool -> m a -> m () )
21:31:12 <mike8901> oh, I put that there :)
21:31:29 <ivanm> Cale: why is the type stupid?
21:31:36 <ivanm> oh, right
21:31:42 <Cale> ivanm: Because it's needlessly monomorphic.
21:31:43 <ivanm> yeah, it'd be nice if it did the >> return () for you
21:31:52 <ivanm> same with until
21:31:55 <ivanm> *unless
21:32:10 <mike8901> it's (value, state)
21:32:14 <Cale> :t forkIO
21:32:15 <lambdabot> Not in scope: `forkIO'
21:32:17 <EvanCarroll> Cale: not really what I'm looking for. I want a way to do if-else_if-else, without obscuring the logic because of the relyance on indentin
21:32:18 <mike8901> so ((), a) should be right..
21:32:25 <EvanCarroll> indenting
21:32:27 <EvanCarroll> Cale: could you make this line up like in C, using brackets?
21:32:41 <Cale> EvanCarroll: You just wouldn't use nested-if. You'd use guards.
21:32:49 <ivanm> mike8901: you should then just have "State a"
21:32:54 <ivanm> since you're hard-coding the state type
21:32:57 <EvanCarroll> can i do if {} else { if {} else { if {} } } effictively and format the code anyway i want
21:33:01 <Cale> EvanCarroll: Here's a good trick if you need to introduce guards in the middle of an expression:
21:33:16 <Cale> No, because if/then/else isn't really layout sensitive.
21:33:18 <ivanm> EvanCarroll: no
21:33:19 <byorgey> mike8901: State a = State (Store -> (a, Store))  will only work for one particular type of state, Store
21:33:21 <Cale> (but do is)
21:33:23 <ivanm> you need thens...
21:33:28 <mike8901> byorgey: That's fine.
21:33:36 <mike8901> I'm just using this Monad for an interpreter
21:33:36 <byorgey> mike8901: the versions we have been writing assume that it's polymorphic in the type of the state
21:33:42 <byorgey> which is why you're getting type mismatches
21:33:45 <Cale> case () of _
21:33:50 <ivanm> mike8901: so put :: Store -> State ()
21:33:54 <ivanm> and get :: State Store
21:33:58 <Cale>   | <cond1>  ->  <res1>
21:34:01 <Cale>   | <cond2>  ->  <res2>
21:34:05 <Cale>   | ...
21:34:13 <Axman6> otherwise...
21:34:20 <Cale> Right.
21:34:27 <byorgey> but the implementations should still be the same.
21:34:34 <ivanm> Cale: yeah, that name-less case _expression_ proposal would be a nice thing to add for cases like that
21:34:55 <Axman6> ivanm: i don't think put :: a -> State ()
21:35:01 <ivanm> Axman6: nope
21:35:14 <Axman6> that's not right, 9it should be put :: a -> State a
21:35:17 <ivanm> Axman6: he's hard-coded his state type to be Store
21:35:19 <mike8901> okay, no more type errors
21:35:23 <ivanm> so put :: Store -> State ()
21:35:34 <Axman6> oh right, put puts the state
21:35:36 <ivanm> Axman6: and in general, put is a -> State a ()
21:35:38 <Axman6> bah, fark state!
21:35:41 <ivanm> Axman6: duh ;-)
21:37:10 <mike8901> okay, so modify now
21:37:28 <Axman6> :t modify
21:37:29 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
21:37:37 <Axman6> hmm
21:37:39 <Axman6> gross
21:38:03 <mike8901> so in my case modify :: (Store -> Store) -> State Store () right?
21:38:04 <Cale> EvanCarroll: another thing you can do if it's bothering you is to define something like:
21:38:12 <Cale> @let cond :: [(Bool,a)] -> a; cond xs = fromMaybe (error "cond: ran out of conditions!") (lookup True xs)
21:38:13 <lambdabot>  Defined.
21:38:26 <Cale> @let b --> x = (b,x)
21:38:27 <lambdabot>  Defined.
21:39:12 <Cale> > map (\x -> cond [x < 0 --> x^2, x == 0 --> 5, x > 0 --> -x^2]) [-10..10]
21:39:13 <lambdabot>   Precedence parsing error
21:39:13 <lambdabot>      cannot mix `L.-->' [infixl 9] and prefix `-' ...
21:39:18 <Cale> aw...
21:39:22 <Cale> need an infix decl
21:39:29 <Cale> > map (\x -> cond [x < 0 --> x^2, x == 0 --> 5, x > 0 --> (-x^2)]) [-10..10]
21:39:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = (t, a)
21:39:35 <Cale> er...
21:39:55 <mike8901> modify :: (Store -> Store) -> State () Store
21:39:55 <mike8901> modify f = State (\s -> ((), f s))
21:39:57 <mike8901> right?
21:40:09 <Cale> > map (\x -> cond [(x < 0) --> (x^2), (x == 0) --> 5, (x > 0) --> (-x^2)]) [-10..10]
21:40:10 <lambdabot>   [100,81,64,49,36,25,16,9,4,1,5,-1,-4,-9,-16,-25,-36,-49,-64,-81,-100]
21:40:21 <Axman6> mike8901: does it match the type?
21:40:22 <Cale> (that'd be nicer if I could write an infix declaration
21:40:23 <Cale> )
21:40:26 <Axman6> and does it do what you want?
21:40:26 <EvanCarroll> Cale: yea, I'm sure there is a way around it, it juse seems very awkward, that else was made an if-expression child of if
21:40:39 <mike8901> oh wait d'oh'
21:40:40 <Cale> EvanCarroll: It seems perfectly natural to me.
21:40:42 <Axman6> EvanCarroll: well, what else should it be?
21:40:50 <EvanCarroll> a sibling of the parent if
21:40:57 <Axman6> EvanCarroll: should you be able to use else without if?
21:41:08 <mike8901>  Store
21:41:08 <Cale> EvanCarroll: How can something be a sibling of its own parent?
21:41:09 <mike8901> er
21:41:15 <mike8901> modify :: (Store -> Store) -> State ()
21:41:15 <mike8901> modify f = State (\s -> ((), f s))
21:41:27 <mike8901> that matches up type-wise
21:41:32 <Cale> Heh, hill people if-expressions
21:41:37 <EvanCarroll> no, but if the statement in an if evaluates to false, an arbitrary child expression named 'else' should execute?
21:41:51 <EvanCarroll> it shouldn't be a child.
21:41:57 <Axman6> yes,l it should be
21:42:16 <Cale> EvanCarroll: Nothing is "executing" here :)
21:42:17 <Axman6> 'if x' has two children: 'then y' and 'else z'
21:42:25 <Cale> The whole thing is a value.
21:42:45 <EvanCarroll> Axman6: that's probably the best way of explaining yet.
21:42:48 <Cale> It must be a value regardless of whether the condition is True or False.
21:43:39 <Cale> Of course, we also could have opted in Haskell to have made if a function.
21:43:47 <Cale> if True x y = x
21:43:50 <Cale> if False x y = y
21:43:52 <Axman6> EvanCarroll: i think if you want to learn haskell, you're going to have to open your mind more, and start being less argumentative when people are trying to help you. telling people something shouldn't be the way it is won't help you. asking why something is the way it is will
21:43:53 <byorgey> mike8901: yep, looks good
21:44:23 <Cale> EvanCarroll: Then we would never write 'then' or 'else', but the tags help when reading code.
21:44:25 <mike8901> ok, so now moving on to the interpreter...
21:45:08 <mike8901> so I have a bunch of functions defined like interp (Add lhs rhs) env store
21:45:46 <mike8901> I want to "thread" the store through
21:46:14 <Cale> @let if' True x y = x; if' False x y = y
21:46:15 <lambdabot>  Defined.
21:46:38 <mike8901> so for an add, I want to do interp lhs env store followed by interp rhs env <store returned by previous result> followed by return (val1 + val2) where val1 is the result returned by the first expression, val2 the second
21:46:51 <Axman6> > let then = (); else = (); if' x _ y _ z = if x then y else z in if' True then 7 else 8
21:46:52 <lambdabot>   <no location info>: parse error on input `then'
21:46:54 <Cale> > map (\x -> if' (x < 0) (x^2) (if' (x == 0) 500 (-x^2))) [-10..10]
21:46:55 <Axman6> :(
21:46:55 <lambdabot>   [100,81,64,49,36,25,16,9,4,1,500,-1,-4,-9,-16,-25,-36,-49,-64,-81,-100]
21:47:07 <Axman6> > let thn = (); els = (); if' x _ y _ z = if x then y else z in if' True thn 7 els 8
21:47:08 <lambdabot>   7
21:47:13 <BMeph> Cale: Shall we also define 'true' and 'false'? For that matter, should we then also define 'pair'? ;)
21:47:19 <mike8901> right now, I have do val1 <- interp lhs env store; val2 <- interp rhs env; return (val1 + val2)
21:47:22 <mike8901> but that doesn't work
21:47:31 <mike8901> (because the second interp expects an store)
21:47:45 <Cale> BMeph: We *do* define True and False in the Prelude already.
21:47:47 <mike8901> *a store
21:48:02 <BMeph> Cale: Not True and False, true and false.
21:48:10 <Cale> As in  true x y = x ?
21:48:29 <Cale> true = const ;)
21:48:31 <BMeph> Cale: i.e. the functions, a la Scott. :)
21:48:46 <Cale> (or Church)
21:48:46 <BMeph> Cale: Yes.
21:49:03 <BMeph> Cale (to both comments.)
21:49:28 <byorgey> mike8901: if you're using a State monad, the whole point is that now you don't have to explicitly thread the store around
21:49:39 <mike8901> yes, that's the goal :)
21:49:41 <byorgey> mike8901: it gets handled implicitly by the state monad
21:49:52 <Cale> Though, probably we'd want a different type for true than for const.
21:49:56 <Cale> :t asTypeOf
21:49:57 <lambdabot> forall a. a -> a -> a
21:50:04 <Cale> asTypeOf x y
21:50:05 <Cale> >asTypeOf x y
21:50:08 <Cale> grr
21:50:10 <Cale> > asTypeOf x y
21:50:11 <lambdabot>   x
21:50:49 <byorgey> mike8901: so something like   do  val1 <- interp lhs env; val2 <- interp rhs env; return (val1 + val2)
21:51:01 <mike8901> that's what I have
21:51:04 <mike8901> but I get a type error
21:51:05 <byorgey> unless evaluating an addition is supposed to modify the store in any way
21:51:14 <byorgey> mike8901: that's not what you wrote
21:51:19 <byorgey> you had an extra 'store' in there
21:51:37 <byorgey> mike8901: what is the type of interp?
21:51:38 <mike8901> oh, sorry, I've since taken that out
21:51:41 <byorgey> ok
21:51:48 <mike8901> haskell doesn't like my explicit type of interp
21:51:57 <mike8901> I defined it as interp :: BCAE -> Env -> Store -> State Value
21:52:05 <mike8901> (BCAE is just a type I'm using)
21:52:19 <byorgey> mike8901: if interp returns a 'State Value' then there's no reason for it to take a Store parameter
21:53:42 <byorgey> it should just be  interp :: BCAE -> Env -> State Value
21:53:56 <mike8901> ok, now it compiles
21:54:02 <byorgey> awesome =)
21:54:10 <mike8901> but... I need to deal with 'with'
21:54:19 <mike8901> basically, with adds something into the store
21:54:19 <byorgey> what is 'with'?
21:54:22 <byorgey> ok
21:54:28 <byorgey> so, use put or modify
21:54:53 <byorgey> and maybe get
21:55:07 <mike8901> yeah, I'll need to get the store first
21:55:49 <byorgey> interp (With foo bar) env = do st <- get; put (new st based on foo and bar); return something
21:56:13 <byorgey> or just use 'modify' if you can express the change to the state as a function
21:56:34 <byorgey> do modify (addToStore foo bar); return blah
21:56:36 <byorgey> something like that
21:57:14 <byorgey> well, and maybe you need some sort of recursive call(s) to interpret.  don't take my code to literally, it's just for inspirational purposes =)
21:57:21 <mike8901> :P
22:01:59 <pastah_rhymez> i hate this: (Fractional b, Integral a, Integral t, Integral t1, Integral b)
22:02:32 <pastah_rhymez> here i try to be all polymorphic and cool and look where it gets me
22:03:22 <c_wraith> the least restrictive code you can manage!
22:12:39 <byorgey> pastah_rhymez: hmm,  Fractional b, Integral b   doesn't look good...
22:12:57 <byorgey> there are no standard types satisfying both of those
22:13:50 <pastah_rhymez> byorgey: no shit, sherlock
22:14:22 <pastah_rhymez> i'm sitting here with fromIntegral and toInteger trying to make this right, but the magic just won't happend :(
22:16:50 <byorgey> pastah_rhymez: try concretizing the types to Integer and Double
22:16:54 <Axman6> pastah_rhymez: perhaps you could share the code?
22:16:59 <byorgey> get it working that way and then generalize if you want
22:17:07 <byorgey> you'll probably get better error messages that way.
22:17:11 <ddarius> This channel is too damn nice.
22:17:21 <pastah_rhymez> Axman6: it' kinda big, but sure, i'll just comment it so that your heads won't explode
22:17:39 <Axman6> ddarius: screw you
22:17:49 <ddarius> Axman6: Nice try.
22:18:38 <FunctorSalad> there's no shortage of venues not having that deficiency on the internet
22:22:04 <pastah_rhymez> ok, here's the paste of my own little slize of polymorphism hell
22:22:06 <pastah_rhymez> http://codepad.org/V2vMsF5N
22:22:18 <pastah_rhymez> it's the function at line #126
22:25:49 <c_wraith> what function will give me the command line args?
22:26:00 <byorgey> c_wraith: getArgs, from System.Environment
22:26:01 <ddarius> :t getArgs
22:26:01 <lambdabot> Not in scope: `getArgs'
22:26:02 <pastah_rhymez> System.Environment.getArgs
22:26:05 <c_wraith> thanks
22:27:31 <byorgey> pastah_rhymez: delta = round $ (fi (f - t) / fi (steps - 2))
22:27:35 <byorgey> or something like that
22:28:03 <pastah_rhymez> byorgey: been there, RealFrac restrictions arise
22:28:17 <luqui> pastah_rhymez, that is not that hellish
22:28:32 <pastah_rhymez> condensed it;
22:28:35 <pastah_rhymez> inter f t n = iterate (+delta) (fi f)
22:28:36 <pastah_rhymez>     where
22:28:38 <pastah_rhymez>         delta :: Double
22:28:40 <pastah_rhymez>         delta = (fi $ f - t) / (fi n)
22:28:56 <luqui> pastah_rhymez, since the first two args are X256, why not restrict them to Word8
22:29:46 <luqui> and why not make the third argument Int?
22:30:03 <pastah_rhymez> luqui: it's the size of the list
22:30:17 <luqui> :t length
22:30:18 <lambdabot> forall a. [a] -> Int
22:30:19 <pastah_rhymez> so it's not a code; thus keeping them separate
22:30:24 <pastah_rhymez> @type take
22:30:25 <lambdabot> forall a. Int -> [a] -> [a]
22:30:28 <pastah_rhymez> that's why
22:30:33 <luqui> what's why?
22:30:46 <pastah_rhymez> well, take is going to be used here, somehow
22:30:57 <luqui> yeah, and take takes an Int
22:31:01 <byorgey> pastah_rhymez: the code I pasted works fine for me.
22:31:10 <luqui> Int is what we use for list sizes typically
22:31:28 <romanandreg> guys do you know how to run parsec parsers using ByteStrings?
22:31:55 <luqui> i don't see a reason for any of this code to be polymorphic
22:32:16 <luqui> concrete types are just as flexible, and would probably be clearer and perform better
22:32:23 <byorgey> wait, sorry, I lied
22:33:03 <byorgey> wait, no, I didn't lie
22:33:07 <byorgey> ghci infers interpolateX256byRGB :: (Integral i, Integral a) => i -> i -> a -> [i]
22:33:11 <dancor> is sox a good choice if i want to read, manipulate (e.g. amplify etc), and write mp3s?  http://hackage.haskell.org/package/sox
22:33:30 <romanandreg> I'm trying to run Parsec parser passing a ByteString and it is not worked
22:33:32 <romanandreg> working*
22:33:54 <Axman6> romanandreg: are you using the bytestring parsec lib?
22:34:01 <Axman6> parsec works on strings be default
22:34:06 <romanandreg> I supposed it was going to work because since version 3.0.0 Parsec has a ByteString API
22:34:18 <Axman6> are you using the bytestring API?
22:34:19 <BMeph> pastah_rhymez:  Try inter f t n = map (\x -> f+(f-t)*x `div` n   ) $ [0..n]
22:34:43 <romanandreg> Axman6: I'm trying... there is no easy to find docs that show how to use parsec with bytestrings thoughts
22:34:49 <byorgey> pastah_rhymez: round introduces a RealFrac constraint, but that's fine, since the 'fromIntegral' calls on both the things being divided will convert them into something with a RealFrac instance (likely defaulted to Double)
22:34:51 <romanandreg> thougt*
22:35:08 <Axman6> romanandreg: well, i'm guessing you have to import a different module
22:35:09 <byorgey> pastah_rhymez: you would only get a RealFrac constraint on the top-level type if you forget a call to fromIntegral.
22:35:18 <Saizan> Axman6: there's actually a class
22:35:30 <mtnviewmark> anyone have advice about orphan instances?
22:35:42 <ddarius> mtnviewmark: What about them?
22:35:51 <Axman6> Saizan: oh> how handy :)
22:36:15 <mtnviewmark> I've got a module Data.Foo.Internal that defined a type and Data.Foo.Pretty that defines a pretty print function for it
22:36:24 <Axman6> man, bookdepository.co.uk is awesome
22:36:32 <mtnviewmark> I where do I put the Show instance?
22:36:39 <romanandreg> Axman6: well I'm importing "Text.Parsec.ByteString" and "Text.ParserCombinators.Parsec"
22:36:46 <mtnviewmark> if I put it in Data.Foo.Pretty - then it is an orphan instance
22:36:48 <romanandreg> there isn't any conflicting methods
22:36:48 <pastah_rhymez> BMeph: that works, though i would prefer delta to be floating :/
22:37:06 <mtnviewmark> if I put it in Data.Foo.Internal, then Data.Foo.Internal has to include Data.Foo.Pretty -- which is circular
22:37:10 <Saizan> romanandreg: Text.ParserCombinators.Parsec is the old list specific API
22:37:20 <Saizan> romanandreg: import Text.Parsec instead
22:37:30 <ddarius> romanandreg: You should be using all Text.Parsec or all Text.ParserCombinators.Parsec.  Not both.
22:38:19 <romanandreg> ok
22:38:42 <romanandreg> ddarius: ok... yeah I'm kinda new to parsec, and the reference I'm reading is using an old api as it seems
22:39:51 <byorgey> pastah_rhymez: if you want delta to be floating, then you'll need to do  'map round' over the list generated by the iterate
22:40:06 <byorgey> and wrap f in a call to  fromIntegral
22:40:06 <Saizan> mtnviewmark: Show instances shouldn't be pretty anyway :) they should produce valid haskell code that rebuilds the value, if possible
22:40:26 <mtnviewmark> well - that aside - I have this issue with several other Classes
22:40:36 <byorgey> interpolate f t n = map round (iterate (+delta) (fi f))  where ...
22:40:53 <BMeph> pastah_rhymez: Or you may just want to rethink your arguments (and your result's element type) being of Integral type. :)
22:41:02 <byorgey> where delta = fi (f - t) / fi (steps - 2)
22:41:13 <mtnviewmark> as for Show should be Haskell code - for debugging and working in ghci --- it was much nicer to have Show be pretty!
22:41:18 <romanandreg> ddarius: is it possible to use Text.Parsec.Char methods with Text.Parsec.ByteString
22:41:39 <pastah_rhymez> BMeph: that's true, it would be nice to have floats up until the end
22:42:16 <ddarius> romanandreg: Yes.
22:42:17 <Saizan> mtnviewmark: i'd put the instances in .Internal, or hide .Internal and only expose the type via modules that export the instances
22:43:24 <romand> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5064#a5064
22:44:03 <mtnviewmark> Saizan - the later is what I do - hide .Internal and only expose Data.Foo itself -- -but where do I put the instance Show declaration? IN Data.Foo? If I put it in Data.Foo.Internal (where the type is), then Data.Foo.Internal has to include Data.Foo.Pretty--- but Data.Foo.Pretty includes Data.Foo.Internal -- and ghc complains about circular module includes
22:44:06 <pastah_rhymez> why the fuck am i this stupid?
22:44:18 <pastah_rhymez> [start, start+delta .. end]
22:44:27 <romand> for some reason c_FindNextChageNotificatoin returns True immediately
22:44:28 <Axman6> lol
22:44:42 <BMeph> pastah_rhymez: Hmm?
22:44:43 <pastah_rhymez> seriously, wtf is wrong with me
22:45:24 <romand> so, when running this -- http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5064#a5064 -- I get list of 1000 True-s
22:45:30 <dancor> http://hackage.haskell.org/packages/archive/sox/0.0.1/doc/html/Sound-Sox-Read.html refers to Control.Monad.Exception.Asynchronous.result which doesn't seem to exist
22:45:31 <Saizan> mtnviewmark: being careful about exposing modules wouldn't matter here if the instances were in .Internal
22:45:35 <dancor> what's going on there
22:45:39 <BMeph> pastah_rhymez: "Why so serious?" ;p
22:46:36 <iaefai> I am trying to do a mouse FFI module, and when I link I get an error: dist\build\BoardGames\BoardGames-tmp\Main.o:fake:(.text+0x221): undefined reference to `__stginit_Mouse_'    any ideas what might be wrong?   Source for the module: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12992#a12992
22:46:38 <mtnviewmark> right - so I put the instances in Internal, but get the circular import error -- since the instance needs functions defined in another hidden internal module
22:47:22 <Saizan> dancor: here it is http://hackage.haskell.org/packages/archive/explicit-exception/0.1.4/doc/html/Control-Monad-Exception-Asynchronous.html#v%3Aresult
22:47:34 <dancor> ah
22:47:35 <dancor> ty
22:47:51 <Saizan> mtnviewmark: no, i meant be careful and put them in Data.Foo
22:48:24 <mtnviewmark> aha
22:48:41 <romand> btw, is there any FFI to WaitForSingleObject win32 api function?
22:48:47 <romand> can't find any in docs
22:49:44 <pastah_rhymez> YES!!!
22:49:49 <pastah_rhymez> inter 1 10 10
22:49:51 <pastah_rhymez> [1,2,3,4,5,5,6,7,8,9,10]
22:49:53 <pastah_rhymez> FINALLY!
22:50:12 <romand> congrs (:
22:50:16 <Axman6> pastah_rhymez: sounds like you've implemented enumFromThenTo...
22:50:19 <ski> (should there be two `5' in there ?)
22:50:33 <pastah_rhymez> Axman6: fagg u maffagga :p
22:50:33 <Axman6> ski: heh, nicely spotted
22:50:50 <pastah_rhymez> ski: yes, third argument is number of elements in between
22:51:06 <Axman6> :o
22:51:21 <ski> in between what ?
22:51:36 <ski> > length [1,2,3,4,5,5,6,7,8,9,10] - 2
22:51:36 <lambdabot>   9
22:51:53 <pastah_rhymez> ski: still working out the bugs :p
22:53:00 <ski> maybe you meant that the last argument is the number of steps in between the elements ?
22:53:00 <BMeph> pastah_rhymez: What happened to wanting to keep floats?
22:53:12 <pastah_rhymez>         delta :: Float
22:53:22 <pastah_rhymez> that's my magic
22:53:57 <pastah_rhymez> ski: actually i don't really know what i meant myself, but i'll get there :)
22:55:27 <BMeph> > let inter f t n = map (\x -> f+(t-f)*x `div` succ n   ) $ [0.. succ n] in inter 1 10 10
22:55:28 <lambdabot>   [1,1,2,3,4,5,5,6,7,8,9,10]
22:56:39 <romanandreg> ddarius: Thanks for the help on parsec, I could make it work like I wanted
22:56:47 <romanandreg> Axman6: thanks too
22:56:48 <romanandreg> :-)
22:57:18 <pastah_rhymez> BMeph: shit, that's awesome
22:57:37 <Axman6> pastah_rhymez: you didn't know div?
22:57:40 <ski> > (\start end noSteps -> let step = (end - start) / noSteps in unfoldr (\i -> if i > noSteps then Nothing else Just (start + i * step,succ i)) 0) 1 10 10
22:57:41 <lambdabot>   [1.0,1.9,2.8,3.7,4.6,5.5,6.4,7.3,8.2,9.1,10.0]
22:57:59 <pastah_rhymez> Axman6: well, i did, but i didn't want to use it, i thought it might be too unprecise
22:58:23 <Axman6> imprecise* :P
22:58:35 <pastah_rhymez> well, i'm swedish
22:58:41 <pastah_rhymez> :p
22:59:02 <ski> (pastah_rhymez : det r ingen urskt ;)
22:59:14 <pastah_rhymez> when we negate stuff (unless it's obviously a french word) we put "o" in front of it
22:59:19 <pastah_rhymez> ski: lätt att det är
22:59:36 <Axman6> ...
22:59:44 <Axman6> bork bork bork
22:59:45 <Axman6> >_>
22:59:50 <pastah_rhymez> Axman6: väl talat
23:00:18 <Axman6> what??? my mother was a saint!
23:00:25 <BMeph> > let inter f t n = let nudge = f + div (succ n) 2 in map (\x -> nudge+(t-f)*x `div` succ n   ) $ [0.. succ n] in inter 1 10 10
23:00:26 <lambdabot>   [6,6,7,8,9,10,10,11,12,13,14,15]
23:00:35 <jfredett> pastah_rhymez: so, the koolaid guy must sound really negative in swedish
23:00:36 <Axman6> actually, she's still alive and cooking dinner right now, but it's still true
23:00:42 <jfredett> "Oyah!"
23:00:43 <BMeph> Okay, that wasn't it...
23:00:58 <jfredett> would be like, "No!" or something... :/
23:01:08 * jfredett is done making jokes... he promises...
23:01:26 <iaefai> How can I do an operation like x AND 255 to get the lower bits of a number?
23:01:36 <copumpkin> .&.
23:01:46 <copumpkin> :t (.&. 0xff)
23:01:47 <lambdabot>     Ambiguous occurrence `.&.'
23:01:47 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
23:01:47 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
23:01:51 <copumpkin> ugh
23:01:57 <copumpkin> :t (Data.Bits..&. 0xff)
23:01:58 <lambdabot> forall a. (Bits a) => a -> a
23:02:20 <pastah_rhymez> BMeph: what's the difference between the last and this?
23:02:22 <copumpkin> > (Data.Bits..&. 0xff) 0xdeadbeef
23:02:23 <lambdabot>   Ambiguous type variable `a' in the constraint:
23:02:24 <lambdabot>    `Data.Bits.Bits a'
23:02:24 <lambdabot>      a...
23:02:31 <copumpkin> > (Data.Bits..&. 0xff) (0xdeadbeef :: Integer)
23:02:32 <lambdabot>   239
23:02:38 <copumpkin> > 0xef
23:02:39 <lambdabot>   239
23:02:59 <BMeph> pastah_rhymez: I'm trying to figure out the extra "fudge factor" so that the div acts like a round instead of a floor. :)
23:03:23 <pastah_rhymez> BMeph: heh, cool
23:04:14 <pastah_rhymez> BMeph: well, why not just do it as floats?
23:04:37 <pastah_rhymez> convert f and t to floats and then do it from there
23:04:51 <junmin>  [s|s<-[1..5], (s,y)<-[(1,2),(3,5)], y<-[3]]  why this list doest return [] ???
23:04:54 <junmin> >  [s|s<-[1..5], (s,y)<-[(1,2),(3,5)], y<-[3]]
23:04:54 <lambdabot>   [1,3,1,3,1,3,1,3,1,3]
23:05:26 <BMeph> "You lie!" ;p
23:06:40 <iaefai> Is there a problem with this definition? mouseEvent :: IO Maybe (Int, Int)    It is telling me it is applied to too many arguments.
23:07:00 <junmin> BMeph: mmm... i am not lying
23:08:09 <ski> iaefai : possibly you wanted `IO (Maybe (Int,Int))' ?
23:08:12 <ddarius> iaefai: The syntactic rules for the type level are the same as the ones for the value level.
23:08:14 <junmin> BMeph: i expect it to return [] :|
23:08:20 <ski> @kind IO
23:08:21 <ddarius> junmin: Why?
23:08:21 <lambdabot> * -> *
23:08:24 <ski> @kind Maybe
23:08:25 <lambdabot> * -> *
23:08:27 <ski> @kind IO Maybe
23:08:28 <lambdabot>     `Maybe' is not applied to enough type arguments
23:08:28 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
23:08:33 <ski> @kind IO Maybe (Int,Int)
23:08:34 <lambdabot>     Kind error: `IO' is applied to too many type arguments
23:08:38 <ski> @kind IO (Maybe (Int,Int))
23:08:39 <lambdabot> *
23:09:13 <iaefai> ok, it compiles, but now it doesn't link properly - it is as if it isn't linking in the C file that I specify with {-# CFILES mouse.c #-}
23:09:40 <junmin> ddarius: (s, 3), there is no any (_, 3) in [(1,2),(3,5)]
23:10:26 <ddarius> junmin: You are shadowing s in the second generator.  You can't use bound variables in patterns.
23:10:27 <BMeph> junmin: Then, say "y ==3", instead of "y <- [3]" :)
23:11:24 <ddarius> On the right of the |, neither of the uses of s or of y are related.
23:12:43 <ddarius> @undo [s|s<-[1..5], (s,y)<-[(1,2),(3,5)], y<-[3]]
23:12:43 <lambdabot> concatMap (\ s -> concatMap (\ (s, y) -> concatMap (\ y -> [s]) [3]) [(1, 2), (3, 5)]) [1 .. 5]
23:12:58 <BMeph> They just cause the other solutions to be repeated a number of times. :)
23:14:37 <BMeph> > [s| s <- [1,2,3], (s,y) <- [(6,'x')], y <- "Oh"]
23:14:38 <lambdabot>   [6,6,6,6,6,6]
23:14:41 <junmin> what's @undo mean?
23:15:30 <BMeph> junmin: It means "Take what you'd 'do' when you 'do' this, and reverse that." ;)
23:15:59 <ddarius> junmin: It desugars do-notation and also list comprehensions.
23:19:55 * junmin is trying to understand the code...
23:20:41 <romand> guys, any ideas on why win32 api ffi lacks wait* functions?
23:23:54 <pastah_rhymez> BMeph: inter f t n = map (\x -> round $ (fi $ f+(t-f)*(fi x)) / (fi $ n+1))  [0 .. succ n]
23:24:11 <BMeph> romand: ...because "Ween-Doze"(TM) lacks wait* functions? ;)
23:24:39 <romand> WaitForSingleObject, for example
23:25:35 <romand> BMeph: nope
23:33:09 <conal> Just tweeted: Sometimes we dislike answers because we're attached to the wrong questions.  My comments on Monad confusion: http://bit.ly/8mI4Lm
23:36:40 <pastah_rhymez> BMeph: shit, i need help
23:36:58 <pastah_rhymez> the interpolate functions can only go up, not down in values
23:37:14 <pastah_rhymez> let interpolate f t n = map (\x -> round $ (fi $ f+(t-f)*(fi x)) / (fi $ n+1))  [0 .. succ n]
23:37:18 <pastah_rhymez> > let interpolate f t n = map (\x -> round $ (fi $ f+(t-f)*(fi x)) / (fi $ n+1))  [0 .. succ n]
23:37:19 <lambdabot>   not an expression: `let interpolate f t n = map (\x -> round $ (fi $ f+(t-f...
23:37:24 <copumpkin> fail
23:38:09 <pastah_rhymez> > let interpolate f t n = map (\x -> round $ (fromIntegral $ f+(t-f)*(fromIntegral x)) / (fromIntegral $ n+1))  [0 .. succ n]
23:38:09 <lambdabot>   not an expression: `let interpolate f t n = map (\x -> round $ (fromIntegra...
23:38:24 <copumpkin> let ... in ...
23:38:38 <pastah_rhymez> i want to define it
23:38:44 <pastah_rhymez> @let
23:38:44 <lambdabot>  Defined.
23:38:47 <pastah_rhymez> cool
23:38:52 <pastah_rhymez> @let interpolate f t n = map (\x -> round $ (fromIntegral $ f+(t-f)*(fromIntegral x)) / (fromIntegral $ n+1))  [0 .. succ n]
23:38:53 <lambdabot>  Defined.
23:38:58 <BMeph> pastah_rhymez: ...never mind. :\
23:39:09 <pastah_rhymez> > interpolate 255 0 255
23:39:10 <lambdabot>   [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20...
23:39:20 <copumpkin> so stateful
23:44:21 <pastah_rhymez> why is this so goddamn hard?
23:44:45 <BMeph> > let { interp start finish internals = [sd,sd+step..fd]; sd = fromIntegral start; fd = fromIntegral finish; step = (fd-sd) / (fromIntegral n + 1)} in interp 1 10 8
23:44:46 <lambdabot>   Not in scope: `start'Not in scope: `finish'
23:45:28 <BMeph> > let { interp start finish internals = [sd,sd+step..fd] where sd = fromIntegral start; fd = fromIntegral finish; step = (fd-sd) / (fromIntegral n + 1)} in interp 1 10 8
23:45:29 <lambdabot>   * Exception: not a number
23:45:41 <BMeph> Yes! \o/
23:46:05 <BMeph> > let { interp start finish internals = [sd,sd+step..fd] where sd = fromIntegral start; fd = fromIntegral finish; step = (fd-sd) / (fromIntegral internals + 1)} in interp 1 10 8
23:46:06 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
23:46:56 <pastah_rhymez> BMeph: that's pretty sweet
23:47:02 <BMeph> > let { interp start finish internals = map round [sd,sd+step..fd] where sd = fromIntegral start; fd = fromIntegral finish; step = (fd-sd) / (fromIntegral internals + 1)} in interp 1 10 10
23:47:03 <lambdabot>   [1,2,3,3,4,5,6,7,8,8,9,10]
23:47:27 <pastah_rhymez> BMeph: that's TOTALLY sweet
23:47:39 <BMeph> pastah_rhymez:  Well, it looks like it does what you want, so I guess that's a plus. :)
23:48:00 <copumpkin> conal: very nice blog post, but you have a broken image link in the middle
23:48:33 <conal> copumpkin: there's an image link??
23:48:40 <copumpkin> conal: I mean for one of the formulas
23:48:59 <copumpkin> straight after the formula describing &&&
23:49:17 <conal> copumpkin: oh, urg.  worked locally but not on the server.  hm.
23:49:21 <pastah_rhymez> BMeph: do you know that you're totally awesome?
23:49:23 <conal> copumpkin: thx.
23:49:37 <copumpkin> no problem, it's a fascinating blog entry, so thank you! :)
23:49:43 <pastah_rhymez> BMeph: now for inserting 'fi' in all the wrong places to make this work with my function
23:51:37 <desp> I have a problem with Foreign.Concurrent.newForeignPtr
23:51:56 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12993
23:52:03 <desp> The docs say that "The only guarantee is that the finalizer runs before the program terminates."
23:52:12 <desp> Unfortunately, the finalizer doesn't seem to run.
23:52:14 <desp> Any ideas?
23:52:20 <BMeph> conal: Do you know how some Concerned Citizen could send that "P.Static" blogger a nitrous oxide-filled balloon? He sounds like someone how hasn't had a good giggle - or even a snide smirk - in a few years... :\
23:52:35 <BMeph> Er, someone *who
23:52:35 * Twey laughs.
23:52:58 <conal> BMeph: lovely idea!
23:53:33 <FunctorSalad> nitrous :o
23:53:44 <BMeph> "OMG, I don't know what a monad is ,so how is showing me an example of one going to help me understand what they do to the stack frames?!?!? Please, think of the STACK FRAMES!!!"
23:53:57 <FunctorSalad> hehehe
23:54:32 <\yrlnry> Heh.
23:54:40 <p_l> lol
23:54:46 <Twey> Hahahahaha
23:54:54 <\yrlnry> Is that really a quote?
23:55:36 <\yrlnry> I guess not.
23:56:05 <\yrlnry> "Monads suck because they stopped working after I got jelly in my keyboard."
23:58:30 <mauke> preflex: quote duqicnk
23:58:30 <preflex>  <duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
23:58:49 <Twey> <3
