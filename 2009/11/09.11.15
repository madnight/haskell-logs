00:00:02 <jrockway> if you want to argue about why perl is better than haskell, don't pick the tree example
00:00:05 <jrockway> or factorial function ;)
00:00:13 <kamatsu> i wanted to make a box type using existential quantification over Monads
00:00:38 <kamatsu> i'm pretty new to this stuff so i'm probably doing something stupid
00:00:47 <kamatsu> why doesn't this work? data Monadbox = forall s. Monad (s) => MonadBox (s)
00:00:48 <ski> what's the error ?
00:00:58 <ski> oh
00:01:02 <FunctorSalad> kind error
00:01:04 <ski> you need to apply the monad to a type
00:01:15 <ski> a monad is not a fully applied type
00:01:25 <ski>   x :: Maybe  -- is nonsense
00:01:28 <ski> @kind Maybe
00:01:29 <lambdabot> * -> *
00:01:33 <kamatsu> right
00:01:52 <ski> so you need to have `s (...)' for some type `(...)', there
00:01:56 <dmwit> An existential monad wrapper sounds pretty darn useless.
00:02:00 <ski> e.g. a parameter of your datatype
00:02:11 <kamatsu> dmwit: i know, i was just playing around, and wondering why this doesn't work
00:02:38 <FunctorSalad> ORLY? /me goes implement turing machine with just existential monads ;)
00:02:42 <ski> (dmwit : if you wrap enough extra functions (or instances), it might be useful)
00:02:52 <mmorrow> this is a neat trick, somewhat related to this
00:02:57 <mmorrow> , src ''Q
00:02:59 <lunabot>  newtype Q a = Q {unQ :: (forall m . Quasi m => m a)}
00:03:05 <mmorrow> and then Q is made an instance of Quasi
00:03:10 <mmorrow> (from TH)
00:03:38 <kamatsu> hmm
00:03:56 <FunctorSalad> that is some sort of free construction, isn't it?
00:04:11 <mmorrow> , src ''Quasi
00:04:12 <FunctorSalad> free Quasi-structure or some such thing
00:04:13 <lunabot>  class (Monad m, Functor m) => Quasi m where
00:04:13 <lunabot>          qNewName :: String -> m Name
00:04:14 <lunabot>          qReport :: Bool -> String -> m ()
00:04:16 <mmorrow> ..
00:04:39 <ski> mmorrow : iteresting hot that uses universal instead of the traditional existential ..
00:04:43 <ski> s/hot/how/
00:05:29 <mmorrow> there's a brief explanation in the comments in the TH.Syntax module
00:05:32 <mmorrow> (in the code)
00:05:35 <ski> (traditional existential as in `data Showable = forall a. Show a => MkShow a; instance Show Showable where ...')
00:06:42 <ski> @source TH.Syntax
00:06:43 <lambdabot> TH.Syntax not available
00:07:07 <mmorrow> err, maybe the explanation/comment i'm thinking of is elsewhere
00:07:14 <mmorrow> (can't seem to find it in that module)
00:07:17 <ski> mmorrow : so `Q' is a monad as well ..
00:07:42 <mmorrow> right
00:08:15 <ski>   data IterList f a = Nil
00:08:16 <mmorrow> basically, Q just serves to provide a common monad for /any/ Quasi
00:08:20 <ski>                     | Cons a (IterList f (f a))
00:08:26 <ski> (yes)
00:08:32 <kamatsu> data MonadBox a = forall s. Monad s => MonadBox (s a)
00:08:51 <kamatsu> wow, i just realized how pointless that is
00:09:01 <kmc> what monads are Quasi, besides Q itself?
00:09:08 <mmorrow> kmc: IO, TcM
00:09:10 <ski>   Cons 0 (Cons [1,2] (Cons ([[3],[4,5],[6,7,8]]) Nil)) :: IterList [] Integer
00:09:18 <kmc> what's TcM?
00:09:24 <kmc> @hoogle TcM
00:09:25 <lambdabot> No results found
00:09:25 <mmorrow> TypeCheckMonad in GHC
00:09:35 <ski>   type AccList f a = Loop a ()
00:09:39 <ski>     where
00:09:42 <ski>     data Loop a acc = Here acc
00:09:43 <ski>                     | Wrap (Loop (f a) (a,acc))
00:09:52 <mmorrow> kmc: which is how reify is supported, etc
00:10:13 <kmc> aha
00:10:28 <kmc> man the cool shit we get for having a self-hosting compiler :)
00:10:35 <ski>   Wrap (Wrap (Wrap (Here ([[0,1,2],[3,4],[5]],([6,7],(8,())))))) :: AccList [] Integer
00:11:07 <qp_pq> self-hosting ?
00:11:40 <mmorrow> qp_pq: compiles itself
00:12:06 <ski> i wonder if one could make a list-like type with elements of types (for four-element example), `f (f (f a))',`f (f (g a))',`f (g (g a))',`g (g (g a))'
00:12:20 <qp_pq> mmorrow: ok how ?
00:12:43 <mmorrow> qp_pq: just like how e.g. gcc compiles itself
00:12:45 <ivanm> kmc: what cool "shit" do we get?
00:13:05 <ski>   reify :: IO a -> Q a  -- ?
00:13:07 <qp_pq> mmorrow: right, so how ?
00:13:23 <mmorrow> qp_pq: um, by reading in the source code and compiling it :)
00:13:29 <ski> (ivanm : be glad it wasn't "warm")
00:13:37 <mmorrow> qp_pq: (w/ an existing ghc)
00:13:38 <ivanm> ski: heh
00:13:53 <mmorrow> qp_pq: so if you ever lose all ghc binaries, you're screwed!
00:14:21 <jrockway> C has the same problem, of course
00:14:30 <mmorrow> ski: reify :: Name -> Q Info
00:14:32 <ski> what problem ?
00:14:43 <jrockway> if you delete every C compiler, you can't compile the C compiler
00:15:04 <jrockway> i use the word "problem" lightly in that case ;)
00:15:15 <ski> maybe there's some simplistic C compilers (for subsets of C) written in assemblers ?
00:15:19 <qp_pq> erm .. it's hard to think that all the C compilers would suddenly vanish
00:15:24 <jrockway> yeah, there probably is
00:15:43 <kmc> can Hugs run GHC?
00:15:48 <ski> iirc, no
00:16:10 <mmorrow> qp_pq: C compiler /binaries/. suppose you got stranded on a desert island (that has an outlet, but no internet), and you by accident delete /usr/bin/cc :o
00:16:21 <mmorrow> time to learn asm!
00:16:34 <mmorrow> (and pray that you still have `as')
00:16:58 <jrockway> if you are ever trapped on a desert island with CMUCL binaries and the SBCL source, you will apparently be ok
00:17:03 <kmc> this reminds me of that self-propagating malware concept
00:17:04 <FunctorSalad> or get off the computer dammit
00:17:07 <FunctorSalad> ;)
00:17:16 <kmc> where you modify your compiler to make the same modification to every compiler it compiles
00:17:20 <FunctorSalad> maybe look for some food or something first
00:17:30 <kmc> and you can basically do arbitrary things to programs people compile, without there being any source-level evidence
00:17:48 <jrockway> a lot of effort to go to, though
00:17:49 <kmc> this was also a plot element in _Glasshouse_
00:18:07 <jrockway> you can probably put something like "/* jrockway's backdoor */" in arbitrary code and nobody will catch on
00:18:23 <jrockway> as long as the unit tests pass, there's no need to look at the source code!
00:20:04 <ski> s/source/object/
00:21:18 <ski> so the solution is to create a new compiler nobody but you knows about, compile it with a suspect compiler, then compile it with the resulting compiler
00:21:51 <Jafet> So you must be able to write your own compilers
00:22:08 <ski> *nod*
00:22:17 <Jafet> Another solution is to use a substantially simpler compiler (such as Bellard's tcc or even otcc)
00:22:25 <Jafet> It's harder to hide backdoors in simpler programs.
00:22:37 <ski> aye
00:22:41 <Elly> if you have a small enough compiler, it could be feasible (although painful) to hand-compile it
00:22:59 <Jafet> Then you'd have to be capable of hand compiling programs
00:23:01 <Jafet> I can't...
00:23:02 <Veinor> kmc: If I recall correctly the self-propagating malware actually happened
00:23:06 <kmc> yes
00:23:14 <kmc> it's an old unix story
00:23:38 * ski has plan sketches for a project with a compiler that will be hand-compiled using itself
00:23:40 <thoughtpolice> kmc: ken thompson's turing award paper is great
00:24:50 <kmc> trusting trust
00:24:53 <kmc> yeah, that's the one
00:25:55 <mmorrow> Jafet: hand compiling is easy. you just follow the instruction (:= the source-code) of the compiler you're compiling!
00:26:19 <Jafet> Touché
00:26:21 <Elly> hand-compiling C isn't that difficult
00:26:36 <Elly> if you can write a C compiler, you can certainly hand-compile :P
00:27:24 <qp_pq> and do you really think this Haskell language will be serious, like providing jobs and stuff ?
00:27:28 <FunctorSalad> wouldn't you just have to use an obscure enough compiler?
00:27:49 <FunctorSalad> (the bad gcc would have to know when it's compiling a compiler, yes?)
00:28:03 <kmc> can i write a (meta-level) haskell pattern as a TH quotation?
00:28:13 <Veinor> FunctorSalad: You could use heuristics in bad_gcc to detect whether you're compiling a compiler, I guess
00:28:23 <Jafet> qp_pq, no, I don't
00:28:30 <kmc> qp_pq, http://www.haskell.org/haskellwiki/Haskell_in_industry
00:28:33 <Jafet> qp_pq, try Java, lots of opportunities.
00:28:49 <Jafet> COBOL, job for life.
00:28:54 <kmc> or stick with perl, since people don't learn it anymore
00:29:10 <Veinor> yeah, perl is aging
00:30:04 <Jafet> So perl <6 might become the new visual basic? Glue that requires maintenance
00:30:18 <Veinor> at least perl doesn't have On Error Goto Next :D
00:30:20 <ivanm> Jafet: well, you can get good money working on old Cobol apps that businesses haven't ported and still need running...
00:30:31 <kmc> microsoft is still pushing VB, aren't they?
00:30:31 <Jafet> Precisely.
00:30:34 <qp_pq> Perl is shipped with almost every Linux/Unix distribution out there
00:30:43 <qp_pq> is Haskell shipped with every Linux/Unix distro ?
00:30:50 <Jafet> qp_pq, so was ALGOL 60.
00:30:57 <qp_pq> Jafet: when ?
00:31:01 <Jafet> And FORTRAN.
00:31:04 <qp_pq> Jafet: 20 years ago ?
00:31:08 <kmc> qp_pq, it's in the package manager of every major Linux distro
00:31:09 <Jafet> And some dialect of BASIC.
00:31:19 <kmc> (and by "Haskell" i assume you mean "a suitable Haskell implementation")
00:31:24 <mmorrow> kmc: yes, since you can represent Exp/Dec/etc as an Exp + one meta-level, you can represent code of *any* meta-level with Exp
00:31:31 <Jafet> (which means "ghc")
00:31:35 <mmorrow> , [|\x -> x|]
00:31:36 <lunabot>  LamE [VarP x_0] (VarE x_0)
00:31:39 <mmorrow> , lift =<< [|\x -> x|]
00:31:41 <lunabot>  AppE (AppE (ConE LamE) (ListE [AppE (ConE VarP) (AppE (AppE (ConE Name) (...
00:31:43 <mmorrow> , lift =<< lift =<< [|\x -> x|]
00:31:45 <lunabot>  AppE (AppE (ConE AppE) (AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (A...
00:31:48 <mmorrow> , lift =<< lift =<< lift =<< [|\x -> x|]
00:31:50 <lunabot>  AppE (AppE (ConE AppE) (AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (A...
00:31:58 <mmorrow> , lift =<< lift =<< lift =<< lift =<< lift =<< lift =<< [|\x -> x|]
00:32:00 <kmc> i mean something like:  case x of [|\x -> x|] -> ()
00:32:01 <lunabot>  AppE (AppE (ConE AppE) (AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (A...
00:32:07 <kmc> err bad example reusing x
00:32:22 <kmc> i don't think it's doable
00:32:28 <mmorrow> kmc: you can use a haskell QuasiQuoter to do that
00:32:33 <kmc> there are problems with alpha renaming; you'd probably want to do unification
00:32:34 <kmc> okay
00:32:38 <mmorrow> kmc: there's one in haskell-src-meta as an example
00:32:49 <mmorrow> (it's trivial in the sense that it's `id' on haskell code)
00:33:04 <mmorrow> it could manipulate the haskell in arbitrary ways
00:33:07 <mmorrow> as well
00:33:13 <Jafet> qp_pq, why don't you troll in ##ruby or something. Those guys need to be taken down a notch, and you're heroic enough to do it.
00:33:18 <qp_pq> would you say Erlang would be more job-getting than Haskell ?
00:33:31 <qp_pq> oh come on
00:33:36 <mmorrow> kmc: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.6/doc/html/src/Language-Haskell-Meta-QQ-Hs.html
00:33:39 <qp_pq> I'm just trying to make a decision here
00:33:40 <Veinor> why do some channels have double-hashes for their names, anyway? I know it's not an irc convention
00:33:41 <kmc> qp_pq, at the most recent Commercial Users of Functional Programming conference, there were more Haskell than Erlang people
00:33:50 <qp_pq> I'm trying to learn what next language I will learn
00:33:50 <kmc> qp_pq, anyway, just learn every language you can and decide for yourself :)
00:33:59 <Jafet> It's a Freenode convention that is occasionally applied when the staff feel like it
00:34:01 <kmc> qp_pq, i think haskell is a great language to learn even if you don't use it that much
00:34:02 <Veinor> ah.
00:34:08 <Veinor> what determines ## vs #, then?
00:34:08 <kmc> and you probably will use it more than you think now
00:34:22 <Veinor> haskell isn't just a language, it's a way of thinking
00:34:27 <Veinor> (only half-joking)
00:34:32 <kmc> the way of thinking is math
00:34:53 <qp_pq> uhm , I'm already doing math in Perl
00:34:55 <kmc> mmorrow, is the intention that some day, all TH will be done with quasi quoters?
00:34:58 <qp_pq> my problem is what to invest time in
00:35:03 <Jafet> http://freenode.net/policy.shtml#channelnaming
00:35:03 <kmc> qp_pq, but you can't reason *about* perl code mathematically
00:35:05 <kmc> not very well
00:35:11 <kmc> i'm talking about how the language works, not what you do with it
00:35:18 <qp_pq> if I should learn Perl6(an unfinished language as far as specs and implementation) or Haskell or Erlang
00:35:27 <qp_pq> these are quite exotic but I'm thinkign about the future
00:35:27 <FunctorSalad> some say that haskell will make you dislike other langs, though
00:35:31 <qp_pq> I'm still young so I got time
00:35:36 <qp_pq> or maybe I should learn better C or C++
00:35:38 <mmorrow> kmc: that would indeed be very cool (and useful) if TH could represent *all* haskell syntax inside quotes (including TH and QuasiQuoters)
00:35:38 <kmc> qp_pq, you're asking here so you probably know what we'll say
00:35:46 <FunctorSalad> (re: "it helps even if you don't use it")
00:35:49 <johnw> qp_pq: i'd say you'll have a lot of fun with Haskell
00:36:11 <arcatan> I feel if you're young you shouldn't think about future but go with what feels interesting
00:36:15 <johnw> knowing C++ well isn't worth the cost it takes, unless you plan to work in that field for a very long time
00:36:23 <kmc> mmorrow, but does QQ.Hs replace the regular non-quasi TH quotes?
00:36:27 <kmc> at least in theory?
00:36:44 <Veinor> I'm learning haskell without regard to whether it'll be useful, just because I think it's cool
00:37:02 <kmc> C++ is a good choice of language only within a very specific niche
00:37:15 <qp_pq> C++ is not niche
00:37:17 <qp_pq> is it ?
00:37:18 <kmc> you will have to find a job in that niche, *OR* put up with the fact that you're using manifestly the wrong language
00:37:21 <kmc> qp_pq, it's overused imo
00:37:32 <kmc> nobody should write a web browser in C++, or any other unsafe language
00:37:36 <qp_pq> so how can an overused language be niche ?
00:37:49 <qp_pq> is C safe to that extent ?
00:37:50 <kmc> qp_pq, i just explained
00:37:53 <kmc> C is not safe
00:37:56 <qp_pq> what is safe ?
00:37:58 <qp_pq> Haskell ?
00:38:06 <mmorrow> gah, i just lost my 3 sentence response by accidently closing #haskell window
00:38:06 <kmc> safe means that you will not get totally unpredictable behavior as a result of a programming error
00:38:12 <kmc> qp_pq, most languages are safe
00:38:23 <kmc> the ones that aren't usually have things like pointer casts
00:38:24 * mmorrow tries to remember
00:38:34 <ivanm> mmorrow: heh
00:38:44 <kmc> or arrays with unchecked bounds
00:38:49 <kmc> in Java, if you screw up you will probably get an exception
00:38:51 <qp_pq> what about Erlang
00:38:57 <qp_pq> is Erlang safe ?
00:39:01 <kmc> in C++ you get a segfault in the *best* case.  you might get a total disaster
00:39:15 <kmc> or it might work for a while, until you deploy the program in a situation where it could cause millions of dollars of damage
00:39:20 <kmc> then of course it will break
00:39:25 <kmc> to my knowledge Erlang is safe
00:39:36 <nvoorhies> or you might just never actually hit the error, ever
00:39:51 <qp_pq> and with Haskell ? will I hit the error ?
00:40:12 <kmc> with Haskell, most type errors are found at compile time
00:40:12 <mmorrow> kmc: since QuasiQuoters only can be used in expression and pattern context, they're more limited that TH in that sense. _but_, the Hs QQ gives you pattern quotes, which TH doesn't (on purpose). also, you'd have to implement TH quotes withing the Hs QQ somehow. so really they're /different/, but in principle they could be made /the same/
00:40:15 <ivanm> kmc: safe from what?
00:40:15 <nvoorhies> haskell will prevent some of the errors from happening by complaining to you when you compile
00:40:24 <johnw> haskell will just consume all of your stack memory and die at an unexpected moment -- despite the correctness of your code
00:40:45 <Jafet> C++ does not even guarantee you can call a function.
00:40:53 <mmorrow> but making them the same would correspond to TH being able to do TH (and so on recursively), which would make it not TH anymore (wrt the TH specification)
00:40:59 * Jafet sets channel mode: +pedant
00:41:43 <mmorrow> johnw: doesn't C just segfault when you exhaust your stack?
00:41:43 <Veinor> okay, I'm not even going to try using emacs from a terminal
00:41:47 <kmc> by safe, i suppose i mean that every compileable program has deterministic behavior
00:41:52 <papermachine> does any programming language *guarantee* you can call a function?
00:41:53 <kmc> but there are loads of caveats to that
00:42:17 <johnw> mmorrow: depends on the hardware, I thought SIGABRT happened with a stack overflow
00:42:27 <Jafet> Erlang probably isn't very safe, but it makes it convenient to write programs that are
00:42:33 <mmorrow> johnw: heh, possibly
00:42:36 <kmc> in C, a one-character typo could result in a program that works on Tuesday, formats your hard drive on Thursday, and subtly redefines the sqrt() function on Sunday
00:42:39 <_xor> What's TCO like in GHC?
00:42:42 <_xor> Again, I'm a newbie :P
00:42:45 <Jafet> papermachine, scheme tries.
00:42:48 <_xor> To Haskell I mean.
00:42:50 <kmc> tail-call optimization?
00:42:53 <_xor> yes
00:42:58 <johnw> segfault is usually address a memory page that hasn't been mapped to your process, or using a misaligned pointer (for some architectures)
00:42:59 <kmc> it's a mandatory part of the language specification
00:43:03 <erikc> no sigabrt, mostly just a segfault
00:43:04 <_xor> Oh, nice.
00:43:06 <FunctorSalad> total cost of ownership? ;o
00:43:10 <mmorrow> _xor: it's actually pretty useable ("it" := depending on that behavior)
00:43:18 <ivanm> kmc: is it?
00:43:18 <kmc> by "safe" i don't necessarily mean "statically typed"
00:43:19 <_xor> Hmm
00:43:46 <kmc> python is safe in this respect
00:43:46 <ivanm> I thought TCO wasn't that big a deal in Haskell due to laziness...
00:43:46 <qp_pq> shouldn't I master first C/C++ or some other well-known language before starting to learn a functional language ?
00:43:46 <erikc> by default, most c/c++ compilers wont generate any sort of checking in function prologues
00:43:46 <ivanm> qp_pq: why?
00:43:48 <kmc> qp_pq, i think functional programming will take over soon
00:43:50 <_xor> qp_pq: Understand the paradigms out there.
00:43:52 <kmc> because of many-core computers
00:43:53 <Xilon> I installed the binary distribution ghc-6.10.4-i386-apple-darwin.tar.bz2. Is there any way to get my original readline back? Python's interpreter stopped working, most likely because of it.
00:43:58 <Philippa> no: if you try to master C++ you'll be there a lifetime, and it doesn't necessarily help much
00:44:00 <johnw> qp_pq: "mastering" C++ will take you years
00:44:09 <kmc> also: C/C++ is not a language
00:44:13 <kmc> C and C++ are very different
00:44:14 <mmorrow> johnw: iirc in linux overrunning the stack does exactly that (tries to write to outside of your processes mem)
00:44:16 <qp_pq> it seems like I should come to Haskell by a reasoning of type "I was well aware of the defficincies of languages X,Y,Z and wanted to get more rigorous..."
00:44:18 <kmc> good C code is not good C++ code
00:44:21 <Jafet> qp_pq, you're wasting your time and ours, trolling here with your superficial understanding of computer programming.
00:44:21 <_xor> qp_pq: Understand the various paradigms, then learn a language from each is my suggestion.
00:44:30 <_xor> Mastering C++ takes ages, if it can ever really be done.
00:44:33 <mmorrow> johnw: on account of how memory gets mapped by the linker
00:44:35 <kmc> _xor, paradigms aren't a partition of languages
00:44:39 <FunctorSalad> Jafet: he isn't trolling
00:44:40 <johnw> mmorrow: ok, I'm sure it's segfault on many platforms
00:44:40 <mmorrow> johnw: (iirc)
00:44:40 <nvoorhies> haskell people have a bad habit of making nonsafe languages sound a lot scarier than they are, when the fact is a huge amount of stuff people use and depend on every day is unsafe and never breaks or does anything weird.  I think it makes people write off a lot of pro-haskell arguments as silly propaganda
00:44:46 <kmc> Haskell is functional and imperative.  python is functional, imperative, and OO
00:44:47 <_xor> kmc: No, they aren't...
00:44:57 <Jafet> FunctorSalad, and I'm bugs bunny
00:44:58 <_xor> kmc: My suggestion to learn one from each wasn't phrased properly.
00:45:02 <kmc> so your advice is to just learn python ;)
00:45:08 <_xor> kmc: From what he's asking, he's implying there's C++ and then there's functional
00:45:26 <_xor> kmc: While the reality is that there are many programming paradigms, each with their pros and cons, and many languages with their own subset of each paradigm.
00:45:31 <mmorrow> johnw: but i think it's /supposed/ to be another signal by some standard, which unfortunately isn't very followed
00:45:36 <qp_pq> Jafet: why do you keep making wrong assumptions about me ?
00:45:37 <johnw> I've been using C++ for 20 years now, working on a compiler, sat on the Committee for 7 years, and I have not mastered the language by a long shot.  I still need to master this new TMP stuff, and I haven't even looked at some of the new features in C++0x
00:45:38 <jrockway> almost all the unsafe code I interact with regularly fails
00:45:46 <jrockway> random oopses in dmesg, firefox dying for no reason, etc.
00:45:52 <Jafet> qp_pq, because you behave in a manner consistent with these wrong assumptions.
00:46:01 <kmc> nvoorhies, at my company we had a latent bug for 6+ years that was finally hit at a crucial time when it could cost us millions of dollars in a millisecond
00:46:05 <kmc> so yes, unsafe languages are scary
00:46:08 <Jafet> qp_pq, in the time you've been trolling here you could have gotten through several chapters of LYAH.
00:46:13 <johnw> reading C++ books mostly scares the crap of me, when I realize how many areas of the Standard are just "undefined behavior"
00:46:25 <FunctorSalad> qp_pq: he's also behaving in a manner consistent with a young person wondering what language to learn
00:46:47 <kmc> do we have an AGF policy here
00:46:47 <Jafet> qp_pq, or several chapters of a Moose or Perl 6 document, if you prefer.
00:46:53 <johnw> in my opinion, C++ is for earning a living, it's not for sated one's desire to find the perfect language
00:46:54 <dibblego> kmc, AGF?
00:46:58 <kmc> assume good faith
00:47:01 <FunctorSalad> err I meant @ Jafet
00:47:46 <jrockway> i was surprised to find recently that MS' C++ compiler does not even give you a warning when you return a pointer to something on the stack
00:48:03 <johnw> jrockway: that would require runtime analysis, I don't know of any compiler that does that
00:48:03 <jrockway> my colleague who was writing the program was even more surprised when his output started containing random memory addresses :)
00:48:05 <qp_pq> Jafet: dude, there are these opportunities for me to learn, I want to decide two questions 1) Should I learn more about network programming, parallelism, event loops, design patterns? 2) Should I learn a new language Perl6/Haskell/Erlang/more Prolog ?
00:48:05 <kmc> qp_pq, i feel like you have asked #haskell what language you should learn, and you have got your answer, and it's not a surprising one
00:48:10 <qp_pq> Jafet: that's why I came here to ask
00:48:26 <jrockway> johnw: really? this was a simple "char foo[42]; return foo"
00:48:37 <kmc> learn parallel progrmaming, and concurrent programming, and understand the difference between them
00:48:43 <kmc> learn how to do these in Haskell because it's very nice
00:48:44 <jrockway> he was a java programmer, and just assumed you could do that :)
00:48:51 <Jafet> qp_pq, so pick one and learn it, then pick another and learn it, instead of constantly bothering us
00:49:11 <nvoorhies> kmc: yeah but there's a difference between saying "here's some kinda bugs that we'll catch using this feature" and claiming that anything in the whole world could happen at any moment.  I know plenty of people who get nice and turned off by that kinda argument, since it's just not the case.  It's also predicated on lack of bugs in the compiler and runtime implementation, etc
00:49:19 <johnw> jrockway: ah, in something that simple, at least g++ says "warning: address of local variable ‘foo’ returned"
00:49:24 <qp_pq> Jafet: I reach my decisions through feedback ...
00:49:26 <jrockway> yeah
00:49:37 <jrockway> we also found that MS's C++ compiler segfaults when fed "Hello world"
00:49:43 <jrockway> so... that is the quality we are talking about there
00:49:48 <kmc> nvoorhies, the simple fact is that the language spec says "unspecified behavior" so yes, anything in the world could happen
00:50:02 <Jafet> nvoorhies, C and C++ do not call it "slightly possibly not very well defined behaviour" for a reason.
00:50:16 <kmc> i think people who are turned off by that are probably the people who program sloppily and think "oh if i make a mistake it will just segfault and i'll find it in the debugger"
00:50:27 <nvoorhies> in some world of platonic ideal compilers, sure.  But the behavior is going to be constrained by the real system it runs on
00:50:28 <jrockway> compilers should warn or fail to compile when you do something that is undefined
00:50:31 <jrockway> then it wouldn't be a problem
00:50:59 <jrockway> "the code you have written, while syntactically correct, will not work.  exiting."
00:51:03 <mmorrow> jrockway: but then you couldn't use C for a bunch of the applications you use it for
00:51:11 <kmc> jrockway, the problem is that C and C++ and the like define loads of things that might not be defined, but you don't know until runtime
00:51:12 <nvoorhies> I'm just saying it's destructive histrionics that make people write off the advocacy as BS
00:51:22 <kmc> i don't see it that way
00:51:23 <jrockway> mmorrow: pass in a flag to say, "ok, that undefined behavior is actually ok"
00:51:30 <johnw> heh, the C++ Standard distinguishes between "undefined behavior" and "unspecified behavior" :)
00:51:36 <mmorrow> jrockway: undefined behavior is defined when you know what's going to happen! ;)
00:51:43 <jrockway> yeah, exactly
00:51:46 <kmc> johnw, and "implementation-dependent behavior", no?
00:51:47 <nvoorhies> and that makes me kinda sad because it'd be nice to see more people use safe languages where they're a better idea
00:51:53 <jrockway> the flag enables a language extension that defines something that was previously undefined
00:52:06 <jrockway> there is no way you can write a correct program that depends on undefined behavior
00:52:08 <johnw> i think that's unspecified: "The implementation is not required to document which behavior occurs."
00:52:09 <kmc> nvoorhies, can you give an example of someone who was turned off by this?
00:52:29 <nvoorhies> 5 or 6 friends, me personally for a while
00:52:30 <kmc> johnw, what if they're required to document but they have freedom to choose?
00:52:31 <jrockway> i know of people that are not turned on by that
00:52:38 <nvoorhies> bunches of coworkers
00:52:39 <eivuokko> nvoorhies, then you'd want also use language that makes you write proof for your logic.
00:52:43 <jrockway> they are the type of people that return stack variables and think the program is fine, however
00:52:45 <Jafet> kmc, "implementation-defined"
00:52:46 <johnw> kmc: you mean, like the size of an int?
00:52:48 <eivuokko> The scale between safe and unsafe is not that clear.
00:52:48 <kmc> nvoorhies, really? can you explain the circumstances?
00:52:49 <jrockway> "the tests pass"
00:53:01 <nvoorhies> eivuokko: yeah sometimes, if it looks like it's going to be worth it
00:53:14 <eivuokko> nvoorhies, what are you doing here then? :)
00:53:16 <jrockway> a lot of "dynamic language" programmers are convinced that types are unimportant
00:53:22 <jrockway> when you say "haskell has static typing" they are turned off
00:53:27 <jrockway> because they don't think they need types
00:53:32 <erikc> qp_pq: whatever you learn, you'll need C, it's the language of operating systems, so ultimately any other language you use is going to need to bind to C libraries
00:53:38 <nvoorhies> kmc: probably, if I had lots of time to talk about my friends in an irc channel
00:53:45 <kmc> jrockway, but do they not understand that their languages are full of types?
00:53:45 <Jafet> Or worse, sometimes they don't think they're using types.
00:53:51 <jrockway> they do not understand that :)
00:53:54 <kmc> ugh
00:54:14 <jrockway> i think anything with an in-depth understanding of programming would realize that types are critical to programs
00:54:17 <qp_pq> erikc: why about C++ ?
00:54:23 <Jafet> erikc, many operating systems are not written in C.
00:54:29 <qp_pq> Jafet: name one
00:54:34 <kmc> House :D
00:54:36 <jrockway> yeah
00:54:39 <Jafet> There are operating systems written in C++, Haskell, Erlang
00:54:39 <qp_pq> House ?!
00:54:42 <qp_pq> what is that /
00:54:42 <qp_pq> ?
00:54:43 <kmc> slightly more serious: BeOS
00:54:46 <jrockway> there is no fundamental reason for anything to be written in C
00:54:47 <kmc> qp_pq, an OS written in Haskell
00:54:49 <kmc> toy / experimental
00:54:50 <Jafet> Lisp operating systems have existed for longer than C operating systems.
00:54:56 <Jafet> They still exist, I think.
00:54:58 <qp_pq> toy ... of course
00:54:59 <johnw> wow, even something like "i = v[i++]" in C++ is undefined.  this language is a like voodoo
00:55:01 <jrockway> you can bootstrap your high-level language from anything low-level
00:55:04 <kmc> qp_pq, "of course"...
00:55:13 <Jafet> Symbolics' Genera is not a "toy".
00:55:23 <kmc> johnw, yup, sequence points
00:55:23 <_xor> Dude
00:55:24 <Jafet> Well, it was not a toy.
00:55:24 <jrockway> if you need to write 0xf00d to address 0xdeadbeef, you can achieve that in a way other than "write the entire OS in C"
00:55:26 <erikc> Jafet: sure, but within the context of someone learning programming today with a career spanning 20 years
00:55:34 <erikc> it's gonna be C
00:55:35 <_xor> My suggestion to you is to learn simple & practicle first, like C.
00:55:38 <kmc> how many C++ programmers know what a sequence point is?  i sure as hell didn't when i first interviewed claiming to know C++
00:55:41 <Jafet> erikc, why are we suddenly talking about careers?
00:55:44 <_xor> Then move on to other languages, like C++, Python, Haskell, etc.
00:55:52 <qp_pq> Jafet: because I asked that
00:55:59 <qp_pq> and I'm concerned about my future
00:56:01 <qp_pq> as a programmer
00:56:07 <kmc> _xor, C is not simple in the sense of making easy things easy
00:56:08 <johnw> kmc: ah, i remember long days spent debating sequence points...
00:56:21 <kmc> qp_pq, are you asking these questions in other channels too?
00:56:23 <_xor> kmc: I meant the constructs.
00:56:32 <_xor> I don't know how much programming language experience he has.
00:56:36 <jrockway> kmc: the same people that think types are evil are the same ones that think abstraction is evil
00:56:37 <qp_pq> kmc: just this one
00:56:39 <jrockway> so C wins
00:56:39 <kmc> _xor, fair enough, i assumed as much, but thought it'd be good to clairify
00:56:58 <qp_pq> I think the people here have an oppinion that I can consider an important one
00:57:03 <johnw> kmc: when I interviewed prospective C++ programmers, I always ask them if they know what a partial template specialization was.  Not a single one ever did
00:57:03 <Jafet> People who prioritize money usually end up not making as much.
00:57:25 <qp_pq> Jafet: I haven't prioritized money...
00:57:26 <kmc> qp_pq, i agree, but i'm not sure we can give good career advice
00:57:42 <jrockway> writing useful programs and writing correct programs are orthogonal
00:57:49 <kmc> i think many people here are either in academia, or have a job not programming haskell and wish they had a job programming haskell
00:57:57 <Jafet> jrockway, they're highly correlated, so no
00:58:09 <kmc> learning haskell is bad for your job satisfaction because you probably won't like other languages anymore
00:58:20 <Jafet> By the way "more useful than any other existing program" does not equate to "useful".
00:58:31 <qp_pq> so my copy of "The C++ Programming language - Bjarne Stroustrup" goes to the bin today
00:58:42 <johnw> qp_pq: haha, which edition?
00:58:42 <jrockway> i am not sure why "jobs" are so worried about implementation languages
00:58:44 <qp_pq> should I buy some C books then ?
00:58:48 <qp_pq> johnw: latest I guess
00:58:50 <jrockway> i work at a pretty huge company, and i can use any language i want
00:58:51 <kmc> qp_pq, have you read K&R?
00:58:55 <Xilon> Mac OS really needs a package manager, now anything that depends on readline doesn't work :/
00:58:56 <johnw> qp_pq: send it to me instead of the bin!
00:58:56 <qp_pq> kmc: yes
00:59:04 <kmc> jrockway, how many people work on the same cod as you?
00:59:05 <_xor> heh
00:59:06 <Jafet> qp_pq, why? That's a good C++ book.
00:59:10 <_xor> I remember debating i=i++;
00:59:13 <_xor> What does that do in C++?
00:59:19 <kmc> _xor, UB i think
00:59:20 <qp_pq> Jafet: people here said C++ is not good
00:59:29 <_xor> kmc: Yup
00:59:29 <qp_pq> I trust that C will be needed many years from now
00:59:32 <Jafet> qp_pq, but that is a good C++ book.
00:59:32 <kmc> qp_pq, it's not that simple
00:59:36 <kmc> C++ will also be needed
00:59:36 <jrockway> kmc: for any given application, probably 2 or 3 other people
00:59:40 <jrockway> the whole team is about 10 people
00:59:43 <_xor> qp_pq: Dude, what are you trying to do?
00:59:47 <qp_pq> then how do you decide ?
00:59:48 <jrockway> outside of those 10, nobody will ever see it, probably
00:59:49 <_xor> Interim job security?
00:59:49 <kmc> qp_pq, don't expect us to rank every language once and for all
00:59:52 <_xor> Learn C# or Java or something
00:59:56 <qp_pq> what to learn and what to ignore ?
01:00:01 <johnw> qp_pq: I _like_ C++, it's not that it's not good
01:00:03 <qp_pq> _xor: what to learn..
01:00:04 <Jafet> qp_pq, what do you like?
01:00:07 <_xor> Progressing language academics?  Haskell, etc.
01:00:11 <thoughtpolice> C++ is a hugely massive language with some ridiculousness involved
01:00:12 <johnw> qp_pq: but you're young, man, have fun with something like Haskell
01:00:13 <kmc> C++ is complicated and will take forever to learn thoroughly
01:00:14 <_xor> Rapid development?  Python, etc.
01:00:17 <_xor> Lot of overlap too.
01:00:22 <thoughtpolice> but I will say I would *much* rather be using C++ at work than just C
01:00:25 <_xor> Yup
01:00:37 <kmc> C++ and C are very much not the same language, but there *is* a continuum between
01:00:39 <qp_pq> I like Perl but there is no company hiring Perl programmers in my country,or there are like 5-6 companies in all the country
01:00:40 <johnw> thoughtpolice: yeah, C++ w/ Boost is actually very nice compared to "the old days"
01:00:44 <_xor> I prefer C, but I like basic stuff from C++
01:00:45 <kmc> even when i don't have libstdc++ i like to use a few C++ features
01:00:48 <thoughtpolice> johnw: oh tell me about it
01:00:49 <qp_pq> so I need to learn something else
01:00:50 <_xor> So I use C++, with basic features.
01:00:54 <kmc> even on AVR :)
01:00:57 <thoughtpolice> boost is great; we use it at work with a lot of success
01:00:59 <jrockway> qp_pq: i work for one of the world's largest companies, and we use a lot of perl
01:01:07 <qp_pq> but I'd also like to be a good choice for personal projects
01:01:13 <qp_pq> kmc: AVR = ?
01:01:19 <thoughtpolice> we've had to modify/supplement it some, but it's very much worth it nonetheless
01:01:22 <kmc> qp_pq, a line of microcontrollers
01:01:24 <Jafet> qp_pq, if you want a language that gets you a job, go to a career advisor
01:01:33 <Jafet> qp_pq, we are not career advisors.
01:01:35 <jrockway> the answer to that is easy, Java
01:01:42 <jrockway> nobody has ever been fired for choosing Java
01:01:45 <qp_pq> Jafet: does a career advisor know about C++ or Perl or Haskell ?
01:01:51 <_xor> I do like C#.
01:01:54 <kmc> tiny computer, with like 16k program memory and 1k RAM
01:01:57 <jrockway> C# is a better java
01:02:00 <johnw> qp_pq: you simply can't lose by mastering Haskell
01:02:03 <Jafet> qp_pq, that depends on which career advisor you talk to.
01:02:09 <johnw> qp_pq: much of what you learn will be transferrable in an abstract sense
01:02:27 <johnw> qp_pq: it's like when I learned Common Lisp; largely useless, but immensely valuable
01:02:37 <jrockway> i appreciate .NET, as it is allowing us to gradually port the C++ code we inherited to a managed language
01:02:38 <kmc> fwiw i don't think haskell is useless
01:02:39 <thoughtpolice> it's funny, because up until my job I had a fairly large aversion to C++, not because I thought it was terrible, but because it was overly complicated. after working with it in a job, I'm *very* convinced it's complicated, but it's also a reasonable choice, and I don't know if I can really see myself just going back to plain old C
01:02:42 <kmc> but i think it will help even if you don't use it
01:02:46 <jrockway> C# segfaults a lot less than C++ written by idiots :)
01:02:52 <johnw> kmc: no, I wouldn't say that as much about Haskell
01:03:03 <thoughtpolice> of course, i will take haskell any day. :) me and a few coworkers will maybe push that
01:03:08 <thoughtpolice> likely with 0% success :(
01:03:08 <kmc> jrockway, can C# segfault at all?
01:03:12 <FauxFaux> jrockway: Only 'cos it's a lot easier to catch a NullSegfaultException in c#. :)
01:03:16 <kmc> in the absense of native calls that is
01:03:22 <jrockway> FauxFaux: oh, funny that you mention that
01:03:30 <jrockway> this code was catching segfaults in a try {} catch {} block
01:03:34 <johnw> kmc: with Haskell I Can write scripts, and have nicely compiled executables very easily, that makes it very usable as a systems language
01:03:36 <kmc> to me conceptually "segfault" means "UB that we caught this time, you lucky bastard"
01:03:38 <jrockway> i think some stuff is managed in microsoft's C++
01:03:44 <jrockway> (there is a "gcnew" allocator, for example)
01:03:48 <kmc> so a NullDereferenceWhateverException isn't like a true segfault
01:03:51 <eivuokko> kmc, there's the unmanaged/unsafe in C# as well.  Not usually used, though.
01:04:02 <_xor> jrockway: There's managed and unmanaged C++ with Microsoft
01:04:06 <jrockway> yeah
01:04:11 <_xor> Managed is just C++ that generate IL
01:04:21 <_xor> Unmanaged is C++ that generates native code
01:04:24 * FauxFaux works at an enterprisey Java shop and sees plenty of NPEs, fwiw, but that's due to the fact that the code is not designed at all.
01:04:27 <jrockway> we are using managed C# libraries from this C++, but the C++ is clearly not managed itseful
01:04:37 <_xor> Managed C++ has new keywords for that type of stuff (the __gc stuff, etc)
01:04:41 <Jafet> Segfault is a memory access violation caught by the memory controller of a protected mode operating system
01:04:48 <qp_pq> can I decide on knowing like 2 languages really well ?
01:04:50 <qp_pq> or 3 langauges ?
01:04:58 <jrockway> (you can get a pointer to the stack and randomly read the saved return address, etc.)
01:05:00 <kmc> qp_pq, Python, Haskell, C
01:05:06 <Rotaerk_> it's not called "Managed C++" anymore.. that's obsolete
01:05:09 <Rotaerk_> it's C++/CLI
01:05:11 <kmc> if you want arbitrary very concrete advice, there it is
01:05:11 <qp_pq> kmc: Python I already know a bout and C also
01:05:13 <FauxFaux> As everyone else said, qp_pq, the majority of skills are transferable.
01:05:22 <johnw> segfault is a good thing; a bad one is overwritten memory that silently produces incorrect results but never crashes
01:05:24 <qp_pq> kmc: I've built this in python/django http://spx2.perlmonk.org:7000
01:05:27 <Veinor> let (Nimber a) * (Nimber b) = Nimber $ fromJust $ mex [fromNimber $ a' * (Nimber b) + (Nimber a) * b' + a' * b' | a' <- map Nimber [0 .. (a-1)], b' <- map Nimber [0 .. (b-1)]]
01:05:30 <Veinor> ew. :/
01:05:31 <jrockway> johnw: yeah
01:05:52 <jrockway> in the case of this app, the data was silently wrong because the original programmer played fast and loose with char arrays
01:06:00 <jrockway> the idea is to fix the damage and port the code to C# gradually
01:06:12 <jrockway> (not my project, i just happen to be the only person on the team that has ever written C++, sadly)
01:06:13 <kmc> yeah.  it's really terrible how returning the address of a stack-allocated array will *usually* work, for a while
01:06:13 <Jafet> Veinor, the perfect at-a-glance clarity that is typical of Haskell programs
01:06:18 <jrockway> yup
01:06:21 <johnw> i really liked C# when I used it, more than Java (which I use now)
01:06:22 <jrockway> his unit tests passed
01:06:28 <jrockway> but the actual program did not work :)
01:06:31 <Veinor> Jafet: haha
01:06:38 <jrockway> it was because there were two 2048-char arrays on the stack
01:06:38 <Araneidae> Hi.  How would people recommend running GHC on Ubuntu?  Binary install from http://haskell.org/ghc/download_ghc_6_10_4.html or use Ubuntu packages?
01:06:40 <johnw> what I can't get enough of is Haskell type inference
01:06:43 <johnw> Hoogle blows my mind
01:06:44 <jrockway> the return value was the second one
01:06:48 <kmc> hmm, maybe Nimber can be made Enum and Bounded?
01:06:54 <jrockway> so it was "padded" by the first 2k, and didn't get overwritten for a while
01:06:55 <kmc> to get rid of the map
01:06:56 <Araneidae> I'm asking because Ubuntu packages seemed a bit behind, but seem to have caught up now...
01:06:57 <jrockway> so amusing
01:07:04 <kmc> [Nimber 0 .. Nimber (a-1)]
01:07:08 <Veinor> kmc: It's also slow as molasses.
01:07:15 <Veinor> what I wrote, I mean.
01:07:15 <Jafet> Araneidae, I don't use the repo ghc or ghc packages
01:07:29 <Veinor> also, Nimber isn't bounded.
01:07:33 <johnw> i just wish ghc would come to Snow Leopard already, without having to hack scripts
01:07:34 <kmc> err yeah
01:07:37 <Araneidae> Jafet, so you use a local install?  Ok, that's a vote for download!
01:07:37 <kmc> Enum then
01:07:41 <johnw> MacPorts still doesn't have it yet
01:07:41 <jrockway> Araneidae: i use debian packages when they are up to date
01:07:45 <Veinor> Enum would work.
01:07:47 <kmc> @type enumFromTo
01:07:48 <lambdabot> forall a. (Enum a) => a -> a -> [a]
01:07:49 <jrockway> when they are not up to date, i install in my homedir
01:07:54 <jrockway> debian has been very good lately, however :)
01:07:55 <Veinor> the question is, how do I make that algorithm go faster?
01:08:25 <Veinor> (yes, there is a closed form)
01:08:33 <Veinor> (well, sort of)
01:08:33 <mmorrow> johnw: yeah, type inference is definitely one of the killer features
01:08:38 <Araneidae> jrockway, yes, that's what I did; think I'll try going back to repo install, looks like they've caught up with 6.10.4
01:08:46 <jrockway> yeah
01:08:58 <_xor> Allow me to introduce you guys to Hindley-Milner
01:09:17 <Araneidae> What about cabal, though?  Seem to remember having *loads* of hassle getting that working before...
01:09:35 <mmorrow> except hindley milner is limited compared to haskell's type system
01:09:45 <jrockway> Araneidae: "wget <that script>; ./<that_script>"
01:09:48 <_xor> What's the method that Haskell uses for TI?
01:09:57 <jrockway> where <that script> is mentioned on the cabal-install website
01:10:04 <Jafet> mmorrow, hs98 is not deducible with HM?
01:10:05 <mmorrow> _xor: it hindley-milner + extensions
01:10:08 <jrockway> pretty sure i did that, and cabal-install works fine for me
01:10:22 <mmorrow> Jafet: i'm not sure
01:10:33 <Araneidae> Yah.  Ok, guess I'll have to bite the bullet.  It's been many months since I last played with Haskell...
01:10:34 <_xor> ah interesting.
01:10:34 <kmc> _xor, magic
01:10:36 <Veinor> kmc: can you help me figure out why that takes horribly long to run?
01:10:40 <kmc> every ghc comes with some ground up unicorns
01:10:45 <kmc> Veinor, i'll take a look
01:10:48 <kmc> can you hpaste some code?
01:10:50 <_xor> ok
01:10:52 <_xor> 4:10am here
01:10:53 <mmorrow> Jafet: i think haskel98 still retains the ability to infer everything without *any* annotations
01:10:54 <_xor> Time for sleeps.
01:10:58 <kmc> 'night _xor
01:10:59 <shrughes> installing the binary on ubuntu 9.10 worked fine for me, I did it today
01:11:03 <_xor> night night :)
01:11:30 <Araneidae> Actually ... there's no pressing reason to upgrade from 6.10.1 to 6.10.4 is there?  That's what I'm worrying about...
01:11:51 <kmc> Haskell Platform uses 6.10.4
01:11:56 <Veinor> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12163#a12163
01:12:03 <Veinor> + is a simple bitwise xor
01:12:04 <kmc> so the most important libraries are guaranteed to work with it
01:12:18 <ivanm> Araneidae: there was a bug in 6.10.4's base I think
01:12:26 <kmc> @type notEnum
01:12:28 <ivanm> Araneidae: well, later versions had a different version of base anyway
01:12:28 <lambdabot> Not in scope: `notEnum'
01:12:32 <kmc> @hoogle notEnum
01:12:32 <lambdabot> No results found
01:12:35 <kmc> Veinor, ^^^^ ?
01:12:43 <mmorrow> Jafet: but, e.g. vanilla hindley-milner doesn't handle polymorphic recursion, so maybe haskell98 even is HM+stuff
01:12:44 <ivanm> Araneidae: biggest difference with 6.10.4: it uses haskeline for ghci rather than editline (or patched to use readline)
01:12:46 <Araneidae> ivanm, did you mean bug in 6.10.1?  Looks like 6.10.4 is current
01:12:52 <Veinor> er
01:12:53 <ivanm> Araneidae: ummm, yeah
01:12:55 <kmc> Veinor, also that's one crazy long line
01:12:58 <Veinor> that should be notElem
01:13:00 <ivanm> s/editline/libedit/
01:13:22 <Jafet> I see
01:13:26 <kmc> Veinor, you're doing a linear search of xs for every [0..]
01:13:34 <Araneidae> Oh, what's a good editor to use for Haskell editing?  I'm used to emacs style keybindings (but not emacs programming!)
01:13:36 <kmc> make xs into a Data.Set instead
01:13:47 <kmc> @src elem
01:13:47 <jrockway> Araneidae: i use emacs
01:13:47 <ivanm> Araneidae: there's haskell-mode for emacs
01:13:48 <lambdabot> elem x    =  any (== x)
01:13:51 <kmc> @src any
01:13:51 <jrockway> it has emacs-style keybindings :)
01:13:51 <lambdabot> any p =  or . map p
01:13:55 <ivanm> Baughn has recently done a lot of work for it
01:13:57 <Veinor> kmc: that would work, yeah
01:13:57 <jrockway> there is also Yi
01:14:04 <ivanm> jrockway: dammit, you beat me to it! ;-)
01:14:12 <Araneidae> Yeah.  Last time I tried real emacs I hated it
01:14:25 <ivanm> there's also support for [g]vi[m], eclipse as well
01:14:27 <ivanm> Araneidae: why?
01:14:42 <kmc> writing your own editor is a fun exercise
01:14:52 <Araneidae> Alas, I have 20 years of finger memory tying me to bindings that aren't exactly emacs, and configuring emacs is *horrible*!
01:14:52 <Veinor> the problem is: can you do set comprehensions?
01:14:58 <kmc> Veinor, no
01:15:03 <kmc> use Set.fromList
01:15:11 <Veinor> right.
01:15:11 <Araneidae> Did try Yi a while ago, but it was pretty broken then -- has it got better?
01:15:25 <kmc> or build the comprehension directly out of map, filter, etc on Set
01:15:25 <ivanm> Araneidae: it installs and runs with no problems; good enough? :p
01:15:27 <jrockway> it is very usable
01:15:29 <jrockway> but not very emacs
01:15:30 * ivanm hasn't done anything else with it
01:15:32 <Veinor> how do you do a qualified import in ghci?
01:15:39 <kmc> Veinor, you can't :/
01:15:41 <Veinor> :(
01:15:48 <kmc> there's a GHC bug ticket for it in fact
01:15:49 <ivanm> jrockway: can't it be qualified with an emacsen?
01:15:56 <ivanm> kmc: yeah, there is, a new one IIRC
01:15:59 <kmc> you can import a module that imports something qualified
01:16:07 <Araneidae> Thanks guys.  Quite a friendly channel, must say :D
01:16:10 <ivanm> which would also help to shorten the prompt... >_>
01:16:15 <jrockway> it is probably enough emacs for most people, but i am a pretty hardcore emacs user, so i notice little things that are slightly different
01:16:17 <Veinor> basically II want to play around with Data.Set in ghci
01:16:25 <jrockway> it is yi, not emacs :)
01:16:27 <ivanm> Araneidae: ssshhhh! don't spread it around! :p
01:16:34 * Araneidae keeps mum
01:16:38 <kmc> Veinor, make a file which does the import
01:16:40 <shrughes> ?users
01:16:40 <lambdabot> Unknown command, try @list
01:16:40 <ivanm> jrockway: emacs is an emacsen...
01:16:45 <shrughes> @users
01:16:45 <lambdabot> Unknown command, try @list
01:16:52 <ivanm> shrughes: that plugin was removed a while back
01:16:57 <shrughes> oh
01:16:57 <ivanm> as it had a memory leak
01:17:05 <ivanm> and was the reason lambdabot kept crashing so often
01:17:07 <ivanm> @uptime
01:17:07 <lambdabot> uptime: 13d 14h 55m 58s, longest uptime: 1m 10d 23h 44m 29s
01:17:09 <ivanm> \o/
01:17:15 <shrughes> @uptime
01:17:16 <lambdabot> uptime: 13d 14h 56m 7s, longest uptime: 1m 10d 23h 44m 29s
01:17:20 <Araneidae> Hm.  Oh well.  Wondering how to uninstall my ghc with least pain...  Guess I'll just move my local/bin to one side for now
01:17:21 <ivanm> we had it up to 22 days recently until the server died IIRC...
01:17:23 <shrughes> let's see if this has a leak too :/
01:17:39 <ivanm> shrughes: no, it was the way the users plugin was storing when people was online
01:17:45 <shrughes> oh okay
01:17:49 <ivanm> shrughes: if you want to know when someone was last on, now use preflex rather than lambdabot
01:17:55 <ivanm> preflex: seen lambdabot
01:17:55 <preflex>  lambdabot was last seen on #haskell 40 seconds ago, saying: uptime: 13d 14h 56m 7s, longest uptime: 1m 10d 23h 44m 29s
01:19:01 <FunctorSalad> preflex: users
01:19:13 <kmc> preflex: what else can you do?
01:19:17 <qp_pq> I'm sad I haven't readched a conclusion , the problem is that learning {C,C++,Haskell,Perl,math} seems too much
01:19:21 <Araneidae> Argh.  First install conflict: "libghc6-src-exts-dev:
01:19:22 <Araneidae>   Depends: libghc6-cpphs-dev (<1.7+) but 1.9-1 is to be installed"
01:19:35 <kmc> qp_pq, get some modafinil
01:19:36 <qp_pq> I should settle on 3 of these maybe ... although I spent some money on Bjarne's book in vain
01:19:42 <kmc> so you don't have to sleep
01:19:47 <shrughes> The trick is to skip C++, C, Perl, and math.
01:20:03 <ivanm> shrughes: why skip maths?
01:20:12 <qp_pq> kmc: I already don't sleep very much
01:20:14 <Jafet> Because it's so hard!
01:20:23 <FunctorSalad> kmc: you learn during sleep no?
01:20:41 <FunctorSalad> if you did a lot the day before
01:20:42 <kmc> FunctorSalad, you learn during sleep-dep-induced hallucination as well!
01:20:52 <shrughes> ivanm: I was just doing {...} \ {Haskell}
01:20:53 <kmc> but yes sleep is actually important
01:21:07 <Jafet> kmc, you should play an elf next time
01:21:46 <FunctorSalad> elf?
01:21:50 <FunctorSalad> which kind?
01:21:59 <kmc> sexy elf
01:22:25 <FunctorSalad> ah, not the format
01:22:34 <Jafet> All elves are sexy!
01:22:51 <kmc> keebler elves?
01:22:59 <medfly> qp_pq, haha, I have a similar problem!
01:23:11 <FunctorSalad> and really, what was that in reference to Jafet ?
01:23:18 <FunctorSalad> (`play an elf next time')
01:23:20 <medfly> qp_pq, however, it doesn't look as bad here, considering I have excellent motivation for it, and I don't have to learn evil maths
01:23:27 <Jafet> Elves don't need to sleep
01:23:44 <eivuokko> Math isn't evil -.-'  Bad teachers are.
01:24:11 <qp_pq> medfly: I do have to learn it
01:24:22 <medfly> I don't like maths.
01:24:23 <qp_pq> and because I have to learn I try to make stupid excuses out of it so it seems more interesting
01:24:27 <qp_pq> and I implement it in Perl
01:25:06 <qp_pq> like this CM::Group::Sym that implements the symmetric group S_n in Perl http://perlhobby.googlecode.com/svn/trunk/scripturi_perl_teste/cm-permutation/cpan/CM-Permutation/
01:25:12 <shrughes> If you're going to avoid one for now, avoid C.
01:26:15 <qp_pq> shrughes: oh, and what should I learn for systems programming then ?
01:26:40 <shrughes> C++.
01:26:41 <Jafet> Which system do you want to program?
01:26:58 <Veinor> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12165#a12165
01:27:01 <qp_pq> Linux
01:27:04 <shrughes> Well, Haskell maybe, for systems programming.  But between C and C++, I'd say C++ is preferable.
01:27:09 <Jafet> You already know perl.
01:27:22 <Veinor> the problem as I see it is that a * b isn't being memoized
01:27:35 <qp_pq> yes but I'd have to leave country to get a job with Perl
01:27:44 <kmc> Veinor, you're still doing linear search... isn't that a problem too?
01:28:00 <Jafet> What's a country?
01:28:01 <Veinor> the problem is that I need t ofind the least element that's not in xs
01:28:09 <shrughes> If you learn C++, you'll know the mechanics of C, although maybe you'd have to look up how unions work and of course much of the standard library.
01:28:16 <Veinor> which in general will require iterating over the entirety of xs.
01:28:34 <kmc> no
01:28:42 <kmc> there are datastructures which can be searched in time less than O(n)
01:28:44 <jrockway> qp_pq: you know mst, right?
01:28:47 <Jafet> (Thinking you) know the syntax of C and semantics of C does not help you a lot when programming C.
01:28:49 <jrockway> he hires perl people that are not from the UK
01:28:50 <qp_pq> jrockway: yeah
01:28:52 <qp_pq> jrockway: what about him
01:28:55 <jrockway> one of his guys is from brazil or something
01:28:56 <kmc> Veinor, like Data.Set.Set
01:28:59 <jrockway> he doesn't care
01:29:09 <Veinor> kmc: yeah, but you're basically searching for the minimum element of its complement :P
01:29:20 <jrockway> nothingmuch works for a US company and is from Israel
01:29:30 <qp_pq> and he lives in Israel ?
01:29:37 <qp_pq> I worked telecommute for a while
01:29:38 <kmc> right.  you have to linear search [0..].  you don't have to linear search xs for *each* of those
01:29:44 <kmc> unless i'm missing something, that should matter
01:29:58 <jrockway> yes, technically
01:30:00 <Veinor> hm
01:30:03 <jrockway> most of the time he lives on someone's couch :)
01:30:17 <medfly> wow, that must suck
01:30:31 <shrughes> you can use a BST whose inner nodes summarize the BST with an interval from the minimim element through consecutive elements
01:30:33 <Veinor> kmc: so could you post how you would implement mex using a Data.Set?
01:30:42 <Jafet> Well, how fluffy is the couch?
01:31:01 <jrockway> depends, i suppose
01:31:13 <jrockway> my couch is not fluffy, but he seemed to enjoy it
01:31:27 <jrockway> personally, i could never do the whole couch surfing thing
01:31:31 <Veinor> also, I think I just need to memoize the multiplication values
01:31:35 <kmc> mex xs = let s = Set.fromList xs in find (`Set.notMember` s) [0..]
01:31:37 <jrockway> i like my desk and 24" monitor and ...
01:31:39 <qp_pq> jrockway: I seem to acquire much faster and I'd appreciate better now if I'd work in a team for example
01:31:47 <qp_pq> jrockway: comparing to 2 years ago...
01:31:53 <jrockway> i see
01:31:56 <qp_pq> jrockway: s/acquire/acquire knowledge/
01:32:05 <Veinor> ahhh
01:32:06 <Veinor> okay.
01:32:11 <jrockway> because of the constraints you have added, you should find a job you want and learn that langauge
01:32:33 <qp_pq> jrockway: would you say Perl is still healthy as far as jobs go ?
01:32:51 <qp_pq> the problem with working telecommute is you're like on a boat ...it's pretty cool for a while
01:33:02 <qp_pq> then you tart to not socializing with anyone and exchanging oppinions and views
01:33:03 <qp_pq> and that's bad
01:33:12 <jrockway> it is a mixed bag
01:33:19 <jrockway> i have looked at jobs.perl.org and don't want any of those jobsa
01:33:21 <johnw> i loved Perl 4
01:33:28 <johnw> modern Perl leaves me underwhelmed
01:33:41 <qp_pq> johnw: under ? for me it's over
01:33:46 <jrockway> but OTOH, i mostly program perl and have a job i like... so maybe jobs.perl is the problem, rather than perl itself
01:33:47 <johnw> haha
01:33:52 <qp_pq> johnw: well... not over, I still have it under control
01:33:53 <johnw> yeah, that too
01:34:02 <jrockway> "modern perl" is pretty nice
01:34:03 <johnw> i wrote modules for CPAN that I can't even read anymore
01:34:08 <jrockway> tons of libraries, good object system
01:34:22 <jrockway> if haskell had the libraries perl did, i would prefer haskell
01:34:25 <jrockway> or even common lisp
01:34:29 <johnw> oh yeah
01:34:31 <jrockway> but it doesn't... so i stick with perl
01:34:31 <Veinor> kmc: that didn't really speed it up.
01:34:34 <johnw> if haskell had those kinds of libraries, man
01:34:41 <jrockway> it is getting there
01:34:52 <johnw> Haskell still has no compelling logging module though
01:34:55 <Jafet> Haskell <- perl FFI?
01:35:03 <Jafet> That would be hilarious
01:35:03 <medfly> jrockway, maybe you're too picky.
01:35:03 <johnw> the one that's in Cabal I did not like very much
01:35:06 <jrockway> "the writer monad"
01:35:21 <jrockway> there is an ocaml/perl bridge somewhere
01:35:31 <Veinor> like I said, memoization I think is key, because this is a heavily recursive function
01:35:37 <Jafet> There's a lot more to logging than Writer
01:36:14 <kmc> Veinor, you're looking for the smallest n such that n `notElem` xs, right?
01:36:20 <jrockway> most of the logging i do in perl looks a lot like Writer
01:36:30 <jrockway> but most of the logging i see other people do does not look like Writer
01:36:43 <jrockway> it looks like Random Global Variable That Is Randomly Mutated
01:36:52 <FunctorSalad> Veinor: basics: you are compiling with -O2?
01:36:52 <Veinor> kmc: I don't think the slowdown is in mex, I think it's in the fact that a * b has to know (a - 1) * b, and then a * (b-1)
01:37:12 <Veinor> I'm not compiling it atm, I'm just running it in ghci
01:37:19 <FunctorSalad> that's your problem
01:37:21 <kmc> Veinor, ah.  it will be faster compiled
01:37:22 <shrughes> jrockway: examples?  how can logging not be like the Writer?
01:37:25 <FunctorSalad> enormous difference.
01:37:26 <kmc> but you also have a good point
01:37:30 <kmc> so maybe you should memoize
01:37:35 <kmc> look at data-memocombinators package
01:37:39 <jrockway> shrughes: most people do logging in an unstructured way
01:37:44 <jrockway> there is a "singleton" somewhere
01:38:00 <johnw> but what if I write my code, then decide after that I want it to have logging in it?  Haskell doesn't make that an easy switch at all
01:38:02 <jrockway> you set "warn" to write to the database and "debug" to write to stderr, etc. for the whole program
01:38:08 <johnw> (to my limited knowledge)
01:38:13 <jrockway> then you call global functions that mutate that global state
01:38:18 <Jafet> johnw, er what
01:38:24 <jrockway> so of course, your database is global and *STDERR is global, etc.
01:38:28 <jrockway> it is just a mess
01:38:34 <shrughes> jrockway: seriously?  ok
01:38:49 <shrughes> jrockway: i'm used to people using log4net which is.. slightly less global
01:38:55 <kmc> johnw, what are you logging?  "doing" things?  then you're already using a monad of some kind
01:39:16 <jrockway> exactly
01:39:16 <kmc> if you just want to log the evaluation of pure functions, it's trickier, because those are supposed to be transparent
01:39:22 <jrockway> a newtype wrapper will hide what actually happens
01:39:23 <Araneidae> Huh.  haskell.org is frozen at the moment
01:39:27 <kmc> but if you're logging "actions", as most programs do, you're fine
01:39:30 <jrockway> one day "log" can be writer, the next it can be a no-op
01:39:51 <shrughes> or is it?  I don't know.  We have named static loggers in every class and call LogUtil.GetLog() usually to get the class name when logging
01:40:02 <shrughes> anyway, it would be nice if haskell didn't have any pure functions
01:40:02 <jrockway> yeah, i think that is messy
01:40:05 <shrughes> it is
01:40:08 <jrockway> i create an instance when the program starts and pass that around
01:40:14 <Veinor> it's still slow even with -O2
01:40:17 <jrockway> (or rather, the dependency injection machinery does that)
01:40:26 <jrockway> $self->logger->warn('foo')
01:40:32 <Veinor> not as slow, but still on the order of seconds.
01:40:34 <jrockway> messy, perhaps, but at least it is structured
01:40:43 <shrughes> passing it around isn't good because it helps imo to log the classname
01:40:50 <Araneidae> How do I resolve this: from `cabal install yi` I get (after lots of builds): cabal: alex version >=2.0.1 && <3 is required but it could not be found.
01:40:59 <FunctorSalad> johnw: rewriting the code from pure to monadic is quite some work indeed, but if it is already monadic then adding MonadWriter is usually easy
01:41:15 <jrockway> shrughes: $self->logger can return an object that delegates to the real logger
01:41:19 <jrockway> (and adds the classname, if desired)
01:41:23 <shrughes> okay
01:41:27 <jrockway> but in perl, the logging library can just pull that off the call stack
01:41:34 <jrockway> so it is not actually implemented this way
01:42:12 <jrockway> i am not a hardcore log user, however
01:42:37 <jrockway> i just log things like "[info] parsing foo.csv" and "[error] something bad happend <stack trace>"
01:42:45 <Araneidae> Surely the yi install should have installed alex?  Ok, ran `cabal install alex` and now now get a compliation failure inside Yi/Prelude.hs
01:43:03 <jrockway> strange
01:43:06 <jrockway> perhaps ask on #yi?
01:43:12 <Jafet> FunctorSalad, just add IO to typesigs?
01:43:27 <Veinor> kmc: how can I install Data/MemoCombinators into ., if you get what I mean?
01:43:35 <FunctorSalad> Jafet: not necessart, I mean just add WriterT to your monad stack
01:43:38 <kmc> cabal install data-memocombinators
01:43:40 <FunctorSalad> *necessary
01:43:47 <kmc> oh, into the direcotry?
01:43:48 <kmc> don't know
01:43:51 <Jafet> I mean, for pure -> monadic
01:43:56 <FunctorSalad> ah
01:44:03 <Veinor> hm, I need to install cabal on this machine
01:44:21 <FunctorSalad> Jafet: how is that enough? you'll have to add all the binds, returns, liftMs
01:44:21 <Veinor> cabal works find without root, correct?
01:44:32 <Veinor> *fine
01:44:45 <Araneidae> jrockway, well if there's any life there, we'll see.
01:44:54 <Jafet> Oh true, you have to do it recursively
01:44:56 <jrockway> Veinor: i use it without root
01:45:09 <Veinor> cool.
01:45:26 <Jafet> You could unsafePerform the log!
01:45:28 <Araneidae> Here's the error message (micro-flood of five lines coming):
01:45:32 <Araneidae> Yi/Prelude.hs:182:9:
01:45:32 <Araneidae>     Duplicate instance declarations:
01:45:32 <Araneidae>       instance Category Accessor.T -- Defined at Yi/Prelude.hs:182:9-38
01:45:32 <Araneidae>       instance Category Accessor.T
01:45:32 <Araneidae>         -- Defined in data-accessor-0.2.1:Data.Accessor.Private
01:45:33 <Veinor> odd, haskell.org is being slow.
01:45:39 <jrockway> what would be relevant to log in a pure function?
01:45:44 <Araneidae> It's not responding at all to me
01:45:57 <Jafet> Something that you were to lazy to test when you wrote it ages ago.
01:45:59 <jrockway> if you are just trying to track control flow while you are developing, that' snot logging
01:46:30 <jrockway> unit tests, Debug.Trace, etc.
01:46:59 <jrockway> logging is for conveying a the results of a sequence of events to the outside world
01:47:02 <jrockway> which is almost always monadic
01:47:03 <Veinor> yeah, it's not responding at all.
01:47:11 <Veinor> :/
01:47:22 <jrockway> (the "sequence of events" is the clue there :)
01:47:52 <Jafet> jrockway, sorry, we're busy conflating logging with debugging output here
01:48:02 <Jafet> Come back later.
01:48:11 <shrughes> jrockway: in some situations you might want to add heavy debug logging to be deployed somewhere in the real world to figure out where the logic is going wrong, and the code in question is pure
01:48:19 <FunctorSalad> pure functions can produce warnings etc too
01:48:25 <jrockway> yeah, true
01:48:35 <Araneidae> Where are the sources that cabal is compiling?
01:48:37 <jrockway> if they can produce warnings, they are no longer pure though, right
01:48:46 <jrockway> an academic distinction, of course, but technically...
01:48:59 <Jafet> shrughes, it's a pure function. It should be correct when it ships
01:49:01 <FunctorSalad> well you can collect them in a pure way, in Writer :)
01:49:02 <shrughes> Araneidae: where online or where on your machine?
01:49:14 <Araneidae> On my machine, I need to dig into the error report
01:49:19 <jrockway> well, now you are "monadic"
01:49:30 <Araneidae> Said: [ 19 of 120] Compiling Yi.Prelude       ( Yi/Prelude.hs, dist/build/Yi/Prelude.o )
01:49:31 <jrockway> in which case, it's not hard to add the WriterT to your stack
01:49:37 <Veinor> since haskell.org seems to be down, can anybody tell me how to install a cabal .tar.gz file into someplace I can install to without root?
01:49:38 <Araneidae> Where is Yi ?
01:49:58 <jrockway> Veinor: for me, it's the default
01:50:04 <Veinor> I meant without cabal.
01:50:15 <Araneidae> `find ~/.cabal/ -name Yi` reports nothing
01:50:18 <Veinor> because haskell.org is being uncooperative.
01:50:28 <Veinor> ls
01:50:31 <jrockway> Araneidae: because it fails to compile and isn't installed there yet?
01:50:36 <Veinor> this isn't a terminal!
01:50:47 <Araneidae> Well, it was compiling it *somehwere*!
01:50:51 <jrockway> Veinor: ahh, good question
01:50:53 <jrockway> i always use cabal
01:50:56 <jrockway> even for my own apps :)
01:51:05 <shrughes> configure build install
01:51:11 <shrughes> I think you pass --user to configure
01:51:30 <jrockway> makes sense
01:51:32 <shrughes> runhaskell Setup.hs configure --user && runhaskell Setup.hs build && ..
01:51:34 <jrockway> that is what you pass the cabal utility
01:51:46 <jrockway> i didn't know that was relayed to Setup.lhs verbatim though
01:51:57 <jrockway> abstraction++ # i have no idea how anything actually works
01:52:09 <shrughes> I don't know if i'm right -- the option might be different
01:52:13 <jrockway> --help to Setup.lhs is the first thing I'd do
01:52:14 <Veinor> no, that's not it
01:52:32 <Veinor> ah, it's back up!
01:52:39 <shrughes> :D
01:52:48 <Araneidae> So.  It looks as if the tar files are in ~/.cabal/packages/hackage.haskell.org , but presumably the sources were discarded after the failed build
01:53:05 <Veinor> bah, this machine doesn't have parsec installed either :/
01:53:07 <jrockway> looks like it's --prefix
01:53:08 <Veinor> wish I had admin rights *grumble*
01:53:17 <Araneidae> (No life over on #yi, for what it's worth)
01:53:35 <shrughes> This is the reason I've never installed Yi
01:53:37 <jrockway> (this is what a random "Setup.lhs configure --help" suggests, anyway)
01:53:43 <Araneidae> haskell.org is back!
01:53:46 <jrockway> weird, i have yi installed
01:54:00 <jrockway> i remember some issue, but obviously it was trivial to resolve
01:54:01 <shrughes> I always run into weird things with yi
01:54:20 <Araneidae> Looks like a conflict between Yi's own Prelude and the Data.Accessor.Private library
01:54:22 <shrughes> It helps that I like emacs already.
01:54:29 <Veinor> I think I'll try this on the machine I actually own.
01:56:15 <Araneidae> Hum.  I wonder: do I actually have the "Haskell Platform" installed?
01:56:26 <Araneidae> Looking over at http://hackage.haskell.org/platform/ I see this message:
01:56:41 <Araneidae> The following platforms provide some support for the Platform, but you're best using the source installer: Ubuntu
01:56:47 <Araneidae> Ho ho ho
01:57:17 <shrughes> ubuntu doesn't have the haskell-platform package (there is one on debian, right?  I have bad memory)
01:57:52 <Araneidae> Nope, no such package :(
01:57:59 * Araneidae is getting a bit tired of Ubuntu
01:58:20 <m3ga> there is a haskell-platform in debian-unstable
01:59:02 <shrughes> The packages are always way out of date on debian too, it's not like it's ubuntu's fault.  I'd just avoid the packaging system entirely for ghc
01:59:09 <Araneidae> Well, guess I'll back out all my Ubuntu packages except the core compiler and install the haskell-platform
01:59:28 <Araneidae> Yes.  Which is where I started ;)
01:59:28 <jrockway> i have developed haskell for years without "the platform"
01:59:43 <Araneidae> What *is* the "platform", anyway?
01:59:46 <shrughes> is "the platform" anything other than GHC + Cabal?  I suppose I could read the website...
01:59:47 <jrockway> i installed cabal-install myself and "paged in" libraries as needed
01:59:56 <jrockway> ghc + cabal-install + commonly-used libraries
02:00:01 <m3ga> what does 'let ?x = x' mean?
02:00:10 <jrockway> and the docs, according to debian :)
02:00:13 <Araneidae> Sounds useful.
02:00:16 <Veinor> kmc: I cabal installed it, but (.text+0x10eb): undefined reference to `__stginit_datazmmemocombinatorszm0zi3_DataziMemoCombinators_'
02:00:24 <kmc> dunno about that
02:00:33 <kmc> m3ga, ?x is an implicit parameter
02:00:35 <kmc> a little-used feature
02:01:05 <m3ga> kmc: thanks, now i can google 'implicit parameter'
02:01:43 <Veinor> I can load it fine in ghci, but I can't import it :/
02:01:55 <kmc> @google ghc implicit parameter
02:01:57 <lambdabot> http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/other-type-extensions.html
02:01:57 <lambdabot> Title: 7.8.�Other type system extensions
02:02:50 <Veinor> this is frustrating :<
02:03:05 <int-e> Veinor: typically that means you forgot --make (or -package <package>) or a dependency in a cabal file. the package is data-memocombinators here.
02:03:10 <kmc> Veinor, are you building with ghc --make?
02:03:18 <kmc> ghc --make -O3 -o myprog myprog.hs
02:03:45 <Veinor> ah.
02:03:53 <m3ga> shrughes: whats in debian unstable right now is pretty much right up-to-date
02:04:18 <Veinor> I need to lrn2ghc, that fixed it.
02:04:23 <shrughes> m3ga: okay, but I don't use unstable
02:04:59 <int-e> (Oh, actually forgetting a dependency in a cabal file fails during compilation already. That's the dreaded hidden exposed package problem :))
02:06:05 <m3ga> ubuntu karmic should also be pretty close to up-to-date
02:06:40 <Veinor> now I just need to know how to use memocombinators for 2-argument functions.
02:07:11 <kmc> memo2
02:07:33 <Veinor> fastMult = memo2 slowMult?
02:07:48 <Araneidae> m3ga, well I'm on Karmic, but I'm trying a complete binary local install now
02:07:50 <kmc> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html#v%3Amemo2
02:07:54 <Veinor> hm, that can't be right
02:08:04 <kmc> you've gotta pass in the "Memo a" values for each type
02:08:29 <Veinor> explain further?
02:08:41 <shrughes> memo2 :: Memo a -> Memo b -> (a -> b -> r) -> a -> b -> r
02:08:46 <shrughes> type Memo a = forall r. (a -> r) -> a -> r
02:09:24 <Veinor> hm.
02:11:28 <kmc> Veinor, maybe "memo2 integral integral"
02:11:44 <Veinor> which means I have to use my slowMult function take integers.
02:11:53 <kmc> what's it take now?
02:12:05 <kmc> nimbers?
02:12:08 <Veinor> well, right now it takes Nimbers, yeah
02:12:11 <kmc> but a nimber is just a wrapped integer, yes?
02:12:11 <jrockway> or you could define the relevant instance of Memo
02:12:21 <kmc> it's not even a matter of instances
02:12:29 <Veinor> kmc: yeah, true
02:12:56 <shrughes> :t Data.MemoCombinators.char
02:12:57 <lambdabot> forall r. (Char -> r) -> Char -> r
02:13:04 <Veinor> but it's newtyped is the thing.
02:13:14 <kmc> the simplest thing would be to use GeneralizedNewtypeDeriving to get Num and Integral
02:13:22 <kmc> maybe you don't want that
02:13:41 <Veinor> probably not.
02:13:46 <kmc> you need a type like:  forall r. (Nimber -> r) -> Nimber -> r
02:13:53 <Veinor> right.
02:14:05 <Veinor> which would be Memo Nimber
02:14:20 <Veinor> oh hey, wrap
02:14:33 <kmc> ah nice
02:15:02 <Veinor> memonimber = wrap fromNimber toNimber integral
02:15:57 <donri> aren't monoids just monadplus?
02:16:10 <kmc> a monoid is not necessarily a monad
02:16:15 <kmc> a monadplus is a monad which is also a monoid
02:16:26 <jrockway> data.memocombinators is a good example of why i have hope for haskell
02:16:30 <idnar> > ["foo", "bar"] `mplus` ["baz", "quux"]
02:16:32 <lambdabot>   ["foo","bar","baz","quux"]
02:16:34 <idnar> > ["foo", "bar"] `mappend` ["baz", "quux"]
02:16:36 <lambdabot>   ["foo","bar","baz","quux"]
02:16:38 <kmc> (more precisely: a monad "m" such that for any "a", "m a" is a monoid)
02:16:40 <jrockway> it is a library that you could write manually, but now don't have to
02:16:49 <shrughes> > ["foo, "bar"] <|> ["baz", "quux"]
02:16:49 <jrockway> and the library is better than what you would have to write manually
02:16:50 <lambdabot>   <no location info>:
02:16:50 <lambdabot>      lexical error in string/character literal at end o...
02:16:54 <idnar> but
02:16:55 <shrughes> oh nevermind
02:16:57 <Apocalisp> yea, every monad "m" is also a monoid
02:16:58 <kmc> jrockway, and it's one of the big promises of pure functions
02:17:00 <idnar> > (Just "foo") `mplus` (Just "baz")
02:17:01 <lambdabot>   Just "foo"
02:17:02 <kmc> that we have to be able to deliver on
02:17:03 <idnar> > (Just "foo") `mappend` (Just "baz")
02:17:05 <jrockway> exactly
02:17:05 <lambdabot>   Just "foobaz"
02:17:20 <kmc> just like parallel execution
02:17:25 <jrockway> yeah
02:17:28 <donri> kmc, ah, so i wasn't completely crazy when i saw a similarity? thanks :)
02:17:32 <jrockway> technically the compiler should be doing this :)
02:17:50 <kmc> there is a space/time tradeoff though
02:17:55 <kmc> annotations make sense
02:18:07 <kmc> (space is also time, via GC etc)
02:18:16 <jrockway> myapp +RTS --memoize -RTS ...
02:18:29 <kmc> hehe
02:18:37 <kmc> more like --memoize-max=50M
02:18:43 <da-xw> kmc: space is also time, via Einstein
02:18:50 <kmc> but it still has to be very smart to use that space usefully
02:18:55 <kmc> da-xw, space has a terrible power
02:18:58 <Veinor> it doesn't seem like it fixed the slowdown :(
02:18:59 <jrockway> yeah
02:19:08 <jrockway> some people at work really like memoizing stuff
02:19:09 <kmc> Veinor, are you sure you've switched to fastMult everywhere?
02:19:17 <jrockway> i removed the memoization and the app ran much faster :)
02:19:20 <kmc> haha
02:19:29 <shrughes> jrockway: when in doubt, add a cache.  no, don't bother checking if there already are caches
02:19:43 <jrockway> when you call the function with a different arg every time, you are just wasting space and time :)
02:19:53 <Veinor> ahhh
02:20:24 <jrockway> there were also memoized functions that just returned a value in a map
02:20:33 <kmc> haha
02:20:34 <jrockway> lookup_real_name('USD') # United States Dollar
02:20:35 <kmc> what language?
02:20:37 <jrockway> perl
02:20:44 <jrockway> memoizing that isn't going to speed anything up
02:20:48 <jrockway> the function is already memoized :)
02:20:52 <kmc> did you have some general memoizer or was it done by hand every time?
02:21:03 <Veinor> yeah, I forgot to swap the recursive definition to the memoizer
02:21:09 <jrockway> general memoizer
02:21:14 <jrockway> "Memoize.pm"
02:21:15 <shrughes> > fix ((1:) . scanl (+) 1)
02:21:16 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
02:21:23 <Veinor> it's a lot faster now.
02:21:36 <Veinor> it can still take a second or two for 20 * 20, though
02:21:55 <shrughes> > Data.MemoCombinators.integral (\f n => if n < 2 then n else f(n-1) + f(n-2))
02:21:56 <lambdabot>   <no location info>: parse error on input `=>'
02:22:03 <shrughes> > Data.MemoCombinators.integral (\f n -> if n < 2 then n else f(n-1) + f(n-2))
02:22:04 <lambdabot>   Not in scope: `Data.MemoCombinators.integral'
02:22:29 <shrughes> I like how Memo a is just a kind of fix
02:22:36 <cdiem> I have some very basic question (reading Real World Haskell)
02:22:43 <Veinor> then again, this might have something to do with the fact that I'm running it on a netbook.
02:22:44 <cdiem> why isn't the following valid? isPalindrome (x:xs) = x == (last xs) && isPalindrome (init xs)
02:23:22 <shrughes> > let isPalindrome (x:xs) = x == (last xs) && isPalindrome (init xs) in isPalindrome "aba"
02:23:23 <lambdabot>   * Exception: Prelude.last: empty list
02:23:44 <shrughes> > let isPalindrome (x:xs) = x == (last xs) && isPalindrome (init xs); isPalindrome "" = True in isPalindrome "aba"
02:23:44 <lambdabot>   * Exception: Prelude.last: empty list
02:23:50 <jrockway> you need a base case?
02:23:58 <shrughes> > let isPalindrome "" = True; isPalindrome (x:xs) = x == (last xs) && isPalindrome (init xs); isPalindrome "" = True in isPalindrome "aba"
02:23:59 <lambdabot>   * Exception: Prelude.last: empty list
02:24:08 <shrughes> > let isPalindrome "" = True; isPalindrome (x:xs) = x == (last xs) && isPalindrome (init xs) in isPalindrome "aba"
02:24:08 <lambdabot>   * Exception: Prelude.last: empty list
02:24:15 <Veinor> haha
02:24:18 <cdiem> i mean, it gives me things like it cannot construct infinite type a = [a]
02:24:28 <shrughes> oh gawd
02:24:30 <shrughes> i hate me
02:24:53 <jrockway> yeah, you can't construct infinite types like a = [a]
02:24:57 <jrockway> ;)
02:25:09 <Veinor> shrughes: you need isPalindrome [x] = True as well :P
02:25:11 <shrughes> cdiem: that line's invalid because it's wrong -- but it's not the line giving you an infinite type
02:25:47 <cdiem> so the whole definition of the function seems wrong :)
02:25:50 <shrughes> cdiem: never mind, i was basing my "it's wrong" on my misreading of what xs was
02:25:56 <jrockway> i am amazed at how many stackoverflow questions there are where ghc's error message is exactly the problem
02:26:41 <jrockway> "when i write []&#$[HJLKDSHFKD[*#&$#, ghci says it's a syntax error" "uh yeah, that's because it's a syntax error" "oh."
02:26:49 <shrughes> > let isPalindrome "" = True; isPalindrome [_] = True; (x:xs) = x == (last xs) && isPalindrome (init xs) in isPalindrome "aba"
02:26:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
02:26:50 <lambdabot>         against inferred ty...
02:27:02 <Araneidae> Wow: building haskell-platform produces *hundreds* of warnings!
02:27:26 <shrughes> > let isPalindrome "" = True; isPalindrome [_] = True; isPalindrome (x:xs) = x == (last xs) && isPalindrome (init xs) in isPalindrome "aba"
02:27:26 <lambdabot>   True
02:27:47 <shrughes> there we go -- there's no infinite type there, paste your full code then
02:27:56 <Jafet> Lol.
02:28:01 <cdiem> well, this was my full code ;]
02:28:01 <sinelaw> shrughes, what's that [_] syntax?
02:28:04 <Jafet> isPalindrome x = x == reverse x
02:28:11 <Veinor> sinelaw: a list containing a single element
02:28:13 <shrughes> sinelaw: just a single-element list with a wildcard
02:28:15 <cdiem> it's an exercise in the book i was trying to solve :)
02:28:20 <jrockway> Jafet: heh, i was just typing that :)
02:28:21 <sinelaw> ok
02:28:42 <shrughes> Jafet: no that's too efficient
02:28:56 <Araneidae> GRRRRR
02:29:00 <Araneidae> configure: error: editline not found, so this package cannot be built
02:29:00 <cdiem> so basically i have missed some of the function declarations for empty list - thanks a lot
02:29:11 <Araneidae> What the bloody hell!  Can't anybody package stuff?!
02:29:34 <Apocalisp> palindrome = (==) =<< reverse
02:30:09 <sinelaw> Jafet, is your solution less efficient or something?
02:30:18 <shrughes> his is more efficient
02:30:19 <cdiem> thanks Apocalisp, though I'm not that good yet to ;]
02:30:23 <Araneidae> What *is* editline, and how do I install it?  All I have right now is a binary ghc install, and a haskell-platform that won't build (despite a successful ./configure)
02:30:24 <Apocalisp> > (palindrome = (==) =<< reverse) "radar"
02:30:26 <lambdabot>   <no location info>: parse error on input `='
02:30:27 <jrockway> Araneidae: the solution is to use debian
02:30:35 <shrughes> the original solution was O(n^2)
02:30:39 <Apocalisp> > let palindrome = (==) =<< reverse in palindrome "radar"
02:30:39 <jrockway> debian focuses on working
02:30:40 <lambdabot>   True
02:30:46 <Araneidae> jrockway, that may well be true, but not particularly  helpful.
02:30:52 <Apocalisp> > let palindrome = (==) =<< reverse in palindrome "rad"
02:30:54 <lambdabot>   False
02:30:55 <jrockway> ubuntu focuses on making an annoying noise when you log in
02:30:57 <Apocalisp> she works!
02:31:01 <cdiem> :)
02:31:01 <Araneidae> In particular at the moment I should be fairly platform independent
02:31:08 <jrockway> there is also an "ubuntu cola"
02:31:12 <Araneidae> jrockway, what you say is true
02:31:15 <maartenm> for some reason my cat is much more curious when I wrote haskell or erlang than in other languages
02:31:16 <Araneidae> Sigh
02:31:20 <shrughes> jrockway: yeah well ubuntu got wireless working out of the box, debian didn't
02:31:34 <jrockway> debian doesn't come in a box...
02:31:36 <Araneidae> However, I have done the followoing steps which surely should work:
02:31:59 <jrockway> there are tradeoffs
02:32:14 <jrockway> i have to know that wicd handles the wireless connection, and then i have to "apt-get install wicd"
02:32:18 <Araneidae> 1. Install GHC 6.10.4 using `./configure --prefix=/my/local/prefix`
02:32:30 <Veinor> I like how all this work I went through is basically pointless since there's a closed-form-y solution to nim multiplication
02:32:32 <Araneidae> 2. Install haskell-platform ditto
02:32:34 <jrockway> but, instead of having to compile haskell manually, i can just "apt-get install haskell-platform"
02:32:48 <jrockway> debian requires more thinking, but less tedium
02:32:48 <shrughes> jrockway: that would be nice, except that I can't apt-get install anything without the wireless connection
02:32:51 <Araneidae> Seems to me that any failures are down to crappy packaging in haskell-platform, no?
02:32:54 <shrughes> or couldn't
02:33:15 <shrughes> that's what pulled me off debian -- for now
02:33:23 <jrockway> next time, buy intel hardware :)
02:33:26 <Araneidae> jrockway, I don't currently have debian installed on this box, so saying Debian is better, although true, is beside the point!
02:33:33 <jrockway> that always works out of the box in debian :)
02:33:35 <shrughes> jrockway: I think my wifi is already some intel thing
02:33:36 <jrockway> yeah, i know
02:33:45 <jrockway> strange that it doesn't work then
02:33:49 <jrockway> but whatever
02:33:53 <Araneidae> Anyhow, anybody know what editline is and how I should install it?
02:34:29 <shrughes> maybe apt-get install libeditline-dev
02:35:03 <Araneidae> shrughes, but that's a package with *package* ghc dependency
02:35:29 <Araneidae> I'm trying to do a *binary* install of ghc (having hit snags with the package install)
02:35:42 <jrockway> omit the -dev then
02:35:55 <shrughes> Araneidae: what?  libeditline-dev requires ghc?
02:36:11 <Araneidae> sorry, I misunderstood.  There is no libeditline
02:36:21 <Araneidae> Oh
02:36:35 <Araneidae> I'm totally wrong.  Misunderstanding how synaptic search works
02:36:38 * Araneidae blushes
02:36:51 <Araneidae> bah
02:37:12 <Araneidae> Still, I do blame haskell-platform ./configure, guess I need to raise a bug report
02:37:34 <jrockway> is there a reason why you can't apt-get install ghc6, libghc6-http (etc.) and then install cabal-install, and bootstrap from there?
02:37:46 <PeakerWork> maybe instance declarations should have a "priority" on them to resolve conflicts.  Same priority conflict would lead to error.  Then orphan instances of priority!=0 should not get a warning
02:37:48 <jrockway> seems like you are going pretty far into the weeds, simply because you think you need "the platform"
02:38:05 <Araneidae> jrockway, well you could be right
02:38:06 <PeakerWork> And instances next to the type or class should always have priority 0 (or warning). And you can safely add missing instances as orphans
02:38:26 <Araneidae> However, I think shrughes might have fixed that problem (and there *is* a configure bug there), so onward ...
02:38:32 <PeakerWork> You could still get a warning about resolved instance conflicts, so you know to get rid of your instances, but it would still build
02:38:55 <PeakerWork> (Some instances are really natural, and there isn't much choice in the matter)
02:39:52 <Araneidae> Huh.
02:40:14 <Araneidae> Still failed, with the same error.  And I now have libeditline-dev installed
02:40:27 <Araneidae> Surely I don't need to reinstall ghc?
02:42:38 <Araneidae> Now that's very odd.  libeditline-dev only installs /usr/include/editline.h, whereas haskell-package `make` is checking for editline/readline.h
02:43:36 <Veinor> I wonder how you can memoize functions that take more complicated arguments than what MemoCombinators provides you
02:43:41 <Veinor> wrap is key, I'm guessing.
02:45:41 <jrockway> well, it's trivial to memoize any arguments that do Eq
02:45:51 <jrockway> i think the complexity that you see is to make it efficient
02:46:10 <jrockway> (there is no point in memoizing if you are just going to iterate over an association list)
02:46:58 <shrughes> well it would be an improvement if you were doing something like (fix $ \f -> Memo.integral $ \n -> if n < 2 then n else f(n-2) + f(n-1))
02:47:27 <jrockway> yeah
02:47:41 <jrockway> i really enjoy waiting 10 seconds to calculate the 10th Fibonacci number ;)
02:47:57 <shrughes> what
02:47:59 <Araneidae> Sigh.  The editline was first reported missing from ./configure in March!
02:48:26 <jrockway> ("anything is an improvement over the default unmemoized recursive implementation")
02:49:06 <jrockway> Araneidae: clearly you should threaten to switch to OCaml if they don't fix it immediately
02:49:18 <jrockway> perl people love to threaten to switch to ruby if <some condition>
02:49:29 <Veinor> bah, it's still O((ab)^2) in the values of its arguments
02:49:29 <Araneidae> Huh.
02:49:35 <Araneidae> I'm trying to switch *to* Haskell!
02:49:50 * Araneidae does all his work in sh + Python + C
02:49:54 <shrughes> i guess you'll have to switch to O'Caml then
02:50:03 <jrockway> yeah
02:50:13 <jrockway> the grass is always greener on the other side
02:50:27 <Araneidae> Did I say anything about switching?
02:50:41 <jrockway> no, it's a joke :)
02:50:49 <Araneidae> 'k
02:51:00 <kynky> this early in the mornin? :)
02:51:02 <Araneidae> Ach.  I should be outside sweeping up leaves, actually.
02:51:10 <jrockway> bah
02:51:17 <jrockway> leaves decompose by themselves!
02:51:19 <Araneidae> Nice day today after yesterday's filthy weather
02:51:32 <Araneidae> Not beech leaves, alas
02:51:42 <Araneidae> They stay nice and papery all year :(
02:52:53 <PeakerWork> Araneidae: why are you building stuff yourself? :)
02:53:00 <PeakerWork> (other than "cabal" that is)
02:53:14 <jrockway> his distro does not have the packages he wants, apparently
02:53:44 <jrockway> personally, i would just install my OS's ghc package, get cabal-install working, and then go from there
02:54:43 <Araneidae> Well, I thought I'd tryin installing haskell-platform, basically
02:54:57 <Araneidae> Seemed like a sensible idea, and it's not in Ubuntu.
02:55:01 <PeakerWork> Araneidae: I generally install ghc's binary, bootstrap cabal-install, and then cabal install stuff
02:55:07 <Araneidae> However, it's looking like not such a smart idea after all.
02:55:29 <Veinor> bah, apparently the slowness is due to haskell; python computes it in like 7 times the speed :/
02:55:31 <Araneidae> Yes, I think I'll go back to that ... but I thought that haskell-platform was the way to go?
02:55:34 <Araneidae> Is it not?
02:55:38 <jrockway> it is
02:55:41 <jrockway> but apparently it's not working
02:55:49 <Araneidae> Just so :)
02:55:50 <jrockway> so practice beats theory, and you should try something else
02:56:02 <Araneidae> Oh, I'm not quite defeated just yet
02:56:06 <jrockway> in theory though, the haskell-platform would just pop into existence
02:56:12 <Araneidae> In particular two bugs are in front of me:
02:56:15 <jrockway> and everything would be sunshine and butterflies
02:56:33 <Araneidae> 1. ./configure doesn't even notice whether editline is installed
02:56:59 <Araneidae> 2. Somebody (not sure who yet) is looking in the wrong(?) place for the header file.
02:57:15 <Araneidae> The latter is interesting, but suggestive of wriggly worms
02:57:27 <kynky> arch and gentoo have great haskell support, thougt debian had ok support and so ubuntu would ?
02:58:08 <Araneidae> Yeah, thought Ubuntu would be a bit more seamless.  But it's a bit too bleeding edge, and as jrockway said earlier, concentrates more on being shiny
02:58:25 <Veinor> I wish haskell was faster.
02:58:27 <Araneidae> Anyhow, later.  The leaves are calling
02:59:16 <jrockway> kill them with fire
02:59:30 <Araneidae> It was pissing it down yesterday, so that'll be tricky
03:00:03 <shrughes> get a big fan
03:00:12 <jrockway> i wish i had leaves, if only so i could tell them to die in a fire, and then kill them in a fire
03:00:15 <shrughes> and blow them off your property before they ever hit the ground
03:00:19 <jrockway> it would be like reddit in real life
03:00:20 <ehamberg> his neighbours will love him :)
03:00:31 <jrockway> i like shrughes' idea
03:00:39 <Araneidae> Suspect they do already: think most of them blew away in yesterday's gales
03:01:36 <jrockway> i am trying to imagine what time zone it is appropriate to rake leaves in
03:01:42 <jrockway> (as it is 5am here)
03:02:14 <shrughes> europe?
03:02:19 <jrockway> yeah
03:02:30 <jrockway> but then i think of europe as being all cities
03:02:37 <jrockway> meaning there are no yards for the leaves to fall in
03:02:54 <jrockway> not saying it's impossible, just that i don't have a mental picture :)
03:03:05 <shrughes> weird, i view europe as all rural. too many WW II movies
03:03:26 <jrockway> haha
03:05:23 <Veinor> ahhh, I figured out why python's faster
03:05:29 <Veinor> it's purity coming back to bite me in the ass.
03:05:41 <Veinor> python can keep memoziation across calls of the function, whereas haskell can't.
03:06:07 <jrockway> "state monad"
03:06:17 <Veinor> true
03:06:25 <shrughes> What?  I'm pretty sure Haskell can
03:07:00 <Veinor> maybe I'm thinking about it the wrong way, then.
03:07:08 <shrughes> fib = Memo.integral fib' where fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2)
03:07:10 <shrughes> for example
03:07:12 <Veinor> hm
03:07:30 <Veinor> the point is that in python, after I call f(40,40), say, f(20,20) is already there and computed
03:07:52 <Veinor> or maybe this is an artifact of ghci
03:09:09 <Veinor> no, 20 !* 20 - 20 !* 20 is definitely slower
03:09:26 <shrughes> could you paste a full code example then
03:09:45 <Veinor> of the haskell code?
03:09:53 <shrughes> yes
03:10:54 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12168#a12168
03:10:57 <dibblego> Veinor, Haskell *shouldn't* (and neither should Python -- and doesn't for the given code)
03:11:26 <Veinor> dibblego: right, python doesn't usually, but it does if you use memoization.
03:11:28 <dibblego> Veinor, assign a !* b using let
03:11:32 <phr> @pl \x->return ()
03:11:33 <lambdabot> const (return ())
03:11:41 <Veinor> dibblego: ?
03:11:41 <dibblego> er a !* b'
03:11:48 <Veinor> explain?
03:11:59 <dibblego> let z = a !* b' in ...
03:12:01 <dibblego> gotta run
03:12:02 <nomeata> Igloo: Hi Ian. I discovered your mime-string library on hackage, and it’s great; I’m using it now to parse incoming mail on darcswatch. But it seems I can only use it to parse mails, not to generate mails, right?
03:12:15 <nomeata> Igloo: I could not find a Message -> String function.
03:12:37 <Igloo> Isn't there some sort of flatten functino that does that?
03:13:40 <shrughes> i don't know what dibblego is talking abotu
03:13:48 <Igloo> nomeata: Codec.MIME.String.Flatten.flatten I think?
03:13:56 <nomeata> Igloo: there is, but it does not work on the Message type, so I was confused
03:14:04 <nomeata> Igloo: Is that what I should use to generate mails?
03:14:04 <int-e> what does the show instance do?
03:14:16 <Igloo> Oh, I see. I'm not sure OTTOMH, I haven't looked at the code in years
03:14:20 <int-e> nm
03:14:59 <hoelk> Is anyone here bored and wants to help a total programming newbie with some easy task? i want to read a list of books from a file (format: bookid(integer), title (string), authors [list of strings] , sort them by id, and write them to another textfile... its just a simple tutorial exercise i want to do and i cant really figure out how to do it
03:16:33 <nomeata> Igloo: also, is there a reason why it’s in the IO monad?
03:16:35 <ehamberg> i you figure out how to read in the file, you can use 'lines' to get a list of lines and then write a function that takes a line and return a record, or something.
03:16:41 <ehamberg> (for hoelk)
03:16:57 <Igloo> nomeata: Again, no idea OTTOMH, sorry
03:17:08 <hoelk> hm
03:17:25 <nomeata> Igloo: ok, thanks nevertheless, I think I can make use of it.
03:18:55 <hoelk> ehamberg: hmm il try that
03:19:09 <int-e> nomeata: there's a comment in the source code of flatten alluding to generating message ids if missing. that'd probably involve IO
03:19:15 <ehamberg> hoelk: good luck. :)
03:21:40 <PeakerWork> hoelk: can you show how an example line would look like?
03:22:09 <PeakerWork> hoelk: Do you understand what this means:  map parseLine (lines (readFile "your filename"))       ?
03:22:36 <hoelk> 1 "Foos Bar" "Alan Smithee" (its probaly easier right now just doing one author instead of list of authors)
03:23:09 <hoelk> i dont understand anything actually ;) i have no real clue yet about haskell or more like programming in general probably
03:23:28 <hoelk> just working myself trough a tutorial and trying to adapt it for an exercise i have to do for uni
03:23:33 <PeakerWork> hoelk: There's the "reads" function
03:23:42 <shrughes> Veinor: it memoizes fine for me
03:23:52 <PeakerWork> > reads "\"hello world\" blah blah" :: [(String, String)]
03:23:53 <lambdabot>   [("hello world"," blah blah")]
03:24:02 <PeakerWork> @type reads
03:24:04 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:24:14 <ehamberg> and, simply
03:24:15 <ehamberg> > read "[\"foo\", \"bar\"]" :: [String]
03:24:16 <lambdabot>   ["foo","bar"]
03:24:18 <hoelk> i was doing something with hGetLine
03:24:25 <PeakerWork> ehamberg: need reads if you want to parse the end
03:24:49 <PeakerWork> @type readFile
03:24:50 <lambdabot> FilePath -> IO String
03:25:01 <PeakerWork> hoelk: readFile returns an action that yields the contents of the file name you give it
03:25:13 <hoelk> ah hm
03:25:21 <PeakerWork> hoelk: so you can use it in your main do block:  main = do { data <- readFile "your filename" ; ... you can use data here ... }
03:25:48 <PeakerWork> hoelk: but lets ignore the file reading and writing -- those parts are I/O (input/output). Lets focus on the data processing part (which is a pure mathematical function)
03:26:07 <PeakerWork> hoelk: Lets assume you have a big String for the input file, and you want to generate a big String for the output file, so far so good?
03:26:24 <hoelk> well i have a working quicksort thing somewhere
03:26:42 <PeakerWork> hoelk: Lets start with the parsing part. You know what parsing means?
03:26:43 <hoelk> i wanted to combine that with acessing data from a file
03:27:04 <hoelk> i would expect parsing = getting stuff out of somewhere line for line or so?
03:27:06 <PeakerWork> hoelk: Once you "convert" your file to a big input String, you don't need to think about the fact its "from a file" anymore
03:27:31 <PeakerWork> hoelk: parsing means converting input data (typically strings) into a different form, that is more useful to what you want to do
03:27:49 <hoelk> yeah thats what i want to
03:27:50 <hoelk> do
03:28:08 <PeakerWork> hoelk: the function "reads" can parse strings into any type using that type's "standard parser".  The standard parser for Haskell Strings does all the tracking of " for you
03:28:25 <PeakerWork> hoelk: But lets define an auxiliary function that wraps "reads" with a simpler interface
03:28:30 <Jafet> Hmm, are there Haskell texts written towards people with little programming experience?
03:28:31 <hoelk> hm
03:28:37 <Jafet1> preflex: seen jafet
03:28:37 <preflex>  jafet was last seen on #haskell 6 seconds ago, saying: Hmm, are there Haskell texts written towards people with little programming experience?
03:28:51 <PeakerWork> @let readM = listToMaybe . reads
03:28:52 <lambdabot>  Defined.
03:28:56 <PeakerWork> @type readM
03:28:57 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
03:29:08 <hoelk> Jafet: im working myself trough "Real world Haskell" right now
03:29:11 <Jafet1> Heh
03:29:17 <PeakerWork> hoelk: readM is now defined as:  Apply the function "reads", and then "listToMaybe"
03:29:23 <hoelk> Jafet, freely available on the net
03:29:57 <PeakerWork> hoelk: come to #haskell-overflow
03:30:19 <Jafet> The problem with starting with languages like haskell is that you probably end up disliking most other languages that are widely used
03:30:40 <PeakerWork> heh
03:30:41 <shrughes> The problem with starting with other languages is that you end up liking them.
03:30:57 <Jafet> I started with C++ and never really liked it
03:31:03 <donri> haskell is said to be difficult to learn. i think if it's the first language you learn all the others are gonna be very effin scary.
03:32:09 <donri> s/all/at least those not purely functional/
03:32:33 <donri> (and the functional ones are gonna seem like lesser haskells ;))
03:32:53 <Jafet> Lisps do not seem like lesser Haskells!
03:33:16 <donri> are lisps pure?
03:33:19 <shrughes> Lisps aren't functional
03:33:27 <Jafet> Joy perhaps, but if you think that Joy is like Haskell that says something unpleasant about how you write Haskell code
03:34:01 <Jafet> Some lisps are.
03:34:04 <mmmdonuts> Scheme can be about as functional as ML.
03:34:06 <shrughes> ok I'm trolling a bit..
03:34:40 <mmmdonuts> Other Lisps, not so much.
03:37:00 <Jafet> APL is also quite pure.
03:37:29 <Jafet> I'm not sure about Prolog, but it's pure in my imagination
03:39:11 <donri> but these are not lisps though?
03:39:27 <Jedai> @hoogle stripPrefix
03:39:27 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
03:39:57 <Jafet> No, they aren't.
03:42:03 <dolio> I'm no prolog expert, but I've heard it's not particularly pure.
03:42:40 <dolio> Mercury would probably be a better candidate. It uses uniqueness types for handling IO, for instance.
03:43:19 <mathijs> Hi all, sorry if this sounds very vague, but I'm looking for a way to do a map-reduce like thing in haskell. Let's say I have an "object" that gets modified by user input. The current state of the object is the sum of all modifications. The modifications are kept in memory in a list. at any time, users can ask for the current object state or the list of modifications.
03:44:37 <Jafet> You want to implement undo?
03:45:25 <mathijs> I can probably define the "object" as a foldr on the list of modifications, but I don't want to recalculate everything every time a modification gets added. So I need a way to cache the current state and just apply the new modification on top of that.
03:45:27 <Kim^Walkman> Sounds like a general fold of the modifications on the object to me :x
03:45:38 <Kim^Walkman> Ah.
03:46:03 <mathijs> Jafet: no, just history for now. Undo can be applied on top of that in the future
03:46:15 <Jafet> Why not represent it as a pair of the current state and the history
03:46:38 <Jafet> That is, the obvious way
03:48:35 <ben> What if the history is not linear
03:48:55 <ben> What if there are multiple actors doing stuff and they need to undo stuff separately
03:49:05 <ben> ideally considering latency between everybody
03:49:12 <Jafet> Then you'd need concurrent primitives regardless of how you do it
03:49:16 <Jafet> Exercise for the reader.
03:49:24 <Taejo> ben: in that case I'd talk to #darcs :)
03:49:35 <mathijs> ben: well that's not the case right now, but I'm looking at operational transform for that
03:49:42 <ben> mathijs: :D
03:50:17 <shrughes> so, as Jafet said, why not represent it as a pair of the current state and the history?
03:51:06 <mathijs> Jafet: it's an option. I just would like to hide it all away from sight. I can try to make a monad to do that, but I'm looking for something in which I define the "object" once as being the fold on all (future available) modifications, and just be able to ask for the current state when I need it.
03:51:49 <sinelaw> sounds like a Monoid, btw
03:52:02 <shrughes> why don't you make it an abstract datatype then?
03:52:53 <Jafet> So define the object as being the fold on the history
03:52:58 <mathijs> sinelaw: it is. Just looking for a way to have it available incrementally while it's defined on a list of future modifications.
03:53:07 <Jafet> I doubt that's very extensible, though
03:53:50 <mathijs> Jafet: in that case I can't add new modifications to the list without recalculating every step.
03:54:02 <Jafet> Why not?
03:54:10 <shrughes> mathijs: you're adding modifications to the middle of the list?
03:54:43 <Jafet> The history is a stream of modifications, and the current state is a fold on a prefix of the history
03:55:11 <mathijs> nope, just to the end
03:55:57 <shrughes> so when you add a new modification, you can update the current state
03:56:07 <mathijs> Jafet: that's true. but if a modification gets added later, and I ask for the current state again, how do I prevent the system from looking through the full history again?
03:56:35 <shrughes> data Thing = Thing CurrentState [Modification]
03:56:43 <mathijs> shrughes: then I explicitly have to mappend it every time. I would like to abstract that.
03:57:12 <Jafet> Memoize the fold?
03:57:23 <idnar> Writer monad?
03:57:27 <shrughes> addModification :: Thing -> Modification -> Thing ; addModification (Thing s ms) m = Thing (applyModification s m) (m : ms)
03:57:33 <mathijs> you see, [Modification] is fed by IO events (user input)
03:58:13 <shrughes> huh, [Modification] is the history, not the future
04:00:14 <mathijs> [Modification] = parse modifications $ getContents
04:00:32 <shrughes> oh god
04:00:34 <shrughes> getContents
04:00:40 <Twey> =<<
04:00:52 <Twey> getContents is fine for simple cases
04:00:53 <mathijs> remember... this is just a thought :P  didn't write anything yet
04:01:03 <Twey> (and lazy IO in general)
04:01:18 <mathijs> I understand. the real implementation will be driven by Chan i think
04:01:27 <Twey> It's only when you start getting complicated that it becomes a problem.  For simple things, it's convenient and efficient.
04:01:39 <shrughes> so what is the problem here
04:01:43 <Twey> (well… more efficient than strictly loading everything)
04:01:46 <shrughes> you can addModification all your modifications
04:01:56 <Twey> But mathijs, remember that getContents is a monadic action, not a function
04:01:56 <mathijs> but I would like to do lazy IO indeed, thus defining what the [Modification] _is_ rather than describing how to feed it and update stuff accordingly
04:02:25 <Twey> So you need to use either fmap (if ‘parse’ is pure) or =<< (if ‘parse’ is also an action in IO)
04:02:41 <Twey> mathijs: Have you looked at Iterator?  I believe it's meant to supplant lazy IO.
04:02:51 <mathijs> Twey: I understand... but I want to get the "stream" out in IO, and bind it to the modifications list.
04:02:56 <shrughes> mathijs: i'm not really sure what you're asking
04:04:15 <shrughes> given a list [Modification]... you can create the object formed from all the modifications
04:04:32 <mathijs> I'm asking for a monoid / foldr on an infinite list, and a way to "peek" at the current result (from a different thread) while it's waiting for the next list element.
04:04:41 <shrughes> you can't do the interactive thing where the user asks for the latest modification if you're taking the [Modification] from getContents
04:04:47 <mathijs> I will look at Iterator
04:05:16 <shrughes> maybe you want mapAccumL
04:05:44 <shrughes> or just scanl..
04:06:02 <shrughes> if you don't want some user-interactive thing
04:06:56 <shrughes> you can't look at a [] from a different thread and see how far it's evaluated though.  Not unless you spawn a thread that tries reading one value and then use another thread to see if it times out...
04:07:06 <Twey> mathijs: Sorry, Iteratee
04:07:09 <Twey> http://okmij.org/ftp/Streams.html
04:07:26 <shrughes> basically you'll have to code it yourself
04:07:58 <mathijs> shrughes: well I can think of some ways to get it done, as long as my modification list is finite. What I'm really just after is a way to make it infinite but be able to look at the result inbetween. Just because I would like a more functional definition of it all (FRP-like)
04:08:24 <shrughes> if you want to generate a list of inbetween results, you can use scanl or mapAccumL
04:09:24 <shrughes> iteratee would be complete overkill if it were useful
04:10:06 <Mugur> hello, everyone. I am new to Haskell and I try some GUIs. I had the idea of using both Graphics.UI.Gtk and Graphics.UI.WX to see what happens. So I have a window created with GTK and when I close it I want to open a wx-window. But I get ambiguous occurrence errors when trying to compile such a thing
04:10:40 <mathijs> shrughes: hmmm... that sounds quite good actually. but since I then get an infinite list, I need a way to look at the last/current element, but you mentioned that's possible from another thread.
04:11:09 <Jafet> Or you can use a view
04:11:14 <Mugur> for example, frame is ambiguous because it might be from both packages
04:11:26 <Twey> Mugur: Sounds like the two packages each export a function with the same name.
04:11:36 <shrughes> mathijs: no i said it's impossible unless you're crazy and go for timing-based attacks
04:11:36 <mathijs> Maybe I should just go for the safest solution (addModification) and don't polute the system with lazy IO :)
04:11:37 <Twey> Mugur: Use qualified imports.
04:11:41 <Jafet> Mugur, import qualified
04:11:51 <mathijs> shrughes: sorry, misunderstood that part :)
04:11:51 * Jafet now types with both hands
04:12:25 <Jafet> What's dirty about lazy IO?
04:13:18 <sinelaw> What's lazy about dirty IO?
04:13:23 <shrughes> mathijs: well, actually, you can just read through the list of modifications in a thread and assign them to an MVar or an IORef, and that var will contain the latest value in the list
04:13:27 <shrughes> so you can do it
04:13:33 <int-e> Jafet: readFile "foo" >>= writeFile "foo"  fails, for examlpe
04:13:40 <shrughes> Jafet: it performs IO in pure functions
04:14:12 <Jafet> shrughes, oh, didn't know you could do that
04:14:13 <int-e> Jafet: and the story for closing the files is quite complicated (so you may run out of FDs easily)
04:14:14 <Mugur> thank you
04:14:14 <mathijs> Jafet: hrm... I guess nothing, it's just how you use it. My thought on using it was a bit too much involved.
04:14:47 <mathijs> shrughes: sounds like a better solution indeed.
04:14:48 <Araneidae> jrockway, europe is quite a mix of cities and countryside, but mostly suburban = lots of houses *and* trees!
04:15:02 <shrughes> mathijs: just take your list of whatever Foo you're interested in and do forM_ thatList $ \x -> do atomicWriteIORef someref x  with it
04:15:15 <shrughes> do that in some thread and then that IORef will contain the "current" value
04:15:18 <shrughes> so not all hope is lost
04:15:23 <shrughes> yeha
04:15:50 <ivanm> preflex: seen malcolmw
04:15:51 <preflex>  malcolmw was last seen on #ghc 17 days, 19 hours, 49 minutes and 9 seconds ago, saying: Igloo: great, I think at least one sponsor will appreciate the opportunity to put some more money in.
04:15:53 <mathijs> shrughes: I know about MVars, don't know about IORefs though. What's the diff?
04:16:43 <shrughes> an IORef is never 'empty' and doesn't block and if two threads try to write to it... i suppose one will win
04:17:17 <Jafet> Sounds exciting
04:17:23 <shrughes> wtf is atomicWriteIORef, i must be smoking crack
04:17:38 <shrughes> an IORef is just a cell that can be modified
04:17:43 <shrughes> the plainest one there is
04:17:57 <int-e> do you mean atomicModifyIORef ?
04:18:15 <shrughes> no I just meant writeIORef
04:18:35 <int-e> oh. yes it'll be atomic.
04:18:50 <mathijs> shrughes: ok, get it. That's the one I need in this case if I don't want blocking.
04:18:50 <shrughes> will writeIORef in one thread and readIORef in another be safe?
04:18:57 <int-e> shrughes: yes
04:18:59 <shrughes> ok
04:23:37 <sinelaw> The opposite of Haskell: weakly typed, referentially opaque, strict, filthy and dysfunctional
04:23:52 <shrughes> and dynamically typed
04:24:15 <shrughes> with ugly syntax
04:24:15 <mathijs> and patented? :P
04:24:21 <shrughes> and no module system
04:24:50 <Twey> What's that, Perl?
04:24:50 <sinelaw> i challenge you to implement it
04:24:52 <shrughes> and intuitive numeric types
04:25:05 <Twey> Or COBOL?
04:25:08 <ben> sinelaw: C++ beat you to it
04:25:09 <sinelaw> Twey, heh, almost perl
04:25:19 <Twey> Hehe
04:25:49 <Axman6> shrughes: define 'safe'?
04:26:12 <shrughes> Axman6: that it won't partly read a value as it's updated
04:26:27 <shrughes> like half of a 64-bit field
04:26:29 <Axman6> hmm, i didn't know IORefs had any such guarantees
04:26:39 <Twey> Nor did I
04:26:43 <Axman6> though it's probably just a pointer
04:26:49 <int-e> Axman6: exactly
04:26:52 <shrughes> i would expect the thing overwritten to be the word size, yeah,
04:26:57 <Axman6> so it should be basically atomic
04:27:34 <shrughes> the fact that atomicModifyIORef exists at all implies some kind of facility for this purpose
04:27:43 <int-e> Axman6: this is also why atomicModifyIORef works - what it does is build a thunk and replace the pointer in the IORef to point to that thunk. (In a small loop, using CAS)
04:28:54 <SubStack> > zip <*> tail $ "abc"
04:28:55 <lambdabot>   [('a','b'),('b','c')]
04:29:00 <SubStack> applicative is so beautiful
04:29:24 <shrughes> yeah well so is duff's device
04:29:31 <mmmdonuts> shrughes, the main reason for atomicModifyIORef is that it makes reading the value and updating it atomic.
04:29:43 <shrughes> mmmdonuts: indeed
04:31:08 <Jafet> Duff's device is a beautiful hack.
04:31:28 <shrughes> zip <*> tail is a disgusting compression
04:31:57 <PeakerWork> shrughes: "disgusting" is a bit over-the-edge :)
04:32:10 <PeakerWork> shrughes: Once you get used to the short-cuts, they become readable
04:33:14 <shrughes> that's a tautology
04:33:38 <mmmdonuts> shrughes: my point was that just writing a value alone with writeIORef is atomic - but that requires that you know what you want to write and don't care if the ioref was updated since you last read it.
04:33:53 <shrughes> mmmdonuts: yes I know
04:33:58 <int-e> > ap zip tail "abc"
04:34:00 <lambdabot>   [('a','b'),('b','c')]
04:34:17 <shrughes> mmmdonuts: the question was of writing in one thread and reading in another
04:35:13 <mmmdonuts> The same applies.  Problems arise when you need multiple successive operations in a single thread to be atomic.
04:35:15 <shrughes> which would have been the wrong thing anyway
04:35:31 <shrughes> no it doesn't
04:36:02 <Twey> > zipWith (+) <*> tail $ [1 ..]
04:36:04 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
04:36:17 <Twey> > zipWith (+) <*> tail $ 0 : 1 : [1 ..]
04:36:19 <lambdabot>   [1,2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51...
04:36:28 <mmmdonuts> shrughes: doesn't how?
04:36:38 <Araneidae> Just stumbled across a file (something.hsc) which #includes C headers before defining a module!  Is this how C bindings are done?  Never seen that before...
04:37:00 <shrughes> mmmdonuts: never mind, what do you mean by "the same"
04:37:03 <Twey> > 0 : 1 : (zipWith (+) <*> tail [1 ..])
04:37:04 <lambdabot>   Couldn't match expected type `[a -> t]'
04:37:05 <lambdabot>         against inferred type `[a1]...
04:37:12 <Twey> Bah, humbug
04:37:31 <Jedai> > let fibs = fix ((1:) . (1:) . ap (zipWith (+)) tail) in take 10 fibs
04:37:32 <mmmdonuts> shrughes, readIORef and writeIORef are safe in the sense that you don't have to do anything to prevent partial values from being written or read.
04:37:33 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
04:37:34 <danderson> what does the unsafe* convention in function names actually mean? I'm looking at the IArray type class, and it has loads of unsafeFoo functions defined. And I have no idea what that implies for me, if I want to define a new instance of that class.
04:37:40 <shrughes> mmmdonuts: right
04:37:44 <mmmdonuts> Even across threads.
04:38:24 <luite> Araneidae: hsc2hs is a tool that can preprocess a haskell file annotated with som things to help working with structs and a few other C things
04:38:29 <mmmdonuts> But, if you have multiple threads, then you almost always need synchronization to prevent race conditions.
04:38:35 <int-e> danderson: it can mean a lot of things - it can mean that you can break the type system (unsafeCoerce), purity (unsafePerformIO), cause segfaults (unsafeWrite - there's no bounds checking then) ...
04:38:48 <luite> Araneidae: but you don't need it to make bindings (there are a few other tools available as well)
04:39:10 <Jedai> Araneidae: The FFI doesn't specify that immediately but tools like hsc2hs and c2hs allows you to use some macros and inclusion and translate that to the proper FFI code
04:39:19 <danderson> int-e: I see. So, presumably, unless I know what I'm doing, I should stick to what I know, and it'll still work just fine?
04:39:35 <Araneidae> luite, Jedai, I see
04:39:42 <mmmdonuts> That's not to do with partial reads/writes, but with the dependencies between reads and writes within each thread.
04:40:17 <int-e> danderson: that's the general idea, yes.
04:40:55 <Jedai> Araneidae: There is also a package "bindings-dsl" that purports to allow easy creation of basic bindings of C libraries
04:41:04 <int-e> danderson: on the other hand the operations exist for a reason. unsafeAt is faster than (!) because it omits the boundary check(s).
04:41:23 <danderson> I see. Thanks. Let's just hope I don't need to do unsafe ops to get a working implementation
04:42:04 <Araneidae> Well, at the moment I'm grovelling down in autoconf: think something is quite messed up with what I'm looking at (haskell-platform editline) on my system
04:42:04 <danderson> right, it makes sense when you have some external guarantees on the bounds. For a haskell newbie, the typeclass definition with loads of unsafe declarations is just a little daunting :)
04:42:29 <Twey> danderson: It means you need to be damned careful when using them.  :þ
04:42:35 <Twey> Heh.
04:47:47 <Araneidae> Ok.  I pass on haskell-platform: it's just plain broken on Ubunut 9.10 :(
04:48:33 <donri> I wonder what Linux is the most popular in Haskelland
04:49:01 <Araneidae> Possibly Debian?  Seems to get more enthusiasm...
04:50:13 <juhp> "ghc-pkg update" no longer seems to remove the older package version from the pkg list?
04:50:15 <SubStack> could be issues with sampling there
04:50:45 <juhp> (pretty annoying)
04:50:59 <Twey> donri: Arch, probably?
04:50:59 <Axman6> donri: could be Arch, dons has done a lot of work getting haskell as a first class citizen
04:51:40 <donri> AUR /= first class
04:51:51 <Axman6> well, close
04:51:54 <juhp> nod
04:52:01 * donri hates the AUR with passion
04:52:57 <kynky> haskell is great in gentoo
04:53:44 * juhp points at fedora-haskell
04:53:53 <donri> yes, i was surprised no one was mentioning fedora
04:53:59 <juhp> :)
04:54:17 <Araneidae> Haskell is good on Fedora?  That's good to hear: we use RHEL at work
04:54:28 <Axman6> hmm, i'm not even sure i have ghc installed on my fedora box yet
04:54:36 <Axman6> i must, since i installed Xmonad...
04:54:39 <donri> but RHEL is like "fedora five years ago" though, right?
04:54:45 <Araneidae> donri, absolutely
04:54:46 <donri> "plus enterprise"
04:55:07 <Araneidae> I'm told RHEL6 will be new and shiny when it arrives, maybe based on Fedora a couple of years ago?
04:55:21 <juhp> Araneidae: unfortunately Fedora SIG (we) haven't been pushing on ghc for EPEL...
04:55:30 <kynky> guess you would want to know if good centos support exists then ?
04:55:31 <donri> F12 in three days :)
04:55:40 <juhp> Araneidae: (rhel6 should be based on f12 yes)
04:55:59 <Araneidae> Woo.  I need to try a F12 install soon (for firewire, as it happens)
04:57:50 <juhp> Araneidae: current rawhide is basically f12 fwiw
04:58:13 <Araneidae> "rawhide" -- I'll try to remember that, our admin guy will know what I'm talking about
04:58:18 <Araneidae> What's EPEL ?
04:58:56 <Taejo> Araneidae: an epel is what the snake gave eve in eden
04:59:17 <juhp> hehe
04:59:34 <Twey> Ah, a Kiwi :þ
04:59:54 <juhp> http://fedoraproject.org/wiki/EPEL (Extra Packages for Enterprise Linux)
05:00:05 <Taejo> it was a real þorn in adam's side
05:01:06 <juhp> hmm guess i will do some testing on ghc-pkg update tomorrow - looks kinda bad
05:01:15 <donri> debconf is packaging with side-effects. \o/
05:09:24 <Araneidae> There's a funny dance for building haskell downloads, isn't there?  Can someone remind me the right magic incantations (I guess the equivalent to ./configure ?)
05:09:39 <koeien> cabal configure, probably
05:09:49 <Araneidae> ok, I'll try that
05:10:02 <koeien> 'cabal install' should suffice as a shorthand
05:10:24 <koeien> this requires a package 'cabal-install', which you may or may not have installed
05:10:25 <Araneidae> Interesting.  Then what's the role of the Makefile?
05:10:32 <Araneidae> (This is Yi, still)
05:10:58 * Araneidae expected to do `make`, or at least `make build` and have things work!
05:11:06 <koeien> i don't see a Makefile in Yi
05:11:15 <Araneidae> huh
05:11:46 <koeien> i did 'cabal unpack yi' and found no Makefile there
05:12:03 <Araneidae> It's there in the darcs version
05:12:08 <koeien> i see
05:12:24 <Araneidae> and it seems to go back to at least Dec last year
05:12:35 <Araneidae> Ok, I should ignore it!
05:13:08 <mmmdonuts> Araneidae: if a cabalized project uses make, running "cabal install" should run the makefile for you as part of the build. But that's usually just for C code etc. The Haskell part of the build is done by cabal.
05:13:41 <romildo> Hi.
05:13:49 <Axman6> hello romildo
05:13:51 <koeien> hello. how can we help?
05:14:20 <ivanm> hey Axman6
05:14:26 <Axman6> o/ ivanm
05:14:30 <Axman6> when are you coming down?
05:14:31 <ivanm> preflex: seen jfredett
05:14:31 <preflex>  jfredett was last seen on #haskell 7 hours, 59 minutes and 40 seconds ago, saying: unsafeOHNOES!
05:14:37 <ivanm> Axman6: good question :p
05:14:55 <ivanm> Axman6: my dad keeps saying we're going to go down, but every time I suggest a day it's no good :s
05:15:04 <Axman6> \
05:15:06 <Axman6> :\*
05:15:13 <ivanm> @tell jfredett there, I've written something for you to write about in HWN :p
05:15:13 <lambdabot> Consider it noted.
05:15:32 <romildo> I am rewriting a Java application to manage a collection movies. Up to now I have been using the standard String type for strings. But now I am considering bytestrings instead.
05:15:54 <ivanm> romildo: bytestrings are for efficient reading and manipulating of files
05:15:56 <ben> Considered Data.Text?
05:16:20 <ivanm> romildo: if you're wanting to do a lot of text manipulation, then Data.Text as ben suggested is a much better idea
05:17:04 <Axman6> hmm, i hadn't looked at Data.Text yet, i'm glad i did
05:17:19 <jkff> Hm, I'm seeing Data.Text for the first time. How is it different from bytestrings? Is it that it's all about unicode?
05:17:22 * ivanm hasn't looked at it either, mainly because he's had no real reason to...
05:17:47 <ivanm> jkff: I think it uses bytestrings under the hood
05:17:53 <koeien> jkff: bytestrings are strings of bytes, not necessarily of text
05:17:59 <Axman6> it uses Arrays of Word16
05:18:19 <romildo> ivanm, my application stores its data in a huge text file. Currently there are 676 movie titles and the file is over 6MB.
05:18:21 <Axman6> data Text = Text {-# UNPACK #-} !(A.Array Word16) {-# UNPACK #-} !Int {-# UNPACK #-} !Int
05:18:32 <ivanm> romildo: so, bytestring would be good for reading it in
05:18:38 <Axman6> romildo: that's not that huge to be honest :)
05:18:42 <jkff> ivanm: no it isn't
05:18:43 <ivanm> but it might not be as good for doing stuff with that data
05:18:46 <jkff> *doesn't
05:18:59 <ivanm> jkff: well, it uses bytestring...
05:19:12 <ivanm> ahhh, the Encoding modules
05:19:25 <romildo> The application starts by reading and parsing this text file when started, and writing the data back to the file when prompted by the user.
05:19:26 <jkff> According to what I see in the source and to what Axman6 has posted, it doesn't use bytestrings, it's just similar to them.
05:19:29 <ivanm> so, read it in with Bytestring, then convert to Text ?
05:19:45 <ivanm> jkff: not under the hood, there's conversion functions
05:19:47 <jkff> romildo: 6mb is more than enough to drop strings and use bytestrings or Text.
05:19:52 <jkff> ivanm: Oh, I see
05:20:13 <jkff> romildo: Are you having any problems with bytestrings/Text?
05:20:17 <ivanm> jkff: I can't see any IO functions in Text
05:20:28 <ivanm> jkff: so I think you'd probably use bytestrings for reading them in
05:20:31 <ivanm> preflex: seen bos
05:20:31 <preflex>  bos was last seen on #haskell 2 days, 6 hours, 8 minutes and 35 seconds ago, saying: it could just be faster still
05:20:42 <ivanm> jkff: he hasn't touched them yet IIUC
05:22:43 <Araneidae> My God.  My first impressions of Yi are that it is junk
05:23:01 <Araneidae> 1. Out of the box it simply fails to run
05:23:25 <ben> Same here
05:23:28 <Araneidae> 2. The configuration examples are as unhelpful as can be
05:23:43 <ivanm> Araneidae: worked for me with no problems
05:23:53 <Araneidae> 3. If there is a configuration file error there's no helpful report, just "Error occurred while loading configuration file."
05:23:58 <ivanm> even told me to pick a default mode (emacs-style, vi-style, etc.)
05:24:00 <Araneidae> ivanm, then you didn't have a problem
05:24:11 <Araneidae> When I run it, it says:
05:24:16 <ivanm> Araneidae: so I'm guessing it's something to do with your setup
05:24:19 <Araneidae> yi-linux-i386: user error (Terminal does not define required capability "cnorm")
05:24:45 <ivanm> yeah, sounds like a system problem
05:24:46 <romildo> I have not attempted using bytestring yet. Currently only String is used. I am concerned about unicode. Is there any reason for bytestring not woking with unicode? Or are my concerns unjustified?
05:25:01 <ivanm> romildo: completely separate concepts
05:25:04 <Araneidae> And what does Yi run on?  Thin air?  Or on systems.
05:25:12 <ivanm> romildo: as Axman6 said, bytestring is an array of bytes
05:25:21 <ivanm> you then have to convert them to something to deal with them
05:25:24 <Axman6> hmm, i find it odd that there's no Data.Text functions for reading and writing files
05:25:39 <ivanm> Axman6: bytestring using .Encoding AFAICT
05:25:52 <ivanm> utf8-string provides conversion functions to/from Bytesting to utf8-based strings
05:25:58 <Axman6> romildo: sounds like you really want Data.Text
05:26:11 <ivanm> Araneidae: yeah, but blaming your systems faults on yi isn't exactly fair...
05:26:22 <ivanm> Araneidae: does "ghc-pkg check" say anything? which configure flags did you use? etc.
05:27:10 <Araneidae> What do you mean "system's fault"?  I think you're transferring the blame
05:27:28 <Araneidae> I didn't use any "configuration" flags, I just ran `cabal install`
05:27:47 <Araneidae> `ghc-pkg check` says nothing at all
05:27:58 <Araneidae> (and returns with error code 0)
05:27:59 <ivanm> Araneidae: right, then you might not have built it properly
05:28:06 <ivanm> I'm not sure what its defaults are for UI...
05:28:46 <ivanm> Araneidae: you probably have to pick either vty or pango as a build-time flag to get a UI working
05:29:02 <Araneidae> Well, it offers -f vty as one of the frontend options
05:29:11 <ivanm> right
05:29:24 <Araneidae> Unfortunately the README is very lacking in detail
05:29:33 <ivanm> http://haskell.org/haskellwiki/Yi
05:29:46 <ivanm> oh, looks like it automagically tries to detect if vty or gtk2hs are installed...
05:31:17 <ManateeLazyCat> When i run command "darcs push AndyStewart@code.haskell.org:/srv/code/gtk2hs", it prompt me password, i input password for my account, but still prompt, i never input password when push patch, what's wrong with code.haskell.org ?
05:31:43 <ivanm> ManateeLazyCat: get an ssh-agent running
05:31:47 <ivanm> then you won't have to keep doing it
05:31:59 <ivanm> it probably wants authentification for each patch
05:32:14 <ivanm> (and it'd be a darcs thing rather than a c.h.o thing)
05:32:18 <dcoutts> no, there are no passwords for code.h.o
05:32:24 <dcoutts> only ssh keys
05:32:58 <ivanm> dcoutts: well, it's his system that keeps wanting to unlock the ssh key
05:32:59 <ManateeLazyCat> dcoutts: Don't need password when i push path to gtk2hs before.
05:35:33 <dcoutts> ManateeLazyCat: are you sure you've got the ssh key locally?
05:35:47 <dcoutts> your server side keys are still there and unchanged in months
05:35:56 <dcoutts> but I do see the rejection in the auth logs
05:37:02 <ManateeLazyCat> The authenticity of host 'code.haskell.org (72.249.126.23)' can't be established.
05:37:02 <ManateeLazyCat> RSA key fingerprint is 61:fb:46:e2:c8:c0:05:84:e5:6f:b4:f3:fa:73:97:bf.
05:37:02 <ManateeLazyCat> Are you sure you want to continue connecting (yes/no)?
05:37:02 <ManateeLazyCat>  
05:37:31 <dcoutts> looks like you lost your local ssh settings
05:37:34 <dcoutts> I don't get the same
05:38:09 <flux> manateelazycat, that will always be asked when you connect a new host via ssh
05:38:17 <ManateeLazyCat> dcoutts: How to get ssh key again?
05:38:22 <flux> maybe someone can confirm the fingerprint for you :)
05:38:47 <romildo> If I choose Data.Text, then the data file should be read using String, and my data types would use Data.Text.Text. When building values of those types I would then convert from String to Data.Text.Text using Data.Text.pack. Is that sensible?
05:40:10 <nipuL> is haskelldb-hdbc known not to work with hdbc-2.2.1, or has it just not been updated in hackage yet?
05:40:49 <Axman6> romildo: the Data.Text.Encoding module has f8unctions for converting  ByteStrings to Text, which is a much more sensible way to do things
05:40:49 <mmmdonuts> romildo, yes.
05:41:14 <mmmdonuts> romildo, ignore me
05:45:50 <romildo> In this case would it be more sensible to read the entire file into a lazy bytestring, converting it to a text, and parse the text?
05:46:48 <romildo> The bytestring would be converted to text using Data.Text.Encoding.decodeUtf8
05:50:54 <Axman6> http://www.reddit.com/r/programming/comments/a4j4a/whats_the_best_most_interesting_piece_of_code/c0ftftg :o
05:53:56 <koeien> zomg
05:54:21 <Axman6> apparently this regex finds prime numbers: /^1?$|^(11+?)\1+$/
05:54:50 <jelly12gen> lol
05:54:54 <Araneidae> Anybody know why glib and gtk aren't in cabal?
05:54:55 <EvilTerran> Axman6, er, really?
05:55:08 <Axman6> yes really
05:55:25 <byorgey> Axman6: well, actually it finds composite numbers.
05:55:29 <EvilTerran> it matches "" and "1", so i'm not sure what encoding you're thinking of
05:55:30 <byorgey> in unary.
05:55:41 <EvilTerran> ah, i see
05:56:12 <EvilTerran> yeah, i guess that does match composite number-length sequences of "1"s. clever.
05:56:24 <danderson> and to test it: perl -l -e '(1 x $_) !~ /^1?$|^(11+?)\1+$/ && print while ++$_;'
05:56:37 <danderson> (aka the "keyboard sneeze" program)
05:56:51 <fluxxen> hi could someone point me in the right direction if I want to add two custom list together like abc :: myList -> myList -> myList how would the pattern matching look like? I can't write like abc (x xs) (y ys) as for a normal list
05:56:59 <jelly12gen> so this is what you do when you are bored Axman6
05:56:59 <jelly12gen> :D
05:57:22 <Axman6> read reddit? yes
05:57:32 <Axman6> fluxxen: have you seen the source of (++)?
05:57:54 <byorgey> fluxxen: you can pattern-match a list with :
05:58:03 <byorgey> fluxxen: like  abc (x:xs) (y:ys) = ...
05:58:06 <EvilTerran> btw, any Category Theory types on?
05:58:14 <fluxxen> byorgey even though it's a custom? I am not so sure
05:58:26 <Axman6> no
05:58:35 <Axman6> fluxxen: what's your datatype look like?
05:58:38 <byorgey> fluxxen: oh, what do you mean, a custom list?  How are your lists defined?
05:58:42 <fluxxen> if I would have been ordinary list I know I could just x:xs:ys etc and ++ but not in custom
05:58:44 <byorgey> EvilTerran: ooh, pick me, pick me!
05:59:15 <Axman6> fluxxen: we can't help unless you give us the definition of your list type...
05:59:45 * Araneidae knows about CT theory
05:59:51 <fluxxen> Axman6 it's like this data Hand = Empty | Add Card Hand
06:00:06 <Araneidae> No, that didn't work.  I guess I just meant CT
06:00:10 <EvilTerran> i was hoping someone could explain to me why, given "o : HomC(B,C) * HomC(A,B) -> HomC(A,C)" we need to state "forall f : A -> B, g : B -> C. exists unique h : A -> C. h = g o f"
06:00:13 <fluxxen> and a Card is Card Jack Spades for example
06:00:27 <EvilTerran> as part of the definition of a category
06:00:28 <fluxxen> and [] is Empty
06:00:34 <mmorrow> @src unzip
06:00:34 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
06:00:48 <Araneidae> EvilTerran, well the whole point is to have composition of arrows: that's what Categories are for!
06:00:48 <Axman6> well, you'd just use: abc Empty rest = rest; abc (Add c h) rest = Add c (abc h rest)
06:00:54 <Philonous> fluxxen: You match patterns just as you create them. So if you have data Foo = Bar Quux Quuux ... than you do myfunction (Bar quux quuux) = ...
06:02:07 <Araneidae> EvilTerran, that's strange.  The "forall ..." clause you give is implicit in the statement that _o_ is a function.  Odd, where did that come from?
06:02:38 <Philonous> If you match multiple patterns in one function you just need to write one definition for every combination of constructors.
06:02:46 <byorgey> EvilTerran: basically that is saying that composition is a function.
06:02:57 <EvilTerran> Araneidae, byorgey, yeah, that's what i thought
06:03:03 <byorgey> EvilTerran: it probably comes from thinking of the definition as a many-sorted algebra
06:03:06 <fluxxen> Philippa yes but how could I get like xs in (x xs)? like (Add(x)Add(xs)Empty) ?
06:03:11 <EvilTerran> Araneidae, my lecturer's slides; actually, looking at them again, it seems the "exists unique" thing is used in place of actually defining composition
06:03:19 <Araneidae> But the original statement "o : C(B,C) x C(A,B) -> C(A,C)" says the smae thing
06:03:37 <byorgey> so just saying  o : HomC(B,C) * HomC(A,B) -> HomC(A,C)  doesn't necessarily mean it's a function, just expressing the type of the  o  constructor, if you will
06:03:44 <Axman6> fluxxen: your syntax is fairly strange
06:03:53 <EvilTerran> instead of him saying that the definition of a category includes a definition of composition, he's just stated the "exists unique" thing strangely
06:04:05 <Araneidae> But it had better be a function ... or at least, an arrow in the appropriate meta-category
06:04:35 <Araneidae> In fact, the uniqueness statement is rather bogus: any "arrow" C(B,C) x C(A,B) -> C(A,C) will serve
06:04:44 <fluxxen> Axman6 hehe yes I am confusing myself but it's part of an exercise so it's nothing I have come up with. don't want complete answers but hints and I think I got some now and gonna try some stuff out. been sitting with it for a while now
06:04:57 <Araneidae>  -- if you take that idea seriously enough you get enriched categories
06:05:16 <byorgey> Araneidae: huh, why is the uniqueness bogus?  you can't have a composition give you two different results.
06:05:16 <Axman6> fluxxen: well, be sure to let us know if you need more help
06:05:21 <EvilTerran> he's written something to the effect of "forall f : A -> B, g : B -> C. exists unique (g o f) : A -> C"
06:05:35 <ksf> @pl \(x,y) -> (f x, f y)
06:05:35 <lambdabot> f *** f
06:05:38 <EvilTerran> which seems a really odd way to state it to me
06:05:40 <Philonous> fluxxen : Well, you have (Add x xs).
06:05:48 <ksf> @pl \f (x,y) -> (f x, f y)
06:05:48 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
06:05:53 <ksf> yeuch
06:06:01 <noteventime> haha
06:06:02 <EvilTerran> ?type join (***)
06:06:03 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
06:06:08 <ksf> :t (&&&)
06:06:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:06:17 <Axman6> @pl \f -> first f . second f
06:06:18 <EvilTerran> > join (***) f (x,y) :: (Expr,Expr)
06:06:18 <lambdabot> liftM2 (.) first second
06:06:19 <lambdabot>   (f x,f y)
06:06:24 <fluxxen> Axman6 thanks man , really appreciate it
06:06:28 <Araneidae> It's bogus because the arrow C(B,A)xC(A,B) -> C(A,C) doesn't even need to be a function between sets, it can be a morphism in any suitable category
06:06:53 <Araneidae> For example, it could be a relation!
06:06:57 <Axman6> fluxxen: best plase to start would be: finish this line: abc Empty rest = ...
06:07:31 <fluxxen> Axman6 ah okey
06:07:38 <byorgey> Araneidae: well, but not when you're just starting out with the definition of a basic category.
06:07:40 <fluxxen> thanks
06:07:46 <Axman6> fluxxen: so, what should be on the right of the =?
06:07:53 <noteventime> Any reflexive, transitive relation would form a category, right?
06:08:09 <EvilTerran> Araneidae, ah, i see; so the definition is necessarily slightly strangely stated for when you're thinking of categories where composition is a function to allow for categories where it's some other flavour of arrow?
06:08:29 * EvilTerran should've used more punctuation there :P
06:08:39 <fluxxen> Axman6 hm it should just be = rest if that is the case?
06:08:40 <Araneidae> byorgey, you're quite right.  But even so, the emphasis should be on the algebra of combining arrows,
06:08:41 <EvilTerran> (put a "," after "function", if that helps)
06:08:46 <Axman6> fluxxen: yup
06:09:31 <Axman6> now, what's the other alternative for Empty in a Hand?
06:09:40 <ManateeLazyCat> dcoutts: Ooops, i delete ~/.ssh when i install new system.
06:09:55 <dcoutts> ManateeLazyCat: ahh, got a backup?
06:10:08 <ManateeLazyCat> dcoutts: No.
06:10:15 <ManateeLazyCat> dcoutts: I forgot it.
06:10:16 <fluxxen> Axman6 (Add card otherCards) ?
06:10:21 <Axman6> yep
06:10:32 <ManateeLazyCat> dcoutts: I forgot backup .ssh file.
06:10:35 <dcoutts> ManateeLazyCat: then you'll need to generate a new ssh key and send the public part to the code.h.o admins, see the webpage
06:10:38 <Axman6> so, what doesa abc (Add card otherCards) rest have to do?
06:11:03 <ManateeLazyCat> dcoutts: Okay, thanks.
06:11:04 <byorgey> EvilTerran: I kind of doubt it's stated slightly strangely for any particular reason.  it's probably just stated strangely. =)
06:11:05 <ksf> EvilTerran, that's.... beautiful. but useless. x and y have distinct types.
06:11:57 <mmorrow> @src transpose
06:11:57 <lambdabot> transpose []             = []
06:11:57 <lambdabot> transpose ([]   : xss)   = transpose xss
06:11:57 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:12:18 <EvilTerran> ksf, ah; sounds like you might be running into the limitations of rank-1 types
06:13:06 <fluxxen> Axman6 this is where the trickyness begins I am not quite sure
06:13:12 <EvilTerran> byorgey, heh, true. i might just ignore it for the time being and go for "when defining a category, define composition" in my personal notes.
06:13:45 <Axman6> fluxxen: ok, well, how about we make it look more like lists: abc (card `Add` otherCards) rest = ...
06:14:00 <Axman6> here, you can see that `Add` is the same as (:) for lists
06:14:15 <Axman6> (this is perfectly valid code by the way)
06:14:35 <byorgey> EvilTerran: right.  "whenever you have two arrows that match up, you can compose them to get a third arrow."
06:15:19 <ksf> EvilTerran, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12174#a12174
06:15:24 <ksf> It's not too bad without them.
06:15:58 <fluxxen> Axman6 ah okey that helps out hm
06:16:50 <Philonous> fluxxen: Suppose you already know how to concatenate otherCard and rest. What is the last thing you need to do?
06:16:54 <fluxxen> Axman6 I have to do it recursive to add one card from rest at the time or could I do it all together like Add(card 'Add' otherCards 'Add' rest) ?
06:17:05 <romildo> In my movie collection manager program I use gtk2hs for the GUI. If I choose to switch from String to a type like Data.Text.Text for an efficient packed Unicode text type, then there would be the incovenience of converting to/from String when using gtk2hs, as widgets expect String.
06:17:32 <benmachine> okay so, I did a ./darcs-all pull -a on my ghc checkout
06:17:34 <fluxxen> and maybe have Empty at the end
06:17:35 <Axman6> fluxxen: i'll give you a hint: abc (card `Add` otherCards) rest = card `Add` ..., and it includes recursion
06:17:42 <benmachine> and it says, Merging them 35/191
06:17:43 <ksf> It's kind of strange that the code passes without annotation, but _giving_ an annotation requires an extension.
06:17:45 <Philonous> fluxxen: You can't Add otherCards rest, beacuse the left part of Add needs to be a single card
06:17:52 <benmachine> it said that before I went out to buy breakfast, too
06:18:03 <benmachine> it is at 100% and has accumulated 22 minutes CPU time
06:18:05 <fluxxen> Axman6 ok thanks. give me a couple a minutes and I gonna try it out and I come back =) really thanks!
06:18:09 <dcoutts> benmachine: probably you've got some clashing local patches
06:18:25 <benmachine> dcoutts: that sounds unlikely, but I won't rule it out
06:18:37 <benmachine> should darcs be 100%-ing in that case?
06:18:38 <dcoutts> benmachine: time to ^C and try, darcs push --dry-run, or darcs revert
06:19:06 <dcoutts> benmachine: it's a known failure mode in "darcs 1" format repositories, to have exponential merge times
06:19:14 <benmachine> oh
06:19:20 <dcoutts> when there are conflicting patches
06:19:26 <romildo> Because of that now I am not sure if it would be a good decision to use packed strings. I would like to reduce memory consumption and mainly get the input data parsed more quickly. Any opnions?
06:19:30 <ben> Converting Data.Text.Texts to a [Char] and then back to a CString just to call some stupid gtk function is backwards as fuck :C
06:19:32 * ksf thinks darcs should give a warning for darcs1 repos
06:19:44 <dcoutts> benmachine: this was the major improvement in darcs 2, but only for the new darcs 2 format repos
06:19:47 <ksf> ...and offer to convert to darcs2 on the fly while fetching
06:19:54 <Heffalump> ksf: it can't, they're not compatible
06:20:00 <dcoutts> ksf: everyone has to convert at once, that's the issue
06:20:07 <Heffalump> also, you do need quite a few conflicts even before darcs 1 goes exponential
06:20:19 <benmachine> hasn't ghc switched to git yet
06:20:22 <Heffalump> and finally, darcs 2 is better, but still not perfect, sadly
06:20:35 <Heffalump> no, they basically changed their mind, at least for now
06:20:41 * EvilTerran wishes he had a way of typesetting his CT notes that didn't make him want to bash his head against the keyboard
06:20:57 <dcoutts> benmachine: the current plan is to procrastinate until darcs 2 is good enough
06:20:59 <ksf> EvilTerran, tex?
06:21:12 <EvilTerran> tex has that effect, i'm afraid
06:21:24 <ksf> tex or latex?
06:21:24 <tibbe> waern: yt?
06:21:32 <benmachine> okay apparently there *are* things darcs wants to push
06:21:36 <benmachine> not that any of them are my things
06:21:55 <EvilTerran> ksf, the part of my mind that loves algebraic tidiness screams at the idea of the core tex language
06:22:09 <Heffalump> and LaTeX just makes it worse
06:22:15 <ksf> oh, then you don't want to look at latex's source.
06:22:17 <ManateeLazyCat> dcoutts: Which pages is for update SSH key? Or i need send mail to administrator?
06:22:23 <ksf> komascript makes it better, though.
06:22:25 <EvilTerran> tex was great for the time
06:22:38 <dcoutts> ManateeLazyCat: the latter
06:22:39 <waern> tibbe: yep
06:22:41 <EvilTerran> but there are different priorities for typesetting these days
06:22:47 <ksf> it's going to get better, soon, when luatex becomes the standard implementation.
06:22:59 <dcoutts> benmachine: you missed the email I think
06:23:08 <EvilTerran> and indeed for computer languages as a whole
06:23:09 <tibbe> waern: it's somewhat ironic that the haddock code lacks haddock documention :)
06:23:25 <benmachine> dcoutts: email?
06:23:38 <ksf> they're going to completely recode (and re-invent) latex, after all, with lua, you can actually change stuff without changing everything.
06:23:45 <waern> tibbe: yes :-)
06:23:49 <Twey> Aye to that.
06:24:07 <Twey> It sounds fantastic, but LuaTeX isn't scheduled for stable release for a few years yet.
06:24:13 <tibbe> waern: I'm experimenting a bit with the HTML backend atm
06:24:15 * EvilTerran is a haskeller because he likes his computer languages to be semantically simple; TeX is possibly the opposite.
06:24:15 <dcoutts> benmachine: http://www.haskell.org/pipermail/cvs-ghc/2009-October/050760.html
06:24:18 <Twey> TeX is long-term development.
06:24:22 <waern> tibbe: I just read your mail. Feel free to add that comment to ppTypeOrFunSig
06:24:31 <ksf> Twey, I don't care what they say, it works just fine.
06:24:32 <tibbe> waern: is the comment correct
06:24:40 <tibbe> waern: I kinda inferred it from what it seems to be doing
06:24:52 <Twey> One imagines that after LuaTeX is stable, the weird impure TeX bits of it will be slowly replaced.
06:24:54 <ksf> and is the only tex driver that gives you both microtypography _and_ truetype
06:24:59 <benmachine> dcoutts: oh
06:25:03 <benmachine> thanks
06:25:20 <waern> tibbe: yes
06:25:31 <tibbe> waern: what do the DocForDecl and DocName types represent?
06:26:04 <ksf> dunno if they started recoding latex in lua, yet. but the context guys are already heavily using it iirc
06:26:10 <Twey> ksf: Nevertheless, it's not even in the AUR.  ☹
06:26:24 <ksf> it's in texlive
06:26:38 <waern> tibbe: DocName is just a Name that might have a "documentation origin" other than the Module in the Name
06:27:01 <tibbe> waern: I see, is it for the "not-home" option?
06:27:26 <ksf> although I ended up circumventing portage to get stuff running, as portage doesn't know how to treat texlive right.
06:27:51 <ManateeLazyCat> dcoutts: I haven't found any page that can update SSH key, i think i should send mail to "support [AT] community.haskell.org" ?
06:27:51 <benmachine> Twey: as cute as your unicode smiley faces are, I have to peer at the screen a little to tell which one it actually is
06:28:08 <tibbe> waern: what's the "summary" argument passed to ppFunSig?
06:28:16 <Axman6> fluxxen: any luck?
06:28:42 <waern> tibbe: the "documentation origin" is the module which is regarded as the "best" place to link to in the documentation
06:28:59 <Twey> benmachine: I suggest a better font.  ;)
06:29:24 <waern> tibbe: this module may be different than the original module, and not just when using not-home
06:29:43 <tibbe> waern: ok, got it
06:30:00 <waern> tibbe: DocForDecl is just a doc for a declaration and docs for its subordinate declarations
06:30:01 <fluxxen> Axman6 : I understand the idea now. Like = (card `Add` rest) first to add the first card in the first Hand to the other hand and then do this recursivly like = (card `Add` rest) abc otherCards rest , right? but What sohuld I have between ")" and "abc" because I get compile error or does it work that way? because I would think that solution would work since it takes the first card and add's it to the rest hand and does t
06:30:44 <ksf> is -fviaC smart enough to replace /2 with `shr` 1?
06:30:45 <Philonous> fluxxen: If you add the reverse of the left list
06:30:57 <waern> tibbe: it's flag to tell if we're rendering the summary or not. The summary is the first part of the html page which doesn't contain the docs, only declarations in short-form
06:31:07 <Philonous> fluxxen: Uhh, I meant if you do it like this you reverse the left list
06:31:13 <tibbe> waern: I see
06:31:13 <Axman6> fluxxen: that's not quite right, but it's close: abc (card `Add` otherCards) rest = card `Add` (abc otherCards rest)
06:32:00 <tibbe> waern: so in ppTypeOrFunSig it seems like we render on one line if 1) we're creating the summary or 2) none of the arguments are documented
06:32:05 <Axman6> fluxxen: i know i gave you the answer when you asked not to, but i think you'll learn more (and be less frustrated) if you sit there and make sure you understand the code
06:32:15 <fluxxen> Axman6 ohh..one thing about haskell when someone show you the answer it seems obvious but it's hard to get it together but I understand complety the solution
06:32:41 <Twey> fluxxen: It gets easier.  ☺
06:32:44 <Axman6> fluxxen: well, *make sure* you *fully* understand that code before moving on ;)
06:32:56 <fluxxen> Axman6 yes thanks. I have tried alot of things so thanks. not trying to go here to just get the answers and not learn. but now it was nice to get the answer so I can get going because I really udnersatand it
06:33:01 <dcoutts> ManateeLazyCat: yes
06:33:23 <waern> tibbe: that should be right, yes
06:33:40 <waern> tibbe: do you plan to rewrite the backend or just modify it?
06:33:46 <ManateeLazyCat> dcoutts: Okay, i send mail to "support [AT] community.haskell.org", thanks for help.
06:33:55 <skorpan> hi.  i'm writing a little lexer and i'm just now realising that it's the first time i'm writing my own one from scratch, i.e. not using alex.  is it common to make newlines separate tokens?
06:33:57 <fluxxen> Axman6 thanks alot mate going to go onto the next exercise now =)
06:34:12 <tibbe> waern: well, lots of changes are needed to generate non-table HTML but the structure should stay similar
06:34:23 <Axman6> fluxxen: are you *sure* you understand how that code works? (perhaps you could explain it to me)
06:34:52 <ben> If you understand how your haskell code works, it is not sufficiently advanced.
06:35:57 <Paczesiowa> skorpan: usually tokens can be seperated by any whitespace
06:36:17 <waern> tibbe: right. Depending on how much will change, it might be a good opportunity to switch to the html package on hackage
06:36:22 <skorpan> Paczesiowa: e.g. python code is special though...
06:36:25 <Axman6> ben: if that's how you write code, i don't want to read it :)
06:36:41 <ksf> what's the difference between ar = array (0,len) . zip [1..]  and  ar xs = array (0,len) . zip [1..] $ xs  ?
06:36:41 <tibbe> waern: yes
06:36:43 <Paczesiowa> skorpan: "usually":)
06:36:54 <fluxxen> Axman6 yes. the abc (card `Add` otherCards) rest = card `Add` (abc otherCards rest) pattern takes the first card from hand1 and add it to the rest hand and does this recursivly until the first hand is empty and when it's empty all the cards from it have been added to the rest hand and therefor the returned hand which is the combined hands is the rest hand.
06:36:54 <tibbe> waern: I think that should be straight forward
06:37:10 <skorpan> Paczesiowa: this is the first time i'm writing a lexer/parser for a non-C-like language :)  does it sound reasonable to you if a python lexer makes newlines a separate token?
06:37:11 <ben> ksf: One of them might possibly be polymorphic?
06:37:15 <waern> tibbe: ok, that's great
06:37:21 <ksf> ben, bastard, you knew.
06:37:32 <ksf> I find that dissatisfying.
06:37:43 <Axman6> fluxxen: i wouldn't say that's totsally correct. the cards aren;t being added to the rest hand (in face, really the rest hand is being added to the first hand)
06:37:52 <ben> type signatures every day~
06:37:54 <ksf> and confusing.
06:37:54 <Paczesiowa> skorpan: languages with significant whitespace are different beasts
06:38:25 <ksf> I'm aiming to leaving out the sigs for the sake of gzip size.
06:38:32 <fluxxen> Axman6 oh thanks for pointed that out
06:38:35 <ben> right
06:38:57 <Jafet> You can lex such a language into a whitespace-insensitive one, then parse it as usual
06:39:10 <Jafet> Haskell is definitely amenable to that, not sure about python
06:39:17 <ben> Axman6: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4945 s my code; it is full of IO and devoid of meaning
06:39:33 <ksf> the only ones left should be the ones that override ghc's defaulting.
06:39:47 <Paczesiowa> iirc there was parser on hackage for langs with significant whitespace
06:39:56 <ben> Can you put {-# LANGUAGE NoMonomorphismRestriction #-}?
06:40:12 <ben> If you have enough functions it applies to, maybe you will save on size (assuming I did not mistype that)
06:40:18 <Axman6> ben: heh, you don't happen to write Objective-C do you?
06:40:31 <ben> Axman6: No, sorry :(
06:40:34 <ben> I used to write Ruby a lot
06:40:36 <fluxxen> Axman6 ye you are right as for card `Add` othercards is like x:xs and the xs is added to the x. and here it's like that card `Add` do it again until there are no cards left
06:40:38 <ben> Maybe that is close enough.
06:40:43 <ksf> ben, yes.
06:40:56 <ksf> though I don't think pragmas are stripped for gzip
06:41:04 <ksf> but it looks nicer that way
06:41:12 <Axman6> ben: it's just that your function names are very ObjC-esque
06:41:21 <ben> Ah
06:41:29 <Axman6> buildSymbolicLinksWithSaveNames
06:41:52 <ben> I would have written symlinks, but the unix package seems to spell it out every time
06:42:42 <ksf> @pl \xs -> \len xs -> ((,) len) . first ar . second ar . unzip . go 0) (length xs) xs
06:42:42 <lambdabot> (line 1, column 66):
06:42:43 <lambdabot> unexpected ")"
06:42:43 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
06:42:54 <ksf> @pl \xs -> (\len xs -> ((,) len) . first ar . second ar . unzip . go 0) (length xs) xs
06:42:55 <lambdabot> (. (first ar . second ar . unzip . go 0)) . (,) . length
06:43:16 <ksf> that's almost readable
06:44:58 <Jafet> Perhaps what Randall thought was God's work holding up the universe, was actually in Haskell.
06:45:19 <Jafet> Dazzled by the <$>.
06:45:38 <skorpan> liftM is equivalent to fmap, but is there any equivalent to liftM2?
06:45:45 <skorpan> okay not *equivalent*
06:45:57 <skorpan> but fmap can be used instead of liftM, but can something else be used instead of liftM2?
06:46:07 <ksf> :t liftA2
06:46:09 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
06:46:12 <ksf> :t liftM2
06:46:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:46:23 <skorpan> are all monads applicative?
06:46:28 <ksf> yep
06:46:30 <skorpan> cool
06:46:38 <ksf> the typeclasses are broken
06:46:43 <skorpan> but are all applicatives functors?
06:46:49 <ksf> yes
06:46:54 <skorpan> interesting
06:46:54 <Apocalisp> @pl \f x y -> f <$> x <*> y
06:46:55 <lambdabot> (. (<*>)) . (.) . (<$>)
06:47:01 <ksf> read the typeclassopedia, it says it all
06:47:09 <skorpan> yeah, i did, just can't remember
06:47:32 <dmwit> :t \f x y -> return f `ap` x `ap` y
06:47:33 <lambdabot> forall a a1 b (m :: * -> *). (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
06:47:41 <dmwit> :t liftM2
06:47:42 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:47:51 <Apocalisp> @pl \f x y -> return f <$> x <*> y
06:47:51 <PeakerWork> I just got an old script to work:   hawk  -- lets you run stdin->stdout through arbitrary Haskell functions. My cmd line is that much more powerful :)
06:47:52 <skorpan> this is madness!
06:47:52 <lambdabot> (. (<*>)) . (.) . (<$>) . return
06:47:57 <ksf> applicatives are to monads what context-free grammars are to context-sensitive grammars
06:48:01 <Apocalisp> @pl \f x y -> return f <*> x <*> y
06:48:02 <lambdabot> ((<*>) .) . (<*>) . return
06:48:05 <Apocalisp> grr
06:48:14 <dmwit> PeakerWork: What, didn't you know about ghc -e?
06:48:55 <PeakerWork> dmwit: I need a bunch of imports and utilities available
06:49:05 <Apocalisp> @type \f x y -> f <$> x <*> y
06:49:07 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
06:49:08 <PeakerWork> dmwit: I'd suppose ghc -e gives you the same environment a file with --make would have?
06:49:27 <dmwit> PeakerWork: ghc -e can give you any environment ghc can, with the same syntax
06:49:28 <ksf> and propably replace everything with bytestrings
06:49:40 <PeakerWork> dmwit: I write:   hawk 'ol (join (++))' to double the text of all lines.  hawk 'il tail'    to remove the first line.
06:49:44 <ManateeLazyCat> dcoutts: Just administrator can read mail to support@community.haskell.org ? I got rt@rt.haskell.org said "Your ticket has been
06:49:44 <ManateeLazyCat> assigned an ID of [rt.haskell.org #901]."
06:49:56 <PeakerWork> dmwit: how do you configure which imports/environment is available in ghc?
06:50:02 <PeakerWork> (without affecting normal files)
06:50:18 <skorpan> what's the best data structure to use (without ST hackery and other black magic) if i want O(1) lookup and don't care even if it's O(n^n) insertion/update/etc?
06:50:34 <dmwit> PeakerWork: ghc ~/programming/Dmwit.hs -e "something using stuff from Dmwit.hs"
06:50:36 <PeakerWork> skorpan: perfect hash?
06:50:51 <Heffalump> skorpan: an array?
06:50:53 <dmwit> skorpan: array, I guess
06:51:01 <PeakerWork> dmwit: Ah, then "hawk" can be a ghc hawk_env.hs -e "expr"
06:51:01 <dcoutts> ManateeLazyCat: it can be read by any of the admins
06:51:45 <Apocalisp> @pl \f x y -> f `fmap` x `ap` y
06:51:45 <lambdabot> liftM2
06:51:49 <Apocalisp> Whew!
06:53:15 <skorpan> can i use strings as indices in arrays?
06:53:35 <Heffalump> skorpan: if you make an Ix instance, yes
06:53:40 <skorpan> i mean, seeing as there is no Ix instance
06:53:44 <skorpan> oh, i see...
06:53:46 <Heffalump> (I'd suggest wrapping them first, it'd seem like a really weird thing to do normally)
06:53:48 <yitz> preflex: seen dcoutts
06:53:49 <preflex>  dcoutts was last seen on #haskell 2 minutes and 49 seconds ago, saying: ManateeLazyCat: it can be read by any of the admins
06:53:56 <Heffalump> what exactly are you trying to achieve?
06:54:12 <Heffalump> do you want it to be O(1) even in the length of the string?
06:54:25 <ManateeLazyCat> dcoutts: Oh, i see, I consider that is public mail. (I send new SSH key in that mail).
06:54:44 <dmwit> skorpan: If the strings happen to all be the same length, you could use my Ix a => Ix [a] instance.  But it's pretty specific to all-same-length lists. =P
06:54:44 <skorpan> Heffalump: i'm writing a lexer and at certain places in the input there must be a "valid" string, which is one out of ~25 possible ones
06:54:55 <ManateeLazyCat> preflex: seen mmorrow
06:54:56 <preflex>  mmorrow was last seen on #haskell 42 minutes and 59 seconds ago, saying: @src transpose
06:54:57 <skorpan> dmwit: yeah, they're not :/
06:55:14 <dmwit> skorpan: Lookup in just about any data structure is O(1) if the number of entries is O(1).
06:55:16 <dcoutts> yitz: hello
06:55:17 <yitz> dcoutts: hi. just bootstrapped cabal-install on a Debian Lenny server, featuring ghc 6.8.2 and base 3.0.1. then cabal update and cabal upgrade cabal-install.
06:55:37 <dmwit> skorpan: Just use Data.Set, is what I'm saying.
06:55:39 <skorpan> i was thinking of using a Map as such: fromList $
06:55:50 <dcoutts> yitz: and cabal upgrade did all sorts of silly things?
06:55:52 <yitz> it then choked on unix-2.3.2.0 with:
06:55:59 <skorpan> i was thinking of using a Map as such: M.fromList $ [("fg", Fg), ("bg", Bg"), ...]
06:56:00 <yitz> Module `GHC.Conc' does not export `Signal'
06:56:01 <dcoutts> yitz: yeah, don't do that, use install
06:56:08 <yitz> install?
06:56:09 <skorpan> uh, typo on Bg" <- should be Bg
06:56:15 <dmwit> skorpan: or Map, right
06:56:16 <skorpan> so Fg and Bg are both constructors of my token type
06:56:17 <Heffalump> skorpan: unless you are going all out for speed, a map/set sounds fine here..
06:56:36 <yitz> oh, hmm. install what? cabal-install?
06:56:44 <skorpan> cool, but does my approach to this string -> token translation sound reasonable?
06:56:48 <doserj> yitz: don't use cabal upgrade, use cabal install
06:56:52 <dmwit> yes
06:56:53 <yitz> ever?
06:57:01 <doserj> ever
06:57:04 <skorpan> dmwit: was that for me?
06:57:06 <doserj> until it is fixed
06:57:09 <yitz> oh. too bad.
06:57:20 <dmwit> skorpan: yes =)
06:57:25 <skorpan> cool :) thanks a lot you guys
06:57:33 <yitz> so, how do i recover now? cabal upgrade installed all kinds of things
06:57:33 <dcoutts> yitz: problem with upgrade, is it's a nice idea in theory, to try to upgrade all dependencies too, but actually you don't want to upgrade core packages
06:57:38 <dcoutts> yitz: unregister those
06:58:05 <ManateeLazyCat> dcoutts: Today, i check darcs version of gtk2hs, i got two error. First eeror is missing `import System.Glib.GList` in file CellLayout.chs.pp to make `compile` failed, and second is ghc: /usr/local/lib/gtk2hs/HScairo.o: unknown symbol arrayzm0zi2zi0zi0_DataziArrayziBase_zddmunsafeNewArrayzu_closure' , i think is something missing in Makefile.am
06:58:06 <ManateeLazyCat>  
06:58:06 <ManateeLazyCat>  
06:58:10 <yitz> ok. so everything in my local package.conf then, i guess.
06:58:44 <a_guest> I want to define a typeclass "class ToRefF t a b where toRefF :: t -> (Ref -> F a b)". I want the instance for (Ref -> F a b) to be id. But I get some kind-problem when defining it. So how do I define that instance?
06:58:50 <yitz> should i then try cabal install cabal-install? or just leave it alone?
06:59:10 <dcoutts> yitz: yes, cabal install cabal-install
06:59:52 <yitz> no wait, i need to leave Cabal-1.6.0.2, HTTP... hmm this is a mess, hope I can figure it out. :(
07:00:52 <yitz> dcoutts: if it's really that broken, perhaps disable "upgrade" by default?
07:01:05 <dcoutts> yitz: I did, for "cabal upgrade" itself
07:01:31 <dcoutts> reports of borkage has significantly reduced since
07:01:37 <yitz> dcoutts: but I needed to cabal upgrade first, to get the disabled one. :)
07:01:54 <dcoutts> you can always use install instead
07:02:28 <yitz> yeah, now you tell me. anyway thanks, I've got it now, I'll work it out. :)
07:02:37 <mmorrow> ManateeLazyCat: hi
07:02:44 <ManateeLazyCat> mmorrow: Hi. :)
07:02:47 <mmorrow> @. undo src transpose
07:02:47 <lambdabot> ()
07:05:00 <dmwit> uh
07:05:03 <dmwit> ?src transpose
07:05:04 <lambdabot> transpose []             = []
07:05:04 <lambdabot> transpose ([]   : xss)   = transpose xss
07:05:04 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
07:05:39 <ManateeLazyCat> dcoutts: I'm curious other developers how to work with gtk2hs, why have so many errors in darcs version? Most error just forgot add `import` or something. What do you think?
07:05:54 <a_guest> I have a problem defining a typeclass instance: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12175#a12175
07:06:08 <dcoutts> ManateeLazyCat: I don't know, I don't hack on it much atm
07:06:30 <a_guest> Is it possible to create such a instance?
07:07:05 <dmwit> a_guest: ToRefF needs three arguments, and you gave it only one.
07:08:39 <dmwit> a_guest: Perhaps you meant "instance ToRefF (Ref -> F a b) a b where" ?
07:08:56 <dmwit> Not sure that's going to work, either, but at least you'll get a different error message.
07:09:11 <a_guest> dmwit: yes, something that way.
07:09:14 <doserj> it works
07:09:25 <doserj> after adding typesynonyminstances and flexibleinstances
07:09:58 <tibbe> waern: when DocName is used in HsType DocName does it describe the binder used?
07:10:02 <mmorrow> dmwit: i think the multiline fooled it
07:10:10 <mmorrow> @undo transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
07:10:11 <lambdabot> transpose ((x : xs) : xss) = (x : concatMap (\ a -> case a of { (h : t) -> [h]; _ -> []}) xss) : transpose (xs : concatMap (\ a -> case a of { (h : t) -> [t]; _ -> []}) xss)
07:10:17 <a_guest> good.
07:10:35 <ManateeLazyCat> dcoutts: I'm always `make` again for test completely, before i push patch, are you?
07:11:46 <a_guest> Is there a good description of the typeclass syntax?
07:11:59 <dmwit> ?where report
07:12:02 <lambdabot> http://www.haskell.org/onlinereport/
07:12:18 <doserj> for MPTCs, you will have to look at the ghc manual, though
07:12:31 <dcoutts> ManateeLazyCat: it's a good idea to
07:12:36 <a_guest> ok, thank you!
07:12:39 <waern> tibbe: not sure what you mean. There is no binder in a HsType
07:13:22 <tibbe> waern: my mistake, what's DocName in HsType DocName?
07:13:28 <waern> the DocNames in there are all the type constructors
07:14:26 <Dertyderty7654> @cerca windows
07:14:28 <lambdabot> No match for "windows".
07:16:12 <Axman6> @help cerca
07:16:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:17:55 <ManateeLazyCat> dcoutts: I think recently errors is including by Alex, i really can't understand he how to including those error? Won't `make` for test?
07:18:17 <ManateeLazyCat> dcoutts: We can avoid those *little* mistake, otherwise we will hurt gtk2hs user.
07:18:25 <dcoutts> ManateeLazyCat: indeed
07:21:51 <ManateeLazyCat> dcoutts: I guess he have two repo, one for `make` test new code, another for `generate patch`, so he will forgot something when he move modified file to `generate patch` repo. I have ask this problem in gtk2hs-devel, but now response. ;-(
07:22:57 <ManateeLazyCat> dcoutts: I will ask again.
07:25:16 <ManateeLazyCat> dcoutts: About concurrent problem with gtk2hs, what do you think? I know Alex have working on it.
07:25:25 * EvilTerran considers writing a haskell library to generate mathml, because writing it directly sucks
07:25:42 <dcoutts> ManateeLazyCat: I'm not actually a maintainer anymore, so best to talk to Axel
07:28:33 <ManateeLazyCat> dcoutts: Ok.
07:35:34 <ManateeLazyCat> dcoutts: I'm thinking about multi-process design with some GUI program, like http://farm4.static.flickr.com/3505/4015396183_585baf5fec_o.png , use RootProcess control base Notebook render, and very Tab in Notebook is running in ChildProcess, use Named-Pipe communication between RootProcess and ChildProcess. If ChildProcess crash (un-catch exception), just close Tab, RootProcess and Notebook still running. So how to transform Gtk+ Widget
07:35:34 <ManateeLazyCat> through Named-Pipe ? Such as Box widget to Notebook?
07:36:04 <dcoutts> ManateeLazyCat: you can do cross-process embedding you know
07:36:17 <waern> tibbe: actually they can be type variables also
07:36:31 <tibbe> waern: ok, I'm almost getting some output from my change now :)
07:36:49 <waern> tibbe: cool!
07:36:52 <ManateeLazyCat> dcoutts: cross-process *embeddeding* ?
07:38:16 <Araneidae> I have two versions of a package, one installed by cabal, the other a local development copy.  How do I persuade ghc to look at the local copy instead?
07:38:52 <ManateeLazyCat> dcoutts: If i use Named-Pipe, i can use Binary to pack and unpack data for communication, but i can't use Binary with Gtk+ object, and i can't write Pointer address of Widget in Pipe.
07:38:54 <dcoutts> Araneidae: it will look at local sources first if they're on the search path
07:39:04 <dcoutts> Araneidae: alternatively -hide-package blah
07:39:16 <Araneidae> ooh: that sounds useful!
07:39:58 <ManateeLazyCat> dcoutts: http://www.gtk.org/api/2.6/gtk/PlugSocket.html
07:40:00 <dmwit> Using two different processes to update the same GUI widgets sounds like a bad idea.
07:40:13 <dcoutts> ManateeLazyCat: right, exactly, and that's bound in gtk2hs
07:40:29 <ManateeLazyCat> dcoutts: Thanks a lot. I research it. :)
07:40:36 <tibbe> waern: do you know why the HTML library produces tags with line breaks before the closing >?
07:40:55 <dcoutts> tibbe: it's by design I believe
07:41:01 <tibbe> dcoutts: ugh
07:41:08 <dcoutts> tibbe: it's perfectly legal
07:41:21 <tibbe> dcoutts: sure, it also perfectly unreadable
07:41:24 <mmmdonuts> tibbe: it's to avoid whitespace from having an effect on the content.
07:41:28 <tibbe> dcoutts: and wastes on char per tag
07:41:39 <tibbe> mmmdonuts: how come?
07:41:44 <dcoutts> right, as mmmdonuts says
07:41:55 <dcoutts> otherwise you have to put whitespace in the html content
07:42:05 <dcoutts> to make tags align
07:42:16 <dcoutts> to reflect the nesting
07:42:23 <tibbe> ??
07:42:38 <tibbe> what do you mean by making tags align?
07:43:38 <Twey> tibbe: In some places, whitespace is significant in tags, which means that formatting it nicely changes the content
07:43:42 <dcoutts> oh, nm, it doesn't actually do that
07:43:56 <Twey> The style the HTML library uses is designed to allow some formatting without doing that
07:44:13 <Twey> You can get the ‘normal’ style using the prettyPrint function
07:44:19 <Twey> (but it's recommended you don't use that in production code)
07:44:20 <tibbe> Twey: do you have an example?
07:44:32 <Twey> tibbe: I had one on my site.  I'll pastebin.
07:44:42 <tibbe> Twey: thanks
07:47:27 <Twey> tibbe: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4947#a4947
07:48:11 <tibbe> Twey: ah yes, extra space inside the tags is not fine
07:48:31 <tibbe> Twey: I think the formatter should be smarter in this case and not format with space when there are text child nodes
07:48:37 <Twey> Well… ‘inside tags’ is iffy terminology in HTML, of course ☺
07:48:54 <Twey> tibbe: But space constitutes a text child node, in some cases
07:49:00 <tibbe> Twey: indeed, although since the library is generating the HTML it can make sure to close all tags
07:49:06 <tibbe> Twey: yes
07:49:07 <ksf> oh, the joy of off-by-one.
07:49:18 <Twey> Yes, it could be smarter, but there's really no point
07:49:27 <ksf> especially if you hid something like 3 of thonse in three lines.
07:49:46 <Twey> Use prettyPrint for debugging, and just crunch whitespace for production
07:49:59 <Twey> If someone wants to view the code, they can run their own pretty-printer over it
07:51:06 <tibbe> waern: do you think it would be worth to (in a separate change) use a Reader monad for the unicode parameter?
07:51:32 <tibbe> Twey: it inserts one space too much for production
07:51:37 <tibbe> Twey: before the >
07:51:46 <tibbe> Twey: that's inside the tag
07:52:07 <waern> tibbe: yes. And perhaps for other parameters as well
07:52:08 <ksf> there's some html printer that always writes \n><tag
07:52:15 <ksf> _that's_ insane.
07:52:17 <tibbe> waern: right, for all global config
07:53:40 <Twey> tibbe: That's why I said ‘inside tags’ is iffy terminology.  Spacing <tag>here</tag> is a problem, but spacing <tag here></tag> is not.
07:54:23 <tibbe> Twey: right
07:54:37 <ksf> back in the days there were html compressors that stripped all unnesseccary whitespace
07:55:07 <ksf> ...all that's not semantically meaningfull, that is.
07:55:46 <ksf> those aren't related to those processors that fix html by deleting all &nbsp;s .
07:57:01 <ksf> I bet those frontpage developers never looked at the html they produces, just at the finished render.
07:57:18 <Twey> Likely
07:57:31 <Zao> ksf: What is this HTML you speak of? WYSIWYG!
07:58:00 <maartenm> hey, I'm very new to Erlang
07:58:10 <maartenm> eh, lemme do a pastie first
07:58:18 <maartenm> oops
07:58:20 <maartenm> wrong channel
07:58:35 <mathijs> or wrong language :P
07:58:35 <ksf> that was a freudian mistake.
07:58:37 <Twey> Heh
07:58:42 <ksf> you actually wanted to switch to haskell.
08:00:43 <maartenm> maybe once you guys finish distributed haskell :)
08:01:25 <ksf> you can write erlang nodes with haskell just fine
08:03:58 <fluxxen> Axman6 are you still there?
08:06:51 <maartenm> ksf : I know, learning erlang to do just that
08:13:07 <fluxxen> how could I do like for example [1..10] but in a custom list. what is it that .. does?
08:13:33 <BONUS> [1..10] is sugar for enumFromTo 1 10
08:13:47 <fluxxen> hm ok
08:13:52 <BONUS> > enumFromTo False True
08:13:53 <lambdabot>   [False,True]
08:14:27 <mathijs> in a custom list you can use this:
08:14:28 <mathijs> > take 10 $ iterate (+1) 1
08:14:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:14:33 <nlogax> > enumFromTo LT GT
08:14:35 <lambdabot>   [LT,EQ,GT]
08:14:40 <nlogax> heh
08:14:59 <fluxxen> BONUS can you give me any hints if I want a custom list for a custom type of ex Card which is "Card (Numeric 2) Suit) for example Card (Numeric 2) Spades and I want to add them so that I get it for 2..10
08:15:18 <fluxxen> mathijs hm ok
08:15:25 <mmx166mhz> hmm, well: I have an arbitrary list of characters( which are all numbers), and I want to make [Integer] of it
08:15:59 <mmx166mhz> Compare it to the (int) thing(typecasting) in Java
08:16:26 <fluxxen> mathijs could you simplify that? seems right but don't quite understand it
08:17:14 <mmx166mhz> no one has an idea?
08:17:24 <BONUS> fluxxen: if i understand you correctly, you'll have to define an Enum instance for your type
08:17:32 <nlogax> > digitToInt '7'
08:17:34 <lambdabot>   7
08:17:38 <BONUS> @src Enum
08:17:39 <lambdabot> class  Enum a   where
08:17:39 <lambdabot>     succ                     :: a -> a
08:17:39 <lambdabot>     pred                     :: a -> a
08:17:39 <lambdabot>     toEnum                   :: Int -> a
08:17:39 <lambdabot>     fromEnum                 :: a -> Int
08:17:41 <lambdabot> [3 @more lines]
08:17:56 <mmx166mhz> thanks, lets try out
08:18:07 <mathijs> fluxxen: iterate takes a function and a start value and returns a list starting with the start value, applying the function to the result for every next element.
08:18:38 <BONUS> to make it a part of enum, you have to define toEnum and fromEnum for that
08:18:43 <nlogax> mmx166mhz: if it's what you needed, it may be the first time i managed to help someone in here!
08:19:02 <mmx166mhz> well, I am trying to let it work for LISTS of chars
08:19:13 <mathijs> fluxxen: so you need to have a function that goes from Numeric 1 to Numeric 2 up to Numeric 9 to Jack
08:19:13 <mmx166mhz> sort of map I guess?
08:19:30 <nlogax> > map digitToInt "12432"
08:19:33 <lambdabot>   [1,2,4,3,2]
08:19:37 <mmx166mhz> aha ;)
08:20:49 <nlogax> > let digitsToInts = map digitToInt in digitsToInts "1798"
08:20:51 <lambdabot>   [1,7,9,8]
08:20:53 <nlogax> :)
08:20:54 <fluxxen> mathijs hm it doesn't mention that I should do something like that. is it any way I could solve it with using Gen?
08:21:10 <fluxxen> mathijs or something with instructions like do ... ? because they mention that
08:22:42 <mathijs> fluxxen: don't know about Gen. do ... notation also doesn't seem to apply here. You either have to create your own iteration function, or define toEnum and fromEnum like BONUS tells.
08:24:11 <qff> hi, anyone running Snow Leopard?
08:25:12 <mmx166mhz> digitToInt is out of scope, GHCi keeps complaining. What am I doing wrong?
08:25:45 <Saizan> ?index digitToInt
08:25:46 <lambdabot> Data.Char
08:25:50 <ksf> passing in functions that do a lookop on a hardwired structure vs. passing in the structures slows my code by a factor of 2
08:25:55 <Saizan> mmx166mhz: you need to import Data.Char
08:26:15 <mmx166mhz> ok, never done that: What do I have to type to import it?
08:26:21 <burp> o0
08:26:24 <IceDane> :module Data.Char
08:26:26 <mmx166mhz> ok
08:26:34 <IceDane> or "import Data.Char" in your source file
08:26:46 <burp> or just import Data.Char in ghci
08:26:56 <mmx166mhz> thanks. I know I am a n00b, but I really wanna master it;)
08:26:57 <Saizan> "import Data.Char" works even at the prompt of ghci, if you've a recent enough version
08:26:58 <ksf> ...I wouldn't mind, but I really need different lookup algos because for n == 4, log n == n/2 which means that binary search is just too bleeding expensive
08:27:03 <IceDane> oh
08:27:05 <IceDane> I didn't konw that
08:27:59 <fluxxen> BONUS ok thanks
08:28:03 <IceDane> How would one define a datatype that's supposed to accept a triplet of tuples of floating point numbers? E.g., a triplet of 2D coordinates
08:28:22 <mmx166mhz> triplet of 3d coords?
08:28:26 <IceDane> Yea
08:28:30 <ksf> (Foo,Foo,Foo)
08:28:35 <IceDane> eh, 2d coords
08:28:38 <ksf> where Foo is your vector type
08:28:52 <mmx166mhz> why would you need triplet for 2d?
08:29:04 <IceDane> mmx166mhz: It's 3 x (x,y)
08:29:04 <ksf> there's some cool vector libraries on hackage, from sophisticated to pure math overkill.
08:29:10 <mmx166mhz> ok ok
08:29:46 <IceDane> ksf: Thanks - I'm trying "data Direction ((a, a), (a, a), (a, a)) .. etc", but it's failing with "Type found where type variable expected"
08:29:57 <IceDane> I'm not sure how I tell the datatype only to
08:30:04 <IceDane> to 'accept' floating point numbers either
08:30:14 <Saizan> IceDane: you want "data Direction a = Dir (a,a) (a,a) (a,a)"
08:30:14 <ksf> it's spelled data Foo = MkFoo Integer
08:30:16 <burp> data Direction a = 
08:30:34 <ksf> Saizan, tuples inside a data declaration?
08:30:38 <Saizan> IceDane: and the Floating requirement will go on your functions
08:30:49 <IceDane> Saizan: Ah, alright.
08:30:55 <Saizan> ksf: too ugly?
08:31:07 <ksf> the other possibility is type Foo a = ((a,a),(a,a))
08:31:29 * ksf doesn't use tuples at all except to return stuff from function.
08:31:49 <IceDane> This is an exercise in RWH
08:32:06 <IceDane> But thanks guise, this worked
08:32:37 <Saizan> the point is that on the left of the "=" you list only the type variables, not the types of the fields
08:32:52 <IceDane> Yeah, that made sense once you showed me how
08:33:06 * ksf recommends http://hackage.haskell.org/package/Vec-0.9.6
08:34:13 * burp recommends hmatrix vector and uvector
08:34:35 <burp> all depends on what you want and need
08:36:49 <Araneidae> How do I quickly search for a library identifier?  Using http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html locks up for minutes at a time when I try it!
08:36:50 <ksf> this is insanity. There I am, sucessfully coding faster code for parts of the program, and then I'm getting 2 to 4x slowdowns due to passing it in.
08:37:20 <ksf> @where hoogle
08:37:20 <lambdabot> http://haskell.org/hoogle
08:37:24 <ksf> @where hayoo
08:37:25 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:37:46 <Araneidae> hoogle!  Sweet
08:38:17 <ksf> alternatively you could write a javascript engine in haskell that's faster than your browser's
08:39:26 <Araneidae> Hum.  But hoogle has never heard of Terminfo, and I have the following code in front of me: import System.Console.Terminfo
08:40:11 <ksf> http://www.google.de/search?q=hackage+terminfo
08:40:36 <Araneidae> Alas.  So the only way to search hackage is google?
08:40:44 <ksf> yep
08:40:56 <ksf> well, not the only one
08:41:02 <Araneidae> Sigh.  Such a lot of joining up needed in Haskell :(
08:41:21 <ksf> hoogle has a strange policy of what gets included in the index
08:41:47 <Araneidae> Not the language, not even the libraries as such, but the whole development environment is ... just a bit chaotic.  (Hey, what's new?)
08:42:25 <ksf> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:System.Console.Terminfo   has a lot of decent results
08:42:58 <ksf> that systax doesn't work.
08:43:49 <Araneidae> Well, that's odd.  The line I'm looking at really says "import qualified System.Console.Terminfo as Terminfo" ... and that doesn't seem to exist in the documentation
08:44:09 <Araneidae> "Read the source, Luke"
08:44:58 <ksf> sure the module exists
08:45:01 <ksf> docs, too.
08:45:26 <ksf> it reexports a couple of other modules
08:45:44 <Araneidae> Yes, think I was misunderstanding some things
08:46:00 <Araneidae> But the reexports make the documentation a bit confused
08:46:37 <Araneidae> For example, System.Console.Terminfo.Base.Terminal is also System.Console.Terminfo.Terminal, but hackage denies that
08:47:44 <tibbe> waern: I noticed that topDeclBox also includes a wiki link. I never remember seeing such a link in any package. Is that ever used?
08:48:21 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12176#a12176
08:48:39 <ksf> #haskell, your task is to replace choose with choose for iubs but not homs.
08:48:47 <ksf> ...without making the program slower.
08:48:51 <ksf> go!
08:49:02 <ksf> er choose' , the second one.
08:49:56 <ksf> using binary search for both is just a little bit slower than linear for both, so there should be a decent speedup if it's just used in the n = 15 case.
08:51:15 <ksf> I should compile the code next time before I post.
08:53:00 <ksf> fixed
08:55:03 <IceDane> The > and < operators for tuples - how are they defined?
08:55:14 <Heffalump> lexicogaphically
08:55:27 <Heffalump> i.e. the second elements are compared only if the first compare equal
08:56:37 <IceDane> so in the case of comparing (2, 2) > (1, 2), it basically comes down to (2 > 1 && 2 > 2) ?
08:56:44 <IceDane> or am I misunderstanding something?
08:57:05 <burp> it's or
08:57:22 <Philonous> more like (2>1) || (2==1 && 2>2 )
08:57:37 <IceDane> ah..
08:57:37 <IceDane> huh
08:57:56 <ksf> using compare, though.
08:58:03 <ksf> > 1 `compare` 2
08:58:04 <lambdabot>   LT
08:58:08 <ksf> > 1 `compare` 1
08:58:10 <lambdabot>   EQ
09:00:43 <luite> how do I find out the proper alignment, in an instance of Storable, using hsc2hs?
09:01:14 <ksf> there's C macros that can do that
09:01:28 <ksf> but I don't thing its the Right Way to do that.
09:01:45 * hackagebot upload: bindings-gsl 0.1.1.6 - Low level bindings to GNU GSL. (MauricioAntunes)
09:02:02 <IceDane> ?index rand
09:02:03 <lambdabot> Test.QuickCheck, Debug.QuickCheck
09:02:07 <IceDane> ?index Random
09:02:07 <lambdabot> System.Random
09:02:12 <IceDane> woop
09:04:02 <ksf> guys, I have a runtime difference of a mere 2.75% between the linear search and the binary search version. there's gotta be some way to get faster by using binary search for half of the data.
09:04:02 <luite> ksf: I found two different things, one is #{const __alignof__(type)}, and the other probably is the macro you are talking about
09:04:22 <ksf> no that looks like the macro
09:04:53 <luite> oh I don't think that's a macro but a gcc special constant
09:04:57 <ksf> ...most of that 2.75% are acually jitter.
09:05:15 <ksf> macro, __buitin_alignof, where's the difference
09:09:49 * hackagebot upload: XMPP 0.1.1 - XMPP library (OlegIvanov)
09:09:51 * hackagebot upload: matsuri 0.0.3 - ncurses XMPP client (OlegIvanov)
09:11:56 <mmx166mhz> Pff, I am still not any further in my way of understanding cabal thingies: Though: Now I understand that IF I manage to install cabal, installing wx is very easy.
09:12:46 <profmakx> whohoo
09:12:52 <profmakx> *matsuritest*
09:13:20 <mmx166mhz> http://www.haskell.org/haskellwiki/Cabal-Install
09:13:35 <mmx166mhz> I have downloaded the cabal.exe but nothing happens if I run it: No matter where I place it
09:14:29 <burp> how do you run it? -.-
09:14:36 <burp> doubleclicking it?
09:14:59 <mmx166mhz> yes
09:15:07 <burp> um
09:15:17 <mmx166mhz> Yeaah, I know I am a n00b -_-, but please I wanna learn it :((
09:15:53 <ben> mmx166mhz: commandline
09:16:05 <mmx166mhz> yes
09:16:17 <mmx166mhz> I tried it: it still says the same though
09:16:27 <ben> Well, what?
09:16:30 <mmx166mhz> " no command given"
09:16:38 <ben> try --help
09:16:43 <ben> cabal --help
09:16:45 <mmx166mhz> yes ;) that one too
09:17:09 <ben> No, that lists the commands.
09:17:21 <mmx166mhz> I see
09:17:35 <mmx166mhz> I see the list of command. The question  is: How can I let cabal work?:)
09:17:42 <kane77> can I define functions while in interactive mode in ghc/hugs? how?
09:17:51 <ben> mmx166mhz: Use cabal in conjunction with one of the commands.
09:18:23 <mmx166mhz> Oh ..:) It works now actually
09:18:44 <mmx166mhz> ThanKS A LOT!
09:19:48 <mmx166mhz> Hmm, It doesnt work still :P. SOme permission denied issues he reports..
09:20:40 <ksf> the first thing you need to do is "cabal update"
09:20:44 <mmx166mhz> I did that
09:20:47 <mmx166mhz> that worked
09:21:11 <mmx166mhz> then I did " cabal install wx", which worked , till it said: sth failed due to permission issies
09:21:38 <ben> Well, fix the issues.
09:21:49 <MoALTz> i'm not enjoying haskell IO. seems like a nightmare just to transform lots of IO Char into IO [Char]... let alone grab input from 2 different handles (stdin and a handle to an network connection)
09:21:55 <mmx166mhz> some create directory thingie didnt get done as permission was denied. SOme ideas how to get rid of this permission things?
09:22:05 <stroan> mmx166mhz: this on windows or linux?
09:22:08 <mmx166mhz> win
09:22:25 <stroan> run the command line as administrator and run the command again?
09:22:29 <mmx166mhz> ok
09:23:00 <Cale> MoALTz: do you understand do-notation?
09:23:31 <Cale> MoALTz: There are lots of useful functions for piecing together IO programs in Control.Monad
09:24:04 <stroan> MoALTz: lots of examples of such functions in RealWorldHaskell
09:24:18 <Cale> :t replicateM 10 getChar
09:24:20 <lambdabot> IO [Char]
09:24:46 <MoALTz> i see
09:24:52 <ksf> Cale, you're one of those performance wizards, aren't you?
09:24:54 <MoALTz> ok, i'll keep at it (using Control.Monad)
09:25:28 <Cale> ksf: Well, not as much as some people, but I have a good rough idea about what will perform well and what won't (and usually why)
09:25:41 <ksf> well, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12181#a12181
09:25:48 <Cale> MoALTz: If there's a specific thing that you'd like to know how to do, just ask
09:26:03 <ksf> the task is to use choose with homs and choose' with iubs' without degrading performance.
09:26:15 <Cale> MoALTz: Also, don't repeat yourself: if there's some sort of pattern showing up in the code you're writing, see if you can turn it into a function.
09:26:25 <MoALTz> *nod*
09:26:28 <ksf> ...as for n = 4, log n == n/2 and thus linear search is faster
09:26:47 <Cale> MoALTz: The nice thing about first class IO values is that you can write functions which act like whatever control structures you need
09:27:06 <Cale> hmm
09:27:24 <Cale> Oh, jeez, fasta stuff
09:27:35 <ksf> and it's already fas0red
09:27:41 <ksf> but there's slack left
09:27:54 * hackagebot upload: hesql 0.3 - Haskell's embedded SQL (ChristophBauer)
09:28:42 <ksf> ...the next step would be to write some TH to unroll that binary search, so there's no pivot etc. calculations
09:30:39 <ksf> uh. actually, I could've implemented the search as a binary tree.
09:30:48 <Cale> perhaps :)
09:31:13 <ksf> and thus wouldn't have had to debug a function containing 4 off by one errors in 3 lines.
09:31:16 <Cale> Though this is already at the level where you're probably into looking at the core to figure out what's going to work better.
09:31:42 <ksf> mostly to check whether stuff is unboxed
09:34:11 <ksf> yep, building a balanced binary tree for both lists means that the same code works for both, and there's no index calculation overhead, at all.
09:40:41 <mmx166mhz> My problem is (still) not resolved, though I am quite far now: I installed cabal, did cabal update, but got the following error when trying to cabal install wx: The exception was: exit: exitfailure 1
09:41:38 <ksf> what's the error before that?
09:41:57 <mmx166mhz> (wait a few moments, I copy paste the whole thing:)
09:44:35 <mmx166mhz> http://www.students.science.uu.nl/~3345629/error.jpg
09:44:46 <joga> u
09:44:49 <joga> oops..
09:44:59 <mmx166mhz> ?
09:45:19 <joga> (just accidentally hit a key) :)
09:45:22 <ksf> you don't seem to have wx installed
09:45:35 <mmx166mhz> Well: I am TRYING to install wx using cabal
09:45:37 <ksf> ...at least cabal can't locate the config program it ships with
09:45:51 <ksf> you still need the underlying C library
09:46:12 <mmx166mhz> Ok, so if I install that too, THEN cabal install wx SHOULD work?
09:50:12 <mmx166mhz> Hello?
09:50:36 <mmx166mhz> Anyone an idea how I can resolve these issues?
09:51:43 <mmx166mhz> ?
10:01:46 --- mode: irc.freenode.net set +o ChanServ
10:01:46 --- mode: irc.freenode.net set +v lambdabot
10:01:46 --- mode: irc.freenode.net set +v preflex
10:01:46 --- mode: irc.freenode.net set +v lunabot
10:03:33 <mmx166mhz> Whats happening?
10:03:40 <Twey> mmx166mhz: Pain
10:03:40 <yitz> this is how freenode deals with certain security issues. it will all end soon.
10:04:07 <Twey> What security issues are those?
10:04:08 <yitz> don't remember, someone explained it once
10:04:14 <yitz> DOS attack or something like that
10:04:22 <Twey> Huh.
10:06:16 <mmx166mhz> Okay, at least I am not the only one who got this.
10:07:54 <stroan> mmx166mhz: still getting the wx-config runGenProcess error?
10:07:59 <mmx166mhz> yes:(
10:08:08 <stroan> you've installed wxWidgets yeah?
10:08:14 <mmx166mhz> uhmm, nope.
10:08:25 <mmx166mhz> just cabal install wxWidgets or..?
10:08:46 <stroan> I've only installed it on linux, but it seems to me like you need to have wxWidgets install first and then install wxHaskell
10:09:00 <mmx166mhz> Ok.. lets look
10:09:16 <stroan> and then make sure the folder wx-config is in is in your path
10:09:36 <mmx166mhz> ok
10:09:59 <mmx166mhz> btw: I get several "paths" when I request what my path is..
10:10:19 <stroan> yeah, path is a list of paths that the system checks for programs/libraries in.
10:10:27 <mmx166mhz> aha, ok
10:12:03 <Rayne> i want to execute two functions from a lib, my idea so far: http://pastie.org/private/h2zskn4nckbjpltuzhfaxw
10:12:21 <stroan> you you can set the path temporarilly using: set PATH=%PATH%;c:\whereveryouwant
10:12:51 <Saizan> mmx166mhz: also, http://haskell.org/haskellwiki/WxHaskell/Building
10:12:51 <stroan> so that'll add the new directory to the end of your path for the current session
10:13:11 <profmakx> gotta patch the haskell xmpp lib :/
10:13:41 <mmx166mhz> Well: I did wxWidgets, then did cabal install wx getting the same error message.
10:13:56 <stroan> mmx166mhz: look at the link Saizan just posted
10:14:14 <stroan> you did need to install wxWidgets
10:14:20 <stroan> but there's another dependency as well
10:14:27 <stroan> at least one
10:15:17 <mmx166mhz> hmm, still confused: I installed wxWidgets, but upon doing cabal install wx still get the same error message
10:15:47 <stroan> http://haskell.org/haskellwiki/WxHaskell/Building#Prerequisites
10:15:50 <stroan> do you have everything there?
10:16:29 <mmx166mhz> No. ( will be back after doing those..)
10:20:51 <mmx166mhz> I have to admit that the whole thing of cabal etc is very frustrating, while haskell itself is a very natural and intuitive language..
10:21:03 <mmx166mhz> I realize how n00b I am..
10:21:11 <stroan> most packages don't have all this trouble
10:21:41 <mmx166mhz> minGW is getting installed at this time.
10:21:58 <mmx166mhz> What is it good for actually? ( all those things which are supposedly prerequisite)
10:22:18 <stroan> what is what good for?
10:22:20 <stroan> cabal?
10:22:25 <mmx166mhz> no, mingw
10:22:39 <stroan> it's just a windows c/c++ compiler
10:24:29 <ksf> mmx166mhz, it's not cabal that's frustrating, it's windoze that's frustrating.
10:25:06 <ksf> the first thing to do should be to install cygwin, as then it can at least pretend to be a unix
10:26:31 <mmx166mhz> STILL :((( same error
10:26:44 <luite> hm, most things use MSYS instead of cygwin
10:27:09 <mmx166mhz> I installed MSYS, minGW and WXWidgets, but still
10:27:21 <luite> mmx166mhz: installing dependencies on windows is quite frustrating
10:27:35 <dcoutts> mmx166mhz: it still says it cannot find wx-config?
10:27:35 <luite> it took me more than a day to compile gtk2hs
10:27:41 <mmx166mhz> yes dcoutts
10:27:49 <dcoutts> then it's not on your %PATH%
10:27:50 <stroan> mmx166mhz: did you put wx-config on your path?
10:28:11 <stroan> also "We assume in this guide that the variable $wxwin points to your wxWidgets installation directory, for example: ~/dev/wxGTK-2.8.10. "
10:28:28 <p_l> maybe someone needs to finish Gentoo/NT
10:28:48 <mmx166mhz> How am I supposed to put " wx-config" on my path? Do I have to download wx-config manually? Doesn'y everything related to wx supposed to be get installed by the single line cabal install wx?
10:29:06 <luite> mmx166mhz: only the haskell things get installed by cabal install
10:29:11 <luite> external dependencies don't
10:29:12 <mmx166mhz> hmm, ok
10:31:01 <luite> mmx166mhz: I think you shouldn't need a full mingw installation in c:\mingw. ghc 6.12 at least has a mingw directory, if you extract g++ (binaries, libraries and includes) into that directory, and add the mingw\bin directory to your path, you can compile the dependencies with that
10:31:22 <luite> a c:\mingw installation may interfere with your gcc used by ghc, especially if it's a different version
10:31:26 <luite> ghc uses 3.4.5
10:32:59 <luite> (you can have a separate gcc 4.4 mingw installed of course, but some paths seem to be hardcoded, so you'd better install it in another location, and make sure that it is not in your path when you compile haskell related things)
10:34:54 <PeakerWork> First actual use of "hawk", I reverse the lines in a file
10:35:27 <mmx166mhz> Aaargh, I am immensely frustrated by all this crap; lets pause for some moment... thanks all
10:36:15 <PeakerWork> I wonder if there's a simpler unix way.. my way is: ... | hawk il reverse | ...  (il = inLines, apply a function to the list of lines)
10:36:55 <PeakerWork> I also have ol (onLines, apply a function to each line, ol=il.map), ow,iw, olw,ilw, etc.. seems so useful (1 actual use on the first day..)
10:39:42 <PeakerWork> print the 5th word of each line: aux|hawk 'ol.iw $ r.(!!5)'
10:39:56 <PeakerWork> (onLines . inWords) (return . (!!5))
10:40:03 <PeakerWork> I love the hawk :-)
10:40:29 <PeakerWork> does take me a couple more seconds to formulate it, though, but it'll probably grow faster when I get used to it
10:40:43 <IceDane> How would you normally create patterns for a function to match only if the list passed to it is 3 elements or more? Pattern guards?
10:40:48 <PeakerWork> than:  awk '{print $5}'  (which is kind of limited to ol functions)
10:40:58 <koeien> f (x:y:z:xs) -- IceDane
10:41:06 <IceDane> Yeah, that's the one of them
10:41:10 <IceDane> but to handle the egde cases
10:41:13 <IceDane> it's a recursive function
10:41:21 <aavogt> then define another equation
10:41:22 <medfly> have a thing for [x,y,z] maybe?
10:41:28 <koeien> f [], f [x], f [x,y]
10:41:31 <IceDane> Oh, duh, that works as well
10:41:35 <medfly> er
10:41:38 <medfly> [x,y] :)
10:41:39 <IceDane> thanks =)
10:41:47 <PeakerWork> IceDane: what does the recursion do?
10:43:38 <IceDane> PeakerWork: I forgot you could do [x]/[x,y], etc, but it basically looks like this: f (x:y:z:xs) = ... : f (y:z:xs)
10:43:57 <PeakerWork> IceDane: I see, but what is it for?
10:44:07 <IceDane> Ah, it's an exercise in RWH
10:44:10 <mathijs> For a network server (tcp, persistent 2-way connection), I'm using forkIO to handle the client-communication. Does this mean an extra thread is created for every client? A while back, I found a slightly older example that just kept a list of handles and returned the one that had data available (no threads/forking involved) but I lost it. Does anyone know what I mean?
10:44:13 <IceDane> Hard to explain, really
10:44:45 <IceDane> PeakerWork: http://icedane.pastebin.com/m388728dc
10:44:50 <IceDane> basically the third
10:44:51 <koeien> mathijs: sounds like the C select() call
10:44:53 <IceDane> (12)
10:45:06 <mathijs> koeien: I think that was used indeed
10:45:46 <Jedai> mathijs: Note that Haskell threads are extremely lightweight, you may be better off using forkIO even for heavy load
10:45:50 <koeien> IceDane: i think a nicer approach is to do    map f $  zip3 xs (tail xs) (tail (tail xs))
10:46:14 <IceDane> koeien: I was wondering if I could use map on this somehow
10:46:24 <int-e> mathijs: it means an extra RTS thread is created. That's rather cheap. if you block on IO in mutliple threads that will become a select call internally. (or are we using epoll etc now?)
10:46:29 <mathijs> Jedai: so there is no real overhead in having 1 haskell thread per client?
10:46:30 <koeien> IceDane: where f is your function (Pt,Pt,Pt)->Direction
10:46:49 <IceDane> zip3 does what, exactly? zips 3 elements together?
10:46:58 <koeien> > zip3 [1,2,3] [4,5,6] [7,8,9]
10:46:58 <PeakerWork> @type zip3
10:46:59 <lambdabot>   [(1,4,7),(2,5,8),(3,6,9)]
10:46:59 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
10:47:10 <PeakerWork> @type zip . zip
10:47:11 <lambdabot>     Couldn't match expected type `[a]'
10:47:11 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
10:47:11 <lambdabot>     Probable cause: `zip' is applied to too few arguments
10:47:28 <IceDane> yeah
10:47:30 <IceDane> that would work
10:47:33 <IceDane> cool, thanks =(
10:47:35 <IceDane> =)*
10:47:51 <mathijs> int-e: well, most clients are just doing nothing, waiting for the server to tell them about changes that might interest them. I think it can easily become a couple 100s/1000s of clients. so forkIO is still the best option?
10:47:52 <Jedai> mathijs: Probably not enough to make it worthy to use a select instead, even on one core, and of course on a multicore a thread based solution scale naturally whereas a select() method soon becomes complicated
10:47:54 <PeakerWork> @type ((.) . (.)) zip . zip
10:47:55 <lambdabot>     Couldn't match expected type `[a]' against inferred type `(a1, b)'
10:47:56 <lambdabot>       Expected type: [a1] -> [b] -> [[a]]
10:47:56 <lambdabot>       Inferred type: [a1] -> [b] -> [(a1, b)]
10:48:14 <PeakerWork> @type (zip.) . zip
10:48:15 <IceDane> By the way - what is an easy way to generate a test set of numbers for this stuff? Just random or something?
10:48:15 <lambdabot> forall b a b1. [a] -> [b1] -> [b] -> [((a, b1), b)]
10:48:19 <mathijs> Jedai: ok cool, I'll stick with forkIO then
10:48:24 <PeakerWork> If Haskell didn't haveN-tuples, you wouldn't need *3 functions
10:48:27 <koeien> IceDane: check out QuickCheck! :)
10:48:39 <IceDane> oooh
10:48:41 <koeien> IceDane: it is also explained in RWH, maybe you haven't seen it yet
10:48:43 <IceDane> is that a test suite?
10:48:44 <koeien> very cool stuff
10:48:48 <IceDane> or soemthing like that
10:49:00 <Jedai> mathijs: If you have a couple of 1000s of threads it should probably be ok (keep in mind that GHC is ever evolving and that especially on concurrency performances GHC 6.12 is better)
10:49:04 <koeien> IceDane: it can generate test cases for you, to check properties that you write
10:49:11 <IceDane> ah
10:49:12 <IceDane> sweet
10:49:34 <IceDane> ah, well, I'm a few chapters away
10:49:39 <koeien> good
10:49:45 <koeien> for now i'd stick to a few manual tests, then
10:49:49 <IceDane> Yeah
10:49:58 <int-e> mathijs: the number of open FDs may become an issue. But you'd have that problem as well if doing things manually.
10:50:02 <IceDane> Heh, I tried skipping a bit, but haskell wasn't merciful
10:50:16 <koeien> @faq Can Haskell be merciful?
10:50:16 <lambdabot> The answer is: Yes! Haskell can do that.
10:50:25 <IceDane> haha
10:50:48 <IceDane> @faq What is the answer to life, the universe and everything?
10:50:48 <lambdabot> The answer is: Yes! Haskell can do that.
10:50:52 <IceDane> oh
10:50:55 <IceDane> Ah well.
10:51:11 <IceDane> Is this bot written in haskell?
10:51:18 <koeien> yes
10:51:27 <IceDane> Shit.
10:51:41 <aavogt> @version
10:51:42 <lambdabot> lambdabot 4.2.2.1
10:51:42 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:52:58 <profmakx> when will we have dynamic linking? or do we already have it?
10:54:02 <burp> 6.12
10:54:46 <null_ptr> he. An newbie question. I have defined my own bool data type "data Boool = Yes | No". Now I want to write my own function to implement ==, /= and so forth. How can I do that?
10:55:09 <koeien> Haskell can do == and /= automatically!
10:55:15 <mauke> koeien: but not with Boool
10:55:32 <mauke> null_ptr: what's the point?
10:55:38 <int-e> eh, do you want Boool -> Boool -> Bool or a -> a -> Boool?
10:55:54 <null_ptr> Boool -> Boool -> Bool
10:55:57 <koeien> mauke: aw, result type is not Boool
10:55:58 <mauke> oh
10:56:04 <koeien> null_ptr: then add 'deriving (Eq)'
10:56:09 <int-e> that's easy. define an Eq instance (or let Haskell derive it)
10:56:12 <rasterfar> profmakx: I think you have to build GHC with --enable-shared?  I haven't tried it though.  http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport?redirectedfrom=DynamicLinking
10:56:15 <burp> @hoogle Boool
10:56:15 <lambdabot> No results found
10:56:39 <Saizan> or, instance Eq Boool where x == y = ..
11:00:44 <Araneidae> How do I do simple mixed arithmetic in Haskell: given a::Int, b::Double want a+b ?
11:01:05 <Draconx> fromIntegral a
11:01:07 <Draconx> + b
11:01:11 <Araneidae> cheers
11:01:11 <koeien> > (fromIntegral 1 :: Double) + (27::Double)
11:01:12 <lambdabot>   28.0
11:01:24 <Araneidae> Knew I needed a promotion of some kind somewhere
11:02:15 <IceDane> Out of curiosity - do many of you guys have background in mathematics? By that I obviously mean "studying mathematics on an academic level" or something
11:02:23 <IceDane> not just high school math, heh
11:02:26 <skorpan> i invented category theory
11:02:37 <skorpan> Cale just formalized it
11:02:39 <Araneidae> skorpan, you must be dead then :)
11:02:42 <IceDane> lol
11:02:59 <Araneidae> Think Mac Lane died a while ago now
11:03:57 <koeien> IceDane: i am doing an MSc in math right now
11:04:31 <Araneidae> I did a PhD in Type Theory; guess that counts as maths
11:04:42 <medfly> IceDane, you can stick around and watch fancy maths conversations
11:04:49 <medfly> IceDane, (also, Cale studied mathematics).
11:04:53 <IceDane> I see
11:06:30 <medfly> I think that studying Haskell counts as studying mathematics on an academic level in a way
11:06:46 <koeien> CS is just applied maths anyway ;)
11:06:52 <medfly> right
11:07:25 <Araneidae> Oops.  My code now says: "toReal y" is 1.0, but "toReal (y + y)" is 0.5.  Something not quite right there...
11:07:56 <ksf> maths is just abstract CS anyway
11:08:07 <IceDane> Heh
11:08:29 <IceDane> I thought I was so sure where i'd end up
11:08:30 <Araneidae> That's better
11:09:30 <IceDane> But there are way too many awesome things that relate to mathematics/computer science and digital electronics to choose between
11:09:46 <IceDane> Take one route and I'll feel I don't get enough of the stuff I'd get going down another path
11:10:00 * ksf suggests game programming
11:10:07 <IceDane> Why?
11:10:26 <ksf> it's the bleeding edge of CS, and you have different disciplines to choose from, but all concrete ones.
11:11:29 <ksf> it also teaches you that copperfield's conjecture is true.
11:11:44 <ksf> It postulates that all percievable things are fakeable.
11:11:54 <IceDane> Thing is, I'm not sure whether I want to go the computer science(Theory-focused, if you will) route, or a combination of CS and didital electronics that might leave me with a bit of everything but not enough of anything, heh
11:13:18 <ksf> let's see... applied topology: http://theory.stanford.edu/~amitp/GameProgramming/
11:13:55 <BONUS> lol
11:14:00 <BONUS> the wx guy just sent me an email
11:14:13 <BONUS> asking to please write a lyah chapter that solves his problem
11:14:43 <medfly> hehe
11:14:43 <null_ptr> thx. Think I found my mistake.
11:15:29 <ksf> and a more obscure corner of ai: http://books.google.de/books?id=vIkhA9zuvSUC&pg=PA210&lpg=PA210&dq=automated+storytelling&source=bl&ots=GT4xY38E3-&sig=JdsqTygkC78LM_xQlpzgIMCWoXg&hl=de&ei=KVMAS6OePMresgbo4bGjDA&sa=X&oi=book_result&ct=result&resnum=5&ved=0CBkQ6AEwBDgK#v=onepage&q=automated%20storytelling&f=false
11:15:51 <IceDane> heh
11:16:36 <ksf> you also need some real understanding of implementing programming languages to design a thing like e.g. scumm.
11:17:11 <PeakerWork> ksf: My friend (yairchu), with a bit of my help, as one of our first QBasic programs, wrote a "quest engine"
11:17:12 <ksf> If you're good, not only your pixels, but also your game design end up being data.
11:17:27 * hackagebot upload: minesweeper 0.8.8.2 - Minesweeper game which is always solvable without guessing (PeterDivianszky)
11:17:29 * hackagebot upload: hssqlppp 0.0.9 - Sql parser and type checker (JakeWheat)
11:17:30 <PeakerWork> (I implemented a Quest game in QBasic, and he created a DSL, because it sucked to repeat lots of implementation details)
11:17:31 * hackagebot upload: darcswatch 0.3 - Track application of Darcs patches (JoachimBreitner)
11:17:55 <fluxxen> if I had a random custom list Hand of type : Add card otherCards (where card is of type : Card Rank Suite) if I was to randomize that Hand so the order of the cards in that list is shuffled using StdGen -> Hand -> Hand how should I start? don't want a complete solutions just a hint or two
11:18:19 <PeakerWork> the language looked like:  "1;2;1;0" (1=define object, 2=obj id, 1=which variable controls its existence, etc)
11:18:20 <ksf> there's an awesome solution from oleg somewhere on the net.
11:18:22 <PeakerWork> (no parsing/etc)
11:18:55 <Jedai> fluxxen: You want to do a shuffle ?
11:18:57 <medfly> IceDane, I think engineering things require you to specialise anyway
11:19:07 <fluxxen> Jedai yes
11:19:29 <medfly> IceDane, at least, if you're learning at a university
11:19:39 <Jedai> fluxxen: There's good functional solution in O(n log n) and there's the obvious fisher-yates algorithms in O(n) if you're willing to use STArray
11:20:18 <Jedai> fluxxen: searching for "haskell shuffle oleg" should bring you to a good solution
11:20:20 <Jedai> @hoogle shuffle
11:20:20 <lambdabot> No results found
11:20:25 <IceDane> medfly: The current education I was looking at would basically be a combination of digital electronics and software engineering, where I would probably specialize in embedded systems
11:20:31 <Jedai> @go haskell shuffle oleg
11:20:32 <lambdabot> Maybe you meant: google googleit do
11:20:38 <Jedai> @google haskell shuffle oleg
11:20:40 <lambdabot> http://okmij.org/ftp/Haskell/
11:20:40 <lambdabot> Title: Haskell Programming: Miscellanea
11:21:12 <fluxxen> Jedai ah okey  gonna give it a look. hopefully I understand it. just been doing haskell for 3 weeks
11:21:15 <IceDane> but the stuff I've been learning recently leaves me wondering whether the undoubtedly shallow dive it takes into advanced mathematics will suit me
11:21:26 <IceDane> All that stuff about engineers just knowing formulas by heart and plugging numbers in isn't the way I wanna work, heh
11:22:18 <medfly> there's always #not-math if you need someone to persuade you that there's no point in learning mathematics
11:22:21 <medfly> or at least that's how it used to be
11:23:10 <IceDane> I like mathematics
11:23:13 <johannesh> evening
11:23:19 <koeien> hello!
11:23:19 <Badger> you shouldn't! :D
11:23:22 <Jedai> fluxxen: http://okmij.org/ftp/Haskell/perfect-shuffle.txt (if you didn't find it already), it's pretty interesting
11:24:06 <andrewsw> IceDane: I like maths too, and it is difficult to choose next steps to study.
11:24:25 <medfly> write down your priorities
11:24:30 <Araneidae> Well, I work in embedded engineering, but I don't use that much mathematics.  Quite a bit of Fourier transforms at one point, and a scattering of other stuff, but mostly it's hacking and program admin
11:24:34 <johannesh> I was wondering, all examples I could found concerning a Main Function in Haskell, deal with some kind out output. How would I make my Main function execute some other function, and then silently exiting?
11:24:39 <Phyx-> hello, I think i'm rather out of it today, but i can't figure out what ghc is complainig about here http://phyx.pastebin.com/d66192295
11:24:54 <IceDane> medfly: Without having given it an *insane* amount of thought or research yet, it seems to be me that my choices are: Practical software engineering + digital electronics with just enough math for it work, but not enough to satisfy me, or too much math/programming with not enough(or any) electronics to satisfy me
11:24:58 <johannesh> *exit
11:25:00 <IceDane> heh
11:25:03 <medfly> laziness?
11:25:57 <koeien> johannesh: "execute some other function", what do you mean?
11:26:00 <medfly> http://en.wikipedia.org/wiki/Lazy_evaluation
11:26:10 <IceDane> Either way, I'll have to look into it a bit more
11:26:14 <andrewsw> IceDane: I think I'm headed down the systems language route -- plenty of math in the compilers and verification there of, plus getting dirty with hardware
11:26:17 <mauke> Phyx-: the error message doesn't seem to match the source
11:26:22 <mauke> Phyx-: (and it works here)
11:26:29 <IceDane> andrewsw: system language?
11:26:35 <koeien> johannesh: otherf = {- do lots of stuff -}   main = putStrLn "inited" >> otherf
11:26:46 <Phyx-> mauke: exactly, it's confusing the heck out of me, if i drop the module declaration it works, if i add it, it doesn't
11:27:00 <johannesh> koeien: second
11:27:12 <andrewsw> IceDane: languages designed for os programming ( but please not C)
11:27:24 <IceDane> andrewsw: I see..
11:27:46 <fluxxen> Jedai that seems very complex. what about a solution that takes a Hand (list) and creates a new one and takes a random card from the first hand and insert in the new list and then removes the card from the first list and do so until all cards from the first list is inside the second list and return it. could you help me get started on solution like that?
11:28:12 <koeien> fluxxen: that is an easy solution, it takes O(n^2) time however :(
11:28:15 <IceDane> I haven't taken a look at every possible education I can take here, so I might be able to take, say, an advanced math course on the side along with the practical stuff
11:28:16 <Jedai> fluxxen: That's the first algorithm given in this text
11:28:18 <IceDane> which may be enough for me
11:28:34 <andrewsw> IceDane: ungrad or grad?
11:28:45 <Jedai> it's slow but if your list are pretty small, it may be enough for you
11:28:49 <fluxxen> koeien hehe well I can live with that
11:28:56 <johannesh> koeien: well, I have a function, which sorts a list. Now I would like that function to be in a file which I intend to compile using ghc and then run  la "time my_sort"
11:28:57 <fluxxen> Jedai oh okey
11:28:57 <IceDane> andrewsw: I don't think we can use those terms over here(Denmark)
11:29:01 <andrewsw> IceDane: s/un/under/
11:29:10 <IceDane> just a sec
11:29:14 <IceDane> let me look something up fast
11:29:15 <fluxxen> Jedai only 52 cards can't be that heavy
11:29:27 * Phyx- wonders if GHC is on crack today
11:29:32 <koeien> johannesh: so you want to do the sort, but not print any output?
11:29:46 <Phyx-> mauke: which ghc version are you using?
11:29:48 <johannesh> koeien: that is exactly right
11:30:00 <Jedai> fluxxen: That should be perfectly fine then (if you're not shuffling all the time...), look at the extract and shuffle functions in oleg's text
11:30:09 <mauke> Phyx-: 6.10.2
11:30:11 <koeien> johannesh: then you need to "force" the list to be evaluated, otherwise it will not be sorted at all
11:30:19 <Jedai> fluxxen: it's something like 6 lines of codes all in all
11:30:31 <fluxxen> Jedai =) great thanks alot!
11:30:33 <koeien> johannesh: example,  forceList [] = [], forceList (x:xs) = x `seq` forceList xs
11:31:05 <Phyx-> mauke: I'm using 6.10.4, but i can't imagine that this wouldn't compile..
11:31:08 <koeien> and then, main = forceList (yourFunction) `seq` return (), this should work
11:31:35 <johannesh> koeien: ok let me try that, thanks in advance :)
11:31:46 <koeien> johannesh: seq is a bit of magical function
11:31:50 <mmx166mhz> OK, I am still not any further with wxHaskell.. WHY is it so difficult?
11:32:16 <romanandreg> I'm a bit confused about the System.Random API and the IO monad relationship, does someone have some time to spare and help me out to understand this basics?
11:32:16 <IceDane> andrewsw: After looking at it, it seems that after the whole 5,5 years it'd be similar to a masters degree
11:32:28 <mmx166mhz> Is here anyone who actually installed wxHaskell on a windows?
11:33:01 <luite> mmx166mhz: didn't the binary distribution work for you? last time I checked, there was a build for ghc 6.10.4
11:33:35 <andrewsw> IceDane: I see. Over here (USA), I'd either double major (Math/CS) or major in one and minor in the other (what I"m doing right now).
11:33:36 <Jedai> romanandreg: basically, you can't have a "random" function in Haskell, this would violate the referential transparency
11:33:45 <mmx166mhz> OK: lets do it all from the beginning: I have WIndows vista and have GHC 6.10.4
11:34:30 <IceDane> Ah
11:34:30 <mmx166mhz> There is a binary package for me on this site: Can I install wxHaskell using this?
11:34:30 <mmx166mhz> http://haskell.org/haskellwiki/WxHaskell/Download#Basic_packages
11:34:30 <Jedai> romanandreg: so you have to transmit the randomness generator explicitly, or in IO, consult an internal IORef
11:34:36 <sinelaw> @hoogle runHaskell
11:34:36 <lambdabot> No results found
11:34:46 <sinelaw> @hoogle runhaskell
11:34:48 <lambdabot> No results found
11:35:01 <IceDane> andrewsw: shit, it seems this only has a single math course in the standard classes
11:35:01 <luite> mmx166mhz: why don't you try the binary packages first?
11:35:07 <IceDane> but I'm not sure about optional
11:35:10 <IceDane> Meh
11:35:14 <mmx166mhz> How should I do it?
11:35:19 <sinelaw> ah :( silly me
11:35:21 <mmx166mhz> I downloaded it , now what?
11:35:22 <andrewsw> IceDane: yikes!
11:35:32 <Jedai> romanandreg: so in IO you can use the classics random functions you're used to in other imperative languages, but in pure code you have to pass along a random gen, eventually using a monad to make it less annoying
11:35:37 <luite> mmx166mhz: the binary one?
11:35:41 <mmx166mhz> yes
11:35:54 <BONUS> hey mmx166mhz i just got your email :)
11:35:56 <luite> oh I have never installed it, downloading it now, one moment
11:36:06 <BONUS> sorry to disappoint you but you probably know more about wx than me, soo
11:36:08 <mmx166mhz> Nice bonus!
11:36:16 <johannesh> koeien: looks good, thank you very much :)
11:36:26 <BONUS> good luck though!
11:36:28 <mmx166mhz> lol, thugh you have a verry nice site
11:36:33 <BONUS> hehe thanks
11:36:37 <Jedai> romanandreg: do you follow what I just said or should I gives more details ?
11:36:58 <andrewsw> IceDane: what math is it?
11:37:40 <Cale> IceDane: I just have a bachelor's in pure mathematics, but I'm still studying constantly and you can read the blog I'm doing with my friend Robin here: http://analogical-engine.com/wordpress/
11:38:23 <medfly> Cale advertises.
11:38:37 <Cale> Indeed :)
11:38:42 <romanandreg> Jedai: yeah, right now I'm studying RWH and see how the State monad facilitates the use of the Random
11:39:14 <romanandreg> Jedai: Is just that there are some functions that uses the IO when I'm not expecting then to be there...
11:39:50 <luite> mmx166mhz: extract the zip to some location, preferably one without spaces. open a command prompt, go to the bin directory and run wxhaskell-register.bat
11:39:51 <IceDane> Cale: I took a look before, I was all.. "whaaat?"
11:39:51 <IceDane> heh
11:39:57 <Cale> Robin and I are planning to look for students interested in tutoring so that we can make a bit of money to support ourselves, but haven't formalised anything in that regard yet.
11:39:59 <luite> mmx166mhz: that should probably work if you have a compatible ghc in your path :)
11:39:59 <IceDane> andrewsw: It looks like the very basic math I'd need for engineering
11:40:02 <Cale> IceDane: I'm doing a series on natural transformations now :)
11:40:19 <luite> mmx166mhz: (I don't, I use 6.12, so I can't test)
11:40:20 <Jedai> romanandreg: Right, the State monad allows you to defer to the monad the random gen bookkeeping... Most "Random" monad you'll find around hackage and the wiki are just State monad with some more functions to get random numbers directly from the gen in the State
11:40:40 <IceDane> Cale: and yeah, you were right. I can always study on my own, to be honest
11:40:55 <romanandreg> Jedai:  that make sense
11:41:13 <romanandreg> Jedai: Sometimes I get lost with some function signatures
11:41:23 <romanandreg> Jedai: this one for example
11:41:26 <romanandreg> Jedai: http://book.realworldhaskell.org/read/programming-with-monads.html#RandomSupply.hs:randomsIO
11:41:45 <romanandreg> how do you get an "IO [a]" out of that?
11:42:03 <sinelaw> IceDane, some of the math required for proper engineering is not all that simple as I thought it would be
11:42:04 <Jedai> romanandreg: You generator must comes from IO, or you won't have real randomness (or even faked but changing for every call of the program)
11:42:14 <luite> oh lots of new posts @ Cales blog, I can hardly keep up :p
11:42:14 <Araneidae> Trying to build a package which depends on a "hidden package" ... how to fix?
11:42:17 <Jedai> romanandreg: once you've got a generator, you can escape in pure code, eventually using a State monad to make it prettier
11:42:42 <Cale> luite: \begin{explain} I started writing & I kept thinking of more stuff to include & I just couldn't stop \end{explain}
11:42:57 <Jedai> romanandreg: That's because of getStdRandom
11:42:59 <stroan> Cale: link to your blog?
11:43:19 <Cale> http://analogical-engine.com/wordpress/
11:43:19 <Jedai> :t getStdRandom
11:43:19 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
11:43:22 <aavogt> sinelaw: what part in particular?
11:43:38 <sinelaw> aavogt, random processes was one
11:43:38 <Phyx-> mauke: found it, my editor was accidently set to mac line endings :S
11:43:47 <romanandreg> Jedai: What I understand... getStdRandom receives a function that receives an StdGen
11:44:10 <romanandreg> and Whatever this functions returns in the first position of the tuple, that is what the getStdRandom fn is going to return to the IO?
11:44:17 <Cale> stroan: There's stuff about category theory, combinatorics, Haskell, linear algebra, and all sorts of stuff at various difficulty levels mixed up there :)
11:44:17 <Jedai> Right, in this case the function is (\g -> let (a, b) = split g in (randoms a, b))
11:44:22 <sinelaw> aavogt it's not all that bad, but it wasn't easy either
11:44:25 <luite> Cale: it's ok because it has lots of pretty pictures and diagrams :)
11:44:59 <sinelaw> aavogt also control theory, which is very nice, requires a little work
11:45:10 <sinelaw> (i don't remember much of it, unfortunately)
11:45:17 <Jedai> romanandreg: so you get an infinite list of random stuff of type "a"
11:45:36 <sinelaw> aavogt and of course, partial differential equations, but that depends on what they expect you to know
11:46:00 <andrewsw> Cale: nice use of LaTeX in the title tags!
11:46:06 <profmakx> rasfar thanks, but I think i'll wait until it turns up in arch :P
11:46:06 <luite> Cale: perhaps you could make the more difficult topics a bit more accessible by linking to more introductory texts or definitions (on your site or external links)
11:46:11 <Jedai> romanandreg: and the second gen you got with split is written in the IO random generator for future use
11:46:50 <romanandreg> Jedai: yes, I understand that... the interface to use randoms is a bit confusing though... you have to use your random functions always with a getStdRandom fn like... is like the getStdRandom is a "factory" function
11:47:38 <Phyx-> is there a tool, that simplifyies core? makes it more readable by e.g. throwing away type information etc?
11:47:44 <dons> ghc-core
11:47:48 <dons> is that tool.
11:47:55 <dons> it does some rewriting, simpliciation and syntax coloring.
11:47:58 <opqdonut> the unique tool that - -
11:48:00 <opqdonut> :)
11:48:03 <Jedai> Right, getStdRandom is an higher order function that allows you to easily use pure random function with the generator coming from IO
11:48:13 <Cale> luite: Yeah, we need to work out a better way to get things organised.
11:48:24 <Phyx-> dons: ah, thanks
11:48:29 <Jedai> Well, if pure random function isn't an oxymoron...
11:49:01 <luite> Cale: it also becomes a bit confusing if you start a post with something like "so now we have ..." and you have to seach for the previous one by the same author :)
11:49:09 <Cale> luite: I'm fleshing out some of the introductory material needed for the adjunctions series right now in my series about natural transformations, but the blog format is a bit funny in that it puts everything upside-down
11:49:27 <Cale> Yeah.
11:49:52 <IceDane> sinelaw: Sorry ,was afk
11:49:59 <Cale> I plan to add some links to turn the structure into something a bit more Hasse-diagram-like
11:50:00 <IceDane> You're doing engineering?
11:50:05 <IceDane> If so, what kidn of math are you doing?
11:50:46 <sinelaw> IceDane yes i'm doing (mostly done) electrical engineering, and i did of course basic calculus, linear algebra, ordinary differential equations, as the basis
11:50:59 <IceDane> Yeah
11:51:14 <sinelaw> IceDane then Partial DEs, probability theory
11:51:43 <IceDane> Does that satisfy the side of you that is interested in the theory and mathematics behind computer science?
11:51:45 <sinelaw> IceDane the heavy ones were then introduction to complex functions , random processes
11:52:25 <sinelaw> IceDane and also analysis (which is about fourier theory and distributions, mostly) which was interesting and not hard at all
11:52:29 <IceDane> Because that's basically what I'm 'worried' about. Whether I will learn enough theory about computer science to be satisfied, heh
11:52:47 <sinelaw> IceDane it's not really related to computer science...more to electrical engineering
11:53:13 <IceDane> sinelaw: I see
11:53:15 <sinelaw> we also did control theory, and signal processing which is very mathematical (but not so abstract)
11:53:31 <IceDane> Yeah, you are basically describing what I'll be diong, methinks
11:53:51 <null_ptr> One more question. Here is the code: http://paste.bradleygill.com/index.php?paste_id=24738 For foo5, foo6 and foo7 I don' get the expected results. Why?
11:53:54 <sinelaw> good stuff. it gave me a pretty strong background and trained me to think properly
11:53:57 <IceDane> Then again, I haven't been exposed to enough raw computer science to know if I'll be all that interested in it
11:54:21 <sinelaw> IceDane like i said, most of what i did has nothing to do with computer science (Except teh very basic courses)
11:54:25 <Araneidae> Does anybody fancy criticising some beginner's Haskell code?  It's the additive fragment of computational reals with a simple minded representation, here: http://pastebin.com/d70c9f676
11:54:34 <IceDane> I just know that the time I've spent doing haskell has made me interested, but I'm not sure that will stick for the whole duration heh
11:54:36 <sinelaw> IceDane #haskell-blah
11:54:38 <IceDane> sinelaw: yeah
11:54:48 <Araneidae> I'll write * and / later -- (*) should be easy, (/) rather fiddly...
11:57:20 <null_ptr> any hints?
11:57:35 <sinelaw> IceDane: What i'm now missing slightly is really the CS-oriented stuff. i might go for a master's in CS in some evening school, but that's not certain, and not now.
11:58:19 <IceDane> I see
11:58:28 <IceDane> Thanks =)
12:00:07 <sinelaw> IceDane bottom line is, i'm happy i went to the trouble of getting a formal education, it really widened my horizons and thinking
12:00:09 <luite> null_ptr: you need more recursion, for example, you use (x == Yes), but that should give the same result if x is equal to Not No, right?
12:02:09 <luite> null_ptr: you already have a function that reduces a Boool, to either Yes or No, so it might be a good idea to use i
12:02:36 <IceDane> sinelaw: Hehe, yeah.. I think I'll stick with the original route. All in all, what I want to be able to do is programming and electrical engineering/digital electronics(or whatever it's called). If I really feel like I need more CS knowledge, one can always look up some CS courses and get the material and read it
12:03:01 <null_ptr> luite: Hmm I thougt "A" for example never sesees "(Not No)" but gets the result of the op. But when I start thinking about it, you're totally right, since I call bop only once..
12:03:30 <luite> null_ptr: you might need to add the casese for bop Yes = Yes and bop No = No
12:03:46 <eivuokko> Araneidae, without thinking about algos, you might want to try to move on to using more folds and map opposed to direct recursion.
12:03:53 <luite> null_ptr: but after you have done that, it should be straightforward to fix the rest
12:04:05 <Araneidae> eivuokko, that's exactly the kind of hints I'm after here
12:04:19 <Araneidae> For example, I really don't like the definition of ==
12:04:29 <null_ptr> luite: I'll see..
12:04:38 <Araneidae> I've had to define *two* intermediate functions, which seems crazy and wrong
12:04:45 <luite> null_ptr: just ask here if you get stuck again
12:05:22 <Araneidae> eivuokko, If you can give me a conversion of one of my fragments that'll show me the trick I'm missing!
12:09:30 <byorgey> Araneidae: for example,  invertRL = map neg, where neg is the appropriate function  Refinement -> Refinement
12:09:43 <eivuokko> Araneidae, it'd help if I understood the math there, but starting from invertRl: it looks it could be map of function that swaps meaning of Up and Down
12:09:58 <Araneidae> That's exactly what it is
12:10:18 <byorgey> Araneidae: prepend n r = replicate n Centre ++ r
12:10:26 <eivuokko> Araneidae, prepend looks like you repeat n times
12:10:50 <eivuokko> Guess byorgey will help, I'll go back playing :)  Gl.
12:11:00 <Araneidae> yes, but isn't ++ a bit inefficient?
12:11:14 <byorgey> Araneidae: no, not here.
12:11:38 <byorgey> Araneidae: the only thing that is inefficient is having left-nested ++, like  (((a ++ b) ++ c) ++ d) ++ ...
12:11:56 <byorgey> Araneidae: ++ is O(n) in its left argument.  Which is exactly the same as your existing code.
12:12:16 <Araneidae> Oh: but doesn't the left hand part of the result list get built twice?
12:12:34 <null_ptr> luite: Got it. I added "bop (Yes) = Yes", "bop (No) = No" and replaced every equation with "(bop x == Yes)". Stupid (helpful) mistake. Thanks!
12:12:35 <Araneidae> Still, your code with replicate saves an auxilliary function
12:12:52 <mauke> (x) is the same as x
12:13:34 <byorgey> Araneidae: maybe.  or maybe the compiler will fuse it away.  who cares? =)
12:13:41 <byorgey> Araneidae: this is called 'premature optimization' ;)
12:13:44 <Araneidae> Sure, it's only an exercise
12:13:56 <Araneidae> Actually, it's called not knowing the library ;)
12:14:09 <byorgey> well, that too =)
12:14:16 <Araneidae> Anything more?  I'm about out of time
12:14:26 <Araneidae> I really don't like the definition of ==
12:14:27 <byorgey> those are the only obvious/easy things.
12:14:34 <Araneidae> Cheers
12:15:11 <Araneidae> I don't like having to define two intermediate names (equalZero and zeroPoint) which are doing the same damned thing!
12:15:32 <eivuokko> always looks like it should be found in Data.List, or map+some function in Data.List
12:15:33 <byorgey> Araneidae: if you have functions to project out the two components of a CReal you don't need eqaulZero.
12:15:34 <Araneidae> In fact, equalZero only exists to unpack its argument (x-y)
12:15:39 <byorgey> exactly.
12:15:58 <Araneidae> Good point
12:16:08 <byorgey> x == y = zeroPoint (getRefinements (x - y))
12:16:12 <byorgey> or whatever
12:16:16 <Araneidae> Yes, yes, thanks.
12:16:31 <Araneidae> And that's a structure definition, if I remember how to do one of those
12:16:48 * Araneidae has the H98 report nearby, sure it's in there
12:17:37 <byorgey> Araneidae: yes, you could do it that way:  data CReal = CReal { getInt :: Int, getRefinements :: [Refinement] }
12:17:54 <byorgey> or you could just define them separately
12:18:16 <vic_> Fast question: can anybody tell me what should I do to make this code work  http://pastebin.com/d5e215b3d
12:18:52 <mauke> vic_: use x `div` 2 instead of truncate (x / 2)
12:19:31 <vic_> Ah, that figures
12:20:09 <byorgey> since x is an Integer (because you use 'mod' on it), and you can perform / on Integers
12:20:14 <byorgey> *can't
12:20:26 <mmx166mhz> YES IT WORKS!( I Mean wxHaskell) (though there is still a minor problem)
12:21:27 <gjl> mod (div (length [1,2,3,4]) 2) 2          returns 0, but halve [1,2,3,4] returns 'Non-exhaustive patterns in function halve'
12:21:29 <mmx166mhz> When I run the executable, it says: Failed to load shared library comctl32.dll
12:21:37 <mmx166mhz> (thugh it works)
12:22:08 <gjl> I must be missing something obvious. halve is defined as halve [a] = (mod (div (length a]) 2) 2)
12:22:10 <Cale> :t truncate
12:22:11 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:22:15 <vic_> byorgey: it gives me
12:22:18 <vic_> nrprim.hs:3:41:
12:22:18 <vic_>     Ambiguous type variable `a' in the constraints:
12:22:18 <vic_>       `Integral a' arising from a use of `div' at nrprim.hs:3:41-49
12:22:18 <vic_>       `RealFrac a' arising from a use of `truncate' at nrprim.hs:3:32-50
12:22:18 <vic_>       `Read a' arising from a use of `readLn' at nrprim.hs:2:5-10
12:22:20 <vic_>     Probable fix: add a type signature that fixes these type variable(s)
12:22:23 <gjl> I must be missing something obvious. halve is defined as halve [a] = (mod (div (length [a]) 2) 2) *
12:22:29 <gjl> sorry, correction
12:22:41 <mauke> gjl: that only works for lists with exactly one element
12:22:50 <Cale> vic_: There's no div in the code you pasted, btw
12:22:51 <vic_> I should ditch this example.
12:23:14 <gjl> mauke, ah. it certainly does. Ok, I'll go read up on lists again. thanks
12:23:16 <mauke> vic_: yeah, because there's no type that satisfies both Integral and RealFrac
12:23:29 <mauke> just use a instead of [a]
12:23:39 <vic_> I shoult add a type signature... ah, ok
12:23:45 <mmx166mhz> anyone know why it gives that error?( though it works)
12:23:52 <Cale> oh
12:24:10 <gjl> mauke: thanks.
12:25:12 <luite> mmx166mhz: if that file was included somewhere in the wxhaskell binary distribution, you'd need to copy it to your application directory, or to some directory in your path
12:25:26 <Cale> gjl: http://pastebin.com/m37756a95
12:25:50 <Cale> gjl: I also took the liberty of indenting things sanely and removing unnecessary parens :)
12:26:08 <Cale> er, I mean vic_
12:26:14 <Cale> (sorry)
12:26:35 <vic_> Cale: awesome
12:26:36 <luite> mmx166mhz: otherwise, you can probably get the dll from microsoft (perhaps it's part of some redistributable package)
12:27:00 <ksf> does an adt that has strictness annotations in its recursion really get unboxed completely with -funbox-strict-fields?
12:27:44 <Cale> vic_: Of course, you usually wouldn't mash IO and non-IO stuff together this way
12:27:57 <mmx166mhz> well luite: The comctl32.dll is some vital file which is normally in c:/windows/system32
12:28:02 <Cale> vic_: Separate it into a proper isPrime :: Integer -> Bool function and call that from the IO code :)
12:29:03 <vic_> Yeah, it now gives me a lovely "   The last statement in a 'do' construct must be an expression
12:29:14 <vic_> main is not enough
12:29:21 <mauke> I blame misindentation
12:29:51 <luite> mmx166mhz: yes I know, if you do have the file, I'm not sure why it cannot find it
12:30:29 <vic_> How many tabs...
12:30:40 <mauke> 0
12:30:59 <vic_> Ok. Works!
12:31:10 <vic_> And just the main. Nice
12:31:52 <vic_> Whitespace in Haskell can be confusing
12:31:58 <mauke> NO IT CANNOT
12:32:04 <mauke> by royal decree
12:32:04 <Cale> hehe
12:32:15 <Cale> vic_: "tabs" is a bad word
12:32:40 <Cale> vic_: Ensure that your text editor is converting them into spaces so that the Haskell compiler will see exactly what you see.
12:33:10 <vic_> I'll tweak my Gedit
12:35:58 <IceDane> Cale: Is there a way to make sure that happens in vm?
12:35:59 <IceDane> vim*
12:36:08 <mauke> :set sw=4 sts=4 et
12:36:50 <vic_> And now a more complex example, with FFI and C.  Here is test.c   http://pastebin.com/d7c316752    and here is foo.hs http://pastebin.com/m1d07f422
12:37:01 <Cale> IceDane: set expandtab
12:37:10 <IceDane> ah, sweet, thanks
12:37:24 <Cale> IceDane: (or et like mauke mentioned)
12:38:07 <gwern> 'Every time you attempt to parse HTML with regular expressions, the unholy child weeps the blood of virgins, and Russian hackers pwn your webapp. Parsing HTML with regex summons tainted souls into the realm of the living. HTML and regex go together like love, marriage, and ritual infanticide. The <center> cannot hold it is too late. The force of regex and HTML together in the same conceptual space will destroy your mind like so much ...
12:38:13 <gwern> ... watery putty. If you parse HTML with regex you are giving in to Them and their blasphemous ways which doom us all to inhuman toil for the One whose Name cannot be expressed in the Basic Multilingual Plane, he comes. HTML-plus-regexp will liquify the n​erves of the sentient whilst you observe, your psyche withering in the onslaught of horror........\nHave you tried using an XML parser instead?'
12:38:22 <gjl> I'm getting a parse error on input '|' when trying to load http://pastebin.com/d4776c10e
12:38:36 <mauke> gwern: just link to http://xrl.us/bf4jh6
12:38:42 <gwern> mauke: nevar
12:38:45 <mauke> it looks better
12:38:53 <gjl> I hope it isn't my (mis)understanding of guarded equations causing that
12:38:53 <gwern> links die. but quotes live as long as the irc logs!
12:39:00 <Cale> gjl: You have too many parens which makes the nesting impossible to follow
12:39:11 <netinho2lol> sup haskell crew
12:39:14 <Twey> Stand back!
12:39:16 <Twey> I know Lisp!
12:39:32 <netinho2lol> cdr is your other car
12:39:37 * _zenon_ golfclap
12:39:39 <netinho2lol> and I don't know lisp
12:39:41 <Cale> gjl: length a / 2 won't work, since length a will be an Int
12:39:44 <_zenon_> who doesn't know Lisp
12:39:48 <Cale> gjl: and Ints don't support /
12:39:59 <Cale> gjl: You should use `div` if you want integer division
12:40:13 <Twey> Ah yes, here's your problem
12:40:16 <Cale> (which is really quite a different operation)
12:40:19 <gjl> Cale: thanks - I knew I forgot to do that
12:40:22 <netinho2lol> hey guys
12:40:22 <Twey> You need an extra closing bracket
12:40:37 <netinho2lol> f (a:as) (b:bs) = (a ++ b) : f as bs
12:40:43 <netinho2lol> this is a foldr, right?
12:40:43 <Twey> And an argument to the drop
12:40:44 <_zenon_> Btw; IRC is for hackers, it's true: http://www.youtube.com/watch?v=O2rGTXHvPCQ
12:41:28 <mauke> netinho2lol: looks like a zip
12:41:38 <netinho2lol> fuuu
12:41:39 <netinho2lol> >.<
12:41:48 <netinho2lol> you're right
12:41:53 <mauke> zipWith (++)
12:41:56 <Cale> gjl: http://pastebin.com/meda55ca
12:42:00 <netinho2lol> facepalms
12:42:06 <Cale> and you're using numbers as lists
12:43:02 <Cale> gjl: Something else you should be aware of: retyping "length a" over and over will mean that the Haskell compiler computes it separately each time it needs it.
12:43:17 <netinho2lol> brb, walking the dog ~_~
12:43:24 <Cale> gjl: Making a definition both cleans up the presentation, and makes the function run faster :)
12:44:06 <Cale> (rather, the Haskell compiler generates code that computes it over and over)
12:44:38 <gjl> Cale: thanks for the pointers.
12:44:49 <Cale> It's actually possible to make this a little better than my paste, since there's still a (length a) in that guard
12:45:08 <Twey> gjl: You could also write it sanely: http://pastebin.com/m7e2bc6c1
12:45:28 <gwern> netinho2lol: incidentally, the license plate is 'my other car is a cdr', not vice versa
12:45:31 <Twey> Oh, Cale redid it, too ☺
12:45:58 <Twey> Oh, yeah
12:46:05 <Twey> Heh, missed the type mismatch >.<
12:46:13 <gjl> I notice that Cale uses [a] -> ([a],[a]) and Twey uses [a] -> ([b],[c])
12:46:34 <gjl> I guess that's what you are referring to then, Twey?
12:46:44 <Twey> No
12:46:49 <Twey> Mine was just a refactoring of yours
12:47:15 <Twey> And as such it was a type error — (0, 0) is Num a => (a, a), not ([a], [b])
12:47:32 <Twey> Er, (Num a, Num b) => (a, b)
12:47:41 <gjl> ah
12:48:10 <gjl> What's the difference between [a] -> ([a],[a]) and [a] -> ([b],[c]) ?
12:48:23 <jmillikin> The second doesn't make much sense
12:48:26 <Twey> gjl: In the first one, the a's all have to be the same type
12:48:32 <Twey> In the second, they don't
12:48:34 <koeien> gjl: in the former, the a's are the same, in the latter, b and c might be different from a
12:48:41 <Twey> Yeah, it doesn't make sense for this function
12:48:46 <gjl> thanks
12:49:03 <koeien> there are only very few functions of type [a] -> ([b], [c])
12:49:23 <koeien> i lie, never mind
12:51:00 <Twey> http://pastebin.com/m8aa6f61 — the power of view patterns compels you!
12:51:33 <Twey> Damn, I missed the 0 again… never mind
12:52:02 <Twey> http://pastebin.com/m64fbe9f3 — that's the one
12:52:49 <fluxxen> can someone please help me out with a shuffle function. I have seen the ones from oleg but I don't want it so complex since I am following an exercise and they give a hint to take a list and create a new list and then randomly pick an element from the first list and put it in the other list until the first list is empty and then the returned list is shuffled (maybe not perfect and maybe not so good performance wise but 
12:53:12 <opqdonut> your line got cut
12:53:17 <yitz> @hoogle [a] -> ([b],[c])
12:53:17 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
12:53:18 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
12:53:18 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
12:53:19 <opqdonut> at "good performance wise but"
12:53:25 <gjl> Twey: interesting. thanks
12:53:34 <fluxxen> but at least it's shuffled) the definition of the function should use shuffle :: StdGen -> [a] -> [a] I don't want complete answer just a hint
12:53:54 <Cale> fluxxen: Your function should produce a perfect shuffle if you do it that way
12:54:20 <fluxxen> Cale ok. but how should I start? I have shuffle g [] = [] in the first pattern matching
12:54:29 <Cale> fluxxen: yep
12:54:36 <Twey> Is it truly perfect?
12:54:49 <Twey> Wouldn't that require an array?
12:54:52 <Cale> fluxxen: actually, you should have another parameter for convenience: the length of the list
12:54:52 <yitz> fluxxen: one easy approach is to use the type Data.Sequence
12:54:53 <fluxxen> Cale can you give me a hint what I want to do for the next stay?
12:55:09 <Cale> fluxxen: and then you can write a quick wrapper which computes it
12:55:12 <fluxxen> yitz will that work even though my list is acctually a custom List ?
12:55:30 <fluxxen> i am making a deck of cards and need a function to shuffle it
12:55:34 <Cale> Twey: perfect in the sense of giving equal probability to each permutation
12:55:42 <Twey> Cale: Yeah
12:55:44 <fluxxen> the list type is Add card otherCards and a card is Card Rank Suit
12:55:56 <Cale> His algorithm will be a sort of dual to selection sort.
12:55:56 <Twey> Cale: But since it's not possible to assign an item directly to the end of the finished list…
12:56:06 <Twey> Aye.
12:56:15 <Cale> That doesn't matter, you can start from either end :)
12:56:18 <yitz> fluxxen: you copy from your list into a Data.Sequence (or a Data.IntMap on [1..n]), then you pull them out one by one in random order. Just like the classic fair shuffle algorithm.
12:56:24 <ksf> It should be forbidden by law to teach CS students tree structures that contain data in nodes.
12:56:32 <ksf> the leaves is where it belongs.
12:56:52 <Cale> ksf: monoidal information about the data in the leaves belongs in the nodes.
12:57:00 <ksf> exactly.
12:57:11 <fluxxen> yitz oh gonna check up sequence then
12:57:40 <fluxxen> thanks guys
12:57:57 <fluxxen> probaly be back with errors though but =)
12:59:04 <Saizan_> you don't need Data.Sequence if you don't care about O(n) indexing
12:59:07 <Raynes> Holy shit.
12:59:09 <ksf> It's embarrassing that I didn't come up with a binary search that isn't slower than linear before, for n == 4
12:59:15 <Raynes> Wrong channel. <3
12:59:20 <yitz> Saizan_: quite true
12:59:47 <sioraiocht> Saizan_: well, unless you append a lot
13:00:12 <yitz> Saizan_: I suppose if you're limited to a standard deck of cards, might as well just use a regular list.
13:00:20 <Saizan_> sioraiocht: we're talking about shuffling, and you can just cons here
13:00:34 <sioraiocht> Saizan_: sorry, should have scrolled up ;)
13:00:43 <fluxxen> Saizan_ I don't even now what that is, what is it?
13:01:19 <Saizan_> fluxxen: picking the nth element of a list takes time proportional to n
13:01:35 <fluxxen> Saizan_ i ah ok. what should I do insteed then?
13:01:49 <opqdonut> ksf: worst or average case?
13:01:53 <opqdonut> average i presume
13:02:47 <Saizan_> fluxxen: if you want something faster you indeed need to use a structure such as Data.Sequence , which is a particular tree
13:03:07 <Saizan_> fluxxen: oleg simply uses a binary tree for this
13:03:53 <profmakx> :q
13:04:25 <ksf> opqdonut, the distribution is even, so it has to beat n/2
13:04:26 <fluxxen> Saizan_ yeah I read about that but it seems to complex for my exercise since I am only on week 3 on haskell. My exercise said I should do a function which took a full deck of cards and shuffled it by taking 1 element from the deck and put it in a new hand until there is no card in the deck (hand). and that I should use the definition shuffle :: StdGen -> Hand -> Hand
13:04:40 <fluxxen> but as yitz pointed out I could do this with data.sequence
13:04:42 <ksf> that means that there musn't be any overhead intruduced by the tree, compared to a list.
13:04:55 <fluxxen> have no idea yet how though but gonna google data.sequence
13:05:19 <Saizan_> fluxxen: Data.Sequence would just be a substitute for oleg's binary tree
13:05:30 <ksf> it actually amounts to indexing an array via a binary heap
13:05:39 <Saizan_> fluxxen: but, as i pointed out, if you don't care about performance, you can just use a list.
13:06:08 <yitz> fluxxen: yeah, but as Saizan_ pointed out, if you are limited to shuffling a deck of cards, it could be fast enough just to use a list instead of Data.Sequence, and it's simpler.
13:06:24 <mmx166mhz> Hi everyone
13:06:35 * yitz should type less, like Saizan_ 
13:06:48 <yitz> hi mmx166mhz welcome back.
13:07:18 <fluxxen> Saizan_ and yitz ah ok
13:07:25 <BONUS> fluxxen: say you have a list (x:xs). if it's empty, leave it empty. if it isn't, shuffle xs and then insert x in a random position there
13:07:58 <Saizan_> fluxxen: at each step you choose a random number between 0 and length of the remaining cards to shuffle, and use it as an index into them, put that card on the top of the shuffled cards, removing it from the to-shuffle ones, and recurse
13:08:01 <fluxxen> BONUS but how do I insert it in a random position?
13:08:29 <fluxxen> Saizan_ ah ok I get it
13:08:31 <BONUS> spiltAt is useful here
13:08:44 <BONUS> > splitAt 3 [1..5]
13:08:45 <jmillikin> Is the output of "darcs send" usually very large?
13:08:45 <lambdabot>   ([1,2,3],[4,5])
13:09:11 <jmillikin> I'm trying to send a patch, but it's generating 390KB of "context", and I wonder if I'm doing something wrong.
13:09:13 <BONUS> you split it at a random position and return [1,2,3] + [x] + [4,5]
13:09:34 <Saizan_> jmillikin: that happens when there haven't been tags in a while
13:09:45 <Saizan_> jmillikin: it lists all the patches, afterall
13:09:56 <mmx166mhz> Does anyone have an idea why when running .exe made with haskell gives an error " comctl32.dll not found"?
13:10:40 <Saizan_> BONUS is using a different algorithm here, but probably works too :)
13:10:46 <jmillikin> Well, it's listing *every* patch, back to the initial check-in. I see several tags in the patch file.
13:11:16 <Cale> mmx166mhz: That's a standard windows library, so I don't know.
13:11:19 <eivuokko> mmx166mhz, sounds like very old Windows (and IE iirc)
13:11:26 <eivuokko> *and IE
13:11:35 <mmx166mhz> I am usig vista
13:11:50 <Cale> Maybe too new Windows ;)
13:11:58 <mmx166mhz> haha:)
13:12:16 <Saizan_> jmillikin: a bit strange, and i never had patch bundles that big, maybe try asking on #darcs
13:12:31 <Cale> But no, if it didn't have comctl32.dll it couldn't run, well, almost any Win95/98 program.
13:12:46 <mmx166mhz> It runs, though it gives this error
13:12:46 <Cale> So I don't know what's going on.
13:12:52 <mmx166mhz> so its not a big deal
13:12:54 <Cale> oh
13:12:59 <eivuokko> mmx166mhz, dunno.  Maybe you have some wierd manifest stopping it finding comctl32 or you have broken Windows.
13:13:00 <netinho2lol> gwern: I said that I didn't know Lisp :P
13:13:01 <Cale> It just prints the error and goes on running?
13:13:08 <mmx166mhz> yes
13:13:12 <Cale> very odd
13:13:27 <stroan> Myself and a lot of other guys in my course have seen that exact error with wx
13:13:27 <mmx166mhz> I'll try it on the uni's pc 2morrow
13:13:41 <mmx166mhz> i am using wx
13:13:45 <stroan> yeah
13:13:49 <stroan> I get it too
13:13:55 <jmillikin> Ah, found the issue, it was comparing against the wrong repository.
13:13:59 <mmx166mhz> Ah, u have an idea?
13:14:28 <stroan> my program works fine despite that, and I mostly dev on linux so I've not put much effort into fixing it
13:14:39 <Cale> Hmm, wery strange, wordpress has started taking me to the preview of the post every time I hit Save on my draft.
13:15:07 <yitz> mmx166mhz: oh, this is a wxHaskell app?
13:15:16 <mmx166mhz> yes
13:16:18 <dec142> anyone have a recommended Haskell tutorial for someone new to functional programming?
13:16:33 <mmx166mhz> Yeah, the one of bonus
13:16:41 <mmx166mhz> http://learnyouahaskell.com/
13:16:41 <Cale> @where lyah
13:16:42 <lambdabot> www.learnyouahaskell.com
13:16:50 <vic_> That's a cool tutorial
13:17:04 <BONUS> y'all are too kind :)
13:17:11 <yitz> mmx166mhz: gui frameworks are complicated. if it still works, that's great. ask one of the wxHaskell developers.
13:17:12 <vic_> As for books, Graham Hutton's is good
13:17:30 <vic_> *Hutton's book is good
13:17:38 <yitz> BONUS: are you still planning on making lyah into a printed book?
13:17:52 <dec142> :) cool thanks I'll check that out as well _vic
13:18:23 <BONUS> yitz: yeah! im going over the prev chapters with the editor now
13:18:33 <BONUS> which is why new chapters haven't been coming out lately
13:18:40 <BONUS> but they will though soon
13:18:40 <yitz> BONUS: great! good luck with that
13:19:01 <BONUS> haha thanks
13:19:09 <yitz> dec142: so there you have it, soon lyah will also be a book :)
13:19:24 <Heffalump> cool, what publisher?
13:19:45 <vic_> Awesome
13:19:50 <BONUS> Heffalump: no starch press
13:19:55 <BONUS> :]
13:20:04 <vic_> NSP has some really cool books
13:20:07 <kw317> BONUS: awesome :D
13:20:12 <BONUS> woot!
13:20:39 <netinho2lol> does anyone knows how to rotate lists?
13:20:40 <yitz> vic_: they're about to have another one
13:20:49 <Zao> netinho2lol: Depends on what you mean by "rotate"
13:21:22 <vic_> yitz: which one?  Lyah?
13:21:34 <yitz> vic_: of course, what else? :)
13:21:36 <vic_> # Land of Lisp Coming Soon!  heh
13:21:43 <Heffalump> BONUS: cool, had never heard of them before, but they look nice
13:21:43 <vic_> Too bad I don't like Lisp
13:22:04 <vic_> yitz:  :-)
13:22:05 <BONUS> yeah they're nice, letting me keep it online and everything
13:22:17 <netinho2lol> Zao: like this: rotate90degrees ["ab","cd"] = ["ca","db"]
13:22:34 <netinho2lol> I'm using list of strings, which is not cool
13:22:36 <yitz> netinho2lol: transpose
13:22:37 <stroan> How can I build a module that links against a c file, such that I don't have to refer to the C file when using that module elsewhere?
13:22:43 <yitz> @type transpose
13:22:44 <lambdabot> forall a. [[a]] -> [[a]]
13:22:58 <yitz> > transpose ["ab","cd"]
13:22:59 <Zao> > transpose ["omg", "wtf"]
13:22:59 <lambdabot>   ["ac","bd"]
13:23:00 <lambdabot>   ["ow","mt","gf"]
13:23:05 <netinho2lol> transpose, like in a algebra matrix
13:23:18 <Zao> Interchange "rows" and "columns"
13:23:32 <yitz> hmm, that's not a rotation though
13:24:01 <yitz> > transpose.reverse $ ["ab","cd"]
13:24:02 <lambdabot>   ["ca","db"]
13:24:06 <Heffalump> hi tibbe
13:24:07 <yitz> there!
13:24:22 <vic_> stroan: do you have some code?
13:24:23 <tibbe> Heffalump: hi :)
13:24:49 <medfly> you can refer to a Haskell file!
13:24:49 <netinho2lol> reverse...
13:24:51 <netinho2lol> OH
13:24:57 <stroan> vic_: spefically I'm trying to build on this http://www.serpentine.com/blog/2008/09/30/unix-hacking-in-haskell-better-pseudoterminal-support/
13:25:00 <yitz> netinho2lol: works for square matrix of any size
13:25:11 <netinho2lol> :P
13:25:32 <netinho2lol> I'm going to look at the code for transpose
13:25:42 <netinho2lol> I'm working with rectangles
13:25:47 <netinho2lol> :) maybe it would help me
13:25:51 <netinho2lol> thanks for the assistance
13:26:03 <yitz> > transpose.reverse $ ["abc","def"]
13:26:04 <lambdabot>   ["da","eb","fc"]
13:26:23 <yitz> netinho2lol: is that what you want for a rectangle?
13:26:26 <vic_> stroan: interesting. I'm trying to do something similar, but simpler. From this  http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
13:26:29 <vic_> Meh...
13:26:52 <tibbe> Heffalump: how can I help?
13:26:55 <netinho2lol> yitz: met me check on paper
13:27:06 <yitz> @src transpose
13:27:06 <lambdabot> transpose []             = []
13:27:06 <lambdabot> transpose ([]   : xss)   = transpose xss
13:27:06 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:27:24 <netinho2lol> yitz: YEAH
13:27:43 <netinho2lol> holy crap
13:27:47 <yitz> netinho2lol: it's in Data.List
13:28:36 <netinho2lol> yitz, I knew I had to reverse at some point, but I didn't know how to do the rest :)
13:28:40 <cads> hey all
13:28:52 <netinho2lol> thanks for the assistance, yitz, Zao
13:28:55 <yitz> @vixen thanks for the help
13:28:55 <lambdabot> you're very welcome!
13:29:09 * netinho2lol pats lambdabot
13:29:17 <yitz> @botsnack
13:29:17 <lambdabot> :)
13:29:17 <lunabot>  :o
13:32:10 <vic_> I really need to read this http://urchin.earth.li/~ian/style/haskell.html
13:32:22 <vic_> "   The last statement in a 'do' construct must be an expression" is driving me nuts
13:33:17 <aavogt> it means you can't end with  a let or  x <- expression
13:33:45 <skorpan> or anything which produces a result i guess
13:33:50 <skorpan> doesn't produce*
13:35:50 <harlekin> @pl (\(a,b) -> (read a) * 100 + (read b))
13:35:50 <lambdabot> uncurry ((. read) . (+) . (100 *) . read)
13:36:03 <harlekin> @pl (\(a,b) -> a * 100 + b)
13:36:04 <lambdabot> uncurry ((+) . (100 *))
13:36:27 <vic_> Yeah. In my case, the do ends with a print
13:36:44 <aavogt> then you screwed up indentation probably by using tabs
13:36:54 <vic_> Yes, damned tabs
13:37:45 <aavogt> > do { "a"; "b"; { let { x = 1; y = 2; return 2 }}}
13:37:45 <lambdabot>   <no location info>: parse error on input `{'
13:37:50 <medfly> I LOVE TABS!
13:37:59 <aavogt> @slap medfly
13:37:59 <lambdabot> I won't; I want to go get some cookies instead.
13:38:05 <harlekin> @pl (read *** read)
13:38:06 <lambdabot> read *** read
13:38:21 <dibblego> join (***) read
13:38:36 <aavogt> @type join (***) read
13:38:38 <lambdabot> forall c. (Read c) => (String, String) -> (c, c)
13:38:43 <aavogt> @type  read *** read
13:38:44 <lambdabot> forall c a. (Read c, Read a) => (String, String) -> (c, a)
13:39:12 <yitz> @type uncurry $ ((+).(100 *)) `on` read
13:39:13 <lambdabot>     Precedence parsing error
13:39:13 <lambdabot>         cannot mix `$' [infixr 0] and `on' [infixl 0] in the same infix expression
13:39:25 <aavogt> I suppose it's because there isn't any higher rank polymorphism there
13:39:29 <IceDane> ?index minimum
13:39:29 <lambdabot> Data.List, Prelude
13:39:31 <yitz> @type uncurry (((+).(100 *)) `on` read)
13:39:32 <lambdabot> forall a. (Num a, Read a) => (String, String) -> a
13:39:33 <IceDane> thought so
13:39:36 <IceDane> ah
13:39:39 <IceDane> spelling errors ftl
13:39:46 <harlekin> @ty on
13:39:47 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:39:56 <harlekin> @ty join
13:39:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:40:27 <harlekin> @src Monad (,)
13:40:27 <lambdabot> Source not found.
13:40:35 <harlekin> Is (,) a monad?
13:40:42 <harlekin> @src >>= (,)
13:40:43 <lambdabot> Source not found. stty: unknown mode: doofus
13:40:52 <yitz> harlekin: it's using the (->)a monad
13:41:01 <harlekin> yitz, ok.
13:41:18 <yitz> > join (*) 4
13:41:19 <lambdabot>   16
13:42:30 <aavogt> > let onBoth :: (forall b. a -> b) -> a -> (b,b); onBoth f x = (f x,f x) in onBoth read "100" :: (Int,Word)
13:42:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:42:31 <lambdabot>         against inferred type ...
13:43:09 <yitz> @type (&&&)
13:43:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:44:08 <yitz> @type join (&&&)
13:44:09 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
13:44:36 <mmx166mhz> everyone keeps talking bout Monads,- can someone explain the global idea of it?
13:44:59 <tibbe> Heffalump: did you want something or did you just feel like saying hi? :)
13:45:19 <yitz> where's that wiki page that lists all those monad tutorials?
13:46:19 <vic_> a monad is a monoid in the category of endofunctors, what's the problem?
13:46:24 <vic_> My favourite quote ahahaa
13:46:29 <Heffalump> just felt like saying hi :-)
13:47:01 <vic_> I feel like saying "Hi!" with the help of the IO monad
13:47:04 <mmx166mhz> is monoid the same one as from maths?
13:47:08 <doserj> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline ?
13:47:28 <yitz> @google monad tutorials
13:47:29 <lambdabot> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
13:47:30 <lambdabot> Title: Monad tutorials timeline - HaskellWiki
13:48:06 <vic_> mmx166mhz: Haskell has lots of math behind
13:48:20 <mmx166mhz> thats actually the reason I am interested in haskell
13:48:35 <mmx166mhz> I was looking for a maths based language
13:48:50 <vic_> Well, you've made the right choice
13:49:01 <vic_> What do you want to do in Haskell?
13:50:11 <vic_> Read this, btw http://lambda-the-ultimate.org/node/1276    it's a good topic
13:50:17 <mmx166mhz> solving maths related problems
13:50:22 <mmx166mhz> project euler things
13:50:42 <vic_> Ah, nice, nice
13:51:16 <vic_> All the P.E. problems are solved on the Haskell Wiki, but don't let that spoil the experience
13:51:43 <Twey> Physical education?  Portable executable?
13:51:48 <Twey> Oh, Project Euler.
13:51:51 <mmx166mhz> lol
13:52:17 <Twey> Well, Haskell is a general-purpose language.
13:52:36 <vic_> Solving Physical Education Problems in Haskell. Yeah, I'd love to see that book
13:52:40 <Twey> While it does in some areas take some inspiration from higher mathematics, it's not really a ‘maths-oriented’ language like Matlab.
13:53:06 <Twey> vic_: http://thedailywtf.com/Articles/Nerds,-Jocks,-and-Lockers.aspx
13:53:21 <yitz> or mathematica
13:53:24 <IceDane> How would I convert a "Maybe Int" to Int ?
13:53:35 <vic_> Twey: haha, I remember that post
13:53:36 <Kim^Walkman> IceDane: Look in the Data.Maybe package
13:53:40 <yitz> @type fromMaybe
13:53:41 <IceDane> Kim^Walkman: thanks
13:53:41 <lambdabot> forall a. a -> Maybe a -> a
13:53:43 <IceDane> ah
13:53:47 <aavogt> IceDane: what value do you want if it's Nothing though?
13:53:51 <Botje> IceDane: pattern matching.
13:53:59 <Botje> you can't not cater to the Nothing case
13:54:05 <Botje> unless you're absolutely positively sure.
13:54:08 <IceDane> I am :P
13:54:11 <yitz> @type maybe
13:54:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:54:27 <IceDane> I'm basically finding the minimum element in a list, then finding its index using elemIndex. Is there a better way, perhaps?
13:54:40 <simm> ne 1 here?
13:54:45 <IceDane> Nope.
13:54:50 <aavogt> @type Data.Traversable.foldr
13:54:50 <Botje> simm: just us chickens.
13:54:51 <lambdabot> Not in scope: `Data.Traversable.foldr'
13:54:59 <aavogt> @type Data.Foldable.foldr
13:55:03 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
13:55:05 <Guest9929> dam it, i joined haskell, is there a java room?
13:55:11 <IceDane> lol
13:55:20 <MoALTz> that is disturbing
13:55:22 <vic_> Haha
13:55:22 <Botje> IceDane: snd $ minimumBy (compare `on` fst) $ zip [0..] list
13:55:29 <Botje> Guest9929: that would be #java
13:55:51 <Cale> Guest9929: Or just learn Haskell ;)
13:55:56 <Guest9929> i did it in year
13:55:57 <aavogt> > fst $ minimum $ zip "hellloz" [0..]
13:55:57 <Guest9929> 1
13:55:58 <lambdabot>   'e'
13:56:03 <Guest9929> i never want to do it again thanks lol
13:56:11 <vic_> Don't mention it
13:56:11 <aavogt> > snd $ minimum $ zip "hellloz" [0..]
13:56:13 <lambdabot>   1
13:56:18 <vic_> And don't forget to check out Jaskell
13:56:19 <Botje> Guest9929: you like java better than haskell?
13:56:27 <Botje> Guest9929: that just shows you don't know java enough yet :)
13:56:27 <Guest9929> well i find it easier yes :D
13:56:35 <vic_> I like Java AND Haskell. Shoot me.
13:56:40 <Veinor> Data.MemoCombinators is really, really, really cool :D
13:56:44 * Kim^Walkman shoots vic_
13:56:52 <Veinor> I'm thinking of writing an article on how to use it.
13:56:53 * medfly shoots vic_ again to confirm death
13:56:56 <yitz> @slap vic_
13:56:56 * lambdabot slaps vic_
13:56:58 * vic_ drops dead 
13:57:13 <vic_> Yeah, saying that you like Java is pretty bad
13:57:15 <IceDane> aavogt: ooh, smart
13:57:15 <IceDane> thanks
13:57:20 <Botje> Guest9929: how is a visitorpatternfactoryfactory better than fmap :)
13:57:39 <vic_> It isn't
13:57:45 <vic_> Java EE sucks
13:57:47 <aavogt> I just rearranged Botje's code though
13:58:04 <Botje> yeah. i forgot about the Ord instance for (,)
13:58:05 <vic_> Java EE causes brain rot
13:58:13 <Guest9929> how do you join java then, is it /join space #java ?
13:58:25 <Botje> yes.
13:58:26 <Veinor> it'd be /join #java
13:58:30 <Botje> how did you get here?
13:58:48 <MoALTz> cosmic joke
13:58:54 <vic_> Seriouslly
13:58:55 <Guest9929> i just looked online for programming help chat room
13:59:00 <yitz> > let minIndex = snd . minimum . flip zip [0..] in minIndex [1,3,5,7,0,10]
13:59:01 <lambdabot>   4
13:59:33 <vic_> Hahah, that's rich  http://gogloom.com/DIR?cat=84126&catdesc=Programming
13:59:38 <vic_> It's the first link on google
14:00:13 <Botje> woah. i didn't know there was such a thing as an irc search engine
14:00:20 <aavogt> too much success?
14:00:20 <vic_> Aye
14:00:32 <vic_> #haskell is an awesome channel
14:00:35 <yitz> @google programming help chat room
14:00:35 <vic_> Googpe approves
14:00:36 <lambdabot> No Result Found.
14:00:41 <vic_> *Google
14:00:45 <Botje> :)
14:01:14 <IceDane> @google cookies
14:01:15 <lambdabot> http://allrecipes.com/Recipes/Desserts/Cookies/main.aspx
14:01:22 <vic_> Hm.
14:01:26 <vic_> Time for a screenshot
14:01:46 <vic_> There http://img211.imageshack.us/img211/5464/wellnow.png
14:02:00 <Botje> :)
14:02:06 <jcapper> 666 users
14:02:10 <vic_> @google cosmic joke
14:02:10 <lambdabot> No Result Found.
14:02:10 <Veinor> yitz: yitz ah, tuples of Ords sort lexicographically?
14:02:12 <jcapper> Ominous
14:02:18 <medfly> you should leave!
14:02:21 <Veinor> google changed their api?
14:02:25 <vic_> Google can't find cosmic jokes
14:02:34 <medfly> basically, if you want help with programming, all you have to do is be on freenode
14:02:51 <medfly> this channel even helped me with my C-ish problem
14:03:36 <DrSyzygy> You don't even have to be looking for programming help for #haskell to be helpful. I've gotten help with mathematics in here. And dating advice!
14:03:40 <yitz> Veinor: yep, lexigraphically (as pointed out previously by aavogt )
14:03:46 <vic_> #haskell: Total of 664 nicks, 0 IRC operators, 1 channel operators, 3 voiced, 88 marked away
14:03:49 <vic_> All good now
14:03:55 <Veinor> that's always convenient.
14:04:10 <jcapper> @users
14:04:10 <lambdabot> Unknown command, try @list
14:04:13 <jcapper> Oh.
14:04:23 <vic_> DrSyzygy: esp. dating advice
14:04:23 <jcapper> I could've sworn that worked at one point
14:04:31 <Veinor> we just need two... er three... more people!
14:04:33 <vic_> #Haskell is the place to be
14:04:44 <vic_> We need 777 people on #haskell
14:04:49 <yitz> preflex users
14:04:49 <medfly> to be lucky?
14:04:51 <Kim^Walkman> Where can you find the Ord implementations for different types?
14:04:58 <aavogt> "you can get medical advice in #haskell"?!?
14:05:01 <medfly> @src Ord
14:05:02 <lambdabot> class  (Eq a) => Ord a  where
14:05:02 <lambdabot>     compare      :: a -> a -> Ordering
14:05:02 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
14:05:02 <lambdabot>     max, min         :: a -> a -> a
14:05:07 <Kim^Walkman> Looking through hoogle but I can't find the instance declarations
14:05:22 <jcapper> Kim^Walkman : Try :info Ord
14:05:24 <jcapper> In GHCi
14:05:26 <yitz> jcapper: @seen was disabled due to a memory leak. I guess that means @users is also toast.
14:05:34 <medfly> preflex, users
14:05:34 <Kim^Walkman> jcapper: Ah, thanks
14:05:36 <jcapper> Assuming you have the module loaded with the instance you're using
14:05:37 <medfly> oh
14:05:44 <jcapper> yitz: Shame.
14:05:57 <aavogt> Kim^Walkman: you could also look at the haskell 98 report
14:06:01 <aavogt> @where onlinereport
14:06:01 <lambdabot> I know nothing about onlinereport.
14:06:09 <aavogt> @where report
14:06:09 <lambdabot> http://www.haskell.org/onlinereport/
14:06:11 <yitz> preflex: seen jcapper
14:06:11 <preflex>  jcapper was last seen on #haskell 27 seconds ago, saying: yitz: Shame.
14:07:17 <vic_> @where prelude
14:07:17 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
14:07:43 <danderson> So, am I right in thinking that fmap and liftM are in practice completely identical for most things, because most Functors are also Monads?
14:07:45 <vic_> seen dec142
14:08:00 <vic_> preflex: seen dec142
14:08:01 <preflex>  dec142 was last seen on #haskell 50 minutes and 8 seconds ago, saying: :) cool thanks I'll check that out as well _vic
14:08:08 <vic_> Oh well.
14:08:15 <vic_> What's preflex
14:08:23 <shrughes> danderson: yes they're identical and so are <$> and map and (.) when the types align
14:09:08 <yitz> danderson: they are only identical if you know that your functor is a monad. not every functor is a monad.
14:09:13 * hackagebot upload: joinlist 0.2.0 - Join list - symmetric list type (StephenTetley)
14:10:01 <danderson> yitz: right, but the two distinct functions exist only because of the lack of family ties between Functor and Monad in current Haskell, right?
14:10:21 <danderson> in a perfect world there would be only the Functor version, and by definition all Monads would be Functors
14:10:22 <yitz> danderson: right, it's mostly for historical reasons.
14:10:48 <danderson> okay, thanks. Just wanted to make sure I wasn't missing something.
14:10:58 <dibblego> danderson, same with (<$>) which has the exact same signature as fmap -- there are also specialisations like (.) and map
14:11:02 <yitz> danderson: some want <$> to be the only version. for a while, Cale was lobbying for (.) to be the only version.
14:11:27 * dibblego high-fives Cale 
14:11:37 <danderson> hmm
14:11:40 <aavogt> @type ()
14:11:41 <lambdabot> ()
14:11:43 <aavogt> @type (.)
14:11:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:11:44 <yitz> > (+ 5) . Just 7
14:11:45 <lambdabot>   Just 12
14:11:50 <yitz> heh
14:11:58 <danderson> not sure I see how (.) is similar to <$> from the type signatures
14:12:05 <DrSyzygy> @type (.)
14:12:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:12:09 <DrSyzygy> @type (<$>)
14:12:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:12:13 <dibblego> danderson, replace f with ((->) t)
14:12:36 <jcapper> Hmm, so why is ((,) a) not a monad, out of interest
14:12:56 <dibblego> (a -> b) -> ((->) t) a -> ((->) t) b
14:13:03 <DrSyzygy> jcapper: It is with additional properties for a.
14:13:12 <DrSyzygy> If a is a monoid, then ((,) a) is a monad.
14:13:13 <dibblego> (a -> b) -> (t -> a) ->  (t -> b)
14:13:44 <DrSyzygy> If it isn't a monoid, you can still make ((,) a) into a monad, but there's no canonical way to do it.
14:13:49 <jcapper> Oh, do you know if this is defined anywhere in the standard libraries?
14:14:11 <aavogt> DrSyzygy: what can you do for return then?
14:14:24 <aavogt> return = (,) undefined -- this is sort of ugly
14:14:51 <danderson> dibblego: aah, I see. I think.
14:14:58 <danderson> thanks.
14:15:15 <DrSyzygy> aavogt: Ooooh, doh. Yeah. you're right, we need assumptions on a.
14:15:22 <roconnor> how is ((,) Void) a monoid in any reasonable way
14:15:29 <roconnor> monad
14:16:10 <vic_> Any ideas on how to run this example http://www.serpentine.com/blog/2008/09/30/unix-hacking-in-haskell-better-pseudoterminal-support/
14:16:30 <vic_> Using the commands from http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
14:16:34 <yitz> roconnor: Void is not a monoid
14:16:39 <jcapper> @djinn (b,a) -> (b -> (c,a)) -> (c,a)
14:16:39 <lambdabot> f (a, b) c =
14:16:39 <lambdabot>     case c a of
14:16:39 <lambdabot>     (d, _) -> (d, b)
14:16:40 <roconnor> exactly
14:17:12 <vic_> I've ended up with foreign.hi  foreign.hs  foreign.o  test.c  test.o
14:17:16 <vic_> Now what...
14:18:17 <yitz> roconnor: using _|_ everywhere, the laws are satisfied vacuously. that's about the best you can do there.
14:18:58 <Cale> :t partition . runCont . return
14:18:59 <lambdabot> forall a. a -> [a -> Bool] -> ([a -> Bool], [a -> Bool])
14:19:39 <DrSyzygy> roconnor: You would agree that (Monoid a) => (Monad ((,) a)) though, right?
14:19:51 * Cale discovers that his old 'swing' combinator is just precomposition by runCont . return :)
14:20:08 <roconnor> DrSyzygy: that is the definition of the Writer Monad, yes.
14:20:11 * DrSyzygy never said anything about _reasonable_ ways above. :-)
14:20:26 <Cale> :t map . runCont . return
14:20:27 <lambdabot> forall r a. a -> [a -> r] -> [r]
14:20:49 <aavogt> @type mconcat (undefined :: [a -> r])
14:20:50 <lambdabot> forall a r. (Monoid r) => a -> r
14:21:01 <chrisdone> evening
14:21:09 <aavogt> @type sequence (undefined :: [a -> r])
14:21:10 <lambdabot> forall a a1. a -> [a1]
14:21:20 <DrSyzygy> More specifically, for each choice of a single element in a, we can generate at least two monads on ((,) a). Return gives you the pre-chosen element, and composition picks either the one, or the other, of the elements that need to be composed.
14:21:35 <Cale> :t foldr . runCont . return
14:21:36 <lambdabot> forall b a. a -> b -> [a -> b -> b] -> b
14:22:00 <DrSyzygy> So Monad ((,) a) where return x = (x, a0); join ((x,a),b) = (x,a) gives one.
14:22:09 <DrSyzygy> And join ((x,a),b) = (x,b) gives the other.
14:22:26 <roconnor> DrSyzygy: I don't think thwt will satify the monad laws.
14:22:30 <yitz> @type fix . runCont . return
14:22:31 <lambdabot>     Occurs check: cannot construct the infinite type: r = a -> r
14:22:31 <lambdabot>     Probable cause: `runCont' is applied to too many arguments
14:22:31 <lambdabot>     In the second argument of `(.)', namely `runCont'
14:22:52 <DrSyzygy> roconnor: It's certainly associative. Are you worrying about unitality?
14:22:58 <MoALTz> why are they called "infinite type"s anyway?
14:23:05 <yitz> @type (.) . runCont . return
14:23:06 <lambdabot> forall (f :: * -> *) r a. (Functor f) => a -> f (a -> r) -> f r
14:23:14 <DrSyzygy> Yeah, we'll probably need to add some if-case handlign to make a0 a unit...
14:23:15 <roconnor> DrSyzygy: in that case I don't think return >=> f  is equal to f
14:23:32 <Cale> MoALTz: because if you were to try to solve the equation r = a -> r for r, you would get something which looks like  a -> (a -> (a -> ...))
14:23:35 <roconnor> DrSyzygy: I think you are simply screwed
14:23:53 <yitz> @type id . runCont . return
14:23:54 <lambdabot> forall r a. a -> (a -> r) -> r
14:24:40 <yitz> @type curry . runCont . return
14:24:40 <lambdabot>     Couldn't match expected type `(a, b)'
14:24:41 <lambdabot>            against inferred type `a1 -> r'
14:24:41 <lambdabot>     In the second argument of `(.)', namely `runCont'
14:25:29 <shapr> Anyone in Huntsville AL or nearby, Haskell User's Group starting up, contact me for information!
14:33:48 <DrSyzygy> roconnor: If I have a type T, with some element t treated specially, of course I can define a monoid structure on T by setting m(a,b) = a; m(t,b) = b. It's going to be associative, and unital.
14:34:42 <DrSyzygy> roconnor: And since I have a monoid structure with this, I can do the Writer monad thing with it.
14:37:59 <DrSyzygy> roconnor: So the full definition'd be Monad ((,) T) where return x = (x, t); join ((x,t),b) = (x,b); join ((x,a),b) = (x,a)
14:38:52 <Scriptor> hey everyone, is there a function that does the opposite of takeWhile?
14:39:01 <PeakerWork> Scriptor: dropWhile?
14:39:21 <PeakerWork> takeWhile . not ?
14:39:21 <Scriptor> that's what it was! thanks!
14:39:24 <PeakerWork> @type takeWhile . not
14:39:24 <lambdabot>     Couldn't match expected type `a -> Bool'
14:39:24 <lambdabot>            against inferred type `Bool'
14:39:24 <lambdabot>     Probable cause: `not' is applied to too many arguments
14:39:32 <PeakerWork> @type takeWhile . (.not)
14:39:33 <lambdabot> (Bool -> Bool) -> [Bool] -> [Bool]
14:45:02 <sleepynate> hello happy hackers
14:53:51 <tibbe> dons: I've been doing some hacking on haddock today, perhaps, after I'm done cleaning up the HTML generation and styling, we could add some extra functionality and AJAX goodness
14:54:12 <sioraiocht> tibbe: AJAX? =(
14:54:22 <tibbe> sioraiocht: javascript stuff
14:54:25 <sioraiocht> I know
14:54:26 <sioraiocht> but
14:54:38 <sioraiocht> static html is so much...easier
14:54:44 <tibbe> sioraiocht: sure, it's optional
14:54:56 <sioraiocht> I feel okay about that, then =)
14:54:57 <tibbe> sioraiocht: like a nice sliding expanding show source box
14:55:06 <tibbe> sioraiocht: perhaps a way to leave comments
14:55:10 <sioraiocht> Hrm
14:55:17 <tibbe> sioraiocht: (see the latest release of Ruby's YARD)
14:55:31 <Heffalump> most really usable web pages these days use JS
14:58:07 <dons> tibbe: check the link i posted on twitter about ruby's new document/comment server
14:58:10 <dons> for their library docs
14:58:20 <tibbe> dons: read it
14:59:13 <idnar> instance AdaptList Int where
14:59:13 <idnar>  data List Int = EmptyInt | ConsInt {-# UNPACK #-}!Int (List Int)
14:59:25 <idnar> huh, I didn't know you could stash a data definition in an instance definition
15:00:23 <Saizan_> idnar: only with associated types
15:00:28 <eivuokko> idnar, called type families (or in that case called assosiated types).  Not H98, but ghc extension.
15:01:26 <idnar> ah, of course
15:01:41 <idnar> I didn't make the mental connection with type families
15:05:15 <Absolute01> Why am I getting an indent parse error when I load this file: http://pastie.org/700283 ?
15:05:24 <Absolute01> should deriving go on the next line?
15:05:38 <Absolute01> commenting out the let input... line fixes it
15:05:41 <Absolute01> but i need it.
15:05:56 <stroan> you use let in ghci like that
15:06:03 <stroan> in a source file just input = ...
15:06:04 <Absolute01> ah :)
15:06:11 <Absolute01> stupid mistake, thanks
15:07:00 <tibbe> dons: I think there's two things to do. The simpler one is to spicy up the HTML output
15:07:08 <tibbe> dons: and then all the dynamic functionality
15:07:10 <monochrom> "indent error" because "let" is expected to be followed by "in" but not found, so suspects indentation.
15:07:49 <Absolute01> Would adding costFromRoot, and heuristicTillGoal fields to the data structure be an effecient way of implementing an A* search in haskell?
15:08:04 <Absolute01> or should I place those fields in a separate data structure?
15:10:21 <NinjaUnderCover> I HEARD TEH ITNERNETZ IS HEREZ
15:10:42 <ben0x539> Well heard.
15:11:06 <eivuokko> Absolute01, Wouldn't that depend on your use case, regardless of language?  Although, compared to non-lazy languages, putting in a data structure might be relatively cheaper in worse-case (as it's not evaluated before you ask).
15:11:52 <Absolute01> data Tree a = Void | Node a cost heuristic (Tree a) (Tree a) <-- is this the best way to name those fields?
15:12:12 <Absolute01> I should probably defien cost and heuristic before hand
15:12:29 <Absolute01> and then do Node a (Cost b) (Heuristic c) ...
15:14:31 <mike8901> If I have many pairs (person, manager), and I want to find a) All of the managers above the person, and b) All of the reports below the person, is there an elegant way to do that with list comprehensions?
15:15:05 <dons> tibbe: yep
15:15:31 <Heffalump> mike8901: well, the direct relationships are easy with list comprehensions
15:15:39 <Heffalump> you'll need to write the recursion yourself to get the indirect ones
15:15:39 <mike8901> yeah, I got that
15:15:43 <mike8901> hm ok
15:15:56 <stoop> mike8901, given a (person, manager) does there exist a (person', manager') where person' = manager?
15:16:14 <mike8901> yes
15:16:17 <blackdog> anyone got any tips on using c2hs with cabal? I have Foor/Bar.chs, but cabal's complaining about not finding the Foo.Bar module
15:16:23 <mike8901> there is a "Root" manager
15:16:33 <mike8901> (for which that doesn't hold) - but for all other cases it does
15:24:44 <blackdog> gah, it just doesn't do dependency analysis, you have to list the modules in the right order. oh well, at least it's working now.
15:26:20 <dschoepe> Is there a way to get cabal to create a hoogle file and merge it with something like ~/.cabal/all.hoo automatically when installing a package?
15:27:11 <mike8901> Is there a builtin funciton that flattens a list in haskell
15:27:14 <mike8901> ?
15:27:33 <tensorpudding> > concat [[1..10],[11..20]]
15:27:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
15:28:00 <blackdog> mike8901: it'll only flatten it one level, though.
15:28:06 <mike8901> hrm
15:28:18 <mike8901> anything that does it recursively to a large depth?
15:28:29 <blackdog> but then, you can't really even write a type for a function that would do it for arbitrary nestings
15:28:43 <dolio> > concat . concat . concat $ [[[[1..5]]]]
15:28:44 <lambdabot>   [1,2,3,4,5]
15:29:07 <blackdog> if you have a large, arbitrarily nested list of lists of ... , you may be doing something wrong
15:29:22 <mike8901> so the issue is from before, I want to find all of the reports to a given person
15:29:36 <mike8901> where I have a db of pairs (name, manager)
15:29:41 <mike8901> I want to find all people that report to a given name
15:29:51 <dolio> How many nestings of lists you have is statically known in Haskell.
15:29:52 <mike8901> (if that makes sense)
15:29:56 <blackdog> where does the nested list come from, then?
15:30:04 <mike8901> basically, name is a string, manager is a string
15:30:16 <dolio> Otherwise you'd have to be using a rose tree type, which would have its own flattening function.
15:30:29 <mike8901> I'm getting the nested lists from finding the direct reports, and the direct reports to those direct reports, and ....
15:30:50 <mike8901> actually, concat may work
15:30:59 <mike8901> since at any given moment in time, I'd only have 1 nesting
15:31:02 <blackdog> mike8901: if you concat at each stage
15:31:05 <mike8901> yeah
15:31:06 <blackdog> yes, exactly
15:31:06 <mike8901> that would work
15:32:17 <BONUS> yeah that's a common thing
15:32:26 <BONUS> when doing breadth first
15:32:44 <BONUS> and similar algorithms
15:33:23 <skorpan> use a breadth knife...
15:33:31 <skorpan> take a breadth mint...
15:33:45 * blackdog takes a deep breadth
15:33:50 <skorpan> those are the completely unrelated puns of tonight.
15:34:00 <blackdog> skorpan: just awful:)
15:34:23 <skorpan> can you do breadther?
15:35:00 * blackdog suspects he has completely broken his Cabal installation. cabal-install seems to refuse to download anything, but doesn't get an error until it actually tries to apen the thing it allegedly downloaded
15:35:53 <blackdog> skorpan: nah, couldn't be bothered. I'm just loafthing about.
15:37:45 <Heffalump> blackdog: is this with a dev cabal-install?
15:38:06 <blackdog> Heffalump: 0.7.5, so possibly
15:38:17 <blackdog> and 1.8.0 of Cabal
15:38:19 <Heffalump> so from darcs?
15:38:22 <Heffalump> if so, try updating
15:38:36 <Heffalump> there was a bug with it downloading stuff but then screwing up where the temp file ended up
15:38:44 <blackdog> yeah, i think so. thanks, i'll give it a go.
15:38:57 <Heffalump> (I think it's fixed now, anyway. If not, then you might need to roll backwards instead)
15:42:13 <blackdog> Heffalump: ah, should have tried that first. thanks, all good.
15:44:36 <gwern> > 3 / 4100
15:44:37 <lambdabot>   7.317073170731707e-4
15:44:45 <gwern> > (11 / 4100) * 100
15:44:47 <lambdabot>   0.2682926829268293
15:46:01 <skorpan> what's up with freenode versioning me every once in a while?
15:46:15 <gwern> security, iirc
15:46:22 <gwern> like its auto-kline setup
15:46:34 <skorpan> but i mean, anyone could *easily* fake that reply
15:49:15 <danderson> so, my ghci is rather annoying in that only half of the normal readline stuff seems to work: home/end keys print garbage, as do C-<arrows> and M-<arrows>. Is there a way to fix this?
15:49:39 <ben0x539> I managed to get home/end keys working by setting my TERM environment variable to something else.
15:50:14 <danderson> what something else?
15:50:55 <ben0x539> rxvt
15:51:26 <danderson> hmm, still doesn't work for me. I sense something stupid at work.
15:52:12 <ben0x539> C-<arrows> never worked for me :<
15:52:15 <gwern> I wonder whether anyone has written a pure union-find. it seems kind of odd we only have one in IO
15:54:22 <danderson> FWIW, http://hackage.haskell.org/trac/ghc/ticket/2606 tracks the history of this problem.
15:54:34 <danderson> Apparently, it's the readline packaged in ubuntu that is being stupid.
15:54:44 <ivanm> of course it is
15:54:57 * ivanm has no idea what danderson is talking about, but agrees with any comment regarding ubuntu being stupid
15:54:58 <ivanm> ;-)
15:55:08 <ben0x539> But ghci uses haskeline now, I thought.
15:55:12 <patch-tag> say you have lazy io and you want to use it in Control.Exception.bracket, any way?
15:55:16 <patch-tag> strict version of bracket?
15:55:16 <ivanm> ben0x539: for 6.10.4
15:55:17 <danderson> ben0x539: HEAD probably does
15:55:18 <ben0x539> Also, fwiw it does not work right on gentoo either
15:55:24 <blackdog> ivanm: take your troll mask off:)
15:55:33 <ivanm> danderson: nope, 6.10.4 does
15:55:37 <ivanm> ben0x539: what doesn't work right?
15:55:43 <ivanm> _everything_ works right in gentoo!
15:55:46 <ben0x539> Well, vi-mode for once
15:55:52 <ivanm> oh, yi?
15:55:56 <ben0x539> No
15:56:00 <ivanm> I thought we were talking about ghci...
15:56:01 <danderson> indeed, fixes suggested in the bug relating to editline don't work
15:56:03 <ben0x539> We are!
15:56:10 <danderson> so it's haskell that is borked!
15:56:11 <ben0x539> Yi does not work either, but that is probably my system.
15:56:12 <ivanm> there's vi-mode for ghci?
15:56:19 <mauke> ivanm: man readline
15:56:22 <ben0x539> No, but there is one for haskeline. And it does not work.
15:56:23 <ivanm> blackdog: heh
15:56:35 <ivanm> mauke: what does readline have to do with ghci nowadays?
15:56:44 <mauke> I use it, and it works
15:57:01 <ben0x539> _nothing_ works right in gentoo, it cannot even update my system without tripping over itself
15:57:10 <ivanm> blackdog: I've had enough problems with ubuntu, and that was on other people's machines
15:57:16 <ben0x539> I am clearly a victim to stackholm syndrome
15:57:18 <ivanm> ben0x539: then that's your fault (usually)
15:57:20 <ben0x539> for still using it, I mean
15:57:34 <ben0x539> ivanm: Well, yeah. That is what I would say if I was with gentoo.
15:57:34 <ivanm> mauke: 6.10.4 still has readline?
15:57:43 <mauke> ivanm: no, I use 6.10.2
15:57:49 <ivanm> mauke: ahhh
15:57:49 <danderson> so, the net result is that ghci is an annoying distraction to use. Sucks. Guess it's back to ghc and main = print foo
15:58:01 <blackdog> ivanm: it screws up a fair bit, but no more often than anything else i use. I get way more grief from Cabal:)
15:58:06 <ivanm> yeah, kolmodin got ghci patched to use readline, we use that in gentoo for 6.10.{1,2,3}
15:58:14 <gwern> nothing worked right on gentoo for me, but that's because I didn't stay in a stage 1 install, so IT IS ALL MY FAULT
15:58:32 <gwern> (is gentoo still around? I don't hear much these days)
15:58:34 <ivanm> blackdog: I find it annoying that you have two completely separate package managers that don't interact (the gui and the command line)
15:58:39 <ivanm> gwern: ummm, who uses a stage 1?
15:58:43 <ben0x539> Not even revdep-rebuild works anymore! :'(
15:58:55 <ivanm> then yes, you probably stuffed something up
15:59:05 <gwern> ivanm: I - I was being sarcastic, did you not understand my quip?
15:59:26 <blackdog> ivanm: uh, what? they're just interfaces to dpkg, aren't they?
15:59:28 <ben0x539> ivanm: I seem to have a hard time using gentoo without making it explode.
15:59:29 <ivanm> gwern: oh, right
15:59:51 <ivanm> blackdog: well, the gui didn't list all packages, and if I installed a package in one UI then the other didn't have it listed (normally the GUIs fault AFAICT)
15:59:58 <ben0x539> For some reason, it wants to depend on a bunch of stuff that is masked.
16:00:13 <ben0x539> I did not set up the portage tree! How can that be my fault!
16:00:36 <ben0x539> And I certainly did not touch any .la files!
16:00:51 <ivanm> probably because you're either using old stuff that is gone, or new stuff where you've only partially unmasked it
16:01:09 <ben0x539> Nope
16:01:22 <ivanm> IMHO, if you don't _fully_ update your system at least once a week, then you have no reason to complain if your gentoo install doesn't work
16:01:42 <gwern> a good reason why no one should use gentoo
16:02:02 * ivanm updates every day...
16:02:04 <ben0x539> IMHO, if I cannot fully update my system without spending an hour googling for obscure bugs, I cannot really be expected to update it each week.
16:02:17 <ben0x539> s/bugs/errors/
16:02:24 <ivanm> ben0x539: I don't (usually)
16:03:11 <ben0x539> gentoo needs a goddamn "figure out what packages are responsible for _____ not working and in what order to reinstall them to make the problem go away" button
16:03:20 <ben0x539> because clearly the package manager would be better at that than I am
16:03:43 <ben0x539> Uh, sorry for getting so excited about it.
16:03:53 <ivanm> ummm, unlike most distros, Gentoo isn't GUI by default...
16:03:57 <ivanm> so where would you put the button?
16:03:58 <jlouis> Oh look, a Z monad!
16:04:02 <ivanm> jlouis: heh
16:04:04 <ben0x539> A metaphorical button!
16:04:11 <int-e> ben0x539: use a different distro then
16:04:13 <ben0x539> emerge -uavND world --justfixit
16:04:36 <ivanm> int-e: exactly; if you bitch about distro X, then you shouldn't use distro X
16:05:01 <int-e> gentoo is for people with too much time at their hands. (I have one gentoo box. I use debian (unstable) on work machines)
16:05:06 <ben0x539> If I followed that logic, I would probably sit in a cave and bitch about my campfire not working properly
16:05:18 <ivanm> (besides, the problems are either due to the dev in charge of a package or the package manager, not the distro itself; assuming it's not a PEBKAC issue)
16:05:19 <blackdog> ivanm: there are two sorts of systems in the world: the ones people bitch about, and the ones no-one uses
16:05:26 <Polarina> If I have a function (String -> String) that pattern matches the first String in all definitions, would ghc optimize that to a hash table/binary tree or something just as fast?
16:05:44 <ivanm> blackdog: yes, but that doesn't mean people bitch about the system they use; just other systems
16:05:49 <Twey> ivanm: I suggest F12.
16:05:52 <ivanm> case in point: I bitch about ubuntu and it exists!
16:05:59 <int-e> gentoo has advantages. for example you won't ever need to install any -devel packages. and if you want the sources of something installed on your machine, they're usually in /usr/portage/distfiles.
16:05:59 <ivanm> Twey: why? I have no problems with gentoo
16:06:02 <kmc> Polarina, good question.  you can make it print out its intermediate code
16:06:06 <ben0x539> I use gentoo on my personal machine because I really like the idea of USE flags and it is usually better at having up-to-date packages than debian, as far as I am aware.
16:06:06 <ivanm> Twey: and IIRC, F12 isn't out yet
16:06:11 <ben0x539> And what int-e just said.
16:06:11 <Twey> 00:03:58 < ivanm> so where would you put the button?
16:06:14 <blackdog> why would you bitch about something you don't use? it doesn't affect you.
16:06:18 <Twey> The F12 button.  :þ
16:06:23 <int-e> and you can learn a lot from when things go wrong. ;)
16:06:30 <ivanm> Twey: oh, wrong meaning of F12
16:06:31 <blackdog> I bitch about Haskell and Mac OS X all the time, but you'll have to pry them out of my cold dead hands
16:07:11 <ivanm> blackdog: I've had to use ubuntu on machines that were not my own; and I'm sick of reading about stupid people that think that linux == ubuntu
16:08:12 <ahf> how can you be a gentoo user and get sick of reading about stupid users?
16:08:21 <blackdog> ivanm: yeah, isn't it awful how those webpages just jump down your optic nerve and force you to read them? :)
16:08:41 <blackdog> hey, style question - where do you put your C files in a Cabal package?
16:09:04 <dcoutts> blackdog: depends, if it's just little bits, people often use cbits/
16:09:06 <int-e> blackdog: I've seen "cbits" several times
16:09:07 <gwern> cbits/, is comon enough
16:09:15 <blackdog> ah, that's what i was looking for. cheers.
16:09:19 <ben0x539> ... so something pulls in a package that is masked. And I cannot find out which one by using equery depends because, well, it is masked.
16:09:23 <ben0x539> :argh:
16:09:42 <ivanm> ahf: I do get sick about reading about stupid users (like the guy that kept insisting that visudo _has_ to use vi)
16:09:49 <int-e> ben0x539: emerge -pv will tell you what pulls in what
16:09:52 <ivanm> blackdog: heh
16:10:24 <ahf> ivanm: i found it highly amusing after diego started whining about it.
16:10:30 <ben0x539> This is from inside revdep-rebuild that I am running because apparently some .la/.a files mysteriously disappeared
16:10:30 <ivanm> ben0x539: --tree IIRC
16:10:43 <ivanm> ahf: heh
16:10:54 <gwern> ivanm: visudo? is that like sudoedit?
16:10:55 <ahf> he needs to figure out the mask reason before he can use --tree.
16:10:56 <ivanm> ben0x539: which ones? did you run lafilefixer?
16:10:57 <ahf> also, paludis.
16:11:03 <ivanm> gwern: never heard of sudoedit
16:11:19 <ivanm> ahf: does he? doesn't it list the dep reasons in more detail than just -pv ?
16:11:42 <ahf> i think it makes a complete graph prior to displaying it.
16:11:54 <ivanm> *shrug* I use paludis ;-)
16:11:57 <ahf> good!
16:12:18 <blackdog> ok. And haskell files that are just tools that use the underlying library - they just live in the top directory?
16:12:20 <ben0x539> Now a thing is depending on ghc-6.12
16:12:24 <ben0x539> I wonder what I did to deserve this.
16:12:28 * ivanm really should go and enable the write cache, as paludis is taking way too long nowadays
16:12:39 <ivanm> ben0x539: which package? extensible-exceptions?
16:12:43 * ivanm is pushing a patch to mask it now
16:12:44 <ben0x539> yes
16:12:46 <ahf> ivanm: tried Exherbo? we've a couple of haskell guys already.
16:12:53 <ivanm> nope
16:12:59 <ivanm> if I switch, it might be to nix
16:13:03 <ben0x539> I wonder what pulled it in
16:13:19 <ahf> nix' is academic wanking!
16:13:24 <fxr> hmm
16:13:28 <ben0x539> "A distribution 'designed for people who know what they're doing with Linux'"
16:13:33 <ben0x539> That sounds even less supportive than gentoo
16:13:46 <ahf> ben0x539: it's far less supportive than gentoo.
16:13:55 <ahf> most of us are old gentoo users and developers.
16:14:00 <ben0x539> Right
16:14:29 <ahf> time to get some sleep. night.
16:14:44 <fxr> http://hackage.haskell.org/packages/archive/fastcgi/3001.0.2.2/doc/html/src/Network-FastCGI.html do you think that runFastCGIConcurrent' is the possible suspect for a hanging process which tries to killThread a worker upon a sigterm?
16:15:48 <ben0x539> I really want to like gentoo :'(
16:16:16 <fxr> I tried to use MSem (which is on haskell wiki) but unable to kill the thread immediately.
16:16:41 <blackdog> I don't really understand the point of using an OS that you have to understand intimately, unless you're actively hacking OSes
16:17:03 <blackdog> surely the point is for it to get out of your way so you can focuse on what you're really interested in?
16:17:33 <ben0x539> blackdog: In my arguably limited experience, the OS getting out of my way is an unrealistic ideal
16:17:38 <jlouis> blackdog: some people like the idea of knowing what happens inside. I was one of those a couple of years ago
16:17:50 <jlouis> ... now I just run Ubuntu and hack Haskell
16:17:56 <ben0x539> and when something inevitably breaks down, I would rather not have to cut through multiple layers of chrome to get to the stuff that is actually broken
16:18:00 <jlouis> and Coq and Twelf and ... :)
16:18:25 <blackdog> jlouis: i'm even more decadent than you - i run Mac and hack Haskell:)
16:18:59 <blackdog> ben0x539: the breakdown isn't really inevitable, though. so long as you're not running cutting-edge stuff, you're usually ok.
16:19:19 <blackdog> i run cutting-edge haskell stuff because i need the features, and i accept the breakage as a necessary cost
16:19:30 <Saizan_> blackdog: or you're running somewhat older hardware
16:19:34 <ivanm> ahf: :o (about nix)
16:19:44 <Saizan_> blackdog: or somewhat less common needs, etc..
16:19:51 <fxr> anybody?
16:20:26 <ben0x539> fxr I am afraid I have no familiarity with what you are doing so rest assured I am not just maliciously ignoring you :(
16:20:27 <blackdog> Saizan_: not quite sure what you mean there
16:20:30 <Saizan_> blackdog: i like having a really simple system that i can mostly ignore but that i can understand if i want/need to
16:20:47 <fxr> okay
16:21:15 <blackdog> Saizan_: any *nix is like that, surely. Some more than others, granted
16:22:06 <chrisdone> why is the credit roll music in movies always contrary to the music that preceded it not a second before?
16:23:07 <Saizan_> fxr: does the worker thread that you're killing does something weird with exception handling?
16:23:21 <Absolute01> May I have guards within a where clause?
16:23:28 <Saizan_> fxr: make sure the exceptions aren't blocked
16:23:33 <mmorrow> chrisdone: for closure
16:23:52 <mmorrow> chrisdone: also, sup!
16:23:58 <Saizan_> Absolute01: yes, foo = ..; where x | .. = .. | .. = ..
16:25:00 <Absolute01> is there a nice way to call notElem on a list of lists?
16:25:06 <ben0x539> map?
16:25:31 <mmorrow> @type (\x -> fmap (not (x`elem`)))
16:25:32 <lambdabot>     Couldn't match expected type `Bool'
16:25:33 <lambdabot>            against inferred type `[a] -> Bool'
16:25:33 <lambdabot>     In the first argument of `not', namely `(x `elem`)'
16:25:37 <mmorrow> @type (\x -> fmap (not . (x`elem`)))
16:25:39 <lambdabot> forall a (f :: * -> *). (Eq a, Functor f) => a -> f [a] -> f Bool
16:25:49 <Saizan_> fxr: with http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Ablocked
16:25:51 <Absolute01> and map (\x xs-> notElem x xs) list
16:25:55 <mmorrow> @type (\x -> fmap (not . (x`elem`))) :: Eq a => a -> [a] -> [[a]]
16:25:55 <Absolute01> i guess that would work
16:25:55 <Absolute01> thanks
16:25:56 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Bool'
16:25:56 <lambdabot>     In the first argument of `(.)', namely `not'
16:25:56 <lambdabot>     In the first argument of `fmap', namely `(not . (x `elem`))'
16:25:56 <Absolute01> :)
16:26:06 <Absolute01> havent used haskell for a while :)
16:26:07 <mmorrow> @type (\x -> fmap (not . (x`elem`))) :: Eq a => a -> [[a]] -> [Bool
16:26:08 <lambdabot> parse error (possibly incorrect indentation)
16:26:10 <mmorrow> @type (\x -> fmap (not . (x`elem`))) :: Eq a => a -> [[a]] -> [Bool]
16:26:11 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [Bool]
16:26:13 <mmorrow> haggah!
16:26:17 <mmorrow> :)
16:26:20 <Absolute01> notElem is in prelude
16:26:35 <mmorrow> so is not and (.) !
16:26:38 <mmorrow> ;)
16:27:06 <mmorrow> @src notElem
16:27:06 <lambdabot> notElem x =  all (/= x)
16:27:13 <fxr> Saizan_: http://npaste.de/debugfcgi/ here is a test case
16:27:19 * mmorrow was hoping for (not .) . elem
16:27:38 <mmorrow> @src all
16:27:38 <lambdabot> all p =  and . map p
16:27:45 <ivanm> @hoogle elem
16:27:46 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
16:27:47 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
16:27:47 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
16:27:47 <mmorrow> @src elem
16:27:47 <lambdabot> elem x    =  any (== x)
16:27:52 <fxr> Saizan_: I'm running it as: cgi-fcgi -start -connect localhost:8999 dist/build/debug.fcgi/debug.fcgi 1
16:27:53 <mmorrow> heh
16:28:12 <ivanm> hmmm, I thought there'd be a (not .) . elem function as well
16:28:25 <mmorrow> pivot on the any/all /=/== is just as "cool" i guess
16:28:35 <fxr> Saizan_: and testing it with http://npaste.de/3q/
16:28:45 <ivanm> mmorrow: true
16:29:08 <ivanm> mmorrow: except that that way isn't as obvious as an explicit not
16:29:11 <roconnor> haskell is making me lazy: To solve a chinese remainder problem I just filtered all the numbers until I found the first solution.
16:29:14 <fxr> Saizan_: it stales when I send sigterm to the process
16:29:16 <ivanm> roconnor: heh
16:29:26 <mmorrow> ivanm: yeah, also true
16:29:26 <jlouis> roconnor: haha
16:29:33 <roconnor> 75496 was just too easy to find.
16:30:03 <ben0x539> Were we not talking about how ghci does not work, a while ago?
16:30:06 <Absolute01> Are variable length args impossible in haskell without lists?
16:30:20 <ben0x539> Absolute01: Not necessarily, consider the implementation of Text.Printf
16:30:23 <Saizan_> fxr: does it print "Exiting..." ?
16:30:32 <roconnor> Absolute01: there are terrible terrible class hacks that can do var lenght arguments too.
16:30:39 <fxr> Saizan_: yes it does
16:30:42 <Absolute01> how can I define a function that accepts multiple lists?
16:30:51 <mmorrow> @src zip
16:30:51 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:30:52 <lambdabot> zip _      _      = []
16:30:57 <roconnor> Absolute01: take a list of lists?
16:31:02 <fxr> Saizan_: but I think the semaphore code doesn't terminate
16:31:08 <Absolute01> roconnor: that seems ugly
16:31:15 <roconnor> Absolute01: nope
16:31:16 <mmorrow> @src transpose
16:31:16 <lambdabot> transpose []             = []
16:31:16 <lambdabot> transpose ([]   : xss)   = transpose xss
16:31:16 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
16:31:27 <roconnor> @type transpose
16:31:28 <lambdabot> forall a. [[a]] -> [[a]]
16:31:29 <Saizan_> fxr: i don't see any semaphore code
16:31:46 <roconnor> @type concat
16:31:46 <lambdabot> forall a. [[a]] -> [a]
16:31:48 <Absolute01> where is forall defined?
16:31:48 <mmorrow> @. pl undo transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
16:31:49 <lambdabot> (line 1, column 28):
16:31:49 <lambdabot> unexpected "="
16:31:49 <lambdabot> expecting variable, "(", operator or end of input
16:31:51 <roconnor> @src concat
16:31:51 <lambdabot> concat = foldr (++) []
16:31:56 <Absolute01> roconnor: easy with the bot please.
16:32:00 <Absolute01> you're flooding the room
16:32:05 <fxr> Saizan_: oh it is in Network.FastCGI.runFastCGIConcurrent
16:32:05 <mmorrow> @. pl undo (\((x:xs) : xss) -> (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss]))
16:32:06 <lambdabot> (line 1, column 57):
16:32:06 <lambdabot> unexpected "{"
16:32:06 <lambdabot> expecting variable, "(", operator or ")"
16:32:19 <roconnor> Absolute01: forall is a GHCism
16:32:37 <Absolute01> :t forall in ghci fails
16:32:38 <lambdabot> parse error on input `in'
16:32:40 <Absolute01> all works
16:32:41 <roconnor> well, it is probably an ism for most haskell compilers.
16:32:45 <fxr> Saizan_: http://hackage.haskell.org/packages/archive/fastcgi/3001.0.2.2/doc/html/src/Network-FastCGI.html here it is
16:32:48 <Saizan_> Absolute01: forall is not a function
16:32:52 <Saizan_> Absolute01: it's syntax
16:33:16 <roconnor> Absolute01: are you looking for the all function?
16:33:18 <roconnor> @type all
16:33:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:33:27 <Absolute01> forall is syntax?
16:33:49 <mmorrow> Absolute01: depends on which extensions are on
16:34:02 <mmorrow> and in what context the word "forall" appears
16:36:32 <krainbolt> Fine. Leave then.
16:36:48 <Absolute01> What's the most elegan way to append 2 values to a list, each value gets added on a condition?
16:36:48 <krainbolt> I didn't love you anyways ;_;
16:37:19 <Absolute01> I am doing l1 = this:original if..., l2 = that:l1 ...
16:37:47 <heatsink> How about using an auxiliary appendIf function?
16:38:05 <Absolute01> heatsink: that's better but still messy. :)
16:38:27 <Absolute01> i guess i could try doing something with monads
16:38:29 <krainbolt> Which BONUS is the BONUS behind LYSHFGG? :(
16:38:31 <Absolute01> maybe thats overkill
16:38:43 <Saizan_> Absolute01: [that | cond2] ++ [this | cond1] ++ original
16:39:00 <Absolute01> guards can be used anywhere?
16:39:02 <Absolute01> thats cool!
16:39:06 <Saizan_> > [1 | True ] ++ [2 | False] ++ [3]
16:39:07 <lambdabot>   [1,3]
16:39:13 <Saizan_> not anywhare
16:39:13 <heatsink> guards can be used in list comprehensions.
16:39:38 <blackdog> How do you give an executable in a Cabal file access to the libraries defined in that file? Cabal is complaining that I need at least cabal-version: > 1.8 for that - surely this is a pretty common use case?
16:39:54 <monochrom> guards can be everywhere in a police state <duck>
16:39:57 <mmorrow> @let bool true false o = if o then true else false
16:40:00 <lambdabot>  Defined.
16:40:10 <dcoutts> blackdog: it's correct, it's a new feature in cabal-1.8
16:40:20 <mmorrow> > (\o -> bool 1 2 o : 3) False
16:40:21 <lambdabot>   No instance for (GHC.Num.Num [t])
16:40:21 <lambdabot>    arising from the literal `3' at <inter...
16:40:26 <roconnor> Saizan_: heh, I've never though about using guards in list comprehensions that are constant for that list.
16:40:28 <dcoutts> blackdog: otherwise you can just import the same source modules directly
16:40:28 <mmorrow> > (\o -> bool 1 2 o : [3]) False
16:40:30 <lambdabot>   [2,3]
16:40:47 <dcoutts> blackdog: and they'll be built once for each component that uses them
16:40:51 <Saizan_> fxr: i'd first insert a print statement after killThread to tell if it completes, and if so then i'd go messing with runFastCGIConcurrent'
16:40:52 <patch-tag> I have a patch for versioned show files, fixing http://bugs.darcs.net/issue1499
16:41:01 <blackdog> dcoutts: oh, ok. yeah, that's not too bad.
16:41:19 <Saizan_> roconnor: i think i've taken that from ndm :)
16:43:17 <fxr> Saizan_: hmm ok tryin...
16:44:06 <Saizan_> fxr: ehm, i meant if it doesn't complete
16:44:50 <Saizan_> since in that case the thread should have been accepted the exception killThread is throwing
16:45:00 <Saizan_> s/been//
16:45:05 <fxr> Saizan_: well quick answer, i sent a kill and it only logged Exiting... killThread not returned
16:46:26 <fxr> Saizan_: when I connect repeatedly to the fcgi app, it terminates cleanly.
16:48:23 <Saizan_> fxr: are you compiling with -threaded ?
16:48:31 <fxr> Saizan_: yes I am
16:49:10 <fxr> btw this is ghc 6.10.4
16:49:22 <fxr> on 64 bit linux
16:49:26 <Saizan_> maybe the problem is that acceptRequest is waiting inside the foreign call, so the ThreadKill exception can't be delivered to that thread
16:50:33 <fxr> Saizan_: well if so it should terminate upon first request isn't it?
16:50:46 <fxr> but it accepts more than one request
16:50:47 <Saizan_> fxr: true
16:51:18 <Saizan_> that could be an effect of scheduling..
16:51:54 * dcoutts emails authors about broken packages that will be even more broken with the new cabal-install releases
16:52:05 <dcoutts> dons_: ghc-core is one of them btw
16:52:28 <dcoutts> dons_: you knew that "build-depends: base < 10" would come back to bite you :-)
16:52:36 <dcoutts> @slap dons_
16:52:37 * lambdabot moulds dons_ into a delicous cookie, and places it in her oven
16:52:40 <ivanm> dcoutts: I've already bitched to him about it, since it doesn't even work with base-4!
16:52:44 <fxr> hmmm
16:52:48 <Saizan_> are you testing on 6.12?
16:52:58 <dcoutts> ivanm: yes, and that's what the new cabal-install notices too
16:53:07 <blackdog> on the flipside, base-4 and haskell-src seems to work if you munge the cabal file
16:53:09 <dcoutts> since it'll use base 4 by default if you use an upper bound
16:53:20 <blackdog> (not exhaustively tested, though)
16:53:22 <dcoutts> Saizan_: only 6.10 atm
16:53:23 <Saizan_> fxr: at this point i'd try adding some print statements inside the FastCGI source
16:53:37 <ivanm> dcoutts: when do you plan on having PVP opt-in for cabal?
16:54:01 <dcoutts> ivanm: when I have any time to implement it
16:54:05 <ivanm> heh
16:54:38 <fxr> Saizan_: oh it will be easy, things happen in IO Monad
16:55:03 <Saizan_> fxr: and/or try to remove the happstack code from the test
16:55:16 <fxr> Saizan_: okay
17:10:21 <papermachine> can someone remind me where the guy who does ring theory and such in Haskell lives on the internet?
17:10:21 <papermachine> I can't find him with a google search :(
17:11:05 <Adamant> papermachine: sigfpe?
17:11:08 <fxr> Saizan_: hmm it worked as expected http://npaste.de/3s/
17:11:17 <papermachine> no, I thought it was someone outside of sigfpe
17:11:21 <fxr> Saizan_: immediately terminates
17:11:27 <papermachine> Though I did just stumble upon his awesome vector space library
17:11:43 <papermachine> sadly my current domain is not a vector space :(
17:12:42 <BMeph> papermachine: "the guy who does ring theory" - there's just one? ;)
17:13:14 <papermachine> okay, maybe that was insufficiently precise.
17:13:44 <BMeph> papermachine: Are we talking ddarius, Cale, FunctorSalad...give us another hint, please. ;)
17:14:10 <papermachine> oh, it's the writer of algebra-0.0.0.1. That's what I needed.
17:14:14 <fxr> oh I forget to killThread
17:14:42 <papermachine> er, maybe not
17:16:10 <fxr> Saizan_: yeah same problem when I try to killThread, here is a simplified test http://npaste.de/3t/
17:16:37 <BMeph> papermachine: Oh, I forgot edwardk in that list. Did you mean him? :)
17:17:17 <papermachine> yeah, sorry. I'll keep searching
17:18:06 <Saizan_> fxr: at least we know we don't have to blame happstack :)
17:19:55 <fxr> Saizan_: are there any alternative ways to implement such workers like lemmih did in runFastCGIConcurrent'?
17:20:41 <fxr> limiting maximum workers to N is a good idea but this doesn't work as expected.
17:21:31 <Saizan_> it can probably be fixed once we understand where the problem is
17:22:14 <Saizan_> there's at least a package on hackage that does a similar job scheduling
17:22:49 <Saizan_> i don't know how it's implemented though
17:23:51 <fxr> Saizan_: is it related with http://www.haskell.org/haskellwiki/SafeConcurrent?
17:24:23 <mike8901> Is it possible to have "where" clauses in a list comprehension?
17:25:04 <kmc> mike8901, you don't write "where"
17:25:11 <kmc> you just give a boolean expression
17:25:23 <mike8901> I mean for a boolean expression IN a list comprehension
17:25:29 <kmc> [a | a <- [1..], odd (3*a)]
17:25:31 <kmc> > [a | a <- [1..], odd (3*a)]
17:25:32 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:25:41 <kmc> mike8901, ?
17:25:59 <kmc> ah you mean a local binding
17:26:03 <mike8901> yeah
17:26:15 <kmc> yeah, "where" is limited -- you can only attach it to equations
17:26:21 <kmc> it's not an expression
17:26:24 <kmc> but "let" is an expression
17:26:24 <MoALTz> would let be enough?
17:26:36 <kmc> > [a | a <- [1..], let n = 3*a, odd n]
17:26:37 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:27:09 <Saizan_> fxr: if killThread doesn't terminate it means the exception is never delivered, so either the thread is stuck in a foreign call, or the asynchronous exceptions are blocked, afaiu
17:27:09 <mike8901> ah, cool
17:29:45 <patch-tag> fyi cabal test is failing on whatever is in head: Running workingdir.sh ...                        passed.
17:29:45 <patch-tag> Some tests failed:
17:29:45 <patch-tag> harness.sh
17:29:46 <patch-tag> setup: user error (Tests failed)
17:30:50 <kmc> @djinn a -> (forall b. b -> a)
17:30:50 <lambdabot> f a _ = a
17:38:44 <sjanssen> preflex: seen dcoutts
17:38:45 <preflex>  dcoutts was last seen on #haskell 44 minutes and 43 seconds ago, saying: ivanm: when I have any time to implement it
17:38:51 <dcoutts> @arr!
17:38:51 <lambdabot> Shiver me timbers!
17:38:59 <gwern> 'In 2007, as part of the Workshop on ML, Sylvain Conchon and Jean-Christophe Filliâtre developed a persistent version of the disjoint-set forest data structure, allowing previous versions of the structure to be efficiently retained, and formalized its correctness using the proof assistant Coq.[6]'
17:39:07 <gwern> ah, so there is a purely functional union-find
17:39:20 <sjanssen> dcoutts: so an upper base version is *required* now?
17:39:25 <dcoutts> gwern: oooh, that's interesting
17:39:33 <blackdog> is it legit to make dynamic executables the default in a Cabal package? Otherwies i end up with bloody huge executables...
17:39:37 <gwern> dcoutts: you have a use for it?
17:39:41 <dcoutts> sjanssen: yes, has been for a while. I announced and explained it at the time.
17:39:47 <dcoutts> gwern: well, ghc does.
17:39:59 <dcoutts> blackdog: not yet
17:40:06 <gwern> I didn't know that. what does ghc currently do?
17:40:06 <sjanssen> dcoutts: ah, I missed it I guess.  Is the check part of hackage's sanity check?
17:40:10 <dcoutts> sjanssen: yes
17:40:51 <dcoutts> sjanssen: the plan is to do it more generally with an opt-in system, but we started with base
17:41:00 <gwern> '
17:41:02 <gwern> 'These packages all use "build-depends: base >= 3 && < 4" (except for
17:41:02 <gwern> ghc-core which cheekily uses "build-depends: base < 10" --- a practise
17:41:02 <gwern> we will ban if it becomes any more popular).'
17:41:03 <gwern> haha
17:41:31 * dcoutts has already @slapped dons for that
17:41:32 <sjanssen> I'm sure it's way to late to whine, but I'm a bit concerned about that
17:41:35 <blackdog> dcoutts: no way at all to make dynamic executables at all, then? or just not to make it the default?
17:42:15 <dcoutts> blackdog: I'm not sure if --enable-shared does it for exes too or just libs
17:42:27 <dcoutts> blackdog: you'd have to build all your libs that way too
17:42:32 <blackdog> just libs
17:42:48 <dcoutts> blackdog: what I really meant was that we're not making shared libs the default yet
17:42:51 <dcoutts> maybe in 6.14
17:43:03 <sjanssen> it's sorta weird to enforce required bitrot in hackage packages
17:43:04 <dcoutts> sjanssen: what's the concern exactly?
17:43:18 <blackdog> if i build the libs with --enable-shared, i can build the other file with "ghc --make Hubrify.hs -package hubris", and all is good.
17:43:32 <blackdog> i just can't seem to build the executable properly from within cabal
17:43:37 <dcoutts> sjanssen: on the other hand, it's much more visible than packages claiming to work, but really not working
17:44:08 <gwern> dcoutts: wait, so if I'm reading this email right, '<4' means 'pick 4 if available?'
17:44:21 <gwern> ‽
17:44:24 <dcoutts> sjanssen: it does mean we need to make it not too hard to update a package if it turns out that later releases (that do change APIs) happen not to break a particular package.
17:44:50 <sjanssen> dcoutts: suddenly I remember having this exact discussion :)
17:45:27 <blackdog> dcoutts: ah, ghc-options: -dynamic does it
17:45:41 <blackdog> (in bad taste? fragile? not sure ...)
17:47:14 <dcoutts> gwern: doh, replied to myself to correct the typo. Thanks for spotting that.
17:47:17 <sjanssen> dcoutts: is the plan to require upper bounds on all dependencies?  Or does "opt-in" mean that a package maintainer chooses whether dependent packages must use an upper bound?
17:47:34 <dcoutts> blackdog: both, I'd prefer a patch to cabal-1.8 to do the right thing
17:47:54 <dcoutts> blackdog: --enable-shared probably should build exes with shared libs
17:48:01 <ivanm> sjanssen: a package maintainer chooses to opt-in to the PVP
17:48:05 <gwern> hm. I thought I installed darcs cabal-install, but 'show' builds for me
17:48:12 <ivanm> and then anyone using that package needs to have an upper bound
17:48:18 <ivanm> IIRC from what dcoutts was telling me ;-)
17:48:26 <dcoutts> blackdog: since the flag name is not --enable-library/executable-shared
17:48:39 <ivanm> sjanssen: which is what that message from dcoutts to myself that preflex quoted was about ;-)
17:48:41 <dcoutts> sjanssen: the latter
17:48:55 <blackdog> dcoutts: yeah, thtat sounds sensible. gotta hack something together quickly for a demo, but i'll try to come back when i have more time.
17:49:24 <dcoutts> blackdog: you can use cabal build --ghc-options=-dynamic, that's no hideous
17:49:26 <dcoutts> not
17:49:39 <dcoutts> where as putting the same thing in the .cabal file is
17:50:22 <dcoutts> sjanssen: so the balance is, if the package author promises to follow a strict package versioning system, then clients promise to make proper use of that
17:50:48 <dcoutts> sjanssen: take a look at haskell-src-exts as an example of where this works well
17:51:11 <gwern> huh. persistent union-find is cited by '36th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages, January 21-23, 2009, Savannah, GA, USA '
17:51:13 <dcoutts> sjanssen: in a sense, yes, we're suffering from bitrot because there are loads of packages that still need haskell-src-exts ==1.0.*
17:51:16 <gwern> I wonder what for
17:51:29 <ivanm> gwern: is it in there?
17:51:39 <ivanm> otherwise, why would an entire symposium cite it? :s
17:51:41 <dcoutts> sjanssen: but on the other hand, those packages still build, which they would not do if they had used open version ranges.
17:52:09 <gwern> ivanm: oh, sorry, apparently the title dropped out - '
17:52:10 <gwern> Copy-on-write in the PHP language'
17:52:52 <dcoutts> sjanssen: so we're trading off some cases of bitrot for others, but I think the tradeoff is reasonable and at least we get to see the problem more visibly and can probably manage it better in the end, with suitable infrastructure.
17:53:07 <ivanm> gwern: heh
17:53:16 <gwern> dcoutts: so where does ghc use union-find?
17:53:39 <dcoutts> gwern: type checking, unification
17:53:45 <ivanm> dcoutts: if only it was possible to edit the package online just to change the upper bounds rather than having to do an extra release
17:53:47 <gwern> 'DisjointIntervalSet'?
17:54:00 <dcoutts> ivanm: right, I'd like to allow that
17:54:00 <gwern> (in compiler/utils/Interval.hs )
17:54:14 <dcoutts> gwern: no, it's done using IORefs atm
17:54:19 <dcoutts> in the TC monad
17:54:33 <dcoutts> yes, it is that evil
17:54:35 <ivanm> dcoutts: how would you do that? go more the gentoo route by having cabal files outside of the tarball?
17:54:42 <dcoutts> ivanm: exactly
17:54:46 <gwern> hm. no, interval.hs isn't right.
17:54:55 <ivanm> dcoutts: cabal-2 ?
17:55:21 <dcoutts> ivanm: doesn't need that
17:55:33 <dcoutts> ivanm: there's already a .cabal file outside the tarball, in the index
17:55:51 <ivanm> dcoutts: right, but as soon as you edit that cabal file, the one _inside_ the tarball is useless
17:56:05 <gwern> (doesn't seem to be compiler/basicTypes/VarSet.lhs either)
17:56:08 <ivanm> I figured with a change that big (relatively speaking), you'd want to leave it for the 2.0 release
18:00:09 <dcoutts> ivanm: we could do it now in cabal-install without changing Cabal at all
18:00:50 <gwern> dcoutts: do you know what name I should search under? 'disjoint' and 'union-find' don't seem to show it
18:01:23 <ivanm> dcoutts: but that doesn't help people that don't use cabal-install ;-)
18:01:24 <dcoutts> gwern: I don't think you'll find it as a distinct thing, it's too entangled in the TC monad and the IORef it uses for type variables
18:01:40 <dcoutts> ivanm: are there such people? :-)
18:01:41 <gwern> dcoutts: really? that's terrible
18:01:43 <sjanssen> dcoutts: that would also mean that tarballs alone are no longer sufficient to build packages
18:01:51 <dcoutts> ivanm: distros can do the same thing if they like
18:02:27 <dcoutts> sjanssen: true, distros do this and manage ok
18:02:38 <ivanm> dcoutts: get and use the hackage cabal file rather than the tarball one?
18:02:45 <dcoutts> ivanm: right
18:02:54 <dcoutts> ivanm: hackport does that already
18:03:20 <sjanssen> dcoutts: well, this practice has some pretty well known failures as well.  The Debian/OpenSSL thing recently, for example
18:03:32 <dcoutts> sjanssen: right, so it must be limited
18:03:35 <ivanm> dcoutts: not for the replacing-when-building
18:03:45 <dcoutts> sjanssen: no code changes, just package meta-data, and only some of it
18:03:50 <ivanm> so if the cabal file disagrees when building, it won't build
18:04:07 <dcoutts> ivanm: right, it'd have to be both places
18:04:07 <gwern> dcoutts: ouch
18:04:28 <dcoutts> gwern: ouch about the package thing or the IORefs?
18:04:45 <gwern> dcoutts: well, the intermixing makes it hard for me to understand
18:05:01 <gwern> dcoutts: but the IORef thing is good for me, actually, since unionfind on hackage uses IORefs as well
18:05:05 <dcoutts> sjanssen: the primary use case would be to tighten or relax dependency constraints to match reality
18:05:09 <jmillikin> If you're thinking about changing the Hackage/ .cabal relationship, it's worth looking at PyPI and their PKG-INFO handling.
18:05:16 <gwern> dcoutts: so if I did a pure union-find, presumably I would have a real contribution
18:05:33 <gwern> dcoutts: which is good since my sister is bugging me for a resume & datastructure code samples for some job apps
18:05:35 <dcoutts> jmillikin: got a reference?
18:05:41 <jmillikin> Specifically, the pkg-info (equiv. to .cabal) is uploaded with the package, but can be modified / generated on the fly.
18:06:08 <dcoutts> jmillikin: and how do they manage tarballs etc, once they've changed the pkg-info ?
18:06:27 <jmillikin> They don't change the tarball at all
18:06:51 <dcoutts> jmillikin: so tools unpack the tarball and overwrite the pkg-info?
18:07:07 <jmillikin> As far as I know, the pkg-info is re-generated during installation.
18:07:32 <dcoutts> oh you mean it's not in the tarball at all?
18:07:38 <dcoutts> it's always carried separately?
18:07:49 <jmillikin> It's in the tarball, and used to populate the PyPI version initially.
18:08:02 <jmillikin> Thereafter, the pypi page can be modified without re-uploading.
18:08:23 <jmillikin> However, I don't think PyPI cares about dependencies in the same way hackage does.
18:08:39 <ivanm> dcoutts: I suppose the problem would be if your library re-exports another library (bad, I know)... then a minor dep update changes the API...
18:08:55 <dcoutts> jmillikin: so the tools download the original tarball, and the new pkg-info, and when configure/building they use the new pkg-info, or something like that?
18:09:17 <jmillikin> Right
18:09:19 <krainbolt> I just got a spam email. The subject "Sharpen Your Love-Sword".
18:09:31 <dcoutts> krainbolt: sounds painful
18:09:35 <dcoutts> ivanm: that already happens
18:10:04 <stroan> I've hust gotten my Expect library working(ish). I can now interact with adduser and passwd via an expect like interface.
18:10:11 <jmillikin> I'm not sure exactly how it works -- python distribution is undergoing some rework at the moment -- but I've always loved the ability to change things like package description, home page, etc from the web interface without having to re-upload.
18:10:16 <gwern> stroan: what was wrong with expect?
18:10:27 <dcoutts> jmillikin: right, that's what I have in mind
18:10:30 <stroan> gwern: this is a haskell implementation of the same
18:10:36 <roconnor> is it possible in GHC to copy a variable without sharing it?
18:11:05 <dcoutts> roconnor: copy the expression instead of the variable
18:11:08 <gwern> stroan: if your friends jumped off a bridge, would you write the bridge in haskell? of course not
18:11:15 <dcoutts> when you bind to a name you create sharing
18:11:23 <roconnor> dcoutts: how do you abstract that?
18:11:38 <jmillikin> If you're interested in knowing how they get it to work on the backend, I believe the PyPI devs track python-dev
18:12:05 <roconnor> this is the problem I'm considering -> http://stackoverflow.com/questions/1735146/ways-to-get-the-middle-of-a-list-in-haskell/1739559
18:12:13 <dcoutts> roconnor: you can use extra "\_ ->"s to prevent sharing
18:12:16 <roconnor> if it weren't for sharing, it could be done in constant space.
18:12:27 <roconnor> dcoutts: heh
18:12:33 <roconnor> like ML-laziness
18:12:34 <gwern> use a sequence
18:12:39 <gwern> your list has to be finite anyway
18:13:03 <roconnor> gwern: was that directed to me?
18:13:09 <gwern> (since I don't think there's any sensible 'middle' for an infinite list)
18:13:25 <stroan> gwern: for one it was a largely educational affair, but also it is nice to integrate the haskell regex types, instead of expect's
18:13:26 <gwern> roconnor: only if you think it was an insightful comment
18:13:31 <roconnor> gwern: ya, I'm leaning to that answer.
18:13:53 <gwern> roconnor: otherwise, I was aiming it at.... erm, jmillikin
18:13:56 <roconnor> If you want to do this operation on lists, you've made a design mistake somewhere else already.
18:14:35 <gwern> heck, length on Seq is O(1)
18:14:55 <gwern> and index is O(log(min(i,n-i))).
18:15:14 <gwern> 0(1) + O(log) doesn't sound slow to me
18:15:36 <gwern> (not an array's O(1)+O(1), admittedly)
18:16:30 <kmc> it's worth noting that asymptotic big-O analysis is total bullshit for many actual tasks
18:16:42 <gwern> hm. I wonder if you can do it in one traversal of a linked list
18:16:59 <gwern> keep a pointer to an old node you visited; if you're at the end of the list, it's magically the middle node
18:17:49 <kmc> it may very well take longer to build the Seq than it does to traverse this list twice
18:18:07 <roconnor> memory use is my concern here.
18:18:27 <ksf> gwern, even cooler, concat is O(log (min n m))
18:18:42 <roconnor> problem with seq is that it is generally strict.
18:18:56 <roconnor> if I have a generator for my list
18:18:56 <ksf> ...in its spine, yes.
18:19:08 <roconnor> getting in the middle should work in constant memory in theory.
18:20:36 <ksf> data T t v = B !t !(T t v) !(T t v) | L !v  with -funbox-strict fields isn't doing what I want it to do, is it?
18:21:01 <ksf> (yes, the type is fully specialized before being hammered with requests)
18:23:13 <roconnor> I'm not an expert but I don't think think polymorphic fields and definitely not recursive fields can be unboxed.
18:23:24 <aavogt> well only the first t and last v could get unboxed... but does that work with polymorphic types?
18:24:01 <ksf> I'm not using it in a polymorphic way.
18:24:14 <ksf> that's just convenience to construct the final tree
18:24:14 <roconnor> ksf: have you newtyped the instances you are using?
18:24:26 <ksf> nope
18:24:41 <aavogt> perhaps if you write  data T = B !Int !(T ....) ...
18:24:55 <roconnor> GHC just won't make specialized data types AFAIK.
18:25:20 <roconnor> because GHC is lame.
18:25:52 <roconnor> ksf: try running your code throug supero... :)
18:26:45 <ksf> As soon as the shootout uses it.
18:27:03 <roconnor> the shootout should definitely use supero
18:27:35 <Axman6> GHC can be told to specialise datatypes for specific elements in polymorphic types
18:28:05 <roconnor> Axman6: how?
18:28:27 <Axman6> using the SPECIALIZE pragma
18:29:08 <Saizan_> i though that only worked on functions, not datatypes
18:29:25 <Axman6> hmm, maybe i'm wrong
18:31:06 <ksf> YAY down 0.20 to 2.08
18:31:14 <ksf> the current entry is 3.12
18:31:35 <ksf> ...and I didn't even look at the current core.
18:32:45 <Axman6> ksf: what are you working on?
18:32:50 <ksf> fasta
18:32:53 <Axman6> ah
18:33:10 <ksf> great. it inlined the function. now I'm never going to find it :)
18:33:27 <Axman6> heh
18:43:01 <ksf> why don't we use the gpu at the shootout?
18:43:13 <ksf> everybody would utterly hate us.
18:44:28 <ksf> I could unroll the binary search with TH.
18:44:47 <twb> darcs.cabal contains a line "ghc-options:      -Wall -O2 -funbox-strict-fields -fwarn-tabs"
18:44:57 <ksf> but I think the actual culprit is too much higher-order stuff just to use bytestring's unfoldrN
18:45:03 <twb> How can I override this in a "cabal install" invocation such that -O0 is used?
18:45:25 <ksf> twb, cabal unpack darcs
18:45:28 <ksf> cd darcs-version
18:45:35 <ksf> vi darcs.cabal
18:45:37 <ksf> cabal install
18:45:52 <twb> ksf: that's plan B
18:46:32 * ksf would really like to have hare now.
18:46:41 <ksf> ...inlining a definition.
18:47:08 <Saizan_> twb: --ghc-options=-O0, maybe
18:47:52 <twb> Let's try it!
18:49:03 <Axman6> ksf: i'd love to see the GPU being used, though i think if we did, the C guys would too, and we wouldn't get far
18:49:16 <ksf> there's no {-# UNROLL foo 10 #-} macro, is there?
18:49:21 <ksf> er pragma
18:50:01 <sjanssen> ksf: no.  There are RULES and INLINE
18:50:06 * Axman6 had a lot ogf fun playing with OpenCL on his GPU
18:51:05 <ksf> is it possible to write a terminating unroll with RULES?
18:52:45 <sjanssen> that is a good question
18:52:57 <twb> Hmm: /usr/bin/ghc -O0 [...] -optc-O2 [...]
18:53:42 <twb> And elsewhere, -O0 ... -O2 ...
18:54:03 <twb> So it seems like cabal's --ghc-options is superseded by .cabal's ghc-options:.
18:54:20 <BMeph> Rock-and-unroll? ;)
19:03:17 <twb> After manually deleting -O0 from ghc-options:, it doesn't seem noticably faster...
19:03:43 <twb> I'll try manually adding -O0 as well.
19:04:16 <twb> (I'm actually trying to avoid OOM-kills.)
19:04:19 <Saizan_> the default is -O and that can be controlled with --disable-optmization/--enable-optimization
19:04:25 <twb> Saizan_: ah, of course
19:04:37 <Saizan_> which is a case against hardcoding -O levels in .cabal files.
19:07:01 <ksf> does the shootout allow -funfolding-usethreshold?
19:07:13 * rgr pasted "need haskell to select config file based on isLightHost" at http://paste2.org/p/517699
19:07:23 <ksf> I've heard they got bitchy about gc tuning...
19:07:35 <rgr> could some kind soul help with that? I am clueless and need a different config for my laptop.
19:07:54 <twb> Haha
19:07:55 <rgr> basically assign the config file based to xmobar based on the hostname switch
19:07:59 <twb> --verbose shows -lcurl -lcurl -lcurl -lcurl
19:08:30 <tensorpudding> keep curling
19:09:05 <Saizan_> rgr: you can't use guards like that
19:09:17 <Saizan_> but you can use an if/then/else exrepssion
19:10:06 <rgr> I dont even know how to assign to be honest! I took the example from here : http://www.haskell.org/haskellwiki/Xmonad/Config_archive/sereven%27s_xmonad.hs
19:10:47 <rgr> so I want the config file passed to xmobar to be based on the boolean isLightHost.
19:13:16 <Saizan_> rgr: something like this then http://paste2.org/p/517704
19:13:26 <rgr> even readin the haskell wiki I cant get it to work (if then else)
19:13:28 <rgr> thanks
19:13:39 <Saizan_> rgr: on #xmonad they might give you more specific helè
19:13:42 <Saizan_> *help
19:14:12 <rgr> thanks very very much. haskell is not for guys who want a quick paddle :-;
19:17:59 <ksf> why doesn't ghc accept all flags it accepts on the command line in OPTIONS, too?
19:22:56 <rgr> Saizan_: worked brilliantly thanks. Once question though what is "<-" when compared to "=". Kind of look to the same to the casual browser of haskell.
19:25:47 <ksf> ZOMG
19:25:51 <ksf> 1.57 seconds.
19:25:58 <ksf> I've hit the 2x mark
19:26:02 <Axman6> hooray!
19:26:08 <Axman6> how'd you do it?
19:26:31 <ksf> right now, I've added a type sig to rand
19:26:57 <ksf> all in all I'd say it was a) not doing some higher-order stuff that hindered inlining and b) binary search instead of linear
19:27:25 <tensorpudding> rgr: <- is part of the do notation
19:29:38 <Axman6> rgr: you can kind of think of <- as being the same as =, but it is different in many important ways
19:29:57 <rgr> yeah, I kind of guessed that :-;
19:30:14 <rgr> doesn't matter. I need to do the tutorial properly one day.
19:30:30 <tensorpudding> rgr: what it means exactly depends on the monad that you're in
19:30:36 <aavogt> theoretically they could have done do notation with = instead of <-
19:30:52 <Axman6> rgr: if you're interested, i've got a tutorial on doing IO in haskell, and that mightr help (though i don't think you're using the IO monad)
19:30:57 * aavogt wonders how that would have turned out
19:31:11 <Axman6> horribly
19:31:25 <Axman6> mainly because the thing on the left is not equal to the thing on the right
19:31:48 <kmc> rgr, the short answer is that "let a = e" is used to merely give a name (a) to an expression (e).  "a <- e" is used to actually *execute* the commands that e represents, and get the *result* as a
19:32:26 <kmc> "let a = getChar"  ==> "a" is another name for "getChar".  both of them *describe* the action of reading a character
19:32:43 <kmc> "a <- getChar"  ==>  "a" is a character, the result of actually executing the "getChar" action
19:32:43 <monochrom> "<-" is punctuation. The whole construct is (for example) "do { x<-m; g (f x) }" and it means "m >>= (\x -> g (f x))". It is meaningful to ask "what does >>= mean" now because it is an overloaded operator.
19:33:38 <tensorpudding> > do x <- [1..10]; return x
19:33:38 <monochrom> (OTOH in "\x -> g (f x)" "->" is punctuation again. The whole construct is "\x -> stuff".)
19:33:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:34:00 <kmc> > do x <- "abc"; y <- "def"; return (x,y)
19:34:00 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
19:34:31 <blackdog> dcoutts: heh, cabal thinks the same thing about ghc-options: -dynamic, but only because it thinks it's the debugging flag "ynamic" :)
19:36:11 <mike8901> Is anyone familiar with the haskell-emacs plugin?
19:36:14 <monochrom> http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming is the best explanation IMO (because I wrote an important part of it!)
19:36:23 <blackdog> Axman6: you coming up to sydney to see me crash and burn?
19:37:26 <tensorpudding> > do x <- Just "foo"; return $ map toUpper x
19:37:26 <lambdabot>   Just "FOO"
19:37:39 <Axman6> blackdog: when?
19:37:46 <blackdog> for FP-Syd
19:37:52 <Axman6> when...
19:37:59 <tensorpudding> an example of do notation in the maybe monad
19:38:42 <blackdog> Thursday
19:39:00 <Axman6> yeah no. no cash, so can't catch the bus
19:39:46 <blackdog> Axman6: fair enough. I guess tickets out of canberra would be expensive. It's just basic economics :)
19:39:56 <Axman6> i'd like to, but if i can get tpo FP-Syd, the earliest would be february
19:40:12 <dibblego> we're doing one in Brisbane tomorrow night
19:40:24 <Axman6> yeah, it's like $50+ for me to get to sydney and back, which is a hell of a lot for someone without a job
19:40:33 <Axman6> dibblego: oo, awesome :)
19:40:41 <dibblego> http://www.meetup.com/Brisbane-Functional-Programming-Group-BFG/calendar/11046568/
19:40:45 <blackdog> Axman6: if you want to pick up some Rails work, let me know.:)
19:40:48 <Axman6> i think you should all come down to canberra and have a haskell conmference
19:40:57 <Axman6> heh, yeah ruby--
19:41:30 <blackdog> it's all relative. i'd rather use ruby than java, or C++.
19:41:42 <blackdog> but then, i would say that.:)
19:41:43 <Axman6> i don't have a problem with java
19:41:48 <ksf> ghc _does_ do something with strictness annotations on recursive data types
19:42:43 <blackdog> Axman6: ... really?
19:42:50 <ManateeLazyCat> Have any administrator of support@community.haskell.org at here?
19:42:51 <Axman6> yeah
19:42:54 * blackdog should probably not start that war again.
19:43:02 <ManateeLazyCat> I want update SSH key in code.haskell.org
19:43:14 <Axman6> it's fairly fast, more safe than C, though i do somewhat like C too
19:43:21 <kmc> java is a good language if you have a really big uninteresting business problem and you need to solve it by hiring lots of mediocre programmers
19:43:24 <monochrom> I don't have a problem with people having no problem.
19:43:26 <blackdog> Axman6: I interviewed with Atlassian recently, and i could not stop saying sarcastic stuff about java.
19:43:34 <ManateeLazyCat> I lost my SSH key, so i can't push patch to code.haskell.org
19:43:36 <tensorpudding> java is a good language if it's 1995 again
19:43:39 <monochrom> I only have a problem with people having a problem.
19:43:44 <kmc> like it or not, much of the software the world needs is like that
19:43:44 <Axman6> blackdog: ha
19:43:53 <blackdog> i tried to stop, i swear to god
19:44:13 <twb> Java had exactly one goal: to make C++ users realize that manual memory management was dumb.
19:44:30 <ben0x539> And then they forgot to add RAII
19:44:34 <monochrom> And my problem with people having a problem is I hate them speaking about their problems in #haskell.
19:44:44 <blackdog> but then they'd ask me about the Factory pattern, and I'd start going on about type systems and inelegant hacks to get around the inability to pass closures around
19:44:45 <kmc> twb, it's not dumb if you are writing a program with microsecond-level latency sensitivity
19:44:46 <ben0x539> and everybody had to call close on their files again like they were back to C again
19:44:53 <twb> kmc: yeah, well
19:45:05 <twb> kmc: I expect C is not so good for RTOS compared to, say, Forth...
19:45:24 <Axman6> or Ada
19:45:28 * Axman6 <3 Ada
19:45:39 <twb> Oh no, more closet Ada hackers
19:45:54 <kmc> is Ada typically implemented without garbage collection?
19:45:59 <twb> Is it just me, or are they popping up a lot in the last few years?
19:46:00 <Axman6> Ada is a wonderful language, if you need to write concurrent code at least
19:47:21 <monochrom> I love my own writing style. "To bring imperative code closer to imperative look" hehe
19:48:21 <Axman6> twb: it's worth looking at as an alternative to C at least, exspecially for concurrent code
19:53:18 <iaefai> The detractors of Ada often complain about it being a 'design by committee', but I noticed haskell was definitely designed by committee. I don't ever hear a disparaging remark about that property of haskell. Any ideas why?
19:54:15 <Axman6> Ada's ugly, so looks like it was designed by a committee. but it's ugly for some fairly sensible reasons
19:56:26 <monochrom> Haskell is designed by committee, and it shows. Why is (+) a typeclass method with no Integer-specific version, while concat is a list-specific version of join, the typeclass method?
19:57:27 <lispy|web> monochrom: hi
19:57:37 <lispy|web> monochrom: How is your rant going?
19:57:39 <lispy|web> ;)
19:58:11 <monochrom> Suppose you appeal to pedagogy for having concat, "don't intimidate students with Monad type errors, just tell them list type errors", well that doesn't hold water with the Num error messages you get with 'a'+True.
19:58:40 * iaefai sleeps
19:58:45 <blackdog> I guess that's what you get with local optimisation
19:59:22 <Axman6> monochrom: i think they saw lists as too important to make the difficult for beginners
19:59:25 <monochrom> So now suppose you say "to hell with students" to defend (+). Then you can't explain why we bother with the list-specific concat when there is already join.
19:59:48 <BMeph> "return'. That is all. :)
19:59:55 <monochrom> Axman6: Verily. They. Committee. Negotiations and compromises, inconsistently.
20:00:31 <lispy|web> > 'a'+True
20:00:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:00:33 <lambdabot>         against inferred type...
20:00:42 <monochrom> You can almost envision that what happened was that one group said to the other "I'll support you making (+) a typeclass method if you will let us have concat".
20:01:33 <lispy|web> monochrom: at least with GHC, I think you gain nothing by having an interger specific version of (+) because you can just get GHC to optimize it correctly.
20:01:43 <iaefai> Without a (+) typeclass, you have + and +. among others like ocaml
20:02:05 <lispy|web> monochrom: So, I would argue thet proper fix is to put the list stuff in a type class, but then you endup with so many things in the class that it's silly, no?
20:02:31 <aavogt> what's so bad about massive type classes?
20:02:39 <monochrom> Perhaps I did not make myself clear.
20:02:40 <lispy|web> monochrom: presumably all of Data.List should be a type class, right?
20:02:56 <lispy|web> :t join
20:02:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:03:15 <monochrom> There are concat and join. concat is a special case of join. You could just use join.
20:03:21 <lispy|web> > [1,2,3,4,5] `join` [6,7,8,9] -- I thnk I get your point :)
20:03:22 <lambdabot>   Couldn't match expected type `[t1] -> t'
20:03:22 <lambdabot>         against inferred type `[a]'
20:03:41 <lispy|web> oh, wait I'm thining of (++)
20:03:57 <lispy|web> > join [[1,2,3],[4,5,6]]
20:03:59 <lambdabot>   [1,2,3,4,5,6]
20:04:06 <monochrom> So now you have to explain why we bother with concat.
20:04:24 <lispy|web> monochrom: monads came later
20:04:33 <lispy|web> the spec didn't get adequately refactored?
20:04:38 <aavogt> monomorphism has it's advantages?
20:04:46 <dibblego> Monoid, (++), mappend
20:04:47 <monochrom> And if you have an explanation, I would like you to apply it to (+).
20:05:10 <lispy|web> monochrom: Not enough refactoring of the spec explains both (+) and concat, IMO
20:05:20 <monochrom> And then if you have an explanation of both, I would like you to see that there is a more fundamental explanation: design by committee.
20:05:33 <lispy|web> (+) doesn't require monads (which came later), but the numeric heirarchy is a mess.
20:05:53 <monochrom> So, for example, if I further ask "why not enough refactoring", then the answer is "design by committee".
20:05:58 <Axman6> holy shit., i just saw a cloud that looked like einstein :O
20:06:05 <^Einstein> Axman6: orly
20:06:09 <Axman6> ha
20:06:16 <^Einstein> ;)
20:06:41 <lispy|web> monochrom: I'm not convinced that "design by committee" is the logical conclusion of "why not enough refactoring"
20:06:54 <lispy|web> I require more convincing
20:08:29 <monochrom> OK, here is another example. The fail method of Monad. And the disappearance of typeclass MonadZero that could have been a much better home for fail.
20:09:01 <lispy|web> BTW, I like the type, m a -> ma -> m a, for (++), better than the type m (m a) -> m a, for general purpose concat usage
20:09:03 <monochrom> MonadZero was around in a predecessor of Haskell. The committee killed it.
20:09:13 <SamB_XP_> dumb committee!
20:09:35 <monochrom> There are a whole bunch of other examples if I spend a few days researching.
20:10:04 <monochrom> For each example, you could explain by a different ad hoc theory.
20:10:06 <lispy|web> Wasn't that change pedegocially inspired?
20:10:32 <monochrom> Alternatively, I have one single theory that explains them all at once: design by committee.
20:10:51 <SamB_XP_> lispy|web: supposedly!
20:11:17 <SamB_XP_> I don't buy it, nor do I think that's really the best basis for deciding what Haskell should look like ...
20:11:25 <monochrom> See, another sign of design by committee is that some features are pedagically inspired but not carried out to the whole language consistently.
20:11:44 <lispy|web> consistency isn't _always_ a good tihng
20:11:51 <lispy|web> It's just one concern
20:12:00 <lispy|web> And it has to be balanced with other concerns
20:12:07 <SamB_XP_> isn't conistency the false hobgoblin of little minds ?
20:12:23 <shrughes> yeah, but a wise consistency is the spiderman of big minds.
20:13:14 <monochrom> @bot
20:13:15 <lunabot>  :o
20:13:15 <lambdabot> :)
20:13:32 <monochrom> > 'a'+'b'
20:13:32 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
20:13:33 <lambdabot>    arising from a use of `GHC....
20:14:06 <monochrom> Tell me how should I explain that to newbies.
20:15:20 <Axman6> i'd ask them what the result should be
20:15:34 <monochrom> They can point to Perl.
20:15:35 <Axman6> "ab"? 'c'?
20:15:51 <kmc> > chr ((ord 'a') + (ord 'b'))
20:15:52 <lambdabot>   '\195'
20:16:04 <shrughes> > chr ((ord 'a' * 256) + ord 'b')
20:16:05 <lambdabot>   '\24930'
20:16:17 <kmc> oh no, unicode!
20:16:25 <Axman6> :O
20:16:50 <Axman6> by now, they'll be starting to see that 'a'+'b' is a silly thing to do
20:17:15 <lispy|web> monochrom: so, do you plan to get on the haskell' committee to fix this?
20:17:16 <monochrom> But you still having answered them what is "instance" and why it is in the error message.
20:17:26 <monochrom> No.
20:17:35 <SamB_XP_> lispy|web: the who?
20:18:26 <lispy|web> SamB_XP_: the who is a band
20:18:34 <lispy|web> Wait, are we on Jeopardy?
20:18:58 <Cale> monochrom: I would probably explain what typeclasses are.
20:19:02 * hackagebot upload: hubris 0.0.1 - Support library for Hubris, the Ruby <=> Haskell bridge (MarkWotton)
20:19:25 <Cale> monochrom: Understanding typeclasses is fundamental anyway. You can't get very far with programming in Haskell without it.
20:19:48 * SamB_XP_ has a sudden desire to download "I Lost on Jeopardy"
20:21:14 <monochrom> I guess IRC is really poor for explaining a proposition that needs more justification than five words.
20:21:47 <lispy|web> monochrom: Perhaps.  It could also be that I don't want to concede the point without a discussion first.
20:22:15 <Cale> monochrom: I agree about your overall point. I just think we shouldn't be so concerned about crippling the types of things for beginners' sake.
20:22:19 <monochrom> Well what did you discuss?
20:22:49 <monochrom> <lispy|web> monochrom: How is your rant going?
20:22:59 <lispy|web> monochrom: Well, I proposed counter arguments and points.
20:23:03 <monochrom> That already killed all hope of discussion.
20:23:12 <lispy|web> monochrom: It's going okay considering.
20:23:30 <monochrom> I am assumed to be ranting. Without discussion first, mind you.
20:23:33 <lispy|web> monochrom: ah, sorry.  I was just teasing.
20:23:49 <Cale> btw, http://analogical-engine.com/wordpress/  Natural transformations 4 is up :)
20:23:52 <lispy|web> monochrom: hence the winky face I sent you
20:24:02 <monochrom> My proposition was <monochrom> Haskell is designed by committee, and it shows.
20:24:16 <monochrom> It was duely forgotten 30 seconds after I said it.
20:24:31 <Cale> It does show. It could show a heck of a lot more though, given some of the things which have been designed by committee in the past.
20:24:37 <monochrom> People just argued over sidetracked things and called it a discussion.
20:25:00 <lispy|web> monochrom: not forgotten, but I did try to contest your evidence.  But, I'm not compelled to move to that explanation
20:25:03 <monochrom> People behave like pushdown automata over IRC. Context-free. That is why discussions are fruitless.
20:25:51 <Cale> Well, you have to admit that's pretty good for a bunch of finite state machines.
20:25:59 <lispy|web> monochrom: your evidence, as I understand it, is that there are inconsistencies in the spirit of the design (here we do it for reason X, here we do it for reason anti-X)
20:25:59 <blackdog> it's a fairly natural result of the tension between backward compatibility and conceptual integrity, i suspect. and design by committee tends to move you in the direction of backward compatibility...
20:26:21 <lispy|web> monochrom: How is it, tha we can prove that came from commitee and not other factors?
20:26:57 <lispy|web> monochrom: yes, I do present ad-hoc explanations, but this isn't physics.
20:28:46 <lispy|web> I guess monochrom doesn't want to discuss it anymore?
20:31:18 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12187#a12187
20:31:30 <ksf> go, try to make it faster.
20:32:00 <ksf> should be about 1.7x of ATS (which is 1.0), right now.
20:32:13 <ksf> http://shootout.alioth.debian.org/u64/benchmark.php?test=fasta&lang=all&box=1
20:32:54 <Axman6> ksf: excellent work :D
20:33:02 <Axman6> what did you do to make it faster?
20:33:45 <Axman6> (| True = ...?)
20:34:01 <ksf> first (choos seq) . rand was a separate function that was passed the sequence and then passed to randFasta
20:34:07 <ksf> ...which completely defeats inlining it
20:34:11 <ksf> otherwise is too long.
20:34:17 <ksf> would mess with the layout columns.
20:35:22 <ksf> then there's the binary lookup, and then some stylistic cleanup
20:35:25 <blackdog> is it parallelisable at all?
20:35:39 <ksf> a tiny bit.
20:36:00 <ksf> we could do rand and choose on different cpus
20:36:35 <ksf> ...but we won't get faster than the throughput of the rng
20:37:02 <Axman6> hmm
20:37:10 <Axman6> which RNG are you using
20:37:25 <ksf> we have to use that one.
20:38:06 <mike8901> How come when I have ceiling (sqrt n) as a subexpression, I get the error Instances of (RealFrac Integer, Floating Integer) required for definition of myfunc ?
20:38:11 <mike8901> Do I need to import a package?
20:38:14 <ksf> the profile is
20:38:14 <Axman6> ksf: also, would UNPACK pragmas be helpful for the T type, and the L constructor?
20:38:15 <ksf> choose                         Main                  46.8   26.7
20:38:15 <ksf> rand                           Main                  29.3   53.5
20:38:15 <ksf> unroll                         Main                  23.3   18.3
20:38:29 <ksf> I pass -funbox-strict-fields.
20:38:34 <Axman6> mike8901: how are you usingt it?
20:38:47 <Axman6> ah, well fair enough
20:38:48 <ksf> ...and the core is full of #'s
20:38:49 <mike8901> I'm passing it to a function which expects an integer
20:39:05 <blackdog> ksf: if you had n cpus, perhaps you could mathematically unpack the effect of applying the RNG n times? might you get a simplification?
20:39:18 <blackdog> (then you could have n striding at once)
20:39:45 <Axman6> :t sqrt
20:39:46 <lambdabot> forall a. (Floating a) => a -> a
20:39:48 <ksf> if you have >= 3 cores, you can run all three cost centres separately on one, but they got to be in lockstep with the rng
20:39:58 <Axman6> mike8901: Integers aren't part od the Floating class
20:40:05 <Axman6> you need to use fromIntegral
20:40:05 <mike8901> so how do I work around the issue?
20:40:07 <ksf> an entry was already disclassified for messing too much with the rng
20:40:26 <ksf> ether fromIntegral, or use an integer sqrt
20:40:28 <Axman6> :t let f = ceil . sqrt . fromIntegral in f
20:40:30 <lambdabot> Not in scope: `ceil'
20:40:34 <Axman6> :t let f = ceiling . sqrt . fromIntegral in f
20:40:35 <lambdabot> forall a b. (Integral a, Integral b) => a -> b
20:40:38 <mike8901> doesinteger round up?
20:40:42 <mike8901> *does integer round up?
20:40:48 <ksf> Integer is infinite precission
20:40:48 <Axman6> integer doesn't round at all
20:40:59 <mike8901> right, but given a float as input...
20:41:09 <mike8901> i.e. integer sqrt x
20:41:18 <ksf> so that double conversion will loose information, so with really big Integers you will get wrong results.
20:41:31 <mike8901> so what's the best way to get ceil sqrt x ?
20:41:48 <mike8901> I basically want to know the highest number to check for factors of a number up to
20:42:32 <Axman6> just check the nu,mbers until n*n >= x
20:42:58 <ksf> http://ertes.de/articles/monads.html#section-3  (scroll a bit down)
20:43:06 <Cale> It's rather unfortunate that we don't have a good fast integer square root somewhere in the libraries
20:43:17 <ksf> that one give you correct answers even for 2^2^128
20:43:22 <ksf> ...if you have enough memories
20:43:26 <ksf> *memory
20:44:00 <dolio> I thought copumpkin was adding primops for lots of GMP stuff, which would presumably include square root.
20:44:15 <Cale> "... if you can has enuff memoriez"
20:44:33 <dolio> Although, I guess starting with 6.12, you can do a foreign import of C-- stuff, which might be better.
20:44:34 <Cale> lolcatFTFY
20:44:42 <mike8901> ok, one other case - I want to find the factors up to 1...sqrt n, in the form of a list comprehension
20:45:08 <mike8901> right now I have x<-[1..n]
20:45:15 <mike8901> but I want x<-[1..sqrt n]
20:45:21 <lispy|web> :t sqrt
20:45:22 <Cale> mike8901: one nice thing to try is making an isPrime and a list of all primes which are mutually recursive :)
20:45:23 <lambdabot> forall a. (Floating a) => a -> a
20:45:46 <Cale> mike8901: so that you only test the *primes* less than or equal to the square root :)
20:45:46 <lispy|web> :t floor . sqrt
20:45:48 <lambdabot> forall a b. (RealFrac a, Integral b, Floating a) => a -> b
20:46:02 <mike8901> Cale: That's what I'm doing
20:46:05 <mike8901> (or trying to do)
20:46:16 * Draconx wants to strangle whoever thought that "floor" returning an integral type was a good idea
20:46:18 <lispy|web> > (\n -> [1 .. floor . sqrt $ n]) 100
20:46:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:46:21 <mike8901> actually hmm
20:46:29 <mike8901> I think there might be a more elegant way to do what I'm doing :)
20:46:34 <Axman6> mike8901: x <- takeWhile (\y -> y * y <= n) [1..n]
20:46:40 <Draconx> > floor (-1/0)
20:46:41 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
20:46:41 <Axman6> sqrt is bad, don't do it!
20:46:46 <Draconx> how does that answer make any sense at all?
20:47:17 <Drakona> Pardon me . . . I'm working through a Haskell tutorial and am finding some notation about function types confusing.  Can someone clarify how I ought to understand a type like (a -> a -> a)?  Does that mean I give it a value of type a and it gives me a function a -> a?  Or I give it the function and I get the value?  Or it's a function that wants two arguments?  Or what?
20:47:31 <Cale> Drakona: your first guess
20:47:40 <Cale> Drakona: a -> b -> c means a -> (b -> c)
20:47:46 <ksf> ...and the last one, in some sense.
20:47:46 <Drakona> I always stop after the first -> then?
20:47:58 <Cale> Drakona: To go along with this, f x y means (f x) y
20:47:59 <lispy|web> :t ( (+), (1 +))
20:48:01 <lambdabot> forall a t. (Num a, Num t) => (a -> a -> a, t -> t)
20:48:03 <dolio> floor (-1/0) is a bug that no one's ever bothered to fix.
20:48:18 <ksf> let's say it's not a value until you've passed in two values.
20:48:19 <Drakona> I see.  Thanks.
20:48:43 <Cale> Drakona: All functions in Haskell really have exactly one parameter, and those which appear to take more are really functions which take the first parameter and produce another function
20:48:49 <kmc> also, functions are values
20:49:02 <kmc> :t subtract
20:49:03 <lambdabot> forall a. (Num a) => a -> a -> a
20:49:04 <kmc> :t subtract 3
20:49:05 <lambdabot> forall t. (Num t) => t -> t
20:49:08 <kmc> :t subtract 3 4
20:49:09 <lambdabot> forall t. (Num t) => t
20:49:20 <EvilTerran> "function of two values" ~~ "function of one value, that itself returns a function of one value"
20:49:23 <kmc> (dunno why it switched from a to t; it doesn't matter)
20:49:27 <Drakona> Ah.  The tutorial was hinting about that with +.  I think I will have to chew on it with the more complex ones.
20:49:36 <Gwern-aw1y> ksf: well, if you're getting the middle of a list using seq, persumably you're working with a Seq from the beginning. and fromList is O(n), so a dumb middle-list could be beaten complexity wise even if you have to convert list->Seq
20:49:57 <Drakona> That 5 + 3 really made a function that added 5 to an integer, and then I fed it a 3.
20:50:12 <Cale> Drakona: yeah
20:50:12 <EvilTerran> ?type (+)
20:50:13 <lambdabot> forall a. (Num a) => a -> a -> a
20:50:14 <EvilTerran> ?type (+) 5
20:50:15 <lambdabot> forall t. (Num t) => t -> t
20:50:21 <EvilTerran> ?type (+) 5 3
20:50:22 <lambdabot> forall t. (Num t) => t
20:50:44 <lispy|web> Drakona: it sounds like you already understand it
20:51:07 <Drakona> Thanks very much.  I appreciate the explanation.
20:51:22 <Cale> Drakona: Of course, when optimising things, the compiler does a good job of discovering when it can skip some of the steps there.
20:51:27 <ksf> :t (+5)
20:51:28 <lambdabot> forall a. (Num a) => a -> a
20:51:38 <ksf> :t (5+)
20:51:39 <lambdabot> forall t. (Num t) => t -> t
20:52:17 <Cale> Drakona: So that if you apply a function to all its arguments right away, it doesn't have to go about making another function.
20:52:18 <Draconx> dolio, sadly, it's not the only function in the prelude that's broken w.r.t floating point.
20:53:02 <Cale> > floor (-1/0)
20:53:03 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
20:53:03 <Drakona> That's a bit beyond what I'm worried about at the moment, but good to know.
20:53:06 <Cale> heh
20:53:17 <Draconx> > max (0/0) 5
20:53:19 <lambdabot>   NaN
20:53:22 <mike8901> Is the best way to generate a list of primes to use a list comprehension for 2.. where the length of the factors is equal to 2?
20:53:22 <Draconx> > max 5 (0/0)
20:53:23 <lambdabot>   5.0
20:53:28 <lispy|web> :t floor (-1/0)
20:53:30 <lambdabot> forall b. (Integral b) => b
20:53:33 <Draconx> so max isn't commutative, either.
20:53:57 <aavogt> > floort (-1/0) :: Word8
20:53:58 <lambdabot>   Not in scope: `floort'
20:54:02 <aavogt> > floor (-1/0) :: Word8
20:54:03 <lambdabot>   0
20:54:03 <ksf> > min infinity 10
20:54:04 <lambdabot>   10
20:54:12 <Drakona> I think I understood +; where I had really gotten lost was trying to untangle something like foldl
20:54:19 <ksf> :t infinity
20:54:20 <lambdabot> Natural
20:54:30 <Axman6> mike8901: i wouldn't say so, though that could be parallised
20:54:32 <Cale> mike8901: With the mutual recursion thing, usually I do something like  2 : filter isPrime [3,5..]
20:54:34 <ksf> @src infinity
20:54:35 <lambdabot> Source not found. It can only be attributed to human error.
20:54:46 <ksf> infinity = succ infinity
20:54:54 * BMeph wants "MOAR" (pred n) `div` 2 and succ . (`mod` 2) . pred
20:55:01 <ksf> > min 10 infinity
20:55:02 <lambdabot>   10
20:55:10 <ksf> it's just IEEE floating point that's broken
20:55:12 <lispy|web> > max 10 infinity
20:55:14 <lambdabot>   * Exception: stack overflow
20:55:25 <Cale> heh
20:55:29 <Drakona> But let's see if I can unravel it.  (a -> b -> a) -> a -> [b] -> a; It takes a function that's effectively a function of two arguments into a value -- something like + or * -- and gives me back a function that (effectively) takes two arguments -- a list and a value -- and gives me a value.
20:55:42 <Draconx> ksf, floor (-inf) should be -inf.
20:55:42 <ksf> > min 10 (max 3 infinity)
20:55:43 <lambdabot>   10
20:55:48 <Cale> Drakona: right
20:55:54 <Draconx> the problem is that floor decides to shoehorn the result into an integer.
20:56:09 <lispy|web> IEEE floating point causes lots of problems for formal reasoning and verification of programs.  Reals are okay, but IEEE floating point gets painful, from what I've heard
20:56:24 <Drakona> Thanks.  That's helpful.
20:57:08 <dolio> floor isn't a function for fiddling with floating point numbers.
20:57:12 <Draconx> lispy|web, all floating point systems have such problems.
20:57:13 <Cale> Drakona: foldl is a bit harder to describe, but I like to think of foldr f z as the function which replaces every (:) in a list with f, and the [] at the end with z
20:57:46 <Cale> and so foldr f is the function which takes a replacement for [] and a list, and does that.
20:57:48 <ksf> > foldr f [1..10]
20:57:49 <lambdabot>   No instance for (SimpleReflect.FromExpr [t])
20:57:49 <lambdabot>    arising from a use of `Simp...
20:57:51 <lispy|web> > foldl (flip (:)) [] [1..10]
20:57:53 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
20:57:54 <ksf> > foldr f [1..10] :: Expr
20:57:55 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:57:55 <lambdabot>         against inferred ...
20:57:56 <dolio> It's one of the many different possibilities for sensibly casting a fractional (or something like that) number to an integer.
20:58:04 <ksf> > foldr f id [1..10] :: Expr
20:58:04 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:58:05 <lambdabot>         against inferred ...
20:58:13 <ksf> :t foldr
20:58:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:58:14 <Cale> > foldr f z [1..10]
20:58:15 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
20:58:21 <aavogt> > foldr f a [b,c,d] :: Expr
20:58:22 <lambdabot>   f b (f c (f d a))
20:58:27 <Draconx> dolio, how is the result on infinity and nan "sensible"?
20:58:41 <dolio> There's no one best "toInteger", so instead there's floor, ceiling, round, truncate...
20:58:46 <Cale> Draconx: I think probably the result on infinity and NaN should be _|_
20:58:49 <Drakona> Yeah, I think I understand how it works.  Just getting my head around how to read the type -- that takes a little work.  But understanding how the arrows associate helps.
20:58:58 <Cale> Drakona: yeah
20:59:04 <lispy|web> Draconx: as a beginner, I found this reverse [1..10] == foldl (flip (:)) [] [1..10], very heard to understand.  But I also found that understanding it helped me a lot.
20:59:08 <Draconx> Cale, would certainly make a lot more sense than some arbitrary negative integer value.
20:59:11 <dolio> It isn't sensible, but it's not because the codomain should be Double.
20:59:31 <Cale> Drakona: You can also always just regard A -> B -> C -> D as being the type of function which takes parameters of types A, B, and C and results in something of type D
20:59:34 <ksf> it's not arbitrary.
20:59:37 <dolio> But as long as decodeFloat remains, broken, those are all going to be broken.
20:59:55 <Cale> Drakona: Just have to keep in mind that you can always apply it to fewer.
21:00:01 <ksf> it's the binary representation of the right result, interpreted as integer...
21:00:11 <Drakona> . . . because a function that takes a and gives me back a function b -> c is a function that's going to want a and b before it gives me c
21:00:17 <lispy|web> A -> B -> C -> D is the same as A -> (B -> (C -> D)), BTW
21:00:19 <Cale> Drakona: right
21:00:34 <Draconx> ksf, so the different nans get different integer results, depending on the underlying bit representation?
21:00:37 <Drakona> I see.  But it's written that way in case I want to use the general function -- leave b until later.
21:01:05 <ksf> Drakona, you do the bit fiddling and checking.
21:01:06 <Cale> Drakona: It's very useful in conjunction with higher-order functions
21:01:17 <ksf> I just treat them as evil and only touch them with a stick.
21:01:35 <Cale> Drakona: Quite often you just want to partially apply a function to get another function in order to say, map over a list
21:01:51 <Draconx> ksf, hm, that can't be right.
21:01:53 <Cale> > map (map (*2)) [[1,2,3],[4,5],[6,7,8]]
21:01:54 <lambdabot>   [[2,4,6],[8,10],[12,14,16]]
21:01:55 <lispy|web> Drakona: So, if you see a type like, (A -> B) -> (C -> D), that's the same as, (A -> B) -> C -> D
21:02:01 <Draconx> > floor (0/0 :: Double)
21:02:02 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
21:02:17 <ksf> nobody but numericolicans can understand IEEE
21:02:36 <Draconx> ksf, given that double is 64 bits, this can't be the integer interpretation of the underlying representation.
21:02:37 <Warrigal> > ceiling (0/0 :: Double)
21:02:38 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
21:03:02 <Drakona> Cale: I see.  You're applying a map function to all lists in a list.
21:03:06 <bd_> > decodeFloat (0/0::Double)
21:03:07 <lambdabot>   (-6755399441055744,972)
21:03:14 <Cale> > length . filter id $ zipWith (/=) "Draconx" "Drakona"
21:03:15 <lambdabot>   2
21:03:25 * Axman6 understands a lot of IEEE-754
21:03:27 <Cale> Drakona: right :)
21:03:30 <Draconx> ksf, so I'll stick with my "arbitrary".
21:04:03 <ksf> > (.) (. (*2)) [[1,2,3],[4,5],[6,7,8]]
21:04:04 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
21:04:11 <Cale> > map (foldr (+) 0) [[1,2,3],[4,5],[6,7,8]]
21:04:11 <ksf> > (.) ((.) (*2)) [[1,2,3],[4,5],[6,7,8]]
21:04:12 <lambdabot>   [6,9,21]
21:04:12 <lambdabot>   [[2,4,6],[8,10],[12,14,16]]
21:04:19 <Cale> ksf: hehe
21:04:22 <Drakona> Cale: So the map(*2) inside the perentheses can be still thought of as waiting for its list, while the one outside already has it.  So the one inside is a more general function.
21:04:27 <ksf> > ((*2).) . [[1,2,3],[4,5],[6,7,8]]
21:04:29 <lambdabot>   [[2,4,6],[8,10],[12,14,16]]
21:04:54 <Cale> Drakona: yeah, in that it's not a list yet :)
21:05:20 <Cale> map (map (*2)) [[1,2,3],[4,5],[6,7,8]]
21:05:34 <Axman6> hmm, anyone kn0ow anything about this function? leob :: (Functor f) => f (f b -> b) -> b?
21:05:40 <Cale> -> [map (*2) [1,2,3], map (*2) [4,5], map (*2) [6,7,8]]
21:06:05 <Cale> Drakona: You can think of it working like that ^^
21:06:08 <Drakona> Yeah, I see what happened.  Neat.
21:06:11 * ksf is still looking for people to further optimize the fasta code
21:06:15 <phr> http://www.skytopia.com/project/fractal/mandelbulb.html  <-- awesome 3d fractal pics.  need some DPH with a grafix accelerator...
21:06:29 <Drakona> Okay, I think I get it.  I really appreciate the help.  I'll go back to playing around with it, I think.
21:06:32 <Cale> Drakona: Although, what it really does is take it one step at a time, so as not to touch any of the elements of the list which it doesn't need to.
21:06:43 <dolio> decodeFloat currently just treats Floats and Doubles as if there are no distinguished codes. So if there is more than one NaN, then it probably produces different decodeFloat results, which will probably translate into different floor/ceiling/etc. results.
21:06:47 <Cale> (but the result is the same in the end)
21:06:49 <BMeph> Axman6: loeb. --someone with Unicode access to umlauts, please feel free to spice that up for me. :)
21:07:18 <Warrigal> What does the Curry-Howard isomorphism say about functors?
21:07:25 <BMeph> Axman6:  loeb :: (Functor f) => f (f b -> b) -> f b
21:07:35 <Axman6> you sure?
21:07:48 <dolio> > let (b,p) = decodeFloat (0/0 :: Double) in b ^ p
21:07:49 <lambdabot>   263514575808465908367279747653309090780191673781737772167777176622984064799...
21:08:08 <dolio> > let (b,p) = decodeFloat (0/0 :: Double) in b  * 10 ^ p
21:08:09 <lambdabot>   -67553994410557440000000000000000000000000000000000000000000000000000000000...
21:08:09 <Cale> BMeph: Löb
21:08:19 <dolio> > let (b,p) = decodeFloat (0/0 :: Double) in b  * 2 ^ p
21:08:20 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
21:08:35 <Warrigal> Ooh, I remember Löb's theorem.
21:08:42 <dolio> > let (b,p) = decodeFloat (0/0 :: Double) in b  * 2 ^ p == floor (0/0 :: Double)
21:08:43 <lambdabot>   True
21:09:06 <BMeph> Cale: Right, thanks. ;)
21:09:09 <Warrigal> One possible f is provability in a certain system.
21:09:49 <Warrigal> But that doesn't seem like a functor. If A and B are sentences, then (A implies B) doesn't seem to imply (A-is-provable implies B-is-provable).
21:09:51 <Cale> Warrigal: You can treat functors as logical operators [] having the property that, of course, (a -> b) -> ([] a -> [] b)
21:10:33 <Cale> Warrigal: It does though.
21:10:41 <Warrigal> Hmm. I guess there's a completeness theorem stating that if something is true in a certain sense, there is a proof of it.
21:11:14 <Warrigal> It sure seems that for not every Turing machine that doesn't halt is there a proof that it doesn't halt. If there were, we'd have a halting oracle, no?
21:11:38 <roconnor> Löb says that the statement "I am provable in PA" is provable in PA.
21:12:08 <Warrigal> I feel eager to discard my existing notions of what "truth" and "logical consequences" and such mean in mathematics, but I don't know what to replace them with.
21:12:53 <Cale> Warrigal: Formalism
21:13:14 <Cale> ;)
21:13:43 <BMeph> Warrigal: It helps to ditch the notion that logic determines truth. Or vice-versa. ;)
21:14:04 * Warrigal decides that in things like \x -> x + 3, \x is the row and x + 3 is the column.
21:14:11 <BMeph> Warrigal: Unless by "truth", you mean... "truth". ;)
21:14:42 <Cale> Oh, hmm, is provability in PA really a functor?
21:15:00 <frivol> This is really "deep"
21:15:02 <Warrigal> Truth is what a perfect Bayesian would say given the evidence and sane priors!
21:15:02 <Cale> Or does it just have Löb's theorem?
21:15:15 <Warrigal> frivol: it's so deep that even I don't fully understand it.
21:16:15 * Warrigal reads about Gödel's completeness theorem once again.
21:16:44 <Cale> I'm pretty sure that having a natural transformation F(FA -> A) -> FA doesn't ensure that F is a functor. That would be really strange.
21:17:31 <Warrigal> Ask lambdabot!
21:17:42 <Cale> djinn isn't smart enough
21:18:13 <Warrigal> lambdabot: for all type constructors F, does "for all types A, F (F A -> A) -> F A" imply "for all types A and B, (A -> B) -> F A -> F B"?
21:18:33 <Warrigal> <lambdabot> Hmm, let me think about that one.
21:18:58 <Cale> Ah, we have ap though: F(p -> q) -> Fp -> Fq
21:19:07 <Warrigal> For all functors F?
21:19:18 <Cale> No, for provability
21:19:28 <Cale> I'm not sure that it's really a functor
21:19:32 <Warrigal> <lambdabot> Your antecedent looks rather ugly, to be honest. It contains an odd number of Fs.
21:19:45 <dolio> Most modal operators are, are they not?
21:20:07 <Cale> If p -> Fp (which we'd have to interpret as meaning that the system is complete), then sure, you get fmap from that
21:20:18 <Warrigal> The most objectionable statement I can think of is (True -> ItDoesntHalt) -> Provable True -> Provable ItDoesntHalt
21:20:25 <Cale> dolio: I think most actually are not.
21:20:32 <Cale> dolio: I mean, the most commonly used ones
21:20:41 <Warrigal> Which means ItDoesntHalt -> Provable ItDoesntHalt.
21:20:59 <Warrigal> By the way, does anyone want to remind me of the difference between a structure and a model?
21:21:04 <dolio> Ah, well, good, I suppose. I was thinking a while back about it, and couldn't figure out how they were, but I figured it was a personal problem.
21:21:30 <Cale> Warrigal: A model of a collection of statements is a structure which satisfies those statements
21:21:58 <kmc> wasn't there some thing where the type of Lb's Theorem (in modal provability logic) turns out to be the type of a useful Haskell function?
21:22:07 <Cale> kmc: yes
21:22:15 <Gwern-aw1y> oh noes, did someone say - LOB's THEOREM???
21:22:17 <dolio> It ties knots.
21:22:19 <Cale> loeb :: (Functor f) => f (f b -> b) -> f b
21:22:20 <Gwern-aw1y> http://lesswrong.com/lw/t6/the_cartoon_guide_to_löbs_theorem/ nyuk nyuk nyuk
21:22:33 <Cale> It does spreadsheet evaluation ;)
21:22:34 <Warrigal> Ah. So the set of all letters in the exclamation "Boy, am I tired!" with the elem function being "precedes" is a structure but not a model?
21:23:01 <Cale> Warrigal: uh...
21:23:16 <Cale> Warrigal: I'm not sure which logic you're talking about
21:23:19 <Warrigal> ZFC.
21:23:38 <Warrigal> Forgot to mention that.
21:23:39 <Cale> Warrigal: oh, sure
21:24:02 <Cale> Would be *amazing* if that turned out to be a model ;)
21:24:09 <Draconx> Warrigal, a model of ZFC needs to satisfy all its axioms.
21:24:21 <Draconx> Warrigal, your example will have a hard time satisfying the axiom of infinity.
21:24:23 <Warrigal> So: "A first-order formula is called logically valid if it is true in every structure for its language."
21:24:27 <Cale> But I'm pretty sure ZFC doesn't have any finite models
21:24:35 <Warrigal> Draconx: I did say it's not a model.
21:24:46 <Cale> Warrigal: yeah
21:24:47 <Draconx> Warrigal, er, sorry.
21:24:56 <Warrigal> If ZFC has any finite models, rejoice, for we have discovered how to embed the universe in the palm of our hands.
21:25:00 <BMeph> Axman6: loeb xs = fmap (\fs -> fs (loeb xs)) xs
21:25:09 <kmc> @djinn (forall a b. (a -> b) -> (f a -> f b)) -> f (f b -> b) -> f b
21:25:09 <lambdabot> -- f cannot be realized.
21:25:37 <Cale> Warrigal: How about it has one, but the collection of sets has Graham's number of elements? :)
21:25:39 <Warrigal> I don't think djinn knows what forall means.
21:25:56 <Warrigal> Cale: we just need bigger hands.
21:26:00 <roconnor> I doubt that provability is a functor
21:26:01 <Cale> hehe
21:26:21 <Cale> Warrigal: and probably a bigger universe to put our new hands in too
21:26:28 <Warrigal> Now, let me repeat what I almost said a minute ago.
21:26:46 <Cale> roconnor: Me too, unless the system is complete
21:26:54 <EvanCarroll> can someone help me out understanding this "# addThree = \x -> \y -> \z -> x + y + z  "
21:27:01 <Warrigal> So: "A first-order formula is called logically valid if it is true in every structure for its language." I can't really imagine what sorts of things would be logically valid, then.
21:27:01 <EvanCarroll> I think the LYAh book is especially unclear here.
21:27:03 <Cale> (which in PA's case would be disastrous)
21:27:09 <BMeph> Cale: "You're gonna need a bigger boat." ;)
21:27:16 <Cale> Warrigal: silly things which are trivial
21:27:24 <Axman6> EvanCarroll: have you seen \x -> ... synmtax before?
21:27:24 <Warrigal> Tautologies only, not axioms?
21:27:34 <EvanCarroll> atually I do understand it.
21:27:41 <EvanCarroll> It just clicked 2 seconds after I asked it.
21:28:08 <roconnor> Warrigal: forall x, x=x is usually considered a logical validity.
21:28:28 <Warrigal> I guess it's obvious how to define "logical consequence" from "logically valid", then. Say that the implication is logically valid, and you've got you a logical consequence.
21:28:29 <Axman6> > (1/0) == (1/0)
21:28:30 <lambdabot>   True
21:28:33 <Axman6> hmm
21:28:40 <Axman6> > (0/0) == (0/0)
21:28:41 <lambdabot>   False
21:28:45 <Axman6> :O
21:28:49 <EvanCarroll> You're defining addThree as a lamda, that takes one value, and returns a function that takes one value that takes value and returns a function that adds the other 3
21:28:51 <BMeph> Cale: Did you get a kick out of Etter's "Three-Place Identity" paper? ;)
21:29:02 <Cale> Warrigal: Still, determining if a sentence is logically valid or not is computationally intensive.
21:29:03 <twb> So I noticed that .cabal/configure had "-- optimization: True".  After uncommenting it and setting it to False, I get
21:29:04 <twb> $ cabal update --error--> cabal: Command.optionToFieldDescr: feature not implemented
21:29:06 <Warrigal> EvanCarroll: quite right!
21:29:13 <Draconx> Axman6, welcome to the wonderful world of floating point.
21:29:17 <EvanCarroll> so the lamdas are implicitly closing over the variables of the parent lamdas
21:29:18 <Cale> BMeph: I'm not sure if I have seen it or not.
21:29:24 <EvanCarroll> and that just wasn't said explicitly
21:29:32 <Warrigal> Cale: surely it's not possible to determine for all sentences.
21:29:34 <blackdog> I'd like to embed an array of strings as an externally visible symbol in a Haskell program. Does the FFI support that? I could always do it by including a C file to compile as well, but it's a bit ugly.
21:30:07 <kmc> blackdog, there's a Template Haskell thing for it somewhere
21:30:16 <Cale> Warrigal: I seem to recall that it's decidable at least.
21:30:26 <EvanCarroll> \x -> (\y -> \z -> x + y + z) == \x -> \y -> (\z -> x + y + z), the lambda returned by x, y has the variables x,y in lamda-scope
21:30:28 <Warrigal> Cale: recursively enumerable, you mean?
21:30:39 <Warrigal> You can go through the set of all possible proofs and output all novel theorems.
21:30:51 <Warrigal> If it were recursively decidable, we'd have a halting oracle.
21:30:56 <roconnor> Warrigal: yes, the logical validities are r.e.
21:31:20 <roconnor> I don't think they are decidable. ... Let me think
21:31:35 <BMeph> Cale: If you have a free five minutes, http://www.boundary.org/bi/articles/Three-place_Identity.pdf
21:32:11 <Cale> BMeph: I saw that you've been reading the blog that I've been writing with Robin :)
21:32:24 <Warrigal> Ahh, I love how Gödel has both a completeness theorem and an incompleteness theorem.
21:32:36 <roconnor> Warrigal: they are probably decidable for very restricted languages.
21:32:43 <roconnor> like having 1 function symbol.
21:33:03 <blackdog> kmc: got any more googleable terms? I may not actually need TH, I'm generating Haskell source anyway. The problem is how to export an array of C strings.
21:33:11 <kmc> ah, sorry
21:33:14 <kmc> i'm not sure then
21:33:29 <Warrigal> roconnor: right, right.
21:33:30 <roconnor> Warrigal: but yes, I'm pretty sure you could solve the halting problem if FOL was decidable in general.
21:33:38 <Warrigal> roconnor: yes, you could.
21:33:39 <Cale> Oh yeah, thinking about it more, it is actually kind of complicated to pick some of them up.
21:33:59 <Cale> They start making sort-of-interesting statements about sets.
21:34:06 <roconnor> you only need a finite number of axioms to represent all recursive predicates.
21:34:53 <BMeph> Cake: Sure! I just need to figure out where to start. I keep going back, and seeing that I should read an earlier one. :)
21:35:56 * Warrigal reads BMeph's PDF and laughs at equality theory and membership theory.
21:37:54 <Warrigal> If this three-place identity thing is interesting enough, I might declare it the foundation of... stuff.
21:38:51 <EvanCarroll> ok question, if `\x -> \y -> \z -> x + y + z` is equal to `x, y, z = x + y + z`, then can you have partial application without currying or currying without partial application?
21:39:15 <Axman6> that second version doesn't make any sense
21:39:26 <Axman6> do you mean f x y z = x+y+z?
21:39:31 <EvanCarroll> yes.
21:39:56 <Warrigal> Partial application without currying makes sense, I guess.
21:40:31 <Warrigal> pap :: ((a,b) -> c) -> a -> b -> c; pap f x = \y -> f (x,y)
21:40:43 <kmc> :t curry
21:40:44 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:40:55 <Warrigal> Though, rethinking that, that's turning the function into a curried one.
21:41:14 <Warrigal> Currying without partial application definitely makes sense; just ignore the fact that it's possible to pass only one argument to a two-argument function.
21:41:23 <EvanCarroll> If currying means applying less arguments then a function requires, thereby returning a function that requires the remaining arguments, then currying is an (implicit) partial application?
21:41:48 <EvanCarroll> Warrigal: how would you curry without partial application?
21:42:00 <kmc> currying means to make a function capable of being partially applied, without extra machinery
21:42:08 <kmc> not the act of applying
21:42:15 <EvanCarroll> ah!
21:42:30 <kmc> "currying" describes the program transformation whereby multi-argument functions are made into single-argument functions
21:43:41 <kmc> it's quite unfortunate that currying isn't called "schnfinkelization"
21:44:03 <sieni> kmc: unfortunate and unfortunate
21:44:05 <Cale> BMeph: maybe start from Natural transformations 1
21:44:34 <Cale> BMeph: We really need to start organising things properly
21:44:44 <Warrigal> For those of us who don't know German-or-whatever, what's a schönfinkel?
21:44:54 <kmc> the name of the guy who actually invented currying
21:45:09 <kmc> Moses Ilyich Schnfinkel
21:45:48 <kmc> "...His papers were burned by his neighbors for heating."
21:46:09 <BMeph_> Cale: "I" will do that. Just finishing up Robin's "Matrices" articles now. Now sure what the point of it is, TBH. I can't imagine someone wanting or needing "to explain matrix multiplication, the trace and the transpose in terms of duality and tensor products".  :)
21:46:15 <EvanCarroll> sounds like a perfectly reasonable thing to do.
21:46:30 <kmc> there was a war on
21:46:32 <kmc> these things happen
21:46:37 <Warrigal> I wonder why it was named after Mr. Curry, then...
21:46:51 <lament> cool name
21:46:51 <Warrigal> BMeph_: for a better understanding of the trace, duality and tensor products?
21:47:06 <Cale> Warrigal: a name
21:47:06 <Cale> Warrigal: He's also credited with the invention of what tends to be called currying
21:47:18 <BMeph_> ...because no angry villagers were allowed near [Curry]'s papers? ;)
21:47:32 <path__> lol
21:47:34 <kmc> they weren't angry, just poor
21:47:37 <kmc> maybe angry also
21:48:04 <BMeph_> Warrigal: Then, wouldn't the purpose be the converse of what's stated? :)
21:48:15 <Cale> Not sure if my messages got sent before I was disconnected
21:48:37 <Cale> BMeph_: Perhaps start from Natural transformations 1 if you're reading my thread :)
21:48:42 <Warrigal> Cale: you sent a message, then you disconnected, then we said stuff, then you connected.
21:48:49 <ski> @type uncurry curry
21:48:49 <Cale> ah
21:48:50 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
21:48:58 <ski> Cale : which blog ?
21:49:07 <Cale> ski: http://analogical-engine.com/wordpress/
21:49:37 <Warrigal> BMeph_: "to explain duality and tensor products by explaining something else in terms of them"
21:49:49 <Warrigal> Otherwise, I'm not sure what the converse would be.
21:49:54 <Cale> ski: My friend Robin and I have been working on it for the past week or so :)
21:51:33 <Cale> BMeph_: However, the series of posts which I'm doing on natural transformations and functors covers a lot of the same ground as the Catsters' videos.
21:51:37 <ski> (is "Schur Functions" related to "Shur Multiplier" ?)
21:51:46 <Cale> er, and adjunctions I should say :)
21:51:53 <Cale> ski: hmm
21:52:20 <ski> (not that i know much about that latter .. looked a little in a book about it)
21:52:21 <Cale> ski: Schur functions are particular symmetric functions which are indexed by partitions of integers
21:52:57 <Cale> I don't know what a Schur multiplier is
21:53:12 <Cale> Oh, it's from representation theory?
21:53:22 <Cale> Then, very possibly there's a connection
21:53:56 <EvanCarroll> I've starred at this for 10 minutes now
21:53:58 <EvanCarroll> # flip' f = \x y -> f y x
21:54:02 <EvanCarroll> I just can't see how it is clearer
21:54:22 <Warrigal> EvanCarroll: clearer than what?
21:54:29 * hackagebot upload: bert 1.1 - BERT implementation (MariusEriksen)
21:54:31 <EvanCarroll> flip' f x y = f y x
21:54:39 <EvanCarroll> per LYAH
21:54:39 <Cale> EvanCarroll: Well, the tendency is to think of whatever's on the right of the = as the true result of the function
21:54:45 <Warrigal> It's not much clearer.
21:55:14 <Cale> EvanCarroll: So it sort of tries to help you think of flip as taking a two parameter function and producing a different two parameter function
21:55:23 <Cale> EvanCarroll: rather than a function of 3 parameters
21:55:39 <ski> say you're writing `zipWith (flip (/)) [1,2,3] [4,5,6]'
21:56:30 <EvanCarroll> I *think* I understand what it is doing, but it seems much harder to mentally parse.
21:56:32 <ski> then the latter definition might make more sense, when rewriting to `zipWith (\x y -> (/) y x) [1,2,3] [4,5,6]'
21:57:09 <ski> (or even better, remove the `[1,2,3]', `[4,5,6]' arguments)
21:57:37 <ski> the latter definition emphasizes that `flip f' returns a function (namely `\x y -> f y x')
21:58:21 <ski> the former definition otoh says that `flip f' returns a function that, when applied to `x' and `y', returns `f y x'
21:58:51 <ski> the result is the same, but it's two different POVs
21:59:38 <EvanCarroll> this i understand, I just don't understand who would prefer to mentally parse the one with explicit currying
22:01:41 <Cale> BMeph_: odd that he chose to make things work out backward :)
22:02:40 * Warrigal decides to read Terence Tao's blog in the hopes of becoming a guru.
22:03:25 * Cale is probably scarred for life with regard to number theory
22:03:53 <Warrigal> Why are you scarred for life with regard to number theory?
22:04:20 <shrughes> it's number theory
22:04:21 <centrinia> Well, number theory is difficult.
22:04:48 <jfredett> Cale: What did NT ever do to you? *hugs his Number Theory Textbook*
22:04:49 <lambdabot> jfredett: You have 1 new message. '/msg lambdabot @messages' to read it.
22:05:55 <Cale> Took an algebraic number theory course in which the assignments were pure evil. Ridiculous things where basically the only way forward is to break things down into cases modulo 8 or modulo 16 and draw graphs of divisibility relations in hopes of finding something you know that's actually useful.
22:06:36 <Cale> Computing ideal class groups with only the Minkowski bound and the definition and not much else.
22:06:44 <Cale> Stuff like that
22:07:19 <jfredett> Cale: I'm sorry, that sucks.
22:07:21 <shrughes> number theory's fun until you get past the stuff musicians know instinctively
22:08:06 <jfredett> I didn't get quite that far, but anything w/ cases mod (x>4) is roughly equivalent the 7th level of hell...
22:08:14 * ski shakes fist at ISP
22:08:15 <BMeph_> Cale: I'm assuming you're talking about the Etter paper now. ;)
22:08:20 <Cale> The prof was otherwise a really nice guy, and he gave us really beautifully typeset and useful notes.
22:08:32 <Cale> BMeph_: oh, the bit about how it works out backward? Yeah
22:09:35 <ski> EvanCarroll : in some cases, it can be useful to recurse through a structure and/or precompute something before later arguments are even given
22:09:56 <EvanCarroll> ski: right but both do that.
22:10:20 <EvanCarroll> flip' f = \x y -> f y x
22:10:26 <EvanCarroll> flip' f x y = f y x
22:10:32 <ski> (so if you e.g. `map' the partially applied function, then you will recurse and/or precompute only once instead of once for each element)
22:10:40 <Cale> BMeph_: It's a really amusing paper, thanks for pointing me to it :)
22:10:41 <ski> in this case, that doesn't matter, yes
22:11:46 <EvanCarroll> so if both forms do the same thing, then why ever use the former? when the latter is shorter and more clear
22:13:03 <Cale> EvanCarroll: You don't have to
22:13:14 <ski> EvanCarroll : but consider a `match :: Eq a => [a] -> [a] -> Bool' which tells if the first input is a contiguous sublist of the second; when only given the first argument, you can precompute an efficient KMR matcher, instead of naively traverse/interpret the pattern over and over
22:13:29 <Cale> EvanCarroll: Most people wouldn't. The important thing is the understanding that they're equivalent in the sense that you already understand that :)
22:13:52 <ski> (and now replace the first argument with a regular expression or other kind of pattern)
22:13:54 <Cale> Oh, yeah, if you jam a let in between too, you can change the performance of things
22:14:15 <Cale> also, there are some very technical wibbles about pattern matching and strictness where breaking up a lambda can change things
22:14:15 <EvanCarroll> ski:  I would be interested in not being confused by "KMR matcher" but because I am I can only request a doc-pointer to whatever you're talking about.
22:14:34 <EvanCarroll> Cale: docs?
22:14:37 <Cale> ski: Knuth-Morris-Pratt is a substring search algorithm
22:14:50 <ski> "KMR" being the "Knuth-Morris-Pratt" matching algorithm
22:14:52 <Cale> er, not ski
22:14:54 <Cale> hehe
22:15:10 <Cale> EvanCarroll: For the let thing, consider an example like...
22:15:40 <Cale> f x y = let k = product [1..x] in k + y
22:15:48 <Cale> g x = let k = product [1..x] in \y -> k + y
22:16:43 <blackdog> is there a library for dealing with temporary files on Hackage?
22:16:51 <Cale> GHC will never push a let upward such that it breaks up a lambda (because it's not always a good idea)
22:17:20 <Cale> But here, breaking up the lambda might be a good idea.
22:17:44 <Cale> Compare the performance of  map (f 10000) [1..10]  and  map (g 10000) [1..10]
22:18:00 <EvanCarroll> I'm going to just store what you're saying for when I'm smarter in tomboy
22:18:06 <EvanCarroll> =(
22:18:15 <Cale> tomboy?
22:18:24 <centrinia> That's a note taking program.
22:18:29 <Cale> oh
22:18:30 <Cale> heh
22:18:45 <Cale> I parsed that as:  I'm going to just store what you're saying for when I'm (smarter in tomboy)
22:19:32 <ksf> @pl  \seed' im fromIntegral seed' / fromIntegral im
22:19:33 <lambdabot> (line 1, column 30):
22:19:33 <Cale> rather than: I'm going to (just store what you're saying for when I'm smarter) in tomboy
22:19:33 <lambdabot> unexpected "/"
22:19:33 <lambdabot> expecting pattern or "->"
22:19:37 <ksf> @pl  \seed' im -> fromIntegral seed' / fromIntegral im
22:19:37 <lambdabot> (. fromIntegral) . (/) . fromIntegral
22:19:38 <EvanCarroll> you're whitespace is too binding... haskell thing.
22:19:40 <EvanCarroll> your*
22:19:51 <ksf> @pl  \f -> f seed' / f im
22:19:52 <lambdabot> liftM2 (/) ($ seed') ($ im)
22:20:10 <ksf> for the sake of clarity, NO
22:20:37 <ksf> @pl  \f a b-> f a / f b
22:20:37 <lambdabot> flip =<< (((.) . (/)) .)
22:21:45 <ksf> you guys didn't even notice that superfluous *1.0 in the random generator!
22:21:52 <ksf> here, try again:
22:21:54 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12187#a12187
22:27:49 <Axman6> ksf: why is that 1.0 * there?
22:28:16 <ksf> it was in the code I originally copied from the benchmark page
22:28:29 <ksf> I guess it's to force the result to Floating or something
22:28:32 <aavogt> @check \x -> x * 1.0 == x
22:28:33 <lambdabot>   "OK, passed 500 tests."
22:28:43 <ksf> yep 1.0 is sane in IEEE
22:28:48 <aavogt> > maxBound * 1.0
22:28:48 <ksf> about the only thing that is
22:28:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:28:49 <lambdabot>    `GHC.Enum.Bounded a'
22:28:49 <lambdabot>    ...
22:28:54 <aavogt> ok
22:29:12 <ksf> it's returning values between 0 and 1, anyway
22:29:34 <Axman6> :\ types can do that...
22:31:56 <shrughes> > (0.0 / 0.0) * 1.0 == (0.0 / 0.0)
22:31:56 <lambdabot>   False
22:32:54 <ksf> well, let's say that at least for medium input size, the same results are generated.
22:33:20 <shrughes> > (1.0 / 0.0) == (1.0 / 0.0)
22:33:21 <lambdabot>   True
22:33:37 <shrughes> it's just that NaN == NaN is False
22:33:56 <ksf> I never understood that one.
22:34:09 <mtnviewmark> defined in IEEE 754 that way
22:34:19 <kmc> yeah, floats are not even a partial order
22:34:35 <ksf> nans were once also forcing me to do really, really strange x87 stack mangling
22:34:39 <mtnviewmark> though C/C++ intentionally break that
22:35:20 <mtnviewmark> (though not all NaNs are the same, so in C/C++, they are only equal if they are the same kind of NaN)
22:35:50 * ksf would have rather more precision than billions of error codes
22:36:07 <mtnviewmark> no loss of precision
22:36:24 <ksf> how's that? they're wasting valuable bitpatterns.
22:36:28 <mtnviewmark> they are all hiding in places where you couldn't encode a number
22:36:35 <shrughes> NaN and infinity costs you a single exponent
22:45:36 <ivanm> jfredett: it'd be on planet...
22:48:47 <cjs> Is there any way to export a data constructor so that it can be used when pattern matching (e.g., Foo{field1,field2}) while not allowing the constructor to be used to construct new values?
22:51:31 <mtnviewmark> I don't think so
22:51:47 <ksf> you can, but you can use those functions to set, too.
22:52:19 <ksf> maybe you can do something with fclabels or similar
22:52:50 <mtnviewmark> you could define a parallel type, for matching, provide a function converting to it.... so:
22:53:11 <mtnviewmark> data Thing = ....  -- these constructors are not exported
22:53:40 <mtnviewmark> data ThingData = Foo Int String | Bar Bool  -- these are exported
22:53:57 <mtnviewmark> view :: Thing -> ThingData   -- exported function
22:54:18 <mtnviewmark> then in client code they could pattern match on (view someThing)
22:54:50 <mtnviewmark> ahhhhh... you could even make this easier
22:54:51 <ski> cjs : O'Caml has that, but Haskell doesn't
22:55:33 <ski> (as an "O'Caml Extension")
22:55:53 <kmc> the technique in haskell would be to export a view type with constructors
22:56:00 <kmc> and a thing which builds the view from the "real" type
22:56:04 <mtnviewmark> newtype Thing = Thing ThingData -- again, don't export the constructor
22:56:05 <kmc> and optionally to use that with view patterns
22:56:33 <kmc> ah, it's what mtnviewmark is describing
22:56:47 <mtnviewmark> :-)
23:01:14 <BMeph_> Rather, (view -> someThing) ;)
23:05:51 <cjs> Ah, I see.
23:06:28 <cjs> Hm. It seems the naming of things could get a bit interesting, though.
23:07:40 <cjs> Because then if you use NamedFieldPuns, you end up with, instead of "Quote{qty,price}", "view -> QuoteView{qty,price}".
23:07:51 <cjs> It's sort of verbose, too.
23:10:25 <Axman6> ksf: taking a look at your code, it seems to me that you could parallelise things quite easily. i'm also wondering if using ZipLists would be helpful: fork off a thread for each computation, get it to compute the string to print using ZipLists, then place them in MVars to be printed by another forked thread (forked because talking to the main thread [ie: bound thread] is rather slow)
23:11:15 <blackdog> Axman6: I think the tricky bit is using the state of the RNG in the right order
23:11:42 <kmc> why is talking to the bound thread slow?
23:11:44 <Axman6> where is random being used anyway?
23:12:19 <Axman6> kmc: i'm not sure why, but i know it is (the thread-ring entry i entered is the fastest because it doesn't use main as one of the threads in the ring)
23:13:58 <blackdog> Axman6: Are we still talking about the genetic thing?
23:14:07 <Axman6> fasta? yeah
23:14:17 <kmc> what's thread-ring?
23:14:24 <blackdog> part of the spec is that you have to use their R
23:14:28 <blackdog> RNG
23:14:38 <kmc> is this shootout?
23:14:40 <blackdog> and it's not splittable - you need to pass it round
23:14:42 <blackdog> kmc: yeah
23:14:48 <Axman6> kmc: a ring of 503 threads, that pass a counter between them 50,000,000 times
23:15:47 <kmc> why 503?
23:16:42 <Axman6> it's a prime number... no better reason than that :\
23:18:24 <Axman6> ksf: also, why do you pass randFasta two strings? why not just pass them the whole string as a constant?
23:19:17 <kmc> what's the name of the shootout program?
23:19:37 <Axman6> fasta
23:19:48 <Axman6> well, which one are you talking about?
23:20:24 <kmc> the one with the threads
23:20:30 <Axman6> thread-ring
23:21:30 <kmc> ah found it, thanks
23:21:49 <kmc> wow we are kicking ass at that one
23:22:20 <Axman6> yup
23:22:29 * Axman6 is quite proud the top one is his submission
23:22:38 <Axman6> not that i wrote much of it
23:23:11 <kolmodin> I see you had distro wars while I was asleep
23:23:11 <lambdabot> kolmodin: You have 1 new message. '/msg lambdabot @messages' to read it.
23:23:19 <kolmodin> and I missed it
23:23:21 <kmc> any idea why?
23:23:41 <Axman6> because MVars are _fast_
23:23:59 <kmc> it's nice and simple code too
23:24:05 <Axman6> yeah
23:25:30 <ksf> Axman6, the problem is that I have a single core
23:25:38 <ksf> ...and the strings already were that way.
23:25:54 <ksf> and the performance impact is drown in jitter.
23:26:00 <blackdog> kolmodin: best kind of discussion to sleep through
23:26:21 <ksf> drown drown drown_ed_
23:26:25 <kolmodin> :D
23:26:46 <kolmodin> well, I feel my distro wasn't represented properly :D
23:27:25 <kolmodin> I just mainly want to say that you don't need to upgrade your system each week to not make it break. that's just crazy talk
23:27:35 <blackdog> kolmodin: clearly nobody hates your distro enough
23:27:35 <Axman6> ksf: yeah. i'd love to work on a parallel version, but i had to take my MBP in today, and won't have it back for about two weeks
23:27:47 <Axman6> so, stuck without an SMP machine
23:27:48 <ksf> choose                         Main                  46.8   26.7
23:27:48 <ksf> rand                           Main                  29.3   53.5
23:27:48 <ksf> unroll                         Main                  23.3   18.3
23:27:51 <thomastim> juego de boxeo online http://www.kobox.org/kobox-fande-Nourine.html
23:27:54 <ksf> it's definitely doable.
23:27:57 <blackdog> Axman6: EC2 instances are fun to develop on:)
23:28:08 <Axman6> got one i can play with? ;)
23:28:09 <ksf> you possibly have to chunk it up to decent size, though.
23:28:14 <kolmodin> blackdog: that's pretty much all I had to contribute to the discussion this time :)
23:28:24 <blackdog> Axman6: I don't keep one running - they're easy to spin up, though.
23:28:40 * Axman6 is too poor to be able to run one
23:28:43 <kolmodin> you guys run haskell software on them?
23:28:46 <ksf> note that rand isn't even the bottleneck
23:28:50 <blackdog> kolmodin: yeah, it's bad enough compiling ghc every second day
23:29:16 <ksf> one tuning possibility is left for choose, and that's reifying the search tree directy as code with TH
23:29:17 <kolmodin> blackdog: on EC2?
23:29:32 <kolmodin> ah, I see
23:29:47 <kolmodin> you're picking a fight about gentoo? well, I will not fall for it :)
23:30:05 <blackdog> Axman6: the medium high-cpu instances are 17 cents an hour
23:30:32 <tensorpudding> gentoo puts the fun in -funroll-loops
23:30:54 <Axman6> blackdog: any innitial setup costs?
23:30:56 <Axman6> -n
23:31:02 <blackdog> kolmodin: yeah, i was using them for compiling GHC a while back
23:31:05 * Axman6 will be back after dinner
23:31:14 <blackdog> Axman6: there's a bit of time to invest in working out how it works
23:31:20 <blackdog> no other costs, though.
23:31:30 <Axman6> hmm, interesting
23:31:44 <blackdog> the tricky bit is that you pay for storage, so you need to externalise all the stuff you actually care about
23:32:40 <blackdog> there are free instances, so you can get a basic ubuntu setup, but any extra storage you pay a bit for. S3 isn't that exy, though.
23:35:00 <kmc> hmm, does Mono suck?  C# Mono is several times slower for most problems than Java 6 -server
23:36:47 <pngll> I'm going through "Learn you a Haskell for great good!". Could someone explain the convention "never add typeclass constraints in data declarations" ? After saying this the author creates a Vector type which always receive Nums, but does not enforce it. Why?
23:37:08 <Heffalump> because H98 got them wrong, and they don't do anything useful
23:37:32 <Heffalump> you don't get the constraint available without restating it when you actually consume the type
23:37:35 <aavogt> when your constructor has a type class constraint, that doesn't mean you get to use it
23:38:00 <aavogt> it only means you have to provide it when applying the constructor
23:39:53 <dblhelix> goodmorning, #haskell
23:40:20 <kmc> pngll, if you *do* want the ctor to make the constraint available, you can define your type using GADT syntax
23:40:42 <tensorpudding> or good evening :P
23:40:42 <kmc> which is also good to know and more general anyway
23:40:50 <kmc> 'morning dblhelix
23:43:32 <pngll> Heffalump, aavogt do you mean the constraint does _not_ work? So I would be allowed to let var= (Thing "a") even though I did data (Num a) => Thing a = Thing a ?
23:44:04 <pngll> kmc, I'm just going through the tutorial so I don't know what GADT syntax is yet, or I just don't know the name.
23:45:17 <ksf> the thing that's actually broken is the very concept of constrained data types: you won't be able to write e.g. a Functor instance if you give the Num constraint, as fmap doesn't come with a num restraint.
23:45:50 <ksf> the Right Way to do it is to mention the constraints in the functions that actually use them.
23:47:45 <ksf> ...as, fwiw, some use of that data type might want to transform a Vector Double into a Vector Colour, do some transformations that don't have anything to do with Num, and then transform back to Double.
23:48:08 <mathijs> Hi all, what's the best way to handle SIGINT/SIGTERM/SIGQUIT (or ctrl c for a foreground process) so I can do some cleaning up and save state?
23:48:36 <ksf> sigaction
23:48:41 <ksf> that's the C answer though.
23:48:57 <ksf> ...and only if you need it, as it's a posix extension.
23:49:46 <ksf> the oldfashioned way is signal, but that's not nearly as powerful
23:50:04 <pngll> ksf, thank you for this explanation.
23:52:19 <mathijs> ksf: can you point me to some documentation? couldn't find sigaction/signal on hoogle/hackage
23:53:05 <ksf> manpages
23:53:17 <ksf> @hoogle System.Posix.Signal
23:53:18 <lambdabot> No results found
23:53:38 <ksf> @hoogle System.Posix.Signals
23:53:38 <lambdabot> No results found
23:53:44 <ksf> http://hackage.haskell.org/packages/archive/unix/2.3.0.0/doc/html/System-Posix-Signals.html
23:53:50 <ksf> well, it _does_ exist...
23:54:19 <ksf> be sure to read man sigaction to know how your system behaves
23:54:57 <mathijs> ksf: cool, thanks
23:59:29 <mmorrow> (adding to Cale's examples)
23:59:40 <mmorrow> <Cale> f x y = let k = product [1..x] in k + y
23:59:40 <mmorrow> <Cale> g x = let k = product [1..x] in \y -> k + y
23:58:25 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
23:58:25 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
23:58:25 --- names: list (clog_ perspectival Dessous mattwynne dikini simonf fasta Chaze koeien37 Schmallon miccm benl23 Pellwurst Beelsebob kayess int-e wunki simplicio jayne r0bby willb emma heapify Modius_ zachk1 hp_ blueflute bens earthy mmaruseacph2 grouzen TR2N sprang dynamix pyNem shag ketil vili spaceodyssey det danvet carlocci eevar2 oskimura sioraiocht shambler lazni mr_ank cdiem smelk nvoorhies O_4 hackagebot c_wraith iblechbot yowgi jones- QplQyer Mowah)
23:58:25 --- names: list (otsdr dolio zakwilson sigh caligula__ m3ga romanandreg nwf Snark alvarezp angelixd_ lament kadoban gio123 ski_ medfly ski gogonkt m-i-l-a-1 Draconx wagle iaefai Rotaerk__ ablokzijl Cale whoppix SamB_XP jsgf Sup3rkiddo twb s76 kniu roconnor novas0x2a Raynes kolmodin BMeph otto_s_ astrocub malie QinGW yahooooo cjs juhp Gwern-aw1y abbe bel5f5 cgibreak triplez tavelram Keiya gr00vy aluink mec70 Pewpewarrows ulfdoz Kapowski luite ttmrichter)
23:58:25 --- names: list (horms Mr_Awesome Polarina mreggen Cobra^^ ivanm Philonous PsiOmega nnunley alphecca- gnuvince zax andrewsw-afk M| hsaliak__ skeeterbug1 mjrosenb dons pifish_ karld stepcut aempirei McManiaC wimt Pthing LeCamarade Alpounet Dunearhp_ chrisdone nathanic1 u_quark Kim^Walkman DEVOKUN saccade_ mahogny dixiecko crem Nereid_ da-x Gracenotes Elench dreixel niksnut gjl voker57__ Saizan_ shrughes PeakerWork mauke kuningas ChthonLaptop felipe_ jan_____)
23:58:25 --- names: list (neurocyte pikhq sereven edwtjo sbok Poeir zygoloid kw317 joed Annie|Home sior|oifig Counter-Strike tmug flux dilinger _Jordan_ idnar jml ahf Axman6 spoop dmwit smg newsham levitation_ Apocalisp dibblego snorble dejones Philippa ertai Megant EvanCarroll fnordus taruti jlouis kanalj MacCoaster byorgey Jiten kalven Exteris igorgue jlaire raim0 andun Tobsan ath ^Einstein drspider_ tamiko pcc1 emias deiga_ arkx Raevel ibid jvoorhis wornof BONUS_)
23:58:25 --- names: list (samulihs geir_ kmeyer phr FauxFaux opqdonut greap nothingmuch agemo skaar stepnem gdsx magicman srcerer jystic jre2 cathper nornagon quicksilver qebab Deewiant pragma_ Innominate dionoea ath^ koninkje_away Sisu cods wang Elly majoh Ornedan epmf_ Taggnostr clog Peaker xian Whitesquall Igloo ortmage1 amuck CalJohn rasfar joga stalker borism Bleadof tew88 Bassetts Cthulhon cognominal nlogax snhmib blalb dino- geoaxis_ dankna augur DrSyzygy)
23:58:25 --- names: list (Heffalump SimonRC canvon_ And[y] Esmil nablaa guerby tilman Badger Jaak Twey @ChanServ rey_ blackdog ac Liskni_si wolverian tkr Lemmih eelco_ JaffaCake Aikawa_ leoncamel ben0x539 dcolish ddvlad takuan reubens sieni araujo noteventime dcoutts xinming ps-auxw bind_return ToRA blastbeat jelly12gen jahgru ville rgr flippo mmorrow gbacon wharrgarble LeoD heaumer_ deavid wisemanby _xor rdd` jabagawee Tomas Guest17379 SmurfOR kpreid kynky Veinor)
23:58:25 --- names: list (alexsuraci thorkilnaur EvilTerran jbauman lhnz Trafalgard mm_freak Raku^ matthew-_ Jedai djinni m4thrick Eelis eyck t Chile danopia kyagrd fhs StoneToad ijnek bumblebee waern tensorpudding sohum fihi09 gbeshers jtra aiko nathanic_work nominolo_ anders^^ baaba clanehin zhijie TML linkinus thoughtpolice Neronus jix Colours burp kmc ve pixel5 jaj alexbobp peddie loupgaroublond karihre tessier clarkb jamwt mulletron hiredman allbery_b trez)
23:58:25 --- names: list (eno Optimo jkramer jontore eek MyCatVerbs glith AnMaster eagletmt onodrim Nereid ksandstr nipuL sjanssen duairc reltuk +lunabot saccade erk __marius__ teneighty tromp_ dcoutts_ davidL PHO_ inimino orbitz endojelly desp bockmabe_ beibmozoi bd_ sebas__ Laney mml`_ rapacity theclaw mux mokus_ jnwhiteh equanimity erg SeaPrior _br_ bran BrianHV nimred boyscared franksh mattam dumael sproingie stroan thomastc mshaw glitch qm13_ sgf_ lavish ned)
23:58:25 --- names: list (mrd drbean Vulpyne electrogeek +preflex Paradox924X Nafai mercury^ mle olsner shortcircuit shachaf BONUS wormwood jrockway integral shepheb Milo- fxr cdfh_ Nanar danderson Aisling poucet jvogel_ wdonnelly harlekin lanaer Khisanth ido disgrntld dek5 sunnavy nasloc__ Lycurgus ystael saiam anji_ mapreduce ahihi Stephan202 mmmulani aleator prigaux koeien pettter mornfall impl _plcs_ GNU\colossus sebbe1991 ggreg_ pantsd_pcf mjv da-xw wagle_home)
23:58:25 --- names: list (alexander2 webframp Paks mikm suiside kakeman dogmaT jfredett int_e tumult netcat jfoutz SubStack droidcore mlh kar-1 desu qed koala_man malouin mmmdonuts Boney therp anekos jql authentic companion_square avysk doublethink_work jims sunfun thedward poe Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh lefant p_l aavogt cygnus_ jasonmay mikste)
23:58:25 --- names: list (sevvie guerrilla osfameron ehamberg flori profmakx lsthemes arjanoosting Maddas mw493 liff ray epokal gOcOOl dfeuer Zao midnite noddy regulate mfp OnionKnight tuukkah mfoemmel mdordal2 tltstc qwr Vq welterde Gabbie drhodes Botje ziman AndyP loop Blub\0 alip thetallguy periodic brx daed +lambdabot noj)
