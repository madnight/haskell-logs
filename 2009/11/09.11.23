00:01:27 <ski> > (\start end noSteps -> let width = end - start in unfoldr (\(q,r) -> if q > end then Nothing else Just (q,(q*noSteps + r + width) `minimalDivMod` noSteps)) (start,0)) 1 10 10
00:01:29 <lambdabot>   [1,2,3,4,5,6,6,7,8,9,10]
00:01:30 <ski> > (\start end noSteps -> let width = end - start in unfoldr (\(q,r) -> if q > end then Nothing else Just (q,(q*noSteps + r + width) `minimalDivMod` (-noSteps))) (start,0)) 1 10 10
00:01:31 <lambdabot>   [1,2,3,4,5,5,6,7,8,9,10]
00:02:15 <copumpkin> conal: hm, mistweet?
00:02:27 <copumpkin> conal: published new blog post: test (with 404 link?)
00:02:47 <conal> copumpkin: yep. mis-auto-tweet :/
00:04:40 * junmin is going to sleep, bye all
00:04:59 <ski> > (`minimalDivMod` 7) `map` [-10..10]
00:05:00 <lambdabot>   [(-1,-3),(-1,-2),(-1,-1),(-1,0),(-1,1),(-1,2),(-1,3),(0,-3),(0,-2),(0,-1),(...
00:05:03 <ski> > (`minimalDivMod` (-7)) `map` [-10..10]
00:05:04 <lambdabot>   [(-1,-3),(-1,-2),(-1,-1),(-1,0),(-1,1),(-1,2),(-1,3),(0,-3),(0,-2),(0,-1),(...
00:05:07 <ski> > (`minimalDivMod` 6) `map` [-10..10]
00:05:08 <lambdabot>   [(-2,2),(-1,-3),(-1,-2),(-1,-1),(-1,0),(-1,1),(-1,2),(0,-3),(0,-2),(0,-1),(...
00:05:12 <ski> > (`minimalDivMod` (-6)) `map` [-10..10]
00:05:13 <lambdabot>   [(-2,2),(-2,3),(-1,-2),(-1,-1),(-1,0),(-1,1),(-1,2),(-1,3),(0,-2),(0,-1),(0...
00:05:43 <ski> (hrm, i suppose that'd look better if it wasn't cut off)
00:06:10 <ski> pastah_rhymez : did you want the last argument to be the number of steps between the elements ?
00:08:13 * ski wonders if `[-3,-2,-1,0,1,2]' or `[-2,-1,0,1,2,3]' would be best as "standard" minimal remainders modulo `6'
00:10:00 <ski> Cale : i suspect the latter one is "most common" in mathematics, yes ?
00:10:01 <pastah_rhymez> ski: yes
00:11:01 <ski> pastah_rhymez : then it looks like BMeph's variant gave the wrong number of steps
00:11:27 <ski> (also it used floating point arithmetic .. which my version didn't)
00:12:09 <copumpkin> moo
00:12:10 <ski> pastah_rhymez : you see above i have two versions for arguments `1',`10',`10'. one giving `6' twice, one giving `5' twice
00:12:24 <ski> this is because of difference rounding policy
00:12:29 <ski> pastah_rhymez : which do you prefer ?
00:12:47 <pastah_rhymez> ski: hang on, busy with something (screenshot coming up)
00:12:56 <iaefai> Can a cabal file have a library and an executeable in the same file?
00:12:56 <kmc> @djinn ((p -> q) -> q) -> q
00:12:56 <lambdabot> -- f cannot be realized.
00:13:06 <Heffalump> iaefai: yes
00:13:19 <ski> (pastah_rhymez : btw, are you implementing something bresenham-like ?)
00:13:29 <iaefai> Heffalump, do you know of any simple examples on how to make the executable use the library?
00:13:34 <pastah_rhymez> http://web.student.chalmers.se/~goranssa/rgb_blending.png
00:13:41 <Heffalump> ah, that you can't do until the new version of cabal comes out :-)
00:13:43 <Heffalump> it's annoying.
00:14:06 <pastah_rhymez> ski getting to this screenshot was a LOT of work :/
00:14:12 <pastah_rhymez> but i guess it was worth it
00:14:14 <ski> @djinn NotNot (((p -> q) -> q) -> q)
00:14:14 <lambdabot> -- f cannot be realized.
00:14:20 <iaefai> Heffalump, I seem to be having a problem with cabal ignoring a c-sources in an executable section. I found an email describing this problem from *2005* that says it was fixed, but sounds like my exact problem.
00:14:23 <ski> @djinn NotNot (((p -> q) -> p) -> p)
00:14:23 <lambdabot> f a =
00:14:24 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
00:14:29 <ski> @djinn ((p -> q) -> p) -> p
00:14:30 <lambdabot> -- f cannot be realized.
00:14:33 <Baughn> @clear
00:14:33 <lambdabot> Messages cleared.
00:14:40 <Heffalump> iaefai: I don't know any more than what I said above, sorry.
00:14:49 <iaefai> :-)
00:14:56 <Baughn> @tell ivanm Not yet.
00:14:56 <lambdabot> Consider it noted.
00:15:04 <pastah_rhymez> anyone: please say that you appreciate my screenshot :)
00:15:09 <iaefai> Heffalump, just out of curiosity, is it possible to install this not quite out cabal yet?
00:15:22 <copumpkin> pastah_rhymez: I appreciate your screenshot
00:15:30 <pastah_rhymez> copumpkin: thank you
00:15:33 <copumpkin> :)
00:15:38 <kmc> type NotNot a = (a -> Void) -> Void ?
00:15:50 <pastah_rhymez> copumpkin: now you can go and write a terminal based 3D shooter with shading and stuff
00:15:51 <ski> yes
00:15:54 <copumpkin> :O
00:16:22 <FunctorSalad> gtk2hs still doesn't build with new ghc eh?
00:16:40 <pastah_rhymez> copumpkin: also: http://web.student.chalmers.se/~goranssa/xterm.png
00:16:53 <FunctorSalad> why is the build process so complicated? (not rhetorical)
00:16:53 <copumpkin> oh nice
00:17:10 <ski> pastah_rhymez : that you appreciate my screenshot :)
00:17:12 <FunctorSalad> apparently what fails is some ghc-pkg / sed interaction o_O
00:17:20 <pastah_rhymez> ski: :p
00:17:50 <pastah_rhymez> now for the next part; blending in HSV space and not RGB
00:17:54 <ski> (which terminal is that ?)
00:18:32 <pastah_rhymez> ski: standard xterm on ubuntu 9.10
00:18:44 <pastah_rhymez> http://www.frexx.de/xterm-256-notes/
00:19:01 <pastah_rhymez> i started with that and Haha and worked my way up to the screenshots
00:20:25 <copumpkin> hahaoya?
00:21:35 <Heffalump> iaefai: yes, grab from darcs - I guess you need both cabal-install and the Cabal library
00:23:01 <pastah_rhymez> copumpkin: haha, haskell version of aa-lib
00:23:08 <copumpkin> just being silly :)
00:27:09 <Veinor> bah, I've hit a wall
00:27:45 <ivanm> Baughn: :(
00:27:45 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
00:28:00 <copumpkin> Veinor: I have a sledgehammer here if you need it
00:28:22 <ski> pastah_rhymez : ok, what did you think of my variant above ?
00:29:07 <BMeph> Veinor: Ouch! ;)
00:29:42 <Veinor> :P
00:29:54 <Veinor> I just... can't think of how to put this algorithm into code. Even pseudocode.
00:30:37 <pastah_rhymez> ski: paste somewhere, plz :)
00:30:44 <copumpkin> Veinor: maybe this here sledgehammer can help?
00:30:53 <pastah_rhymez> i don't think i know what you're referring to :)
00:30:59 <iaefai> I hate it when something that should be so easy doesn't make any sense, and for once it isn't haskell the language.
00:31:35 <Baughn> ivanm: Also. Not that much point @telling me when I'm still in the channel.
00:31:52 <Veinor> I don't know how a sledgehammer would help :D
00:31:57 <ivanm> Baughn: right, but I don't know how big your scrollback buffer is
00:32:00 <ivanm> or if you have logs
00:32:05 <copumpkin> Veinor: what's the algorithm?
00:32:16 <copumpkin> there are few algorihtms that don't benefit from a good whack
00:32:16 <ivanm> hmmm.... I should probably clean my #haskell logs out, they're about 85M IIRC...
00:32:27 <Baughn> ivanm: Three days, irssi automatically stores things addressed to me separately, and I have 800MB of logs.
00:32:34 <ivanm> :o
00:32:38 * ivanm faints
00:32:46 <ivanm> Baughn: is there any reason for having logs that far back?
00:32:53 <Baughn> Whoops
00:32:54 <Baughn> 1.7GB
00:32:58 <Veinor> multiplication
00:33:00 <Baughn> ivanm: Is there any reason not to?
00:33:01 <Veinor> those blasted nimbers :P
00:33:06 <pastah_rhymez> Baughn: popular guy :)
00:33:12 <ivanm> Baughn: disk space!
00:33:17 <pastah_rhymez> Baughn: hello, i am going on your disk now
00:33:24 <Baughn> ivanm: This is the year of $80 1.5TB disks
00:33:30 <ivanm> think of the poor bits in the hard drives!
00:33:33 <pastah_rhymez> Baughn: how do like it? i'm EVERYWHEARZ!
00:33:35 * ivanm is using a laptop...
00:33:40 <Baughn> ivanm: Seriously, 1.7GB is /nothing/
00:33:52 <copumpkin> Veinor: do you have a mex?
00:34:02 <pastah_rhymez> Baughn: i could write a script...
00:34:13 <Veinor> basically, they can be evaluated using the following properties: multiplication and addition form a field. if if 2^a > k, then 2^(2^a) * 2^k = 2^(2^a+k)
00:34:14 <ivanm> Baughn: also, I've found when trying to search through my logs that emacs doesn't like files that are 80MB in size, let alone 1.7GB...
00:34:22 <Baughn> ivanm: Yeah, so use grep.
00:34:22 <pastah_rhymez> i'm hoping you haven't turned on flood protection...
00:34:27 <Veinor> copumpkin: I have a mex, I'm just trying to make it go fast
00:34:27 <Baughn> ivanm: Or less
00:34:31 <ivanm> (I wanted to search for a particular discussion I'd had with roconnor about Colour and copy a whole section out)
00:34:38 <copumpkin> Veinor: oh, fast :P
00:34:43 <ivanm> Baughn: not as easy to copy out a particular segment using less...
00:34:44 <Veinor> indeed :P
00:34:52 <Baughn> ivanm: No, but at least it works
00:34:56 <ivanm> true
00:34:57 <Veinor> oh, also 2^(2^a) * 2^(2^a) = 2^(2^a) + 2^(2^a-1)
00:35:16 <Veinor> where exponentiation is the usual exponentiation, but addition is num-addition (ie, xor)
00:35:37 <Veinor> the way I figure it, I just have to write a function that calculates 2^a * 2^b
00:35:39 <Baughn> ivanm: Oh. Have you tried asking emacs to open the file in read-only mode? That'd lend itself better to not using way too much memory; random-access read-write pretty much requires that
00:35:41 <p_l> ivanm: ed works fine
00:35:49 <pastah_rhymez> ivanm, Baughn: a friend once wrote a script for scraping images from irc and save them (4chan etc.), so another guy in the channel knew this and posted a link that linked directly to /dev/random
00:35:52 <ivanm> Baughn: hmmm, never thought of that...
00:36:00 <pastah_rhymez> bye bye disk space :)
00:36:16 <Veinor> haha
00:36:19 <ivanm> pastah_rhymez: heh
00:36:19 <p_l> pastah_rhymez: I did this with telnetting to a DC hub...
00:36:21 <Baughn> ivanm: I wouldn't offer good odds on it working, though. :P
00:36:23 <Veinor> well, it'd be /dev/urandom
00:36:29 <Veinor> /dev/random will quickly block :P
00:36:38 <p_l> pastah_rhymez: apparently crashed gateway router as well as the hub :D
00:36:39 <ivanm> @slap p_l
00:36:39 * lambdabot slaps p_l with a slab of concrete
00:36:42 <ivanm> (for the ed comment)
00:36:42 <copumpkin> Veinor: yeah, not sure how to make it faster :P
00:36:52 <copumpkin> I'm assuming your code is the version on github
00:37:02 <Veinor> copumpkin: well, I'm pretty sure you can make it faster using the algorithm I just described :P
00:37:08 * p_l breaks the slab of concrete with the might of ED, THE STANDARD TEXT EDITOR
00:37:11 <Veinor> the problem is implementing it
00:37:12 <copumpkin> oh, missed that
00:37:14 <Veinor> yeah
00:37:29 * Baughn has edited haskell source in ED, the STANDARD TEXT EDITOR
00:37:47 * pastah_rhymez is scared of ed
00:37:47 <copumpkin> Baughn++
00:38:05 <Veinor> nano is what I use when I'm on a terminal.
00:38:13 <zachk> > let strange k = let i = (-1) ^ (k - 1) in i * ((k + ((i + 1) `div` 2)) `div` 2) in take 10 $ map strange [1..]
00:38:14 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5]
00:38:20 <zachk> woot
00:38:29 <pastah_rhymez> p_l, Baughn: you should look into making an ED mode for yi
00:38:41 <pastah_rhymez> :)
00:38:42 <Veinor> zachk: :D
00:38:49 <Baughn> pastah_rhymez: You can't say just "ED". It's "ED, THE STANDARD TEXT EDITOR".
00:38:57 <pastah_rhymez> not that anyone would use it, but it would be cool :)
00:39:06 <pastah_rhymez> Baughn: sorry, won't happend again
00:39:09 <zachk> i have new obession and its math ++ haskell for doing the calculations
00:39:23 <zachk> cant sleep
00:39:33 <copumpkin> lol
00:39:35 * p_l used ED, THE STANDARD TEXT EDITOR, to install operating systems using dumb terminals (and by dumb, I mean directly talking on serial port without any control characters)
00:39:36 <copumpkin> you have the bug
00:39:41 <copumpkin> lots of us do
00:40:06 <Veinor> I'm thinking that for now I'm going to just clean up the code, maybe haddock it up and submit it to hackage
00:40:06 <Zao> p_l: Sounds like an excellent situation to have a cat walking in your keyboard.
00:40:17 <zachk> i tried not thinking about primes i though thinking about series/sequences would put me to sleep. no luck :-(
00:40:27 <p_l> Zao: especially when you don't know the OS very well :D
00:40:42 <pastah_rhymez> zachk: how long to the closest midnight?
00:40:49 * Baughn uses ED, THE STANDARD TEXT EDITOR to automatically rewrite haskell-mode $version tags
00:40:58 <zachk> its 3:42 am here and i need to be awake at 8
00:41:11 <Veinor> I mean, I do have all the stuff I need implemented. it's just horribly unoptimal
00:41:12 <ivanm> Baughn: really?
00:41:23 <Baughn> ivanm: Well, once. Really, I use sed.
00:41:25 * ivanm wacks zachk over the back of the head with a 4-by-2
00:41:29 <ivanm> Baughn: heh
00:41:30 <pastah_rhymez> zachk: write some C, that ought to make you sleep
00:41:41 <zachk> i loathe C , and i always have
00:45:50 * BMeph used to have a problem with ED, THE STANDARD TEXT EDITOR, but then he had a talk with his physician who recommended these awesome little blue pills... ;p
00:46:11 <medfly> lol
00:46:25 * Baughn wonders. "ED, GENTLEMAN ADVENTURER"?
00:46:39 <copumpkin> ED? YOU SHOULD TAKE VIAGRA
00:47:05 <ivanm> with how Ord instances need to be Eq first, does that make Ord a super- or a sub-class of Eq?
00:47:21 <Baughn> sub-class
00:47:41 <Baughn> The types it allows is a subset of those Eq allows
00:47:51 <ivanm> right
00:47:59 <ivanm> I can never keep the order of sub- and super- straight :s
00:48:30 <netinho2lol> sup guys
00:48:43 <blackh> Errr... sup
00:48:47 <sieni> ivanm: Well, it's easy. superclass or superset is something that has more elements
00:49:00 <ivanm> sieni: right
00:49:02 <netinho2lol> do you know where can I find a list of all OPTIONS_GHC ?
00:49:09 <ivanm> netinho2lol: why are you wanting to eat male humans?
00:49:20 <ivanm> netinho2lol: the GHC user's guide presumably
00:49:40 <ivanm> netinho2lol: more specifically, I think OPTIONS_GHC is pretty much all command-line flags to ghc
00:49:56 <netinho2lol> ivanm: eating human males?
00:50:00 <ivanm> @wn sup
00:50:02 <lambdabot> *** "sup" wn "WordNet (r) 2.0"
00:50:02 <lambdabot> sup
00:50:02 <lambdabot>      n : a small amount of liquid food; "a sup of ale" [syn: {swallow}]
00:50:02 <lambdabot>      v : take solid or liquid food into the mouth a little at a time
00:50:02 <lambdabot>          either by drinking or by eating with a spoon
00:50:04 <lambdabot>      [also: {supping}, {supped}]
00:50:09 <ivanm> netinho2lol: ^^
00:50:13 <netinho2lol> lulz
00:50:25 <BMeph> zachk: I still like using C now and then, but I mostly like to tease "hardcore" C mongerers about how they never want to use data/control structure without finding out how it messes around with stack frames... ;p
00:50:28 <blackh> ivanm: "sup" means drink, doesn't it?
00:50:52 <ivanm> blackh: usually more for drinks or soups, yes
00:51:05 <ski> "sup" means "supremum"
00:51:19 <MisterN> ski is right.
00:51:20 <ivanm> ski: no, "supremum" means "supremum"
00:51:29 <copumpkin> sup means supper
00:51:30 <copumpkin> mmm
00:51:33 <ski> ivanm : that as well :)
00:51:37 <ivanm> http://www.google.com.au/search?hl=en&q=define%3Asup
00:51:39 <BMeph> "sup" is what you do at supper. Just like you dine at dinner. :)
00:51:43 <Veinor> sup?
00:51:47 <p_l> Baughn: “Baughn wonders. "ED, GENTLEMAN ADVENTURER"?” <--- OH MY GOD WHAT HAVE I DONE
00:51:52 <ivanm> BMeph: zigackly!
00:53:17 <netinho2lol> ivanm: can't find much in the users' guide
00:53:25 <Baughn> p_l: It makes sense, you know it does
00:53:45 <Baughn> p_l: Ed intends to destroy all other editors, and then at last itself. It will allow Emacs to help it with this.
00:54:44 <blackh> netinho2lol: What do you want the GHC_OPTIONS for?
00:55:05 <netinho2lol> because I run ghci with lots of flags
00:55:08 <ivanm> netinho2lol: ghc --help
00:55:13 <ivanm> ;-)
00:55:46 <ivanm> OK, not really
00:55:55 <ivanm> man ghc would probably have more
01:07:54 <ivanm> with cabal, is it possible to have an executable that is a non-Main module?
01:18:12 <cjs> How does one ensure that a ByteString (strict, not lazy) is in normal head form (fully evaluated)? ought not 'length s `seq` s' do the trick?
01:18:21 <ivanm> cjs: AFAIK, it is
01:18:24 <ivanm> since it's strict...
01:20:38 <shrughes> s `seq` ...
01:20:57 <cjs> And if I copy it, first, I should be guranteed that it won't be holding any other ByteStrings it was derived from in memory, right?
01:20:57 <ivanm> shrughes: that usually just evaluates to whnf, not hnf
01:20:59 <ivanm> cjs: maybe use deepseq?
01:21:07 <ivanm> cjs: *shrug*
01:21:48 <blackh> cjs: ByteString is strict, so if it's evaluated at all, it's fully evaluated.
01:22:28 <cjs> This is driving me nuts. I replaced a newtype of an Int with a newtype of a strict ByteString and suddenly I'm leaking space like mad.
01:23:18 <ivanm> cjs: try with lazy
01:23:26 <ivanm> cjs: maybe you're evaluating/reading too much
01:23:29 <blackh> cjs: a newtype of a ByteString should be completely strict
01:23:35 <cjs> Now admittedly that ByteString is derived from some much longer ones, but copy should take care of that.
01:23:58 <cjs> Evaluating too much could cause a space leak?
01:24:11 <ivanm> maybe ;-)
01:24:15 * ivanm is guessing
01:24:18 <blackh> cjs: Is your code pasteable
01:24:42 <cjs> Hm. I'm not sure.
01:25:02 <ivanm> cjs: too sikrit?
01:25:07 <ivanm> or too long?
01:25:13 <cjs> Well, part of it is a stock exchange simulator....
01:25:32 <ivanm> so both?
01:26:01 <cjs> Of course it's not long, it's written in Haskell!
01:26:03 <cjs> :-)
01:26:19 <ivanm> is it long compared to other haskell libs/apps?
01:26:21 <cjs> Where else could you write an entire stock exchange simulator in 500 lines of code?
01:26:29 <ivanm> i.e. more than a single module?
01:26:32 <ivanm> cjs: :o you serious?
01:26:33 <MisterN> cjs: in R.
01:26:38 <cjs> ivanm: Very.
01:26:40 <ivanm> I take it the data it uses isn't in the module?
01:26:47 <ivanm> MisterN: yes, but then it's slow...
01:27:16 <MisterN> ivanm: it's fast in haskell?
01:27:43 <cjs> Hm. So I was using, in this sim, prices represented as a Fixed2, which is just a newtype Int where the number is scaled by 100. I've now got something called an ExactPrice, which is a 171 line module that I think is safe to paste.
01:27:48 <ivanm> it would probably be faster... isn't R interpreted?
01:28:08 <cjs> And I could use advice on that, anyway. Let me get something set up.
01:28:37 <MisterN> ivanm: yes, R is interpreted, but this doesn't imply that the haskell version is faster
01:28:59 <MisterN> ivanm: a well-written C++ version would most definitely be faster, but i don't know if the same holds for haskell.
01:29:05 <ivanm> I would think in general that it would be
01:29:49 <ivanm> it depends on how much you rely on statistics stuff that is defined into R (that is, it isn't interpreted but uses pre-compiled C-based libraries or something)
01:29:54 <MisterN> well, it depends how well you can do certain operations with haskell
01:31:12 <ivanm> true
01:31:19 <cjs> http://www.cynic.net/1831/ExactPrice.hs
01:31:38 <cjs> That's got my copy and seq hacks in there.
01:31:51 <ivanm> cjs: I take it cynic.net is your non-starling-software site?
01:31:59 <cjs> Yeah, my personal one.
01:32:07 <ivanm> I wonder if OverloadedStrings does anything...
01:32:23 <cjs> It's handy for the unit tests.
01:32:40 <ivanm> cjs: have you actually profiled to tell where the leak is coming from?
01:33:11 <cjs> Which you can probably run with extremely minor tweaks just by importing Test.HUnit rather than Starling.Test. Or you can just delete the unit tests and that import.
01:33:27 <ivanm> cjs: you're converting to/from bytestrings a fair amount... isn't that usually a bad thing to do?
01:34:06 <cjs> ivanm: Yes. It wasn't terribly useful, unfortunately. Using a version compiled for profiling my space leak is that consumer threads can't keep up with producer threads and channels explode.
01:34:22 <ivanm> hmmm...
01:34:30 <cjs> Ususally. this can definitely use some optimization; I just wrote it the other day,.
01:34:31 <ivanm> sure that isn't the case for non-profiled build as well?
01:34:45 <cjs> No, because a non-profiled build can run multicore.
01:34:52 <ivanm> ahhh
01:34:59 <cjs> Yeah, it's been a real killer for me.
01:35:13 <cjs> I can do another -hT run and see what it says, though.
01:35:42 <ivanm> preflex: seen dons
01:35:43 <preflex>  dons was last seen on #xmonad 1 day, 11 hours, 57 minutes and 59 seconds ago, saying: feel free to do the conversion and upload the repo
01:35:47 <ivanm> preflex: seen dcoutts
01:35:48 <preflex>  dcoutts was last seen on #haskell 9 hours, 43 minutes and 47 seconds ago, saying: poe: aye, I think we've tweaked the wording for the next release
01:36:49 <cjs> Anyway, I'm open to any suggestions on improving that module even if it's nothing to do with the space leak.
01:37:16 <ivanm> cjs: first of all, leave spaces on either side of a `.' to stop it looking like OOP code! :p
01:37:28 <ivanm> cjs: I wonder if bytestring-show would be any better/efficient than pack/unpack...
01:37:32 <cjs> Hee hee.
01:37:40 <cjs> Show does something entirely different.
01:37:48 <cjs> > show $ pack "bingo"
01:37:49 <lambdabot>   Not in scope: `pack'
01:38:02 <cjs> > show $ Data.ByteString.Char8.pack "bingo"
01:38:03 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'
01:38:19 <cjs> Well, anyway, it shows you the chunks. Oh, wait, that's a lazy ByteString.
01:38:51 <ivanm> which is?
01:39:37 <cjs> Hm. Yes, strict ones show as a string shows.
01:39:43 <ivanm> cjs: by bytestring-show, I mean the actual bytestring-show package
01:39:55 <cjs> Oh!
01:40:04 <ivanm> by dolio
01:40:57 <cjs> Mmm, possibly.
01:41:19 <cjs> So you're talking about mkExactPrice, right? Not readExactPrice?
01:42:09 <cjs> BTW, -hT says the big leaker is bytestring-0.9.1.4:Data.ByteString.Internal.PS. Next worst is ghc-prim:GHC.Types.:.
01:42:43 <cjs> Most of the ExactPrices going into the simulator module are constructed by readExactPrice, by the way.
01:42:54 <fritschy_> regarding monads, are there some best practices or patterns on how to desiogn/lay out code to have it clean and functional? ;) As far as i understood, there have to be some "monadic" code paths that can call pure functions but will never be called from a pure function? If tat's rubbish, tell me to RTFM more ;)
01:43:29 <ben0x539> fritschy_: That is a immediate consequence of the types involved :)
01:43:38 <ivanm> cjs: I wonder if that's the small corner case that resulted in 0.9.1.5 ...
01:43:48 <ivanm> cjs: try upgrading bytestring (which is usually a no-no) and see if it helps
01:43:56 <fritschy_> ben0x539: so there must be some patterns to do it right?
01:44:05 <cjs> Hm! That's an interesting thought. What makes you say that?
01:44:10 <ben0x539> fritschy_: You cannot get it wrong, the compiler would complain.
01:44:34 <ivanm> cjs: because I know there was a corner case in bytestring that resulted in 0.9.1.5
01:44:39 <cjs> And upgrading ByteString, well, hmm....that could be an interesting exercise. I could give it a go.
01:44:47 <ben0x539> fritschy_: Functional code can *return* IO actions, but IO actions would only ever be executed if they are composed into the 'main' IO action...
01:44:48 <ivanm> that wouldn't normally be a problem, but one package (forget which) needed it
01:45:13 <ivanm> cjs: it'll install in parallel so install it, see if it works, if it doesn't then uninstall it and there won't be any problems
01:45:21 <cjs> ivanm: So, basically, you think the code as it stands isn't doing anything wrong, leak-wise?
01:45:29 <fritschy_> ben0x539: how does this work for/with other monads? aren't they polluting the functions they're called from?
01:45:33 <ivanm> cjs: the problem will be if it _does_ magically improve your app... then you have to manually track down every package that uses bytestring and rebuild it :s
01:45:39 <cjs> Oh, is it easier now? I've heard horror stories about upgrading ByteString.
01:45:39 <fritschy_> bad wording, i know ;)
01:45:45 <ivanm> cjs: I haven't used bytestring enough to know how it works
01:45:54 <ben0x539> fritschy_: It is pollution when IO does it because IO is somewhat analoguous to impure code
01:45:59 <ivanm> cjs: no, it's still a horror story
01:46:18 <ben0x539> fritschy_: IO has to be run through composition with main, most other monads have a way to run them 'purely'
01:46:26 <ivanm> cjs: but if you just want to test the one module, then it should be OK to have it installed in your user account rather than system
01:46:30 <fritschy_> ben0x539: oh, nice :)
01:46:34 <ivanm> cjs: have you tried using a lazy bytestring to see if that improves anything?
01:46:35 <ben0x539> fritschy_: Like if you do a computation n the list monad, the result is a list so you just take the values out.
01:46:43 <cjs> Ooo, I just realized: maybe length is the wrong way to go with strict bytestings!
01:46:54 <ivanm> cjs: heh
01:47:04 <cjs> After all, with a lazy bytestring, you traverse the spine to get the length. But with strict, you already know it.
01:47:07 <ivanm> cjs: otherwise, the only other things I can think of is that you're over-using pack/unpack, or that it's the bytestring bug
01:47:12 <ivanm> cjs: exactly
01:47:20 <ben0x539> fritschy_: Or Parsec's parsing monad, there are functions to apply the parser to a given input string or whatever -- a given monad Foo tends to have a runFoo function.
01:47:29 <ivanm> cjs: though I would have thought that Bytestring.length would be an O(1) for strict...
01:48:14 <cjs> For strict, it would just look at the bounds.
01:48:29 <cjs> That might not force, e.g., copy to actually copy the data.
01:48:40 <fritschy_> ben0x539: ok, that's giving me hope ;)
01:49:00 <quicksilver> strict bytestrings are fully forced by definition though
01:49:00 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
01:49:06 <quicksilver> (fully forced if you force them at all)
01:49:14 <ben0x539> What do the !!s do in bytestring's definition?
01:49:26 <ivanm> quicksilver: he wants to avoid any pointer sharing IIUC
01:49:35 <cjs> Are they. Hmm. Seems so. using last instead of length didn't help.
01:49:55 <ivanm> ben0x539: I'd guess same as !! for lists
01:50:01 <ivanm> > [1..10] !! 3
01:50:02 <lambdabot>   4
01:50:04 <quicksilver> ben0x539: cause you to raise your eyebrows when reading the definition out loud.
01:50:17 <quicksilver> ben0x539: (they mean the fields are strict)
01:50:37 <ben0x539> 'PS !!(ForeignPtr Word8) !!Int !!Int'
01:51:00 <ben0x539> I thought a single ! did that already.
01:51:04 <ivanm> quicksilver: isn't that just !, not !!?
01:51:14 <cjs> ivanm: I really can't conceive of how lots of pack/unpack could be a problem. In the end, all that comes out is a strict bytestring, and especially if I copy it, it should retain nothing else.
01:51:15 * quicksilver nods
01:51:18 <ben0x539> Hmm, maybe haddock is betraying me. The actual source seems to have just !.
01:51:25 <ben0x539> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Internal.html#1
01:51:34 <cjs> ben0x539: Yes, I recall that. It's a Haddock bug.
01:51:35 <quicksilver> ben0x539: I think it's some curious haddock bug or workaround but I can't remember what/why
01:51:42 <ivanm> cjs: I would think that it would be expensive
01:51:45 <ben0x539> Oh, okay. :(
01:51:45 <cjs> That had me going for quite a while, too, earlier this year.
01:52:07 <ben0x539> "Okay, for bytestrings - they need to be *stricter* than strict. They are just that low-level."
01:52:23 <ivanm> heh
01:52:32 <cjs> ivanm: Well, I'm not too worried about CPU at the moment, though I'll probably start worrying soon. Space leaks are a much bigger problem, because I'm processing five million or so messages from the exchange over six hours.
01:52:43 <ivanm> right
01:52:54 <ivanm> cjs: which is why I would have thought lazy bytestrings might be better
01:53:15 <ivanm> anyone know if this cabal hack is still valid? http://haskell.org/pipermail/haskell-cafe/2007-November/034689.html
01:53:51 <cjs> Lazy bytestrings tend to retain more, in my impression. Remember, they're just lists of strict bytestrings.
01:54:30 <cjs> Anyway, I have to start out with strict, because I'm reading messages from the network. I tried the getContents thing a couple of times before I realized how wrong that is for a network server. :-)
01:54:33 <ivanm> true
01:54:37 <ivanm> heh
01:55:15 <cjs> Ah, the early days.
01:55:34 * cjs reminisces
01:56:02 <cjs> Hm. Anyway, I'll try lazy bytestrings. It's easy, and can't do any harm.
02:02:53 <smiler> In what (cabal) package can I find Data.Number ?
02:03:33 <ivanm> http://www.holumbus.org/hayoo/hayoo.html?query=Data.Number
02:03:52 <ivanm> bah, that wasn't as useful as I thought
02:03:55 <ivanm> smiler: numbers ?
02:04:45 <ivanm> nope
02:04:51 <smiler> I'm looking for Data.Number.{BigFloat,CReal,Dif,Fixed} and so on
02:05:00 <ivanm> smiler: oh, you should have said so
02:05:02 <ivanm> that is numbers
02:05:11 <ivanm> smiler: there is no Data.Number module anywhere AFAICT ;-)
02:05:18 <smiler> Ah :)
02:05:19 <smiler> Thanks
02:05:27 <ivanm> smiler: that's what Hayoo is useful for
02:05:51 <cjs> Hm, no, non-strict doesn't seem to fix it.
02:06:12 <ivanm> cjs: :(
02:06:20 <quicksilver> cjs: you said that when you profiled, the problem was channels filling up faster than they could be serviced
02:06:29 <quicksilver> do you have reason to believe that *isn't* the case normally?
02:06:30 <cjs> That I've got : leaking a lot, too, is very suspcious, though.
02:06:32 <ivanm> quicksilver: he said that was because profiling wasn't multicore
02:06:41 <quicksilver> he did, but I wondered if he was sure about that
02:07:08 <smiler> ivanm: Cool, I'll remember that
02:07:09 <cjs> quicksilver: Yes; if I go back to using a newtype Fixed2 = F2 Int in place of the ExactPrice, the leak goes away entirely.
02:08:38 <quicksilver> hmm. A newtype over strict bytestring should have identical space behaviour to a newtype over Int
02:08:55 <quicksilver> ok, not identical, but proportioanl ;)
02:09:06 <cjs> quicksilver: That was sort of my thought!
02:09:11 <quicksilver> obviously it takes more space, but only by a constant multiple.
02:09:23 <quicksilver> unless you're accidentally creating very long bytestrings
02:10:03 <cjs> So I thought I might be retaining something, but copying the final ByteString and "last s `seq` s"'ing it before handing it to the data constructor should take care of that.
02:11:56 <cjs> This is obviously Haskell's revenge on me for declaring at ICFP that I felt I finally had a reasonable handle on space leaks. :-)
02:15:21 <cjs> I have this funny feeling that it might be my goofy little state machine I built for readExactPrice, though.
02:15:43 <vy> What's wrong with this simple splitWith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12994#a12994
02:15:58 <cjs> I will go have a cigarette, contemplate my sins, and then rewrite that if nobody has a better idea when I come back. (Anything to delay installing a new version of bytestring.)
02:16:15 <mauke> :t span
02:16:15 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:16:48 <mauke> vy: the y
02:17:24 <cjs> vy: You want to produce a list of lists, but for the next list in the list of lists you call splitWith, which produces not a list but a list of lists.
02:17:35 <cjs> Errr....does that make sense? :-)
02:17:46 <mauke> according to my diagrams, 「y :: a」 and 「splitWith f ys :: [[a]]」 and 「(:) :: a -> [a] -> [a]」
02:17:59 <ivanm> mauke: what are all those boxes meant to be?
02:17:59 <vy> mauke: cjs: Hrm... I see, I think. Thanks.
02:18:10 <mauke> U+300C (e3 80 8c): LEFT CORNER BRACKET [「]; U+300D (e3 80 8d): RIGHT CORNER BRACKET [」]
02:18:11 <cjs> Essentially, you're doing an infinite recursion.
02:18:35 <cjs> Typewise, I mean.
02:18:43 <mauke> basically, splitWith returns a list of lists of elements, but you're trying to prepend a bare element to it
02:19:45 <cjs> I think of it, as, rather than [[],[],[]], your code is trying to produce [[],[[],[]]].
02:19:50 <cjs> Damn, that's not readable either!
02:20:20 <mauke> [X, [A1,A2,A3], [B1,B2,B3] ]
02:25:22 <cjs> Gah, I'm an idiot and a liar. (The two often go together.) It's actually mkExactPrice that's producing most of these values.
02:25:26 <cjs> If not all.
02:26:15 <cjs> ByteString really should come with its own printf. I wonder if that's what's borking me.
02:26:47 <ivanm> cjs: which encoding should ByteString use? :p
02:27:19 <cjs> ivanm: Hm? It's just digits, '-' and '.'. Not a lot to be worried about encoding-wise there, I'd think.
02:27:22 <vy> cjs: mauke: Here is the fixed version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12994#a12997 It still appears to be a little bit ugly.
02:27:37 <cjs> Oh, for the printf. Yeah. It should use, er, "C" encoding. :-)
02:27:51 <ivanm> cjs: the actual Bytestring is just Word values; you have to convert them to Chars somehow
02:28:02 <cjs> ivanm: I'm using Data.ByteString.Char8.
02:28:05 <ivanm> unless you mean the Char8 modules should have printf
02:28:13 <cjs> Yes, that was my thought.
02:28:25 <cjs> printf doesn't make a lot of sense for Word8s.
02:29:28 <mauke> I have a proto-printf for bytestrings
02:29:38 <cjs> (Incidently, in this case, fracLen is almost invariably 2.)
02:30:17 <mauke> http://mauke.ath.cx/preflex/Util/String.hs
02:31:36 <netinho2lol> mauke: do you know how I can concat a list of IOs?
02:32:06 <cjs> netinho2lol: sequence.
02:33:05 <netinho2lol> cjs: the prelude sequence?
02:33:31 <mauke> what do you mean by "concat"?
02:34:44 <netinho2lol> I have a list of lists of Strings
02:34:57 <netinho2lol> each of these lists of strings are a "pic"
02:35:01 <mauke> then you don't have IO
02:35:27 <netinho2lol> I can IO the lists of Strings
02:35:34 <mauke> IO is not a verb
02:35:41 <netinho2lol> using putStr . unlines
02:36:20 <mauke> ok, then what's the problem/what are you trying to do?
02:36:33 <cjs> mauke: Thanks. Though I'm not sure that I should really be using printf at all....
02:37:08 <netinho2lol> let me take a screenshot, mauke
02:38:06 <vy> I'm recursively walking over a [String]. In the "myWalker [] = ...", what should I replace "..." with?
02:38:21 <mauke> whatever you want, baby
02:38:33 <vy> mauke: Would a Nothing be appropriate?
02:38:42 <koeien37> vy: might be. depends on the rest.
02:38:44 <mauke> vy: well, what is this function suposed to do?
02:39:21 <vy> mauke: Recursively print first word of each line.
02:39:35 <mauke> that sounds like the wrong problem to solve
02:39:42 <mux> vy: then you should use mapM_ instead of rolling your own recursion
02:39:50 <mauke> I'd rather extract the first word of each string and return that as a list
02:39:54 <mauke> you can always print it later
02:40:03 <vy> mux: Sssh! I still don't know mapM_ at this chapter of RWH.
02:40:07 <mux> something like mapM_ (putStrLn . firstWord) ...
02:40:16 <mauke> vy: do you know map?
02:40:26 <vy> mauke: Neither map.
02:40:36 <mux> mapM_ (putStrLn . head . words)
02:40:47 <mauke> vy: 'k, then for [] you want to do nothing
02:40:52 <mauke> vy: in IO, that's 'return ()'
02:41:20 <vy> Hrmm... Maybe (putStr unlines ...) could be more appropriate.
02:41:27 <netinho2lol> mauke: http://imgur.com/JHSob.png
02:41:52 <ivanm> netinho2lol: O...K...
02:42:23 <netinho2lol> now I have a list of peh, for example, but if I map putPic over that list, I get a list of IO
02:42:46 <mauke> netinho2lol: mapM_
02:43:01 <mauke> @src mapM_
02:43:01 <lambdabot> mapM_ f as = sequence_ (map f as)
02:43:09 <mauke> so yeah, sequence would have worked
02:43:15 <MisterN> @src sequence_
02:43:15 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
02:43:23 <MisterN> @src sequence
02:43:23 <lambdabot> sequence []     = return []
02:43:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:43:23 <lambdabot> --OR
02:43:23 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:44:30 <netinho2lol> mauke, mind overload
02:44:40 <netinho2lol> let me try to understand the source, first :P
02:44:52 <mauke> you don't have to understand it to use it :-)
02:45:27 <netinho2lol> I have to understand if I want to learn :D
02:50:35 <netinho2lol> mauke: so, mapM_ maps a function to the list and then applies sequence to the output list, right?
02:50:50 <mauke> well, sequence_
02:50:52 <mauke> but yes
02:52:30 <cjs> netinho2lol: By the way, throwing the function name into hoogle, looking up the Haddoc docs from there, and clicking on "source" is often a good way to learn about these things. If you do that for mapM_, you'll see the definition:
02:52:33 <cjs> mapM_ f as      =  sequence_ (map f as)
02:52:53 <mauke> or he could just scroll twenty lines up
02:52:58 <cjs> (It's surprising how often the definition of the function is more clear than the documentation.)
02:53:10 <koeien37> that's imo a problem of the documentation :P
02:53:32 <koeien37> s/problem/shortcoming
02:53:35 <cjs> koeien37: You mean, the documentation isn't just the source code of the function? :-)
02:53:54 <mauke> no, the documentation is the type
02:53:59 <koeien37> cjs: well, at least in that case it's always consistent with the actual unction
02:57:06 <cjs> So what do people think about the idea of using unsafePerformIO to keep a cache to implement the Flyweight pattern for abstract data types?
03:00:37 <StarFire> Is it possible restrict the argument of a type class instance somehow? I'm trying to write something like "instance Monoid a => MonadPlus (Foo a)", but that obviously results in a kind error.
03:01:04 <mauke> does it?
03:01:37 <StarFire> It does, if Foo is * -> *
03:02:01 <quicksilver> StarFire: No.
03:02:06 <StarFire> quicksilver: OK.
03:02:14 <mauke> oh, I see
03:02:17 <quicksilver> StarFire: if Foo :: * -> * is going to be an instance of MonadPlus then by definition it is an instance for all a
03:02:25 <quicksilver> that's what it means to have a constructor class
03:02:32 <mauke> that's the usual "Set is not a Monad" thing
03:03:08 <StarFire> So it's not possible to use mappend in my mplus operation?
03:08:09 <netinho2lol> RAGE
03:08:19 <netinho2lol> I had a wonderful idea
03:10:11 <Veinor> is there a good tutorial for how to do stuff with haddock?
03:11:02 <mauke> http://www.haskell.org/haddock/doc/html/index.html ?
03:11:33 <Veinor> ah, thanks :P
03:19:32 <vy> Is the latest hpaste.el working for anyone?
03:20:40 * mauke uses http://mauke.ath.cx/stuff/perl/pastebin instead
03:21:02 <bastl> Hi all when issuing :info on a GADT, i get this line: Graph :: (($a) ~ Graph) => GraphFam Graph what does it mean? I dont know that syntax ...
03:25:36 <quicksilver> ~ is a type equality
03:25:52 <quicksilver> it's probably odd for it to be showing up on :info though
03:26:27 <bastl> there are some instances autogenerated by TH.
03:26:33 <bastl> what does $a mean ?
03:26:56 <mauke> wait, this is not #perl
03:27:17 <quicksilver> I have no idea what the $ is
03:27:31 <bastl> hmm
03:31:29 <bastl> here's my definition of the GADT and the result of ghci: Is the former syntactic sugar for the latter ?
03:31:38 <bastl> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5065#a5066
03:33:32 <opqdonut> bastl: the latter is type family stuff, i have no idea but GADTs might be implemented with tfs nowadays
03:33:34 <FunctorSalad_> what's the shortcut for fromRational . toRational again?
03:34:01 <opqdonut> :t fromRational . toRational
03:34:02 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
03:34:06 <mauke> :t realToFrac
03:34:07 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
03:34:13 <FunctorSalad_> I think the $ is the parameter of the GADT
03:34:16 <FunctorSalad_> $a
03:34:26 <opqdonut> yes, it is
03:34:36 <Athas> Is there a more elegant interface to Unix signals than System.Posix.Signals?
03:34:41 <quicksilver> opqdonut: GADTs were always implemented using TCs, I believe.
03:34:46 <FunctorSalad_> maybe the $a has the special meaning of "first parameter"?
03:34:49 <opqdonut> quicksilver: oh, okay
03:34:53 <quicksilver> opqdonut: GADTs were the reason TCs were added to GHC core
03:35:06 <quicksilver> but I think it's a bug for that to bubble through to :info
03:35:23 <quicksilver> (TC = type coercion, not type family, to split hairs a little more)
03:35:25 <FunctorSalad_> mauke: thanks
03:35:33 <Athas> I'm in a pickle where I have an interactive program with an event loop, and after every iteration of the event loop I want to do something special if I received a SIGCHLD during the iteration (so sort of like "synchronous signals").
03:35:51 <Athas> Is the most elegant thing really to have some IORef that my SIGCHLD handler frobs around in?
03:36:30 <opqdonut> Athas: why are you using SIGCHLD?
03:36:40 <opqdonut> and not for example forkIO & waitIO
03:36:44 <opqdonut> or whatever they were called
03:37:04 <Athas> opqdonut: I don't want to wait.
03:37:20 <pastah_rhymez> anyone know where i can find an e-mail adres to "Balazs Komuves", i can't find anything on his haskell page or in google
03:37:24 <Athas> I just want to be informed when one of my children terminate.
03:37:49 <tristes_tigres> Hello, I've had a disagreement with someone. He complained that he wanted an implementation of finger trees in C. I told him that this is not a maningful request, because C lacks the requisite abstraction tools, and, on the other hand, can achieve the same goals faster. Do you think I am correct ?
03:38:54 <fasta> tristes_tigres, you are wrong.
03:38:54 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
03:39:35 <tristes_tigres> fasta: in what way ?
03:40:06 <fasta> tristes_tigres, you can implement finger trees in C.
03:40:12 <path[l]> is there a way to get the third part of a tuple
03:40:14 <path[l]> like fst and snd
03:40:27 <fasta> path[l], Data.NTable, or something like that.
03:40:34 <tristes_tigres> fasta: It is obvious that I can, but you are quite missing the point
03:40:37 <path[l]> thanks
03:40:47 <pastah_rhymez> @faq can you make better finger trees in haskell than in c?
03:40:48 <lambdabot> The answer is: Yes! Haskell can do that.
03:40:49 <fasta> path[l], or if you don't like complex messages, you just pattern match.
03:41:12 <fasta> tristes_tigres, of course, I am missing the point. Go tell everyone you are right.
03:41:27 <fasta> Why ask, if you already know the Truth?
03:41:46 <tristes_tigres> fasta: why reply to the question I did not ask ?
03:42:11 <fasta> tristes_tigres, you told him that it was "not a meaningful request".
03:42:17 <path[l]> well I kinda have 2 lists and i want to find indexes where they both don't match. So I did a zip3 of a b and [1,2..] and then a filter (\(p,q,r) p!=q) and then I need to get r
03:42:31 <fasta> tristes_tigres, if you don't believe me, just wait until someone else either agrees with me or agrees with you.
03:43:01 <fasta> tristes_tigres, or you might want to define what is "meaningful".
03:43:40 <tristes_tigres> fasta: quite right. Finger tree are built on top of the abstractions that are missing in C. To "write" them in C means habing first to implement those abstractions
03:44:22 <fasta> tristes_tigres, which abstractions?
03:44:35 <tristes_tigres> in C++ or C# it may be a meaningful exercise
03:44:40 <tristes_tigres> but not in C
03:44:53 <fasta> tristes_tigres, well, I don't agree, and probably nobody in this channel does.
03:45:18 <fasta> tristes_tigres, you might want to try ##c if you want to be proven right, but I think they will also say you are wrong.
03:45:19 <quicksilver> C has void pointers and function pointers
03:45:32 <fasta> Maybe #php :D
03:45:34 <mauke> C has macros
03:45:37 <quicksilver> which are entirely sufficient, although not at all safe clearly.
03:45:49 * mauke builds his templates by hand
03:45:52 <quicksilver> and fingertrees have some advantages even in a C-like environment
03:45:53 <path[l]> <blah> $ filter (\(p,q,r) -> p != q) $ zip3 orig dest [1,2..]
03:46:05 <path[l]> I want that to give me all the rs
03:46:06 <quicksilver> like persistence and sharing of substructures, if you happen to care about those.
03:46:07 <path[l]> where p != q
03:46:13 <tristes_tigres> faquicksilver: but not void pointers to void
03:46:17 <opqdonut> path[l]: well you can always say (\(_,_,x) -> x)
03:46:26 <path[l]> ah
03:46:26 <path[l]> ok
03:46:28 <path[l]> got it
03:46:29 <path[l]> thanks
03:46:36 <mux> or even (,,x) with the latest tuple sections extension in ghc
03:46:41 <opqdonut> ah
03:47:12 <mauke> [ y | (x, y) <- zip (zipWith (/=) orig dest) [1 ..], x ]
03:47:12 <quicksilver> catMaybes $ zipWith3 (\p q r -> if p /= q then Just r else Nothing) orig dest [1..]
03:47:15 <opqdonut> path[l]: _or_ even better you can use findIndiced
03:47:19 <opqdonut> :t findIndices
03:47:20 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
03:47:21 <quicksilver> or, if you want to be cute,
03:47:44 <quicksilver> catMaybes $ zipWith3 (\p q r -> gurad (p /= q) >> return r) orig dest [1..]
03:47:46 <opqdonut> so something like "findIndices (uncurry (==)) $ zip as bs"
03:48:04 <opqdonut> quicksilver: gurad?
03:48:05 <path[l]> hmm
03:48:25 <path[l]> I knew there were neater options
03:48:25 <path[l]> lol
03:48:26 <quicksilver> guard.
03:48:30 <quicksilver> (sorry)
03:48:31 <tristes_tigres> fingertrees are needed to implement quick access to data, and this can be achieved by simplier means in C
03:48:42 <path[l]> let me see what zipwith does first
03:48:51 <quicksilver> tristes_tigres: persistence and sharing of substructures.
03:49:13 <path[l]> aha
03:49:42 <tristes_tigres> quicksilver: as I said, I do not doubt that one can re-implement parts of GHC in C and than re-implement fingertrees on top of that
03:49:50 <quicksilver> tristes_tigres: I did not say that.
03:49:53 <quicksilver> you would not have to
03:50:08 <quicksilver> I am giving you the two main advantages of fingertrees which are not 'quick access to data'
03:50:16 <path[l]> not in scope catMaybes
03:50:19 <quicksilver> those two advantages are persistence and sharing of substructures.
03:50:23 <fasta> tristes_tigres, why are you continuing this conversation? YOU ARE WRONG. That was all you wanted to know.
03:50:45 <path[l]> I like mauke's solution. Its using ideas I already know :/
03:50:46 <fasta> If you want to learn something, stop arguing.
03:50:53 <quicksilver> you can use those, for example, to efficiently store an undo buffer.
03:50:58 <quicksilver> (which Yi does I believe?)
03:51:08 <quicksilver> and that is an advantage in any language, C-like or not.
03:51:12 <tristes_tigres> fasta: I am not prepared to to take your word on this, I am afraid. I would want some reasoning
03:51:30 <quicksilver> you are being given reasoning. You don't appear to be listening.
03:54:21 <quicksilver> lambdabot: @messages
03:54:21 <lambdabot> yitz asked 1d 14h 10m 59s ago: does this look familiar? http://www.haskell.org/pipermail/libraries/2009-November/012812.html if so, please comment on the list.
03:54:31 <quicksilver> @tell yitz Good point. Done.
03:54:31 <lambdabot> Consider it noted.
03:55:08 <path[l]> oh maybe dumb question. How do I quit from ghci
03:55:31 <quicksilver> path[l]: I entirely sure you can guess that.
03:55:36 <tristes_tigres> quicksilver: you said that fingertrees' advantage is not "quick access to data", and then you said that they may be used to "efficiently store an undo buffer"
03:55:44 <path[l]> exit and quit don't work
03:55:48 <path[l]> I keep hitting ctrl-D
03:55:56 <quicksilver> path[l]: what letter is used for ghci commands?
03:56:02 <quicksilver> (or character I should say)
03:56:11 <quicksilver> the command is ":quit" of course :)
03:56:13 <path[l]> got it
03:56:14 <path[l]> thanks
03:56:15 <path[l]> lol
03:56:18 <path[l]> your clue helped
03:56:22 <tristes_tigres> effieiceint sotrage of undo buffer can be written in C witghout fingertrees. And it will be more efficient, likely
03:56:41 <quicksilver> tristes_tigres: you seem almost like you're trolling.
03:57:00 <quicksilver> fingertrees are a clever solution to an undo buffer, sharing most of the data between all the revisions of the data
03:57:07 <quicksilver> I don't dispute there *are* other clever solutions to that, too.
03:57:21 <quicksilver> but they are one, which makes them useful.
03:57:37 <quicksilver> and I doubt you have any reason to think some other (unspecified) implementation will be more efficient
03:57:47 <quicksilver> I think you just made that up without giving it any thought.
03:58:46 <tristes_tigres> quicksilver: I think that you simply switched into defensive mode without giving my question any thoght
04:00:06 <fasta> tristes_tigres, sure, quicksilver and not thinking.
04:00:42 <koeien37> tristes_tigres: fwiw, i don't see why it cannot or shouldn't be done in C. I wouldn't say it is particularly convenient, but we are programming in C after all
04:00:52 <fasta> tristes_tigres, please write a faster finger tree in C and brag then. Also prove its correctness, please, with something like Ynot.
04:01:10 <tristes_tigres> koeien: I said twice that it can be done
04:01:24 <fasta> tristes_tigres, you started with that it was not "meaningful".
04:01:36 <tristes_tigres> that is not the question, but fasta insists on answering it over and over
04:01:36 <koeien37> tristes_tigres: i know. focus on the "shouldn't"
04:01:38 <fasta> tristes_tigres, did you already switch w.r.t. that?
04:02:07 <paul424> anyone knows the hugs interpretter ? how do I start the evaluation in it ?
04:02:29 <koeien37> paul424: a bit more specific? you can enter your expressions at the hugs prompt
04:02:36 <tristes_tigres> fasta: There are things that can dt done, and that are meaningless. I think it's a very clear distinction
04:02:50 <paul424> paul424: woops, I mean how do I stop :)
04:02:50 <fasta> tristes_tigres, well, keep believing in that fantasy.
04:02:57 <koeien37> paul424: stop? try CTRL+C
04:03:02 <tristes_tigres> koeien: yes, I am thinking more along the lines of "shouldn't"
04:03:26 <paul424> koeien37: yeah I tried already , but that does not heolp .
04:03:38 <tristes_tigres> fasta: you believe that eveything that can be done, also should be done ?
04:03:55 <fasta> tristes_tigres, I believe that meaningful and "should" have different meanings.
04:04:20 <koeien37> paul424: hmm. you can always kill the process, i don't know of a more graceful way than CTRL+C :(
04:04:22 <fasta> tristes_tigres, so, I believe you are asking something else now and I also happen to believe there are cases where implementation in C can be useful.
04:04:31 <tristes_tigres> fasta: you are just refusing to understand what I am saying, that's all
04:05:04 <fasta> tristes_tigres, of course. I am intentionally trying to misunderstand you.
04:05:26 <tristes_tigres> koeien: I agree that it is not conveneient at all. It does not fit the C way of doing things, and therefore I think it is not meaningful
04:05:38 <tristes_tigres> fasta: It would seem so, yes
04:05:50 <koeien37> tristes_tigres: it is not particularly convenient in the same way that writing quicksort in C is not convenient
04:06:03 * fasta asks for ops to kill this conversation. 
04:06:17 <sieni> there are very few things that are convenient in c
04:06:20 <mux> it is not convenient in the same way that writing any data structure in C is not convenient due to the lack of polymorphism
04:07:05 <tristes_tigres> sieni: writing programs that are faster and use less memory IS more convenient in C
04:08:00 <sieni> tristes_tigres: do you write c code for living?
04:08:07 <quicksilver> it's possible to argue that binary trees are "not convenient in C"
04:08:11 <quicksilver> compared to, e.g., haskell
04:08:18 <quicksilver> nonetheless they are widely used.
04:08:38 <opqdonut> it's possible to argue that C is not convenient, nonetheless - -
04:08:46 <quicksilver> the case of fingertrees is not deeply fundamentally different - just you also have an implicit or explicit monoid operation
04:09:07 <quicksilver> (and measure operation, or you just specialise to something concrete)
04:10:49 <tristes_tigres> sieni: benchmarks on haskell.org would seem to support my contention implementation of the same algorithm in C tends to use less memory and be faster, than haskell. It is also harder to write and debug, of course
04:11:13 <Axman6> tristes_tigres: `depends on the task
04:11:30 <sieni> tristes_tigres: so what?
04:11:54 <tristes_tigres> sieni: so this is an example of the task for which C is more convenient
04:12:11 <quicksilver> but you haven't said what the task is?
04:12:19 <quicksilver> fingertrees are a structure, not a task.
04:12:35 <quicksilver> if the task is a resizeable mutable array then, yes, fingertrees are not the obvious choice in C
04:12:38 <tristes_tigres> quicksilver: implementing algorithms with minimal hardware resources
04:12:50 <quicksilver> (although they are used for that in haskell, in a sense)
04:13:05 <Axman6> tristes_tigres: that's not a task
04:13:09 <quicksilver> but if the task involves sharing or persistence then there are reasons to consider them.
04:13:25 <sieni> tristes_tigres: so how does the marginally shorter execution time translate into convenience since somebody also has to write the program?
04:13:53 <tristes_tigres> Axman9: thell that to people who write firmware
04:14:14 <Axman6> no
04:14:32 <fasta> tristes_tigres, if the people who write firmware were more clued in on software issues, they would not do it in the ways they do it right now.
04:14:33 <Axman6> and it's still not a task, it's a goal
04:14:46 <dibblego> I say, this discussion is quite silly
04:14:47 <quicksilver> when did we start talking about firmware?
04:14:53 <fasta> tristes_tigres, writing firmware is only a secondary goal; it's not their core-business.
04:14:56 <quicksilver> this discussion isn't going in circles, it's spiralling through the void.
04:15:13 <fasta> dibblego, you make 2 then.
04:15:23 <sieni> there are worse things in life than writing C
04:15:47 <sieni> I would think that writing C++ would be particularly horrendous experience
04:16:56 <Axman6> tristes_tigres: also, guess what, haskell isn't aimed at firmware developers (even though firmware _is_ written using haskell)
04:17:05 <sieni> C very elegantly combines the abtraction level of Fortran IV with the portability of Assembler.
04:17:15 <netinho2lol> omg
04:17:23 <netinho2lol> mauke, you're a btard
04:17:30 <mauke> am I?
04:17:31 <Axman6> o.O
04:17:41 <fasta> mauke, no, you are not.
04:17:50 <mauke> netinho2lol: you're a ubuntu user
04:17:58 <netinho2lol> mauke: guilty
04:17:59 <opqdonut> ouch, under the belt!
04:18:05 <Axman6> netinho2lol: gross
04:18:12 <Axman6> mauke: play fair man
04:18:25 <pastah_rhymez> does ghc still generate slower code if you have a type signature in your where-clause?
04:18:39 <opqdonut> ??
04:18:48 <netinho2lol> mauke: you have really cool stuff in your site, specially the c codes
04:18:48 <opqdonut> did it do that?
04:18:57 <pastah_rhymez> opqdonut: cool bug
04:19:05 <tristes_tigres> quicksilver: I am trying to say that C is language that should be used when the goal is to minimize hardware resources utilization. Using complicated abstractions does not fit the language
04:19:15 <opqdonut> pastah_rhymez: do you have a link or something?
04:19:29 <fasta> tristes_tigres, you are very good at not presenting a point.
04:19:38 <fasta> tristes_tigres, trolls also do that.
04:19:47 <quicksilver> tristes_tigres: complicated is a difficult and subjective notion.
04:19:56 <quicksilver> tristes_tigres: in fact, the correct abstraction invariable simplifies a problem
04:20:00 <quicksilver> that's why you use it.
04:20:16 <quicksilver> whenever you face a programming problem - in any domain, in any language - you should aim for the abstractions which simplify the problem.
04:20:28 <quicksilver> there are a million different reasons to use C
04:20:42 <netinho2lol> assembly :)
04:20:43 <quicksilver> minimising hardware and resource utilization in just one possible one.
04:20:51 <thp> what is the most efficient way of splitting a list into three pieces: (list of elements left to the center), center element, (list of elements right to the center)?
04:21:15 <quicksilver> (arguably portability is a more major one)
04:21:35 <Axman6> quicksilver: you can't argue that! C's not good at it@
04:21:36 <Axman6> !*
04:21:39 <quicksilver> whilst there may well be some contexts in which a fingertree in C would be a poor choice, that doesn't make fingertrees *always* irrelvant in C.
04:22:01 <quicksilver> if your abstraction is making life more complicated for you, then you're doing it wrong.
04:22:03 <opqdonut> thp: use length and breakAt, optimize it when you need to
04:22:23 <thp> opqdonut: thanks
04:22:26 <pastah_rhymez> opqdonut: can't find it now, but i know i've read it
04:23:12 <opqdonut> thp: there is probably some cool slow pointer - fast pointer solution, but it'd iterate over the list twice too
04:23:33 <koeien37> opqdonut: you mean a bit like Floyd's trick?
04:23:36 <opqdonut> thp: anyway, if you need to that often for long lists, you probably have the wrong datastructure
04:24:46 <koeien37> opqdonut: i guess that'll work. but i agree -- profile first if you think you have a problem
04:24:47 <opqdonut> something like "f (x:xs) (_:_:ys) = let (a,b) = f xs ys in (x:a); f xs [] = ([],xs)"
04:25:01 <thp> opqdonut: thanks. by looking at the docs, i think with breakAt you mean splitAt
04:25:06 <opqdonut> (off the top of my head, doesn't handle corner cases)
04:25:11 <opqdonut> thp: yeah, that :)
04:25:31 <Axman6> quicksilver: what are finger trees again?
04:25:34 <koeien37> opqdonut: something like that should work, and then g xs = f xs xs.
04:25:45 <thp> i guess i can work with that. thanks for the pointers :)
04:26:09 <opqdonut> koeien37: yeah, something like that :) but the complexity isn't really worth it
04:26:14 <tristes_tigres> quicksilver: the description of fingertrees in the original article is, "functional representation of persistent sequences supporting access to the ends in amortized constant time".
04:26:14 <tristes_tigres> Persistent sequences supporting access to the ends in amortized constant time can be achieved simplier in C, can't it ?
04:26:29 <quicksilver> Axman6: if I could explain in one sentence, there would have been no point Hinze + Patterson writing that lovely paper on it :)
04:26:31 <koeien37> opqdonut: depends. often not. but otherwise, write a naive and a complicated one and quickcheck it :)
04:26:34 <mauke> tristes_tigres: how?
04:26:42 <quicksilver> tristes_tigres: off the top of my head, I can't think how
04:26:55 <quicksilver> (which is not to say "no" - I'm sure other techniques exist)
04:27:06 <Axman6> quicksilver: heh, i see. i couldn't remember if they were something simple i was familliar with under another name. i'll google it :)
04:27:09 <quicksilver> although they might end up being a concretisation of fingretrees if you look at them carefully
04:27:17 <quicksilver> Axman6: http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
04:27:31 <benmachine> could anyone offer opinions on installing xmonad from my OS' package manager (pacman) versus installing it via cabal install?
04:27:35 <Axman6> ta
04:27:46 <quicksilver> tristes_tigres: I remark that 'persistent' is the important word, though
04:27:53 <koeien37> benmachine: cabal install might give you a newer version
04:28:00 <tristes_tigres> quicksilver: by working with pointers
04:28:05 <quicksilver> erase that word and, yes, it's trivial to do it in true constant time.
04:28:07 <koeien37> benmachine: if you are familiar enough with cabal, you can use that
04:28:23 <tristes_tigres> quicksilver: I think the more important keyword is "functional"
04:28:30 <benmachine> koeien37: I don't know about familiarity; generally I find it more difficult to do a system upgrade with cabal
04:28:49 <quicksilver> tristes_tigres: what do you understand by 'persistent' ?
04:29:05 <tristes_tigres> it's the data structure designed to work within the particular limitations of functional programming
04:29:12 <koeien37> benmachine: that is true. if your package manager's xmonad version suffices for you, i'd go with that (similar reasoning for GHC)
04:29:16 <quicksilver> tristes_tigres: no.
04:29:25 <koeien37> "limitations"
04:29:35 <Axman6> tristes_tigres: okl, seriously, do you have a point here? or are you just trolling?
04:29:39 <quicksilver> tristes_tigres: a persistent data structure is when which, when "modified" still retains O(1)-access to the old version.
04:30:04 <quicksilver> tristes_tigres: so if you take a string and replace one char in the middle, you have O(1)-access to the old string as well as the new.
04:30:06 <tristes_tigres> koeien: now you are being defensive
04:30:16 <quicksilver> a trivial way to achieve persistence is always copy everything.
04:30:23 <mauke> tristes_tigres: now you are being annoying
04:30:24 <quicksilver> ..but of course that makes all operations O(n).
04:30:48 <quicksilver> so, the "clever" persistent data structures are those which achieve persistence with better complexity that O(n) on various useful operations.
04:33:03 <benmachine> is cabal install likely to get better at upgrading lots of things in the future?
04:33:09 <benmachine> near future, I mean
04:33:39 <ivanm> preflex: seen dcoutts
04:33:40 <preflex>  dcoutts was last seen on #haskell 12 hours, 41 minutes and 44 seconds ago, saying: poe: aye, I think we've tweaked the wording for the next release
04:34:19 <tristes_tigres> quicksilver: OK, I see the point when persistence is important. The way I understood the motivation of the fingertrees was to mitigate the consequences of immutability
04:34:28 <straw> Hey, let's say I have a [Bool]. Additionally I have indexes and want to 'flip' these certain indexes? How would I do that? Or how do I change only a few elements in a list anyway?
04:34:44 <mauke> straw: you wouldn't use a list for that
04:34:46 <quicksilver> tristes_tigres: right, that's why I focussed on persistence + sharing as the application domains
04:34:56 <straw> mauke: uhm, ok, but it's a task :)
04:35:00 <quicksilver> tristes_tigres: if you're not interested in those then they are indeed not interesting in C.
04:35:09 <mauke> straw: then I'd use splitAt
04:35:44 <straw> mauke: Ok, thanks. I look it up. (We implement a simple 'memory management' using [Bool] ;o)
04:36:56 <Axman6> straw: what course is this for? (i've seen a lot of people in here the last few days talking about implementing something that sounds very similar)
04:37:55 <ivanm> Axman6: you have? I don't recall anything about it...
04:38:19 <koeien37> i've seen something about a typeclass Memory. but that may also have come from straw
04:38:41 <Axman6> nah, there's been others (unless he keeps chainging nicks)
04:39:07 <straw> Axman6: it's a course about algorithms and data structures, mainly using Java and Haskell
04:39:20 <desp> Looks like calling atexit via FFI ends in a bus error; http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13004
04:39:24 <straw> and nope, it's my first time here ;]
04:39:28 <Axman6> straw: where?
04:39:33 <desp> Any ideas how to guarantee that somethings gets done before exiting?
04:39:40 <straw> Axman6: FU Berlin
04:41:19 <Axman6> desp: finaliser? :\
04:42:01 <desp> Axman6: tried that, and apparently the docs lie.
04:42:10 <desp> Either that, or there's a bug in GHC.
04:42:23 <desp> Not sure, #ghc is nonresponsive.
04:42:31 <Axman6> or you're doing it wrong ;)
04:43:36 <desp> That's also likely; here's my attempt at using finalizers, if anyone fixes it I'll be glad: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12993
04:44:09 <desp> The documentation disagrees between Foreign.ForeignPtr and Foreign.Concurrent on whether finalizers are supposed to be guaranteed to be run before exiting.
04:44:52 <Axman6> quicksilver: ah ha! this is a paper i saw ages ago, and couldn't find it when i went looking for it some time after! thanks a lot for the link :)
04:45:26 <ben0x539> goddamn, hayoo is down
04:45:36 <koeien37> god can't help that
04:45:56 <koeien37> hoogle is up & running though
04:46:14 <Axman6> i wish hayoo had a more memorable URL
04:46:26 * koeien37 <3 firefox awesomebar
04:46:31 <Axman6> like... hayoo.org, or haskell.org/hayoo
04:46:46 <ivanm> koeien37: you only found out about it now?
04:46:47 <ivanm> :o
04:47:02 <koeien37> ivanm: no :) just that i don't car ethat much anymore about memorable urls
04:47:13 <ivanm> @slap FGL for not having Show instance for PatriciaTree
04:47:13 * lambdabot will count to five...
04:47:24 <ivanm> tbh, FGL is a really shitty library...
04:47:50 <desp> @lap Random for not having Random instance for Int16
04:47:50 <lambdabot> Maybe you meant: map slap
04:47:55 <desp> Why yes I did.
04:48:59 <Axman6> > map slap [ desp, ivanm, koeien37]
04:49:00 <lambdabot>   Not in scope: `slap'Not in scope: `desp'Not in scope: `ivanm'Not in scope: ...
04:50:00 <ben0x539> koeien37: I am bad at using hoogle :(
04:50:23 <ben0x539> Axman6: But hayoo has one of those handy search engine plugins that plug it into firefox' search bar :3
04:50:38 <Axman6> ben0x539: oo, that is handy
04:50:53 <smiler> I've setup lambdabot but it tosses an fd:8: hClose: resource vanished (Broken pipe) whenever I try to use for example @unlambda or @bf. Any idea on what it tries to do that's failing?
04:50:53 <ben0x539> (hoogle does too, but it only searches a tiny subset of hackage, doesn't it)
04:51:57 <Axman6> ben0x539: i prefer not to look on hackage first
04:53:34 <ben0x539> Axman6: If I am using some random cabal package, it seems easier to type the function name into hayoo than figure out where I installed the documentation :/
04:53:49 <Axman6> i just use ghci :\
04:53:56 <Axman6> types are usually all i need
04:54:05 <Axman6> but, i should use hayoo more
04:54:38 <tristes_tigres> quicksilver: I guess I tend to view persistence of the functional data structres as a liability, but probably it may be a feature sometimes. Strange that it was not used in some VCS
04:54:58 <Axman6> VCS?
04:55:00 <ivanm> Axman6: :o
04:55:09 <koeien37> version control system
04:55:19 <Axman6> i though so, but wanted to make sure
04:55:54 <quicksilver> combining (this kind of) persistence with on-disk representation (a.k.a the other kind of persistence! confusing language!) is not a very well-trodden path I don't think.
04:56:43 <koeien37> read/show :P
04:57:53 <Axman6> quicksilver: thanks again for linking to that paper. i think i had read an article about finger trees in the past, but it wasn't through enough. but the paper is extremely clear, and it's reminding me why i love haskell again :D
04:58:29 <quicksilver> koeien37: read/show loses the sharing
04:58:35 <quicksilver> koeien37: so it 'breaks' the persistence, in a sense
04:58:44 <quicksilver> at least, it breaks the efficient storage.
04:58:53 <koeien37> ah sure
04:59:12 <Axman6> although, this annoys me: a <| Deep pr m sf = Deep ([a] ++ pr) m sf... did they forgret about :?
04:59:17 <koeien37> you could probably do it, but needs some work
04:59:19 <quicksilver> I have seen a couple of things on -cafe about sharing-restoring deserialisation.
05:00:09 <tristes_tigres> vacuum package can extract GHC values in order to present them as a graph, so it presumably can with little modification save them.
05:00:33 <quicksilver> certainly although it's pretty evil
05:00:37 <quicksilver> mmorrow++ # evil
05:00:40 * Axman6 loves Data.Binary for data persistance
05:00:56 <Axman6> or, serialisation i should say
05:03:11 <ivanm> how does one use -main-is for ghc?  it doesn't seem to link an executable together when I use it
05:03:28 <ivanm> I'm trying to use Data.GraphViz.Testing.runDefaultTests as the main function :s
05:03:38 <tristes_tigres> quicksilver: so something that could be a rationale for functional data structures is not implemented at all
05:03:39 <Axman6> has anyone tried implementing B-Trees in haskell? i gave it a go a while ago, but it proved to be very difficult (for me at least)
05:03:59 <pastah_rhymez> Axman6: do you mean real ones?
05:04:08 <pastah_rhymez> with rotations and balancing?
05:04:20 <Axman6> B-Trees are self balancing no?
05:04:31 <Axman6> B-Trees, not binary trees
05:04:34 <pastah_rhymez> Data.Map's are
05:04:40 <pastah_rhymez> oh, what are those?
05:05:04 <Axman6> pastah_rhymez: they're really cool, that's what they are :P i'll get you the lecture slides for our course if you like
05:05:25 <pastah_rhymez> yeah, that'd be a nice relaxation from this HSV bullshit
05:05:39 <Axman6> they're used a lot in databases
05:05:47 <pastah_rhymez> (soon do be done, just need to figure out how to walk the shortest path in a HUE-circle)
05:07:13 <eugenn> @src maximize
05:07:13 <lambdabot> Source not found. My brain just exploded
05:07:27 <quicksilver> Axman6: yes, I did B*-trees or something
05:07:36 <quicksilver> Axman6: or B#-trees, I can never remember the daft names
05:07:37 <Axman6> B+Trees?
05:07:41 <quicksilver> maybe ;)
05:08:36 <Axman6> B+-Trees seem like they'd be even more difficult to implement in haskell, since they require the bottom leaves to the tree to point to the 'next' bottom branch. i can't imagine it being done without pointers
05:10:38 <Axman6> pastah_rhymez: got a favourite file hosting website? i'll need tpo upload the slides
05:11:10 <pastah_rhymez> Axman6: dunno, i always upload stuff to school :)
05:11:39 <quicksilver> Axman6: well yes, you do it all with pointers, of some sort
05:11:40 <Axman6> well, i'm on windows, and i refuse to download an ftp client. i'll go find something somewhere :P
05:11:47 <eugenn> > (\f x -> foldl1 (max . $f) x) (1+) [2,3,4]
05:11:48 <lambdabot>   <no location info>: parse error on input `$'
05:12:01 <eugenn> > (\f x -> foldl1 (max . f) x) (1+) [2,3,4]
05:12:02 <lambdabot>   4
05:12:03 <quicksilver> Axman6: I think I just used Integers, pointers for some arbitrary virtual model
05:12:05 <ivanm> Axman6: my favourite file hosting website is c.h.o ...
05:12:06 <ivanm> ;-)
05:12:13 <quicksilver> Axman6: (with an implementation using files and hSeek)
05:12:32 <quicksilver> I know I intended to do another implementation using bytestrings, read-only, for testing, but can't remember if I did.
05:12:59 <pastah_rhymez> Axman6: win-scp?
05:13:01 <Axman6> sounds fascinating. wouldn't mind seeing that
05:13:02 <eugenn> > (\f -> foldl1 (max . f)) (1+) [2,3,4]
05:13:03 <lambdabot>   4
05:13:11 <Axman6> pastah_rhymez: dropbox ;)
05:13:20 <pastah_rhymez> Axman6: /dcc?
05:13:32 <pastah_rhymez> i think that's my favourite filesharing service
05:13:36 <Axman6> running irssi on my serber
05:13:40 <Axman6> v*
05:14:12 <pastah_rhymez> Axman6: one of these? http://www.pbase.com/stefan_serb/image/58806008
05:14:26 <eugenn> > (\f -> foldl1 (min . f)) (^2) [(-2),(-1),0,1,2,3,4]
05:14:27 <lambdabot>   0
05:14:43 <Axman6> yup
05:14:57 <pastah_rhymez> or maybe this dude? http://upload.wikimedia.org/wikipedia/commons/d/d4/N.Tesla.JPG
05:15:14 <eugenn> @pl > (\f -> foldl1 (max . f))
05:15:14 <lambdabot> (line 1, column 1):
05:15:14 <lambdabot> unexpected ">"
05:15:14 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:15:32 <eugenn> @pl (\f -> foldl1 (max . f))
05:15:32 <lambdabot> foldl1 . (max .)
05:16:05 <Axman6> pastah_rhymez: http://dl.dropbox.com/u/43370/21-btrees-2x2.pdf
05:16:32 <ivanm> pastah_rhymez: what have you got against Serbs?
05:17:03 <pastah_rhymez> ivanm: what gave the impression that i should have something against them?
05:17:29 <ivanm> pastah_rhymez: *shrug* most of the rest of the international community does :s
05:17:32 <ivanm> ;-)
05:18:05 <Axman6> not as much as israel atm
05:18:36 <eugenn> > (foldl1 . (max .)) (^2) [(-4),(-3),(-2),8,(-1),0,87]
05:18:37 <quicksilver> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13006#a13006
05:18:37 <lambdabot>   340282366920938463463374607431768211456
05:18:43 <quicksilver> Axman6: (yes, you were right, it was B+)
05:19:08 <eugenn> > foldl1 . (max .) (^2) [(-4),(-3),(-2),8,(-1),0,87]
05:19:09 <lambdabot>   Couldn't match expected type `a -> a -> a'
05:19:09 <lambdabot>         against inferred type `[...
05:19:11 <ivanm> Axman6: bah, everyone always hates the serbs (except for maybe the russians)
05:19:21 <ivanm> Axman6: whereas the world seems to always be split on Israel
05:19:39 <quicksilver> Axman6: I don't recall if it compiles ;) it certainly mostly worked at one point.
05:19:54 <Axman6> heh
05:20:56 <ivanm> if I want to have a library and an executable that uses that library in the same package, do I have to duplicate all the modules for the cabal file?
05:21:16 <Axman6> i don't believe you do
05:23:27 <ivanm> \o/
05:24:07 <pchiusano> hi i have a silly question - i just downloaded the haskell platform, and it seems to include a version of cabal, but there doesn't seem to be any command line cabal file... is there more I have to do to get cabal up and running?
05:24:42 <bastl> FunctorSalad: I'm playing around with generic rewriting here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5067#a5067 Do you have an idea how I can make "rewrite" independent of the Family ? e.g.: make the family itself an additional paramenter?
05:24:44 <ivanm> pchiusano: you mean cabal-install?
05:24:45 <Axman6> quicksilver: yeah seems you've come at the problem from the other end which i was interested in. i was more interested in writing a functional B-Tree structure from scratch, and not using other data structures in the process. still impressed though
05:24:50 <ivanm> pchiusano: should be there...
05:24:57 <ivanm> pchiusano: which OS/distro ?
05:25:01 <Axman6> it isn't there for me on windows either
05:25:05 <pchiusano> ivanm: windows
05:25:17 <Axman6> so, i decided to give up on writing haskell until i get my macbook pro back
05:25:41 <pchiusano> oh, it is not there for windows?
05:25:52 <quicksilver> Axman6: don't be impressed, it's trivial :) It's just implementing from books / lecture notes / web pages :)
05:26:09 <quicksilver> Axman6: the only remotely clever bit was instantiating the abstract interface via Handles as well as via ByteStrings.
05:26:31 <Axman6> heh
05:26:32 <ivanm> pchiusano: I'm guessing it's not in the PATH properly
05:26:39 <quicksilver> Axman6: I'm not sure what the advatanges of a "functional B+ tree" would be, over the conventional varieties of tree
05:27:10 <pchiusano> ivanm: no, there are no executable binaries for cabal in the installation dir
05:27:26 <Axman6> i'd still be very interested to see B-Tree (not B+) implemented in haskell though. i couldn't figure it out
05:27:28 <pchiusano> but there are a bunch of .hi files, and a .o file
05:28:20 <Axman6> pchiusano: does running cabal help in cmd work? (i just realised it did for me, and that windows sucks because it doesn't have tab completion)
05:28:43 <ivanm> pchiusano: *shrug*
05:29:37 <pchiusano> Axman6: damn, that worked
05:29:41 <pchiusano> i am an idiot
05:29:48 * Axman6 blames windows
05:29:50 <pchiusano> i just noticed it is actually in the extralibs dir
05:29:58 <pchiusano> which i didn't see :)
05:30:15 <pchiusano> arright, sorry to bug y'all, move along
05:30:34 <rwx> does the partition function end up making two passes over a list, or one?
05:30:40 <Axman6> hey, i learnt something, you've wasted no one's time :)
05:30:52 <Axman6> rwx: which partition function?
05:30:56 <Axman6> @hoogle partition
05:30:57 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
05:30:57 <mauke> @src partition
05:30:57 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
05:30:57 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
05:30:57 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
05:30:57 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
05:30:59 <lambdabot>                               | otherwise = (ts, x:fs)
05:31:12 <Axman6> one pass
05:31:18 <Axman6> there's only one foldr
05:31:38 <eugenn> you can't get the number that maximizes a function without explicit recursion, can you? and with only one pass
05:31:38 <mauke> I wonder why select takes p as an extra argument
05:32:48 <eugenn> @src otherwise
05:32:48 <lambdabot> otherwise = True
05:32:55 <rwx> Axman6, the one in Data.List
05:33:53 <rwx> ah :-) i didn't check the source, i just read the description given "i.e. partition p xs == (filter p xs, filter (not . p) xs)"
05:33:56 <rwx> thanks!
05:33:59 <Veinor> how can I get ghci to import a module that's in the local directory?
05:34:25 <rwx> but as a followup, would ghc optimize that to make one pass? i don't have an understanding of what ghc does and doesn't do
05:34:25 <Axman6> :l, and i think :m will do it too
05:34:54 <mauke> partition p = foldr (\x -> (if p x then first else second) (x :)) ([], [])
05:35:01 <Axman6> rwx: no, because you may only want to use one of those halves, so it'll be more lazy if it remains as the current definition
05:35:02 <mauke> rwx: I don't think it would
05:35:13 <Veinor> :m won't do it
05:35:22 <Veinor> and :l loads it, not imports it
05:35:44 <Axman6> well, import it into a file you're working on then
05:36:18 <Veinor> that works :P
05:37:02 <hotzen> hi all, i have problems with assoc data types. why is "instance Graph G3 where type Edge G3 = (Int,Int)" distinct from "instance ... where type Edge G4 = (Int,Int)" ? I dont understand when it matters to use type-family or data-family
05:37:49 <hotzen> with list-constructors on the other hand, haskell implies injectivity? i dont get it ...
05:38:08 <Lemmih> hotzen: What?
05:38:14 <eugenn> @src succ
05:38:14 <lambdabot> Source not found. Are you on drugs?
05:38:33 <eugenn> > succ 1
05:38:34 <lambdabot>   2
05:38:38 <Veinor> also, is there a stylistic way to determine whether to use let/where?
05:39:06 <hotzen> Lemmih: I am talking about  the oleg,peyton jones fun with type functions paper
05:39:07 <quicksilver> hotzen: your question was hard to follow but the words which might form your answer are in there
05:39:15 <eugenn> > let h=(+1) in h 8
05:39:16 <lambdabot>   9
05:39:20 <quicksilver> hotzen: associated data is automatically injective because it's a fresh type
05:39:23 <hotzen> i dont get the injectivity
05:39:29 <quicksilver> hotzen: associated type synonym is not injective
05:39:38 <quicksilver> which means the inferer can't draw certain conclusions.
05:40:08 <hotzen> what does injective mean in this topic? the type function itself is injective?
05:40:13 <quicksilver> yes.
05:40:16 <hotzen> if i use types instead of data, it is not?
05:40:23 <quicksilver> not guaranteed to be, yes
05:40:39 <quicksilver> in your example above, you have two different types G3 and G4 for which Edge G3 == Edge G4
05:40:47 <quicksilver> so, that's a failure of injectivitiy.
05:41:30 <hotzen> because both times the Edge constructor results in the same Tuple (Int,Int) which is by def not injective?
05:41:59 <quicksilver> I wouldn't call Edge a constructor here ;)
05:42:04 <Veinor> also, I have a style question
05:42:05 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13007#a13007
05:42:07 <hotzen> k
05:42:07 <quicksilver> Edge is a type function (or an indexed type family)
05:42:12 <hotzen> yes
05:42:22 <Veinor> is that haskell-y?
05:42:26 <quicksilver> yes, if two Graphs types can have the same Edge type, that is obviously not injective
05:42:30 <quicksilver> since that's what injective means.
05:42:35 <hotzen> quicksilver: thank you, have to further think about ;)
05:43:41 <Axman6> Veinor: i always put the where on the line after the function definition
05:44:15 <Veinor> well, I guess the question is: is expressing this function as a bunch of where statements haskell-y
05:44:18 <Axman6> and line up the parts of the where with the first definition in the where
05:44:54 <eugenn> > let a (b,c) d = (b d,c d) in (succ,pred) 7
05:44:54 <Axman6> sure, works for me
05:44:54 <lambdabot>   Couldn't match expected type `t1 -> t'
05:44:55 <lambdabot>         against inferred type `(a ->...
05:45:03 <Axman6> i think i read your blog earlier btw
05:45:06 <eugenn> > let a (b,c) d = (b d,c d) in a (succ,pred) 7
05:45:07 <lambdabot>   (8,6)
05:45:26 <Veinor> :D
05:45:30 <Axman6> > (succ *** pred) 7
05:45:31 <lambdabot>   No instance for (GHC.Num.Num (b, b'))
05:45:31 <lambdabot>    arising from the literal `7' at <i...
05:45:36 <Axman6> > (succ &&& pred) 7
05:45:37 <lambdabot>   (8,6)
05:45:41 <Veinor> in retrospect I kind of wish I had gone with Data.MemoTrie given that it's easier to use
05:45:49 <Axman6> heh
05:45:53 <stroan> Axman6: I'm becoming quite sure you're as much a bot as lambdabot. I never read this and you're not active ;)
05:45:55 <Veinor> but I didn't realize it existed at the time, and plus MemoTrie doesn't have a wrap
05:46:01 <Axman6> well, you'll know for next time
05:46:19 <eugenn> > (succ &&& pred &&& succ) 9
05:46:20 <Veinor> you have to mess around with making your argument a HasTrie and I'm not entirely sure what's involved in that
05:46:20 <lambdabot>   (10,(8,10))
05:46:21 <Axman6> stroan: ?
05:46:48 <eugenn> :t (&&&)
05:46:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:47:14 <stroan> just find it funny that I go to bed reading you talk about something, and I wake up and you're helping someone else. it's rather impressive
05:47:53 <Axman6> eugenn: that type is difficult, but all you need to do is replace a with (->), and realise that (->) b c == b -> c
05:48:07 <Axman6> stroan: where in the world are you?
05:48:14 <stroan> ireland
05:48:34 <Axman6> yeah, that explains it. i'm an aussie, and i;m on holidays, without a job :P
05:49:28 <stroan> I stand by my point of it being impressive :)
05:49:29 <Rayne> in ghci i can multiply 2 with 2.0, if i write "x = 2::Integer and y=2::Double" into a text file and try to do a=x*y it fails with an error, why?
05:49:45 <mauke> Rayne: because you can only multiply numbers of the same type
05:50:00 <eugenn> > 4 + 3.5
05:50:01 <lambdabot>   7.5
05:50:24 <eugenn> > 4 * 3.5
05:50:25 <lambdabot>   14.0
05:50:30 <Axman6> :t (*)
05:50:31 <lambdabot> forall a. (Num a) => a -> a -> a
05:50:37 <Axman6> Rayne: ^^^^^^^^^^^^^^^^6
05:50:51 <Axman6> Rayne: you can only multiply things of the same type
05:51:07 <Rayne> so if i enter 2*2.0 ghci converts 2.0 to integer 2?
05:51:10 <eugenn> :t 4
05:51:11 <lambdabot> forall t. (Num t) => t
05:51:12 <ben0x539> no
05:51:12 <Axman6> no
05:51:13 <mauke> Rayne: no
05:51:16 <Axman6> 2 -> 2.0
05:51:21 <eugenn> :t 3.5
05:51:22 <lambdabot> forall t. (Fractional t) => t
05:51:24 <Axman6> using fromInteger
05:51:29 <mauke> :t 2 * 2.0
05:51:30 <lambdabot> forall t. (Fractional t) => t
05:51:43 <Axman6> :t ?2 * 2.5
05:51:44 <lambdabot> parse error on input `?'
05:51:48 <Axman6> bah
05:52:09 <eugenn> > sqrt 2
05:52:10 <lambdabot>   1.4142135623730951
05:52:12 <zygoloid> Axman6: 2 can't be the name of an implicit parameter :)
05:52:30 <Axman6> zygoloid: just you wait...
05:52:31 <eugenn> > 4 * arcTan 1
05:52:32 <lambdabot>   Not in scope: `arcTan'
05:52:38 <Axman6> atan
05:52:43 <Jedai> Rayne: integer literal are polymorphic
05:52:54 <eugenn> ups, arcTan is in smalltalk :P
05:53:02 <eugenn> > 4 * atan 1
05:53:03 <lambdabot>   3.141592653589793
05:53:39 <quicksilver> Rayne: in fact, ghci/ghc doesn't do any automatic conversions, but what is confusing is that number literals ("constants") are polymorphic and decide what type to be by context.
05:53:49 <eugenn> @src atan
05:53:49 <lambdabot> Source not found.
05:53:56 <mauke> it's a method IIRC
05:54:02 <Jedai> Rayne: they may be of any numeric type, so inference decides what their type should ultimately be
05:54:46 <rwx> the GpuGen from Galois et al: are they going to release it? everything i see is from 2008. i understand it's probably a real competitive advantage
05:55:06 <Rayne> ah, thanks quicksilver
05:55:09 <Jedai> Rayne: Even decimal literals are polymorphic, though they may only be of the Fractional class because not every Num have (/)
05:55:36 <voidprayer> Igloo, thank you for your help in http://hackage.haskell.org/trac/ghc/ticket/3668
05:55:48 <Rayne> thanks a lot
05:56:09 <eugenn> > 125 % 25
05:56:09 <lambdabot>   5 % 1
05:57:30 <voidprayer> i am sorry that i have a problem with building ghc. I set "SRC_LD_OPTS+= -fno-PIE" in mk/build.mk to avoid hardened toolchains' problem, but the build fails at:
05:57:42 <voidprayer> /var/tmp/portage/dev-lang/ghc-6.10.4/work/usr/bin/ghc -o genapply -package-conf /var/tmp/portage/dev-lang/ghc-6.10.4/work/ghc-6.10.4/libraries/bootstrapping.conf -H32m -O -optc-march=native -opta-march=native -optc-nopie -optl-nopie -opta-Wa,--noexecstack -w -package pretty -fforce-recomp    -fno-PIE   GenApply.o
05:58:00 <voidprayer> the -fno-PIE is directly sent to ghc. should SRC_LD_OPTS sent to ld?
05:58:09 <voidprayer> thanks
05:58:58 <eugenn> :t lambda
05:58:59 <lambdabot> Not in scope: `lambda'
05:59:21 <lpsmith> :t \x -> x
05:59:22 <lambdabot> forall t. t -> t
05:59:29 <lpsmith> :t \x -> x +1
05:59:30 <lambdabot> forall a. (Num a) => a -> a
05:59:31 <eugenn> :t id
05:59:32 <lambdabot> forall a. a -> a
05:59:59 <eugenn> :t id . (+1)
06:00:00 <lambdabot> forall a. (Num a) => a -> a
06:00:25 <hotzen> is there anything like toIntegral for doubles?
06:00:39 <Beelsebob1> @hoogle Double -> Integer
06:00:39 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
06:00:39 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
06:00:39 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
06:00:48 <hotzen> oh, thanks
06:01:05 <Beelsebob1> @hoogle (RealFrac a, Integral b) => a -> b
06:01:06 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
06:01:06 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
06:01:06 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
06:01:21 <eugenn> @src round
06:01:21 <lambdabot> Source not found. My brain just exploded
06:01:23 <Beelsebob1> IIRC there’s one for just chopping off the decimal part
06:01:33 <Beelsebob1> but I can’t remember what it’s called
06:01:42 <Veinor> if I want to submit something to hackage, but all the work is currently in a git repo, what's the recommended method for doing so?
06:01:49 <eugenn> > floor 4.7
06:01:50 <lambdabot>   4
06:02:07 <Veinor> ah, nevermind. wrong question to ask.
06:02:10 <Beelsebob1> > floor −4.7
06:02:11 <lambdabot>   Not in scope: `−'
06:02:12 <Beelsebob1> > floor (-4.7)
06:02:12 <lambdabot>   -5
06:03:15 <eugenn> (\x -> if x<0 then ceiling else floor) (-4.7)
06:03:19 <eugenn> > (\x -> if x<0 then ceiling else floor) (-4.7)
06:03:19 <lambdabot>   -0.375->
06:03:20 <lambdabot>    0
06:03:20 <lambdabot>  -0.75->
06:03:20 <lambdabot>    0
06:03:20 <lambdabot>  -1.5->
06:03:21 <lambdabot> [6 @more lines]
06:03:37 <eugenn> what the
06:03:39 <Beelsebob1> o.O
06:03:44 <Beelsebob1> haw the hell did that happen
06:03:46 <Beelsebob1> how*
06:03:54 <Beelsebob1> also, yeh, that, but there’s a class method for it
06:04:01 <eugenn> I just don't get monads
06:04:10 <Beelsebob1> eugenn: do you get Functors?
06:04:30 <eugenn> I don't.. :P
06:04:36 <Beelsebob1> get Functors first
06:04:41 <eugenn> ok
06:04:45 <lpsmith> :t (\x -> if x < 0 then ceiling else floor)
06:04:46 <lambdabot> forall a a1 b. (Num a, Ord a, RealFrac a1, Integral b) => a -> a1 -> b
06:04:48 <eugenn> I'll keep that in mind
06:04:54 <lpsmith> :t (\x -> if x < 0 then ceiling x else floor x)
06:04:55 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:04:56 <Beelsebob1> eugenn: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
06:05:14 <hotzen> @hoogle Integer -> Double
06:05:14 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
06:05:14 <eugenn> > (\x -> if x<0 then ceiling x else floor x) (-4.7)
06:05:14 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
06:05:14 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
06:05:15 <lambdabot>   -4
06:05:22 <idnar> Beelsebob1: Show instance for functions
06:05:26 <eugenn> oh, I just missed the x
06:05:27 <idnar> > (+1)
06:05:27 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
06:05:35 <Beelsebob1> idnar: ahhhh, cunning
06:06:00 <Beelsebob1> how does it chose the domain idnar?
06:06:06 <fasta> What do you think range(1,10) returns in Python? Python is such a beautiful language. /sarcasm
06:06:07 <idnar> I haven't a clue
06:06:50 <eugenn> > let f :: 2->3;5->9 in f 5
06:06:50 <lambdabot>   <no location info>: parse error on input `->'
06:06:55 <fasta> > (*2)
06:06:56 <lambdabot>   {-3->-6;-2->-4;-1->-2;0->0;1->2;2->4;3->6}
06:07:02 <fasta> > (/2)
06:07:03 <lambdabot>   -0.375->
06:07:03 <lambdabot>    -0.1875
06:07:03 <lambdabot>  -0.75->
06:07:03 <lambdabot>    -0.375
06:07:03 <lambdabot>  -1.5->
06:07:05 <lambdabot> [4 @more lines]
06:07:10 <Beelsebob1> fasta: I would *hope* a list containing [1..10]
06:07:22 <fasta> Beelsebob1, yes, I would too, but it doesn't.
06:07:45 <idnar> it's [1..9]
06:07:48 <stroan> fasta: you can see the logic, given what range(10) does
06:07:52 <eugenn> > let f = 2->3;5->9 in f 5
06:07:53 <lambdabot>   <no location info>: parse error on input `->'
06:07:54 <Beelsebob1> oh random
06:08:05 <idnar> range(10) is [0..9]
06:08:13 <eugenn> > let f = {2->3;5->9} in f 5
06:08:13 <lambdabot>   <no location info>: parse error on input `{'
06:08:27 <fasta> stroan, yes, it is just constructed to create for loops starting at index 0.
06:08:56 <Beelsebob1> > let f 2 = 3; f 5 = 9 in f 5
06:08:56 <lambdabot>   9
06:09:08 <eugenn> oooh
06:09:24 <fasta> Beelsebob1, probably, there is just some kind of hard-coded stuff for primops.
06:09:33 <Beelsebob1> randomness
06:09:34 <Axman6> eugenn: the {x->y;a->b} stuff isn't haskell
06:09:55 <stroan> the only two consistent ways of writing range or two parameters I think, are the way they've doneit, or range(start_no,length_of_list)
06:10:10 <Yuuri> Hello! Can anyone help me with installing GD bindings, please? I've got strange compiler errors during the installation o.O
06:10:22 <eugenn> > let f 2 = 3; f 5 = 9 in :t
06:10:22 <Jedai> Axman6: well you could see it as the Haskell following a "case n of"
06:10:23 <lambdabot>   <no location info>: parse error on input `:'
06:10:52 <eugenn> > let f 'a' = 'b'; f 7 = 9 in f 7
06:10:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
06:10:54 <lambdabot>    arising from the literal `7...
06:11:07 <Axman6> Jedai: yes.. but it's not :P
06:11:08 <Beelsebob1> @type let f 2 = 3; f 5 = 9 in f
06:11:08 <lambdabot> forall t t1. (Num t1, Num t) => t -> t1
06:11:28 <Jedai> eugenn: What would be the type of f
06:11:34 <Jedai> eugenn: ??
06:11:42 <eugenn> int -> int?
06:11:48 <Beelsebob1> eugenn: is ‘a’ and Int?
06:12:05 <eugenn> oh, you mean the other I tried
06:12:07 <mauke> s/and/an/
06:12:09 <Beelsebob1> @type ‘a’ -- Hint
06:12:10 <lambdabot> parse error on input `???'
06:12:15 <eugenn> yes, I suspected it would fail
06:12:24 <Beelsebob1> @type ‘a’
06:12:25 <lambdabot> parse error on input `???'
06:12:35 <eugenn> @type 'a'
06:12:36 <lambdabot> Char
06:12:37 <Beelsebob1> oh, my dumb IRC client is auto-correcting quotes isn’t it
06:12:39 <path[l]> hmm I modified my hs file. But when I do ghc -O2 something.hs it doesnt seem to recompile. But it's using the older binaries I think
06:12:54 <path[l]> cause it says compilation is not required
06:13:01 <path[l]> but gives me an error about undefined symbols
06:13:09 <hotzen> @hoogle Char -> Integer
06:13:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:13:10 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
06:13:10 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
06:13:23 <Axman6> :t ord
06:13:24 <lambdabot> Char -> Int
06:13:24 <hotzen> @hoogle Char -> Int
06:13:24 <lambdabot> Data.Char digitToInt :: Char -> Int
06:13:24 <lambdabot> Data.Char ord :: Char -> Int
06:13:24 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
06:13:34 <eugenn> > ord 'a'
06:13:35 <lambdabot>   97
06:13:43 <eugenn> > ord 'A'
06:13:44 <lambdabot>   65
06:13:51 <eugenn> oh it's ascii
06:14:02 <Axman6> > map org "why yes it is"
06:14:03 <lambdabot>   Not in scope: `org'
06:14:07 <Axman6> > map ord "why yes it is"
06:14:08 <lambdabot>   [119,104,121,32,121,101,115,32,105,116,32,105,115]
06:14:15 <Veinor> odd, I downloaded cabal-install and ghc --make Setup.hs is hanging
06:14:31 <eugenn> does ord have an inverse?
06:14:43 <Axman6> chr
06:14:54 <Axman6> > map chr [119,104,121,32,121,101,115,32,105,116,32,105,115]
06:14:55 <lambdabot>   "why yes it is"
06:15:07 <Beelsebob1> eugenn: aka fromEnum and toEnum btw
06:15:25 <eugenn> :t fromEnum
06:15:26 <lambdabot> forall a. (Enum a) => a -> Int
06:15:37 <quicksilver> eugenn: it's not ascii, by the way
06:15:51 <Axman6> it's utf-8?
06:16:01 <Veinor> yeah, linking setup takes unreasonably long
06:16:19 <eugenn> fromEnum 'j'
06:16:22 <eugenn> > fromEnum 'j'
06:16:23 <lambdabot>   106
06:17:22 <quicksilver> Axman6: no, it's not utf8
06:17:45 <quicksilver> Axman6: utf8 is a byte based encoding where different characters are different numbers of bytes long.
06:17:46 <Yuuri> cabal install gd (with --extra-lib & include) prints this:
06:17:47 <Yuuri> cbits\gd-extras.c:10:0:
06:17:47 <Yuuri> internal compiler error: in rest_of_handle_final, at toplev.c:2067
06:17:56 <quicksilver> it's unicode code points.
06:17:57 <path[l]> can someone tell me why my code might load in ghci but not compile?
06:18:24 <Axman6> path[l]: not without the error message and code
06:18:32 <path[l]> ok fair enough sec
06:20:57 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5068#a5068
06:21:30 <mux> path[l]: looks like you're missing --make or passing all the packages via -package flags
06:21:50 <mux> path[l]: try just adding --make, it should work
06:21:58 <path[l]> ok what does that do
06:22:17 <path[l]> oops yeah that was it
06:23:59 <mux> path[l]: it auto-detects what packages to link to
06:24:04 <path[l]> ah
06:24:05 <path[l]> thanks
06:24:10 <mux> path[l]: you could have specified -package containers by hand, alternatively
06:24:17 <path[l]> I must have forgotten I had used this
06:25:09 <Athas> I'm beginning to feel that interactive, graphical programs have to be designed with some CSP mechanism...
06:25:20 <Athas> If anything, shared-state multithreading is even uglier in Haskell than in C!
06:26:28 <Heffalump> Athas: http://www.cs.kent.ac.uk/projects/ofa/chp/
06:26:43 <Athas> Right, I know about that.
06:26:54 <Athas> I think I can get away with judicious use of MVars for this program, though.
06:30:29 <desp> How can I get Haddock to document portion of type synonym declarations?
06:31:03 <desp> Like  type Foo = Bar | -- ^ the bar parameter
06:38:56 <Yuuri> Help me please! T_T
06:39:43 <saml> Yuuri, how can i help you ?
06:39:48 <saml> ask me anything
06:40:56 <saml> help me Yuuri, please ask me questions
06:41:10 <Yuuri> saml, hello. I've trying to install Graphics.GD with cabal install and have weird "internal compiler error" message.
06:41:19 <saml> Yuuri, ubuntu?
06:41:34 <Yuuri> No, WInXP
06:41:42 <saml> you should install dependencies. not haskell packages but probably you are missing some packages (C/C++ libraries)
06:42:05 <saml> cabal isn't good at documenting which libraries you need to have to install a package
06:42:15 <saml> let me google for what is GD about
06:42:37 <saml> Yuuri, did you install GD for windows?
06:42:56 <Yuuri> I've got (probably) all needed includes and libraries, and try installing with --extra-include-dirs and so on.
06:43:14 <Yuuri> But C:\Documents and Settings\Администратор>cabal install gd --extra-include-dirs="D:\\Programs\\Common\\include" --extra-lib-dirs="D:\Programs\\Common\\lib"
06:43:17 <uracyl> 1) why does the Prelude when running the hugs98 does not seem to be present 2) why does let x = 1 binding fails ?
06:43:20 <saml> yah if you already have libgd on windows, you should point it to proper location
06:43:46 <Yuuri> prints cbits\gd-extras.c:10:0: internal compiler error: in rest_of_handle_final, at toplev.c:2067
06:44:02 <saml> i have no idea
06:44:16 <Yuuri> Sorry.
06:44:40 <saml> hrm i don't know.. for windows, ghc comes with gcc
06:44:58 <saml> and probably cabal uses gcc shipped with ghc
06:45:15 <saml> so you should configure the gcc that came with ghc to know where to find gd
06:45:27 <saml> can you compile simple gd C/C++ program with gcc?
06:45:49 <Yuuri> Yes, and I've found such bug with compiler error at toplev.c in GCC bugzilla.
06:46:04 <Yuuri> Well, I'll try it.
06:46:13 <saml> oh then maybe GD isn't supported on windows
06:46:56 <saml> bugzilla says it's fixed
06:47:06 <saml> http://gcc.gnu.org/bugzilla/show_bug.cgi?id=23589
06:47:09 <uracyl> hey why I don;t have the standard prelude loaded when starting winhugs ? running ghci does everything well ...
06:47:45 <saml> why do you use winhugs?
06:47:48 <Axman6> people are still using hugs? :\
06:47:56 <saml> because ghci doesn't do copy-paste on windows well?
06:49:28 <mauke> ghci isn't supposed to do copy/paste
06:50:32 <Yuuri> saml, thanx, I haven't noticed that it was fixed :-[
06:50:52 <Yuuri> Hmm. D:\Programs\Haskell>gcc test.c
06:50:52 <Yuuri> gcc: installation problem, cannot exec `cc1': No such file or directory
06:51:43 <eivuokko> I think you can't run gcc that comes with ghc without -B
06:51:53 <saml> Yuuri, i am not sure if cabal uses gcc that came with ghc. it's not an affirmitive information
06:52:06 <eivuokko> Or whatever that "gcc installed here" directory option was.
06:52:12 <eugenn> :t foldr
06:52:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:52:56 <saml> mauke, maybe it's hskline or something that ghci uses is broken on windows because windows cmd is bad
06:53:42 <mauke> haskeline/ghci shouldn't be involved in copy/paste
06:54:14 <saml> then probably the cloud failed to scale
06:55:16 <uracyl> :load E:\\foo.bar  gives nothing
07:02:00 <Yuuri> saml, should I try installing with runhaskell Setup, maybe?
07:02:25 <saml> Yuuri, i bet the result would be the same because cabal does that internally maybe
07:02:32 <uracyl> :load E:\\foo.bar  gives nothing , how should I load files under ghci ?
07:02:46 <saml> afaik, cabal downloads cabal package and does runhaskell Setup
07:02:51 <Yuuri> Meh.
07:02:56 <saml> along with dependencies
07:03:37 <Trollinator> hi
07:03:37 <saml> but you can download actual package or go to ~/.cabal/package, unzip and find README or something. it might have some info about windows
07:03:58 <saml> but i find that packages aren't documented well
07:04:06 <saml> hi Trollinator
07:04:11 <Trollinator> hi
07:04:11 <saml> how may i help you today?
07:04:48 <Trollinator> i'm trying to write a monad instance for [Maybe a].
07:05:02 <Trollinator> with just list, it's easy, instance Monad [] where...
07:05:08 <saml> isn't [] already instance of Monad?
07:05:19 <Trollinator> it is.
07:05:41 <Axman6> [Maybe a] has the wrong type to be a monad
07:06:19 <Trollinator> well, yes, i guess that's why it doesn't work.
07:06:34 <quicksilver> you'd have to newtype it
07:06:43 <Trollinator> ah
07:06:44 <quicksilver> newtype TrollFunkyMonad a = [Maybe a]
07:06:47 <quicksilver> erm
07:06:52 <quicksilver> newtype TrollFunkyMonad a = MkTFM [Maybe a]
07:06:53 <quicksilver> rather.
07:07:03 <Trollinator> cool, thanks.
07:07:10 <saml> you are welcome
07:07:14 <quicksilver> or, you can give type composition a name
07:07:46 <quicksilver> (newtype TypeCompose f g a = O (f (g a)))
07:07:56 <quicksilver> hmm no, that doesn't help
07:07:59 <quicksilver> ignore that :)
07:08:04 <quicksilver> yes it does!
07:08:05 <Trollinator> :o)
07:08:10 <quicksilver> then it would be legal to write an instance for
07:08:14 <quicksilver> TypeCompose [] Maybe
07:08:22 <quicksilver> because that has the right form to be a Monad
07:08:27 <quicksilver> clumsy to use though
07:08:47 <eugenn> :t []
07:08:48 <lambdabot> forall a. [a]
07:09:08 <Trollinator> i like the newtype solution better.
07:09:12 <koeien37> eugenn: here, [] is used as the type constructor.
07:09:14 <koeien37> :k []
07:09:15 <lambdabot> * -> *
07:09:37 <Trollinator> so there is something to generically compose type constructors?
07:10:04 <eugenn> :k (->)
07:10:05 <lambdabot> ?? -> ? -> *
07:10:27 <eugenn> :k (<-)
07:10:28 <lambdabot> parse error on input `<-'
07:10:46 <koeien37> -> is the function type constructor
07:10:54 <koeien37> <- is something completley different, related to do-notation
07:11:43 <benmachine> and list comprehensions
07:11:50 <benmachine> and other silly things
07:11:50 <quicksilver> Trollinator: well, there isn't anything built in but the language is powerful enough to express it
07:12:35 <Trollinator> i see.
07:12:41 <quicksilver> Trollinator: it's basicaly my newtype TypeCompose above, although http://hackage.haskell.org/package/TypeCompose adds a lot more magic aroudn the edges
07:12:47 <quicksilver> e.g., instances
07:12:52 <MoALTz> why does "let (/.) = (/) :: (Num a, Floating a) => a -> a -> a" give an :i of "(/.) :: Double -> Double -> Double" ??
07:13:02 <quicksilver> there is an automatic function instance for O f g if both f and g are themselves functors
07:13:07 <MoALTz> couldn't Float be just as valid?
07:13:15 <quicksilver> basically fmap = fmap . fmap
07:13:18 <Yuuri> saml, thanks for all your help!
07:13:20 <quicksilver> MoALTz: monomorphism restriction.
07:13:27 <Yuuri> I'll try to install MinGW separately.
07:13:41 <quicksilver> MoALTz: just a stupid hack in the language to try to make some things better
07:13:46 <quicksilver> (at the cost of making other things worse)
07:14:06 <MoALTz> =/
07:14:12 <koeien37> yeah it's annoying
07:14:17 <koeien37> i'd switch it off
07:14:27 <benmachine> you can disable it or you can define things in files or you can do umm
07:14:55 <benmachine> something like let (/.) :: (Num a, Floating a) => a -> a -> a; (/.) = (/)
07:15:03 <koeien37> let (/.) :: (Num a, .. would work
07:15:05 <koeien37> yeah
07:15:27 <benmachine> although, isn't Floating a subclass of Num anyway?
07:15:31 <eugenn> :k Maybe
07:15:32 <lambdabot> * -> *
07:15:52 <benmachine> yeah every Floating is a Fractional is a Num
07:15:57 <MoALTz> hmm it seems so
07:16:19 <FunctorSalad_> "For new code, the new locale library is recommended. " <-- which is?
07:16:43 <mux> oh, the one that is mentioned but doesn't exist yet?
07:16:46 <mux> I've encountered that.
07:17:12 <FunctorSalad_> nvm, `time' needs old-locale anyway
07:17:13 <rwx> <quicksilver> MoALTz: just a stupid hack in the language to try to make some things better <-- what things are made better? is there a page detailing this tradeoff?
07:17:21 <mux> FunctorSalad_: yup
07:17:44 <quicksilver> FunctorSalad_: there is none
07:17:49 <quicksilver> FunctorSalad_: it's a weird documentation bug
07:17:58 <mauke> rwx: performance of things like 'x = 2 * pi'
07:18:08 <quicksilver> rwx: http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:18:11 <FunctorSalad_> :)
07:19:54 <eugenn> :t balance'
07:19:54 <lambdabot> Not in scope: `balance''
07:21:18 <rwx> quicksilver, thanks... i'm definitely wtf'ing now
07:21:54 <FunctorSalad_> @where nmr
07:21:54 <lambdabot> I know nothing about nmr.
07:22:06 <quicksilver> @where dmr
07:22:06 <lambdabot> I know nothing about dmr.
07:22:15 <FunctorSalad_> @fact nmr
07:22:15 <lambdabot> nmr: {-# LANGUAGE NoMonomorphismRestriction #-}
07:22:16 <eugenn> @where eugenn
07:22:16 <lambdabot> I know nothing about eugenn.
07:22:17 <FunctorSalad_> :)
07:22:38 <eugenn> @fact CT
07:22:39 <lambdabot> I know nothing about ct
07:22:49 <quicksilver> FunctorSalad_: what's @fact?
07:23:11 <FunctorSalad_> quicksilver: just a String -> String dictionary I think
07:23:15 <FunctorSalad_> @factt
07:23:16 <lambdabot> I can not handle empty facts.
07:23:19 <FunctorSalad_> @fac
07:23:19 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
07:23:30 <FunctorSalad_> fact-set adds entries
07:23:33 <quicksilver> I've never seen it used :)
07:23:39 <quicksilver> does it have anything any good in it?
07:23:50 <FunctorSalad_> don't know
07:23:53 <byorgey> what are fact-cons and fact-snoc for, if you can't observe the ordering of the facts??
07:24:02 <FunctorSalad_> added the nmr flag once because it's so long to type out every time ;)
07:24:24 <FunctorSalad_> @fact-cons nmr this disables the dmr
07:24:24 <lambdabot> Fact altered.
07:24:26 <Axman6> byorgey: snoc would tremove a fact i'd guess
07:24:28 <FunctorSalad_> @fact nmr
07:24:29 <lambdabot> nmr: this disables the dmr {-# LANGUAGE NoMonomorphismRestriction #-}
07:24:44 <byorgey> Axman6: 'snoc' usually means adding to the end, not removing
07:24:54 <Axman6> true
07:24:54 <byorgey> aha!!
07:25:02 <eugenn> @where lambdabot
07:25:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
07:25:06 <byorgey> I see, it conses or snocs to an individual fact, not the fact database
07:25:12 <FunctorSalad_> yeah
07:25:35 <byorgey> @fact-snoc nmr booyah.
07:25:35 <lambdabot> Fact altered.
07:25:39 <byorgey> @fact nmr
07:25:39 <lambdabot> nmr:  booyah.this disables the dmr {-# LANGUAGE NoMonomorphismRestriction #-}
07:25:41 <FunctorSalad_> hehe
07:25:46 <FunctorSalad_> ?
07:25:48 <byorgey> it doesn't work =(
07:25:58 <FunctorSalad_> that's an odd snoc
07:27:45 <quicksilver>         "fact-snoc"   -> alterFact (P.append ((P.pack " ") `P.append` dat))   factFM writer fact
07:27:48 <quicksilver>         "fact-delete" -> writer ( M.delete fact factFM ) >> return "Fact deleted."
07:27:52 <quicksilver> doh, wrong two lines
07:27:59 <quicksilver>         "fact-cons"   -> alterFact ((dat `P.append` (P.pack " ")) `P.append`) factFM writer fact
07:28:13 <eugenn> @quote laptop
07:28:13 <lambdabot> monogamoussocks says: folding@home should maintain a --maintain-spermcount option for laptop usage
07:28:16 <quicksilver> cons/snoc are certainly trying to do somethign different.
07:28:52 <eugenn> :t shift
07:28:53 <lambdabot> forall a. (Bits a) => a -> Int -> a
07:29:11 <quicksilver> but one makes it the left argument of `P.append`
07:29:12 <eugenn> > shift "cons"
07:29:12 <lambdabot>   No instance for (Data.Bits.Bits [GHC.Types.Char])
07:29:13 <lambdabot>    arising from a use of ...
07:29:20 <quicksilver> and one makes it the first argument of P.append
07:29:25 <quicksilver> these are the same thing :)
07:29:32 <byorgey> hehe
07:29:33 <quicksilver> (except it puts the space on the other side, in fact)
07:30:17 <eugenn> > (\x -> init x : last x) "cons"
07:30:18 <lambdabot>   Occurs check: cannot construct the infinite type: a = [[a]]
07:31:38 <eugenn> > (\x -> last x:(drop 1 x)) "cons"
07:31:39 <lambdabot>   "sons"
07:32:11 <eugenn> > reverse "cons"
07:32:12 <lambdabot>   "snoc"
07:32:54 <byorgey> wonder how long that bug has existed in @fact-snoc
07:36:50 <eugenn> @quote lambdabot
07:36:50 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
07:44:25 <IceDane> Is there an equivalent of .ghci in windows? Can't seem to find anything regarding it on google.
07:45:45 <Jedai> IceDane: there is a .ghci in Windows, it's just that there's nothing as convenient and simple as HOME on Windows so it can be harder to find
07:45:56 <IceDane> ah, yeah
07:45:57 <Zao> %HOMEDRIVE%%HOMEPATH%
07:46:01 <Zao> If memory serves me right.
07:46:07 <quicksilver> IceDane: http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/ghci-dot-files.html
07:46:14 <Zao> (which is your user folder in Doc&Settings or Users)
07:46:30 <IceDane> Thanks ;)
08:12:11 <Veinor> is there a function that takes 13 and returns [1,1,0,1]?
08:13:05 <ben0x539> I do not think so, I did not find one. :>
08:13:09 <Lemmih> Veinor: A more interesting question is: Does that function have a name?
08:13:18 <Veinor> yes, that's what I meant :P
08:13:31 <Veinor> shouldn't be too hard to write using Data.Bits and a log2 function
08:13:48 <ben0x539> log2?
08:14:01 <Veinor> log2 13 = 4, log2 15 = 4, log2 16 = 5
08:14:10 <ben0x539> Oh, I see
08:14:20 <copumpkin> Veinor: that's overly complicated
08:14:23 <quicksilver> that would be a daft way to write it though :)
08:14:24 <tromp_> use showInBase or whatever it's called?!
08:14:30 <mux> > showIntAtBase 2 intToDigit 13 ""
08:14:31 <Veinor> yeah, I'm thinking imperatively again :P
08:14:31 <lambdabot>   "1101"
08:14:36 <Veinor> ahhh, I didn't know that exists
08:14:38 <quicksilver> > reverse $ unfoldr (\x -> if x==0 then Nothing else Just (x `rem` 2, x `div` 2)) 13
08:14:39 <lambdabot>   [1,1,0,1]
08:14:46 <copumpkin> Veinor: even just repeatedly divModding by 2
08:14:51 <Veinor> :P
08:14:58 <mux> > map digitToInt $ showIntAtBase 2 intToDigit 13 ""
08:14:59 <lambdabot>   [1,1,0,1]
08:15:00 <copumpkin> quicksilver: interesting combination! rem and div!
08:15:03 <ben0x539> > log2
08:15:04 <lambdabot>   Not in scope: `log2'
08:15:04 <mux> that's a bit confoluted though.
08:15:06 <ben0x539> :(
08:15:13 <quicksilver> Veinor: even in an imperative language, using logarithms to calculate representations is daft.
08:15:15 <tromp_> :t divMod
08:15:16 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
08:15:19 <quicksilver> copumpkin: typo.
08:15:24 <Veinor> yeah, yeah
08:15:34 * copumpkin lambastes Veinor
08:15:36 <Veinor> :<
08:15:46 <byorgey> what's the difference between `mod` and `rem` again?  I always forget.
08:16:03 <tromp_> > -` `rem` 2
08:16:04 <lambdabot>   <no location info>: parse error on input ``'
08:16:04 <quicksilver> > (-3 `rem` 2,-3 `mod` 2)
08:16:05 <lambdabot>   (-1,-1)
08:16:08 <tromp_> > -1 `rem` 2
08:16:09 <byorgey> And neither of them does what I really often want, which is to give me a result in 0..m-1
08:16:09 <lambdabot>   -1
08:16:19 <tromp_> > -1 `mod` 2
08:16:20 <lambdabot>   -1
08:16:23 * quicksilver can't remember either :)
08:16:32 <quicksilver> > ((-3) `rem` 2,(-3) `mod` 2)
08:16:33 <byorgey> > (-3 `rem` -2, -3 `mod` -2)
08:16:33 <lambdabot>   (-1,1)
08:16:33 <lambdabot>   Precedence parsing error
08:16:34 <lambdabot>      cannot mix `GHC.Real.rem' [infixl 7] and pref...
08:16:34 <IceDane> @src rem
08:16:34 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:16:35 <copumpkin> it's when the second parameter is negative
08:16:37 <tromp_> 'i thought mod wld give the sensible answer
08:16:41 <quicksilver> there you do. stupid precedence
08:16:42 <tromp_> 'apparently not
08:16:45 <quicksilver> > ((-3) `rem` 2,(-3) `mod` 2)
08:16:46 <lambdabot>   (-1,1)
08:16:46 <mux> > (-5) `div` 2
08:16:47 <lambdabot>   -3
08:16:53 <mux> > (-5) `quot` 2
08:16:54 <lambdabot>   -2
08:16:57 <Axman6> > 4 `rem` (-2)
08:16:58 <tromp_> ah
08:16:58 <byorgey> ah, I see
08:16:58 <lambdabot>   0
08:17:04 <mux> div truncates towards negative infinity
08:17:09 <mux> quot truncates towards 0
08:17:10 <Axman6> > 5 `rem` (-2)
08:17:11 <lambdabot>   1
08:17:17 <byorgey> > (-3) `rem` 5
08:17:17 <Axman6> > 5 `rem` (-3)
08:17:18 <lambdabot>   -3
08:17:18 <lambdabot>   2
08:17:24 <tromp_> > pred 0 `mod` 2
08:17:24 <Axman6> > 5 `mod` (-3)
08:17:25 <lambdabot>   1
08:17:25 <lambdabot>   -1
08:17:28 <byorgey> oh, nice, so rem actually does do what I want.
08:17:49 <byorgey> er, no it doesn't.
08:18:04 <ben0x539> Where is showInbase then?
08:18:05 <tromp_> > pred 0 `rem` 2
08:18:06 <lambdabot>   -1
08:18:16 <h20xt> > 5 `mod` -2
08:18:17 <lambdabot>   Precedence parsing error
08:18:17 <lambdabot>      cannot mix `GHC.Real.mod' [infixl 7] and pref...
08:18:20 <tromp_> @hoogle showIntAtBase
08:18:20 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
08:18:26 <ben0x539> oh
08:18:27 <h20xt> > 5 `mod` (-2)
08:18:28 <lambdabot>   -1
08:18:31 <h20xt> hm
08:18:32 <byorgey> oh, mod actually does what I want.  I just never realized it because of the stupid -/mod precedence =)
08:18:34 <h20xt> thats not cool
08:18:37 <byorgey> > (-3) `mod` 5
08:18:38 <lambdabot>   2
08:18:40 <byorgey> =D
08:18:41 <h20xt> > 5 `rem` (-2)
08:18:42 <lambdabot>   1
08:18:50 <byorgey> sorry for starting this =)
08:19:03 <h20xt> where is the math mod?
08:19:12 <ben0x539> Int -> Char? That is a daft function, too
08:19:18 <h20xt> nvm
08:20:17 <Veinor> oh god, this function is going to be ugly
08:20:25 <Veinor> I can sense it
08:21:36 <zygoloid> > map fromEnum . flip (showIntAtBase 2 toEnum) "" $ 19486
08:21:37 <lambdabot>   [1,0,0,1,1,0,0,0,0,0,1,1,1,1,0]
08:21:50 <ben0x539> > let f n = map (read . (:[])) $ showIntAtBase 2 (head . show) n "" in f 19486
08:21:52 <lambdabot>   [* Exception: Prelude.read: no parse
08:21:54 <ben0x539> aww.
08:22:18 <ben0x539> What is the enum involved there?
08:22:36 <rickz__> Hi, If I have a list of [[a]] and I want to check each [a] inside that with a function I got that takes a [a] and returns a bool, if one of them returns false then my function which is [[a]] -> Bool to return false. I know that I could use and to check for the last thing I asked for but how can I do the first thing without using a helper function and doing it recursivly which I understand I can do?
08:22:39 <zygoloid> showIntAtBase foolishly insists on producing [Char]
08:22:48 <zygoloid> so the Enum is Char :)
08:23:07 <medfly> > reverse . map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) $ 19486
08:23:08 <lambdabot>   [1,0,0,1,1,0,0,0,0,0,1,1,1,1,0]
08:23:14 <copumpkin> Veinor: what function is going to be ugly?
08:23:23 <zygoloid> rickz__: let me rephrase your question, hopefully it'll make it obvious:
08:23:47 <quicksilver> ben0x539: the Char enum
08:23:48 <Philonous> @type all
08:23:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:23:56 <zygoloid> rickz__: you have a value :: [b], and you want to check each b with a function :: b -> Bool. if the function returns false then the result is False otherwise the result is True
08:24:05 <ben0x539> rickz__: well, write it out? pattern-match on the list, return false when it does not satisfy your function, return true when the list is over, recurse if neither
08:24:16 <zygoloid> @type all
08:24:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:24:23 <mux> ben0x539: explicit recursion for such a simple thing would be bad :-(
08:24:34 <Philonous> @type all :: ([a] -> Bool) -> [[a]] -> Bool
08:24:35 <lambdabot> forall a. ([a] -> Bool) -> [[a]] -> Bool
08:24:36 <ben0x539> mux: I think he wanted to do it explicitly
08:24:54 <rickz__> hm ok I think I got it thanks
08:24:58 <zygoloid> ben0x539: "without [...] doing it recursively"
08:25:01 <mux> ben0x539: sorry, indeed
08:25:21 <zygoloid> rickz__: if you want to use 'and', then you can use \f xs -> and (map f xs)
08:25:24 <zygoloid> @src all
08:25:24 <lambdabot> all p =  and . map p
08:25:31 <zygoloid> ^^ but that's what 'all' does anyway
08:25:33 <ben0x539> well if he does not want to do it recursively and does not want to do it with a helper function, i guess he will have to use list comprehensions
08:28:34 <Philonous> @type (\f xs -> foldl' ((. f) . (&&)) True xs)
08:28:35 <lambdabot> forall b. (b -> Bool) -> [b] -> Bool
08:28:45 <h20xt> can anyone help me out and tell me why http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13013#a13013 doesn't work as i expect
08:28:53 <h20xt> i expect it to print the first argument
08:28:54 <Veinor> copumpkin: closed-form nim-multiplication, it took me a couple days just topseudocode it out :D
08:29:47 <Philonous> @type \(x:_) -> putStrLn x
08:29:48 <lambdabot> [String] -> IO ()
08:29:58 <Philonous> @type getArgs
08:29:59 <lambdabot> Not in scope: `getArgs'
08:30:14 <Philonous> it should be IO [String]
08:30:28 <Philonous> @type (>>=)
08:30:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:30:40 <h20xt> its not types, it compiles
08:31:13 <netinho2lol> list p = foldr (\ x xs -> if p x then Just (x:xs) else xs) [] -- does anyone know where I put the Nothing part?
08:31:55 <Philonous> h20xt: liftM ( \(x:_) -> putStrLn x ) getArgs :: IO (IO ())
08:31:56 <Axman6> he type of liftM (\(x:_) -> putStrLn) getArgs is IO (IO ())
08:32:14 <h20xt> heh
08:32:16 <h20xt> thanks
08:32:37 <zygoloid> netinho2lol: what Nothing part? if you're writing 'filter' then you don't need the Just.
08:32:41 <Axman6> i think you want >>+
08:32:54 <Axman6> >>=
08:33:00 <Philonous> That's what I was trying to suggest
08:33:06 <h20xt> thank your Philonous
08:33:12 <zygoloid> > let filter p = foldr (\x xs -> if p x then (x:xs) else xs) [] in filter odd [1..5]
08:33:12 <h20xt> thank you Axman6
08:33:13 <lambdabot>   [1,3,5]
08:33:16 <h20xt> you are correct
08:33:27 <netinho2lol> zygoloid: this is a special filter that return Nothing or Just [list of ok stuff]
08:33:30 <netinho2lol> :)
08:33:32 <Axman6> ok, time to sleep. night all
08:33:56 <zygoloid> netinho2lol: i'd suggest doing that with case filter p xs of [] -> Nothing; xs -> Just xs
08:34:05 <Axman6> me too
08:34:09 <zygoloid> netinho2lol: where possible you should try to decompose things into separate logical units :)
08:34:49 <netinho2lol> I made it that way, zygoloid, but my teacher wants me to use foldr
08:35:01 <dingo> > map (*2) [1..10]
08:35:02 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
08:35:07 <mux> folds are cool
08:35:09 <zygoloid> :( ok, fair enough
08:35:26 <netinho2lol> mux: they are confusing as well
08:35:27 <zygoloid> netinho2lol: ok, so the second argument to foldr is what it produces if given []. that should be Nothing.
08:35:39 <mux> > let foo f = foldr (f . (:)) [] in foo (+1) [1..7]
08:35:41 <lambdabot>   No instance for (GHC.Num.Num ([a] -> [a]))
08:35:41 <lambdabot>    arising from the literal `1' ...
08:35:44 <mux> woops.
08:36:00 <mux> > let foo f = foldr ((:) . f) [] in foo (+1) [1..7]
08:36:01 <lambdabot>   [2,3,4,5,6,7,8]
08:36:07 <zygoloid> netinho2lol: however, the second argument of your lambda will be Maybe [a], so you'll need to be more careful with your 'if'.
08:36:21 <dingo> Hi. I'm completely NEW to IRC, never used it before in my life....   I've JUST (2minutes back) discovered LAMBDABOT...
08:36:35 <Polarina> dingo: Congratulations and welcome. :)
08:36:46 <netinho2lol> sup dingo!
08:36:46 <dingo> So, when I type something to lambdabot, do everybody else see it??    THANKS
08:36:58 <Polarina> dingo: Yes, everything you type in here, everyone sees.
08:37:29 <luite> dingo: but you can also talk directly to lambdabot, in private ( /query lambdabot )
08:37:30 <zygoloid> dingo: it depends. if you're in #haskell, everyone sees it, but if you open a private chat with lamdabot only you, lambdabot and Cale can see it :)
08:37:31 <roconnor> dingo: you can also /msg lambdabot > 2 + 2
08:38:06 <medfly> Cale spies on people that have private things with lambdabot!
08:38:10 <netinho2lol> zygoloid: so, the empty list is changed to Nothing, because it's the default case
08:38:19 <dingo> Polarina: thanks, so   "/msg lambdabot > 2 + 2" -->  only I will see result?   (and maybe Cale) :-)
08:38:32 <netinho2lol> and then, the second arg of the lambda expression is eval with Maybe?
08:38:41 <Polarina> dingo: Yes. Cale can see it because she controls the bot. :)
08:38:50 <zygoloid> netinho2lol: right. you want your lambda to be of type a -> Maybe [a] -> Maybe [a]
08:39:20 <telofy> Hi. For some reason a function called with “numbers” is not matched to the instance that is defined as "instance Memory [(Int,Int)] where" here: http://yu-shin.de/mm1.hs Help?
08:39:55 <dingo> Polarina: Works, thank You. :-)
08:40:15 <Polarina> dingo: No problem. :)
08:40:37 <dingo> I like this irc thing...
08:40:38 <Cale> Polarina: she?
08:40:58 <Polarina> Cale: Yes. *evil*
08:41:08 <Cale> (I am a he :)
08:41:19 <Polarina> Cale: From now on, I'll call you "it".
08:41:21 <Heffalump> prove it!
08:41:53 <Polarina> dingo: We are glad you like it and hope you'll stick around. :)
08:42:08 <Cale> Polarina: I'd prefer 'they' to 'it' if you're going gender-neutral :)
08:42:38 <netinho2lol> zygoloid: list p = foldr (\ x Maybe xs -> if p x then Just (x:xs) else xs) Nothing,
08:42:48 <netinho2lol> list p = foldr (\ x Maybe xs -> if p x then Just (x:xs) else xs) Nothing -- doesn't work
08:43:16 <Heffalump> netinho2lol: what's the Maybe inbetween x and xs doing?
08:43:40 <netinho2lol> ops
08:43:49 <netinho2lol> else Maybe xs
08:43:53 <netinho2lol> lemme test
08:43:56 <Cale> uhh
08:44:07 <Cale> Maybe is a type constructor, and it only belongs in *types*
08:44:25 <Cale> Nothing and Just are the value-level parts of that type
08:46:09 <netinho2lol> then I should use Just?
08:46:32 <Heffalump> what is list actually supposed to do?
08:47:04 <netinho2lol> it works just like filter
08:47:11 <netinho2lol> well, with Just
08:47:24 <Cale> netinho2lol: What type is 'list' supposed to have?
08:47:51 <netinho2lol> generic
08:47:52 <netinho2lol> a
08:48:05 <netinho2lol> signature should be ... (a -> Bool) -> [a] -> Maybe [a]
08:48:17 <notweebl_> I'm trying to read "2000 3000 4000" :: Integer but it can't read the spaces, obviously. what's the best solution to circumvent this?
08:48:53 <Cale> netinho2lol: Okay, so if filter p xs is not null, you want the result to be Just (filter p xs), and if it is null, you want it to be Nothing?
08:49:05 <Cale> notweebl_: map read . words
08:49:05 <aavogt> > read (words "2000 3000 4000") :: [Int]
08:49:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:49:06 <lambdabot>         against inferred type...
08:49:07 <Vulpyne> > map read (words ""2000 3000 4000") :: [Int]
08:49:08 <lambdabot>   <no location info>:
08:49:08 <lambdabot>      lexical error in string/character literal at end o...
08:49:26 <Cale> > map read . words $ "2000 3000 4000"
08:49:27 <lambdabot>   [* Exception: Prelude.read: no parse
08:49:32 <Cale> er
08:49:40 <Cale> > map read . words $ "2000 3000 4000" :: [Integer]
08:49:40 <aavogt> heh, nobody get's it completely right
08:49:41 <lambdabot>   [2000,3000,4000]
08:49:47 <Zao> Iterative development.
08:49:51 <netinho2lol> Nothing is there's nothing in the list, Just [stuff] if there's stuff
08:49:52 <Cale> There we are :)
08:49:58 <notweebl_> but it should read as 200030004000
08:50:04 <Cale> notweebl_: oh!
08:50:05 <Zao> Converges on a solution, but might just be a local maxima.
08:50:07 <danderson> > map read $ words "2000 3000 4000" :: Int
08:50:08 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:50:08 <lambdabot>         against inferred type ...
08:50:18 <Cale> notweebl_: read . filter (not . isSpace)
08:50:18 <danderson> bah, stupid compiler.
08:50:20 <Heffalump> netinho2lol: that's rather redundant, in that Just [] has no meaning
08:50:27 <danderson> > map read $ words "2000 3000 4000" :: [Int]
08:50:27 <lambdabot>   [2000,3000,4000]
08:50:30 <Cale> notweebl_: Or  read . filter isDigit
08:50:32 <danderson> compile what I mean, not what I type!
08:50:33 <netinho2lol> notweebl_: unwords
08:50:45 <Zao> > concat . words $ "2000 3000 4000"
08:50:45 <rwx> in ruby there's that convenient notation for numbers in which you can insert "commas": 1_000_000_000; is that possible in haskell?
08:50:46 <lambdabot>   "200030004000"
08:50:51 <notweebl_> cool thx
08:50:56 <netinho2lol> Heffalump: it's Nothing
08:50:57 <netinho2lol> :P
08:51:03 <Cale> > read . filter isDigit $ "2000 3000 4000" :: Integer
08:51:04 <lambdabot>   200030004000
08:51:11 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13015#a13015
08:51:17 <Veinor> This code works. Now how do I make it pretty?
08:51:35 <netinho2lol> initially: case filter p list of [] -> Nothing; list -> Just list
08:51:35 <Heffalump> netinho2lol: so does that representation apply both to the input and output lists?
08:51:41 <Vulpyne> Expose it to light so it sparkles.
08:51:55 <Heffalump> netinho2lol: so why not just do that?
08:52:19 <netinho2lol> because I'm restricted to use folds, by the teacher :(
08:52:51 <netinho2lol> I really suck at folds
08:53:01 <h20xt> Vulpyne: :(
08:53:59 <Vulpyne> h20xt: I'm sorry.
08:54:48 <Cale> @let silly p = foldr (\x xs -> if p x then (case xs of Nothing -> Just [x]; Just ys -> Just (x:ys)) else xs) Nothing
08:54:49 <lambdabot>  Defined.
08:55:05 <Cale> > silly even [1,3,5,7]
08:55:07 <lambdabot>   Nothing
08:55:15 <Cale> > silly even [1..10]
08:55:16 <lambdabot>   Just [2,4,6,8,10]
08:55:32 <Rotaerk> @type silly
08:55:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe [a]
08:56:05 <lpsmith> foldr cons nil (1 : 2 : 3 : 4 : [])  ==  1 `cons` (2 `cons` (3 `cons` (4 `cons` nil)))
08:56:08 <netinho2lol> Cale: it's quite silly indeed :|
08:56:38 <lpsmith> foldr and foldl are pretty easy :-)
08:57:23 <netinho2lol> lpsmith: they "compact" a lot of things... but it's not really immediate or readable to me :(
08:57:32 <netinho2lol> Cale: thanks for the assistance
08:57:58 <Cale> netinho2lol: No problem. Do you understand what's going on in that fold?
08:58:07 * netinho2lol rages at silly function
08:58:18 <netinho2lol> Cale: I am reading it
08:58:22 <Cale> netinho2lol: You should think of foldr as providing you the opportunity to redefine what (:) and [] do
08:58:46 <gressvol-> I have a datatype that is for a card came: data Hand = Empty | Add Card Hand, the problem I have is that I in a function would like to return a tuple (Card, Hand). Is it possible to recursively build the hand inside this tuple?
08:58:57 <Cale> netinho2lol: foldr f z goes through a list and replaces each (:) with f and the [] at the end with z
08:59:14 <rickz__> is there a function like if I do        thisFunction 1 [1,2,1] I want the result 2
08:59:18 <gressvol-> the function should remove a card from a deck and return the deck without that card
08:59:51 <Cale> rickz__: uhh...
09:00:12 <rickz__> Cale ? :)
09:00:13 <Cale> rickz__: thisFunction x xs = length (filter (== x) xs) ?
09:00:27 <Cale> rickz__: or maybe  thisFunction n xs = xs !! n
09:00:37 <Saizan> gressvol-: you just have to pattern match on the tuple the recursive call is giving you, to extract its contents and build a new tuple using them
09:00:38 <netinho2lol> Cale: this silly function is silly :P
09:00:45 <gressvol-> and I can do it if I'm having something similar to this pickn n (Add c h) rest = pickn (n-1) h (something here)
09:00:52 <gressvol-> but I want to get rid of the rest argument
09:01:04 <Cale> rickz__: Or perhaps  thisFunction x xs = minimum (filter (> x) xs)
09:01:13 <Runar> > let thisFunction = const 2 in thisFunction 1 [1, 2, 1]
09:01:13 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:01:14 <lambdabot>    `GHC.Num.Num t' arising f...
09:01:22 <Cale> rickz__: It's *really* hard to tell what you want from one example like that ;)
09:01:58 <rickz__> oh yeah filter it is
09:02:00 <rickz__> forgot
09:02:04 <rickz__> thanks
09:02:06 <gressvol-> Saizan: Okey, how do I pattern match on something that is recursive?
09:02:13 <rickz__> @src filter
09:02:13 <lambdabot> filter _ []     = []
09:02:14 <lambdabot> filter p (x:xs)
09:02:14 <lambdabot>     | p x       = x : filter p xs
09:02:14 <lambdabot>     | otherwise = filter p xs
09:02:45 <Runar> > let thisFunction = const . const $ 2 in thisFunction 1 [1, 2, 1]
09:02:46 <lambdabot>   2
09:03:22 <Cale> netinho2lol: Another way to write the foldr you want is to write your function in this format first:
09:03:32 <Cale> foo [] = ...
09:03:39 <netinho2lol> bar!
09:03:50 <Cale> foo (x:xs) = ... x ... foo xs ...
09:05:11 <Cale> If you can do that, then  foo = foldr (\x ys -> ... x ... ys ...) (...), where the body of the lambda is just the RHS of the second line where foo xs has been replaced by ys, and the second parameter to the foldr is the RHS of the first line.
09:06:08 <Cale> netinho2lol: Make sense?
09:06:26 <netinho2lol> that actually makes sense :|
09:06:55 <netinho2lol> await
09:06:58 <netinho2lol> what's RHS?
09:07:03 <Cale> right hand side
09:07:09 <Cale> of the equation
09:12:53 <gressvol> sorry to reask my question, when returning a tuple how do I pattern match recursivly. so I can build up a tuple by the recurrence?
09:13:30 <byorgey> gressvol: I'm not quite sure what you're asking.  Can you give an example?
09:15:09 <gressvol> byorgey: yes I have a datatype that looks like this Hand = Empty | Add Card Hand, And in a function I want to return a tuple (Card,Hand). When I find that specific Card I want to recursivly build up the Hand
09:16:02 <therp> gressvol: sorry joined late, but your datatype is isomorphic to [Card], why don't you just that?
09:16:55 <gressvol> therp: I have no idea, This is a school exercise and I have been given the datatype as it is.
09:17:07 <therp> gressvol: that's what I suspected :)
09:17:08 <byorgey> gressvol: I am still not sure what it is you want to do.  This function that returns a (Card,Hand) tuple --- you want to do something with its output?  Or you are trying to define this function recursively? or...?
09:17:31 <byorgey> gressvol: what exactly does this function do?
09:18:45 <gressvol--> sorry got dc
09:18:46 <gressvol--> byorgey: I have a function pickncard :: Int -> Hand -> (Card, Hand) removes the n:th card from a hand and returns the hand without the card
09:19:09 <byorgey> ok, so the (Card,Hand) pair is the nth card along with the hand without that card?
09:19:19 <gressvol--> byorgey: yes
09:19:32 <byorgey> gressvol--: ok.  and are you asking for help defining this function? or with using its result?
09:20:03 <gressvol--> I have the base case, what I dont understand is how to do the recursivly call
09:20:11 <gressvol--> how to build the hand in the recursion
09:20:13 <byorgey> gressvol--: ok, what is the base case?
09:20:29 <gressvol--> pickCardn 0 (Add c h) = (c, h)
09:20:35 <byorgey> ok, right.
09:21:17 <byorgey> so in the recursive case,  pickCardn n (Add c h) = ...
09:21:24 <byorgey> what sort of recursive call will you make on the right-hand side?
09:21:26 <gressvol--> pickCardn n (Add c h) = pickCardn (n-1) h, something like this
09:21:32 <byorgey> yes
09:21:35 <koeien37> sounds good
09:21:36 <gressvol--> but need to "build" the tuple
09:21:41 <byorgey> ok, now I see what you are asking
09:22:06 <byorgey> so you can say   let (c',h') = pickCardn (n-1) h in ...
09:22:40 <byorgey> that is,  pickCardn n (Add c h) = let (c',h') = pickCardn (n-1) h in ...
09:23:01 <byorgey> 'let' allows you to do pattern-matching on intermediate results like that
09:23:12 <koeien37> alternatively, you can use 'where'
09:23:13 <byorgey> in this case you could also use 'where'
09:23:14 <koeien37> but let is fine
09:23:17 <byorgey> =)
09:23:31 <byorgey> pickCardn n (Add c h) = ...    where (c',h') = pickCardn (n-1) h
09:23:41 <byorgey> now, what should go in the ... ?
09:24:06 <byorgey> we now have the nth card c' and the remaining hand from the recursive call h'
09:24:19 <byorgey> how to put everything together to make the final result?
09:24:24 <hotzen> hello, could anybody help me with a short type family question please? where does the error come from?
09:24:24 <hotzen> http://haskell.pastebin.com/m29d7f98a
09:24:38 <hotzen> @quiksilver: would you mind taking a loot at this?
09:24:38 <lambdabot> Unknown command, try @list
09:24:57 <hotzen> @quicksilver: would you mind taking a loot at this?
09:24:58 <lambdabot> Unknown command, try @list
09:25:26 <EnglishGent> is there a way we could create a multiparameter type class so as to allow overloading map - so that it simultaneously has types
09:25:42 <EnglishGent> map :: (a -> b) -> [a] -> [b]
09:26:11 <EnglishGent> and  (a -> IO b) -> [a] -> IO [b]
09:26:38 <gressvol--> byorgey: (c', Add c h')
09:26:45 <byorgey> gressvol--: right!
09:26:47 <koeien37> gressvol--: yes
09:26:55 <gressvol--> :)
09:26:57 <koeien37> gressvol--: what can go wrong with your function?
09:27:07 <byorgey> yes, there's still one more case to think about
09:27:12 <gressvol--> if n > size of hand
09:27:16 <koeien37> correct
09:27:16 <gressvol--> but I have that covered
09:27:17 <koeien37> >=
09:27:28 <koeien37> (you started at zero)
09:27:33 <gressvol--> I have never seen the let .. in
09:27:38 <koeien37> how did you cover this?
09:27:40 <gressvol--> syntax
09:28:22 <gressvol--> koeien37: what do you mean?
09:28:27 <koeien37> gressvol--: the other case?
09:28:35 <koeien37> do you call "error" there?
09:28:42 <byorgey> gressvol--: let x = y in z  has the value of z, where each occurrence of x in z is replaced by y
09:28:50 <byorgey> i.e. it just lets you give a name to something locally within z
09:29:00 <byorgey> > let x = 5  in x + x * x
09:29:01 <lambdabot>   30
09:29:18 <scree> hotzen: you need another [] in the signature of smartContcat
09:29:25 <koeien37> > let (x:xs) = [1,2,3] in x
09:29:26 <lambdabot>   1
09:29:27 <scree> s/Contcat/Concat
09:29:36 <gressvol--> koeien37: no I returned an Empty hand
09:29:36 <hotzen> aaaaaaah
09:29:39 <hotzen> omg, thank you
09:29:48 <hotzen> it works
09:29:48 <scree> smartConcat :: (SmartList a b) => [a] -> [b] -> [NewListTy a b]
09:29:50 <hotzen> yessssss
09:29:53 <hotzen> thanks a BUNCH!
09:30:14 <koeien37> gressvol--: yes, but you promised that you will return a card and a new hand
09:30:44 <byorgey> what if someone calls  pickCardn 3 Empty ?
09:31:24 <gressvol--> then there is a problem :P
09:31:34 <EnglishGent> what's a smart list? :)
09:31:46 <gressvol--> but what are you suggesting, an error message in that case?
09:32:05 <hotzen> i try to use the type families to add arbrirtary types to a list
09:32:09 <koeien37> gressvol--: two options. either you make sure that your program never does this (so give a proof of this.)
09:32:12 <hotzen> kind of wacky name, i know...
09:32:24 <koeien37> gressvol--: or, change the return value into Maybe (Card, Hand), so tha tyou allow for failure
09:32:36 <scree> hotzen: can you give a non-trivial instance?
09:32:44 <gressvol--> koeien37: okey, I see
09:32:53 <hotzen> they are all trivial, it's just for the understanding of it
09:33:02 <koeien37> gressvol--: did you see Maybe before?
09:33:04 <hotzen> instance SmartList Double Int where
09:33:04 <hotzen> type NewListTy Double Int = Double
09:33:04 <hotzen> smartCons x ys = x : (map fromIntegral ys)
09:33:09 <byorgey> changing the return value to  Maybe (Card, Hand) would be annoying unless you put that in a wrapper function
09:33:13 <hotzen> looks like these ...
09:33:21 <gressvol--> koeien37: yes I have
09:33:59 <scree> hotzen: gotcha
09:34:09 <koeien37> byorgey: yes, you need to pack and unpack the Just or Nothing
09:34:14 <koeien37> byorgey: that's why we have monads ;)
09:34:33 <scree> hotzen: could hide some fun performance issues if you're not careful :)
09:34:48 <byorgey> well, yes, I know, but telling gressvol-- to translate everything to do-notation or whatever seems a bit heavyweight at this point =)
09:34:50 <hotzen> ;) its just for a seminar about fundeps and type fams
09:34:58 <scree> ah
09:35:17 <hotzen> i hope that is a good example for type-fams
09:35:21 <hotzen> im open for any suggestion
09:35:46 <copumpkin> ksf: thanks for that excellent "what monads are not"!
09:35:54 <copumpkin> I'm glad someone finally wrote that
09:35:58 <opqdonut> link?
09:36:06 <copumpkin> http://www.haskell.org/haskellwiki/What_a_Monad_is_not
09:36:11 <scree> hotzen: it seems a pretty good example that isn't container classes
09:36:47 <hotzen> ok, will try a container additionally ;) ty
09:38:28 <scree> hotzen: only if you want
09:38:50 <scree> hotzen: it's so much the canonical example that everyone's bound to find it if they do any reading
09:39:10 <hotzen> the graph-example in fun with fun types is quite neat
09:39:24 <copumpkin> Veinor: why would you even want to divide nimbers?
09:40:00 <copumpkin> Veinor: just to get a field?
09:41:01 <koeien37> "mobits"
09:41:45 <netinho2lol> I have an opinion
09:41:55 <copumpkin> is it well reasoned?
09:42:02 <copumpkin> and supported
09:42:06 <netinho2lol> every function that returns error should be switch to return Nothing or Just the output
09:42:12 <netinho2lol> copumpkin: not really
09:42:19 <netinho2lol> :P
09:42:43 <copumpkin> netinho2lol: oh, I agree
09:42:56 <copumpkin> I hate errors in common pure functions
09:43:02 <koeien37> and what about nonterminating functions?
09:43:14 <copumpkin> if it's a necessity, then sure
09:43:35 <copumpkin> if it can be detected beforehand in a reasonably efficient manner, then a Maybe would be nice
09:43:41 <FunctorSalad_> koeien37: what about them? ;)
09:43:53 <copumpkin> but things like head or Data.Binary's decode
09:43:54 <koeien37> they are also a kind of "error-calling functions"
09:44:06 <copumpkin> those seem to belong quite squarely in Maybeland
09:44:26 <FunctorSalad_> koeien37: sure they have bottom semantics too, but just because we can't eliminate *all* the bottoms doesn't mean that we shouldn't eliminate the gratuitious ones ;)
09:44:40 <FunctorSalad_> like copumpkin's example
09:54:49 <theclaw> why is package "ghc-6.10.4" hidden by default?
09:56:25 <FunctorSalad_> dunno, maybe because of all the toplevel modules
09:56:34 <Igloo> theclaw: Because otherwise there would be modules like "Utils" exposed
09:57:01 <theclaw> Igloo: why?
09:57:22 <Igloo> Because there are modules like that in ghc-6.10.4
09:57:49 <FunctorSalad_> theclaw: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/index.html
09:58:46 <theclaw> Igloo, FunctorSalad_ - so this is overhead not normally needed?
09:59:45 <FunctorSalad_> theclaw: you only need the ghc package to use ghc as a library
09:59:54 <FunctorSalad_> not to compile your programs or anything
10:00:42 <theclaw> FunctorSalad_: I'm just reading "yet another haskell tutorial", which talks about FiniteMap, which is defined in ghc
10:00:44 <sproingie> ls
10:00:45 <hotzen> scree: do you have any idea how to fully implement the smartConcat?
10:00:47 <sproingie> whoops
10:01:23 <copumpkin> theclaw: that's ancient
10:01:34 <FunctorSalad_> theclaw: 'tis standalone now http://hackage.haskell.org/package/FiniteMap
10:01:37 <copumpkin> theclaw: it's called Map now and is in Data.Map, in the containers package, which is nt hidden anymore
10:01:44 <copumpkin> @slap FunctorSalad_
10:01:44 * lambdabot places her fist firmly on FunctorSalad_'s jaw
10:01:52 <FunctorSalad_> :(
10:02:14 <theclaw> oh okay, thanks
10:02:17 <copumpkin> "This is the deprecated Data.FiniteMap library, often useful to get old code to build when you are too lazy to update it."
10:02:25 <FunctorSalad_> if the code he's reading uses FiniteMap he probably wants FiniteMap, no :p
10:02:46 <theclaw> FunctorSalad_: anyway, what do you mean with "only when using ghc as a library"?
10:02:53 <copumpkin> he should probably not be learning latin in his science course
10:03:04 <theclaw> FunctorSalad_: i.e, what do you mean with library? any difference to module?
10:03:45 <FunctorSalad_> theclaw: as opposed to calling ghc to compile your programs
10:04:24 <FunctorSalad_> the ghc package is good for programmatically loading modules, looking up types and so on
10:05:31 <theclaw> FunctorSalad_: sorry, I don't quite get it. Could you give me an example where the ghc module is used as a library?
10:05:38 <theclaw> FunctorSalad_: err, ghc package
10:06:12 <FunctorSalad_> theclaw: if you're just starting with haskell you don't need to worry about that package
10:06:52 <sieni> ville: nice nick
10:06:54 <FunctorSalad_> an example app is ghci, I guess :)
10:07:23 <ray> lambdabot
10:07:47 <theclaw> FunctorSalad_: I'd like to know that, though. You mean when using the package as a library from e.g. a C program?
10:07:49 <ray> > print "look at me, i'm evaluating haskell"
10:07:50 <lambdabot>   <IO ()>
10:08:00 <FunctorSalad_> theclaw: from a haskell program
10:08:00 <ray> i meant text, didn't i
10:08:05 <ray> it's been so long
10:08:19 <ray> http://hackage.haskell.org/package/mueval
10:09:31 <gwern> good ol mueval
10:09:31 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
10:09:31 <theclaw> FunctorSalad_: erm..
10:09:38 <gwern> what a surprising lot of code mueval turned out to be
10:09:40 <gwern> @messages
10:09:40 <lambdabot> kowey said 4h 14m 11s ago: small request: zooko would like his darcs wiki password reset -- is this something you know how to do?
10:09:51 <ray> you'd think it'd be like two lines
10:09:59 <theclaw> FunctorSalad_: so it contains "meta functions"?
10:10:08 <FunctorSalad_> theclaw: yep
10:10:21 <ray> any haskell program that needs to compile haskell
10:10:36 <theclaw> FunctorSalad_: but it's a normal package. I was confused about the term "library"
10:11:15 <gwern> @flush
10:11:43 <gwern> ray: well, it can be relatively easy if you use hint; 3 or 4 lines, I suppose for the barestbones. but mueval needs a lot more than that
10:13:28 <Veinor> copumpkin: yeah, basically
10:13:57 <Veinor> I'm not sure of any natural context in which division of games comes up in CGT
10:14:20 <copumpkin> Veinor: "just cuz we can"
10:14:29 <Veinor> :D
10:14:47 <Veinor> although, if i recall correctly there is some way to give meaning to multiplication of nimbers
10:17:11 <Veinor> but yeah, multiplication is very fast now
10:19:42 * EnglishGent wonders - is there an irc client in Haskell anywhere? (serious question!) :)
10:19:58 * EnglishGent looking at networkish stuff
10:20:41 <Badger> benmachine wss making one, though how far he got I do not know
10:21:00 <tensorpudding> you could always make one, it's not too hard to make one
10:30:20 <sproingie> bots are essentially dumb clients, i'd start with that
10:33:49 <Yuuri> Hello again!
10:34:09 <gressvol--> I have the datatype Hand = Empty | Add Card Hand, I wan't to print a hand consisting of every card in a given suit using list comprehension. My problem is that I can only generate Hands containing 1 card each: [(Add (Card (Numeric i) suit) Empty) | i <- [2..10]] this will give me 9 hands containg 1 card each. How can I modify this to give me 1 hand with 9 cards?
10:34:13 <Yuuri> I've found the root of all problems with installing a package.
10:34:48 <Yuuri> GHC 6.10 for Win comes with an old GCC, 3.4.5, and internal compiler bug is fixed in later versions.
10:35:42 <Yuuri> Can somebody tell me how to install GHC with a newer GCC?
10:36:04 <Botje> gressvol--: you can't do that with a list comprehension. look at foldr instead.
10:38:30 <EvanCarroll> Botje: sup dude
10:38:32 <EvanCarroll> long time no see
10:39:20 <Botje> i just got back from begging for money
10:39:30 <Botje> if i get it i can slack for four years :)
10:43:06 <Yuuri> RDonch, hello 8=]
10:43:17 <RDonch> Yuuri: hey. 8=]
10:43:26 <Yuuri> What have you forgot here?
10:44:02 <RDonch> Just wanna see how you're faring.
10:44:18 <Yuuri> I do it this way:
10:44:26 <Yuuri> Please help me! T_T
10:45:21 <Yuuri> I have GHC 6.10.4 for Win32, but it comes with GCC 3.4.5 only, and I need to install GCC 4.4.0 some way.
10:47:51 <Botje> Yuuri: you could install gcc separately?
10:48:35 <Yuuri> Botje, I installed MinGW, but I don't know how to make GHC use an external GCC...
10:48:48 <Botje> you'll probably have to specify that at compile time
10:49:36 <Igloo> If it helps, I think 6.12 will come with 4.4
10:49:58 <Yuuri> I don't compile, I install package - Graphics.GD which is a binding to the C library
10:50:02 <Igloo> Or you can tell GHC what gcc to use with the -pgmc flag
10:50:14 <lpsmith> Yuuri:  ghc should be using the native code generator by default anyway,  not gcc
10:50:35 <Yuuri> And cabal install runs GCC that comes with a GHC package
10:51:39 <lpsmith> ahh,  i see
10:57:29 <Yuuri> What should I do? Is it possible to replace GCC binaries in GHC folder, maybe? Or to change config files?
10:58:10 <lpsmith> yuuri:  there should be an option in your .cabal/config,  iirc
10:58:36 <luite> Igloo: oh really? is 4.4 already included in the latest binaries for windows?
10:58:55 <mrbluesky> Hey! How do I run Haskell binaries? I would have thought it would've been "./File.o", but that's not working for me.
10:59:07 <sm> ./File
10:59:26 <chrisdone> mrbluesky: well, ghc should output a binary, either programname or programname.exe
10:59:35 <chrisdone> mrbluesky: did you use ghc --make?
10:59:38 <mrbluesky> Yeah
10:59:45 <mrbluesky> It's only outputting .hi and .o
10:59:51 <chrisdone> odd
10:59:53 <koeien37> did you define a main function?
10:59:59 <theclaw> when (++) is defined as: "(++) = foldr (\a b -> (a:) . b) id", then the "rightmost fold" of e.g. "(++) [1,2,3]" would be "(3:) . id", right? But this can't be the case, as it doesn't work! :/
11:00:14 <mrbluesky> as in a "main = do"? Yeah I did that
11:00:35 <koeien37> no error messages from the compiler?
11:00:40 <mrbluesky> none at all
11:00:42 <sm> do you have a "module SomethingOtherthanMain" declaration in the file ?
11:01:09 <mrbluesky> yeah, module A
11:01:14 <Yuuri> lpsmith: err... Where is this file in Windows? :-[
11:01:14 <mrbluesky> the file is A.hs
11:01:15 <rob|> hey guys. anyone around with privs to invite lambdabot to a channel?
11:01:21 <sm> just remove that or make it module Main
11:01:32 <mrbluesky> ok
11:02:06 <mrbluesky> that worked! Thanks man (:
11:02:19 <sm> np
11:02:27 <lpsmith> yuuri:  I don't remember exactly,  I think it's something like /home-directory/appdata/cabal/config
11:02:34 <lpsmith> but I can never remember
11:03:03 <lpsmith> I'm not sitting at a windows box ATM to check
11:03:20 <theclaw> err, I'm wrong
11:04:26 <lpsmith> Yuuri:  /user/yuuri/AppData/Roaming/cabal/config
11:06:10 <Yuuri> lpsmith: Thank you. Now I'm trying to find a right parameter...
11:06:48 <quicksilver> EnglishGent: no need. mapM already has both those types.
11:07:00 <quicksilver> EnglishGent: (set "m" = "Identity" to get the first)
11:07:22 <zenzike> I have a large state, like data State = State x1 x2 ... xn. I need to be able to manipulate the variables x1 .. xn with IORefs, is it better to have a single IORef to a state (an IORef State), or define my State so that each of the x1 .. xn is an IORef?
11:07:52 <lpsmith> Yuuri:  you should be able to set the "flags:" parameter and use the flag that Igloo mentioned
11:08:38 <quicksilver> zenzike: almost certainly one large IORef is better than n small ones
11:09:13 <zenzike> quicksilver: that's what i thought at first, but is there a good reason for it? Is it not better to pass a pure State around, that is made up of lots of impure bits and bobs?
11:09:33 <sproingie> perhaps you want ST
11:10:01 <Yuuri> lpsmith: Thanks! I'd better check it tomorrow, I've already tired of infinite trial-n-errors >_<
11:10:13 <Baughn> zenzike: Why do you want IORef at all, instead of using State?
11:10:34 <zenzike> Baughn: I don't actually know why not. Would you recommend State or ST instead?
11:10:52 <jmcarthur_work> if it is possible with State you should use State, usually
11:10:53 <Baughn> zenzike: Yes. It's highly inconvenient to have to use all over the place.
11:11:10 <koeien37> zenzike: if you can, you can escape rom State or ST
11:11:25 <koeien37> Baughn: you missed an "IO" there :)
11:11:27 <zenzike> oh, but I'm working within an IO monad already, is that going to cause problems?
11:11:27 <Baughn> zenzike: It's sometimes necessary, but then mostly when using the same state from multiple threads, and I tend to find that STM is better than IORef then
11:11:49 <jmcarthur_work> zenzike, StateT :)
11:12:02 <jmcarthur_work> it really depends on the abstraction you want
11:12:12 <Baughn> zenzike: Once you have fallen into sin, you can never escape. The program that uses IO will forever be tainted.
11:12:13 <zenzike> Thanks. I'll get reading :-)
11:12:19 <jmcarthur_work> and that usually is hard to think about until you have just tried it a few times
11:12:23 <zenzike> I've just been messing around with opengl stuff, and all the examples use iorefs
11:12:25 <sproingie> the program without any IO is not very interesting
11:12:38 <Baughn> But it's pure!
11:12:49 <jmcarthur_work> zenzike, GLUT callbacks make it kind of hard to stay pure sometimes :(
11:13:04 <mm_freak> IO isn't impure in any way, you just need to be careful not to think imperatively too much
11:13:19 <jmcarthur_work> well, the IO *monad* is pure
11:13:22 <sproingie> IO on the whole isn't impure
11:13:33 <sproingie> inside of IO there are all kinds of impure things crawling about
11:13:35 <mm_freak> also you should not that you use pure stuff from IO stuff, not the other way around
11:13:44 <koeien37> well yeah, C isn't impure either, if you consider everything in an IO monad
11:14:14 <mm_freak> nothing about IO is impure
11:14:25 <jmcarthur_work> not inherently
11:14:37 <koeien37> i have not seen a good (strict, mathematical) definition of "impure"
11:14:40 <koeien37> does it exist?
11:14:43 <mm_freak> its implementation is impure, but the code itself is pure, even if you do real I/O or generate truely random numbers
11:14:52 <zenzike> i'm pretty sure i can't stay pure in these examples, but that got me wondering about whether or not it was better to have a single motherofall IORef, or spawn off lots of little IORefs
11:14:56 <jmcarthur_work> it's kind of a chicken and egg problem though. purity is built on impurity, and impurity is built on purity
11:15:20 <mm_freak> koeien37: purity is usually defined in terms of referential transparency
11:15:36 <mm_freak> if you can replace a function call by its result without effect on the meaning of the program, then it
11:15:41 <mm_freak> then it's a pure function
11:15:46 <jmcarthur_work> and i would consider referential transparency to only have meaning in an otherwise impure context
11:15:55 <koeien37> "function call"
11:15:59 <jmcarthur_work> so purity and impurity are relative to each other in that sense
11:16:11 <koeien37> but i can live with it still being a bit vague
11:16:14 <Baughn> zenzike: Well, you could kill two dogs with one stone and use STM
11:16:21 <mm_freak> koeien37: i consider application a function "call"
11:16:21 <jmcarthur_work> a pure function has no impact on its impure context
11:16:26 <koeien37> yeah, STM rocks (although i haven't used it.)
11:16:54 <koeien37> mm_freak: but then i can argue that C is pure too. the current syntax is syntactic sugar for a referentially transparent (say) monadic I/O program
11:17:03 <mm_freak> the thing is:  there are no impure functions in haskell…  there are _some_ impure function in the usual implementations
11:17:13 <mm_freak> functions like unsafePerformIO
11:17:23 <mm_freak> koeien37: no, C is not pure
11:17:38 <mm_freak> you can't replace printf("x"); by simply 1;
11:17:48 <koeien37> mm_freak: i say that f(x(), x()) becomes, a <- x; b <- x; f a b
11:17:51 <wdonnelly> relevant: http://conal.net/blog/posts/the-c-language-is-purely-functional/
11:18:02 <mm_freak> koeien37: note that IO is a state monad
11:18:20 <mm_freak> only it has no discrete representation in memory, because its state is the universe
11:18:30 <koeien37> mm_freak: it is just that the monadic stuff reminded me a few years ago as the "inverse of the semantics of an imperative language"
11:18:37 <PeakerWork> mm_freak: that kind of view makes it quite difficult to model forkIO/etc
11:18:51 <mm_freak> PeakerWork: yes, but it's the general idea behind it
11:18:51 <jmcarthur_work> haskell itself is impure if your definition of referential transparency includes that the value of an expression on one architecture must be the same as that expression on another architecture
11:18:55 <conal> mm_freak: iiuc, the state monad view of IO is a persistent, misleading myth
11:19:04 <jmcarthur_work> where the architecture is considered a part of the impure state of the world
11:19:05 <quicksilver> GLUT callbacks aren't really a substantial problem.
11:19:13 <conal> mm_freak: since that view doesn't explain concurrency
11:19:16 <quicksilver> they're just fiddly.
11:19:21 <koeien37> wdonnelly: interesting article.
11:19:38 <zenzike> Baughn: thanks, I'll look into it
11:19:51 <mm_freak> well, actually i have to ask how it doesn't
11:19:58 <quicksilver> you can always extract some state (from an MVar) in a callback wrapper, run an entirely non-IO (e.g. State monad) callback and then stuff it back in.
11:20:02 <mm_freak> but i'll ask that in a few hours, because i've got to go now =)
11:20:04 <koeien37> this was something i had in my mind somewhere, but not as concrete as said there
11:20:04 <mm_freak> see you later
11:20:06 <jmcarthur_work> i'm fine with just saying that the IO monad is a way to relatively sequence IO actions, and not much else
11:20:35 <quicksilver> conal: it is an unfortunate thing that the GHC implementation uses the State# construct which makes IO *look* like a state monad.
11:20:53 <PeakerWork> The words "purely functional" lose a lot of their meaning after showing you can build imperative programs from these "pure" values -- to restore their meaning -- it makes sense to re-define them to mean something other than referential transparency
11:20:59 <quicksilver> conal: of course State# is not haskell, and RealWorld# is only a trick (like ST)
11:21:00 <conal> quicksilver: yeah :(  people keep getting fooled and fooling others.
11:21:12 <jmcarthur_work> PeakerWork, agreed
11:21:16 <idnar> @pl \f x -> (x, f x)
11:21:16 <lambdabot> ap (,)
11:21:26 <koeien37> i don't think we need to define "purely functional"
11:21:45 <jmcarthur_work> i think we do if we intend to use it
11:21:46 <koeien37> at least not rigorously . i doubt it can be done
11:21:50 <quicksilver> conal: in fact I think the best way to describe it might be to say that State# is a hack in the *impure* language of GHC core to control evaluation so that it can be used to implement haskell purely.
11:22:11 <jmcarthur_work> we could at least establish a working definition that explains how we think *haskell* is purely functional
11:22:24 <quicksilver> conal: (and it's resemblence to the State monad is just slightly more than a syntactic coincidence)
11:23:11 <quicksilver> jmcarthur_work, koeien37 : a pure function (a -> b) is a function which will always produce the same b, given the same a. Haskell is purely functional because its function type (->) has this property.
11:23:26 <koeien37> quicksilver: C has no function type, then
11:23:53 <koeien37> how can we then say it is pure or impure?
11:24:21 <danderson> @unmtl MaybeT (State s) a
11:24:21 <lambdabot> s -> (Maybe a, s)
11:24:38 <danderson> nifty.
11:24:51 <sproingie> @mtl s -> (Maybe a, s)
11:24:51 <lambdabot> Maybe you meant: ft map msg pl unmtl url
11:24:57 <sproingie> aw :(
11:25:10 <jmcarthur_work> quicksilver, not when a or b are e.g. Int and you adopt the (controversial) view that a program should behave the same for every run no matter the architecture
11:25:44 <PeakerWork> sproingie: @mtl for when you know what the type is, but not what it means? :-)  If you know it means: Maybe within State you don't really need @mtl to tell you the syntax :)
11:27:08 <sproingie> could be a nice way to suggest transformers
11:27:23 <sproingie> but mostly for silliness
11:28:35 <conal> jmcarthur_work: thx for making that last point.
11:29:47 <quicksilver> jmcarthur_work: I agree with that view but I think we can view it as a less serious problem
11:30:12 <quicksilver> jmcarthur_work: I would rather a language which only used types with precise semantics, but I don't lose much sleep over Int.
11:30:26 <quicksilver> koeien37: C has a function type; int a(int)
11:30:30 <quicksilver> koeien37: and it's impure
11:30:44 <jmcarthur_work> i don't even mind its presence in the libraries, just in the spec and Prelude
11:31:01 <quicksilver> jmcarthur_work: it's a regrettable concession to efficient compilation.
11:31:15 <quicksilver> jmcarthur_work: it's not as serious as unrestricted sideeffects :)
11:31:22 <jmcarthur_work> true
11:31:36 <quicksilver> System.Info and similar modules bug me though
11:31:48 <quicksilver> System.Info.osVersion or whatever it's called should be IO-tagged
11:32:05 <quicksilver> and there's actually no real efficiency advantage gained by this incorrectness.
11:32:43 <conal> i'd love to have a shared, solid foundation for these questions.  RT is mired in confusion.  my offering is the two principles in http://conal.net/blog/posts/notions-of-purity-in-haskell/
11:33:14 <jmcarthur_work> quicksilver, you have to admit that it's in keeping with the idea that referential transparency is scoped by runs of the program
11:33:22 <geekagent> I just wrote a database pool for Takusen. Anyone interested?
11:34:16 <ksf> > Just 3 >> Just 4
11:34:17 <lambdabot>   Just 4
11:34:22 <ksf> Qed.
11:34:31 <ksf> the maybe monad isn't commutative.
11:34:39 <ksf> heck even the monoid isn't.
11:34:42 <ksf> how could it?
11:35:40 <jmcarthur_work> the monoid could be if the inner monoid is, couldn't it?
11:35:47 <quicksilver> jmcarthur_work: it is, I just don't like that idea :)
11:35:58 <EnglishGent> conal - I agree the Int thing is particularly ugly
11:35:59 <jmcarthur_work> so you might be able to say that the monoid is "commutativity preserving"?
11:36:04 <ksf> > [1,2] >> [3,4]
11:36:05 <lambdabot>   [3,4,3,4]
11:36:13 <ksf> > [1,2] << [3,4]
11:36:13 * EnglishGent wishes Haskell would default to Integer
11:36:14 <lambdabot>   Not in scope: `<<'
11:36:17 <quicksilver> jmcarthur_work: referential transparency should be powerful enough to allow compile time calculation and/or migrating of distributed processes
11:36:31 <jmcarthur_work> quicksilver, 100% agree
11:36:42 <conal> EnglishGent: glad to hear.  i get discouraged with how many haskellers accept stuff like this.
11:36:48 <quicksilver> ksf: that's not what commutativity means of a monad
11:36:52 <geekagent> EnglishGent: whats wrong with (Num a) => a?
11:37:29 <quicksilver> ksf: commutative monoids are those such that (x <- a; y <- b; return (x,y)) === (y <- b; x <- a; return (x,y))
11:37:42 <quicksilver> ksf: Maybe is commutative, up to ability to distinguish different bottoms.
11:37:50 <EnglishGent> geekagent - I mean the fact that the size of Int is machine dependent in Haskell - Int is not a big int like Integer - and for a language that strives for mathematical purity - this grates
11:38:08 <EnglishGent> Common Lisp gets this right - BigInts are the default
11:38:11 <ksf> quicksilver, can you add that to http://www.haskell.org/haskellwiki/What_a_Monad_is_not?
11:38:51 <jmcarthur_work> quicksilver, actually, commutativity in that sense can be generalized to Applicative, can't it?
11:38:54 <chrisdone> EnglishGent: yeah. imagine we had Char and Character...
11:39:09 <quicksilver> jmcarthur_work: yes definitely
11:39:17 <quicksilver> jmcarthur_work: informatlly it means "the order of effects isn't observable"
11:39:25 <jmcarthur_work> that would be when (*>) == (<*) ?
11:39:30 <jmcarthur_work> wait
11:39:30 <straw> Is there a function which gets a list and gives back a list of tupels containing the elements and their index? (ATM I'm using something like.. zip list (length list)
11:39:32 <jmcarthur_work> wrong
11:39:45 <jmcarthur_work> when (a *> b) == (b <* a)
11:39:53 <koeien37> > zip [1,2,5] [1..]
11:39:53 <quicksilver> yes
11:39:53 <lambdabot>   [(1,1),(2,2),(5,3)]
11:40:00 <ksf> .o( which might just be connected to applicatives also existing as indexed versions )
11:40:11 <quicksilver> jmcarthur_work: or liftA2 (,) x y = swap $ liftA2 (,) y x
11:40:23 <straw> koeien37: thanks
11:40:35 <quicksilver> jmcarthur_work: or, flip (liftA2 f) == liftA2 (flip f)
11:40:51 <jmcarthur_work> quicksilver, yup
11:41:02 <conal> or flip . liftA2 == liftA2 . flip
11:41:11 <conal> hm.  nice.
11:41:11 * jmcarthur_work wonders when knowing that property would be useful
11:41:16 <jmcarthur_work> conal, i like that
11:41:22 <quicksilver> the eta reduction was left as an exercise to the reader
11:41:25 <quicksilver> conal++ # top of the class
11:41:40 <chrisdone> hehe
11:41:48 <Taejo> :t liftA2 . flip
11:41:49 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (b -> a -> c) -> f a -> f b -> f c
11:41:56 <conal> quicksilver++ for the more insightful bit
11:42:05 <quicksilver> jmcarthur_work: it gives the compiler even more freedom to reorder stuff, but I can't imagine it being useful in practice
11:42:21 <quicksilver> jmcarthur_work: conceivably it might somehow enable further optimisations in some contexts
11:44:59 <quicksilver> ksf: if you want to connect the intuition to Monoids, a commutative Monad m has a commutative Monoid "m ()"
11:45:05 <jmcarthur_work> i could see it as a way to parallelize certain applicatives or something, perhaps, where all the threads can simply contribute to a single result in whatever order they complete
11:45:05 <quicksilver> > Just () >> Nothing
11:45:06 <lambdabot>   Nothing
11:45:09 <quicksilver> > Nothing >> Just ()
11:45:10 <lambdabot>   Nothing
11:45:22 <quicksilver> jmcarthur_work: as long as everything inlines, teh compiler can see that anyway
11:46:04 <jmcarthur_work> can see it, but won't use it afaik...
11:46:10 <quicksilver> jmcarthur_work: (I mean, the lack of data dependencies once the defintions of >> *> <*> are fully inlined already gives the compiler the ability to parallelise)
11:46:22 <jmcarthur_work> theoretically
11:46:23 <quicksilver> right, the ghc compiler doesn't do *any* speculative evaluation yet
11:46:32 <quicksilver> but, if it did, it would work as well in this case as any other
11:46:41 <quicksilver> you wouldn't have to tell it expicitly that a monad was commutative :)
11:46:42 <jmcarthur_work> i'm not sure i would want it to unless it was very very good
11:47:24 <quicksilver> it's very hard to get it right
11:47:34 <quicksilver> it's very intuitively attractive tho
11:47:35 <jmcarthur_work> but in the absence of compiler optimizations, this idea could at least be useful for parallelizing certain things which have effects
11:47:50 <jmcarthur_work> with code put in manually for it, i mean
11:48:25 * jmcarthur_work considers what it really *means* to parallelize effects
11:49:14 <quicksilver> parallelisation is given as a motivation for applicative in the original applicative paper IIRC
11:49:23 <jmcarthur_work> oh? i don't remember that
11:50:05 <absentia> wha?
11:50:13 <ksf> quicksilver, what I want is to prevent people looking at http://www.haskell.org/haskellwiki/What_a_Monad_is_not getting too confused. and >> by itself clearly isn't commutative.
11:51:28 <quicksilver> ksf: agree entirely. I'll correct it later if no one else does before me.
11:51:37 <sproingie> it is associative tho, right?
11:51:49 <koeien37> yep
11:52:26 <koeien37> follows from m >>= (\x -> k x >>= l) = (m >>= k) >>= l
11:52:44 <jmcarthur_work> hmm... i guess any monad can be parallelized, really, although the run function might not actually use that
11:53:06 <jmcarthur_work> in the sense that you can run the first half and the second half, then combine them
11:53:16 <jmcarthur_work> s/run/evaluate/
11:53:33 <jmcarthur_work> i'm not sure how >>= plays into it
11:53:46 <jmcarthur_work> but >=> is associative
11:54:21 <jmcarthur_work> (which is the core of the >>= law above)
11:54:39 <koeien37> yes, the law is nicer with >=>
11:55:21 <rgr> why is [1..5] legal as a range but [5..1] not?
11:55:31 <jmcarthur_work> rgr, both are perfectly legal
11:55:44 <jmcarthur_work> [5..1] just doesn't do what you want ;)
11:56:18 <rgr> jmcarthur_work: could you explain quickly?
11:56:18 <jmcarthur_work> > [5,4..1]
11:56:19 <lambdabot>   [5,4,3,2,1]
11:56:23 <jmcarthur_work> > [5..1]
11:56:24 <lambdabot>   []
11:56:33 <rgr> Why could it not "guess" 1 as in [1..5]?
11:56:37 <rgr> or -1
11:56:38 <jmcarthur_work> [5..1] is legal and represents []
11:56:48 <jmcarthur_work> rgr, we don't play guessing games in haskell ;)
11:56:57 <rgr> why is it guessing?
11:57:08 <rgr> (any more than [1..5])
11:57:09 <jmcarthur_work> it's not guessing
11:57:19 <jmcarthur_work> @src enumFromTo
11:57:19 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:57:29 <jmcarthur_work> meh
11:57:46 <koeien37> @src enumFromTo Int
11:57:47 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:57:58 <rgr> just from high "beginner" level it seems that [1..5] and [5..1] can have the same assumptions made.
11:58:18 <jmcarthur_work> rgr, what assumptions?
11:58:28 <Polarina> I am running Ubuntu 9.04, how can I use ghci to compile a .exe for my lame Windows users?
11:58:30 <rgr> you cant guess? The ones I made I assum :)
11:58:37 <rgr> e.g a range
11:58:37 <jmcarthur_work> the definition of enumFromTo uses succ and a simple condition to test when it's done
11:58:53 <jmcarthur_work> rgr, [] is a range
11:59:00 <rgr> ok so its your knowledge of how its done rather than why. I see that.
11:59:57 <rgr> I'll probably get it later in the tutorial. Thanks.
12:00:02 <jmcarthur_work> rgr, what about \x → [1..x]? should it really result in [1, 0] if you pass in 0? you would just have to do more work to rule that out (which i think would be the more common case than allowing it)
12:02:50 <sjanssen> http://www.haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_a_replacement_for_applicative_functors
12:03:21 <sjanssen> above link contains the claim "a monad is a monoid in a category of endofunctors. It's all very simple", doesn't that seem very smug?
12:03:21 <sjanssen> perhaps misleading?
12:03:32 <shambler_> @src append
12:03:32 <lambdabot> Source not found. There are some things that I just don't know.
12:03:36 <jmcarthur_work> i would remove it
12:03:43 <jmcarthur_work> if i was logged in
12:03:46 <shambler_> @src (++)
12:03:47 <lambdabot> []     ++ ys = ys
12:03:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:03:47 <lambdabot> -- OR
12:03:47 <lambdabot> xs ++ ys = foldr (:) ys xs
12:03:49 <Polarina> I am running Ubuntu 9.04, how can I use ghc to compile a Haskell program into an .exe for my lame Windows users?
12:03:49 <jmcarthur_work> or remembered my password
12:04:31 <blackh> Polarina: Normally you have to use Windows.  I have not tried, but in theory you should be able to run ghc under wine and get a Windows executable.
12:04:34 <ksf> Polarina, wine.
12:04:50 <jmcarthur_work> Polarina, be nice you your windows users.... convert them to linux :)
12:04:50 <Polarina> :(
12:04:55 <jmcarthur_work> *to your
12:05:06 <ksf> ghc can, in principle, cross-compile, but you're going to hate your life if you set out doing that.
12:05:22 <Polarina> ksf: So, how do I make it crosscompile?
12:06:11 <andyjgill> Hey, has anyone got a (reference to a) gif of the Thompson-Wheeler logo?
12:06:19 <blackh> Polarina: There's a cross-compiling patch that someone did recently, and with some work you could adapt it to cross-compile to Windows.
12:06:20 <ksf> I don't think it's going to work without fixing the build system.
12:07:01 <MarcWeber> Polarina: viric is working on adding cross compilation support to nix(os). nix could be a nice environment to setup this. However there is still some work to be done.
12:07:11 <sjanssen> Polarina: using wine or Windows itself will be much easier and take less time
12:07:18 <Polarina> Ok.
12:07:46 <eivuokko> Does cross-compiling affect th?
12:08:16 <sjanssen> eivuokko: that's a good question.  I imagine TH would be a major obstacle to cross-compiling
12:08:49 <Polarina> TH?
12:08:53 <jmcarthur_work> template haskell
12:09:03 <jmcarthur_work> a macro language for haskell, basically
12:09:13 <sjanssen> Polarina: Template Haskell, a compile-time metaprogramming feature
12:09:18 <eivuokko> Polarina, template haskell, implemented as running user (haskell) code inside compiler.
12:09:25 <Polarina> o.O
12:09:27 <sjanssen> (if you're using it, you'd know)
12:09:33 <Polarina> Ok. :P
12:09:45 <jmcarthur_work> sjanssen, unless it's a library that's using it and not his code
12:09:50 <eivuokko> And it's not *so* easy to avoid using packages that use TH in practice.
12:33:54 <Polarina> How do I flush text to terminal after a putStr?
12:34:05 <mauke> hFlush stdout
12:34:11 <Polarina> Thanks.
12:40:01 <Saizan>  /win 20
12:40:06 <PopeDavid> before anyone says I haven't done enough research, I have :p ; what's the best way to convert an Int to [Char] and vice versa? all I see in the prelude is digitToInt and intToDigit
12:40:32 <mauke> return . ord
12:40:33 <roconnor> > read "20" :: Integer
12:40:34 <lambdabot>   20
12:40:38 <mauke> er, return . chr
12:40:41 <roconnor> > show 20
12:40:42 <lambdabot>   "20"
12:41:21 <Raevel> > readS "20" :: Int
12:41:22 <lambdabot>   Not in scope: `readS'
12:41:22 <PopeDavid> ah, I see. What's the significance of the double colon? I thought that was used in definition signatures, not as part of a call
12:41:40 <Raevel> PopeDavid: you can specify types anywhere
12:41:48 <roconnor> PopeDavid: read and show are what you want, but they are somewhat hard to find because of their polymorphism
12:41:54 <roconnor> @hoogle Int -> [Char]
12:41:55 <lambdabot> Prelude show :: Show a => a -> String
12:41:55 <lambdabot> Text.Show show :: Show a => a -> String
12:41:55 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:42:03 <roconnor> @hoogle [Char] -> Int
12:42:03 <lambdabot> Test.HUnit.Base Label :: String -> Node
12:42:03 <lambdabot> Prelude error :: [Char] -> a
12:42:03 <lambdabot> Prelude length :: [a] -> Int
12:42:14 <Rotaerk> PopeDavid, if an expression is generic, you can specify the type it should be treated as
12:42:15 <roconnor> well, at least show is easy to find.
12:42:47 <PopeDavid> yeah. Thanks for the advice :)
12:42:58 <roconnor> PopeDavid: I have to say read "20" :: Integer  to say that read "20" has type Integer, because otherwise read doesn't know what type it should produce.
12:43:11 <chrisdone> hahaha, my own code just cracked me up. epic failure: http://chrisdone.com/pics/fail.png
12:43:16 <roconnor> PopeDavid: if you use read "20" in a context where it is clear, you don't need the type anotation
12:43:24 <roconnor> > read "20" + read "5"
12:43:25 <lambdabot>   25
12:43:32 <roconnor> no annotation neede here
12:43:34 <chrisdone> it's supposed to show 'sky"
12:44:13 <Rotaerk> chrisdone, close enough!
12:44:17 <chrisdone> haha
12:44:29 <mauke> sʞʎ
12:44:55 <chrisdone> hahaha
12:45:19 <medfly> > read 'a' + 5
12:45:20 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:45:20 <lambdabot>         against inferred ty...
12:45:25 <medfly> I had to try
12:45:34 <roconnor> I guess it would take a lot of work to have types save chrisdone from that error.
12:47:50 <koeien37> > read "a" + 5
12:47:51 <lambdabot>   * Exception: Prelude.read: no parse
12:48:32 <Zariel> hi, why does this not work http://pastey.net/129356 ?
12:48:34 <PopeDavid> roconnor: ta, my code works now, thanks
12:49:13 <mauke> Zariel: because x :: Char and a :: String
12:49:27 <Megant> Zariel: you are mapping the characters in the string
12:49:30 <medfly> then b?
12:50:02 * medfly wonders if that works
12:50:24 <Cale> Zariel: btw, you're indenting if/then/else improperly
12:50:29 <Cale> Zariel: It should look like:
12:50:32 <Cale> if foo
12:50:34 <Cale>    then bar
12:50:38 <Cale>    else quux
12:51:02 <Zariel> ah right, thats the python kicking out again
12:53:20 <Cale> Zariel: So, there are two type errors: one is that you're comparing x (which is a Char) with a (which is a String), and the second is that the possible results of the if are b (which is a String) and x (which is a Char)
12:53:23 <Zariel> hm, so im trying to do it wrong. Im trying to do 's/a/b/' c
12:53:44 <Cale> Zariel: are a and b supposed to be Chars after all then?
12:53:51 <Zariel> strings
12:54:00 <Cale> Okay, then map won't help you.
12:54:13 <Cale> (well, not directly)
12:55:15 <BONUS> quick : if we have several threads waiting to takeMVar, are they going to take them out in the order in which they blocked or in arbitrary order?
12:55:27 <wenlibot> wow god haskell is so slow
12:55:34 <koeien37> nope it isn't
12:55:41 <ben0x539> is too
12:55:43 <koeien37> is there a specific problem?
12:55:55 <BONUS> e.g. when it's filled up, which thread gets to take it
12:55:55 <ben0x539> compiling ghc takes forever! compiling lua takes like five minutes!
12:55:56 <Cale> wenlibot: Which implementation?
12:56:14 <wenlibot> ghc code is so bloated!..
12:56:19 <Heffalump> ben0x539: that's because lua doesn't do anything useful ;-)
12:56:19 <Cale> (Haskell is just a language, so it can't be fast or slow)
12:56:20 <wenlibot> hello world is like 500 kb
12:56:23 <wenlibot> what the hell
12:56:35 <Cale> wenlibot: That's a constant term though.
12:56:37 <mauke> BONUS: first to block is first to get the value
12:56:38 <ben0x539> Heffalump: Come on, now, lua runs half of World of Warc-- point taken
12:56:48 <junmin> > read "12"
12:56:49 <lambdabot>   * Exception: Prelude.read: no parse
12:56:53 <Cale> wenlibot: Your executables won't grow in proportion to that when the program becomes more complicated.
12:57:12 <Cale> wenlibot: There's a lot of stuff which is statically linked into every binary that GHC produces.
12:57:14 <gcollins> wenlibot: executables are linked statically, shared lib support coming within a version or two
12:57:49 <wenlibot> WHY?
12:58:10 <mauke> wenlibot: because people like dynamic linking
12:58:24 <Cale> wenlibot: Because there's a garbage collector and a thread scheduler, and all sorts of other stuff which every GHC-Haskell program needs to run.
12:58:47 <BONUS> mauke: pip pip! cheerio
12:59:01 <blackh> wenlibot: The stuff in the GHC runtime is so cool, that 500 KB doesn't even seem like that much!
12:59:21 <wenlibot> the code that it generates SUCKS
12:59:33 <Cale> wenlibot: How so?
12:59:42 <mauke> wenlibot: nah, all machine code looks like that
12:59:49 <sjanssen> wenlibot: please don't troll in here
12:59:50 <Cale> wenlibot: Can you see ways in which to improve it?
13:00:06 <Cale> wenlibot: If so, then perhaps submit bugs to the GHC trac.
13:00:06 <blackh> wenlibot: Of course the generated code sucks! That's what we have compilers for!
13:00:29 <wenlibot> seriously 500kb for hello world..
13:00:36 <mauke> 500kb is nothing
13:00:54 <Heffalump> wenlibot: what are you actually trying to achieve with this conversation?
13:00:57 <Cale> wenlibot: What's 500kb? That's not even a minute of audio.
13:00:57 <blackh> wenlibot: Yeah, you need to toughen up!
13:01:01 <mauke> wenlibot: how often do you need to ship hello world to your customers?
13:01:22 <wenlibot> someone needs to learn how to write a compiler
13:01:27 <wenlibot> that doesn't make a 500kb hello world
13:01:45 <geekagent> wenlibot: it's called gcc
13:01:45 <Heffalump> wenlibot: what are you actually trying to achieve with this conversation?
13:01:50 <Cale> wenlibot: Why do you care about the size of Hello World?
13:01:55 <blackh> wenlibot: You don't seem to grasp how extremely cool it is the *way* in which "hello world" is executed!
13:02:00 <mauke> isn't it called jhc?
13:02:11 <koeien37> :)
13:02:11 <Cale> pff
13:02:16 <koeien37> socratic method ftw
13:02:19 <Cale> Trolls these days have no stamina.
13:02:23 <koeien37> yeah
13:02:23 <Heffalump> :-)
13:02:37 <sjanssen> I would at least like to see some creativity
13:02:43 <Cale> @keal
13:02:43 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
13:02:47 <koeien37> and definitely more persistence
13:02:53 <sjanssen> @protontorpedo
13:02:53 <lambdabot> what is the best absolute beginner utorial for haskell?
13:03:42 <Cale> protontorpedo was persistent, but keal was genuinely entertaining
13:03:54 <EnglishGent> ?
13:04:03 <EnglishGent> ah! trolls
13:04:07 <eivuokko> Historical figures on #haskell.
13:04:21 <geekagent> EnglishGent: I believe they're reminiscing with the help of lambdabot
13:04:24 <Cale> EnglishGent: When someone trolls here for long enough, we make a bot of them.
13:04:38 <Raevel> cruel fate :-(
13:04:48 <mauke> http://halfassured.tumblr.com/post/241422880
13:04:54 <EnglishGent> <deadpan>hmm - so ... you reward trolls with - immortality? </deadpan>
13:05:12 <EnglishGent> :)
13:05:16 <koeien37> we even love trolls in #haskell
13:05:21 <sjanssen> EnglishGent: no, we provide ourselves with infinite opportunities to make fun of them
13:06:03 * EnglishGent wonders ... can the bots pass the turing test? indeed - can the trolls on which their based?
13:06:35 <ixor> I hear Haskell's arrays suck. Is that true?
13:06:52 <EnglishGent> see... bot or human?
13:06:55 <mauke> ixor: can you pass the turing test?
13:06:56 <EnglishGent> good question isnt it? :D
13:07:19 <ixor> turing test?
13:07:23 <Lemmih> ixor: Data.Vector is pretty good.
13:07:28 <tromp_> ixor, do you want them to suck, or do you not want them to suck?
13:07:29 <EnglishGent> define 'suck' ixor - what problem are you trying to solve?
13:07:37 <Geheimdienst> ixor successfully passed the trolling test. jury still out on turing test.
13:07:43 <ixor> I want fast programs
13:07:52 <sjanssen> ixor: they're a mixed bag.  However, we usually avoid arrays for structures that are nicer in a functional setting: lists, Data.Map, etc.
13:07:53 <mauke> ixor: then why use arrays?
13:07:57 <geekagent> ixor: fast programs that do what?
13:08:00 <Botje> do you have an objective metric for 'suck' ? :)
13:08:03 <ixor> that use arrays
13:08:06 <mauke> the fastest program is the one that doesn't use data structures
13:08:09 <tromp_> ixor, you can't get any faster than main = return ()
13:08:22 <ixor> so do Haskell's arrays suck?
13:08:30 <EnglishGent> ixor - for doing what? if your word processor completes its spell check 10ms faster - you wont notice
13:08:39 <ixor> for doing things quickly
13:08:44 <EnglishGent> if you want to use arrays a lot - have a look at ZPL
13:08:45 <koeien37> no
13:08:47 <Lemmih> ixor: No. But they can be unwieldy if used unwisely.
13:08:51 <mauke> oh, "things"
13:08:53 <sjanssen> ixor: if you ask a question, I think you're obligated to read our responses before repeating it :)
13:08:59 <EnglishGent> (a modern variant on APL)
13:09:10 <ixor> I heard Haskell can't even express generic parallel quicksort
13:09:26 <EnglishGent> ixor - C cant even do lambdas
13:09:34 <sjanssen> ixor: you're listening to Jon Harrop too much, and it isn't true
13:09:41 * Botje gives ixor a 3/10
13:09:46 <Botje> next troll!
13:09:56 <mauke> oh, was that the troll gong?
13:09:57 <Botje> let's hope that one is more entertaining
13:10:11 <Heffalump> what did wenlibot get?
13:10:13 <EnglishGent> speed isnt everything - there _are_ applications that need it - for many problems however engineer time is far more valuable than machine time
13:10:33 <ixor> so if my application does need speed I shouldn't use Haskell?
13:10:36 <EnglishGent> wb necrobious
13:10:40 <Botje> i wasn't around for that one :)
13:10:43 --- mode: ChanServ set +o sjanssen
13:10:47 <mauke> ixor: you're out
13:10:49 <ixor> aww
13:10:54 --- kick: ixor was kicked by sjanssen (sjanssen)
13:10:55 <mauke> have a spidergoat: http://sugarmegs.org/posternutbag/goat%20on%20rock.jpeg
13:11:01 <EnglishGent> it depends how much speed you need for your application - if
13:11:08 <EnglishGent> oh - I had a sensible answer for that :P
13:11:09 <Heffalump> ixor was me, btw. Sorry if it actually annoyed anyone.
13:11:17 <sjanssen> Heffalump++ nice try
13:11:18 <EnglishGent> hi Heffalump :)
13:11:22 <tromp_> haskell beats c on some shootout tests
13:11:25 <koeien37> Heffalump++
13:11:36 <koeien37> it was too coincidental :P
13:11:42 <Rotaerk> mauke, wtf
13:11:46 --- mode: ChanServ set -o sjanssen
13:12:40 * Heffalump will have to work on improving his score on the Botje scale :-)
13:12:42 <absentia> I'm more worried 'bout the memory use (space in haskell parlance?) than the speed.
13:12:47 <EnglishGent> sjanssen :: Maybe OP
13:12:47 <EnglishGent> :)
13:12:54 <absentia> speed is, in a sense, relative... (h0h0h0) -- but memory is not.
13:12:59 <mauke> Rotaerk: hmm?
13:13:08 * absentia hasn't seen Botje in such a long time.
13:13:16 <sjanssen> Heffalump: "generic parallel quicksort" was a dead give away
13:13:32 <sjanssen> does anybody know why JDH repeats that all the time?
13:13:43 <Heffalump> I wasn't expecting to be taken for a genuine troll :-)
13:14:13 <Rotaerk> mauke, that goat must have superpowers
13:14:21 <Heffalump> because he latches on to soundbites like that and does them to death
13:14:51 <Heffalump> though I haven't heard much more from him on the subject since my last reddit fight with him
13:15:04 <sjanssen> Heffalump: where does the soundbite come from?  Did he do one of his stupid blog posts "proving" that Haskell couldn't do it?
13:15:25 <koeien37> reddit fights? zomg
13:15:54 <Heffalump> he benchmarked the purely functional one against an imperative F# one and got a factor of 6k difference, and then couldn't find any code to copy-and-paste that did it imperatively.
13:16:01 <Heffalump> so now claims it's an unsolved problem
13:16:26 <sjanssen> Heffalump: nice.  I suppose you wrote it for him in your reddit fight?
13:16:42 <absentia> who ?
13:16:47 <Heffalump> no, I just pointed out that it was trivial and that he was clearly too stupid to do it
13:16:51 <absentia> the frog guy?
13:17:03 <Heffalump> absentia: yeah
13:17:04 <koeien37> link to epic thread?
13:17:25 <Heffalump> oh, I have epic threads with him every so often, when I feel like some entertainment
13:17:27 <absentia> I read that longa55 thread.. was amusing in the beginnig, then just got repetitive.
13:17:41 * koeien37 had a discussion once on division by zero that went on for pages...
13:18:14 <absentia> http://halshop.files.wordpress.com/2007/03/phpw9jvl0pm.jpghttp://halshop.files.wordpress.com/2007/03/phpw9jvl0pm.jpg
13:18:15 <absentia> http://halshop.files.wordpress.com/2007/03/phpw9jvl0pm.jpg
13:18:17 <absentia> sory.
13:18:42 <medfly> haha wtf
13:19:24 <Zariel> Now shouldnt x be [Char] ? http://pastey.net/129360
13:19:43 <EnglishGent> koeien -- http://spikedmath.com/089.html
13:19:48 <EnglishGent> :)
13:20:14 <Heffalump> koeien37: http://www.reddit.com/r/programming/comments/9y25c/joel_spolsky_snakeoil_salesman/c0f02j1
13:20:27 <Lemmih> Zariel: Yes, but the end result is a list of Strings, not a String.
13:20:28 <absentia> ug!
13:20:50 <Zariel> Lemmih: ah thanks, how do you unpack a list, instead of just returning list !! 0
13:20:53 <Lemmih> Zariel: You might wanna use 'unwords'.
13:22:20 <Zariel> hm, such an ugly way of doing it, it seems
13:23:34 <Lemmih> Zariel: swapWords a b = unwords . map fn . words where fn x = if x==a then b else a
13:23:37 <absentia> ug... sorry for the massive url:  http://images.google.com/imgres?imgurl=http://www.codinghorror.com/blog/images/spolsky-wtf.jpg&imgrefurl=http://www.codinghorror.com/blog/archives/000679.html&usg=__O3Z4HCOn95jy0Rg7VQjCau-8ya0=&h=300&w=300&sz=18&hl=en&start=2&tbnid=-6Vdh0TR8eoSGM:&tbnh=116&tbnw=116&prev=/images%3Fq%3Djoel%2Bspolsky%26gbv%3D2%26hl%3Den
13:23:50 <absentia> it's the coding horror url
13:24:01 <absentia> http://www.codinghorror.com/blog/archives/000679.html
13:25:39 <sproingie> my favorite Joel On Software is the one where he says "don't listen to me"
13:26:01 <sproingie> he also has a pretty good intro to unicode
13:27:10 <koeien37> Heffalump: thanks
13:28:39 <Polarina> How do I convert a String to a Factorial?
13:28:47 <tavelram> @pl \(a,b) -> (show a) ++ "\t" ++ (show b)
13:28:47 <lambdabot> uncurry ((. (('\t' :) . show)) . (++) . show)
13:28:52 <koeien37> "a factorial" ?
13:28:58 <koeien37> fractional?
13:28:58 <tavelram> yeah, not really shorter ;)
13:29:06 <Polarina> koeien37: Yes.
13:29:13 <monochrom> \s -> s ++ "!"  converts a string to a factorial
13:29:21 <Polarina> ...
13:29:31 <koeien37> depends on which fractional you want
13:29:35 <Polarina> monochrom: It does not.
13:29:38 <koeien37> read "3.1415296" :: Double
13:29:46 <koeien37> > read "3.1415296" :: Double
13:29:46 <Polarina> koeien37: Thanks.
13:29:47 <lambdabot>   3.1415296
13:30:47 <EvanCarroll> does haskell support anything like junctions?
13:31:08 <monochrom> the list monad is disjunction
13:31:29 <opqdonut> how about a cojunction?
13:32:09 <absentia> ever use scala -- want unicode variables?  :-)  just try printing out THAT program.
13:33:33 <EvanCarroll> monochrom: how would you write something like a==1||a==2||a==5 etc? is there s shorthand
13:33:54 <monochrom> @type elem
13:33:55 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:34:10 <monochrom> a `elem` [1,2,5,etc]
13:34:17 <EvanCarroll> thats right,
13:34:22 <EvanCarroll> i remember seeing that use too
13:34:30 <eugenn> > elem a [a]
13:34:31 <lambdabot>   True
13:34:52 <koeien37> :t a -- Magic!
13:34:53 <lambdabot> Expr
13:37:57 <eugenn> is Expr a subclass of some type?
13:38:08 <monochrom> No.
13:38:09 <koeien37> ??
13:38:15 <koeien37> that sentence makes no sense
13:38:36 <eugenn> as with Fractional being a subclass of Num I mean
13:38:48 <sproingie> you're confusing types with type classes
13:38:50 <monochrom> But Expr is not a typeclass.
13:38:57 <eugenn> oh
13:38:57 <koeien37> Expr is a type. Fractional and Num are typeclasses
13:39:15 <koeien37> they are different (related, of course. Types can be instances of type classes.)
13:39:36 <koeien37> Eq is a type class. Instances are, among others, Int, Bool, [a] (as long as a instantiates Eq)
13:40:28 <eugenn> is Num a type or a type class?
13:40:35 <monochrom> typeclass
13:40:39 <koeien37> a class
13:40:41 <koeien37> :t 3
13:40:42 <lambdabot> forall t. (Num t) => t
13:41:10 <koeien37> > 3 :: Num -- would not make sense
13:41:11 <lambdabot>   Class `GHC.Num.Num' used as a type
13:41:25 <koeien37> > 3 :: Int -- makes sense, since Int is a type.
13:41:26 <lambdabot>   3
13:42:07 <EnglishGent> @hoogle Set (IO a)
13:42:08 <lambdabot> System.Exit exitFailure :: IO a
13:42:08 <lambdabot> System.Exit exitSuccess :: IO a
13:42:08 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
13:42:14 <EnglishGent> @hoogle Set
13:42:15 <lambdabot> module Data.Set
13:42:15 <lambdabot> Data.Set data Set a
13:42:15 <lambdabot> Network.Browser setAllowBasicAuth :: Bool -> BrowserAction t ()
13:42:44 <EnglishGent> hi copumpkin :)
13:43:27 <eugenn> Monad is not a type class right? is a constructor?
13:43:34 <koeien37> it is a type class
13:43:37 <koeien37> :t return
13:43:38 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:43:48 <jlouis> @hoogle Monad
13:43:49 <lambdabot> module Control.Monad
13:43:49 <lambdabot> module Data.Graph.Inductive.Monad
13:43:49 <lambdabot> module Data.Graph.Inductive.Query.Monad
13:43:53 <koeien37> @src Monad
13:43:53 <lambdabot> class  Monad m  where
13:43:53 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:43:53 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:43:53 <lambdabot>     return      :: a -> m a
13:43:55 <lambdabot>     fail        :: String -> m a
13:44:01 <jlouis> ah, yes, better indeed
13:44:05 <copumpkin> oi mate
13:44:09 <copumpkin> it's a type class
13:44:44 <koeien37> so instances (which are things of _kind_ * -> *) of Monad have to implement those 4 functions (modulo default implementations.)
13:45:28 <Geheimdienst> so, are typeclasses a little like mixins (traits) in other languages? they basically seem to be bags of functions that a particular instance can implement
13:45:39 <eugenn> ooh so for example, any instance of Num that I could define must be able to sum with each other?
13:45:45 <copumpkin> typeclasses are relations
13:45:46 <koeien37> eugenn: yes.
13:46:36 <koeien37> eugenn: if you have your own type, say   data C = C Double Double   for complex numbers, you can implement Num for it. Then you can use the functions (+), (*), but also things like `sum' and `product'.
13:46:56 <koeien37> s/implement/instantiate   better terminology
13:47:39 <ksf> join === mplus, or am I messing something up?
13:47:44 <sproingie> typeclasses are like interfaces.  you have to implement them, at least enough to satisfy the unimplemented parts
13:48:05 <eugenn> I know that probably no one did it, but could somethig like a 'vector space' type be defined?
13:48:07 <sproingie> they're unlike interfaces in that you can't use them directly as types
13:48:09 <monochrom> join is not mplus.
13:48:19 <ksf> monochrom, in a category of endofunctors?
13:48:21 <EnglishGent> is there any way of playing "what if" with :t? i.e. "if I gave this function a parameter of type T (I cant be bothered to implement one just to check..) what would the type be?
13:48:23 <koeien37> eugenn: this would b emore like a type class instead
13:48:40 <koeien37> EnglishGent: the magic of undefined
13:48:48 <koeien37> :t (+) (undefined::Double)
13:48:49 <lambdabot> Double -> Double
13:48:51 <monochrom> I see what you mean. Nevermind me.
13:48:52 <EnglishGent> I dont know that koeien
13:48:55 <EnglishGent> ah!
13:48:57 <EnglishGent> thanks :)
13:49:41 <sproingie> :t undefined
13:49:42 <lambdabot> forall a. a
13:50:12 <eugenn> GHC shows 'forall' like lambdabot? winhugs doesn't
13:50:22 <sproingie> it's a lambdabot thing
13:50:31 <Cale> It's a GHC thing.
13:50:43 <Cale> If you turn on some GHC extensions, it'll display the foralls.
13:50:44 <koeien37> lambdabot is built on GHC, i'd guess ;)
13:50:53 <monochrom> lambdabot exploits ghc's extensions. one extension displays explicit foralls.
13:51:13 <sproingie> ghci by default doesn't
13:51:43 <Geheimdienst> woah, i think i just understood what the difference is between "f :: Num -> Bla" and "f :: Num n => n -> Bla". on the left side of "=>" there's typeclasses, on the right side you have types. right?
13:51:53 <koeien37> correct.
13:51:54 <monochrom> Yes.
13:52:05 <koeien37> on the left you have "constraints", basically, which are in terms of typeclasses
13:52:18 <koeien37> and type variables
13:52:24 <eugenn> In my first class of functional paradigm, they told me haskell is hyper-mega-powerful. Now I know what they were talking about
13:52:44 <koeien37> eugenn: it's turing complete. but it's also very cool :)
13:52:59 <sproingie> the type system alone is turing complete
13:53:16 <koeien37> is it? H98?
13:53:23 <sproingie> i dunno about H98
13:53:24 <monochrom> The number system alone is Turing complete.
13:53:43 <koeien37> i'd guess you'd need at least UndecidableInstances
13:55:10 <h20xt> c++ did it first :P
13:57:46 <PeakerWork> I think you need UndecidableInstances for it to be TC, which wasn't there in H98
13:58:26 <Polarina> Why won't this compile? http://codepad.org/1JwjxpE9
13:58:59 <koeien37> Polarina: you use "read".
13:58:59 <ben0x539> Well, because you are using read on a think that you have not constrained to be in the Read typeclass
13:59:06 <Polarina> koeien37: And?
13:59:18 <koeien37> Polarina: but your type a is not necessarily an instance of  Read
13:59:28 <ben0x539> @type read
13:59:29 <lambdabot> forall a. (Read a) => String -> a
13:59:29 <Polarina> The Learn You A Haskell book uses read.
13:59:43 <koeien37> you can use it
13:59:48 <ben0x539> See the difference between that and your type?
13:59:56 <Polarina> ben0x539: No, I don't.
13:59:57 <koeien37> use rpn :: (Num a, Read a) => ... instead
14:00:22 <Polarina> koeien37: What does that do?
14:00:26 <ben0x539> read can only ever return a value of a type that is instance of the Read typeclass.
14:00:52 <koeien37> Polarina: it demands that a implements the type class Read. You need to have this, because you use "read" on the input.
14:00:52 <Polarina> ben0x539: Ok, thanks.
14:00:52 <ben0x539> So the function can only work if you tell the compiler to only spit out values that are in the Read typeclass
14:00:53 <Athas> Is there a filterM for Sets?  Should I just use Set.toList/Set.fromList?
14:01:11 <monochrom> You need "a" to be in typeclass Read for the "read" function.
14:01:20 <koeien37> Set.filter -- would be surprised if it didn't exist.
14:01:30 <ben0x539> Athas: Maybe you can use filter and then sequence
14:01:40 <ben0x539> Is that how it works? I forget.
14:01:41 <ben0x539> @src filterM
14:01:41 <lambdabot> Source not found.
14:01:50 <Athas> ben0x539: that's not a bad idea.
14:02:17 <ben0x539> Probably not.
14:02:18 <ben0x539> I am stupid. :<
14:03:23 <Athas> Well, actually, it won't work.
14:03:33 <halberd> it is possible, in a dependently typed language, to give the type of the best next move in a chess game (a move that results in victory in the smallest number of moves).  A theorem prover can then attempt to find a move that satisfies that type.  However, if you are interested only in a _good_ move within reasonable computation time, can you express that as a type?
14:03:33 <Athas> Damn, it was so elegant.  Curse you, reality!
14:04:33 <ben0x539> Maybe we can write Data.Set.notQuiteSequenceButStill
14:04:49 <sproingie> Data.Set.CloseEnoughForGovernmentWork
14:06:25 <koeien37> Polarina: also, you have a call to "main" at the end of your main function, but this is wrapped in forever. unnecessary
14:06:53 <Polarina> koeien37: Oh, I didn't notice. Thank you.
14:07:29 <Saizan> Athas: i'd go with fromAscList/toAscList , you shouldn't get anything asymptotically faster than that
14:07:32 <EnglishGent> Data.Set.SetOfAllSetsThatDontContainThemselves
14:07:48 <Saizan> s/get/be able to get/
14:07:50 <EnglishGent> (note :: with non-wellformendess - you can do that!) :)
14:09:13 <Geheimdienst> so, what's the easiest way to get a function to Show and Read? i have a data Foo = Foo { some stuff } deriving (Read, Show). now i want to add a (Bar -> Baz) to it, but ghc keeps yelling at me
14:09:23 <koeien37> you can't.
14:09:37 <koeien37> well, you could, but you don't want to, generally
14:10:12 <koeien37> and think about it, how would you show a function?
14:10:21 <holmak> you could write your own renderFoo function that shows the parts you want to see, and just use that
14:11:19 <Geheimdienst> well, i don't want to really show it. i just want to satisfy that deriving. as far as i'm concerned, empty string is fine, or "OMG LOLCATS" or something
14:11:26 <conal> Geheimdienst: there is a Show instance you can import for functions
14:11:35 <koeien37> yes. so give up on Read at least
14:11:41 <koeien37> you can do Show
14:12:03 <koeien37> > show id
14:12:04 <lambdabot>   "{()->()}"
14:12:11 <conal> :)
14:12:12 <holmak> Why do you need to satisfy Read and Show?
14:12:21 <conal> where'd that Show come from?
14:12:35 <koeien37> lambdabot's show? no idea. probably custom, like
14:12:41 <koeien37> > show (print 37)
14:12:42 <lambdabot>   "<IO ()>"
14:12:48 <conal> > show (id :: Bool -> Bool)
14:12:49 <lambdabot>   "{True->True;False->False}"
14:12:53 <holmak> fancy
14:12:57 <Geheimdienst> i really don't know :-) someone declared some superclass to be deriving (Show Read)
14:12:58 <conal> sweet!
14:13:05 <koeien37> ah no. cool
14:13:06 <Geheimdienst> this is the code i'm talking about: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Layout-Decoration.html
14:13:24 <conal> > show (id :: Integer -> Integer)
14:13:25 <lambdabot>   "{-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}"
14:13:27 <Geheimdienst> i'd like a function in the Theme
14:13:42 <conal> hm
14:13:46 <Saizan> holmak: not sure how you'd talk about computation time in types, but you could surely make up a metric such as number of some kind of steps in an algorithm and bound those
14:13:50 <koeien37> > show (id :: (Int->Int)->(Int->Int) )
14:13:51 <lambdabot>   "{-3->0;-2->-1;-1->-2;0->-3;1->-2;2->-1;3->0}->\n  {-3->0;-2->-1;-1->-2;0->...
14:14:00 <conal> wowzers
14:15:16 <Saizan> it's from SmallCheck
14:16:31 <conal> BTW, there's another way to "Show" functions, which is to change the result type of show to something more expressive than String, such as (interactive) GUIs.  that's the idea of tangible values.
14:17:27 <monochrom> That's a good TV show. <duck>
14:19:12 <holmak> monochrom++
14:19:17 <holmak> you deserve it, there
14:19:45 <monochrom> hehe
14:21:44 <GNU\colossus> hi all!
14:21:51 <GNU\colossus> how do I append a list to a list of lists?
14:21:52 <koeien37> hello
14:22:12 <koeien37> > [[1],[2,3]] ++ [[4,5,6]]
14:22:13 <lambdabot>   [[1],[2,3],[4,5,6]]
14:22:19 <Vulpyne> listoflists ++ [list]
14:22:28 <Vulpyne> Prepending would be more efficient if possible though.
14:22:30 <GNU\colossus> bummer. thanks.
14:22:42 <Vulpyne> list:listoflists in that case.
14:22:47 <koeien37> yes. if you do this repeatedly it might pay to add it in the front and then reverse.
14:22:55 <koeien37> (reverse once, that is)
14:23:18 <monochrom> generating is more efficient than appending or (prepending then reverse)
14:23:20 <Zariel> is there a way of doing, for(1 = 0; i < 5; i++){} apart from func [ 1 .. 5 ] ?
14:23:46 <Vulpyne> Zariel: Passing func the index of each?
14:23:50 <ben0x539> Use DList?
14:24:17 <holmak> @hoogle map
14:24:18 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
14:24:18 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
14:24:18 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
14:24:25 <monochrom> forM and forM_ with [0..4]
14:24:56 <monochrom> Example. forM_ [0..4] (\i -> print i)
14:25:00 <holmak> Zariel: what are you doing inside the loop?
14:25:14 <Zariel> creating a string to draw a square
14:25:29 <Vulpyne> Maybe map is what you want?
14:25:33 <holmak> If there is no IO, you can use map, probably
14:25:44 <holmak> check Hoogle
14:26:39 <monochrom> Try this example.  map (\i -> replicate i '*') [0..4]
14:26:52 <monochrom> > map (\i -> replicate i '*') [0..4]
14:26:52 <lambdabot>   ["","*","**","***","****"]
14:27:27 <monochrom> Perhaps this is better:
14:27:36 <monochrom> > map (\i -> replicate i '*' ++ "\n") [0..4]
14:27:37 <lambdabot>   ["\n","*\n","**\n","***\n","****\n"]
14:27:51 <monochrom> You can then concat to get one single string. It is a triangle.
14:28:02 <ddarius> > unlines $ map (flip replicate '*') [0..4]
14:28:03 <lambdabot>   "\n*\n**\n***\n****\n"
14:28:05 <conal> :i iterate
14:28:06 <Zariel> monochrom: thanks
14:28:10 <conal> :t iterate
14:28:11 <lambdabot> forall a. (a -> a) -> a -> [a]
14:28:29 <monochrom> Always think of generation, never appending.
14:28:44 <conal> iterate ('*':) "\n"
14:28:54 <conal> > iterate ('*':) "\n"
14:28:55 <lambdabot>   ["\n","*\n","**\n","***\n","****\n","*****\n","******\n","*******\n","*****...
14:30:48 <Geheimdienst> ok another newbie question: in a line like this, what does Read (ds a) mean?
14:30:53 <Geheimdienst> class (Read (ds a), Show (ds a), Eq a) => DecorationStyle ds a where
14:31:00 <Geheimdienst> is that short for Read ds, REad a?
14:31:04 <holmak> no
14:31:16 <holmak> ds is some kind of parameterized type
14:31:27 <holmak> think of "Read (Maybe Int)"
14:31:48 <Geheimdienst> oic
14:40:35 <Zariel> can i convert anything to a string?
14:41:17 <Raevel> Zariel: no, but if there is a Show instance for the type you can
14:41:22 <EnglishGent> um - that depends on what you mean by 'convert'
14:41:40 <Zariel> for instance, toString 1 -> "1"
14:41:46 <EnglishGent> yes - but not always in a reversable fashion
14:43:30 <skorpan> :t lex
14:43:31 <lambdabot> String -> [(String, String)]
14:43:33 <skorpan> wtf
14:43:36 <skorpan> @src lex
14:43:36 <lambdabot> Source not found.
14:43:44 <skorpan> O_o
14:44:00 <holmak> instance Show a where show _ = "<something!>"
14:44:02 <byorgey> > lex "hi there"
14:44:03 <lambdabot>   [("hi"," there")]
14:44:12 <byorgey> > lex "hi,there+"
14:44:13 <lambdabot>   [("hi",",there+")]
14:44:28 <holmak> @hoogle lex
14:44:28 <lambdabot> Prelude lex :: ReadS String
14:44:28 <lambdabot> Text.Read lex :: ReadS String
14:44:28 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
14:44:34 <skorpan> it's not immediately obvious to me what that does
14:44:43 <byorgey> > lex "+++f"
14:44:44 <lambdabot>   [("+++","f")]
14:44:47 <holmak> maybe grabbing GHC-tokens?
14:44:56 <watermind> is there any obvious reason why we cannot specify types in a module interface?
14:45:19 <watermind> and is this going to be the same in Haskell'
14:45:24 <ddarius> Because there is no "module interface"
14:45:34 <byorgey> watermind: I'm not sure what you mean
14:45:40 <byorgey> what is it you would like to be able to do?
14:45:43 <holmak> do you mean the export list?
14:45:52 <watermind> yes I mean the export list
14:46:02 <byorgey> you can list types in the export list.
14:46:21 <holmak> do you mean you can't put type signatures in the export list?
14:46:32 <EvanCarroll> how come foldr and foldl have different sub-type definitions
14:46:32 <watermind> byorgey: really? let me try again
14:46:40 <watermind> holmak: yes...
14:46:48 <watermind> holmak: at least it seemed to be the case
14:46:53 <ddarius> watermind: Why would you want to?
14:46:59 <watermind> wonder if I messed up somewhere
14:47:06 <holmak> you can export types, but you can't specify type signatures for things in the export list
14:47:15 <holmak> type signatures go in the body...
14:47:26 <EvanCarroll> @src foldr
14:47:26 <lambdabot> foldr f z []     = z
14:47:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:47:41 <watermind> ddarius: I want to specify the types of functions when I export them
14:48:02 <watermind> holmak: I know they go in the body and that it would be redundant
14:48:06 <holmak> watermind: You can, and should, specify function types just above the function
14:48:08 <byorgey> watermind: for what purpose?
14:48:22 <ddarius> watermind: You can put type signatures anywhere.  If you want, you can have all the type signatures at the top.
14:48:29 <watermind> holmak: but if it were optional it wouldn't hurt anybody
14:48:54 <watermind> ddarius: well I like my types right above my functions
14:48:58 <holmak> i don't understand -- if what was optional?
14:49:06 <watermind> ddarius: but I'd also like to specify them in the export list
14:49:21 <holmak> why?
14:49:35 <byorgey> watermind: ok, well, the answer is "unfortunately, you can't" =)
14:50:06 <byorgey> although I am still curious why you would want to do such a thing.
14:50:06 <holmak> the type of a function exports along with the function itself, you can't separate the two
14:50:10 <byorgey> is it just for documentation purposes?
14:50:11 <watermind> holmak: well in many cases you also don't need to specify types of your functions at all
14:50:15 <watermind> holmak: in ML you don't
14:50:25 <byorgey> if so, why not put the type in a comment next to the exported thing?
14:50:30 <watermind> holmak: and you can just explicitly state them in your expressions if you want
14:50:56 <byorgey> module Foo where ( foo -- :: X -> Bar    ... and so on
14:50:57 <watermind> holmak: but still in Haskell we can specify a type signature even though it is redundant
14:51:03 <watermind> so same thing really
14:51:19 <byorgey> watermind: right, but export lists are not expressions.
14:51:28 <holmak> yeah certainly, i just don't see wh you want to put it in the export list instead of by the definition
14:51:29 <byorgey> at least, not in Haskell
14:51:48 <ddarius> Specifying the type signature is not redundant, but specifying it twice certainly would be.
14:52:04 <ddarius> Haskell having separate interface files, like the MLs would be a good thing though.
14:52:17 <watermind> ddarius: it is redundant if you can put type annotations in expressions to resolve ambiguities
14:53:05 <jkramer> Ahoy
14:53:10 <watermind> and it seems that in practice lots of people do put the types in the export list
14:53:13 <watermind> as comments
14:53:28 <watermind> just like lots of people write type signatures in ML
14:53:31 <watermind> ... as comments
14:53:41 <jkramer> I'm trying to build a port of the binary GHC package for CRUX Linux, but it looks like the Makefile is missing a working DESTDIR parameter
14:53:51 <watermind> so why not allow to really specify them and let the compiler check for consistency
14:54:07 <jkramer> Does anyone know how can install into a sandbox?
14:54:11 <jkramer> *I
14:55:05 <holmak> watermind: Sorry, can you restate that last comment, I didn't follow
14:56:18 <watermind> holmak: was saying that in many files I've seen, people do write the signatures of the functions in the export list as comments... just like many people write type signatures fore ML functions as comments
14:57:53 <holmak> Could be, I've never used ML though
14:58:17 <MakoryuOnIce> Hey, what's the name of the <*> operator?
14:58:47 <holmak> ap, i think?
14:58:51 <holmak> @hoogle ap
14:58:51 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
14:58:51 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
14:58:51 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
14:58:56 <skorpan> i call it "the sequencing operator"
14:58:58 <Vulpyne> :t (<*>)
14:58:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:59:05 <Vulpyne> :t ap
14:59:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:59:27 <h20xt> <*> = ap for all Monads
14:59:55 <idnar> it's just a shibboleth to me, either way
15:00:08 <idnar> wait, that's not the word I want
15:00:09 <idnar> oh well
15:00:09 <qiemem> Hi all. I'm trying to represent a quadtree of a grid. I need to use a function that, when given the quadtree of a 2^n x 2^n grid, will return a quadtree of the center 2^{n-1} x 2^{n-1} grid. However, such a function doesn't make sense on a 2x2 or 1x1(leaf) grid. So, I'd like my types to represent this difference between quadtrees (it would be simple to return some sort of Empty tree, or use Maybe, but I'd like to do this properly). Ho
15:00:10 <qiemem> I go about representing my quadtrees?
15:00:15 <MakoryuOnIce> Also, what's this about ML?
15:01:24 <holmak> I guess watermind was contrasting type signature-specifying practice between ML and Haskell
15:01:53 <MakoryuOnIce> Hmm, is it all that different?
15:02:00 <tensorpudding> ML uses the same type-inference system that Haskell does right?
15:02:06 <holmak> Beats me, I don't know ML
15:02:13 <tensorpudding> Hindley-Milner or whatever
15:02:18 <h20xt> F# takes a lot from ML
15:02:18 <MakoryuOnIce> tensorpudding: More or less, yeah.
15:02:21 <holmak> He was saying something about specifying types in the export list?
15:02:37 <skorpan> any ideas on how to make this cuter? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13055#a13055
15:02:49 <tensorpudding> I thought F# was basically OCaml with .NET
15:03:16 <Apocalisp> more or less
15:03:34 <jmelesky> tensorpudding: it's in the ML family, but it's not ocaml
15:04:44 <MakoryuOnIce> tensorpudding: ML lacks typeclasses, so IIRC you have to explicitly "import" members of its modules... I never quite understood how it works, but I know it has implications for type inference
15:05:37 <Apocalisp> skorpan: getSate >>= foldr (uncurry fst) 0
15:05:46 <MakoryuOnIce> The biggest implication (I think) is that ML's type system prohibits undecidable types altogether
15:07:04 <doserj> skorpan: getState >>= head . (++ [0])
15:07:28 <Apocalisp> wait, uncurry fst == const
15:07:54 <MakoryuOnIce> > curry const
15:07:55 <lambdabot>   {()->{()->{()->((),())}}}
15:08:05 <skorpan> O_o
15:08:22 <MakoryuOnIce> :t curry
15:08:22 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:08:23 <holmak> skorpan: getState >>= (return . fromMaybe 0 . listToMaybe), I think?
15:08:57 <MakoryuOnIce> Apocalisp: U MENA curry fst? :p
15:09:02 <MakoryuOnIce> :t curry fst
15:09:03 <lambdabot> forall a b. a -> b -> a
15:09:09 <Apocalisp> duh
15:09:14 <Apocalisp> yeah, that
15:09:21 <idnar> @type curry const
15:09:21 <lambdabot> forall a b b1. a -> b -> b1 -> (a, b)
15:09:25 <idnar> @type curry fst
15:09:26 <lambdabot> forall a b. a -> b -> a
15:09:43 <idnar> > curry fst
15:09:44 <lambdabot>   {()->{()->()}}
15:09:52 <idnar> heh, that's spectacularly useless
15:10:01 <idnar> > curry fst :: Integer -> Integer -> Integer
15:10:02 <lambdabot>   -3->
15:10:02 <lambdabot>    {-3->-3;-2->-3;-1->-3;0->-3;1->-3;2->-3;3->-3}
15:10:02 <lambdabot>  -2->
15:10:02 <lambdabot>    {-3->-2;-2-...
15:10:14 <idnar> > curry fst :: Integer -> () -> Integer
15:10:15 <lambdabot>   -3->
15:10:15 <lambdabot>    {()->-3}
15:10:15 <lambdabot>  -2->
15:10:15 <lambdabot>    {()->-2}
15:10:15 <lambdabot>  -1->
15:10:17 <lambdabot> [5 @more lines]
15:10:25 <MakoryuOnIce> > curry fst :: Ordering -> Ordering -> Ordering
15:10:26 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
15:10:26 <lambdabot>    arising f...
15:10:31 <MakoryuOnIce> -_-
15:10:38 <idnar> > curry fst :: Boolean -> () -> Boolean
15:10:39 <lambdabot>   Not in scope: type constructor or class `Boolean'Not in scope: type constru...
15:10:48 <idnar> > curry fst :: Bool -> () -> Bool
15:10:49 <lambdabot>   {True->{()->True};False->{()->False}}
15:10:55 <Apocalisp> getSate >>= (liftM2 foldr (. const) ($ 0)) return
15:11:12 <Zariel> hwo can i create a function which takes arguments which can be operated on by (==) ?
15:11:24 <idnar> @type \x y -> x == y
15:11:25 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:11:40 <ben0x539> Does ghc do unicode literals
15:11:44 <idnar> or rather
15:11:47 <idnar> @type (==)
15:11:48 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:11:59 <monochrom> > '\u0020'
15:12:00 <lambdabot>   <no location info>:
15:12:00 <lambdabot>      lexical error in string/character literal at chara...
15:12:04 <watermind> MakoryuOnIce: it's different in the sense that in ML, from what I've seen, you don't specify type signatures at all... at most you annotate expressions with types
15:12:06 <ben0x539> guess not
15:12:08 <MakoryuOnIce> ben0x539: Yep. Careful using them with the default IO library, though
15:12:14 <idnar> Zariel: ^^^ in other words, you need an (Eq a) constraint on the types you want to compare
15:12:22 <Zariel> ah right
15:12:23 <MakoryuOnIce> watermind: Ah, I see
15:12:27 <idnar> the types of the arguments you want to compare, I mean
15:12:29 <eugenn> @type Eq
15:12:30 <lambdabot> Not in scope: data constructor `Eq'
15:12:33 <monochrom> > \u0020
15:12:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:12:35 <idnar> @kind Eq
15:12:36 <lambdabot> Class `Eq' used as a type
15:12:41 <idnar> oh, heh
15:12:44 <watermind> MakoryuOnIce: so in ML programms often people do write type signatures but just as comments
15:12:49 <idnar> anyway, it's a type class
15:13:06 <MakoryuOnIce> watermind: So you'd write "let map (f : 'a -> 'b) (x :: xs) = ..."
15:13:06 <MakoryuOnIce> watermind: O_o
15:13:08 <monochrom> ok, it has to be hex.
15:13:13 <monochrom> > '\x0020'
15:13:14 <lambdabot>   ' '
15:13:16 <watermind> MakoryuOnIce: and I was contrasting that with what happens with haskell's modules export lists
15:13:31 <idnar> ???
15:13:36 <ben0x539> Oh, oka
15:13:37 <ben0x539> y
15:13:40 <Apocalisp> foldr (return . const) (return 0) =<< getState
15:13:43 <idnar> > '\x20aoeu'
15:13:44 <lambdabot>   <no location info>:
15:13:44 <lambdabot>      lexical error in string/character literal at chara...
15:13:46 <idnar> oh okay
15:13:55 <watermind> MakoryuOnIce: where you cannot specify the type of the functions being exported (because it would be redundant I guess) but everyone writes them as comments anyway
15:14:00 <WheelJack> Hello, I need a Help
15:14:05 <idnar> for some reason, I thought \xnn worked
15:14:14 <WheelJack> I would like to know if someone her speak spanish
15:14:23 <monochrom> ' is not "
15:14:23 <WheelJack> here
15:14:35 <idnar> > "\x20aoeu"
15:14:36 <lambdabot>   "\522oeu"
15:14:39 <idnar> that's even worse :(
15:14:43 <skorpan> given a list, e.g. [5,3,2,5,4] i want to "take while the next element is LEQ to the current one", what's the best way?
15:14:44 <idnar> > "\u0020aoeu"
15:14:45 <lambdabot>   <no location info>:
15:14:45 <lambdabot>      lexical error in string/character literal at chara...
15:14:46 <medfly> WheelJack, a simple approach is: "I have code <link to paste of Haskell code>, how do I fix it?"
15:14:56 <watermind> MakoryuOnIce: just like in haskell you can write a map definition without any type signature or annotation and get the expected result
15:14:58 <idnar> > "\x0020aoeu"
15:14:59 <lambdabot>   "\522oeu"
15:14:59 <skorpan> so myFun [5,3,2,5,4] --> [5,3,2]
15:15:07 <Zariel> idnar: can i do that without defining the class a ?
15:15:12 <tessier> I can see that I am going to have to remove AoE from my list of irssi keywords to hilight.
15:15:20 * idnar scratches his head
15:15:27 <idnar> > "\x20aaaa"
15:15:27 <lambdabot>   <no location info>:
15:15:28 <lambdabot>      lexical error in string/character literal at chara...
15:15:28 <ben0x539> dvorak?
15:15:38 <WheelJack> I can send a file
15:15:42 <WheelJack> to be checked
15:15:44 <WheelJack> because
15:15:45 <idnar> okay, I don't even know how that works
15:15:48 <idnar> Zariel: I'm not sure exactly what you mean
15:15:49 <medfly> WheelJack, http://hpaste.org
15:15:54 <ben0x539> > "\x20aa\&a"
15:15:54 <WheelJack> i suppose is fine
15:15:55 <lambdabot>   "\8362a"
15:16:09 <skorpan> :t ma
15:16:10 <skorpan> :t max
15:16:10 <lambdabot> Not in scope: `ma'
15:16:11 <lambdabot> forall a. (Ord a) => a -> a -> a
15:16:34 <WheelJack> i have a misstake
15:16:43 <sproingie> fg
15:16:49 <Zariel> idnar: Define a polymorphic function split that is applied to two arguments of types [a] and a, where a is a type on which == is defined
15:16:51 <Zariel> pretty much
15:16:53 <WheelJack> I couldn't compiled
15:16:54 <sproingie> argh.  i gotta fix that splitscreen
15:16:58 <idnar> Zariel: a isn't a class, it's just a type variable
15:17:00 <Zariel> i guess im going to have to do class Eq a where
15:17:18 <idnar> Zariel: so, (Eq a) => [a] -> a -> Integer
15:17:22 <monochrom> idnar: maximal munch. "\x20aezzz" is ['\x20ae', 'z', 'z', 'z']
15:17:25 <watermind> WheelJack: yo no ablo español :S
15:17:32 <watermind> WheelJack: es mui complicado
15:17:36 <idnar> the Eq class is defined in the prelude, you wouldn't usually be defining it yourself
15:17:41 <idnar> monochrom: yeah, that's just awful :P
15:17:44 <idnar> but okay
15:17:44 <WheelJack> Watermind
15:17:45 <Zariel> idnar: ah i see
15:17:50 <WheelJack> could you help me
15:17:54 <WheelJack> with this
15:18:05 <Vulpyne> WheelJack: You need to describe your problem.
15:18:14 <WheelJack> this is right
15:18:17 <monochrom> Now try this:
15:18:22 <watermind> WheelJack: pero lo invento mui bien
15:18:24 <monochrom> > "\x20\&aezzz"
15:18:25 <lambdabot>   " aezzz"
15:18:27 <WheelJack> 	esUp :: Char -> Bool
15:18:29 <WheelJack> 	esUp a
15:18:29 <idnar> Zariel: you can often figure this sort of thing out with ghci just by leaving off the type signature, and asking ghci what the type it inferred is
15:18:31 <WheelJack> 				| ord a >= 65 && ord a <=90 = True
15:18:33 <WheelJack> 				| otherwise    = False
15:18:46 <idnar> (ie. leave the type signature off, load the code up in ghci, and do :t yourFunction)
15:18:47 <monochrom> Use \& to disrupte maximal munch.
15:18:52 <MakoryuOnIce> > ord '\&'
15:18:53 <lambdabot>   <no location info>:
15:18:54 <lambdabot>      lexical error in string/character literal at end o...
15:18:55 <medfly> ASCII?
15:19:00 <idnar> > "\&"
15:19:01 <lambdabot>   ""
15:19:04 <skorpan> i accidentally wrote a list reversing function...
15:19:13 <WheelJack> I need difference a of A
15:19:14 <koeien37> skorpan: hehe
15:19:15 <idnar> > length "\&"
15:19:16 <lambdabot>   0
15:19:19 <idnar> man
15:19:27 <Vulpyne> > ord 'a' - ord 'A'
15:19:28 <lambdabot>   32
15:19:31 <WheelJack> if I introduce A the program tell me True
15:19:33 <idnar> I think I prefer Python's take on that
15:19:35 <WheelJack> otherwise
15:19:36 <WheelJack> false
15:19:41 <ben0x539> > cycle "\&"
15:19:42 <lambdabot>   "* Exception: Prelude.cycle: empty list
15:19:46 <monochrom> \& is haskell special provision for empty string for disrupting maximal munch in \x111 \o111 etc.  Not an escape code for a valid Char.
15:20:00 <medfly> @hoogle ord
15:20:00 <lambdabot> Data.Char ord :: Char -> Int
15:20:01 <lambdabot> module Data.Ord
15:20:01 <lambdabot> Prelude class Eq a => Ord a
15:20:09 <Vulpyne> I have no idea of what you just said, but maximal munch sounds hilarious.
15:20:11 <idnar> Python has "\x12" "\u1234" "\U12345678" with the number of digits in each form being fixed
15:20:20 <idnar> Vulpyne: OM NOM NOM NOM
15:20:27 <koeien37> i want multiline strings :(
15:20:29 * monochrom is likely the only one in the world who reads the standard for this.
15:20:32 <watermind> monochrom: I usually understand what people say in this channel and you totally lost me :P
15:20:41 <medfly> WheelJack, maybe you need module Data.Char
15:20:48 <medfly> er
15:20:52 <medfly> yeah :)
15:20:56 <skorpan> given a list, e.g. [5,3,2,5,4] i want to "take while the next element is less than or equal to the current one". what's the best way? (i'm spamming, yes.)
15:21:00 <WheelJack> some one has msn messenger
15:21:25 <MakoryuOnIce> koeien37: I'm curious myself as to why we don't have them
15:21:30 <aavogt> skorpan: can be done with group
15:21:32 <Vulpyne> skorpan: What would you do for the first and last elements?
15:21:32 <ddarius> monochrom: Nope.
15:21:43 <skorpan> Vulpyne: that's the big problem :)
15:21:44 <watermind> WheelJack: I don't think you'll get anyone's msn unless you're female and exceptionally attractive
15:21:56 <aavogt> > groupBy (>) [5,6,2,3,4]
15:21:57 <lambdabot>   [[5],[6,2,3,4]]
15:22:00 <idnar> @type uncurry (<=)
15:22:00 <lambdabot> forall a. (Ord a) => (a, a) -> Bool
15:22:02 <aavogt> > groupBy (<) [5,6,2,3,4]
15:22:03 <lambdabot>   [[5,6],[2,3,4]]
15:22:04 <monochrom> watermind: It is because there is nothing to understand. Just citing rules. Like when people cite a Chess rule "rooks must not go diagonally" there is nothing to understand.
15:22:12 <idnar> oh, groupBy, of course
15:22:17 <skorpan> aavogt: this is madness!
15:22:20 <MakoryuOnIce> > read "\"This is a\\\n--Whoops\n\\ multiline string\"" :: String
15:22:20 <WheelJack> any one knows the channel in spanish
15:22:20 <lambdabot>   "* Exception: Prelude.read: no parse
15:22:47 <WheelJack> I would like speak with some one that could check all my code
15:22:48 <koeien37> WheelJack: it probably exists, but there might not be a lot of activity (I know that the dutch channel is very silent.)
15:22:53 <Vulpyne> WheelJack: Sorry, I don't think there is one.
15:22:54 <watermind> monochrom: except for  "munch" ,  "\x111" and  "\o111" :)
15:22:56 <WheelJack> and could help me
15:23:00 <skorpan> this is HASKELLLLLL
15:23:03 <mike8901> Is HUnit the best framework to write Haskell unit tests in?
15:23:11 <idnar> > let xs = [5,6,2,3,4] in fst . takeWhile (uncurry (<=)) $ zip xs (tail xs)
15:23:12 <lambdabot>   Couldn't match expected type `(a, b)'
15:23:12 <lambdabot>         against inferred type `[(a1, ...
15:23:21 <Vulpyne> WheelJack: Maybe this will help you: http://haskell.org/haskellwiki/Haskell.es
15:23:32 <MakoryuOnIce> mike8901: From what I've heard, QuickCheck is where it's at
15:23:35 <Vulpyne> Actually, #haskell.es
15:23:36 <mike8901> hm ok
15:23:37 <doserj> skorpan: groupBy always compares with the first element, though
15:23:44 <idnar> > let xs = [5,6,2,3,4] in takeWhile (uncurry (<=)) $ zip xs (tail xs)
15:23:45 <lambdabot>   [(5,6)]
15:23:57 <monochrom> OK but that's exactly like an audience who hasn't seen "rook".
15:23:58 <skorpan> doserj: that's fine
15:24:18 <idnar> hah, my horribly complicated version didn't even work
15:24:19 <doserj> > head $ groupBy (<) [5,7,6,3] -- is that what you want?
15:24:20 <lambdabot>   [5,7,6]
15:24:32 <skorpan> hm... no.
15:24:38 <WheelJack> Thanks Vulpyne
15:24:49 <sm> http://www.starling-software.com/en/blog/my-beautiful-code/2009/11/22.the-go-language.html , interesting
15:25:03 <centrinia> > init . head . groupBy (<=) $ [5,7,6,3]
15:25:04 <lambdabot>   [5,7]
15:25:10 <centrinia> What about that?
15:25:16 <mike8901> hmm, so does QuickCheck allow me to specify explicit tests? I'm testing an interpreter, so there's not really a good way to "automagically" generate tests..
15:25:19 <centrinia> > init . head . groupBy (<=) $ [1]
15:25:20 <lambdabot>   []
15:25:23 <centrinia> > init . head . groupBy (<=) $ []
15:25:24 <lambdabot>   * Exception: Prelude.head: empty list
15:25:38 * sm ponders how haskell's typeclasses are hierarchical
15:25:40 <WheelJack> One question, is possible combine math instruction with char instructions
15:25:41 <centrinia> > init . head . groupBy (<=) $ [10,9..1]
15:25:42 <lambdabot>   []
15:25:52 <skorpan> > init . head . groupBy (>) $ [10..1]
15:25:53 <lambdabot>   * Exception: Prelude.head: empty list
15:25:58 <skorpan> > init . head . groupBy (<=) $ [10..1]
15:25:59 <lambdabot>   * Exception: Prelude.head: empty list
15:26:09 <doserj> > init . head . groupBy (<=) $ [5,7,6,7,6,6,6,3,2]
15:26:10 <lambdabot>   [5,7,6,7,6,6]
15:26:11 <idnar> > groupBy (<=) $ [5,7,6,3]
15:26:12 <lambdabot>   [[5,7,6],[3]]
15:26:19 <monochrom> haskell typeclasses are a DAG. You are allowed diamonds and more.
15:26:32 <skorpan> a dag?
15:26:35 <skorpan> you mean dog
15:26:38 <holmak> @src num
15:26:38 <lambdabot> Source not found. That's something I cannot allow to happen.
15:26:40 <idnar> > init . head . groupBy (<=) $ [2,7,6,5,3]
15:26:41 <Vulpyne> WheelJack: You can convert a Char to Int using fromIntegral
15:26:41 <lambdabot>   [2,7,6,5]
15:26:42 <holmak> @src Num
15:26:43 <lambdabot> class  (Eq a, Show a) => Num a  where
15:26:43 <lambdabot>     (+), (-), (*)           :: a -> a -> a
15:26:43 <lambdabot>     negate, abs, signum     :: a -> a
15:26:43 <lambdabot>     fromInteger             :: Integer -> a
15:26:43 <monochrom> I mean deg
15:26:48 <idnar> I'm pretty sure that's not right
15:26:54 <holmak> Num is a subclass of Eq and Show!
15:27:26 <idnar> > let xs = [2,3,4,5,4,3,2] in takeWhile (uncurry (<=)) $ zip xs (tail xs)
15:27:27 <lambdabot>   [(2,3),(3,4),(4,5)]
15:27:29 <idnar> hmm
15:27:32 <tavelram> so, Im doing some computing on a group Z*_23, using Integers, which involves a few "(a*b) `mod` 23", and some "(a^b) `mod` 23" as well. Is there a neat way to overload just * and ^ in a neat way? or what would you suggest as a new operator to use instead? .*. and .^.?
15:27:42 <Milo-> list comprehension is fun, but I still don't understand Monads and Just/Maybe
15:27:43 <koeien37> tavelram: use a newtype
15:27:58 <tavelram> but I dont want to use alot of constructors all the time =/
15:27:59 <koeien37> tavelram: newtype GF23 = GF23 Int, then instance Num GF23 where ...
15:28:19 <koeien37> shouldn't be too bad due to overloading of numbers
15:28:38 <koeien37> otherwise, yeah, something like (.*.) and (.^.)
15:28:40 <idnar> > let xs = [2,3,4,5,4,3,2] in map fst . takeWhile (uncurry (<=)) $ zip xs (tail xs)
15:28:41 <lambdabot>   [2,3,4]
15:28:47 <idnar> that's almost right, but it loses an element :/
15:28:54 <tavelram> koeien, yeah, any suggestions other than ..?
15:29:14 <skorpan> idnar: note that i want to take while "descending"
15:29:32 <skorpan> not that it changes the problem in any way
15:29:34 <idnar> skorpan: oh, inverted the condition when I read it
15:29:42 <monochrom> [ x+2 | s<-hello, x<-s ] = do { s<-hello; x<-s; return (x+2) }  is one way to learn monads based on knowing already list comprehension.
15:29:46 <idnar> > let xs = [5,4,3,2,3,4,5] in map fst . takeWhile (uncurry (>=)) $ zip xs (tail xs)
15:29:47 <lambdabot>   [5,4,3]
15:29:48 <koeien37> tavelram: why is the newtype solution so bad?
15:29:52 <idnar> > let xs = [5,4,3,2,2,3,4,5] in map fst . takeWhile (uncurry (>=)) $ zip xs (tail xs)
15:29:54 <lambdabot>   [5,4,3,2]
15:29:58 <watermind> monochrom: when you say "diamonds and more" do you have anything particulary interesting in mind for the "and more bit" or just diamond like generalizations if that maes sense?
15:30:00 <idnar> but, yeah, I can't figure out how to not "lose" an element
15:30:15 <skorpan> > fst (foldl (\(h,t) s -> if s < h then (s,h:t) else (0,h:t))) $ [5,4,3,2,5,6]]
15:30:16 <koeien37> tavelram: you can still write down "21" to mean GF23 21.
15:30:16 <lambdabot>   <no location info>: parse error on input `]'
15:30:17 <skorpan> > fst (foldl (\(h,t) s -> if s < h then (s,h:t) else (0,h:t))) $ [5,4,3,2,5,6]
15:30:18 <idnar> I need to invert "zip xs (tail xs)"
15:30:18 <lambdabot>   Couldn't match expected type `(a, b)'
15:30:18 <lambdabot>         against inferred type `(b1, [...
15:30:24 <idnar> oh!
15:30:24 <monochrom> We can do a pentagon too.
15:30:28 <tavelram> koeien37, oh really?
15:30:29 <Milo-> monochrom do you mind explaining that slightly?
15:30:35 <idnar> > let xs = [5,4,3,2,2,3,4,5] in (head xs) : map snd . takeWhile (uncurry (>=)) $ zip xs (tail xs)
15:30:35 <koeien37> tavelram: yes! look:
15:30:36 <lambdabot>   Couldn't match expected type `[[(a, b)]]'
15:30:36 <lambdabot>         against inferred type `[(...
15:30:37 <koeien37> :t 3
15:30:38 <lambdabot> forall t. (Num t) => t
15:30:42 <idnar> > let xs = [5,4,3,2,2,3,4,5] in (head xs) : (map snd . takeWhile (uncurry (>=)) $ zip xs (tail xs))
15:30:43 <lambdabot>   [5,4,3,2,2]
15:30:49 <idnar> > let xs = [5,6,7] in (head xs) : (map snd . takeWhile (uncurry (>=)) $ zip xs (tail xs))
15:30:50 <lambdabot>   [5]
15:30:51 <koeien37> 3 is actually transformed into fromInteger 3
15:31:00 <tavelram> oh cool :)
15:31:00 <idnar> skorpan: how's that?
15:31:11 <koeien37> so if you implement fromInteger, you can use this
15:31:14 <monochrom> > [x+2 | x<-[3,1,4]] == do {x<-[3,1,4]; return (x+2)}
15:31:15 <lambdabot>   True
15:31:16 <skorpan> > let xs = [5,4,3,2,8,9,3,2,1] in (head xs) : (map snd . takeWhile (uncurry (>=)) $ zip xs (tail xs))
15:31:17 <watermind> Milo-: Maybe is the easiest monad, if you think of monads as encapsulating computations
15:31:17 <lambdabot>   [5,4,3,2]
15:31:17 <koeien37> so 3 :: GF23 will be well-typed and will mean fromInteger 3 :: GF23
15:31:25 <skorpan> > let xs = [] in (head xs) : (map snd . takeWhile (uncurry (>=)) $ zip xs (tail xs))
15:31:26 <lambdabot>   [* Exception: Prelude.head: empty list
15:31:31 <skorpan> i guess i can live with that
15:31:35 <skorpan> :) thanks
15:31:40 <idnar> descending [] = [] :P
15:31:43 <watermind> Milo-: return  will encapsulate a value a as Just a
15:31:46 <Milo-> watermind the do part was comparament to some other language?
15:31:53 <monochrom> > do {x<-[3,1,4]; return (x+2)} == [3,1,4] >>= \x -> return (x+2)
15:31:54 <lambdabot>   Couldn't match expected type `m a'
15:31:54 <lambdabot>         against inferred type `GHC.Bool....
15:31:54 <Milo-> or was it actually working syntax?
15:32:05 <monochrom> > do {x<-[3,1,4]; return (x+2)} == ([3,1,4] >>= \x -> return (x+2))
15:32:05 <watermind> Milo-: and >>= extracts the encapsulated value if it exists
15:32:06 <lambdabot>   True
15:32:41 <watermind> Milo-: nothing... do is very much specific to haskell... and I dislike using new notation to teach Monads because it seems like magic
15:32:43 <doserj> > let f p [] = [] ; f p [x] = [x] ; f p (x:y:xs) = if p x y then x:f p (y:xs) else [x] in f (>=) [5,4,3,4,5] -- boring, but works...
15:32:44 <lambdabot>   [5,4,3]
15:32:57 <monochrom> OK I'll try sticking with >>=
15:33:13 <watermind> monochrom: to be honest I even prefer mu :S
15:33:22 <koeien37> mu as join?
15:33:27 <watermind> monochrom: I think join is much easier to understand than >>=
15:33:30 <watermind> koeien37: yes
15:33:44 <koeien37> watermind: yeah, but then you'll have to understand >>= in terms of join. not *too* bad of course
15:33:52 <koeien37> for some monads, like Maybe, join might be easier
15:33:53 <watermind> koeien37: true
15:34:03 <koeien37> or []
15:34:06 <watermind> koeien37: and for lists is also very easy
15:34:06 <Milo-> monochrom am I mistaken, or does that compare the two given lists to each other?
15:34:33 <watermind> koeien37: and those are pretty much the most simple monads
15:34:35 <monochrom> Yes compare. They are the same. Anecdotal evidence. :)
15:35:04 <koeien37> watermind: but for, e.g., parsers or IO, i think that >>= is more intuitive. at least it was for me. Not that i would start monads w/IO
15:35:15 <monochrom> join is easier to understand for those who understand join. >>= is easier for those who understand >>=
15:35:27 <koeien37> yeah, this is hindsight of course ;)
15:35:28 <ivanm> monochrom: wow, what a profound comment...
15:35:42 <monochrom> No, not intended to be profound.
15:35:48 <koeien37> anyway, i will shut up for a few hours! good night
15:35:49 <idnar> I find join easier to understand for some monads, and >>= easier to understand for other monads
15:36:03 <watermind> monochrom: I understand both and I learn >>= first :S I still think join is easier
15:36:11 <watermind> *learned
15:36:47 <watermind> koeien37: and yes you have a point with IO and parsing... although join is quite intuitive with IO too
15:36:49 <Milo-> strong C background makes me not want to touch '>>=' for some reason :P
15:36:50 <idnar> also, I like =<< more than >>=
15:37:01 <idnar> @type (=<<)
15:37:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:37:06 <doserj> for the 'monads as containers' intuition, join is easy to understand. For the 'monads as computations/actions' intuition, >>= may be easier to understand.
15:37:16 <monochrom> Here is the profound part. The best strategy to teach monads is to toss a coin, if it's head tell the join story, if it's tail tell the >>= story.
15:37:26 <Milo-> heh
15:37:46 <idnar> monochrom: do we toss the coin in the quantum nondeterminism monad?
15:38:02 <idnar> schroedinger's monad tutorial!
15:38:02 <monochrom> (That is, until one day we have the technology to just cut open the audience's brain to find which story suits it.)
15:38:35 <idnar> I am now picturing monochrom as Sylar from `Heroes`
15:39:57 <monochrom> join is best for drawing a very pleasant commuting diagram.
15:40:40 <Milo-> http://book.realworldhaskell.org/read/monads.html#id638573 that's not a pretty 'first sight'
15:41:48 <monochrom> Yes, >>= nicely refactors that and cuts down size by half (because >>= already captures the other, repetitive half)
15:42:44 <tavelram> koeien, but since Im using mod, I need to overload Integral as well?
15:42:52 <Milo-> I see, Monads aren't really testable in ghci
15:43:50 <monochrom> Oh you can test.
15:44:04 <monochrom> > ([3,1,4] >>= \x -> return (x+2))
15:44:05 <lambdabot>   [5,3,6]
15:44:10 <Milo-> that I did test
15:44:10 <Gracenotes> bracketed dos are nice, too
15:44:11 <monochrom> works
15:44:37 <Gracenotes> you can do 'foo <- bar'. if bar is Show a => IO a. :X
15:44:44 <monochrom> OK of course you can't test very general things. You have to, for example, pick a particular monad, e.g., you have to use list, or you have to use Maybe, etc.
15:51:58 <Milo-> hmm where did I put the list of all 'known' operators and their descriptions
15:52:33 * monochrom offers again to cut open your brain to find it for you :)
15:52:36 <Milo-> well, got to google later.
15:52:42 <Milo-> time to sleep
15:53:43 <Milo-> that worked out better than expected, just wrote 'haskell operators' to firefox's url bar and some random pdf opened with a nice list.
15:54:06 <monochrom> (Google in Australia had an April Fool joke of making an iPhone app that can scan your brain to recall e.g. you meet a person you met sometime ago but what's his/her name again?)
15:57:30 <Liskni_si> monochrom: what did it do?
15:58:24 <monochrom> I thought I just said what it did.
15:59:26 <Liskni_si> how did it do that?
16:00:08 <monochrom> I would not know. It's an April Fool joke.
16:04:30 <roconnor> @djinn (a -> (b -> c, c -> b), (b -> c,c -> b) -> a) -> ((a -> b,b -> a) -> c, c -> (a -> b,b -> a))
16:04:31 <lambdabot> -- f cannot be realized.
16:05:11 <copumpkin> roconnor: oh my
16:09:35 <roconnor> copumpkin: Apparenlty <-> isn't associative.
16:10:53 <Saizan> ?djinn-add type Iff a b = (a -> b , b <- a)
16:10:54 <lambdabot> Cannot parse command
16:11:15 <Axman6> <-?
16:11:23 <Saizan> hah
16:11:30 <Saizan> ?djinn-add type Iff a b = (a -> b , b -> a)
16:12:00 <Saizan> ?djinn Iff (Iff a b) c -> Iff a (Iff b c)
16:12:15 <Axman6> @djinn Iff a b -> Iff b a
16:12:15 <lambdabot> No output from Djinn; installed?
16:12:16 <lambdabot> f (a, b) = (b, a)
16:12:31 <Saizan> i made djinn loop?
16:12:38 <Axman6> seems so
16:13:04 <Saizan> ?djinn Iff a (Iff b c) -> Iff (Iff a b) c
16:13:05 <lambdabot> -- f cannot be realized.
16:20:23 <ben0x539> someone come up with a lambdacats-ish caption for http://www.zooborns.com/.a/6a010535647bf3970b0120a617376a970b-800wi
16:22:43 <sproingie> ben0x539: liftMeow
16:22:59 <ben0x539> hah
16:23:00 <sproingie> (maybe put the 'eow' in a smaller font)
16:32:13 * roconnor totally disagrees with point 10 on "What monads are not"
16:32:27 * roconnor largely disagrees with point 5
16:33:51 <tensorpudding> what's impure about monads?
16:34:16 <jmcarthur> nothing
16:34:52 <tensorpudding> was asking roconnor since he disagrees with point 5 on "what monad's are not"
16:35:16 <roconnor> IO isn't impure.
16:35:21 <roconnor> nothing in haskell is impure!
16:35:40 <tensorpudding> oh, so you disagree with saying IO is impure
16:35:54 <roconnor> that's right
16:35:55 <Veinor> I get this trying to install base-4.0.0.0: config.status: error: cannot find input file: include/HsBaseConfig.h.in
16:35:58 <tensorpudding> not that you're disagreeing about monads being pure
16:36:02 <jmcarthur> i think I/O is impure
16:36:05 <jmcarthur> but the IO monad is not
16:36:08 <jmcarthur> :)
16:36:13 <roconnor> jmcarthur: good point
16:36:27 <Axman6> Veinor: you don't install base, it comes with GHC and is tied vert closely to the versipon of ghc you have
16:36:32 <tensorpudding> why do you disagree with 10?
16:36:41 <Veinor> ah, okay
16:36:56 <roconnor> tensorpudding: order is very important to monads in general.
16:37:24 <roconnor> it just so happens there are some commutative monads where it doesn't matter.
16:37:33 <rickz__> apart from haskell what other good functional languages are there?
16:37:39 <IceDane> rickz__: erlang
16:37:44 <IceDane> is supposed to be good
16:37:57 <mokus_> roconnor: yea, I also strongly disagree with 10 - even in commutative monads, the order of lines in a do-block matters
16:38:00 <roconnor> I guess monads are as much about order as monoids are about order.
16:38:00 <jmcarthur> roconnor: i think order is no more important to monads than it is to monoids
16:38:08 <rickz__> IceDane is that the language Sony Ericsson made?
16:38:10 <jmcarthur> ha
16:38:11 <roconnor> jmcarthur: :D
16:38:27 <Axman6> roconnor: yes
16:38:29 <Axman6> uh, rickz__
16:38:34 <jmcarthur> monads don't actually *specify* anything about ordering, though, just like monoids
16:38:41 <roconnor> so, are monoids about order?
16:38:45 <mokus_> eg, do {x <- foo; y <- bar x; ...}
16:38:46 <jmcarthur> that is, it can be a monad whether or not ordering is important
16:39:01 <jmcarthur> in that sense, monads have nothing to do with ordering
16:39:09 <rickz__> anyone tried F#?
16:39:27 <mokus_> I guess I agree with the headline but not the text under it ;)
16:39:52 <IceDane> rickz__: yes it is
16:39:52 <roconnor> jmcarthur: I don't think I like your statement.
16:40:16 <jmcarthur> you don't "like" it?
16:40:35 <IceDane> rickz__: I haven't tried it, but it's not entirely functional, that much I know
16:40:41 <roconnor> I think monoids do specify order
16:40:50 <jmcarthur> the sum monoid doesn't
16:41:02 <roconnor> ya, but monoids do
16:41:13 <jmcarthur> i mean, you write an ordering in, but that particular monoid doesn't care
16:41:20 <roconnor> the operation essentially takes an order pair, not an unordered pair.
16:41:29 <jmcarthur> ah, in that sense i agree
16:41:53 <roconnor> so monoids work with ordered inputs.
16:42:27 <holmak> rickz__: I tried F#
16:42:49 <rickz__> IceDane ah okey. read somewhere it had taken alot from haskell and since I am a .net guy starting to learn (and love) haskell it would be nice to be able to use it along with the daily stuff I write
16:42:54 <roconnor> I guess one difficult point is what do we mean when we say "monoids involve ordering"
16:43:06 <jmcarthur> Monoids (and monads) are about sequence in the mathematical sense, not in the evaluation order sense.
16:43:18 <jmcarthur> good way to say it?
16:43:18 <holmak> I didn't like it nearly as well as Haskell, seems to have a *lot* of rough edges
16:43:19 <roconnor> jmcarthur: yes yes
16:43:27 <Draconx> roconnor, the word "ordering" usually refers to partial orderings, which a monoid is not.
16:43:32 <roconnor> jmcarthur: that is an imporant point to get across.
16:44:01 <roconnor> jmcarthur: but I don't think that is the issue being discussed in point 10.
16:44:01 <holmak> And F# is too multiparadigm for my tastes, dilutes the benefits of functionalism
16:44:05 <jmcarthur> not quite
16:44:13 <IceDane> rickz__: according to wikipedia, it has all the .net framework at its disposal, and on top of the innevitable OOP principals that forces on it, it can also be used to write somewhat imperative code
16:44:13 <jmcarthur> point 10 is talking about effects
16:44:22 <IceDane> a quick look at it makes me think it's ugly as bleep
16:44:23 <IceDane> but meh
16:44:28 <IceDane> It might be nice
16:44:46 <IceDane> I got interested in functional programming from tasting it in C#, so who's to say it's thad bad?
16:44:48 <roconnor> Draconx: I agree.  I'd rename pt 10 to say "Monads are not about sequencing" and continue to disagree with it.
16:44:50 <tensorpudding> I'd try F# if it weren't impossible for me to do so
16:44:56 <IceDane> tensorpudding: howso?
16:44:59 <holmak> impossible?
16:45:02 <tensorpudding> not running windows
16:45:14 <holmak> Is it available on Mono?
16:45:21 <tensorpudding> Mono is only C#
16:45:21 <IceDane> There is mono, but I'm not sure if it's available
16:45:22 <IceDane> ah
16:45:23 <dibblego> you don't need windows to try F#
16:45:24 <IceDane> it is?
16:45:30 <dibblego> no, it isn't
16:45:32 <roconnor> jmcarthur: basically the order of parameters is very important in theory of monoids.
16:45:32 <IceDane> there are always VMs :P
16:45:36 <monochrom> F♯
16:45:40 <jmcarthur> "Monads are not always about sequencing"
16:45:52 <roconnor> jmcarthur: and I think it would be natural to say that "the order of parameters to a monoid matters"
16:45:58 <tensorpudding> dibblego: Mono supports F#?
16:46:00 <roconnor> even if it doesn't always matter.
16:46:04 <jmcarthur> right
16:46:05 <holmak> wine + F# express, if there is such a thing?
16:46:05 <tensorpudding> I can't glean that from Mono's website
16:46:09 <dibblego> tensorpudding, Mono supports compiled IL
16:46:09 <jmcarthur> we are on the same page
16:46:26 <IceDane> Anyway, since I'm here, I'm wondering if someone could tell me why(and how to go about doing it) one should try to keep main very small? Someone from here told me to do so, anyway.
16:46:27 <holmak> I would think the only issue would be getting an F# -> IL cmpiler
16:46:29 <dibblego> tensorpudding, there is a F# compiler for Linux
16:46:30 <medfly> running a VM to try a language...
16:46:32 <tensorpudding> How do I compile F# to IL?
16:46:34 <Axman6> dibblego: how do you compile it if you're not on windows?
16:46:40 <dibblego> fsc
16:46:56 <roconnor> jmcarthur: I think you agree that saying "order doesn't matter for monoids" is plain wrong.
16:47:02 <jmcarthur> "Monads are more than just sequencing"
16:47:11 <IceDane> Axman6: translating it to IL should be system-independent
16:47:15 <roconnor> jmcarthur: I guess that isn't quite what the title of pt 10 is saying.
16:47:15 <IceDane> if mono can then run that
16:47:53 <tensorpudding> Okay, Microsoft says that with their compiler package it will work on Mono
16:47:59 <IceDane> ah, cool
16:48:18 <roconnor> jmcarthur: pt 10 says "there are also commutative monads, like Maybe, that don't order anything"
16:48:22 <dibblego> the Visual Studio features for F# are quite good though, but I refuse to run windows
16:48:22 <Axman6> IceDane: it should be, in theory, but that depends on whether there is a compiler from F# to the IL
16:48:23 <roconnor> I sort of disagree with this
16:48:35 <mokus> jmcarthur: gotta start with "monads are not," right?  "monads are not just about sequencing" would work, I think
16:48:40 <IceDane> Axman6: I think someone said there was just before you asked your original question
16:48:42 <roconnor> jmcarthur: when I write code with the Maybe monad, I'm still ordering my effects.
16:48:52 <roconnor> jmcarthur: it just so happens that the order doesn't matter.
16:48:57 <Draconx> roconnor, er, what monad operation is commutative w.r.t Maybe?
16:48:58 <IceDane> dibblego: I would run linux only if it was possible.
16:49:25 <IceDane> There is too much I use daily that is dependent on windows only software(MS Office being a big part of it, and the occasional game being some of it)
16:49:39 <IceDane> And no, don't mention open office. It is useless when used together with other people that use MS office
16:49:45 <Axman6> i try to avoid linux where possible (i'm even using windows ofer linux on this machine at the moment because it's far more usable)
16:49:50 <Draconx> certainly a >>= b is not the same as b >>= a for any monad.
16:49:54 <monochrom> I run windows and then add a virtual machine for linux.
16:49:59 <jmcarthur> Draconx: the simplest property we came up with for commutative monads (and applicatives) earlier was: flip . liftA2 == liftA2 . flip
16:50:12 <roconnor> Draconx: a communtative monad is one in which  flip (liftM2 f) = liftM2 (flip f)
16:50:18 <tensorpudding> My computer is too slow to run Windows in a VM
16:50:34 <Axman6> IceDane: sounds like you need a mac. you get the best of both worlds
16:50:34 <IceDane> tensorpudding: that's bad
16:50:38 <IceDane> Axman6: heh
16:50:40 <monochrom> but most likely fast enough to run linux in a vm
16:51:08 <monochrom> but I digress to #haskell-blah
16:51:09 <tensorpudding> I don't like running Windows though.
16:51:14 <tensorpudding> yes
16:51:20 <jmcarthur> roconnor: so you would also say that I am sequencing when i say 1+2+3+4?
16:51:41 <Axman6> IceDane: it wasn't a joke ;) this is the first windows machine i've ever owned and used windows on in my life. it's been macs all my life, and we've never had any problems with compatibility
16:51:43 <monochrom> I am sequence when I say M*N*P, all matrices.
16:51:49 <jmcarthur> roconnor: written out, sure, there is sequence, but the meaning of the expression does not rely on it at all
16:52:01 <IceDane> I simply dual boot. Hard disk space is cheap as dirt these days, and i'll probably eventually set VMs up on both so that they can run the OS installed on the other hardware, if I need them fast without rebooting
16:52:01 <tensorpudding> hmm, no one wants to talk on #haskell-blah
16:52:07 <Draconx> jmcarthur, it does if (+) there is floating point addition :P
16:52:29 <jmcarthur> Draconx: floating point is a hack
16:52:31 <roconnor> jmcarthur: tough question.
16:52:37 <monochrom> Yeah, "x+y=y+x" is an extra axiom you have to be told some time ago, otherwise who knows.
16:52:50 <mokus> jmcarthur: it's a hack, but it's a fact of life too
16:53:19 <monochrom> and moreover I already have my M*N*P example.
16:54:06 <monochrom> In fact, how about this presentation. I write M*N*P, does order matter? You really don't know, and the safe default is just follow that order unless you know for sure I have scalars not matrices there.
16:54:47 <jmcarthur> monochrom: we agree, but how do we word that in a meaningful way in the context of "monads are not <something>"?
16:55:15 <jmcarthur> "Monads are not *necessarily* about sequence"?
16:55:29 <jmcarthur> but they are, in a sense
16:55:43 <roconnor> @type sequence
16:55:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:55:52 <roconnor> ^^ very important operation IMHO.
16:56:07 <IceDane> question: If I have several functions defined with "let" inside a do construct, some of which depends on some of the other, can I always be certain that they will be evaluated in top-down order?
16:56:11 <jmcarthur> it's just like fold, but for monads instead of monoids
16:56:14 <jmcarthur> :t fold
16:56:15 <lambdabot> Not in scope: `fold'
16:56:19 <jmcarthur> :t Data.Foldable.fold
16:56:20 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
16:56:25 <poe> monochrom order = associativity?
16:56:31 <monochrom> I don't like "about". Nothing is about anything else. X is about X and that is it. X is never about Y when X/=Y.
16:56:36 <MakoryuOnIce> :t sequence []
16:56:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a]
16:56:40 <mokus> IceDane: in let bindings the order doesn't matter
16:56:43 <jmcarthur> monochrom: maybe that's our problem
16:56:50 <Axman6> IceDane: no. order doesn't matter in haskell
16:56:53 <IceDane> mokus: so they are all evaluated first and then they are executed in order or something?
16:57:00 <IceDane> or how does it work?
16:57:08 <mokus> IceDane: they are all evaluated lazily as needed
16:57:08 <jmcarthur> IceDane: they are not evaluated unless needed
16:57:17 <monochrom> poe: Assume associativity. There is still commutativity or non-commutativity. M*N*P = M*P*N is still an order question.
16:57:17 <Axman6> they aren'tr evaluated at all until you need the result
16:57:18 <Draconx> IceDane, evaluation order in Haskell is constrained by data dependencies.
16:57:49 <jmcarthur> "Monads do not imply noncommutativity"?
16:58:00 <jmcarthur> kind of a mouthful for a bullet point
16:58:06 <jmcarthur> *mouth full
16:58:10 <IceDane> I suspected that .. so if a depends on b which depends on c which depends on a, none of them are evaluated until a is actually executed?
16:58:17 <IceDane> last a = d
16:58:18 <IceDane> sry
16:58:21 <mokus> "Monads are not only useful to sequence effects"?
16:58:38 <monochrom> A monoid may be non-commutative. A monad may be sensitive to sequence order.
16:59:02 <Axman6> IceDane: d would have to be evaluated before c before b before a
16:59:34 <jmcarthur> but a would force b would force c
16:59:47 <monochrom> X∪Y may be different from X.
16:59:48 <IceDane> Axman6: Yes, I figured
16:59:49 <jmcarthur> when a is forced
16:59:53 <IceDane> Thanks
17:01:05 <jmcarthur> "Monads impose a sequence but do not necessarily use it"
17:01:07 <IceDane> One more question; there was someone in here that advised me that my main function should be as small as possible. Are there certain reasons for this or are we just talking general code readability and so on, to avoid a bunch of functions embedded in a do construct with let?
17:01:38 <jmcarthur> IceDane: smaller functions are simpler, easier to read, easier to test
17:01:59 <IceDane> jmcarthur: thought so
17:02:01 <jmcarthur> there is no operational reason for small main functions though
17:02:04 <jmcarthur> that i know of
17:02:10 <IceDane> Alright
17:02:13 <monochrom> You can still define your own "small".
17:02:21 <Axman6> IceDane: we hate IO, so try to avoid it :P
17:02:24 <jmcarthur> i prefer "simple" over "small"
17:02:32 <jmcarthur> and IO is not "simple"
17:02:42 <jmcarthur> often
17:03:08 <IceDane> I agree..
17:10:55 <Axman6> IceDane: in general, main is quite small because we try to keep as much of the program pure as possible. we take inputs from the commandline or stdin in main, pass those to pure code which does all the work, and then print the output to stdout in main again. all the work is in the pure part
17:11:17 <MakoryuOnIce> @src (<*>) :: []
17:11:17 <lambdabot> Source not found. Wrong!  You cheating scum!
17:11:21 <MakoryuOnIce> @src (<*>) []
17:11:21 <lambdabot> Source not found.
17:11:28 <MakoryuOnIce> o_o
17:11:38 <Axman6> <*> = ap
17:11:48 <MakoryuOnIce> Yes
17:11:57 <IceDane> Axman6: Ah, yeah, makes sense. I would thus try to keep unpure functions that might, say, read a file by themselves, and then make pure code do the work?
17:12:00 <Axman6> @src ap
17:12:01 <lambdabot> ap = liftM2 id
17:12:16 <Axman6> IceDane: yup
17:12:37 <Axman6> IceDane: so you can see why the KIO parts of haskell programs tend to be very small now?
17:12:48 <IceDane> yeah
17:13:49 <Axman6> they can be more complex if you move into using concurrent threads, but you still tend to only have main spawn the threads, and then wait for them to all finish
17:14:22 <IceDane> That is common in many threaded 'design patterns' in many languages
17:14:28 <IceDane> but how is threading in Haskell? Troublesome?
17:14:43 <Axman6> no, it's fantastic actually
17:14:43 <ben0x539> Is there a function to wait on threads or do I have to build that myself
17:14:45 <MakoryuOnIce> IceDane: Far better than most languages
17:14:57 <IceDane> MakoryuOnIce: yeah? Does it do synchronization and so on automatically?
17:15:03 <IceDane> I think I read about it being able to do so somewhere
17:15:03 <Axman6> ben0x539: the easiest way to to wait on a list of MVars
17:15:17 <ben0x539> Axman6: Yeah, okay
17:15:21 <IceDane> god how I hate repeatedly entering critical sections and leaving them or locking/unlocking mutexes with a passion
17:15:26 <ben0x539> Surely lots of mvars are inefficient ._.
17:15:38 <Axman6> ben0x539: MVars are extremely efficient
17:15:42 <ben0x539> :O
17:15:45 <MakoryuOnIce> IceDane: For pure code, you have a number of functions to dispatch evaluation to another thread (with the runtime worrying about scheduling this)
17:16:03 <Axman6> like 'holy shit, did i fuck it up? there's no way they're that fast' efficient
17:16:25 <Axman6> MakoryuOnIce: you referring to par?
17:16:35 <MakoryuOnIce> Axman6: Yeah, and all the functions built on it, like parMap
17:16:42 <IceDane> MakoryuOnIce: That sounds good. What about performance?
17:16:58 <ben0x539> Faster than singlethreaded C, ideally
17:16:59 <Axman6> IceDane: it's excellent again, and getting better in 6.12
17:17:10 <IceDane> Sweet.
17:17:21 <IceDane> I can't explain how annoying threading is in C.
17:17:32 <IceDane> I almost scratched my eyes out using posix threads on linux in C
17:17:39 <Axman6> heh
17:17:44 <MakoryuOnIce> IceDane: Performance is fantastic. Basically, Haskell's purity gives the GHC implementers huge amounts of leeway to perform automatic optimizations on parallel code
17:17:58 <Axman6> our concurrency course stuck to using fork  and pipes for concurrency
17:17:59 <MakoryuOnIce> I used a lot of adjectives.
17:18:03 <IceDane> I guess that it would
17:18:35 <IceDane> I look forward to doing proper stuff in haskell
17:19:20 <Axman6> IceDane: do you know what MVars are btw? they're actually really cool
17:19:45 <IceDane> Axman6: No clue :P
17:19:48 <monochrom> Yes, learn MVars, then you'll know our locking story and judge for yourself how good it is.
17:19:55 * sm likes channels
17:20:07 <ben0x539> Surely channels are slow and have a lot of overhead
17:20:10 <ben0x539> being a huge pile of mvars
17:20:20 <Veinor> OK, I have a fresh Ubuntu 9.10 install with the libghc6-{http,zlib} packages installed. When I try to ghc --make Setup for cabal-install, it hangs on linking.
17:20:37 <monochrom> Yeah, what if channels were primitive and mvars implemented with channels.
17:20:49 <Axman6> IceDane: MVars are variables that can be either empty or full. if you try to read from an empty MVar, you will be blocked until it is filled be another thread. and the same is true gfor putting into a full MVar
17:20:58 <ben0x539> Then we would basically be back with pipes :<
17:21:21 <IceDane> Axman6: so you basically "read" from an mvar until the thread is finished, where you get access to it and are thus able to use the data?
17:21:29 <poe> that's what they've done in Go (http://golang.org)
17:21:32 <IceDane> (finished with it*)
17:21:34 <monochrom> I want to make a big difference between "x is slow in the status quo" and "x is slow in principle".
17:21:49 <poe> (i.e. channels are primitives)
17:22:29 <monochrom> For haskell was slow in the status quo 20 years ago. If people refused to use it for that reason, we wouldn't be here now.
17:22:35 <Axman6> IceDane: the really cool thing is that the runtime system is like an all seeing oracle when it comes to MVars, it will automatically wake up the first waiting thread immediately. this gives extremely high performance
17:22:38 <monochrom> "haskell is compiled to C anyway"
17:22:48 <ben0x539> poe: But go channels are mvars
17:22:52 <Veinor> yeah, cabal-install is freezing on the linking step even with Cabal hand-installe
17:22:56 <ben0x539> they block if you write to a "full" one
17:22:56 <Veinor> d
17:23:32 <ben0x539> uh, if i did not fuck my ten lines of go code ever, that is, which i might just as well have done
17:23:43 <Axman6> ben0x539: now i think about it, waiting on a list of MVars is silly. you just need to wait N times on one MVar, and that's muchy easier to code anyway
17:24:04 <ben0x539> Axman6: But then one of the threads might trick me (or be defective) and write to the mvar multiple times :<
17:24:19 <IceDane> Axman6: that sounds very cool
17:24:35 <Axman6> sure, or you could just not be a dick and write your code properly ben0x539 :P
17:24:43 <mokus> ben0x539: then don't leave it to the threads; invoke them all using one function that properly brackets it
17:24:48 <ben0x539> If I was good at writing code... ;)
17:25:02 <IceDane> Is it possible to deadlock using mvars? I mean, can a thread simply 'not fill it' and thus make all its waiting threads sit so indefinitely?
17:25:28 <Axman6> yes
17:25:45 <Veinor> hm, okay, it looks like other stuff is freezing as well
17:25:50 <IceDane> meh, that's still cool
17:25:59 <IceDane> Pure code makes it hard to write code that doesn't work as intended
17:26:18 <IceDane> So if you write code that ignores filling an mvar, I guess that's just your fault
17:26:22 <monochrom> I agree with mokus. Most production code writes their own forking wrapper anyway.
17:26:33 <ben0x539> (maybe i was wrong about go but i think that i has people writing into channels block until someone reads)
17:27:12 <mokus> STM is also a very nice model for concurrent state
17:27:33 <mokus> and much harder to make it hang if you'r worried about that sort of thing
17:27:36 <Axman6> not great performance though
17:27:56 <mokus> true, but it's very nice when you need to do very complex transactional stuff
17:28:04 <Axman6> yesh
17:28:12 <Axman6> i haven't found a good use for it yet
17:28:36 <jmcarthur> IceDane: we are only talking about concurrency, too. haskell *also* has excellent tools for parallelism
17:28:36 <mokus> i use it occasionally when I want to get something written quickly and don't much care how fast it runs
17:28:58 <mokus> it's nice not to have to give even the slightest amount of thought to locking, etc.
17:29:42 <Axman6> indeed
17:30:12 <mokus> plus, i have an 8-core xeon at work, so i can take a little bit of 'sluggishness' ;)
17:30:12 <Axman6> am i the only one who finds parallelism in haskell harder to use than the concurrency stuff? the parallelism stuff is very hard to get right
17:30:29 <jmcarthur> > parMap rnf (+1) [1..999]
17:30:30 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:30:38 <Peaker> I haven't had to worry about code performance almost at all.. I wish Haskell development focused more on usability and less on performance
17:30:41 <IceDane> jmcarthur: I'm not sure I understand the difference.. Oh, wait, concurrency is just several threads while parallelism is for running the same code on both cores or something?
17:30:45 <jmcarthur> Axman6: i don't find it that difficult
17:30:46 <IceDane> (if you have a dual core CPU)
17:30:50 <monochrom> the parallelism stuff gets less development and research.
17:30:57 <Axman6> > parMap rnf (^123456) [1..10]
17:30:58 <lambdabot>   [1,910216475946838102195359336549342514795341578633060412797978130729701828...
17:31:06 <ben0x539> IceDane: parallelism is for pure data, concurrency for IO actions, basically
17:31:12 <Axman6> jmcarthur: that won't perform well
17:31:18 <IceDane> ben0x539: I see
17:31:19 <jmcarthur> Axman6: indeed
17:31:26 <jmcarthur> it was just a demonstration
17:31:31 <ben0x539> parallelism is for making the runtime magically evaluate some things in advance so when your one single real thread actually needs them, they will already be there
17:31:42 <Axman6> jmcarthur: and that's the difficult part, making sure you have enough work to do in parallel
17:31:51 <jmcarthur> IceDane: parallelism is about efficient computations, concurrency is about many things happening at the same time
17:31:56 <Peaker> Axman6, NDP?
17:32:04 <jmcarthur> IceDane: the former is an optimization, the latter is about abstraction
17:32:08 <IceDane> jmcarthur: Ah..
17:32:12 <Axman6> NDP needs a lot of work
17:32:20 <kynky> parallelism is about divide and conquer, concureency is about control of multiple processes (and message passing)
17:32:25 <Axman6> which is being done, but still
17:32:28 <IceDane> Yeah
17:32:29 <jmcarthur> NDP is also intentionally limited in power
17:32:32 <IceDane> that's the way I understood it
17:32:48 <Peaker> How come everyone is so worried about using multi-cores?  My Pentium Pro was easily fast enough for the vast majority of stuff I need on my computer.. I feel the bottlenecks are not the CPU speed
17:32:51 <mokus> in practical settings, "parallelism" also often means running the same code on multiple inputs simultaneously
17:33:01 <Peaker> Is everyone writing network servers?
17:33:06 <jmcarthur> Peaker: i wouldn't call it worry so much as wanting to use the extra power
17:33:16 <Peaker> jmcarthur, what for?
17:33:17 <jmcarthur> Peaker: consider the benefits we reap from GPUs
17:33:31 <Axman6> Peaker: scientific computation
17:33:38 <jmcarthur> massive parallelism will allow us to get the same benefits for more general computation
17:33:43 <MakoryuOnIce> Peaker: For most people, the real benefit of computer performance is that their games run faster
17:33:48 <kynky> if its applicable to the task at hand
17:33:50 * hackagebot upload: terrahs 0.8 - A Haskell GIS Programming Environment (SergioCosta)
17:33:55 <Peaker> jmcarthur, Well, if you're implementing a real time graphics/physics engine, or a network server, or doing serious number crunching, sure.  Is it really that common around here?
17:34:04 <jmcarthur> some things are not important or intensive enough to parallelize
17:34:10 <monochrom> The way I understand Simon Marlow (was it him?): parallelism is when you know and you need it parallel because you want fast. concurrency is when you don't know and don't care, you just organize your program that way for convenience. Example: you wait for input from mouse and you wait for input from network too, convenient to write two concurrent processes/threads/whatever, you don't actually care that the two are interleaved
17:34:10 <monochrom>  or parallelized.
17:34:15 <IceDane> Peaker: This may be off topic, but have you seen the samsung SSD awesomeness video? Basically a lot of ssds in raid, amounts to 2GB/s read speeds. They clearly demonstrate that hard disks are huge bottlenecks
17:34:21 <Axman6> Peaker: that's badsically all the stuff i'm interested in :P
17:34:29 <Peaker> jmcarthur, I feel that there are basic things broken in today's software, and that the focus on parallelism could be better served elsewhere
17:34:43 <jmcarthur> Peaker: some people just find it interesting, but i wouldn't be surprised if there are actually a very high number of people doing number crunching and stuff that can benefit
17:34:48 <kynky> i think every1 has known about IO bottleneck for soe time
17:34:55 <jmcarthur> Peaker: i agree, from a user standpoint
17:34:57 <kynky> *some time
17:35:09 <ben0x539> Personally I just feel stupid waiting for a program to finish while have my CPU sits there and twiddles its thumbs
17:35:11 <blackdog> jmcarthur: it'd be really nice to come up with some good examples. it'd help me sell haskell to the rubyists, for one thing:)
17:35:18 <IceDane> kynky: yeah, but it is quite .. obvious if you watch the video
17:35:27 <IceDane> You don't think about it on a daily basis if you
17:35:28 <Peaker> jmcarthur, In terms of percentages, I think very few developers work on those kinds of applications.. I think its just the current cool thing
17:35:30 <IceDane> you're using your system
17:35:45 <kynky> IceDane, ram disks :)
17:35:56 <Peaker> ben0x539, When does that happen to you in practice?
17:36:01 <IceDane> kynky: hehe, or 20 SSDs in raid =)
17:36:24 <Axman6> Peaker: a lot
17:36:28 <jmcarthur> Peaker: well, many of *my* programs involve a lot of crunching, and that's even before i cared much for parallelism... even when i was a ruby guy
17:36:47 <Axman6> ... crunching in ruby? :O
17:36:47 <Peaker> Axman6, I understand that you like to toy with those things, I think you're the exception :)
17:37:02 <jmcarthur> Axman6: i played with genetic programming in ruby a couple times
17:37:18 <jmcarthur> because i didn't want to do it in C
17:37:30 <Axman6> Peaker: well, i don't think there'd be so much research into the topic if there wasn't come demand for it
17:37:31 <kynky> if doing parralism, thought there wasa right way of going about it, the wrong way means alot of hard work
17:37:44 <ben0x539> Peaker: compare go's focus on the whole coroutine thing, http://www.gotw.ca/publications/concurrency-ddj.htm, the thing that erlang is doing where everything is super-parallel, etc :(
17:37:45 <Peaker> I am a lot more worried about the lack of good trace backs (monadic and/or evaluation ones) than about performance. About better editing tools for Haskell, etc..
17:37:59 <Peaker> Axman6, I think the demand is that the whole "multi-core is the future" hype
17:38:13 <Axman6> well.. it is
17:38:24 <jmcarthur> Peaker: we needn't focus an entire community on one thing though, of course
17:38:34 <Axman6> for msany reasons, not just performance
17:38:38 <kynky> should be design over performance, and then when have  a sound design, profile that and optimize ?
17:39:04 <IceDane> this may be the wrong channel to ask this, but the language came up - What's up with the ruby people? Every time I meet one, and ruby comes up, they can't stop trying to force it down my throats.
17:39:12 <IceDane> I've not even taken a look at it. What makes them such fanatics?
17:39:14 <kynky> haskell is beautiful
17:39:21 <Peaker> CPUs are fast and not the bottleneck -- why is firefox taking seconds to load up its window?
17:39:32 <Axman6> don't know if you've noticed, but CPU speed has in general dropped quite a bit. 3-3.2GHz machines used to be popular, but they're far less popular these days. this is because more cor4es running at lower speeds is far more energy efficient
17:39:36 <tensorpudding> IceDane: i can't imagine this is the right channel to ask that
17:39:39 <jmcarthur> IceDane: ruby is a culture as much as a language, i think
17:40:15 <IceDane> tensorpudding: I sensed a "haskell vs. ruby" tension in here, I thought you might have some possibly equally fanatic thoughts about ruby being shit or something.
17:40:22 <IceDane> I may have been wrong
17:40:22 * xternal is a ruby person =)
17:40:23 <tensorpudding> no
17:40:28 <kynky> ruby has its uses, but it has drawbacks too
17:40:38 * ben0x539 used to be a ruby person before rails
17:40:38 <jmcarthur> Peaker: i agree that fundamental usability issues are important, but i would not say they are the only important problems we have today
17:40:41 <tensorpudding> I feel that ruby is used for a lot of good software
17:40:50 <MakoryuOnIce> IceDane: Nah, some of us were Ruby programmers ourselves until we found out that everything we like in Ruby is done better in Haskell
17:40:54 <Peaker> Axman6, There are tons of optimizations that could probably help most people's performance more than utilizing more cores.  Ordering data on disks to minimize seeks (defragging based on files doesn't do this, btw).  Or evicting RAM pages less stupidly.  Or doing more 0-copy stuff..
17:41:01 <jmcarthur> IceDane: i don't think there is a tension so much as vast differences, that's all
17:41:04 <IceDane> MakoryuOnIce: Ah, good, then I don't need to worry about missing out on it
17:41:05 <tensorpudding> haskell and ruby aren't very similar though
17:41:12 <cjs> Speaking as a rather experienced Rubyist who switched to Haskell, Ruby has many good things about it.
17:41:17 <MakoryuOnIce> tensorpudding: Not at first glance, no, not at all
17:41:22 <kynky> you get a lot of benefits with a strongly typed language, you get garentees
17:41:24 <jmcarthur> i am in the same boat as cjs
17:41:26 <cjs> Haskell and Ruby are similar in that both are significantly better than Java. :-)
17:41:43 <Peaker> cjs, Do you see Ruby as significantly different to Python?
17:41:50 <MakoryuOnIce> tensorpudding: I specifically mean Ruby-isms (both semantic and cultural) that differentiate it from other major languages, including Python
17:42:03 <jmcarthur> to be honest, when i was a rubyist, there was a trend to either try Io or Haskell next (this was people who tried new languages often)
17:42:22 <jmcarthur> Io and Haskell are *very* different, so i found that interesting
17:42:24 <cjs> Well, keep in mind I've not done a lot of Python, but no, I see them both as much of a muchness, in the big picture. If someone asked me whether to learn Ruby or Python, I'd tell them to learn whatever the people around them are using.
17:42:43 <tensorpudding> it has gotten popular to try lots of languages
17:42:53 <jmcarthur> Ruby and Python are much the same in language, but extremely different in culture.
17:42:56 <Peaker> tensorpudding, not around here.. would be great if it was
17:42:57 <cjs> MakoryuOnIce: What differentiates Ruby from Python, besides Ruby folks being so into that Rails piece of crap?
17:42:59 <jmcarthur> and libraries
17:43:03 <tensorpudding> of different paradigms
17:43:08 * cjs agrees with jmcarthur.
17:43:17 <tensorpudding> ruby is significantly different culturally than python
17:43:19 <MakoryuOnIce> cjs: First of all, Rails people don't really count as Ruby people last I checked. Rails is its own culture.
17:43:19 <Peaker> cjs, why is Rails a piece of crap? (I don't know rails or web dev)
17:43:24 <xternal> age?
17:43:26 <cjs> MakoryuOnIce: Ok, I'll accept that.
17:43:38 <xternal> I'll bet the average age of ruby vs. python uses is different.  just a hunch
17:43:43 <xternal> *users
17:44:00 <kynky> ruby is newer than python
17:44:15 <tensorpudding> ruby appears more flexible syntactically
17:44:16 <xternal> just barely
17:44:19 <cjs> Peaker: Well, the quick summary is that ActiveRecord (or any ORM thing) is really the wrong way to go, and the framework is best described as the bastard child of a PHP programmer and a web designer.
17:44:19 <xternal> like 3 years
17:44:22 <MakoryuOnIce> cjs: Second, Ruby people are essentially Lispers' twin siblings, separated at birth and raised in a culture where having actual syntax is a normal thing
17:44:24 <shachaf> Ruby is rather nicer to functional programming than Python, as I remember it.
17:44:42 <Peaker> cjs, ORM = Relational Database abstraction?
17:44:42 <jmcarthur> shachaf: yes
17:44:46 <cjs> Peaker: Yes.
17:44:55 <Peaker> cjs, Why is abstracting relational databases the wrong way?
17:45:24 <cjs> For the same reason we switched from the hierarchical/network database model to the relational model in the first place. Basically, ORM is just trying to reverse that.
17:45:27 <tensorpudding> ruby is one of those metaprogramming languages
17:45:29 <MakoryuOnIce> cjs: Ruby is all about metaprogramming and funky DSLs, whereas Python always looks like Python (and if it doesn't, then other Python programmers will yell at you)
17:45:34 <tensorpudding> it has some lisp qualities to it
17:45:39 <tensorpudding> which python surely lacks
17:45:47 <Peaker> cjs, I haven't dealt with databases much
17:45:58 <kynky> pyhin has one way to skin a cat, ruby has a 1000 ?
17:46:00 <Peaker> cjs, I don't know what that reason is either -- but abstracting stuff sounds like a great idea to me :)
17:46:06 <jmcarthur> A difference between Ruby programmers and Python programmers is that Ruby programmers are more inclined to write "elegant" code and Python programmers are more inclined to write "idiomatic" code. And they will argue about what each of those things mean.
17:46:07 <cjs> The metaprogramming thing is one of the rather annoying things about Ruby. It's great to use, but to write the code to implement the metaprogramming stuff is a nightmare.
17:46:08 <tensorpudding> it also has the everything-is-an-object notion
17:46:14 <xternal> I think it depends on what you are working on, too.
17:46:17 <Peaker> cjs, Especially hiding the awful notion of using a runtime-generated textual strings as an aPI
17:46:31 <cjs> Peaker: C.J. Date, Introduction to Database systems. Or one of his shorter books if you just want the overview.
17:46:43 <monochrom> Perhaps "abstract from relational to orm" is like "abstract from haskell to c"
17:47:01 <Peaker> cjs, Do you agree that at least SQL should be replaced with an API (perhaps combinators) rather than strings that are parsed at runtime?
17:47:16 <monochrom> I don't actually know. I am suggesting a possible interpretation.
17:47:19 <cjs> monochrom: Quite possibly. I'd think that the relational algebra would appeal to Haskell folks, since they're fairly mathematically oriented, in general.
17:47:23 <MakoryuOnIce> cjs: The crucial connection between Ruby and Haskell is the fact that a lot of the stuff Rubyists do with metaprogramming can be done more safely and sanely with type hackery and lazy evaluation
17:47:36 <cjs> Peaker: SQL is an abomination. You'll get no disagreement from me on that. :-)
17:47:37 <QtPlaty[HireMe]> Peaker: I'm not convinced of that.
17:48:00 <Peaker> QtPlaty[HireMe], what advantage does using runtime string parsing have?
17:48:36 * Axman6 feels the only time strings should be parsed to get program functionality out of them is in a compiler. fuck SQL
17:48:59 <IceDane> I have not done very much webdev, but my few experiences with SQL made me wonder how on earth most of the world's websites' databases and the backend code to their websites ran on that
17:49:01 <ben0x539> Does SQL actually get parsed in your program?
17:49:08 <holmak_> I will support Peaker here. SQL syntax is an abomination.
17:49:15 <ben0x539> I figured it would just be sent over the network anyway, so who cares whether it is a string or something else.
17:49:19 <MakoryuOnIce> Peaker: Yeah, that's SQL's biggest weakness right there
17:49:50 <MakoryuOnIce> Peaker: It would be nice if SQL standards were defined in terms of a parse tree, rather than syntax
17:49:56 <IceDane> ben0x539: I would argue that almost every single SQL injection vulnerability on the net can be traced back to how hard it is to write proper SQL
17:50:18 <QtPlaty[HireMe]> Peaker: Runtime string pasing at least doesn't have the leaky abstraction problems that every altenative I seen has.
17:50:20 <jmcarthur> ben0x539: would you rather write raw xml into a web service's code than use an API?
17:50:43 <Peaker> QtPlaty[HireMe], Consider passing around the parsed query rather than the strings, what leaks would that introduce?
17:50:50 <ben0x539> IceDane: I would argue that you can trace it to the author's ignorance of prepared statements :<
17:51:18 <ben0x539> jmcarthur: xml is a whole lot more verbose than sql, and tends to be a closer map to the problem domain in any case
17:51:22 <IceDane> ben0x539: Yes, but they had designed in differently(Using an API of some sort as was mentioned), it wouldn't be a problem
17:51:32 <jmcarthur> ben0x539: i'm not so sure about that
17:51:42 <xternal> most folks I know serializing data to a web api don't rely on xml anymore.   it's json
17:51:46 <IceDane> Microsofts LINQ stuff does translate to SQL, but all databases can be translated to objects and those objects can be added directly
17:51:48 <jmcarthur> ben0x539: do you know relational algebra?
17:51:49 <xternal> or sometimes yaml, but usually json.
17:51:52 <xternal> xml is a hammer.
17:51:54 <ben0x539> jmcarthur: No
17:51:56 <QtPlaty[HireMe]> Peaker: Thats fine.  And prepared statements are also a fa better then sting intropolation you will not get any protests from me there.
17:52:01 <Berengal> Peaker: runtime parsing has some of the same benefits that JIT compiling does: Access to runtime information. In databases, this can especially be of great benefit, since that's the kind of information indexes and statistics and such are
17:52:02 <IceDane> that completely eliminates sql injection vulnerabilities
17:52:09 <jmcarthur> ben0x539: i recommend it. it changed the way i looked at SQL, for sure
17:52:16 <ben0x539> IceDane: Presumably then sql would be utterly terrible to compose in languages less expressive than, I guess, ruby
17:52:17 <jmcarthur> or relational calculus
17:52:30 <Berengal> Well, you don't need parsing to get runtime-recompilation of the queries...
17:52:42 <Peaker> QtPlaty[HireMe], Well, the thing that bothers me is the use of runtime text parsing -- if it was a parse tree, it'd probably evolve into a nicer API anyway
17:52:46 <Berengal> But then again, you do need some stream of bytes to send over the network
17:52:58 <ben0x539> (LINQ translates to sql? You cannot put arbitrary code in those lambdas...?)
17:53:08 <Peaker> Berengal, I don't understand why runtime string parsing adds any new information at runtime
17:53:19 * Axman6 finds it really fun taking a SQL statement, translating it into relational algebra, and then optimising it
17:53:22 <IceDane> ben0x539: I've hardly ever looked at ruby, but I think using SQL in general is horrible. I don't understand how on earth someone thought it was a good idea to be forced to embed strings of long, ugly queries into another language.
17:53:26 <ben0x539> jmcarthur: Noted. Mind, I skipped the exam on regular, linear algebra already :(
17:53:42 <jmcarthur> Axman6: i can't really think in SQL anymore without first thinking in relational algebra
17:53:42 <Axman6> jmcarthur: i agree, relational algebra makes SQL make a lot more sense
17:53:44 <Berengal> Peaker: It doesn't in itself, but it does force you to not compile the query
17:53:45 <monochrom> SQL and regex are horrible.
17:53:50 <ben0x539> IceDane: I just mean, what would an API to SQL even look like in C?
17:54:00 <QtPlaty[HireMe]> Peaker: Would you be ok with compile time text parsing?
17:54:01 <Peaker> Berengal, That doesn't sound like a great reason to use it
17:54:11 <Peaker> QtPlaty[HireMe], That's what your compiler is doing
17:54:11 <Berengal> Peaker: it's not.
17:54:19 <monochrom> But I digress.
17:54:28 <Berengal> Peaker: But I do have a better reason: Uniform access from all different programming languages.
17:54:31 <IceDane> ben0x539: I'm not sure. I guess it could all translate to sql eventually, unless they completely redesign the whole thing, but at least the APIs would take care of security.
17:54:31 <QtPlaty[HireMe]> Peaker: Can you expand on that idea?
17:54:55 <ben0x539> Yeah, but they would probably look terrible and involve lots of void pointers and type-unsafe function pointers and.
17:55:00 <Peaker> Berengal, Uniformity breaks as soon as handling the query results is concerned
17:55:04 <IceDane> ben0x539: yes, it would be horrid
17:55:06 <IceDane> I give you thad
17:55:06 <Peaker> Berengal, So might as well break it in the query itself
17:55:26 <Berengal> Peaker: But yeah, I'd still rather have lots of combinator libraries for building "relational formulaes" or something
17:55:27 <ben0x539> I suspect bringing up C is unfair anyway
17:55:37 <IceDane> Writing an irc bot in C was like 50% string parsing. I can't imagine C parsing SQL in a beautiful manner
17:55:46 <Peaker> QtPlaty[HireMe], your code calls an SQL function with some string -- that code is probably itself a string parsed by your compiler.  It could parse a bunch of function calls that build up the query right there, in compile time
17:56:50 <Berengal> I was somewhat surprised to see that TopLink in Java can build queries out of objects, not just string parsing...
17:57:21 <IceDane> Berengal: Are you referring to database-to-object mapping?
17:57:26 <QtPlaty[HireMe]> The thing is, SQL is a successful declaitive DSL and most altenative I've seen fall short of it fo expressive powe.
17:57:37 <QtPlaty[HireMe]> power.
17:58:09 <Berengal> IceDane: Well, that's what TopLink is, but it also has it's own "Java Persistence Query Language", which is a bastard-SQL for objects.
17:58:26 <IceDane> I see
17:58:49 <Berengal> IceDane: And you can build queries for that language by creating lots of different query object thingies and linking them together
17:58:49 <jmcarthur> QtPlaty[HireMe]: what alternatives?
17:59:11 <QtPlaty[HireMe]> jmcarthur: Mostly verious ORM models.
17:59:29 <jmcarthur> i would not really consider an ORM to be a viable SQL alternative
17:59:39 <QtPlaty[HireMe]> And a few hyackial database langs.
17:59:41 <IceDane> Berengal: .NET has LINQ, which among other things allows you to write short queries inside code on collections of objects and such. But it also includes database-to-object mapping stuff, which enables you to create objects out of the tables you have, and add stuff to them, throw them in a collection and pass them to a class and then call something like "ExecuteQuery"
17:59:42 <jmcarthur> what about something like datalog?
17:59:44 <Berengal> QtPlaty[HireMe]: The alternatives I've seen to SQL seem to all be superior
17:59:46 <IceDane> I was particularly fond of it
17:59:51 <jmcarthur> something that's actually a relational model?
18:00:00 <IceDane> it made using databases a piece of cake
18:00:37 <QtPlaty[HireMe]> Berengal: Have you ever tried to access salesforce?
18:00:38 <IceDane> Before I discovered it, some code I wrote was written using SQL squeries, and converted to useLINQ it was probably only 10% of the original line count
18:00:40 <Berengal> IceDane: Yeah. I haven't tried LINQ much (Don't know C# at all, basically), but from what I've gathered it looks pretty neat
18:01:05 <Berengal> QtPlaty[HireMe]: I don't know what that is, so no
18:01:20 <Veinor> Why can't I get print to print newlines?
18:01:27 <Axman6> i saw some LINQ yesterday, it looked quite nice indeed
18:01:43 <Axman6> Veinor: what do you mean?
18:01:43 <Berengal> From what I've gathered, LINQ is almost do-notation for C#
18:01:49 <Veinor> > intercalate "\n" ["a", "b"]
18:01:50 <lambdabot>   "a\nb"
18:02:13 <IceDane> Berengal: yes, it is indeed
18:02:28 <Veinor> > intersperse '\n' ["a", "b"]
18:02:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
18:02:30 <lambdabot>         against inferred type...
18:02:32 <IceDane> Oh, and linq works on XML as well
18:02:54 <Berengal> IceDane: haskell-db is a database-monad for haskell, which I have used a bit, and it was pretty decent
18:03:02 <Veinor> > intercalate "\n" ["a", "b"]
18:03:02 <Berengal> Arrows > Monads for XML ;)
18:03:03 <lambdabot>   "a\nb"
18:03:06 <Veinor> see?
18:03:33 <IceDane> Berengal: Ah. I haven't even gotten to monads yet in my quest to learn haskell, but I can only assume it will be awesome like everything else haskell has thrown at me
18:03:33 <Berengal> > text $ intercalate "\n" ["a", "b"]
18:03:33 <holmak_> The .NET folks seem to be intent on sneaking as much FP into C# and F# as they can...
18:03:34 <lambdabot>   a
18:03:34 <lambdabot>  b
18:03:54 <holmak_> IceDane: Monads are pretty extreme, for sure
18:04:01 <mokus> holmak_: I won't complain about that ;)
18:04:04 <IceDane> How 'extreme'?
18:04:11 <IceDane> Also, yes, they're sneaking in FP everywhere
18:04:12 <holmak> Took me forever to figure them out
18:04:23 <IceDane> C# 3.0(or 3.5, not sure) supports lambda functions and such things
18:04:23 <Berengal> IceDane: if you get how the do-notation works for a couple of them, you've pretty much grokked it.
18:04:36 <holmak> Just don't try to figure it out for IO first
18:04:43 <Veinor> Berengal: is there a better way to do it then that?
18:04:50 <holmak> Read Real World Haskell
18:05:10 <IceDane> With semi-functional extensions if you include the linq namespaces. Like .. objectCollection.Where( x => x.Name == "lolwtf");
18:05:23 <IceDane> holmak: Yeah, I'm reading it right now
18:05:28 <Berengal> Veinor: What you've got is a string with a newline. If you "print" that string, it'll first be converted to it's representation, with double-quotes and escaped special chars and all. If you just want to print the string, use putStrLn
18:05:37 <Veinor> ahh
18:05:49 <holmak> i think they introduce monads in a long-winded, but good way
18:05:55 <holmak> long-winded by necessity
18:06:05 <holmak> to demonstrate why they are useful
18:06:44 <Berengal> How to grok monads in 3 easy steps: 1) Maybe 2) Write your own parser 3) realize it's just a class like any other class
18:06:55 <holmak> haha
18:06:58 <holmak> so true!
18:07:00 <IceDane> Haha, I'll cross that bridge when I come to it
18:07:08 <IceDane> I tried running past some bridges in impatience
18:07:13 <IceDane> it didn't work out very well
18:07:18 <Berengal> IceDane: have you seen the Erik Meijer lectures on C9?
18:07:25 <mokus> Berengal: my personal preferred path is 1) Functors 2) Monoids 3) join
18:07:28 <IceDane> Berengal: Never heard of the person or the 'thing'
18:08:25 <Berengal> http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13/
18:08:36 <Berengal> That one has parsers and monads in it
18:09:24 <IceDane> ah
18:09:25 <Berengal> IceDane: The guy works on C#, LINQ and .NET, so he's using lots of analogies to those languages for teaching Haskell
18:09:48 <Cale> mokus: That's a pretty abstract path. You go via monoid objects in the category of endofunctors? Or are you talking about normal monoids in Set?
18:09:58 <IceDane> Berengal: bookmarked
18:09:59 <IceDane> thanks
18:10:16 * hackagebot upload: graphics-drawingcombinators 0.43 - A functional interface to 2D drawing in OpenGL (LukePalmer)
18:10:25 <mokus> Cale: yes, but I find it is intuitive when specialized to the "ctegory" of haskell Functors
18:10:49 <mokus> Cale: monad's clicked for me when i understood join
18:12:09 <ddarius> A monad is just a monoid object in a category of endofunctors, but to understand that you need to know what a category is, but a category is just a monad in the 2-category of spans of sets!
18:12:52 <mokus> ddarius: not really - all you really need to understand about it, for programming purposes, is right htere in the type of 'join' ;)
18:13:16 <mokus> ddarius: it squashes functors the same may mappend squashes values
18:14:03 * ddarius thinks the spirit of his comment is being partially missed.
18:14:20 <mokus> maybe
18:14:56 <Cale> But I think to *really* understand the definition for what it means to be a monoid object, you at least need to know what a monoidal category is.
18:15:00 * mokus is in the "you don't need to understand category theory to understand haskell' camp, even though it really makes haskell more beautiful when you do at least get a bit of it
18:15:11 <FunctorSalad> I for one am thinking why spans of sets should form a 2-cat
18:15:13 <Cale> You can get by on a sort of fuzzy intuitive basis like that though
18:15:28 <Cale> Oh, for programming, you don't need *any* of this.
18:15:41 <mokus> that's the context i'm talking about
18:15:44 <ddarius> mokus: While my statement is true, it is (pretty) clearly silly.
18:16:07 <FunctorSalad> B1 <-- A --> B2
18:16:16 <mokus> ok, sorry - I'm bad at catching sarcasm and the like even IRL, I'm hopeless on IRC ;)
18:16:33 <Cale> FunctorSalad: I'm surprised that you know what a span of sets is without knowing that they form a 2-category
18:16:35 <ddarius> FunctorSalad: Composition of 1-cells is pulling back.
18:17:04 <Cale> (because they're not the sort of thing that you'd normally bump into in another context)
18:17:34 <FunctorSalad> Cale: they're the input data for a pushout
18:18:06 <Cale> FunctorSalad: Oh, I suppose you might see them there, yeah.
18:18:44 <FunctorSalad> so you meant "monad in a 2-category" as a generalization of "monad in CAT"?
18:19:12 <Cale> FunctorSalad: yeah, if you have a 2-category, you can generalise the definition of monad to fit that
18:19:58 <rickasaurus> I guess it would help if I understood what an endofunctor was :D
18:21:01 <Cale> (Given a 0-cell C, a monad T is a 1-cell T: C -> C, together with a pair of 2-cells: eta: id_C -> T and mu: T^2 -> T satisfying the usual laws.
18:21:22 <Cale> rickasaurus: Do you know what a category is?
18:21:24 <mokus> rickasaurus: it would help cut through some of the explanations out there, but it's probably not worth it unless you find abstract mathematics interesting in its own right
18:21:35 <FunctorSalad> Cale: *nods*
18:22:00 <rickasaurus> Cale: not in any mathematical sense :)
18:22:05 <Cale> rickasaurus: okay
18:22:27 <rickasaurus> I do like maths, but I never took anything past calc 3/linear algebra and calc stats
18:23:41 <tensorpudding> that means you missed out on about all the fun stuff
18:23:44 <Cale> Okay, so a category C is a collection of "objects" (which can be anything at all -- they're effectively just labels), together with...
18:23:49 <Cale> for each pair of objects A and B, a collection C(A,B) of "arrows"
18:24:01 <Berengal> I had this nice intro paper to category theory, but I lost it... I think the guy proved the ace of spades or something at the end of it
18:24:10 <rickasaurus> arrows?
18:24:31 <Cale> and for each three objects X, Y, Z, a function called composition C(Y,Z) x C(X,Y) -> C(X,Z)
18:24:43 <rickasaurus> ok
18:24:53 <Cale> If f is an arrow in C(X,Y), we write f: X -> Y
18:25:09 <rickasaurus> a transformation of type X into type Y?
18:25:23 <Cale> and so composition takes an arrow g: Y -> Z, and f: X -> Y, and produces some arrow g . f: X -> Z
18:25:31 <FunctorSalad> ddarius: wait, aren't 1-cells just morphisms of diagrams, and their composition is just composition of the parts?
18:25:36 <Cale> Well, 'transformation' might be a bit of a loaded term.
18:25:47 <Cale> The arrows are not required to be functions or anything in particular.
18:25:58 <rickasaurus> so consider it a mapping
18:26:06 <FunctorSalad> (in this category)
18:26:24 <Cale> But this is a generalisation of sets and functions, or, say, vector spaces and linear maps
18:26:45 <Cale> Let me finish the definition and I'll give some more exotic examples though :)
18:26:50 <rickasaurus> so in this case an arrow sounds a lot like a function
18:27:01 <Cale> Well, in the category of sets and functions it is.
18:27:21 <rickasaurus> I see, so call categorys are well defined?
18:27:29 <Cale> ?
18:27:35 <mokus> an arrow can be an instance of a partial order, to give an example that's not a function
18:27:44 <mokus> and composition is transitivity
18:28:05 <rickasaurus> As in, in category theory there are well defined categories. for example, sets and functions.
18:28:16 <rickasaurus> That would be one category
18:28:33 <Cale> We also need, for each object X an arrow id_X: X -> X such that id_X . f = f, and g . id_X = g for any f and g which will compose
18:28:37 <Berengal> Anything that matches the definition for a category is a category
18:28:46 <rickasaurus> an identity arrow?
18:28:50 <Cale> and: for any three arrows f, g, h which compose, we have (f . g) . h = f . (g . h)
18:29:04 <rickasaurus> what do the dots mean in this case?
18:29:06 <Cale> rickasaurus: right, id_X is an identity arrow
18:29:09 <Cale> composition
18:29:26 <Cale> The composition is an arbitrary function on arrows which satisfies these laws.
18:29:37 <rickasaurus> so (f. g) . h is really ((f . g) . h)?
18:29:45 <Cale> ?
18:29:55 <Cale> You just wrapped parens around the whole thing
18:30:05 <dibblego> on this topic, does Arrow inherit Category?
18:30:08 <Cale> I guess that's true :)
18:30:14 <Cale> dibblego: inherit?
18:30:18 <rickasaurus> I took some scheme in college
18:30:21 <dibblego> the type-class
18:30:33 <h20xt> i hope not
18:30:37 <dibblego> sorry, is it is a subclass
18:30:57 <Cale> dibblego: yes
18:31:00 <rickasaurus> so what you are definining is the communitive property?
18:31:03 <Cale> (according to the haddock)
18:31:11 <Cale> rickasaurus: associative
18:31:20 <rickasaurus> oh, sorry, it's been a while :)
18:31:21 <Cale> Composition is rarely commutative.
18:31:23 <dibblego> oh thanks (sorry for not looking myself)
18:32:17 <Cale> rickasaurus: Now, what happens to this definition if we restrict ourselves to categories in which there is just one object?
18:32:19 <rickasaurus> so they cannot be arbatrarily reordered
18:32:25 <Cale> yeah
18:32:40 <Cale> But how you parenthesise the chains of compositions doesn't matter.
18:33:03 <rickasaurus> oh wow, this is pretty much algebra
18:33:05 <Cale> If there is only one object, say X, then the only arrows we have are X -> X
18:33:14 <Cale> It is a branch of algebra, yes
18:33:32 <Cale> any two of those arrows will compose
18:33:44 <Cale> and there is an identity, and composition is associative
18:33:50 <Cale> So what we have is a monoid
18:33:58 <ivanm> preflex: seen ChilliX
18:33:58 <preflex>  ChilliX was last seen on #haskell 2 days, 26 minutes and 51 seconds ago, saying: blackdog: yeah, file a bug
18:34:05 <Axman6> :(
18:34:07 <rickasaurus> hrm, what does compose mean in this context
18:34:22 <Axman6> still marking exams i'd guess ivanm
18:34:29 <ivanm> yeah
18:34:38 <rickasaurus> As in you could just as easily have (X -> X) -> X
18:34:42 <ivanm> Axman6: someone just pointed out his ghc post about dynamic linking...
18:34:59 <ivanm> and I wanted to point out that we're having heaps of trouble in gentoo _because_ ghci, etc. uses dynamic linking :s
18:35:25 <Cale> Well, two arrows g: Y -> Z, and f: W -> X will compose to give g . f: W -> Z if and only if X = Y
18:35:29 <ivanm> (admittedly, our problems are due to C libs, specifically not knowing which version of a C lib we want...)
18:35:40 <rickasaurus> So if you had X -> Y you could just as easily have ( X -> Y ) -> X -> Y
18:35:54 <Cale> rickasaurus: I'm not sure I understand your notation here.
18:36:14 <rickasaurus> sorry, i'm just kind of making it up
18:36:29 <rickasaurus> X is a set
18:36:41 <Cale> Is it?
18:36:43 <Cale> It wasn't in my example.
18:36:54 <rickasaurus> crap, I might be lost :)
18:37:16 <rickasaurus> I think I understand though
18:37:18 <Cale> However, the collection of arrows C(X,X) may be a set (we might as well restrict ourselves to those here, for simplicity)
18:37:38 <Cale> But X is just a label.
18:37:45 <ddarius> FunctorSalad: 0-cells are sets,  A 1-cell, X : A -> B is a span (pair of functions) X -> A and X -> B.  id is just a pair of id functions.  Composition is the pull back along the matching arrows, i.e. X : A -> B and Y : B -> C produces (X o Y) : A -> C which is a pair of functions (the projections) X o Y -> X and X o Y -> Y.
18:37:53 <Cale> The objects in a category are only there to tell us when the arrows will compose
18:38:03 <rickasaurus> a label for a unique set or for a domain?
18:38:13 <Cale> They might not be sets
18:38:40 <Cale> Though if f is an arrow X -> Y, we still call X the domain of f, and Y the codomain. But they might not be sets.
18:38:41 <rickasaurus> I see, so it's easist to understand in terms of discrete values but the label can represent anything
18:38:45 <ddarius> FunctorSalad: 2-cells, X -> Y are just functions f : X -> Y that make the spans commute, i.e. X_i = f ; Y_i for i = 1,2 and X_i meaning the ith projection.
18:39:03 <ddarius> FunctorSalad: Composition and identity for 2-cells lifts straight from Set.
18:39:06 <FunctorSalad> ddarius: hmm ok, thought we were using the diagram category as the 1-category part
18:39:34 <rickasaurus> For example in the context of a type system X is the type restriction?
18:39:49 <ddarius> FunctorSalad: Now work out what the definition of a monad in a 2-category means in this context and see how it leads to a (small) category.  It's a nice exercise.
18:40:02 <Cale> The objects are types, and the arrows would be functions definable in the language, yeah.
18:40:28 <rickasaurus> this is way less complex than I thought
18:40:35 <rickasaurus> but perhaps more profound :)
18:40:53 <Cale> Are you familiar with what a monoid is?
18:41:23 <rickasaurus> I'm somewhat familiar with monads but only in terms of application such as maybe and io
18:41:58 <Cale> A monoid is just a set M together with a binary operation *: M x M -> M called multiplication, such that there is an identity element 1 in M such that 1*x = x = x*1 for any x in M, and such that multiplication is associative: (x*y)*z = x*(y*z) for any x,y,z in M
18:42:05 <Zariel> @src words
18:42:05 <lambdabot> words s = case dropWhile isSpace s of
18:42:05 <lambdabot>     "" -> []
18:42:05 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:42:47 <Cale> For instance, normal addition or multiplication of numbers, concatenation of strings, multiplication of matrices, and lots of others.
18:43:14 <rickasaurus> hrm
18:43:40 <Zariel> if im splitting a list at given elements, how can i create a list within a list to append to when i dont know it ends ?
18:43:42 <Cale> But a monoid is essentially the same thing as a category having only one object.
18:43:59 <rickasaurus> So for example, the simple maybe monad
18:44:11 <Cale> monad /= monoid here
18:44:19 <rickasaurus> I see
18:44:37 <rickasaurus> so all monoids are identity
18:44:42 <Cale> ?
18:45:05 <rickasaurus> they are all defined in terms of the same domain
18:45:09 <rickasaurus> no wait
18:45:22 <rickasaurus> I mean they are all defined by having the same input and output domain
18:45:31 <Cale> If we have only one object X, then we just have one set C(X,X) of arrows
18:45:37 <sjanssen> what's the name of Conal's library that has an implementation of futures?
18:45:48 <Cale> and just one kind of composition:  C(X,X) x C(X,X) -> C(X,X)
18:46:05 <Cale> and it's required to have an identity and be associative
18:46:19 <Cale> So that's exactly the same thing as the definition of monoid that I just gave.
18:46:24 <rickasaurus> I see
18:46:36 <Cale> With C(X,X) standing in for M, and id_X standing in for 1
18:46:40 <conal> sjanssen: it's in Reactive.  Data.Future
18:46:42 <rickasaurus> so monoids define the input and output as having the same set of restrictions?
18:46:43 <Cale> and . standing in for *
18:46:52 <sjanssen> conal: thanks
18:46:56 <Cale> "set of restrictions"?
18:46:57 <conal> :)
18:47:16 <rickasaurus> well, the object X in this case
18:47:16 <Cale> "input"?
18:47:27 <mokus> rickasaurus: The fact that they are arrows is misleading you i think - the "Arrows" in this case can be any "objects" in the monoid - just as strings
18:47:29 <rickasaurus> I would consider the left to be input and the right to be output
18:47:32 <Cale> Well, a monoid is this set with a multiplication
18:47:49 <mokus> er, 'such as strings' i meant
18:48:05 <rickasaurus> but they could be strings which contain the letter a
18:48:18 <rickasaurus> or some such other restriction?
18:48:31 <Cale> rickasaurus: So for example, there's a category with just one object, and an arrow for every String, and composition of arrows is concatenation of strings, and the identity arrow is the empty string.
18:48:45 <byorgey> rickasaurus: the arrows in a category don't necessarily correspond to functions, so "input" and "output" can be misleading.
18:49:00 <rickasaurus> hrm
18:49:02 <Cale> Or, for example, there is a category with just one object, and whose arrows are real numbers, and the composition of arrows is addition of real numbers.
18:49:05 <mokus> well, there is such a monoid, but that's incidental - their arrow-ness is purely a coincidence, an accident of the fact that it's being presented as a category
18:49:20 <Zariel> Can anyone give me a hand with this ? http://pastey.net/129373
18:49:29 <Zariel> a starting point would be good
18:49:34 <Cale> rickasaurus: This should start to give you the idea that these things are not necessarily very "function-like"
18:50:07 <rickasaurus> I'm just not sure how far to generalize what X means in this case
18:50:25 <Cale> rickasaurus: There's also a category whose objects are the natural numbers, and whose arrows n -> m are the n-by-m matrices, and composition is matrix multiplication.
18:50:26 <rickasaurus> what keeps X from being different than Y
18:50:39 <byorgey> Zariel: I think you need parentheses in  q (x:xs) 0 : []
18:50:44 <rickasaurus> X must have some kind of domain right?
18:50:57 <Cale> I don't understand what you mean by "have some kind of domain"
18:50:59 <byorgey> q x:xs 0 : []  is parsed as  (q x) : (xs 0) : []  which is probably not what you mean
18:51:10 <Cale> X is an element of the arbitrary collection of objects which comes with our category
18:51:34 <rickasaurus> So we are defining a category, in this case real numbers
18:52:01 <Zariel> byorgey: thanks, then i end up with an infinite list
18:52:04 <Cale> rickasaurus: Well, yeah, I defined a category with one object, and the collection of arrows from that object to itself are the real numbers.
18:52:04 <rickasaurus> in this example X's domain is real numbers?
18:52:07 <Zariel> it just looks wrong to me
18:52:11 <Cale> rickasaurus: no
18:52:26 <Zariel> @src replicate
18:52:26 <lambdabot> replicate n x = take n (repeat x)
18:52:28 <byorgey> Zariel: what is the parameter n for?
18:52:48 <rickasaurus> what is that one object
18:52:49 <byorgey> Zariel: you never seem to use it.
18:52:49 <mokus> rickasaurus: what keeps X from being Y is that there is no Y; the category only has one object, and X is it
18:52:50 <Zariel> it was which list it was up to, but that didnt get included
18:52:56 <Cale> rickasaurus: X hardly matters here. It could be anything. The only purpose of the objects in a category is to remind us which pairs of arrows we can compose
18:53:10 <rickasaurus> so in this can X is everything where the operation multiplication is defined?
18:53:10 <Cale> rickasaurus: When there's only one object, any two arrows will compose
18:53:20 <rickasaurus> in this case even
18:53:25 <Cale> rickasaurus: X doesn't have any internal structure here.
18:53:56 <Cale> If you want to work in the world of ZFC, pick your favourite set and use it for X. It doesn't matter which set.
18:54:06 <Cale> But we aren't even thinking of X as a set.
18:54:24 <Cale> X is just a label which helps us remember which arrows will compose.
18:54:40 <rickasaurus> so everything is defined in terms of the operation
18:54:51 <rickasaurus> or the association
18:55:02 <Cale> Yeah, composition and the collections of arrows is where everything interesting happens.
18:55:12 <Cale> But the objects tell us which collections of arrows we might have.
18:55:43 <rickasaurus> it's so different that I normally think about types.
18:55:44 <Cale> If we have only one object X, the answer to that question is boring: we only have the collection of arrows C(X,X)
18:56:07 <rickasaurus> only identity
18:56:12 <EvanCarroll> Cale: !!! hallo! quick question, why does foldr, and foldl have different signatures for the subs they accept
18:56:15 <Cale> Not only the identity arrow
18:56:38 <rickasaurus> every possible association of X to X?
18:56:47 <Cale> EvanCarroll: because the function you pass them takes the elements of the list on the opposite side
18:57:04 <Cale> rickasaurus: The arrows themselves are again just "anything"
18:57:20 <Cale> rickasaurus: They don't necessarily have any internal structure or meaning apart from how they compose
18:57:31 <Cale> rickasaurus: We can tell one from the other, and that's it.
18:57:58 <rickasaurus> I see, but if they all are from X to X what differenciates them?
18:58:01 <Cale> When we define a category, the arrows may or may not have an interpretation as functions.
18:58:16 <Cale> Well, there may be lots of them
18:58:25 <Cale> and the composition behaves differently on them
18:58:31 <rickasaurus> are they all unique?
18:58:41 <Cale> unique in which sense?
18:58:56 <rickasaurus> in the collection of arrows C(X,X)
18:59:07 <rickasaurus> are all arrows unique?
18:59:12 <Cale> In our category where the arrows are real numbers and composition is addition we have that 1 . 1 = 2
18:59:17 <Cale> and 1 . 2 = 3
18:59:27 <Cale> and pi . e = (pi + e)
18:59:31 <natron> hi! I'm trying to compile a program on ubuntu 9.10 with the Network library.  I can generate an object file, but it's failing to link saying it can't find Network functions
18:59:49 <natron> anybody have any experience setting up library paths with ghc?
18:59:52 <Cale> natron: Are you passing --make to ghc?
19:00:12 <natron> no, ghc -o myexe File.hs
19:00:25 <Cale> add --make
19:00:29 <rickasaurus> so we have three things, labels, arrows and compositions?
19:00:44 <Cale> rickasaurus: The labels are called objects, but yeah.
19:00:58 <natron> oh wow that's nice, thanks Cale
19:01:05 <byorgey> and don't forget the special identity arrows!
19:01:10 <rickasaurus> arrows define mappings from label to label over the defined composition?
19:01:25 <ray> identity arrows are 0
19:01:50 <Cale> The identity arrow is indeed 0 in this category
19:01:55 <rickasaurus> I'm trying hard here to pull abstractions out of these examples
19:01:57 <Cale> (there's only one)
19:02:08 <byorgey> they're not really "mappings", they're just... arrows =)
19:02:24 <Cale> rickasaurus: They are just arrows. You stick two arrows together, you get another arrow
19:02:26 <ray> yeah mapping isn't general enough
19:02:26 <byorgey> although in *some* categories they correspond to mappings/functions
19:02:35 <brx> rickasaurus: you are doing the opposite.
19:02:40 <rickasaurus> sure, arrows can be objects right?
19:02:43 <ray> arrow is the vaguest thing possible
19:02:54 <copumpkin> moo
19:02:56 <byorgey> brx: that's not really fair...
19:02:58 <ray> an arrow is the vaguest thing that fits the properties
19:02:59 <copumpkin> wow, ray is alive
19:03:05 <Cale> rickasaurus: hmm... the arrows of one category can be the objects of another, but that's getting fancy
19:03:14 <rickasaurus> ahh, I see, and the composition defines the properties
19:03:23 <ray> you can abstract away "elements" by considering only the identity arrows
19:03:54 <Cale> rickasaurus: It's kind of like asking what the elements of an arbitrary set are.
19:04:01 <rickasaurus> I'm finding it pretty hard to generalize just from the identity
19:04:04 <ray> that's useful in the aforementioned composition is addition category, because we don't care what the element is
19:04:07 <Cale> rickasaurus: They could be anything we can reason about.
19:04:38 <Cale> rickasaurus: Now, let's look at another special case for the general idea of a category
19:04:42 <rickasaurus> so the composition is the category
19:04:49 <Cale> rickasaurus: In a sense, yes.
19:05:05 <ray> composition is the important part of the definition of category
19:05:12 <Cale> But the rest of the structure is important too.
19:05:36 <Cale> If S is a set, a preorder on S is a binary relation <= such that:
19:05:44 <Cale> 1) for every a in S, we have a <= a
19:06:03 <Cale> 2) for every a,b,c in S, if a <= b and b <= c then a <= c
19:06:13 <Cale> So, reflexive and transitive
19:06:23 <Cale> (you should be reading <= as "less than or equal to")
19:06:37 <rickasaurus> it took me a minute but I got it :)
19:06:55 <Cale> This is a little different from our usual notion of "order" since it allows for things where a <= b and b <= a
19:07:13 <Cale> and for cases where a and b are just incomparable: it's neither the case that a <= b nor that b <= a
19:07:32 <Cale> But our usual notions of ordering fit into this framework anyway.
19:07:48 <rickasaurus> sure, as in programming you can define ordering in many ways
19:07:51 <Cale> right
19:07:59 <Cale> So if we have a preordered set S, we can form a category from it whose objects are the elements of S
19:08:16 <Berengal> Such as the set of natural numbers?
19:08:16 <Cale> and where there is just one arrow a -> b in the category when a <= b
19:08:18 <Cale> and no others
19:08:47 <Cale> Since a <= a, we get that there will be an "identity arrow" for every a
19:08:49 <rickasaurus> and no other elements or arrows?
19:08:52 <Cale> right
19:09:04 <Cale> So there's at most one arrow between any two objects now
19:09:10 <Cale> but many objects
19:09:26 <Cale> Where, for the other example, we had just one object, but many arrows from that object to itself.
19:09:28 <voidprayer> join #ghc
19:09:32 <voidprayer> sorry
19:09:35 <rickasaurus> I see
19:09:39 <Cale> So we're sort of exploring the two axes along which a category can grow here :)
19:10:07 <rickasaurus> so there's really a -> b, a -> a, b-> b
19:10:10 <ray> i like the second one because it's not as obvious
19:10:51 <rickasaurus> and maybe b -> a
19:10:55 <Cale> the transitivity ensures that if we have an arrow a -> b, and an arrow b -> c, then there will be an arrow a -> c which we can call their composite, but since there's only one such arrow, nothing else is needed to define it
19:11:27 <rickasaurus> that makes sense
19:11:44 <rickasaurus> a -> c is implictly defined
19:11:57 <Cale> So, for an example of such a category, we could take the objects to be the natural numbers, and put an arrow a -> b when a divides evenly into b.
19:12:40 <Cale> Or, we could take the category whose objects are the real numbers, and where there's an arrow a -> b when a <= b under the usual ordering for real numbers.
19:13:16 <rickasaurus> I'm following you on this
19:14:18 <Cale> okay
19:14:20 <rickasaurus> so just the same we could be ordering arrows of another category
19:15:00 <rickasaurus> or maybe not
19:15:11 <MAN> mm... sorry to interrupt, but is there a c2hs experienced user around?
19:15:14 <rickasaurus> as the arrow only defines the relationship
19:15:16 <Cale> I guess we could, though it's easier to preorder the objects of another category by whether there is an arrow from one to the other
19:15:49 <rickasaurus> this seems almost like prolog
19:15:52 <Cale> MAN: maybe look for dcoutts or... I forget who else uses it a lot. Probably dons is familiar.
19:16:23 <MAN> thanks, ill do that :D
19:16:26 <Cale> rickasaurus: Similarly, we could form a category whose objects are statements in some logical system, and where there's an arrow P -> Q whenever P logically implies Q
19:16:45 <Cale> Or when Q can be inferred from P according to the rules of the logic.
19:17:25 <rickasaurus> that's kind of how category works in terms of a type system right
19:17:49 <Cale> Sort of, except in our programming language we have many arrows P -> Q
19:18:03 <Cale> one for each program whose input is of type P and whose output is of type Q
19:18:28 <Cale> Which, on the logic side is the same as having an arrow for each possible proof of P -> Q
19:18:32 <rickasaurus> I see :)
19:19:09 <Cale> (there are some fiddly details which must be worked out here if you want to satisfy associativity though)
19:19:29 <Cale> (you need to take proofs up to some sort of equivalence)
19:19:54 <rickasaurus> that seems like it would very hard for a compiler to do
19:20:22 <Cale> Yeah, but we don't worry about the distinction between functions which compute the same result when we talk about programming here.
19:20:48 <Cale> So even though (f . g) . h and f . (g . h) are *slightly* different programs, we consider them to define the same function.
19:21:57 <rickasaurus> it's a strange way to define function right? as in this case f(y) = x + 1 would be infinitely many programs
19:22:13 <Cale> er, no?
19:22:26 <Cale> f(x) = x+1 might be a definition of f in the above
19:22:31 <Cale> and maybe g(x) = x^2
19:22:37 <Cale> and h(x) = 2*x
19:22:48 <EvanCarroll> name a function that a -> b -> a
19:22:53 <rickasaurus> I see
19:22:56 <EvanCarroll> where a /== b
19:23:01 <Cale> :t const
19:23:02 <lambdabot> forall a b. a -> b -> a
19:23:21 <rickasaurus> I misunderstood, you were talking about the ordering of functions themselves
19:23:53 <rickasaurus> but you can never be sure that (f. g) . h and f . (g . h) would be associative
19:24:11 <Cale> rickasaurus: Well, they're the same function in that for the same input they will always give the same result.
19:24:21 <rickasaurus> what if one were modulus
19:24:27 <Axman6> Cale: you sure?
19:24:28 <Cale> rickasaurus: Even if the series of reduction steps goes a little differently.
19:24:49 <Cale> Axman6: yeah, though I'm not making any guarantees about seq
19:24:57 <pastah_rhymez> why is there no puts function?!
19:24:59 <Axman6> what about const?
19:25:09 <Cale> Axman6: huh?
19:25:10 <pastah_rhymez> why does it constantly remind me of its absence!?
19:25:20 <Cale> pastah_rhymez: puts?
19:25:24 <ivanm> pastah_rhymez: what do you expect it to do?
19:25:25 <pastah_rhymez> Cale: State
19:25:27 <ivanm> @hoogle gets
19:25:27 <lambdabot> Control.Monad.State.Class gets :: MonadState s m => (s -> a) -> m a
19:25:27 <lambdabot> System.FilePath.Posix getSearchPath :: IO [FilePath]
19:25:27 <lambdabot> System.FilePath.Windows getSearchPath :: IO [FilePath]
19:25:38 <Axman6> > const . ((*2) . (^2)) 3
19:25:39 <Cale> pastah_rhymez: put (f x) ?
19:25:39 <lambdabot>   No instance for (GHC.Num.Num (f a))
19:25:39 <ivanm> pastah_rhymez: gets is just liftM f get
19:25:39 <lambdabot>    arising from the literal `2' at <int...
19:25:40 <pastah_rhymez> ivanm: to take a record field name and a value
19:25:43 <Axman6> > const . ((*2) . (^2)) 3 4
19:25:44 <lambdabot>   No instance for (GHC.Num.Num (t -> f a))
19:25:44 <lambdabot>    arising from the literal `2' at...
19:25:47 <Axman6> bah
19:25:52 <pastah_rhymez> puts myFieldVar newValue
19:25:54 <Cale> pastah_rhymez: oh
19:25:56 <FunctorSalad> pastah_rhymez: the fclabels package does what you want
19:26:00 <rickasaurus> hrm, I'm going to have to scroll back up and write this stuff down
19:26:04 <Cale> pastah_rhymez: Yeah, field names are not first-class.
19:26:10 <ivanm> pastah_rhymez: ummm... there's no obvious way of having a function to do \ d r v -> d { r = v }
19:26:12 <pastah_rhymez> Cale: i know
19:26:18 <ivanm> unless you use fclabels or something
19:26:28 <pastah_rhymez> but this is just fugly;
19:26:30 <pastah_rhymez> modPos f g = modify (\s -> s { current = posMod (current s) } )
19:26:30 * EvanCarroll is going to be fold[lr] god someday
19:26:32 <pastah_rhymez>     where posMod (t,r,(x,y)) = (t,r,(f x, g y))
19:26:34 <Cale> rickasaurus: I can pretty much explain what a functor (and an endofunctor) is now though :)
19:26:50 <pastah_rhymez> could puts be achieved with rewrite rules, perhaps?
19:27:08 <pastah_rhymez> because how often do you REALLY modify the WHOLE state?
19:27:10 <rickasaurus> so what is the difference?
19:27:19 <Cale> pastah_rhymez: That's a scary idea. Safer to use Template Haskell or something.
19:27:58 <pastah_rhymez> Cale: i don't know the first thing about either... how do i get started?
19:28:18 <FunctorSalad> fclabels
19:28:20 <Cale> rickasaurus: If C and D are two categories, then a functor F: C -> D is a mapping on both objects and on arrows, such that if a: X -> Y is an arrow in C, then Fa: FX -> FY is an arrow in D.
19:28:27 <Cale> rickasaurus: and such that F(id_X) = id_(FX)
19:28:37 <pastah_rhymez> FunctorSalad: didn't see your reply earlier, thanks :)
19:28:41 <Cale> rickasaurus: and such that F(a . b) = (Fa) . (Fb)
19:28:50 <FunctorSalad> (has TH macros for making first class labels already)
19:29:09 <rickasaurus> ok
19:29:37 <EvanCarroll> Cale: does const: , just ignore his other argument
19:29:43 <rickasaurus> are objects considered to be a superset of arrows?
19:29:55 <Cale> rickasaurus: uh, they're completely separate
19:30:22 <EvanCarroll> const x _        =  x
19:30:29 <rickasaurus> ahh, it almost seems like arrows can be use almost anywhere objects are
19:30:34 <Cale> rickasaurus: Though, in a sense, objects are a subset of arrows, in that you could treat the identity arrow id_X: X -> X as being the same thing as X itself. But that is probably just confusing at this point.
19:30:49 <rickasaurus> I think I understand
19:30:54 <EvanCarroll> Cale: and const permits a and b to the same type
19:31:10 <EvanCarroll> Cale: I'm looking for a function that will not be accepted in foldl, but that works in foldr
19:31:16 <Cale> EvanCarroll: ah, okay
19:31:23 <Cale> EvanCarroll: then flip (:) is good
19:31:32 <Cale> > foldl (flip (:)) [] [1..10]
19:31:33 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
19:31:43 <Cale> > foldr (flip (:)) [] [1..10]
19:31:44 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
19:31:50 <Cale> > foldr (:) [] [1..10]
19:31:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:32:36 <blackdog> is it possible to export a Haskell tuple to C through the FFI?
19:32:39 <pastah_rhymez> FunctorSalad: gee, thanks; Could not find module `Control.Monad.State'
19:32:46 <EvanCarroll> hrm
19:32:47 <rickasaurus> so what's an endofunctor?
19:32:53 <EvanCarroll> now i get to try to figure out why
19:32:56 <blackdog> or do i need to make a special purpose struct...
19:32:59 <EvanCarroll> Cale: ++ thanks for the example
19:33:00 <Cale> rickasaurus: An endofunctor is just a functor from a category to itself
19:33:24 <Cale> EvanCarroll: Consider just a one-element list to start with
19:33:24 <rickasaurus> oh. I see
19:34:09 <FunctorSalad> pastah_rhymez: uh, the mtl vs transformers mess is my fault now? :o
19:34:21 <Cale> rickasaurus: The Functor class in Haskell is really for endofunctors on the category of Haskell types where the mapping on objects is given by a type constructor.
19:34:35 <Cale> rickasaurus: and the mapping on arrows is given by fmap
19:34:49 <pastah_rhymez> FunctorSalad: nah, i just like to blame someone ;)
19:34:55 <rickasaurus> I'll have to play with fmap
19:34:56 <pastah_rhymez> how do i get out of this?
19:34:58 <jmcarthur> if i write a function that pattern matches on two arguments in one case and the first argument does not match, is the second argument forced regardless? i suspect that it is?
19:35:00 <Cale> rickasaurus: So the laws for functors translate into Haskell as  fmap (f . g) = fmap f . fmap g and  fmap id = id
19:35:08 <Cale> > fmap (*2) [1..10]
19:35:09 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
19:35:10 <kyagrd> Hi, is anyone using ghc 6.12 release condidate?
19:35:16 <Cale> > fmap (*2) (Just 5)
19:35:17 <lambdabot>   Just 10
19:35:27 <Cale> > fmap (*2) (+1) 7
19:35:27 <jmcarthur> i guess i could just try it
19:35:28 <lambdabot>   16
19:35:41 <kyagrd> I've expreienced scoping inconsistency in ghci, and I wonder if it still is the case in ghc 6.12
19:36:08 <FunctorSalad> pastah_rhymez: the problem is that "mtl" and "monads-fd" use the same module names
19:36:26 <byorgey> > let f (Just x) (Just y) = 3; f Nothing _ = 5  in f Nothing undefined
19:36:27 <lambdabot>   5
19:36:29 <FunctorSalad> you can "ghc-pkg hide mtl", or use package imports
19:36:31 <pastah_rhymez> FunctorSalad: yeah, i see that in my error message :/
19:36:38 <byorgey> jmcarthur: apparently not.
19:36:39 <kyagrd> Try ([1,2,3,4] List.\\ [1,3]) and (List.(\\) [1,2,3,4] [1,3]) in ghci run without any option. The former works but the latter doesnt :(
19:37:17 <pastah_rhymez> FunctorSalad: why not hide monads-fd?
19:37:21 <kyagrd> I don't believe there's any reason that infix operators are sliently in scope ... straine
19:37:39 <byorgey> kyagrd: try (List.\\) ?
19:37:41 <FunctorSalad> pastah_rhymez: fclabels uses monads-fd I think
19:38:07 <FunctorSalad> it's a bad situation
19:38:10 <jmcarthur> byorgey: i find that odd, really, but it works out conveniently for me in this case at least
19:38:13 <kyagrd> byorgey: List.\\ the infix operator is in scope without imporing it with :m command
19:38:33 <kyagrd> a \ is a backslash my IRC client duh
19:38:34 <byorgey> kyagrd: it's imported from the Prelude.  what's strange about that?
19:38:47 <kyagrd> byorgey: Well but why not List.(\\) then?
19:38:59 <holmak> > (\(a, b) -> a + b) undefined
19:39:00 <lambdabot>   * Exception: Prelude.undefined
19:39:09 <MakoryuOnIce> kyagrd: The syntax is Module.identifier, not Module.(expression)
19:39:12 <kyagrd> Oh my bads sorry
19:39:21 <holmak> > (\(x:xs) b -> a + b) 42 undefined
19:39:22 <lambdabot>   No instance for (GHC.Num.Num [t])
19:39:22 <lambdabot>    arising from the literal `42' at <inte...
19:39:26 <holmak> oops
19:39:28 <jmcarthur> > let f (Just x, Just y) = 3; f (Nothing, _) = 5 in f (Nothing, undefined)
19:39:29 <lambdabot>   5
19:39:30 <holmak> > (\(x:xs) b -> a ++ b) 42 undefined
19:39:31 <lambdabot>   No instance for (Data.Monoid.Monoid SimpleReflect.Expr)
19:39:32 <lambdabot>    arising from a u...
19:39:33 <byorgey> kyagrd: because it's  (List.\\), not  List.(\\)
19:39:44 <jmcarthur> > let f (Just x, Just y) = 3; f (Nothing, _) = 5 in f (Just 1, undefined)
19:39:45 <lambdabot>   * Exception: Prelude.undefined
19:39:54 <jmcarthur> oh, right
19:40:02 <kyagrd> My issue is ... (\\) is not in scope ...
19:40:03 <Axman6> holmak: you're trying to mastch a number to a list...
19:40:16 <kyagrd> So prelude imports it as qualified? List.\\
19:40:26 <kyagrd> Didn't know that
19:40:30 <holmak> I know, I was wondering about jmcarthur's question about failed matches not forcing evaluation
19:40:42 <holmak> And coming up with terrible tests
19:40:52 <byorgey> kyagrd: actually, sorry, it's not imported from the prelude
19:41:01 <byorgey> kyagrd: you can just always refer to anything as ModuleName.name
19:41:08 <byorgey> even if that module is not imported
19:41:13 <jmcarthur> holmak: apparently failure of the first part of a pattern means the rest of it is not forced
19:41:23 <holmak> good to know!
19:41:31 <byorgey> kyagrd: 'List' is the original Haskell98 name of what is now known as Data.List
19:42:01 <holmak> What's the status on Haskell' ?
19:42:23 <jmcarthur> holmak: i haven't checked the spec though, so i don't know if that is even specified
19:42:33 <jmcarthur> i would think it would be
19:42:39 <holmak> Definitely a fascinating edge case
19:42:49 <holmak> well, important, if not fascinating
19:44:17 <EvanCarroll> how come this doesn't work
19:44:19 <EvanCarroll> let a = (flip (:)) in [1,2,3] a 5
19:44:24 <EvanCarroll> I think haskell hates me today
19:45:33 <holmak> EvanCarroll: I believe it is because "a" is not an infix operator
19:46:08 <holmak> try let a = (flip (:)) in [1,2,3] `a` 5
19:46:20 <holmak> you know about backticks?
19:46:24 <EvanCarroll> yea
19:46:26 <cjs> Hm. I wonder if someone here might know. There was a video with Guy Steele and another guy discussing the history of Lisp and/or functional programming, done in sort of a Ginsberg style. Does anyone know what it is and where I might find it?
19:46:31 <EvanCarroll> ah that works
19:46:33 <EvanCarroll> =)
19:46:57 <holmak> infix operators are kinda funky
19:49:28 <medfly> cjs, http://video.google.com/videoplay?docid=-8860158196198824415&ei=F1gLS-n7FYe62wL_9Lj8CA&q=guy+steele&view=2# ?
19:50:04 <medfly> cjs, I haven't actually looked at the contents
19:50:11 <EvanCarroll> that was more me being stupid than it being funky
19:50:18 <Adamant> I love how the Twilight trailer is a related video
19:53:05 <cjs> No, that doesn't seem to be the one. The one I'm thinking of had two presenters, and they alternated back and forth speaking.
19:54:26 <EvanCarroll> Adamant: money makes the googles go around.
19:55:00 <Adamant> EvanCarroll: I thought they only got paid if they got a click
19:55:09 <Adamant> which they won't be getting from me on that one, at least
19:57:36 <EvanCarroll> they only get paid if they get a click, but a shitty click through I believe has negative effects on the ad
19:57:53 <EvanCarroll> I think it either reduces exposure or raises the rate (or both)
19:57:54 <EvanCarroll> I forget
19:58:56 <EvanCarroll> but the law of spam still applies
19:59:12 <EvanCarroll> the rate of success is always positive and non-zero if you do it enough
20:04:16 <pastah_rhymez> medfly: that video is good :)
20:04:53 <pastah_rhymez> is haskell what he would call a "large language"?
20:06:38 * medfly didn't actually watch it, but just googled some to try to help cjs :)
20:06:50 <cjs> medfly: Thanks anyway.
20:13:51 <jmcarthur> i like "growing a language"
20:17:12 <medfly> it does look interesting :-)
20:17:22 <medfly> that's some task he took on himself :-)
20:17:24 <pastah_rhymez> i love how he speaks
20:21:57 <ivanm> anyone have any idea when gtk2hs will be updated for use with 6.12?
20:43:16 <pastah_rhymez> FunctorSalad: how does mkLabels work for fclabels? i follow the instructions but i can't get it to work :(
20:43:19 <pastah_rhymez> http://hackage.haskell.org/packages/archive/fclabels/0.4.1/fclabels.cabal
20:43:32 <pastah_rhymez> <interactive>:1:11:
20:43:33 <pastah_rhymez>     lexical error in string/character literal at character '\''
20:44:47 <FunctorSalad> pastah_rhymez: enable template haskell
20:45:07 <FunctorSalad> @fact-set th {-# LANGUAGE TemplateHaskell #-}
20:45:07 <lambdabot> Fact recorded.
20:45:28 <pastah_rhymez> FunctorSalad: oh, so that's what's missing, thanks
20:45:58 <pastah_rhymez> this is going to be soooo swell :)
20:46:18 <Axman6> hmm, it's been a while since i've seen any interesting haskell articles :(
20:46:25 * Axman6 heads to p.h.o
20:48:59 <pastah_rhymez> FunctorSalad: aww man, same error. The tutorial tells me to run (mkLabels [''GS]) where GS is the constructor for my GameState, but i only get the lexical error for "''" when i run it in ghci
20:50:08 <FunctorSalad> template haskell should enable the ''Thing syntax
20:50:50 <kmc> , ''Maybe
20:50:53 <lunabot>  Data.Maybe.Maybe
20:52:16 <aavogt> , 'Maybe
20:52:18 <lunabot>  luna: Not in scope: data constructor `Maybe'
20:52:23 <kmc> , 'Just
20:52:24 <lunabot>  Data.Maybe.Just
20:52:24 <aavogt> , 'Nothing
20:52:26 <lunabot>  Data.Maybe.Nothing
20:52:40 <kmc> , [$ty| Just |]
20:52:44 <lunabot>  forall a . a -> Maybe a
21:01:00 <manju> hello
21:01:13 <manju> I am trying to learn haskell
21:01:17 <kmc> hi manju :)
21:01:27 <manju> hi kmc
21:01:36 <manju> in this example
21:01:37 <manju> minBound :: Int
21:01:46 <kmc> > minBound :: Int
21:01:47 <lambdabot>   -9223372036854775808
21:01:59 <manju> it says minBound is polymorphic constant
21:02:06 <manju> what is a polymorphic constant ?
21:02:08 <Axman6> indeed it is
21:02:18 <kmc> manju, the type is:
21:02:19 <Axman6> > minBound :: word8
21:02:20 <kmc> :t minBound
21:02:20 <lambdabot>   Could not deduce (GHC.Enum.Bounded word8) from the context ()
21:02:21 <lambdabot>    arising fr...
21:02:21 <lambdabot> forall a. (Bounded a) => a
21:02:25 <Axman6> > minBound :: Word8
21:02:26 <lambdabot>   0
21:02:32 <Axman6> > minBound :: Bool
21:02:33 <lambdabot>   False
21:02:38 <kmc> manju, it can have any type "a" so long as "a" is in the typeclass Bounded
21:02:47 <kmc> i.e., there is a minBound for every Bounded type, possibly a different one
21:02:51 <kmc> > minBound :: Char
21:02:52 <lambdabot>   '\NUL'
21:02:53 <Axman6> @instances Bounded
21:02:54 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
21:03:06 <kmc> manju, the syntax is (e :: t) and it's called a "type signature" or "type annotation"
21:03:10 <kmc> e is an expression and t is a type
21:03:58 <kmc> normally they're not necessary but sometimes polymorphism is ambiguous.  in this case there's an implicit "show", where lambdabot or ghci or whatever prints out your expression
21:04:02 <kmc> :t show minBound
21:04:03 <lambdabot> String
21:04:11 <kmc> > show minBound
21:04:12 <lambdabot>   "()"
21:04:17 <manju> ok...
21:04:23 <kmc> okay, bad example -- it's been arbitrarily defaulted to the type ()
21:04:25 <kmc> forgot about that
21:04:53 <Axman6> manju: basically, it has a different value, depending on the type which is it being used as
21:05:15 <manju> ah...
21:05:15 <kmc> > minBound :: (Char, Int, Bool)
21:05:16 <lambdabot>   ('\NUL',-9223372036854775808,False)
21:05:26 <Axman6> @src Bounded
21:05:26 <lambdabot> class  Bounded a  where
21:05:26 <lambdabot>     minBound, maxBound :: a
21:05:44 <kmc> > maxBound :: ((Word8, Word16), (Word32, Word64))
21:05:44 <lambdabot>   ((255,65535),(4294967295,18446744073709551615))
21:05:52 <manju> This is amazing
21:05:52 <Axman6> manju: basically, if you have a type which implements Bounded, you must define the minBound and a maxBound
21:06:50 <manju> so minBound is not a function ?
21:07:01 <Axman6> it is a function, just one that doesn't take any arguments
21:07:11 <manju> sorry if my newbness is showing, but a function is a function in haskell right ?
21:07:27 <Axman6> not sure what you mean
21:07:44 <kmc> manju, minBound is not a function.  it doesn't have arguments
21:07:51 <manju> how is it any different from template <sometype> minBound
21:08:06 <Gracenotes> whenever you need to call maxBound or minBound, GHC gives you a lookup table that contains both of them. It might know at compile time what specific table to give you (like for Int), or maybe it doesn't
21:08:07 <kmc> manju, templates are C++'s (broken) way of handling parametric polymorphism
21:08:09 <manju> sorry I come from a C++ background
21:08:17 <Axman6> manju: you poor thing :(
21:08:25 <manju> heh
21:08:27 <kmc> we can't say specifically how it's different because they're very different languages
21:08:27 <Gracenotes> that is how typeclasses can provide nice runtime dispatch, effectively
21:08:33 <blackh> manju: Functions can be polymorphic on their return type, even ones with zero arguments.
21:08:44 <kmc> there are no functions with zero arguments!
21:08:50 <kmc> every function in haskell has exactly one argument
21:09:15 <kmc> in Haskell the point of a function is to map input values to output values, as in maths.  same input implies same output, no side effects
21:09:16 <Gracenotes> ..at least until some point in compilation >_>
21:09:36 <kmc> orthogonal concepts like side effects and polymorphism are handled by orthogonal features
21:09:45 <kmc> unlike most languages which mash them all into "function"
21:09:59 <blackh> manju: Let me state this in a more kmc-friendly way: A _value_ like minBound can be defined differently depending on its type - this is done through type classes.
21:10:15 * kmc is glad he is being catered to
21:10:38 <blackh> kmc: Would you like a cup of tea?
21:10:50 <kmc> @vixen Would you like a cup of tea?
21:10:50 <lambdabot> i'd say i like
21:11:16 <Gracenotes> #haskell has enterprise kmc-friendliness, leveraging kmc into our synergasmic product
21:11:17 <lunabot>  luna: Not in scope: `haskell'
21:11:21 <Gracenotes> :o
21:11:22 <manju> ah...so it is like, I define a variable and that depending on what type it is called as returns different types ?
21:11:32 * orbitz runs around naked
21:11:58 <Axman6> manju: yeah, that's basically it (it sounds like you've basically got the idea)
21:12:02 <kmc> @vixen are you synergasmic?
21:12:02 <lambdabot> i truely am
21:12:12 <manju> that is so cool
21:12:28 <Gracenotes> manju: and not just different types, different values specifically defined for each type
21:12:29 <Axman6> manju: it's all to do with type inference i guess
21:12:56 <kmc> manju, yes, but the terms "call" and "return" are not applicable
21:13:04 <kmc> it's just a family of values, indexed by type
21:13:09 <Berengal> you could read values with constrained types as functions with (some) arguments supplied automatically by the compiler
21:13:11 <Axman6> heh
21:13:31 <blackh> manju: It's very cool! Type classes can be selected on any input value, but also on the basis of the return value - even if it's a value and not a function.
21:13:32 <Axman6> i hate how honest people are in here, it makes it very hard for newbies to understand them
21:13:40 <orbitz> Hah
21:13:46 <kmc> i'd say "you define a variable; depending on what type it is *used* it *evaluates* differently"
21:14:10 <orbitz> So I think i'm goign to try to write this app at work in Python and concurently in Haskell and hopefully get a good comparison
21:14:12 <kmc> i may sound pedantic but there's a long process of removing bad intuition built by inferior languages, and we'd like to help you :)
21:14:16 * kmc hands over a glass of kool-aid
21:14:20 <manju> I think I will log this conversation, because I only understand 20% of it
21:14:31 <manju> I will read it once I learn more
21:14:40 <Gracenotes> manju: are you somewhat familiar with vtables?
21:14:42 <mmorrow> manju: this channel is logged
21:14:48 <kmc> THIS PHONE IS TAPPED
21:14:48 <orbitz> manju: for me, a lot of Haskell stuff makes sense after i've messed with it like 50 times
21:14:54 <Axman6> manju: it would be helpful if you could forget all the C++ you know before learning haskell. it has poluted your brain
21:15:02 <orbitz> haha
21:15:11 <manju> Axman6, yeah I know
21:15:32 <Axman6> and don't worry about getting the names of things 100% correct
21:15:34 <ddarius> What?!  C++'s template system is a lazy, purely functional language.
21:15:38 <manju> I have been trying to write a program to print a list in haskell and I've been running around in circles
21:15:55 <kmc> ddarius, unfortunately C++'s template system is nothing like C++
21:15:59 <kmc> manju, "print"?
21:16:01 <manju> but I am getting there slow
21:16:04 <kmc> doing IO is a poor way to learn Haskell
21:16:11 <kmc> load up GHCi and write some "pure" functions
21:16:13 <kmc> maybe do Project Euler
21:16:14 <Axman6> manju: forget IO. it has been purposely made difficult in haskell to discourage you from using it too much
21:16:25 <kmc> manju, your intuition about functions being involved is not totally wrong; most Haskell implementations will *implement* typeclasses by explicitly passing around a structure of the type-specific implementations.  but that's hidden from the user
21:16:25 <Berengal> Project Euler is a great way to learn Haskell
21:16:27 <manju> Project Euler ?
21:16:32 <kmc> @google Project Euler
21:16:33 <lambdabot> http://projecteuler.net/
21:16:34 <lambdabot> Title: Project Euler
21:16:43 <manju> hmmmm
21:16:43 <stelleg> nice bot
21:16:51 <Axman6> project euler helped me learn a lot about haskell
21:16:52 <Berengal> PE was actually what got me hooked in Haskell in the first place
21:16:56 <Berengal> It's where I realized its power
21:17:07 <kmc> @bot
21:17:07 <lunabot>  :o
21:17:07 <lambdabot> :)
21:17:30 <Berengal> I started doing it in java and got like 10 problems. Then I moved to python and got about 30. When I moved to Haskell, I got to 60
21:17:54 <toast-opt> ddarius, it's _sometimes_ lazy
21:17:55 <Axman6> manju: also, if you do decide to play with PE, don't feel bad if you can't do one of the early problems. some of them are fairly difficult
21:18:02 <Berengal> Most of them by simply encoding the problem in haskell directly
21:18:08 <dibblego> Berengal, http://functionaljava.googlecode.com/svn/branches/projecteuler/
21:18:28 <orbitz> ugh functional java
21:18:29 <manju> Axman6, ok
21:18:42 <kmc> manju, you can (and should) learn the basics of Haskell without any explicit IO.  it's not that Haskell is bad at IO, but it's trickier to get Haskell IO from a C++ or similar background
21:18:50 <tensorpudding> functional java, isn't that what scala is supposed to be
21:18:59 <tensorpudding> wait, no, that's the dynamic java
21:19:00 <Berengal> Is functional java in a maven repo somewhere? Because I'd totally use that at work if it were
21:19:03 <kmc> and it's not as important, because we have good interactive Haskell environments
21:19:26 <kmc> (which has nothing to do with compilers vs interpreters, functional programming, or types; it's just a common-sense usability feature that many popular languages lack)
21:19:30 <dibblego> Berengal, I am not responsible for the maven build, but you might like to hassle the person who is (maybe he's up to date)
21:19:33 <Axman6> manju: IO in haskell is special, and from a newbies point of view, an advanced topic. the stuff you need to learn about haskell is all pure
21:19:34 <mmorrow> kmc: environments?
21:19:48 <manju> Axman6, ok
21:19:52 <Berengal> dibblego: I'll look into it
21:19:59 <BMeph> Berengal: Here's something for you to Really go "Ugh!" about:
21:20:02 <toast-opt> kmc, i'm constantly confused why java, C#, C++, ... why these languages still lack good interactive modes
21:20:02 <manju> Thanks for pointing out the right way
21:20:05 <dibblego> Berengal, if you cannot find it, email the list
21:20:07 <mmorrow> kmc: i know of one, that you can't define data/newtype/class/instance in.. (not to complain of course :)
21:20:08 <BMeph> @google Haskell MPS
21:20:08 <lambdabot> http://hackage.haskell.org/package/mps
21:20:09 <lambdabot> Title: HackageDB: mps-2009.11.7
21:20:29 <kmc> mmorrow, okay, point taken.  we *have* interactive environments
21:20:31 <mmorrow> well, one actively maintained one
21:20:37 <BMeph> Berengal: ^^ How's Haskell re-done to look more OO-ish grab you? ;p
21:20:43 <Axman6> manju: and biggest tip of all: stick around here, #haskell is the #1 resource for haskell beginners. those who don't use it tend to learn the language quite slowely
21:20:45 <kmc> and they're actually used by most programmers, unlike the C REPLs
21:20:46 <Axman6> -e
21:20:48 <mmorrow> kmc: plural?
21:20:56 <kmc> GHCi and lambdabot :D
21:21:26 <mmorrow> lambdabot: i don't think the bots really count, since they're essentially ghci minus some capabilities
21:21:39 <toast-opt> and hugs?
21:21:43 <kmc> toast-opt, because the enterprise way is to touch one C++ header file then get a nice hour long coffee break while you rebuild
21:22:10 <mmorrow> toast-opt: ah yeah, i guess hugs counts
21:22:16 <kmc> because in C++ the design decisions of parametric polymorphism, file layout, and inlining optimizations are all deeply intertwined
21:22:17 <manju> Axman6, ok...thanks, I will
21:22:22 <toast-opt> kmc, the longest module i've seen took 15 minutes to build.  of course, i had an 8GB 4 core box
21:22:29 <Berengal> BMeph: could be worse. There could be curly braces...
21:22:32 <Axman6> manju: are you following any specific tutorial?
21:22:32 <kmc> what's a "module"?
21:22:35 <toast-opt> so that's like 2 normal machine hours
21:22:51 <manju> Axman6, learnyouahaskell.com
21:22:55 <Axman6> good work
21:23:06 <kmc> manju, that's a good one.  check out RWH too
21:23:07 <kmc> @where RWH
21:23:09 <toast-opt> @google LYAH
21:23:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:23:18 <lambdabot> http://www.lyahbethleflore.com/
21:23:18 <BMeph> Berengal: The man redefines '^', for crying out loud! I think that's where I draw the line. :\
21:23:20 <lambdabot> Title: Lyah Beth LeFlore - Available Books
21:23:24 <toast-opt> eh, that didn't work
21:23:40 <toast-opt> @where LYAH
21:23:41 <lambdabot> www.learnyouahaskell.com
21:23:41 <toast-opt> ?
21:23:43 <Berengal> BMeph: I'm crying inside, but I pretend to be manly about it
21:23:44 <toast-opt> :)
21:24:01 <toast-opt> LYAH is my new favoritist tutorial ever
21:24:29 <toast-opt> esp the art.  i need to frame some of that, put it on a wall
21:24:39 <BMeph> Say, is there a Haskell' mailing list, or do folks just kvetch in-channel? ;)
21:24:58 <kmc> there's a trac
21:25:11 <manju> http://www.lyahbethleflore.com/ where is the haskell book here
21:25:22 <manju> all I see are some novels
21:25:24 <kmc> manju, google failed
21:25:29 <kmc> it's the site you already had
21:25:32 <manju> kmc, ah
21:25:33 <Axman6> that site has nothing to do with haskell, just google failing
21:25:44 <kmc> apparently there are people named "lyah"
21:25:54 <kmc> which i can only hope is pronounced like "hell yeah"
21:25:56 <manju> hehe
21:26:00 <toast-opt> yeah, my bad :(
21:26:22 <manju> thankfully it was work safe
21:26:50 <toast-opt> yeah, don't google without a content filter on corperate net
21:26:51 <dons> ?yow
21:26:51 <lambdabot> Couldn't find fortune file
21:27:13 <Axman6> :(
21:27:22 <medfly> @nixon
21:27:23 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
21:27:33 <kmc> @. elite nixon
21:27:33 <lambdabot> pE0p|E rEA(T T0 ph34R, NO7 lo\/3; +H3y dON't 734C|-| 7|-|at in zundAy SchOO1, bUT It'z0rz +ruE.
21:27:47 <kmc> nixon has so many great leet-words
21:27:53 <medfly> :)
21:27:55 <kmc> ph34r, FaGz
21:28:00 <kmc> @. elite nixon
21:28:00 <lambdabot> I BRouGhT mYse|f DowN. I i/\/\p3aCheD Myselph 8y r35IGnIng.
21:28:01 <tensorpudding> @botsnack
21:28:01 <lambdabot> :)
21:28:01 <lunabot>  :o
21:28:21 <medfly> it's funny that it's using leet but saying "impeached" :)
21:28:32 <kmc> i will squash u like the bug u are
21:28:38 <kmc> @protontorpedo
21:28:38 <lambdabot> so why would one prefer haskell to say clisp or smalltalk?
21:28:42 <kmc> @protontorpedo
21:28:43 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
21:28:43 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
21:28:50 <kmc> that's my favorite one
21:29:11 <Berengal> That one is lol indeed
21:29:27 <medfly> what is @protontorpedo?
21:29:45 <Gracenotes> a quote engine. of sorts.
21:29:48 <Axman6> dons: while you're around, any chance i could get you to change my url on planet.haskell.org? it's still pointing to my old site (it should point to http://axman6.com/blog/ under Alex Mason)
21:30:24 <toast-opt> hey, curious question.  does haskell have any serializable functions, like plt's continuation-based server lib?
21:30:43 <manju> should I be scared of monads
21:30:45 <dons> Axman6: did you email the admins?
21:30:45 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:30:51 <kmc> manju, no, but you should learn the basics first
21:30:58 <kmc> for example, "Monad" is a typeclass, so you should learn about those
21:31:00 <Gracenotes> medfly: by someone who was once in this channel, I'm guessing
21:31:00 <manju> kmc, ok
21:31:07 <Axman6> dons: i thought that was you. i can do that :)
21:31:10 <kmc> manju, Haskell is not "about" monads
21:31:11 <stelleg> @prontontopedo
21:31:11 <lambdabot> cant u just have data in arrays and do operations using you prog lang?
21:31:16 <kmc> they're just one particular, powerful tool we have
21:31:21 <manju> ok
21:31:24 <Berengal> toast-opt: only though the erlang library, I think... not natively
21:31:27 <kmc> and in fact they're not much of a language feature and can be implemented in many languages
21:31:29 <manju> why does everyone talk about that ?
21:31:42 <kmc> manju, because they have a strange name and are not common in other languages
21:31:47 <Gracenotes> I think you might call some people who have special quite commands trolls.
21:31:47 <manju> ok
21:31:52 <toast-opt> berengal: through erlang library?  how so?
21:31:56 <stelleg> they are a mathematical construct, no?
21:32:13 <kmc> toast-opt, i'm not familiar with plt.  as far as what i think of when you say "serializable functions"... yhc has something, and there's always eval from e.g. hint
21:32:22 <Axman6> manju: the reason you'll meet monads is that IO is implemented as a monad in haskell (so it at least looks pure)
21:32:38 <Berengal> toast-opt: well, it allows you to use haskell as an erlang node, and since erlang has serializeable functions, haskell should have them through that library too... You probably can't use regular functions though
21:32:43 <manju> Axman6, ok
21:32:49 <kmc> Berengal, i don't think that follows
21:32:49 <Berengal> toast-opt: but that's just me hypothesizing
21:33:01 <kmc> it just implements the erlang network protocol
21:33:06 <kmc> not a whole VM
21:33:12 <toast-opt> kmc, eh, plt's servlets had a funny feature where you could call/cc to respond to the client request, embedding urls that contained further computation to perform.  basically, you stash state in the form of a continuation in the page you serve to the client
21:33:20 <kmc> oh, haha
21:33:22 <toast-opt> ... leaving no state lingering behind on the server
21:33:23 <kmc> that's pretty cool
21:33:34 <kmc> yay for executing code that clients send you
21:33:44 <c_wraith> hopefully it's signed :)
21:33:47 <kmc> hehe
21:33:48 <toast-opt> pure, functional, security hole you can drive a truck thru if you don't follow the directions and authenticate your continuations
21:34:04 <Berengal> toast-opt: that sounds wrong on so many levels
21:34:10 <toast-opt> c_wraith: with an hmac, if you're smart
21:34:38 <kmc> toast-opt, you can use continuations like that in Haskell, but you'd have to keep them server-side and send a lookup key of some kind
21:34:41 <toast-opt> berengal: hey, i code C++ for a day job.  when i come home, i want to code in all the wrong ways i'm not permitted to in a work environment
21:34:58 <toast-opt> kmc, of course.  the 'stateful' version of plt does something similar
21:35:07 <medfly> huh, so work is about writing really good code?
21:35:11 <Berengal> toast-opt: I use agda for that :)
21:35:15 <medfly> I thought it's the other way around
21:35:17 <ac> any tips or ideas for writing a "comet" web app in Haskell?
21:35:29 <toast-opt> medfly, it's for writing dull code.  i never write ungood code :)
21:36:00 <toast-opt> medfly, home is for things like haskell, and learning what's out there.  like threading state through the client's web browser :S
21:36:41 <Berengal> toast-opt: I've threaded enough state through the client at work to not want to do that particularely much anymore
21:37:04 <toast-opt> berengal, hey, i only tried it once :)
21:37:10 <kmc> i've "threaded" my "state", if you know what i mean
21:37:18 <toast-opt> zing
21:37:25 <kmc> @vixen zing
21:37:26 <lambdabot> f
21:37:32 <kmc> @. vixen nixon
21:37:32 <lambdabot> Most guys don't understand me, but we really seem to connect.
21:37:36 <toast-opt> note to self, no #haskell at work
21:37:38 <kmc> @. vixen nixon
21:37:38 <lambdabot> I hear ya!
21:37:52 <ac> (comet being a long polling style of ajax to push events to the browser)
21:37:54 <Berengal> toast-opt: me too, but unfortunately the state contained about 20'000 objects from a query. Pagination didn't help us then...
21:38:18 <toast-opt> ac, i dunno, but that sounds interesting
21:38:27 <toast-opt> i don't know much about comet
21:38:42 <ac> toast-opt: it's just a matter of blocking a request until something else happens
21:38:43 <toast-opt> berengal 8-|
21:39:14 <ac> so if there was some sort of event based HTTP server in Haskell, that would be ideal
21:39:16 <toast-opt> berengal, i think plt's stateless servlets cap the state at 16K or so
21:39:20 <ac> like the new Node project
21:39:36 <Berengal> toast-opt: on the upside, we optimized that part of the app so much that once we figured client-side state was the problem, switching to server-side made it lightning fast
21:40:15 <toast-opt> heh, as long as it all turned out for the best
21:40:33 <Berengal> It was still written in Java, so no :(
21:40:37 <toast-opt> i still have nightmares of string copies :S
21:41:12 <toast-opt> 'void somefun(std::wstring s) { doStuf(something+s+anotherThing); }'
21:41:27 <kmc> software transmitted disease
21:41:48 <toast-opt> at one point, i think we estimated string copies made up 25% of runtime or more
21:42:06 <kmc> ugh and taking s by value
21:42:10 <toast-opt> yeah
21:42:16 <kmc> why not "const std::wstring& s"
21:42:20 <toast-opt> we tried string replace... but...
21:42:27 <toast-opt> some of the funs were mutating
21:42:46 <kmc> i like how C++ is designed without garbage collection, for efficiency... and the result is pessimistic copying everywhere
21:43:01 <toast-opt> kmc, well, copying is fast :)
21:43:27 <ac> hmm, the happstack server claims to do this well
21:43:43 <toast-opt> pass by ref is good if you start with it.  but if you don't, you'll find dozens of crashes where you accessed danging references
21:44:03 <ddarius> Why wouldn't you start with it?
21:44:23 <toast-opt> lots of devs new to C++
21:44:34 <toast-opt> or, new to 'new-style C++'
21:44:44 <Berengal> Those should still be in school
21:44:50 <BMeph> Does anyone understand the logic of making '^' be an argument-flipped fmap? :\
21:44:56 <Berengal> Don't hire people who don't know their stuff
21:45:07 <toast-opt> it's tough, they don't teach C++ in schools
21:45:28 <Berengal> toast-opt: Don't program in C++ then?
21:45:31 <toast-opt> and there's never enough time for training
21:45:35 <kmc> the irony is that "C in a .cpp file" is more maintainable than "idiomatic" C++, unless the author is an expert and a genius
21:45:39 <toast-opt> berengal: don't even get me started about that!
21:45:42 <kmc> C++ is the ultimate case of "a little knowledge is a dangerous thing"
21:46:12 <toast-opt> kmc, heh, i assume you've read bits of the C++ FQA?
21:46:15 <kmc> hehe
21:46:20 <kmc> just started today
21:46:29 <toast-opt> ah, that thing is a treasure trove
21:46:33 <kmc> hey let's overload every operator and make implicit conversions for everything.  that will leverage user intuition and cut costs!
21:46:48 <toast-opt> don't get me wrong, i like C++.  but so much of that hits home!
21:46:50 <kmc> nothing like having "a+b" be a multi-millisecond computation that could throw an exception
21:46:57 <Berengal> What I don't get is why Java declawed C++, only to retain all the stupid stuff it doesn't need anymore, like a separation between primitive types and classes...
21:47:07 <toast-opt> ugh, we had a couple of implicit conversion problems too
21:47:51 <toast-opt> yeah, but don't type classes have the whole 'a+b could do anything' thing?
21:48:15 <kmc> oh but it's lazy, anything could do anything ;)
21:48:20 <toast-opt> heh
21:48:23 <kmc> just printing out an Int can force an arbitrary amount of computation
21:48:24 <toast-opt> true
21:48:33 <mmorrow> intstance Num Asdf where (+) = error "try to guess where this error is coming from! ahaha!@"
21:48:41 <toast-opt> i bet haskell programmers spend more of the time they saved actually thinking of the runtime perf
21:48:57 <kmc> C++ makes a big deal about being machine-speed, sacrifice nothing on efficiency, but it makes efficiency woefully opaque
21:48:58 <ddarius> I doubt it.
21:49:06 <toast-opt> C programmers are too busy, so can't analyze anything more complicated than a double-nested-for-loop
21:49:09 <kmc> not as bad as Haskell, but much worse proportional to the niche they claim to inhabit
21:49:24 <manju> Where are the answers to Euler Project problems ?
21:49:36 <toast-opt> manju - it tells you if you answer it right
21:49:47 <kmc> "You can get fast programs, but you have to work for them. In this respect, using Lisp is like living in a rich country instead of a poor one: it may seem unfortunate that one has to work to stay thin, but surely this is better than working to stay alive, and being thin as a matter of course." -- Paul Graham, _On Lisp_
21:49:53 <toast-opt> the answer's aren't the interesting part though. the solutions are interesting
21:49:58 <kmc> manju, 5
21:50:28 <toast-opt> 5?
21:50:37 <kmc> the answers are numbers
21:50:40 <kmc> some of them are probably 5
21:50:44 <toast-opt> haha
21:50:51 <toast-opt> actually, i don't think any are
21:50:57 <kmc> the truth is five, but men have only one name for it
21:51:06 <toast-opt> i like the one that was like a bajillion digits long
21:51:28 <toast-opt> i'm like "it can't possibly want the actual number... just the position in the sequence"
21:51:40 <toast-opt> 1000 digits later or so...
21:51:51 <ddarius> Project Euler should be done in Agda or Coq or some such so that one can prove that the answer is correct.
21:51:56 <kmc> haha
21:51:59 <kmc> ooh, that's a good idea
21:52:03 <kmc> i need to learn me some more of that agda
21:52:20 <copumpkin> it's fun!
21:52:22 <mmorrow> does agda have arbitrary precision Integers?
21:52:27 <toast-opt> ddarius: if there's one thing i learned about contract-based programming, it's that checking the answer is easier than proving it
21:52:33 <copumpkin> mmorrow: arbitrary precision unary naturals ;)
21:52:34 <kmc> mmorrow, better.  it has inductive naturals ;)
21:52:43 <mmorrow> seems like project euler would be pretty painful without those
21:52:46 <mmorrow> heh, yeah..
21:52:53 <mmorrow> , 10000 ^ 10000
21:52:54 <lunabot>  1000000000000000000000000000000000000000000000000000000000000000000000000...
21:52:59 <copumpkin> :)
21:53:03 <kmc> aren't a lot of them just "find the smallest x such that p"?
21:53:03 <toast-opt> > 128^128
21:53:04 <Berengal> I still haven't done the first PE problem in ahda
21:53:04 <lambdabot>   528294531135665246352339784916516606518847326036121522127960709026673902556...
21:53:06 <Berengal> agda*
21:53:08 <kmc> you can prove that that combinator is correct for all p
21:53:12 <toast-opt> much more interesting looking, powers of 2 in decimal
21:53:20 <Berengal> I always get stuck on which syntax I want for the range function
21:53:23 <kmc> > (128 ^ 128) :: Natural
21:53:27 <lambdabot>   mueval-core: Time limit exceeded
21:53:31 <kmc> > 5 :: Natural
21:53:32 <lambdabot>   5
21:53:38 <ddarius> toast-opt: The Project Euler web site might have the wrong answers.
21:53:42 <manju> ah...cool
21:53:52 * manju figured it out
21:53:55 <toast-opt> ddarius: "somebody on the internet is wrong"
21:54:02 <medfly> oh no!
21:54:09 <medfly> we must correct this!
21:54:10 <toast-opt> http://xkcd.com/386/
21:54:15 <mmorrow> kmc: it's like with CReal, it's awesome until you actually need to do a non-trivial computation with it
21:54:41 <mmorrow> hmmm, actually gmp has an arbitrary precision float type
21:55:06 <mmorrow> i tried adding the MPFR arb prec float pkg to lunabot, but i think it's borked on lunabot's machine or something
21:55:09 <kmc> hmm even in an unrelated joke of only four lines he manages to work in a reference to sex
21:55:20 <mmorrow> because something verrrrry strange happens when you try to use it
21:55:29 <ddarius> mmorrow: Once you have arbitrary precision integers, arbitrary precision floats is just a matter of implementing the algorithms using them.
21:55:30 <kmc> are arbitrary floats different from ratios of integers?
21:55:56 <toast-opt> kmc - my guess is that it would lazily evaluate digits
21:55:58 <ddarius> kmc: Yes and no.
21:56:12 <mmorrow> ddarius: well true, in the same sense that once you have brainfuck anything else is just a matter of losing your sanity until...
21:56:39 <kmc> we could also use arbitrary-but-fixed (non-scalable) integers and fixed-precision
21:56:51 <ddarius> mmorrow: The algorithms are more or less the same given finite or arbitrary precision integers.
21:56:55 <toast-opt> can CReal do sqrt?  non-integer powers?
21:57:07 <ddarius> mmorrow: They are probably quite a bit easier with arbitrary precision integers.
21:57:20 <mmorrow> ddarius: wait, what algorithms are we talking about now?
21:57:39 <ddarius> mmorrow: Floating point addition, multiplication, division, exponentiation, etc.
21:57:43 <mmorrow> those that you would need to implement to
21:57:47 <mmorrow> ah
21:58:02 <BMeph> @hackage Typefuck
21:58:02 <lambdabot> http://hackage.haskell.org/package/Typefuck
21:58:25 <mmorrow> ddarius: it would be interesting to see how efficient you could make a "pure haskell" (using Integer) implem of arbitrary prec floats
21:58:37 <kmc> @hackage crazy-superbud-that-if-smoked-would-bring-about-world-peace
21:58:38 <lambdabot> http://hackage.haskell.org/package/crazy-superbud-that-if-smoked-would-bring-about-world-peace
21:59:00 <ddarius> mmorrow: Depends on the usage pattern, and most of the really big number stuff is a matter of good algorithms.
21:59:27 <mmorrow> kmc: you'd have the gmp Integer implem (as exposed via Integer) at your disposal
21:59:32 <mmorrow> s/kmc/ddarius/
22:03:08 <mmorrow> hmm, actually MPFR seems to be ok for the most part. i can't remember what was causing it to act non-deterministically
22:03:09 <mmorrow> , 0.00000000000000000000000000000000000000000000000000000000000000000000000000001/pi :: MPFR
22:03:11 <lunabot>  3.183098861837907e-78
22:03:38 <mmorrow> iirc it was related to some crazy analytic number theory formula that cale had
22:03:43 <toast-opt> lunabot responds to ','?
22:03:59 <mmorrow> it was giving really bizarre answers (non-deterministic, different each time)
22:04:05 <ddarius> Good ole analytic number theory.
22:04:11 <mmorrow> they were reaalllllllllllllllly close to 0 though
22:04:18 <mmorrow> toast-opt: yes
22:04:28 <mmorrow> ddarius: ugh
22:05:17 <manju> How do I print something
22:05:20 <ddarius> mmorrow: Doing the math to go from Cauchy's Residue Theorem to Riemann's Hypothesis is enjoyable.
22:05:31 <manju> I am trying to debug a function
22:05:33 <mmorrow> , (pi / (pi ^ 10000000)) :: MPFR
22:05:34 <lunabot>  5.89126467077106e-4971499
22:05:37 <mmorrow> , (pi / (pi ^ 10000000)) :: MPFR
22:05:39 <lunabot>  5.89126467077106e-4971499
22:05:44 <mmorrow> hmm, seems ok now
22:05:50 <Axman6> MPFR?
22:05:55 <mmorrow> ddarius: heh
22:06:02 <mmorrow> Axman6: arbitrary precision floats
22:06:15 <mmorrow> Axman6: it's a pkg on hackage (that wraps the MPFR library)
22:06:16 <kmc> manju, Debug.Trace
22:06:22 <Axman6> how nice. advantages over CReal?
22:06:22 <kmc> but, the preferred way is just to call your function in GHCi
22:06:27 <Berengal> manju: load it up in ghci and try it there
22:06:37 <mmorrow> Axman6: it can be used for non-trivial computations
22:06:37 <kmc> manju, you should bookmark http://www.haskell.org/ghc/docs/latest/html/libraries/
22:06:45 <Axman6> mmorrow: heh
22:06:53 <Axman6> mmorrow: also, how's that pure-fft going?
22:07:00 <mmorrow> Axman6: hehe
22:07:06 <kmc> Debug.Trace is a hack, in particular, it uses side-effects in an unsafe way, so they might happen at any time, or not at all
22:07:23 <mmorrow> Axman6: maybe sometime next decade i'll get it done, if we're lucky
22:07:31 <Axman6> :P
22:07:38 <kmc> manju, so Debug.Trace is not a reasonable answer to the general question "how do i print something"
22:07:59 <Zao> Typically one prints something using the printing I/O functions in the IO monad.
22:08:00 <kmc> which is much harder to explain in Haskell than in most languages, though the end result is pretty easy to work with
22:08:17 <manju> kmc, Berengal, I did Debug.Trace
22:08:24 <manju> but I get a syntax error
22:08:26 <Axman6> don't!
22:08:34 <kmc> manju, did you try debugging using GHCi first?
22:08:58 * Zao readies map unsafePerformCluebat
22:08:59 <Axman6> Debug.Trace is a practically _the_ last resort
22:09:11 <kmc> pure functions are great... you just test them by putting things in and seeing what comes out
22:09:21 <kmc> you don't have to set up test harnesses or any of that nonsense
22:09:42 <kmc> Axman6, what are the earlier resorts?
22:09:46 <Zao> Idempotent functions are awesome.
22:10:03 <Axman6> ghci
22:10:11 <kmc> ghci in general or ghci debugger?
22:10:16 <kmc> because i think the latter is pretty hard for beginners to use
22:10:30 <Axman6> ghci, then if you really need it, ghci debugger
22:12:19 <mtnviewmark> I have a cabal-install question: I installed a package --user that needed a newer version of bytestring than as installed --global --- so now my .cabal tree has a newer version of bytestring than my system
22:12:25 <mtnviewmark> this seems to make things unhappy -
22:12:26 <Berengal> I've never used the ghci debugger. Never had a need
22:12:43 <toast-opt> quick question -- i have a thing that needs a list, but needs to make random accesses
22:12:46 <Axman6> i've played with it, but never needed it
22:12:54 <kmc> toast-opt, how about Data.Sequence
22:12:55 <toast-opt> what's the right 'array' to start with?  Data.Array.IArray?
22:12:56 <Axman6> toast-opt: Data.Sequence
22:13:04 <mtnviewmark> questions: a) How can I upgrade bytestring in my system (not --user), and how can I get everything to rebuild using it (do I need to do this? I think so)
22:13:14 <kmc> or yeah IArray.  depends if you need O(1) access or just O(log n)
22:13:25 <toast-opt> O(1) would be prefered
22:13:30 <kmc> remember, log n < 64
22:13:39 <kmc> asymptotic complexity analysis is not all it's cracked up to be
22:13:39 <toast-opt> need to make n*n accesses :)
22:13:40 <Berengal> mtnviewmark: rebuilding everything is painful. If you want to do it the easy way, just remove cabal entirely and rebuild from scratch
22:14:02 <Berengal> mtnviewmark: as for upgrading, just cabal install bytestring --global
22:14:03 <kmc> Seq is probably easier, especially if you have code using a list now
22:14:05 <kmc> then profile it
22:14:17 <toast-opt> k, thx, i'll start with Seq
22:14:56 * kmc wonders how many ultra cuckoo hashmaps in the world would be faster if replaced with assoc lists
22:16:24 <mtnviewmark> great - now I have bytestring-0.9.1.4, both bytestring-0.9.1.5 in global
22:16:28 <mtnviewmark> grrrr....
22:16:51 <Berengal> mtnviewmark: yeah, it won't remove the old one, but it'll prefer the new one if it has to choose
22:17:08 <mtnviewmark> so, the issue is my project depends on several packages ---
22:17:10 <toast-opt> kmc - oh, cool, they're fast combining sequences :)
22:17:14 <mtnviewmark> when I configure I get messages like
22:17:17 <toast-opt> thx for showing me that.
22:17:39 <Berengal> toast-opt: fingertrees ftw
22:17:58 <Axman6> yeah, i read most of the fingertree paper last night, and they're awesome!
22:18:08 <mtnviewmark> "this package indirectly depend on multiple version of the same package" .... utf8-string-0.3.5 requires bytestring-0.9.1.4   uuid-1.1.1 requires bytestirng-0.9.1.5
22:18:11 <toast-opt> i like that it has an 'angry face' operator for concatenating.  (><)
22:18:20 <mtnviewmark> how do I resolve that?
22:18:30 <pastah_rhymez> mtnviewmark: dependency hell! yay!
22:18:31 <Berengal> mtnviewmark: yeah, that's not going to work. You need to get everything to work with the same version of bytestring
22:18:40 <kmc> cartman operator
22:18:58 <pastah_rhymez> kmc: how does that look?
22:19:03 <kmc> http://www.xtcian.com/eric-cartman-200.jpg
22:19:10 <toast-opt> exactly!
22:19:18 <toast-opt> it's the cartman operator!
22:19:40 <mtnviewmark> but, for example utf8-string only has this constraing:    bytestring >= 0.9   ---
22:19:49 <mtnviewmark> so do i just need to force cabal to recompile that?
22:19:53 <toast-opt> kmc, darn, the names collide with the prelude list functions?
22:19:58 <Berengal> mtnviewmark: yes
22:20:02 <kmc> toast-opt, yup.  "import qualified Data.Sequence as S"
22:20:07 <toast-opt> thx
22:20:15 <kmc> it's the same as Map and Set
22:20:16 <mtnviewmark> which is what, cabal install foo --reinstall?
22:20:35 <Berengal> I wonder if perhaps the Prelude shouldn't be cut down a bit. I often find myself having to hide lots of things from it
22:20:42 <Berengal> mtnviewmark: should be
22:20:54 <kmc> it'd be nice to have finer grained imports for prelude
22:21:09 <mtnviewmark> well, that will work for all my packages in --user, but the ones in --global came from Haskell Platform
22:21:13 <mtnviewmark> wonder about that....
22:21:27 <Berengal> kmc: indeed. Or perhaps we should be able to 'import Foo hiding (module Bar)'
22:21:33 <kmc> yeah, that would be nice
22:21:38 <toast-opt> kmc, i am missing context-sensitive name resolution you get in OO-ish languages.  mySeq.length
22:21:44 <kmc> though it would expose a bit of implementation... should i have to hide GHC.Prim?
22:21:48 <Berengal> mtnviewmark: you could --reinstall --global
22:21:56 <kmc> toast-opt, yeah, we could also use some good container typeclasses
22:22:06 <kmc> in fact it's a frequent motivating example for fundeps and asstypes
22:22:10 <kmc> i like the way haskell handles module collisions -- complain loudly iff there's an ambiguity
22:22:15 <mtnviewmark> I have to name each package, right - there is "just do that for everything that depends on package X", is there?
22:22:17 <kmc> better than python's "silently overwrite with the second import"
22:22:18 <toast-opt> Seq.length mySeq... yes, Haskell, i know it's a Seq.  i already told you that.  why. can't. you. figure. it. out.
22:22:32 <toast-opt> hah, true
22:22:34 <twb> I'm trying to build a static Darcs on Debian 6.0 to run on Fedora Core 3.
22:22:37 <kmc> well, i'd write "S.length mySeq".  it's a little better
22:22:45 <mtnviewmark> kmc, I do too, I also like that the package system has been designed from the ground up to support --user installaction
22:22:52 <Berengal> mtnviewmark: delete all installed packages
22:23:07 <mtnviewmark> uhm, little scary, no?
22:23:08 <kmc> but yeah it would be better to have:  class Length a where { length :: (Num n) => a -> n }
22:23:17 <kmc> that's a particularly easy one since you don't return element types or "keys"
22:23:19 <twb> cabal install -fstatic -f-curl --> (.text+0x15): warning: Using 'getaddrinfo' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
22:23:19 <twb> And then running it --> FATAL: kernel too old Segmentation fault
22:23:21 <toast-opt> kmc, i guess it needs to resolve Seq.length before it can infer the type of mySeq... but still
22:23:27 <kmc> you can define it yourself quickly
22:23:27 <Gracenotes> kmc: even more importantly than complaining about ambiguity is allowing hiding and qualified import
22:23:36 <Berengal> mtnviewmark: it should re-download everything. Since everything's statically linked anyway, all working programs should continue to work
22:23:42 <kmc> Gracenotes, yes.  though qualified import is quite common these days, and is the default in python frex
22:23:45 <Gracenotes> kmc: Java has ambiguity checking. The lack of hiding and qualified import drives me insane something.
22:23:49 <Gracenotes> *sometimes
22:24:02 <kmc> in python you do have a lot of flexibility because the names you import are just
22:24:09 <kmc> runtime variables, and the modules are just dictionaries
22:24:20 <toast-opt> rope
22:24:29 <Berengal> mtnviewmark: seriously, reinstalling every cabal package is a painful process. I was ailing for weeks after I decided to turn on profiling builds and had to basically reinstall everything
22:24:36 <Gracenotes> does Python have hiding? I forget
22:24:54 <Berengal> mtnviewmark: It's something they're working on though, so it should be easier sometime in the future
22:25:00 <kmc> Gracenotes, from foo import *; del bar
22:25:08 <Gracenotes> heh.
22:25:18 <kmc> yeah, not too nice
22:25:36 <Berengal> Gracenotes: In Java you can do stuff like foo.bar.Class instead of import foo.bar.Class; Class
22:25:37 <mtnviewmark> okay - turned out just reinstalling everything that was in my --user that was mentioned in the configure as on the old package worked
22:25:44 <Gracenotes> but, yes, the module system is very reified, especially compares to include mechanisms
22:25:44 <kmc> you're not supposed to from-import things other than other modules
22:25:53 <kmc> #include is /awful/
22:25:54 <lunabot>  luna: Not in scope: `include'
22:25:56 <kmc> haha
22:25:59 <kmc> # 2 + 3
22:26:00 <lunabot>  luna: parse error on input `|]'
22:26:07 <kmc> # map
22:26:08 <lunabot>  luna: parse error on input `|]'
22:26:12 <kmc> i give up
22:26:22 <Gracenotes> Berengal: that is the way of resolving ambiguity. It is extremely annoying
22:26:27 <kmc> import MyLongModule; s = MyLongModule
22:26:35 <toast-opt> i think #include is for awesome.  especially when people fudge your include guards
22:26:46 <kmc>  #pragma once ftw
22:26:52 <Gracenotes> now, (for example) Go has everything qualified with no other alternative, and I've been using it a bit. no complaints, actually, it's pretty nice.
22:27:22 <Gracenotes> well, everything from other packages qualified by package name except for references within a package
22:27:24 <toast-opt> wow, not getting sick of repeating yourself?
22:27:25 <kmc> that's decent, especially because library authors will use good short names
22:27:42 <toast-opt> qualified, so at least the namespace is short?
22:27:43 <kmc> instead of the whole Foo Foo::Foo::addFooToOtherFoo(const Foo&)
22:28:07 <Gracenotes> I'm not sure what happens if two package names are the same, but I think there's a way of manually qualifying imports as well
22:28:21 <Gracenotes> anyway, Haskell. yeah.
22:28:25 <kmc> i was reading about Scheme's import/export specifiers... they're nuts
22:28:41 <toast-opt> kmc, well, they wanted to invent a _real_ module system
22:28:59 <kmc> there's a whole DSL for composing combinators of package version selection, selecting, hiding, qualifying, renaming, and metaprogram staging
22:29:00 <toast-opt> i think that was goal #1 with r6rs
22:29:05 <kmc> ah that wasn't in r5?
22:29:09 <toast-opt> nope
22:29:13 <kmc> aha
22:29:25 <toast-opt> r5 just has load, or something like that
22:29:34 <toast-opt> and it's optional (intended just for interpreter, i think)
22:29:37 <pastah_rhymez> gaddamit!! *rage* *rage* *rant*
22:29:49 <kmc> pastah_rhymez, doing some C++?
22:29:50 <pastah_rhymez> i can't get template haskell to work :)
22:29:53 <pastah_rhymez> :(
22:29:54 <kmc> heh
22:29:58 <kmc> can you hpaste your code?
22:30:05 <kmc> and/or err msg?
22:30:06 <pastah_rhymez> .paste
22:30:11 <pastah_rhymez> £paste
22:30:13 <kmc> @paste
22:30:13 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:30:15 <pastah_rhymez> @paste
22:30:15 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:30:24 <kmc> sterling paste :O
22:30:44 <Berengal> Perhaps we should just implement first-class parameterizeable modules in Haskell to get it over with...
22:30:56 <toast-opt> hah
22:30:58 <kmc> can we implement all of OCaml as a TH quasiquoter
22:31:08 <toast-opt> ?!
22:31:08 <lambdabot> Maybe you meant: . ? @ v
22:31:19 <toast-opt> @google ocaml quasiquote
22:31:21 <lambdabot> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
22:31:21 <lambdabot> Title: Why It’s Nice to be Quoted: Quasiquoting for Haskell
22:31:25 <Gracenotes> first class modules are good. I don't see the need for parameterizeable modules within that.
22:31:34 <Gracenotes> at least, for Haskell specifically
22:31:39 <Berengal> kmc: just a matter of implementing an OCaml compiler in haskell, no?
22:31:39 <toast-opt> hmm, unexpected
22:31:40 <kmc> we have various similar things
22:31:53 <pastah_rhymez> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5073#a5073
22:31:55 <kmc> Berengal, or even shelling out to one.  the real interesting thing would be if it generated "equivalent" Haskell AST
22:32:00 <pastah_rhymez> ^^ borken template haskell
22:32:06 <BMeph> Is there any documents that clearly explains how ML modules are used?
22:32:13 <kmc> we have MPTC with asstypes.  an instance of that is like a parametrized module, a bit
22:32:14 <BMeph> *Are
22:32:28 <kmc> pastah_rhymez, did you also launch ghci with -XTemplateHaskell ?
22:32:28 <Berengal> Gracenotes: True, type classes get around the need for parametricity
22:32:31 <BMeph> ... *explain
22:33:00 <pastah_rhymez> kmc: wut?
22:33:08 <kmc> LANGUAGE pragmas only apply to that file
22:33:15 <kmc> not sure if they apply to an open (?) import
22:33:18 <kmc> into ghci
22:33:21 <Berengal> kmc: they don't
22:33:26 <pastah_rhymez> aww... it didn't say anything in the cabal readme
22:33:37 <kmc> i mean usually you'd put your mkLabels into the file
22:33:42 <kmc> it doesn't do much good without a decl splice
22:34:32 <kmc> , pprint <$> runQ [| \x -> x+1 |]
22:34:33 <lunabot>  luna: Not in scope: `pprint'
22:34:38 <kmc> , ppr <$> runQ [| \x -> x+1 |]
22:34:39 <lunabot>  luna: Not in scope: `ppr'
22:34:42 <kmc> grr
22:34:57 <pastah_rhymez> kmc: could you modify my paste for me?
22:35:16 <kmc> $ ghci -XTemplateHaskell myfile.hs
22:35:33 <pastah_rhymez> kmc: did that ;)
22:35:39 <pastah_rhymez> No instance for (Show (Q [Dec]))
22:35:43 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5073#a5074
22:35:44 <pastah_rhymez> etc.
22:35:45 <kmc> well that's a different error
22:35:48 <Cale> ^^ pastah_rhymez
22:36:25 <pastah_rhymez> oh, so that's supposed to be IN the source
22:36:27 <pastah_rhymez> cool
22:36:32 <Cale> yeah
22:36:43 <Cale> It generates a bunch of declarations wherever you splice it in like that
22:36:58 <pastah_rhymez> didn't explicitly say that on the cabal file so i thought i had to generate some stuff and paste it in my source
22:37:10 <kmc> pastah_rhymez, no... that's the hard way to do TH
22:37:14 <kmc> useful sometimes
22:37:37 <kmc> but it's tricky... you'd have to run your Q-monad action within GHCi, but you can't reify within runQ :: Q a -> IO a
22:38:01 <pastah_rhymez>  Not in scope: type constructor or class `A'
22:38:57 <pastah_rhymez> haha, $(mkLabels... has to be beneath the datatype declaration
22:39:50 <kmc> heh, i'm a bit surprised... but i guess figuring out intelligently what order to run splices is undecidable
22:40:46 <Cale> actually, I find that really surprising too... wasn't TH originally designed to prevent that sort of nonsense?
22:41:20 <kmc> maybe in simple cases it could
22:41:28 <kmc> but what if you compute a name inside your splice code, then try to reify it?
22:41:47 <kmc> conversely, what if a non-spliced decl refers to a spliced one?
22:42:07 <kmc> there is quite a bit of stuff in the TH paper that's not in ghc
22:43:25 <Cale> and vice-versa
22:48:57 <mtnviewmark> style question: I have a whole set of functions that return Either String Foo -- and I'm including Control.Monad.Error  ---- is better to have those functions use   Right thing   and   Left errormsg    -or-   do people prefer    return thing   and     error errormsg    ?
22:49:39 <mtnviewmark> note: some of those functions chain others together either with do syntax, or with >>= and >>
22:49:51 <Berengal> mtnviewmark: I hope you're using fail, not error
22:50:01 <mtnviewmark> sorry, yes, fail
22:50:02 <Berengal> And you gain nothing by using Left and Right
22:50:02 <Cale> error is not the same thing as throwError
22:50:19 <kmc> mtnviewmark, the latter; it'll be easier if you convert to some other MonadError
22:50:20 <kmc> like ErrorT
22:50:23 <Cale> (If you're using Control.Monad.Error, use throwError for the general thing)
22:50:32 <kmc> fail sucks too
22:50:38 <kmc> :t throwError
22:50:40 <Berengal> fail should be in its own class
22:50:41 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
22:50:59 <Cale> :t catchError
22:51:00 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
22:51:01 <kmc> *gasp* MPTC!
22:51:14 <mtnviewmark> is throwError any different than fail?  for Either String a?
22:51:18 <kmc> :t fail
22:51:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
22:51:25 <Cale> mtnviewmark: For that specific type, no.
22:51:38 <kmc> mtnviewmark, "fail" is a hack to deal with pattern-match failures
22:51:41 <Cale> mtnviewmark: But I would discourage any explicit use of 'fail'
22:51:45 <kmc> "fail" is widely regarded as, well, a failure
22:51:54 <mtnviewmark> I understand the issue there
22:51:54 <kmc> it should at least have a more obscure name, if it's only used by generated code
22:52:14 <mtnviewmark> alas, for well behaved monads, fail reads much more nicely in code than throwError
22:52:22 <mtnviewmark> especially if one never has the intention of catching it!
22:52:44 <Cale> Personally, if I knew the monad in question was Either, I actually probably would just use Left
22:52:48 <kmc> import Prelude hiding(fail); fail = throwError
22:52:49 <kmc> ;P
22:53:17 <mtnviewmark> indeed! obfuscate!
22:54:07 <Cale> There are so many exception systems to choose from.
22:54:25 <kmc> @quote standards
22:54:26 <lambdabot> edwardk says: Haskell 98 is the Windows 98 of standards ;)
22:54:30 <kmc> @quote standards
22:54:30 <lambdabot> edwardk says: Haskell 98 is the Windows 98 of standards ;)
22:54:34 <Berengal> kmc: {-# LANGUAGE NoImplicitPrelude #-}; class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b; class MonadFail m where fail :: a -> m b
22:54:43 <kmc> yeah
22:54:50 <kmc> failOnPatternMatchFuckup
22:55:22 <Berengal> There are cases in some monads where calling fail is perfectly fine by itself
22:55:45 <Cale> Berengal: Problem with that is that you have to recompile everything against your new Prelude, which won't happen by itself. Get used to typing NoImplicitPrelude everywhere :)
22:56:07 <Berengal> Cale: Or picket outside Haskell' HQ
22:57:00 <manju> ok I am at wits' end, how do I print n ?
22:57:03 <mtnviewmark> had one had MonadFail, then presumably it wouldn't have a default implementation of fail that called error?
22:57:03 <manju> fibonacci n =
22:57:03 <manju>   if n <= 0
22:57:03 <manju>   then 0
22:57:03 <manju>   else n + n - 1
22:57:21 <mmorrow> , reify ''Maybe
22:57:22 <lunabot>  luna: No instance for (GHC.Show.Show
22:57:30 <mmorrow> , ppDoc <$> reify ''Maybe
22:57:32 <lunabot>  Template Haskell error: Can't do `reify' in the IO monad
22:57:32 <lunabot>  luna: user error (Template Haskell failure)
22:57:32 <copumpkin> manju: you print the result of fibonacci n
22:57:36 <mtnviewmark> and you could only use MonadFail types if the compiler determines that a pattern match failure is possible?
22:57:38 <mmorrow> , ppDoc <$> $(lift =<< reify ''Maybe)
22:57:40 <lunabot>  luna: Couldn't match expected type `f a'
22:57:44 <mmorrow> , ppDoc $(lift =<< reify ''Maybe)
22:57:45 <lunabot>  data Maybe a_0 = Nothing | Just a_0
22:57:47 <kmc> manju, as a beginner, pretend that "if" doesn't exist
22:57:59 <manju> kmc, ok
22:58:00 <kmc> fibonacci 0 = 0; fibonacci n = n + n - 1
22:58:04 <kmc> now that's not correct either
22:58:05 <mmorrow> pastah_rhymez: you can print TH stuff that uses reify in ghci, you just need to do:
22:58:11 <mmorrow> $(lift =<< ....)
22:58:16 <Berengal> mtnviewmark: it does that already, with the pragma and classes I defined above
22:58:24 <kmc> manju, and i'd put those on separate lines instead of using a semicolon
22:58:27 <mtnviewmark> in any event, throwFailure has an unfortunate name for use with things like Either String x
22:58:30 <kmc> in haskell you should generally use pattern matching with multiple function equations, when possible
22:58:35 <kmc> and when not, use a "case" statement
22:58:40 <Berengal> mtnviewmark: do-notation is just sugar. GHC desugars it before typechecking and constraint solving and whatnot
22:58:41 <kmc> "if" is really not that useful, i feel
22:58:46 <manju> kmc, ok
22:58:47 <Cale> kmc: case expression :)
22:58:51 <kmc> sorry yes
22:58:52 <kmc> case expression
22:58:54 <mmorrow> pastah_rhymez: (that needs instances of Lift for the TH AST types though, which are in haskell-src-meta)
22:59:02 <Cale> There is one thing which manju's code handled which the new code doesn't though.
22:59:06 <kmc> yeah
22:59:08 <Cale> Which is negative parameters
22:59:10 <kmc> which you'd probably use a guard for
22:59:14 <mtnviewmark> yes, I just didn't know if it would insist on MonadFail
22:59:25 <mtnviewmark> and insist that all instances have a fail defined
22:59:36 <copumpkin> or you could just avoid using a signed type
22:59:42 <copumpkin> o.O
22:59:51 <kmc> manju, so you want to know why (fibonacci n) is not the nth fibonacci number?
22:59:52 <Berengal> mtnviewmark: it does. And in general, GHC doesn't insist that a class instance define anything. It just complains loudly if it doesn't have a definition
22:59:54 <kmc> try evaluating it in ghci
22:59:56 <Cale> manju: Anyway, what you appear to be missing is that Fibonacci is recursive.
22:59:59 <kmc> find some small n for which it fails
23:00:06 <kmc> and then look at your definition and see why it's wrong
23:00:11 <manju> Cale, I know :-)
23:00:20 <manju> but I got stuck trying to print
23:00:28 <kmc> manju, just do it in ghci
23:00:29 <copumpkin> you can't print from inside fibonacci
23:00:31 <kmc> manju, did you try ghci
23:00:33 <copumpkin> that's fundamental
23:00:35 <manju> I mean I am currently not working on fibonacci
23:00:47 <manju> kmc, I did, but I don't know what to do with it
23:00:51 <kmc> you type stuff
23:00:54 <kmc> expressions
23:00:55 <manju> other than :l babySteps.hs
23:00:58 <kmc> it evaluates them and prints them
23:01:00 <kmc> > 2 + 3
23:01:01 <lambdabot>   5
23:01:01 <Berengal> manju: use ghci and your brains. In my experience, you can force most bugs in haskell to surrender themselves just by staring at the code
23:01:04 <kmc> it's like that without the ">"
23:01:16 <manju> ok
23:01:30 <kmc> > let fibonacci n = if n <= 0 then 0 else n + n - 1 in map fibonacci [0..]
23:01:31 <lambdabot>   [0,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51...
23:01:44 <mmorrow> manju: you can do IO in ghci too
23:01:52 <mmorrow> a <- readFile "stuff"
23:01:55 <manju> I am not lookingat that
23:01:55 <mmorrow> a :: String
23:01:56 * manju closes his
23:01:59 <kmc> but ghci already does all the IO that you should need to debug such a simple function
23:02:01 * manju closes his eyes
23:02:07 <Cale> manju: If you're working on something more complicated and feel that you really need to get hold of some parameters for which a function is failing, you can use Debug.Trace, but for simple functions like this, you wouldn't normally do that.
23:02:24 <mmorrow> mapM_ (runQuery . ("SELECT x from " ++)) tables
23:02:28 <mmorrow> etc
23:02:43 <manju> Cale, can you show me how I can modify the above function to print n using Debug.Trace ?
23:02:44 <mmorrow> (well, probably mapM there, but you know ;)
23:02:48 <kmc> manju, you really shouldn't
23:02:51 <Berengal> manju: Have you ever worked with an interpreter before?
23:02:51 <kmc> manju, did you try ghci?
23:02:55 <manju> kmc, ok
23:03:01 <manju> Berengal, no, I come from C++
23:03:03 <Cale> manju: Debug.Trace will give you a way to create expressions that print things when they're evaluated, which is in an order that is entirely up to the compiler.
23:03:26 <mmorrow> mapM_ print fibs
23:03:26 <kmc> manju, you already know how to load your file in ghci.  then, type:   fibonacci 0
23:03:39 <kmc> see if it's the right value.  if so, try fibonacci 1, etc.
23:03:49 <kmc> (there are smarter ways, like the map i illustrated above)
23:03:51 <Berengal> manju: Get used to ghci. REPLs are a wonderful tool that probably increases effectiveness of coding (and learning) by several orders of magnitude
23:04:04 <manju> Berengal, ok
23:04:08 <kmc> once you find a small failing test case, you can look through your code and substitute in your head
23:04:16 <Cale> manju: Yeah, generally the right way to debug something is to factor it into tiny pieces and then make sure the pieces work.
23:04:36 <manju> Cale, ok...
23:04:45 <kmc> in haskell we have this wonderful property called referential transparency that says that if expression "e" evaluates to value "v", you can just pretend that each "e" in your program is "v".  You don't have to care about order of evaluation or side effects or any of that.
23:05:19 <kmc> so in this case... (fibonacci 1) is (if 1 <= 0 then 0 else 1 + 1 - 1), which is (1 + 1 - 1), which is 1
23:05:29 <kmc> do you see how it works?
23:05:46 <Cale> Referential transparency means that when you test a function in isolation, it will produce the same results when you actually use it.
23:06:43 <Cale> Something which is extremely valuable, but fails for... well, essentially every programming language in mainstream use :)
23:07:02 <Gracenotes> people who are referentially transparent are not fun to be around
23:07:10 <Berengal> @quote referential.transparency
23:07:11 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
23:07:18 <kmc> haha
23:07:24 <kmc> that quote does not exactly help us make our point
23:07:30 <Berengal> No, not really
23:07:31 <Gracenotes> unless, then again, we are all referentially transparent. scary thought.
23:07:39 * kmc dereferences Gracenotes
23:07:47 <Cale> Well, hey, it's good to know about Debug.Trace.trace too.
23:08:26 <Berengal> I'm still at a point where I can say I've only used pure ghci for debugging haskell for all my bugs
23:08:33 <pastah_rhymez> "Internally uses the covariant in getter, contravariant in setter bi-functioral-map function" <-- how is this related to programming?
23:08:41 <Cale> Sometimes you really would like to observe the order in which expressions are being evaluated without having to think about it.
23:08:45 * pastah_rhymez just wants to write his tetris clone...
23:08:55 <Berengal> Cale: perhaps I'm just really smart :P
23:09:07 <copumpkin> doubt it
23:09:10 <Gracenotes> pastah_rhymez: which graphics framework?
23:09:12 <kmc> unfortunately performance is not referentially transparent
23:09:15 <Cale> Berengal: well, it's rare enough
23:09:16 <pastah_rhymez> Gracenotes: haha
23:09:17 <kmc> text-based tetris
23:09:27 <Gracenotes> :x
23:09:27 <kmc> "You see a T-shaped block.  > rotate block"
23:09:33 <pastah_rhymez> Gracenotes: latest version, with xterms 256 colour support
23:10:05 <Gracenotes> interesting
23:10:07 <Cale> "On the side of the block there is a mailbox. The mailbox is closed. In the distance, you see a white house."
23:10:12 <Berengal> Cale: I've never written any programs where performance was an issue. I suspect I'd be using more advanced tools at that point
23:10:20 <Gracenotes> that is pretty cool
23:10:35 <kmc> "You lose.  Your consolation prize is a bottle of vodka.  > drink vodka"
23:10:39 <Gracenotes> I've never done much terminal stuff, let alone things like curses
23:10:43 <pastah_rhymez> i remember reading a VERY old pc gamer (96~97) where one of the best players in sweden (HeatOn, maybe...) told that in the beginning he won by insane marginals
23:10:49 <pastah_rhymez> without using any mouse
23:11:11 <pastah_rhymez> kmc: that's something :)
23:11:20 <kmc> pretty good prize imo
23:12:08 <pastah_rhymez> or you can do it more in your style of play; send your own packages over telnet for everything "i am at (x,y,z) now", "shoot in direction (x,y,z)"
23:12:40 <pastah_rhymez> <3 <3 <3 quake 1s network api :)
23:13:58 <toast-opt> kmc, (drink vodka) has to be in the IO monad, right?
23:14:35 <Cale> "As you pour the vodka into your mouth, you find that it turns to sand. You choke and spit the sand out of your mouth only to watch the bottle turn to sand as well. Wasn't it cooler a moment ago?"
23:16:14 <Veinor> ... ?
23:18:43 <Cale> That's a sort of awkward attempt at a reference to an interactive fiction game by Andrew Plotkin called Shade.
23:18:55 <Gracenotes> that is somewhat depressing
23:19:33 <Veinor> I figured it was IF.
23:23:24 <Cale> http://www.ifiction.org/games/play.phpz?cat=&game=297&mode=html
23:23:45 <Cale> (or http://www.wurb.com/if/game/918)
23:27:41 <pastah_rhymez> i just started writing fc-label code, but i'm curious; is there a performance penalty to writing State-code with fclabels?
23:32:19 <Saizan_> unlikely, why?
23:32:29 <pastah_rhymez> just curious
23:32:41 <pastah_rhymez> i know some language extensions are slow
23:32:49 <pastah_rhymez> like Scrap Your Boilerplate
23:33:00 <kmc> pastah_rhymez, SYB is not an extension per se
23:33:04 <kmc> it uses a couple of extensions
23:33:08 <kmc> rank-2 types
23:33:14 <kmc> and another i forgot
23:33:21 <pastah_rhymez> oh, ok
23:33:25 <dblhelix> kmc: unsafeCoerce
23:33:37 <kmc> which compile to no-op :D
23:34:11 <kmc> SYB is slow because it does a huge fuckoff traversal calling typeOf for e.g. every char in a string (though there's some way to short that out, i think)
23:34:15 <Saizan_> TH is expanded at compile time, and the functions created by fclabels are simple O(1) functions which probably get inlined
23:34:48 <dblhelix> indeed, none of the used extensions is "slow"; SYB is just an inherently slow approach to generic programming
23:35:11 <kmc> well and derivable Data/Typeable is an extension but secondary and not a runtime issue at all
23:35:24 <dblhelix> see the work of Alexey Rodriguez and others on comparing libraries for generics
23:35:42 <kmc> pastah_rhymez, i generally give performance advice of two sorts: "oh god don't do that" and "probably fine, profile it if you have problems".  fclabels is solidly in the second camp
23:36:03 <pastah_rhymez> kmc: haha, nice
23:36:11 <dblhelix> and the work of José Pedro Magalhaes and others for work on optimising such libraries (this is a shameless plug, btw)
23:36:17 <hotzen> is there any way to select text in the ghci?
23:36:30 <kmc> hotzen, with whatever functionality your terminal provides
23:36:33 <kmc> or with GNU Screen
23:37:03 <hotzen> using the windows-shell, capsuled in "Console2".
23:37:16 <kmc> not gonna comment on that
23:37:23 <kmc> on windows i used PuTTY to localhost as a shell
23:37:25 <hotzen> can you select text with the mouse via bash?
23:37:38 <kmc> iirc bash knows nothing about mice
23:37:46 <kmc> select is really the role of the terminal, not the shell
23:38:03 <kmc> the shell isn't even running while your command is
23:38:23 <hotzen> is there any non-cygwin shell replacement for win?
23:38:28 <kmc> if you want a non-GUI terminal copy/paste system, use screen
23:38:37 <kmc> screen is awesome for many more reasons
23:39:14 <hotzen> looking into it, ty
23:39:31 <hotzen> http://www.bangmoney.org/presentations/screen.html `
23:39:32 <hotzen> ?
23:39:49 <kmc> yes
23:40:57 <kmc> the killer feature for screen is attach / detach
23:41:05 <Veinor> Agreed.
23:41:09 <kmc> i honestly don't understand how people use UNIX for years without it
23:41:13 <Veinor> Also, multiple windows.
23:41:28 <kmc> multiplexing is second.  depending on your WM and such it can be a bit redundant
23:41:38 <Veinor> True, but in the pre-WM age...
23:41:42 <kmc> it annoys me that it's not easier to move individual windows between screens.  maybe there is an easy way that i don't know about
23:42:02 <Veinor> oh, that reminds me: isn't there some program that can screenify running programs?
23:42:13 <kmc> woah, that'd be a trick
23:42:18 <Veinor> yeah, it's deep magic
23:42:24 <kmc> ptrace it and reopen fd 0,1,2 ? ;)
23:42:32 <Veinor> I think that's what it is, actually
23:42:49 <kmc> at work a friend had a problem where his WM's working dir was a stale NFS handle
23:43:01 <kmc> solution: attach gdb to it, print chdir("/")
23:43:27 <Veinor> haha
23:46:21 <Veinor> http://sooda.dy.fi/foo/screenify
23:46:22 <Veinor> :D
23:46:44 <kmc> omg
23:47:34 <kmc> wonder if there's a race in the mktemp
23:48:38 <Veinor> isn't mktemp designed to be non-race-y?
23:49:03 <kmc> i thought the safe one was mkstemp, on the C level
23:49:07 <kmc> don't know about shell
23:50:44 <toast-opt> hmm, i keep getting "No instance for (Fractional Int)  arising from a use of `simpleImageF'" and so forth
23:51:33 <kmc> well... Ints are indeed not fractional
23:51:38 <kmc> :t fromIntegral
23:51:39 <lambdabot> forall a b. (Integral a, Num b) => a -> b
23:51:52 <kmc> i don't know what simpleImageF' is
23:52:22 <toast-opt> it should be a function producing an array of floats
23:53:02 <toast-opt> Sure enought, :t simpleImageF has :: ... RealFloat b1) => ... -> a (t,t1) b1
23:53:52 <toast-opt> oh, maybe its inputs are the problem
23:53:54 <hotzen> could somebody help me with an could-not-deduce-type error using type families pls?
23:53:54 <hotzen> http://haskell.pastebin.com/m5b325b59
23:54:45 <kmc> hotzen, is that your only instance for SmartList?
23:54:56 <hotzen> no, i shortened it for brevitty
23:55:10 <kmc> it'd be essential to see all the instances
23:55:19 <toast-opt> kmc, all these int to float conversions are killing me :S
23:55:29 <kmc> toast-opt, where are the ints coming from?
23:55:45 <toast-opt> kmc, trying to iterate fixed samples over continuous functions
23:55:47 <hotzen> here you go: http://haskell.pastebin.com/m45cbbba3
23:56:08 <ksf> hotzen, how do you plan to build lists with : and Ints?
23:56:12 <toast-opt> things like [ f(x+0.5) | x <- [0..(cx-1)]}
23:56:21 <kmc> hotzen, so all of your instances are two concrete types
23:56:21 <toast-opt> oops, /}/]/
23:56:34 <hotzen> ksf: its primarily for a seminar to show how type-families work. i dont need overloading (:) for now
23:56:46 <hotzen> yes, they are concrete
23:56:51 <hotzen> is this a problem?
23:56:56 <kmc> no i see
23:57:04 <kmc> hotzen, why are both elemTy and listTy in the typeclass head?
23:57:15 <kmc> it seems to me that one of them should be the class instance, and the other the ass-type
23:57:18 <ksf> you want something like instance SmartList Int []
23:57:33 <ksf> ...or what kmc said.
23:57:34 <kmc> or, that you should use a fundep between them, and drop the asstype entirely.  but i think the first way is nicer
23:57:53 <ksf> hotzen, http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
23:58:00 <qiemem> If I have two instances of a value, will there be two copies of the value in memory or one? Or does it depend? For instance, if I have a binary tree whose left and right children are identical binary trees, will left and right be pointing to the same spot in memory (assuming both have been evaluated)? This is with regards to code compiled by ghc.
23:58:18 <hotzen> yes, im reading fun with type funs
23:58:41 <hotzen> but in the paper, they also have "class Cons a b where type ResTy a b"
23:58:46 <kmc> hotzen, you have (SmartList Int Int), (SmartList Char Int), and (SmartList Int Double)
23:58:51 <kmc> so it's not a type-function either way
23:58:53 <hotzen> because i get some List b and want to add an elem a, so i get a new list ResTy
23:59:04 <mtnviewmark> hotzen  - is smartConcat2' missing some equations?
23:59:07 <kmc> ah ah okay
23:59:14 <kmc> there are *three* types involved
23:59:15 <kmc> i see now
23:59:18 <ksf> hotzen, also, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13083#a13083
23:59:40 <hotzen> mtnviewmark: yes, but already the first fails :(
23:59:56 <vy> I have a function returning "Either String Int", how can I make a pattern matching over return values to differentiate between a String and an Int?
23:59:58 <mtnviewmark> well, I'm thinking without the rest, the types can't be inferred
