00:00:03 --- mode: ChanServ set +o mauke
00:00:03 --- mode: mauke set -b *!*@71.sub-75-210-111.myvzw.com
00:01:04 --- mode: mauke set -o mauke
00:01:18 <ezyang> I wonder how far away from compilation my hs file is now...
00:01:38 <ezyang> oh dear.
00:01:39 <ezyang> Could not find module `Control.Monad.Trans':       it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
00:01:47 <Saizan> "A ⊃ B" ~ "A -> B" or "A <- B" ?
00:01:53 <Berengal> ezyang: import "mtl" Control.Monad.Trans
00:02:03 <Saizan> or hide one of those
00:02:09 <Saizan> or -hide-package
00:02:27 <Berengal> Saizan: A -> B
00:02:40 <ezyang> How do I know which one I want?
00:03:01 <Berengal> You try one, and if it complains, try the other
00:03:06 <ezyang> haha
00:03:27 <Saizan> Berengal: but doesn't A ⊃ B mean that B is a subset of A?
00:03:59 <kmc> it's also an archaic symbol for implication
00:04:23 <Elly> "archaic" - my current logic professor uses it :P
00:04:34 <Elly> (on the other hand, his PhD advisor was Alonzo Church, so...)
00:04:37 <kmc> ok fine ;P
00:04:37 <Saizan> i thought the meaning was related though
00:05:04 <Saizan> if you know x \in B and B is a subset of A then x \in A
00:05:06 <kmc> hmm, A -> B  iff B holds on a subset of points where A holds
00:05:10 <kmc> yeah
00:05:37 <Berengal> That's just application
00:05:45 <Saizan> ah, i guess you can turn it around like that
00:06:02 <Berengal> And I thought you meant implication
00:06:20 <Saizan> yeah, i meant implication
00:06:26 <procyon112> He just implied implication.
00:06:35 <sjanssen> preflex: seen edwardk
00:06:35 <preflex>  edwardk was last seen on #haskell 3 days, 11 hours, 55 minutes and 25 seconds ago, saying: cale: what i currently do is i allow do foo; bar; baz on one line, but in essence with my layout if you break it across multiple lines (and need indentation control) you need to move it down, since i don't know that the width of space, d, and o are the same.
00:08:50 <Saizan> kmc: no, that still doesn't make sense to me, if B holds on a subset of points where A holds, from A(x) holding i can't conclude that B(x) holds
00:09:03 <Berengal> Was just about to say that
00:09:54 <trofi> http://i.imgur.com/ng5aS.png
00:09:55 <kmc> ah i have it backwards
00:10:01 <kmc> and missing the word "only"
00:10:47 <Saizan> but if you invert the two in the subset part, then you'd have to invert the direction of ⊃
00:10:48 <kmc> A -> B iff { x : A } subseteq { x : B }
00:11:09 <Saizan> that's why that notation seems backward to me
00:11:42 <Saizan> though maybe it's just nonsensical notation :)
00:11:49 <Elly> hm?
00:12:12 <Berengal> I just stick to function arrows...
00:12:15 <Elly> A \subset B meaning "A implies B" makes sense to me
00:12:51 <QtPlaty[HireMe]> Elly: Isn't that mixing of levals?
00:13:03 <ski> (that archaic implication notation isn't really related to the subset notation .. if you try to compare them, you'll notice they "go in opposite directions")
00:13:16 <kmc> sigh
00:14:02 <Saizan> (ok, that makes sense then :)
00:14:08 <QtPlaty[HireMe]> A subset B is diffrent to A implies B one is a stament about sets and the other is a statement about boolean truth.
00:14:30 <Saizan> QtPlaty[HireMe]: sure, we were drawing analogies
00:14:36 <ski> (i.e. `forall a. P a -> Q x' can be interpreted as `{a | P a} \subset {a | Q a}', but the notation for `\subset' is roughly a `C', while the old one for implication is roughly a converse `C')
00:14:41 <kmc> there's a correspondence between sets and their membership predicates
00:14:45 <Saizan> since you can see sets as predicates on elements
00:15:36 <ski> (s/Q x/Q a/)
00:15:46 <kmc> but you have to be careful with that
00:16:12 <ezyang> hoo boy type errors now
00:19:33 <procyon112> Bah.  This linode must die.
00:24:50 <procyon112> @hoogle (a->b->m c a)->a->[b]->m c a
00:24:52 <lambdabot> Data.Graph.Inductive.Internal.Thread threadList :: Collect r c -> Split t i r -> [i] -> t -> (c, t)
00:24:52 <lambdabot> Data.Graph.Inductive.Internal.Thread threadList' :: Collect r c -> Split t i r -> [i] -> t -> (c, t)
00:24:52 <lambdabot> Data.Generics.Twins gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (a -> e -> (a, r')) -> a -> d -> (a, r)
00:25:19 <procyon112> ^^^ This is not foldM for Either. :(
00:26:17 <Berengal> Is there a foldM for Either a
00:26:17 <Berengal> ?
00:26:27 <Saizan> only because the Monad instance for Either is broken
00:26:52 <procyon112> Either is like an abusive spouse.
00:27:22 <Saizan> procyon112: easy solution: write a dummy Error instance for your c
00:29:45 <ezyang> crafting monad transformer stack unwrappers is such a pain
00:32:41 <Berengal> Realizing that combinators don't have to be written in terms of return and bind has made my life easier
00:33:37 <c_wraith> Isn't it the case that more-interesting combinators for specific monads require working with the underlying representation more directly?
00:35:14 <Saizan> if they don't they aren't really specific
00:36:05 <ezyang> http://pastebin.com/m2ec0f25 any idea what the problem is?
00:36:31 <ezyang> MyError has a instance of Error, so the monadfailure instance should work...
00:36:33 <kmc> ezyang, you defined MyError?
00:36:39 <ezyang> yup
00:36:53 <kmc> it's a monad?
00:37:03 <ezyang> no?
00:37:03 <crash[`]> What's the best binding to do a Windows ui with haskell?
00:37:09 <Peaker> They should bring back the MonadZero for pattern failures in "do" and get "fail" out (I'd say get (>>) out too, and let rewrite rules do optimizations)
00:37:11 <kmc> well it seems to think you're using it as a monad
00:37:40 <kmc> err, never mind
00:37:46 <Peaker> then, also make Either a monad without silly contexts, and have an Error newtype or alternative for Either for the Either monad silliness
00:37:54 <kmc> :k MonadFailure
00:37:56 <lambdabot>     Not in scope: type constructor or class `MonadFailure'
00:38:05 <kmc> damn hoogle is down
00:38:10 <ezyang> I'm playing with Control.Monad.Failure right now, and it ostensibly should fix this problem
00:38:17 <ezyang> http://hackage.haskell.org/packages/archive/control-monad-failure/0.4/doc/html/Control-Monad-Failure-Class.html
00:38:37 <Peaker> Its so weird to me that Haskell got monads right the first time (with MonadZero, etc) and monad comprehensions, etc, but decided to cripple everything for better error messages
00:39:29 <Peaker> kmc: http://holumbus.fh-wedel.de/hayoo/hayoo.html
00:40:47 <Berengal> Peaker: it puzzles me too. Perhaps a Haskell-lite would solve the initial confusion?
00:40:56 <Berengal> Helium has type-classes now...
00:41:06 <Berengal> Well, ish
00:41:10 <crash[`]> Wow a girl I was talking to just said "i'm barely functional" and my first thought was "you are exceptionally object-oriented"
00:41:42 <ezyang> zing!
00:41:48 <EnglishGent^afk> I like the Dr. Scheme approach of having 'layers' to a language
00:41:53 <kmc> great
00:42:12 <EnglishGent^afk> heheh - nice comeback crash[`] :)
00:44:01 <medfly> though protip: she doesn't want to hear you joking around about that, and even more so if she doesn't get the joke :p
00:45:12 <EnglishGent> mind you I'm not sure I want a relationship where purity is constantly enforced
00:45:37 <crash[`]> EnglishGent: lolol
00:46:00 <crash[`]> EnglishGent: something about monads, gonads, and IO impurity
00:46:19 <EnglishGent> indeed!
00:46:38 * EnglishGent is kind blurry having just woken up..
00:46:38 <Jafet> Just do it unsafe.
00:46:46 <EnglishGent> can Haskell get me another cup of coffee?
00:46:58 <crash[`]> Jafet: anything about monadic wrappers?
00:47:02 <kmc> ugh
00:47:08 <EnglishGent> (is the bot down again?)
00:47:33 <Jafet> I don't like them; they bind a lot
00:47:44 <Phyx-> EnglishGent: no, he's still sleeping
00:47:54 <kmc> who?
00:48:00 <crash[`]> what if lambdabot were a real person?
00:48:06 <crash[`]> that'd be both very impressive and incredibly depressing
00:48:10 <shachaf> @vixen Are you real?
00:48:11 <lambdabot> i'm really real
00:49:10 <kmc> lambdabot is female
00:49:53 <toast-opt> drat, hoogle is down
00:49:58 <EnglishGent> are you sure? I mean Haskell certainly isnt - when you do something wrong - _it tells you what_
00:49:59 <EnglishGent> :)
00:49:59 <sayyestolife> I'm rational :<
00:50:00 <crash[`]> who here considers themself a data structure genius?
00:50:21 <Jafet> EnglishGent, but in a very very convoluted way
00:50:28 <toast-opt> there was a sequence type other than List and Seq, one that had log n indexing
00:50:33 <EnglishGent> lol! true!
00:50:36 <toast-opt> (Seq doesn't work on windows with vanilla install)
00:55:19 <toast-opt> hmm, are there any other Foldable types?
01:01:47 <crash[`]> toast-opt: :t BathTowel
01:02:00 <toast-opt> heh
01:02:12 <toast-opt> i'm doing some fractal renderings in haskell to practice
01:02:21 * toast-opt ran into perf while doing image processing on lists
01:02:33 <toast-opt> i should just skip to Array
01:02:46 <toast-opt> someone pointed out earlier what i was doing wrong, so i shouldn't have a problem this time
01:02:49 <crash[`]> can someone explain what a Foldable type really means? What's something that's foldable but a collection?
01:03:15 <crash[`]> rather
01:03:17 <crash[`]> but not a collection
01:04:51 <kmc> crash[`],
01:04:56 <kmc> they're all collections, almost by definition
01:05:23 <Berengal> crash[`]: Read the typeclassopedia. It gave me an intuition of what the various standard typeclasses mean at least
01:05:25 <kmc> :t foldMap (return :: a -> [a])
01:05:27 <lambdabot> Not in scope: `foldMap'
01:05:28 <Berengal> Including Foldable and Traversable
01:06:05 <Berengal> Couldn't you define fold on functions?
01:06:23 <EnglishGent> instance Foldable Space -- implementation provided by A. Einstein
01:06:24 <EnglishGent> :)
01:06:41 <kmc> space has a terrible power
01:07:43 <kmc> Berengal, sure, and a function is an implicit, associative collection
01:07:53 <kmc> but i'm not sure how the definition of foldr or foldMap would work
01:08:17 <kmc> crash[`], toList :: Foldable t => t a -> [a]
01:08:21 <kmc> so in some sense they're all collections
01:08:37 <Berengal> kmc: foldMap returns a monoid, so's easy to cheat on that one at least
01:10:02 <kmc> sure, any datatype can be defined to be an empty container
01:10:09 <kmc> as long as it has the right kind
01:11:12 <kmc> if a is enumerable then (a -> b) is a container of b in a more interesting way
01:11:18 <crash[`]> alright
01:16:41 <crash[`]> anyone who's a data structure guru wanna give me some thoughts over PMs?
01:18:17 <ski> crash[`] : why not ask your question right here (possibly providing link to code), so that even data structure non-gurus might possibly help, if they have anything to contribute ?
01:21:46 <Saizan> crash[`]: collection is quite broad, e.g. i'd expect to be able to insert elements in it, Foldable is specifically about tearing them down
01:33:25 <crash[`]> Saizan: understood, I was just a bit curious if there were any cases where there was something foldable that wasn't a "collection" (for lack of more accurate terminology(
01:34:17 <copumpkin> @instances Foldable
01:34:18 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
01:34:26 <copumpkin> @instances-importing Foldable
01:34:27 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
01:34:34 <copumpkin> fuck you, lambdabot
01:35:54 <kmc> :(
01:35:58 <crash[`]> :(
01:36:04 <Berengal> @instances-importing Data.Foldable Foldable
01:36:04 <lambdabot> Maybe, []
01:36:12 <crash[`]> Hm
01:36:22 <Saizan> @slap copumpkin
01:36:22 * lambdabot pulls copumpkin through the Evil Mangler
01:36:29 <copumpkin> ouch
01:36:41 <crash[`]> why not something like sequences?
01:36:54 <Berengal> There might be instances defined elsewhere
01:37:01 <crash[`]> oh okay
01:37:22 <Berengal> @instances-importing Data.Foldable Data.Tree Foldable
01:37:23 <lambdabot> Maybe, Tree, []
01:37:30 <Saizan> @instances-importing Data.Sequence Foldable
01:37:31 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
01:37:38 <Berengal> @instances-importing Data.Foldable Data.Sequence Foldable
01:37:39 <lambdabot> Maybe, Seq, ViewL, ViewR, []
01:38:58 <crash[`]> Ah :)
01:39:31 <crash[`]> i'm always learning around here
01:42:33 <crash[`]> how about something disconnected. When is a sequence appropriate over a list?
01:42:49 <copumpkin> if you need a lot of appending, you probably want a Seq
01:42:58 <copumpkin> or a DList or an FMList, or just to rethink how you're doing things
01:43:17 <crash[`]> DList/FMList?
01:43:49 <copumpkin> other listy representations
01:43:50 <ski> @instances Data.Foldable.Foldable
01:43:52 <lambdabot> Maybe, []
01:44:00 <copumpkin> that allow for cheap appends
01:44:11 <Berengal> What's a FMList?
01:44:16 <crash[`]> oh, so Haskell lists are built on finger trees, right? so that'd be log n appends?
01:44:23 <crash[`]> mm, not appends I guess, just inserts?
01:44:31 <Berengal> No, regular lists are just singly linked lists
01:44:31 <copumpkin> no
01:44:37 <crash[`]> Ah
01:44:37 <Jafet> Lists are lists
01:44:46 <Berengal> @src []
01:44:46 <lambdabot> data [] a = [] | a : [a]
01:44:49 <copumpkin> Seq is built on finger trees
01:44:50 <crash[`]> I just read some article about using finger trees for lists some time prior
01:45:12 <copumpkin> Berengal: http://hackage.haskell.org/package/fmlist
01:45:24 <copumpkin> newtype FMList a = FM {
01:45:24 <copumpkin> unFM :: forall m. Monoid m => (a -> m) -> m
01:45:24 <copumpkin> }
01:45:31 <copumpkin> odd representation :P
01:45:57 <ski> looks nqCPS-y
01:46:00 <Berengal> I saw a video presentation by Guy Steele where he presented a list-like structure that looked like fingertrees
01:46:34 <Berengal> The presentation was in the context of parallelism, and he used Fortress alot
01:46:46 <Jafet> "List" can refer to many different structures
01:47:40 <Berengal> Yeah. The basic premise is just that they can be empty, and have a single normal ordering
01:47:49 <kmc> @djinn (p -> (q -> r)) -> ((p -> q) -> (p -> r))
01:47:51 <lambdabot> f a b c = a c (b c)
01:48:48 <Jafet> @djinn a -> b
01:48:49 <lambdabot> -- f cannot be realized.
01:49:56 <kmc> @djinn (Not p -> Not q) -> (q -> p)
01:49:57 <lambdabot> -- f cannot be realized.
01:50:28 <Jafet> Hmm
01:50:46 <Jafet> @src Not
01:50:46 <lambdabot> Source not found. Maybe you made a typo?
01:50:59 <Berengal> Not a = a -> _|_ ?
01:50:59 <kmc> data Void; type Not a = a -> Void
01:51:18 <kmc> @djinn Not p -> p -> q
01:51:19 <lambdabot> f a b = void (a b)
01:51:25 <ray> right, Void
01:51:40 <kmc> void :: Void -> a
01:52:37 <Berengal> I need to learn some idioms for working with Void...
01:52:58 <Jafet> Is Void even valid Haskell?
01:53:02 <Saizan> (Not . Not) is a monad
01:53:10 <kmc> Saizan, some kind of continuation monad?
01:53:14 <Berengal> Jafet: Sure, it's valid Haskell 2010
01:53:21 <Saizan> kmc: Cont Void, yup
01:53:22 <kmc> Jafet, you can't define an ADT with no constructors in H98
01:53:32 <Jafet> Right
01:53:46 <kmc> but it's a reasonable thing to do
01:53:53 <kmc> well-defined enough
01:53:59 <Jafet> You can only do it once though
01:54:05 <kmc> why?
01:54:20 <Jafet> They're all isomorphic.
01:54:38 <kmc> sure, but you can make multiple isomorphic types, in general
01:54:44 <kmc> in fact it's key to effective use o fthe type system
01:54:48 <Jafet> And I can't think of it being very useful, other than in theory like CH
01:54:55 <Jafet> Hmm?
01:55:09 <Berengal> Isomorphic doesn't mean identical
01:55:18 <kmc> Jafet, type-levels booleans for example
01:55:19 <Saizan> newtype Void; -- faster
01:55:22 <kmc> data True; data False
01:55:25 <kmc> Saizan, haha
01:55:41 <Berengal> One practical application of the empty types is as tags in phantom types
01:56:26 <kmc> it's important that True and False (the types defined above) are two different types, for the purposes of writing typeclasses as functions on them
01:56:46 <Jafet> Good point
01:57:03 <kmc> but also, at the more mundane level, it's important to have isomorphic types, so the typechecker can prove your data don't mix in unexpected ways
01:57:08 <kmc> that's why we have newtype
01:57:53 <ski> Jafet : `data Void' is valid given `EmptyDataDecls'
01:58:04 <Berengal> Typesafety isn't free. It's not enough to have a powerful type language and typechecker. You also need to provide the types
01:58:48 <kmc> if you make two newtypes of Double named GBP and USD, then the typechecker can prove that you don't accidentally add dollars and pounds
01:59:15 <ski> Berengal : also thinks like `kill :: SystemM Void', where this was an action that does not return monadically
01:59:37 <kynky> modelling currency on doubles, is that wise (considering the wobble)
01:59:49 <kmc> kynky, no, but it's standard practice :/
01:59:51 <ray> unwise
02:00:04 <Jafet> CReal!
02:00:08 <Berengal> kynky: Excel uses floating point. Consider that for a moment
02:00:12 <kmc> what's this CReal i keep hearing so much about
02:00:18 <ski> > pi :: CReal
02:00:20 <lambdabot>   3.1415926535897932384626433832795028841972
02:00:26 <kmc> where's it come from
02:00:38 <EnglishGent> surely pi :: Yum! ?
02:00:39 <EnglishGent> :)
02:01:00 <Berengal> EnglishGent: Yum is a typeclass
02:02:02 <Saizan> kynky: for currencies you can use fixed precision types like in Data.Fixed
02:02:06 <kynky> we used doubles at my place of work for a very large application that dealt with currency, it was a pain
02:02:45 <kynky> all seems well and good at first, i came onto project well after it was entrenched
02:02:56 <Berengal> Fixed precision numerals can still accumulate rounding errors
02:03:11 <ski> @where CReal
02:03:12 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
02:03:16 <kynky> but doing division can have nasty effects (much more so than addition and subtraction)
02:03:18 <Jafet> Financial regulations usually specify a consistent rounding scheme
02:03:31 <Jafet> So it isn't a matter of doing it mathematically correct, but legally correct
02:04:14 <kynky> both :)
02:04:20 <ski> (`darcs get http://darcs.augustsson.net/Darcs/CReal' i think)
02:04:22 <kmc> nice
02:04:33 <ski> kynky : isn't that a contradiction in terms ? :)
02:05:26 <kynky> ski, i justtyped out a massive sentance, then realised, what you were really saying, lol
02:07:30 <Cale> Whoa... X has grown to 761864K. pmap -d shows a 696860K chunk of anonymous memory.
02:08:03 <mmorrow> whoever invented ctrl+alt+backspace is a geniush
02:08:37 <Cale> I would like to figure out what I might do about this. Restarting X every couple days is irritating.
02:08:58 <ski> (mmorrow : typed it in emacs ?)
02:09:24 <mmorrow> ski: oh noes, don't do it!
02:10:07 <mmorrow> at least X commits suicide with extreme efficiency, then resurrects itself to crash another day
02:10:27 <kynky> Cale, newer X versions disable that by default, but you can put functionality back by editing xorg.conf
02:10:44 <mmorrow> kynky: disable what?
02:10:49 <kynky> i have to ssh into from phone and kill X sometimes
02:10:55 <kynky> three finger salute
02:11:00 <mmorrow> blasphemy!
02:11:21 <Cale> kynky: Oh, I did enable ctrl-alt-backspace. My concern isn't that, it's the memory leak.
02:11:33 <Jafet> I disabled that when I found out some of my classmates were more nix aware than I thought
02:11:36 <kynky> started from versions 1.6 and above
02:12:35 <kynky> memory leak could be literally anything, when it comes to X :)
02:12:37 <mmorrow> kynky: that's rather overly confident of them
02:13:11 <kynky> mmorrow, yep
02:13:50 * mmorrow wonders howtf he's supposed to log out now!
02:14:04 <kynky> lol
02:14:10 <ski> (Cale : maybe try starting two X sessions, and put half your applications in one, half in the other ?)
02:15:22 <kynky> should be done by the exiting of the last program specified in .xinitrc , normaly a wm or panel, which should give logout command
02:15:29 <Jafet> mmorrow, hardwire a joystick as a kill switch
02:15:31 <Elly> upgrading to xorg-server 1.7.1 helped a lot with the memory use
02:15:38 <Elly> (from 1.7.0 and 1.6.X)
02:15:50 <Elly> my X server has been up for four days and is only using 52M
02:16:01 <kynky> 1.7.1 here too
02:16:46 <mmorrow> Jafet: ooh, i'll get aviator sunglasses too
02:16:51 <Cale> Elly: oh, that's an idea.
02:17:12 <Jafet> Wait, joysticks are too easy to press.
02:17:28 <Jafet> Acquire a big red button and laser-engrave upon it "DO NOT PRESS"
02:17:41 <mmorrow> with a liftable glas cover of course
02:17:46 <mmorrow> *glass
02:18:12 <ski> or a switch with labels "Magic","More Magic"
02:18:28 <Jafet> X isn't magic!
02:18:32 <Jafet> ...maybe a little bit
02:18:51 <mmorrow> or maybe do the two-keys-and-launch-code-verification like in Hunt for Red October
02:19:16 <mmorrow> you've gotta make sure your XO concurs first too
02:19:26 <Elly> ctrl-alt-backspace is fine even in environments with untrustworthy other people, as long as you 'exec startx'
02:19:37 <Elly> (or generally just make sure X doesn't return to a shell :P)
02:21:19 <kynky> Elly or if it does, it returns to a locked shell :)
02:21:35 * ski remembers pressing `Meta-Stop' and typing `reboot' at the forth prompt ..
02:21:39 <kynky> vlock is handy
02:33:40 <ksf> tokenizing sucks.
02:33:46 <ksf> or, at least, tokenizers suck.
02:34:08 * ksf sees no sense in confusing himself with two different approaches to parsing.
02:34:34 <ksf> it does make sense, in some cases, to tokenize the input. using regexen instead of a proper parser for that doesn't.
02:34:57 <kynky> depends, you can parse whole thing into memory, assuming it small, or stream parse it
02:35:33 <ksf> you don't need to limit yourself to regexen to have online parsing.
02:37:25 <ksf> ...and now I'm suffering utter pain with yi as all the boilerplate assumes alex
02:38:07 <kynky> i use eclipsefp :)
02:38:27 <kynky> leksah looked good
02:38:37 <ksf> eclipse doesn't come with vi (at least not a free, proper one), and isn't scriptable in haskell
02:39:03 <ksf> (this is not to say that yi comes with a proper vi. but I'm trying to fix that)
02:39:12 <kynky> :)
02:40:45 <smiler> Hmm, isn't there a built-in nth in Data.List?
02:40:57 <mmorrow> (!!) you mean?
02:41:00 <ksf> it's called !!
02:41:07 <mmorrow> , [0..9] !! 4
02:41:08 <lunabot>  4
02:42:05 <mmorrow> , (repeat (!!) !! 100000) [0..9] 4
02:42:06 <lunabot>  4
02:42:32 <Berengal> It's a shame IDEs either have great support systems (integrated debugger, code navigation etc.) but sucky editors, or they have sucky support systems but great editors
02:43:08 <Baughn> Berengal: Or they're SLIME.
02:43:28 <Baughn> Berengal: Just you wait. I'll get haskell-mode to the same level.
02:43:40 <mmorrow> i prefer the "\"unix philosophy\"" of having separate programs that each do something well
02:43:46 <Berengal> Baughn: Haven't used SLIME much...
02:43:48 <kynky> not saying eclipse is great, but it was meant to be pluginably configurable, over time, i see it getting better, it was sockingly ba a few years ago
02:44:15 <ksf> it's been really good for java for a couple of years now
02:44:18 <Berengal> kynky: changing the keybinding in eclipse to emacs bindings reveals just how much is still lacking
02:44:37 <Saizan> mmorrow: you've to plug them together at some point though, to get an usable UI
02:44:50 <Jafet> mmorrow, the parts do not necessarily make the whole
02:44:57 <kynky> ksf i use eclipse in my java daytime job, used  t use intellij idea
02:44:59 <Jafet> That's where perl comes in
02:45:12 <ksf> we've got scion, and we have hare (well, at least in principle)
02:45:14 <mmorrow> Saizan: right, you have a program that's good at wiring programs together ..
02:45:58 <mmorrow> Jafet: a jack of all trades is a master of none
02:46:02 <Jafet> perl tries to do just about everything well, and the scary thing is that it's succeeding
02:46:10 <Berengal> mmorrow: I think I prefer the modular approach, of having separate /libraries/ that does something well.
02:46:35 <Berengal> The problem with unix is that the communication interface is just strings
02:46:40 <ksf> the annoying part is that we've got 1000 different haskell ast data types, and different parsers for each.
02:46:41 <mmorrow> Berengal: program, library, same thing in my book
02:46:47 <kynky> at the end of the day, whatver ide or vim or emacs you use, if it makes you more efficient its a good thing, its all about choice i guess
02:47:14 <mmorrow> Berengal: (using unix as an example, not necessarily as a literal model)
02:47:23 <Berengal> kynky: I use emacs for editing text, and netbeans/eclipse to organize projects
02:47:37 <ksf> eclipse's java mode has the distinct advantage that java is trivial to compile, so they could roll their own, incremental compiler.
02:47:41 <mmorrow> the thing that i really really want is a structural editor for code
02:48:03 <Berengal> mmorrow: coding in the AST?
02:48:12 <Jafet> paredit!
02:48:14 <kynky> ksf, there is incemental haskell compiler in eclipsefp , iirc
02:48:34 <ksf> parser, maybe.
02:48:41 <Berengal> leksah does "incremental" compiling...
02:48:56 <Berengal> Well, not really, it just calls cabal build every few keystrokes
02:49:02 <ksf> but you have to give a link if you want me to believe that it doesn't compile the whole file, after each changed character.
02:49:03 <mmorrow> you can edit at the character by char level, you can add *structured* chunks of syntax/code to various maps that you can create/delete on-demand, and that're persistent
02:49:31 * ksf wants to have refactorings.
02:49:53 <ksf> things like "move definition to another module" and have every import etc. work out fine.
02:50:11 <Jafet> ksf, patches welcome
02:50:15 <Berengal> Refactorings would be nice...
02:50:19 <ksf> we do have hare.
02:50:36 <ksf> ...but it doesnt' work with ghc 6.10, if it works with ghc at all, by now.
02:51:07 <kynky> its a good thing haskell is strict , so haskell ide can make good choices
02:51:10 <ksf> the main thing is that we don't have a standard haskell ast, that everybody uses.
02:51:28 <mmorrow> suppose i want a map (Map Category ([Decl],[FunDecl])), and i can tag various bits of random files with categories, and specify the subset of that file (at the [Decl] level, rather than String-level) i want inserted into the Map, et voila
02:51:31 <Berengal> I wonder if it's possible to construct an isomorphism between haskell and a two-dimentional graph representation... Drag-and-drop editing
02:51:52 <ksf> _and_ I want a proper ex mode.
02:52:40 <mmorrow> then you can key-combo + enter a category name, and you get a nested frame of nested frames of various structured thingies, and you can blah blah -fdo-what-i-mean-damnit!
02:52:42 <mmorrow> :)
02:52:56 <crash[`]> M-x-C-butterfly
02:52:57 <mmorrow> heh
02:54:05 <mmorrow> Berengal: i think that the actions expressible with only a mouse and visual indicators aren't enough to really be able to handle everything
02:54:32 <mmorrow> i mean, take the mental process of programming a module/whatever
02:55:00 <mmorrow> there's a lot more going on there than you could express with graphics and mechanical manipulation of shapes
02:55:24 <mmorrow> but a cool graphical interface is always a win
02:55:28 <EnglishGent> is hpaste down?
02:55:31 <mmorrow> :o
02:55:41 * EnglishGent cant seem to get at it
02:56:41 <mmorrow> (un-deadlocked)
02:58:07 <EnglishGent> ty mmorrow :)
02:58:10 <mmorrow> :)
02:58:47 <Berengal> mmorrow: Possibly, but it'd be nice for refactoring or other higher-level editing
03:00:14 <EnglishGent> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13283#a13283
03:00:24 <EnglishGent> help - anyone? please? :)
03:00:29 <mmorrow> Berengal: oh sure. i just meant to say that, suppose you could express transformations with haskell one-liners (given some syntactic dsl + support functions + DOM-analog-structure for the datastructure you're logically operating within
03:00:48 <Berengal> It would become tedious to express everything with just the mouse...
03:01:07 <EnglishGent> how about an EEG interface?
03:01:09 <EnglishGent> :)
03:01:19 <Baughn> Even worse. ^^:
03:01:28 <Baughn> With a sideline of new robot overlords
03:02:22 <Saizan> EnglishGent: it has no way to tell that a and t should be the same in your case, it needs more annotations on that expression
03:02:40 <Saizan> EnglishGent: depending on which instances you want, you could add fundeps
03:03:30 <EnglishGent> okay - but then why does it match *at* all?
03:03:59 <Saizan> it's not matching, in fact
03:04:15 <Berengal> The error you get is exactly that: It can't match it
03:04:16 <EnglishGent> I could understand if I'd said instance (z -> Bool) [x] where ...
03:04:39 <Saizan> no, the problem is not inside the instance
03:04:53 <Saizan> the problem is that it can't tell that you want that instance for the expression in ghci
03:05:04 <Berengal> @type (odd, [1..10])
03:05:05 <lambdabot> forall a t. (Integral a, Num t, Enum t) => (a -> Bool, [t])
03:05:40 <Saizan> if you had an "instance (z -> Bool) [x] where" then it'd match
03:05:46 <Berengal> Note that this isn't (a -> Bool, [a])
03:05:54 <Saizan> a hacky thing you can do is use ~
03:06:41 <toast-opt> eh, quick q.  time function?  tick counts, stopwatch class, current clock time, something
03:06:47 <Berengal> instance (a ~ b) => Filter (a -> Bool) [b] where
03:06:49 <Berengal> That works
03:07:01 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13283#a13284 <- yeah, i just pasted that
03:07:15 <EnglishGent> toast-opt " :set +t "
03:07:41 <Saizan> also "+RTS -s" for programs
03:07:44 <McManiaC> what is ~ ?
03:07:49 <Berengal> Type equality
03:07:58 <McManiaC> aaah okay
03:09:15 <McManiaC> when are two types equal?
03:09:41 <mmorrow> when they're either the same type, or you've defined a type family + instances
03:09:55 <toast-opt> i'm just looking for something like C's "clock()"
03:09:56 <mmorrow> type family F a
03:10:03 <mmorrow> type instance F Int = Bool
03:10:03 <EnglishGent> wee! *another* language extension
03:10:11 <McManiaC> okay
03:10:11 <McManiaC> cool
03:10:32 <Saizan> ?hoogle Clock
03:10:32 <lambdabot> module Data.Time.Clock
03:10:33 <lambdabot> System.Posix.Types type ClockTick = CClock
03:10:33 <lambdabot> System.Time data ClockTime
03:10:39 <mmorrow> (Bool ~ F Int)
03:10:43 <Berengal> Type families and GADTs make Haskell that much closer to dependent types :)
03:10:44 <toast-opt> oh, hoogle is back up?
03:10:46 <toast-opt> sorry
03:10:49 <Saizan> ?hoogle getClockTime
03:10:49 <lambdabot> System.Time getClockTime :: IO ClockTime
03:28:06 <toast-opt> thx saizan
03:36:02 <mux> yay, cabal-install 0.6.4
03:36:09 <mux> anyone knows what's new in it?
03:38:27 <blueonyx> @src mapM
03:38:28 <lambdabot> mapM f as = sequence (map f as)
03:38:51 <Saizan> 1) works with ghc-6.12 2) you can make it keep an index of the installed haddock docs 3) ..
03:41:06 <FliPPeh> @hpaste
03:41:06 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:41:24 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5148#a5148
03:41:29 <FliPPeh> This code of mine confuses me
03:41:39 <FliPPeh> The type is "SafetyState Bool", SafetyState is.. my state.
03:41:52 <FliPPeh> BUT I can't do "return False" or "return True"
03:41:59 <FliPPeh> I can only return ()
03:42:35 <Baughn> Saizan: How do you make that index? I don't see a relevant option.
03:43:17 <Berengal> FliPPeh: All your returns need to return the same type
03:43:58 <FliPPeh> It compiles this way, even though it's function type is "State Bool" and everything wants "State ()"
03:44:27 <Saizan> Baughn: let me check if it's really available in the stable branch first :)
03:44:30 <Berengal> @type forever
03:44:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
03:44:36 <Baughn> Saizan: I'm actually on the darcs version. ^^;
03:44:47 <FliPPeh> It's the looping function?
03:44:48 <Berengal> forever doesn't care about the type of the input: It can return anything (since it never returns)
03:45:07 <Berengal> But the value if the input still needs to be well-typed
03:45:11 <Berengal> of*
03:45:49 <Saizan> Baughn: "doc-index-file: $datadir/doc/index.html" in ~/.cabal/config, anyway
03:45:49 <FliPPeh> Hmhm
03:46:00 <FliPPeh> I wanted to have it return "False" on exception
03:46:10 <FliPPeh> Because I can't use "catch" on my state functions
03:46:22 <Berengal> No can do. forever doesn't return, so you can't... return anything
03:46:28 <FliPPeh> thus "catch mainLoop (\e -> ..." is out of reach
03:46:43 <Baughn> Saizan: Hm. Guess I'd just failed to regenerate the config file
03:47:05 <FliPPeh> But yeah, I totally forgot about the forever there
03:47:07 <FliPPeh> Thanks :)
03:47:11 <Saizan> Baughn: it doesn't though the config file if there's already one
03:47:12 <FliPPeh> Gotta try something else
03:47:17 <Berengal> You could use an error-monad
03:47:17 <Saizan> Baughn: maybe we should fix that.
03:47:32 <Berengal> There are ways of exiting monadic computation that doesn't return anything
03:47:52 <Berengal> > forever Nothing
03:47:54 <lambdabot>   Nothing
03:47:57 <Baughn> Saizan: writeConfigFile (currentConfigFile `mappend` defaultConfigFile) or so?
03:48:09 <Baughn> Saizan: ..just be careful to do it transactionally.
03:48:22 * Baughn wonders if the prelude writeFile does that
03:49:19 <Saizan> *touch, btw
03:49:29 <Berengal> Baughn: isn't there some safe-file package on hackage that does that?
03:50:10 <Saizan> Baughn: yeah, though maybe users would complain about loss of their own comments if we just do that
03:50:22 <Baughn> Berengal: Not that I can see.. well, it ought to be a default
03:50:40 <Berengal> Baughn: Pretty sure there is, but I can't remember its name :/
03:50:42 <Baughn> Saizan: Add another comment format which can be copied, perhaps? % or so?
03:52:00 <Saizan> Baughn: maybe, or try to parse comments as flags as well and add only the flags that don't appear either in the source or the comments, and always keep all the comments
03:52:17 <Saizan> Baughn: can you open a ticket?:)
03:52:53 <Baughn> I suppose
04:01:40 <Baughn> Saizan: http://hackage.haskell.org/trac/hackage/ticket/613 <-- ..I may have been reading too much lesswrong.com lately
04:03:20 <Saizan> Baughn: if there's a concrete plan it's more likely to get fixed though
04:03:41 <Baughn> Saizan: I know, but it's not an important bug. I view this as an experiment.
04:03:58 <Baughn> Saizan: Ideally, it would be possible to put spoiler tags in the report. ;)
04:05:34 <smiler> @hoogle String -> Integer
04:05:35 <lambdabot> Prelude read :: Read a => String -> a
04:05:36 <lambdabot> Text.Read read :: Read a => String -> a
04:05:36 <lambdabot> Prelude error :: [Char] -> a
04:06:03 <smiler> @src read
04:06:04 <lambdabot> read s = either error id (readEither s)
04:07:32 <smiler> How can I convert a string to an integer?
04:08:22 <koala_man> read "1234" :: Integer
04:08:35 <jkff> > read "1234" :: Integer
04:08:36 <lambdabot>   1234
04:08:53 <chrisdone> @src any
04:08:53 <lambdabot> any p =  or . map p
04:09:12 <Phyx-> > read "chicken" :: BBQ Chicken
04:09:14 <lambdabot>   Not in scope: type constructor or class `BBQ'Not in scope: type constructor...
04:09:16 <Phyx-> awww
04:09:21 <chrisdone> would've said foldr1 (||) m'self
04:10:01 <Phyx-> @src or
04:10:02 <lambdabot> or    =  foldr (||) False
04:10:21 <chrisdone> haha, wtf
04:10:52 <chrisdone> @src foldr1
04:10:53 <lambdabot> foldr1 _ [x]    = x
04:10:53 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
04:10:53 <lambdabot> foldr1 _ []     = undefined
04:12:30 <smiler> Hmm, that wasn't really what I wanted to do
04:12:51 <path[l]> is there a nice way to take Just xs and get xs or [] ?
04:12:52 <smiler> What I actually need is to split "1234" into  [1,2,3,4]
04:13:23 <smiler> For an arbitary length of the string
04:14:39 <path[l]> > map digitToInt "1234"
04:14:41 <lambdabot>   [1,2,3,4]
04:15:42 <path[l]> something like that?
04:16:15 <smiler> ah, cool
04:16:43 <Jafet> > map digitToInt "lol"
04:16:44 <lambdabot>   [* Exception: Char.digitToInt: not a digit 'l'
04:16:52 <Jafet> @hoogle reads
04:16:53 <lambdabot> Prelude reads :: Read a => ReadS a
04:16:53 <lambdabot> Text.Read reads :: Read a => ReadS a
04:16:53 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
04:18:10 <jkff> @instance Traversable
04:18:10 <lambdabot> Maybe you meant: instances instances-importing
04:18:15 <jkff> @instances Traversable
04:18:16 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
04:18:26 <jkff> @instances Data.Traversable.Traversable
04:18:27 <lambdabot> Maybe, []
04:18:36 <jkff> So OK.
04:18:47 <jkff> > Data.Traversable.sequenceA (Just 1) :: [Int]
04:18:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:18:49 <lambdabot>         against inferred type ...
04:18:52 <jkff> Hm
04:19:13 <jkff> No, not quite that..
04:20:01 <EvilTerran> ?hoogle sequenceA
04:20:01 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:20:02 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
04:20:11 <jkff> (let f = msum . fmap return in f (Just 1)) :: [Int]
04:20:16 <jkff> > (let f = msum . fmap return in f (Just 1)) :: [Int]
04:20:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
04:20:17 <lambdabot>         against inferred typ...
04:20:20 <jkff> Grr
04:20:51 <jkff> > Data.Foldable.toList (Just 1)
04:20:51 <lambdabot>   [1]
04:20:51 <jkff> Yeah!
04:20:51 <jkff> Here you are path[l] :)
04:20:52 <path[l]> hi
04:21:07 <path[l]> oh
04:21:09 <path[l]> heh
04:21:40 <jkff> Yep
04:21:40 <path[l]> I was thinking of doing catMaybes though
04:21:41 <path[l]> cause I have like Just [] or Nothing
04:21:58 <path[l]> > catMaybes [Just [1,2,3], Nothing, Just [4]]
04:21:59 <lambdabot>   [[1,2,3],[4]]
04:22:14 <path[l]> hmm not quite I need to join those
04:22:20 <path[l]> still close enough
04:23:30 <jkff> > Data.Foldable.concat [Just [1,2,3], Nothing, Just [4]]
04:23:31 <lambdabot>   Couldn't match expected type `[a]'
04:23:31 <lambdabot>         against inferred type `Data.Mayb...
04:24:02 <jkff> Ah, not the right thing.
04:24:55 <watermind> where is catMaybes defined?
04:24:57 <jkff> Well, concat . catMaybes is not bad, is it? :)
04:25:00 <jkff> @src catMaybes
04:25:01 <lambdabot> catMaybes ls = [x | Just x <- ls]
04:25:04 <jkff> @info catMaybes
04:25:05 <lambdabot> catMaybes
04:25:11 <jkff> Oh, thanks, dear lambdabot
04:25:15 <jkff> So helpful of you
04:25:23 <jkff> @hoogle catMaybes
04:25:23 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
04:25:28 <watermind> ah
04:25:31 <watermind> thanks
04:25:47 <watermind> I searched in Data.List and Control.Monad :S
04:25:58 <jkff> > Data.Foldable.fold [Just [1,2,3], Nothing, Just [4]]
04:26:00 <lambdabot>   Just [1,2,3,4]
04:26:04 <jkff> Yeah again!
04:26:11 <jkff> I'm starting to like Data.Foldale
04:26:15 <Zao> Is it a cat? Is it a monad? It's a CatMaybe!
04:26:29 <jkff> The MaybeCat
04:28:04 <Twey> Schrödinger would love it
04:28:10 <watermind> @src Data.Foldable.fold
04:28:11 <lambdabot> Source not found. Wrong!  You cheating scum!
04:28:15 <watermind> :(
04:28:50 <Twey> @index catMaybes
04:28:51 <lambdabot> Data.Maybe
04:28:53 <jkff> Twey: Seen http://farm4.static.flickr.com/3522/3741819171_04fd45b201_o.png ?
04:29:14 <Twey> jkff: Hahaha
04:29:16 <jkff> watermind: fold is a member of the Foldable class
04:29:47 <jkff> Twey: that's from the Cartesian Closed Comic, http://ro-che.info/ccc/
04:30:08 <watermind> jkff: ah good point... is there a way to ask for the src of an instance?
04:30:18 <jkff> watermind: Don't know :)
04:30:23 <jkff> @help src
04:30:23 <watermind> :S
04:30:24 <lambdabot> src <id>. Display the implementation of a standard function
04:30:26 <Twey> Haha, nice comic
04:30:44 <jkff> I liked this one http://ro-che.info/ccc/images/shootout.png
04:32:24 <burp> lol
04:32:50 <path[l]> haha
04:32:52 <path[l]> nice
04:36:38 <watermind> ahhh! fold :: t m -> m  ... t is a Monoid!!
04:36:41 <watermind> not a Monad
04:37:02 <opqdonut> nnnooot really
04:37:09 <watermind> ?
04:37:28 <watermind> m
04:37:28 <opqdonut> m is a monoid and t is some sort of "container"
04:37:29 <watermind> eh
04:37:34 <watermind> yes I meant m
04:37:39 <opqdonut> ok, carry on then :)
04:37:45 <watermind> I kept reading Monoid as Monad
04:41:53 <mreh> > concat . take 3 $ repeat [1..3]
04:41:55 <lambdabot>   [1,2,3,1,2,3,1,2,3]
04:42:37 <mreh> easier way of doing that?
04:43:26 <opqdonut> > concat $ replicate 3 [1..3]
04:43:26 <lambdabot>   [1,2,3,1,2,3,1,2,3]
04:43:33 <opqdonut> > take 9 $ cycle [1..3]
04:43:34 <lambdabot>   [1,2,3,1,2,3,1,2,3]
04:43:51 <watermind> ok so that use of Foldable by jkff over there was overkill right
04:43:57 <mreh> :t replicate
04:43:58 <lambdabot> forall a. Int -> a -> [a]
04:43:59 <watermind> there was no need for Foldable
04:44:04 <watermind> Monoid would have been enough
04:44:20 <watermind> as in that case fold = mconcat
04:44:22 <watermind> right?
04:44:27 <opqdonut> > [1..3] >>= const [1..3]
04:44:28 <lambdabot>   [1,2,3,1,2,3,1,2,3]
04:44:28 <Saizan> yes
04:44:33 <opqdonut> there ;)
04:44:45 <mreh> :t const
04:44:47 <lambdabot> forall a b. a -> b -> a
04:44:50 <Saizan> no, wait
04:45:02 <Saizan> ?type Data.Foldable.fold
04:45:03 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
04:45:17 <mreh> [1..3] >> [1..3]
04:45:25 <mreh> > [1..3] >> [1..3]
04:45:26 <Saizan> yes, that's mconcat if t = []
04:45:26 <lambdabot>   [1,2,3,1,2,3,1,2,3]
04:45:42 <watermind> Saizan: ok thought so, thanks
04:45:44 <mreh> opqdonut: even better
04:45:59 <mreh> > [1..3] >> [1..4]
04:46:01 <lambdabot>   [1,2,3,4,1,2,3,4,1,2,3,4]
04:46:05 <opqdonut> ah, yeah
04:46:08 <opqdonut> stupid me
04:46:49 <mreh> let f n = [1..n] in f 3
04:46:50 <burp> > let f n = take n [1..] >> [1..n] in 3
04:46:51 <mreh> > let f n = [1..n] in f 3
04:46:52 <lambdabot>   3
04:46:53 <lambdabot>   [1,2,3]
04:46:57 <burp> oops
04:47:32 <mreh> > let f l n = l >> [1..n] in f [1..3] 3
04:47:34 <lambdabot>   [1,2,3,1,2,3,1,2,3]
04:48:13 <mreh> isn't there a function that does this already?
04:48:18 <burp> and what is the most efficient one? :D
04:48:40 <mreh> @hoogle [a] -> Int -> [a]
04:48:41 <lambdabot> Prelude drop :: Int -> [a] -> [a]
04:48:42 <lambdabot> Prelude take :: Int -> [a] -> [a]
04:48:42 <lambdabot> Data.List drop :: Int -> [a] -> [a]
04:49:13 <mreh> burp: I don't know, you tell me :)
04:49:36 <burp> let's add it to the shootout ;-)
04:51:09 <opqdonut> all of those probably have the same operational semantics
04:51:20 <opqdonut> especially after ghc has had a go with them
05:05:08 <mreh> has anyone trained perceptrons in here?
05:07:22 <mreh> i'm doing a haskell implementation, just a little sketchy on the algorithm itself
05:20:29 <ACSpike[Home]> is there any gui library that is generally preferred over the others?
05:20:55 <Peaker> ACSpike[Home], I hear of gtk2hs and wxhaskell over here a lot
05:21:44 <ACSpike[Home]> any for qt and tk?
05:29:17 * hackagebot upload: unicode-symbols 0.1 - Unicode alternatives for common functions and operators (RoelVanDijk)
05:30:40 <burp> yes, there is also qt, qthaskell
05:32:10 <ACSpike[Home]> if I'm new to haskell should I be trying to learn how to use something FRP like grapefruit?
05:32:30 <Raynes> ACSpike[Home]: It appears Gtk2hs and WxHaskell are the most popular with Gtk2hs being the more popular of the two. I've used Gtk2hs in the past, and intend to play with WxHaskell in the future.
05:35:27 <blueonyx> Raynes: do you intend to play with WxHaskell, because you used Gtk2Hs in the past?
05:35:58 <Raynes> blueonyx: I intend to play with WxHaskell, simply because I never have before.
05:36:27 <Raynes> Gtk2hs was cool.
05:37:13 <blueonyx> ah k
05:37:16 <dcoutts> I've been using gtk2hs recently, making commercial apps on windows
05:39:08 <Peaker> does qthaskell have a uic compiler from the UI designer?
05:39:18 <ACSpike[Home]> commercial apps == apps that run for 2-3 minutes during every 30 minutes of regularly scheduled programming?
05:40:42 <dcoutts> ACSpike[Home]: I'm not sure what you mean
05:41:22 <dcoutts> ACSpike[Home]: I'm not making malware if that's what you mean :-)
05:41:30 <dcoutts> stuff clients actually want
05:42:08 <ACSpike[Home]> dcoutts: no not at all. just a joking, but what sort of apps do you write? database frontends?
05:42:30 <dcoutts> ACSpike[Home]: I can't say precisely, I've got an 18 page NDA :-)
05:42:42 <skorpan> missiles... i knew it!
05:42:58 <ACSpike[Home]> 18 pages sounds like you can't even say imprecisely
05:43:25 <Raynes> ACSpike[Home]: He writes natural disasters for God. He got tired of doing everything himself, in Lisp.
05:43:33 <ACSpike[Home]> heh
05:43:46 <Raynes> And by God I mean Peaker.
05:43:48 <skorpan>  
05:43:48 <skorpan>  
05:43:48 <skorpan>  
05:43:48 <skorpan>  
05:43:48 <skorpan>  
05:43:49 <skorpan> maybe he's securing systems for the 2012 bu
05:43:53 <skorpan> g
05:44:11 <Raynes> And by natural disasters, I mean Basic dialects.
05:44:43 <dcoutts> Raynes: surely those are man-made disasters, not natural ones
05:45:16 <Raynes> dcoutts: Basic dialects grow on trees, didn't you know?
05:45:25 <dcoutts> crikey
05:52:23 * hackagebot upload: haskell-src-exts 1.3.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
05:58:59 <Berengal> Playing around with agda syntax has made me realize I want that in haskell as well
05:59:24 <mux> multifix operators?
05:59:52 <Berengal> Yep
05:59:58 <Berengal> And letters in operators
06:00:10 <mux> yeah that's rather cool :)
06:02:22 <Berengal> I mean, come on! Look at the pretty syntax! http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5151#a5151
06:03:33 <Phyx-> oh wow that's ugly
06:03:54 <Berengal> Phyx-: you think everything is ugly
06:04:10 <Phyx-> Berengal: I know, which is a problem when i look in the mirror
06:04:41 <Phyx-> but in all seriousness, don't particulairly like the "comm-+" function name or that it's allowed :(
06:05:27 <Phyx-> but maybe that's the haskell talking
06:06:05 <Berengal> If I had to name just one thing I'm missing in haskell's syntax it's - in identifiers
06:06:38 <Phyx-> maybe,  but i've gotten use to the camelCasing
06:06:44 <ksf> call-with-current-continuation
06:07:01 <ksf> callWithCurrentContinuation
06:07:12 <Phyx-> point taken
06:07:36 <Berengal> I've been using camelCase most of my programming career, but even just two weeks of lisp changed my mind
06:07:41 <Phyx-> but, you could do call_with_current_continuation
06:07:44 <Phyx-> which reads better
06:08:02 <ksf> no it doesn't.
06:08:02 <skorpan> Berengal++
06:08:22 <ksf> also, isDigit -> digit?
06:08:31 <Phyx-> i seem to be in the minority here, better shutup before i'm lynched
06:08:37 <Berengal> ksf: Yes!
06:08:42 <Berengal> (But not digitp)
06:08:55 <skorpan> why not digitp?
06:09:00 <ksf> sounds like pig latin
06:09:25 <Berengal> digitp is still better than isDigit, imho, but digit? is still much better
06:09:38 <opqdonut> yeah - in identifiers rules
06:09:56 <opqdonut> that agda syntax does look nice
06:10:09 <opqdonut> i've been doing lots of coq lately and it sometimes gets on my nerves
06:10:16 <opqdonut> especially ltac being so imperative
06:10:32 <skorpan> i tried coq but choked
06:10:59 <Berengal> I'm probably going to have to try coq sometime, but I still haven't grokked agda completely
06:12:13 <opqdonut> anyone have a link to some coq-versus-agda comparison?
06:12:54 <Berengal> http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.AgdaVsCoq
06:12:56 <opqdonut> ah, it seems nontrivial proofs in agda can be hard
06:13:23 <Berengal> Agda focuses more on the programming than the logic compared to coq
06:13:53 <Berengal> I think you can even turn off totality if you want...
06:14:23 <opqdonut> yeah, that's what that wiki page says
06:16:21 <djwonk> Phyx-: i think snake casing reads better. we could bring in the cognitive scientists and see if snake_case or CamelCase is easier for the brain to process. :)
06:24:09 <dubhrosa> quick newbie question, hope someone can help suggesting an elegant way to parse a file like "1\na\n3\na\nb\nc" into ["a\n","a\nb\nc\n"], i.e. there is a line count before each block that should be kept together, I have an ugly parser that works here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13289 but doesn't feel at all like the correct solution, any suggestions appreciated...
06:25:25 <Lemmih> dubhrosa: (x:xs) = lines l
06:26:43 <Lemmih> dubhrosa: parse [] = []; parse (x:xs) = unlines block : parse rest where (block, rest) = splitAt (read x) xs
06:27:39 * EvilTerran would be inclined to "lines" it into ["1","a","3","a","b","c"], then group things together again
06:29:18 <Twey> Yeah, I was thinking that
06:29:22 <Twey> lines and a foldr
06:32:41 <kingbiscuit> how do I put the results of two different funciton applications into a tuple? I have within a do structure, (result1, result2) <- (function1 arg1 arg2, function2 arg3 arg4) but that doesn't work
06:33:26 <poe> let (x',y') = (f x, g y)
06:33:32 <poe> in ...
06:33:41 <Zao> [r1, r2] <- sequence [f1 a1 a2, f2 a1 a2] ?
06:33:50 <Zao> kingbiscuit: I assume by function you mean monadic computation?
06:33:50 <poe> you can omit "in .." in the do notation
06:34:13 <kingbiscuit> hmm
06:34:36 <dubhrosa> thanks, I'll give that a shot
06:34:50 <Zao> <- expects something of type `m a' on the RHS
06:34:52 <kingbiscuit> yes Zao that's right
06:35:00 <Zao> While you have something of type (m a, m a)
06:35:05 <Twey> > (* 2) &&& (+ 3) $ 5
06:35:07 <lambdabot>   (10,8)
06:35:37 <ski>   (result1, result2) <- liftM2 (,) (function1 arg1 arg2) (function2 arg3 arg4)
06:35:38 <poe> I think it's okay to do r <- f ..; s <- g ..; in that case.
06:35:44 <FliPPeh> @hpaste
06:35:44 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:36:00 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152#a5152
06:36:05 <FliPPeh> Can this function be uncluttered?
06:36:13 <FliPPeh> I tried as hard as I could, but I don't see a better way :x
06:37:30 <FliPPeh> "PRIVMSG" -> handlePrivmsg prefix (head a) (last a)
06:37:35 <Twey> FliPPeh: Yes, it can
06:37:36 <FliPPeh> This one's dangerous, too
06:37:56 <FliPPeh> It practice it's safe to do that, as the list will at least be [x, y]
06:38:01 <Spockz> is there a way to trace which functions are being called through the ghci?
06:38:01 <FliPPeh> But it feels... bad
06:38:37 <FliPPeh> Twey, I'd be happy if you could help me with that :)
06:40:09 <FliPPeh> > let safeHead (x:y) = x in safeHead [1,2,3]
06:40:10 <lambdabot>   1
06:40:14 <FliPPeh> > let safeHead (x:y) = x in safeHead []
06:40:15 <lambdabot>   * Exception: <interactive>:1:137-154: Non-exhaustive patterns in function s...
06:41:18 <jkff> Hi again. We can get an analog of "virtual dispatch" in Haskell using GADTs like data ShowBox = forall a . Show a => MkShowBox a. I wonder if this can be extended to multiple virtual dispatch in some sense?
06:41:18 <Twey> FliPPeh: What do handlePrivmsg, performAutostart, &c. return?
06:41:44 <FliPPeh> They all return "SafetyState ()"
06:41:55 <Twey> Ah, okay
06:42:05 <Twey> So the return ()'s are redundant, aren't they?
06:42:12 <FliPPeh> I don't know
06:42:21 <Twey> Oh, wait, sorry — I was misreading
06:42:22 <FliPPeh> I can't leave it blank, can I?
06:42:33 <FliPPeh> Can't have dangling arrows there :)
06:42:40 <FliPPeh> pointing to eol
06:45:22 <FliPPeh> > let isPalindrome s = s == reverse s in isPalindrome "otto"
06:45:23 <lambdabot>   True
06:45:28 <FliPPeh> > let isPalindrome s = s == reverse s in isPalindrome "lagerregal"
06:45:29 <lambdabot>   True
06:45:33 <FliPPeh> > let isPalindrome s = s == reverse s in isPalindrome "lagerRegal"
06:45:34 <lambdabot>   False
06:46:31 <Twey> FliPPeh: I think ‘when’ is the most important transformation here
06:46:45 <FliPPeh> What does "when" do?
06:46:45 <Twey> when cond act = if cond then act else return ()
06:46:47 <FliPPeh> :t when
06:46:48 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:47:23 <Twey> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152#a5154
06:47:44 <Twey> (with pattern guards: {-# LANGUAGE PatternGuards #-}
06:47:59 <kingbiscuit> would anyone be able to tell me why my monadic computatoin doesn't work at the bottom of this paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13291
06:48:09 <FliPPeh> Wow
06:48:13 <FliPPeh> You really cleaned that up
06:48:32 <Twey> Arguably ☺
06:48:45 <Twey> Oh, the last set of brackets on the JOIN line is unnecessary
06:48:54 <FliPPeh> So, what does when do exactly?
06:48:58 <Twey> "JOIN"    -> get >>= flip when (addChannel $ head a) . (== nick') . userNick . userInfo
06:48:59 <FliPPeh> Is it like an If for monads?
06:49:03 <Twey> FliPPeh: Basically, yeah
06:49:23 <Twey> FliPPeh: With a default else case of ‘return ()’
06:49:28 <Zao> kingbiscuit: Well, what is the error and what are the types involved?
06:50:38 <Twey> Oh wait, crikey!
06:50:48 <Twey> Oh, no
06:50:53 <FliPPeh> :o
06:50:57 <Twey> That's okay… I thought I'd screwed up for a minute :þ
06:50:58 <jkff> kingbiscuit: Your code desugars to: addSTM tmvar increment = (takeTMVar tmvar, tryPutTMVar tmvar ((takeTMVar tmvar) + increment)) >>= \(result, isDone) -> ...
06:51:09 <jkff> But >>= has type m a -> (a -> m b) -> m b
06:51:27 <jkff> And you're giving it a (STM something, STM somethingelse) instead of "m a"
06:51:32 <kingbiscuit> well I always get: Main.hs:96:6:     Couldn't match expected type `(STM a, STM Bool)'            against inferred type `IO (STM Bool)'
06:51:32 <Twey> An advantage of ski's multiple equations is that you can handle ‘anything else’ with a single equation
06:51:50 * ski annotated "." with "using several equations" at <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152#a5153>
06:51:53 * ski annotated "." with "factoring out the \"catch-all\" case" at <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152#a5155>
06:52:25 <gio123> is here anybody from portugal?
06:52:27 <jkff> kingbiscuit: Yes, thats what I'm saying: according to >>=, IO (STM Bool) is expected, and you're giving it (STM a, STM bool) instead.
06:53:29 <jkff> kingbiscuit: you should do result <- ... ; isDone <- ...
06:53:40 <ski> hm, i suppose `when' i nicer, yes
06:54:18 <jkff> kingbiscuit: your code is wrong even ideologically: it doesn't specify whether you want it to be interpreted as do result <- ...; isDone <- ..., or vice versa
06:54:19 <ski> FliPPeh : do you care for me to make an annotation using `when' (but not pointless as Twey did) ?
06:55:06 <FliPPeh> Oh no, go ahead :o
06:55:52 <Twey> FliPPeh: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152#a5156
06:57:00 <Twey> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152#a5157 rather
06:58:33 <FliPPeh> :)
06:58:52 <FliPPeh> Asking for help here is always awesome
07:00:00 <Twey> Or else http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152#a5158
07:00:14 <Twey> (think that might go over the 80-column limit, but eh :þ)
07:00:34 <Twey> IMO, there should be a standardly-named ‘flip when’.
07:00:59 <FliPPeh> (Just NickName{}) "PRIVMSG")
07:01:00 <kingbiscuit> jkff: in an error, the inferred type is the one you're giving wrongly, and the expected type is the one you're supposed to give?
07:01:05 <FliPPeh> What's the record syntax for?
07:01:23 <ski> avoiding writing `_' for the arguments of the constructor
07:01:32 <FliPPeh> Ohh
07:03:06 <gio123> eh, i was very drunk yesterday
07:03:07 * Twey wishes hpaste had a real modify, for all these tiny annoying edits
07:03:39 <ski> "modify" isn't real ?
07:04:12 <kingbiscuit> anyone know if in an error, what is the difference between inferred and expected?
07:04:17 <kingbiscuit> type
07:04:19 * Jafet plops Twey in a do block
07:04:23 <Twey> Also, monospace fonts in the text box would be nice
07:04:29 <Twey> Arrgh!  *flails and tries to escape*
07:04:37 <ski> "expected" can be what you put in the type signature
07:04:37 <Twey> ski: It's not a real modify, no
07:04:45 <ski> what does it do, then ?
07:04:49 * ski has never tried it
07:04:54 <Twey> ski: It appends a new version
07:05:00 <Twey> Instead of updating the old one
07:05:06 <ski> i thought "add revision" did that ?
07:05:24 <Twey> Which sounds great, until you keep seeing things that you should have done and get this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5152
07:05:32 <Twey> They're the same
07:05:34 <ski> (or is the only difference whether the textbox is initialized with the previous paste/annotation or empty ?)
07:05:38 <Twey> Yeah
07:06:06 <FliPPeh> :)
07:06:34 <kingbiscuit> how do i convert a variable to an IO version of the variable?
07:06:45 <ski> `return aVariable'
07:06:46 <Twey> kingbiscuit: return
07:06:53 <Twey> (for any monad, not just IO)
07:07:07 <kingbiscuit> o, thanks
07:10:17 <koeien37> > return 3 :: Maybe Int
07:10:19 <lambdabot>   Just 3
07:11:02 <kingbiscuit> how to convert STM variable to regular variable?
07:11:30 <koeien37> you mean, "run an STM action"?
07:12:40 <koeien37> :t atomically
07:12:42 <lambdabot> Not in scope: `atomically'
07:14:02 <kingbiscuit> uhhh I guess so
07:14:26 <koeien37> atomically runs an STM action for you
07:14:34 <kingbiscuit> I have a function that returns a boolean whethe depending on whether or not hte STM action ran properly
07:14:45 <kingbiscuit> after I get the result of this function I want to use the Bool in a normal context
07:14:57 <koeien37> you can do
07:14:59 <kingbiscuit> but I keep getting  Couldn't match expected type `Bool'            against inferred type `STM Bool'
07:15:17 <koeien37> "normal context"? You mean IO ?
07:15:22 <kingbiscuit> ya
07:15:46 <koeien37> do { x <- atomically mySTMAction ; ... use x as Bool ... }
07:18:57 <jkramer_> Hello
07:19:02 <koeien37> hi jkramer_
07:19:18 <jkramer_> Is there a nice/simple module for number formatting?
07:19:37 <kingbiscuit> I tried doing that koeien37 but I get: Main.hs:95:0:     Occurs check: cannot construct the infinite type: a = STM a     When generalising the type(s) for `somefunction'
07:19:39 <jkramer_> ('ve found text.printf.mauke and xformat, but they seem rather big for my purposes
07:20:01 <koeien37> kingbiscuit: that is impossible to diagnose without seeing the source. could you paste it?
07:20:02 <koeien37> ?hpaste
07:20:03 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:20:04 <jkramer_> I just want to format a number as like %.02f
07:20:17 <koeien37> Text.Printf defines "printf"
07:20:25 <koeien37> > printf "0.02f" 37.0
07:20:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:20:27 <lambdabot>    `Text.Printf.PrintfType ...
07:20:36 <kingbiscuit> ok
07:20:36 <koeien37> > printf "%.02f" 37.0
07:20:38 <kingbiscuit> one sec
07:20:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:20:39 <lambdabot>    `Text.Printf.PrintfType ...
07:20:46 <koeien37> > printf "%.02f" 37.0 :: String
07:20:47 <lambdabot>   "37.00"
07:20:58 <Zao> > Text.Printf.printf "%03d %.2f" 42 3.579 :: String
07:20:59 <lambdabot>   "042 3.58"
07:21:27 <nostrand> hi, where do a i put function declarations in an Alex file?
07:22:22 <kingbiscuit> how do I add in haskell? can I do : (5 + 6 + (+ 7 8))
07:22:33 <koeien37> no
07:22:42 <koeien37> > 5 + 6 + ( (+) 7 8)
07:22:44 <lambdabot>   26
07:22:56 <jkramer_> koeien37, Zao Thanks
07:22:57 <koeien37> + is infix, you can use (+) to use it prefix
07:23:21 <kingbiscuit> oh
07:23:25 <kingbiscuit> thanks
07:23:25 <koeien37> you can also use sections, like (+37) to define the function that maps x to x + 37
07:27:16 <kingbiscuit> I see
07:27:26 <kingbiscuit> ok I pasted the function...can't figure it out: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13294#a13294
07:27:43 <kingbiscuit> I'm trying to increment an STM var up to a limit
07:28:51 <koeien37> do you want to do this atomically, i.e. in one transaction?
07:28:58 <koeien37> or should your increments be transactions by themselves?
07:29:31 <kingbiscuit> they should be transactions by themselves
07:29:54 <koeien37> your takeTMVar and tryPutTMVar should be in one transaction, then
07:42:15 <watermind> MonadSum instances are Monoids rights?
07:42:21 <watermind> *right
07:47:20 <kingbiscuit> anyone know how to put takeTMVar and tryPutTMVar in one transaction here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13294
07:48:02 <watermind> what is wrong here?
07:48:02 <watermind> instance MonadPlus m => Monoid (m a) where
07:49:12 <Saizan_> it's an overlapping instance
07:49:22 <Saizan_> and undecidable too!
07:49:36 <Saizan_> (probably)
07:49:37 <Axman6> kingbiscuit: why are you using ((+) result delta)? :\
07:49:58 <kingbiscuit> prefix is wrong?
07:50:07 <watermind> Saizan_: nah...
07:50:19 <watermind> never mind with fglasgow-exts it works
07:50:26 <kingbiscuit> should I always use infix then
07:50:55 <watermind> Saizan_: I don't think fglasgow-exts includes overlaping instances ...
07:51:23 <Axman6> kingbiscuit: not wrong, but ugly and basically never used for infix functions
07:51:23 <watermind> ok so is there some reason not to have this instance by default ?
07:51:58 <watermind> instance MonadPlus m => Monoid (m a) where   mempty  = mzero;  mappend = mplus
07:52:08 <watermind> other than the fact that it's not H98
07:52:10 <Axman6> kingbiscuit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13294#a13295
07:52:29 <watermind> but I think there's plenty of non H98 stuff there
07:52:45 <Axman6> kingbiscuit: i assume you're new to haskell? you code has some rather odd parts to it
07:54:06 <Saizan_> watermind: that it overlaps with many other instances, try to use it, you'll get the error
07:56:24 <watermind> Saizan_: I see...
07:56:41 <watermind> Saizan_: I wonder if there is any overlapping definition that doesn't coincide with mine though
07:57:00 <watermind> Saizan_: for lists and maybe they are surely the same
07:57:08 <Saizan_> watermind: they aren't
07:57:11 <Saizan_> for Maybe
07:57:20 <kingbiscuit> Axman6: very new, thanks for the help but now I get a parse error on input `putStr'
07:57:23 <Saizan_> > Just [1] `mappend` Just [2]
07:57:25 <lambdabot>   Just [1,2]
07:57:34 <Saizan_> > Just [1] `mplus` Just [2]
07:57:35 <lambdabot>   Just [1]
07:58:12 <watermind> oh right
07:58:20 <mercury^> :t mplus
07:58:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
07:58:29 <mercury^> :t mappend
07:58:29 <watermind> Saizan_: nevermind you're right
07:58:31 <lambdabot> forall a. (Monoid a) => a -> a -> a
07:58:42 <Saizan_> watermind: also, your instance doesn't overlap only with the MonadPlus'es, it overlaps with any instance of the form (t a)
07:59:13 <Saizan_> watermind: since the context is not taken in consideration when deciding which instance to pick
07:59:17 <watermind> Saizan_: hmm howcome ?
07:59:24 <watermind> oh
07:59:41 <watermind> hmm how can that be
08:00:02 <Saizan_> it's only checked after the decision is taken
08:00:21 <mercury^> Hmm, MonadPlus is just (Monad, Monoid)?
08:00:26 <watermind> Saizan_: to see if it satisfies the requirements?
08:00:26 <mercury^> (With different names)
08:00:27 <Saizan_> it's to keep the open world assumption, you could always add an instance later
08:00:39 <Saizan_> watermind: yeah, with no backtracking
08:00:50 <watermind> Saizan_: right makes sense
08:01:20 <ksf> if ! is bang and # is hash, what's ?
08:01:53 <Saizan_> mercury^: a bit stronger, a MonadPlus m has to form a monoid (m A) in the same way for any A
08:02:02 <Jafet> ksf, wtf
08:02:24 <ksf> ?. the character '?'
08:02:24 <lambdabot> Plugin `compose' failed with: Unknown command: "the"
08:02:25 <watermind> :D
08:02:35 <Runar> ksf: cond
08:02:48 <ksf> QuestionMark makes for an abysmal constructor.
08:03:01 <poe> the composition of ?! is called interrobang, so ? is something "interro.." :)
08:03:03 <Saizan_> Hook?
08:03:07 <Runar> * is splat
08:03:08 <Jafet> So do Bang and Hash...
08:03:45 <Runar> @arr Saizan_
08:03:45 <lambdabot> I want me grog!
08:04:02 <Saizan_> @arrr indeed
08:04:03 <lambdabot> Drink up, me 'earties
08:06:46 <ksf> "The symbol is also sometimes [6] thought to originate from the Latin quaestiō (that is, qvaestio), meaning "question", which was abbreviated during the Middle Ages to Qo."
08:06:47 <DonTony> quit
08:06:52 <ksf> Qo sounds good.
08:09:47 <ksf> wikipedia also lists "query"
08:10:28 <SamB_XP_> interrogator?
08:10:32 <Axman6> kingbiscuit: remove a space before       (done,result) <- atomically $
08:14:01 <Axman6> kingbiscuit: after having a look at your code, i believe this is what you actually want: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13294#a13298
08:14:46 <Axman6> kingbiscuit: uh, except, change done' <- to say done instead
08:14:55 <Axman6> done <-*
08:15:36 <kingbiscuit> i will try that, thanks
08:16:24 <Axman6> kingbiscuit: go and read the docs for STM, and see if you can find some tutorials. you'll see that what you were doing should have been done using retry like i implemented
08:17:23 <Axman6> and i'm off to bed.
08:20:06 <chrisdone> ever hold Skype meetings about Haskell?
08:20:17 <kingbiscuit> does the spacing matter? i keep getting not in scope errors
08:21:15 <Jafet> king, sometimes.
08:26:37 <EnglishGent> chrisdone - I'd be willing to join in if anyone is interested in organising any :)
08:28:53 <Jedai> kingbiscuit: depends on what you call "spacing", indentation matters but whitespace between tokens on the same line does not
08:30:35 <Jedai> kingbiscuit: Use of an Haskell IDE (or rather editor aware of Haskell needs) can help, or some strict rules, avoid tabulations, always start a block on a fresh line, ...
08:31:29 <kingbiscuit> I see
08:31:50 <kingbiscuit> why do they do indentation rules like that
08:31:51 <kingbiscuit> such a pain
08:32:06 <wzp> simple question, is _ synonym for "anything" ?
08:32:19 <FunctorSalad> wzp: in patterns, yes
08:32:44 <wzp> is there another definition for it ?
08:32:48 <Jedai> kingbiscuit: I rather like it, the rules are pretty simples
08:33:01 <Jedai> kingbiscuit: Did you take the time to read them somewhere ?
08:33:14 <mauke> kingbiscuit: uh, why are you using them?
08:33:27 <mauke> you can always write your code with { ; } and ignore the layout
08:33:29 <eldragon> Lamping90 didn't complete its algorithm, he did unsolved holes!.
08:33:47 <Jedai> kingbiscuit: The rules I just gave you are just to help if you have difficulties with layout, they're not obligatory
08:33:51 <eldragon> and he didn't show us his algorithm!
08:34:25 <eldragon> instead, he reported ideas, but it's unsufficient.
08:34:54 <kingbiscuit> what do you mean use {  ; } and ignore the layout
08:35:22 <Jedai> kingbiscuit: the basic rules is that the indentation of a block is established by the first token of the block like putStr in : do putStr "hello"
08:35:28 <eldragon> Asperti94 did much effort to repair some important holes of Lamping90
08:36:25 <Jedai> kingbiscuit: You don't _have to_ use layout in Haskell, you can use explicit blocks with braces and semicolon like in a C-like syntax
08:36:25 <eldragon> for Lamping90, croissants and brackets didn't exist.
08:36:36 <kingbiscuit> oh ok
08:36:43 <Phyx-> boy weekends are boring
08:36:45 <Jedai> kingbiscuit: but most people use it
08:36:49 <Phyx-> guess i should get on with reading papers
08:37:11 <Jedai> kingbiscuit: since it's convenient, easier to the eyes and used by almost every important code in Haskell
08:37:29 <eldragon> Jedai, i will write code in pure lambda calculus
08:37:51 <chrisdone> eldragon: it's too dangerous to go alone, take fix
08:37:53 <eldragon> as if it's in year 1970
08:39:02 <Jedai> kingbiscuit: So as I said the first token of a block (started by do/where/let/case of) fix the indentation level of the block, then any line with the same indentation level start a new statement in this block, any with a superior indentation level continue the previous statement and any with an inferior indentation level ends the block
08:39:14 <FunctorSalad> eldragon: Lamping90?
08:39:52 <Jedai> kingbiscuit: the indentation level of the block is determined by the position of the first token on the line (so empty lines don't count)
08:40:01 <Jedai> s/block/line/
08:40:03 <kingbiscuit> I see
08:40:27 <kingbiscuit> when you say inferior indentation, does the actual number of spaces matter
08:40:29 <gwern> this channel is making me hungry
08:40:30 <kingbiscuit> or just that it's more indented
08:40:43 <mauke> the latter
08:40:44 <eldragon> FunctorSalad, yes, he discovered partially the problem of optimality of Levy/Wadsworth
08:40:48 <Jedai> kingbiscuit: a tabulation (the character, not the keypress) count for 8 spaces, so you better avoid them and use just whitespace
08:40:54 <chrisdone> gwern: have a bacon sandwich
08:41:06 <gwern> chrisdone: I don't have any bacon
08:41:06 <djwonk> looking for some help on how to streamline a function: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5164#a5164
08:41:19 <chrisdone> gwern: a nothing-sandwich it is!
08:41:21 <kingbiscuit> I see, thanks
08:41:32 <Jedai> kingbiscuit: the only thing that count is if there are more or less spaces, the exact difference does not matter and can be adjusted according to your taste
08:41:36 <gwern> despair! despair! this world lacking fatty meats has left me in despair!
08:41:44 * gwern goes and hangs self from a lambda
08:42:10 <chrisdone> someone hath taken your bacon
08:42:23 <djwonk> i get the feeling that if i understood sequence or mapM better this would be easy
08:42:33 <Jedai> gwern: You've watched to much zetsubou sensei...
08:42:50 <FunctorSalad> what's it with all this hype about bacon...?
08:42:53 <chrisdone> :t (sequence .) . map
08:42:54 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
08:42:57 <chrisdone> :t mapM
08:42:58 <gwern> Jedai: I'd respond to that, but I'm afraid your words just make no sense to me
08:42:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:43:26 <mux> I think zetsubou is despair in japanese
08:43:42 <mux> I don't know zetsubou-sensei though :)
08:43:45 <Jedai> gwern: Oh, that's interesting, your sentence is exactly the same as the signature sentence of this show
08:44:01 <djwonk> chrisdone: i think i'm looking for a fold actually, each playerTurnLoop is a mutator
08:44:12 <chrisdone> EnglishGent: well, my Skype username is, surprisingly, chris.done if you want to chat about Haskell or your feelings
08:44:38 <chrisdone> djwonk: there is foldM!
08:44:48 <eldragon> it's a long story: Wadsworth71 -> Levy80 -> Lamping90 -> Asperti94 -> ... until the Interaction Systems ... -> to now it's still unsolvable.
08:44:48 * djwonk does the happy dance
08:45:12 <FunctorSalad> happy...
08:45:23 <mauke> ツ
08:46:01 <eldragon> how many beta-reductions computes the Haskell code?
08:46:47 <Jedai> djwonk: board <- foldM (\board n -> playerTurnLoop (players !! n) board) board [0,1,2,2,1,0]
08:46:51 <gwern> eldragon: who knows?
08:47:01 <Jedai> djwonk: or something like that...
08:47:27 <djwonk> Jedai: thanks
08:47:35 <eldragon> i know that Haskell has a theorical weakness
08:48:21 <gwern> perish the thought!
08:48:53 <FunctorSalad> if you tie two Haskells together, they'll be unstoppable
08:51:02 <gwern> FunctorSalad: with a chain! haskell-chucks
08:51:37 <chrisdone> awesome, found my game boy advance. I wonder if I can purchase some equipment for programming it
08:52:33 <Draconx> chrisdone, there are sketchy online vendors in china that sell that sort of stuff.
08:53:09 <chrisdone> excellent
08:53:29 <ehamberg> and there are tonnes of tutorials. the demo scene seems to love the gba.
08:53:38 <gwern> chrisdone: what would be the point of that?
08:53:47 <eldragon> i will build a lambda-calculus interpreter better than Haskell, yes, the archaicqest is strongest!
08:53:54 <chrisdone> gwern: I could write mini-games :D
08:54:08 <djwonk> FunctorSalad: when The Invasion of the Monads arrives, don't expect C++ to save you
08:54:11 <gwern> chrisdone: get a gp2x or something. you'll have massively better hardware, and you might even save money since you won't need specialist equipment just to modify it
08:55:01 <chrisdone> gwern: wow, I had never heard of this
08:56:12 <djwonk> Jedai: i swapped the params of playerTurnLoop to get: board <- foldM playerTurnLoop board $ players ++ reverse players
08:56:59 <FunctorSalad> "Naive implementation of error handliing which converts Get monad into
08:56:59 <FunctorSalad> hybrid of state monad and error monad (Either like) gives about 5 times slowdown."
08:57:06 <FunctorSalad> I find that a bit concerning
08:57:29 <FunctorSalad> why so much?
08:57:55 <FunctorSalad> I would have expected the Either monad to compile to something fairly efficient
08:58:19 <FunctorSalad> he's talking about `binary', btw
08:59:06 * ksf hates alex
08:59:10 <ksf> the lexer, that is.
08:59:15 <FunctorSalad> :-(
08:59:23 <Saizan_> FunctorSalad: it can be bad, depending on how the expressions nest
08:59:52 <gwern> FunctorSalad: did you look at the core?
09:00:43 <Saizan_> FunctorSalad: also, binary was quite finely tuned with INLINE pragmas etc.. anything "naive" is going to be noticeable
09:01:07 <FunctorSalad> gwern: not yet
09:01:15 <FunctorSalad> Saizan_: ah, that would explain some
09:01:28 <FunctorSalad> gwern: suspecting something?
09:01:36 <gwern> FunctorSalad: no, not really
09:02:01 <gwern> but then, I've heard that monads compile inefficiently compared to CPS or alternative methods
09:03:03 <eldragon> lambda calculus is as the precursor of lisp and as the lisp of the modern functional programming languages.
09:03:56 <FunctorSalad> naively you'd think that the Either monad should be implemented with jumping or exception-throwing once an error appears, not construct and deconstruct Eithers at every step ;)
09:04:44 <gwern> hie thee to the core!
09:04:49 <c_wraith> No I wouldn't :P
09:04:56 <Saizan_> i think the problem is seeing when you can do that without losing sharing, for ghc
09:04:57 * gwern coins a Haskell expression: 'needs moar core'
09:05:13 <Saizan_> since the Codensity transformation has that effect
09:05:30 <FunctorSalad> c_wraith: hmm
09:06:01 <FunctorSalad> gwern: not sure about a good example to core
09:06:17 <Saizan_> (and Codensity (Either e) is more or less jumping and exception-throwing)
09:06:25 <eldragon> i don't agree the non-kiss principle of the haskell code that has too premature optimizations (a.k.a is the evilness in the Knuth's sense).
09:06:29 <FunctorSalad> Saizan_: interesting
09:07:39 <ksf> prematiure generalisation is the root of all procastination
09:08:23 <Phyx-> ksf: i thought the doing nothing part was
09:08:35 <eldragon> hahaha ksf
09:09:30 <Phyx-> oh it was a joke.... guess my humor detector is broken today
09:09:55 <ski> re "Either monad should be implemented with jumping or exception-throwing" : it might be nice to have "unboxed variant" types behaving like "Multi-return Function Call" <http://www.ccs.neu.edu/home/shivers/papers/mrlc-jfp.pdf> (Olin Shivers and David Fisher)
09:10:41 <eldragon> ski, don't use monads, think in lambda calculus, i don't need monads.
09:11:26 <ski> eldragon : .. can you elaborate on how that relates to what i said ?
09:12:00 <ski> (and "monad" in "Either monad" there is irrelevant to my comment)
09:12:19 <eldragon> i can't elaborate
09:12:27 <Phyx-> isn't "don't use monads" rather extreme
09:12:38 <Runar> it's wrong
09:13:30 <eldragon> in words of Rosser-Church, all is computable in lambda calculus, what's the problem?
09:14:08 * ski sometimes uses monadic reasoning, sometimes not, when "thinking in lambda calculus" .. the former doesn't exclude the latter
09:14:20 <c_wraith> Why not use monads, if the abstraction makes your code cleaner?
09:15:32 <Phyx-> it's like saying "everyone should only use assembly langauge"
09:15:49 <Runar> it's not like saying that at all
09:16:03 <eldragon> hahaha Phyx, is Church's lambda calculus the assembly language? hahahaha
09:16:21 <ski> in some sense, yes
09:16:40 <c_wraith> In the same way the turing machine is an assembly language, actually.
09:17:22 <Runar> eldragon: monads and lambda calculus are not mutually exclusive. You can't have one without the other.
09:17:23 <eldragon> for my mind, lambda calculus is highest language
09:17:33 <ski> representing algebraic types with a Church representation is a tedious lowlevel detail
09:17:34 <Phyx-> eldragon: i don't see what's so funny, besides, i wasn't comparing the two, i was comparing your analogy
09:17:36 <gwern> c_wraith: I think the issue is that we shouldn't pay 5x or 10x slowdowns just for monads, especially if they could be compiled more efficiently
09:18:52 <c_wraith> gwern:  I think if you're seeing that kind of slowdown in a real application (rather than a benchmark of an error-handling system) you've designed something very poorly
09:19:05 <FunctorSalad> so I wasn't completely off? :o
09:19:22 <gwern> c_wraith: you think whoever was modifying binary did something very poorly?
09:19:36 <Saizan_> gwern: he said he did it naively.
09:19:54 <gwern> Saizan_: where naive = didn't do the compiler's job for it?
09:20:05 <FunctorSalad> ski: heh what does this quip in the paper about continuations "breaking the bank" mean?
09:20:11 <FunctorSalad> (in the capsule review)
09:20:52 <Saizan_> gwern: no idea, not looked at the code
09:21:18 <c_wraith> gwern: I don't have the full context here, as I missed the start of this.
09:21:50 <Saizan_> gwern: though since the base binary code was full of INLINE pragmas and strictness annotations, getting 5x slowdown from a "naive" approach doesn't surprise me
09:22:03 <gwern> Saizan_: yes, you said that already I think
09:22:30 <c_wraith> gwern:  But I do think that binary probably is a worst-case, as it's one of the few times I can see an error actually propogating from anywhere in the system, rather than from a few select points.
09:22:30 <Runar> is somebody blaming that slowdown on "monads"?
09:22:43 <Saizan_> Runar: on adding the error handling
09:22:47 <c_wraith> Runar: as I understand, it's being blamed on Either, specifically.
09:22:56 <Saizan_> Runar: we actually don't know how the error handling is implemented
09:22:58 <c_wraith> Runar: and the implementation of >>= for Either e
09:23:01 <gwern> Runar: this wouldn't be the first time, btw. there was a few years ago someone who swapped code from monads to CPS and got major speedups
09:23:30 <ksf> it's more likely that code gets slower than faster if you randomly add strictness.
09:23:31 <FunctorSalad> is `Get' a state monad already? (he said he turned Get into a StateT/Either hybrid)
09:23:37 <ksf> ...that's at least my experience.
09:23:43 <eldragon> "aggressive optimizations = premature optimizations = Knuth's roots of evilness."
09:23:48 <c_wraith> gwern: did they use the CPS monad for that? >_>
09:23:50 <Saizan_> FunctorSalad: yes, but reimplemented
09:23:50 <Runar> is that a GHC issue? Saying "monads are slow" is like saying "triangles are large"
09:23:59 <gwern> c_wraith: no, straight CPS, IIRC
09:24:45 <Saizan_> gwern: are you talking about ddarius and roconnor?
09:24:55 <gwern> Saizan_: I don't recall
09:24:55 <eldragon> what's the contrario? "c-o-n-s-e-r-v-a-t-i-v-e"
09:25:07 <Saizan_> they reimplemented the monad taking its CPS transformation, but still using the monad interface
09:25:31 <FunctorSalad> like in edwardk's monad-ran?
09:25:40 <Saizan_> using "forall r. ContT r m" instead of "m"
09:25:45 <FunctorSalad> ah
09:25:54 <ski> FunctorSalad : related to that i think, yes
09:26:13 <Saizan_> yeah, monad-ran is going further in that direction
09:26:52 <c_wraith> I mean, >>= for Either e *is* inherently somewhat inefficient.  It constructs and pattern-matches an Either for every bind.  That's going to be slower than a jumping-based solution, in pretty much every case.  But that's not the fault of "monads"
09:26:53 <Saizan_> with ContT you get (a -> m r) -> m r, with monad-ran you can use two distinct functors (a -> f r) -> g r
09:27:30 <ski> FunctorSalad : re "break the bank", i don't know
09:28:33 <ski> (c_wraith : yes. i'm imagining that if we had an "unboxed `Either'" type, things would be better here)
09:29:32 <narens> a design question: Say I code a covariance function that takes two lists xs and ys... and internally, it needs to compute mean1 mean2 to get the final result. But, this is extra work if I already have it calculated.... so I could pass them in as arguments but that becomes really ugly. I could use the State monad, but that seems like too much. I explored memocombinators but that won't work acrross functions so the calculated values can
09:29:32 <narens> be cached. I guess what I am asking as what is the best way to implement a simple cache that can be used for situations like this. Would a combinator be a good choice, where the input is an array and the output is of the form (Cache -> Result).
09:29:40 <Saizan_> (the instances defined via Ran look almost like a church encoding)
09:30:41 <Runar> ski: Would a church encoding of Either perform better?
09:32:04 <c_wraith> But in most cases, I'd expect Either to be used at a relatively high level, in comparison to the code using most of the CPU time, and so the cost of using it would be almost negligible.  binary seems like a special case, in that the error cases are at the very lowest levels.
09:32:23 <Saizan_> however, it's not a panacea, you can find cases where using these monad-ran versions perform way worse
09:32:52 <ski> Runar : i think it would be comparable .. maybe an "unboxed" version could be slightly more efficient (due to non-first-class-ness)
09:33:16 <Gracenotes> pattern matching does essentially compile down to continuation using a stack.. >_>
09:33:39 <narens> anyone? :-)
09:34:12 <c_wraith> narens:  reader monad?
09:34:14 <Saizan_> well, you'd get an effect comparable to list deforestation though
09:34:21 <FunctorSalad> narens: maybe make a type that contains both the values and the mean?
09:34:30 <FunctorSalad> data Sample = Sample [Double] Double
09:34:31 <Saizan_> >>=-fusion
09:34:44 <narens> I mean this is not just for covaraince... but a whole slew of univariate stats
09:34:49 <FunctorSalad> narens: due to lazyness the mean would only be calculated if needed
09:35:09 <ski> (The idea basically being that whenever an expression of type `Either# a b' is forced, instead of passing a return address to return the value to, two return adresses are passed (corresponding to the two branches of an `Either#' `case'), and one of them will be chosen)
09:35:12 <c_wraith> narens:  clever use of nested scope so the other results are still in scope for this function?
09:35:33 <Runar> > let left x f g = f x; right x f g = g x in (left "Look, a monad in lambda calculus") id id -- eldragon
09:35:34 <lambdabot>   "Look, a monad in lambda calculus"
09:35:55 <ski> (so e.g. `Left# x' means : select the first return address, and return `x' to it)
09:36:05 <narens> but, in a situation when I calcualte mean separately use it and then sometime later i caclulate cov.. then i do extra work. I kind of don't want to use a monad because that would restrict its usage in simple cases
09:36:11 <Saizan_> ski: isn't that a lowlevel version of passing two heakell-level continuations?
09:36:27 <ski> yes
09:37:07 <ski> in the same sense that the ordinary implicit continuations, are a lowlevel version of CPS
09:38:05 <narens> Is there a general Cache implementation apart from the state monad. I made one that was a Map containing arbitrary keys so I can use algebraic types like MEAN and STD... and Dynamic values. I guess I am asking if there is a standard lib for a Cache system.
09:38:25 <ski> the "unboxed" restriction here being that you can't put a "value" of type `Either# a b' into a datastructure (since it doesn't actually construct a tag, it instead selects the correct continuation/branch to use)
09:39:04 <Saizan_> narens: there are various libs for memoization, i'm not aware of ones for caching
09:39:23 <narens> Saizan_: memoization only works within a function right?
09:39:34 <ksf> everything is a function
09:39:39 <narens> Saizan_: I mean mainly for DP
09:39:41 <FunctorSalad> or a data
09:39:46 <FunctorSalad> ;)
09:39:55 <ksf> that's a function that takes no arguments
09:39:58 <Saizan_> narens: memoization works as long as you've a reference to the same memoized version of the function
09:40:17 <mmorrow> machine code is homoiconic
09:40:22 <narens> indeed, but when I tried using it in map, it kept recalcuating but when i used a fold it didn't
09:40:39 <Saizan_> maybe you didn't use a CAF?
09:40:39 <ski> (so it is really the continuations to expressions of type `Either# a b' which would be unboxed .. since such a continuation is a pair of one continuation for `a' and another for `b', the "unboxed" means that these two are provided separately .. cf. `(# a , b #)', here values of types `a' and `b' are given separately)
09:41:02 <mmorrow> narens: what do you want to key on for this cache? ptr equivalence of arguments?
09:41:28 <narens> mmorrow: no, I didn't think you could do ptr equivalence
09:41:57 <mmorrow> narens: yeah, that wouldn't work here
09:42:04 <FunctorSalad> using the list of samples as a key would take as much time as recalculating the mean, no?
09:42:07 <narens> mmorrow: right? because let p = [1..] in p == p would go on forever
09:42:11 <mmorrow> narens: then what?
09:42:19 <mmorrow> narens: not unless you cheat
09:42:21 <FunctorSalad> narens: missed my reply?
09:42:34 <FunctorSalad> (make type containing the values and the mean)
09:42:48 <narens> FunctorSalad: I wasn't using the samples as Key just a constructor MEAN, STD etc
09:43:01 <FunctorSalad> the previous one I mean :)
09:43:03 <mmorrow> ski: kind of like a scott encoding
09:43:30 <narens> but yea, i think i am just going to settle with the state monad, but is there a penalty for carrying around the samples?
09:43:47 <narens> for eg.. if its a big list. I mean, I know this is how parsing libs carry around the text right?
09:43:48 <c_wraith> narens:  If you're not going to mutate it, please use the Reader monad
09:43:54 <mmorrow> ski: (which has an infinite type in hindley milner :/)
09:43:56 <narens> I do need to mutate
09:44:12 <c_wraith> narens: ah, ok.  And the cost isn't really an issue.
09:44:19 * ski has no idea what a scott encoding is
09:44:36 * hackagebot upload: hoauth 0.1.9 - A Haskell implementation of OAuth 1.0a protocol. (DiegoSouza)
09:44:43 <c_wraith> narens:  Think of the state monad as creating a function from state -> result
09:45:04 <mmorrow> ski: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=112
09:45:06 <Saizan_> state -> (newstate,result)
09:45:13 <FunctorSalad> ski: would we really need unboxed Either? can't ghc notice when an Either is returned and pattern matched on right away?
09:45:24 <FunctorSalad> (and not stored otherwise)
09:46:04 <ski> FunctorSalad : possibly. i'm imagining it might be simpler for the compiler to translate things to `Either#' internally, when it can detect that it may do so
09:46:47 <ski> (and so you can use `Either#' if you want to get hard guarantees, like with unboxed tuples)
09:46:57 <mmorrow> ski: the paper linked to at the bottom of this page has a nice classification of various encodings http://en.wikipedia.org/wiki/Scott_encoding
09:47:43 <Saizan_> well Either is not recursive, so church and scott are the same, right?
09:48:06 <eldragon> the term "lazyness" is a little confuse, there are 2 kinds of "lazyness": the "optimal lazyness" in the sense of Wadsworth/Levy of reaching to the minimum of beta-reductions and the "lazyness" in current functional programming languages that almost of them prevent some reevaluations of the work if they can.
09:48:32 <mmorrow> Saizan_: hmmm, i think so maybe
09:49:05 <ski> (on page 4 in that paper, you can imagine `recur :: [a] -> Either [a] ()' and read `multi () #2',`multi (recur xs) (fn ans => x::ans) #2',`multi (recur xs) #1 (fn () => xs)',`multi (recur lis) #1 (fn () => lis)' as `Right# ()',`case recur xs of Left# ans -> Left# (x:ans); Right# u -> Right# u',`case recur xs of Left# ans -> Left# ans; Right# () -> Left# xs',`case recur lis of Left# xs -> xs; Right# () -> lis')
09:49:10 <c_wraith> eldragon: I've never heard the latter referred to as "lazy".
09:49:15 <mmorrow> left f g a = f a; right f g a = g a
09:49:17 <ski> (er, s/Either/Either#/)
09:49:34 <ski> maybe it'll be clearer if i paste what i mean ..
09:50:10 <eldragon>  # beta-reductions of ("normal lazyness in FP languages") >= # beta-reductions of ("optimal lazyness")
09:50:20 <Saizan_> yeah, that's the church encoding for Either too
09:52:59 <ski> (Saizan_ : was that comment for me ?)
09:53:09 <mmorrow> (me i think)
09:53:18 <Saizan_> mmorrow :)
09:53:57 <Saizan_> ski: that was a bit too much code for a single line, i think
09:55:01 <mmorrow> ski: what paper are you referring to?
09:55:25 <mmorrow> found it
10:05:13 <mmorrow> shivers papers are always good
10:14:03 * ski pasted "Multi-return Function Call example" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13301>
10:14:06 * ski annotated "Multi-return Function Call example" with "using haskell with \"unboxed\" variants" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13301#a13302>
10:14:37 <ski> Saizan_,mmorrow,(c_wraith ?) : there
10:15:34 <ski> (the actual `multi' syntax using in the paper is a bit idiosyncratic, btw ..)
10:16:40 <ski> (btw, for some reason it always feels like hpaste's 40 character title limit is too small)
10:18:06 <mmorrow> filter p xs = (\nil cons -> xs nil (\x xs -> if p x then cons x (filter p xs) else filter p xs))
10:18:14 <mmorrow> {- using scott-encoded lists -}
10:19:00 <mmorrow> ski: yeah, i've felt that way too actually
10:20:32 <ski> (hm, i suppose i should've selected `SML' as language for the first part .. though, now when i check, i can only find `OCaml')
10:20:47 <Gracenotes> mmorrow: should the last xs parameter be there?
10:20:53 <mmorrow> ski: heh, i've noticed that too.. grr
10:21:19 <mmorrow> Gracenotes: yes, it has an infinite type
10:21:21 <Gracenotes> oh, I see, you're applying the continuation functions to it. never mind
10:23:14 <Gracenotes> I see, that's somewhat a different encoding than plain continuation-style.. the.. uh.. right-something in category theory
10:23:18 <ski> ok, so Scott encoding more or less just imagines no datatype is recursive
10:23:46 <Gracenotes> Kan extension
10:24:35 <mmorrow> F [|case e of Con1{x1_i} -> e1; .. ;ConN{xN_i} -> eN|] ==> e (\{x1_i} -> F[|e1|]) .. (\{xN_i} -> F[|eN|])
10:24:40 <ski> mmorrow : is that `filter' meant to be a direct translation of the usual `filter' .. or of the parsimonious one ?
10:24:46 <Gracenotes> I think the other would be just called Church encoding
10:25:36 <mmorrow> ski: just the usual one, i'm still trying to parse what his multi syntax means/is doing
10:25:51 <ski> i can explain it, if you want
10:26:01 <mmorrow> ok :)
10:26:07 <ski> (but, as said, it is a bit idiosyncratic)
10:26:33 <ski> `multi <expression> <clause> ... <clause>' does two things at a time
10:26:57 <ski> (a) it enables to select from multiple continuations give to the whole expression
10:27:40 <ski> (b) it enables to provide multiple continuations to the `<expression>' sub-expression
10:28:24 <mmorrow> [0,1] ==> (\nil cons -> cons 0 (\nil cons -> cons 1 (\nil cons -> nil)))
10:28:31 <mmorrow> (scott)
10:30:26 <mmorrow> ski: ah, ok i think i see maybe. so if there are N clauses, then you get a collection of N "return_i" functions to use in <expression>?
10:30:28 <ski>   <clause> ::= #n
10:30:28 <ski>              | fn <variable> => <expression>
10:31:10 <ski> the `<clause> ... <clause>' represents the multiple continuations that are sent to `<expression>'
10:31:54 <ski> if a `<clause>' is `#n' (for positive integer `n'), then that selects the `n'th continuation given to the whole expression
10:33:13 <ski> so `multi e #1 #3 #1 #2' will accept three continuations, say `k1',`k2',`k3',`k4', and will then provide `k1',`k3',`k1',`k2' as four continuations to `e'
10:33:21 <mmorrow> ahh, i see. so that's the mechanism for "returning past multiple activations" (or one of the countless ways to say that in someone's favorite lingo)
10:33:34 <mmorrow> oh
10:34:20 <mmorrow> oh, ok i think i grok his notation now
10:34:25 <ski> however, if a `<clause>' is of the form `fn <variable> => <expression>', then we actually construct a new continuation, instead of using an already constructed one (which is known as semi-tail-call)
10:35:19 <mmorrow> "push a new continuation on the stack (which can be short-circuited of course)"
10:35:28 <ski> now, there's some weird details in how to determine what continuations to pass to `<expression>' inside this `<clause>'
10:35:47 <ski> (the idiocy^H^Hsyncracy)
10:35:54 <mmorrow> :)
10:36:06 <blueonyx> hi, i have a program which uses the ghc package to compile code it gets from stdin, now i put something in which imports Database.CouchDB but i throws 'unknown package: CouchDB-0.8.1.3' at me, what does that mean? the same works in ghi :/
10:36:18 <blueonyx> *ghci
10:36:35 <blueonyx> (and i recently installed CouchDB-0.10.0)
10:36:47 <mmorrow> ghc-pkg list <package-name>
10:36:51 <mmorrow> will make sure
10:36:58 <mmorrow> maybe use ghc --make ?
10:37:27 <ski> if that `<expression>' is a value (`<variable>',`<numeric literal>',`fn <variable> => <expression>'), then that value is provided to the *first* of the continuations provided to the whole `multi'-expression
10:38:01 <blueonyx> mmorrow: its in the list as 0.10.0, thats why it cannot find 0.8.* but why doesnt it use 0.10?
10:38:22 <eivuokko> blueonyx, If you are using cabal or similar, you might need to reconfigure to make your build notice new version.
10:38:58 <ski> if that `<expression>' however is not a value (`<expression> <expression>',`multi <expression> <clause> ... <clause>'), then we provide all the "outer" continuations to this `<expression>', should the clause be executed
10:39:05 <ski> mmorrow : that's it, i think
10:39:10 <blueonyx> eivuokko: what to reconfigure? i recompiled already
10:39:14 <mmorrow> ski: heh
10:39:41 <dcoutts> blueonyx: the problem is you've got compiled modules that refer to CouchDB-0.8.1.3, but you've unregistered that package
10:40:06 <dcoutts> blueonyx: the fix is to clean those compiled modules and recompile
10:40:10 <eivuokko> blueonyx, Something refers to CouchDB-0.8.3.  Reconfigure, recompile everything (and really recompile, not just --make)
10:40:51 <blueonyx> ah yea thanks
10:41:50 <ski> so, instead of this nonsense with ".. is provided to the *first* of the continuations ..", i propose one write `fn <variable> => #<positive integer literal> <expression>' instead. (this is already expressible as `fn <variable> => multi <expression> #<positive integer literal>')
10:43:26 <ski> mmorrow : then my notation is just : interpreting an expression that accepts multiple continuations as an expression of unboxed variant type, selecting a continuation is calling an unboxed constructor, providing multiple continuations is `case'ing on the unboxed constructors
10:44:17 <ski> the one thing that maybe doesn't look as nice(?) in my syntax is the `#n' case .. you'll notice i invented new variable names, there
10:44:24 <malosh> Hi. Is there a CPP define that ghc turns on with option -threaded ?
10:44:55 <ski> mmorrow : is the two parts and the correspondence between them clear, now ?
10:45:20 <mmorrow> ski: yeah, i think so
10:45:25 <ski> (or maybe you want to know what the parsimonius filter actually *does* ? :)
10:45:40 <mmorrow> ski: heh, yeah, that too
10:45:48 <mmorrow> ?
10:46:07 <ski> the idea is to share as long a tail as possible in the output with the input
10:46:29 <ski> so instead of returning values in `[a]', we return values in `Either# [a] ()'
10:46:52 <ski> where `Left# xs' means that some elements were dropped, and `xs' is the resulting list
10:47:26 <ski> while `Right# ()' means that no elements were dropped, so the "output" is actually the same as the input
10:47:40 <mmorrow> ah, ok
10:48:14 <ski> i take you can figure out the details from that :)
10:48:32 <mmorrow> hmm, how does that work when, say you ask for the head of:
10:49:25 <mmorrow> err, wait
10:50:11 <mmorrow> (i'm trying to determine the mechanics of this in the case where you'd eventually get a Right# () since the list would be unchanged, but you don't know that until you've traversed the entire list)
10:50:27 <ski> (one could of course have called the cases `Changed# xs' and `Unchanged#' instead, if one can declare new unboxed variant types)
10:50:38 <mmorrow> is that supposed to be possible with zero new allocation?
10:50:43 <ski> well, it's bottom-up
10:51:17 <ski> it checks the predicate on the elements on the way down, recalling each result
10:51:29 <ski> then on the way up, it decides whether ot not to cons
10:51:50 <mmorrow> hmm, i have to work through this in my head
10:52:36 <ski> in base case we return `Right# ()', since the original `filter' returns `[]', which is unchanged from the input
10:53:08 <ski> in the recursive case, first we check (and remember til later) whether to keep the current element or not
10:53:24 <ski> in either case, we continue recurring down
10:53:43 <mmorrow> let xs = [0..9]; ys = filter (/=10) xs in (xs,ys) {- are the spines of xs and ys pointer-equivalent? -}
10:54:47 <ski> if we got `Left# xs' (some elements dropped), and the current element should be kept, then we cons, and tell the caller that elements were dropped : `Left# ans -> Left# (x : ans)'
10:55:13 <ski> mmorrow : yes, `xs' and `ys' are the same list, there
10:55:36 <mmorrow> hmm nice
10:55:44 <ski> (the toplevel `recur' call will return `Right# ()' in that case, so that `filter' returns the input)
10:57:59 <ski> if we got `Right# ()' (no element dropped, recursive output is the recursive input `xs'), and the current element should be kept, then the current output will also be the same as the current input, so we tell just tell the caller that nothing was changed : `Right# g_1 -> Right# g_1'
10:58:28 <blueonyx> is there some kind of nubBy which allows to define which of the both 'equal' elements should be kept?
10:59:20 <ski> (that was a semi-tail-call, so there will actually be no "intermediate stop" here in the execution)
10:59:35 <ski> if we got `Left# xs' (some elements dropped), and the current element should be dropped, then we don't cons, and tell the caller that elements were dropped : `Left# g_2 -> Left# g_2' (this is also a semi-tail-call)
10:59:43 <mmorrow> blueonyx: you could possibly groupBy, then map over the [[a]] and collapse the lists of equiv-modulo-the-(==)-function elements
11:00:53 <blueonyx> mmorrow: thanks
11:01:00 <mmorrow> np
11:01:13 <ski> if we got `Right# ()' (no element dropped, recursive output is the recursive input `xs'), and the current element should be dropped, then the current output is the same as the recursive output, i.e. recursive input, so we tell tell the caller that elements have been dropped (the current one) : `Right# () -> Left# xs'
11:01:36 <mmorrow> ah, hmm
11:02:27 <ski> the toplevel call from `filter' to `recur' invokes `recur' with :
11:02:42 <ski> one continuation which, when some elements were dropped, will give that result as final result : `Left# g_0 -> g_0'
11:02:59 <sshc> is there a standard function that takes a list ([a] ?) and puts every pair in a tuple? (returns [(a, a)])
11:03:10 <ski> and a continuation which, when no element was dropped, will just return the initial input as final result
11:03:12 <sshc> if there's an extra one, it can either be ignored or appended to the last one
11:03:17 <nolrai_P> @hoogle compareOn
11:03:18 <lambdabot> No results found
11:03:21 <nolrai_P> @hoogle compare
11:03:22 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
11:03:22 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
11:03:22 <lambdabot> Text.ParserCombinators.Parsec.Error messageCompare :: Message -> Message -> Ordering
11:03:27 <ski> mmorrow : does that help ?
11:03:38 <nolrai_P> @hoogle compareWith
11:03:40 <lambdabot> No results found
11:03:44 <ski> (maybe you just need to think on it on your own :)
11:04:33 <mmorrow> ski: yes
11:04:37 <mmorrow> ski: and yes
11:04:39 <mmorrow> :)
11:04:40 <ski> > liftM2 (,) `join` [0,1,2]  -- sshc : like this ?
11:04:41 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
11:05:01 <nolrai_P> @hoogle compareBy
11:05:03 <lambdabot> No results found
11:05:37 <nolrai_P> @hoogle Ord b => (a->b) -> a -> a -> Ordering
11:05:39 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:05:39 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
11:05:39 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
11:05:53 <ski> sshc : or maybe you want `[(0,0),(0,1),(0,2),(1,1),(1,2),(2,2)]' or `[(0,1),(0,2),(1,2)]' or `[(0,1),(1,2)]' as result for input `[0,1,2]' ?
11:05:57 <sshc> ski: "foobar" -> [('f', 'o'), ('o', 'b') and so forth]
11:06:02 <ski> (perhaps modulo the order)
11:06:18 <ezyang> Is there any Haskell library that lets me magically shift failures from one type to another?
11:06:18 <ski> @quote aztec
11:06:19 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
11:06:20 <sshc> I can just zip every other one
11:06:28 <ski> > (zip`ap`tail) "foobar"
11:06:29 <mmorrow> ski: that's definitely interesting, but i've got to work through how exactly it can manage to provide a ptr-equivalent (aka same) head of a list before it's actually seen all the items in the list (or am i misunderstanding what you said?)
11:06:31 <lambdabot>   [('f','o'),('o','o'),('o','b'),('b','a'),('a','r')]
11:07:06 <ski> > let as = "foobar" in zip as (tail as)  -- sshc, aka
11:07:07 <mmorrow> (using "head" there to mean "prefix")
11:07:08 <lambdabot>   [('f','o'),('o','o'),('o','b'),('b','a'),('a','r')]
11:07:08 <sshc> ski: how do I remove every other element of a list?
11:07:33 <ezyang> Specifically, I have some code that wants to return a value in the general MonadFailure monad, but it calls Parsec and that wants to instantiate it as Either ParseError
11:07:37 <ski> i would probably define a function `halve' recusively, that does that
11:08:08 <ski> mmorrow : it's not "before" but "after" it has seen all the items in the list
11:08:13 <Jedai> sshc: with a foldr ?
11:08:24 <mmorrow> ski: aha! ok.
11:08:48 <ski> mmorrow : first it traverses down the list to the end (remembering the result of the predicate on each seen element, on some stack, say)
11:09:04 <mmorrow> ski: but then is the head of the resulting list data-dependent then on the traversal of the *entire* list?
11:09:04 <blueonyx> is there some group for "Mississippi" -> ["M","iiii","ssss","pp"]? (since my type is Eq but not Ord, i cant use sort . group)
11:09:07 <Jedai> > foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) [1..10]
11:09:08 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
11:09:35 <ski> mmorrow : then, as it retraces its steps back up again, it knows at each point whether any elements have been dropped from the the current result or not
11:09:44 <sshc> Jedai: thanks, but what is that '~'?
11:09:49 <mmorrow> ski: (err, to clarify, are we using lazy evaluation here?)
11:10:08 <ezyang> i.e. I fail to see how control-monad-failure lets me call multiple external APIs and unify the handling
11:10:14 <Jedai> sshc: It's lazy patterns, allows you to use that function on infinite lists
11:10:15 <ezyang> w/o schlepping the data around myself
11:10:18 <ski> (if no element has been dropped, then the current result is represented by `Right# ()', which implicitly means that the result is the same as the current (sub-)input)
11:10:26 <nolrai_P> Whats the easyist way to check a list for duplicates?
11:10:44 <c_wraith> > nub [1,2,3,2]
11:10:46 <lambdabot>   [1,2,3]
11:11:05 <Jedai> sshc: also called irrefutable patterns
11:11:13 <blueonyx> > length [1,2,3,2] == length $ nub [1,2,3,2]
11:11:15 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:11:15 <lambdabot>         against inferred type ...
11:11:23 <ezyang> Ooh, I might want wrapFailure
11:11:29 <blueonyx> > length [1,2,3,2] == length (nub [1,2,3,2])
11:11:30 <lambdabot>   False
11:11:33 <ski> mmorrow : we might as well not be using lazy evaluation, since `ans' is already computed in the case we cons `x : ans'
11:11:40 <mmorrow> ski: does:  let xs = [0..9]; ys = filter (/=10) xs in head ys `seq` ()   require a traversal of all of `xs'?
11:11:49 <Jedai> sshc: because they just go on assuming the parameter will match them until one of the binding they define is really needed
11:12:04 <ski> (or did you mean to ask whether we used lazy evaluation for the `Left# xs' and `Right# ()' ?)
11:12:40 <Jedai> mmorrow: no
11:12:41 <mmorrow> ski: i just was confused if we're expecting (head . filter p) to be O(1) or O(n)
11:12:41 <junmin> data TestData = A
11:12:48 <Jedai> mmorrow: yes
11:12:57 <c_wraith> nolrai_P: Just be aware that nub is O(n^2), so it shouldn't be used on large input
11:13:28 <mmorrow> Jedai: (qualified by "in the particular modified evaluation model under discussion")
11:13:37 <sshc> > foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) [1..9]
11:13:38 <lambdabot>   ([2,4,6,8],[1,3,5,7,9])
11:13:45 <sshc> > foldr (\x ~(xs,ys) -> (ys, x:xs)) ([],[]) [1..]
11:13:46 <junmin> data TestData = A | A String ; read "A"::TestData; but read "A asdf"::TestData is returning an error, is it about the quote?
11:13:46 <Jedai> mmorrow: Ok, then I have no idea ^^
11:13:47 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
11:13:52 <mmorrow> Jedai: :)
11:14:31 <ski> mmorrow : re "does: ... require a traversal of all of `xs'?" : yes .. that's already the case if we replace `Either#',`Left#',`Right#' with `Either',`Left',`Right'
11:14:53 <mmorrow> ski: aha. ok, now i'm on the same page.
11:16:01 <Jedai> sshc: Without the irrefutable pattern, foldr would need to evaluate on the tail of the list before evaluating on the current element since it would need to verify if it really returns a pair
11:16:02 <ski> the point of using `Either#' would be to avoid the repetative `Right g_1 -> Right g_1' and `Left g_2 -> Left g_2' interpretative overhead
11:16:16 <ski> (cf. `(>>=)' for `Maybe' or `Either e')
11:16:23 <mmorrow> ski: ahh, right.
11:17:30 <ski> i.e., the point is that with `Right# g_1 -> Right# g_1' and `Left# g_2 -> Left# g_2', the corresponding `recur xs' calls in the `case'-scrutinee becomes semi-tail-calls
11:18:38 <ski> i.e., if the branch/continuation in question is selected, then the execution won't actually stop at the branch just to return the same thing again, instead jumping directly up to where something interesting happens
11:18:47 <ski> (cf. throw to exception handlers)
11:20:03 <EnglishGent> hi ski :)
11:21:44 <nolrai_P> > let f list = foldl' ($) list (map delete $ nub list) in f [1,2,3,2,4]
11:21:45 <ski> (.. and, i suppose, with the syntax i chose here, the compiler would have to recognize that in `Left# g_2 -> Left# g_2' both sides are the same, to see that this should be compiled as a semi-tail-call .. i suppose this is simpler with the `#n' clauses for `multi')
11:21:46 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
11:21:49 <ski> hello EnglishGent
11:24:14 <mmorrow> @let collect (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
11:24:16 <lambdabot>  Defined.
11:24:53 <nolrai_P> > let f list = concatmap (filter ((>1) . length)) $ group list in f [1,2,3,2]
11:24:55 <lambdabot>   Not in scope: `concatmap'
11:25:05 <mmorrow> @let histo = collect (+) id (const 1)
11:25:07 <lambdabot>  Defined.
11:25:10 <nolrai_P> @hoogle concatmap
11:25:20 <ski> (mmorrow : so it appears to be a trade-off whether to utilize lazy evaluation or to exploit semi-tail-calls (possibly letting the compiler rewrite from `Either' to `Either#' ?))
11:25:33 <mmorrow> > histo [0,1,2,0,2,1,9,8,9]
11:25:33 <lambdabot>   fromList [(0,2),(1,2),(2,2),(8,1),(9,2)]
11:25:34 <mmorrow> > M.keys (histo [0,1,2,0,2,1,9,8,9])
11:25:34 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
11:25:34 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
11:25:34 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
11:25:34 <lambdabot>   [0,1,2,8,9]
11:25:49 <nolrai_P> > let f list = concatMap (filter ((>1) . length)) $ group list in f [1,2,3,2]
11:25:51 <lambdabot>   No instance for (GHC.Num.Num [a])
11:25:51 <lambdabot>    arising from the literal `1' at <inter...
11:26:23 <nolrai_P> :t ((>1) . length)
11:26:25 <lambdabot> forall a. [a] -> Bool
11:26:48 <nolrai_P> :t (filter ((>1) . length))
11:26:50 <lambdabot> forall a. [[a]] -> [[a]]
11:27:06 <nolrai_P> :t concatMap (filter ((>1) . length))
11:27:08 <lambdabot> forall a. [[[a]]] -> [[a]]
11:27:52 <nolrai_P> :t (concat . (filter ((>1) . length)))
11:27:53 <mmorrow> ski: hmm, i think the/a tradeoff would be to sacrifice O(1) space but get O(1) (head . filter p) with lazy eval (w/ the caveat that there's the possibility of fusing this filter traversal with some consumer by some means)
11:27:54 <lambdabot> forall a. [[a]] -> [a]
11:27:57 <Jedai> > let f = concat . filter ((>1) . length) . group in f [1,2,3,2]
11:27:58 <lambdabot>   []
11:28:05 <nolrai_P> > let f list = concat . (filter ((>1) . length)) $ group list in f [1,2,3,2]
11:28:07 <lambdabot>   []
11:28:39 <nolrai_P> > let f list = concat . (filter ((>1) . length)) . group $ sort list in f [1,2,3,2]
11:28:41 <lambdabot>   [2,2]
11:28:51 <mmorrow> versus getting O(1) space by "deforesting in-place" (or something), but needing O(n) time to access the head of the result
11:29:27 <ski> right
11:29:54 <Jedai> nolrai_P: If you just want to detect duplicates you could do "any ((>1) . length) . group . sort"
11:29:59 <mmorrow> ski: i think Either# (Foo#) would definitely give you something you don't have currently in the cases where it's applicable
11:30:16 <mmorrow> "applicable" := "in the cases where it does just that"
11:30:16 <ski> `Either# (Foo#)' ?
11:30:24 * mmorrow likes circular definiteions
11:30:42 <ski> i'm not sure what you mean
11:30:57 <mmorrow> ski: ah, just meant "(Foo#)" to mean this concept extended to arbitrary datatypes
11:31:11 <mmorrow> bad choice of notation..
11:31:12 <sm> would anyone know a good way to get nice printed/paper-efficient/previewable hard copy of all haskell source in a project, on a mac ?
11:31:28 <mmorrow> ski: rephrasing that whole last sentence to be clear
11:31:30 <sm> I just spent 20 minutes with emacs getting nowehere
11:31:40 <ski> ok (i called that "(heavyweight) unboxed variant (algebraic ?) type")
11:32:12 <ski> (or maybe "counboxed" would be more proper than "unboxed" .. i'm not sure)
11:32:25 <yitz> circular definitions are defined as what mmorrow likes
11:32:26 <lambdabot> yitz: You have 1 new message. '/msg lambdabot @messages' to read it.
11:32:29 <mmorrow> ski: i think Either# (and this concept in general) would definitely give you something you don't have given ghc's current eval model, and there are cases where it would definitely be a win
11:33:00 <EnglishGent> circular definitions like mmorrow
11:33:01 <EnglishGent> :)
11:33:02 <mmorrow> </rephrasin>
11:33:03 <mmorrow> g
11:33:34 <ski> well, you could probably get similar complexies (maybe deallocating some things earlier), using explicit CPS
11:33:50 <mmorrow> ski: yeah
11:33:53 <ski>   recur :: forall o. [a] -> ([a] -> o) -> (() -> o) -> o
11:34:38 <ski> but possibly, since the continuations are non-first-class (so you can't kepp them around (even by mistake)), one can have more efficient implementation
11:34:53 <ski> (i'm not sure whether that would affect the complexities, though)
11:35:34 <mmorrow> ski: right, it seems like he's going for the one-shot-continuations-that-still-retain-stack-allocatability-without-the-possibility-of-incurring-O(n)-copying-cost-in-the-worst-case thing
11:36:00 <ski> (also, i think, transforming into CPS is a global transformation, which might not be possible or realistic, if you don't control the code of libraries that would need to be CPS-transformed)
11:36:04 <mmorrow> 20-word-hyphenated-supar-words ftw!
11:36:11 <c_wraith> this isn't german!
11:36:29 <mmorrow> ski: yeah, i agree
11:36:30 <ddarius> Germans wouldn't use hyphens.
11:36:33 <mmorrow> c_wraith: heh
11:36:36 <ski> mmorrow : right. the continuations are still linear, not intuitionistic
11:36:45 <c_wraith> ddarius: true
11:36:48 <ddarius> @google Linear Continuation Passing Style
11:36:50 <lambdabot> http://research.microsoft.com/apps/pubs/?id=64173
11:36:50 <lambdabot> Title: Linear and Affine Typing of Continuation-Passing Style - Microsoft Research
11:36:51 <Niccus> it's going to get an error compiling on O(n)
11:36:57 <ski> ddarius :)
11:37:09 <ddarius> That wasn't the paper I was expecting.
11:37:10 <mmorrow> oneshotcontinuationsthatstillretainstackallocatabilitywithoutthepossibilityofincurringO(n)copyingcostintheworstcas
11:37:22 * mmorrow germantranslates
11:37:47 * ski tries to recall the title .. or the author
11:38:06 <yitz> mmorrow: must start with a capital letter
11:38:10 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5168#a5168
11:38:10 <FliPPeh> My head
11:38:12 <FliPPeh> It hurts!
11:38:13 <mmorrow> doh!
11:38:23 <FliPPeh> Rate my function, is this good or bad coding?
11:38:30 <ddarius> @google "Linear Continuation Passing Style"
11:38:31 <FliPPeh> It works, that's all I know ;D
11:38:32 <lambdabot> No Result Found.
11:38:38 <Niccus> well, it's coding for one
11:39:31 <ezyang> gah, I have two typecheck errors left, and I get pin down their location
11:39:38 <ddarius> @google "Linear Continuations"
11:39:45 <lambdabot> http://portal.acm.org/citation.cfm?id=143174
11:39:45 <lambdabot> Title: Linear continuations
11:39:51 <yitz> FliPPeh: use do notation
11:39:56 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13310#a13310
11:40:05 <FliPPeh> yitz: It would one get rid of the "get >>="
11:40:09 <ddarius> The thesis above that I accidentally stumbled upon does look like it might be somewhat interesting.
11:40:11 <FliPPeh> Not worth it in my oponion
11:40:27 <ski> Linearly Used Continuations <http://www.cs.bham.ac.uk/~hxt/research/LinUC.ps>
11:40:28 <ski> or
11:40:29 <ski> Linear Continuation-Passing <http://www.cs.bham.ac.uk/~hxt/research/LinCP.pdf>
11:40:29 <ski> ?
11:40:39 <FliPPeh> only*
11:40:45 <ezyang> source: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13311#a13311
11:40:49 <ski> (Hayo Thielecke)
11:41:43 <ddarius> FliPPeh: You can push the if into the tuple and gain some laziness.
11:42:19 <ezyang> They both seem to be problems when I try instantiating MonadFailure
11:42:32 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13312#a13312 <-- this works with GNU cpp but not with cpphs, is it a missing feature or a weird GNU extension?
11:42:35 <yitz> FliPPeh: give the two anonymous functions names in a where clause. use guards for the first, pattern matching for the second.
11:42:58 <Baughn> ,seen dcoutts
11:43:01 <lunabot>  luna: Not in scope: `seen'
11:43:09 <benmachine> preflex: seex dcoutts
11:43:11 <benmachine> eer
11:43:17 <mauke> benmachine: probably a missing feature
11:43:19 <benmachine> preflex: seen dcoutts
11:43:19 <preflex>  dcoutts was last seen on #haskell 1 hour, 3 minutes and 14 seconds ago, saying: blueonyx: the fix is to clean those compiled modules and recompile
11:43:30 <Baughn> We seem to have a profusion of bots. ^^;
11:43:46 <benmachine> mauke: fun. how do I un-missing it :P
11:43:59 * hackagebot upload: fmlist 0.8 - FoldMap lists (SjoerdVisscher)
11:44:10 <FliPPeh> yitz: giving them names, okay, but what do you mean by using guards and patterns?
11:44:21 <benmachine> it's nice being able to find things by just doing darcs.haskell.org/nameofthing
11:44:25 <Baughn> dcoutts_: Anyway, any chance you could tell me how to extract the installation library directory in postInst in cabal/hooks?
11:44:29 * benmachine gets cpphs
11:45:04 <dcoutts> Baughn: yes, you get the InstallDirs from the LocalBuildInfo
11:45:28 <dcoutts> via absoluteInstallDirs
11:45:41 <benmachine> in other news: is it at all sane to write plugins to C applications (i.e. shared objects) with the FFI?
11:47:46 <Baughn> benmachine: Yes, shouldn't be a problem
11:47:51 * ski annotates "." with "any better ?" at <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5168#a5169>
11:47:55 <ski> FliPPeh : ?
11:47:55 <ddarius> FliPPeh: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5168#a5170
11:48:04 <Baughn> benmachine: Just, beware - GHC will blow up if you have /multiple/ RTSs running in one application.
11:48:17 <FliPPeh> Yeah, I just figured that out :)
11:48:19 <FliPPeh> Thanks
11:49:05 <benmachine> heh, okay
11:49:05 <FliPPeh> Still not sure about pattern matching
11:51:07 <Baughn> dcoutts: I could have searched for that for /months/. Thanks!
11:51:22 <ddarius> You can replace the filter with a list comprehension and it's slightly shorter and perhaps more clean looking.
11:51:35 <Baughn> ..it may now take me months to figure out how to use it, but it's a start.
11:51:36 <FliPPeh> Oh, I got it
11:51:59 <FliPPeh> yitz: Like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5171#a5171 ?
11:54:51 * sm finds the answer: enscript
11:55:28 <benmachine> woah, cpphs uses unsafePerformIO for #include
11:56:00 <Baughn> Which is perfectly safe, unless you alter the headers while the program is running
11:56:07 <FliPPeh> Why is it called "unsafePerformIO" and not "performUnsafeIO"? :q
11:56:08 <Baughn> ..and, frankly, would it work if you did that? Either way?
11:56:26 <FliPPeh> Did Yoda write that?
11:56:27 <c_wraith> FliPPeh: because it performs IO and is unsafe
11:56:28 <gwern> FliPPeh: because it could be safe to perform IO
11:56:29 <Baughn> FliPPeh: Because the IO it performs is, in itself, perfectly safe
11:56:36 <yitz> FliPPeh: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5168#a5172
11:56:42 <gwern> the IO isn't unsafe, it's the performing of IO
11:56:45 <FliPPeh> Quad-highlight
11:57:01 <FliPPeh> Thanks for clearing that up :)
11:57:43 <yitz> FliPPeh: oops - need a dot - (== n) . userN
11:57:48 <FliPPeh> Hm
11:57:57 <alatter> hey folks, has anyone got the GHC 6.12 RCs working on Mac OS 10.6 with the zlib package? I keep getting "Codec.Compression.Zlib: incompatible zlib version" errors
11:58:05 <FliPPeh> modify == get >>= (\s -> put s [..] ) ?
11:58:38 <ddarius> @src State modify
11:58:39 <lambdabot> Source not found. Just try something else.
11:58:42 <ddarius> @src modify
11:58:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:58:53 <ddarius> modify f = get >>= put . f
11:59:00 <FliPPeh> Oh nice
11:59:08 <FliPPeh> I knew about modify, but had no idea what id does
11:59:09 <FliPPeh> Thanks :D
11:59:23 <Baughn> dcoutts: ..can't figure out what to feed absoluteInstallDirs for a CopyDest, though.
11:59:35 <benmachine> oh hmm cpphs can't really concatenate string literals like GNU cpp does that wouldn't make sense
11:59:38 <koeien37> if you look at the type sig, you can guess what it does
11:59:38 <koeien37> :t modify
11:59:38 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
12:00:35 <benmachine> if I ghc --make and in the process compile a C file, is it going to use cpphs?
12:00:53 <benmachine> because that seems to be what it's doing but that's not really a good idea
12:01:06 <benmachine> because cpphs isn't ANSIfied
12:01:58 <ezyang> This would be neat: if GHC followed recursive instance declarations and asked you to define the minimal instance to make the whole shebang work.
12:02:39 * roconnor thought Haskell allowed recursive instance declarations
12:02:49 <alatter> ezyang: well, it sort of does. except the failure is at run-time.
12:02:54 <Cale> So I found out how to trigger an X.org memory leak: play Gnome's "AisleRiot" solitaire. It seems that every time you pick up and move a card, more memory is allocated inside the X server and it's never freed, even after you close the game.
12:02:55 <ezyang> roconnor: It does.
12:03:02 * ski annotated "." with "modifying" at <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5168#a5173>
12:03:13 <ski> FliPPeh : ^
12:03:17 <roconnor> ezyang: oh, you mean to have a static check of some kind added
12:03:26 <yitz> Cale: oh noes
12:04:00 <Cale> My X memory usage goes up by about 20MB for every game played.
12:04:11 <yitz> Cale: in that case, there are probably a lot more ways to leak that memory...
12:04:16 <ddarius> Cale: Play better.
12:04:17 <Cale> yitz: yeah
12:04:22 <Cale> ddarius: hehe
12:04:41 <ezyang> roconnor: Yeah, sort of.
12:05:02 <ezyang> Anyway, I think I have a case of "your instance is in another castle"
12:05:48 * ddarius decides to make a top down flying shooter where enemies never get deallocated until they are killed.  You lose when you run out of memory.
12:05:53 <wzp> damn haskell is a hard language i just realised
12:06:13 <wzp> where did you learn haskell ?
12:06:28 <yitz> wzp: it's only hard if you've been previously brainwashed
12:06:28 * CalJohn learnt it from reading the Bird book
12:06:30 <mauke> wzp: on the internets
12:06:33 <ski> (FliPPeh : btw, next time, annotate the original paste ("modify" or "add revision"))
12:06:40 <ezyang> What's the relationship between transformers, mtl and Galois's monad library thingy?
12:06:47 <mercury^> ddarius: there was a doom engine modification that mapped every enemy to a process.
12:06:48 <wzp> yitz: like how ?
12:06:50 <ezyang> wzp: Typeclassopedia and RWH
12:07:12 <ski> wzp : like learning imperative programming ;)
12:07:16 <mercury^> ddarius: best suited for pacifist runs. :P
12:07:32 <ddarius> mercury^: "Ack!  My computer is filled with zombies!"
12:07:35 * mauke has infinite swap
12:07:37 <gwern> ddarius: would they use up memory even if they fly past and are no longer reachable in any way?
12:07:38 <wzp> ski: ok i'll better leave :-'
12:07:38 <yitz> wzp: do you already know how to program in a different language?
12:07:53 <ski> wzp : well, one can (usually) unlearn
12:07:53 <ddarius> gwern: Of course.  They aren't killed in that case, are they?
12:08:06 <ski> (i suspect it's what most of us here has done)
12:08:07 <gwern> perhaps the edge of the screen is the grim reaper
12:08:12 <gwern> which is why you must keep flying
12:08:15 <wzp> yitz: sure
12:08:25 <yitz> which one(s)?
12:08:31 <wzp> c and ruby
12:08:42 * ddarius didn't unlearn anything for Haskell.
12:08:45 <shambler> wzp, well I was terrified some time ago by my inability to write recursive stuff, and now it's feels a lot easier, reading SICP atm
12:08:50 <shambler> just don't give up
12:08:51 <shambler> ;)
12:08:52 <medfly> I learnt it on some channel on freenode called #haskell
12:08:59 <yitz> ddarius: the abominable snowman appears just before you run out of memory
12:09:02 <mauke> never gonna give you up
12:09:05 <smiler> Is there a function in the library that flatten a nested list?
12:09:06 <shambler> ya
12:09:08 <shambler> like that
12:09:13 <ddarius> :t concat
12:09:15 <lambdabot> forall a. [[a]] -> [a]
12:09:16 <nolrai_P> @hoogle sort
12:09:18 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
12:09:18 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
12:09:18 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
12:09:20 <smiler> sweet, thanks
12:09:30 <Baughn> smiler: Or, alternately, join
12:09:40 <Baughn> smiler: Which flattens all sorts of other things too
12:09:42 <Gracenotes> concatMap id
12:09:46 <wzp> i'm never gonna give you up, but i though about learning ocaml instead, no monads and shit
12:09:54 <gwern> yitz: that sounds too hard. how do you know when you're about to run out of memory? doesn't the OS lie to you?
12:09:56 <Baughn> Monads are nice. ;_;
12:10:04 <roconnor> > join (Just (Just 4))
12:10:05 <lambdabot>   Just 4
12:10:09 <shambler> you can learn both
12:10:14 <mauke> wzp: how is "no monads" a good thing? no one forces you to use them in haskell
12:10:18 <Baughn> > join (,) 42
12:10:20 <lambdabot>   (42,42)
12:10:22 <wzp> btw i have no idea what they are, i just read comments that they are horrifying creatures
12:10:23 <smiler> concatMap was excatly what I needed
12:10:30 <yitz> gwern: oh well, it was an idea
12:10:31 <roconnor> > join (&&)
12:10:33 <lambdabot>   {True->True;False->False}
12:10:37 <mauke> wzp: monads don't really matter
12:10:42 <mauke> and they're simple
12:10:45 <Baughn> wzp: You see those joins? 'join' is the sole operation a monad adds on top of applicative functors.
12:10:53 <shambler> and waht is matter?
12:10:54 <Baughn> wzp: So, the nature of monad is join. Which is simple.
12:10:57 <yitz> @google monads warm fuzzy
12:11:00 <lambdabot> http://lambda-the-ultimate.org/node/92
12:11:00 <lambdabot> Title: Explaining monads | Lambda the Ultimate
12:11:02 <ski> ddarius : well, but didn't you have to explicitly notice that assumptions and idioms that are common amongst imperating programming languages isn't really valid any longer (in the context of haskell) ?
12:11:13 <yitz> no, there's a wiki page
12:11:15 <ski> (which was roughly what i meant by "unlearn")
12:11:22 <roconnor> Baughn: join is also the sole operation a monad adds to a pointed functor.
12:11:29 * ezyang sighs 
12:11:32 <ddarius> ski: That's true for every language and I still use those assumptions and idioms in other languages and even in Haskell.
12:11:41 <ddarius> Just as I used Haskell idioms in other languages.
12:11:45 <yitz> stop teasing wzp
12:11:55 <monochrom> @quote monochrom learning
12:11:56 <lambdabot> monochrom says: If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
12:12:06 <shambler> hehe
12:12:07 <monochrom> I said that? :)
12:12:18 <shambler> well that's make sense
12:12:21 <yitz> monochrom: algebraic geometry isn't that hard
12:12:24 <mauke> haha
12:12:26 <Baughn> roconnor: I wonder, what would a monad without ap look like?
12:12:30 <roconnor> > runIdentity (join (return (return 7)))
12:12:31 * Baughn looks for examples
12:12:31 <lambdabot>   7
12:12:35 <monochrom> @quote monochrom unlearning
12:12:36 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
12:12:46 <wzp> oh and those curry functions
12:12:47 <ski> yes. the point being that there being more differences between haskell, and most "imperative languages", than amongst the latter
12:12:48 <shambler> wow
12:13:08 <mauke> wzp: you'll have to understand curry, but that also applies to OCaml
12:13:20 <wzp> omg i better hang myself
12:13:26 <mauke> wzp: what's the problem?
12:13:40 <wzp> i thought ocaml would save me
12:13:58 <mauke> save you from learning something new?
12:14:06 <ddarius> wzp: Learn C# instead.  In that they give monads a different name.
12:14:15 <yitz> wzp: it won't take you long to "get" haskell, and it will open your eyes to a whole new way of programming that will help you in other languages too.
12:14:15 <monochrom> curry lamb functions
12:14:35 <yitz> wzp: except for a bit of frustration that those other languages are uglier than you realized
12:14:45 <wzp> mauke: it's like recursiveness, it fuck your brain, that's frustrating
12:15:18 <yitz> wzp: what are you reading?
12:15:21 <Niccus> it's okay, in your programming career, brainfucks are common
12:15:28 * Twey chuckles.
12:15:41 <mauke> you'll just have to get used to how f(x, y) and f(x)(y) are equivalent
12:15:56 <wzp> yitz: quite a few tutorials at the same time, rwh, learyouahaskell and haskell wiki
12:15:57 <nolrai_P> @hoogle map
12:15:59 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
12:15:59 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
12:15:59 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
12:16:00 <ddarius> mauke: But not the same...
12:16:03 <ski> @quote gooey
12:16:05 <lambdabot> Botje says: the faster your brain blows, the faster we can get at the gooey insides!
12:16:09 <wzp> they explain everything differently
12:16:26 <wzp> should i just stick to rwh ?
12:16:33 <Niccus> learnyouahaskell hasn't gotten to monads :(
12:16:36 <yitz> wzp: haskell wiki is just sort of a grab-bag
12:16:56 <wzp> so rwh then ?
12:17:39 <ddarius> Haskell is like karate.  It's just a bunch of basic, basic, basic.
12:17:57 <wzp> and i like ocaml as it has interfaces nicely with c
12:18:01 <osaunders> Why does 9 + 2 + -3 give a parse error?
12:18:09 <osaunders> > 9 + 2 + -3
12:18:10 <ddarius> osaunders: Because it is a parse error.
12:18:11 <lambdabot>   Precedence parsing error
12:18:11 <lambdabot>      cannot mix `GHC.Num.+' [infixl 6] and prefix ...
12:18:12 <wzp> i speak gibberish
12:18:25 <Niccus> it read - as subtraction
12:18:25 <Lemmih> > 2 + (-3)
12:18:27 <osaunders> Why is 9 + 2 + -3 a parse error?
12:18:27 <lambdabot>   -1
12:18:29 <wzp> i like ocaml as it can talk with c nicely
12:18:38 <ddarius> wzp: Many consider the Haskell FFI the nicest FFI they've ever seen.
12:18:40 <eldragon> > +2
12:18:41 <lambdabot>   <no location info>: parse error on input `+'
12:19:56 <wzp> ddarius: ff what ?
12:19:58 <mauke> wzp: ocaml can't talk to C directly
12:20:06 <wzp> mauke: 'nicely'
12:20:08 <roconnor> > 9 + 2 + (-3)
12:20:10 <lambdabot>   8
12:20:11 <mauke> wzp: you have to write bindings in C first and link them into OCaml
12:20:17 <mauke> wzp: Haskell can call C functions directly
12:21:48 <wzp> mauke: any links ? i asked google but didn't get any interesting results
12:22:02 <mauke> @where ffi
12:22:03 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
12:22:06 <mauke> wzp: ^
12:22:47 <mwc> indeed, haskell's FFI is much nicer than Ocamls, I just compared them recently to decide which to use on a project
12:22:58 <mwc> the one thing I miss is that there's no way to throw a Haskell exception from C
12:23:14 <ddarius> Who uses Haskell exceptions?
12:23:17 <yitz> yucky url. i can't wait until we can link to the ffi in the Haskell 2010 Report.
12:23:48 <mwc> ddarius: handling errors in C libraries
12:24:55 <wzp> mauke: o'boy, thanks
12:25:18 <mwc> "Your C library has just shit all over itself. Time to unwind and save what you can because it's no longer safe to continue"
12:25:40 <mwc> which is still better than the C library's default error handler, which is to call abort()
12:26:11 <mauke> which C library are you talking about?
12:26:15 <mwc> MPI
12:26:17 <wzp> but do you guys have any tutorials i could stick to ? there quite a few of 'em on the internets, hard do make a decision, as i don't know much
12:26:28 <medfly> @where lyah
12:26:29 <lambdabot> www.learnyouahaskell.com
12:26:49 <mwc> I must be old to have learned from YAHT
12:26:54 <mauke> @where+ lyah http://www.learnyouahaskell.com/
12:26:55 <lambdabot> Good to know.
12:27:02 <mwc> all I've heard in the last year has been lyah
12:27:09 <ddarius> mwc: YAHT didn't exist when I learned Haskell.
12:27:13 <wzp> that one doesn't explain monads and stuff, that would mean i'd have to switch tutorials later
12:27:20 <medfly> I'm spoiled. I was babysat into Haskell.
12:28:06 <osaunders> I really like the way you can write 1_000_000 in Perl and Ruby to get 1000000.
12:28:14 <osaunders> You can't do that in Haskell though :-(
12:28:37 <mauke> you can sort of hack it in
12:28:42 <flippeh_> Can someone tell me how "modify" works? I give it a function that has one parameter, which will be the state
12:28:43 <mauke> but it's not nice
12:28:49 <flippeh_> But how does modify give that function the state?
12:28:51 <dcoutts> Baughn: since you're installing to the target then it's NoCopyDest, rather than any other temp dir prefix
12:28:51 <wzp> isn't real world haskell good enough ?
12:28:58 <flippeh_> After all, the function is a parameter of modify, not vice versa
12:29:01 <Polarina> wzp: No, not really.
12:29:04 <osaunders> mauke: How?
12:29:19 <mauke> osaunders: by overloading string literals
12:29:38 <mauke> flippeh_: it calls 'get' to get the state
12:29:48 <osaunders> mauke: Yeah that sounds pretty ugly.
12:30:10 <flippeh_> so basically it forces "get >>= f"
12:30:12 <flippeh_> Right?
12:30:22 <mauke> "forces"?
12:30:29 <flippeh_> does
12:30:30 <wzp> Polarina: where should i learn from, then ? any books or something ? something i could stick to and follow without being completely brainfucked
12:30:56 <Baughn> dcoutts: A nice project for someone with more free time than me would be to make hackage haddock pages into wikis
12:30:56 <mauke> <ddarius> modify f = get >>= put . f  <FliPPeh> Oh nice
12:31:01 <Polarina> wzp: http://learnyouahaskell.com/
12:31:01 <Niccus> pretty sure the brainfuck part is a given
12:31:12 <flippeh_> Oh, that was the actual implementation
12:31:19 <flippeh_> I thought it was just how I could imagine it
12:31:23 <mauke> heh
12:31:30 <mauke> no, that's literally what it does
12:31:38 <Polarina> wzp: Real World Haskell is great in the first two chapters, then it's downwards exponentially.
12:31:41 <ddarius> Alternatively, you could use the quasi-quoting extension, but...
12:31:50 <dcoutts> Baughn: better would be to make it an wiki-like editable interface that sends patches back to the author so they can be integrated upstream, rather than having the docs on hackage be a diverging fork
12:31:52 <flippeh_> I'm struggling with giving the function of modify arguments
12:31:55 <flippeh_> It just won't work
12:31:58 <wzp> Polarina: they don't explain monads :( or should i read monads apart ?
12:32:01 <flippeh_> modify (f a1 a2)
12:32:03 <flippeh_> Nah
12:32:13 <mauke> wzp: why are you so hung up on monads? they're no big deal
12:32:20 <Polarina> wzp: Monads are coming real soon.
12:32:27 <Baughn> dcoutts: The wiki would have to maintain its database as a diff to make any sense whatsoever, so that sounds reasonable
12:32:35 <mauke> flippeh_: what's the type of f and a1, a2?
12:32:51 <Baughn> dcoutts: "Hackage improvements" sounds like a good theme for SoC '10. We could probably use some, by now.
12:32:52 <flippeh_> Nothing, just for demonstration
12:32:55 <flippeh_> No actual code
12:32:55 * ddarius thinks the "Gentle Introduction" is still one the best Haskell tutorials out there...
12:33:00 <flippeh_> I want to give the function arguments
12:33:01 <dcoutts> Baughn: I was thinking of it just being darcs patches
12:33:05 <wzp> mauke: because i'd like to stick to a tutorial and learn, and if there's no monads, that means later i'd have to make my own research and interpret my own way
12:33:14 <osaunders> Is it possible to call Ruby/PHP/Python etc. code from Haskell with the FFI?
12:33:26 <mauke> wzp: oh noes
12:33:47 <mauke> flippeh_: if it doesn't take arguments, you can't give it any
12:33:52 <wzp> Polarina: yay :)
12:34:11 <Baughn> dcoutts: Convertible to darcs patches, sure. Those lose context compared to the wiki, though; the wiki at least should keep a note of which definition/docstring the edit applies to, not just the line number.
12:34:22 <flippeh_> What if it DOES take arguments? it already takes the state as argument one, but for every other argument I want to add, it hits me with errors
12:34:28 <yitz> wzp: nothing special about monads, just learn haskell in the usual way, you'll see them little by little as you go along
12:34:54 <mauke> flippeh_: modify (\x -> f x a1 a2)
12:34:58 <flippeh_> Monads aren't that bad, I'm a newbie but have a fairly good view of what they do
12:35:06 <mauke> flippeh_: you can only omit the lambda if x is the last argument
12:35:43 <wzp> yitz: yeah, i guess i'll do that :)
12:35:53 * ezyang thinks monads are really horrible. 
12:35:59 <Baughn> flippeh_: Or you can flip it a lot. Let's see..
12:36:02 <wzp> 'The Haskell-prime committee has announced Haskell 2010: a new revision of the Haskell language standard' does that mean there will be a haskell 10, or ?
12:36:05 <Baughn> @pl \x -> f x a1 a2
12:36:06 <lambdabot> flip (flip f a1) a2
12:36:06 <ezyang> But maybe because he's been following the bouncing errors for a while now
12:36:09 <Niccus> monads will get you at night
12:36:24 <mauke> wzp: no, a Haskell 2010
12:36:27 <Baughn> wzp: There just was
12:36:49 <Baughn> wzp: Practically speaking, that process mainly just codifies what is already implemented in GHC and (hopefully) other compilers. :P
12:37:13 <yitz> wzp: it's just updating the old Haskell 98 report (from 12 years ago) to reflect what Haskell looks like today. well, some of the updates anyway.
12:38:09 <ezyang> OMG IT TYPECHECKS
12:38:11 <mwc> as opposed to C++0x wait, C++1x, which won't be implemented for years after it's written
12:38:14 * ezyang waves victory flag 
12:38:24 <yitz> ezyang: \o/
12:38:27 <wzp> oh okay, i thought there would be some radical new changes
12:38:44 <wzp> as haskell 98 sounds quite old
12:38:53 <mwc> We should replace monadic IO with comonadic IO, just for shits and giggles
12:38:59 <mauke> yes, but they're already implemented as language extensions in GHC
12:39:13 <Baughn> mwc: Even better, commutative IO
12:39:16 <flippeh_> Does that include adding things only enabled by compiler options (XPatternGuards, ...) to the standard?
12:39:23 <mwc> Baughn: haven't read the wiki article on that
12:39:26 <Baughn> mwc: Or commutative, comonadic IO? :3
12:39:35 <byorgey> flippeh_: indeed
12:39:40 <flippeh_> That's nice
12:39:51 <flippeh_> I dislike using such, feels like cheating the language
12:39:53 <Baughn> mwc: I'm not sure there is one. Well, the basic principle is - commutative monad, monad where order of operations doesn't matter.
12:40:06 <Baughn> mwc: It would be 'interesting' to figure out a way to do that for IO
12:40:28 <Niccus> wouldn't it then be monadic monadic IO to force imperative order?
12:40:32 <Niccus> oh god my head hurts
12:41:06 <Baughn> Niccus: The IO executor would have to figure out the order of operations from their dependencies, or something
12:41:22 <Baughn> So, basically just explicitly noted dependencies. Which might be a win because, a lot of time, order /doesn't/ amtter.
12:42:36 <osaunders> Oh wow http://shootout.alioth.debian.org/u64q/shapes.php shows that GHC is faster than Go!
12:42:47 <osaunders> Produces faster code, I should say.
12:42:52 <Baughn> osaunders: That's hardly a surprise
12:43:09 <Baughn> Language speed is, to a large degree, proportional to effort spent on compiler implementation. Go is young.
12:43:43 <wzp> i saw this sdl binding for haskell, is it me or are there no documentation for that ?
12:44:01 <wzp> s/are/is
12:44:09 <Baughn> wzp: There's the documentation on libsdl.org. The binding is shallow enough that haddock documentation should suffice, otherwise.
12:46:24 <wzp> Baughn: oyea, hackage has documentation
12:46:38 <ben> Is it not morally questionable that strict ByteStrings use unsafePerformIO all over the place?
12:46:39 <Baughn> wzp: For everything.
12:47:08 <Baughn> wzp: Also, the newest version of cabal/install builds a nifty documentation index
12:47:16 <mauke> ben: they use it for good, not evil
12:47:19 <mwc> ben: it's a black box that presents a pure interface, but does IO inside
12:47:27 <mwc> personally, I think ST is a better choice for those situations
12:47:44 <ben> mauke: But that is what we all say :<
12:48:18 <ski> (mwc,Baughn : idempotent I/O memoizing could be fun)
12:48:39 <ben> It is not even just unsafePerformIO, it is their own inlinePerformIO which is marked as *very* unsafe :(
12:48:49 <mwc> ski: we could probably write that in Haskell already
12:50:08 <ski> (idempotent in the sense that when debugging, you can go back in time, but when primitive I/O actions are to be performed (again), the memoized result is just fetched, instead of performing observable effects on the world)
12:50:41 <ski> (Mercury has this thing)
12:51:05 <mercury^> =)
12:51:20 <Baughn> ben: unsafePerformIO is not evil. It is a source of great power.
12:51:35 <monochrom> I should become cyanide. I would make a nice pair with mecury. :)
12:51:42 <Niccus> so it's like how guns can't be evil?
12:51:46 <Baughn> ben: Of course, like any decent power tool it can turn in your hand and shred your hands if you're careless. :P
12:51:54 <mauke> guns don't kill people; bullets do
12:52:03 <ben> Must not make gratuitous star wars references
12:52:10 <mercury^> Guns don't kill people. I kill people. With guns.
12:52:10 <Niccus> bullets are painful
12:52:11 <Elly> bullets don't kill people; blood loss and shock does
12:52:15 <monochrom> I use guns to bang people's heads until they understand monads.
12:52:17 <mreh> guns don't kill people, rappers do
12:52:26 <monochrom> perhaps s/bang/bash/
12:52:36 <Baughn> Throwing people out of planes doesn't kill them. Hitting the heartless ground does.
12:53:17 <ben> unsafePerformIO does not crash programs. Relying on the semantics that are no longer guaranteed does...?
12:53:27 <Baughn> No, it wouldn't
12:53:43 <mreh> is there a generic way of filtering a list for elements with a certain constructor?
12:53:48 <Baughn> Losing referential transparency doesn't actually crash GHC programs. It just confuses the programmer.
12:53:53 <monochrom> Programs don't run. People run them on computers.
12:54:06 <mercury^> It's very hard to write a program that uses unsafePerformIO wrong.
12:54:19 <Baughn> mreh: filter (case of Foo -> True; _ -> False)
12:54:19 <mercury^> (If that's not your goal)
12:54:25 <monochrom> Haskell doesn't interpret or compile. ghc does.
12:54:26 <i_am_neuron> Folks, I'm stuck with lazy evaluation (it seems so). I have this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5174#a5174 and when built with cabal and invoked it gives one "Aaa!" as output (should be more). However, in ghci there is a valid number of "Aaa!"s. What I'm doing wrong?
12:54:28 <Baughn> mreh: (Warning: Syntax not actually implemented)
12:54:59 <Baughn> mreh: Actually, as I understand it, it'll probably be: filter (\Foo -> True; _ -> False) or thereabouts
12:55:17 <ski> mercury^ : ?
12:55:32 <mreh> Baughn, I want to parameterize what gets filtered
12:55:35 <mauke> i_am_neuron: maybe ghc realises that 'trace "Aaa!" return' will always evaluate to 'return' and caches the result
12:56:15 <Baughn> mreh: You can't avoid the explicit case, I'm afraid.
12:56:41 <mauke> can this be done with SYB?
12:56:52 <Cale> i_am_neuron: That code looks like a type error to me.
12:56:59 <ski> > [x | Right x <- [Left 0,Right 'a',Right 'b',Left 1,Right 'c',Left 2,Left 3]]
12:57:02 <lambdabot>   "abc"
12:57:05 <Cale> i_am_neuron: Are you sure it's the code that you're actually running?
12:57:08 <mauke> Cale: where?
12:57:10 <Cale> :t Debug.Trace.trace
12:57:12 <lambdabot> forall a. String -> a -> a
12:57:14 <ski> mreh : ^
12:57:19 <Cale> oh, right :)
12:57:21 <Cale> heh
12:57:21 <i_am_neuron> mauke: Hmmm, could be
12:57:27 <i_am_neuron> Cale: yep, sure
12:57:38 <Cale> You're putting the trace on the return itself, rather than on (return dir)
12:57:40 <mreh> ski: can I parameterise the Constructor?
12:57:44 <ski> no
12:57:50 <monochrom> Perhaps the trace is optimized away.
12:58:00 <mreh> > let f = Right in [x | f x <- [Left 0,Right 'a',Right 'b',Left 1,Right 'c',Left 2,Left 3]]
12:58:01 <lambdabot>   <no location info>: Parse error in pattern
12:58:45 <Cale> i_am_neuron: In any case,  trace "Aaa!" return "" is a constant
12:58:52 <mreh> I need to make a new data type because I'm working with discreet data, but I can't choose all the ones I want
12:59:01 <Cale> i_am_neuron: and I'm betting that it's let lifted to the top level and only computed once
12:59:09 <mreh> I don't _need_ to, but it's a good idea
12:59:19 <i_am_neuron> Cale: if I replace it with 'trace "Aaa!" (return "")' the behaviour remains the same
12:59:22 <Cale> i_am_neuron: so it's evaluated once, but executed perhaps many times
12:59:28 <Cale> i_am_neuron: yeah, it would.
12:59:47 <Cale> Evaluation and execution are two separate things.
12:59:56 * ski . o O ( `[x | x@(Foo _ | Bar | Baz _ _)] <- [Foo 0,Foo 1,Quux "frob",Fred,Baz 's' "ss"]]' )
12:59:59 <Cale> Evaluation means turning expressions into values.
13:00:08 <mreh> > (\f = [x | f x <- [Left 0,Right 'a',Right 'b',Left 1,Right 'c',Left 2,Left 3]]) Right
13:00:10 <lambdabot>   <no location info>: parse error on input `='
13:00:13 <Cale> Execution means carrying out the steps described by values of type IO t
13:00:16 <mreh> > (\f -> [x | f x <- [Left 0,Right 'a',Right 'b',Left 1,Right 'c',Left 2,Left 3]]) Right
13:00:17 <lambdabot>   <no location info>: Parse error in pattern
13:00:33 <Cale> Evaluation is pure and deterministic, execution is not.
13:01:06 <Cale> trace co-opts the evaluation mechanism a bit and prints a message when something is *evaluated*
13:01:12 <Cale> which is something normally impossible to do
13:01:41 <ben> Calling the absence of unsafePerformIO 'normally' is a bit optimistic in this day and age
13:01:46 <Baughn> trace s a = unsafePerformIO (putStr s `seq` return a)
13:01:47 <Cale> There's no solid guarantee that any trace won't be optimised away by the compiler, or about how many times the message will be printed in general.
13:02:01 <Baughn> Er. s/`seq`/>>/
13:02:07 <yitz> ben: why?
13:02:33 <Cale> ben: I treat the usage of unsafePerformIO as being something akin to modifying one's compiler. You can do it, but you should always treat it with a certain mesaure of care.
13:02:37 <Cale> measure*
13:02:47 <yitz> ben: i.e. almost never do it
13:02:48 <ben> "#define private public"
13:03:01 <ben> Bytestrings do it and everybody uses bytestrings :I
13:03:11 <Baughn> ben: unsafePerformIO is most often safe in FFI code. Outside of that, think /hard/.
13:03:14 <ski> ben : how about the absense of `unsafePerformIO' on an action which is observationally referentially opaque ?
13:03:15 <i_am_neuron> Cale: I think I got it
13:03:18 <Cale> ben: But you don't have to use unsafePerformIO to use bytestrings.
13:03:19 <yitz> ben: but it's hidden in the library.
13:03:38 <kmc> we've delegated the responsibility to use it safely to the bytestring authors
13:03:40 <Cale> ben: Consider bytestrings a language primitive. They *could* be built into GHC.
13:03:46 <yitz> "almost never use it" in your own code.
13:04:13 <ben> Baughn: Do you mean "in manipulating raw memory to implement an interface that is itself pure"?
13:04:22 <Cale> ben: But instead they're a library, written to use unsafePerformIO to sidestep the evaluation mechanism of normal Haskell code.
13:04:23 <kmc> it would make me happier, though, if there were less powerful primitives that could be used
13:04:40 <Baughn> ben: Well, that'd be the archetypical case.
13:05:14 <yitz> Baughn: or if you *must* globally allocate an outside resource, when you don't have access to main.
13:05:29 <Cale> i_am_neuron: in any case, since your function is already giving an IO action as its result, you can get the behaviour you want by just using putStrLn instead.
13:05:52 <Baughn> yitz: Or just to say 'sha256 = unsafePerformIO $ fromJust $ getDigestByName "sha256"'
13:05:58 <Baughn> yitz: Which is admittedly a bit disturbing.
13:06:10 <yitz> Baughn: indeed
13:06:23 <yitz> Baughn: or ditto for encodings
13:06:28 <Baughn> yitz: I've gotten extremely comfortable with unsafePerformIO the last few months. It'll probably come back to bite me sometime soon. ^^;
13:06:31 <Cale> i_am_neuron: I like to think of values of type (IO t) as being (generalised) algebraic datastructures which explicitly describe the steps to be performed, using higher-order syntax.
13:07:01 <i_am_neuron> Cale: I see. Printing is not that important to me, I was actually debugging this case wit trace: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5174#a5175 When run, it gives "All directories processed successfully" which is incorrect. Can you see why?
13:07:16 <yitz> Baughn: do the getDigestByName in main and pass it through
13:07:20 <yitz> or use Reader
13:07:21 <Cale> i_am_neuron: and then there's an impure program in the Haskell runtime system which sits there gobbling up those datastructures and actually performing the actions, and it pattern matches, which causes the evaluator to run
13:07:32 <Baughn> yitz: I know, I know. ^^;
13:07:59 <Baughn> yitz: Although my actual response has been to rewrite hsopenssl.
13:08:18 <Baughn> yitz: (..to not use openssl. The entire library is dangerously crashy.)
13:08:36 <Cale> i_am_neuron: It's saying that the number of directories in dirs is equal to the number of results which were equal to ""
13:08:43 <Cale> i_am_neuron: Is that really what you want?
13:08:43 <yitz> Baughn: you mean, let them use the unsafePerformIO so we don't need to dirty ourselves?
13:08:56 <yitz> oh
13:09:02 <Baughn> yitz: That too
13:09:07 <Cale> i_am_neuron: Don't you want filter (/= "") ?
13:09:29 <Baughn> yitz: What I need is - AES, RSA and SHA256. All the other stuff just gets in the way.
13:09:31 <Cale> Er...
13:09:50 <yitz> re-inventing openssl and taking security responsibility for its maintenance is quite a job
13:10:03 <i_am_neuron> Cale: in the latest revision of the code dirs is hardcoded to [".", "foo"], which means that processDirs should return [".", ""], and filtered array would be of size 1, not 2
13:10:03 <Cale> i_am_neuron: But that'll never happen, because there'll always be "." and ".."
13:10:19 <i_am_neuron> Cale: Have a look at the dirs function
13:10:20 <yitz> Baughn: oh, you just want an updated crypto library. yeah.
13:10:23 <Cale> i_am_neuron: ah, okay
13:10:31 <i_am_neuron> Cale: those I'm trying to process
13:10:40 <Baughn> yitz: I'm not. I'm implementing a binding to some other guy's stuff; an AES implementation that's compact enough to be stuffed right into the cabal package.
13:10:49 <Cale> Why is processDir written to use IO?
13:11:31 <i_am_neuron> Cale: because it will change the directory content (no changing now, but I'm working on it)
13:11:35 <Baughn> yitz: openssl is /huge/. Too huge for comfort.
13:11:38 <Cale> ah, okay
13:11:52 <yitz> Baughn: yeah.
13:12:05 <Baughn> yitz: Also, openssl seems to be going unmaintained lately. It's been years, and they still haven't written any documentation for its aes functions.
13:12:10 <Cale> i_am_neuron: So I think the problem is that the way in which you're checking that processDir succeeded doesn't really make sense.
13:12:14 <yitz> Baughn: does your AES need to be fast?
13:12:25 <Cale> er
13:12:25 <Baughn> yitz: Yes
13:12:36 <yitz> oh. that's a bit harder.
13:12:47 <i_am_neuron> Cale: Why? At the end I'm expecting to receive list of failed directories
13:12:54 <Baughn> yitz: And before you ask, Brian Gladman's implementation includes hand-optimized assembly
13:13:01 <i_am_neuron> Cale: interspersed with empty strings
13:13:13 <Cale> i_am_neuron: oh!
13:13:20 <Cale> i_am_neuron: I see why things are confusing.
13:13:27 <Cale> i_am_neuron: Why are you applying show to all the strings?
13:13:31 <yitz> Baughn: probably MMX registers and stuff
13:13:34 <Cale> show "."
13:13:35 <Cale> > show "."
13:13:37 <lambdabot>   "\".\""
13:13:40 <Cale> > show ".."
13:13:42 <lambdabot>   "\"..\""
13:14:16 <Cale> show "\""
13:14:18 <mreh> what does "nub" stand for?
13:14:21 <Cale> > show "\""
13:14:21 <lambdabot>   "\"\\\"\""
13:14:29 <Cale> mreh: The English word "nub".
13:14:39 <byorgey> @wn nub
13:14:40 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
13:14:40 <lambdabot> nub
13:14:40 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
13:14:40 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
13:14:40 <lambdabot>      3: the choicest or most essential or most vital part of some
13:14:41 <lambdabot> [5 @more lines]
13:14:46 <mreh> a nub is the end of something
13:14:49 <Baughn> yitz: Hum. Actually, not a single SSE/MMX instruction to be seen.
13:14:55 <byorgey> mreh: see definition #3
13:14:56 <Cale> mreh: The essential part of something.
13:14:58 <i_am_neuron> Cale: I see now!
13:15:01 <i_am_neuron> :t FilePath
13:15:01 <mreh> nub [1,2,3,2,3,1]
13:15:03 <lambdabot> Not in scope: data constructor `FilePath'
13:15:04 <mreh> > nub [1,2,3,2,3,1]
13:15:06 <lambdabot>   [1,2,3]
13:15:06 <trofi> nub is a slowest function
13:15:13 <crash[`]> goooooooooood morning world
13:15:25 <yitz> Baughn: really? that's usually the only reason people go to assembly these days. c compilers have gotten pretty good.
13:15:30 <trofi> > (S.toList . S.fromList) [1,2,3,4,3,2,1]
13:15:32 <i_am_neuron> Cale: type FilePath = String was the answer
13:15:32 <lambdabot>   [1,2,3,4]
13:15:33 <Cale> nub is as fast as it can be given its type
13:15:33 <Baughn> yitz: I'll have to benchmark it later
13:15:49 <Cale> i_am_neuron: yeah
13:15:56 <crash[`]> yitz: true, but even gcc can do some very very good work with SSE
13:16:03 <i_am_neuron> Cale: thanks, I guess I could handle this now
13:16:13 <yitz> Baughn: perhaps it's meant to be security by obscurity :)
13:16:35 <Cale> > nub [1..]
13:16:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:16:38 <Baughn> yitz: In a few years it won't matter, with new CPUs having AES built right into the ISA
13:16:45 <Cale> > (S.toList . S.fromList) [1..]
13:16:49 <lambdabot>   mueval-core: Time limit exceeded
13:17:10 <Cale> > nub [4,3,2,1]
13:17:11 <lambdabot>   [4,3,2,1]
13:17:14 <yitz> Baughn: question is, will you be able to use it without a MS-issued key in your OS.
13:17:18 <Cale> > (S.toList . S.fromList) [4,3,2,1]
13:17:20 <lambdabot>   [1,2,3,4]
13:17:26 <Baughn> yitz: ..yes.
13:17:39 <trofi> > nub [1..]
13:17:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:17:51 <Baughn> yitz: This isn't that TPM abomination, it's just AES.
13:18:27 <Cale> > join replicate =<< [1..]
13:18:29 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
13:18:34 <Cale> > nub (join replicate =<< [1..])
13:18:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:18:58 <sshc> how do I create a random string?
13:19:22 <Lemmih> sshc: Use mine: randomString = "42"
13:19:32 <yitz> haha
13:19:53 <Baughn> sshc: replicateM stringLength randomIO
13:20:10 <yitz> > randoms (mkStdGen 42) :: String
13:20:12 <lambdabot>   "\41423\368463\206725\161530\914412\1094711\15230\345119\1035538\358835\890...
13:20:30 <yitz> > randomRs ('!','~') (mkStdGen 42) :: String
13:20:31 <lambdabot>   "2$P9{jk.#V|j_A?V\"(z}!wSykkScx7Or]=M&o7Kl%QGK;1rYZYk/}YRR3\"OW@c<]0EWHg\"x...
13:21:43 <ski> > fst (randomR ('!','~') (mkStdGen 42)) :: String
13:21:45 <lambdabot>   Couldn't match expected type `GHC.Base.String'
13:21:45 <lambdabot>         against inferred typ...
13:22:29 <sshc> is it possible to creat an *alphanumeric* random string?
13:22:56 <ski> > replicateM 10 (State (randomR ('!','~'))) `evalState` mkStdGen 42 :: String
13:22:58 <ski> there
13:22:58 <lambdabot>   "2$P9{jk.#V"
13:23:32 <sshc> ski: thanks :)
13:23:41 <vy> :t tells that "maxBound :: (Bounded a) => a". I interpret this as "maxBound is taking a single argument which is an instance of Bounded typeclass". However, "maxBound (1::Int8)" doesn't work, what's wrong? OTOH, I couldn't understand how "maxBound :: Int8" works.
13:23:42 <lambdabot> parse error on input `,'
13:24:05 <yitz> > map ((['0'..'9']++['A'..'Z']++['a'..'z'])!!) $ randomRs (0,62) (mkStdGen 42)
13:24:07 <lambdabot>   "uCnkHVIQUgg6LBiSok9LHX01hM9cxRhEIEk9UTum1RqLZ7XCMsrJw2SabeGlDS2iz7Mxugouh5...
13:24:40 <Lemmih> vy: try: maxBound :: Int.
13:24:46 <Lemmih> vy: try: maxBound :: Int8.
13:25:23 <mauke> vy: maxBound is a constant; it takes no arguments
13:25:31 <mauke> vy: there is no -> in its type
13:25:34 <Lemmih> Sigh, I should learn to read the entire sentence before typing.
13:25:37 <vy> mauke: Ooops! I just see that.
13:26:00 <yitz> > map ((['0'..'9']++['A'..'Z']++['a'..'z'])!!) $ randomRs (0,61) (mkStdGen 42)
13:26:02 <lambdabot>   "x9vuiNaH01RrAk4p3RBWASAEE4yAlUSLQE4HcUoXS0GUQEnU74EiGYN1Kdi8TyTU98QHalDVH5...
13:26:05 <ski> > let cs = ['0'..'9']++['A'..'Z']++['a'..'z']; n = length cs in replicateM 10 (liftM (cs !!) (State (randomR (0,n-1)))) `evalState` mkStdGen 42
13:26:07 <lambdabot>   "x9vuiNaH01"
13:27:38 <yitz> > any (== 'z') . map ((['0'..'9']++['A'..'Z']++['a'..'z'])!!) $ randomRs (0,61) (mkStdGen 42)
13:27:40 <lambdabot>   True
13:28:08 <ski> > let cs = ['0'..'9']++['A'..'Z']++['a'..'z'] in length cs
13:28:10 <lambdabot>   62
13:28:13 <stoop> :t any
13:28:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:28:25 <stoop> any (== 'z') ['a' .. 'z']
13:28:30 <stoop> > any (== 'z') ['a' .. 'z']
13:28:31 <lambdabot>   True
13:28:32 <ski> > any even [1,3,5,6,7,9]
13:28:34 <lambdabot>   True
13:28:34 <ski> > any even [1,3,5,7,9]
13:28:36 <lambdabot>   False
13:28:55 <MHD> I just realised how awesome this channel is...
13:28:59 <yitz> > all odd [1,3,5,7,9]
13:28:59 <stoop> I see.
13:28:59 <lambdabot>   True
13:29:02 <ski> > all even [1,3,5,6,7,9]
13:29:04 <stoop> Nice.
13:29:04 <lambdabot>   False
13:29:33 <stoop> > and [True ..] -- :-)
13:29:34 <lambdabot>   True
13:29:39 <ski> (MHD : for what reason ? :)
13:29:45 <mauke> > all (\x -> even x && odd x) [1,3,5,6,7,9]
13:29:47 <lambdabot>   False
13:29:51 <mauke> > all (\x -> even x && odd x) []
13:29:53 <lambdabot>   True
13:29:56 <ski> (:
13:30:07 <yitz> MHD: I agree :)
13:30:16 <yitz> great people here
13:30:26 <kyagrd> > [True ..] == [True]
13:30:28 <lambdabot>   True
13:30:44 <sshc> > [False..] == [False, True]
13:30:45 <lambdabot>   <no location info>: parse error on input `]'
13:30:47 * mmorrow reads http://home.in.tum.de/~baueran/thesis/ "Compilation of Functional Programming Languages using GCC - Tail Calls"
13:30:52 <MoALTz> it's [False ..] that does the other item thing
13:30:53 <ski> > and [True,True ..]
13:30:58 <lambdabot>   mueval-core: Time limit exceeded
13:30:59 <sshc> > [False..] == [False]
13:31:00 <lambdabot>   <no location info>: parse error on input `]'
13:31:01 <MoALTz> heh
13:31:08 <yitz> mmorrow: meaning lisp?
13:31:23 <stoop> > or [False ..]
13:31:25 <lambdabot>   True
13:31:46 <MoALTz> > succ False
13:31:47 <lambdabot>   True
13:31:50 <MoALTz> > succ True
13:31:52 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
13:32:01 <stoop> > [False ..] = [False, True]
13:32:01 <lambdabot>   <no location info>: parse error on input `='
13:32:06 <stoop> > [False ..] == [False, True]
13:32:06 <ski> mmorrow : sounds interesting, ty
13:32:06 <lambdabot>   True
13:32:11 <yitz> MoALTz: on bounded types, succ sucks
13:32:25 <mmorrow> yitz: any language where some encoding of it into C would be unduly borked unless it can use the C function call mechanism + TCO
13:32:27 <MHD> Universal computation
13:32:41 <stoop> > and $ repeat True
13:32:46 <lambdabot>   mueval: ExitFailure 1
13:32:46 <MHD> Sequential, Parralell, Declarative
13:32:58 <MHD> Lambdas with Types
13:33:31 <yitz> mmorrow: true of any, for some value of "encoding"
13:34:05 <mmorrow> yitz: right
13:34:36 <mmorrow> yitz: sticking an entire program in a single function is grim..
13:34:52 <crash[`]> mmorrow: dunno how many times i've seen that in C :P
13:35:00 <yitz> mmorrow: that's what they do? ugh.
13:35:06 <mreh> map == [1..3]
13:35:08 <mreh> > map == [1..3]
13:35:10 <lambdabot>   Couldn't match expected type `(a -> b) -> [a] -> [b]'
13:35:10 <lambdabot>         against infer...
13:35:15 <mreh> > map (==) [1..3]
13:35:18 <lambdabot>   [{-3->False;-2->False;-1->False;0->False;1->True;2->False;3->False},{-3->Fa...
13:35:28 <MoALTz> ???
13:35:29 <kyagrd> wow
13:35:36 <Niccus> (==) <$> [1..3] <*> [1..3]
13:35:41 <Niccus> > (==) <$> [1..3] <*> [1..3]
13:35:42 <yitz> mmorrow: luckily, in C it can be just a pointer to the entire program :)
13:35:42 <lambdabot>   [True,False,False,False,True,False,False,False,True]
13:35:52 <mmorrow> crash[`]: if you aren't guaranteed TCO, and your language doesn't map onto the C call/return+one-stack model, you don't have many options
13:36:03 <mmorrow> yitz: heh
13:36:23 <MoALTz> i don't understand the "map (==) [1..3]" results
13:36:42 <MoALTz> seems like it would give a list of 1 argument functions
13:36:43 <Niccus> it results in [(1==),(2==),(3==)]
13:36:46 <mmorrow> crash[`]: (assuming here that we're taking a translation into C as a given)
13:36:47 <mauke> MoALTz: map (==) [1..3] is [(1 ==), (2 ==), (3 ==)]
13:36:58 <Niccus> well maybe (==1),... but hey == is commutative
13:37:01 <MoALTz> but how does that result in the output "[{-3->False;-2->False;-1->False;0->False;1->True;2->False;3->False},{-3->Fa..." ?
13:37:38 <yitz> > (1 ==)
13:37:40 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->True;2->False;3->False}
13:38:02 <MoALTz> oh, so a lambdabot enhancement
13:38:07 <yitz> MoALTz: oh, it looks like some weird Show instance for function types in lambdabot
13:38:08 <mauke> MoALTz: because someone's written a Show instance for functions
13:38:14 <Niccus> > (1++)
13:38:15 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:38:15 <lambdabot>    `Test.SmallCheck.Serial ...
13:38:16 * mauke blames SmallCheck
13:38:18 <kyagrd> somehow defiend instance of Show for functions
13:38:24 <stoop> > (True ==)
13:38:24 <MoALTz> yitz, mauke: ah right
13:38:25 <lambdabot>   {True->True;False->False}
13:38:30 <kyagrd> > id
13:38:31 <lambdabot>   {()->()}
13:38:34 <stoop> > (0.1 ==)
13:38:35 <lambdabot>   -0.375->
13:38:35 <lambdabot>    False
13:38:37 <lambdabot>  -0.75->
13:38:39 <lambdabot>    False
13:38:39 <kyagrd> > id :: Int -> Int
13:38:41 <lambdabot>  -1.5->
13:38:45 <lambdabot>   {-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}
13:38:47 <lambdabot> [4 @more lines]
13:38:51 <kyagrd> > id :: Int -> Int
13:38:53 <lambdabot>   {-3->-3;-2->-2;-1->-1;0->0;1->1;2->2;3->3}
13:39:01 <Niccus> nice extension
13:39:07 <yitz> @vixen are we confusing you?
13:39:08 <lambdabot> i hope I don't confuse you
13:39:12 <mreh> > (map (\a b -> filter (b==a)) [1..3]) >>= [1..3]
13:39:14 <stoop> heh
13:39:14 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
13:39:14 <lambdabot>         against inferred ...
13:39:19 <kyagrd> oh ... Int = {-3,-2,-1,0,1,2,3} :)
13:39:22 <mmorrow> lol, starts out with a Dirty Harry quote
13:39:57 <mmorrow> <clint eastwood>"It all comes down to methods. Everybody wants results, but no one is willing to do what it takes to get them."</clint eastwood>
13:40:03 <mreh> > [1..3] >>= (map (\a b -> filter (b==a)) [1..3])
13:40:08 <kyagrd> > id :: (()->())->(()->())
13:40:08 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
13:40:10 <lambdabot>         against inferred ...
13:40:12 <lambdabot>   {{()->()}->{()->()}}
13:40:17 <mreh> lol
13:40:42 <yitz> mmorrow: are you sure this isn't an OOP paper?
13:40:51 <mmorrow> heh
13:41:09 <mreh> > map (map (\a b -> filter (b==a)) [1..3]) [1..3]
13:41:11 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
13:41:11 <lambdabot>         against inferred ...
13:41:43 <benmachine> okay so I'm using Network.HTTP to get myself a web page and it has a form in it, are there any tools hanging around to help me find and parse and submit the form?
13:41:53 <mmorrow> yitz: the abstract explicitly mentions GHC, and uses it as an example of such a compiler that this might be relevant for
13:42:13 <yitz> > filter (uncurry (==)) $ zip [1..3] [1..3]
13:42:15 <lambdabot>   [(1,1),(2,2),(3,3)]
13:42:35 <mmorrow> yitz: which is what piqued my attention (as well as it apparently goes into detail about what it takes to do TCO in C)
13:42:36 <yitz> mmorrow: GHC uses TCO?
13:42:56 * MHD is away: autoaway [l(on) p(on)]
13:43:31 <mmorrow> yitz: hackery-in-place-of http://darcs.haskell.org/ghc/includes/stg/TailCalls.h
13:43:54 <mmorrow> yitz: (we're talking about just the C backend here)
13:44:06 <yitz> mmorrow: oh in stg, once things get strictified. ok.
13:44:24 <mreh>  map ($ [1,2,1,2,3,3,1,2,3]) (map (\a -> filter (a==)) [1..3])
13:44:26 <kyagrd> Is lambdabot's show instance for functions packaged as a library on hackage?
13:44:27 <mreh> > map ($ [1,2,1,2,3,3,1,2,3]) (map (\a -> filter (a==)) [1..3])
13:44:29 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
13:44:31 <mreh> that was horrible
13:44:32 <mmorrow> and then there's the evil mangler, but that's more so code and data can get laid out next to one another
13:45:32 <mreh> > (\c l -> map ($ l) (map (\a -> filter (a==)) c) [1..3] [1,2,1,2,3,3,1,2,3]
13:45:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:45:43 <mmorrow> yitz: what i really have in mind though is working out a reasonable compilation encoding of compiled haskell into C
13:45:57 <yitz> mmorrow: cf. jhc
13:46:08 <mreh> > (\c l -> map ($ l) (map (\a -> filter (a==)) c)) [1..3] [1,2,1,2,3,3,1,2,3]
13:46:09 <mmorrow> yitz: and bonus points if the resulting code is useable directly from hand-written C
13:46:10 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
13:46:12 <mmorrow> yitz: right
13:46:16 <MHD> what exactly is the point of seq?
13:47:26 <yitz> MHD: laziness is usually good, but sometimes "thunks" of unevaluated things can pile up and exhaust memory
13:47:46 <mreh> MHD, look up foldl
13:47:53 <mreh> foldl'
13:47:57 <poe> > group . sort $ [1,2,1,2,3,3,1,2,3]
13:47:59 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
13:48:07 <ski> @type let map2 :: (Functor f,Functor g) => (forall x. f x -> g x) -> (a -> b) -> (f a -> g b); map2 fg ab = fg . fmap ab in map2
13:48:09 <lambdabot> forall (f :: * -> *) (g :: * -> *) a b. (Functor g, Functor f) => (forall x. f x -> g x) -> (a -> b) -> f a -> g b
13:48:11 <ski> @let map2 :: (Functor f,Functor g) => (forall x. f x -> g x) -> (a -> b) -> (f a -> g b); map2 fg ab = fg . fmap ab
13:48:12 <lambdabot>   TypeOperators is not enabled
13:48:12 <mreh> poe: :D
13:48:15 <ski> ?
13:48:15 <yitz> > foldl (+) [1..1000000]
13:48:17 <lambdabot>   No instance for (GHC.Num.Num [t])
13:48:17 <lambdabot>    arising from a use of `GHC.Num.+' at <...
13:48:25 <yitz> > foldl (+) 0 [1..1000000]
13:48:27 <lambdabot>   * Exception: stack overflow
13:48:32 <yitz> > foldl' (+) 0 [1..1000000]
13:48:34 <lambdabot>   500000500000
13:48:41 * FunctorSalad can't find the type operator there
13:48:43 <mreh> foldl1 (+) [1..1000000]
13:48:49 <mreh> > foldl1 (+) [1..1000000]
13:48:51 <lambdabot>   * Exception: stack overflow
13:49:01 <poe> mreh not *exactly* the same thing, and slower probably :)
13:49:31 <mreh> poe: yah, i'm trying to classify k-classes with k perceptrons
13:50:03 <mreh> splitting the data into k groups, one for each perceptron to train on
13:50:25 <BMeph> Why is there such a semingly common "confusion" between "what a Monad is" and "how does the mechanism for implementing a Monad work"? :\
13:50:32 <yitz> MHD: btw that foldl stack overflow goes away in compiled code with ghc's -O2 flag, but not every case gets solved that way.
13:50:35 <BMeph> Er, *seemingly
13:50:51 <osaunders> Why are True and False capitalized but null isn't?
13:51:04 <Twey> osaunders: Because True and False are data constructors, but null is a function
13:51:12 <mwc> osaunders: capitalization differentiates data constructors from mere values
13:51:12 <Twey> null = (== [])
13:51:13 <gwern> :t null
13:51:15 <lambdabot> forall a. [a] -> Bool
13:51:20 <Twey> data Bool = True | False
13:51:34 <yitz> @src null
13:51:34 <osaunders> OK.
13:51:34 <lambdabot> null []     = True
13:51:34 <lambdabot> null (_:_)  = False
13:51:45 <yitz> @src True
13:51:46 <lambdabot> Source not found. Do you think like you type?
13:51:58 <mauke> @src Bool
13:51:59 <lambdabot> data Bool = False | True deriving (Eq, Ord)
13:52:03 <mwc> Type constructors (Bool) and data constructors (True, False) are always capitalized, values aren't. makes haskell parseable
13:52:20 <mauke> constants are capitalized, variables aren't
13:52:40 <osaunders> > let true = True
13:52:42 <lambdabot>   not an expression: `let true = True'
13:52:45 <ski> , src ''Bool
13:52:48 <lunabot>  data Bool = False | True
13:52:48 <BMeph> osaunders: I think that's actually a good question, which should be found in more Haskell tutorials in the future (and I'm not making a joke). :)
13:52:49 <ski> , src 'True
13:52:51 <lunabot>  data Bool = ... | True | ...
13:52:51 <lunabot>  infixl 9
13:52:53 <Twey> > let true = True in true
13:52:54 <lambdabot>   True
13:52:56 <yitz> mauke: that's a little confusing, because Haskell's variables aren't.
13:53:04 <ski> (`infixl 9' ?)
13:53:08 <Niccus> > let 2 + 2 = 5
13:53:09 <lambdabot>   not an expression: `let 2 + 2 = 5'
13:53:11 <mauke> yitz: I don't care!
13:53:17 <Niccus> > let 2 + 2 = 5 in 2 + 2
13:53:19 <lambdabot>   5
13:53:23 <Twey> yitz: They're mathematical ‘variables’
13:53:26 <ski> FunctorSalad : me neither ..
13:53:29 <monochrom> "variable" as in logic, not physics.
13:53:32 <yitz> ok, ok.
13:53:34 <Twey> *nod*
13:53:48 <osaunders> I guess if someone did true = True, that would be bad, but why exactly?
13:53:49 <monochrom> You could call them bindees.
13:54:06 <osaunders> BMeph: Thanks :-)
13:54:10 <yitz> osaunders: not bad, just unlikely to be useful.
13:55:01 <yitz> monochrom: bindables?
13:55:08 <osaunders> yitz: Fair enough.
13:55:09 <BMeph> Wasn't that something in Andrej Brauer's blog, that whole "variables vs. definitions" thing? Specifically, references that are mutable, vs. ones that aren't? :)
13:55:22 <monochrom> public class Bindee implements Bindable { ...
13:55:49 <Twey> osaunders: Not bad, just pointless
13:55:59 <yitz> monochrom: throws Bound
13:56:12 <Twey> (and not in a good way :þ)
13:56:20 <mreh> > (\c l -> map ($ l) (map (\a -> filter ((a==) `on` snd)) c)) [1..3] (zip [0..] [1,2,1,2,3,3,1,2,3])
13:56:22 <lambdabot>   Couldn't match expected type `a -> c'
13:56:22 <lambdabot>         against inferred type `GHC.Bo...
13:56:52 <mreh> @hoogle on
13:56:53 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:56:54 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
13:56:54 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
13:57:06 <ski> @src otherwise
13:57:07 <lambdabot> otherwise = True
13:57:09 <ski> Twey : ^:)
13:57:17 <BMeph> Dang it, Andrej *Bauer.
13:58:00 <osaunders> So there no null value or Null type in Haskell?
13:58:04 <mreh> @src on
13:58:05 <lambdabot> (*) `on` f = \x y -> f x * f y
13:58:05 <Twey> @let itimes n = foldr (.) id . replicate n
13:58:07 <lambdabot>  Defined.
13:58:09 <stoop> > ()
13:58:09 <FunctorSalad> BMeph: hmm, both vars and defs are immutable in haskell or logic
13:58:10 <lambdabot>   ()
13:58:14 * Twey wants one of those built-in :<
13:58:17 <BMeph> I personally see no essential difference between "true = True" and "otherwise = True" outside of how they are used. :)
13:58:17 <mauke> @src Maybe
13:58:19 <lambdabot> data Maybe a = Nothing | Just a
13:58:29 <Twey> BMeph: Compiler magic.  ☺
13:58:29 <mreh> :t (*)
13:58:31 <lambdabot> forall a. (Num a) => a -> a -> a
13:59:38 <MHD> How do you conveniently type a the monad of a do construct?
13:59:56 <mauke> parse error
14:00:06 <BMeph> FunctorSalad: I think the point is that he (Andrej) is giving his own definition for "variables" which would only be met in Haskell with [ST,IO]Refs.
14:00:11 <FunctorSalad> MHD: you can annotate assignment statements in a do block
14:00:40 <MHD> FunctorSalad: How? x <- Just 1?
14:00:58 <FunctorSalad> x <- Just 1 :: Maybe Int
14:01:06 <FunctorSalad> forces the block to be in the Maybe monad
14:01:47 <ski> Twey : seconded
14:01:50 <BMeph> Just FYI, the blog in question I meant is: http://math.andrej.com/2009/04/11/on-programming-language-design/
14:03:56 <BMeph> :t liftM2 ($)
14:03:58 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
14:04:17 <Twey> ski: That, or (+) and (-) defined in terms of succ/pred
14:04:29 <Twey> (or possibly equivalents)
14:07:20 <mreh> dont you use `on` to filter using another function?
14:07:31 <integral> @src on
14:07:31 <lambdabot> (*) `on` f = \x y -> f x * f y
14:07:44 <mreh> is * a parameter?
14:07:51 <integral> yes
14:07:58 <mreh> is it infix?
14:08:02 <integral> yep
14:08:15 <mreh> this is just an arbitary text file definition of `on` isnt it
14:08:19 <MHD> how is "return tt" not an expression?
14:08:32 <integral> > sortBy (compare `on` snd) [(1,4), (2,3), (4,2), (5,1)]
14:08:33 <lambdabot>   [(5,1),(4,2),(2,3),(1,4)]
14:08:40 <mwc> MHD: check your whitespace
14:09:17 <mreh>  > filter ((<3) `on` snd) [(1,4), (2,3), (4,2), (5,1)]
14:09:24 <BMeph> :T returnit
14:09:29 <mreh> > filter ((<3) `on` snd) [(1,4), (2,3), (4,2), (5,1)]
14:09:30 <BMeph> :T return it
14:09:31 <lambdabot>   Couldn't match expected type `b -> c'
14:09:31 <lambdabot>         against inferred type `GHC.Bo...
14:09:31 <MHD> mwc: It would really bug me if that was it, I'm a python programmer
14:09:32 <Twey> mreh: ‘on’ is for binary functions
14:09:41 <osaunders> BMeph: Thanks for that link.
14:09:41 <BMeph> :t return it
14:09:43 <lambdabot> Not in scope: `it'
14:09:55 <integral> mreh: you want . there not `on`
14:10:03 <integral> > filter ((<3) . snd) [(1,4), (2,3), (4,2), (5,1)]
14:10:05 <lambdabot>   [(4,2),(5,1)]
14:10:38 <BMeph> osaunders: My pleasure. I think the author should hang out here, for our mutual benefit, but I suspect that he'd rather be productive at whatever job he has... ;)
14:10:44 <ski> MHD : you're not mixing tabs and spaces for indentation, right ?
14:11:10 <yitz> ski: of course not, MHD is a python programmer
14:11:50 <MHD> ski: There is no suck things as tab characters, only indentation guides every four spaces!
14:11:52 * ski isn't sure to what extent, if any, python allows mixing tabs and spaces for indentation
14:11:55 <MHD> such*
14:12:16 <yitz> ski: in recent versions it's always a syntax error
14:12:20 <BMeph> ...unless they're "every eight spaces" instead. ;)
14:12:24 <ski> ok, ic
14:12:26 <yitz> should be in haskell too imho
14:12:44 <smiler> MHD: ascii value 9?
14:13:05 <MHD> Bmeph: Eight spaces is a waste of perfectly fine whitespace characters, imagine how many function apllications that is...
14:13:07 <kmc> it should just be a syntax error to use tabs
14:13:29 <MHD> Bmeph: IMHO at least
14:13:38 <ski> > map (take 5) $ iterateSR (State $ \g -> let (g0,g1) = split g in (randoms g0,g1)) `runReader` mkStdGen 42 :: [[Bool]]
14:13:39 <smiler> Tab vs spaces wal is almost as fun as editor wars *g*
14:13:40 <lambdabot>   [[True,False,False,True,True],[False,True,True,False,False],[False,True,Tru...
14:13:40 <yitz> kmc: i agree. or at least there should be a pragma to enforce that.
14:13:52 <kmc> or tabs should nondeterministically parse to invisible function applications that will cause bizarre killer type errors
14:14:02 <yitz> smiler: one leads to the other, inevitably.
14:14:03 <MHD> OTT of editor wars, what do you guys use?
14:14:08 <smiler> yitz: true that
14:14:14 <smiler> What I have at hand
14:14:17 <MHD> I use SciTE and Cream/Vim
14:14:26 <FunctorSalad> emacs :D
14:14:26 <ski> ("OTT" meaning "Observational Type Theory" ?)
14:14:30 <smiler> Mostly emacs and vim
14:14:32 <FunctorSalad> ski: hrhr
14:14:39 <MHD> where OTT = On The Topic
14:14:40 <FunctorSalad> (with viper)
14:14:42 <ski> ah
14:15:12 <ski> (emacs, fwiw)
14:15:21 <tcherkoff> ed is the only editor that doesn't waste a programmer's valuable time.
14:15:41 <yitz> tcherkoff: not true. also teco.
14:15:46 <MHD> "Using Haskell Semantics in Everyday Language or How Typed Lambdas Will Ruin Your Social Skills" - Someone needs to write a book like that
14:15:49 <ski> ex
14:16:15 <smiler> MHD: haha
14:16:30 <jik> ciao kmc
14:16:32 <medfly> hahaha
14:17:12 <BMeph> Notepad++! ;p
14:17:38 <medfly> almost all the programmers I know have procrastination issues :P
14:17:41 <ben> obligatory mention of gobby
14:17:42 <FunctorSalad> preflex: karma Notepad
14:17:42 <preflex>  Notepad: 796
14:17:45 <FunctorSalad> :o
14:17:58 <medfly> preflex, karma Cale
14:17:59 <preflex>  Cale: 17
14:18:01 <medfly> NO!
14:18:06 <jik> buona sera ce qulcuno
14:18:15 <Twey> ‘OTT is ‘Over The Top’ in my lexicon :þ
14:18:19 <dogmaT> cat > Main.hs
14:18:20 <Twey> ‘OTT’**
14:18:23 <Twey> (emacs)
14:18:46 * hackagebot upload: wumpus-core 0.13.1 - Pure Haskell PostScript and SVG generation. (StephenTetley)
14:18:52 <osaunders> Oh wow Maybe is damn clever shit.
14:18:55 <jik> italienich
14:19:02 <BMeph> MHD: Why don't you start with a blog article, and see what develops... ;)
14:19:04 <yitz> preflex, karma C
14:19:05 <preflex>  C: 50874
14:19:05 <nolrai_P> geany for myself.
14:19:13 <aavogt> medfly: sampling bias: you only get to know them when they are procrastinating
14:19:15 <Twey> osaunders: Wait 'til you discover Either!  :þ
14:19:26 <Twey> aavogt: Haha, point
14:19:29 <jik> dutch
14:19:32 <Twey> That must be why nobody's ever seen Oleg
14:19:33 <medfly> that's correct :P
14:19:37 <osaunders> Twey: I'll look forward to that.
14:19:41 <mwc> osaunders: maybe is basically haskell's version of a nullable type. Like a pointer, there's a null value that means it's "empty", but you have to explicitely check for it every time you use it
14:19:47 <jik> french
14:20:02 <MoALTz> > let (a:[]) `tackOn` b = a:b in "hello world" tackOn " again"
14:20:03 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
14:20:04 <lambdabot>         against inferred type ...
14:20:30 <jik> ok ok ok ok ok
14:20:58 <crash[`]> to get to the other side
14:20:59 <jik> ha ha ha ha ha
14:21:06 <Twey> jik: Warékš
14:21:07 <crash[`]> why did the tachyon cross the road?
14:21:21 <jik> no
14:21:29 <MHD> I wan't to write my own text editor some day...
14:21:32 <BMeph> moALTz: I strongly suspect that that function will not do what you think it should.... :)
14:21:42 <jik>  :)
14:21:43 <MoALTz> BMeph: seems that way =/
14:21:47 <yitz> MHD: join the yi project
14:21:59 <MHD> yitz: What can it do?
14:22:10 <MHD> yitz: And what language?
14:22:13 <yitz> MHD: it's an editor being written in Haskell
14:22:24 <Paczesiowa> constrained existential types are implemented as records of a value and all the dictionaries for that type, right?
14:22:34 <MHD> yitz: Ahh. Yeah I remember now
14:22:40 <BMeph> Isn't yi more like an IDE than just and editor? :)
14:22:51 <BMeph> just *an editor
14:22:54 <MHD> yitz: Although I was thinking of making it in an imperative language
14:22:56 <yitz> BMeph: in the same sense that emacs is
14:23:06 <MHD> yitz: Suck as the dreaded C++
14:23:13 <MHD> such*
14:23:19 <yitz> preflex, karma C
14:23:19 <preflex>  C: 50875
14:23:22 <ski> Paczesiowa : in GHC, yes
14:23:31 <BMeph> MHD: No, I think you had it right the first time, heh-heh. ;p
14:23:42 <kmc> MHD, Haskell is an imperative language
14:24:02 <tibbe> dcoutts: I like the proposal regarding separate namespaces for type classes and types. It would be useful in the html lib.
14:24:05 <Paczesiowa> ski: what about types that are in negative (?) position?
14:24:06 <MHD> let "suck" = "such" in allFuture (typedBy MHD)
14:24:09 <ski> Haskell comes with an imperative language
14:24:19 <ski> Paczesiowa : example ?
14:24:25 <MHD> kmc: Haskell is typed lambda calculus
14:24:28 <tez_h> wind
14:24:31 <tez_h> Ooops!
14:24:46 <kmc> MHD, sure, and one of the datatypes you can manipulate with the typed lambda calculus is a sequence of imperative steps
14:24:51 <ski> MHD : monads provide imperative programming
14:24:55 <MHD> kmc: C++ is a turing machine construct
14:25:02 <Paczesiowa> ski: data T = forall a. C a => MkT (a -> Bool)
14:25:02 <kmc> only some monads
14:25:13 <kmc> but syntactically all of them, i guess
14:25:14 <MHD> kmc: Go to wiki and look up "Universal computation"
14:25:15 <mauke> s/monads/IO/
14:25:24 <yitz> preflex, karma C
14:25:24 <preflex>  C: 50876
14:25:38 <MHD> kmc: Lambda calculus and Turing machines can simulate each other
14:25:44 <ski> Paczesiowa : a value of type `T' will still be a pair of a dictionary `C a' for some hidden type `a', and a value of type `a -> Bool'
14:26:16 <kmc> MHD, i'm aware
14:26:22 <kmc> and i don't see the relevance
14:26:22 <ski> Paczesiowa : so the polarity of the occurances of `a' doesn't matter for where and who has the disctionaries
14:26:40 <MHD> kmc: Haskell is just still kinda new with me
14:26:57 <MHD> kmc: I only turned 17 yesterday
14:27:01 <ski> kmc : you don't think of the list monad as imperative programming ? :)
14:27:13 <MHD> kmc: and I have been a hobby programmer for 2 and a half year
14:27:20 <kmc> MHD, congrats on your birthday
14:27:21 <Paczesiowa> ski: that's what I thought, thanks
14:27:22 <ski> (or parser monads .. or continuation monads)
14:27:40 <MHD> kmc: Not really, no. I see Monads as a simulation
14:27:51 <MHD> kmc: And I realluy like pointers...
14:28:13 * MHD is ashamed of his guilty manual memory management pleasures
14:28:14 <Paczesiowa> @src cast
14:28:15 <lambdabot> Source not found. Maybe you made a typo?
14:28:28 <Paczesiowa> @hoogle cast
14:28:29 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
14:28:29 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
14:28:29 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
14:28:29 <kmc> in GHC Haskell nearly every type is implemented by a pointer :)
14:28:38 <MHD> kmc: I know that
14:28:42 <kmc> > cast 'x' :: Maybe Bool
14:28:44 <lambdabot>   Nothing
14:28:45 <kmc> > cast 'x' :: Maybe Char
14:28:47 <lambdabot>   Just 'x'
14:29:19 <MHD> kmc: So is most languages that doesn't implement the standard int8/16/31/64 plus raw floating points
14:29:28 <reltuk> > cast 'x' :: Either String Char
14:29:29 <lambdabot>   Couldn't match expected type `Data.Either.Either
14:29:30 <lambdabot>                           ...
14:29:31 <kmc> not C++
14:29:42 <MHD> kmc: Exacta
14:29:53 <eugenn> @pl incluyeTramoEntre parCiudades = any (esTramoEntre parCiudades)
14:29:54 <lambdabot> incluyeTramoEntre = any . esTramoEntre
14:29:54 <kmc> > 5 :: Word31
14:29:57 <lambdabot>   Not in scope: type constructor or class `Word31'
14:29:57 <MHD> kmc: That's why I like it
14:30:04 <kmc> MHD, C++ is terrible and it will rot your brain
14:30:11 <MHD> kmc: I know
14:30:17 <shambler> ohhh
14:30:22 <MHD> kmc: But It is fun
14:30:26 <shambler> please stop this C++ hate :(
14:30:28 <shambler> please? ;(
14:30:30 <kmc> there are people who make entire careers in learning how to work around deficiencies of C++
14:30:41 <kmc> and it's quite hard
14:30:41 <MHD> I will now state that C++ isn't bad
14:30:45 <kmc> as hard as programming in haskell
14:30:52 <kmc> but all of the intellectual effort is utterly wasted
14:31:02 <MHD> kmc: Yes, but faster and Object oriented
14:31:23 <eugenn> @pl cuantosLesFaltaTramoEntre parCiudades = length . filter (not . incluyeTramoEntre parCiudades)
14:31:24 <lambdabot> cuantosLesFaltaTramoEntre = (length .) . filter . (not .) . incluyeTramoEntre
14:31:27 <MHD> kmc: I have seen a mathematician who did his work in C
14:31:28 <kmc> MHD, http://yosefk.com/c++fqa/
14:31:31 <shambler> it's easy to write horrible code with it, code which would rape kawai anime girls only if it could, but is it really C++'s fault? ;(
14:31:32 <MHD> Yes?
14:31:39 <kmc> shambler, yes
14:32:56 <MHD> kmc, don't worry. I am a haskell programmer by heart, for I have understood the purpose of the IO monad.
14:33:07 <MHD> and I honour it
14:33:10 <MoALTz> > (2+6) `mod` 6
14:33:12 <lambdabot>   2
14:33:20 <kmc> that's really peripheral to being a haskell programmer
14:33:20 <MoALTz> oops
14:33:30 <FunctorSalad> MHD: not sure kmc hates C as much as C++ ;)
14:33:42 <Twey> MHD: ‘Faster’ is not the general case.  There are some areas in which C++ is faster, and some in which Haskell is faster.  For example, C++ has terrible performance at concurrency.
14:33:44 <FunctorSalad> (re C & math)
14:33:50 <monochrom> I have seen a mathematician who did his work in fortran.
14:33:52 <kmc> languages don't have performance
14:33:54 <MHD> kmc, yeah, yeah, but a C++ programmer would utterly hate it
14:33:57 <kmc> implementations do
14:34:06 <monochrom> I have seen a cs prof who taught cobol.
14:34:12 <kmc> MHD, i'm a C++ programmer by profession and i like the IO monad and hate C++
14:34:13 <Twey> Aye, GHC/<just about any C++ compiler>
14:34:24 * MHD pities kmc
14:34:32 <kmc> thank you
14:34:43 <kmc> stay in school kids
14:34:46 <MHD> It's those damn multinational corporations, they don't see true potential
14:34:48 <kmc> and by "in school" i mean "grad school forever"
14:34:57 <Twey> Ha
14:34:59 <soopos> How can you write this in Haskell: http://paste.pocoo.org/show/153541/ ?
14:35:06 <MHD> I'm past that, so... Too late
14:35:19 <Twey> http://xkcd.com/664/
14:35:35 <MHD> soopos, I'm not sure I understand
14:35:42 <monochrom> what does def f2(x=x) mean?
14:35:53 <MHD> Haskell was actually quite hard to learn...
14:36:03 <MHD> It took me two days
14:36:05 <ben> I suspect the way to write this in haskell is "print 77"
14:36:11 <reltuk> monochrom maybe a default parameter...
14:36:12 <soopos> monochrom: To pass the x in f1 scope to f2
14:36:13 <kmc> monochrom, a default arg
14:36:18 <ben> give or take a few const
14:36:20 <kmc> but it's already in scope in f2
14:36:24 <kmc> python has lexical closures
14:36:48 <MHD> I usually do functional programming where i can in python
14:36:56 <yitz> soopos: print 77
14:37:04 <soopos> kmc: You are right. x=x is unnecessary
14:37:08 <Paczesiowa> two days to learn haskell:)
14:37:30 <CalJohn> MHD: heh, if you think it is possible to do functional programming in Python, my hunch is that you have not learned haskell
14:37:35 <MHD> Paczesiowa: Most of it to figgure out Monads
14:37:35 <Paczesiowa> @where oleg
14:37:36 <crash[`]> Paczesiowa: for what?
14:37:36 <lambdabot> http://okmij.org/ftp/
14:37:42 <soopos> * \x. f1(x) (\x.f2(x))   - correct?
14:37:50 <monochrom> let {f1 = let {x = 77; f2 = print x} in f2 } in f1
14:37:51 <Paczesiowa> MHD: have fun
14:37:57 <crash[`]> CalJohn: I completely disagree.. Functional doesn't necessarily imply purity or anything
14:38:01 <gwern> this is my RealWorld#. There are many like it, but this is mine. My RealWorld# is my best friend. It is my life. I must master it as I master my code...
14:38:11 <MHD> Aaaah too many people talking to me!
14:38:16 <crash[`]> MHD: FOCS
14:38:18 <CalJohn> crash[`]: no, i don't think so either.  i think it's pretty hard without TCo, though
14:38:18 <crash[`]> GMSDg
14:38:19 <crash[`]> Focus
14:38:32 <MHD> Paczesiowa: Monads in general
14:38:37 <MHD> Mostly IO
14:38:52 * BMeph cheers gwern on!
14:38:58 <dibblego> then you haven't learned Haskell at all
14:39:00 <reltuk> f1 = let x = 77 in \arg -> case arg of Nothing -> putStrLn x; Just otherX -> putStrLn otherX
14:39:03 <MHD> But those two days compare to 4 hours leanring the monstrosity that is Java
14:39:18 <kmc> CalJohn, i think it is possible to do functional programming in Python
14:39:24 <kmc> and i know both Python and Haskell quite well
14:39:29 <BMeph> ...without me, my RealWorld# is useless. Without my RealWorld#, I am useless.
14:39:43 <gwern> BMeph: it works well, doesn't it
14:39:45 <kmc> i agree with crash[`]
14:39:48 <soopos> Is there any irc-channel for lambda calculus?
14:39:53 <kmc> #math perhaps
14:39:54 <lunabot>  luna: Not in scope: `math'
14:39:55 <BMeph> gwern: Yes, yes it does. :)
14:40:00 <kmc> this is not a bad place to ask tbh
14:40:02 <kmc> or haskell-blah
14:40:06 <CalJohn> kmc: i have discussed this with you before, and you only have this position because you define functional programming very loosely
14:40:12 <MHD> dibblego: Then shoot, guess what I donw' understand
14:40:12 <osaunders> What's haskell-blah?
14:40:15 <kmc> another channel
14:40:18 <medfly> offtopic channel
14:40:19 <kmc> off-topic version of this one
14:40:23 <osaunders> OK.
14:40:53 <ski> reltuk : `f1 = let x = 77 in maybe (putStrLn x) putStrLn' ?
14:41:02 <kmc> CalJohn, okay.  what essential functional feature does Python lack?
14:41:07 <kmc> i don't think we've discussed that before
14:41:16 <BMeph> CalJohn: Didn't you mean to say, "if you think it is possible to do functional programming in Python, my hunch is that you have not learned Python"? ;)
14:41:35 <MHD> I am kind of not amused
14:41:38 <gwern> well, it has basic lambdas, maps, and folds. from there, it's just building up the library isn't it?
14:41:44 <reltuk> ski: sure!  :-)
14:41:54 <MoALTz> > map (\x -> (x-2):x) [7,13..]
14:41:54 <kmc> lambda is not an essential FP feature
14:41:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:42:02 <MHD> You are indirectly insulting my intelligence
14:42:05 <reltuk> I guess you need to putStrLn . show or whatever...
14:42:09 <CalJohn> BMeph: heh, that is another way of thinking about it
14:42:36 <kmc> every time you call a method in Python, you're invoking a lexical closure generated from a partial function application
14:42:39 <ski> @src print
14:42:40 <lambdabot> print x = putStrLn (show x)
14:42:43 <eugenn> @pl daLoMismo f g x = f x == g x
14:42:44 <lambdabot> daLoMismo = liftM2 (==)
14:42:49 <Niccus> > (\x -> (x-2):[x]) =<< [7,13..]
14:42:50 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
14:43:07 <MoALTz> :t =<<
14:43:09 <lambdabot> parse error on input `=<<'
14:43:13 <MoALTz> :t (=<<)
14:43:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:43:21 <kmc> @src (=<<)
14:43:22 <lambdabot> f =<< x = x >>= f
14:43:25 <kmc> ^^^^ best definition ever
14:43:29 <MoALTz> heh
14:43:50 <medfly> @src (>>=)
14:43:52 <lambdabot> Source not found. You type like i drive.
14:43:53 <MHD> Imma go kill some innocent pedestrians
14:44:10 <kmc> @src Monad
14:44:11 <lambdabot> class  Monad m  where
14:44:11 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:44:11 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:44:11 <lambdabot>     return      :: a -> m a
14:44:11 <lambdabot>     fail        :: String -> m a
14:44:12 <gwern> MHD: no no be an hero
14:44:16 <kmc> haha
14:44:19 <CalJohn> kmc: shall we say; "tail call optimisation"
14:44:22 <MHD> gwern: Guess a game?
14:44:24 <Niccus> I'm more used to =<< just because it works like .
14:44:33 <CalJohn> kmc: there is no way to dialectic your way out of that one :)
14:44:45 <gwern> MHD: I DON'T WANT TO PLAY TICTACTOE OR GLOBAL THERMONUCLEAR WAR, ALREADY!
14:44:55 <Baughn> So I'm designing an AES interface..
14:45:11 <MHD> gwern: I was just talking about [prototype]... relax
14:45:19 <kmc> CalJohn, that's a good one
14:45:24 <eugenn> :t liftM2
14:45:25 <kmc> but see http://code.activestate.com/recipes/474088/
14:45:26 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:45:30 <Baughn> Would you like each encryption mode context to be a different type, or the same? How about the encrypt/decrypt setting? Any desires?
14:45:34 <MHD> gwern: As I said, kill innocent pedestrans
14:45:44 <MHD> Bai gaiz
14:45:52 <eugenn> > liftM2 (+) (-)
14:45:54 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
14:45:54 <lambdabot>    arising from a use of `GHC.Num.+'...
14:46:44 <Baughn> ..hum. Actually.. yay, type families
14:46:54 <Niccus> > liftM2 (+) [1..3] [4..6]
14:46:55 <lambdabot>   [5,6,7,6,7,8,7,8,9]
14:47:01 <andun> can anyone point me to to some resources about basic kinds of optimizations usually done on functional programming languages?
14:47:09 <kmc> CalJohn, would you say that you can do functional programming in the hypothetical language "Python + TCO"?
14:47:22 <kmc> (note I'm not asking whether it's a "functional language")
14:47:23 <gwern> andun: there's the GHC book I guess
14:47:29 <kmc> andun, Secrets of the GHC Inliner
14:47:37 <kmc> @google Secrets of the GHC Inliner
14:47:39 * BMeph plans to go and kill some pedestrian innocents!
14:47:39 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/index.htm
14:47:39 <lambdabot> Title: Simon Peyton Jones: papers
14:47:44 <kmc> @google from lists to streams to nothing at all
14:47:57 <CalJohn> @google lambda the ultimate goto
14:48:00 <Paczesiowa> ski: using undefined is ok as value of that negative existential type, right?
14:48:01 <junmin> @src filter
14:48:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
14:48:02 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
14:48:02 <lambdabot> http://library.readscheme.org/page1.html
14:48:02 <lambdabot> Title: The Original 'Lambda Papers' by Guy Steele and Gerald Sussman
14:48:02 <lambdabot> filter _ []     = []
14:48:03 <lambdabot> filter p (x:xs)
14:48:05 <lambdabot>     | p x       = x : filter p xs
14:48:06 <lambdabot>     | otherwise = filter p xs
14:48:18 <FunctorSalad> BMeph: how do you know they are innocent? you might accidentally hit a guilty pedestrian :o
14:48:27 <CalJohn> @google the universality of fold
14:48:29 <andun> gwern: the ghc book?
14:48:30 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
14:48:30 <lambdabot> Title: A tutorial on the universality and expressiveness of fold
14:48:33 <andun> kmc: thanks
14:48:34 <junmin> @src takeWhile
14:48:34 <lambdabot> takeWhile _ []                 =  []
14:48:35 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
14:48:35 <lambdabot>                    | otherwise =  []
14:48:51 <kmc> andun, also read the GHC manual, esp. its optimization pragmas
14:49:23 <CalJohn> kmc: i would say "yes, pretty much, but it would be nice to have statements in lambdas also"
14:49:33 <kmc> CalJohn, i agree
14:49:44 <kmc> and that's a lexical problem and not anything more fundamental
14:49:47 <BMeph> FunctorSalad: Eh? You must be mistaking me for MHD... ;p
14:49:54 <kmc> because they fucked up when designing the whitespace dependence
14:49:55 <gwern> andun: http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
14:49:55 <soopos> Do you need to compile Haskell code?
14:49:58 <kmc> in a crucial and obvious way
14:50:09 <kmc> soopos, no, there are interpreters, for example Hugs, and GHCi does bytecode-interpretation
14:50:16 <Paczesiowa> @src catchesHandler
14:50:16 <lambdabot> Source not found. Take a stress pill and think things over.
14:50:20 <andun> gwern: nice. thanks <3
14:50:25 <CalJohn> kmc: what was the mistake?
14:50:34 <kmc> soopos, the *usual* way to run Haskell code is to compile the bulk of your program with GHC, and use GHCi interactively to poke at it
14:50:37 <ski> (gwern : <http://en.wikipedia.org/wiki/Nuclear_War_(computer_game)> ?)
14:50:38 <kmc> or to run a completed binra
14:50:42 <kmc> binary*
14:50:48 <FunctorSalad> BMeph: hadn't seen his message, so I assumed yours was spontaneous and that surely you have some good reason to do it
14:51:01 <kmc> CalJohn, they didn't define an equivalent whitespace-insensitive form, that can be intermixed with the other
14:51:10 <gwern> ski: I prefer DEFCON actually
14:51:26 <ski> not seen that
14:51:30 <kmc> the easiest way to do so is to define whitespace dependence as a self-contained transformation to the whitespace-insensitive form
14:51:35 <soopos> kmc: Is it possible to use it like Python? - You can for instance ":!python" in Vim. It would be great to have ":!haskell" in Vim too.
14:51:38 <kmc> nuclear war, on the dance floor
14:51:49 <ski> Paczesiowa : yes, why shouldn't it ?
14:51:49 <BMeph> FunctorSalad: Um, because I believe that being pedestrian invalidates any claims to innocence? ;p
14:51:54 <nolrai_P> :t maybe
14:51:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:51:58 <kmc> soopos, there's a program "runhaskell"
14:51:59 <soopos> kmc: * for visual selection
14:52:02 <CalJohn> soopos: i think that there is a vim mode as well
14:52:12 <kmc> soopos, but the usual way to interactively develop is with GHCi
14:52:23 <kmc> you can use its :r command to reload the file you've edited
14:52:41 <CalJohn> (i think he means having an inferior lisp in his vim)
14:53:05 <sshc> how do I run "setCookie" in an IO monad?
14:54:18 <BMeph> sshc: How do you *not* run "setCookie" in an IO monad? ;)
14:54:38 <gwern> BMeph: unsafely
14:54:42 <Paczesiowa> ski: I'm just still mindblown about Handler type (it has existentialy quantified exception inside) and how it checks if it can handle another non-existential exception. maybe it's been a while, since I've written something that worked right after typechecking and I still didn't know why.
14:54:54 <sshc> BMeph:     No instance for (Network.CGI.Monad.MonadCGI IO)
14:54:54 <sshc>       arising from a use of `setCookie'
14:55:07 <ski> (gwern : is that "Defcon" or "Defcon 5" on WP ?)
14:55:43 <ski> Paczesiowa : of course, if someone forces that `undefined', you get bottom
14:55:47 <ski> `Handler' ?
14:55:58 <Paczesiowa> ski: Control.Exception stuff
14:56:03 <FunctorSalad> Paczesiowa: AIUI, a FooException will be caught by either a `catch' with e=FooException or one with e=SomeException
14:56:10 <MarcWeber> What is mmap about exactly? It is faster than altering file contents by seeking because you can write to memory addresses directly?
14:56:28 <Paczesiowa> FunctorSalad: I know that, I'm only suprised by its implementation
14:56:51 <sshc> setCookie gives me that error
14:56:55 <ski> @kind Control.Exception.Handler
14:56:57 <lambdabot> * -> *
14:57:21 <Paczesiowa> @type Control.Exception.Handler
14:57:23 <lambdabot> forall e a. (GHC.Exception.Exception e) => (e -> IO a) -> Control.Exception.Handler a
14:57:33 <FunctorSalad> data Handler a where
14:57:33 <FunctorSalad>   Handler :: forall a e. (Exception e) => (e -> IO a) -> Handler a
14:57:50 <sshc> why doesn't setCookie work in an IO monad?
14:57:54 <FunctorSalad> Paczesiowa: think I misunderstood you
14:58:22 <FunctorSalad> Paczesiowa: maybe it has something to do with exceptions being Typeable
14:58:49 <sshc> I don't understand why setCookie doesn't work in a do block of an IO monad
14:58:53 <FunctorSalad> so it could just check whether the typereps of the thrown exceptions and the handler's "e" match
14:58:56 <Paczesiowa> FunctorSalad: I was suprised that you can cast things to another type that is not only existential, but you don't have any value of that type (it's only an argument)
14:59:42 <sshc> Googling "No instance for (Network.CGI.Monad.MonadCGI IO)" gives me no results
14:59:57 <FunctorSalad> Paczesiowa: where does casting come in here?
15:00:19 <Paczesiowa> FunctorSalad: catches/catchesHandler
15:00:53 <ski> @type Control.Exception.catches
15:00:56 <lambdabot> forall a. IO a -> [Control.Exception.Handler a] -> IO a
15:00:56 <ski> @type Control.Exception.catchesHandler
15:00:58 <lambdabot> Not in scope: `Control.Exception.catchesHandler'
15:01:03 <sshc> @type setCookie
15:01:05 <lambdabot> Not in scope: `setCookie'
15:01:11 <Paczesiowa> ski: it's not exported
15:01:45 <ski> class `Exception' has `Typable' as superclass
15:02:03 <FunctorSalad> AFAIK `cast' just checks whether the TypeReps are equal, then does unsafeCoerce
15:02:04 <ski> thus it can check if two types in `Exception' are the same type
15:02:04 <seanmcl> I can't seem to get breakpoints to work in ghci.  For instance, :list Prover.proveM returns the code for proveM, but :break Prover.proveM says "No breakpoints found at that location.".  Do you have to do something special to make breakpoints work?
15:02:07 <FunctorSalad> I might be wrong
15:02:47 <ski> (Paczesiowa : and it can do this comparision even on existentially hidden types)
15:03:14 <sshc> why does setCookie stop compiling with the error "No instance for (Network.CGI.Monad.MonadCGI IO)"
15:03:25 <Paczesiowa> :t setCookie
15:03:26 <lambdabot> Not in scope: `setCookie'
15:03:41 <ski> FunctorSalad : for a closed universe, you can define `cast' with GADTs, iirc
15:03:46 <sshc> :import Network.CGI
15:03:53 <sshc> :m Network.CGI
15:03:58 <sshc> :t setCookie
15:04:00 <lambdabot> Not in scope: `setCookie'
15:04:11 <FunctorSalad> ski: makes sense
15:04:29 <sshc> Paczesiowa: setCookie :: (MonadCGI m) => Cookie -> m ()
15:04:50 <Paczesiowa> sshc: :i MonadCGI
15:05:39 <sshc> Paczesiowa: http://pastebin.com/m2b94e7fc
15:07:08 <Paczesiowa> sshc: :i CGIT
15:08:12 <sshc> Paczesiowa: http://pastebin.com/m6bbcf774
15:08:31 <dibblego> are 0/+ and 1/* the only monoids on the integers?
15:08:45 <Paczesiowa> sshc: how do you use that setCookie?
15:08:53 <copumpkin> dibblego: if you restrict it to naturals, there are definitely more
15:08:56 <ben> isn't minBound/max one too?
15:08:57 <copumpkin> probably more on integers too
15:09:13 <copumpkin> benmachine: integers don't have a min or max bound :P
15:09:18 <benmachine> binary xor
15:09:20 <benmachine> hello
15:09:27 <copumpkin> ah, yeah
15:09:28 <ben> Oh :<
15:09:37 <benmachine> in fact most bitwise operations'd work as a monoid
15:09:42 <benmachine> except & not really on integers
15:09:50 <copumpkin> although it sort of relies on certain representations of negativity
15:09:52 <benmachine> so by most I mean, the other two
15:10:03 <benmachine> true
15:10:13 <mauke> instance Monoid Integer where mappend = (.&.); mempty = -1
15:10:18 <benmachine> but you could construct one that worked
15:10:21 <copumpkin> you can also have monoids with gcd and lcm, if you're using naturals only
15:10:43 <nolrai_P> what exactly does "Warning: Pattern match(es) are overlapped" mean? It seems to only happen some of the times I would expect it too.
15:10:45 <sshc> Paczesiowa: setCookie $ Cookie theCookie'sName aRandomString (Just datetime) Nothing Nothing False
15:11:05 <sshc> Paczesiowa: I use that in a do block following "when"
15:11:18 <Paczesiowa> sshc: but where? you should do that somewhere inside another cgi computation
15:11:19 <sshc> Paczesiowa: even if I add return() after it, it fails
15:11:42 <Paczesiowa> sshc: it fails because you do it inside IO computation, you have to use it inside CGIT computation
15:11:56 <copumpkin> :t Positive
15:11:57 <lambdabot> forall a. a -> Positive a
15:12:15 <copumpkin> :t Nonnegative
15:12:17 <lambdabot> Not in scope: data constructor `Nonnegative'
15:12:17 <Paczesiowa> @info Positive
15:12:18 <lambdabot> Positive
15:12:21 <ski>   `data Equal :: * -> * -> * where ReflInt :: Equal Int Int; ReflProd :: Equal a0 a1 -> Equal b0 b1 -> Equal (a0,b0) (a1,b1)', `data TypeRep :: * -> * where RepInt :: TypeRep Int; RepProd :: TypeRep a -> TypeRep b -> TypeRep (a,b)' and `substitute :: Equal a b -> f a -> f b', then `data Dynamic = forall a. MkD (TypeRep a) a' and `equal :: TypeRep a -> TypeRep b -> Maybe (Equal a b)' `coerce :: TypeRep a -> Dynamic -> Maybe a'
15:12:24 <copumpkin> I think it's quickcheck
15:12:26 <Paczesiowa> > Positive (-1)
15:12:28 <lambdabot>   Not in scope: data constructor `Positive'
15:12:28 <ski> (iirc)
15:13:00 <benmachine> @info is not a command
15:13:01 <lambdabot> is not a command
15:13:12 <copumpkin> did c++ people just pull the word "functor" out of their ass, or was there some justification for its use?
15:13:43 <Nafai> copumpkin: You mean you expect theory to be behind C++?
15:14:05 <copumpkin> Nafai: well, wondering if it was a misunderstanding of theory, or literally just chosen because "it sounds cool"
15:14:13 <nolrai_P> How is it used in c++?
15:14:24 <copumpkin> Skeletor is awesome and evil! These are like functions, so let's call them Functors!
15:14:46 <Niccus> it's from category theory
15:14:48 <copumpkin> nolrai_P: an object that wraps a function so you can pass it around, to make up for c++'s obvious shortcomings
15:15:09 <Nafai> nolrai_P: http://en.wikipedia.org/wiki/Function_object#In_C_and_C.2B.2B
15:15:09 <FunctorSalad> copumpkin: clearly they mean a functor with domain a discrete category
15:15:10 <ben> A functor in C++ is any object that responds to the function call operator, (<parameters go here>)
15:15:11 <FunctorSalad> ;)
15:15:16 <copumpkin> lol
15:16:01 <toast-opt> what's a functor in haskell, btw
15:16:04 <nolrai_P> Yeah, maybe an independant derivation of a word for something like a function?
15:16:08 <toast-opt> i took a look, and it wasn't obvious from the docs
15:16:09 <copumpkin> toast-opt: a type constructor
15:16:16 <copumpkin> toast-opt: that satisfies some laws :)
15:16:23 <toast-opt> heh
15:16:31 <copumpkin> Maybe is a functor
15:16:32 <toast-opt> i think that's called a "type class'"
15:16:42 <copumpkin> nope
15:16:45 <Nafai> nolrai_P: Possibly, but honestly, you'd think someone involved with the C++ standardization process would be familiar with category theory
15:16:47 <copumpkin> well, Functor is a typeclass
15:17:06 <toast-opt> yes, i mean the thing you described applies to any typeclass, no?
15:17:32 <copumpkin> toast-opt: sort of
15:17:57 <copumpkin> toast-opt: in another language, Functor might be an interface called Mappable, but you'd need higher kind support in that language
15:18:12 <ben> I think 'functino' is a much neater derivation of function
15:18:18 <nolrai_P> Nafai: So? Its not like the math people trademarked it. and I wouldn't particularly expect that.
15:18:20 <stoop> affinerator
15:18:26 <nolrai_P> A little function?
15:18:41 <copumpkin> toast-opt: it's basically anything that has a meaningful notion of mapping "over its innards". The obvious map laws it must support are that map id = id and map f . map g = map (f . g)
15:18:48 <copumpkin> > fmap (Just 5)
15:18:49 <lambdabot>   Couldn't match expected type `a -> b'
15:18:49 <lambdabot>         against inferred type `Data.M...
15:18:52 <copumpkin> > fmap (+1) (Just 5)
15:18:54 <lambdabot>   Just 6
15:18:54 <copumpkin> (meh)
15:19:11 <toast-opt> copumpkin, so a Functor is like a generalization of a function?
15:19:13 <copumpkin> toast-opt: if you squint at that, it's like map (+1) [1,2,3]
15:19:25 <copumpkin> toast-opt: it's a generalization of something that you can map over, like a list
15:19:52 <copumpkin> > fmap (+1) [1,2,3]
15:19:53 <lambdabot>   [2,3,4]
15:20:00 <toast-opt> oh, wait, i see,
15:20:01 <copumpkin> > fmap (+1) (Just 1)
15:20:02 <lambdabot>   Just 2
15:20:06 <toast-opt> it's something that can be mapped
15:20:09 <copumpkin> > fmap (+1) []
15:20:11 <lambdabot>   []
15:20:12 <copumpkin> > fmap (+1) Nothing
15:20:13 <lambdabot>   Nothing
15:20:15 <copumpkin> yep :)
15:20:29 <Raevel> no ghc in snow leopard? :-(
15:20:30 <copumpkin> there are several other examples
15:20:42 <Niccus> glasgow isn't known for its big cats
15:20:49 <toast-opt> fmap :: (Functor something) => (a -> b) -> Functor a -> Functor b, then?
15:20:53 <copumpkin> it does work in snow leopard
15:20:55 <nolrai_P> for example every monad is a functor.
15:21:17 <nolrai_P> Or should be.
15:21:23 <toast-opt> @t fmap
15:21:23 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:21:24 <copumpkin> toast-opt: replace the second and third Functor with something
15:21:25 <toast-opt> > :t fmap
15:21:25 <copumpkin> :t fmap
15:21:25 <lambdabot>   <no location info>: parse error on input `:'
15:21:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:21:38 <toast-opt> ah, that's right
15:21:46 <copumpkin> make sense?
15:21:55 <toast-opt> still getting used to type classes being assertion, not parameterized types
15:22:12 <toast-opt> copumpkin, entirely.  that's kinda cool. not sure where the 'funct' in it comes from
15:22:13 <copumpkin> an interesting functor is (c ->)
15:22:25 <copumpkin> it maps fairly cleanly to the notion of a functor in category theory
15:22:36 <toast-opt> ... iow, now i'm only confused about the name.  the meaning is clear now.
15:22:43 <toast-opt> ah, got it.
15:23:09 <copumpkin> in the category of haskell types (as objects) and functions as arrows
15:23:15 <toast-opt> category theory made up a word, and haskell uses it.  if i want to find out what the name came from, ask category theory folks.
15:23:16 <copumpkin> (ignoring seq and unsafe* etc.)
15:23:16 <toast-opt> so?
15:23:26 <toast-opt> aren't you all category theory folks here?
15:24:01 <copumpkin> "The word "functor" was borrowed by mathematicians from the philosopher Rudolf Carnap [Mac Lane, p. 30]. Carnap used the term "functor" to stand in relation to functions analogously as predicates stand in relation to properties. [See Carnap, The Logical Syntax of Language, p.13-14, 1937, Routledge & Kegan Paul.] For Carnap then, unlike modern category theory's use of the term, a functor is a linguistic item. For category theorists, 
15:24:18 <copumpkin> a functor is a morphism in the category of categories
15:25:08 <toast-opt> curious question -- i'm having some bad perf in rendering large fractal images
15:25:24 <toast-opt> does Data.Array.fromList evaluate lazily too?
15:25:49 <copumpkin> :t Data.Array.fromList
15:25:51 <lambdabot> Not in scope: `Data.Array.fromList'
15:26:01 <toast-opt> sry, listArray
15:26:02 <mauke> toast-opt: yes
15:26:12 <mauke> that's how you can build recursive arrays
15:26:19 <toast-opt> that's what i thought
15:26:29 <toast-opt> cpu time is scaling fine until it starts paging
15:26:37 <toast-opt> what's the way to force?
15:26:43 <copumpkin> you could rnf it
15:26:45 <copumpkin> but that's ugly
15:27:02 <Raevel> when will ghc 6.12 be released?
15:28:05 <copumpkin> I think too many people misunderstand dependent types as a holy grail
15:30:42 <nolrai_P> Is it posible for a single pattern match to be overlapped?
15:30:53 <benmachine> uhm, with?
15:30:54 <copumpkin> did anyone catch this gem? http://knol.google.com/k/are-real-numbers-uncountable#
15:32:19 <nolrai_P> good lord.
15:32:27 <poe> copumpkin eek.
15:33:09 <Niccus> that is beautiful
15:33:09 <copumpkin> I love his comment at the bottom: "Unfortunately I had to disable comments on this knol. I am not interested in debating any of Cantor's theories. He was a fool and I shall not waste my time debating any of his feeble ideas."
15:33:09 <gwern> and people complain about wikipedia
15:33:29 <ben> >:I
15:33:41 <copumpkin> "all numbers with finite decimal expansions are countable, ergo the reals are countable! QED, and cantor's a dumbass"
15:34:00 <poe> classy
15:34:10 <inimino> thank god someone created Knol, where true experts won't be shouted down by the mob
15:34:36 <copumpkin> well, edwardk has a nice catamorphism knol out there
15:34:45 <poe> for better questions and answers http://mathoverflow.com/ :)
15:35:26 <copumpkin> I sort of doubt this crank would get much karma on there :)
15:35:36 <copumpkin> I'm surprised the ratings for his articles are so high?
15:35:38 <poe> oh great there is a way to flag the knol in the lower left.
15:35:55 * mauke categorizes it as "obvious troll"
15:36:37 <Niccus> oh we can only wish cranks are trolls, consciously knowing that what they're saying is incorrect
15:37:26 <inimino> more like "I couldn't understand Cantor and this is my incredibly elaborate justification of why I'm still smarter than everyone who can"
15:37:33 <poe> copumpkin also his other works are worthy: "In conclusion, both a fraction and derivative, belong to a special class of numbers we call fractions."
15:38:13 <copumpkin> I seem to remember him claiming that all that reduction equivalence classes of tuples = rationals was crap, and that 1/2 /= 2/4
15:39:08 <Niccus> what conclusions did he derive from that morsel of theory
15:39:28 <copumpkin> that mainstream mathematicians are dumber than he is, I think
15:40:43 <crash[`]> copumpkin: we should mail him a present
15:40:48 <nolrai_P> Why am I getting this warning? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13317#a13317
15:40:54 <crash[`]> a little trophy engraved with something mean
15:41:21 <ray> i never waste my time debating cantor's feeble ideas either
15:42:23 <nolrai_P> true
15:43:11 <mauke> nolrai_P: what's the definition of Object?
15:43:48 <osaunders> Quake 1, episode 1, hard difficulty, 30 mins 48 secs, me, awesome.
15:44:38 <Niccus> good work
15:45:18 <crash[`]> osaunders: i would shake your hand if i could
15:45:39 <monochrom> nolrai_P: Are you turning on warnings such as -Wall ?
15:45:42 <osaunders> crash[`]: :-D
15:46:02 <gwern> copumpkin: wait, 1/2 =/ 2/4 ?
15:46:11 <copumpkin> gwern: according to Mr Crank
15:46:24 * gwern 's mind is blown
15:46:50 <gwern> so, I could like, take 3 oranges, cut each in half, and wind up with more or less than 6?
15:47:14 <mauke> less
15:47:42 <ben> 6 or 6 halves?
15:47:50 <osaunders> > 1/2 == 2/5
15:47:52 <lambdabot>   False
15:47:53 <osaunders> > 1/2 == 2/4
15:47:55 <lambdabot>   True
15:48:24 <ray> osaunders: what, you can't find nightmare? it's inside the episode 4 entrance
15:48:26 <mauke> @check \x y -> x/y == (2*x)/(2*y)
15:48:28 <lambdabot>   "Falsifiable, after 0 tests:\n0.0\n0.0\n"
15:48:31 <ray> come back when you're done
15:48:33 <osaunders> > [1.0, 1.1 .. 1.5]
15:48:34 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
15:49:08 <osaunders> ray: On shareware?
15:49:26 <nolrai_P> mauke: Thanks!
15:49:35 <mauke> haha, what
15:49:45 <ray> you aren't using the full version?!!?!
15:49:50 <ray> it doesn't matter, it's still inside the gate
15:50:00 <osaunders> No, I'm cheap.
15:50:07 <osaunders> Exceptionally cheap.
15:50:43 <gwern> too cheap to even pirate it, 'twould seem, 'sblood!
15:51:31 <osaunders> gwern: Yes, that cheap.
15:51:50 <osaunders> I'm so cheap that when I open my wallet people die.
15:52:23 <mauke> <mathrick> "In Cantor's time, there was little or no knowledge about bijective or surjective functions." <-- !?!?!?!?!
15:52:31 <mauke> <Foone2> those weren't discovered till 1969
15:52:32 <mauke> <Foone2> when they were found on the moon
15:52:44 <mauke> <Gayo> it's only with our modern electron microscopy that we can really analyze the deep structure of a bijective function
15:53:26 <monochrom> why are we reading this, though funny it is?
15:54:12 <nolrai_P> we've learned to much math so we have to get rid of it with anti-math.
15:54:22 <mauke> because it's a reaction to copumpkin's link
15:55:58 <centrinia> "By Cantor's definition, a set is countable if a bijection exists from a subset to itself." -- John Gabriel
15:56:41 <mauke> wait, is that John Gabriel from Penny Arcade?
15:57:34 <centrinia> Wow, this blog post is a piece of work. :O
15:58:31 <Baughn> @ask dcoutts Could you point me at the part of cabal which creates .cabal/share/doc/index.html? (I'd like to make it create an index.xml as well, for haskell-mode)
15:58:32 <lambdabot> Consider it noted.
15:58:50 <i_am_neuron> Folks, I'm converting a year's 2-digit string representation to its 4-digit representation. The best I got is: 'show ((\x -> if x > 50 then x + 1900 else x + 2000) (read y :: Int))' I think it's ugly. Could you help me doing it better?
15:59:12 <kmc> @bot
15:59:12 <lunabot>  :o
15:59:13 <lambdabot> :)
15:59:22 <monochrom> I think it's just fine.
15:59:41 <ray> i_am_neuron: in substance
15:59:50 <toast-opt> hmm, quick q -- any way to access the fraction of a floating point number?  ex, 1.37511e2 -> 0.511
16:00:09 <ray> i would clean it up using where clauses
16:00:14 <mauke> @hoogle (RealFrac a) => a -> (a, a)
16:00:15 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
16:00:15 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
16:00:15 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
16:00:21 <leimy> Ok, this may be an obvious question to many but when the heck would one really prefer foldl to foldl'?
16:00:25 <mauke> > properFraction 1.37511e2
16:00:26 <lambdabot>   (137,0.5109999999999957)
16:00:33 <toast-opt> oh, sweet
16:00:36 <toast-opt> thx mauke
16:00:49 <copumpkin> doesn't look very proper to me
16:00:59 <i_am_neuron> ray: thx, I'll do this
16:01:00 <FunctorSalad> leimy: heh I don't know either off-hand
16:01:05 <monochrom> I haven't found a good use of foldl
16:01:06 <toast-opt> so snd . propertFraction
16:01:09 <kmc> leimy, maybe your accumulator really does need to be lazy
16:01:12 <copumpkin> leimy: I don't know of any reasons
16:01:14 <kmc> like you're consing onto an infinite list
16:01:27 <toast-opt> > snd . properFraction $ 1.37511e2
16:01:29 <lambdabot>   0.5109999999999957
16:01:30 <ray> i_am_neuron: also, make the arbitrary cutoff between 1900s and 2000s a variable, so you can change it at a glance
16:01:37 <ray> (also in a where clause)
16:01:44 <monochrom> Oh, I guess using foldl to implement reverse is a good one.
16:01:49 <kmc> > foldl (flip (:)) (repeat 0) [1..10]
16:01:51 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:01:52 <leimy> The only reason I can see it being a benefit, is when the foldl's result can be paused and resumed in the program lifetime.
16:01:52 <kmc> > foldl' (flip (:)) (repeat 0) [1..10]
16:01:53 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:01:56 <kmc> hmm
16:01:59 <FunctorSalad> heh
16:02:00 <leimy> meaning, using that non-strictness like a coroutine
16:02:12 <kmc> right 'cause it only forces to whnf
16:02:16 <leimy> However, I very very rarely need to do that :-)
16:02:21 <leimy> like, almost never
16:02:33 <leimy> maybe I think too much like a strict programmer.
16:02:42 <copumpkin> I still can't think of any examples
16:02:57 <leimy> well i can think of one or two
16:03:03 <leimy> consider that "sum" is basically foldl
16:03:17 <leimy> and you have a program that reads ints till it gets not int or a EOF
16:03:24 <FunctorSalad> > length $ foldl (\_ _ -> undefined) [0..10]
16:03:25 <leimy> then you could "interact" it
16:03:25 <lambdabot>   Couldn't match expected type `[a]'
16:03:26 <lambdabot>         against inferred type `[b] -> [t]'
16:03:26 <copumpkin> why not just foldr there?
16:03:30 <toast-opt> ... maybe you want foldl if you're using unsafePerformIO
16:03:44 <leimy> and make the whole thing lazy.
16:03:45 <FunctorSalad> > length $ foldl (\x _ -> undefined:x) [] [0..10]
16:03:46 <lambdabot>   11
16:03:48 <leimy> because the entire program can stream.
16:03:50 <toast-opt> and want to defer the io, but need left fold
16:03:50 <FunctorSalad> > length $ foldl' (\x _ -> undefined:x) [] [0..10]
16:03:52 <lambdabot>   11
16:04:02 <FunctorSalad> err right, only whnf
16:04:06 <leimy> One could seemingly produce a running sum with the right version of foldl ?
16:04:11 <leimy> but I think scan does that :-)
16:04:23 <copumpkin> > scanl (+) 0 [1..5]
16:04:25 <lambdabot>   [0,1,3,6,10,15]
16:04:32 <leimy> yep :-)
16:04:36 <copumpkin> > scanl1 (+) [1,3..]
16:04:37 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:07:10 <leimy> > let ones = 1:ones; in scanl1 (+) $ take 10 ones
16:07:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:08:07 <leimy> > let ones = 1:ones in sum $ take 10 ones
16:08:08 <lambdabot>   10
16:08:29 <leimy> See it's not like foldl gets you a magic state monad or anything
16:08:44 <leimy> or does it? :-)
16:09:02 <tcherkoff> i_am_neuron: http://is.gd/56gRs
16:09:13 <leimy> what is the value of a non strictly evaluated foldl?
16:09:23 <leimy> Probably just a thunk, not a value and a thunk :-)
16:09:44 <leimy> I should say a non NF foldl evaluation.
16:10:49 <i_am_neuron> tcherkoff: wow! :)
16:11:12 <leimy> anyway these things are fresh in my mind due to some real world problems I had with laziness
16:11:40 <leimy> It seems haskell is a better procrastinator than my late father was (no offense dad!)
16:11:54 <syntaxglitch> hoogle seems to be having issues :(
16:12:01 <leimy> syntaxglitch: it's just lazy
16:12:07 <mauke> preflex: seen byorgey
16:12:08 <preflex>  byorgey was last seen on #haskell 2 hours, 57 minutes and 17 seconds ago, saying: mreh: see definition #3
16:13:08 <paul0> Hi
16:13:12 <ACSpike[Home]> is there a list function that replaces one element with something else?
16:13:22 <Baughn> preflex: seen skorpan
16:13:23 <preflex>  skorpan was last seen on #haskell 10 hours, 3 minutes and 6 seconds ago, saying: i tried coq but choked
16:13:51 <Niccus> ACSpike what do you mean exactly?
16:14:33 <leimy> ACSpike[Home]: You can't mutate a list, so do you mean construct a list with a new value in the place of another
16:14:34 <leimy> ?
16:14:43 <mauke> preflex: tell byorgey re 'split': I just found one of my program gives wrong answers for empty strings because splitEvery 7 "" == [], not [""]. is this deliberate?
16:14:43 <preflex>  Consider it noted.
16:14:46 <leimy> if so, yes you can write that many ways :-)
16:14:50 <Baughn> @ask skorpan Does the patch meet your requirements? (If you want to keep adaptive fill on.. good luck fixing it!)
16:14:54 <tez_h> preflex: seen Heffalump
16:14:54 <preflex>  Heffalump was last seen on #haskell 5 days, 2 hours, 57 minutes and 55 seconds ago, saying: koeien37: http://www.reddit.com/r/programming/comments/9y25c/joel_spolsky_snakeoil_salesman/c0f02j1
16:14:58 <ACSpike[Home]> leimy: yes of course
16:14:59 <lambdabot> Consider it noted.
16:15:13 <ACSpike[Home]> I want to specify an index and a new item and get a new list
16:15:22 <osaunders> Is there any difference between function application and calling a function?
16:15:32 <leimy> ACSpike[Home]: You could use fold
16:15:36 <leimy> one of them :-)
16:15:57 <ACSpike[Home]> yes, I was just wondering if there was already something to do this
16:16:02 <leimy> The seed could be the index of the thing you want and an empty list :-)
16:16:16 <leimy> Looked at Data.List?
16:16:18 <poe> osaunders usually no :) the former concept is encapsulated in the ($) function.
16:16:32 <leimy> It at least has a lookup function
16:16:43 <leimy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
16:17:12 <mmorrow> nice, global register vars + gcc http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5177
16:17:19 <Jedai> ACSpike[Home]: No, probably because it's not a very list-like operation, are you sure you don't want to use some flavor of array instead ?
16:17:43 <osaunders> poe: OK, thanks.
16:17:54 <ACSpike[Home]> I'm just working on an exercise in a book with a list of length 5 so speed isn't a real big deal
16:18:41 <leimy> well I'm pretty sure you can't go faster than some kind of fold
16:18:42 <ACSpike[Home]> I figured there might be a companion to (!!) but you are right it isnt very listy
16:18:48 <Jedai> > let replace n x xs = let (pre, _:post) = splitAt n xs in pre ++ x : post in replace 4 20 [1..10]
16:18:50 <lambdabot>   [1,2,3,4,20,6,7,8,9,10]
16:19:21 <leimy> Jedai: nice :-)
16:19:43 * leimy probably would have folded :-)
16:20:04 <leimy> and then had strictness issues :-)
16:21:21 <ACSpike[Home]> Jedai: thanks!
16:21:35 <leimy> that's a pretty nice function right there :-)
16:22:34 <Jedai> it lacks error handling though, a real solution should do a case _ of on the second part of the pair splitAt returns
16:23:02 <Stinkman> Noob question: This is my definition of Tree in which each node has zero or more children. How does it look?
16:23:02 <Stinkman> data Tree a = Leaf a | ValuedBranch (a, [(Tree a)]) deriving (Show,Eq)
16:23:02 <Stinkman> Here is how I print the tree:
16:23:02 <Stinkman> createTabs :: Int -> String
16:23:02 <Stinkman> createTabs tabs = if tabs > 0 then "\t" ++ createTabs (tabs - 1) else ""
16:23:03 <Stinkman> printTree :: Tree String -> Int -> String
16:23:05 <Stinkman> printTree (ValuedBranch (a,b)) level = (createTabs level) ++ (show a) ++ "\n" ++ concat [(printTree nTree (level +1)) | nTree <- b]
16:23:08 <Stinkman> printTree (Leaf a) level = (createTabs level) ++ (show a) ++ "\n"
16:23:10 <Stinkman> If I were to export this type from a module, and I knew more about Haskell, I would hide the value constructors and provide accessor functions--correct?
16:23:25 <Stinkman> Sorry I was unaware my POS IRC client would do taht
16:24:13 <Jedai> Stinkman: "ValuedBranch a [Tree a]" would be more haskelly
16:25:31 <Stinkman> Jedai: thanks.  That would not be a pair tuple, though, right?
16:25:41 <mmorrow> , time (head (foldl' (flip (:)) [] [0..10000]))
16:25:43 <lunabot>  (1.0e-3,10000)
16:25:46 <mmorrow> , time (head (foldl (flip (:)) [] [0..10000]))
16:25:48 <lunabot>  (1.0e-3,10000)
16:25:58 <mmorrow> , time (head (foldl' (flip (:)) [] [0..10000]))
16:26:00 <lunabot>  (1.0e-3,10000)
16:26:06 <mmorrow> um
16:26:08 <Stinkman> Jedai: Oh I see.  I got it.  I would then use pattern matching
16:26:12 <poe> what's lunabot reference webpage/darcs repo?
16:26:29 <Jedai> Stinkman: No, which would be more haskelly, why would you want a pair there ? The value and the subtrees are not that tightly coupled
16:27:01 <Stinkman> Jedai: Because I'm new to Haskell and currently not Right Thinking on many issues
16:27:15 <Stinkman> Jedai: I definitely see why that is more Haskelly
16:27:51 <mmorrow> poe: http://moonpatio.com/repos/lunabot/
16:28:16 <Jedai> Stinkman: You use too much parens too (to avoid precedence problem I guess ?), for instance function application has higher precedence than any operator so you don't need parens around (createTabs level) or (show a)
16:29:28 <osaunders> I've been creating these flashcards for learning Haskell. And you know what, it's way too much work.
16:29:28 <mmorrow> , time (last (foldl' (flip (:)) [] [0..10000]))
16:29:30 <lunabot>  (1.0e-3,0)
16:29:33 <mmorrow> , time (last (foldl (flip (:)) [] [0..10000]))
16:29:35 <lunabot>  (1.0e-3,0)
16:29:42 <mmorrow> , time 42
16:29:44 <lunabot>  (0.0,42)
16:30:13 <Stinkman> Jedai: Got it.  I will refine my evil ways
16:30:41 * mmorrow tries to think of some way to tell the difference between reverse with foldl and foldl' with time
16:30:57 <Jedai> Stinkman: I would also invert the parameter order of printTree to be able to replace "concat [(printTree nTree (level +1)) | nTree <- b]" by "concatMap (printTree $ level + 1)"
16:31:14 <mmorrow> , time (foldl' (+) 0 (foldl (flip (:)) [] [0..10000]))
16:31:16 <lunabot>  (9.989999999999999e-4,50005000)
16:31:22 <mmorrow> , time (foldl' (+) 0 (foldl' (flip (:)) [] [0..10000]))
16:31:24 <lunabot>  (1.0e-3,50005000)
16:31:39 <mmorrow> , time (foldl' (+) 0 (foldl' (flip (:)) [] [0..10000]))
16:31:40 <Jedai> mmorrow: I think foldl' would be better, no ? foldl would just replace the cons cell by closures in memory
16:31:41 <lunabot>  (1.0e-3,50005000)
16:31:55 <mmorrow> Jedai: i think it would be better too
16:32:11 <Jedai> mmorrow: There shouldn't be much difference in this case though, not like sum...
16:32:22 <derenrich> so yeah
16:32:37 <derenrich> why isn't the += operator implemented yet?
16:32:54 <Axman6> derenrich: what would it do?
16:32:59 <derenrich> add
16:33:01 <mmorrow> Jedai: i'm trying to think of some combo of dependencies that highlights that foldl is building up thunks wrt reverse
16:33:03 <Stinkman> derenrinch: hahaha
16:33:04 <benmachine> @let (+=) = mod
16:33:06 <lambdabot>  Defined.
16:33:07 <benmachine> > 4 += 3
16:33:09 <lambdabot>   1
16:33:11 <benmachine> implemented.
16:33:15 <Axman6> derenrich: but we have (+) for that
16:33:20 <Jedai> derenrich: Because you can do it yourself ? And it would only work on Ref anyway
16:33:40 <derenrich> o thanks
16:33:50 <mmorrow> hmm, this might be being offset by the enumFromTo?
16:33:55 <Jedai> derenrich: You do understand that affectation don't exist in Haskell ?
16:33:56 <Stinkman> Jedai: I will have to look up some stuff but thank you very much.  That looks wayyy better.
16:34:15 <mmorrow> , let xs = [0..10000]; o = rnf xs `seq` () in time o
16:34:17 <benmachine> Jedai: does affection?
16:34:17 <lunabot>  (1.0e-3,())
16:34:19 <Jedai> Stinkman: You're welcome, good luck with your exploration of Haskell :)
16:34:22 <mmorrow> aha!
16:34:39 <benmachine> ignore me I am being silly
16:34:44 <mmorrow> , let xs = [0..10000]; o = rnf xs `seq` () in o `seq` time (foldl (flip (:)) [] xs)
16:34:46 <lunabot>  (1.0e-3,[10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,998...
16:34:55 <mmorrow> , let xs = [0..10000]; o = rnf xs `seq` () in o `seq` time (head (foldl (flip (:)) [] xs))
16:34:57 <syntaxglitch> wouldn't x += y just do what it does in most languages, be syntactic sugar for x = x + y?
16:34:57 <lunabot>  (9.989999999999999e-4,10000)
16:34:58 <Jedai> benmachine: only if you don't say it out loud (but that's not Haskell that's academia)
16:35:02 <mmorrow> , let xs = [0..10000]; o = rnf xs `seq` () in o `seq` time (head (foldl' (flip (:)) [] xs))
16:35:04 <lunabot>  (1.0e-3,10000)
16:35:12 <derenrich> doesn't work http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5178#a5178
16:35:20 <syntaxglitch> so if you said "x += 2" it'd mean the same thing as "x = x + 2", defining x as two larger than itself
16:35:22 <Niccus> :t time
16:35:23 <lambdabot> Not in scope: `time'
16:35:33 <alatter> syntaxglitch: you could do that, but then evaluating 'x' would crash your program
16:35:43 <benmachine> unless you used lazy naturals
16:35:48 <mmorrow> Niccus: it's from http://hackage.haskell.org/package/timeit
16:35:49 <alatter> true fact!
16:35:50 <Jedai> syntaxglitch: Ok, so it would only be useful with a lazy (+) (not very often)
16:35:59 <syntaxglitch> I didn't say it would be useful!
16:36:05 <benmachine> or! something like record update syntax could mean the xs referred to different things
16:36:09 <syntaxglitch> But it would be valid Haskell :)
16:36:11 <poe> > (do { y <- (+)1; return y; }) 10 -- kind of += :D
16:36:12 <copumpkin> it is useful
16:36:12 <lambdabot>   11
16:36:16 <alatter> syntaxglitch: sorry to accuse of being useful :-)
16:36:20 <mmorrow> ah ok, the list was just too small
16:36:26 <mmorrow> , let xs = [0..1000000]; o = rnf xs `seq` () in o `seq` time (head (foldl (flip (:)) [] xs))
16:36:28 <lunabot>  (0.295954,1000000)
16:36:31 <mmorrow> , let xs = [0..1000000]; o = rnf xs `seq` () in o `seq` time (head (foldl' (flip (:)) [] xs))
16:36:33 <lunabot>  (9.5986e-2,1000000)
16:36:59 <copumpkin> > (fix (2 +) :: Natural) > 3
16:37:02 <lambdabot>   True
16:37:06 <alatter> I guess I should have used a pronoun
16:37:33 <poe> ?index Natural
16:37:34 <lambdabot> bzzt
16:37:36 <Jedai> mmorrow: I didn't know "time", it's an evil hack from lunabot ?
16:37:37 <mmorrow> , fix N
16:37:38 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = Luna.Nest.N a
16:37:57 <mmorrow> Jedai: it's from the timeit package on hackage, but unsafePerformIO'ed in the bot
16:37:58 <copumpkin> > fix succ > (3 :: Natural)
16:37:59 <lambdabot>   True
16:38:04 <mmorrow> well
16:38:25 <poe> ?check \n -> fix succ > (n :: Natural)
16:38:26 <lambdabot>   Not in scope: type constructor or class `Natural'
16:38:27 <copumpkin> preflex: seen Veinor
16:38:27 <preflex>  Veinor was last seen on #haskell 22 hours, 43 minutes and 34 seconds ago, saying: > (9^9^9)
16:38:29 <mmorrow> time o = unsafePerformIO (timeIt (return $! o))
16:38:30 <poe> aww :(
16:38:44 <Jedai> mmorrow: nice ^^
16:38:54 <mmorrow> it's surprisingly handy
16:39:58 <MoALTz_> > [1.0 ..]
16:39:59 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
16:40:03 <Jedai> copumpkin: I think "let x = succ x" is good enough
16:40:09 <copumpkin> fix is prettier
16:40:24 <kingbiscuit> done' <- do $ {                         if result' == limit                                 then return true;                                 else return false;                 };
16:40:24 <poe> > succ 0 :: Natural
16:40:26 <lambdabot>   1
16:40:26 <Jedai> > let x = succ x in x > 10000 :: Natural
16:40:28 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
16:40:28 <lambdabot>         against ...
16:40:38 <copumpkin> muahahaha
16:40:52 <copumpkin> > let x = succ x in x > (10000 :: Natural)
16:40:52 <kingbiscuit> anyone know how to assign a variable as a result of an if statement? I tried this: done' <- do $ {                         if result' == limit                                 then return true;                                 else return false;                 };
16:40:53 <lambdabot>   True
16:41:05 <mauke> 'do $' looks wrong
16:41:25 <mauke> kingbiscuit: let done' = result' == limit
16:41:30 <Jedai> kingbiscuit: your semicolon are incorrectly placed
16:42:02 <mmorrow> , let go o = (time o :) . go in fix go
16:42:03 <lunabot>  luna: Couldn't match expected type `[(GHC.Types.Double, a)]'
16:42:11 <mmorrow> , let go o = (fst (time o) :) . go in fix go
16:42:12 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Double]'
16:42:34 <Jedai> kingbiscuit: as they are right now they say that "if result' == limit then return True" and "else return False" are two independent statements
16:42:48 <kingbiscuit> oh
16:43:28 <Jedai> kingbiscuit: and True and False take a capital (they're data constructors so they have to) but just use what mauke told you...
16:44:00 <benmachine> by the way, it might help to think of them not as "if statements" but "if expressions"
16:44:14 <benmachine> they can be used wherever a normal expression can, although you might want to put them in brackets
16:44:20 <Jedai> benmachine: Good point !! ;)
16:44:21 <benmachine> er, parentheses
16:44:29 <kingbiscuit> oh ok, thanks fo rthe help
16:44:31 <mmorrow> , let go o = (fst (time o) :) in fix (go (42:))
16:44:31 <kingbiscuit> errrr
16:44:33 <lunabot>  [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,...
16:44:40 <kingbiscuit> how do I stop ghci from this infinite loop i've created
16:44:46 <Niccus> ctrl+c
16:44:46 <mmorrow> ^Z
16:44:46 <mauke> try ctrl-c
16:44:47 <MoALTz> ctrl-c
16:44:51 <Jedai> kingbiscuit: Ctrl-C
16:44:56 <mauke> if that doesn't work, ctrl-z and kill %1
16:45:00 <mauke> (assuming unix)
16:45:03 <mmorrow> (^Z only if it's locked up)
16:45:04 <mmorrow> yeah
16:45:07 <kingbiscuit> thanks, ctrl-c didn't do anything but ctrl-z said suspended
16:45:14 <copumpkin> aw mmorrow has a smiley in his code
16:45:16 <mmorrow> killall -9 ghc # !!
16:45:24 <MoALTz> unless you are using interactive, which for some reason using ctrl-c in will cause ghci to exit too (??)
16:45:28 <copumpkin> or two, even!
16:45:28 <mauke> ctrl-z stops it; you can either resume or kill it now
16:45:29 <Jedai> kingbiscuit: or you try to kill it from another terminal or from the process manager on Windows
16:45:38 <MoALTz> :t interactive
16:45:40 <lambdabot> Not in scope: `interactive'
16:45:47 * MoALTz looks
16:46:03 <syntaxglitch> Okay, say I have a function that returns "IO Foobar", and I want to keep grabbing values from it until some value is reached. Pulling things from a lazy infinite list of type [IO Foobar] works, but is kind of awkward due to having to work around IO for each item.
16:46:03 <syntaxglitch> I wanted to write a function that would transform [IO Foobar] to IO [Foobar] so that I could just use takeWhile to pull the values I want and pass the [Foobar] to a comfortably non-IO function to do the interesting stuff.
16:46:03 <syntaxglitch> But when I tried doing it that way my program hung. I'm guessing that it tried to evaluate the entire [IO Foobar] list instead of only getting as many as needed to construct the IO [Foobar], but I don't have a solid enough grasp on Haskell to be sure.
16:46:04 <mmorrow> copumpkin: (:[{-Help!-}]) {- best quote evar -}
16:46:05 <syntaxglitch> Any idea why it wasn't being lazy there? Also, is my approach at all sensible, or should I scrap the IO [Foobar] idea and do something else?
16:46:06 <MoALTz> *interact
16:46:15 <Axman6> syntaxglitch: ... don't do that!
16:46:15 <mmorrow> @quote eat a comment
16:46:16 <lambdabot> No quotes for this person. Maybe you made a typo?
16:46:21 <mmorrow> @quote Help
16:46:22 <lambdabot> quicksilver says: well if you can get proggit to help with your interview, then perhaps you can get proggit to help with the job when you get it. So it's not cheating, it's just an indication of one
16:46:22 <lambdabot> of your skill sets.
16:46:23 <syntaxglitch> sorry D:
16:46:28 <copumpkin> @quote orbitz
16:46:29 <lambdabot> copumpkin says: orbitz makes [##C++] especially brutal to make people appreciate #haskell more
16:46:29 <syntaxglitch> That ended up being longer than I thought
16:46:31 <mmorrow> @quote Help!
16:46:31 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
16:46:36 <mmorrow> heh
16:46:57 <benmachine> :t sequence
16:46:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:47:18 <mauke> gentlemen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13320#a13320
16:47:28 <mauke> this little program encodes strings in javascript
16:47:56 <copumpkin> :o
16:47:57 <Axman6> syntaxglitch: takeWhile <some predicate> `fmap` sequence <list of IO actions>
16:48:07 <copumpkin> mauke: why the linear algebra?
16:48:17 <mauke> copumpkin: to solve the system of equations
16:48:18 <mmorrow> mauke: ooh, this looks either debaucherous, handay, or both
16:48:34 <benmachine> Axman6: you'd still have to do the whole list's IO wouldn't you?
16:48:35 <Jedai> syntaxglitch: just write a "untilM" or something, you have some package on hackage with something like that but that may not be worth it given the simplicity of the task
16:48:53 <benmachine> untilM is probably a good idea
16:49:00 <Axman6> benmachine: i think sequence is lazy enough. i could be wrong
16:49:03 <copumpkin> it's easy to write, anyway
16:49:04 <Jedai> Axman6: This don't work unfortunately (IO is too strict, in other monads it may work I believe)
16:49:06 <copumpkin> Axman6: nope
16:49:12 <Axman6> bah :(
16:49:22 <syntaxglitch> Jedai, that's basically what I was planning on doing, give or take
16:49:23 <benmachine> sequence shouldn't be lazy
16:49:27 <benmachine> weird things would happen
16:49:38 <copumpkin> [print "moo", putStrLn "ohai", launchMissiles]
16:49:47 <benmachine> yes :P
16:50:12 <syntaxglitch> but I wasn't sure if the nonlaziness with IO was because I was doing something wrong, or if that's just the way IO is
16:50:31 <benmachine> syntaxglitch: the order in which your IO happens is considered important
16:50:33 <Jedai> syntaxglitch: It's the way IO is, for good reasons
16:50:49 <syntaxglitch> well, yeah
16:50:53 <benmachine> so deferring evaluation of a result until later could be dangerous
16:51:03 <benmachine> you can still do it with unsafeInterleaveIO
16:51:11 * stoop touches benmachine 
16:51:18 * benmachine falls over
16:51:38 <syntaxglitch> I'm too young as a Haskell prog'er to be doing unsafe things
16:51:41 <syntaxglitch> falling in with a bad crowd
16:51:43 <syntaxglitch> that never ends well
16:51:44 <benmachine> heh
16:51:50 <benmachine> you are probably right
16:52:01 <benmachine> but it's nice to know what exists
16:52:19 <mauke> mmorrow: did you get it to compile? :-)
16:52:28 <benmachine> note that readFile and getContents are lazy, which is why they do odd things sometimes
16:52:29 <Jedai> benmachine: sequence is not inherently strict though, it's just IO that is, (error monads are like that too, but the list monad is not)
16:53:37 <benmachine> Jedai: not inherently, maybe, but
16:53:49 <benmachine> > sequence (map Just [1..])
16:53:52 <lambdabot>   * Exception: stack overflow
16:54:17 <benmachine> > sequence (map Just [1.. 20] ++ [Nothing])
16:54:19 <lambdabot>   Nothing
16:54:29 <syntaxglitch> Actually, now that I think about it, if it worked the way I was trying for, I could end up in a situation where non-IO code deciding how many elements to read from a non-IO list would change the order in which IO actions were executed
16:54:36 <syntaxglitch> ...which sounds like a bad idea
16:54:36 <benmachine> > sequence (map Just [1.. 20] ++ repeat Nothing)
16:54:38 <lambdabot>   Nothing
16:55:11 <Jedai> syntaxglitch: that's the problem in a nutshell
16:55:18 <benmachine> syntaxglitch: quite often it is, hence the unsafe in unsafeInterleaveIO, but you can imagine some cases when ordering'd not be important
16:55:44 <syntaxglitch> yeah, but probably unwise more often than not, I'd imagine...
16:55:53 <Axman6> syntaxglitch: you could always write a function: sequenceWhile :: Monad m => (a -> Bool) -> [m a] -> m [a]
16:56:17 <mmorrow> mauke: just did, but realized i don't have a js interp compiled on this computer, so now building the spidermonkey repl...
16:56:22 <syntaxglitch> okay, problem solved: my original idea was dumb and didn't work because Haskell was protecting me from myself
16:56:29 <syntaxglitch> good to know!
16:56:30 <kingbiscuit> can anyone help  me figure out why I get a "parse error on input putStr" in this function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13321
16:56:39 <mauke> sample output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13320#a13322
16:57:04 <syntaxglitch> Axman6, not a bad idea
16:57:19 <Axman6> kingbiscuit: i told you yesterday. you need to remove a space before result <- atomically $ do {
16:57:20 <mmorrow> heh, yeah i'm not quite sure quite what it does yet..
16:57:26 <mauke> Axman6: what?
16:57:35 <Axman6> kingbiscuit: result needs to line up with putStr
16:57:36 <mauke> Axman6: why?
16:57:50 <Axman6> mauke: ?
16:57:57 <mauke> YOU HEARD ME
16:58:05 <syntaxglitch> it looks untidy otherwise, Haskell has delicate sensibilities and gets upset if things are disorganized
16:58:10 <Axman6> i did, but i have no idea what you're on about
16:58:10 <syntaxglitch> you're hurting its feelings :(
16:58:18 <mauke> Axman6: I have no idea what you're on about
16:58:40 <Axman6> -_-
16:58:55 * Axman6 ignores mauke for a while so he can continue to be helpful
16:58:57 <mauke> kingbiscuit: you need 'let {done = result == max};'
16:58:59 <Jedai> kingbiscuit:  The problem is the ";" after "let done = result == max" is taken as part of the block introduced by let, not the block introduced by do...
16:59:14 <kingbiscuit> hmm, I tried the space but it still errors the same
16:59:22 <mauke> the space doesn't matter
16:59:29 <Jedai> kingbiscuit: you don't use layout so space don't matter
17:00:10 <Jedai> kingbiscuit: in fact your problem came from mixing layout (no braces in your let) and explicit syntax
17:00:58 <kingbiscuit> oh that makes sense
17:01:11 <Axman6> kingbiscuit: we almost never use { .. } and semicolons. it adds unneeded ugliness: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13321#a13325
17:01:27 <Gracenotes> some people like them in addition to indentation.
17:01:51 <kingbiscuit> it does look nicer, but i'm no good with spacing
17:02:04 <Jedai> Gracenotes: I like them in my GHCi but not much elsewhere
17:02:28 <Gracenotes> you are forced to like them in GHCi :)
17:02:28 <Jedai> kingbiscuit: it's really not that hard if you follow some simple rules
17:02:30 <copumpkin> mauke's series of interjections to Axman6 (especially the "what") reminds me of that lazy town vs. lil jon remix
17:02:42 <Axman6> ha
17:02:58 * Axman6 still has no idea what mauke was on about
17:03:01 <copumpkin> rub that **** it's yours *****
17:03:04 <mmorrow> mauke: ohhh, haha. cool
17:03:05 <kingbiscuit> I have a severe logic error in that funciton...it's supposed to be able to be called by different threads and add up to a limit (like 100), but it always infinite loops...I think this has something to do with wrongly placed atomicity but not sure where it is
17:03:31 <mauke> Axman6: your comments about the spacing were irrelevant because he didn't use layout
17:03:32 <Gracenotes> it's a piece of cake to bake a pretty cake
17:03:35 <mmorrow> mauke: i didn't realize what was happening for a second there (i still am not sure, but it's clearly encoding the input somehow)
17:03:53 <copumpkin> if the way is hazy
17:04:27 <kingbiscuit> oh wait, maybe it's not atomicity...I think my condition is wrong
17:05:05 <Axman6> kingbiscuit: what's the type of putTMvar?
17:05:48 <mmorrow> mauke: also amusing is to run the encoder on it's own output one or more times, then wrap in the same number of eval()'s
17:05:55 <mauke> hehe
17:06:10 <kingbiscuit> putTMVar :: TMVar a -> a -> STM ()
17:06:28 <Axman6> kingbiscuit: then the put' <-"
17:06:31 <Axman6> bah
17:06:46 <Axman6> then the "put' <-" is unnecessary
17:07:13 <Gracenotes> copumpkin: you gotta do the cooking by the book. (mm, lambda cookies)
17:07:43 <kingbiscuit> oh true
17:07:48 * Axman6 giggles adorably
17:07:53 <mauke> ./jslinenc 'Hello, world!' | ./jslinenc | { echo 'print('; cat; echo ')' } | js | { echo 'print('; cat; echo ')' } | js
17:08:35 <Niccus> but then comes the concept of currying lambda cookies and that doesn't sound tasty
17:08:47 <Axman6> om nom nom
17:13:34 <Botje> ever had wasabi or chili chocolate? it's very nice :)
17:14:11 <Gracenotes> at the same time? :o
17:14:56 <gwern> chili chocolate tastes strange
17:15:02 <gwern> not good, but not bad either
17:15:23 <gwern> just a tiny pinch of chili powder works well in hot chocolate tho
17:15:40 <copumpkin> preflex: seen edwardk
17:15:40 <preflex>  edwardk was last seen on #haskell 4 days, 5 hours, 4 minutes and 57 seconds ago, saying: cale: what i currently do is i allow do foo; bar; baz on one line, but in essence with my layout if you break it across multiple lines (and need indentation control) you need to move it down, since i don't know that the width of space, d, and o are the same.
17:21:33 <BMeph> Interesting: the company that does the kids' program has filed (at least) two"take-down" orders for that video...and lost both times.
17:21:35 <blackdog> is there a ghc-pkg command corresponding to "obliterate this package with fire"?
17:21:37 <blackdog> unregister doesn't seem to remove the actual packages
17:23:17 <gwern> blackdog: heck, ghc-pkg doesn't even keep track of files installed
17:23:28 <gwern> how could it?
17:25:02 <chrisdone> gwern: cabal packages could optionally implement an uninstall procedure?
17:25:14 <gwern> chrisdone: which would work how?
17:25:32 <Cale> It should be possible for cabal to uninstall, it just hasn't been implemented.
17:25:36 <gwern> if you don't know what files you installed at the beginning, you're guessing, methinks. good guesses, perhaps, but still guesses
17:26:00 <chrisdone> gwern: then keep track of what files were installed at the beginning?
17:26:29 <blackdog> gwern: you're right, it's a cabal responsibility
17:26:44 <blackdog> sorry, wasn't thinking clearly. rm -rf it is:)
17:26:55 <gwern> chrisdone: great. get right on it!
17:27:27 <blackdog> gwern: there are a few things you could work out from the cabal file, surely. being complete would be a lot trickier, i suppose.
17:29:26 <chrisdone> gwern: I might try it tomorrow
17:36:16 <musty> stoop, hi.
17:43:53 <toast-opt> are list concatenations expensive?
17:43:59 <copumpkin> yeah
17:44:03 <toast-opt> i know they are in scheme, but not sure if lazy evaluation helps
17:44:04 <blackdog> only if you look at them
17:44:20 <copumpkin> the same is true of anything in haskell! :P
17:44:48 <toast-opt> heh
17:44:50 <blackdog> copumpkin: indeed:) i just had that problem in Hubris, actually - throwing a pattern match exception inside a Maybe on the Haskell side
17:45:02 <blackdog> but i wasn't looking at it any further than Just _
17:45:11 <gwern> lispers know the value of everything, and the cost of nothing; haskellers don't know even that
17:46:10 <MarcWeber> int_e: Today I digged up your git-darcs-import patch. It still works very well. I'll post it on the darcs mailinglist. Hopefully we can find a way to integrate it into darcs permanently..
17:46:10 <blackdog> i should probably do a deepseq or something, the rubyists might be a bit surprised by something that doesn't blow up until you look at it.
17:51:01 <mxweas> copumpkin: Hey, you here?
17:54:02 <bos> anyone want google wave invites?
17:54:23 <thoughtpolice> bos: i've kinda wanted to try it, but i'm still not exactly sure what wave is :/
17:54:47 <bos> thoughtpolice: dm me an email addy
17:56:04 <blackdog> bos: have you found it useful? i can see scope for useful things, but am not seeing many people actually using it yet.
17:56:22 <bos> blackdog: i don't have enough contacts on there for it to be useful yet.
17:56:54 <ray> anyone want to add me on google wave? :)
17:56:58 <blackdog> bootstrapping's hard:/
17:57:25 <bos> yep
17:58:21 <ray> gwern: haskellers know the type of everything and the value of nothing?
17:58:25 <sshc> what's wrong with haskell.org?
17:58:39 <sshc> hoogle
17:58:39 <Niccus> no idea but it's bad
17:59:12 <Axman6> bos: i've got it, and there's a few other haskellers who do too (there a public haskell wave too)
17:59:46 <ray> haskell.org works for me
17:59:53 <bos> Axman6: i haven't found most of those people yet :-\
18:00:13 <ray> someone needs to make a directory
18:00:15 <sizur> I have a wave too, and it's a desert
18:00:17 <Axman6> i think searching for "haskell with:public" does it
18:01:54 <Axman6> hmm, i have 24 invites now. anyone want one?
18:02:10 <monochrom> how did you earn 24 invites?
18:02:30 <ray> they just hand them out like candy, but they aren't guaranteed to actually invite someone
18:02:39 <ray> and even if it does it takes a week or so
18:03:20 <monochrom> Oh fun, redundant inexpensive invite array RIIA
18:03:23 <gwern> ray: that works too, but my version is more insulting, and we do know values if we look
18:03:50 <Axman6> monochrom: by being awesome
18:03:53 <ray> well it's a tradeoff between being insulting and fitting the formula
18:05:38 <gwern> ray: yeah; perlis's original epigram only mentioned lisp programmers; if he had said something like 'C programmers know the cost of everything and the value of nothing' and vice versa, then I could've just swapped lisp for c and haskell for lisp
18:05:54 <sshc> can anybody explain the DoAnIfThen in Haskell 2010?
18:05:55 <michaelh> axman, throw one my way! :)
18:06:20 <mauke> if cond then
18:06:22 <mauke>   foo
18:06:23 <mauke> else
18:06:24 <mauke>   bar
18:06:34 <michaelh> axman6, if you're serious
18:06:39 <Axman6> yep
18:06:43 <sshc> mauke: will that work in a do block?
18:06:48 <sshc> mauke: *without* any semicolons?
18:06:48 <mauke> it will now
18:06:48 <Axman6> just pm me email addresses
18:06:54 <mauke> sshc: er, what?
18:07:02 <mauke> sshc: do you know how layout works?
18:07:06 <sshc> mauke: trac says it needs semicolons
18:07:11 <mauke> no, it doesn't
18:07:12 <monochrom> You have to write "do { xxx; if x then do { m; n } else do {m;n} }" now. It proposes to let you write "do { xxx; if x then {m;n} else {m;n} }"
18:07:32 <mauke> monochrom: that's completely different from what I've read
18:07:43 <sshc> which GHC version supports this?
18:07:43 <mauke> are we talking about the same thing?
18:07:51 <Cale> What proposes that?
18:07:57 <sshc> does 6.10.4 support this?
18:08:44 <Axman6> could someone tell me where this american idea that you need to pull lose teeth out comes from? they come out by themselves...
18:09:11 <ray> you try walking around with a half-detached tooth in your mouth sometime
18:09:19 <Axman6> i have, many times
18:09:21 <monochrom> We are impatient.
18:09:38 <ray> not even eating, just existing
18:09:38 <monochrom> We don't do lazy tooth detachment.
18:09:44 <ray> eating is an order of magnitude worse
18:09:58 <jql> how does any kid overcome the compulsion to play with the tooth? it felt so necessary to wiggle it
18:09:58 <ray> where do *you* get this idea that you shouldn't just reach in and yank the thing out
18:10:07 <Axman6> ray: having lost all my baby teeth this way, i can tell you it's fine
18:10:20 <jql> the only way to return to normalcy is to see the tooth removed
18:10:23 <Axman6> jql: it helps it come out, no need to not play with it really
18:10:25 <syntaxglitch> when I was a kid I ate too much gooey candy
18:10:31 <syntaxglitch> so the problem tended to solve itself promptly
18:10:50 <Axman6> this is the reason i asked: http://www.liveleak.com/view?i=49b_1259354881
18:11:15 <jql> is that the toy car one?
18:11:43 <Axman6> yeah
18:11:51 <ray> the classic is using a door
18:11:58 <sshc> why would you pull them out?
18:12:05 <jql> I never had a tooth "pulled"
18:12:14 <jql> they all fell out au natural
18:12:37 <jql> and by that, I mean I wiggled them into submission
18:12:38 <Axman6> why go through the pain >_<
18:13:00 <monochrom> If programming languages are like dental care, OCaml is like yanking out all teeth at 14, Haskell is like never yank any teeth, and C++ is like shooting yourself in the mouth to yank out teeth.
18:13:03 <jql> shit, 20 years later I can recall the sensation
18:13:07 <ray> well that's not really common
18:13:14 <ray> i just pulled them out by hand
18:13:18 <jql> probably because of my teeth-falling-out nightmares, but still
18:14:12 * ddarius never had any pain removing any teeth.
18:14:25 <jql> regardless of the efficacy of pulling teeth, those parents were pretty cool
18:14:39 <ray> yeah, it's painless if it's actually loose
18:14:42 <jql> I can only aspire to be as cool
18:15:09 <stoop> monochrom, what are your problems with ocaml?
18:15:43 <MarcWeber> monochrom: That's not quite true: You have to take IDE features int account etc. One thing which bothers me is that you will never be able to do a instance.getCompletionList() in haskell :)
18:16:17 <blackdog> MarcWeber: that's not strictly true. it's just a bit harder.
18:17:15 <blackdog> as you're writing a haskell program, there's a hole for the bit you're writing, and that has some type constraints on it. if you just did a hoogle search then cut it down by types (eliminate anything that fundamentally can't fit), you could get something usable
18:18:12 <MarcWeber> blackdog: In haskell you use (Tag foo) = getter ADT or such.  So you have to remember getter because you write it before ADT. Same about SQL. If you could write  FROM .... SELECT .... WHERE you could get completions at .... without jumping back
18:18:18 <sshc> is there an offline alternative I can use besides hoogle?
18:18:59 <Saizan_> you can "cabal install hoogle"
18:19:01 <MarcWeber> sshc: What for exactly? If you want to look up types and implementation I recommend hack-nix, vim and tags. It works really well.
18:19:18 <Saizan_> and then use the hoogle executable
18:19:36 <ray> is that really offline?
18:19:36 <sshc> MarcWeber: I was looking for something to use while the online hoogle is donw
18:19:38 <Saizan_> MarcWeber: hack-nix installs TAGS files?
18:19:44 <sshc> Saizan_: thanks, I'll look at that
18:19:45 <MarcWeber> Saizan_: sure.
18:19:59 <MarcWeber> That's not quite true. It exports TAG_FILES so that vim adds them automatically.
18:20:13 <MarcWeber> Otherwise I would die looking up types and such
18:20:17 <Saizan_> ray: yes, though you only have a limited database by default, you can add to it manually
18:21:05 <blackdog> MarcWeber: sure. but the context that you're writing in has an expected return value, so you could just take every possible completion. It's not nearly as accurate, i'll give you that.
18:21:11 <ray> then i'll definitely install it
18:21:38 <Niccus> @hoogle [a] -> a\
18:21:38 <lambdabot> Parse error:
18:21:38 <lambdabot>   --count=20 "[a] -> a\"
18:21:38 <lambdabot>                       ^
18:21:41 <Niccus> @hoogle [a] -> a
18:21:41 <lambdabot> Prelude head :: [a] -> a
18:21:41 <lambdabot> Prelude last :: [a] -> a
18:21:41 <lambdabot> Data.List head :: [a] -> a
18:22:16 <Saizan_> that plugin is just a thin layer above the hoogle executable in fact
18:23:05 <MarcWeber> Saizan_: hack-nix is even cooler because you can make it configure 5 shells compiling the same project using 2 different version of ghc and 2 different flag combinations..
18:23:38 <ray> @hogl a -> [a]
18:23:40 <lambdabot> Prelude repeat :: a -> [a]
18:23:40 <lambdabot> Data.List repeat :: a -> [a]
18:23:40 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
18:26:29 <Saizan_> MarcWeber: but no coffee? awww.
18:27:00 <MarcWeber> Saizan_: If it could cook coffee that would be a bug.
18:27:39 <p_l> Saizan_: you need to get a coffee machine that support Hypertext Coffee Pot Protocol
18:28:04 <stoop> Hi
18:28:12 <stoop> Hoogle is down, any idea when it'll come back up?
18:28:30 <Saizan_> no
18:28:36 <p_l> *Coffee pot Control Protocol
18:28:49 * Saizan_ didn't realize hoogle was so popular
18:29:03 <stoop> I use hoogle most of the time I use Haskell.
18:29:26 <stoop> (to avoid re-inventing the wheel).
18:29:28 <stoop> Fortunately, there is lambdabot :-)
18:29:31 <stoop> @hoogle a -> b
18:29:31 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:29:31 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:29:31 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:29:33 <stoop> Ok.
18:29:35 <stoop> Great.
18:29:43 <mauke> you can also install hoogle locally
18:29:57 <stoop> mauke, probably a better idea.
18:30:05 <stoop> mauke, it would require a web server, etc...yes?
18:30:10 <Saizan_> no
18:30:15 <Saizan_> it has a CLI interface
18:30:15 <stoop> Is it also a utility?
18:30:18 <stoop> Wow.
18:30:24 <Optimality> err, I suppose developing an interest in Hoogle and attempting to try it out in response to a "hoogle is down" message is a bad idea :)
18:30:27 <mauke> er, the web page is just a thin wrapper around hoogle
18:30:49 <stoop> I had no idea.
18:30:54 <Saizan_> Optimality: "cabal install hoogle" to you too :)
18:30:59 <Optimality> lulz
18:31:10 <ray> optimality: hoogle is the wonderful haskell search engine that can search by type signature
18:31:16 <Optimality> yeah, I was like "Hmm, this Hoogle sounds interesting, let's go try it out! Oh right..."
18:31:59 <Optimality> holy crap it installed 77 packages
18:32:11 <stoop> Optimality, no.
18:32:21 <blackdog> it'd be even better with strong cabal integration, so installing a new package would let hoogle index it too. Not volunteering, though:)
18:32:21 <stoop> Optimality, that is 77 files that were compiled.
18:32:38 <Saizan_> MarcWeber: wait, 2 ghc versions and 2 different flag combinations adds up to 4, what's the fifth shell for?
18:32:44 <stoop> The problem is now I need to index everything.
18:32:49 <mauke> Saizan_: bottom
18:33:03 <Optimality> stoop: oic :)
18:33:13 <stoop> This is great for productivity and has most a lot of what I need.
18:33:18 <stoop> Thanks
18:33:33 <MarcWeber> Saizan_: It was an example only. You do hack-nix --build-env $NAME_OF_CONFIG and it prints a "source PATH/source-me" line
18:34:21 <Saizan_> MarcWeber: i see, much like Python's virtualenv
18:34:24 <MarcWeber> When sourcing that file ghc and the dependencies are added to PATH .
18:34:24 <stoop> The nice thing about the web interface is that I have links to documentation.
18:34:58 <MarcWeber> Saizan_: And it supports gtk2hs.
18:35:39 <Saizan_> MarcWeber: how does it work? it bypasses cabal-install completely?
18:36:00 <MarcWeber> Saizan_: Yes.
18:36:32 <MarcWeber> the brute-force dependency solver is written in nix. So it's slower. But when using latest versions only and default flag configurations its quite usable
18:37:11 <MarcWeber> If you have an environment for a project once you can't destroy it while preparing environments for other projects.
18:39:49 <MarcWeber> Saizan_: And you can substitute arbitrary packages within those dependency chains.
18:40:02 <MarcWeber> Eg you can replace HTTP by HTTP-fixed or HTTP-my-dev-version.
18:40:13 * araujo got wave invites in case anyone interested
18:40:48 <osaunders> What is there that's good for writing a simple 2D game in HS?
18:41:12 <Saizan_> MarcWeber: by writing some script/configuration file for the environment?
18:42:07 <MarcWeber> Saizan_: http://github.com/MarcWeber/haskell-nix-overlay/blob/master/default.nix line 98.
18:42:28 <MarcWeber> This imports a file which basically contains the hackage index contents.
18:42:47 <MarcWeber> After reading that you can inject a map function replacing or adding packages.
18:43:01 <Saizan_> i see
18:43:14 <aavogt> @type ?f `uncurry` ('a',1)
18:43:15 <lambdabot> forall b c. (?f::Char -> b -> c, Num b) => c
18:43:25 <mmorrow> how would people define (wrt code transformations and/or optimizations) "a syntactic transformation" and "a semantic transformation" (i'm trying to come up with 1-2 sentence definitions of each that are "good")
18:43:26 <mmorrow> ?
18:44:02 <mmorrow> also, assume that those are the only two terms under discussion (i.e. "well it could be both" isn't)
18:44:04 <MarcWeber> Saizan_: The nix config file looks like this. It just overrides some stuff from the main configuration: http://dpaste.com/126482/
18:44:34 <MarcWeber> line 6 is most important. It contains the target packages.
18:44:41 <ddarius> mmorrow: If the audience knows what syntax and semantics are the terms are self explanatory.
18:44:47 <mmorrow> i'm not sure how to precisely define "semantic transformation", because *any* transformation invariably needs to manipulate/produce syntax
18:46:15 <ddarius> mmorrow: What is an example of each?
18:46:17 <mmorrow> ddarius: oh, i mean this for myself too, i'm not sure how to define the two in such a way that i can even (given the definitions) mechanically classify a transformation given X, Y, and Z about it
18:46:28 * mmorrow comes up with examples
18:46:33 <osaunders> Hoogle is still down.
18:46:47 <osaunders> So yeah, 2D games, what should I use?
18:47:13 <Saizan_> SDL?
18:47:15 <nainaide> BONUS, thanks for your  http://learnyouahaskell.com/, great work! I am looking forward the new chapters every day! :)
18:47:46 <mmorrow> syntactic := the transformation is dependent on the actual concrete (concrete abstract rep that is) syntactic representation of the program
18:48:07 <osaunders> Hm.
18:48:32 <mmorrow> semantic := isn't completely definable by only giving the way it transforms the syntactic representation
18:48:40 <Optimality> ahh, that reminds me - BONUS, I did really enjoy your tutorial, and learned what Haskell I know from it - thanks!
18:48:43 <ray> semantic transformation would be the same for different syntaxes that denote the same thing?
18:48:43 <Optimality> BONUS++
18:49:06 <ddarius> mmorrow: Perhaps think of what is held invariant for each type.
18:49:12 <mmorrow> ray: right, something like that
18:49:55 <mmorrow> ddarius: hmm, that could be an approach
18:51:36 <osaunders> Do Haskellers use Git?
18:51:58 <bos> plenty of them do.
18:52:03 <bos> many do not.
18:52:11 <MarcWeber> ?where time
18:52:13 <lambdabot> I know nothing about time.
18:52:21 <osaunders> Says on the Haskell Wiki that people use darcs mostly.
18:52:35 * osaunders likes git.
18:52:58 <kmc> i use git
18:53:19 <MarcWeber> osaunders: I'm using git. And I don't use darcs for bigger projects for various reasons.
18:53:36 <kmc> git is based on an immutable associative datastructure :)
18:53:46 <ray> haskellers that are gits use git, haskellers that are darcses use darcs.. wait
18:54:08 <osaunders> I really like git. In fact I can't really imagine how anything else could be much better without my knowing about it.
18:54:23 <ray> that's a lack of imagination
18:55:10 <Saizan_> that's a very dangerous way of thinking, it leads to people like Guido Van Rossum :)
18:55:20 <MarcWeber> The nice thing about git is: It tracks the real world: What patch was added when. So you can follow the development progress easily. In darcs you just have darcs changes --verbose, right? And I like having multiple branches within one directory. Last but not least I use some git gui tools very often.
18:55:52 <osaunders> I don't always think the same way.
18:56:16 <osaunders> Also I'm not expressing myself well at the moment.
18:56:29 <roconnor> the main drawback of git is that it tracks the real world. :/
18:56:43 <Saizan_> MarcWeber: darcs annotate if you want to know which darcs patch is responsible for which line
18:56:46 <p_l> well, you can in theory build any kind of version control on top of git... it's just a content-addressable memory
18:56:48 <osaunders> It would be better to say Linus promoted git on the basis that is did a whole bunch of things that others didn't. I like those things.
18:56:50 <mwc> I don't really like the "big sack of patches" model of darcs
18:57:07 <MarcWeber> Saizan_: Run it and prepare a cup of tee and coffee
18:57:18 <ray> i do like the big stack of patches model
18:57:34 <Saizan_> MarcWeber: i would use hack-nix for that if it worked!
18:57:39 <mwc> ray: I said sack, not stack, specifically
18:57:44 <mwc> if it was a stack, I'd like it better
18:58:03 <Saizan_> MarcWeber: thogh, seriously, it's quite faster recently, but i'm not here to promote any vcs :)
18:58:07 <ray> well, it's not a stack in the data structural sense
18:58:25 <mwc> the fundamental principle of darcs is that it doesn't enforce patch ordering
18:58:48 <mwc> if the patches were sequentially ordered, there'd be a "stack"
18:58:49 <ray> right
18:59:17 <mwc> to me, revision history is intrinsically causal, and so I don't like darc's acausal structure
18:59:35 <ray> i don't think non-total ordering is incompatible with calling it that :)
18:59:39 <MarcWeber> Saizan_: Eg I've written a small system which get's a dev snapshot of a software package automatically. For every vcs it wsa easy to find a name for the snapshot archive. name-r20.tar.gz for svn, name-HASH.tar.gz for git etc. What to do with darcs?
18:59:54 <mwc> s/don't like/am instinctually revolted by/
18:59:59 <crash[`]> other than the fact that darcs is written in haskell/used for most haskell projects, how you guys think it compares to SVN/Git/etc?
19:00:16 <ray> being written in haskell just brought it to my attention quicker
19:00:35 <Saizan_> osaunders: the others in that sentence are mostly the centralized vcses, not the dvcs crowd, though git is surely the faster in the group
19:00:58 <osaunders> Saizan_: Yeah, maybe.
19:01:30 <osaunders> I'm really happy with git at the moment though. And I still don't know as much about it as I would like. I'd like to stay settled on git for at least a year.
19:02:07 <ray> with darcs, if you want to cherrypick patches from a repository, you just do it
19:02:24 <Saizan_> MarcWeber: an hash of the context, i guess
19:02:41 <osaunders> ray: git diff SOMECOMMIT SOMECOMMIT~1 > whatever.diff
19:02:46 <ray> that's conceptually appealing to me, because it's really just an irrelevant coincidence that this change happened to be written before that change
19:02:46 <MarcWeber> Saizan_: But it's hard to find the context if the hash is given only.
19:03:19 <MarcWeber> My solution is adding tags. However they are meaningless to others.
19:03:31 <mmorrow> ddarius,ray: ooh, this looks possibly very interesting (just uploaded to here, i forget where i got it from ;) http://moonpatio.com/repos/synsem_absinterp.pdf
19:03:34 <ray> git has github though :)
19:04:01 <MarcWeber> If darcs had a nicer gui and if it supported multiple branches within one directory I'd love it.
19:04:20 <osaunders> mmorrow: Wow that looks hard.
19:04:27 <MarcWeber> ray: Read the haskell weekly news. There was an article that someone launched darcs hosting similar to git
19:05:40 <mmorrow> osaunders: heh, it does. but i also think that just reading a few choice one-liners might end up being very useful
19:06:01 <ray> looks french! good thing that's only in the addresses
19:06:07 <mmorrow> now to find those one-liners..
19:06:16 <osaunders> mmorrow: Hehe, good luck!
19:06:33 <osaunders> Although I'm sure you're much smarter than me so it won't be as hard for you.
19:07:33 <mmorrow> osaunders: understanding is almost always simply a matter of desire
19:07:33 <sshc> is darcs more suited speficially for Haskell?
19:07:53 <thoughtpolice> no
19:07:54 <ray> not really, it just happens to be implemented in haskell
19:08:05 <osaunders> mmorrow: There's a bit more to it than that but desire is a big part, sure.
19:08:07 <sshc> what advantage does using darcs instead of git have if you're working in Haskell?
19:08:31 <osaunders> sshc: That's sort of what we've been debating.
19:08:41 <ben> sshc: You get less dirty looks from #haskell
19:08:46 <osaunders> lol
19:08:53 <mmorrow> osaunders: well, desire is what prompts you to spend a year learning about what you need to finally go back and do it ;)
19:09:09 <ben> If darcs is good enough for ghc, it probably ought to be good enough for me...
19:09:09 <sshc> :)
19:09:29 <ray> except they were plotting to go git
19:09:29 <osaunders> mmorrow: Yeah. I do know what you mean desire has brought me here, to learn Haskell.
19:09:42 <ben> ray: I thought that was years ago and nothing came of it?
19:09:43 <mmorrow> osaunders: woot!
19:09:56 <osaunders> ben: Git is good enough for the Linux Kernel.
19:09:58 <thoughtpolice> ben: it was like, a few months ago
19:10:06 <ben> hmm
19:10:21 <thoughtpolice> ben: but darcs has improved a lot since then, so the question of changing to git is still up in the air
19:10:32 <thoughtpolice> it may or may not happen.
19:10:39 <osaunders> ben: Which is actually more impressive given how many contributors are involved.
19:10:39 <ben> osaunders: The linux kernel has a very unique culture, I guess
19:11:13 <mmorrow> the tools that exist for working with/viewing/cgi-ing/etc git repos are what makes it tempting to me
19:11:23 * mmorrow is considering switching currently actually
19:11:28 <crash[`]> Mercurial is still getting popularity as well, surprisingly.. FogCreek is building a new product around it, Kiln
19:11:41 <osaunders> ben: It means git has a bunch of stuff specifically for patching and emailing patches.
19:11:50 <thoughtpolice> i like git's speed (not to say darcs == uber slow) and it's branching capabilities
19:11:59 <thoughtpolice> which is why i've mostly moved to git for all my own work
19:12:46 <byorgey> preflex: seen mauke
19:12:47 <preflex>  mauke was last seen on #haskell 39 minutes and 59 seconds ago, saying: Saizan_: bottom
19:12:48 <preflex>  byorgey: you have 1 new message. '/msg preflex messages' to read it.
19:12:53 <osaunders> I use bzr (bazaar) for a while, that's written in Python so it's not exactly fast but it's very user friendly.
19:13:37 <thoughtpolice> mmorrow: also yes, cgit is awesome imo :)
19:13:42 <osaunders> ben: Just don't use CVS or SVN and you can't go too far wrong.
19:13:45 <crash[`]> cgit?
19:13:57 <thoughtpolice> probably the fastest web-viewer for any VCS i've ever seen
19:13:59 <crash[`]> osaunders: What do you not like about SVN?
19:14:01 <Rotaerk> osaunders, what about VSS?
19:14:02 <Rotaerk> *cough*
19:14:11 <Rotaerk> you forgot to exclude that
19:14:23 <ray> svn?!!?!?!?!?!?!!?!!
19:14:28 <ray> i feel the rage coming on
19:14:45 <ray> no, wait, i got it out with all those punctuation marks
19:15:01 <kingbiscuit> Axman6, mauke, Jedai, thanks for the help
19:15:12 <ben> I never quite got around to figuring out how to set up svn in the first place.
19:15:12 <osaunders> crash[`]: Always online and entirely centralized, merges and branching are really hard and error prone, a lot of operations are slow compared with git.
19:15:24 <ben> The whole distributed thing seems to make that trivial.
19:15:58 <osaunders> crash[`]: Oh and the general shell interface just seems inferior and clunky. If you do something wrong you might have to type 6 things to fix it with SVN but there'll probably be one with git.
19:16:06 * thoughtpolice remembers reading a book about SVN when he was learning about version control
19:16:31 <thoughtpolice> the first few pages talked about 'setting up a server'; I thought that was needlessly complicated, and at that point closed the book and never opened it again :)
19:16:40 <osaunders> SVN always scared be by how easily things were to screw up and how fixing them would have to involve other people and stuff.
19:17:06 <crash[`]> osaunders: alright; i've used SVN for the last 4 years and never had any real troubles. I do like git more, but I was just curiousl. Only thing I really prefer in git is being offline
19:18:14 <ray> svn is like cvs but with some minor changes and a gigantic marketing machine
19:18:43 <osaunders> SVN is better than CVS but not by enough, for me.
19:18:44 <elly> minor changes like versioning of directories :P
19:18:51 <c_wraith> well, svn also removed sane tagging.
19:18:59 <ray> unfortunately, the world of version control passed it by!
19:19:12 <ray> moving straight (back) to decentralized systems
19:20:42 <dibblego> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Category.html where is instance (Monad m) => Category (Kleisli m) ?
19:21:43 <byorgey> preflex: tell mauke that's intentional, so it satisfies the property   splitEvery n (as ++ bs) == splitEvery n as ++ splitEvery n bs, whenever (length as `mod` n == 0)  and other similar properties
19:21:43 <preflex>  Consider it noted.
19:22:57 <atp> hey all, what's the appropriate function to use to remove a file these days... it used to be removeFile I thought but that function doesn't seem to exist anymore, and removeLink in the POSIX libs is neither portable nor semantically what i want
19:23:16 <atp> (sorry, don't do much IO stuff usually)
19:25:56 <Cale> :t System.Directory.removeFile
19:25:58 <lambdabot> FilePath -> IO ()
19:27:12 <atp> Cale: thanks a bunch!
19:28:45 <mmorrow> ddarius: wow, that paper actually answers pretty much exactly i was wondering, and in encyclopaedic quantity and excrutiating (/= bad) detail.. (well, bad in the sense that fully understanding this would take like a month.., but just the words once-overed are enlightening)
19:30:16 <mmorrow> geez, each section of this paper contains the content of a single "regular" paper
19:32:52 * mmorrow prints this one
19:37:58 <vovik> can anyone help me fix these errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13330
19:38:04 <vovik> i'm having trouble with where clause scope
19:40:09 <osaunders> GHC takes a very long time to compile.
19:40:50 <holmak> What are you compiling?
19:40:53 <vovik> osaunders: imagine how people feel that just want to use xmonad and don't care about haskell
19:41:07 <vovik> holmak: i think he's compiling ghc
19:41:33 <holmak> ah, I read that the other way, that GHC takes a long time to compile *things*....
19:41:34 <osaunders> Yes.
19:41:56 <osaunders> MacPorts likes to compile things.
19:42:11 <osaunders> And apparently I didn't have a new enough GHC for DARCS.
19:42:19 <holmak> awesome
19:42:19 <alc> vovik: indent clauses after where
19:42:44 <holmak> GHC terrifies me, I don't even want to think about what goes on in there
19:42:51 <osaunders> heheh
19:42:52 <holmak> The transformations and things
19:42:55 <vovik> alc: didn't help :(
19:43:28 <Berengal> vovik: You've got one spelling error, two references to a name that's only introduced in an inner scope and one missing import
19:43:44 <Berengal> Plus I think indexOf is called elemIndex
19:44:01 <monochrom> nowbefore vs nowBefore
19:44:39 <vovik> thanks, let me fix those...
19:44:50 <monochrom> cardIndex belongs to nowAfter only.
19:45:46 <Axman6> holmak: some of the transformations are pretty easy to think about (especially when they're defined in RULES)
19:46:35 <monochrom> I used to think of what they taught in universities scary. Then I went to university and found them pretty easy.
19:48:06 <vovik> how do i make cardIndex belong to nowBefore and nowAfter
19:48:32 <vovik> should i use let instead of where for this?
19:48:39 <holmak> I suppose thats true. Most things in Haskell turn out to not be as horrible as they appear.
19:48:54 <monochrom> by not belonging to anyone in particular.
19:49:23 <holmak> It seems that every time I figure something new (monads), I look back and say, hey, there wasn't too much to that after all!
19:49:38 <monochrom> Make cardIndex a silbing of the other three.
19:49:57 <vovik> monochrom: thanks
19:50:05 <crash[`]> holmak: a lot of people seem to make a big deal out of things like that because of the sort of culture that's picking things up
19:50:09 <monochrom> It is the same story whether you use let or where.
19:51:09 <vovik> i see, so how do i know when to use let and when to use where>
19:51:20 <monochrom> mood
19:51:27 <vovik> hahaha ok
19:51:52 <Berengal> They're the same, except where can span over several expressions, and let is itself a single expression
19:53:44 <osaunders> You know Refactoring, the book, by Martin Fowler?
19:53:59 <osaunders> Is there one for Haskell? Because that would be awesome!
19:54:00 <monochrom> I don't know it.
19:54:25 <osaunders> monochrom: Do you know the word?
19:54:30 <monochrom> Yes.
19:54:43 <osaunders> Then you have felt its influence. :-)
19:55:45 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example  shows an example of refactoring a lot of Just/Nothing switching code into monadic code. That is how we refactor without saying "refactor".
19:56:14 <monochrom> Of course RWH has a similar example.
19:56:36 <monochrom> @src forever
19:56:37 <lambdabot> Source not found. Maybe you made a typo?
19:57:09 <blackdog> the line is sort of blurry, i think - everyone's written a dumb first draft that they've then gone back and made modular, readable, etc. is that refactoring or just programming?
19:57:32 <monochrom> Oh well; you could find it yourself: Control.Monad.forever is a refactoring of deliberate infinite loop of actions into one library function. We do that all the time without saying "refactoring" too.
19:58:11 <Berengal> I'd call 'forever' an abstraction...
19:58:25 <osaunders> blackdog: That's probably just programming.
19:58:26 <monochrom> Parametric polymorphism was an early refactoring method.
19:58:51 <osaunders> Refactoring means having tests.
19:58:54 <monochrom> I see no need to distinguish refactoring and abstraction.
19:59:00 <Berengal> Again, I'd call parametric polymorphism an abstraction
19:59:14 <Berengal> I'm not saying there's a difference, I'm saying I use different words
19:59:36 <blackdog> osaunders: we use tests too. we're not cowboys:)
19:59:47 <blackdog> except shapr. he has the hat and everything.
19:59:53 <osaunders> lol
20:00:07 * Berengal prefers proofs to tests if possible
20:00:18 <osaunders> Parametric polymorphism sounds like a goal of refactoring not refactoring itself.
20:01:02 <osaunders> Berengal: I'm guessing that's pretty advanced.
20:01:10 <blackdog> osaunders: no, not at all
20:01:16 <blackdog> type obligations are proofs
20:01:23 <Berengal> osaunders: depends on the language.
20:01:36 <osaunders> OK.
20:01:42 <osaunders> Well I'm referring to Haskell.
20:01:58 <Berengal> You can prove something in almost any language. The better the type system, the more you can prove.
20:02:02 <osaunders> I've heard about how difficult proofs are in stateful languages.
20:02:16 <osaunders> Hm, OK.
20:02:54 <ray> if you have a test, you now have to prove your program and your test
20:02:57 <roconnor> pointers or refererences makes proofs far more difficult.
20:03:02 <inimino> you can't write a correct program without constructing a proof, at least in your head
20:03:04 <inimino> if a language makes proofs difficult, it probably makes writing correct programs just as difficult
20:03:05 <ray> so just prove the program
20:03:25 <vovik> if i call a function that returns Maybe Int, but i don't want to continue execution if it returns Nothing, is case ... of ... Nothing -> error "..." a legitimate way to handle it?
20:03:39 <ray> if you really want to die on Nothing, use fromJust
20:03:49 <kmc> but you can give a better message this way
20:03:52 <roconnor> @type maybe
20:03:52 <kmc> :t maybe
20:03:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:03:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:03:59 <kmc> :t maybe (error "bleh") id
20:04:00 <Berengal> roconnor: I saw an ICFP video where they did just that in Coq, by bundling a functional version with the stateful algorithms/datastructures and proving the functional one
20:04:01 <lambdabot> forall a. Maybe a -> a
20:04:31 <roconnor> @type fromMaybe
20:04:32 <lambdabot> forall a. a -> Maybe a -> a
20:04:41 <vovik> oh so fromJust Nothing raises a descriptive enough error?
20:04:51 <ray> > fromJust Nothing
20:04:52 <lambdabot>   * Exception: Maybe.fromJust: Nothing
20:04:53 <roconnor> fromMaybe (error "bleh")  is probably better
20:05:20 <roconnor> I'd normally reserve fromJust for cases where I "know" the maybe is a Just.
20:05:26 <monochrom> Refactoring does not imply testing. Some refactoring methods involve testing just because the code transformation is so fragile that you can't be sure it's correctness-preserving. Well, the Just/Nothing refactoring to monad suffers no such problem: just inline >>= and mplus and you will see it is the same code.
20:05:40 <vovik> so what is fromMaybe used for?
20:05:44 <Axman6> roconnor: agreed
20:05:55 <Berengal> vovik: unpacking Maybes
20:06:01 <roconnor> vovik: converting a Maybe a into an a given a default value.
20:06:12 <roconnor> @type fromMaybe
20:06:13 <lambdabot> forall a. a -> Maybe a -> a
20:06:22 <roconnor> @djinn a -> Maybe a -> a
20:06:22 <Berengal> > fromMaybe 5 Nothing
20:06:22 <lambdabot> f a b =
20:06:23 <lambdabot>     case b of
20:06:23 <lambdabot>     Nothing -> a
20:06:23 <lambdabot>     Just c -> c
20:06:23 <lambdabot>   5
20:06:28 <vovik>  so the first argument is the default value?
20:06:35 <roconnor> yes
20:06:46 <Berengal> There's also maybe
20:06:48 <Berengal> @type maybe
20:06:49 <roconnor> vovik: which could be (error "I'm to lame to implement this case")
20:06:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:08:16 <vovik> well in this case if the call to elemIndex returns Nothing, the preconditions for the function where not met so i think using fromJust is justified (no pun intended)
20:08:42 <Axman6> :\
20:09:03 <Berengal> vovik: That's your prerogative.
20:09:10 <Berengal> I'm a fan of total functions...
20:09:11 * Axman6 doesn't think this is good practice
20:09:16 <Axman6> Berengal: me too
20:09:47 <Axman6> if for no better reason than -Wall happiness (and using error doesn't match my idea of happiness)
20:10:34 <monochrom> I'm a fan of writing main as a total function composed of partial functions but I use them wisely so I can prove that main is a total function despite its "imperfect" ingredients.
20:10:47 <monochrom> I mean, gosh, there is such a thing as if-then-else!
20:11:01 <Berengal> My reason is it's easy to forget the preconditions...
20:11:30 <Berengal> monochrom: I like Either too
20:11:40 <monochrom> main = if x==0 then print (1/(x+1)) {- this is a partial function, bite me -} else print (1/x) {- this is a partial function, bite me -}
20:11:44 <vovik> ugh i need to move to a room where my internet isn't so bad
20:12:35 <vovik> what would be the advantage of using fromMaybe with error ... as the default value?
20:12:44 <vovik> over fromJust
20:12:49 <Berengal> main = myDiv 1 x where myDiv n x | x == 0 = Left (n / (1 + x)) | otherwise = Right (n / x)
20:12:50 <dons> ?src fromJust
20:12:51 <lambdabot> fromJust Nothing  = undefined
20:12:51 <lambdabot> fromJust (Just x) = x
20:13:01 <dons> error is a bit better than undefined?
20:13:06 <roconnor> I made a point of not having a converion function AlphaColour -> Colour mainly becuase it is a partial function.
20:13:08 <dons> ?src fromMaybe
20:13:08 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
20:13:13 <Berengal> vovik: Better error messages
20:13:14 <roconnor> in my Colour library
20:13:15 <MoALTz> > undefined == undefined
20:13:17 <lambdabot>   * Exception: Prelude.undefined
20:13:24 <roconnor> the problem being that transparent has no colour.
20:13:30 * hackagebot upload: clutterhs 0.1 - Bindings to the Clutter animation library (MatthewArsenault)
20:13:51 <vovik> *** Exception: Maybe.fromJust: Nothing is a pretty informative error message if you ask me
20:14:05 <kmc> doesn't say where
20:14:08 <Saizan_> vovik: not if you've more than one fromJust in your program
20:14:15 <Saizan_> libraries included.
20:14:24 <andun> > let x = x in x == x
20:14:28 <lambdabot>   mueval-core: Time limit exceeded
20:14:31 <Saizan_> i assure you it's a pain!
20:14:41 <vovik> alright, you've convinced me
20:14:47 <Berengal> Prelude.head: Empty list <- hate
20:14:51 <vovik> but why is fromMaybe better than just a case?
20:14:55 <kmc> head should be named "unsafeHead"
20:15:16 <monochrom> Berengal: You are still using the partial function (/) in your code. To practice what you preach, you must presuppose that the Prelude provides a Just/Nothing version of division only, and no access to (/).
20:15:18 <Berengal> kmc: Or even better, require a proof of totality (i.e. non-empty list)
20:15:39 <MoALTz> (take 1) ?
20:15:45 <vovik> i guess fromMaybe is more concise than a case
20:15:50 <mmorrow> heh, yeah calling error is actually worse than just letting a pattern match fail, since at least then you get a source position range and module name..
20:16:06 <Berengal> monochrom: Yes, but the partial function is moved closer to the checking of the precondition. It's not the callers responsibility to get the input right anymore
20:16:21 * BMeph thinks people would look at you funny if you called it "unsafePerformHead"... ;p
20:16:21 <Saizan_> it's more concise and can be used in pointfree style
20:16:46 <Saizan_> also, it has a known simple semantic, a case can get as complex as you want
20:16:56 <vovik> Saizan_: good points
20:17:03 <MoALTz> > 1:2:3:4:[5..]
20:17:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:17:13 <MoALTz> > 1:2:3:4:undefined:[6..]
20:17:15 <lambdabot>   [1,2,3,4,* Exception: Prelude.undefined
20:18:30 <mmorrow> BMeph: why?
20:18:40 <mmorrow> BMeph: ( ;) )
20:18:52 <kmc> BMeph, :o
20:20:17 <vovik> thanks a lot for your help guys
20:22:05 * mmorrow thought he would just kill the suspense by indicating he's joking, since it's hard to tell when you're joking over irc.. but in hindsight he should've waited for a response because it probably would have been amusing regardless
20:24:23 <aavogt> @type gets head
20:24:24 <lambdabot> forall a (m :: * -> *). (MonadState [a] m) => m a
20:42:26 <solidsnack> I think John D Earle on the haskell-prime mailing list is a troll.
20:43:43 <Niccus> what'd he do
20:44:13 <Berengal> Troll, I assume
20:46:22 <Axman6> solidsnack: yeah, taking a quick look seems to comfirm it
20:47:21 <solidsnack> Niccus: He's posted a series of "On The Meaning of Haskell" messages.
20:47:36 <solidsnack> I was not really sure what was going on at first.
20:47:39 <dons> sometimes we get wacky people
20:48:11 <bos> it disturbs me slightly that forall is so stubbornly slippery in my mind.
20:48:23 <kmc> how's it slippery?
20:48:37 <ayphabo> what precendence does (::) have in relation to other operators?
20:48:55 <kmc> it's not an operator
20:48:57 <kmc> any more that = is
20:49:07 <bos> kmc: i have a hard time remembering the difference between these, for example:
20:49:10 <kmc> but it has lower precedence in a sense
20:49:12 <bos> data B a = forall b. B (a -> b) a
20:49:19 <bos> data B a = B (forall b. a -> b) a
20:49:45 <kmc> bos, yeah, the existential use of "forall" is a little weird
20:50:00 <kmc> but it's easy to see what the type (forall b. a -> b) means, and that b is not free in that type
20:50:06 <ayphabo> like does it have the same precedence as function application, or multiplication, or what?
20:50:13 <bos> kmc: "easy" :-)
20:50:39 <Axman6> ayphabo: it doesn really have any precedence... or, it has an extremely low precedence
20:51:41 <ayphabo> like in this code http://pastebin.com/m5480fd1 where can i put ::Int32
20:52:21 <Axman6> what?
20:52:42 <Axman6> are you trying to cast an Int into and Int32?
20:52:46 <kmc> bos, do you know System F?
20:53:06 <Axman6> because, you can't do casting in haskell (easily anyway). you need to use fromIntegral
20:53:15 <bos> kmc: i'm aware of it, but i've never read deeply about it.,
20:53:22 <Axman6> > fromIntegral (123 :: Int) :: Int32
20:53:24 <lambdabot>   123
20:53:49 <ayphabo> i'm trying to get the ints to overflow the exact same way as ints do in java
20:54:41 <Axman6> well, if you want to make the le value an Int32, you need to use fromIntegral
20:54:46 <Axman6> :t length
20:54:47 <lambdabot> forall a. [a] -> Int
20:54:52 <Axman6> :t fromIntegral
20:54:54 <lambdabot> forall a b. (Integral a, Num b) => a -> b
20:55:48 <ayphabo> ah, so fromIntegral just fixes all the types for you, i see
20:57:36 <kmc> bos, in system F, if expression e has type T (possibly free in S), then expression ΛS. e  has type  ∀S. T
20:57:41 <kmc> i.e. you add another kind of lambda to expressions, which is abstraction over types
20:57:50 <kmc> and the types associated with use of that lambda have foralls in them
21:00:29 <crash[`]> kmc: your A is upside down :(
21:00:35 <crash[`]> that's worse than an F
21:00:48 <kmc> ∀+
21:01:00 <crash[`]> Nooooes
21:01:09 <bos> kmc: yeah
21:02:01 <bos> i wonder if it would be kosher to add an operator to criterion to gather together a benchmark's name and the benchmark itself in a nice way.
21:02:25 <bos> right now, you have to write something like this:
21:02:27 <bos> bench "fib 10" $ B fib 10
21:02:31 <bos> that's a lot of clutter.
21:02:37 <bos> maybe something like this would be nicer:
21:02:47 <bos> "fib 10" := fib 10
21:02:57 <mmorrow> Bench{
21:03:06 <mmorrow> ooh, that's better than what i was about to suggest
21:04:40 <bos> hmm, i don't think it would work.
21:04:49 <bos> i'd have to write ("fib 10" := fib) 10
21:04:50 <bos> ugh.
21:04:50 <ddarius> $(bench fib 10)
21:05:16 <bos> ddarius: TH?
21:06:48 <bos> hi mtnviewmark
21:06:55 <mtnviewmark> good evening, bos
21:06:58 <mmorrow> maybe  data Bench = forall a. String := a; bench :: Bench -> ...
21:07:26 <mtnviewmark> spent some of last night and today benchmarking the Haskell LLSD library vis-a-vis the Python one
21:07:55 <bos> mtnviewmark: and?
21:08:17 <mtnviewmark> well, without having done ANY optimization or work on the Haskell lib, it is 8x faster than the Python one
21:08:25 <Berengal> \o/
21:08:25 <bos> mtnviewmark: oh, that's a nice surprise.
21:08:39 <kmc> mtnviewmark, which Python implementation?
21:08:44 <kmc> and which Haskell implementation?
21:08:49 <bos> mmorrow: hmm
21:09:00 <mtnviewmark> I expect to get some significant speed ups in the Haskell yet -- I'm not doing any forcing of strict, even in the obvious places
21:09:20 <mtnviewmark> kmc - the "standard one" that is floating around
21:09:34 <mtnviewmark> and - my haskell implementation
21:09:52 <mtnviewmark> not yet published (unsure how complete something should be before I put it on Hackage)
21:10:23 <kmc> CPython then
21:10:24 <kmc> mtnviewmark, i meant the language itself
21:10:24 <mtnviewmark> 2.6.1 to be percise
21:10:24 <mmorrow> bos: like `bench' being an interpreter for some mini Bench language
21:10:24 <kmc> ah
21:10:28 <mtnviewmark> I got that now....:-)
21:10:30 <solidsnack> bos: Why would you have to write `("fib 10" := fib) 10` ?
21:10:52 <solidsnack> Would the precedence of `:=` be greater than that of application?
21:11:18 <mmorrow> err, right, i guess
21:11:30 <mmorrow> data Bench = forall a. String := (Int -> a); bench :: Bench -> ...
21:11:38 <mmorrow> or whatnot
21:11:47 <bos> solidsnack: application binds most tightly
21:12:41 <bos> mmorrow: i don't think that helps?
21:13:12 <mmorrow> bos: oh, you mean with precedence and (:=) ?
21:13:16 <mtnviewmark> actually, the more interesting result for me was, having written this mini LLSD application now first in Haskell and then in Python, was the difference in the experience --- the Python one got coded faster, and got to "first run" sooner --- but had many little bugs that had to be eeked out one by one -- whereas the the Haskell one basically worked the first time it fully compiled.
21:13:16 <bos> right
21:13:28 <mtnviewmark> oh, and the Haskell one is 1/2 the size
21:13:30 <bos> mtnviewmark: welcome to the religion.
21:13:57 <mmorrow> bos: ah, i was picturing something like
21:13:57 <kmc> yeah that sounds like typical results
21:13:57 <mtnviewmark> I'm there!
21:14:05 <bos> python is a great way to write buggy code very fast.
21:14:07 <papna> 1/2 the lines-of-code?
21:14:12 <mtnviewmark> I have to admit though, part of the glory seems to be the language leads library writers to create good, generic interfaces
21:14:12 <papna> That's nothing to be proud of!
21:14:17 <Jafet> bos, that runs very slowly
21:14:24 <mtnviewmark> papna - yes, 1/2 the lines of code
21:14:26 <kmc> Jafet, but that's not the language's fault especilaly
21:14:43 <kmc> it's more that all existing implementations suck
21:14:46 <mtnviewmark> the LLSD library is 1/6 the lines of code as the C++ version of the same library
21:14:46 <kmc> i expect that to change
21:14:50 <blackdog> kmc: some languages are easier to compile to fast code than others, though.
21:14:54 <kmc> yeah
21:15:15 <Jafet> Ironically, I think the more efficient implementations will start coming out on JVM or .net
21:15:15 <kmc> python has a lot of dynamic features that are rarely used, and could be JIT-compiled out
21:15:27 <papna> kmc, Python is so dynamic it doesn't lend itself to a lot of stuff that leads to speedups in other languages.
21:15:41 <Jafet> Like that jython thing
21:15:41 <kmc> jython and ironpython
21:15:42 <kmc> that's not ironic
21:15:55 <Jafet> Python isn't dynamic, it's more like unstructured
21:16:00 <papna> Jafet, ..........
21:16:08 <kmc> you can assume those features aren't being used, and trap back to an interpreter when they are
21:16:08 <mtnviewmark> to be honest, I'm less concerned about speed (so long as either is in the ballpark), as I am about ease of coding, clarity of code, and confidence in the code
21:16:13 <kmc> mtnviewmark, exactly
21:16:23 <papna> Jython doesn't have the momentum IronPython has had the last couple years.
21:16:35 <papna> mtnviewmark, Indeed.
21:16:35 <crash[`]> Jafet: it's kind of dynamic by definition
21:16:39 <Jafet> papna, just look at its object semantics
21:16:58 <crash[`]> specifically..?
21:17:01 <kmc> i don't know what "unstructured" means as a contrast with "dynamic"
21:17:09 <Jafet> Example: def foo(l = []): l.append(len(l)); return l;
21:17:12 <kmc> and "dynamic" is a sort of poorly defined cluster of separate features
21:17:16 <bos> python is no more dynamic than javascript.
21:17:28 <bos> which is happily jitted all the time.
21:17:28 <mtnviewmark> I'm an old Smalltalk geek (worked on Apple Smalltalk w/Dan Ingalls) --- and I used to espouse that, despite it's speed loss, because coding in that environment and language was so much faster and efficient than the alternatives at the time (C and Pascall... it was a while ago!)
21:17:37 <solidsnack> Once you are dynamic, you are basically as dynamic as everyone else.
21:17:40 <kmc> it's a better descriptor than "scripting language" but only by a bit
21:17:51 <kmc> solidsnack, python doesn't support easy dynamic metaprogramming, like Lisp does
21:17:56 <kmc> but that's only one particular feature
21:18:08 <papna> Jafet, What am I supposed to gather from that (other than you-can-write-a-couple-lines-of-awful-Python-code)?
21:18:33 <kmc> python and javascript are actually very similar languages
21:18:33 <blackdog> kmc: it has eval, doesn't it?
21:18:44 <blackdog> i suppose "easy" is the key word, though
21:18:46 <kmc> blackdog, yes, but it's an eval on strings -- it's quite annoying to build code as strings
21:18:47 <kmc> yes
21:18:49 <Jafet> What I was failing to convey is that, python is "unstructured" because it lacks the ways to make abstractions over dynamic behaviour that makes those behaviour useful
21:19:03 <kmc> Jafet, what does it lack?
21:19:07 <mtnviewmark> oy - eval is the language implementor's nightmare
21:19:10 <blackdog> kmc: heh, half of Hubris is pasted-together C and haskell. is moderately filthy.
21:19:20 <kmc> mtnviewmark, it's not that bad.  you just bundle your compiler as a library
21:19:27 <mmorrow> bos: something like http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5180#a5180
21:19:32 <kmc> the mere presence of eval doesn't mean you can efficiently compile code
21:19:36 <kmc> Lisp has been doing it for decades
21:19:55 <crash[`]> Jafet: can you actually say anything conceret about it at all?
21:19:58 <crash[`]> concrete, even
21:20:08 <mtnviewmark> kmc: right, and close your eyes and give up all semblance of optimizations or control!
21:20:19 <kmc> ?
21:20:27 <kmc> when you compile eval'd code you can optimize it as well as any code
21:20:29 <bos> mmorrow: ah. have you looked at the changes in new criterion?
21:20:43 <kmc> you can expect that calling eval in an inner loop will be slow.  but not that calling eval'd code in an inner loop will be slow
21:20:45 <mmorrow> bos: ooh, no
21:20:47 <ddarius> mtnviewmark: eval is weak sauce
21:20:54 * mmorrow looks
21:20:55 <bos> mmorrow: i got rid of that pestilential Int parameter, but the resulting type makes it harder to pull your trick.
21:20:57 <blackdog> kmc: I suppose you'd give up intraprocedural optimisation unless you kept all of the source code around
21:21:03 <Jafet> kmc, overloading functions, for example
21:21:07 <mtnviewmark> most eval facilities wreak havoc on how the VM is operating, as the code compiled usually can play with the environment in janky ways!
21:21:12 <kmc> Jafet, you can make a decorator for that
21:21:15 <kmc> so it's a deficiency of the std lib
21:21:16 <mmorrow> bos: heh, pestilence!
21:21:19 <kmc> but fair enough
21:21:29 <papna> Jafet, Overloading functions is an awful idea and not one that is dynamic.
21:21:29 <bos> mmorrow: now you benchmark via this type:
21:21:39 <bos> data B a = forall b. B (a -> b) a
21:21:39 <kmc> yes, it is terrible
21:21:46 <bos> mmorrow: for pure code, that is
21:21:51 <papna> Jafet, Further, you can simulate it perfectly in Python, it's just that you don't want to.
21:21:57 <ddarius> mtnviewmark: Look at the literature on behavioral reflection.
21:22:03 <kmc> in Python you can get arg lists as first-class values
21:22:08 <crash[`]> Jafet: i fail to see how that makes it less dynamic..
21:22:18 <kmc> which is always better for the things overloading is used for, like ad-hoc poly and backwards compat of interfaces
21:22:25 <mmorrow> bos: ah, hmm
21:23:20 <papna> Python also has a feature "Picking new names for different functions" when you want backwards-compatibility of interfaces. It's really neat.
21:23:26 <kmc> indeed
21:23:27 <bos> mmorrow: it's a nicer type by far to work with.
21:23:33 <kmc> and also easy delegation of methods
21:23:46 <kmc> overloading is a disaster especially when you combine it with overriding in subclasses
21:23:48 <bos> mmorrow: since that Int was silly, and only there to fool the compiler.
21:23:57 <bos> mmorrow: i think it was copumpkin who suggested the new type.
21:24:02 <kmc> in C++ if your parent adds a parameter, your virtual override now becomes an unrelated overload
21:24:04 <bos> bless 'im!
21:24:33 <bos> we seem to have opened a black hole with discussion of dynamic languages here :-(
21:24:38 <mtnviewmark> kmc: that is one of the awful "gotchas" of C++ coding.... bites programmers all the time!
21:24:40 <kmc> it happens fairly regularly
21:24:48 <kmc> mtnviewmark, indeed
21:24:49 <mtnviewmark> sorry -
21:24:56 <kmc> at work we have a ctor with 17 boolean parameters
21:25:00 <kmc> all with defaults, some true, some false
21:25:03 <Saizan> yeah, we should enforce the strict police!
21:25:07 <mtnviewmark> I was only trying to share my rapturous conversion as it happened
21:25:20 <Saizan> discussing other langs can go to -blah, anyway
21:25:22 <mtnviewmark> I'll shuffle to the back of the temple now and beatifically smile quitely
21:25:37 <bos> :-)
21:25:51 <bos> we like the rapturous conversion part. hallelujah!
21:26:52 <kmc> praise jeebus
21:27:00 <blackdog> mtnviewmark: don't worry about it, the monks get stroppy after too much time contemplating the infinities
21:27:05 <mtnviewmark> yesterday, I wrote a 9 line function in the IO monad, and I actually felt bad --- "how can I move more of this to pure code..."  !!!
21:27:31 <mtnviewmark> kmc: praise >>=
21:27:39 <blackdog> mtnviewmark: easy, put it on a pasteboard and ask here:)
21:27:59 <mtnviewmark> (which, by the way, looks pretty much like the Amtrack logo)
21:28:05 <kmc> the old one
21:28:16 <Jafet> ..oO( @purify )
21:28:20 <mmorrow> bos: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5180#a5182
21:28:50 <mmorrow> bos: i agree, i like your new types over Int for sure
21:29:12 <mtnviewmark> blackdog - sure, it's just that two weeks ago, I wouldn't have shuddered a bit at interleaving so much IO through my code --- I do it all the time in C++ or Python!
21:29:18 <kmc> :k Any
21:29:20 <lambdabot> *
21:29:39 <mmorrow> bos: oops, meant to delete the "B" reference def at the top there...
21:30:47 <mmorrow> s/attachId/withId/
21:31:12 <mmorrow> gah
21:31:24 <mmorrow> and, .. | Id := Bench | ..
21:32:40 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5180#a5183
21:35:56 <bos> mmorrow: that's cute.
21:36:30 <mmorrow> cute minilangs ftw
21:37:18 <ddarius> Must we use circular programming even in our benchmarking suites?
21:37:22 <Saizan> positional references? eww.
21:37:43 <ddarius> Saizan: A Map could be used.
21:38:11 <mmorrow> heh
21:38:54 <mmorrow> Saizan: that was more a "oh crap, now i want to reference this, but adding another def would be ugly..err oh!"
21:38:55 <Saizan> ddarius: then you'd use strings i suspect?
21:39:36 <bos> i'm not actually doing this, by the way.
21:39:39 <ddarius> Yes.  You could make a record but that would be way overkill and Haskell doesn't have a lightweight anonymous record construct.
21:39:49 <mmorrow> bos: heh
21:40:26 <mmorrow> ddarius: yes, circular programming, especially when it's uncalled for
21:40:38 <Saizan> i'd like a syntax like this: do b1 <- "this" =: ...; b2 <- "that" =: ...; ..use b1 and b2 here..
21:41:06 <mmorrow> too bad you can't create new binding forms
21:41:09 <bos> okay, i fixed up the documentation for criterion, changed the type of B, and uploaded a new release.
21:41:14 <mmorrow> (save for with QQs)
21:41:21 <mmorrow> bos: woo
21:41:30 <bos> alas, no other shiny new changes to it.
21:41:46 <bos> but where was i? oh, i know, i was going to write benchmarks for the text library tonight!
21:41:46 <mmorrow> sometimes a spit shine is shine enough
21:42:01 <bos> first, i think, hot chocolate with some brandy.
21:42:13 <mmorrow> sounds about right
21:42:55 * hackagebot upload: criterion 0.3.0 - Robust, reliable performance measurement and analysis (BryanOSullivan)
21:43:03 <roconnor> bos: as an undergrad I found that drinking wine did not make my AI assignmentes easier to write.
21:43:08 <roconnor> and in fact made them harder.
21:43:21 <bos> i was quite astounded to find that my one-liner unicode character count was 4x faster than GNU "wc -m".
21:43:25 <roconnor> s/easier/less painful
21:43:31 <bos> roconnor: true.
21:44:11 <mmorrow> roconnor: you must not have drank enough then, duh
21:44:25 <roconnor> oh
21:44:38 <Saizan> Ballmer's peak?
21:44:39 <mtnviewmark> as an undergrad, I wrote thousands of lines of code on gin-gimlets!
21:44:52 <roconnor> Saizan: I was about to say, I must have missed Ballmer's peak :D
21:45:03 * bos hates writing benchmark code.
21:45:12 <bos> it was much more fun writing a benchmark platform.
21:46:27 <roconnor> I just finished writing the largest dependently typed function in Coq that I have written to date.
21:46:35 <roconnor> I'm starting to get the hang of it.
21:46:47 <roconnor> It must be so much easier in agda
21:48:58 <bos> "it must be so much easier in agda" denotes a very special view of the world.
21:49:17 <Saizan> i'd be interesting to compare, but i guess it uses lots of other definitions/libs?
21:49:53 <Saizan> s/i'd/it'd/
21:52:13 <ddarius> roconnor: Are you making significant use of tactics?
21:54:49 <roconnor> I was using a lot of inversion tactics
21:54:56 <roconnor> now I've rewritten it mostly by hand
21:55:52 <ddarius> roconnor: Why? (Out of curiousity.)
21:59:35 <roconnor> too hard to reason about the code generated by the dependent inversion tactics (and most tactics in general)
22:15:41 <mtnviewmark> where is a good place to start for learning about improving the execution behavior of my code (time and memory)?
22:16:00 <bos> mtnviewmark: real world haskell, most likely.
22:16:12 <mtnviewmark> heh !
22:16:22 <reltuk> @type sequenceA
22:16:24 <lambdabot> Not in scope: `sequenceA'
22:16:25 <bos> the GHC user guide is also very helpful.
22:17:15 * mtnviewmark lent his copy of RWH out.... turns to the on-line version....
22:17:22 <bos> mtnviewmark: do you have a .cabal package for your library?
22:17:35 <mtnviewmark> yes
22:17:51 * mtnviewmark uses Leksah ... so had to have one 
22:17:56 <bos> mtnviewmark: in the library stanza, add "ghc-prof-options: -auto-all" to it
22:18:16 <mtnviewmark> meaning profiling all the top level functions - or ALL the functions?
22:18:19 <bos> then make sure you're building your library with profiling enabled.
22:18:25 <bos> mtnviewmark: all the top-level functions.
22:18:31 <bos> it's a good place to start.
22:18:45 <bos> then compile your app with -prof -auto-all, and run with +RTS -P
22:18:58 <bos> then read the .prof file, and fix your code :-)
22:19:14 <mtnviewmark> is there a cabal option for "use the profiling build"?
22:19:57 <bos> profiling is selected when you're building the app, not a library.
22:20:10 <bos> so for instance, i have this in my .cabal/config:
22:20:12 <bos> library-profiling: True
22:20:25 <bos> that ensures that i never have to worry about building a profiling version of a library.
22:20:32 <bos> it doubles build times, but i don't mind.
22:20:52 <mtnviewmark> in the library specific config, or in the global config at the top?
22:20:54 <bos> i also have "documentation: True"
22:21:13 <bos> mtnviewmark: that config option is in $HOME/.cabal/config
22:21:17 <mtnviewmark> oh - er .cabal/config
22:21:20 <mtnviewmark> yup
22:21:35 <bos> the GHC profiler is a lovely thing to use.
22:22:06 <mtnviewmark> okay, so added "ghc-prof-options: -auto-all" to global area in llsd.cabal, add library-profiling: True to .cabal/config
22:22:42 <mtnviewmark> how do I get cabal build to do the profiling build?
22:22:43 <blackdog> mtnviewmark: you'll probably have to cabal install --reinstall your dependencies too
22:22:50 <mtnviewmark> view
22:22:51 <mtnviewmark> fie
22:23:29 <mtnviewmark> oh - I see "executable-profling" -- will that build every executable twice too?
22:23:41 <bos> mtnviewmark: i don't know
22:24:14 <mtnviewmark> can't I just, w/o editing my .cabal/config, get cabal to build just my package w/profiling?
22:24:22 <bos> if you have library-profiling: True, then cabal build will always do a plain build followed by a profiling build.
22:25:00 <bos> mtnviewmark: you have to "cabal configure -p"
22:25:01 <thoughtpolice> bos: woot for criterion :) benchmarking has never been so easy
22:25:07 <bos> good!
22:25:32 * mtnviewmark finds the cabal documentation a maze of twisty passages...
22:25:34 <Axman6> * on linux
22:29:08 <mtnviewmark> bah - Haskell Platform doesn't install profiling versions
22:29:16 <mtnviewmark> I suppose I could reinstall THAT
22:30:54 <bos> oh, neat! text is faster than utf8-string in my wee test!
22:31:01 <bos> i sort of wasn't expecting that.
22:36:05 <mtnviewmark> okay - so *this* part of package managment could be easier.... so not sure what to do to get my libs available for profiling
22:37:12 <bos> mtnviewmark: it's easy. "cabal install -p"
22:37:27 <bos> mtnviewmark: unless you do the $HOME/.cabal/config magic i showed earlier.
22:37:32 <mtnviewmark> but my dependencies aren't profiled and it is complaining
22:37:43 <bos> then you need to "cabal install --reinstall" those.
22:37:45 <Saizan> mtnviewmark: you've to manually recurse on your deps, for now
22:37:57 <mtnviewmark> that's the first pain (the manual recurse)
22:38:05 <mtnviewmark> the second is that some things are installed --user, some --global
22:38:17 <mtnviewmark> and the --global were installed via Haskell Platfrom
22:38:30 <mtnviewmark> not sure if my --global settings will put them in the same place
22:38:44 <mtnviewmark> and not even sure how to run cabal for --global (as I'd need admin privs.)
22:38:56 <mtnviewmark> (whcih I have, but had doing things like building as root)
22:38:56 <Saizan> cabal install --global --root-cmd=sudo
22:39:34 <mtnviewmark> er, okay...
22:39:59 <Saizan> don't ever do "sudo cabal .."
22:40:43 <mtnviewmark> ah - now I see the problem -- on a Mac, Haskell Platform puts things in places that DONT correspond to the cabal defaults for --global
22:40:58 <Saizan> that's not a problem
22:41:20 <Saizan> the libs get registered with ghc-pkg anyway
22:41:36 <blackdog> Saizan: ah, that's a useful thing to know. i assume it only uses sudo for the install step, then?
22:41:49 <Saizan> blackdog: yup
22:41:58 <mtnviewmark> right - just then I've got stuff splattered all over my disk
22:42:03 * mtnviewmark likes to keep things tidy
22:42:18 <Saizan> mtnviewmark: you can use --prefix if you want
22:42:32 <mtnviewmark> yes, I was going to do so....
22:43:05 <mtnviewmark> and I'm not even going to worry about getting the haddock all linked up for now...
22:43:37 <Saizan> (sudo cabal is a pain since sudo doesn't chage $HOME to the root one, so you get your ~/.cabal/ full of root-owned files)
22:45:45 <Saizan> an index page for all the installed haddock docs? you need the darcs version of cabal for that
22:50:12 <Saizan> (fsvo need)
23:08:42 <crash[`]> how does the local version of hoogle run on Wi?
23:08:44 <crash[`]> win*
23:10:03 <alatter> crash: neil m. wrote it, I think. He uses windows so I expect it works okay.
23:10:50 <crash[`]> alatter: i mean, does it run its own web server as a service, or?
23:11:10 <alatter> crash: ah! I've only run the command-line tool locally.
23:11:24 <alatter> crash: I don't know what specifically the website hooks into.
23:12:09 <crash[`]> oh, okay
23:12:24 <crash[`]> I didn't realize there even was a command line tool, I'm so poorly informed :)
23:12:59 <alatter> crash: I thought there was. It's been a while.
23:17:33 <crash[`]> alatter: i'm sure you're right, I just didn't know
23:18:23 <crash[`]> i'm just familiar with the hoogle site so I naiively assumed that's what it meant to install it locally
23:26:18 <omg911> is there any easy way to do binary AND on Int types in haskell?
23:26:26 <Berengal> omg911: Data.Bits
23:27:20 <Berengal> > 3 .&. 7
23:27:21 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:27:22 <lambdabot>    `Data.Bits.Bits t'
23:27:22 <lambdabot>      a...
23:27:25 <Berengal> > 3 .&. 7 :: Int
23:27:26 <lambdabot>   3
23:28:23 <omg911> Berengal: oh cool thanks!
23:28:39 <omg911> didn't know about this module
23:34:03 <Gracenotes> not the same as & or |, but the latter isn't quite available
23:35:29 <Gracenotes> unfortunately I don't think there's a way to do a logical right shift
23:36:12 <Berengal> There's shiftR and rotateR
23:36:58 <Gracenotes> former is arithmetic and, well, I suppose you could rotateR and .&. with higher bits, but.. it's just not available
23:37:12 <mtnviewmark> well, that's little help - after all that work to get the profiled libs installed...
23:37:32 <mtnviewmark> profiling shows 100% of time in MAIN and nowhere else!
23:37:48 <Gracenotes> mtnviewmark: add cost centers? (er, centres?)
23:38:18 <mtnviewmark> all the rest are 0
23:38:29 <mtnviewmark> hmmm... only 16 ticks
23:38:42 <Gracenotes> oh. maybe it's not running through it, then..
23:38:49 <mtnviewmark> seems low since it takes 4 seconds
23:39:16 <mtnviewmark> and my program produces the result indicating it has read all the test data (10k records of binary data)
23:39:58 * hackagebot upload: vector 0.4.1 - Efficient Arrays (RomanLeshchinskiy)
23:42:31 <reltuk> mtnviewmark: does it do anything with the data?
23:42:55 <mtnviewmark> yes, gathers statistics (counts of record types, etc...) and prints them out at the end
23:43:09 <mtnviewmark> which it is doing!
23:43:35 <mtnviewmark> trying 100k records now
23:44:08 <mtnviewmark> it is certainly taking long enough....
23:44:30 <mtnviewmark> (wonders if the counters in his Stats gather should be strict....)
23:46:16 * mtnviewmark watches his machine go into swapping mode
23:46:34 <reltuk> probably...otherwise they could end up as giant thunks before they start getting reduced :-p
23:48:14 <reltuk> I thought ghc switched to git...that was mistaken, huh?
23:48:43 <ddarius> reltuk: They started to but never finished and darcs got better in the meantime.
