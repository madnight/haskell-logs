00:00:21 <iaefai> never saw that function
00:00:43 <iaefai> :t intercalate
00:00:44 <lambdabot> forall a. [a] -> [[a]] -> [a]
00:00:49 <iaefai> @src intercalate
00:00:49 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
00:00:52 <c_wraith> > intercalate "/"  ["","ajax","index.html"]
00:00:53 <lambdabot>   "/ajax/index.html"
00:01:08 <cjs> luite: Well, you can just read commands from the terminal in a separate thread, but that can get output mixed up with input on the screen if output is frequent, which can be confusing to the user.
00:01:53 <iaefai> SWEET! This thing now works
00:02:02 <iaefai> What is a good place to have darcs hosting?
00:02:17 <c_wraith> patch-tag.com
00:02:41 <iaefai> Some how I find darcs slightly easier than git even with annoying questions
00:03:39 <iaefai> I just saw Saizan's name
00:03:40 <vegai> darcs is easier clearly, but with a price of being not quite as powerful
00:03:45 <copumpkin> #darcs is also a good place to hang out
00:03:46 <luite> cjs: I could  keep it in a single thread if I make the algorithm return list of each step, instead of just the final result, the user interface code would then just consume the list until it receives some command (that does assume nonblocking IO, I'm not sure if that's available)
00:03:48 <sanxiyn> Anything is easier than git.
00:03:54 <copumpkin> vegai: define power?
00:03:55 <vegai> cvs isn't :)
00:04:02 <sanxiyn> Including cvs.
00:04:03 <vegai> copumpkin: crapload of features
00:04:11 <vegai> I never got the hang of cvs, really
00:04:25 <vegai> every time it worked as I wanted, it seemed like a miracle
00:04:39 <vegai> and I'm glad I can talk about using only past tense
00:04:46 <iaefai> vegai: agreed
00:05:00 <iaefai> Last time I was using git it wouldn't properly tag things
00:06:06 <kmc> i like that "do the opposite of what cvs does" is a design principle for git
00:06:07 <c_wraith> I like how svn chose the worst possible approach to tagging.
00:06:31 <c_wraith> tagging is one of the few places svn is actually worse than cvs
00:06:48 <ibid> the answer to "can git do it?" is "yes".  the answer to "how does one make git do it?" is "i don't know"
00:06:53 <iaefai> Why did we even end up with crap like cvs as a 'standard' for a while?
00:07:07 <kmc> i don't think git is that hard.  it's based around an append-only database containing only a few types of objects
00:07:20 <ibid> iaefai: cvs was the best game in town back then
00:07:21 <kmc> there are a lot of sophisticated commands for manipulating it, but you don't need that many to get shit done
00:07:25 <blackdog> ibid: my favourite git answer is "git checkout"
00:07:35 <blackdog> the question, of course, being "How can i destroy all my hard work?"
00:08:46 <c_wraith> that's an awesome answer
00:09:21 <kmc> commit early and often...
00:09:55 <iaefai> eek ^M ^M ^M ^M
00:10:26 <iaefai> Does there exist a quick way to make sure that every file in . and below is in the repository?
00:10:45 <ibid> blackdog: :)
00:10:49 <c_wraith> for darcs?
00:10:54 <c_wraith> darcs w --look
00:11:47 <c_wraith> that actually will report any files in the whole repo directory tree that aren't in the repo.  More specifically, what you asked for would be
00:11:50 <c_wraith> darcs w --look .
00:12:34 <ibid> blackdog: how do you actually use git checkout to destroy work?
00:13:14 <sanxiyn> ibid: I think it's "git checkout ."
00:13:19 <sanxiyn> You need to put some paths.
00:13:28 <ibid> sanxiyn: yeah, that'd do it
00:13:48 <iaefai> ok, c_wraith I have M ./web/main.css -5 +20  and three lines that have 'a', does that mean I have to add those, or can I have it to do it automatically?
00:14:28 <c_wraith> iaefai:  you can pass the --look flag to the record command, too
00:14:53 <iaefai> ok, and what does 'w' mean for the long name? I am in the manual right now
00:14:58 <c_wraith> whatsnew
00:15:36 <iaefai> ok, nice
00:16:13 <iaefai> TextWrangler has a menu option called "Zap Gremlins" :P
00:17:35 <iaefai> Sweet: http://patch-tag.com/r/iaefai/chess/snapshot/current/content/pretty
00:17:41 <iaefai> THank you everyone for your help today
00:18:10 <c_wraith> you're welcome (for the bits I assisted with)
00:18:27 <iaefai> I love cabal, I wish C could be that friendly
00:18:38 <iaefai> or Make, whatever you want to say :P
00:18:46 <sanxiyn> "robot control chess project"?
00:18:59 <iaefai> yes, this thing is going to control a robot playing chess
00:19:12 <iaefai> A robotic arm that picks up pieces
00:19:27 <iaefai> It will work through a web browser and the haskell program in the web  server
00:19:49 <iaefai> The webserver works, now I have to add some ajax request handling - which will call for some json module
00:20:02 <blackdog> iaefai: i'm wrestling with nmake on Windows at the moment, and it appears to rebuild everything except the code that's actually changed
00:20:10 <blackdog> very frustrating
00:20:23 <iaefai> blackdog: I was never a fan of make
00:20:26 <c_wraith> that's an awesome optimization
00:20:34 <sanxiyn> die nmake die
00:21:32 <iaefai> The bitch of this thing is that it might be running through internet explorer
00:21:33 <blackdog> the most annoying bit is that it's building a C program with some embedded Lua, but for some reason, some parts of the Lua are compiled down to a string that the C programs gets at compile time
00:21:40 <iaefai> I might get a portable firefox going on the machine :P
00:21:48 <blackdog> so you need a full compile, just to change what's running in the interpreter
00:22:11 <iaefai> lua is evil?
00:22:18 <hiredman> that sounds horrible
00:22:24 <sanxiyn> It isn't?
00:22:32 <blackdog> not necessarily lua's fault - just the way that the program's designed
00:22:44 <hiredman> lua is neat
00:22:47 <blackdog> OTOH, you don't get any notion of threads stronger than coroutines, which is a bit awkward
00:23:05 <iaefai> blackdog: let us go back to cooperative multitasking
00:23:48 <blackdog> iaefai: indeed. it all works fine until you want to introduce a kind of event the library designer didn't account for
00:24:21 <iaefai> How about that haskell thing with 8 different methods of handling errors or something that I saw yesterday.
00:31:58 <iaefai> guten nacht
00:56:30 <shellsage> I'm trying to write a library, but when I run `cabal install --prefix=$HOME --user` I get "cabal: There is no installed version of base"
00:56:46 <shellsage> Googling for that error message didn't yield any obvious results
01:05:33 <blackh> shellsage: What does --prefix=$HOME do?
01:09:06 <fasta> Has anyone gotten Hipmunk to work on Windows?
01:16:27 <fasta> blackh, that makes sure everything is installed relative to your home dir.
01:26:57 <cjs> Hm. When I use hIsEOF on a Handle generated from a Socket via socketToHandle, after the other end has closed the Handle I get not False but an exception: "myprogram: <socket: 3>: hLookAhead: resource vanished (Connection reset by peer)". Thoughts?
01:28:15 <Botje> you can only check if a network connection is closed by trying to write to it, iirc
01:28:18 <fasta> cjs, it's just a way to encode it. It could have been done in a more functional way.
01:28:55 <cjs> Botje: not in this case. I'm reading from a socket that I've already half-closed.
01:29:20 <fasta> cjs, if you just want your program to continue, catch the exception.
01:30:34 <cjs> Grr. But that's exactly what hEOF is supposed to do! "NOTE: hIsEOF..is the same as calling 'hLookAhead' and checking for an EOF exception."
01:30:50 <cjs> I guess a network connection returns a different exception.
01:31:59 <fasta> cjs, in that case report a bug.
01:32:04 <cjs> I guess I want to be using sIsReadable.
01:32:20 <cjs> Mmm, yes, I'm thinking that it's a bug.
01:32:35 <fasta> cjs, have you already read the souce too?
01:32:41 <cjs> Yup.
01:32:46 <fasta> cjs, sometimes that helps understand what the author meant. Ok.
01:33:25 <alar> do I have a chance to catch Sigbjorn Finne here? My emails seem to can't reach him
01:33:28 <cjs> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11855#a11855
01:34:03 <cjs> So, my theory about this is that hIsEOF should deal with the "connection reset by peer"...oh, wait, hmmm.
01:34:28 <cjs> I'd better tcpdump this and make sure it really is closed at the other end, rather than reset....
01:35:10 <cjs> Oh, it is reset! It's a protocol error.
01:35:31 <cjs> Good thing I checked.
01:35:37 <fasta> cjs, to me it seems that the documentation and the code implementing it have nothing to do with eachother.
01:35:53 <fasta> cjs, in other words, a bug.
01:35:58 <cjs> In the hpaste I just posted?
01:36:04 <fasta> cjs, yes.
01:36:23 <cjs> They seem to correspond to me.
01:36:26 <monochrom> hIsEOF is not designed for sockets. In fact in some sense "test for eof" is impossible for sockets.
01:36:28 <fasta> cjs, ioError should never be called if the function only returns True or False.
01:37:06 <fasta> cjs, of course the documentation is associated with this function, it just does something else.
01:37:23 <cjs> I'm not doing it on a Socket directly, of course; I'm doing it on a Handle derived from a stream protocol socket. hIsEOF should work fine on that, since it's got, for the purposes of EOF, the same semantics as a file.
01:37:42 <cjs> Really? What does the function do that's different from the documentation?
01:38:04 <fasta> cjs, the documentation doesn't say it can throw an exception.
01:38:57 <cjs> Mmm....no...but the same is true for many other functions in this file. I would think the documentation would say if it caught errors that occur when you're not at EOF.
01:39:19 <cjs> Should, it, when not at EOF and a disk read error occurs, catch that and eval to False?
01:39:41 <fasta> cjs, good documentation encodes the exact pre and post-conditions.
01:40:33 <fasta> cjs, all these questions should already have been answered by whoever wrote the library.
01:40:38 <cjs> I think the documentation for this module would be less helpful if every function were specifically annotated as "this may throw an IOException." It's sort of taken for granted when you use IO.
01:40:59 <cjs> fasta: I believe that what it's doing is perfectly correct and obvious. My connection was reset, which is an error, and it's reporting that.
01:41:24 <cjs> (The remote end did not send a FIN, it just started sending RSTs all of a sudden.)
01:43:40 <QtPlaty[HireMe]> cjs: Could be some sort of throttling/firewall in the middle
01:44:02 <cjs> No, this is over the loopback. It's definitely me putting bugs in my own server. :-)
01:45:32 * QtPlaty[HireMe] nods
01:50:47 <dcoutts> shellsage: does ghc-pkg check report any problems for you?
01:54:36 <int-e> Mmm. How hard would it be to split Cabal's --htmldir into two flags? (It has two purposes: a) it specifies where to copy the generated haddocks, and b) the URL for links accessing the package docs.)
01:55:15 <dcoutts> int-e: how are those different?
01:55:27 <int-e> dcoutts: the latter may go through a web server.
01:56:11 <int-e> dcoutts: (in fact I want the latter to be a relative path)
01:56:39 <dcoutts> int-e: so you want to say "I'm installing the docs in /usr/local/share/blah but when you make links to docs for this package, use http://blah/blah" ?
01:56:58 <dcoutts> int-e: relative paths make some sense
01:57:08 <int-e> dcoutts: yep. and I'm aware of --html-location, but it's more of a workaround to me.
01:57:58 <dcoutts> int-e: surely the decision to link to the local or some http instance of docs is something that wants to be decided when you generate docs for the dependent packages
01:58:06 <int-e> dcoutts: absolute URLs may also make sense occasionally. in fact, it may make sense to build a package without documentation and specify an absolute URL to a known location of the docs.
01:58:38 <dcoutts> int-e: it's rather ad-hoc, perhaps just editing the package registration later makes sense
02:00:07 <int-e> dcoutts: I guess. But it would be nicer to let Cabal do that when it registers the package.
02:01:06 <dcoutts> int-e: I don't really understand the use case yet
02:05:14 <int-e> dcoutts: Well, there are two. a) what I really want is to set up docs on a web server, publicly browsable. The actual docs would reside in, say, /srv/www/haddock/<package>/... but I want URLs that resolve to http://host/haddock/<package>/... -- relative paths would be best, because they'd also work locally. But local browsing isn't imprtant, it's ok if that ends up being broken. b) what I just said, linking to external docs.
02:06:02 <dcoutts> int-e: but isn't that exactly what --html-location= is for?
02:06:06 <int-e> dcoutts: and it turns out that there's a field in the package description for that, namely haddock-html.
02:06:39 <int-e> dcoutts: --html-location only works if the scheme is completely regular. It turns out that Cabal likes to add version numbers, while ghc's installation doesn't do that.
02:06:56 <dcoutts> int-e: you can change cabal's
02:07:24 <dcoutts> int-e: and ghc-6.12 does use version numbers
02:07:25 <fasta> dcoutts: would it be possible to add a convention for the location of libraries on Windows for Haskell packages that depend on C libraries?
02:07:32 <int-e> dcoutts: and there's still the use case of having some docs linked externally and others locally, which --html-location doesn't cover.
02:07:51 <dcoutts> fasta: you can do it locally in the cabal/config file
02:08:31 <fasta> dcoutts: yes, but then others will need to have the same configuration.
02:08:48 <int-e> dcoutts: anyway. It's certainly not a high priority (editing package configurations is one way to get what I want) -- I should just submit a feature request and get working on a patch for that some time.
02:09:20 <dcoutts> int-e: yes, editing via ghc-pkg would be useful
02:09:35 <fasta> dcoutts: if people can just stick something on Hackage and have it work that help a lot. For example, I am allowed to distribute some code, but it depends on C libraries, so, if it doesn't work out of the box, it only creates irritation.
02:09:45 <dcoutts> int-e: note that it'll be relatively easy to do by hand with 6.12, they're just flat files + a binary cache to update
02:10:18 <dcoutts> fasta: does it help much? those users still have to install the C libs in the "right" place
02:11:04 <fasta> dcoutts: Some installers offer non-interactive installation, so yes.
02:11:21 <fasta> dcoutts: just having _a_ standard to point to helps a lot.
02:11:42 <cjs> fasta: So, doing a shutdown and close on the server once it sees EOF from the client fixes the problem; the client now sees hIsEOF eval to True, rather than an exception. It was a server bug.
02:11:59 <dcoutts> fasta: would it be an absolute path or relative to where you installed your ghc / haskell platform ?
02:12:15 <fasta> dcoutts: relative paths are safer I think.
02:12:28 <dcoutts> fasta: wouldn't the user have to specifically those extra C libs to just the right location?
02:12:35 <dcoutts> specifically install
02:12:46 <dcoutts> I mean it's not going to be their default install location
02:13:31 <fasta> dcoutts: yes, they would have to do that, but I expect that over time it will be easier to do some integration which automatically installs the C library too on Windows.
02:14:10 <fasta> Initially it might be quite useless, but one could say the same for an Internet with only two networks ;)
02:14:11 <int-e> dcoutts: ghc-pkg describe pkg | sed 's=^haddock-html: .*=haddock-html: ../pkg=' | ghc-pkg update -  seems to do the trick.
02:15:47 <phr> :t fix
02:15:48 <lambdabot> forall a. (a -> a) -> a
02:19:22 <Jafet> > [(m*m - n*n, 2*m*n, m*m + n*n) | n <- [1..], m <- [n+1..], mod m 2 + mod n 2 == 1, gcd m n == 1]
02:19:23 <lambdabot>   [(3,4,5),(15,8,17),(35,12,37),(63,16,65),(99,20,101),(143,24,145),(195,28,1...
02:19:37 <mux> generating pythagorean triplets?
02:19:47 <mux> sounds like project euler
02:20:01 <Jafet> This one doesn't generate all of them, even though it is correct!
02:20:19 <int-e> it generates the primitive ones
02:20:26 * mux nods
02:20:34 <Jafet> It doesn't, because n is always 1
02:20:44 <int-e> heh
02:20:57 <int-e> done properly, it would
02:21:11 <int-e> m <- [1..], n <- [1..m-1], ...
02:21:22 <Jafet> Well, this is what happens when evaluation gets in the way of math
02:21:51 <Jafet> > [(m*m - n*n, 2*m*n, m*m + n*n) | m <- [1..], n <- [1..m-1], mod m 2 + mod n 2 == 1, gcd m n == 1]
02:21:52 <lambdabot>   [(3,4,5),(5,12,13),(15,8,17),(7,24,25),(21,20,29),(9,40,41),(35,12,37),(11,...
02:23:24 <anders^^> does anyone know where MaybeT lives?
02:23:32 <Jafet> @hoogle MaybeT
02:23:33 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
02:23:52 <phr> mtl ?
02:23:53 <anders^^> that's about the only thing we found too :(
02:23:56 <Phyx-> @index MaybeT
02:23:57 <lambdabot> bzzt
02:24:29 <phr> http://hackage.haskell.org/package/MaybeT
02:25:51 <anders^^> thanks :)
02:26:46 <Phyx-> I'm trying to define a MonadIO instance , I have "liftIO = (($!) return) . unsafePerformIO" that works partially, except that exitFailure no longer quits the program
02:31:10 <Phyx-> lol, anyone?
02:31:19 <Saizan> Phyx-: argh, you're not supposed to make MonadIO instances if it requires unsafePerformIO
02:31:36 <Saizan> Phyx-: what monad are you using here?
02:31:47 * mornfall votes for Identity.
02:32:06 <Phyx-> Saizan: i figured asmuch, i know the unsafePerformIO was the problem, but i didn't know what else to use
02:32:18 <Phyx-> Either String monad
02:32:39 <Phyx-> instance i made myself
02:32:42 <Saizan> you could switch to EitherT String IO, and have a sane MonadIO instance
02:32:50 <Phyx-> heheh
02:33:06 <Saizan> actually, it's called ErrorT, iirc
02:33:13 <Saizan> ?hoogle ErrorT
02:33:13 <lambdabot> Control.Monad.Error newtype ErrorT e m a
02:33:13 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
02:33:13 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
02:33:22 <opqdonut>  /wg Lor
02:33:26 <opqdonut> woops
02:34:00 <Phyx-> oh, nice, didn't know about that, thanks Saizan
02:34:19 <Phyx-> knew the unsafePerformIO was evil there :P
02:37:43 <Saizan> np :)
02:45:28 <Jafet> > let makepyth m n = (\(a:b:c:[]) -> (a,b,c)) $ sort [m*m - n*n, 2*m*n, m*m + n*n]; ispyth m n = mod m 2 + mod n 2 == 1 && gcd m n == 1 in [makepyth m n | (n, m, _) <- [makepyth m n | m <- [1..], n <- [1..m-1], ispyth m n], ispyth m n]
02:45:29 <lambdabot>   [(7,24,25),(119,120,169),(161,240,289),(336,527,625),(41,840,841),(720,1519...
02:46:52 <fasta> How can I set haskell-program-name to an arbitrary Lisp expression in Emacs? It appears that something has changed which makes this impossible in 2.6.1.
02:47:11 <fasta> If I first load a Haskell buffer and then setq it, everything is ok.
02:47:55 <fasta> The installation instructions also appear to be incomplete as infhaskell has to be required.
02:48:34 <ziman_> @djinn (a -> b) -> ((b -> c) -> (a -> c))
02:48:34 <lambdabot> f a b c = b (a c)
02:48:47 <mmorrow> can anyone think of a problem that has a complexity of O(n^k) for k > 2 for the best-known algo, but that isn't NP-* and using heuristics (but NP-*-but-P-on-a-restricted-input-set i'm including) ?
02:49:12 <phr> what's NP-* ?
02:49:19 <mmorrow> NP-{hard,complete}
02:49:52 <Jafet> Complexity of O(n^k), where k is constant, is squarely in P
02:50:23 <mmorrow> right, but certain NP problems are P on restricted subsets
02:50:34 <phr> you mean like 2SAT?
02:50:42 <Jafet> Then those are in P...
02:50:49 <dancor> everything is P on a sufficiently restricted subset ;)
02:50:50 <Jafet> I don't understand the question
02:51:09 <mmorrow> also, approximation algos and/or heuristic algos for NP problems usually have polynomial complexity (or what's the point of approximating/using heuristics)
02:51:44 <sieni> dancor: like finite :-)
02:51:47 <phr> there is not always an approximation algo or any useful heuristic
02:51:53 <phr> that's why cryptography works ;)
02:51:55 <Jafet> dancor, let n->0
02:51:59 <fasta> mmorrow, fixed parameter complexity.
02:52:08 <fasta> mmorrow, that's how the field is called.
02:52:25 <mmorrow> Jafet: i'm trying to see whether there an algorithm that's of the best known complexity for a particular problem that isn't an approximation algo or a heuristic algo for an NP-{hard,complete} problem
02:52:39 <dancor> mmorrow: if there is an O(n^k) alg then it's automatically not NP-hard, right?
02:52:47 <mmorrow> .. that is O(n^3) or worse
02:52:57 <dancor> parsing is O(n^3) right
02:53:06 <phr> http://arxiv.org/abs/cs/0107027
02:53:15 <Jafet> Matching against a context-free grammar
02:53:17 <fasta> dancor, parsing in general is undecidable.
02:53:17 <mmorrow> dancor: right, but i also want to consider NP-{hard,complete} problems that are P on restricted inputs
02:53:25 <sieni> dancor: assuming P/=NP, yes
02:53:28 <dancor> NP-complete implies NP-hard
02:53:36 <phr> cfg with earley algorithm = O(n^3)
02:53:39 <mmorrow> dancor: ok
02:53:40 <cjs> Hey, is it reasonable that Network.Socket doesn't permit you to both bind and connect a Socket?
02:53:58 <dancor> sieni: right i guess that hasn't been proven yet
02:53:59 <mmorrow> dancor: err, but not vice-versa
02:54:10 <Jafet> mmorrow, that doesn't make sense: either a problem is in NP/P, or you redefine it so that it's in P, in which case it becomes a different problem
02:54:21 <dancor> considering NP-{hard,complete} problems is no different than considering NP-hard problems ;)
02:54:45 <mmorrow> Jafet: basically i'm trying to determine if this statement has a known counterexample :
02:54:57 <Jafet> Then prove P=NP
02:54:57 <fasta> If you can solve the NP-Complete problem, you can always solve the NP-hard problem in a polynomial factor number of steps more.
02:55:15 <phr> mmorrow, what statement?
02:55:16 <dancor> fasta: i guess i meant contextfree parsing
02:55:47 <dancor> he's typing it
02:55:50 <fasta> dancor, yes, I understood that you meant that. I just was anal about it.
02:56:05 <dancor> it's completely fair
02:56:08 <mmorrow> "if you have an algo with complexity O(n^k) for some k > 2, then either it's an NP-{hard,complete} problem and you're either (1) using an approximation algo or a heuristic algo, or (2) only considering a restricted input set, OR it has a more efficient known algorithm to accomplish the same"
02:56:20 <phr> completely wrong
02:56:26 <fasta> Oh, in fact what I said was wrong.
02:56:27 <dancor> complete
02:56:36 <mmorrow> that's the exact statement that i'm trying to put into question form
02:57:09 <phr> like, schoof's algorithm for elliptic curves is O(n**7) or something like that
02:57:18 <phr> but maybe there's better algos for that
02:57:20 <Jafet> mmorrow, are you smoking something
02:57:27 <fasta> There are bound to be problems that have been proved to be NP-Hard, but might be EXP.
02:57:28 <Jafet> It smells good from here.
02:57:40 <mmorrow> also my use of NP-hard here might be odd or redundant, since i wouldn't consider myself extremely knowledgeable in complexity theory
02:57:50 <dancor> i think there are plenty of P problems which are not know to be linear or quadratic.
02:57:53 <phr> fasta, yeah, there's some cute problems that are obviously np-hard but unknown whether they're in np
02:58:00 <mmorrow> so just replace that with what i should be saying
02:58:10 <mmorrow> dancor: right! exactly my question.
02:58:14 <dancor> yes!
02:58:18 <mmorrow> yay!
02:58:20 <mmorrow> :)
02:58:29 <dancor> i think parsing is one that's cubic
02:58:29 <mmorrow> that's a better way to phrase it too
02:58:32 <dancor> contextfree parsing
02:58:38 <mmorrow> ah, nice ok.
02:58:40 <phr> matrix determinant
02:58:54 <dancor> and i bet you can even construct things that you can prove are O(n^k) for each k!
02:58:54 <phr> modular exponentiation
02:59:05 <mmorrow> Jafet: i might be, yes.
02:59:07 <phr> well, natural problems, hmm
02:59:41 <Jafet> PRIMES is known to be in O~(n^6) (AKS), with an approximation in O~(n^(2+eps)) (Miller-Rabin), and a heuristic in O~(n^4) (ECPP). Does that answer whatever your question is asking?
02:59:45 <Jafet> s/S//
02:59:57 <mmorrow> shoop elliptic curves, CF parsing, matrix det, primes in P
03:00:03 <mmorrow> thank yous
03:00:18 <mmorrow> (i thought that primes algo was less than that)
03:00:21 <phr> http://www.springerlink.com/content/p4062562023974h5/
03:00:33 <Jafet> dancor, I bet no one knows how to do that yet
03:00:39 <dancor> maybs
03:00:43 <phr> there's gotta be tons of graph problems that are n**3 or higher
03:00:47 <phr> i'm just not up on that stuff
03:01:15 <Jafet> Given an input n and parameter k, produce n^k 1s!
03:01:31 <fasta> Busy beaver!
03:02:10 <fasta> Oh, well, maybe not every polynomial ;)
03:02:15 <fasta> very*
03:03:10 <Jafet> > fix (1:)
03:03:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:03:23 <Jafet> > fix ('1':)
03:03:24 <lambdabot>   "11111111111111111111111111111111111111111111111111111111111111111111111111...
03:03:49 <dancor> Jafet: so for any f there is a write-a-bunch-of-1s problem that is provably O(f)?
03:04:17 <Jafet> You make that sound like a problem!
03:04:35 <dancor> you make use of no. 2 pencils in your proof
03:04:44 <dancor> s/you/you may/
03:05:38 <mmorrow> interestingly it's still unknown whether graph iso is in P or NP
03:06:01 <sinelaw> graph iso?
03:06:07 <mmorrow> graph isomorphism
03:06:17 <dancor> gr is
03:06:24 <mmorrow> aka gs
03:06:27 <Jafet> Well, for any positive f, writing a fixed number of 1s is provably O(f)
03:06:27 <mmorrow> err
03:06:28 <mmorrow> gi
03:06:37 <mmorrow> ok.
03:06:42 <dancor> Jafet: ya, that settles that.
03:06:42 <mmorrow> s/ok./oh./
03:06:58 <mmorrow> i also meant to include in that "statement" the qualification
03:07:12 <dancor> that the output is O(n) or something?
03:07:21 <mmorrow> the algo that's O(n^k) for k > 3 is **provably optimal**
03:07:39 <dancor> mmorrow: we can prove optimality for the writing-1s
03:08:07 <mmorrow> oh rly
03:08:08 <Jafet> dancor, the output is O(1), which happens to be O(f).
03:08:12 <phr> provable lower bounds are hard to come by
03:10:10 <dancor> Jafet: eh, the output length depends on n..
03:10:56 <Jafet> Can't be, 'cause it's fixed, see
03:11:05 <mmorrow> hmm, are there any problems that have a known provably optimal lower bound but no known algo to achieve that? (one would think a proof would imply an algo, but i'm not sure off the top of my head)
03:11:43 <dancor> Jafet: i may not have said it right, but i feel that there is a statement which excludes our clever class of problems
03:12:35 <dancor> namely you can restrict yourself to problems where, over the range of possible instances, the outputs are not "too large" compared to the inputs
03:12:53 <Jafet> Easy way to constrain the output: yes no
03:13:10 <dancor> sure
03:13:45 <Jafet> mmorrow, it's been conjectured that there is no optimal algorithm for multiplication
03:13:56 <Jafet> Ie. it is one of those funny Blum problems
03:14:02 <mmorrow> Jafet: multiplication of what?
03:14:18 <dancor> integers?
03:14:28 <dancor> binary integers
03:14:37 <dancor> say
03:15:08 <Jafet> Numbers!
03:15:32 <mmorrow> i think the "print n^k ones" is invalid since that information can just as well be encoded like ("here are "++show n++"^"++show k  ++ " ones")
03:15:37 <mmorrow> or something along those lines
03:15:44 <MoALTz> do you mean for real numbers?
03:15:47 <Jafet> It is entirely valid
03:16:23 <Jafet> The problem says to produce n^k ones on the output stream.
03:18:45 <mmorrow> i'm not sure how to say it, but that seems to me to be a different "type" of "algorithm"
03:18:55 <mmorrow> than, say, graph isomorphism
03:19:34 <mmorrow> (where the output is an explicit representation of the iso, so the distinction not being a decision problem or not)
03:20:16 <mmorrow> well, i guess that's still kind of a decision problem
03:20:21 <mmorrow> but whatever, i'm sidetracking
03:20:30 * mmorrow resumes
03:20:51 <Jafet> By the way, I could also encode something like "Here are the factors of 7^293+1"
03:21:07 * ivanm saw someone mention graph isomorphism...
03:21:13 <ivanm> is there a new alg out or something?
03:21:24 <ivanm> oh, wait, mmorrow is just using it as an example... :s
03:21:30 <Jafet> No, we mentioned it to taunt you
03:21:46 * ivanm really should go and finish re-implementing nauty in Haskell one of these days
03:21:52 <ivanm> Jafet: :(
03:21:54 <ivanm> @slap Jafet
03:21:54 * lambdabot clobbers Jafet with an untyped language
03:21:55 <mmorrow> , [$here|Jafet: but are those the factors of $(7^293+1)?|]
03:21:55 <ivanm> ;-)
03:21:57 <lunabot>  "Jafet: but are those the factors of 410890144178860169944839701040026605...
03:22:57 <Jafet> And are those n^k ones?
03:23:18 <mmorrow> no, but that sentence contains the same information as n^k one printed out
03:23:19 * Twey suggests n^k patterns.
03:23:27 <Jafet> So did mine
03:23:33 <sinelaw> mmorrow, you wrote PerfectHash right?
03:23:38 <Jafet> It's just slightly harder to get that information.
03:23:40 <mmorrow> whereas 7^293+1 doesn't tell me the factors of 7^293+1
03:24:40 <Jafet> Tell you? What does that have to do with anything?
03:24:52 <dancor> mmorrow: not sure what you're getting at, i think the size constraint of output vs input is the critical thing
03:24:54 <Jafet> I can't tell my dog to print n^k ones.
03:25:13 <MoALTz> depends what the problem involving 7^293+1 is
03:25:18 <dancor> and looking only at decision problems is a fine way of dealing with that
03:25:24 <mmorrow> , makeMeAnO'n'k'algo n k = rnf [(i,j) | i <- [1..n], j <- [1..k]] `seq` () in makeMeAnO'n'k'algo 100000 2
03:25:25 <lunabot>  luna: parse error on input `='
03:25:30 <mmorrow> , let makeMeAnO'n'k'algo n k = rnf [(i,j) | i <- [1..n], j <- [1..k]] `seq` () in makeMeAnO'n'k'algo 100000 2
03:25:32 <lunabot>  ()
03:25:42 <mmorrow> , let makeMeAnO'n'k'algo n k = rnf [(i,j) | i <- [1..n], j <- [1..k]] `seq` () in makeMeAnO'n'k'algo 100000 10
03:25:45 <lunabot>  ()
03:25:47 <mmorrow> , let makeMeAnO'n'k'algo n k = rnf [(i,j) | i <- [1..n], j <- [1..k]] `seq` () in makeMeAnO'n'k'algo 100000 1000
03:25:53 <lunabot>  Killed.
03:25:57 <mmorrow> aww
03:26:23 <fasta> Jafet, can you explain in short what Blum exactly proved?
03:26:31 <Jafet> Oh god, apostrophes!
03:26:34 <dancor> The linear speedup theorem for Turing machines shows that the space and time requirements of a Turing machine solving a decision problem can be reduced, roughly speaking, by any multiplicative constant factor.
03:26:47 <Jafet> fasta, Blum's speedup theorem
03:27:01 <fasta> Jafet, yes, I know the name, and at some point I tried reading the paper.
03:27:15 <Jafet> Oh, I don't know the details either.
03:27:36 <fasta> Jafet, for a given machine there is a fastest algorithm, which makes it kind of a weird theorem.
03:28:15 <fasta> I only see other people refer to it, but nobody explains in his/her own words the same theorem.
03:28:18 <Jafet> He proved that there may be no fastest algorithm.
03:28:44 <Jafet> Imagine a series of algorithms whose running times converges to a limit.
03:28:51 <dancor> when there are any, there are usually (or always?) infinitely many machines that solve a given problem under a given amount of time
03:29:02 <Jafet> Shell sort may be an example.
03:29:37 <mmorrow> ivanm: hgal uses the naughty algo, but it's pretty much useless for graphs with more than 10 vertices (with a non-trivial number of edges)
03:29:49 <ivanm> mmorrow: yes, I know
03:29:59 <mmorrow> maybe even >5, i can't remember
03:30:11 <ivanm> I have sent jyp an email asking if he minded if I took over (since he's told me he doesn't care about it anymroe), with no response :s
03:30:11 <quicksilver> dancor: but the linear speedup theorem requires increasing the number of symbols
03:30:29 <dancor> Jafet: but every problem has an infimum complexity so who cares right?
03:30:31 <quicksilver> dancor: which is cheating in any natural sense of the word, since "clearly" machines with more symbols are going to be hard to build
03:31:14 <dancor> quicksilver: if you as me we should only allow two symbols
03:31:20 <mmorrow> i briefly entertained re-implementing it last week, and read half of the paper, sidetracked on computational group theory for a few hours, then determined i'm procrastinating and wasting time on a non-essential thing to what i was coding to begin with, then finally abandoned it
03:31:24 <mmorrow>  @ivanm
03:31:36 <ivanm> mmorrow: heh
03:31:41 <ivanm> I've implemented the first stage of it
03:32:10 <dancor> mmorrow: i hope you mean you adandoned the original thing, and have now dedicated your life to the tangent
03:32:23 <mmorrow> ivanm: i read through part of the nauty C code too, but not enough to tell why it can handle so much more than hgal
03:32:56 <ivanm> mmorrow: hgal fails due to data structures and by trying to be too imperative in a non-efficient fashion IIRC from when I looked at it
03:32:56 <mmorrow> ah, and browsed through the GRAPE code as well (it's a horror show)
03:33:07 <ivanm> heh
03:33:32 <mmorrow> apparently nauty can handle graphs with >1000 nodes in a reasonable amount of time
03:33:37 <ivanm> I was thinking of implementing a simpler algorithm instead (VF2 IIRC), but the description was too simple and it apparently (according to its authors) only out-performs nauty in certain sparse graphs
03:33:47 <fasta> Why doesn't (setq haskell-program-name "ghci ghci -hide-package transformers -hide-package monads-fd -hide-package mtl-tf-0.1 -ignore-dot-ghci -v0  -fno-print-explicit-foralls") and then loading a trivial module work on Windows?
03:33:49 <ivanm> mmorrow: then again, nauty has extra extensions that aren't in the paper
03:33:59 <fasta> modulo the first "ghci "
03:34:00 <ivanm> if it wasn't for the license, I'd consider just providing bindings...
03:34:11 <mmorrow> ivanm: right, i was trying to find out what exactly those are
03:34:13 <ivanm> mmorrow: though mckay is (hopefully) going to be my supervisor next year...
03:34:21 <mmorrow> ivanm: ooh, nice
03:34:24 <ivanm> so I might be able to get some sikrit info from him!
03:34:48 <fasta> The only thing that does work is (setq haskell-program-name "ghci")
03:34:52 <ivanm> "hopefully" == "I should get in to ANU, but I'm not being 100% optimistic in case something happens"
03:34:56 <mmorrow> oh hai, so tell meh teh sikrits!
03:35:07 <ivanm> fasta: hang on, I'll give you what I use
03:35:23 <fasta> ivanm, on Windows? Thanks.
03:35:31 <ivanm> no, in linux
03:35:37 <fasta> ivanm, on Linux I have no issues.
03:35:41 <ivanm> in custom-set-variables, I have '(haskell-program-name "ghci -idist/build/autogen")
03:35:49 <ivanm> fasta: ahhh
03:35:58 <ivanm> fasta: why two ghci's in there though?
03:36:09 <fasta> ivanm, I already said modulo.
03:36:16 <ivanm> ahh, that's what you meant ;-)
03:36:24 <ivanm> fasta: and maybe the ghci syntax for args is different? using / instead of - or something?
03:36:35 <sinelaw> ain't it sucky that verilog / vhdl code can be un-synthesizable? i wonder if Lava insures that your code is synthesizable
03:36:36 * ivanm vaguely recalls having to do weird things with args in windows for other things
03:36:36 <fasta> ivanm, yes, I already considered that.
03:37:00 <fasta> ivanm, even just -iC:\\ breaks it.
03:37:09 <ivanm> :o
03:38:35 <fasta> ivanm, oh, well, actually that is not true. :)
03:38:38 <sinelaw> and whether haskell's type system is strong enough to make it possible to write an EDSL that does
03:38:58 <ivanm> heh
03:38:59 <fasta> sinelaw, just use Coq if you want to do fancy stuff.
03:39:21 <fasta> And build your own Coq if you want to do really fancy stuff :)
03:39:37 <sinelaw> and build your own coq-builder if your want to do REALLY fancy stuff :P
03:40:08 <koeien> and your own coq-builder-factory if ...
03:40:08 <sinelaw> fasta, it's not so fancy, and being in haskell will give a huge advantage (haskell will be a great meta-language)
03:40:24 <zygospasm> ... you have enterprisitis?
03:40:32 <fasta> sinelaw, yes, Haskell is nice for DSLs.
03:41:20 <sinelaw> i'm so disappointed by these two highly specific language, VHDL and Verilog, which seem to miss some of the most important requirements in their own specific domain
03:41:52 <sinelaw> and i'm amazed that hardware actually exists with these horrible things
03:41:53 <jkff> So many people learn Haskell from tutorials and blogposts and (of course) get an impression that it is quite cool for easy math tasks and parsing. Then, since they're too lazy to actually try writing real code in it, they declare that although it is maybe somewhat OK for math and parsing (although of course noone would do serious math and parsing in Haskell!), it is not suitable for Real Tasks. To me that sounds like "I learnt LOGO and it turned out that
03:42:22 <jkff> programming is not suitable for real tasks".
03:42:22 <bastl> how can I load pragmas in ghci, esp. TH ?
03:43:24 <fasta> bastl, -XTemplateHaskell
03:43:57 <fasta> jkff, not really relevant in this discussion, is it?
03:44:10 <bastl> ah ok. can I do it at runtime ?
03:44:15 <koeien> bastl: :set -XTemplateHaskell
03:44:18 <bastl> ah
03:44:19 <bastl> tx
03:44:32 <jkff> fasta: You're right. I just could not resist posting this after participating in a fiery discussion of Haskell vs everything else.
03:45:10 <fasta> What Haskell needs to do to show relevance is write applications.
03:45:21 <fasta> E.g. FreeArc looks likes a real Windows application.
03:45:27 <fasta> like*
03:46:14 <fasta> Or a Ferrari with a lambda logo would also do fine for marketing.
03:46:59 <jkff> Yes :) One should stop writing tutorials on Haskell's syntax and semantics and instead start writing tutorials on "How to write an Oracle killer in Haskell" etc.,  and only give brief directions to places where to learn the syntax and semantics.
03:47:44 <bastl> how can i see the code TH actually generates ?
03:48:58 <bastl> i have a function that should produce something of type "Q [Dec]"
03:49:21 <koeien> there is an option for that, it is in the ghc manual
03:50:37 <koeien> bastl: -ddump-splices seems to be it
03:52:53 <bastl> ok, i have it. can one dump this to a file ?
03:53:43 <koeien> i don't know, would be interested in this feature as well
03:55:23 <fasta> bastl, you can also use runQ
03:55:44 <fasta> bastl, (from within ghci and then it will show automatically)
03:56:16 <fasta> bastl, there are also pretty print functions, but I am not much of a TH expert, although I am getting more confident with what is possible.
03:59:49 <fasta> Doesn -fno-print-explicit-foralls still exist?
04:03:14 <fasta> Oh, I think I know the problem. The silly length of commands limit on Windows.
04:16:55 <paolino> is there a module that maps List function in a class methods ?
04:17:33 <paolino> so I can newtype a list and derive its functionalities ?
04:17:58 <ketil> Is it possible to make GHC emit a warning on 'undefined's?
04:18:41 * ketil often uses undefined during development, but would like to be reminded about during compilation.
04:19:10 <jogla> Hello
04:19:10 <paolino> ketil, if undefined needs to evaluated , I think the program must bump there
04:19:51 <ketil> bump?  Anyway - I want the compiler to tell me (not a run time error).
04:19:59 <paolino> ops
04:20:14 <CalJohn> ketil: i'm pretty sure that -Wall will do it, but I'm not sure what the warning is called
04:20:14 <sohum> can't you just grep undefined?
04:20:37 <ketil> CalJohn, no, -Wall doesn't help.
04:20:46 <koeien> no, grepping is the way to go really
04:20:56 <koeien> otherwise, notYet = undefined, and then grep for notYet
04:20:59 <ivanm> Cale: you still around?
04:21:04 <ketil> sohum, yes I guess I can.
04:21:10 <ketil> easy to forget, though.
04:21:14 <sohum> heh
04:21:21 <sohum> the unix way!
04:21:29 <koeien> isn't there something like #warning "need to fix this"
04:21:29 <CalJohn> ketil: yes, i jsut checked, you're right :(
04:21:36 <ketil> (and of course, you might make the same argument agains -Wall -- surely you can run lint?)
04:22:02 <koeien> well, sometimes undefined is useful and you don't want a warning -- it's not like you put it there by accident
04:22:21 <CalJohn> even hlint does not pick up undefined...
04:22:36 <Jafet> What does undefined do when evaluated?
04:22:55 <CalJohn> crashes the program
04:23:03 <koeien> throws an exception
04:23:14 <koeien> you can catch it in IO, but it's not pretty generally
04:23:18 <Jafet> So run unit tests, catch the exception.
04:24:26 <quicksilver> I don't think any serious program should ever use undefined
04:24:42 <quicksilver> it's always preferable to use (error "some descriptive text reminding why this is undefined")
04:25:23 <Jafet> Be glad that Haskell is old enough to have legacy code in it!
04:27:21 * EvilTerran only uses undefined in casual code, in place of (error "This should never be evaluated - the impossible has happened!")
04:27:52 <koeien> well, but then it's better to have the function there anyway
04:27:57 <koeien> unless it's a one-page script
04:28:04 <quicksilver> (error "my radiator is full of jam")
04:28:16 <koeien> like error "myOwnUnsafeHead: called with []"
04:29:17 <eevar2> as for legacy code. will haskell 2010 break backwards compatibility for more consistency?
04:29:33 <eevar2> library-wise
04:29:45 <koeien> does haskell' have a new name?
04:30:27 <quicksilver> eevar2: it's quite likely it will break it in some small ways, yes
04:30:40 <quicksilver> eevar2: like, removing the monomorphism restriction by default
04:31:10 <idnar> what is Haskell 2010 now?
04:31:22 <idnar> like Haskell' except useful?
04:31:54 <quicksilver> it's a phrase that eevar2 just made up.
04:32:01 <quicksilver> if I'm not mistaken
04:32:03 <idnar> heh
04:32:15 <quicksilver> I am mistaken.
04:32:25 <quicksilver> it's a milestone in the haskell' trac
04:32:31 <quicksilver> http://www.haskell.org/pipermail/haskell-prime/2009-July/002812.html
04:33:41 * Phyx- just wants them to fix a bug he's been waiting on for ages now
04:33:55 <Phyx-> milestone set to 9.12 but somehow i don't see that happenening
04:34:03 <jogla> I have an exercise in Haskell I don't understand
04:34:25 <koeien> jogla: sure, what is it?
04:34:37 <jogla> I have to define a class Polynomial that can be a Const (Int), a Var (String), or both combined via * or +
04:34:41 <jogla> So i wrote the following
04:34:51 <jogla> data Polynomial = Const Int | Var String deriving Show
04:34:56 <jogla> That's the first part
04:35:25 <jogla> But I can't add anotehr like "Polynomial Polynomial * Polynomial
04:35:33 <jogla> nor can i write a function that combines them
04:35:36 <koeien> you can
04:35:48 <jogla> Can you give me a hint?
04:35:54 <koeien> data Polynomial = Const Int | Var String | Mult Polynomial Polynomial -- something like this
04:36:08 <jogla> Ahh
04:36:11 <jogla> Thanks!
04:36:17 <koeien> you can also pick :*:
04:36:28 <koeien> data Polynomial = Const Int | Var String | Polynomial :*: Polynomial
04:36:48 <koeien> and similar for the sum of two polynomials
04:36:59 <koeien> but depending on the task at hand, this might not be the best representation
04:36:59 <jogla> ahh, that's cool
04:37:27 <Jafet> Usually a polynomial is represented as a truncated power series
04:37:40 <Jafet> A univariate one, that is
04:38:00 <koeien> Jafet: yes, this the usual way
04:38:21 <koeien> jogla: you mentioned "class" by the way, what you mean is "ADT" or "data type"
04:38:29 <ivanm> quicksilver: would you be able to proof-read my paper for PEPM to make sure I get the Haskell stuff right?
04:38:30 <quicksilver> koeien: if the task at hand is to answer the exercise that jogla has been set, than this probably is the right representation :)
04:38:42 <koeien> jogla: a "class" in Haskell also exists, but is different
04:38:56 <quicksilver> ivanm: I'll try to find time, yes
04:39:05 <jogla> Ahh, the exercise says "data structure"
04:39:09 <ivanm> quicksilver: want me to email it or upload it somewhere?
04:39:18 <koeien> jogla: yeah, that's this
04:39:33 <jogla> Thanks
04:41:41 <ivanm> @tell dibblego http://forums.whirlpool.net.au/forum-replies.cfm?t=1311734
04:41:42 <lambdabot> Consider it noted.
04:44:54 <quicksilver> ivanm: email is fine
04:53:57 <jystic> Is there a way to force the screen to be repainted when using gtk2hs? I'm updating a horizontal scale at 20Hz but it's only being re-rendered at 1Hz.
04:54:34 <dcoutts> jystic: it gets repainted whenever the gtk event loop is idle
04:55:14 <jystic> hmm, it's weird because when I move my mouse back and forth across it quickly it does indeed repaint faster
04:55:27 <dcoutts> jystic: 1Hz is about 10x more than you can visibly detect anyway isn't it?
04:55:27 <jystic> but if I just leave it, it's only once a second
04:55:41 <jystic> 1Hz = once per second
04:55:42 <dcoutts> oh sorry, wrong order of mganitude
04:55:45 <jystic> yeah
04:55:47 * dcoutts misread
04:55:56 <jystic> that's cool
04:56:04 <dcoutts> jystic: perhaps you're blocking the event loop then
04:56:31 <jystic> hmm, that's no good
04:56:42 <jystic> I have no idea how to debug that
04:57:02 <dcoutts> jystic: it's mostly a matter of looking at the code
04:57:42 <dcoutts> jystic: how are you doing the updates?
04:57:51 <ivanm> quicksilver: sent; there's not that much of a rush (I have until Monday to send the final submission)
04:58:02 <ivanm> so whenever you've got time over the next few days
04:58:30 <jystic> dcoutts: I have another thread running which sleeps for 10ms then advances a simple simulation, updating a TVar as it goes
04:59:07 <jystic> dcoutts: then I have a "timeoutAdd" calling me back every 25ms
04:59:12 <dcoutts> jystic: ok so you're using forkIO, are you using the single or multi-threaded rts?
04:59:25 <jystic> dcoutts: which reads from the TVar
04:59:42 <jystic> I'm just using runghc at the moment
05:00:09 <dcoutts> jystic: so you must be using unsafeInitGUIForThreadedRTS then?
05:00:15 <jystic> dcoutts: yep
05:00:22 * dcoutts does not recommend that
05:00:26 <jystic> dcoutts: and i'm using postGUIAsync
05:00:32 <jystic> ok :)
05:01:02 <jystic> is that my only option if I want true multithreading?
05:01:25 <dcoutts> jystic: no, I use the single threaded rts and forkIO
05:02:06 <jystic> dcoutts: so forkIO will still allow for the use of multiple cores, even on the single threaded rts?
05:02:27 <SamB_XP> dcoutts: what's wrong with using gtk2hs in the multithreaded RTS as long as you're careful to use one specific forkOS'd thread for all calls into gtk2hs ?
05:02:28 <dcoutts> jystic: no, not multiple cores, multiple lightweight threads
05:02:41 <dcoutts> SamB_XP: getting it right is hard
05:02:46 <SamB_XP> well, yeah
05:02:51 <dcoutts> SamB_XP: and there's a bug with finalisers
05:02:52 <SamB_XP> true
05:02:58 <SamB_XP> dcoutts: bug in which ?
05:03:07 <SamB_XP> GHC RTS ?
05:03:10 <dcoutts> http://haskell.org/gtk2hs/archives/2009/11/04/writing-concurrent-programs/
05:03:20 <jystic> dcoutts: so if I want to use multiple cores, then I don't have a choice?
05:03:24 <Vanadium> The specific thread that is allowed to call into gtk is the one that is blocking on mainGUI, right?
05:03:33 <dcoutts> jystic: but none of this explains your issue
05:03:40 <jystic> dcoutts: nope :)
05:04:06 <dcoutts> jystic: so you're updating the gui by setting a property of a widget right? not doing any custom drawing
05:04:13 <jystic> dcoutts: yep
05:04:22 <jystic> dcoutts: running on the single threaded rts causes the widget to not be updated at all
05:04:47 <dcoutts> jystic: yes, you need to use the cooperative scheduling trick when you use the single threaded rts
05:04:54 <dcoutts> it's just one line of code
05:05:02 <jystic> timeoutAddFull (yield >> return True) priorityDefaultIdle 100 ?
05:05:08 <SamB_XP> dcoutts: trick ?
05:05:10 <dcoutts> right
05:05:40 <dcoutts> Vanadium: yes
05:05:45 <SamB_XP> why do you need to use some "cooperative scheduling trick"?
05:06:33 <dcoutts> SamB_XP: because you're running a thread scheduler (ghc rts) and a GUI event loop in a single OS thread
05:06:38 <jystic> If I do that, I can see that the other thread runs (doing putStrLn), but the widget doesn't update at all now, unless I mouse over it, then it repaints
05:07:22 <SamB_XP> dcoutts: oh, yeah. Can't I just import some gtk2reactor from twisted.internet.reactor or something ?
05:07:54 <dcoutts> SamB_XP: gtk event loop is very flexible, it's the ghc rts one that is not
05:08:10 <SamB_XP> yeah, I know
05:08:31 <SamB_XP> I was just complaining about how it's so wired-in and not pluggable like it ought to be ;-P
05:08:55 <SamB_XP> you didn't understand that bit about gtk2reactor/twisted ?
05:09:20 <Vanadium> I would really be tempted to try to use multiple proper threads rather than this cooperative multitasking thing
05:09:28 <dcoutts> SamB_XP: I'm not sure I know what you were getting at
05:09:49 <dcoutts> Vanadium: sure, that's the better solution in the end, but has it's own set of problems to be overcome
05:10:08 <dcoutts> jystic: what are you actually setting?
05:10:21 <SamB_XP> dcoutts: well, I was pretending to get Concurrent Haskell mixed up with Twisted (you know, the Python async framework?)
05:10:31 <jystic> the value of a horizontal scale
05:10:37 <SamB_XP> surely it's a frequent mistake
05:10:44 <Vanadium> (so far i have not gotten around to doing something with gtk2hs at all because every time I do, everything is so different from what I am used to and aaah)
05:10:57 <jystic> i'm just doing a git commit to github so you can see the file directly, probably easier
05:11:16 <SamB_XP> dcoutts: anyway, the event loop of Twisted is called a reactor
05:11:27 <SamB_XP> and there are actually more than one of them
05:11:50 <dcoutts> isn't twisted just to make up for python's lack of proper (lightweight) threads? :-)
05:12:11 <Saizan> btw, what forces the C gtk to be so anal about threads? the kernel? other libs? or is that just how you do it in C?
05:12:12 <Botje> i thought event loop servers were more efficient than threaded ones?
05:12:18 <SamB_XP> dcoutts: in a way
05:12:34 <Botje> Saizan: i'd guess internal locking and stuff.
05:12:45 <SamB_XP> but if Python had those, it would probably have the same problem as GHC ;-P
05:12:51 <Saizan> Botje: that depends on the kind of threads
05:12:59 <Vanadium> The C API takes the gdk locks every time it runs one of your callbacks
05:13:03 <dcoutts> Saizan: a few things: each widget is a mutable object, you don't want to update them concurrently without locking, but locking on each method is expensive
05:13:11 <Vanadium> so the C advice is "only call gtk from one thread OR take the locks manually from other threads
05:13:14 <Vanadium> "
05:13:39 <Vanadium> since the one thread is under control of the gtk mainloop anyway and it can make sure the locks are in place when your code is called
05:13:47 <dcoutts> Saizan: then X11 is a little hairy to use from multiple threads properly, not impossible but the C widget toolkits don't make it easy (and there's no great benefit to doing so)
05:13:47 <jystic> dcoutts: here http://github.com/jystic/lambdasim/blob/master/Main.hs
05:13:51 <Vanadium> It does not really translate that well into Haskell's funny non-OS thread thing
05:13:58 <SamB_XP> anyway, Twisted has the basic select(2)-based reactor, an epoll reactor, I think something called iocpreactor ...
05:14:28 <dcoutts> Saizan: and lastly, win32 GDI has very very strict threading requirements. GDI objects can only be accessed from their creating thread.
05:14:29 <SamB_XP> ... some reactor that's good for win32, and some reactors for specific GUI frameworks like GTK and Qt
05:14:30 * quicksilver always uses the threaded RTS with openGL which I beleive has the same issue
05:14:38 <quicksilver> oops, scrolled up somewhat
05:14:42 <quicksilver> but maybe it's still relevant.
05:14:43 <SamB_XP> dcoutts: whoah, anal!
05:14:50 <SamB_XP> I didn't know that!
05:14:52 <jystic> dcoutts: be nice, i'm only a newbie :) any tips on style/stupid things i'm doing would be appreciated though :P
05:14:54 <quicksilver> I just don't make any GUI calls from the non-main thread.
05:15:29 <SamB_XP> probably because I don't write any GDI code and haven't reversed that much of it yet ;-P
05:15:41 <Saizan> dcoutts: so a bit of 2 and 3 :)
05:16:22 <quicksilver> Vanadium: well "haskell's funny non-OS thread thing" does have the property that the main thread is guaranteed to be the main thread.
05:16:45 <quicksilver> Vanadium: so it's always safe to call the GUI code from (a) only the main thread and (b) callbacks the GUI library sends you, since they run in the main thread too.
05:18:21 <SamB_XP> well, I believe in my app I forkOS off a thread to be the GUI thread, and then send all things for the GUI to deal with through a Chan
05:18:42 <SamB_XP> those things that require a response from the GUI thread include an MVar to post the response to
05:18:58 <quicksilver> yeah, that's the general pattern I use too.
05:19:03 <quicksilver> only I don't forkOS
05:19:05 <quicksilver> I just use the main thread
05:19:07 <quicksilver> since that's bound anyway
05:19:26 <SamB_XP> it's possible that that's what I do
05:19:33 <mr_ank> interestingly, that's the same pattern used in a few other GUI toolkits - in java and c++
05:19:37 <srush> this is kind of a n00b question
05:19:57 <mr_ank> even in the iphone you have to be careful
05:20:00 <srush> if I have newtype Foo a  = Foo a
05:20:02 <SamB_XP> I haven't looked at my code lately since I was frustrated that I couldn't figure out how to get a guarenteed monospace font or plain vanilla character-matrix widget
05:20:18 <srush> and I know a is always (Show a)
05:20:33 <srush> is there anyway I can get away from writing that everywhere
05:20:38 <SamB_XP> mr_ank: well, it's all because the C GUI libs are so anal :-(
05:20:48 <SamB_XP> I mean, in our case
05:20:50 <Saizan> srush: let ghci infer the types for you :)
05:21:19 <srush> but on new instances for Foo
05:21:28 <srush> I always need (Show a) => Foo a
05:21:40 <mr_ank> SamB_XP: i'm looking to build a commercial product. I was going to use c++ but i think i'll use haskell
05:21:44 <Saizan> you mean typeclass instances?
05:21:47 <srush> yeah
05:21:50 <mr_ank> it has to have a UI etc ... we'lll see what happens
05:21:54 <CalJohn> Saizan: make Foo a an instance of Show
05:22:06 <fadax> hi
05:22:16 <SamB_XP> CalJohn: I think you misread ?
05:22:18 <Axman6> 'lo fadax
05:22:18 <Saizan> CalJohn: that won't help much
05:22:35 <quicksilver> I think the short answer, srush, is "no".
05:22:36 <fadax> how can i convert a string to a function? for example if i have the string "*" how can i convert this to the multiplication function ?
05:22:41 <Vanadium> SamB_XP: What language GUI libs do you prefer? :S
05:22:49 <SamB_XP> srush: so what's the problem again ?
05:22:54 <quicksilver> class constraints on tpes don't really work in haskell98
05:22:59 <quicksilver> in GHC + GADTs you can get something working
05:23:04 <quicksilver> but I'm not entirely convinced it's wise.
05:23:09 <SamB_XP> Vanadium: I'm not saying I prefer anything, just that it wasn't our idea to be so anal about threads ;-P
05:23:11 <xian> fadax: You can't.
05:23:16 <srush> hmm
05:23:21 <SamB_XP> but merely an inherited restriction
05:23:21 <srush> I'd like to try
05:23:24 <Saizan> but only if you get Foo a as an argument, not if it's a result
05:23:57 <srush> it's just so annoying to change this one constraint and have to update all the other instances
05:24:00 <CalJohn> SamB_XP: yeah, i think I did...:/
05:24:20 <Axman6> fadax: you can parse the string, and see if it's something you know should be turned into a function, like if you get a "*", you know that has to become (*), but it's not very general...
05:24:27 <int-e> @type \x -> lookup x [("+",(+)), ("-",(-)), ("*",(*))]
05:24:29 <lambdabot> forall a. (Num a) => [Char] -> Maybe (a -> a -> a)
05:24:37 <Vanadium> SamB_XP: But requiring people who call into your library from other threads to lock a mutex seems pretty reasonable...
05:24:50 <zygospasm> srush: "data Foo a = (Show a) => Foo a". However, you'll need either ExistentialQuantification or GADTs enabled for that to be accepted.
05:24:51 <fadax> oh ok  thanks
05:25:07 <zygospasm> srush: whether you /should/ do this is another matter ;-)
05:25:15 <Saizan> or, if you want to interpret general haskell code, you can use hint or the ghc-api, but not sure if it applies here
05:25:35 <srush> zygospasm: I tried that, but I still needed (Show a) on the instance
05:25:44 <srush> what did I do wrong?
05:25:52 <fadax> int-e how did that work? you are looking  up x but x doesn't appear n the list ?
05:25:56 <fadax> in*
05:25:57 <Axman6> fadax: what we should be asking you is why you need to do that, so we can give you a better answer
05:26:00 <zygospasm> srush: you probably put the context on the LHS of the =?
05:26:08 <quicksilver> zygospasm: it's accepted by some versions of GHC in a fairly buggy and inconsistent way.
05:26:09 <Axman6> fadax: do you know the Maybe type?
05:26:16 <int-e> fadax: x is a variable bound by the \x ->  in front. (read \ as lambda)
05:26:16 <Axman6> @src Maybe
05:26:19 <quicksilver> zygospasm: (with no extensions on, I mean)
05:26:19 <lambdabot> data Maybe a = Nothing | Just a
05:26:40 <int-e> > (\x -> x + x) 4 -- equals 4+4
05:26:41 <lambdabot>   8
05:27:19 <fadax> oh  ok thanks
05:27:29 <fadax> i know the maybe type
05:28:46 <srush> actually, in a simpler example that worked
05:28:49 <srush> why is that bad?
05:36:31 <fadax> int-e in that list of strings and functions what is the type of each function?
05:36:38 <fadax> like (*)
05:36:52 <Saizan> ?type (*)
05:36:53 <lambdabot> forall a. (Num a) => a -> a -> a
05:37:15 <fadax> oo ok  thanks
05:37:30 <int-e> fadax: they all have the same type.
05:38:00 <Axman6> @src Num
05:38:01 <lambdabot> class  (Eq a, Show a) => Num a  where
05:38:01 <lambdabot>     (+), (-), (*)           :: a -> a -> a
05:38:01 <lambdabot>     negate, abs, signum     :: a -> a
05:38:01 <lambdabot>     fromInteger             :: Integer -> a
05:39:25 <fadax> ok so if i want to make a function list as a constant
05:39:28 <zygospasm> quicksilver: what sort of bugs? i've done a little playing and it seems to behave as i'd expect in GHC 6.10.4
05:39:36 <fadax> can i do  fList :: [ (String, a -> a -> a) ]
05:40:19 <fasta> fadax, I don't see why not.
05:40:23 <zygospasm> quicksilver: or do you mean that some versions of GHC accept it without -XExistentialQuantification but it doesn't work properly then?
05:40:39 <Axman6> fadax: you won't be able to put (*), (+) etc in there though
05:40:49 <fasta> fadax, it is kind of pointless to have a function of type a -> a -> a, though.
05:40:51 <Axman6> because they don't have the type a -> a -> a
05:40:57 <Axman6> :t id
05:40:59 <lambdabot> forall a. a -> a
05:41:06 <Axman6> wait
05:41:10 <fasta> :t const id
05:41:10 <Axman6> ok, well, not id
05:41:11 <lambdabot> forall a b. b -> a -> a
05:41:24 <fasta> :t const id :: a -> a -> a
05:41:25 <lambdabot> forall a. a -> a -> a
05:41:33 <zygospasm> @type [("a", const), ("b", flip const)]
05:41:34 <lambdabot> forall a. [([Char], a -> a -> a)]
05:41:53 <quicksilver> zygospasm: the bugs were in 6.6 and/or 6.8
05:42:02 <zygospasm> ah, that explains it :)
05:42:02 <fadax> i don't understand.. when i try fList = ("+", (+)) : ("-", (-)) : ("*", (*)) : []
05:42:02 <quicksilver> zygospasm: and the bugs were in deviation from haskell98
05:42:05 <fadax> it gives an error
05:42:10 <fasta> 6.10.4 is quite nice for actual Haskell.
05:42:13 <quicksilver> zygospasm: and this isn't an existential, because there is an "a" on the left.
05:42:26 <fadax> cannot justify constraints in explicitly typed binding
05:42:29 <zygospasm> quicksilver: no, but the ExistentialQuantification extension allows it anyway it would seem
05:42:29 <fasta> Outside of unsupported features, that is.
05:43:52 <Axman6> fadax: have you also written a type signature?
05:43:56 <zygospasm> @type [(("+"), (+)), ("*", (*))]
05:43:57 <lambdabot> forall a. (Num a) => [([Char], a -> a -> a)]
05:44:21 <Axman6> because if you've written [(String,a->a->a)], then that's wrong
05:44:36 <Axman6> it needs to be Num a => [(String, a->a->a)]
05:45:37 <fadax> ooh
05:45:50 <fadax> oops, it works now.. thanks
05:48:02 <dcoutts> jystic: ok, I think it's just rather odd. It appears that setting the range value does not immediately queue it to be redrawn. I do not know why. You can force it to redraw using widgetQueueDraw headingScale. It smells like weird gtk+ behaviour to me. I can see the code for it in the gtk+ source but that doesn't give a good explaination.
05:48:28 <jystic> dcoutts: thanks, i'll give that a try
05:48:36 <jystic> dcoutts: i found something interesting
05:48:54 <jystic> dcoutts: if I make the size of scale really large, it redraws more often
05:49:28 <jystic> it's almost like it's a "feature", not updating the UI if the slider wouldn't have moved much on the screen
05:49:34 <quicksilver> sounds like some "optimisation" they added to prevent excessive redrawing
05:49:45 <quicksilver> perhaps some other gtk component alters that too often and caused flickering
05:49:48 <dcoutts> jystic: that makes a little sense, the C does calls gtk_range_calc_layout then only if the range->layout changed does it queue a redraw.
05:49:56 <quicksilver> so they hacked in a limiter
05:50:06 <dcoutts> jystic: and gtk_range_calc_layout is a big complex function
05:50:45 <dcoutts> jystic: a range is not normally an output widget, you might want to consider something else
05:50:48 <jystic> dcoutts: if I make my window really small (and hence the scale is only 10px wide) it doesn't update at all
05:51:27 <jystic> dcoutts: i think it fits my scenario, the user can change the heading of the vessel with a slider, but they can also change the rudder which changes the heading over time
05:53:21 <dcoutts> jystic: ok, so just stick widgetQueueDraw headingScale into your onRangeValueChanged headingScale handler
05:53:45 <jystic> dcoutts: works perfectly! thanks so much for looking in to it for me!
05:54:13 <dcoutts> jystic: ta for posting the code, much easier to debug that way :-)
05:54:30 <jystic> dcoutts: no problem :)
05:54:38 <dcoutts> it's quite handy that github lets you download a tarball
05:54:47 <dcoutts> no need to install git :-)
05:54:52 <jystic> haha
05:54:57 <sinelaw> github is cool.
05:55:09 <sinelaw> best online vcs i know of
05:55:28 <jystic> it's useful at work, we're stonewalled behind a http with a username/password
05:55:40 <sinelaw> for the only reason that's it's so damn simple to use, especially create new repos
05:55:44 <jystic> http proxy*
05:56:02 <sinelaw> what does an http look like? :)
05:56:46 <jystic> i don't know, but it sure is slow :)
05:59:15 <sinelaw> http://static.howstuffworks.com/gif/willow/sloth-info0.gif
05:59:36 <sinelaw> Title: HTTP
05:59:46 <jystic> haha
06:04:26 <jogla> Do you know what this means when defining a custom show function:
06:04:29 <jogla> Equations give different arities for "show"
06:04:50 <byorgey> jogla: every equation in your definition must have the same number of arguments
06:05:19 <jogla> ohh
06:05:46 <jogla> But, what if that doesn't fit to my data structure?
06:05:51 <quicksilver> it does.
06:05:59 <quicksilver> just remember to put your constructors in parens
06:06:03 <quicksilver> (which is where they need to be)
06:06:16 <Axman6> jogla: the arity of a function is how many arguments it takes in, just so you know
06:06:17 <byorgey> show (MyConstuctor x y) = ...
06:06:18 <jogla> ahh, ok
06:06:24 <quicksilver> show (Bar a b) = "Bar " ++ show a ++ " " ++ show b
06:06:30 <jogla> ahh, thanks, i wondering what that means
06:06:37 <fasta> The error message is also slightly misleading.
06:06:39 <quicksilver> jogla: although most of the time, you just use 'deriving Show'
06:06:43 <Axman6> jogla: i take it you're new to haskell?
06:06:53 <quicksilver> jogla: which writes the show instance automatically and painlessly.
06:07:19 <fasta> f Nothing = 1;f = \x -> x is wrong for example.
06:07:50 <jogla> Axman6: yes
06:07:57 <fasta> Oh, of course the types only match for a crazy num instance, but otherwise it is correct.
06:07:58 <jogla> quicksilver: yes, i know
06:08:16 <Axman6> jogla: well, stick around here, and ask questions! there's plenty of people who'll be willing to help you :)
06:08:16 <saml> hello
06:08:24 <jogla> Thanks :)
06:08:29 <saml> you're welcome!
06:08:34 <byorgey> hey saml
06:08:35 <byorgey> hehe
06:08:48 <Axman6> jogla: #haskell is imo, _the_ best resource for haskell newbies
06:09:10 <saml> yah a bunch of kanye west who will let you finish.. but we answer before you even finish your question!
06:09:57 <yrlnry> is it naughty to create a Monad instance for which >>= always yields  _|_?
06:10:14 <Vanadium> Axman6: But you cannot print it out and take it with you to the workplace :<
06:10:23 <saml> so the monad will only allow one command yrlnry ?
06:10:33 <saml> that sounds like SingletonPattern
06:10:40 <fasta> Ok, my turn: ~/AppData\Roaming\cabal\Codec-Image-DevIL-0.1\ghc-6.10.4/libHSCodec-Image-DevIL-0.1.a(DevIL.o):fake:(.text+0x121a): undefined reference to `ilDeleteImages@8'
06:10:47 <fasta> Does this ring any bells?
06:11:03 <fasta> It's during cabal build.
06:11:10 <yrlnry> it does satisfy the required laws,
06:11:10 <Axman6> hmm, i must be tired, i read that as "does that wring my balls?"
06:11:14 <saml> fasta, whichi package is it?
06:11:26 <yrlnry> Well, what I'm really thinking about is a Comonad instance for [].
06:11:29 <fasta> saml, my own.
06:11:32 <Axman6> so, goodnight all
06:11:43 <yrlnry> But you can't define a Comonad instance for [] unless you allow functions that sometimes fail.
06:11:58 <yrlnry> Because there's no extract :: [a] -> a.
06:12:05 <dcoutts> fasta: ccall vs stdcall?
06:12:29 <fasta> dcoutts: could be, but I believe the library was already generalized for that.
06:12:42 <fasta> dcoutts: on Windows I use stdcall.
06:13:15 <dcoutts> fasta: and you're sure that the C lib does too? It's not actually the standard calling convention on Windows.
06:14:08 <fasta> dcoutts: No, I am not sure about that. Is there a DLL dumper or anything like that?
06:14:17 <koeien> the SDK has one iirc
06:14:21 <dcoutts> fasta: nm might do it
06:14:30 <dcoutts> fasta: the .h files will also say
06:19:25 <ski> yrlnry : yes
06:19:52 <ski> `return () >>= id' should be `()'
06:19:58 <fasta> dcoutts: there was an indirection and it seems that it is __stdcall. nm doesn't support it.
06:20:16 <ski> er
06:20:34 * ski didn't think that through
06:20:54 <saml> > return () >>= id
06:20:55 <lambdabot>   Couldn't match expected type `m b' against inferred type `()'
06:21:04 <fasta> dcoutts: but I installed the binary distribution of the library, so I don't know what the distributor did. Must be somewhere in the documentation... :/
06:21:21 <jmcarthur_work> yrlnry, your proposal would not satisfy the laws, i think
06:21:29 <ski> yrlnry : does `m a' every contain a proper (non-`_|_') value, for your `m', for any `a' ?
06:21:31 <jmcarthur_work> oh it's been said by now
06:21:35 <jmcarthur_work> i was scrolled up, sorry
06:22:07 <ski> s/every/ever/ (brain switched words under me !)
06:22:15 <yrlnry> sorry, I;m not sure now whether we're talking about Monad or Comonad.
06:22:22 <ski> `Monad'
06:22:24 <jmcarthur_work> they both have similar laws
06:22:50 <yrlnry> Oh, I see.  return . join = id will fail if  either is allowed to _|_.
06:22:57 <yrlnry> Sure.
06:23:06 <ski> yrlnry : not if `_|_ = id', though
06:23:20 <yrlnry> right, but that's totally degenerate.
06:23:26 <ski> (which it is for the empty type, ignoring `seq')
06:23:54 <ski> (so .. is your type empty ?)
06:24:15 <ski> or maybe i should ask what your type is ?
06:24:34 <yrlnry> Well, as I said, what I'm really thinking about is instance Comonad [].
06:24:57 <yrlnry> But I conclude that there isn't one, since there's no extract :: [a] -> a.
06:25:01 <ski> you can make a `Comonad' instance for `Stream' were `data Stream a = Cons a (Stream a)'
06:25:09 <yrlnry> Yes.
06:25:14 <knobo> Why does let perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])] just return [] when I call the function like this: perms [1, 2, 3, 4] ? is it the wrong way of calling it?
06:25:25 <ski> also, there's one for potentially-finite streams
06:25:54 <int-e> knobo: what's the base case?
06:25:56 <koeien> knobo: what is perms [] ?
06:26:06 <ski> > let perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])] in perms []
06:26:07 <lambdabot>   []
06:26:08 <knobo> it makes permutation of a list
06:26:18 <int-e> mm. oh.
06:26:29 <int-e> right, there is no base case, so perms [] = [], which is wrong
06:26:36 <koeien> knobo: try to understand why perms [1] fails
06:27:33 <ski> knobo : possible help : define `select :: [a] -> [] (a,[a])' which return every way of selecting one element from a list
06:27:57 <int-e> ski: that won't help with this particular problem
06:28:04 <koeien> ski: that is not the problem here, right?
06:28:04 <ski>   select [0,1,2,3] = [(0,[1,2,3]),(1,[0,2,3]),(2,[0,1,3]),(3,[0,1,2])]  -- e.g.
06:28:23 <int-e> ski: in fact we can implement the same thing with select and it will still return empty lists.
06:29:48 <ski> int-e, koeien : *nod*, the problem here was having no base case, as you said. i just wanted to avoid the atrocious `xs\\[x]'
06:30:23 <int-e> ski: but your select is O(n^2) as well ;)
06:30:50 <int-e> (assuming an Eq instance and constant time comparison)
06:31:00 <koeien> why would you need Eq ?
06:31:09 <knobo> I know it is not the best way. I found the example here: http://www.haskell.org/pipermail/haskell/2006-July/018298.html
06:31:37 <int-e> koeien: I need Eq or I'd be comparing apples and oranges - an implementation that works with another that doesn't.
06:31:40 <knobo> I'm just trying to learn haskell, and I'm just trying to understand simple examples.
06:31:41 <koeien> knobo: yeah, Sebastian forgot the base case there
06:31:58 <knobo> what do you mean by "base case"
06:31:59 <ski> btw, does knobo want `perms [0,0,1] = [[0,1],[0,1],[1,0]]' ?
06:32:14 <koeien> knobo: the case perms []
06:32:18 <ski> knobo : tell us the list of all permutations of the empty list ?
06:32:50 <int-e> > [1,1] \\ [1]
06:32:51 <lambdabot>   [1]
06:33:16 <knobo> so how do I add the base case to the function?
06:33:37 <knobo> perms [] = []
06:33:43 <koeien> knobo: add, before the line starting with perms xs = ... , another line perms [] = ...
06:34:18 <koeien> in Haskell, the definitions are tried from top to bottom.
06:34:20 <ski> int-e : i just noticed that :)
06:34:29 <int-e> ski: I had the same idea ;)
06:34:45 <koeien> knobo: that could be it, but perms [] shouldn't be []. What are all permutations of [] ?
06:35:15 <knobo> koeien: I have to think about that..
06:35:17 <koeien> (what are all subsets of the empty set? what is 0! (0 factorial)?)
06:35:36 <opqdonut> subsets of the empty set is well-defined
06:35:40 <opqdonut> as opposed to 0!
06:35:45 <int-e> 0! is well-defined
06:35:46 <koeien> opqdonut: 0! is well-defined
06:36:02 <opqdonut> well okay if the empty product is
06:36:04 <tromp_> 0! is number of empty sequences
06:36:11 <koeien> it is equal to the number of functions empty -> empty
06:36:16 <koeien> bijections*
06:36:23 <opqdonut> good way of putting it
06:37:22 <koeien> and the empty product is also well-defined
06:37:37 <int-e> and [x:ps | x <- xs, ps <- perms (xs\\[x])] only works if the permutations have a first element.
06:41:30 <int-e> let perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])] ++ [[] | null xs] in perms [1..3] -- ;-)
06:42:12 <koeien> blargh
06:42:23 <koeien> but you know that ;)
06:43:24 <fasta> dcoutts: I think the calling convention used is __declspec(dllexport). Is there even a way to call this using GHC?
06:44:14 <dcoutts> fasta: that's normal, and strictly speaking it is not a calling convention
06:44:43 <ski> > [[] | [] <- [inits [0..]]]
06:44:44 <lambdabot>   []
06:44:50 <dcoutts> fasta: it'd be __declspec(stdcall) I think
06:45:20 <dcoutts> fasta: dllexport just means it is exported from a DLL
06:45:23 <fasta> dcoutts: what would be? What I need in my foreign import?
06:45:35 <dcoutts> fasta: just ccall probably
06:45:55 <dcoutts> fasta: and presumably you've got an import lib for this dll
06:46:18 <fasta> dcoutts: import lib? I have a .lib file, yes.
06:46:25 <dcoutts> right
06:46:44 <dcoutts> fasta: you can probably check the symbols using nm
06:47:44 <int-e> > let perm xs = let go [] [] zs = (zs:); go [] xs zs = id; go (x:xs) ys zs = go xs ys (x:zs) . go ys xs (x:zs) . go xs (x:ys) zs in go xs [] [] [] in perm [1..3]
06:47:47 <lambdabot>   [[3,2,1],[3,2,1],[2,3,1],[2,3,1],[1,3,2],[1,3,2],[3,1,2],[3,1,2],[1,2,3],[1...
06:48:07 <fasta> dcoutts: that only gives me  Recognised but unhandled machine type (0x8664) in Import Library Format archive
06:48:41 <koeien> "x86_64" maybe? ;)
06:49:01 <fasta> koeien, yes, why?
06:49:12 <fasta> koeien, oh, I see.
06:49:20 <fasta> koeien, but why would that be a problem?
06:49:45 <fasta> koeien, just that they didn't implement x86_64 support yet, I guess.
06:49:52 <koeien> fasta: i have no idea, i just noticed it. maybe you are linking two types ?
06:49:57 <koeien> maybe not, no idea
06:50:26 <knobo> whatever I do I just get: test.hs:2:4: parse error (possibly incorrect indentation)
06:50:39 <fasta> koeien, well, I got the 64 bits library version, so I expect to get it. :)
06:50:41 <koeien> knobo: could you hpaste your code?
06:50:53 <koeien> knobo: did you close all your parentheses and brackets ?
06:50:56 <koeien> ?hpaste
06:51:00 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:51:01 <int-e> > let perm xs = let go' [] [] zs = (zs:); go' xs ys zs = go xs ys zs . go ys xs zs; go [] xs zs = id; go (x:xs) ys zs = go' xs ys (x:zs) . go xs (x:ys) zs in go xs [] [] [] in perm [1..3]
06:51:02 <lambdabot>   [[3,2,1],[2,3,1],[1,3,2],[3,1,2],[1,2,3],[2,1,3]]
06:51:06 <fasta> cat does show some stuff besides binary garbage.
06:51:08 <int-e> koeien: so is that better? :)
06:51:26 <koeien> int-e: perfect, reminds me of the "diagonal" code on -cafe lately
06:51:56 <knobo> Right now I have one file with a single line in it: let xs = [x | x <- [1..10] ]
06:52:01 <knobo> it gives me that error..
06:52:07 <koeien> ah yes
06:52:10 <knobo> It works fine in ghci
06:52:11 <koeien> leave out the "let "
06:52:19 <koeien> that is only to define things in ghci
06:52:32 <koeien> in actual haskell programs, you just define things at the toplevel without the "let"
06:55:46 <knobo> And I have to define a function main.
06:56:27 <koeien> if you actually want to execute your program, yes
06:56:32 <koeien> but you can load your file into ghci
06:56:46 <koeien> and then try out the definitions in the file. the syntax is   :l MyFile.hs
07:00:13 <wdonnelly> knobo: also if you just want to display the result of a simple computation, something like 'main = print xs' will work just fine to make it into a full program
07:03:04 <knobo> Great! Thanx for the help.
07:05:50 <mogunus> Hello. I am coming from a SICP course and a lot of common lisp experience, what is the best resource for me to learn haskell quickly?
07:06:34 <koeien> i suggest RWH, you can skim some parts
07:06:37 <koeien> @where RWH
07:06:38 <lambdabot> is http://www.realworldhaskell.org/blog/
07:06:56 <koeien> the main differences are purity, laziness and the type system
07:07:11 <sinelaw> and unf
07:07:19 <sinelaw> *fun
07:07:55 <koeien> if you know FP already, it shouldn't be too hard to pick up haskell
07:07:56 <copumpkin> mogunus: by not trying to learn haskell quickly
07:08:03 <mogunus> I have very little experience with type systems, beyond my CS courses taught in java. I'm looking forward to using a type system that is actually... you know, good.
07:08:25 <koeien> well, common lisp also has  a type system, it's just very different
07:08:49 <koeien> haskell's type system is stronger than java's, e.g. "" + 37 won't compile
07:10:04 <fasta> dcoutts: changing to ccall also doesn't work.
07:10:10 <earthy> koeien: yes it will, given an instance declaration instance Num String
07:10:14 <EvilTerran> koeien, "instance Num String ..." :P
07:10:16 <koeien> earthy: yep.
07:10:27 <koeien> i left this out on purpose :P you probably understand why
07:10:31 <earthy> ofcourse, that is frowned upon. ;)
07:10:37 <yrlnry> I'm trying to figure out the Isabelle proof assistant.  The tutorial that comes with it is not working well for me.  Is there a good place to ask questions about it>
07:10:38 <yrlnry> ?
07:10:50 <koeien> i actually meant "" ++ 37 btw
07:11:02 <doublethink_work> yrlnry: perhaps the mailing list?
07:11:14 <EvilTerran> koeien, i guess (True || "False") would be an example that avoids haskell's actual polymorphism entirely
07:11:18 <earthy> the *main* advantage above Java's type system is that Haskell's is much much more expressive, and that inference is assumed
07:11:40 <earthy> leading to waaay fewer type annotations in actual code without sacrificing type safety
07:11:59 <koeien> it is stronger, but type inference and expressiveness make it far more pleasant to use
07:12:06 <notallama> well, java's type system is horrible, so there are a lot of advantages to pick from.
07:12:09 <endojelly> wanna see what tseitin makes out of a fun (and senseless) little formula like x v ¬(x v y)? (^ is and, v is or)
07:12:16 <koeien> since some people are fed up with java's type system, and think "static typing is useless"
07:12:19 <endojelly> this:
07:12:19 <yrlnry> And Haskell has higher-order type constructors, which Java lacks.
07:12:20 <endojelly> (¬z_1 v x) ^ (¬z_1 v y) ^ (¬x v ¬y v z_1) ^
07:12:20 <endojelly> (¬z_2 v ¬z_1) ^ (z_1 v ¬z_2) ^
07:12:20 <endojelly> (¬z_3 v x v z_2) ^ (¬x v z_3) ^ (¬z_2 v z_3)
07:12:26 <Rotaerk> java has inherent nullability doesn't it?
07:12:27 <endojelly> minisat says it's SATISFIABLE.
07:12:28 <mogunus> This RWH thing looks pretty fantastic. Thanks. I will most likely be in here asking confused questions in a while.
07:12:31 <endojelly> no shit sherlock! 8)
07:12:36 <yrlnry> doublethink_work:  thanks.
07:12:42 <koeien> mogunus: sure, no problem
07:12:51 <EvilTerran> earthy, and, as typeclasses let you reflect the inferred types as values, you can then let type inferrence write parts of your code for you
07:13:12 <koeien> Rotaerk: yes, except for some types as "int"
07:13:20 <Rotaerk> k thought so
07:13:32 <Rotaerk> that's something I've always hated about C#
07:13:34 <EvilTerran> "what's this?" "it's a Foo" "what can i do with it?" "bar, baz, and zot"
07:13:47 <EvilTerran> "what's this?" "dunno yet" "what can i do with it?" "er, likewise"
07:14:12 <notallama> i find that writing haskell code is like writing c++ templates, but without having to wave any chicken bones around.
07:14:19 <koeien> Rotaerk: yeah, me too
07:14:36 <koeien> down with NullReferenceException
07:15:23 <koeien> although C# has a pretty awesome IDE
07:15:30 <EvilTerran> notallama, i see what you mean; it's even more pronounced with ML's parameterised module system
07:16:10 <Cale> endojelly: Either all the variables are false, or z2 is false and the rest are true, or x and z3 are true and the rest are false.
07:16:13 <Rotaerk> yea C# has a lot of niceities
07:16:18 <EvilTerran> notallama, in which a "parameterised module" serves a similar job to a C++ template, in that they can be parameterised with types and values at compile-time
07:17:13 <endojelly> Cale, the zs aren't really that important, they are satisfication equivalent to the subterms of the formula
07:17:55 <endojelly> Cale, minisat says a solution is x=1, y=1, z1=1, z2=0 und z3=1
07:17:58 <endojelly> the important part is x=1, y=1
07:18:08 <endojelly> you can ignore the rest or look at it if you care about the subterms
07:18:09 <EvilTerran> notallama, i actually found it quite nice to tinker with ML in part because it confirmed my suspicions that C++ templates have a nug of a good idea hidden in there somewhere
07:18:22 <Cale> Oh, I just realised what I said is not quite right, I'm missing some possibilities :)
07:18:23 <koeien> EvilTerran: unintentionally, right?
07:18:43 <koeien> EvilTerran: i thought that its power was only discovered after the specification
07:18:53 <endojelly> Cale, it's just a fancy way to put formulas into CNF without potential exponential growth 8)
07:19:01 <Cale> yeah
07:19:15 <EvilTerran> koeien, possibly. that or stroustrup skimmed a paper on parameterised modules at some indeterminate point before before devising C++.
07:19:31 <EvilTerran> (i'd have to do some date checking to see if the latter is chronologically possible, mind)
07:19:47 <koeien> C++ has some nice ideas
07:20:08 <endojelly> Cale, and I did it by hand. that's normally not done. so I hope I did it right, it's incredibly easy to mistake a v for a ^ or vice versa and screw everything following that mistake up 8)
07:20:22 <endojelly> at least the proposed solution *is* a solution
07:21:04 <Cale> The DNF of that would be (not x /\ not z1 /\ not z2 /\ not z3) \/ (x /\ y /\ z1 /\ z3 /\ not z2) \/ (x /\ not y /\ not z1 /\ not z2 /\ z3)
07:21:45 <endojelly> Cale, how did you do it, by hand? just with a table I guess?
07:24:20 <Cale> The fact that I'm at a computer makes it easier ;)
07:25:06 <Cale> Mathematica has a convenient LogicalExpand function which DNF's things
07:27:55 <fasta> What exactly are the libFoo.a files on Windows created by GHC? Dependency walker cannot do anything useful with it.
07:28:21 <doublethink_work> they're used by the linker?
07:28:49 <doublethink_work> i mean without a specific name i couldn't tell you exactly, but considering GHC links statically right now on windows I would imagine it's part of a library or the library itself
07:28:59 <quicksilver> static libraries although using the "wrong" (unix-style) naming convention
07:29:17 <quicksilver> dependency walker says nothing interesting because static libs don't have dependencies AFAIK.
07:29:20 <fasta> doublethink_work,  AppData\Roaming\cabal\Codec-Image-DevIL-0.1\ghc-6.10.4/libHSCodec-Image-DevIL-0.1.a(DevIL.o):fake:(.text+0x121a): undefined reference to `ilDeleteImages@8'
07:29:26 <doublethink_work> well, that's just how mingw does stuff on windows :p
07:29:42 <fasta> doublethink_work, that's basically the problem.
07:29:46 <quicksilver> You attempt to collect the libraries together into an executable with ld and it tells you if you screwed up.
07:29:58 <doublethink_work> fasta: you're not linking in DevIL, and ilDeleteImages@8 seems to be a function of WINAPI calling convention
07:30:14 <doublethink_work> (given the '@8' on the end)
07:30:30 <fasta> doublethink_work, and how do you do know that this @8 stands for that?
07:30:44 <doublethink_work> because i've done lots of windows programming in the past :P
07:30:53 <doublethink_work> that's just the convention for functions compiled with the WINAPI convention
07:31:03 <fasta> doublethink_work, and AFAIK, all the Haskell FFI specifies is ccall and stdcall.
07:31:23 <doublethink_work> winapi == stdcall
07:31:37 <fasta> doublethink_work, ok, but I also tried it with stdcall already.
07:31:44 <fasta> doublethink_work, and I got the same results.
07:32:37 <doublethink_work> fasta: what exactly did you mean 'tried'?
07:32:38 <doublethink_work> what code?
07:33:04 <ben_m> I always think I can remove those 2-line dos by just using >>=, but it always turns out as crap :P
07:33:15 <fasta> doublethink_work, there is a macro in the Haskell imagedevil library  binding, and I changed it from ccall to stdcall.
07:33:22 <koeien37> ben_m: why?
07:33:31 <koeien37> ben_m: i often do that, and find it more readable
07:33:41 <ben_m> Maybe I suck at writing do-less code then
07:33:48 <koeien37> strategically placed liftM's or fmap's are also often useful
07:33:49 <fasta> doublethink_work, it does work with setting the symbol to ccall on Linux.
07:34:07 <koeien37> ben_m: but  by all means, do whatever you think is more readable
07:34:08 <doublethink_work> fasta: do you have DevIL for windows installed? it's possible that that particular function was not compiled with the stdcall convention
07:34:13 * benmachine never ever uses liftM
07:34:23 <fasta> doublethink_work, yes, I just have the binaries installed and the headers.
07:34:31 <koeien37> > (+5) `liftM` (Just 37)
07:34:31 <fasta> doublethink_work, but it doesn't say how it was compiled.
07:34:32 <lambdabot>   Just 42
07:34:39 <int-e> Berengal: right, use fmap instead ;)
07:34:46 <fasta> doublethink_work, I got the 64 bits version btw.
07:34:51 <ben_m> do { (arg1:arg2:_) <- getArgs; putStrLn $ printf "arg1: %s - arg2: %s" arg1 arg2 }
07:34:53 <ben_m> vs
07:34:56 <int-e> or <$> if you can be bothered to import Control.Applicative
07:34:59 <doublethink_work> fasta: ok, where are they? you likely have to have a copy of DevIL for windows that was compiled with GCC/mingw
07:35:01 <ben_m> getArgs >>= return . ((!! 0) &&& (!! 1)) >>= putStrLn . uncurry (printf "arg1: %s - arg2: %s")
07:35:02 <benmachine> <$> is nice
07:35:03 <doublethink_work> those builds might be MSVC
07:35:12 <koeien37> ben_m: yeah, this case i'd leave it in two lines too
07:35:19 <ben_m> yeh :D
07:35:19 <benmachine> ben_m: when you have pattern matching do is excusable
07:35:22 <benmachine> although case also works
07:35:30 <fasta> doublethink_work, why would I need a GCC version?
07:36:01 <benmachine> (as do let and where if you don't mind losing the possibility of error handling)
07:36:11 <fasta> doublethink_work, why can't it call MSVC libraries?
07:36:15 <benmachine> actually you can error handle with let and hwere
07:36:17 <benmachine> where
07:36:22 <doublethink_work> fasta: because I don't think MinGW can understand MSVC-generated lib files primarily :p
07:36:27 <koeien37> fail is evil anyway
07:36:48 <doublethink_work> i.e. windows uses the '.obj' convention if I remember correctly, which is a different format from unix's 'lib<foo>.a'
07:36:56 <endojelly> koeien37, how so?
07:36:57 <doublethink_work> mingw might have a conversion utility, I don't know off hand
07:37:02 <Saizan> fail is nice in IO, actually
07:37:15 <endojelly> and in Error?
07:37:19 <koeien37> we'd need MonadFail
07:37:22 <fasta> doublethink_work, I thought quicksilver just said that only the extension was wrong.
07:37:27 <fasta> doublethink_work, not the actual contents.
07:37:43 <benmachine> Saizan: what does nice mean
07:37:52 <doublethink_work> fasta: no, it's a different file format
07:37:54 <koeien37> doesn't fail in IO call error?
07:38:06 <benmachine> that is what I thought
07:38:13 <fasta> doublethink_work, ok, so isn't there a way to use a MS tool chain then?
07:38:18 <Saizan> no, it calls ioError, it makes a normally catchable exception
07:38:35 <doublethink_work> fasta: i don't believe so, no, not until GHC is compilable/compatible with MSVC
07:38:40 <fasta> doublethink_work, I already have msys setup, so it is more out of curiosity.
07:38:59 <doublethink_work> fasta: it is of course always good to double check everything I say with #ghc :)
07:39:32 <fasta> doublethink_work, ok, so I compile imagedevil myself and then it should work. The issue with compiling imagedevil is that it depends on a gazillion libraries.
07:39:43 <doublethink_work> fasta: that's typically the issue :(
07:39:51 <fasta> All I need is a simple pnm reader.
07:40:25 <Saizan> i.e. IO has a notion of failure, unlike many others
07:40:37 <fasta> I already ripped out the useful parts from some Haskell bindings to C libraries.
07:41:00 <fasta> It would have been better if those had been factored out already.
07:41:03 <koeien37> yes. but in code that is general for all monads, you shouldn't assume this
07:41:31 <koeien37> it does make the notation more concise
07:41:48 <koeien37> > do { [] <- return [37]; return 3 } :: Maybe Int
07:41:49 <lambdabot>   Nothing
07:50:22 <ben_m> Is it stupid to try and write every exercise in a book without do notation? :D
07:50:32 <ben_m> do notation just seems so ... imperative to me
07:51:27 <camio> ben_m, I don't think so. I rarely use do notation, and when I do, it is usually interfacing something imperative.
07:51:42 <quicksilver> do notation is a trivial syntactic convenience
07:51:50 <quicksilver> as such, it obscures possible refactorings.
07:52:00 <quicksilver> so, knowing how not to use it is really useful.
07:52:08 <ben_m> alright
07:52:31 <yrlnry> What about >> expr as opposed to >>= \_ -> expr ?
07:52:42 <quicksilver> I like >>
07:52:50 <camio> The main problem problem I see with do notation is that its meaning easily gets glossed over with newcomers.
07:53:00 <quicksilver> nothing wrong with combinators which can be expressed in terms of each other.
07:53:21 <camio> I take the same issue with list comprehension syntax.
07:53:29 <quicksilver> the fact that (a - b) is (a + (negate b)) doesn't stop minus being a useful operators to have around
07:54:54 <openAK> is this english channel?
07:54:59 <ben_m> yes
07:55:01 <yrlnry> Shoot, I've been writing (a + (negate b)) for the past three years.
07:55:05 <yrlnry> I didn't know about (-).
07:55:08 <camio> hehe
07:55:21 <yrlnry> Is there a similar shorthand for a * (recip b), perchance?
07:55:36 <ben_m> yrlnry: I've actually used odd compositions of not and elem because I didn't know notElem
07:55:39 <openAK> learned about haskell today from standford lectures
07:55:47 <openAK> am I late to enter into?
07:56:14 <yrlnry> someone once ridiculed me extensively for writing something like   iota = upFrom 1 where upFrom n = n:(upFrom (n+1))
07:56:17 <openAK> so where should I start.. any help here?
07:56:24 <ben_m> yrlnry: heh
07:56:48 <yrlnry> but actually his suggested alternative produced a type error, which was why I hadn't used it.
07:56:48 <ben_m> Reinventing the wheel is fun
07:57:02 <camio> openAK, I'm not understanding your request.
07:57:03 <yrlnry> Some overloading thing.
07:57:22 <int-e> openAK: haskell.org has a Learning section on the menu.
07:57:22 <yrlnry> Needed an explicit type annotation to fix.
07:57:26 <openAK> camio, can I have a short hand tutorial of Haskell
07:57:32 <openAK> int-e, thanx
07:57:54 <camio> openAK, http://learnyouahaskell.org/ has been recommended here before.
07:57:55 <int-e> openAK: and you can always ask questions here. people are generally helpful
07:58:35 <Gracenotes> yrlnry: this may shock you, but in the Num typeclass there are two default definitions. "x - y = x + negate y" and "negate x = 0 - x"
07:59:06 <yrlnry> That makes very good sense.
07:59:13 <Gracenotes> D:
07:59:17 <openAK> int-e, camio thanx mate.. I will do that.. getting into the groove.. generally I work in Spring..
07:59:22 <yrlnry> "D:" ?
08:01:07 <Gracenotes> uh. the Integer Show instance is not the built-in GMP one? hmmm
08:01:18 <int-e> yrlnry: australian smiley?
08:01:18 <Gracenotes> at least according to the source I have. interesting.
08:01:26 <burp> hm, why has noone build a haskell llvm frontend? :>
08:02:00 <Gracenotes> frontend? :o
08:02:08 <Botje> burp: that was a summer of code project, i think
08:02:14 <burp> oh, ok
08:02:20 <burp> yes, it's called frontend
08:02:39 <Saizan> ChilliX et al. are working on that
08:03:05 <int-e> Gracenotes: I'm responsible for that one - I found it competetive with gmp's own when I wrote it (gmp may have improved). Before it used the simple iterated `divMod` 10 stuff, which was horribly slow :)
08:03:41 <Saizan> it probably won't be ABI compatibile with the other ghc backends, iirc
08:04:03 <ben_m> this ( http://sprunge.us/EQVO?haskell ) brings me to the conclusion that do-notation is prettier when you need pattern matching
08:04:40 <Saizan> ben_m: why you use all those >>=?
08:04:55 <ben_m> Don't I have to?
08:04:59 <zygospasm> int-e: is it lazier than the GMP one perchance?
08:05:19 <Saizan> you can just compose functions together, without going through return
08:05:20 <benmachine> ben_m: a >>= return . f is the same as fmap f a
08:05:36 <ben_m> hmm
08:05:36 <benmachine> fmap f . fmap g $ a is the same as fmap (f . g) a
08:05:42 <int-e> zygospasm: a bit.
08:05:49 <zygospasm> benmachine: s/fmap/liftM/ :)
08:05:54 <Saizan> main = getArgs >>= (\(a:b:_) -> return $ read a + read b) >>= print
08:05:58 <ben_m> That sounds like a good use for <$> and <*>
08:05:59 <quicksilver> ben_m: getArgs >>= (\(a:b:_) -> print $ read a + read b)
08:06:14 <benmachine> zygospasm: well, you'd have to go pretty far to find a type that had liftM but not fmap
08:06:22 <Gracenotes> int-e: oh, nice :D
08:06:31 <benmachine> <$> is nice for this sort of situation yes
08:06:31 <Saizan> ben_m: also main = print . (\(a:b:_) -> read a + read b) =<< getArgs
08:06:46 <zygospasm> benmachine: you don't have to go very far to find a monadic combinator which has a (Monad m) constraint but not a (Functor m) one
08:06:52 <ben_m> I see
08:07:07 <benmachine> zygospasm: hmm?
08:07:13 <Gracenotes> int-e: I'll have to look into it more. have to go to class at the moment
08:07:15 <Saizan> (splitAt 1 >>> head *** head >>> read *** read)
08:07:24 <benmachine> zygospasm: hmm.
08:07:28 <Saizan> d'oh, i always copy the newline
08:07:47 <ben_m> Saizan: I test-paste first in some other buffer because I do that a lot
08:07:50 <ben_m> :)
08:07:54 <camio> ben_m, by using getArgs and print you're giving the problem an imperative bias in the first place.
08:08:25 <Saizan> print . (splitAt 1 >>> head *** head >>> read *** read >>> uncurry (+)) =<< getArgs -- also
08:08:38 <camio> i
08:09:01 <Saizan> though at that point i'd rewrite the thing to make it all go in the same direction :)
08:09:10 <ben_m> heh
08:10:08 <int-e> join (***) (head >>> read) ?
08:10:24 * benmachine thinks >>> is confusing
08:10:28 <Saizan> ?type System.Environment.getArgs >>= (splitAt 1 >>> head *** head >>> read *** read >>> uncurry (+) >>> print)
08:10:30 <lambdabot> IO ()
08:10:39 * ben_m thinks the whole business of mixing Monads with Arrows etc. is confusing
08:10:43 <int-e> >>> is no more confusing than >>= is, imho
08:10:51 <Saizan> >>> is just flip (.)
08:10:57 <benmachine> well yes
08:10:59 <benmachine> so just use . :P
08:11:01 <Saizan> here, at least
08:11:16 <benmachine> I'm used to reading functions right to left
08:11:17 <int-e> ben_m: (a -> a) -> (a, a) -> (a, a)  needs a better name than join (***) is all.
08:11:30 <benmachine> if you mix >>> and . and application you have to read it in several different directions
08:12:16 <int-e> @type join (***) {- actually works in any arrow, right? -}
08:12:17 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
08:12:22 <zygospasm> @type print . uncurry (+) . join (***) (read . head) . splitAt 1 =<< System.Environment.getArgs
08:12:23 <lambdabot> IO ()
08:13:01 <dolio> @type id &&& id >>> sum . head *** map product . tail
08:13:02 <lambdabot> forall a. (Num a) => [[a]] -> (a, [a])
08:13:10 <int-e> hmm, I wonder whether a patch changing all 'a' in Control.Arrow to (~>) would get accepted.
08:13:21 <zygospasm> @unpl id &&& id >>> sum . head *** map product . tail
08:13:22 <lambdabot> (\ e -> (((\ a -> a) &&& \ b -> b) >>> sum) ((head *** (map product)) (tail e)))
08:13:48 <quicksilver> int-e: do we want Control.Arrow to depend on -XTypeOperators?
08:13:49 <dolio> Uh...
08:14:01 <quicksilver> int-e: (probably not until TypeOperators is part of a future haskell standard, I fear?)
08:14:10 <dolio> I'm pretty sure unpl is wrong.
08:14:26 <dolio> Precedence fail.
08:14:41 <camio> ben_m: I'd probably do one of these http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4593#a4593
08:14:42 <quicksilver> I was going to say, I bet it has the wrong binary precedences
08:14:46 <quicksilver> for &&& and ***
08:15:02 <int-e> quicksilver: hmm, right
08:15:19 <Phyx-> is there a way to detect the ghc install path?
08:15:24 <quicksilver> int-e: maybe a patch which includes those versions of the types in the haddock only, for easy reading? ;)
08:15:37 <ben_m> camio: That looks good
08:15:57 <dolio> @unpl (id &&& id) >>> ((sum . head) *** (map product . tail))
08:15:58 <lambdabot> (((\ a -> a) &&& \ b -> b) >>> ((\ e -> sum (head e)) *** \ h -> map product (tail h)))
08:15:59 <quicksilver> Phyx-: I believe there is a private Ghc_paths module, or something like taht, but it's normal not what you want to do.
08:15:59 <int-e> quicksilver: uh, how would that work? #ifdef HADDOCK around every type signature?
08:16:13 <quicksilver> int-e: I dunno. I said it without thinking it through ;)
08:16:17 <quicksilver> int-e: it's an idea, though...
08:16:46 <Phyx-> quicksilver: i'm trying to call ghc and related tools from my program, ofcourse i could just assume that they're on the path
08:16:46 <int-e> quicksilver: that's too ugly and not very maintainable.
08:17:38 <int-e> Phyx-: http://hackage.haskell.org/package/ghc-paths ?
08:18:04 <Phyx-> int-e: yeah, just found it :)
08:18:40 <Phyx-> another small question is -M the only way to get a depencency trace?
08:19:03 <Phyx-> I would rather want it send over stdout instead of written to a file
08:20:51 <int-e> Phyx-: if you find an alternative I'd like to hear about it.
08:21:49 <Phyx-> hehhe, guess i'll be taking a look at the ghc usermanual
08:25:39 <int-e> oops. there goes hpaste.
08:26:39 <FunctorSalad> Re pointfreeCase@cafe: couldn't you do this with a quasiquoter?
08:26:46 <int-e> Phyx-: It's just that http://pastebin.ca/1658504 is not pretty.
08:27:30 <int-e> Phyx-: oh, the comment is wrong. Hah.
08:31:43 <Phyx-> int-e: cool, let me give that a try
08:32:29 <Phyx-> oh wait, that uses the same method i am now, hehe
08:32:50 <Phyx-> i've been thinking of writing a small stub that uses the GHC api to do it
08:33:10 <Phyx-> if the api allows it
08:38:08 <Phyx-> hmm it does
08:38:11 <Phyx-> let's see it this works
08:48:20 <JoePeck> I'm looking for a function that sets a position in a List. Much like !! gets the value at a position in a list. Is there already a function for this? (I wrote my own)
08:48:34 <quicksilver> no, there isn't.
08:48:42 <quicksilver> it's not hard to write (obviously) but it's a fairly bad idea
08:48:51 <quicksilver> it probably doesn't exist because it's a fairly bad idea :)
08:49:07 <JoePeck> quicksilver: Thanks. I agree its a bad approach, I'm going to try to make my approach more functional
08:49:35 <quicksilver> use Data.Sequence if you want a finite sequence which you can efficiently update in the middle
08:50:09 <camio> or Array, no?
08:51:14 <quicksilver> no
08:51:16 <quicksilver> hell no
08:51:25 <quicksilver> if you ever use Array, that's an immediate 1-day ban from #haskell
08:51:37 <quicksilver> repeat offences will send you over to ##c++
08:51:52 <camio> quicksilver, please don't ban me I didn't know the rule.
08:52:09 <yrlnry> I think he is kidding.
08:52:21 <camio> so was I :)
08:52:21 <fasta> yrlnry, so was camio.
08:52:25 <fasta> :)
08:52:33 <yrlnry> so was I.
08:52:44 <copumpkin> so was I
08:53:13 <ben_m> I'm not.
08:53:21 <quicksilver> actually Array (that's the immutable one) is fine
08:53:29 <quicksilver> but that doesn't have an efficient update routine either ;)
08:53:46 <quicksilver> array is quite convenient if you have a cuboid array of data.
08:53:48 <yrlnry> JoePeck: setElt (x:xs) 0 new = new:xs; setElt (x:xs) (n+1) new = x:(setElt xs n new);
08:54:04 <quicksilver> but MArray is not recommended until you've exhausted all other avenues.
08:54:20 <JoePeck> yrlnry: does that reverse the list?
08:54:23 <yrlnry> ellipsoid : spheroid : sphere  :: cuboid : ??? : cube
08:54:38 <quicksilver> yrlnry: I generally opt for (take (n-1) xs) ++ new ++ drop n xs
08:54:49 <yrlnry> JoePeck:  I'm torn between saying "try it and see " and "no".
08:54:52 <JoePeck> quicksilver: nice
08:54:59 <quicksilver> even though that traverse the list twice, because it is easy to read
08:55:01 <JoePeck> yrlnry: hehe, I agree, I should try it first
08:55:10 <quicksilver> and if it gets to slow, I know I'm going to switch to Seq.
08:55:12 <yrlnry> quicksilver:  but then you have to scan the list twice.
08:55:24 <yrlnry> and do a bunch of append.
08:55:27 <quicksilver> right.
08:55:31 <yrlnry> okay.
08:55:34 <quicksilver> but you just saw my answer to that ;)
08:55:38 <yrlnry> yes.
08:55:49 <quicksilver> if O(n) is too slow, the constant factor of 3 is unlikely to be the issue.
08:56:00 <benmachine> yrlnry: square prism?
08:56:00 <yrlnry> I'm still shocked that nobody complained about my use of n+k pattern.
08:56:04 <quicksilver> once O(n) is too slow, I'm moving to Seq.
08:56:12 --- mode: ChanServ set +o quicksilver
08:56:17 --- kick: yrlnry was kicked by quicksilver (n+k pattern)
08:56:22 --- mode: quicksilver set -o quicksilver
08:56:31 <yrlnry> Thanks, I feel better now.
08:56:33 <quicksilver> :)
08:56:54 <fasta> yrlnry, only compiler implementors complain about that ;)
08:57:07 <ski>   (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]  -- modify, don't set !
08:57:19 <fasta> If only people releasing libraries had some kind of QA.
08:58:02 <Phyx-> hrm.. think i found a bug.. the api gives a panic instead of a simple exception when a module can't be found
08:58:12 <fasta> OTOH, who is so crazy to build on MSYS.
08:59:49 <JoePeck> quicksilver: it would need to be (take (n) xs) ++ [val] ++ (drop (n+1) xs)
08:59:55 <JoePeck> but I like the readability
09:00:19 <JoePeck> its a route I took before I did a single loop (like yrlnry's)
09:01:49 <ski>   (xs !!<- n) mod = front ++ mod x : back
09:01:52 <ski>     where
09:02:03 <ski>     (front,x:back) = genericSplitAt n xs
09:02:52 <knobo> what should I do to evaluate odd head [1] int ghci?
09:02:56 <knobo> s/int/in/
09:03:34 <Rotaerk> knobo, "odd head [1]" ?
09:03:35 <Vulpyne> Type "odd (head [1])" ?
09:04:01 <Vulpyne> Without the parenthesis, it'll be interpreted as if you typed "((odd head) 1)
09:04:09 <knobo> aha..
09:04:16 <Rotaerk> which is incorrect types
09:04:32 <Vulpyne> ((odd . head) 1) would work though. :)
09:04:39 <Vulpyne> Er [1]
09:04:49 <Rotaerk> you have an odd head
09:04:57 <Vulpyne> How did you know? :(
09:05:20 <n000b> join #squid
09:08:10 <Baughn> Which style of FFI call is fastest, safe or unsafe?
09:08:23 <Baughn> I suppose, since unsafe gives more guarantees, it should be "safe".. sounds backwards
09:08:40 <knobo> A question about lazy evaluation. Does: filter (\x -> (odd .head) x)  (perms [1,2,3,4,5]) construct all permutations that start with an even number, or just the first element in that list? perms is defined like this: perms xs = [x:ps | x <- xs, ps <- perms (xs\\[x])]
09:09:11 <Saizan> Baughn: yeah, "safe" is you telling the compiler that it's safe :)
09:10:00 <Saizan> ?undo [x:ps | x <- xs, ps <- perms (xs\\[x])]
09:10:01 <lambdabot> concatMap (\ x -> concatMap (\ ps -> [x : ps]) perms (xs \\ [x])) xs
09:10:23 <Saizan> hah, buggy
09:11:11 <Baughn> Saizan: Right. Would it be safe to call aesCTR in 16-byte increments, or should I strive to fit in as large a buffer as possible?
09:11:32 <Baughn> Saizan: ..I feel kind of silly doing this at all, when the next cpu generation has the freakin' function built-in
09:11:47 <Botje> knobo: you should inspect the core output for that
09:12:05 <Baughn> Saizan: s/safe/sane/
09:12:20 <Saizan> going to core for this would be overkill, imo
09:12:48 <Botje> i'm not sure if ghc is smart enough to put the filter inbetween the map calls.
09:13:07 <Saizan> you just have to write perms more lazily
09:13:21 <Baughn> Saizan: Well, we'll have to eventually. The next intel cpu series has a nice set of AES /instructions/, so.. yeah.
09:13:22 <Saizan> *a lazier perms
09:13:28 <Baughn> Function-call overhead suddenly becomes an issue
09:15:22 <Saizan> perms xs = [map (x:) (perms (xs \\ [x])) | x <- xs] should be lazy enough, though i think that kind of transformation is already done
09:15:45 <Saizan> btw, there's a way to write perms without \\
09:17:29 <knobo> Saizan: I know. I've seen on an mailinglist. But I hav not fully understood the \\ version yet. I can understand it when I know what the function does, but not enough to write it by myself.
09:18:03 <Phyx-> int-e: http://phyx.pastebin.com/f829bc2e wrote that just now, does the same, except returns it on the stdout, (in my case i was already working in haskell so i can use it directly)
09:18:03 <Saizan> ?type \xs -> [map (x:) (perms (xs \\ [x])) | x <- xs]
09:18:04 <lambdabot> Not in scope: `perms'
09:18:06 <mmorrow> , [
09:18:07 <lunabot>  luna: parse error on input `)'
09:18:17 <Saizan> ?type fix \perms xs -> [map (x:) (perms (xs \\ [x])) | x <- xs]
09:18:19 <lambdabot> parse error on input `\'
09:18:25 <Saizan> ?type fix $ \perms xs -> [map (x:) (perms (xs \\ [x])) | x <- xs]
09:18:27 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
09:18:27 <lambdabot>       Expected type: [t]
09:18:27 <lambdabot>       Inferred type: [[t]]
09:18:45 <Saizan> ?type fix $ \perms xs -> map (\x -> map (x:) (perms (xs \\ [x]))) xs
09:18:45 <mmorrow> , (\xs -> [fmap (drop 1) (splitAt i xs) | i <- [0..length xs-1]]) [0..3
09:18:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
09:18:46 <lunabot>  luna: parse error on input `)'
09:18:46 <lambdabot>       Expected type: [[a]]
09:18:46 <lambdabot>       Inferred type: [[[a]]]
09:18:47 <mmorrow> , (\xs -> [fmap (drop 1) (splitAt i xs) | i <- [0..length xs-1]]) [0..3]
09:18:49 <lunabot>  [([],[1,2,3]),([0],[2,3]),([0,1],[3]),([0,1,2],[])]
09:19:32 <mmorrow> , (\xs -> [fmap (drop 1) (splitAt i xs) | i <- fst (zip [0..] xs)]) [0..3]
09:19:33 <lunabot>  luna: Couldn't match expected type `(a, b)'
09:19:48 <mmorrow> , (\xs -> [fmap (drop 1) (splitAt i xs) | (i,_) <- zip [0..] xs]) [0..3]
09:19:49 <lunabot>  [([],[1,2,3]),([0],[2,3]),([0,1],[3]),([0,1,2],[])]
09:25:18 <mmorrow> , (\xs -> concat [(permutations . uncurry (++) . fmap (drop 1) . splitAt i) xs | (i,_) <- zip [0..] xs]) [0..3]
09:25:20 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[0,2,3],[2,0,3],[3,2,0],...
09:25:48 <mmorrow> epic pipeline
09:26:41 <FunctorSalad> hehe. in the haskell grammar, allowing "*" in expressions, in the same production where vars are allowed, causes: shift/reduce conflicts:  8
09:26:41 <FunctorSalad> reduce/reduce conflicts: 89
09:26:59 <FunctorSalad> up from original: shift/reduce conflicts:  6
09:28:19 <FunctorSalad> thought it should work since * is already illegal if not in an operator position
09:30:43 <knobo> kinda noizy channel..
09:30:48 <knobo> ;)
09:31:07 <Saizan> heh, a bit
09:31:17 <Veinor> o/
09:31:19 <sinelaw> it's additive white gaussian
09:31:24 <sinelaw> noise
09:31:28 <knobo> But any conclution. I was not able to follow
09:31:33 <maltem> #haskell deliberately ignores the unwritten rules of IRC
09:31:45 <mmorrow> sinelaw: you should generate an image of it
09:31:54 <Phyx-> nah, i hide all join and parts
09:32:02 <sinelaw> mmorrow, what image?
09:32:07 <mmorrow> sinelaw: of the noise
09:32:10 <Phyx-> so i see only text and occasional kicks
09:32:11 <Phyx-> :P
09:32:20 <Botje> sinelaw: i think you mean addiCtive white gaussian noise.
09:32:26 <sinelaw> mmorrow yes, but how
09:32:27 <Saizan> knobo: there wasn't much of a conclusion :)
09:32:27 <quicksilver> FunctorSalad: sections?
09:32:34 <sinelaw> Botje true.
09:32:44 <quicksilver> (* b) vs (a b)
09:32:55 <FunctorSalad> quicksilver: hmm yes
09:32:56 <Saizan> knobo: what do you not understand about the \\ solution?
09:33:07 <Phyx-> maltem: which is? no talking?
09:33:13 <FunctorSalad> ".." only causes three new shift/reduce conflicts
09:34:20 <maltem> Phyx-, yeah, although I'm not sure if the text-to-number-or-users ratio is unusual here
09:34:31 * Phyx- wonders wth cabal is complaining about
09:34:33 <mmorrow> sinelaw: hmm. maybe mapping (time-between-messages, some-function-of-msg-length-content, something-else) -> [(x,y,value)]
09:34:54 <mmorrow> x,y the pixel coords, and value a colorspace coord
09:34:56 <knobo> Saizan: how we get the result [[1, 2 , 3], [1, 3, 2], [2, 1 ....] and not just [[1, 2 , 3], [2, 1 ,3]...
09:35:08 <mmorrow> (r,g,b) or (h,s,v)
09:35:48 <sinelaw> mmorrow, but it's one dimensional (time -> noise) not two
09:35:50 <Phyx-> http://phyx.pastebin.com/d1f18dd0a <-- does anyone know why cabal is having trouble parsing line 3?
09:36:01 <mmorrow> sinelaw: that's where the creativity comes in..
09:36:12 <sinelaw> Error
09:36:36 <Phyx-> "Parse of field 'exposed-modules' failed."
09:36:36 <knobo> how the arguments after | is joined together.
09:36:45 <mmorrow> sinelaw: (time-between-messages, some-function-of-msg-length-content, something-else) is three dimensions
09:36:48 <Saizan> knobo: because the 'x' which gets deleted from the list you pass to the recursive call gets consed in front of each permutation
09:37:38 <Saizan> knobo: ah, list comprehensions are translated with concatMap, let me fetch the page with the translation
09:37:41 <Tomomosius> Whant to win prizes like Xbox360 Elite,PS3,PSP-3000,40 inc LCD TV and many more. Then watch this video http://www.youtube.com/watch?v=YZl3vlYgO0g It will explain u how.U can pm me here to
09:37:53 <knobo> Saizan: good idea
09:38:03 <sinelaw> Tomomosius, monomorphism restriction
09:38:23 <Saizan> knobo: http://www.haskell.org/onlinereport/exps.html#list-comprehensions
09:38:44 * Phyx- curses at cabal
09:38:46 <Saizan> concatMap f xs = concat (map f xs)
09:39:11 <FunctorSalad> quicksilver: only 2 shift/reduce conflicts for using "-<" from arrow notation... should I just assume they are bogus? ;)
09:39:12 <Saizan> Phyx-: what error does it give?
09:39:31 <FunctorSalad> quicksilver: (I'm trying to make a preprocessor for the 'pointless case statement' thing)
09:39:43 <sinelaw> Saizan they use the list monad, no?
09:39:48 <sinelaw> translated into a do
09:39:51 <Phyx-> Saizan: " Parse of field 'exposed-modules' failed."
09:39:59 <Saizan> sinelaw: right, it's the same
09:40:06 <gwern> raindrops keep falling on my head
09:40:19 <sinelaw> gwern you're outside?
09:40:21 <Saizan> Phyx-: you've a "QuickCheck >= 2.1.0.1" line there
09:40:31 <Phyx-> Saizan: nvm, i had a line that should have been in build-depends
09:40:37 <gwern> sinelaw: I never said they were falling right now
09:40:39 <Phyx-> Saizan: yeah, just saw that
09:41:11 * Phyx- tried compiling
09:41:33 <quicksilver> FunctorSalad: I'm not sure. I'd try it and see if it seems to cause problems in practice :)
09:42:05 <sinelaw> gwern, that would be a first - outdoor IRCing
09:42:12 <gwern> not at all
09:42:17 <gwern> a little wireless and there you go
09:42:30 <sinelaw> yes, but to actually do it...
09:42:37 <FunctorSalad> oh wait, "-<" is part of expression syntax actually
09:43:19 <FunctorSalad> the problem is that it needs to be short and easy to type, or it would defeat the whole point of pointless case
09:44:00 <medfly> outdoor IRCing? my friend often talks to me using his mobile phone
09:44:25 <sinelaw> thou shall not fring
09:44:30 <FunctorSalad> you'd have to pay me to try to IRC from a phone :o at least without a proper keyboard
09:44:47 <medfly> there are more decent phone keyboards nowadays
09:44:53 <medfly> mobile phone keyboards
09:46:43 <Badger> heh
09:46:53 <Badger> best of all is irssi on an iphone
09:48:09 <milaz> hi all!
09:48:18 <gwern> greetings fellow human
09:48:30 <milaz> can anybody give me some advice on avoiding memory leak in my program?
09:48:53 <shambler> simplesimon2k: free allocated memory
09:49:14 <milaz> i have to zero-fill some file. and i do this: let block = B.replicate 1024 0
09:49:25 <milaz> sequence_ $ replicate (size * 1024) (B.hPut handle block)
09:49:44 <milaz> and when size = 100, it eats 33 Mb of memory
09:50:44 <benmachine> > foldr (\x -> either (Left . if x == '\n' then id else (x:)) (if x == '\n' then Left . (x:) else Right . (x:))) (Right []) "foo\nbar\n\nbaz\n" -- this function looked much neater in my head
09:50:46 <lambdabot>   Left "foobarbaz\n"
09:51:07 <benmachine> anyone got any cleanup ideas?
09:51:29 <benmachine> aside from you know, scrapping it and implementing it in a non-stupid way
09:52:14 <Saizan> milaz: tried with replicateM_ ?
09:52:26 <Saizan> milaz: and are you compiling with -O2?
09:52:44 <Saizan> that doesn't look like it whould use much memory
09:52:50 <milaz> no, just ghc --make sw.hs
09:53:03 <Saizan> ah, maybe it's the state hack
09:53:18 <Saizan> well, try with -O2 first, then with -fno-state-hack
09:54:32 <Cale> Does anyone offhand know how to tell vim that the inside of \begin{diagram} ... \end{diagram} is in math mode so that it will get the syntax highlighting right?
09:56:19 <kmc_> benmachine, what's it supposed to do?
09:56:43 <benmachine> kmc_: it removes all newlines except the last one
09:56:44 <shambler> concat lines
09:57:14 <benmachine> hmm
09:57:16 <kmc_> > ((:'\n') . concat . lines) "foo\nbar\n\nbaz\n"
09:57:17 <lambdabot>   Couldn't match expected type `[a]'
09:57:17 <lambdabot>         against inferred type `GHC.Types...
09:57:25 <kmc_> > ((++"\n") . concat . lines) "foo\nbar\n\nbaz\n"
09:57:26 <lambdabot>   "foobarbaz\n"
09:57:28 <benmachine> heh
09:57:34 <kmc_> what's the Eitherness for?
09:57:46 <benmachine> it's to remember whether we've passed a newline or not
09:58:12 <benmachine> a bit like a bool state only sort of easier
09:58:12 <Botje> Cale: a quick look through the latex syntax suggests "call TexNewMathZone("M","diagram",1)
09:58:20 <Botje> :call, probably
09:58:21 <dschoepe> Is there an alternative to using Read for configuration files with better error messages and that is less strict when parsing records?
09:58:55 <benmachine> dschoepe: if read isn't good enough at error handling, consider reads
09:59:01 <benmachine> :t reads
09:59:02 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:59:10 <kmc_> if your config file gets fancy, use parsec
09:59:15 <kmc_> there are also some config libraries on hackage
09:59:20 <Cale> Botje: thanks!
09:59:40 <dschoepe> benmachine: my particular problem is that I also want to parse records that don't have all of the fields set.
09:59:49 <benmachine> ah
10:00:17 <dschoepe> kmc_: I was trying to avoid writing it myself, so I'll take a look at the things on hackage.
10:02:12 * benmachine wonders what the performance characteristics of a fold that uses Either to sort-of do two calculations at once are
10:02:46 <milaz> Saizan: thanks for advice, but I still see large numbers in .prof file
10:02:48 <benmachine> I guess you probably get quite a large thunk-chain but when it actually comes to evaluating the thing you only need one traversal of the list I think
10:02:58 <milaz> Maybe I just read bytes column wrong?
10:02:59 <benmachine> which is interesting.
10:03:42 <milaz> Saizan: because in process list the memory taken does not exceed 2Mb
10:07:01 <int-e> Phyx-: thanks.
10:20:00 <dpratt71>   where can I find out what "type instance" means?
10:20:55 <paolino> look for typeclasses
10:21:13 <dpratt71> paolino: ok, thanks
10:22:04 <dolio> "type instance" would be type families.
10:22:08 <pchiusano> I was trying to explain what a combinator library is to one of my coworkers and realized I didn't have a good definition
10:22:32 <pchiusano> can anyone help me? :)
10:22:33 <dpratt71> dolio: ah, was a bit confused about the reference to typeclasses
10:24:39 <dolio> Well, "combinator" has a technical definition, but I'm not sure that's what people use when they talk about combinator libraries.
10:24:58 <pchiusano> dolio: no, it's not
10:24:59 <maltem> pchiusano, a library that gives opportunities to *combine* the functions (provided by only the library) in various ways? -- Not implying that this means much.
10:25:19 <pchiusano> technically, a combinator is just a function w/ no free variables
10:25:48 <Saizan> milaz: the .prof at the top lists the sum of all the allocated memory over the time, not the peak
10:25:57 <jlouis> pchiusano: another approach might be to eplain || and && and being combinators for boolean algebra
10:27:23 <camio> pchiusano: What to you mean by a function without free variables? Are you talking about a function definition?
10:27:37 <pchiusano> I think of it in terms of defining a set of primitive functions, and then a suite of other functions purely in terms of these primitive functions
10:29:22 <camio> What do you mean by "purely in terms of"
10:29:42 <pchiusano> actually, wikipedia has this: "A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments."
10:30:05 <camio> Ah, that's a good def. Thanks for pointing that out.
10:30:05 <pchiusano> that is not bad
10:30:12 <dolio> Yes, that's how it'd be defined in a combinator calculus.
10:30:49 <Twey> That makes sense to me.  What was all that about functions without free variables?
10:30:51 <dolio> That's why J Z = Z (\X Y -> X) (\F G X -> F X (G X)) isn't really a single-combinator basis.
10:31:04 <mauke> .oO( Jay-Z? )
10:31:24 <pchiusano> yeah, I don't know where I got the no free variables thing... I feel like I saw that as a def on wikipedia
10:31:24 <Twey> Jazed
10:31:36 <dolio> Rap's Grateful Dead.
10:32:00 <Twey> pchiusano: Don't all functions have free variables?  That's what makes a function.
10:32:19 <dolio> "id x = x" doesn't have any free variables.
10:32:35 <Twey> Hm
10:32:51 <Twey> Quoth WP: « a free variable is a notation that specifies places in an expression where substitution may take place. »
10:33:00 <Twey> Doesn't x fit that definition?
10:33:30 <Twey> The caller substitutes something for x, and the body of the function is evaluated in that context.
10:33:34 <dolio> In "jd x = x + n" n is a free variable.
10:33:46 <dolio> x is a bound variable.
10:33:47 <Twey> Oh, I see
10:33:59 <pchiusano> Twey: "Combinatory logic can be viewed as a variant of the lambda calculus, in which lambda expressions (representing functional abstraction) are replaced by a limited set of combinators, primitive functions from which free variables are absent."
10:34:03 <Twey> n is a free variable because it's defined in an outer scope?
10:34:28 <dolio> Yes, it isn't bound by jd.
10:34:45 <pchiusano> general gist is that you aren't referencing other functions other than what are passed into the function
10:34:48 <pchiusano> or values
10:35:05 <Twey> I get it.  Thanks.
10:35:09 <FunctorSalad> how unsafe is this? http://hackage.haskell.org/packages/archive/value-supply/0.5/doc/html/Data-Supply.html
10:35:13 <FunctorSalad> seems impossible to do purely
10:35:23 <kmc_> wait but anything defined in (say) SKI calculus is free in S, K, and/or I
10:35:28 <dolio> \f x -> f (\y -> x y) also has no free variables, as a whole expression, but f and x are free in the sub-expression "f (\y -> x y)".
10:36:19 <Gracenotes> GHC keeps a list of free variables for a function. so they are bound as appropriate when the time comes.
10:36:32 <pchiusano> i like the idea that a combinator may have free in its body some previously defined combinators
10:37:00 <pchiusano> although that is a little vague, what counts as previously defined?
10:37:06 <dolio> S F G X = F X (G X) has no free variables in its definition.
10:37:15 <dolio> Same with K x y = x
10:37:16 <pchiusano> but I think that's enough for an informal definition
10:37:24 <dolio> Those two are all you need.
10:37:40 <int-e> > ap const const 3
10:37:42 <lambdabot>   3
10:38:12 <roconnor> > ap const ap 3
10:38:13 <lambdabot>   No instance for (GHC.Num.Num (m (a -> b)))
10:38:13 <lambdabot>    arising from the literal `3' ...
10:38:44 <int-e> types getting in the way of theory ;)
10:38:50 <pchiusano> FunctorSalad: have you seen http://lukepalmer.wordpress.com/2009/09/14/io-free-splittable-supply/
10:39:13 <Gracenotes> pchiusano: hm. Well, arguments to the combinator can themselves use combinators.. but if there are functions that *internally* use only other combinators, I'm not sure there's a term that covers those :o
10:39:30 <int-e> S K a b -> K b (a b) -> b
10:39:35 <FunctorSalad> pchiusano: thanks that seems to answer it
10:39:42 <Gracenotes> unless you want to call them higher-level combinators, maybe :P
10:39:46 <int-e> @type ap 3
10:39:47 <lambdabot> forall (m :: * -> *) a b. (Num (m (a -> b)), Monad m) => m a -> m b
10:40:34 <dolio> > let s = ap ; k = const ; i = s k k ; u = s i i in u u
10:40:35 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
10:42:00 <int-e> typed lambda calculus is strongly normalizing. so that had to fail :)
10:42:32 <jlouis> mmm, Strongly normalizing!
10:43:37 <dolio> , let s f g x = f x (g x) ; k x y = x ; i = s k k ; u = s i i in unsafeCoerce u u
10:43:39 <lunabot>  luna: Not in scope: `unsafeCoerce'
10:43:43 <dolio> Aww.
10:44:08 <int-e> dolio: u can't be typed already.
10:44:16 <dolio> Oh, right.
10:44:46 <dolio> It doesn't matter anyway. mmorrow isn't as crazy as I thought.
10:45:23 <dolio> @type In
10:45:24 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
10:45:29 <dolio> @type InF
10:45:30 <lambdabot> Not in scope: data constructor `InF'
10:46:49 <srush> why does this fail
10:46:51 <srush> type Test m = (m String, m Int)
10:46:51 <srush> wrap :: (a -> m a) -> (String, Int) -> Test m
10:46:51 <srush> wrap fm (s, i) = (fm s, fm i)
10:47:34 <int-e> srush: because that means forall a . (a -> m a) -> (String, Int) -> Test m -- a is chosen by the caller of f.
10:47:55 <int-e> srush: what you want can be done with a rank 2 type: wrap :: (forall a . a -> m a) -> (String, Int) -> Test m
10:48:21 <int-e> (assuming that Test m = (m String, m Int) )
10:48:46 <srush> awesome, thanks
10:50:20 <dolio> > let s f g x = f x (g x) ; k x y = x ; i = s k k ; u = s outR i in u (InR u)
10:50:24 <lambdabot>   mueval-core: Time limit exceeded
10:51:09 <sproingie> is there a simple example use case of using Rank-N types somewhere, like the Shape example for existentials?
10:51:33 <saml> hey, what's 62038f3a  in base 10?
10:51:39 <saml> do it in one line using lambdabot please?
10:51:51 <dolio> > 0x62038f3a
10:51:52 <lambdabot>   1644400442
10:52:15 <mauke> dolio++
10:52:17 <sproingie> > 0xdeadbeefcafebabe
10:52:18 <lambdabot>   16045690984503098046
10:52:37 <dolio> @karma
10:52:37 <lambdabot> You have a karma of 5
10:52:46 <sieni> @karma
10:52:46 <lambdabot> You have a karma of 0
10:52:52 <sinelaw> @karma
10:52:52 <lambdabot> You have a karma of 0
10:52:55 <sieni> @karma dons
10:52:56 <lambdabot> dons has a karma of 10
10:52:59 <sinelaw> wow
10:53:07 <sproingie> slow karma around these parts
10:53:08 <dons> i lost a lot
10:53:15 <mauke> preflex: karma dons
10:53:16 <preflex>  dons: 5
10:53:16 <sieni> > 0xdeadbabe
10:53:17 <lambdabot>   3735927486
10:53:20 <sproingie> dons: if it makes you feel better, that's actually a good thing :)
10:53:23 <dons> hehe
10:53:26 <dolio> lambdabot forgets periodically.
10:53:27 <mauke> dons++
10:53:52 <sproingie> and mauke keeps dons on the dharma wheel for a while longer
10:54:17 <dons> so it goes.
10:54:59 <dolio> So, how awesome is frisbee? Is it worth fooling with the .cabal to make it build with the current library setup?
10:55:34 <saml> dolio, you're a genius
10:55:44 <dolio> Obviously.
10:56:05 <sproingie> pandora really needs a "merge these two stations" feature
10:56:20 <saml> now, what's 1644400442 in base 56 ?  0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ  as digits
10:56:41 <mauke> preflex: num 10 56 1644400442
10:56:49 <mauke> wait, that's not a plugin
10:56:59 <mauke> preflex: calc '56 1644400442
10:56:59 <preflex>  Invalid number base
10:57:20 <saml> preflex, calc '36 1644400442
10:57:20 <preflex>  r717i2
10:57:26 <sproingie> my counting may be a bit off but isn't that base 62?
10:57:35 <dolio> @type showIntAtBase 52 (!!([0..9] ++ ['a'..'z'] ++ ['A'..'Z']) 1644400442 ""
10:57:36 <lambdabot> parse error (possibly incorrect indentation)
10:57:44 <sproingie> > length "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
10:57:46 <lambdabot>   62
10:57:47 <dolio> > showIntAtBase 52 (!!([0..9] ++ ['a'..'z'] ++ ['A'..'Z'])) 1644400442 ""
10:57:48 <lambdabot>   Couldn't match expected type `[a]'
10:57:48 <lambdabot>         against inferred type `GHC.Types...
10:57:55 <mauke> dolio: list !! index
10:58:04 <dolio> > showIntAtBase 52 (([0..9] ++ ['a'..'z'] ++ ['A'..'Z'])!!) 1644400442 ""
10:58:05 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:58:05 <lambdabot>    arising from the literal `0...
10:58:10 <dolio> Bah.
10:58:19 <burp> :t showIntAtBase
10:58:20 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
10:58:20 <sproingie> add + and / and you have base64
10:58:23 <saml> i grant the best language award to haskell
10:58:25 <dolio> > showIntAtBase 52 ((['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'])!!) 1644400442 ""
10:58:26 <lambdabot>   "4gKMdm"
10:58:43 <mauke> preflex: calc '2 pi
10:58:44 <preflex>  11.001001000011111101101010100010001000010110100011
10:58:52 <sproingie> saml: yahbut claiming it means you'll have to evaluate every other language first
10:59:02 <burp> I see a pattern!
10:59:16 <dolio> > showIntAtBase 62 ((['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'])!!) 1644400442 ""
10:59:17 <lambdabot>   "1NhJFM"
10:59:38 <johh> is quot and div, and rem and mod the same for positive integers?
10:59:43 <saml> sproingie, i evaluated java: http://codepad.org/TvNghi3b
10:59:47 <sproingie> johh: TIAS
10:59:54 <mauke> sproingie: what, all of them?
10:59:58 <saml> dolio, that looks about right
11:00:01 <mauke> johh: AFAIK yes
11:00:46 <sproingie> mauke: just my attempt at a laziness joke :p
11:00:53 <saml> darn i want to twit > showIntAtBase 62 ((['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'])!!) 1644400442 ""
11:01:05 <sproingie> @twit
11:01:05 <lambdabot> Not enough privileges
11:01:11 <sproingie> whoah
11:01:17 <sproingie> i wasn't expecting there was such a module
11:01:22 <dolio> @beer
11:01:23 <lambdabot> Unknown command, try @list
11:01:30 <mauke> sproingie: s/tw/qu/
11:01:48 <sproingie> mauke: it it actually trying to DWIM two letters worth of typo?
11:01:58 <dolio> Oh, right, lambdabot doesn't do @seen anymore.
11:02:04 <sinelaw> I'm leeching all the logs of #haskell. any funky idea of what to do with them?
11:02:17 <sproingie> sinelaw: retroactive turing test
11:02:25 <sinelaw> ok, something easier
11:02:39 <sproingie> put up a "best of #haskell" blog
11:02:43 <sinelaw> ...that involves a little bit of parsing
11:02:49 <sinelaw> ...and automatic
11:03:02 <camio> @list
11:03:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:03:13 <sproingie> user statistics?  mentions of topics by keyword?
11:03:26 <mauke> count occurrences of "monad"
11:03:36 <sproingie> or "monad tutorial"
11:03:47 <Botje> sinelaw: grep for unsafe\w+
11:03:52 <Botje> see what you find :)
11:03:58 <sproingie> > fix error
11:03:59 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
11:04:03 <sproingie> that's always my favorite
11:04:05 <sinelaw> it's going pretty slow. i'm still in 2004.
11:04:19 <sinelaw> downloading, that is
11:04:22 * Botje advises sinelaw not to invest in lehman brothers stock.
11:04:43 <sproingie> i grok how the fixpoint combinator works, but i don't get the topological concept of fixed point
11:04:52 <sinelaw> Botje, in my point in time, that counts as inside information
11:04:55 <fluxxen> hello, Im having a slight problem with iterating through a custom type List, the list is built like this http://pastebin.com/m20dbca1d . If I would want to check wether or not a Card (an item in that List) is of ex Rank == King for example. Can anyone give me a hint on how to do that in a method that get's an Hand as paramter
11:05:56 <mauke> @src filter
11:05:56 <sproingie> what's with the custom list type?
11:05:56 <lambdabot> filter _ []     = []
11:05:56 <lambdabot> filter p (x:xs)
11:05:56 <lambdabot>     | p x       = x : filter p xs
11:05:56 <lambdabot>     | otherwise = filter p xs
11:05:58 <sinelaw> heh, i grepped for "monad" & "crap" in the same line, and found something
11:06:06 <mauke> like that, only replace [] by Empty and (:) by Add
11:06:08 <sinelaw> 04.04.09:03:31:30 <mycroftxxx> I'm actually seriously digging into Dylan, haskell is just a tangent to learn monads and other "purist crap" :)
11:06:19 <Botje> :)
11:06:37 <sproingie> dylan would be nice if it had any ecosystem.  at all.
11:06:41 <Botje> sinelaw: you could train a markov generator to spew topology and category theory
11:06:57 <lament> yeah, dylan is a bit of a shame
11:07:11 <sinelaw> what's an ecosystem?
11:07:11 <lament> it had potential as a lisp with a human face
11:07:14 <sproingie> sinelaw: users
11:07:17 <Rotaerk> hmm never heard of dylan
11:07:17 <sinelaw> oh
11:07:22 <sinelaw> heh, point proven
11:07:24 <lament> Rotaerk: nobody has
11:07:37 <dolio> I've heard of Dylan.
11:07:39 <fluxxen> mauke yeah I was here yesterday and I can't use filter en length but I got a function that does the same thing as for length but now I need a way of making filter but not as a function itself rather a function that takes an Hand and returns an Integer and I don't have filter but in a way you could say I have length (I got sizeofHand)
11:07:54 <dolio> Not used it. But heard of it.
11:08:05 <mauke> fluxxen: uh, I told you how to write filter
11:08:07 <lament> are you sure it wasn't Bob Dylan or Dylan Thomas?
11:08:09 <mauke> of course you have it
11:08:33 <sinelaw> "suffer the first vision that set fire to the stars...
11:08:40 <dolio> Dylan is a character in Predator, right?
11:08:57 <dolio> Played by Carl Weathers?
11:08:59 <fluxxen> mauke yes and thank you for that =) but If don't want to use filter. it must be a way of doing it?
11:09:15 <Botje> fluxxen: mauke is suggesting you write a function that _looks_ like filter, but operates on your Hand datatype.
11:09:28 <Botje> fluxxen: if you look closely, Add is equivalent to (:), and Empty is equivalent to []
11:09:30 <fluxxen> mauke the solution you gave me with filter and length is exaxlty what I want to accomplish but as I don't have filter in my custom type I have a problem
11:09:51 <fluxxen> Botje yes that would be a solution but in my exercise I don't think I am supposed to do that
11:10:00 <Botje> fluxxen: so the base case for you function filterHand would look like: filterHand p (Empty) = False
11:10:04 <sproingie> fluxxen: is there a particular reason you're using that type instead of a list?
11:10:24 <fluxxen> sproingie yes it's part of an exercise
11:10:27 <sproingie> ah
11:10:50 <sproingie> probably to learn how lists work :)
11:11:13 <fluxxen> sproingie ye hehe and I have done all functions except this last one. And there is no solutions to the excercises
11:11:40 <fluxxen> this one I need to check if a hand has more then 1 ace, if then my rank of the ace would be 1 insted of 11
11:12:03 <sproingie> since maps and folds aren't going to work, you'll probably have to use primitive recursion
11:12:35 <fluxxen> sproingie yes that I was I have been trying to do but I can't get to make like if ex x rank is Ace
11:12:55 <fluxxen> tried a couple of things on how to extract that from the Card in the Hand
11:13:04 <fluxxen> but the errors I get are not helping much hehe
11:13:08 <sproingie> case expressions are nice for doing pattern matching on
11:14:45 <Gilly> A small problem if you are bored: Suppose you have a deck of cards. You play the following game: 1) Choose a card 2) Take cards until you reach that card, put them away 3) Having reached that card you take a sip of drink of your choice and go back to 1 (choosing one of the cards that's still left in the deck). What is the expected number of sips you get?
11:15:00 <Gilly> There are 52 cards in the deck.
11:15:20 <camio> I just had a funny thought, why not replace bang patterns with bottom patterns? f (!a,b) = (a,b) would be instead f (_|_,_) = _|_ and f (a,b) = (a,b).
11:15:29 <Gilly> err, wrong channel sorry...
11:15:45 <Elly> Gilly: this is still a good place for that :)
11:15:54 <Gilly> well, i guess :)
11:16:07 <Elly> Gilly: the real question is: if you're repeatedly taking sips of the drink of your choice, how long are you able to keep playing this game for? :P
11:16:07 <sproingie> Gilly: naw, that's a neat problem.  i approve of any statistics problem that involves drinking.
11:16:28 <benmachine> is it somewhere between 5 and 6?
11:16:37 <benmachine> wait no
11:16:41 <benmachine> wait yes
11:16:41 <Gilly> Elly: that passed my mind too :) it depends if you are an absolutist or not
11:17:11 <sproingie> it's anywhere from 1 to 52 sips
11:17:28 <benmachine> sproingie: you don't expect to get 52, though
11:17:32 <medfly> 51
11:17:40 <Elly> kind of depends on the potency of your drink
11:17:40 <medfly> 51 - 0:)
11:17:44 <benmachine> medfly is playing with the pack face up?
11:17:48 <sproingie> the average case is more interesting, i would guess geometric series if the pick is halfway through the remaining deck
11:17:56 <Gilly> benmachine: :D
11:17:57 <medfly> what?
11:18:10 <sproingie> i'm a math moron so i couldn't calculate that off the top of my head
11:18:14 <benmachine> heh
11:18:24 <benmachine> well log_2 52 is between 5 and 6
11:18:27 <benmachine> hence my guess
11:18:35 <sproingie> oh yeah it's binary search
11:18:41 <sproingie> so log2 it is
11:18:42 * benmachine shrugs
11:18:43 <Gilly> :) it's funny but you're actually wrong with that I think.
11:18:49 <benmachine> I'm not surprised
11:18:54 <Gilly> i had the same idea first myself
11:18:55 <benmachine> I only thought about it briefly
11:18:56 <sproingie> it's like a worst case binary search
11:20:08 <benmachine> well hmm
11:20:23 <benmachine> if you have 1 card left you are guaranteed to take a drink
11:20:28 <sproingie> if you s/sips/shots/ you'll have a nice buzz on
11:20:38 <benmachine> if you have two cards left you expect 1.5 drinks
11:20:45 <benmachine> if you have three, then umm
11:20:50 <benmachine> it gets a bit tricker?
11:20:52 <benmachine> *trickier
11:21:18 <sproingie> i recommend a monte carlo solution, i.e. throw random crap out and see what sticks :)
11:21:32 <benmachine> with three I think you expect two drinks
11:21:39 <benmachine> no
11:22:00 <benmachine> 11 / 6
11:22:09 <benmachine> that
11:22:10 <benmachine> still sounds wrong
11:22:12 <sproingie> between 1 and 3 is all you can say, average case would be 2
11:22:37 <benmachine> if you have three cards you have a 1 in 3 chance of drinking now, and hence getting 2.5 drinks total
11:22:44 <benmachine> (because for two cards it's 1.5)
11:22:53 <sproingie> i wonder if there's a monty hall problem in there somewhere
11:22:59 <benmachine> and you have a two in three chance of not drinking now and hence getting 1.5
11:23:19 <benmachine> soo, 2.5 / 3 + 1.5 * 2 / 3
11:23:19 <mauke> use a probability monad!
11:23:23 <benmachine> heh
11:24:15 * benmachine gets a bit of paper and a pencil
11:24:23 <copumpkin> USE THE POWER OF THE MONAD
11:24:28 * mauke gets about 10 drinks
11:24:59 <sproingie> BY THE POWER OF MONAD
11:25:49 <doublethink_work> YOU SHALL NOT PASS
11:26:04 * mauke listens
11:26:14 <dolio> > let arr = listArray (0,52) l ; l = map f [0..52] ; f 0 = 0 ; f n = 1 + sum (map (arr!) [0..n-1]) / fromInteger n in arr ! 52 :: Double
11:26:15 <lambdabot>   4.538043950697449
11:26:29 <Gilly> yea, the haskell way :)
11:26:32 <benmachine> :o cheating
11:27:15 * benmachine tries to work out the logic involved
11:27:40 <Apocalisp> > let f 1 = 1; f n = (1 / n) + f (n - 1) in f 52
11:27:41 <lambdabot>   4.538043950697447
11:27:54 <benmachine> that's much nicer
11:28:12 <dolio> :)
11:28:15 <Apocalisp> bonus points if you use a hylomorphism
11:28:29 <copumpkin> zomg a hylomorphism
11:28:33 * benmachine doesn't get bonus points
11:28:42 <dolio> Brute force requires so much less thinking. :)
11:28:55 <Gilly> Apocalisp: ;) good
11:29:13 <benmachine> I'm surprised it's that low actually
11:29:23 <maltem> yeah bad game
11:29:29 <benmachine> > let f 1 = 1; f n = (1 / n) + f (n - 1) in f 2
11:29:31 <lambdabot>   1.5
11:29:33 <benmachine> > let f 1 = 1; f n = (1 / n) + f (n - 1) in f 3
11:29:34 <lambdabot>   1.8333333333333333
11:29:59 * benmachine wonders if there is a simple non-recursive version
11:30:23 <benmachine> wait it is
11:30:34 <benmachine> > sum [recip n | n <- [1 .. 52]]
11:30:35 <lambdabot>   4.538043950697447
11:30:58 <dolio> That's non-recursive?
11:31:01 <benmachine> no
11:31:02 <Apocalisp> that's a recursive version
11:31:04 <benmachine> but it's interesting
11:31:15 <Apocalisp> pretty
11:31:26 <Gilly> yes, it's a pretty result :) you can prove it, too :P
11:31:30 <benmachine> > sum (map recip) [1 .. 52]
11:31:31 <lambdabot>   Couldn't match expected type `[a]'
11:31:31 <lambdabot>         against inferred type `[a1] -> [...
11:31:39 <benmachine> oops
11:31:43 <benmachine> > sum (map recip [1 .. 52])
11:31:44 <lambdabot>   4.538043950697447
11:31:49 <zygospasm> it's easy: let f_k = sum [1/n|n <- [k..]]; x = sum [1/n|n <- [1..]], and the answer is x - f_53 ;-)
11:31:50 <dolio> sum . map recip . enumFromTo 1
11:31:58 * zygospasm subtracts infinity from infinity for fun and profit
11:32:11 <copumpkin> > sum . map ((^2) . recip) . enumFromTo 1 $ 52
11:32:11 <burp> physicists do that all the time
11:32:12 <lambdabot>   1.6258870236192313
11:32:30 <copumpkin> > sum . map ((^2) . recip) . enumFromTo 1 $ 1000
11:32:31 <lambdabot>   1.6439345666815615
11:32:40 <burp> subtract infinities to make values finite ;)
11:32:44 <copumpkin> > pi^2 / 6
11:32:45 <lambdabot>   1.6449340668482264
11:33:57 <dolio> Anyhow, the closed form is f n = H_n, which is cheating, of course. :)
11:34:50 <benmachine> is there a non-cheating closed form?
11:35:27 <Apocalisp>  > (\n -> (1/(n * n) - 1) / 2) 52
11:35:32 <Apocalisp> > (\n -> (1/(n * n) - 1) / 2) 52
11:35:33 <lambdabot>   -0.49981508875739644
11:35:39 <Apocalisp> Bah
11:36:15 <dolio> Not unless you've discovered how to computer harmonic numbers with analytic functions.
11:36:16 <Gilly> H_n isn't very nicely behaving in terms of closed expressions, so I wouldn't hope for too fancy formulas for it
11:36:39 <dolio> Compute, even.
11:36:49 * benmachine figures out how to computer
11:37:09 <copumpkin> > log 52 + 0.577
11:37:10 <lambdabot>   4.528243718581427
11:37:10 <copumpkin> tada!
11:37:15 <dolio> ln n < H_n < ln (n + 1), though, so you can get a neighborhood.
11:37:22 <copumpkin> O:-)
11:37:41 <zygospasm> > (log 52 + log 53) / 2
11:37:42 <lambdabot>   3.9607678160667747
11:37:43 * copumpkin goes back to doing nothing
11:37:48 <benmachine> > log 53
11:37:49 <lambdabot>   3.970291913552122
11:37:56 <benmachine> erm.
11:37:59 <copumpkin> the 0.577 is important
11:38:14 <benmachine> where does it come from
11:38:43 <copumpkin> it's obviously just an approximation
11:38:51 <burp> > log 77 + 0.194
11:38:53 <lambdabot>   4.537805421853684
11:38:53 <copumpkin> it comes from fancy math
11:39:01 * benmachine likes fancy maths
11:39:01 <burp> and this is from very fancy maths
11:39:06 <dolio> It's lim n  -> oo (H_n - ln n)
11:39:11 <dolio> Euler's constant.
11:39:13 <benmachine> oh
11:39:14 <copumpkin> ooo
11:39:24 <benmachine> that is not that fancy
11:39:38 <benmachine> is there any way of calculating it other than getting really big numbers and plugging them in
11:40:16 <Apocalisp> > "Four or five"
11:40:17 <lambdabot>   "Four or five"
11:40:26 <benmachine> :P
11:40:27 <medfly> :))
11:40:28 <zygospasm> > let e = [1 + sum (take (n-1) e) / fromIntegral n | n <- [1..]] in e !! 52
11:40:29 <lambdabot>   4.556911875225751
11:40:32 <medfly> Apocalisp wins!
11:40:39 <Apocalisp> \o/
11:40:51 <poe> benmachine: would you like a generating function?
11:40:54 <zygospasm> > let e = [1 + sum (take (n-1) e) / fromIntegral n | n <- [1..]] in e !! 51
11:40:55 <lambdabot>   4.538043950697449
11:40:58 <zygospasm> (d'oh)
11:41:03 <benmachine> poe: uhm, sure why not
11:41:17 * benmachine is just curious
11:41:26 <poe> well wikipedia has it :)
11:41:41 <poe> (harmonic number)
11:41:58 <dolio> Get a copy of Concrete Mathematics. It has all this stuff and more.
11:43:02 <benmachine> I actually have that book
11:43:09 <benmachine> it is a little over fifty miles away though
11:43:32 <dolio> Heh. Well, that explains why you weren't able to crib from it like I did.
11:44:15 <malosh> Does someone know of a way to represent efficiently a sparse (lazy) array for dynamic programming ?
11:44:33 <Twey> Data.Map
11:44:48 <malosh> Sorry, I forgot : adapted for parallelism :-)
11:45:23 <Apocalisp> malosh: how about a dynamorphism?
11:45:24 <Gilly> Apocalisp: btw, did you just guess the answer or did you really calculate it?
11:45:47 <Apocalisp> Gilly: The recursive solution?
11:45:49 <malosh> Apocalisp : I dont know, what is it ?
11:45:59 <Gilly> Apocalisp: that the answer to the card problem is H_n
11:46:22 <Apocalisp> Gilly: I did't know what H_n was until just now.
11:46:39 <Gilly> Apocalisp: well, that the answer was a sum of numbers 1/i up to i=n ? :)
11:46:56 <Apocalisp> Just looked like sum of 1/n in a geometric series.
11:47:47 <Vanadium> How do I set LANGUAGE pragmas in ghci?
11:48:05 <copumpkin> :set -X<lang>
11:48:06 <Apocalisp> Arrived at it through induction. f 1 -> 1, f (n+1) -> 1/(n+1) + f n
11:48:24 <Gilly> alright, well - the way i solved this the first time was using the recurrence: E_n = 1/n (1 + E_{n-1}) + ... + 1/n (1 + E_0) where E_0 = 0 and E_1 = 1.
11:48:40 <Gilly> where E_n is the expected number of sips in a deck of n cards
11:49:13 <Gilly> thought that you might have had something similar
11:49:28 <zygospasm> E_n = 1 + (E_n-1 + E_n-2 + ...) / n = 1/n + E_n-1 + (E_n-2 + ... - (n-1) + (n-1)*E_n-1) / n, but (n-1)E_n-1 = n-1 + En-2 + En-3 + ...
11:49:32 <zygospasm> so E_n = 1/n + E_n-1
11:49:59 <Gilly> zygospasm: right
11:50:03 <Apocalisp> Gilly: Ah, I see. Pretty straightforward. I didn't put a lot of thought into it.
11:51:24 <Apocalisp> Was just going to say "on the order of log 52"
11:51:26 <Gilly> this channel produced the answer remarkably quickly, though :D kudos to you
11:51:48 <benmachine> the combined efforts of 650 minds
11:51:50 <Apocalisp> Any constant fraction is as good as a half, you know that.
11:51:52 <benmachine> including ChanServ
11:52:15 <Gilly> benmachine: yup :) all of those 650 minds suddenly sparked alive when it was about drinking games
11:53:01 <Apocalisp> I suspect copumpkin is figuring it out the empirical way.
11:53:07 <copumpkin> ?
11:53:17 <Apocalisp> Just kidding.
11:53:27 <Vanadium> What is the inverse of fromIntegral? :<
11:53:29 <Gilly> the didn't get the same reaction on #math where I originally wanted to post that problem, though :P
11:53:37 <Gilly> Vanadium: round, floor, ceiling
11:53:41 <Vanadium> Oh, right.
11:54:00 <sproingie> the new listcomp stuff in 6.12 looks yummy
11:54:07 <sproingie> downright linqish
11:54:14 * Apocalisp gets out a deck of cards and some scotch
11:54:22 <zygospasm> sproingie: what stuff's that then? didn't see nowt on the release notes :)
11:54:31 <sproingie> zygospasm: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
11:54:41 <sproingie> down at 7.3.8
11:54:46 <Gilly> Apocalisp: have fun - drink of your choice, as i said ;)
11:55:05 * benmachine has lemonade
11:55:10 <sproingie> i wonder if you can use view patterns in a listcomp?
11:55:35 <zygospasm> sproingie: oh, those things. never really understood those :)
11:56:02 <sproingie> they look pretty simple.  evaluate an arbitrary function on the thing being matched, then match against that
11:56:56 <zygospasm> sproingie: i find it hard to see what they desugar into
11:57:18 <sproingie> let bindings maybe?
11:57:41 <zygospasm> sproingie: like what on earth does this mean: [ x | y <- [1..5], x <- "hello", then group using inits ]
11:58:07 <sproingie> oh what the listcomps desugar into.  heck if i know.
11:58:53 <zygospasm> looks like it's the same as: inits [ x | y <- [1..5], x <- "hello" ]
11:58:57 <zygospasm> that seems somewhat surprising... :)
12:00:49 <zygospasm> the clauses all seem to be on the wrong side of the ] to me :(
12:01:13 <benmachine> I know this isn't really a haskell question but we seem to be digressing this evening; is it possible for an operator to be commutative but not associative?
12:01:47 <zygospasm> sure. \a b -> a * b + 1
12:01:50 <sproingie> 'infix' with no 'l' or 'r' declares a non-associative operator
12:02:17 <benmachine> zygospasm: oh, that is kind of obvious yes thankyou
12:05:16 <gwern> @wn sniggering
12:05:18 <lambdabot> No match for "sniggering".
12:05:22 <gwern> @wn snigger
12:05:23 <lambdabot> *** "snigger" wn "WordNet (r) 2.0"
12:05:23 <lambdabot> snigger
12:05:23 <lambdabot>      n : a disrespectful laugh [syn: {snicker}, {snort}]
12:05:23 <lambdabot>      v : laugh quietly [syn: {snicker}]
12:05:30 <gwern> @wn snicker
12:05:31 <lambdabot> *** "snicker" wn "WordNet (r) 2.0"
12:05:31 <lambdabot> snicker
12:05:31 <lambdabot>      n : a disrespectful laugh [syn: {snort}, {snigger}]
12:05:31 <lambdabot>      v : laugh quietly [syn: {snigger}]
12:05:38 <skorpan> ...
12:05:56 <Badger> heh
12:06:01 * Badger snickers.
12:06:09 <gwern> or perhaps you snigger?
12:06:09 <drhodes> @wn sniglet
12:06:10 <lambdabot> No match for "sniglet".
12:06:10 <zygospasm> > [ x | ((+1) -> x) <- [1..10]
12:06:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:06:15 <zygospasm> , [ x | ((+1) -> x) <- [1..10]
12:06:17 <lunabot>  luna: parse error on input `)'
12:06:20 <zygospasm> aww
12:06:20 <Badger> perhaps I do!
12:06:34 * benmachine marathons
12:06:46 <Badger> >_>
12:07:58 * benmachine is making a reference to a chocolate bar that ceased to exist before he was born?
12:08:12 <Badger> did it?
12:08:20 <Badger> hm, thought it was more recent than that
12:08:27 <skorpan> drhodes: a snigger is a fully grown sniglet
12:08:30 <benmachine> wikipedia says it changed in 1990
12:08:38 <benmachine> it doesn't cite its sources though?
12:08:45 <byorgey> , [ x | ((+1) -> x) <- [1..10] ]
12:08:46 <lunabot>  [2,3,4,5,6,7,8,9,10,11]
12:08:56 <Badger> > [citation | needed]
12:08:56 <byorgey> zygospasm: works fine, you just forgot a closing ]  =)
12:08:57 <lambdabot>   Not in scope: `needed'Not in scope: `citation'
12:08:59 * quicksilver thinks it's scary that people who weren't born when marathon changed its name can now program haskell.
12:09:05 <zygospasm> byorgey: ah, oops, ta :)
12:09:16 <drhodes> skorpan: "A sniglet is a neologism defined as "any word that doesn't appear in the dictionary, but should""
12:09:30 <zygospasm> drhodes: isn't that also called a liff?
12:09:38 <skorpan> quicksilver: marathon didn't change its name, it's not the same product
12:09:43 * benmachine hugs quicksilver
12:10:08 <benmachine> there are actually three days of 1990 for which I was born
12:10:09 <benmachine> if that helps
12:10:18 <quicksilver> skorpan: prove it!
12:10:56 <skorpan> quicksilver: i wasn't born then, i used wikipedia - which actually contradicts itself
12:10:58 <drhodes> zygospasm: never heard of a liff, but I just looked it up and it appears a liff would be a collection of sniglets
12:11:36 <quicksilver> I have eaten many of both and they seemed the same to me.
12:11:41 <kmc_> > let ((+1) -> x) = 3 in x
12:11:41 <zygospasm> quicksilver: it has a different name. ergo it's a different product ;-)
12:11:42 <lambdabot>   Illegal view pattern:  ((+ 1) -> x)
12:11:42 <lambdabot>  Use -XViewPatterns to enable view patt...
12:11:44 <kmc_> , let ((+1) -> x) = 3 in x
12:11:45 <skorpan> quicksilver: imitation is not flattery
12:11:45 <lunabot>  4
12:18:42 <fluxxen> is there a way to use a wild card in a if statement? like if (A B C) == (A B %) because I don't care for C. I tried _ as I have used as wildcard in pattern matching on the left side but won't work in my if statement.
12:18:44 * hackagebot upload: first-class-patterns 0.2.0 - First class patterns and pattern matching, using type families (ReinerPope)
12:19:04 <sproingie> speak of the devil
12:19:19 <fluxxen> sproingie are you talking about me? :)
12:19:36 <sproingie> naw, all this talk about pattern matching then that hackage upload pops up
12:19:46 <fluxxen> sproingie ah ok hehe
12:19:58 <sproingie> sometimes i think hackage is an AI that watches the channel then provides what we need right then
12:21:00 <Botje> fluxxen: use pattern matching
12:21:06 <ben_m> fluxxen: You could first bind both sides to a two-tuple in a let
12:21:14 <fluxxen> sproingie do you know such a wild card that I said? in my case if card == Card Ace Spades  I want the Spades to be a wild card because I don't care if it's a spade, heart or what ever it is
12:21:39 <Botje> fluxxen: use pattern matching
12:21:44 <kmc_> > case (1, 2, 3) of (1,2,_) -> "foo!"
12:21:45 <benmachine> fluxxen: try case
12:21:45 <lambdabot>   "foo!"
12:21:47 <benmachine> instead of if
12:21:48 <sproingie> it's _
12:21:50 <Botje> case card of (Card Ace _) -> ...
12:22:17 <fluxxen> ah ok cool gonna check up case thanks guys
12:22:21 <fluxxen> Botje ok cool thanks
12:22:22 <kmc_> fluxxen, the caveat is that pattern matching is structural on terms, rather than using a (==) operator you've defined.  that's probably what you want, though
12:22:55 <kmc_> fluxxen, you can pattern match on the left-hand side of a function equation as well
12:23:05 <kmc_> isWild (Card Ace _) = True
12:23:42 <fluxxen> ah ok this is what I worked out so far http://pastebin.com/m540821a6
12:23:50 <fluxxen> but only works on one Suit
12:23:57 <fluxxen> great tips, thanks
12:24:25 <sproingie> fluxxen: consider allowing the rank and suit as parameters then
12:24:43 <sproingie> or consider a general boolean predicate as a parameter
12:24:56 <sproingie> i.e. Card -> Bool
12:25:28 <fluxxen> sproingie i am following an exercise and Im not supposed to write such functions other then the ones stated
12:26:00 <kmc_> that's lame that they won't let you generalize your code
12:26:06 <sproingie> all right then.  if it solves the stated problem, you're fine.  you'll probably generalize it later
12:26:17 <fluxxen> kmc ye
12:26:39 <fluxxen> but if you saw my code, case will do fine there? if so Iam gonna read up on case and try implement it
12:26:47 <kmc_> yes
12:26:52 <fluxxen> ok cool
12:26:55 <fluxxen> thanks again
12:26:56 <kmc_> you could use "case" instead of if
12:27:21 <kmc_> or, you could break your (Add card hand) equation into two, (Add (Card Ace _) hand) and (Add _ hand)
12:27:24 <sproingie> you could actually add another pattern match
12:27:29 <sproingie> which will look the nicest
12:28:56 <sproingie> tho i'd probably use the case since it's easier to add arbitrary logic to it
12:29:23 <kmc_> yeah this function is really two things: a predicate, and a fold to count how many times that predicate is true on your custom list type
12:29:24 <sproingie> (e.g. rewriting it to take a predicate)
12:29:38 <sproingie> i think generalizing it into a fold is premature at this stage :)
12:30:01 <sproingie> it rather looks like the exercise is teaching folds
12:30:12 <sproingie> (eventually)
12:31:12 <benmachine> so I compiled a library from the darcs version and I want to play with it without installing it
12:31:32 <benmachine> how do I most easily do that (complicated by the fact that I already have an earlier version installed from cabal)?
12:33:09 <fluxxen> sproingie and kmc_ thanks alot for the help. when you guys say it, it's so clear what to do. but I guess I will see the easy solutions after a while since I just have programmed haskell in 1.5 weeks
12:33:28 <sproingie> have fun, that's what counts :)
12:34:21 <sproingie> huh, so i did darcs get --partial http://darcs.haskell.org/cabal/ and now it's hung at "Writing inventory 8/8"
12:35:00 <sproingie> ah nvm, *finally* it's applying patches
12:35:04 <fluxxen> sproingie yes I really do. yesterday I sat from 12 to 23 o clock with just a small break for food hehe
12:35:15 <jlouis> sproingie: darcs is no git :)
12:35:37 <sproingie> hell it's not even bzr
12:35:49 <sproingie> which i'll tell you is no speed demon
12:35:56 <jlouis> git /almost/ cheats w.r.t speed
12:36:19 <kmc_> copy-on-write is cheating?
12:36:22 <jlouis> especially for clones
12:36:24 <sproingie> i still don't grok git's vaguely defined "content tracking" philosophy
12:36:27 * Rotaerk uses bzr.
12:36:35 <kmc_> sproingie, what about it is ungrokable?
12:36:41 <sproingie> i use hg myself, i'm starting to migrate to bzr
12:37:04 <sproingie> kmc_: what that actually even means.  there is much handwaviness about all of it
12:37:25 <kmc_> a git repository is an append-only database of content-addressible objects: blobs (file contents), trees (filesystem entries), and commits (pointer to root tree + metadata)
12:37:48 <kmc_> and on top of that, some mutable pointers into that database
12:37:55 <sproingie> so it hashes every blob?  at what granularity?
12:38:09 <jlouis> sproingie: it just snapshots the directory contents. This in turn means that things like diff file moves and the like happens on a heuristic
12:38:24 <kmc_> the DB is an associative data structure.  the key for any object is its SHA1 hash
12:38:32 <kmc_> the key for a blob is the SHA1 hash of the entire file
12:39:09 <sproingie> ok, that sounds actually normal.  the explanations of this usually makes it sound far more magical
12:39:19 <kmc_> and yes, there's no special treatment of moves in the store.  it has heuristics to recognize that file A in commit X is very similar to file B in commit X~1
12:39:24 <kmc_> err X^1?
12:39:37 <jlouis> X^ :)
12:39:42 <kmc_> yeah
12:39:51 <jlouis> which is the same as X^1 IIRC
12:40:09 <sproingie> the explanations i hear make it sound like if you cut a block from the middle of one file and added it into another, that it would track that as one logical move and not two file changes
12:40:18 <kmc_> so git has a really simple data model, and some fairly complicated ways to manipulate it (can you say octopus merge?)
12:40:24 <kmc_> it's definitely a few-nouns, many-verbs system
12:40:25 <sproingie> which sounds quite magical
12:40:50 <jlouis> sproingie: it is a heuristic that figures that kind of stuff out. It might fail in principle
12:41:03 <kmc_> sproingie, to my knowledge there's nothing of that sort in the database.  any history browser tool is free to present history in an intelligently compressed wayi
12:41:15 <jlouis> In practice, it fails rarely
12:41:33 <kmc_> (there is also some transparent differential compression of blobs)
12:42:49 <kmc_> the immutable database is really nice and should warm any functional programmer's heart :)
12:43:17 <kmc_> for example, branching is as simple as copying a pointer
12:43:33 <sinelaw> woohoo, 531MB of #haskell logs are now on my local computer.
12:43:39 <sinelaw> just need to find a use
12:43:54 <tristes_tigres> Hi !
12:44:05 <skorpan> sinelaw: grep for e-mail addresses and sell to the highest bidder
12:44:17 <kmc_> hi :)
12:44:24 <sproingie> probably a lot of useful explanations in there.  somewhere.
12:44:30 <sinelaw> skorpan, i don't think i'll find any
12:44:33 <sinelaw> many
12:44:39 <tristes_tigres> I find myself writing a lot of \(SomeDataConstructor s) -> s, is there more elegant way ?
12:44:51 <Botje> write a function for it and use that
12:45:03 <kmc_> tristes_tigres, you can declare SomeDataConstructor as a record
12:45:04 <sinelaw> tristes_tigres, something with @ I think
12:45:11 <kmc_> then you will get those functions for free
12:46:19 <tristes_tigres> kmc sinelaw: thanks, but they are not mine datatypes
12:46:31 <kmc_> tristes_tigres, then you can just define the function yourself
12:46:42 <tristes_tigres> ok? thanks
12:47:02 <kmc_> unFoo (Foo a) = a
12:47:29 <ben_m> Most built in types already have those functions defined
12:47:43 <ben_m> At least I think so
12:48:08 <benmachine> newtypes tend to have them
12:48:16 <benmachine> for other types, it doesn't really make sense
12:48:35 <ben_m> I can only think of fromJust right now ... :/
12:49:08 <ben_m> That does more though, doesn't it?
12:49:10 <FunctorSalad> yay I implemented this pointfree case thing
12:49:53 <FunctorSalad> though I had to "fork" src-exts for it :-(
12:50:01 <skorpan> don't people feel a bit guilty when posting "+1!" to haskell-cafe?
12:50:15 <FunctorSalad> skorpan: why? I almost did
12:50:28 <benmachine> if everyone does it we'll run out of e-paper
12:50:59 <skorpan> FunctorSalad: i always almost do but then i feel like people will get pissed about having to read "+1"
12:51:10 <kmc_> for non-newtypes, you have more than one
12:51:23 <skorpan> i can imagine that e.g. richard stallman could rant quite a bit about "+1" posters
12:51:26 <nibro> FunctorSalad: if it's backwards compatible then pass me a patch and I'll put it in under UnknownExtension :-)
12:51:59 <benmachine> ben_m: it does less :P on the basis that when it gets Nothing it just chokes
12:52:14 <FunctorSalad> nibro: oh hi didn't know you were here :) well, I had to add a new rule to the parser
12:52:33 <Vanadium> At least post (+1) so it parses correctly
12:52:56 <FunctorSalad> nibro: (not a new rule, a new alternative in one of the rules)
12:53:12 <nibro> FunctorSalad: I suppose the tricky thing is what it does to the AST, no?
12:53:35 <nibro> FunctorSalad: Did you change the Case node to hold a Maybe Exp, or did you add a new node completely?
12:53:45 <FunctorSalad> nibro: added a new nullary constructor to Exp and Pat
12:54:01 <nibro> FunctorSalad: Hmm, I see
12:54:04 <FunctorSalad> ("AD_HOC_POINTFREE_CASE_TOKEN") *g*
12:54:13 <nibro> :)
12:54:53 <FunctorSalad> nibro: the syntax is "case .. of blah"
12:55:07 <zygospasm> that doesn't look very point free
12:55:12 <zygospasm> i can see two points right ther :)
12:55:32 <ben_m> pointfree tends to have more points usually
12:55:40 <ben_m> As in function compositon etc.
12:55:43 <FunctorSalad> it probably breaks arithmetic sequence syntax, but could probably be re-fixed by postprocessing
12:56:09 <zygospasm> wasn't "case of ..." suggested ages ago?
12:56:33 <benmachine> case of sounds more natural to me
12:56:56 <nibro> FunctorSalad: I would probably prefer to have a separate EmptyCase node (or whatever color you want on the shed) for this specific feature, rather than a nullary constructor that's only useful in this exact context
12:56:59 <FunctorSalad> I also added pointfree case alternatives, like "case thing of Just .. -> (+1)"
12:57:22 <nibro> FunctorSalad: ah, that's a different thing then
12:57:25 <FunctorSalad> nibro: but I also allow expressions like "case (Just ..) of"
12:57:28 <benmachine> isn't that the same as Just _
12:57:36 <benmachine> ish
12:57:41 * benmachine is confused
12:57:47 <FunctorSalad> benmachine: no, it rewrites to "Just x -> (+1) x"
12:57:48 <nibro> FunctorSalad: how is case (Just ..) of pointsfree?
12:57:57 <benmachine> oh
12:57:57 <zygospasm> FunctorSalad: do you allow that for other pattern bindings too?
12:58:04 <nibro> FunctorSalad: ah, me and benmachine shared the same confusion
12:58:08 <FunctorSalad> nibro: means "(\x -> case (Just x) of"
12:58:17 * byorgey thinks this is getting a little silly
12:58:18 <benmachine> this is sounding more complicated
12:58:26 <zygospasm> FunctorSalad: let f (Just ..) = map (+1)
12:58:30 <benmachine> more simple = more better
12:58:30 <FunctorSalad> yes but about the two different rules (one for the scrutinee, one for alts)
12:58:42 <zygospasm> go go "case of"
12:58:45 <iaefai___> Does anyone know if there is a way to install regex-posix on windows?
12:58:45 <nibro> FunctorSalad: when would it ever be useful to do that?
12:59:07 <quicksilver> iaefai___: should be possible if you install the posix regexp libs into cygwin
12:59:13 <quicksilver> iaefai___: (I guess, I've never tried)
12:59:17 <nibro> iaefai: rumor says you can do it under cygwin, but it requires dark rituals around midnight
12:59:31 <iaefai___> I prefer avoiding cygwin
12:59:35 <FunctorSalad> nibro: it was hardly any extra effort, since I'm parsing the ".." in the production where "_" and so on are parsed
12:59:38 <azumanga> Is ghci the best way to use haskell interactively? I'm finding the commands don't work quite the same as in files (I can't import for example)
12:59:54 <iaefai___> azumanga:  :modules +name
12:59:59 <FunctorSalad> then I just subst the TOKENs with the fresh vars in the AST
13:00:06 <nibro> FunctorSalad: I still don't see why case (Just ..) of would be useful for anything... ?
13:00:07 <iaefai___> haskell platform basically comes with mingw right?
13:00:20 <sproingie> iaefai___: no, just enough mingw to get things to compile
13:00:22 <zygospasm> azumanga: import should work(ish) in recent versions of ghci, as a synonym for :m +
13:00:45 <zygospasm> azumanga: but yeah, ghci is an interactive IO do-expression, not an interactive haskell shell
13:00:49 <sproingie> iaefai___: you'll need msys to get most other things to compile, like haskell itself
13:00:53 <azumanga> iaefai___: Thanks
13:01:05 <Cale> Heh, it would be pretty funny if the LHC actually destroyed any universe in which it was turned on, and because of this, we observe it failing to work in ever more elaborate ways.
13:01:11 <FunctorSalad> nibro: didn't think about it... but the nesting in the case alternatives seems useful
13:01:16 <Cale> http://www.theregister.co.uk/2009/11/05/lhc_bread_bomb_dump_incident/
13:01:36 <benmachine> woo quantum immortality
13:01:39 <zygospasm> Cale: there were a couple of reputable scientists suggesting much the same a week or so ago
13:01:53 <FunctorSalad> I also allow multiple "..", like "case .. + .. of"
13:01:56 <sproingie> "a bit of baguette on the busbars", thought perhaps to have been dropped by a bird.
13:02:06 <FunctorSalad> which desugars to "(\x y -> case x + y of"
13:02:07 <nibro> FunctorSalad: in the case alternatives it would be useful, I agree
13:02:09 <sproingie> "boson busbars baffled by bungling baguette bird"
13:02:11 <zygospasm> FunctorSalad: you've crossed the Thin Line of Evil
13:02:19 <FunctorSalad> hehehe
13:02:20 <Cale> sproingie: ahaha
13:02:53 <jimmyjazz14> how might someone do something magical like the following...
13:02:58 <jimmyjazz14> foldl (\a b-> a b) (three) [1,2,3] where three a b c = (a,b,c)
13:03:13 <zygospasm> Cale: it's not quantum whatsits or anything like that. just that birds are much smarter than we are, and they don't want us catching up.
13:03:20 <saml> @type foldl
13:03:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:03:37 <FunctorSalad> nibro: in either case, of course it would be much better if at least the changes could somehow be auto-applied to new versions of exts
13:03:42 <jlouis> QuantumMonad?
13:04:00 <saml> > foldl (\a b -> (,,) a b) (1,2,3) [1,2,3]
13:04:01 <lambdabot>   Occurs check: cannot construct the infinite type:
13:04:01 <lambdabot>    a = c -> (a, b, c)
13:04:54 <FunctorSalad> nibro: (assuming there's no way to change the parser in a backwards-compatible way)
13:05:20 <nibro> FunctorSalad: well, as it doesn't clash with existing syntax there's no problem with it, it's just the purity of the AST I worry about :-)
13:05:29 <saml> > foldl (\(x,y,z) b -> (x,y,b+z)) (1,2,3) [1,2,3]
13:05:30 <lambdabot>   (1,2,9)
13:05:39 <nibro> FunctorSalad: but if it gets enough support to be "official", then obviously it should be included
13:06:40 <twanvl> I like the \{pats -> exp; pats -> exp; ...} idea, that syntax makes more sense to me than "case of"
13:06:45 <FunctorSalad> nibro: it does clash with arithmetic sequence syntax (3 new shift/reduce conflicts). ".." was the least used token I could find which is also easy to type ;)
13:07:40 <zygospasm> twanvl: ooh, nice, i've always wanted a lambda like that :)
13:07:53 <iaefai___> Any ideas what you would use to extract lzma
13:08:07 <FunctorSalad> hmm to me it seems more case-y than lambda-y
13:08:12 <nibro> FunctorSalad: why not use _ instead?
13:08:28 <FunctorSalad> nibro: already has a meaning in patterns
13:08:46 <FunctorSalad> maybe add a new token "__", but that would require a lexer change
13:08:52 <twanvl> what does your .. mean in patterns?
13:09:17 <nibro> FunctorSalad: ah, I keep forgetting about the pattern stuff, I'm personally less appealed by those
13:09:17 <flux> functorsalad, _ is its own token?
13:09:19 <FunctorSalad> twanvl: allows giving a function on the right of "->"
13:09:35 <FunctorSalad> twanvl: (which will be applied to the values of the "..")
13:09:49 <FunctorSalad> flux: yes
13:10:03 * nibro personally dislikes the whole pointless thing, but bows to the masses
13:10:10 <zygospasm> FunctorSalad: i really don't like the way it makes case patterns different from all other patterns
13:10:21 <FunctorSalad> nibro: I needed just that recently :) (the pointfree case alternatives)
13:10:31 * copumpkin is tempted to just write -1 on -cafe just to piss people off
13:11:05 <FunctorSalad> the advantage over a "fold" function is that you don't get significant ordering
13:11:06 <nibro> FunctorSalad: "needed" is quite different from "wanted" :)
13:11:33 <FunctorSalad> (which is important for a 10-constructor type)
13:11:38 <tommd> copumpkin: You should put (-1) just to be explicit that you don't mean (-) 1.
13:11:44 <copumpkin> lol
13:11:57 <zygospasm> FunctorSalad: 10-constructor type? you're doing it wrong! ;-)
13:12:03 <zygospasm> j/k
13:12:10 <copumpkin> needs at least 11
13:12:12 <FunctorSalad> zygospasm: ASTs
13:12:31 <copumpkin> of which 10 constructors are always impossible to provide non-bottom values to
13:13:29 <copumpkin> data X = X | X2 (forall x. (x :== x) -> Void) | X3 Void
13:13:38 <FunctorSalad> "<zygospasm> FunctorSalad: i really don't like the way it makes case patterns different from all other patterns" <-- agreed, I didn't say it's finished ;)
13:14:11 <FunctorSalad> don't know if it would work for any pattern
13:14:18 <jimmyjazz14> is there a way to convert a list into the argument for a function ?
13:14:30 <jimmyjazz14> arguments that is
13:14:32 <twanvl> what is the advantage of "(Just ..) -> f" compared to "(Just x) -> f x"? Is it really that bad to have an 'x' in there?
13:14:42 <copumpkin> yep
13:14:48 <FunctorSalad> twanvl: same arguments as for PL in general
13:14:50 <byorgey> jimmyjazz14: you can do it for any particular function.  but not in general.
13:15:03 <byorgey> jimmyjazz14: for function f you can just write  applyf [x,y,z] = f x y z
13:15:05 <twanvl> FunctorSalad: except that this needs a new syntax
13:15:30 <zygospasm> jimmyjazz14: there's an evil type class hack which can allow that for a general function of type a -> a -> ... -> a -> b
13:15:48 <byorgey> jimmyjazz14: you can even do  apply3 f [x,y,z] = f x y z  which will work for any three-argument function
13:15:48 <zygospasm> zygospasm: but i have a rule: if you can't work it out on your own, you shouldn't use it ;-)
13:16:08 <ski> FunctorSalad : imho, that `..' syntax is bad .. it has a non-composable feel
13:16:23 <ski> zygospasm : `let f . Just = map (+1)' :)
13:16:23 <copumpkin> zygospasm: does working through it with yourself and talking to yourself count as working on your own?
13:16:23 <jimmyjazz14> byorgey: cool combined with template haskell thats about what I was thinking
13:16:50 <FunctorSalad> ski: if the transformation is applied bottom-up, I don't think there's a problem with nested uses
13:16:56 <FunctorSalad> if that's what you mean
13:17:20 <ski> FunctorSalad : similar to the `cut' syntax in Scheme SRFI 26
13:17:24 <FunctorSalad> (I use everywhereM, think that's bottom-up)
13:17:39 <FunctorSalad> ski: don't know scheme
13:18:14 <ski> FunctorSalad : the problem is that `case f (g ..) of blah' would not be the same as `let x = g .. in case f x of blah' (or would it ?)
13:18:52 <FunctorSalad> (now I don't even know whether I should post it to -cafe, lest I'll be expected to implement all the bikeshedding results :))
13:18:55 <ski> (the Scheme was just for reference/comparision, if you (or anyone else) know about it (here <http://srfi.schemers.org/srfi-26/srfi-26.html> it is))
13:19:30 <FunctorSalad> ski: ".." in expressions is only legal in the scrutinee of a "case" currently
13:19:48 <ski> iirc, i can't lift out sub-expressions without regard to whether `..' occurs in a sub-expression or not
13:20:13 <ski> in this sense, it is as non-composable as `return',`break',`continue' in C, et.c. and as `!' (the cut) in Prolog
13:20:29 <ski> s/iirc/iiuc/
13:21:42 <ski> twanvl : something like that syntax would be fine, yes
13:21:49 <shellsage> What is the best structure for credentials?
13:21:59 <shellsage> Would it be something like: data Credentials = ...
13:22:47 <FunctorSalad> ski: what would your second example deguar too?
13:23:09 <FunctorSalad> (the first one desugars to `(\x -> case f (g x) of blah)' in my implementation)
13:24:03 <zygospasm> map (case of Just -> (+3); Nothing -> 0) [Just 1, Just 2, Nothing] ~> [4, 5, 0]
13:25:00 <kmc_> Nothing -> const 0 ?
13:25:11 <zygospasm> (case of (:) -> (,)) [1,2,3] ~> (1,[2,3])
13:25:26 <FunctorSalad> ^^
13:25:39 <kmc_> woah
13:25:50 <ski> FunctorSalad : which example ?
13:25:59 <FunctorSalad> <ski> FunctorSalad : the problem is that `case f (g ..) of blah' would not be the same as `let x = g .. in case f x of blah' (or would it ?)
13:26:11 <azumanga> Is there any way I can get a more descriptive message than : D.hs: user error (Pattern match failure in do expression at D.hs:17:10-21). I can't figure out the problem.. :\
13:26:31 <kmc_> azumanga, you can hpaste your code and we'll try to find the problem :)
13:26:42 <ski> the second expression there is what i would expect i could refactor the first expression into, ignoring whether `..' occurs in a subexpression or not
13:26:45 <iaefai___> Is there a way of telling cabal to link the program in with a certain library? libregex.a specifically
13:26:49 <zygospasm> azumanga: you're doing a pattern-match in D.hs on line 17, characters 10-21 and it's failing :)
13:27:12 <zygospasm> azumanga: you could use Debug.Trace.trace to print out the thing you're matching so you can see why it doesn't match
13:27:15 <ski> but the second expression there is actually meaningless (afaict) .. so it wouldn't desugar at all
13:27:19 <ski> (which was the point)
13:28:03 <FunctorSalad> hmm
13:28:54 <FunctorSalad> ski: but don't binders generally break the "move subexpessions around" property? :)
13:29:07 <FunctorSalad> the "case" is a binder here
13:29:19 <FunctorSalad> and the ".." sort-of an deBruijn index
13:29:24 * ski doesn't care *that* much if the syntax for what twanvl suggested is `case of Just x -> x + 3; Nothing -> 0' or `\{Just x -> x + 3; Nothing -> 0}' .. the abstract syntax has the right idea, imo
13:29:48 <ski> FunctorSalad : yes, but `..' is not a proper name
13:30:21 <seanmcl> Do you have to tell ghci to do something special to use the debugger?  I load my project, then type :break M1.M2.val, and it replies "No breakpoints found at that location." even though it is an exported function from a loaded module.
13:30:57 <ski> (FunctorSalad : as you say, a bit like a (zero) deBruijn index .. how to get greater indices .. and the modularity properties of this is as bad as deBruijn indices)
13:31:01 <FunctorSalad> I don't understand "the abstract syntax has the right idea"?
13:31:29 <ski> the abstract syntax of `case of Just x -> x + 3; Nothing -> 0' and `\{Just x -> x + 3; Nothing -> 0}' is the same .. it's just the concrete syntax that differs
13:31:44 <ski> the abstract syntax of `case .. of Just x -> x + 3; Nothing -> 0' is different
13:32:22 <ski> (indicentally, in OCaml, the corresponfing code is `function SOME x -> x + 3 | NONE -> 0')
13:32:43 <lament> head explodes
13:33:07 <ben_m> lament: Oh I have that everytime I try to understand what they're talking about in here
13:33:08 <FunctorSalad> ski: don't all three (haskell) examples desugar to the same?
13:34:06 <ski> the two first avoid the troublesome (imo) `..' construction
13:34:10 <ski> the latter doesn't
13:34:15 <FunctorSalad> ok I think I'm convinved that the ".." in the scrutinee is not that great
13:34:22 <ski> the intended semantics of them is of course the same
13:34:53 <FunctorSalad> partly because you can just postcompose the pointfree case expressions with "Just" to achieve "case (Just ..) of blah"
13:35:20 <FunctorSalad> I don't like "case of" much though... how about "pcase"?
13:35:34 <mmorrow> "case f (g e1) of p -> e2" would only really be different than "let x = g e1 in case f x of p -> e2" if `x' was used in e2, but even then the different would only be space-wise
13:36:28 <mmorrow> if `x' wasn't use in e2, you could inline it and in the worst case nothing would improve
13:36:41 <FunctorSalad> ski: but what about the pointless case alternatives?
13:36:50 <ski> (mmorrow : `x' is assumed fresh :)
13:37:03 <mmorrow> in that case
13:37:07 <FunctorSalad> (you don't expect to be able to move around patterns)
13:37:22 <fadax> hey
13:37:23 <ski> FunctorSalad : i'm not sure what you mean ?
13:37:55 <FunctorSalad> ski: "case (1,2) of ( .. , .. ) -> (+)" (silly example)
13:38:07 <ski> FunctorSalad : as for `pcase', i think `\{<pat0> -> <expr0> ; <pat1> -> <expr> ; ...}' would be more syntactically pleasing
13:38:13 <jmcarthur_work> nice, unreal dev kit available for noncommercial use for free now
13:38:25 <ski> FunctorSalad : ok, that
13:38:35 <ski> well, i don't want `..' in patterns either :)
13:38:41 <fadax> i've got a constant -   fList :: Num a => [ (String, a -> a -> a) ]
13:38:46 <fadax> fList = ("+", (+)) : ("-", (-)) : ("*", (*)) : []
13:38:51 <ski> maybe `case (1,2) of (,) -> (+)' .. i'm not sure
13:39:11 <fadax> i'm trying to use haskells built in lookup function to lookup "*" for example...
13:39:17 <fadax> can someone help me with this please?
13:39:24 <FunctorSalad> ski: but that would silently continue to work when you change the arity of the constructor
13:39:26 <jmcarthur_work> oh i put that in the wrong channel
13:39:29 <jmcarthur_work> sorry
13:39:48 <FunctorSalad> (and if (+) is polymorphic enough)
13:39:49 <fadax> i try:   lookup "*" fList
13:39:56 <Twey> :t (-)
13:39:57 <lambdabot> forall a. (Num a) => a -> a -> a
13:39:58 <fadax> this is meant to return a value of type Maybe a
13:39:59 <fadax> ?
13:40:03 <Twey> Looks good to me
13:40:23 <FunctorSalad> ski: also it would require the preprocessor to know the arity
13:40:27 <ski> FunctorSalad : if you want "pointless" nested patterns, then maybe one can allow `case foo of Just . (,) -> bar; Nothing -> baz' similar to `let f . (,) = g in ..f..' .. however, this is a bit radical, i think
13:40:37 <mmorrow> , let op x = maybe (error (x++"!")) id (lookup x (zip ["+","*"] [(+),(*)])) in op "*" 4 (op "+" 7 3)
13:40:38 <lunabot>  40
13:40:51 <mmorrow> , let op x = maybe (error (x++"!")) id (lookup x (zip ["+","*"] [(+),(*)])) in op "*" 4 (op "/" 7 3)
13:40:53 <lunabot>  luna: /!
13:41:16 <ski> FunctorSalad : i'm not sure if "silently continue to work when you change the arity of the constructor" is a pro or a con
13:41:22 <mmorrow> @src maybe
13:41:22 <lambdabot> maybe n _ Nothing  = n
13:41:22 <lambdabot> maybe _ f (Just x) = f x
13:41:34 <mmorrow> @src lookup
13:41:34 <lambdabot> lookup _key []          =  Nothing
13:41:35 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
13:41:35 <lambdabot>                         | otherwise = lookup key xys
13:41:37 <Twey> > lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))] `fromJust` 3
13:41:38 <lambdabot>   -0.375->
13:41:38 <lambdabot>    3.375
13:41:38 <lambdabot>  -0.75->
13:41:38 <lambdabot>    3.75
13:41:40 <lambdabot>  -1.5->
13:41:42 <lambdabot> [5 @more lines]
13:41:44 <Twey> > lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))] `fromJust` 3 5
13:41:45 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:41:46 <lambdabot>    `GHC.Num.Num t' arising f...
13:41:58 <Twey> Ho hum
13:42:01 <Twey> > lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))] `fromJust` 3 $ 5
13:42:02 <lambdabot>   -2.0
13:42:05 <fadax> what??
13:42:13 <FunctorSalad> ski: but needing semantic information for the preprocessor is a con from a lazyness standpoint ;)
13:42:27 <mmorrow> @unpl lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))] `fromJust` 3 $ 5
13:42:27 <lambdabot> (fromJust (lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))]) 3 5)
13:42:32 <mmorrow> @pl lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))] `fromJust` 3 $ 5
13:42:32 <lambdabot> (lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))] `fromJust` 3) 5
13:42:38 <fadax> what are you doing?
13:42:38 <Twey> Hey
13:42:44 <Twey> It wasn't point-free to start with :þ
13:42:53 <mmorrow> apparently it was.. :)
13:43:04 <ski> FunctorSalad : i want something that, if later accepted to be implemented proper in an implementation, is "right" :)
13:43:15 <ski> (nothing less will do)
13:43:20 <fadax> Twey
13:43:26 <Twey> fadax: Hello!
13:43:33 <Twey> Isn't that what you were trying to do?
13:43:38 <Twey> Lookup a function?
13:43:58 <fadax> well yes i need to lookup a function and then apply it  to an expression
13:44:06 <mmorrow> , let op x = maybe (error (x++"!")) id (lookup x (zip ["+","*"] [(+),(*)])) in op "*" 4 (op "/" 7 3)
13:44:07 <lunabot>  luna: /!
13:44:12 <mmorrow> , let op x = maybe (error (x++"!")) id (lookup x (zip ["+","*"] [(+),(*)])) in op "*" 4 (op "+" 7 3)
13:44:13 <mmorrow> grr
13:44:13 <lunabot>  40
13:44:15 <fadax> but what are you doing with fromJust (?)  and 3, 5
13:44:27 <mauke> 3 and 5 are the function arguments
13:44:37 <fadax> oh
13:44:40 <mmorrow> @let optab = zip ["+","*"] [(+),(*)]
13:44:41 <lambdabot>  Defined.
13:45:06 <fadax> so what is fromJust
13:45:08 <FunctorSalad> ski: "Let's make this easy for the *computer*" ;) (from some language draft which made fun of lisp, IIRC)
13:45:08 <mmorrow> @let op x = case lookup x optab of Just o -> o; Nothing -> error x
13:45:09 <lambdabot>  Defined.
13:45:12 <Twey> fromJust converts the Maybe (a -> a -> a) that we get from lookup to the a -> a -> a that we need to apply
13:45:31 <fadax> oh right
13:45:36 <mmorrow> > op "*" 4 (op "+" 7 3)
13:45:36 <fadax> but what about the function 'maybe'
13:45:37 <lambdabot>   40
13:45:42 <mmorrow> @src maybe
13:45:43 <lambdabot> maybe n _ Nothing  = n
13:45:43 <lambdabot> maybe _ f (Just x) = f x
13:45:44 <fadax> isn't that supposed to do that?
13:45:48 <Twey> It does
13:45:55 <mmorrow> it essentially wraps a "case" on a Maybe value into a function
13:46:03 <Twey> The difference is that fromJust just dies horribly if the argument it's supplied is Nothing
13:46:19 <Twey> Which obviously is a bad thing in most cases, but it's good for demonstration.  ☺
13:46:21 <mmorrow> , fromJust Nothing
13:46:23 <lunabot>  luna: Maybe.fromJust: Nothing
13:46:29 <fadax> hmm ok
13:46:39 <mmorrow> , maybe 0 length [0..9]
13:46:40 <Twey> maybe allows you to include a value to be returned instead if a Nothing is provided
13:46:40 <mauke> fromJust = fromMaybe (error "Maybe.fromJust: Nothing")
13:46:41 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe [a]'
13:46:48 <mmorrow> , maybe 0 length (Just [0..9])
13:46:50 <lunabot>  10
13:46:58 <mmorrow> , maybe 0 length Nothing
13:46:59 <lunabot>  0
13:47:03 <mauke> fromMaybe = flip maybe id
13:47:27 <mmorrow> , either show id (Right "aaaaaaaaaassssssddddddffffffffff")
13:47:29 <lunabot>  "aaaaaaaaaassssssddddddffffffffff"
13:47:35 <mmorrow> , either show id (Left [0..])
13:47:37 <lunabot>  "[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
13:48:03 <mmorrow> , either (show . maybe 0 length) id (Left (Just [0..9]))
13:48:04 <lunabot>  "10"
13:48:22 <mmorrow> either is the analogous function for Either as maybe for Maybe
13:48:43 <mmorrow> @let list nil _ [] = nil; list _ cons (x:xs) = cons x xs
13:48:44 <lambdabot>  Defined.
13:48:47 <fadax> :S
13:49:28 <fadax> maybe 0 id (lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))]) 3 5
13:49:35 <fadax> should this work ?
13:49:42 <mmorrow> @let myfoldl f = fix (\k z xs -> list z (\x xs -> k (f z x) xs))
13:49:43 <lambdabot>  <local>:7:28:
13:49:43 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t1...
13:50:12 <ski> FunctorSalad : as for `let f . Just . (,) = g in ..f..' and `case blah of Just . (,) -> g' .. this would either require handling `.' specially (ick !), or require allowing this kind of thing generally (meaning how much ?), and also establish some kind of (new) rules to determine which token on the left-hand-side of the `=' which is being defined (and which on the left of `->' is not a variable to bind locally) .. and this sou
13:50:13 <mmorrow> @let myfoldl f = fix (\k z -> list z (\x xs -> k (f z x) xs))
13:50:14 <lambdabot>  Defined.
13:50:26 <mmorrow> > myfoldl (+) 0 [0..1000]
13:50:28 <lambdabot>   500500
13:50:53 <mmorrow> @let myfoldr f = fix (\k z -> list z (\x xs -> f x (k z xs) xs))
13:50:53 <lambdabot>  Defined.
13:51:02 <FunctorSalad> ski: hmm I find that hard to read
13:51:07 <mmorrow> > myfoldr (++) [] (replicate 3 [0..4])
13:51:08 <ski> which ?
13:51:08 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = [t1] -> t1
13:51:21 <mmorrow> gah
13:51:31 <FunctorSalad> ski: the composition of patterns, if I understand you correctly
13:51:31 <mmorrow> @let myfoldr_ f = fix (\k z -> list z (\x xs -> f x (k z xs)))
13:51:32 <lambdabot>  Defined.
13:51:37 <mmorrow> > myfoldr_ (++) [] (replicate 3 [0..4])
13:51:38 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4]
13:51:52 <mmorrow> maybe,either,list FTW!
13:52:05 <FunctorSalad> ski: actually I don't care about ".." in nested positions in patterns so much, but ".." still allows "partial application" of patterns
13:52:05 <mmorrow> bool to i guess
13:52:08 <mmorrow> too
13:52:26 <ski> FunctorSalad : i agree that it might not always be that nice .. i don't know what would be better :/ .. but i don't think `case blah of Just (.. , ..) -> g' is the solution, though
13:52:29 <milaz> @src fix
13:52:30 <lambdabot> fix f = let x = f x in x
13:52:44 <mmorrow> @let bool false _ False = false; bool _ true True = true
13:52:45 <lambdabot>  Defined.
13:52:58 <mmorrow> , fix (\x -> 42)
13:52:59 <lunabot>  42
13:53:14 <benmachine> mmorrow: isn't that kind of backwards
13:53:23 <mmorrow> the fix def?
13:53:25 <benmachine> well, I suppose not
13:53:25 <mmorrow> or bool
13:53:27 <benmachine> no bool
13:53:33 <malie> why do i have to import Control.Applicative for ((*3) `fmap` (+5) $ 100) to work?
13:53:37 <benmachine> bool a b c = if c then b else a
13:53:44 <mmorrow> yeah, i always can't decide which way to write it
13:53:51 <mmorrow> , fromEnum 0 :: Bool
13:53:53 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
13:53:58 <mmorrow> , toEnum 0 :: Bool
13:53:59 <lunabot>  False
13:54:12 <mmorrow> was why i chose that way
13:54:26 <ski> FunctorSalad : one idea might be to allow a branch like `Just (.. , ..) -> g .. ..' .. where `..' is like a positional variable (so order is important) .. but i'm not sure how good this would nest .. and introducing significant ordering of subexpressions feels a bit bad, too :/
13:54:38 <fadax> maybe 0 id (lookup '-' [('+', (+)), ('-', (-)), ('/', (/)), ('*', (*))]) 3 5   <-- how come this doesn't work? if i use the id function on the result of the lookup it will return itself (ie the function?)
13:55:03 <FunctorSalad> ski: what's the point of having them on the RHS?
13:55:07 <malie> with Prelude.fmap it says "No instance for (Functor ((->) a))"
13:55:20 <malie> which ((->)a) is
13:55:24 <ski> (maybe "like a positional variable" wasn't the best of expression .. but just maybe the point got through)
13:55:25 <mauke> import Control.Monad.Instances
13:55:36 <mmorrow> fold con_1 .. con_n (Con_i x_1 .. x_m) = con_i x_1 .. x_m
13:55:49 <mmorrow> for i `in` [1..n]
13:56:25 <mmorrow> data T = Con_1 x_11 .. x_1m1 | .. | Con_n x_n1 .. x_nmn
13:56:25 <FunctorSalad> mmorrow: like that, except that I don't want significant constructor ordering
13:56:33 <malie> mauke, Control.Monad.Instances is needed for fmap to work?
13:56:55 <ski> FunctorSalad : it would be slightly better that way than just `Just (.. , ..) -> g' (and you could do stuff like `Just (.. , ..) -> g (bar ..) (baz (flip ..) x)')
13:57:38 <twanvl> ski: then just give it a name
13:57:38 <malie> seems crazy at first
13:57:59 <mmorrow> fadax: the Nothing "slot" (0 in your example) has to be the same type as the type of [(_,this)] in the list
13:58:09 <ski> (FunctorSalad : one sense in which it would be better is that the types of the two sides in `f (Just (.. , ..)) = g (bar ..) (baz (flip ..) x)' would at least have the same time)
13:58:30 <mmorrow> maybe (\_ _ -> 0) id (lookup '-' [('+', (+)), ('/', (/)), ('*', (*))]) 3 5
13:58:32 <mmorrow> , maybe (\_ _ -> 0) id (lookup '-' [('+', (+)), ('/', (/)), ('*', (*))]) 3 5
13:58:33 <lunabot>  0.0
13:58:42 <mmorrow> , maybe (\_ _ -> 0/0) id (lookup '-' [('+', (+)), ('/', (/)), ('*', (*))]) 3 5
13:58:43 <lunabot>  NaN
13:59:38 <ski> twanvl : i'm not sure the feature i suggested (`Just (.. , ..) -> g .. ..') would be that good .. i'm only claiming (imo) it would be slightly better than the one it was an attempted clean-up(?) of (`Just (.. , ..) -> g')
14:00:08 <FunctorSalad> ski: maybe "case x of Just -> (+1); Nothing -> 0" is best (simplest), but I don't know how to get hold of the arity from a preprocessor called by -pgmF
14:00:37 <fadax> ooh i see ok thanks mmorrow
14:00:44 <kmc_> it'd confuse me that the branches have different types
14:00:45 <twanvl> "case x of Just -> (+1); Nothing -> 0" suggests that you are pattern matching a function
14:00:48 <kmc_> even though it sugars out right
14:01:06 <ski> FunctorSalad : i understand your point .. i just don't want a bad (imo) feature in Haskell :)
14:01:09 <twanvl> as if you could write  case Just of Just -> "just"; Nothing -> "nothing"
14:01:50 <ski> twanvl : yes, that's the other weakness
14:02:24 <medfly> isn't there maybe?
14:02:38 <ski> yes
14:02:41 <twanvl> maybe
14:02:46 <medfly> :-)
14:03:36 <ski> (medfly : the `Just' and `Nothing' here was just an example of the feature under scrutination, nothing more)
14:04:28 <FunctorSalad> data MaybeAlgebra a r = { justHandler :: a -> r; nothingHandler :: r }
14:04:39 <FunctorSalad> how about generating these guys with TH?
14:04:59 <FunctorSalad> then you can even decide whether to use positional or named syntax
14:06:46 <ski> FunctorSalad : it could be nice if something like `data Algebra Maybe r a = {nothing :: r , just :: a -> r}' was autogenerated from `data Maybe a = Nothing | Just a'
14:07:02 <ski> though i suppose that would require kind polymorphism, to begin with
14:07:03 <gwern> @wn syzygy
14:07:05 <lambdabot> *** "syzygy" wn "WordNet (r) 2.0"
14:07:06 <lambdabot> syzygy
14:07:06 <lambdabot>      n : the straight line configuration of 3 celestial bodies (as
14:07:06 <lambdabot>          the sun and earth and moon) in a gravitational system
14:07:11 <kmc_> Algebra would be a data family?
14:07:22 <kmc_> seems like it'd need variable arity -- i guess that's the kind polymorphism?
14:07:24 <ski> (`Algebra' being something like a `data' famuly)
14:07:29 <FunctorSalad> ski: "Algebra (Maybe a) r" you mean I suppose
14:07:48 <FunctorSalad> (avoids kind poly)
14:07:48 <ski> FunctorSalad : hm, i'm not sure
14:08:29 <kmc_> and there'd be some apply :: Algebra a r -> a -> r?
14:08:45 <iaefai> Star Wars: "Luke, Obi-Wan never told you about the true nature of the force!"  #haskell: "Luke, kmc never told you about the true nature of the monad!"
14:08:50 <FunctorSalad> kmc_: yeah
14:08:54 <ski>   Algebra :: forall_kind k. k -> * -> k  -- was what i had in mind .. hm
14:09:29 <FunctorSalad> ski: why not just make Algebras for fully applied types?
14:09:32 <kmc_> the monad that can be told is not the eternal monad
14:09:38 <FunctorSalad> (the original type can still be higher-kinded)
14:09:39 <twanvl> I though an algebras had something to do with folds
14:09:58 <ski> (btw, i would like `Derivate' and `Zipper' as (optionally) auto-generated data families, as well)
14:10:12 <ski> twanvl : they do
14:10:52 <FunctorSalad> with recursive types you have a choice of one-layer vs recursive
14:10:59 <FunctorSalad> "fold" means the recursive one I think
14:11:20 <ski> FunctorSalad : i'm not sure whether `Algebra (Maybe a) r' would be ok or not .. i would need to think on it
14:11:20 <FunctorSalad> but they are tricky for GADTs
14:11:52 <ski> (one can just punt and refuse to autogenerate for "hard" data type definitions like GADTs, at least initially)
14:12:07 <FunctorSalad> I think as long as you just fold one layer, you can always have return type "r"
14:12:23 <ski> kmc_ : is the eternal monad the same as the final monad ?
14:12:59 <FunctorSalad> if you fold a nested type or GADT recursively, your handlers must be polymorphic and "r" must depend on the index
14:13:00 <sproingie> the monad that can be returned is not the eternal monad
14:13:06 <sproingie> so sayeth the tao of haskell
14:13:07 <FunctorSalad> (hard to put that clearly)
14:14:26 <ski> (FunctorSalad : yes, istr something like that, as well .. but the details elide me)
14:14:27 <FunctorSalad> say you have "data Exp a = Var a | Lam (Exp (Maybe a))"
14:14:39 <camio> :t unit
14:14:40 <lambdabot> Not in scope: `unit'
14:14:59 <waern> does anyone have a copy of this paper: http://portal.acm.org/citation.cfm?id=1159871 ?
14:15:01 <camio> Is () pronounced "unit"?
14:15:08 <Twey> ;6RYes
14:15:11 <FunctorSalad> to fold that recursively you need an algebra like "var :: forall a. a -> r a; lam :: forall a. r (Maybe a) -> r a"
14:15:16 <ski> camio : yes (if you mean the type)
14:15:25 <iaefai> 'an algebras'?
14:15:27 <camio> ski, thanks.
14:15:27 <Twey> Also the value, generally
14:15:36 <ira> hey is there an easy way to *read* a ByteString into an Int, the way you *read* a String?
14:15:39 <Twey> () :: () -- unit is of type Unit
14:15:48 <camio> waern: Yeah, I have that paper. Why do you ask?
14:15:50 <ski> Twey : indeed (but i'm as fond of that :)
14:15:50 <FunctorSalad> you can strengthen that type by giving the algebra the information that "a" will be a Maybe tower over the original "a" though :)
14:15:53 <Twey> :t unpack
14:15:54 <lambdabot> Not in scope: `unpack'
14:16:16 <waern> camio: I don't have ACM access and can't find the paper anywhere else
14:17:00 <ski> (Twey : *sigh* s/as/not as/)
14:17:17 <Twey> How would you read it, then?
14:17:23 <knobo-home> When I have a tupple, how do I return the individual elements?
14:17:23 <ira> should i use Data.ByteString.Lazt.Char8's unpack to convert to [Char] then?
14:17:32 <camio> waern: http://www.cs.chalmers.se/~zalewski/thesis.pdf
14:17:40 <saml> > let f (a,b,c) = b in  f (1,2,3)
14:17:41 <lambdabot>   2
14:17:45 <saml> > snd (1,2)
14:17:46 <lambdabot>   2
14:18:00 <saml> > nth 5 (1,2,3,4,5,6)
14:18:01 <lambdabot>   Not in scope: `nth'
14:18:13 <camio> waern: It's paper V in that thesis.
14:18:26 <saml> > let nth n = some template haskell trickery in nth 5 (1,2,3,4,5,345,4,,3,)
14:18:27 <lambdabot>   <no location info>: parse error on input `,'
14:18:35 <ira> I mean, bs unpack to String read to Int?
14:18:45 <camio> waern: It wasn't as interesting as I though it would be, but YMMV.
14:19:06 <waern> camio: all right, thanks!
14:19:13 <ski> Twey : (the reason being that i don't like confusing the type- and value-level (`(a,b)' for the type is not good, SMLs `a * b' is better)), "empty tuple", or maybe something like "niple" (hrm), or "zerople" (i'm not sure any of these are good)
14:19:27 <FunctorSalad> ×
14:19:52 <waern> camio: I'm interested in it simply because I need a data-type generic library for c++ at work
14:20:10 <dolio> Top
14:20:40 <ski> `Top' is a type (in linear logic) :)
14:20:59 <knobo-home> Does haskell have symbols like in lisp 'symbol
14:21:04 <dolio> Oh, we were talking about values?
14:21:05 <ski> no
14:21:09 <camio> waern: Good luck. I use boost::fusion and boost::variant for that kinda stuff. The template techniques are the same. [end off topic conv.]
14:21:23 * ski was
14:21:24 <FunctorSalad> knobo-home: 'foo gets the name of foo if template haskell is on
14:21:26 <Twey> Nuple!
14:21:34 <Twey> ‘Null tuple’
14:21:42 <knobo-home> what is template haskell?
14:21:57 <kmc_> knobo-home, a framework for writing haskell programs that write other haskell programs
14:22:01 <FunctorSalad> "unit" is fine isn't it
14:22:04 <kmc_> gives you quotation and splice operators
14:22:13 <kmc_> i vote for "nurple"
14:22:26 <FunctorSalad> nilpple
14:22:31 <twanvl> How about "1"?
14:22:43 <knobo-home> aha, something in the direction of macros?
14:22:49 <kmc_> knobo-home, yes
14:22:53 <FunctorSalad> ➀
14:22:56 <waern> camio: interesting. Will have to check that out. [final end of off-topic conv.]
14:22:58 <ski> FunctorSalad : well, "unit" also suggests it is the unit of some binary operation .. that holds for the type (up to isomorphism, more or less), but i'm not sure it's proper to say that holds for the values
14:22:58 <kmc_> Haskell is a good language for manipulating synatx trees
14:23:04 <kmc_> so it makes sense to use it to manipulate its own syntax trees
14:23:24 <kmc_> a quote surrounds a piece of haskell code and gives you the syntax tree for that code as an algebraic data type
14:23:34 * ski idly wonders whether TH enforces (or at least defaults to) hygiene
14:23:41 <kmc_> a splice takes a value of that type and pastes it into the surrounding code
14:23:45 <knobo-home> But, I think I'll stay to the basics for now :)
14:23:46 <kmc_> and these are nestable
14:24:08 <FunctorSalad> "singularity"?
14:24:48 <kmc_> as for symbols, the appropriate replacement depends on what you're doing
14:24:58 <FunctorSalad> TypeThatDoesn'tQuiteHaveOnlyOneElementBecauseThere'sAlsoBottom
14:25:07 <kmc_> often they're used in LISP/Ruby/etc as enumeration types
14:25:24 <kmc_> and in haskell we'd prefer to explicitly define a new type and a set of values, for type safeaty
14:25:26 <ski> (no Java, please ! :)
14:25:41 <ddarius> Well, technically the typed version of symbols is just enumeration types, i.e. types of the form data Foo = Bar | Baz | Quux
14:25:43 <knobo-home> It took me some months before I was a master of macros in common lisp, so I will have to play with the basics for a while. I did common lisp as a full time job, now I'm only doning hobby haskell.
14:27:32 <ddarius> FunctorSalad: Sierpinski Space
14:28:29 <saml> knobo-home, that's very nice. what did you do with common lisp? web app?
14:29:44 <knobo-home> saml: web was a small part of it.
14:30:44 <knobo-home> not realy web related.
14:33:45 <Apocalisp> There's got to be a better way to say this: if (p x) then (g (f x) y (g (h x) b)) else (g (h x) y (g (f x) b))
14:33:47 <knobo-home> billing and order handling
14:34:07 <milaz> @src list
14:34:08 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:34:23 <knobo-home> xb
14:34:32 <kmc_> Apocalisp, (p x) decides whether f and h are switched?
14:34:54 <dibblego> if p x then id else swap (f, h)
14:34:54 <lambdabot> dibblego: You have 1 new message. '/msg lambdabot @messages' to read it.
14:35:00 <Apocalisp> kmc_: good point
14:35:19 <kmc_> let (a,b) = if p x then (f,h) else (h,f) in g (a x) y (g (b x) b)
14:35:28 <kmc_> :t swap
14:35:29 <lambdabot> Not in scope: `swap'
14:36:04 <kmc_> :t flip (,)
14:36:05 <lambdabot> forall a b. b -> a -> (a, b)
14:36:09 <kmc_> :t uncurry $ flip (,)
14:36:10 <newsham> ?djinn (a,b)->(b,a)
14:36:10 <lambdabot> forall a b. (a, b) -> (b, a)
14:36:11 <lambdabot> f (a, b) = (b, a)
14:36:20 <Apocalisp> ooh
14:36:28 <dibblego> if p x then id else swap $ (f, h) -- missed a $
14:36:38 <kmc_> not a clear usage of $ imo
14:36:43 <kmc_> (if p x then id else swap) (f, h)
14:37:43 <sproingie> i mentally read that as "(not a clear usage of) imo"
14:37:49 <kmc_> haha
14:38:07 <kmc_> @hoogle swap
14:38:08 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
14:38:08 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
14:38:12 <newsham> ?hoogle Bool -> c -> c -> c
14:38:13 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
14:38:13 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
14:38:13 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
14:38:32 <kmc_> @hoogle Bool -> (a -> a) -> a -> a
14:38:33 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
14:38:33 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
14:38:33 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
14:39:44 <kmc_> :t \b -> uncurry $ (if b then flip else id) (,)
14:39:45 <lambdabot> forall b. Bool -> (b, b) -> (b, b)
14:39:49 <ski> there's got to be a better way to say `case blah of A x -> foo x; B y -> bar (baz y); C z -> bar (quux z)'. discuss !
14:40:09 <ski> (or maybe even `case blah of A x -> foo x; B x y -> bar x (baz y); C x z -> bar x (quux z)')
14:40:37 <newsham> ski: destructor functions
14:40:51 <knobo-home> what's wrong here: set-color c (x,y,z) = (x,c,z)
14:41:06 <ski> newsham : elaborate ?
14:41:15 <knobo-home> Parse error in pattern
14:41:30 <knobo-home> aha minus
14:41:30 <ski> knobo-home : replace `set-color' with `set_color' or `setColor'
14:41:34 <newsham> ski: every data type you define has a natural destructor function (at least two, actually)
14:41:49 <newsham> for example "data Maybe a = Nothing | Just a" has "maybe"
14:41:51 <newsham> ?src maybe
14:41:52 <lambdabot> maybe n _ Nothing  = n
14:41:52 <lambdabot> maybe _ f (Just x) = f x
14:42:32 <newsham> but for some reaosn when you define a data type, haskell gives you the constructor functions (Nothing, Just) but ont the destructor function (maybe)
14:43:03 <newsham> if you deifne a destructor fucntion, you can use it instead of 'case'
14:43:50 <newsham> also its first class, unlike case.
14:44:14 <zygospasm> newsham: ski was just saying defining a catamorphism for each data structure you defined to avoid using case was elaborate, maybe? :)
14:45:16 <sg> hi
14:45:42 <ski> newsham : so in my case, i can write `ABC foo (bar . baz) (bar . quux) blah', yes .. i still need to type `bar' twice (assume it is a large expression, and that i'd rather not rewrite it into pointless, in this case)
14:45:54 <ski> er, s/ABC/abc/
14:46:48 <ski> (i.e. i'd rather not rewrite `bar (...)' into pointless)
14:48:51 <roconnor> @djinn (a -> Not a) -> Not a
14:48:51 <lambdabot> f a b = a b b
14:49:18 <ben_m> What does @djinn do?
14:49:51 <dibblego> writes a program from a type signature
14:49:55 <etpace> How would I pattern match for the head of a sublist? so f [[2,3],[4,5]]
14:49:56 <ben_m> ah :)
14:50:16 <etpace> would be 2*
14:50:27 <newsham> ski: ahh. dunno.
14:50:38 <roconnor> etpace: f ((x:xs):xss) = x
14:50:48 <dibblego> etpace, ([x:_] : _)
14:51:03 <dibblego> etpace, ((x:_) : _) -- oop
14:52:09 <etpace> thanks
14:52:52 * ski was thinking about stuff like `case blah of A x -> foo x; bar (cases B y -> baz y; C z -> quux z)' but fears this may invoke calls for burning :)
14:53:16 <tomh-> > map (-1) [1..4]
14:53:17 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
14:53:17 <lambdabot>    arising from a use of syntactic n...
14:53:26 <tomh-> hmm
14:53:35 <tomh-> > map (\x -> x-1) [1..4]
14:53:36 <lambdabot>   [0,1,2,3]
14:53:43 <tomh-> shorter way to write that?
14:54:21 <byorgey> tomh-: map (subtract 1) [1..4]  is the canonical way, although it's not necessarily shorter =)
14:54:38 <byorgey> unfortunately  map (-1) [1..4] doesn't work because of a bug in the syntax.
14:54:46 <tomh-> hehe ok
14:54:52 <ski> > map ((-) 1) [1..4]
14:54:53 <lambdabot>   [0,-1,-2,-3]
14:55:02 <ski> > map (flip (-) 1) [1..4]
14:55:03 <lambdabot>   [0,1,2,3]
14:55:21 <byorgey> of course, subtract = flip (-)
14:55:34 <kmc_> , pprint $ LamE [] $ TupE []
14:55:34 <lunabot>  luna: Not in scope: `pprint'
14:55:39 <tomh-> that probably makes it more readable
14:55:39 <ski> `subtract' is probably nicer
14:56:25 <ski> , pp $ LamE [] $ TupE []
14:56:27 <lunabot>  "\\ -> ()"
14:56:44 <kmc_> :t \ -> ()
14:56:45 <lambdabot> parse error on input `->'
14:56:51 <zygospasm> > map pred [1..4]
14:56:52 <lambdabot>   [0,1,2,3]
15:01:19 <zygospasm> @djinn (Not a -> a) -> a
15:01:20 <lambdabot> -- f cannot be realized.
15:01:24 <zygospasm> @djinn (Not a -> a) -> Not a
15:01:24 <lambdabot> -- f cannot be realized.
15:03:01 <T-Cell> Does anyone know how to get ghci to call erf, the error function?
15:03:24 <ivanm> T-Cell: statistics and hmatrix packages have it IIRC
15:07:46 <Vulpyne> Oh no, hpaste is down!
15:09:34 <quicksilver> @djinn (Not a -> a) -> Not (Not a)
15:09:35 <lambdabot> f a b = void (b (a b))
15:10:22 <ddarius> newsham: eliminator
15:10:31 <kmc_> @djinn (Not (Not p) -> p) -> ((p -> q) -> p) -> p
15:10:32 <lambdabot> f a b = a (\ c -> void (c (b (\ d -> void (c d)))))
15:10:59 <Vulpyne> I am trying to make a monad transformer that uses State and Error. I get a really odd error with a pre-existing MonadError IOError instance. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11877
15:11:11 <Vulpyne> I really have no clue what I am doing, or how to fix it.
15:12:08 <mmorrow> @djinn a -> Not (Not a)
15:12:08 <lambdabot> f a b = b a
15:12:12 <mmorrow> @djinn Not (Not a) -> a
15:12:13 <lambdabot> -- f cannot be realized.
15:12:22 <mmorrow> @djinn Not a -> Not (Not (Not a))
15:12:22 <lambdabot> f a b = void (b a)
15:12:29 <mmorrow> @djinn Not (Not (Not a)) -> Not a
15:12:29 <lambdabot> f a b = void (a (\ c -> c b))
15:12:43 <Saizan_> Vulpyne: why are you requiring MonadError EventSocketError m ?
15:12:43 <Philonous> @hoogle void
15:12:44 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
15:13:10 <Vulpyne> The simple answer is, it no longer works if I remove that. :)
15:13:45 <Vulpyne> Hm.
15:13:48 <Philonous> @type void
15:13:49 <lambdabot> Not in scope: `void'
15:13:49 * mmorrow takes that as proof that double-negated forall isn't as good as exists
15:13:58 <byorgey> argh, why doesn't Rand in MonadRandom have an Applicative instance?
15:14:22 <Saizan_> Vulpyne: mh, maybe the derived MonadError instance is fishy
15:14:34 <Vulpyne> Actually, when I removed that from the example it worked.
15:14:44 <Vulpyne> But I swear it didn't work in my actual code. I am going to try it and see what happens now.
15:14:46 <Saizan_> heh
15:15:02 <Saizan_> make sure you're calling throwError from the right monad.
15:15:11 <Saizan_> i.e. not inside lift
15:15:19 <Philonous> mmorrow: That are "Not" and "void"?
15:15:46 <ddarius> mmorrow: Encoding existentials using universals is annoying lacking impredicativity and (especially) lacking type level functions.
15:15:49 <Saizan_> Philonous: data Void; type Not a = a -> Void; void :: Void -> a
15:15:50 <newsham> ddarius: sure, that word works.
15:16:09 <ddarius> newsham: That's the usual word.
15:16:13 <Vulpyne> Saizan_: It would appear that I am stoopid.
15:16:14 <Philonous> Saizan_: Thanks
15:16:27 <kmc_> "Not a" is "a implies false"
15:16:32 <kmc_> void is "false implies anything"
15:16:51 <Vulpyne> Saizan_: So far it looks good after I removed that restriction. Thank you, I've been pulling my hair out for a while.
15:17:01 <Saizan_> Vulpyne: np :)
15:17:18 <Saizan_> Vulpyne: do you understand the error now?
15:17:51 <Vulpyne> Sort of. I understand there's already an instance for MonadError IOError.
15:17:58 <Vulpyne> Which was conflicting with my restriction.
15:18:21 <Philonous> Modulo Curry-Howard-isomorphism, yes.
15:18:38 <Saizan_> yeah, since MonadError e m has a functional dep. m -> e, you can't have two instances with the same m and different e
15:19:22 <Saizan_> but requiring MonadError YourError for the transformed monad eventually came to requiring MonadError YourError IO, conflicting with MonadError IOError IO
15:19:52 <Vulpyne> That makes sense.
15:20:08 <Vulpyne> I thought I needed it, I can't remember why.
15:20:37 <Saizan_> (that happens because all the transformers in mtl have so called "lifting instances" that push such requirements to the transformed monad if they aren't provided by the transformer)
15:22:31 <noteventime> After doing some SML homework I'm really beginning to appreciate some of the simple things of Haskell, like numerals having the type Num a => a
15:25:40 * zygospasm figures that with some unsafePerformIO and catch one could implement a total 'pierce :: ((p -> q) -> p) -> p'
15:26:19 <kmc_> :t callCC
15:26:20 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:26:27 <zygospasm> pierce f = let g x = throw (Wrap x) in f g `catch` (\Wrap x -> x)
15:27:03 <zygospasm> (if f calls g, return the value it provided, otherwise return the value f returns)
15:27:07 <kmc_> what's Wrap for here?
15:27:31 <zygospasm> kmc_: just converting an arbitrary type q into something which extensible exceptions can handle
15:29:36 <kmc_> so it's an existential SomeException or whatever?
15:29:42 <zygospasm> something like that
15:30:08 <zygospasm> i guess in a sense this is adding a form of continuations into haskell
15:30:34 <zygospasm> in fact, that's exactly what it is :)
15:37:20 <ski> zygospasm : what about the expression returning more than once, though !?
15:38:27 <ksf> is there anything one can do with -XCPP one couldn't equally well do with TH?
15:38:40 <zygospasm> ski: that's not necessary for an implementation of pierce, but...
15:39:10 <sproingie> ksf: conditionally use TH in the first place
15:40:21 <sproingie> #ifdef blocks in general
15:40:45 <ksf> ...I'm not planning on not using TH, I'm planning on not using XCPP.
15:41:39 <sproingie> #ifdef seems to be the primary use of -XCPP
15:43:03 <ksf> you can do conditions in plain TH, and even block-like stuff, as you can do IORefs inside Q.
15:43:22 <FunctorSalad> cpp is cool in haskell... less dangerous due to ref transparency and the type system
15:43:29 <ksf> I'm just wondering if there's some stuff one can't do, like limitations of where to splice etc.
15:44:01 * ski doesn't remember whether TheHunter's implementation of `pierce' in Haskell (+ extensions + evil) allowed multiple returns .. :/
15:44:09 <FunctorSalad> ksf: it's much faster than writing up an AST
15:44:20 <sproingie> what's the flag to enable evil?
15:44:21 <FunctorSalad> ksf: and quotation brackets are too strict for many things
15:44:31 <FunctorSalad> they require the stuff inside to be legal haskell
15:44:56 <ksf> yep a finer granularity would be nice.
15:45:22 <ksf> (that is, btw, the one and only reason why I'm constantly advocating sexprs as the basis of all syntax sugar)
15:45:49 <ksf> TH on tokens, something like that.
15:46:09 <FunctorSalad> thought sexpr were basically the lack of sugar
15:46:20 <ksf> well yes that's the point.
15:47:08 <ksf> they're easy to manage 'cos you don't have to memorize umphteen constructors for gazillions of syntactic sweets.
15:47:13 <ski> sproingie : the evil in question here being `unsafePerformIO' (or maybe it was `unsafeCoerce' or both), as well as linear implicit parameters
15:47:20 <FunctorSalad> ksf: misunderstood "basis" then
15:47:27 <FunctorSalad> you mean "target language"
15:47:32 <FunctorSalad> (of desugaring)
15:47:33 <FunctorSalad> ?
15:47:43 <ksf> ...you usually don't care whether your generated code uses enumFromThenTo or list syntax.
15:47:54 <ksf> yes.
15:48:07 <FunctorSalad> ksf: AIUI, core plays that role in haskell
15:48:10 <sproingie> yay liskell
15:48:27 <FunctorSalad> ghc desugars to core after typechecking, then does all the optimizing stuff
15:48:45 <sproingie> sexps may have a uniform look but lisp has tons of special forms
15:48:51 <ksf> that's ghc core, though.
15:49:14 <FunctorSalad> can't it read external core? I'm not sure
15:49:20 <ski> scope-aware sexps might be nice
15:49:39 <ksf> well let's say that http://www.haskell.org/onlinereport/lexemes.html isn't nearly as simple as sexprs
15:49:56 <ksf> haskell needs way less special forms due to laziness.
15:49:58 <sproingie> haskell's got syntax sugar up the wazoo
15:50:12 <ksf> i.e. you can actually implement ifthenelse in terms of a function.
15:50:14 <FunctorSalad> I looked at core briefly and it's pretty nice actually. just a few constructs but still the power of System F enhanced with coercions
15:50:17 <sproingie> even with special forms, macros can treat them uniformly, which is nice
15:51:07 <ksf> the really nice thing with core is that all strictness and laziness is explicit.
15:51:19 <FunctorSalad> it is? :o
15:51:46 <ksf> but I think it's a bit too low-level.
15:51:53 <ksf> ...and hopelessly ghc-specific.
15:52:16 <ksf> there's pattern matching, and then there's referencing stuff. the former is strict, the latter lazy.
15:54:40 <mmorrow> , let callcc f = let k=toss; o=f k`seq`toss(o) in snag(o)(\a -> a) in callcc (\k -> foldl' (\a b -> if b==0 then k(0::Int) else a*b) 1 ([1..9]++[0]++[10..])) :: Int
15:54:42 <lunabot>  0
15:54:58 <mmorrow> toss is throwDyn and snag is catchDyn
15:55:06 <ksf> and then I'm wondering about what a true haskell make would look like.
15:55:13 <mmorrow> (unIO'ed)
15:55:15 <Guest60923> ha upei
15:55:33 <Guest60923> moo pio mbaepio pe la ejapota
15:55:54 <ksf> there's some anciliary features I've collected like md5 file+comandline hashing, but there's nothing that looks specifically like haskell, yet.
15:56:00 <Guest60923> remopar.blogspot.com
15:56:07 <mauke> Guest60923: how about no
15:56:16 <Guest60923> rowing  o
15:56:38 <mmorrow> ksf: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7058
15:56:45 <mmorrow> @google http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7058
15:56:49 <lambdabot> http://citeseer.ist.psu.edu/feldman79make.html
15:56:55 <Guest60923> manowar
15:57:00 --- mode: ChanServ set +o mauke
15:57:00 --- kick: Guest60923 was kicked by mauke (I said no)
15:57:48 <Botje> woah. people wrote papers about make, lex and yacc?
15:57:52 * ksf challenges the "correctly and with a minimum amount of effort" in that abstract.
15:57:52 <Botje> cool!
15:58:00 --- mode: mauke set -o mauke
15:58:21 <Guest60923> haskell you are astupid ,ignorant fuck you puto emo
15:58:26 --- mode: ChanServ set +o mauke
15:58:26 --- mode: mauke set +b *!*@170.51.11.183
15:58:42 <psal> sigh @ irc
15:59:14 <Botje> i reported the guy's blog as spam
15:59:26 --- mode: mauke set -o mauke
15:59:41 <Botje> looked real enough.
16:01:25 <ksf> right now, there seem to be three approaches to overcome make/autohell: scons, which afaiu is a python lib that makes writing your own make easy, cmake, which generates makefiles/eclipse projects/whatnot, and jam, which is very close in what it does and its denotionality to make.
16:01:49 <Botje> i /like/ make
16:02:00 <ksf> can someone tell me the proper, complete type of gcc?
16:02:58 <ksf> make is fine, as long as you don't have more than one directory and/or processor.
16:02:59 <FunctorSalad> I have no idea what some more complex make setups do internally, but it looks... vast, and awe-inspiring
16:03:28 <FunctorSalad> (in the ambivalent sense)
16:04:03 * ksf came to utterly despise it while slurping the ghc build system
16:04:04 <kmc_> claw-inspiring
16:04:06 <ksf> (the new one)
16:04:13 <sproingie> jam is pretty horrendous
16:04:14 <ksf> cramp-inspiring.
16:04:17 <sproingie> cmake is nice
16:04:29 <ksf> cmake isn't a builder, though.
16:04:52 <sproingie> scons is decent but not for its cross-platformy stuff.  using it with cmake would be a nice combination
16:05:02 <ksf> I've tried omake once, and it's quite cool. were it not written in ocaml and thus vastly impure.
16:05:04 <sproingie> scons has some autoconfish stuff but it's not very good
16:05:30 <sproingie> it does invoke tools in a pretty nice cross platform way tho
16:06:02 <ksf> there's some non-trivial amount of ad-hocery going on in there, and stuff get's as thick as m4 macros.
16:06:25 <sproingie> autoconf is kind of old and crufty but it isn't really that terrible
16:06:27 <kmc_> bjam is exciting
16:06:32 <sproingie> it's automake that produces real abominations
16:06:33 * ksf plans on rsh-capabilities in the default install.
16:06:41 <kmc_> it calls stat() on essentially every file in the filesystem
16:07:08 <ksf> it's a bugger to configure a cross-build if you can't transparently run your tests on the target platform.
16:07:13 <sproingie> i maintained a project that did config with autoconf, then used hand-rolled makefiles with lots of includes
16:07:17 <sproingie> that worked out pretty well
16:10:06 <iaefai> Trolls?
16:10:39 <ksf> well I tried to figure out how to separate the binary directories for the libs ghc needs while building itself into stage1 / stage2 because the first one needs to be built with host, the other with target info, and despaired.
16:14:33 <ksf> If you know that 8088-unknown-frobnitz-gcc spews out binaries for arch 8088-unknown-frobnitz, and the user happens to have configured knowledge about such a machine running sshd, stuff can be run.
16:17:34 <blackthorne> hi
16:17:39 <kmc_> hi
16:18:49 <blackthorne> you may consider me as an Erlang fan... lately, I've read a lot of about haskell scalability.
16:19:49 <blackthorne> Long time ago, I learned Haskell but didn't understood what made it so interesting for that purpose
16:20:01 <ksf> can anyone point me to papers to the alternatives considered for monadic io? I've heard about streams and stuff.
16:20:21 <sproingie> stream-based IO was what early haskells did before monads
16:20:36 <sproingie> clean uses uniqueness typing, can't say as i know much more about it
16:20:42 <ksf> ...so just stdio->stdout?
16:20:52 <ksf> as in interact?
16:21:33 <sproingie> not entirely sure.  you'd have to ask a grizzled old haskell vet
16:23:35 <milaz> there's Clean language that uses uniqueness types
16:23:46 <milaz> probably it was something like it
16:23:51 <ksf> uniqueness types have the nice property of being vastly more fine-grained than that big sin-bin called Monad IO
16:24:18 <wio> hello
16:24:21 <wio> please help me
16:24:23 <wio> I can't istall glut
16:24:35 <ksf> heck we don't even distinguish between closed and opened handles, much less closed ones or actually preventing write operations to those.
16:24:57 <Saizan_> main :: [Response] -> [Request], actually
16:25:10 <ksf> er ...handles that have been closed after having been open, that is.
16:25:13 <milaz> i'm afraid to use something else than withFile
16:25:19 <wio> Could not find module `Graphics.UI.GLUT':
16:25:33 <wio> someone?
16:25:51 <Saizan_> wio: do you have cabal-install ?
16:26:00 <milaz> wio: did you try hackage?
16:26:10 <wio> ?
16:26:10 <wio> http://www.xmission.com/~nate/glut.html
16:26:12 <wio> from there
16:26:20 <wio> our instructions were quite simple hmm
16:26:48 <sjanssen> wio: you also need to install the Haskell bindings to that C library
16:27:31 <dcolish> so i'm having a lot of issues getting HaXml to parse stuff beyond how i am trying here: http://pastebin.com/m3863428f
16:27:43 <dcolish> this just prints the xml post parse
16:27:43 <milaz> wio: look at http://hackage.haskell.org/package/GLUT
16:28:51 <wio> hmm
16:29:07 <wio> that should be better than nate's?
16:29:22 <binrapt> I am somewhat puzzled by how programming languages employ the terms list, array, vector, often in totally different meanings, one referring to the same concept which is known under a different name in other programming languages.
16:29:32 <binrapt> The classical functional programming language archetypes such as Lisp and ML didn't even employ the terms array and vector, did they? Just lists, right? When I hear array I usually think of C and C++.
16:29:40 <milaz> wio: nate's is the library itself; the link I gave enables using this library from Haskell
16:29:42 <binrapt> List also often refers to linked lists, like in C++ (and Java?!). Whereas it doesn't in languages like Common Lisp, Erlang and Haskell?
16:29:46 <sproingie> common lisp has vectors
16:29:52 <binrapt> And then there's the vector which was often just a more mathematical notion of an array it seems, I do not even know which programming language introduced this one as a native type
16:30:00 <mauke> binrapt: Lisp/Haskell/ML lists are singly linked
16:30:02 <binrapt> The C++ STL features this as a dynamic array, kinda, I believe Java uses the term in a similar fashion. Implying consecutive storage in memory for fast random access.
16:30:05 <sproingie> vector and array typically mean much the same thing
16:30:11 <binrapt> sproingie oh, what type are they?
16:30:17 <binrapt> mauke hmm I didn't know that
16:30:39 <sproingie> array implies a packed representation, vector tends to imply a packed array of numbers
16:30:53 <binrapt> Numbers? Now that's a new one to me
16:30:53 <mauke> struct cons { void *car; struct cons *cdr; };
16:30:58 <sproingie> it does depend a lot on context -- a geometry lib may mean something different with vectors
16:30:58 <milaz> vector is single-dimensional array
16:31:02 <mauke> C++ got it wrong
16:31:10 <lament> let's all fight over terminology
16:31:17 <mauke> C++ calls dynamic arrays "vector" and vectors "valarray"
16:31:20 <binrapt> But I am terminologically primarily influenced by C++ in that regard since it was the first compiled programming language I actually spent a lot of time with
16:31:28 <wio> milaz: ok, thanks, I'll tr
16:31:29 <wio> y
16:31:37 <ksf> binrapt, my condolences.
16:31:40 <binrapt> mauke: Does Java do it right in your opinion then?
16:31:43 <binrapt> ksf: Now, now!
16:31:52 <mauke> binrapt: I don't know enough about the java library
16:32:02 <sproingie> java uses vector in the same sense as C++
16:32:11 <sproingie> Vector is in fact quite deprecated except for javaME
16:32:14 <binrapt> But Java is heavily influenced by C++ anyways
16:32:20 <binrapt> Oh I didn't know that
16:32:21 <mauke> how about "functor"? :-)
16:32:26 <ksf> Haskell uses vector for all kinds of stuff.
16:32:29 <sproingie> well not officially deprecated, but discouraged
16:32:30 <binrapt> mauke oh that one is even more wild, eh?
16:32:32 <ksf> ...except arrays, I think.
16:32:58 <ksf> but I think the common theme is "sequence with statically known size"
16:32:59 <lament> did C++ totally invent the word "functor" or did they borrow it from somewhere?
16:33:07 <sproingie> category theory
16:33:11 <mauke> there's C++::functor, SML::functor, Haskell::functor and math::functor
16:33:14 <sproingie> as usual C++ gets it grotesquely wrong
16:33:21 <lament> sproingie: probably not category theory
16:33:42 <sproingie> well ML anyway, which did get it from category theory
16:34:05 <lament> afaik, "functor" means something entirely different in C++ and has no relation to ML/category theory
16:34:07 <binrapt> The C++ functor is just some object which encapsulates a function pointer or a pointer to an object and a member function, providing a common call interface
16:34:18 <mauke> ML functors are parameterized modules, right?
16:34:19 <lament> i'm guessing C++ simply invented the term
16:34:32 <sproingie> binrapt: if you squint and look sideways you could say that's a functor
16:34:38 <sproingie> call the member fmap
16:34:40 <Saizan_> mauke: right
16:34:45 <mauke> sproingie: I'd call that a closure
16:34:50 <binrapt> sproingie how does the category theory one differ really?
16:35:00 <Draconx> mauke, they're a bit like functions from structures (modules) to structures.
16:35:03 <lament> an object that can be used as a function? If you squint, you could call it a "function"
16:35:05 <sproingie> as usual with category theory, it's a lot more abstract :)
16:35:12 <ksf> I thought a functor is a structure-preserving morphism between two categories?
16:35:13 <lament> nothing functorial about it
16:35:32 <ksf> uh.
16:35:35 <sproingie> sure, but functions are functors
16:35:40 <sproingie> well not all of them
16:36:09 <ksf> nope they've got to stay inside one category, in some sense.
16:36:17 <sproingie> (Hask)
16:36:21 <sproingie> :)
16:36:31 <ksf> I was thinking of [] or -> or whatever.
16:36:44 <sproingie> oh a useful category.  picky picky
16:36:44 <ksf> a -> b -> [a] -> (-> b) won't work.
16:38:05 <mauke> hah, #perl is talking about "hashes" vs "associative arrays"
16:38:19 <ksf> zomg.
16:38:46 <sproingie> with perl it's all about loose terminology
16:38:49 <skorpan> i trolled them well.
16:38:50 <lament> calling them anything other than dictionaries is obviously too descriptive
16:39:09 <mauke> skorpan: not really
16:39:15 <skorpan> no... not really. :|
16:39:45 <kmc_> yes the term "functor" in C++ is all about taking a deficiency of the language and making it sound like a cool feature
16:39:51 <binrapt> Haha, C++ calls those maps
16:39:57 <mauke> lament: "dictionary" implies an ordering. "hash" doesn't.
16:39:58 <binrapt> I bet functional programmers don't like that
16:39:59 <ksf> sparse-indexable efficient data lookup structure.
16:40:07 <mauke> binrapt: we have Data.Map
16:40:13 <kmc_> C++ std::map is very much like Haskell Data.Map
16:40:25 <mauke> except not persistent
16:40:27 <binrapt> Oh, really? I thought they'd usually think of the map function
16:40:35 <kmc_> :t Map.map
16:40:37 <lambdabot> Couldn't find qualified module.
16:40:41 <Philonous> skorpan: Learn COBOL!
16:40:41 <kmc_> :t Data.Map.map
16:40:42 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
16:40:45 <skorpan> Philonous: :)
16:40:46 <kmc_> :)
16:40:51 <sproingie> HASKOBOL
16:40:51 <binrapt> COBOL is an abomination :(
16:41:01 <binrapt> sproingie now that's a new one
16:41:10 <milaz> Data.Map has an underlying tree structure, and is very different from hashes :)
16:41:13 <sproingie> haskell with COBOL syntax
16:41:16 <lament> mauke: I always thought that "hash" implied a specific implementation, including a lack of ordering, while "dictionary" said nothing about implementation and simply referred to a key/value structure
16:41:25 <binrapt> Lots of upper case ASCII keywords, I presume, sproingie?
16:44:52 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
16:44:52 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
16:44:52 --- names: list (clog Rotaerk Zeiris bombshelter13_ binrapt yairchu wio bens__ FunctorSalad_ ttmrichter blackthorne cying Hugglesworth copumpkin Kim^Walkman ujihisa hgolden lorne qwr Cobra^^ jethomas Tobsan saint_cypher_ dolio saccade_ Nereid_ psal da-x ksf cloudhead m0nkfish james_britt NutCobbler miccm lispy temoto eyck_ novas0x2a ivanm kpreid ChilliX rtknz Pthing bos arvidj_ sg trin_cz shepheb Saizan_ infrared miclorb skorpan ddvlad qiemem mjv knobo-home)
16:44:52 --- names: list (ddarius niksnut jsgf Aikawa doserj TR2N lpsmith sigh dibblego m3ga Associat0r mmorrow Modius Whitesquall1 tsou khaoz amz Uawdal bgs100 nekschot adept borism Beelsebob kuningas jml kakeman skaar Milo- jahgru stalker joed wormwood mdordal2 mercury^ Nafai SubStack mapreduce im_maciek SimonRC mlh netcat jontore tkr Raevel jones- pikhq mfoemmel hellige jbauman M| LeoD ggreg_ luite tinLoaf Paradox924X xian malouin pixel5 tltstc jnwhiteh nothingmuch)
16:44:52 --- names: list (tmug sior|oifig mornfall gdsx Schmidt karld canvon wagle_home pragma_ integral jleedev Vanadium kanalj hiredman jfoutz kar-1 regulate aempirei Khisanth And[y] jrockway wdonnelly quicksilver sunnavy jvoorhis poucet tuukkah jlouis mjrosenb taruti suiside loupgaroublond prigaux magicman ToRA _plcs_ Boney matthew-_ Bassetts Zao smg Lemmih impl kosmic clog_ droidcore jfredett MacCoaster sjanssen erk kolmodin ahihi stepnem Taggnostr jql equanimity)
16:44:52 --- names: list (tumult_ Neronus erg bob0 Deewiant SeaPrior ac fraktil Annie|Home burp benmachine eelco Eelis sebbe1991 dons Arnar Counter-Strike ve anji byorgey earthy doublethink_work _br_ thoughtpolice nnunley Jiten kalven bran neurocyte deiga newsham aleator BrianHV fryguy felipe_ mahogny allbery_b anders^^ nimred boyscared franksh greap EvanCarroll Hunner Nereid heaumer int-e ville Exteris clanehin sshc Axman6 thorkilnaur koeien GNU\colossus joevandyk)
16:44:52 --- names: list (MyCatVerbs andun nornagon soduko lsthemes mattam juhp encryptio TML blackdog pifish vegai edwtjo etpace harlekin wolverian ath Nanar dumael_ sproingie stroan tom_tsuruhara andrewsw saiam Poeir r0bby_ drspider DekuNut Badger dcolish inclement fxr thomastc_ angelixd alexbobp mshaw mle glitch_ qm13_ sgf_ shortcircuit MrDomino gildor DrSyzygy Igloo aluink pettter jimmyjazz14 lavish cognominal shapr jonafan Esmil gOcOOl spoop ned nathanic_work)
16:44:52 --- names: list (thingwath gnuvince preflex Stephan212 McManiaC p}q mrd_ tessier mreggen agemo willb ath^ notallama qed kfish SamB_XP crem BMeph lanaer helge guerrilla opqdonut Vq Jaak poe leimy gbeshers frivol det jao ehamberg QtPlaty[HireMe] jims welterde ksandstr Megant_ Philippa leoncamel Guest39988 mfo lament Gabbie drhodes sevvie jelly12gen deavid Botje flippo cjs onodrim danopia` mikste jasonmay kynky cygnus_ seancorfield ziman aavogt Tomas kadoban)
16:44:52 --- names: list (araujo therp wharrgarble xinming p_l rdd kniu jfhall Veinor ystael lefant fnord123 dcoutts sunfun AndyP ray dmwit companion_cube Blaketh shutdown_-h_now AnMaster arcatan bohanlon Cyneox dixie cjay loop Gilly Blub\0 dionoea ertai daf epmf arkx dsfox thetallguy1 bind_return fnordus ps-auxw dogmaT alpheccar alip djinni scree thetallguy periodic brx daed lambdabot Twigathy PsiOmega JuanDaugherty icee kmc jvogel zaarg absentia tomasos trez)
16:44:52 --- names: list (noj koala_man maskd gbacon dqd rey_ laz0r shachaf Baughn zygospasm t nominolo|uni birkenfeld profmakx Valodim Warrigal Ferdirand nlogax sereven jtra marmolak nablaa stoop tarbo_ igorgue bolrod smorg eibmozoib idnar Elly Laney theclaw mokus wang PeakerWork Fullma_ gogonkt mr_ank JaffaCake gju sieni LeCamarade|Away whoppix rapacity tew88 byoteki teneighty Colours kmc_ pem Cale Paks mauke tonyIII Optimo ahf flori reqamst flux cods dilinger)
16:44:52 --- names: list (davidL kw317 desp authentic bd_ Draconx Aisling endojelly alexander1 mml` dayz bockmabe ClaudiusMaximus desu majoh dcoutts_ anekos hesselink orbitz Sisu omes geoaxis lunabot tilman koninkje_away sebas_ tensorpudding saccade Raku^ pshc __marius__ tromp_ liff lantti PHO_ yahooooo mux oubiwann malie guerby aggiejy jabagawee kosmikus mikm otto_s_ midnite_ vili zakwilson s76 ski jmcarthur rdrake Bleadof hexpuem jayne alvarezp blueflute alb)
16:44:52 --- names: list (ibid jrib sbok hackagebot CalJohn prince ijnek kamatsu Kapowski shellsage quetzal- noteventime drbean _Jordan__ Stefa1 zax phr dino-_ Vulpyne blackh SmurfOR mfp zoonfafer ponzao__ osfameron timchen119 vy` sohum tinker kayess__ electrogeek kyagrd twanvl knobo ben_m triplez noknok gwern mogunus jperras caligula_ sm arsenm reid06 glith eno joga ^Einstein Apocalisp Phyx- ski_ jystic conal Xichekolas nwf bla123 seanmcl fihi09 JoePeck dfdf levitation_)
16:44:52 --- names: list (Raynes tavelram_ SyntaxNinja cygnus OnionKnight nathanic shambler medfly proq webframp milaz inimino rgr demolithion Philonous pchiusano trofi astrolabe fbru02 mm_freak gbeshers_home Pewpewarrows snorble woggle dreixel tamiko travisbrady mpwd ketil ccasin Trafalgard Twey noddy2000 jre2 comak Kambus jan_ amiri Liskni_si StoneToad edwardhendricks @ChanServ)
16:44:56 <kmc_> fmap is the law that a functor maps every morphism into the new category
16:44:57 <FunctorSalad_> of course you can define Functors between Control.Categories
16:45:08 <sproingie> .oO( EndoFunctorSalad )
16:45:19 <kmc_> i really like the loose definition of "Control" in a lazy, pure functional language
16:45:49 <sproingie> .oO( EndiveFunctorSalad )
16:46:00 <kmc_> in C++ a for loop is magical built-in syntax.  in haskell we can define zygohystomorphic prepromorphisms in a library
16:46:23 <lament> that's the only argument for C++ that i've heard so far
16:46:29 <sproingie> "zygohystomorphic prepromorphism" has got to be my most favoritest word of all time
16:46:44 <mauke> zygohistomorphic
16:46:46 <ivanm> sproingie: even though it's actually _two words_?
16:46:47 <sproingie> zygohistomorphic even
16:46:54 <skorpan> saxamaphone
16:46:57 <sproingie> ivanm: okay compound word then
16:47:45 <FunctorSalad_> zygohistericomorphic
16:52:11 <m3ga> my manager accused me of assault for sending him a link to zygohistomorphic prepromorphisms
16:53:42 <ivanm> :o
16:54:02 <blackdog> anyone know if there's been any work on a Haskell SWIG backend? It should be possible to generate one just about automatically, you'd think
16:55:37 <ivanm> SWIG?
16:56:13 <ivanm> ahhh, found the wikipedia page
16:56:15 <blackdog> tool for binding C/C++ libs
16:56:20 <ivanm> blackdog: to complement the FFI?
16:56:27 <ivanm> or as an FFI-based wrapper?
16:56:44 <blackdog> ivanm: a wrapper around the FFI, i guess
16:57:02 <blackdog> the idea would be to provide interfaces to Haskell code - calling it as a client
16:57:16 <ivanm> right
16:57:22 <blackdog> and because you have more information at the haskell level, you might get away with generating bindings as well
16:57:24 <ivanm> sounds semi-interesting...
16:57:42 <blackdog> the only reason you can't do it for C is that it's not clear what (say) int * is
16:57:54 <blackdog> is that a pointer to a single int? an array? an out parameter?
16:58:21 <mauke> it's actually a number cast to a pointer for historical reasons! :-)
16:58:26 --- mode: ChanServ set +o mauke
16:58:26 --- mode: mauke set -b *!*@170.51.11.183
16:59:26 --- mode: mauke set -o mauke
16:59:41 <ivanm> so you removed the ban, and NutCobbler quit in retaliation? :p
16:59:44 <blackdog> mauke: well, exactly :)
17:00:03 <ksf> "int *" is a parse error.
17:00:18 <mauke> oh, another interesting possibility
17:00:24 <blackdog> ksf: don't be pedantic. you know what i mean
17:00:26 <mauke> it's a pointer to the first member of a struct
17:00:27 <ksf> those things parse like "int (*argc)"
17:00:39 <mauke> ksf: void f(int *); is perfectly valid
17:00:40 <Axman6> mauke: who was that?
17:00:42 <ksf> it's argc-dereferenced-is-an-int, not int-pointer-argc
17:00:52 <kmc_> that's so bad though
17:01:00 <blackdog> sure. the point stands, though
17:01:10 <mauke> Axman6: the spammer I removed earlier
17:01:11 <ksf> and the One And Only Way To Write Argv is char *argv[], btw.
17:01:12 <kmc_> makes even less sense with references
17:01:23 <Axman6> ah ok
17:01:33 <mauke> well, references make no sense
17:01:42 <ivanm> heya Axman6
17:01:47 <Axman6> 'lo
17:01:55 <blackdog> anyway. the idea would be to export all the information you have because you're coming from Haskell, in some useful way.
17:02:02 <mauke> ksf: I disagree. I think the [] is completely pointless syntactic sugar
17:02:20 <binrapt> I always use char ** argv
17:02:40 <mauke> disqualified for putting spaces between a unary operator and its operand
17:02:56 <binrapt> Actually I even used char * * argv at times
17:03:01 <ksf> well as long as you don't write int* argc
17:03:23 <mauke> int argv, char **argc
17:03:28 <binrapt> I don't want type and name to touch
17:03:30 <binrapt> They must not touch!
17:03:43 <ksf> * isn't a type.
17:03:46 <ksf> it's an operation.
17:03:49 * Axman6 always disliked the type *var style, always found that type* var made more sense
17:03:56 <binrapt> I consider it part of the type in this case
17:04:00 <binrapt> It's not like x = *y;
17:04:08 <mauke> binrapt: it's exactly like that
17:04:10 <ben_m> Axman6: The problem with the latter is that people write int* a, b; and think it declares 2 pointers
17:04:12 <ksf> well sure, y dereferenced is x.
17:04:13 <binrapt> Axman6 I wish it was like that
17:04:17 <blackdog> Axman6: the problem is when you declare "int * a, b, c"
17:04:25 <binrapt> It's absurd that you have to write type * a, * b;
17:04:25 <blackdog> gah, beat me to it
17:04:29 <Axman6> yes, good point!
17:04:31 <Woof> Exactly, ben_m; I also prefer int *a;
17:04:36 <Axman6> still... ugly
17:04:47 <ksf> so x gotta be int or you're somewhere in the realm of *((void)0)
17:04:53 <mauke> I blame C++ for people writing T* x; or T * x;
17:04:58 <Woof> Of course, I prefer not having to work with pointers at all
17:05:01 <blackdog> binrapt: it's a design choice. no-one's claiming that C is the perfect language to write new code in
17:05:08 <ben_m> I prefer int *a, in variable declaration but int* a in function declaration/definition
17:05:14 <binrapt> I use C++ only really
17:05:21 <Axman6> i also somewhat dislike the type x, y, z; was of declaring things too, unless it's loop indicies, i usually give them their oown type x;\type y; lines
17:05:39 <sproingie> http://conal.net/blog/posts/the-c-language-is-purely-functional/
17:05:46 <ksf> are declarations in loops c99?
17:05:59 <binrapt> I usually go type\n\tx,\n\ty,\n\tz;
17:06:02 <ben_m> Anyways, good night.
17:06:06 <mauke> T* x; completely breaks down in more complicated cases like T (*x)[20];
17:06:30 <lament> int *x simply means that *x is an integer, which is exactly what's going on.
17:06:34 <ksf> old c not allowing declarations everywhere was actually a good thing. if you need a variable, bleeding make a new block.
17:06:34 <binrapt> I think I actually use the same spacing pattern as you do in that case
17:06:35 <lament> int* x is nonsense
17:06:51 * jmcarthur does int * x
17:07:05 <binrapt> jmcarthur pointer spacing high five
17:07:16 * mauke slaps jmcarthur, binrapt 
17:07:23 <binrapt> But then again I don't even use int anymore
17:07:27 * ksf applauds mauke
17:07:31 <binrapt> Or long, really
17:07:40 <sproingie> i do int *x because it's traditional and i may as well get used to it because everyone else's code is gonna read that way
17:07:46 <binrapt> Unless some foreign API uses them
17:08:07 <jmcarthur> i do int * x because no matter what you do it's silly syntax
17:08:07 <lament> sproingie: it means *x is an integer.
17:08:24 <binrapt> lament interesting, I never thought about it that way before
17:08:26 <jagwire> hello, is it possible to define an instance of Show for a function?
17:08:28 <sproingie> #define POINTER(type,identifier) type ## * ## identifier
17:08:35 <mauke> sproingie: completely invalid
17:08:39 <sproingie> oops need a space
17:08:47 <sproingie> and ## eats 'em
17:08:48 <mauke> jagwire: yes
17:08:51 <binrapt> sproingie lacks an argument which allows you to define multiple *s
17:08:53 <sproingie> man i hate cpp
17:08:53 <lament> binrapt: int x, *y - x and *y are both integers
17:09:07 <sproingie> binrapt: that's a feature
17:09:09 <ksf> ...while we're at it: the whilespace is if( condition ) {\n<white>foo( arg, arg );\n}
17:09:12 <jagwire> mauke, can you elaborate a little bit?
17:09:15 <ksf> and foo= bar
17:09:17 <sproingie> #define POINTER_TO_POINTER
17:09:20 <sproingie> etc
17:09:29 <Axman6> ksf: foo= bar??? :O
17:09:41 <jmcarthur> sizeof(int) or sizeof int?
17:09:43 <sproingie> alternatively you could just put the * in the identifier
17:09:43 <ksf> yep. assignments lean to the left.
17:09:46 <mauke> ksf: I disagree. I don't want 'if' to look like a function call
17:09:54 <mauke> jmcarthur: neither, it's sizeof (int)
17:09:59 <binrapt> if(condition)\n{\n\tfoo(argument1, argument2);\n}
17:10:02 * jmcarthur slaps his forehead
17:10:07 * ksf wants spaces inside his parens.
17:10:08 <luite> lament: but in C++ that doesn't hold anymore for classes that overload operator*
17:10:08 <sproingie> c declarations are best parsed right-to-left
17:10:14 <binrapt> Wait actually I wouldn't use {} for a single line
17:10:27 <ksf> me neither.
17:10:51 <sproingie> overloaded operator * doesn't affect declarations
17:11:19 <ksf> sizeof( int )
17:11:33 <ksf> ...the parens belong to the function, not the argument.
17:11:47 <ksf> and it's a*b + c
17:11:58 * jmcarthur agrees with the last one
17:12:09 <mauke> ksf: there is no function there
17:12:19 <mauke> sizeof is a unary operator
17:12:25 <jmcarthur> yeah sizeof is definitely not a function
17:12:27 <mauke> it's sizeof EXPR or sizeof (TYPE)
17:12:30 <FunctorSalad_> is there some way to tell ghci that it shouldn't recompile an imported module (which is in the current project)?
17:12:33 <ksf> __builtin_sizeof suspiciosly looks like on.
17:13:09 <ksf> it should probably be (sizeof int)
17:13:23 <mauke> check your mental parser: what is sizeof(0)["abcdefgh"] ?
17:13:58 <ksf> sizeof EXPR is black magic.
17:14:19 <mauke> s/black magic/laziness/
17:14:31 <ksf> it's like using Int and complaining that your code fails on 32-bit platforms.
17:14:43 <sproingie> presumably 0 defaults to int, so e?
17:14:57 <mauke> 0 doesn't default to int, it is an int
17:15:11 <mauke> and the answer is 1
17:15:40 <sproingie> wait ["abcdefgh"] i can't parse
17:15:49 <dolio> So it reduces to sizeof 'b'?
17:15:53 <ksf> sizeof 0UL looks as much as a hack as sizeOf (undefined::Word32)
17:15:53 <mauke> according to the C precedence rules, postfix operators > prefix operators > infix operators
17:15:58 <dolio> Er, 'a'?
17:16:01 <sproingie> [sizeof(0)]"abcdefgh" i can get
17:16:03 <dolio> Essentially.
17:16:51 <dolio> i["str"] = *(i + "str") = *("str" + i) = "str"[i]
17:17:15 * sproingie tears chunks of hair out
17:17:32 <Zao> dolio: Except that identical string literals do not necessarily share the same storage.
17:17:35 <jagwire> what's wrong with: instance Show (Int -> Float) where show s = s ?
17:18:02 <dolio> jagwire: Is it complaining about FlexibleInstances?
17:18:03 <ksf> about everything.
17:18:06 <Zao> Well, the same glyph will plop out, but it's not necessarily the same one :)
17:18:12 <jagwire> yeah, dolio.
17:18:51 <ksf> show has type (Show a) => a -> String, but you're trying to do show :: (Int -> Float) -> Int -> Float
17:18:57 <ksf> which isn't a string, at all.
17:19:03 <dolio> jagwire: Haskell98 requires instances to be of the form "T a b c .." where a, b, c ... are variables. So you need an extension to do something like T U V, which is what you're doing.
17:20:05 <jagwire> ksf: so how would you create an instance of Show for a function of (Int -> Float) ?
17:20:16 <jagwire> or really a -> b tbh
17:20:42 * ksf wonders what the show instance is going to look like. an enumeration of (Int, Float) tuples from minBound :: Int to maxBound :: Int ?
17:21:11 <ksf> it's always hard to show functions.
17:21:19 <jagwire> okay
17:21:32 <ksf> you could also represent them as gnuplot data or something.
17:21:53 <ksf> but, in general, I'd say you dont _want_ to have a show instance for any function type.
17:22:00 <jagwire> If it's not something basic, I don't think I should dive into it
17:22:02 <jagwire> gotcha.
17:22:04 <jagwire> hmph.
17:22:09 * jagwire kicks his homework
17:23:37 <ksf> instance Show ((->)a) where show _ = "You wish"
17:24:07 <jagwire> :)
17:24:23 <ksf> term rewriting and evaluating under lamdas would be cool to have, though.
17:25:43 <ksf> but even the lisp systems of olde just spewed out #<compiled procedure> or something.
17:25:45 <dcolish> how does Either work?
17:25:53 <ksf> @src Either
17:25:53 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:26:01 <ksf> @src Data.Either
17:26:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:26:13 <ksf> data Either a b = Left a | Right b
17:26:17 <ksf> that's all there is to it.
17:27:09 <ksf> @djinn Maybe a -> Maybe b -> b -> Either a b
17:27:09 <lambdabot> f a b c =
17:27:10 <lambdabot>     case a of
17:27:10 <lambdabot>     Nothing -> Right c
17:27:10 <lambdabot>     Just d -> case b of
17:27:10 <lambdabot>               Nothing -> Left d
17:27:11 <lambdabot>               Just e -> Right e
17:27:34 <dolio> , ''Either
17:27:35 <lunabot>  Data.Either.Either
17:27:43 <dolio> , src ''Either
17:27:46 <lunabot>  data Either a b = Left a | Right b
17:27:46 <ksf> @djinn Maybe a -> Maybe b -> Either a b
17:27:46 <lambdabot> -- f cannot be realized.
17:27:59 <ksf> @djinn Maybe a -> Maybe b -> Either a b -> Either a b
17:27:59 <lambdabot> f a b c =
17:27:59 <lambdabot>     case a of
17:27:59 <lambdabot>     Nothing -> c
17:27:59 <lambdabot>     Just d -> case b of
17:27:59 <lambdabot>               Nothing -> case c of
17:28:01 <lambdabot>                          Left e -> Left e
17:28:03 <lambdabot>                          Right _ -> Left d
17:28:05 <lambdabot>               Just f -> Right f
17:28:11 <ksf> hum strange.
17:28:16 <dolio> , [$ty| either Right Left |]
17:28:19 <lunabot>  forall a1 a . Either a a1 -> Either a1 a
17:29:35 <doserj> @djinn Either a b -> (Maybe a, Maybe b)
17:29:35 <lambdabot> f a =
17:29:35 <lambdabot>     case a of
17:29:35 <lambdabot>     Left b -> (Just b, Nothing)
17:29:35 <lambdabot>     Right c -> (Nothing, Just c)
17:30:11 <ksf> @djinn Maybe a -> Maybe b -> Bool -> Either a b
17:30:11 <lambdabot> -- f cannot be realized.
17:30:28 <dcolish> so when i get a Either String a, do i use a case to pull out the string?
17:30:31 <ksf> @djinn (Maybe a, Maybe b) -> Either a b
17:30:31 <lambdabot> -- f cannot be realized.
17:30:35 <mauke_> dcolish: yes
17:30:39 <dcolish> ok
17:30:45 <dolio> ksf: What should f Nothing Nothing return?
17:31:03 <dcolish> so something like Left String -> str?
17:31:24 <dcolish> or does the case do that?
17:31:25 <mauke_> Left str -> str
17:31:25 <ksf> dcolish, yep.
17:31:29 <dcolish> ok cool
17:31:37 <dcolish> i'm feeling a little lost in monad land
17:31:42 <mauke_> where str is any variable name you like
17:31:52 <mauke_> fortunately this isn't about monads :-)
17:31:57 <dcolish> its not?
17:32:02 <ksf> (as in "something _like_", as mauke pointed out)
17:32:10 <mauke> no, just plain old data structures
17:32:21 <ksf> > Left 2 >> Right 3
17:32:22 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:32:23 <lambdabot>    `Control.Monad.Error.Cla...
17:32:34 <ksf> > Left 2 >> Right (3:: Int)
17:32:35 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:32:36 <lambdabot>    `GHC.Num.Num t' arising ...
17:32:42 <ksf> > Left (2 :: Int) >> Right (3:: Int)
17:32:43 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Types.Int)
17:32:43 <lambdabot>    arising ...
17:32:44 <mauke> > Left "no" >> Right 3
17:32:45 <lambdabot>   Left "no"
17:33:06 <ksf> oh it's Monad (Either String)
17:33:23 <ksf> > Right 2 >> Right 3
17:33:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:33:24 <lambdabot>    `Control.Monad.Error.Cla...
17:33:36 <ksf> > Right 2 >> (Right 3 :: Either String Int)
17:33:37 <lambdabot>   Right 3
17:38:43 <dcolish> Either is all kinds of fun
17:40:29 <travisbrady> in case anyone was wondering Haskell is still extremely awesome
17:44:48 <Rotaerk> travisbrady, PROVE IT
17:45:12 <dolio> What's the readout on your coolometer?
17:45:34 <mauke> it's over 8000
17:46:05 <dolio> 8000 megafonzis?
17:46:09 <travisbrady> Rotaerk: haha, dang, got me there. maybe this'll help? http://www.willamette.edu/~fruehr/haskell/evolution.html
17:46:30 <tensorpudding> i think you can prove haskell is awesome in agda now
17:46:50 <Rotaerk> :P
17:46:58 <dolio> You can prove anything in Agda with the currently unsound universe polymorphism.
17:48:11 <dolio> Or, I suppose it's inconsistent, not unsound.
17:49:34 <medfly> is it just me or does one of those have errors
17:53:00 <blackdog> hey, anyone remember that article "things to know before arguing about type systems"? my google fu fails me
17:54:42 <ivanm> blackdog: bugger, though I had bookmarked it :s
17:55:00 * ivanm vaguely recalls there being a link from wikipedia
17:55:09 <ivanm> blackdog: http://www.pphsg.org/cdsmith/types.html
17:55:13 <ivanm> yay for wikipedia!
17:57:11 <blackdog> ivanm: cheers mate
17:57:19 <ivanm> no worries
16:03:28 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
16:03:28 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
16:03:28 --- names: list (clog_ qiemem beutdeuce bel5f5 opdolio flazz kniu mikmik ujihisa triplez sohum u_quark Cthulhon preflex_ Hugglesworth augur mauke bombshelter13__ zachk Alpounet Raynes- trie NEEDMOAR hansfbaier Adamant jagwire eldragon reprore_ dancor dejones Woof timemage clog Rotaerk Zeiris binrapt wio bens__ FunctorSalad_ blackthorne copumpkin Kim^Walkman hgolden lorne qwr Cobra^^ jethomas Tobsan saint_cypher_ dolio saccade_ Nereid_ psal da-x ksf cloudhead)
16:03:28 --- names: list (james_britt temoto eyck_ novas0x2a ivanm kpreid ChilliX rtknz arvidj_ sg shepheb Saizan_ infrared miclorb ddvlad mjv knobo-home ddarius niksnut Aikawa doserj TR2N lpsmith sigh dibblego m3ga Associat0r mmorrow Modius Whitesquall1 amz Uawdal bgs100 nekschot adept borism Beelsebob kuningas suiside taruti mjrosenb jlouis tuukkah poucet jvoorhis sunnavy quicksilver wdonnelly jrockway And[y] Khisanth aempirei regulate kar-1 jfoutz hiredman kanalj)
16:03:28 --- names: list (Vanadium jleedev integral pragma_ wagle_home canvon karld Schmidt gdsx sior|oifig tmug nothingmuch jnwhiteh tltstc pixel5 malouin xian Paradox924X tinLoaf luite ggreg_ LeoD M| jbauman hellige mfoemmel pikhq jones- Raevel tkr jontore netcat mlh SimonRC im_maciek mapreduce SubStack Nafai mercury^ mdordal2 wormwood joed stalker jahgru Milo- skaar kakeman jml mornfall loupgaroublond prigaux magicman ToRA _plcs_ Boney matthew-_ Bassetts Zao)
16:03:28 --- names: list (smg Lemmih impl kosmic droidcore jfredett MacCoaster sjanssen erk kolmodin ahihi stepnem Taggnostr jql equanimity tumult_ Neronus ac erg bob0 Deewiant SeaPrior fraktil Annie|Home burp benmachine eelco Eelis sebbe1991 dons Arnar Counter-Strike ve anji byorgey earthy doublethink_work _br_ nnunley Jiten thoughtpolice kalven neurocyte bran deiga newsham aleator BrianHV fryguy felipe_ mahogny allbery_b anders^^ nimred boyscared franksh greap)
16:03:28 --- names: list (EvanCarroll Hunner Nereid heaumer int-e ville Exteris clanehin sshc Axman6 thorkilnaur koeien GNU\colossus joevandyk MyCatVerbs andun nornagon soduko lsthemes mattam juhp encryptio TML blackdog pifish vegai edwtjo etpace harlekin wolverian ath Nanar dumael_ sproingie stroan tom_tsuruhara andrewsw saiam Poeir r0bby_ drspider DekuNut Badger dcolish inclement fxr thomastc_ alexbobp mshaw mle glitch_ qm13_ sgf_ shortcircuit MrDomino gildor)
16:03:28 --- names: list (DrSyzygy Igloo aluink pettter jimmyjazz14 lavish cognominal shapr jonafan Esmil gOcOOl spoop ned nathanic_work thingwath gnuvince Stephan212 McManiaC p}q mrd_ tessier mreggen agemo willb ath^ notallama qed kfish SamB_XP crem BMeph lanaer helge guerrilla opqdonut Vq Jaak leimy gbeshers frivol det jao ehamberg QtPlaty[HireMe] jims welterde ksandstr Megant_ Philippa leoncamel Guest39988 mfo lament Gabbie drhodes sevvie jelly12gen deavid Botje)
16:03:28 --- names: list (flippo cjs onodrim danopia` mikste jasonmay kynky cygnus_ seancorfield ziman aavogt Tomas kadoban araujo therp wharrgarble xinming p_l rdd jfhall Veinor ystael lefant fnord123 dcoutts sunfun AndyP ray dmwit companion_cube Blaketh shutdown_-h_now AnMaster arcatan bohanlon Cyneox dixie cjay loop Gilly Blub\0 dionoea ertai daf epmf arkx dsfox thetallguy1 bind_return fnordus ps-auxw dogmaT alpheccar alip djinni scree thetallguy periodic brx)
16:03:28 --- names: list (daed lambdabot Twigathy PsiOmega JuanDaugherty icee kmc jvogel zaarg absentia tomasos trez noj koala_man maskd gbacon dqd rey_ laz0r shachaf Baughn zygospasm t nominolo|uni birkenfeld profmakx Valodim Warrigal Ferdirand nlogax sereven jtra marmolak nablaa stoop tarbo_ igorgue bolrod smorg eibmozoib idnar Elly Laney theclaw mokus wang PeakerWork Fullma_ gogonkt mr_ank JaffaCake gju sieni LeCamarade|Away whoppix rapacity tew88 byoteki teneighty)
16:03:28 --- names: list (Colours kmc_ pem Cale Paks tonyIII Optimo ahf flori reqamst flux cods dilinger davidL kw317 desp authentic bd_ Draconx Aisling endojelly alexander1 mml` dayz bockmabe ClaudiusMaximus desu majoh dcoutts_ anekos hesselink orbitz Sisu omes geoaxis lunabot tilman koninkje_away sebas_ tensorpudding saccade Raku^ pshc __marius__ tromp_ liff lantti PHO_ yahooooo mux oubiwann malie guerby jabagawee kosmikus mikm otto_s_ midnite_ vili zakwilson)
16:03:28 --- names: list (s76 ski jmcarthur rdrake Bleadof hexpuem jayne alvarezp blueflute alb ibid jrib sbok hackagebot CalJohn prince ijnek kamatsu Kapowski shellsage quetzal- noteventime drbean _Jordan__ Stefa1 zax phr dino-_ Vulpyne blackh SmurfOR mfp zoonfafer ponzao__ osfameron timchen119 vy` tinker kayess__ electrogeek knobo noknok gwern mogunus caligula_ sm arsenm reid06 glith eno joga ^Einstein Apocalisp Phyx- jystic conal Xichekolas nwf seanmcl fihi09)
16:03:28 --- names: list (JoePeck dfdf levitation_ tavelram_ OnionKnight nathanic shambler medfly proq webframp inimino rgr Philonous pchiusano trofi astrolabe fbru02 mm_freak gbeshers_home Pewpewarrows snorble woggle dreixel tamiko travisbrady mpwd ketil ccasin Trafalgard Twey noddy2000 jre2 Kambus jan_ amiri Liskni_si edwardhendricks @ChanServ)
18:09:11 <jamescarr> hey
18:09:18 <jamescarr> what cabal package is Data.CSV in?
18:09:28 <jamescarr> I thought it was just csv
18:09:33 <jamescarr> but that is Text.CSV :(
18:09:52 <ivanm> is there a Data.CSV?
18:09:59 <jamescarr> yes
18:10:09 <ivanm> hayoo says misingh
18:10:41 <jamescarr> there is no package named 'misingh'
18:11:16 <Cale> missingh
18:12:08 <ivanm> fine, I mis-spelt
18:12:11 <ivanm> get over it! ;-)
18:13:00 <jamescarr> lol
18:39:03 <ivanm> @tell byorgey with the "Real World #haskell" "book" on the wiki, maybe you should update the title of Chapter 14 to reflect ?users not being valid anymore...
18:39:04 <lambdabot> Consider it noted.
18:43:01 <jamescarr> wow... haskore is cool
18:46:16 <gwern> ivanm: what happened to @users?
18:46:30 <ivanm> gwern: removed due to memory leaks, etc.
18:46:41 <gwern> oh. did it take @seen with it?
18:46:44 <ivanm> yes
18:46:49 <ivanm> preflex_: seen gwern
18:46:49 <preflex_>  gwern was last seen on #haskell 8 seconds ago, saying: oh. did it take @seen with it?
18:46:55 <ivanm> preflex_'s is better anyway ;-)
18:46:57 <gwern> that was like half lambdabot's functionality
18:47:41 <ivanm> heh, not quite
18:47:45 <ivanm> @. elite quote
18:47:46 <lambdabot> CaLe zaY$: Bu+ iN aNOt|-|eR z3NsE, FUNc7ionaL PRogRAm/\/\ERs ARE APpLIeD LOGi(IANz0rz wh0 SpENd a1| +|-|EIR timE Pr0\/InG +RI\/ial THeor3mz In in+erEz7ing waY5 iN an in(onzIz+Ent In7Ui+i0nis+ L09Ic.
18:49:04 <Cale> heh
18:49:36 <gwern> so, which makes one's head hurt more, the syntax or the semantics of that?
18:50:22 * hackagebot upload: hoauth 0.1.6 - A Haskell implementation of OAuth 1.0a protocol. (DiegoSouza)
18:51:50 <Gracenotes> ^@.@^
18:52:45 <Gracenotes>  ‾‾‾
18:53:32 <ivanm> show-off
18:54:22 <Gracenotes> ﹉︹﹉
18:54:32 <copumpkin> weirdo
18:55:09 <Gracenotes> I like to be CJK-compatible
18:55:43 <ivanm> copumpkin: look who's talking!
18:55:51 <copumpkin> ivanm: look who's talking!
18:56:02 <ivanm> :D
18:56:09 * ivanm is weird and proud of it
18:57:39 <gwern> ಠ_ಠ
19:03:25 <RyanT5000> so, to what extent can laziness be abstracted from a language's semantics?
19:03:57 <RyanT5000> i was just thinking about it, and it seems like there are a really large number of situations in which nobody cares whether something is lazy or not
19:03:57 <ivanm> "This is a lazy language" and "This is a non-lazy langauge" ;-)
19:04:08 <RyanT5000> ivanm: that's completely not abstracted, lol
19:04:41 <blackdog> RyanT5000: you certainly care whether constructs like "if" are lazy or strict
19:04:48 <ivanm> I understood "semantics" to be individual specification of constructs
19:04:53 <Cale> RyanT5000: Haskell isn't really defined to use lazy evaluation. It has non-strict semantics.
19:04:59 <ivanm> I've abstracted it away by having a catch-all phrase
19:05:05 <blackdog> (practically speaking, if "if" is not lazy you're sort of screwed, but you know what i mean)
19:05:25 <ivanm> Cale: it's just that all the known/at-least-semi-usable implementations use laziness?
19:05:41 <RyanT5000> blackdog: well, if "if" is side-effect free, you just have a problem terminating recursions :P
19:05:49 <ivanm> blackdog: because of "if null then foo else bar" ?
19:06:02 <blackdog> ivanm: you still evaluate both of foo and bar, then
19:06:02 <Cale> ivanm: GHC doesn't just use laziness, it has a strictness analyser and changes how things are evaluated based on that analysis.
19:06:09 <RyanT5000> Cale: that makes sense
19:06:13 <ivanm> blackdog: that's what I meant
19:06:18 <RyanT5000> i've been wondering about other evaluation strategies, though
19:06:30 <RyanT5000> for example, memoizing a value only if it's smaller than the original thunk
19:06:36 <RyanT5000> (for some value of "smaller")
19:06:37 <blackdog> if person.isBad() then shoot(person) else hug(person)
19:06:39 <ivanm> Cale: :o you mean it automagically applies some selective strictness now?
19:06:49 <blackdog> gets all kind of blood on your suit
19:06:49 <Cale> ivanm: It has for a very long time
19:06:55 <ivanm> blackdog: you have a problem with hugging a corpse? :p
19:07:01 <ivanm> ahh, right, the mess...
19:07:04 <ivanm> Cale: didn't know that...
19:07:21 <blackdog> ivanm: insert comment about your mother's performance in bed _here_
19:07:37 <Cale> ivanm: Of course it will never do it in a way which is visible as anything more than a change in performance.
19:07:37 <ivanm> @slap blackdog
19:07:38 * lambdabot pokes blackdog in the eye
19:07:43 <ivanm> Cale: *nod*
19:07:49 <Cale> (referential transparency is important there)
19:08:01 <RyanT5000> Cale: does that mean lists can never be strict?
19:08:12 <ivanm> RyanT5000: you want infinite lists or not?
19:08:33 <RyanT5000> ivanm: i want the lists that are provably not infinite to sometimes be strict :P
19:08:33 <Cale> RyanT5000: What counts as strict?
19:08:45 <RyanT5000> Cale: that sounds more like a question *i* would ask *you*
19:08:48 <RyanT5000> lol
19:08:57 <RyanT5000> i mean, i'd love to have all sorts of analysis
19:09:10 <RyanT5000> if GHC can prove my list is of length 1, i'd love if it just provided a scalar instead
19:09:31 <RyanT5000> any sort of deforestation-style or strictness-analysis-style stuff is always good
19:09:37 <Cale> RyanT5000: Sometimes it even manages to remove lists altogether, collapsing the producer and the consumer into a single recursive program.
19:09:47 <RyanT5000> Cale: yeah, i'm aware of that one
19:10:22 <RyanT5000> actually, i was talking to some of the PL guys at Harvard the other day about the possibility of doing generalized deforestation
19:10:42 <ivanm> RyanT5000: so you want it to traverse the entire list (even if it's extremely long and not infinite) to see if it's infinite or not?
19:10:54 <RyanT5000> ivanm: no, i'm talking about a compile-time analysis here
19:11:14 <RyanT5000> in magically-selected cases, i'd like it to replace f [x] with scalar_f x
19:11:15 <ivanm> I've written some code that produces lists that are hundred of thousands of items long (but definitely finite)... should it be fully evaluated?
19:11:28 <RyanT5000> ivanm: i'm not talking about anything like that
19:11:57 <blackdog> trying to remember - something about inductive and coinductive data structures, maybe? one's the dual of the other?
19:12:32 <ivanm> blackdog: isn't co-inductive something like "data Foo = Foo Bar, data Bar = Bar Foo" ?
19:12:44 <RyanT5000> ivanm: that's co-recursive
19:12:48 <ivanm> oh, right
19:12:49 <ivanm> duh
19:13:10 <RyanT5000> np :)
19:13:23 <RyanT5000> speaking of datastructures
19:13:31 <RyanT5000> i've grown quite unimpressed with algebraic ones
19:13:48 <RyanT5000> though they're still a ridiculous improvement on OOP
19:14:14 <Cale> There's actually a surprising amount that can be encoded
19:14:31 <RyanT5000> Cale: well, *technically*, yes, they're quite powerful
19:14:42 <RyanT5000> but i'm currently running into serious issues with inter-programmer communication
19:15:10 <RyanT5000> basically, the problem is this
19:15:13 <RyanT5000> i have a huge terrain mesh
19:15:19 <blackdog> i think one of the applications is to distinguish infinite lists (streams) from guaranteed finite lists
19:15:28 <RyanT5000> which everything (in the game i'm writing) uses
19:15:38 <RyanT5000> but every piece of the game needs different info
19:15:47 <RyanT5000> e.g.: the physics system needs precomputed gradients for the ground
19:15:55 <RyanT5000> the navigation system needs traversal cost info
19:15:59 <RyanT5000> etc.
19:16:08 <RyanT5000> and each of these components is worked on by a different programmer
19:16:19 <RyanT5000> ideally, i wouldn't need *everybody* to touch this datastructure to add the fields they need
19:16:29 <RyanT5000> so, i've got some hackish things in place
19:16:35 <RyanT5000> but what i really want is composable data schema
19:17:09 <RyanT5000> which would allow me to build datastructures automatically out of a bunch of separate descriptions of requirements
19:17:24 <RyanT5000> similar to how you can add a new table to a database without messing up anything that already exists
19:17:47 <RyanT5000> seems like it would be good, to me :P
19:17:49 <Cale> There's always a bit of tension between making it easy to extend the data, and making it easy to extend the operations on the data.
19:17:57 <RyanT5000> yeah, that's true
19:18:12 <RyanT5000> but i'm not sure how fundamental that tension is in *this* problem
19:18:27 <RyanT5000> because i could, e.g., just make each system use a Map ThingID MyThingData
19:18:36 <Cale> One thing which is an option that is not considered often enough is that you can store records of the operations rather than the data you'd have otherwise stored.
19:18:48 <RyanT5000> hm
19:18:55 <RyanT5000> that's an interesting point
19:19:01 <RyanT5000> though i'm not sure how performance would compare
19:19:18 <RyanT5000> (certain parts of this system really need to blast through the datastructure fast)
19:19:27 <stroan> correcting maths papers. I wonder why people have so much trouble with trig...
19:19:42 <Cale> Then you create functions which construct values of that type and take as parameters the values which the straightforward algebraic approach would handle as fields of the constructor.
19:20:05 <RyanT5000> Cale: yeah, that makes sense
19:20:45 <Cale> stroan: My answer is because they typically learn it well before they ought to in terms of the order in which things are covered.
19:21:33 <stroan> they can deal with calculus with relative ease
19:21:36 <jmcarthur> Cale: what would you propose as a prereq for trig that isn't taught first?
19:21:42 <Cale> jmcarthur: Calculus.
19:21:45 <jmcarthur> *isn't currently
19:21:46 <stroan> but trig stumps them
19:22:09 <RyanT5000> so, i've heard that there are a lot of proposals for fixing the Haskell records system; are they compiled anywhere?
19:22:19 <RyanT5000> (as in, a list of the proposals)
19:22:30 <Cale> RyanT5000: That would be a great idea. I have no idea if it exists.
19:22:37 <sproingie> Haskell' is about it
19:22:43 <jmcarthur> reminds me i've been meaning to try out lenses
19:22:55 <RyanT5000> Cale: it seems like picking *any* of them would be good
19:23:00 <RyanT5000> lol
19:23:17 <camio> RyanT5000: What troubles are you running into with the current record system?
19:23:41 <RyanT5000> camio: well, the namespacing is horrendous, for one
19:23:50 <RyanT5000> camio: but i'd also like extensible record types
19:23:52 <sproingie> the requirement for unique labels is nasty
19:24:01 <Cale> The namespace issues actually don't bother me at all.
19:24:11 <RyanT5000> Cale: why's that?
19:24:13 <Alpounet> @type (***)
19:24:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:24:30 <Alpounet> @type (&&&)
19:24:32 <Cale> RyanT5000: I always find good prefixes to add to my record labels.
19:24:32 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:24:40 <Cale> The real problem is with record extension.
19:24:50 <RyanT5000> Cale: yeah, but prefixes are duplicated code
19:24:53 * ddarius would recommend not bothering with trigonometry for the most part.
19:25:11 <stroan> Cale: would there be any reason to not implement them via typeclasses and instances?
19:25:25 <Cale> RyanT5000: If the fields are also really related to each other, it's often possible to factor the common fields out into a separate type
19:25:45 <RyanT5000> Cale: sure, but it's still duplicating the name of the type (or whatever you base the prefix on)
19:26:09 <RyanT5000> Cale: it's definitely conveying redundant information
19:26:31 <RyanT5000> Cale: i agree about factoring them out, though
19:27:13 <RyanT5000> one thing i haven't seen in the records literature is a reasonable treatment of scoping
19:27:13 <Cale> I don't know why, but it just seems like a small constant factor to me. The big mess is... well, look at HaskellDB and consider how much prettier it would be with a proper record system :)
19:27:36 <RyanT5000> Cale: i hate duplication in all its forms :P but i agree there are bigger issues
19:27:38 <sproingie> prefixes work but they're noise
19:28:25 <RyanT5000> what i *really* don't like is that the record {q = 5} entered in one library is the same value (and type) as {q = 5} in another library
19:28:45 <Cale> why?
19:28:45 <RyanT5000> even if those libraries have no common dependencies
19:28:55 <Cale> With which system?
19:28:56 <RyanT5000> Cale: because that's taking the string "q" and using it as the key
19:29:01 * copumpkin defines kolmogorov complexity as the size of the code that RyanT5000 writes to generate a dataset
19:29:05 <RyanT5000> O'Caml's, and every other record system i've ever seen
19:29:14 <sproingie> seems right to me, it's just the value 5
19:29:16 <sproingie> with a label
19:29:36 <Cale> I don't mind that. Using the name/type pairs to define the datatype implicitly is what extensible records are about.
19:29:42 <RyanT5000> right, but the characters that compose the label shouldn't be relevant, even at compile-time
19:29:55 <RyanT5000> Cale: sure, i agree with you there, i just disagree that static strings are good "names"
19:30:11 <RyanT5000> it's basically the same thing as a global variable, except stateless
19:30:17 <RyanT5000> it shares many of the same problems
19:30:32 <Cale> Having to declare field labels is probably going to create more hassle than it will solve.
19:30:33 <RyanT5000> two "names" should never be equivalent unless they were derived from the same declaration
19:30:59 <RyanT5000> Cale: i'm pretty sure an assembly programmer would have said the same thing about not having global state
19:31:11 <RyanT5000> i don't mind the declaration being implicit
19:31:21 <RyanT5000> but there needs to be *some* identifiable declaration site
19:31:29 <RyanT5000> or you might as well just have it be a hash-map with strings
19:31:35 <Cale> The type of the function which takes the record as a parameter.
19:31:54 <Cale> (as it will include the same names)
19:32:07 <RyanT5000> hm
19:32:12 <RyanT5000> no, i don't think that works
19:32:17 <Cale> why not?
19:32:35 <RyanT5000> you still have the same problem where a structure from Library 1 that *happens* to use the same labels and types will *happen* to be the same type
19:33:02 <Cale> Yes, but since the data is out in the open, that just means that perhaps the libraries are usable together.
19:33:28 <RyanT5000> Cale: well, if they're *actually* usable together, you should be able to easily write a conversion function
19:33:34 <Cale> It's similar to getting a pair of Ints from one library, and passing it to another, with the understanding that those are the Ints you wanted.
19:33:38 <RyanT5000> just because someone says "type Point = {x :: Int, y :: Int}" doesn't mean they mean the same thing as every other person who says that
19:33:55 <RyanT5000> Cale: sure, but that doesn't *purport* to have anything aside from an ordering
19:34:10 <Cale> The records don't either.
19:34:13 <RyanT5000> i suppose not
19:34:28 <Cale> They just have fields with particular names and types.
19:34:46 <Cale> and if you want to impose more meaning, maybe use newtype?
19:35:15 <RyanT5000> lol i guess
19:35:42 <RyanT5000> i totally agree that records without declared labels are well-defined
19:36:05 <RyanT5000> i just don't believe in strings that are required to magically match :P
19:36:20 <RyanT5000> i'm not the hugest fan of tuples either, and i don't think anyone would suggest using really *large* tuples
19:36:45 <copumpkin> I use 53-tuples
19:36:45 <RyanT5000> (in place of records, anyway)
19:36:48 <RyanT5000> copumpkin: why?
19:36:51 <sproingie> copumpkin: !
19:36:51 <RyanT5000> lol
19:36:58 <copumpkin> just to be annoying
19:37:00 <RyanT5000> haha
19:37:10 <RyanT5000> just append 51 units to every pair
19:37:10 <copumpkin> :)
19:37:12 <RyanT5000> lol
19:37:34 <ivanm> copumpkin: have you defined your own custom fst53, snd53, thrd53, etc. functions? ;-)
19:37:38 <Cale> copumpkin: Insist that the GHC developers add more instances to the Prelude for you ;)
19:37:44 <copumpkin> damn right!
19:37:59 <sg> everyone knows it should be 42-tuples
19:38:08 <Cale> frtysnd53
19:38:11 <copumpkin> 42 is so last millennium
19:38:15 <RyanT5000> shouldn't fst and snd be in a typeclass?
19:38:27 <copumpkin> they are in one hackage package
19:38:29 <RyanT5000> huh
19:38:31 <copumpkin> by augustss I think
19:38:42 <RyanT5000> the prelude seems like it could use a makeover
19:38:56 <copumpkin> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html
19:39:01 <sg> btw, not related but...
19:39:03 <copumpkin> RyanT5000: definitely :)
19:39:03 <Cale> RyanT5000: Most people agree. Nothing gets done for some reason.
19:39:15 <copumpkin> there's a slightly concerted effort in #alt-stdlib
19:39:18 <copumpkin> but it's been quiet recently
19:39:19 <Cale> RyanT5000: But, join #alt... right
19:39:24 <sg> i never used haskell and would like to read on it's different features from usual languages
19:39:43 <sg> i've heard about monads what are other different concepts i could read on?
19:39:53 <Cale> sg: What counts as a usual language?
19:39:53 <copumpkin> don't start with monads
19:39:59 <copumpkin> that's my suggestion
19:40:04 <sg> Cale: well, the typical imperative language
19:40:04 <ivanm> Cale: well, there's a couple of alternatives...
19:40:17 <ivanm> sg: it isn't imperative
19:40:18 <copumpkin> monads are way overhyped by people who don't know haskell talking about haskell
19:40:18 <Cale> sg: Oh, then, just about everything is different.
19:40:19 <ivanm> ;-)
19:40:29 <RyanT5000> sg: have you looked at any of the tutorials?
19:40:33 <sg> Cale: that's why i'm interested
19:40:34 <RyanT5000> the best way to learn is by doing
19:40:37 <ivanm> copumpkin: overhyped in a negative way?
19:40:41 <sproingie> learn you a haskell is a good tutorial
19:40:48 <ivanm> doesn't "hyping" normally involves positive stuff?
19:40:48 <RyanT5000> yup
19:40:49 <sg> RyanT5000: i don't really want to learn haskell
19:40:52 <Cale> sg: So, the first thing is that variables never change value so long as they remain in scope.
19:40:52 <copumpkin> I just think people make too much of a deal out of them
19:40:58 <sg> i just want to read on it's different features
19:41:04 <sproingie> variables aren't
19:41:09 <copumpkin> ivanm: not really
19:41:13 <sg> specifically those that are very different from other languages
19:41:21 <RyanT5000> sg: immutability, laziness, typeclasses
19:41:25 <ivanm> copumpkin: agreed; I just think that "make too much fuss about" is a better description than "overhyped"
19:41:27 <RyanT5000> those are the biggest ones
19:41:34 <sproingie> laziness, type inference, those are big
19:41:36 <copumpkin> ivanm: if you insist :)
19:41:40 * ivanm checks that most authorative of sources, wikipedia!
19:41:40 <RyanT5000> yeah, type inference is big
19:41:41 <ivanm> copumpkin: heh
19:41:52 <Cale> sg: Or, more generally, if you have functions f and g such that f x == g x for every x, then you can replace f with g throughout the program (functions are completely determined by the values they produce)
19:41:53 <RyanT5000> though, i wish someone would give me inferred type aliases!
19:41:55 <sproingie> polymorphism is real odd.  values themselves are polymorphic
19:41:56 <RyanT5000> lol
19:42:03 <ivanm> copumpkin: http://en.wiktionary.org/wiki/overhyped
19:42:06 <copumpkin> make exaggerated claims about (a product, idea, or event); publicize or promote excessively
19:42:09 <sg> Cale: so a function that get's the same input always returns the same value?
19:42:17 <RyanT5000> Cale: what do you think of this idea: type Blah inferred
19:42:18 <Cale> sg: indeed, that's true as well
19:42:22 <RyanT5000> inferred is a new keyword
19:42:27 <ivanm> copumpkin: right, usually to _get_ people interested
19:42:29 <RyanT5000> (that i'm proposing for the sake of argument)
19:42:30 <ivanm> not to drive them away!
19:42:33 <Cale> sg: So functions are proper mathematical functions
19:42:38 <copumpkin> lol
19:42:48 <sg> that looks like automatic memoization
19:42:49 <RyanT5000> Blah always has the same meaning, wherever it occurs, but its meaning is inferred by the compiler
19:42:55 * copumpkin shrugs and gets back to proving boring elementary statements in agda
19:43:10 <RyanT5000> sg: well, functions aren't automatically memoized, but results are
19:43:16 <Cale> sg: While it would be possible to memoise functions automatically, it's not done because it would eat memory like nobody's business.
19:43:36 <sproingie> right, and what haskell needs is more space leaks
19:43:39 <RyanT5000> sg: of course, almost every language memoizes results, they just usually do it upfront
19:43:40 <sg> Cale: see, i'm interested in rare features, i find them nice. I've been reading on ML pattern matching for example
19:43:47 <ivanm> Cale: especially when you don't actually want a particular function to be memoised
19:43:49 <RyanT5000> sg: Haskell hsa that
19:43:50 <sg> that's the kind of thing i'm looking for
19:43:51 <ivanm> sproingie: heh
19:43:53 <RyanT5000> *has
19:44:03 <Cale> sg: another thing is that unlike most languages, expressions in Haskell are typically evaluated outermost first
19:44:08 <ivanm> @remember sproingie [about auto-memoisation] right, and what haskell needs is more space leaks
19:44:09 <lambdabot> Good to know.
19:44:27 <sg> Cale: i don't think i really understand that
19:44:34 <sg> what does outermost first mean?
19:44:40 <Cale> sg: So suppose we had a function like  double x = x + x
19:44:45 <ivanm> sg: most langauges, if you have something like 2 * (3 + 4), you do the 3+4 first
19:44:48 <Cale> and we have an expression  double (double 5)
19:44:49 <dibblego> cue double function
19:44:53 <ivanm> dibblego: heh
19:45:04 * ivanm lets Cale explain, as it's probably better
19:45:24 <Cale> Then in strict evaluation which is what most common languages use, we would evaluate the innermost expressions first:
19:45:27 <Cale> double (double 5)
19:45:30 <Cale> -> double (5 + 5)
19:45:32 <Cale> -> double 10
19:45:35 <Cale> -> 10 + 10
19:45:37 <Cale> -> 20
19:45:41 <sg> exactly
19:45:59 <Cale> But under outermost-first evaluation, we start from the outside
19:46:02 <Cale> double (double 5)
19:46:09 <Cale> -> (double 5) + (double 5)
19:46:18 <Cale> -> (5 + 5) + (double 5)
19:46:27 <Cale> -> 10 + (double 5)
19:46:30 <Cale> -> 10 + (5 + 5)
19:46:33 <Cale> -> 10 + 10
19:46:35 <Cale> -> 20
19:46:48 <ivanm> Cale: implementation wise, don't both occurences of "double 5" in the reduction "point to" the same thunk?
19:46:57 <Cale> Obviously, we've duplicated some work here, so what Haskell does is a little different
19:47:03 <sg> mmm, that's really strange
19:47:08 <sg> i mean... unexpected
19:47:14 <Cale> Haskell does something called lazy evaluation which is a refinement of outermost first evaluation
19:47:21 <sg> at least if you come from other backgrounds
19:47:27 <ivanm> sg: because Haskell generally doesn't evaluate something until it absolutely has to be evaluated
19:47:46 <Cale> what it says is that a parameter to a function which occurs multiple times in the body of the function is evaluated at most once and shared between the copies
19:47:52 <Cale> So, it looks more like:
19:47:55 <Cale> double (double 5)
19:48:01 <Cale> -> let x = double 5 in x + x
19:48:02 <tommd> It also evaluates if the closure taunts it too much.
19:48:06 <Cale> -> let x = 5 + 5 in x + x
19:48:09 <Cale> -> let x = 10 in x + x
19:48:12 <Cale> -> 20
19:48:38 <ivanm> tommd: heh
19:48:40 <sg> "a function which occurs multiple times in the body of the function is evaluated at most once..."
19:48:46 <Cale> sg: Under strict evaluation, we always evaluate every parameter to a function exactly once.
19:48:57 <sg> that's because it will always yield the same result, right?
19:49:00 <Cale> sg: Under outermost first evaluation, we evaluate each parameter zero or more times.
19:49:03 <sg> that's guaranteed i suposse
19:49:13 <Cale> sg: Under lazy evaluation we evaluate it zero or one times.
19:49:44 <Cale> It will always give the same result regardless.
19:49:44 <sg> isn't it sometimes confusing? i mean you don't really know when something will be evaluated
19:50:12 <Cale> sg: That is true, but since evaluation has no side effect but to produce a value, it usually doesn't matter when.
19:50:31 <ora> Is there a good place to look to get the code reloading functionality of hsplugins? Or is there a working/compiling version of hsplugins somewhere?
19:50:32 <Cale> The answer is "when you need the value"
19:50:41 <ivanm> sg: yes, but usually you don't care if/when something is actually evaluated
19:50:44 <Cale> ora: Try hint
19:50:55 <ivanm> ora: plugins is a replacement for hsplugins
19:50:56 <sg> how about debugging?
19:51:10 <sg> will that make it more difficult?
19:51:38 <ivanm> sg: the only time it's usually important is when you have a recursive function with a counter or something, then you generally want to force the counter to be updated at each step to stop having a large chain of function evaluations to be applied later
19:51:41 <Cale> sg: Yeah, it does mess with that, as it's much harder to get a stack trace which is meaningful, but on the other hand, testing things independently is far more effective in Haskell.
19:51:54 <pip_> I have a simple question.  If I have a function (a->a->a)->[a]->a->[a] i.e. [1,2,3] * 2 = [2,4,6], what I have to do to make 2 * [1,2,3] possible?
19:51:54 <ivanm> sg: usually, debugging == using the interpreter ;-)
19:52:05 <ora> ivanm: Thanks, but plugins doesn't compile for me :(
19:52:05 <ivanm> pip_: you can't
19:52:09 <ivanm> not with *
19:52:14 <ivanm> pick a different symbol for starters!
19:52:18 <ivanm> ora: oh? why not?
19:52:19 <ora> Cale: Thanks! I looked into it before and it baffled me to no end, but I'll take another look.
19:52:26 <sg> Cale: ivanm: thanks a lot for the explanations. very helpful
19:52:52 <sg> it's there some kind of reference i can read about those distinguising features? (i don't like stealing people's time too much)
19:52:57 <pip_> so I need two functions, one for 2 * [1,2,3] and one for [1,2,3] * 2?
19:53:11 <Cale> sg: Referential transparency means that if you test a function in isolation and it works, then it's guaranteed to work the same way as part of the whole program.
19:53:16 <sproingie> * is defined for Num, you can't overload it for anything that isn't an instance of Num
19:53:27 <ivanm> pip_: I meant "* is already taken for multiplication", but yes, you'd need something different
19:53:40 <sjanssen> pip_: yes, or some ad-hoc overloading with type classes.  I'd recommend two functions, or arrange to use one function consistently
19:53:49 <RyanT5000> Cale: here's my fundamental problem with the unsited labels: they complicate the domain of discourse that programmers are expected to bring to the table when they start using the libraries
19:53:51 <Cale> sg: Well, I would start with a Haskell tutorial. We've only really scratched the surface here. There are lots of cool things later on like typeclasses and all the various things you can do with those.
19:53:54 <ivanm> pip_: if you have say "foo 2 [1,2,3]", then "flip foo [1,2,3] 2" will work
19:54:01 <RyanT5000> Cale: tuples don't - everyone already understands Nat
19:54:24 <ivanm> Cale: like embed Basic into Haskell? :p
19:54:30 <Cale> ivanm: haha
19:55:00 <Cale> sg: Oh, and algebraic datatypes, which are rather nice.
19:55:06 <Cale> sg: (ML has those too)
19:55:22 <RyanT5000> Cale: but "x = 5" in the context of a point requires that the programmer understand what "x" means
19:55:38 <Cale> GHC also has fancier extensions like GADTs and type families
19:55:39 <RyanT5000> Cale: in other words, the declaration site is *outside* the program, in the real world
19:55:56 <Cale> RyanT5000: hmm...
19:55:58 <pip_> Thanks ivanm.  So it is hard if I want 2 `foo` [1,2,3] and [1,2,3] `foo` 2?
19:56:08 <ivanm> pip_: yes
19:56:18 <ivanm> you can do it by type-class hackery, but I wouldn't bother
19:56:19 <Cale> RyanT5000: It's not just a label which is mentioned by the types in the API of the library that the programmer is using?
19:56:20 <RyanT5000> Cale: whereas, if there's a definition site, then the meaning is defined *completely* within the program
19:56:24 <ivanm> 2 `flip foo` [1,2,3]
19:56:32 <ivanm> though I'm not sure if you can do that...
19:56:33 <sjanssen> ivanm: nope
19:56:41 <ivanm> > [1,2] `flip (:)` 3
19:56:42 <lambdabot>   <no location info>: parse error on input `('
19:56:44 <ivanm> :(
19:56:53 <ivanm> sjanssen: it would be cool if you could though
19:56:54 <RyanT5000> Cale: well, i suppose you could take it that way, but then you'd have *absolutely no basis* for thinking it was compatible with other libs' identical labels
19:57:26 <Cale> RyanT5000: Well, you know what it means if you also know what the functions do.
19:58:03 <RyanT5000> Cale: true
19:58:14 <Cale> Just like, well,  permutations :: [a] -> [[a]]  doesn't actually tell you what the function does, but if you're allowed to interpret the function name and read the documentation for it, then you can know that :)
19:58:17 <RyanT5000> Cale: the really bad parts are where you get *incompatible* things that are also label-compatible
19:58:34 <Cale> RyanT5000: I suppose.
19:58:37 <RyanT5000> e.g.: the classic "Canvas::Draw" "Lottery::Draw" problem
19:58:45 <RyanT5000> (from design & evolution of C++)
19:58:52 <RyanT5000> (i still respect Stroustrup)
19:59:04 <sjanssen> what are we talking about?  Record systems?
19:59:07 <RyanT5000> sjanssen: yes
19:59:09 <Cale> sjanssen: yeah
19:59:17 <RyanT5000> and how i'd like labels to have declarations
19:59:31 <sjanssen> not an unreasonable idea
19:59:37 <RyanT5000> because i don't like expanding the size of the domain of discourse that's assumed as a prerequisite to using the language
19:59:41 <Cale> (and I'd just like the label names to appear in the types of the values)
19:59:45 <RyanT5000> that's my best explanation of my gut feeling somehow :P
20:00:12 <aavogt> ivanm: you can sort of do that infix stuff: http://haskell.org/haskellwiki/Infix_expressions
20:00:49 <sjanssen> RyanT5000: what would a declaration be?  Would it put any restrictions on the type of the member?
20:01:00 <RyanT5000> sjanssen: i'm not even so concerned about that
20:01:11 <ivanm> aavogt: yeah, seen that... a bit ugly though IMHO
20:01:25 <RyanT5000> sjanssen: i don't really think the label should have a type declared with it
20:01:27 <Cale> sjanssen: Presumably it would exist solely so that you could explicitly qualify which module's version of the label you meant.
20:01:36 <RyanT5000> because then you couldn't have parametric polymorphism
20:02:52 <Cale> RyanT5000: How do you stand on lacks predicates?
20:03:08 <RyanT5000> what are those?
20:03:26 <Cale> Contextual things which express that some row variable lacks a field with a given label
20:03:29 <sg> Cale: sorry (i'm working too)
20:03:43 <sproingie> Cale: like pattern matching on the absence of something?
20:03:57 <RyanT5000> Cale: that would seem to require soft typing of row types
20:03:59 <Cale> Usually used to ensure that when you extend a record with some new label, it doesn't already have a label with that name
20:04:15 <RyanT5000> Cale: oh, you mean a type-system-level predicate?
20:04:18 <Cale> yes
20:04:25 <RyanT5000> hm
20:04:30 <Cale> TRex had them
20:04:36 <RyanT5000> those seem necessary
20:04:46 <Cale> But some of the proposals, like Daan Leijen's, don't.
20:05:09 <Cale> Daan Leijen's idea was that if you extend a record multiple times at the same label, they should behave like a stack.
20:05:11 <copumpkin> I wish I were a Daan rather than a Dan
20:05:17 <copumpkin> having a double A in one's name is so much cooler
20:05:33 <copumpkin> RyaanT5000
20:05:40 <copumpkin> Caale?
20:05:42 <Cale> copumpkin: You could legally change your name to Daaniel
20:05:42 <RyanT5000> haha
20:05:52 <RyanT5000> Cale: i'm not so sure about the stack idea
20:05:59 <RyanT5000> Cale: but i'm not really sure about that problem at all
20:06:02 <sproingie> sproingii
20:06:05 <RyanT5000> Cale: honestly,  i don't like records
20:06:06 <ivanm> copumpkin: so you don't want to be named after a vegetable anymore? ;-)
20:06:17 <copumpkin> Cale: but that would be trying too hard! if you have to make an effort to be cool, that's automatically uncool
20:06:18 <RyanT5000> i think records should be the same thing as environments
20:06:27 <copumpkin> ivaanm: oh no, I love my vegetable
20:07:08 <RyanT5000> then, records should be openable
20:07:15 <ivanm> @slap copumpkin
20:07:16 * lambdabot moulds copumpkin into a delicous cookie, and places it in her oven
20:07:22 <Cale> copumpkin: vegetaable
20:07:25 <RyanT5000> and, perhaps, environments should be reflectable
20:07:27 <copumpkin> lol
20:07:29 <RyanT5000> in the sense that you could say something like
20:07:42 <RyanT5000> "env", as a keyword, which would have a value equal to a record equal to your current environment
20:08:15 <Cale> I'm not 100% sure what that means, but I have an idea :)
20:08:24 <RyanT5000> Cale: neither am i
20:08:28 <RyanT5000> lol
20:08:33 <RyanT5000> it's an idea i've been pondering for a while now
20:08:57 <RyanT5000> it's related to my perpetual quest to get rid of the idea of a "Top Level Scope"
20:09:51 <sjanssen> Haskell doesn't have a top-level scope, does it?
20:09:57 <RyanT5000> sjanssen: sure it does
20:09:58 <sjanssen> I guess module names are top-level
20:10:02 <RyanT5000> where are all your types declared?
20:10:16 <RyanT5000> i mean, you can't put a "data" in a "let", can you?
20:10:24 <sproingie> that would be awesome
20:10:29 <RyanT5000> yeah
20:10:39 <RyanT5000> and, i understand that there are some annoyances that that would cause in the type system
20:10:39 <sproingie> drive the parser absolutely bananas tho
20:10:45 <RyanT5000> i think the parser could deal :P
20:11:39 <sproingie> reminds me a bit of postgres, where you can stick arbitrary ddl into a transaction
20:11:55 <sproingie> i've defined whole new types in one SP that way
20:12:01 <RyanT5000> ddl?
20:12:07 <sproingie> data definition language
20:12:09 <RyanT5000> ah
20:12:10 <sproingie> like CREATE TABLE
20:12:29 <RyanT5000> ah, sproingie, were you reading what i was saying earlier about composable schema?
20:12:33 <RyanT5000> i *really* want that, lol
20:12:41 <RyanT5000> i want to be able to make database-like structures in Haskell
20:12:50 <RyanT5000> but populate them entirely with Haskell datatypes
20:12:50 <sproingie> er wait that's dml.  i think.  i can never remember.
20:12:58 <RyanT5000> either way :P
20:13:05 <sproingie> er dml is manipulation, so nvm
20:14:54 <sproingie> loosely following the conversation, yah
20:15:28 <RyanT5000> sproingie: the thing that always annoys me about databases is the lack of expressiveness of the cell datatypes and the marshalling necessary to get stuff in and out
20:15:38 <RyanT5000> other than that, relational stuff is really cool
20:15:51 <RyanT5000> has anyone made a non-gimped relational paradigm?
20:16:19 <sproingie> depends what you mean by gimped.  all the "pure" ones are usually of academic interest only
20:16:28 <jmcarthur> which saddens me
20:16:30 <sproingie> in the end, people really want their nulls
20:16:48 <sproingie> i personally don't think null is so evil, i just think NOT NULL should have been the default
20:16:51 <RyanT5000> by pure do you mean (essentially) non-monadic?
20:16:55 <jmcarthur> it would be awesome to see something in the fashion of datalog applied to the real world
20:17:18 <RyanT5000> oh, another thing! column labels should have declaration sites :P
20:17:20 <sproingie> i mean pure as in upholds some notion of purity, like databases that deliberately withhold null
20:17:31 <RyanT5000> i'm really only a several-trick pony, lol
20:17:39 <jmcarthur> i want databases to have more interesting type systems, too
20:18:01 <jmcarthur> i don't want nullable attributes. i want Maybe attributes! ;)
20:18:18 <RyanT5000> yeah, Maybe is the best thing that ever happened to Null :P
20:18:32 <sproingie> yah, Maybe Just rocks
20:18:43 <sproingie> (you see what i did there?)
20:18:51 <jmcarthur> i see what you did there
20:19:28 * inimino sees Nothing
20:19:31 <jmcarthur> but more generally, ADTs in a relational database would be awesome
20:19:47 * roconnor sees Just sproingie
20:19:57 <jmcarthur> sooooo many times i've wished for a sum type
20:20:39 <RyanT5000> lol
20:20:47 <RyanT5000> ADTs everywhere are awesome
20:21:07 <jmcarthur> we should just make a RDBMS in haskell
20:21:12 <jmcarthur> with haskelly features
20:21:17 <copumpkin> hql?
20:21:19 <jmcarthur> maybe even just have it as a haskell dsl
20:21:34 <copumpkin> prql
20:21:36 <jmcarthur> edsl, i mean
20:21:39 <copumpkin> pronounced as prequel
20:21:45 <jmcarthur> oooh
20:21:56 <ivanm> jmcarthur: a sum type? what do you mean?
20:22:05 <copumpkin> ivanm: ze zum!
20:22:13 <jmcarthur> Either is an example of a sum type
20:22:42 <jmcarthur> contrast with a product type, like tuples
20:22:52 <ivanm> roconnor: can Colour deal with HSV values RGB values with an Alpha channel?
20:22:59 <sproingie> that would be neat.  i remember thinking mnesia was the bees knees because it's so integrated with erlang
20:23:05 <ivanm> jmcarthur: you want a more general sum type than Either?
20:23:22 <jmcarthur> yes
20:23:27 * copumpkin wants dependent sums in haskell
20:23:30 <ivanm> sproingie: well, mnesia isn't an RDBMS
20:23:32 <copumpkin> (kthx)
20:23:34 <jmcarthur> although perhaps you missed that we are talking about relational databases
20:23:43 <ivanm> yes ;-)
20:23:49 <sproingie> relational shmelational
20:23:52 <ivanm> heh
20:23:53 <copumpkin> nothing better than dependent sums for relationalness
20:24:12 <copumpkin> haskell is hard!
20:24:15 <copumpkin> let's go write some agda!
20:24:31 <jmcarthur> dependently typed relational database management system
20:24:32 <ora> ivanm: regarding plugins, I lied - it's not that it didn't compile, it just had issues whenever you tried to use it (typically having an error something like: unknown symbol `base_GHCziBase_map_closure')
20:24:39 <ivanm> heh
20:24:42 <jmcarthur> can we make that longer and more buzzwordy?
20:25:08 <copumpkin> try to integra calculus of constructions in there somewhere
20:25:13 <copumpkin> integrate, that is
20:25:28 <jmcarthur> you mean the coinductive calculus of constructions, i assume? ;)
20:25:38 <copumpkin> the cocalculus
20:25:42 <copumpkin> of nstructions
20:26:12 <copumpkin> well, we actually need the extended calculus of constructions anyway
20:26:19 <jmcarthur> right
20:27:05 <sproingie> coculus
20:27:27 <ivanm> roconnor: that should be "and RGB ..." ;-)
20:28:51 <roconnor> ivanm: it can deal with HSV
20:28:56 <roconnor> ivanm: it can deal with RGB
20:28:58 <pip_> another newbie question: i.e. data Moo a = Con a, how do I restrict a to be, i.e Num type?
20:29:00 <roconnor> and it can deal with alpha
20:29:06 <roconnor> (see AlphaColour)
20:29:09 <ivanm> \o/
20:29:23 <ivanm> duh, missed the RGBSpace.HSV module
20:29:23 <roconnor> ivanm: the issues are subtle, but all the pieces are there.
20:29:31 <ivanm> roconnor: *nod*
20:29:44 <roconnor> HSV doesn't really specify a colour
20:29:55 <roconnor> but HSV can be converted to an RGB tripple
20:30:09 <roconnor> and given a colour space (such as sRGB) that RGB triple can be turned into a colour.
20:30:17 <ivanm> roconnor: heh, about to ask that
20:30:18 <sproingie> pip_: put type constraints on the functions that deal with Moo a
20:30:43 <ivanm> roconnor: I take it the RGB value in the modules is the same just re-exported everywhere?
20:31:06 <roconnor> ivanm: the RGB type is rexported in many places, yes.
20:31:20 <roconnor> ivanm: HSV is not well tested
20:31:28 <roconnor> not tested at all really :)
20:31:30 <ivanm> heh
20:31:35 <roconnor> so there could be errors in the formula.
20:31:55 <roconnor> I think maybe I do test coverting back and forth with RGB works
20:32:34 <ivanm> roconnor: hmmm, I'm meant to have HSV values that are all 0<= x <= 1 IIRC...
20:32:47 <ivanm> so your hsv function doesn't seem to be applicable :s
20:34:23 <scutigera> data Foo = Foo Int Double, how is this a valid type decl.  The type shows up as Int -> Double -> Foo
20:34:30 <ivanm> roconnor: what I have to deal with: http://graphviz.org/doc/info/attrs.html#k:color
20:34:38 <ivanm> scutigera: because that's what it is
20:34:55 <ivanm> scutigera: Foo (the constructor) is a function that takes an Int, a Double and returns a Foo (the data type)
20:35:45 <scutigera> ivanm: oh, duh.  -> -> I thought it was "adjacent" types or something.  I completely forgot the constructor is really a function (right ?)
20:35:54 <ivanm> yup
20:36:05 <ivanm> it's just a special function!
20:36:31 <sproingie> it also allows for pattern-matching
20:36:35 <scutigera> any advantage to using Pt Double Double to define a point instead of Pt (Double, Double) ?
20:36:37 <roconnor> ivanm: yep, you are just given a bunch of coordinate, but without a basis there is no way to interpret those coordinates.
20:36:53 <ivanm> scutigera: partial application
20:37:03 <ivanm> scutigera: makes using Pt easier as well
20:37:16 <roconnor> ivanm: but you might as well assume that the coordinate system is sRGB.
20:37:23 <ivanm> scutigera: on the minus side, using a newtype on the pair would possibly be slightly more efficient at runtime
20:37:26 <ivanm> roconnor: *nod*
20:38:01 <scutigera> you could also strictify the elements (?)
20:38:09 <kmc> why would a newtyped pair be more efficient than a data with two fields?
20:38:20 <kmc> isn't "(,) a b" just a data type with two fields?
20:38:39 <kmc> scutigera, the main advantage is nicer syntax imo... tuples are noisy
20:38:40 <ivanm> kmc: because at runtime, it _is_ just a tuple
20:38:45 <ivanm> with no extra boxing, etc.
20:38:53 <blackdog> help me, obi-wan-lambdacats, you're my only hope
20:38:54 <blackdog> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4599#a4599
20:39:02 <ivanm> kmc: in general, if you have only a single value, newtype > data
20:39:07 <ivanm> not sure how valid it is with a tuple though
20:39:08 <kmc> ivanm, that's not what i'm asking
20:39:26 <kmc> ivanm, i think "newtype Foo = Foo (Int, Int)" and "data Foo = Foo Int Int" should be isomorphic
20:39:28 <eibmozoib> ivanm: why can't GHC optimise such cases to newtypes?
20:39:32 <blackdog> I'm a bit baffled - I don't understand where the Show constraint is coming from, and indeed, defining it at the prompt is fine
20:39:44 <ivanm> kmc: as I said, I don't know how valid my statement that newtype is better is
20:39:52 <ivanm> eibmozoib: because there are times you don't want it too
20:39:53 <kmc> ivanm, it's correct and not applicable
20:39:55 <kmc> eibmozoib, because there is a semantic difference
20:39:55 <ivanm> with unboxing, etc.
20:40:01 <ivanm> kmc: heh
20:40:17 <ivanm> blackdog: add an explicit type sig
20:40:19 <ivanm> duh ;-)
20:40:22 <scutigera> ivanm: have noticed that the Pt X X form is a little nicer
20:40:28 <kmc> ivanm, you're right that newtype will be faster than data for one field.  what i'm saying is that newtype of one field which is a tuple is no different than data of two fields
20:40:34 <eibmozoib> What is the semantic difference?
20:40:36 <kmc> because that tuple is just another data type...
20:40:48 <ivanm> kmc: agreed; I was stating that it _might_ be better, I wasn't sure
20:41:02 <blackdog> ivanm: there's a type sig on it already.
20:41:10 <kmc> eibmozoib, if "newtype Foo = Foo Int" then "undefined" and "Foo undefined" are the same
20:41:11 <ivanm> blackdog: :o
20:41:23 <ivanm> blackdog: oh, missed the code up the top
20:41:33 <blackdog> ivanm: i'm just confused as to why defining it at the ghci prompt is different to defining it in a file
20:41:35 <ivanm> blackdog: (Data.Map.deleteMin :: FOo)
20:41:38 <kmc> if it's data you could do "case Foo undefined of Foo _ -> ()" and not hit the undefined
20:41:46 <kmc> newtype doesn't add another layer of laziness the way data does
20:41:48 <ivanm> blackdog: defaulting?
20:41:54 <kmc> that's because the newtype's runtime representation is the same as the underlying type
20:41:59 <eibmozoib> Ah, I see.
20:42:02 <scutigera> kmc: why should Foo (X,X) and  Foo X X be isomorphic ?
20:42:19 <ivanm> scutigera: kmc just said they weren't
20:42:36 <blackdog> ivanm: hm. maybe. "Value" is represented by a CULong...
20:42:36 <kmc> i was saying Foo (X,X) is isomorphic to Bar X X, if Foo is a newtype and Bar is data
20:42:49 <ivanm> oh, "why should"
20:42:49 <kmc> because Foo (X,X)  is isomorphic to (X, X)
20:42:59 <ivanm> yeah, I missed you saying that you think they should be
20:42:59 <kmc> and "data (,) a b = (,) a b"
20:43:09 <kmc> is just as good as "data Bar a b = Bar a b"
20:43:14 <ivanm> kmc: well, Foo !X !X /= (!X, !X) IIRC
20:43:15 <blackdog> ivanm: but why is ghci behaving differently?
20:43:21 <ivanm> blackdog: defaulting?
20:43:29 <ivanm> (again :P)
20:43:32 <kmc> are tuples more strict than other product types?
20:43:41 <kmc> > case (undefined, undefined) of (_,_) -> ()
20:43:42 <lambdabot>   ()
20:43:43 <blackdog> ivanm: hang on, defaulting only happens in ghci?
20:44:06 <ivanm> blackdog: pretty much, or a top-level value I think
20:44:23 <ivanm> kmc: I would think less possibly
20:44:45 <ivanm> kmc: I'm not sure if you can have unboxed values in a tuple as well
20:44:57 <kmc> @kind (,)
20:44:58 <lambdabot> * -> * -> *
20:45:01 <kmc> looks like no
20:45:08 <scutigera> ivanm: uvector uses unboxed tuples
20:45:15 <kmc> there are unboxed tuples
20:45:15 <ivanm> dons did a blog post recently about adaptive lists and IIRC, he did a data type to replace (Int,Int) for improved performance
20:45:22 <ivanm> scutigera: *shrug* shows what I know ;-)
20:45:26 <kmc> they're not the same as tuples of unboxed values
20:45:38 <kmc> in fact unboxed tuples can't even be passed to functions as args
20:45:41 <kmc> @kind (->)
20:45:42 <lambdabot> ?? -> ? -> *
20:45:44 <scutigera> kmc: uh, oh, true...
20:46:14 <kmc> ?? is * union #
20:46:14 <lambdabot>  is * union #
20:46:18 <kmc> ha
20:46:20 <ivanm> blackdog: using that wrappedDeleteMin in ghci might cause problems as well
20:46:28 <kmc> ? is ?? union (#)
20:46:30 <kmc> iirc
20:47:00 <kmc> @kind Int#
20:47:01 <lambdabot> Not in scope: type constructor or class `Int#'
20:47:02 <ivanm> kmc: http://donsbot.wordpress.com/2009/10/11/self-optimizing-data-structures-using-types-to-make-lists-faster/
20:47:21 <ivanm> though dons is using {-# UNPACK #-} pragmas there
20:47:33 <kmc> the point of that is that it's monomorphic and unpacked
20:47:36 <kmc> and strict
20:47:59 <kmc> to my knowledge "data Foo a b = Foo a b" should behave identically to (,)
20:48:04 <ivanm> hmmm.... does !Int = {-# UNPACK $-} Int ?
20:48:08 <kmc> aside from of course the special syntax
20:48:37 <ivanm> kmc: even for Foo !a !b ?
20:48:45 <kmc> no, that's a different thing
20:48:50 <ivanm> kmc: right
20:48:54 <ivanm> _that_ is what I'm talking about
20:49:04 <ivanm> and why there can't be an automatic conversion done by GHC
20:49:05 <kmc> but that would be a different definition
20:49:11 <ivanm> (AFAIK, anyway)
20:49:18 <kmc> you can't take my Foo there and somehow instantiate it at a strict type
20:49:40 <kmc> strict does not necessarily imply unboxed, but ghc will make that optimization with -funbox-strict-fields
20:49:46 <eibmozoib> kmc: but newtype X = X Int should not be synonymous with data X = X Int, right?
20:49:58 <kmc> what do you mean by "synonymous"
20:50:03 <kmc> they are observably different
20:50:04 <dibblego> eibmozoib, it's not
20:50:18 <eibmozoib> That is what I am asserting.
20:50:22 <ivanm> due to undefined goodness/badness
20:50:26 <scutigera> ooh, ooh, I knew that.  Does snoopy dance.
20:50:32 <kmc> they are mostly interchangeable though
20:50:36 <ivanm> scutigera: heh
20:50:39 <kmc> if you don't have any bottoms in your data
20:50:57 <eibmozoib> But substituting (,) for Int are newtype/data equivalent?
20:51:11 <kmc> ?
20:51:22 <kmc> you can't write "newtype X = X (,)", that's a kind error
20:51:48 <eibmozoib> Good point. data P a b = P x y then
20:51:59 <ivanm> eibmozoib: that makes no sense either
20:52:00 <kmc> x and y are not in scope
20:52:04 <ivanm> exactly!
20:52:19 <kmc> "data P a b = P a b" ==> P is isomorphic to (,)
20:52:23 <eibmozoib> I'm obviously having a bad day.
20:52:51 <scutigera> well, those learning Haskell have a bad day, almost everyday
20:53:10 <ivanm> kmc: well, newtype'd (,)
20:53:26 <ivanm> well, it depends on isomorphic in usage or isomorphic in how they act
20:53:27 <eibmozoib> Is a pair type that is defined with newtype distinguishable from one defined with data?
20:53:32 <scutigera> :t (,)
20:53:33 <scutigera> (,) :: a -> b -> (a, b)
20:53:34 <lambdabot> forall a b. a -> b -> (a, b)
20:53:34 <kmc> i feel like we're running in circles
20:53:36 <kmc> eibmozoib, yes
20:53:56 <ivanm> eibmozoib: by people using it?no
20:53:59 <ivanm> * no
20:54:00 <scutigera> so is (,) just syntactic sugar then
20:54:01 <kmc> if P is newtyped then "P undefined undefined" cannot be distinguished from "undefined"
20:54:01 <ivanm> kmc: yeah
20:54:08 <kmc> if it's data, including the standard (,), then it can
20:54:24 <ivanm> kmc: do you mean "isomorphic" in what it represents, or "isomorphic" in how you use it?
20:54:34 <kmc> i mean there is a bijection between the values of the two types
20:54:37 <kmc> a computable bijection even
20:54:45 <ivanm> because one way that P differs from (,) is that you can hide its implementation and have new instances
20:55:02 <ivanm> so in terms of usage they may not have a bijection
20:55:08 <scutigera> bijection is a made up, right. like impredicate polymorphism.
20:55:13 <kmc> ?
20:55:16 <ivanm> a _newtyped pair_ however, yes, could in general be considered isomorphic to a data pair
20:55:21 <ivanm> scutigera: ?
20:56:14 <scutigera> ivanm: bijection is a real term/word ?
20:56:48 <copumpkin> yup
20:57:14 <scutigera> teh google only comes up with about 10 pages for "impredicate polymorphism".
20:57:21 <ivanm> scutigera: yes
20:57:25 <kmc> impredicative?
20:57:32 <ivanm> scutigera: bijection = injection + surjection
20:57:40 <kmc> "Results 1 - 10 of about 57,300 for impredicative polymorphism"
20:57:45 <ivanm> that one is a new one for me...
20:57:50 <kmc> a bijection between A and B is a
20:58:01 <ivanm> scutigera: technically, all words are made up ;-)
20:58:07 <kmc> way to associate every element of A with exactly one element of B, and vice versa
20:58:26 <scutigera> and nothing left out.   thank you wikipedia :-)
20:58:51 <ivanm> scutigera: well, if something was left out, then you couldn't have both conditions that kmc stated matched!
20:59:36 <scutigera> kmc: oh, I use scroogle and it comes up with 12 pages.  guess I should stop using scroogle.
20:59:37 <kmc> intuitively it's just a way to pair up the two sets so that nothing's left out
20:59:51 <ivanm> never heard of scroogle...
21:00:14 <kmc> in this case if "newtype Foo = Foo Bar" then for every x :: Bar we have Foo x :: Foo, and every Foo x :: Foo we have x :: Bar
21:00:32 <kmc> where we treat values extensionally; that is, we care about whether values are observably different
21:00:56 <scutigera> ivanm: http://scroogle.org/  google for the tinfoil hat crowd ;-)
21:01:01 <kmc> whereas with "data", Foo contains "one more" extensionally different value
21:01:55 <ivanm> scutigera: all I see there is an ugly web page ;-)
21:03:06 <scutigera> ivanm: yeah - you can go to the scraper link. it grabs google searches and doesn't let google have you ip, etc... http://www.scroogle.org/scraper.html
21:03:24 <bos> @seen dons
21:03:25 <lambdabot> Unknown command, try @list
21:03:31 <scutigera> ivanm: like I had, you can hear the crinkle of the foil
21:03:37 <scutigera> like I said
21:03:44 <ivanm> right...
21:03:49 <ivanm> preflex_: seen dons
21:03:49 <preflex_>  dons was last seen on #ghc 9 hours, 59 minutes and 57 seconds ago, saying: and makes the cost/benefit ratio of having them in /rts/ a bit more pleasant
21:03:52 <ivanm> bos: ^^
21:03:56 <bos> ta
21:03:57 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
21:04:07 <ivanm> bos: any idea when you'll update criterion to use the new version of Chart?
21:04:16 <bos> new version?
21:06:46 <ivanm> 0.12
21:07:26 <scutigera> oh this is going to be a dumb question: let a = Pt 1.0 2.0, how do I access the first or second value ??
21:07:49 <ivanm> scutigera: pattern match
21:07:55 <ivanm> or use a record data structure
21:08:41 <scutigera> let c d = a ??
21:09:17 <eibmozoib> let (Pt _ y) = a
21:09:35 <eibmozoib> er to get the 2nd
21:09:39 <scutigera> doh.  goes to kitchen to get paper bag
21:09:52 <Cale> case a of Pt x y -> x^2 + y^2
21:10:13 <Cale> norm (Pt x y) = sqrt (x^2 + y^2)
21:10:21 <Cale> things like that :)
21:11:53 <bos> ivanm: new version uploaded to hackage now
21:11:56 <scutigera> impredicative, not impredicate !
21:12:00 * hackagebot upload: criterion 0.1.3 - Robust, reliable performance measurement and analysis (BryanOSullivan)
21:12:11 <ivanm> bos: \o/
21:12:34 <ivanm> bos++
21:12:38 <ivanm> bos: how big was the change?
21:12:42 <bos> one line
21:12:43 <NutCobbler> I need a hint on how to change an Int into a straightforward Double.
21:12:47 <ivanm> bos: heh
21:12:56 <Cale> NutCobbler: fromIntegral
21:12:59 <scutigera> fromIntegral
21:13:03 <scutigera> too slow..
21:13:05 <NutCobbler> I've tried that..
21:13:10 <ivanm> bos: oh, whilst I remember: where did you get all the images you used for your keynote talk (where you talked about books, etc.)?
21:13:22 <ivanm> NutCobbler: and?
21:13:30 <scutigera> NutCobbler: always works for me
21:13:30 <ivanm> > fromIntegral 3 / 4.5
21:13:31 <lambdabot>   0.6666666666666666
21:13:36 <ivanm> NutCobbler: ^^
21:14:00 <roconnor> > fromIntegral 3 :: Double
21:14:01 <lambdabot>   3.0
21:14:18 <Cale> > fromIntegral (3 :: Int) :: Double
21:14:19 <lambdabot>   3.0
21:15:35 <bos> ivanm: flickr creative commons search
21:15:50 <ivanm> heh
21:16:15 <scutigera> is there a floating point version of ceiling, round, floor ?
21:16:27 <NutCobbler> o.K. The name of the function is miss leading. I used fromInteger before.
21:16:45 <NutCobbler> ...and the definition is just a complete deception.
21:18:25 <NutCobbler> How am I supposed to real? I think I'm getting it. I thought I would find something like fromIntegral :: Num b => Integral a => a -> b ..instead of: fromIntegral :: (Num b, Integral a) => a -> b
21:19:10 <ivanm> scutigera: ceil, round, floor?
21:19:17 <ivanm> > ceil 3.0
21:19:18 <lambdabot>   Not in scope: `ceil'
21:19:22 <ivanm> > ceiling 3.0
21:19:23 <lambdabot>   3
21:19:28 <Cale> NutCobbler: The part before the => is a class context and constrains the types a and b
21:19:28 <ivanm> OK, it's actually called ceiling
21:19:58 <scutigera> ivanm: ceiling returns an Int, I want realCeiling = fromIntegral ceiling
21:20:15 <roconnor> @type ceiling
21:20:16 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:20:17 <Cale> NutCobbler: It consists of a list of predicates which must be true of the type variables, in this case, b can be any numeric type, but a must be an integer-like numeric type
21:20:35 <ivanm> scutigera: fromIntegral . ceiling
21:20:37 <roconnor> > (ceiling 10^100) :: Int
21:20:39 <lambdabot>   0
21:20:43 <roconnor> > (ceiling 10^100) :: Integer
21:20:44 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
21:20:58 <roconnor> > (ceiling 10^10) :: Integer
21:20:59 <lambdabot>   10000000000
21:21:00 <NutCobbler> Nice. Implementing the types on my one function fixed a secondary problem!!!!
21:21:01 <roconnor> > (ceiling 10^10) :: Int
21:21:02 <lambdabot>   10000000000
21:21:06 <kmc> > 10^(10^100)
21:21:11 <lambdabot>   mueval: ExitFailure 1
21:21:21 <kmc> 2^2
21:21:23 <kmc> > 2^2
21:21:24 <lambdabot>   4
21:21:27 <scutigera> ivanm: ok, just wondering if it was already defined.  I have a bad habit of writing stuff like that when it's already defined :-)
21:21:27 <kmc> > 2^2^2
21:21:28 <lambdabot>   16
21:21:29 <kmc> > 2^2^2^2
21:21:30 <lambdabot>   65536
21:21:40 <scutigera> > 2 ** 3
21:21:42 <lambdabot>   8.0
21:21:47 <NutCobbler> round 5.5
21:21:54 <NutCobbler> > round 5.5
21:21:56 <lambdabot>   6
21:22:00 <NutCobbler> > round 5.4
21:22:01 <lambdabot>   5
21:22:02 <roconnor> scutigera: you don't need ivanm's code
21:22:12 <copumpkin> nobody needs ivanm
21:22:23 <ivanm> @slap copumpkin
21:22:24 * lambdabot would never hurt copumpkin!
21:22:24 <roconnor> scutigera: ceiling can return an Int, Integer, Word, whatever integral type you want.
21:22:26 <scutigera> yeah, but what about his code
21:22:37 <roconnor> > (ceiling 10^10) :: Int
21:22:38 <lambdabot>   10000000000
21:22:44 <ivanm> roconnor: he wants -> Double
21:22:48 <ivanm> so what's wrong with mine?
21:22:51 <roconnor> ahhhhhhhhhhhhhhhhhh
21:22:54 <NutCobbler> > 2^2^2
21:22:55 <ivanm> silly!
21:22:56 <lambdabot>   16
21:22:56 <scutigera> > fromIntegral ceiling 2.2
21:22:58 <lambdabot>   No instance for (GHC.Real.Integral (a -> b))
21:22:58 <lambdabot>    arising from a use of `GHC....
21:23:05 <copumpkin> wow, that was a big ahhhhhhhhhhhhhhhh
21:23:11 <ivanm> > fromIntegral . ceiling $ 2.2
21:23:12 <lambdabot>   3
21:23:16 <ivanm> scutigera: ^^
21:23:27 <kmc> > text ('a'ghci : repeat 'h')
21:23:28 <lambdabot>   Not in scope: `ghci'
21:23:30 <kmc> gaah
21:23:31 <roconnor> scutigera: whatever code you are writing, it sounds wrong. :)
21:23:32 <kmc> > text ('a' : repeat 'h')
21:23:37 <lambdabot>   mueval: ExitFailure 1
21:23:44 <kmc> hmm, text is strict?
21:23:46 <kmc> > ('a' : repeat 'h')
21:23:47 <NutCobbler> > :t repeat
21:23:47 <copumpkin> > text ('a' : replicate 100 'h')
21:23:47 <lambdabot>   "ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh...
21:23:48 <lambdabot>   ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh...
21:23:48 <lambdabot>   <no location info>: parse error on input `:'
21:23:50 <scutigera> roconnor: do tell.
21:24:01 <kmc> :t repeat
21:24:02 <lambdabot> forall a. a -> [a]
21:24:08 <kmc> > repeat ()
21:24:09 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
21:24:19 <kmc> > repeat repeat
21:24:27 <lambdabot>  Terminated
21:24:32 <copumpkin> :t sequence (repeat repeat)
21:24:36 <lambdabot> forall a. a -> [[a]]
21:24:37 <NutCobbler> > take 10 repeat ()
21:24:38 <scutigera> wow, lambdabot met somebody special
21:24:39 <lambdabot>   Couldn't match expected type `[a]'
21:24:40 <lambdabot>         against inferred type `a1 -> [a1]'
21:24:46 <roconnor> scutigera: ceiling :: Double -> Double is ringing alarm bells in my head.
21:24:49 <copumpkin> > sequence (repeat repeat) 5
21:24:50 <lambdabot>   [[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
21:24:53 <kmc> why is "repeat repeat" a problem?
21:24:59 <copumpkin> it's a function
21:25:05 <kmc> a list of functions probably isn't showable
21:25:06 <copumpkin> well, the show instance barfs :)
21:25:09 <copumpkin> it is
21:25:12 <copumpkin> > (+1)
21:25:13 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
21:25:18 <copumpkin> that's why it barfs
21:25:20 <kmc> oh it's the clever show
21:25:28 <kmc> > ('x':)
21:25:29 <lambdabot>   ""->
21:25:30 <lambdabot>    "x"
21:25:30 <lambdabot>  "a"->
21:25:30 <lambdabot>    "xa"
21:25:30 <lambdabot>  "aa"->
21:25:31 <lambdabot> [5 @more lines]
21:25:33 <copumpkin> > take 5 . repeat
21:25:34 <lambdabot>   {()->[(),(),(),(),()]}
21:25:53 <kmc> eating one battery; eating five batteries!
21:25:56 <roconnor> scutigera: doubles generally represent values of continuous variables, and integers are for discrete variables.
21:26:01 <NutCobbler> > take 20 . repeat
21:26:03 <lambdabot>   {()->[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]}
21:26:09 * copumpkin hates naming things
21:26:20 <copumpkin> that's the hardest part of writing a program
21:26:23 <roconnor> scutigera: descritizing a continuous value but staying in the continuous world is quite unusual.
21:26:29 <kmc> > inits . repeat
21:26:34 <lambdabot>   mueval-core: Time limit exceeded
21:26:41 <NutCobbler> :t inits
21:26:44 <lambdabot> forall a. [a] -> [[a]]
21:26:49 <kmc> > inits [1..5]
21:26:50 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
21:27:02 <kmc> > inits [1..]
21:27:04 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
21:27:05 <roconnor> scutigera: but not knowing what you are doing, it is hard for me to say for sure.
21:27:09 <copumpkin> inits is a slow function
21:27:23 <kmc> yeah
21:27:24 <copumpkin> tails on the other hand is fast
21:27:24 <kmc> > inits
21:27:25 <lambdabot>   []->
21:27:26 <lambdabot>    [[]]
21:27:26 <lambdabot>  [()]->
21:27:26 <lambdabot>    [[],[()]]
21:27:26 <lambdabot>  [(),()]->
21:27:27 <lambdabot>    [[],[()],[(),()]]
21:27:29 <lambdabot>  [(),(),(...
21:27:37 <copumpkin> > tails
21:27:38 <lambdabot>   []->
21:27:39 <lambdabot>    [[]]
21:27:39 <lambdabot>  [()]->
21:27:39 <lambdabot>    [[()],[]]
21:27:41 <lambdabot>  [(),()]->
21:27:43 <lambdabot>    [[(),()],[()],[]]
21:27:45 <lambdabot>  [(),(),(...
21:27:58 <kmc> could definitely pick a more instructive type...
21:28:05 <kmc> but i guess that's defaulting at work
21:28:11 <kmc> > tails :: [Int] -> [[Int]]
21:28:12 <copumpkin> it's good enough to show off inits/tails
21:28:12 <lambdabot>   []->
21:28:12 <lambdabot>    [[]]
21:28:12 <lambdabot>  [-2]->
21:28:12 <lambdabot>    [[-2],[]]
21:28:12 <lambdabot>  [-2,-1]->
21:28:14 <lambdabot>    [[-2,-1],[-1],[]]
21:28:16 <lambdabot>  [-2,-1,0...
21:28:31 <kmc> > inits :: [Char] -> [String]
21:28:33 <lambdabot>   ""->
21:28:33 <lambdabot>    [""]
21:28:33 <lambdabot>  "a"->
21:28:33 <lambdabot>    ["","a"]
21:28:33 <lambdabot>  "aa"->
21:28:35 <lambdabot> [3 @more lines]
21:28:38 <kmc> @more
21:28:38 <lambdabot>    ["","a","aa"]
21:28:39 <lambdabot>  "aaa"->
21:28:41 <lambdabot>    ["","a...
21:28:43 <bos> any reasonably wizardly types around at the moment?
21:28:44 <kmc> okay enuf spam
21:28:45 <bos> i'm trying to find a more elegant way to prevent let-floating and thunk overwriting in criterion.
21:28:53 <bos> the current scheme makes me sad.
21:28:57 <bos> the function being benchmarked needs to be evaluated on every loop iteration, or the measurements are nonsensical.
21:28:59 <scutigera> roconnor: think I'm ok.  typically I need a pair of real values to bracket an interval and make sure it includes the interval.  so floor for the min and ceiling for the max.
21:29:28 <scutigera> roconnor: other places too.  doesn't show up a lot.
21:29:48 <roconnor> scutigera: ah, okay.  Though you might be better off with some of the RealFloat functions.
21:29:49 <copumpkin> bos: how are you doing it now?
21:30:09 <roconnor> @type decodeFlaot
21:30:11 <lambdabot> Not in scope: `decodeFlaot'
21:30:14 <roconnor> @type decodeFloat
21:30:15 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
21:30:24 <roconnor> @type emcodeFloat
21:30:25 <lambdabot> Not in scope: `emcodeFloat'
21:30:31 <roconnor> @type encodeFloat
21:30:32 <kmc> > decodeFloat 12.34
21:30:32 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
21:30:33 <lambdabot>   (6946802425218990,-49)
21:30:35 <scutigera> roconnor: RealFloat ?
21:30:47 <kmc> > 6946802425218990 ** (2 ** (-49))
21:30:47 <bos> copumpkin: increment an Int on every iteration, and require the function to use it.
21:30:48 <lambdabot>   1.0000000000000648
21:30:50 <roconnor> RealFloat is a type class with functions like encodeFloat and decodeFloat
21:31:09 <kmc> > 6946802425218990 ** (2 ** (-48))
21:31:10 <lambdabot>   1.0000000000001297
21:31:11 <roconnor> 6946802425218990 * (2 ** (-49))
21:31:15 <roconnor> > 6946802425218990 * (2 ** (-49))
21:31:16 <lambdabot>   12.34
21:31:17 <kmc> er whoops
21:31:22 <kmc> nice
21:31:25 <roconnor> > 6946802425218990 * (2 ^ (-49))
21:31:26 <lambdabot>   * Exception: Negative exponent
21:31:29 <roconnor> > 6946802425218990 * (2 ^^ (-49))
21:31:30 <lambdabot>   12.34
21:32:07 <kmc> > decodeFloat pi
21:32:08 <lambdabot>   Ambiguous occurrence `pi'
21:32:09 <lambdabot>  It could refer to either `L.pi', defined at <loc...
21:32:13 <roconnor> scutigera: I'm thinking lower x := let (m,e) = decodeFloat x in encodeFloat (pred m) e
21:32:15 <kmc> :t L.pi
21:32:16 <bos> copumpkin: it works, but it's awkward to use.
21:32:16 <lambdabot> forall t. (Fractional t) => t
21:32:26 <NutCobbler> What's the easiest way to create a list of permutations?
21:32:35 <copumpkin> bos: trying to remember what I did when I started my benchmark lib
21:32:36 <roconnor> scutigera: and upper x = let (m,e) = decodeFloat x in encodeFloat (succ m) e
21:33:09 <roconnor> scutigera: though I'm unclear how that will work on boundary cases.
21:33:14 <kmc> NutCobbler, you can write it recursively
21:33:18 <scutigera> roconnor: neat.  didn't know about that, but not sure why it's better than fromIntegral . ceiling
21:33:52 <NutCobbler> kmc, I write one so often, I figure there has to be like one command to do it.
21:34:00 <roconnor> scutigera: it would provide tighter bounds, and probably work with large numbers.
21:34:30 <roconnor> > let lower x = let (m,e) = decodeFloat x in encodeFloat (pred m) e in lower 12.34
21:34:32 <lambdabot>   12.339999999999998
21:34:48 <roconnor> > let upper x = let (m,e) = decodeFloat x in encodeFloat (succ m) e in lower 12.34
21:34:49 <lambdabot>   Not in scope: `lower'
21:34:55 <roconnor> > let upper x = let (m,e) = decodeFloat x in encodeFloat (succ m) e in upper 12.34
21:34:56 <lambdabot>   12.340000000000002
21:35:07 <scutigera> roconnor: cool !
21:35:32 <scutigera> roconnor: that's an excellent addition to the bag of tricks.
21:35:39 <ivanm> bos: it doesn't want to build!
21:35:50 <roconnor> scutigera: I'd be careful how it deals with mantissa carrying
21:36:00 <roconnor> scutigera: I'd want to test that case carefully
21:36:02 <ivanm> bos: Criterion.hs:32:37: Module `Data.Array.Vector' does not export `concatU'
21:36:22 <scutigera> roconnor: mantissa carrying ??
21:36:32 <bos> ivanm: oh crud.
21:36:40 <ivanm> heh
21:36:53 <roconnor> > floatRange undefined
21:36:54 <lambdabot>   (-1021,1024)
21:36:56 <ivanm> bos: don't you test your own software? :p
21:37:01 <roconnor> > floatDigits undefined
21:37:02 <lambdabot>   53
21:37:06 <ivanm> that's uvector, isn't it?
21:37:38 <roconnor> scutigera: Doubles are represented as a 53 bit mantissa (integer) times 2^some exponent (between -1021 and 1024)
21:38:06 <scutigera> roconnor: yes,wrote my own ieee parser one :-(
21:38:08 <roconnor> > encodeFloat 2^53 0 -- mantissa too big to fit in 53 bits
21:38:09 <lambdabot>   No instance for (GHC.Num.Num (t -> b))
21:38:09 <lambdabot>    arising from the literal `53' at ...
21:38:28 <roconnor> > encodeFloat 2^53 0
21:38:29 <lambdabot>   No instance for (GHC.Num.Num (t -> b))
21:38:30 <lambdabot>    arising from the literal `53' at ...
21:38:37 <roconnor> > encodeFloat (2^53) 0
21:38:38 <kmc> > encodeFloat (2^53) 0
21:38:39 <lambdabot>   9.007199254740992e15
21:38:39 <lambdabot>   9.007199254740992e15
21:38:50 <roconnor> > decodeFloat (encodeFloat (2^53) 0)
21:38:51 <lambdabot>   (4503599627370496,1)
21:38:57 <roconnor> > decodeFloat (encodeFloat (2^53-1) 0)
21:38:59 <lambdabot>   (9007199254740991,0)
21:39:04 <copumpkin> bos: maybe http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11885#a11885 ?
21:39:07 * hackagebot upload: uvector 0.1.0.5 - Fast unboxed arrays with a flexible interface (BryanOSullivan)
21:39:13 <roconnor> > decodeFloat (encodeFloat (2^5+1) 0)
21:39:14 <lambdabot>   (4644337115725824,-47)
21:39:17 <ivanm> bos: heh
21:39:19 <roconnor> > decodeFloat (encodeFloat (2^53+1) 0)
21:39:20 <lambdabot>   (4503599627370496,1)
21:39:35 <roconnor> > (encodeFloat (2^53+1) 0) == (encodeFloat (2^53+2) 0)
21:39:36 <lambdabot>   False
21:39:39 <roconnor> > (encodeFloat (2^53+1) 0) == (encodeFloat (2^53+0) 0)
21:39:40 <lambdabot>   True
21:40:01 <roconnor> scutigera: ... anyhow, it seems to handle overflowing mantissa properly.
21:40:07 * hackagebot upload: criterion 0.1.4 - Robust, reliable performance measurement and analysis (BryanOSullivan)
21:41:13 <scutigera> roconnor: regardless, I'll think a little harder next time I use realCeiling...
21:41:57 <roconnor> > 2^100 <= fromIntegral (ceiling 2^100)
21:41:58 <lambdabot>   True
21:42:13 <roconnor> > 2.0^100 <= fromIntegral (ceiling 2.0^100)
21:42:13 <copumpkin> bos: it seems to work for me in ghci and with -O2, but I may be missing something
21:42:14 <lambdabot>   True
21:43:34 <bos> copumpkin: hmmmmmmmm.
21:43:46 <copumpkin> that's a long hmm :)
21:44:31 <copumpkin> I think I actually repeat it one time too many in that code
21:44:37 <copumpkin> :P
21:44:54 <ivanm> bos: only change for 0.1.4 is dep update?
21:44:59 <bos> copumpkin: i think that's an interesting approach.
21:45:01 <bos> ivanm: yep
21:49:24 <scutigera> roconnor: fromIntegral (round (ymin/dy)) * dy
21:49:35 <blackdog> argh, this is so filthy. it looks like the only approved way to read all the elements in a hash in ruby from C is to submit a callback function to change state.... i suppose i could use an IORef on the haskell side, but it's still a bit horrible.
21:49:42 <scutigera> want the value to be an exact multiple of dy
21:50:39 <ivanm> blackdog: so hubris is actually a 3-way bridge? :p
21:50:48 <ivanm> Haskell |-> Ruby |-> C ?
21:51:10 <blackdog>  is sort of the lingua franca
21:51:14 <blackdog> C is, rather
21:51:20 <ivanm> heh
21:51:33 <ivanm> oh, you use the FFI to talk to Ruby via C?
21:51:40 <blackdog> more or less
21:51:42 <ivanm> so Haskell <--> C <--> Ruby ?
21:51:48 <blackdog> yep.
21:51:50 <ivanm> that's.... interesting... :s
21:51:57 <blackdog> how else would you do it?
21:51:59 <ivanm> blackdog: why are you bothering with this anyway?
21:52:01 <copumpkin> ruby has a relatively simple c ffi
21:52:04 <ivanm> blackdog: never touched ruby ;-)
21:52:14 <blackdog> ivanm: because i'm unreasonably stubborn
21:52:24 <ivanm> heh
21:52:39 <blackdog> and because i get double value from the project - i can give talks at two different user groups :)
21:52:56 <p_l> copumpkin: like every language that is implented in C (well, it also depends on how well the API is written... but no worrying about stack etc..)
21:52:58 <ivanm> blackdog: heh
21:53:10 <copumpkin> yeah, but it's particularly easy to get started iwth
21:53:11 <ivanm> wow, gcc definitely gets used for uvector...
21:53:18 <copumpkin> unlike say, firefox's JS implementation
21:53:22 <copumpkin> ivanm: yep
21:53:30 <copumpkin> ivanm: although it really doesn't have that much c code
21:53:36 <ivanm> copumpkin: pre-processing?
21:53:39 <copumpkin> it could probably be made pure haskell
21:53:49 <copumpkin> a couple of offset memcpy helpers
21:53:53 <blackdog> I tell the Ruby guys that Haskell will help them speed up their Ruby code and keep their apps going, and I tell Haskell guys that it'll Trojan Horse those poor unsuspecting rubyists...
21:53:54 <ivanm> ahhh
21:54:02 <ivanm> blackdog: lol
21:54:14 <ivanm> @remember blackdog  I tell the Ruby guys that Haskell will help them speed up their Ruby code and keep their apps going, and I tell Haskell guys that it'll Trojan Horse those poor unsuspecting rubyists...
21:54:14 <lambdabot> Okay.
21:54:26 <ivanm> @forget blackdog  I tell the Ruby guys that Haskell will help them speed up their Ruby code and keep their apps going, and I tell Haskell guys that it'll Trojan Horse those poor unsuspecting rubyists...
21:54:27 <lambdabot> Done.
21:54:33 <ivanm> @remember blackdog  [About Hubris] I tell the Ruby guys that Haskell will help them speed up their Ruby code and keep their apps going, and I tell Haskell guys that it'll Trojan Horse those poor unsuspecting rubyists...
21:54:34 <lambdabot> Good to know.
21:54:36 <ivanm> that's better
21:54:59 <blackdog> with any luck the rubyists don't check this channel:)
21:55:12 <ivanm> >_>
21:55:14 <ivanm> <_<
21:56:41 <blackdog> the C headers for ruby are a bit frustrating, though. always reads VALUE do_something(VALUE, VALUE, VALUE)
21:56:45 <copumpkin> blackdog: zomg, I'm a rubyist
21:56:56 <blackdog> copumpkin: keep it under yourhat
21:57:11 <copumpkin> I actually haven't really touched ruby in several months
21:57:18 <copumpkin> strange coincidence, that
21:57:21 <blackdog> anyway, you've been here forever, you can't be my fault :)
21:57:34 <ivanm> copumpkin: how is that a coincidence?
21:57:55 <copumpkin> well, strangely enough I stopped using my favorite language, ruby, at roughly the same time I found out about haskell
21:58:08 <ivanm> copumpkin: you've only been here for a few months?
21:58:15 <ivanm> wow...
21:58:19 <copumpkin> well, coming up to a year now :)
21:58:23 <copumpkin> but it doesn't feel like that long
21:58:25 <ivanm> you've definitely over-extended your annoyance quota then!
21:58:29 <copumpkin> yeah!
21:58:31 <ivanm> ahhh, that makes more sense then
21:58:32 <copumpkin> I mean :(
21:58:41 <blackdog> copumpkin: ... seriously? wow, i thought you were one of the old-timers.
21:58:44 <copumpkin> about 11 months now
21:58:52 <copumpkin> blackdog: nah, just make a lot of noise
21:59:07 <blackdog> I got into haskell in ... 2002? I sort of feel i should be better at it by now...
21:59:36 <ned> how does one quantify how 'good' you are haskell anyways?
21:59:37 <nornagon> heh
21:59:45 <nornagon> i learned haskell and stopped using ruby, too
21:59:52 <copumpkin> ned: how many categorical recursion schemes you can name off the top of your head
21:59:54 <nornagon> but now I mostly code in C and python :P
21:59:58 <ivanm> ned: I believe the units are still milli-olegs
22:00:06 <ivanm> nornagon: :o
22:00:08 <ivanm> traitor!
22:00:15 <blackdog> although the micro-oleg is a more practical unit
22:01:04 <nornagon> oh, and javascript :D
22:01:27 <scutigera> nornagon: I'd like to give up Python for Haskell.  Used Python for real work and found it lacking.
22:02:00 <nornagon> i don't much like python, to be honest
22:02:12 <nornagon> it feels quite verbose when compared with ruby
22:02:43 <blackdog> nornagon: remember the python way: it is better to be explicit than it is to finish work early and go to the pub.
22:02:50 <bos> now now.
22:03:06 <ivanm> blackdog: heh
22:03:19 <blackdog> bos: gentle ribbing, sah. nothing malicious.
22:03:20 <ivanm> bos: no problems this time ;-)
22:03:30 <ivanm> blackdog: s/sah/sirrah/ :p
22:03:46 <scutigera> the dynamic typing stuff gets old.  funny, but it didn't bug me in scheme, but it seems to be a constant annoyance in python
22:03:57 <blackdog> i was more going for world war 2 private than Elizabethan fop
22:04:13 <ivanm> wait, I didn't realise it was to an inferior...
22:04:15 <nornagon> the thing that bugs me in python is that inheritance and the whole class model seems a bit useless
22:04:23 <nornagon> due to duck typing
22:04:55 <blackdog> yeah. if you're going to go for OO, the lightweight message-based approach seems more sensible
22:05:30 <kmc> what i find amusing is that C++ is also duck typed, at the template level
22:05:37 <Gracenotes> classes with duck typing are nice -- it organizes dynamic dispatch.
22:05:38 <copumpkin> quack
22:05:45 <scutigera> my favorite is the way if branches with UNDEFINED variables don't show up as an error until you actually take the branch.  so if it's a seldom seen error condition....
22:05:57 <Gracenotes> at least, nice in a dynamic types sense
22:06:53 <Gracenotes> (of course, classes with static types organize dynamic dispatch anyway...)
22:07:26 <Gracenotes> but in many languages it is the only means, as opposed to *a* means
22:08:02 <kmc> i don't see how duck typing "organizes" dispatch
22:08:06 <kmc> actual base classes organize it
22:08:21 <kmc> duck typing is an ad-hoc way of doing the same thing
22:08:25 <copumpkin> quack
22:08:29 <p_l> lol
22:08:51 <Gracenotes> yeah, that is what I meant by saying that static types can handle the same thing. But it is organized nonetheless
22:08:53 <scutigera> they're just dictionaries
22:09:14 <kmc> the only organized part of duck typing is the documentation
22:09:53 <kmc> (well, okay, i can imagine a formal, static subtyping or implementation relation which is somehow structural instead of nominal.  but it's not too common for objects)
22:10:58 <kmc> C++1x dropped concepts so templates will stay totally quack-typed
22:11:33 <Gracenotes> btw, I mean "organized" more in the contractual sense. polymorphism over subclasses (which ends up being, modulo direct type-checking, reasonably ducky)
22:12:26 <kmc> this is great fun because when someone screws up their quackery you get an error message at instantiation time, which usually takes up 2 pages and is 50% pointy brackets by weight
22:13:28 <Gracenotes> they really shouldn't make pointy brackets out of lead
22:14:17 <kmc> it's depleted uranium actually
22:15:14 * p_l is mortally scared of C++ templates
22:15:28 <Heffalump> they build character
22:16:18 <p_l> Heffalump: yeah right. Especially when they screw something like this if(!pointer-to-some-normal-class) :>
22:19:05 <kmc> C++ programmers have this cognitive dissonance where they realize that compile-time metaprogramming is powerful but they don't see that templates are an awful implementation of same
22:19:30 <kmc> and so it's all "templates are useful because x,y,z" instead of "templates are useful despite x,y,z"
22:20:42 <blackdog> can you expose an IORef to an external C function?
22:22:43 <copumpkin> bos: did that approach turn out to be suitable, or was there something I missed?
22:26:16 <javaprogrammer> hello
22:26:39 <javaprogrammer> i need help with a program im writing.
22:27:11 <copumpkin> javaprogrammer: it better not be in java
22:27:18 <copumpkin> *it had
22:27:27 <javaprogrammer> im trying to take every other nextInt() from my scanner.
22:27:29 <javaprogrammer> lol it is.
22:27:42 <Rotaerk> javaprogrammer, tip #1:  ask your question first rather than waiting for people to acknowledge you
22:27:44 <copumpkin> "A man walks into a barber shop and asks for a coffee"
22:27:51 <Rotaerk> tip #2:  ask that question in the appropriate channel
22:27:55 <copumpkin> javaprogrammer: you see a problem with that statement? :)
22:28:04 <javaprogrammer> where would i find the approriate channel?
22:28:14 <Rotaerk> javaprogrammer, how about #java
22:28:22 <Heffalump> well, let's see. #haskell is about Haskell. What do you think might be about Java? :-)
22:28:32 <Heffalump> it might be ##java, freenode has weird conventions
22:28:54 <Rotaerk> you have to be identified to join that channel apparently; if you don't want to do that you could try a different IRC network
22:29:28 <javaprogrammer> how do i get identified?
22:29:29 <dibblego> freenode ##java is quite a cesspit
22:29:36 <copumpkin> lol
22:29:41 <dibblego> javaprogrammer, /msg nickserv help identify
22:29:59 <bos> copumpkin: i think it'll work
22:30:00 <dibblego> javaprogrammer, /msg nickserv help register
22:30:03 <Rotaerk> don't think i've ever bothered to register with an irc network
22:30:14 <bos> copumpkin: just trying to think about how to munge the typeclass
22:30:17 <Rotaerk> that's actually the first channel I've run across that required it
22:30:27 <copumpkin> bos: oh, you don't like the NFData constraint?
22:30:35 <javaprogrammer> REGISTER skater4 boreddude564@aim.com
22:30:38 <javaprogrammer> gay.
22:30:43 <Rotaerk> lol
22:30:45 <bos> copumpkin: it's not that, i want to admit IO actions too.
22:30:47 <copumpkin> bos: you could be really evil and use vacuum to force the whole thing
22:30:48 <copumpkin> oh
22:30:56 <copumpkin> hmm
22:31:40 <javaprogrammer> Syntax: REGISTER skater4 boreddude564@aim.com
22:31:42 <copumpkin> bos: one (possibly overkill) idea might be to have it take an arbitrary arrow (which might be Kleisli IO) instead of a function
22:31:46 <copumpkin> ahem
22:32:14 <bos> copumpkin: then nobody will be able to understand it, including its putative maintainer :-)
22:32:14 <copumpkin> would probably be ArrowApply actually
22:32:17 <copumpkin> lol
22:32:48 <Rotaerk> javaprogrammer, figure out that you're supposed to send that to nickserv, yet?
22:33:04 <flippo> Great password though.   Keep using it.
22:33:06 <bos> type families might be useful for this.
22:33:16 <copumpkin> hmm, yeah
22:34:04 <Rotaerk> kind of odd that password comes first
22:40:19 <javaprogrammer> how do i connect to another server?
22:41:16 <kmc> ?
22:41:17 <bos> @hoogle printf
22:41:18 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
22:41:18 <lambdabot> module Text.Printf
22:41:18 <lambdabot> Text.Printf class PrintfArg a
22:41:25 <kmc> @faq can haskell connect to another server?
22:41:25 <lambdabot> The answer is: Yes! Haskell can do that.
22:41:38 <javaprogrammer> BUT HOW!>!?!?!?
22:42:13 <copumpkin> if you have a typeclass with an undecidable instance for a (that is, all types), can you use its methods without the constraint?
22:43:18 <Gracenotes> that is..
22:44:01 <dancor> for "a"
22:44:15 <dancor> \fancy-font-a
22:44:51 <javaprogrammer> @faw
22:44:52 <lambdabot> The answer is: Yes! Haskell can do that.
22:44:54 <javaprogrammer> @faq
22:44:55 <lambdabot> The answer is: Yes! Haskell can do that.
22:45:03 <javaprogrammer> ...
22:45:05 <johnw> he is very pro-Haskell
22:45:15 <dancor> trite: haskell can do that
22:46:07 <kmc> @nixon
22:46:07 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
22:46:49 <dancor> did he say that to spiro agnew
22:47:23 <kmc> hehe
22:47:43 <kmc> hey, agnew is now a character in a popular teevee cartoon show
22:47:50 <kmc> or most of him anyway
22:47:59 <bos> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11887#a11887
22:48:01 <dancor> well i'm oblivious
22:48:31 <copumpkin> bos: ooh very nice :)
22:48:40 <kmc> he probably said it while moping about losing to kennedy
22:48:50 <copumpkin> bos: don't think the NFData is necessary as a superclass on the b there?
22:49:16 <bos> copumpkin: f could always be rnf . realF
22:49:32 <Gracenotes> if HNF is enough...
22:49:37 <copumpkin> oh, fair enough
22:49:40 <bos> copumpkin: so you'd get to choose whether to evaluate to WHNF or NF yourself.
22:49:44 <copumpkin> nice, yeah
22:49:54 <copumpkin> much nicer this way :)
22:50:26 <bos> i think the problem with the earlier typeclass was that i tried to separate "evaluate this once" from "evaluate this many times".
22:50:48 <bos> thereby presenting an opportunity for thunking to occur.
22:50:52 <Gracenotes> bos: the first instance does the exact same calculation n times?
22:51:03 <bos> Gracenotes: yes
22:51:26 <Gracenotes> ah. just gotta watch out for recursion overhead then
22:51:57 <bos> it's just a loop.
22:52:03 <Gracenotes> for chaining, there could be (a -> a, a). which would overlap quite badly.
22:53:03 <bos> the instance as it stands requires FlexibleInstances.
22:53:33 <Gracenotes> is that because of the b?
22:54:30 <bos> i think it's because a appears twice.
22:54:57 <Gracenotes> mm.
23:25:02 <copumpkin> > mapM ((map ((chr .) . (. ord) . ($0) . flip) [setBit, clearBit] <*>) . pure) "blahblah"
23:25:03 <lambdabot>   ["cmaicmai","cmaicmah","cmaicm`i","cmaicm`h","cmaiclai","cmaiclah","cmaicl`...
23:36:16 <bos> copumpkin: i am tempted to sin.
23:36:25 <copumpkin> confess to me, my child
23:36:30 <Elly> I am already sinning!
23:36:32 * copumpkin barfs
23:36:33 <Elly> it's pretty great
23:36:45 <bos> so i think of Text.Printf as a kind of sin bin.
23:36:58 <bos> it's where lennart's type hacks go to be naughty in private.
23:37:42 <bos> but i could use the same scheme for the benchmarking code, so that it would be possible to describe benchmarks using that PrintfType typeclass hack.
23:37:57 <bos> but on second thought, that's too grody for words, and insufficiently general to work.
23:38:13 <bos> never mind. if sin won't buy me even a fleeting pleasure, why bother?
23:38:54 <bos> copumpkin: but! i have criterion using your suggested code now, and it's nicer.
23:39:11 <copumpkin> yay! glad I could help :)
23:39:39 <copumpkin> bos: I quite like that PrintfType thing actually
23:39:59 <copumpkin> I gravitated towards it when I tried this, but couldn't get everything working the way I wanted
23:40:30 <copumpkin> but I was young and inexperienced at the time :P
23:40:44 <bos> @hoogle MonadIO
23:40:45 <lambdabot> Control.Monad.Trans class Monad m => MonadIO m
23:41:55 <bos> @hoogle liftIO
23:41:56 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
23:42:40 <ivanm> bos: I don't know how feasible it is, but it'd be cool if there could be a simple "compareFunctions" function in criterion which says which method appears to be faster, maybe even getting a lambdabot plugin for it
23:45:32 <copumpkin> that'd be neat
23:45:51 <copumpkin> an Ord instance for functions!! :P
23:46:02 <copumpkin> then we can finally stick them into Sets and Maps ;)
23:46:58 <kmc> * copumpkin barfs  <=== http://bit.ly/3UZ46R ?
23:47:06 <copumpkin> lol
23:47:14 <copumpkin> that's it
23:47:36 <copumpkin> anyway, bedtime
23:47:58 <kmc> 'night
23:48:14 <copumpkin> g'night!
23:48:43 <bos> copumpkin: night
23:51:28 <bos> @type forM_
23:51:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
23:51:38 <bos> @type mapM_
23:51:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
23:53:42 <kmc> @free forM
23:53:46 <lambdabot> Expected variable or '.'
