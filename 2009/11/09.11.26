00:00:31 <jkff> (Whoops, need to go, let's continue a few hours later)
00:00:37 <jkff> (Thanks though!)
00:01:29 <kmc> i tried to write some examples for compare/contrast in C++ but i got enraged and quit
00:05:07 <Saizan_> what i was going to say is that ad-hoc polymorphism corresponds to intersection types, since that one overloaded method would have simultanously all the types for which it is defined
00:05:46 <ski> kmc : i don't agree with "a type is polymorphic iff it contains quantifiers"
00:06:55 <ski> imo, `exists x. Ord x *> x * (a -> x -> x) * (a -> x -> Bool)' is not polymorphic
00:08:05 <kmc> that's a value of type x bundled with some operations?
00:08:10 <ski> further, imho, "`forall a. [a] -> Integer' is polymorphic" is really sloppy phrasing of "`forall a. [a] -> Integer' is a type of polymorphic operations (of some sort)"
00:08:17 <ski> kmc : yes
00:08:35 <Saizan_> "an universal quantifier in strictly positive position"?
00:08:46 <Saizan_> an unknown type x
00:08:47 <ski> imo, a polymorphic type would be something like `Flip :: forall_kind k0 k1. (k1 -> k0 -> *) -> k0 -> k1 -> *'
00:09:47 <ski> summarizing, a value (alternatively type) is polymorphic if its type (alternatively kind) has an outermost `forall' (alternatively `forall_kind')
00:09:53 <kmc> does the Report use terms like "polymorphic type"?
00:10:36 <ski> (for contrast, neither `Maybe' nor `Maybe Bool' are polymorphic types. but `Maybe' is a parametric type)
00:14:52 <kmc> "The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system."
00:15:14 <kmc> i find that statement annoying and controversial ;)
00:15:52 <blackdog> kmc: you like the monomorphism restriction, or you think other things are more annoying? :)
00:17:19 <toast-opt_> i appologize if this was already covered, but why not infer type classes based on which functions are implemented?
00:19:17 <blackdog> toast-opt_: you'd end up with punning problems - something would end up a member of a typeclass which it really shouldn't
00:19:22 <ziman> do you mean type classes or type instances?
00:19:22 <kmc> blackdog, let's go with (b)
00:19:26 <blackdog> although i suppose Rubyists live it with every day
00:19:38 <blackdog> kmc: what's your biggest bitch with haskell?
00:19:46 <blackdog> i'd have trouble going past the record system myself
00:20:00 <kmc> yeah, records suck
00:20:10 <blackdog> hm, or maybe how hard it is to move time of computation around
00:20:18 <kmc> i mean i can list things i think of as warts of the design, but they don't cause me real problems very often
00:20:34 <toast-opt_> kmc, i think i see what you mean
00:21:46 <kmc> toast-opt_, does "shift :: a -> Int -> a" shift a bit register by a number of bits, or an engine by a number of gears?
00:22:04 <toast-opt_> fair
00:22:13 <kmc> presumably you can tell from the name of the typeclass constraint on a -- but the other concept will get mashed in, too
00:22:23 <kmc> that's the big reason imo
00:22:34 <kmc> i have to wonder if this will be a problem with Go as it's adopted
00:22:39 <kmc> because they have implicit membership like this
00:22:58 <kmc> people forget, an interface is not just a set of values with specific types.  it's also a contract about how those values relate
00:23:22 <kmc> (replace "value" with "function" and "relate" with "behave" in a dys-functional language)
00:24:42 <kmc> classes like Monad have "laws" that aren't checkable by the compiler
00:26:38 <kmc> you can break the laws either way, but in Haskell's system you have to write an explicit lie ("instance Monad MyThingThatsNotAMonad") and someone will run "git blame" on that line and find you and yell at you ;)
00:27:33 <Saizan_> and at least you have to do it consciously
00:28:36 <kmc> blackdog, i meant mostly that MR is invisible to beginners and people who haven't started learning Haskell -- the people who possess the preponderance of annoyance and controversy over Haskell's type system
00:29:31 <kmc> (and i don't mean to dismiss their annoyance -- but MR has not got much to do with it, either way)
00:30:16 <Saizan_> you haven't been on #haskell long enough :P i remember lots of newbies confused because they let-ed something in ghci that doesn't behave as the body
00:30:29 <ski> > let primes = 2 : tail ([2..] `diff` composites); composites = mergeStream [[p*n | p <- primes] | n <- [2..]]; mergeStream = foldr (\xs ys -> blueInput blueKeepHead (`merge` ys) xs) [] in primes
00:30:31 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:30:47 <kmc> blue?
00:30:55 <Milo-> red
00:30:57 <ski> "blueprint"
00:31:03 <kmc> :t blueInput
00:31:05 <lambdabot> forall a. (a -> a -> a) -> (a -> a) -> a -> a
00:31:10 <kmc> @src blueInput
00:31:11 <lambdabot> Source not found.
00:31:15 <kmc> @hoogle blueInput
00:31:16 <lambdabot> No results found
00:31:17 <ski> <ski> @let blueInput :: (a -> a -> a) -> (a -> a) -> (a -> a) ; blueInput blue f a = a `blue` f a
00:31:23 <ski> <ski> @let blueKeepHead :: [a] -> [a] -> [a]; blueKeepHead (x:_) ~(_x:xs) = x:xs
00:32:02 <kmc> i'm afraid i just blue myself
00:32:08 <ski> it's similar to `(0 :) . tail' previously
00:33:25 <ski> blueInput blueKeepHead (`merge` ys) xs)  is equivalent to  xs `merge` ys  except that the former is more defined in that `xs' is assumed to have a head, and this is claimed to be the head of the whole expression as well
00:34:16 <ski> so `primes' are numbers greater than `1' which are not composites, and composites are products of primes and numbers greater than `1'
00:34:51 <ski> (also, `2' is claimed to be the first prime, by `(2 :) . tail')
01:00:42 <EnglishGent^afk> boo :|
01:01:00 * EnglishGent^afk converts some Haskell code to Elisp - and find it blows the stack :|
01:01:25 <EnglishGent> dont suppose anyone has any ideas re: driving Emacs from Haskell?
01:01:40 <toast-opt> ski, i haven't seen that semicolon yet.  is that part of the IO monad, monads in general, or ghci?
01:02:24 <ski> toast-opt : sorry, which semicolon ?
01:02:40 <toast-opt> let blue.. = something ; somethingelse = ...
01:03:01 <ski> that's just putting several items on a single line, instead of using layout
01:03:04 <ski> just a syntax thing
01:03:13 <toast-opt> oh, so ; is same as whitespace?
01:03:36 <ski> well, not quite .. it's the same as the *proper* amount of whitespace
01:03:41 <toast-opt> thx, i'll be on the look out for that then
01:03:55 <ski>   let {foo x = ..x..; bar x y = ..x..y..} in ..foo..bar..
01:03:58 <ski> is the same as
01:04:01 <toast-opt> reading RWH and LYAH, but haven't reached that level of detail in either
01:04:03 <ski>   let foo x = ..x..; bar x y = ..x..y.. in ..foo..bar..
01:04:07 <ski> which is the same as
01:04:11 <ski>   let foo x = ..x..
01:04:18 <ski>       bar x y = ..x..y..
01:04:25 <ski>   in  ..foo..bar..
01:04:33 <toast-opt> ok, so semicolon and curly braces work sorta C-syntax-like, and whitespace very python-esqe
01:04:45 <ben> ; separates things instead of terminating them, though
01:04:59 <toast-opt> ben, of course, yes.  thx for clarifying
01:05:00 <ski> the keyword `let' (as well as `of', `where' and maybe some more i'm forgetting) starts a layout-block
01:05:09 <toast-opt> pascal syntax-like then :)
01:05:12 <ben> do, presumably
01:05:23 <ben> 'do' starts the worst layout blocks
01:05:28 <ski> the layout block is optional, so you can use `{',`;',`}' instead if you like (even mixing the two styles)
01:05:42 <ski> ben : ty, `do' yes
01:05:47 <toast-opt> ski, very helpful to know, when tinkering in the REPL
01:06:05 <ski> that's one common use of it, yes
01:06:22 <toast-opt> had a pair of mutually recursive functions wanted to tinker with other day.  ended up using a combinator to assemble them
01:06:35 <toast-opt> (;) would have been useful
01:07:08 <ski> heh, `;' is not an operator
01:07:11 <ski> @type (;)
01:07:13 <lambdabot> parse error on input `;'
01:07:44 <toast-opt> let mutualRecurY a b = let a' = a b' ; b' = b a'
01:08:08 <toast-opt> ski, i think of (;) in C++ as an operator though, so habit
01:08:23 <ski> (probably there should be an `in ..a'..b'..a..b..' at the end of that)
01:08:26 <toast-opt> it's the sequencing operator ;)
01:08:34 <ski> @type (>>)
01:08:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
01:08:45 <toast-opt> ski, yes thx
01:08:46 <ski> that could be said to be a sequencing operator
01:09:32 <ski> > let x = z*z; y = 42 ; z = y + 100 in (x,y,z)
01:09:34 <lambdabot>   (20164,42,142)
01:09:56 <ski> the `;' doesn't sequence .. it doesn't matter which order the three defining equations are put int
01:10:03 <ski> (s/int/in/ :)
01:10:30 <ski> (though it can matter for defining equations for the same defined operation)
01:15:39 <ski> > let ; in ()
01:15:41 <lambdabot>   ()
01:15:54 <ski> > let ; _ = () in ()
01:15:55 <ski> > let _ = () ; in ()
01:15:56 <lambdabot>   ()
01:15:57 <lambdabot>   ()
01:16:44 <ski> ben : it appears it can optionally start and end the declarations, as well
01:17:21 <ben> Maybe it just ends up being interpreted like an empty line :/
01:18:00 <ski> (i don't think so .. the implementation used translates in the other direction, iirc)
01:18:23 <ben> hence 'like' and not 'as', I guess
01:18:41 * ski smiles
01:18:46 <ben> > let in 42
01:18:48 <lambdabot>   42
01:19:02 <toast-opt> makes sense
01:19:13 <ski> > [ () | ]  -- unfortunatley doesn't work, though
01:19:15 <lambdabot>   <no location info>: parse error on input `]'
01:19:26 <toast-opt> it is just as easy to parse zero definitions as it is 1+
01:19:49 <ben> > [ () | ; ]
01:19:52 <lambdabot>   <no location info>: parse error on input `;'
01:19:57 <ben> Yeah, not sure what I expected there
01:20:10 <toast-opt> yeah, but i've noted that whitespace in list comprehensions doesn't work quite the same
01:20:15 <toast-opt> of course, that could be user error
01:20:26 <ski> it ought to (imho) be the same as
01:20:32 <ski> > [() | True]
01:20:34 <lambdabot>   [()]
01:21:03 <ski> (since the `,' between the generators and guards in a list comprehension logically behaves as a conjunction)
01:21:06 <toast-opt> wait, why does that enumerate anything?
01:21:12 <toast-opt> > [() | False]
01:21:14 <lambdabot>   []
01:21:24 <toast-opt> interesting.  oh, because it's a boolean clause?
01:21:29 <ski> indeed
01:21:44 <toast-opt> maybe it's a foldl1, not a foldl?
01:21:58 <ski> it's not a fold at all
01:22:17 <toast-opt> i mean, that it folds over the clauses
01:22:30 <ski> it's a combination of `filter' and `map' and/or `concatMap', if you like
01:22:52 <toast-opt> filters, you mean
01:23:09 <toast-opt> can there be more than one boolean clause?
01:24:05 <ski> sure
01:24:08 <ski> any number
01:25:09 <ski> > [(i,j,k) | True , i <- [0..9] , even i , j <- [0..i] , odd j , k <- [j..i]]
01:25:11 <lambdabot>   [(2,1,1),(2,1,2),(4,1,1),(4,1,2),(4,1,3),(4,1,4),(4,3,3),(4,3,4),(6,1,1),(6...
01:27:28 <toast-opt> i thought they run from right to left
01:28:08 <toast-opt> > [ (x,y) | x <- [0..2], y <- [3..5]]
01:28:09 <lambdabot>   [(0,3),(0,4),(0,5),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
01:28:26 <ski> > map (\(i,j,k) -> (i,j,k)) (concatMap (\(i,j) -> map ((,,) i j) [j..i]) (filter (\(i,j) -> odd j) (concatMap (\i -> map ((,) i) [0..i]) (filter (\i -> even i) (concatMap (\() -> [0..9]) (filter (\() -> True) [()]))))))
01:28:28 <lambdabot>   [(2,1,1),(2,1,2),(4,1,1),(4,1,2),(4,1,3),(4,1,4),(4,3,3),(4,3,4),(6,1,1),(6...
01:28:33 <toast-opt> sry, very late, brain getting things backward
01:28:56 * toast-opt left to right reads outer to inner
01:29:13 <ski> the right-most generator "spins fastest"
01:29:21 <ski> right
01:30:26 <Gracenotes> so many right parens
01:31:12 <Gracenotes> at least, for languages that use indentation more heavily (and are generally less terse), you can see nested levels closing by how far the indentation drops
01:31:37 <toast-opt> reminds me of scheme days :)
01:31:41 <ski> (more heavily than ?)
01:32:05 <ski> Scheme is nice :)
01:32:38 <toast-opt> yes, but few C++ devs make it past the big stack of right parens
01:33:19 <fasta> }}}}}} or ))))))), it doesn't really matter.
01:33:21 <toast-opt> i'm thinking i might have a go at moving folks from C# to F# though.  OCaml is a step in the right direction
01:33:37 * ski nods
01:33:47 <toast-opt> fasta - you mean, } ; ) ] and +  vs ))))))
01:33:54 <Gracenotes> but, }\n (indentation) }\n (less indentation) }\n (even less) }\n (no indentation) }
01:33:57 <Maddas> Does Aaron Keller happen to frequent this channel?
01:34:31 <ski> Gracenotes : the brackets get lonely !
01:34:46 <fasta> toast-opt, well, I gave an example of something which is possible, but yes, you can use all of those.
01:34:54 <Maddas> Sorry, I just dropped in, but is this about scheme and indentation?
01:34:55 <toast-opt> it's never been about the blocks, it's always been about the rest of paren use.  infix vs parens call, [] indexing vs parens indexing, curly brace blocks vs paren blocks
01:35:09 <Maddas> Scheme is read mostly by looking at indentation, not by counting parens...
01:36:28 <toast-opt> i like the uniformity, but it hurts other C++ devs eyes to see such undifferenciated punctuation.  ML family languages don't have that problem despite being scheme + static type inference in language philosophy
01:37:25 <Zao> toast-opt: My primary annoyance at indentation depth is trying to discern how far out I should outdent.
01:37:27 <Maddas> Heh, I was under the impression that O'Caml's syntax was universally despised.
01:38:00 <Zao> I wonder how hard it would be to hack something like CodeKana into vim ( http://www.codekana.com/ )
01:38:15 <toast-opt> zao, yeah, but you have to at least try the language to get into that problem
01:39:28 <ski> Maddas : some people seem to dislike it, but i don't know why. it's not the prettiest always, but i don't think it is ugly
01:39:45 <Maddas> ski: Neither do I, but everyone I've heard talk about the syntax seemed to find it very ugly.
01:39:59 <Maddas> But then again, I don't understand why people find Perl syntax so bad :-)
01:40:28 <Maddas> toast-opt: If people completely refuse to even try a language based on such superficial items, I'd argue that the problem is the developers :-)
01:41:00 <toast-opt> maddas, k, but how do you suggest i fix that? :)
01:41:11 * Maddas flails his arms around helplessly :-)
01:41:19 <toast-opt> i'm just saying it's terribly convenient that haskell doesn't have lisp syntax :)
01:41:45 * Maddas always found that a bit of a pain :-P
01:41:47 <fasta> > ((+) 1 2) -- Haskell has even more parens ;)
01:41:49 <lambdabot>   3
01:42:01 <toast-opt> fasta, optional most of the time
01:42:23 <Maddas> toast-opt: I'm just pulling your leg now :-)
01:42:33 <fasta> toast-opt, it's called a joke.
01:42:41 <toast-opt> oh, duh
01:42:43 <toast-opt> sorry
01:42:53 <shambler> > (+) 1 2
01:42:54 <lambdabot>   3
01:42:59 <shambler> liar!
01:43:08 <Maddas> shambler: That's still the same number of parens, though!
01:43:27 <Jafet> > (((((+) (((1))) ((2))))))
01:43:29 <lambdabot>   3
01:43:35 <Maddas> Jafet proves the point.
01:44:47 <toast-opt> (map (lambda (x) x*2) (filter (lambda (x) (> x 0)) s))
01:45:00 <toast-opt> vs [ x*2 | x <- s, x > 0]
01:45:10 <toast-opt> the former has C++ developers run away screaming
01:45:13 <Jafet> (define \ lambda) ; this should work!
01:45:23 <Maddas> toast-opt: But it would have them run away screaming even if you used different syntax.
01:45:39 <Maddas> The difference between the examples is more than syntactical.
01:45:40 <toast-opt> the second... well, once they get past the [] list notion, they are happily relieved to see some _variety_ in the syntax
01:45:44 <Gracenotes> it should be possible to use a stack-as-linked-list to remove the extraneous parens from "(((((+) (((1))) ((2))))))"
01:45:54 <fasta> toast-opt, you can write  (lc x*2 | x <- s, x > 0) in Scheme, if you want.
01:46:12 <ski>   (loop ((for x (in-list s)) (if (> x 0))) => (* x 2))
01:46:16 <fasta> toast-opt, or even  [ x*2 | x <- s, x > 0] if you modify the reader.
01:46:18 <toast-opt> fasta, heh, yeah, show a C++ developer scheme macros on the first day
01:46:24 <ski> (iirc my foof-loop correctly)
01:46:34 <Maddas> toast-opt: Why would they need to see the implementation?
01:46:41 <Maddas> Do you show them a Haskell parser the first day? :-)
01:46:59 <fasta> toast-opt, if you are an expert C++ programmer, Scheme is _trivial_, imho.
01:47:05 <toast-opt> maddas, so lc is a standard function in some scheme?
01:47:13 <fasta> toast-opt, no.
01:47:24 <Jafet> Almost nothing is standard in scheme. It's a cottage industry language
01:47:32 <toast-opt> heh, true
01:47:33 <Maddas> toast-opt: No.
01:47:39 <ski> Jafet : (define-syntax-rule (\ . body) (lambda . body))
01:47:45 <fasta> toast-opt, but if you want to push Scheme into your company and you are the expert, you should do so.
01:47:53 <ksf> :t (***)
01:47:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:48:16 <Maddas> toast-opt: But just as a counter-point, try to explain C++ programmers the IO monad and you'll have them running faster than you would by explaining (print "foo")
01:48:16 <ksf> is there a generalisation of arrows to arbitrary sizes?
01:48:18 * Jafet smells PLT on ski
01:48:27 <toast-opt> maddas, heh, true
01:48:43 <ski> Jafet : i can give you the r5rs `syntax-rules' version too, if you prefer :)
01:48:46 <toast-opt> maddas, i'd need a better understanding of monads first.
01:48:48 <Maddas> toast-opt: If they simply can't stomach the syntax, we'll take your word for it, and there's no point in trying to argue that this is somehow the language's "fault" :-)
01:48:52 <ksf> I'm asking because messing with n-tuples can come in very handy for pl, if combined with currying.
01:48:55 <fasta> Plain Scheme has some applications, but Windows application development is not one of them. For that much better tools need to be implemented.
01:49:11 <ski> ksf : what does "size" mean in this context =
01:49:13 <fasta> I think the PLT tools, in particular DrScheme have not been used in a big project.
01:49:14 <ski> s/=/?/
01:49:35 <toast-opt> maddas, i certainly don't blame scheme.  i blame c++ :)
01:49:36 <ksf> not just first and second, but also third and nth.
01:50:01 <Jafet> ksf, I would start by figuring out how to do n-tuples in Haskell in the first place
01:50:01 <fasta> If you ask it to search where a certain identifiier comes from or something like that you have to wait a few seconds, IIRC. It's just slow beyond belief.
01:50:04 <Maddas> toast-opt: I think syntax is something that many people find easy to get accustomed to if they actually want to. The first language I seriously used was Perl, and I still don't understand everyone's dislike of it, but it didn't stop me from appreciating completely different approaches. :-)
01:50:37 <Jafet> ksf, and not C++-style "let's do 9-tuples and hope nobody has any use for bigger ones"
01:50:42 <toast-opt> maddas, heh, like so many others, i had a love affair with perl in college.  i thought the sigils were 'cool'.  man, i was naive then
01:50:55 * Maddas doesn't see why that is naive
01:51:00 <ksf> we've got heterogenous lists.
01:51:11 <Maddas> toast-opt: I may just be too argumentative though :-)
01:51:16 <toast-opt> heh
01:51:17 <Jafet> I don't get heterogeneous lists!
01:51:25 <toast-opt> yeah, i _am_ blaming perl
01:51:26 <fasta> ksf, by "we have got", you mean that we have a packakge that doesn't compile?
01:51:35 <fasta> package*
01:51:37 <ksf> I do get them, just not oleg's type magic used to implement them.
01:52:16 <toast-opt> no ambiguity there.  it's a great hack, to be sure, but not something i'd like to write more than 100 lines of
01:52:31 * Maddas had no problems doing that :-)
01:52:40 <Jafet> I consider STRef sufficiently advanced already
01:53:13 <Maddas> (And my first experience writing code in a company was in a small company writing Perl. The code was easy to read, well-written, and perfectly adequate.)
01:53:13 <ksf> the other possibility, of course, is TH, but metaprogramming always feels like a hack in haskell
01:53:15 <Twey> Jafet: But Haskell-style ‘let's do 36-tuples and hope nobody has any use for bigger ones’?  ;)
01:53:27 <ski> (`STRef's are "just" mutable cells)
01:54:22 <ksf> also, sufficient involved abuse of the type system always seems to come with a big inpact on compile times
01:54:31 <toast-opt> maddas, eh, i like to hate Perl, but it does get stuff done.
01:54:37 <toast-opt> was always looking forward to Perl 6
01:54:52 * Maddas was always simultaneously horrified and awed by what little he saw of Perl 6 :-)
01:54:55 <toast-opt> but then reality set in
01:55:04 <toast-opt> yeah, same here
01:55:17 <ksf> ...maybe oohaskell would have taken off if you could compile objects with more than say 6 fields without fetching coffee from the supermaret, roasting it, then cooking it.
01:55:36 <toast-opt> oohaskell?  is this a dialect?
01:55:55 <ksf> it's an oleg library, implementing all of oop and more in GHC haskell
01:56:00 <ksf> built upon HList
01:56:15 <bombshelter13b> Quicky: Is it easy/practical to write a library in haskell and then use it from a C++ program?
01:56:22 <Jafet> Perhaps he should of written a compiler for it too
01:56:23 <Maddas> toast-opt: What I'm trying to get at is that I find it a lot more interesting (and productive) to try to see why people like what they use as opposed to trying to put things in a negative light in order to make your personal favourite look better. The latter is easier, but especially online it usually also ends in pointless pissing contests (or people furiously agreeing without exchanging anything more than self-congratulatory statements). :-)
01:56:40 <toast-opt> maddas, point taken
01:56:49 <ksf> Jafet, good point.
01:57:06 <ski> (toast-opt : O'Haskell is a dialect, though)
01:57:11 <Jafet> In other news, gcc 4.5 will bite the bullet and support plugins
01:57:20 <ksf> or, well, haskell could strive more to be easy on type-level hackers
01:58:05 <toast-opt> maddas, so, given that, what's your solution?
01:58:09 <ksf> it seems to be quite clear by know that the type-level is quite popular.
01:58:17 <Maddas> toast-opt: does run around screaming count? :-(
01:58:22 <toast-opt> heh
01:58:23 <toast-opt> no
01:58:29 * Maddas is not very good at meeting his standards, unfortunately :-P
01:58:33 <Maddas> toast-opt: Do whatever works :-)
01:58:36 <Jafet> You can take your pants off while you're at it.
01:58:38 <quicksilver> I did not have the impression that oohaskell was to be understood as a library intended for writing applications with.
01:58:49 <ksf> things, like, primitive type-level numerals, and closed type funs, for a start.
01:58:59 <quicksilver> I thought oohaskell was an interesting proof-of-concept experiment in how you could express OO things in haskell.
01:59:08 <Maddas> toast-opt: If you can drag them half-way to Haskell by using ML, that sounds like a plan. :-)
01:59:16 <toast-opt> maddas, which is why i mentioned F#.  may not be ideal, but might be close enough to start the conversation
01:59:26 <bombshelter13b> ... no one knows about using haskell libraries from another language? C'mon, there're usually experts in here. ;)
01:59:30 <ksf> it's actually a library to design OOP-style EDSLs in Haskell.
01:59:36 <Jafet> haskell-mop!
01:59:56 <ksf> you can do virtually everything OOP with it, be it smalltalk, java, or things that don't have any language support whatsoever.
02:00:08 <toast-opt> ... of course, i'm still going to be tinkering in Haskell until i have a good hang of it
02:00:40 <Jafet> bombshelter13b, you use... the FFI
02:01:03 <bombshelter13b> Jafet: Huh, I'd understood the FFI to be the opposite? Calling a foreign function from Haskell?
02:01:15 <ksf> I for one like the approach to express OOP fully in terms of a HM type system, too many things in OOP are premature design descisions, so they shouldn't be cast into languages.
02:01:16 <bombshelter13b> Jafet: I'm interested in calling Haskell functions from some other language.
02:01:43 <ksf> you use the ffi for that, too.
02:01:48 <Jafet> There is at least one hashkell to C FFI I know of
02:02:02 <Jafet> Pshft, my schpelling
02:02:15 <bombshelter13b> Jafet: Are you aware of it's name?
02:02:17 <ksf> it's a matter of exporting an enough c-like api, and calling some magic rts function before you call any of them.
02:02:26 <Maddas> toast-opt: Absolutely.
02:02:31 <Jafet> It's probably called something like "hs2c", you know
02:03:04 <EnglishGent> oh that would be useful bombshelter13b
02:03:09 <toast-opt> esp type classes.  never worked with something quite like it
02:03:11 <EnglishGent> (calling Haskell from other languages)
02:03:54 <EnglishGent> as for using haskell-libraries in another language - I'm currently trying to port a chunk of the standard prelude to elisp
02:03:57 <EnglishGent> does that count? :P
02:03:58 <EnglishGent> :)
02:05:15 <Jafet> I'd just use edwin and import SRFIs.
02:05:32 <EnglishGent> and becoming corrupted enough I keep doing things which are good style in Haskell - and lousy in lisp :|
02:06:07 <EnglishGent> edwin?
02:06:12 <bombshelter13b> EnglishGent: better a situation than I'm in - most things that are good style in haskell are godawful terrible inefficient in Python!
02:06:18 <Jafet> emacs port to scheme
02:06:33 <EnglishGent> got a link Jafet? :)
02:06:34 <Jafet> That's because python is godawful terrible inefficient
02:06:43 <Jafet> Nothing much you can do about that
02:09:17 <ski> EnglishGent : it's bundled with MIT Scheme
02:10:03 <EnglishGent> thanks ski, all :)
02:10:15 <Dunearhp> has anyone who has used gtk2hs ever come across a runtime error like:
02:10:25 <Dunearhp> myProgram: ): openFile: does not exist (No such file or directory)
02:10:45 <Jafet> Does it literally say ):
02:11:06 <Dunearhp> yes
02:11:07 <Dunearhp> thying to open ")"
02:11:18 <Dunearhp> s/thying/trying/
02:11:34 <ben> ... well, is your program trying to open ")"? :]
02:11:58 <Jafet> Why is it trying to open )
02:12:34 <Dunearhp> no, it happens when I try to insert text into a textBuffer
02:12:47 <ski> closing ")" would make more sense
02:12:48 * ski ducks
02:12:53 <ben> Hah
02:13:08 <Dunearhp> hehe
02:13:56 <ehamberg> haskell coders are all angels: http://i.imgur.com/ng5aS.png :)
02:14:30 <Jafet> Evidently not all.
02:14:33 <oteren> haha
02:14:45 <oteren> that graph has to be off
02:14:50 <oteren> perl is at least 5% FFFFFFFFFFFFFFFFFFFUCK
02:14:52 <fasta> ehamberg, try FIXME
02:14:56 <EnglishGent> ah - well edwin is interesting - but it wont help with this problem (which involves an existing emacs mode I'm trying to patch)
02:14:58 <fasta> ehamberg, or XXX.
02:15:08 * EnglishGent makes the sign of the lambda
02:15:14 <ehamberg> fasta: not mine, but yeah, that would be interesting :)
02:15:20 <EnglishGent> oteren - please, dont mention that -- other language
02:15:21 <EnglishGent> :)
02:15:23 <Dunearhp> trust me c is as bad as perl
02:15:27 <Jafet> There is always the option of implementing scheme in elisp!
02:15:49 <Maddas> ehamberg: haha, nice graph.
02:15:58 <EnglishGent> yes - *properly* - with support for call-with-current-continuation
02:16:06 <Jafet> The scheme SRFIs cover most of Haskell prelude, for example SRFI 1 for list processing
02:16:10 <ski> and proper tail calls
02:17:12 <EnglishGent> http://sisc-scheme.org/ -- a useful scheme interpereter (full RSR5)
02:17:22 * EnglishGent has found it occassionally useful :)
02:17:49 <ivanm> ehamberg: I'm amazed Java's is so low...
02:17:58 <ivanm> maybe because so much of it is work-related? >_>
02:18:09 <ehamberg> hehe, could be :P
02:18:15 <Maddas> ivanm: Because it is so verbose? ;-)
02:18:23 <Dunearhp> the profanities are all in the docs
02:18:26 <shambler> http://sisc-scheme.org/sisc-online.php
02:18:28 <shambler> coool
02:19:15 <Twey> ‘The algorithmic language Scheme’?
02:19:20 <Twey> What is an algorithmic language?
02:19:33 <Jafet> One for writing algorithms in, of course
02:19:41 <ski> it's stolen from "The algorithmic language Algol", iirc
02:19:41 <Jafet> Maybe they don't get to do that in Java well.
02:19:53 <Twey> Haha.
02:20:03 <fasta> Twey, an academic more precise phrase than "programming language".
02:20:12 <EnglishGent> as I said - it's rather handy
02:20:21 * EnglishGent has used it before when writing Java applets
02:20:33 <EnglishGent> hey - the client specified Java - and *technically* it was Java
02:20:43 <fasta> I don't particularly like that they didn't go all the way with the formal semantics of Scheme.
02:20:49 <EnglishGent> just with a long configuration file (i.e. Scheme program!) :D
02:21:06 <fasta> A machine specification of what Scheme is would be quite handy.
02:22:02 <fasta> Probably all such exact specifications for real languages are proprietary.
02:22:23 <fasta> (of course Intel has one for its assembly language, and so on).
02:23:23 <quicksilver> EnglishGent: all sufficiently advanced programs include a buggly, poorly specified, and incompletely implemented, lisp interpreter?
02:23:45 <shambler> :))))
02:23:56 <shambler> this is old joke afair
02:24:10 <Jafet> quicksilver, he realized that and included a real lisp interpreter from the get go
02:24:14 * quicksilver nods
02:24:29 <Maddas> (AKA Greenspun's Tenth Rule)
02:26:21 <ski> (Dunearhp : did you mean <http://www.scsh.net/docu/html/man.html> ?)
02:26:26 <mlesniak> Is there an option that GHC's profiling lists functions defined with "where" separatly? Currently they are all listed under the parent function
02:26:43 <mlesniak> (.... which does not help at all ;-))
02:27:04 <shambler> Any sufficiently complicated concurrent program in another language contains an ad hoc informally-specified bug-ridden slow implementation of half of Erlang.
02:27:05 <shambler> hehe
02:27:20 <mlesniak> Nice one!
02:28:36 <oteren> span((== x) (x:list) gives:   Couldn't match expected type `a -> Bool'  against inferred type `Bool'
02:29:02 <ski> oteren : maybe you meant `span (== x) (x:list)' ?
02:29:04 <oteren> i suck at reading compiler errors from haskell
02:29:17 <oteren> ah ofc, paranthesis error
02:29:18 <oteren> hehe ty
02:41:01 <Twey> shambler: Unless it's Haskell, in which case it contains an ad-hoc informally-specified bug-ridden very-fast implementation of half of Erlang ;)
02:41:39 <ivanm> Twey: :o
02:41:56 * Twey notes that GHC still beats HiPE quite significantly on the thread-ring benchmark.
02:42:11 <shambler> :)
02:42:14 <shambler> true
02:42:23 <ivanm> @slap Twey and shambler
02:42:24 <lambdabot> I don't perform such side effects on command!
02:42:26 <Jafet> Is haskell code buggy in erlang because it cannot crash?
02:42:27 <ivanm> grrr.....
02:42:34 <Twey> Jafet: Hahaha
02:42:38 <Twey> ivanm: :-D
02:42:40 <Jafet> (Until you run out of stack)
02:42:44 <Twey> @botsnack
02:42:44 <lunabot>  :o
02:42:46 <lambdabot> :)
02:47:39 <mlesniak> If anyone has an idea how to improve the speed of finding the minimal element in an array I'd be thankful. See http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5104#a5104
02:47:52 <oteren> is haskell officially supported on the cell platform?
02:48:08 <Jafet> mlesniak, use a heap?
02:49:16 <mlesniak> Jafet: Could you elaborate a bit?
02:49:38 <Jafet> A heap, which is a data structure designed for extracting the smallest element
02:50:14 <mlesniak> Then I understood it, but (context) I'm writing a naive quicksort implementation with insort-replacement and have to find the smallest element in a given range of the array.
02:50:34 <mlesniak> Without this constraint a heap would be my first choice, too.
02:50:41 <Jafet> What is insort replacement
02:50:53 <mlesniak> But I'd like to stay as close as possible (educational value) at the original implementation
02:50:56 <mlesniak> Argh, inplace ;-)
02:51:10 <Jafet> Ew
02:51:31 <mlesniak> So, stuck to IOUArray ;-)
02:51:40 * ksf would like to have "cabal dependencies"
02:51:50 <ksf> ...to install all dependencies of a particular package.
02:52:03 <oteren> you cant find a minimal element any faster than O(n) as long as its stored in an (unsorted) array
02:52:21 <oteren> and you're already doing that
02:52:28 <ksf> ...well, actually it's only useful for .cabals in the cwd.
02:52:44 <mlesniak> oteren: clear and obvious, but I think maybe there is a faster way using some haskell magic...
02:52:46 <Jafet> Presumably he wants a faster O
02:53:03 <mlesniak> That it will always be O(n) is ok, but maybe some folding or other haskell-tricks would improve the speed
02:53:38 <oteren> to find a smallest item
02:53:42 <oteren> you need to compare it to the other elements
02:53:44 <mlesniak> I'm not sure that unpacking the array elements into a list and traversing using find it the optimal approach
02:53:45 <Jafet> Why do you need to find the smallest item, though
02:54:07 <mlesniak> Jafet: http://en.wikipedia.org/wiki/Quicksort ;-)
02:54:13 <ksf> mlesniak, linear lookup on a static list is as fast as going through an array
02:54:28 <Jafet> Quicksort usually searches for the median.
02:54:56 <Twey> Jafet: Presumably for sorting after the pivot
02:55:06 <ksf> go ahead and time it, while optimizing fasta I didn't notice any performance advantages of UArrays over lists/trees
02:55:08 <Twey> Smallest item, then next smallest item, then next smallest item
02:55:13 <mlesniak> ksf: Ok, I just remembered that someone here on #haskell transformed similar code using folds into a much faster version
02:55:15 <Jafet> That's a selection sort.
02:55:15 <oteren> you are moving the elements smaller than the pivot
02:55:20 <oteren> indeed
02:55:42 <Jafet> Which performs relatively horribly unless you are on a tape, or something
02:55:47 <mlesniak> Jafet: the german quicksort-wikipedia page has a bit more explanationary pseudo-code
02:55:52 * oteren bubbles through life
02:55:54 <Twey> Jafet: Oh, yeah.  :-\
02:55:58 <Twey> oteren: Heh
02:56:17 <oteren> you dont want the smallest element
02:56:21 <oteren> you want the element smaller than the pivot
02:56:32 <oteren> elements in plural even
02:56:36 <mlesniak> oteren: yes, which is specified by op = (<pivot)
02:56:38 <path[l]> *sigh* no matter what code I write in haskell I run into performance issues
02:57:08 <Jafet> mlesniak, so where does selecting the smallest element come in at all?
02:57:16 <oteren> indeed
02:57:28 <ksf> with lists you get a couple of pointer derefs and a test for nil, with arrays you get adress arithmetic and a test for the end of the array. on modern processors it doesn't matter if you do one deref or two: the second one is going to be a cache hit, and the code path is clear enough to be evaluated speculatively.
02:57:32 <Jafet> > putStrLn "Hello life in the fast world lane"
02:57:34 <lambdabot>   <IO ()>
02:58:01 <Jafet> ksf, he seems to be using unsafe IO
02:58:15 <mlesniak> Jafet: ok, to clarify, the first element smaller (or bigger) than the pivot
02:58:42 <oteren> yes
02:58:56 <Jafet> Oha
02:58:59 * Jafet reads the code now
02:59:42 <oteren> quicksort is rather inefficient to do in haskell
02:59:48 <oteren> and quicksort *in-place* in haskell
02:59:55 <oteren> thats just shouting for a code abortion
02:59:57 <mlesniak> oteren: Yes, thought so to,
02:59:58 <path[l]> whats the right way to memoize a 2 parameter function in haskell
03:00:16 <Jafet> Curry it!
03:00:22 <oteren> rice & curry
03:00:31 <quicksilver> path[l]: the most general way is a clever Trie; see MemoTrie on hackage
03:00:35 <Jafet> No slashfic in here, please
03:00:36 <path[l]> hmm but I was wondering what I should be storing the values in
03:00:39 <path[l]> oh ok
03:00:42 <quicksilver> path[l]: in most specific cases there is a simpler hack.
03:00:46 <ksf> path[l], have a look at gmap
03:00:49 <ksf> @hackage gmap
03:00:49 <lambdabot> http://hackage.haskell.org/package/gmap
03:01:25 <path[l]> well I have a function f i j where i and j will vary from 0 to about 20ish
03:02:05 <path[l]> also I cant use packages, and Ive been fighting for performance every step of the way. So Im thinking it makes sense to go specific rather than general
03:02:17 <path[l]> reading
03:02:30 <quicksilver> why can't you use packages?
03:02:44 <path[l]> its for an online coding thingy which only has ghc
03:02:54 <quicksilver> if it's only 400 elements (20x20) that's not very hard
03:02:59 <quicksilver> I'd just bung them all in a Map
03:03:44 <fasta> path[l], which problem are you working on now?
03:03:53 <path[l]> well actually its even less than that. It's about the diagonal times 5 (optimizations), so 20times 5 I guess?
03:04:03 <path[l]> fasta: http://www.codechef.com/problems/DDILEMMA/
03:04:18 <path[l]> the haskell lazyness made my code really small
03:04:20 <path[l]> but sadly
03:04:28 <fasta> path[l], so, your solution passed the other one?
03:04:28 <path[l]> instead of 30 seconds I take 18+ minutes
03:04:29 <path[l]> lol
03:05:06 <path[l]> no I gave up on that. Just input and output on that took 1.5 seconds on my machine out of a total of 3. So I decided Id skip that for now
03:05:23 <path[l]> this looks like its less of an IO thing and more computation
03:06:32 <path[l]> on this one when I have about 200 and 600 domains and new domains I take 4 seconds. When I have about 2000 and 6000 which is the actual I take several minutes
03:06:41 <path[l]> several being more than 20
03:07:14 <Jafet> That means your algorithms suck
03:07:22 <Jafet> So do better
03:07:42 <path[l]> I dont think so, its a standard problem and afaik Im doing what other people have done in C++ and Java
03:08:10 <Jafet> The way your program is scaling contradicts your statement
03:10:04 <path[l]> hmm true. Let me just look through the code of a solution that passed and check if its the same
03:10:14 <fasta> path[l], if you offer 300$ for a fast implementation of some simple program witten in Java/C++ and post it to the mailing list, I am sure you will get solutions in the same performance range.
03:10:31 <Jafet> It seems that the transformation will yield the same difference no matter which order the rules are applied
03:10:32 <fasta> path[l], Xah Lee did that once for Mathematica to prove a point. \
03:10:48 <path[l]> lol I see
03:10:56 <Jafet> If that is the case, then the edit distance is a metric, and you can use spatial trees or something
03:11:02 <path[l]> no but I dont blame haskell, Im just wondering what tricks Im missing
03:11:16 <quicksilver> or lazily constructed spatial tries
03:11:20 <quicksilver> (edit-distance-tries?)
03:11:23 <quicksilver> if you're smart about it.
03:11:37 <quicksilver> however I doubt that's necessary to get the right complexity which you current seem to be missing
03:12:12 <Jafet> Well, if I do these things, I prefer to do them right
03:13:25 <path[l]> well yeah at the moment Im calculating edit distances directly off the strings which are in UArrays. But Im calculating it lazily and I do only the diagonal of width 5
03:13:34 <path[l]> because I dont care about scores greater than that
03:21:04 <path[l]> so I just looked at a succesful C solution
03:21:19 <path[l]> and the person made it work without memoization and he calculates the entire matrix
03:21:33 <path[l]> so I have a feeling my data structures are the ones hurting me
03:22:20 * RayNbow wonders if sigfpe is going to turn http://twitter.com/sigfpe/status/6073161112 into a larger blog post in the near future :)
03:23:01 <path[l]> I guess I should create a better way to memoize this function. Something with quick lookup for 31x31 (sorry not 20)
03:23:28 <path[l]> a big Uarray I guess
03:24:59 <bastl> is there any graph drawing library using gtk2hs / cairo available ?
03:26:33 <ivanm> bastl: no
03:28:50 <Athas> Is there a way to block until either 1) a (specified) file descriptor has data available for reading, or I receive a signal?
03:46:01 <Lemmih> Athas: Yes.
03:46:22 <Athas> Lemmih: how?
03:47:06 <sohum> @pl \x -> f x
03:47:07 <lambdabot> f
03:47:10 <sohum> @pl \() -> f ()
03:47:11 <lambdabot> (line 1, column 4):
03:47:11 <lambdabot> unexpected " "
03:47:11 <lambdabot> expecting operator, pattern or "->"
03:47:17 <path[l]> any idea how I can prevent the gc from freeing memory? I wanna defer it
03:47:20 <Lemmih> Athas: One thread waits for the fd, another waits for the signal, a third waits for the two threads.
03:48:37 <quicksilver> path[l]: yes, by using command-line options which you cannot use.
03:48:52 <quicksilver> path[l]: anyhow "prevent the GC from freeing memory" is a strange goal. Why is that something you want to do.
03:49:12 <Athas> Lemmih: wow, that is awful, although less awful than other options.
03:49:31 <path[l]> I ran the profiler with -hd and took a look at the graph
03:49:34 <Athas> What's the easiest way to make a thread wait for two other threads?  I could use CSP, but it's a little overkill I think.
03:49:46 <Lemmih> Athas: An MVar.
03:49:46 <path[l]> and I have these jagged spikes which all correspond to (:)
03:49:51 <path[l]> Im guessing its gc cleaning up after me
03:51:00 <Athas> Lemmih: oh right, they can have two writers.
03:51:10 <fasta> Are pthreads as easy to use as mvars, btw?
03:51:41 <Athas> They're different things.
03:51:47 <Athas> But MVars are nice.
03:52:14 <fasta> Athas, mvars in combination with forkIO sort of do the same thing as pthreads, no?
03:52:44 <Athas> thingwath: not really, since assigning/reading with MVars can block.
03:53:01 <Athas> Well, maybe in Haskell-land it's the same thing.
03:57:11 <Athas> Is it dangerous to be too creative with signals and sigmasks in GHC?  Specifically, does the RTS itself make use of signals?
04:06:57 <quicksilver> fasta: pthreads are "sort of" the same as forkIO
04:07:05 <quicksilver> fasta: but pthreads provide no MVar facility at all.
04:07:26 <quicksilver> fasta: in pthreads you gaily write directly to shared memory and happily create elusive and very hard to debug race conditions.
04:07:48 <fasta> quicksilver, there must be some way to do mutual exclusion in one of those libraries.
04:07:56 <Jafet> Sniff, you're making me all nostalgic about C now
04:08:06 <quicksilver> yes, pthread_mutex
04:08:15 <quicksilver> it's a much less interesting primitive than MVar though.
04:08:24 <fasta> quicksilver, why is that?
04:09:06 <quicksilver> well it's just a bare lock
04:09:58 <fasta> quicksilver, oh, right. Mvars already enclose the actual value.
04:10:15 <fasta> quicksilver, so there is no way to confuse any order.
04:11:39 <quicksilver> pthreads also have condvars
04:11:43 <quicksilver> which some people swear by
04:11:48 <quicksilver> and some people swear at
04:13:09 <RayNbow> hmm, Clojure has "managed references"... is there a package/lib in Haskell that provides the same?
04:14:41 <quicksilver> RayNbow: it would help if you told us what they were?
04:16:05 <RayNbow> I'm not sure myself yet, I've only seen a few talks on Clojure so far :p
04:16:42 <quicksilver> RayNbow: ok, since you don't know what they are, I can answer confidently.
04:16:50 <quicksilver> RayNbow: No, haskell doesn't need them. It has something better.
04:19:54 <RayNbow> hmm, if I'm reading http://clojure.org/refs correctly, IORefs might have the same behaviour in certain cases when using atomicModifyIORef
04:28:00 <oteren> span gives a tuple with two arrays
04:28:08 <oteren> and fst gives the first array
04:30:16 <oteren> and i still get   Couldn't match expected type `[a]' against inferred type `(a1, b) -> b'
04:30:39 <oteren> when i try to put fst(theTuple) into a func taking an array as an argument
04:30:53 <Lemmih> oteren: Lists aren't arrays.
04:31:42 <Lemmih> oteren: You probably meant '(fst theTuple)'.
04:33:55 <miguel-hs> Lemmih, oteren: Or, may be, she/he meant 'head theTuple'.
04:34:21 <Lemmih> miguel-hs: I very much doubt that.
04:34:35 <oteren> nono, i just screwed up the parenthesis
04:34:48 <miguel-hs> Ok, I missed the type error.
04:34:54 <oteren> haskell is quite sensitive to over-parenthesising
04:35:24 <quicksilver> oteren: haskell isn't sensitive to over-parenthesising, only wrong-parenthesising, surely?
04:35:31 <quicksilver> > ((((4)))) + (((3)))
04:35:33 <lambdabot>   7
04:36:03 <Lemmih> oteren: You didn't have too many. You just put them the wrong place.
04:37:08 <PeakerWork> I think he meant #haskell is quite over-sensitive
04:37:30 <oteren> that too
04:37:31 <oteren> :D
04:46:19 <bastl> The module Control.Monad.Trans is in two packages. How can i tell ghci to ignore one of them?
04:46:47 <bastl> ivanm: happens when launching CairoGhci.hs
04:46:52 <ben> For ghc it would be -hide-package mtl
04:47:04 <ivanm> huh? why you suddenly asking _me_? :o
04:47:16 <ivanm> there was a mailing list thread recently about it
04:47:36 <ivanm> something to do with an {-# OPTIONS_GHC .... #-} pragma IIRC
04:47:51 <bastl> because you knew that there are no cairo graph-drawing packages  :-)
04:47:56 <ivanm> so probably {-# OPTIONS_GHC -hine-package mtl #-} at the top of the file?
04:48:05 <ivanm> bastl: I know that because I'm interested in graph drawing!
04:48:08 <bastl> hide ?
04:48:14 <ivanm> bastl: I lied, someone just did one as a demo IIRC...
04:48:21 <ivanm> um, yeah, hide, not hine
04:48:54 <bastl> cool. you answer questions on IRC and you lie ? I trust most ppl here ;-)
04:49:00 <ivanm> http://chplib.wordpress.com/2009/11/24/force-directed-graph-layout-with-barriers-and-shared-channels/
04:49:10 <ivanm> well, I was mistaken
04:49:19 <ivanm> its not really a full-blown graph layout thingy AFAIK
04:49:21 <ivanm> just a demo
04:49:47 <ivanm> bastl: any reason it has to use gtk2hs?
04:50:07 <ivanm> bastl: *shameless plug* my graphviz bindings can create a cairo window...
04:50:09 <bastl> just had some experiences and thought that cairo is a good library for that ...
04:50:29 <bastl> ah?
04:50:38 <ivanm> yeah
04:52:49 <bastl> ill have a look at it. any demos available?
04:53:25 <ivanm> the graphs here were made using it: http://code.haskell.org/~ivanm/Sample_SourceGraph/SampleReports.html
04:53:38 <ivanm> bastl: but it's just a haskellian wrapper around Graphviz: www.graphviz.org
04:56:36 <mxc> ola
04:56:59 <bastl> SourceGraph depends on a nlot of packages ...
04:58:57 <mxc> is there a significant performance/space hit when moving from Doubles to Pico's (12 digit fixed precision from Data.Fixed)
04:59:10 <ivanm> bastl: does it?
04:59:14 <bastl> and finally fails because multiset fails :-/
04:59:22 <ivanm> depends on cabal, hsx, graphviz, graphalyze, fgl...
04:59:32 <ivanm> but graphviz and graphalyze depend on fgl as well, so *shrug*
04:59:42 <ivanm> bastl: compared to yi, it barely uses any packages at all!
04:59:48 <ivanm> bastl: :o how does multiset fail?
04:59:48 <bastl> :-)
05:00:03 <ivanm> bastl: oh, right, there was a new release and I think I dind't have an upper bound...
05:00:10 <ivanm> bastl: use the older multiset
05:00:11 <bastl> Data.Data not found, hidden-pacakge base
05:00:19 <ksf> what was that program called that outputs html+graph plots of a packages' module structure?
05:00:19 <bastl> 0.1 ?
05:00:23 <ivanm> mxc: never used Pico's, but I would assume so
05:00:26 <ivanm> bastl: right
05:00:30 <bastl> k
05:00:40 <ivanm> ksf: sourcegraph does that as part of its running
05:00:49 <ivanm> there's another one on hackage though that only does module dependencies
05:02:11 <ksf> sometimes I'm really missing eclipse, where you could jump back and forward to other methods without managing files.
05:02:21 <ksf> ...I know there's ctags, but it's not the same.
05:05:02 <quicksilver> mxc: Yes. Significant. Doubles are CPU-native, Fixed uses Integer which uses gmp which is a user-level library.
05:05:04 <blackdog> ksf: I know what you mean. every individual feature can be emulated, but it's not generally very smooth.
05:05:30 <shambler> gmp is cool
05:05:53 <ksf> also, refactoring.
05:06:02 <mxc> oh
05:06:07 <mxc> didn't realize that Fixed used GMP
05:06:22 <quicksilver> mxc: to be pedantic, it doesn't.
05:06:24 * hackagebot upload: elerea 1.1.0 - A minimalistic FRP library (GergelyPatai)
05:06:26 <quicksilver> mxc: Fixed uses Integer.
05:06:31 <blackdog> ksf: i think that's just a matter of putting in the work. it probably wouldn't be that hard to pull the @pl command out of lambdabot and integrate it with emacs, for instance
05:06:33 <quicksilver> (and GHC uses gmp to imlpement Integer)
05:06:49 <mxc> was kinda hoping that it was just 64 bit ints with a division by 1e9 everytime you go in and out
05:06:53 <mxc> if that makes any sense
05:07:24 <quicksilver> > 2 ^ 64
05:07:25 <mxc> yeah, summing 30mm Doubles took 3 sec, still running for Picos
05:07:26 <lambdabot>   18446744073709551616
05:07:30 <quicksilver> of course it makes sense
05:07:36 <quicksilver> that's precisely how it works :)
05:07:45 <quicksilver> ...except it doesn't use 64 bit ints, it uses Integer.
05:08:08 <quicksilver> I imagine part of the reason it is so is because it was written long before anyone had dreamed of 64 bit ints.
05:08:18 <mxc> wisn't Integer significantly slower than Int64/Int32s
05:08:29 <quicksilver> (and of course it doesn't "really" divide by 1e9, it just fixes things up when it needs to)
05:08:37 <mxc> of course
05:08:48 <quicksilver> mxc: Int32 isn't an option
05:08:50 <mxc> in my continued unscientific test, summing 30mm Int64s took 1.7 sec, and with integers was 4.7 sec
05:08:55 <int-e> mxc: it's also considerably more correct for large numbers ;)
05:09:00 <quicksilver> (not enough digits)
05:09:03 <mxc> yeah, you'd have a small range
05:09:06 <mxc> true
05:09:07 <quicksilver> Int64 didn't exist when it was written
05:09:19 <mxc> hehe
05:09:29 <path[l]> hmm Im not sure how to build my memoization thing with a UArray. Everytime I insert into it won't I be creating a while new array?
05:09:39 <bastl> ivanm: i am impressed: about a year ago i was looking for such a tool. This is really very cool.
05:11:06 <int-e> path[l]: UArray and memoization don't go well with each other.
05:11:12 <path[l]> ah
05:12:01 <path[l]> I have a function which takes 2 parameters i and j and I know both vary from 0 to 31. Whats the best thing to use for memoization
05:12:18 <path[l]> IntMap is an option I guess
05:12:33 <ivanm> bastl: which tool? SourceGraph?
05:12:40 <bastl> yes.
05:12:44 <int-e> path[l]: Array (Int, Int) x or perhaps Array Int (Array Int x)
05:13:03 <mxc> path[i] hte issue isn;'t w/ it being an array, just an unboxed array
05:13:04 <bastl> one question: what If i would like to use it with another language?
05:13:08 <ivanm> bastl: I've got a paper on it coming up at PEPM in January...
05:13:12 <path[l]> oh ok
05:13:16 * ivanm should probably start working out wtf he's going to say...
05:13:26 <path[l]> what does boxing and unboxing do?
05:13:41 <quicksilver> ivanm: just sing a little song, that's what most people do.
05:14:03 <ivanm> bastl: there's language.c available on hackage; theoretically, all you'd have to do is update the Parsing section of modules and some small changes to the graph-drawing stuff
05:14:04 <int-e> path[l]: but not UArray, because you can't tie knots with UArray elements - you need thunks (unevaluated values) for that, which require boxing, hence a boxed array.
05:14:16 <ivanm> bastl: but I don't know enough C to tell how to do it properly...
05:14:19 <ivanm> quicksilver: heh
05:14:32 <path[l]> hmm
05:14:48 <mxc> in an unboxed array of ints for example, each element is simply the 4 or 8 bytes to store the int
05:14:49 <ivanm> quicksilver: hmmm.... Lobachevsky seems appropriate somehow...
05:14:57 <ivanm> not that I plagiarised; I just like the song! :p
05:14:58 <mxc> so no unevaluated thunks -> no laziness -> no memoization
05:15:05 <path[l]> oh ok
05:15:11 <int-e> path[l]: the "box" something that contains a value; basically it is a tag and a value. The point is that you can have other tags that describe failures or unevaluated values.
05:15:21 <mxc> a boxed array of ints has essentially pointers to haskell int values, which can be thunks
05:15:24 <path[l]> ah
05:15:34 <mxc> i mgiht be mangling the terminology
05:16:01 <path[l]> in the example I see it uses Fibbonacci which looks up a linked list. He does it by mapping the list [1..x] to the values and looking it up. With a boxed array is there something similar I could do?
05:16:34 <path[l]> I should look up the constructor
05:16:37 <path[l]> nm
05:16:39 <path[l]> I think I got it
05:16:47 <int-e> path[l]: yep, you just need to use ! (from Data.Array) instead of !! (from Prelude or Data.List) for the lookup.
05:16:49 <EvilTerran> you could have an array of the first so-many fibonacci numbers made in a similar way, yes
05:17:23 <path[l]> EvilTerran: nah thats the famous example I see on the net everywhere of memoization with haskell
05:17:24 <path[l]> lol
05:22:13 <mxc> hm, can't put strictness annotations in newtypes?
05:23:13 <ski> `newtype' constructors are strict anyway
05:23:23 <ski> (but matching on them doesn't force)
05:23:42 <ivanm> EvilTerran: I thought that normally used a Map...
05:25:12 <EvilTerran> ivanm, well, i guess you could use a Map
05:25:33 <mxc> ok, i know the problem, essentially i want to do this:  newtype T a = T !(Either String !a)  - as in evaluation of the outer constructor should force the whole thing, but, i think i might need to redefine Either to accomplish that
05:25:54 <EvilTerran> but then, an array's just a map with dense keys, so you can do anything you could do with an array with a map instead
05:25:57 <jmcarthur> i suppose i should not be shocked that the functor and monad laws do not appear to have corresponding rewrite rules, considering the laws must be testable, right?
05:25:57 <quicksilver> you would, yes, mxc
05:26:05 <quicksilver> you can't change the strictness of a pre-existing type.
05:26:15 <ivanm> EvilTerran: right, but with a Map can't you theoretically have an infinite number of fibonacci values?
05:26:18 <jmcarthur> or perhaps i am not looking hard enough?
05:26:23 <EvilTerran> mxc, "data T a = TS String | TA !a"?
05:26:23 <quicksilver> jmcarthur: do you believe they are interesting optimisations?
05:26:24 <ivanm> whereas with an array don't you have to define the bounds?
05:26:36 <quicksilver> jmcarthur: (do you know in which direction you'd choose to "optimise" them? )
05:26:44 <EvilTerran> ivanm, Data.Map is spine-strict, though, so no infinite Maps
05:26:54 <ivanm> oh, yeah.... :(
05:26:55 <jmcarthur> quicksilver: is fmap f . fmap g ==> fmap (f . g) not an interesting optimization?
05:27:09 <ivanm> EvilTerran: but still, it's easier to "grow" a memoized map than an array
05:27:16 <EvilTerran> jmcarthur, is it always an optimisation?
05:27:31 <mxc> evilterran: yeah, thats what I was trying to avoid,
05:27:33 * jmcarthur is trying to think of a case in which it is not
05:27:35 <mxc> thanks though
05:27:37 <quicksilver> jmcarthur: yes, that one probably is.
05:27:56 <jmcarthur> i agree that most of them are probably not interesting
05:28:01 <jmcarthur> associativity, for example
05:28:31 <EvilTerran> ivanm, true; i was thinking of creating a single array with its elements defined in terms of each other, tho
05:30:06 <EvilTerran> fibs = listArray (0,n) $ 0 : 1 : [fibs!(i-2) + fibs!(i-1) | i <- [2..n]] -- kinda thing
05:30:14 <jmcarthur> i suppose the purpose was probably not only to keep the laws testable but also to give developers the opportunity to selectively add rewrite rules to particular cases
05:33:25 <blackdog> EvilTerran: I still wonder why that restriction on giving the bounds up front is necessary
05:33:43 <blackdog> it would not be impossible to resize when an element beyond the current bounds was written to
05:34:04 <blackdog> you could still throw an error when you read from outside the current bounds
05:34:51 <EvilTerran> blackdog, it wouldn't be impossible, but it wouldn't be simple either
05:35:21 <EvilTerran> seeing as things are generally expected to not change
05:36:11 <quicksilver> blackdog: what would you fill the empty gaps with? _|_ ?
05:37:14 <ivanm> how does one use hpc within a cabal file? does -fhpc need to be added to ghc-options?
05:39:17 <blackdog> quicksilver: hm, that's a point. The use I was envisioning was defining a value at every index, but doing it lazily
05:39:55 <quicksilver> I think the only real answer to your question is that this lies outside the envisioned use-case of arrays
05:40:03 <quicksilver> i.e. it's not impossible, just not what they were trying to do.
05:40:04 <blackdog> it's not necessarily the syntax you always want, but it'd be nice to have constant time access to everything you've previously computed
05:40:21 <quicksilver> mutation behind the scenes like that is bad for GC but that might not be a show stopper.
05:40:22 <blackdog> gah. semantics, not syntax.
05:40:47 <blackdog> you can sort of simulate it with lists of arrays, i suppose
05:41:40 <quicksilver> constant time access is a myth anyway ;)
05:41:53 <quicksilver> but fast access certainly
05:42:36 <blackdog> quicksilver: you mean cache effects etc?
05:42:48 <quicksilver> blackdog: not really.
05:43:03 <quicksilver> blackdog: array access only works for a fixed length of pointer
05:43:20 <quicksilver> blackdog: so your maximum array size is 2^32 or 2^64
05:43:30 <quicksilver> blackdog: ... so it really isn't an asymptotic notion
05:43:45 <quicksilver> blackdog: if you imagined some theoretical system which supported arbitrary large memory model
05:43:54 <quicksilver> blackdog: ...then pointer dereference would presumably be O(log n)
05:43:58 <poucet> quicksilver: by that argument, nothing is, as the number of atoms in the universe are bounded
05:44:04 <quicksilver> blackdog: proportional to the number of bits in the pointer.
05:44:06 <blackdog> ah, righto. still, 2^64 is big enough for my practical purposes...
05:44:27 <quicksilver> blackdog: but if 2^64 is big enough for your practical purposes, then so are all the O(log n) structures
05:44:35 <quicksilver> blackdog: (e.g. trie, binary tree, etc)
05:44:47 <quicksilver> blackdog: since log n is bounded above by 64 which is 'just' a constant.
05:45:08 <quicksilver> blackdog: so actually we just care which happens to be fastest. Which probably is arrays, I agree.
05:45:33 <quicksilver> poucet: no, asymptotic complexity applies to theoretical machines, not real ones
05:45:41 <blackdog> asymptotic analysis tends to break down a bit at some levels...:) i still remember being affronted to be told by my algos professor that chess wasn't even in polynomial space
05:45:58 <quicksilver> poucet: because to consider aysmptotic behaviour you must be considering a machine which can handle problems of arbitrary size.
05:46:02 <blackdog> asymptotically, it's constant-time to solve..
05:46:35 <quicksilver> poucet: ...and in such a machine, pointer dereference would probably be O(log n). Depending how to choose to set up the theoretical framework.
05:51:41 <ski> > let fibs n = (fib,arr) where fib = (arr !); arr = tabulate (0,n) fib_; fib_ 0 = 0; fib_ 1 = 1; fib_ i = fib (i-2) + fib (i-1) in snd (fibs 10)
05:51:43 <lambdabot>   array (0,10) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34...
05:55:16 <mxc> if anyone's curious, wrapping doubles, ints, whatever, in Either's (to thread errors thorugh a calculation) seems to impose about a 30x performance penalty
05:55:47 <EvilTerran> mxc, might a CPS version be faster?
05:56:06 <Ferdirand> hello #haskell. Is there a standard datatype for infinite lists, that doesn't have a nil constructor ? does it make sense to define one ?
05:56:18 <mxc> you'd ahve to include the overhead for me un-forgetting CPS
05:56:21 <quicksilver> it does make sense, and some people call it 'Stream'
05:56:27 <EvilTerran> "type Either' a b = forall c. (a -> c) -> (b -> c) -> c"
05:56:32 <ejpbruel> im not sure if im in the right channel for this
05:56:35 <ski> > let fibs n = fixTabulate (0,n) $ \fib i -> case i of 0 -> 0; 1 -> 1; i -> fib (i-2) + fib (i-1) in snd (fibs 10)
05:56:37 <lambdabot>   array (0,10) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34...
05:56:39 <ejpbruel> i have a question about letrecs
05:56:44 <quicksilver> the CPS will be faster almost certainly, EvilTerran + mxc
05:56:54 <ski> ejpbruel : what about them ?
05:57:16 <ejpbruel> well, suppose i wanted to create an infinite list of n's
05:57:25 <ejpbruel> i could define that something like this (not sure if this is valid Haskell syntax):
05:57:40 <ejpbruel> infiniteListOf n = letrec c = n : c in c
05:57:49 <ejpbruel> alternatively, i could also write:
05:58:00 <ejpbruel> infiniteListOf n = n : (infiniteListOf n)
05:58:03 <ski> Ferdirand : i don't think so. try defining `data Stream a = Cons a (Stream a)' or `data Stream a = Cons {head :: a,tail :: Stream a}' or `data Stream a = a :> Stream a'
05:58:04 <mxc> ejpbruel - s/letrec/let
05:58:19 <ejpbruel> the latter, if i understand correctly, is less efficient, because i need to evaluate infiniteListOf all the time
05:58:24 <ejpbruel> but that got me thinking
05:58:32 <mxc> second one is better, but this isnt ocaml, no 'rec' declarations are necessary
05:59:00 <Ferdirand> I did define it already, but I was wondering if there was a hidden catch
05:59:04 <int-e> @src repeat
05:59:05 <lambdabot> repeat x = xs where xs = x : xs
05:59:07 <ski> the first one will probably construct a cyclic list, while the second might not
05:59:17 <ski> @src cycle
05:59:18 <lambdabot> cycle [] = undefined
05:59:18 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
05:59:32 <ejpbruel> ski: exactly, so if i understnad correctly the first should be faster, because it only requires a (circular) list traversal
05:59:41 <mxc> evilterran - i'll go reread the CPS tutorials, but at first glance, it seems like you wouldn't be able to create instances for Num, Fractional etc
05:59:44 <ejpbruel> whilest the second one requires a new reduction on each traversal to the next node
05:59:58 <Ferdirand> So far, the only motivation I have for using it is that allows me to remove [] when matching, and make the compiler happy
06:00:09 <ejpbruel> anyway, since i can see the semantic equivalence between the two expressions, can't the compiler as well?
06:00:24 <ejpbruel> ie shouldnt the compiler be able to generate the cyclic list from the recursive definition automatically?
06:00:25 <quicksilver> ejpbruel: the compiler doesn't compile all semantically equivalent things identically.
06:00:40 <ejpbruel> quicksilver: that would be my point :)
06:00:46 <quicksilver> deciding which of two semantically equivalent forms is better is called "optimisation"
06:00:51 <ejpbruel> they are semantically equivalent but not equally efficient expressions
06:00:57 <quicksilver> perfect optimisation - i.e. always getting it right - is an unsolved problem.
06:01:08 <quicksilver> and, I presume, will never be solved perfectly.
06:01:17 <ejpbruel> of course, i realize that, i believe its even proven to be unsolvable
06:01:27 <ejpbruel> but this is a very specific subproblem of the larger problem of optimization
06:01:29 <ski> Ferdirand : i'm not sure about a catch ..
06:02:00 <ejpbruel> i.e. detecting recursive definitions like the 2nd and transforming them to the (allegedly more efficient) definition using a letrec
06:02:16 <quicksilver> ejbruel: so given that the compiler can't always get it right, it is beneficial to have predictable compiler behaviour so the user can choose
06:02:22 <ejpbruel> would that be possible?
06:02:34 <quicksilver> ejpbruel: GHC lets the user choose, by and large, by using explicit "let" to denote sharing.
06:02:40 <quicksilver> of course, this isn't documented or guaranteed ;)
06:02:47 <quicksilver> it's just #haskell folklore.
06:03:00 <Ferdirand> ski: so, if there is no catch, i'd have expected something so simple to be in the standard lib already.. found it a bit suspicious :)
06:03:07 <ejpbruel> quiksilver: that would imply that the compiler cannot, in general, find an optimal solution when there's a choice between a definition with and without a letrec
06:03:17 <quicksilver> Ferdirand: the catch is you may lose certain static optimisations
06:03:20 <quicksilver> Ferdirand: (list fusion)
06:03:35 <quicksilver> ejpbruel: that's right. it's possible to construct examples where extra sharing is good, and other examples where it is bad.
06:03:44 <PeakerWork> quicksilver: I wouldn't say its deciding between 2 given equivalent forms -- its also about finding those equivalent forms
06:03:53 <ejpbruel> quicksilver: would you be able to give me such an example?
06:03:53 <quicksilver> ejpbruel: "naively" sharing is good because it reduces memory usage
06:03:59 <quicksilver> ejpbruel: but the catch is the interaction with GC
06:04:11 <quicksilver> ejpbruel: sharing means that something can't be GCed while the 'other' reference is live
06:04:13 <fasta> PeakerWork, if you can decide, you can also find.
06:04:16 <ejpbruel> peakerwork: i believe so too, the main problem might be that the compiler might be unable to 'see' the equivalence
06:04:35 <fasta> PeakerWork, of course, in general, it cannot.
06:04:36 <ejpbruel> quicksilver: some context: im currently working on an interpreter for a haskell like language
06:04:40 <PeakerWork> fasta: you can't generally decide they are equivalent, even if you can decide which is better :)
06:04:42 <quicksilver> ejpbruel: some times your program's memory usage might increase, and it might be better to unshare it (let it be GC'ed) and reconstruct it later.
06:05:04 <quicksilver> PeakerWork: you can decide for some interesting languages.
06:05:11 <ejpbruel> quicksilver: thats an interesting point
06:05:15 <quicksilver> PeakerWork: STLC is strongly normalizing and therefore decidable.
06:05:16 <ejpbruel> quicksilver: because the 2nd definition requires more reductions but does not cause reference cycles
06:05:38 <PeakerWork> Yeah, ok
06:05:56 <ejpbruel> quicksilver: another question then
06:05:56 <quicksilver> PeakerWork: and STLC is a fairly "interesting" fragment of haskell, too.
06:06:12 <ejpbruel> quicksilver: let's assume that the compiler can detect the equivalence between the expression with and the expression without the letrec
06:06:29 <ejpbruel> quicksilver: lets also assume that you want to be able to choose between the two, for the reasons youve just illustrated
06:06:59 <ejpbruel> quicksilver: since the compiler can detect the equivalen between recursive definitions and letrec definitions, and cycles are only caused by letrecs, wouldnt it be possible to detect the creation of cycles at compile time?
06:09:12 <PeakerWork> ejpbruel: if you forbid all recursion, you forbid general recursion and get terminating programs.. But you also lose a lot of interesting power -- that you don't have to lose for termination
06:09:33 <ejpbruel> PeakerWork: i realize that, but im not saying one should forbid recursion
06:09:51 <ejpbruel> PeakerWork: im saying that one could be able to detect where recursion occurs in the program
06:10:15 <ejpbruel> PeakerWork: given that would be possible, i could create a refcounting implementation, where nodes that are part of a cycle share the same refcount
06:10:16 <PeakerWork> ejpbruel: oh, I don't think there's a problem detecting that (with false positives, though)
06:10:48 <ejpbruel> PeakerWork: that's what im trying to confirm :)
06:11:18 <ejpbruel> PeakerWork: by the way, there's an interesting paper on total functional programming, where one only allows structural recursion on finite data structures, and additionaly use codata to have well behaved inifinite recursion
06:11:39 <quicksilver> Turner, no doubt.
06:11:50 <ejpbruel> PeakerWork: such a language would still not be Turing complete, but i strongly suspect that any *useful* algorithm you could come up with would be implementable in such a language
06:11:50 <PeakerWork> Yeah, I read that, its interesting, but I still don't fully understand codata
06:12:18 <PeakerWork> ejpbruel: well, you can't implement an interpreter for such a language in such a language
06:12:30 <ejpbruel> PeakerWork: way i understand it, codata allows you to model a process that recurses on an infinite data structure, as long as it performs some useful work within a finite amount of time
06:13:44 <ejpbruel> PeakerWork: it would seem that way, given Turings thesis
06:14:07 <ejpbruel> PeakerWork: but does the fact that a language can interpret itself automatically imply turing completeness?
06:14:19 <ejpbruel> PeakerWork: i had some doubt about that comment, you see
06:15:15 <ejpbruel> PeakerWork: you could probably prove it by contradiction, but my proof skills are not that good :)
06:15:45 <PeakerWork> ejpbruel: quicksilver's Hello language in which there's just one program "Hello" which prints "Hello". Its also a valid interpreter for "Hello" programs
06:15:56 <path[l]> Im confused. Which array constructor should I use to create an array for memoization? if I use listArray  Ill end up creating a throwaway list
06:15:59 <PeakerWork> (and the empty language is its own interpreter)
06:16:30 <ejpbruel> PeakerWork: good point
06:16:49 <ejpbruel> PeakerWork: for me, that sheds some doubt on the statement that a non-Turing complete language cannot interpret itself *because* it isn't turing complete
06:16:52 <EnglishGent> what's STLC?
06:16:53 <EnglishGent> :)
06:17:05 <ski> Simply Typed Lambda Calculus
06:17:08 <EnglishGent> ah!
06:17:11 <EnglishGent> ty :)
06:17:14 <ejpbruel> PeakerWork: i think that statement is only true if you look at the family of non-turing complete languages in general
06:17:20 <PeakerWork> ejpbruel: well, there's a simple proof of why an interesting total language cannot interpret itself
06:17:32 <PeakerWork> iirc, anyway :)
06:17:33 <ejpbruel> PeakerWork: please explain?
06:19:08 * ski wonders when Loeb's theorem is provable in total languages
06:19:54 <ski> (that's vague, of course. but i suspect it is provable when expressible)
06:20:03 <ejpbruel> PeakerWork: do you remember the name of that proof, by any chance? :)
06:20:03 <zygoloid> isn't loeb's theorem a monadic fixed point?
06:20:15 <ski> not monadic
06:20:26 <ski> closer to comonadic, in that case
06:20:56 <ski>   loeb :: F (F a -> a) -> F a
06:21:07 <ski> if we assume we have
06:21:10 <ski>   eval :: F a -> a
06:21:12 <ski> then
06:21:49 <ski>   eval (loeb codeEval) :: a
06:21:51 <ski> assuming
06:21:55 <leimy> I have enough of a subset of my little Expect language (not the libexpect bindings) that I might be able to put together a hackage package for it.  I need to clear it with work.
06:21:57 <ski>   codeEval :: F (F a -> a)
06:22:22 <leimy> I need to test it a bit more, but I think it works ok, and does not have issues with memory leakage.
06:22:32 <ski> the type `F a' being the type of expressions of type `a'
06:22:34 <path[l]> hmm if I use a list comprehension constructor for an Array, does that create a temporary list?
06:22:38 <zygoloid> i thought that F in such cases had to comply with axioms F (F a) -> F a, and a -> F a?
06:22:59 <ski> zygoloid : in which cases ?
06:23:06 <zygoloid> the F in loeb's theorem
06:23:16 <ski> nope
06:23:21 <ski> the `F' is a modality
06:23:55 <ski> ("provable", a kind of "neccesary"-modality .. which are more like comonads than monads)
06:24:01 <poucet> Does anyone know the status of monadic patterns?
06:24:13 <ski> poucet : monadic patterns ?
06:24:31 <poucet> Yes, there was this monadic pattern syntax
06:24:38 <poucet> Which made patterns 'somewhat' more first class
06:24:57 <poucet> I can't remember the exact syntax
06:25:02 <ski> zygoloid : it must satisfy `F a -> F (F a)', and `F (a -> b) -> F a -> F b', also if `a' is provable without assumptions, then `F a' should be provable without assumptions
06:25:07 <poucet> but basically:  Pat |-> Exp
06:25:09 <poucet> has type
06:25:17 <poucet> \t -> m (typeof Exp)
06:25:20 <poucet> so you can combine patterns
06:25:21 <PeakerWork> ejpbruel: http://lambda-the-ultimate.org/node/3076
06:25:24 <ski> zygoloid : but if we also have `F a -> a', then the system is inconsistent, as the above reasoning showed
06:25:36 <zygoloid> ski: i don't have a good intuition for modal logics, i could well believe i got it backwards
06:25:57 <zygoloid> ski: but i thought we had a combinator in here for a while, loeb :: Monad m => m (m a -> a) -> m a?
06:26:14 <ski> (and `eval :: F a -> a' would be the self-interpreter spoken about above)
06:26:38 <ejpbruel> PeakerWork: thanks! lemme dive into it :)
06:26:43 <ski> zygoloid : `loeb :: Functor f => f (f a -> a) -> f a', yes. but that uses general recursion
06:27:14 <zygoloid> *shrug* ok, i guess my memory sucks ;-)
06:27:38 <ski> poucet : (itym s/\\//) where does `t' come from ?
06:29:54 <poucet> ski: t is the type of the pattern
06:30:25 <ski> would `Pat |-> Exp' be an expression ?
06:30:29 <poucet> I think so
06:30:31 <poucet> oh waiit
06:30:36 <poucet> it's a function,
06:30:44 <poucet> which returns m (typeof Exp)
06:30:49 <poucet> so you can combine them
06:30:56 <poucet> There was a syntax proposal for this at some point
06:30:59 * ski wonders what to wait for
06:31:09 <poucet> ski: it's a function, so yes an expression
06:31:20 * zygoloid wonders if you could get an approximation of first-class patterns with some TH and some CPP
06:31:42 <ski> expressions comsume bindings
06:31:48 <ski> patterns produce bindings
06:31:57 <ejpbruel> PeakeWork: so what it amounts to: if you could define eval in a total language, you could use it to reintroduce inifinite recursion?
06:32:02 <poucet> ski: IIRC
06:32:05 <poucet> the syntax was
06:32:07 <poucet> |pat -> exp
06:32:10 <poucet> instead of \pat -> exp
06:32:29 <ski> if patterns are to be reified as expressions, to be passed to functions, then their types ought to mention which variables (with what types) they bind
06:32:46 <poucet> ski: patterns are not reified, but a pattern-match clause is reified
06:32:57 <path[l]> >  a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \<- [2..100]])
06:32:59 <lambdabot>   <no location info>: parse error on input `='
06:33:04 <ski> poucet : how is that better than `\pat -> return exp' ?
06:33:14 <poucet> ski: less overhead?
06:33:16 <EvilTerran> ski, pattern-match failure
06:33:19 <poucet> and that
06:33:20 <path[l]> >  a = Data.Array.array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \<- [2..100]])
06:33:22 <lambdabot>   <no location info>: parse error on input `='
06:33:24 <poucet> EvilTerran: good point :)
06:33:28 <ski> EvilTerran : ok
06:33:34 <poucet> ski: that way you can combine patterns
06:33:45 <poucet> (|pat1 -> exp) + (|pat2 -> exp)
06:33:50 <EvilTerran> (|Just x -> x) Nothing = Nothing; (\Just x -> return x) Nothing = _|_
06:33:51 <zygoloid> ski: it's like "do pat <- return a; return exp" i guess
06:33:57 <ski> `\x -> pat <- return x; return exp' :)
06:34:01 <EvilTerran> yeah
06:34:18 <zygoloid> #define Pat(pat, exp) \a -> do pat <- return a; return exp
06:34:21 <lunabot>  luna: Not in scope: `define'
06:34:22 <path[l]> >  let a = Data.Array.array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \<- [2..100]])
06:34:24 <lambdabot>   <no location info>: lexical error at character '\FS'
06:34:29 <path[l]> huh
06:34:35 <path[l]> > let  a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \<- [2..100]])
06:34:37 <lambdabot>   not an expression: `let  a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \...
06:34:41 <poucet> ski: the idea was to have a very lightweight syntax that would promote the use of monadic pattern matching, so that it's easy to combine them
06:34:46 <ski> poucet : and how to define that `+' ?
06:34:47 <poucet> I can't find the proposal on google tho
06:34:48 <EvilTerran> path[l], "i \<- [2..100]"
06:34:55 <path[l]> > let  a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i \<- [2..100]]) in a
06:34:57 <lambdabot>   Not in scope: `\<-'
06:35:02 <path[l]> oh
06:35:06 <ski> oh, hm
06:35:13 <ejpbruel> evil h :: t = evil h t
06:35:14 <path[l]> wierd I just copied that off the website
06:35:16 <ejpbruel> hmmm
06:35:19 <ejpbruel> sorry about that
06:35:21 <ski>   \ma mb x -> ma x `mplus` mb x
06:35:22 <ski> i suppose
06:35:28 <poucet> ski: yeah
06:35:30 <path[l]> > let  a = array (1,100) ((1,1) : [(i, i * a!(i-1)) | i <- [2..100]]) in a
06:35:32 <lambdabot>   array (1,100) [(1,1),(2,2),(3,6),(4,24),(5,120),(6,720),(7,5040),(8,40320),...
06:35:34 * EvilTerran has been thinking about something to the effect of "<ski> expressions comsume bindings <ski> patterns produce bindings" recently
06:35:37 <poucet> actually not mplus
06:35:48 <poucet> Though I guess you could
06:35:51 <ski> `morelse' ?
06:35:54 * poucet nods
06:36:07 <ski> why ?
06:36:07 <poucet> But that's debatable :) Especially for the list monad
06:36:31 <poucet> Anyways, there was a syntax proposal for this a while back, and I can't find it.
06:36:34 <poucet> Wondered if it was in or not.
06:36:35 <EvilTerran> and the possibility of first-class patterns as a goal
06:36:47 <poucet> EvilTerran: do you remember how it was called?
06:36:54 <EvilTerran> er...
06:36:56 <ski> (|(_,Just y) -> y) + (|(Just x,_) -> x)
06:37:16 <ski> (in list monad, e.g., yes)
06:37:32 <poucet> ski: yes, I know, there can be debate about whether to use morelse or mplus
06:37:46 <poucet> I don't want to debate that at the moment, since I don't have a clear drive either way :)
06:38:12 <alp_> how can I check if a string is Read-able into an Integer without causing any error if it isn't the case ?
06:38:20 <poucet> alp_: reads
06:38:22 <poucet> :t reads
06:38:24 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:38:42 <alp_> > reads "12" :: Integer
06:38:45 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
06:38:45 <lambdabot>         agains...
06:38:57 <poucet> > reads "12" :: [(Integer, String)]
06:38:57 <ski> EvilTerran : elaborate on "first-class patterns as a goal" ?
06:38:57 <int-e> > reads ('"' : repeat ' ') :: [(Integer, String)]
06:38:59 <lambdabot>   [(12,"")]
06:39:02 <lambdabot>   mueval-core: Time limit exceeded
06:39:03 <poucet> > reads "a12" :: [(Integer, String)]
06:39:06 <lambdabot>   []
06:39:10 <alp_> ok, got it
06:39:13 <alp_> thank you poucet
06:39:17 <ski> > (reads :: ReadS Integer) "12"
06:39:19 <lambdabot>   [(12,"")]
06:39:24 <poucet> ski: nice one :)
06:39:57 <path[l]> > let a = Data.Array.array ((0,0),(4,4) [((i,j), i * j) | i <- [1..100], j <- [1..100]) in a
06:40:09 <lambdabot>   <no location info>: parse error on input `)'
06:40:20 <int-e> ReadS and ShowS are inconsistent - one is the type of the reads function while the other is the return type of shows ...
06:40:22 <poucet> path[l]: missing ) after (4,4)
06:40:40 <path[l]> ah damn. I need a better editor
06:42:43 <EvilTerran> ski, i mean, i've been idly thinking recently about how one would deal with this concept of "bindings" in such a way as to get a coherent language with first-class patterns
06:43:06 <path[l]> > let a = Data.Array.array ((0,0),(4,4)) [((i,j), i * j) | i <- [0..100], j <- [0..100]] in a
06:43:08 <lambdabot>   array * Exception: Error in array index
06:43:10 * ski sometimes defines
06:43:10 <ski> @type let readM :: MonadPlus m => ReadS a -> String -> m a; readM reads s = do (a,"") <- foldr (mplus . return) mzero (reads s); return a in readM
06:43:12 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => ReadS a -> String -> m a
06:43:39 <EvilTerran> ski, for some yet-to-be-defined meaning of "first-class patterns", that is ;)
06:43:43 <zygoloid> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13226#a13226 <-- first class patterns in one line of CPP
06:43:49 <path[l]> hmm ok what does that mean. Error in array index
06:44:27 <mmorrow> EvilTerran: one possibility is to refer to all sub-patterns/expressions with their path from the root
06:44:39 <zygoloid> do first-class patterns mean more to some people than simply some syntactic sugar for functions :: a -> Maybe b?
06:44:47 <mmorrow> in "(Node (x,_) _,_)"
06:44:49 <mmorrow> x is at
06:44:51 <EvilTerran> mmorrow, indeed, i've thought about something like that
06:44:59 <mmorrow> [0,0,0]
06:45:03 <mmorrow> and this composes too
06:45:13 <mmorrow> "(_,(Node (x,_) _,_))"
06:45:18 <ski> > let a = Data.Array.array ((0,0),(2,2)) [((i,j), i * j) | i <- [0..2], j <- [0..2]] in a
06:45:18 <mmorrow> [1] ++ [0,0,0]
06:45:20 <lambdabot>   array ((0,0),(2,2)) [((0,0),0),((0,1),0),((0,2),0),((1,0),0),((1,1),1),((1,...
06:45:41 <ski> > tabulate ((0,0),(2,2)) $ \(i,j) -> i * j
06:45:42 <path[l]> huh what did I do that was different
06:45:44 <lambdabot>   array ((0,0),(2,2)) [((0,0),0),((0,1),0),((0,2),0),((1,0),0),((1,1),1),((1,...
06:45:53 <ski> path[l] : you had up to `100'
06:46:05 <path[l]> oh I thought it would ignore that
06:46:08 <path[l]> hmm
06:46:44 <path[l]> it will run this constructor lazily right? Meaning if I dont pop something from this array, it wont calculate it?
06:47:06 <zygoloid> > (\v -> do a | a < 10 <- v; Just (a + 4)) 12
06:47:07 <lambdabot>   <no location info>: parse error on input `|'
06:47:13 <ski> EvilTerran : yes, i'm not sure what "first-class patterns" means :)
06:47:14 <mmorrow> path[l]: unless something else that you need depends on that thing
06:47:22 <zygoloid> :( i guess my macro should use case rather than do then :)
06:47:30 <path[l]> cool Im gonna use this to memoize my 2 para function
06:48:10 <EvilTerran> ski, yeah, i feel the definitions of "first-class pattern" and "binding" may be mutually referential; at least, it seems worthwhile to consider them both in parallel
06:49:30 <poucet> http://hackage.haskell.org/trac/haskell-prime/ticket/114
06:49:33 <poucet> woot, found it
06:52:15 <ski> (zygoloid : are you lilac ?)
06:54:14 <ski>   let __a__ = 42 in Pat(Left __a__,__a__)
06:55:17 <zygoloid> ski: sometimes
06:55:25 <zygoloid> ski: yeah, don't do that :)(
06:55:53 <ski> hygienic syntax ftw !
06:56:01 <zygoloid> good ol' CPP
06:56:13 <mmorrow> #define ZOMG(x)\ int _________________________x = x; ...
06:56:14 <lunabot>  luna: Not in scope: `define'
06:56:18 <mmorrow> gah
06:56:25 <zygoloid> #42
06:56:26 <lunabot>  luna: parse error on input `]'
06:56:29 * mmorrow makes a note to s/#/;/
06:56:43 <mmorrow> #ty let fix f = let x = f x in f in fix
06:56:50 <lunabot>  forall t . (t -> t) -> t -> t
06:56:58 <mmorrow> :o
06:57:05 <mmorrow> #ty let fix f = let x = f x in x in fix
06:57:06 * ski wonders whether TH implements hygiene, or just "gensym"
06:57:07 <mmorrow> heh
06:57:08 <lunabot>  forall t . (t -> t) -> t
06:57:22 <mmorrow> , newName "gensym"
06:57:22 <lunabot>  luna: No instance for (GHC.Show.Show
06:57:39 <mmorrow> , listE . fmap varE =<< replicateM_ 10 (newName "gensym")
06:57:40 <lunabot>  luna: Couldn't match expected type `[Language.Haskell.TH.Syntax.Name]'
06:57:45 <path[l]> hmm suddenly when I load my .hs file in ghci, it doesnt throw an error but when I try to inquire about the type of any function it says not in scooe
06:57:46 <mmorrow> arghh!!
06:58:14 <zygoloid> #ty newName
06:58:17 <lunabot>  String -> Q Name
06:58:24 <ski> (with real hygiene, a macro exported from a module can expand to an expression referring to identifiers that were not exported)
06:58:48 <mmorrow> ski: TH only has gensym
06:58:56 <mmorrow> ski: but you can of course write a renamer
06:58:57 <ski> ok
06:59:25 <mmorrow> since you can have and combine raw AST chunks outside of the control of any enforcer of hygiene
07:00:16 <mmorrow> haha, repicateM<NOT _>
07:00:18 <mmorrow> , listE . fmap varE =<< replicateM 10 (newName "gensym")
07:00:19 <lunabot>  ListE [VarE gensym_0,VarE gensym_1,VarE gensym_2,VarE gensym_3,VarE gensy...
07:00:44 <mmorrow> i've been staring at that for at least a minute going "wtf, oh! err, wait, wtf, oh!, err..."
07:00:46 <notweebl> how do i convert IO String to String
07:00:47 <ski> , listE . fmap varE =<< replicateM 2 (newName "gensym")
07:00:48 <lunabot>  ListE [VarE gensym_0,VarE gensym_1]
07:01:21 <ski> are the names renumbered on print, or does it reset between runs ?
07:01:21 <mmorrow> , listP . fmap varP =<< replicateM 2 (newName "x")
07:01:22 <lunabot>  luna: No instance for (GHC.Show.Show
07:01:49 <mornfall> @src lines
07:01:50 <lambdabot> Source not found. Just try something else.
07:01:55 <mmorrow> ski: it has a global unsafePerformIO (newIORef 0) it uses
07:02:20 <mmorrow> in the Language.Haskell.TH.Syntax module
07:02:39 <mmorrow> in lunabot, that gets reset between every new ", .."
07:02:44 <mornfall> What is the general form of lines/words?
07:02:53 <mmorrow> but in you program, it would continue counting upwards
07:03:00 <notweebl> how do I make a String out of an IO String?
07:03:08 <ski> , listE . tail . fmap varE =<< replicateM 2 (newName "gensym")
07:03:09 <lunabot>  ListE [VarE gensym_1]
07:03:16 <ski> mmorrow : ok
07:03:23 <mornfall> notweebl: You need to bind it. You can't "convert" it.
07:03:29 <mmorrow> notweebl: take the entire rest of your program that wants a String, and shove it inside that (IO String)
07:04:06 <mmorrow> f :: String -> o
07:04:08 <mmorrow> m :: IO String
07:04:24 <mmorrow> (return . f =<< m) :: IO o
07:04:25 <poucet> :t (>>+)
07:04:27 <lambdabot> Not in scope: `>>+'
07:04:27 <poucet> :t (>>=)
07:04:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:04:30 <mmorrow> (f <$> m) :: IO o
07:04:41 <poucet> m >>= f :: IO o
07:04:53 <mmorrow> (f :: String -> o)
07:04:57 <poucet> whoops, nm
07:04:59 <poucet> mmorrow: good point
07:05:01 <mmorrow> :)
07:05:20 <mornfall> And <$> lives in Control.Applicative
07:05:21 * poucet stops reading half-heartedly and goes back to work ;)
07:05:28 <ski> also `fmap' and `liftM'
07:05:40 <mornfall> ski: But <$> is so much nicer!
07:05:52 <ski> mornfall : i don't agree :)
07:06:10 <ski> (it's too symmetric a name)
07:06:56 <ski> (`$<' or `<$' would be ok)
07:07:02 <mornfall> Anyway, back to *my* question. What is the generic variant (with delimiter as a parameter) of lines/words?
07:07:11 <mornfall> I can't find it. : - (
07:07:24 <mornfall> @hoogle a -> [a] -> [[a]]
07:07:26 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:07:26 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:07:26 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:07:41 <mornfall> @hoogle [a] -> a -> [[a]]
07:07:43 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:07:43 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:07:43 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:07:54 <ski> @hoogle+
07:07:56 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:07:56 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:07:56 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
07:07:58 <ski> that's how you do it
07:08:24 <quicksilver> mornfall: there isn't one.
07:08:26 <mornfall> Do what?
07:08:27 <ski> (to look through the rest of the finds)
07:08:30 <mornfall> quicksilver: Why on earth? :)
07:08:38 <quicksilver> mornfall: because there are too many choices.
07:08:45 <mornfall> Of what?
07:08:48 <quicksilver> keep delimeter in items?
07:08:56 <quicksilver> keep delimeter as separate item on its own?
07:09:03 <quicksilver> coalesce multiple delimeters?
07:09:11 <quicksilver> take delimeter as a single element?
07:09:14 <quicksilver> list of elements?
07:09:17 <quicksilver> predicate on elements?
07:09:22 <quicksilver> predicate on lists of elements?
07:09:58 <mornfall> That's stupid.
07:10:02 <quicksilver> (if you observe them carefully you will find that words/lines make some different choices)
07:10:04 <zygoloid> mornfall: Data.List.Split.split is the generic variant :)
07:10:10 <quicksilver> I'm sorry for being stupid.
07:10:14 <quicksilver> I will not speak again in this channel.
07:10:22 <fasta> I doubt that.
07:10:37 <zygoloid> > (words " foo", lines "\nfoo")
07:10:38 <lambdabot>   (["foo"],["","foo"])
07:10:55 <zygoloid> lines is invertible, words is not.
07:10:59 <ski> <http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/src/Data-List-Split-Internals.html#SplitList>
07:11:00 * hackagebot upload: NoSlow 0.1 - Microbenchmarks for various array libraries (RomanLeshchinskiy)
07:11:14 <mmorrow> ooh, cool
07:11:21 <mmorrow> @hackage NoSlow
07:11:22 <lambdabot> http://hackage.haskell.org/package/NoSlow
07:12:06 <path[l]> > let f 0 0 = 1; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in f 1 1
07:12:09 <ski> (quicksilver : ignorance is not stupid :)
07:12:18 <lambdabot>   <no location info>: lexical error at character '\FS'
07:12:30 <fasta> zygoloid, lines is not invertible.
07:12:33 <mmorrow> path[l]: hah, you've got random unicode stray chars again
07:12:56 <fasta> zygoloid, or maybe I am confused with unlines.
07:13:03 <EvilTerran> > (lines . unlines) ["foo\nbar"]
07:13:05 <path[l]> > let f 0 i = i; f i 0 = i; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in f 1 1
07:13:05 <path[l]> gone now?
07:13:05 <lambdabot>   ["foo","bar"]
07:13:07 <lambdabot>   <no location info>: lexical error at character '\FS'
07:13:23 <path[l]> > let f 0 i = i; f i 0 = i; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in f 1 1
07:13:24 <fasta> > (lines . unlines) ["foo\nbar\n"]
07:13:25 <lambdabot>   2
07:13:26 <lambdabot>   ["foo","bar",""]
07:13:43 <zygoloid> fasta: unlines is not invertible, that's true.
07:13:46 <EvilTerran> fasta, if you require the inverse to be both a left-inverse and a right-inverse, then it's not invertible
07:14:14 <mornfall> mysplit d = map (map wibble) . words . map wibble
07:14:14 <mornfall>     where wibble ' ' = d
07:14:14 <mornfall>           wibble a = if a == d then ' ' else a
07:14:21 <fasta> zygoloid, ack.
07:14:24 <mornfall> What an awesome language this is... : - P
07:14:29 <EvilTerran> lines is left-invertible but not right-invertible
07:14:45 <zygoloid> lines is injective but not surjective
07:14:47 <mmorrow> , ""
07:14:48 <lunabot>  luna: lexical error in string/character literal at character '\FS'
07:14:54 <EvilTerran> lines is monic but not epic!
07:14:58 <mmorrow> what the frig char is this!!?
07:15:04 <mmorrow> it doesn't display in my font
07:15:05 <EvilTerran> > ord '\FS'
07:15:08 <lambdabot>   28
07:15:26 <zygoloid> file separator
07:15:30 <mmorrow> it's has a 28 as part of its utf8 encoding i think
07:15:35 <mmorrow> aha
07:15:53 <mmorrow> s/aha//
07:16:06 <mmorrow> , 0x1c
07:16:07 <lunabot>  28
07:16:08 <path[l]> > let f 0 i = i; f i 0 = i; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in (array ((0,0),(1000,1000)) [((p,q), (f p q)) | p <- [0..1000], q <- [0..1000]]) ! 5 1
07:16:10 <lambdabot>   <no location info>: lexical error at character '\GS'
07:16:11 <mmorrow> hmmm
07:16:17 <path[l]> argh
07:16:38 <EvilTerran> hm... perhaps lines and unlines form some kind of adjoint pair...
07:16:50 <path[l]> > let f 0 i = i; f i 0 = i; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in (array ((0,0),(1000,1000)) [((p,q), (f p q)) | p <- [0..1000], q <- [0..1000]]) ! (5, 1)
07:16:55 <lambdabot>   mueval-core: Time limit exceeded
07:17:13 <path[l]> hmm now thats wierd. if its lazy that shouldnt happen
07:17:37 <zygoloid> apparently FS was used by forms-mode terminals once upon a time
07:18:13 <mmorrow> path[l]: i think you're pulling on something that you're using to define the thing you're pulling on
07:18:13 <EvilTerran> path[l], the thunks in the array will all get allocated in the course of evaluating that, even if most of them aren't forced
07:18:38 <path[l]> EvilTerran: why?
07:18:42 <zygoloid> path[l]: umm, were you intending to memoize that function with the array?
07:18:46 <path[l]> yeah
07:18:51 <zygoloid> path[l]: f should at some point use the array if so!
07:18:57 <EvilTerran> path[l], because it's an array. the thunks are arranged in contiguous memory.
07:19:06 <path[l]> oh oops thanks zygoloid
07:19:06 <EvilTerran> otherwise you wouldn't get O(1) lookup
07:19:10 <path[l]> yeah that was an accident
07:19:18 <zygoloid> > > let f 0 i = i; f i 0 = i; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in f 5 1
07:19:20 <lambdabot>   <no location info>: parse error on input `>'
07:19:20 <path[l]> EvilTerran: ah
07:19:24 <zygoloid> > let f 0 i = i; f i 0 = i; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in f 5 1
07:19:26 <lambdabot>   3
07:19:27 <EvilTerran> so they have to be allocated all at once
07:19:54 <mmorrow> path[l]: (allocated /= evaluated)
07:19:59 <path[l]> right
07:20:16 <zygoloid> path[l]: oh, umm, it'll also have to build the first 5001 elements of the list before it can produce element (5, 1)
07:20:16 <haskell_n00b> mijn function is test = do x <- readFile "foo.txt" lines x return (). And I'm getting the next error couldn't  match expected type '[String]' against inferred type 'IO String'. Does any one know how to fix this?
07:20:33 <EvilTerran> an array kinda goes from "<thunk>" to "array (lo,hi) [<thunk>, <thunk> ...]" as the first step of forcing it
07:20:57 <path[l]> zygoloid: how come? f 5 1 is evaluatable without that. I understand the allocation bit
07:20:58 <mornfall> Hm. Is there a *simple* way to make a POSIX extended RE?
07:21:01 <path[l]> but why should it evaluate them
07:21:26 <zygoloid> path[l]: it needs to find a list element with key (5, 1)
07:21:37 <zygoloid> which means scanning through (and forcing the fst of) the first 5001 elements of the list
07:21:42 <EvilTerran> haskell_n00b, when you want to put more than one action on the same line in a do-block, you need to separate the actions with ";"
07:21:51 <haskell_n00b> :t putStrLn
07:21:52 <lambdabot> String -> IO ()
07:21:58 <EvilTerran> haskell_n00b, otherwise neither we nor the compiler will know what you mean :)
07:22:01 <path[l]> really? Why would it need to force the previous elements? I dont get it
07:22:01 <zygoloid> path[l]: i can't remember how it's specified; it might have to force the fst of every list element even
07:22:10 <zygoloid> path[l]: to check whether they are (5, 1)!
07:22:12 <haskell_n00b> :t name <- getLine
07:22:13 <lambdabot> <no location info>: not an expression: `name <- getLine'
07:22:24 <path[l]> ah
07:22:28 <EvilTerran> path[l], zygoloid, well, to check whether they should be in cell (! 5)
07:22:30 <zygoloid> path[l]: you might want to use listArray instead
07:22:33 <ski> > fixTabulate ((0,0),(5,5)) (\f ij -> case ij of (0,j) -> j; (i,0) -> i; (i,j) | abs (i - j) > 2 -> 3 | otherwise -> f (i-1,j) + f (j-1,i)) (5,1)
07:22:35 <lambdabot>   3
07:22:42 <EvilTerran> (which requires forcing the fst of the pair)
07:22:43 <path[l]> hmm
07:23:03 <path[l]> how will listArray help me though, isnt that just another constructor?
07:23:14 <ski> haskell_n00b : if `getLine :: IO String', then `name :: String' inside the `do'-block after that `name <- getLine' command
07:23:15 <mmorrow> data Closure = CON Tag [Ptr] [Word] | THUNK Thunk | IND Ptr | PAP Fun Arity [Ptr|Word] | Blackhole; data Thunk = AP Fun [Word] | THUNK Ptr
07:23:16 <mornfall> Ah, hmm, Text.Regex claims to be extended.
07:23:26 <mmorrow> is a model of heap objects
07:23:41 <zygoloid> path[l]: well, listArray would allow it to stop after 5001 elements rather than checking the whole list for duplicates
07:23:48 <EvilTerran> path[l], well, if the list is arranged the same way, then yeah, the array construction will still involve running over a huge initial prefix of the list
07:23:58 <haskell_n00b> this is my problem: mijn function is test = do x <- readFile "foo.txt" lines x return (). And I'm getting the next error couldn't  match expected type '[String]' against inferred type 'IO String'. Does any one know how to fix this?
07:24:15 <mmorrow> err, AP Fun [Word|Ptr]
07:24:18 <EvilTerran> path[l], another possibility, if you wanted to be sneaky, would be to keep using the "array" constructor, but arrange the list in a different order
07:24:26 <zygoloid> i find it a little shocking that array doesn't have a constructor :: (Array i e, Ix i) => (i, i) -> (i -> e) -> Array i e
07:24:28 <mmorrow> (abusing syntax)
07:24:34 <ski> haskell_n00b : what do you intend `lines x' to do ?
07:24:51 <ski> do you want to print the result of evaluating that expression ?
07:24:55 <EvilTerran> > [(i,n-i) | n <- [0..], i <- [0..n]] -- path[l], this order, for example
07:24:56 <haskell_n00b> to break the data from the file into a list of Strings
07:24:57 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
07:25:07 <zygoloid> EvilTerran: I don't think that's the problem
07:25:22 <zygoloid> EvilTerran: array docs say: "The array is undefined (i.e. bottom) if any index in the list is out of bounds."
07:25:32 <ski> haskell_n00b : and what to do with the list of strings then ?
07:25:34 <zygoloid> that measn forcing the fsts of the /whole/ list before any lookup
07:26:02 <ski> haskell_n00b : if you don't do anything with it, haskell will not actually compute the list
07:26:04 <EvilTerran> path[l], that'll give you the effect that, when you have small values in both indices, the relevant item will be near the start of the list
07:26:16 <EvilTerran> although, from what zygoloid says, that won't help
07:26:24 <haskell_n00b> I have number in the file and the function test get a number and i want to see if the number already exists in the file
07:26:26 <zygoloid> i don't know whether listArray has this problem too
07:26:40 <EvilTerran> > array ((),()) [((),())]
07:26:42 <lambdabot>   array ((),()) [((),())]
07:26:46 <EvilTerran> > array ((),()) (((),()) : undefined)
07:26:48 <lambdabot>   array * Exception: Prelude.undefined
07:26:57 <EvilTerran> > listArray ((),()) (((),()) : undefined)
07:26:59 <lambdabot>   array ((),()) [((),((),()))]
07:27:01 <mmorrow> data Box a = Box a
07:27:02 <zygoloid> > let f 0 i = i; f i 0 = i; f i j | abs (i -j) > 2 = 3 | otherwise = f (i-1) j + f (j-1) i in (listArray ((0,0),(1000,1000)) [f p q | p <- [0..1000], q <- [0..1000]]) ! (5, 1)
07:27:07 <lambdabot>   mueval-core: Time limit exceeded
07:27:11 <zygoloid> i guess so :(
07:27:12 <EvilTerran> > listArray ((),()) (() : undefined) -- even
07:27:14 <lambdabot>   array ((),()) [((),())]
07:27:33 <zygoloid> > listArray (1,5) undefined
07:27:35 <lambdabot>   array * Exception: Prelude.undefined
07:27:46 <ski>   test = do
07:27:48 <EvilTerran> > array (False,False) [(False,()), (True,())]
07:27:50 <lambdabot>   array * Exception: Error in array index
07:27:51 <ski>     x <- readFile "foo.txt"
07:27:52 <ski>     putStrLn (lines x)
07:27:56 <zygoloid> > listArray (1,5) (():undefined) ! 0
07:27:57 <lambdabot>   * Exception: Prelude.undefined
07:28:00 <ski> haskell_n00b : tried something like that ?
07:28:05 <zygoloid> right, listArray is broken in the same way
07:28:13 <haskell_n00b> I will try it now
07:28:15 <haskell_n00b> brb
07:28:15 <ski> haskell_n00b : actually, use `print', not `putStrLn'
07:28:23 <haskell_n00b> oke
07:28:25 <haskell_n00b> brb
07:28:25 <EvilTerran> zygoloid, although i note listArray stops reading when it's got enough elements
07:28:34 <ski> (or `mapM_ putStrLn')
07:28:55 <zygoloid> EvilTerran: enough to fill the array, not enough to resolve the indexing, sadly
07:29:04 <haskell_n00b> i will use print for this example
07:29:31 <EvilTerran> zygoloid, er, the indices are implicit in listArray; i'm not sure what you mean
07:29:40 <haskell_n00b> thnx ski for your help :D
07:29:46 <ski> yw
07:30:00 <mmorrow> zygoloid: what are you picturing "listArray (1,5) (():undefined) ! 0" to do instead?
07:30:08 <zygoloid> > listArray (1,5) (():undefined) ! 1
07:30:10 <lambdabot>   * Exception: Prelude.undefined
07:30:20 <zygoloid> ^^ EvilTerran that's what i mean. i'd want () not _|_ there
07:30:24 <mmorrow> implicitly do  ():undefined ==> (():replicate 4 undefined) ?
07:30:28 <zygoloid> mmorrow: nothing, i typoed the 0.
07:30:59 <mmorrow> zygoloid: so then the compiler catching the invalid array index statically?
07:31:13 <zygoloid> mmorrow: huh?
07:31:20 <zygoloid> mmorrow: i'd want "listArray (1,5) (():undefined) ! 1" to give ()
07:31:21 <EvilTerran> i guess that'll be because the process of assembling the Array (so it can then be indexed) requires identifying thunks to point each array cell at
07:31:39 <zygoloid> EvilTerran: right, but it should be /forcing/ those thunks which indexes the list, not /creating/ them
07:31:41 <mmorrow> zygoloid: ok, so then you're saying it should implicitly change
07:31:44 <ski> > listArray (1,5) (():replicate 4 undefined) ! 1
07:31:45 <lambdabot>   ()
07:31:50 <mmorrow> zygoloid: ():undefined ==> (():replicate 4 undefined)
07:32:10 <mmorrow> it can't just have null ptrs in the array slots
07:32:11 <zygoloid> mmorrow: if it makes you happy to think of it that way
07:32:21 <mmorrow> zygoloid: what else could it do?
07:32:30 <zygoloid> mmorrow: exactly as i described
07:32:47 <zygoloid> mmorrow: it should defer pulling elements out of the list until it needs to
07:32:49 <mmorrow> zygoloid: what should   listArray (1,5) (():undefined) ! 4
07:32:51 <mmorrow> give?
07:32:58 <zygoloid> mmorrow: obviously that should be _|_
07:33:04 <zygoloid> because it's forced the tail of the list
07:33:13 <mmorrow> ok, so then slot four in the list has to be a ptr to "undefined"
07:33:32 <zygoloid> mmorrow: no. there are other ways of getting _|_ than a ptr to undefined
07:33:33 <int-e> or some other sort of bottom
07:33:36 <mmorrow> it needs to allocate the whole array at once
07:33:39 <int-e> like a pattern match failure on (:)
07:33:45 <zygoloid> mmorrow: right. i've already said what it should do
07:34:10 <EvilTerran> mmorrow, listArray dom xs = array dom [(i, xs!!i) | i <- range dom] -- >:)
07:34:32 <mmorrow> zygoloid: but doing it like you said would either entail ==> ((): replicate 4 undefined), or having garbage in the ptr slots of the array until they're filled
07:34:37 <Lemmih> zygoloid: You can get that behavior with a simple wrapper, can't you?
07:34:39 <EvilTerran> (that being what it "should" do, not what it does)
07:34:42 <mmorrow> and the latter would break an invariant
07:35:10 <fasta> It doesn't have to allocate it all at once. It only has to allocate 1.0 + epsilon times what it had allocated before in terms of size.
07:35:34 <int-e> @type unfoldr (Just . (\ ~(x : xs) -> (x, xs))
07:35:36 <lambdabot> parse error (possibly incorrect indentation)
07:35:46 <mmorrow> fasta: well, it has to be contiguous memory, and if it doesn't reserve all the space at once, something else might take up some of the space it needs
07:36:02 <fasta> mmorrow, that doesn't matter in the way I describe it.
07:36:05 <mmorrow> (but i'm not sure how you mean
07:36:06 <EvilTerran> mmorrow, and then we lose O(1) indexing, right?
07:36:21 <mmorrow> fasta: yeah, what does (1.0 + epsilon) mean here?
07:36:38 <fasta> mmorrow, I am referring to a structure similar to what a Vector is in Java.
07:36:39 <mmorrow> EvilTerran: err, how do you mean?
07:36:59 <mmorrow> fasta: ah, hmm. i'm not familiar with how those are implemented
07:37:03 <EvilTerran> mmorrow, i mean, if we allocate the array as it's forced, and then end up having to move it because we've run out of space where we were working
07:37:21 <fasta> mmorrow, ok, or the chapter on amortized analysis from Introduction to Algorithms.
07:37:27 <mmorrow> EvilTerran: oh right, you'd have to continually be copying it to retain O(1) indexing
07:37:29 <mmorrow> or something
07:37:34 <int-e> [xs !! i | i <- [0..]] is essentially the conversion of  bottom  to  repeat bottom  that mmorrow is talking about.
07:37:35 <EvilTerran> you could probably sneak around it with amortised analysis
07:37:40 <fasta> mmorrow, just a basic "growable" vector.
07:37:48 <mmorrow> fasta: ah, ok
07:37:49 <Jafet> Buddy allocation!
07:38:11 <EvilTerran> int-e, yeah, that's what i was thinking of with my variation on listArray above
07:38:12 <fasta> With very nice amortized analysis, you can build memory management on top of diffarrays.
07:38:27 <int-e> @type unfoldr (Just . (\ ~(x : xs) -> (x, xs)))
07:38:29 <lambdabot> forall a. [a] -> [a]
07:38:35 <Jafet> Actually, there is a nontheoretically useless vector structure that doesn't need to be contiguous
07:38:42 <Jafet> It's from a 2001 paper, I think
07:39:04 <int-e> (that's doing the same conversion ... at the risk of stack overflows)
07:39:16 <fasta> Jafet, that sounds, interesting.
07:39:22 <int-e> > unfoldr (Just . (\ ~(x : xs) -> (x, xs))) [1..1000000] !! 999999
07:39:25 <lambdabot>   * Exception: stack overflow
07:39:35 <int-e> > [1..1000000] !! 999999
07:39:37 <lambdabot>   1000000
07:39:49 <Jafet> They proved that it wastes the minimum amount of space at any time while retaining O(1) indexing
07:40:13 <Jafet> For some large O that involves computing square roots. I suppose id solved that one.
07:40:26 <fasta> Jafet, do you have a link?
07:40:29 <int-e> that's the two-level structure that wastes O(sqrt(n)) entries at most, right?
07:40:49 <Jafet> I don't, but int-e might
07:41:08 <Jafet> I loved the word "superblocks"
07:41:29 <felix^^> hi!
07:41:44 <int-e> no, no link, sorry
07:42:28 <felix^^> i'm trying to convert a simple tree (data Tree = Leaf a | Tree(Tree a, Tree a)) into a tuple, but fail due to an infinite type error. what would be an idiomatic way to convert the tree?
07:43:08 <Jafet> Into a list, probably
07:44:33 <felix^^> Jafet: my approach fails for lists as well with the same problem
07:44:45 <int-e> fasta: but the idea is to store indices 4^k to 4^(k+1) in chunks of size 2^k - so for 4^k elements you'll have 2^(k+1) chunks of sizes 1 to 2^k. you can keep the index of chunks in a traditional growable array (doubling on growing / halfing sizes on shrinking). You can initialise array elements lazily.
07:44:50 <Jafet> What is your approach?
07:45:12 <Lemmih> felix^^: toList (Leaf a) = [a]; toList (Tree (l,r)) = toList l ++ toList r ?
07:45:18 <prof_nimnul> type List x = (x, List x) I guess
07:46:17 <int-e> fasta: the real trouble is finding the length (highest bit) of a bit vector in constant time, but it can be done (and for machine words, some CPUs have built-in operations for that task).
07:46:21 <fasta> int-e, my memory allocator wasted n space, but it seems a quite nice improvement, although small constant factors are not that important.
07:46:23 <felix^^> Lemmih: the approach flattens the structure though, right?
07:46:39 <mmorrow> int-e: bsr! (or is that one bsf?)
07:46:47 <path[l]> EvilTerran: am I better off using an intMap then?
07:46:49 <Lemmih> felix^^: Yes, that's the point of lists.
07:46:52 <fasta> I wonder how much space C memory allocators waste.
07:46:53 <int-e> mmorrow: r, "reverse", from the highest bit.
07:47:08 <Lemmih> felix^^: A list that isn't flat is called a tree.
07:47:26 <mmorrow> this is a nice malloc http://rtportal.upv.es/rtmalloc/
07:47:27 <Jafet> fasta, depends on how simplistic they are
07:47:28 <mmorrow> O(1) !!
07:47:46 <Jafet> .oO( O(1) in 640k? )
07:47:47 * mmorrow has a C implem of that, but it has a few bugs still 
07:47:49 <felix^^> Lemmih: yes, i understand that much -- which is why i wanted to have (possibly nested) tuples
07:48:03 <mmorrow> my realloc sometimes asplodes
07:48:59 <Lemmih> felix^^: That's also impossible. If you want a tree, you need a tree.
07:49:19 <fasta> mmorrow, have you looked at the details?
07:49:20 <mmorrow> int-e: ah nice
07:49:21 <felix^^> alright, thx
07:49:23 <Jafet> Nested HLists!
07:49:29 <Jafet> (Is that possible?)
07:49:35 <Lemmih> Jafet: Hlists == tuples.
07:49:41 <mmorrow> fasta: i've implemented it (or do you mean the benchmark details?)
07:49:48 <fasta> mmorrow, I mean Oleg also says his double linked lists are O(1), but of course they are not.
07:49:56 <fasta> mmorrow, what you wrote TLSF?
07:50:04 <Jafet> Lemmih, not sure if you can parametrize them recursively
07:50:05 <int-e> O(1) oranges?
07:50:11 <mmorrow> fasta: ah, this one really is O(1) i believe
07:50:24 <mmorrow> fasta: i implemented the algo from the paper
07:50:29 <dv_> hi
07:50:41 <dv_> can anybody tell me why this program runs on only one core? http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=ghc&id=3#log
07:50:42 <mmorrow> fasta: it's actually fairly concise
07:50:48 <fasta> mmorrow, the paper corresponding to TLSF?
07:50:52 <mmorrow> fasta: right
07:51:14 <fasta> mmorrow, the real-time aspects are quite interesting.
07:51:23 <mmorrow> fasta: yeah totally
07:51:29 <fasta> mmorrow, thanks for telling me something I didn't know yet :)
07:51:45 <mmorrow> fasta: there's this one interesting quote from the guy that wrote the malloc for firefox (iirc jemalloc)
07:51:50 <Lemmih> Jafet: Hlists are exactly the same as tuples.
07:52:02 <path[l]> is there a constructor for map thats truly lazy
07:52:06 <mmorrow> fasta: and that one in O(lg n) since it uses red-black trees, and he says something along the lines of:
07:52:29 <fasta> mmorrow, actually, it says that you have to know the size of the application data in advance...
07:52:39 <mmorrow> fasta: "i didn't appreciate enough the difference between O(lg n) and O(1)"
07:52:42 <zygoloid> mmorrow: sorry, got called away
07:52:56 <fasta> mmorrow, haha.
07:53:05 <int-e> dv_: well, only one of the threads can ever run.
07:53:20 <Lemmih> path[l]: Your question is very hard to understand.
07:53:22 <Jafet> The asymptotic functions are probably less relevant than the fact that those trees probably thrash the cache horribly
07:53:32 <mmorrow> fasta: err, you can mmap chunks of memory on-demand, then break up each "superblock" into a bunch of physically contiguous blocks
07:53:34 <Jafet> Lemmih, didn't know that
07:53:35 <dv_> int-e, arent threads supposed to run concurrently?
07:53:45 <dv_> oh wait
07:53:47 <dv_> a thread _ring_
07:53:59 <int-e> dv_: yes, but at any time 502 of them are waiting on MVars.
07:54:00 <mmorrow> fasta: at least, i'm doing something along those lines
07:54:13 <dv_> yeah, misunderstood the point of the test
07:54:19 <zygoloid> mmorrow: what i'm suggesting is: we have an array :: Array i e. thunk_i :: (e, [e]), thunk_i = case snd thunk_i-1 of (x:xs) -> (x, xs). array element i is initialized to fst thunk_i
07:54:23 <path[l]> I tried to memoize a function with an Array, and people pointed out that if I try to access the element at index 10,10 it has to find 9*10 elements before that because of the way arrays work. So Im looking for a better structure to memoize with
07:54:35 <mmorrow> fasta: but yeah, it's actually a really elegant algo/data-structure in my opinion
07:54:41 <mmorrow> fasta: and surprisingly simple
07:54:58 <prof_nimnul> dv_: ForkIO creates lightweight threads
07:55:00 <dv_> it does not test how well stuff can be parallelised, but how small the threading overhead (context switches..) is
07:55:14 <zygoloid> mmorrow: denotationally, you can think of it turning undefined into repeat undefined, if you like, but don't suggest that's how it has to happen operationally!
07:55:24 <Jafet> path[l], what is the structure and frequency of your input?
07:55:47 <mmorrow> zygoloid: all i'm saying is that if at any point you have a ptr slot in a heap object with an invalid ptr, you'll crash the GC
07:55:49 <int-e> dv_: you could inject more tokens into the ring. :)
07:56:00 <zygoloid> mmorrow: as i've demonstrated, that's not an issue.
07:56:16 <mmorrow> zygoloid: i don't understand your notation, could you elaborate?
07:56:16 <dv_> hmm
07:56:33 <zygoloid> mmorrow: which part do you want me to explain further?
07:56:43 <dv_> I wonder if shootout has a test that is supposed to be fully parallelized
07:56:47 * dv_ looks
07:56:47 <mmorrow> zygoloid: suppose i want a 1000 element array, and i'm intializing it with (():undefined)
07:57:02 <mmorrow> zygoloid: what do the 999 ptr slots contain intially?
07:57:06 <Lemmih> path[l]: What do you mean by 'find'?
07:57:14 <mmorrow> (the first one containing ())
07:57:21 <path[l]> well I repeatedly get pairs of strings for which I need to find the levenshtein distance. But I need the distance to be accurate only if its less than 3. So Im mostly going to be going from f m m backward down a band of the diagonal
07:57:28 <zygoloid> mmorrow: no, the first one doesn't contain (), it contains a thunk which produces ()
07:57:42 <mmorrow> zygoloid: sure, either way, s/()/a ptr to something valid/
07:58:01 <mmorrow> zygoloid: but what does, e.g., slot 843 contain?
07:58:05 <zygoloid> mmorrow: no, thunk which produces _|_ is a perfectly fine array element
07:58:15 <zygoloid> mmorrow: slot 843 contains fst thunk_843
07:58:47 <zygoloid> thunk_843 = case snd thunk_842 of (x:xs) -> (x, xs)
07:58:50 <mmorrow> zygoloid: ok, then we're saying the same thing, kind of
07:59:00 <path[l]> Lemmih: not sure to tell the truth =p. Im quite confused at the moment. But Im literally sacrificing chickens here to find ways to speed this up
07:59:06 <mmorrow> let's work out what the compiler would have to do to do that
07:59:17 <mmorrow> zygoloid: (i don't know the answer yet)
07:59:34 <mmorrow> input ==> listArray (0,999) (():undefined)
07:59:39 <zygoloid> mmorrow: well, i've already described how to implement it, i'm not sure what more you want :)
08:00:16 <mmorrow> zygoloid: so you want the compiler to generate code that will identify ptrs to undefined at runtime
08:00:31 <zygoloid> mmorrow: i have no idea what you mean by that
08:00:40 <mmorrow> zygoloid: listArray (0,999) (():undefined)
08:00:51 <zygoloid> nowhere in my description do i need to identify whether values are _|_
08:00:51 <mmorrow> zygoloid: what does the thunk in slot 843 point to?
08:01:01 <zygoloid> mmorrow: i can repeat myself if you like
08:01:17 <zygoloid> mmorrow: the thunk in slot 843 = fst thunk_843
08:01:18 <mmorrow> yes, i would :)
08:01:35 <mmorrow> what does (fst thunk_843) point to?
08:01:54 <mmorrow> data Thunk = THUNK Ptr
08:01:56 <zygoloid> fst thunk_843 is an expression
08:02:22 <mmorrow> right, so what does it evaluate to?
08:02:36 <zygoloid> well, thunk_843 is a pair, it evaluates to the fst of that pair
08:02:55 <mmorrow> what does the fst of that pair point to?
08:02:59 <zygoloid> 16:02 < zygoloid> thunk_843 = case snd thunk_842 of (x:xs) -> (x, xs)
08:03:45 <Lemmih> path[l]: You're unlikely to make it faster by stumbling around blind.
08:03:58 <zygoloid> the downside of what i'm suggesting has just become obvious to me: stack overflow :)
08:04:07 <mmorrow> it either points to (1) some value in the heap, (2) undefined (which is (1)), (3) a null ptr (or garbage)
08:04:19 <mmorrow> (3) will crash the GC
08:04:22 <zygoloid> mmorrow: i've already said what it is.
08:04:24 <mmorrow> (2) is my suggestion
08:04:26 <int-e> mmorrow: (4) a thunk.
08:04:35 <mmorrow> well, a thunk is (1)
08:04:46 <int-e> (that will evaluate to undefined. or a stack overflow.)
08:04:50 <int-e> ah
08:05:16 <mmorrow> zygoloid: i think we're talking about the same thing (essentially), just by different means
08:05:27 <int-e> case snd thunk_842 of (x:xs) -> (x, xs)  is a perfectly fine description of a thunk to me
08:05:31 <zygoloid> mmorrow: i have no idea what point you're trying to make :)
08:05:35 <ni|> happy thanksgiving
08:06:01 <int-e> (that's what will be evaluated when you force the thunk)
08:06:03 <mmorrow> zygoloid: the point i guess i'm trying to make is that (():undefined) *has* to implicitly become (():repeat undefined)
08:06:14 <mmorrow> (or s/repeat/replicate n/ or whatever)
08:06:19 <zygoloid> mmorrow: as i said, if that's how you want to think about it denotationally, that's fine
08:06:52 <int-e> mmorrow: but it doesn't. what /does/ have to happen is that  elems (listArray (...) undefined) will have that form.
08:07:34 <Adamant> get your Turkey Day on if applicable #haskell
08:07:43 <mmorrow> zygoloid: (what i'm *really* trying to do is figure out how one might implement your suggested behavior)
08:08:10 <zygoloid> mmorrow: well, here's a (rubbish) implementation. your list is xs. array element i = xs !! i
08:08:20 <mmorrow> zygoloid: because i agree that it is preferable, but i'm not positive yet if it's a valid transformation
08:08:21 <int-e> mmorrow: btw I think changing listArray that way is a bad idea, but the main reasons for that are performance reasons (both in terms of memory as in terms of execution time)
08:08:24 <BONUS> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13200 <--- mind = blown
08:08:34 <mmorrow> int-e: hmm
08:08:44 <zygoloid> int-e: i think the main problem is that i think the stack overflow is probably unavoidable
08:09:03 <int-e> zygoloid: the !! version doesn't have the stack overflow. it's just incredibly slow.
08:09:19 <int-e> zygoloid: (and leaks memory)
08:09:27 <int-e> well. "leak"
08:09:31 <mmorrow> int-e: yeah, you might be right (wrt this adding unacceptable overhead)
08:09:31 <zygoloid> int-e: heh, fair point :)
08:09:42 <BONUS> sup y'all
08:09:49 <zygoloid> fortunately i gave myself two "i think"s and a "probably"sworth of wiggle-room :)
08:09:49 <mmorrow> BONUS: sup!
08:09:51 <int-e> it keeps a list alive that should really be dead when the array has been constructed.
08:10:13 <zygoloid> int-e: the point of my implementation was to avoid that
08:10:17 <BONUS> just going through the edits keith made, soon i'll have some work for you!!! :)
08:10:30 <zygoloid> int-e: i think the only problem it has is (higher constant factor runtime plus) stack overflow
08:10:45 <mmorrow> BONUS: sweet :)
08:11:03 <zygoloid> i'm not certain the stack overflow is unavoidable, either.
08:12:08 <zygoloid> i would note that one could easily implement this in IO and provide a pure interface
08:12:39 <zygoloid> (you'd maintain a 'tail array' and the amount of the array you'd filled so far)
08:12:39 <zygoloid> 'tail list'
08:12:40 <int-e> Heh. Array initialisation is done in ST already.
08:12:57 <fasta> int-e, you can tell it not to.
08:13:08 <fasta> int-e, otherwise some algorithmic tricks would not work.
08:13:12 <int-e> But you'd have to catch errors that occur when traversing the spine /and/ communicate the last index that was successfully written to the error handling code.
08:13:42 <int-e> fasta: sorry, not to do what?
08:13:54 <fasta> int-e, you can tell it not to initialize the elements.
08:14:01 <zygoloid> it would undeniably fiddly, but it would require constant stack and no asymptotic overhead
08:14:23 <int-e> fasta: they will be initialised to undefined then.
08:14:42 <fasta> int-e, no, not even that.
08:14:48 <fasta> int-e, formally, yes. Not actually.
08:16:17 <fasta> int-e, it used to be possible in even the safe library functions to get  non-deterministic behaviour from ST. They fixed that and since I relied on it, they renamed the old behaviour to some unsafe function.
08:16:34 <fasta> I am not even sure whether it is possible to do that in Java.
08:16:42 <int-e> fasta: if you mean  unsafeNewArray_  - that only avoids initialisation for /unboxed/ arrays.
08:17:01 <fasta> int-e, oh, it must have been that one then.
08:17:02 <BONUS> ooh, this reminds me
08:17:17 <mmorrow> fasta: yeah, the GC would asplode if it ever saw an invalid ptr
08:17:17 <int-e> you can't do that for boxed arrays; the result would confuse the garbage collector to no end.
08:17:23 <fasta> Programming languages that really restrict you to do useful stuff are useless.
08:17:47 <mmorrow> GC's are a totaly pita, but sooo handay!
08:17:54 <fasta> int-e, well, probably there are also ways around that.
08:18:13 <fasta> int-e, it's just an uncommon scenario. A better GC might be able to handle it.
08:18:13 <BONUS> say i have a shuffle function or something forall a. [a] -> StdGen -> ([a], StdGen). if i want to use STUArrays internally to implement it, that type signature obviously won't do cause it doesn't work for all a anymore
08:18:18 <BONUS> so what does the type signature become then?
08:18:18 <mmorrow> fasta: you could add invalid ptr checks to ever ptr deref in the GC, but that (probably) would kill performance
08:18:28 <int-e> (I guess you could have boxed arrays with a highwater line or some sort of bitmap.)
08:18:37 <fasta> mmorrow, yes
08:18:58 <mmorrow> BONUS: you could just use a regular STArray
08:19:01 <zygoloid> int-e: yeah, all you need for the listArray case is a HWM, which would seem trivial to add to the GC
08:19:26 <BONUS> yeah, of course, but i was wondering, what would a correct type be for using STUArrays
08:19:44 <mmorrow> you could also ensure that all invalid ptrs are intialized to NULL, and catch SIGSEGV
08:19:46 <BONUS> i mean if there was an Unboxable typeclass or something, then it would be Unboxable a => ...
08:19:55 <mmorrow> (which is pretty ugly..)
08:20:16 <fasta> mmorrow, the point would be to not have the costs associated with the initialization.
08:20:31 <fasta> mmorrow, that is, to have a very sparse array.
08:20:31 <mmorrow> BONUS: oh. hmm, yeah maybe something like what uvector does
08:20:44 <int-e> zygoloid: I'm not sure it's so easy. Array access would have to check /and modify/ the highwater mark, in something that's supposed to be immutable. At the very least this needs some thought about thread synchronisation and the like.
08:20:51 <BONUS> ah. i'll czech out uvector
08:21:00 <mmorrow> fasta: well, the OS clears mmapped memory
08:21:27 <notweebl> quick question to see if what im thinking is correct: if I bind an IO String to something it will be a String, but when I return this string variable it will be the type it was (e.g. IO String) yes?
08:21:32 <fasta> mmorrow, why would it be mmapped?
08:21:34 <zygoloid> int-e: i don't see how it's harder than normal ST mutable arrays?
08:21:56 <zygoloid> int-e: yes, you'd need locking for HWM updates, but they should be rare in practice
08:21:57 <mmorrow> fasta: iirc this is also an issue with java gc's (thinking of this in particular: http://moonpatio.com/repos/gc-intf.txt)
08:22:02 <int-e> zygoloid: those are just atomic pointer updates, in something that is marked as mutable (and thus will be traversed by the GC)
08:22:04 <BONUS> notweebl: roughly, yes.
08:22:16 <mmorrow> fasta: in that they particularly address the problem of the best time to zero memory
08:22:21 <int-e> zygoloid: (the updates are atomic because they're machine word sized and aligned)
08:22:40 <mmorrow> fasta: i just mean mmap as an example of one way you might achieve zero'ed memory for free
08:22:57 <zygoloid> int-e: you can do the HWM updates with a simple cmpxchg since it's nondecreasing
08:23:07 <mmorrow> fasta: (but then you'd need to re-zero)
08:23:58 <fasta> mmorrow, I think zeroing memory is a waste of time.
08:24:22 <int-e> zygoloid: would you agree that that's still a lot of effort to go through just to make  arrayList (foo,bar) (():undefined) work?
08:24:25 <mmorrow> fasta: i'm just trying to think of a way the GC can identify (or recover from) dereferencing an invalid ptr
08:24:34 <Argue> hey BONUS i'm on chapter 8 :)
08:24:35 <fasta> mmorrow, it might help to debug stuff, but for an actual correct application it should never happen.
08:24:38 <mmorrow> fasta: so it doesn't have to add a check before every ptr deref
08:24:50 <BONUS> hey Argue :)
08:24:58 <mmorrow> fasta: (from the pov of the GC i'm thinking)
08:25:11 <fasta> mmorrow, in general, probably not.
08:25:12 <Argue> good work so far mang
08:25:24 <BONUS> thanks. working on finishing it
08:25:49 <Argue> well you'd better do it before the weekend or i might catch up and move on to somebody else's tutorial!
08:25:58 <prof_nimnul> mmorrow: Look at conservative GCs
08:26:04 <BONUS> oh no :O
08:26:15 <int-e> no conservative GCs please.
08:26:24 <zygoloid> int-e: yes, most certainly :) i think it'd be hugely impractical. it'd be much better to implement a funcArray :: (Ix i) => (i, i) -> (i -> e) -> Array i e
08:27:08 <mmorrow> prof_nimnul: yeah, we need an accurate GC, but do you mean some technique that's applicable to an accurate GC in this context?
08:27:12 <fasta> mmorrow, the GC has to do at the very least a comparison to in the most simplistic case a constant to a variable.
08:27:23 <zygoloid> int-e: that said, the HWM approach could decrease the asymptotic runtime of creating an N element array and using the first k indices from O(n) to O(k), and that might be worth it
08:27:34 <int-e> zygoloid: but that's what listArray (i, j) (map f (range (i, j)) does already
08:28:15 <int-e> (In fact I wouldn't be surprised if the intermediate list isn't even constructed.)
08:28:29 <zygoloid> int-e: no, it's not! it forces the whole list spine (up to the length of the array)
08:28:56 <zygoloid> i mean, denotationally, they're the same
08:30:04 <zygoloid> int-e: i guess i do actually want the HWM / 'is filled' bitmap thing, and as mmorrow says, that needs a GC extension
08:30:30 <zygoloid> (i guess i actually want O(1) array creation)
08:30:50 <int-e> right. any implementation of  funcArray  right now will create  n  thunks, n being the number of array elements.
08:31:18 * zygoloid nods
08:31:24 <int-e> and that's what the  listArray  version of it will do. (The list exists only temporarily.)
08:31:46 <mmorrow> also, related to this, is if the GC has some way to efficiently deal with null ptrs (efficiently := acceptably efficient), it could also handle context switches during non-allocating code
08:31:49 <zygoloid> indeed. you're right in that they're probably even operationally the same
08:31:49 <int-e> (And possibly gets fused away. I'm not sure.)
08:32:29 <mmorrow> s/during non-allocating code/between GC safe-points/
08:32:47 <mmorrow> which it can't do currently
08:32:48 <fasta> mmorrow, how are those related?
08:33:01 <mmorrow> fasta: because, say you have
08:33:23 <mmorrow> foo n = 0 : (something non-allocating and that takes a long long time)
08:33:48 <mmorrow> currently ghc can only context switch during an allocation at a safe-point
08:34:08 <mmorrow> but foo doesn't get to a safe point until the tail of that list gets computed
08:34:08 <int-e> oh. "null pointers" are actually possibly invalid pointers?
08:34:14 <mmorrow> int-e: right
08:34:26 <mmorrow> "null" := catch-all phrase for "anything invalid"
08:34:51 <int-e> yeah, I'm too much of a C programmer to agree with that meaning :)
08:35:13 <mmorrow> fasta: and additionally if foo isn't allocating, since the context-switch hook is during allocation, no other threads can run until foo is done
08:35:18 <int-e> but as long as we know what you mean that's fine.
08:35:48 <fasta> mmorrow, there is no fundamental reason for putting the context-switch hook there.
08:35:50 <mmorrow> i figure null-ptr without loss of generality, since you can always arrange that invalid ptr slots be zeroed
08:35:52 <Baughn> "trap: handleConnection: 7: hGetBuf: failed (Bad address)" <-- I was trying to debug what I thought was a race condition, but this (nested) error message..
08:36:03 <fasta> mmorrow, other than maybe some idea of "efficiency".
08:36:09 <Baughn> "hGetBuf: failed (Bad address)" means what, exactly? It sounds.. bad.
08:36:18 <mmorrow> fasta: right, but it's forced currently since the GC assumes the invariant that all ptrs are valid
08:36:19 <fasta> I think throwing correctness out of the window for efficiency is a mistake.
08:36:31 <fasta> In this case fairness.
08:36:47 <Baughn> @index hGetBuf
08:36:48 <lambdabot> System.IO
08:36:48 <int-e> fasta: the reason is that allocation is prepared to save the context state in a well-defined way already. normal code inbetween isn't.
08:36:57 <mmorrow> fasta: right. fairness is gone once you have a non-allocating stretch of code that takes a non-trivial amount of time
08:37:31 <mmorrow> fasta: and no one has a solution for this currently (i'd really like to think of one)
08:37:36 <fasta> There are instruction counters on x86. Why not just use those?
08:37:38 <int-e> (allocation, almost by definition, can be interrupted by a garbage collection. so it's essential that this works.)
08:38:14 <int-e> that still won't help with code that's just not allocating, happily running until it's forcefully killed.
08:38:41 <fasta> Hmm, never mind.
08:39:13 <fasta> Keeping track of much everything is doing costs a lot. There should be some hardware signals that do that.
08:39:35 <fasta> That is that you can register a computation as being allowed to run for X cycles and then switches to something else.
08:39:51 <quicksilver> that doesn't solve the safe point problem though
08:39:54 <int-e> and there are ... hmm ... three approaches, I guess. 1) add dummy allocations fequently enough. 2) add enough meta-information to code that it can be interrupted at any point and the GC still knows what is a pointer and what's not. 3) deal conservatively with possible pointers, as an approximation of 2)
08:39:57 <quicksilver> it's perfectly possible to pre-empt.
08:40:11 <quicksilver> the problem is that, by pre-empting, you risk structures being in an inconsistent stat
08:40:53 <int-e> you will have to deal with partially initialised heap nodes and with pointers that only live in registers but nowhere on the stack nor heap.
08:40:54 <mmorrow> which brings you too the GC dealing with null-ptrs (wlog) efficiently
08:40:58 <mmorrow> as a possible solution
08:41:10 <mmorrow> s/too/to/
08:43:31 <int-e> I'm not convinced that 3) is easier than 2)
08:44:33 <int-e> (And I guess if this were an easy problem, a solution would be implemented in ghc by now.)
08:45:30 <quicksilver> int-e: I'm not convinced 2 is possible
08:45:34 * hackagebot upload: lambdacube-engine 0.1.2 - 3D rendering engine entirely written in Haskell (CsabaHruska)
08:45:48 <quicksilver> int-e: or at least I fear it required huge contortions
08:46:15 <quicksilver> int-e: journaling things to temporary memory locations and then flipping with atomics
08:47:40 <mmorrow> i think the 3 dimensions of <something> degradation/increase/decrease that'll occur to solve this are
08:47:57 <mmorrow> (1) code size, (2) code running time, (3) GC running time
08:48:23 <mmorrow> (1) unroll all non-allocating loops N times, add a context switch check at the end of N
08:48:45 <mmorrow> (2) don't unroll, add a context switch check each loop (unacceptable)
08:48:55 <mmorrow> (3) have the GC deal with invalid/null ptrs
08:49:25 <mmorrow> i haven't thought about int-e's (2) though very much
08:49:40 <mmorrow> well, i guess that could be considered tied in with my (3)
08:49:48 <mmorrow> but it'd also increase code size
08:51:11 <quicksilver> (1) is the most obviously appealing to me
08:51:44 <mmorrow> quicksilver: yeah, that seems like it's the easier to do of (1) and (3) (i'm considering (2) a non-option)
08:52:18 <mmorrow> and it seems like it could be reasonable too
08:53:46 <int-e> quicksilver: the burden would be on the GC - say, use ptrace to find register contents; look up the program counter in some sort of map to find information about how much of the top of the heap is currently in flux, and which registers are heap pointers ... then create a thunk! that reconstructs the top of the heap, and restarts the thread's computation. Then start doing GC. It's all very fiddly, ugly, and uses an unknown amount of meta-information to...
08:53:53 <int-e> ...work, but I think it's possible in principle. I'm not sure it can be made practical without constraining the mutator's behaviour.
08:54:46 <int-e> (Of course, talk is cheap. And the devil is in the details.)
08:55:10 <mmorrow> int-e: do you know of any implemented system that does something remotely similar to this? it'd be interesting to see how they go about that
08:56:10 <int-e> In a very limited way, stack unwinding in C++ (for running destructors on exceptions) solves a similar problem.
08:56:52 <mmorrow> ahh, right. that's tied in with the eh_frame stuff that gcc generates on x86_64, right?
08:58:08 <mmorrow> (i just am familiar with that because it always takes up like 25%+ of the .s that gcc -S spits out)
08:58:08 <ACSpike[Home]> does "associate left" mean the parens go 2+(3+4)?
08:58:26 <h20xt> if I have something like, (take 5 [1..]) is that effectively unrolled by ghc?
08:58:30 <int-e> mmorrow: heh. the name is suggestive, but I don't know for sure.
08:58:53 <int-e> h20xt: no
08:59:08 <mmorrow> h20xt: it's definitely possible in principle though
08:59:19 <mmorrow> ACSpike[Home]: the opposite
08:59:42 <int-e> h20xt: as a rule, ghc doesn't unroll recursive functions. (possible keywords: ghc, inliner, "loop breaker"). You can do a lot with RULE pragmas though.
08:59:56 <h20xt> huh okay, so even static data has to be computed at run time?
09:00:50 <mmorrow> h20xt: that'd be similar to how gcc -O3 will do  "for(i=0; i<5; i++) acc += 1;" ==> "acc += 5"
09:00:53 <h20xt> ah okay, thanks for those keywords int-e
09:01:00 <mmorrow> h20xt: which unfortunately ghc doesn't currently do
09:01:13 <h20xt> mmorrow: i was thinking it might
09:01:21 <h20xt> i actually assumed it did
09:01:51 <h20xt> woah rewrite rules are neat
09:18:55 <int-e> @hoogle [a] -> [(a, [a])]
09:18:57 <lambdabot> Data.Char readLitChar :: ReadS Char
09:18:57 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
09:18:57 <lambdabot> Prelude reads :: Read a => ReadS a
09:20:35 <poucet> @pl \x -> fmap (x:) $ f (x+1) n (k - 1)
09:20:36 <lambdabot> liftM2 fmap (:) (flip (flip f n . (1 +)) (k - 1))
09:25:00 <poucet> @pl \x -> fmap (x:) $ f n (k-1) (x+1)
09:25:01 <lambdabot> liftM2 fmap (:) (f n (k - 1) . (1 +))
09:30:05 <theclaw> is there a function which does the same as [1..n]?
09:30:18 <poucet> @pl \n -> [1..n]
09:30:19 <lambdabot> enumFromTo 1
09:30:23 <theclaw> thanks
09:30:26 <poucet> > enumFromTo 1 10
09:30:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:30:44 <Polarina> Does there exist an disassembler for Haskell code?
09:30:49 <burp> :t enumFromTo
09:30:52 <lambdabot> forall a. (Enum a) => a -> a -> [a]
09:31:22 <poucet> Polarina: No, and I do not think that would be a very easy task.
09:32:57 <Polarina> poucet: I see.
09:33:41 <Daimonic> I want to express something like this, as short as possible: 4 Arguments: result only true if just one of the four arguments is true
09:34:17 <zygoloid> Daimonic: (horrible): f a b c d = (fromEnum a + fromEnum b + fromEnum c + fromEnum d) == 1
09:34:32 <Daimonic> from Enum, nice idea
09:34:52 <poucet> zygoloid: f a b c d = 1 == sum (map fromEnum [a,b,c,d])
09:34:52 <poucet> ?
09:34:53 <zygoloid> Daimonic: (nicer): f a b c d = sort [a, b, c, d] == [False, False, False, True]
09:36:18 <theclaw> is there an *easy* way to write a function which geenrates all faculties?
09:36:30 <zygoloid> faculties?
09:36:38 <theclaw> i.e., not something like "map fac [1..]"
09:36:49 <Cale> You mean factorials
09:37:01 <quicksilver> > scanl (*) [1..]
09:37:03 <lambdabot>   No instance for (GHC.Num.Num [t])
09:37:03 <lambdabot>    arising from a use of `GHC.Num.*' at <...
09:37:08 <quicksilver> > scanl1 (*) [1..]
09:37:10 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
09:37:16 <theclaw> Cale: eeks - thanks.
09:37:18 <Cale> > scanl (*) 1 [1..]
09:37:20 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
09:37:22 <quicksilver> I won.
09:37:36 <theclaw> Cale: I'm not a native speaker ;)
09:37:41 <theclaw> aah.. hmpf :[
09:37:47 <theclaw> and - without scanl?
09:37:55 <Cale> theclaw: sure...
09:38:05 <quicksilver> what is the arbitrary imposition of requirements about?
09:38:15 <quicksilver> what is the advantage of not using scanl1?
09:38:25 <Cale> theclaw: What am I allowed to use?
09:38:32 <quicksilver> (you can certainly go look up the source of scanl1 and write it out specialised to those definitions)
09:38:35 <quicksilver> Cale: S, K and I.
09:38:43 <Cale> haha
09:38:59 <Cale> I don't think it'll be possible in a typed lambda calculus like Haskell then ;)
09:39:25 <theclaw> Cale, quicksilver - I just didn't remember scanl and wondered whether there was an as-easy way without using scanl
09:39:59 <zygoloid> > fix((1:).zipWith(*)[1..])
09:40:01 <theclaw> but that's a bit stupid, I admit ;)
09:40:01 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
09:40:08 <Cale> > let facs n = n : map (*n) (facs (n+1)) in facs 1
09:40:10 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
09:40:24 <int-e> Cale: oh ow :)
09:40:34 <dons> bos: looks like uvector is doing ok.
09:40:35 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:40:36 <int-e> let's do something with cubic complexity next?
09:40:51 <zygoloid> quicksilver: I? when I were a lad we didn't get I. just S and K. and we were grateful for them...
09:40:51 <theclaw> hmm.
09:40:57 <dons> prob. not much work to have it be the fastest in all kernels
09:41:11 <Cale> int-e: hm?
09:41:39 <Cale> Is mine secretly quadratic?
09:41:45 <int-e> Cale: well now you multiply every list element by 1, 2, and so on, individually
09:41:53 <Cale> oh, yes, of course
09:43:32 <bos> dons: yeah
09:43:38 <dons> bos: might be easiest to just make a uvector project on code.haskell.org and start adding devs
09:43:42 <bos> dons: slower some places, faster others
09:43:43 <theclaw> thanks for helping :)
09:44:00 <dons> i'm not entirely sure why it beats vector
09:44:19 <bos> vector is now much more complicated than uvector
09:44:32 <dons> that might explain it then :)
09:44:47 <Cale> > let facs = 1 : zipWith (*) [1..] facs in facs
09:44:49 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
09:44:56 <tibbe> @seen gcollins
09:44:57 <lambdabot> Unknown command, try @list
09:45:33 <bos> dons: i think making a project would be good
09:45:40 <dons> prob. want     to import some of the vector tricks to uvector now as well.
09:45:45 <bos> dons: did you do anything with the vacuum patch i sent?
09:46:07 <dons> did i apply it?
09:46:12 <dons> i seem to think i did
09:46:20 <zygoloid> > let fac n = go n (sum, [1]); go :: Int -> (a -> Int, a) -> Int; go 0 (f, xs) = f xs; go n (f, xs) = go (n-1) (sum . map f, replicate n xs) in map fac [1..]
09:46:24 <zygoloid> impredicativity ftw
09:46:25 <lambdabot>   mueval-core: Time limit exceeded
09:46:47 <Cale> > unfoldr (\(m,n:ns) -> let k = n*m in Just (k,(k,ns))) (1,[1..])
09:46:47 <int-e> > scanl (fmap fmap fmap sum replicate) 1 [1..5]
09:46:49 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
09:46:50 <lambdabot>   [1,1,2,6,24,120]
09:47:10 <haskell_n00b> does anyone know why this doesn't work:                 checkCC :: String -> IO ()
09:47:10 <haskell_n00b> checkCC file = do putStr "Enter a credit card number: "
09:47:10 <haskell_n00b>                   x <- getLine
09:47:10 <haskell_n00b>                   let num = readCC x in
09:47:10 <haskell_n00b>                       if (validate num)
09:47:10 <haskell_n00b>                         then do print ("the number " ++ (showCC num) ++ " is valide and the type is " ++ (lookupIssuer file num))
09:47:13 <haskell_n00b>                                 --return "end"
09:47:15 <haskell_n00b>                             else do putStrLn "Invalide number"
09:47:17 <haskell_n00b>                                     return "end"
09:47:19 <haskell_n00b>                   --checkCC file
09:47:20 <bos> dons: did you do anything with the vacuum patch i sent?
09:47:21 <haskell_n00b>                   return ()
09:47:40 <Cale> haskell_n00b: use hpaste, don't paste things directly into the channel
09:47:42 <notweebl> lol frank
09:47:43 <notweebl> noob
09:47:46 <Cale> @where hpaste
09:47:47 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
09:47:53 <int-e> bos: shouldn't you send those to mmorrow?
09:47:56 <haskell_n00b> hpaste?
09:48:10 <tibbe> bos: is text at a point where you would like to have it included in the platform?
09:48:13 <notweebl> haskell_n00b: whats your real name :P
09:48:26 <bos> tibbe: almost!
09:48:38 <tibbe> bos: great! I'm curious. What's missing?
09:48:39 <zygoloid> > let fac n = go n (id, 1); go :: Int -> (a -> Int, a) -> Int; go 0 (f, xs) = f xs; go n (f, xs) = go (n-1) (sum . map f, replicate n xs) in map fac [1..5]
09:48:41 <lambdabot>   [1,2,6,24,120]
09:48:54 <haskell_n00b> notweebl why are you interested in my name?
09:49:39 <bos> tibbe: I/O support and some tuning for GHC 6.10
09:49:48 <bos> tibbe: it needs a benchmark suite, in essence
09:50:17 <zygoloid> int-e: my factorial function is O(n!). happy?
09:51:17 <tibbe> bos: good thing you have criterion then ;)
09:51:28 <tibbe> bos: what will the I/O support look like?
09:51:29 <Cale> > let fac = map length . permutations . enumFromTo 1 in map fac [1..]
09:51:31 <lambdabot>   [[1],[2,2],[3,3,3,3,3,3],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],...
09:51:32 <int-e> zygoloid: I guess
09:51:37 <Cale> er, oops :)
09:51:47 <bos> tibbe: uh, it'll be nice! it'll do I/O!
09:52:03 <tibbe> bos: heh
09:52:09 <Cale> > let fac = length . permutations . enumFromTo 1 in map fac [1..]
09:52:15 <lambdabot>   mueval-core: Time limit exceeded
09:52:20 <Cale> > let fac = length . permutations . enumFromTo 1 in take 6 $ map fac [1..]
09:52:23 <lambdabot>   [1,2,6,24,120,720]
09:52:23 <notweebl> haskell_n00b: well i don't need to know your name but ex 7 is a bitch
09:53:22 <dons> bos: i've requested a project be created.
09:54:29 <haskell_n00b> ex 7?
09:54:41 <haskell_n00b> oow indeed
09:54:49 <haskell_n00b> 8 also
09:54:53 <bos> thanks dons!
09:54:59 <int-e> > map Seq.length $ scanl (\l n -> mconcat $ replicate n l) (Seq.singleton ()) [1..]
09:55:01 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
09:55:10 <int-e> (what's the complexity now?)
09:55:40 <notweebl> any tips on 7 ? ^_^
09:55:42 <Botje> O(snowman)
09:56:06 <haskell_n00b> are you asking me for tips, I m here for help:P
09:56:23 <notweebl> if you're working on 8 you have 7 i presume :-)
09:56:38 <haskell_n00b> I still don't have it
10:02:27 <skorpan> help: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13232#a13232
10:04:39 <ski> haskell_n00b : you need to extract the result of `lookupIssuer file num', using `<-'
10:05:28 <haskell_n00b> tnx
10:07:47 <skorpan> what i
10:08:02 <skorpan> what i'm trying to do in the code i pasted is to get the level of indentation for each line in the read file
10:10:25 <skorpan> anyone? :(
10:11:50 <c_wraith> skorpan: I'll take a look, but I make no promises. :)
10:14:10 <skorpan> i'm thinking maybe "x `manyTill` y" consumes not only the found "x" but also the "y"
10:15:09 <int-e> yep it does
10:15:11 <c_wraith> yes, it does need to
10:15:48 <int-e> try  x `manyTill` lookAhead y
10:16:12 <c_wraith> hehe.  but the try was a suggestion, not the combinator. :)
10:16:14 <skorpan> that seems to work
10:16:17 <skorpan> yeah i got it :)
10:16:25 <int-e> c_wraith: hence the additional space :)
10:17:54 <skorpan> thanks
10:20:05 <mmorrow> int-e: (bos's patch was for vacuum-cairo)
10:20:12 <int-e> mmorrow: ah!
10:22:18 <notweebl> i have a list of strings containing only numbers and i want to sort them by length, so ["25","2","352"] will become ["352","25","2"]
10:22:40 <notweebl> that they're numbers doesn't really matter though i guess
10:22:41 <int-e> @type sortBy
10:22:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:22:45 <skorpan> > sortBy (comparing length) ["25", "2", "352"]
10:22:47 <lambdabot>   ["2","25","352"]
10:22:47 <int-e> @type comparing
10:22:49 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:23:06 <ben> > sortBy (compare `on` length) ["25", "2", "325"] -- I was going to say :(
10:23:08 <lambdabot>   ["2","25","325"]
10:23:17 <skorpan> ben: pwnd!!1
10:23:25 <bd_> :t on
10:23:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:23:37 <notweebl> @src sortBy
10:23:38 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:23:40 <lament> :t compare
10:23:42 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
10:23:54 <skorpan> @src on
10:23:56 <lambdabot> (*) `on` f = \x y -> f x * f y
10:23:58 <ben> @type (compare `on`)
10:24:00 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
10:24:27 <int-e> @type comparing
10:24:29 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:24:33 <int-e> funny how it swaps a and b :)
10:27:35 <mmorrow> heh, the description next to dtrace in "See also" made me lol http://en.wikipedia.org/wiki/Ltrace
10:27:49 <mmorrow> totally unbiased and informational..
10:28:27 <mmorrow> "Solaris(R) dtrace(R): The evolution of tracing tools!!@(TM)"
10:28:40 <ski> > compare :: Bool -> Bool -> Ordering
10:28:42 <lambdabot>   {True->{True->EQ;False->GT};False->{True->LT;False->EQ}}
10:29:24 <mmorrow> oh snap
10:29:30 <mmorrow> that's almost in graphviz format
10:30:22 <mmorrow> oh nice, it *is* in graphviz format coincidentally
10:30:26 <mmorrow> http://moonpatio.com/cgi-bin/graphedit.cgi?style=dot&query=digraph+dg+{%0D%0A%0D%0A%0D%0A{True-%3E{True-%3EEQ%3BFalse-%3EGT}%3BFalse-%3E{True-%3ELT%3BFalse-%3EEQ}}%0D%0A%0D%0A%0D%0A%0D%0A}%0D%0A
10:31:49 <mmorrow> > undefined :: Ordering -> Maybe Bool -> Either () ()
10:31:50 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
10:31:51 <lambdabot>    arising f...
10:32:05 <mmorrow> > undefined :: Maybe Bool -> Either () ()
10:32:07 <lambdabot>   * Exception: Prelude.undefined
10:32:21 <mmorrow> ah
10:32:27 <ski> > seq :: (Bool -> ()) -> Bool -> Bool
10:32:29 <lambdabot>   {{True->();False->()}->{True->True;False->False}}
10:33:34 <mmorrow> > [minBound..maxBound] :: [Maybe Bool]
10:33:36 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe GHC.Bool.Bool))
10:33:37 <lambdabot>    arising...
10:34:11 <mmorrow> > id :: Maybe Bool -> Maybe Bool
10:34:13 <lambdabot>   {Nothing->Nothing;Just True->Just True;Just False->Just False}
10:34:21 <mmorrow> gah
10:34:38 <mmorrow> i was thinking something different was going on for a second there
10:35:11 <mmorrow> > Just
10:35:13 <lambdabot>   {()->Just ()}
10:35:33 <mmorrow> > fix (In . Just)
10:35:35 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
10:35:36 <lambdabot>    arising from a u...
10:35:37 <ddarius> > unsafeCoerce
10:35:39 <lambdabot>   Not in scope: `unsafeCoerce'
10:35:42 <mmorrow> heh
10:36:10 <roconnor_> ddarius: {()->()}
10:36:17 <mmorrow> where are these instances from?
10:36:29 <ddarius> > fix vacuum
10:36:30 <mmorrow> smallcheck or another package that's using it?
10:36:36 <lambdabot>   Not in scope: `vacuum'
10:36:37 <mmorrow> ddarius: curse you!
10:36:41 * mmorrow kills the 
10:36:42 <ski> > (\x k -> k x) :: Bool -> (Bool -> ()) -> ()
10:36:43 <mmorrow> oh
10:36:45 <mmorrow> :)
10:36:55 <lambdabot>   {True->{{True->();False->()}->()};False->{{True->();False->()}->()}}
10:37:15 <ski> > (\x k -> k x) :: () -> (() -> ()) -> ()
10:37:17 <lambdabot>   {()->{{()->()}->()}}
10:38:00 <roconnor_> > (\x k -> k x)
10:38:01 <lambdabot>   {()->{{()->()}->()}}
10:38:33 <roconnor_> > flip ($)
10:38:35 <lambdabot>   {()->{{()->()}->()}}
10:38:41 <ski> > \f k -> f (\a _ -> k a) k
10:38:43 <lambdabot>   {{{()->{()->()}}->{{()->()}->()}}->{{()->()}->()}}
10:39:33 <mmorrow> , let go ('(':')':xs) = show "()" ++ go xs; go (x:xs) = x : go xs; go [] = [] in text (go "{{{()->{()->()}}->{{()->()}->()}}->{{()->()}->()}}")
10:39:34 <lunabot>  {{{"()"->{"()"->"()"}}->{{"()"->"()"}->"()"}}->{{"()"->"()"}->"()"}}
10:40:11 <mmorrow> @type \f k -> f (\a _ -> k a) k
10:40:13 <lambdabot> forall t t1 t2 t3. ((t -> t1 -> t2) -> (t -> t2) -> t3) -> (t -> t2) -> t3
10:40:57 <mmorrow> @@ @djinn @(run dropWhile (/='.') @(type \f k -> f (\a _ -> k a) k))
10:41:00 <lambdabot>  Cannot parse command
10:41:17 <roconnor_> @.
10:41:18 <lambdabot> Not enough arguments to @.
10:41:49 <mmorrow> @@ @run dropWhile (/='.') @type \f k -> f (\a _ -> k a) k
10:41:52 <lambdabot>   <no location info>: parse error on input `->'
10:42:08 <mmorrow> @@ @run dropWhile (/='.') (@type \f k -> f (\a _ -> k a) k)
10:42:11 <lambdabot>   <no location info>: parse error on input `->'
10:42:13 <mmorrow> bah
10:42:42 <mmorrow> well, this is the most interesting one http://moonpatio.com/cgi-bin/graphedit.cgi?style=dot&query=digraph+dg+{%0D%0A{True->{True->EQ%3BFalse->GT}%3BFalse->{True->LT%3BFalse->EQ}}%0D%0A}%0D%0A
10:44:35 <ski> @type runCont . callCC . (Cont .) . (. (runCont .))
10:44:37 <lambdabot> forall a r a1. ((a -> (a1 -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
10:48:43 <ski> would there be a problem with adopting `\{Left x -> Right x; Right y -> Left y}' for `\xy -> case xy of Left x -> Right x; Right y -> Left y' (for fresh `xy') ?
10:48:50 <notweebl> is it possible to use do and have where?
10:49:01 <skorpan> notweebl: why not?
10:49:08 <notweebl> just asking :D
10:49:11 <notweebl> i didn't know
10:49:17 <ski> notweebl : yes .. but possibly what you want is a `let'-command inside the `do'-expression
10:49:21 <skorpan> hehe.. "do" is just syntactic sugar for a bunch of >>= and >>
10:49:37 <notweebl> let x =
10:49:43 <notweebl> let x = "bla" in do?
10:49:51 <ddarius> notweebl: 'where' is attached to a function clause.
10:49:55 <ski> (since variables bound inside a `do'-expression isn't visible in an enclosing `where')
10:49:57 <skorpan> do { hello; what; let x = 4; something x }
10:50:02 <mmorrow> hah, this is interesting http://hackage.haskell.org/package/data-aviary-0.2.0
10:50:30 <roconnor_> mmorrow: that graph is so wrong
10:50:32 <roconnor_> :D
10:50:53 <mmorrow> roconnor_: it's the literal output, it has to be right! right?
10:51:00 <mmorrow> ;)
10:51:44 <iMonad> anybody implementing undirected neural net?
10:52:10 <musically_ut> Why is the sequence of IO operations different in this "main = do{ putStr "Name:"; name <- getLine; putStrLn name }" when I run it in ghci and when I first I compile it with ghc --make and then run it?
10:52:36 <musically_ut> When executed from the command line, the "Name:" is printed only after the name has been entered.
10:52:50 <ski> musically_ut : `hFlush stdout'
10:52:58 <ski> (or set `NoBuffering')
10:53:10 <musically_ut> ski, is that a compiler option?
10:53:15 <ski> no
10:53:19 <ski> @index hFlush
10:53:20 <lambdabot> System.IO
10:53:22 <ski> @index stdout
10:53:24 <lambdabot> System.IO
10:53:32 <roconnor_> @index NoBuffering
10:53:33 <lambdabot> System.IO
10:53:53 <ski> @type System.IO.hSetBuffering
10:53:55 <lambdabot> GHC.IOBase.Handle -> GHC.IOBase.BufferMode -> IO ()
10:54:21 <musically_ut> Excellent, thanks ski, roconnor_
10:54:44 <ski> so either set the buffering initially, or flush after each output not ending in a newline, that you'd like to be flushed immediately anyway
10:55:15 <ben> @src hPutStrLn
10:55:16 <lambdabot> hPutStrLn hndl str = do hPutStr  hndl str; hPutChar hndl '\n'
10:56:18 <musically_ut> ski, I'll unset the buffering initially.
10:56:31 <musically_ut> Any interesting reason why the behaviour is different in ghci and ghc, BTW?
10:57:08 <ben> ghci needs to mess with buffering to do the line editing
10:57:26 <musically_ut> Hmm, I guessed so.
10:57:32 <ski> i'm not quite sure. maybe one wants to be able to have more interaction (e.g. with `interact') in GHCi
10:57:48 <musically_ut> And is making stdout/stdin a special case of Buffer is against the philosophy of Haskell?
10:58:03 <ski> @type System.IO.stdout
10:58:06 <musically_ut> I would expect input from stdin to atleast flush the stdout beforehand.
10:58:15 <lambdabot> GHC.IOBase.Handle
10:58:19 <ben> It does not do that in C, so...
10:58:28 <Saizan_> NoBuffering for stdout/stdin is very slow for non-interactive programs
10:58:35 <ski> @index Buffer
10:58:36 <lambdabot> Graphics.X11.Xlib.Types, Graphics.X11.Xlib
10:58:41 <roconnor_> musically_ut: that doesn't work well for utility programs designed to be used with pipes
10:58:57 <musically_ut> Hmm.
10:59:45 <ben> roconnor_: Meh, an implementation could easily detect whether it is running on a pipe
11:00:07 <roconnor_> ben: oh?
11:00:45 <ben> err, using some unportable APIs I am not familiar with personally :)
11:01:55 <c_wraith> istty does it in C
11:02:11 <c_wraith> I'm assuming that's somewhere in haskell, too
11:02:11 <musically_ut> istty is portable?
11:02:29 <ben> Where is istty from?
11:02:35 <c_wraith> posix, I think
11:02:44 <ben> I do not seem to have a manpage for it :(
11:03:02 <mauke> isatty
11:03:03 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
11:03:03 <c_wraith> http://www.thinkage.ca/english/gcos/expl/c/lib/istty.html
11:03:24 <mauke> c_wraith: what is that?
11:03:47 <c_wraith> some bad thing that's confusing me :)
11:04:08 * mauke includes <fgsfds.h>
11:05:27 <ezyang> Happy thanksgiving!
11:05:55 <EnglishGent> hi ezyang :)
11:06:51 <ezyang> Hi EnglishGent!
11:09:46 <stoop> What XML parser do you recommend?
11:10:15 <stoop> It seems HaXml is pretty popular.
11:10:36 * Baughn bangs head on table
11:10:58 <stoop> Baughn, why?
11:11:10 * mauke bangs <head> on <table>
11:11:19 <Baughn> stoop: Well, I guess I could say "XML", but honestly it had nothing to do with you
11:11:31 <Baughn> HsOpenSSL is /broken/. Or OpenSSL is. Frankly, I suspect the former.
11:12:14 <stoop> Encryption is for newbies, anyways.
11:12:22 <Baughn> ..real men use hitmen?
11:13:02 <ezyang> no no, that's rubber hose cryptanalysis
11:14:00 <Baughn> In any case, sealBS/openBS sometimes mangle my data. Let's write a test, see what exactly is up...
11:14:43 * Baughn sighs. I've been at this the whole day. It never occurred to me to distrust the encryption library.
11:15:19 <poe> ?wiki HXT
11:15:20 <lambdabot> http://www.haskell.org/haskellwiki/HXT
11:15:38 <Baughn> stoop: Incidentally, what are you using XML for?
11:15:41 <poe> stoop this one is very nice.
11:16:04 <stoop> It seems xml is what I'll be going with, since it is really simple.
11:16:38 <stoop> Baughn, I am working on a GANTT chart using GNOME planner. Unfortunately, planner cannot generate data for weekly costs of a project. I am writing a program to generate this data.
11:17:02 <Baughn> stoop: And thus, you must read XML output by other programs. Got it.
11:17:14 <Baughn> stoop: For haskell<->haskell communication, I'm partial to Data.Binary.
11:18:59 <Twey> Baughn: Well, you did ask it for BS :þ
11:19:07 <h20xt> Baughn: i find Data.Binary to be *slow* have you had a different experience, for instance I was dumping out a targa file the other day, and it was much much slower than writing out a text ppm, any ideas why?
11:20:28 <Baughn> h20xt: Did you write the instances manually?
11:20:52 <Baughn> h20xt: In my experience, I get >1GB/s from Data.Binary quite easily, but it rather depends on what you do with it
11:21:19 <Baughn> In particular, anything to do with string manipulation or (un)packing bytestrings is deathly slow no matter /what/ the context is
11:21:50 <sshc> how do I call forM_, but pass an incrementing id?  that is, the first time forM_ or mapM_ calls the action, it also passes 0 (or 1), and then 1 (or 2), and then 2, 3, 4, etc.
11:22:11 <poe> ?type forM_
11:22:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
11:22:17 <ddarius> :t zipWithM_
11:22:20 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
11:22:23 <Lemmih> sshc: You can use [1..]
11:22:35 <poe> isn't [a] the numbers you're talking about?
11:23:06 <mauke> :t forM_ . zip [0 ..]
11:23:08 <lambdabot> forall (m :: * -> *) b t b1. (Monad m, Num t, Enum t) => [b1] -> ((t, b1) -> m b) -> m ()
11:23:21 <sshc> ah, zip
11:23:21 <ddarius> :t zipWithM [0..]
11:23:24 <lambdabot>     Couldn't match expected type `a -> b -> m c'
11:23:24 <lambdabot>            against inferred type `[a1]'
11:23:24 <lambdabot>     In the first argument of `zipWithM', namely `[0 .. ]'
11:23:25 <poe> :t (forM_ .) . zip [0..]
11:23:27 <lambdabot>     Couldn't match expected type `[a]' against inferred type `(t, b)'
11:23:28 <lambdabot>       Expected type: [b] -> [[a]]
11:23:28 <lambdabot>       Inferred type: [b] -> [(t, b)]
11:23:33 <ddarius> :t zipWithM_ ?f [0..]
11:23:35 <lambdabot> forall a b (m :: * -> *) c. (?f::a -> b -> m c, Num a, Enum a, Monad m) => [b] -> m ()
11:23:44 <sshc> > zip [0..] ["foo","barr","quux"]
11:23:47 <lambdabot>   [(0,"foo"),(1,"barr"),(2,"quux")]
11:24:02 <sshc> thanks, zip is what I was looking for!
11:24:46 <h20xt> Baughn: interesting, i wrote one of the instances, it was for DiffArray
11:27:47 <h20xt> oh and i had one for converting tuples of Doubles into [Word8]
11:28:33 <h20xt> hm i wrote a few test cases, and it seems really fast, i must have been doing something stupid, thanks for clearing that up for me
11:30:29 <Baughn> h20xt: Of course, you realize that /DiffArray/ is slow. :P
11:31:00 <Baughn> h20xt: There are a number of problems with Binary, though, mainly in its encoding of lists; they're not lazy enough, and it can force stack overflows.
11:32:00 * hackagebot upload: hssqlppp 0.0.10 - Sql parser and type checker (JakeWheat)
11:33:36 <skorpan> nice package name
11:34:56 <Baughn> No doubt developed by a snakeman
11:35:10 <Twey> Hehe
11:35:22 <Twey> With a stutter
11:35:25 <Twey> ‘Hssssssqlppppp!’
11:38:34 * ski . o O ( "bddbddb" )
11:38:52 <Baughn> ..running make -j on ghc... not good idea.... save yourself
11:41:54 <mmorrow> Baughn: make -j5 !
11:42:44 <ddarius> make -j2147483647
11:44:53 <mmorrow> ddarius: while [[ true ]]; do ghc -e 'fix(\o->mapM_ forkIO [system "make -j1773749374" >> o,system "make -j183743" >> o])'; done
11:45:03 <mmorrow> top
11:45:10 <EnglishGent> bddbddb looks very interesting
11:45:28 * EnglishGent has been wondering about developing someway of getting Haskell & Datalog to talk to each other
11:45:40 <mmorrow> EnglishGent: do it
11:45:51 <EnglishGent> I only managed (with some help from CosmicRay) to get it to talk to postgres recently though
11:46:15 <EnglishGent> I'm still learning Haskell mmorrow - but I'm taking tentative steps in that direction
11:46:30 <mauke> '[[ true ]]' better written as 'true'
11:46:34 <EnglishGent> I now have Haskell talking to Postgress, I have a search library I wrote
11:46:37 <mauke> 'true' better written as ':'
11:46:53 <EnglishGent> and a few other bits & pieces - but there's still quite a lot more I feel I need to understand properly first :)
11:47:17 <h20xt> Baughn: DiffArray is slow? hm slow for accessing right? not slow for changing?
11:47:29 <Twey> mauke: Where'd that : come from?
11:47:40 <mauke> the shell
11:47:41 <mmorrow> EnglishGent: here's a datalog AST i've got if it helps http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5105#a5105
11:48:02 <mmorrow> with pretty printer
11:48:03 <EnglishGent> oh - ty! :)
11:48:19 <mmorrow> mauke: oh nice
11:48:25 <mmorrow> EnglishGent: :)
11:48:30 <EnglishGent> oh I'm sure that will help! :D
11:51:49 <mmorrow> EnglishGent: http://en.wikipedia.org/wiki/Query_optimizer
11:52:49 <mmorrow> EnglishGent: (related, but for SQL) http://code.haskell.org/haskelldb/src/Database/HaskellDB/Optimize.hs
11:53:02 <mmorrow> haskelldb doesn't do joins though
11:53:27 <Baughn> h20xt: DiffArray is impure under the surface, and as I understand it, it uses entirely too many locks
11:53:56 <Baughn> h20xt: The idea is good, but locking is horribly slow. In practice, you can look up a medium-length Data.Map chain faster than you can grab a lock, so..
11:54:34 <mmorrow> EnglishGent: ah, found it (couldn't remember the name) http://en.wikipedia.org/wiki/Magic_Sets_algorithm
11:55:12 <Athas> Does GHC do anything special with signal masks when calling foreign functions?
11:55:18 * ski would like a copy of that paper ..
11:55:47 <Athas> I'm calling the nextEvent function from the X11 binding, and it seems to block at least SIGCHLD until the function returns.  I wonder if that's the fault of xlib or GHC.
11:56:26 <mmorrow> ski, EnglishGent: do you have acm access?
11:56:42 <uwe> /?
11:56:45 <mmx166mhz> How to use "digitChar"?
11:57:19 <mercury^> :t digitChar
11:57:21 <lambdabot> Not in scope: `digitChar'
11:57:28 <mmx166mhz> exactly
11:57:47 <mmx166mhz> show, ok
11:57:56 <mmx166mhz> digitChar is not neccsary
11:57:57 <mercury^> Well, which package is it part of?
11:58:01 <mauke> mmx166mhz: what do you mean, "exactly"?
11:58:08 <mmx166mhz> that it says out of scope
11:58:20 <mauke> please make more sense
11:58:36 <mercury^> I think he tries to use it but didn't import it.
11:58:46 <mauke> use what?
11:58:54 <mercury^> A function called digitChar.
11:58:58 <ski> mmorrow : hm, actually i might have from uni computers ..
11:58:58 <mauke> and what's that supposed to be?
11:59:00 * ski checks
11:59:54 <theclaw> @src scanl
11:59:56 <lambdabot> scanl f q ls = q : case ls of
11:59:56 <lambdabot>     []   -> []
11:59:56 <lambdabot>     x:xs -> scanl f (f q x) xs
12:01:10 <h20xt> Baughn: ah interesting, thank you, i should look into the implementation more
12:04:15 <mmorrow> ski: ping
12:06:41 <rasfar> mmorrw: I have access if you like.
12:06:50 <rasfar> mmorrow, even
12:07:31 <mmorrow> rasfar: oh thanks, i was actually making the same offer to them though. :)
12:08:02 <rasfar> heh, didn't read far enough back I guess.
12:08:22 <mmorrow> well, it was veiled.. ;)
12:09:07 <Baughn> @type fmap fmap fmap fmap fmap fmap
12:09:10 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
12:11:13 <pastah_rhymez> http://i.imgur.com/ng5aS.png
12:11:47 <Athas> That low for Java?
12:13:05 <h20xt> i need some pointers, I want to have an Image type that I can perform setPixel operations on, at this point it is just a newtype for Data.Array (Double, Double, Double) but doesn't that mean i will be copying a huge amount of memory every time I call setPixel?
12:13:13 <Twey> Athas: Yeah, we figure it's because Java programmers have their bosses looking over their shoulders
12:13:26 <Philonous> THe java guis abbreviate it to simply f to reduce strain
12:13:29 <Twey> Hahaha
12:13:34 <Lemmih> h20xt: It does.
12:13:49 <Twey> Don't you mean that they expand it to humanSexualIntercourse for clarity?
12:14:15 <Twey> h20xt: If it's large enough, it may be worthwhile to use one of the cleverer Arrays
12:14:29 <Twey> Exactly which one probably depends on your use case
12:14:53 <h20xt> i was kind of thinking of just buiding up a list of changes, and applying them when i write out the file instead
12:15:33 <Lemmih> h20xt: You don't need to read any of the pixels?
12:15:50 <Twey> h20xt: Sounds like STUArray might be good for you
12:16:13 <h20xt> Lemmih: No i don't, its just ouput for a raytracer
12:16:17 <Twey> Hm
12:16:20 <h20xt> Twey: thanks ill take a look
12:16:21 <ski> (EnglishGent : iirc, there was some other deductive database optimizations discussed in papers re Aditi ..)
12:17:14 <Lemmih> h20xt: Why not just generate a list of pixels, then?
12:17:45 <h20xt> Lemmih: hm, heh, good point
12:17:58 <Twey> Heh
12:18:28 <Twey> Might be nice to be a little less lazy, if there are going to be several passes
12:18:28 <h20xt> thanks you guys, STUArray looks helpful though, i didn't know about it
12:18:32 <jlouis> Philonous: of course the Java developers would have to call it properly: AbstractFacadeLegacyProfanityInterFace aflpi = new ConcreteFacadeLegacyProfanityInterface(); aflpi.f();
12:18:41 <kmc> the graph doesn't account for the fact that C++ programmers have invented their own profanity
12:18:47 <kmc> like "typename" and "sfinae"
12:19:01 <Twey> ‘sfinae’?
12:19:07 <EnglishGent> and Perl just *is* a profanity
12:19:12 <Twey> Heh
12:19:14 <Twey> Censored, though
12:19:15 <mauke> "a substitution error is fine too"
12:19:16 <kmc> because it looks like cartoon characters swearing
12:19:16 <EnglishGent> (well - it looks like line noise anyway) :)
12:19:18 <kmc> mauke, yes
12:19:22 <Twey> mauke: Hahaha
12:19:46 <EnglishGent> oh ski - sorry didnt see your earlier comment re: deductive databases
12:19:52 <mauke> (substitution failure is not an error, actually)
12:19:56 <EnglishGent> if you have references they'd be appreciated :)
12:20:12 <ski> Aditi isn't being developed anymore
12:20:21 <ski> <http://web.archive.org/web/20080727184353/http://www.cs.mu.oz.au/research/aditi/papers.html> has names of some papers
12:20:27 <EnglishGent> thanks :)
12:21:33 <ski> (i have a heap of papers related to that lying around, if you care for them ..)
12:25:19 <kmc> i think the people who think Perl looks like line noise should look at J and K
12:29:13 <Chile> kmc: the difference is J and K are understandable once you know them
12:29:28 <Chile> kmc: perl code just looks worse and worse the more perl you know.
12:30:16 --- mode: ChanServ set +o mauke
12:30:16 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]' by mauke
12:30:36 <mauke> Chile: I think you're just incompetent, because I can read Perl fine
12:30:45 <Cyneox> hi there! i need some help in adding a newline character to a [Char]. i have following code: http://haskell.pastebin.com/d2b4cc8eb. i need to add to every token a newline..how do i do that?!
12:31:17 --- mode: mauke set -o mauke
12:31:17 <mauke> Cyneox: map (++ "\n") . words
12:31:27 <kmc> > unlines . words $ "abc def   ghi"
12:31:27 <Chile> mauke: quite possibly :)
12:31:29 <lambdabot>   "abc\ndef\nghi\n"
12:31:54 <Cyneox> mauke: i'll try that out..
12:32:28 <theclaw> what does the "[]" in "instance Computation []" mean? (from YAHT)
12:32:39 <mauke> theclaw: the list type constructor
12:32:40 <theclaw> it doesn't mean "any list", does it?
12:32:43 <Axman6> it means that lists are an instance of it
12:32:47 <Axman6> yes
12:32:57 <mauke> > "foo" :: [] Char
12:32:59 <lambdabot>   "foo"
12:33:07 <Cyneox> mauke: could you give me some example?
12:33:12 <theclaw> that makes it clear, thanks!
12:33:25 <EnglishGent> theclaw - it means that the type of lists is a member of the Computation type class
12:33:28 <theclaw> so [] a == [a]
12:33:41 <mauke> Cyneox: no
12:34:06 <EnglishGent> i.e. that every for every operation defined by Computation - List provides an implementation
12:34:22 <EnglishGent> (single parameter type classes are a bit like Java interfaces in that regard) :)
12:34:32 <Cyneox> mauke: map (++ "\n") "test test" ... that wont work
12:34:33 <theclaw> mauke: you meant me?
12:34:44 <mauke> theclaw: no
12:34:47 <theclaw> okay
12:35:17 <Twey> @src sequence
12:35:18 <lambdabot> sequence []     = return []
12:35:19 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:35:19 <lambdabot> --OR
12:35:19 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:35:23 <mauke> > let withNewlines = map (++ "\n") . words  in  withNewLines "test test"
12:35:25 <lambdabot>   Not in scope: `withNewLines'
12:35:31 <mauke> > let withNewLines = map (++ "\n") . words  in  withNewLines "test test"
12:35:33 <lambdabot>   ["test\n","test\n"]
12:36:33 <Cyneox> thanks
12:37:56 <Cyneox> mauke: "\n" !=
12:38:00 <Cyneox> '\n'
12:38:13 <Cyneox> i need to add a newline character, not a "\n"
12:38:31 <Twey> Cyneox: A newline character, not a newline character?
12:38:43 <kmc> '\n' :: Char
12:38:46 <kmc> "\n" :: [Char]
12:38:53 <Cyneox> kmc: right..
12:38:53 <Twey> ['\n'] == "\n"
12:39:14 <Twey> If you append a Char to a String, you get a String.
12:39:47 <Cyneox> e.g.: ["b1","b2"] .. i need to add a '\n' to b1 and b2..
12:40:10 <wornof> (map (++ "\n")) == (map (++ ['\n']))
12:40:11 <Cyneox> is this equivalent to  ["b1\n","b2\n"] ?
12:40:14 <Twey> Yes
12:40:17 <Cyneox> ahh ok
12:41:37 <Cyneox> Main> print (head (map (++ "\n") (withNewLines "blabla blabl")))
12:41:37 <Cyneox> "blabla\n"
12:41:43 <Cyneox> is that correct?!
12:41:55 <Cyneox> why do i get no newline ?!
12:41:59 <Twey> er, yes
12:42:02 <mauke> you did
12:42:05 <Twey> You do get a newline
12:42:07 <Twey> It's right there
12:42:18 <Cyneox> but the output should be:
12:42:20 <Cyneox> blabla
12:42:25 <Cyneox> [newline]
12:42:26 <mauke> then use putStr, not print
12:42:49 <Cyneox> ok..now it works..
12:42:52 <Cyneox> thanks a lot!
12:42:53 <Twey> print is putStrLn . show, and show yields a debug-friendly representation
12:43:00 <Twey> Heh
12:43:19 <mmx166mhz> How to add elements on begin of a list, until the length is say 10.
12:43:26 <kmc> Twey, not always, i've defined some remarkably unfriendly Show instances ;)
12:43:34 <Twey> kmc: *Should* :þ
12:43:42 <mauke> show _ = "not today, little one"
12:43:47 <mmx166mhz> so "dsadas" becomes "aaaadsadas"
12:44:38 <kmc> > head . dropWhile ((< 10) . length) . iterate ('a':) "dsadas"
12:44:40 <lambdabot>   Couldn't match expected type `[a]'
12:44:40 <lambdabot>         against inferred type `GHC.Types...
12:45:03 <theclaw> EnglishGent: yup, thx :)
12:45:14 <kmc> > head . dropWhile ((< 10) . length) $ iterate ('a':) "dsadas"
12:45:17 <lambdabot>   "aaaadsadas"
12:45:32 <kmc> there's probably a more efficient way
12:48:42 <Twey> > let str = "dsadas" in replicate (10 - length str) 'a' ++ str
12:48:45 <lambdabot>   "aaaadsadas"
12:49:11 <kmc> > let f xs = iterate ('a':) xs !! (10 - length xs) in f "dsadas"
12:49:13 <lambdabot>   "aaaadsadas"
12:49:39 <kmc> > let f xs = iterate ('a':) xs !! (max 0 (10 - length xs)) in f "areallylongstringalreadymorethan10chars"
12:49:41 <lambdabot>   "areallylongstringalreadymorethan10chars"
12:51:21 <Twey> @hoogle Int -> [a] -> Maybe a
12:51:23 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:51:23 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:51:23 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
12:51:32 <Twey> That's not what I asked for…
12:53:55 <poe> :t find
12:53:57 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:55:08 <kmc> :t \n xs -> (!! n) $ map Just xs ++ repeat Nothing
12:55:11 <lambdabot> forall a. Int -> [a] -> Maybe a
12:55:14 <kmc> @pl \n xs -> (!! n) $ map Just xs ++ repeat Nothing
12:55:15 <lambdabot> (. ((++ repeat Nothing) . map Just)) . flip (!!)
12:55:21 <Saizan_> ?tyle findIndex
12:55:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
12:55:33 <kmc> tyle?
12:55:36 <poe> ?type elemIndex
12:55:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
12:58:00 <Twey> Saizan_, poe: Other way around, from index to element, like (!!) but safe
12:59:19 <poe> That screams for different datastructure usecase, or you'd write your own
12:59:32 <Saizan_> poe: no, why?
12:59:45 <Saizan_> well, i agree on "write your own"
13:00:08 <kmc> if you know that (!!) is O(n) it's still a perfectly fine way to write an O(n) "loop"
13:00:10 <Saizan_> Twey: i forgot which way around findIndex was :)
13:00:20 <Twey> Saizan_: Hint: it finds the index :þ
13:00:34 <poe> OK, it doesn't.
13:00:45 <Twey> kmc: *nod*
13:00:49 <fergie> I'm having trouble with Data.ByteString.Internal.ByteString
13:01:02 <fergie> Does anyone know any good tutorials?
13:01:30 <Twey> It's not the best way to do what I'm doing, but it's a silly tiny thing, so I don't particularly fancy reïmplementing the list monad on arrays ;)
13:02:00 <Fritsie> i have a question about haskell
13:02:03 <Twey> fergie: Doesn't the ‘internal’ mean you're not supposed to touch it?  :þ
13:02:24 <Twey> Fritsie: That makes a change from all the questions about Ancient Greek and applied gymnastics we get in here!
13:02:50 <Fritsie> instance Eq (Map a b) where
13:02:50 <Fritsie> 				 Empty == Empty = True
13:02:50 <Fritsie> 				 ((KS (a,b) m) == z) = (m == (getmap (remove z a)))
13:02:50 <Fritsie> 				 _ == _ = False
13:02:52 <poe> > let f n = (!! n) . map listToMaybe . tails in f 10 [1..10]
13:02:54 <lambdabot>   Nothing
13:03:08 <fergie> Twey: Probably :-) I'm trying to get information out of the Headers in happstack. The type is M.Map Data.ByteString.Internal.ByteString HeaderPair
13:03:08 <poe> sorry for the wrong comment before
13:03:35 <Twey> fergie: Oh, I think that's just the full type of the ByteString
13:03:48 <Twey> It's probably the same as the ByteString that's exposed elsewhere
13:03:51 <Twey> o/ medfly
13:04:00 <Twey> Fritsie: Pastebins are good, tabs are bad
13:04:00 <medfly> hi :)
13:04:16 <fergie> Twey: thanks. So I can use toString?
13:04:26 <Twey> fergie: I'd imagine so.
13:04:46 <Twey> (although for a Map you probably want to encode your key as a ByteString for the lookup, no?)
13:05:08 <fergie> Twey: so it would be better to use fromString on the key?
13:05:09 <Fritsie> http://pastebin.com/m4264b488
13:05:17 <Twey> fergie: *nod*
13:05:43 <fergie> Twey: I'll give that a try. Thanks for your help
13:06:15 <Twey> Fritsie: http://urchin.earth.li/~ian/style/haskell.html
13:06:19 <Twey> What's your question?
13:06:56 <fbru02> hey guys how can i install 6.12.1 in arch ?
13:07:11 <Fritsie> im getting an error on :
13:07:12 <Fritsie> ((KS (a,b) m) == z) = (m == (getmap (remove z a)))
13:07:20 <arjanb> Fritsie: remove outer parentheses on both side of the = in middle case
13:09:19 <Fritsie> im getting this error:
13:09:19 <Fritsie> Cannot justify constraints in instance member binding
13:13:34 <Fritsie> full code:
13:13:35 <Fritsie> http://pastebin.com/m96f7577
13:14:23 <Philonous> I wonder why there are so many newcomers. Are exams impending?
13:15:15 <medfly> that's what I heard
13:15:28 <Cyneox> iw there any way to convert a Int to a list of Int's : Int -> [Int] ?
13:15:44 <ezyang> Cyneox: repeat
13:15:49 <CalJohn> Cyneox: "convert"?
13:15:57 <ezyang> Philonous: Fun!
13:15:58 <CalJohn> @hoogle Integer -> [Integer]
13:16:00 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
13:16:00 <lambdabot> Prelude repeat :: a -> [a]
13:16:00 <lambdabot> Data.List repeat :: a -> [a]
13:16:26 <c_wraith> Cyneox: how long of a list?
13:16:38 <Cyneox> e.g. 1234 -> [1,2,3,4]
13:16:45 <ezyang> ah
13:16:48 <Twey> Heh
13:16:56 <kmc> > map read $ show 1234
13:16:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:16:58 <lambdabot>         against inferred ty...
13:17:03 <kmc> > map read $ show 1234 :: [Int]
13:17:05 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:17:05 <lambdabot>         against inferred ty...
13:17:08 <Twey> > map digitToInt $ show 1234
13:17:08 <kmc> > map (read . return) $ show 1234 :: [Int]
13:17:10 <lambdabot>   [1,2,3,4]
13:17:11 <lambdabot>   [1,2,3,4]
13:17:16 <ezyang> That's so dirty!
13:17:19 <Cyneox> :D
13:17:27 <Twey> > digitToInt <$> show 1234
13:17:29 <lambdabot>   [1,2,3,4]
13:17:33 <Twey> ezyang: Heh
13:17:37 <Twey> There are other ways
13:17:51 <Cyneox> hmm..btw: how do i use that in hugs?!
13:17:59 <ezyang> I'm trying to think of the most concise modulo/divide way to do it
13:18:07 <Twey> > reverse . map (`mod` 10) . takeWhile (/= 0) $ iterate (`div` 10) 1234
13:18:09 <lambdabot>   [1,2,3,4]
13:18:23 <ezyang> "there you go"
13:18:50 <Twey> Cyneox: Er, the same way, I imagine?
13:19:12 <Twey> I don't know if Hugs has digitToInt (nobody *really* uses Hugs, it's all a lie) but read at least should work.
13:19:27 <Cyneox> map (read . return) $ show 1234 :: [Int]
13:19:27 <Cyneox> [1,2,3,4]
13:19:30 <Cyneox> that worked
13:20:39 <pastah_rhymez> i'm doing some refactoring for my (StateT GameState m a)
13:21:13 <pastah_rhymez> the thing is that i can have many configurations in my game (tetris; block random generation, rotation rules etc.)
13:21:28 <arjanb> Fritsie: your remove function works on only maps with Eq constrain on the key, so you need:  instance Eq a => Eq (Map a b) where
13:21:37 <pastah_rhymez> so is adding a ReadarT Interface a good thing to add to my StateT?
13:22:17 <Botje> yes. they never change anyway
13:22:41 <pastah_rhymez> Botje: yeah, i thought so...
13:23:08 <pastah_rhymez> this is my first monad stack i'm writing aside from school work, so i'm a bit insecure :/
13:23:28 <Fritsie> arjanb: Omg it works, thanks a lot!
13:24:34 <Philonous> pastah_rhymez: If you use the functions from MonadReader and MonadState you can add more Transformers to your stack without ever having to change a single line of existing code
13:24:59 <pastah_rhymez> Philonous: yeah, GeneralizedNewtypeDeriving; i know :)
13:25:52 <jlouis> I wonder if there is a theorem stating that any logic encodable in LF admits weakening for any context...
13:26:17 <jlouis> nah, that won't hold
13:26:37 <jlouis> Thanks for being the rubberduck at the monitor #haskell!
13:28:22 <ben> No problem!
13:28:56 <jlouis> Weakening holds on everything utilizing a hypothetical judgement however
13:30:58 <mmorrow> quicksort is *not* an in-place algorithm http://en.wikipedia.org/wiki/In-place_algorithm
13:36:37 <Polarina> mmorrow: It can be.
13:38:13 <mmorrow> Polarina: it says that it can't
13:38:20 <mmorrow> s/can't/is not/
13:38:32 <mmorrow> (this is all i know)
13:39:07 <Polarina> mmorrow: It can be implemented to be in-place (not in Haskell though).
13:39:23 <mmorrow> the argument is that, even with the relaxed definition to O(ln n) space, quicksort still needs O((lg n)^2) space
13:39:54 <mmorrow> Polarina: you need to include the stack frames used for the divide-and-conquer in the total
13:40:15 <mmorrow> which makes it O((lg n)^2) (the article says)
13:40:29 <jlouis> It sounds about right
13:40:51 <mmorrow> yeah, seems right to me
13:43:49 <mmorrow> Polarina: ("in place algorithm" := uses O(lg n) additional space)
13:43:52 * hackagebot upload: bktrees 0.2.2 - A set data structure with approximate searching (JosefSvenningsson)
13:44:07 <mmorrow> err,
13:44:12 <ben> Stack space does not count, come on :V
13:44:13 <mmorrow> Polarina: ("in place algorithm" := uses <= O(lg n) additional space)
13:44:18 <mmorrow> ben: why not?
13:44:23 <ben> It is cheap!
13:44:26 <mmorrow> it's memory
13:44:54 * hackagebot upload: numeric-prelude 0.1.3 - An experimental alternative hierarchy of numeric type classes (HenningThielemann)
13:45:37 <tromp_> it's only O(log n) extra memory in RAM model
13:46:29 <jlouis> It's only an extra log n factor in O(n log n)
13:47:19 <mwc> Booo, it's a pain in the neck that ForeignPtr can't take a haskell function as a finalizer
13:47:34 <vic_> So... I installed http://hackage.haskell.org/package/permutation  using cabal but the example doesn't work.
13:47:37 <vic_> It gives me Enumerate.hs:5:18: Module `Data.List' does not export `permutations'
13:48:09 <jlouis> vic_: what version of Haskell?
13:48:33 <jlouis> vic_: I have Data.List.permutations here on 6.10.4 and the most recent Haskell Platform
13:48:51 <vic_> Glasgow Haskell Compiler, Version 6.8.2, for Haskell 98, stage 2 booted by GHC version 6.8.2. On Ubuntu
13:48:51 <vic_> Also, I installed cabal in my home folder
13:49:00 <vic_> jlouis: ah, ok
13:49:12 <vic_> I should install that haskell platform
13:49:19 <jlouis> vic_: I am fairly sure that is your problem
13:49:34 <vic_> Thanks
13:49:43 <pastah_rhymez> vic_: you should avoid the haskell platform on lolbuntu
13:49:52 <pastah_rhymez> i have heard it will make things explode
13:49:58 <notweebl> whats lolbuntu
13:50:03 <vic_> Heh
13:50:08 <vic_> A distro for lazy people
13:50:12 <pastah_rhymez> notweebl: the new flavour, do you know nothing?
13:50:23 <vic_> lolbubuntu
13:50:30 <notweebl> no sorry :(
13:50:32 <pastah_rhymez> vic_: no, just "lolbuntu"
13:50:46 <mmorrow> this is interesting http://en.wikipedia.org/wiki/VList
13:50:52 <jlouis> pastah_rhymez: well, it did not explode anything here
13:50:53 <pastah_rhymez> vic_: what version of ubuntu are you running?
13:50:55 <vic_> pastah_rhymez: what distro are you using?
13:51:13 <pastah_rhymez> vic_: ubuntu 9.10
13:51:23 <vic_> ok
13:51:29 <pastah_rhymez> but i installed ghc over the default one
13:51:44 <notweebl> this is what /ctcp versions are for people!
13:51:59 <notweebl> if you modify them ^^
13:52:03 <pastah_rhymez> vic_: http://www.haskell.org/ghc/download_ghc_6_10_4.html
13:52:18 <mwc> So if I need to run a haskell-written IO action as a finalizer for a foreignptr, I need to export it via the FFI then reimport it as a function pointer?
13:52:24 <vic_> pastah_rhymez: yeah, I;ve tried 6.10.4 on XP. Pretty neat
13:52:37 <pastah_rhymez> vic_: you should try it with REAL terminals :)
13:52:49 <notweebl> what's a real terminal?
13:52:51 <vic_> Indeed.
13:52:54 <notweebl> as in *nix shell?
13:53:02 <p4p800> Suppose I have a list with lists consisting of 3 elements. I want to reduce it to a list with the first element of all the lists . How to do this?
13:53:04 <pastah_rhymez> notweebl: as in non-"cmd"
13:53:17 <vic_> Any shell is better than cmd
13:53:27 <notweebl> yes :P
13:53:30 <pastah_rhymez> indeed
13:53:32 <vic_> Good thing the MS people dumped it for that flashy Monad
13:53:41 <pastah_rhymez> vic_: install that, and then you install all your libs you need through cabal
13:53:46 <notweebl> i cant work with cmd windows
13:53:50 <notweebl> how the fuck do i copy shit, seriously?
13:53:51 <notweebl> :"D
13:53:58 <vic_> pastah_rhymez: will do
13:54:01 <pastah_rhymez> notweebl: no clue
13:54:14 <vic_> notweebl: it can be done, but it's ugly :-P
13:54:29 <pastah_rhymez> vic_: i heard that the haskell platform on *nix should be avoided if you can, since it can mess things up :/
13:54:43 <pastah_rhymez> vic_: you didn't answer before; what os?
13:54:47 <vic_> Eh, I used Gentoo in the past
13:54:51 <notweebl> if i need to haskell @ university where there's windows pcs i just logon to my shell at home twice, once with ghci and other one with nano and just ctrl+o and :r
13:55:01 <vic_> pastah_rhymez: Ubuntu 9.04
13:55:12 <pastah_rhymez> vic_: oh, ok
13:55:22 <shambler> right click, "mark", enter/right click
13:55:24 <vic_> Yeah, it's a smooth version.
13:55:43 <vic_> pastah_rhymez: is 9.10 as buggy as people say?
13:55:52 <notweebl> i'm using 9.10 haven't noticed anything broken yet
13:56:11 <vic_> Your Experience May Vary
13:56:14 <notweebl> but i don't work on it much tbh, most of my work is on a debian 5 server
13:56:34 <pastah_rhymez> vic_: sound seemed awesome at the beginning, but now it crashes all the time
13:56:51 <pastah_rhymez> restarting firefox every 4-5 hours cause it got borked
13:57:11 <vic_> Meh, thought so. I'll wait for 10.04 or something
13:57:18 <vic_> The .04's seem more stable :-P
13:57:21 <pastah_rhymez> but they have all of pulseaudio in place; per app volume etc.
13:57:35 <vic_> Sound has always been a problem on Ubuntu for me
13:58:03 <vic_> I had an alias for /sbin/alsa force-reload.. jeez
13:58:24 <blackh> vic_: I have only had one problem in 9.10, with video being set by default to a bad hue setting, but I think that's specific to NVidia drivers
13:58:59 <blackh> vic_: I use it all day.  I've had no problems with sound.
13:59:02 <vic_> Well, I'm happy with my 9.04. And I usually do a clean upgrade once a year.
13:59:20 <vic_> My Gentoo experience was tiresome
13:59:37 <mmorrow> oh, ok that's semi-bootleg saying that ptrs need O(lg n) bits (re: quicksort). so that brings quicksort down to O(lg n) extra space, which satisfies the relaxed definition of "in place algo", but it's non-constant extra space nonetheless
14:00:29 <mmorrow> err, well actually it doesn't qualify quicksort as in-place i guess
14:00:40 <vic_> Ok, time to blow stuff up and install haskell platform
14:00:49 <mmorrow> since the point of the relaxed def was to take O(lg n)-sized ptrs into account
14:01:06 <mmorrow> so if ptrs are constant-sized, then "in-place" := O(1)
14:01:17 <mmorrow> (by their logic... right?)
14:01:45 <mmorrow> i think so
14:01:56 <fbru02> hey guys anyone knows how to install 6.12 in arch?
14:01:56 * mmorrow stands by his original claim
14:02:33 <vic_> What's 6.12?
14:02:46 <ben> vic_: the new, unreleased ghc version.
14:02:49 <ben> It is shiny and faster and more parallel
14:02:58 <vic_> Nice
14:03:20 <fbru02> uh i thought it was released ?
14:03:24 <ben> Oh? whoops
14:03:32 <vic_> God, and I'm still using 6.8.2... *facepalm*
14:03:45 <ben> http://www.haskell.org/ghc/ news does not seem to indicate so - there is a second release candidate, I believe, though
14:03:47 <fbru02> nice , funny !  :)
14:03:53 <vic_> Haskell users of the future, I salute you
14:04:06 <fbru02> well that's what i meant i guess
14:04:28 <vic_> Haskell 6.12 - Bleeding edge in a parallel way
14:04:47 <ben> Now with not one but N parallel, bleeding edges!
14:04:48 <fbru02> i mean why cant i use a rc?
14:04:50 <p4p800> Suppose I have a list with lists consisting of 3 elements. I want to reduce it to a list with the first element of all the lists . How to do this?
14:05:03 <ben> fbru02: Because a lot of packages do not work with it yet. Say, cabal, cabal-install, darcs.
14:05:16 <p4p800> so [[124,12],[1243,99]] becomes[124,1243]
14:05:29 <ben> Also it bumps a bunch of versions, so some packages will be configured not to work with it.
14:06:24 <pastah_rhymez> i want to be able to have m be IO every now and then for this structure
14:06:26 <pastah_rhymez> newtype Game m a = Game { runGame :: ReaderT Interface (StateT GameState m) a }
14:06:27 <fbru02> ben: so i guess threadscope and 6.12 will be released later this year?
14:06:28 <pastah_rhymez>     deriving (Monad, MonadReader Interface, MonadState GameState)
14:06:35 <vic_> How are the other Haskell implementations ... versus ghc?
14:06:57 <pastah_rhymez> vic_: jhc is fast
14:06:59 <Botje> ghc crushes them all
14:07:09 <vic_> How about hugs?
14:07:15 <ben> fbru02: I can only guess.
14:07:17 <pastah_rhymez> but doesn't support that much of the new stuff
14:07:24 <pastah_rhymez> vic_: hugs is for bootstrapping :)
14:07:29 <pastah_rhymez> since it's written in c
14:07:40 <vic_> Interesting
14:08:17 <pastah_rhymez> vic_: it USED to be that hugs gave better error messages than ghc, but that was 3~4 years ago
14:08:28 <fbru02> sorry if i sounded stupid asking about asking for an unreleased version but in my experience i like using untested software because i learn hitting my head with the rough edges
14:09:14 <vic_> fbru02: it's ok. You wanna learn stuff by seeing them break :-D
14:09:17 <fbru02> anyway i will be going for 6.10.4, anyone uses arch ? i just installed it , how should install the haskell platform ? download it and use cabal or us yaourt ?
14:09:29 <ezyang> vic_: That approach makes you hate software. :-)
14:09:38 <ben> fbru02: I am not saying that it is stupid, only mentioning that it is unreleased because it seemed relevant.
14:09:46 <ben> fbru02: I am trying ghc 6.12 myself, but I am also on gentoo
14:10:29 <vic_> The Arch Linux wiki is down for maintenance, try again later. Meh
14:10:47 <vic_> Anyway, this tut looks good http://sporkcode.wordpress.com/2009/07/11/installing-the-haskell-platform-in-ubuntu/
14:11:06 <fbru02> thanks guys
14:11:24 <pastah_rhymez> fbru02: you probably already have the platform then
14:11:40 <vic_> ben: Gentoo and ghc 6.12. What a combo! :-D
14:12:32 <fbru02> that's bleeding edge
14:12:52 <vic_> Gentoo is bleeding edge by definition
14:13:32 <vic_> fbru02: how's Arch Linux, btw? Heard good things about it
14:15:08 <fbru02> vlc_ just trying it out, main platform is osx for me,  but it seems that it has good support for haskell, many packages are installed with the usual package manager which calls cabal , havent used a package that needs c bindings yet
14:15:54 <vic_> I might try Arch in the near future
14:17:28 <vic_> After I break my Ubuntu, that is
14:21:34 <vic_> I feel dumb. It clearly says here http://hackage.haskell.org/package/permutation  Built on ghc-6.10 *sigh*
14:22:31 <ski> (just in case anyone cared <http://www.mdstud.chalmers.se/~md9slj/deductive/>)
14:24:17 <SamB_XP_> hmm ... does anyone have a clue how the japanese make the text regions of their hex editors line up correctly ?
14:27:59 <akappa> SamB_XP_, why the problem of lining up should be different for the ideograms?
14:28:24 <SamB_XP_> akappa: eh?
14:28:54 <p_l> SamB_XP_: they ignore it? :D
14:29:41 <SamB_XP_> p_l: what, and get character positions that have little or no relation to their addresses ?
14:29:42 <p_l> iirc hex editors tend not to interpret anything other than ASCII unless in some special moe
14:29:45 <p_l> *mode
14:30:01 <SamB_XP_> I ask because IDA just isn't too good at it
14:30:06 <p_l> SamB_XP_: you can highlight the areas correspondings to a complete codepoint
14:30:35 <SamB_XP_> also, what about if the character spans e.g. a 16-byte boundary?
14:30:39 <p_l> the question, what is a code point inside arbitrary binary data? Especially with different, variable length encoding
14:31:23 <SamB_XP_> hmm, true ...
14:31:54 <mwc> I think the only way it makes sense is if you enforce a fixed length encoding UCS-16, UCS-32, or bugger unicode and use some pre-unicode fixed length encoding (JIS?)
14:33:02 <SamB_XP_> mwc: the shift-JIS variant I'm using isn't exactly fixed length ...
14:33:14 <mwc> SamB_XP_: there are earlier JIS which are, IIRC
14:33:32 <mwc> shiftjis is kind of like UTF-8 for the earlier JIS encodings, IIRC
14:33:42 <SamB_XP_> oh
14:34:04 <SamB_XP_> hmm
14:34:07 <SamB_XP_> maybe!
14:34:11 <p_l> SamB_XP_: If you want to find strings, I recommend writing down fragments you see in the app, then generating byte sequences for that text in several encodings and searching for that
14:34:39 <SamB_XP_> p_l: oh, not really
14:35:15 <SamB_XP_> I was just wondering about it ;-)
14:35:23 <p_l> SamB_XP_: well, that's part of what I'd do while reverse-engineering for example a VN...
14:35:59 <notweebl> do { x <- getLine; putStrLn "Hello " ++ x; } doesn't work?
14:36:37 <SamB_XP_> p_l: well, the game I'm looking at right now is actually a fighter
14:37:09 <SamB_XP_> p_l: I don't even think I started looking at it for any particular reason ;-)
14:37:18 <wagle> nnooooOOOOooo!  (ghc not supported on snow leopard..)
14:37:21 * wagle melts
14:37:30 <fergie> does anyone know of anyone using Haskell with MongoDB?
14:37:33 <vic_> Wtf.
14:37:59 <vic_> wagle: yeah, but Snow Leopard supports that C with closures thing
14:38:04 <vic_> And some other cool stuff
14:38:44 <wagle> oh yeah, clang supports garbage collection, so that would be doable now
14:39:02 <p_l> clang != programming language
14:39:05 <slabanja> wagle: I use ghc on snow leopard (not the macports version though)
14:39:42 <wagle> and p != upper case letter
14:40:08 * wagle riposts the non-sequitar with another
14:40:09 <vic_> And Clang == there be purple dragons
14:40:42 <p_l> Clang is just a compiler, last time I checked, that happens to support ANSI C and Objective-C (and plans C++)
14:40:51 <Azstal> Is someone using clang known as a clanger?
14:41:01 <wagle> and where did i say clang was a programming language?
14:41:35 <SamB_XP_> >> 3 `shiftL` 3
14:41:38 <SamB_XP_> > 3 `shiftL` 3
14:41:40 <lambdabot>   Ambiguous type variable `t' in the constraint:
14:41:40 <lambdabot>    `Data.Bits.Bits t'
14:41:40 <lambdabot>      a...
14:41:45 <vic_> So these things don't actually work on Snow Leopard? http://arstechnica.com/apple/reviews/2009/08/mac-os-x-10-6.ars/10
14:41:48 <SamB_XP_> > 3 `shiftL` 3 :: Integer
14:41:48 <vic_> Darn.
14:41:50 <lambdabot>   24
14:46:52 <vic_> Yay. "Installation of ghc-6.10.4 was successful." But there is no beer in the fridge.
14:47:23 <mwc> I'd say it's more of a scotchworthy event anyways
14:47:48 <wagle> slabanja: ah..  thanks, i was forgetting about the non-macports thing
14:48:12 <vic_> mwc: indeed
14:48:50 <kmc> gentoo is great if you want to learn linux rather than use it
14:49:30 <vic_> kmc: s/Gentoo/LFS/
14:49:52 <vic_> Or Slackware, even better
14:49:54 <kmc> that ARS article badly confuses "dynamic language" with "functional language"
14:50:24 <mwc> kmc: ars technica?
14:50:29 <wagle> kmc the adventure is in building a distribution, say redhat 7.3 (ignore my showing my age), from source..
14:50:33 <vic_> Yeah, Ruby and Js have some functional features, but that's all
14:50:46 <kmc> well i guess it's time for this argument again
14:50:53 <wagle> presumably gentoo can be built from source
14:51:05 <vic_> Stage 1 installs anyone?
14:51:32 <kmc> vic_, i meant that it implies that closures are an exotic feature in the world of "compiled languages" (ignoring also the nonsensicalness of that term)
14:51:39 <mwc> well, there's a point of view from which objects are closures with multiple entry points, so closures are just degerate objects. I think this is how the Ocaml guys reconcile their object system with the rest of ML
14:52:13 <kmc> mwc, exactly, the problem is just that dys-functional languages like C++ lack convenient syntax for declaring those closure-object-types
14:52:14 <vic_> kmc: got it
14:53:00 <wagle> c's had trampolines for some time (dynamic extent, they are corrupt when the stack is unused or reused)
14:53:15 <vic_> How about "C has had closures forever" http://porkrind.org/missives/closures-in-straight-c
14:53:41 <kmc> vic_, i would say that Ruby and JS are functional languages.  because i'd rather talk about specific feature sets rather than fuzzy subjective ideas of how it's "supposed" to be used
14:54:15 * vic_ shrugs 
14:54:33 <vic_> It's a fuzzy border
14:54:34 <kmc> if you admit the latter mode of discussion, you get all kinds of crazy disagreement.  like people arguing that Lisp isn't functional because it's dynamically typed
14:56:34 <vic_> At least the border between declarative and imperative is clearly defined  http://www.faqs.org/docs/artu/graphics/taxonomy.png haha
14:57:23 <kmc> heh, i don't understand that at all
14:57:42 <vic_> Yeah, it kinda cracks me up
14:58:11 <kmc> maybe it makes sense for minilanguages
14:58:45 <vic_> or DSLs
14:59:04 <vic_> And that's another long talk
14:59:11 <mwc> @pl \x y z -> t >>= \w -> f w x y z
14:59:13 <lambdabot> ((((t >>=) .) . flip) .) . flip . flip f
14:59:19 <mwc> balls.
14:59:47 <vic_> Looks good
15:00:19 <kmc> it does amuse me that every nontrivial UNIX tool has its own, totally different DSL
15:01:21 <vic_> Unix is a great collection of DSLs
15:01:35 <vic_> You could consider C a DSl
15:01:48 <kmc> the domain is "writing UNIX"?
15:02:11 <bla123> writing the kernel
15:02:50 <bla123> iirc, they somewhere said they invented C so the would not have to write the kernel in assembly
15:03:49 <vic_> C is high-level assembly
15:05:06 <vic_> configure: error: The OpenGL C library is required
15:05:09 <vic_> Grrrreat
15:06:27 <blackdog> kmc: heh, yes. "is recursive -r or -R..."
15:06:52 <nvoorhies> saying that c is high level assembly always gives me the creeps
15:06:54 <blackdog> I suppose the real unix way would be to separate recursion out completely - always use find or something
15:07:17 <kmc> C is lacking a few crucial features that a real assembly language would have
15:07:26 <kmc> like interprocedural jumps / tail calls
15:07:37 <mwc> what's the story with throwing an exception from a finalizer on a foreign printer? Should we just swallow the error?
15:07:42 <Milo-> yikes
15:07:46 <nvoorhies> Yeah, and code can't be self-modifying, for instance
15:07:50 <Milo-> I just realised there is a bind operator in haskell's logo ._
15:08:02 <mwc> I mean, it's kind of like throwing an exception from a destructor in C++, but I'd expect it to work in Haskell ;)
15:08:08 <nvoorhies> in the text segment i mean, not just operands for branches
15:08:10 <Milo-> all I saw was the lambda -sign before
15:08:17 <SamB_XP_> mwc: you expect a lot!
15:10:37 <kmc> Milo-, it's basically the old amtrak logo ;P
15:11:01 <Milo-> amtrak is a train?
15:11:28 <vic_> This http://3.bp.blogspot.com/_t4oY2AFkthw/R1Gbr9DklbI/AAAAAAAABZ8/fJRMXDEwVEI/s1600-R/amtrak.jpg
15:11:29 <kmc> the USA's national passenger rail company
15:11:37 <kmc> yes, that's amtrak
15:11:50 <Milo-> yes, I can see how similiar it is to the haskell logo
15:12:20 <kmc> here you see an amtrak engine car trying to mate with a shipping container
15:12:29 <Milo-> yes
15:12:34 <Milo-> hyundai
15:12:41 <Milo-> hyundai shipping container
15:12:41 <olsner> the difference, as we can see in the picture, is that amtrak crashes (haskell doesn't do that)
15:13:13 <Milo-> well I'm glad you clarified that to me
15:13:16 <vic_> The moral: Amtrak should run on Haskell
15:13:33 <kmc> i do see a few similarities
15:13:43 <kmc> for example it's impossible to predict the runtime of an amtrak train
15:13:43 <mwc> shouldn't it stay on (ruby on) rails?
15:13:46 * mwc ducks
15:13:51 <vic_> Haha
15:14:23 <Milo-> :D
15:14:29 <nvoorhies> I'd be worried about the amount of rails laid down on the ground expanding to fill north america
15:14:33 <vic_> Ruby on Railroads. Very succesfull framework
15:14:45 <EnglishGent> we need Haskell on a Hovercraft
15:14:47 <EnglishGent> :)
15:14:48 <vic_> *successful
15:14:52 <mwc> Haskell in Helicopters?
15:14:56 <vic_> Haskell on Boats
15:15:01 <Milo-> haskell in haskell
15:15:05 <vic_> Haskell on Curry
15:15:10 <mwc> Haskell with Hyperdrives?
15:15:10 <EnglishGent> Haskell in Hyperspace
15:15:10 <Milo-> curry on soup
15:15:16 <vic_> Oh wait...
15:15:17 <EnglishGent> curry on programming!
15:15:23 <EnglishGent> (sorry - british pun)
15:15:24 <EnglishGent> :)
15:15:32 <vic_> Would you like some curry with that?
15:15:39 <nvoorhies> if they had a mutant ninja turtles tie in it could be haskell on a half shell
15:15:49 <Twey> I wanted them to call a Python framework ‘Snake on a Plane’
15:16:04 <Twey> Don't think they ever did, though
15:16:26 <vic_> So http://curry-language.org/ is based on Haskell. Funny
15:16:32 <EnglishGent> Samuel Jackson said he was too busy to be the maintainer :|
15:16:36 <Milo-> "I'm running 28 instances of python at the moment" says a man to another man in a plane.
15:16:43 <Twey> EnglishGent: Heh
15:17:04 <Milo-> hmm
15:17:06 <vic_> a universal programming language aiming to amalgamate the most important declarative programming paradigms, namely  functional programming and  logic programming. Oh lawd
15:17:17 <vic_> Lost me there
15:17:27 <gemie> could someone hint me how to print a [[Int]] list to the screen where I want each inner list to be on one line and the next on a new
15:17:27 <Milo-> why am I hearing "YMCA" in my head now that I opened the curry-language.org?
15:17:51 <vic_> Milo-: no idea. I'm currently listening to Reverend Horton Heat
15:17:57 <gemie> I am trying with map and putStr aswell as lines but can't get it to work properly
15:17:59 <EnglishGent> oh - I've looked (briefly) at curry
15:18:04 * vic_ spends the night in a box 
15:18:24 <EnglishGent> it's basically Haskell with some logic programming features
15:18:34 <kmc> gemie, make a function for printing a single line, then use mapM_ to apply it to every row
15:18:39 <kmc> :t mapM_
15:18:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:18:55 <Milo-> woah
15:19:09 <Milo-> a built-in function with really random looking name
15:19:26 <kmc> not built in
15:19:28 <kmc> @src mapM_
15:19:30 <lambdabot> mapM_ f as = sequence_ (map f as)
15:19:51 <vic_> configure: error: editline not found, so this package cannot be built... Installing haskell-platform-2009 is hard, let's go shopping
15:19:55 <kmc> there's a convention involved.  the 'M' denotes a monadic variant of a prelude list-ish function
15:20:08 <Milo-> oh comes with List-module?
15:20:09 <Twey> And _ means ‘ignore something’
15:20:10 <kmc> and the underscore denotes a variant of *that* which discards its results (and can be more efficient)
15:20:11 <kmc> so thus
15:20:13 <kmc> :t mapM
15:20:15 <gemie> kmc yeah thats cool. but isn't there any way to do it without a helper function? can't I just lines somehow since it takes a string and make it to a [String] and then I can print that string if Iam doing it IO
15:20:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:20:17 <kmc> :t map
15:20:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:20:34 <kmc> gemie, sure.  you can prepare the whole string and then putStr it once
15:20:43 <Twey> (which is faster, I think)
15:20:46 <Milo-> my ghci had Data.List already imported
15:20:48 <EnglishGent> deposit_fund  bank_account = do { bank_account <- (repeat ($)) ; return bank_account}
15:20:53 <kmc> Milo-, it's in Control.Monad
15:20:58 <Milo-> okay
15:21:34 <Twey> EnglishGent: depositFund bankAccount = repeat ($)
15:21:45 <Twey> (exactly equivalent, apart from the names being in Haskell style)
15:22:33 <kmc> > unlines $ map (unwords . map show) [[1,2],[3]]  -- gemie
15:22:33 <Twey> ‘x <- y; return x’ = ‘y’
15:22:35 <lambdabot>   "1 2\n3\n"
15:23:10 <toast-opt> question -- if i put a type annotation on a function, any type errors i get compiling are definitely in that function right?
15:23:17 <Twey> (do x <- y; return x === y >>= return, and z >>= return === z forall x, y, z)
15:23:32 <Twey> (it's one of the monad laws)
15:23:34 <Milo-> I still have no idea what I could write so I guess I'll stick re-solving the eulers in haskell that I have already solved in C or java.
15:23:40 <toast-opt> ex:   f :: (RealFloat rf) => Int -> Int -> rf ; f x y = ...
15:23:50 <kmc> toast-opt, so a file with two functions that have type signatures cannot have errors? ;)
15:24:10 <Twey> explode :: IO a -> ()
15:24:18 <kmc> Milo-, write a Scheme interpreter
15:24:22 <toast-opt> kmc, i mean, if i specify the type signatures, any errors are definitely in the function, not in another function calling it wrong
15:24:26 <toast-opt> right?
15:24:31 <gemie> kmc cool gonna test it out thanks =)
15:24:38 <kmc> @google write yourself a scheme
15:24:40 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:24:40 <lambdabot> Title: Write Yourself a Scheme in 48 Hours - Wikibooks, collection of open-content text ...
15:24:42 <Milo-> btw, is there a function that fetches a html-page in text format from the inert net?
15:24:45 <v_c> http://jonathan.tang.name/files/scheme_in_48/tutorial/firststeps.html  yeah
15:24:47 <v_c> Good tut
15:24:51 <Twey> toast-opt: So long as the types perfectly match the possible inputs, yes
15:25:20 <Twey> You can have a function from Int and explode on negative numbers, for example — that's no good: you want a Word
15:25:28 <Milo-> kmc v_c wha, what?
15:25:34 <Milo-> 8_O
15:25:36 <kmc> write a Scheme interpreter
15:25:38 <kmc> it's not hard
15:25:45 <Milo-> oh dear O_O
15:25:49 <kmc> you, too, can design and implement programming languages
15:25:56 <Twey> Heh
15:26:01 <kmc> any programmer who can't is seriously missing out
15:26:05 <tromp_> or a BF interpreter
15:26:05 <v_c> Scheme doesn't even have syntax
15:26:07 <Twey> *nod*
15:26:28 <kmc> you're in a bad position if you can't make your own tools
15:26:33 <v_c> But, still, writing a Haskell compiler == hard.
15:26:40 <mwc> Hmm, I'm beginning to think my entire approach to this problem is wrong. If one is wrapping a foreign library, then normally you use a foreign pointer to represet a resource obtained from that lib and to deallocate it when there are no more references to it. How does one handle errors in that cleanup stage? My original thought was to throw a Haskell exception
15:26:42 <kmc> yes
15:26:47 <kmc> in fact, writing a scheme compiler would be tricky
15:26:52 <Milo-> how will I be able to test that?
15:27:01 <Milo-> I don't know any scheme :c
15:27:05 <kmc> Milo-, learn scheme
15:27:06 <v_c> http://mitpress.mit.edu/sicp/
15:27:11 <kmc> it's a beautiful language
15:27:15 <v_c> You should read that too, it's a p good book
15:27:23 <v_c> SICP, a classic
15:27:32 <kmc> it's a sort of Platonic ideal of a programming language
15:27:34 <Milo-> been skimming sicp for a long time
15:27:47 <kmc> and very much oriented towards functional code, but also very different from Haskell
15:27:57 <Twey> mwc: Try a with* function
15:28:01 <kmc> and indeed from anything else that isn't Lisp-derived
15:28:20 <Milo-> but noone answered me, is there a function that calls a webserver and requests a page, and then returns the html-page in text-format (including tags and what-not)
15:28:26 <kmc> you can also test it by pasting stuff out of sicp
15:28:29 <Twey> (at a lower level, expose the foreign cleanup/free_* function)
15:28:41 <mwc> Twey: how do you mean?
15:28:45 <kmc> Milo-, did you look at the various http libraries on hackage?
15:28:49 * v_c wishes there was a Haskell book like SICP 
15:29:08 <kmc> there's HTTP and http-monad
15:29:13 <kmc> i can't recommend one
15:29:28 <lament> v_c: of course, the reason there's no such book is that Haskell wasn't designed specifically for writing such a book... :)
15:29:36 <v_c> Indeed
15:29:42 <Milo-> dev-haskell/http-4000.0.6 <- I have that installed
15:29:59 <v_c> There are some interesting Haskell books, but that's all
15:30:02 <Twey> mwc: withSomeForeignResource :: (SomeForeignResource -> IO a) -> IO a; withSomeForeignResource action = makeSomeForeignResource >>= action
15:30:17 <Twey> Er
15:30:21 <mwc> Twey: oh, that's not the problem
15:30:33 <lament> v_c: and if haskell were designed with this purpose in mind, it would be radically different...
15:30:40 <seanmcl> Is there a way to tell if there are unused exports from modules within the context of a larger program?
15:31:32 <Twey> mwc: withSomeForeignResource :: (SomeForeignResource -> IO a) -> IO a; withSomeForeignResource action = do resource <- makeSomeForeignResource; result <- action resource; cleanupSomeForeignResource resource; return result
15:31:36 <Twey> Like that
15:32:06 <Twey> Oh, errors?  Yes, an exception would be appropriate
15:32:07 <mwc> Hmm, that would make for an awkward use since these are long lived values
15:32:14 <Twey> mwc: Not at all
15:32:18 <h20xt> could someone explain this error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13241#a13241?
15:32:18 <kmc> but Scheme is mostly a cleanup of a subset of Common Lisp
15:32:21 <kmc> which was designed much earlier
15:32:31 <Twey> mwc: Long-lived values can be passed to functions, too
15:32:51 <mwc> The problem I have specifically is how to throw an exception from a finalizer attached to a ForeignPtr
15:32:52 <Twey> The with* pattern offers inversion of control, basically
15:33:09 <kmc> h20xt, x and y come from your ctor "Integer" so are fixed to be Int.  but your function "op" takes only values of some unknown type a
15:33:16 <Twey> Ah, I see
15:33:22 <mwc> I wrote a haskell function to do the cleanup and check return codes from the wrapped C function, then exported it to C, then imported it back as a FunPtr (Ptr Resource -> IO ()) and then added that as a finalizer
15:33:35 <h20xt> kmc: im not seeing that is an issue
15:33:37 <mwc> the fact that I had to do that much work makes me think I'm using the API entirely incorrectly
15:33:43 <kmc> h20xt, what if i pass (++) as "op"
15:33:46 <Twey> *headscratch*
15:33:50 <kmc> how are you going to apply (++) to two Ints
15:34:09 <toast-opt> hmm, can't figure out the type errors.  Curious question: is it generally bad style to write functions over 'Double' over '(RealFloat rf) => rf' instead?
15:34:12 <Twey> Why did you export it through C just to give it back to Haskell?
15:34:13 <h20xt> kmc: so i need a typeclass on a?
15:34:13 <kmc> h20xt, these types are distinct:    forall a. a -> Int    (forall a. a) -> Int
15:34:15 <mwc> -- Ugly hack to get a FunPtr to freePtrAndHandleErr so we can use it as a
15:34:15 <mwc> -- finalizer.
15:34:15 <mwc> foreign export ccall freePtrAndHandleErr :: Ptr MPIType -> IO ()
15:34:15 <mwc> foreign import ccall "System/MPI/Type_stub.h &freePtrAndHandleErr" freePtrAndHandleErr_p :: FunPtr (Ptr MPIType -> IO ())
15:34:20 <mwc> doesn't look right to me :)
15:34:43 <kmc> schemeBinaryOp :: (forall a. (Num a) => a -> a -> a) -> (SchemeNumber -> SchemeNumber -> SchemeNumber)
15:34:46 <kmc> h20xt, try that type ^^^
15:34:54 <kmc> you'll probably need to turn on some ghc extensions
15:34:55 <mwc> and then I get an error at run time because I'm not allowed to call back to haskell from a C finalizer
15:34:55 <Twey> Nor to me
15:35:12 <kmc> RankNTypes
15:35:21 <Baughn> ..I just had a haskell program randomly segfault
15:35:24 <Twey> Ych, need bed… maybe someone smarter can help you, though :þ
15:35:47 * Baughn sighs. HsOpenSSL again, I bet.
15:36:10 <h20xt> kmc: thanks kmc, works like a charm
15:36:37 <kmc> h20xt, by moving the quantifier inside, you specify that op has to work for *all* Num types, not just for a particular type of the caller's choosing
15:37:08 <kmc> otherwise the implicit "forall" applies to schemeBinaryOp as a whole, and means "whatever op you give me, i can deal with it"
15:37:27 <h20xt> kmc: ah, i see, okay, that makes perfect sense, thank you very much
15:37:33 <kmc> :) no problem
15:38:55 <Baughn> " segfault at c93be0 ip 0000000000c93be0" <-- ..okay, that's MainCapability. Why would it be jumping /there/? o_O
15:40:43 <toast-opt> type MyNum = Double creates an alias for the Double number type.  Is there a way to create a alias for a typeclass, like RealFloat?
15:41:33 <v_c> This is one serious ticket http://trac.haskell.org/haskell-platform/ticket/84
15:41:36 * v_c gives up 
15:41:55 <Twey> Oh, something: how does the new Unicode support work in GHC, and in which version was it added?  I saw a document about it once, but I can't find it again
15:42:13 <ben> 6.12, I believe
15:42:18 <Twey> Oh wait
15:42:20 <ben> http://ghcmutterings.wordpress.com/2009/09/30/heads-up-what-you-need-to-know-about-unicode-io-in-ghc-6-12-1/ maybe?
15:42:23 <Twey> Found it — http://ghcmutterings.wordpress.com/2009/09/30/heads-up-what-you-need-to-know-about-unicode-io-in-ghc-6-12-1/
15:42:26 <Twey> Yeah :-D
15:42:28 <Twey> Thanks
15:42:46 <ben> :)
15:43:49 <kmc> toast-opt, not exactly.  there are some proposals for it
15:44:11 <jlouis> mmorrow: The SSA property of LLVM's IL is really exploitable when representing the IL as a functional program. It is interesting, now that I wrote up the description of the semantics, in how many places a beta-substitution is enough
15:44:19 <toast-opt> k.  but in general i should prefer RealFloat to Double?
15:44:32 <jlouis> and with the Twelf representation, beta-substitution is essentially for free
15:44:36 <aavogt> @instances-importing Double
15:44:37 <lambdabot> Couldn't find class `Double'. Try @instances-importing
15:44:38 <kmc> what do you mean?  they're different sorts of things
15:44:42 <aavogt> @instances-importing RealFrac
15:44:43 <lambdabot> Double, Float
15:45:21 <kmc> @src RealFloat
15:45:23 <lambdabot> Source not found. My brain just exploded
15:45:24 <toast-opt> kmc, if i'm writing numeric code, should I prefer making f :: (RealFloat rf) => rf -> rf, or should i prefer f :: Double -> Double
15:45:25 <toast-opt> ?
15:45:47 <aavogt> > sqrt 2 :: CReal
15:45:47 <lambdabot>   1.4142135623730950488016887242096980785697
15:46:00 <toast-opt> wait, RealFrac?
15:46:00 <kmc> @hoogle CReal
15:46:02 <lambdabot> No results found
15:46:04 <toast-opt> crap, is that my problem?
15:46:44 <kmc> class (RealFrac a, Floating a) => RealFloat a
15:47:02 <toast-opt> oh, ok, so both are type classes
15:47:09 <kmc> yeah
15:47:21 <kmc> Double -> Double might be faster
15:47:27 <toast-opt> faster?
15:47:28 <kmc> but ghc will often specialize anyway
15:47:31 <kmc> faster code
15:47:39 <toast-opt> gotcha
15:47:50 <toast-opt> less dynamic dispatch?  easier for the compiler to inline?
15:47:50 <v_c> * Installation completed successfully. Awesome. I can has Haskell Platform on lolbuntu
15:47:59 <derenrich> anyone here making pumpkin soup today? i'm considering adding peanut butter to mine and i'm looking for advice
15:48:26 <kmc> yeah, you'd avoid passing the dictionary around
15:48:28 <v_c> So, yeah, installing Haskell platform can be a handfull
15:48:45 <v_c> *handful
15:48:51 <kmc> what you lose from fixing the type to Double depends on what you're doing
15:49:05 <kmc> i don't know of any compelling reason to use Float
15:49:05 <jlouis> v_c: you used the checkinstall -y trick as well?
15:49:11 <HugoDaniel> i think i like haskell too much :/
15:49:14 <medfly> derenrich, what?
15:49:21 <kmc> you lose the ability to use newtype-wrapped Doubles
15:49:30 <kmc> which can be useful for sort of dimensional analysis type things
15:49:34 <jlouis> medfly: this is #haskell, we eat Hokkaido-soup :)
15:49:36 <kmc> preventing unrelated values from mingling
15:49:49 <HugoDaniel> when i say to the people around me "im going it in haskell", they usually reply with "im not sure thats the right tool for the job", mostly regardless of the job at hand
15:49:52 <kmc> where's CReal come from?
15:49:54 <HugoDaniel> ...thats just a thought
15:50:04 <v_c> jlouis: nope. What's the checkinstall -y trick?
15:50:06 <kmc> HugoDaniel, what sort of job?
15:50:08 <derenrich> jlouis: how do you make that?
15:50:10 <kmc> and do they know Haskell?
15:50:15 <kmc> it has something of an undeserved reputation
15:50:15 <Milo-> does length -function work in a constant time?
15:50:15 <ACSpike[Home]> I'm reading "Programming in Haskell". In chapter 8 exercise 8 it talks about a "natural grammar". is "natural grammar" jargon? or just the grammar that one would naturally define?
15:50:22 <Milo-> or is it linear?
15:50:23 <HugoDaniel> kmc: no
15:50:27 <jlouis> derenrich: http://onemorefoodblog.wordpress.com/2006/09/23/hokkaidosoup/ no peanut butter :)
15:50:40 <HugoDaniel> kmc: i just do all my programming tasks in haskell
15:50:41 <derenrich> jlouis: you saved thanksgiving!!
15:50:57 <medfly> I actually have some pumpkin soup
15:51:07 <medfly> it's somewhat different, though...
15:51:21 <jlouis> derenrich: note that Hokkaido pumpkins are rather small compared to "normal" pumpkins. But Hokkaido soup is absolutely delicious
15:51:22 <HugoDaniel> which usually requires recoding bits of java and python...
15:51:27 <blackdog> jlouis: oh great, now i'm reading that as "this .... is ..... #HASKELLLL!!!!"
15:51:41 <derenrich> jlouis: obviously
15:52:02 <v_c> #haskell - advice on soup and curry
15:52:02 <lunabot>  luna: Not in scope: `haskell'
15:52:11 <jlouis> v_c: checkinstall is a hack that tracks an installation and wraps it up into a .deb for easy deinstallation
15:52:27 * v_c facepalm 
15:52:32 * hackagebot upload: bamboo-theme-mini-html5 2009.11.27 - bamboo mini html5 theme (JinjingWang)
15:52:35 <v_c> I should try that in the near future
15:52:54 <v_c> deinstallation can be a problem
15:54:05 <v_c> The last thing: how do I remove a directory from the $PATH
15:54:41 <v_c> PATH=/home/vic/.cabal/bin to be exact
15:54:48 <jlouis> the easiest way is to remember the old PATH and then reinstate it. Persistence!
15:55:01 <v_c> Indeed
15:55:17 <jlouis> you wan't to add ~/.cabal/bin to the existing path
15:55:47 <v_c> Thing is, if I open a new terminal and check the PATH, it gives me PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
15:56:07 <v_c> whereis cabal
15:56:08 <v_c> cabal: /usr/local/bin/cabal
15:56:15 <v_c> Neat
15:56:17 <jlouis> well, there is a snippet you can drop in the bottom of your ~/.profile
15:56:26 <jlouis> let me find it
15:57:04 <jlouis> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5106#a5106
15:57:26 <v_c> jlouis: thanks.
15:58:10 <jlouis> v_c it makes .cabal/bin override what is in other places though
15:58:19 <jlouis> I believe that is the correct thing to do
15:59:00 <v_c> Yeah, it's all good now. I can use cabal the right way
15:59:05 <v_c> In usr/bin haha
15:59:20 <v_c> */usr/local/bin
15:59:27 <derenrich> ahhahahahah
15:59:47 <v_c> These chips are making me thirsty
16:01:33 <v_c> So, I installed permutation via cabal. How can I test if it works? http://hackage.haskell.org/package/permutation
16:01:59 <jlouis> ghci RET :m +Data.Choose
16:02:37 <v_c> Prelude Data.Choose>
16:02:38 <v_c> :-D
16:02:49 <v_c> Indeed.
16:03:03 <jlouis> another path is to ask cabal
16:03:38 <jlouis> $ cabal list permutation
16:04:07 <toast-opt> > let y x = x $ y x in take 10 $ y \s -> 0 : map (+1) s
16:04:08 <lambdabot>   <no location info>: parse error on input `\'
16:04:15 <dcoutts> jlaire: or $ cabal info permutation
16:04:28 <toast-opt> > let y x = x $ y x in take 10 $ y (\s -> 0 : map (+1) s)
16:04:30 <lambdabot>   <no location info>: lexical error at character '\SI'
16:04:30 <v_c> cabal list permutation
16:04:30 <v_c> cabal: /home/vic/.cabal/packages/hackage.haskell.org/00-index.tar: openBinaryFile: permission denied (Permission denied)
16:04:33 <v_c> Hmmm..
16:04:51 <dcoutts> v_c: hmm, did you accidentally run sudo cabal update?
16:04:52 <v_c> There still is a .cabal/bin/cabal
16:05:05 <dcoutts> v_c: check the owner and permissions of that file
16:05:07 <v_c> Not really accidentally..
16:05:26 <v_c> -rw------- 1 root root 16M 2009-11-27 02:00 /home/vic/.cabal/packages/hackage.haskell.org/00-index.tar
16:05:30 <v_c> Meh
16:05:42 <toast-opt> lambda bot doesn't like backslashes?
16:05:45 <dcoutts> v_c: well, if you'd known it'd break things you wouldn't have done it :-) hence it was accidental :-)
16:05:57 <toast-opt> > let y x = x $ y x in take 10 $ y (\\s -> 0 : map (+1) s)
16:05:59 <lambdabot>   <no location info>: parse error on input `->'
16:06:00 <v_c> Yeah. What now?
16:06:52 <jlouis> sudo chown $(whoami):$(whoami) /home/vic/.cabal/packages/hackage.haskell.org/00-index.tar :P
16:07:05 <v_c> predictable :-P
16:07:27 <v_c> Should I delete the bin from the .cabal folder/
16:07:35 <jlouis> no!
16:07:54 <v_c> -rwxr-xr-x 1 root root 4.1M 2009-11-27 01:50 /usr/local/bin/cabal
16:07:58 <jlouis> it is meant for installing helper binaries into cabal.
16:07:59 <v_c> Is this the evil twin?
16:08:07 <v_c> Ah.. ok
16:08:17 <toast-opt> i guess i can write it w/o the lambda to make it 'trickier'
16:08:19 <toast-opt> > let y x = x $ y x in take 10 $ y ((0:) . map (+1))
16:08:22 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
16:08:42 <jlouis> well, you probably want a grand cleanup and change to your own user for everyhting in ~/.cabal
16:09:48 <v_c> Well, everything in .cabal is now usable
16:09:49 <v_c> So to speak
16:09:55 <eikke__> would anyone in here who knows python be willing to check whether some code I wrote (in python) is a 'correct' implementation of the Haskell State monad?
16:10:06 <eikke__> wrote it to check whether I actually got the state monad thing...
16:11:17 <v_c> And now cabal list permutation does the right thing (TM)
16:11:26 <v_c> jlouis: thanks
16:12:12 <v_c> It took me two whole hours to install a package, but it feels good
16:12:40 <v_c> It'll probably take me another two hours to figure out how to use it
16:14:37 <v_c> How can I use this?  swaps :: Permute -> [(Int, Int)]
16:29:32 <gemie> anyone awake?
16:30:08 <gemie> I got a [[Maybe Int]] that I need to print to the screen. I am trying to use map and lines to get it to work but I can't get it to be done properly
16:31:24 <aavogt> gemie: you can use 'print' ?
16:31:50 <aavogt> it really depends on how you want the Nothing elements to look like
16:31:51 <QtPlaty[HireMe]> gemie: Perhaps you need filter.  Or a show instnace?
16:31:57 <gemie> aavogt not in this case I need to use putStr and I got a function that makes an inner list of maybe int to chars
16:32:19 <aavogt> @type unlines
16:32:20 <lambdabot> [String] -> String
16:32:29 <aavogt> you want that one, not lines
16:33:32 <aavogt> @type putStr $ lines $ map (undefined::[Maybe Int] -> String) ?x
16:33:33 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
16:33:33 <lambdabot>     In the first argument of `map', namely
16:33:33 <lambdabot>         `(undefined :: [Maybe Int] -> String)'
16:33:47 <aavogt> @type putStr $ unlines $ map (undefined::[Maybe Int] -> String) ?x
16:33:49 <lambdabot> (?x::[[Maybe Int]]) => IO ()
16:34:14 <aavogt> heh, I made the same mistake, gemie
16:37:07 <gemie> aavogt yeah thanks been sitting trying to make it with lines for a while :P
16:46:38 <gemie> aavogt suppose that I didn't have the function for making an inner list of maybe int to char
16:46:52 <aavogt> =)
16:47:01 <gemie> I have it but =)
16:47:06 <gemie> would be nice to make something better
16:47:08 <aavogt> gemie: depends what you want to do
16:47:12 <gemie> since I am only using the function there
16:47:55 <aavogt> @type map show . catMaybes
16:47:56 <lambdabot> forall a. (Show a) => [Maybe a] -> [String]
16:48:02 <aavogt> type map show . sequence
16:48:17 <aavogt> @type map show . sequence $ (?x:: [Maybe Int])
16:48:18 <lambdabot>     Couldn't match expected type `[a]'
16:48:18 <lambdabot>            against inferred type `Maybe Int'
16:48:18 <lambdabot>       Expected type: [[a]]
16:48:30 <gemie> aavogt it's a sudoku game so in the function iam making like chr fromJust + ord '0' and if it's nothing then just a '.'
16:48:32 <aavogt> @type liftM (map show) . sequence $ (?x:: [Maybe Int])
16:48:33 <lambdabot> (?x::[Maybe Int]) => Maybe [String]
16:48:53 <gemie> what is really sequence?
16:49:02 <aavogt> you don't want sequence here
16:49:05 <bd_> @src sequence
16:49:05 <lambdabot> sequence []     = return []
16:49:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:49:05 <lambdabot> --OR
16:49:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:49:10 <aavogt> > sequence  [Just 1,Nothing]
16:49:11 <lambdabot>   Nothing
16:49:16 <aavogt> > sequence  [Just 1,Just 2]
16:49:17 <lambdabot>   Just [1,2]
16:49:41 <gemie> so sequence takes a list of sequence and performs them?
16:49:43 <aavogt> @type map (maybe "." show)
16:49:44 <lambdabot> forall a. (Show a) => [Maybe a] -> [[Char]]
16:49:49 <gemie> hm ok
16:50:03 <aavogt> sequence takes a list of monadic actions and sequences them
16:50:09 <pastah_rhymez> gemie: sequence takes a list of monadic computations and comuptes a list of results
16:50:12 <pastah_rhymez> hehe
16:50:16 <pastah_rhymez> gemie: try this:
16:50:34 <sshc> When should I make the return type "[IO Foo]" instead of "IO [Foo]"?
16:50:57 <pastah_rhymez> sequence_ [putStr "lol", print (1,'x'), puStrLn $ "i am a dem" ++ show 0]
16:51:09 <c_wraith> sshc:  when you want to provide a list of actions that you may or may not choose to execute later.
16:51:19 <pastah_rhymez> @type [putStr "lol", print (1,'x'), puStrLn $ "i am a dem" ++ show 0]
16:51:20 <lambdabot> Not in scope: `puStrLn'
16:52:07 <gemie> ?
16:52:18 <pastah_rhymez> gemie: try it in your terminal
16:52:47 <pastah_rhymez> and i missed a 't' in there :/
16:52:56 <kmc> sshc, [IO Foo] is a list of IO-recipes.  IO [Foo] is a single IO-recipe, whose result is a list
16:53:04 <pastah_rhymez> gemie: in ghci: ":t [putStr "lol", print (1,'x'), putStrLn $ "i am a dem" ++ show 0]"
16:53:28 <kmc> ([] of IO, versus IO of [])
16:53:38 <medfly> type?
16:53:41 <sshc> ok
16:53:51 <medfly> oh, ok
16:53:54 <sshc> how do I write "if x then foo else bar" in a do block without putting the "if" and the "then" on separate lines?
16:54:02 <kmc> exactly like that
16:54:09 <pastah_rhymez> sshc: wait for haskell 2010
16:54:21 <kmc> > do { if True then return 3 else [] }
16:54:22 <sshc> kmc: but I want else on a separate line
16:54:23 <lambdabot>   [3]
16:54:39 <gemie> pastah_rhymez I get a [IO () ]
16:54:40 <pastah_rhymez> lol = do
16:54:42 <pastah_rhymez>     if x then foo
16:54:44 <pastah_rhymez>          else bar
16:54:46 <pastah_rhymez> gemie: that's correct
16:55:00 <pastah_rhymez> now take that list and run 'sequence_' on it
16:55:21 <sshc> foo = do
16:55:26 <sshc>     if x then
16:55:37 <thoughtpolice> treddit.com
16:55:40 <sshc>         bar
16:55:47 <sshc>     else do
16:55:51 <sshc>         quux
16:55:51 <thoughtpolice> oh damn wrong window :(
16:55:59 <sshc> and add a do after then
16:56:02 <sshc> that's what I'm trying to do
16:56:03 <gemie> pastah_rhymez I see =) cool
16:56:35 <pastah_rhymez> gemie: also, check the type of 'sequence magiclist', note the '_' missing after 'sequence'
16:56:36 <sshc> do I only need to indent else further?
16:56:44 <gemie> when not doing _ (which I guess means throw away the rest) I also get [(),....] why is that?
16:56:53 <gemie> why are they returned?
16:56:55 <kmc> :type sequence
16:57:01 <kmc> :t sequence
16:57:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:57:03 <kmc> :t sequence_
16:57:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:57:15 <sshc> :type foo
16:57:17 <kmc> gemie, ghci has a special case -- if an IO action has return type (), it doesn't print the value
16:57:17 <gemie> I see :)
16:57:19 <sshc> :t foo
16:57:20 <kmc> because it's certainly ()
16:57:22 <gemie> you guys now all hehe
16:57:22 <lambdabot> Not in scope: `foo'
16:57:27 <pastah_rhymez> gemie: you get a list of all the results
16:57:43 <gemie> and here we don't have a result?
16:57:47 <pastah_rhymez> gemie: change the list to [return "lol", getLine]
16:57:49 <kmc> () is a useless result
16:57:53 <kmc> but it's still a result
16:58:00 <kmc> () is the useless type, with one value, also written ()
16:58:05 <pastah_rhymez> gemie: you know how getLine works?
16:58:05 <kmc> equivalently, it's the "empty tuple"
16:58:41 <pastah_rhymez> sshc: lol = do
16:58:42 <pastah_rhymez>     if p then do
16:58:44 <pastah_rhymez>             foo1
16:58:46 <pastah_rhymez>             foo2
16:58:48 <kmc> gemie, it's worth noting that "sequence" is only one of the many functions of type [IO a] -> IO [a].  because when you have a list of recipes, you can glue them together into a single recipe in various ways
16:59:02 <kmc> "sequence" uses every recipe exactly once, and in left-to-right order
16:59:41 <gemie> pastah_rhymez yes. I tried it out now. I can't mix a list like [return "lol", putStr "test"] so that I get one empty () and a result which has lol?
16:59:58 <kmc> you can't mix () and String
17:00:01 <kmc> > [(), "foo"]
17:00:03 <lambdabot>   Couldn't match expected type `()'
17:00:03 <lambdabot>         against inferred type `[GHC.Types...
17:00:07 <sshc> kmc: how does sequence evaluate the IO's?
17:00:15 <kmc> sshc, "evaluate" isn't the issue
17:00:21 <pastah_rhymez> gemie: no, you can't
17:00:25 <kmc> it sequences them together using (>>)
17:00:25 <pastah_rhymez> @type getLine
17:00:26 <lambdabot> IO String
17:00:28 <kmc> @src sequence
17:00:30 <lambdabot> sequence []     = return []
17:00:30 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:00:30 <lambdabot> --OR
17:00:30 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:00:40 <kmc> the first one there is probably the more useful
17:00:40 <gemie> ah ok
17:01:13 <kmc> evaluating an IO action doesn't do any IO
17:02:24 <kmc> evaluation is separate from performance
17:05:17 <c_wraith> performing IO only happens as a result of binding it into main]
17:06:50 <kmc> (and GHCi binds every IO action you type into its own main)
17:08:48 <heoa> newbie question: How can I do withouth writing every brackets   f(f(f(f...(f 2))...)     eg  f(  (100 times)  (f 2))
17:10:28 <kmc> :t iterate
17:10:30 <lambdabot> forall a. (a -> a) -> a -> [a]
17:10:40 <kmc> > iterate f x
17:10:42 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
17:11:55 <lament> > iterate (+ 1) 0
17:11:56 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:12:11 <kmc> > iterate (*2)
17:12:13 <kmc> > iterate (*2) 1
17:12:16 <lambdabot>   mueval-core: Time limit exceeded
17:12:17 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
17:12:35 <centrinia> > iterate id 1
17:12:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:13:05 <kmc> > iterate succ 'A'
17:13:08 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
17:13:36 <lament> > iterate ("lo" ++) "lol"
17:13:37 <alc> :t f
17:13:39 <lambdabot>   ["lol","lolol","lololol","lolololol","lololololol","lolololololol","lololol...
17:13:39 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
17:13:44 <alc> :t x
17:13:46 <lambdabot> Expr
17:18:10 <heoa> > iterate (12/(1+x)) 0
17:18:12 <lambdabot>   Couldn't match expected type `a -> a'
17:18:12 <lambdabot>         against inferred type `Simple...
17:18:51 <heoa> > let f x = (12/(1+x))
17:18:53 <lambdabot>   not an expression: `let f x = (12/(1+x))'
17:19:04 <heoa> > f x = (12/(1+x))
17:19:06 <lambdabot>   <no location info>: parse error on input `='
17:19:56 <heoa> :t function
17:19:58 <lambdabot> Not in scope: `function'
17:20:21 <Warrigal> @hoogle a -> (b -> b) -> b -> b
17:20:22 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
17:20:23 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
17:20:23 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
17:20:30 <Warrigal> Weird.
17:20:55 <kmc> > iterate (\x -> 12/(1+x)) 0
17:20:57 <lambdabot>   [0.0,12.0,0.9230769230769231,6.24,1.6574585635359116,4.515592515592516,2.17...
17:21:07 <kmc> > let f x = 12 / (1+x) in iterate f 0
17:21:10 <lambdabot>   [0.0,12.0,0.9230769230769231,6.24,1.6574585635359116,4.515592515592516,2.17...
17:21:21 <lament> > iterate (\x -> if x == 1 then 1 else if x `mod` 2 == 0 then x `quot` 2 else x * 3 + 1) 27
17:21:23 <lambdabot>   [27,82,41,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274...
17:21:31 <kmc> heoa, "let" without "in" is not an expression, although it is valid within a monadic do-block
17:24:08 <heoa> weird, it works in ghci like:   let f x = (12)/(1+x)
17:24:18 <kmc> heoa, in ghci you are inside a monadic do-block
17:24:56 <heoa> have to look at the source code :D
17:25:11 <heoa> Thank you.
17:25:18 <Warrigal> heoa: lambdabot isn't GHCi. :-)
17:25:24 <kmc> > iterate ((`mod` 2) >>= ([(`div` 2), succ . (*3)] !!)) 27
17:25:26 <lambdabot>   [27,82,41,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274...
17:25:40 <Saizan_> you're not exactly in one, but the syntax is similar
17:29:08 <kmc> Warrigal, "flip const" ?
17:29:15 <kmc> @djinn a -> (b -> b) -> b -> b
17:29:33 <lambdabot> f _ a b = a b
17:31:41 <heoa> > iterate (\x -> (x+9)^(1/3)) 0
17:31:43 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:31:43 <lambdabot>    `GHC.Real.Fractional t'
17:31:43 <lambdabot> ...
17:31:52 <heoa> > iterate (\x -> (x+9)^(0.333)) 0
17:31:54 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:31:54 <lambdabot>    `GHC.Real.Fractional t'
17:31:54 <lambdabot> ...
17:31:58 <kmc> :t (^)
17:32:00 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
17:32:00 <kmc> :t (**)
17:32:02 <lambdabot> forall a. (Floating a) => a -> a -> a
17:32:06 <kmc> :t (^^)
17:32:08 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
17:32:20 <kmc> heoa, those are three exponentiation operators
17:32:45 <heoa> > iterate (\x -> (x+9)**(1/3)) 0
17:32:47 <lambdabot>   [0.0,2.080083823051904,2.2293641616632986,2.2393314970516873,2.239993854751...
17:32:48 <Warrigal> kmc: that would work, but it's not the function I'm after.
17:33:06 <kmc> Warrigal, how can it do anything useful with the "a" argument?
17:36:05 <Warrigal> kmc: it has a (b -> b) and a b. There's more than one way to get a b from that.
17:36:22 <kmc> yeah but what's the "a" good for
17:38:57 * hackagebot upload: package-vt 0.1.3.3 - Haskell Package Versioning Tool (KrzysztofSkrzetnicki)
17:39:55 <Warrigal> Well, I don't mean general a; I mean something like Int.
17:41:41 <Saizan_> hoogle should have exists and forall quantifiers
17:59:58 <kmc> @let log2 n = case n `divMod` 2 of (1,0) -> return (1::Integer); (n',0) -> succ <$> log2 n'; _ -> Nothing
18:00:01 <lambdabot>  Defined.
18:00:04 <kmc> > log2 16
18:00:07 <lambdabot>   Just 4
18:00:09 <kmc> > log2 49
18:00:11 <lambdabot>   Nothing
18:03:02 <centrinia> > log2 0
18:03:05 <lambdabot>   * Exception: stack overflow
18:03:07 <centrinia>  :p
18:03:34 <sshc> I have the contents of a directory with "contents <- getDirectoryContents statsDirectory", and I want to call a function, which returns IO [Foo], for every one of those contents with an extra argument.  Apparently, I'm doing this incorrectly: foo <- List.Concat $ forM contents $ function something        (I need to pass something as the very first argument to "function"), because GHC is complaining that it "Couldn't match expected type `[[a]]'   against inf
18:03:41 <sshc> d type `IO [[Score]]'"
18:04:12 <kmc> centrinia, ask a stupid question, get a stupid answer ;P
18:04:39 <kmc> foo <- forM .... ; return $ concat foo
18:04:50 <kmc> (or use foo in another monad action if you wish)
18:06:58 <kmc> > let f xs n = case dropWhile ((/=1).denominator.(n*)) xs of [] -> []; (x:_) -> n : f xs (n*x) in take 12 $ catMaybes $ map (log2.floor) $ f [17%91,78%85,19%51,23%38,29%33,77%29,95%23,77%19,1%17,11%13,13%11,15%14,15%2,55%1] 2
18:07:02 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29,31]
18:07:59 <sshc> thanks, kmc !
18:08:30 <kmc> sshc, or you could use a combinator like liftM, fmap, or <$>
18:31:50 <ivanm> Axman6: ping!
18:33:48 <pastah_rhymez> @ps (\(x,y) (z,w) -> (x+z, y+w))
18:33:48 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
18:34:08 <kmc> @hoogle comparing
18:34:10 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
18:44:16 <sshc> will record syntax change in Haskell 2010?
18:44:47 <ivanm> sshc: no
18:55:01 <Cale> sshc: Essentially nothing is changing relative to what's implemented in GHC.
18:55:23 <Cale> sshc: They've just selected a handful of the most conservative extensions and decided to formalise them.
19:02:26 <junmin> hello how can i correct (_, a, b) `elem` someList case of? it's saying Pattern sysntax in expression context: _
19:02:45 <ivanm> junmin: you can't
19:03:11 <junmin> well, it's "case (_, a, b) `elem` someList of"
19:03:14 <ivanm> junmin: create a function (a,b,c) -> (a,b,c) -> Bool
19:03:18 <ivanm> then use any
19:03:35 <junmin> ivanm: let me see
19:04:22 <junmin> @src any
19:04:23 <lambdabot> any p =  or . map p
19:05:24 <junmin> ivanm: got it thx
19:05:28 <ivanm> no worries
19:09:42 * geekagent created a Monad wrapping MonadCGI that allows authorization to be simply annotated.
19:10:15 <geekagent> user <- authRequired; (rest here) (if the user is not logged in, the rest doesn't happen)
19:11:11 * roconnor creates a Monad to exploit a security hole in geekagent's Monad.
19:11:38 * ivanm just gets a big crowbar to threaten geekagent with
19:11:54 <roconnor> ivanm: you need a rubber hose.
19:12:45 <geekagent> roconnor: a crowbar would probably work.
19:12:45 <p_l> roconnor: or build a jail, UK-style
19:13:08 <p_l> (with the option: "security will look the other way when inmates play with you")
19:13:25 <ivanm> roconnor: or was it a wrench that xkcd had?
19:13:48 <ivanm> p_l: as opposed to "security will play with you"?
19:13:48 <ivanm> ;-)
19:14:24 <p_l> ivanm: they don't want to waste money on training security in torture
19:15:54 <geekagent> http://haskell.pastebin.com/m3d6ccf08
19:16:02 <junmin> @src fst
19:16:04 <lambdabot> fst (x,_) =  x
19:16:21 <centrinia> @src snd
19:16:22 <lambdabot> snd (_,y) =  y
19:20:05 <geekagent> Extending The Monads in Various Stages for a cgi-app feels kind-of like writing Python WSGI Middleware, only it's more fun to do it in haskell.
19:21:08 <geekagent> does anyone know what happened to hpaste?
19:40:45 <sshc> doess gcc recognize semicolons after "then" and before "else" in a "do" block?
19:41:08 <sshc> s/gcc/ghc/
19:42:25 <sshc> pefect timing
19:43:26 <dibblego> is there a unicode character for >>= ?
19:43:35 <monochrom> No, haskell syntax does not have semicolon inside if-then-else
19:45:04 <monochrom> haskell 2010 may change that.
19:45:39 <Warrigal> When's the last time we had a Haskell named after a year?
19:45:55 <sshc> Warrigal: Haskell 98
19:45:57 <monochrom> Last time was Haskell 98. :)
19:46:15 <sshc> monochrom: I was wonder if *ghc* supported it, since it already supports most of 2010 changes, according to recent chat
19:46:18 <Warrigal> Well, we missed our last chance to call something Haskell 99; I guess we'll have to wait for the next one.
19:46:35 <monochrom> I haven't heard of ghc supporting it.
19:48:20 <monochrom> The current 6.10.4 manual has no mention of the do-if extension.
19:50:19 <aavogt> perhaps it is always enabled?
19:53:17 * shapr boings tiredly
19:54:20 <kmc> always with the boinging
19:54:29 * BMeph pops the top on a "tall boy" can of Lambda-Ade, and passes it to shapr
19:54:59 <BMeph> mmorrow: ping
19:56:06 <ddarius> shapr: I blame the tryptophan
19:59:33 <shapr> ddarius: I agree
19:59:45 <shapr> BMeph: ooh, lambda-ade!
20:06:16 <syntaxglitch> anyone bored enough for looking at a short snippet of code and advising me on all the ways I'm doing it wrong?
20:07:33 <Berengal> syntaxglitch: it helps to paste the snippet :)
20:08:24 <syntaxglitch> Berengal, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5116#a5116
20:08:47 <syntaxglitch> it works, of course
20:08:58 <syntaxglitch> but is probably ugly and not very idiomatic Haskell
20:14:59 <Berengal> Looks like pretty much straightforward mathematical functions
20:15:17 <syntaxglitch> well, yeah
20:15:59 <syntaxglitch> probably not really a good sample for "what should haskell code look like" I guess, it's pretty simple code
20:16:47 <syntaxglitch> I just tend to implement roughly that code in any language I feel like learning as a "get my feet wet" exercise
20:17:57 <Berengal> Well, with functions like these, there's not much you can do to improve them other than improve the mathematics themselves
20:18:41 <Berengal> Mapping pure mathematics into haskell is a lossless convertion, most of the time
20:19:08 <syntaxglitch> well, one thing I was wondering about was, say, should some of these functions be combined, or further decomposed, for instance
20:21:06 <syntaxglitch> or, say, stylistic things like use of list comprehensions vs. map
20:21:41 <ddarius> syntaxglitch: You have superfluous parentheses in three places.
20:22:15 <Berengal> That, and colorPoint is partial
20:22:17 <syntaxglitch> I just don't want to be one of those people who sits down and writes Language Y in Language X, and I know I've got a lot of habits from Python and Scheme in the back of my head
20:23:24 <syntaxglitch> ddarius, which places?
20:23:40 <toast-opt> syntaxglitch, that sounds like a good way to start, at least.  may not be ideal, but the more often you can use X, the more opportunities to learn the 'right' way to do things in X
20:24:33 <toast-opt> i found i only started to write idiomatic python after i learned enough to write C-like python code.  that let me start doing real work with it
20:24:47 <Berengal> There's so many idioms in haskell that idiomatic haskell is a myth
20:24:54 <syntaxglitch> toast-opt, well, that's why I was asking for feedback on whether I'm doing anything that's horrible anti-idiomatic in Haskell
20:25:13 <toast-opt> syntaxglitch, sry, i missed that
20:27:01 <Berengal> As long as you keep yourself mostly pure and keep writing small functions, there's not much people could arrest you for
20:27:54 <Saizan_> except tabs
20:28:01 <Berengal> Oh, yes. Use spaces.
20:28:24 <syntaxglitch> mostly pure meaning what, "minimize lines of code within IO"?
20:28:40 <Berengal> No uneccessary IO
20:29:24 <syntaxglitch> and I normally prefer tabs, but... that doesn't seem to work very well with Haskell's layout system
20:29:51 <Berengal> Use something like emacs or yi that can indent properly
20:30:07 <Berengal> Manual indenting is so last millenium
20:30:19 <toast-opt> yeah, i'm just learning, but it keeps surprising me how easily you can mix pure and IO code
20:31:02 <toast-opt> like, you can have a pure function list of file handles, and process it with pure lazy algorithms.
20:32:28 <syntaxglitch> Berengal, my editor indents just fine... I prefer tabs mostly due to better semantic value (indenting vs. alignment)
20:32:57 <Berengal> syntaxglitch: that's often the same thing in haskell's layout
20:33:32 <syntaxglitch> yeah, I've noticed
20:34:10 <syntaxglitch> which is why now I use spaces for Haskell, and tabs elsewhere
20:34:11 <Berengal> (And personally, I've never seen any value in that)
20:35:19 <Saizan_> > -1 :+ -1
20:35:20 <lambdabot>   Precedence parsing error
20:35:20 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
20:35:30 <Saizan_> > -1 :+ (-1)
20:35:31 <lambdabot>   Precedence parsing error
20:35:31 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
20:35:41 <Saizan_> > (-1) :+ -1
20:35:42 <lambdabot>   Precedence parsing error
20:35:42 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and pr...
20:35:48 <Saizan_> ok.
20:36:19 <Berengal> agda is a fun language
20:37:06 <syntaxglitch> I should design and implement my own language someday
20:37:09 <syntaxglitch> it sounds like fun
20:37:47 <syntaxglitch> I could build in all the obtuse features I enjoy from other languages and make a language that only I could ever enjoy
20:38:09 <path[l]> is there a built in function that gives you -1 for negative x and +1 for postive?
20:38:15 <ddarius> :t signumh
20:38:17 <lambdabot> Not in scope: `signumh'
20:38:17 <ddarius> :t signum
20:38:19 <lambdabot> forall a. (Num a) => a -> a
20:38:28 <ddarius> > signum
20:38:30 <lambdabot>   {-3->-1;-2->-1;-1->-1;0->0;1->1;2->1;3->1}
20:39:17 <path[l]> ah
20:39:25 <path[l]> heh 0 is its own value eh
20:39:43 <syntaxglitch> what else would make sense for 0?
20:39:43 <Cale> well, it's neither positive nor negative
20:39:49 <path[l]> thanks
20:39:54 <path[l]> no I agree
20:40:50 <syntaxglitch> Cale, unless you're working with some floating point representations :)
20:41:09 <aavogt> > signum (-0) :: Double
20:41:10 <lambdabot>   0.0
20:41:12 <path[l]> I trying to find a way to list (0,0) -> (m,n) in the order where (p1,q1) < (p2,q2) is p1-q1 < p2-q2. But I want a function thats got a closed form
20:42:36 <aavogt> path[l]: what do you mean by the ordering of (x,y) ?
20:43:05 <aavogt> is that by distance, or by comparing the first elements, then the second (like lexicographically)
20:43:33 <path[l]> no its just a 2 dimensional matrix elements where I want the elements closer to the diagonal listed first
20:43:47 <aavogt> ah I misread your original
20:44:17 <aavogt> > do x <- [1..4]; y <- reverse [1..x]; return (x,y)
20:44:18 <lambdabot>   [(1,1),(2,2),(2,1),(3,3),(3,2),(3,1),(4,4),(4,3),(4,2),(4,1)]
20:44:35 <toast-opt> not quite
20:45:41 <aavogt> or you want to go on the diagonal first, then the next line, and so on until (m,0)?
20:46:14 <aavogt> p1-q1 < p2-q2 doesn't really define an order for the diagonal when m==n
20:47:21 <MoALTz> > [1..10000000000]
20:47:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:47:27 <MoALTz> > reverse [1..10000000000]
20:47:33 <lambdabot>   mueval: ExitFailure 1
20:47:39 <MoALTz> thought so
20:47:53 <MoALTz> > [10000000000,(10000000000-1)..1]
20:47:55 <lambdabot>   [10000000000,9999999999,9999999998,9999999997,9999999996,9999999995,9999999...
20:49:25 <toast-opt> hmm, i wonder if reverse of Sequences are efficient
20:50:04 <syntaxglitch> zero is annoying anyway, what with the whole "reals not being closed under division"
20:50:08 <syntaxglitch> we should get rid of it :(
20:50:34 <toast-opt> syntaxglitch, 'it' here being 'zero'?
20:50:37 <path[l]> sorry dced. Essentially I have a 2 parameter function thats defined recursively and I want to memoise it. But since the function runs backward along the diagonal broadly and Im thinking placing elements on the same diagonal together might help me
20:50:38 <toast-opt> :)
20:51:06 <syntaxglitch> toast-opt, yeah, though I guess getting rid of division would work too
20:51:50 <Berengal> Just redefine zero to be "really close to zero", then division would be closed again
20:51:51 <toast-opt> syntaxglitch, i thought the goal was for division to be of type a -> a -> a for some value of a
20:52:13 <toast-opt> removing division is just saying the solution set it empty, which it already is
20:53:29 <syntaxglitch> or could just get rid of addition and subtraction, is there even a way to get to zero without those?
20:53:49 <aavogt> keep dividing by something
20:54:11 <aavogt> you can get to zero considering roundoff error
20:54:27 <aavogt> > elemIndex 0 $ iterate (/2) 1
20:54:28 <lambdabot>   Just 1075
20:54:38 <syntaxglitch> sorta recenter the number line on 1 and let 1/2 and 2 be the same conceptual "distance" from 1
20:54:55 <pastah_rhymez> @pl (\fp -> fmap f (readFile fp))
20:54:55 <lambdabot> fmap f . readFile
20:55:00 <pastah_rhymez> right...
20:56:21 <syntaxglitch> I guess if you remove + and - zero ends up behaving a lot like infinity, only reachable in the limit
20:57:02 <aavogt> syntaxglitch: it only took 1076 divisions by 2 to get a value that (==0)
20:57:14 <aavogt> starting with 1
20:57:29 <aavogt> you're also going to ban floating point?
20:57:38 <toast-opt> import qualified Data.Sequence as Seq
20:57:39 <syntaxglitch> floating point values are fake numbers anyway
20:57:41 <syntaxglitch> they're horrible
20:57:44 <aavogt> good luck getting anything done ;)
20:57:49 <toast-opt> > import qualified Data.Sequence as Seq
20:57:50 <lambdabot>   <no location info>: parse error on input `import'
20:57:51 <Berengal> aavogt: without zero, we've only got unary
20:58:01 <syntaxglitch> aavogt, since when is math about getting things done? :)
20:59:28 <aavogt> syntaxglitch: I'm in engineering, so the math they bother to teach us is about getting things done ;)
21:00:32 <manju> what is Haskell ST
21:00:39 <aavogt> Berengal: what do you mean by that?
21:01:04 <syntaxglitch> aavogt, engineering as in "software engineering" or something else
21:01:19 <Axman6> manju: you mean the ST monad?
21:01:21 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
21:01:38 <aavogt> I think zero as a placeholder to represent nonzero numbers isn't the same thing as zero as a number
21:01:48 <aavogt> syntaxglitch: chemical actually
21:01:48 <manju> Axman6: Haskell ST, STRef solution enables encapsulating local heaps and mutability within referentially-transparent code
21:01:58 <syntaxglitch> aavogt, ah, neat
21:02:10 <manju> Axman6: this is what the slide set says, I don't know further
21:02:25 <syntaxglitch> aavogt, just asking because I have issues with the term "software engineer" but I'll spare you :P
21:02:29 <Axman6> manju: ah good. ST is a monad, that is very much like IO, in that it allows metable variables, but doesn
21:02:32 <Axman6> doesn
21:02:33 <Axman6> rarg
21:03:39 <Axman6> doesn't allow external effects. this means that you can write imperative algorithms, which use STRefs as variables, but it looks like it's completely pure to the rest of your program (and it is infact guaranteed to be pure)
21:04:09 <aavogt> and it is faster than the State monad?
21:04:51 <Axman6> much faster. it is actually using mutable variables
21:05:19 <Berengal> Much faster when you need mutability
21:05:25 <Axman6> yes
21:05:33 <Berengal> If your state is a single integer, for example, there's no difference.
21:05:34 <manju> ok
21:05:43 <Axman6> it could be faster though. it can be annoyingly slow i think
21:05:56 <Berengal> ST or State?
21:06:00 <Axman6> st
21:06:12 <Berengal> I haven't used it much
21:06:31 <manju> It is like writing fast parts which require imperative style performance in haskell itself, like instead of coding the high-performance parts in C/C++, one uses haskell's ST Monad ?
21:06:32 <Berengal> But I guess the boxed mutable array issue is a real one
21:06:42 <manju> s/It is/Is it ?
21:06:54 <Berengal> manju: yeah.
21:07:04 <manju> Berengal: cool, thanks
21:07:18 <Berengal> And it's guaranteed to be pure
21:07:25 <Axman6> manju: not really, it's more for when you have an algorithm that just doesn't really work in a functional way, and requires you to use a more imperative style
21:07:26 <manju> ok...
21:08:49 <toast-opt> > import Data.Sequence in 1
21:08:54 <lambdabot>   <no location info>: parse error on input `import'
21:09:04 <Axman6> you can't import in lambdabot
21:09:19 <toast-opt> axman6 - any way to access libs outside of prelude?
21:09:37 <manju> Which is a good haskell book to buy ? I am looking for something which is good for a beginner, and scales well when I want to learn advanced stuff.
21:10:09 <aavogt> > Seq.take 5 $ Seq.fromList [1..10]
21:10:14 <lambdabot>   fromList [1,2,3,4,5]
21:10:16 <toast-opt> manju, I'm liking RWH -- as a C++ developer, it's very accessible, with good examples and really explains how things work without being too CS101
21:10:20 <manju> I am currently looking at RWH, and Programming in Haskell
21:10:34 <manju> toast-opt: ok, it is cheap too, I like that part
21:10:35 <toast-opt> but LYAH is really nice too.  i actually prefer it
21:10:37 <manju> :-)
21:10:56 <toast-opt> LYAH is fun, and then i go to RWH for more details and larger samples
21:10:56 <manju> yeah LYAH is good, but I want to buy it in dead-tree
21:11:02 <monochrom> I prefer a future tutorial: SYIH = shoot yourself in haskell :)
21:11:07 <toast-opt> yeah, i'd like a pocket-sized LYAH
21:11:18 <manju> monochrom: link ?
21:11:27 <monochrom> It does not exist.
21:11:27 <toast-opt> monochrom, that would be sweet.  esp. in o'reily-pocket-sized
21:11:34 <aavogt> performIO!!!!
21:11:37 <manju> heh ok
21:11:45 <Axman6> aavogt: you forgot the unsafe?
21:11:50 <manju> How is Programming in Haskell ?
21:11:57 <Axman6> it's lovely
21:12:07 <aavogt> Axman6: well, how else are you going to SYIH?
21:12:08 <toast-opt> aavogt, oh, Seq is already imported?
21:12:10 <manju> Axman6: the book
21:12:23 <Axman6> oh, never seen it :)
21:12:25 <toast-opt> let f = (+1); y x = x $ y x in y $ (0 Seq.<|) . Seq.map f
21:12:37 <aavogt> @version
21:12:38 <lambdabot> lambdabot 4.2.2.1
21:12:38 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:12:49 <toast-opt> > take 10 (let f = (+1); y x = x $ y x in y $ (0 Seq.<|) . Seq.map f)
21:12:52 <lambdabot>   Not in scope: `Seq.map'
21:12:58 <monochrom> module SYIH where { performIO :: IO a -> a; coerce :: a -> b; newGlobalVar :: a -> IORef a; ... }
21:13:01 <toast-opt> oops, and take wouldn't work either
21:13:08 <manju> what books did you guys use to learn haskell ?
21:13:20 <Axman6> i learnt it at university, then from here
21:13:27 <monochrom> I read the gentle introduction.
21:13:31 <aavogt> toast-opt: if you check the L.hs file or some imports.h file in that repo, you can see the tons of imports that lambdabot has
21:13:35 <aavogt> I read YAHT
21:13:35 <manju> ah :-( lucky
21:13:45 <manju> what is yaht ?
21:13:52 <aavogt> @where yaht
21:13:52 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
21:14:07 <toast-opt> that's ok.  i'll just have to fix my ghc install
21:14:12 <toast-opt> i'll get around to that later
21:15:24 <monochrom> Oh, a better one: SHIUTH = shoot yourself in unreal tournament haskell :)
21:15:31 <ivanm> Axman6: still here, catching the 7PM flight
21:15:38 <ivanm> but yes, we're going to be down
21:15:40 <manju> Anyone has dead-tree haskell books ?
21:15:42 <ivanm> monochrom: :o
21:15:44 <Axman6> heh, ok
21:15:47 <ivanm> manju: yes
21:15:50 <ivanm> manju: craft and RWH
21:15:55 <manju> ivanm: which one ?
21:16:02 <Axman6> ivanm: staying the night?
21:16:03 <manju> which is craft ? how is it ?
21:16:06 <ivanm> Axman6: 2
21:16:12 <Axman6> ah good
21:16:16 <ivanm> @google craft of functional programming
21:16:18 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
21:16:19 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
21:16:23 <ivanm> manju: ^^
21:16:25 <ivanm> I quite liked it
21:16:31 <ivanm> school of expression isn't bad either
21:16:39 <aavogt> ah, my library has those two
21:16:42 <monochrom> I have «the haskell school of expression» and «introduction to functional programming using haskell 2nd edition»
21:17:13 <monochrom> In fact, http://www.vex.net/~trebla/weblog/fpbooks.xhtml
21:17:14 <ivanm> monochrom: is that bird's book?
21:17:23 <monochrom> Yes that's Bird's.
21:17:39 <Axman6> craft was our uni textbook. i never read it though
21:17:43 <monochrom> The only book in the world that explains foldl stack overflow and how foldl' solves it.
21:17:44 <ivanm> Axman6: heh
21:17:48 <nvoorhies> I kinda liked the haskell road to logic, maths, and programming
21:17:55 <ivanm> monochrom: IIRC, I read his miranda one...
21:17:55 <Axman6> i tend not to read textbooks really
21:17:56 <monochrom> The only dead-tree book, I confess.
21:18:14 <ivanm> Axman6: you obviously don't do much high end math of physics...
21:18:15 <ivanm> ;-)
21:18:28 <toast-opt> nice book collection that person has
21:18:36 <nvoorhies> textbooks are awesome because you can scribble in them
21:19:53 <manju> I don't think Bird is for me yet...
21:20:01 <manju> I will start with something simple
21:20:08 <manju> I will go with RWH I think.
21:20:12 <monochrom> Don't you agree that it is such a scandal that by the 21st century and after so many haskell books published, there is still only one covering foldl vs foldl' and it was written before 2000 and basically no other books afterwards covers it and therefore we still have to explain again and again on IRC?
21:21:01 <manju> monochrom: why don't you guys write an article ? That will prevent noobs like me from bothering you :-)
21:21:13 * manju whips out the CC
21:21:21 <Berengal> monochrom: I thought #haskell was _the_ authority on haskell tutorials...
21:21:31 <ivanm> Axman6: anyway, you got my mobile then?
21:22:07 <toast-opt> monochrom, RWH has a whole section on foldl vs foldl'
21:22:35 <toast-opt> near the back though, and it's a big book.  maybe no one finishes it
21:23:00 <Axman6> ivanm: yup. i'll make sure it's in my phone though
21:23:25 <monochrom> Bird's does it in the middle. The end is monad transformers. (Yes, a book that teaches monad transformers before 2000 too, fancy that!)
21:24:10 <toast-opt> never seen that one
21:24:33 <monochrom> And of course Bird's doesn't just talk about foldl. The chapter is about the full story of haskell evaluation order, and then foldl is the obvious target.
21:24:34 <toast-opt> i mean, in a book store
21:24:51 <aavogt> it's probably out of print?
21:24:52 <toast-opt> i never got while foldl was so bad
21:25:19 <aavogt> > foldl f x [y,z,w,undefined]
21:25:20 <lambdabot>   f (f (f (f x y) z) w) * Exception: Prelude.undefined
21:25:34 <toast-opt> it starts at the head, right?
21:25:34 <toast-opt> oh, did i get them backwards again?
21:26:21 <Axman6> > foldl (const . Just) Nothing [1..5]
21:26:22 <lambdabot>   Occurs check: cannot construct the infinite type:
21:26:23 <lambdabot>    a = Data.Maybe.Maybe a
21:26:28 <Axman6> > foldr (const . Just) Nothing [1..5]
21:26:31 <lambdabot>   Just 1
21:26:42 <Axman6> > foldr (flip const . Just) Nothing [1..5]
21:26:45 <lambdabot>   Nothing
21:27:12 <Axman6> > foldr (just . flip const) Nothing [1..5]
21:27:14 <lambdabot>   Not in scope: `just'
21:28:21 <toast-opt> foldr doesn't suffer from this?
21:28:34 <Jafet> > foldr const undefined [1..5]
21:28:37 <lambdabot>   1
21:28:40 <Jafet> > foldl const undefined [1..5]
21:28:42 <lambdabot>   * Exception: Prelude.undefined
21:29:04 <aavogt> > foldl (flip const) undefined [1..5]
21:29:05 <lambdabot>   5
21:29:38 <sshc> are there any functions that exist in hackage that escape HTML?
21:30:11 <aavogt> @hoogle fromString
21:30:11 <lambdabot> Data.String fromString :: IsString a => String -> a
21:30:15 <aavogt> @hoogle toHtml
21:30:15 <lambdabot> Text.Html toHtml :: HTML a => a -> Html
21:30:15 <lambdabot> Text.XHtml.Frameset toHtml :: HTML a => a -> Html
21:30:15 <lambdabot> Text.XHtml.Strict toHtml :: HTML a => a -> Html
21:30:38 <aavogt> sshc: I believe that the String instance of HTML escapes html entities
21:31:01 <toast-opt> i think i see, it doesn't evaluate anything.  fold x f [y, z, ...] will expand to foldl (f x y) [z, ...] and so forth, but foldr will become 'f x (foldr y [z ...])' which then allows f to run, potentially delaying any further foldr expansion
21:31:21 <toast-opt> but foldl, each iteration, unfolds to another foldl that's even bigger...
21:31:33 <Berengal> aavogt: It does. The non-escaping version is primHtml :: String -> Html
21:31:58 <toast-opt> it's the complete opposite problem that strict evaluation has.  that's wild.
21:32:18 <aavogt> Berengal: yeah, I've used that at some point ;)
21:32:53 <Berengal> toast-opt: it's not an issue if the folded function can return a constructor immediately without looking at it's first argument
21:33:25 <Berengal> In a way, foldl evaluates the list from right to left...
21:33:47 <sshc> > toHtml "<foo>"
21:33:49 <lambdabot>   Not in scope: `toHtml'
21:35:06 <sshc> aavogt: how do I convert an HTML to a String after it's been escaped by toHtml?
21:35:07 <Berengal> sshc: if you're using a different html toolkit, it probably has its own way of escaping strings.
21:35:30 <Berengal> sshc: show
21:35:41 <sshc> oh
21:35:44 <Berengal> or one of the render functions
21:35:45 <sshc> I'm not using any HTML toolkit
21:35:54 <aavogt> @hoogle Html -> String
21:35:55 <lambdabot> Prelude show :: Show a => a -> String
21:35:55 <lambdabot> Text.Show show :: Show a => a -> String
21:35:55 <lambdabot> Text.Html prettyHtml :: HTML html => html -> String
21:36:50 <toast-opt> > :t Seq
21:36:52 <lambdabot>   <no location info>: parse error on input `:'
21:54:57 <Axman6> could i interest some people into lurking in #hackage? especially anyone with much experience with cabal
21:56:57 <Axman6> malcolmw: you've got some fairly well known hackage packages don't you? HsColour?
21:57:20 <ivanm> haxml
21:57:21 <malcolmw> Axman6: yeah, HsColour, cpphs, HaXml
21:57:22 <ivanm> polyparse
21:57:22 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
21:57:24 <ivanm> etc.
21:57:36 * ivanm wonders if that message is from him...
21:57:51 <malcolmw> ivanm: it is
21:57:55 <ivanm> heh
21:57:58 <ivanm> in that case, nvm
21:57:58 <Axman6> malcolmw: would you like to join us in #hackage? someone with your experience would be fantastic :)
21:58:05 <ivanm> whatever complaint it was about, I worked it out
21:58:18 <malcolmw> ivanm: about parsers being too lazy
21:58:33 <malcolmw> ah, yes, 8 days ago
21:58:47 <ivanm> malcolmw: IIRC, it was that backtracking only works if its that parser that fails
21:58:54 <ivanm> if the next parser fails, it won't backtrack
21:59:16 <malcolmw> ivanm: something like that, yes.
21:59:34 <ivanm> that is, (string "foo" `onFail` string "foobar") >> string "baz" will fail on "foobarbaz"
21:59:55 <ivanm> in the end, I re-arranged the parsing order to ensure longer ones went first
22:00:05 <malcolmw> ivanm: absolutely, you need to try the longest match first
22:00:13 <ivanm> oh, and a lot of "well, let's parse it as a string and _then_ try to work out if it was actually meant to be a number" :s
22:01:12 <ivanm> admittedly, most of my problems were from quickcheck generating stupid examples...
22:01:42 <junmin_> @src sum
22:01:43 <lambdabot> sum = foldl (+) 0
22:02:43 <ivanm> and that definition really annoys copumpkin ;-)
22:02:57 <Axman6> really annoys me too
22:03:24 <malcolmw> foldl' would be a better choice, but we're stuck with the space-leaking version
22:03:49 <Axman6> i think that sum' should be a standard function
22:03:52 <ivanm> malcolmw: copumpkin wants foldr ;-)
22:04:05 <ivanm> for use with Nat
22:04:11 <Axman6> bah
22:04:26 <ivanm> humbug!
22:04:27 <malcolmw> Nat doesn't exist though, does it?
22:04:46 <ivanm> Nat or Natural; one of them does in some package or another
22:04:50 <ivanm> @type 3 :: Nat
22:04:54 <lambdabot> Not in scope: type constructor or class `Nat'
22:04:56 <ivanm> @type 3 :: Natural
22:04:58 <lambdabot> Natural
22:05:03 <Axman6> bloody hell, they only just release the PS2 in brazil
22:05:16 <ivanm> PS/2 ports?
22:05:17 <ivanm> ;-)
22:05:27 <Axman6> > sum [1,1..] :: Natural
22:05:33 <lambdabot>   mueval-core: Time limit exceeded
22:05:36 <Axman6> :(
22:05:47 <Axman6> > 2 :: NAtural
22:05:49 <lambdabot>   Not in scope: type constructor or class `NAtural'
22:05:49 <Axman6> > 2 :: Natural
22:05:50 <malcolmw> hoogle doesn't know about Natural
22:05:52 <lambdabot>   2
22:06:05 <Axman6> >_< i want my S (S Z)!
22:06:15 <ivanm> > 3 < genericLength [1..] :: Nat
22:06:17 <lambdabot>   Not in scope: type constructor or class `Nat'
22:06:17 <ivanm> > 3 < genericLength [1..] :: Natural
22:06:19 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
22:06:19 <lambdabot>         against ...
22:06:33 <ivanm> > (3 :: Natural) < genericLength [1..]
22:06:35 <lambdabot>   True
22:07:41 <Axman6> ok, i'm going to sleep. i've had three early mornings with the SES in a row doing hard work, and i'm stuffed. nap time!
22:08:06 <malcolmw> -package numbers apparently
22:08:08 <aavogt> @localtime Axman6
22:08:13 <lambdabot> Local time for Axman6 is Fri Nov 27 17:11:55 2009
22:08:13 <ivanm> Axman6: heh
22:08:32 <ivanm> Axman6: well, I"m going to be heading off to the airport in about an hour
22:08:37 <ivanm> so I may see you tomorrow...
22:08:47 <malcolmw> oops, that package was written by lennart, my boss :-)
22:08:57 <Axman6> yeah, we'll organise something tomorrow. have a good flight :)
22:09:25 <ivanm> malcolmw: heh
22:09:30 <ivanm> cya!
22:09:42 <ivanm> malcolmw: heh
22:09:49 <ivanm> oh, whoops, already heh'd that comment :s
22:10:14 <aavogt> ivanm: heh
22:10:15 <Axman6> malcolmw: ha :)
22:10:39 <ivanm> there's also the nat package
22:10:51 <ivanm> malcolmw: yeah, but he didn't upload it...
22:47:05 <manju> can anyone point me to a sample haskell source file
22:47:12 <manju> like a stand alone program ?
22:47:31 * manju doesn't even know what an haskell program looks like :-|
22:48:46 <c_wraith> manju
22:48:47 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9809
22:48:53 <c_wraith> that's a complete haskell program
22:49:01 <mxc> on hackage.haskell.org most of the doucmentation is linked to source code
22:49:21 <manju> cool...thanks :-)
22:49:32 <manju> that is exactly what I wanted
22:51:39 <mxc> so yesterday, I was talking about wrapping numbers (Double, etc)  up in newtype Robust a = Robust a Either a for safe calculations.  it took a 30x speed hit. EvilTerran suggested using CPS instead with somehting like
22:51:40 <mxc> data Robust a = forall c. R ((String -> c) -> (a -> c) -> c)
22:51:40 <mxc> trying to create instances for applicative, and for the life of me, can't do it
22:52:26 <mxc> fmap and pure are easy:  fmap f (R r) = R (\x y -> r x (y . f)), pure  a = R (\_ x ->  x a)..  (<*>) is killing me
22:54:07 <ddarius> mxc: Use djinn.
22:54:18 <manju> main = do
22:54:20 <manju>   ls0 <- flit(ls)
22:54:21 <manju>   print ( max (ls0)
22:54:31 <manju> what is wrong with this code ?
22:54:42 <mxc> oooh
22:54:44 <mxc> looks interesting
22:54:59 <manju> I want to assign output of flit(ls) to ls0 and print the max in ls0 ?
22:55:05 <c_wraith> manju: depends on what "flit" does
22:55:15 <manju> flit returns an array
22:55:16 <c_wraith> also, your parens are unbalanced
22:55:22 <manju> ah
22:55:25 <c_wraith> What's the exact type of flit?
22:55:39 <manju> flit is a function
22:55:51 <c_wraith> functions have types
22:56:01 <manju> flit ([]) = []
22:56:03 <manju> flit (h:xs) = h : flit ([x | x <- xs, x `mod` h > 0])
22:56:04 <manju> like this
22:56:11 <Niccus> I think you need to use let ls0 = flit(ls) instead...?
22:56:17 <Saizan_> that returns a list
22:56:23 <Saizan_> and yeah, you need let
22:56:36 <manju> sieve.hs:7:6: parse error on input `='
22:56:52 <Saizan_> wrong indentation, maybe?
22:57:23 <Saizan_> also, you don't wrap arguments in parentheses, you use parentheses to group expressions
22:57:34 <Saizan_> @paste
22:57:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:57:53 <Saizan_> manju: you could paste the code there ^^ and we'd take a look
22:58:14 <manju> ok...wait
22:59:00 <manju> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5118#a5118
22:59:59 <manju> I got tired of doing stuff interactively in ghci and wanted to write my first program :-(
23:00:09 <Saizan_> that looks correct, actually
23:00:17 <Jedai> manju: "realToFrac 600851475143" you don't need to write realToFrac
23:00:45 <manju> Jedai: but it works ?
23:00:48 <manju> I get the list
23:00:50 <manju> I printed it
23:01:08 <Jedai> manju: integer literals are polymorphic, they're of the type (Num a => a) which means they'll be translated to the correct type (if it's an instance of Num) automatically
23:01:55 <Saizan_> manju: you defined your own max, i guess?
23:02:04 <mxc> @djinn type C a = (a -> r) -> r
23:02:04 <lambdabot> Cannot parse command
23:02:13 <Saizan_> otherwise you've to use maximum
23:02:24 <Saizan_> @djinn-add type C a = (a -> r) -> a
23:02:24 <lambdabot> Error: Undefined type variable r
23:02:32 <manju> no
23:02:34 <Saizan_> @djinn-add type C r a = (a -> r) -> r
23:02:40 <Jedai> manju: max is normally of type (Ord a) => a -> a -> a
23:02:45 <mxc> trying to follow this example: http://lambda-the-ultimate.org/node/1178
23:02:48 <manju> I haven't defined my own max
23:02:57 <manju> ah
23:02:59 <Jedai> manju: in other words it choose the max between two values, not in a list
23:03:06 <Jedai> :t max
23:03:09 <lambdabot> forall a. (Ord a) => a -> a -> a
23:03:19 <manju> ah
23:03:23 <Niccus> :t maximum
23:03:25 <lambdabot> forall a. (Ord a) => [a] -> a
23:03:53 <manju> Jedai: that was what was wrong
23:04:05 <Jedai> manju: maximum is the correct function in your case, or you could write it yourself as "maximum (x:xs) = foldl' max x xs"
23:04:20 <Saizan_> manju: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5118#a5119 <- i've cleaned a bit on style, also
23:05:16 <Saizan_> mxc: the commands on the djinn repl are splitted over different lb commands, you can also cabal install djinn though
23:05:17 <manju> Saizan_: cool..that indeed looks more haskellish :p
23:05:31 <mxc> i'm running it locally too
23:05:45 <mxc> ty though
23:06:13 <Saizan_> i don't see where r is coming from in that example thoug
23:07:02 <mxc> yeah, thats what got me hoping it would work w/ existential types
23:08:44 * manju waits as ghci uses 100% CPU
23:08:46 <Saizan_> with higher-rank types it becomes undecidable afaiu
23:09:49 <Saizan_> though your Robust type is quite weird, it looks useless in fact
23:10:28 <Saizan_> are you sure you don't want data Robust a = R (forall c. (String -> c) -> (a -> c) -> c) , instead?
23:12:35 <Saizan_> your definition is isomorphic to (), because when you unwrap R you know nothing about c which is the result, so at best you can pass it around doing nothing with it
23:13:10 <Saizan_> and you'd have to pass functions isomorphic to (const undefined) as arguments
23:19:51 <mae_lappy> can someone riddle me this? why is there no functions for getting a signed integer from a bytestring -- only words...
23:19:51 <mae_lappy> (pktRaw pkt)
23:20:01 <mae_lappy> http://hackage.haskell.org/packages/archive/binary-strict/0.4.6/doc/html/Data-Binary-Strict-Get.html
23:20:04 <mae_lappy> (in binary package)
23:25:46 <b6> mae_lappy: i agree that's not nice, but i guess you can fix it to be signed.
23:26:22 <mae_lappy> damn..
23:27:08 <mae_lappy> is there another module i should know about that is more exhaustive
23:27:13 <c_wraith> mae_lappy:  Look at the binary package
23:27:21 <c_wraith> oh, you are
23:27:22 <c_wraith> nevermind
23:27:24 <mae_lappy> the binary package has encode
23:27:28 <mae_lappy> so you can do
23:27:39 <mxc> saizan_ i think you might be right
23:27:40 <mae_lappy> or decode
23:27:41 <mxc> thanks!
23:27:49 <c_wraith> I guess I wanted a word64, not an Int64, so my memory is all flawed
23:27:52 <mae_lappy> decode x :: Int32
23:27:59 <mae_lappy> but problem is that
23:28:04 <mae_lappy> binary only works with lazy bytestrings :\
23:28:17 <b6> mae_lappy: i think there's binary-strict.
23:28:25 <mae_lappy> yeah
23:28:28 <mae_lappy> it suffers from the same problem
23:28:33 <mae_lappy> no int
23:28:35 <mae_lappy> just word
23:28:53 <b6> well, yeah. but just do the subtraction or however you want to do it yourself.
23:29:01 <b6> it's not nice but doesn't seem like a showstopper.
23:29:27 <Saizan_> mae_lappy: there's a Binary instance for Int, surely?
23:29:38 <Saizan_> mae_lappy: or do you need to specify endianess?
23:30:01 <mae_lappy> yes there is an instance of binary
23:30:20 <mae_lappy> but encode / decode only works with lazy bytestrings
23:30:21 <Saizan_> you can use get and put
23:30:27 <mae_lappy> strict is missing the encode / decode stuff
23:30:34 <mae_lappy> get and put hmm
23:30:34 <Saizan_> get works in the Get monad
23:31:25 <mae_lappy> ahh
23:32:19 <Saizan_> though binary-strict doesn't have the Binary class, not sure what you actually need
23:32:23 <Saizan_> ?hoogle readInt
23:32:24 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
23:32:25 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
23:32:25 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
23:32:33 <Saizan_> there are those though
23:32:58 <b6> i made a package that compiles and installs ok and can be used in ghci. but when i try to build another package against it, i get 'unknown symbol: atexit'.
23:33:51 <Saizan_> also, it's easy to go from a strict bytestring to a lazy one
23:34:18 <mae_lappy> ic
23:34:25 <mae_lappy> you are the best
23:35:16 <Saizan_> b6: are you using make?
23:35:21 <Saizan_> b6: err, --make
23:35:30 <b6> Saizan_: no, like cabal build.
23:37:02 <Saizan_> maybe atexit comes from some C lib that ghci has linked in by default
23:39:19 <b6> ok. it's in my /usr/lib/libc_nonshared.a.
23:41:12 <Saizan_> well, what i know is that extra-libraries is the field used for C lib deps, though i don't know if it applies here
23:42:26 <b6> igloo is saying in some post that i'm supposed to wrap atexit somehow.
23:42:57 <bos> @hoogle IORef
23:42:57 <lambdabot> module Data.IORef
23:42:58 <lambdabot> Data.IORef data IORef a
23:42:58 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
