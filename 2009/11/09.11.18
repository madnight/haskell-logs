00:00:21 <dankna> it's basically "you can't write things that can shell out to other things"; it's not "you can't write self-modifying code"
00:02:28 <mmorrow> dankna: ah, hmm. i thought that any sort of self-modifying or machine-code-generating-in-order-to-be-run (or something like a linker/loader) were all verboten
00:03:02 <dankna> no, the sort of thing the policy is intended to exclude is like... a Nintendo emulator that can load ROM files from the network
00:03:03 <mmorrow> to prevent programs from creating their own little runtime environment to host non-authorized progs
00:03:18 <mmorrow> dankna: ah, i see.
00:03:21 <shrughes> that's funny because the hp-48 emulator is programmable
00:03:40 <dankna> shrughes: you'll find exceptions to all their policies, it's not very consistent
00:04:26 <mmorrow> dankna: what about a compiler?
00:04:43 <dankna> I'm not certain and I don't think anybody has tried to find out
00:05:27 <shrughes> what about a program that downloads and executes programs with proofs of termination?
00:05:39 <dankna> amusing concept
00:06:01 <dankna> I doubt that would be any different from any other program that downloads and executes programs, but... who knows.
00:06:05 <c_wraith> Is there a universal Monad instance for applicative somewhere?
00:06:07 <kmc> Agda for iPhone?
00:06:08 <dankna> write one and find out.
00:06:13 <kmc> c_wraith, no, it would cause problems :/
00:06:18 <Cale> Heh, there are programs with proofs of termination which still use impractically large amounts of resources to run
00:06:25 <Cale> c_wraith: no
00:06:42 <Cale> c_wraith: because it is impossible
00:06:52 <c_wraith> Err.  I may have asked the question backwards.
00:07:18 <Cale> The other way around is a problem for technical reasons
00:07:20 <c_wraith> One of the two ways is possible, and that's the one I was asking about
00:07:21 <kmc> you can't write "instance (Monad m) => Applicative m" without causing overlap problems
00:07:31 <kmc> even though the code would be straightforward
00:07:51 <c_wraith> the code would be all of two lines. >_>
00:07:54 <kmc> basically, the class Monad should have been defined as "class (Applicative f) => Monad f"
00:08:04 <kmc> and Applicative as "class (Pointed f) => Applicative f"
00:08:27 <Cale> The reason is that when deciding which instance to select while compiling a module, it's impossible to make use of the fact of whether or not another instance exists.
00:08:48 <Cale> Well, you could theoretically make use of the fact that an instance *does* exist.
00:09:02 <Cale> But you can't rely on another instance *not* existing.
00:09:08 * hackagebot upload: arbtt 0.4.3 - Automatic Rule-Based Time Tracker (JoachimBreitner)
00:09:09 <c_wraith> but because of orphan instances, you could never know an instance doesn't exist
00:09:11 <c_wraith> I see
00:09:25 <kmc> anyone else just get a buttload of DCC spam?
00:09:30 <Cale> Yeah, any future module which imports the one you're compiling might define a new instance of a class.
00:09:44 <Zao> kmc: Thankfully not.
00:09:50 <kmc> what's going on
00:09:54 <kmc> who do i complain to?
00:10:01 <dankna> anyone you feel like
00:10:12 <dankna> but they'll all have exactly the same ability to do something about it
00:11:26 <kmc> okay
00:11:26 <c_wraith> well, I wrote the full 2-line applicative instance for the specific monad I have.  :)
00:13:34 <c_wraith> How much code in the universe would be broken if Monads were actually explicitly defined in terms of Applicatives, beyond the things that would need new Applicative instances written?
00:13:57 <dolio> Not much.
00:14:54 <c_wraith> how painful would a guerilla-rewrite to implement that be?
00:17:04 <Heffalump> very
00:17:21 <c_wraith> figures
00:17:26 <FunctorSalad> wouldn't gain you a lot either though
00:17:47 <FunctorSalad> (missing Applicative instances are annoying though)
00:17:57 <c_wraith> It would mean I wouldn't have to remember the pragma to turn off orphan instance warnings right now...  :)
00:18:10 <apartado> hi, can anyone help me? I need to know how i can "printf" (C) a question and receive a value from the user (a number) and keep it in a variable to use in subsequent functions... how can this be done in haskell? I still havent studied monads...
00:18:15 <dolio> It'd get you some nice things.
00:18:21 <FunctorSalad> c_wraith: I always get that one wrong too
00:18:36 <dolio> There's a lot of duplication of functions for Applicatives and Monads.
00:18:56 <kmc> the past is a grotesque animal
00:19:03 <FunctorSalad> :o
00:19:20 <ehamberg> apartado: http://random.axman6.com/blog/?page_id=70
00:19:27 <jandem> can an interpreter written in Haskell have the same speed as one written in C/Java? Or is it unlikely?
00:19:31 <Cale> apartado: You would use IO, like  do putStrLn "What's your name?"; name <- getLine; ... use name here ...
00:19:40 <kmc> jandem, yes
00:19:49 <kmc> probably faster than Java (assuming a JVM-based implementation)
00:20:03 <kmc> i don't know why you say "C/Java" as they have wildly different performance characteristics
00:20:17 <apartado> Cale: so, the "getline" can be used with numbers, not only for characters or strings?
00:20:23 <kmc> :t readLine
00:20:24 <lambdabot> Not in scope: `readLine'
00:20:30 <Cale> apartado: getLine in particular is for strings.
00:20:42 <Cale> apartado: You can either use read on the resulting string to parse it
00:20:51 <Cale> (as whatever type is necessary)
00:20:55 <jandem> kmc: I mean, C-speed would be best, but Java speed would be excellent too
00:20:57 <Cale> Or, you can use  readLn
00:20:59 <Cale> :t readLn
00:21:00 <lambdabot> forall a. (Read a) => IO a
00:21:05 <kmc> jandem, write it and find out :)
00:21:17 <jandem> kmc, are the examples of fast interpreters? i searched but only found Pugs
00:21:22 <jaspervdj> :t gets
00:21:23 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
00:21:38 <kmc> jandem, you can probably find some.  one of the main things haskell is used for is implementing other, often domain-specific, languages
00:21:43 <FunctorSalad> are interpreters special performance-wise?
00:21:52 <apartado> Cale: can you give me an example? i mean, numberOfPlayers is the "variable", how can I make the user define its value?
00:21:53 <kmc> jandem, if you want to look at totally arbitrary benchmark programs, the Shootout has GHC-Haskell outperforming Sun-JVM-Java on most programs
00:22:04 <kmc> Sun-JVM-Java6--server-Java that is
00:22:34 <jandem> kmc, if it does the same for interpreters that would be awesome :)
00:22:37 <c_wraith> woot.  finally tracked down the right pragma.
00:22:47 <kmc> jandem, i think you won't be disappointed with performance
00:22:51 <jandem> it would be nice to have llvm bindings to generate low level code ;)
00:22:53 <Cale> apartado: numberOfPlayers <- readLn
00:22:54 <kmc> it will matter more the details of the language you implement
00:22:57 <ksf> there's got to be a way to implement a decent hashtable in haskell
00:22:58 <kmc> and yes there are LLVM bindings
00:23:03 <ksf> in fact, I know that there is.
00:23:07 <Cale> apartado: and then just use numberOfPlayers as an Integer somewhere later on
00:23:07 <apartado> Cale: thats all?
00:23:18 <kmc> ksf, we have Judy arrays now (not a hashtable, but similar goals)
00:23:29 <ksf> the question is why the current shootout entry is 10 times slower than the c++ one
00:23:30 <kmc> i think hashtables are not all they're cracked up to be
00:23:32 <apartado> Cale: ok, thank you very much
00:23:37 <jandem> kmc, ok i will try to build a minimal prototype and benchmark that... It will anyway greatly enhance my haskell skills :)
00:23:39 <Cale> apartado: and, provided that the type is not ambiguous, type inference will ensure that the right parser is selected
00:23:45 <kmc> jandem, cool.  we're always here to help :)
00:23:46 <Cale> (at compile time)
00:23:52 <apartado> Cale: ok, thanks :)
00:23:55 <kmc> jandem, what sort of language are you implementing?
00:24:14 <ksf> does anyone know whether the shootout people actually rejected entries that use other maps?
00:24:19 <Cale> apartado: Note however that numberOfPlayers doesn't refer to a box in which there's an Integer value
00:24:30 <ksf> I can't find anything on the map
00:24:32 <ksf> *net
00:24:34 <Cale> (like it would in C, say)
00:24:48 <Cale> apartado: It refers directly to the value which the user enters there, and is immutable.
00:25:11 <FunctorSalad> kmc: what are these goals?
00:25:32 <FunctorSalad> (when would I use one?)
00:25:36 <kmc> FunctorSalad, associative container optimized for speed
00:26:01 <apartado> Cale: thats fine :) thank you
00:26:04 <FunctorSalad> so should I use it instead of Data.Map when optimizing?
00:26:08 <kmc> perhaps
00:26:14 <kmc> you should try less invasive things like IntMap first
00:26:17 <apartado> Cale: bu bie
00:26:35 <kmc> Judy arrays are implemented using 256-ary tries with several tricks for node representation. a particular goal was minimizing the number of potential cache misses
00:26:42 <kmc> they fail the beer-coaster test miserably
00:26:51 <dmorti> Hi all, I keep getting errors like "Codec.Compression.Zlib: premature end of compressed stream" when I try to install Hackages using cabal.  Any ideas what's going on?
00:27:21 <FunctorSalad> kmc: that doesn't sound like a disadvantage yet :)
00:27:29 <FunctorSalad> except complex implementation
00:27:37 <Heffalump> Judy arrays are stuck in IO and you have to use ForeignPtr to interface with them, IIRC
00:27:54 <kmc> also the keys have to be machine words, don't they?
00:27:56 <Heffalump> Hash tables are slow mainly because the GC doesn't deal very well with mutable arrays.
00:28:16 <Heffalump> kmc: yes, hence ForeignPtr (or any one-word unboxed data)
00:28:40 * kmc would like to see hash tries as a pure datastructure
00:29:06 <c_wraith> isn't gmap really close to that?
00:29:08 <FunctorSalad> ok, IO is not so nice of course
00:30:07 <kmc> anyone here have opinions about the quality of Data.Hash?
00:31:53 <FunctorSalad> if I understand these types correctly, frozen judy arrays are IO-free
00:31:55 <mmorrow> kmc: Judy arrays are implemented with 20,000+ lines of C code that take into account things like cache-line sizes and stuff
00:32:11 <Heffalump> which cache-line size? :-)
00:32:13 <mmorrow> and they're actually tries
00:32:24 <FunctorSalad> if I knew what a cache line is...
00:32:43 <mmorrow> Heffalump: i think actually one or a couple particular fixed sizes
00:32:45 <mmorrow> :|
00:32:53 <FunctorSalad> but sounds really high-tech ;)
00:33:14 <mmorrow> and from what i understand, if you wanted to support a different size, it'd take non-trivial changes to the code
00:33:38 <mmorrow> but that might have just been a hater talking trash (i read this on the internets :)
00:33:48 <Heffalump> I suspect you read the same article as me
00:33:49 <kmc> FunctorSalad, do you know how data cache works generally?
00:34:02 <ksf> Heffalump, the gc does deal with alloca'd memory just fine.
00:34:06 <Heffalump> what we need is to implement them in Haskell and get the fast code out.
00:34:07 <ksf> that is, it doesn't exist.
00:34:08 <mmorrow> Heffalump: was it benchmarking a hash-table implem in C against judy?
00:34:17 <Heffalump> I think so, yes.
00:34:19 <mmorrow> Heffalump: and the guy was super bitter
00:34:20 <mmorrow> :)
00:34:38 * mmorrow is half joking
00:34:47 <Heffalump> well, not jdh30 levels of bitterness, but yeah
00:34:56 <mmorrow> heh
00:34:58 <kmc> if you want the gory details on judy arrays: http://judy.sourceforge.net/doc/shop_interm.pdf
00:35:01 <FunctorSalad> kmc: uh, if introduction to CS counts...
00:35:13 <kmc> FunctorSalad, a cache line is the smallest unit which can be loaded into cache
00:35:20 <Heffalump> what we need is to figure out how to implement them in Haskell :-)
00:35:21 <ksf> they won't let us use judy arrays in the shootout, will they?
00:35:30 <mmorrow> Heffalump: totally
00:35:55 <kmc> they assume the cache is 16 machine words, meaning 64 resp. 128 bytes for 32 resp. 64-bit judy arrays
00:36:02 <Heffalump> getting that kind of low-level memory layout control might be painful, unless the only issue is getting the arrays the right size and alignment
00:36:19 <kmc> (the implementations for 32-bit vs. 64-bit are actually different, not just a macro substitution of types)
00:36:19 <FunctorSalad> what would be the point in implementing them in haskell if you need such exact control over the machine?
00:36:30 <ksf> FunctorSalad, inlining
00:36:31 <Heffalump> FunctorSalad: a nicer interface than IO and proper GC integration
00:36:42 <kmc> s/cache/cache line/
00:36:44 <ksf> you can't inline ffi functions and have constant method call overhead
00:36:46 <kmc> but they also say it will work all right on machines with different cache line sizes
00:37:26 <FunctorSalad> ah, learned something new :) (inlining/ffi)
00:37:54 <c_wraith> well, very little that optimizes for a particular cache line size doesn't work on other sizes...  It just doesn't get the big efficiency boost
00:38:03 <ksf> FunctorSalad, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12290#a12290
00:38:07 <ksf> try to do that in C
00:38:16 <kmc> it was optimized for PA-RISC or ia64 or some shit
00:38:38 <mmorrow> ksf: is using haskell to generate the C cheating?
00:38:48 <ksf> I'm generating haskell
00:38:48 <mmorrow> :)
00:38:50 <ksf> not c
00:39:02 <ksf> well ghc generates c
00:39:02 <mmorrow> right, but you said "try to do that in C"
00:39:22 <mmorrow> so i said, is it cheating if i /use/ haskell to generate the C to do it?
00:39:25 <kmc> are the shootout programs compiled via-C or no?
00:39:27 <ksf> where "that" includes having the nucleotide data in the form as it is.
00:39:35 * mmorrow is just messing around
00:39:42 <ksf> kmc, depends on what's faster.
00:39:57 <kmc> so you get to pick
00:40:00 <ksf> in the case of my fasta code, it's a 260% difference
00:40:01 <mmorrow> but that would be neat to see someone have a go at generating C with haskell to beat the C solution
00:40:24 <ksf> that's basically what I'm doing.
00:40:34 <ksf> I'm also being smarter about lookups and IO, though.
00:40:51 <mmorrow> if the GC runs more than zero times, it's not the same
00:40:54 <mmorrow> :)
00:41:00 <c_wraith> I like the huge chunk of template haskell code in there. :)
00:41:07 * mmorrow is just being difficult now
00:42:44 <mmorrow> ksf: TH ftw
00:43:09 <ksf> also, it's vitally important to leave out most strictness annotations.
00:43:16 <Heffalump> that hpasted code looks like C!
00:43:28 <ksf> I bet some shootout entries are slower than nescessary because they're scattered all over the place
00:43:32 <copumpkin> lol
00:43:35 <mmorrow> gah! ksf and kmc are both green, and i can never tell who's who when they both talk at once
00:43:44 <copumpkin> aw
00:43:45 <kmc> i get that a lot
00:43:54 <mmorrow> have to revert from identify by color and length to looking at letters
00:44:18 <c_wraith> they share the same letter-height profile
00:44:20 <mmorrow> and you both start with a k
00:44:22 <mmorrow> yeah
00:44:23 <c_wraith> and the same first letter
00:44:31 <c_wraith> oh, wait, no
00:44:34 <mmorrow> the f
00:44:35 <c_wraith> f is taller than c
00:44:40 <mmorrow> but the end is the end
00:44:41 <c_wraith> ok, I can tell them apart now!
00:44:47 <kmc> reading is hard
00:44:55 <mmorrow> lets go shopping!
00:45:04 <c_wraith> it's really hard to not combine you into kfc
00:45:06 <dankna> shopping is hard, let's do math
00:45:13 <kmc> kennedy fried chicken
00:46:13 <notkmc> has anyone of you ever implemented a fast C hashtable?
00:46:24 <dankna> define fast
00:46:26 <dankna> I've implemented it
00:46:40 <Lycurgus> yes, but not recently
00:46:42 <dankna> I haven't benched it and strained to get every last ounce of performance out of it
00:47:02 <ivanm> dankna: does it out-perform a non-fast hashtable? :p
00:47:12 <dankna> ... for appropriate definitions thereof...
00:47:13 <notkmc> Lycurgus, can you make http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=ghc&id=3 about 10 times faster?
00:47:57 * notkmc thinks that code is a complete mess
00:48:00 <Lycurgus> since were off-topic, what's up with Chrome?
00:48:04 <kmc> our internet reputation depends on it!
00:48:22 <dankna> I'm having trouble remembering what notkmc's "real" name is
00:48:29 <dankna> real in quotes because nobody hear is using their real name (except me :D)
00:48:34 <dankna> *here
00:48:48 <Heffalump> my wife calls me Heffalump IRL sometimes..
00:48:49 <mmorrow> @djinn Not(Not(Not kmc)) -> Not kmc
00:48:49 <lambdabot> f a b = void (a (\ c -> c b))
00:48:55 <dankna> does she?  haha, awesome
00:49:00 <mmorrow> Heffalump: heh
00:49:05 <kmc> triple negation ftw
00:49:14 <copumpkin> @djinn Not (Not mmorrow) -> mmorrow
00:49:14 <lambdabot> -- f cannot be realized.
00:49:17 <Lycurgus> I use my real name but this is a nick I preserve because it's registered in the Wikipaedia
00:49:21 <mmorrow> copumpkin: :o
00:49:22 <copumpkin> damn, it doesn't know about oleg's super duper trick ;)
00:49:31 <kmc> whatsat?
00:49:36 <Lycurgus> *wikipediae
00:49:37 <dankna> Lycurgus: well, that's fair
00:49:41 <kmc> oleg proved that constructive logic is equivalent to classical logic?
00:49:45 <kmc> wikipÊdia
00:50:01 <copumpkin> he recently posted a way to get LEM in constructive logic using a universally quantified monad
00:50:08 <kmc> oh dear
00:50:09 <copumpkin> can't say I really understood much :)
00:50:33 <kmc> do you have a link?
00:50:37 <kmc> i'm up for a good head-splosion
00:50:58 <copumpkin> http://lists.seas.upenn.edu/pipermail/types-list/2009/001396.html
00:51:19 <copumpkin> http://okmij.org/ftp/Computation/lem.html is prettier
00:52:04 <FunctorSalad> what do the "mirc colors" in xchat mean anyway?
00:52:04 <copumpkin> "We have thus confirmed the old result that LEM is intuitionistically justified for decidable propositions."
00:52:08 <FunctorSalad> is it just for reference?
00:52:22 <copumpkin> there are special control codes that allow people to format their messages
00:52:25 <copumpkin> it's obscene
00:52:34 <Phyx-> coloorss
00:52:39 <Phyx-> coloorss
00:52:40 <Phyx-> lol
00:53:10 * shachaf makes note to look at that page tomorrow.
00:53:13 <FunctorSalad> copumpkin: set your saturation to 100% now :o
00:53:19 <Zao> FunctorSalad: There's a bunch of incompatible colour standards for IRC.
00:53:20 <shachaf> (Except that tomorrow is already today.)
00:53:27 <Zao> Most of which are thankfully censored by +c mode on channels.
00:53:40 <Phyx-> I go to bed, and wake up, and the same people are talking :P
00:53:43 <kmc> "weak reductio -- proving the negation of a proposition A by assuming A and exhibiting a contradiction -- is intuitionistically justified.... Strong reductio -- proving A by contradiction with the assumption of NOT A -- is equivalent to... the law of excluded middle"
00:53:52 <ksf> another possibility would be to try to enrage the internets against the braindeadness of k-nucleotide's requirements
00:53:52 <kmc> i don't understand the difference
00:54:34 <Phyx-> arrgg not another tab..
00:54:46 * Phyx- likes to start a petition to banish flash from the internet
00:55:02 <shachaf> kmc: Between proving not A by assuming A and proving A by assuming not A?
00:55:02 <dankna> quite
00:55:07 <FunctorSalad> wow xchat is a lot prettier with saturated colors
00:55:14 <copumpkin> ew
00:55:21 <kmc> aha
00:55:26 <kmc> thanks
00:55:29 <Phyx-> FunctorSalad: i would have expected you to be using irssi :P
00:55:32 <FunctorSalad> for the nicks :p
00:55:42 <FunctorSalad> Phyx-: how so?
00:56:50 <Phyx-> FunctorSalad: i'd figure you'd be used to commandline things, so irssi was just a guess :P
00:57:29 <shachaf> FunctorSalad: irssi (or another terminal client) lets you keep your session in a screen, on a remote server.
00:57:32 <ksf> telnet!
00:57:53 <FunctorSalad> why would I want to do that? ;)
00:58:09 <Phyx-> ksf: yeah, i did that a few times, rather annoying when you make a typo
00:58:24 <shachaf> FunctorSalad: So that your client is always running and has logs.
00:58:53 <dankna> or you could just leave your client always running :D
00:59:02 <Phyx-> FunctorSalad: you can alsoo upgrade irssi without having to disconnect :D
00:59:15 <kmc> this shit is nuts
00:59:32 <shachaf> dankna: But that doesn't help if you reboot/shut down/move to a different computer/etc.
00:59:42 <dankna> shachaf: true, of course
00:59:49 <FunctorSalad> "<Phyx-> I go to bed, and wake up, and the same people are talking :P" hehehe
00:59:59 <shambler_> hehe
01:00:06 <Phyx-> :P
01:00:17 <shachaf> Someday someone will make a *working* graphical equivalent of screen, anyway.
01:00:27 <dankna> that would be nice.
01:00:36 <Phyx-> dankna: remote desktop? :P
01:00:42 <dankna> I'm not shachaf
01:00:54 <shambler_> x server can work other network
01:01:01 <dankna> remote desktop has a performance penalty.  if it hooked in at the OpenGL level that would be different.
01:01:01 <Phyx-> oops
01:01:08 <dankna> but it doesn't - it hooks in at roughly the framebuffer level.
01:01:11 <shachaf> Phyx-: Sure, or SSH forwarding with VNC, or NX, or something. Nothing works all that nicely.
01:01:29 <shachaf> Sigh... If we were all using NeWS...
01:02:10 <ehamberg> scree: the quassel (gui) irc client has a server/client architecture
01:02:43 <shachaf> Wow, people are sure having trouble addressing me today.
01:02:59 <shachaf> ehamberg: That is interesting.
01:03:03 <Phyx-> i've never experienced any such penalties with rdp
01:03:05 * shachaf investigates.
01:03:45 <mufasis> can someone explain to my why haskell is good
01:04:03 <kmc> @faq Can Haskell explain why Haskell is good?
01:04:03 <lambdabot> The answer is: Yes! Haskell can do that.
01:04:20 <shachaf> @protontorpedo
01:04:21 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
01:04:21 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
01:04:25 <kmc> mufasis, perhaps http://haskell.org/ can help you
01:04:26 <Phyx-> shachaf: i use remote desktop daily, i even use it to code remotely. never even had so much as a lag, infact, it could even keep up with some video playing
01:04:38 <shachaf> Phyx-: Huh.
01:04:39 <kmc> @quote gnarley
01:04:39 <lambdabot> No quotes match. Take a stress pill and think things over.
01:05:01 <kmc> well that was productive
01:05:05 <Phyx-> i keep confusing you and dankna
01:05:37 <shachaf> I believe you are only confusing yourself. :-)
01:05:51 <shachaf> Wow, Quassel sure has a lot of dependencies.
01:05:52 <Phyx-> I just woke up :)
01:05:56 <fasta> Phyx-, which remote desktop do you use?
01:06:35 <dankna> Apple Remote Desktop is a very nice one and just let me take this moment to plug it. :)
01:06:44 <Phyx-> fasta: both 5 & 6
01:07:03 <fasta> Phyx-, Does that work also with intermediate machines?
01:07:05 <Phyx-> on windows i use mstsc, on nix i use rdesktop
01:07:15 <shachaf> Phyx-: Always with a Windows server, though, no?
01:07:22 <shachaf> dankna: Does Apple Remote Desktop use VNC?
01:07:34 <Phyx-> shachaf: yes, my work uses windows servers and i have one at home
01:07:36 <dankna> yes, but with some extensions; however it's compatible with plain-VNC servers as well.
01:07:45 * shachaf has had moderate success with NX in the past.
01:07:49 <fasta> Phyx-, I want to go from machine A (Linux) through a router, through another Linux machine, to control another Windows machine.
01:07:51 <Phyx-> fasta: you mean connecting to a machine then connecting to another one?
01:08:19 <shachaf> But anyway -- I run my IRC client on a server! There's no real excuse to have GTK or Qt or an X server running *on the server*.
01:08:41 <Phyx-> fasta: well, i've done that before, also worked good, but was all windows in the chain though
01:09:05 <fasta> Phyx-, I basicallly want it to be fast enough for it not to be annoying.
01:09:37 <fasta> Phyx-, how much bandwidth do you need for that and which software did you use?
01:09:53 <Phyx-> fasta: i was coding on this, didn't even notice any keyboard lag
01:10:11 <fasta> Phyx-, yes, but if you are on a LAN it is different of course ;)
01:10:33 <Phyx-> ofcourse, but i was doing this home -> work :P or uni -> home
01:10:35 <fasta> Phyx-, I have only 100KB/s up speed or so.
01:11:26 <shachaf> Phyx-: I seem to remember having very significant (up to a second) delays using VNC on a 100 Mb/s network.
01:11:43 <shachaf> This was some time ago -- perhaps things have improved.
01:11:51 <Phyx-> fasta: not really sure, i have a 1Mbit/s up, seems to do the job just fine, as for the software, like i said, i use windows as the host everytime, so the software was just terminal services
01:12:11 * copumpkin feels like he's getting sucked deeper and deeper into mat
01:12:11 <copumpkin> h
01:12:33 <Phyx-> shachaf: i served up 5 sessions of VNC to a VMWare VM, and all 5 people were able to use it with minimum lag
01:12:44 <shachaf> Huh.
01:12:54 * shachaf must investigate this the next time it becomes necessary.
01:13:23 <Phyx-> shachaf: rdp 6.0 also allows you to do program only remoting
01:13:46 <fasta> Phyx-, what is "program only remoting"?
01:13:46 <shachaf> Phyx-: I'm not very likely to be using Windows.
01:14:03 <Phyx-> e.g. you can instead of getting the whole desktop, just get the program you want to run, it would look like any other program but would be running remotely
01:14:06 <Phyx-> shachaf: heheh
01:14:14 <fasta> Phyx-, just checking.
01:16:02 <Phyx-> fasta: haven't tried that particulair feature yet, so don't know how well it works, but i'd assume it would improve performance
01:16:29 <Phyx-> shachaf: rdp isn't windows only btw
01:16:46 <torba> There is function `fff :: Int -> Char -> (Int, Char)`
01:16:48 <torba> fff 100 :: Char -> (Int, Char)
01:17:09 <shachaf> Phyx-: Huh. I should investigate tomorrow.
01:17:10 <torba> how can i make a Int -> (Int, Char) prototype?
01:17:20 <torba> fff _ '2'?
01:17:25 <Zao> @type flip
01:17:25 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:17:26 <shachaf> flip fff 'a'
01:17:33 <shachaf> @src flip
01:17:34 <lambdabot> flip f x y = f y x
01:17:51 <torba> does it work for any arity?
01:17:57 <shachaf> Or (`fff` 'a').
01:18:09 <shachaf> torba: It'll swap the first and second arguments, yes.
01:18:42 <torba> Int -> Char -> Double -> (Int, Char, Double)
01:18:43 <copumpkin> :t flip (id id)
01:18:44 <lambdabot> forall b c. b -> (b -> c) -> c
01:18:50 <Zao> f :: a -> b -> c   associates to   f :: a -> (b -> c)
01:19:04 <shachaf> copumpkin: ...id id == id, you know.
01:19:07 <Zao> That is, f is a function with one argument returning a function with one returning a value
01:19:17 <copumpkin> shachaf: orly
01:19:24 <copumpkin> would never have guessed :o
01:19:25 <Phyx-> copumpkin: isn't that the same as just flip id?
01:19:28 <copumpkin> lol
01:19:29 <Phyx-> lol
01:19:40 <copumpkin> people really must think I'm dumb
01:19:40 <kmc> :t flip id
01:19:42 <lambdabot> forall b c. b -> (b -> c) -> c
01:19:53 <shachaf> copumpkin: Maybe they make the silly assumption that you're trying to help people. :-)
01:20:01 <Phyx-> copumpkin: no no, just sleepy and/or drunk today :P
01:20:14 <copumpkin> YO HO HO AND A BOTTLE OF RUM
01:20:19 <kmc> @arr
01:20:20 <lambdabot> Aye Aye Cap'n
01:20:22 * copumpkin snores loudly
01:20:23 <Phyx-> KAANPAAIII!
01:20:37 <shachaf> @arrow
01:20:37 <lambdabot> I want me grog!
01:20:51 <Phyx-> @monad
01:20:51 <lambdabot> Unknown command, try @list
01:20:58 <shachaf> @botsneak
01:20:58 <lunabot>  :o
01:20:59 <lambdabot> :)
01:21:00 <Phyx-> i bet monads feel left out
01:21:08 <shachaf> @applicativefunctor
01:21:08 <lambdabot> Unknown command, try @list
01:21:49 <shachaf> @zygohistomorphicprepromorphism
01:21:49 <lambdabot> Unknown command, try @list
01:22:14 <profmakx> in other words categorial masturbation?
01:22:57 <FunctorSalad> more like masturbation about the alleged ridiculosity of category theory
01:23:11 <FunctorSalad> (it doesn't actually sound very category-theoretical)
01:23:32 <Phyx-> about?
01:23:43 <Phyx-> how.... you know what. i don't even wanna know
01:23:44 <Phyx-> :S
01:23:52 <torba> is it possible to make a function which receives a tuple of lists and returns list of tuples `([a], [b], ..., [z]) -> [(a, b, ..., z)]`?
01:24:00 <FunctorSalad> Phyx-: what about 'about'
01:24:11 <copumpkin> torba: not without a typeclass that did all the work for you
01:24:13 <Phyx-> torba: for an n-tuple?
01:24:17 <shachaf> torba: That "..." isn't a very simple type.
01:24:32 <torba> for any tuple
01:24:43 <Phyx-> FunctorSalad: well, the about is weird, you don't M about something usually
01:24:46 <copumpkin> torba: no, tuples of different sizes are completely unrelated
01:24:47 <shachaf> torba: You can do it for a 26-tuple if you like, but the whole point of tuples in general is that their type is known at compile time.
01:24:52 <FunctorSalad> Phyx-: "to"?
01:25:09 <Phyx-> FunctorSalad: which makes more sense, but then you must be one lonely individual!
01:25:10 <torba> it is possible in C++, so i wonder if it is possible in haskell
01:25:12 <Phyx-> lol
01:25:28 <copumpkin> torba: it's transpose
01:25:31 <FunctorSalad> still not getting you
01:25:34 <Phyx-> torba: no, because like copumpkin tuples of different sizes are completely unrelated
01:25:41 <copumpkin> and it isn't really possible in c++ in the same sense either
01:26:18 <Phyx-> FunctorSalad: well... i for one don't find category theory particulairly sexy
01:26:19 <Phyx-> lol
01:26:49 <FunctorSalad> Phyx-: read more carefully?
01:26:56 <EnglishGent> hi all :)
01:27:00 * Phyx- goes back up
01:27:26 <Phyx-> hi EnglishGent
01:27:34 <Phyx-> FunctorSalad: aha, i missed a piece :P
01:27:35 <EnglishGent> that's a wide-spread problem Phyx-
01:27:51 * EnglishGent bemoans the lack of supermodels who dig category theory
01:27:52 <EnglishGent> :)
01:28:03 <Phyx-> hahaha
01:28:08 <EnglishGent> hi Phyx :)
01:28:09 <johnw> EnglishGent: they might well do, but would they admit it?
01:28:44 <EnglishGent> I see your point johnw - social stigma!
01:28:52 <shachaf> One would expect them to find model theory more to their liking, no?
01:29:14 <Phyx-> johnw: well, statistically, they wouldn't have brains AND looks no?
01:29:15 <EnglishGent> lol!
01:29:16 <johnw> yes, a person's appearance should be relatively unrelated to their brain, as with gender too; so, a lot of what we see is expected patterns
01:29:26 <EnglishGent> good one shachaf
01:30:11 * EnglishGent wonders if you can actually use that excuse to meet them :)
01:30:14 <FunctorSalad> "supermodel" isn't just good looks
01:30:20 <FunctorSalad> it's a profession
01:30:22 <EnglishGent> "well, I am studying model theory - *and*"
01:30:23 <EnglishGent> :)
01:30:36 <FunctorSalad> so it'd be not very surprising that they're not *also* mathematicians
01:30:41 <EnglishGent> hi FunctorSalad :)
01:30:48 <FunctorSalad> hai
01:30:53 <EnglishGent> FunctorSalad - accountants perhaps, tis not the same thing though
01:31:11 <FunctorSalad> ?
01:31:14 <shachaf> @go "mathematician by avocation"
01:31:15 <lambdabot> Maybe you meant: google googleit do
01:31:26 * EnglishGent actually knows at least one professional mathematican who finds it boggling how many lay people think he spends his time actually doing arithmetic
01:32:04 <Phyx-> hmmm.. nice bug on samsung's support page, every model number in the list is doubled
01:32:06 <johnw> sure, for most people that's the start of math
01:32:15 <shachaf> ...You mean professional mathematicians don't spend their time doing arithmetic?
01:32:30 * shachaf 's hopes are shattered.
01:32:34 * EnglishGent wonders is cocaine a tax deductable expense if your a supermodel?
01:32:35 <EnglishGent> :)
01:32:43 <FunctorSalad> :D
01:32:47 <EnglishGent> hi shachaf :)
01:32:49 <Phyx-> EnglishGent: no, but weed is
01:32:55 <Phyx-> atleast i think so here :P
01:33:26 <shachaf> EnglishGent: ...Hi?
01:33:28 <Phyx-> EnglishGent: here being dutchland ofcourse :P
01:34:02 <Phyx-> Interesting... why does samsung need my address in order to send me an email...
01:34:32 <EnglishGent> probably becuase who ever coded the page had been smoking too much weed Phyx
01:34:33 <EnglishGent> :)
01:35:18 <Phyx-> EnglishGent: I would expect the boxes to be moving around :P
01:36:04 <Phyx-> hmm doesn't even ask me for a country.... this automatically assumes i live in the US, even though i was send here by a dutch support link
01:36:07 <Phyx-> FAIL
01:37:29 <ksf> k-nucleotide is especially flawed because it doesn't ever require pure lookups, just insertions
01:37:40 <EnglishGent> oh btw (something actually haskell related!) I asked last night if it might be possible to write a 'monadinizer' - where you give it a function signature without monads, then show it where the m's should go - and it figures out a way of transforming a function matching the first signature into the second
01:37:40 <ksf> ...well, or updates
01:38:02 <EnglishGent> well I've done some thinking on it since - and it seems to me that it is *not* possible - at least in some cases
01:38:04 <shachaf> EnglishGent: It's easier to write it the other way around (just runIdentity).
01:38:22 <shachaf> Maybe everything should be written monadically in some sense.
01:38:25 <Phyx-> :t runIdentity
01:38:26 <lambdabot> forall a. Identity a -> a
01:38:42 <Phyx-> :t runIdentity join
01:38:43 <lambdabot>     Couldn't match expected type `Identity a'
01:38:43 <lambdabot>            against inferred type `m (m a1) -> m a1'
01:38:43 <lambdabot>     In the first argument of `runIdentity', namely `join'
01:39:10 <EnglishGent> specifically - how could you convert takeWhile :: (a -> Bool) -> [a] -> [a] into takeWhileM :: (a -> m Bool) -> [a] -> m [a] ?
01:39:24 <ksf> according to the all-knowing trash dump, "In computer science, a hash table or hash map is a data structure that uses a hash function to efficiently map certain identifiers or keys (e.g., person names) to associated values (e.g., their telephone numbers). The hash function is used to transform the key into the index (the hash) of an array element (the slot or bucket) where the corresponding value is to be sought."
01:39:29 <shachaf> EnglishGent: There's obviously more than one way to do it.
01:39:31 <EnglishGent> you'd need some combinator that it did it - that also performed the corresponding transformation on dropWhile
01:39:40 <shachaf> EnglishGent: Which is why the monad has a particular ordering.
01:39:45 <ksf> which actually means that one can use _anything_, as long as there's a hash function.
01:39:47 <shachaf> EnglishGent: Hence the other direction makes much more sense.
01:40:03 <EnglishGent> and it looks to me that would require the combinator 'looking inside' the origional function to find out where the function it's been passed is being used - in order to transform it appropriately
01:40:39 <EnglishGent> well I dont know much about the other direction yet shachaf - I only discovered the Identity monad yesterday - I'm still quite new to Haskell
01:40:47 <shachaf> EnglishGent: But there's more than one way to transform it appropriately anyway! The M version of the function has additional information.
01:41:13 <path__> I dont understand why there is an identity monad.
01:41:16 <shachaf> "x <- m; y <- n; f x y" is different from "y <- n; x <- m; f x y"
01:41:27 <shachaf> path__: Why shouldn't there be?
01:41:47 <path__> I mean if it doesnt do anything, why would you need it
01:42:07 <shachaf> path__: You can put monad transformers on top of it, you can turn a monadic function into a non-monadic function, and anyway, it's just a Monad instance for a 1-tuple.
01:42:09 <EnglishGent> there are in some cases shachaf - but in many cases there's an 'obvious' counterpart - consider (a -> b) -> [a] -> [b] vs (a -> m b) -> [a] -> m [b] -- there might be an infinite range of functions satisfying the second signature, but if I showed you those two & asked what the second one was
01:42:18 <EnglishGent> I bet your first thought would be mapM
01:42:42 <path__> hmm
01:42:48 <shachaf> EnglishGent: Sure -- but it's hardly possible to do it programmatically. Whereas the other direction *is* possible (with a commutative monad such as Identity where the order doesn't matter).
01:43:02 <EnglishGent> path_ - I only discovered it yesterday, but I've already found it useful for writing test cases to help me understand / debug monadic code
01:43:12 <shachaf> EnglishGent: And there are at least a few M functions in Control.Monad that would make some sort of sense in another order.
01:44:31 <path__> Im not sure how to put it but the fact that there is an identity monad kinda feels like working around the ability to express an idea. But maybe Im too new to the language to tell
01:44:51 <EnglishGent> shachaf - do you mind telling me more about this other direction? as I said I only discovered the existence of Identity monad yesterday - and I dont completely get what your saying :)
01:45:24 <Kim^Walkman> How do I remedy ‚Äúcould not find link destinations for [‚Ä¶]‚Äù warnings with haddock? I keep getting them for modules such as GHC.Bool.Bool, ByteString etc
01:46:16 <EnglishGent> path__ - how long have you been using it? I'm at about the ~5 week stage
01:46:32 <shachaf> > let myMap f l = runIdentity (mapM (Identity . f) l) in myMap succ [1,2,3] -- EnglishGent
01:46:34 <lambdabot>   [2,3,4]
01:47:12 <EnglishGent> I dont think I have a problem understanding monads - but I do still frequently struggle to get functions into the 'right form' - hence why I was thinking about a 'monadanizer' - I have a whole bunch of conversion functions I've written now to help me
01:47:36 <shachaf> The "right form"?
01:48:00 <EnglishGent> i.e. I have a function returning m (a -> b) - I want something m a -> mb
01:48:04 <EnglishGent> or similar problems
01:48:24 <shachaf> @ty ap
01:48:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:48:31 <shachaf> There you go.
01:48:43 <EnglishGent> I'd like to do as much as possible with hofs - I dont want to write more code than I have to
01:49:06 <path__> EnglishGent: oh my answer is much more shameful. I used it for a week or two then a long break, then a few weeks then a break and so on. So its been on and off for several months but very slowly at each point
01:49:19 <EnglishGent> ty - but that was just an example, I find I frequently encounter situations where the m's are in the 'wrong' places
01:49:29 <EnglishGent> partly I think it's that I dont know enough of the standard libs
01:49:52 <shachaf> EnglishGent: I agree that writing two versions of a function is annoying. But, as I said, you won't be able to automatically convert f into fM nearly as easily as you would fM into f.
01:50:00 <EnglishGent> for example - I have my own function 'unwrap' to do that - I didnt know there was one for it already in the standard libs till you told me just now shachaf! :)
01:50:09 <shachaf> > ap const const 5
01:50:10 <lambdabot>   5
01:50:29 <shachaf> EnglishGent: Excellent! You should look over them sometime.
01:50:43 <shachaf> EnglishGent: Also look at ApplicativeFunctor (where ap is called <*>).
01:50:55 <shachaf> s/Functor//
01:51:20 <kmc> :t (>>=)
01:51:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:51:41 <EnglishGent> are there any articles / papers I should read? I'm trying to learn more of the standard libs - but they are pretty large
01:52:11 <EnglishGent> (on this monad <-> non-monadic code issue)
01:52:20 <shachaf> EnglishGent: My recommendation tends to be to reimplement a bunch of the common monads yourself.
01:52:23 <shachaf> State and so on.
01:52:31 <shachaf> @instances Monad
01:52:32 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:53:56 <EnglishGent> btw - are there takeWhileM :: (a -> m Bool) -> [a] -> m [a] & so on in the libraries somewhere? I couldnt find them when I look if there are
01:54:15 <EnglishGent> but it looks odd that some list manipulators like map have monadic counterparts - where as other equally fundamental ones dont
01:55:12 <ksf> http://www.minet.uni-jena.de/dbis/lehre/ws2005/dbs1/ExHashOrig.pdf  <--- trie- based hashtables
01:55:29 <ksf> the point is to balance the trie by hashing
01:55:39 <fasta> EnglishGent, there is no need to learn all of the hierarchies.
01:55:40 <bastl> @help pl
01:55:40 <lambdabot> pointless <expr>. Play with pointfree code.
01:55:51 <fasta> EnglishGent, you can, but it is pointless, imho.
01:55:54 <bastl> @pl extract p s = reverse (drop (length p) (reverse (drop (length p) s)))
01:55:54 <lambdabot> extract = (reverse .) . ap ((.) . drop . length) ((reverse .) . drop . length)
01:55:55 <ksf> ...and to make the hashtable extendable by its backing being a trie
01:56:16 <ksf> I think there's some point in implementing that.
01:56:38 <kmc> can someone remind me how to implement (>>=) in terms of join and return?
01:56:41 <fasta> EnglishGent, just remember that you have monads (which are things that support certain operations) and that concrete monads have some extra operations.
01:56:53 <ksf> kmc, the types can.
01:56:57 <fasta> EnglishGent, that's really all there is to programming Haskell.
01:57:00 <quicksilver> EnglishGent: there are good reasons to feel that "takeWhileM" is less fundamental than "mapM"
01:57:54 <fasta> Sorry for the oversimplification. Please don't start a discussion about that.
01:58:45 <kmc> ksf, i'm failing somehow.  so i have x :: m a, and f :: a -> m b.  i can't use "join" on either of these, and i can't apply f to m.
01:59:02 <shachaf> kmc: What can you use join on?
01:59:13 <shachaf> kmc: That is, what can you produce that has time m (m x)?
01:59:16 <bastl> @pl ex s = reverse $ drop (length p) s
01:59:16 <lambdabot> ex = reverse . drop (length p)
01:59:35 <shachaf> Er, type.
01:59:35 <kmc> well, i can use join.return on x.  that seems profoundly useless
01:59:35 <kmc> as it should be the identity
01:59:39 <shachaf> kmc: It should. What else?
01:59:47 <fasta> kmc, x >= f?
01:59:52 <fasta> >>=*
01:59:57 <kmc> i'm implementing >>=
02:00:01 <kmc> it's recursive?
02:00:03 <shachaf> fasta: No, he/she/it is trying to write (>>=).
02:00:04 <quicksilver> kmc: hint : you can't implement (>>=) in terms of join and return
02:00:11 <kmc> oh?
02:00:17 <quicksilver> kmc: you're missing something which is considered "more basic" than join and return
02:00:17 <kmc> i thought join and return together define a monad
02:00:22 <kmc> fmap!
02:00:23 <kmc> thank you
02:00:25 <quicksilver> right.
02:00:30 <kmc> okay no more hints for now ;)
02:00:31 <shachaf> kmc: Not by themselves. Sorry, I didn't see that.
02:00:32 <kmc> thanks all
02:01:00 <fasta> kmc, what monad are you implementing that doesn't already exist?
02:01:53 <fasta> I think someone proved that everything followed from the continuation monad, so there is no need to implement >>= anymore.
02:02:23 <therp> fasta: oh that would be an interesting paper. do you have more details?
02:02:26 <shachaf> I think someone proved that everything followed from the SK calculus, so there is no need to implement programming languages anymore.
02:02:30 <fasta> Hmm, well, that's quite a large leap I make there.
02:03:11 <fasta> Anyway, what can't you make with newtype deriving and all the existing monads in e.g. the mtl?
02:03:51 <quicksilver> somebody showed that all the monads in the MTL can be built from Cont + State, I think.
02:03:57 <quicksilver> that doesn't mean that all *possible* monads can be
02:04:02 <quicksilver> that would be a much stronger statement.
02:04:20 <fasta> Well, it seems obviously true.
02:04:44 <fasta> If you can store state and can store continuations, then it seems you can express anything.
02:04:49 <quicksilver> well, ST is an interesting monad which can't most people believe cannot be implemented in pure haskell at all, let alone with Cont.
02:05:01 <fasta> quicksilver, I already proved 2 years ago, that you can.
02:05:14 <quicksilver> I don't believe you.
02:05:27 <quicksilver> how do you implement a dynamically typed heap in pure haskell?
02:05:28 <fasta> quicksilver, it depends on what you mean by "pure haskell".
02:05:53 <quicksilver> "express anything" is a weaker notion, too
02:05:56 <fasta> quicksilver, can I use the whole of Haskell98?
02:06:05 <fasta> quicksilver, yes, I agree.
02:06:05 <quicksilver> you can "express anything" in brainfuck or SK-calculus.
02:06:36 <quicksilver> the issue here is to build any monad out of a tower of ContT and StateT such that the >>= from that tower is the >>= you wanted.
02:07:32 * shachaf notices the time.
02:07:49 <shachaf> That's what I get for looking at #haskell past midnight.
02:08:00 * shachaf goes to sleep.
02:08:02 <fasta> quicksilver, basically once you have DiffArrays, you can implement ST.
02:11:15 <quicksilver> fasta: I don't understand how that gets you the dynamically typed heap
02:11:36 <quicksilver> (diffarrays don't have a different api from normal arrays, do they? they just store things differently)
02:12:38 <kmc> you'd need Dynamic as well
02:13:02 <kmc> you can implement ST with an assoc list of Dynamics, if you don't care at all about performance
02:13:42 <fasta> quicksilver, isn't that a mere detail? I mean the typing.
02:14:19 <fasta> quicksilver, I only cared about being able to have a graph which resized when needed that could story anything.
02:14:23 <fasta> store*
02:14:29 <kmc> :t return 'x'
02:14:31 <lambdabot> forall (m :: * -> *). (Monad m) => m Char
02:14:39 <kmc> lexande, ^^^
02:14:47 <quicksilver> fasta: it's not a mere detail at all, it's the whole core of the problem.
02:14:52 <fasta> That is basically just a memory model represented in Haskell.
02:15:11 <quicksilver> kmc: which is why I specified pure haskell, to exclude Dynamic from the game
02:15:16 <kmc> > return 'x' :: Maybe Char
02:15:18 <lambdabot>   Just 'x'
02:15:20 <kmc> > return 'x' :: [Char]
02:15:22 <lambdabot>   "x"
02:15:40 <quicksilver> the fact you can't (I speculate) implement a type safe dynamically typed heap in haskell is an interesting failure of expressivity.
02:15:59 <lexande> kmc, i do not know how to parse those things
02:16:03 <fasta> quicksilver, any computation which uses X types using ST can be implemented using X DiffArrays.
02:16:06 <kmc> which ones?
02:16:56 <fasta> quicksilver, isn't it a heterogeneous typed heap, btw?
02:17:14 <quicksilver> yes, that is probably a better word for it.
02:17:24 <quicksilver> @hoogle newSTRef
02:17:25 <lambdabot> Data.STRef newSTRef :: a -> ST s (STRef s a)
02:17:25 <lambdabot> Data.STRef.Lazy newSTRef :: a -> ST s (STRef s a)
02:17:30 <quicksilver> that's the point
02:17:38 <quicksilver> I don't believe you can implement newSTRef in pure haskell.
02:17:55 <quicksilver> and I think that's quite an interesting fact, if true, because I can't quite put my finger on why not.
02:18:10 <lexande> kmc, [] means list or something?
02:18:16 <kmc> yes
02:18:26 <lexande> i follow now but that seems like horrible notation
02:18:40 <kmc> [Char] is special syntax for what would otherwise be written "List Char"
02:18:43 <kmc> analogous to Maybe
02:19:01 <kmc> data List a = Nil | Cons a (List a)
02:19:22 <kmc> (these things aren't defined by default, though; only the special syntax)
02:19:37 <kmc> > return 'x' :: [] Char
02:19:39 <lambdabot>   "x"
02:20:16 <lexande> yeah i get that, the notation that seems horrible is specifying which monad's natural transformations you want "after the fact" like that
02:20:42 <kmc> the syntax here is (e :: t) where e is an expression and t is a type
02:20:46 <kmc> usually, it would be left off
02:20:51 <kmc> and the type inferred from the greater context
02:20:57 <kmc> > return 'x'
02:20:58 <fasta> quicksilver, the problem is that you need to have a way to express "if I put *something* in a box, after a readSTRef I get *something* out again".
02:20:59 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
02:20:59 <lambdabot>    arising from a use of...
02:21:24 <zygoloid> impredicative polymorphism isn't possible in haskell'98 is it? that'd seem to kill the "use X DiffArrays" approach
02:21:36 <fasta> quicksilver, but from an efficiency point of view (which I see as the only reason to use ST), there is no problem in using DiffArrays.
02:21:59 <kmc> > head (return 'x')
02:22:00 <fasta> zygoloid, no, it doesn't kill the approach, it is just not as direct.
02:22:00 <lambdabot>   'x'
02:22:11 <lexande> it would seem a lot saner to write return_([]) or something
02:22:18 <quicksilver> fasta: I don't think that's the problem. Polymorphic boxes are easy.
02:22:21 <fasta> zygoloid, I wasn't aware that people cared for the types so much ;) .. in #haskell ;)
02:22:29 <kmc> > (return :: a -> [a]) 'x'
02:22:30 <lambdabot>   "x"
02:22:35 <zygoloid> fasta: it means that your X DiffArrays can't be determined at compile time
02:22:38 <kmc> > (return :: a -> Maybe a) 'x'
02:22:39 <lambdabot>   Just 'x'
02:22:40 <quicksilver> fasta: the problem is having a polymorphic "new box"
02:22:45 <lexande> since each monad has a completely different one
02:22:53 <lexande> also are you not obliged to define it when you define your monad?
02:22:57 <kmc> you are
02:23:00 <kmc> @src Monad
02:23:00 <lambdabot> class  Monad m  where
02:23:01 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:23:01 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:23:01 <lambdabot>     return      :: a -> m a
02:23:01 <lambdabot>     fail        :: String -> m a
02:23:06 <lexande> actually m_return might make more sense
02:23:11 <fasta> quicksilver, heh, that's a logicians answer.
02:23:18 <kmc> (>>) has a default implementation in terms of (>>=)
02:23:21 <quicksilver> fasta: very likely :)
02:23:31 <fasta> quicksilver, it was implied that one needs a way to create boxes in the first place.
02:23:41 <kmc> fail also has a default and is a sort of wart for dealing with pattern-match failure
02:23:42 <mux> I wish `return' was called `inject'
02:24:11 <kmc> mux, how about: class (Functor f) => Pointed f where { pure :: a -> f a }
02:24:25 <fasta> Let's say that if you can use GHC + all the extensions, the implementors can remove ST and I can still implement ST.
02:24:43 <zygoloid> fasta: that's easy, with unsafePerformIO
02:24:50 <fasta> zygoloid, without unsafePerformIO./
02:25:03 <kmc> :t unsafeIOtoST
02:25:04 <lambdabot> Not in scope: `unsafeIOtoST'
02:25:09 <fasta> zygoloid, just DiffArray, as a basic data structure and a way to construct boxes as above.
02:25:10 <mux> kmc: I don't mind the Pointed class abstraction but inject sounds more natural to me
02:25:10 <zygoloid> fasta: that's easy, with unsafeCoerce
02:25:18 <mux> also, pure is already with both arrows and applicative functors
02:25:20 <zygoloid> fasta: ok, i'd really like to see that.
02:25:21 <mux> +used
02:25:33 <zygoloid> fasta: your STRef is required to work for any type, not just Typeable ones
02:25:36 <kmc> "inject" sounds a bit... forceful
02:25:42 <lexande> "eta"
02:25:55 <kmc> mux, no longer with arrows, for that reason
02:26:06 <mux> oh, it's only 'arr' now?
02:26:13 <kmc> and Applicative would subclass Pointed of course
02:26:15 <mux> @yarr
02:26:16 <lambdabot> Well Ahoy! thar.
02:26:22 <kmc> while we're complaining about names, Arrow is a terrible name
02:26:28 * mux nods
02:26:38 <lexande> what is Arrow?
02:26:52 <kmc> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
02:26:53 <mux> Arrow could be a Functor in that "other" meaning of functors in other languages
02:27:07 <kmc> mux, you mean "function"?  because that's what "functor" means in C++
02:27:18 <fasta> zygoloid, since you can make heterogeneous lists, you can make any heterogeneous data structure.
02:27:19 <mux> yup
02:27:27 <kmc> they have a fancy name to make a lack of true first-class functions sound like a feature
02:27:43 <kmc> but Arrow is not much like that either
02:28:06 <fasta> kmc, we have a fancy name for not having objects.
02:28:28 <kmc> Arrow is some kind of Category, with a functor from Hask, and cartesian products, and some other stuff?
02:28:30 <kmc> fasta, what name is that?
02:28:40 <zygoloid> fasta: yes. however, heterogeneous isn't enough, if you can use an unbounded number of types, unknown until runtime
02:29:11 <mux> kmc: suggestion #2: s/return/wrap/
02:29:13 <zygoloid> fasta: (which is something which impredicative recursion can give you)
02:29:29 <kmc> lexande, if you want the "right" definitions of things, look at http://hackage.haskell.org/package/category-extras
02:29:53 <zygoloid> fasta: as i said, if you can do it, i would be impressed and i think i'm not alone in that.
02:29:54 <kmc> where else you gonna get your Biff functors and chronomorphisms?
02:30:17 <kmc> mux, not bad
02:30:18 <fasta> zygoloid, can you give an example of that in combination with ST?
02:30:39 <kmc> though i would like the name to emphasize that the values you can get with return are a small, special subset of the values in the monadic type overall
02:30:39 <lexande> that looks fun
02:31:31 <fasta> zygoloid, SPJ already agreed with me, if you care about arguments by authority :)
02:31:33 <zygoloid> fasta: how about a function f :: Integer -> a -> ST s a, which (depending on the integer) might call itself at type (a, a) or at type Maybe a.
02:32:03 <zygoloid> fasta: agreed with you about which particular point?
02:32:05 <fasta> zygoloid, that has nothing to do with Haskell 98 anymore.
02:32:05 <c_wraith> err.  weirdness.  "import Text.XHtml.Strict" results in having a function named "row" in scope.  but "import qualified Text.XHtml.Strict as X" does not result in having "X.row" in scope.
02:32:33 <zygoloid> fasta: that's why i asked if you were including impredicative tpying
02:32:34 <quicksilver> fasta: how is that not haskell98? polymorphic recursion is haskell98.
02:32:56 <c_wraith> err.  nevermind.  I'm too tired for this
02:33:04 <c_wraith> That was entirely operator error
02:33:28 <fasta> zygoloid, quicksilver: ah, ok.
02:34:38 <lexande> kmc, what does the . in purify f = \k -> runIdentity (f (return . k)) mean?
02:35:11 <kmc> @src (.)
02:35:12 <lambdabot> (f . g) x = f (g x)
02:35:18 <kmc> composition
02:35:33 <lexande> and runIdentity?
02:35:40 <kmc> @src runIdentity
02:35:41 <lambdabot> Source not found. I feel much better now.
02:35:49 <c_wraith> @src Identity
02:35:49 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
02:35:49 <kmc> it extracts something from the Identity monad
02:35:59 <kmc> runIdentity :: Identity a -> a
02:36:12 <fasta> zygoloid, if you write a complete example, I might look at it later.
02:36:28 <c_wraith> that newtype idiom is actually pretty confusing for beginners, isn't it?
02:36:32 <kmc> (it's a field label in the newtype above, so that signature is the type of the field, not the type of the projection it defines)
02:36:55 <kmc> > (return :: a -> Identity a) 'x'
02:36:57 <lambdabot>   No instance for (GHC.Show.Show
02:36:57 <lambdabot>                     (Control.Monad.Identity....
02:37:04 <kmc> > runIdentity ((return :: a -> Identity a) 'x')
02:37:05 <lambdabot>   'x'
02:37:17 <quicksilver> c_wraith: I think so, yes.
02:38:25 <lexande> *sigh* can i just see this proof written in category theory somewhere?
02:38:30 <kmc> probably
02:38:44 <kmc> i'm not sure the monads are all that essential
02:38:47 <kmc> it may be more of a technical trick
02:39:51 <c_wraith> On a completely unrelated note, the author of uu-parsinglib got back to me.  He said he used to have a combinator that did what I wanted in older versions, and since I asked, would re-introduce it in the next version.  He also said that my implementation of it looked right, which sort of amazed me. :)
02:40:08 <kmc> what's it do?
02:40:26 <c_wraith> Detect end of input without extracting the error state.
02:40:41 <kmc> what does "extracting the error state" mean?
02:40:56 <c_wraith> that's hard to explain if you haven't used uu-parsinglib
02:41:00 <kmc> all right, no worries
02:43:19 <ksf> why don't we host or own, sane benchmark game?
02:43:27 <cathper> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4974#a4974
02:43:40 <cathper> What variable(s) has t as type variable?
02:43:55 <kmc> cathper, did you write that code by hand?
02:44:06 <quicksilver> cathper: your numeric operators
02:44:22 <quicksilver> cathper: in particular, your use of "floor" ties c4 to be Integral
02:44:28 <kmc> do you mean to be operating on two-element lists rather than pairs?
02:44:37 <cathper> kmc: Yes :-)
02:44:47 <quicksilver> cathper: but your extensive use of / all over the place ties stuff to be Fractional
02:44:49 <Baughn> cathper: What /is/ that?
02:45:00 <quicksilver> cathper: ..and of course, nothing can be Integral and Fractional at the same time, hence the error.
02:45:17 <kmc> :t div
02:45:18 <lambdabot> forall a. (Integral a) => a -> a -> a
02:45:20 <kmc> :t fromIntegral
02:45:22 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:45:29 <ksf> :t fromIntegral . floor
02:45:30 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
02:45:35 <quicksilver> cathper: do you want to do integer math or floating point math throughout?
02:46:02 <ksf> ...or rational?
02:46:05 <cathper> Baughn: Some kind of bound on the number of zeros of multivariate polynomials (which I'm not supposed to talk a lot about since it's research which are goiing to be published soon).
02:46:09 <ksf> ...or computable real?
02:46:13 <cathper> quicksilver: I see.
02:46:13 <quicksilver> well quite.
02:46:29 <kmc> wow craziness
02:46:34 <quicksilver> cathper: if you want to use fractional throughout, change the floors to fromIntegral . floor, as ksf hinted.
02:46:46 <cathper> quicksilver: Actually I'd prefer integer math.
02:46:51 <quicksilver> if you want to use integer throughout, change all the / to `div` (as ksf also hinted)
02:46:59 <ksf> I did?
02:47:07 <quicksilver> oh, kmc hinted that.
02:47:07 <cathper> quicksilver: I see, yes.
02:47:14 <ksf> you might want to use quot
02:47:15 <quicksilver> all you three-letter nicknames beginning with k look the same ot me.
02:47:22 <ksf> WE KNOW!
02:47:26 <Phyx-> quicksilver: lol
02:47:33 <cathper> :-D
02:47:39 <Baughn> cathper: That's all greek to me, I'm afraid
02:47:51 <ksf> quicksilver, get a font with proportional width.
02:48:01 <ksf> I'm more space-efficient than kmc
02:48:05 <kmc> "IRC client for Emacs"
02:48:08 <kmc> i hope that's a joke
02:48:09 <Phyx-> rofl
02:48:21 <cathper> kmc: It doesn't look pretty in fixed with fonts, but it looks even worse when you typeset it like a monkey in LaTeX :-)
02:48:29 <ksf> ...by a full k!
02:48:29 <Baughn> kmc: No. That exists.
02:48:29 <kmc> :D
02:48:37 <Baughn> ksf: ERC is even pretty goo
02:48:44 <Phyx-> goo?
02:48:49 <Baughn> Yes. Goo.
02:49:01 <Phyx-> hrm. like... sticky?
02:49:01 <cathper> Of course it does, Emacs /is/ an OS ... ;-)
02:49:15 <kmc> now if only someone would write a decent text editor for that OS
02:49:22 <Phyx-> hahaha
02:49:25 <Baughn> kmc: vimperator?
02:49:30 <kmc> haha
02:50:27 <cathper> Baughn: Right.
02:50:54 <quicksilver> Baughn: lies. This is greek :
02:51:00 <quicksilver> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4975#a4975
02:51:01 <cathper> Or maybe just start a shell and fire up vim :-)
02:51:13 <Baughn> quicksilver: No, I'm quite certain "polynomical" is greek. :P
02:51:16 <cathper> quicksilver: :-D
02:51:23 <Baughn> "multivariate", I don't get, but.. wikipedia helps
02:51:38 <kmc> polynominomicon
02:51:47 <Baughn> polynomnomnomicon?
02:51:50 <cathper> It's just a polynomial, where you can have more variables.
02:52:00 <quicksilver> cathper: can monkeys use LaTeX, in fact?
02:52:01 <Baughn> Aww. Too simple.
02:52:05 <kmc> mo' variables mo' problems
02:52:09 <cathper> So, in other words (which prolly doesn't help), it's a finite sum of monomials.
02:52:12 <quicksilver> cathper: or did you mean "like a monkey in latex", which is a horrible thought?
02:52:21 <Baughn> cathper: ..no, that helps
02:52:22 <kmc> haha
02:52:26 <cathper> quicksilver: :-D
02:52:31 <Baughn> cathper: Though I do wonder how you'd solve one
02:52:31 <kmc> quicksilver, it's safer than otherwise...
02:52:34 <cathper> quicksilver: Choose the one you like most :-P
02:53:12 <cathper> Baughn: In a finite field F, try all points in F^m if you have m variables ...
02:53:28 <cathper> Or do something smarter :-)
02:53:46 <Baughn> cathper: *sweatdrop*
02:54:12 <Baughn> R isn't even finite. I'm going to need a negative time-delay computation element to solve this.
02:54:20 <cathper> Or read our paper when it's published and you'll know how *many* zeros you at most can find.
02:54:25 <cathper> :-)
02:54:38 <Baughn> Not very useful for finding exact solutions. :P
02:54:53 <cathper> Or, well, use my Haskell code to calculate the bound.
02:55:04 <Baughn> Assuming it works
02:55:35 <cathper> Baughn: Right, but then you know how many times you in average has to try if you try some number of points from F^m by random --
02:55:41 <cathper> ... ish ...
02:55:42 <cathper> If that makes sense?
02:55:48 <Baughn> ..it does, it's just scary.
02:56:03 <cathper> Baughn: Of course it does :-P
02:56:26 <Baughn> cathper: It's going to do me no good at all if F is infinite, you realize
02:56:31 <cathper> This cf function is actually just for checking if our math is right.
02:56:42 <cathper> Baughn: Correct.
02:56:48 <Baughn> Oh, you're not using Coq or some such?
02:56:52 <cathper> But nothing is infinite, ya know ...
02:56:56 <Baughn> R is
02:57:03 <cathper> R doesn't exist
02:57:04 <cathper> :-P
02:57:15 <cathper> In real world computer stuff ...
02:57:27 <Baughn> Not /yet/..
02:57:30 <cathper> Well, there are 'nuf applications, so I'm not worried :-)
02:57:32 <cathper> :-)
02:57:50 <cathper> Theres a finite number of atoms in the Unverse ...
02:57:53 <kmc> R doesn't exist, period
02:57:54 <Baughn> You just know, if we made an infinite computer, they'd find a way to make windows slow on it.
02:57:56 <kmc> it's so bogus
02:58:01 <kmc> don't get me started again
02:58:06 <Baughn> cathper: That is not at all proven
02:58:28 <kmc> i hope that there are at most countably finite atoms in the Universe
02:58:42 <Baughn> I'd kind of agree that R doesn't exist, though. But N well could.
02:58:42 <kmc> countably infinite*
02:58:46 <cathper> Baughn: Nope, it's physics---they don't prove stuff ...
02:58:53 <Baughn> Or, rather, CN
02:58:58 <kmc> N is well-behaved
02:59:02 <kmc> R has terrible fucked-up properties
02:59:17 <cathper> R can be convenient sometimes, anyway.
02:59:21 <kmc> also nice ones but whatever
02:59:32 <cathper> C can as well.
02:59:34 <kmc> i don't like thinking about things that contain an infinite amount of information
02:59:42 <mlesniak> What is the best way to interact with a process which receives input from stdin (e.g. I want to call gnuplot from within my Haskell program)? It seems there are many packages on hackage?
02:59:46 <kmc> as does almost every element of R or C
03:00:02 <Baughn> kmc: Make it lazily evaluated, and you should be fine
03:00:10 <Baughn> mlesniak: System.Process should be fine
03:00:11 <kmc> mlesniak, there's a module System.Process in the standard library, which may do what you want
03:00:27 <mlesniak> kmc, Baughn: Ah, standard library, perfect!
03:00:53 <mlesniak> (I just found System.Process.Pipe which needs an extra package and I want to limit the dependencies)
03:00:59 <Baughn> mlesniak: De-facto standard, anyhow. Fortunately, Haskell is defined by GHC more than the other way around.
03:02:55 <ksf> something's fishy with the results of the k-nucleotide benchmark
03:03:07 <ksf> ...It's running faster on my box, and my box is slower.
03:03:24 <Baughn> ksf: IIRC, it tickles some baad cases in GHC
03:03:28 <ksf> not to mention that it runs faster without -fvia-c
03:03:59 <ksf> oh, I see.
03:04:08 <ksf> then why doesn't the shootout use 6.10.4?
03:04:13 <ksf> it's been out long enough.
03:04:15 <EnglishGent> sorry another question - quicksilver said earlier that there are good reasons to feel that "takeWhileM" is less fundamental than "mapM" (sorry - I missed it at the time)
03:04:22 <EnglishGent> why is that the case?
03:04:33 <quicksilver> because in writing takeWhileM there are choices
03:04:40 <quicksilver> like whether the condition should itself be monadic
03:04:41 <EnglishGent> hi quicksilver :)
03:05:29 <kmc> mapM is not very fundamental -- it can be defined in terms of sequence and map
03:05:33 <quicksilver> (a -> Bool) -> [m a] -> m [a], (a -> m Bool) -> [m a] -> m [a] or even (a -> m Bool) -> [a] -> [a]
03:05:42 <quicksilver> are three alternatives that spring to mind
03:05:49 <quicksilver> (sorry missing m before the final [a])
03:05:59 <EnglishGent> actually - that seems to be a problem to me (I still dont quite follow shachaf's suggestion about writing things in monadic form & converting back to pure) - but lots of functions seem to have this thing where there's a plethora of choices
03:06:02 <quicksilver> and what kmc just said is *also* true.
03:06:09 <cathper> :t mapM
03:06:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:06:14 <kmc> @src mapM
03:06:14 <lambdabot> mapM f as = sequence (map f as)
03:06:21 <EnglishGent> it's why I was thinking about an 'auto-monadanizer' until I realised it's not possible, at least in some cases
03:06:24 <Baughn> class Monad m => UnsafeUnwrapMonad m where unwrap :: m a -> a
03:06:41 <quicksilver> EnglishGent: it's a subjective point, but somehow things seem 'more important' if there is only one sensible choice, and 'more important' if they can't be re-expressed in terms of 'simpler' things.
03:06:45 <kmc> isn't that called Copointed
03:06:50 <kmc> and not necessarily unsafe
03:06:52 <Baughn> kmc: Yes
03:06:54 <EnglishGent> but I find my self writing several variants of most monadic functions at the moment - and I'm sure that's not right
03:07:16 <Baughn> kmc: The difference is, you'd define this for monads that aren't copointed
03:07:22 <Baughn> kmc: Like IO, or State, or..
03:07:23 <quicksilver> generally it's not. generally you just need the pure one and the one with ms on the right of all arrows
03:07:30 <kmc> ah
03:07:33 <quicksilver> and you can get anything from those two.
03:07:51 <EnglishGent> ah!
03:08:41 <EnglishGent> so then it should really be takeWhileM :: (Monad m) => (a -> m Bool) -> m [a] -> m [a]
03:08:57 * EnglishGent can see that there's a variant where the 2nd parameter isnt monadic
03:09:14 <EnglishGent> and whilst you could make just the 3rd monadic - that seems silly
03:09:31 <kmc> EnglishGent, the first "m [a]" there isn't on the right of (->), in the significant sense
03:09:40 <kmc> it's not directly on the right of (->)
03:09:55 <kmc> it's in a contravariant position
03:10:05 <Baughn> kmc: instance UnsafeUnwrapMonad State where unwrap s = runState s undefined
03:11:14 <EnglishGent> kmc - sorry, not quite sure what you mean by 'contravariant' position there (I have some idea what contravariant subtyping is, and I've an idea what a contravariant functor is category theory - but I dont see the connections between these entities yet)
03:11:24 <kmc> i may not be using it correctly
03:11:29 <kmc> anyway, it's an argument, not a return value
03:11:30 <EnglishGent> hello drwho
03:11:38 * EnglishGent looks for following Daleks
03:11:40 <EnglishGent> :)
03:11:43 <drwho> hello EnglishGent
03:11:51 <smelk> can someone recommend a combinatorial parser for ambiguous grammars? (something like parsec would be nice, but returning multiple results)
03:11:55 <drwho> DALEKS WHERE!?
03:11:59 <drwho> :O
03:12:05 <EnglishGent> lol! :)
03:12:15 <kmc> @quote dalek
03:12:15 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
03:13:48 <EnglishGent> actually programming a computer on the Tardis must be a nightmare musnt it? I mean lazy evaluation introduces problems with IO & so on... but there a function might return the result before *any* of it's inputs are evaluated :)
03:13:50 <Baughn> drwho: No daleks. Noo daleks. You can relax. They can't get up the stairs to this channel.
03:14:12 <Baughn> > fix (const 4) -- EnglishGent: What, like this?
03:14:13 <lambdabot>   4
03:14:37 <drwho> Baughn, good. all that is left to worry about is cybermen
03:14:59 <Baughn> drwho: The snipers can handle those.
03:15:05 <drwho> lol
03:15:09 <cathper> If I'd like the parameters to be Integer, what would then be the right way to do it?
03:15:13 <cathper> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4974
03:15:38 <Baughn> cathper: Add an appropriate type signature for cf as a whole
03:15:56 <Baughn> cathper: cf :: [Integer] Integer [Integer] -> Integer, or some such
03:16:02 <Baughn> With more ->s
03:16:20 <EnglishGent> I was thinking more of '> [2,4,6,8,10,12] > take 7 filter even [1 .. hey - wait a minute! it gave me a result -- and I havent passed it the expression yet!]' :)
03:17:13 <EnglishGent> ooh! actually if it can do *that* you can implement 'halts :: (x -> y) -> Bool' cant you! :)
03:18:05 <cathper> Baughn: Then ghci barfs.
03:18:07 <cathper> rekursiv.hs:67:6:
03:18:07 <cathper>     Kind error: `[Integer]' is applied to too many type arguments
03:18:07 <cathper>     In the type `[Integer] Integer [Integer]'
03:18:07 <cathper>     In the type `[Integer] Integer [Integer] -> Integer'
03:18:09 <cathper>     In the type signature for `cf':
03:18:13 <cathper>       cf :: [Integer] Integer [Integer] -> Integer
03:18:30 <EnglishGent> oh - wait, no you cant - you can only do if x & y are retracts of Integer
03:18:40 <EnglishGent> still... that would be pretty handy...
03:21:55 * cathper smacks himself.
03:23:40 <mreh> classParse :: ReadS Class
03:23:40 <mreh> classParse (p:‚Äô#‚Äô:r) = reads (p:‚Äôs‚Äô:r)
03:23:40 <mreh> classParse (p:‚Äôb‚Äô:r) = reads (p:‚Äôf‚Äô:r)
03:23:40 <mreh> classParse r = reads r
03:24:10 <mreh> can somebody explain why the type signature of classParse does not look anything like the implementation
03:24:48 <mreh> I dont understand how you can pattern match on no input
03:26:33 <koeien1> ReadS can be a type synonym, no?
03:26:41 <Baughn> @src ReadS
03:26:41 <lambdabot> Source not found. :(
03:26:49 <mreh> I've found the documentation :D
03:27:09 <mreh> I tend to shoot first and ask questions later
03:27:33 <mreh> ...or is it the otherway round
03:27:42 <Phyx-> #src ReadS Int
03:27:43 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
03:27:48 <Phyx-> @src ReadS Int
03:27:48 <lambdabot> Source not found. It can only be attributed to human error.
03:27:56 <EnglishGent> kmc - you still here?
03:27:59 <Phyx-> @src Int ReadS
03:27:59 <lambdabot> Source not found. Are you on drugs?
03:28:05 <Phyx-> yes, yes i am
03:28:08 <Phyx-> how did you know lambdabot ?
03:29:36 <mreh> "returns a list of possible parses as (a, String) pairs"?
03:30:03 <koeien1> yeah "a result + the rest of the string that you did not parse"
03:30:11 <mreh> fair enough
03:31:16 <mreh> > :t reads
03:31:17 <lambdabot>   <no location info>: parse error on input `:'
03:31:22 <mreh> :t reads
03:31:23 <lambdabot> forall a. (Read a) => String -> [(a, String)]
03:32:14 <koeien1> > reads "37" :: [(Int, String)]
03:32:15 <lambdabot>   [(37,"")]
03:32:20 <koeien1> > reads "37rest" :: [(Int, String)]
03:32:22 <lambdabot>   [(37,"rest")]
03:32:46 <mlesniak> What is the reason that Data.Map's function receive the map as the last parameter, e.g. Map.insert key value map? Wouldn't Map.insert map key value easy currying and be more consistent (with for example System.IO's handle-functions)?
03:32:47 <mreh> can it read type constructors?
03:33:05 <mlesniak> reason = rationale
03:33:12 <mreh> > reads "Nothing" :: [(Maybe, String)]
03:33:13 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
03:33:13 <lambdabot>  Expected kind `...
03:33:15 <Gracenotes> mlesniak: chaining operations
03:33:27 <mreh> ¬†> reads "Nothing" :: [(Maybe Int, String)]
03:33:31 <mlesniak> Gracenotes: Good point, right
03:33:32 <Phyx-> > reads "3+7" :: [(Expr,String)]
03:33:33 <lambdabot>   No instance for (GHC.Read.Read SimpleReflect.Expr)
03:33:33 <lambdabot>    arising from a use of...
03:33:35 <Gracenotes> mlesniak: the value that is likely to change the most is generally last
03:33:51 <Gracenotes> the most variable one, so to speak
03:33:58 <Gracenotes> @type maybe
03:33:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:34:04 <Gracenotes> @type sortBy
03:34:05 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:35:13 <mreh> > reads "Nothing" :: [(Maybe Int, String)]
03:35:14 <lambdabot>   [(Nothing,"")]
03:35:17 <Gracenotes> of course this can be disputed, but it's a nice principle. it might apply particularly to an if function, e.g. a -> a -> Bool -> a
03:35:34 <Gracenotes> instead of the usual order
03:36:34 <mreh> so you can define polymorphic type synonyms?
03:36:56 <mreh> that confused me, I thought I was looking at a monad
03:37:07 <koeien1> yes, you can
03:37:17 <koeien1> type X a = Maybe a (or type X = Maybe)
03:37:38 <koeien1> type Endo a = a -> a -- valid
03:37:50 <EnglishGent> can someone remind me - what's the name of that program (it's available in channel) where you give it a type signature & it constructs an example of a function having that signature?
03:37:55 <Gracenotes> although newtype-wrapping is a good idea there ;)
03:37:58 <koeien1> @djinn a->a
03:37:59 <lambdabot> f a = a
03:38:06 <koeien1> Gracenotes: sure :)
03:38:09 <EnglishGent> thanks koeien :)
03:38:23 <Gracenotes> :)
03:38:25 <koeien1> @djinn a->b
03:38:25 <lambdabot> -- f cannot be realized.
03:38:25 <Gracenotes> @botsnack
03:38:25 <lunabot>  :o
03:38:26 <lambdabot> :)
03:38:35 <mlesniak> @djinn Int -> Char
03:38:36 <lambdabot> Error: Undefined type Int
03:38:39 <mreh> yum, botsnacks
03:38:42 <mlesniak> @djinn Integer -> Char
03:38:43 <lambdabot> Error: Undefined type Integer
03:38:49 <Gracenotes> @botsmack
03:38:49 <lunabot>  :o
03:38:49 <lambdabot> :)
03:38:55 <EnglishGent> @djinn (Monad m) => m a -> m b -> m (a -> b)
03:38:56 <lambdabot> -- f cannot be realized.
03:39:07 <EnglishGent> I didnt think it could
03:39:13 <mreh> lambdabot likes it!!
03:39:28 <Gracenotes> djinn can't so Haskell polymorphism so well
03:39:34 <EnglishGent> is that definitive - does that mean 'it's impossible' (which is what I think) - or 'djinn cant think of a way to do it' ?
03:39:34 <Raevel_> @djinn (Monad m) => a -> m a
03:39:34 <lambdabot> f = return
03:39:45 <Raevel_> oh, i thought it didn't handle type classes at all
03:39:57 <koeien1> :t let f a b = b >>= return (const b) in f
03:39:58 <lambdabot> forall t b a. t -> (b -> a) -> b -> b -> a
03:40:11 <Gracenotes> becausse the direct mapping between the logic it uses and haskell types doesn't exist
03:40:12 <mreh> any haskell projects I could dedicated some time towards? Where's the best place to check?
03:40:17 <koeien1> :t let f a b = b >>= return . const in f
03:40:18 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => t -> m a -> m (b -> a)
03:40:23 <Gracenotes> Raevel_: but it can't handle polymorphism *within* typeclasses, as such
03:40:37 <Gracenotes> not true polyish polymorphism
03:40:43 <koeien1> :t let f _ b = const `liftM` b in f
03:40:44 <lambdabot> forall t (m :: * -> *) a1 b. (Monad m) => t -> m a1 -> m (b -> a1)
03:40:57 <koeien1> EnglishGent: there is your function
03:41:02 <EnglishGent> oh - ty!
03:42:14 <zygoloid> koeien1: the "cannot be realized" message means (i think) that there's no total function with that type
03:44:30 <koeien1> zygoloid: i guess it assumes const _|_ = _|_
03:47:00 <quicksilver> EnglishGent: don't be decieved by koeien1, that isn't your function ;)
03:47:13 <quicksilver> EnglishGent: your function doesn't exist; koeien1's answer ignores the 'a'.
03:47:33 <koeien1> quicksilver: it is more general, you mean?
03:47:57 <quicksilver> it doesn't satisfy the (entirely unwritten) spirit of EnglishGent's question ;)
03:48:01 <EnglishGent> ah - thanks quicksilver :)
03:48:11 <koeien1> quicksilver: heh. yeah that is definitely true ;)
03:48:15 <quicksilver> although I do wonder if he really meant (m a -> m b) -> m (a -> b)
03:48:21 <quicksilver> which also doesn't exist.
03:48:26 <EnglishGent> I did
03:48:32 <EnglishGent> but - same answer
03:49:05 <EnglishGent> hey! I'm making some progress - at least I correctly convinced myself it didnt exist! :)
03:49:36 * EnglishGent got as far as witing his own version of 'ap' - till someone last night nicely pointed out it was already in the libraries
03:49:40 <EnglishGent> :)
03:50:17 * EnglishGent regrets he cannot remember who mentioned it :|
03:51:34 <osfameron> independently inventing something is often the best way to understant it ;-)
03:53:25 <EnglishGent> true! though it can be annoying when you spend hours doing it (not that it did on this occassion - but it has in the past!)
03:55:27 <EnglishGent> anyone got any suggestions for mreh?
03:55:27 * EnglishGent just doesnt know enough yet to make sensible recommendations :|
03:55:27 <mreh> i've been googling, haskell.org has alot of information
03:55:27 <mreh> someone asked me today "Oh they still use Haskell do they?"
03:55:27 * hackagebot upload: lostcities 0.1 - An implementation of an adictive two-player card game (PedroVasconcelos)
03:55:27 * hackagebot upload: bullet 0.1.1 - A wrapper for the Bullet physics engine. (CsabaHruska)
03:55:31 <mreh> "ORLY?!"
03:55:52 <EnglishGent> mreh - perhaps they were thinking of Pascal? I've had *lots* of people confuse the two when I tell them I'm learning Haskell (and the names do sound similar)
03:56:12 * mreh high fives EnglishGent
03:56:16 <mreh> all the time
03:56:24 <EnglishGent> :)
03:56:47 <mreh> nah, he knew Haskell well, i think he used it many moons ago, probably back when I was a wee boy
03:58:15 <lunaris> Hi all; got a quick question regarding the FFI.
03:58:25 <EnglishGent> hello lunaris :)
03:58:40 <ksf> EnglishGent, no, they don't.
03:58:48 <lunaris> If I've got a dynamic stub (foreign import ccall "dyanmic", etc.), can I make it completely polymorphic in any way?
03:58:54 <ksf> Blaize Pascal isn't Blaize Paiscelle
03:59:01 <ksf> so don't bleeding pronounce him like that.
03:59:12 <lunaris> E.g. f :: FunPtr a -> a?
03:59:31 <lunaris> I know I can't write that.
03:59:31 <ksf> rhymes with rascal
03:59:31 <lunaris> But I'm wondering if anyone has a workaround / alternative.
03:59:35 <EnglishGent> yes - but the way people tend to prononunce them they do - I think mreh will confirm the confusion on this :)
03:59:40 <mreh> :t ShowS
03:59:40 <lambdabot> Not in scope: data constructor `ShowS'
04:00:07 <mreh> I pronounce it Haskull
04:00:22 <mreh> and Pascaaaaaal
04:00:23 <Zao> I seem to have lost the sound bite of SPJ pronouncing Haskell "properly" as linked on cafe.
04:00:32 <SamB_XP> I pronounce it ha-skell
04:00:49 <SamB_XP> like I *ha*ve a *skel*ington
04:01:14 * quicksilver pronounces it haskuhl, where the 'uh' is supposed to be a schwa but I"m too lazy to get unicode working.
04:01:16 <Kim^Walkman> Anybody managed to build readLine package from Cabal on Mac OS?
04:01:39 <ksf> if you can, use haskeline
04:01:59 <ksf> all that readline/libedit stuff is just utter pain
04:02:20 <Kim^Walkman> Figured I'd install mkcabal which has it as a dependency
04:02:36 <Kim^Walkman> But readline fails to build; from what I gather it can't find the header files for readline
04:02:39 <ksf> having said that, osx being a bsd system, i think you need to install the C readline by yourself, as it comes with editline.
04:03:05 <ksf> osx comes with editline, that is, not readline.
04:03:23 <Kim^Walkman> I installed it via macports; so it's in a non-standard location (/opt/local)
04:03:26 <donri> got root? no, has skull!
04:03:30 <lunaris> Guessing the answer to my question is no then -- Thanks anyway guys :)
04:03:36 <ksf> the gnu guys went out of their way to annoy people with that one.
04:03:59 <SamB_XP> ksf: hmm ???
04:04:17 <Kim^Walkman> So, I do have readline, I'm having trouble telling cabal where it is
04:04:35 <ksf> lunaris, there's a hackage package for doing dynamic stuff
04:04:44 <lunaris> ksf: I know, hs-plugins.
04:04:44 <ksf> relieves all the pain.
04:04:48 <lunaris> But it's not quite what I want.
04:04:57 <ksf> that's not what I mean
04:05:13 <lunaris> Orly? :o
04:05:31 <lunaris> Has my blinding ignorance let me down again?
04:06:28 <quicksilver> lunaris: I would expect that to work, actually, but I don't know anything about import "dynamic"
04:06:34 <ksf> http://hackage.haskell.org/package/libffi
04:06:55 <quicksilver> lunaris: as long as you treat the haskell object as a non-introspectable blob
04:07:24 <ksf> you can even use that thing with ghci
04:07:31 <lunaris> quicksilver: I'm being "really polymorphic" here; I want to be able to instantiate that type with say (Ptr a -> Ptr b -> IO ()).
04:07:47 <lunaris> I.e. linking in functions for which I don't know the signature at compile time.
04:07:48 <ksf> callFFI :: FunPtr a -> RetType b -> [Arg] -> IO b
04:08:18 <lunaris> ksf: I'll try it out, thanks :) Sorry I missed that.
04:08:46 <ksf> I missed it too, until someone here told me
04:08:56 <lunaris> I'm going to be quiet now :|
04:09:10 * lunaris makes a note to use the "internet" before asking questions.
04:09:23 <SamB_XP> this is the internet, silly
04:09:29 <ksf> ...as binding via dynamic manually is utter pain in comparison to statically binding with c2hs
04:10:21 * lunaris :: Question -> Maybe Answer
04:10:30 <ksf> no the internet is that place where one's secretary gets those printouts from
04:10:39 <SamB_XP> ksf: what printouts ?
04:10:43 <ksf> some kind of series of tubes, like a fax
04:10:52 <lunaris> I'm going to return Nothing on this one.
04:10:52 <SamB_XP> ... er, what's printout again ?
04:11:22 <ksf> you take a printer, and print.
04:11:22 <SamB_XP> oh, did you know the gears are powered by tubes ?
04:11:26 <ksf> then you have a printout.
04:11:27 <jtra> lunaris: really? I would guess Question -> IO (Maybe Answer)
04:11:48 <lunaris> jtra: I'm pure baby -- lunaris = Nothing
04:12:00 <ksf> "Internetausdrucker" has become quite a common term in german.
04:12:12 <lunaris> :: English?
04:12:17 <SamB_XP> lunaris: but you have to at least use Id (Maybe Answer), if you want to return Nothing
04:12:25 <ksf> internet-printouters
04:12:31 <lunaris> Nice :)
04:12:48 <lunaris> Hmm, true.
04:12:48 <SamB_XP> ksf: are those people like dilbert, who are in charge of printing out the entire internet?
04:12:55 <SamB_XP> until they get to the end, I guess ?
04:12:57 <lunaris> Maybe I should become overloaded.
04:13:01 <ksf> no, they're usually politicans.
04:13:06 * lunaris :: Monad m => Question -> m Answer
04:13:21 <lunaris> ksf: But they claim back for the printouts.
04:13:39 <ksf> they're also policemen that fall for krautchan fakes of postal runs
04:13:59 <ksf> http://www.action-team.us/krautchan-winnenden-hoax/
04:15:05 * SamB_XP wants fuser for NT
04:15:15 <lunaris> Use Wubi
04:15:19 <lunaris> x)
04:15:50 <lunaris> Reminds me of a great April Fool's post where Gentoo posted a port named "Gentoo NT", which was basically portage around the NT kernel.
04:16:01 <SamB_XP> huh.
04:16:14 <SamB_XP> I think I'd be more interested in a port of the OTHER gentoo
04:16:30 <SamB_XP> the one that's an (iirc orthodox) file manager
04:18:11 <SamB_XP> okay ... how the *heck* was I able to delete a .bin/.cue pair that was mounted by daemontools ...
04:19:27 <ksf> wow.
04:19:42 <ksf> ms finally managed to let you delete opened files?
04:20:11 <ivanm> lunaris: Redhatter actually started making Gentoo NT...
04:20:12 <shambler_> erm?
04:20:14 <SamB_XP> ksf: well, there is a way to open a file that will allow it to be deleted
04:20:14 <shambler_> are they?
04:20:19 <ivanm> using the Unix Services stuff
04:20:33 <shambler_> hehe
04:21:05 <SamB_XP> ksf: but I don't think that's it, since "unmounting" the image didn't free up any disk space
04:21:35 <SamB_XP> I'm thinking that daemontools might not keep the files open at all times...
04:22:23 <ksf> If I were them, I'd mmap them
04:22:56 <SamB_XP> how big can DVD images get though?
04:23:02 <mreh> type Atom note = Maybe note -- how is this different from "type Atom = Maybe"
04:23:04 <SamB_XP> probably bigger than 3 GB?
04:23:20 <mreh> doi!
04:23:30 <mreh> "note" is a type variable isn't it
04:23:55 <ksf> hmmm the partial application restriction doesn't apply to type synonyms, does it?
04:24:11 <ksf> if type Atom = Maybe won't work you have your answer
04:24:20 <ksf> otherwise it's going to be equivalent.
04:24:47 <Lemmih> mreh: It isn't.
04:25:01 <Lemmih> mreh: (isn't different, that is)
04:25:07 <opqdonut> the former Atom always has to be used with an argument
04:25:09 <opqdonut> but otherwise no
04:27:40 <mreh> thx
04:28:58 * SamB_XP wonders why Virtual PC 2007's bios is trying -- and failing -- to connect to a DHCP server ...
04:29:41 <ksf> it's the failing part that should surprise you
04:30:13 <SamB_XP> ksf: well, it's just I haven't seen a way to turn it off that bothers me in terms of "trying"
04:30:51 <SamB_XP> and, well, the fact that I'm used to that being a thing that the OS is in charge of
04:30:57 <ksf> virtual machines and networking can get really annoying.
04:31:13 <SamB_XP> I know
04:31:27 <SamB_XP> I have something that can work set up on my Linux box ...
04:31:43 <SamB_XP> ... but it's a bit tricky to get programs to use it
04:31:47 <EnglishGent> fuser? SamB_XP?
04:31:55 <EnglishGent> do you mean fuse? or something else? :)
04:31:59 <ksf> with virtualbox I ended up ssh'ing from the vm into my host, setting up a port mapping via it.
04:32:19 <ksf> ...then I could ssh from the host to the vm, which is what I wanted to do.
04:32:26 <SamB_XP> EnglishGent: fuser -- isn't that the name of the *nix program that tells you who is using a file ?
04:32:51 <EnglishGent> confess I'm not sure off hand SamB_XP
04:33:05 <ivanm> gah! dealing with parsing quotable strings is driving me crazy!
04:33:13 <EnglishGent> I'm less bothered with needing to know on *nix as most programs arent so keen to lock files as their windows counterparts
04:33:16 <ksf> processes.
04:33:21 <ksf> it tells you the processes
04:34:18 <SamB_XP> ksf: I'd probably go for setting the MAC address to a hard-coded, preferably invalid value and using IPv6
04:34:51 <SamB_XP> EnglishGent: well, it's useful if you'be got a cheap sound card and want to know who's hogging it, etc.
04:35:18 <ksf> oh, neil doesn't seem to like completely implicit view patterns.
04:35:53 <ksf> he says it's a bad idea, without giving any reason
04:36:20 <EnglishGent> oh I'm not saying it's not useful SamB_XP - just that I dont know the command off hand as I have less need for it :)
04:36:28 <SamB_XP> hmm, maybe the reason Virtual PC is not succeeding in it's DHCP attempts is because it's looking for a netboot image ...
04:37:16 <mreh> any Haskore wizards on?
04:37:33 <mreh> data Primitive note =
04:37:33 <mreh>          Atom Dur (Atom note) -- a note or a rest
04:37:33 <mreh>     deriving (Show, Eq, Ord)
04:37:48 * SamB_XP wonders if he should try to install NT 3.51 Workstation using NTFS or FAT ...
04:38:05 <mreh> given "Atom" is "Maybe", why would you have a Primitive is equal to Nothing?
04:38:25 <EnglishGent> NTFS if you can - FAT is pretty horrible
04:38:37 <EnglishGent> (my advice anyway)
04:38:38 <EnglishGent> :)
04:39:03 <mreh> FAT16
04:39:11 <mreh> that's my vote
04:39:26 <SamB_XP> mreh: I don't think they had FAT32 in these days
04:39:36 <sieni> SamB_XP: Upgrading?
04:39:54 <SamB_XP> sieni: what, you think I have a 3.50 install or something ?
04:40:23 <sieni> Nope, just trying to be funny
04:40:28 <SamB_XP> ;-)
04:42:39 <mreh> :t Maybe a b
04:42:40 <lambdabot> Not in scope: data constructor `Maybe'
04:42:49 <mreh> :t Just a b
04:42:50 <lambdabot>     Couldn't match expected type `Expr -> t'
04:42:50 <lambdabot>            against inferred type `Maybe Expr'
04:42:50 <lambdabot>     In the expression: Just a b
04:56:43 <burp> @src reverse
04:56:43 <lambdabot> reverse = foldl (flip (:)) []
04:58:47 * hackagebot upload: Vec-Transform 1.0.2 - Extends the Vec package with some 4x4 transform matrices (TobiasBexelius)
05:10:51 <Baughn> @djinn Maybe a -> a
05:10:52 <lambdabot> -- f cannot be realized.
05:14:00 <LouriePieterse> Would it be inappropiate if I ask something simple that doesnt have todo with the channel?
05:14:41 <Baughn> LouriePieterse: Whatever you have to ask, it is not as inappropriate as asking to ask
05:14:56 <ivanm> Baughn: well, asking to ask isn't that inappropriate
05:14:58 <McManiaC> is there a pretty way of something like "case '' of _ | foo -> do... ; | bar -> do...; | otherwise -> ..." ?
05:15:06 <Baughn> ivanm: True. So..
05:15:17 <ivanm> and I can think of some inappropriate questions for any occasion, let alone this channel...
05:15:26 <ksf> in contrast to usenet, discussions about whether something is OT is OT in IRC.
05:15:30 <LouriePieterse> Okay the thing is, I am working on the project, but I couldnt decided on a name for it.
05:15:35 <ivanm> McManiaC: why are you using a case for that rather than a pattern match or guard function?
05:15:56 <ksf> LouriePieterse, what kind of thing?
05:16:01 <LouriePieterse> Would some of you please take a minute and complete this poll of mine? Its quite simple, I just couldnt make up my mind over a name! http://bit.ly/projectname
05:16:22 <ksf> hell none of them
05:16:46 <LouriePieterse> Its just a bunch of weird words... :D
05:17:15 <ksf> "beugung" und "kruemmung" have the connotation of bending under pressure.
05:17:19 <McManiaC> ivanm: hm okay, i could define a function there too‚Ä¶
05:17:20 <ksf> you want a strong name.
05:17:56 * EnglishGent has a look a the poll :)
05:18:01 <Baughn> I like "bremsstrahlung"
05:18:02 <LouriePieterse> ksf Yes, it has to do with bending. :)
05:18:09 <LouriePieterse> EnglishGent thanks! :)
05:18:12 <ksf> ...then call it bender.
05:18:14 <scree> all synonyms for diffraction, no?
05:18:14 <ksf> something active.
05:18:30 <LouriePieterse> scree Yes.
05:18:38 <LouriePieterse> But bender sounds so... dull.
05:20:37 <ksf> call it bragg, if you can.
05:21:04 <LouriePieterse> ksf Sounds cool, but why?
05:21:15 <ksf> http://en.wikipedia.org/wiki/Bragg_diffraction
05:21:29 <scree> bojning?
05:21:36 * LouriePieterse checking link.
05:21:36 <scree> with a line through the o
05:22:26 <LouriePieterse> I really like the Bragg one. And it is related to the project.
05:22:32 <scree> ksf: but that's not even true...
05:22:32 <ksf> if that'd make you look silly because your program doesn't have anything to do with bragg diffraction and you can't even really quote it as historical kudos, then go for another cool name.
05:22:41 <LouriePieterse> scree Checking youre one.
05:22:57 <scree> ksf: Bragg diffraction, that is
05:23:26 <scree> it gives the right answers but only by cosmic accident
05:23:53 <ksf> well that makes for a good headline of the bug tracker
05:24:05 <ksf> ...I don't have any clue about physics.
05:24:10 <scree> lol
05:24:23 <scree> LouriePieterse: it means "bending" in danish, apparently
05:25:26 <ksf> isn't the whole cosmic just a big -- or series of -- accidents?
05:25:27 <LouriePieterse> Maybe it should add it to the poll.
05:25:31 <LouriePieterse> I
05:26:06 <ksf> fresnel is good, too.
05:26:13 <ksf> widely known for his lenses.
05:26:24 <ksf> (if that's the same one)
05:26:41 <scree> ksf: I'm happy for the universe to be an accident, but chemistry should have a reason behind it
05:27:18 <ksf> reason? you can't reason with the universe. It just won't listen.
05:28:09 <scree> puts its cosmic fingers in its cosmic ears and hums cosmically to itself?
05:28:18 <EnglishGent> nope - you cant bargin with it either... and it absolutely *will not stop*
05:28:19 <Baughn> ksf: Accident? It's no accident, it's just running every possible program at once. We live in one of them.
05:28:30 * LouriePieterse really likes this channel. Maybe I should visit more often.
05:28:38 <Baughn> ksf: Some run slower than others, which is why occam's razor works. :3
05:28:45 * ksf thinks he should warn the channel that he just poured his third glass of wine
05:29:07 <scree> Baughn: does that mean that all the rubbish buggy programs i've written are *universes* somewhere?
05:29:15 <ksf> LouriePieterse, NOOOO! we're trying to avoid success, here
05:29:17 <Baughn> scree: Yes
05:29:23 <ksf> alas.
05:29:29 <ksf> our plans were spoiled.
05:29:36 <Baughn> @quote success
05:29:36 <lambdabot> JonHarrop says: We invested a lot of time and money diversifying into Haskell before I discovered that their industrial success stories were largely faked.
05:29:46 <Baughn> ..righto
05:29:59 <scree> pity the people who have to live in them
05:30:15 <Baughn> scree: I very much doubt there are any.
05:30:47 <scree> Baughn: at least they weren't in C; imaging what living through a seg fault would feel like
05:31:15 <Baughn> scree: I feel relatively certain that, whatever else the basic instructions are, they're total.
05:31:17 * ksf had a segfaulting haskell program, today.
05:31:28 <Baughn> ksf: ..that's enough wine for you.
05:31:56 <ksf> Baughn, you're just jealous because I know how to deal with pointers.
05:32:21 <ksf> (my code was actually correct. it figures that the buffer was too small)
05:32:32 <Baughn> ksf: Then the code wasn't correct, now was it?
05:32:54 * scree has just realized that the universe can't solve the halting problem
05:33:07 <ksf> well it would have been, if I hadn't written 4096 in some places and kept one at 61
05:33:17 <LouriePieterse> scree Did you know that? :)
05:33:29 <ksf> scree, it's trying to, that's why it's still running.
05:33:36 <LouriePieterse> scree You should read Computing the Universe.
05:33:49 <Baughn> ksf: Bad ksf. You should factor out such constants.
05:34:02 <LouriePieterse> Sorry, Programming the Universe.
05:34:08 <ksf> didn't feel like it.
05:34:14 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12290 , btw.
05:34:19 <Baughn> scree: Whatever /else/ might be true, at least it seems nearly certain that the laws of physics for our universe are turing-computable
05:34:27 <Baughn> scree: Which means they can't do anything a turing machine can't
05:35:26 <scree> Baughn: presumably we mean computable to finite given accuracy
05:36:15 <Baughn> scree: No, we mean "a turing machine can compute the complete history of the universe in a finite, if very large, number of steps"
05:36:30 <Baughn> scree: Well, at least for variants of this universe where space-time isn't infinite. :P
05:36:36 <ksf> LouriePieterse, but I still have to read the new pratchett!!
05:36:45 <ksf> you can't just give me a hint like that.
05:37:01 <scree> Baughn: haven't heard much about such discrete models
05:37:31 <ksf> quantum loop theory says that there's no beginning to the universe.
05:37:47 <Baughn> scree: The models tend to be idealized, and discreteness makes them ugly
05:37:48 <ksf> it says that before the big bang, there was "another" universe, which was the same
05:38:04 <Baughn> scree: Above a certain resolution, it doesn't matter; the macroscale results are the same.
05:38:10 <ksf> ...just not the same space (and maybe time, I don't know the maths), but certainly the same cause+effect
05:38:21 <scree> Baughn: sure...
05:38:41 <ksf> I assumed all the newer theories assume the universe to be discrete
05:38:46 <scree> Baughn: so I guess the point is we don't know anything about space below the plank length, so it might as well be discrete
05:38:59 <Baughn> scree: The point is that we /can't/; quantum physics prohibits it
05:39:12 <ksf> also, discreteness doesn't get you into formalistic lala-land
05:40:08 <scree> Baughn: we can't measure it directly, but it would be nice to have some theory about it that recovers macro-scale results as simply as possible
05:40:42 <ksf> bucky fuller says that Universe is infinite, but bounded.
05:40:48 <Baughn> scree: That's the point. Quantum physics prohibits any differences in the precise events below planck scale from affecting macro-scale results, ever.
05:40:53 <ksf> (or the other way round)
05:41:14 <Baughn> ksf: Those are quite different things. :P
05:41:23 <Baughn> I'd tend to agree with the first version, but not the second
05:41:28 <ksf> me too.
05:41:42 <ksf> I also think that space actually doesn't exist. it's a side-effect of matter.
05:41:50 <Baughn> Unbounded but finite is a nice formalism, but there's no evidence that that is the case
05:41:52 <ksf> time, too. it's a side-effect of cause and effect.
05:42:16 <Baughn> ksf: Well, the laws of physics are time-symmetric, so yeah..
05:42:48 <ksf> oh I think it _was_ finite but unbounded.
05:43:08 <Baughn> ksf: But if you have to solve a set of equations in four dimensions, where you have initial values for T=0 and must fill in everything else.. causality kind of drops out quite naturally as a result of there being boundary conditions
05:43:28 <ksf> in the sense that there's a fixed amount of energy/matter (let's call the sum "1"), but unbounded in the sense that it isn't specified how much space it takes up.
05:43:50 <Baughn> Information can't propagate backwards because it'd contradict the boundary conditions. It *can* propagate forwards. Of course, it's possible to set up conditions where that very carefully isn'T the case..
05:43:55 <ksf> I root causality in logic.
05:44:03 <Baughn> ...which is my explanation for post-selection "paradoxes". Geez..
05:44:11 <ksf> I know that's egocentric, as I could'nt think about that stuff without logic.
05:44:23 <ksf> ...unlogical things being unpercievable, so to speak.
05:44:34 <scree> Baughn: (technically time-symmetry can be violated)
05:44:50 <Baughn> scree: How?
05:45:04 <Baughn> ksf: The universe could be infinite and have infinite matter/energy while still taking finite computational power
05:45:11 <scree> Baughn: I thought CPT was as good as it got
05:45:29 <scree> Baughn: as in, reverse time then electrons flip their charges
05:45:31 <shambler_> http://en.wikipedia.org/wiki/CPT_symmetry
05:45:49 <Baughn> scree: Sure, but that still allows information to propagate either way
05:46:31 * scree apologizes for bringing up a technicality that doesn't affect the main point
05:46:48 <Baughn> scree: If you know the state of the universe at time T=1, then you /can/ calculate its state at time T=0. If the laws of physics weren't time-symmetric, that would be impossible. That's all there is to it.
05:47:06 <Baughn> ksf: Specifically, via lazy evaluation. Which does beg the question of what is forcing the evaluation..
05:47:07 <ksf> "Universe is the comprehensive, historically synchronous, integral-aggregate system embracing all the separate integral-aggregate systems of all menís consciously apprehended and communicated (to self or others) nonsimultaneous, nonidentical, but always complementary and only partially overlapping, macro-micro, always-and- everywhere, omnitransforming, physical and metaphysical, weighable and unweighable event sequences. Universe is a dynamically s
05:47:07 <ksf> ynchronous scenario that is unitarily nonconceptual as of any one moment, yet as an aggregate of finites is sum-totally finite. "
05:47:10 <shambler_> <ksf> I assumed all the newer theories assume the universe to be discrete // no, not realy, space is still continuous
05:47:19 <shambler_> you can't calculate initial state
05:47:32 <Baughn> ksf: ..why are you posting crackpot stuff now?
05:47:39 <ksf> that's bucky!
05:47:45 <Baughn> ...I see.
05:48:02 <Baughn> Those words do not go together like that.
05:48:16 <scree> Baughn: I think time-symmetric is too strong; all you need is reversible
05:48:30 <ksf> He may have been insane, but judge not his words to be false because of that. the reason he's insane is because it's true.
05:48:30 <Baughn> scree: Admittedly. I think that's what I meant.
05:48:38 <Baughn> ksf: ..riight
05:48:48 <scree> Baughn: ok
05:49:43 <ksf> in other words, if you want your mind _seriously_ blown, read http://www.rwgrayprojects.com/synergetics/toc/toc.html
05:50:03 <shambler_> hehe
05:50:07 <LouriePieterse> I must be going. Bye.
05:50:09 <shambler_> must be fun stuff
05:50:17 <Baughn> scree: Point is, the laws of physics don't specify causality, and don't have to; it's quite clearly emergent from the asymmetry of entropy in the time dimension
05:50:59 <Baughn> ksf: Not really. It needs to pass my nonsense detector to get in a position to blow my mind.
05:52:36 <ksf> "Entropy is not random: it is always one negative tetrahedron. "
05:52:45 <ksf> well, the point is that he actually has a point.
05:52:49 <ksf> ...in his own maths.
05:52:54 <Baughn> Only because tetrahedron are pointed
05:52:59 <scree> Baughn: agree, just need some reason why we started in a low-entropy universe
05:53:12 <ksf> which, unlike crackpots, support a lot of buildings.
05:53:39 <ksf> a tetrahedron is the unit of 3d-space
05:53:44 <Jafet> I hope prisms support my buildings, not tetrahedrons
05:53:54 <ksf> that doesn't mean it's spacefilling, though.
05:53:54 <Baughn> scree: Things in this universe which lack a reason are called "laws of physics".. the initial state could perfectly well fall under that
05:54:21 <Baughn> scree: However, occam's razor then applies: The higher the kolmogorov complexity of the laws, the lower their prior probability
05:54:37 <Baughn> scree: ..a zero-entropy starting state just happens to correspond to the lowest possible kolmogorov complexity
05:55:05 <ksf> Baughn, the point that might spark your interest is that buckyballs are called buckyballs because the people that first constructed them noticed that there's just no maths to describe them, except bucky's.
05:55:19 * scree is going to look up some long words
05:55:26 <Baughn> ksf: Pity how he's batshit insane, then
05:55:30 <BONUS> hey y'all check this out. some ST typing stuff: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12306#a12306 the second example doesn't work because the forall quantifier for a isn't the same for the function type signature and the ST action type signature at line 29
05:55:34 <ksf> well, so was tesla.
05:55:49 <ksf> and so am I.
05:55:53 <BONUS> what's the most idiomatic way to tell ST to use STArrays
05:56:01 <ksf> still I'm able to churn out decent code, at least occasionally.
05:56:07 <ksf> how could it be otherwise?
05:56:11 <BONUS> otherwise it complains it doesn't know which MArray instance to use
05:56:14 <BONUS> cause it's ambiguous
05:56:34 <ksf> BONUS, a type annotation?
05:56:57 <BONUS> ksf, in swapArrayElems?
05:56:59 <ksf> depending on how your code is syntactically layout, either a top-level or expression-level one
05:57:13 <ksf> well you only need to fix it in one place
05:57:22 <ksf> I'd say where you construct it.
05:57:27 <BONUS> ah
05:57:45 <BONUS> but check out line 29
05:57:47 <BONUS> i'd have to then do
05:58:07 <BONUS> (newListArray :: the really long type annotation here here) (1, len) xs
05:58:10 <BONUS> that seems kind of ugly
05:58:20 <ksf> make a type definition
05:58:22 <ksf> and use that.
05:58:24 <quicksilver> BONUS: -XScopedTypeVariables
05:58:30 <ksf> you can put that at the top of the file.
05:58:36 <ksf> looks very, very professional.
05:58:39 <quicksilver> BONUS: your error is because the 'a' in line 25 is different from the 'a' in line 29
05:58:50 <BONUS> yeah i know
05:58:57 <quicksilver> BONUS: (that's why the type error is complaining about a1 not being a)
05:59:00 <ksf> oh there's a paste for it.
05:59:04 <quicksilver> BONUS: -XScopedTypeVariables will fix it.
05:59:05 <BONUS> i was just wondering where the best location is to annotate
05:59:08 <BONUS> ah
05:59:14 <BONUS> cool
05:59:19 <lunaris> Just add {-# LANGUAGE ScopedTypeVariables #-}
05:59:25 <quicksilver> you will need to put an explicit forall to line 25
05:59:35 <lunaris> And a forall a. (Type signature)
05:59:37 <lunaris> Or similar.
05:59:39 <quicksilver> the scoped type vars extension is kicked into life by the presence of an explicit forall
05:59:42 <lunaris> Except quicksilver beat me to it ;)
05:59:51 <BONUS> haha
06:00:00 <BONUS> nice
06:00:08 * ksf thinks array code has worse readability than Ptr a mangling
06:00:08 * lunaris goes back to being quiet.
06:00:38 * lunaris says "Just use unsafeCoerce" *Thunder clap* MWAHAHAHA
06:00:40 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
06:01:07 <BONUS> ah cool. thanks
06:02:07 * hackagebot upload: astview-utils 0.1 - Interfacing between hint and astview (SebastianMenge)
06:02:10 <BONUS> is there a reason the explicit forall is required though?
06:02:45 <Baughn> BONUS: Scoped type variables only actually scope if you explicitly forall them
06:02:55 <quicksilver> BONUS: to maintain haskell98 compatibility
06:02:57 <Baughn> BONUS: Otherwise the effect of turning on the extension would be zero
06:03:30 <quicksilver> BONUS: (it is possible to write valid haskell98 code which *depends* on the two 'a's being distinct, obscure though that is)
06:04:06 <ksf> sounds like an equally bad idea as dynamic scope
06:04:24 <fasta> Why does readProcess "ghc" ["--print-libdir"] not return the same as when executed in the shell?
06:04:38 <ksf> different environment?
06:04:41 <fasta> I get these DOS paths.
06:04:50 <fasta> Instead of the "real thing".
06:05:28 <ksf> you're not under windoze/cygwin, are you?
06:05:30 <m0nkfish> for a minute there i thought you two were just listing advantages of forall
06:05:40 <m0nkfish> bonus!!!
06:05:42 <BONUS> yeah i see how that would be possible, although i don't see why anyone sane would use the same type variable names
06:05:46 <BONUS> hello
06:05:48 <fasta> If I execute it in rxvt I get the right answer, in cmd.exe I get the right answer, just not when I execute it in ghci.
06:06:12 <BONUS> does the scope of the type variable include where clauses?
06:09:18 <quicksilver> BONUS: it should be the same as the scope of the identifier that it is annotating.
06:10:11 * hackagebot upload: parallel 2.0.0.0 - Parallel programming library (SimonMarlow)
06:10:16 <halcyon10> hi, how can i convert a [Maybe a] to a (Maybe [a]) ? i basically want the list to survive only in the case that there is no Nothing in the list
06:10:48 <poucet> @hoogle [Maybe a] -> Maybe [a]
06:10:48 <Heffalump> halcyon10: sequence
06:10:49 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:10:49 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:10:49 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
06:11:04 <BONUS> > sequence [Just 3, Just 2, Just 1]
06:11:05 <lambdabot>   Just [3,2,1]
06:11:10 <BONUS> > sequence [Just 3, Nothing, Just 1]
06:11:12 <lambdabot>   Nothing
06:11:13 <BONUS> :)
06:11:32 <halcyon10> Heffalump: cool, thanks a lot!
06:11:44 <fasta> Is there a version of readProcess that does give the same result as the shell?
06:12:39 <sothim> hello! I'm searching for the tmr-Haskore.tar.gz from the MonadReader issue2, I found the article in the wiki, but don't see any "attachment", anybody an idea?
06:14:36 <jaj> hmm I didn't see that issue9 even copied the state monad functionality
06:15:42 <fasta> Heh, is issue9 some kind of Internet meme to force Google to rename it?
06:18:32 <zygoloid> fasta: issue9 is the new name. The Internets Haz Spoken
06:18:49 <fasta> zygoloid, ah, that is seriously cool.
06:19:20 <fasta> zygoloid, the programming language doesn't seem to contain anything new, though.
06:19:22 <zygoloid> (of course, it's not an /official/ new name but it is a de facto new name) :)
06:19:49 <fasta> zygoloid, the only thing what interested me was the "getting faster tools"-part.
06:22:02 <BONUS> wait it isn't seriously renamed right
06:24:02 <fasta> I think if enough people refuse to call it whatever they named it, they will have to ;)
06:24:12 <BONUS> haha
06:24:14 <ziman> @pl \x -> f `fmap` g x
06:24:15 <lambdabot> (f `fmap`) . g
06:24:18 <BONUS> i don't see the big deal though
06:24:25 <allbery_b> I like the comparison to Algol 68
06:25:36 <BONUS> @pl \x -> fmap f (g x)
06:25:37 <lambdabot> fmap f . g
06:25:52 <BONUS> i didnt know pl kept infix in infix
06:25:55 <BONUS> pretty cool
06:28:43 <fasta> I also don't see why the issue9 people present their stuff as being innovative/new.
06:29:30 <fasta> I only saw the video, but I saw absolutely nothing new.
06:29:55 <quicksilver> I don't think they do, really
06:30:05 <quicksilver> that's not the impression I've had, at least
06:30:31 <fasta> They presented a few things as "new".
06:30:42 <fasta> Most of it was acknowledged as being "old".
06:30:46 <BONUS> the only thing i find kind of stupid is that they keep touting "short compilation times" as one of the main points
06:31:01 <fasta> Well, it is a good point.
06:31:07 <BONUS> i mean that's great but i don't think long compilation times is the biggest gripe with most languages
06:31:11 <Hunner> @help
06:31:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:31:20 <allbery_b> when you're doing terative development, fast compilation is a major win
06:31:22 <fasta> Just making a completely interactive system without any noticable compilation time is better.
06:31:26 <allbery_b> *iterative
06:31:27 <quicksilver> long compilation times are a real headache for large C++ projects, I believe.
06:31:34 <fasta> quicksilver, yep
06:31:35 <quicksilver> (and they certainly are for large haskell projects)
06:31:48 <quicksilver> (but google probably weren't thinking about haskell)
06:31:57 <BONUS> yeah i think they aimed with C++
06:32:03 <quicksilver> you don't really feel them in C#/.NET though
06:32:04 <BONUS> but C++ is notorious when it comes to compilation times
06:32:30 <allbery_b> http://www.cowlark.com/2009-11-15-go/ is the algol68 comparison btw
06:36:07 <BONUS> @pl \m io -> forkIO $ io >>= putMVar m
06:36:07 <lambdabot> (forkIO .) . (=<<) . putMVar
06:36:16 <BONUS> eh
06:38:53 <BONUS> re: terminology: are right-associative functions and left-associative functions deemed to be subsets of associative functions
06:39:28 * ksf thinks he should figure out how to use Float and Word constants with TH without using the ast combinators to make the macro operation more clandestine
06:40:18 <ksf> insuspicious readers could read $() and [| |] as just some funny syntax trick
06:42:15 <quicksilver> ksf: insuspicious readers might be a good blog title
06:43:47 <roconnor> woah, apparently there are other Kleene algerbras other than regular expressions.
06:43:48 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
06:49:52 <zygoloid> type InsuspiciousReader a = Reader (forall r. r) a
06:52:11 <osslin> I have a data structure that looks like this: data Sudoku = Sudoku { rows :: [[Maybe Int]] } I want to use list comprehension to generate an empty Sudoku, how do I do that?
06:52:31 <Tobsan> osslin: introduction to functional programming, is it? ;)
06:52:44 <osslin> Tobsan: yes:)
06:52:54 <Tobsan> osslin: you just want to generate a matrix of Nothing, right?
06:53:00 <osslin> correct
06:53:17 <Tobsan> well, and the sudoku is 9x9
06:53:44 <osslin> Yes, but if I manage to generate one row I can use replicate
06:54:01 <tromp_> :t replicate
06:54:02 <lambdabot> forall a. Int -> a -> [a]
06:54:04 <Tobsan> you could just use replicate inside the replicate, right?
06:54:37 <osslin> Tobsan: already tryed that and will give me error or types
06:54:45 <osslin> it doesn't know that I mean Sudoku
06:54:56 <osslin> rather [[Maybe b]] or something
06:55:19 <tromp_> > replicate (replicate 9 Nothing) :: http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int
06:55:20 <lambdabot>   <no location info>: parse error on input `.'
06:55:28 <osslin> But yes, I get a 9x9 matrix of Nothing by doing so, but how do I tell it that it is a Sudoku?
06:55:31 <tromp_> > replicate 9 (replicate 9 Nothing) :: http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int
06:55:32 <BONUS> Sudoku is a function actually.
06:55:33 <lambdabot>   <no location info>: parse error on input `.'
06:55:37 <Tobsan> osslin: just put it in the Sudoku record
06:55:41 <BONUS> of type [[Maybe Int]] -> Sudoku
06:55:41 <Tobsan> and then you're done!
06:55:51 <tromp_> > replicate 9 (replicate 9 Nothing) :: [[Maybe Int]]
06:55:52 <lambdabot>   [[Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing],...
06:59:53 <osslin> Tobsan: don't understand what you mean.
07:00:14 <dmwit> osslin: "Sudoku" is a conversion function between the type [[Maybe Int]] and the type Sudoku.
07:00:15 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
07:00:26 <dmwit> osslin: Part of the problem is that Sudoku is both a type and a value.
07:00:43 <dmwit> osslin: The type is the one to the left of the '=' sign; the value is the "constructor" to the right of the '=' sign.
07:00:56 <dmwit> osslin: Clear as mud, right?
07:01:05 <saml> yes
07:01:18 <saml> wait. mud isn't clear
07:01:26 <saml> i see what you did there
07:02:02 <osslin> dmwit: think so
07:02:16 <dmwit> osslin: Here, let me describe the same thing, but using the following data definition instead:
07:02:24 <dmwit> data Sudoku1 = Sudoku2 { rows :: [[Maybe Int]] }
07:02:36 <dmwit> Now, Sudoku2 is a conversion function from type [[Maybe Int]] to type Sudoku1.
07:02:56 <fasta> What is wrong with this runhaskell -i:.. -hide-package transformers -hide-package monads-fd -hide-package mtl-tf-0.1 Foo.hs I get <interactive>:1:110: Not in scope: `main' Foo.hs most definitely contains main.
07:03:04 <ksf> or, popularly, data Sudoku = MkSudoku { rows :: [[Maybe Int]] }
07:03:17 <dmwit> Yes, I like a real name better than a number.
07:03:32 <ksf> fasta, is your module called Main, too?
07:03:45 <dmwit> fasta: Hm.  Does Foo export main?
07:03:49 <fasta> ksf, no, but that shouldn't be a requirement AFAIK.
07:03:57 <ksf> oh yes it is.
07:04:07 <saml> data Sudoku = NewSudoku { rows :: [[Maybe Int]] }
07:04:12 <dmwit> (unnamed is fine, too)
07:04:19 <ksf> you'd usually call the file with the Main module foo.hs, then.
07:04:20 <fasta> ksf, if you don't say module Foo where bla bla bla, then module Main is implied.
07:04:25 <ksf> yes.
07:04:36 <ksf> (then it's called Main)
07:04:45 <saml> > let new ctor = ctor in new Just 1
07:04:46 <lambdabot>   Just 1
07:04:59 <fasta> ksf, and I don't have any module declaration.
07:05:02 <path__> hi guys wheres the best place to look up haskell references for stuff?
07:05:10 <path__> like methods in the unboxed array
07:05:15 <dmwit> ?where hoogle
07:05:16 <lambdabot> http://haskell.org/hoogle
07:05:18 <saml> > let new ctor = ctor in let a = new Just 1 in a
07:05:18 <dmwit> ?where hackage
07:05:19 <lambdabot> http://hackage.haskell.org/package/
07:05:19 <lambdabot>   Just 1
07:05:33 <ManateeLazyCat> path__: Use calbal install hoogle.
07:05:39 <path__> ah thanks
07:05:46 <ManateeLazyCat> path__: You can use hoogle search local api.
07:06:08 <path__> oh ok
07:06:09 <ManateeLazyCat> path__: If you want search all api, you can use lambdabot at #haskell.
07:06:11 <path__> that sounds good
07:06:27 <ksf> hayoo has a bigger index, though.
07:07:11 <path__> when should I use an unboxed array and when boxed
07:08:05 <Saizan> you can use an unboxed array only with primitive types, basically
07:08:10 <path__> ah
07:08:12 <path__> so not with String
07:08:30 <Saizan> and for those types it's generally faster, though it's strict in the elements
07:08:35 <Saizan> no
07:08:59 <path__> cool thanks
07:09:27 <path__> hmm if I do cabal install, will it install docs for the version I have?
07:09:41 <path__> I have ghc 6.10.4
07:10:24 <Saizan> if you pass it the --enable-documentation flag, or set documentation: True in the ~/.cabal/config
07:10:54 <path__> oh sorry I meant ManateeLazyCat  suggested cabal install hoogle
07:11:04 <path__> (which I assume will give me a copy of whats on hackage)
07:11:21 <path__> I just meant will the docs it downloads correspond with my haskell library versions :)
07:11:34 <ManateeLazyCat> path__: Hoogle will search your local API by any calbal package.
07:11:37 <Saizan> ah, no
07:12:41 <Saizan> cabal install hoogle will install the hoogle executable together with a default API index (which corresponds to the libs that used to come with ghc, more or less), you need to add manually to that index atm
07:12:44 <zygoloid> s/\<calbal\>/cabal/g
07:13:46 <Saizan> (last time i checked, at least)
07:14:04 <path__> hmm 6.10.4 is latest though
07:14:14 <path__> hmm
07:14:25 * cathper ‚ô• Haskell.
07:15:09 <zygoloid> > ?cathper ‚ô• Haskell
07:15:10 <lambdabot>   Not in scope: data constructor `Haskell'Not in scope: `‚ô•'
07:15:48 * hackagebot upload: lambdacube-engine 0.1.1 - 3D rendering engine entirely written in Haskell (CsabaHruska)
07:15:50 <cathper> "Can you get me this?" -- 23 keystrokes later -- "Wow!". "What about the list of those optimizing?" -- 7 keystrokes later -- "Whoah. Impressive!"
07:16:24 <cathper> Thanks to Haskell I'm now well-liked by my supervisor :-)
07:16:45 <path__> what do you do
07:17:14 <cathper> Math -> Discrete math -> Coding-ish -> Network Coding.
07:17:23 <path__> ah
07:17:31 <cathper> But we discovered something more general, so that's what we're working on now.
07:17:49 * hackagebot upload: lambdacube-examples 0.1.1 - Examples for LambdaCube (CsabaHruska)
07:18:47 <path__> now that Ive installed hoogle, is there a locally browsable set of html entries?
07:19:50 * hackagebot upload: lambdacube-bullet 0.1.1 - Example for combining LambdaCube and Bullet (CsabaHruska)
07:20:12 <Saizan> you can use the hoogle command to make queries
07:20:26 <Saizan> the html docs are created by haddock
07:21:12 <path__> ah
07:21:53 <ManateeLazyCat> path__: Haddock can build html docs by scan you Haskell code.
07:22:11 <ManateeLazyCat> path__: Detail see haddock documentation.
07:22:23 <path__> :o ... ok Ill do that
07:22:46 <ManateeLazyCat> path__: Just write comment with haddock style, then haddock will generate detail documentation in html file.
07:23:37 <ManateeLazyCat> path__: http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/ is document generate by haddock for gtk2hs project.
07:24:00 <path__> ah I see
07:24:03 <EnglishGent> hello Saizan, ManateeLazyCat :)
07:24:13 <ManateeLazyCat> EnglishGent: Hello! :)
07:24:31 <ManateeLazyCat> EnglishGent: Good to see you again. ;)
07:24:55 <trofi^w> strict-concurrency is broken on ghc-6.12rc1: http://pastebin.ca/1676477
07:25:24 <ManateeLazyCat> BTW, when time release GHC-6.12 ?
07:25:47 <ManateeLazyCat> I like it's new feature -- Unicode IO
07:25:47 <trofi^w> *shrug*
07:26:08 <ManateeLazyCat> Then i don't need transform file coding when i read file content.
07:26:17 <ManateeLazyCat> Just use Unicode coding everything.
07:26:25 <trofi^w> yup
07:27:20 <mmx166mhz> How can we check easily whether "abcd" begins with "ab" ?
07:27:30 <mmx166mhz> WITHOUT leaving the Prelude
07:27:33 <Heffalump> isPrefixOf
07:27:40 <ManateeLazyCat> :> isPrefixOf
07:27:48 <mmx166mhz> I know that one, but I guess I cant use that
07:27:54 <mmx166mhz> Its outside prelude right?
07:27:56 <sproingie> it's a prelude function
07:28:00 <mmx166mhz> ah ok!
07:28:23 <ManateeLazyCat> > hoogle isPrefixOf
07:28:25 <lambdabot>   Not in scope: `hoogle'
07:28:26 <sproingie> prelude used to be so easy to browse before hierarchical libraries
07:28:37 <donri> @hoogle isPrefixOf
07:28:38 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
07:28:38 <koeien1> @hoogle isPrefixOf
07:28:38 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:28:38 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
07:28:38 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
07:28:38 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:28:40 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
07:28:45 <sproingie> @hoogle isPrefixOf
07:28:45 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
07:28:45 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
07:28:46 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
07:28:47 <BONUS> > let a +? b = take (length a) b == a in "ab" +? "abcd"
07:28:49 <lambdabot>   True
07:28:50 <sproingie> criminy
07:29:00 <mmx166mhz> I must say: I am confused, as some things fall under " Prelude", but some under e.g. "List"
07:29:08 <mmx166mhz> But List is just a subset of Prelude?
07:29:23 <sproingie> all prelude does now is import stuff from other modules
07:29:24 <donri> i think they're all in List and Prelude imports some of them
07:29:24 <koeien1> BONUS: that uses quite some memory, right?
07:29:28 <trofi^w> Prelude just reexports some of List functions
07:29:32 <Hunner> Any way I can direct ghc to include the ghc package instead of having to run "ghc --make -package ghc"?
07:29:32 <koeien1> O(|a|) ?
07:29:35 <mmx166mhz> aha, thanks
07:29:53 <BONUS> koeien1: nah, very little memory, the string "abcd" is very short
07:29:54 <donri> lambdabot should have a "silence used command for x seconds" thing :P
07:29:59 <stoop> haha
07:30:01 <trofi^w> as Prelude was the first place they were introduced (before hier. modules)
07:30:01 <koeien1> BONUS: yeah, lol ;)
07:30:13 <sproingie> :browse Prelude
07:30:20 <sproingie> that should show you everything in Prelude
07:30:21 <trofi^w> :p
07:30:48 <sproingie> ghci really ought to build in haddock and hoogle
07:30:50 <BONUS> but in seriousness, i dont think it uses more memory than isPrefixOf
07:30:55 <BONUS> at least not asimptotically
07:31:06 <koeien1> i don't know about that implementation
07:31:25 <BONUS> laziness, etc.
07:31:25 <koeien1> but your implementation traverses a (length a) while keeping hold of a?
07:32:05 <BONUS> yeah but that doesn't copy a
07:32:11 <BONUS> cause a is immutable
07:32:17 <BONUS> that's one of the cool things you get from purity
07:32:36 <koeien1> well, the thunks get evaluated, right?
07:32:37 <zygoloid> it's still not a very good implementation, spacewise
07:32:49 <sproingie> @src isPrefixOf
07:32:49 <lambdabot> isPrefixOf [] _          = True
07:32:49 <lambdabot> isPrefixOf _  []         = False
07:32:49 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
07:32:51 <koeien1> avg xs = sum xs / length xs -- also leaks
07:32:51 <BONUS> but yeah, not the ideal implementation
07:32:58 <ManateeLazyCat> zygoloid: How cheap memory?
07:33:17 <zygoloid> ManateeLazyCat: depends how much of it you use :)
07:33:40 <ManateeLazyCat> zygoloid: Of course, Haskell will use much memory than C sometimes.
07:34:01 <sproingie> startsWith = flip isPrefixOf -- for java and python junkies
07:34:06 <zygoloid> we're not talking X bytes versus Y bytes, we're talking O(n) bytes versus O(1) bytes, and that matters for large inputs no matter what.
07:34:13 <path__> can someone help me understand this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4976#a4977
07:34:15 <ManateeLazyCat> zygoloid: But i still like Haskell. :)
07:34:18 <koeien1> sproingie: i think the name isPrefixOf is very well chosen
07:34:38 <BONUS> i like startsWith better :[
07:34:46 <koeien1> sproingie: in OO langauges there is some asymmetry, and then startsWith is clearer
07:35:07 <zygoloid> @type listArray
07:35:09 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
07:35:11 <sproingie> isPrefixOf does follow the more usual pattern of needle followed by haystack
07:35:38 <sproingie> whereas in OO it tends to be a method so it gets reversed
07:35:40 <BONUS> i ate too much sour candy and now i dont feel so good, brb
07:36:36 <ziman> i'd say isPrefixOf is meant to be used infix
07:36:37 <zygoloid> path__: you can't make an IArray for any type you like, sadly.
07:36:46 <m0nkfish> ziman: i was just going to say that
07:37:05 <m0nkfish> `startsWith` wouldn't make sense really
07:37:11 <zygoloid> path__: and there's no instance for arrays of String, so you can't do that :(
07:37:14 <m0nkfish> unless you flipped it
07:37:22 * ManateeLazyCat Just choose your like name.
07:37:31 <zygoloid> path__: if you used Data.Array instead of Data.Array.IArray your code should work fine, though
07:37:52 <path__> zygoloid: ah ok, but can you explain what the error is please? I didnt quite get it
07:38:01 <dayz> hi
07:38:01 <dayz> i know that an inconsistent theory entails everything. one explanation is that P -> Q is true if P is false, despite the value of Q. but what are the model-theoretic or proof-theoretic explanations?
07:38:45 <lunaris> P->Q abbreviates (~P V Q) (~ = not, V = or)
07:38:53 <hotzen> hello, could anybody please explain the type-family/associated type  type-constructors? i dont get the "type Ref m :: * -> *"
07:39:04 <lunaris> It seems weird at first, but it's handy when you use things like forall.
07:39:05 <zygoloid> path__: the IArray listArray function is :: (IArray a e, Ix i) => (i, i) -> [e] -> a
07:39:20 <lunaris> For example: forall a. Food(a) -> Tasty(a)
07:39:30 <lunaris> You don't want things which aren't food to be "looked at" by the forall.
07:39:40 <zygoloid> path__: the type of array you get is determined by an IArray instance, and depends on the type you're storing in the array
07:39:41 <lunaris> So vacuous truth is a consequence of that definition of implication.
07:39:44 <hotzen> especially why "this declaration is fine: data T m a = MkT [Ref m a]" - isn't Ref a type function which returns me the type of a if applied to "Ref m" ?
07:40:01 <zygoloid> path__: the error is saying there's no instance of "IArray a String" for any a, so listArray can't be used on a list of Strings.
07:40:33 <path__> zygoloid: when you say determined by an array instance what does that mean? Is there a predetermined list of array instances?
07:40:49 <BONUS> nah
07:41:07 * hackagebot upload: astview 0.1 - View abstract syntax trees for your custom  languages and parsers in a graphical (GTK+)  application (SebastianMenge)
07:41:13 <BONUS> Ref is a type function that takes a type and returns a type constructor, which in turn takes one type, to return a type
07:41:41 <BONUS> so basically Ref is a type function that takes two types and returns a type
07:41:56 <BONUS> in Ref m a, m and a are the types supplied to the type function Ref
07:42:20 <ksf> ...or rather, a is supplied to m, and the result to Ref
07:42:34 <ksf> kind * doesn't mean that it can't be a function.
07:42:35 <BONUS> a is supplied to Ref m imo
07:42:45 <koeien1> yes
07:42:49 <hotzen> but if i have "instance  Mutation IO where type Ref IO = IORref" Ref io gives me IORef, so why should i use "Ref m a" ?
07:42:59 <koeien1> Ref m is something of kind * -> *, this means that you give it a type, and it returns a type
07:43:13 <koeien1> because IORef is of kind * -> *
07:43:15 <hotzen> yes and what returns "Ref m a" ?
07:43:25 <koeien1> that is an "IORef a"
07:43:25 <ksf> IO a
07:43:29 <ksf> wait
07:43:35 <hotzen> data T m a = MkT [Ref m a]
07:43:35 <hotzen> hm
07:43:37 <BONUS> Ref m a returns something
07:43:38 <ksf> can you paste the source
07:43:46 <ksf> ?
07:43:54 <koeien1> yeah, so we have    T IO a = MkT [IORef a]
07:43:55 <ksf> @hpaste
07:43:55 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:43:57 <hotzen> is there some haskell-paste-service?
07:43:59 <hotzen> thanks
07:44:19 <BONUS> hotzen: here's a simpler example. say you have type family Foo a :: *. and then you have data T a = MkT [Foo a]
07:44:22 <sproingie> should have called it haste
07:44:51 <BONUS> Foo is a type function which takes a type and returns a type
07:45:07 <BONUS> and then you can say
07:45:08 <koeien1> a partial type function
07:45:21 <BONUS> type instance Foo Int = Char
07:45:34 <BONUS> and then you can do MkT "haha" :: T Int
07:45:35 <sproingie> i need to learn type families one of these days
07:45:46 <hotzen> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4978#a4978
07:45:52 <BONUS> if we pass Int to Foo, we get back a Char
07:46:03 <ksf> sproingie, read the fun with type functions paper
07:46:04 <BONUS> so if we made a MkT with chars, Foo a has to be Foo Int
07:46:06 <ksf> spj+oleg
07:46:51 <sproingie> hey wow it's refreshingly free of greek letters
07:47:04 <leimy> Can more than one thread write a TChan while one thread reads it?
07:47:25 <leimy> or does every thread need it's own TChan to write to exclusively?
07:47:26 <ksf> greek letters are a rare sight in oleg papers
07:47:53 <ksf> and also rare in spj ones, at least if he doesn't talk about the implementation of the type system
07:48:06 <hotzen> bonus: thanks. the only thing i dont get "then you can do MkT "haha" :: T Int"
07:48:18 <koeien1> leimy: the former, i think
07:49:00 <ksf> hotzen, T Int means that Foo a is Char, which means that Mkt :: [Char] -> T Int
07:49:36 <leimy> koeien1: that could be a problem :-)
07:49:43 <leimy> I've got one thread dealing with stdout
07:49:45 <leimy> on a TChan
07:49:56 <leimy> and multiple other channels wanting to use it.
07:49:59 <hotzen> ksf: is this some syntax? i dont get it
07:49:59 <leimy> I guess I should be doing a dup
07:50:10 <ksf> ...it's the type relationship.
07:50:17 <leimy> the documentation isn't clear on this by the way.
07:50:38 <ksf> if you instantiate T with Int, Int gets passed on to Foo
07:50:42 <ksf> and Foo Int is Char
07:50:49 <BONUS> hotzen: if we do MkT "haha", the inferred type is MkT Char
07:50:51 <ksf> ...Foo a gets replaced by Char
07:50:55 <koeien1> leimy: i don't see why you need to do dupTChan
07:50:59 <BONUS> and then you ask yourself
07:51:07 <ksf> and MkT [Foo a] finally becomes MkT [Char]
07:51:09 <BONUS> which type do we have to apply to Foo to get a Char
07:51:14 <BONUS> the answer is Int
07:51:23 <ksf> so in the end, data T Int = MkT [Char
07:51:26 <BONUS> because it's MkT [Foo a] and Foo Int is a Char
07:51:50 <MyCatVerbs> leimy: For the many-writers, one-reader case, you want one Chan.
07:52:01 <BONUS> (but this isn't injective though. Foo () or Foo Double could also return Char. what then?)
07:52:03 <MyCatVerbs> leimy: "dup" is for when you have many readers.
07:52:05 <fritschy> Cale: have you heard of simplereflect? kind of simple expr. reflection... (regarding how to analyze/look into expression evaluation)
07:52:30 <hotzen> ouh, thanks!!
07:52:44 <ksf> unification is evil. it involves greek variables.
07:53:04 <leimy> MyCatVerbs: that's what I was hoping...
07:53:06 <sproingie> damn greeks
07:53:19 <MyCatVerbs> leimy: There's no problem with having more than one thread write to a Chan at once, all the accesses are synchronized. There's no problem with having more than one thread read from a chan either, except that only one of the threads will get any given message. If you want several to all get the message, then you need to use dup.
07:53:52 <MyCatVerbs> e.g. in a producer/consumer pipeline, there's no problem whatsoever with having several producers and several consumers all on one Chan.
07:54:33 <MyCatVerbs> leimy: It's actually necessary for the implementation to work that way because there isn't an equivalent to Occam's "ALT" built in. This way is, IMHO, far more convenient. :)
07:54:40 <mmx166mhz> I have a .txt file, and what to read in everyting in a single list . How to?
07:54:46 <koeien1> readFile
07:54:48 <mmx166mhz> ok
07:54:52 <koeien1> :t readFile
07:54:53 <lambdabot> FilePath -> IO String
07:55:41 <mmx166mhz> works very easy indeed. And now ill use words and lines;)
07:55:47 <koeien1> precisely :)
07:55:53 <ManateeLazyCat> :t words
07:55:54 <lambdabot> String -> [String]
07:55:56 <ManateeLazyCat> :t lines
07:55:57 <lambdabot> String -> [String]
07:55:59 <MyCatVerbs> mmx166mhz: Is your nickname related to your first computer, perhaps? :)
07:56:06 <mmx166mhz> yeah!
07:56:18 <mmx166mhz> mmx is actually also  abrreviation of mathmadx
07:56:25 <ManateeLazyCat> mmx166mhz: See `words` and `lines`.
07:56:26 <mmx166mhz> regarding my interest therein;)
07:56:37 <MyCatVerbs> I guess your kids will have "GHz" in their nicknames, eventually.
07:57:33 <chupish> man, my first computer was a 386; kids these days with their fancy pants 166 mhz computers... :D
07:57:47 <koeien1> mine 286... and i'm not even old
07:57:47 <Jafet> "Created using a 2 nm process"
07:57:49 <leimy> MyCatVerbs: my code is written in a way that I have a thread parsing requests from stdin, several writing things to a stdout channel where a single thread sends the output (prevents interleaving of output by the unit on the TChan)
07:58:10 <leimy> then I have several other TChans for stdin's parsed request to go to a command processor
07:58:21 <leimy> and another TChan to get the data back from the request handler
07:58:30 <chupish> no am I koeien1, but hilarious none the less
07:58:43 <elanonimo> we're stuck in 3 GB addressspace of the current 32-bit processors.
07:58:44 <sproingie> i'm pretty sure we're seeing the end of moore's law within a couple decades
07:58:47 <leimy> but now, it looks like I've got the ability to send one command, and the rest go off to nowhere :-)
07:59:00 <sproingie> the next generation is going to see chips scaling out
07:59:01 <MyCatVerbs> leimy: That sounds perfectly sane and workable. :)
07:59:08 <elanonimo> at almost laptops
07:59:32 <chupish> sproingie: aren't we seeing it now? Chips aren't really getting faster, just more of them & smaller, with better power usage.
07:59:49 <koeien1> moore's law doesn't refer to the speed, right?
08:00:09 <sproingie> chupish: well moore's law has to do with density.  we're already seeing clock speeds take a step back but that's more for practical reasons
08:00:16 <elanonimo> soon, the laptops should support 6 GiB, 8 GiB, 12 GiB, ... of RAM, every them 64-bit.
08:00:40 <sproingie> theoretically speaking we can push clock speeds quite a bit more if we wanted to pour megawatts into every computer
08:00:52 <chupish> sproingie: yes, I know; that's what I mean, we're not really seeing the same level of increase; I didn't say it's dead, just that the begining may be here, baring some new tech :D
08:00:54 <fasta> sproingie, do you know the actual limit here?
08:01:09 <elanonimo> the limit is 3 GB, most people knows it
08:01:11 <sproingie> well it does have to do with density
08:01:22 <fasta> elanonimo, no, not that limit.
08:01:47 <sproingie> i suspect the next breakthrough in density will be some kinda nanotech
08:01:48 <mmx166mhz> the type of readFile "file.txt" is IOString, I cant apply functions which apply to String. How to overcome?
08:01:53 <sproingie> basically replacing the semiconductor transistor
08:01:56 <MyCatVerbs> koeien1: Moore's Law refers to transistor count.
08:02:22 <koeien1> mmx166mhz: main = do { x <- readFile "file.txt" ; ... do something with x ... }
08:02:22 <Jafet> Moore's law is irrelevant to modern computing; consider instead Parkinson's law
08:02:24 <fasta> We build faster computers, faster computers help design even faster computers and so on.
08:02:24 <MyCatVerbs> koeien1: speed tends to go up too, at least proportionally to the square root of that, as transistors get smaller.
08:02:31 <elanonimo> MyCatVerbs, why almost RAMs aren't double their capacities?
08:02:39 <MyCatVerbs> What Andy giveth, Bill taketh away. ^^
08:02:44 <koeien1> mmx166mhz: you might want to look up some information on how to do I/O in Haskell
08:02:56 <MyCatVerbs> elanonimo: because Moore's Law has slowed to about half the rate that people think it runs at, perhaps.
08:02:56 <koeien1> mmx166mhz: an example is the chapter on that in Real World Haskell
08:02:58 <koeien1> @where RWH
08:02:59 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:02:59 <ManateeLazyCat> mmx166mhz: Use `<-` get string from IO String
08:03:14 <JaffaCake> GHC meeting over in #ghc if anyone's interested
08:03:16 <MyCatVerbs> elanonimo: IIRC it runs at more like doubling every 3 years at the moment.
08:03:45 <MyCatVerbs> Also there have been some silly economics at play lately specifically because of the 32/64 bit switchover.
08:03:48 <elanonimo> it's still that almost people can't jump over 6 GiB of RAM
08:04:14 <sproingie> laptops anyway
08:04:22 <sproingie> my PC came with 9G out of the box
08:04:23 <elanonimo> 99% of them are stuck at 3 GiB or 3.5+ GiB of RAM.
08:04:40 <MyCatVerbs> That's plenty for the moment. ^^
08:05:13 <chupish> Dunno MyCatVerbs; I wouldn't mind a SiCortex desktop with GHC & Scheme :D
08:05:34 <MyCatVerbs> There's "wouldn't mind" and then there's "can't live without". :P
08:06:11 <chupish> well, most things of modernity are "wouldn't mind"s, no?
08:06:33 <chupish> still, I'd like to see something like CHP or the like on such a machine
08:06:48 <hotzen> BONUS: i got to "what then?"
08:06:59 <MyCatVerbs> I suspect that there's a pretty much minimal level of computing which we can't really get along without any more.
08:07:23 <MyCatVerbs> Warehouse inventory management, air control, traffic control, census-taking...
08:07:27 <hotzen> i didnt get that Foo Int = Char is inferred back and not executed
08:07:31 <hotzen> so what happens in this case?
08:07:38 <MyCatVerbs> Of course we could throw it all away and go back to doing everything on paper, but it would suck. :P
08:08:06 <chupish> Yes, especially things like parallel computing
08:08:29 <sproingie> the original definition of "computer" was a woman at a desk with an adding machine
08:08:35 <sproingie> very parallel design actually
08:08:52 <chupish> actually, it's a bit different
08:08:57 <edwardk> and the adding machine was an upgrade ;)
08:08:59 * chupish searchs for old dictionary
08:09:10 <chupish> ah "a person who sums columns of numbers"
08:09:27 <vshabanov> hi people, does anyone aware of working tcl/tk bindings for haskell? TclHaskell seems too old
08:10:09 <sproingie> tcl/tk seems too old
08:10:47 <sproingie> that toolkit needs to be left with motif and athena widgets
08:11:30 <vshabanov> latest versions seems to look more native
08:11:47 <vshabanov> at least from activetcl
08:12:13 <sproingie> functionality-wise tho...
08:12:30 <sproingie> on windows it's not so bad, it uses common dialogs.  used a tk file picker on unix lately?
08:12:59 <chupish> Tile makes Tk a bit nicer
08:14:33 <BONUS> hotzen: well that's the thing about type functions, a type function isn't guaranteed to return a different type for different "input types", so if you just do MkT "haha", it can't know it's supposed to be a T Int unless you specifically say :: T Int
08:15:38 <hotzen> oh, ok
08:15:45 <hotzen> thanks for that
08:16:14 <vshabanov> but (not counting look'n'feel questions) is there working tcl binding?
08:19:18 <sproingie> tclhaskell's all i know about
08:20:35 <chupish> if you've plenty of time on your hands, it might be worth adding Tk functionality to hiccup...
08:28:14 <stroan> I can bind to function symbols with the FFI, without requiring -fvia-C. Can I do the same for variable symbols? the foreign import ccall "&varname" etc. seems to be demanding -fvia-C
08:29:19 <mmx166mhz> let input = do{ contents <- readFile "database.txt" ; return (lines contents)} WHY is this still NOT a String(but an IO[String]). ..?
08:30:17 <stroan> mmx166mhz: once you go "into" the IO monad you can't really get out. It makes sense though, input will depend on the contents of database.txt so it is not "pure"
08:30:18 <hotzen> what is the "associate types" equivalent in java?
08:30:54 <mmx166mhz> Hey, this is pretty frustrating then!
08:31:00 <hotzen> hrhr
08:31:26 <sproingie> if you need to treat it like a pure string, lift a pure string function
08:31:36 <Heffalump> hotzen: you mean associated? There isn't one.
08:31:37 <mmx166mhz> How to do that.?
08:31:54 <stroan> :t liftM
08:31:55 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:32:35 <MoALTz> import Control.Monad  to get that (and others)
08:32:53 <hotzen> "Garcia et al compare the support for generic programming offered by Haskell, ML, C++, C# and Java. They give a table of qualitative conclusions, in which haskell is rated favourably in all respects except associated types" - How does he mean it regarding Java?
08:33:20 <stroan> :t liftM concat
08:33:20 <hotzen> OO vs. associated types?
08:33:21 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
08:33:22 <sproingie> you can treat content as a pure string if you use functions that return IO something
08:33:42 <Heffalump> oh, actually, Java does have inner types, perhaps they are enough. I wouldn't have thought so, though.
08:33:56 <Kim^Walkman> @type ap
08:33:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:33:58 <ksf> Java's generics are an ugly hack
08:34:10 <ksf> ...that is, they're implemented by dynamic typing.
08:34:11 <sproingie> do { putStrLn "what is your name?"; name <- getLine; putStrLn $ "Hello, " ++ name }
08:34:19 <sproingie> won't work here for obvious reasons
08:34:41 <guerrilla> so, any recommendations for a haskell library for some simple xml processing?
08:34:41 <ksf> while the typechecker is static, the jvm can't express polymorphism in any other way than casting to Object and back
08:34:58 <ksf> ...which wrecks havoc when you want to overload methods based on type.
08:35:28 <ksf> as every distinct generic List of something type has the same jvm type of list of Object
08:35:29 <stroan> don't suppose anyone knows how to import variable symbols without requiring -fvia-C?
08:35:30 <BONUS> sproingie: which reasons would those be? :D
08:35:38 <sergueyz> Associated types are types associated with another types. class Foo a where { type Bar a; ...} instance Foo Int where { type Bar Int = Bool; ...}
08:35:51 <sproingie> BONUS: no IO in lambdabot
08:35:54 <ksf> associated types are syntactic sugar for type families
08:35:58 <BONUS> oh you mean in lambdabot
08:36:04 <BONUS> sorry i wasn't paying attention
08:36:07 <Apocalisp> @pl putStrLn "What is your name?" >> getLine >>= putStrLn . ("Hello," ++)
08:36:08 <lambdabot> putStrLn "What is your name?" >> getLine >>= putStrLn . ("Hello," ++)
08:36:09 <sergueyz> 'Bar a' is an associated type (I think).
08:36:21 <ksf> sergueyz, yes
08:36:35 <sproingie> yes i was trying to illustrate the use of "name"
08:36:46 <ksf> you could pull it out of the class and use a type family, though.
08:36:52 <sproingie> i guess i should have actually lifted something, eh?
08:36:53 <Apocalisp> @do putStrLn "What is your name?" >> getLine >>= putStrLn . ("Hello," ++)
08:36:53 <lambdabot> do { a <- do { putStrLn "What is your name?"; getLine}; (putStrLn . ("Hello," ++)) a}
08:36:59 <Apocalisp> ooh
08:37:02 <hotzen> ksf: is there a difference between associated types and type families?
08:37:04 <sproingie> wow
08:37:13 <ksf> hotzen, the latter subsumate the former
08:37:29 <ksf> you also get -XAssociatedTypes for free when you enable -XTypeFamilies
08:37:31 <hotzen> thanks
08:38:12 * ksf doesn't understand why haskell wouldn't be rated favourably wrt. ass. types
08:38:35 <ksf> or is that back from a time where GHC didn't have them, yet?
08:38:37 <hotzen> i think, they haven't been implemented then
08:38:39 <hotzen> yes
08:38:50 <hotzen> its from fun with type funs, v2
08:39:03 <ksf> must have missed that one
08:39:16 <hotzen> i have to presentate the key features next week :(
08:39:26 <BONUS> ass. types
08:39:29 <sergueyz> that paper is very old. there weren't any in haskell.
08:39:42 <ksf> oh, do peano numbers on the type level
08:40:33 <hotzen> are type funs really turing complete?
08:40:49 <ksf> Add is trivial, an application of Sub doesn't typecheck if its result would be <0, for free, and mult requires -XUndecidableInstances
08:40:49 <Heffalump> with UndecidableInstances, yes
08:41:09 <hotzen> ill shoot myself ...
08:41:15 <ksf> ...though Mult could arguably be proved terminating by a quite simple checker.
08:41:59 <ksf> the nice thing is that it's all very, very readable with type families.
08:42:35 <hotzen> like anything in haskell.... but you have to understood it in depth or you drool ...
08:42:37 <tromp_> g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1 cld not be proved terminating though
08:43:19 <tromp_> if turned into a typeclass
08:44:01 <Jafet> What sort of logic would the typechecker be simulating, in this case?
08:44:12 <hotzen> brainfuck?
08:44:26 <sproingie> so what happens if you have nonterminating types?  ghc loop forever or does it eventually blow up?
08:44:30 <ksf> we have bf on the type level
08:44:34 <tromp_> that's goodstein's function
08:44:50 <Jafet> So FOL, then
08:44:58 <ksf> sproingie, it should error out, and ask you to increase recursion depth.
08:45:22 <ksf> at least it always did that when I blew it up
08:45:28 <Jafet> I thought goodstein's function was some complicated digit manipulation
08:45:29 <FunctorSalad> nonterminating types?
08:45:41 <ksf> you can make it not terminate with RULES or TH, though.
08:45:51 <sproingie> ghc: you blew it up!  damn you all to hell!
08:45:54 <elanonimo> is failing the theory?
08:46:18 <ksf> no, in theory you always succeed. it's when theory doesn't match practice that you fail.
08:47:04 <FunctorSalad> ksf: I thought the problem with WP was that it only worked in practice...
08:47:16 <sproingie> FunctorSalad: my attempt to find a name for "a type program that doesnt terminate"
08:48:13 <ksf> oh, yes, the blessing of naivete. like the cyberneticans of olde, who didn't knew that what they did was impossible so they did it anyway.
08:48:52 <FunctorSalad> ? what was that
08:49:37 <ksf> ...because, you see, computability theories usually don't include human creativity+adaptability+situational awareness in their models.
09:07:21 <hotzen> simply spoken: in which regard is haskell's "class" to java's interface?
09:08:16 <Cale> hotzen: Well, it's a better match than Haskell class to Java's class?
09:08:18 <quicksilver> they look similar but have different intended purposes.
09:08:33 <quicksilver> they are both a collection of signatures
09:08:44 <quicksilver> but haskell typeclasses are intended for overloading
09:08:52 <quicksilver> whilst java's interfaces are intended for a kind of polymorphism
09:09:03 <Cale> er, what?
09:09:07 <hotzen> parametric polymorphism over it's methods?
09:09:18 <mmx166mhz> Hi everyone
09:09:27 <mmx166mhz> I am still stuck with my problem
09:09:43 <Cale> Haskell typeclasses are a means of restricting the types over which type variables range in parametrically polymorphic functions and values
09:09:55 <mmx166mhz> The fact that String read in from a file is a IOString , and none of my functions written for strings work for them!
09:10:05 <mmx166mhz> So basically reading in files is useless?:S
09:10:11 <Cale> Java interfaces are treated as types in Java
09:10:35 <hotzen> ah, so they are not comparable?
09:10:35 <Jafet> mmx166mhz, you need to read a few of the several hundred explanations of monads in Haskell available on the internet
09:10:52 <quicksilver> mmx166mhz: simply, though, use <- to unwrap an IO String into a sring
09:11:00 <quicksilver> mmx166mhz: foo <- readFile "foo.txt"
09:11:07 <quicksilver> (this syntax is only valid inside a do block)
09:11:10 <mmx166mhz> hmm,
09:11:14 <quicksilver> then foo is String, not IO string.
09:11:21 <mmx166mhz> aha
09:12:09 <hotzen> hm
09:12:30 <hotzen> so a haskell-class defines must-implement functions and restricts their parametric-types?
09:12:45 <hotzen> whereas java-interfaces are types themselves and define must-implement functions?`
09:13:11 <hotzen> is there any "big" difference?
09:13:24 <zygoloid> yes. typeclasses are strictly more general.
09:13:36 <Jafet> Stop thinking in blub hotzen
09:13:39 <hotzen> strictly more general? ;)
09:13:41 <hotzen> blub?
09:14:15 <zygoloid> because: 1) they can be added after the fact. 2) the methods do not need to take the given type as an argument (they can, for instance, return it, or use it any way they like in the type signature)
09:14:39 <zygoloid> there are more reasons if you allow haskell'98 extensions, such as the natural generalization to multi-parameter type classes, associated types and so on
09:15:23 <hotzen> k
09:15:40 <hotzen> i am just preparing associated types for students knowing oo and java
09:15:54 <Jafet> Oh.
09:16:05 <Jafet> Well then, stop encouraging students to think in blub...
09:16:09 <zygoloid> oh, and i forgot, 3) types which are instances of type classes don't have to be of kind *
09:16:10 <hotzen> and i am looking for a "nice" way to explain the differences and equalities to haskell-classes
09:16:14 <hotzen> what does blub mean?
09:16:25 <zygoloid> @google Paul Graham Blub paradox
09:16:26 <lambdabot> http://www.paulgraham.com/avg.html
09:16:26 <lambdabot> Title: Beating the Averages
09:16:38 * Jafet hugs lambdabot
09:16:41 <Philonous> How do you require an argument of a function to implement two distinct interfaces in java?
09:16:50 <quicksilver> zygoloid: if they add static methods to interfaces (as was proposed at least) that would resolve (2), I think.
09:17:07 <quicksilver> Philonous: pass it twice and check for equality? ;)
09:17:08 * zygoloid nods
09:17:29 <Philonous> quicksilver: You're kidding, right?
09:17:29 <quicksilver> but to me there is also a difference in intended use which goes beyond expressibility.
09:17:39 <quicksilver> which I failed to explain well.
09:17:43 <hotzen> philonous: hm scala should do that with its traits, doesn't it?
09:17:47 <quicksilver> Philonous: nobody would use java seriously, would they?
09:17:52 <Philonous> I don't know scala
09:17:56 <quicksilver> Philonous: so any comment about java is naturally intended in jest.
09:18:04 <quicksilver> it's a joke language.
09:18:08 <hotzen> ok, i wont do blub but im looking for anologies in java
09:18:41 <quicksilver> I'm trying to say that "interfaces-are-actually-types" is inherent in the Java intended use of interfaces
09:18:44 <hotzen> i mean analogies
09:18:51 <hotzen> got that
09:18:52 <quicksilver> whereas the intended use of haskell typeclasses really is overloading.
09:19:05 <quicksilver> like (+), for example.
09:19:07 <hotzen> ok, thank you
09:19:09 <zygoloid> quicksilver: i wouldn't say that.
09:19:10 <jmcarthur_work> dude, bindings-DSL is nice
09:19:31 <quicksilver> Num (whether you love it or hate it the way it's one big class instead of lots of little ones) is all about overloading (+), (*) and so on
09:19:40 <zygoloid> quicksilver: overloading is one reason. but allowing the creation of general functions which work over anything which provides a certain interface with a certain semantics is i think the key thing.
09:20:03 <quicksilver> Monad is about overloading >>=/return (and thus do notation), so that you can reuse powerful combinators like mapM
09:20:08 <zygoloid> rather than just the C++-style overloading as in using-the-same-name-for-something-else
09:20:35 <quicksilver> zygoloid: yes, it's a more regimented kind of overloading than that, definitely.
09:20:37 <zygoloid> haskell typeclasses are not for overloading << to mean stream-insert rather than left-shift
09:20:43 <quicksilver> agree
09:21:12 <zygoloid> i think we're saying the same thing, but i don't like calling it overloading because i think that has other connotations
09:21:25 <hotzen> thats interesting, thanks
09:21:31 <jmcarthur_work> it has connotations if you come from C++, definitely
09:21:35 <Jafet> Semantic reuse?
09:22:06 <FunctorSalad> quicksilver: how would static interface methods solve 2)? you'd *lose* the one position they're polymorphic in ;)
09:22:42 <FunctorSalad> unless you mean adding some sort of dispatch by argument types too
09:23:01 <zygoloid> FunctorSalad: you could say 'interface Foo { Foo MkFoo() }', but you're right that 'A.MkFoo()' would statically be of type A
09:23:08 <zygoloid> *not statically
09:23:29 <zygoloid> s/Foo MkFoo/static Foo MkFoo/g
09:23:33 <Jafet> hotzen, you may find this interesting http://haskell.org/onlinereport/standard-prelude.html
09:23:40 <quicksilver> sure, but java people are used to their static types being limited :)
09:23:48 <quicksilver> there are all kinds of cases where you need to cast in java
09:23:57 <FunctorSalad> :(
09:24:00 <Jafet> Oh lord, we're talking about java now
09:24:08 <quicksilver> (A)(A.MkFoo()) would be quite natural to them ;)
09:24:10 <hotzen> jafet: thanks ;)
09:24:31 <quicksilver> or (A)((typeof a).MkFoo()) or some such
09:25:00 <Jafet> hotzen, then you can look at the CReal library to see how it plugs cleanly into the Num class
09:26:04 <FunctorSalad> Foreign.C.Real :D
09:26:25 <FunctorSalad> (yes, old one)
09:31:07 <witten_> how do the modifications to linear types that allow some aliasing (e.g. L^3) work?
09:31:27 <quicksilver> that's a hardcore question.
09:31:28 <witten_> I don't understand how splitting a type into a pointer and a capability buys you anything
09:31:43 <witten_> I figured this might be the place to ask it
09:34:57 <witten_> or maybe there's a better place?
09:35:57 <quicksilver> witten_: certainly a good chance to find someone here who knows the answer
09:36:01 <quicksilver> although apparently not right now :)
09:36:43 <witten_> okay, thanks :)
09:51:16 <Gwern-away> besides hawiki, hoogle, and hackage, are there any sites people routinely link to?
09:51:49 <edwardk> Gwern-away: ?
09:52:02 <Badger> rwh and lyah?
09:52:05 <Philonous> hayoo ?
09:52:10 <Badger> well, not routinely perhaps.
09:52:14 <Gwern-away> edwardk: gitit plugin. I want to write things like [foobar](!Hoogle) or [foobar](!Hawiki)
09:52:31 <edwardk> Gwern-away: i'm particularly guilty of pointing to old blog articles of mine on here.
09:52:33 <edwardk> ah
09:52:42 <Gwern-away> edwardk: where the resulting link points to... "http://haskell.org/hoogle/?hoogle=foobar"
09:52:46 <edwardk> i thought you were looking to add some kind of auto-kick to lambdabot or something =)
09:52:53 <Gwern-away> Philonous: oh, hayoo. hm, yeah
09:53:12 <Gwern-away> (funnily, I never use it. I should probably figure out where/if it's any better than hoogle)
09:53:35 <ksf> it seems to have a bigger index
09:53:45 <ksf> and the interface is more web2.0
09:54:01 <ksf> which means that it's nicer, but sucks if you want to link to the result page
09:54:07 <Philonous> hayoo includes extra packages and I like the formatting better
09:54:49 <ksf> does it do contravariance search?
09:55:20 <Philonous> You mean given the type it returns the function name?
09:55:59 <ksf> no given Monad m => a -> m b it should return bind
09:56:14 <ksf> as you can put such a function into bind
09:56:52 <Philonous> Evidently not
09:57:05 <zygoloid> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%28Monad%20m%29%20%3D%3E%20a%20-%3E%20m%20b
09:57:34 <ksf> that's an anchor though, no query
10:00:20 <burp> @hoogle <+>
10:00:22 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
10:00:22 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
10:00:22 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
10:01:16 <zygoloid> ksf: fancy javascript like hayoo's could pick that up and query on it. but it doesn't. i'm not really sure why it even bothers to set the anchor..
10:01:43 <zygoloid> ksf: actually, looks like it /does/ query on it. sometimes.
10:02:10 <ksf> newfangled knicknack
10:02:56 <zygoloid> hayoo's type searches aren't very good
10:03:11 <zygoloid> maybe i'm just spoiled by hoogle. but even exact matches don't work reliably
10:08:16 <Philonous> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=%28Monad%20m%29%20-%3E%20a%20-%3E%20m%20b
10:11:49 <paolino> anyone can hint me on how to use promote, please ?
10:11:56 <paolino> :t promote
10:11:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Gen a) -> Gen (m a)
10:12:45 <paolino> I need to thread a state in a arbirary definition, can it be useful ?
10:13:20 * hackagebot upload: hpage 0.4.5 - A scrapbook for Haskell developers (FernandoBenavides)
10:21:14 <Philonous> Is it possible to tell cabal to use gmake instead of make ?
10:25:11 <donri> Philonous, symlink?
10:25:46 <Jafet> A better question is, why is make not gmake?
10:26:08 <Philonous> because FreeBSDs make doesn't understand GNU make syntax
10:26:11 <donri> or if you have a different make, perhaps alias cabal to something that locally aliases make to gmake
10:30:16 <mmorrow> , let go n = let !o = foldl' (+) 0 [1..n] in \x -> o + x in time (go 1000000 `seq` ())
10:30:21 <lunabot>  (0.426935,())
10:30:43 <mmorrow> , let go n = let o = foldl' (+) 0 [1..n] in \x -> let !z = o in z + x in time (go 1000000 `seq` ())
10:30:45 <lunabot>  (0.0,())
10:30:52 <mmorrow> , let go n = let o = foldl' (+) 0 [1..n] in \x -> let !z = o in z + x in time (go 1000000 0 `seq` ())
10:30:54 <lunabot>  (0.254962,())
10:31:16 <mmorrow> , let go n = let !o = foldl' (+) 0 [1..n] in \x -> o + x in go 1000000 `seq` time (go 0 `seq` ())
10:31:18 <lunabot>  (0.0,())
10:33:34 <fxr> Philonous: there's no way to declare make program in cabal. It was hardcoded in Distribution.Make. You better symlink as donri suggests.
10:34:50 <Philonous> Thanks.
10:42:16 <donri> (something should probably be done about that)
10:47:35 <path__> hi I was told that when I wanna do a simple fold the most likely one I want is foldl', is that right
10:49:46 <fxr> path__: use foldl instead of foldr at least. See graph representations on http://www.haskell.org/haskellwiki/Fold.
10:49:49 <Hunner> The good thing about Haskell is that its name is easily googleable. The bad thing about Haskell is that its myriad of operators are not.
10:50:17 <lament> the other good thing about haskell is that its operators are easily hoogleable.
10:50:26 <Hunner> yes, there is that.
10:50:27 <jlouis> Hunner: hoogle
10:50:32 <fxr> and hayooable
10:50:34 <luite> Hunner: at least they're hoogleable
10:50:48 <luite> bah too late :p
10:51:16 <path__> fxr I dont understand how that suggests foldl is better than foldr
10:51:19 * Hunner discovered hoogle last week. Life is better
10:51:52 <fxr> path__: remember you're working with lazy lists.
10:52:02 <Lemmih> path__: It's not. They're two different functions doing two different things.
10:52:29 <path__> yeah I understand but if Im working with a small finite list, why is foldl a better option
10:52:32 <ksf> foldr fits perfectly into the iterator-style workings of lazy lists
10:52:45 <path__> I understand foldr can deal with infinite lists because I can stop early
10:53:26 <EvilTerran> path__, foldl can use O(1) memory in some circumstances; it's purely a performance thing
10:53:38 <ksf> it also doesn't have to unroll the list on the stack, so if you traverse it and don't hold a ref to its beginning, the gc can clean up as you generate elements.
10:53:49 <path__> hmm
10:53:53 <EvilTerran> ksf, that being how it can use O(1) memory
10:54:09 <ksf> yep, but that being foldr.
10:54:26 <ksf> , foldr f 0 [1..10]
10:54:28 <lunabot>  luna: Ambiguous type variable `b' in the constraints:
10:54:31 <cdiem> I was just looking at this regarding foldl/foldr: http://stackoverflow.com/questions/384797/implications-of-foldr-vs-foldl-or-foldl
10:54:31 <ksf> , foldr f 0 [1..10] :: Expr
10:54:33 <lunabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
10:54:35 <EvilTerran> well, it's more that the intermediate lists can get fused out of existance at compile-time, so don't even get allocated in the first place
10:54:48 <ksf> see it can start to reduce f 1 right away.
10:54:54 <ksf> , foldl f 0 [1..10] :: Expr
10:54:56 <lunabot>  f (f (f (f (f (f (f (f (f (f 0 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
10:55:17 <path__> EvilTerran: ah
10:55:31 <ksf> while here, it first has to unroll the whole list before it can start to reduce f <something> 10
10:55:38 <path__> well I was told if I wanna use foldl I should just use foldl' instead cause it doesnt keep too many thunks
10:56:06 <fxr> path__: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
10:56:14 <ksf> yep if you need foldl, you usually want foldl'
10:56:46 <path__> so the thing is when I type :t foldl in ghci I get a response but when I type :t foldl' I get
10:56:51 <ksf> but primitive operators like (+) are strict, anyway.
10:57:03 <path__> <interactive>:1:0: Not in scope: `foldl''
10:57:22 <ksf> could be in data.list or such
10:57:38 <jlouis> can't lambdabot answer where a name is?
10:57:52 <ksf> tbh, I usually use foldr or explicit recursion
10:57:54 <jlouis> I vaguely remember that being coded into it years ago
10:59:06 <path__> ah so its not in prelude like foldl and foldr?
10:59:29 <fxr> jlouis: @hoogle can answer
11:00:02 <burp> yes it's in Data.List
11:00:19 <path__> thanks
11:02:12 <path__> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4981#a4981 <--- can someone tell me how to write this nicer?
11:04:53 <Twey> ksf: I think that (+) needn't be strict
11:05:05 <sproingie> path__: using Data.Map would probably look nicer
11:05:15 <path__> on which part?
11:05:42 <sproingie> all the parts where you're indexing into arrays
11:05:58 <Twey> IntMap?
11:06:41 <sproingie> > fromList [(10, "Ten"), (20, "Twenty"), (30, "Thirty")]
11:06:42 <ksf> Well, on most types.
11:06:43 <lambdabot>   Not in scope: `fromList'
11:06:50 <sproingie> bah
11:06:51 <ksf> not on Natural, at least
11:06:55 <sproingie> , fromList [(10, "Ten"), (20, "Twenty"), (30, "Thirty")]
11:06:57 <lunabot>  luna: Not in scope: `fromList'
11:07:01 <Botje> path__: you could merge tensArray and specArray
11:07:05 <sproingie> > bite me
11:07:06 <lambdabot>   Not in scope: `bite'Not in scope: `me'
11:07:17 <ksf> but then Natural is'nt exactly a thing backed by unboxed type and operated on by primops
11:07:17 <poucet> > a b c
11:07:18 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
11:07:19 <lambdabot>                           ...
11:07:27 <poucet> > why are there no whitespaces
11:07:29 <lambdabot>   Not in scope: `why'Not in scope: `are'Not in scope: `there'Not in scope: `n...
11:07:39 <path__> sproingie: but Id have to type a lot more :/
11:07:42 <PeakerWork> @seen augustuss
11:07:43 <lambdabot> Unknown command, try @list
11:07:59 <Botje> oh wait, nvm
11:08:00 <path__> Botje: how would I do that? Would you mind just modifying the pastie :)
11:08:02 <PeakerWork> augustuss is alive and well, apparently.. He commented on Reddit...
11:08:25 <mauke> preflex: seen augustss
11:08:26 <preflex>  augustss was last seen on #haskell 80 days, 6 hours, 48 minutes and 33 seconds ago, saying: I was thinking of hac7 :)
11:09:01 <path__> hundredsToWord takes a 3 digit number and gives it to me in word camelcased
11:09:27 <Botje> path__: yeah, nevermind. I just spotted why not.
11:09:37 <path__> ok
11:09:43 <Phyx-> hmm this white default irssi theme sucks
11:09:58 <Phyx-> i can't read my own nick
11:09:59 <Phyx-> :|
11:10:30 <sproingie> > fromList $ zip [10,20..] ["Ten", "Twenty", "Thirty"]
11:10:31 <lambdabot>   Not in scope: `fromList'
11:10:34 <sproingie> oh right
11:11:59 <sproingie> my left nut for a prelude string split function
11:12:00 <Phyx-> test
11:12:03 <Phyx-> > id
11:12:04 <lambdabot>   {()->()}
11:12:28 <sproingie> i guess words would do here
11:12:36 <Twey> Phyx-: Adjust your terminal colour settings ‚Äî there shouldn't be any colour in the palette that's identical to the background colour
11:13:36 <sproingie> fromList $ zip [10,20..] $ words "Ten Twenty Thirty Fourty Fifty Sixty Seventy Eighty Ninety"
11:13:39 <sproingie> there
11:14:02 <Twey> Aye
11:14:07 <mauke> > M.fromList $ zip [10,20..] $ words "Ten Twenty Thirty Fourty Fifty Sixty Seventy Eighty Ninety"
11:14:08 <lambdabot>   fromList [(10,"Ten"),(20,"Twenty"),(30,"Thirty"),(40,"Fourty"),(50,"Fifty")...
11:14:11 <path__> sproingie: ah I get it
11:14:26 <sproingie> ahh M
11:14:46 <sproingie> > let tens = M.fromList $ zip [10,20..] $ words "Ten Twenty Thirty Fourty Fifty Sixty Seventy Eighty Ninety" in tens ! 30
11:14:47 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
11:14:47 <lambdabot>         against inferred t...
11:14:52 <path__> thanks Ill try that
11:14:52 <lament> a function that splits on space is quite a lot less useful than a function that splits on a specified delimiter
11:14:59 <sproingie> blean
11:15:36 <copumpkin> > liftA2 (+) (Just 5) (Just 7) -- EnglishGent^semi
11:15:37 <lambdabot>   Just 12
11:15:50 <sproingie> i'm still trying to figure out what's wrong with that
11:15:59 <sproingie> the thing i just tried above
11:16:01 <copumpkin> > liftA2 (+) (Just 5) Nothing -- EnglishGent^semi
11:16:02 <lambdabot>   Nothing
11:16:18 <copumpkin> > liftA2 (+) (pure 5) (Just 7) -- EnglishGent^semi
11:16:19 <lambdabot>   Just 12
11:16:36 <Badger> :t pure
11:16:37 <copumpkin> @type \f x y -> liftA2 f (pure x) y -- EnglishGent^semi
11:16:38 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
11:16:38 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> a -> f b -> f c
11:16:48 <mauke> > let tens = M.fromList $ zip [10,20..] $ words "Ten Twenty Thirty Fourty Fifty Sixty Seventy Eighty Ninety" in tens M.! 30
11:16:48 <copumpkin> @type \f x y -> liftA2 f x (pure y) -- EnglishGent^semi
11:16:49 <lambdabot>   "Thirty"
11:16:49 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> b -> f c
11:17:06 <sproingie> ah.  forehead-smack
11:17:55 <sproingie> i assumed ! was defined in a typeclass
11:18:11 <Twey> :t (!)
11:18:13 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
11:18:18 <Twey> Huh.
11:18:25 <Twey> Oh
11:18:33 <Twey> Of course it doesn't work on other arrays.
11:18:39 <Twey> It's pure.
11:18:39 <sproingie> :t (M.!)
11:18:40 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
11:18:43 <Phyx-> hrm. i was reviewing some of my old code today, and i found a comment "-- we miss you wli"
11:18:46 <Phyx-> lol
11:18:51 <Twey> Phyx-: o.@
11:18:59 <path__> hmm words ignores leading spaces?
11:19:10 <path__> can I split on something other than spaces?
11:19:12 <monochrom> > words "  x"
11:19:13 <lambdabot>   ["x"]
11:19:26 <sproingie> path__: by writing your own, or using Text.Regex.split
11:19:35 <sproingie> it's an annoying oversight
11:19:36 <Phyx-> Twey: now, the question is, what happened to wli?
11:19:36 <path__> cause I need to match a blank string against 0
11:19:40 <Phyx-> @seen wli
11:19:41 <lambdabot> Unknown command, try @list
11:19:46 <Phyx-> #seen wli
11:19:47 <lunabot>  luna: Not in scope: `seen'
11:19:53 <mauke> sproingie: Data.List.Split?
11:19:53 <sproingie> @google haskell python split
11:19:54 <lambdabot> No Result Found.
11:19:57 <path__> ah
11:20:10 <sproingie> i take it @google got dwimmed to @hoogle
11:20:17 <Twey> Phyx-: I didn't actually notice that he'd vanished.  Good question, though.
11:20:28 <Twey> ,seen wli
11:20:29 <lunabot>  luna: Not in scope: `seen'
11:20:32 <Twey> Ack
11:20:35 <Twey> preflex: seen wli
11:20:35 <preflex>  wli was last seen on #haskell-blah 131 days, 20 hours, 56 minutes and 16 seconds ago, saying: He's in the bathroom right now having another of those hushed convos about dumping me.
11:20:41 <Phyx-> we need to send out a search party!
11:20:46 <Twey> Oh
11:20:50 <Twey> Sounds like life happened :-\
11:20:56 <Phyx-> :-\
11:20:59 <sproingie> ah, SplitOn
11:21:27 <tommd> preflex: seen lunabot
11:21:27 <preflex>  lunabot was last seen on #haskell 37 seconds ago, saying:  luna: Not in scope: `seen'
11:21:27 <sproingie> > L.splitOn ", " "hello, world"
11:21:27 <lambdabot>   Not in scope: `L.splitOn'
11:21:27 <chrisdon`> woot, The Complete Works of Chuang Tzu arrived! ^_^
11:21:27 <Phyx-> Twey: i hope she's ok
11:21:27 <mauke> she?
11:21:33 * Twey thought wli was male.
11:21:35 <sproingie> how do i know what lambdabot has imported as what names?
11:21:57 <Phyx-> I assume it was a she since the comment said "he's in the bathroom ... dumping me"
11:22:05 <path__> hmm couldnt find package data.list.split
11:22:06 <Twey> Phyx-: Not only females can have boyfriends :√æ
11:22:13 <chrisdon`> mauke: Twey: you're both gender fixated
11:22:20 <Phyx-> Twey: i suppose not, but that's my first conclusion :P
11:22:35 <mauke> chrisdone: how so?
11:22:40 <tommd> Well I asked lambdabot and she said she though I knew already.
11:22:49 <path__> I cant import data.list.split
11:22:58 <Twey> chrisdone: I just remember wli as being male.  *shrug*
11:22:59 <sproingie> Data.List.split
11:23:02 <sproingie> case-sensitive
11:23:09 <tommd> import Data.List (split)
11:23:13 <tommd> @hoogle split
11:23:13 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
11:23:14 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
11:23:14 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
11:23:16 <mauke> what
11:23:20 <tommd> @hoogle Data.List.split
11:23:21 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
11:23:21 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
11:23:25 <tommd> Not split.
11:23:26 <mauke> it's Data.List.Split
11:23:28 <mauke> case sensitive
11:23:32 <Twey> Heh
11:23:34 <sproingie> i think you want splitOn
11:23:36 <tommd> Oh, is there a "Split" module?
11:23:39 <mauke> yes
11:23:42 <path__> @hoogle Data.List.Split
11:23:42 * chrisdone stops further attempts at irony
11:23:42 <Twey> On Hackage, yes
11:23:42 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
11:23:42 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
11:23:49 <Twey> I don't think \b has it
11:23:50 <sproingie> oh Data.List.Split.splitOn
11:23:51 <tommd> No, hoogle doesn't do hackage.
11:23:53 <Twey> chrisdone: Heh
11:24:06 <Phyx-> come to think of it
11:24:09 <Phyx-> why doesn't hoogle do hackage
11:24:11 <path__> oh I dont wanna install another package atm
11:24:13 <path__> nm then
11:24:17 <path__> I dont have it
11:24:18 <sproingie> i didn't even notice the .Split.  i was wondering why i hadn't noticed that stuff in the standard lib
11:24:22 <tommd> Phyx-: Because ndm graduated before making it do that.
11:24:27 <tommd> ndm++
11:24:58 <sproingie> wow split is hairy
11:25:20 <Cale> sproingie: hm?
11:25:25 <Phyx-> tommd: I thought hoogle is still in developement, doesn't Neil still work on it?
11:25:36 <sproingie> Cale: it's very very generic and customizeable
11:25:44 <sproingie> not a bad thing, just more than i expected
11:25:50 <tommd> Phyx-: Neil works more on his day job and has been much less active with the Haskell community since getting the job.
11:25:51 <Cale> ah
11:26:03 <tommd> Not that I blame him, he needs to make a living _and_ have a life.
11:26:33 <Phyx-> tommd: oh, I thought he got a grant to work on Hoogle full time
11:27:02 <tommd> Phyx-: No, he is making millions with some Credite-Sussie like company iirc.
11:27:18 <tommd> Otherwise we would still see him on IRC these days.
11:27:29 <tommd> But all things come to pass.
11:27:44 <Phyx-> heheeh
11:27:44 <sproingie> i really hate iPod earbuds
11:27:50 <Phyx-> i hate iPods
11:27:55 <lament> i hate ears
11:27:56 <shambler> why?
11:28:34 <sproingie> nice and comfortable rubber rings, but that exposed metal face?  static zappiness abounds
11:28:35 <chrisdone> yeah I bought some earbuds for like $20 and they were like sitting in a tin can and hurt
11:28:42 <path__> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4981#a4982 <--- here we go
11:28:49 <path__> much nicer
11:29:00 <sproingie> their quality is pretty good for starter earbuds, it's the zappiness factor
11:29:02 <Phyx-> tommd: can't imagine it would take alof of work to get hoogle to work with hackage though, isn't it more about generating the new database every day or so?
11:29:16 <path__> thanks sproingie
11:30:05 <chrisdone> sproingie: I got some sony ones from wallmart a few years ago and they have never ever faltered, are bassy and have a thin rubbery film that adjusts to any ear. I love them. if I lost them I'd cry because they don't sell them anymore =D
11:30:17 <sproingie> i guess i wouldn't have the static shock problem if my phone weren't charging and thus grounded
11:30:48 <sproingie> but pandora sucks down battery like no ones business
11:30:49 <tommd> Phyx-: You can e-mail him and ask, though truth be told I haven't even seen him online via gmail-chat in a long time.  Understand that I don't really know him, but was used to seeing him on a lot.
11:30:56 <tommd> preflex: seen ndm
11:30:56 <preflex>  ndm was last seen on #haskell 193 days, 9 hours, 12 minutes and 39 seconds ago, saying: plus with current compiler technology, it would be slower
11:31:10 <tommd> preflex: seen nmitchell
11:31:10 <preflex>  Sorry, I haven't seen nmitchell
11:31:16 <Phyx-> seemed to have vanished around the same time as wli
11:31:18 <sproingie> preflex: seen god
11:31:19 <preflex>  god was last seen on ##c++ 45 days, 20 hours, 26 minutes and 16 seconds ago, saying: I don't really know either actually
11:31:24 <sproingie> YES
11:31:31 <chrisdone> what on earth was he doing in ##c++
11:31:47 <burp> must be fake god
11:31:52 <mauke> preflex: great success!
11:32:05 <tommd> @botsnack
11:32:05 <lunabot>  :o
11:32:06 <lambdabot> :)
11:32:21 <mauke> I don't remember lambdabot reporting a person seen more than a few days ago
11:33:07 <monochrom> :)
11:41:56 <Phyx-> it's like an atom bomb fell in here, where'd everyone go
11:42:59 <copumpkin> shh
11:43:02 <copumpkin> hiding under the desk
11:43:08 <iMonad> :)
11:43:16 <lament> duck and cover!
11:43:43 <Zao> As long as no-one talks about the bomb, the unsafe side effects will not trigger.
11:43:45 <Phyx-> hahahah
11:44:06 <Philonous> Installing wxhaskell is a real pita. Cabal doesn't pass --user to the configure script and the make file lacks include dirs
11:44:09 <monochrom> hahaha
11:45:29 <joe___> are u aware of a function that can transform "Data.ByteString.Internal.ByteString" to "Integral" so that I can use showHex
11:45:33 <joe___> :t showHex
11:45:34 <lambdabot> forall a. (Integral a) => a -> String -> String
11:46:08 <dcoutts> Philonous: the wxhaskell package can of course just use a custom Setup.hs that does do so
11:46:09 <joe___> I can use  Data.ByteString.unpack to go to Word8
11:46:19 <joe___> :t Data.ByteString.unpack
11:46:19 <copumpkin> joe___: you'll need to specify your needs more
11:46:20 <lambdabot> BSC.ByteString -> [Word8]
11:46:27 <copumpkin> big endian, little endian? some other byte ordering?
11:46:30 <copumpkin> how many bytes?
11:46:41 <Philonous> dcoutts: Well, it doesn't
11:46:41 <joe___> I am trying to print a string of 8 bytes
11:46:59 <copumpkin> signed or unsigned?
11:47:10 <joe___> unsigned
11:47:15 <copumpkin> joe___: Data.Binary's decode for Word64 should do it then
11:47:31 <joe___> will check it out
11:47:36 <joe___> thanks
11:48:01 <Egg_> can someone clarify the way to make a new line in haskell? I have \n so far, but GHCI just returns my text with actual \n inserted in it
11:48:05 <Egg_> http://pastebin.com/m3ccf8a19 is my code
11:48:41 <Egg_> it's splitting a list of strings into new lines for each element of the list btw
11:49:07 <Phyx-> :t unlines
11:49:08 <lambdabot> [String] -> String
11:49:23 <Cale> Egg_: GHCi quotes String values in order to show them to you
11:49:24 <Phyx-> > unlines ["hello","world"]
11:49:26 <lambdabot>   "hello\nworld\n"
11:49:35 <Phyx-> :t newLineChar
11:49:35 <blackh> Egg_: That is a new line.  Try putStrLn to output it
11:49:36 <lambdabot> Not in scope: `newLineChar'
11:49:47 <shambler> @src lines
11:49:48 <lambdabot> Source not found. Just try something else.
11:49:48 <Cale> Egg_: If you apply putStrLn the string, then you get an action which prints it on the screen directly.
11:49:53 <Cale> to*
11:49:53 <Egg_> ah right
11:49:55 <Egg_> thanks
11:50:14 <Phyx-> hm, his functions weren't in IO, i assumed it wanted it outside IO
11:50:15 <Phyx-> lol
11:50:42 <Phyx-> @hoogle newline
11:50:43 <lambdabot> Text.Parsec.Char newline :: Stream s m Char => ParsecT s u m Char
11:50:43 <lambdabot> Text.ParserCombinators.Parsec.Char newline :: Stream s m Char => ParsecT s u m Char
11:50:43 <lambdabot> Text.Regex.Posix.ByteString compNewline :: CompOption
11:50:48 <Phyx-> odd
11:51:20 <mauke> Phyx-: what's wrong with '\n'?
11:51:37 <Phyx-> mauke: well, on windows that should be \r\n
11:51:41 <mauke> wrong
11:51:58 <Phyx-> wrong?
11:52:03 <mauke> yes
11:52:07 <Phyx-> why?
11:52:25 <mauke> because I follow the religion of C
11:52:58 <Phyx-> I don't beleive in your religion... i'm atheist
11:53:01 <mauke> C had to work on many different architectures and file formats, so they needed a portable line abstraction
11:53:15 <mauke> they came up with '\n'
11:53:34 <monochrom> yeah, the stdio library promises to translate \n to the right thing.
11:53:39 <sproingie> in text mode anyway
11:53:39 <mauke> '\n' is a single virtual character that's translated to the external newline format by the I/O library
11:54:07 <mauke> the external format may be a fixed-length record format, multiple separator bytes, or whatever
11:54:14 <idnar> the external newline is basically always 0x0a these days anyway
11:54:15 <sproingie> thankfully sockets don't do that, so you use \r\n to do a standard EOL for text mode protocols regardless of platform
11:54:20 <donri> the noodly appendages shall slay the non-believers.
11:54:24 <mauke> you do not use \r\n ever.
11:54:38 <Phyx-> -.-
11:54:44 <mauke> this is because C does not specify the value of '\n', only that it is a single char that's treated specially by stdio
11:54:51 <sproingie> you do if you're speaking http on a unix box
11:55:03 <mauke> all common socket protocols use "\13\10"
11:55:08 <mauke> this is not the same as "\r\n"
11:55:10 <ksf> net standard newline is crlf
11:55:16 <ksf> ...and http uses exactly that.
11:55:38 <blackh> What were they *thinking* ?!
11:55:49 <sproingie> i'm pretty sure it's only the repulsive "text mode" that makes \n anything but \10
11:56:02 <mauke> there is no "mode"
11:56:05 <ksf> not that distinguishing between carriage return and newline on a socket would make any more sense than on anything that isn't actually a typewriter.
11:56:08 <mauke> the compiler knows '\n'
11:56:15 <ksf> well, even there it does'nt make sense.
11:56:17 <Cale> There is a text mode with respect to Haskell Handles
11:56:30 <mauke> yes, but it doesn't affect the value of '\n'
11:56:45 <Cale> Well, it affects how \n is treated
11:57:18 <ksf> It's hilarious that a control character used to speed up _printing on paper_ is going to be used for quantum computation a thousand years from now, all because of unix
11:57:58 <Baughn> ksf: Wait, what?
11:58:02 <sproingie> \n is not understood by the compiler
11:58:18 <sproingie> \n is a single character that need not necessarily be \10
11:58:22 <sproingie> but it does have to be a single char
11:58:33 <mmx166mhz> I am confused by the haskell IO system: Can someone please explain in understandable language HOW you can apply functions which apply to String to a string read in from a file(i.e.: GHC complains becoz it is a IO[String]).
11:58:36 <ksf> carriage return means back to the beginning of the line. line feed means next line, keep the printing head where it is.
11:58:38 <Phyx-> "Most textual Internet protocols (including HTTP, SMTP, FTP, IRC and many others) mandate the use of ASCII CR+LF (0x0D 0x0A) on the protocol level, but recommend that tolerant applications recognize lone LF as well. In practice, there are many applications that erroneously use the C newline character '\n' instead"
11:58:38 <paolino> I have a problem with "reads" here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4983#a4983
11:58:42 <sproingie> stdio translates it when you use text mode
11:58:44 <mauke> sproingie: who else understands \n if not the compiler?
11:58:47 <Phyx-> mauke: wikipedia says you're wrong mauke :)
11:58:50 <sproingie> mauke: stdio
11:58:50 <ben0x539> ksf: But unix does \n, how is it unix's fault? :(
11:58:52 <ksf> it's just insanity to use such control codes as line terminator
11:58:56 <Baughn> mmx166mhz: You can"t
11:58:58 <mauke> Phyx-: how so?
11:59:07 <ksf> it's because unix pwns the net and has'nt fixed it.
11:59:11 <Phyx-> mauke: well, read that bit i just pasted
11:59:12 <sproingie> insofar as \n is implementation-defined you could say the compiler "understands" it
11:59:16 <sproingie> but it's always one char
11:59:27 <Baughn> mmx166mhz: However, there are functions to turn a function :: (a -> b) into a function (IO a -> IO b)
11:59:28 <mauke> Phyx-: that seems to be exactly what I said
11:59:44 <mmx166mhz> Aha, that what I am looking for then baughn
11:59:45 <Baughn> mmx166mhz: Which is what do-syntax implicitly uses. Well, actually it's m a -> m b, for an arbitrary monad m.
11:59:51 <Baughn> @src Monad
11:59:52 <lambdabot> class  Monad m  where
11:59:52 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:59:52 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:59:52 <lambdabot>     return      :: a -> m a
11:59:52 <lambdabot>     fail        :: String -> m a
12:00:00 <Phyx-> mauke: no, you said \r\n should never be used, while that says, that the sue of \n is inpractice a mistake
12:00:06 <sproingie> text mode is a horror that never should have been so deeply embedded
12:00:23 <mauke> Phyx-: uh, ok?
12:00:32 <Phyx-> hahahaha
12:00:33 <mauke> Phyx-: so how does that contradict what I said?
12:00:36 <Baughn> mmx166mhz: Well.. the one I described is actually fmap
12:00:40 <ben0x539> ksf: What should unix use as the line terminator instead?
12:01:02 <Baughn> mmx166mhz: >>= is a bit more complicated, since it lets you use a function a -> m b instead
12:01:04 <Phyx-> mauke: well, if i understood correctly, you're saying \n should always be used right?
12:01:09 <mauke> Phyx-: no
12:01:19 <Phyx-> then i must have misunderstood you
12:01:33 <paolino> Is it possible I misunderstood what readS_to_P reads should do ?
12:01:49 <ksf> a single, logical one.
12:01:52 <Baughn> mmx166mhz: http://www.haskell.org/haskellwiki/Typeclassopedia <- How about you read this, then check back when something confuses you? ;)
12:02:01 <mmx166mhz> thanks
12:02:06 <monochrom> mauke: 7.19.2.2-3, 7.19.5.3 "r" "rb" "w" "wb"
12:02:07 <ben0x539> but unix lines end in just \n
12:02:15 <mauke> Phyx-: <mauke> all common socket protocols use "\13\10"  <mauke> this is not the same as "\r\n"
12:02:15 <ben0x539> i mean 0x0a i guess
12:02:29 <mauke> Phyx-: in practice you want either "\n" or "\13\10"
12:02:35 <Baughn> mmx166mhz: It goes into more detail than strictly necessary, but you'll be better off in the long run knowing the whole typeclass chain than just Monad. Monad's simple, it's just that it bundles a lot of other stuff, and it's not that simple when combined.
12:02:37 <mauke> monochrom: hmm?
12:02:52 <sproingie> mac used to define \n as \13
12:02:54 <monochrom> sections of the C standard talking about binary vs text
12:03:06 <mauke> sproingie: yes, and I like it :-)
12:04:08 <sproingie> > "\CR\LF"
12:04:09 <lambdabot>   "\r\n"
12:04:44 <mauke> on an old mac that would have been printed as "\n\r"
12:04:44 <paolino> ksf, was that for me ?
12:04:59 <mathijs> does anyone know of a nice library based on Chan (or similar) which lets me combine Channels(multiple into one)? I know about dupChan, but that leaves data in other Channels as well.
12:05:01 <sproingie> even better, those aren't going to change.  just in case someone ports haskell to System 7
12:05:02 <ksf> nope
12:05:09 <paolino> k
12:05:57 <Baughn> mathijs: You probably want STM. It makes it simple to build stuff like that.
12:06:15 <Baughn> mathijs: Also, Control.Concurrent.Chan is horribly, horribly inefficient and may also (still) be broken.
12:06:16 <ben0x539> ksf i have no idea what you are asking from unix
12:06:35 <mauke> Baughn: how is it broken?
12:06:40 <Chaze> hi. is there a better way to define "fun _ _ _ _ _ _  = False"
12:06:55 <sproingie> not really
12:07:00 <Baughn> mauke: I'd have to look it up, but IIRC it could deadlock under some circumstances
12:07:22 <Baughn> mauke: So you'd have one thread blocked on /writing/ while another is blocked on reading
12:07:25 <luqui> Chaze, there's a worse way:   fun = const . const . const . const . const . const $ False
12:07:33 <sproingie> YES
12:07:48 <Chaze> luqui: why exactly is it worse?
12:07:50 <ben0x539> Surely there is a way to say const to the n'th power
12:07:57 <Baughn> mauke: It has no doubt been fixed in 6.12, but without finding the post I'd be cautious about 6.10. Anyhow, STM's chan is actually faster..
12:07:57 <sproingie> for people who miss C++ and can't get enough const
12:08:03 <mauke> fun = def
12:08:06 <luqui> ben0x539, well the types are changing each time, so unfortunately not
12:08:18 <mauke> Baughn: time to patch preflex, I guess :-)
12:08:18 <jlouis> Baughn: how about MVars?
12:08:32 <jlouis> Any opinion, though they have a different semantics
12:08:33 <jlouis> ?
12:08:36 <Baughn> jlouis: Oh, MVars are fine.
12:08:43 <mathijs> Baughn: ok, so I just need to build something like that myself using STM? I know STM a bit (read the chapter in RWH) and was planning to use it for another part of my project. I just don't see how to it for this purpose yet.  I'm looking for a Monoid-like interface for Chan, in which I can just mappend new Chans and still just have 1 list of inputs come out (getChanContents)
12:08:56 <luqui> Chaze, well, it's longer, and they're both pretty silly
12:08:57 <Baughn> jlouis: Rumor says they're about twice the speed of a TVar
12:09:11 <mauke> oh wait, I already use TChan everywhere
12:09:18 <Baughn> mathijs: STM is really easy to use once you get into it. Here, let me show you one:
12:09:49 <Baughn> mathijs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12321#a12321 <-- Here's a simple leaky bucket implementation using STM
12:09:57 <Chaze> luqui: well, i have such a function inside a "instace.. where .." for one type, while there's something more interesting for another datatype
12:10:14 <luqui> Chaze, ack, you have a method with six arguments?
12:10:25 <luqui> consider increasing your level of abstraction
12:10:26 <Chaze> luite: no, i was exagerating here
12:10:30 <luqui> oh
12:10:42 <Chaze> just wondering how i could say "function that takes n arguments"
12:10:57 <Baughn> mathijs: atomically does exactly what it says. The only clever bit is that retry /blocks/ the computation until one of the TVars (or equivalent) you've read has changed
12:11:04 <mathijs> Baughn: thanks, that's a nice example
12:11:12 <Baughn> mathijs: Which is in fact very, very clever. always calls retry if the condition fails.
12:11:18 <luqui> Chaze, ah, well yeah, what you diid is probably the best way
12:11:55 <sproingie> wow that's nice
12:11:57 <mauke> import Data.Default; instance Default Bool where def = False
12:11:59 <mauke> fun = def
12:12:07 <mathijs> Baughn: will modifying a TVar also cause the current atomically part to stop (when running) ?
12:12:19 <Chaze> mauke: ah, thx
12:12:27 <luqui> mauke, you're joking right?
12:12:30 <mauke> mathijs: no, TVars are like IORefs in that regard
12:12:32 <Chaze> how could i chain const ?
12:12:35 <Chaze> just curious
12:12:36 <mauke> luqui: I'm not sure
12:12:40 <copumpkin> Data.Default is fun!
12:12:51 <Baughn> mathijs: atomically is, well, atomic. The only way a TVar gets modified inside one is if you call writeTVar in the same block.
12:13:08 <luqui> Chaze, you couldn't, because of types.  well maybe you can, but it would involve type system hackery
12:13:23 <idnar> or template haskell
12:13:24 <bd_> mathijs: GHC's STM implementation uses optimistic concurrency, it won't block but will rather retry when it tried to commit and realized things have changed under it. Just keep in mind an atomic block always _looks_ like it was the only thing running at the time.
12:13:33 <joe___> copumpkin, I am stuck. I am posting more details on where I am below
12:13:35 <joe___> [send.hs:103:18-70] *Main Numeric>                   putStrLn ( show ( Data.ByteString.unpack datastack ))
12:13:39 <joe___> [153,153,153,153,153,153,153,153]
12:13:48 <copumpkin> joe___: you looked at Data.Binary?
12:13:53 <mathijs> Baughn: yeah I got that part. But since an atomically block(of code) will fail in the end if a TVar got modified by another thread, there's no need to continue a running one I think.
12:14:02 <joe___> instead of the list of 153 (decimal numbers), I want a hex number (99)
12:14:03 <luqui> Chaze, you would like to say  fun = iterate const False !! 6
12:14:14 <mathijs> bd_: cool, that's the answer then :)
12:14:19 <luqui> Chaze, but you can only do that if the types are homogeneous
12:14:31 <joe___> copumpkin, I checked out Data.Binary but just could not make sense out of it.
12:14:41 <joe___> I find the Numeric.showHex does what I want
12:14:58 <joe___> but I would have to convert the bytestring to Integral for that to work
12:15:17 <bd_> mathijs: They _might_ be terminated and restarted partway - GHC checks on certain GC cycles I believe. But it might wait until it completes the atomically block before deciding to rollback
12:15:21 <copumpkin> > map showHex [153,153,153,153,153,153,153,153]
12:15:22 <lambdabot>   [""->
12:15:22 <lambdabot>    "99"
12:15:22 <lambdabot>  "a"->
12:15:22 <lambdabot>    "99a"
12:15:22 <lambdabot>  "aa"->
12:15:24 <lambdabot> [4 @more lines]
12:15:28 <mauke> joe___: er, isn't that what unpack does?
12:15:37 <copumpkin> > map (flip showHex "") [153,153,153,153,153,153,153,153]
12:15:38 <lambdabot>   ["99","99","99","99","99","99","99","99"]
12:15:54 <luqui> :t showHex
12:15:55 <lambdabot> forall a. (Integral a) => a -> String -> String
12:16:27 <luqui> what is that crazy output it gave the first time?
12:16:45 <jasonmay> > take 5 map (5+) [0 .. 10]
12:16:46 <lambdabot>   Couldn't match expected type `[a]'
12:16:46 <lambdabot>         against inferred type `(a1 -> b)...
12:16:52 <jasonmay> > take 5 (map (5+) [0 .. 10])
12:16:53 <mauke> luqui: a list of functions
12:16:53 <lambdabot>   [5,6,7,8,9]
12:17:06 <Baughn> mathijs: I don't know exactly how STM works, I just know the semantics. They work well enough. :3
12:17:10 <copumpkin> luqui: lambdabot has smallcheck loaded, which has a show instance for functions
12:17:11 <luqui> > id :: String -> String
12:17:12 <lambdabot>   ""->
12:17:12 <lambdabot>    ""
12:17:12 <lambdabot>  "a"->
12:17:12 <lambdabot>    "a"
12:17:12 <lambdabot>  "aa"->
12:17:14 <lambdabot> [6 @more lines]
12:17:15 <joe___> copumpkin, brilliant. It works. will try to understand it further
12:17:19 <sproingie> > succ
12:17:20 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
12:17:24 <luqui> copumpkin, ah
12:17:28 <sproingie> oh FINE
12:17:30 <Baughn> mathijs: Of course, the greatest advantage is that they can be composed. Could you imagine writing modifyWhen using MVars? o_O
12:17:50 <sproingie> > succ :: Int -> Int
12:17:51 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
12:18:28 <mathijs> Baughn: well it looks nice & clean to me indeed. I better get reading a bit more about STM
12:18:51 <sproingie> clojure is also big on STM, they have some nice examples
12:18:54 <Baughn> mathijs: I already pretty much told you all you need to know. The haddock API documentation is plenty. :3
12:18:57 <joe___> copumpkin, the datatypes from unpack and map do not match
12:18:58 <sproingie> hope you like sexps
12:19:07 <Baughn> mathijs: "atomically does what it says, retry actually blocks"
12:19:30 <joe___> copumpkin, ignore my prev line
12:19:35 <copumpkin> :)
12:19:36 <joe___> copumpkin, it works
12:20:19 <copumpkin> :t decode
12:20:20 <lambdabot> Not in scope: `decode'
12:20:58 <ksf> retry should be called oops
12:21:06 <Chaze> something else: pattern matching won't allow me to catch cases where arbitrary identical arguments are passed, will it?
12:21:15 <mauke> Chaze: right
12:21:31 <Baughn> mathijs: Actually, that"s probably the very nicest thing about STM. It's very hard to get it wrong. :)
12:22:14 <luqui> Chaze, no
12:22:26 <luqui> Chaze, use:   f x y | x == y  = ...
12:23:05 <mathijs> Baughn: that sounds like a very big advantage ;)   but I usually want to make sure and prove to myself it's right also :)
12:23:13 <Chaze> mauke: luqui: thanks, guessed so
12:23:56 <copumpkin> luqui: by the way, I translated your diagonal function from Omega to agda :) it was a lot more painful than one might expect! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12323#a12323
12:25:23 <copumpkin> I have yet to prove anything about it
12:25:26 <luqui> copumpkin, ouch
12:25:42 <luqui> DiagonalP rubs me the wrong way
12:25:50 <luqui> zipCons as a constructor?
12:25:59 <copumpkin> the problem is that the termination checker couldn't figure out that the naive translation of your code terminated
12:26:06 <jlouis> copumpkin: is there an "Agda is ..." page for one who is not afraid of Coq?
12:26:10 <joe___> copumpkin, I am trying to understand the statement and have a few questions
12:26:12 <copumpkin> and the only way to do that is to do the corecursion on data constructors
12:26:22 <joe___> :t showHex
12:26:23 <lambdabot> forall a. (Integral a) => a -> String -> String
12:26:33 <copumpkin> so you create a mini-DSL in agda that you "evaluate"
12:26:38 <copumpkin> to convince it that you terminate
12:26:41 <copumpkin> it's really ugly :)
12:26:53 <luqui> jlouis, Agda is ... like coq but with different syntax and a few other minor differences?
12:26:58 <joe___>  :t Data.ByteString.unpack
12:27:01 <copumpkin> jlouis: hmm, not sure :) I haven't played with coq much, but there's an #agda channel if you're curious
12:27:25 <copumpkin> luqui: but I agree, it's very ugly :)
12:27:26 <Phyx-> hmm, should i learn Agda?
12:27:35 <mmx166mhz> Why doesnt the following work?  map (read::Integer) ["1","2"]
12:27:38 <joe___> copumpkin, I am trying to understand "showHex" can convert from "Word8" to "(Integral a)"
12:27:48 <copumpkin> joe___: it can't
12:27:53 <copumpkin> fromIntegral can though
12:27:58 <luqui> Phyx-, how comfortable are you with FP?
12:27:58 <jlouis> oh, s√• Agda is CiC based or something else?
12:28:03 <jlouis> so...
12:28:06 <luqui> jlouis, something else
12:28:15 <Phyx-> luqui: very
12:28:25 <luqui> Phyx-, then sure, why not :-)
12:28:33 <joe___> but, [send.hs:103:18-70] *Main Numeric> :t (head $ Data.ByteString.unpack datastack )
12:28:36 <joe___> (head $ Data.ByteString.unpack datastack ) :: Word8
12:28:48 <joe___> showHex (head $ Data.ByteString.unpack datastack ) ""
12:28:48 <joe___> "99"
12:28:50 <copumpkin> Phyx-: it's pretty fun, if a little tedious sometimes :)
12:29:01 <mauke> joe___: Integral is not a type, it's a class
12:29:03 <copumpkin> luqui: have you played much with it?
12:29:09 <joe___> copumpkin, it works and I am trying to understand why.
12:29:10 <mauke> mmx166mhz: because read is not an Integer, it's a function
12:29:14 <Saizan> jlouis: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.AgdaVsCoq
12:29:16 <luqui> copumpkin, no, not much.   I got into coq first.
12:29:20 <copumpkin> ah
12:29:22 <mmx166mhz> How to do it?
12:29:24 <Phyx-> I've seen some example of things that can be done in it, it looked to be fun, even though i don't know how practical
12:29:46 <luqui> Phyx-, not too practical atm, imo.   But it is a glimmer of the future.
12:29:54 <mauke> > map read ["1", "2"] :: [Integer]
12:29:56 <lambdabot>   [1,2]
12:29:56 <joe___> oh, integral is a class and hence can include many types. and somewhere Word8 might have been defined as belonging to that class?
12:29:58 <copumpkin> ah
12:30:04 <mauke> joe___: exactly
12:30:05 <monochrom> joe___: Word8 is already an instance of Integral. Do you know what is Integral? Do you know typeclass?
12:30:05 <Phyx-> luqui: cool, i'll take a look
12:30:30 <jlouis> Saizan: thanks!
12:30:40 <joe___> monochrom, I have read about "typeclass". example: Eq?
12:30:45 <jlouis> And also to luqui and copumpkin
12:30:51 <copumpkin> :)
12:31:08 <monochrom> Yes. Integral is another exmaple. Word8 is made belonging to Integral.
12:31:47 <copumpkin> luqui: would diagonal be more pleasant in coq?
12:32:05 <luqui> copumpkin, my guess is that it would be worse.
12:32:12 <joe___> monochrom, is there a way to find where that definition of Word8 belonging to Integral would be, (for understanding the process)
12:32:12 <luqui> copumpkin, coq is not good at codata
12:32:12 <copumpkin> ah
12:32:28 <copumpkin> I see
12:32:52 <copumpkin> the problem with creating this intermediate DSLish thingy is that it's made the whole thing a nightmare to prove anything about
12:32:52 <joe___> copumpkin, saw it
12:32:56 <monochrom> If you type ":type Word8" at ghci prompt, it will say.
12:33:23 <mauke> :type Word8 looks malformed
12:33:26 <luqui> copumpkin, yeah proofs are easy only if you write in direct style.
12:33:42 <monochrom> Oh sorry, ":info Word8"
12:33:44 <luqui> copumpkin, I would probably end up using Int ->   instead of lists
12:33:48 <copumpkin> maybe the termination checker will improve
12:33:59 <copumpkin> and I'll be able to use it more directly
12:34:15 <copumpkin> luqui: I see
12:34:15 <luqui> copumpkin, but of course that's not the same function, because Int ->  don't have ends.
12:34:17 <joe___> monochrom, that helped
12:34:18 <monochrom> The docs of Prelude and of Data.Word also say.
12:34:25 <mmorrow> oh man, git's kind of nice. i like gitweb too. oh noes! i might sell out!
12:34:38 <copumpkin> mmorrow: it is quite nice :) you should get on github and be 2.0ish
12:34:44 <luqui> maybe exists n. Fin n -> a  ?
12:34:45 <jlouis> mmorrow: haha. I have a red lightsaber for you when you finally convert
12:35:02 <luqui> huh, except that's always finite.   yeah.. h
12:35:05 <luqui> hm
12:35:12 <copumpkin> luqui: what would be the advantage of exists n. Fin n, over just Nat?
12:35:35 <joe___> :t Numeric.showHex
12:35:35 <lambdabot> forall a. (Integral a) => a -> String -> String
12:35:45 <luqui> copumpkin, precedence problem.  exists n. (Fin n -> a)
12:35:48 <jlouis> ok, Agda is on the list of interesting things to check out
12:35:51 <joe___> does that mean that the 1st argument belongs to the integral class?
12:36:06 <joe___> :t Numeric.showHex
12:36:07 <lambdabot> forall a. (Integral a) => a -> String -> String
12:36:19 <luqui> copumpkin, I was trying to get at the fact that lists can be non-infinite
12:36:22 <mmorrow> copumpkin: i just compiled apache, git, configured darcs.cgi, and gitweb.cgi, and i think i'm sold. ah, i also got darcs-to-git too, which seems to do a decent job
12:36:45 <copumpkin> luqui: oh, but the index of Fin is already forced to be finite
12:36:52 <jlouis> Perhaps this is a dumb Agda question in the wrong channel. Does Agda do HOAS ?
12:37:03 <mmorrow> copumpkin: but yeah, i'm so not 2.0
12:37:17 <luqui> copumpkin, right. I went too far.  exists n. (Fin n -> a)  now cannot model infinite at all.
12:37:19 <copumpkin> mmorrow: you need rounded corners and a starburst!
12:37:23 <copumpkin> makeover!
12:37:27 <mmorrow> copumpkin: woooo!
12:37:38 <copumpkin> mmorrow2.0[BETA]
12:37:47 <Phyx-> mmorrow has evolved
12:38:05 <mmorrow> now i run on the client side, twice as slowly!
12:38:06 <Phyx-> we have the technology, to make him faster, stronger, more functional
12:38:17 <copumpkin> lol
12:38:20 <Phyx-> mmorrow: what, are you flash now?
12:38:22 <copumpkin> github is actually quite nice
12:38:25 <copumpkin> despite being 2.0ish
12:38:33 <mmorrow> i was thinking js, but either or
12:38:48 <mmorrow> copumpkin: yeah, it looks it
12:38:59 <whoppix> copumpkin, it's just has a lot of downtime, which can be mildly annoying
12:39:07 <copumpkin> yeah
12:39:07 <Phyx-> I want to start an online petition to ban flash from the web :|
12:39:22 <whoppix> copumpkin, and the bugtracker is pretty broken too.
12:39:22 <luqui> jlouis, not exactly qualified to answer, but nobody else is.  HOAS doesn't work in coq because it involves non-strictly-positive recursive datatypes.
12:39:30 <copumpkin> ah, I haven't tried it
12:39:39 <luqui> jlouis, that might be where Agda's different core calculus is better?
12:39:51 <whoppix> copumpkin, spare yourself the hassle and just disable it :) the ajax-interface doesn't work very well, and mostly not at all in opera.
12:39:58 <copumpkin> here's some HOAS in agda from dolio: http://code.haskell.org/~dolio/agda-share/hoas/PHOAS.agda
12:40:03 <jlouis> luqui: perhaps.
12:40:22 <jlouis> copumpkin: PHOAS will work I guess because that works in Coq as well
12:40:34 <copumpkin> probably :)
12:40:52 <copumpkin> http://code.haskell.org/~dolio/agda-share/hoas/html/PHOAS.html is a prettier version
12:42:11 <jlouis> When this is done, I should try doing PHOAS in Twelf for the fun of it and see what happens
12:43:53 <Phyx-> @google ghc core syntax
12:43:55 <lambdabot> http://www.haskell.org/ghc/docs/6.10-latest/html/ext-core/core.pdf
12:43:55 <lambdabot> Title: An External Representation for the GHC Core Language (For GHC 6.10)
12:44:36 <Phyx-> that'll work
12:44:51 <yitz> Phyx-: hmm. can you find an online petition site that doesn't use flash?
12:45:05 <yitz> you might be stuck
12:45:23 <Phyx-> yitz: petitionspot.com doesn't i think
12:45:32 <Phyx-> my petition title "Fix it or Kill it"
12:45:33 <gio123> is there any brazilian or portugues?
12:45:34 <Phyx-> catchy no?
12:45:35 <yitz> whew
12:45:47 <yitz> wait - silverlight?
12:46:14 <Phyx-> yitz: silverlight doesn't randomly crash tabs, nor suck cpu cycles like a mad man on crack
12:46:23 <Phyx-> i much rather have it, or anything else than flash
12:46:41 <Phyx-> it's just not normal, going to a site, has a simple flash ad, and i hear my cpu fan start running harder
12:46:48 <mmx166mhz> suppose: We have a list of 3 or 4 elements ( strings), and we wanna put together the 3rd+4th element. (only if it has a 4t element) How to?
12:47:26 <yitz> Phyx-: does silverlight run on linux and mac?
12:47:42 <Phyx-> yitz: microsoft directly supports mac, and is helping the moonlight team for linux
12:48:17 <yitz> use svg, if it can cut it for your project
12:48:52 <Phyx-> mmx166mhz: you could use pattern matching f (x:y:z:o:[]) = x++z; f x = []
12:50:01 <Phyx-> actually that should have been z++o
12:50:04 <Phyx-> but you get the idea
12:50:10 <mmx166mhz> yea:)
12:50:28 <yitz> > let {join3and4 x = let (h,t) = splitAt 3 x in h ++ concat t} in join3and4 ["ab", "cde", "f", "gh"]
12:50:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
12:50:46 <yitz> > let {join3and4 x = let (h,t) = splitAt 3 x in h ++ [concat t]} in join3and4 ["ab", "cde", "f", "gh"]
12:50:47 <lambdabot>   ["ab","cde","f","gh"]
12:51:01 <yitz> mmx166mhz: another way ^^
12:51:19 <Phyx-> yitz: did that actually do anything?
12:51:37 <yitz> > let {join3and4 x = let (h,t) = splitAt 2 x in h ++ [concat t]} in join3and4 ["ab", "cde", "f", "gh"]
12:51:38 <lambdabot>   ["ab","cde","fgh"]
12:51:47 <yitz> better?
12:51:50 <Phyx-> yup
12:51:52 <Phyx-> :)
12:52:31 <Phyx-> I suppose, the matching equivalent is f (x:y:z:o:[]) = x:y:(z++o); f x = x
12:52:53 <yitz> > let {joinAfter n x = let (h,t) = splitAt n x in h ++ [concat t]} in joinAfter 2 ["ab", "cde", "f", "gh"]
12:52:54 <lambdabot>   ["ab","cde","fgh"]
12:54:13 <yitz> Phyx-: the matching is easier for that special case. but it can get tiresome if you ever need to generalize it.
12:55:53 <Phyx-> yitz: yeah, but most often than not, you don't need to
12:56:34 <yitz> could go either way. you know what to do when you get there.
12:57:34 <Phyx-> i'm hungry
12:57:47 <Phyx-> time to eat, then read this paper on core
12:57:56 <yitz> @vixen Phyx- is hungry.
12:57:57 <lambdabot> Uh-huh
13:10:14 <McManiaC> how can I get my local/internet IP?
13:10:38 <mauke> 127.0.0.1?
13:10:43 <tommd> McManiaC: That is off topic in this channel.
13:10:48 <dixiecko> is there any list function which returns differences between two lists? added/removed :)
13:11:03 <McManiaC> tommd: well, I'm looking for a haskell module of course ;)
13:11:06 <copumpkin> http://whatismyip.org/
13:11:08 <Heffalump> tommd: unless the question is how to do it programmatically..
13:11:08 <copumpkin> ;)
13:11:25 <mauke> copumpkin: http://checkip.dyndns.org/
13:11:41 <tommd> dixiecko: You can hoogle for it, but Data.List has some of the commonly-needed functions.
13:11:41 <tommd> McManiaC: Ah, my mistake.
13:11:41 <Heffalump> System.runInteractiveProcess "wget http://whatismyip.org"
13:12:01 <Zariel> Hey all, can anyone explain (or link) to me what "$" and "|||" mean?
13:12:06 <mauke> @src ($)
13:12:07 <lambdabot> f $ x = f x
13:12:27 <McManiaC> does the Network module has anything like that? I wanna write a server-client application anyway
13:13:25 <tommd> McManiaC: There really isn't any protocol-independent way to get your external IP if it isn't the IP assigned to the system.  There are all sorts of protocol-dependent methods to learn it, I think STUN does that for example.
13:15:48 <blackh> McManiaC: I can answer your question in as much detail as you like - what are you using the address for?
13:16:44 * hackagebot upload: pointful 1.0.2 - Pointful refactoring tool (MikhailGlushenkov)
13:16:59 <sim716> is the command to join java #java space /join
13:17:11 <mauke> haha
13:17:17 <mauke> WHY DO PEOPLE DO THIS
13:17:18 <McManiaC> blackh: I want my tool to connect to a server and say "hi, I'm here". the server then remembers the local + external IP of the client and does something with it
13:17:24 <sim716> why is that funny?
13:17:32 <tommd> McManiaC: Something in my head is trying to tell me many of the home wireless router/access points come with upnp enabled and you should be able to use that, assuming it is the router that gets your internet IP (though these are sometimes getting a NAT addr too).
13:17:36 <mauke> sim716: because you came to #haskell to ask that
13:17:52 <mauke> sim716: and #haskell is about Haskell, not Java or IRC
13:17:57 <ksf> sim716, the java channel is called #JavaChatInterfaceServerPartClientInterface
13:18:00 <blackh> McManiaC: So you want your client to know what the IP address of the local machine is?
13:18:22 <blackh> McManiaC: If it's behind a firewall, then you want the LAN IP address, right?
13:18:34 <McManiaC> blackh: i need both, LAN + Internet
13:18:52 <sim716> just doesnt seem to change to the java room tho
13:19:03 <sim716> no matter how many times i write the command
13:19:12 <blackh> McManiaC: Well, the Internet one can't be obtained locally, so that's your server's job, right?
13:19:24 <McManiaC> blackh: I guess the internet can also be retrieved by the server that is responding to the clients "hi there"
13:19:38 <tommd> sim716: Part of the humor is that you somehow got here so he doesn't see why you can't get to #java.  To answer your question "/join #java"
13:20:03 <BONUS> try /part #java
13:20:28 <sim716> nope :)
13:20:38 <jlouis> if IRC commands had been a Java class
13:21:01 <sim716> lol :) well i must say guys i admire you for liking haskell
13:21:35 <sim716> its probably the single hardest unit i have evr studied
13:21:47 <McManiaC> sim716: i pity you for liking java :)
13:22:14 <copumpkin> hard means fun
13:22:20 <copumpkin> tedium is what pisses me off
13:22:35 <blackh> McManiaC: I know how to do it in C - I'm seeing what's in Network.*
13:23:37 <McManiaC> blackh: probably Network.Socket ?
13:23:48 <sim716> i have honestly typed /join #java about ten times now :)
13:24:12 <copumpkin> sim716: it probably joined you to ##java, or is complaining about you not being logged in
13:24:23 <Cale> sim716: Well, the Haskell language itself isn't so hard. (Depending on what GHC extensions to it that you include.) But in any case, certainly no more complicated than Java is. It's the implications of the rules where things get interesting. Haskell programmers have interesting ways of abstracting over particular library designs.
13:24:52 <Heffalump> Cale: really? (no more complicated than Java) With all the GHC extensions I'd say it's significantly more complicated.
13:24:52 <tromp_> it's a bit like Go (the game)
13:25:10 <tromp_> simple rules but deep strategy
13:25:33 <dobblego> sim716, what happens when you type /join ##java (do you land in a monkey cage?)
13:25:37 <Cale> Heffalump: Well, there is a lot going on in some of the type system extensions, I suppose.
13:26:18 <Cale> Perhaps it would have been safer to say "no more complicated than C++", but that feels like an understatement.
13:26:36 <blackh> McManiaC: The closest thing is Network.BSD.getNetworkEntries but it doesn't appear to have the necessary info
13:26:39 <Cale> C++ wastes its complications on stupid BS though.
13:26:48 <Heffalump> C++ is killed by weird interactions
13:26:58 <mauke> ‚àÄ x ‚àà Languages: x is no more complicated than C++
13:27:01 <blackh> McManiaC: Network.Socket hasn't got it.  One trouble is, even in C this can be a bit platform specific.
13:27:10 <blackh> McManiaC: What do you actually want to use it for?
13:27:42 <sim716> brb
13:27:52 <Cale> Java has its set of weird interactions too though, as I'm sure dobblego would be willing to inform us about :)
13:28:13 <dobblego> I'm eating, sorry :)
13:28:15 <blackh> McManiaC: In fact, to do it properly is a little tricky, but it can be done.
13:28:16 <McManiaC> blackh: a IP database running on a known server for dynmic IPs
13:29:03 <blackh> McManiaC: So what are you going to actually do with the machine's local (meaning LAN) IP address?
13:29:28 <McManiaC> blackh: store it and send it to another client on request
13:29:56 <chris9> map read ["0","1","2"] :: Int
13:30:04 <blackh> McManiaC: And do what with it?
13:30:20 <blackh> What will the other client use it for?
13:30:36 <McManiaC> thats it basicly
13:30:37 <McManiaC> ^^
13:31:05 <blackh> McManiaC: OK - here is how you do it:
13:31:10 <ac> is it possible in Haskell to have an IO type that blocks (for example was for a few seconds) in the middle of its value?
13:31:19 <ac> s/was/was/
13:31:24 <ac> waits
13:31:25 <mauke> what do you mean by "in the middle of its value"?
13:31:29 <blackh> McManiaC: You have to look at the routing table (very platform specific) and see what interface it is going out on.
13:31:35 <Cale> ac: threadDelay?
13:31:46 <Cale> :t Control.Concurrent.threadDelay
13:31:47 <lambdabot> Int -> IO ()
13:31:49 <blackh> McManiaC: Then you have to look at the network interfaces, and get the IP address of that interface.
13:32:08 <Cale> ac: It takes its parameter in microseconds
13:32:22 <blackh> McManiaC: So you need to look up the routing table entry for some remote address, so you know which interface it is, in case the machine is multi-homed.
13:32:41 <ac> Cale: I know about threadDelay. That's a bad way of asking my question. What I want is to send an HTTP response that takes say 10 seconds to send, but it sends part of the response every 2 seconds
13:32:43 <chris9> hi guys, anyone can help me?, I dunno what is the prototype of decode function, decode x y = [(enlist x),( map read (enlist y) :: Int); enlist :: String -> [[Char]]    enlist x = map (:[]) x
13:32:47 <blackh> McManiaC: If you want to just guess, you can pick the first interface that isn't localhost, but that won't work on a multi-homed box.
13:33:07 <tommd> ac: Control-Event will let you schedule 5 events each 2 seconds apart.
13:33:30 <tommd> chris9: That should be :: [Int]
13:33:42 <tommd> not ":: Int"
13:34:04 <McManiaC> blackh: hm okaaaay
13:34:04 <McManiaC> ^^
13:34:13 <blackh> McManiaC: Listing the network interfaces is also platform specific.
13:35:07 <blackh> McManiaC: To put it another way - there's no such thing as "the box's IP address".  Instead, there's a list of interfaces, each of which has a different IP address, and a routing table, which decides what interface to use for a given destination.
13:35:34 <ac> Cale: and I'm using fastcgi, so I have to provide a CGIResult type that somehow blocks when it's evaluated. Or is this kind of thing not possible with the fastcgi library?
13:36:32 <chris9> I have first decode :: String(that's x)->String(that's y)-> ø? here is i.e.  x="AEIOU" y="1234" ,then the result is [["A","E","I","O","U"],["1","2","3","4"]]
13:37:05 <chris9> sry the last is [1,2,3,4]
13:37:28 <tommd> chris9: That isn't possible.  You can't have a list of lists of different types.
13:37:46 <tommd> Lists are homogeneous.
13:37:55 <chris9> oh ok, got it, sry im new
13:37:56 <chris9> thks
13:38:02 <tommd> chris9: You can use a tuple
13:38:18 <tommd> so "decode :: String -> String -> ([String], [Int])
13:38:38 <chris9> oh yes,thks!Á
13:40:06 <gstv> hi there, can anyone help on lhs2tex installation?
13:40:55 <tommd> gstv: cabal install lhs2tex works for me - I'm guessing there are some c library deps that you'll need to install.
13:41:06 * shapr boings cheerfully
13:43:27 <gstv> yes, after trying "runghc Setup.hs configure" I'm getting a error dependency: utf8-string -any
13:43:28 <mathijsB> good evening
13:44:05 <shapr> hoi!
13:44:16 <gstv> but, I have this package is already installed
13:44:18 <shapr> hoe gaat het?
13:44:19 <mathijsB> anyone able to give me a hint on the following : i got an integer number and i want a list of the individual digits in reverse order :')
13:44:42 <Zao> mathijsB: Convert to string, reverse, map read
13:44:51 <shapr> Yeah, I was going to suggest that.
13:44:52 <shrughes> map digitToInt
13:45:00 * shapr hugs Igloo 
13:45:04 <ac> my guess is that assuming it's possible to do this with fastcgi, it's not possible with the current fastcgi library because you never get a hold of a socket you can write to
13:45:05 <mathijsB> good one, ty.
13:45:09 <Igloo> Hey shapr
13:45:22 <shapr> How's life?
13:45:31 <Igloo> surviving!
13:45:34 <Igloo> You?
13:45:44 <shapr> Excellent! I'm about to go to university!
13:46:03 <Igloo> Neat! Studying what where?
13:46:15 <shapr> CS at University of North Alabama
13:46:28 <shapr> I'm thinking that my BladeCenter will double their total computing power.
13:46:31 <tommd> What's their program entail?
13:46:49 <shapr> Learning C++, writing some Java, doing some math and data structures stuff.
13:46:51 <shapr> I think I can handle it.
13:47:25 <tommd> shapr: But Portland State is starting to teach Haskell in their undergrad courses!
13:47:38 <Igloo> Birmingham Alabama is where you've been for a while, right?
13:47:40 <FunctorSalad> \o/
13:47:45 <tommd> You should go there and then just teach to course instead of take it ;-)
13:47:47 <shapr> Igloo: I just moved back to Alabama from Boston.
13:48:22 <ksf> shapr, my condolences
13:48:27 <ksf> you will suffer much with c++
13:48:31 <shapr> ksf: Hey, I like Alabama! Oh that...
13:48:39 <mathijsB> c++ is so nice :')
13:48:51 <tommd> Unless they teach C++ as C with objects.
13:48:56 <tommd> That isn't too bad.
13:49:06 <ksf> yep it makes satisfying noises if you drain it down /dev/null
13:50:06 <erikc> C++ is easy if you know C and Haskell
13:50:17 <copumpkin> it's still not pleasant
13:50:21 <mathijsB> i guess...
13:50:24 <mathijsB> reversly its not the case
13:50:32 <medfly> erikc, it is? good to know
13:50:32 <mathijsB> i know c and c++ and haskell is so confusing.
13:50:40 * medfly has to learn C++ soon
13:50:42 <ksf> it's still a language that mutually exludes itself
13:50:43 <mathijsB> it looks like fun though
13:50:43 <mathijsB> :)
13:50:45 <medfly> hurray!
13:51:37 <ksf> it's an intricate arragement of senseless things that are legal and useful stuff that's forbidden
13:51:50 <erikc> the value types + templates side of C++ is very much like Haskell + typeclasses
13:52:17 <ksf> templates are more like TH
13:52:30 <erikc> the object side is very much like a totally broken, frustrating to use Java
13:52:45 <FunctorSalad> ^^
13:52:46 <erikc> and then you need to know C cause you'll need to mentally convert the C++ to C so you don't blow your foot off
13:52:48 <ksf> just that with TH, you can abstract over bleeding anything and do anything, in plain haskell.
13:53:01 <Philonous> strange, I always found java to be a totally broken, frustrating to use C++
13:53:27 <ksf> java at least comes with sane closures and a usable gc
13:53:54 <ksf> and if you don't do inheritance but only interfaces things almost look sane.
13:54:05 <ben0x539> It has sane closures now?
13:54:11 <ksf> way too many .java files needed, though.
13:54:30 <shrughes> sane closures with insane syntax
13:54:35 <erikc> Philonous: i dont care for Java, but it has gc (which makes things like standardized exception handling and closures work) and it has a better package system than #include, and binary distribution that lives longer than a compiler version
13:54:39 <ksf> well they're syntactically verbose, but not too bad.
13:54:52 <ksf> in fact, they're not an alien thing to use with e.g. swing
13:55:56 <erikc> there is nothing good about the object side of c++ anymore, it's a legacy
13:56:38 <Fredderf> @pl (\x y -> x ++ e:y)
13:56:38 <lambdabot> (. (e :)) . (++)
13:58:52 <erikc> Alpha: List of deliverables to get the module feature complete. Please give a timeline.
13:59:01 <erikc> Beta: List of deliverabels to get the module bug free. Please give a timeline.
13:59:04 <erikc> sigh, to laugh or to cry
14:02:15 <Cale> erikc: Do a perfectly honest ;) timeline for ensuring that the module is actually free of bugs according to a formal specification of its behaviour. Don't forget to include formal proofs of correctness of the underlying compiler and machines on which the program will be run.
14:05:01 <mmorrow> omg, a lisp interpreter written in awk http://github.com/darius/awklisp/
14:05:14 <mmorrow> from 1994
14:05:22 <mmorrow> (slash 2001)
14:07:09 <erikc> Cale: :)
14:08:09 <mathijsB> hmh, I am trying to use digitToInt, but when I type :t digitToInt in ghci I get a 'not in scope' error. Am i missing anything? the Prelude should be loaded...
14:08:30 <mauke> @index digitToInt
14:08:30 <lambdabot> Data.Char
14:08:56 <fc1> let a = listArray ((1,1), (3, 5)) (repeat (Cell 0 Nothing)) :: DiffUArray (Int,Int) Cell, but i'm getting an error on '    No instance for (IArray
14:08:56 <fc1>                        (IOToDiffArray Data.Array.IO.Internals.IOUArray) Cell)
14:09:08 <fc1> so how do i do the instance declaration?
14:09:26 <fc1> and why isn't this by default done by the interpreter?
14:09:41 <mauke> you probably don't
14:09:51 <edwardk> mmorrow: darius bacon is a bit of a masochist ;)
14:09:52 <mauke> and the interpreter has no idea how to define an instance of a random class
14:10:31 <edwardk> mmorrow: there is also a lispawk iirc, which could get very metacircular very fast
14:10:36 <edwardk> gotta run
14:10:51 <mathijsB> thanks lambdabot, that solved it :)
14:10:53 <mauke> ... for very slow values of "fast"
14:11:22 <mmorrow> hah, lisp awk
14:11:30 * mmorrow needs that immediately
14:12:01 <Fredderf> @pl (\element list -> zipWith ((. (element :)) . (++)) (inits list) (tails list))
14:12:02 <lambdabot> (`ap` tails) . (. inits) . zipWith . (. (++)) . flip (.) . (:)
14:12:02 <fc1> mauke: so how do i add this declaration then?
14:12:12 <mauke> fc1: you probably don't
14:13:05 <fc1> ah? this what ghci's error suggested:  Possible fix:
14:13:05 <fc1>       add an instance declaration for
14:13:05 <fc1>       (IArray (IOToDiffArray Data.Array.IO.Internals.IOUArray) Cell)
14:13:09 <mauke> yes
14:13:14 <mauke> that doesn't mean it's right
14:14:00 <Fredderf> @pl (\x -> putStrLn . unlines . map concat $ perm x)
14:14:00 <lambdabot> putStrLn . unlines . map join . perm
14:14:04 <mmorrow> gah, can't find it
14:15:34 <Gracenotes> or mapM_ (putStrLn . concat) . perm
14:16:22 <fc1> mauke: so what was the cause of the error? or how do i fix it?
14:18:09 <mauke> fc1: you can't use an IOUArray with Cell
14:19:45 <fc1> mauke: so how can i tell which type can be used with it?
14:19:58 <fc1> can i used it with STArray?
14:20:12 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IO.html#t%3AIOUArray
14:20:32 <mauke> fc1: why not use IOArray?
14:20:46 <mmorrow> heh
14:20:49 <mmorrow> [m@monire awklisp]$ echo '((lambda (x) (x x)) (lambda (x) (x x)))' | ./old-awklisp
14:20:49 <mmorrow> Segmentation fault
14:20:57 <copumpkin> nice
14:21:02 <McManiaC> blackh: Network.Socket> getPeerName s'
14:21:02 <McManiaC> 134.2.246.148:54894
14:21:03 <mmorrow> (same on ./awklisp)
14:21:08 <copumpkin> sounds like an AWKward implementation
14:21:13 * copumpkin apologizes
14:21:29 * mmorrow throws bologna and tomatoes at pumpkin
14:21:34 <copumpkin> lol
14:21:47 <mmorrow> if you have some bread you can make a sandwich!
14:21:57 <fc1> mauke: i thought that uboxed version is generally the recommended one
14:21:58 * copumpkin doesn't like tomatoes :(
14:22:07 <mmorrow> :(
14:22:15 <copumpkin> people think I'm crazy
14:22:19 <Raynes> copumpkin: I hate tomatoes.
14:22:23 <copumpkin> oh good
14:22:25 <Raynes> copumpkin: We are not alone.
14:22:32 <fc1> and and this is what's frustrating about haskell -- its library is a bit too complicated to navigate
14:22:32 <mauke> fc1: yes, if you are in fact using a type that can be unboxed
14:22:59 <Phyx-> I hate tomatoes too
14:23:06 <gOcOOl> when does one need 'module main where ...'? the haskell script I'm using doesn't have it and it seems to work just fine.
14:23:22 <copumpkin> gOcOOl: you get an implicit one if you don't write it
14:23:24 <mauke> gOcOOl: never, because it's the default
14:25:00 <gOcOOl> ah ok, thanks. seems like it's unnecessary then
14:27:20 <FunctorSalad> hmm apparently the main module is also special in that it doesn't check module name - filename correspondence
14:27:25 <blackh> McManiaC: That's the IP address of the remote end of the socket, I think
14:27:49 <ddarius> FunctorSalad: The Report doesn't specify any correspondence between files and module names at all.
14:28:22 <FunctorSalad> oh
14:29:46 <Phyx-> @type (@)
14:29:47 <lambdabot> parse error on input `@'
14:30:05 <Phyx-> > hoogle @
14:30:07 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:30:27 <BONUS> imo @ is syntax
14:30:33 <gOcOOl> also, why would one 'import Prelude' in their source file? seems like that's unnecessary as well
14:30:48 <mauke> gOcOOl: to hide parts of it
14:31:02 <gOcOOl> ah yes, makes sense
14:31:18 <mauke> e.g. import Prelude hiding (catch)
14:31:23 <mauke> or import qualified Prelude as P
14:31:38 <Phyx-> BONUS: i'm not looking at the Haskell "@"
14:31:59 <mauke> then what are you doing with lambdabot?
14:32:18 <Phyx-> mauke: making a wild stab in the dark?
14:32:38 * mauke wildly stabs Phyx- in the dark
14:32:38 <copumpkin> poor dark
14:32:38 <copumpkin> why would you stab it?
14:32:46 <Phyx-> but anyway, think i know what it is
14:32:55 <mauke> with the BURNING MAGNESIUM DAGGER OF LOVE
14:32:59 <Phyx-> copumpkin: it was being mean to the light
14:33:06 <McManiaC> blackh: getHostByName "localhost" >>= inet_ntoa . hostAddress
14:33:07 <McManiaC> :)
14:33:15 * copumpkin has that in dragon age
14:33:45 <blackh> McManiaC: Almost. :)
14:33:59 <McManiaC> blackh: almost?
14:34:02 <mauke> "127.0.0.1"
14:34:19 <blackh> McManiaC: Well, it'll give you localhost 127.0.0.1
14:34:19 * Phyx- tests his hypothesis
14:34:23 <McManiaC> oh damn
14:34:24 <McManiaC> right
14:34:24 <McManiaC> ^^
14:34:56 <mauke> getHostByName "lolcathost"
14:35:06 <blackh> Looking up the hostname in the DNS can work in some configurations.
14:35:16 <blackh> But usually it doesn't.
14:35:23 <copumpkin> Veinor: do you follow a bunch of conservative users on twitter just to get riled up / pissed off in the morning?
14:36:49 <cpfr> is there anyway to get the pid of the process I start in System.Process
14:37:56 <mmorrow> awklisp is pretty sweet
14:38:15 <mmorrow> ((lambda (x) (list x (list 'quote x))) '(lambda (x) (list x (list 'quote x))))
14:38:18 <copumpkin> when it doesn't segfault
14:38:43 <mmorrow> oh yeah that
14:38:56 <mauke> cpfr: why?
14:39:00 <mmorrow> [m@monire awklisp]$ O=$(echo "((lambda (x) (list x (list 'quote x))) '(lambda (x) (list x (list 'quote x))))" | ./awklisp); while [[ true ]]; do echo $O; O=$(echo $O | ./awklisp); done
14:39:11 <copumpkin> ack
14:40:00 <cpfr> mauke, I want to do something in xmonad where I spawn applications and have metadata about them
14:40:24 <mmorrow> , let o :: String -> String; o = (fromJust.fromDynamic.eval) in iterate o "ap(++)show\"ap(++)show\""
14:40:28 <lunabot>  ["ap(++)show\"ap(++)show\"","ap(++)show\"ap(++)show\"","ap(++)show\"ap(++...
14:42:45 <mmorrow> , let o :: ExpQ->ExpQ; o = (return.either(undefined)(id).parseExp.fromJust.fromDynamic.evalQ) in (fmap (ppDoc <$>) . iterate o) [|ap(++)show"ap(++)show"|]
14:42:48 <lunabot>  [ap (++) show "ap(++)show",ap (++) show "ap(++)show",ap (++) show "ap(++)...
14:50:43 <romanandreg> guys quick question, do you know where I can find the source files of a Haskell installation in Mac OS X?
14:51:41 <Raevel_> romanandreg: do you mean the ghc source?
14:51:53 <romanandreg> Raevel_: yes, exactly that
14:51:59 <Raevel_> how did you install it?
14:52:11 <comak> http://darcs.haskell.org/ghc?
14:52:27 <romanandreg> Raevel_: If I remember correctly I think I did it with the package from ghc
14:52:45 <romanandreg> Raevel_: it was not ports, that for sure
14:53:09 <SubStack> you can ghc --print-libdir
14:53:20 <SubStack> but that's mostly compiled stuff and some c headers
14:53:22 <mmorrow> @hoogle processId
14:53:22 <lambdabot> System.Posix.Types type ProcessID = CPid
14:54:15 <romanandreg> SubStack: Thank you
14:54:29 <romanandreg> SubStack: Boy that was difficult to find in google :-@
14:54:47 <mmorrow> cpfr: just in ghci :m + System.Posix.Process, then type pid and start tab-fishing
14:55:19 <mmorrow> @hoogle getProcessID
14:55:19 <lambdabot> No results found
14:55:42 <mmorrow> @type System.Posix.getProcessID
14:55:43 <lambdabot> IO System.Posix.Types.ProcessID
14:55:48 <mmorrow> @type System.Posix.Process.getProcessID
14:55:49 <lambdabot> IO System.Posix.Types.ProcessID
14:56:10 <romanandreg> SubStack: Damn, I just have the binary files :-(...
14:56:21 <mathijsB> Hm, Im trying to multiply all odd elements out of a list by 2. I was thinking I could use the : operator to recursivly split and rebuild the list. Then also pass another argument that alternates between True and False to know where to multiply by 2.
14:56:33 <mathijsB> Even though it sounds like it could work, I think it is a little complicated, anyone knows an easier way?
14:56:39 <cpfr> mmorrow, i wanted some more programmable
14:56:44 <romanandreg> Is there a way to read the sources without actually downloading the whole thing?
14:57:02 <mmorrow> cpfr: like.. a function?
14:57:37 <cpfr> mmorrow, like I want to be able to spawn a process in xmonad and know what pid it got
14:57:38 <mmorrow> romanandreg: http://darcs.haskell.org/ghc/compiler
14:57:48 <cpfr> so later with xprop i can do things to that process
14:58:18 <mmorrow> @type System.Posix.Process.forkProcess
14:58:19 <lambdabot> IO () -> IO System.Posix.Types.ProcessID
14:58:37 <mmorrow> cpfr: you should read the haddock documentation, it'll tell you everything you want to know.
14:59:02 <mmorrow> cpfr: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:59:07 <romanandreg> mmorrow: thanks dude
14:59:14 <mmorrow> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html
14:59:23 <mmorrow> romanandreg: :)
14:59:23 <Cale> (It also links to the source code if you're really interested)
14:59:51 <sm> I'm contemplating splitting the hledger package into several.. perhaps one per subcommand, and would welcome any thoughts. http://groups.google.com/group/hledger/browse_thread/thread/c4e0531f14c8dd85
15:00:46 <yitz> sm: why so many?
15:01:06 <sm> well, because of the goals in that message
15:01:20 <mmorrow> sm: just having read the first two paragraphs, i think the idea of a modular plugin thing is win-win
15:01:36 <sm> it may be a silly idea, but I'm not sure
15:02:06 <mmorrow> as long as the plugins are relatively straightforward to get the most basic thing working
15:02:31 <mmorrow> since if not, it's hard to get started
15:02:47 <mmorrow> ("you" := someone that doesn't know the internals)
15:02:59 * mmorrow 's two cents :)
15:03:09 <sm> thanks
15:03:38 <romanandreg> does Data.Array (!) have O(N) efficiency?
15:03:45 <sm> I suppose ideally you'd try this out with beta testers on a personal hackage server
15:03:46 <monochrom> 1
15:04:10 <mmorrow> ah, yeah you could also go for each command/sub-thing being its own cli util, but each of them operating on the same thing/the same data-format
15:04:14 <mmorrow> or whatnot
15:04:54 <sm> the main thing I don't want to give up is a single "hledger" front end that lists all commands, options etc. Like git/svn/hg
15:05:18 <mmorrow> like, i started out with these two short progs that read a graph [(String,[String])] stdin -> stdout and do some operation on the graph, then slowly accumulated about 8 of these cli graph transformers, and they're actually super handy
15:05:39 * hackagebot upload: UMM 0.1.0 - A small command-line accounting tool:  hledger + bugs - features? maybe... (UweHollerbach)
15:05:50 <mmorrow> mostly because you can use them in shell-scripts/while doing whatever
15:05:54 <sm> woah
15:05:58 <copumpkin> UMM
15:06:06 <mmorrow> sm: :o
15:06:17 <sm> does that make my case or what :)
15:06:35 <sm> amazing timing
15:06:37 <mmorrow> hah
15:07:42 <yitz> sm: I like modularity to make it easy for people to add new features independently, in their own package. But why do the core fetures need to be broken up into different packages?
15:08:03 <yitz> sm: at first I thought you were the one who uploaded it :)
15:08:11 <sm> nope, first I heard of it
15:08:32 <romanandreg> does Data.Array (!) have O(N) efficiency?
15:08:35 <sm> yitz: well, first I wanted to make the web and ui commands separate packages, because they have heavier deps (happstack and vty)
15:08:39 <copumpkin> romanandreg: nope
15:08:55 <copumpkin> romanandreg: why would it? it's constant
15:09:12 <sm> and, it would be nice to recognize third-party commands/plugins which are published as separate packages
15:09:19 <yitz> sm: all true
15:09:28 <sm> and in that case why not just make each command a package
15:09:36 <yitz> that's the step i don't get
15:09:46 <romanandreg> copumpkin: Just wondering, there no indication of the efficiency of ! in the docs of Data.Array
15:10:20 <Axman6> should be O(1)
15:10:22 <romanandreg> copumpkin: I was going to check out the Data.Array source code
15:10:25 <copumpkin> well given that one of the distinguishing characteristics of an array is to have constant-time lookup
15:10:33 <romanandreg> copumpkin: but before, I wanted to ask here
15:10:50 <copumpkin> you'll just see a primitive
15:11:08 <sm> right now it's hard to ensure all of hledger is solid, it has outgrown my free time a bit, and I feel separating out chunks reduces that effort
15:11:15 <mmorrow> i think if you're going to split feature across multiple packages, you need a super focused/clear/complete interface/spec/whatever that they all are assuming and using
15:11:35 <mmorrow> then you just could maintain that i guess
15:11:41 <sm> but you're right that the existing core commands could be kept in the one main package (hledger-cli). I just think maybe it's simpler more consistent to go all or nothing
15:11:53 <sm> mmorrow: yes, this would force that. See the last goal
15:12:36 <mmorrow> totally
15:12:44 <Phyx-> wow, this VM is taking 100% of 1 core
15:13:36 <yitz> sm: imho it only makes sense if for each separate package there is a compelling reason why some people would want it and some not
15:13:42 <mmorrow> sm: that'd be cool if they all manipulated a specified abstract (but with concrete data-types) ledger structure, almost like an AST for a language
15:13:59 <sm> yitz: I hear that. So for you hledger (command-line, core commands), hledger-web, hledger-vty, hledger-lib would be about right ?
15:14:09 <yitz> sounds good
15:15:18 <yitz> you could even break out command-line, if that would remove a dependency on, say, unix, and if it's possible to work entirely with one of the other UIs.
15:16:56 <mmorrow> hmm, yeah i think yitz has a point, breaking apart the functionality into separate packages is definitely a different thing than separating the different user interfaces into separate pkgs
15:18:25 <yitz> sm: btw, i think hledger is really cool.
15:18:41 <sm> thanks! that's good to hear
15:19:01 <sm> things have been pretty quiet in hledger-land
15:19:08 <yitz> sm: i haven't gotten around to start using it yet. too lazy. but i'm really glad it's there, and i hope i will some day.
15:19:56 <yitz> sm: i wrote basically the same thing when i was in college. in rexx, ran on a mainframe. used it for the co-op i lived in.
15:20:07 <sm> cool
15:20:45 <yitz> or was it pl/i? i hope not. :/
15:21:07 <sm> it would be fun to see the code :)
15:21:22 <yitz> yeah, probably gone forever though
15:22:03 <sm> well thanks to Uwe Hollerbach, hackage Finance category is filling out. Excellent.
15:22:38 <yitz> it shows that hledger is inspiring
15:23:23 <ivanm> preflex: seen roconnor
15:23:23 <preflex>  roconnor was last seen on #haskell 8 hours, 39 minutes and 36 seconds ago, saying: woah, apparently there are other Kleene algerbras other than regular expressions.
15:23:33 <roconnor> here
15:23:37 <ivanm> hey roconnor
15:23:43 <sm> inspired by ledger
15:23:46 <ivanm> all the values are 0 <= x <= 255
15:23:58 <roconnor> which x?
15:24:01 <roconnor> er
15:24:04 <roconnor> my question is
15:24:22 <yitz> sm: yeah, but hledger is taking on a life of its own now
15:24:24 <roconnor> forall c,  is c <= a where a is alpha and c in {r,g,b}
15:24:37 <roconnor> however
15:24:47 <roconnor> if a is always 255, then this is not a helpful question.
15:24:54 <sm> yitz: well, we'll see. I am the only confirmed user afaik :)
15:25:29 <ivanm> roconnor: a is usually 255
15:25:44 <yitz> sm: i guess it's not just laziness. my finances are a wreck right now. i don't want to know what hledger would tell me.
15:25:46 <roconnor> is it ever strictly between 0 and 255?
15:25:49 <ivanm> roconnor: heh, actually, the only one that isn't 255 is for the transparent colour
15:25:54 <roconnor> okay
15:26:00 <sm> you make a good point. I often don't use it for the same reason
15:26:09 <roconnor> then it is unclear if this is premultiplied colour or not
15:26:15 <roconnor> then again, it doesn't matter
15:26:18 <roconnor> er
15:26:18 <ivanm> what do you mean by "premultiplied"?
15:26:20 <roconnor> acutally
15:26:24 <roconnor> what is transparent again?
15:26:26 <sm> I would like it to make finances fun. But that's not so easy!
15:27:05 <ivanm> roconnor: 255 255 254 0
15:27:08 <roconnor> okay
15:27:16 <roconnor> that violates the inequality
15:27:17 * ivanm doesn't get why the B value is 254 rather than 255
15:27:23 <roconnor> which means these are not premultiplied colours
15:27:32 <roconnor> which is fine
15:27:36 <roconnor> that is the usual case.
15:27:42 <ivanm> so I can just use them as-is?
15:27:49 <roconnor> yep
15:27:53 <roconnor> read the r g b as a colour
15:28:14 <roconnor> read the alpha  (scaling to 0-1)
15:28:31 <ivanm> by "scaling", you mean "divide the value by 255" ?
15:28:37 <roconnor> and then use sRGB r g b `withOpacity` (fromIntegral a / 255.0)
15:28:42 <roconnor> yes
15:28:45 <ivanm> good-o
15:29:46 <roconnor> ivanm: do you need to convert back?
15:29:55 <roconnor> ivanm: converting back is trickier
15:29:57 <ivanm> if so, I'll just convert back to a plain colour
15:30:24 <roconnor> well there is no direct operation from AlphaColour -> Colour
15:30:43 <roconnor> at the end of my tutorial I describe a trick for doing this.
15:31:50 <roconnor> mostly because that operation is not well defined for Transparent
15:33:12 <Chaze> this took me quite long. any comments/alternatives? http://pastie.org/705123
15:34:38 <roconnor> Chaze: I think map (x:) is more clear
15:35:24 <Chaze> not sure what you mean
15:35:38 <roconnor> replacing map ((:) x) with map (x:)
15:35:55 <roconnor> Chaze: you got the base case for permutations right ... always tricky
15:36:01 <roconnor> @src permutations
15:36:02 <lambdabot> Source not found.
15:36:07 <roconnor> @hoogle permutations
15:36:08 <lambdabot> Data.List permutations :: [a] -> [[a]]
15:36:08 <ivanm> roconnor: OK, different question: for your HSV colours, you have the V being an angle... if I have all three 0 <= H,S,V <= 1, do I just multiply V by 360?
15:36:18 <roconnor> V is not an angle
15:36:22 <roconnor> if I say so then it is an error
15:36:25 <ivanm> s/V/H/
15:36:25 <roconnor> H is an angle
15:36:33 <ivanm> yeah, read the wrong one
15:36:43 <roconnor> I followed wikipedia
15:36:52 <roconnor> so I guess you should scale it up to 360
15:36:54 <ivanm> I read "Its value ...", and saw the `V' there ;-)
15:37:12 <ivanm> roconnor: but there's no expectations about what the S and V values are?
15:37:28 <roconnor> the should be between 0 and 1 I think
15:37:47 <ivanm> good-o
15:37:51 <uafhsop> hello; i'm looking for a hackage library that can do miller-rabin primality testing
15:37:51 <Chaze> what i'm also wondering, but can't quite figure out: if i needed only permutations of n elements of my list, would lazy evaluation prevent calculating the rest ?
15:38:10 <Chaze> take 3 (permutations "A veeeery long list")
15:38:13 <roconnor> @src Data.List.permutations
15:38:13 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:38:28 <luqui> > take 3 (permutations "A veeeeeery long list")
15:38:29 <lambdabot>   ["A veeeeeery long list"," Aveeeeeery long list","v Aeeeeeery long list"]
15:38:34 <luqui> ;-)
15:38:37 <ivanm> Chaze: yes
15:38:42 <luqui> > take 3 (permutations [0..])
15:38:43 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
15:38:48 <Botje> uafhsop: http://www.polyomino.f2s.com/david/haskell/hs/Primes.hs.txt
15:38:59 <luqui> if it works on infinite lists, you can be pretty certain that it is lazy
15:39:00 <Chaze> luqui: wow
15:39:04 <Botje> check out "isMillerRabinPrime"
15:39:44 <ivanm> roconnor: how can I then convert an RGB values I've created with hsv to Colour (or AlphaColour)?
15:39:45 <roconnor> Chaze: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#permutations
15:39:50 <ben0x539> Why can fromIntegral not be named toNum
15:39:55 <ben0x539> fromIntegral is too long
15:40:06 <roconnor> ivanm: you can use one of the SRGB functions
15:40:11 <FunctorSalad> how can I obtain the module name after I've loaded a file with GHC API's `load' ?
15:40:22 <roconnor> ivanm: you may wish to use curryRGB or uncurryRGB
15:40:30 <ivanm> roconnor: get the tripple out of the RGB?
15:40:46 <roconnor> Chaze: I think the standard lib returns the permutations in a more efficent order
15:40:51 <luqui> Chaze, oh, it looks like your version is not lazy enough
15:40:53 <uafhsop> Botje: cool, they should put that in hackage
15:41:01 <ivanm> ooohh... {,un}curryRGB looks nice
15:41:07 <roconnor> ivanm: I think using curry/uncurryRGB is better than extracting the components
15:41:17 <ivanm> yeah, just noticed them
15:41:19 <Chaze> luqui: yeah, it didn't look very lazy to me ;)
15:41:42 <luqui> Chaze, no, don't get me wrong, it's actually pretty lazy
15:41:43 <uafhsop> Botje: any idea what dependencies that file has?
15:41:57 <luqui> Chaze, it just doesn't work on infinite lists for some reason
15:42:34 <roconnor> Chaze: I think your problem is that concatMap needs the head of (permuations xs) to begin
15:42:46 <roconnor> which requres the head of permutations (tail xs) to begin
15:42:56 <roconnor> which requires the head of permutataions (tail (tail xs)) to begin
15:42:58 <roconnor> etc.
15:43:38 <roconnor> Chaze: where as the code in Data.List returns the identity permutation straight away.
15:44:40 <roconnor> Chaze: actually I might be mistaken
15:44:44 <uafhsop> hey is there a very good, simple to use isprime function in hackage? (not simple trial division)
15:45:03 <roconnor> Chaze: notice how in insertEverwhere the head of the head of the result is item in both cases
15:45:22 <ivanm> uafhsop: ummm.... look for a library with "wheel" in the name/description...
15:45:28 <ivanm> something like that...
15:45:33 <Draconx> What's the proper way to convert a Double to a CDouble?  realToFrac (0/0 :: Double) :: CDouble is giving me -Infinity instead of NaN.
15:45:42 <roconnor> Chaze: right now that is buried underneath the a case analysis on insertEverywhere's second parameter.
15:45:44 <ivanm> uafhsop: maybe use hayoo to search for "prime" ?
15:46:09 <Chaze> yeah, i need to concat item into the list myself rather than by recursion
15:46:11 <roconnor> Chaze: the trick is to somehow push that case analysis deeper so that you can get the head of the head of the result out right away
15:46:18 <uafhsop> i got lots of packages to generate primes, or to test by trial division
15:46:37 <roconnor> Chaze: ie, rewrite insertEverywhere so that (head (head (insertEverywhere x undefined)) == x)
15:46:52 <Mr_Awesome> is there a better way to write (\x -> [x]) ?
15:46:57 <roconnor> Mr_Awesome: return x
15:46:59 <roconnor> er
15:47:01 <roconnor> Mr_Awesome: return
15:47:12 <roconnor> > return 5 :: [Int]
15:47:13 <lambdabot>   [5]
15:47:19 <ivanm> or, (:[])
15:47:20 <roconnor> or
15:47:22 <roconnor> ya
15:47:27 <roconnor> > (:[]) 5
15:47:29 <lambdabot>   [5]
15:47:29 <ivanm> which works more generally rather than assuming any random monad
15:47:35 <roconnor> we call that the monster
15:47:43 <ivanm> roconnor: I thought it was the monkey...
15:47:45 <roconnor> (:[]) -- rawr
15:47:48 <roconnor> oh
15:47:55 <roconnor> I call that the monster
15:48:23 <Axman6> ivanm: i'd call that l;ess general ;)
15:48:36 <roconnor> sometimes specific is good.
15:48:49 <ivanm> Axman6: well, "more generally" as in "it always returns a singleton list no matter how/where you use it"
15:48:50 <Mr_Awesome> that's what i was thinking. anyway, thanks.
15:49:16 <ivanm> Axman6: as I've been bitten before when using return to create a list in ghci/lambdabot and it didn't know which monad to use... :s
15:49:45 <ivanm> anyone have any idea how many packages break because they didn't put an upper bound on the version of parallel being used?
15:49:49 * ivanm guesses his does...
15:50:14 <roconnor> Chaze: insertEverywhere x list = (x : list) : go list where go [] = []; go (x:xs) = map ((:) x) (insertEverywhere item xs)
15:50:30 <roconnor> er
15:50:38 <roconnor> Chaze: insertEverywhere item list = (item : list) : go list where go [] = []; go (x:xs) = map ((:) x) (insertEverywhere item xs)
15:50:45 <Chaze> roconnor: thanks!
15:51:13 <roconnor> I bet take 3 permutations will run much faster.
15:51:47 <ivanm> we need a @criterion plugin for lambdabot so that once and for all we can prove/disprove these expections! ;-)
15:53:05 <roconnor> actually
15:53:09 <roconnor> that might not be enough
15:53:19 * roconnor is still worried about the concatMap
15:53:33 <jmegner> I have a question
15:53:37 <jmegner> let's say I'm inserting element into a hash table, and I'm doing the nice functional thing of using immutable data structures
15:53:53 <jmegner> does a new hash table have to be created every time I add a key-value pair?
15:54:04 <jmegner> s/element/elements/
15:54:07 <roconnor> jmegner: yes
15:54:17 <roconnor> we don't use hash tables very much in Haskell.
15:54:23 <jmegner> roconnor: are there performance penalties in that?
15:54:24 <sproingie> yes.  the copy is pretty cheap tho
15:54:37 <jmegner> sproingie: well, hash tables can get pretty big
15:54:58 <ivanm> jmegner: the way Data.Map works is by using a tree structure
15:55:05 <sproingie> the copy isn't really a copy per se
15:55:06 <ivanm> and pointers are kept to whatever old bits are still usable
15:55:24 <ivanm> so you only have O(log n) that needs changing/updating when you insert/delete a key/value pair
15:55:50 <jmegner> ivanm: that seems like a significant performance degradation
15:55:54 <Adamant> I read that as "Oleg(n)"
15:56:06 <HugoDaniel> hi
15:56:12 <sproingie> the complexity of Oleg is high
15:56:13 <ivanm> jmegner: it isn't
15:56:15 <ivanm> Adamant: heh
15:56:23 <HugoDaniel> i want to learn about optimizing haskell, can someone point me out some reading sources ?
15:56:42 <jmegner> ivanm: going from O(1) to O(log(n)) is a big jump to me
15:56:50 <sproingie> HugoDaniel: the ghc manual has a few pointers
15:56:54 <ivanm> jmegner: hashmaps aren't O(1)
15:57:01 <ivanm> or hashtables
15:57:05 <HugoDaniel> im not looking for the usual "mark everything as strict" kind of tricks :/
15:57:08 <sproingie> Data.Map isn't a hashtable, it's a treemap
15:57:14 <ivanm> sproingie: right
15:57:24 <ivanm> jmegner: http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
15:57:26 <roconnor> HugoDaniel: try making things more lazy.
15:57:32 <jmegner> well, I'm not concerned only about hash tables
15:57:36 <monochrom> jmegner: Have you actually benchmarked things and find them unacceptably slow in the real?
15:57:37 <Draconx> jmegner, for n less than the number of atoms in the observable universe, lg n is less than 250.  It's not what I'd call a "big jump".
15:57:38 <sproingie> you want a true hashtable, you could probably whip something up with STArray
15:57:42 <HugoDaniel> im looking more into using memory prefetching, cache aligning data types, etc...
15:57:44 <sproingie> it'd be fast, and ugly as all getout
15:57:56 <jmegner> I'm just wondering if immutable data structures have performance penalties you can't escape from
15:58:00 <ivanm> @remember Adamant [on the update complexity of Data.Map] I read that as "Oleg(n)"
15:58:01 <lambdabot> It is forever etched in my memory.
15:58:17 <ivanm> jmegner: very marginal ones if that
15:58:22 <jmegner> Draconx, good point
15:58:32 <sproingie> jmegner: they're tradeoffs.  they have gains you can't get with mutable ones
15:58:44 <ivanm> jmegner: unless you want to do something funky like judy tables, then you need them to be mutable
15:58:51 <roconnor> jmegner: there is no known asymtotic complexity penalties with a lazy functional language.
15:58:53 <jmegner> so, there's never a case that a O(n) operation becomes a O(n**2) operation due to immutability?
15:59:06 <ivanm> jmegner: you can't prove something like that in a general case
15:59:21 <Chaze> I want to implement this myself, but is there some function that picks all permutations of n elements out of a list?
15:59:23 <ivanm> maybe for a specific data structure, but then it's because you're probably using the wrong data structure
15:59:23 <Chaze> like:
15:59:25 <Chaze> nub $ map (take 3) $ permutations "A veeeeery long list"
15:59:37 <jmegner> ivanm: I'm okay with not having proof, but if no one has found any, that'll satisfy me
15:59:45 <roconnor> Chaze: still too slow?
15:59:49 <ivanm> jmegner: functional programming isn't just a matter of a different coding style; it's often a matter of using different algorithms and data structures catered to that programming style
15:59:57 <sjanssen> jmegner: there are certain algorithms that are proven to be asymptotically slower without mutability
16:00:02 <Chaze> roconnor: no, this is quite a different problem
16:00:04 <sjanssen> DFS is one
16:00:09 <ivanm> jmegner: see okasaki's book/thesis "purely functional data strucutres"
16:00:20 <Asztal> :t concatMap permutations . map (take 3) . tails
16:00:21 <lambdabot> forall a. [a] -> [[a]]
16:00:27 <jmegner> ivanm: is that book/thesis available for no charge?
16:00:27 <Chaze> before, i was using take 3 to take 3 permutations
16:00:37 <roconnor> Chaze: I'm not aware of a standard lib procedure to do that
16:00:41 <ivanm> jmegner: the thesis is; the book has a bit more stuff in it but you have to buy it
16:00:45 <Chaze> roconnor: alright, thx
16:00:47 <ivanm> @google okasaki thesis
16:00:48 <roconnor> Chaze: someone ought to make one.
16:00:49 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
16:00:49 <lambdabot> Title: Purely Functional Data Structures
16:00:56 <ivanm> jmegner: ^^ that's it
16:00:57 <jmegner> ivanm: thanks
16:00:58 <sproingie> the pdf gives you the gist of things, the book puts some meat on it
16:01:05 <roconnor> Chaze: if you want duplicates (which you don't) it is much easier.
16:01:09 <sjanssen> jmegner: but in the real world, O(log n) immutable structures are acceptable substitutes for O(1) mutable structures
16:01:09 <ivanm> sproingie: yeah; pity it's so expensive for such a thin book :(
16:01:28 <ivanm> we need an updated version with fancier data structures; maybe that's what RWH II can be about? :p
16:01:33 <sproingie> yeah and i'm told it's mostly ML examples, not haskell
16:02:06 <roconnor> Chaze: but if you wrote that permutations, doing what you want instead is not any harder.
16:02:06 <ivanm> sproingie: the thesis is IIRC; the book is ML examples with Haskell in an appendix
16:02:55 <Chaze> roconnor: yeah just figured
16:03:20 <sproingie> not sure if the implications of laziness would be adequately explained in a "here's the same code in Haskell" appendix
16:04:21 <ivanm> sproingie: it isn't from a lazy perspective, just a purely functional one
16:04:35 <ivanm> lazy data structures get even more goodness from what he wrote
16:04:40 <ivanm> s/from/than/
16:04:47 <ben0x539> Neat.
16:04:58 <ben0x539> I always assumed there were some severe order of complexity penalties.
16:04:59 <roconnor> there are known penalties for a strict pure functional language.
16:05:01 <monochrom> It is mostly ML with laziness annotation everywhere. May as well be Haskell.
16:05:20 <sproingie> oh the ML stuff is lazy?  didn't know that
16:05:40 <roconnor> monochrom: any knot tying?
16:05:43 <monochrom> Yes, I have the advantage of actually reading it before commenting.
16:05:55 <ivanm> monochrom: heh
16:05:59 <ivanm> I haven't read it in a while
16:06:09 <ivanm> I've been meaning to buy it, but it's not cheap :s
16:06:24 <ivanm> (especially since it'll probably sit on my shelf and not get read much...)
16:06:47 <sproingie> $39.25 on amazon, that's not terrible
16:07:04 <ivanm> sproingie: so that's about AU$75
16:07:09 <tensorpudding> ML is lazy?
16:07:10 <ivanm> that is terrible for such a thin book
16:07:20 <ivanm> tensorpudding: ML _laziness annotations_
16:07:24 <sproingie> kindle edition would be nice
16:07:33 <mathijsB> hm, i'm wondering what the proper way to do the following in haskell is : i got a list of single or double digit numbers, and I want to add all digits.
16:07:38 <mathijsB> is it nicer to do
16:07:47 <jmegner> okay, I think that adding to the beginning of a list can be done in O(1), but adding to the end of a list would be O(n), right?
16:07:47 <mathijsB> sumDigits [] = 0sumDigits (x:xs) = (x `div` 10) + (x `mod` 10) + sumDigits xs
16:07:52 <mathijsB> or
16:07:59 <mathijsB> sumDigits xs = sum (map (\x -> (x `div` 10) + (x `mod` 10)) xs)
16:08:01 <tensorpudding> add all the digits in the sense of 11 + 12 = 1112 or 1+1+1+2?
16:08:10 <roconnor> @hoogle digitToInt
16:08:10 <lambdabot> Data.Char digitToInt :: Char -> Int
16:08:23 <mathijsB> 11 + 12 = 1+1+1+2
16:08:52 <mathijsB> So i can just use a mod and a div to get the parts, But im wondering if its nicer to iterate over the list or to use a labda expression
16:09:01 <mathijsB> or some completely other way I havent though of maybe?
16:09:14 <tensorpudding> > map digitToInt "1110"
16:09:15 <lambdabot>   [1,1,1,0]
16:09:17 * ivanm wonders how he gets "Oracle Database 10g Express Edition PHP Web Programming" when searching for "Purely Functional Data Structures" in an online book store aggregatr...
16:09:42 <roconnor> > (sum . (map digitToInt)) "1110"
16:09:43 <lambdabot>   3
16:09:43 <tensorpudding> > sum $ map digitToInt $ "10" ++ "11"
16:09:45 <lambdabot>   3
16:09:52 <jmelesky> ivanm: paid results on "data" ?
16:10:16 <mathijsB> well, the input is Integer in this case, so it feels bad to convert to string first then use digittoint, i think?
16:10:23 <ivanm> jmelesky: AFAIK, this is some guys hobby
16:10:29 <ivanm> and he gets money on sale referalls
16:10:32 <monochrom> roconnor: I don't think I see knot tying. But there is clever conscious sharing (in the scheduling technique), and that comes close to knot tying.
16:10:37 <ben0x539> How do I turn a Ptr () into a ByteString?
16:10:59 <roconnor> monochrom: explict sharing is always easier to control than implicit sharing. :)
16:11:00 <jmelesky> ivanm: *shrug* don't know what to tell you, then
16:11:24 <ivanm> jmelesky: unless it's the bookstores its searching that are returning those results... *shrug*
16:11:25 <roconnor> ben0x539: very unsafely
16:11:56 <ben0x539> roconnor: Well, I am fine with copying it and I have the length and everything :< But I guess I do not really want to do that
16:14:17 <skorpan> that blog entry on hash tables was great
16:14:35 <jmegner> ivanm: how would I append to the front and back of an immutable list/some-sequence-container in O(1)?
16:14:58 <ivanm> jmegner: there's a more efficient queue structure on hackage IIRC
16:15:01 <roconnor> jmegner: use Data.Seq
16:15:08 <roconnor> which uses a finger tree
16:15:13 <ivanm> roconnor: is that O(1)? or O(log n)?
16:15:21 <roconnor> amortized O(1)
16:15:21 <ivanm> I thought it had to do some re-shuffling...
16:15:27 <roconnor> er
16:15:28 <roconnor> hmm
16:15:30 <roconnor> not sure now
16:15:32 <ivanm> heh
16:15:38 <ivanm> jmegner: but yeah, Data.Sequence is nice
16:15:40 <jmegner> roconnor, ivanm: oh, cool
16:15:50 <roconnor> maybe it is O(log(n))
16:15:58 <roconnor> still
16:15:59 <roconnor> ...
16:16:01 <ivanm> as someone said earlier; we normally don't care about O(log n) penalties
16:16:22 <jmegner> ivanm, roconnor: lots of things in Haskell are tree-ish, aren't they?
16:16:30 <roconnor> The docs say O(1)
16:16:32 <ivanm> yup
16:16:40 <ivanm> roconnor: OK, I must have mis-remembered
16:16:49 <ivanm> or else it's an amortized thing, and I was remembering worst case
16:17:00 <roconnor> I can't imagine it is always O(1).
16:17:21 <roconnor> but I could beleive it is O(log n) every log n insertions
16:17:52 <Veinor> copumpkin: why yes, yes I do
16:18:15 <Veinor> EVERY MORNING I WAKE UP AND OPEN PALM SLAP A TWEET INTO ECHOFON
16:18:46 <ivanm> @slap Veinor
16:18:47 * lambdabot places her fist firmly on Veinor's jaw
16:18:50 <Veinor> :(
16:18:59 <ben0x539> Speaking of which, is there any documentation on Parsimony?
16:19:05 <ben0x539> beyond haddock
16:19:21 <jmegner> ivanm, roconnor: thanks for answering my questions; they were really bugging me;
16:19:39 <copumpkin> Veinor: lol
16:19:47 <jmegner> ivanm, roconnor: I was thinking "surely there's something going on I don't know about"
16:20:04 <jmegner> bye guys, thanks
16:20:10 <ivanm> cya jmegner
16:20:24 <Veinor> IT'S @JSWTX AND, RIGHT THEN AND THERE I START TAPPING THE KEYBOARD
16:20:25 <Veinor> etc.
16:20:53 <ben0x539> jswtx # Bio fiscal conservative social liberal foreign policy hawk blogger
16:20:54 <ben0x539> ???
16:21:36 <Veinor> Injoke.
16:21:42 <mmorrow> here's what a Data.Sequence looks like http://moonpatio.com/vacuum/gallery/sequence.html
16:23:05 <mmorrow> it's better at appending (to either end) and at splitting in two, than it is at indexing
16:23:14 <monochrom> ivanm: I too thank you for the hash table blog link.
16:23:42 <ivanm> monochrom: you've never seen it before? :o
16:24:23 <monochrom> I have never read 99.99999% of the world's blogs.
16:24:54 <Veinor> I read a few.
16:25:01 <Veinor> And I have my one that I barely update. :V
16:25:30 <ivanm> mmorrow: now, if only I understood what that vacuum diagram did/meant... :p
16:25:45 <ivanm> monochrom: well, it's been on proggit a few times, been referenced here, etc. ...
16:25:56 <monochrom> I don't read proggit either. :)
16:26:41 <jlouis> Doing Twelf proofs turns out to be a tedious thing
16:26:44 <tensorpudding> I don't follow proggit, I do follow /r/haskell though
16:27:19 <jlouis> proggit is dead. It was interesting a few years ago
16:27:29 <copumpkin> Veinor: is :V your signature smiley?
16:27:33 <copumpkin> V for Veinor
16:27:57 <ivanm> jlouis: I still read through it...
16:27:58 <Veinor> Yes, because I am alsays :V about everything.
16:28:12 <ivanm> monochrom: heh; it's one of my favourite procrastination methods
16:28:17 <Veinor> Even at a funeral, my mouth is permanently open at a 30-degree angle. It's tragit.
16:28:20 <Veinor> *tragic
16:28:54 <mmorrow> ivanm: that's the actualy structure of a Data.Sequence
16:28:58 <mmorrow> *actual
16:29:18 <tensorpudding> Reddit is pretty close to being too noisy now
16:29:32 <kmc> proggit is pretty bad
16:29:36 <mmorrow> a tuple is    .. <- a <- (,) -> b -> ..
16:29:51 <kmc> if you want to hear a lot about Agile Scrum
16:29:54 <kmc> then it's the place to go
16:29:55 <tensorpudding> you have a few great subreddits that never get posted to, or a bunch of big reddits that are noisy
16:29:57 <ivanm> is DavidA who does the haskellformaths package here?
16:30:07 <kmc> haskell-reddit is good because it's dons's personal links blog ;)
16:30:11 <ivanm> mmorrow: right, but I've never really understood the vacuum graphs
16:30:13 <ivanm> kmc: heh
16:30:27 <tensorpudding> yes, /r/haskell is good because dons is the only one who every posts on it
16:30:40 <tensorpudding> ever*
16:30:46 <mmorrow> what mental picture do you have in your mind, say, for a Data.Map?
16:30:50 <mmorrow> or Data.Tree
16:31:25 <ivanm> tensorpudding: no he isn't...
16:31:33 <jlouis> mmorrow: it looks awfully much like the typical product diagram for cat. theory, your 2-tuple example
16:31:36 <ivanm> mmorrow: a binary tree... >_>
16:31:57 <mmorrow> that's vacuum diagram is actually amusingly the exact same picture as is in the fingertree paper (well, of course it is, but it's still an "oh cool" sight)
16:32:13 <ivanm> mmorrow: the labels, etc. don't help
16:32:26 <mmorrow> those are the constructors
16:32:29 <ivanm> and it'd be easier to read if the image was slightly bigger or zoomable ;-)
16:32:32 <ivanm> ahhh, right
16:33:02 <mmorrow> and the numbers are the order that the algo vacuum is using visited the nodes
16:33:21 <mmorrow> which is a variation of a cheney garbage collector
16:33:30 <tensorpudding> ivanm: almost the only one, I suppose
16:33:38 <ivanm> tensorpudding: he does a majority, yes
16:35:43 <luqui> @src ap
16:35:44 <lambdabot> ap = liftM2 id
16:35:50 <luqui> @src liftM2
16:35:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:48:19 <Cale> Just checking: has anyone else here used Tikz to typeset diagrams with natural transformations in them? I'm wondering about the easiest way to get the usual double-lined arrow style for that.
16:48:59 <Cale> (I could just go on using xypic, but xypic ends up looking like line noise, and doesn't have many of the cool features that PGF/Tikz does)
16:51:14 <Apocalisp> @type comain
16:51:15 <lambdabot> Not in scope: `comain'
16:51:21 <Apocalisp> pssh
16:52:26 <mauke> do coprogrammers destroy de?
16:53:03 <ben0x539> I hate functional dependencies >:[
16:53:21 <ivanm> mauke: de what?
16:53:33 <Draconx> Cale, you draw a double-lined arrow with e.g. \draw[double,->] (0,0) -> (1,1);
16:53:38 <tensorpudding> de, the dual of code
16:53:57 <ben0x539> I thought the dual of code was decode
16:54:24 <Mr_Awesome> is there some haskell utility that will show the evaluation of a piece of code step by step?
16:54:38 <mauke> yes, it's called Cale :-)
16:54:43 <Cale> ehehe
16:54:58 <Cale> I was about to say that if you would write one, you might save me a lot of trouble :)
16:55:15 <mmorrow> Cale: kuvio is supposed to be good
16:55:20 <kmc> it's a simple and fun exercise to write that utility, for lambda calculus
16:55:25 * mauke writes code to privmsg Cale
16:55:32 <ivanm> mauke: heh
16:55:36 <Mr_Awesome> perhaps i'll write that then.
16:55:40 <mmorrow> err, but Tikz looks like something else actually from the webpage
16:56:49 <mmorrow> that's a pretty sweet image on the cover of the manual (looking at a screenshot of Tikz)
16:56:54 <Cale> yeah :)
16:57:02 <Draconx> TikZ is wonderful :)
16:59:51 <Mr_Awesome> i seem to be having a problem with my "interleave" function.  anyone care to take a look? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=4985#a4985
17:00:03 <tensorpudding> hmm, vacuum-cairo seems to want some non-existent packages
17:00:45 <mauke> Mr_Awesome: because line 3 tries to look at x before it exists
17:00:55 <Cale> Mr_Awesome: because interleave tries to pattern match both the head and the tail
17:01:01 <Cale> er, the first and second list
17:01:02 <Cale> rather
17:01:56 <mauke> reduced code: x = case x of [] -> y; (x:xs) -> ...
17:01:57 <Cale> Try  interleave [] ys = ys;  interleave (x:xs) ys = x : interleave ys xs
17:01:59 <Mr_Awesome> mauke: i thought only line 4 would get called.
17:02:08 <mauke> Mr_Awesome: why?
17:02:19 <Cale> Mr_Awesome: it tries the patterns in order
17:02:36 <Mr_Awesome> because the second list is not empty.
17:02:46 <mauke> how do you know it's not empty?
17:02:48 <Cale> Mr_Awesome: In order to tell that it must evaluate it
17:03:03 <Cale> Mr_Awesome: But it is already trying to evaluate it
17:03:41 <Mr_Awesome> aha, i see.
17:03:42 <Cale> > let interleave [] ys = ys;  interleave (x:xs) ys = x : interleave ys xs; x = [0..] `interleave` x in x
17:03:43 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
17:04:14 <Mr_Awesome> heh, your definition is quite a bit more elegant than mine. :)
17:04:15 <mauke> headache
17:05:36 <monochrom> nice conundrum
17:05:37 <Mr_Awesome> there wouldn't happen to be something in the std lib that replicates this functionality, would there?
17:05:40 <Cale> Hey, those are the nim-values for heaps of n beans in the game where you're allowed to take up to half of the beans in a heap.
17:06:09 <Cale> Well..
17:06:26 <mauke> > let x = unzip ([0 ..], x) in x
17:06:27 <lambdabot>   Couldn't match expected type `[(a, b)]'
17:06:27 <lambdabot>         against inferred type `([t]...
17:06:34 <mauke> wait, what am I thinking
17:06:42 <ivanm> good question
17:06:44 <ivanm> ;-)
17:06:50 <Cale> > let interleave xs ys = concat (transpose [xs,ys]); x = interleave [0..] x in x
17:06:51 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
17:06:55 <mauke> wow, I need sleep
17:07:25 <fc1> so how do i iterate over a multi-dimensional array
17:07:30 <Mr_Awesome> transponse, of course.
17:07:41 <Mr_Awesome> well, thanks for the help.
17:08:39 <shrughes> > extendSequence [0, 0, 1, 0, 2, 1, 3]
17:08:40 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
17:08:47 <Cale> > let a n | even n = n `div` 2 | otherwise = a ((n - 1) `div` 2) in map a [0..]
17:08:48 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
17:12:50 <Philonous> Can I somehow have aan instance like "instance Monoid [a] where mempty = [], mappend = (++) "
17:13:23 <Saizan> there's already one
17:13:37 <Saizan> > [1,2] `mappend` [3,4]
17:13:39 <lambdabot>   [1,2,3,4]
17:13:50 <Philonous> Oh great, where is it defined?
17:14:05 <Saizan> Data.Monoid, i thought
17:14:44 <mmorrow> tensorpudding: (if you're on linux (because it uses freeglut to not have to enter a main event loop, and uses pthread_create() once)), this might work for you (also, you have to make libpthread.so a symlink to the real .so, since ghci doesn't do linker scripts)... now after that paragraph of disclaimers ... this might work for you, i use it all the time for viewing vacuum stuff http://moonpatio.com/repos/vacuum-gl/
17:15:02 <kmc> are there screenshots?
17:15:09 <Philonous> Hah, indeed. thanks.
17:15:12 <mmorrow> kmc: actually there are, one sec
17:16:14 <Philonous> Strangely the very same code gave me complaints about ambiguous type variables a minute ago, but now it works.
17:16:34 <tensorpudding> mmorrow: what is that?
17:16:54 <mmorrow> http://moonpatio.com/vacuum/gallery/vacuum-gl.png
17:17:13 <mmorrow> http://moonpatio.com/vacuum/gallery/sharing.png
17:17:23 <mmorrow> http://moonpatio.com/vacuum/gallery/flipTree2.png
17:17:49 <tensorpudding> so this is different than vacuum cairo I suppose?
17:17:51 <mmorrow> (ignore the test-program call "segfault-something", this is an old shot ;) http://moonpatio.com/vacuum/gallery/neato_vac.png
17:18:19 <mmorrow> tensorpudding: it uses OpenGL instead of cairo+gtk(which you need to compile yourself, since it's not cabalized)
17:18:32 <mmorrow> it depends on base,OpenGL,GLUT,vacuum
17:18:35 <mathijsB> hm, say i want to iterate backwards over a list, is there any equivalent to : that gets the last element of alist?
17:18:36 <mmorrow> err, and containers
17:18:40 <mathijsB> or should i use reverse and then : ?
17:18:41 <mmorrow> maybe array too :)
17:19:01 <mmorrow> tensorpudding: also it talks directly with the graphviz C api
17:19:06 <kmc> mmorrow, nice
17:19:17 <mmorrow> so there's no intermediate process
17:19:25 <kmc> sharing is caring
17:19:33 <mmorrow> :)
17:19:44 <kmc> mathijsB, you can't pattern match a list from the back
17:20:00 <kmc> so yeah you'd have to reverse it
17:20:29 <monochrom> I wonder why you would iterate backwards. Maybe because of misdesign.
17:20:47 <kmc> and it'll require traversing the whole list before any elements are processed
17:21:16 <tensorpudding> mmorrow: sounds cool, i suppose i'll try and install it...
17:21:22 <mmorrow> tensorpudding: it's also really a graph-viewer-via-graphviz in general, although the code needs to be organized bad
17:21:32 <mmorrow> tensorpudding: you're on linux, right?
17:21:35 <Philonous> mathijsB: You may want view patterns "foo (reverse -> x:xs) = ... " But if you want to grab the last element of a list regularly maybe you are using the wrong data structure?
17:21:51 <kmc> mathijsB, maybe Data.Sequence would be useful
17:21:56 <kmc> random access and bidirectional iteration
17:22:20 <mmorrow> osx fails since apparently freeglut doesn't work on it (and apparently also the graphviz .bmp format is different, and my reader doesn't handle that variant), and windows doesn't have pthread.h
17:22:36 <tensorpudding> mmorrow: yes
17:22:58 <mmorrow> (pthread_create() was needed to get two C functions that read/write from a pipe()'ed FILE* to talk in a single proc)
17:23:06 <mmorrow> tensorpudding: nice
17:23:06 <mathijsB> hm, ty kmc
17:23:33 <mmorrow> it needs freeglut to be able to sit in the background in ghci
17:24:55 <tensorpudding> it claims to be installed now
17:25:38 <mmorrow> tensorpudding: ooh nice.
17:25:48 <mmorrow> so in ghci you can do (view :: a -> IO ())
17:25:53 <tensorpudding> where are the haddocks?
17:26:09 <mmorrow> http://moonpatio.com/repos/vacuum-gl/haddocks/
17:26:29 * hackagebot upload: vector 0.4 - Efficient Arrays (RomanLeshchinskiy)
17:26:38 <kmc> hmm, does Data.Sequence allow insertion in the middle of a sequence?
17:26:40 <kmc> it seems not to
17:26:43 <mmorrow> it's not on hackage because it's been added to as-i've-needed something, and not really coherently designed
17:26:46 <kmc> is that hard to implement efficiently?
17:26:58 <ivanm> mmorrow: do you have an interactive version of vacuum for browsing/exploring the graphs? or is the cairo version just producing static graphs still?
17:27:10 <monochrom> usually you break the sequence into two at the insertion point, then re-join.
17:27:40 <kmc> :t viewr
17:27:40 <mmorrow> although i've used it a lot, and i'd like to get it organized and some more convenience functions added to it to make a generic graph viewer
17:27:41 <lambdabot> Not in scope: `viewr'
17:27:43 <kmc> :t S.viewr
17:27:44 <lambdabot> Couldn't find qualified module.
17:28:21 <mauke> :t Seq.viewr
17:28:22 <lambdabot> forall a. Seq.Seq a -> Seq.ViewR a
17:28:36 <mmorrow> ivanm: you can also use ubigraph to get 3D graphs, but wrt something like getting info as-things-are-evaluated, unfortunately not at the moment
17:28:43 <kmc> also... there's no toList, unless i'm missing it?
17:28:50 <mmorrow> there's a lazy version though that works now
17:28:57 <ivanm> mmorrow: is there ubigraph bindings?
17:29:04 <kmc> ah, but it's Foldable
17:29:08 <mmorrow> ivanm: there is yeah, on hackage
17:29:24 <tensorpudding> what is this about libpthread?
17:29:29 <mike8901> Can someone help me with understanding Monads?
17:29:31 <mmorrow> (i've also got my own bootleg ubigraph bindings too)
17:29:33 <tensorpudding> i have a symlinked libpthread.so
17:29:36 <ivanm> mmorrow: :o
17:29:39 * monochrom snickers
17:29:45 <kmc> :t (\x -> foldr (:) []) :: Seq.Seq a -> [a]
17:29:46 <lambdabot>     Couldn't match expected type `[a]'
17:29:46 <lambdabot>            against inferred type `[a1] -> [a1]'
17:29:46 <lambdabot>     In the expression: foldr (:) []
17:29:48 <mmorrow> tensorpudding: oh right, is it a symlink already
17:29:49 <mmorrow> ?
17:29:50 <mauke> mike8901: why do you need to understand them?
17:29:57 <ivanm> mmorrow: oh, I thought you meant generic ubigraph bindings, not just those for vacuum :(
17:30:03 <kmc> :t (foldr (:) []) :: Seq.Seq a -> [a]
17:30:04 <lambdabot>     Couldn't match expected type `Seq.Seq a'
17:30:05 <lambdabot>            against inferred type `[a1]'
17:30:05 <lambdabot>     In the expression: (foldr (:) []) :: Seq.Seq a -> [a]
17:30:05 <mike8901> maukue: Writing an interpreter
17:30:08 <mmorrow> tensorpudding: i had to rename my original libpthread.so to libpthread.so_
17:30:14 <mauke> mike8901: so?
17:30:20 <tensorpudding> why?
17:30:21 <ivanm> tensorpudding: could be someone having a linker script
17:30:21 <mmorrow> then make a symlink so whatever the ....so.7 is
17:30:27 <ddarius> mike8901: Read Wadler's "The Essence of Functional Programming"
17:30:31 <ivanm> mmorrow: you have a linker script for libpthread.so?
17:30:35 <mmorrow> tensorpudding: if you cat libpthread.so, you'll see it's a linker script
17:30:38 <kmc> mike8901, sure
17:30:39 <mmorrow> just text
17:30:44 <copumpkin> to understand monads, you must first understand all of mathematics
17:30:48 <kmc> mike8901, are you trying to understand a particular monad?
17:30:59 <ivanm> mmorrow: right, so it's a linker script; hgolden is working on a GHC patch to understand them \o/
17:31:05 <mike8901> well, I'm trying to create a particular monad - it's more syntax than concept that I'm having trouble with
17:31:06 <kmc> mike8901, the Maybe monad is a good place to start
17:31:07 <ddarius> Monads hardly require any mathematics.
17:31:11 <mmorrow> [m@monire ~]$ ls -l /usr/lib64/libpthread.so
17:31:11 <mmorrow> lrwxrwxrwx 1 root root 22 2009-04-02 01:24 /usr/lib64/libpthread.so -> /lib64/libpthread.so.0
17:31:14 <ivanm> mmorrow: I'm currently fighting gentoo devs on linker scripts vs symlinks... :@
17:31:19 <tensorpudding> will moving libpthread.so break things?
17:31:23 <ivanm> mmorrow: apparently symlinks are bad for statically linked packages
17:31:33 <ivanm> tensorpudding: _maybe_ if it's a statically linked binary or something
17:31:34 <mauke> mike8901: oh, I can do syntax
17:31:36 <mmorrow> tensorpudding: not if you put a symlink the the real lib file
17:31:38 <kmc> mike8901, okay, we can help with syntax too
17:31:39 * ivanm goes off to find the gentoo bug report
17:31:43 <mike8901> cool :)
17:31:43 <monochrom> To understand coinduction, you must first explain coinduction.
17:31:49 <copumpkin> lol
17:32:00 <mmorrow> tensorpudding: do "cat /usr/lib/libpthread.so" and you'll see
17:32:08 <ivanm> tensorpudding: http://bugs.gentoo.org/4411
17:32:18 <ivanm> that's Gentoo's rationale for linker scripts rather than symlinks
17:32:20 <mike8901> so, basically, I need the Monad to take in a "Store" of variables, do a computation on them, and return a value, and a store.
17:32:37 <mauke> State Store
17:32:43 <kmc> that sounds like how you'd describe it *without* monads
17:32:50 <mmorrow> [m@monire ~]$ cat /usr/lib64/libpthread.so_
17:32:50 <mmorrow> ...
17:32:50 <mmorrow> GROUP ( /lib64/libpthread.so.0 /usr/lib64/libpthread_nonshared.a )
17:32:51 <ivanm> monochrom: hmm... is that correct? is that because you have to understand before you can explain?
17:32:55 <kmc> @unmtl State Store a
17:32:56 <lambdabot> Store -> (a, Store)
17:33:03 <mike8901> I don't mean the haskell store type
17:33:04 <ivanm> but how is that co-inductive since understanding doesn't require explanation?
17:33:10 <kmc> mike8901, granted
17:33:12 <mauke> wait, haskell has a store type now?
17:33:14 <kmc> i don't think we have a haskell Store type
17:33:17 <ivanm> mmorrow: yeah, that's a linker script
17:33:21 <mike8901> oh, ok :)
17:33:23 <tensorpudding> it seems to have crashed ghci
17:33:28 <ivanm> mauke: you mean we can have Haskell shops? :o
17:33:29 <ivanm> ;-)
17:33:40 <mmorrow> tensorpudding: heh, did it say "elf file too short" or something?
17:34:04 <tensorpudding> No, I fixed the pthread problem, now it says there is no renderer for bmp
17:34:11 <mmorrow> :o
17:34:15 <mike8901> so I have type Env = [(Identifier, Value)] where type Identifier = String, type Value = Int
17:34:19 <mmorrow> tensorpudding: is your graphviz old?
17:34:19 * shapr boings quietly
17:34:22 <tensorpudding> and ghci is unresponsive
17:34:28 <mike8901> then, instance Monad (Env e) where
17:34:33 <mauke> mike8901: type Env = Map Identifier Value
17:34:35 <mmorrow> tensorpudding: you probably also need graphviz-devel if you don't have it
17:34:35 <tensorpudding> It's the default of debian stable
17:34:43 <mauke> mike8901: Env e is malformed
17:34:46 <tensorpudding> I have the dev package
17:34:48 <ben0x539> Why are the pattern matches for 'checkClass s v@(_, fmap (== s) . lookup "class" -> Just True) = ... , checkClass _ _ = ...' overlapped?
17:34:50 <mmorrow> hmm
17:34:52 <mike8901> mauke: er, why?
17:34:54 <kmc> mike8901, did you look at the State monad?
17:35:02 <mmorrow> tensorpudding: what ghc version do you have?
17:35:04 <kmc> you probably want to use the (State Env) monad
17:35:05 <mauke> mike8901: because Env doesn't take any arguments
17:35:07 <ivanm> tensorpudding: libpthread is probably statically compiled
17:35:09 <kmc> rather than declaring Env itself as a monad
17:35:12 <kmc> which doesn't make much sense
17:35:26 <kmc> also, [(key, value)] is a really inefficient way to store a map, for most purposes
17:35:27 <tensorpudding> mmorrow: 6.10.4
17:35:30 <kmc> Data.Map is better
17:35:41 <mmorrow> tensorpudding: although if it said no renderer for bmp, that sounds like a graphviz problem
17:35:42 <mike8901> kmc: Not so concerned about efficiency for the time being
17:35:45 <copumpkin> or just make a map function
17:36:06 <mauke> mike8901: Data.Map has easier functions for dealing with environments
17:36:08 <mmorrow> tensorpudding: does "$ dot -Tkjsdkjjklsjd" list "bmp" in the list of formats?
17:36:16 <kmc> yeah, i feel Data.Map is easier than an assoc list
17:36:18 <mauke> at least in my opinion
17:36:19 <mmorrow> (that'll trigger the help w/ the list)
17:36:23 <kmc> since it provides a whole library
17:36:39 <ivanm> mmorrow: eh, I prefer -Txxx
17:36:49 <monochrom> ivanm: coinduction talks about let's say an infinite stream, a function Stream->(Item,Stream). It is an infinite producer. So I use that as pun: you have to produce a tutorial first.
17:36:58 <mike8901> I have code for dealing with [(key, value)] in my existing interpreter - I'd like to stick with that for the time being
17:36:59 <tensorpudding> No, it seems not to...
17:37:13 <tensorpudding> Debian stable has an old version of dot, it appears.
17:37:34 <mike8901> so why doesn't instance Monad (Env e) where... make sense?
17:37:44 <mauke> mike8901: because Env doesn't take any arguments
17:37:45 <ivanm> mmorrow: what would I have to do to get you to use my graphviz library for vacuum rather than you having your own Dot module?
17:37:54 <mmorrow> i've got dot - graphviz version 2.22.2 (20090313.1817), but i think i compiled from source iirc
17:37:56 <ivanm> monochrom: ahhh
17:37:57 <mauke> mike8901: especially not two of them
17:38:04 <mmorrow> any reasonably new version should work
17:38:04 <mike8901> mauke: So, what should I put in its place?
17:38:11 <mauke> mike8901: nothing
17:38:17 <mauke> mike8901: what are you trying to do?
17:38:17 <mike8901> so just instance Monad where.. ?
17:38:18 <tensorpudding> this is 2.20.2 here
17:38:20 <ivanm> monochrom: I obviously don't understand coinduction ;-)
17:38:23 <mauke> mike8901: no, nothing at all
17:38:38 <kmc> mike8901, the state is not the stateful computation
17:38:39 <ivanm> tensorpudding: yeah, might be out of date
17:38:40 <mike8901> mauke: Create a monad that does Env -> (val, Env)
17:38:49 <kmc> @unmtl State Env val
17:38:49 <mauke> mike8901: that's State Env
17:38:49 <lambdabot> Env -> (val, Env)
17:38:51 <mike8901> I have a non-monadic interpreter working
17:38:53 <ivanm> tensorpudding: note that the graphviz docs lie a lot as well about what outputs are available, etc.
17:39:00 <mauke> mike8901: import Control.Monad.State
17:39:02 <mike8901> I want to do it myself though, without the haskell Env.
17:39:09 <kmc> mike8901, there's no haskell Env
17:39:09 <mauke> THERE IS NO HASKELL ENV
17:39:13 <kmc> you're confusing State and Env
17:39:16 <kmc> @unmtl State Env val
17:39:16 <lambdabot> Env -> (val, Env)
17:39:20 <kmc> @unmtl State FooBarBaz val
17:39:20 <lambdabot> FooBarBaz -> (val, FooBarBaz)
17:39:23 <mike8901> ok, sorry, without haskell State
17:39:24 <mmorrow> ivanm: the vacuum graphviz code is literally like 15 lines, and i want to keep deps to a minimum, but i've been looking at that lately actually. it'd be interesting to play around with it
17:39:31 <mauke> mike8901: ok, then reimplement State
17:39:37 <ivanm> mmorrow: fair enough
17:39:39 <mike8901> that's what I'm trying to do :)
17:39:52 <mmorrow> ivanm: vacuum-graphviz or something i'm thinking
17:39:54 <copumpkin> @src State
17:39:54 <ivanm> mmorrow: it'd just be nice to have a high-profile use case rather than just me using it ;-)
17:39:54 <lambdabot> Source not found. Where did you learn to type?
17:40:02 <mmorrow> ivanm: heh :)
17:40:13 <mauke> mike8901: step 1: data State a = State (Env -> (a, Env)); step 2: instance Monad State where
17:40:27 <mmorrow> ivanm: i didn't realize you had all you have in there until about a week ago actually
17:40:34 <ivanm> mmorrow: :o
17:40:38 <ivanm> don't you read announcement emails?
17:40:57 <mmorrow> heh, but that's one thing, and seeing the haddocks/code is another
17:41:03 <ivanm> mmorrow: I was pretty pissed off when I found that galois had paid someone to write language.dot, re-implementing a lot of the same stuff I was working on at the same time :s
17:41:06 <ivanm> mmorrow: heh
17:41:38 * ivanm is amazed how many corner parsing bugs QC is finding
17:41:57 <mauke> I'll parse your corners!
17:42:11 <copumpkin> Kavannagh QC!!
17:42:11 * ivanm slowly backs away from mauke 
17:42:16 <mike8901> mauke: ok, so then return a = [] ?
17:42:30 <ivanm> mike8901: return a = [a] you mean?
17:42:33 <krainbolt> => []
17:42:40 <mike8901> sorry, yes
17:42:42 <mauke> mike8901: no, [] has the type [a], but you need State a
17:42:49 <monochrom> return a = State (\e -> (a,e))
17:44:36 <monochrom> Though I spoil the solution, it is for the good cause of speeding up the learning. (Concrete examples tell more than wordy discussion.) Beating the dead horse is faster than beating around the bush.
17:44:58 <copumpkin> foreplay?
17:45:40 <mike8901> okay, so then (Env x) >>= State(\e -> (interp e x)) where interp is of the form Expr -> Env -> Val ?
17:45:59 <monochrom> I be damned if you had foreplay in a bushy place with a dead horse nearby.
17:46:13 <mauke> http://superdickery.com/index.php?option=com_content&view=article&id=310:the-things-archie-will-do-to-get-a-girl&catid=32:seduction-index&Itemid=36
17:46:32 <mauke> mike8901: no, >>= State is wrong
17:46:38 <mauke> mike8901: the second argument of >>= is a function
17:47:01 <mauke> mike8901: and Env x is wrong too because the first argument is a State a, not an Env
17:47:10 <copumpkin> :)
17:47:11 <mauke> and Env x is wrong in general because you don't have a data constructor called Env
17:47:58 <EvilTerran> hehe
17:48:25 <EvilTerran> lambdabot's hackage page is on the first page of google results for "4.2.2.1"
17:48:31 <monochrom> hahahaha
17:48:33 <EvilTerran> (i was looking for info about the DNS server)
17:48:48 <mauke> vnsc-pri.sys.gtei.net
17:48:57 <monochrom> @remember EvilTerran lambdabot's hackage page is on the first page of google results for "4.2.2.1"
17:48:58 <lambdabot> Done.
17:49:20 <EvilTerran> mauke, pardon?
17:49:32 <mauke> that's the name of the server
17:49:50 <EvilTerran> ah, of course
17:49:59 * EvilTerran tried to access it as a website <.<  >.>
17:50:11 <mike8901> so I'd do (State a) >>= f = State(\s -> f a s) ?
17:50:38 <mauke> that looks too simple
17:50:52 <mauke> f a doesn't typecheck
17:50:54 <EvilTerran> mike8901, remember that the parameter of the State value constructor is a function
17:51:10 <mauke> remember, if you do (State a), then a is a functio... what EvilTerran said
17:51:11 <EvilTerran> from the old state, to the result and the new state
17:51:27 <kmc> @unmtl State Env a
17:51:27 <lambdabot> Env -> (a, Env)
17:51:30 <mmorrow> @type State (splitAt 4)
17:51:31 <lambdabot> forall a. State [a] [a]
17:51:40 <mmorrow> @type State next
17:51:42 <lambdabot> forall s. (RandomGen s) => State s Int
17:52:04 <mike8901> EvilTerran: Can you elaborate a little bit?
17:52:42 <mmorrow> get = State (\s -> (s,s))
17:52:43 <mauke> State g >>= f = State (\e -> f ... (g e) ...
17:53:20 <mmorrow> get = \s -> (s,s)
17:53:38 <mmorrow> put s = \_ -> ((),s)
17:53:57 <mmorrow> (omitting the constructor)
17:54:05 <mike8901> right, so (State a) >>= f = State(\s -> f a s) should call f with the parameters of the expression(a) and the store (s), right?
17:54:25 <mauke> what do you mean by "should"?
17:54:37 <mike8901> will :)
17:54:46 <mauke> yes, if you ignore the typechecker
17:54:53 <mike8901> ok, I don't care about types for now
17:55:17 <mike8901> but I guess I might as well implement type checking..
17:55:30 <mauke> what?
17:55:34 <mmorrow> State f >>= k = State (\s_old -> case f s_old of (a,s_new) -> case k a of State g -> g a s_new)
17:55:34 <mauke> I mean the Haskell typechecker
17:55:34 <kmc> lol
17:55:40 <mike8901> oh
17:55:41 <mike8901> :P
17:55:45 <mauke> your code does not compile
17:55:49 <gOcOOl> @src print
17:55:49 <lambdabot> print x = putStrLn (show x)
17:55:49 <copumpkin> who's yo daddeh
17:56:08 <mauke> mike8901: simply because f expects the result of an expression, not the expression itself
17:56:33 <ivanm> mmorrow: oh, anyway, with graphviz, there's Even More Cool Stuff (TM) in the darcs repo that I'm hacking on atm
17:56:51 <ivanm> mmorrow: I'll probably be making a release as soon as QuickCheck stops finding bugs... >_>
17:56:52 <mmorrow> ivanm: ooh nice. on code.haskell.org?
17:56:53 * Cale submits new information about  fix (interleave [0..])  to Sloane
17:56:55 <ivanm> mmorrow: yup
17:57:04 <mmorrow> ivanm: cool, i'll check it out
17:57:15 <ivanm> Cale: Sloane?
17:57:20 <Cale> OEIS
17:57:22 <mmorrow> , fix (interleave [0..])
17:57:23 <kmc> @src interleave
17:57:24 <lunabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16...
17:57:24 <lambdabot> Source not found. I am sorry.
17:57:24 <ivanm> ahhh
17:57:30 <kmc> @hoogle interleave
17:57:30 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
17:57:30 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
17:57:30 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
17:57:40 <copumpkin> interesting
17:57:41 <mmorrow> , 'interleave
17:57:42 <lunabot>  Control.Monad.Logic.Class.interleave
17:57:45 <ivanm> Cale: hmmm... what pattern is that meant to be?
17:57:51 <Cale> interleave xs ys = concat . transpose $ [xs,ys]
17:58:17 <Cale> ivanm: write the natural numbers, but leave a space between each pair
17:58:19 <mmorrow> that's a good new one for fix
17:58:36 <mauke> , fix (interleave "sequence")
17:58:37 <lunabot>  "ssesqeuseqnecueseqnecueseqnecueseqnecueseqnecueseqnecueseqnecueseqnecues...
17:58:41 <Cale> ivanm: and then write them again, leaving a space blank between each pair again, and so on
17:59:05 <Cale> (in the spaces that you left in the last step)
17:59:09 <copumpkin> > fix (interleave "abc")
17:59:10 <lambdabot>   "aabacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbac...
17:59:23 <ivanm> Cale: so, is it a _useful_ sequence? even a named one?
17:59:47 <Cale> ivanm: Well, "These are the nim-values for heaps of n beans in the game where you're allowed to take up to half of the beans in a heap."
17:59:58 <ivanm> O...K...
18:00:04 <ivanm> "nim-values"?
18:00:06 <Cale> http://www.research.att.com/~njas/sequences/A025480
18:00:18 <mmorrow> hah, in my first programming class we had to code nim for our second assignment
18:00:42 <mmorrow> you can solve the game fairly easily
18:01:02 <ivanm> oh, nim is the name of a game?
18:01:03 <mmorrow> for small enough boards i suppose (or does that matter?)
18:01:19 <Cale> yeah, and nim-values are a generalisation of the solution to that game, essentially
18:01:51 <Cale> http://en.wikipedia.org/wiki/Nim-value
18:12:34 <mike8901> so I'm looking back at the data definition for State - I want to fully understand it: What does "a" represent in data state a = State(Env -> Value, Env)) ?
18:12:52 <mike8901> and what does "State" represent on the RHS?
18:13:25 <mauke> er
18:13:29 <mauke> have you used 'data' before?
18:13:38 * mike8901 admits he has not
18:13:52 <mauke> then you might want to start with something simpler :-)
18:14:05 <mike8901> I like to throw myself into projects :)
18:14:30 <mauke> data Color = Red | Green | Blue | Yellow
18:14:51 <mike8901> That makes sense
18:15:06 <mauke> data Point3d = Coords Int Int Int
18:15:08 <mike8901> but what's the "a" ? - just an arbitrary param?
18:15:09 <Philonous> State is a constructor. It does what the name suggests, it constructs values of a certain type
18:15:25 <mauke> data Maybe a = Nothing | Just a
18:15:27 <Philonous> Yes, a is a type parameter
18:15:43 <mike8901> I have data State a = State (Env -> (Value, Env))
18:16:18 <mauke> no, you don't
18:18:35 <Philonous> mike8901: Look at Maybe a: It can either be Nothing or Just a, for any a. So for example Just "foo" is of type Maybe String, Just 5 is of type Maybe Int , Just (Just "foo") is of type Maybe ( Maybe String). Nothing on the other hand can be any of those types, it's polymorphic.
18:19:02 <ben0x539> Is anyone using Parsimony?
18:19:06 <ben0x539> I believe sepEndBy is broken.
18:32:42 <mike8901> hrm, so the Haskell state monad defines newtype State s a = State { runState :: (s -> (a,s)) }
18:32:56 <mike8901> I'm not entirely sure how to read that syntax
18:33:21 <roconnor> mike8901: it creates two functions (which are inverses of each other)
18:33:26 <roconnor> @type State
18:33:27 <lambdabot> forall s a. (s -> (a, s)) -> State s a
18:33:28 <ben0x539> read it as State s a = State (s -> (a, s))  ; runState (State f) = f
18:33:33 <roconnor> @type runState
18:33:34 <lambdabot> forall s a. State s a -> s -> (a, s)
18:33:34 <c_wraith> haha.  I was just saying last night that it's a horrible idiom from the viewpoint of being understandable to people new to the language. :)
18:33:35 <ben0x539> plus i guess a type
18:34:07 <roconnor> mike8901: technically it is using record syntax.
18:34:23 <mike8901> hrm, ok, let's say I want to ignore that for the time being :)
18:34:33 <mike8901> and create something of a cleaner definition(or at least something I can understand)
18:34:35 <c_wraith> It's common to see record syntax used with data
18:34:39 <dobblego> is there a way to start ghci with all exposed-modules in a cabal file?
18:34:51 <ivanm> dobblego: what do you mean?
18:34:55 <ivanm> oh, wait, I get you
18:34:57 <c_wraith> it also works with newtype, so long as there's only one argument.
18:35:02 <mike8901> I'm new to Haskell - I'd rather stick with syntax I know when exploring the horribly confusing concept of Monads...
18:35:23 <c_wraith> monads aren't confusing.  You've just had them presented to you badly. :)
18:35:26 <ivanm> dobblego: write a script to generate a Haskell file that does nothing but import all exposed modules, then runs ghci on it?
18:35:41 <mike8901> c_wraith: I sort of understand what they are, I just don't know how to express them in Haskell...
18:36:01 <dobblego> ivanm, I figured it's just a switch I have overlooked
18:36:13 <mike8901> so data State a = State(Env -> (Value, Env)) is wrong?
18:36:13 <c_wraith> mike8901:  reimplement the Maybe monad, then.  It's a really straightforward one, with a simpler type.
18:36:49 <c_wraith> mike8901:  well, yes, because you want type variables where you have Value and Env
18:36:51 <ivanm> dobblego: don't think so
18:36:58 <ivanm> cabal-install doesn't seem to offer such a thing
18:37:03 <mike8901> I defined value and env previously
18:37:28 <mike8901> type Value = Int, type Env = [(Identifier, Value)], type Identifier = String, type Value= Int
18:37:34 <c_wraith> it's not a useful monad if Value is fixed.
18:37:40 <mike8901> it's not..
18:37:46 <dobblego> ivanm, righto cheers
18:38:06 <Saizan> dobblego: there's a ticket for something like "cabal ghci"
18:38:07 <mike8901> It's just the type of Value that's fixed
18:38:15 <c_wraith> It's ok if the state is fixed, but...  It doesn't even have the right kind, if there's no type variable
18:38:28 <c_wraith> mike8901: are you familiar with kinds?
18:38:36 <mike8901> nope
18:38:46 <c_wraith> mike8901: a kind is just a type of a type.
18:38:54 <dobblego> Saizan, great cheers
18:39:00 <c_wraith> @kind Maybe
18:39:01 <lambdabot> * -> *
18:39:18 <c_wraith> That indicates that Maybe is a type constructor that takes a type, and returns a type.
18:39:45 <c_wraith> @kind State
18:39:46 <lambdabot> * -> * -> *
18:40:19 <c_wraith> State takes two types, and returns a type.  (or more specifically, takes a type and returns another type constructor that takes a type and returns a type)
18:40:35 <c_wraith> Monads need to have the kind * -> *
18:40:50 <c_wraith> (well, with some exceptions you can ignore involving symbols other than *)
18:41:06 <mike8901> c_wraith: conceptually, I can understand: I want the monad to take as input Env and output (value, Env)
18:41:43 <c_wraith> mike8901: correct.  So your data declaration started out by declaring a type variable, but it never used that variable in the definition
18:42:33 <mike8901> er, so what exactly is a "type variable"?
18:42:38 <mike8901> is that the "a"
18:42:39 <mike8901> ?
18:42:42 <c_wraith> yes
18:42:50 <c_wraith> It indicates "you can use any type here"
18:43:14 <c_wraith> And then the definition at least should use that type variable, to indicate how values of that type are related to the definition
18:43:39 <c_wraith> One of the simpler examples is Maybe...  data Maybe a = Just a | Nothing
18:43:53 <mike8901> but do I really need a type variable?
18:44:09 <mike8901> I know the types of Env and Value
18:44:55 <c_wraith> A monad "decorates" a value of any type, though.
18:45:26 <mike8901> so what do I want then? data State a = State(a -> (Value, a)) ?
18:45:49 <c_wraith> Other way around.  You want the Env to be a fixed type, but the value to be a
18:45:50 <ivanm> @src Maybe
18:45:51 <lambdabot> data Maybe a = Nothing | Just a
18:45:53 <ben0x539> Add more # to make it faster
18:45:54 <ivanm> c_wraith: you lied! :o
18:46:17 <c_wraith> @src Monad
18:46:18 <lambdabot> class  Monad m  where
18:46:18 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:46:18 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:46:18 <lambdabot>     return      :: a -> m a
18:46:18 <lambdabot>     fail        :: String -> m a
18:46:27 <ben0x539> @src ST
18:46:28 <lambdabot> newtype ST s a = ST (STRep s a)
18:46:35 <ben0x539> @src STRep
18:46:35 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
18:46:45 <mike8901> c_wraith: that sounds really ugly... isn't one of the primary features of Haskell strong typing? ;)
18:47:04 <c_wraith> mike8901:  Look at just the "return" function there.  Note that it is defined to work for any input type
18:47:14 <ben0x539> mike8901: It decorates a value of any type, but only one type at a time. It is perfectly safe.
18:47:40 <mike8901> okay, so then going with data State a = State(a -> (Value, a))
18:47:47 <mike8901> I have instance Monad State where:
18:47:51 <kmc> @unmtl State Value
18:47:52 <lambdabot> err: `State Value' is not applied to enough arguments, giving `/\A. Value -> (A, Value)'
18:47:53 <kmc> @unmtl State Value a
18:47:54 <lambdabot> Value -> (a, Value)
18:48:27 <Cale> Yeah, if you get it the wrong way around it won't even be a functor, let alone a monad, so it's good to take care :)
18:49:02 <mike8901> ok, so data State a = State(Env -> (a, Env)) ?
18:49:34 <c_wraith> mike8901:  yes, though you'd usually put a space before the first (
18:49:49 <mike8901> okay, I have a space there :)
18:49:50 <Axman6> heh, i was refraining from saying that
18:50:06 <mike8901> then, instance Monad State where
18:50:12 <mike8901> return a = State(\s -> (a,s))
18:50:15 <kmc> @unmtl State Env a
18:50:15 <lambdabot> Env -> (a, Env)
18:51:06 <c_wraith> why did fail ever get put into Monad?  >_>
18:51:13 <kmc> mike8901, strong typing and parametric polymorphism work closely together
18:51:51 <kmc> parametric polymorphism is *precisely how* you write strongly, statically typed functions which are generic across many datatypes
18:52:35 <kmc> :t return
18:52:36 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:52:41 <Cale> c_wraith: The reasoning is a growing snowball of failure which started with the removal of monad comprehension syntax.
18:53:12 <kmc> no type-safety issue there.  you know, when you put in something of type "a", that you get back something of type "m a".  that's known at compile time, and the typechecker can use it accordingly
18:53:22 <ben0x539> Can we just pretend fail is a synonym for error and not worry about it?
18:53:43 <sproingie> fail is fail
18:53:47 <sproingie> there's an easy mnemonic
18:54:43 <Cale> c_wraith: Someone noticed that this meant that MonadPlus no longer needed to be in the Prelude, so they got moved to the Monad library. Then someone else noticed that all the *existing* instances which were instances of one were also instances of the other. So they decided to merge them (also a bad idea). Then there was the problem that because there was no MonadZero, the translation for the do-notation had to change
18:54:44 <Cale> to deal with the case where pattern matches failed.
18:55:12 <Cale> So they just stuffed a fail method in there and that's how you get the trainwreck of fail.
18:55:35 <sproingie> is fail likely to go away in a future standard?
18:55:56 <Cale> If there's any justice in the world it should at least get separated into its own class.
18:56:29 <kmc> that's a sad story
18:56:29 <sproingie> MonadFail?  sounds good to me
18:56:32 <sjanssen> if monoids are things that have a "combine" operation, what are the things that have a "difference" operation?
18:56:46 <copumpkin> groups
18:56:59 <ivanm> I must say, the list monad is nice to work with for writing custom shrink methods for Arbitrary instances...
18:57:02 <Cale> Oh, I had some edit fail in there
18:57:07 <ben0x539> Do monoids already have a neutral elements, or was that semigroups, or
18:57:11 <Cale> I meant to mention MonadZero earlier in that, really I did ;)
18:57:17 <Cale> ben0x539: yeah
18:57:19 <copumpkin> monoids have neutral elements
18:57:33 <c_wraith> > let { q = modify (+5)  >> return 7; r = modify (subtract 1) >> return 'R' } in runState (do { x <- q ; y <- r ; return $ show x ++ show y }) 0
18:57:34 <lambdabot>   ("7'R'",4)
18:57:37 <Cale> semigroups are the ones which are just associative
18:57:49 <dobblego> is the function (0 -> 'a', 1 -> 'b', ...) somewhere in Data.Char
18:58:07 <ben0x539> Oh.
18:58:09 <sjanssen> hmm, I'm not sure if my structure is a group
18:58:09 <sproingie> @hoogle Int -> Char
18:58:09 <lambdabot> Data.Char chr :: Int -> Char
18:58:10 <lambdabot> Data.Char intToDigit :: Int -> Char
18:58:10 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
18:58:10 <Cale> dobblego: no, but you can use chr and ord to write it
18:58:11 <copumpkin> chr . (+97)
18:58:20 <dobblego> Cale, yeah don't like repeating libraries though
18:58:29 <kmc> > chr . (+97)
18:58:30 <lambdabot>   {-3->'^';-2->'_';-1->'`';0->'a';1->'b';2->'c';3->'d'}
18:58:34 <copumpkin> sjanssen: well difference seems like \x y -> x `op` (inv y)
18:58:38 <c_wraith> mike8901:  Note how in the example I just gave, return was used with 3 different types, overall?  That's why a monad needs to have a variable return type.
18:58:53 <sjanssen> copumpkin: yeah.  It's possible I don't really mean difference
18:59:52 <ben0x539> > let f = (subtract `on` fromEnum) 'a' in map f "abc"
18:59:53 <lambdabot>   [0,1,2]
18:59:58 <copumpkin> sjanssen: what do you have?
19:00:28 <c_wraith> Cale, could lambdabot import qualified Text.ParserCombinators.UU.Parsing ?
19:00:29 <sjanssen> what I'm thinking about are X11 window configuration changes.  Those are essentially sets of properties that we want to change on the window: size, position, border are some examples
19:02:11 <sjanssen> I know those are a monoid where the result is the union of properties, and choosing either left or right when the same property is set for different values
19:03:03 <sjanssen> given a windows current properties, and a desired set of new properties, I want to compute what actually must change
19:03:55 <copumpkin> hmm
19:04:10 <Saizan_> seems like you want "xor"
19:04:37 <ainirtnec> Hi copumpkin.
19:04:51 <copumpkin> omg it's centrinia
19:05:06 <sjanssen> Saizan_: yeah, actually
19:06:14 <sjanssen> so let's rephrase that: given that mappend = (&&), what is the fancy math name for xor?
19:06:26 <copumpkin>  /=
19:06:28 <dobblego> (/=)
19:06:41 <c_wraith> for bits...
19:06:44 <sjanssen> I'm not asking for the actual implementation
19:06:48 <copumpkin> :P
19:07:18 <sjanssen> implementing this stuff is easy, I just want to understand if there is an abstraction here that I'm missing
19:07:21 <kmc> sjanssen, it's another Monoid
19:07:38 <kmc> check for yourself: xor is an associative operator, with 0 as identity
19:07:47 <Saizan_> sjanssen: wikipedia says abelian group
19:07:56 <Saizan_> sjanssen: for the case of Bool at least
19:08:01 <kmc> isn't it a field too ;P
19:08:03 <monochrom> The boolean ring of {True,False} uses the two operations /= and &&
19:08:12 <kmc> the thing is that a single Haskell datatype can be a Monoid in several ways
19:08:24 <kmc> which is why Data.Monoid has newtype wrappers for, e.g., Sum and Product
19:08:58 <monochrom> And by /= I do not mean "actual implementation"
19:09:08 <ainirtnec> The boolean ring of ({True,False},(/=),(&&)) is also a field. It is F_2 :O
19:09:17 <sjanssen> actually, I'm not looking for xor.  I want the things in Y that are not in X -- I don't care about the things in X that are not in Y
19:09:31 <kmc> asymmetric set subtraction, then
19:09:34 <sjanssen> that's like set difference
19:09:47 <roconnor_> Heyting algebra?
19:09:47 <ainirtnec> > [1..10] \\ [3,5,9]
19:09:49 <lambdabot>   [1,2,4,6,7,8,10]
19:09:55 <kmc> that seems to require inverses
19:10:09 <ivanm> @hoogle [a] -> [[a]]
19:10:10 <lambdabot> Data.List inits :: [a] -> [[a]]
19:10:10 <lambdabot> Data.List permutations :: [a] -> [[a]]
19:10:10 <lambdabot> Data.List subsequences :: [a] -> [[a]]
19:10:30 <ivanm> > subsequences [1..10]
19:10:31 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
19:10:33 <ivanm> bah
19:10:42 <ivanm> is there a function that returns all possible ways of removing one element of a list?
19:11:08 <copumpkin> yeah, but it's not in any library
19:11:10 <copumpkin> ;)
19:11:17 <ivanm> well, that was implicit ;-)
19:11:21 <c_wraith> it's common in permutation code, though.
19:11:25 <ivanm> yeah
19:11:31 * ivanm hacks together his own
19:11:48 <Gracenotes> ivanm: maybe a scanl on a zipper
19:11:57 <copumpkin> selections [] = []
19:11:57 <copumpkin> selections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]
19:12:02 <copumpkin> I think I stole that from Cale
19:12:06 <ivanm> I actually need a way of removing any 2, but I figure nub . concatMap rem1 . rem1 should do the trick
19:12:17 <Gracenotes> or.. hm, that's probably not enough.. map/accum sorts of things
19:12:27 <sjanssen> we ought to have a list paramorphism function in the libraries, I keep missing it
19:12:38 <Gracenotes> okay, zippers be less useful there
19:12:40 <ivanm> "paramorphism"?
19:12:53 <c_wraith> copumpkin:  It's the exact same way I've written the function.  But it's also the most obvious way, so that's not saying much.
19:13:29 <sjanssen> ivanm: para :: (a -> [a] -> b -> b) -> b -> [a] -> b -- like foldr, but it gets the "tail" in addition to the head
19:13:41 <copumpkin> ivanmorphism
19:14:03 <sjanssen> hah, if ivanm every changes his nick it beter be that
19:14:07 <monochrom> monomorphism!
19:14:25 * ivanmorphism coughs
19:14:39 <dobblego> Data.Map is moved out of base?
19:14:45 <sjanssen> monochrom: don't change your nick to that, everybody would subconsciously hate you
19:14:46 <ivanmorphism> containers
19:14:51 <sjanssen> dobblego: yeah, like 5 years ago
19:14:57 <dobblego> no way
19:15:09 <ivanmorphism> containers is still included with ghc
19:15:14 <ivanmorphism> even 6.12 I think?
19:16:48 <kmc> so the [] monad is good for "all-possible-results" nondeterminism.  what about a "backtrack until first success" style?  would i use a list there?  maybe Omega, or roll my own with Cont?
19:16:48 <sproingie> sproingomorphism
19:17:16 <copumpkin> success?
19:17:23 <ivanm> @slap copumpkin
19:17:24 * lambdabot activates her slap-o-matic...
19:17:31 <dobblego> http://paste.pocoo.org/show/151605/
19:17:37 <sproingie> kmc: possibly Either, with failures on Right?
19:17:38 <monochrom> Still use [], then head it. Lazy list, won't pursue "2nd success".
19:17:42 <Cale> kmc: take the head of the resulting list?
19:18:00 <sproingie> not quite backtracking there, more like "short circuit at first success"
19:18:01 <kmc> sproingie, that won't backtrack
19:18:04 <Cale> (or safer: take 1)
19:18:26 <sproingie> i suspect you'd need Cont for genuine backtracking
19:18:33 <kmc> Either won't give a nondeterministic choice operator
19:18:39 <ivanm> copumpkin: with that selections function, I take it it's type sig is :: [a] -> [(a,[a])] ?
19:18:46 <copumpkin> ivanm: indeedles
19:18:49 <sjanssen> dobblego: you gotta unhide containers.  If you're building with Cabal, that means adding to build-depends.  If you get this error with standalone ghc, "ghc-pkg expose containers"
19:18:50 <kmc> what would be the effective difference between backtracking with Cont, and using head with []?
19:19:09 <dobblego> sjanssen, of course cheers
19:19:18 <monochrom> I don't actually see how to use Cont for this.
19:19:30 <sproingie> technically you could use Cont for anything
19:19:32 * sjanssen is trying to remember, base was first split in GHC 6.8, right?
19:20:03 <ivanm> sjanssen: yeah, I think so
19:20:10 <ivanm> or was it 6.6?
19:20:19 <monochrom> Yeah, apart from "you could use assembly code too" kind of "can". Much more coding and no better efficiency.
19:20:41 <ivanm> no, 6.6 had base-2 with internal bytestring IIRC (which makes deps of some packages so... "interesting" :s )
19:20:55 <sjanssen> ivanm: 6.8 if we believe the release notes
19:21:09 <kmc> continuations are a natural way to implement backtracking
19:21:10 <sjanssen> dobblego: sorry, Data.Map was split out of base only two years ago, not five
19:21:22 <kmc> if you hit a failure, you pop off some stack the continuation of the last choice you made, and make it differently
19:21:30 <Saizan_> kmc: there's LogicT on hackage, that's a bit cleverer than []
19:21:33 <dobblego> sjanssen, yeah I was being daft in any case, cheers
19:21:42 <kmc> ah excellent
19:21:51 <kmc> Saizan_, that's probably what i want, thanks
19:22:23 <ivanm> sjanssen: yeah, but what do they know? :p
19:23:06 <mike8901> hrm, I'm having trouble understanding what runState is in the State monad definitions - do I need to have that in my data declaration?
19:23:09 <copumpkin> I really want a Set monad :(
19:23:15 <kmc> mike8901, it's a record label
19:23:18 <kmc> :t runState
19:23:19 <lambdabot> forall s a. State s a -> s -> (a, s)
19:23:21 <mike8901> do I need one?
19:23:24 <kmc> no
19:23:28 <copumpkin> a potentially infinite set monad would be even nicer
19:23:35 <sproingie> mike8901: runState just takes the State wrapper off the state function
19:24:04 <monochrom> It is optional. It is more convenient.
19:24:44 <mike8901> so then would I write (State x) >>= f = State (\s -> (f x s)) ?
19:25:02 <mike8901> damnit, too much scheme
19:25:15 <mike8901> (State x) >>= f = State (\s -> f x s) is what I meant
19:25:16 <monochrom> hahaha
19:25:21 <kmc> heh
19:25:29 <kmc> it's the same either way
19:25:35 <copumpkin> you can remove the lambda
19:25:40 <Saizan_> that doesn't look right, though 'x' is indeed the content of the State there
19:26:00 <kmc> yeah, (\s -> f x s) === (f x)
19:26:08 <Saizan_> so, a function from the state to a tuple of the new state and the result
19:26:35 <mike8901> Saizan_: So it's not right?
19:27:01 <Saizan_> mike8901: f expects the result of x as first argument, not the whole x
19:27:02 <sproingie> what throws people is that a State value is a function
19:27:34 <sproingie> it should be called StateTransformer or something
19:27:45 <mike8901> Saizan_: The "result" of x? what do you mean?
19:27:52 <Saizan_> mike8901: x is a function there
19:27:56 <kmc> :t mconcat
19:27:57 <lambdabot> forall a. (Monoid a) => [a] -> a
19:28:04 <kmc> :t mappend
19:28:05 <lambdabot> forall a. (Monoid a) => a -> a -> a
19:28:07 <kmc> :t msum
19:28:08 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
19:28:23 <dobblego> is it usual to use '\n' in a Show instance?
19:28:46 <monochrom> No.
19:28:47 <Saizan_> mike8901: (x :: s -> (s,a)) , (f :: a -> State s b)
19:28:51 <kmc> probably not, if you want to preserve (read . show) == id
19:29:00 <kmc> :t read.show
19:29:01 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
19:29:20 <Saizan_> read generally don't care about \n
19:29:22 <dobblego> instance Show ChessBoard
19:29:27 <kmc> > (read . show) "3"
19:29:29 <lambdabot>   * Exception: Prelude.read: no parse
19:29:35 <kmc> > (read . show) (text "()")
19:29:36 <lambdabot>   ()
19:29:50 <tensorpudding> @type text
19:29:52 <lambdabot> String -> Doc
19:30:05 <tensorpudding> hmm
19:30:16 <monochrom> in the Text.PrettyPrinter module
19:30:56 <mike8901> Saizan: I'm still not fully understanding -- how do I evaluate x and pass it to f?
19:30:57 <copumpkin> what does "Every object has a power object." mean?
19:31:05 <copumpkin> it seems like you'd need two objects to have a power object
19:31:16 <tensorpudding> what is a power object?
19:31:36 <Saizan_> mike8901: you want to apply x to something, it's not a matter of evaluating
19:31:43 <copumpkin> tensorpudding: and exponential
19:31:45 <copumpkin> -d
19:31:59 <Saizan_> mike8901: 'x' expects to be given a state
19:32:34 <Saizan_> (is that even grammatically correct?)
19:32:40 <copumpkin> yep
19:32:46 <mike8901> would that be the "s" that's passed to the lambda...?
19:33:02 <Saizan_> mike8901: yeah :)
19:33:09 <kmc> go into the cave and find your power object
19:33:17 <monochrom> hahaha
19:33:21 <dobblego> @type \x k -> x ++ intercalate x k ++ x
19:33:22 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:33:26 <mike8901> so then (State x) >>= f = State(\s -> (f (x s)) ?
19:33:43 <monochrom> I didn't find a power object. I found a monad.
19:34:32 <Saizan_> mike8901: almost, the result of x is a tuple, of a new state and the actual value of type 'a' that f is immediatelly interested in
19:35:46 <Saizan_> mike8901: so you've to unpack that tuple to access the argument for f
19:36:35 <Saizan_> then you should think about what the result of f is, and what type the overall result of the lambda should have
19:37:17 <Saizan_> the types say almost everything here :)
19:38:54 <tensorpudding> i wish that other languages made it as easy to figure out what a function actually does as haskell
19:39:02 <monochrom> I am no longer sure why we go through this to write an interpreter. Writing plain functions that thread through the environment is faster. You say, oh, what if this is a venue for learning monads? I answer, then still write the plain threading-through version first, and then point out a refactoring that leads to the monadic version. Infinitely clearer, as Wadler shows.
19:39:08 <dobblego> don't tell the Scala guys
19:40:17 <mike8901> (State x) >>= f = State(\s -> let (v, s') = (x s) in State (f v) s'  ) ?
19:41:22 <Saizan_> well, are you sure about the last State?
19:41:45 <Saizan_> what type would you give to "State (f v)" ?
19:43:03 * Saizan_ feels like a typechecker
19:43:48 <mike8901> sorry, I didn't mean for that last State to be there
19:43:56 <mike8901> (State x) >>= f = State(\s -> let (v, s') = (x s) in (f v) s'  )
19:44:28 <ivanm> dobblego: what are we not telling the scala guys?
19:44:42 <Saizan_> mike8901: though (f v :: State s b), you can't directly apply that to s', since State s b is not a function type
19:45:01 <dobblego> about determining function's from types and how life can be made easier (say out loud: () has infinite inhabitants)
19:47:37 <sjanssen> dobblego: huh?  Are you talking about Haskell with that "infinite inhabitants" statement?
19:48:00 <dobblego> sjanssen, I am just taking the piss over a very stupid mailing list thread
19:48:53 <ivanm> dobblego: heh
19:49:14 <mike8901> Saizan: so, do I create a lambda or something?
19:50:27 <Saizan_> mike8901: well, no, recall that data State s a = State (s -> (a,s)), so (f v) does contain a function in it, but you've to unpack the State constructor to get at it
19:51:15 <sproingie> was i the only one confused about State being the type and constructor?
19:51:24 <mike8901> nope
19:51:40 <Saizan_> yeah, that's quite confusing at first
19:52:01 <sproingie> especially since the type is parameterized on two variables, and the constructor takes just one value it gets both types from
19:52:22 <copumpkin> oh, the triples described in TTT are monads
19:52:37 <sproingie> seems a bit easier if you think in terms of State SomeType a
19:52:43 <Saizan_> though they really belong to different levels, so once you're more familiar with the type system it doesn't matter
19:52:53 <sproingie> like the obligatory State StdGen a
19:53:14 <sproingie> Saizan_: once you're familiar with the type system, State is no longer confusing :)
19:53:35 <Saizan_> yeah, 's' is fixed during the monadic operations
19:53:38 <mike8901> so do I do something like (State x) >>= f = State (\s -> let (v,s') = (x s) in let (v',s'') = (f v) in v' s' or something?
19:53:45 <mike8901> I'm really lost
19:53:57 <Saizan_> f v is not a tuple :)
19:54:13 <mike8901> too much scheme ;)
19:54:17 <sproingie> State's >>= is hard for me to remember off the top of my head
19:54:27 <sproingie> the exact implementation that is
19:54:33 <copumpkin> it's figure-outable
19:54:39 <sproingie> oh sure
19:54:46 <Saizan_> (State x) >>= f = State (\s -> let (v,s') = (x s); State f' = (f v) in f' s')
19:54:57 <Saizan_> that's it :)
19:55:08 <copumpkin> djinn should be able to figure it out
19:55:10 <mike8901> what's with the semicolon?
19:55:27 <c_wraith> it's separating two declarations in the let ... in
19:55:50 <Saizan_> you'd generally put those two on different lines, outside of irc
19:56:14 <Saizan_> or, you'd define runState (State f) = f
19:56:16 <Saizan_> and then write
19:56:38 <Saizan_> (State x) >>= f = State (\s -> let (v,s') = (x s) in runState (f v) s')
19:57:31 <copumpkin> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
19:57:32 <lambdabot> f a b c =
19:57:32 <lambdabot>     case a c of
19:57:32 <lambdabot>     (d, e) -> b d e
19:57:43 <monochrom> hehe
19:57:56 <copumpkin> so easy a bot can do it
19:58:00 <Saizan_> :)
19:58:23 <sproingie> runState is usually defined as a record label
19:58:56 <sproingie> State s a = { runState :: s -> (a,s) }
19:59:06 <sproingie> whoops forgot a State
19:59:09 <Axman6> s/ = / = State/
19:59:18 <sproingie> State s a = State { runState :: s -> (a,s) }
19:59:27 <Saizan_> (there are lots of exercises newbies struggle with that djinn solves, i've always found that cruel)
19:59:38 <copumpkin> lol
19:59:45 <copumpkin> you have to learn to think like a djinn
19:59:55 <copumpkin> (I'm not kidding)
19:59:59 <sproingie> cosmic powers!
20:00:04 <sproingie> itty bitty living space
20:02:21 <monochrom> It is cruel to people who believe that those exercises require "creativity", "understanding", all that over-glorified self-gratifying jazz.
20:02:37 <Gracenotes> I think function-based monads are best understood without newtypes. at least at first
20:03:37 <Gracenotes> for me, anyway, when I was learning State, runState confused the hell out of me. The concept that it transformed a state into a function which was applied... I was like, 'wtf' :o
20:04:19 <sproingie> it's pretty simple when you realize it's just unwrapping the function value
20:04:27 <Gracenotes> when really, State is fundamentally a function, a computation. the container interpretation is not helpful here at all
20:04:47 <sproingie> i think the biggest hurdle is realizing State doesn't encapsulate (value,state) pairs, it encapsulates a *function* from state -> (value,state)
20:05:02 <sproingie> i don't think tutorials adequately, uh, state that
20:05:09 <monochrom> haha
20:05:15 <c_wraith> I didn't fully grasp that until this weekend.
20:05:20 <c_wraith> Suddenly everything made sense
20:05:35 <sproingie> yeah you're gluing together functions that alter state.  functional language after all
20:05:45 <copumpkin> c_wraith: did you get "creativity", "understanding", or some of that over-glorified self-gratifying jazz?
20:05:51 <sproingie> s/alter/act on/
20:05:57 <Gracenotes> another misconception: if you're wondering why there is no value coming *in*, that's because it comes in from the outside environment
20:06:09 <sproingie> right, you need to give it an initial state somewhere
20:06:12 <Gracenotes> the lexical context.
20:06:22 <c_wraith> copumpkin:  nope.  I just understood suddenly how a "value" could depend on its context.
20:06:29 <sproingie> then it's >>= that takes care of handing it around
20:06:43 <c_wraith> answer:  the value is a function!
20:06:58 <c_wraith> (and the context is the argument to the function)
20:07:38 <copumpkin> you can also get djinn to write join for State
20:07:59 <sproingie> i suspect djinn is smarter than i am
20:08:59 <copumpkin> you need to learn to think like djinn!
20:09:07 <copumpkin> be a proof hunter!
20:09:39 <sproingie> crikey, there's a wily one
20:09:43 <kmc> it's like a safari to find a value with the right type!
20:09:54 <copumpkin> totally
20:09:54 <kmc> http://www.smbc-comics.com/index.php?db=comics&id=1701
20:09:57 <monochrom> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm  is a good tutorial
20:10:17 <kmc> "New: Updated to Haskell '98."
20:11:03 <copumpkin> wow
20:11:19 <sproingie> i don't care for that one because it's using ST for a constructor, and that confuses all hell out of people when they hear about ST
20:11:26 <sproingie> which *also* has to do with state
20:11:55 <monochrom> But I think you like "StateTrans".
20:12:00 <c_wraith> ST is special magical state. :)
20:12:04 <sproingie> i do, yah
20:12:12 <copumpkin> state thread
20:12:18 <sproingie> tho they use StateTrans as the type name
20:12:29 <sproingie> for a tutorial it's probably more helpful that they have different names
20:13:00 <sproingie> maybe just Trans
20:39:56 <Dreamer3> http://blog.pastie.org/2009/11/pastie-learns-erlang-lua-io-haskell-lisp-and-more.html
20:44:24 <mike8901> Is there a good built-in way of developing basic test cases in haskell?
20:44:53 <c_wraith> mike8901: QuickCheck isn't exactly built in, but it's probably what you want
20:45:14 <mike8901> Is it included with most Haskell distributions?
20:45:15 <c_wraith> mike8901: It's easy to install, if you have cabal working
20:46:14 <mike8901> I'm looking for a quick-n-dirty way of getting tests working...
20:46:22 <szr> hi. I'm trying to build ghc-6.10.4 on a GNU/Linux from the source tarball (ghc-6.10.4-src.tar.bz2 + extralibs tarball) and one of the prereqs is having ghc already (which in a case like this is a little horse-before-the-cart)
20:46:33 <mike8901> Is there not really anything built in for that?
20:46:52 <c_wraith> szr:  use the binary distribution.  bootstrapping ghc is a nightmare
20:46:53 <szr> I'd appreciate any pointers on how to build it directly without a ghc alread on the system
20:47:25 <szr> c_wraith: yeah I'd like to avoid bootstrapping; I just want to build it straight like most other compilers (ie, Perl)'
20:48:24 <copumpkin> mike8901: yes, there really is not anything built in, depending what you mean by built in
20:48:25 <szr> I'm surprised you need ghc in order ot build it (again, it is rather horse-before-the-cart); why is it one just cannot ./configure and make it?
20:48:38 <c_wraith> szr:  because much of it is written in haskell
20:48:39 <copumpkin> mike8901: you could just install the haskell platform and have everything you need
20:48:47 <mike8901> copumpkin: I basically want to put a list of function calls and their outputs
20:48:54 <copumpkin> mike8901: but really, cabal-install is easy as pie
20:48:57 <c_wraith> szr:  it's more like guilding gcc than building perl
20:49:02 <mike8901> the thing is, I need to give this to someone else
20:49:02 <c_wraith> *building
20:49:04 <copumpkin> mike8901: why not just write properties?
20:49:09 <mike8901> properties?
20:49:13 <copumpkin> mike8901: they should use haskell platform anyway
20:49:25 <copumpkin> mike8901: x + (y + z) == (x + y) + z
20:49:37 <szr> c_wraith: I've never installed haskell before but I have build gcc (and scratch Linux systems) before so I know how that is
20:49:38 <copumpkin> why should you waste time thinking up specific examples when you have a property in mind?
20:49:56 <mike8901> compumpkin: How would I specify a bunch of those in a .hs file though, and know which failed, and be able to call them all with 1 command?
20:50:13 <copumpkin> read up on quickcheck
20:51:06 <mike8901> http://www.quick-chek.com/ comes up first on the Google results for quickcheck ;)
20:51:39 <c_wraith> szr:  The compiler is self-hosting.  you only really have 3 choices, to use ghc:  use a binary distro, compile from an older version, or manage the nightmare of bootstrapping.  The binary distro really is fine.
20:51:58 <ivanm> mike8901: :o
20:52:01 <ivanm> @hoogle quickcheck
20:52:02 <lambdabot> package QuickCheck
20:52:02 <lambdabot> module Debug.QuickCheck
20:52:02 <lambdabot> module Test.QuickCheck
20:52:03 <kmc> that's assuming (though it's probably true) that no other haskell compiler can compile GHC
20:52:03 <ivanm> @google quickcheck
20:52:04 <ivanm> bah
20:52:05 <lambdabot> http://www.quick-chek.com/
20:52:05 <lambdabot> Title: Quick Chek
20:52:07 <kmc> and that no haskell interpreter can interpret GHC
20:52:09 <ivanm> it does too...
20:52:29 <copumpkin> @google quickcheck haskell
20:52:31 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
20:52:32 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
20:52:39 <kmc> @where quickcheck
20:52:40 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
20:52:51 <kmc> anyway yes, you should be using Haskell Platform.  that's the useful definition of "built in"
20:53:06 <szr> c_wraith: can I just temporarily get the binary and then build the source (so that I can tinker around) ?
20:53:26 <c_wraith> szr: sure
20:54:21 <c_wraith> the generic binary distribution uses ./configure still...  it just skips the make step
20:54:34 <szr> ah
20:54:37 <c_wraith> err, generic *linux* binary distribution
20:54:45 <szr> yeah
20:58:45 <maurer_1> Does anyone know if there are some massive caveats when using hmatrix?
20:59:11 <maurer_1> I wrote a fairly short program, and 90% of runtime is spent converting the text input to the matrix, this taking a full minute
21:00:15 <maurer_1> (I'm trying to write a number of programs that need to be performance efficient, and am trying to make sure that I've got the kinks worked out on smaller code first)
21:00:54 <maurer_1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12358#a12358 has the code. It's a simple least squares line fit to the provided data.
21:01:03 <Raynes> @pl \x y -> f x : y
21:01:03 <lambdabot> (:) . f
21:01:40 <maurer_1> 90% of time is spent in readMatrix, which confuses me. Re-implementing readMatrix by hand doesn't really do any better.
21:02:09 <kmc> @hoogle readMatrix
21:02:10 <lambdabot> No results found
21:03:15 <zrilak> Hi people, I could use some help; I am completely new to Haskell.
21:03:21 <zrilak> Trying to install xmobar, i get this:
21:03:47 <kmc> maurer_1, did you try isolating the read, as in:  (readMatrix <$> readFile) >>= (`seq` return ())
21:04:17 <maurer_1> Nope, let me give that a shot.
21:04:25 <zrilak> http://pastie.org/705473
21:04:42 <kmc> zrilak, are you using the Haskell Platform?
21:04:51 <kmc> where did you get your haskell compiler from?
21:04:55 <ivanm> zrilak: use cabal-install
21:04:59 <kmc> (assuming you're using one)
21:05:15 <kmc> zrilak, the easiest way is to install the Platform: http://hackage.haskell.org/platform/
21:05:31 <kmc> that will also give you this "cabal" command, which can be used, e.g. "cabal install xmobar"
21:05:45 <zrilak> kmc: that'll pull all the dependencies?
21:05:48 <kmc> yes
21:05:52 <zrilak> cabal installer, I see
21:05:58 <kmc> all of the Haskell-specific dependencies
21:06:03 <zrilak> okay, I just have the ghc and hand-installed Cabal so far
21:06:09 <zrilak> thanks!
21:06:17 <kmc> sometimes a Haskell package will depend on a system library in C or so, in which case you'd install that through your usual package manager first
21:06:33 <zrilak> that's what I tried with xft, but the other dependencies are unknown to me.
21:07:58 <maurer_1> zrilak: The .cabal file for the package will have a list of the external libraries in it (or it should if it's not a really weird package)
21:08:11 <kmc> maurer_1, actually IO's (>>=) is strict so what i said is overkill
21:08:58 <maurer_1> Oh, so you are just trying to make sure that it strictly transforms the string into a matrix?
21:09:03 <zrilak> thanks a lot!
21:09:26 <kmc> i'm interested in the time it takes to read the matrix and fully evaluate the parsing, then throw it out and quit
21:09:32 <maurer_1> OK
21:09:35 <kmc> should tell you if the speed problem is really in readMatrix
21:09:38 <maurer_1> Lemme see if the matrix has a show function
21:10:09 <szr> c_wraith: ok, trying to build the binary (i386-unknown-linux-n) and make is failing with "installPackage: timer_create: Operation not supported", do you know what that means?
21:10:18 <kmc> readMatrix is implemented using String and Prelude list/string operations, which is dubious.  perhaps you can do better with ByteString
21:10:41 <c_wraith> szr: I haven't seen that before.  What linunx are you running on?
21:10:58 <c_wraith> ...  we'll just pretend my horrible typos don't exist
21:11:30 <copumpkin> not me
21:11:38 * copumpkin stares intently at c_wraith's abominable typos
21:11:53 <Veinor> Is a linunx like a quincunx?
21:12:04 <c_wraith> at least your not staring at my abdominal typos
21:12:05 <Veinor> (that's an incredibly obscure word)
21:12:09 <szr> c_wraith: GNU/Linux i686 (i686-pc-linux-gnu)
21:12:12 <saccade_> c_wraith: ow
21:12:31 <c_wraith> quincux is less obscure since nvidia popularized it as an AA mode
21:12:42 <copumpkin> quincunx?
21:12:48 <gnut> hi all
21:12:48 <c_wraith> szr:  custom built?
21:13:00 <c_wraith> yes, copumpkin.  it was a 5x oversampling mode
21:13:11 <copumpkin> c_wraith: nah, just pointing out another abominable typo ;)
21:13:21 <szr> this box was originally a rh9 box that's been pretty heavily modified but nothing too radical core lib wise
21:13:29 <c_wraith> man, I can't even see my typos
21:14:18 <c_wraith> And...  szr, I have no idea.  maybe search the ghc trac for that error message?
21:14:29 <gnut> How would I define mzero for an instance of MonadPlus IO without using fail? If I use return (), it complains that IO () is not IO a.
21:14:30 <ivanm> how come even if I have "default (Int)", I'm geting integral values defaulting to Integer?
21:15:12 <gnut> I just want mzero to print a string on screen
21:15:35 <ivanm> gnut: there's no general way of doing so
21:15:44 <ivanm> unless you use something like Maybe or Either
21:16:05 <gnut> ivanm: okay. thanks.
21:16:50 <c_wraith> actually, I think nvidia's quincux did some sort of sample sharing between adjacent pixels
21:17:42 <mathijsB> hmhh
21:18:00 <mathijsB> im a little haskell-confused, I have an integer thats an argument to a function
21:18:14 <mathijsB> first I want to convert it to string, then i want to do some other operations on it in the function
21:18:24 <kmc> @unmtl ContT r (State s) a
21:18:25 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
21:18:27 <mathijsB> should I do that using a let clause ?
21:18:47 <kmc> @unmtl StateT s (Cont r) a
21:18:47 <lambdabot> s -> (a -> s -> r) -> r
21:19:00 <mathijsB> i actually want to use the converted string recursivly in the same function
21:19:12 <kmc> mathijsB, that'd be a fine way to do it
21:20:29 <mathijsB> oki, ty
21:21:02 <szr> c_wraith: I'm going to try the linux instead of linux-n binary package
21:21:10 <szr> not sure what the difference is though
21:21:48 <ivanm> does anyone know how to change ghci's defaulting rules? I want it to default to Int, not Integer...
21:24:15 <kmc> aww i can't have mutually recursive type synonyms :/
21:24:32 <copumpkin> nope
21:27:05 <ddarius> No more than you can have recursive type synonyms.
21:32:28 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:32:28 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
21:32:28 --- names: list (clog_ Raynes- portnov nvoorhies octal blackdog JohnnyL gnut mmaruseacph2 halcyon10 caligula_ moconnor Pthing zrilak maurer_1 k3ph Khisanth sdelic path__ szr kniu Dreamer3 gogonkt_ Stefan Cthulhon ablokzijl otto_s travisbrady mm_freak mwc Keiya shrughes gwern adlan Cromulent ritek Alpounet luqui mun trie eno roconnor khorne Saizan_ saccade_ angelixd PsiOmega c_wraith Lycurgus preflex bryno mauke Beelsebob kpreid cycloid juhp gbeshers_home)
21:32:28 --- names: list (krainbolt triplez david__ Rotaerk aluink oskimura_ meanburrito920_ whoppix Draconx mxc torbenh3 fracture cloudhead zakwilson Cobra| jimmyjazz14 Chile tensorpudding Adamant Smokey` kyagrd O_4 dolio mercury^ blackh ChilliX ivanm vili LitesterB romanandreg SyntaxNinja ErrantEgo gbeshers ttmrichter koeien Zeiris ddarius fc1 gnuvince jan___ gjl ksandstr_ sigh rdd` mathijsB fhs Raynes Igloo crem Gracenotes noteventime johnw dave__ LouisJB1 nazgjunk)
21:32:28 --- names: list (ggreg_ Modius arvidj Pewpewarrows leimy kmc niksnut nathanic_work jre2 monochrom copumpkin Asztal trofi Mr_Awesome StarFire sprang Whitesquall1 sm dancor Aikawa ray Trafalgard hgolden FunctorSalad rgr mattrepl samulihs joga flux im_macie1 Philonous Mortomes dayz mmorrow bbee levitation[A] jims elanonimo orbitz red-agent mexisme stepnem Kambus m0nkfish hs12 booxter hiredman danopia Badger tuukkah kayess_ smelk DrSyzygy JaffaCake epokal avysk)
21:32:28 --- names: list (taruti pem BgPerl-VB14 SamB_XP gOcOOl bran profmakx Boney allbery_b rapacity netcat sebas_ stoop dfeuer ski cgibreak djinni hackagebot olsner tltstc SeaPrior det clanehin Nafai Vulpyne dcolish mjv jfredett Megant karld mrd BONUS erg magicman thomastc mshaw ps-auxw dumael qm13 mattam sproingie stroan _br_ DRMacIver gdsx BrianHV Zao ac jnwhiteh t nimred tew88 Neronus franksh tumult harlekin Stephan202 ben0x539 drbean lavish nornagon peddie)
21:32:28 --- names: list (Paradox924X tkr loop glitch anders^^ fritschy electrogeek soduko pantsd_pcf r0bby Gabbie chrisdone ned dreixel m-i-l-a-n koala_man rasfar lomeo StoneToad kfish fihi09`` thorkilnaur_ jorizma nathanic erk And[y] BMeph Reisen aep bwr kynky augur wm_eddie alexsuraci jelly12gen Polarina fredcy EnglishGent^afk voker57_ sioraiocht Kim^Walkman mreggen tmatix idnar mahogny +lambdabot Esmil EvilTerran +lunabot lefant cdfh dobblego EvanCarroll gbacon)
21:32:28 --- names: list (paulvdw CalJohn sohum onodrim noj nnunley Exteris alpheccar arjanoosting lsthemes flori ehamberg osfameron guerrilla sevvie mikste jasonmay cygnus_ aavogt p_l Blaketh cjay Gilly thetallguy1 Twigathy icee zaarg absentia dqd laz0r tarbo_ marmolak Ferdirand Warrigal Valodim birkenfeld nominolo|uni Baughn poe thedward companion_square authentic jql anekos mmmdonuts malouin qed desu kar-1 mlh droidcore SubStack jfoutz int-e dogmaT kakeman suiside)
21:32:28 --- names: list (mikm Paks webframp alexander2 wagle_home da-xw sebbe1991 GNU\colossus _plcs_ impl mornfall prigaux aleator mmmulani ahihi anji_ saiam nasloc__ sunnavy dek5 ido lanaer wdonnelly jvogel_ poucet Aisling danderson Nanar fxr Milo- shepheb integral wormwood shachaf shortcircuit mokus_ mux theclaw mml`_ bd_ beibmozoi bockmabe_ desp endojelly inimino PHO_ davidL dcoutts_ tromp_ __marius__ saccade reltuk sjanssen nipuL Nereid AnMaster glith MyCatVerbs)
21:32:28 --- names: list (eek jontore Optimo trez jamwt clarkb tessier loupgaroublond alexbobp jaj pixel5 ve burp jix linkinus TML baaba jtra ijnek eyck Eelis m4thrick Jedai Raku^ lhnz jbauman Veinor Tomas deavid heaumer_ LeoD wharrgarble flippo ToRA bind_return xinming araujo sieni eelco_ Lemmih wolverian Liskni_si rey_ Twey Jaak tilman nablaa SimonRC Heffalump geoaxis_ dino- snhmib deiga_ emias pcc1 tamiko drspider_ ^Einstein ath Tobsan andun jlaire igorgue kalven)
21:32:28 --- names: list (Jiten byorgey MacCoaster jlouis fnordus ertai newsham smg dmwit spoop Axman6 ahf jml _Jordan_ dilinger tmug Counter-Strike Annie|Home joed kw317 zygoloid Poeir sbok edwtjo sereven pikhq neurocyte felipe_ PeakerWork dixiecko DEVOKUN wimt McManiaC stepcut pifish_ dons hsaliak__ M| andrewsw zax luite tavelram yahooooo kolmodin wagle kadoban lament TR2N emma willb jayne a-s mcclurmc donri kosmikus smiler Arnar jrockway scree Hunner LeCamarade)
21:32:28 --- names: list (Spaghettini amgarching guerby ystael Spockz awarring jmcarthur Kapowski jleedev sunfun shapr Colours_ shellsage CodeBlock clog ville jonafan srcerer nwf koninkje_away FauxFaux dionoea arkx BONUS_ wang inclement pragma_ greap skaar jvoorhis agemo aiko sgf Elly cods quicksilver Ornedan_ xian qeb`away _kuningas Innominate jystic ibid ath^_ stalker_ Raevel_ Bassetts wisemanby Bleadof kmeyer nlogax Deewiant epmf_ borism_ nothingmuch geir_ majoh)
21:32:28 --- names: list (boyscared Taggnostr equanimity Laney venkatg canvon cathper thoughtpolice opqdonut drhodes Sisu ziman noddy Botje AndyP thingwath mdordal2 Vq liff brx midnite Blub\0 mw493 mjrosenb aempirei matthew-_ hellige daed welterde pettter_ qwr alip mike8901 jabagawee dcoutts da-x mfoemmel mfp Cale ezrakilty periodic jones- regulate @ChanServ)
21:33:51 <copumpkin> numerology :o http://www.tac.mta.ca/tac/volumes/16/19/16-19.pdf
21:34:11 <maurer_1> kmc: Do you really think I would get a substantial speedup by rewriting the builtin readMatrix function to use ByteString?
21:34:27 <copumpkin> yeah, especially if you don't use human-readable text
21:34:34 <copumpkin> and don't actually deal with parsing
21:35:02 <kmc> maurer_1, i honestly have no idea
21:35:33 <kmc> copumpkin's right, it'd be much better to pre-mangle your matrix into contiguous doubles
21:36:02 <kmc> which you could read very quickly and then convert with matrixFromMArray or similar
21:36:10 <maurer_1> kmc, copumpkin: While that would be nice, that just helps for revising the code (as I can convert the data files to a nicer packed format), it doesn't really help performance if someone just gives me a datafile
21:36:31 <copumpkin> you'll still be a lot faster using bytestring
21:36:36 <copumpkin> string is a list
21:36:39 <maurer_1> OK, I'll give it a shot and see what happens.
21:36:40 <copumpkin> you get no locality
21:41:05 <mathijsB> http://pastie.org/705496
21:41:14 <mathijsB> anyone could give me a hint on whats wrong with that?
21:41:22 <mathijsB> im getting a parser error on the second '=' in the let statement.
21:41:54 <maurer_1> copumpkin: Hm. That's rather annoying. I suppose I'll take the "special binary matrix format" approach.
21:44:21 <mathijsB> pattern matching on functions is not allowe in a let clause?
21:44:30 <mathijsB> *allowed
21:45:48 <mathijsB> oh well, nm, adding a newline made it compile, i shall re-read the haskell introduction chapter on formatting :)
21:47:17 <mtnviewmark> anyone here familiar with using the binary package?
21:47:27 <copumpkin> more or less
21:47:47 <mtnviewmark> is there anyway to have it deail with failure gracefully?
21:48:10 <mtnviewmark> like, I'm parsing binary date from in over the  wire, and perhaps it doesn't parse.....
21:48:24 <mtnviewmark> near as I can tell fail = error
21:48:35 <copumpkin> oh, I think that's a common complaint
21:48:38 <copumpkin> and I don't think so :/
21:49:16 <c_wraith> Just use binary with instances where all input is legal. >_>
21:49:22 <mtnviewmark> fie! since writing my own little ByteStream parsing monad, while it was fun, I don't think it is anywhere near as efficient as that one
21:49:29 <copumpkin> fie indeed!
21:49:49 <copumpkin> this calls for a petition!
21:49:57 <mtnviewmark> I was hoping there was some head-explosing way to combine PUT with some monad-transformer
21:50:02 <ddarius> If you are not using Get instances, you can just encode the error in the output or equivalently use an error monad transformer.
21:50:28 <Gracenotes> monads are nice for pretty do block notation
21:50:53 <mtnviewmark> I really don't want to encode the error in the parsed thing ---
21:51:07 <mtnviewmark> I want the parse to return an Either String Thing
21:51:25 <ddarius> mtnviewmark: That would be one way of encoding the error in the output.
21:51:26 <mtnviewmark> and was hoping that point of a parser-liker monad was that it would "do the right thing" with errors
21:52:03 <mtnviewmark> ddarius - but then I have to do error checking myself at every step - rather than have the monad handle it
21:52:48 <ddarius> mtnviewmark: If you mean you need to propagate the error case, then that's what using a monad transformer would give you which is equivalent as I said.
21:53:07 <mtnviewmark> will the error monad transformer work stacked up on a monad not from the mtl package work?
21:53:08 <ddarius> mtnviewmark: If you mean you need to do something like "if is malformed then throw error", well, you need to do that regardless.
21:53:13 <mtnviewmark> (has never used monad transformers)
21:53:36 <ddarius> Monad transformers work over any monad (as the type of the operations say)
21:53:54 <mtnviewmark> ddarius - well, if you call "get :: Word32" and there are only 3 bytes left, Binary is going to call error for me "thanks, Binary!"
21:54:36 <mtnviewmark> I suppose the qeustion was will the monad transformer mange to "transform" that behavior
21:54:45 <ddarius> mtnviewmark: So you'll need to write some of your own primitives that do do error checking in that sense (hence the caveat about Get instances at the beginning)
21:55:03 <c_wraith> You do have to watch for package incompatbilities.  You won't necessarily be able to use a monad transformer from transformers with a monad from mtl, because of incompatibilities between the two packages.
21:55:11 <ddarius> @unmtl ErrorT e Get a
21:55:11 <lambdabot> Get (Either e a)
21:57:31 <ivanm> is there a Double -> Double version of round?
21:57:37 <Veinor> what would it do?
21:57:43 <ivanm> or is it just fromIntegral . round ?
21:57:45 <ddarius> fromIntegral . round
21:57:52 <Veinor> ah, yeah
22:01:21 <maurer_1> kmc: In case you run into this problem, or anyone is reading this chat log, while readMatrix sucks, fromFile appears deadly efficient. I'm now testing it situationally, but in terms of just loading a matrix it seems to be about 15 times faster, as expected.
22:16:59 <mtnviewmark> okay  - so after much digging around the source, there seems to be no way to use Binary and Get to read w/o the possibility of error being called: Most of the lovely Binary instances are written in terms of things like getWord32be, which just call 'error' if there aren't enough bytes
22:17:07 <kmc> :t callCC
22:17:07 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
22:17:21 <copumpkin> mtnviewmark: frustrating, eh :/
22:17:45 <mtnviewmark> yes, because it is clear that binary has gone to great lengths to be very efficient
22:17:50 <kmc> i feel like it should be more like callCC :: (stuff) => ((forall b. a -> m b) -> m a) -> m a
22:17:53 <kmc> is that crazy?
22:18:07 <mtnviewmark> and I'm sure my own home-brewed thing is probably horribly slow
22:18:21 <copumpkin> http://comonad.com/reader/2008/kan-extensions/
22:20:12 <kmc> copumpkin, interesting
22:23:43 <kmc> i'm not really sure how to incorporate any of that into what i'm doing
22:24:52 <kmc> would it be reasonable to move the quantifier in on callCC, or would that actually not express the type of callCC properly?
22:25:13 <kmc> (of the conceptual callCC, i mean... i know they're not the same types)
22:25:36 <dolio> ((a -> forall b. m b) -> m a) -> m a is fine.
22:25:52 <dolio> But that requires higher-rank types, obviously.
22:25:55 <copumpkin> kmc: what do you envision in the (stuff)?
22:26:12 <kmc> same as above
22:26:23 <kmc> forall a (m :: * -> *). (MonadCont m)
22:26:26 <copumpkin> ah ok
22:26:58 <kmc> dolio, and it's not implausible that some valid continuation-passing code would work with the higher-rank callCC but not the actual mtl one?
22:27:07 <kmc> 'cause i feel like i've hit such a case
22:27:15 <dolio> That lets you call the continuation in situations where you'd need different result types, which is fine, since it's not actually giving you one.
22:27:53 <kmc> perhaps there is a more high-tech continuation monad somewhere?
22:28:39 <dolio> You could bug the mtl/transformers people, I guess.
22:29:05 <dolio> Well, not transformers, since they're trying to be H98 compatible.
22:29:23 <dolio> But you could use the higher-rank type in monads-tf/fd.
22:33:14 <shrughes> A general question: if you were to write a non-trivial web-app in Haskell, what would you use?  Sorry for the vague term "non-trivial" -- i'll let you assume what it means
22:33:57 <kmc> perhaps happstack
22:34:01 <shrughes> You know what, that's a terrible question, probably induced by sleep deprivation, so never mind.
22:34:34 <kmc> dolio, it seems callCC in monads-tf / monads-fd is still insufficiently polymorphic :/
22:41:04 <jpet> I got some help here debugging a stack overflow yesterday... finally found it today.
22:41:54 <jpet> ghc will overflow on this:
22:42:02 <jpet> hmm :: [Integer]
22:42:13 <jpet> hmm = filter (\n -> (n .&. (n-1))==0) [1..]
22:42:25 <jpet> main = mapM_ print hmm
22:42:54 <jpet> (The filter there just picks powers of two, so I'm filtering out increasingly long subsequences.)
22:42:55 <Axman6> that's testing for powers of two right?
22:43:12 <jpet> If 'hmm' is let-bound it doesn't overflow.
22:43:34 <Axman6> probably gets better inlined
22:43:44 <jpet> Is that a ghc bug or am I crazy?
22:44:16 <ivanm> hey Axman6
22:44:42 <Axman6> o/
22:46:24 <jpet> Axman: even with -O0 it overflows with top-level 'hmm', and doesn't overflow with let-bound, so I'm not sure if the difference is inlining.
22:46:59 <copumpkin> see what differs in the generated core?
22:47:08 <Axman6> why are you using -O0?
22:47:24 <jpet> Axman: I just tried -O0 to see if the optimizer made a difference.
22:48:40 <jpet> ...also, [Integer] overflows (at smaller-than-32-bit values) but [Int] does not.
22:50:03 <jpet> How do I view the generated core?
22:50:17 <jpet> (Should just google that I suppose)
22:51:38 <ivanm> gah, I keep getting bitten by doing something like: foo `onFail` bar $ baz, where I should be putting parens around the last line
22:51:54 <ivanm> just spent 10 minutes before I worked out what the error meant :@
22:55:17 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
22:55:17 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
22:55:17 --- names: list (clog_ njbartlett novas0x2a kmc PhilRod ritek jpet maurer_ Gwern-away Dessous ned- sayyestolife lazni kayess blackh hiredman shintah sm SmurfOR ablokzijl akappa Sup3rkiddo necrobious ski_ zrilak mtnviewmark mm_freak horms clog Raynes- portnov nvoorhies octal blackdog JohnnyL mmaruseacph2 halcyon10 caligula_ Pthing Khisanth sdelic path__ szr Dreamer3 gogonkt_ Stefan Cthulhon otto_s mwc shrughes Alpounet luqui mun trie eno khorne Saizan_ saccade_)
22:55:17 --- names: list (angelixd PsiOmega c_wraith Lycurgus preflex bryno mauke Beelsebob kpreid juhp gbeshers_home krainbolt triplez david__ Rotaerk aluink oskimura_ meanburrito920_ whoppix Draconx torbenh3 fracture zakwilson Cobra| Chile tensorpudding Adamant Smokey` kyagrd O_4 dolio mercury^ ChilliX ivanm vili romanandreg SyntaxNinja ErrantEgo gbeshers ttmrichter koeien Zeiris fc1 gnuvince jan___ gjl ksandstr_ rdd` fhs Igloo crem Gracenotes noteventime johnw)
22:55:17 --- names: list (dave__ LouisJB1 nazgjunk ggreg_ Modius arvidj Pewpewarrows leimy niksnut nathanic_work jre2 monochrom copumpkin Asztal Mr_Awesome StarFire sprang Whitesquall1 dancor Aikawa ray Trafalgard hgolden FunctorSalad rgr samulihs joga flux im_macie1 Philonous Mortomes dayz bbee levitation[A] jims elanonimo orbitz red-agent mexisme stepnem Kambus m0nkfish hs12 booxter danopia Badger tuukkah smelk DrSyzygy JaffaCake epokal avysk taruti pem BgPerl-VB14)
22:55:17 --- names: list (SamB_XP gOcOOl bran profmakx Boney allbery_b rapacity netcat sebas_ stoop dfeuer ski cgibreak djinni hackagebot olsner tltstc SeaPrior det clanehin Nafai Vulpyne dcolish mjv jfredett Megant karld mrd BONUS erg magicman thomastc mshaw ps-auxw dumael qm13 mattam sproingie stroan _br_ DRMacIver gdsx BrianHV Zao ac jnwhiteh t nimred tew88 Neronus franksh tumult harlekin Stephan202 drbean ben0x539 lavish nornagon peddie Paradox924X tkr loop glitch)
22:55:17 --- names: list (anders^^ fritschy electrogeek soduko pantsd_pcf r0bby Gabbie chrisdone dreixel m-i-l-a-n koala_man rasfar lomeo StoneToad kfish fihi09`` thorkilnaur_ jorizma nathanic erk And[y] BMeph Reisen aep bwr kynky augur wm_eddie alexsuraci jelly12gen Polarina fredcy EnglishGent^afk voker57_ sioraiocht Kim^Walkman mreggen tmatix idnar mahogny +lambdabot Esmil EvilTerran +lunabot lefant cdfh dobblego EvanCarroll gbacon paulvdw CalJohn sohum onodrim)
22:55:17 --- names: list (noj nnunley Exteris alpheccar regulate jones- periodic ezrakilty Cale mfp mfoemmel da-x dcoutts jabagawee mike8901 alip qwr pettter_ welterde daed hellige matthew-_ mjrosenb aempirei mw493 Blub\0 midnite brx liff Vq mdordal2 thingwath AndyP Botje noddy ziman Sisu drhodes opqdonut thoughtpolice cathper canvon venkatg Laney equanimity Taggnostr boyscared majoh geir_ nothingmuch borism_ epmf_ Deewiant nlogax kmeyer Bleadof wisemanby Bassetts)
22:55:17 --- names: list (Raevel_ stalker_ ath^_ ibid jystic Innominate _kuningas qeb`away xian Ornedan_ quicksilver cods Elly sgf aiko agemo jvoorhis skaar greap pragma_ inclement wang BONUS_ arkx dionoea FauxFaux koninkje_away nwf srcerer jonafan ville CodeBlock shellsage Colours_ shapr sunfun jleedev Kapowski jmcarthur awarring Spockz ystael guerby amgarching Spaghettini LeCamarade @ChanServ Hunner scree jrockway Arnar smiler kosmikus donri mcclurmc a-s jayne willb)
22:55:17 --- names: list (emma TR2N lament kadoban wagle kolmodin yahooooo tavelram luite zax andrewsw M| hsaliak__ dons pifish_ stepcut McManiaC wimt DEVOKUN dixiecko PeakerWork felipe_ neurocyte pikhq sereven edwtjo sbok Poeir zygoloid kw317 joed Annie|Home Counter-Strike tmug dilinger _Jordan_ jml ahf Axman6 spoop dmwit smg newsham ertai fnordus jlouis MacCoaster byorgey Jiten kalven igorgue jlaire andun Tobsan ath ^Einstein drspider_ tamiko pcc1 emias deiga_ snhmib)
22:55:17 --- names: list (dino- geoaxis_ Heffalump SimonRC nablaa tilman Jaak Twey rey_ Liskni_si wolverian Lemmih eelco_ sieni araujo xinming bind_return ToRA flippo wharrgarble LeoD heaumer_ deavid Tomas Veinor jbauman lhnz Raku^ Jedai m4thrick Eelis eyck ijnek jtra baaba TML linkinus jix burp ve pixel5 jaj alexbobp loupgaroublond tessier clarkb jamwt trez Optimo jontore eek MyCatVerbs glith AnMaster Nereid nipuL sjanssen reltuk saccade __marius__ tromp_ dcoutts_)
22:55:17 --- names: list (davidL PHO_ inimino endojelly desp bockmabe_ beibmozoi bd_ mml`_ theclaw mux mokus_ Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh p_l aavogt cygnus_ jasonmay mikste sevvie guerrilla osfameron ehamberg flori lsthemes arjanoosting poe thedward companion_square authentic shortcircuit shachaf wormwood integral shepheb Milo- fxr Nanar danderson Aisling)
22:55:17 --- names: list (poucet jvogel_ wdonnelly lanaer ido dek5 sunnavy nasloc__ saiam anji_ ahihi mmmulani prigaux mornfall impl _plcs_ GNU\colossus sebbe1991 da-xw wagle_home alexander2 webframp Paks mikm suiside kakeman dogmaT int-e jfoutz SubStack droidcore mlh kar-1 desu qed malouin mmmdonuts anekos jql)
22:57:14 <mwc> jpet: that certainly sounds like a compiler bug to me
22:57:23 <mwc> what version?
22:58:18 <jpet> 6.10.4
22:58:53 <jpet> Off-the-shelf Haskell Platform binaries
23:00:48 <jpet> Ok, after studying the generated core a bit, I can conclude that generated core is somewhat hard to follow.
23:02:31 <dobblego> where is the instance Applicative Gen in QC2?
23:03:34 <ivanm> preflex: seen Heffalump
23:03:36 <preflex>  Heffalump was last seen on #haskell 9 hours, 36 minutes and 46 seconds ago, saying: C++ is killed by weird interactions
23:07:45 <mwc> jpet: hehehe
23:08:04 <mwc> anyone else think that was quoteworthy?
23:08:29 <ivanm> mwc: eh, go ahead
23:08:53 <ivanm> what's that quote about you're never clever enough to debug your own code?
23:10:46 <mwc> @remember jpet Ok, after studying the generated core a bit, I can conclude that generated core is somewhat hard to follow.
23:10:46 <lambdabot> Okay.
23:11:03 <Elly> jpet: that made me giggle
23:11:29 <mtnviewmark> when I run a HUnit ttest, it prints:   <<loop>>
23:11:32 <mtnviewmark> what does that mean?
23:11:36 <mwc> jpet: if you're feeling keen, go download a 6.12 RC, see if the bug is still there. Mention it in your bug report
23:11:39 <ivanm> mtnviewmark: infinite loop
23:11:45 <ivanm> and that's GHC, not HUnit doing that
23:12:08 <mtnviewmark> hmmm... okay.... so GHC detected an inf. loop, eh? wonder how that crept in
23:13:24 <mtnviewmark> aside - can you assign "as" labels to modules when you use :m in ghci?
23:14:47 <Axman6> nope
23:17:46 <ivanm> there's a bug on it though
23:19:47 <Axman6> fark, it's too hot to go to SES training >_<
21:23:40 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:23:40 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
21:23:40 --- names: list (clog Athas SamB_XP takuan fasta ujihisa TR2N` Mowah jimmyjazz14 mm_freak_ np0w3r triplez spaceodyssey zakwilson dolio perspectival kayess galdor shambler simplicio hansfbaier medfly hackagebot iblechbot shag shintah| otsdr LitesterB knobo Elench path__ caligula__ QplQyer sigh solidsnack muri_one oskimura_ dblhelix novas0x2a1 m-i-l-a-1 kmc Gwern-away ned- sayyestolife blackh hiredman SmurfOR akappa Sup3rkiddo ski_ Raynes nvoorhies blackdog)
21:23:40 --- names: list (halcyon10 Pthing Khisanth szr gogonkt_ Stefan Cthulhon otto_s shrughes luqui mun trie eno khorne Saizan_ saccade_ angelixd PsiOmega c_wraith Lycurgus preflex bryno mauke Beelsebob kpreid juhp gbeshers_home krainbolt david__ Rotaerk aluink whoppix Draconx torbenh3 fracture Cobra| Chile tensorpudding Adamant Smokey` kyagrd O_4 mercury^ ChilliX ivanm vili romanandreg SyntaxNinja ErrantEgo gbeshers ttmrichter koeien fc1 gnuvince jan___ gjl)
21:23:40 --- names: list (ksandstr_ rdd` fhs Igloo crem Gracenotes johnw LouisJB1 nazgjunk ggreg_ Modius arvidj Pewpewarrows leimy niksnut nathanic_work jre2 monochrom copumpkin Asztal Mr_Awesome StarFire sprang dancor Aikawa ray Trafalgard hgolden FunctorSalad rgr samulihs joga flux im_macie1 Philonous Mortomes dayz bbee levitation[A] jims elanonimo orbitz red-agent mexisme stepnem Kambus m0nkfish booxter danopia Badger tuukkah smelk DrSyzygy JaffaCake epokal avysk)
21:23:40 --- names: list (taruti pem BgPerl-VB14 gOcOOl bran profmakx Boney allbery_b rapacity netcat sebas_ stoop dfeuer ski cgibreak djinni olsner tltstc SeaPrior det clanehin Nafai Vulpyne dcolish mjv jfredett Megant karld mrd BONUS erg magicman thomastc mshaw ps-auxw dumael qm13 mattam sproingie stroan _br_ DRMacIver gdsx BrianHV Zao ac jnwhiteh t nimred tew88 Neronus franksh tumult harlekin Stephan202 drbean ben0x539 lavish nornagon peddie Paradox924X tkr loop)
21:23:40 --- names: list (glitch anders^^ fritschy electrogeek soduko pantsd_pcf r0bby Gabbie chrisdone dreixel koala_man rasfar lomeo StoneToad kfish fihi09`` thorkilnaur_ jorizma nathanic erk And[y] BMeph Reisen aep bwr kynky augur wm_eddie alexsuraci jelly12gen Polarina fredcy EnglishGent^afk voker57_ sioraiocht Kim^Walkman mreggen tmatix idnar mahogny +lambdabot Esmil EvilTerran +lunabot lefant cdfh dobblego EvanCarroll gbacon paulvdw CalJohn sohum onodrim noj)
21:23:40 --- names: list (nnunley Exteris alpheccar regulate jones- periodic ezrakilty Cale mfp mfoemmel da-x dcoutts jabagawee mike8901 alip qwr pettter_ welterde daed hellige mjrosenb matthew-_ aempirei mw493 Blub\0 midnite brx liff Vq mdordal2 thingwath AndyP Botje ziman Sisu drhodes opqdonut thoughtpolice cathper canvon venkatg Laney equanimity Taggnostr boyscared majoh geir_ nothingmuch borism_ epmf_ Deewiant nlogax kmeyer Bleadof wisemanby Bassetts Raevel_)
21:23:40 --- names: list (stalker_ ath^_ ibid jystic Innominate _kuningas qeb`away xian Ornedan_ quicksilver cods Elly sgf aiko agemo jvoorhis skaar greap pragma_ inclement wang BONUS_ arkx dionoea FauxFaux koninkje_away nwf srcerer jonafan ville CodeBlock shellsage Colours_ shapr sunfun jleedev Kapowski jmcarthur awarring Spockz ystael guerby amgarching Spaghettini LeCamarade @ChanServ Hunner scree jrockway Arnar smiler kosmikus donri mcclurmc a-s jayne willb emma)
21:23:40 --- names: list (lament kadoban wagle kolmodin yahooooo tavelram luite zax andrewsw M| hsaliak__ dons pifish_ stepcut McManiaC wimt DEVOKUN dixiecko PeakerWork felipe_ neurocyte pikhq sereven edwtjo sbok zygoloid kw317 joed Annie|Home Counter-Strike tmug dilinger _Jordan_ jml ahf Axman6 spoop dmwit smg newsham ertai fnordus jlouis MacCoaster byorgey Jiten kalven igorgue jlaire andun Tobsan ath ^Einstein drspider_ tamiko pcc1 emias deiga_ snhmib dino- geoaxis_)
21:23:40 --- names: list (Heffalump SimonRC nablaa tilman Jaak Twey rey_ Liskni_si wolverian Lemmih eelco_ sieni araujo xinming bind_return ToRA flippo wharrgarble LeoD heaumer_ deavid Tomas Veinor jbauman lhnz Raku^ Jedai m4thrick Eelis eyck ijnek jtra baaba TML linkinus jix burp ve pixel5 jaj alexbobp loupgaroublond tessier clarkb jamwt trez Optimo jontore eek MyCatVerbs glith AnMaster Nereid nipuL sjanssen reltuk saccade __marius__ tromp_ dcoutts_ davidL PHO_)
21:23:40 --- names: list (inimino endojelly desp bockmabe_ beibmozoi bd_ mml`_ theclaw mux mokus_ Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh p_l aavogt cygnus_ jasonmay mikste sevvie guerrilla osfameron ehamberg flori lsthemes arjanoosting poe thedward companion_square authentic jql anekos mmmdonuts malouin qed desu kar-1 mlh droidcore SubStack jfoutz int-e dogmaT)
21:23:40 --- names: list (kakeman suiside mikm Paks webframp alexander2 wagle_home da-xw sebbe1991 GNU\colossus _plcs_ impl mornfall prigaux mmmulani ahihi anji_ saiam nasloc__ sunnavy dek5 ido lanaer wdonnelly jvogel_ poucet Aisling danderson Nanar fxr Milo- shepheb integral wormwood shachaf shortcircuit)
