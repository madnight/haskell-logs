00:00:03 <BMeph> ksf: That's what byorgey calls it; it's just '$', but with flipped arguments. :)
00:00:30 <ksf> :t flip ($)
00:00:31 <lambdabot> forall b b1. b -> (b -> b1) -> b1
00:00:45 <ksf> @google contravariance
00:00:46 <lambdabot> http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
00:00:46 <lambdabot> Title: Covariance and contravariance (computer science) - Wikipedia, the free encyclope ...
00:00:49 <quicksilver> BMeph: it's not, though.
00:00:59 <quicksilver> BMeph: because it's while not EOF
00:01:06 <quicksilver> BMeph: (not just once)
00:01:38 <EnglishGent> morning all :)
00:01:53 <quicksilver> ksf: is it really necessary to keep passing the Handle since it never varies? why not just whileFile :: Handle -> IO () -> IO ()
00:02:06 <mxc> bmeph: i like  (|>) = flip $
00:02:22 <mxc> essentially the f# pipe operator
00:02:29 <mxc> sometimes makes things easier to read
00:02:49 <ksf> yep, that's true.
00:03:37 <ksf> I think I'm too accustomed to reading from right to left, by now.
00:03:38 <mxc> let a = "blasdf  sdf  sd fh" |> map toUpper |> filter isSpace |> ...
00:03:45 <mxc> for a dummy example
00:04:02 <mxc> let a =
00:04:02 <mxc>   "blasdf  sdf  sd fh"
00:04:03 <mxc>   |> map toUpper
00:04:03 <mxc>   |> filter isSpace |> ...
00:04:24 <ksf> mobits being composed left to right is actually a good thing, because that's a hint that yoeu can't easily combine them with pure functions.
00:04:40 <mxc> whats a mobit?
00:04:53 <ksf> Monad m -> m a
00:04:57 <ksf> that's a mobit.
00:05:20 <mxc> Mean Monad m => m a?
00:05:25 <ksf> yep
00:05:53 <ksf> a piece of a monad that you can use to construct aggregate pieces
00:06:06 <ksf> or, rather, a bit of its value domain.
00:06:34 <mxc> but a 'mobit' in a sense is a value, so i dont understand what composition woudl even mean
00:06:54 <mxc> like, getStr :: IO String is a mobit as you describe
00:07:14 <ksf> other terms for it is "monadic value", or, in a concrete case "IO action" or "parser"
00:08:25 <rasfar> Hi EnglishGent, it's ... definitely morning at 3am.
00:08:45 <EnglishGent> hi rasfar :)
00:08:55 <mxc> and by composition, you just mean somehting like a >> b?
00:09:03 <EnglishGent> it's not quite *that* morning behind me - but it's bad enough!
00:09:22 <ksf> yep
00:09:29 * EnglishGent is utilising evaluating (ap coffee EnglishGent.instance) :)
00:09:35 <ksf> >> takes two mobit and gives you a new one
00:09:40 <EnglishGent> currently evaluating*
00:09:43 <EnglishGent> beh :|
00:10:30 <ksf> EnglishGent.Instance? are you allocated by unsafePerformIntercourse . newChildRef?
00:11:03 <EnglishGent> I believe that is how most of us were allocated ksf
00:11:08 <mxc> ksf: that sounds very impure
00:11:17 <EnglishGent> the only exception I know of is supposed to be an instance of Divinity
00:12:14 <ksf> the other explanation goes that he was an instance of covering up a sexual relation before marriage
00:12:49 <mxc> ^she ?
00:13:02 <EnglishGent> ooh - a glyph meaning monad! http://en.wikipedia.org/wiki/File:DeeHieroglyph.gif -- designed by John Dee - http://en.wikipedia.org/wiki/John_Dee .. in 1564
00:13:09 <ksf> considering human nature and occam's razor, I'm tending to believing exactly that.
00:13:29 <mxc> ksf - if you said 'she' i'd be with you..
00:13:30 <ksf> mxc, well, they, in the end.
00:13:39 <poe> EnglishGent nice :)
00:14:28 <pastah> i have a piece f code i want validated... could someone help me?
00:14:33 <rasfar> no doubt, that's a scary enough looking glyph given the simplicity.  count on the alchemists.
00:14:35 <pastah> (blind to your own bugs etc)
00:15:15 <EnglishGent> pastah - post it to hpaste, give the link here & we'll do our best :)
00:16:56 * EnglishGent now has visions of a book with that symbol on the front & the title 'Ars Monadica' -- and the expressions of comp-sci undergrads when you show it & tell them it's required reading...
00:16:57 <EnglishGent> :)
00:17:12 <shambler> hehe
00:17:20 <quicksilver> pastah: paste away
00:17:39 <jkff> Hi. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12462#a12462 - is this a compiler bug? I totally don't understand why the compiler is complaining.
00:19:17 <ksf> because m a
00:19:24 <ksf>  /= a
00:19:42 <ksf> MonadC m (m a) =>
00:19:50 <ksf> dunno why that isn't inferred, though.
00:19:56 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12463#a12463
00:20:07 <jkff> Why MonadC m (m a)?
00:20:19 <jkff> I want MonadC m c there, and this is what is inferred if I omit the signature
00:20:22 <ksf> because both m's are equal.
00:20:26 <pastah> does genTGMsequence work the way that the comment states?
00:20:44 <quicksilver> jkff: the problem is that the signature of join doesn't mention c
00:20:52 <quicksilver> jkff: so there is no way to specifiy which 'c' you want.
00:20:57 <ksf> ...so you have to have instances for m a and m (m a)
00:21:03 <jkff> Ah. Hm.
00:21:28 <quicksilver> I'm not really sure why it compiles when you remove the type sig.
00:21:32 <quicksilver> I think *that* might be a bug.
00:21:40 <pastah> EnglishGent, quicksilver
00:21:43 <quicksilver> it should be an ambiguity error since it can't decide which category to use.
00:22:00 <jkff> But shouldn't it work for every category and be thus polymorphic?
00:22:02 <pastah> EnglishGent, quicksilver: stole idea from here; http://www.tetrisconcept.net/wiki/TGM_randomizer
00:23:04 <Baughn> FunctorSalad: If you're referring to the Annoying Brokenness of Indentating Comments, that's fixable.
00:23:04 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
00:23:06 <quicksilver> jkff: sure but it's not usable since you can't tell it which category to use.
00:23:07 <Baughn> @clear
00:23:08 <lambdabot> Messages cleared.
00:23:20 <jkff> Hm, maybe things could work if I made a fundep m -> c ?...
00:23:26 <quicksilver> jkff: yes, I think so
00:23:34 <jkff> Indeed, it works
00:23:37 <jkff> Thanks!
00:23:41 <FunctorSalad> Baughn: not indentation-related... I mean that the tex input method mangles dashes
00:23:53 <FunctorSalad> Baughn: so Agda input method is a nice replacement
00:24:01 <FunctorSalad> (and it has moar characters)
00:24:08 <Baughn> FunctorSalad: Maybe I'm misunderstanding something. What tex input method?
00:24:16 <jkff> By the way, I wonder if this MonadC class is already well-known. It seems to me that it might be a useful generalization of monads, but not as general as monads in category theory.
00:24:17 <quicksilver> pastah: looks fine to me :)
00:24:34 <pastah> quicksilver: heh, thanks for the input :)
00:24:41 <quicksilver> pastah: although the reptition of 'return' in the first function is fractionally ugly
00:24:56 <pastah> quicksilver: you're ugle
00:24:59 <pastah> :p
00:25:00 <FunctorSalad> Baughn: ah yes, that was the context :) using the tex input method
00:25:07 <FunctorSalad> to enter unicode for haskell
00:25:19 <FunctorSalad> Baughn: M-x set-input-method
00:25:49 <pastah> quicksilver: actually ,that function isn't really in my code... i just added that there for your pleasure :p
00:25:52 <FunctorSalad> Baughn: so I guess my point is just that maybe a haskell-input-method should be included ;)
00:26:20 <EnglishGent> hpaste is broken :/
00:26:23 <quicksilver> jkff: it certainly seems fairly 'obvious' to me. But I don't know if there are other interesting Control.Categorys to try monads over.
00:26:38 * EnglishGent just got server errors twice in a row
00:26:50 <FunctorSalad> there are also kleisli categories :D
00:26:59 <Baughn> FunctorSalad: I didn't even know emacs /had/ input-methods
00:27:08 <quicksilver> there are indeed, but are monads over them interesting?
00:27:13 <quicksilver> (from a programming point of view)
00:27:13 <FunctorSalad> Baughn: it's great, you can use all the pretty symbols :D
00:27:17 <EnglishGent> what are those FunctorSalad? (I know some types of category - but not that one!) :)
00:27:20 <Baughn> FunctorSalad: Well, thanks for the hints; it goes on my TODO, somewhere near the bottom. ^^;
00:27:42 <jkff> The good thing is that this generalization allows one to constrain "c" to less general things than any opaque lambda terms. That might be useful for optimization.
00:27:43 <Baughn> FunctorSalad: I do use pretty symbols. Just.. not by writing in unicode.
00:28:15 <FunctorSalad> Baughn: ?
00:28:23 <FunctorSalad> ah you mean the prettifier?
00:28:30 <Baughn> FunctorSalad: I mean.. right.
00:28:31 <jkff> For example, "c" might be "instance Category MyTerm where id = Id; (.) = Compose", where MyTerm is a GADT of a constrained domain-specific language.
00:28:46 <FunctorSalad> Baughn: I mean for one's own operators though
00:28:57 <FunctorSalad> (not lang constructs)
00:28:59 <Baughn> FunctorSalad: Say, are you the one who's been submitting patches to make haskell-mode play well with unicode symbols?
00:28:59 <jkff> And "m" might be a monad of a certain interpreter backend
00:29:08 <FunctorSalad> Baughn: no :)
00:29:20 <jkff> Then "m" might perform various optimizations that would be impossible if the second argument of >>= were opaque.
00:29:49 <FunctorSalad> EnglishGent: Control.Arrow.Kleisli
00:29:50 <quicksilver> jkff: hmm, yes, that is intersting.
00:30:05 <jkff> The bad part is that you lose the do syntax and I am not sure about which monad-polymorphic functions like sequence, liftM etc can be generalized well.
00:30:14 <jkff> And where one should put "c" instead of "->".
00:30:14 <FunctorSalad> quicksilver: hmm don't know about monads over kleisli cats
00:30:36 <EnglishGent> ty FunctorSalad - but I meant catagorically in terms of the math :)
00:30:42 * EnglishGent reading wikipedia article now :)
00:31:54 <pastah> hpaste got t3h dedd
00:32:21 <quicksilver> mmorrow: halp halp hpaste fail
00:32:42 <FunctorSalad> quicksilver: then there are also "restricted" categories...
00:32:47 <FunctorSalad> for the notorious set monad
00:33:34 <FunctorSalad> but you don't get such 'restricted' categories with the current Control.Cat
00:34:38 <jkff> Hm, I can't even write a liftM :-|
00:34:52 <pastah> quicksilver: paste.lisp.org :)
00:35:58 <jkff> Looks like mixing two categories (-> and c) is not good.
00:37:29 <FunctorSalad> jkff: sure you lose do syntax?
00:37:42 <FunctorSalad> it uses the current (>>=)
00:37:45 <jkff> Yes, at least because c is not required to represent arbitrary lambda terms
00:37:50 <FunctorSalad> with NoImplicitPrelude at least
00:38:16 <jkff> do a <- x ; ... is desugared into x >>= \a -> ..., and \a -> ... has type a -> ..., not "c a ..."
00:38:18 <FunctorSalad> I mean you'd still have do syntax for the special case where the cat is Hask
00:38:22 <jkff> Yes
00:38:39 <jkff> But we already have enough monads for that special case
00:38:49 <FunctorSalad> (CCCs can interpret lambda terms btw :D)
00:39:13 <jkff> I'm thinking about that, too. Oh! One moment please
00:39:35 <jkff> return should have type c a (m a), not a -> m a
00:39:39 <jkff> Then we have liftM
00:39:52 <FunctorSalad> a ~> m a
00:39:53 <FunctorSalad> ;)
00:40:09 <jkff> Yep. It is not clear where exactly "->" should be replaced by "~>".
00:40:44 <FunctorSalad> hmm, where in math you have functions in the metalevel set theory, you'd have ->
00:40:53 <FunctorSalad> ~> for any categorical constructs
00:41:01 <jkff> That is the question :)
00:41:16 <jkff> Looks like we need a CCC already for liftM2...
00:41:31 <jkff> Probably one should model an Applicative in the same fashion first
00:41:35 <FunctorSalad> so e.g. target tupling is "a ~> b1 -> a ~> b2 -> a ~> Product b1 b2"
00:41:42 <FunctorSalad> with ~> binding stronger
00:41:54 <FunctorSalad> hmm the tilde is too hard to tell apart
00:41:59 <FunctorSalad> --> ?
00:42:16 <jkff> Or ~~> :)
00:42:31 <Axman6> ~~o
00:42:38 <Axman6> ... sperm operator >_>
00:42:43 <Axman6> sorry
00:42:46 <FunctorSalad> that's illegal
00:42:53 <FunctorSalad> (can't mix symbols and alnum)
00:43:31 <jkff> @unpl \f m1 m2 -> m1 >>= (\a -> m2 >>= (return . f a))
00:43:32 <lambdabot> \ f m1 m2 -> m1 >>= \ a -> m2 >>= \ d -> return (f a d)
00:43:36 <jkff> @pl \f m1 m2 -> m1 >>= (\a -> m2 >>= (return . f a))
00:43:37 <lambdabot> liftM2
00:43:40 <jkff> Grrr
00:43:50 <jkff> Stupid lambdabot, that's what I'm trying to model
00:44:07 <jkff> @pl \f m1 m2 -> m1 `bind` (\a -> m2 `bind` (ret . f a))
00:44:08 <lambdabot> flip ((.) . bind) . flip ((.) . bind) . ((ret .) .)
00:44:11 <jkff> @pl \f m1 m2 -> m1 `bind` (\a -> m2 `bind` (ret `compose` f a))
00:44:12 <lambdabot> flip ((.) . bind) . flip ((.) . bind) . ((ret `compose`) .)
00:44:14 <jkff> OMG
00:44:29 <FunctorSalad> you need a CCC already to even make sense out of "A -> B -> C" ;)
00:44:43 <FunctorSalad> products are enough if you uncurry though
00:44:58 <jkff> Right
00:45:03 <jkff> OK, we need a category with products then.
00:46:01 <jkff> Things are getting crazy
00:46:11 <jkff> @hoogle (~>)
00:46:11 <lambdabot> No results found
00:46:18 <jkff> In what module is it defined?
00:46:46 <FunctorSalad> so liftM2 :: ((a,b) --> c) -> ((m a, m b) --> m c)
00:47:00 <FunctorSalad> it's a type variable
00:47:25 <FunctorSalad> class Category (~>) where ...
00:47:43 <jkff> I was more along the lines of "class (Category c) => CatP c where type Product a b :: * ; projLeft :: Product a b ~> a ; projRight :: Product a b ~> b ; product :: a -> b -> Product a b"
00:47:58 <jkff> But I am not sure about the signature of "product"
00:48:18 <jkff> Maybe, product :: (a,b) ~> Product a b?
00:48:21 <FunctorSalad> <FunctorSalad> so e.g. target tupling is "a ~> b1 -> a ~> b2 -> a ~> Product b1 b2"
00:48:35 <jkff> Hm.
00:48:38 <FunctorSalad> categorical products aren't defined in terms of elements
00:48:48 <jkff> Yep, you're right.
00:48:51 <FunctorSalad> but in terms of how to make functions into the product
00:50:38 <mjrosenb> has anyone tried to build minesweeper?
00:52:16 <mjrosenb> it dies with     Could not find module `Number.Peano':
00:52:53 <mjrosenb> and i do not know where to find that.
00:53:42 <Taejo> mjrosenb: hayoo allows one to search the whole of hackage
00:53:54 <Taejo> it seems Number.Peano is in numeric-prelude
00:54:05 <Taejo> perhaps minesweeper is missing the dependency
00:55:43 <mjrosenb> seems like it
00:57:06 <mjrosenb> wow, that has a bunch of dependencies
01:00:42 <mjrosenb>       it is a member of the hidden package `numeric-prelude-0.1.2'
01:00:44 <mjrosenb> sigh.
01:01:47 <Taejo> mjrosenb: there's something wrong here: the dependencies on numeric-prelude and lazysmallcheck are only declared if the tests flag is enabled
01:02:13 <mjrosenb> geed times
01:02:15 <mjrosenb> *good
01:02:22 <Taejo> mjrosenb: I'm trying to work it out
01:02:42 <mjrosenb> Taejo: there is also the above error even when numeric-prelude is present.
01:11:58 <Taejo> mjrosenb: have you contacted the package maintainer?
01:12:59 <mjrosenb> Taejo: not yet.
01:17:17 <Taejo> mjrosenb: in the cabal file, simply moving the line "CPP-Options: -DTEST" above the "build-depends:" line seems to do it (maybe just removing the blank is enough)
01:17:40 <Taejo> I don't know cabal syntax well enough to know what the actual problem is
01:20:55 <mjrosenb> Taejo: which build-depends: line?
01:21:08 <Taejo> the one immediately above it
01:22:53 <Taejo> mjrosenb: I'll send a patch to the maintainer
01:23:26 <mjrosenb> which version of numeric-prelude do you have?
01:23:29 <mjrosenb>     Could not find module `Number.Peano':
01:23:29 <mjrosenb>       it is a member of the hidden package `numeric-prelude-0.1.2'
01:23:38 <mjrosenb> i still get that^
01:24:13 <Taejo> mjrosenb: you should only need numeric-prelude when the "tests" flag is enabled
01:24:31 <Taejo> mjrosenb: in which module do you get that
01:24:49 <mjrosenb> Data/PContainer.lhs:14:9:
01:24:55 <Taejo> oh, it's not guarded by an ifdef
01:25:00 <mjrosenb> indeed.
01:26:22 <Taejo> mjrosenb: I think the best thing is to tell the maintainer to try and build his own packages before uploading them
01:26:43 <Taejo> if it was a one-line patch I'd do it myself
01:29:14 <mjrosenb> Taejo: he may be using an older version of numeric-prelude
01:29:55 <Taejo> mjrosenb: since the package doesn't declare any dependency on numeric-prelude (without the flag), it shouldn't make a difference
01:30:23 <mjrosenb> do the #ifdefs belong in the cabal file, or in the .lhs file?
01:31:22 <Taejo> mjrosenb: in the .lhs
01:32:50 <mjrosenb> and Core/BitField.lhs
02:00:52 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
02:00:52 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
02:00:52 --- names: list (clog_ path_ pao fbru02 simonf takuan dikini perspectival Asztal Jafet borism Nereid blueflute eevar2 mpwd Nereid_ trin_cz u_quark Pewpewarrows miccm LouisJB aluink epokal jrockway stoop Taejo mmx166mhz jre2_ skaar abbe otsdr1 spaceodyssey cdfh DarkUnicorn zachk danvet paolino cdiem Axman6 dancor wisemanby medfly dolio Beelsebob Schmallon malcolmw yowgi twanvl macron shag galdor shambler hackagebot sigh lazni1 QplQyer Kim^Walkman bastl SamB_XP_)
02:00:52 --- names: list (Athas np0w3r triplez m-i-l-a-n StoneToad_ Snark sohum oskimura_ yahooooo sanders_ TR2N QtPlaty[HireMe] ablokzijl shintah jabagawee vili Gracenotes pifish mm_freak portnov johnw Pthing copumpkin alvarezp otto_s_ voker57_ saint_cypher caligula_ fhs sunfun dmwit lpsmith Raynes augur kpreid Apocalisp saccade_ onodrim Dessous red-agent ivanm cognominal_ amuck joga Adamant mwc ksf ttmrichter Guest51951 XGas horms torbenh4 Cobra^^ lvh_ sgf gOcOOl)
02:00:52 --- names: list (smelk mun jmcarthur astrocub slbkbs bnijk_ McManiaC xternal geekagent nablaa mreggen FauxFaux ville mauke jan_ eyck MisterN tensorpudding Country-Strike BgPerl-VB16 anders^^ fnordus sbok_ wimt smg jleedev edwtjo daed mattam Annie|Home Laney electrogeek dionoea tew88 ertai Wraithan kynky dankna spoop jml pikhq ahf qm13 zygoloid_ newsham mjrosenb joed dilinger karld_ Colours erg _Jordan__ jvoorhis scree tmug MacCoaster crem Philonous fracture)
02:00:52 --- names: list (Cthulhon| byorgey EnglishGent mexisme trie kw317 Trafalgard leoncamel mxc Aikawa_ Alpounet szr sioraiocht kwos notweebl Saizan Feuerbach qz Esmil dfeuer dobblego gbeshers_home nlogax Botje muri_one rdd` zax_ Boney_ doublethink_work ClaudiusMaximus rwx dino- xinming Kambus zhijie noddy mmorrow therp levitation[A] FunctorSalad int-e wharrgarble1 gogonkt JaffaCake1 vy Poeir clog Elench novas0x2a1 ned- hiredman SmurfOR akappa blackdog Khisanth)
02:00:52 --- names: list (eno angelixd Lycurgus +preflex juhp whoppix Draconx Chile mercury^ ErrantEgo gbeshers gnuvince gjl ksandstr Igloo nazgjunk ggreg_ arvidj leimy nathanic_work StarFire ray rgr samulihs flux im_macie1 dayz bbee jims orbitz stepnem booxter danopia Badger tuukkah DrSyzygy avysk taruti pem bran profmakx allbery_b rapacity netcat sebas_ shortcircuit shachaf wormwood integral shepheb Milo- fxr Nanar danderson Aisling poucet jvogel_ wdonnelly lanaer)
02:00:52 --- names: list (ido sunnavy nasloc__ saiam anji_ ahihi mmmulani prigaux mornfall impl _plcs_ sebbe1991 da-xw wagle_home pastah webframp Paks mikm suiside kakeman dogmaT jfoutz SubStack droidcore mlh kar-1 desu qed malouin mmmdonuts anekos jql authentic companion_square thedward poe arjanoosting flori ehamberg osfameron guerrilla sevvie mikste jasonmay cygnus_ aavogt p_l Blaketh cjay Gilly thetallguy1 Twigathy icee zaarg absentia dqd laz0r tarbo_ marmolak)
02:00:52 --- names: list (Ferdirand Warrigal Valodim birkenfeld nominolo|uni Baughn mokus_ mux theclaw mml`_ bd_ beibmozoi bockmabe_ desp endojelly inimino PHO_ davidL dcoutts_ tromp_ __marius__ saccade reltuk sjanssen nipuL AnMaster MyCatVerbs eek jontore Optimo trez clarkb tessier loupgaroublond alexbobp jaj pixel5 ve burp jix linkinus TML baaba jtra ijnek Eelis m4thrick Jedai Raku^ lhnz jbauman Veinor Tomas deavid heaumer_ LeoD flippo ToRA bind_return araujo sieni)
02:00:52 --- names: list (eelco_ Lemmih wolverian Liskni_si rey_ Twey Jaak tilman SimonRC Heffalump geoaxis_ deiga_ emias pcc1 tamiko drspider_ ^Einstein ath Tobsan andun jlaire igorgue kalven Jiten jlouis neurocyte felipe_ PeakerWork dixiecko stepcut dons hsaliak__ M| andrewsw luite tavelram kolmodin kadoban lament emma willb jayne mcclurmc donri kosmikus smiler Arnar Hunner LeCamarade Spaghettini amgarching guerby ystael Spockz awarring shellsage CodeBlock jonafan)
02:00:52 --- names: list (srcerer nwf koninkje_away arkx BONUS_ wang inclement pragma_ greap agemo aiko Elly cods quicksilver Ornedan_ xian qeb`away _kuningas Innominate jystic ibid ath^_ stalker_ Raevel Bassetts Bleadof Deewiant epmf_ nothingmuch geir_ majoh boyscared Taggnostr equanimity venkatg canvon thoughtpolice opqdonut drhodes Sisu ziman AndyP thingwath mdordal2 Vq liff brx midnite Blub\0 mw493 aempirei matthew-_ hellige welterde pettter_ qwr alip dcoutts)
02:00:52 --- names: list (da-x mfoemmel mfp Cale periodic jones- regulate alpheccar Exteris nnunley noj CalJohn paulvdw gbacon EvanCarroll lefant +lunabot EvilTerran +lambdabot idnar tmatix fredcy Polarina jelly12gen alexsuraci wm_eddie aep Reisen BMeph And[y] erk nathanic jorizma thorkilnaur_ fihi09`` lomeo rasfar koala_man dreixel chrisdone Gabbie r0bby pantsd_pcf soduko fritschy glitch loop tkr Paradox924X peddie nornagon lavish ben0x539 drbean Stephan202 harlekin)
02:00:52 --- names: list (tumult franksh Neronus nimred t jnwhiteh ac Zao BrianHV gdsx DRMacIver _br_ stroan sproingie dumael ps-auxw mshaw thomastc magicman BONUS mrd Megant jfredett mjv dcolish Vulpyne Nafai clanehin det SeaPrior tltstc olsner djinni @ChanServ ski)
02:04:21 <Haskellbeginner> hi, will someone plz explain how I get from a string input to an integer in  Haskell
02:06:13 <rasfar> I use read with a typecast iirc.  probably wrong thing to do though...
02:07:25 <rasfar> @ read "23" :: Int
02:07:59 <rasfar> wth?
02:08:07 <rasfar> , read "23" :: Int
02:08:08 <lunabot>  23
02:08:25 <medfly> > read "23" :: Int
02:08:25 <opqdonut> that's exactly the right thing to do :)
02:08:26 <lambdabot>   23
02:08:33 <rasfar> (whew!)
02:08:46 <opqdonut> rasfar: and it's not a cast, it's a type declaration
02:09:03 <opqdonut> it's unneeded if the environment specifies the type of the read expression well enough
02:09:13 <rasfar> oh, so read s isn't well-typed otherwise?  ah I see.
02:09:29 <opqdonut> it is well-typed, the type just isn't unique
02:09:32 <opqdonut> > read "23"
02:09:33 <lambdabot>   * Exception: Prelude.read: no parse
02:09:41 <opqdonut> > read "True" || False
02:09:42 <lambdabot>   Not in scope: `||ï¿½'
02:09:47 <opqdonut> > read "True" || False
02:09:48 <lambdabot>   True
02:09:56 <opqdonut> (mystery whitespace there)
02:10:04 <rasfar> (so i figured)
02:10:25 <opqdonut> actually that was a bad example, because lambdabot defaults to () nowadays
02:10:39 <opqdonut> so it's trying to do read "23" :: (), which obviously fails
02:10:40 <rasfar> If only I wasn't so busy, I'd be participating more here and getting back up to speed.  But as it is, I'm pulling an all-nighter on a bloody stats assignment...
02:10:43 <opqdonut> > read "()"
02:10:44 <lambdabot>   ()
02:11:37 <rasfar> i see.  read "()" gives an error in ghci though.
02:12:02 <rasfar> What's the difference between @ and >, incidentally?
02:12:58 <medfly> I think @ is used to other things
02:13:02 <medfly> @type read
02:13:03 <lambdabot> forall a. (Read a) => String -> a
02:13:36 <rasfar> i'll check back ... gotta keep pluggin' at the R code. :/  This channel is golden.  medfly: I *was* able to evaluate @ read "23" :: Int but it took a good 30 seconds...
02:14:48 <mjrosenb> Data/PContainer.lhs:264:5: Not in scope: `ap'
02:14:51 * mjrosenb headdesk
02:15:05 <mjrosenb> @hoogle ap
02:15:05 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
02:15:06 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
02:15:06 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
02:15:22 <mjrosenb> oh god i hope it is in Control.Monad
02:16:31 <mjrosenb> hrmm, this wants me to use a pastebin, doesn't it
02:18:51 <mjrosenb> http://pastebin.ca/1679121
02:19:05 <smiler> Ouch
02:19:15 <mjrosenb> oh man, the prettyprinter must have had fun with that
02:19:19 <mjrosenb> >--
02:20:25 <Asztal> o_O
02:23:29 <mjrosenb> hrmm, ghc seems to have gone away and not come back
02:23:33 <mjrosenb> this does not bode well
02:26:24 <mjrosenb> http://pastebin.ca/1679134
02:26:26 * mjrosenb cries
03:01:39 * EnglishGent comforts mjrosenb
03:05:48 <zygoloid_> mjrosenb: looks like it's finding Data.Binary.get; did you intend it to use Control.Monad.State.get?
03:06:54 <mjrosenb> zygoloid_: no clue.
03:07:04 <mjrosenb> zygoloid_: this is minesweeper
03:10:34 <pao> hi all :-) how do I slurp a iso8859-1 encoded file?
03:10:53 <quicksilver> get one of the encodings packages
03:10:57 <quicksilver> encodings, or iconv, perhaps
03:11:34 <pao> @hackage encodings
03:11:35 <lambdabot> http://hackage.haskell.org/package/encodings
03:11:46 <musically_ut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5020#a5020
03:11:58 <musically_ut> I am getting weird printing behaviour from Haskell.
03:12:08 <pao> quicksilver: thanks
03:12:09 <quicksilver> @hackage thiscommandisnotveryuseful
03:12:09 <lambdabot> http://hackage.haskell.org/package/thiscommandisnotveryuseful
03:12:16 <musically_ut> The output is attached in the paste.
03:12:18 <quicksilver> @hackage you/can/type/whatever/you/like
03:12:18 <lambdabot> http://hackage.haskell.org/package/you/can/type/whatever/you/like
03:12:28 <ivanm> musically_ut: what's so weird about it?
03:12:32 <ivanm> (that will help us find the error)
03:12:38 <ivanm> musically_ut: why not use Data.Complex?
03:12:46 <musically_ut> Why is "(-0.0)" being printed.
03:13:01 <musically_ut> ivanm, this is more like a self assignment, and besides, the problem is in the printing.
03:13:10 <pao> quicksilver: I realized that :-)
03:13:11 <ivanm> musically_ut: you're telling it to?
03:13:13 <musically_ut> Also, I could not create a simpler example to illustrate the problem.
03:13:28 <musically_ut> I am specifically trying not to do that in the show instance of C
03:13:40 <musically_ut> I don't want it to print the "+" when the number is negative.
03:13:56 <musically_ut> And the behaviour is perfect if I create instances the traditional way.
03:14:07 <musically_ut> However, if I use implicit typing, it messes up the rules.
03:14:11 <quicksilver> what do you mean, the traditional way?
03:14:13 <ivanm> musically_ut: let me check what you want: if its 0i, should it print the 0?
03:14:24 <musically_ut> quicksilver, let a = C (-1) 0.0
03:14:28 <musically_ut> Behaves well.
03:14:46 <musically_ut> But let b = (-1)::C messes up the output.
03:14:48 <ivanm> musically_ut: how is (-1)::C valid?
03:14:53 <ivanm> oh, right, fromInteger
03:14:57 <musically_ut> ivanm, Yes.
03:14:58 * ivanm facepalms
03:15:16 <musically_ut> Interestingly, let a::C = -1 is alright.
03:15:27 <ivanm> musically_ut: is it?
03:15:27 <musically_ut> Produces the right output after a show, that is.
03:15:33 <ivanm> they produce the same output in your paste
03:15:53 <musically_ut> The output of printing b is not right.
03:16:01 <ivanm> > show 0
03:16:01 <lambdabot>   "0"
03:16:09 <quicksilver> musically_ut: the output of both is the same
03:16:23 <quicksilver> musically_ut: I don't understand why you think a is all right and b is not?
03:16:26 <musically_ut> Oh, right, output for both is wrong.
03:16:33 <musically_ut> Sorry, was thinking of another example.
03:16:35 <musically_ut> My bad.
03:16:43 <ivanm> > let pr i j = show i ++ (if j < 0 then " " else " +") ++ show j ++ "i" in pr (-1) 0
03:16:44 <lambdabot>   "-1 +0i"
03:16:48 <quicksilver> I suspect (-1) desugars to negate (fromIntegral 1)
03:17:01 <quicksilver> instead of fromIntegral (-1) as you might expect.
03:17:08 <ivanm> @src Double fromIntegral
03:17:08 <lambdabot> Source not found. Where did you learn to type?
03:17:10 <musically_ut> But the problem is in the 0.0
03:17:21 <musically_ut> (-1) behaves as expected.
03:17:21 <quicksilver> musically_ut: yes, negate is negating it.
03:17:32 <musically_ut> negate is negating the 0.0?
03:17:33 <musically_ut> Oh.
03:17:40 * musically_ut redoes his thinking.
03:17:41 <ivanm> musically_ut: try this: fromInteger c = flip C 0 $ fromInteger c
03:17:52 <Jafet> That was the most awesome phrase I've heard today quicksilver
03:17:53 <quicksilver> (-1) is not a literal, precisely
03:17:56 <ivanm> > let pr i j = show i ++ (if j < 0 then " " else " +") ++ show j ++ "i" in pr (-1) (-0)
03:17:57 <lambdabot>   "-1 +0i"
03:18:09 <ivanm> Jafet: what, "negate is negating..." ?
03:18:27 <ivanm> quicksilver: it's weird that it seems to be even considering a -0 though
03:18:33 <musically_ut> Interesting, suggestion ivanm .
03:18:33 <Jafet> :t (-1)
03:18:34 <lambdabot> forall a. (Num a) => a
03:18:40 <Jafet> Erm.
03:18:46 <ivanm> unless it's mis-representing it as some really weird Double and only printing it as 0
03:18:53 <musically_ut> Is this, technically a bug?
03:19:00 <ivanm> musically_ut: maybe...
03:19:03 <Jafet> > -0.0
03:19:03 <lambdabot>   -0.0
03:19:04 <musically_ut> Because it is printing -0.0, but failing the i < 0 test.
03:19:11 <quicksilver> ivanm: it's not weird
03:19:12 <musically_ut> > -0.0 < 0
03:19:14 <lambdabot>   False
03:19:15 <quicksilver> ivanm: -0 is -0
03:19:24 <musically_ut> > -0.0 == 0
03:19:25 <lambdabot>   True
03:19:26 <ivanm> quicksilver: oh, aren't we using 2s-complement for doubles?
03:19:31 <quicksilver> ivanm: no.
03:19:32 <Jafet> IEEE 754 defines positive and negative zeroes.
03:19:32 <musically_ut> Ah ..
03:19:36 <quicksilver> we're using IEEE754
03:19:40 <ivanm> Jafet: does it? weird...
03:19:50 <Jafet> Two's complement doesn't even make much sense for floating point
03:19:53 <ivanm> I thought it used 2s complement
03:20:00 <ivanm> Jafet: duh, course not
03:20:21 <Jafet> Hmm
03:20:22 <ivanm> quicksilver: OK, so why is the negate from the fromIntegral applying to the 0 ?
03:20:23 <Jafet> @hoogle nan
03:20:24 <lambdabot> Prelude isNaN :: RealFloat a => a -> Bool
03:20:29 <quicksilver> ivanm: because he told it to
03:20:30 <mjrosenb> IEEE also does not say that -0 < 0 iirc
03:20:39 <ivanm> quicksilver: how?
03:20:41 <quicksilver> ivanm: look at his negate instace.
03:20:47 <ivanm> quicksilver: right
03:20:49 <quicksilver> negate (C i j) = C (-i) (-j)
03:20:50 <FunctorSalad_> surely there is some oleg trick to take the transitive hull of a binary class?
03:21:07 <Jafet> :t -0
03:21:07 <lambdabot> forall a. (Num a) => a
03:21:08 <musically_ut> ivanm, the new definition of fromInteger has the same effect.
03:21:14 <Jafet> :t -0::Integer
03:21:15 <lambdabot> Integer
03:21:22 <Jafet> ...d'oh
03:21:26 <ivanm> musically_ut: you need special cases of negate for when i and j are 0
03:21:29 <FunctorSalad_> hmm this may not be that easy...
03:21:30 <musically_ut> quicksilver, so are you suggesting that I change my 'negate' definition?
03:21:34 <musically_ut> Ah.
03:21:34 <ivanm> so 3 different cases
03:21:34 <FunctorSalad_> you'd have to avoid cycles :o
03:21:48 <musically_ut> Interesting, trying this solution then.
03:21:48 <quicksilver> if you care deeply about negative zeros, yes
03:21:53 <ivanm> 3 _extra_ cases, that is
03:21:59 <Jafet> (...what if you pass negate negative zeroes?!)
03:22:20 <ivanm> negate (C 0 0) = ...; negate (C 0 j) ...; negate (C i 0) = ...; negate (C i j) = ...
03:22:38 <Jafet> > -0
03:22:38 <lambdabot>   0
03:22:39 <ivanm> Jafet: fine, you need another 4 cases for negative 0s as well
03:22:53 <ivanm> Jafet: wait, if it's a -0, it'll get negated to be just 0, so it's all good
03:22:57 <ivanm> so 4 cases should do it
03:23:06 <Jafet> I'd just use case and let
03:23:08 <nvoorhies> > -0.0
03:23:09 <lambdabot>   -0.0
03:23:43 <ivanm> Jafet: for what?
03:23:52 <ivanm> (as in how)
03:24:04 <musically_ut> ivanm, quicksilver thanks, the new definition of negate works, and produced the right result.
03:24:37 <musically_ut> quicksilver, I would never have figured out that a call to negate was involved in the conversion, thanks, it is a new insight in how parsing works. :)
03:24:56 <ivanm> musically_ut: for your show instance, you might want to consider doing it with signum and abs, so you always explicitly set the sign in the output
03:25:19 <path[l]> how do I make an infinite list thats a cycle of a finite list?
03:25:25 <musically_ut> ivanm, how? I don't completely understand.
03:25:38 <musically_ut> Oh, right.
03:25:40 <Jafet> > let negate x y = (let neg x = if x == 0 then 0 else -x in (neg x, neg y)) in negate 0.0 -0.0
03:25:41 <lambdabot>   No instance for (GHC.Real.Fractional (a -> (t, a)))
03:25:42 <lambdabot>    arising from the lit...
03:25:47 <path[l]> cycle [1,2,3]
03:25:55 <path[l]> > cycle [1,2,3]
03:25:56 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
03:25:58 <path[l]> ah doh
03:26:21 <ivanm> Jafet: the problem might still occur with negate in other cases though
03:26:29 <quicksilver> musically_ut: the point is that unary - isn't part of literal syntax, because you can do "-x" with a variable x as well.
03:27:13 <musically_ut> quicksilver, yes, I should have realised that, since I am doing a compilers course myself, but still did have not connected all the parts of my knowledge well enough.
03:28:04 <quicksilver> musically_ut: it could have been a special case.
03:28:18 <quicksilver> musically_ut: but as it happens, it isn't ;)
03:28:41 <musically_ut> :)
03:31:06 <path[l]> is there a flatten operation? Given a number n Im trying to find the simplest way to create a list which is [1,1,1(n times), 2,2,(n times)... n,n,n(n times)]
03:31:08 <path[l]> any ideas?
03:31:28 <rwx> concat?
03:31:48 <path[l]> I was first thinking of taking [1..n] and doing a map and a replicate
03:31:48 <path[l]> but I get a list of lists
03:31:48 <path[l]> oh
03:31:50 <path[l]> concat is flatten
03:32:17 <path[l]> hmm concatMap seems to be better
03:32:22 <ksf> join is, too.
03:32:38 <ksf> and concatMap is (>>=)
03:32:44 <ksf> well, with arguments flipped
03:32:45 <SamB_XP_> ksf: how punny!
03:32:55 <path[l]> I dont see a join
03:33:09 <ksf> but you get at concatMap with list comprehensions, too.
03:33:25 <ksf> path[l], it should be in the prelude, but some idiots put it into Control.Monad
03:33:36 <path[l]> oh
03:33:43 <ksf> :t join
03:33:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:33:47 <path[l]> wait wouldnt a list comprehension give me this
03:33:54 <SamB_XP_> ksf: itym Monad ?
03:34:16 <SamB_XP_> those idiots didn't even have hierarchical names!
03:34:17 <ksf> :t join :: [[a]] -> [a]
03:34:18 <lambdabot> forall a. [[a]] -> [a]
03:34:24 <rwx> [ replicate n x | x <- [1 .. n] ]
03:35:05 <path[l]> > concatMap (\x -> replicate 5 x) [1..5]
03:35:06 <lambdabot>   [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5]
03:35:15 <path[l]> oh rwx ... yeah thats better
03:35:22 <path[l]> crap I need to learn list comprehensions
03:35:27 <Jafet> Why do you want such a list
03:35:35 <ksf> they're really just an alternative syntax for do
03:35:39 <rwx> also there's zip
03:35:41 <ksf> ...restricted to lists.
03:36:18 <rwx> they appeal to newbies like me, though
03:36:27 <path[l]> well I have a bunch of numbers which represent positions in a matrix, so Im planning to zip them with this list and a cycle list. So with every number I have its column index and it's row index
03:36:32 <path[l]> which Im gonna use for the next operation
03:36:34 <Jafet> I thought they're syntactic caramel for filters
03:36:48 <ksf> > (\n  -> [1..n] >>= replicate n) 5
03:36:49 <lambdabot>   [1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5]
03:36:50 <SamB_XP_> Jafet: that comes in too
03:36:56 <ksf> :t \n  -> [1..n] >>= replicate n
03:36:57 <lambdabot> Int -> [Int]
03:36:58 <SamB_XP_> and it's really more of a butterscotch
03:37:06 <Jafet> Now I'm getting hungry.
03:37:20 <path[l]> oh yeah I forgot >>= is concatMap
03:38:03 <ksf> they capture arbitrary list hylomorphisms
03:38:21 <ksf> iff I'm using the term hylo correctly, that is.
03:39:16 <path[l]> > [ replicate n x | x <- [1 .. n] ]
03:39:17 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:39:17 <lambdabot>         against inferred type ...
03:39:29 <path[l]> > [ replicate 3 x | x <- [1 .. 3] ]
03:39:30 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
03:39:52 <path[l]> hmm oh thats not what I wanted nm Ill use the >>= approach
03:40:15 <ksf> > [ y | y <- replicate 3 x , x <- [1 .. 3] ]
03:40:16 <lambdabot>   [x,x,x,x,x,x,x,x,x]
03:40:19 <ksf> uh.
03:40:40 <ksf> > [ y | y <- replicate 3 a , a <- [1 .. 3] ]
03:40:41 <lambdabot>   [a,a,a,a,a,a,a,a,a]
03:40:44 <ksf> buggers!
03:41:09 <path[l]> I dont understand what thats doing lol.
03:41:19 <Haskellbeginner> simple question: how do I get from a string like "12345" to the integer 12345, can someone plz help me
03:41:21 <ksf> :t a
03:41:21 <lambdabot> Expr
03:41:23 <ksf> :t x
03:41:24 <lambdabot> Expr
03:41:36 <paulvdw> what about:
03:41:53 <paulvdw> > [ y | a <- [1..3], y<- replicate 3 a ]
03:41:54 <lambdabot>   [1,1,1,2,2,2,3,3,3]
03:42:01 <ksf> anyway, /me thinks the >>= solution is the cleanest
03:42:16 <path[l]> yeah I like it
03:42:23 <ksf> oh yes those are ordered.
03:42:27 <paulvdw> uhuh
03:42:36 <path[l]> is it because its a monad?
03:42:36 <ksf> ...just like do notation, incidentally.
03:42:46 <path[l]> right
03:42:53 <path[l]> got it
03:43:14 <Jafet> > True && 1/0 == 1
03:43:15 <lambdabot>   False
03:43:19 <koala_man> Haskellbeginner: read "12345" :: Int
03:43:32 <Jafet> ...whoops
03:43:59 <ksf> > False && undefined
03:44:00 <lambdabot>   False
03:44:05 <ksf> > True && undefined
03:44:06 <lambdabot>   * Exception: Prelude.undefined
03:45:07 <Raevel> Haskellbeginner: use read, but make sure the string is in fact only numbers before doing so
03:45:17 <Haskellbeginner> yes
03:45:35 <Haskellbeginner> and from an integer 12345 to a list [1,2,3,4,5]?
03:45:36 <ksf> you can use reads, too
03:46:07 <ksf> > map digitToInt "12345"
03:46:08 <lambdabot>   [1,2,3,4,5]
03:46:40 <ksf> the other possibility is to go the long way and do an unfold.
03:47:29 <ksf> :t listToMaybe . map fst . reads
03:47:30 <lambdabot> forall a. (Read a) => String -> Maybe a
03:47:49 <ksf> did I already mention that that one should be in the standard libraries?
03:48:17 <ksf> ...in fact, it should be the default form of read.
03:50:42 <Haskellbeginner> still don't understand how I come from an integer to a list ksf
03:50:47 <sieni> > map digitToInt "abcde"
03:50:49 <lambdabot>   [10,11,12,13,14]
03:50:52 <sieni> cool
03:51:00 <ksf> :t unfold
03:51:01 <lambdabot> Not in scope: `unfold'
03:51:10 <sieni> > map digitToInt "zyxwv"
03:51:11 <lambdabot>   [* Exception: Char.digitToInt: not a digit 'z'
03:51:14 <ksf> sieni, works up to f
03:51:17 <sieni> stupid limitation
03:51:21 <ksf> :t unfoldr
03:51:22 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:51:24 <ksf> :t unfoldl
03:51:25 <lambdabot> Not in scope: `unfoldl'
03:51:40 <ksf> :t divMod
03:51:41 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
03:51:58 <ziman> > map (\x -> chr.round $ 96.75 + (-21.98)*cos(x*1.118) + 13.29*sin(x*1.118) + (-8.387)*cos(2*x*1.118) + 17.94*sin(2*x*1.118) + 1.265*cos(3*x*1.118) + 16.58*sin(3*x*1.118) + 3.988*cos(4*x*1.118) + 8.463*sin(4*x*1.118) + 0.3583*cos(5*x*1.118) + 5.878*sin(5*x*1.118)) [0..11]
03:51:59 <lambdabot>   "Hello world!"
03:52:03 <ksf> > 12345 `divMod` 10
03:52:04 <lambdabot>   (1234,5)
03:52:12 <ksf> ...that's the first digit.
03:52:36 <ksf> @djinn \(x,y) -> (y,x)
03:52:37 <lambdabot> Cannot parse command
03:52:45 <ksf> @djinn (x,y) -> (y,x)
03:52:45 <lambdabot> f (a, b) = (b, a)
03:53:00 <ksf> @pl \(x,y) -> (y,x)
03:53:00 <lambdabot> uncurry (flip (,))
03:53:19 <Jafet> Free points.
03:53:20 <ksf> > uncurry (flip (,)) (12345 `divMod` 10)
03:53:21 <lambdabot>   (5,1234)
03:53:33 <ksf> that's the right order to put them into Maybe (a,b) above
03:54:12 <ksf> ...but we only want to have them inside a Just if x `div` y is 0, otherwise Nothing.
03:54:12 <ziman> (from http://www.poromenos.org/node/89)
03:54:52 <da-x> is there an easy way to detemine which packages an arbitrary hs module depends on?
03:54:59 <ksf> > (\b@(x,y) -> if y == 0 then Nothing else Just b) $ uncurry (flip (,)) (12345 `divMod` 10)
03:55:04 <SamB_XP_> whoa ... I think I'm in love ...
03:55:10 <lambdabot>   Just (5,1234)
03:55:17 <ksf> > (\b@(x,y) -> if y == 0 then Nothing else Just b) $ uncurry (flip (,)) (1 `divMod` 10)
03:55:19 * SamB_XP_ just opened an OS/2 executable in IDA and looked at the segment list
03:55:29 <ksf> @bot
03:55:29 <lunabot>  :o
03:55:35 <lambdabot>   Nothing
03:55:42 <ksf> wait that won't work.
03:56:00 <zygoloid_> oops
03:56:01 <zygoloid_> my bad
03:56:45 <ivanm> Can anyone see/tell why this seems to hang?  from what I can tell, the problem is in the "evaluate length err" :s http://dpaste.com/122797/
03:57:21 <SamB_XP_> (well, I admit it would be cooler if the segments had *names*, but oh well ...)
03:57:25 <ksf> > ufoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (1 `divMod` 10)) 12345
03:57:29 <ksf> > unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (1 `divMod` 10)) 12345
03:57:38 <path[l]> could someone help me understand this error? I've marked the types of each function http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5022#a5022
03:57:44 <ksf> , unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (1 `divMod` 10)) 12345
03:57:45 <lunabot>  [1]
03:57:59 <Lemmih> ivanm: You can't narrow it down to less than 400 loc?
03:58:10 <ivanm> Lemmih: oh, whoops
03:58:23 <ivanm> Lemmih: sorry, it's the graphvizWithHandle' function
03:58:30 <ksf> , (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (1 `divMod` 10)) 12345
03:58:31 <lunabot>  Just (1,0)
03:58:39 <ivanm> Lemmih: the entire paste was from me trying to bug dcoutts about it, since he helped me write it
03:58:40 <zygoloid> ksf: it was zygoloid_ in the PRIVMSG with the excess flood
03:58:52 * ivanm creates a new paste just for Lemmih 
03:59:14 <ksf> , unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (i `divMod` 10)) 12345
03:59:15 <lunabot>  [5,4,3,2,1]
03:59:15 <ksf> duh.
03:59:15 <ivanm> @hpaste
03:59:22 <ivanm> bah
03:59:25 <ksf> , reverse $ unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (i `divMod` 10)) 12345
03:59:26 <lunabot>  [1,2,3,4,5]
03:59:28 <ivanm> where's lambdabot?
03:59:33 <ivanm> and hpaste is down... :s
03:59:35 <path[l]> my code seems to load fine in ghci but gives me an error at runtime. which is very strange
03:59:53 <zygoloid> , map (\x -> chr.round $ 96.75 + (-21.98)*cos(x*1.118) + 13.29*sin(x*1.118) + (-8.387)*cos(2*x*1.118) + 17.94*sin(2*x*1.118) + 1.265*cos(3*x*1.118) + 16.58*sin(3*x*1.118) + 3.988*cos(4*x*1.118) + 8.463*sin(4*x*1.118) + 0.3583*cos(5*x*1.118) + 5.878*sin(5*x*1.118)) [281..292]
03:59:53 <shambler> * lambdabot has quit (Excess Flood)
03:59:54 <lunabot>  "Hello world!"
04:00:18 <blueonyx> path[l]: you might wanted to call listValidOptions instead of vlidOptions?
04:00:34 <path[l]> oh crap that was dumb of me
04:00:37 <ivanm> Lemmih: http://dpaste.com/122799/
04:00:44 <path[l]> sorry, thanks
04:01:38 <ksf> @pl reverse $ unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (i `divMod` 10))
04:01:43 <ksf> argh
04:02:23 <ksf> > reverse (unfoldr (ap (flip if' Nothing . (0 ==)) (Just . uncurry (flip (,)) . (`divMod` 10)))) 12345
04:02:30 <ksf> , reverse (unfoldr (ap (flip if' Nothing . (0 ==)) (Just . uncurry (flip (,)) . (`divMod` 10)))) 12345
04:02:31 <lunabot>  luna: Not in scope: `if''
04:07:06 <ksf> , reverse $ unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (i `divMod` 10)) 1
04:07:10 <lunabot>  [1]
04:07:12 <ksf> , reverse $ unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (i `divMod` 10)) 0
04:07:13 <lunabot>  []
04:07:32 <ksf> well it's certainly debatable whether that's correct behaviour.
04:07:40 <ksf> , reverse $ unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (i `divMod` 10)) -23
04:07:41 <lunabot>  luna: Couldn't match expected type `[a]' against inferred type `b -> [b]'
04:07:46 <ksf> , reverse $ unfoldr (\i -> if i == 0 then Nothing else Just $ uncurry (flip (,)) (i `divMod` 10)) (-23)
04:07:52 <lunabot>  Killed.
04:08:00 <ksf> that, too.
04:10:05 <mathijsB> good morning
04:10:43 <mathijsB> I am trying to read multiple values seperated by white spaces from a string.
04:11:02 <ksf> , unwords "foo bar"
04:11:03 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char]'
04:11:03 <mathijsB> What is the easiest way to do so? I am thinking about takeWhile ( !isDigit ) and multiple of those
04:11:12 <ksf> , words "foo bar"
04:11:13 <lunabot>  ["foo","bar"]
04:11:24 <ksf> , words "123 456 foo bar"
04:11:25 <lunabot>  ["123","456","foo","bar"]
04:11:43 <mathijsB> ah thanks :)
04:12:02 <kw317> , map read (words "123 456")
04:12:03 <lunabot>  luna: Prelude.read: no parse
04:12:36 <ksf> , map read (words "123 456") :: [Int]
04:12:36 <lunabot>  [123,456]
04:15:43 <Chaze|shigoto> i want a function that takes a list of numbers and returns True if the numbers can be arranged in a sequence. like this:
04:15:44 <Chaze|shigoto> isSequence lst = (map (flip (-) (minimum lst)) (sort lst)) == [0..(length lst) - 1]
04:15:52 <Chaze|shigoto> but that feels a little clumsy
04:16:39 <nominolo> preflex: @users
04:17:01 <nominolo> preflex: users
04:17:28 <quicksilver> Chaze|shigoto: you mean, if they are consecutive?
04:18:38 <quicksilver> I would use something like (zipWith (\a b -> a + 1 == b) lst (tail lst)) to check each pair for consecutiveness
04:18:41 <Chaze|shigoto> quicksilver: yeah, that sounds like the right word
04:18:43 <quicksilver> and then combine with 'and'
04:18:58 <Chaze|shigoto> yeah. that's neat
04:19:19 <Chaze|shigoto> it also shouldn't be restricted to Int
04:19:34 <quicksilver> , let consec lst = and (zipWith (\a b -> a + 1 == b) lst (tail lst)) in consec [3,4,5,6]
04:19:35 <lunabot>  True
04:22:40 <path[l]> could someone explain to me how to create an empty set. Is it just set = Set Int ?
04:23:05 <opqdonut> :t empty
04:23:16 <opqdonut> anyway, Data.Set.Empty
04:23:21 <path[l]> oh doh that was dumb
04:23:22 <ivanm> does writeFIle work with binary data as well?
04:23:27 <opqdonut> *Data.Set.empty
04:23:33 <path[l]> how does it know what type of set it is?
04:23:34 <opqdonut> is the constructor for the empty set
04:23:54 <quicksilver> path[l]: by type inference.
04:23:54 <opqdonut> path[l]: it's polymorphic over the element type
04:23:58 <opqdonut> just like the empty list
04:24:00 <opqdonut> :t []
04:24:06 <opqdonut> gah, still not working
04:24:07 <path[l]> ah right
04:24:15 <quicksilver> #type []
04:24:15 <lunabot>  luna: Not in scope: `type'
04:24:15 <ziman> ivanm, there are bytestrings for binary data, and there's also Data.ByteString.writeFile
04:24:18 <quicksilver> #ty []
04:24:21 <lunabot>  forall a . [] a
04:24:37 <quicksilver> lunabot's type syntax is abit funky though :)
04:25:43 <ivanm> ziman: yeah, I'd prefer avoiding bytestring if I can; I'm having to get the output of a handle and write it to file
04:25:56 <ivanm> the handle may or may not be binary (I can tell from another param that gets passed in)
04:27:18 <quicksilver> ivanm: sounds like a perfect application for Bytestring
04:27:37 <quicksilver> ivanm: the type of the plain "writeFile" is String, which is morally quite wrong for what you're doing
04:27:44 <ivanm> quicksilver: *sigh* I was hoping to avoid another dep...
04:27:49 <quicksilver> (and might stop working in 6.12, I think?)
04:27:57 <ivanm> quicksilver: even if the output _is_ String?
04:28:05 <quicksilver> ivanm: you said it was binary!
04:28:17 <ivanm> quicksilver: it _may_ be binary
04:28:39 <quicksilver> in which case, using the String version may attempt to impose an encoding on it (in 6.12)
04:28:46 <ivanm> :s
04:28:49 <quicksilver> so it's more future-proof to use ByteString, which is intended to be binary.
04:29:03 <quicksilver> in 6.10 or earlier you can get away with using strings for binary stuff though.
04:29:03 <ivanm> quicksilver: so will bytestring still work if the output _is_ text?
04:29:10 <quicksilver> bytestring doesn't care
04:29:16 <quicksilver> text is just a kind of binary data
04:29:21 <quicksilver> (but the converse does not apply)
04:31:22 <ivanm> quicksilver: OK, I have another case where I'm getting the output out from a handle with hGetContents and I _need_ it to be String (since I"ll be parsing it)... will 6.12 complain/do weird stuff?
04:31:48 <ivanm> quicksilver: oh, and with Bytestring, should I make sure that all the handles are indeed in binary mode before using it?
04:33:18 <quicksilver> I've never used a system where 'binary mode' meant anything
04:33:24 <quicksilver> I suppose you probably do.
04:33:49 <quicksilver> if you're using hGetContents then 6.12 will assume the data is UTF-8, as I understand it
04:33:52 <quicksilver> (and decode it accordinaly)
04:34:16 <quicksilver> whilst 6.10 assumes it is 'unicode truncated to 8 bits wide' - which is a bit like iso8859-1 but not exactly.
04:36:10 <ivanm> well, I'm dealing with strings that are [a-zA-Z\200-\377], _, ., \" and digits
04:36:54 <ivanm> that's more than ASCII, isn't it... :(
04:37:19 <ivanm> wait, it's meant to be utf-8 anyway \o/
04:37:29 <ivanm> (but accepts Latin1)
04:37:53 <Chaze|shigoto> > "\200"
04:38:03 <ivanm> , "\200"
04:38:05 <lunabot>  "\200"
04:38:23 <Chaze|shigoto> it should learn to print those :)
04:38:47 <ivanm> , text "\200"
04:38:48 <lunabot>  
04:38:50 <ivanm> heh
04:39:00 <ivanm> , text "\377"
04:39:01 <lunabot>  y
04:39:04 <ivanm> hmmm...
04:39:20 <ivanm> , text ['\200'..'\377']
04:39:36 <ivanm> lunabot: wakey-wakey!
04:52:00 <quicksilver> ivanm: "it's meant to be UTF8 but accepts latin1" ?
04:52:08 <quicksilver> ivanm: but those are incompatible encodings...
04:52:29 <ivanm> quicksilver: yeah, I misread it; you have to tell it to use latin1
04:55:07 <ivanm> quicksilver: so B.hGetContents h >>= B.writeFile "foo" ?
05:01:35 <quicksilver> ivanm: yes. That will pass data totally unchanged
05:01:40 <quicksilver> ivanm: byte-for-byte copy
05:02:23 <ivanm> should the handle be in binary mode?
05:10:20 <zygoloid> presumably a cat-like program which does  getContents >>= writeFile "foo"  will no longer be 8-bit clean in 6.12?
05:10:49 <zygoloid> (that is, you'll need to tell the IO system to do latin1 rather than unicode first)
05:15:15 <ivanm> quicksilver: I'm guessing this new locale stuff is going to cause a lot of problems with compatability for apps that use utf8-string, etc. ...
05:15:33 <ivanm> quicksilver: since things like hSetEncoding are new as well
05:17:37 <quicksilver> zygoloid: yes, it will no longer be 8-bit clean unless you happen to choose an encoding for which all possibilities are valid.
05:17:41 <quicksilver> zygoloid: (IYSWIM)
05:17:54 <ivanm> oh, right, utf8-string still works if you do everything through it or set handles to binary mode
05:18:09 <quicksilver> utf8-string will need patching, won't it?
05:18:15 <quicksilver> doesn't it use the string IO underneath
05:18:32 <ivanm> quicksilver: nope, uses bytestring according to simon marlow
05:18:38 <ivanm> http://ghcmutterings.wordpress.com/2009/09/30/heads-up-what-you-need-to-know-about-unicode-io-in-ghc-6-12-1/#comments
05:18:42 <ivanm> his second comment
05:18:43 <quicksilver> OK, good.
05:19:01 <SamB_XP_> and bytestring uses C, so that's not affected ;-)
05:19:59 <ivanm> quicksilver: so if I use Bytestring.hGetContents, should it be set to binary mode first?
05:20:03 <dolio> utf8-string does have code for doing utf8 on normal strings, as I recall.
05:20:10 <dolio> That will presumably stop working.
05:20:27 <quicksilver> dolio: certainly it becomes a meaningless operation
05:20:42 <quicksilver> since what that operation means is "pretend this String isn't actually a string, but is actually a [Word8]"
05:20:50 <quicksilver> ..and then decde it.
05:21:04 <ivanm> dolio: simon marlow claims it will keep working, since it does it in binary mode
05:21:21 <ivanm> and it will still be useful for compatability purposes (e.g. in xmonad)
05:21:42 <quicksilver> ivanm: that's not the bit dolio is talking about
05:21:50 <quicksilver> he's talking about "decode :: String -> String"
05:21:54 <quicksilver> or whatever it was called
05:21:58 <ivanm> quicksilver: ahhh
05:22:11 <ivanm> dolio: yeah, that'll break
05:22:11 <quicksilver> it's a badly-typed operation which existed to compensate for System.IO's brokenness
05:22:26 <ivanm> and now is completely redundant? :p
05:22:41 <quicksilver> well changing encoding is still valuable, for sure
05:22:42 <ivanm> quicksilver: it does have the advantage of working the same on all OSs, etc.
05:22:52 <ivanm> in that you don't have to worry about what encoding is being used
05:22:53 <quicksilver> decode :: [Word8] -> String is still fine I assume
05:22:54 <quicksilver> for example.
05:23:40 <ivanm> does bytestring expect handles to have binary mode set?
05:25:39 <quicksilver> if SamB_XP is write and it uses C, then it doesn't care.
05:25:45 <quicksilver> s/write/right/ (wtf?)
05:26:09 <ivanm> heh
05:26:12 <ivanm> OK, good-o
05:27:03 <hotzen> hi all, what is the difference between associated types and type families?
05:27:49 <EnglishGent> hello hotzen
05:27:59 <hotzen> hi gent
05:28:27 * EnglishGent has no idea :|
05:28:43 <EnglishGent> a question of my own if anyone knows - what is a 'rigid type variable' ?
05:28:43 <hotzen> k ;))
05:28:46 <quicksilver> hotzen: associated means part of a class
05:28:52 <quicksilver> hotzen: as I understand the terminologu
05:28:57 <EnglishGent> hi quicksilver :)
05:29:04 <hotzen> do they serve the same purpose?
05:29:05 <quicksilver> and associated type family is a type familiy associated with a class
05:29:19 <quicksilver> you can also declare them outside classes, in which case they aren't associated
05:29:26 <hotzen> ah
05:29:29 <hotzen> thanks alot!!
05:29:34 <quicksilver> http://www.haskell.org/haskellwiki/GHC/Type_families
05:29:40 <quicksilver> is a reasonably comprehensive rundown
05:29:43 <FunctorSalad_> does the association add anything special?
05:29:51 <FunctorSalad_> except enforcing that you define both
05:29:58 <hotzen> re-reading it *shame on me*
05:30:28 <quicksilver> FunctorSalad_: well, it means the type infererer generates class constrains for you
05:30:55 <hotzen> one more thing,  does the term "indexed" mean anything special?
05:31:09 <quicksilver> FunctorSalad_: if the family "Foo a" is defined as part of class "Bar a" then by using "Foo b" the compiler will generate the constraint "Bar b"
05:31:12 <quicksilver> I think that's the point.
05:31:22 <RayNbow> hmm... are there any differences between (let x = foo in e) and (\x -> e) (foo)?
05:31:42 <FunctorSalad_> quicksilver: hmm makes sense... for bare type families the "constraint" is invisible?
05:31:45 <hotzen> what is mean with constraint?
05:31:52 <RayNbow> (except that lets are more convenient to type)
05:31:52 <quicksilver> hotzen: (Num a) => a -> a
05:31:56 <FunctorSalad_> the things before the =>
05:31:58 <hotzen> thanks
05:32:08 <quicksilver> RayNbow: yes, a subtle monomorphism distinction I think.
05:32:26 <quicksilver> > let x = id in id id
05:32:31 <quicksilver> , let x = id in id id
05:32:33 <lunabot>  PRIVMSG #haskell : luna: No instance for (GHC.Show.Show (a -> a))
05:32:39 <FunctorSalad_> ^^
05:32:41 <quicksilver> #ty let x = id in id id
05:32:43 <lunabot>  forall a . a -> a
05:32:50 <quicksilver> #ty let x = id in x x
05:32:51 <quicksilver> sorry!
05:32:52 <lunabot>  forall a . a -> a
05:32:56 <BONUS> RayNbow: well they're both just e
05:32:56 <RayNbow> hmm, lambdabot dead again? :p
05:33:01 <quicksilver> #ty (\x -> x x) id
05:33:03 <lunabot>  luna: Exception when trying to run compile-time code:
05:33:07 <BONUS> so why write (let x = foo in e) at all
05:33:09 <quicksilver> RayNbow: do you see?
05:33:14 <RayNbow> quicksilver: yeah
05:33:19 <quicksilver> RayNbow: the lambda captures the id monomorphically
05:33:25 <quicksilver> the let binding allows it to stay polymorphic
05:33:31 <RayNbow> BONUS: oh, e stands for an arbitrary expression... probably using x
05:33:35 <BONUS> ah
05:33:40 <BONUS> quicksilver: not for long!
05:33:51 <RayNbow> quicksilver: thanks :)
05:33:55 <quicksilver> hotzen: indexed doesn't mean much.
05:34:10 <quicksilver> hotzen: 'indexed family of types' is a 'family of types indexed by types' also known as a type function.
05:34:26 <hotzen> thanks. and whats about this monomorphical? is this an important topic when using the whole type-families-thingy?
05:35:00 <hotzen> sorry if asking dumb questions ...
05:35:24 <hotzen> I know polymorphic and heard about monomorphical in ocaml but i have no clue what it is for
05:35:39 <quicksilver> hotzen: that discussion was with RayNbow it wasn't an answer to your question :)
05:35:46 <quicksilver> hotzen: monomorphic = having a concrete type
05:35:53 <hotzen> thats all? thanks
05:35:54 <quicksilver> polymorphic = having some free type variables
05:35:55 <EnglishGent> hotzen - dont worry about it (dumb questions) I have that feeling all the time
05:35:58 * EnglishGent very much a newbie
05:36:08 <EnglishGent> I'm glad to report the channel is very friendly :)
05:36:13 <quicksilver> of course in category theory it means something completely unrelated
05:36:18 <quicksilver> but let's not be confused by that :)
05:36:18 <hotzen> yeah, already got to know that ;)
05:36:42 <hotzen> i visited a course about category-theory and it was BF
05:37:01 <hotzen> so, thanks alot, will read further...
05:37:14 <EnglishGent> BF?
05:37:15 <mauke> category theory is, like, my BFF
05:37:46 * EnglishGent recomends "conceptual mathematics" - *easily* the most readable text on category theory I've yet encountered
05:37:47 <opqdonut> :D
05:37:54 <quicksilver> Bloody Fantastic, he means
05:38:00 <quicksilver> it's a very english abbreviation.
05:38:00 <hotzen> hrhr
05:38:14 <quicksilver> I had a whisky sour down the club last night, it was BF, you know old chap?
05:38:20 <mauke> then why does he have a german username?
05:38:21 <EnglishGent> simple enough a high school student could follow it! (something often claimed by books on higher math - but which very rarely true in my opinion!)
05:38:24 <RayNbow> , let f = show in f 3 ++ f 'a'   -- aww... this doesn't work :p
05:38:25 <lunabot>  luna: parse error (possibly incorrect indentation)
05:38:29 <cathper> How to get values from a tuple that is not a pair (then one could use fst and snd). Other options than PM?
05:38:30 <hotzen> i rather meant the famous programming-language...
05:38:44 <hotzen> englishgent: thanks, will note it
05:38:46 <quicksilver> RayNbow: yes, but only because of the monomorphism restriction
05:38:49 <RayNbow> (damn those contexts :p)
05:38:49 <mauke> cathper: not really
05:38:49 <cathper> mauke: Okay.
05:39:01 <mauke> /msg tuple hey, give me your third element
05:39:04 <quicksilver> RayNbow: with -XNoMonomorphismRestriction, or an explicit signature on 'f', it will be fine.
05:39:32 <cathper> mauke: One could define fst, snd, trd, frd for a 4-tuple ...
05:40:02 <EvilTerran> cathper, not with fst for pairs in scope
05:40:20 <mauke> preflex: 6st 1 2 3 4 5 6 7
05:40:21 <preflex>  1st 2rd 3th 4th 5th 6st 7rd
05:40:41 <shrughes> what?
05:40:51 <nvoorhies> lol
05:40:58 <cathper> EvilTerran: Right.
05:41:16 <EnglishGent> could someone please tell me what a 'rigid' type variable is? becuase I've error messages referring to one... and no idea what they are :|
05:41:17 <quicksilver> cathper: I am of the opinion that \(_,_,x)->x is only a few characters to type and as easy to read as 'thd' ot 'thrd' ot whatever you might choose.
05:41:18 <EvilTerran> well, you could probably do something with typeclasses, but it wouldn't be particularly tidy
05:41:27 * EnglishGent making some forays into the wonderful world of MP type classes
05:41:46 <cathper> quicksilver: Right.
05:42:29 <quicksilver> cathper: also I don't use large n-tuples very often.
05:42:37 <quicksilver> if I do, it's normally for big literals
05:42:38 <EvilTerran> with template haskell, you could set things up so $(i `of` n) (x_1, x_2 .. x_n) = x_i
05:42:45 <quicksilver> and then they get "digested" by a single lambda.
05:42:48 <quicksilver> EvilTerran: but, should you?
05:42:52 <cathper> quicksilver: I have a 4-tuple.
05:43:03 <mauke> (a, (b, (c, (d, ()))))
05:43:07 <quicksilver> cathper: treat it well.
05:43:09 <EvilTerran> mauke++
05:43:11 <shrughes> fist, sound, thud, foth, fath, sith
05:43:24 <EvilTerran> altho i'd be using a snd-strict pair constructor
05:43:40 <EvilTerran> so it'd still have the same bottoms as (a,b,c,d)
05:43:42 <RayNbow> @karma quicksilver
05:43:51 <mauke> preflex: karma quicksilver
05:43:52 <preflex>  quicksilver: 12
05:43:58 <RayNbow> quicksilver++
05:44:05 <RayNbow> preflex: karma quicksilver
05:44:08 <preflex>  quicksilver: 13
05:44:27 <akappa> @karma akappa
05:44:37 <quicksilver> (fst,snd) -> (fist,send,thid) -> (first,secnd,third,forth) -> (firsty,second,thirdy,fourth,fifthy)
05:44:40 <RayNbow> someone should bump the karma counter in case quicksilver doesn't like the number 13 :p
05:44:56 <quicksilver> that maintains the invariant that the selectors for a n-tuple use n+1 characters
05:44:58 <shrughes> quicksilver--
05:45:00 <quicksilver> which makes them easy to remember :)
05:45:01 <shrughes> solved :P
05:45:37 <cathper> quicksilver: Neat.
05:46:07 <quicksilver> on reflection "sond" -> "scond" -> "second" is better than the version I chose.
05:51:18 <bastl> @pl printAdjList g = mapM_ putStrLn (adjlist g)
05:51:52 <mmorrow> quicksilver: this is one case where i think the template-haskell solution is the most elegant by a long shot
05:51:58 <BONUS> mapM_ putStrLn . adjlist
05:52:04 <mmorrow> (assuming a tup TH function)
05:52:17 <quicksilver> mmorrow: it's one where I feel there is no need for a solution ;)
05:52:23 <mmorrow> $(tup 5 3) :: (a,b,c,d,e) -> c
05:52:27 <bastl> hmmm...
05:52:29 <bastl> BONUS: @help
05:52:36 <shrughes> ok
05:52:38 <BONUS> unknown command
05:52:38 <shrughes> ok
05:52:41 <bastl> :-)
05:52:46 <quicksilver> mmorrow: but since you're here, what's wrong with hpaste?
05:52:51 <mmorrow> uhoh
05:53:16 <mmorrow> takusen's sqlite driver seems to have problems with sqlite and locking it up
05:53:25 * mmorrow is guessing that's what it is, as firefox boots
05:53:41 <mmorrow> yeah
05:54:08 * mmorrow likes intermittently complaining about the takusen sqlite driver, but never attempting to fix it
05:54:09 <EnglishGent> hpast was down last night
05:54:18 <EnglishGent> I havent tried it again since
05:54:28 <EnglishGent> I got errors about the database being locked (if that helps anyone)
05:54:50 <mmorrow> EnglishGent: i have to restart it, since it has a bug that puts the sqlite db into deadlock
05:55:19 <EnglishGent> np mmorrow - just wanted to make sure the relevant person knew :)
05:55:23 <mmorrow> ok
05:55:41 <mmorrow> oops, ssh'ed to the wrong machine..
05:56:20 <mmorrow> ok, up
05:57:16 <joga> hmm...what do I need in the rc file of lambdabot to make it join a channel with a password? :)
05:57:57 <zygoloid> who has the power to get lambdabot to reconnect?
05:58:08 <mmorrow> Cale
06:00:51 * hackagebot upload: haha 0.3.1 - A simple library for creating animated ascii art on ANSI terminals. (SebastiaanVisser)
06:03:53 <pastah> anyone here good with colors?
06:04:20 <pastah> i have two colors and want to make a list of values between them
06:04:41 <mmorrow> pastah: if you're using, e.g., (r,g,b), that's a 3D space
06:04:47 <mmorrow> so you'll have to choose a path
06:04:49 <pastah> mmorrow: yes, RGB
06:04:52 <mmorrow> (through space)
06:05:03 <pastah> mmorrow: ok, straight line?
06:05:08 <pastah> pros? cons?
06:05:12 <mmorrow> pastah: you can choose any
06:05:17 <FauxFaux> /o\ don't do colour manipulation in rgb, it's far too painful.
06:05:29 <mmorrow> pastah: well, think of it like this:
06:06:00 <pastah> FauxFaux: kinda forced, working with xterms 256 color mode ;)
06:06:05 <zygoloid> pastah: what do you want to do with these values in between?
06:06:13 <quicksilver> most people say that, for an aesthetically pleasing journey between two colours, use HSV or HSL
06:06:15 <pastah> zygoloid: print in xterm!!
06:06:24 <mmorrow> pastah: the unit cube [0,1]><[0,1]><[0,1] is the 3D space you're inside
06:06:36 <pastah> mmorrow: ok, cool
06:06:55 <mmorrow> pastah: the (straight) line from (0,0,0) to (1,1,1) is white to black, and travels through all the greys
06:06:57 <nvoorhies> straight line might not look as smooth as interpolation in another color space that's closer to the metric space defined by your cones' response, which is pretty close to the normal HSV space
06:07:16 <mmorrow> pastah: there's a formula for `intensity', but i forget what it is
06:07:29 <mmorrow> but intensity isn't linear along this line
06:07:45 <mmorrow> since it's derived from the human eye's perception of something or other (iirc)
06:07:55 <pastah> quicksilver, nvoorhies: so i should go from rgb -> hsv, interpolate my n values, and for each hsv color --> rgb?
06:08:24 * EnglishGent thinks it says a lot about this channel that people are talking about metric spaces & cone responses when talking about colours....
06:08:39 <EnglishGent> in other channels people ask me what the RGB values for mirrored are....
06:08:41 <EnglishGent> :)
06:08:45 <mmorrow> pastah: err, i meant (0,0,0) to (1,1,1) is black to white..
06:08:53 <nvoorhies> pastah: yeah that works out a bit nicer, generally
06:09:00 <fasta> quicksilver studied pure mathematics, I think. I don't know about the others.
06:09:01 <gwern> :t maybe
06:09:36 <mmorrow> pastah: i just know this from a computer graphics course i took
06:09:36 <nvoorhies> I did gpu hardware for about 5 years
06:09:44 <pastah> nvoorhies: haha
06:09:48 <pastah> nice :)
06:10:01 <gwern> any ideas about 'let e = authorEmail ra in if e â¡  "" then Just e else Nothing'
06:10:01 <nvoorhies> so I'm kinda cloudy on the software/perceptual side of things
06:10:08 <gwern> * â 
06:10:47 <mmorrow> err, s/pastah/fasta/
06:10:51 <pastah> gwern: maybe :: b -> (a -> b) -> Just a -> b
06:10:53 <mmorrow> well, both i guess
06:11:40 <pastah> haha, i just wanted to make my tetris game look nice... i feel like i got sidetracked here :)
06:12:17 <fasta> mmorrow, yes, me too, but color is not really one of my interests.
06:13:19 <mmorrow> fasta: i find it interesting in the context of digital image manipulation
06:13:59 <fasta> mmorrow, sure interests can change depending on your current goals.
06:14:04 <mmorrow> an image being a map of a (bounded) surface to a 3D colorspace
06:14:11 <mmorrow> well, 4D with alpha
06:14:13 <nvoorhies> I kinda find anything that takes whether I'm looking at it as a parameter to be creepy
06:14:23 <mmorrow> but that's not technically part of the colorspace i suppose
06:14:36 <mmorrow> then it's all linear transformations of vector spaces
06:14:50 <mmorrow> (wrt space and/or color)
06:14:58 <mmorrow> "it" := image transformations
06:15:31 <mmorrow> nvoorhies: heh
06:15:35 <nvoorhies> It'd be nice if you could get info on where eyeballs are pointing when rendering things
06:15:52 <nvoorhies> since outside of the fovea you're going to need little info for hue and saturation
06:16:16 <EnglishGent> nvoorhies - what if there are multiple observers?
06:16:28 <pastah> quicksilver: if i do (map hsv2rgb . extrapolate c0 c1 n . rgb2hsv), then extrapoleta just has to be linear, right?
06:16:41 <nvoorhies> yeah, there's good reasons no one tries to do it
06:17:02 <mmorrow> pastah: if you're using linear interpolation it'll be linear
06:17:15 <pastah> mmorrow: but i'm doing it in HSV space
06:17:17 <mmorrow> (wrt the current colorspace coords)
06:17:19 <mmorrow> yeah
06:17:22 <nvoorhies> and you don't want people throwing up or something if the look down at the keyboard and things go strange and flashy or what have you
06:17:25 <mmorrow> not necessarily linear wrt intensity
06:17:27 <pastah> i understood it as it would look better
06:17:39 <mmorrow> but iirc HSV might have that property
06:17:43 <fasta> nvoorhies, retina displays are already possible, right?
06:18:03 <mmorrow> oh wait, isn't V intensity?
06:18:16 <mmorrow> i think it is (but my memory is hazy)
06:18:29 <nvoorhies> fasta: not that I know of, but I haven't read up on it in a few years
06:18:56 <pastah> http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV
06:18:59 <EnglishGent> they are fasta
06:19:06 <EnglishGent> (retinal displays)
06:19:20 <pastah> well, this was simple :/
06:19:21 <EnglishGent> in fact - we've even a few people with direct connections to the visual cortex!
06:19:44 <EnglishGent> (experimental work of course, but no less impressive for that)
06:19:46 <fasta> EnglishGent, we have? With how much bits of data?
06:19:54 <nvoorhies> EnglishGent: has that moved beyond the 16x16 kind of things?
06:20:30 <EnglishGent> well it's still very crude - but we're up to 64x64 pixel arrays with a few shades of grey in there
06:20:35 <nvoorhies> I remember seeing something that was on the threshold of being useful, but seemed like it'd be worth waiting 5 years on
06:20:41 <EnglishGent> enough that at least one patient was able to drive(!) in a car park
06:20:54 <nvoorhies> nice
06:21:03 <EnglishGent> and we're a *lot* further on with connections to the auditory nerve
06:21:21 <EnglishGent> up to the point where patients can now appreciate music(!)
06:21:22 <EnglishGent> :D
06:21:27 <quicksilver> EnglishGent: you don't need to be able to see to drive ;)
06:21:55 <mmorrow> just memorize the vision test chart!
06:22:01 <EnglishGent> lol!
06:22:13 * mmorrow grandmother did this actually, she's sly
06:22:20 <geekagent> quicksilver: They did it on mythbusters with a seeing person in the back giving directions and a blind guy driving.
06:22:33 <rwx> cochlear implants?
06:22:36 <quicksilver> geekagent: yes, and some blind 90-year old did a lap in racing car for charity
06:22:42 <quicksilver> geekagent: (being directed over headphones)
06:22:54 <mmorrow> left left! NO YOUR OTHER LEFT!!
06:22:59 <quicksilver> but, still, EnglishGent is right that it's impressive
06:23:42 <quicksilver> ok, she was 51, and it wasn't for charity.
06:23:45 <quicksilver> facts are overrated.
06:23:49 <mmorrow> haha
06:23:50 <quicksilver> she *was* blind though.
06:23:57 <quicksilver> http://www.thisislocallondon.co.uk/news/4730834.GRAVESEND__Blind_woman_speeds_to_life_long_dream_at_135mph_at_Brands_Hatch/
06:24:30 <zygoloid> a blind man got a pretty respectable time on the top gear track iirc
06:25:17 <EnglishGent> brb (rl)
06:29:13 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5023#a5023 <--- hi sorry, dumb question. But I've got a type error here that I don't understand
06:30:15 <quicksilver> are you sure you want lists of sets?
06:30:32 <quicksilver> maybe you do
06:30:35 <path[l]> yeah
06:30:48 <quicksilver> what's the type of insertValidOptions
06:30:54 <quicksilver> (be handy to see the error you're getting, to)
06:30:56 <quicksilver> too
06:31:22 <path[l]> oh yeah. insetValidOptions isnt an issue though because the code compiles without allValidSets being defined
06:31:29 <path[l]> gonna add the error to the pastie
06:31:54 <quicksilver> I think the main problem is that fold takes three parameters
06:31:58 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5023#a5024
06:32:00 <quicksilver> and you're giving it two
06:32:11 <path[l]> yeah but Im just currying the right most
06:32:31 <path[l]> oh no Im not
06:32:35 <path[l]> yeah I see the problem
06:32:41 <Gracenotes> *2* rightmost :x
06:34:12 <quicksilver> path[l]: btw that's not currying, it's partial application ;)
06:34:23 <path[l]> isnt that the same?
06:34:28 <quicksilver> nope.
06:34:52 <quicksilver> currying is when instead of having functions which take two parameters, you have functions which take one and return a function.
06:35:02 <quicksilver> partial application is the process of only suppling some parameters.
06:35:11 <quicksilver> :t curry
06:35:19 <quicksilver> #ty curry
06:35:22 <lunabot>  forall c b a . ((a, b) -> c) -> a -> b -> c
06:36:06 <BONUS> i just considered spending the whole day on #haskell pretending that i'm a bot
06:36:09 <BONUS> but then i thought better of it
06:36:33 <EnglishGent> back :)
06:37:04 <path[l]> so you're saying when I use partial application Im using the built in ability to curry?
06:37:06 <EnglishGent> BONUS - how do we know your not a bot?
06:37:16 <EnglishGent> I bet you were programmed to say that!
06:37:27 <BONUS> .:cannot parse:.
06:37:30 <EnglishGent> lol!
06:37:31 <BONUS> OUT OF CHEESE ERROR
06:37:44 <quicksilver> path[l]: no, you're just taking advantage of the convention to write functions in curried style
06:37:54 <quicksilver> path[l]: (taking advantage of that convention and following it)
06:37:57 <EnglishGent> redo from start? :)
06:38:12 <path[l]> I see
06:39:10 <Gracenotes> @botsnack
06:39:10 <lunabot>  :o
06:39:25 <Gracenotes> where is that :)? :o
06:39:42 <BONUS> :o
06:39:53 * medfly pats BONUS 
06:40:29 <vy> How can I negate the value returned by "compare"?
06:40:39 <akappa> vy, not
06:40:50 <Gracenotes> call "flip compare" instead
06:40:53 <akappa> ops
06:41:01 <akappa> by compare
06:41:17 <vy> Gracenotes: Thanks.
06:41:17 <Gracenotes> which.. effectively negates it for a sane 'compare'
06:41:20 * akappa sometimes doesn't read the full question before "answering"
06:42:07 <BONUS> or do (fmap . fmap) not compare
06:42:54 <path[l]> when I use f.g, if g takes multiple parameters can I still write pointless code
06:43:26 <opqdonut> yes
06:43:32 <path[l]> so if I have (Int -> Char).(Int -> Int -> Int -> Int)
06:43:46 <opqdonut> it just becomes a bit uglier :)
06:43:48 <BONUS> if you want Int -> Int -> Int -> Char there
06:43:54 <BONUS> you have to do
06:44:06 <BONUS> ((.).(.).(.)) f g
06:44:24 <opqdonut> > let plus = (+) in (plus.).succ $ 1
06:44:24 <opqdonut> , let plus = (+) in (plus.).succ $ 1
06:44:24 <opqdonut> gah, do we have a bot here?
06:44:25 <lunabot>  luna: No instance for (GHC.Show.Show (a1 -> a -> a))
06:44:29 <path[l]> whoa, wth. Why?
06:45:06 <idnar> @type (.)
06:45:16 <idnar> oh
06:45:21 <idnar> *facepalm*
06:45:49 <EnglishGent> can someone help me with this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12465#a12465
06:45:50 <path[l]> hmm guess it's not worth it
06:45:55 <path[l]> drawing smileys in my code
06:46:01 <BONUS> path[l]: if you do f.g and g takes several parameters
06:46:05 <BONUS> like, two
06:46:10 <BONUS> and you do f.g $ x
06:46:18 <BONUS> then x gets passed to g, which gets partially applied
06:46:27 <BONUS> and a function that takes the remaining parameter gets passed to f
06:46:32 <jmcarthur_work> @let result = (.)
06:46:38 <zygoloid> Defined.
06:46:40 <path[l]> right yeah. I wanted to avoid all the parameters in this case
06:46:40 <jmcarthur_work> oh no lambdabot :(
06:46:52 <jmcarthur_work> zygoloid, ;)
06:46:57 <BONUS> but that's sometimes useful
06:47:08 <pao> @hpaste
06:47:10 <BONUS> e.g. (:).(+1)
06:47:12 <zygoloid> jmcarthur_work: command not understood. for a list, use your imagination
06:47:18 <zygoloid> pao: http://hpaste.org
06:47:28 <jmcarthur_work> (result.result.result) f g
06:47:32 <pao> zygoloid: thanks
06:48:26 <FunctorSalad_> data IPName = IPDup String | IPLin String
06:48:34 <FunctorSalad_> there are linear implicit parameters?
06:48:40 <FunctorSalad_> (that is from haskell-src-exts)
06:49:23 <cathper> From a list [[a1,a2,...,as], [b1,b2,...,bt], ..., [m1,m2,...,mu]] how do I get [ [a,b,...,m] | a <- [a1,a2,...,as], b <- [b1,b2,...,bt], ..., m <- [m1,m2,...,mu] ] ?
06:49:31 <cathper> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5025#a5026
06:49:43 <zygoloid> jmcarthur_work: (result.result.result) ?f ?g :: (Functor f1, Functor f2, Functor f3, ?f :: a -> b, ?g :: f1 (f2 (f3 a))) => f1 (f2 (f3 b))
06:49:47 <cathper> (The lower one is the right.)
06:50:15 <zygoloid> cathper: sequence
06:50:57 <zygoloid> > sequence [[1,2,3], [4,5], [6,7,8]]
06:50:57 <zygoloid> [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,5,6],[2,5,7],[2,5,8],[3,4,6],[3,4,7],[3,4,8],[3,5,6],[3,5,7],[3,5,8]]
06:51:28 <cathper> @src sequence
06:51:54 <tromp_> > sequence . words $ "foo bar"
06:52:12 <cathper> Anyway, neat. Thanks zygoloid!
06:52:17 <zygoloid> sequence []     = return []
06:52:17 <zygoloid> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:52:28 <BONUS> , sequence ["b","aui","t"]
06:52:29 <lunabot>  ["bat","but","bit"]
06:52:40 <quicksilver> tromp_: ["fb","fa","fr","ob","oa","or","ob","oa","or"]
06:52:54 <tromp_> thx, quickbot:-)
06:53:15 <tromp_> or is that silverbot?
06:54:25 <quicksilver> EnglishGent: because the correct definition is comp x y = y . x ?
06:54:43 <Athas> What's the Haskell binding to execvp(3)?
06:55:24 <quicksilver> Athas: to be honest, exec is a bit broken in haskell
06:55:32 <quicksilver> Athas: the RTS doesn't really know how to safely fork()
06:55:34 <EnglishGent> doh! thanks quicksilver! :)
06:56:10 * EnglishGent was looking at the error about 'rigid type variables' & scratching his head!
06:56:36 <Athas> quicksilver: I don't need to fork(), though, so that's OK!
06:57:08 <Athas> quicksilver: though now I'm curious, can't I fork() even if I immediately exec() some other program?
06:57:36 <quicksilver> sometimes it works, apparently
06:58:06 <quicksilver> System.Posix.Process.executeFile
06:58:10 <quicksilver> is your execvp
06:58:33 <quicksilver> although it doesn't let you customise argv[0]
06:59:14 <Athas> I'll probably live, thanks.
07:03:53 <EnglishGent> quicksilver - actually even if you fix the x/y order - it still doesnt behave as I expect -- (comp succ succ) [1..5] gives a type error - whereas I'd expect it to be the same as doing (succ . succ) [1..5]
07:04:04 <EnglishGent> ah!
07:04:06 <EnglishGent> hang on
07:04:07 <EnglishGent> beh!
07:05:01 <EnglishGent> I mean map (succ . succ) [1..5] works - where as map (comp succ succ) [1..5] doesnt
07:05:48 <BONUS> , map (liftM2 comp succ succ) [1..5]
07:05:49 <lunabot>  luna: Not in scope: `comp'
07:05:56 <BONUS> , map (liftM2 compare succ succ) [1..5]
07:05:57 <lunabot>  [EQ,EQ,EQ,EQ,EQ]
07:06:10 <BONUS> oh wait tjat's not the same lol
07:07:29 <ivanm> hmmm, is it bad when quickcheck does over 3000 shrinks and keeps going? :s
07:10:05 <ivanm> gah, worked out why... shrink for one of my datatypes kept going shrink f = [f] :s
07:10:42 <hotzen> "... must be fully saturated w.r.t. to that arity" what does w.r.t. mean?
07:11:20 <hotzen> with respect to? is the additional "to" a typo?
07:11:28 <rwx> hotzen, with respect to
07:11:32 <hotzen> thank you
07:11:33 <mokrzu> hello, i new in haskell and have some questions, first what's pure code and "no side effects" when i declarete function in for egz. python i think it return always the same value for the same argument, isn't it ?
07:11:49 <mokrzu> what's the difference ?
07:12:06 <EnglishGent> well code that always returns the same values for the same inputs is 'deterministic'
07:12:18 <hotzen> "always the same value" is the definition of the mathematical function
07:12:18 <EnglishGent> pure code is deterministic - but not necessairly vice-versa
07:12:36 <rwx> mokrzu, http://en.wikipedia.org/wiki/Pure_function
07:12:47 <hotzen> side effects are for example outputs to the console. things the functions does "hidden" without defining it with its signature
07:12:48 <EnglishGent> for example - imagine  a function (psudo code) f(x) = {print x; return x + 1}
07:13:07 <EnglishGent> that's determinstic - but it has side effects - it prints something on the screen
07:13:37 <path[l]> > words "1 1 1"
07:13:43 <EnglishGent> hi btw mokrzu :)
07:14:19 <path[l]> how do I convert ["1","0","1"] to [1,0,1]
07:15:08 <zygoloid> map read, map (digitToInt . head), const [1,0,1]... any number of ways :)
07:15:12 <rwx> mokrzu, the big deal about purity is that 1) they don't mutate things (state), so it makes parallelism easier, 2) by being pure, one can reason about them easier (in fact, the compiler can make nontrivial optimizations because of this)
07:15:12 <mokrzu> hi :) ok, now i understand it
07:15:24 <zygoloid> map (length . filter (=='1'))
07:15:27 <path[l]> digitToInt ah
07:17:10 <quicksilver> EnglishGent: it works but you need to annotate the types
07:17:36 <kohwj> what's the most insane, mind-blowing haskell program you've seen?
07:18:16 <quicksilver> EnglishGent: > map (comp (succ :: Int->Int) (succ :: Int -> Int)) ([1..5] :: [Int]) :: [Int]
07:18:20 <quicksilver> [3,4,5,6,7]
07:18:37 <quicksilver> EnglishGent: if you can understand why it needs all those annotations, you will have learnt a lot about haskell type inference + MPTCs.
07:18:37 <mokrzu> secondly, what should i use as version control system, GIT or Darcs ? (I know git yet) ?
07:18:46 <quicksilver> if you know git and like it, use it
07:19:00 <quicksilver> learning another DVCS is just a distraction from what you really wanted to spend your time doing.
07:19:13 <EnglishGent> I was about to ask quicksilver - becuase I dont .. this is my first forray into MPC though
07:19:26 <mokrzu> ok, thanks
07:19:56 <quicksilver> EnglishGent: ok, well let's suppose we only annotate one type, to give just a little concreteness
07:20:15 <quicksilver> EnglishGent: map (comp succ succ) ([1..5] :: [Int])
07:20:29 <quicksilver> EnglishGent: (really just because I don't want the polymorphism of numbers to get in the way of explanation)
07:20:42 <quicksilver> EnglishGent: now, it's look for an instance of Comp x y z
07:20:47 <hotzen> what are "forall types" ?
07:20:53 <EnglishGent> use strings then? (no polymorphism) -- just a suggestion :)
07:21:02 <quicksilver> EnglishGent: it knows "z" is a function, because you're using comp succ succ as a parameter to map.
07:21:11 <EnglishGent> okay...
07:21:18 <quicksilver> EnglishGent: it knows it's of the form (Int -> w)
07:21:25 <quicksilver> because you're applying it to a list of ints.
07:22:16 <quicksilver> it's knows x and y are functions of the form (a->a) (b->b) because of the type signature of succ
07:22:21 <quicksilver> #ty succ
07:22:24 <lunabot>  forall a . Enum a => a -> a
07:22:28 <byorgey> hotzen: a polymorphic/parametric type.  for example,  'forall a. [a] -> Int'  is the type of a function which can take a list of any type, and return an Int
07:22:44 <quicksilver> EnglishGent: so it's looking for an instance like "Comp (a -> a) (b -> b) (Int -> w)"
07:22:46 <byorgey> hotzen: note that in Haskell the type  [a] -> Int  has an implicit 'forall a.' at the beginning
07:22:48 <quicksilver> EnglishGent: with me so far?
07:22:53 <rwx> byorgey, so the "forall a" is redundant, given how we usually read type signatures?
07:22:57 <rwx> ok
07:23:07 <EnglishGent> so far :)
07:23:48 <quicksilver> EnglishGent: unfortunately, that's all it knows.
07:23:57 <quicksilver> EnglishGent: now the only instance it has is the one you gave it.
07:24:17 <quicksilver> EnglishGent: if it was sure that a == b == w == Int then it could see how to use it.
07:24:25 <quicksilver> EnglishGent: but it doesn't know that, and it's not allowed to assume it.
07:24:36 <hotzen> byorgey: what is the reason for the implicit forall a. ?
07:24:41 <quicksilver> EnglishGent: haskell is obliged to find the most polymorphic instance or nothing.
07:24:47 <EnglishGent> ah
07:24:54 <hotzen> is the "." from the normal dot-free notation?
07:25:15 <byorgey> hotzen: no, this is a different ".", it's just syntax
07:25:16 <EnglishGent> hmm .. I need to think about the implications of this
07:25:24 <quicksilver> EnglishGent: do. it takes a while.
07:25:34 <hotzen> what if i omit it?
07:25:50 <byorgey> hotzen: if you omit the "."?  that would be a syntax error.
07:25:57 <hotzen> no the whole forall-expr?
07:26:27 <byorgey> hotzen: right, you are allowed to omit the 'forall a.': by convention, any lowercase identifier in a type has an implicit 'forall' at the beginning
07:26:38 <byorgey> forall a. [a] -> Int  and  [a] -> Int  are exactly the same type
07:26:40 <hotzen> hm
07:26:56 <byorgey> the latter is really just a shortcut for the former.
07:27:32 <mmorrow> kohwj:
07:27:38 <hotzen> so whats the exact purpose of forall? is this some tricky semantic?
07:27:40 <mmorrow> , fix ((0:) . scanl (+) 1)
07:27:41 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
07:27:53 <mmorrow> kohwj: ^
07:28:10 <byorgey> hotzen: have you ever studied any logic?
07:28:16 <medfly> I think it makes mathematicians feel at home
07:28:25 <mmorrow> kohwj: well, not really the *most* mind-blowing, but that's a cool one-liner
07:28:36 <byorgey> hotzen: it's not tricky.  'forall a' just means 'this works for ANY value of a'
07:28:40 <hotzen> byorgey: i dont understand your question
07:28:58 <EnglishGent> @hoogle [Char] -> [Char]
07:28:59 <hotzen> i didnt know this has to be explicitly stated, even if its implicitly stated
07:29:26 <EnglishGent> is lambdabot dead again? :|
07:29:29 <tromp_> , let f a b = a:f b (a+b) in f 0 1
07:29:30 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
07:29:36 <mmorrow> exists x in X such that forall y in Y, blah blah
07:29:47 <medfly> kohwj, http://uncyclopedia.wikia.com/wiki/Haskell#Haskell_Code_Examples
07:29:47 <medfly> kohwj, the let thing :)
07:30:32 <byorgey> hotzen: well, the 'forall' comes from logic where it is known as the "universal quantifier", which is why I asked.  But if you haven't studied logic then that's OK.
07:30:39 <mmorrow> forall a. ..... is leaving the "forall a __in HaskellTypes__. ...." implicit
07:30:46 <hotzen> ah, the alquantor
07:30:50 <hotzen> k
07:31:17 <quicksilver> hotzen: I think your questions are being taken in the wrong way
07:31:31 <quicksilver> hotzen: there is *no* point to forall, because forall is NOT IN HASKELL :)
07:31:37 <quicksilver> forall is not part of the haskell standard.
07:32:04 <quicksilver> however, forall has been adopted as a keyword by various haskell implementations - including GHC - because it enables you to express richer types than you can with plain haskell-98
07:32:20 <hotzen> ok, thank you
07:33:09 <quicksilver> the convention of an implicit forall is shared by ML
07:33:24 <quicksilver> but the limitation of the convention is it assumes all your foralls bunch up to the top level
07:33:29 <quicksilver> which makes some types inexpressible
07:33:48 <hotzen> have to think about that. thanks very much
07:34:19 <mmorrow> forall a. (forall a. a -> a) -> a /= forall a. (a -> a) -> a
07:34:26 <mmorrow> (i'm purposely name-shadowing there)
07:34:45 <mmorrow> forall a. (forall a. a -> a) -> a == forall a. (forall b. b -> b) -> a
07:35:40 <Athas> What's the Haskell binding to waitpid?
07:35:55 <mmorrow> (\x -> ... (\x -> ...) ...) `kindaLike` (forall a. ... (forall a. ...) ...)
07:37:46 <ben0x539> Athas: There is a bunch of process starting variants that return an ExitCode, does that do?
07:38:39 <mmorrow> Athas: it's System.Posix.Process.getProcessStatus :: Bool -> Bool -> ProcessID -> IO (Maybe ProcessStatus)
07:39:01 <mmorrow> Athas: with a certain combo of the first two args (i don't recall)
07:39:20 <mmorrow> they control whether you want it to block until the proc exits, and something else i forget
07:39:27 <Athas> mmorrow: many thanks!
07:39:35 <mmorrow> Athas: :)
07:40:13 <Athas> Oooh, this is grand.
07:48:24 * leimy is spending a little time with Go.
07:49:48 <tromp_> the game?
07:49:56 <leimy> Initially I can say that I really prefer how Haskell requires instances of Show for a lot of stuff over the implementation of a method called "String"
07:50:06 <leimy> tromp_: the lanugage :-)
07:50:08 <leimy> er language
07:50:14 <burp> Go or Go!? =)
07:50:18 <leimy> not Go!
07:50:20 <leimy> go
07:50:22 <leimy> :-)
07:50:25 <burp> ok :D
07:50:54 <leimy> I like how Go is based on Plan 9 compilers, and issue 9 is the conflict of name bug request.
07:50:55 <burp> it's not even functional, right?
07:51:05 <leimy> It functions, just not functionally
07:51:08 <leimy> :-)
07:51:11 <medfly> "it's not even functional"
07:51:17 <leimy> It's a functional dysfunctional language
07:51:19 <idnar> I heard a rumour they're renaming it to Issue 9
07:51:32 <leimy> yeah the 9fans were asking if they could name it  Issue 0
07:51:35 <leimy> er Issue 9
07:51:47 <idnar> that's a much more awesome name, tbh
07:51:48 <tromp_> they have name issues
07:51:50 <ksandstr> it tosses some 35 years of declaring variables type-first. can't be a good idea especially if it's for novelty's sake
07:51:52 <leimy> yeah
07:52:06 <leimy> ksandstr: I don't think they did it for novelty's sake
07:52:12 <quicksilver> let x :: Int = 3 ?
07:52:15 <leimy> I think they did it for readability :-)
07:52:24 <quicksilver> or, x :: Int; x = 3;
07:52:31 <sproingie> doesn't go have some local type inference?
07:52:35 <leimy> I don't know how many times i've had to explain that  "int * x, y;" has a problem
07:52:40 <leimy> yes it can do some duck typing
07:52:40 <ksandstr> quicksilver: in the C family. I should have specified.
07:53:01 <ksandstr> leimy: perhaps it's rather that you've got a problem with it
07:53:05 <koeien37> leimy: i write this as "int *x", i think this is quite common
07:53:14 <leimy> ksandstr: I didn't, people think that's 2 pointers
07:53:25 <leimy> also people have trouble with "const int" vs "int const"
07:53:26 <sproingie> it is pretty jarring to make the rest of the language look like C then do that
07:53:27 <leimy> when they're the same
07:53:34 <sproingie> const is just a mess
07:53:41 <koeien37> const int * const p ;
07:53:42 <leimy> yes
07:53:51 <sproingie> #def fnord const
07:53:52 <lunabot>  luna: Not in scope: `def'
07:54:01 <ksandstr> leimy: and they would be wrong. the book they learned C from probably states this explicitly.
07:54:02 <leimy> const int * const p; is the same as int const * const p;
07:54:12 <sproingie> (er #define)
07:54:15 <leimy> ksandstr: yeah... if they used a book :-)
07:54:22 <leimy> or listened in class :-)
07:54:45 <sproingie> it's why i just declare each variable on its own line
07:54:49 <leimy> const always applies to the item to the left of const unless there isn't one there :-)
07:54:53 <leimy> sproingie: that's what I do.
07:54:53 * maltem vaguely remembers the last time doing some thing in C(++), and trying to make the code better by using more "const"s, and failing miserably
07:54:54 <sproingie> if that takes up too much space, i'm using too many variables
07:55:22 <leimy> in C++ it's even worse
07:55:34 <leimy> const member functions
07:55:35 <ksandstr> and then we get the workarounds. one variable per line, eh? why not just learn yourself that "*" goes with the name, not the type?
07:55:46 <leimy> pure virtual functions are "= 0"
07:55:49 <maltem> I think what I tried was passing a variable value to a function that expected a const
07:55:50 <leimy> it's really whacked
07:55:56 <sproingie> const-correctness in C++ is another thing that repels me from the language
07:56:00 <koeien37> they wanted to avoid more keywords, i guess
07:56:12 <leimy> Oh man, const correctness can be overridden by the mutable keyword too
07:56:14 <sproingie> it's one of those "effective C++" things that just makes you realize what a minefield the language is
07:56:19 <ksandstr> java's lack of const-correctness drove me to haskell
07:56:29 <koeien37> i like const correctness, what is wrong with it?
07:56:33 <quicksilver> const-correctness is a good idea
07:56:35 <koeien37> you have to apply it consistently, that is true
07:56:37 <quicksilver> C++ makes it a pain
07:56:37 <ksandstr> exactly!
07:56:43 <quicksilver> but then C++ makes lots of things a pain :)
07:56:47 <leimy> Const correctness is not easy to add if you don't start with it :-)
07:56:50 <koeien37> true
07:56:52 <quicksilver> programming, for starters.
07:56:53 <ksandstr> painful, yet possible
07:56:53 <koeien37> leimy: yeah, ok
07:56:59 <sproingie> haskell has a nice idea of const correctness :)
07:57:05 <sproingie> less severely so does scala
07:57:09 <leimy> that's the tricky bit, and a lot of people don't do it up front, or design for it.
07:57:17 <leimy> I like that values are immutable by default
07:57:17 <koeien37> i really need to spend some time with scala i think :)
07:57:19 <Gracenotes> I do like C++'s idea of requiring const-correctness for some uses of a data structure but not others, at least when you're working with mutable data structures
07:57:24 <leimy> Scala looks great in that respect
07:57:26 <leimy> or Clojure really
07:57:31 <ksandstr> i'd love a C variant that required you to specify mutability, rather than immutability
07:57:33 <leimy> either one can deal with that problem well
07:57:44 <leimy> Though I think I'd lean more towards Clojure
07:58:15 <leimy> ksandstr: I tend to think that way now as well
07:58:16 <Jafet> C is based on a flat, integer-addressed, byte-indexed memory model
07:58:25 <sproingie> clojure's nice when rich doesn't start talking abstractly about state and channelling heidegger
07:58:28 <leimy> yeah, it doesn't really fit C, but I think that way now :-)
07:58:31 <Jafet> Which dates to BCPL, except then you had words.
07:58:39 <Jafet> Types are illusion
07:58:47 <leimy> yeah. ;-)
07:58:58 <leimy> I sometimes think BCPL should be what's used at C's level more than C is :-)
07:59:01 <ksandstr> yes well loops are an illusion too
07:59:07 <leimy> just let me work on bytes and stuff at a higher level than assembly
07:59:11 <koeien37> no, folds are an illusion :)
07:59:13 <leimy> let types come into play later.
07:59:20 <leimy> koeien37: as are unfolds :-)
08:00:09 <Jafet> Watch as the anamorphism causes comprehensibility to disappear!
08:00:14 <leimy> I think I find Go interesting as I've written some Limbo before.
08:00:22 <leimy> and Limbo is pretty neat too.
08:00:30 <leimy> Nothing really ever gets linked in Limbo
08:00:33 <ksandstr> Go almost made me "go" and invent my own damn C-with-batteries language
08:00:36 <leimy> it's just all explicitly loaded :-)
08:00:40 <leimy> kinda erlangy
08:00:55 <dayz> hi
08:01:03 <Jafet> The problem with C is not the lack of batteries. It's the lack of wires.
08:01:17 <dayz> i have a more abstraction question: what type should a first-order logic formula, like an axiom, have? boolean? like \forall x.F(x) = G(x). it's not a boolean expression, right?
08:01:21 <ksandstr> C-with-a-slipknot then?
08:01:56 <quicksilver> dayz: if you're a classicist and you're thinking semantically then yes, it's boolean
08:02:05 <maltem> dayz, data FirstOrderFormula = ... -- ?
08:02:06 <quicksilver> dayz: - it's either true or false, although you may not know which
08:02:56 <quicksilver> dayz: however, that's not very interesting way to model them, of course.
08:03:19 <maltem> "and you're thinking semantically" was the part that I wasn't sure about, apparently
08:03:20 <Jafet> data GEBBool = True | False | Other
08:06:27 <dayz> quicksilver, but it's just an axiom, should it not be true by default already?
08:09:10 <quicksilver> dayz: if it is an axiom, then yes.
08:09:14 <quicksilver> dayz: but that's just a point of view.
08:09:46 <quicksilver> dayz: today you're the axiom, tomorrow you're a theorem and we try to prove you from other axiom(s)
08:11:08 <dayz> thanks
08:11:37 <bogiebro> Why are the AST types in template-haskell and haskell-src so different?
08:11:55 <quicksilver> because one is more concerned with what the code *means*
08:12:03 <quicksilver> where haskell-src is more concerned with how it is *written*
08:12:09 <quicksilver> (so it can be reconstructred in text form)
08:13:04 <bogiebro> none the less, there seems to be an overlap in what they represent
08:13:45 * quicksilver nods
08:13:54 <quicksilver> well they wre written by different people at different times, too ;)
08:14:06 <quicksilver> but there is a difference of emphasis which explains some of the differences.
08:14:09 <Berengal> Still, one has way too much information for the others' needs
08:14:35 <quicksilver> haskell-src-exts > haskell-src, I believe
08:16:04 <Saizan> and haskell-src-meta should have a converter
08:23:12 <toor_> if my data type is like "data abc :: abc { rows :: [[Maybe Int]] } how could I define a such list of abc in a pattern matching? basicly I want to be able to get to thoose two inner "rows" to check if thats length is something. abc [ [Just 2, Just 3, Nothing], [Nothing, Just 2, Nothing] ]
08:23:59 <Botje> sounds complicated.
08:24:01 <Botje> i'd use a guard
08:24:03 <ksandstr> fn (a:b:_) ?
08:24:22 <Twey> Guards sound good.
08:24:39 <toor_> ok guard it is =) thanks gonna test it out see if it works
08:25:27 <Twey> I presume you mean something like foo xs | all ((== 3) . length)
08:25:48 <Twey> Er, xs
08:25:54 <Twey> foo xs | all ((== 3) . length) xs
08:26:19 <toor_> what is foo in this case a [Nothing, Just 2] ?
08:26:33 <toor_> I mean
08:26:37 <toor_> xs is that right but what is foo
08:26:49 <quicksilver> Twey: you're not unwrapping his data
08:26:55 <quicksilver> Twey: which I assume is his main problem
08:27:01 <toor_> yes
08:27:13 <Twey> toor_: foo is a function
08:27:33 <Twey> quicksilver: I'm not sure I understand what's meant by âunwrappingâ the data
08:27:48 <Twey> It's a list â it can only be represented as a list, surely
08:28:07 <Twey> If one extracts the elements, they'll need as many names as there are items
08:28:16 <Botje> he has data ABC = ABC { rows :: [[Maybe Int]] }
08:28:22 <Botje> so just stick a ". rows" in there somewhere
08:28:24 <Twey> Oh, right
08:28:25 <Twey> Yeah
08:28:37 * hackagebot upload: deepseq 1.1.0.0 - Fully evaluate data structures (SimonMarlow)
08:28:53 <Twey> foo xs | all ((== 3) . length) $ rows xs
08:29:09 <Rotaerk> can you pattern match on a record?
08:29:13 <Twey> Rotaerk: Yes
08:29:23 <quicksilver> foo (ABC xs) | all ((==3) . length) $ xs
08:29:26 <quicksilver> or
08:29:28 <Twey> foo ABC { rows = r } | all ((== 3) . length) $ r
08:29:30 <Twey> Or
08:29:34 <quicksilver> foo (ABC {rows =xs}) | all ((==3) . length) $ xs
08:29:36 <quicksilver> haha :)
08:29:43 <Twey> foo ABC {..} | all ((== 3) . length) $ rows
08:29:46 <Twey> Heh
08:29:49 <Botje> you kids and your record syntax.
08:29:54 <Rotaerk> hmm I wouldn't use a list for the rows if their length is to be of a fixed size like that
08:29:56 <toor_> damn =) thanks
08:29:57 <Twey> (that's an extension, though)
08:30:02 <rwx> is there a standard tight-binding infix compose operator?
08:30:04 <Twey> Rotaerk: *nod*
08:30:07 <quicksilver> and a nasty extension at that.
08:30:19 <Twey> rwx: . binds pretty tightly.
08:30:21 <toor_> Rotaerk iam making a function to check that each inner [] inside the outer [] has  the length of 9
08:30:31 <Twey> About the only thing that binds more tightly is function application.
08:30:46 <Rotaerk> toor_, why? is this a requirement, or just a check that's okay if it's false
08:31:07 <rwx> > map (+ 1) . (+ 1) [0]
08:31:21 <Rotaerk> i.e. values with rows of length != 9 are valid or invalid?
08:31:31 <quicksilver> rwx: function application binds tighter than all infix operators, by definition.
08:31:38 <quicksilver> rwx: there is no precedence tighter than application
08:31:54 <koeien37> even not record syntax?
08:31:54 <ksandstr> does this include `backquotes`?
08:32:01 <Twey> Apart from record syntax
08:32:04 <Twey> That's magic
08:32:13 <Twey> (it doesn't really âbindâ per se)
08:32:15 <ksandstr> ... i ask because backquotes is kinda-sorta application too
08:32:16 <rwx> quicksilver, ah.. so the shortest way to write that is map (f . g) [0] ?
08:32:18 <quicksilver> those are not infix operators.
08:32:20 <Twey> (it's just part of the value)
08:32:21 <koeien37> rwx: yeah
08:32:22 <quicksilver> rwx: yes.
08:32:26 <rwx> :-/
08:32:30 <Twey> ksandstr: Yes
08:32:35 <Botje> rwx: map (+2) list *runs*
08:32:39 <Twey> ksandstr: Backquotes by default get very low precedence
08:32:42 <koeien37> rwx: or, [f (g 0)] in this particular case ;-)
08:32:49 <rwx> Botje, that's why i picked f and g the second time ;-)
08:33:03 <Botje> ;)
08:33:06 <rwx> koeien37 :-)
08:33:15 <Twey> :t map $ f . g $ [0]
08:33:18 <rwx> i have to say i'm impressed with how much people here actually talk about haskell
08:33:23 <ksandstr> Twey: thanks.
08:33:23 <rwx> it's not bullshit banter 50% of the time
08:33:24 <mercury^> Twey: that won't work.
08:33:29 <koeien37> well... it *is* #haskell after all
08:33:31 <Twey> It would be nice if we could do that but ARGH \b IS DEAD
08:33:39 <Rotaerk> rwx, bullshit banter gets routed to #haskell-blah
08:33:44 <koeien37> lunabot to the rescue
08:33:50 <koeien37> , 37^2
08:33:51 <Twey> Rotaerk: There's lots of banter, but not much bullshit banter.  âº
08:33:51 <lunabot>  1369
08:33:56 <quicksilver> #ty map $ f . g $ [0]
08:33:58 <lunabot>  luna: Exception when trying to run compile-time code:
08:34:00 <ksandstr> rwx: i like how this channel goes from talking about flowers to infix operator precedence in two seconds
08:34:02 <Twey> Yes, there we are
08:34:13 <Twey> ksandstr: Haha
08:34:35 <quicksilver> I missed the conversation about flowers? Damn.
08:40:36 <m0nkfish> rwx: it's better to have bullshit banter than 'a strict no-LOL policy'
08:40:38 <toor_> quicksilver and Twey I get an parse error : possibly icorrect indention
08:40:48 <m0nkfish> see: the least helpful channel on irc, #python
08:41:01 <koeien37> toor_: can you paste your source code?
08:41:09 <koeien37> toor_: make sure all your parens are matched correctly
08:41:10 <koeien37> ?hpaste
08:41:17 <koeien37> blah lambdabot
08:41:18 <toor_> ye of course one sec
08:41:27 <koeien37> it is in the /topic
08:41:48 <Twey> toor_: If you're talking about the ... $ ... $ ... example, that was just wishful thinking.  $ associates the wrong way, so it won't actually work.
08:42:05 <quicksilver> m0nkfish: I only object to banter if it seems to be stopping people who are trying to conduct on-topic conversations
08:42:12 <koeien37> Twey: that shouldn't give "possibly incorrect indentation"
08:42:12 <quicksilver> m0nkfish: or, if it appears to be offensive
08:42:44 <toor_> koeien37 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12470#a12470
08:42:59 <toor_> Twey ah okey
08:43:03 <toor_> I did that hehe
08:43:06 <koeien37> toor_: yeah, you need a "result" of your function
08:43:09 <Twey> Oh, no, that's not this one
08:43:23 <koeien37> toor_: if the result should be a boolean indicating validity for you, replace the | by a =
08:43:38 <Twey> toor_: You need a) a right-hand side for your function and b) a capital initial for your type
08:44:00 <koeien37> toor_: we thought you wanted to do something else, while checking the validity
08:44:09 <koeien37> toor_: and a capital initial for your data constructor.
08:44:19 <koeien37> toor_: (in addition to what Twey said)
08:45:22 * sproingie looks at newegg's shellshocker discount today.  regular: $39.99.  Discounted: $39.99
08:45:34 <sproingie> after rebate.  what a bargain
08:45:37 <Twey> sproingie: Nice
08:45:48 <toor_> thanks worked fine now. was the guard thing that confused me a little bit
08:45:52 <toor_> you guys are the best =)
08:46:03 <quicksilver> toor_: also, always post (a) enough of the program to actually work - you're missing the data type definition - and also (b) paste the error (not that we needed it this time)
08:46:07 <Cale> toor_: At the type level, the case of the first letter in an identifier distinguishes between whether it's a type variable (lowercase) or a type constructor or type (uppercase).
08:46:20 <quicksilver> Cale: hi. can haz lambdabot? kthx.
08:46:44 <toor_> i see. will do in the future. thanks once again guys
08:46:47 <Cale> sure
08:47:00 <Cale> toor_: At the value level, the case of the first letter of an identifier distinguishes between whether it is a variable or defined value (lowercase) or a data constructor (uppercase)
08:47:15 <Cale> When you do pattern matching, this distinction is important.
08:48:10 <Cale> data constructors actually try to match, while lowercase variable names will be introduced as new variables, and hide any existing definitions for those names
08:48:52 <toor_> I see
08:48:57 <toor_> thanks for the tips
08:49:32 <toor_> next step is to now check that each element in row is a Just 1-9 or a Nothing but haven't given it any time yet so gonna try out some stuff
08:49:48 <koeien37> a sudoku-solver? :)
08:50:24 <toor_> koeien37 correct =)
08:51:48 <mokrzu> what's the RealFloat typeclass ? is it equal to Floating ?
08:52:11 <Saizan> ?src RealFloat
08:52:12 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:52:28 <koeien37> lambdabot! she's back
08:53:37 <Twey> \o/
08:54:15 <Twey> mokrzu: Floating is a subclass of RealFloat
08:54:43 <Twey> RealFloat provides functions for working with different float representations, from what I can see
08:54:54 <quicksilver> Complex is a member of Float
08:54:57 <quicksilver> but not a member of RealFloat
08:55:02 <quicksilver> that's the "point" of it
08:55:16 <quicksilver> if you type :i Float or :i RealFloat in ghci you can see what they compose of.
08:56:33 <Saizan> s/ Float/ Floating/
08:56:43 <quicksilver> thank you.
08:57:01 <quicksilver> "Complex is a member of Floating but not RealFloat" I should have said.
08:57:35 <mokrzu> thanks, it is not explain in tutorial
08:57:45 * hackagebot upload: gnome-keyring 0.2.1 - Bindings for libgnome-keyring (JohnMillikin)
08:57:47 * hackagebot upload: parallel 2.1.0.0 - Parallel programming library (SimonMarlow)
09:21:54 * hackagebot upload: haskeline 0.6.2.2 - A command-line interface for user input, written in Haskell. (JudahJacobson)
09:29:49 <cx> Hi, if I have a list with a list inside that list and what to get the elements from the inner list using patternmatching, how could I do this? I know that for one list its (x:xs) but how does it looks for a list in a list?
09:30:14 <koeien37> :t \( (x:xs) : ys) -> x
09:30:15 <lambdabot> forall t. [[t]] -> t
09:30:20 <koeien37> e.g.
09:30:44 <koeien37> there is nothing special about this case. you can make pattern matching  as complex as you want
09:30:45 <cx> hmm oki
09:31:11 <koeien37> :t (\ Just (((Just 3):xs):ys) -> ys)
09:31:12 <lambdabot>     Constructor `Just' should have 1 argument, but has been given 0
09:31:12 <lambdabot>     In the pattern: Just
09:31:12 <lambdabot>     In the expression: (\ Just (((Just 3) : xs) : ys) -> ys)
09:31:37 <koeien37> :t (\ (Just (((Just 3):xs):ys)) -> ys)
09:31:38 <lambdabot> forall t. (Num t) => Maybe [[Maybe t]] -> [[Maybe t]]
09:32:14 <cx> oki thanks koeien37
09:32:19 <cx> :)
09:53:24 <joe_____> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12472#a12472
09:53:58 <joe_____> i am wondering if u have any thoughts on making the call to readoutput better?
09:54:27 <joe_____> better, in the sense, more functional?
09:54:33 <joe_____> or more haskell-like?
10:00:25 <tromp_> readoutput mydevicehandle $ forthoutput : adcoutput : [] cld be replaced with
10:01:16 <tromp_> sequence (foo mydevicehandle) [forthoutput, adcoutput]
10:01:37 <tromp_> where foo is the loop body of readoutput
10:02:23 <tromp_> or just call foo mydevicehandle forthoutput and then foo mydevicehandle adcoutput
10:02:55 <joe_____> good idea, will give it a shot
10:03:55 <tromp_> in general, explicit tail recursioin is better replaced by a higher order function like sequence
10:08:13 <tensorpudding> @type sequence
10:08:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:09:04 <tromp_> you need sequence_ for that case
10:09:18 <tensorpudding> foldr is my homeboy
10:09:43 <tromp_> i mean for joe's case
10:09:56 <tromp_> :t sequence_
10:09:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:10:44 <tensorpudding> well, if you're sequencing monadic actions, and you don't care about the return values, you want sequence_
10:11:03 <EnglishGent> hello :)
10:11:19 <tensorpudding> > sequence_ [getChar, getChar]
10:11:20 <lambdabot>   <IO ()>
10:11:40 <tensorpudding> that's interesting...
10:17:37 <Vulpyne> @src sequence_
10:17:37 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:18:58 <tensorpudding> if it's take a list and giving a value back, it's probably able to be implemented using a fold
10:19:09 <tensorpudding> err, if it takes*
10:19:47 <joe_____> with all the do's in the code, I feel that I am going back to the days of imperative coding.
10:20:02 <tensorpudding> you can desugar it if you think that would help
10:20:11 <joe_____> hence, wanted to check with you folks on how u would have done it..
10:22:12 <toor_> This works correct, it checks a row and check that the inputs are valid. But I want to check the next row aswell and tried to get ys and so in the mix but no luck.
10:22:16 <toor_> isSudoku (Sudoku ((x:xs):ys)) = (all (`elem` [Nothing] ++ map Just [1..9]) $ (x:xs))
10:23:05 <toor_> i rather not do it recursivly if there is a way to do it the other way because I am thinking of putting that expression inside a list and check some other stuff and then use and to see that all stuff I want to check is true
10:23:06 <Vulpyne> What's the next rows? ys?
10:23:52 <tromp_> @src Ix
10:23:52 <toor_> a sudoku is like "Sudoku [ [Just, 4, Nothing], [Just 3]]
10:23:53 <lambdabot> class (Ord a) => Ix a where
10:23:53 <lambdabot>     range           :: (a,a) -> [a]
10:23:53 <lambdabot>     index           :: (a,a) -> a -> Int
10:23:53 <lambdabot>     inRange         :: (a,a) -> a -> Bool
10:23:53 <lambdabot>     rangeSize       :: (a,a) -> Int
10:24:25 <toor_> the one I posted was for checking that the first [] of Just 4 and nothing is okey but I want to check the second [] (just 3) is valid aswell
10:24:59 <toor_> tromp_ was that for me?
10:25:21 <tromp_> you might want to use inRange
10:25:35 <tromp_> actually, i'd use Char for each cell
10:25:44 <tromp_> and test with isDigit
10:26:24 <tromp_> or maybe an unboxed array of Chars
10:27:01 <toor_> so it's not possible to check the other [] with my solution somehow?
12:25:55 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
12:25:55 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
12:25:55 --- names: list (clog BCoppens fbru02_ cognominal Raynes lvillani Scotchy holmak danopia Wild_Cat blueflute Pellwurst_ ravi_n jwp thetallguy astrolabe bos vovik noisetonepause Philippa ulfdoz gnuvince monochrom sigrid leoncamel melba jcapper trofi bogiebro LouisJB Knight_Lord bastl szr rfh s76_ PhilRod james_britt cdiem jimfear novas0x2a borism CosmicRay danly kpreid sprang QplQyer Guest38388 ttt-- Yoric[DT] camio diginux Philonous rdjong jan___ Scriptorius)
12:25:55 --- names: list (zancas Saizan massy aadv Rayne sm chris2 shambler Wraithan drunkenmonkeyboy mpwd blackh Aikawa portnov deavid TR2N ccasin lavish mec70 eagletmt travisbrady mmaruseacph2 lambdabot vili jmelesky levitation_ joe_____ Chaze zakwilson dolio triplez SyntaxNinja mm_freak_ bdimcheff _zenon_ MoALTz dreixel shintah| Mr_Awesome perspectival Apocalisp Icewing conal phyrex1an ezrakilty eivuokko red-agent koeien37 musically_ut Berengal nathanic_work)
12:25:55 --- names: list (trie m0nkfish DeSoVoDaMu augur Rotaerk MacCoasts blastbeat saml oskimura_ Gwern-away ajhager Nshag roconnor medfly mattrepl shrughes lurkymclurkleton kwos McManiaC Modius jrib Keiya iblechbot arjanb OnionKnight mexisme` preflex miccm audiqu Asztal nvoorhies cathper tomh- holzplatten Kim^Walkman ddvlad RayNbow drbean_ TML paulvisschers carlocci meridion FunctorSalad_ fbru02 Nereid aluink epokal jrockway stoop jre2_ skaar abbe spaceodyssey)
12:25:55 --- names: list (cdfh zachk danvet paolino Axman6 dancor wisemanby Beelsebob twanvl macron galdor hackagebot SamB_XP_ m-i-l-a-n StoneToad_ sohum yahooooo sanders_ QtPlaty[HireMe] jabagawee Gracenotes pifish alvarezp otto_s_ caligula_ fhs sunfun dmwit onodrim Dessous ivanm amuck joga Adamant mwc Guest51951 XGas torbenh4 Cobra^^ sgf gOcOOl mun jmcarthur astrocub slbkbs bnijk_ xternal nablaa mreggen FauxFaux mauke eyck MisterN tensorpudding Country-Strike)
12:25:55 --- names: list (BgPerl-VB16 anders^^ fnordus sbok wimt smg jleedev edwtjo daed mattam Annie|Home Laney electrogeek dionoea tew88 ertai kynky dankna spoop jml pikhq ahf qm13 zygoloid newsham mjrosenb joed dilinger karld_ Colours erg _Jordan__ jvoorhis scree tmug crem Cthulhon| byorgey EnglishGent mexisme kw317 Trafalgard Alpounet sioraiocht notweebl qz Esmil dfeuer dobblego gbeshers_home nlogax Botje rdd` Boney_ ClaudiusMaximus rwx dino- xinming zhijie)
12:25:55 --- names: list (noddy mmorrow int-e wharrgarble1 gogonkt JaffaCake vy Poeir Elench ned- hiredman SmurfOR blackdog Khisanth eno angelixd Lycurgus juhp whoppix Draconx Chile mercury^ ErrantEgo gbeshers gjl ksandstr Igloo nazgjunk ggreg_ arvidj leimy StarFire ray rgr samulihs flux im_macie1 dayz bbee jims orbitz stepnem Badger tuukkah DrSyzygy avysk taruti pem bran profmakx allbery_b rapacity netcat sebas_ ski djinni olsner tltstc SeaPrior det clanehin Nafai)
12:25:55 --- names: list (Vulpyne dcolish mjv jfredett Megant mrd BONUS magicman thomastc mshaw ps-auxw dumael sproingie stroan _br_ DRMacIver gdsx BrianHV Zao ac jnwhiteh t nimred Neronus franksh harlekin Stephan202 ben0x539 nornagon peddie Paradox924X tkr loop glitch fritschy soduko pantsd_pcf r0bby Gabbie chrisdone koala_man rasfar lomeo fihi09`` thorkilnaur_ jorizma nathanic erk And[y] BMeph Reisen aep wm_eddie alexsuraci jelly12gen Polarina fredcy tmatix idnar)
12:25:55 --- names: list (EvilTerran +lunabot lefant EvanCarroll gbacon paulvdw CalJohn noj nnunley Exteris alpheccar arjanoosting flori ehamberg osfameron guerrilla sevvie mikste jasonmay cygnus_ aavogt p_l cjay Gilly thetallguy1 Twigathy icee zaarg absentia dqd laz0r tarbo_ marmolak Ferdirand Warrigal Valodim birkenfeld nominolo|uni Baughn poe thedward companion_square authentic jql anekos mmmdonuts malouin qed desu kar-1 mlh droidcore SubStack jfoutz dogmaT kakeman)
12:25:55 --- names: list (suiside mikm Paks webframp pastah wagle_home da-xw sebbe1991 _plcs_ impl mornfall prigaux mmmulani ahihi anji saiam nasloc__ sunnavy ido lanaer wdonnelly jvogel_ poucet Aisling danderson Nanar fxr Milo- shepheb integral wormwood shachaf shortcircuit mokus_ mux theclaw mml`_ bd_ beibmozoi bockmabe_ desp endojelly inimino PHO_ davidL dcoutts_ tromp_ __marius__ saccade reltuk sjanssen nipuL AnMaster MyCatVerbs eek jontore Optimo trez clarkb)
12:25:55 --- names: list (tessier loupgaroublond alexbobp jaj pixel5 ve burp jix linkinus baaba jtra ijnek Eelis m4thrick Jedai Raku^ lhnz jbauman Veinor Tomas heaumer_ LeoD ToRA bind_return araujo sieni eelco_ Lemmih wolverian Liskni_si rey_ Twey Jaak tilman SimonRC Heffalump geoaxis_ deiga_ emias pcc1 tamiko drspider_ ^Einstein ath Tobsan andun jlaire igorgue kalven Jiten jlouis neurocyte felipe_ PeakerWork dixiecko dons hsaliak__ M| andrewsw luite tavelram kolmodin)
12:25:55 --- names: list (kadoban lament emma willb jayne mcclurmc donri kosmikus smiler Arnar Hunner LeCamarade Spaghettini amgarching guerby ystael Spockz shellsage CodeBlock jonafan srcerer nwf koninkje_away arkx BONUS_ wang inclement pragma_ greap agemo aiko Elly cods quicksilver Ornedan_ xian qeb`away _kuningas Innominate jystic ibid ath^_ stalker_ Raevel Bassetts Bleadof Deewiant epmf_ nothingmuch geir_ majoh boyscared Taggnostr equanimity venkatg canvon thoughtpolice)
12:25:55 --- names: list (opqdonut drhodes Sisu ziman AndyP thingwath mdordal2 Vq liff brx midnite Blub\0 mw493 aempirei matthew-_ hellige welterde pettter_ qwr alip dcoutts da-x mfoemmel mfp Cale periodic jones- regulate @ChanServ)
12:26:09 <paolino> that is CReal with ergot
12:28:21 <tromp_> 215 is the smallest uninteresting number
12:28:37 <holmak> How interesting!
12:28:39 <EnglishGent> but that makes it interesting tromp_"
12:28:40 <byorgey> hehehe
12:28:41 <EnglishGent> !
12:28:51 <tromp_> not interesting enough to have its own wikipedia page!
12:29:00 <EnglishGent> fixed soon enough....
12:29:01 <EnglishGent> :)
12:29:04 <monochrom> Oh hahaha
12:29:12 <monochrom> (How did you find out?)
12:29:13 <holmak> aha, wiki-metrics. Your evidence is indisputable
12:29:28 <tromp_> i went through wikipedia pages for 1..214
12:29:36 <monochrom> hahaha
12:29:43 <mikste> http://en.wikipedia.org/wiki/215_(number)
12:29:46 <monochrom> You must have been very borded.
12:30:52 <monochrom> And whoever wrote all those 214 articles for 1..214 must have been very bored too.
12:31:11 <monochrom> "210 is the number after 209"
12:31:12 <tromp_> maybe someone can find the smallest number that doesn't even redirect
12:32:47 <tromp_> somewhere between 1000 and 1100
12:33:01 <Cale> They list a bunch of silly properties of each number that almost nobody actually cares about.
12:33:05 <tromp_> wait; it's less than 1000
12:33:44 <tromp_> http://en.wikipedia.org/wiki/793_%28number%29 has been deleted :)
12:33:48 <Cale> 215 is apparently a Harshad number, which means that it's divisible by the sum of its digits in base 10.
12:34:08 <notweebl> > 215 `mod` 7
12:34:09 <lambdabot>   5
12:34:18 <Cale> er, in some base?
12:34:36 <Cale> But that's silly
12:34:40 <notweebl> i know :P
12:34:45 <Cale> oh, I'm looking at 210
12:34:47 <Cale> sorry :)
12:34:57 <burp> > 210 `mod` (2+1+0)
12:34:58 <lambdabot>   0
12:35:03 <EnglishGent> movie scripts in Haskell....
12:35:06 <Cale> yeah, that's better
12:35:12 <Cale> But nobody actually cares about that property
12:35:19 <EnglishGent> endorse_as_friend AnakinSkywalker Palpatine
12:35:39 <EnglishGent> <interactive> Couldn't match expected type `Trusted`
12:35:47 <notweebl> 330 is the same...
12:35:49 <notweebl> it's not special ^^
12:35:56 <EnglishGent>         against inferred type `Politician`
12:36:06 <EnglishGent> :)
12:36:11 <EnglishGent> (sorry)
12:36:31 <monochrom> base 10 is overrated. I mean, by all means use it in practice, but things like "the base 10 digits add up to a prime number" are stupid, what's so special about base 10 for this.
12:36:41 <tromp_> hmm, the page about 57 is missing some property
12:37:16 <holmak> These properties are useful because number theorists come up with them
12:37:27 <holmak> Then invent category theory or something to prove them
12:37:38 <holmak> Then we have category theory!
12:37:43 <EnglishGent> horray!
12:37:51 <Cale> holmak: heh, the ones which are really by number theorists I don't mind
12:38:12 <Cale> It's the things which are specific to some base representation which are silly.
12:38:17 <monochrom> No. Quite on the contrary, these stupid base 10 properties are ample material to fuel numerology doomsday stories.
12:38:44 <holmak> Is there a #numerology ? Can we troll them?
12:39:01 <EnglishGent> you know I really wish rationalists would stop complaining about the 2012 doomsday thing....
12:39:14 <EnglishGent> the *really* rational thing to do would be to sell the believers insurance...
12:39:15 <EnglishGent> :)
12:39:17 <holmak> But it is plaguing us with godawful movies!
12:39:40 <monochrom> I think the sfx is not godawful. :)
12:39:45 <MisterN> EnglishGent: i'm pretty sure people are trying to do that :)
12:40:03 <holmak> Well, can't argue with SFX.
12:40:13 <FunctorSalad_> insurance for?
12:40:18 <notweebl> > 4111111111111111 :: Int
12:40:19 <lambdabot>   4111111111111111
12:40:24 <notweebl> > 4111111111111111 :: Integer
12:40:25 <lambdabot>   4111111111111111
12:40:34 <koeien37> > maxBound :: Int
12:40:35 <lambdabot>   9223372036854775807
12:41:05 <FunctorSalad_> > 2^64 :: Int
12:41:06 <lambdabot>   0
12:41:06 <notweebl> then i don't understand why i'm suppose to use Integer -> Bool instead of Int -> Bool in a credit card number validation function
12:41:14 <Cale> Hmm, this haXe language has an interesting set of backends, and it's written in O'Caml. It would be nicer as a Haskell library instead of an independent programming language though.
12:41:36 <koeien37> notweebl: Int may have a lower bound on your platform
12:41:42 <EnglishGent> well if there's a disaster which ends civilisation as we know it in 2012 - then you can make a claim FunctorSalad :)
12:42:02 <monochrom> Int may be 32-bit if you use the 32-bit version of ghc
12:42:07 <notweebl> ah that's it
12:42:30 <monochrom> But I don't understand why even 64-bit Int. I would use String.
12:42:52 <koeien37> yes. it's a credit card number, you don't want calculations with them
12:43:01 <FunctorSalad_> Integer seems more efficient and just as good
12:43:11 <FunctorSalad_> (newtype it)
12:43:33 <BONUS> with string you have to worry about encodings and such imo
12:43:44 <BONUS> you might run into some troubles idk
12:43:51 <Cale> notweebl: Also, depending on what you do with the number to validate it, perhaps you need much larger intermediate values? Integer is just safer.
12:43:56 <monochrom> So-called credit card "number", student "number"... are really names (Strings) that happen to use '0', '1', etc. Moreover, sometimes the leading '0's matter, and number types would lose them.
12:44:10 <Cale> Yeah, that's true.
12:44:10 <BONUS> monochrom: good point
12:44:11 <shrughes> Using an integer for credit card numbers is just weird
12:44:24 <FunctorSalad_> monochrom: not with fixed width
12:44:45 <shrughes> credit cards aren't fixed width
12:44:50 <FunctorSalad_> and yes they don't have arithmetic structure, but Integer is a more efficient coding
12:44:58 <notweebl> shrughes: i know, but it's my first assignment to program something in Haskell
12:45:11 <notweebl> so it's a good exercise to know how to split the number into a list etc etc
12:45:13 <BONUS> how about [Int]
12:45:18 <BONUS> for cc numbers
12:45:18 <FunctorSalad_> could matter if you have some enormous spam operation
12:45:24 <notweebl> yeah i am using lists
12:45:39 <FunctorSalad_> ;)
12:45:56 <notweebl> i love the recursion in haskell, so powerful
12:46:18 <monochrom> fixed width assumes you never change the standard. history has shown we have changed the standard many times. just look at phone "number". Hong Kong phone "number" has gone from 6 digits to 7 digits to 8 digits in just 30 years.
12:46:57 <shrughes> credit cards today use different width
12:47:04 <notweebl> all i had to change in this case was to look if the number is uneven as this matters for taking each second digit in the cc#
12:47:13 <notweebl> as in number of numbers
12:47:14 <monochrom> You be doomed if you wrote phone system software that "fix-width"ed 6 digits and then run into your own version of Y2K problems.
12:47:56 <FunctorSalad_> uh so start with a leading one
12:47:58 <FunctorSalad_> (in decimal)
12:48:11 <FunctorSalad_> yes now it's getting adhoccy ;)
12:48:19 <monochrom> Toronto switched from 7 digits to 10 digits just 10 years ago.
12:48:37 <BONUS> what makes people think "but we'll never reach year 2000!" or "hong kong will never have more than 999,999 people!"
12:49:03 <EnglishGent> or 640K will be enough for anyone!
12:49:07 <FunctorSalad_> @google mediocrity demotivator
12:49:08 <notweebl> laziness
12:49:08 <lambdabot> http://despair.com/med24x30prin.html
12:49:08 <lambdabot> Title: Mediocrity
12:49:52 <FunctorSalad_> sorry accidental part
12:50:10 <EnglishGent> wb FunctorSalad :)
12:50:15 <FunctorSalad_> ty
12:50:31 <FunctorSalad_> that poster actually seems like an explanation :)
12:50:34 <Scotchy> credit card number validation is based on each number position. So it's actually not a whole number but a set of 13 - 16 numbers between 0 and 9
12:51:01 <Scotchy> so it is more clever to store it as a list of 13-16 numbers
12:51:09 <notweebl> but i was required to let people enter it as an integer and then convert it to a list
12:51:20 <FunctorSalad_> Scotchy: that's less efficient
12:51:44 <Scotchy> FunctorSalad_, a string consisting of 13-16 characters each being a number can be considered as a list of numbers
12:51:47 <notweebl> people don't want to write [1,2,4,5,2,7,4,2,4,1,2,7,9] when they enter their cc#
12:52:26 <Scotchy> nothingmuch, just let them write the credit card number and then convert it to a list inside your app
12:52:33 <FunctorSalad_> > 64 * (log 2.0 / log 10.0)
12:52:34 <lambdabot>   19.265919722494793
12:52:44 <stroan> are there any decent documents on putting together new cabal packages?
12:52:49 <FunctorSalad_> look, you can store that many decimal digits in one 64bit-word :o
12:52:52 <notweebl> Scotchy: it's what i did if you were referring to me :P
12:52:55 <tromp_> it's a string of digits
12:53:00 <FunctorSalad_> the list of ints will take a lot more memory
12:53:19 <jmillikin> stroan: not that I know of. You might want to take an existing, small package and use the .cabal file as a base
12:53:22 <pikhq> FunctorSalad_: It will then be treated as a list.
12:53:54 <stroan> jmillikin: will do that then. Want to throw up the libexpect bindings I've spent the last while writing and testing
12:54:00 <nomeata> Hi. Thomas Hartman, Magnus Therning or some patch-tag guys here? http://patch-tag.com/r/magnus/dataenc/pullrepo is broken.
12:54:00 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:14 <pikhq> In order to do any validation, he will have to access specific digits.
12:54:29 <pikhq> ... Hmm. Actually, might be better as an array or an n-tuple.
12:54:43 <FunctorSalad_> base conversion is fast, memory can be expensive :)
12:54:49 <jmillikin> stroan: here's an example of a .cabal file for a binding: http://hackage.haskell.org/packages/archive/gnome-keyring/0.2.1/gnome-keyring.cabal
12:54:54 <Scotchy> FunctorSalad_, what's a lot of memory for you ? 16*4bytes is only 64bytes... Which isn't anything huge. If he doesn't need to process billions of CC numbers at once this won't make any difference
12:54:56 <FunctorSalad_> (IANA performance expert, but I gathered that)
12:55:00 <stroan> excellent, cheers
12:55:09 <nomeata> aavogt: re darcswatch: It still exists, but the implementation has changed so the data will be available for new patches only, sorry.
12:55:57 <FunctorSalad_> Scotchy: yes, of course for just a few CC numbers it doesn't matter :)
12:56:06 <rwx> bad idea: learning haskell and ruby simultaneously. hint: you'll quickly hate one of them
12:56:13 <FunctorSalad_> (or just a few thousand)
12:56:16 <pikhq> rwx: Which one?
12:56:54 <ben0x539> ruby, because adding threads makes stuff slower
12:57:02 <pikhq> FunctorSalad_: He needs to process 4096 of them at once for him to start getting L1 cache misses....
12:57:19 <rwx> pifish, well, this is #haskell
12:57:38 <pikhq> rwx: Heheh. Good point.
12:57:40 <FunctorSalad_> uh you didn't count the cons cells and boxes, but admittedly now I'm just arguing for sake of arguing :)
12:57:53 <pikhq> FunctorSalad_: Mmm, right.
12:58:12 <pikhq> FunctorSalad_: Fourth that, I guess?
12:58:24 <FunctorSalad_> dunno
12:58:34 <pikhq> If it starts being an issue, start using unboxed ints?
12:58:56 <rwx> have any of you looked at 'the reduceron'?
12:59:05 <Saizan> in unboxed arrays, presumably
12:59:13 <pikhq> Saizan: Presumably.
13:02:05 <nomeata> Is there a way to tell lambdabot that I prefer that people send me mails instead of lambdabot messages?
13:08:37 <Chaze> huh? can't a create a list of various datatypes if they all share a class?
13:08:37 <mmorrow> no
13:08:37 <mmorrow> (well, kind of, but 80% chance it's not what you want)
13:08:37 <Chaze> so I have to define one datatype that can be constructed with any of my datatypes i want to have in my list?
13:08:37 <mmorrow> class Foo a where foo :: a -> Something; data SomeFoo = forall a. Foo a => SomeFoo a
13:08:37 <mmorrow> foos :: [SomeFoo]; foos = [SomeFoo (9::Int),SomeFoo (Node (Just ()) [] :: Tree ())]
13:08:37 <mmorrow> and then all you can do with them is via the class methods of Foo
13:08:37 <holmak> What are you trying to do, Chaze?
13:08:37 <FunctorSalad_> yeah you'll never recover the original types (except with Typeable)
13:08:37 <mmorrow> as in, you can't ever recover that the head of that list is an Int, unless Something lets you do that indirectly
13:08:37 <pikhq> Chaze: Define a datatype that can be constructed with any of the types you want in the list, probably. It depends on what you're trying to actually do, though.
13:08:38 <BONUS> usually there's an alternative solution though
13:08:38 <Saizan> maybe you don't want a typeclass at all for this
13:08:38 <mreh> I wan
13:08:38 <pikhq> data Foo = Bar Int | Baz | Qux String;
13:08:38 * mmorrow agrees with BONUS and Saizan
13:08:38 <mreh> I want to read Haskore music notationAn algebra of music, can't get to a copy
13:08:38 * pikhq nods at BONUS
13:08:38 * BONUS does a backflip
13:08:50 * mmorrow peddles furiously on a tricycle
13:09:22 * holmak dismounts his hovercraft
13:09:32 <mmorrow> @protontorpedo
13:09:32 <lambdabot> its bs dude
13:09:45 <mmorrow> @protontorpedo
13:09:45 <lambdabot> and haskell is not a lisp. correct? holy shit then m learning haskell
13:10:18 <nomeata> lambdabot: help
13:10:30 <absentia> haskell is lisp withour macros.  wait.. it's lisp++... leisp, next gen done right.. without all the conses.. wait...
13:10:30 <mreh> @list
13:10:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:10:59 <absentia> I always love how bubble sorting with lisp 100 items... does over 2mil conses.  YAY!
13:11:17 <absentia> need a 2MB (min) heap... just to sort 100 numbers.  yay!
13:11:32 <p_l> ... I still wonder why bubble-sort isn't prohibited
13:11:47 <p_l> also, it depends probably how you implement that bubble sort
13:11:56 <absentia> haskell quicksort LOOKS nice.. but quicksort with pointers.. sorts in place...  in haskell, your size is *unknown*  yay!
13:13:00 <Cale> absentia: Use an array?
13:13:01 <mmorrow> @remember p_1 I still wonder why bubble-sort isn't prohibited
13:13:02 <lambdabot> It is stored.
13:13:03 <mmorrow> lol
13:13:12 <absentia> ignore me... I'm just being lame.
13:13:12 <Cale> absentia: quicksort is a sucky algorithm for sorting lists anyway
13:13:46 <BONUS> what's GHC's sort implementation like again?
13:13:50 <BONUS> is it in ST?
13:13:57 <mmorrow> merge sort
13:13:58 <p_l> mmorrow: ... could you fix it so that my nick would be written correctly? It's p_l, not p_1. Papa Underscore Lima
13:14:08 <mmorrow> p_l: heh, oops
13:14:13 <mmorrow> @remember p_l I still wonder why bubble-sort isn't prohibited
13:14:13 <lambdabot> Done.
13:14:22 <Cale> BONUS: It's a mergesort
13:14:26 <Cale> BONUS: No state.
13:14:26 <mercury^> @forget p_1 I still wonder why bubble-sort isn't prohibited
13:14:26 <lambdabot> Done.
13:14:44 * p_l wonders what fonts people use that they mix l and 1
13:14:54 <mmorrow> courier 10 pitch
13:15:02 * mmorrow uses that for everything
13:15:04 <p_l> heh
13:15:08 <Cale> BONUS: Roughly, it maps (:[]) over the list, and then merges adjacent pairs until there's only one thing left.
13:15:08 <mmorrow> :)
13:15:08 <FunctorSalad_> sucky? I thought it was among the best, average-case wise
13:15:16 <Chaze> well, in my case putting everything in one datatype works just as well. I have too few experience to say if that'll always be the case..
13:15:21 <Cale> FunctorSalad_: On *lists*
13:15:26 <FunctorSalad_> ah :)
13:15:28 <FunctorSalad_> missed that
13:15:35 <Cale> FunctorSalad_: Quicksort is not so bad in the average case on mutable arrays.
13:15:36 <BONUS> Cale: ah. i would have thought it would use STArrays for great speed
13:15:50 <Cale> (though it's still quadratic in the worst case)
13:15:52 <mmorrow> p_l: hah, and coincidentally i have a handy visual aid http://moonpatio.com/images/Courier10Pitch.gif
13:16:05 <Chaze> i was mainly using different datatypes for having different implementations of the class functions in the "where" block
13:16:08 <Twey> Those are fairly similar.
13:16:11 <mercury^> Cale: the conversion to array does not affect complexity, does it?
13:16:12 <Chaze> but i guess that's not really the point
13:16:13 <Cale> BONUS: You get some benefits from laziness with mergesort
13:16:19 <p_l> I use Consolas 11pt in urxvt, and I have no problems with 1 and l... despite them having two pixel difference on my screen
13:16:32 <FunctorSalad_> are there any realistic cases where "median of first, middle, last element" gives quadratic behaviour?
13:16:49 <p_l> (Emacs goes with 9pt, because for some reason it scales differently)
13:16:52 * mmorrow checks the pixel diff of 1 and l in courier 10 pitch
13:17:03 <Cale> FunctorSalad_: When someone figures out that's what your algorithm is ;)
13:17:03 <JohnnyL> i hope chromeos doesn't shadow haskell at the server (instead using python or java).
13:17:07 <mmorrow> well, i guess it depends on the fontsize
13:17:19 <BONUS> what does chromeos have to do with haskell
13:17:20 <FunctorSalad_> Cale: didn't take malice into account :o
13:17:23 <mercury^> Firefox has a weird font system.
13:17:34 <mmorrow> p_l: hah, i'm using 5pt font
13:17:52 <JohnnyL> BONUS or better yet, what do you have to do with chromeos?
13:18:04 <absentia> what?
13:18:21 <mmorrow> with 1400x900 resolution
13:18:34 <mmorrow> (and sub-pixel smoothing ftw!)
13:18:36 <FunctorSalad_> Cale: for a moon landing vehicle or something I'd want guaranteed quasilinearity too ;)
13:18:43 <JohnnyL> "<absentia> ignore me... I'm just being lame."
13:18:53 <p_l> I unfortunately have only 1280x800 screen... though I nearly bought once a 15,4" 1920x1200 :)
13:19:17 <mercury^> mmorrow: eek.
13:19:18 <mmorrow> p_l: my last thinkpad was 1024x768, it was slightly painful
13:19:42 <mercury^> Subpixel rainbows are one of the worst inventions ever.
13:19:48 <mmorrow> yay!
13:19:54 <absentia> johnnyl:  ie:  not trying to start a real conversation... or flame war (ie: not a troll).  I'm just interested in good.. new... languages.  There's so much trade off when it comes to using a language.  :-/
13:20:09 <monochrom> 1024x768 is painful because developers assume everyone has 204680x172640 screens.
13:20:18 <absentia> johnny: but sometimes people think anything negative said 'bout a language is baiting or trolling.. and that's not my intention.
13:20:44 <absentia> I don't like macs with x800 or x900... we need more vertical.  I had 1900x1600 on a pc like .. years ago.  now I suffer with vertically challeneges web browsing.
13:20:46 <Chaze> now that I'm working only with one datatype (some overcomplicated version of playing cards), should I even define a class for the operations that are allowed on this type?
13:20:47 <FunctorSalad_> well there are better points about haskell than the hyped 'quicksort' ;)
13:20:53 <mmorrow> monochrom: yeah, code that's wider than 80 pixels causes me to have 4 near-death experiences simultaneously
13:20:57 <absentia> funct: such as?
13:21:03 <mmorrow> monochrom: ummm
13:21:10 <mmorrow> monochrom: s/pixel/cols/
13:21:18 <FunctorSalad_> absentia: the type system, referential transparency
13:21:27 <p_l> mercury^: I actually use subpixel rendering... looks quite nice when it's set correctly... usually
13:21:40 <monochrom> And developers make that assumption because they are given too much money to buy large screens.
13:21:48 <absentia> func: right.
13:22:00 <mercury^> p_l: I hate every type of font display you currently get on computer screens.
13:22:04 <monochrom> I advocate forcing developers to do all their work on netbooks. That will teach them to be considerate!
13:22:07 <mercury^> They need much more DPI.
13:22:41 <p_l> mercury^: I heard of planned >300 DPI flat screens soon
13:22:59 <mmorrow> monochrom: i'd be using my massive resolution wide-screen external display, but i accidentally my thinkpad hd monitor connector cable, and it's some fancypants newfangled one that's impossible to find..
13:23:03 <Apocalisp> @type (>>= maybe (return []))
13:23:04 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (Maybe a1 -> a1 -> m [a]) -> Maybe a1 -> m [a]
13:23:09 <absentia> I just like the idea of `par` on 100,000,000 cores.  :-)
13:23:52 <p_l> mmorrow: DisplayPort?
13:23:57 <BONUS> lol cool nick
13:24:05 <mmorrow> p_l: hmm, not sure
13:24:06 <Apocalisp> @pl (>>= maybe (return []))
13:24:06 <lambdabot> (maybe (return []) =<<)
13:24:14 * mmorrow turns his laptop around
13:24:54 <Apocalisp> BONUS: Love LYAH. Keep it coming.
13:25:16 <mmorrow> p_l: the symbol above it is a "D" with the inner space partially filled in, and it looks like a super usb port, but with the left-hand side flaring out
13:25:26 <BONUS> thanks! moa is in the works!
13:25:41 <BONUS> s/moa/moar
13:25:49 <notweebl> The read function reads input from a string, which must be completely consumed by the input process.  -> can anyone give me a small example of this?
13:25:54 <notweebl> Prelude stuff
13:25:57 <p_l> mmorrow: Looks like mini DisplayPort
13:26:11 <mmorrow> p_l: that sounds probable
13:26:32 <mercury^> mmorrow: or mini DVI
13:26:47 <p_l> and by super-usb you mean that evil contraption of fast link-layer with protocol designed for brain-dead devices? ;-)
13:26:57 <p_l> *physical layer
13:27:00 <mmorrow> p_l: oh, actually it's a regular DisplayPort http://en.wikipedia.org/wiki/DisplayPort
13:27:38 <luite> hm, that looks almost as fragile as the hdmi connectors
13:29:44 <mmorrow> luite: the connector is bigger than it looks in that wikipedia picture
13:29:51 <mmorrow> bigger than usb
13:30:04 <FunctorSalad_> implicit params + GADTs is kinda dragon territory, isn't it?
13:30:13 <mmorrow> @yarrrr
13:30:13 <lambdabot> Yeh scurvy dog...
13:30:15 <FunctorSalad_> doesn't seem to do what I want
13:30:46 <luite> mmorrow: ah, I've never seen one in real life :) my old thinkpad still has a vga connector
13:31:14 <mmorrow> luite: it looks super fragile compared to vga though for sure
13:31:27 <ddarius> VGA pins bend easily.
13:31:32 <mmorrow> heh
13:31:33 <notweebl> can anyone give me an example on how to use read?
13:31:44 <mmorrow> , read "Node () []" :: Tree ()
13:31:46 <lunabot>  luna: Prelude.read: no parse
13:31:47 <ddarius> > read "1" :: Integer
13:31:47 <koeien37> > read "3" ::Int
13:31:48 <lambdabot>   1
13:31:48 <lambdabot>   3
13:31:53 <mmorrow> wut
13:32:11 <mmorrow> , read "Node {rootLabel=(),subForest=[]}" :: Tree ()
13:32:13 <lunabot>  Node {rootLabel = (), subForest = []}
13:32:15 <mmorrow> :)
13:32:24 <notweebl> thx
13:32:42 <MisterN> luite: my new thinkpad has a vga connector, too.
13:32:56 <mmorrow> notweebl: unless some code has explicitly subverted this, (read . show) should be id
13:32:57 <MisterN> in addition to a displayport connector.
13:33:09 <mmorrow> MisterN: yeah, mine too
13:33:21 <mmorrow> although unfortunately the vga out resolution sucks
13:33:40 <MisterN> mmorrow: i guess you need to use displayport or dvi for better quality
13:33:59 * mmorrow mourns for his lost displayport cable
13:34:14 <nomeata> Iâd like to extend lambdabotâs tell plugin, but there seems to be not support for extending a pluginâs state without loosing it...
13:34:55 <FunctorSalad_> to be more specific, I have an implicit param ?prf :: q
13:34:56 <MisterN> mmorrow: :P :P
13:35:02 <FunctorSalad_> now a GADT pattern match refines q
13:35:11 <FunctorSalad_> the type of ?prf doesn't notice, apparently
13:35:24 <FunctorSalad_> should I write up a minimal example and report it?
13:35:31 <FunctorSalad_> or is this expected
13:36:17 <mmorrow> FunctorSalad_: if the type of ?prf it existential wrt the GADT, ghc'll add a field to the GADT and stick the currently in-scope ?prf in there upon construction (like with existential dictionaries)
13:36:42 <sproingie> would an existential dictionary give absurd definitions to everything?
13:36:49 <mmorrow> so you'd be capturing ?prf at creation time of the data (i'm 99% sure)
13:36:59 <FunctorSalad_> mmorrow: existential wrt the GADT?
13:37:08 <FunctorSalad_> ?prf is in context before the GADT match
13:37:08 <lambdabot> Maybe you meant: arr bf part pl rc src url
13:37:14 <FunctorSalad_> but the match should refine it
13:37:33 <mmorrow> data Foo a where Foo :: (?asdf :: b -> a) => Foo a
13:37:50 <mmorrow> hmm, actually looking at that example, i'm not so sure anymore what would happen
13:38:09 <mmorrow> (the `b' being existential there)
13:38:13 <mmorrow> err, better example
13:38:18 <mmorrow> data Foo a where Foo :: (?asdf :: b -> a) => b -> Foo a
13:38:42 <FunctorSalad_> mmorrow: the IP is not inside the GADT in my case
13:38:57 <mmorrow> FunctorSalad_: ah, what's your particular example?
13:38:59 <FunctorSalad_> I'll try to write a minimal example...
13:40:33 <mmorrow> sproingie: just the opposite, it provides the class methods for a thing that's put in an existential box that has a class constraint on the existential type var
13:40:43 <FunctorSalad_> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12593#a12593
13:40:44 <mmorrow> data Foo = forall a. Show a => Foo a
13:40:46 <mmorrow> becomes
13:40:54 <mmorrow> data Foo = Foo (ShowD a) a
13:40:56 <mmorrow> (literally)
13:41:16 <FunctorSalad_> err don't ask me why I called that second function "var" ;)
13:41:21 <mmorrow> where ShowD a = ShowD {showsPrec :: Int -> a -> ShowS, ...}
13:43:31 <mmorrow> FunctorSalad_: hah, i got a panic trying this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12593#a12595
13:44:04 <FunctorSalad_> mmorrow: actually the ?i isn't even necessary
13:44:11 <FunctorSalad_> ?j just isn't an Int
13:44:11 <lambdabot> Maybe you meant: jargon join . ? @ v
13:44:24 <mmorrow> ah, doesn't panic in 6.11.asdf
13:44:30 <FunctorSalad_> mmorrow: :o
13:44:44 <mmorrow> (6.11.20090917)
13:44:44 <sproingie> mmorrow: i was making more a philosophy joke, not a very good one tho :p
13:45:31 <mmorrow> sproingie: s/my response/existential laughter/
13:45:51 <sproingie> hell is other people's code
13:46:22 <mmorrow> FunctorSalad_: aha! with ImpredicativeTypes and
13:46:28 <mmorrow> var :: G ((?j :: a) => a) -> Int
13:46:29 <mmorrow> i get
13:46:37 <mmorrow>     Couldn't match expected type `Int'
13:46:38 <mmorrow>            against inferred type `(?j::a) => a'
13:47:15 <rwx> do you guys indent code manually? the only program to do it that i've found is for emacs, and i do not use emacs :-)
13:47:15 <FunctorSalad_> what are you doing :o
13:47:26 <Twey> rwx: No, we use emacs
13:47:31 <FunctorSalad_> IP *inside* the type argument?
13:47:42 <Lemmih> rwx: I use yi in emacs mode.
13:47:55 <sproingie> i had no idea there was such a thing as implicit type params
13:48:15 <rwx> Lemmih, i tried to build yi the other day but it's broken in cabal/hackage
13:48:52 <FunctorSalad_> sproingie: IPs are values :)
13:49:18 <Lemmih> rwx: The darcs repository is full of goodies.
13:50:07 <mmorrow> FunctorSalad_: this shows how to capture them http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12593#a12601
13:50:27 <mmorrow> not sure if that can be adapted to what you're going for though
13:50:50 <FunctorSalad_> mmorrow: works if you do scoped tyvars and "?j :: a" in the expression :o
13:51:07 <mmorrow> oh nice
13:51:40 <FunctorSalad_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12602#a12602
13:53:21 <FunctorSalad_> I'm using IPs to pass proof objects...
13:53:45 <FunctorSalad_> since type classes aren't quite strong enough for what I'm attempting
13:54:03 <FunctorSalad_> (you can't have reachability in a graph as a typeclass it seems)
13:54:08 <sigrid> is there a shortcut for using Binary get/put on IO Handles?
13:54:19 <FunctorSalad_> (a type graph)
13:54:32 * mmorrow delete "what's the graph here?"
13:54:35 <mmorrow> *deletes
13:55:18 * monochrom writes a lot of zeroes into rwx
13:55:28 <mmorrow> @type \h -> Data.ByteString.Lazy.hPut h . Data.Binary.encode
13:55:29 <lambdabot> forall a. (Data.Binary.Binary a) => GHC.IOBase.Handle -> a -> IO ()
13:55:33 <mmorrow> sigrid:
13:55:54 <rwx> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5028#a5028 this is what happens when i try to build yi from latest hackage. i guess data-accessor is too new?
13:56:06 <rwx> monochrom, actually you don't have privs, i'm chmod 700
13:56:42 <monochrom> oops
13:57:04 <mmorrow> @type \h bytes -> Data.Binary.decode <$> Data.ByteString.Lazy.hGet h bytes
13:57:05 <lambdabot> forall a. (Data.Binary.Binary a) => GHC.IOBase.Handle -> Int -> IO a
13:57:14 <mmorrow> @type \h -> Data.Binary.decode <$> Data.ByteString.Lazy.hGetContents h
13:57:15 <lambdabot> forall a. (Data.Binary.Binary a) => GHC.IOBase.Handle -> IO a
13:57:33 <FunctorSalad_> mmorrow: it's a graph with types as nodes, and edges defined by a GADT
13:57:54 <Kruppe> anyone here use gentoo + xmonad + emacs?
13:57:56 <FunctorSalad_> there's an edge from A to B if "A :>: B" is inhabited
13:58:03 <FunctorSalad_> (where (:>:) is a GADT)
13:58:28 <FunctorSalad_> so I don't think 'there's a path from C to D' can be expressed with classes
14:00:07 <bos> preflex: seen dons
14:00:07 <preflex>  dons was last seen on #ghc 3 days, 21 hours, 56 minutes and 50 seconds ago, saying: dcoutts: ok.
14:00:39 <bos> anyone here know anything about the cereal package on hackage?
14:05:07 <Apocalisp> @pl \f -> f a b
14:05:07 <lambdabot> flip ($ a) b
14:06:23 <Apocalisp> @unpl flip ((flip id) a) b
14:06:23 <lambdabot> (\ e -> e a b)
14:07:11 <Apocalisp> Surely there's a combinator for this.
14:07:53 <BONUS> why would there be
14:07:56 <BONUS> you just do f a b
14:08:09 <Chaze> is Enum the only build-in class that demands "succ" ?
14:08:11 <Apocalisp> BONUS: I don't know what f is
14:08:59 <Apocalisp> @pl \a b -> \f -> f a b
14:08:59 <lambdabot> flip . flip id
14:09:17 <Apocalisp> close enough
14:09:20 <mathijsB> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=12620#a12620
14:09:38 <mathijsB> anyone could give me a hint why im getting a type error on the getContents() line there?
14:09:57 <Chaze> rephrased:i have a function that works on types with a successor function. asking for Enum feels like too much
14:10:04 <mathijsB> im missing it completely, it looks just like in the haskell manual, only it doesnt compile for me :(
14:10:20 <BONUS> :t getContents
14:10:21 <lambdabot> IO String
14:10:26 <BONUS> getContents doesn't take any params
14:10:30 <BONUS> you want hGetContents
14:10:35 <BONUS> :t hGetContents
14:10:36 <lambdabot> Not in scope: `hGetContents'
14:10:43 <BONUS> or wait what's that again
14:10:58 <BONUS> yeah it's hGetContents
14:11:06 <mathijsB> thanks, compiles now :)
14:11:09 <BONUS> strange that lambdabod doesn't know it
14:11:22 <gwern> c.h,o down again?
14:11:22 <mathijsB> can you tell me what getContents is then? hGetContents with std-in orso?
14:11:23 <mmorrow> FunctorSalad_: here's a go at a GADT graph (ended up s/graph/diagram/ since i'm not sure how to make more "interesting" graph shapes than that) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12593#a12621
14:11:44 <mmorrow> err, that should be s/diagram/square/ i guess
14:11:49 <Apocalisp> @pl \b a -> \f -> f a b
14:11:49 <lambdabot> flip (flip . flip id)
14:12:08 <dcestari> hello all, I have a really dumb question
14:12:25 <mmorrow> FunctorSalad_: maybe just keep making graphs of diagrams of graphs of diagrams ... and so on to build up interesting structures?
14:12:41 <koeien37> dcestari: fire it
14:13:12 <mmorrow> FunctorSalad_: not sure the "shape" of the structures that'd let you build
14:13:17 <dcestari> how do I keep a global counter for anything (I know, not functional)
14:13:29 <FunctorSalad_> mmorrow: I already have a particular set of edges
14:13:38 <FunctorSalad_> just need the transitive hull :)
14:13:38 <jmillikin> dcestari: IORef or MVar are the most common choices
14:13:55 <FunctorSalad_> mmorrow: and that works fine with a GADT, just not with classes AFAIK
14:14:03 <mmorrow> FunctorSalad_: how are you storing edges?
14:14:16 <sileni> hello everyone :D
14:14:23 <koeien37> hi sileni
14:14:31 <sileni> how is everyone
14:14:53 <mmorrow> FunctorSalad_: like, you can't have it like you might for the value-equivalent graph, e.g. [Edge]
14:14:56 <dcestari> I need to compare the number of elements on a list of lists
14:15:07 <dcestari> [[a]] I need every [a] to have the same length
14:15:10 <FunctorSalad_> mmorrow: the edges correspond to constructors of the GADT
14:15:15 <sileni> is it wrong to mention this channel to a haskell teacher ><
14:15:28 <mmorrow> FunctorSalad_: oh, so each GADT is a /particular/ graph
14:15:35 <jmillikin> dcestari: get the length of the first list, check that every list is that length
14:15:38 <koeien37> sileni: there are lots of TAs and profs here. i guess it can't hurt :)
14:15:49 <sileni> haha
14:15:50 <FunctorSalad_> mmorrow: yeah :)
14:15:51 <jmillikin> You'd need to decide what to do if the top-level list is empty
14:15:52 <mmorrow> rather than you having a graph GADT that can rep /arbitrary/ graphs (which was what i initially thought you meant)
14:15:55 <dcestari> mmmmm jmillikin you are right
14:16:00 <gwern> sileni: it's an odd haskell teacher who doesn't know of #haskell
14:16:01 <sileni> this is by far the friendliest channel on freenode i have visited lol
14:16:02 <FunctorSalad_> mmorrow: right
14:16:03 <mmorrow> FunctorSalad_: i was scratching my head for a second on that one :)
14:16:11 <dcestari> sileni: yes it is
14:16:32 <FunctorSalad_> mmorrow: and it looks really pretty with the rightwards triangle as name for the GADT ;)
14:16:41 <FunctorSalad_> (unicode)
14:16:54 <mmorrow> ah nice
14:16:58 <FunctorSalad_> data (:â·:) p q where
14:17:24 <FunctorSalad_> it's not a type-level graph library, I just need the transitive hull as a means to an end
14:18:49 <Rotaerk> hmm it'd be nice if SQL were eventually replaced by a functional scripting language
14:19:03 <koeien37> sql is quite declarative
14:19:10 <FunctorSalad_> (the graph defines the set of type parameters that may be reached while folding a GADT)
14:19:12 <Rotaerk> I know
14:19:19 <Rotaerk> the SQL syntax just doesn't lend itself well to its purpose imo
14:19:21 <koeien37> Rotaerk: but it's not the nicest language, yeah
14:19:24 <jmillikin> That'd be like replacing power drills with throw-towels
14:19:27 * Zao hits Rotaerk with some relational algebra.
14:19:48 <deech> Hi all, I have a general noob question. Have you found Haskell to be a good environment for rapid prototyping? For developing tight, readable programs that just work, I have found it wonderful. But I've found getting there from a blank screen is hard for me (harder than, say, Ruby). I know it's pretty broad, but any suggestions?
14:19:51 <Rotaerk> given this simple transform chain:  map (v -> v * v) . filter isOdd . map (+ 1) $ [5, 6, 7, 8]
14:20:08 <Rotaerk> in SQL you'd express it as:  select V1 * V1 from (select Value + 1 as V1 from T) as R1 where isOdd(V1)
14:20:52 <jmillikin> deech: I've been relatively happy with it for prototyping. The best way to start from blank is to start with the top-level type signature, filter down until you've got relatively simple signatures, and then start implementing.
14:21:33 <rwx> deech, i am curious what answers you get!
14:21:55 <OscarZ> Hi.. I'm trying to learn haskell and ran into this simple problem when coding in Java and got the feeling this is the kind of thing that's easy and elegant to do in Haskell. I have an array of array of elements, say [["a","b","c"],["d","e"],["f","g"]] and i want to form all possible combinations of full length of them (in this case 3 strings), eg. ["adf","adg","aef", "aeg", ...] How is this done?
14:22:22 <ben0x539> > sequence [["a","b","c"],["d","e"],["f","g"]]
14:22:23 <lambdabot>   [["a","d","f"],["a","d","g"],["a","e","f"],["a","e","g"],["b","d","f"],["b"...
14:22:33 <mauke> > sequence ["abc", "de", "fg"]
14:22:34 <lambdabot>   ["adf","adg","aef","aeg","bdf","bdg","bef","beg","cdf","cdg","cef","ceg"]
14:22:37 <rwx> OscarZ, also known as the cartesian product
14:22:58 <koeien37> although sequence is somewhat magical if you read the source for the first time
14:23:02 <koeien37> @src sequence
14:23:02 <lambdabot> sequence []     = return []
14:23:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:23:02 <lambdabot> --OR
14:23:02 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:23:45 <rwx> hah it is
14:25:07 <deech> jmillikin: I don't understand by a top-level type signature?
14:25:22 <jmillikin> deech: When you write a function, you can optionally provide a type signature for it.
14:25:29 <jmillikin> for example, main :: IO ()
14:25:52 <sigrid> how can Haskell be told to wait for a few milliseconds?
14:26:09 <koeien37> threadDelay
14:26:11 <OscarZ> thanks.. my hunch was correct it seems ;) i dont understand it though
14:26:19 <koeien37> iirc the argument is in *micro*seconds, take care
14:27:06 <deech> jmillikin: so generate a bunch of top-level signatures and leave the functions undefined?
14:27:16 <jmillikin> deech: right
14:27:34 <jmillikin> You can generally step your way through the logic while writing the signatures, like making sure no types pop out of nowhere
14:27:52 <jmillikin> once the general flow of values is worked out, go through and implement the plumbing.
14:29:36 * kw317 wonders whether someone could recommend good textbook for compiler optimisations
14:29:38 <deech> jmillikin: cool! I'll have to try that next time. I have to say that I had to write some code for a hackfest. In any other language it would be non-trivial, but the Haskell code just worked - so no embarassment!
14:29:51 * kw317 has Principles of Program Analysis and he does not like it too much
14:31:18 <OscarZ> could someone explain this a bit: sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)  ... what's the meaning of "do" and "<-" ?
14:31:33 <koeien37> look up how monads work, basically :)
14:31:37 <koeien37> any monad tutorial will explain it
14:31:38 <Cale> OscarZ: Well, it desugars in terms of >>=
14:31:46 <deech> jmillikin: BTW, I've wanted to ask you about using Noweb for developing your dbus-client and dbus-core. Would you recommending using it with haskell?
14:31:53 <Cale> OscarZ: So if you know about >>= I can explain how it works
14:31:59 <mauke> @undo do v <- x; vs <- sequence xs; return (v:vs)
14:31:59 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
14:32:13 <Rotaerk> hmm is there a list composition function, such that f [1, 2] [3, 4] == [(1,3), (1,4), (2,3), (2,4)]
14:32:16 <OscarZ> Cale: i dont know even that..
14:32:18 <jmillikin> deech: It mostly works pretty well, the only major issue I have with it is that it interacts poorly with Cabal's dependency calculations.
14:32:28 <jmillikin> So I have to keep everything in one file, instead of spreading it out.
14:32:28 <Cale> OscarZ: But what the code *says* is to run x, naming the result v, and then run sequence xs, naming the result vs, and return (v:vs)
14:32:30 <Rotaerk> oh nm list comprehension..
14:32:35 <mauke> > liftA2 (,) [1, 2] [3, 4]
14:32:36 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
14:32:38 <Chaze> roconnor: that's zip isn't it ?
14:32:44 <Chaze> nevermind
14:32:45 <jmillikin> NoWeb also doesn't have any import/include mechanism
14:32:53 <Cale> OscarZ: this is in an arbitrary monad, so what the word "run" means will be different in each case
14:33:21 <Cale> OscarZ: For example, in the list monad, 'run' means "select an element from in all possible ways"
14:33:28 <Chaze> @type liftA2
14:33:29 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:33:34 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
14:33:35 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
14:34:20 <Cale> OscarZ: In the IO monad, "run" means to execute whatever action it is.
14:34:43 <Cale> OscarZ: For instance, the action  getLine  gets a line of text from the user on stdin, and produces a String
14:34:47 <deech> jmillikin: Thanks for your feedback ...
14:35:09 <rwx> cale this is good explanation
14:35:20 <jmillikin> it's still much, much better than the silly "literate haskell" format
14:36:24 <Cale> OscarZ: The do-block itself defines a computation in whatever monad you're using, so effectively, it's used to glue simpler computations together into more complicated ones.
14:36:36 <Cale> OscarZ: do x <- getLine; putStrLn x
14:37:00 <Cale> OscarZ: Will be the action which when you run it, gets a line of text from the user, and prints it back out
14:37:02 <deech> jmillikin: If you're using emacs to develop? If so do you have a multi-mode package to recommend?
14:37:07 <koeien37> jmillikin: what's wrong with lhs + lhs2TeX ? :) i am quite satisfied
14:37:10 <mauke> do x <- getLine; return (map toUpper x)
14:37:16 <jmillikin> `do' is easier to understand as just composing functions. Cale's example could be written as: getLine >>= (\x -> putStrLn x)    or   (getLine >>= putStrLn)
14:37:25 <jmillikin> deech: I use gvim and gedit. no multi-mode, just Haskell syntax.
14:37:40 <Cale> jmillikin: But he doesn't know what >>= is yet. I could explain that too, I suppose.
14:37:41 <jmillikin> koeien37: .lhs is no different from .hs, really
14:38:07 <Cale> There are lots of sensible orders in which to explain this stuff :)
14:38:12 <OscarZ> Cale: please do, if you dont mind :)
14:38:17 <jmillikin> ah, yeah, that would be a good idea.
14:38:19 <jmillikin> OscarZ: http://book.realworldhaskell.org/read/monads.html
14:38:49 <Cale> OscarZ: Do you know about typeclasses and types with parameters?
14:38:51 <jmillikin> I find Maybe to be the simplest monad to understand for beginners, and its implementation of (>>=) is very simple.
14:39:19 <Cale> OscarZ: (just to get some idea of how to tune my explanation :)
14:39:20 <Chaze> Cale's explanation is neat. But can someone explain that?
14:39:21 <Chaze> > [1,2,3] >> ["a","b"]
14:39:22 <lambdabot>   ["a","b","a","b","a","b"]
14:39:30 <koeien37> sure
14:39:34 <koeien37> >> ignores its argument
14:39:42 <koeien37> ehm
14:39:44 <mauke> (>>=) attaches a callback to an abstract "action", forming a new action
14:39:48 <Cale> Chaze: For each element in [1,2,3], you're picking an element from ["a","b"], and it ends up in the result.
14:40:10 <Cale> Callback? Really?
14:40:15 <mauke> yes
14:40:20 <OscarZ> Cale: all i know is of basic function definitions .. such as foobar a b c = b+c
14:40:21 <Cale> Callbacks don't usually have results.
14:40:25 <Chaze> > [1,2,3] >>= ["a","b"] >> return
14:40:25 <mauke> mine do!
14:40:26 <lambdabot>   Couldn't match expected type `t -> [a]'
14:40:26 <lambdabot>         against inferred type `[a1]'
14:40:28 <OscarZ> Cale: and that you can define types for them
14:40:31 <Cale> OscarZ: Okay
14:40:35 <Chaze> > [1,2,3] >>= ["a","b"] >>= return
14:40:35 <lambdabot>   Couldn't match expected type `t -> [a]'
14:40:36 <lambdabot>         against inferred type `[a1]'
14:40:39 <mauke> do you know java interfaces?
14:40:52 <koeien37> > [1,2,3] >> ["a","b"] >>= return
14:40:52 <OscarZ> i know java yes.. i have OO background
14:40:53 <lambdabot>   ["a","b","a","b","a","b"]
14:40:57 <Cale> OscarZ: So, I'll explain.
14:41:20 <Chaze> i was attempting to rebuild a list comprehension
14:41:22 <Cale> OscarZ: In Haskell, we have types with type parameters. You might have seen how if t is any type, then [t] is the type of lists of values of type t
14:41:41 <OscarZ> yes
14:41:49 <Chaze> > [1,2,3] >>= ["a","b"] >>= (\x y-> (x,y))
14:41:50 <lambdabot>   Couldn't match expected type `t -> [a]'
14:41:50 <lambdabot>         against inferred type `[a1]'
14:41:56 <Cale> OscarZ: Or Maybe t is the type whose values consist of the value Nothing, and for each x of type t, the value Just x
14:42:08 <mauke> Chaze: >>= takes a function on the right
14:42:13 <mauke> Chaze: ["a", "b"] is not a function
14:42:17 <koeien37> > [1,2,3] >>= (\x -> ["a","b"] >>= \y -> return (x,y))
14:42:18 <lambdabot>   [(1,"a"),(1,"b"),(2,"a"),(2,"b"),(3,"a"),(3,"b")]
14:42:30 <Chaze> thanks!
14:42:32 <Cale> OscarZ: Similarly, we might have a type M t for some sort of "computations whose result has type t"
14:42:38 <dobblego> Chaze, I think you want liftM2
14:42:53 <koeien37> @src liftM2 -- Chaze
14:42:54 <lambdabot> Source not found. I feel much better now.
14:42:56 <Chaze> dobblego: just fooling around.. what does it do though?
14:43:02 <koeien37> @src liftM2
14:43:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:43:09 <dobblego> Chaze, it does what koeien37 said
14:43:25 <OscarZ> Cale: ok
14:43:33 <ivanm> hmmm.... now quickcheck is giving me a decimal number of shrinks...
14:43:38 <Cale> OscarZ: Many different libraries define something of this sort: they might be parsers, or nondeterministic things, or transactions, ...
14:43:39 <dobblego> > liftM2 (\x y -> (x, y)) [1,2,3] ["a","b"]
14:43:39 <ivanm> and just failed with a segmentation fault! :s
14:43:39 <lambdabot>   [(1,"a"),(1,"b"),(2,"a"),(2,"b"),(3,"a"),(3,"b")]
14:44:09 <koeien37> and (\x y -> (x,y)) is more succinctly written as (,)
14:44:17 <OscarZ> Cale: ok.. what about the inputs of this computation ?
14:44:40 <jmillikin> Computations don't have inputs.
14:44:40 <Cale> OscarZ: Well, for this sort of computation, we'll handle inputs by making functions a -> M b
14:45:03 <mauke> instead of having explicit inputs, we just use functions that build "constant" computations on the fly
14:45:08 <jmillikin> A function can return a computation, which is what's meant when it returns something like "Maybe Int"
14:45:15 <Cale> OscarZ: That is, we'll just write a function which produces a different computation depending on what inputs it gets
14:45:33 <koeien37> putStrLn  will be an examle
14:45:49 <Cale> OscarZ: This is not the most general possible thing we could do, and generalising further gives different APIs, but this seems to have hit a sweet spot in the design space.
14:46:51 <Cale> So what we've done is picked out a small set of generic operations on "computations of some sort", and made a common interface for libraries to implement.
14:47:07 <Cale> and that way, we can have functions like that 'sequence' you mentioned which work in any 'monad'
14:47:35 <Cale> (monads are what we call the type constructors like M which additionally support this extra bit of API)
14:47:43 <Cale> So, what things do we need?
14:48:05 <Cale> The first is that we need a way to make a "computation" which "does nothing but return a given result"
14:48:24 <Cale> This is expressed as a function: return :: a -> M a
14:48:51 <Cale> So, no matter what M we're using,  return 5  will be the computation which "does nothing", and returns the result 5.
14:48:57 <mauke> you could think of it as a simple constructor
14:49:01 <Cale> If it's a parser, it won't eat any text
14:49:09 <Cale> If it's an IO action, it won't have any effects
14:49:22 <Cale> If it's a list, it'll just be the list of one element: [5]
14:50:23 <Cale> Okay, so that's simple enough, but computations aren't very computation-like if we don't have a way to chain them together.
14:51:14 <Cale> So we might start with something like an operation  (>>) :: M a -> M b -> M b  which takes two computations, and produces a computation that does each in turn, returning the result of the second.
14:51:39 <mauke> you may know the "comma operator" from C or Java
14:51:42 <Cale> If they were parsers, this will be the concatenation of the parsers
14:51:58 <Cale> If they were IO actions, this will be the action which does one and then the other
14:52:22 <Cale> But we seem to be wasting the result of the first computation here
14:52:40 <Cale> What if we want what happens next to depend on the result of the first action?
14:52:55 <Cale> So this (>>) is not really the primitive we want (but will be a consequence)
14:53:08 <Cale> Following?
14:54:03 <Cale> OscarZ: ?
14:54:14 <OscarZ> Im reading yes..
14:54:16 <Cale> okay
14:54:30 <Cale> If you want, I'll give you a moment to catch up :)
14:54:42 <OscarZ> Sure, thanks :)
14:54:45 <OscarZ> I need it
14:56:15 <OscarZ> I have a feeling your explanations are very good even though I dont understand them fully ;) I think I might have missed some fundamental concept that makes this so difficult to comprehend..
14:56:40 <koeien37> is there a part you are not sure about?
14:56:48 <mauke> I think it's just very abstract ATM
14:56:54 <Cale> Quite possibly. It's probably not clear at all, for instance, how we're going to define these operations separately for different types
14:56:54 <koeien37> yeah, it is
14:57:06 <mauke> meaning there actually isn't that much to understand
14:57:13 <koeien37> abstract nonsense :)
14:57:30 <Cale> and it should be made absolutely clear that what each of the operations we're discussing does will really depend on each separate implementation
14:57:36 <Twey> Hehe
14:57:43 <Cale> We're describing a common interface to a lot of libraries
14:58:13 <Cale> If you're new to functional programming, the sort of library we're describing may be new to you as well.
14:58:15 <sproingie> a >> b is like "a then b".  "a >>= b" is like "a to b".
14:58:20 <mauke> it might be easier to start with a concrete example or three, then look at the commonalities
14:58:26 <sproingie> what that actually means is totally up to the monad
14:58:37 <koeien37> mauke: i like the approach in RWH :)
14:58:38 <sproingie> (long as it follows a few laws)
14:58:40 <Cale> It's not all *that* common in OO-land to define objects which represent computations of various sorts (though it is done)
14:58:55 <sproingie> Cale: Strategy Pattern perhaps
14:59:06 <koeien37> that would be similar
14:59:18 <Chaze> Can I have an example of this "5" being fed into a list monad and thus being turned into [5] ?
14:59:20 <sproingie> little more fine-grained than strategy
14:59:26 <mauke> > return 5 == [5]
14:59:26 <OscarZ> Cale: yeah, functional programming seems difficult to me.. i dont have a strong math background.. i've understood mathematical structures and haskell are closely related
14:59:27 <lambdabot>   True
14:59:27 <Cale> > return 5 :: [Integer]
14:59:28 <koeien37> > return 5 :: [Int]
14:59:28 <lambdabot>   [5]
14:59:28 <lambdabot>   [5]
14:59:42 <ivanm> @type return 5
14:59:43 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
14:59:46 <Twey> OscarZ: It's okay.  You don't need one.
14:59:56 <mauke> return 5 is sort of like new T(5) except you don't know what T is
14:59:58 <koeien37> OscarZ: semantics of programming languages are also related to mathematics
15:00:00 <Cale> OscarZ: Well, I could give a wildly different description of this stuff if you did have a strong mathematical background, but it's not required.
15:00:02 <mauke> it's a virtual constructor
15:00:36 <Cale> OscarZ: A common theme of functional programming is to write libraries which behave like little programming languages unto themselves.
15:01:26 <h20xt> whats the forall in the type?
15:01:39 <h20xt> ive seen it before, but don't know what it is for some reason
15:01:43 <Cale> OscarZ: That is, they will define some "primitives", and some "means of combination" which let you combine the primitives into more interesting things. Typically the "means of abstraction" -- that is, the ways we give names to things, will be borrowed from whatever language the library is for.
15:01:47 <sproingie> in this case it's gratuitous
15:02:01 <koeien37> h20xt: it just means that it is a type variable.
15:02:08 <Cale> OscarZ: For example in a drawing library, our primitives might be simple lines and shapes.
15:02:15 <koeien37> > [] :: forall a. [a]
15:02:16 <lambdabot>   []
15:02:28 <h20xt> koeien37: is it like the mathmatical forall then?
15:02:42 <Cale> OscarZ: and our means of combination will take one or more drawings and transform or combine them somehow: drawing one on top of the other, rotating things, etc.
15:02:43 <mauke> h20xt: precisely, my dear watson
15:03:12 <Cale> OscarZ: Things of this sort are called "combinator libraries" or "embedded domain specific languages"
15:03:21 <koeien37> h20xt: yeah
15:03:52 <koeien37> h20xt: you can often leave it out in Haskell, except in existential types (and maybe some other places which I can't think of now)
15:03:57 <monochrom> "forall" indicates polymorphism. usually you would think it is redundant. In Haskell98 and SML it is redundant. It becomes necessary to be explicit when you want to write a higher-order function that takes a polymorphic function as a parameter.
15:04:13 <h20xt> ah
15:04:18 <h20xt> that is what i have never used it
15:04:30 <h20xt> koeien37: what are these existential types?
15:04:43 <Chaze> having an existential quantifier in a function signature makes no sense to me at this point :)
15:05:12 <Twey> A type that takes a polymorphic value as a parameter.  ;)
15:05:16 <OscarZ> In the middle of all this abstraction I'm sure I have some concepts "fixed" together in my thinking because of my OO / imperative programming background.. do you have ideas what they could be ?
15:05:16 <mauke> h20xt: it means a value has a concrete type but you don't know what it is
15:05:17 <Cale> OscarZ: Another example might be if you were writing a cookbook application, to have a bunch of primitive ingredients (Water, Flour, Egg, etc.), and then ways to transform and combine ingredients (Chop, Mix, Blend, Bake, etc.)
15:05:24 <koeien37> f :: (forall a. a->a) -> (a,b) -> (a,b)
15:05:39 <koeien37> f g (x,y) = (g x, g y) -- valid
15:06:07 <monochrom> Suppose I want to write a function "funny", it takes a function parameter (call it f), and it has to be polymorphic because in the code I will apply f to both Char and Int, e.g., funny f = (f 0, f 'x')
15:06:10 <sproingie> Cale: that sounds like either I/O or state transformers
15:06:14 <mauke> h20xt: bare existentials are useless, because there's nothing you can do with 'exists a. a'
15:06:25 <Cale> OscarZ: And then we can write functions which capture information about the primitives and are defined recursively on the means of combination, so they can tell us information about any of these things, such as determining the number of calories, or producing a natural language description of how to make the recipe.
15:06:39 <monochrom> The type of funny has to be (forall a. a->Whatever) -> (Whatever, Whatever)
15:06:59 <h20xt> oh wait, so could i have used these to solve a problem i was having trying to write a scheme interpreter
15:07:11 <monochrom> Note that just (a->Whatever) -> (Whatever,Whatever) won't do.
15:07:30 <Cale> OscarZ: (Similar things have been done with financial contracts and hardware designs in place of food recipes, to good effect)
15:07:35 <h20xt> basically i had types that represented scheme types and they were basically wrappers around haskell types but i wanted to apply + to all of them, and i could never get the types to work
15:08:07 <mauke> h20xt: that sounds like it can be solved by enumerating all possibilities
15:08:14 <monochrom> If you had funny :: (a->Whatever) -> (Whatever,Whatever), that would mean funny itself polymorphic (but I don't need it) but f would be monomorphic (this breaks my need).
15:08:19 <h20xt> i didn't wnat to type that much :(
15:08:56 <OscarZ> Cale: let me catch up a bit.. are you by any chance a professor in some university? :)
15:08:59 <Cale> OscarZ: For example, you could write a hardware design library which let you describe a circuit from primitive components, and then have one function for producing a simulation of the circuit, and another for producing a description of how to wire up an FPGA.
15:09:03 <Cale> OscarZ: Nope
15:09:16 <monochrom> Is Cale describing a library for playing Cooking Mama? <duck>
15:09:27 <Cale> Heh
15:10:28 <Twey> h20xt: Well, not really â in that case you just want a new type, data SchemeValue = SchemeNumber Integer | SchemeString String | SchemeSymbol String | SchemeList [SchemeValue]
15:10:40 <h20xt> Twey: i had that
15:10:44 <Twey> Then you can derive Num for it and give it a (+)
15:10:49 <Cale> OscarZ: Let me know when you've caught up :)
15:10:58 <h20xt> Twey: my problem came when i went to define (+) for all of them
15:11:13 <mauke> Twey: "derive"?
15:11:26 <Twey> Implement
15:11:51 <Twey> (SchemeNumber a) + (SchemeNumber b) = SchemeNumber $ a + b
15:11:51 <h20xt> it required me typing out each case, but i knew there had to be a better way to do it because they all had the same structure and each of the internal types had (+) defined
15:12:06 <Twey> Ah â then you should have made it a Functor
15:12:07 <h20xt> Twey: i don't think i ever got the types to work
15:12:10 <OscarZ> Cale: Sure.. brb.. then ill read it from the beginning and ask when i run into something i dont understand
15:12:19 <mauke> h20xt: er, String and [] have no +
15:12:28 <OscarZ> Cale: your efforts to explain are highly appreciated
15:12:29 <Cale> OscarZ: okay :)
15:12:31 <OscarZ> and others too :)
15:12:44 <Cale> OscarZ: In case I'm not here for some reason:
15:12:48 <koeien37> mauke: well, [] is a functor
15:12:56 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
15:13:00 <Twey> <3
15:13:05 <mauke> koeien37: so?
15:13:06 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
15:13:14 <koeien37> mauke: you could fmap it again
15:13:34 <mauke> koeien37: I'd need an applicative functor
15:13:48 <koeien37> ah, yes.
15:14:19 <h20xt> also, while im here, would you guys mind telling me a little about Arrows, are they akin to -> in math, just a guess
15:14:24 <Cale> OscarZ: It is a somewhat terse overview, but to some extent, once you've heard about the basics the only way to grok these ideas is to dig in and try it. :)
15:14:37 <Twey> h20xt: Arrows are like monads.  But not.
15:14:47 <h20xt> Twey: heh
15:14:57 <Cale> (probably *using* monads a bunch before you attempt to define one yourself)
15:15:05 <koeien37> h20xt: -> is an arrow
15:15:14 <sjanssen> @keal
15:15:14 <lambdabot> i changed my user od
15:15:17 <Twey> h20xt: http://en.wikipedia.org/wiki/Arrows_in_functional_programming
15:15:19 <Chaze> h20xt: -> in math? what would that be, an implication?
15:15:21 <koeien37> h20xt: i.e.  (->) a b
15:16:00 <h20xt> Chaze: like a mapping between two things
15:16:06 <Cale> h20xt: (Hughes') Arrows give an interface to a sort of library whose computations, unlike with a monad, also parametrise over the input type.
15:16:20 <Cale> h20xt: So, instead of b -> M c, you have A b c
15:16:43 <Cale> h20xt: and you have various ways to compose and wire these things up
15:17:08 <Cale> http://haskell.org/arrows/
15:17:12 <Cale> http://haskell.org/arrows/syntax.html
15:17:17 <Chaze> oh, monochrom: thanks for the intro on the forall keyword. just took me some time to read
15:17:24 <Cale> It helps to look at some pictures while you view the code :)
15:17:26 <h20xt> Cale: awesome, thanks
15:17:57 <h20xt> Thanks Twey
15:18:11 <wpm83> yeah i will rest
15:18:11 <Cale> h20xt: Arrows are more general than monads, but that also means there's fewer genuinely interesting things you can do with an *arbitrary* arrow
15:18:47 <Cale> h20xt: But there are additional classes which add in other special features and such
15:18:53 <h20xt> Cale: i think im getting it, makes sense why i don't see them often
15:19:16 <sproingie> is there anything besides yampa that uses arrows in anger?
15:20:12 <Cale> sproingie: HXT
15:20:40 <Cale> Which uses them as XML transformers to transform streams of XML fragments into other streams of XML fragments
15:20:44 <monochrom> I learned arrows from HXT.
15:20:59 <h20xt> also, i have always wondered this, say i have a big Data.Array holding pixels for an image, and I wan't to change a value using (//) does the runtime *actually* make an entire copy, or does it just fake it? if not should i use something like and IORef to do that?
15:21:30 <Cale> h20xt: Depends on which sort of array you're talking about, but usually it *really* copies it.
15:21:38 <visualbasicgui> Hey guys.
15:21:44 <Cale> h20xt: Which is why it's a good idea to collect up lots of changes in that list.
15:21:46 <koeien37> if you don't want it, try computing in the ST monad :)
15:21:56 <visualbasicgui> If any of you remember, I left a couple hours ago to interview at a local sandwich shop.
15:21:58 <koeien37> if you have a local computation that involves lots of destructive updates
15:22:18 <visualbasicgui> The manager said "come back at 7 and we'll do a working interview. You'll shadow somebody and we'll see how that works out."
15:22:30 <visualbasicgui> but he calls me at 6:20
15:22:35 <Polarina> Does anyone have a simple article explaining foldl and foldr?
15:22:39 <visualbasicgui> to say "oh nevermind we don't need you after all"
15:22:48 <Cale> Polarina: Have you seen the wikipedia page?
15:22:51 <mauke> http://foldr.com/
15:22:53 <Cale> Polarina: I wrote most of it.
15:22:53 <visualbasicgui> so it turns out i got thunked
15:22:58 <visualbasicgui> but they didn't need to evaluate me after all
15:23:00 <Polarina> Cale: The one on wikibooks?
15:23:06 <Cale> no, wikipedia
15:23:10 <Polarina> Cale: Link?
15:23:11 <jmillikin> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
15:23:12 <mauke> hmm, no
15:23:20 <h20xt> Cale: ah i see, so my own sort of lazyiness
15:23:21 <Cale> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
15:23:30 <koeien37> Polarina: foldr.com
15:23:34 <Cale> Polarina: also see: http://cale.yi.org/index.php/Fold_Diagrams
15:23:34 <Polarina> Cale: I'll look at it.
15:23:44 <visualbasicgui> "Learn you a haskell for great good" has a really good graphic depicting what a fold does
15:23:47 <Cale> Polarina: The simpler of the two is definitely foldr
15:23:52 <visualbasicgui> well a fold that reduces its list to a value
15:23:53 <visualbasicgui> here:
15:24:06 <Cale> Polarina: Recall that every list is either the empty list []
15:24:12 <visualbasicgui> http://learnyouahaskell.com/foldl.png
15:24:17 <monochrom> Cook you a haskell for great food
15:24:18 <Polarina> But foldr doesn't work well on infinite lists, does it?
15:24:26 <koeien37> Polarina: it does
15:24:29 <Cale> Polarina: or it is a nonempty list built by applying (:) to an element and another list
15:24:31 <visualbasicgui> actually foldr works on infinite lists, while foldl doesn't I think?
15:24:36 <koeien37> visualbasicgui: yeah
15:24:41 <visualbasicgui> I don't understand that.
15:24:42 <Polarina> How so?
15:24:49 <Cale> Polarina: It's foldl which doesn't work on infinite lists.
15:24:54 <junmin> hello all, i am uing gchi, but i cannot define a data, it says parse error on input `data', is it about any lib i should import?? thanks
15:24:59 <visualbasicgui> while i can sort of understand why foldl wouldn't work. it doesn't know when to stop
15:25:00 <Cale> @src foldr
15:25:00 <lambdabot> foldr f z []     = z
15:25:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:25:09 <jmillikin> junmin: Types cannot be defined within ghci.
15:25:11 <gwern> so weird. I've cabal-installed gitit 6 or 7 times now, and it seems every time cabal-install pulls ina different dep! a regex one install, filestore another, missingh the next, and configile this last install
15:25:13 <Polarina> Cale: Why wouldn't it work?
15:25:16 <koeien37> junmin: no. can you paste your code?
15:25:17 <Cale> Polarina: foldr passes control to f immediately when the list is nonempty
15:25:20 <jmillikin> You should save them to a file, and then import that file.
15:25:21 <Cale> @src foldl
15:25:22 <lambdabot> foldl f z []     = z
15:25:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:25:23 <visualbasicgui> oh wow. Thanks lambdabot!
15:25:26 <mauke> koeien37: ghci
15:25:33 <visualbasicgui> the source for foldr makes sense
15:25:36 <Cale> Polarina: foldl does nothing but call itself until it reaches the end of the list
15:25:37 <koeien37> mauke: ah ok.
15:25:42 <junmin> koeien37: data A = B | C
15:25:46 <Polarina> Cale: Ah.
15:26:08 <visualbasicgui> oh is that how its done
15:26:09 <koeien37> junmin: yeah, you need to do this in a .hs file
15:26:09 <monochrom> Do not understand. Calculate. Remember "outermost first". For example, foldr1 (&&) [False, x, ...] = False && foldr1 (&&) [x,...]  what is the next step?
15:26:24 <visualbasicgui> @src foldr1
15:26:24 <lambdabot> foldr1 _ [x]    = x
15:26:24 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
15:26:24 <lambdabot> foldr1 _ []     = undefined
15:26:29 <Baughn> http://op-webtools.web.cern.ch/op-webtools/vistar/vistars.php?usr=LHC1 <-- No matter how off-topic this is, it's too SHINY to miss
15:26:34 <Polarina> @src foldr
15:26:35 <lambdabot> foldr f z []     = z
15:26:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:26:42 <Polarina> @src foldl'
15:26:42 <lambdabot> foldl' f a []     = a
15:26:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:26:54 <visualbasicgui> Polarina: don't worry about the strict versions
15:26:59 <Polarina> Ok.
15:27:01 <visualbasicgui> they'll only explode your brain if you don't already understand the lazy ones
15:27:08 <junmin> koeien37: jmillikin: OK thanks. hugs can do that?
15:27:10 <visualbasicgui> did you check out the png i sent? http://learnyouahaskell.com/foldl.png
15:27:18 <Polarina> visualbasicgui: Yes.
15:27:21 <jmillikin> junmin: I don't know, I've never used hugs.
15:27:25 <Cale> Well, it might be good to worry a bit about them soon enough, since almost every time you will either want foldr or foldl'
15:27:33 <koeien37> junmin: too long ago for me :)
15:27:53 <Cale> Something like 99% of all folds are one of those two :)
15:28:00 <visualbasicgui> Polarina: have you read the chapter in RWH on folds?
15:28:06 <junmin> haha, jmillikin koeien37 OK. it is outdate then XD
15:28:14 <Polarina> visualbasicgui: No, I am going through Wikibooks.
15:28:16 <visualbasicgui> Polarina: as well, I would *strongly* recommend "Learn you a haskell..."
15:28:19 <koeien37> junmin: most of us use ghc
15:28:53 <Polarina> Can a foldr on a infinite list ever finish?
15:28:58 <koeien37> Polarina: yes
15:29:02 <Polarina> Ok. :)
15:29:09 <Chaze> i suppose I can't introduce 'superclasses' - meaining classes that have less restrictions? e.g. a class that is like Enum, only it requires *only* the succ function
15:29:14 <koeien37> > foldr (&&) True (repeat False)
15:29:15 <lambdabot>   False
15:29:52 <monochrom> Chaze: Right, we can't.
15:30:03 <koeien37> Chaze: not without changing the definition of Enum
15:30:04 <junmin> i am writing the .hs file now, should i explicitly import the Prelude lib? or it's always be loaded by default?
15:30:04 * Cale is astounded at how little the Wikipedia article has changed since he scrapped and rewrote it a couple years ago.
15:30:07 <visualbasicgui> how do i get "@src" in ghci? is there such a thing?
15:30:31 <monochrom> No such thing.
15:30:34 <Cale> visualbasicgui: There isn't, but there are source links from the haddock documentation which take you to the real source
15:30:36 <Baughn> junmin: Prelude is imported by default. You can ask GHC not to, or if you explicitly import only a part that also works.
15:30:37 <koeien37> visualbasicgui: no :(
15:30:50 <Cale> visualbasicgui: (rather than the fake educational source which @src uses)
15:31:04 <visualbasicgui> hmmm
15:31:15 <junmin> Baughn: cool.
15:31:15 <visualbasicgui> i just don't want to spam @src every time i want to see the source of a function
15:31:26 <monochrom> /msg lambdabot @src foldr
15:31:28 <koeien37> you can PM lambdabot
15:31:28 <Cale> @src just uses a text file
15:31:28 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:31:34 <koeien37> also, hoogle has links
15:31:43 <Chaze> how would I write a function that requires the passed object to have a successor - ideally using the existing definition of succ on anything that implements Enums ?
15:31:43 <jmillikin> visualbasicgui: use hoogle. http://haskell.org/hoogle/?hoogle=foldr
15:31:47 <visualbasicgui> lol @ 2001 reference in lambdabot
15:31:48 <ben0x539> Cale: Is it a .hs file?
15:31:50 <Baughn> Hoogle's links show the actual /real/ code
15:32:04 <Baughn> Lambdabot's @src is designed for educational value over reality
15:32:13 <monochrom> Chaze: f :: (Enum x) => x -> returntype
15:32:18 <Baughn> @src qsort
15:32:18 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:32:18 <visualbasicgui> Chaze: just make sure your input in the type signature is of type Enum?
15:32:22 <Baughn> @src sort
15:32:22 <lambdabot> sort = sortBy compare
15:32:23 <mauke> Chaze: you can't
15:32:27 <Chaze> well, then i'm asking for too much
15:32:30 <Baughn> @src sortBy
15:32:30 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:32:32 <visualbasicgui> Chaze: :: (Enum a) => a -> etc...
15:32:38 <Baughn> ..anyway. Trust me, sortBy is not implemented like that.
15:32:59 <visualbasicgui> Chaze: you could have f :: (Enum a) => a -> Maybe b (where b is your return type)
15:33:05 <visualbasicgui> and return Nothing if there is no succ
15:33:10 <mauke> what was the cool method of splitting a list into chunks of length n?
15:33:11 <monochrom> You can omit the type. Just write f a = const True (succ a)
15:33:22 <koeien37> Chaze: what you can do, is "class HasSuccessor a where mySucc :: a -> a", and "instance Enum a => HasSuccessor a where mySucc = succ"
15:33:38 <mauke> koeien37: except that instance doesn't actually work :-/
15:33:55 <koeien37> mauke: enlighten me
15:33:57 <Chaze> ah, that's closest to what i wanted!
15:34:13 <mauke> koeien37: for one, it's not H98
15:34:29 <mauke> and it clashes with every other instance of HasSuccessor
15:35:05 <junmin> @src Parser
15:35:06 <lambdabot> Source not found. Maybe you made a typo?
15:35:16 <mauke> your instance basically says "every type a is an instance of HasSuccessor with mySucc = succ; oh, and it also has to implement Enum"
15:35:18 <gwern> YAY
15:35:21 <visualbasicgui> mauke: i think that can be done with a fold and take somehow...
15:35:21 <ben0x539> > repeat "toot" !! 1000000
15:35:22 <lambdabot>   "toot"
15:35:23 <gwern> gitit's feeds now validate
15:35:25 <ben0x539> > repeat "toot" !! 10000000
15:35:25 <lambdabot>   "toot"
15:35:27 <gwern> that took forever
15:35:33 <koeien37> mauke: ah yes, i see some problems
15:35:41 <Chaze> meh
15:36:00 <gwern> the feed library's docs are terrible
15:36:08 <mauke> :t groupBy
15:36:09 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:37:06 <sproingie> gitit won't install for me
15:37:16 <sproingie>   duplicate packages specified as selected dependencies: base-3.0.3.2, base-4.2.0.0
15:37:46 <mauke> > (groupBy ((<) `on` fst) . zip . cycle . enumFromTo 0 . pred) 4 "Hello, world"
15:37:47 <lambdabot>   Couldn't match expected type `t1 -> t'
15:37:47 <lambdabot>         against inferred type `[[(a,...
15:37:56 <mauke> d'oh
15:38:13 <mauke> > ((groupBy ((<) `on` fst) .) . zip . cycle . enumFromTo 0 . pred) 4 "Hello, world"
15:38:14 <lambdabot>   [[(0,'H'),(1,'e'),(2,'l'),(3,'l')],[(0,'o'),(1,','),(2,' '),(3,'w')],[(0,'o...
15:38:31 <mauke> > ((map snd . groupBy ((<) `on` fst) .) . zip . cycle . enumFromTo 0 . pred) 4 "Hello, world"
15:38:32 <lambdabot>   The operator `L..' [infixr 9] of a section
15:38:32 <lambdabot>      must have lower precedence ...
15:38:47 <gwern> sproingie: looks like you have the diamond dep issue then
15:38:54 <gwern> (not gitit's fault!)
15:39:02 <sproingie> sounds nasty.  what's the cure?
15:39:33 <gwern> sproingie: I forget
15:39:38 <jmillikin> does Cabal mention which package is using the old base?
15:39:38 <sproingie> :(
15:39:50 <junmin> could not find module `Parser` it is a member of the hidden package `ghc-6.10.4` :|
15:39:54 <Jewbacca> Hello assembled.  Newbie question (hoping this resembles somehow the way etiquette runs here): attempting to explore lambda calculus in Haskell as a beginning exercise, attempting to implement Show for my Expression type, which I've attempted to make polymorphic.  Issue is Chars and Strings "show" with quotation marks, which turn up in my concatenated expressions.  How can I make a special...
15:39:57 <Jewbacca> ...case for > instance Show (Expression a) for when a is Char or String to kill this?
15:40:16 <sproingie> jmillikin: no, tho it does have another duplicate package line after
15:40:18 <sproingie>   duplicate packages specified as selected dependencies: pandoc-1.2.1, pandoc-1.2.1
15:40:29 <sproingie> maybe pandoc?
15:40:44 <Baughn> Jewbacca: Overlapping instances. You'll want to be sure of the rules first, but it's all in the GHC user manual.
15:40:59 <Chaze> so is there no way to make use of succ for HasSuccessor ?
15:41:05 <Jewbacca> Thank you Baughn, looking now
15:41:15 <Chaze> if one could only pattern match classes -.-
15:41:18 <koeien37> Chaze: there is, but you need some language extensions
15:41:33 <Baughn> Jewbacca: However, keep in mind that Show is supposed to produce valid haskell syntax
15:41:36 <Vulpyne> So you have something like instance Show (Expression String) where show (StringExpression x) = show x ?
15:41:44 <koeien37> Vulpyne: yeah.
15:41:46 <FunctorSalad_> Jewbacca: newtype Foo = Foo String, use foos instead of strings in your lamba terms
15:41:52 <Vulpyne> Cause you could just do x, not show x.
15:41:53 <FunctorSalad_> write appropriate show instance for Foo
15:41:56 <sproingie> Baughn: it doesn't always.  StdGen's Show doesn't
15:41:58 <junmin> could not find module `Parser` it is a member of the hidden package `ghc-6.10.4` :| why? i cannot import Parser
15:41:59 <Baughn> Jewbacca: Breaking that just for educational purposes is fine, but in a real program you should make a PrettyPrint class or something
15:42:09 <Baughn> sproingie: I didn't say all the library developers do a good job
15:42:18 <Vulpyne> And for a char, you could just have show (CharExpression x) = [x]
15:42:39 <Baughn> Well, no
15:42:41 <Baughn> > show 'c'
15:42:42 <lambdabot>   "'c'"
15:43:42 <FunctorSalad_> "<Baughn> Jewbacca: However, keep in mind that Show is supposed to produce valid haskell syntax" <-- sauce? :D
15:43:55 <Jewbacca> Cool, thanks
15:44:01 <Baughn> FunctorSalad_: Ask any elder god
15:44:13 <Baughn> FunctorSalad_: ..but yes, read . show == id
15:44:26 <Baughn> Supposedly, anyway
15:44:27 <ivanm> Baughn: heh
15:44:46 <FunctorSalad_> well that's incompatible with use for debugging purposes, if the reparseable expr in indecipherable
15:44:48 <Vulpyne> I asked Cthulhu what he thought about the Show typeclass but he just tried to eat me.
15:44:50 <FunctorSalad_> *is
15:45:28 <FunctorSalad_> btw someone change the Pretty class(es) to have analogue of showsPrec :|
15:45:39 <FunctorSalad_> I always write such a class
15:46:15 <Vulpyne> Instance Show a where show _ = "undefined" -- Totally valid!
15:46:49 <junmin> @src import Parser
15:46:49 <lambdabot> Source not found. I am sorry.
15:46:51 <koeien37> Vulpyne: you will need overlapping instances though
15:47:10 <ivanm> is there any way I can run profiling on my app where the profile still gets generated even when I kill the app (due to it seeming to get into an infinite loop)?
15:47:26 <Vulpyne> {-# LANGUAGE OverlappingInstances #-} Instance Show a where show _ = "undefined" -- Happy now?
15:47:26 <ivanm> or even maybe only let the action its running go on for a certain period of time?
15:47:34 <koeien37> ivanm: i think the profile gets generated, but you might need to correct the last frame i think?
15:47:45 <Vulpyne> @hoogle System.Timeout
15:47:45 <koeien37> if you open it in a text editor, you'll see
15:47:45 <lambdabot> module System.Timeout
15:47:45 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
15:47:47 <ivanm> koeien37: I have an empty file here....
15:47:52 <koeien37> hmm :(
15:48:17 <Vulpyne> ivanm: That may do what you want.
15:48:19 <Jewbacca> Well part of my difficulty, I think, is that Expression is already > data Expr a = Application (Expr a) (Expr a) | Lambda a (Expr a) | Variable a, so I'm already matching those constructors in the definition of show
15:48:28 <ivanm> thanks Vulpyne
15:48:34 <sigrid> can an IO Handle be closed for writing, but not for reading?
15:49:13 <Vulpyne> With a Show a constraint?
15:49:21 <Jewbacca> And in my malformed newbie intuition it seems like I should be able to have show Variable (Char a) =, and show Variable (String a) =
15:49:46 <ben0x539> What is the a now?
15:49:49 <Vulpyne> Yeah, if you want to handle in specially depending on which of those, you would probably have to do something like that.
15:49:54 <ben0x539> Oh, nevermind
15:50:02 <ivanm> sigrid: IOMOde is set to ReadMode ?
15:50:17 <ben0x539> Jewbacca: Is that a function or a instance?
15:50:21 <Jewbacca> Instance
15:50:25 <Vulpyne> Or make a container thing for your variables that could be a separate type and have a different show instanec.
15:50:30 <ben0x539> If it is a function, you cannot say Char there because it is a value constructor ._.
15:50:32 <Jewbacca> Here, I'll pastebin
15:50:37 <ben0x539> err, *not* one
15:51:09 <Jewbacca> http://pastebin.com/m72543d0f
15:51:15 <Jewbacca> if anybody'd care to have a look
15:55:42 <Vulpyne> Jewbacca: I annotated that - maybe it will help you.
15:56:15 <Jewbacca> I feel like the container idea should work, I just wonder if there's a built-in constructor for Char, and lament having to add extra constructors to my current manual test stuff, though I know eventually I'd try a parser for the natural LC syntax
15:56:38 <Jewbacca> Thanks!
15:56:42 <JohnnyL> Rewooowww{Chutzpah}Rwweoooerrrr
15:57:18 <Vulpyne> Well, when you have data Blah = X | Y | Z, the name of the type is Blah, the constructors are X, Y and Z but they're all type Blah.
15:57:32 <Jewbacca> Okay, I'll leave the channel clutter to a successor-TBD
15:58:08 <Vulpyne> You were trying to match a type where constructors were expected.
15:58:40 <Jewbacca> Yeah, that was a temporary thing I forgot to revert
15:59:08 <Vulpyne> Well, your wondering about the constructor for Char sounded a bit like you were looking at it that way. :)
15:59:27 <Jewbacca> Is there an explicit constructor for Chars though?
15:59:47 <BONUS> hmm, interesting, i think i just used undefined for the first time
15:59:51 <BONUS> like including it on purpose
15:59:53 <Vulpyne> I guess you could look at surrounding one with single quotes as constructing it.
16:00:10 <Jewbacca> Yes, but to match in a function defintion
16:00:30 <Vulpyne> There is no case where pattern matching it would make sense though.
16:00:30 <Vulpyne> Because it would never have multiple constructors.
16:00:30 <Vulpyne> If the type is Char, a character is all you will find.
16:00:37 <BONUS> > take 10 . drop 1 $ iterate (\(a,g) -> randomR (1,10) g) (undefined, mkStdGen 100)
16:00:38 <lambdabot>   [(4,4041414 40692),(1,651872571 1655838864),(7,693699796 2103410263),(1,147...
16:00:53 <Vulpyne> Let's say the constructor for char was Meep, give an example of what you'd try to do with that.
16:01:16 <Jewbacca> show (Variable (Meep a)) = ...
16:01:49 <Jewbacca> show (Variable (Moop a)) = ..
16:01:56 <Jewbacca> show (Variable a) = ...
16:02:04 <Vulpyne> But the argument to show would have to be a Expression Char.
16:02:20 <Vulpyne> Because you have data Expression a = Constructor a | etc
16:02:21 <Jewbacca> Hmm
16:02:24 <Jewbacca> Yeah
16:02:46 <Vulpyne> So it could never be anything but a Char, so pattern matching a constructor wouldn't make sense.
16:02:51 <monochrom> I personally would not mind Show Char giving me 'x'.
16:03:03 <Jewbacca> I'll play around some more and try to get a better grip on my options
16:03:27 <Jewbacca> Like, without the quotation marks?
16:03:28 <Vulpyne> Jewbacca: The first thing is - is every a being the same actually what you want?
16:03:40 <Jewbacca> Yeah
16:03:45 <Jewbacca> Within an expression
16:03:51 <Vulpyne> Okay.
16:04:11 <Vulpyne> The instance Show (ExprVar Char) where show x = ...
16:04:17 <Vulpyne> That show will only be used for ExprVar Char.
16:04:24 <FunctorSalad_> > show 'c'
16:04:25 <lambdabot>   "'c'"
16:04:26 <Jewbacca> Yeah
16:04:29 <Vulpyne> You don't have to worry about ever being called with an ExprVar Int, or whatever.
16:04:35 <FunctorSalad_> > read "'c'" ::Char
16:04:36 <lambdabot>   'c'
16:04:44 <FunctorSalad_> hmm?
16:04:56 <FunctorSalad_> afk
16:05:24 <Vulpyne> Another way you could do it, without the container, would be instance Show (Expression Char) where show (Variable x) = x
16:05:33 <Vulpyne> And make a Show instance for each possible type of Expression.
16:05:35 <Jewbacca> I tried that
16:05:46 <Vulpyne> You would have to make a separate Show instance.
16:06:00 <Jewbacca>     Illegal instance declaration for `Show (Expression Char)'
16:06:04 <Vulpyne> It looked like you were trying to pattern match in a "Expression a" instance of Show.
16:08:43 <Jewbacca> Okay, I'm going to thank you very much for your help and in general for this channel being open, but I'm going to have to read this over and play a bit to get it.
16:09:13 <Vulpyne> Jewbacca: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=12753#a12753
16:09:45 <Jewbacca> Hmm
16:09:49 <Vulpyne> Jewbacca: That worked for me. Note that you would have to redefine how you show Lambda, and Application for each instance though (or make a common function you could call)
16:10:35 <Jewbacca> I think I like the first way you demonstrated better, with ExprChar and ExprString
16:10:55 <Vulpyne> Yeah, that may be nicer.
16:11:03 <Jewbacca> I'll play with both to try to get it
16:11:07 <Vulpyne> If you know there are a limited number of types you expect it to work with.
16:11:25 <Jewbacca> Well again this is entirely pedagogical
16:11:50 <Jewbacca> I'm probably only even going to be playing with Char, but I'm trying to assimilate the type system while I do it
16:12:05 <Vulpyne> I see.
16:12:36 <Jewbacca> Thank you again Vulpyne
16:12:59 <Jewbacca> Welcoming channel, I'll be back to inadvertantly monopolize it again soon
16:13:09 <Vulpyne> See you later.
16:24:34 <deadguys_> hello all.  can anyone point me to a good resource for getting vim to indent haskell code?  googling has led me to indent/haskell.vim and align, but I'm not sure how I need to configure vim to get them working
16:25:10 <jmillikin> Considering how unusual and complex some Haskell indentation schemes are, you're probably best off with just the "tab" key.
16:26:08 <Zao> http://urchin.earth.li/~ian/style/haskell.html
16:26:08 <jmillikin> Especially considering that HS whitespace is syntactically important, which makes it difficult to smart-indent.
16:26:12 <Zao> There's some vim info at the end.
16:26:43 <Zao> Nothing on autoindent though, as that's non-trivial.
16:26:46 <mauke> make sure your .vimrc contains 'syntax on' and 'filetype plugin indent on'
16:27:06 <Berengal> @type join (liftM2 (+))
16:27:07 <mauke> and that indent/haskell.vim is somewhere in vim's runtime path
16:27:09 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1
16:27:18 <Berengal> Is that construct bad?
16:28:47 <jmillikin> I don't see why it'd be "bad"
16:30:10 <BONUS> in which situation would join $ liftM2 (+) be useful?
16:30:39 <BONUS> > join (liftM2 (+)) $ [2,2,2]
16:30:40 <lambdabot>   [4,4,4,4,4,4,4,4,4]
16:30:53 <deadguys_> mauke: i have indent/haskell.vim as ~/.vim/plugin/haskell.vim is that right?  or should it be ~/.vim/plugin/indent/haskell.vim?
16:31:11 <mauke> ~/.vim/indent/haskell.vim
16:31:28 <MoALTz> > join $ liftM2 (+) $ [1,4,6,4,1]
16:31:29 <lambdabot>   Couldn't match expected type `[a1] -> a'
16:31:29 <lambdabot>         against inferred type `[a1]'
16:31:41 <MoALTz> > join (liftM2 (+)) $ [1,4,6,4,1]
16:31:42 <lambdabot>   [2,5,7,5,2,5,8,10,8,5,7,10,12,10,7,5,8,10,8,5,2,5,7,5,2]
16:31:45 <mauke> plugin/ is for global plugins, ftplugin/ for filetype-specific plugins, indent/ for indentation scripts, and syntax/ for syntax highlighting
16:32:05 <BONUS> oh yeah that's cool
16:32:40 <ivanm> with a profile output, is there a way of making the class method instances be recognisable?
16:33:21 <gwern> @quote Hubris
16:33:21 <lambdabot> blackdog says:  [About Hubris] I tell the Ruby guys that Haskell will help them speed up their Ruby code and keep their apps going, and I tell Haskell guys that it'll Trojan Horse those poor
16:33:22 <lambdabot> unsuspecting rubyists...
16:33:30 <gwern> @quote ethic
16:33:30 <lambdabot> lispy says: Great, I leave the channel for a few hours and suddenly Haskell has a new found work ethic.
16:33:39 <gwern> @quote the.fail
16:33:39 <lambdabot> roconnor says: ivanm: I will keep the fail in the code
16:33:54 <gwern> @quote What.are
16:33:55 <lambdabot> JonHarrop says: What are the features of this languages [Go] in the context of FP?
16:34:06 <gwern> hm? that seems like a bad quote
16:34:21 <lispy> ?quote Gwern
16:34:21 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:34:26 <gwern> @quote What.are.your
16:34:26 <lambdabot> lament says: just remember to ask, "What are your questions", as opposed to "Do you have any questions"
16:34:34 <gwern> @quote gwern
16:34:34 <lambdabot> gwern says: all good languages are but corruptions or extensions of haskell
16:34:46 <ivanm> gwern: any particular quote you looking for?
16:34:55 <gwern> ivanm: just going through the HWN, as usual
16:35:00 <ivanm> ahhh
16:35:12 <ivanm> what's so bad about the harrop quote?
16:35:23 <lispy> Most quotes are funny
16:35:23 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
16:37:30 <gwern> ivanm: I just don't see the point
16:37:47 <gwern> as well ask, what are the features of Go in the context of OOP?
16:42:49 <mreh> how can I make a list of the running total of a list?
16:43:09 <mreh> is there an easy way?
16:43:11 <monochrom> OOP feature of Go: black pieces and white pieces exhibit similar behaviour, could be two subclasses of a "piece" class.
16:43:13 <mauke> scanl
16:43:20 <mreh> :t scanl
16:43:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:44:07 <mreh> scanl (+) 0 [1..10]
16:44:14 <mreh> > scanl (+) 0 [1..10]
16:44:15 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
16:44:20 <mreh> coool
16:44:24 <mreh> thx
16:44:37 <Berengal> monochrom: I think of that more as ducktyping
16:44:44 <Berengal> But it's an interesting system
16:44:53 <Berengal> Statically checked ducktyping, no less.
16:45:15 <ivanm> gwern: harrop == pusher of OCaml, F# == believer in FP > *, unless the FP is in Haskell
16:45:27 <ivanm> monochrom: heh
16:45:48 <sproingie> that's not duck typing, that's basic polymorphism
16:46:39 <Berengal> Well, ducktyping is all about behaviour...
16:47:12 <sproingie> sure, but as the term is commonly used, "statically checked duck typing" is an oxymoron
16:47:22 <monochrom> Has anyone ever defined "behaviour" for this purpose?
16:47:24 <Berengal> Not neccessarily
16:47:27 <sproingie> tho i've always said that type inference is the ultimate duck typing
16:47:48 <Berengal> monochrom: in OOP terms, behaviour is what messages an object recognizes... at least that's how I see it
16:47:52 <sproingie> "if it quacks like a duck, you damn sure can't compile something that tells it next to bray like a donkey"
16:48:53 <sproingie> OO polymorphism just means rolling both of those behaviors into .speak()
16:48:54 <jfhall> Does anyone use shim for emacs? The only sources I could find are from 2007 and I don't know if it is still worth using anymore
16:49:09 <Berengal> sproingie: and that's why I'm not a big fan.
16:49:29 <sproingie> i love the hell out of it, personally
16:49:37 <Berengal> The Go interfaces look a bit nicer. Instead of a hierarchy of inheritance, objects subscribe to an interface instead
16:49:52 <BONUS> so the go interfaces are like typeclasses basically
16:50:01 <sproingie> i thought go did structural subtyping ala ocaml
16:50:04 <Berengal> Yeah, sort of
16:50:10 <BONUS> only i assume they don't come with the extra cool stuff (multiparameters, etc.)
16:50:42 <Berengal> I haven't looked too closely at the language, but that's the impression I got from the tutorials
16:50:42 <monochrom> I still use software written in 2000. What's wrong with that. The only important criterion should be what it buys me, not when it was written
16:50:54 <nominolo> preflex: seen edwardk
16:50:54 <preflex>  edwardk was last seen on #haskell 1 day, 4 hours, 10 minutes and 35 seconds ago, saying: Twey: yeah, and if the messenger happened to capture that on his web cam or iphone, then you really would wind up popular on the internets. ;)
16:51:49 <jfhall> monochrom: I just wasn't sure if shim has been outdated by improvements in haskell-mode, I'm still not entirely sure what it does, I just wanted to know if it was worth looking into
16:52:19 <monochrom> You haven't started trying shim? Then I understand.
16:52:32 <ivanm> isn't shim dead?
16:52:40 <jfhall> thats what I was wondering
16:52:53 <ivanm> jfhall: there's nominolo's project that Baughn is wanting to integrate into haskell-mode
16:52:54 <jfhall> monochrom: no, I haven't tried it yet
16:53:18 <jfhall> ivanm: interesting I'll check that out, thanks
16:53:26 <monochrom> I have never heard of shim, if that is any consolation. :)
16:53:38 <ivanm> can't recall the name of it though...
16:53:55 <ivanm> monochrom: it was an attempt at providing a library of extra Haskell support to editors
16:53:57 <jfhall> monochrom: I just heard about...
16:54:48 <jfhall> ivanm: Google brought up scion when I searched for nominolo
16:55:00 <jfhall> it's a haskell ide library
16:55:47 <ivanm> jfhall: that's the one
16:56:08 <jfhall> ivanm: looks interesting, thanks again for the info
16:57:56 <ivanm> jfhall: no worries
16:59:55 <sproingie> hm i'm pondering doing a roguelike in haskell, and yah i'm aware of the other ones around like mage and LambdaHack.  i'm wondering what the approaches to handling all that state are other than the usual World->World approach?
17:00:36 <sproingie> maybe FRP, not sure
17:03:21 <dolio> preflex: seen ski
17:03:22 <preflex>  ski was last seen on ##logic 1 day, 5 hours, 4 minutes and 50 seconds ago, saying: * ski doesn't recall `U' very well at all
17:05:30 <cdjvc> hi
17:05:47 <cdjvc> can somebody help me?
17:05:54 <sproingie> yes
17:05:55 <ben0x539> Probably.
17:06:06 <sproingie> next question costs $10
17:06:51 <monochrom> Oh $10 is cheap.
17:06:53 <cdjvc> i have a problem with a code
17:07:11 <cdjvc> it's a stupid code
17:07:16 <sproingie> knew i should have charged more
17:07:30 <Zao> Code rarely is stupid, coders are.
17:07:43 <dolio> Nice confidence booster.
17:08:07 <cdjvc> can i send a code to somebody?
17:08:09 <sproingie> haskell often makes me feel really dumb til things click
17:08:10 <Zao> Also, your code told me to tell you to stop anthropomorphising it. It doesn't like it.
17:08:11 <sproingie> @paste
17:08:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:08:14 <sproingie> cdjvc: use that
17:08:36 <monochrom> Please continue to talk poetically forever about your code but never say anything specific.
17:08:59 <sproingie> right now i'm feeling dumb for not having a good design to handle a stateful game
17:09:48 <sproingie> all i can think of is glomming a bunch of monad transformers like StateT and RandomT into a big World monad
17:10:06 <sproingie> this makes me feel icky
17:10:36 <cdjvc> sorry i don't understand english very well, can you help me sproingie ?
17:10:48 <blackdog>  /lastlog blackdog
17:11:03 <blackdog> oops. sorry. stray space.
17:12:04 <Chaze> there isn't, by any chance something that behaves like curry/uncurry, but with 3-tuples?
17:12:22 <sproingie> @hoogle a -> b -> c -> (a,b,c)
17:12:23 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
17:12:23 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
17:12:29 <dolio> No, there is not.
17:12:32 <FunctorSalad_> I'm sure mmorrow has a TH macro for arbitrary n-tuples
17:12:36 <FunctorSalad_> :)
17:12:45 <cdjvc> i do a two simple functions but in main say me a "error"
17:13:03 <FunctorSalad_> such stuff seems like a good use for TH, really
17:13:03 <cdjvc> can somebody help me please?
17:13:10 <FunctorSalad_> n-ary bind, too
17:13:38 <Botje> cdjvc: can you put your code and the error you get on hpaste.org ?
17:13:44 <dolio> I guess $(curry 5) isn't too intrusive.
17:16:12 <cdjvc> Botje, thanks i put my code
17:21:43 <EvilTerran> hm...
17:23:02 <EvilTerran> in category theory, i'm seeing a lot of "given $foo there exists a unique $bar such that $baz; let $eek($foo) be this $bar"
17:23:44 <sproingie> existential blues
17:24:36 <EvilTerran> eg, for products: "given arrows f : A -> B, g : A -> C, there exists a unique arrow h : A * B -> C such that pi1 . h = f; pi2 . h = g. let <f,g> be this h"
17:24:57 <dolio> That's kind of what category theory is all about.
17:25:18 <monochrom> Given number x there exists a unique number y such that y is twice x; let f(x) be this y.
17:26:20 <monochrom> A less trivial example. Given nonnegative x there exists a unique nonnegative y such that y^2=x; let sqrt(x) be this y.
17:26:21 <EvilTerran> yeah... i just find it a bit weird to have, in effect, "(forall x. exists y. ...); let f(x) = y". it seems badly scoped. :P
17:27:11 <dolio> Or at least, the modelling of various structures categorically.
17:27:31 <monochrom> Right, it is flexible English.
17:28:00 <EvilTerran> i've been idly thinking about the possibility of phrasing it as something like "given objects A, B, C, there exists a unique function <_,_> : Hom(A,B)*Hom(A,C) -> Hom(A,B*C) such that etc etc"
17:28:12 <dolio> You don't talk about structures by looking at what they're made of. You look at what operations characterize them uniquely (or uniquely up to isomorphism).
17:28:52 <EvilTerran> i was suspecting that that sort of phrasing might also more closely follow the phrasing of how it would work in a (>1)-category
17:29:18 <EvilTerran> "given ... there exists a unique morphism in the upper category (or whatever it's called) such that ..."
17:29:55 <HugoDaniel> hi
17:30:01 <EvilTerran> does that make sense?
17:30:03 <monochrom> you again
17:30:34 <dolio> You generally discard uniqueness in n-categories.
17:30:37 <dolio> I think.
17:30:42 <IceDane> Hey - is there a way to remove all elements from a list that match a certain condition? Or get the list = list1 - list2 (e.g., mins all elements in list2)
17:30:51 <EvilTerran> dolio, unique up to isomorphism, then :P
17:30:56 <dolio> Right.
17:31:11 <akappa> IceDane, list comprehension with denied condition
17:31:27 <IceDane> Hmm. I guess I might be able to make that work
17:31:31 <akappa> just retain all the elements that doesn't match a certain condition
17:31:54 <dolio> You wouldn't talk about hom-sets either, though, I think.
17:31:57 <EvilTerran> IceDane, filter would work too
17:32:04 <akappa> ys = [ x | x <- xs, not (P x) ]
17:32:17 <EvilTerran> dolio, that was just to distinguish the arrows from the function arrow visually
17:32:30 <IceDane> EvilTerran! Thanks. I'm still bad at remembering all the standard functions
17:32:43 <Axman6> IceDane: you've not seen the filter function?
17:32:48 <IceDane> Axman6: I have
17:32:53 <IceDane> I just didn't think of it
17:32:58 <dolio> But I'm not exactly sure how you define products in n-categories.
17:33:14 * EvilTerran should see how sleeping on it works, it's pretty late here
17:33:19 <EvilTerran> g'night
17:33:52 <dolio> But, having it involve something like Hom(A,B)*Hom(A,C) would appear to require products of arrows to exist.
17:33:58 <dolio> Which seems undesirable.
17:41:16 <IceDane> God I'm bad at this.. What is an easy way to repeatedly apply a function to a list? E.g., apply filter to a list, then filter again to the result?
17:41:16 <MoALTz> is there an easy way to apply an arguement twice without a lambda?
17:41:40 <MoALTz> takeWhile (\n -> fff n n) [1..]    to replace the lambda there
17:41:41 <Axman6> filter f . filter g $ list
17:41:57 <dolio> > join (,) 1
17:41:57 <lambdabot>   (1,1)
17:42:01 <Axman6> MoALTz: join
17:42:02 <IceDane> Axman6: In a loop
17:42:14 <Axman6> IceDane: 'loop'?
17:42:24 <monochrom> When does the applying stop?
17:42:24 <Codex_> icedane: how about list comprehensions?
17:42:32 <dolio> foldr filter list predicateList
17:42:44 <IceDane> Not just two composite filters, I'm talking about .. thousands of applications to the list and the result
17:42:47 <Axman6> flip filter?
17:43:01 <IceDane> Hmm
17:43:05 <IceDane> maybe foldr works yeah
17:43:33 <mauke> filter (f . g . h)
17:43:41 <mauke> no, wait
17:43:53 <mauke> filter (all fs)
17:44:16 <dolio> filter (and . sequence predicateList) list
17:45:07 <IceDane> I can just as well explain the problem - I'm implementing a simple prime sieve
17:45:12 <dolio> @type \pl -> filter (and . sequence pl)
17:45:13 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
17:46:06 <dolio> Sieving primes using repeated filter is probably not the best relatively naive algorithm.
17:46:11 <IceDane> I basically need to filter all numbers from the list that divide evenly into the first number, the second.. so on
17:46:26 <IceDane> dolio: that might be, but I'd be happy simply being able to do it
17:46:34 <Axman6> IceDane: i think we might be able to help you better if you tell us what you're actually trying to do
17:46:40 <IceDane> Axman6: I just did.
17:46:46 <Axman6> well, that's a perfect use for nubBy
17:46:59 <Axman6> @src nubBy
17:47:00 <lambdabot> nubBy eq []             =  []
17:47:00 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
17:47:04 <dolio> I'd recommend using circularly defined trial division.
17:47:20 <Axman6> you're trying to get a lift of primes right?
17:47:50 <IceDane> Axman6: I'm not sure what lift means
17:48:00 <Axman6> list*
17:48:08 <IceDane> ah
17:48:08 <IceDane> yeah
17:48:13 <monochrom> No wonder. The circular trial division is a loop (a tied knot, too) with filter as part of the circle.
17:49:10 <Axman6> > 2:nubBy (\x y -> (y `mod` x) == 0) [3,5..]
17:49:10 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:49:20 <Axman6> > 2:nubBy (\x y -> (y `mod` x) /= 0) [3,5..]
17:49:24 <lambdabot>   mueval-core: Time limit exceeded
17:49:46 <blackdog> hm. what's the most sensible way to represent big-ish bitstrings in haskell? length is predictable, needs fast comparison
17:49:49 <Axman6> hmm
17:49:50 <Axman6> > 2:nubBy (\y x -> (y `mod` x) == 0) [3,5..]
17:49:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:49:52 <dolio> Yes, but it's a better filter. :)
17:50:17 <mauke> blackdog: ByteString?
17:50:18 <Axman6> > 2:nubBy (\x y -> (x `mod` y) == 0) [3,5..]
17:50:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:50:52 <blackdog> Axman6: you missed me not completely screwing up the Hubris talk, btw, despite managing to break my demo an hour before the talk...
17:51:09 <Axman6> lol, well done
17:51:14 <Axman6> it was a thursday right?
17:51:19 <blackdog> mauke: i guess that'd work.i'd need to implement comparison myself, though
17:51:28 <blackdog> Axman6: yeah. last one for the year
17:51:32 <dolio> At least, I think that's the fastest naive way. I haven't looked at benchmarks of them all in a while.
17:51:40 <Axman6> i can't really do thursdays
17:51:48 <Axman6> got SES training
17:52:15 <blackdog> come the apocalypse, you'll probably be glad you did that instead of drinking with the functional alcoholics
17:53:59 <Axman6> heh
17:54:12 <Axman6> i dunno, we do our fair chare of drinking :P
17:54:37 <blackdog> yeah, but i bet you don't get to bag out the poor bugger still using CVS while you do it.
17:54:56 <Axman6> lol
18:25:07 <visualbasicgui> Hello everybody
18:25:19 <visualbasicgui> I have a question about the inferring of types
18:25:34 <visualbasicgui> wouldn't a concise way to define "any"
18:25:35 <visualbasicgui> be
18:25:58 <visualbasicgui> any :: (a -> Bool) -> [a] -> Bool
18:26:07 <visualbasicgui> any = or . map
18:26:13 <visualbasicgui> ?
18:26:16 <mauke> @src any
18:26:16 <lambdabot> any p =  or . map p
18:26:29 <visualbasicgui> hmm. why do i have to include p?
18:26:30 <Badger> :t any
18:26:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:26:36 <mauke> @. pl src any
18:26:36 <lambdabot> (line 1, column 1):
18:26:36 <lambdabot> unexpected end of input
18:26:36 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:26:48 <mauke> @pl any p = or . map p
18:26:48 <lambdabot> any = any
18:26:52 <mauke> haha
18:26:57 <visualbasicgui> lol wut
18:27:06 <visualbasicgui> But
18:27:21 <mauke> visualbasicgui: because (or . map) p xs == or (map p) xs
18:27:27 <visualbasicgui> from what i think about partial application & curry sauce
18:27:31 <visualbasicgui> yes yes
18:27:33 <visualbasicgui> no that makes sense
18:27:37 <visualbasicgui> :(
18:27:38 <mauke> meaning you'd call 'or' with two arguments, (map p) and xs
18:27:43 <visualbasicgui> yes
18:27:48 <mauke> :t (or .) . map
18:27:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:27:54 <mauke> magic!
18:27:56 <mmorrow> @let fplus (<>) f g x = f x <> g x
18:27:57 <lambdabot>  Defined.
18:28:07 <visualbasicgui> ?????
18:28:14 <visualbasicgui> (or .) . map
18:28:17 <visualbasicgui> let me think about that
18:28:19 <mauke> mmorrow: looks like liftM2
18:28:36 <Axman6> visualbasicgui: you need to pass the p, or you're giving or the function (map p) as input
18:29:33 <visualbasicgui> thanks
18:29:50 <Axman6> any = or . map -> any p = (or . map) p -> any p xs = ((or . map) p) xs -> (or (map p) xs)
18:30:06 <dolio> > fplus (+) (f :: Expr -> Expr) (g :: Expr -> Expr) x
18:30:08 <lambdabot>   f x + g x
18:30:08 <mauke> Axman6: welcome to 3 minutes ago
18:30:08 <visualbasicgui> ah
18:30:15 <dolio> > liftM2 (+) (f :: Expr -> Expr) (g :: Expr -> Expr) x
18:30:16 <lambdabot>   f x + g x
18:30:21 <MoALTz> let fff c n = fromInteger c > logBase 10 (fromInteger (t^n)). if c = n then i get the mathematical form n > logBase 10 (t^n). but this reduces to (since n and t are +ve): n > n*logBase 10 t, 1 > logBase 10 t, 10 > t ???
18:30:34 * MoALTz is puzzled how his old code *worked*
18:31:44 <mmorrow> > filter (foldr (fplus (||)) (const False) [odd,fplus(&&)(<9)(>5),(==0).(`mod`13)]) [0..]
18:31:48 <lambdabot>   [0,1,3,5,6,7,8,9,11,13,15,17,19,21,23,25,26,27,29,31,33,35,37,39,41,43,45,4...
18:31:56 <visualbasicgui> oh and i finally succeeded in understanding foldl in terms of foldr
18:31:58 <visualbasicgui> by writing it out
18:31:59 <visualbasicgui> on papier
18:32:09 <Axman6> > [1,3..]
18:32:10 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:32:19 <Axman6> > 0:[1,3..]
18:32:20 <lambdabot>   [0,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51...
18:32:23 <mauke> > inRange (6, 8)
18:32:24 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->False;2->False;3->False}
18:32:42 <Axman6> wait up... what is that doing mmorrow?
18:32:48 <mmorrow> @let ors = foldr (fplus (||)) (const False)
18:32:49 <lambdabot>  Defined.
18:32:57 <mmorrow> @let ands = foldr (fplus (&&)) (const True)
18:32:58 <lambdabot>  Defined.
18:33:11 <visualbasicgui> @let pi = 3
18:33:12 <lambdabot>  Defined.
18:33:16 <visualbasicgui> :O
18:33:21 <visualbasicgui> what have i done?!
18:33:29 <visualbasicgui> >pi
18:33:33 <visualbasicgui> > pi
18:33:33 <Axman6> > pi
18:33:33 <lambdabot>   Ambiguous occurrence `pi'
18:33:34 <lambdabot>  It could refer to either `L.pi', defined at <loc...
18:33:34 <lambdabot>   Ambiguous occurrence `pi'
18:33:34 <lambdabot>  It could refer to either `L.pi', defined at <loc...
18:33:36 <mmorrow> fplus (<>) [p1,p2,..pn] ==> \x -> p1 x <> p2 x <> ... <> pn x
18:33:43 <Axman6> you've broken everything
18:33:45 <visualbasicgui> ???
18:33:47 <visualbasicgui> the world is over
18:33:56 <visualbasicgui> oh god
18:33:57 <visualbasicgui> undo
18:34:03 <visualbasicgui> ctrl + z
18:34:13 <mmorrow> @undefine
18:34:17 <visualbasicgui> is that possible?
18:34:18 <mmorrow> @let fplus (<>) f g x = f x <> g x
18:34:19 <lambdabot>  Defined.
18:34:20 <mauke> > filter (or . sequence [odd,inRange(6,8),(==0).(`mod`13)]) [0..]
18:34:21 <lambdabot>   [0,1,3,5,6,7,8,9,11,13,15,17,19,21,23,25,26,27,29,31,33,35,37,39,41,43,45,4...
18:34:21 <mmorrow> @let ors = foldr (fplus (||)) (const False)
18:34:22 <lambdabot>  Defined.
18:34:25 <mmorrow> @let ands = foldr (fplus (&&)) (const True)
18:34:26 <lambdabot>  Defined.
18:35:03 <visualbasicgui> @undefine L.pi
18:35:06 <visualbasicgui> ?
18:35:15 <Axman6> fark. how do i tell windows to use my middle trackpoint button as middle click, and not do that tretarded scrolly thing?
18:35:16 <mauke> visualbasicgui: you just deleted all @defines
18:35:26 <visualbasicgui> no i didn't
18:35:27 <visualbasicgui> oh
18:35:28 <visualbasicgui> well
18:35:29 <Axman6> all @lets*
18:35:29 <visualbasicgui> hmm
18:35:30 <visualbasicgui> i'll just go
18:35:31 <visualbasicgui> and uh
18:35:32 <Axman6> yes, you did
18:35:33 <visualbasicgui> and hang myself
18:35:34 <mmorrow> @let fplus (<>) f g x = f x <> g x
18:35:35 <lambdabot>  Defined.
18:35:38 <mmorrow> @let ands = foldr (fplus (&&)) (const True)
18:35:39 <lambdabot>  Defined.
18:35:39 <visualbasicgui> i'll never show my face around here again
18:35:39 <mmorrow> @let ors = foldr (fplus (||)) (const False)
18:35:40 <lambdabot>  Defined.
18:35:41 <visualbasicgui> good day chaps
18:35:44 <visualbasicgui> :*(
18:35:47 <mauke> mmorrow: dude, wtf are you doing?
18:36:00 <mmorrow> i'm trying to preserve my defines across the onslaughts
18:36:13 <mauke> why?
18:36:20 <mmorrow> because i want to use them
18:36:22 <mauke> how is fplus better than liftM2?
18:36:22 <Axman6> mmorrow: i'm sure if you asdk cale nicely enough, he'll redefine and and or to be those definitions
18:36:23 <gwern> because caleskell wasn't enough
18:36:24 <visualbasicgui> don't you have your own ghci?
18:36:34 <Saizan_> mmorrow: ask cale to put them in Pristine.hs and/or send a patch then
18:36:39 <mauke> :t ands
18:36:40 <lambdabot> forall t. [t -> Bool] -> t -> Bool
18:36:54 <mauke> :t (and .) . sequence
18:36:55 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
18:37:06 <mmorrow> mauke: you're making me sad
18:37:36 <BMeph> mmorrow: I think mauke's saying you were sad before; he's just pointing it out... ;p
18:37:40 <mmorrow> @let fprod (><) f g (x,y) = f x >< g y
18:37:41 <lambdabot>  Defined.
18:37:56 <mmorrow> try to do fprod lift liftMauke7!!@
18:38:01 <mmorrow> :)
18:38:24 <mauke> :t [(***), fprod]
18:38:24 <mmorrow> fplus is the dual
18:38:25 <lambdabot>     Couldn't match expected type `(b, b')'
18:38:25 <lambdabot>            against inferred type `t1 -> t3'
18:38:25 <lambdabot>     Probable cause: `fprod' is applied to too few arguments
18:38:41 <mauke> oh, right
18:38:42 <mmorrow> grr, should've called it ftimes i guess for symmetry
18:38:56 <Saizan_> ?type ftimes
18:38:57 <lambdabot> Not in scope: `ftimes'
18:39:00 <Saizan_> ?type fprod
18:39:01 <lambdabot> forall t2 t3 t4 t t1. (t2 -> t3 -> t4) -> (t -> t2) -> (t1 -> t3) -> (t, t1) -> t4
18:39:05 <visualbasicgui> coffee?
18:39:07 <visualbasicgui> yay or nay?
18:39:16 <mmorrow> it's like (***), but replaces (,) with an arbitrary function
18:39:25 <visualbasicgui> yes of course
18:39:28 <visualbasicgui> coffee every second
18:39:30 <visualbasicgui> it's no question
18:39:50 <mmorrow> and fplus is like (&&&), but replaces (,) with an arbitrary function
18:40:01 <dolio> @type ((uncurry .) .) . (***)
18:40:02 <lambdabot>     Couldn't match expected type `a -> b -> c'
18:40:02 <lambdabot>            against inferred type `(c1, c')'
18:40:02 <lambdabot>       Expected type: a1 b1 c1 -> a1 b' c' -> a1 (b1, b') (a -> b -> c)
18:40:12 <Saizan_> ?type \f g h -> uncurry f . (g *** h)
18:40:13 <lambdabot> forall a b c (a1 :: * -> * -> *) b1 b'. (Arrow a1, Functor (a1 (b1, b'))) => (a -> b -> c) -> a1 b1 a -> a1 b' b -> a1 (b1, b') c
18:40:14 <dolio> @type ((. uncurry) .) . (***)
18:40:15 <lambdabot>     Couldn't match expected type `(a, b) -> c'
18:40:15 <lambdabot>            against inferred type `(b1, b')'
18:40:15 <lambdabot>       Expected type: (b1 -> c1) -> (b' -> c') -> ((a, b) -> c) -> b2
18:40:24 <Saizan_> ?pl \f g h -> uncurry f . (g *** h)
18:40:24 <lambdabot> (. (***)) . (.) . (.) . uncurry
18:40:34 <Saizan_> nice :)
18:40:41 <SamB_XP> visualbasicgui: I'm *still* waiting for that comonad ...
18:42:24 <mmorrow> ah, found it
18:42:26 <mmorrow> http://www.mail-archive.com/haskell-cafe@haskell.org/msg58066.html
18:42:38 <mmorrow> @let coprod (<>) i1 i2 = (\a b -> i1 a <> i2 b)
18:42:38 <lambdabot>  Defined.
18:42:43 <MoALTz> "takeWhile (\n -> logBase 10 (fromInteger (t^n)) < fromInteger n) [1..]" selects correctly, while (what should be identical) "takeWhile (\n -> (fromInteger n) * logBase 10 (fromInteger t) < fromInteger n) [1..]" does not...
18:42:45 <mmorrow> @let prod   (><) p1 p2 = (\a   -> p1 a >< p2 a)
18:42:46 <lambdabot>  Defined.
18:43:11 <Axman6> : fprod
18:43:14 <ben0x539> Is there a web version of the typeclassopedia
18:43:22 <MoALTz> > takeWhile (\n -> logBase 10 (fromInteger (2^n)) < fromInteger n) [1..]
18:43:23 <mmorrow> @let diag = foldr (curry (prod mappend fst snd . uncurry (coprod mappend (splitAt 2) (splitAt 1)))) []
18:43:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:43:24 <lambdabot>  Defined.
18:43:38 * BMeph is astounded that mmorrow's successfully renamed liftM2 and on! :o
18:43:48 <MoALTz> > takeWhile (\n -> (fromInteger n) * logBase 10 (fromInteger 2) < fromInteger n) [1..]
18:43:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:44:10 <dolio> coprod isn't on, actually.
18:44:23 <mmorrow> coprod is on on CRACK!
18:44:38 <SamB_XP> you mean on `on` crack ?
18:44:41 <Saizan_> ?type [coprod , liftM2 ]
18:44:42 <lambdabot>     Occurs check: cannot construct the infinite type: t4 = t -> t4
18:44:42 <lambdabot>     Probable cause: `liftM2' is applied to too many arguments
18:44:42 <lambdabot>     In the expression: liftM2
18:44:48 <Axman6> sded
18:44:50 <mmorrow> SamB_XP: gah, yes
18:44:51 <Axman6> whoops
18:44:56 <SamB_XP> @type on `on` ?crack
18:44:57 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> c
18:44:57 <lambdabot>     Probable cause: `on' is applied to too many arguments
18:44:57 <lambdabot>     In the first argument of `on', namely `on'
18:44:58 <Axman6> :t fprod
18:44:59 <lambdabot> forall t2 t3 t4 t t1. (t2 -> t3 -> t4) -> (t -> t2) -> (t1 -> t3) -> (t, t1) -> t4
18:45:01 <Saizan_> ah, right, no final return
18:45:13 <SamB_XP> mmorrow: whoa, that's a pretty good trick then ;-P
18:45:38 <mmorrow> SamB_XP: (((`on` cRACK) !) ?)
18:45:57 <ivanm> I'm trying to use timeout, but for some reason I just had it going for over one and a half hours when I gave it a timeout value of 600000000, which should equate to 10 minutes
18:46:03 <ivanm> anyone know why it might do that?
18:46:09 <SamB_XP> @type (((`on` cRACK) ?!) ??)
18:46:10 <lambdabot> Not in scope: `cRACK'
18:46:10 <lambdabot> Not in scope: `?!'
18:46:10 <lambdabot> Not in scope: `??'
18:46:16 <SamB_XP> @type (((`on` ?cRACK) ?!) ??)
18:46:17 <lambdabot> Not in scope: `?!'
18:46:17 <lambdabot> Not in scope: `??'
18:46:20 <Axman6> ivanm: are you sure?
18:46:20 <SamB_XP> hmm.
18:46:31 <SamB_XP> something is wrong with the syntax of implicit parameters ;-(
18:46:32 <MoALTz> > takeWhile (\n -> (fromInteger n) * logBase 10 (fromInteger (2 :: Integer)) < fromInteger n) [1..] :: [Integer]
18:46:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:46:46 <mmorrow> @type ?(!)
18:46:47 <MoALTz> > takeWhile (\n -> (fromInteger n) * logBase 10 (fromInteger (5 :: Integer)) < fromInteger n) [1..] :: [Integer]
18:46:47 <lambdabot> parse error on input `?'
18:46:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:46:48 <ivanm> Axman6: the value provided is meant to be in terms of 1e-6 seconds
18:46:56 <dolio> ?! is an operator name, as is ??
18:46:56 <lambdabot> Maybe you meant: . ? @ v
18:46:58 <Axman6> > logBase 10 2
18:46:59 <lambdabot>   0.30102999566398114
18:47:01 <mmorrow> hmm, can you even have an implicit param that's a symbol?
18:47:10 <ivanm> Axman6: I had 1800000000 (half an hour), and it did timeout after half an hour
18:47:20 <SamB_XP> dolio: yeah, but I want for them to be implicit operator names ;-P
18:47:32 <dolio> Too bad.
18:47:38 <Axman6> mmorrow: x * (|n| < 1) is always going to be less than x
18:47:51 <Axman6> ivanm: extra szero perhaps?
18:47:56 <Axman6> uh, MoALTz, not mmorrow
18:48:16 <ivanm> Axman6: I had 1800000000 still there, and just added a `div` 3 to the end of it
18:48:27 <Axman6> :\
18:48:38 <ivanm> yeah :s
18:50:22 <Axman6> ivanm: did it happen to coincide with daylight savings time? :P
18:50:28 <ivanm> heh, no
18:50:34 <MoALTz> Axman6: mathematically log_B (x^y) == y * log_B x   right? if so then the only reason i can see why my original code worked was due to some precision quirk. trying to find the hackage code paste to post
18:51:20 <Axman6> @where hpaste
18:51:20 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
18:52:33 <mmorrow> (gah, and i called proc fplus instead of having fplus be coprod)
18:52:38 <mmorrow> s/proc/prod/
18:53:44 <mmorrow> i always reverse that, it's like when you turn the wrong way at some intersection the first time, you're forever screwed into triple-negating your first choice (which was correct) and turning the wrong way anyways
18:57:43 <ivanm> Axman6: check my logic: timeout says: "...return Nothing in case no result is available within n microseconds (1/10^6 seconds)..."
18:58:07 <ivanm> so if I have 60 * round 1e6, then that should be one minute?
19:02:31 <visualbasicgui> We are machines for turning coffee into theorems
19:02:52 <visualbasicgui> (i mean programmers or mathematicians, not just any old human)
19:03:01 <visualbasicgui> (they're machines for turning food into poop and babies)
19:03:51 * Saizan_ is a tea machine
19:04:48 * ddarius is a Thai tea machine
19:04:56 <mmorrow> visualbasicgui: the author of that quote was a machine for turning amphetamines into theorems
19:05:05 <dancor> i begrudge the simplication, humans emit like ten kinds of things.
19:05:07 <ivanm> Axman6: bah, suddenly worked for the one minute case
19:05:12 * ivanm is a juice machine
19:05:45 <dancor> some humans make machines even..
19:06:05 <ddarius> dancor: We already covered babies.
19:06:36 <dancor> lolmachine
19:06:55 * monochrom is in CPS, turns coffee-to-theorem machines to theorems
19:07:37 <ddarius> monochrom: That suggests that you provide the coffee.
19:07:53 <dancor> Const Brand Coffee
19:08:22 <dancor> now with more defined behavior
19:08:36 <mmorrow> @type (\f -> (\x -> f (Unsafe.Coerce.unsafeCoerce x x)) (\x -> f (Unsafe.Coerce.unsafeCoerce x x))) :: (coffee -> theorem) -> theorem {- monochrom ? -}
19:08:37 <lambdabot> forall coffee theorem. (coffee -> theorem) -> theorem
19:09:24 <monochrom> hahaha
19:09:39 <mmorrow> if you're Y, you need no coffee?
19:09:43 <monochrom> Thank you for the Y combinator!
19:09:48 <mwc> type Mathematician = Coffee -> Theorem
19:09:58 <dancor> [Theorem]
19:10:10 <mwc> actually, should be polymorphic over over the caffiene type
19:10:14 <dancor> i guess you can combine theorems
19:10:39 <monochrom> (Caffeine c) => c -> Theorem
19:10:52 <dancor> class Provable
19:11:08 <monochrom> (Caffeine c, Provable p) => c -> p
19:11:19 <mwc> and stimulants, like the iron triangle (tobacco + caffiene + scotch) like the old mathematicians in the dept tell us about from the good old days when we could smoke in the math building and there were no women's washrooms
19:11:28 <monochrom> (Caffeine c, Provable p, Arrow t) => t c p
19:11:55 <IceDane> It's not possible to use a where clause to define multiple patterns for the asme function? where f (x:Xs) = .. \n f [] = []
19:11:56 <IceDane> ?
19:12:16 <dancor> IceDane: you can, the f's have to line up
19:12:18 <visualbasicgui> i think so
19:12:19 <mwc> IceDane: check your layout
19:12:25 <visualbasicgui> IceDane: yes i think you can do that
19:12:39 <visualbasicgui> IceDane: like mwc says, remember indentation rules ("offside" rule etc...)
19:12:47 <IceDane> Yeah, I thought I was adhering to them
19:12:52 <monochrom> We do that all the time.
19:13:04 <visualbasicgui> IceDane: are you using emacs? I don't mean to preach but I installed haskell-mode and I've really never had to worry about these things. Just hit TAB until it makes sense.
19:13:05 <dancor> i don't do it that often
19:13:14 <dancor> ghci can't test nested complexities
19:13:26 <dancor> nor can tests ;)
19:13:29 <mwc> are those like naked singularities?
19:13:32 <monochrom> I turn coffee into where clauses with multiple patterns for the same function.
19:13:39 <visualbasicgui> hahaha
19:13:44 <IceDane> monochrom: Currently on windows, but I normally use vim
19:13:47 <visualbasicgui> I turned water and coffee grounds into coffe
19:13:49 <visualbasicgui> *coffee
19:14:18 <Saizan_> paste the code, maybe
19:14:19 <visualbasicgui> then came back here to see that I had turned an erdos quote mutilation into a series of haskell-themed jokes for me to peruse
19:14:20 <visualbasicgui> :D
19:15:40 <mwc> it's kind of scary that GHC has grown so large the darcs repo needs to be staged out of a tarball
19:16:06 <monochrom> GHC is larger than extralibs
19:16:58 <blackdog> anyone managed to get uvector compiling with 6.12?
19:18:05 <ivanm> blackdog: hey, I haven't managed to get 6.12 to compile 6.12 yet! :p
19:18:07 <Saizan> mwc: that mostly means it has a long history
19:18:31 <blackdog> ivanm: do you care how fast your compiler goes? :)
19:18:49 <ivanm> blackdog: well, it'd be nice to compile things reasonably quickly
19:18:58 <mwc> and that HTTP is a poor protocol for patch blasting. or hackage.h.o isn't as beefy as git.kernel.org
19:19:57 <BMeph> GHC 7 will be SkyNet. Either that, or it'll host SkyNet. ;)
19:20:12 <ivanm> heh
19:20:21 <ivanm> BMeph: you mean skynet won't be self hosting? :p
19:20:33 <monochrom> GHC 7 has unsafeLaunchMissile as promised in STM papers.
19:20:52 <sproingie> skynet was built on a chip from a terminator, that's the ultimate self-hosting
19:21:05 <monochrom> hahaha
19:21:08 * ivanm has long been tempted to get one of those USB missile gadgets just so that he can write unsafeLaunchMissile ...
19:21:13 <ivanm> sproingie: heh
19:21:19 <sproingie> ghc 7 will be built with ghc 8
19:21:25 <monochrom> hahahaha
19:21:25 <mwc> too bad it the chip wasn't from a terminator foot, the bootstrapping jokes write themselves
19:21:34 <monochrom> hahahah
19:22:18 <monochrom> wait, the chip was from an arm, no? so the joke writes itself, no?
19:22:34 <mwc> I thought they had an arm and part of the head
19:22:42 <mwc> HEAD joke maybe?
19:22:55 <monochrom> Oh even better, you need both head and arm, not just arm, to write a joke!
19:23:02 <mwc> Anyone think 6.12 gets released before december?
19:23:10 <ivanm> mwc: nope
19:23:17 <ivanm> there's meant to be a new RC soon IIRC
19:24:32 <sproingie> monochrom: it was based on the ARM architecture
19:24:42 <Axman6> sproingie: and ghc 8 will bve lazily written as paryts of it are needed to compile ghc 7?
19:24:48 <monochrom> hehe
19:24:57 <Axman6> bleh, frigging keyboard
19:24:57 <sproingie> ghc 8 won't actually exist til someone runs it
19:25:25 <tensorpudding> replace all the appearances of 6 in the source code with 8
19:25:37 <monochrom> ghc 7 kills all of us so no one will ask to build ghc 7
19:26:03 <monochrom> or complain about it giving poor error messages
19:26:17 <mwc> Either that or they'll do a lame drop the 6, and release GHC 12, 14, 16, etc.
19:26:27 <mwc> you know, pull an emacs
19:26:41 <sproingie> is that what emacs did?
19:26:43 <blackdog> when did emacs drop a number?
19:26:57 <monochrom> It was what java did.
19:27:04 <sproingie> and solaris
19:27:17 <Axman6> it's the hip thing to do
19:27:21 <sproingie> emacs still has minor versions.  it's just not that afraid of incrementing minor versions
19:27:36 <sproingie> linus is deathly afraid of the number 2.7 apparently
19:28:16 * blackdog hearts QuickCheck
19:28:17 <mwc> after version 1.12, the next release was 13, released in 85
19:28:39 <blackdog> nothing else could make bittwiddling code fun
19:28:55 <mwc> I don't think he wants to put the kernel back into the crapola of 2.4 and 2.5 concurrent development
19:29:32 <monochrom> "ghc 7 built with ghc 8" is nothing. just look at: windows 6 is built with windows 2000
19:30:25 <mwc> what is windows 6?
19:30:31 <MoALTz> Axman6: seems it was a precision thing. "logBase 10 (fromInteger (t^p)) < fromInteger q" is true until the conversion from (t^p) to Floating suddenly becomes Infinity
19:30:37 <monochrom> either xp or vista, I forgot
19:30:49 <mwc> isn't it WIndows 2000 = NT 5.0, XP = NT 5.1, Vista = NT 5.2, 7 = NT 5.3?
19:30:55 <sproingie> i guess vendors have gotten more savvy about picking kernel versions and integrating the patches they need
19:31:02 <Axman6> sounds about right. (though i think you mean Float or Double)
19:31:03 <sproingie> even slackware adds patches to vanilla kernel now
19:33:05 * roconnor doesn't recognise the name Miguel de Icaza
19:33:12 <ray> !!!
19:33:31 <Cale> roconnor: I think he's from the Gnome team?
19:33:37 <Cale> Maybe Mono?
19:33:45 <tensorpudding> who?
19:33:52 <Cale> Miguel de Icaza
19:33:52 <mwc> Mono has made him into the most controversial linux figure
19:34:00 <tensorpudding> yeah, he created gnome
19:34:07 <tensorpudding> and he's a big mono guy
19:34:15 <ray> there is nothing controversial about mono unless you still pay attention to rms
19:34:20 <p_l> I think Bonobo was more controversial :P
19:34:33 <tensorpudding> and some people got pissed because he was in support of the SUSE - Microsoft thing
19:34:35 <sproingie> who's the guy responsible for the gnome philosophy of "if it's useful, remove it"?
19:34:45 <Cale> I don't really get why implementing a programming language could make someone so controversial, even if that programming language was originally designed by Microsoft.
19:34:46 <Zao> sproingie: All of them?
19:35:04 <tensorpudding> well, mono is slowly taking over all of gnome
19:35:06 <p_l> especially when you take into account the source of Bonobo idea
19:35:07 <monochrom> hahaha, I like that, it's like avoid success at all costs
19:35:18 <tensorpudding> a lot of the new gnome apps are using it
19:35:33 <tensorpudding> and there was a kerfuffle about tomboy making it a requirement
19:35:35 <mwc> Cale: it's the VM and entire infrastructure, a full clone of .NET. The FUD is that once gnome is dependent on it, Microsoft brings out the patent stick
19:35:40 <sproingie> Cale: lots of very stupid people with nothing more than opinions and tribal hatred.  see also, slashdot.
19:35:47 <Cale> I wouldn't even mind the simplification of Gnome so much if the "simpler" things that they replaced other things with actually *worked*.
19:36:04 <Cale> pulseaudio is so annoying.
19:36:15 <Zao> Cale: In the last Gnome I tried, the "focus-on-mouse" setting was removed.
19:36:17 <p_l> GNOME's "simplification" was what made me leave it back with 2.4 or 2.2
19:36:19 <tensorpudding> i like pulseaudio, it's good
19:36:21 <sproingie> i loved how one gnome version had this search bar at the top, you could plug anything into it
19:36:24 <visualbasicgui> what would a "functional" processor even look like? has there ever been research into building one? It seems to me that a lot of monkeying around would have to be done translating haskell into machine code, which is imperative.
19:36:30 <sproingie> so naturally they got rid of it and replaced it with an icon
19:36:32 <Zao> s/removed/obliterated, but for an entry in gconf/
19:36:38 <Cale> visualbasicgui: Google for "Reduceron"
19:36:43 <visualbasicgui> yes?
19:36:45 <visualbasicgui> :) joy
19:37:20 <sproingie> transputer was designed to run occam, no?
19:37:25 <visualbasicgui> what other models of computation have been notable other than turing machines, or lambda calculus?
19:37:45 <dolio> Post systems.
19:37:56 <dolio> Mu recursive functions?
19:37:57 <Axman6> sproingie: i believe so
19:37:57 <tensorpudding> i left gnome for something simpler
19:37:57 <blackdog> visualbasicgui: finite automata?
19:38:06 <Cale> http://video.google.com/videoplay?docid=-1518197558546337776#
19:38:14 <rwx> visualbasicgui, petri nets
19:38:25 <sproingie> visualbasicgui: if you believe wolfram's hype, cellular automata
19:38:25 <rwx> visualbasicgui, insert arbitrary unorthodox model of computation here
19:38:32 <rwx> visualbasicgui, quantum computing
19:38:47 <Cale> er, that actually looks a bit different than I expected it to look, maybe it's the same talk I'm thinking of given in a different place
19:38:52 <rwx> sprang, like, omg, they are REPLICATE AND ARE UNPREDICTABLE
19:39:05 <visualbasicgui> I can't believe I went from java to c++ and thought "OH MAN MAH BRAINS EXPLODIN"
19:39:12 <visualbasicgui> I'm just trying to become aware of as many different
19:39:15 <sproingie> i'm pretty sure his CA are deterministic
19:39:18 <rwx> visualbasicgui, are you looking for turing-equivalent models ?
19:39:19 <visualbasicgui> _totally_ different paradigms
19:39:21 <visualbasicgui> or models as possible
19:39:30 <sproingie> which more or less makes them turing machines with eye candy
19:39:33 <rwx> sproingie, i was being sarcastic. but anyway, unpredictable != deterministic
19:39:36 <rwx> cf. chaos theory
19:39:44 <visualbasicgui> rwx: what this mean?
19:39:56 <sproingie> sure, there's emergent complexity
19:39:58 <rwx> cf. halting problem
19:40:08 * Axman6 has seen turing machines implemented in the game of life before
19:40:10 <sproingie> which i think is ultimately what he's fascinated with
19:40:29 <visualbasicgui> Axman6: I remember the first time I loaded that file into some life viewer
19:40:36 <visualbasicgui> Axman6: I teared.
19:40:36 <rwx> visualbasicgui, well there are such things like finite automata, regular grammars, stuff like that, that aren't as "powerful" as turing machines. look at the wikipedia article for the "chomsky heirarchy"
19:40:45 <tensorpudding> they recently implemented a turing machine in the game of life
19:40:48 <mauke> RIP AND TEAR
19:40:50 <visualbasicgui> I've seen that
19:40:52 <visualbasicgui> it's so amazing
19:41:01 <visualbasicgui> what super brain coded that structure?
19:41:08 <sproingie> usually based on gliders, glider guns, and glider eaters
19:41:14 <sproingie> and glider bouncers
19:41:22 <tensorpudding> glider flip-flops
19:41:35 <visualbasicgui> glider quuxers
19:41:43 <visualbasicgui> glider capacitors
19:41:47 <visualbasicgui> you know, the usual
19:41:52 <visualbasicgui> *looks at nails*
19:41:56 <visualbasicgui> nothin much
19:42:05 <monochrom> glider tweeters
19:42:13 <rwx> visualbasicgui, the cool thing about models of computation is that you can probably take an arbitrary input/output system and talk about its computational powers
19:42:14 <monochrom> glider followers
19:42:23 <rwx> visualbasicgui, e.g. what's the computational power of an abacus? or whatever
19:42:29 <tensorpudding> glider gun gun guns
19:42:37 <mwc> anyone else think it's madness that cabal builds are still serial?
19:42:43 <rwx> visualbasicgui, anyway, i highly recommend scott aaronson's blog. he makes complexity theory pretty accessible
19:42:45 <monochrom> "in 140 gliders or less"
19:42:48 <tensorpudding> it generates glider gun guns
19:42:54 <blackdog> mwc: absolutely. somebody really ought to bell that cat:)
19:42:59 <sproingie> monochrom: twitter life?
19:43:30 <visualbasicgui> rwx: i'm wiki'ing these as you lsit them off
19:43:36 <visualbasicgui> rwx: my mind is expanding
19:43:42 <visualbasicgui> rwx: thanks :)
19:43:43 <rwx> hehe
19:43:48 <rwx> np
19:44:03 <sproingie> an abacus by itself has no computational power, it's just a bunch of beads
19:44:14 <visualbasicgui> tensorpudding: HAHAHA @ glider gun gun guns
19:44:16 <BMeph> Mmmm...channel Bill Gosper twice: make a continued-fraction glider gun! ;)
19:44:16 <sproingie> you supply the computation
19:44:34 <rwx> visualbasicgui, also, scholarpedia doesn't get listed as highly in google search rankings as it should. it's completely awesome. check out articles on algorithmic information theory and associated things. they are written by experts in the field, sometimes nobel/etc winners
19:44:36 <tensorpudding> what would a c-f glider gun do, praytell?
19:45:05 <tensorpudding> some of scholarpedia's articles are superfantastic and others are terrible
19:45:28 <sproingie> scholarpedia sounds like it has the same goals as citizendium
19:45:41 <tensorpudding> the terrible ones are generally really deep but not nearly broad enough; for example they might completely miss a subtopic that was the reason you were searching
19:46:27 * hackagebot upload: Omega 0.2.0 - Operations on Presburger arithmetic formulae (ChristopherRodrigues)
19:46:29 <visualbasicgui> tensorpudding: reminds me of the simpsons clip with "truck truck truck"
19:46:30 <tensorpudding> sometimes it's better to have an encyclopedia to just collate sources that you can search, rather than attempt to explain everything
19:46:44 <visualbasicgui> scholarpedia hmmmmm
19:46:47 <rwx> the one on the chinese room argument was written by the guy who published it, searle i think? and the tone is completely NOT neutral
19:46:50 <visualbasicgui> brb researching 20 open tabs
19:46:59 <visualbasicgui> once the stack pops off to a reasonable size i'll return
19:47:02 <rwx> i take the 'cybernetics approach' to the argument, and he lists that as a basically silly counterpoint to his views
19:47:07 <visualbasicgui> oh and before i go
19:47:09 <visualbasicgui> searle is stupid
19:47:16 <rwx> o/
19:47:31 <visualbasicgui> i listened to a whole lecture series by him
19:47:36 <sproingie> unfortunately, "battling ideas" doesn't converge toward useful wikipedia articles either.
19:47:39 <visualbasicgui> he's smart but
19:47:46 <visualbasicgui> ugh
19:47:50 <visualbasicgui> sometimes he just has no clue
19:47:55 <visualbasicgui> the chinese room specifically
19:48:05 <visualbasicgui> THE ROOM UNDERSTANDS CHINESE MAN
19:48:07 <visualbasicgui> THE ROOOOOM
19:48:11 <rwx> yeah haha
19:48:22 <rwx> that's what he calls the cybernetics reply
19:48:25 <sproingie> visualbasicgui: it always makes me think of some kind of horror movie
19:48:26 <rwx> like, no shit, it's a SYSTEM
19:48:28 <rwx> THANKS
19:48:48 <visualbasicgui> lol
19:48:49 <visualbasicgui> oh
19:48:53 <visualbasicgui> damn you keep pulling me back here
19:48:53 <visualbasicgui> but
19:48:56 <visualbasicgui> before i go
19:49:01 <visualbasicgui> i have this AMAZING book that's
19:49:03 <mauke> visualbasicgui: STOP HITTING ENTER SO OFTEN
19:49:15 <sproingie> visualbasicgui: except instead of chinese it's writing from the elders of r'lyeh
19:49:55 <visualbasicgui> basically my life's goal to understand. It's this book from mit press called "cybernetics, or control in the animal and machine" or something. Google it. And sorry for hitting enter so often. I will compose in paragraphs henceforth.
19:50:39 <mauke> nice
19:50:54 <monochrom> You should finish writing your own dissertation before hitting enter. <duck>
19:51:35 <sproingie> well i have to say wikipedia's article on chinese room is actually pretty damn superb
19:51:47 <roconnor> sproingie: link
19:51:48 <Axman6> yeah, the enter key is a finite resource. quit wasting it visualbasicgui ;)
19:52:06 <sproingie> well superb though not entirely in line with encyclopaedic style
19:52:14 <sproingie> roconnor: http://en.wikipedia.org/wiki/Chinese_room
19:53:05 <sproingie> stylistically speaking it's a mess, but it includes a whole lot of perspectives on it
19:53:29 <sproingie> mine is that Searle is himself just an English Room and doesn't really understand language
19:54:08 <monochrom> Well said, sproingie.
19:56:26 <sproingie> seems folks like Searle and Penrose and whatnot are just deathly afraid of the idea of being "reduced to machines"
19:57:40 <ddarius> sproingie: If you can't beat them, join 'em.
19:58:00 <visualbasicgui> sproingie: YES
19:58:02 <monochrom> And I have joined machines.
19:58:23 <visualbasicgui> sproingie: you see this a lot in touchy feely humanities majors as well. "The internet is killing our ability to slow down and THINK, MAN"
19:58:31 <sproingie> i take descarte's view, cogito ergo sum.  which doesn't actually mean "thinking makes me exist", it's "if I think I exist, I might as well even if I don't"
19:58:42 <rwx> well the internet surely is changing our cognitive patterns, whatever that means
19:58:51 <visualbasicgui> I think for the better, as long as you can adapt.
19:59:04 * ddarius would think thinking would be an existence proof...
19:59:08 <visualbasicgui> Plato said of books, because they were a developing medium in his time, that they would destroy our ability to think
19:59:24 <rwx> sproingie, descartes' notion is more primitive than that: he said, "if i can doubt my own existence, i must exist"
19:59:28 <visualbasicgui> They didn't destroy our ability, but I suppose they did change our thought patterns and habits
19:59:55 <rwx> btw i highly recommend the free book "accelerando". it won a LOT of awards, and is awesome re: transhumanism
20:00:12 <visualbasicgui> Homer communicated his poems mostly orally. He must have had an impressive memory to keep that all stored up in his head, even if he did use verse and rhyme and repetitive syntax and structure and improvisation to help him remember.
20:00:25 <junmin> hello, how can reprentate a rule of natural numbers? nat ::= 0|1|2|... how can remove the "..."? thanks
20:00:26 <sproingie> rwx: well unfortunately he uses it as a stepping stone to Yet Another Proof Of God, but as an existentialist argument it works pretty well too
20:00:34 <blackdog> visualbasicgui: to an extent they did - the measure of intelligence used to be an incredible memory. a greek storyteller would know many epic stories word-for-word. very few people train their memories that way any more
20:00:53 <blackdog> visualbasicgui: blah, what you said:)
20:01:05 <rwx> blackdog, in aus?
20:01:08 <visualbasicgui> blackdog: hahaha
20:01:12 <blackdog> rwx: yeah
20:01:55 <visualbasicgui> sproingie: the funniest thing about descartes to me was that he says "i will begin by doubting everything that i have ever believed! I will banish all inherited biases and start from the raw truth! oh and btw god still"
20:02:16 <sproingie> visualbasicgui: well he had an agenda
20:02:57 <visualbasicgui> sproingie: i think it was partly that, and partly the fact that we can't really understand, living in a time which is so secular, how DEEPLY ingrained were the habits of religious thought in descartes's time
20:03:06 * sproingie .oO( #haskell-philosophy )
20:03:17 <rwx> blackdog, <- inert
20:03:20 <visualbasicgui> sproingie: it's like doubting materialism, or the results of physics for us.
20:03:35 <blackdog> Pascal's Wager is another interesting example of that - the man's obviously a genius, but somehowe doesn't manage to pick up on the idea of probability density
20:03:42 <visualbasicgui> hahahahaha
20:03:54 <blackdog> rwx: inert?
20:04:23 <sproingie> the flaws of pascal's wager are pretty self-evident
20:04:36 <visualbasicgui> pascal's wager always strikes me as just far too sneaky to be a really convincing argument for being pious. There should be a more human, intuitive argument for it than "this is how you can exploit the system"
20:04:37 <sproingie> answer C: there is a god, his name is Quetzlcoatl, and he's pissed off.
20:05:15 <dolio> junmin: Represent a rule in what context?
20:05:33 <visualbasicgui> hahahahhaha quetzlcoatl is just one of the intersections between our dimensional plane and the pan-dimensional time-god whos most recent incarnation on our planet was michael jackson
20:06:03 <visualbasicgui> he will return in 2012 with all new dances and a new album whose every track will top the charts for a thousand years
20:06:12 <visualbasicgui> and he will unite all humanity in prosperity and celebration
20:06:19 <visualbasicgui> michael jackson, i mean.
20:06:39 <Raevel> i'm confused
20:06:44 <visualbasicgui> junmin: yes, repeat your question. we've sort of derailed.
20:06:50 <blackdog> visualbasicgui: that interpretation of the wager doesn't really invalidate it, though. there's no reason god can't be a literal-minded bastard.
20:06:58 <junmin> dolio: well, i am trying to write a parser of the Arithmetic Expressions
20:07:12 <junmin> visualbasicgui: a sample in the book Programming in Haskell
20:07:16 <visualbasicgui> blackdog: well yes that's true, but even if he did exist, if he was such a pedant, I'd just not believe in him out of spite.
20:07:27 <dolio> Using a library?
20:07:34 <rwx> junmin, cross reference maybe with "write yourself a scheme in 48 hours"
20:08:01 <blackdog> visualbasicgui: that's highly irrational:)
20:08:09 <Cale> junmin: A natural number is either zero or it is the successor of another natural number
20:08:22 <visualbasicgui> Cale: peano ftw
20:08:35 <dolio> That doesn't help with parsing decimal numerals.
20:08:53 <blackdog> i think rowan atkinson demolished it best in his devil sketch. after going through robbers, hindus, moslems, etc etc etc, and assigning them all to hell, he looks down at his clipboard
20:08:58 <visualbasicgui> dolio: constructing the reals is MUCH harder than the positive integers & 0.
20:09:05 <junmin> dolio: agree with dolio
20:09:11 <blackdog> and says "Oh, and Christians? I'm _so_ sorry, the jews were right..."
20:09:30 <visualbasicgui> i think its on a rotation to be fair. I just hope i die during saganist week
20:09:44 <visualbasicgui> and yes lol i've seen that
20:09:50 * sproingie is a devout pastafarian.  Ramen.
20:09:59 <junmin> rwx: i have no experience with scheme :|
20:10:43 * junmin going to eat, brb
20:10:49 <dolio> Well, I don't know how you're parsing things, but you'd probably do well to create a parser for digits 0 - 9, and a parser that parses one or more copies of another parser.
20:10:53 <dolio> And then combine the two.
20:10:56 <visualbasicgui> how do i do those little status asterisk thingies?
20:11:06 <tensorpudding> the first thing you can do with scheme, is write a scheme
20:11:46 <Cale> visualbasicgui: are you referring to /me ?
20:11:59 * Cale uses /me to perform an action
20:12:07 <monochrom> /me does
20:13:03 * visualbasicgui thanks cale with a million internet dollars
20:13:20 * visualbasicgui wonders what the escape sequence for "/" commands is
20:13:31 <Cale> usually another /
20:13:34 <Cale> /
20:14:16 <p_l> visualbasicgui: in irssi, it's / + space
20:14:20 <p_l> /
20:14:39 <monochrom> /say /me
20:14:52 <visualbasicgui> / slash
20:16:06 <monochrom> It goes meta quickly. It is like reading Lamport's book on LaTeX. "But how did you get \begin printed as \begin?"
20:16:53 <p_l> lol
20:16:55 <tensorpudding> hmm, that's a good question
20:17:03 <tensorpudding> how do they print latex code in latex?
20:17:04 <aavogt> \\begin
20:17:12 <mauke> "Easy. I wrote that book in MS Word."
20:17:20 <aavogt> or perhaps an environment that ignores stuff...
20:17:22 <aavogt> heh
20:17:25 <p_l> tensorpudding: \begin{verbatim} ... \end{verbatim} ? :D
20:17:36 <mauke> aavogt: isn't \\ a line break?
20:17:54 <tensorpudding> p_l: sounds reasonable
20:18:22 <p_l> tensorpudding: there was also the command to insert printable \
20:19:49 <aavogt> mauke: true
20:20:37 <ivanm> I need to work out how to tell quickcheck not to recursivley shrink too much :s
20:21:35 <aavogt> ivanm: how can shrinking be bad?
20:21:50 <ivanm> aavogt: it's taking up too much memory and spending way to long trying to shrink the one thing
20:22:06 <ivanm> aavogt: because it's quite possible I've told it to over shrink :s
20:22:46 <ivanm> or the shrink definitions are recursing too much
20:22:46 <aavogt> perhaps you would spend way too long to interpret the unshrinked case
20:23:05 <Cale> \backslash
20:23:23 <ivanm> aavogt: hmmm?
20:24:03 <ivanm> aavogt: I'm also getting decimal shrinks for some reason :s
20:27:51 <visualbasicgui> I have a stylistic question, or rather i guess poll
20:28:01 <visualbasicgui> who prefers to use $ and who prefers to use parens?
20:28:14 <visualbasicgui> I find multiple $'s just as ugly as multiple parens
20:28:14 <ivanm> in most cases, just about everyone here uses $ AFAIK
20:28:18 <visualbasicgui> yes?
20:28:22 <visualbasicgui> well yeah i suppose
20:28:24 <ivanm> visualbasicgui: usually only a single $ though
20:28:24 <visualbasicgui> that
20:28:27 <dolio> . should be used, too.
20:28:31 <ivanm> visualbasicgui: f . g . h . k $ x
20:28:34 <ivanm> or something like that
20:28:46 <visualbasicgui> yes I suppose the reasoning would be that parens contribute twice as much noise and in the wrong place.
20:28:52 <ivanm> visualbasicgui: I do use parens when doing something like foo (bar x) `onFail` baz
20:28:58 <visualbasicgui> Yes it's definitely just a matter of habituation.
20:29:08 <visualbasicgui> I use at most 1 parens
20:29:13 <ivanm> since using $ parses it wrongly (and it takes me forever to work out why :s )
20:29:27 <ivanm> visualbasicgui: exactly; nesting parens is ugly
20:30:07 <visualbasicgui> Yeah the rules around $ are more confusing I guess, but I think that's just a matter of getting used to those rules. For example function application is just as different in haskell, but for some reason I've gotten used to it more. Composition of functions, and the $ operator I guess are just the same.
20:30:14 <visualbasicgui> Almost as soon as I posted, I realized I like $ better.
20:30:33 <visualbasicgui> There's something very pretty and refreshing about f . g . h . k $ x
20:30:34 <ivanm> heh
20:31:00 <byorgey> visualbasicgui: no, function composition and $ are quite different.
20:31:02 <monochrom> I use parens. I don't like $
20:31:10 <ivanm> monochrom: :o
20:31:17 <byorgey> $ is function application
20:31:19 <monochrom> Yes I would rather write (f . g . h) x
20:31:19 <tensorpudding> but $ is so nice sometimes
20:31:42 <byorgey> for example f . g . h $ x  and f . g . h . x  are not the same thing
20:32:45 <rwx> can you think about $ as just implying a set of parens?
20:32:48 <ivanm> but f . g . h $ x and f $ g $ h $ x are (usually) the same
20:32:48 <monochrom> I blame it on tradition and education. The tradition is: "the function f(x)" as opposed to the correct "the function f".
20:32:59 <ivanm> rwx: pretty much
20:33:04 <ivanm> monochrom: hmmmm...
20:33:18 <Saizan> i think he meant that they are both the same wrt getting used to
20:33:53 <ddarius> Mathematicians are horribly sloppy.
20:34:25 <visualbasicgui> if mathematicians were as rigorous as mathematics really demands, every proof would be a billion pages and most would never get written at all
20:34:35 <monochrom> Did you know, the other day, someone asked "can you pass a function to itself in haskell?"  Do you know what we found to be on his mind after half an hour of torture?  "so like f(f(x))"
20:34:46 <visualbasicgui> that's why we have abstraction. It's sort of like saying "haskell coders are sloppy." We're not, we're just more abstract. Nobody wants to write bits and bytes.
20:34:53 <ddarius> visualbasicgui: That's not true at all, no more than every program is a billion pages.
20:34:55 <monochrom> "the function f(x)" my ass
20:35:08 <ivanm> monochrom: *groan* saying f (f (x)) doesn't even make sense!
20:35:19 <visualbasicgui> monochrom: *face PALM*
20:35:41 <visualbasicgui> ddarius: read what i said about abstraction
20:35:42 <ddarius> let f x y = y, now the function f(x) is...
20:35:52 <ddarius> visualbasicgui: The sloppiness had nothing to do with abstraction.
20:36:36 <visualbasicgui> What's an example of sloppiness in (proper) mathematics that isn't just abstraction? I don't think such a thing exists in proper mathematics. Perhaps you're just referring to an error in calculation?
20:36:53 <ddarius> visualbasicgui: The example monochrom brought up is an example of sloppiness.
20:37:08 <visualbasicgui> ah you mean notation
20:37:11 <visualbasicgui> yes yes
20:37:15 <visualbasicgui> mathematical notation is sloppy
20:37:28 <monochrom> 3 x, 3 1/2, sin 1/2
20:37:49 <visualbasicgui> but since all notation is really just an agreed-upon _representation_ of true mathematical structure, the _thoughts_ expressed in that notation are pure or abstract, but never sloppy.
20:37:54 <visualbasicgui> yes notation can be sloppy sometimes.
20:38:04 <visualbasicgui> ambiguous. that's because it's language.
20:38:17 <rwx> visualbasicgui, destroy mathematical platonists!!
20:38:41 <visualbasicgui> rwx: what's your stance on the ontology of mathematical objects?
20:38:55 <rwx> they aren't
20:39:00 <visualbasicgui> :D hahaha
20:39:05 <rwx> :D
20:39:13 <visualbasicgui> points for style, but i don't know how you've arrived at that conclusion
20:39:19 <rwx> take set theory
20:39:23 <monochrom> language does not have to be ambiguous. haskell is a language, not ambiguous. first-order logic is also given a language, not ambiguous. you could say ambiguous languages have uses, and I agree, such as poems and jokes. But not for math.
20:39:27 <rwx> what's a physical analogue of a set?
20:39:56 <visualbasicgui> what, in the 3 dimensions of space and 1 of time usually considered the "physical" world?
20:39:58 <rwx> (disregarding for now infinite sets, axiom of choice, etc)
20:40:08 <rwx> well, yeah, does mathematics describe the world?
20:40:23 <rwx> we use it to talk about the world
20:40:28 <rwx> but is it the language of reality?
20:40:51 <visualbasicgui> none. But i think the world of physical objects in the colloquial sense seems necessarily to exist. This could only be the case if at bottom it were composed of something as necessary as logic or mathematics.
20:41:01 <adu> monochrom: my math teacher says ambiguity is when we define one thing to mean two things
20:41:09 <rwx> adu i like that
20:41:14 <byorgey> rwx: "sets don't have *physical* analogues" is not a very convincing counterargument to mathematical platonism.
20:41:19 * ddarius finds nothing necessary about logic or mathematics.
20:41:28 <rwx> byorgey, feel free to jump in
20:41:33 <visualbasicgui> hmmm
20:41:33 <adu> and he uses it as an excuse to define wierd notations, because HE never defined them before in the class
20:41:43 <byorgey> rwx: I just did. =)
20:41:49 <rwx> more :)
20:42:03 <visualbasicgui> ddarius: I suppose at least you could say that logic or mathematics are necessary laws of thought, but perhaps not of the real world. Maybe we structure our experience of the lawless world in such a way that our logic describes it?
20:42:06 <rwx> visualbasicgui, isn't that by definition, that it would be "built" on something that is necessary?
20:42:12 <dolio> How about if you guys don't have another 8 page off-topic philosophy discussion?
20:42:32 <byorgey> hehe, yeah, #haskell-blah it is
20:42:35 <rwx> how about i note that i am refreshed to talk seriously about these things with people who don't read continental philosophy all day?
20:42:42 <rwx> hehe
20:42:48 <visualbasicgui> hey! i dont :(
20:43:02 <visualbasicgui> I'm really into the more rigorous types
20:43:17 <monochrom> Yeah, such as Hindley-Milner types.
20:43:24 <visualbasicgui> awww rwx you hurt my heart
20:43:44 <adu> I like JavaScript types
20:43:56 <Axman6> javascript has types?
20:43:57 <visualbasicgui> WELL if anybody has a complaint about being off track, then perhaps they could raise something interesting to talk about in haskell-world?
20:44:09 <monochrom> I hate $
20:44:19 <Axman6> visualbasicgui: there's a place for off topic talk: #haskell-blah
20:44:29 <visualbasicgui> :_(
20:44:31 <Axman6> monochrom: i'll take all your money if you like
20:44:35 <visualbasicgui> _sorry_
20:44:35 <dolio> We could get some unicode. Then we could write: f â g â h â¢ x
20:45:04 <Saizan> why â¢ for $?
20:45:04 <dolio> Also, we could make the application operator associate the right way.
20:45:07 <visualbasicgui> i'll just be in the corner reading RWH if anybody needs me :(
20:45:07 <Axman6> frigging windows
20:45:08 <ddarius> dolio: We could be like those crazy relational people and write x.h.g.f
20:45:10 <rwx> unicode would be nice; does latex in haskell help much for that?
20:45:12 <monochrom> But I prefer f â¢ g â¢ h â x
20:45:14 <Axman6> huh, Saizan's worked
20:45:15 <blackdog> visualbasicgui: he's not really having a go. We like off-topic-ness, that's why we started a channel for it.
20:45:27 <Axman6> what';s the thing bevfore x there monochrom?
20:45:37 <monochrom> hollow circle
20:45:42 <Axman6> ah
20:45:48 <Saizan> Axman6: weird, i copy/pasted
20:45:49 <Axman6> it's a hollow square here :P
20:45:53 <dolio> Saizan: Well, in the font I originally typed it in, it looked like a black circle about the same size as the composition operator.
20:46:07 <Axman6> Saizan: the things after the f and g were boxes
20:46:08 <Saizan> (oh, it's just irssi decoding it right, maybe)
20:46:11 <visualbasicgui> blackdog: oh right! *smack face* xchat can join multiple channels! Okay I won't be a bother. Debate your operator preferences at will, everybody.
20:47:24 <Saizan> dolio: so i guess it relates to Applicative functors' <*>?
20:54:09 <opdolio> ddarius: x;h;g;f would be the (a) category theory motivated notation, but that's not available, unfortunately.
20:55:10 <ddarius> opdolio: ; is just flip (.).  CT views values as functions from the terminal object.  The . above was flip ($).
20:55:27 <opdolio> Or maybe it is.
20:55:51 <opdolio> If you have indexed monads, then you could do 'do x ; h ; g ; f' in the indexed writer monad.
20:57:53 <opdolio> Well, since application is just composition, flip (.) and flip ($) are pretty much the same. :)
21:21:14 <IceDane> Does anyone else experience strange behavior in ghci after you use it to run something that makes your cpu go apeshit, and then ctrl+c it?
21:21:29 <IceDane> Every time I type something in it, it goes to the top of usage, even if it's nothing
21:21:54 <ivanm> IceDane: are you forking it?
21:22:16 <IceDane> ivanm: Nope
21:22:46 <ivanm> no idea then
21:22:55 <ivanm> IceDane: how are you running ghci? just in a terminal?
21:24:33 <Saizan> maybe it allocated a lot of memory? it doesn't return it to the OS
21:27:37 <IceDane> ivanm: yeah, sorry
21:27:41 <IceDane> just running it from urxvt
21:27:54 <ivanm> so we can't blame emacs then...
21:28:57 <IceDane> Saizan: Yeah, I was basically finding intersections between two infinite lists(I know that it'll never stop, but at least it'll display all intersections, which is all I need.) Either way, when I do it, it churns a lot of memorya nd cpu, but when I kill it it stops
21:29:07 <IceDane> but then it doesn't use any memory or cpu until I just start typing and hit enter or something
21:30:24 <IceDane> On another subject; is there no configuration file to specify default options for ghci? I'd like to have -fwarn-incomplete-patterns on always, as well as +t
21:31:06 <SamB_XP> IceDane: how about ~/.ghci ?
21:31:13 <SamB_XP> put a :set command in there
21:31:33 <IceDane> Oh, sweet. I tried the man page but I couldn't find anything about it
21:31:42 <IceDane> thanks =)
21:31:54 <SamB_XP> it's also possible the file is called ~/.ghcirc
21:32:11 <roconnor> :set -fno-print-bind-result
21:32:13 <roconnor> :set -fno-monomorphism-restriction
21:32:19 <roconnor> that is the contents of my .
21:32:23 <roconnor> my .ghci file
21:32:31 <IceDane> SamB_XP: .ghci worked
21:42:37 <ivanm> gah, I'm having problems with QuickCheck because I have recursive data structures, and its created a structure so deep that I'm having trouble getting to the bit that has the actual problem! :@
21:43:14 <roconnor> ivanm: sized?
21:43:27 <ivanm> default
21:43:31 <ivanm> well, not quite
21:43:51 <ivanm> I have DotSubGraphs contain a DotStatements, which in turn can contain a list of DotSubGraphs
21:43:56 <ivanm> that list can be no larger than 2
21:47:36 <byorgey> ivanm: are you using the 'sized' combinator?
21:47:53 <ivanm> byorgey: only for generating the DotSubGraphs inside DotStatements
21:48:01 <byorgey> interestingly, this directly relates to my current research
21:48:14 <byorgey> maybe in a few months I will have a nice tool that will solve your problem =)
21:48:27 <ivanm> anyway, I think I can maybe get it to work by having a Bool-based arbitrary-like function for DotStatements on whether it should generate any DotSubGraphs...
21:48:33 <ivanm> byorgey: heh, bit late then ;-)
21:48:37 <ivanm> byorgey: what are you working on?
21:49:47 <byorgey> ivanm: stuff related to combinatorial species in general; in particular much better test generation for recursive structures
21:49:54 <ivanm> wait, I'm not using sized
21:49:57 <ivanm> I'm using resize
21:50:06 <ivanm> byorgey: hmmm...
21:51:45 <byorgey> ivanm: as you have discovered, the state of the art in test generation for recursive structures is quite horrible.
21:51:51 <ivanm> yeah
21:52:36 <byorgey> ivanm: actually, would you mind sending me a quick description of the data structures you're using and the problem you are running into?  It would be nice to have some real-world examples =)
21:52:46 <ivanm> byorgey: the graphviz package
21:52:56 <byorgey> ah, right
21:53:00 <ivanm> byorgey: specifically, the ones in Data.GraphViz.Types
21:53:06 <ivanm> I'm just trying to add tests now
21:53:15 <jl_2> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5035#a5035
21:53:21 <jl_2> why would that code not work?
21:53:24 <byorgey> ivanm: I just used the graphviz package the other day, actually
21:53:30 <ivanm> yay! it's hella faster now! \o/
21:53:32 <ivanm> byorgey: \o/
21:53:33 <byorgey> it was overall a quite pleasant experience =)
21:53:37 <ivanm> yay!
21:53:44 <ivanm> I'm getting quite pleased with it tbh
21:53:46 <jl_2> it says splitRegex and mkRegex are not in scope
21:54:04 <Saizan> ?hoogle splitRegex
21:54:04 <lambdabot> Text.Regex splitRegex :: Regex -> String -> [String]
21:54:05 <ivanm> byorgey: especially since to begin with, it was "dammit, I have to maintain this now that matthew-_ doesn't want it just so I can use it elsewhere? :@ "
21:54:06 <ivanm> ;-)
21:54:19 <Saizan> jl_2: you've to import Text.Regex , it seems
21:54:22 <byorgey> ivanm: hehe
21:54:26 <byorgey> ivanm: I especially think it's cool that it can just use graphviz as a layout engine and read the absolute node positions etc. back in
21:54:49 <Saizan> jl_2: also, you probably want to add a print in front of that expression, since main has to be an IO action
21:54:50 <jl_2> Could not find module `Text.Regex'
21:54:54 <byorgey> (not that I have used that feature yet, I just noticed it while looking through the haddocks)
21:55:18 <jl_2> eh, that's just the simplest test case that fails to compile
21:55:21 <ivanm> byorgey: yeah, that was one reason why I chose graphviz rather than one of the other dot packages available at that time
21:55:52 <jl_2> how do I get Text.Regex?
21:56:05 <ivanm> jl_2: it's in the regex-base package
21:56:15 <jl_2> I have just about every *.Regex.* package in debian's repo installed
21:56:18 <ivanm> jl_2: you then need one of the regex-* engines, such as regex-posix though
21:56:51 <Saizan> it's in regex-compat, actually
21:57:05 <ivanm> byorgey: I actually found a huge bug in that a release or two ago where the positions could be read, but not the splines of the edges... >_>
21:57:11 <ivanm> Saizan: oh *shrug*
21:57:21 <byorgey> ivanm: hehe, whoops
21:57:26 <jl_2> that figures - that's the only one I don't have
21:57:47 <ivanm> byorgey: never caught it before since i was only considering node positions
21:57:53 <Saizan> jl_2: hoogle is quite useful for these kind of things
21:58:03 <ivanm> byorgey: and that was part of the original code that matthew-_ had, so he was probably never using the edge splines either
21:58:11 <jl_2> ... because it depends on an older version of regex-posix (?)
21:58:16 <ivanm> jl_2: hayoo is also helpful
21:58:34 <ivanm> jl_2: there's two branches of regex-*; 1.13 is "stable", 1.19 is "Development"
21:58:49 <ivanm> and it annoys dcoutts because they're some of the packages that split hackage... ;-)
21:59:01 <Saizan> those versions are of HaXml :)
21:59:27 <Saizan> there's 0.7x and 0.9x in regexes, though
21:59:32 <ivanm> Saizan: oh, right
21:59:35 <ivanm> yeah, 0.7x and 0.9x
21:59:42 <ivanm> except for tdfa, which is now 1.x
21:59:46 <jl_2> regex-compat says it's the "old" interface
21:59:51 <ivanm> there was 0.8x at one stage...
21:59:55 <jl_2> is there a "new" interface I could use?
21:59:57 <ivanm> of some of them at least
22:00:12 <ivanm> jl_2: have you seen the RWH chapter on regexes?
22:00:52 <Saizan> the one in regex-base should be the new one
22:01:53 <Saizan> http://hackage.haskell.org/package/regex-base-0.83 <- or pick a different version
22:02:13 <jl_2> I know it came up when I googled "haskell regular expressions", but I don't think it used a "split" function
22:08:53 <ivanm> anyway, now that I'd finally thought of limiting creation of sub-graphs, I managed to track down the bug that's been annoying me all day :@
22:09:51 <ivanm> strangely enough, "-" isn't a valid string representation of a number... >_>
22:14:10 <jl_2> Is this describing the new interface? http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
22:14:16 <jl_2> using (=~)?
22:14:27 <ivanm> jl_2: yes
22:14:38 <ivanm> that's bos' blog; he's one of the trio that wrote RWH
22:14:52 <ivanm> (which is stated so on the page :p )
22:15:23 * ivanm guesses that the RWH chapter grew out of that blog post
22:16:31 <jl_2> "123:456" =~ "([0-9]+)" :: [String] doesn't seem to work for me either
22:17:02 <ivanm> so that should return ["123", "456"]
22:17:16 * ivanm has never used the regex libs before; this is all from what he's read in RWH :p
22:17:34 * jl_2 is starting to think Debian's regex libraries for ghc are in a bad state
22:18:18 <jl_2> frustrating thing is I thought I'm sure I had it working at one point, a long time ago
22:18:25 <Gracenotes> regex libraries in hackage
22:18:43 <jl_2> I just can't find the code
22:18:56 <Gracenotes> well. there are good ones. me likes regex-tdfa a lot
22:19:51 <path_> could someone explain to me how to read a series of numbers into a list? like if I have 5 4 3 2 1 as input on the command line
22:21:14 <Gracenotes> path_: well, in terms of types, you go from String to [String] to [Int], right?
22:21:15 <Cale> path_: Well, the IO action getArgs will get the list of commandline arguments
22:21:25 <Cale> (as a list)
22:21:42 <Cale> and then you can, say, map read over that to read the numbers.
22:21:42 <path_> no these arent commandline, ill want it to be interactive
22:21:43 <path_> Gracenotes: thats right
22:21:45 <Cale> ah
22:21:59 <Cale> Yeah, then getLine, and then words and read
22:22:05 <Gracenotes> > words "hello world !"
22:22:06 <lambdabot>   ["hello","world","!"]
22:22:38 <path_> yeah but getLine is what fails for me. Saying parse error
22:23:13 <Gracenotes> hm, that's.. unusual. Mind pastebining your code?
22:23:19 <path_> oh nm I fixed it :/
22:23:20 <path_> lol
22:23:23 <Gracenotes> er. binning
22:23:26 <Gracenotes> okay :o
22:24:03 <mwc> @pl getProgName >>= \p -> getArgs >>= \a -> return (p:a)
22:24:03 <lambdabot> (`fmap` getArgs) . (:) =<< getProgName
22:24:21 <Gracenotes> hmm
22:24:44 <ivanm> jl_2: try reading the RWH chapter on regexes
22:25:01 <Gracenotes> pl didn't get it to liftM2 (:) getProgName getArgs :'(
22:25:19 <mwc> Ah, of course
22:25:28 <ivanm> @type liftM2 (:) getProgName getArgs
22:25:29 <lambdabot> Not in scope: `getProgName'
22:25:29 <lambdabot> Not in scope: `getArgs'
22:25:51 <ivanm> mwc: is that valid?
22:26:08 <mwc> ivanm: they're in System.Environment
22:26:09 <ivanm> @undo do { n <- getProgName; args <- getArgs $ return n : args }
22:26:09 <lambdabot>  Parse error at "}" (column 58)
22:26:13 <ivanm> mwc: yeah, I know
22:26:25 <ivanm> bah, I used @undo that way before...
22:26:28 <ivanm> oh, semicolon
22:26:39 <ivanm> @undo do { n <- getProgName; args <- getArgs; return $ n : args }
22:26:39 <lambdabot> getProgName >>= \ n -> getArgs >>= \ args -> return $ n : args
22:26:43 <jl_2> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5036#a5036
22:27:55 <ivanm> @pl liftM2 (:) getProgName getArgs
22:27:55 <lambdabot> liftM2 (:) getProgName getArgs
22:28:20 <Gracenotes> @unpl liftM2 (:) getProgName getArgs
22:28:20 <lambdabot> (getProgName >>= \ b -> getArgs >>= \ a -> return ((:) b a))
22:29:46 <Gracenotes> easily verifiable, but not so easily calculable? :)
22:30:58 <mwc> it's better written using control.applicative I think, (:) <$> getProgName <*> getArgs
22:32:32 <Gracenotes> eh. I'm a bit more of a fan of lift[AM][1-5]?, for those values
22:32:44 <Gracenotes> (and liftA doesn't even go as high)
22:34:09 <ivanm> mwc: you sure you're not dobblego in disguise? :p
22:34:15 <Gracenotes> there's something more, uh, sci-fi-ish about <$><*>, though :) but, applicative brackets. maybe one day.
22:35:45 <Gracenotes> "In a world where man must learn to use <$> and <*> to apply effectful computations..."
22:35:53 <mwc> Heh
22:41:39 <Polarina> Is there a quick tutorial on parallelism?
22:42:10 <ivanm> Polarina: dons did some blog posts about them a couple of years ago...
22:42:23 <ivanm> lemme see if I can track them down...
22:43:01 <ivanm> Polarina: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29
22:43:25 <Polarina> ivanm: Thanks.
22:43:36 <ivanm> no worries
22:47:43 <Polarina> ivanm: What is `pseq`?
22:48:49 <Saizan> let d = a `pseq` b, means that a will be evaluated before d, which will have the value of b
22:48:51 <ivanm> @hoogle pseq
22:48:51 <lambdabot> Control.Parallel pseq :: a -> b -> b
22:49:12 <ivanm> Saizan: a will be evaluated before b, I think you mean ;-)
22:49:16 <Polarina> Huh?
22:49:38 <Saizan> no, d :) you don't know much about b, since it could be used somewhere else
22:50:01 <Saizan> Polarina: it's a way to control the order of evaluation, to better exploit parallelism
22:50:08 <Polarina> ...
22:51:00 <ivanm> "d = a `pseq` b, means that a will be evaluated before d" <-- a is _part_ of d!
22:51:24 <Saizan> ivanm: not of the value of d
22:51:32 <ivanm> yes
22:51:35 <Polarina> What the hell are you talking about?
22:51:48 <Saizan> ivanm: if i write d = const a b, does that imply 'a' gets evaluated before d?
22:51:54 <ivanm> but my (admittedly limited) understanding is that it just means that evaluate a, chuck out the result and then evaluate b
22:52:15 <ivanm> Saizan: ummmm.... evaluated within d? :p
22:52:23 <ivanm> Saizan: OK, I see what you're getting at
22:52:35 <ivanm> Polarina: pseq is used to force an order of evaluation
22:52:45 <Polarina> ivanm: Why would one wish to do that?
22:52:53 <ivanm> Saizan: I think the problem is partly a problem of the semantics of the English language
22:53:07 <ivanm> Polarina: OK, you have some parallel threads that need to do stuff with a communication channel
22:53:15 <ivanm> Polarina: you kinda have to open the channel first, right? ;-)
22:53:23 <Polarina> Sure.
22:53:26 <Saizan> there's no channel here though..
22:53:39 <Saizan> Polarina: do you know about `par` ?
22:53:49 <ivanm> Saizan: I did it as an off-the-top-of-my-head example on why you'd want ordering in parallel code
22:53:58 <Polarina> Saizan: No, not really.
22:54:28 <Saizan> Polarina: par is a way to annotate pure code with hints on what you want to parallelize
22:54:34 <Axman6> Polarina: it's often used to make sure that the elements of an equation are evaluated in parallel before being put into the equation
22:55:33 <Saizan> Polarina: when you write a `par` b, 'a' gets put into a queue so that it gets evaluated in parallel if there are threads available, while current thread goes on evaluating b
22:55:44 <Polarina> Saizan: Ah, nice. Thanks.
22:55:44 <Saizan> s/write/evaluate/
22:57:02 <Saizan> and, as Axman6 says, you might want to make sure something is actually put on this queue before the expression using it is evaluated
22:57:19 <Saizan> otherwise it doesn't have time to evaluate in a different thread
22:57:27 <Saizan> that's where pseq is useful
22:57:29 <Polarina> If I were writing a software rasterizer, would it be fair to have each pixel given a separate thread?
22:58:16 <Polarina> Saizan: You mean strict evaluation?
22:58:58 <Saizan> Polarina: you can get that effect with pseq, yeah
22:59:05 <Polarina> :)
22:59:46 <Saizan> a separate thread for each pixel sounds too fine-grained
22:59:58 <Saizan> though it depends on how computationally intensive it is
23:00:24 <Saizan> these sparks are very cheap, even cheaper than forkIO threads afaiu
23:00:26 <Polarina> Ray-tracing?
23:00:57 <Saizan> calculating a single pixel, in particular
23:01:05 <Polarina> If I do  a `par` b, how do I get the result of both a and b?
23:01:56 <Taejo> Polarina: let a = foo in a `par` b `pseq` (a, b)
23:02:04 <Polarina> ...
23:02:18 <Taejo> sorry, I mean let {a = foo, b = bar} in a `par` b `pseq` (a, b)
23:02:46 <Polarina> ...
23:02:49 <ivanm> Polarina: note here that foo and bar are what you're actually wanting evaluated
23:03:00 <Polarina> ...
23:03:05 <Saizan> Taejo: s/,/;/
23:03:12 <Taejo> Polarina: if you have a question, ask it
23:03:18 <Taejo> ... doesn't help me
23:03:22 <ivanm> by giving them these aliases within the function to a and b, they get "saved" as they get evaluated
23:03:30 <Polarina> I don't understand your answer. Not a single bean of progress, sorry.
23:03:35 <ivanm> Taejo: s/me/anyone guess what you mean/
23:03:42 <Saizan> Taejo: i was just nitpicking :) {a = foo; b = bar}
23:03:48 <ivanm> Polarina: you have too values you want evaluated in parallel: foo and bar
23:03:51 <Taejo> Saizan: yeah, you're right
23:04:04 <ivanm> Polarina: you can then do this:
23:04:04 <Axman6> Polarina: has anyone shows you the parallel fib function yet
23:04:04 <Axman6> ?
23:04:34 <ivanm> eval foo bar = let {a = foo; b = bar} in a `par` b `pseq` (a,b)
23:04:42 <Polarina> Axman6: Fibonacci is already fast enough for me.
23:05:00 <Saizan> Polarina: probably reading the blog post linked above will be more productive
23:05:04 <Axman6> fib n | n < 2 = 1 | otherwise = (a `par` b) `pseq` a + b where a = fib (n-1); b = fib (n-2)
23:05:07 <ivanm> Polarina: this way, by giving them named variables inside the eval function, they're result gets saved as they get evaluated
23:05:07 <Polarina> ivanm: Why the pseq and the tuple?
23:05:10 <Axman6> Polarina: that's not the point
23:05:20 <ivanm> Polarina: well, you need a tuple to return two results
23:05:34 <ivanm> Polarina: and the pseq ensures that both a and b are fully evaluated first
23:05:48 <blackdog> Axman6: to be fair, it's only a good example because you're deliberately ignoring the linear solution:)
23:05:49 <ivanm> (a `par` b) <--- evaluate a and b in parallel
23:06:00 <Axman6> blackdog: again, not the point ;)
23:06:15 <ivanm> (a `par` b) `pseq` (a,b) <-- evaluate them in parallel, and only when they're done return the values
23:06:21 <Axman6> ivanm: (a `par` b) <-- create a spark for a, and return b
23:06:21 <Saizan> ivanm: it doesn't ensure they are fully evaluated
23:06:36 <ivanm> Axman6: I'm over-simplifying based on my understanding of what Taejo wrote ;-)
23:06:54 <Polarina> Why not just:  eval a b = a `par` b `pseq` (a,b)  ?
23:06:55 <ivanm> Axman6: go back to gloating about OpenCL or something... :p
23:07:11 <Axman6> Polarina: that's the same thing
23:07:20 <ivanm> Polarina: because then a and b might get evaluated twice
23:07:28 <Polarina> ivanm: ?
23:07:31 <Taejo> ivanm: not if you define a function
23:07:40 <ivanm> Taejo: eh, whatever ;-)
23:07:45 <Taejo> the important thing is that a and b are variables, not expressions
23:07:51 * ivanm guesses he is confusing himself as well as Polarina 
23:07:57 <Polarina> Taejo: What's the difference?
23:08:14 <blackdog> Axman6: it would be nice to have a similar example that doesn't have the trivial solution, though. if the canonical example has obvious simpler implementations, something is wrong.
23:08:37 <Axman6> better example: pmap f [] = []; pmap f (x:xs) = x' `par` xs' `pseq` (x':xs') where x' = f x; xs' = pmap f xs
23:09:05 <Axman6> blackdog: enter pmap
23:09:15 <Taejo> Polarina: if you had (big_expensive_function x) instead of 'a', then par would evaluate (big_expensive_function x), but the work would be wasted because the result isn't "saved"
23:09:36 <Polarina> Why would let "save" things?
23:09:51 <Axman6> because it does
23:09:57 <Polarina> I don't get it.
23:09:57 <Axman6> we're telling you it does :P
23:10:12 <Taejo> Polarina: because Haskell is a call-by-name language, if you give a name to something it will only be evaluated once
23:10:13 <Axman6> it's sharing the results
23:10:31 <Polarina> Taejo: What's exactly why I don't get it.
23:10:50 <Taejo> Polarina: do you know what lazy evaluation is?
23:10:53 <Saizan> Axman6: iirc, one has to write it like  (x' `par` xs') `pseq` (x':xs') because the precedence of pseq is broken?
23:10:54 <Polarina> Taejo: Yes.
23:11:07 <Axman6> Saizan: i don't believe so
23:12:41 <Saizan> Polarina: essentially, if you have f :: A -> B, (x :: A) and you evaluate (f x, f x) you evaluate "f x" twice, if you write let y = f x in (y,y) you evaluate "f x" only once
23:12:42 <Taejo> Polarina: do you know that {f 0 = 1; f n = let x = f (n-1) in x+x} is more efficient than {f 0 = 1; f n = let x = f (n-1) + f (n-1)} ?
23:12:49 <Axman6> Polarina: in haskell, if you have f x in two places in a function, each of those f x's will be evaluated individually. if you say let y = f x, and replace those f x's in the original function, y will be evaluated once when it's first used, and when it used again, the result will already be there
23:12:54 <jl_2> if anybody's still interested, I've confirmed my problem is with the Regex packages in the debian unstable repos
23:13:36 <Saizan> Polarina: this is just how GHC (and the other implementations) decided to do it
23:13:47 <Polarina> Ah, I see, thanks. :)
23:13:49 <mwc> Wow, Foreign.Marshal.Pool sure makes life easier
23:14:02 <Axman6> mwc: what's it do?
23:14:02 <Saizan> Polarina: trying to figure out when caching the result of "f x" is a win is a difficult problem
23:14:05 <Polarina> Wouldn't -O2 optimize that out though?
23:14:18 <Axman6> Polarina: possibly, but maybe not
23:14:26 <Saizan> no, GHC does very little CSE
23:14:30 <Axman6> it might not be able to tell that two things are the same
23:14:44 * Axman6 stands corrected
23:15:13 <mwc> Axman6: when you need to allocate storage and store haskell values to memory for passing to C functions, you can allocate the values in a pool that's automatically deallocated. Saves a lot of withCString... withArray... etc. or mucking about with finalizers
23:15:37 <Axman6> hmm, sounds nice
23:16:20 <Saizan> how does that look like?
23:16:27 <blackdog> Axman6: pmap is a a tool, though, not a problem.
23:17:14 <Axman6> it is a problem if hyou want to map a function in parallel :P
23:17:56 <blackdog> no, it's a tool for mapping a function in parallel. what i mean is some easily defined task that can be computed much faster in parallel than the best serial method.
23:18:17 <Axman6> well, it lets you do that :)
23:18:20 <blackdog> good problems are very valuable
23:18:29 <Saizan> maybe raytracing is one :=
23:18:34 <Axman6> yeah
23:18:35 <blackdog> yes, but it's a solution. our problem is that we don't have a good problem yet.
23:18:43 <Saizan> though you'd probably use DPH for that?
23:18:54 <blackdog> Saizan: hard to get down to a one-liner, i imagine
23:19:05 <Axman6> Saizan: probably, though it's not all that complete at the moment
23:19:55 <Saizan> mh, some kind of search maybe
23:20:25 <Saizan> a sudoku solver?
23:23:45 <Axman6> blackdog: anyway, i use the fib example because it's dead simple, and very clearly shows how to use par and pseq
23:24:14 <Axman6> it doesn't matter if it gets faster or slower, that's not the point of the example
23:26:54 <ivanm> Axman6: and because when paralellised, the naive definition gets almost decent in terms of efficiency?
23:28:47 <blackdog> Axman6: Yeah, I understand its attraction. But wouldn't you enjoy not having to say things like "that's not the point"?
23:28:55 <BMeph> Delaunay, p'rhaps? ;)
23:29:08 <blackdog> ivanm: it's linear so long as you have infinite processors:)
23:29:16 <ivanm> blackdog: heh
23:29:46 <ivanm> blackdog: not quite; the number of processors needed depends on how many branches in the tree there are
23:30:02 <blackdog> perhaps something like parallelising an obvious brute force solver would be good
23:30:21 <blackdog> fib has two child calls per invocation, though
23:31:08 <blackdog> if you have infinite processors, you can fork twice at each invocation and get to the bottom in linear time
23:31:38 <blackdog> something a bit under 2^^n processors in the end, i think
23:31:56 <ivanm> yeah
23:32:16 <ivanm> wait, 2^^n = 2 ^ (2 ^ n) ?
23:32:18 <shrughes> fib(n) processors
23:32:39 <ivanm> shrughes: heh
23:32:45 <shrughes> > 2 ^^ 5
23:32:45 <lambdabot>   32.0
23:33:12 <ivanm> shrughes: yes, but is blackdog using the ^^ operator or the mathematics ^^ thingy?
23:33:56 <shrughes> ivanm: i'm not the person to ask... but 2^n would be closer than 2^^n
23:34:23 <ivanm> shrughes: well, that's what I was asking him...
23:34:30 <blackdog> just exponentiation
23:34:46 <blackdog> sorry, it's called something different in every language, i always have to look it up
23:34:52 <shrughes> yeah I was just figuring he was using some weird exponentiation operator for some reason
23:34:56 <ivanm> blackdog: ^ ;-)
23:35:01 <ivanm> > 2 ^ 5
23:35:02 <lambdabot>   32
23:35:20 <shrughes> "what's the extra ^ for?"  "^ your own ^"
23:35:40 <ivanm> what I thought he meant: http://en.wikipedia.org/wiki/Tetration#Notation
23:35:47 <Zao> Some languages use ^ for xor?
23:35:51 <ivanm> (the last one)
23:35:57 <ivanm> Zao: something like that
23:36:08 <Chad> i seem to be having an issue getting a winsock c++ client to connect to a simple tcp listen server written in haskell
23:36:12 <Zao> Hasn't stopped Haskell though... (/=)
23:36:27 <Chad> it seems teh connect() always fails ^_^
23:36:59 <shrughes> > 2 .^. 3 -- i don't think this will work but...
23:37:00 <lambdabot>   Not in scope: `.^.'
23:37:08 <shrughes> > 2 `xor` 3
23:37:09 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:37:10 <lambdabot>    `Data.Bits.Bits t'
23:37:10 <lambdabot>      a...
23:40:40 <ivanm> Zao: Haskell generally uses more maths-y notation
23:43:17 <Saizan> Chad: the server runs of windows? maybe you need to add withSocketsDo ?
23:44:41 <Chad> Saizan: i did... i just managed to coerce the errno out of the connect, supposedly it's "no such file or directory", which, is somewhat confusing to be coming from connect
23:44:45 <Chad> i'll look into it a little more...
23:44:48 <red-agent> Hi. What library should I use to manipulate images?
23:45:03 <ivanm> red-agent: what format do you want to use?
23:45:11 <ivanm> what kind of manipulation do you want to do?
23:45:17 <red-agent> Would be nice if the library could give me a way to hack into the encoding/decoding process.
23:45:40 <red-agent> ivanm, Direct manipulation with color components.
23:46:04 <ivanm> which image format?
23:46:12 <red-agent> Formats - lossless primarily, some lossy, like jpeg would be nice too.
23:46:28 <red-agent> Png, jpeg, bmp, tiff.
23:46:31 <red-agent> Something like that.
23:47:35 <ivanm> red-agent: might be easiest if you look through http://hackage.haskell.org/package/#cat:graphics
23:47:52 <red-agent> ivanm, Would be cool if I could hack into the dct/quantization stage of the jpeg encoding/decoding.
23:47:59 <red-agent> ivanm, Thanks. I'll take a look.
23:49:12 <red-agent> ivanm, Is there any de-facto srandard library for basic image manipulation?
