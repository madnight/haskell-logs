01:12:12 <hgolden> hi. i'm getting compile failures from ghc-6.12 on both convertible-1.0.5 and convertible-1.0.6. has anyone been able to compile them successfully?
01:15:06 <Kim^Walkman> hgolden: No issue here, but I'm using 6.10.4
01:18:50 <aavogt> hgolden: what's the error?
01:18:58 <hgolden> Kim^Walkman: yeah. it works ok for me on 6.10.4 also
01:20:30 <hgolden> aavogt: there are several lines with basically the same message:
01:20:32 <hgolden> Data/Convertible/Instances/C.hs:132:21:
01:20:33 <hgolden>     Not in scope: type constructor or class `CLDouble'
01:22:23 <vy> Anybody in the house with a HaskellWiki account?
01:23:05 <hgolden> vy: i have one
01:24:22 <vy> Would you mind adding BILFP (Bilkent University Comp. Eng. Dept. Functional Programming Society @ http://bilfp.wikidot.com/) under Europe/TURKEY in "User Groups" page please?
01:25:13 <hgolden> ok. i'll try. hopefully i remember my password.  ;-)
01:27:09 <aavogt> hgolden: the CLDouble doesn't seem to exist in 6.12: http://www.haskell.org/ghc/dist/current/docs/html/libraries/base/Foreign-C-Types.html
01:27:36 <hgolden> aavogt: is there a substitute?
01:27:57 <Baughn> hgolden: CDouble
01:28:35 <aavogt> in that case you just have to comment out the instances for CLDouble
01:29:01 <Baughn> hgolden: I know that's a bit troublesome, but the fact is that x86's support for 80-bit precision FP has only gotten worse over the years
01:29:19 <Baughn> SSE only supports 64-bit, after all
01:30:09 <Baughn> (..though, realistically, it missing is a bit)
01:30:11 <Baughn> *bug
01:31:11 <p_l> Baughn: SSE2 supported 128bits, iirc
01:32:12 <p_l> ... after checking, no, only 64bits. Pity
01:35:06 <p_l> and here I thought that I'd need to add 128bit floats to MMIX, heh
01:36:34 * p_l planned 128 & 265 bit extensions to MMIX FPU
01:38:27 <hgolden> aavogt, Baughn: thanks for your help. i will report this to John Goerzen
01:39:04 <hgolden> vy: i have updated the HaskellWiki. do you want any changes or more detail?
01:44:01 <profmakx> eh
01:49:18 <vy> hgolden: To be honest, it'd be perfect if you can add "Project aims to improve people's knowledge and encourage the use of functional programming languages -- especially in Turkey. Group is open to functional programming related discussions and establishes related presentations at Bilkent University that are open to anybody." lines below the link.
01:49:44 <hgolden> vy: i'll do that right away.
01:52:36 <Twey> ‘functional-programming–related discussions’
01:53:29 <dobblego> @hoogle [a -> a] -> a -> a
01:53:30 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
01:53:30 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
01:53:30 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
01:53:31 <vy> hgolden: Awesome! Thanks so much!
01:54:05 <quicksilver> Twey++ # accurate hyphen-advice
01:54:11 <simplicio> :t sequence :: [a -> a] -> a -> a
01:54:12 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
01:54:12 <lambdabot>     In the expression: sequence :: [a -> a] -> a -> a
01:54:34 <simplicio> I see
01:54:48 <simplicio> :t foldr (.) id
01:54:49 <lambdabot> forall b. [b -> b] -> b -> b
01:55:52 <Twey> quicksilver: Haha
01:56:06 <hgolden> vy: you're welcome. you should be able to get a HaskellWiki account by applying. this would allow you to keep your entry current.
01:56:31 <quicksilver> > appEndo . mconcat . map Endo
01:56:32 <lambdabot>   []->
01:56:32 <lambdabot>    {()->()}
01:56:32 <lambdabot>  [{()->()}]->
01:56:32 <lambdabot>    {()->()}
01:56:32 <lambdabot>  [{()->()},{()->()}]->
01:56:34 <lambdabot>    {()->(...
01:56:36 <quicksilver> :t appEndo . mconcat . map Endo
01:56:37 <lambdabot> forall a. [a -> a] -> a -> a
01:56:46 <vy> hgolden: I was just applying for one... But I didn't want to waste an account for this.
01:56:53 <quicksilver> dobblego: that's the "elegant" answer but obviously it's no easier to type than foldr (.) id ;)
01:57:01 <dobblego> ta
01:57:01 <quicksilver> newtype unwrapping makes so much noise
01:57:11 <quicksilver> it's like tissue paper
02:09:11 <dolio> Needs some higher order.
02:09:19 <dolio> ala Endo mconcat, or whatever.
02:12:02 <quicksilver> dolio: sure, but then you need to bundle appEndo and Endo into some kind of structure which models isomorphisms
02:12:19 <quicksilver> (or just a structure which models adjunctions, and this one happens to be iso)
02:15:35 <dolio> Yes.
02:16:30 <dolio> If your goal is reducing newtype noise, though, that's a genuine one-instance-per-type type class.
02:23:33 <dolio> Huh, no generalized newtype deriving for associated types.
02:24:11 <quicksilver> dolio: ISTR a discussion about that
02:24:34 <cyxx-cyxx> Hi, is it possible to make a "haskell project" to a runable .exe file for others that dont have ghc installed?
02:25:02 <Twey> cyxx-cyxx: Er, yes — it's called compilation
02:25:42 <quicksilver> dolio: http://hackage.haskell.org/trac/ghc/ticket/1496
02:27:37 <ivanm> Twey: you mean I've been running my code in ghci all this time for no reason? :o
02:27:37 <ivanm> :p
02:27:43 * Twey laughs.
02:29:21 <sieni> Well, ghc stands for glasgow haskell compiler, right?
02:29:37 <Twey> Indeed, indeed
02:31:14 <zygoloid> "The Glorious Glasgow Haskell Compilation System"
02:35:05 <quicksilver> dolio: http://hackage.haskell.org/trac/ghc/ticket/1496
02:35:19 <dolio> Yeah, I got it. :)
02:35:26 <dolio> I'd forgotten about that.
02:35:29 <quicksilver> dolio: which is inconclusive. My gut feeling is that newtype deriving is probably unsound for associate types in general but sound for associated data.
02:35:52 <quicksilver> dolio: (you'd have to automatically newtype-wrap the associated type too to do something sensible there)
02:36:22 <dolio> Well, it's a regression from functional dependencies in that respect.
02:36:33 <dolio> I can derive MonadState with fundeps, but not type families.
02:36:47 * quicksilver nods
02:37:07 <quicksilver> needs solving, yes.
02:41:14 <ivanm> with quickcheck's shrinking, does it keep trying to shrink until the error stops occuring?
02:41:28 <mux> I'm hoping so
02:41:36 <ivanm> heh
02:41:39 <quicksilver> I believe that's how it works.
02:41:47 <ivanm> because it's generating very large "shrunken" values here :s
02:41:54 <mux> any other behaviour wouldn't be very useful
02:42:07 <ivanm> oh, and do you know if its possible to make ghci default to Int rather than Integer?
02:43:50 <ivanm> I think PrettyPrint has stopped liking me...
02:43:58 <ivanm> it's putting in all these \\\\\\\ /////// lines :s
02:46:18 <ivanm> I'm wanting LeftMode _with_ indentation!
02:46:24 <ivanm> is that too much to ask? :s
02:49:36 <malosh> Hi. Has someone ever used MVars for something else than a ridiculously inefficient proof of concept, or have I missed something important :-) ?
02:50:03 <ivanm> mvars are used all the time
02:50:10 <ivanm> they're how you communicate between threads
02:50:21 <malosh> In a single-threaded version I am 100 times faster with IORefs than with MVars
02:51:00 <malosh> I've got a huge Map from Data.Map and all the threads should have a common mutable reference to this
02:54:09 <dolio> Yes, locking is slower than not-locking.
02:54:31 <int-e> the uncontested path of mvars should really be rather fast. a factor of 100 seems too big. does the allocation behaviour of the program change? (+RTS -sstderr)
02:58:09 <quicksilver> 100 times faster doesn't seem all that surprising
02:58:16 <quicksilver> an IORef is jsut a pointer dereference
02:58:22 <quicksilver> an MVar is something more complicated
02:58:45 <quicksilver> it's an unusual case for a dereference to be the time-bottleneck of your program isn't it?
02:59:12 <simplicio> is this wallclock time or cpu time?
03:09:39 <int-e> quicksilver: but the uncontested case of taking an MVar is basically a succeeding cmpxchg on a cache line that the processor should own exclusively in the single threaded case. that's fast, too. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12377#a12377 gives me a factor of 2, and that's about the worst case I can think of (readMVar is two operations)
03:13:43 <quicksilver> int-e: oh that's much better than I feared. What are the absolute timings, roughly?
03:13:58 <int-e> 1.46 seconds vs. 2.76 seconds
03:14:26 <quicksilver> > 1.46 / 100000000
03:14:27 <lambdabot>   1.46e-8
03:14:47 <quicksilver> 14 nanoseconds for ioref, 27 nanoseconds for mvar
03:14:50 <int-e> oh.
03:14:51 <quicksilver> that's pretty good IMO.
03:15:14 <quicksilver> I was guessing microseconds for mvar
03:16:17 <int-e> 64 cycles vs. 34. Ok, that's reasonable.
03:17:22 <quicksilver> especially considering the overhead of the loop itself
03:20:52 <quicksilver> int-e++ # empirical
03:30:00 <mmorrow> malosh: also, in the single-threaded case atomicModifyIORef isn't (but your single-threaded so you can't tell the difference) iirc
03:30:07 <mmorrow> *you're
03:30:29 <mmorrow> well, it's atomic wrt context-switches i guess
03:30:52 <mmorrow> (rts context-switches that is)
03:33:41 <int-e> mmorrow: right.
03:34:36 <quicksilver> mmorrow: does unobservable non-atomicity matter?
03:36:00 <mmorrow> quicksilver: only for a possible "wtf" moment when you first turn on -threaded and take a perf hit
03:36:03 <int-e> (well, right in that weird theoretical, non-observable sense that won't matter in practice)
03:37:23 <int-e> The difference is again between a cas (cmpxchg) and a simple write access.
03:37:36 <Hunner> is there a way I can make an ambiguous function imported from a module only used if refereced explictly?
03:38:01 <int-e> Hunner: import qualified Foo
03:38:09 <mmorrow> import Foo hiding (bar)
03:38:13 <mmorrow> import qualified Foo as F
03:38:16 <mmorrow> or something
03:38:28 <mmorrow> (or just qualify the whole thing like int-e)
03:38:57 <int-e> import qualified Foo as F tends to be more practical and refactoring-friendly.
03:39:25 <Hunner> thanks, "import qualified" is what I wanted
03:39:42 <Hunner> refactoring friendly? In case the module name changes?
03:40:36 <mmorrow> you can also import multiple modules all qualified as F, which is depending on who you're asking useful or evil
03:41:24 <Hunner> Right off the bad I would call that sadisticly useful
03:41:27 <Hunner> bat*
03:41:42 <mmorrow> heh, yeah something like that
03:45:13 <int-e> mmorrow: it's useful if you ask me.
03:45:51 <mmorrow> int-e: me too
03:46:43 <int-e> (for example I like how I can import almost everything Gtk+ related as G :-) )
03:47:19 <quicksilver> it would all make a bit more sense to me if you could re-export qualifications.
03:47:22 <quicksilver> (I think)
03:47:28 <quicksilver> and then they nested as expected.
03:47:44 <quicksilver> otherwise it feels like qualifications dont' compose.
03:47:53 <int-e> right, that would be cute.
03:48:10 <int-e> export ( ... module F as F ... )
03:48:23 <mmorrow> if one thing could be added to the module system (which i also think is a reasonable extension), i think the most useful (and the feature i want constantly) would be the ability to preserve the qualification (and subset) of a re-exported module
03:48:31 <mmorrow> or equivalently, to have nested modules
03:48:39 <mmorrow> well, pseudo-equivalently
03:48:54 <mmorrow> quicksilver: haha
03:49:03 <mmorrow> i didn't read your comment until after i wrote that
03:49:18 <quicksilver> mmorrow: way ahead of you :P
03:49:23 <mmorrow> :)
03:49:36 <c_wraith> what about the traditional "make instances non-global" vague complaint?
03:49:54 <quicksilver> making instances non-global would reduce the language to a bloody rubble
03:50:04 <quicksilver> it would be the single most evil thing any person could ever do to haskell
03:50:10 <int-e> c_wraith: that's a hard problem, because of the way type classes work impredicativly in haskell 98.
03:50:27 <quicksilver> as you can see, I'm still on the fence on this one ;)
03:50:41 <mmorrow> yeah, it's a major hindrance that qualification is useless wrt re-exporting modules, so you have no way of packaging up a set of some abstract functionality that draws from multiple modules and presenting it via a single module
03:50:55 <int-e> c_wraith: so it's impossible to avoid that code uses incompatible type class instances for the same data type, simply because it goes through different code paths.
03:50:56 <mmorrow> if there're any name clashes, you're screwed wrt re-export
03:51:21 <int-e> c_wraith: (take "impossible" with a grain of salt. it may be merely deviously hard. )
03:51:26 <quicksilver> c_wraith: to my mind, the essential purpose of typeclasses hinges around the fact they are global.
03:51:38 <quicksilver> typeclasses are elegant because you can use them to maintain invariants.
03:51:56 <quicksilver> if you don't want that thing - the global thing which helps you maintain invariants - then you don't really want typeclasses
03:52:08 <quicksilver> there are plenty of ways of implementing that not-typeclass-thing
03:52:13 <quicksilver> (explicit dictionaries, some people call it)
03:52:40 <c_wraith> I just want to not have to deal with issues like the convertible/time conflict
03:52:42 <quicksilver> IOW, non-global typeclasses woudln't be typeclasses any more. They'd be something else, and deserve a different name.
03:53:08 <quicksilver> ...and that something else is not particularly hard to implement in haskell as it is now.
03:53:09 <int-e> quicksilver: which puts the responsibility of avoiding those inconsistencies on the programmer. it won't make the problem go away.
03:53:29 <int-e> c_wraith: my pet peeve is the Monad instance for Either.
03:53:32 <quicksilver> int-e: I'm not sure which part of my rant your comment is directed at ;)
03:53:37 <mmorrow> right, the lack of syntactic support for doing that is the main reason the discussion usually ends up going back to using typeclasses for their syntactic mechanism, but with a different semantics
03:53:41 <mmorrow> (@quicksilver)
03:53:44 <int-e> quicksilver: the explicit dictionaries one
03:53:48 <mmorrow> (imo)
03:54:32 <int-e> (I guess the right way to solve that is to make my own Either type ;-) )
03:54:51 <int-e> And then take over the world and make everybody use it.
03:54:59 <mmorrow> mwahaha
03:55:02 <int-e> mwahaahahahaaa!
03:55:06 <mmorrow> lol
03:55:23 <c_wraith> I try not to use Either anyway.  So I'd support not-using your new type, also! :)
03:56:05 <quicksilver> if you wanted this new explicit dictionaries approach to regain some kind of implicitness
03:56:17 <quicksilver> you would essentially be implementing some kind of implicit parameters
03:56:26 <quicksilver> (either lexically or dynamically, I presume)
03:56:38 <quicksilver> and, it seems to be a broad consensus that those were a bad thing.
03:56:58 <quicksilver> I think the whole 'implicit' feature of typeclasses is only really suited to things which are global.
03:57:03 <mmorrow> quicksilver: i think being able to "open" a record in some scope would go a long way too
03:57:06 <quicksilver> but that's probably a subjective point.
03:57:21 <quicksilver> mmorrow: sure, that would be nice. Totally trivial, too :)
03:57:21 <int-e> I thought it was linear implicit parameters that were really bad.
03:57:24 <mmorrow> since without that ability, using records gets tedious fast
03:57:28 <mmorrow> quicksilver: totally
03:57:33 <c_wraith> open?
03:57:40 <quicksilver> mmorrow: I really don't find explicit dictionaries as hard as people make out
03:57:49 <quicksilver> I can't understand why we're so scared of tuples of functions
03:58:03 <quicksilver> surely in a language with good ADT support tuples / product types of functions are a totally natural thing.
03:58:07 <mmorrow> quicksilver: it gets annoying if you've got a record with 10 functions and you constantly have to be writing
03:58:09 <int-e> are we?
03:58:22 <int-e> scared, that is?
03:58:25 <quicksilver> int-e: the detractors of the explicit dictionary approach appear to be
03:58:29 <mmorrow> ... deleteQ dict j (insertQ dict i foo) ...
03:58:41 <quicksilver> scared of the syntactic overheard rather than terrified of the concept, I mean :)
03:58:58 <mmorrow> yeah, typeclasses have made us soft!
04:00:32 <int-e> I guess I'd want implicit parameters then, and I'd miss the guarantee that any type will only have one instance of every class.
04:01:06 <int-e> oh it's worse, I'd want /overloaded/ implicit parameters then.
04:01:10 <int-e> hah.
04:01:35 <mmorrow> yeah, i've just recently realized that this would be a legitimate (and useful) use-case for implicit params
04:01:52 <quicksilver> mmorrow: I intuitively disagree. implicit parameters are disgusting.
04:01:53 <mmorrow> an implicit param that's a record of functions
04:02:03 <quicksilver> mmorrow: (I'm afraid I can't remember why)
04:02:05 <int-e> (so I could have   (?eq :: Eq a, ?eq :: Eq b) => [a] -> [b] -> something
04:02:07 <int-e> )
04:02:12 <mmorrow> quicksilver: heh
04:02:18 <quicksilver> it's a logical argument I have entirely forgotten and all that's left is a strong prejudice.
04:02:30 <FunctorSalad> I don't see much wrong with IP dicts intuitively either
04:02:42 <quicksilver> something to do with it introducing an 'evaluation order' into pure expressions, IIRC
04:03:00 <quicksilver> let a = ?x; ?x = 1; b = ?x in ...
04:03:16 <quicksilver> or, perhaps worse,
04:03:18 <int-e> An implicit parameter is an implicit Reader monad, with all the commutativity rules that would make using actual Reader classes tedious.
04:03:24 <mmorrow> int-e: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7512
04:03:40 <quicksilver> let ?x = 0; a = ?x : b; ?x = 1; b = ?x : a in ...
04:03:41 <FunctorSalad> quicksilver: what's the problem with that?
04:03:54 <quicksilver> which ?x do "a" and "b" "see" ?
04:03:55 <int-e> mmorrow: I know, but know write code that uses /two/ Eq instances.
04:04:04 <mmorrow> the context for an implicit param is basically the exact same thing as a typeclass context, which i didn't realize until recently
04:04:13 <mmorrow> int-e: :o
04:04:13 <FunctorSalad> are you even allowed to reassign them?
04:04:16 <quicksilver> mmorrow: yes, that's why they were easy to implement
04:04:30 <int-e> mmorrow: that's what I was getting at with the 'overloaded implicit parameters' comment.
04:04:32 <FunctorSalad> > let ?x = 0; a = ?x : b; ?x = 1; b = ?x : a in (?x,a,b)
04:04:33 <lambdabot>   <no location info>: parse error on input `a'
04:04:43 <mmorrow> int-e: i missed that aspect of it initially
04:04:51 <quicksilver> mmorrow: they're "just" typeclasses generalised away from being only for one purpose
04:04:55 <FunctorSalad> > let { ?x = 0; a = ?x : b; ?x = 1; b = ?x : a } in (?x,a,b)
04:04:55 <mmorrow> (:= missed that part of what you were saying)
04:04:56 <lambdabot>   <no location info>: parse error on input `a'
04:05:55 <mmorrow> FunctorSalad: a let ?x = .. and a let x = .. are syntactically different
04:06:00 <int-e> mmorrow: I guess all in all I like type classes the way they are. I dislike some extensions (OverlappingInstances and IncoherentInstances) because they weaken the uniqueness guarantee that I like.
04:06:01 <mmorrow> slash can't mix them
04:06:11 <FunctorSalad> oh
04:06:47 <quicksilver> int-e: I entirely agree. typeclasses as they are, are good.
04:06:51 <mmorrow> int-e: yeah i agree. i think typeclasses are really good at what they're good at, and a solution for these other use-cases is a more powerful module-system
04:07:08 <quicksilver> int-e: the other thing being discussed may also be a useful thing, but it's a different thing deserving of a different name
04:07:16 <mmorrow> FunctorSalad: although confusingly they use the same concrete syntax..
04:07:17 <quicksilver> and I certainly wouldn't call them "non-global typeclasses"
04:07:27 <quicksilver> that's like "non-mammalian sheep"
04:07:50 <mmorrow> omg, like salamander sheep
04:08:18 <quicksilver> and furthermore explicit dictionaries are not such a bad solution as they are made out to be
04:08:36 <quicksilver> although it would be nice ot be able to use real function definition syntax inside record notation.
04:09:19 <mmorrow> (and to have types in records, and nested records...oh wait, modules!)
04:09:48 <FunctorSalad> isn't the main problem having to pass the dictionary around?
04:10:01 <mmorrow> although, the modules would be "second-class" unlike haskell "records" that are first-class
04:10:06 <FunctorSalad> not the confusion of dealing with function tuples or anything
04:10:29 <quicksilver> you can bundle the dictionary and the 'object' together so there is only one thing to pass around
04:10:57 <quicksilver> data Drawable a = { data :: a, draw :: a -> IO (), ... }
04:11:06 <FunctorSalad> hmm
04:11:31 <quicksilver> and the design combinators to suit taste
04:11:32 <int-e> (let's give it a name: explicit existential types)
04:11:47 <quicksilver> surely that's not existential yet?
04:11:58 <quicksilver> it's certainly something which it is often useful to take the existential of.
04:12:08 <int-e> not quite. but almost :)
04:12:16 <mmorrow> the thing that proper modules give you that existentials can't though, is the ability to express sharing in the types of sub-components explicitly
04:12:22 <int-e> hmm. data Drawable = forall a . etc
04:12:35 <int-e> that's what I really had in mind.
04:12:37 <mmorrow> rather than "by construction", which imo turns your code into a clusterfuck
04:12:38 <quicksilver> yes, data SomeDrawable = forall a . Drawable a
04:13:02 <quicksilver> it's useful to have the parametrised version around sometimes
04:13:12 <quicksilver> you might have a function which works on Drawable Strings, f.ex.
04:13:36 <FunctorSalad> mmorrow: hmm anything shared will have to be inside the scope of one quantifier
04:14:18 <FunctorSalad> (is that the 'by construction'? ;))
04:14:57 <mmorrow> FunctorSalad: right
04:15:34 <mmorrow> rather than    with S.P.R.Foo s == This.That.Omg.Bar a b c
04:16:57 <FunctorSalad> hmm but why existential-wrap the things then
04:17:10 <FunctorSalad> seems to be an example of what quicksilver just said :)
04:17:17 <FunctorSalad> (keep the parameterised version 'round)
04:17:17 <mmorrow> FunctorSalad: that's not existentials, but rather something more
04:18:19 <mmorrow> my favorite example where "fibered" wins in the parameterized vs. fibered thing (stealing that term from that ATAPL book)
04:18:25 <mmorrow> is, say you have
04:18:42 <FunctorSalad>  "fibered"? like fibered categories? :o
04:18:53 <mmorrow> data Mapping a b = Mapping {mapping :: a -> b}
04:19:01 <mmorrow> now, you want to compose 40 Mappings
04:19:20 <mmorrow> with parameterized records, your final type will need to reference 40 type params
04:19:24 <mmorrow> rather than
04:19:37 <FunctorSalad> :o
04:19:38 <mmorrow> Mapping = Mapping {mapping :: a -> b}
04:19:43 <medfly> hi!
04:19:51 <simplicio> 40 mappings? that's terrible
04:20:08 <FunctorSalad> mmorrow: I don't see why you need to keep the intermediate params
04:20:16 * SamB_XP wonders how to pass boot flags to the NT 3.51 installer ...
04:20:23 <mmorrow> struct MyMapping = Mapping {Mapping one; Mapping two; mapping = two.mapping . one.mapping} with one.b == two.a
04:20:53 <mmorrow> FunctorSalad: consider:
04:21:23 <mmorrow> FunctorSalad: err, lemme find the nicely phrased version of this
04:21:42 <mmorrow> (from a book (online as a pdf, can't remember the name))
04:22:27 <mmorrow> FunctorSalad: basically, you have no way to express that you require different existential sub-components of two things to be equivalent
04:22:31 <ivanm> mmorrow: I think you need another pair of parenthises in there somewhere... :p
04:22:38 <mmorrow> so you have to then parameterize them by the type
04:22:58 <FunctorSalad> mmorrow: you first need to demand equality, then ex-wrap
04:23:04 <mmorrow> which then forces all these type-params to propogate from the lowest levels of abstraction to the top-level type
04:23:24 <FunctorSalad> data TwoMappings where MkTwoMappings :: Mapping a b -> Mapping b c -> TwoMappings
04:23:26 <mmorrow> FunctorSalad: but what if another type want two /different/ components to be equal?
04:23:40 <mmorrow> and doesn't care about those other components being equal
04:23:47 <mmorrow> you'd have to write completely new types
04:23:54 <SamB_XP> hmm. it seems like it would be easier to just write Python...
04:23:57 <FunctorSalad> you just need to rewrite the existential wrappers
04:24:01 <mmorrow>  /and/ they'd need to be in the same module
04:24:13 <mmorrow>  /and/ constructed with this particular case in mind
04:24:30 <mmorrow> so they can't be generic or re-useable for another situation
04:24:59 <quicksilver> mmorrow: that's an interesting one
04:25:03 <quicksilver> mmorrow: it's never come up for me :)
04:25:14 <quicksilver> but I admit to not having travelled terribly far down this road
04:25:22 <quicksilver> I got a particle system working though
04:25:31 <quicksilver> (if the eventual output isn't 3D graphics, it's not real)
04:27:55 <mmorrow> quicksilver, FunctorSalad: gimme a second, i'm partially botching the example i just gave with the compositions of structures, but it really is a good one if said correctly, trying to find it..
04:28:01 <ben0x539> @src IsString
04:28:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:28:23 <alexander2> CTRL + L doesn't work in ghci any more :(
04:28:37 <ivanm> who is this BOB that lambdabot is channeling?
04:28:40 <pastah> i'm running 10.4 from ubuntu
04:28:45 <ben0x539> What is it supposed to do?
04:28:57 <pastah> ben0x539: clear the screen
04:29:05 <ben0x539> 10.4 ghci stopped using readline, maybe you can coerce it to do what you want in .haskeline
04:29:06 <pastah> or the terminal, rather
04:29:14 <ben0x539> Works for me, though... :)
04:29:27 <pastah> ben0x539: are you using ubuntu 9.10?
04:29:30 <ben0x539> no
04:29:34 <ben0x539> but ghc 6.10.4
04:29:56 <pastah> hmmm... i think i will install it from the binary package, just for that
04:30:55 <pastah> i can't read error messages if they're not in the top of my terminal
04:31:14 <pastah> i juts get agitated because i can't find the start in my wall of text
04:33:35 <SamB_XP> pastah: the *top* of your terminal?
04:33:43 <SamB_XP> I would think you would look at the bottom!
04:33:58 <SamB_XP> also, isn't finding the error messages what Emacs is for ?
04:34:10 <pastah> SamB_XP: i'm a blasphemer
04:34:16 <pastah> VI VI VI! the number of the beast!
04:34:19 <mmorrow> quicksilver, FunctorSalad: found it, but it's in a real book, making a paste that expresses it since it's hard to say in just a few words
04:34:28 <SamB_XP> heck, VI can probably do that too by now!
04:34:40 <mmorrow> well, it's probably easy to say in a few words, but i don't know how
04:34:45 <pastah> SamB_XP: i like to use two windows, side by side
04:34:58 <pastah> a terminal for checking errors + general testing
04:35:05 <pastah> and gvim for writing shit
04:35:06 <SamB_XP> yeah
04:35:14 <SamB_XP> I've done basically that
04:35:29 <SamB_XP> though maybe it was notepad.exe and command.com
04:35:30 <pastah> well, i don't want them to intertwine and form some weird offspring
04:35:34 <SamB_XP> on Windows 95
04:35:49 <quicksilver> mmorrow: trying making 80% of the words "badger" and the remaining 20% "mushroom"
04:36:01 <quicksilver> mmorrow: that's quite a flexible way of expressing tricky concepts.
04:36:10 <pastah> i know ghci can do :e or whatever to "ease" the development process, but that's just boring
04:36:23 <simplicio> vim can :make
04:36:42 <SamB_XP> quicksilver: hmm, it wouldn't be more efficient if you did it 50/50 ?
04:37:17 * SamB_XP wonders if anyone has ever created a peer-to-peer protocol that works on this principle
04:38:45 <pastah> yeeees! CTRL-L works again
04:38:49 <pastah> oh happy day!
04:38:52 <SamB_XP> wow, this is amusing
04:40:08 <quicksilver> pastah: how did you fix it?
04:40:34 <SamB_XP> they have a section in a knowledge base article about XP Professional that only applies to people who have a copy of NT 3.51 -- the article *is* about technique that would be useful if your XP system became unbootable, so it's not crazy or anything, but it just seems ... a few versions back ;-)
04:40:54 <pastah> quicksilver: cd ~/code/src/ghc-6.10.4/; ./configure && sudo make install
04:41:16 <SamB_XP> http://support.microsoft.com/kb/311073
04:41:19 <quicksilver> fair enough
04:41:43 <pastah> who maintains ghc for debian/ubuntu?
04:42:29 <SamB_XP> pastah: check the control file ?
04:42:38 <SamB_XP> or, uh, apt-cache show
04:42:51 <pastah> SamB_XP: i really suck at debian :)
04:43:12 <SamB_XP> what I mean to say is that the package carries this information
04:43:27 <pastah> Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
04:43:39 <pastah> one angry mail coming up...
04:43:43 <c_wraith> that's amusingly less-than-useful :)
04:43:47 <shambler> ;))
04:43:55 <bastl> Hi all.
04:44:01 <SamB_XP> pastah: oh, I guess you should check the changelog actually
04:44:04 * hackagebot upload: astview 0.1.2 - A GTK-based abstract syntax tree viewer for custom languages and parsers (SebastianMenge)
04:44:10 <SamB_XP> the Debian changelog, I mean
04:44:25 <pastah> bah, fuck it, it's working now
04:44:33 <SamB_XP> (or in this case I guess it would be the Ubuntu one ?)
04:44:59 <c_wraith> I just wonder how the debian version managed to break the delete key
04:45:04 <bastl> FunctorSalad: now astview should work finally (if you have gtk2hs installed properly)
04:45:06 <c_wraith> well, ubuntu version
04:45:09 <SamB_XP> but anyway, the package changelog generally shows you who actually does the work
04:45:56 <bastl> I'm doing my first steps with uploading to hackage. Worked quite well.
04:46:33 <bastl> But 'cabal upload' hangs after uploading: The package is there, but the process keeps hanging around ...
04:46:34 <SamB_XP> and in Ubuntu packages, it shows you the work both in Debian and in Ubuntu, assuming the Ubuntu package is derived from the Debian one
04:47:22 <FunctorSalad> bastl: 1.0 worked after I just deleted the docs stuff from the Setup.hs :)
04:47:39 <FunctorSalad> (the missing file was related to documentation)
04:47:56 <bastl> and we cared so much about documentation :-) And I'm very proud of the userhook ...
04:48:19 <SamB_XP> (hmm, actually, that KB article I was looking at looks like it was originally for NT 3.5 and NT 4 and they just slapped an XP on it?)
04:48:54 <pastah> SamB_XP: XP is NT 5.1, right?
04:49:01 <SamB_XP> pastah: yeah
04:49:32 <SamB_XP> I'm guessing the procedure for creating a boot floppy hasn't changed much since NT 4
04:50:19 <FunctorSalad> bastl: I'm afraid there is a new error :o http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12382#a12382
04:50:45 <bastl> gnnnn.
04:51:30 <bastl> It tries to load/link the example-stuff ...
04:52:15 <ivanm> should I be worried if QuickCheck is taking up about 100% runtime for a while?
04:52:31 <pozic> ivanm: no
04:52:37 <FunctorSalad> why *wouldn't* it? ;)
04:53:04 <ivanm> I'm worried it might be due to recursive shrink definitions...
04:53:25 <FunctorSalad> make sure shrink shrinks?
04:53:28 <ivanm> and I am running it in ghci...
04:54:16 <SamB_XP> ivanm: it's not producing any output ?
04:54:20 <ivanm> SamB_XP: nope
04:54:31 <SamB_XP> which function did you actually call, though?
04:54:34 <mmorrow> quicksilver, FunctorSalad: aha, ok i've got it. why i was getting confused is because there's no way to express the "fibered" example in haskell, and i was trying to use haskell to phrase it, but anyways this example exhibits what i'm trying to say in general http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4996#a4996
04:54:38 <SamB_XP> (maybe you should call verboseCheck?)
04:55:11 <ivanm> the problem could be that I have defined "shrinkM Nothing = [Nothing], shrinkM just = shrink just" for use with data structures which have both a maybe and other sub-types, so if I just use shrink on the maybe then it wouldn't be shrunk :s
04:55:19 <ivanm> SamB_XP: quickCheck
04:55:29 <SamB_XP> ivanm: yeah, try again with verboseCheck or something
04:56:07 <FunctorSalad>  mmorrow so it's fibred as in fibred product aka pullback?
04:56:17 <mmorrow> quicksilver, FunctorSalad: so i'm not quote sure how to succinctly  phrase this, but the punchline is how you can't build a FourMaps out of two TwoMaps with the existential version
04:56:21 <FunctorSalad> mmorrow: TwoMaps looks a lot like a pullback
04:56:48 <FunctorSalad> mmorrow: and what language is the first? ;)
04:57:03 <mmorrow> FunctorSalad: i'm borrowing this usage of "fibered" from the book ATAPL, and he says in a footnote that he's using "fibered" in a loosely-related-to-categiry-theory-sense
04:57:23 <mmorrow> FunctorSalad: but right, the point is that it's not a /product/ of other modules, but a pullback
04:57:50 <Itkovian> Any idea how to force evaluation of chunks in a list?
04:58:02 <ivanm> SamB_XP: doesn't seem to exist for QC2 ...
04:58:37 <mmorrow> FunctorSalad: it's some unspecified ML variant (the first language)
04:58:37 <SamB_XP> ivanm: oh
04:58:48 <mmorrow> FunctorSalad: err, ML-module-language variant
04:58:49 <SamB_XP> ivanm: well, there's got to be a way to adjust the verbosity *somehow*
04:59:44 <ivanm> it doesn't help that running ghci within emacs doesn't seem to work too well for the re-write stuff that quickCHeck does :s
04:59:47 <mmorrow> quicksilver: hah, badger badger mushroom badger?
04:59:58 <FunctorSalad> ivanm: insert tracers?
05:00:01 <mmorrow> crap, i got the percentages wrong
05:00:39 <vy> To calculate the mean of a list what should be the signature of "Just ((foldl (+) xs) / (fromIntegral (length xs)))", where function returns Nothing for an empty list as input?
05:00:53 <quicksilver> mmorrow: ok, I'm almost convinced by your elegant argument :)
05:00:58 <ivanm> FunctorSalad: I'm hoping to avoid that, as it would result in a _lot_ of output :s
05:01:14 <SamB_XP> ivanm: hehehe
05:01:16 <FunctorSalad> though it's a bit fishy that there isn't a parameterful version of TwoMaps...... ;)
05:01:18 <mmorrow> quicksilver: yay!
05:01:35 <SamB_XP> ivanm: there *is* something to be said for running GHCi in an xterm
05:01:35 <FunctorSalad> ivanm: you only insert them to find the problem
05:01:58 <quicksilver> mmorrow: seriously, it's just better language support for "automatically" doing sensible things with quantifiers at the module level?
05:02:04 <FunctorSalad> production version: trace = const id ;)
05:02:10 <ivanm> FunctorSalad: very large data structures are generated...
05:02:22 <quicksilver> mmorrow: just like H-M inference allows you to ignore quantifiers entirely, making them all top level universal, with the pros and cons of that
05:02:32 <FunctorSalad> ivanm: or run in profiler
05:02:36 <ivanm> it takes ghci long enough to read one in... (though again, that _could_ be the interaction with emacs)
05:02:53 <quicksilver> mmorrow: ML signature inference also allows you to ignore quantifiers entirely, and does something canonical, but lets you use "sharing" as a convenient way to tweak
05:02:54 <ivanm> FunctorSalad: yeah, but I'm trying to get the bugs fixed before I make an overall test executable
05:03:09 <quicksilver> mmorrow: ....whereas haskell explicit quantifier use forces you to do clumsy wrapping/unwrapping here.
05:03:15 <ivanm> well, there's a hack to get verbose-check like functionality anyway: http://www.mail-archive.com/haskell-cafe@haskell.org/msg60028.html
05:03:31 <quicksilver> (because we don't get first-class polymorphism without naming the type)
05:03:58 <mmorrow> quicksilver: or rather, for being able to (1) name subcomponents of existential packages (or (nested) modules if that's the case), and (2) require that the types of certain groups of subcomponents are the same, without having to think ahead of time which subgroups of types someone *might* want to require to be equal at some point in the future for a particular application
05:04:32 <ivanm> OK, running it in ghci now... and it becomes noticeably slower as it does more tests...
05:04:45 <ivanm> does it try to generate larger samples as it goes on or something?
05:04:52 <FunctorSalad> yes
05:05:07 <ivanm> good-o
05:05:18 <mmorrow> quicksilver: yeah, this is more of a module-level thing, and it's kind of weird to try to express with haskell records since you can't have type subcomponents
05:05:47 <mmorrow> and haskell modules don't have (named-in-a-signature) abstract types or nested modules
05:06:08 <mmorrow> so i'm not sure how this would/could be manifested in haskell as-is
05:07:18 <quicksilver> mmorrow: it's a kind of guided inference
05:07:31 <quicksilver> mmorrow: "infer the most general type but let me add specific constraints"
05:07:32 <quicksilver> I think.
05:07:36 <FunctorSalad> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4996#a4997
05:07:40 <mmorrow> quicksilver: ah, yeah that's a good way to say it
05:07:48 <FunctorSalad> so I still don't entirely get it.
05:08:38 <quicksilver> FunctorSalad: I think the point is you don't necesarily want FourMaps to be existential on the 'mid'
05:08:50 <quicksilver> you don't necessarily want anything to be existential, although you might.
05:09:15 <quicksilver> you want to leave type variables free as long as you can, and add arbitrary equality constraints where you combine structures.
05:09:26 <mmorrow> FunctorSalad: you changed the whole thing though, mine had the kind of TwoMaps as :: *
05:09:30 <mmorrow> not * -> * -> *
05:09:52 <FunctorSalad> sure
05:10:05 <quicksilver> mmorrow: but arguably the ML type of TwoMaps is * -> * -> *
05:10:14 <mmorrow> err, right, what quicksilver said
05:10:14 <quicksilver> s/type/kind/
05:10:16 <mmorrow> yeah
05:10:17 <FunctorSalad> data Ex2 f = forall a b. Ex2 (f a b)
05:10:24 <quicksilver> btu then you can also argue it isn't
05:10:26 <FunctorSalad> you can write that once and for all
05:10:37 <quicksilver> the ML version doesn't force you to tie the kind down.
05:10:47 <quicksilver> you can use it as if it was kind * and also as if it was kind * -> * -> *
05:10:51 <mmorrow> yeah, forget what i just said
05:10:52 <pastah> @src mapAccumL
05:10:53 <lambdabot> mapAccumL _ s []        =  (s, [])
05:10:53 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
05:10:53 <lambdabot>    where (s', y ) = f s x
05:10:53 <lambdabot>          (s'',ys) = mapAccumL f s' xs
05:10:55 <pastah> @src mapAccumR
05:10:56 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:11:02 <pastah> wat?
05:11:51 <mmorrow> FunctorSalad: the point is that you can /specify/ that two subcomponent types are the same without having to rewrite the type/module/sig/whatever declaration to make that so
05:12:06 <mmorrow> so you don't need to predict all possible patterns of use ahead of time
05:12:08 <ksf> why can't I nest data declarations inside a where?
05:12:46 <FunctorSalad> data decls inside a where...?
05:12:54 <quicksilver> ksf: it's a bug in the language.
05:13:07 <quicksilver> there is no good reason.
05:13:15 <quicksilver> unless simplicity counts as a reason.
05:13:42 <mmorrow> quicksilver: yeah, it's kind of an odd comparison between type kinds of haskell types and the "types" on ML functors
05:13:52 <mmorrow> s/on/of/
05:14:15 <ksf> FunctorSalad, I've got a function with 17 meaninful lines, and the data type is needed only inside those auxilary defs
05:14:31 <FunctorSalad> ksf: :)
05:15:06 <FunctorSalad> why not just use sums/tuples?
05:15:40 <pastah> concat is O(m*n), right (squared structure)
05:15:49 <ksf> data T b l = B b (T b l) (T b l) | L l
05:15:50 <FunctorSalad> (of course I get the point of types expressing intention, but in the local case the intention is close enough)
05:16:27 <pastah> ksf: is that some sort of tree?
05:16:28 <ksf> at least on the top of my head I can't come up with an inbuilt type that supports that.
05:16:31 <ksf> yep
05:16:33 <pastah> very cryptic, indeed
05:16:53 <FunctorSalad> looks like a binary tree :)
05:16:53 <pastah> but you have a special node-type; l
05:16:58 <pastah> kinda cool
05:17:02 <FunctorSalad> with distinct node and edge labels
05:17:03 <ksf> ...with the data at the leaves, and room for monoidal information in the branches
05:17:05 <pastah> useful? i dunno, but cool
05:17:28 <quicksilver> curiously there isn't even a haskell-prime proposal for local data
05:17:29 <quicksilver> how odd.
05:18:12 <ivanm> what are you calling local data?
05:18:15 <ksf> it's parametrized because I'm fist building a [T () (Float,Word8)] and then convert it into T Float Word8
05:18:51 <quicksilver> ivanm: a type which is local to a smaller scope than a file
05:19:11 <ksf> actually, the important intermediate step is [T () (Float,Word8)] -> T () (Float,Word8) , which builds the binary tree
05:19:13 <ivanm> quicksilver: as in a data definition inside a function?
05:19:17 <quicksilver> ivanm: yes.
05:19:40 <ivanm> how useful would something like that be?
05:19:48 <ksf> I couldn't be arsed to figure out how to fuse the building and bubbling up of the monoidal stuff into one loop
05:20:05 <ksf> not useful, just nice to have.
05:20:26 <quicksilver> definitely nice to have.
05:20:32 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12389#a12389
05:20:35 <FunctorSalad> I'm not saying it wouldn't be useful, but is it really a problem to make it toplevel?
05:20:40 <FunctorSalad> (don't export)
05:20:54 <ksf> there's just no reason whatsoever to have T at the top level
05:21:40 <ivanm> mmorrow: with Text.PrettyPrint.HughesPJ, do you know if it's possible to have it rendered with infinitely long lines like LeftMode, but to also have indentation?
05:21:55 <quicksilver> ksf: it would be a pain in a REPL potentially
05:22:04 <FunctorSalad> hmm one could make anonymous recursive type with functor-combinators
05:22:04 <quicksilver> ksf: since the types "wouldn't exist" at the scope the repl was running at.
05:22:10 <FunctorSalad> (like in regular / multirec)
05:22:12 <Chaze|shigoto> i've got that I can't - or shouldn't - write a "function" returning random values. but how would the main structure of a program look like that needs randomness? e.g. in the main loop 1. take user input 2. generate infinite list of randomness 3. feed that into an actual function 4. show result ?
05:22:23 <pastah> does "f !x = lol x" requere some special compiler directive?
05:22:24 <ivanm> I've been using ZigZagMode up until now, but for very long lines it decides to do line-break-thingies to reduce the indentation; this makes my parser unhappy :s
05:22:32 <mmorrow> ivanm: hmm, i thought it does infinitely long lines by default, but i'm not sure what you mean by "have indentation"
05:22:33 <FunctorSalad> pastah: BangPatterns
05:22:34 <pastah> -XBangPattarns or something?
05:22:39 <ksf> quicksilver, wheres are generally a pain in the repl
05:22:43 <mmorrow> ivanm: i'm not familiar with different rendering modes though
05:22:45 <ivanm> mmorrow: if you have LeftMode, it ignores all nest commands
05:22:47 <ksf> ...as you can't call those functions.
05:22:49 <mmorrow> ivanm: i always just use render
05:22:53 <mmorrow> ivanm: oh
05:22:56 <pastah> FunctorSalad: thanks :)
05:22:57 <mmorrow> ivanm: hmm, not sure
05:22:58 <ivanm> mmorrow: yeah, PageMode does wrapping
05:22:58 <ksf> I say that's because we have a module system.
05:23:20 <ksf> lets and wheres should be records, just like modules
05:23:31 <FunctorSalad> ivanm: set huge page width?
05:23:35 <FunctorSalad> just an idea
05:23:49 <quicksilver> ksf: true.
05:23:56 <ivanm> FunctorSalad: it gets set to being maxBound :: Int with ZigZagMode IIRC; obviously that isn't wide enough :s
05:24:00 <FunctorSalad> dunno HughesPJ though
05:24:08 <FunctorSalad> oh
05:24:34 <FunctorSalad> what are you parsing?
05:25:13 <ksf> I think I should make my fasta code load+compile the sequence data at runtime, not at compiletime.
05:25:18 <mmorrow> quicksilver: yeah, local data would be nice
05:25:40 <ivanm> FunctorSalad: this is for graphviz; when QuickCheck decides to make Arbitrary instances, they can get quite... deep...
05:25:51 <PeakerWork> @type sortBy . comparing
05:25:53 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
05:26:03 <PeakerWork> @hoogle sortOn
05:26:04 <lambdabot> No results found
05:26:04 <ivanm> so I'm trying to check that parse . print == id for my dot code datatypes
05:26:15 <ksf> the big macro gets compiled at compile-time, so ghc should be quite quick about loading the data.
05:26:16 <ivanm> PeakerWork: sortBy (compare `on` f) ?
05:26:30 <FunctorSalad> ivanm: is dot even whitespace-sensitive?
05:26:31 <PeakerWork> ivanm: I want a more compressed (named) form, not a lesser one :)
05:26:39 <ksf> ...at least neglegible compared to the total run-time, that is.
05:26:46 <FunctorSalad> if you use semicolons
05:26:52 <PeakerWork> ivanm: I am using it to replace awk at the command line, giving short-hand names so I can code golf a lot at the shell prompt
05:27:04 <ivanm> FunctorSalad: I'm not sure, the definition isn't that ... precise :s
05:27:20 <ivanm> PeakerWork: then create a function that does it yourself
05:27:31 <ivanm> sortOn f = sortBy (compare `on` f)
05:27:58 * ivanm wonders if he should try switching to a different pretty-printing library
05:28:48 <FunctorSalad> ivanm: hmm, this parses: echo "digraph { a; b; c }" | dot
05:29:05 <ivanm> FunctorSalad: so I suppose prettiness doesn't matter...
05:29:09 <PeakerWork> ivanm: that's what I am doing, but if there was one..
05:29:14 <ivanm> except prettiness makes it easier to debug manually, etc. :s
05:29:24 <pastah> how do i check the type of a function in a where clause in a where clause?
05:29:43 <FunctorSalad> pastah: scion can do that
05:29:44 <ivanm> I wonder what the "marking" that has been added to marked-pretty is actually for
05:29:52 <ivanm> the API looks the same at first glance...
05:30:23 <ivanm> oh, right, right down the end... a zero-width mark can be inserted, whatever that means
05:30:30 <FunctorSalad> it's quite sophisticated, I think he somehow tries to find the sourceLoc in the typechecked AST produced by GHC
05:30:37 <pastah> FunctorSalad: i thought that maybe ghci had some hidden cool feature for that
05:30:54 <FunctorSalad> pastah: implicit params? ;)
05:31:09 <ivanm> preflex: seen byorgey
05:31:10 <preflex>  byorgey was last seen on #haskell 1 day, 7 hours, 53 minutes and 41 seconds ago, saying: @remember IceDane [on escaping an imperative mindset]: <kmc> i recommend heavy drinking <IceDane> I've tried that. I just have fun and wake up and feel like shit the day after. but still think in loops.
05:31:17 <FunctorSalad> > let a = ?whatsthetype (fmap . fmap) in 12
05:31:18 <lambdabot>   Unbound implicit parameter (?whatsthetype::((a -> b)
05:31:18 <lambdabot>                       ...
05:31:47 <pastah> haha == greatest lib
05:36:22 <Chaze|shigoto> what exactly happens when I curry a function that doesn't take a tuple ?
05:36:47 <Chaze|shigoto> (uncurry (curry min))  is a function that does min on the first element of a tuple, and carries around the second
05:36:48 <ivanm> it won't work
05:36:50 <ivanm> @type curry
05:36:51 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
05:36:52 <Chaze|shigoto> but i don't know why
05:37:06 <ivanm> @type \f -> uncurry (curry f)
05:37:07 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
05:37:10 <EvilTerran> Chaze|shigoto, uh, uncurry . curry = id
05:37:26 <ivanm> EvilTerran: shhhh!!! I was hoping he'd realise that himself!
05:37:33 <Chaze|shigoto> uncurry (curry min) :: (Ord a, Ord b) => (a,b) -> (a,b) -> (a,b)
05:37:59 <ksf> :t uncurry (curry min)
05:38:00 <lambdabot> forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> (a, b)
05:38:05 <EvilTerran> ?type min :: (Ord a, Ord b) => (a,b) -> (a,b) -> (a,b) -- Chaze|shigoto, yeah, that's just a more specific type for "min"
05:38:06 <lambdabot> forall a b. (Ord b, Ord a) => (a, b) -> (a, b) -> (a, b)
05:38:15 <ivanm> yay, QuickCheck found a sample that fails, which is several screenfulls long! :s
05:38:32 <EvilTerran> Chaze|shigoto, so the behaviour of (uncurry (curry min)) is a matter of the way "min" is defined for pairs, nothing to do with curry/uncurry.
05:38:35 <Chaze|shigoto> >  (uncurry (curry min)) (2,3) (5,1)
05:38:36 <lambdabot>   (2,3)
05:38:44 <EvilTerran> >  min (2,3) (5,1)
05:38:45 <lambdabot>   (2,3)
05:38:48 <EvilTerran> >  min (2,3) (2,1)
05:38:49 <lambdabot>   (2,1)
05:39:05 <FunctorSalad> ivanm: ADT diff?
05:39:12 <ksf> if you want to min on the first element do
05:39:16 <ivanm> FunctorSalad: hmmm?
05:39:17 <Chaze|shigoto> ah right, wasn't aware of that
05:39:17 <EvilTerran> ?src (,) min
05:39:17 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:39:31 <ksf> > fist (min 2) (10,3)
05:39:32 <lambdabot>   Not in scope: `fist'
05:39:35 <ksf> > first (min 2) (10,3)
05:39:36 <lambdabot>   (2,3)
05:39:36 <Chaze|shigoto> :t curry min
05:39:37 <lambdabot> forall a b. (Ord a, Ord b) => a -> b -> (a, b) -> (a, b)
05:39:45 <EvilTerran> Chaze|shigoto, or rather, it's a result of the way Ord is defined for pairs
05:39:50 <ksf> or
05:39:52 <FunctorSalad> ivanm: I have that lying around somewhere for types deriving Data.Data.Data
05:39:58 <idnar> @type uncurry . curry
05:39:59 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
05:40:05 <ksf> > first (curry min) ((10,2),3)
05:40:06 <lambdabot>   (()->
05:40:06 <lambdabot>    ((-3,-3),())->
05:40:06 <lambdabot>      ((-3,-3),())
05:40:06 <lambdabot>    ((-3,-2),())->
05:40:06 <lambdabot>      ((-3,-2),(...
05:40:15 <ksf> > first (uncurry min) ((10,2),3)
05:40:16 <lambdabot>   (2,3)
05:40:28 <EvilTerran> uh... what was that?!
05:40:49 <idnar> EvilTerran: Show instance for functions
05:40:59 <idnar> > (+1)
05:41:00 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
05:41:04 <ksf> that's me confusing curry and uncurry
05:41:16 <idnar> @type min
05:41:17 <lambdabot> forall a. (Ord a) => a -> a -> a
05:41:17 <ivanm> yay, it's over 91000 characters long! :s
05:41:25 <idnar> @type uncurry (curry min)
05:41:25 <lambdabot> forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> (a, b)
05:41:25 <ksf> > (1/)
05:41:27 <lambdabot>   -0.375->
05:41:27 <lambdabot>    -2.6666666666666665
05:41:27 <lambdabot>  -0.75->
05:41:27 <lambdabot>    -1.3333333333333333
05:41:28 <lambdabot>  -1.5->
05:41:29 <lambdabot>    ...
05:41:46 <ksf> > (+undefined)
05:41:47 <lambdabot>   * Exception: Prelude.undefined
05:41:54 <ksf> just checking
05:42:18 <ksf> > (1/) . (+1.5)
05:42:20 <lambdabot>   -0.375->
05:42:20 <lambdabot>    0.8888888888888888
05:42:20 <lambdabot>  -0.75->
05:42:20 <lambdabot>    1.3333333333333333
05:42:20 <lambdabot>  -1.5->
05:42:22 <lambdabot>    In...
05:42:42 <ksf> > (1/) . (+0.375)
05:42:43 <lambdabot>   -0.375->
05:42:43 <lambdabot>    Infinity
05:42:43 <lambdabot>  -0.75->
05:42:43 <lambdabot>    -2.6666666666666665
05:42:43 <lambdabot>  -1.5->
05:42:45 <lambdabot>    -0.88888888...
05:43:18 <FunctorSalad> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12392#a12392
05:43:20 <FunctorSalad> :)
05:43:43 <ivanm> FunctorSalad: I don't have Data.Data.Data instances for them though...
05:44:05 <ivanm> and it doesn't help me work out where the breakage occurs AFAICT...
05:44:19 <FunctorSalad> you are comparing two ASTs no?
05:44:29 <FunctorSalad> (the original and the reparsed)
05:44:48 <ivanm> no
05:45:01 <ivanm> FunctorSalad: the problem is usually that the reparsed isn't being parsed ;-)
05:45:04 <ksf> is Data.Data.Data some kind of reference to swedish chefs?
05:45:26 <ivanm> so I have to work out where the parsing fails :s
05:45:26 <ivanm> ksf: heh
05:45:34 <ivanm> @remember ksf is Data.Data.Data some kind of reference to swedish chefs?
05:45:35 <lambdabot> I will never forget.
05:46:25 <ksf> Ha! I shall be included in the HWN, yet again. People will remember me for ages!
05:46:32 <Chaze|shigoto> ah, almost forgot the reason i've been asking: how would I build a function min that takes 3 arguments ?
05:46:51 <ivanm> Chaze|shigoto: min3 a b c = ...
05:47:03 <ivanm> or maybe just use minimum
05:47:05 <ivanm> @type minimum
05:47:06 <lambdabot> forall a. (Ord a) => [a] -> a
05:47:07 <Chaze|shigoto> ivanm: couldn't i build it myself from min ?
05:47:10 <pastah> whoo! my tetris thingy has a printing function :D
05:47:13 <ksf> @src minimum
05:47:13 <lambdabot> minimum [] = undefined
05:47:13 <lambdabot> minimum xs = foldl1 min xs
05:47:21 <ivanm> Chaze|shigoto: *shrug* if you really wanted to
05:47:48 <Chaze|shigoto> ivanm: i'm asking *how*. for learning purposes
05:47:51 <ivanm> hmmm, emacs doesn't seem to deal well with 60000+ character long lines... ;-)
05:47:55 <ksf> > 1 `min` (2 `min` 3)
05:47:56 <lambdabot>   1
05:47:59 <ivanm> Chaze|shigoto: depends on what you want it to do
05:48:07 <ksf> @pl 1 `min` (2 `min` 3)
05:48:08 <lambdabot> 1
05:48:13 <ivanm> ksf: he really learnt how there, didn't he
05:48:15 <ivanm> ksf: heh
05:48:23 <ksf> @pl \a b c -> a `min` (b `min` c)
05:48:23 <lambdabot> (. min) . (.) . min
05:48:41 <Chaze|shigoto> is it possible for n arguments ?
05:48:48 <ksf> with a list, yes
05:48:55 <ksf> :t foldl1 min
05:48:56 <lambdabot> forall a. (Ord a) => [a] -> a
05:49:02 <ivanm> Chaze|shigoto: not a general function, no
05:49:07 <Chaze|shigoto> yeah, was aware of that
05:49:08 <ivanm> unless you want to do type-class hackery
05:49:10 <Chaze|shigoto> alright
05:49:20 <ivanm> but is there any particular reason you're not using minimum?
05:49:37 <Chaze|shigoto> ivanm: cause i want to get an overview of what's possible in haskell :)
05:49:50 <ivanm> well, it's turing-complete...
05:49:50 <FunctorSalad> ivanm: ok, parse error is a different prob
05:49:52 <ivanm> ;-)
05:49:53 <ksf> oh you won't ever have that kind of overview.
05:49:56 <ivanm> FunctorSalad: yeah :s
05:49:57 <ksf> noone has it.
05:50:14 <ksf> except oleg, maybe
05:50:26 <ivanm> heh
05:50:34 <ksf> and he's just fooling us all the time, pretending to have discovered something new
05:50:38 <int-e> the hive mind of #haskell is pretty good though.
05:50:39 <Chaze|shigoto> ksf: one might consider that good, i find that's a huge downside
05:50:45 <pastah> if i have defined some type as StateT MyState IO a
05:51:05 <pastah> can i then write a function as State MyState a and run it?
05:51:17 <pastah> or do I need to make them all StateT?
05:51:25 <ksf> well, unlike c++, even all the crazy stuff that the language commitee just din't think of aren't actually painful or unideomatic.
05:51:39 <ksf> haskell is very deep, but not very broad
05:51:43 <EvilTerran> pastah, you'd need to lift your State s a to make it a StateT s m a
05:51:59 <pastah> EvilTerran: nah, i use lift to run my IO stuff
05:52:04 <FunctorSalad> what's a broad language?
05:52:08 <pastah> that doesn't make a lot of sense...
05:52:10 <FunctorSalad> lots of builtin stuff?
05:52:11 <ksf> something like c++
05:52:17 <ksf> lots of rules, no composition.
05:52:24 <EvilTerran> pastah, i don't mean literally the function "lift". i mean lifting in a general sense that i haven't worked out the details of yet.
05:52:25 <FunctorSalad> :(
05:52:34 <EvilTerran> ?type lift
05:52:35 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:52:37 <pastah> EvilTerran: haha, nice :)
05:52:42 <quicksilver> EvilTerran: that's called "hoist" by some people
05:52:43 <ksf> haskell is more like a language emerging from itself
05:52:52 <quicksilver> EvilTerran: you avoid it by never using State explicitly
05:52:55 <ksf> more like lisp in that sense.
05:52:56 <shambler> like lisp dialects?
05:52:59 <shambler> yeah
05:53:00 <shambler> agree
05:53:06 <quicksilver> EvilTerran: (just use MonadState instead, and instantiate it to the right type)
05:53:06 <ksf> tiny core, many possibilities
05:53:50 <EvilTerran> pastah, however, if you can write your state computation as "foo :: State s a", you can make that "foo :: MonadState s m => m a"
05:54:00 <EvilTerran> (this is what quicksilver is getting at)
05:54:19 <EvilTerran> and then you can use it in (nearly) any monad transformer stack with a StateT in it
05:54:24 <pastah> EvilTerran: well, i want to separate pure state functions from fugly io
05:54:46 <pozic> pastah: liftIO
05:54:51 <pastah> pozic: sorry
05:54:56 <pastah> other way around
05:54:58 <EvilTerran> pastah, if "foo :: MonadState s m => m a", then foo can have no IO effects; it must work for *any* state monad, so it can't do anything other than state monadic effects
05:55:14 <pozic> pastah: runState/T
05:55:34 <pastah> liftS :: State s a -> StateT s m a
05:55:34 <quicksilver> @type \action -> do { s <- get; let {(a,s') = runState action s}; put s'; return a }
05:55:36 <lambdabot> forall (m :: * -> *) s b. (MonadState s m) => State s b -> m b
05:55:40 * pastah tries to write
05:55:43 <pozic> pastah: I didn't real the scrollback in case it is irrelevant.
05:55:48 <quicksilver> EvilTerran, pastah ^^ there is the code for 'hoistState'
05:55:56 <quicksilver> although as I say it's not normally necessary.
05:56:12 <EvilTerran> there's a correspondence between the types "State s a" and "forall m. MonadState s m => m a"
05:56:16 <FunctorSalad> @wn hoist
05:56:17 <lambdabot> *** "hoist" wn "WordNet (r) 2.0"
05:56:17 <lambdabot> hoist
05:56:17 <lambdabot>      n : lifting device for raising heavy or cumbersome objects
05:56:17 <lambdabot>      v 1: raise or haul up with or as if with mechanical help; "hoist
05:56:17 <lambdabot>           the bicycle onto the roof of the car" [syn: {lift}, {wind}]
05:56:19 <lambdabot> [3 @more lines]
05:56:40 <pastah> quicksilver: that's pretty sweed
05:56:43 <pastah> *sweet
05:57:52 <pozic> hoist and intercalate can be friends then.
05:58:23 * FunctorSalad needs good name for program that generates folds for (mutually recursive) gadts
05:59:02 <quicksilver> pastah: thanks. But normally it never happens
05:59:12 <quicksilver> because normally when you write a State action, you use 'get' and 'put'
05:59:23 <FunctorSalad> hmm maybe I should add code generation for gmapQ / gmapT-like functions
05:59:27 <quicksilver> and if you use 'get' and 'put' then what you actually have is a MonadState action, not a State action
05:59:32 <quicksilver> so hoist turns out not to be needed.
05:59:49 <pastah> quicksilver: i want to denote what functions that are pure so that they are easily separatable from the StateT lol IO ones
05:59:53 <quicksilver> yes
06:00:01 <quicksilver> MonadState s m => m a *is* pure
06:00:11 <quicksilver> since it runs over all possible m, it obviously can't use IO
06:00:17 <pastah> quicksilver: yes, i know, but StateT Lol IO is not
06:00:20 <quicksilver> purity by parametricity.
06:00:23 <quicksilver> right.
06:00:32 <quicksilver> but you never need to use "State" directly.
06:00:44 <pastah> fuck it then
06:00:47 <quicksilver> You can use "MonadState" for the pure ones and "StateT s IO" for the impure ones
06:00:48 <pastah> glorified C it is
06:00:53 <quicksilver> not at all.
06:01:02 <quicksilver> I completely agree about easy separation.
06:01:10 <pastah> quicksilver: yeah, that was my intention
06:01:15 <quicksilver> I'm just saying you use MonadState for pure
06:01:19 <quicksilver> (instead of State)
06:01:38 <FunctorSalad> what's the problem?
06:01:41 <pastah> i'm trying to rewrite your "hoist" to do-notation, but things are missing up :(
06:01:56 <pastah> *messing*
06:01:58 <FunctorSalad> if you want IO too, just require MonadIO
06:02:15 <pastah> gawd! no more chefs here plz
06:02:25 <FunctorSalad> eh?
06:06:26 <pastah> quicksilver: heh, cleaned it up a little :)
06:06:27 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12394#a12394
06:07:20 <pozic> pastah: I have absolutely no idea why you would ever want to use that.
06:07:20 <quicksilver> pastah: yup, although it's still useless :)
06:07:48 <pastah> now i can write loads of functions in State Lol a
06:07:59 <pastah> and be sure that they are pure
06:08:15 <quicksilver> pastah: you should instead write them in MonadState Lol m => m a
06:08:18 <pozic> Well, whatever makes you happy. Come back in a month and tell me whether you are still using it.
06:08:19 <pastah> then just say "liftS runPure s" inside my StateT Lol IO
06:08:25 <quicksilver> pastah: and you will be equally sure they are pure
06:08:38 <quicksilver> pastah: and then you can use them inside StateT Lol IO with no lifting required.
06:09:20 <pastah> quicksilver: oh, so just removing the IO?
06:09:46 <quicksilver> you keep it polymorphic in the m
06:09:56 <quicksilver> "MonadState Lol m => m a" says that it runs in *all* m
06:10:05 <quicksilver> ...and therefore it must be pure, if it runs in all possible m.
06:10:42 <pozic> And if you are not a C++ programmer, you just never annotate anything unless the compiler cannot derive it.
06:11:15 <pastah> quicksilver: these will serve me well;
06:11:16 <pastah> type Game m a = StateT GameState m a
06:11:18 <pastah> type GameIO a = StateT GameState IO a
06:11:21 <pozic> For released code it might be nice to see the types in the source code, though, but tools should fix that really.
06:11:40 <pozic> pastah: code duplication
06:11:50 <quicksilver> pastah: seems reasonable
06:12:01 <quicksilver> (although you could just write type GameIO a = Game IO a) ;)
06:12:10 <pastah> nowai!
06:12:16 <pozic> Yeswai
06:12:17 <pastah> ok then :)
06:12:46 * pastah is making tetris
06:13:01 <geekagent> pastah: what about type GameIO a = (MonadIO m) => StateT GameState m a
06:13:56 <pastah> geekagent: m is on RHS but not on LHS
06:14:00 <pastah> == won't work
06:14:27 <pastah> geekagent: ghc gives "Illegal polymorphic or qualified type:"
06:14:38 <geekagent> pastah: what about type GameIO m a = (MonadIO m) => StateT GameState m a
06:14:48 <pastah> nah
06:15:12 <pastah> "Game m a = StateT Lol m a" is fine :)
06:17:13 <pastah> btw, this page is pretty awesome: http://bsixcentdouze.free.fr/tc/tgm-en/tgm.html
06:19:23 <zygoloid> class (MonadState GameState m, MonadIO m) => GameIO m; instance (MonadState GameState m, MonadIO m) => GameIO m
06:19:30 * ddarius recommends type Game = StateT X
06:20:12 <pastah> ddarius: no way! i'm not messing with the kind system
06:20:15 <pastah> NO WAY
06:20:23 <pastah> it will only lead to tears and heartache
06:20:40 <sohum> how's that messing with the kind system?
06:20:42 <sohum> :k X
06:20:43 <ddarius> pastah: If you don't eta-reduce, you end up with cases of partial application of the type synonym which are disallowed.
06:20:43 <lambdabot> Not in scope: type constructor or class `X'
06:21:07 * pastah cries
06:21:16 <pastah> i hate this channel
06:21:31 <sohum> oh, right
06:21:34 * sohum gets it now
06:22:09 <pastah> me: i wanna do something cool, this will make do, right?;    smart_people: here, on page 4 in the typeclassopedia you can see that zygotomorphism will mess things up for you
06:22:44 <pozic> pastah: just use the IO monad and IORefs and you can program like in C.
06:22:58 <pozic> pastah: no need for complicated things ;)
06:23:06 <pastah> nah, i'm pretty much done with my IO now
06:23:16 <pozic> In case anyone thought I was serious, I was not.
06:23:39 <pozic> pastah: people have just given names to a bunch of things. No need to worry about that.
06:23:42 <pastah> i will just need to make a randomizer in IO, then i'm odne
06:23:51 <pozic> pastah: just connect the types and you are done.
06:24:00 <pozic> pastah: probability monads.
06:24:07 <pozic> pastah: no need for IO.
06:24:21 <ddarius> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
06:25:33 <pozic> pastah: and if things are not obvious, maybe you just have to read a bit more stuff.
06:25:55 <ddarius> Don't listen to him pastah!  That's how it starts!
06:27:05 <pastah> haha
06:27:23 <sohum> and then before you know it, you're staying up late at night reading about endofunctors and monomorphism restrictions and breaking composability
06:27:54 <quicksilver> for a while, it's great, you write a monad tutorial
06:28:04 <quicksilver> then you write a blog post about how bad monad tutorials are
06:28:16 <quicksilver> you upload a DSL to hackage
06:28:20 <quicksilver> but, slowly, it gets worse
06:28:33 <quicksilver> you start to have recurrent nightmares about impredicativity
06:28:52 <quicksilver> you think you're being chased by a sinister black figure call The Evil Mangler
06:29:13 <sohum> we /are/ being chased by a sinister black figure called The Evil Mangler
06:29:18 <sohum> duh
06:30:07 <pastah> nah, i'll just stick to my StateT IO hacks
06:31:02 <siorai> can one express last as a foldr?
06:31:38 <sohum> > foldr1 f [a,b,c]
06:31:39 <lambdabot>   f a (f b c)
06:31:57 <pastah> @type const
06:31:59 <lambdabot> forall a b. a -> b -> a
06:32:06 <sohum> :t foldlr1 (flip const)
06:32:07 <lambdabot> Not in scope: `foldlr1'
06:32:08 <sohum> :t foldr1 (flip const)
06:32:10 <lambdabot> forall a. [a] -> a
06:32:20 * mmorrow picture The Evil Mangler as a godzilla-sized half cyborg that resembles larry wall, but with portions of his head missing, brainz exposed, and both arms below the elbow are spinning steel blades
06:32:24 <pastah> > foldr1 (flip const) "abcde"
06:32:25 <lambdabot>   'e'
06:33:23 <siorai> cheers, pasta
06:33:24 <sohum> :t foldr const undefined
06:33:25 <lambdabot> forall a. [a] -> a
06:33:38 <sohum> > foldr const undefined "abcde"
06:33:38 <mmorrow> one eye covered with an eyepatch too possibly for good measure
06:33:38 <jkff> > foldr (\x (t,v) -> if t then (False,x) else (False,v)) (True, undefined) [1..10]
06:33:39 <lambdabot>   'a'
06:33:40 <lambdabot>   (False,10)
06:33:49 <sohum> hrm?
06:33:57 <jkff> > let last = snd . foldr (\x (t,v) -> if t then (False,x) else (False,v)) (True, undefined) in last [1..10]
06:33:59 <lambdabot>   10
06:34:02 <jkff> Here you are.
06:34:23 <sohum> > foldr f undefined [a,b,c,d,e]
06:34:24 <lambdabot>   Ambiguous type variable `b' in the constraints:
06:34:24 <lambdabot>    `SimpleReflect.FromExpr ...
06:34:43 <sohum> > foldr f d [a,b,c]
06:34:45 <lambdabot>   f a (f b (f c d))
06:35:02 <sohum> > foldr const d [a,b,c]
06:35:03 <lambdabot>   a
06:35:13 <sohum> oh, right
06:35:15 <sohum> duh
06:35:24 <sohum> hnf.
06:35:37 <jkff> I think this is not going to work. There's an article "when is a function a fold or unfold"; I haven't read it, but it might tell why :)
06:35:56 <jkff> I mean, I think there is no way to express last as "foldr ... ..."
06:35:59 <sohum> :t foldr (flip const) undefined
06:36:00 <lambdabot> forall b a. [a] -> b
06:36:03 <jkff> Not as "something . foldr ... ..."
06:36:40 <sohum> yea, ok.
06:36:44 <sohum> so it has to be foldr1
06:37:02 <sohum> > foldr1 (flip const) [1..10]
06:37:03 <lambdabot>   10
06:38:47 <jkff> What about foldl?
06:39:03 <jkff> Can last be expressed as foo . foldl _ _, where foo is non-recursive?
06:39:13 <sohum> > foldl1 f [a,b,c]
06:39:15 <lambdabot>   f (f a b) c
06:39:19 <jkff> Oh
06:39:21 <jkff> I'm a fool
06:39:31 <sohum> > foldl f undefined [a,b,c]
06:39:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:39:32 <lambdabot>    `SimpleReflect.FromExpr ...
06:39:38 <sohum> > foldl f d [a,b,c]
06:39:39 <jkff> > foldl (flip const) [1..5]
06:39:39 <lambdabot>   f (f (f d a) b) c
06:39:40 <lambdabot>   []->
06:39:40 <lambdabot>    [1,2,3,4,5]
06:39:40 <lambdabot>  [[]]->
06:39:40 <lambdabot>    []
06:39:41 <lambdabot>  [[],[]]->
06:39:43 <lambdabot> [4 @more lines]
06:39:55 <jkff> > foldl (flip const) undefined [1..5]
06:39:56 <lambdabot>   5
06:40:18 <sohum> yea
06:40:21 <sohum> same logic
06:42:04 <geekagent> libxml2 has the ability to stream out a document in chunks. Would anyone be interested in a function in the Text.XML.LibXML module that created a lazy bytestring representation of a document?
06:44:06 <pastah> what's most costly to create?
06:44:16 <pastah> (x,y) or [x,y]?
06:44:28 <saml> (x,y)
06:44:36 <pastah> saml: cool, thanks :)
06:44:38 <saml> [x,y] is a list
06:44:43 <saml> wait.. i don't even know what you asked
06:44:51 <pastah> what has the most overhead
06:45:01 <saml> i bet [x,y]
06:45:12 <pastah> ok
06:45:13 <saml> but i did not implement ghc.. so i don't know
06:45:19 <pastah> hehe
06:45:25 <Lemmih> pastah: Why do you ask?
06:45:34 <saml> are you storing 2D coordinates?
06:45:39 <pastah> yeah
06:45:45 <pastah> well, not really
06:45:49 <ddarius> const is associative
06:45:52 <pastah> but almost
06:46:06 <saml> i think (x,y) makes sense then. because [x,y] means you can has [x,y,z,a,b,c,...]
06:46:25 <saml> (x,y) means i only want 2 things in the life time of application
06:46:37 <saml> > snd (1,2)
06:46:38 <lambdabot>   2
06:46:51 <saml> and you have enterprise grade accessor for pairs
06:47:08 <saml> > [1,2] ! 2
06:47:09 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
06:47:09 <lambdabot>         against inferred t...
06:47:13 <saml> > [1,2] !! 2
06:47:14 <lambdabot>   * Exception: Prelude.(!!): index too large
06:47:14 <ddarius> For 2D coordinates I'd recommend an explicit, strict data type; possibly monomorphic.
06:47:24 <ainirtnec> > [1,2] !! 1
06:47:25 <lambdabot>   2
06:47:49 <saml> oh crap. see? pair is better. you want the 2nd element, then you use snd
06:48:04 <pastah> ddarius: yeah, i made a grid interface a while back for stuff like that
06:48:09 <pastah> though this is different
06:49:46 <ben0x539> What does 'explicit' mean?
06:49:56 <saml> data TwoNumbers a = TwoNumbers a a
06:50:06 <saml> explicit means visible. no magic
06:50:29 <saml> it's opposite of implicit
06:50:32 <pastah> ben0x539: that nothing is left for your imagination
06:50:42 <mmorrow> data Vec2 = Vec2 {-# UNPACK #-}!Double {-# UNPACK #-}!Double
06:50:51 <ben0x539> Or the compiler's imagination, I guess.
06:50:59 <mmorrow> will be struct {double a; double b}
06:51:03 <mmorrow> well
06:51:09 <mmorrow> will be struct {void *blah; double a; double b}
06:51:15 <saml> wow that's awesome
06:51:35 <saml> > 1.223 :: {-# UNPACK #-}!Double
06:51:36 <lambdabot>   Unexpected strictness annotation: !!GHC.Types.Double
06:51:44 <mmorrow> only works for a datatype field
06:51:57 <mmorrow> > 1.233## :: Double#
06:51:57 <lambdabot>   Not in scope: type constructor or class `Double#'
06:52:02 <mmorrow> > 1.233##
06:52:03 <lambdabot>   Couldn't match kind `#' against `*'
06:52:12 <ddarius> > 1.0#
06:52:13 <lambdabot>   Couldn't match kind `#' against `*'
06:52:20 <mmorrow> @type GHC.Prim.D# 1.233##
06:52:20 <lambdabot> Not in scope: data constructor `GHC.Prim.D#'
06:52:22 <ddarius> The 'bot has a point.
06:52:26 <mmorrow> @type GHC.Real.D# 1.233##
06:52:27 <lambdabot> Not in scope: data constructor `GHC.Real.D#'
06:52:32 <mmorrow> @type GHC.Exts.D# 1.233##
06:52:33 <lambdabot> Double
06:52:46 <saml> D# is a good language name
06:52:56 <mmorrow> Eb!
06:52:57 <saml> C# D# E# F#
06:53:16 <ddarius> H# if you're a Brit
06:53:18 <smiler> We already have C# and F#, only need a few more to complete the scale
06:53:31 <Berengal> Where's A# and B#?
06:53:39 <zygoloid> Berengal: B# is C :)
06:53:57 <Berengal> I can see how that makes sense
06:54:00 <zygoloid> ddarius: H#? british?
06:54:18 <mmorrow> maybe that's like turning your amp up to 11
06:54:34 <zygoloid> ddarius: is that a Red Dwarf reference?
06:55:30 <Berengal> zygoloid: In britland, the scale is C D E F G A H, not C D E F G A B
06:55:40 <mmorrow> :o
06:55:49 <zygoloid> Berengal: that's not true, but it's an amusing idea :)
06:56:11 <Berengal> Well, it is in Norway anyway
06:56:21 <Berengal> So I assume that's what he meant
06:57:00 <saml> > A B C D E F G
06:57:01 <ainirtnec> How about G flat?
06:57:01 <lambdabot>   Not in scope: data constructor `A'Not in scope: data constructor `B'Not in ...
06:57:57 <saml> if you convert Pi digits as base 7 number (using "ABCDEFG" as alphabet) then its melody is so beautiful
06:58:21 <saml> try it and blog and post it on reddit please
06:58:24 <saml> so that i don't have to do that
06:58:40 * mmorrow plays that with his pcspkr-via-FFI-to-ioctl module
06:58:48 <geekagent> saml: what if you do it base 12 on the chromatic scale?
06:59:13 <saml> geekagent, try it. and try different scales too like pentatonic. and post them all
06:59:18 <zygoloid> Berengal: actually, i remember reading about that in Godel-Escher-Bach. in some places (Germany?) 'B' means Bb and 'H' means B
06:59:24 <saml> i will upvote
06:59:37 <mmorrow> > pi :: CReal
06:59:38 <lambdabot>   3.1415926535897932384626433832795028841972
06:59:38 <therp> zygoloid: correct
06:59:42 <stroan> don't suppose anyone knows if it's possible to use "foreign import ccall "&symbol" ..." without -fvia-C?
06:59:48 <mmorrow> > showDReal 100 (pi :: CReal)
06:59:49 <lambdabot>   Not in scope: `showDReal'
06:59:52 <mmorrow> > showCReal 100 (pi :: CReal)
06:59:53 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
07:00:01 <zygoloid> and in other places (France?) it's ut re mi... rather than do re mi
07:00:04 <ainirtnec> > map (['A'..'G'] !!) (randomRs (0,6) (mkStdGen 42)) -- This is also a beautiful melody. :)
07:00:06 <lambdabot>   "AFAEDDEFCAAGAECABECADFABBBCDDGBAEAECCBAGBGDAAAFFBFEFCCABCFCFGACCFABDAABABF...
07:00:16 <geekagent> stroan, I beleive it is
07:00:19 <saml> rick roll melody it is
07:00:28 <saml> wait.. how would we do rythm part?
07:00:36 <Berengal> zygoloid: Indeed, that's what I was taught as well. Not that I really know the difference
07:02:16 <zygoloid> Berengal: i wonder if it shows a preference for the mixolydian mode?
07:02:38 <stroan> geekagent: I really can't figure out how though
07:02:52 <stroan> I'm tryingt to get access to a variable symbol
07:03:09 <Berengal> zygoloid: All I know about music is that currently my headphones aren't working.
07:04:12 <zygoloid> could your batteries Bb?
07:05:27 <quicksilver> *rimshot*
07:05:44 <Veinor> Oh god, that was horrible
07:06:42 <quicksilver> he's here all week
07:07:55 * Berengal attempts to fix his headphones by kicking his computer
07:14:50 <ski> Berengal : you rebooted the system by kicking the computer ?
07:15:21 <Berengal> ski: The other way around, really, and it worked
07:15:42 * ski tries to imagine what the other way would mean
07:15:52 <Berengal> Kicking the computer by rebooting it
07:15:58 <HaskellBeginner> does someone have time to answer a few questions, very basic
07:16:02 <ski> the computer kicking you, and that caused the system to be rebooted ?
07:16:10 <ski> HaskellBeginner : ask away
07:16:18 <HaskellBeginner> ok
07:16:35 <Berengal> ski: Or the computer kicked me by rebooting me?
07:16:45 <ski> could be that
07:16:45 <HaskellBeginner> I want to double every even digid from a list of digits
07:16:57 <Berengal> cokick?
07:17:09 <Berengal> (== join?)
07:17:14 <ski> HaskellBeginner : sounds like a job for `map'
07:17:21 <HaskellBeginner> I have done prolog
07:17:28 <ski> ok
07:17:28 <HaskellBeginner> so I'm a litlle thinking like prolog
07:17:33 <HaskellBeginner> and wanted to go trough the list
07:17:37 <HaskellBeginner> with a head and tail funciotin
07:17:38 <stroan> HaskellBeginner: I came to Haskell from Prolog
07:17:38 <sohum> @pl \x -> if f x then g x else h x
07:17:39 <lambdabot> ap (liftM2 if' f g) h
07:17:50 <sohum> ....huh
07:17:52 <sohum> :t if'
07:17:53 <lambdabot> Not in scope: `if''
07:17:54 <stroan> There are some really misleading similarities
07:18:01 <stroan> you'll need to learn to think differently
07:18:06 <ski> HaskellBeginner : that would work, too .. except it's usually better to match directly, rather than call `head' and `tail'
07:18:08 <Berengal> if' p t f = if p then t else f
07:18:19 <HaskellBeginner> ah ok
07:18:19 <sohum> thanks, Berengal
07:18:25 <pastah> HaskellBeginner: have you seen a lambda function before?
07:18:29 <HaskellBeginner> no
07:18:31 <ski> stroan : what misleading similarities are you thinking of
07:18:39 <pastah> these are equal:
07:18:40 <ski> HaskellBeginner : what code you you have so far ?
07:18:43 <pastah> f x = x*x
07:18:46 <Hunner> Arg. I hate it when peopel mix tabs and spaces, especially since I have ts=4 by default...
07:18:49 <pastah> f = \x -> x*x
07:18:50 <HaskellBeginner> ok one sec
07:19:02 <stroan> ski: pattern matching syntax is very similar
07:19:03 <ski> @paste
07:19:04 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:19:08 <sohum> :t ap
07:19:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:19:09 <stroan> but doesn't have the backtracking facilities
07:19:10 <HaskellBeginner> is it possible to copy-paste
07:19:12 <HaskellBeginner> code?
07:19:14 <ski> HaskellBeginner : you may paste there ^
07:19:15 <HaskellBeginner> or just line by line
07:19:25 <ski> at the paste site
07:19:45 <pastah> HaskellBeginner: it's ok in here as long as it's just 1-2 lines
07:19:48 <ski> stroan : right, but i would say the basic idea of doing cases by matching is similar
07:19:59 <HaskellBeginner> ah ic
07:20:01 <HaskellBeginner> i'm pasting one sec
07:20:13 <Liskni_si> any idea what's wrong with code.haskell.org?
07:20:45 <Berengal> stroan: The list monad is almost prolog already. Haskell has pattern matching from the start, which just leaves out unification
07:20:48 <stroan> it is, but the evaluation strategy is also very different
07:20:58 <HaskellBeginner> I've paste my double even digid
07:21:00 <HaskellBeginner> but this code gives an error with the type
07:21:01 <sohum> (liftM2 if' f g) `ap` h == liftM3 if' f g h?
07:21:10 <Berengal> HaskellBeginner: post the link to the paste
07:21:20 <sohum> *is (lift...
07:21:23 <HaskellBeginner> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4998#a4998
07:21:56 <pastah> HaskellBeginner: remove the [ in the beginning
07:21:58 <pastah> and ] in the end
07:22:38 <Tobsan> @faq can haskell build a time machine and enable me to travel in time and leave some code at niklas's desk on monday morning this week?
07:22:38 <lambdabot> The answer is: Yes! Haskell can do that.
07:22:38 <ski> sohum : yes
07:22:48 <Berengal> [ and ] are list literals of finite length
07:22:51 <sohum> ski: danke.
07:23:06 <HaskellBeginner> so
07:23:22 <sohum> let if' x y z = if x then y else z in map (liftM3 if' even (*2) id) [0..10]
07:23:25 <sohum> > let if' x y z = if x then y else z in map (liftM3 if' even (*2) id) [0..10]
07:23:26 <lambdabot>   [0,1,4,3,8,5,12,7,16,9,20]
07:23:32 <ski> sohum :  liftM2 f ma mb `ap` mc  =  return f `ap` ma `ap` mb `ap` mb  =  liftM3 f ma mb mc
07:23:46 <sohum> oh /that/'s what ap's for
07:23:50 <sohum> cool
07:24:09 <Berengal> sohum: I like to use applicatives for that. "if' <$> even <*> (*2)  <*> id"
07:24:49 <sohum> Berengal: why are you using different ones? just from symmetry...
07:25:01 <sohum> :t (<$>)
07:25:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:25:04 <sohum> :t (<*>)
07:25:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:25:23 <Berengal> sohum: you need to lift the "if'" into the function applicative. (It's already a function, but not function enough :P)
07:25:28 <ManateeLazyCat> Recently i think about multi-process design, if every tab use one process, example every process use 4MB memory, in 2GB machine, i give this application 1600MB memory, then limit 400 Tabs, if Tabs is browser tab, every tab will use more memory.....
07:25:34 <sohum> Berengal: huh.
07:26:05 <wm_eddie> ManateeLazyCat: copy on write.
07:26:12 <zygoloid> ManateeLazyCat: a lot of that memory will be code and will be shared in any decent OS
07:26:12 <Berengal> sohum: just think of <*> as a generalized function application that works for generalized functions... ish
07:26:26 <sohum> yay for ishes :P
07:26:36 <pastah> HaskellBeginner: reload that paste
07:26:40 <Berengal> And <$> lifts a regular function into one of these generalized functions
07:26:52 <ManateeLazyCat> wm_eddie: zygoloid : more detail?
07:27:01 <ski> HaskellBeginner : are you sure you want to double every other element, counted from the *end* ?
07:27:14 <pastah> i renamed the variables to be more haskell-y and added "xss@" which means "xss is an alias for whatever's to the right of this @"
07:27:55 <HaskellBeginner> eh
07:28:08 <ManateeLazyCat> wm_eddie: zygoloid : I'm design *Haskell Application Platform*, so i use every tab with one process for protected, if any Tabs crash won't effect others tabs.
07:28:10 <pastah> HaskellBeginner: and you shouln't use variable names as "head" or "tail", since those are actual haskell functions
07:28:14 <zygoloid> ManateeLazyCat: the same memory pages can be mapped into the address spaces of multiple processes. more VM used does not mean more physical memory used.
07:28:25 <HaskellBeginner> ah ic
07:28:37 <pastah> head "lawlzmyballz"
07:28:40 <pastah> > head "lawlzmyballz"
07:28:42 <lambdabot>   'l'
07:28:51 <pastah> > tail "lawlzmyballz"
07:28:52 <lambdabot>   "awlzmyballz"
07:28:57 <sproingie> > head []
07:28:57 <sproingie> :(
07:28:57 <lambdabot>   * Exception: Prelude.head: empty list
07:29:09 <pastah> > tail []
07:29:11 <lambdabot>   * Exception: Prelude.tail: empty list
07:29:16 <ski> HaskellBeginner : you can call then `head', `tail' .. but one wouldn't usually shadow common library functions like that without a reason to
07:29:18 <zygoloid> > tail "terror"
07:29:19 <lambdabot>   "error"
07:29:25 <sproingie> > fix error
07:29:26 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
07:29:33 <HaskellBeginner> no indeed I understand
07:29:53 <HaskellBeginner> but you say it's better to define this function without the whole recursive head/tail thing?
07:30:05 <sohum> > take 10 $ fix (2:)
07:30:06 <lambdabot>   [2,2,2,2,2,2,2,2,2,2]
07:30:43 <ski> HaskellBeginner : pastah's annotation to the paste is still recursive
07:31:41 <pastah> HaskellBeginner: once you get used to writing your own list recursion functions you can start thinking about higher order functions
07:33:01 * ManateeLazyCat Yes, copy-on-write will save a lot memory.
07:33:06 <HaskellBeginner> yes
07:34:40 <ManateeLazyCat> BTW, how many process that Linux allow running (in 2GB memory)? I mean efficient running those processes.
07:34:49 <HaskellBeginner> what's the meaning of @ in xxs@(x:xs) pastah?
07:35:06 <tromp_> name binding
07:35:09 <ski> the list that is matched against `x:xs' is also called `xxs'
07:35:34 <ski> it's like if you had said `foo(XXs,...) :- XXs = [X|Xs],...' in Prolog
07:35:49 <HaskellBeginner> ah yes
07:35:50 <HaskellBeginner> ok
07:35:52 <ski> you get a name both for the whole list, and for the head and tail
07:36:00 <pastah> HaskellBeginner: it's just so that i can write "odd (length xss)" and don't have to write "odd (length (x:xs))"
07:36:51 <tromp_> although in that case i'd say even (length xs)   :)
07:37:17 <HaskellBeginner> ok ok
07:37:47 <pastah> @type mapAccumL
07:37:48 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:38:05 <ski> HaskellBeginner : what is your function supposed to give on input `[0,1,2,3]' ?; on input `[0,1,2,3,4]' ?
07:39:10 <HaskellBeginner> ehm, [0,2,2,6] and the other one [0,2,2,6,4]
07:39:23 <pastah> > (mapAccumL (\b x -> if b then (not b,x) else (not b, 2*x)) (
07:39:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:39:49 <Veinor> so basically double the odd numbers?
07:39:49 <pastah> > (\xs -> mapAccumL (\b x -> if b then (not b,x) else (not b, 2*x)) (odd $ length xs) xs) [1..10]
07:39:51 <lambdabot>   (False,[2,2,6,4,10,6,14,8,18,10])
07:39:58 <HaskellBeginner> yes
07:40:08 <pastah> > (\xs -> snd $ mapAccumL (\b x -> if b then (not b,x) else (not b, 2*x)) (odd $ length xs) xs) [1..10]
07:40:09 <lambdabot>   [2,2,6,4,10,6,14,8,18,10]
07:40:13 <HaskellBeginner> it's the Luhn validation algorithm what I'm trying to program step by step
07:40:35 <ski> HaskellBeginner : ok. since the current `doubleSecond' will give `[0,2,2,6,4]' on the latter, but `[0,1,4,3]' on the former
07:40:42 <pastah> HaskellBeginner: that version i just did here is quicker, only checks rest of the list once
07:40:51 <pastah> yours checks it over and over again
07:41:18 <Veinor> the best way would be to use f = map doubleOdd where doubleOdd = whatever involving guards
07:41:40 <pastah> Veinor: nah, i would use two functions, who call each other
07:41:53 <pastah> and an initializer function :)
07:42:16 <Veinor> bah, I forgot how to put a where statement with multiple lines on one line
07:42:50 <quicksilver> where a=b;c=d
07:42:59 <Veinor> > let f = map doubleOdd where {doubleOdd | odd x = 2 * x; doubleOdd | otherwise = x} in f [0,1,2,3]
07:43:00 <lambdabot>   Conflicting definitions for `doubleOdd'
07:43:00 <lambdabot>  In the binding group for: doubleOd...
07:43:03 <Veinor> :/
07:43:17 <sohum> remove the second "doubleOdd"
07:43:23 <sohum> guards go on one line
07:43:29 <sohum> (and the semicolon, I think)
07:43:32 <ski> @type let swap = snd &&& fst in flip . (((swap .) . runState) .) . mapM . ((State . (swap .)) .) . flip
07:43:33 <lambdabot> forall c a b. (c -> a -> (c, b)) -> c -> [a] -> (c, [b])
07:43:36 <HaskellBeginner> pastah you going to fast for me, :) , I get an error of occurs check on your code, pasted online
07:43:36 <Veinor> > let f = map doubleOdd where {doubleOdd | odd x = 2 * x | otherwise = x} in f [0,1,2,3]
07:43:38 <lambdabot>   Couldn't match expected type `a -> b'
07:43:38 <lambdabot>         against inferred type `Simple...
07:43:55 <quicksilver> Veinor: you're missing the parameter x for doubleOdd
07:43:56 <poucet> you need 'doubleOdd x | odd x = ..
07:44:19 <Veinor> ahhh yeah, how silly of me
07:44:21 <Veinor> > let f = map doubleOdd where {doubleOdd x | odd x = 2 * x | otherwise = x} in f [0,1,2,3]
07:44:23 <lambdabot>   [0,2,2,6]
07:44:26 <quicksilver> yay!
07:44:44 <Veinor> that's probably the best way to write it, none of this accumulator silliness :P
07:45:01 <quicksilver> > let f = map doubleOdd; doubleOdd x | odd x = 2 * x | otherwise = x in f [0,1,2,3]
07:45:02 <ski> Veinor : you should double elements on odd *indices*
07:45:02 <lambdabot>   [0,2,2,6]
07:45:07 <quicksilver> Veinor: who needs 'where'?
07:45:12 <Veinor> oh, that's what it's trying to do
07:45:21 <Veinor> I thought he was trying to double odd numbers
07:45:50 <sohum> @pl \x -> k x where k x | f x = g x | otherwise = h x
07:45:50 <lambdabot> (line 1, column 27):
07:45:50 <lambdabot> unexpected "="
07:45:50 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
07:46:01 <Veinor> if you're doubling odd indices, I think you might need an accumulator or something
07:46:03 <sohum> pl doesn't understand guards I see
07:46:05 <zygoloid> > zipWith ($) (cycle [id,(*2)]) [0,1,2,3]
07:46:06 <lambdabot>   [0,2,2,6]
07:46:16 <Veinor> ... oh yeah, heh
07:46:17 <Botje> sohum: it understands if, though.
07:46:29 <Botje> @pl \x -> if f x then g x else h x
07:46:30 <lambdabot> ap (liftM2 if' f g) h
07:46:33 <sohum> Botje: in terms of if', which hoogle can't find >_>
07:46:38 <Botje> @src if'
07:46:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:46:41 <Botje> argh
07:46:45 <ben0x539> if' a b c = if a then b else c
07:46:48 <pastah> HaskellBeginner: check the paste now
07:46:51 <Veinor> hoogle says there's no Bool -> a -> a that does what you'd think
07:46:56 <Botje> yeah. that.
07:47:03 <sohum> I know that's the definition
07:47:08 <quicksilver> > let f = zipWith (\i x -> if odd i then x*2 else x) [0..] in f [0,1,2,3]
07:47:10 <lambdabot>   [0,2,2,6]
07:47:13 <sohum> but why is it not already defiined.
07:47:23 <poucet> sohum: exercise left for the reader.
07:47:27 <sohum> poucet: :P
07:47:28 <Veinor> I'd say 'because it's not useful', but when has that stopped us before?
07:47:32 <HaskellBeginner> i'm checking
07:47:46 <Botje> i think it's supposed to be in haskell'
07:48:02 <poucet> Botje: so all operators in haskell' will be operator' for operator in haskell?
07:48:10 <Botje> hah! :)
07:48:16 <Botje> poucet++
07:48:30 <poucet> @karma vincenz
07:48:30 <lambdabot> vincenz has a karma of 0
07:48:39 <poucet> Well I didn't lose much by killing vincenz.
07:48:59 <poucet> @karma poucet
07:49:00 <lambdabot> You have a karma of 2
07:49:01 <Botje> it was confusing, too
07:49:14 <sohum> @karma c
07:49:14 <lambdabot> c has a karma of 0
07:49:22 <sohum> oh?
07:49:26 <sohum> c++
07:49:28 <poucet> c++ is not a great language
07:49:28 <sohum> @karma c
07:49:29 <lambdabot> c has a karma of 0
07:49:34 <int-e> @karma sohum
07:49:35 <lambdabot> sohum has a karma of 0
07:49:36 <sohum> ...interesting.
07:49:36 <jystic> @pl \x y -> x `xor` (ord y)
07:49:36 <lambdabot> (. ord) . xor
07:49:38 <sproingie> i don't think it scans for random ++
07:49:43 <sproingie> @karma c--
07:49:43 <lambdabot> c-- has a karma of 3
07:49:49 <sproingie> oh that's cute
07:49:52 <sohum> ...what
07:49:55 <poucet> o.O
07:50:18 <sproingie> i believe c-- is the new backend target
07:50:21 <int-e> I think c++ decreased the karma of the person saying it at one point.
07:50:31 <sohum> ahaha
07:50:33 <Veinor> I don't know why but that amuses me
07:50:39 <Botje> that's mean. I teach c++!
07:50:48 <poucet> Botje: I feel for you, really.
07:50:52 <Veinor> I am sorry for your loss, Botje :(
07:50:54 <poucet> Botje: I like programming in C++, but teaching it must be HELL
07:51:02 <ben0x539> @pl let if' c a b = unsafePerformIO $ newIORef a >>= \ref -> unless c (writeIORef ref b) >> readIORef ref in if'
07:51:03 <lambdabot> ((unsafePerformIO .) .) . flip ((.) . (>>=) . newIORef) . flip flip readIORef . (liftM2 (>>) .) . (. flip writeIORef) . (.) . unless
07:51:06 <Botje> it's still fun, so far
07:51:26 <int-e> just stay away from the (dys)functional template programming.
07:51:46 <Botje> i only use them for data structures
07:51:48 <portnov> > map sum $ filterM (const [False,True]) [1..4]
07:51:49 <lambdabot>   [0,4,3,7,2,6,5,9,1,5,4,8,3,7,6,10]
07:51:56 <ski> > mapM (\x -> State $ \b -> ((if b then id else (2*)) x,not b)) [1..10] `evalState` False  -- pastah ?
07:51:57 <lambdabot>   [2,2,6,4,10,6,14,8,18,10]
07:52:15 <ski> (not claiming that's what HaskellBeginner want)
07:52:24 <pastah> ski: haha, i think mapAccum wins
07:52:38 <sohum> :t filterM . const [True,False]
07:52:40 <lambdabot>     Couldn't match expected type `a -> m Bool'
07:52:40 <lambdabot>            against inferred type `[a1]'
07:52:40 <lambdabot>     In the first argument of `const', namely `[True, False]'
07:52:47 <sohum> :t filterM (const [True,False])
07:52:48 <lambdabot> forall a. [a] -> [[a]]
07:52:58 <sohum> :t pset
07:52:58 <poucet> sohum: generates permutations
07:53:00 <lambdabot> Not in scope: `pset'
07:53:17 <sohum> poucet: I know :) It's my favourite piece of monad golf
07:53:24 <int-e> > zipWith id (cycle [id, (2*)]) [1..10]
07:53:26 <lambdabot>   [1,4,3,8,5,12,7,16,9,20]
07:53:32 <sohum> @let pset = filterM (const [True, False])
07:53:33 <lambdabot>  Defined.
07:53:57 <byorgey> preflex: seen ivanm
07:53:58 <preflex>  ivanm was last seen on #xmonad 2 hours, 1 minute and 13 seconds ago, saying: *shrug*
07:54:06 <Botje> mapaccum looks like it could be implemented more cleanly with the state monad
07:54:28 <mmorrow> , fix (interleave [0..])
07:54:29 <lunabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16...
07:54:33 * ManateeLazyCat When i use GHC dynamic recompile my project in external process, eat 198MB..... not small. :)
07:54:59 <sohum> ...what
07:55:04 <sohum> :t interleave
07:55:05 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
07:55:07 <mux> @oeis 0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9
07:55:09 <lambdabot>  a(2n) = n, a(2n+1) = a(n).
07:55:09 <lambdabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8,...
07:55:30 <ManateeLazyCat> mmorrow: Hi
07:55:43 <mmorrow> ManateeLazyCat: hi
07:55:45 <sohum> > interleave [0,1,2] [2,3,4]
07:55:47 <lambdabot>   [0,2,1,3,2,4]
07:55:55 <mmorrow> ManateeLazyCat: how's your prog coming?
07:55:56 <sohum> ok
07:56:04 <ski> pastah : why ?
07:56:36 <mmorrow> , foldr interleave [] (fmap (\n -> [n..]) [0..])
07:56:37 <lunabot>  [0,1,1,2,2,2,3,3,4,3,5,3,6,4,7,4,8,5,9,4,10,6,11,4,12,7,13,5,14,8,15,5,16...
07:56:48 <ManateeLazyCat> mmorrow: I think i need refactory my project again, prallel-process/concurrent-thread.
07:57:13 <ManateeLazyCat> mmorrow: Maybe will later 1 month.
07:57:35 <ainirtnec> > interleave [] [1..10]
07:57:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:57:37 <mmorrow> ManateeLazyCat: ah, i see. well, at least it'll be a better program overall.
07:57:49 <sohum> @oeis 0,1,1,2,2,2,3,3,4,3,5,3,6,4,7,4,8,5,9,4,10,6,11,4,12,7,13,5,14,8,15,5,16
07:57:50 <lambdabot>  Sequence not found.
07:57:50 <ManateeLazyCat> mmorrow: I use GtkPlug/GtkSocket to implement multi-process reander in *same* window.
07:58:02 <mmorrow> ManateeLazyCat: ooh cool
07:58:14 <mmorrow> ManateeLazyCat: one thing that i really like that gedit does is:
07:58:51 <ManateeLazyCat> mmorrow: Code and throw exception will running in split process, but render in RootProcess, so ChildProcess crash won't effect RootProcess.
07:58:52 <mmorrow> ManateeLazyCat: anytime you do "$ gedit foo.txt" in *any* shell, it'll open that file up in an *existing* gedit instance if one exists
07:59:29 <mmorrow> which is handy, since you can use gedit like a kind of dump for files you want to quickly-browse-but-not-right-now
07:59:40 * quicksilver thinks it's fairly evil to do that with the main process
07:59:43 <mmorrow> as you walk the filesystem tree in your shell
07:59:44 <ManateeLazyCat> mmorrow: Infact, GtkSocket/GtkPlug is cross-process embedded in Gtk.
07:59:51 <quicksilver> should either be "gedit -client" or "geditclient"
07:59:52 <quicksilver> IMO
08:00:18 <ManateeLazyCat> mmorrow: So i can embedded any Gtk widget in my project, even i never coding it.
08:00:25 <mmorrow> ManateeLazyCat: ah, neat
08:00:48 <mmorrow> quicksilver: it just sticks the newly opened file in another tab
08:01:17 <mmorrow> and you can split tabs to new windows (which i guess makes another process?), and move tabs /between/ sindows
08:01:17 <sohum> most gnome apps do that, I think
08:01:19 <mmorrow> *windows
08:01:22 <sohum> it's a dbus thing
08:01:24 <ManateeLazyCat> mmorrow: Example, firefox develop MozillaEmbedded (i don't remember exactly name), it's a Gtk widget with Xembedded protocol, then i can just use some lines to embedded it in it.
08:01:29 <mmorrow> sohum: ahh
08:01:40 <ManateeLazyCat> mmorrow: No, split tabs share one process.
08:01:40 <mmorrow> ManateeLazyCat: that's handy
08:01:54 <mmorrow> ManateeLazyCat: ah
08:02:00 <ManateeLazyCat> mmorrow: Otherwise, will eat too much memory.
08:02:17 <mmorrow> hmm, right
08:02:58 <ManateeLazyCat> mmorrow: Think about, every Tabs use 4MB, and i open 50 Tabs use 200MB, if i split with 5 Views, i need 1GB.
08:03:05 <ManateeLazyCat> 1000MB
08:03:11 <sproingie> i think it's reasonable for apps to decide whether to use the same instance, tho gedit -new would be a good idea
08:04:02 <sproingie> can't use simple external editor scripts with a reused editor
08:04:34 <quicksilver> mmorrow: I understood what you said.
08:04:38 <quicksilver> mmorrow: I just said it was a bad itdea.
08:04:40 <ManateeLazyCat> mmorrow: Because two tabs in different View, just share share data, so if any un-catch exception occur in current Tabs, it also crash in Other View. But won't effect other tabs.
08:05:14 <ManateeLazyCat> mmorrow: Infact, gedit is simple editor, and haven't advance feature.
08:05:28 <quicksilver> it's meddling with understood semantics for no good reason. "xterm" starts a fresh xterm, so "gedit" should start a new "gedit".
08:05:33 <ManateeLazyCat> mmorrow: IMO, Geany is better than Gedit on some feature.
08:05:35 <quicksilver> that's why emacs uses emacsclient for this.
08:05:37 <zygoloid> ManateeLazyCat: you don't need 1GB for 250 runs of a 4MB process. you only need 250x the amount of unshared memory
08:06:14 <ManateeLazyCat> zygoloid: Yep, i mean limit.
08:06:24 <ManateeLazyCat> zygoloid: In practice, won't use 1GB
08:06:38 <ManateeLazyCat> zygoloid: If every Process need write something.
08:07:51 <ManateeLazyCat> mmorrow: For current situation, i worried about Memory use for crazy user (like me) that open too many Tabs, if use too memory, will make OS became. slow.
08:08:10 <quicksilver> implement process-level GC :)
08:08:29 <quicksilver> although, to be honest, your OS's built in VM system is a kind of process GC
08:08:32 <quicksilver> they get swapped out, at least
08:08:48 <ManateeLazyCat> mmorrow: Maybe i need add some mechanism make stable module share *one* process when memory is not enough.
08:09:01 <ManateeLazyCat> quicksilver: Not easy.
08:09:17 <int-e> So the OOM killer is the ultimate garbage collector?
08:09:29 <sproingie> no it's just garbage
08:09:37 <ManateeLazyCat> quicksilver: Parallel-Process/Concurrent-Haskell-Thread is complicated enough now.
08:09:45 <ManateeLazyCat> quicksilver: But that's a good idea.
08:10:38 <sproingie> OOM killer is like the first thing i disable on production boxes.  i'd rather have a malloc fail than have random critical things killed off
08:10:48 <ManateeLazyCat> quicksilver: Infact, i think it's *Haskell Application Platform*, not really OS, because it don't care hardware in most time.
08:11:05 <mmorrow> quicksilver: true, but that single feature is the only reason i ever use it at all
08:11:27 <mmorrow> quicksilver: actually, firefox has this behavior too
08:11:56 <ManateeLazyCat> mmorrow: I consider use D-Bus as IPC for my multi-process communication, what do you think?
08:12:14 <quicksilver> mmorrow: the feature is great, not bad.
08:12:16 <ManateeLazyCat> mmorrow: First, i need binding Gtk-Dbus to gtk2hs. :)
08:12:25 <quicksilver> mmorrow: the bad part is making it the default behaviour of the command 'gedit'
08:12:34 <Zao> ManateeLazyCat: Sounds like a rather heavy dependency.
08:12:38 <mmorrow> ManateeLazyCat: i'm not very familiar with D-Bus actually, but you could also listen on a network port i guess for incoming tasks too
08:12:39 <quicksilver> mmorrow: it should be gedit -client or gclient or gc or something
08:12:42 <Zao> Especially as many lusers do not have one running.
08:12:54 <Zao> Also, good luck getting a decent dbus up on Windows.
08:13:08 <mmorrow> quicksilver: nuh uh!!@
08:13:34 <mmorrow> quicksilver: but yeah, that behavior could get annoying if i used gedit as my main editor
08:13:43 <mmorrow> maybe
08:13:51 <ManateeLazyCat> mmorrow: Infact, named-pipe is enough, but i want use D-Bus for a try.
08:14:02 <mmorrow> ManateeLazyCat: ah true, yeah named pipe
08:14:10 <mmorrow> ManateeLazyCat: cool, go for it
08:14:13 <sproingie> i have gedit bound to super-n (from windows, where it pops up notepad++)
08:14:17 <sproingie> very convenient
08:14:28 <sproingie> i use it as a sort of extended clipboard
08:14:34 <mmorrow> totally, me too
08:14:49 <mmorrow> gedit is like teh super clipboard
08:14:53 <ManateeLazyCat> mmorrow: RootProcess control everything, ChildProcess infact don't care user event, everything is message by RootProcess.
08:15:27 <sproingie> i
08:15:34 <sproingie> i'm pondering switching it to emacs actually
08:15:58 <mmorrow> hmm, interesting. could a ChildProcess "change owners" somehow? like, say you have two separate root process instances, can they exchange children? (just thought of this, i don't know of a use-case or even if it would be useful at all)
08:16:04 <mmorrow> (@Manatee)
08:16:09 <ManateeLazyCat> Liskni_si: Zao said binding Gtk-Dbus to gtk2hs is too many dependency: libdbus -> gtk+ -> gtk2hs
08:16:37 <Saizan_> mmorrow: chromium does something like that, probably
08:16:42 <ManateeLazyCat> mmorrow: I have binding DND event for Gtk Notebook.
08:17:02 <ManateeLazyCat> mmorrow: So i can create new RootProcess when user Drop Tabs outside.
08:17:05 <sproingie> processes generally can't be reparented
08:17:13 <ManateeLazyCat> mmorrow: But that's too cool.
08:17:14 <sproingie> except by killing the parent of course
08:17:29 <ManateeLazyCat> mmorrow: Infact, i don't need do that.
08:17:39 <ManateeLazyCat> mmorrow: Notebook support that default.
08:18:09 <ag90> Hey. Is it just me or is projects.haskell.org down?
08:18:09 <ManateeLazyCat> mmorrow: If you have two Notebook and open record properties, then you can Drop tabs from one to another.
08:18:16 <mmorrow> sproingie: oh right, i meant logically as opposed to physically
08:18:47 <mmorrow> sproingie: well, actually i was considering that the ChildProcess wasn't actually necessarily a real child of the RootProcess
08:19:35 <mmorrow> something like how nodes get organized into a hierarchy by some algorithm (fsvo of (distributed) node)
08:19:40 <ManateeLazyCat> mmorrow: Infact, in my model, don't need Tab Process as Chlid of RootProcess.
08:20:01 <sproingie> yah i suppose you can start a new RootProcess then have one hand the other the data
08:20:01 <mmorrow> ManateeLazyCat: ah, cool
08:20:26 <ag90> Anyone? Is projects.haskell.org down?
08:21:00 <sproingie> using shm you could hand off the data pretty quickly
08:21:06 <mmorrow> sproingie: or have children "register" with a root, and do a "reparenting" by a root telling a child to go to another root (or the child making that decision, or something)
08:21:20 <Saizan_> ag90: looks down, yup
08:21:38 <ag90> Thanks. Just wanted to be sure the problem's not at my end.
08:21:42 <ManateeLazyCat> mmorrow: In more deeply, i can split sub-module from my platform, example some user don't like running some many feature, just want use editor or browser, then can drop tabs (or View) outside, then platform split to editor program and browser program, of course, them can merge again.
08:21:58 <ManateeLazyCat> mmorrow: But above feature just TODO plan, haven't implement.
08:22:12 <sproingie> mmorrow: sure, a virtual process model can be designed however you want, but if you implement it with real processes, you probably want the actual process hierarchy to match
08:22:27 <sproingie> otherwise you get a rude surprise when you kill the original parent
08:22:54 <mmorrow> ManateeLazyCat: oh nice, yeah that's kind of what i mean. the ability to split/merge parts of the application into separate/the-same logical (or physical) piece
08:23:02 <mmorrow> that would be cool for sure
08:23:10 <ManateeLazyCat> mmorrow: Infact, you don't need *reparent* or something, everything is split.
08:23:25 <sproingie> weren't those fancy "object oriented" OS's supposed to make that sort of thing easy?
08:23:30 <sproingie> gee, whatever happened
08:23:32 <mmorrow> sproingie: heh, true (re: killing a parent not necessarily killing a logical "child")
08:23:47 <ManateeLazyCat> mmorrow: Because GtkSocekt/GtkPlugs support cross-process embedded, so you just need unplug from current RootProcess then Plug to another RootProcess.
08:24:03 <mmorrow> ManateeLazyCat: oh nice, yeah exactly what i meant
08:24:15 <sproingie> beos had replicants that sort of did all this
08:24:18 <mmorrow> "connection"-oriented (or something)
08:24:58 <ManateeLazyCat> mmorrow: Honestly, those need refactory current code for cross-process model.
08:25:16 <ManateeLazyCat> mmorrow: So maybe i need more time, now just me works on it.
08:25:36 <ManateeLazyCat> mmorrow: I want open source as quickly as possible, but for current situation, less is faster.
08:26:05 <ManateeLazyCat> mmorrow: Perhaps i need buy 2GB for test my *OS*.
08:26:07 <mmorrow> ManateeLazyCat: there's a fine line between "feature creep" and foresight
08:26:28 <cathper> Uhm, there's RealFrac, is there also a infinite precision Frac that can interpret 0.9999... as 1, for instance?
08:27:04 <ManateeLazyCat> mmorrow: For extension system, i need add some *third-layout* to control *communication* part, then every sub-system won't know others sub-system.
08:27:09 <fasta> cathper, there are CReals
08:27:22 <ManateeLazyCat> mmorrow: Otherwise, code is hard to modified and maintain.
08:27:25 <tromp_> how wld it get 0.999... as input?
08:27:32 <tromp_> as a String?
08:27:51 <tromp_> then, obviously, it cldn't check that all elements are 9
08:28:03 <cathper> tromp_: Nope, as a result of a computation, I get 30.99999...
08:28:03 <mmorrow> ManateeLazyCat: yeah, i think decreasing coupling is always a win
08:28:03 <HaskellBeginner> I get an error in my code (parse error on input 'z' ), Someone maybe tell me why? I have pasted it on the pastesite, its called sum digits
08:28:08 <ManateeLazyCat> mmorrow: Infact, have so much feature i have plan, but now i just want to build a stable framework, then let others people help me to do.
08:28:18 <ManateeLazyCat> mmorrow: Just me, is too slow for my project.
08:28:26 * hackagebot upload: astview 0.1.3 - A GTK-based abstract syntax tree viewer for custom languages and parsers (SebastianMenge)
08:28:28 <tromp_> then you already have 31
08:28:32 <cathper> tromp_: And when I truncate it, it's 30, but that's just because of the finite number representation.
08:28:43 <tromp_> they're the same
08:28:47 <fasta> cathper, well, you do things numerically or symbolically, of course, but that's not what CReal does.
08:28:58 <fasta> cathper, and rounding is possible too, of course.
08:29:02 <cathper> fasta: numerically.
08:29:22 <mmorrow> ManateeLazyCat: yeah, i think it's super important to get something/anything working/released as a first step. i'm trying to do this with my own project as well.
08:29:56 <fasta> cathper, well, you cannot ask the program to to that. It would have to prove that once the computation reaches 30.9, it will in turn evaluate to 30.99 and then to 30.999 and so on for ever.
08:29:57 <ManateeLazyCat> mmorrow: Split/Merge is killer feature, for old UNIX hacker, just use sub-system them want, keep KISS, for crazy guy, will use my *huge* platform.
08:30:03 <mmorrow> it's so easy to go off on (at the moment) unnecessary tangents, then all of a sudden a month has gone by
08:30:04 <bastl> could anyone (with gtk2hs installed) plz try astview? I uploaded already 3 non-working versions :-/
08:30:23 <mmorrow> ManateeLazyCat: hehe, totally
08:30:31 <fasta> cathper, so, it is going to be symbolic anyway, so you probably want to ask something else.
08:30:55 <fasta> cathper, and as tromp_ said 31.0 and 30.999999999999999 are the same.
08:31:15 <ManateeLazyCat> mmorrow: I hope oneday, i just need Linux-Kernel and my platform for everything, of course, not mean write everything myself, just provide a super cool platform for Haskeller.
08:31:33 <sproingie> "linux is my bios"
08:31:34 <mmorrow> ManateeLazyCat: i'm excited to use it :)
08:33:35 <ManateeLazyCat> mmorrow: Do you have any others good suggestions for my project?
08:33:43 <ManateeLazyCat> mmorrow: I like to listen your suggestions.
08:33:51 <fasta> mmorrow, export real-time operations.
08:33:54 <mmorrow> heh :)
08:34:00 <fasta> ManateeLazyCat, export real-time operations.
08:34:02 <ManateeLazyCat> mmorrow: You have help me fix *recursive reference*.
08:34:13 <mmorrow> ManateeLazyCat: not at the moment, but i'll think about for sure.
08:34:29 <ManateeLazyCat> fasta: I don't understand, can you more detail?
08:34:35 <mmorrow> *..think about _it_ for ...
08:34:52 <fasta> ManateeLazyCat, I missed most of the conversation, but I had the impression you wanted to create some kind of Haskell layer on top of the Linux kernel.
08:34:54 <ManateeLazyCat> mmorrow: More suggestions is better!
08:35:15 <ManateeLazyCat> fasta: Infact, not
08:35:21 <fasta> ManateeLazyCat, ok, never mind then.
08:35:40 <ManateeLazyCat> fasta: Just Haskell base on Gtk+ for create *Haskell Application Platform*.
08:35:57 <ManateeLazyCat> fasta: Then you can use Haskell with gtk2hs implement any application in it.
08:35:57 <fasta> ManateeLazyCat, what does that even mean?
08:36:11 <fasta> ManateeLazyCat, so, just a gtk2hs automatic installer?
08:36:22 <ManateeLazyCat> fasta: No.
08:36:30 <mmorrow> fasta: like, say, Yi (emacs) + not just "text"
08:36:43 <dcoutts> bastl: Could not find module `Language.Haskell.HsColour.Colourise'
08:36:44 <sproingie> i suspect meaning a full desktop and application stack in haskell.  tall order.
08:36:51 <fasta> mmorrow, ah, Climacs.
08:36:52 <dcoutts> bastl: astview-0.1.3
08:37:04 <sproingie> only WM in that stack being xmonad, which frankly ain't everyone's taste
08:37:09 <bastl> ah, thats a problem: My Setup.hs has dependencies ...
08:37:10 <ManateeLazyCat> mmorrow: You can implement any Gtk+ program in it, but just with *similar* behaviour. Most are keyword.
08:37:11 <dcoutts> bastl: this appears to be when compiling the Setup.hs itself
08:37:24 <mmorrow> ah right
08:37:30 <bastl> i guess it doesnt help to add that to the cabal file ?
08:37:35 <mmorrow> fasta: and not just an "editor"..
08:37:35 <dcoutts> bastl: it's generally best to avoid deps in the Setup
08:37:36 <ManateeLazyCat> mmorrow: Is for fasta :)
08:37:37 <HaskellBeginner> can someone help me with a simple code with a parsing error I don't understand?
08:37:48 <dcoutts> bastl: it'd help for users of cabal-install
08:37:54 <cathper> > let i1=5; i2=13; r=3; s1=6; s2=6; k=2 in s2*(i1/r) + ((k+1)*s2 - i2) * ((i1/(r-k))-(i1/r)) + (i2-k*s2)*(s1-(i1/r))
08:37:55 <lambdabot>   30.999999999999996
08:38:05 <cathper> This number should be 31.
08:38:06 <sproingie> HaskellBeginner: sure, paste it and let's take a look
08:38:07 <ManateeLazyCat> fasta: My user is programmer or engineer want work efficiently.
08:38:09 <sproingie> @paste
08:38:09 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:38:15 <cathper> fasta, tromp_
08:38:16 <bastl> but its a very nice hook, IMHO
08:38:23 <ManateeLazyCat> fasta: But wider than emacs user.
08:38:26 <fasta> ManateeLazyCat, if you want that, fix GHC first ;)
08:38:37 <ManateeLazyCat> fasta: ?
08:38:38 <dcoutts> bastl: how about depending on the hscolour program instead?
08:38:45 <bastl> how?
08:38:59 <tromp_> > let i1=5; i2=13; r=3; s1=6; s2=6; k=2 in s2*(i1/r) + ((k+1)*s2 - i2) * ((i1/(r-k))-(i1/r)) + (i2-k*s2)*(s1-(i1/r)) :: CReal
08:39:00 <fasta> ManateeLazyCat, the GHC bug data base contains problems actual users already have.
08:39:00 <lambdabot>   31.0
08:39:12 <ManateeLazyCat> fasta: Yes, i want i can do some contribution for GHC, but now haven't time do that. :)
08:39:15 <fasta> ManateeLazyCat, then you are sure you are not solving imaginative problems.
08:39:16 <dcoutts> bastl: build-tools: hscolour
08:39:27 <cathper> tromp_: Okay, so CReal, it is, I see.
08:39:53 <mmorrow> fasta: who is paying for the ghc hacking?
08:39:58 <Athas> fasta: well, Climacs is basically textual too.
08:40:01 <ManateeLazyCat> fasta: I think i will do more contribution for gtk2hs when my project release.
08:40:03 <bastl> dcoutts: ah. ok. I had that before, but i liked the "in-haskell" solution very much. hmm.
08:40:04 <Athas> Doesn't Microsoft Research fund most of GHC?
08:40:13 <quicksilver> > let i1=5; i2=13; r=3; s1=6; s2=6; k=2 in s2*(i1/r) + ((k+1)*s2 - i2) * ((i1/(r-k))-(i1/r)) + (i2-k*s2)*(s1-(i1/r)) :: Rational
08:40:14 <lambdabot>   31 % 1
08:40:15 <ManateeLazyCat> fasta: I will do contribution for GHC when i have enough knowledge about it.
08:40:20 <mmorrow> Athas: all 3 paid developers, yes.
08:40:21 <copumpkin> moo
08:40:26 <quicksilver> cathper: Rational is much faster than CReal and exact.
08:40:47 <ski> mmorrow : it would be useful to trade one process from one screen session to another
08:40:58 <ski> pastah : regexp ?
08:41:01 <fasta> Is there some way to turn a GTK+ application into one that does do all the window operations in the background, but doesn't actually show the windows using some global flag?
08:41:04 <tromp_> but Rational won't work for square roots
08:41:13 <quicksilver> cathper: however if you can prove that that operation always results in an exact integer you should probably be able to rearrange it so that it is actuall integer math.
08:41:30 <tromp_> :t sqrt
08:41:30 <mmorrow> ski: yeah totally
08:41:31 <fasta> mmorrow, every user when there is a problem and Microsoft, I suppose.
08:41:32 <lambdabot> forall a. (Floating a) => a -> a
08:41:51 <cathper> quicksilver: It's not always an integer.
08:41:52 <tromp_> map ((^2) . sqrt) [0..20]
08:41:59 <quicksilver> tromp_: AFAICR, cathper is working in Z/{p^m}, so doesn't need Real square roots.
08:42:10 <fasta> I still don't quite understand why MS still funds them, though.
08:42:12 <tromp_> > map ((^2) . sqrt) [0..20]
08:42:13 <lambdabot>   [0.0,1.0,2.0000000000000004,2.9999999999999996,4.0,5.000000000000001,5.9999...
08:42:15 <cathper> quicksilver: But fractional should be enough.
08:42:31 <tromp_> > map ((^2) . sqrt) [0..20] :: [CReal]
08:42:32 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
08:42:38 <fasta> They are basically competing against F#.
08:42:42 <ManateeLazyCat> fasta: Microsoft is changing....
08:42:49 <fasta> ManateeLazyCat, probably not.
08:43:04 <mmorrow> fasta: i don't see much incentive for people to contribute, say, an entire code-generator subunit, fully tested and working, which took 2 months of full-time work, without getting paid full-time for it
08:43:05 <ManateeLazyCat> fasta: I think Microsoft is changing something.
08:43:31 <qwr> > (map head . filter (\l -> not (null l) && all (>= head l) (tail l)) . tails) [17,1,13,28,1,2,6,34,37,15,48]
08:43:32 <lambdabot>   [1,1,2,6,15,48]
08:43:33 <cathper> quicksilver: Except from floor which gives me a RealFrac.
08:43:36 <byorgey> HaskellBeginner: z needs to be lined up exactly under the y in the 'where' block.  You have a tab before the 'where', change it to use spaces instead.
08:43:41 <ManateeLazyCat> fasta: Sometimes, Microsoft is open than before.
08:43:43 <qwr> > (map head . filter (\l -> all (>= head l) (tail l) && not (null l)) . tails) [17,1,13,28,1,2,6,34,37,15,48]
08:43:44 <lambdabot>   [1,1,2,6,15,48* Exception: Prelude.tail: empty list
08:44:05 <qwr> is this evaluation order somehow documented in haskell or just ghc behaviour?
08:44:11 <fasta> mmorrow, the incentive will be there when enough applications depend on it. Simple economics. It might take a 100 fold the number of applications, though ;)
08:44:12 <mmorrow> fasta: ghc needs companies (or someone!) to fund developers to do particular tasks badly
08:44:19 <doublethink_work> fasta: MSR pretty much pays people to work on whatever they think is important
08:44:25 <fasta> mmorrow, I am well aware of that.
08:44:36 <doublethink_work> simon & simon happen to think GHC and haskell are important, so that's their job :)
08:44:51 <cathper> quicksilver: Is there a floor :: Rational -> Rational?
08:44:52 <byorgey> HaskellBeginner: since Haskell is indentation-sensitive, it's recommended to always use spaces and never tabs.  You should be able to set your favorite editor to automatically convert tabs into spaces.
08:44:54 <cathper> :t floor
08:44:55 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:45:02 <cathper> Bleh.
08:45:03 <fasta> doublethink_work, so, the whole world has applied at MSR?
08:45:08 <doublethink_work> probably
08:45:13 <mmorrow> fasta: right, but two months of full-time work without getting paid and without doing something that /will/ get you paid in the future is a stretch
08:45:15 <cathper> quicksilver: floor :: Rational -> Integral.
08:45:18 <ManateeLazyCat> fasta: IMO, Microsoft fund SPJ research Haskell and GHC is right thing.
08:45:49 <byorgey> hmm, code.haskell.org seems to be down =(
08:45:49 <byorgey> at least the webserver is
08:46:05 <qwr> (that && first argument seems to get evaluated before second...)
08:46:11 <fasta> mmorrow, yes, I agree. Open-source software economics doesn't work, imho, for large complicated features that everyone wants.
08:46:14 <ManateeLazyCat> mmorrow: I agree, if not resource to support research, Haskell and GHC will stop.
08:46:16 <doublethink_work> i don't really see it as competition. considering don syme is down the hallway from SPJ and Simon M., I expect they have a great deal of interesting conversations :)
08:46:17 <fasta> mmorrow, blame RMS.
08:46:30 <cathper> :-D
08:47:12 <stroan> is community.haskell.org not responding for anyone else?
08:47:32 <ManateeLazyCat> fasta: RMS is idealist, but he do right thing in most feature.
08:47:38 <cathper> stroan: I get icmp response.
08:47:47 <quicksilver> > floor (1.5::Rational)
08:47:48 <lambdabot>   1
08:47:50 <quicksilver> cathper: works for me
08:47:55 <fasta> In the meanwhile I am starting to believe that a lot of stuff in Haskell is a good idea. There are some bad ones, but in general programs written in Haskell lead to better software.
08:47:56 <cathper> Gah.
08:47:56 <quicksilver> cathper: (why didn't you just try it?)
08:48:01 <stroan> cathper: http?
08:48:05 <byorgey> stroan: yeah, the webserver seems to be down
08:48:13 <byorgey> or at least under very heavy load
08:48:17 * cathper is a Haskell n00b. <- quicksilver 
08:48:22 <fasta> ManateeLazyCat, he didn't come up with a solution to the problem as raised by mmorrow.
08:48:29 * stroan hopes hitting f5 over and over fixes the problem
08:49:07 <stroan> haskell servers seem to need a bit of redundancy
08:49:21 <quicksilver> it's hard to imagine a world in which there are not resources to support research.
08:49:37 <quicksilver> it would be very different form this one
08:49:44 <quicksilver> GHC existed before MSR hired the simons
08:49:55 <quicksilver> (and people were paid to work on it, too)
08:50:00 <ManateeLazyCat> fasta: I think not perfect people in this world? :) I still respect him, even i disagree with him on some feature.
08:50:15 <quicksilver> of course, where the resources go varies from decade to decade
08:50:26 <quicksilver> but there has always been money going into programming language research.
08:50:43 <therp> It would be interesting if http://en.wikipedia.org/wiki/Basic_income would fundamentally change the way the free software ecosystem works..
08:51:04 <qwr> > let (&&) a b = if b then a else False in (map head . filter (\l -> all (>= head l) (tail l) && not (null l)) . tails) [17,1,13,28,1,2,6,34,37,15,48]
08:51:05 <lambdabot>   [1,1,2,6,15,48]
08:51:33 <fasta> We have a gazillion formal systems to model just about everything. What else is there to be researched?
08:51:34 <copumpkin> qwr: why are you redefining (&&)?
08:51:36 <ManateeLazyCat> fasta: I think Microsoft is good company if it more open.
08:51:40 <Raevel> oh, for some reason my scion broke, but now it's working again, so so so awesome
08:51:42 <copumpkin> fasta: you're kidding?
08:52:00 <qwr> copumpkin: i'm interested, whether the && eval
08:52:08 <copumpkin> people lump MSR with MS too much
08:52:10 <fasta> copumpkin, no, I know quite a bunch of stuff and I have not seen a single fundamental new idea in the last 5 years.
08:52:11 <qwr> copumpkin: i'm interested, whether the && evaluation order is defined in standard library or not
08:52:15 <copumpkin> > True && undefined
08:52:16 <lambdabot>   * Exception: Prelude.undefined
08:52:24 <copumpkin> > False && undefined
08:52:25 <lambdabot>   False
08:52:29 <poucet> qwr: it doesn't matter, since it haskell is lazy.
08:52:43 <qwr> > undefined && False
08:52:44 <lambdabot>   * Exception: Prelude.undefined
08:52:49 <qwr> it matters
08:52:54 <int-e> it matters since haskell is lazy
08:53:03 <copumpkin> check out the unamb package
08:53:05 <fasta> copumpkin, everyone thinks they are working on the latest and greatest thing, while in fact most of it is just a reinvention of something or something that is merely possible now because of faster hardware.
08:53:06 <copumpkin> @hackage unamb
08:53:07 <lambdabot> http://hackage.haskell.org/package/unamb
08:53:12 <quicksilver> qwr: yes, the evaluation order of && is defined by the standard library.
08:53:15 <poucet> fasta: welcome to the real world
08:53:19 <poucet> @src (&&)
08:53:20 <lambdabot> True  && x = x
08:53:20 <lambdabot> False && _ = False
08:53:26 <pastah> ski: yeah, regexp; you have two states, ds0 and ds1 and both can reach the accepting state [] when [] is encountered
08:53:29 <ezrakilty> it's designed to emulate the short-circuiting && as in C
08:53:29 <fasta> copumpkin, but please, present your fantastic examples.
08:53:44 <qwr> quicksilver: thanks
08:53:48 <copumpkin> fasta: not sure prefacing one's sweeping generalization of the world of research with "I know quite a bunch of stuff" makes it more convincing
08:53:51 <quicksilver> qwr: the haskell standard doesn't pin evaluation order completely
08:53:57 <quicksilver> but that example is clear.
08:53:59 <therp> fasta: what a true insight, although I would remove the faster hardware part.
08:54:33 <ski> pastah : i would think of finite state machine, or something like that ..
08:54:36 <fasta> therp, I didn't want to make it too general ;)
08:55:30 <fasta> copumpkin, be sure not to overload my bandwidth with all your examples.
08:55:48 <sproingie> "something that is merely possible"
08:55:54 <sproingie> love that phrase
08:55:57 <pastah> ski: tomato tomato
08:56:07 <sproingie> as opposed to FTL drive research i guess
08:56:17 <therp> fasta: but I don't see that as negative as copumpkin would. stuff usually becomes more refined if it is reinvented. Haskell is just another reinvention of a functional language, and for sure not the last one.. but the nice thing is that this reinvention happened to hit a sweet spot with its design choices
08:56:54 <fasta> therp, yes, sure there seems to be some progress going on. I like that, of course.
08:57:25 <fasta> sproingie, 1994 called they want their warp-drive back.
08:57:28 <therp> so reinvention isn't bad. and isn't a waste of time either. reinvention another CPS-small-step evaluator that could be tied into a big-step evaluator using the Y combinator was just pure fun.
08:58:10 <sproingie> industrial research is largely innovation, i.e. to make an old thing new
08:58:28 <sproingie> the green field of new ideas is where academia lives
08:58:29 <copumpkin> fasta: oh, I just took issue with the arrogance of your statement, I can't say I have any examples of "groundbreaking" new research, or that any examples I may have would satisfy your criteria
08:58:42 <cathper> sproingie: Nice def of innovation :-)
08:59:06 <fasta> I just think that the cost/benefit equation of PL research is getting a bit off balance; there are more interesting things to put in money.
08:59:26 <therp> fasta: money? there is money in PL research? never heard that.
08:59:27 <fasta> It's the same for philosophy positions.
08:59:39 <ski> pastah : have some ketchup ?
08:59:40 <therp> at least not where I live.
08:59:42 <quicksilver> on the other hand, PL research is very very cheap.
08:59:42 <copumpkin> "all the things that can be invented have been invented and we should do something else"
08:59:51 <copumpkin> I love it when people say that or the equivalent of it
08:59:54 <cathper> People on universities spend time on what they think is interresting and publishable, I guess ...
09:00:00 <quicksilver> compared to most areas of research you might put money into.
09:00:29 <fasta> copumpkin, you can talk to me in 30 years and point at all the fantastic inventions that came from "PL research".
09:00:43 <sproingie> (haskell perhaps?)
09:01:00 <sproingie> even has 10 years to go for that deadline
09:01:01 <ski> fasta : composable continuations ?
09:01:03 <copumpkin> fasta: I defer to your knowledge of a "bunch of stuff"
09:01:58 <fasta> ski: meh, I don' t think they are _that_ interesting.
09:02:28 <poucet> ski: you mean delimited ones?
09:02:56 <ski> yes
09:03:03 <fasta> copumpkin, the bunch of stuff I talk about existed before 5 years ago. PL research did some interesting things, but at some point there is just not that much to be done anymore, other than evolutionary stuff, which is mostly just the writing of faster/better compilers.
09:03:04 <copumpkin> DPH
09:03:19 <fasta> And at that point you are basically building a product.
09:03:21 <ski> delimited / composable / sub- continuations
09:03:34 <Raevel> what do i need to do to get cabal test to run my tests?
09:04:13 <fasta> And when you are building a product it is not called "research" anymore according to the various grant agencies.
09:04:19 <copumpkin> dph has some genuinely interesting ideas in it, and the current difficulty of working with dependent types probably means there's a fair amount of work that can be done in that area
09:04:26 <poucet> ski: I'm curious why the whole continuations for code that can spawn never went anywhere
09:04:42 <fasta> copumpkin, yet all of it is just filling in details.
09:05:06 <copumpkin> well then, what are "genuinely new ideas" in the past 10 years?
09:05:09 <copumpkin> or 20?
09:05:16 <fasta> copumpkin, nothing that "changes the game", because ultimately it is the hardware that changes the actual possibilities of computing.
09:05:37 <fasta> copumpkin, building a vastly better quantum computer would be one.
09:05:49 <fasta> copumpkin, OOPS would be another.
09:06:09 <copumpkin> OOPS?
09:06:15 <cathper> Is there a way of representing Infinity as a Rational?
09:06:22 <copumpkin> cathper: nope
09:06:22 <quicksilver> cathper: no.
09:06:23 <fasta> copumpkin, OOPS is an algorithm which was quite "new", just like "The fastest algorithm for all well-defined problems" .
09:06:42 <Baughn> @quote mdo
09:06:42 <lambdabot> No quotes match. Wrong!  You cheating scum!
09:06:58 <cathper> copumpkin, quicksilver: Okay, thanks :-)
09:07:09 <copumpkin> fasta: a faster quantum computer would "just" be evolutionary too
09:07:13 <fasta> copumpkin, but all the PL people do is building the same kind of things: termination detectors, type-systems, compilers and so on. All these things have remained the same for at least the past 20 years.
09:07:35 <fasta> copumpkin, I mean one with a few hundred thousand bits.
09:07:42 <medfly> I think you need to remember what things were like 20 years ago
09:08:03 <fasta> copumpkin, currently, people expect that quantum computers grow with only in a linear way.
09:08:08 <fasta> copumpkin, not in an exponential way.
09:08:28 <fasta> s/with only//
09:08:45 <quicksilver> fasta: it is utterly ridiculous to suggest computer programming or programming languages are the same now as they were 20 years ago
09:08:53 <quicksilver> and I remember 20 years ago pretty clearly.
09:08:58 * copumpkin was a toddler
09:08:59 <quicksilver> (in this respect, at least!)
09:09:06 <copumpkin> but it's ridiculous even to me :P
09:09:34 <nothingmuch> anybody want to troll bash? http://blog.woobling.org/2009/11/functional-programming-and-unreasonable.html
09:09:36 * hackagebot upload: astview 0.1.4 - A GTK-based abstract syntax tree viewer for custom  languages and parsers (SebastianMenge)
09:09:38 <copumpkin> fasta: anyway, sure, if you restrict your definition of innovation sufficiently, there has been no innovation in PL
09:09:44 <fasta> quicksilver, the basic ingredients for Haskell exist for 20 years, no?
09:09:46 <copumpkin> and every researcher should go home and do something else
09:09:57 <Baughn> "mdo a <- forkIO (killThread b); b <- forkIO (killThread a)" <-- Who wins?
09:10:13 <fasta> quicksilver, the basic formal system behind Coq exists even longer.
09:10:15 <copumpkin> fasta: you just haven't really convinced me that you actually read enough PL literature to make such sweeping generalizations
09:10:22 <sproingie> http://www.yesbutnobutyes.com/archives/funnycomic_capwank.jpg
09:11:00 <fasta> copumpkin, and you fail to say anything with contents.
09:11:33 <quicksilver> fasta: the basic ingredients for newtonian mechanics have existed for 500 years; the basic ingredients for relativity for 50 (rounding to arbitrary approximations) and yet the field of physics has made huge advances in those spans.
09:12:52 <copumpkin> fasta: all I'm saying is that if you're going to say something as dismissive and potentially offensive to a huge number of people, you'd better have a very detailed list of everything that's happened in the past few years and why you consider it unworthy of research funding
09:13:42 <fasta> copumpkin, you should go into politics and bore people with your arguments there.
09:13:47 <copumpkin> o.O
09:13:55 <copumpkin> wow :)
09:13:55 <sproingie> BUH BYE
09:14:12 <copumpkin> I'd call it a parthian shot but it wasn't very good
09:14:12 <sproingie> another satisfied customer.  next!
09:14:14 <Vulpyne> Guy's a bit of a jerk, eh?
09:14:39 <copumpkin> @tell fasta you can do better than that
09:14:40 <lambdabot> Consider it noted.
09:16:21 <ystael> copumpkin: "parthian flounce" ?
09:16:26 <copumpkin> :)
09:20:34 <hyuma> hi guys
09:20:42 <hyuma> anyone can tell me what's wrong in that code?
09:20:43 <copumpkin> allo!
09:20:43 <hyuma> mulInt :: [Int] -> Int
09:20:43 <hyuma> mulInt [ ] = 1
09:20:43 <hyuma> mulInt (x : xs) = x * mulInt xs
09:20:48 <hyuma> sorry
09:20:49 <hyuma> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5004#a5004
09:21:17 <tromp_> looks ok
09:21:25 <copumpkin> > let mulInt [ ] = 1; mulInt (x : xs) = x * mulInt xs; in mulInt [1..5]
09:21:26 <lambdabot>   120
09:21:34 <copumpkin> hyuma: how about you tell us what's wrong
09:21:44 <copumpkin> and we'll tell you what's wrong with what's wrong
09:21:48 <stoop>  > let mulInt [ ] = 1; mulInt (x : xs) = x * mulInt xs; in mulInt [1..3]
09:21:50 <stoop> > let mulInt [ ] = 1; mulInt (x : xs) = x * mulInt xs; in mulInt [1..3]
09:21:51 <tromp_> > prod [1..5]
09:21:52 <lambdabot>   6
09:21:52 <lambdabot>   Not in scope: `prod'
09:21:56 <copumpkin> > product [1..5]
09:21:57 <lambdabot>   120
09:22:00 <jlouis> Someone is WRONG on the Internet!
09:22:12 <stoop> Hrm.
09:22:14 <stoop> Maybe.
09:22:17 <stoop> > let mulInt [ ] = 1; mulInt (x : xs) = x * mulInt xs; in mulInt [1..]
09:22:19 <lambdabot>   * Exception: stack overflow
09:22:28 <stoop> hyuma, is that what is happening?
09:22:56 <mmorrow> you're laying the entire list out on the stack before you multiply anything
09:23:01 <stoop> Hi mmorrow
09:23:06 <mmorrow> int mul(int *xs, int n){if(n < 1) return 1; return xs[n] * mul(xs,n-1);}
09:23:08 <hyuma> stoop: no, I receive this error: possibly incorrect indentation
09:23:11 <mmorrow> stoop: hiya
09:23:27 * mmorrow disappears
09:23:27 <stoop> mmorrow, I thought you could be interested in http://www.reddit.com/r/systems/
09:23:37 <copumpkin> hyuma: what's the indentation you actually used?
09:23:45 <copumpkin> the pasted version looked fine
09:23:52 <mmorrow> stoop: ooh, cool. i'll check that out
09:23:57 <stoop> mmorrow, we need more contributors and moderators. You seem to be working on interesting things which we would love to learn more about.
09:23:58 <jlouis> tabs?
09:24:06 <hyuma> copumpkin: I receive error in first line, i dunno why
09:24:35 <copumpkin> yay systems
09:25:15 <mmorrow> yay!
09:25:17 <jmcarthur_work> stoop or mmorrow: what is mmorrow working on that is relevant to OS dev and computer architecture?
09:25:35 <Vulpyne> > let mulInt = foldl' (*) 1 in mulInt [1..5]
09:25:36 <lambdabot>   120
09:25:47 <mmorrow> jmcarthur: there looks like some compiler links on that page too
09:25:51 * jmcarthur_work subscribes to the systems reddit
09:25:52 <jmcarthur_work> aha
09:26:05 <copumpkin> jmcarthur_work: zomg!
09:26:20 <stoop> I'm not so sure of the description.
09:26:25 * mmorrow ninja-vanishes
09:26:31 <jmcarthur_work> copumpkin, !!!
09:26:31 <copumpkin> poof!
09:26:36 <stoop> These are things that /r/programming and /r/coding don't seem really interested in for some reason or another.
09:26:48 <sm> and.. the newer haddock in ~/.cabal/bin sees them ok. Hmm
09:26:52 * stoop adds compilers to description
09:27:00 <copumpkin> only 5 readers, sad
09:27:09 <copumpkin> stoop: have you posted a link to it in proggit/coding?
09:27:18 <jmcarthur_work> there shall be more if we introduce a lot of activity
09:27:23 <Vulpyne> > let mulInt = foldl' (*) 1 in length . show $ mulInt [1..10000]
09:27:24 <lambdabot>   35660
09:27:27 <stoop> copumpkin, no, I'm not sure that's a good idea, yet.
09:27:41 <jmcarthur_work> i think it's a good idea
09:27:42 * hackagebot upload: stateref 0.3 - Abstraction for things that work like IORef. (JamesCook)
09:27:50 <stoop> jmcarthur_work, have you seen /r/asm?
09:27:54 <jmcarthur_work> we can always repost if we take off later
09:28:16 <jmcarthur_work> stoop, i have now :)
09:28:16 <copumpkin> omno
09:28:18 <copumpkin> omnom
09:28:25 <stoop> "Excellent guide for writing assembly for FreeBSD", "80x86 Cheatsheet : most common reference summarized in 2 pages", etc...
09:28:42 <copumpkin> so you're trying to keep that shit out?
09:28:43 <stoop> If you guys would like that in /r/systems, then posting is a good idea.
09:29:26 <stoop> copumpkin, personally, yes. Personally, I would like posts to peer-reviewed work or more quantitative/formal analysis.
09:29:45 <jmcarthur_work> could just moderate heavily
09:30:03 <jmcarthur_work> as long as that is in the description
09:30:04 <stoop> copumpkin, not some heavily opinionated blog entry written by an overzealous college student.
09:30:08 <stoop> jmcarthur_work, ok.
09:30:10 <copumpkin> damn!
09:30:20 * copumpkin was just preparing an opinionated blog entry
09:30:29 <copumpkin> to submit to /r/systems
09:30:31 <stoop> copumpkin, haha
09:31:15 <stoop> jmcarthur_work, if you would like to post to proggit, then, please do.
09:31:26 <quicksilver> it sounds suspiciously like stoop is asking for reasoned, serious discussion on the internet
09:31:35 <quicksilver> stoop: what kind of ridiculous idea is that?
09:31:36 <copumpkin> damn
09:31:43 * hackagebot upload: priority-queue 0.2 - Simple implementation of a priority queue. (JamesCook)
09:33:49 * hackagebot upload: random-fu 0.0.3 - Random number generation (JamesCook)
09:35:32 <stoop> jmcarthur_work, we just need to decide on a description.
09:39:22 * pumpkin coughs
09:39:26 <pumpkin> *cough*
09:39:36 <Adamant> hi
09:39:52 <stoop> pumpkin, are you alright?
09:41:10 <quicksilver> this is his secret, serious discussion identity
09:41:19 <quicksilver> not to be confused with the opinionated blogger who was hear earlier.
09:41:19 <stoop> haha
09:41:53 <pumpkin> lol
09:42:04 <pumpkin> I thought I might have a @tell awaiting me
09:42:24 <shambler> ;)
09:42:35 <pumpkin> but nope :)
09:42:41 <copumpkin> at least I got rid of the squatter
09:42:56 <pastah> @src quotRem
09:42:57 <lambdabot> Source not found. Where did you learn to type?
09:47:40 <medfly> @src quoteRm
09:47:40 <lambdabot> Source not found. Just try something else.
09:47:42 <medfly> @src quoteRem
09:47:43 <lambdabot> Source not found. stty: unknown mode: doofus
09:48:04 <Vulpyne> I like that one.
09:48:48 <doublethink_work> omg
09:48:55 <doublethink_work> copumpkin: but nobody reversed your arrows!
09:48:57 <doublethink_work> YOU CAN'T DO THAT
09:48:57 <c_wraith> And as general information @src is very incomplete, since it's only filled in by hand
09:49:02 <copumpkin> lol
09:49:38 <zygoloid> quotRem = curry (uncurry quot &&& uncurry rem)
09:50:52 <c_wraith> heh.  Is that the actual implementation ghc uses?
09:51:04 <BMeph> hECK, NO. :)
09:51:13 <c_wraith> because I thought the point of having it be a single operation was that you only needed to do the division once. :)
09:51:25 <BMeph> quotRem = liftM2 (,) quot rem
09:51:28 <doublethink_work> stoop: oo, nice reddit. more articles would be nice, I might have some sitting on my computer at home
09:51:31 * doublethink_work subscribes
09:52:24 <zygoloid> nah, ghc uses: quotRem a b | a < 0 = (c - b, d + 1) | otherwise = (c, d) where (c, d) = a `divMod` b  ;-)
09:52:24 <BMeph> (Also not the way it's done, but more familiar, somewhat)
09:52:57 <BMeph> zygloid: Wow, you're on a roll for libel today... ;)
09:53:05 <zygoloid> hehe :)
09:53:25 <BMeph> Er, *zygoloid :)
09:53:27 <leimy> Woohoo!
09:53:36 <copumpkin> leimy: yay!
09:53:44 * leimy has a phone interview with Amazon regarding maybe going to work with them on their AWS stuff.
09:53:45 <zygoloid> though i think it's more slander in the absence of a publisher
09:54:14 <copumpkin> leimy: congratulations!
09:54:32 <BMeph> zygoloid: #haskell is logged, so "Congratulations! You're a slanderer AND a libeller!" ;p
09:54:35 <leimy> thanks... hopefully it goes better than my first google interview (the people I know who worked there had to interview like 5 or 6 times)
09:55:20 <BMeph> leimy: Well done with the foot-in-the-door, and all. :)
09:55:28 <leimy> Yes thank you!
09:55:43 <leimy> They're mostly Java and C++, but maybe I can bring them over from the dark side... :-)
09:56:12 <BMeph> leimy: Hit 'em in the weak spot; use Scala! ;)
09:56:30 <leimy> BMeph: That's an excellent gateway drug
09:56:41 <BMeph> leimy: :)
09:56:55 <leimy> For me it was ANSI Common Lisp
09:56:57 <leimy> and then Scheme
09:57:01 <leimy> Then Haskell
09:57:06 <leimy> then erlang.
09:57:11 <leimy> back to haskell :-)
09:58:00 <leimy> I need to look into Deepseq though and a few other things.
09:58:22 <leimy> Stuff like running loops around System.timeout consuming heap space when the timeout doesn't occur really weirds me out.
09:58:44 <leimy> Lazy by default is sort of kicking my arse.
10:00:48 <BMeph> leimy: I like lazy by default, if only because it's a more obvious "this is a default; you can change it if you want to" style. I distrust the whole "you can make it lazy by returning it in a function" crowd. Maybe because that crowd doesn't seem comfortable with functions in the first place. ;)
10:01:58 <chrisdone> leimy: yeah. my google phone interview went rubbish
10:02:34 <stoop> chrisdone, why? What kinds of things were they asking?
10:03:30 <chrisdone> stoop: a google head hunter saw me chatting in ##c when I was about 18 and assumed I knew anything about computer science. I didn't. their CS questions were effective. I didn't enjoy it =)
10:04:01 <chrisdone> stoop: "how would you sort a million 32-bit integers?"
10:04:17 <chrisdone> (in 2MB of memory)
10:04:20 <sproingie> chrisdone: i'd ask if they were mostly sorted or random
10:04:39 <sproingie> with only 2 meg, i would say in place radix sort
10:04:56 <int-e> 2 MB isn't enough to hold that data
10:05:06 <int-e> (without tricks)
10:05:09 <jmcarthur_work> exactly
10:05:11 <copumpkin> mmm tricks
10:05:24 <stoop> copumpkin turns tricks.
10:05:32 <copumpkin> I do indeed
10:05:38 <scree> wasn't that the question obama was asked?
10:05:45 <chrisdone> yeah
10:05:47 <jmcarthur_work> not bubble sort
10:05:47 <sproingie> google's recruiters cast a wide net on irc.  i had one approach me in #python
10:05:57 <stoop> sproingie, how long ago was this?
10:06:03 <sproingie> discovered that was SOP for pretty much every regular in #python
10:06:13 <sproingie> stoop: i dunno, maybe a year ago?
10:06:14 <stoop> I've only been asked by friends @google to submit my resume.
10:06:23 <sproingie> well that's a much better way in
10:06:31 <stoop> Actually, I was e-mailed by a recruiter freshman year.
10:06:49 * stoop has no idea what he would do at Google
10:06:54 <copumpkin> I'm guessing not many google recruiters hang out in here ;)
10:07:00 <nothingmuch>  
10:07:04 <tromp_> i'd hang out in the sauna
10:07:04 <sproingie> i can't really fault them, they need talent and they're mining a potentially rich pool of it
10:07:16 <stoop> It seems many of their great developers are expendable.
10:07:24 <chrisdone> I'm glad the interview failed. I'm not smart enough to work at somewhere like Google, unless I worked in the caffeteria or something
10:07:40 <sproingie> naw you need a PhD to serve sloppy joes there
10:07:44 <copumpkin> lol
10:07:46 <chrisdone> =(
10:07:53 <scree> worrying to think one of us may not be all they seem...
10:07:56 <stoop> My friend has only a BS and he is a senior software engineer @Google.
10:08:04 <stoop> chrisdone, don't underestimate yourself.
10:08:07 <copumpkin> stoop: is he good at BS?
10:08:11 <stoop> chrisdone, Google has a lot of idiots.
10:08:17 <shambler> lol
10:08:17 <stoop> copumpkin, not at all.
10:08:20 <sproingie> every company has a lot of idiots
10:08:26 <sproingie> every large one anyway
10:08:29 <shambler> every nig company
10:08:31 <chrisdone> sproingie: I could be the guy who shouts motivational chants to the guy who serves sloppy joes
10:08:32 <shambler> big
10:08:37 <stoop> copumpkin, very shy/anti-social nerd kind of guy. He gets work done. :-)
10:08:43 <copumpkin> :)
10:08:49 <shambler> small and successfull companies can't afford to hold idiots
10:08:54 <sproingie> galois probably has no idiots
10:08:59 <edwardk> I know some incredibly smart people at google, and I happen to know some er.. not so smart people at Google. Their hiring process isn't perfect. ;)
10:09:13 <medfly> I think it's better than some
10:09:17 <stoop> Yes.
10:09:26 <scree> as long as their firing process is ok
10:09:28 <medfly> like, the ones that go like "did you lie well enough on your CV? you're in!"
10:09:34 <stoop> Apple had an interesting interview process.
10:09:42 <chrisdone> stoop: what was that like?
10:09:47 <stoop> 6 hours.
10:09:53 <alt-nick> yeah, I'm interested in hearing about Apple's process as well
10:09:54 <shambler> oh my
10:10:02 <sproingie> i've interviewed six hours for an internal transfer.  that's not unusual
10:10:03 <stoop> My flight was late, so I missed the connecting flight. I stepped into it with 0 sleep.
10:10:03 <shambler> they take you to the disney land?
10:10:23 <sproingie> multi-day interviews are grueling
10:10:26 <stoop> I did well except with the author of spotlight, he was grilling me and I wasn't really taking it.
10:10:35 <medfly> multi-day?
10:10:40 <edwardk> medfly: i think the haphazard gauntlet they run people through was a much better filter early on. now that they have started to cheap out on some of the extras and are seen as a little less of a geek Nirvana, the fact that the founders still find time to review resumes is becoming more and more of a bottleneck than a quirky boon
10:10:41 <medfly> do they let you sleep at the place?
10:10:42 <stoop> The team I was interviewing for was run by an asshole, however.
10:10:46 <danderson> bah, I want a maybe monad in python
10:10:48 <shambler> medfly, with rest ofc ;)
10:10:50 <sproingie> yeah where they have you interview again the next day with different people
10:10:51 <stoop> He was pretty clueless and very arrogant.
10:11:00 <stoop> This was CoreOS, BTW.
10:11:14 <sproingie> stoop: well at least you discovered that in the interview
10:11:20 <stoop> Anyways, he asked me to write a program to print a triangle out to the screen in a recursive manner.
10:11:33 <medfly> lol, my sister does that for her programming homework.
10:11:37 <sproingie> i love doing the "turn the interview around" bit, anyone even slightly techie loves talking about themselves
10:11:46 <stoop> I did it, apparently it was supposed to be a "trick question" and "impossible without modifying the specifications of the problem".
10:11:51 <medfly> sproingie, really?
10:11:57 <stoop> http://carte.repnop.org/etc/triangle.c
10:11:59 <edwardk> stoop: tail recursion ftw?
10:12:18 <edwardk> ah
10:12:42 <medfly> my current employer sure can speak a lot
10:12:46 <medfly> luckily, he's a nerd...
10:12:47 <chrisdone> sproingie: yeah I do that. takes the pressure off to ask the interviewer questions, if they let you
10:12:48 <sproingie> medfly: yah, tho i suck at doing that in real life so i'm not actualyl good at it in interviews
10:12:51 <leimy> Yeah the google interview questions were amazing.
10:12:55 <sproingie> medfly: when it works, it works great
10:13:02 <stoop> Microsoft was the best.
10:13:03 <leimy> Well for me considering I'd not interviewed anywhere in nearly a decade
10:13:07 <leimy> I was kind of nervous :-)
10:13:09 <stoop> In terms of the interview process...
10:13:13 <leimy> yeah?
10:13:15 <stoop> The chief architect of CLI was interviewing me, in fact.
10:13:20 <edwardk> why return the size of the triangle from triangle()?
10:13:23 <leimy> stoop: you working there now
10:13:24 <leimy> ?
10:13:44 <stoop> He was a really nice guy, knowledgeable.
10:13:48 <sproingie> i've been in the same company for about six years now, longest i've ever been in one place
10:13:49 <stoop> leimy, no, I'm still a university student.
10:13:53 <leimy> ah
10:13:55 <sproingie> longest i've ever lived in one place come to think of it
10:14:06 <stoop> leimy, I do well in these interviews, though I mostly do them for the sake of doing them.
10:14:08 <medfly> that's unusual.
10:14:13 <leimy> sproingie: I used to move every 7 years as long as I can remember
10:14:22 <chrisdone> sproingie: how... "monadic" of you
10:14:24 <sproingie> about every 4-5 years for me
10:14:25 <leimy> stoop: it's definitely good experience.
10:14:26 <stoop> leimy, in order to note standards of industry and get an idea before-hand what a company is like.
10:14:29 <sproingie> chrisdone: *groan*
10:14:36 <chrisdone> :D
10:14:37 <copumpkin> lol
10:14:41 <stoop> leimy, yes. Microsoft interview was fun.
10:15:03 <edwardk> stoop: speaking of which, when do you escape your undergrad?
10:15:04 <leimy> Well people recommend you interview for the place you don't want to work so badly first
10:15:07 <stoop> Fortunately, once I graduate, I can actually accept offers. :-P
10:15:11 * kwos had a seriously funny interview lately at goldman sachs
10:15:12 <leimy> I don't think there's that luxury these days :)
10:15:15 <medfly> the only place I was interviewed for was a tech support thing at an ISP a while back, 3 hours of tests :|
10:15:19 <stoop> edwardk, hopefully, this summer.
10:15:22 <kwos> why people ask these silly puzzles these days?
10:15:25 <sproingie> thinking of moving again.  san francisco is nice but i miss actually having rain once in a while
10:15:33 <medfly> kwos, because many people who claim to be able to program cannot.
10:15:36 <sproingie> maybe portland
10:15:41 <chrisdone> kwos: what was your interview?
10:15:47 <medfly> kwos, at least, that's what I hear. think of them as a good thing.
10:15:52 <copumpkin> sproingie: feel free to come over to the northeast and I'll take SF from you
10:15:58 <sproingie> vancouver would be nice but i doubt i could manage the changing countries thing
10:16:03 <kwos> medfly: funny thing was that the interviewer run out of puzzles - she didn't know any that I didn't know
10:16:15 <stoop> edwardk, I've always wondered, where do you work? What kind of work do you do? You have really good balance between breadth and depth.
10:16:19 <sproingie> copumpkin: used to live in rochester ny, that was enough for me.  every time i go back it's only gotten more depressing.
10:16:21 <chrisdone> kwos: haha
10:16:25 <medfly> changing countries isn't so bad
10:16:35 * medfly hopes to do that
10:16:36 <sproingie> medfly: it's just difficult
10:16:36 <copumpkin> stoop: he's a secret agent!
10:16:41 <sproingie> especially without a college degree
10:16:47 <danderson> kwos: which company was this?
10:16:51 <kwos> the best bit of conversation: "You've got 100 doors" and I stopped her there: "Perfect square!"
10:16:52 <Vulpyne> Watch out for pigeons.
10:16:55 <PeakerWork> stoop: Microsoft's design mistakes in C#/etc make me seem the .NET guys (esp. chief architects) aren't that knowledgable...
10:17:09 <medfly> I only did that as a kid though
10:17:10 <kwos> "Yes, that's the correct answer for the question I was about to ask" ;-)
10:17:11 <sproingie> PeakerWork: anders helsberg is a sharp cookie
10:17:19 <int-e> right. perfect square. odd number of divisors. fun :)
10:17:36 <edwardk> I work for SM&A, as a defense consultant, basically we write software that helps people figure out where their billion dollar government contract is on track and what course of action they should take to correct its course where it isn't, among other things
10:17:37 <kwos> yeah, classic
10:17:52 <edwardk> in general i get paid to be able to come in and solve business problems with technical solutions
10:17:59 <stoop> Ok.
10:18:03 <sproingie> "every even number greater than two is the sum of two primes.  prove it."
10:18:10 <sproingie> there's a good interview question, right? ;)
10:18:16 <shambler> :S
10:18:16 <copumpkin> sproingie: damn right
10:18:20 <kwos> sproingie: I've got a really good one
10:18:27 <medfly> kwos, they didn't expect the fake programmer to memorise all those problems!
10:18:29 <Guest13125> If I was doing an IO program that asked for an integer and then another one and added them together and displayed a value and some text around it like "the sum was " ++ value what should that definition be? myfunc :: IO String ?
10:18:38 * hackagebot upload: event-monad 0.0.2.0 - Event-graph simulation monad transformer (JamesCook)
10:18:39 <kwos> sproingie: you're plaing the following game: I write two numbers on two pieces of paper and put them face down on the table
10:18:53 <copumpkin> @quote primes
10:18:54 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
10:18:54 <sproingie> copumpkin: actually it's not too bad even seriously, anyone who responds with "if i do, where do i pick up my nobel" knows a little something about the question
10:18:57 <copumpkin> @quote primes
10:18:57 <lambdabot> sigfpe says: It's like deciding that the prime numbers bigger than 20 are interesting for some reason, and then choosing to name them "the primes".
10:19:02 <copumpkin> @quote primes
10:19:03 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
10:19:06 <copumpkin> meh
10:19:11 <kwos> you choose one piece and look at the number, then you can either keep it or switch to the other piece
10:19:16 <Vulpyne> guest: It's displaying the number to the screen, not returning it to another function for later use?
10:19:30 <quicksilver> edwardk: is  not natural law that billion dollar government contracts are off track from day one?
10:19:33 <sproingie> kwos: monty hall problem?
10:19:33 <kwos> your goal is to get the higher number; we're plaing many times; design a strategy that will give you more than 50% prob. of winning on average
10:19:39 <copumpkin> ***king hell, lambdabot forgot all my quotes
10:19:51 <quicksilver> @quote copumpkin
10:19:52 <lambdabot> copumpkin says: [about learning Haskell compared to other languages] I learned X in Y time, but Z is taking much longer. Z sucks!
10:19:53 <kwos> sproingie: not really
10:20:10 <MoALTz> heh
10:20:16 <edwardk> quicksilver: actually what i think is interesting about them is that about 15% of the way through them you can get a pretty good estimate about how well they will be performing at close of contract.
10:20:27 <chrisdone> kwos: that not a rephrasal of choosing the doors?
10:20:38 <int-e> kwos: yeah, the trick is to let the probability of switching depend on the value you see, so you're more likely to switch away from the lower than from the higher number.
10:20:38 <sproingie> it's not monty hall if there's only two choices
10:20:46 <medfly> sproingie, fields medal
10:20:51 <sproingie> that show would lose a bundle if there were only two doors :)
10:21:05 <medfly> seriously guys, wtf? I thought those interview questions are to weed out fakers
10:21:15 <kwos> oh, these numbers on paper are different
10:21:31 <kwos> that's one more constraint, but otherwise I'm free to choose any numbers I want
10:21:35 <medfly> that just wrote things that they aren't
10:22:03 <ainirtnec> @quote lambdabot
10:22:03 <copumpkin> when in doubt, smile at the interviewer
10:22:04 <lambdabot> lambdabot says: I know nothing about love.
10:22:04 <sproingie> medfly: i suspect you'd get a pile of prizes if you solved goldbach
10:22:07 <danderson> medfly: most interviews start with a softball question to weed out the bullshitters with faked resumes
10:22:12 <kwos> medfly: nope, people are serious with this stuff
10:22:24 <danderson> but these are just stupid.
10:22:26 <medfly> er, interview questions, not these
10:22:35 <edwardk> copumpkin: but not for so long that it comes across as creepy
10:22:35 <medfly> they damn should.
10:22:37 <kwos> danderson: some are better than others, yes
10:22:44 <sproingie> "Low Prices on Goldbach conjecture Free 2-Day Shipping w/ Amazon Prime"
10:22:46 <danderson> the only data they provide is how much time $person has spent on puzzle sites on the internet :)
10:22:56 <copumpkin> edwardk: oh damn, that's what I've been doing wrong!
10:22:57 <danderson> omg, I have amazon prime!
10:23:05 <kwos> danderson: some prbability questions are nice
10:23:06 * danderson orders a dozen Goldbach conjectures
10:23:08 <copumpkin> ah well, next time
10:23:22 * sproingie orders 7 + 5 goldbach conjectures
10:23:23 <copumpkin> extra points if you manage to sex your interviewer though
10:23:23 <kwos> or some puzzles, say the one with muddy children
10:23:25 <int-e> a job interview costs time. a puzzle is something you can ask quickly that will weed out more bad programmers than good programmers. in the end it's statistics.
10:23:34 <kwos> which is really thread synchronization problem
10:23:36 <danderson> kwos: stuff with actual probability/stats are good, because those are useful for a software job
10:23:42 <chrisdone> I hate puzzles
10:23:49 <int-e> hmm, muddy children, I don't know that one
10:23:50 <chrisdone> they stop me getting anything real done
10:23:51 <danderson> but I've even seen questions that rely on wordplay
10:23:57 <tromp_> i love puzzles
10:24:02 <danderson> which is just stupid
10:24:04 <chrisdone> like eating
10:24:04 <sproingie> my favorite is "why are manhole covers round"
10:24:12 <sproingie> the correct answer is "because manholes are round"
10:24:16 <copumpkin> lol
10:24:17 <danderson> sproingie: so that ninja turtles can get through faster
10:24:23 <medfly> I have a better answer :-(
10:24:24 <BONUS> i like that one
10:24:25 <danderson> that's my answer if I ever get that question
10:24:33 <chrisdone> is that a trick question like Petals Around the Rose?
10:24:36 <BONUS> and yeah that's the only correct answer haha
10:24:52 <copumpkin> http://manhole.com/
10:24:52 <chrisdone> just to see how much reasoning someone can do?
10:24:57 <kwos> int-e: it's something with children that had mud on their face that are lined up by their father and they don't know whether they are muddy or not and he asks them in turn: do you have mud on your face? first one says I don't know, second says I don't know, ..., nth one says yes
10:24:58 <danderson> (a friend got asked that question at an interview where he was on minus sleep time, and he didn't want the job anyway :)
10:25:00 <sproingie> copumpkin: i am so not going there
10:25:03 <kwos> int-e: how is that possible?
10:25:04 <int-e> kwos: Oh. I don't know /that/ version of that puzzle.
10:25:05 <copumpkin> sproingie: you'd be surprised
10:25:16 <danderson> sproingie: surprisingly, it's SFW
10:25:23 <kwos> int-e: yeah, there are few versions circulating, and it's a pretty good one
10:25:28 <danderson> not terribly interesting, but there you go
10:25:30 <sproingie> actually i work in anti spam, it doesn't matter how much NSFW stuff i have at work
10:25:32 <medfly> I think a cylinder is a great shape for the purposes of a manhole, and that's why they're round.
10:25:37 <int-e> kwos: there's a monastary version
10:25:40 <sproingie> my coworker next to me looks at images in spam all day
10:25:52 <medfly> e.g. handling explosions, not taking up too much spam
10:25:53 <Cale> It's really because it's a convenient shape of uniform diameter. If manholes/manhole covers were square, it would be possible for the cover to fall down the manhole.
10:25:57 <kwos> int-e: and the one with smurfs ;-)
10:26:10 <copumpkin> danderson: what I wonder is how friendfinder decided manhole.com would be a worthy domain to purchase
10:26:17 <medfly> I guess that kind of tells you t he type of person someone is
10:26:23 <danderson> actually, the manhole question is first and foremost based on an incorrect assumption
10:26:25 <copumpkin> it seems like an excellent name for a gay porn site
10:26:27 <sproingie> Cale: it's because manholes are a large diameter pipe vertically sunk
10:26:32 <danderson> I see as many square manholes as I see round ones
10:26:32 <kwos> well, if you know those puzzles then you must like puzzles
10:26:33 <int-e> kwos: and there's an unsynchronised version with three wise men :)
10:26:33 <sproingie> and pipes tend to be round
10:26:39 <danderson> thus, the correct answer is "they're not."
10:26:41 <kwos> if you like puzzles then you must have logical mind
10:26:49 <danderson> or, in a prolog interview, "No."
10:26:51 <byorgey> Cale: are there any other uniform-diameter shapes?
10:26:55 <medfly> I didn't see a manhole in a lot of time.
10:27:00 <kwos> in some vague sense it might be more useful than "tell me something about yourself"
10:27:04 <chrisdone> I like the MU puzzle. anyone know that?
10:27:15 <ainirtnec> Does a triangle work?
10:27:18 <kwos> chrisdone: nope
10:27:19 <chrisdone> http://en.wikipedia.org/wiki/MU_puzzle
10:27:20 <medfly> kwos, it's funny how after a while, everyone knows the correct answer for some questions.
10:27:23 <sproingie> rectangular ones tend to use a big lip, or are on hinges
10:27:24 <Cale> byorgey: sure. Some british coins use a different shape of uniform diameter.
10:27:36 <medfly> kwos, like here they have this common question in interviews, "name one bad characteristic of yours"
10:27:37 <kwos> medfly: like my last interview
10:27:39 <byorgey> ah!
10:27:44 <byorgey> those heptagonal ones
10:27:46 <byorgey> neat
10:27:47 <medfly> it's so repetitive that people know what to answer, what to do, etc.
10:27:53 <chrisdone> yeah, 20p and 50p
10:28:19 <sproingie> medfly: "i stalk, murder, butcher, and eat interviewers"
10:28:35 <kwos> I had this nice one the other day: rolling a die and get award in dollars, 1 dollar for each spot, so six gives you six dollars and so on
10:28:44 <chrisdone> "I stalk, murder and eat with butchers"
10:28:53 <kwos> if you don't like the first result you can re-roll and if you don't like the second you re-roll
10:28:54 <shambler> "I realy don;t like to answer dumb questions"
10:28:59 <Cale> byorgey: The reason is to give vending machines a basis to tell between them accurately.
10:29:00 <medfly> the correct answer is something like "I always stay late at work to finish up something, and I don't spend enough time with my family"
10:29:34 <shambler> but they now this is a lie
10:29:36 <danderson> more generically, take something good for the company and formulate it as a big personal problem
10:29:46 <sproingie> medfly: it's really a question that tells you more about the asker, and you make the answer fit what they want to hear
10:29:52 <ainirtnec> Is it possible for an odd-number sided regular polygon shaped manhole cover to fall into its corresponding manhole?
10:30:08 <sproingie> asking that hackneyed question at all tends to mean they want to hear that BS answer
10:30:19 <medfly> ainirtnec, it can be too small.
10:30:28 <copumpkin> lol
10:30:39 <medfly> I suggest "of the same perimeter", then no.
10:30:41 <sproingie> they have a constant diameter, so no
10:30:56 <medfly> in that case, it doesn't get much better than round.
10:30:56 <ben0x539> Just make the cover way larger than the hole is, and add a correspondingly-sized depression in the street level so nobody notices
10:30:59 <danderson> sproingie: honestly, in an interview, if I ever asked that, I'd want the candidate to answer something non-bullshitty, or to just call me out on the stupidity of the question
10:31:15 <Cale> ainirtnec: yes, but you can bulge the sides so that it is no longer possible.
10:31:22 <danderson> people who read "100 interview tips and tricks to ace it" and such annoy me :)
10:31:39 <danderson> (at least if applied transparently - if they successfully fool me, more power to them)
10:31:45 <kwos> danderson: the funny thing is that I know all these puzzles from the interviews over the years ;-)
10:31:55 <sproingie> my honest answer i give is that i tend to monotask
10:31:59 <danderson> kwos: that's actually more sad than funny
10:32:03 <kwos> danderson: it's just that interviewers are not creative enough anymore - just re-use stuff
10:32:05 <sproingie> if they can't handle that, i didn't want to work there anyway
10:32:14 <Cale> ainirtnec: by using circular arcs whose centre is the vertex opposite any given edge.
10:32:17 <jmcarthur_work> "I just... get too caught up in my work sometimes!"
10:32:22 <medfly> any regular polygon of the same perimeter cannot fall into a round hole.
10:32:27 <kwos> danderson: why sad?
10:32:50 <ainirtnec> Hmm.
10:33:00 <danderson> kwos: sad for the company if it's unaware that their evaluation of talent rests entirely on being able to answer trick questions
10:33:02 <ainirtnec> medfly, a square certainly can.
10:33:11 <medfly> maybe it can. I dunno.
10:33:12 <danderson> sad for the candidate who has to either go along with the bullshit or not get hired
10:33:14 <medfly> I don't even care :P
10:33:15 <ainirtnec> medfly, a hexagon can as well.
10:33:15 <sproingie> medfly: i think it has to have an odd number of vertices
10:33:19 <danderson> (or find the good places to work)
10:33:22 <kwos> wasn't it microsoft who started this trend originally asking these sorts of questions, giving birth to the whole ecosystem of books and interview tips websites and so on?
10:33:32 <copumpkin> this seems #haskell-blahish
10:33:36 <medfly> I hate maths and even more so, I hate talking about it in English.
10:33:43 <jmcarthur_work> best interview question: "Just go ahead and tell me what you think I want to hear, then we can get on with it."
10:33:43 <danderson> Microsoft started with something more interesting than that iirc
10:33:52 <danderson> questions like "how many gas stations are there in California?"
10:34:02 <sproingie> "lots"
10:34:12 <danderson> which were designed to see how/if a candidate can just start thinking about a large badly specified problem
10:34:12 <copumpkin> "if you give me google I'll tell you"
10:34:13 <kwos> oh, the back-of-the-envelope calculation kind of questions
10:34:15 <nvoorhies> MS also was famous for asking the manhole question too
10:34:18 <danderson> or if they just panic and dump core
10:34:26 <medfly> wtf is that manhole question? it's bullshit.
10:34:28 <int-e> copumpkin: I assume you have google. tell me :)
10:34:34 <sproingie> i do get asked to approximate things that have such a wild probability of varying that i refuse to answer
10:34:43 <kwos> one of the dumbest questions: "here's a ball; analyze it" ;-)
10:34:52 <danderson> bwahahahah
10:34:59 <danderson> I'm all over that question
10:35:02 <kwos> (at this point the interviewer gives you a metal ball, or something)
10:35:03 * danderson looks up his interview schedule
10:35:14 <sproingie> if they want that in an interview, i'll say "i'd have to say probably over ten thousand, and claiming to know more would just be completely dishonest"
10:35:14 <nvoorhies> at this point the interviewer drops his pants
10:35:17 <ainirtnec> kwos, did you throw it back at the interviewer? :)
10:35:36 <medfly> kwos, did you actually get it?
10:35:41 <kwos> ainirtnec: I never got that one, but I guess I would do that
10:35:42 <nvoorhies> I had a coworker who had an interviewee threaten him with a bomb
10:35:44 <kwos> medfly: my former manager did
10:35:51 <medfly> jesus.
10:35:58 <medfly> I'm glad I got this job without an interview.
10:36:04 <kwos> hehe
10:36:11 <medfly> I used to kind of fear interviews, but I suck
10:36:12 <danderson> medfly: likewise.
10:36:12 <kwos> it's always better to rely on good old personal connections
10:36:18 <shambler> nvoorhies, wait what?
10:36:18 <Cale> GOOOOOOOODNIIIIIIIIGHT-a-ding-ding-ding-ding-ding!
10:36:26 <danderson> Cale: exactly!
10:36:29 <medfly> is Cale going to bed?
10:36:35 <dilinger> interviews can be fun
10:36:36 <Cale> medfly: No
10:36:38 <int-e> here's a ball. Cut it into 5 pieces and reassemble to make two balls of equal size.
10:36:40 <danderson> medfly: he's quoting Monty Python's silly interview sketch
10:36:48 <shambler> int-e, lol
10:36:49 <nvoorhies> The guy started panicking when the questions were too hard, then just told him "I have a bomb in my briefcase. If you don't hire me I will set it off"
10:36:49 <medfly> Cale, how pathetic of you.
10:36:49 <danderson> which is exactly what kwos is talking about :)
10:36:50 <kwos> int-e: awesome ;-)
10:36:50 <dilinger> the ones where they take you out for lunch and talk about interesting stuff
10:37:18 <ainirtnec> int-e, may I apply non-rigid transformations to it?
10:37:30 <danderson> Cale: one day I'll snap and interview just like that.
10:37:41 <int-e> ainirtnec: no.
10:37:45 <nvoorhies> And the interviewing person of course tells him that he just lost the job, so the guy with the briefcase opens it, flicks some switch, there's a beep, then he closes the case and sprints out the door
10:37:54 <danderson> Candidate says "Hello", reply "Hmmm, really? Oh dear me... *scribble note*"
10:37:56 <copumpkin> int-e: 8721, plus or minus a few ;)
10:37:57 <sproingie> wait i heard this one
10:38:08 * kwos wonders if anyone finds the answer to this probability question that he asked earlier
10:38:09 <medfly> nvoorhies, did it blow up?
10:38:17 <nvoorhies> yeah, ruined the conference room
10:38:25 <shambler> nvoorhies, hahaha
10:38:28 <shambler> no way
10:38:31 <Cale> medfly: http://www.youtube.com/watch?v=zP0sqRMzkwo&feature=related
10:38:34 <sproingie> no but the boss needed a new chair
10:38:38 <medfly> no. british humour sucks.
10:38:45 <nvoorhies> coworker followed the guy shouting "bomb bomb bomb" and a minute later it went "Foomp"
10:38:46 <kwos> medfly: no it does not!
10:38:59 <kwos> What is yellow and writes poetry?
10:39:01 <nvoorhies> They didn't end up hiring that engineer.
10:39:10 <kwos> A ballpoint banana!
10:39:26 <medfly> nvoorhies, it should be the other way around
10:39:33 <medfly> nvoorhies, the interviewer does this when hiringengineers
10:39:38 <nvoorhies> It should have gome pmoof?
10:39:40 <medfly> nvoorhies, "cna you diffuse that bomb?"
10:39:53 <shambler> :)
10:39:54 <nvoorhies> The "Swordfish" school of interviewing
10:39:54 <sproingie> i dunno, is there anything i can diffuse it in?
10:40:09 <nvoorhies> "Why is this time bomb round"
10:40:10 <ben0x539> Hah
10:40:14 <shambler> :)))
10:40:18 <sproingie> and thus grammar nazi gets blown up
10:43:04 <copumpkin> int-e: so do I get the job???
10:45:09 <FunctorSalad> "<medfly> kwos, like here they have this common question in interviews, "name one bad characteristic of yours"" <-- "where should I start..."
10:45:19 <MoALTz> hehe
10:45:19 <medfly> no no
10:45:32 <Twey> I hear the correct answer is ‘I'm a bit of a perfectionist’
10:45:37 <kwos> I'm a perfectionist ;-)
10:45:38 <kwos> haha
10:45:39 <kwos> yeah
10:45:45 <copumpkin> int-e: actually closer to 8250 now
10:45:49 <MoALTz> that type of answer can backfire
10:45:52 * kwos remembers it from trainspotting ;-)
10:45:55 <int-e> "I'm far too modest."
10:46:00 <Twey> kwos: Stargate
10:46:01 <Twey> int-e: Hahaha
10:46:03 <sproingie> "I shoot heroin."
10:46:10 <shambler> erm
10:46:11 <Twey> sproingie: xD
10:46:11 <shambler> :)
10:46:17 <int-e> copumpkin: I don't know what you're doing.
10:46:17 <Twey> MoALTz: How?
10:46:21 <edwardk> Twey: That one has always worked for me =)
10:46:29 <c_wraith> I think answers to that should be surreal
10:46:29 <Twey> I *am* a perfectionist.
10:46:33 <copumpkin> int-e: you asked me to tell you because I have google :)
10:46:35 <Twey> edwardk: Yeah, same
10:46:36 <c_wraith> "I'm afraid of the color blue"
10:46:41 <Berengal> I actually answered "I think Haskell is a much better language than Java"
10:46:42 <Twey> c_wraith: Hahaha
10:46:42 <sproingie> that's not surreal
10:46:51 <sproingie> unless you're afraid of the *taste* of blue
10:46:54 <Twey> Berengal: That's axiomatic :þ
10:47:03 <Twey> sproingie: Blue actually tastes fairly foul.
10:47:08 <Twey> I swallowed some once.
10:47:15 <Twey> It's not half as bad as gold, though.
10:47:18 <sproingie> rasberry slushee or windex?
10:47:26 <MoALTz> Twey: it's like responding to "tell me your name" with "my first name is james. did you know that there were x king james' in y? also, ..."
10:47:30 <int-e> copumpkin: Ah. Right, sorry, I got distracted. Good job, I'm just afraid we can't really afford qualified people here.
10:47:40 * kwos was asked interesting question about haskell in an interview
10:47:44 <MoALTz> question avoidance can seriously annoy some people
10:47:48 <Twey> MoALTz: No it isn't.
10:47:50 <medfly> Twey, there are a few
10:47:51 <toor_> if iam writing an IO program which ask for ex Ints. how can I add thoose to a list and ask for a new one? Just got into IO and if was a normal function I would have known but so blurry now hehe.
10:47:52 <MoALTz> it is
10:47:59 <Twey> MoALTz: It's a serious flaw, and it's a direct answer to the question.
10:48:02 <copumpkin> int-e: :(
10:48:13 <toor_> then for example when I get a certain int I want to stop and display that list
10:48:15 <Twey> It just happens to be a flaw that also has a positive aspect.
10:48:23 <Berengal> Should I install GHC 6.10 or 6.12?
10:48:25 <Twey> (but, hey, I suppose most probably do)
10:48:32 <kwos> it was something along the lines: "what do you think is the main reason why haskell is not widespread in the industry"
10:48:35 <copumpkin> well at least I'll be prepared when I get asked that in an interview
10:48:37 <sproingie> Berengal: 6.10 for now
10:48:47 <copumpkin> I've always wanted to know how many gas stations there were in california anywya
10:48:47 <Cale> toor_: Use a parameter to that recursive function to maintain the list of ints collected so far
10:48:52 <sproingie> i use 6.12 because i need dynamic linking, static blows up on me
10:48:55 <MoALTz> i'm unconvinced
10:48:56 <Twey> MoALTz: You're in #haskell.  You're telling me you've never missed a deadline because you *had* to put finishing touches on something?  :þ
10:49:15 <Berengal> sproingie: Does much of hackage not work with 6.12?
10:49:18 <MoALTz> i've nearly missed deadlines sure :)
10:49:18 <Twey> kwos: What did you answer?
10:49:40 <MoALTz> however, in my case it's more of a procastination issue...
10:49:47 <sproingie> Berengal: i havent tried much.  i imagine most stuff does.  the current stable version of cabal however does not
10:49:54 <medfly> is it just me or do all programmers have a procrastination issue?
10:49:57 <Twey> MoALTz: You don't count, then.  Go and stand over there in the corner, with the other people who don't count.  :þ
10:49:58 <Cale> toor_: That is, write  collectInts' :: [Int] -> IO [Int]  first, and then apply it to an empty list to get the IO action you're really after
10:50:01 <copumpkin> medfly: I'll tell you later
10:50:03 <Berengal> sproingie: I'm okay with unstable, as long as it's working
10:50:03 <kwos> Twey: I said something about perception of risk associated with haskell (and perception of haskell giving an edge if you're a startup) and industrial support (compilers, supply of programmers, etc)
10:50:12 <medfly> it's like every programmer I know.
10:50:21 <Twey> kwos: Fair enough
10:50:27 <kwos> after many best haskell programmers around are not very much interested in full time jobs in the industry
10:50:29 <Twey> medfly: Well, I keep meaning to fix it, but…
10:50:33 <dcoutts> Berengal: darcs version of Cabal + cabal-install work with ghc 6.12
10:50:34 <kwos> and it's a bit of a problem
10:50:35 <Cale> toor_: Of course, you could also use an IORef, but for something like this, there's no need :)
10:50:42 <medfly> I personally don't think I would like Haskell as much if it were popular
10:50:55 <copumpkin> the libraries are already crusty
10:50:56 <kwos> Twey: in some sense I thought this is what they wanted me to say
10:50:58 <Twey> medfly: No, seriously I don't procrastinate much any more.  I used to be very bad about it, but I'm better now.
10:51:01 <copumpkin> and we're not even popular
10:51:06 <medfly> Twey, what did you do
10:51:08 <toor_> Cale: thanks. but then I would have to give it a [Int] the first time I run the function but then it should ask for new ints and add them to my parameter and list of int which I begun with?
10:51:08 <kwos> Twey: but it's also what I think is a big issue for some companies
10:51:09 <Twey> kwos: Yes, it seems reasonable
10:51:20 <Cale> toor_: When it calls itself
10:51:22 <Berengal> dcoutts: is there no binary/tarball?
10:51:24 <Twey> medfly: I developed a six-month backlog of owed work, then dropped out.
10:51:26 <medfly> Twey, I don't procrastinate in some occasions, but on others I am just as bad as usual :|
10:51:30 <Cale> toor_: actually, that's not even necessary
10:51:31 <dcoutts> Berengal: no
10:51:39 <MoALTz> leaving something in an unfinished or incomplete state feels really bad though. i used to be a perfectionist but procastination has won the war against that (hard to be a perfectionist when you are rushing just to have something ready to hand in..)
10:51:44 <Berengal> dcoutts: Ah, well, I'll just have to get darcs as well then
10:51:49 <medfly> Twey, oh, when I'm pushed against a corner I don't procrastinate any more :)
10:51:56 <dcoutts> Berengal: if you're testing the 6.12RC you're expected to be able to operate darcs :-)
10:51:58 <Twey> medfly: Ah :þ
10:52:08 <medfly> Twey, but that only happened with school so far
10:52:09 <Twey> MoALTz: Perfectionism is more fun than procrastination.
10:52:16 <toor_> Cale I don't have to use the parameter? the function is from an exercise in a book (art of haskell..) http://pastebin.com/m4b07fdfe
10:52:25 <Cale> toor_: You could write something like collectInts :: IO [Int]; collectInts = do x <- readLn; if x == 0 then return [x] else do xs <- collectInts; return (x:xs)
10:52:26 <Berengal> dcoutts: Well, I do, but I'm also on a newly installed system
10:52:30 <medfly> the only time I _could_ work was when I was at least two weeks behind on homework (mind you, it was more than what you think two weeks are)
10:52:30 <MoALTz> agreed
10:52:34 <Berengal> And I'm lazy
10:52:54 <toor_> Cale ah cool I get it
10:53:01 <toor_> Cale thanks alot gonna test it out
10:54:06 <dcoutts> Berengal: you can generate a tarball with sdist
10:55:00 <toor_> is there anyone here that use notepad++ when writing haskell code? I have begun to realize that it adds "hidden" spaces and stuff that mess up the whole indention so I have to use the "show everything" button to delete them where I can see the spaces as ---->.. so if there is anyone using it, is there any setting that can make this not happend?
10:55:10 <Berengal> dcoutts: that assumes I have cabal already, which I don't. Right now I don't even have GHC
10:55:29 <lvh> toor_: sorry, emacs user.
10:55:50 <MoALTz> toor_: disable auto indent? was the easiest way for me to get rid of the problem
10:56:09 <mauke> toor_: those look like tabs
10:56:17 <MoALTz> autoindent in notepad++ is strange (spaces->tabs issue)
10:56:35 <copumpkin> ♺
10:56:54 <toor_> MoALTz ah ok unchecked it now, was set to check as default
10:57:03 <toor_> thanks
10:57:25 <MoALTz> had to ask here too, so no problem :)
10:57:41 <chrisdone> I'm a perfectionist about not being perfect, but sometimes I lapse
10:57:41 <sproingie> toor_: turn off tabs in notepad++, that's the best way
10:58:17 <FunctorSalad> kwos: what was this "100 doors" puzzle with answer "perfect square"?
10:58:20 <lvh> an editor not being able to figure out how to do autoindent properly seems like an excellent reason to find a new editor
10:58:23 <EnglishGent> hello :)
10:58:25 <toor_> sproingie ok thanks for the advice
10:58:32 <chrisdone> good day, gent
10:58:32 <sproingie> notepad++ is all right for looking at code, i'd use emacs+flymake for writing it
10:58:53 <sproingie> i had to make a few tweaks to the flymake wrapper to make it process warnings properly
10:58:56 <FunctorSalad> (not "is there anything special about the number of doors?" I suppose)
10:59:09 <kwos> FunctorSalad: there are 100 in a corridor doors which are initially closed and there's a guy who's going to go down the corridor 100 times
10:59:30 <kwos> he will open every closed door and close every open
10:59:43 <kwos> first time he will do this to all the doors, second every second door and so on
10:59:47 <EnglishGent> hi chrisdone :)
10:59:53 <kwos> which doors will be open after he's finished?
11:00:08 * kwos thinks it's a pretty neat questions
11:00:11 <kwos> *question
11:00:25 <dankna> it's a pretty neat question, certainly
11:00:35 * EnglishGent agrees
11:00:50 * EnglishGent is sure we can write a little program in Haskell to calculate the solution... :)
11:01:35 <chrisdone> I don't know why I read these puzzles when I've got a lot of stuff to do
11:01:36 <heterarchy> no need to write code
11:01:56 <FunctorSalad> hmm it's asking for parity of number of divisors
11:01:58 <toor_> indention is one tricky thing with haskell when you are not used to it i tell you hehe. Maybe uglier with ; and { all over the place but at least it's clear hehe. ghci complains about wrong idention here, http://pastebin.com/m37c5630e  . Looks okey to me
11:02:04 <sproingie> my sneaking suspicion is the primes will be open?
11:02:05 <EnglishGent> btw - speaking of code - how can I tell haskell *not* to load the standard prelude?
11:02:29 <kwos> sproingie: nope
11:02:41 <sproingie> oh well
11:02:51 <FunctorSalad> and for each divisor d of n you have one n/d
11:02:52 <EnglishGent> I'm not sure if they will be open or closed - but, perhaps they are the only ones in some state?
11:03:19 <FunctorSalad> so for a non-square the parity is even
11:03:26 <FunctorSalad> modulo off-by-one-errrors
11:03:31 <ben0x539> toor_: indent the 'else'
11:03:46 <Berengal> EnglishGent: import Prelude (), or {-# LANGUAGE NoImplicitPrelude #-}, depending on what you want
11:03:59 <EnglishGent> ty Berengal :)
11:04:59 <Berengal> EnglishGent: import Prelude() will just not import the names. The other allows you to define your own versions of the functions some sugar desugars to
11:05:49 <toor_> ben0x539 thanks! do you know why tho? I mean if and else should be on the same level of indent? but I get that do should be indent. but I guess that because of do else has to be too
11:06:08 <EnglishGent> that (defining other versions) is what I'd like to
11:06:20 <copumpkin> {-# LANGUAGE NoImplicitPrelude #-}
11:06:21 <chrisdone> NoImplicitPrelude is a good way to learn the Prelude's class hierarchy by reimplementing things like Num, Integral, etc
11:06:22 <ben0x539> toor_: The hint for remembering this is that 'then' and 'else' have to line up with each other, not with 'if'
11:06:27 * EnglishGent can think of ways to generalise some of them - that leaves their type signatures the same
11:06:47 <EnglishGent> hi copumpkin :)
11:06:50 <toor_> ben0x539 oh I see thanks great tip
11:06:52 <geekagen1> or to do things like abelian group and ring in the prelude.
11:07:29 <copumpkin> hi :)
11:09:23 <EnglishGent> yeah - I'd like to do that sort of thing as well geekagen1 - but right now I've got some other ideas I'd like to kick around :)
11:14:34 <Berengal> Dependent types: Yay or nay?
11:14:48 <copumpkin> (yea, not yay)
11:15:06 <Berengal> (I was trying to be punny)
11:16:54 <lvh> EnglishGent: Python, but it works: list(x for x in enumerate((sum(door % i == 0 for i in xrange(1, 100)) + 1) % 2 for door in xrange(100)) if x[1] == 0)
11:21:24 <trofi> code.haskell.org is down for me
11:21:46 <danderson> same. Nullrouted.
11:23:47 <heterarchy> oops
11:27:22 <Blaketh>   [
11:38:29 <heterarchy> hmmm ... what causes a situation like this from cabal: base-4.0.0.0 was excluded because of the top level dependency base -any
11:38:52 <FauxFaux> Classic 6.8 / 6.10 discrepancy.
11:39:17 <heterarchy> ok, should I use 6.12 instead of the ubuntu built in 6.8?
11:39:41 <toor_> what is the easiet way of doing a random number from 0 to 10 in an IO program? doing a guess program
11:40:05 <mauke> :t randomRIO
11:40:06 <lambdabot> forall a. (Random a) => (a, a) -> IO a
11:40:18 <mauke> x <- randomRIO (0, 10) or something
11:41:14 <th0r_> mauke cool thanks
11:41:50 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12415#a12416 <-- Now, how do I convince the type system to give me a scoped type variable in an instance?
11:42:18 <Baughn> ..nm. That works. I'd just forgotten to add the extension. ;_;
11:42:45 <mauke> I bet I can do it without the extension
11:42:51 <Baughn> Go ahead
11:43:06 <Baughn> ..oh. I see.
11:43:42 <mauke> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12415#a12417
11:43:45 <mauke> completely untested
11:44:05 <Baughn> Right.
11:55:39 <trofi> why recommendation is to use camelCase?
11:56:08 <trofi> for what stuff foo_far style is reserved?
11:57:32 <Vulpyne> trofi: Nothing, really.
11:58:05 <Vulpyne> trofi: Even if a function exists in the prelude, you could just redefine it in most cases if you wanted to. (There aren't any that I know of in foo_bar style though.)
11:58:22 <burp> > 10^10^29
11:58:27 <lambdabot>   mueval: ExitFailure 1
11:59:21 * trofi likes mostly_normal_word_spacings moreThanCamelCased
11:59:31 * ben0x539 doesNot
11:59:42 <Cale> > log 10 / log 2
11:59:43 <lambdabot>   3.3219280948873626
12:00:02 <mauke> > logBase 2 10
12:00:03 <lambdabot>   3.3219280948873626
12:00:07 <Cale> 3.32 * 10^29 bits is a lot of storage.
12:00:12 <MoALTz> i like scheme's style, since you don't need to use shift (hello-world)
12:00:21 <Cale> er
12:00:25 <Cale> yeah
12:00:36 <Cale> For a single number anyhow :)
12:00:57 <burp> um yes ;)
12:01:49 <Cale> Maybe if you're trying to store the universe, it's not really going to cut it.
12:03:26 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12420#a12420 <- Will this hopefully existential quantification do what I think it will?
12:04:07 <burp> I read that this is the statistical distance in meter to meet your exact doppelgnger ;)
12:04:20 <burp> (well it's larger than our universe, but still.. ;)
12:04:36 <chrisdone> where's that haskell piespy image?
12:04:54 <Cale> Baughn: That looks like universal quantification to me
12:05:09 <Baughn> Cale: Sure does. That's what this error is telling me too.
12:05:16 <Cale> Baughn: That is, the callbacks field will be required to be a polymorphic function
12:05:29 <Cale> If you want it to be existential, move the forall outside of the constructor
12:05:50 <Cale> data RPCContext = forall a b. ...
12:06:34 <Cale> I'm not sure if the record syntax + existentials stuff is still working or not though. I heard some noise about it being broken.
12:07:39 <Baughn> I get the feeling I'm punching a little above my level right now. Ah well..
12:08:12 <Cale> oh, move the class context too
12:08:26 <Baughn> Did that.
12:08:31 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12420#a12422
12:08:37 <Cale> Not working?
12:08:42 <Baughn> Working, but..
12:08:43 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12423#a12423
12:09:08 <Cale> ah, right
12:09:29 <Baughn> I don't entirely see how pattern-matching would help
12:09:36 <Cale> You can only use the selector functions for fields that don't involve the existentially quantified variables
12:09:36 <Saizan> heh, you can't give a type to callbacks
12:09:40 <Saizan> that's the only problem
12:10:01 <burp> > 3*10^8  * 16*10^9 * 86400*365 :: Double -- meter
12:10:03 <lambdabot>   1.513728e26
12:10:12 <Baughn> That leaves me unable to extract callbacks, though
12:10:17 <Baughn> Unless..
12:10:22 <Saizan> pattern matching will work
12:10:41 <Baughn> Yeah, but then I can't do it by name. :/
12:11:02 <mathijsB> hmh, i'm trying to leanr haskell and im wondering, say I want to iterate over a list or something, and I want to keep an iteration counter.
12:11:02 <Cale> You can write a CPS-style extractor
12:11:07 <mauke> what
12:11:15 <mathijsB> I would do something like someFunc a = someFunc (a + 1)
12:11:15 <Cale> mathijsB: If it's a list, use zip [0..]
12:11:34 <mathijsB> but to use this function now I would always have to type someFunc 1
12:11:34 <mauke> I haven't paid attention, but case x of Rec { foo = bar } -> ...
12:11:39 <mathijsB> is there any way to make the 1 a default argument?
12:11:42 <Cale> > zip [0..] "hello there"
12:11:43 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'t'),(7,'h'),(8,'e'),(9...
12:11:50 <mathijsB> ghci doesnt seem to allow me to do someFunc = someFunc 1
12:11:57 <Cale> mathijsB: You just wrote what looks like an infinite loop to me
12:11:57 <mathijsB> ah
12:12:05 <Baughn> mauke: Ah, right. Thanks. THough that just gave me a new and more exciting error.
12:12:09 <mathijsB> yep i know, but its just a sample of keeping an iteration counter
12:12:23 <mathijsB> but i suppose the idea of doing that is wrong, and that i should use zip to attach an iteration count to the list?
12:12:35 <mauke> mathijsB: you have to use a different name
12:12:37 <Botje> it's not wrong, but zip is just more convenient :)
12:12:41 <mauke> otherFunc = someFunc 1
12:13:00 <Botje> as your knowledge of haskell grows, you'll avoid simple recursion and writer higher-order code
12:13:07 <Cale> Baughn: withCallback :: (forall a b. (Binary a, Binary b) => (a -> IO b) -> c) -> RPCContext -> c
12:13:20 <Baughn> Cale: I only use it once, so now need, really
12:13:20 <Cale> Baughn: or something....
12:13:22 <mathijsB> :)
12:13:25 <Botje> and using zip in combination with foldr or map is a good example of that :)
12:13:33 <Baughn> Cale: Mauke's is good enough. :)
12:13:53 <rasfar> Usually you want to use such a counter inside the function, so I think the zip trick wouldn't help you there?
12:13:58 <Baughn> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12423#a12424 <-- However, this blew up nastily.
12:14:11 <Cale> mathijsB: Using zip is a lot more convenient than maintaining a counter in some recursive function's parameter
12:14:37 <mathijsB> it sounds like that :) the counters gave me a lot of headache :')
12:14:40 <Baughn> Waitaminute..
12:14:52 <Cale> Baughn: So the first two errors are obvious enough.
12:14:57 <Baughn> And fixed.
12:15:05 <Cale> :)
12:15:13 <Baughn> The other two didn't go away, damn my luck. :P
12:15:20 <mathijsB> thanks for the help :)
12:16:50 <Cale> Baughn: It looks like a clash between two places where you might have any type at all, but they need to be the same type, and you don't know that.
12:17:08 <adekoba> is there any way to handle errors (failure to parse) with the binary package aside from using catch which introduces the IO monad?
12:17:12 <Cale> Baughn: Oh, do you have ScopedTypeVariables on?
12:17:18 <Baughn> Naturally
12:17:28 <adekoba> i'd like to be able to handle errors without using IO...
12:17:33 <Baughn> I have a three-line list of extensions on, actually. ^^;
12:17:56 <Baughn> adekoba: Look at the Error/ErrorT classes/transformers
12:18:28 <Cale> adekoba: I think you can use the somewhat lower level interface perhaps.
12:18:39 <Cale> (Get and Put)
12:18:58 <adekoba> Cale: instead of just encode/decode you mean?
12:19:04 <Cale> adekoba: The high-level Binary interface is only really suited to situations where you know that you'll never have a parsing failure.
12:19:05 <Cale> yeah
12:19:15 <adekoba> ahhh this makes sense
12:19:20 <adekoba> thanks very much you two
12:19:25 <Baughn> adekoba: You could use the Serialize package, which is the same thing only strict
12:19:40 <Cale> er, actually
12:19:43 <Baughn> adekoba: Its decode function is :: Maybe a
12:19:51 <Baughn> Well. Either, actually.
12:20:09 <Cale> Yeah, and the Get monad has no capacity for capturing errors either
12:20:27 <Baughn> Serialize's does, and conveniently the same instance source will work with either
12:20:41 <Cale> nice :)
12:20:59 <Baughn> Cale: It's a bit annoying that it uses strict bytestrings, though.
12:21:15 <adekoba> hm, serialize looks interesting. I only need strict bytestrings.
12:22:14 <Baughn> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12425#a12425 <-- Maybe I should just store functions of type ByteString -> ByteString
12:22:27 <Baughn> ..yeah. That'd be a lot easier.
12:23:21 <leimy> Since I have free time now, I should probably get back to that 9P implementation in Haskell.  newsham did a lot of work on it already!
12:26:39 <leimy> Anyone notice Doug Mcllroy posting on Haskell Cafe?
12:29:40 <mreh> how do I apply a list of functions to a single arg?
12:29:47 <mreh> isn't that ap?
12:29:52 <mmorrow> leimy: :p
12:29:55 <mmorrow> leimy: :o
12:29:56 <mmorrow> i meant
12:29:56 <Twey> It's ($), mreh
12:30:03 <Twey> map ($ arg) listOfFunctions
12:30:10 <copumpkin> > sequence [(+1), (*2), (^3)] 5
12:30:11 <lambdabot>   [6,10,125]
12:30:27 <leimy> mmorrow: Nothing like the guy who came up with the idea of the unix pipe showing up on the mailing list you read regularly to make you think you're not wasting time with something :-)
12:30:28 <mmorrow> (doug mcilroy invented unix pipes, among other things)
12:30:30 <Twey> A.K.A. map (`id` arg), A.K.A. map (flip id arg)
12:30:31 <mmorrow> heh
12:30:31 <leimy> yep :-)
12:30:36 <Baughn> The (->) r monad isn't exactly in the prelude though, is it?
12:30:54 <Twey> leimy: O.O
12:31:08 <copumpkin> leimy: yep :)
12:31:08 <Twey> Nice.
12:31:43 <tromp_> > "foo" >>= "bar"
12:31:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> [b]'
12:31:45 <lambdabot>         against inferr...
12:31:48 <doublethink_work> oo yes, I saw Doug's question the other day
12:31:54 <leimy> Yeah I've gotten email from Rob Pike before, but I was asking him a question about one of his books.  I saw Doug's name in my inbox and thought "no way!"
12:31:57 * doublethink_work thought it was awesome to see him on -cafe
12:31:59 <leimy> the I realized it wasn't for me :-)
12:32:14 <tromp_> > "foo" >> "bar"
12:32:15 <lambdabot>   "barbarbar"
12:32:37 <copumpkin> it's sad to say that he's down the hall from me but I've never spoken to him
12:32:50 <copumpkin> beyond "hi"
12:34:07 <leimy> i'd probably just say thanks :-)
12:34:10 <chrisdone> how do you detect whether two lines at any angle overlap?
12:34:12 <leimy> I don't know how many things I've done with pipes :-)
12:34:16 <leimy> but it's a lot.
12:34:33 <Twey> ‘I've crafted more pipelines than you've had hot dinners!’
12:34:41 <Heffalump> chrisdone: if they aren't parallel, they overlap :-) Though presumably you actually mean line segments.
12:35:02 <Twey> copumpkin: ‘He’ as in Doug McIlroy?
12:35:07 <copumpkin> yep
12:35:33 <Twey> copumpkin: Where are you, again?  O.O
12:35:37 * Heffalump went to his talk in Victoria
12:35:38 <edwardk> copumpkin: tell him i really like his compression stuff =)
12:35:50 <copumpkin> dartmouth
12:35:55 <edwardk> copumpkin: and that it is really useful for working directly in a pre-reduced monoidal representation
12:36:13 <copumpkin> edwardk: oh okay, I'll walk up to him, even though he doesn't really know who I am, and tell him that someone else he doesn't know really likes his compression stuff :)
12:36:18 <jlouis> Didn't Doug do generating functions via CSP as well?
12:36:22 <jlouis> I vaguely remember so
12:36:24 <chrisdone> Heffalump: I throw two pencils in a box at random and I want to detect if they have overlapped knowing the coordinates of either end of each pencil. are they line "segments"?
12:36:36 <edwardk> he's done lots of stuff
12:36:36 <Heffalump> chrisdone: yes. Lines go to infinity
12:36:42 <Berengal>  copumpkin: Why not?
12:36:58 <edwardk> chrisdone: yes
12:37:07 <chrisdone> Heffalump: you crazy math people!
12:37:15 <jlouis> Heffalump: and if we define the vanishing point to be the same point for parallel lines :)
12:37:20 <edwardk> copumpkin: just tell him that he is mad popular on the internets. professors love that
12:37:22 <Twey> chrisdone: It's true.  :þ
12:37:33 <jlouis> affine geometry is so cool, heh
12:37:35 <Twey> copumpkin: You could also ask for his autograph.  :þ
12:37:35 <copumpkin> edwardk: ok :D
12:37:55 <edwardk> Heffalump: bah, infinity is just another line (or plane depending on if you are in 2d or 3d). think projectively! =)
12:37:57 <chrisdone> Twey: still crazy
12:38:01 <Berengal> copumpkin: Really, think about how you'd react if that happened to you.
12:38:20 <Heffalump> edwardk: I didn't say it wasn't.
12:38:25 <copumpkin> Berengal: I'd punch whoever it was in the face!
12:38:27 <Heffalump> I just said it's where lines go.
12:38:34 <Heffalump> which it is, projective or not.
12:38:41 <Twey> Wait, what?
12:38:44 <edwardk> copumpkin: yeah. you should bring me his autograph to the next boston haskell user group. ;)
12:38:49 <Berengal> copumpkin: Why? Because you haven't done any compression stuff? :P
12:38:54 <copumpkin> Berengal: yeah :P
12:39:02 <Twey> copumpkin: For saying that you were popular on the Internet?  :þ
12:39:04 <copumpkin> edwardk: damn, I need to get busy then, that's next week!
12:39:20 <copumpkin> Twey: yeah, I hate being popular
12:39:25 * Twey laughs.
12:39:41 <Twey> I guess punching the messenger in the face would be one way of dealing with that problem
12:39:50 <copumpkin> that's my usual solution to things
12:39:54 <Twey> Haha
12:40:00 <Berengal> You might want to reconsider that
12:40:13 <Berengal> Punch them somewhere it's harder to sue for
12:40:16 <mauke> if violence is not the solution to your problem, you're not using enough of it
12:40:17 <edwardk> Twey: yeah, and if the messenger happened to capture that on his web cam or iphone, then you really would wind up popular on the internets. ;)
12:40:18 <copumpkin> I have been told that it isn't the best way to deal with it
12:40:31 <Twey> edwardk: Heheheheh
12:40:53 <copumpkin> hah
12:44:20 <chrisdone> I often search an unsorted collection of objects and realise that I am searching in random order
12:46:25 * BMeph cancals his plans for getting copumpkin's autograph, if he ever winds up in NH...
12:47:48 <ystael> BMeph: there's at least one really good reason to go to NH: http://portsmouthbrewery.com/
12:49:31 <gjl> mauke, that's quote worthy. Did you coin that yourself.
12:49:47 <chrisdone> gjl: common saying
12:49:55 <mauke> gjl: it's common knowledge
12:49:55 <BMeph> ystael: Another one (my reason, actually) is: http://freestateproject.org/
12:50:19 <gjl> ah. Further proof that I'm out of touch with society.
12:51:39 <ystael> BMeph: aw, that little porcupine logo is cute
12:53:18 <chrisdone> :t abs
12:53:19 <lambdabot> forall a. (Num a) => a -> a
12:53:53 <chrisdone> > let diff n = abs . subtract n in 2-5
12:53:54 <lambdabot>   -3
12:53:56 <BMeph> ystael:  :)
12:54:04 <chrisdone> > let diff n = abs . subtract n in diff 2-5
12:54:05 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
12:54:05 <lambdabot>    arising from the literal `5' at <...
12:54:11 <chrisdone> :t subtract
12:54:12 <lambdabot> forall a. (Num a) => a -> a -> a
12:54:22 <chrisdone> > let diff n = abs . subtract n in diff $ 2-5
12:54:23 <lambdabot>   {-3->0;-2->1;-1->2;0->3;1->4;2->5;3->6}
12:54:28 <BMeph> > let diff n = abs . subtract n in diff (2-5)
12:54:28 <chrisdone> okay I give up
12:54:29 <lambdabot>   {-3->0;-2->1;-1->2;0->3;1->4;2->5;3->6}
12:54:56 <chrisdone> what do you call \n -> abs . subtract n, mathematically?
12:55:03 <BMeph> > let diff n = abs . subtract n in diff 2 5
12:55:05 <lambdabot>   3
12:55:29 <ystael> @pl \n -> abs . subtract n
12:55:29 <lambdabot> (abs .) . subtract
12:55:30 <chrisdone> BMeph: woops, big fail
12:55:48 <ystael> chrisdone: ^
12:55:52 <chrisdone> is this called the "absolute difference"?
12:56:39 <rwx> chrisdone, what do you mean 'mathematically'?
12:56:50 * copumpkin is listening to "Venezia e Napoli - Tarantella" by Jorge Bolet, from the album Liszt, The Piano Works Disc 6. 458kbps Apple Lossless (★★★★☆)
12:56:57 <copumpkin> whoops sorry! damn IRC client
12:57:13 <chrisdone> rwx: well, the <what> of 2 and 5 is 3
12:58:22 <chrisdone> n/m
12:58:31 <rwx> chrisdone, as in, the difference?
12:58:47 <rwx> set theoretically...
12:59:07 <chrisdone> rwx: is that what you call it?
12:59:23 <byorgey> chrisdone: "absolute difference" sounds good to me
12:59:33 <chrisdone> rwx: the difference between 2 and 5 is -3, I thought.. wanted another word for absolute value of that
12:59:45 <chrisdone> byorgey: ah, good
12:59:52 <Baughn> chrisdone: Distance
12:59:52 <rwx> chrisdone, the difference is more about distance e.g. say on a number line they are 3 integers apart
12:59:55 <copumpkin> chrisdone: distance?
13:00:08 <byorgey> I thought of distance too, but you don't say "the distance of 2 and 5"
13:00:16 <chrisdone> ah, "distance"
13:00:18 <byorgey> but you could say "the distance between 2 and 5"...
13:00:43 <chrisdone> thanks
13:00:45 <rwx> you can say -3 or +3 if you're "moving" from 2 to 5, or from 5 to 2
13:00:54 <rwx> but just between the two, metaphorically it's distance
13:01:54 <conal> distance is the magnitude of difference.
13:01:55 * hackagebot upload: hesql 0.5 - Haskell's embedded SQL (ChristophBauer)
13:05:20 <EnglishGent> I have a function [x] -> Bool - is there any way of overloading it (perhaps using multi-paramter type classes) so it can also be used where I need an IO [x] -> IO Bool ?
13:06:29 <Heffalump> I think multi-param type classes are the right approach
13:06:30 <mauke> why not use a separate function?
13:06:30 <chrisdone> :t liftM . (>>=)
13:06:31 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m, Monad m1) => m1 a -> m (a -> m1 b) -> m (m1 b)
13:06:34 <dobblego> endojelly, see fmap
13:06:38 <chrisdone> woops
13:06:42 <Heffalump> well, if overloading is reasonable at all, yes
13:06:51 <byorgey> EnglishGent: why not just use fmap?
13:07:02 <EnglishGent> I'm experimenting with some ideas - I know it could be done using liftM or other approaches
13:07:06 <dobblego> @type fmap :: ([x] -> Bool) -> IO [x] -> IO Bool
13:07:07 <lambdabot> forall x. ([x] -> Bool) -> IO [x] -> IO Bool
13:07:10 <magthe> is there a shortcut to refer to a function (which has a name clashing with Prelude) in the current module, or will I have to always write Foo.Bar.Baz.head ?
13:07:17 <dobblego> EnglishGent, fmap == liftM
13:07:20 <mauke> http://pipeline.corante.com/Lemongraph.jpg
13:07:28 <mauke> magthe: you could hide the prelude version
13:07:30 <endojelly> dobblego, what? why?
13:07:34 <endojelly> dobblego, I don't want to see fmap?
13:07:38 <endojelly> dobblego, you can't make me!
13:07:44 <endojelly> I am not comfortable with this.
13:08:05 <EnglishGent> still - what would the type class look like? I've not played with multi-parameter type classes before
13:08:09 <magthe> mauke, yeah, that'll solve some cases... but in the cases where I need Prelude too?
13:08:10 <byorgey> more lemons!
13:08:18 <dobblego> class Functor f where fmap :: (a -> b) -> f a -> f b
13:08:35 <mauke> magthe: then you can use Prelude.foo
13:09:03 <mauke> magthe: or you could simply rename your function
13:09:52 <magthe> mauke: sure, or import Prelude as P.... but if it's the _local_ function I want?  is Foo.Bar.Baz.foo my only option?
13:10:14 <Baughn> "return (return ())" <-- Sometimes my simple, imperative mind spontaneously rebels against haskell. Then I beat it back down.
13:10:21 <mauke> magthe: no, just use another name
13:10:30 <Twey> Baughn: Heheheh
13:10:55 <mauke> Baughn: hey, return is an idempotent function in Perl
13:11:05 <Heffalump> EnglishGent: well, simplest would be class Foo a b where foo :: a -> b
13:11:08 <Baughn> mauke: In this case, I'm using it to sort-of do IO inside STM
13:11:10 <magthe> mauke: hmm, silly, since there clearly is a best name for the function, but it clashes with Prelude
13:11:17 <Heffalump> instance Foo [x] Bool
13:11:25 <Heffalump> instance Foo (IO [x]) (IO Bool)
13:11:30 <Heffalump> but that's pretty hacky
13:11:42 <mauke> magthe: well, what do you want?
13:11:52 <Heffalump> you should try to figure out why the overloading makes sense and see if it can be made more general
13:11:57 <mauke> the compiler can't just magically figure out what you mean if you just use 'head' everywhere
13:12:00 <Vulpyne> magthe: You could just do shortfunc = Foo.Bar.Baz.long_func
13:12:00 <Heffalump> e.g. instance Foo a b => instance Foo (IO a) (IO b)
13:12:13 <EnglishGent> thanks Heffalump :)
13:12:21 <Heffalump> once you've got the hang of that, you might want to consider a functional dependency too.
13:12:33 <Heffalump> but I'll leave that as future work
13:13:40 <magthe> Vulpyne: yes, of course, thanks
13:14:13 <mauke> shrt@longFunctionNameIsLong = ...
13:14:33 <Twey> Haha, nice
13:14:38 <Twey> I didn't think of that
13:15:01 <Twey> Top-level patterns baffle me a little
13:15:12 <Twey> Can one use all the patterns one can anywhere else?
13:15:37 <mauke> AFAIK yes
13:16:01 <chrisdone> Heffalump: how do you write a line segment? (x,y)-(a,b) ?
13:17:25 <byorgey> Twey: sure, why not?  Patterns are for binding, which is what you do at the top level.
13:18:06 * byorgey has done  [name1, name2, name3, ...] = [ ... ]  at the top-level before, I forget why
13:18:47 <Twey> byorgey: Interesting
13:19:11 <Twey> Yeah, I do [name1, name2, name3] = map … [ … ] quite often
13:19:17 <chrisdone> byorgey: great way to top-level bind a few things that are related and short on one line?
13:19:26 <byorgey> chrisdone: yeah, exactly.
13:19:29 <Twey> But it's weird to me to have the function name be a pattern :þ
13:20:19 <byorgey> _ = this is a well-typed comment
13:20:54 <rwx> are there any 'big' systems programming projects on the horizon using haskell? e.g. a firefox replacement or something
13:21:10 <chrisdone> this is a funnny top-level binding: (x:y) = x:[]
13:21:13 <Gwern-away> why would you want to replace firefox?
13:21:20 <Gwern-away> that's milleniums of man-hours
13:21:30 <chrisdone> guess what it gives
13:21:35 <chrisdone> x :: GHC.Prim.Any and y :: [GHC.Prim.Any]
13:21:56 <jlouis> It is more interesting to create something new rather than replacing something that already exists
13:22:04 <rwx> it was an example Gwern-away, but i'd replace it so we don't have to spend millenia also updating it
13:22:27 <byorgey> chrisdone: that's just because of type defaulting, I guess
13:22:51 <Gwern-away> rwx: NIH is a pejorative term for a reason
13:23:07 <copumpkin> national institutes of health?
13:23:29 <Gwern-away> YES
13:23:36 <Gwern-away> and also 'Not Invented Here'
13:23:37 <rwx> Gwern-away, NIH is more defensible when the alternatives are not easily componentizeable
13:23:38 <Gwern-away> both are fail
13:23:41 <rwx> e.g. firefox
13:23:49 <rwx> whereas now there is uzbl, right in the unix philosophy
13:23:57 <chrisdone> yeah, delicious webkit
13:24:17 <chrisdone> some legend has started adding webkit to emacs
13:24:34 <chrisdone> which makes me, um, very excited
13:26:01 <EnglishGent> why would you want to replace firefox?
13:26:09 <EnglishGent> becuase it's not written in Haskell of course! :D
13:26:41 * BMeph coughs weirdly: it almost sounds like he said "darcs!" but that can't be right...
13:27:35 <tensorpudding> Uzbl is not really comparable to Firefox
13:28:40 <chrisdone> tensorpudding: that's his point. firefox is not componentizeable, uzbl is
13:29:08 <tensorpudding> What do you mean by compenentizable?
13:31:56 <Axman6> chrisdone: don't go making up words
13:33:29 <EnglishGent> would it be possible to modify the Haskell evaluator to that (IO x -> y) (IO x) evalutes to IO y - so that you dont have to keep inserting 'ap' ? (this is effectively asking "can I overload space?") :)
13:33:33 <chrisdone> Axman6: rwx made it up. I understood it just fine. "something out of which components can be made"
13:34:29 <chrisdone> (``componentize'' is a word)
13:34:40 <MatrixTiramisu> only in america
13:35:00 <ToposTartare> EnglishGent: you might want to start by trying to overload ($), as space can't be overloaded, sadly
13:35:22 <chrisdone> MatrixTiramisu: it's a word if I use it and you understand it. did you want until "blog" was in the dictionary before accepting it as "a word"?
13:35:37 <dankna> ("Grep" is in the OED.  I find that cool.)
13:35:58 <EnglishGent> ToposTartare - yes it can! you just need the -XBlackHole extension! (sorry) :)
13:36:05 <ToposTartare> lol
13:36:18 <ToposTartare> I'd like an overloadable space too, though
13:36:24 <ToposTartare> ArrowApply!
13:37:03 <doublethink_work> ( ) = unsafeCoerce#
13:37:04 <doublethink_work> :>
13:37:14 <ToposTartare> :O
13:38:08 <jlouis> unsafeTrustme!
13:38:22 <EnglishGent> danka - yes but what's it's *definition* ? to grep : "a formal of sexual abuse" ?
13:38:23 <chrisdone> unsafeFreeCandy
13:38:23 <EnglishGent> :)
13:38:34 <MatrixTiramisu> unsafeTrustMeI'mOleg
13:38:43 <MatrixTiramisu> unsafeTrustMeI'mDons
13:39:02 <MatrixTiramisu> unsafeTrustMeI'mOlegAndDonsExtremeProgramming
13:39:15 <rgr> I dont suppose anyone here as an emacs extension to save/restore the contents and/or history of the haskell interpreter running inside emacs?
13:39:16 <doublethink_work> unsafeGetInTheVan
13:39:16 <EvanCarroll> god the left fold is hard for me to understand
13:39:46 <jlouis> EvanCarroll: there is a page on the haskell wiki IIRC
13:39:49 <chrisdone> rgr: well you can just do C-x s to save the haskell shell log. you can load it by yanking the text back in
13:39:53 <EvanCarroll> and the right fold
13:39:53 <Gwern-away> rgr: contents or history?
13:39:54 <EvanCarroll> both are had
13:39:56 <EnglishGent> rgr - you can save the history of the haskell intepreter just as you would a file C-x C-s
13:39:56 <EvanCarroll> hard
13:39:58 <EvanCarroll> jlouis: i've read it
13:39:58 <chrisdone> rgr: should be easy to write a keyboard macro to do that?
13:40:01 <EvanCarroll> and the wikipedia page
13:40:02 <MatrixTiramisu> EvanCarroll: it's easier to understraqnd once you realise it
13:40:04 <BMeph> rgr: save-buffer, perhaps? ;)
13:40:06 <EvanCarroll> and the pages under external links on the wiki
13:40:23 <MatrixTiramisu> s just a generalised way of writing tail recursive functions
13:40:24 <chrisdone> foldr is easy with lambdabot
13:40:26 <MatrixTiramisu> uh
13:40:28 <rgr> well history really.
13:40:35 <EnglishGent> really you'd like to combine that with some form of git management & synchronise it with the source state as well though
13:40:36 <MatrixTiramisu> EvanCarroll: it's easier to understraqnd once you realise its*
13:40:36 <chrisdone> > foldr f a [x,y,z]
13:40:37 <lambdabot>   f x (f y (f z a))
13:40:41 <EnglishGent> I keep meaning to hack that up
13:40:46 <Gwern-away> rgr: well, you'd have trouble serializing the bound variables and what not, since I don't think the GHC API supports that
13:40:48 <EvanCarroll> what i don't understand is why does a rfold work on an infinate list but not an lfold
13:40:52 <rgr> but I think saving it and reloading it or yanking it is pretty silly
13:40:56 <EvanCarroll> how does the rfold know where to start?
13:40:56 <Gwern-away> rgr: but doesn't ghci maintain its own scrollback history?
13:40:57 <chrisdone> EvanCarroll: just look at the outcome
13:41:01 <chrisdone> > foldl f a [x,y,z]
13:41:02 <lambdabot>   f (f (f a x) y) z
13:41:17 <rgr> Gwern-away: not sure. Just back to doing the tutorial.
13:41:22 <BMeph> EvanCarroll: Ask Cale to explain folds to you; he has some pictures in his personal Wiki that show it spectacularly. :)
13:41:34 <mathijs> Hi all, I'm having a look /play with STM. One thing I don't fully get it the "alwaysSucceeds" part about invariants. I understand what they are for, but I don't see how they work. If I execute one at one "line" in IO, how come they hook in into every transaction I run furtheron? how far do they reach? just the current IO block?
13:41:44 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
13:41:54 <jlouis> b00m, Cale to the rescue
13:42:03 <MatrixTiramisu> EvanCarroll: what foldr does is replace every (:) with the functions you give it, and the [] with the z value. so if you say have a list of Boolean values, and you replace every (:) with (||), it will exit as soon as it finds a Treu
13:42:06 <EvanCarroll> I've seen those pictures
13:42:09 <EvanCarroll> i didn't understand them
13:42:20 <chrisdone> > foldr (:) a [x,y,z]
13:42:21 <lambdabot>   Couldn't match expected type `[a]'
13:42:21 <lambdabot>         against inferred type `SimpleRef...
13:42:26 <chrisdone> daw
13:42:32 <rgr> let fac n = if n == 0 then 1 else n * fac (n-1)
13:42:35 <sproingie> is there a way to tell ghci to load hidden modules?
13:42:35 <rgr> oops
13:43:18 <Gwern-away> sproingie: nope
13:43:42 <Gwern-away> sproingie: a hidden package you could unhide with ghc-pkg, but a hidden module inside a visible package? so far as I know, no
13:43:56 <Cale> EvanCarroll: Focus on the top left one for foldr
13:44:11 <Gwern-away> (I'm not sure they even exist post-installation, actually. wouldn't they get inlined and whatnot into the visible modules's compiled files?)
13:44:16 <Cale> EvanCarroll: It's showing how foldr f z replaces each (:) in the list with f, and the [] at the end with z
13:44:30 <MatrixTiramisu> EvanCarroll: foldr (||) False [False, True, False, False ..] -> False || (True || (False || False ..)) -> True || (False || False ..) -> True
13:44:43 <Cale> So, for instance, if we use foldr (:) [] -- that ought to be the identity function
13:44:50 <sproingie> Gwern-away: i can still see a .hi file
13:44:52 <Cale> Because it replaces (:) with (:) and [] with []
13:44:57 <Cale> > foldr (:) [] [1..]
13:44:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:45:05 <Cale> and indeed, it is :)
13:45:13 <ToposTartare> hey, I bet it changes further down
13:45:17 <Cale> heh
13:45:20 <ToposTartare> it's like 100, 99, 101
13:45:30 <jlouis> ToposTartare: prove it!
13:45:36 <chrisdone> @src foldr
13:45:37 <lambdabot> foldr f z []     = z
13:45:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:45:38 <ToposTartare> :)
13:45:38 <MatrixTiramisu> heh, beat me to it
13:45:46 <chrisdone> ^ that's why it works on infinite lists. the tail is lazily evaluated
13:45:50 <Cale> Yeah, it gives some permutation of the natural numbers which in a complicated way encodes all mathematical truths
13:45:55 <sproingie> possibly it's just enough of a .hi file to tell me to go pound sand instead of saying it doesn't exist
13:45:55 <EvanCarroll> chrisdone: explain
13:46:07 <sproingie> i can't remember how to dump .hi files in order to tell
13:46:20 <chrisdone> EvanCarroll: well, do you know why ``take'' works on infinite lists?
13:46:29 <EvanCarroll> I didn't know it did
13:46:42 <chrisdone> EvanCarroll: do you know why ``head'' works on infinite lists?
13:46:44 <tensorpudding> @hoogle unfold
13:46:44 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
13:46:45 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
13:46:45 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
13:46:46 <MatrixTiramisu> > takw 10 [1..]
13:46:47 <lambdabot>   Not in scope: `takw'
13:46:49 <Gwern-away> sproingie: .hi are interfaces though, aren't they? not containing the actual code
13:46:50 <MatrixTiramisu> > take 10 [1..]
13:46:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:46:53 <EvanCarroll>  chrisdone yes, because you only need the first element
13:47:44 <chrisdone> EvanCarroll: right. that's what ``take'' does
13:47:51 <chrisdone> @src take
13:47:51 <lambdabot> take n _      | n <= 0 =  []
13:47:51 <lambdabot> take _ []              =  []
13:47:51 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:47:55 <chrisdone> > take 3 [1..]
13:47:56 <lambdabot>   [1,2,3]
13:48:11 <chrisdone> EvanCarroll: foldr is the same
13:48:29 <tensorpudding> > let unfold f p x = if p x then [] else a : unfold f p b where (a,b) = f x in unfold (\x -> (x, x+2)) (== 20) 0
13:48:30 <lambdabot>   [0,2,4,6,8,10,12,14,16,18]
13:48:41 <tromp_> > 99999 `elem` [0..]
13:48:43 <lambdabot>   True
13:49:09 <EvanCarroll> chrisdone: but foldr is With a right fold, the sum would be parenthesized as 1 + (2 + (3 + (4 + 5)))
13:49:17 <EvanCarroll> how do you parenthise infiniti
13:49:20 <tromp_> > maxBound :: Int
13:49:22 <lambdabot>   9223372036854775807
13:49:30 <mauke> EvanCarroll: step by step
13:49:31 <tensorpudding> > let unfold f p x = if p x then [] else a : unfold f p b where (a,b) = f x in unfold (\x -> (x, x+2)) (== 19) 0
13:49:32 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
13:49:36 <tromp_> > [9223372036854775800..]
13:49:37 <lambdabot>   [9223372036854775800,9223372036854775801,9223372036854775802,92233720368547...
13:49:48 <mauke> > [maxBound ..]
13:49:49 <tromp_> > [9223372036854775806..]
13:49:49 <lambdabot>   [()]
13:49:50 <lambdabot>   [9223372036854775806,9223372036854775807,9223372036854775808,92233720368547...
13:50:00 <mauke> > [maxBound :: Int ..]
13:50:01 <lambdabot>   [9223372036854775807]
13:50:11 <EvanCarroll> (bot spam in this channel is really distracting)
13:50:23 <And[y]> > false
13:50:24 <And[y]> :P
13:50:24 <lambdabot>   Not in scope: `false'
13:50:30 <tensorpudding> > False
13:50:31 <lambdabot>   False
13:50:54 <chrisdone> EvanCarroll: that's right, it would be like: 1 + (2 + (3 + (4 + ...))). for the sum of the list (``foldr (+) 0 [1..]'', for example), it would loop forever
13:50:58 <tensorpudding> @type repeat
13:50:59 <lambdabot> forall a. a -> [a]
13:51:06 <tensorpudding> > and $ repeat True
13:51:11 <lambdabot>   mueval: ExitFailure 1
13:51:39 <copumpkin> > and $ repeat False
13:51:40 <lambdabot>   False
13:51:54 <chrisdone> EvanCarroll: because what does foldr (+) 0 [1..] return?
13:51:55 <tensorpudding> > any $ repeat False
13:51:56 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
13:51:57 <lambdabot>         against inferred ...
13:52:16 <copumpkin> > foldr (+) 0 [1..] > (3 :: Natural)
13:52:17 <lambdabot>   True
13:52:30 <tensorpudding> ...
13:52:37 <tensorpudding> oh
13:53:08 <copumpkin> > foldr (+) 0 [1,2,3,-5, -7] > (3 :: Natural)
13:53:09 <lambdabot>   True
13:53:13 <copumpkin> ahem
13:53:31 <mauke> > -5 :: Natural
13:53:32 <lambdabot>   * Exception: Natural: (-)
13:53:40 <copumpkin> :)
13:53:45 <EvanCarroll> chrisdone: so if parenthesis mean you work in to out, how do you start working on a list that is infintinately in
13:54:09 <mauke> EvanCarroll: that's not what parentheses mean
13:54:17 <mauke> and lazy evaluation works outside in, not inside out
13:54:37 <EvanCarroll> =(
13:54:48 <tromp_> > -1 :: Natural
13:54:50 <lambdabot>   * Exception: Natural: (-)
13:55:13 <mauke> EvanCarroll: f (g x) calls f first
13:55:14 <tensorpudding> > () :: Natural
13:55:15 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
13:55:15 <lambdabot>         against ...
13:55:37 <tromp_> > [1..] :: [Natural]
13:55:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:55:46 <EvanCarroll> mauke: that kind of makes sense then, thanks
13:55:50 <tensorpudding> > [] :: [Maybe Int]
13:55:51 <lambdabot>   []
13:56:54 <EvanCarroll> well..
13:56:54 <EvanCarroll> gah
13:57:01 <EvanCarroll> this makes my head explode
13:58:35 <Cale> EvanCarroll: Okay, let's look at how you'd normally write a recursive function for finding the sum or product of a list of numbers
13:58:38 <Cale> sum [] = 0
13:58:43 <Cale> sum (x:xs) = x + sum xs
13:58:46 <Cale> product [] = 1
13:58:53 <Cale> product (x:xs) = x * product xs
13:59:04 <Cale> These are really very similar looking
13:59:10 <Cale> and there are lots of other functions like them
13:59:15 <Cale> concat [] = []
13:59:19 <EvanCarroll> right, but how is that going to work if the list is infinite
13:59:24 <Cale> concat (x:xs) = x ++ concat xs
13:59:32 <Cale> Well, sum and product won't
13:59:38 <Cale> concat will
13:59:40 <EvanCarroll> so why would foldr or foldl?
13:59:41 <tromp_> > on Naturals is like comparing length of two lists
13:59:42 <lambdabot>   <no location info>: parse error on input `of'
13:59:54 <EvanCarroll> or concat
14:00:04 <Cale> Oh, you want to know why foldr can work on an infinite list?
14:00:10 <EvanCarroll> yes!
14:00:15 <copumpkin> > genericLength [1..] > (genericLength [1..5] :: Natural)
14:00:17 <lambdabot>   True
14:00:18 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
14:00:27 <Cale> So foldr immediately passes control to f
14:00:30 <tromp_> because + is not strict on Naturals
14:00:37 <Cale> passing it the parameters x and (foldr f z xs)
14:00:53 <Cale> only if f pattern matches on its second parameter will foldr get to continue down the list
14:01:05 <EvanCarroll> Cale: right but the `foldr f z xs` can never be known without a finante xs right?
14:01:20 <Cale> EvanCarroll: We just stop right here.
14:01:22 <EvanCarroll> finite*
14:01:35 <Cale> EvanCarroll: Maybe we don't need to know foldr f z xs at all!
14:01:39 <roconnor> > foldr const "EvanCarroll" [0..]
14:01:40 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
14:01:40 <lambdabot>    arising from the literal ...
14:01:42 <chrisdone> EvanCarroll: what does ``foldr (\(x:xs) -> x) 0 [1..]'' return
14:01:57 <roconnor> er
14:01:59 <Cale> EvanCarroll: consider  foldr const 0 [1..]
14:02:04 <chrisdone> woops
14:02:09 <tensorpudding> > foldr (\(x:xs) -> x) 0 [1..]
14:02:10 <lambdabot>   No instance for (GHC.Enum.Enum [b -> b])
14:02:11 <lambdabot>    arising from the arithmetic seq...
14:02:12 <Cale> That is,  foldr const 0 (1:[2..])
14:02:14 <chrisdone> yeah, what cale said. never mind
14:02:24 * roconnor also defers to Cale
14:02:29 <Cale> const x y = x
14:02:35 <tensorpudding> @type const
14:02:36 * chrisdone is the redundant cook
14:02:36 <lambdabot> forall a b. a -> b -> a
14:02:43 <Cale> foldr const 0 (1:[2..])
14:02:55 <Cale> -> const 1 (foldr const 0 [2..])
14:02:57 <EvanCarroll> god damn, I'm going to ignore lambdabot I can't learn with 100 people giving him syntax errors
14:02:58 <Cale> -> 1
14:03:44 <Cale> EvanCarroll: Make sense?
14:03:59 <EvanCarroll> I'm trying
14:04:00 <EvanCarroll> one sec
14:04:06 <Cale> EvanCarroll: It's important to understand that Haskell uses lazy evaluation, which means that it reduces the function before its parameters.
14:04:20 <And[y]> EvanCarroll: you should not learn here, anyways =D
14:04:31 <Cale> (well, that's not quite true, it really uses non-strict evaluation, but lazy evaluation is equivalent)
14:04:42 <Cale> And[y]: why not?
14:05:03 <EvanCarroll> And[y]: I've read every tutorial I could find on this, it wasn't the first place i turned
14:05:21 <roconnor> EvanCarroll: ignore what And[y] said. :)
14:05:54 <Cale> EvanCarroll: That is, in most programming languages, when you evaluate the expression f (g x), you first evaluate g x and then substitute the value you get into the body of f.
14:06:04 <chrisdone> EvanCarroll: if it help to emphasize the point, foldr const 0 [1..] == foldr (\x y -> x) 0 [1..]
14:06:16 * hackagebot upload: randsolid 0.1 - Set the background of your root window to a random colour. (JohannesMartinsson)
14:06:20 <Cale> EvanCarroll: But in Haskell, you substitute (g x) into the body of f, and only evaluate it later, if you need it
14:06:35 <And[y]> you learn with your brain and not with your keyboard ... thats why i commented on this ;)
14:07:05 <tensorpudding> the power of thunks!
14:07:15 <chrisdone> And[y]: can I kiss you with my brain?
14:07:26 * Cale prefers the term 'expression' to the term 'thunk'
14:07:32 <EvanCarroll> Cale: right, but in both folds it needs both g x to return from f, how can it ever know xs if the list is infiniti
14:07:36 <roconnor> #haskell seems to have a funny definition of non-strict.
14:07:36 <EvanCarroll> infinite
14:07:37 <lunabot>  luna: Not in scope: `haskell'
14:07:43 <Cale> EvanCarroll: hm?
14:07:58 <Cale> EvanCarroll: Do you want a better example? Perhaps let's do one with concat
14:08:05 <kolmodin> Igloo: if nobody told you yet, code.haskell.org seems down or very slow
14:08:09 <Cale> Recall that [] ++ ys = ys
14:08:19 <Cale> and that (x:xs) ++ ys = x : (xs ++ ys)
14:08:39 <EvanCarroll> right
14:08:44 <Cale> and we have concat [] = [] and concat (x:xs) = x ++ concat xs
14:08:48 <copumpkin> And[y]: I learned all my haskell through #haskell
14:09:02 <mauke> EvanCarroll: it doesn't need the value of g x to return from f
14:09:16 <Cale> So let's try something like concat [[k] | k <- [0..]]
14:09:26 <leimy> copumpkin: Ever use ReadP?
14:09:38 <leimy> and compared it to Parsec?
14:09:43 <copumpkin> didn't enjoy it much
14:09:47 <Cale> concat needs to pattern match on that list, so we need to reduce the list comprehension a bit
14:09:59 <Cale> So our first step is:
14:10:02 <Cale> concat [[k] | k <- [0..]]
14:10:16 <Cale> -> concat ([0] : [[k] | k <- [1..]])
14:10:28 <Cale> and now concat can pattern match
14:10:48 <Cale> -> [0] ++ concat [[k] | k <- [1..]]
14:10:59 <Cale> and now it's ++'s turn
14:11:18 <Cale> -> (0:[]) ++ concat [[k] | k <- [1..]] -- desugaring
14:11:28 <leimy> Is it generally always better to use unfold's instead of list comprehensions when building a list due to compiler optimizations?
14:11:32 <Cale> -> 0 : ([] ++ concat [[k] | k <- [1..]])
14:11:49 <Cale> (there's the second rule for (++))
14:12:00 <Cale> and now we know the first element of the resulting list
14:12:09 <Cale> and we didn't have to do an infinite amount of work at all
14:12:17 <roconnor> leimy: my gut reaction is no.
14:12:44 <Cale> EvanCarroll: follow all that?
14:13:02 <Cale> EvanCarroll: If you want, I can hpaste it and put a comment on each step
14:13:16 <EvanCarroll> how do i run the tuff you sent to lamdabot in ghci?
14:13:27 <EvanCarroll> to get the same output
14:13:32 <Cale> I didn't send anything to lambdabot
14:13:49 <EvanCarroll> i thought thats what the -> stuff was
14:13:50 <roconnor> leimy: someone else here probably knows GHC better than I do, but IIRC there is (or were) two sorts of optimizations for list deforestation.
14:13:54 <Cale> No, that was me.
14:14:18 <roconnor> leimy: the build/foldr pair and the destroy/unfoldr pair ?
14:14:28 <roconnor> leimy: so you want to match your pairs up
14:14:40 <Cale> EvanCarroll: by -> I mean that this is what happens as we evaluate one step at a time
14:14:42 <roconnor> leimy: but that was a while ago, and I got the impression that things may have changed
14:14:51 <leimy> hmmm
14:14:51 <Cale> EvanCarroll: I've just been typing all this by hand :)
14:14:58 <roconnor> leimy: and I probably even what I said isn't quite right
14:15:04 <leimy> heh :-)
14:15:06 <leimy> fair enough
14:15:44 <roconnor> leimy: cause this was all before stream fusion
14:16:13 <leimy> There's something in Real World Haskell about it
14:16:20 <Cale> Weren't there nice general algorithms for deforestation even before stream fusion?
14:16:22 <EvanCarroll> Cale: sorry i'm still looking at it
14:16:27 <Cale> EvanCarroll: that's okay
14:16:41 <roconnor> leimy: I don't have a feel for what stream fusion will eliminate
14:16:46 <leimy> Is that book a year old?
14:16:47 <leimy> hmmm
14:16:47 <roconnor> leimy: but I understand it is quite a bit.
14:16:48 <Cale> EvanCarroll: The important thing is to become comfortable with the order in which we choose to pick subexpressions to apply rules to
14:17:02 <leimy> roconnor: it to deforest things :-)
14:17:05 <Cale> EvanCarroll: because it's exactly the opposite of what you'd get in a strict evaluator
14:17:19 <leimy> it burns down forests
14:17:22 <roconnor> leimy: stream fusion is specific to list deforestation IIRC
14:17:24 <leimy> and destroys jungles
14:17:42 <roconnor> does GHC implement stream fusion now?
14:17:51 <MisterN> hi. is it possible to write ghc Modules in C?
14:18:06 <roconnor> ``In particular, stream fusion is able to fuse zips, left folds and functions over nested lists, including list comprehensions.
14:18:12 <Cale> MisterN: It's possible to use FFI to import C functions
14:18:14 <roconnor> from http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
14:18:21 <leimy> roconnor: I think if you can lazily consume the result of unfoldr, you never have to build the spine of the list
14:18:31 <leimy> and therefore the next value can be in a register
14:18:41 <leimy> the result is really effing fast :-)
14:18:47 <roconnor> leimy: true, but I think stream fusion does that too, and more
14:18:48 <EvanCarroll> Cale: so does concat just retrun one value, or is it a coroutine?
14:18:52 <MisterN> Cale: i know. but that's not what i was asking for :)
14:18:53 <Cale> MisterN: But typically you want to do at least a little work wrapping the ugly C APIs in something a little prettier to a Haskell programmer.
14:19:08 <MisterN> i hate FFI.
14:19:09 <roconnor> leimy: according to the paper abstract stream fusion applies to list comprehensions.
14:19:19 <MisterN> i think FFI is a fundamentally broken concept.
14:19:28 <Cale> EvanCarroll: concat takes a list of lists and constructs a single list
14:19:32 <EvanCarroll> Cale: is it yielding after each returned value?
14:19:53 <Adamant> MisterN: what doy ou mean?
14:19:58 <Adamant> *do you
14:20:01 <Cale> EvanCarroll: case expressions only force evaluation to happen until they can match one of their patterns
14:20:24 <Cale> EvanCarroll: and at some level, all evaluation happens because some case expression demands a pattern match
14:20:27 <ddarius> roconnor: Stream fusion doesn't require compiler modification.
14:20:41 <Cale> EvanCarroll: (other things get translated into case expressions)
14:20:50 <EvanCarroll> Cale: is there a better book that LYAH to get a foundation in this?
14:21:04 <Cale> EvanCarroll: Well, depends on how deep you want to go
14:21:04 <MisterN> Adamant: in python, you can write modules in C and import them as if they were python modules.
14:21:09 <roconnor> ddarius: sure.  But it is an optimisation that comes with GHC by default?
14:21:10 <aavogt> LYAH is a book already?
14:21:12 <Cale> EvanCarroll: and how GHC-specific you want to be
14:21:19 <BONUS> aavogt: soon :D
14:21:33 <ddarius> roconnor: No.  The libraries distributed with GHC do not use stream fusion.
14:21:36 <Adamant> MisterN: that doesn't work for a variety of reasons with Haskell
14:21:40 <lvh> (At least in the dominant implementation of Python: CPython.)
14:22:02 <Cale> EvanCarroll: but the basic idea is simple: if you have  case foo of <pat1> -> ... ; <other patterns>
14:22:13 <ddarius> MisterN: Can I just write Scheme modules and import them as if they were python modules?
14:22:15 <aavogt> BONUS: depending on the cover you have be be careful that it doesn't get sold as a children's book (or is that the point ;)
14:22:25 <Cale> EvanCarroll: then you evaluate foo step-by-step until you can tell if it matches <pat1> or not
14:22:29 <BONUS> hey i'd love it if kids learned haskell!
14:22:43 <sproingie> yes you can write C modules in python, but guess what, a lot of those are being replaced by the FFI, ctypes
14:22:44 <MisterN> ddarius: it would be possible to write a middle layer in C to allow that, yes.
14:22:50 <Cale> If it does match, the result is whatever is to the right of the ->
14:23:04 <Cale> If it doesn't, you continue with trying to match the other patterns
14:23:19 <Cale> EvanCarroll: make sense?
14:23:29 <EvanCarroll> no =(
14:23:35 <EvanCarroll> Cale: I still don't understand how recursion in an infinite list can be resolved.
14:23:39 <Cale> EvanCarroll: The important thing to realise is that (some representation of) expressions really exists at runtime
14:23:43 <roconnor> ddarius: if I import Data.List.Stream, will list comprensions use the new functions?
14:23:50 <ddarius> roconnor: No.
14:23:50 <EvanCarroll> i understand that.
14:23:59 <roconnor> ddarius: sucky
14:24:01 <MisterN> sproingie: i don't see native python modules becoming irrelevant
14:24:15 <MisterN> especially because modules can be written not just in C, but also in C++ and other languages.
14:24:21 <aavogt> roconnor: use do instead?
14:24:23 <Cale> EvanCarroll: Let's go with map (+1) [0..]
14:24:24 <sproingie> MisterN: no, but i also don't see a lot of support for the assertion that the FFI is something to avoid
14:24:24 <Cale> @src map
14:24:24 <lambdabot> map _ []     = []
14:24:25 <lambdabot> map f (x:xs) = f x : map f xs
14:24:39 <roconnor> aavogt: presumably that won't help either.
14:24:40 <aavogt> but I suppose that the monad instance cannot be overridden either
14:24:45 <aavogt> yeah
14:24:48 <Cale> This desugars to something like:
14:24:51 <EvanCarroll> i just don't understand how you can add one to the result of a list, if the result of a list includes infiniti, or how you can add the the whole list excluding the last item, if you don't know what the last item is
14:25:00 <MisterN> sproingie: well... FFI being the sole interface to a language is definitely something to avoid.
14:25:06 <Cale> map f lst = case lst of [] -> []; (x:xs) -> f x : map f xs
14:25:22 <Cale> EvanCarroll: add?
14:25:23 <roconnor> ddarius: no module of GHC rewrite rules to replace old functions with new functions?
14:25:34 <sproingie> MisterN: i would tend to agree there
14:25:37 <MisterN> ghc only supports FFI and therefore there are no C++ bindings for haskell :(
14:25:41 <EvanCarroll>   in the cafe of fold (+) [0..]
14:25:42 <Cale> EvanCarroll: Do you mean 'add' in the sense of (1:) ?
14:25:46 <EvanCarroll> whatever
14:25:49 <Cale> oh, that doesn't terminate
14:25:51 <EvanCarroll> I don't see why the function matters
14:25:55 <Cale> > foldr (+) 0 [0..]
14:25:56 <lambdabot>   * Exception: stack overflow
14:26:00 <ddarius> roconnor: I doubt it.
14:26:02 <EvanCarroll> : or +
14:26:09 <MisterN> i would love to be able to write haskell modules in C or C++
14:26:11 <MisterN> (mostly C++)
14:26:23 <Cale> EvanCarroll: let's do a bit of that reduction then
14:26:27 <ddarius> MisterN: You can, you just have to present a C interface as you do for almost every language.
14:26:28 <Cale> foldr (+) 0 [0..]
14:26:36 <Cale> -> 0 + foldr (+) 0 [1..]
14:26:37 <aavogt> there's -XNoImplicitPrelude... but that's a pain
14:26:44 <Cale> -> 0 + (1 + foldr (+) 0 [2..])
14:26:52 <Cale> -> 0 + (1 + (2 + foldr (+) 0 [3..]))
14:26:54 <roconnor> leimy: so apparently you have to use the function in Data.List.Stream.
14:26:57 <ddarius> roconnor: Maybe I'm wrong, you can check the source of the stream fusion libraries.
14:27:12 <Cale> The outer + can't produce any part of its result because it needs to pattern match on the second parameter
14:27:23 <leimy> roconnor: I think the Uvector library works though too
14:27:25 <MisterN> ddarius: for many languages i don't have to artificially create a C interface. for example python and lua and javascript have direct c++ bindings, which work with the Module paradigm
14:27:51 <Cale> and then "1 + ..." can't evaluate until "..." does as well
14:27:51 <sproingie> lua goes through a C api
14:27:54 <Philonous> EvanCarroll: A "list" in haskell is not really a list but just a promise to compute a list when it is needed. It's called a thunk. When you manipulate that thunk the data is not changed at all (as it is not there yet), but the runtime system just remembers to change it when it is needed. It's just when you somehow force the values (for example print them on the screen) that the data is actually evaluated, and even than only thos
14:27:57 <Cale> and same for "2 + ..."
14:28:07 <MisterN> sproingie: but you do not have to write a C API for your library.
14:28:08 <ddarius> I'm not aware of anything (including C++) that can seamlessly talk to C++ code.
14:28:10 <Cale> and so it just runs forever, trying to evaluate the foldr
14:28:18 <sproingie> MisterN: generated C is still C
14:28:27 <MisterN> sproingie: no, there is no C generation involved.
14:28:44 <ddarius> You don't actually have to have C code to present a C interface.
14:28:47 <MisterN> http://www.rasterbar.com/products/luabind.html
14:28:58 <ddarius> I can present a C interface is Haskell code completely within Haskell.
14:29:23 <chrisdone> a very lovely feature
14:29:26 <leimy> s/present/misrepresent
14:29:32 <Philonous> EvanCarroll: So whenever you see a list you might mentally replace that with a list generator. And the generator does terminate, even though it could, potentially, create an infinite list.
14:29:32 <ivanm> @remember ddarius I'm not aware of anything (including C++) that can seamlessly talk to C++ code.
14:29:32 <lambdabot> I will never forget.
14:29:43 <sproingie> C++ can certainly talk to C++.  seamlessly is another question.
14:30:07 <MisterN> see, pointless C++ bashing is why i talked about "C modules" in the beginning.
14:30:16 <sproingie> the very first thing i see in the luabind docs is extern "C"
14:30:19 <leimy> C++'s ABI is iffy :-)
14:30:34 <MisterN> leimy: whatever.
14:30:47 <MisterN> why doesn't haskell allow writing modules in C?
14:31:05 <m0nkfish> what is the common term for lazy tabulation
14:31:16 <leimy> MisterN: who said it doesn't?
14:31:26 * leimy has a ring buffer in C that he calls from haskell all the time.
14:31:39 <MisterN> leimy: <Adamant> MisterN: that doesn't work for a variety of reasons with Haskell
14:31:56 <leimy> interesting... I wonder what it is I wrote then :-)
14:31:59 <MisterN> leimy: do you use FFI for the ring buffer? i mean writing modules without FFI...
14:32:17 <leimy> You're not going to get far without the FFI :-)
14:32:30 <leimy> For one Haskell's data types are not C's
14:32:42 <MisterN> leimy: you can do it in python without FFI. even though python's data types are not C's.
14:32:55 <leimy> Ok.
14:33:10 <leimy> How does Python reference that code?
14:33:44 <MisterN> leimy: you call C functions to register your stuff, with callbacks and so on
14:33:57 <leimy> so how is that *not* an FFI?
14:34:18 <leimy> In C for python don't you have to deal with PyObject and stuff like that?
14:34:34 <leimy> I mean, in Haskell, I can call into malloc and free and a bunch of other stuff with no plumbing C code.
14:34:39 <idnar> I would call the Python C API "FFI"
14:35:05 <leimy> So I guess I'm confused.
14:35:05 <ddarius> MisterN: That's better than simply writing 'foreign import ccall "my_func" myFunc  :: CInt -> IO ()' ?
14:35:14 <leimy> I mean I wrote my C ring buffer for C... then I told Haskell how to import it.
14:35:23 <leimy> in Python, you have to write your code in C with Python as a target.
14:35:30 <MisterN> ddarius: yes, because it works with C++, and even if you hate C++, i think i'm entitled to liking it.
14:35:30 <leimy> I'm not sure Python's way is specifically better.
14:35:48 <ddarius> MisterN: I like C++.  That's how I know how hard it is to use even with other C++ compilers.
14:35:56 * leimy has many years of C++ experience.
14:36:04 <leimy> most of it was pretty good.
14:36:06 <ddarius> MisterN: And Haskell's FFI works with C++ too.  I started bindings to Kyra a long time ago.
14:36:10 <Cale> The problem with FFI and C++ is mostly on the C++ side of things.
14:36:21 <leimy> ddarius: Awesome... I used to work on Kyra! :-)
14:36:41 <MisterN> ddarius: it's possible if you write a virtual C layer
14:37:00 <ddarius> MisterN: That's true for everything and that's pretty much the only way and is what I said earlier.
14:37:01 <MisterN> ddarius: but that sucks. i much prefer the boost.python approach. you know boost.python?
14:37:22 <ddarius> MisterN: I don't use python.
14:37:35 <leimy> Hmmm never used boost.python
14:37:54 <MisterN> it's pretty cool
14:38:04 <leimy> Dave Abrahams is a really smart fellow
14:38:22 <MisterN> http://www.boost.org/doc/libs/1_41_0/libs/python/doc/tutorial/doc/html/index.html
14:38:33 <leimy> I believe he took my slot on a contract for MIT Lincoln Labs to make a Vector Signal Image Processing Library, and make sure the C++ was kosher :-)
14:39:33 <MisterN> and with a few others, i have created something similar to boost.python for javascript: http://flusspferd.org/docs/cpp-tutorial-classes.html
14:39:50 <leimy> So instead of doing the FFI stuff on the Python side, you're doing it on the C/C++ side
14:39:56 <leimy> haskell has that the other way around.
14:40:00 <MisterN> and it seems to be impossible to do the same stuff for haskell
14:40:10 <leimy> I just write C code, then call it from haskell :-)
14:40:18 <leimy> like I said, you can even do malloc/free :=)
14:40:48 <leimy> Stuff ends up in IO Ptr
14:40:50 <leimy> but it works :-)
14:40:55 <jmcarthur_work> i much prefer the haskell way
14:41:09 <cpfr> this is just a quick question, how do i add a type signature to a function that occurs in a where clause
14:41:09 <Cale> leimy: and then you write another Haskell layer on top of that to abstract it away :)
14:41:19 <leimy> Sure if you care to :-)
14:41:26 <Cale> cpfr: the same way as to any function
14:41:39 <jmcarthur_work> it means i have a full arsenal of haskell combinators, monads, etc. available to me in the bindings themselves
14:41:41 <leimy> Someone posted an implementation of "select" for Haskell using the C routines.
14:41:42 <Cale> cpfr: Just write the type signature inside the where clause before the rest of the lines of the function
14:42:01 <MisterN> jmcarthur_work: probably because you do not want to bind C++ classes.
14:42:07 <cpfr> Cale, so can i have where foo :: Int -> Int \n foo a = a + 2
14:42:21 <jmcarthur_work> MisterN, if bindings were in C you'd have to go through the same trouble anyway
14:42:27 <Cale> cpfr: Yeah, just make sure to line it up properly
14:43:06 <MisterN> jmcarthur_work: except i would not have to create a virtual C interface for my c++ classes, which is really something i want to avoid. generally i avoid code generation like the plague.
14:43:09 <Cale> cpfr: Each "foo" should like up vertically there
14:43:12 <Cale> line*
14:43:46 <cpfr> thanks it worked
14:43:52 <jmcarthur_work> MisterN, you are already making a virtual interface. might as well just do it at the highest level you can. anything higher can be mechanical
14:43:55 <MisterN> see, it's lovely how much you like FFI for binding pure C interfaces. but it breaks as soon as you don't have a C interface. and i think forcing everything to have a C interface is not the way to go.
14:44:18 <jmcarthur_work> MisterN, i see your point, i just disagree
14:44:26 <MisterN> jmcarthur_work: if you look at boost.python or http://flusspferd.org/docs/cpp-tutorial-classes.html , you will see that it is not really mechanical at all.
14:44:26 <jmcarthur_work> i have bound to C++ APIs without issue
14:44:32 <Cale> MisterN: Well, it's not like there's a natural thing to turn a C++ object into on the Haskell side. Maybe some kind of existential?
14:44:57 <Cale> MisterN: Or an opaque value, which will essentially be the same as going via C.
14:45:03 <MisterN> Cale: C functions don't exactly fit in naturally either :)
14:45:06 <jmcarthur_work> MisterN, your examples are bindings to OO languages
14:45:20 <Cale> MisterN: They do, they have types involving IO
14:46:18 <jmcarthur_work> i'll be interested in a C binding interface when you can give me alloca in C
14:46:52 <Cale> alloca :: Storable a => (Ptr a -> IO b) -> IO b
14:47:00 <Cale> good luck with that ;)
14:47:18 <MisterN> jmcarthur_work: you don't think there's a natural way to bind c++ classes to haskell?
14:47:32 <jmcarthur_work> MisterN, how would you do it?
14:47:45 <aavogt> can there be a mechanical translation to oohaskell?
14:48:05 <MisterN> jmcarthur_work: i don't really know.
14:48:06 <Cale> MisterN: There are a number of choices, none of which I can see is any better than the result you get going via C.
14:49:05 <Cale> You can recover some OO-ness on the Haskell side with properties.
14:49:07 <rgr> in a tutoprial I see this  "4 `elem` [3,4,5,6]" . What is the significance/meaning of the single quotes around "elem"?
14:49:23 <mauke> they're backticks, not single quotes
14:49:25 <Botje> backquotes turn a function into a binary operator
14:49:29 <Cale> rgr: the backquotes turn functions into infix operators
14:49:31 <mauke> and they turn normal identifiers into infix operators
14:49:33 <rgr> Botje: thanks
14:49:36 <MisterN> jmcarthur_work: maybe use IO Classname for every class?
14:49:42 <jmcarthur_work> rgr, foo bar baz == bar `foo` baz
14:49:45 <Botje> elem 4 [3..6] is less elegant than 4 `elem` [3..6]
14:49:48 <Cale> (they are not the same as single quotes)
14:50:00 <jmcarthur_work> MisterN, what does it mean to return a C++ class as a value?
14:50:04 <rgr> yes, wrong term.
14:50:18 <jmcarthur_work> oh you mean instances
14:50:41 <Cale> Yeah, classes <-> types, objects <-> values
14:50:58 <Cale> But we have no subtyping relation on the Haskell side.
14:51:19 <rgr> Botje: why is one less elgant than the other?
14:51:30 <Cale> So there's nothing to map "A is a subclass of B" onto.
14:51:51 <Cale> Except possibly a function for turning values of type A into values of type B
14:51:51 <Botje> rgr: unless you're used to lisp, the second translates into the wanted relationship more easily
14:51:58 <Cale> and values of type B into values of type Maybe A
14:52:20 <Botje> 5 `mod` 3 vs mod 5 3 :)
14:52:48 <rgr> yeah ok. I am still seeing brackets :-; Makes sense Thanks.
14:53:02 <MisterN> Cale: that problem doesn't go away if you go via C
14:53:17 <ddarius> MisterN: C has (almost) no subtyping.
14:53:33 <MisterN> ddarius: but the logical interface has.
14:53:33 <ddarius> But yes, going via C doesn't make C++ any more natural.
14:54:03 <Cale> MisterN: right
14:54:24 <jmcarthur_work> i would argue that going via C doesn't not make C++ any less natural, though
14:54:31 <jmcarthur_work> *does not
14:54:35 <ddarius> Haskell has no OO features.  There is no "seamless" way to map any OO language into Haskell, especially in a way that would make Haskellers happy.
14:54:36 <Twey> 22:51:30 < Cale> So there's nothing to map "A is a subclass of B" onto.
14:55:00 <MisterN> ddarius: i think "natural" is the wrong word. both haskell and c++ are man-made. and the impedance mismatch is neither due to only C++ nor due to only Haskell.
14:55:01 <Twey> Gtk2Hs gives every type its own typeclass, which works pretty well.
14:55:12 <Cale> Twey: that's true
14:55:23 <MisterN> ddarius: also, every language is an OO language
14:55:25 <ddarius> MisterN: I agree.  They are simply different.  All I'm saying is Haskell is (significantly) different from C++ .
14:55:36 <ddarius> MisterN: So Haskell is an OO language?
14:55:46 <Cale> Twey: though it's more or less what I said in the 'except' part, only with typeclasses :)
14:55:58 <MisterN> ddarius: the probability for it being so is high, yes.
14:56:01 <jmcarthur_work> MisterN, that sounds like propaganda from the blogosphere
14:56:05 <kynky> haskell is functional
14:56:13 <jmcarthur_work> MisterN, do you have any justification for that?
14:56:33 <Cale> Haskell can be used to write OO programs reasonably naturally, but the translation between the way you do it in C++ and the way you do it in Haskell is nontrivial.
14:56:37 <jmcarthur_work> just because you can write OO in any language doesn't mean that is the most natural way to look at it
14:56:40 <ddarius> MisterN: If "every language" were an "OO language" then the term "OO" would have no meaning.
14:56:42 <MisterN> jmcarthur_work: well, i think you don't throw away the logical concept of an "object", when working with haskell.
14:56:51 <jmcarthur_work> MisterN, which is?
14:57:09 <kynky> ip = imperative programing, oop = object orientated programming, fp = functional programming, guess which one haskell is?
14:57:17 <tensorpudding> it's not impossible to have a language that is functional and has objects
14:57:18 <jmcarthur_work> my fundamental understanding of an object is message passing, and i don't see that in haskell unless i do it explicitly, usually
14:57:45 <sproingie> where object is seen as having an identity distinct from value, you do indeed throw away that concept
14:57:49 <Cale> jmcarthur_work: You can accomplish it effectively in a pure way using records of functions
14:58:02 <jmcarthur_work> Cale, right, but you are doing it explicitly
14:58:04 <tensorpudding> doesn't lisp have an object system?
14:58:12 <sproingie> tensorpudding: it has a terrific object system
14:58:17 <ddarius> tensorpudding: Common Lisp has CLOS.
14:58:19 <MisterN> lisp is a multi-paradigm language.
14:58:24 <kynky> haskell has functions :)
14:58:32 <tensorpudding> yes, so its not like objects and functions are orthogonal to each other
14:58:40 <Twey> tensorpudding: CL has THE Object System.
14:58:42 <Cale> jmcarthur_work: I guess. The fact that functions capture the values of variables in scope when they are constructed takes care of a lot of it for you though.
14:59:04 <ddarius> tensorpudding: No one said anything like that, just that Haskell doesn't support OO.
14:59:10 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
14:59:11 <jmcarthur_work> objects are a good solution to certain classes of problems. that doesn't make them good solutions for *every* class of problems. this is my problem with the argument that every language is OO
14:59:20 <sproingie> i'm very accustomed to thinking of objects as having identity so switching to FP is a little jarring for me, i'm still figuring it out
14:59:25 <tensorpudding> what does OO mean? does it just mean "we have objects" or something more akin to the way that objects are used?
14:59:37 <sproingie> i just have to think of identity as a function, really
14:59:38 <Cale> Yeah, "OO" is too general a term.
14:59:47 <ddarius> tensorpudding: It means different things to different people clearly.  Obviously for MisterN it means something completely generic.
14:59:49 * BMeph starts humming to himself: "I love the whole world, and all its messed-up stuff, boom-de-yadda, boom-de-yadda..."
14:59:59 <Cale> But for some definitions of it, you can get very good approximations of the style in Haskell.
15:00:09 <tensorpudding> I propose replacing Object-Oriented with Objectionable, as it parallels Functional better :P
15:00:20 <ddarius> Cale: Most of which are distinctly encodings.
15:00:30 <sproingie> wouldn't that make haskell a Functionable language?
15:01:00 <tromp_> is OO Objectional then?
15:01:03 <Twey> To me, an ‘object’ is a value that can hold multiple primitive values and procedures for mutating them, and has an identity distinct from the sum of its parts (so that equality does not equal equivalence).
15:01:05 <ddarius> For example, using the PIE definition of OO, Haskell does not support any but the E.
15:01:08 <Cale> ddarius: I don't know. The line between an encoding and just programming something in a natural way is sort of fuzzy.
15:01:20 <ddarius> Cale: Agreed, hence the "distinctly."
15:01:21 <sproingie> mm pie
15:01:27 <tensorpudding> there is a good paper that was on LtU a little while ago about objects vs. abstract data types
15:01:31 <Cale> ddarius: The "encoding" I discuss is a perfectly functional idiom if you look at it another way.
15:01:32 <MisterN> i think OO is mostly a style of approaching programming problems.
15:01:33 <Philonous> And prolog is questionable.
15:01:41 <ddarius> Cale: Some natural Haskell code can be readily viewed as an OO style.
15:01:43 <MisterN> and i assume this style is useful in haskell.
15:01:46 <Cale> yeah
15:01:54 <sproingie> PIE ... polymorphism, inheritance, encapsulation?
15:02:00 <ddarius> sproingie: Yes.
15:02:04 <jmcarthur_work> i usually think of an object as something than can send messages to other objects or receive messages from other objects. to say anything about how they work or how they are structured internally breaks the OO abstraction
15:02:07 <tensorpudding> http://lambda-the-ultimate.org/node/3668
15:02:21 <sproingie> haskell has polymorphism up the wazoo, just in different places
15:02:23 <jmcarthur_work> MisterN, it's useful, but not prevalent
15:02:26 <Cale> MisterN: Occasionally, though maybe less than you'd expect, if you've been hanging around with OO fanatics :)
15:02:50 <ddarius> sproingie: "Polymorphism" in OO means inclusion polymorphism and/or subtype polymorphism.  Neither of which are even applicable to Haskell.
15:03:05 <sproingie> not inclusion, no
15:03:06 <MisterN> Cale: oh, i do not hang out nor am an OO fanatic :)
15:03:19 <jmcarthur_work> i also think that polymorphism is orthogonal to OO
15:03:24 <MisterN> i have done my share of functional programming, though mostly in C++ templates :D
15:03:29 <rgr> why would one need to do [20,19..1] to generate from 20 to 1 as a range and not just [20..1]? Can the compiler not assume the step in the same way it does [1..20] ?
15:03:38 * SimonRC has been inhaling some OO design pattern text recently.  Things keep looking familiar but different.
15:03:45 <ddarius> jmcarthur_work: Most features representative of each paradigm are "orthogonal" to that paradighm.
15:04:02 <SimonRC> I now keep doing design-pattern-matching all over the place
15:04:11 <SimonRC> and decomposing my programs in new ways
15:04:14 <MisterN> but it's probably inevitable for large well-designed applications to adopt OO concepts.
15:04:15 <SimonRC> evne the Forth and Haskell ones
15:04:17 <Cale> rgr: because an empty list is actually really what you'd want in a lot of cases there
15:04:21 <ddarius> rgr: The compiler doesn't try to figure stuff out.  [20..1] is just syntactic sugar for enumFromTo 20 1
15:04:41 <jmcarthur_work> ddarius, there are certain kinds of polymorphism that OO languages happen to enjoy a high concentration of, sure
15:05:01 <rgr> ddarius: and this is different from [1..20] how?
15:05:11 <jmcarthur_work> > [1..20]
15:05:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
15:05:13 <jmcarthur_work> > [20..1]
15:05:15 <lambdabot>   []
15:05:16 <Cale> We *could* have defined enumFromTo 20 1 to generate a descending list, but it would mess up a lot of definitions
15:05:16 <ddarius> rgr: Because that means enumFromTo 1 20 and enumFromTo is not commutative.
15:05:29 <Cale> (and sure, fix others)
15:05:38 <rgr> jmcarthur_work: I know what they eval to. I am asking why. Thanks anyway.
15:05:38 <ddarius> jmcarthur_work: Many would consider higher order functions orthogonal to FP and others consider them a defining characteristic of FP.
15:05:57 <mauke> rgr: because [20 .. 1] == [] is actually the right answer
15:06:01 <dolio> If that list weren't empty, then 'factorial n = product [1..n]' wouldn't work.
15:06:08 <sproingie> i cant conceive of FP without HOFs
15:06:16 <ddarius> sproingie: There are FP languages without HOFs.
15:06:25 <sproingie> ddarius: such as?
15:06:30 <jmcarthur_work> ddarius, my "i thinks" were an attempt to distill a simple definition of OO, not to encompass everything that people claim to be OO
15:06:52 <ddarius> sproingie: FP (the language) only had limited HOFs and Single-Assignment C and its predecessors are first order.
15:07:04 <rgr> mauke: I'm not sure I can rephrase my Q any clearer. I know what is "right" I am asking "why". I think its probably important to grasp these concepts earlier rather than later.
15:07:14 <jmcarthur_work> ddarius, so i was attempting to cast polymorphism aside for this working definition
15:07:35 <ddarius> jmcarthur_work: Haskell still lacks (OO-style) inheritance.
15:07:53 <ddarius> Some may even say that (standard) Haskell lacks OO-style encapsulation.
15:08:11 <dolio> http://cseweb.ucsd.edu/~goguen/pps/utyop.ps
15:08:14 <SimonRC> ddarius: Haskell has more encapsulation than smalltalk though
15:08:15 <jmcarthur_work> because while the type system is a big part of what make a language, it can still be OO without a particular type system, so it would appear that the type system is not necessary for OO
15:08:17 <Saizan> rgr: it's the principle of usefulness/least surprise for when the two indexes might be variables, like the factorial definition above
15:08:39 <SimonRC> hmm
15:08:55 <ddarius> SimonRC: I'm pretty sure Alan Kay would not subscribe to the PIE view of OO, though he would agree with the general direction.
15:09:05 <jmcarthur_work> i continue to speak with hidden assumptions though, which i don't have time to enumerate because i must leave
15:09:10 <SimonRC> ddarius: "PIE"?
15:09:13 <sproingie> kay doesn't get to control a term just by coining it
15:09:34 <ddarius> jmcarthur_work: Inclusion polymorphism is, basically, dynamic dispatch.  Haskell doesn't have dynamic dispatch and most consider that a defining feature of OO.
15:09:55 <MisterN> Cale: your site on OO in haskell is very interesting
15:09:57 <sproingie> he's free to sneer at simula and its descendants, it makes them no less OO
15:10:10 <MisterN> and i think it proves nicely that OO is possible in haskell :)
15:10:23 <ddarius> MisterN: Define "OOP"
15:10:41 <DioCagnaccio> why code OO code in haskell?
15:10:42 <Cale> MisterN: just without inheritance or subtyping
15:10:48 <ddarius> sproingie: The descendants of Simula are free to sneer at Smalltalk and it makes it no less OO as well.
15:11:05 <sproingie> ddarius: exactly
15:11:06 <Cale> But to me, OO really means "coalgebraic"
15:11:10 <sproingie> it's not like OO is a calculus
15:11:27 <tensorpudding> coalgebraic?
15:11:38 <ddarius> sproingie: There is the sigma calculus by which neither Simula nor Smalltalk would (immediately) be OO.
15:11:40 <Cale> tensorpudding: Objects are defined by how you take them apart.
15:11:47 <MisterN> ddarius: i wish to avoid actually defining OO. but this really looks like it: http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
15:11:55 <Cale> tensorpudding: Which is the same thing as their responses to messages
15:12:09 <tensorpudding> ah
15:12:16 <ddarius> MisterN: I'm not asking you to provide an authoritative definition, I'm asking you to provide yours.
15:12:16 <sproingie> i always thought of pi calculus as the ultimate OO
15:12:46 <ddarius> sproingie: I agree (ish).  I think concurrency leads to something that is very natural and something I wouldn't mind calling THE OO.
15:12:47 <SimonRC> strike out those that do not apply:  http://paulgraham.com/reesoo.html
15:12:49 <SimonRC> :-)
15:12:55 <ddarius> sproingie: Look at the Blue and Deep Blue calculi.
15:13:00 <sproingie> ddarius: tho it's more the "untyped OO calculus"
15:13:02 <MisterN> ddarius: well, to me it's about objects and manipulating functions, a way of thinking. i suck at defining.
15:13:35 <ddarius> MisterN: What are "objects" and what constitutes "manipulating functions"?
15:14:31 <MisterN> ddarius: an instance of this would fit the concept: data GameObject = GameObject { updateObject :: GameState -> [Key] -> [GameObject], renderGameObject :: IO (), hitTest :: Point -> Bool }
15:15:13 <MisterN> ddarius: this type encapsulates its state behind methods (although they are purely functional, but that is no real problem)
15:15:46 <MisterN> ddarius: here, the state is implicit in the function values. this is very much like how you do OO in scheme.
15:15:58 <MisterN> doing OO in scheme is a lot of fun btw. :)
15:16:02 <sproingie> ddarius: got a link to deep blue calculus that isn't on citeseer?
15:16:06 <sproingie> citeseer seems to be down
15:16:27 <ivanm> citeseer seems to be down quite often :s
15:16:32 <ivanm> @hoogle "deep blue calculus"
15:16:32 <lambdabot> Parse error:
15:16:33 <lambdabot>   --count=20 ""deep blue calculus""
15:16:33 <lambdabot>              ^
15:16:35 <ivanm> @google "deep blue calculus"
15:16:41 <ivanm> gah, I'm mixing up hoogle and google!
15:16:48 <ivanm> hmmm... google seems to be down as well... :p
15:16:50 <lambdabot> Plugin `search' failed with: thread killed
15:17:02 <Botje> @hoogle `ls`
15:17:02 <lambdabot> Parse error:
15:17:03 <lambdabot>   --count=20 `ls`
15:17:03 <lambdabot>              ^
15:17:05 <sproingie> FATALITY
15:19:50 <ddarius> sproingie: Can't really find one.
15:20:28 <rgr> Why is the bracketing required here :  take 10 (iterate (2*) 1)  ? I'm not sure I follow that it is necessary but obviously it is.
15:20:59 <idnar> function application is left-associative
15:21:35 <idnar> so without it, you'd have (((take 10) iterate) (2*)) 1
15:21:51 <Vulpyne> rgr: If you have "x y z" that's parsed as "(((x) y) z)"
15:21:56 <idnar> and the parens around (2*) are necessary for a section
15:22:38 <SimonRC> ** ERROR: Too much concurrent IRC input.  Shedding load. **
15:25:05 <BMeph> sproingie: Perhaps look up Boudol on the INRIA site and hope. ;)
15:25:10 <sproingie> > take 10 (iterate (2*) 1)
15:25:11 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
15:25:16 <sproingie> > take 10 $ iterate (2*) 1
15:25:17 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
15:25:31 <ddarius> sproingie: Here's the blue calculus paper which was a predecessor to the deep blue calculus. http://www-sop.inria.fr/meije/personnel/Gerard.Boudol/popl97-abstract.html
15:25:37 <sproingie> i just love the hell out of $
15:25:48 <medfly> lovin' the hell out of it!
15:25:51 <ddarius> (or maybe note)
15:26:01 <EvanCarroll> hrm 1/3, 10/3, 100/3
15:26:08 <sproingie> ddarius: i get a 550 error :(
15:26:08 <EvanCarroll> hahah
15:26:13 <EvanCarroll> comments on the oreilly book
15:26:30 <byorgey> ivanm: you were looking for me?
15:26:51 * BMeph wishes there were a '<$' operator or somesuch, as the flip of '$'
15:27:02 <medfly> why?
15:27:13 <byorgey> BMeph: I call that >$>
15:27:23 <byorgey> it works nicely with >>>
15:27:29 * BMeph shudders
15:27:38 <byorgey> x >$> f >>> g >>> ...
15:27:46 <ivanm> byorgey: yeah, just let me remember why... ;-)
15:27:57 <byorgey> hehe
15:28:10 <BMeph> byorgey: I now know who to blame for Haskell's "line noise" complaints... ;)
15:28:18 <sproingie> haskellers
15:28:27 <ivanm> OK, how much of the mpppc package on hackage is actually you?
15:28:38 <ivanm> BMeph: heh
15:28:42 <byorgey> ivanm: me?
15:28:54 <ivanm> byorgey: well, your name is on it... http://hackage.haskell.org/package/mpppc
15:28:58 <byorgey> woah
15:29:08 <byorgey> amazing!  I must have coded it in my sleep
15:29:11 <ivanm> I'm guessing they took your boxes package or something
15:29:27 <byorgey> yeah, that's my guess too
15:29:37 <copumpkin> wow
15:29:54 <ivanm> byorgey: OK, in that case, with boxes, does it allow me to have infinitely long lines with indentation?  and how hard is it to convert from pretty to boxes?
15:29:54 <copumpkin> what does it take to be a multidimensional pretty printer?
15:30:18 <ivanm> copumpkin: well, they only allow up to n = 2 so far...
15:30:23 <copumpkin> oh
15:30:25 <ivanm> no 3D printing, no time stuff, etc.
15:31:16 <byorgey> ivanm: boxes should allow you to have infinitely long lines, I think, although it's been a while since I've thought about it
15:31:43 <ivanm> *nod*
15:31:57 <byorgey> ivanm: converting from pretty to boxes shouldn't be too hard, many of the combinators are similar
15:31:59 <ivanm> because pretty only allows me to pick one from indentation and long lines :@
15:32:03 <ddarius> sproingie: Here the National University of Singapore mirror which seems to have a certificate issue: http://citeseer.comp.nus.edu.sg/viewdoc/summary?doi=10.1.1.25.1919
15:32:54 * EvanCarroll switches from haskell book to orielly book for the time being
15:33:28 <byorgey> ivanm: hmm, actually, I might be lying about infinite lines
15:33:32 <rgr> idnar: thanks for explanation.
15:33:40 <byorgey> text t = Box 1 (length t) (Text t)
15:33:45 <byorgey> doesn't look good =(
15:34:11 <ddarius> sproingie: Some other work on the blue calculus is here: http://homepages.laas.fr/dalzilio//DalzilioS.html
15:35:54 <ivanm> byorgey: :(
15:36:24 <ddarius> infiniteText t = RectangularPrism 1 t
15:36:49 <byorgey> ivanm: you should still try it... there's a chance it just might be lazy enough...
15:37:10 <ddarius> byorgey: ... quite the optimist you are
15:37:12 <ivanm> byorgey: right
15:37:20 <byorgey> oh, wait, no it's not
15:37:31 <ivanm> when I say "infinitely long lines", I don't actually mean _infinite_, just really long
15:37:31 <byorgey> well, it would be if you switched it to use lazy naturals =)
15:37:45 <chrisdone> EvilTerran: did you learn why foldr works on infinite lists then?
15:38:18 <byorgey> ok, I'm off, good luck typesetting your infinite boxes
15:38:26 <ivanm> heh, thanks byorgey
15:44:21 <bnijk_> need free haskell ebooks,
15:44:25 <bnijk_> where to find them
15:44:27 <bnijk_> ?
15:44:45 <stroan> @locate rwh
15:44:46 <lambdabot> Unknown command, try @list
15:44:51 <gnuvince> bnijk_: google for "real world haskell" and "learn you a haskell for great good"
15:44:57 <bnijk_> i've seen both
15:45:02 <bnijk_> i was at the RWH site a second ago
15:45:03 <stroan> what's the lambdabot command for finding things like that?
15:45:08 <bnijk_> and it said you had to shell out 40 bucks for a pdf
15:45:17 <stroan> available in html for free
15:45:22 <stroan> on the site
15:45:25 <bnijk_> retarded
15:45:29 <bnijk_> o'reilly....
15:45:48 <danderson> feel free to buy it then. The book is worth it.
15:46:09 <bnijk_> define value
15:46:28 <danderson> you're a troll. Conversation terminated.
15:46:50 <bnijk_> excuse me?
15:46:55 <bnijk_> seriously
15:46:57 <yitz> @where rwh
15:46:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:46:58 <bnijk_> what the fuck is wrong with you
15:47:06 <yitz> @where lyah
15:47:06 <lambdabot> www.learnyouahaskell.com
15:47:14 * xternal is reading that now
15:47:16 <xternal> I like it.
15:47:26 <bnijk_> LYAH doesn't talk about monads
15:47:33 <bnijk_> i need a decent explanation of monads
15:47:41 <rgr> why do you think you are entitled to everything for free is probably his point. I bought RWH this week. A lot of hard work and effort went into it. But I use theonline version..
15:47:45 <tensorpudding> RWH has a big section on monads
15:47:53 <Cale> bnijk_: I've written some tutorials about monads which you might like.
15:47:58 <bnijk_> i don't think i'm entitled to everything for free...i do think i, and everyone else, am entitled to books for free
15:48:02 <bnijk_> Cale: link away
15:48:07 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
15:48:14 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
15:48:36 <rgr> why do you think you should get books for free out of curiosity? Althought is is :-)
15:48:37 <Cale> and (not really about monads, but if you just want to get started using I/O)  http://www.haskell.org/haskellwiki/Introduction_to_IO
15:48:38 <yitz> bnijk_: I highly recommend Cale's monad tutorials.
15:48:38 <tensorpudding> monads can compute, they can contain, they can even walk the dog
15:48:48 <bnijk_> rgr: take my word for it, as an economist
15:49:03 <bnijk_> finite demand and infinite supply means no price
15:49:10 <rwx> pl \(a,b) -> a:b:[]
15:49:14 <rwx> > pl \(a,b) -> a:b:[]
15:49:15 <lambdabot>   <no location info>: parse error on input `\'
15:49:19 <tensorpudding> use @pl
15:49:24 <rgr> bnijk_: you sound like a tight arse to me. But that is the other definition :-; If economists were so clever they'd all be milionaires.
15:49:28 <MoALTz> bnijk_: like with fresh water eh? ;)
15:49:31 <rwx> tensorpudding, how?
15:49:33 <bnijk_> no
15:49:37 <bnijk_> fresh water has finite supply
15:49:42 <tensorpudding> @pl \(a,b) -> a:b:[]
15:49:42 <lambdabot> uncurry ((. return) . (:))
15:49:58 <rwx> thanks
15:49:59 <rgr> And books don't?
15:50:04 <bnijk_> not ebooks
15:50:10 <MoALTz> fresh water has an infinite supply - it rains. information is rate limited in terms of duplicating, copying, etc
15:50:12 <bnijk_> well, finite, to be fair, but really, really, really big
15:50:15 <rgr> bandwisth and disk are free? What nonsense you spout.
15:50:20 <yitz> @pl \a b -> [a, b]
15:50:20 <lambdabot> (. return) . (:)
15:50:29 <bnijk_> water is different
15:50:30 <tensorpudding> books are worth the time it takes to write them
15:50:34 <MoALTz> (although i'm being a bit obtuse here)
15:50:38 <bnijk_> transportation, filtration, those cost way more than copying files
15:50:51 <bnijk_> the price is so low to copy a file, you can consider it to be zero
15:50:51 <Cale> If you really care about making a PDF, it's probably not so hard to make one from the HTML.
15:51:00 <bnijk_> yeah Cale
15:51:11 <bnijk_> i'll do it at work tomorrow
15:51:19 <stroan> there are pdfs of the book floating about, pdf prints of the html version
15:51:32 <Cale> But... given that you're reading it on a computer anyway, and there's not lots of inset math or anything, it usually doesn't matter, does it?
15:51:41 <tensorpudding> the html version looks okay
15:51:46 <bnijk_> Cale: not particularly...the 'p' is for 'portable' though
15:51:48 <BONUS> bnijk_: well to write a book, the thing you need the most is time imo. and no one has an infinite supply of time.
15:51:54 <tensorpudding> but print almost always looks better
15:51:55 <stroan> bnijk_: I would go so far as to recommend the html version. there's some good points made in the comments sections
15:52:03 <bnijk_> yeah BONUS, but compare that time to the number of readers
15:52:06 <tensorpudding> yes, the comments are nice
15:52:16 <Cale> I wonder how hard it would be to make a LaTeX version :)
15:52:23 <xternal> I have used the comments in conjunction with reading dead-tree as well, found it useful
15:52:36 <tensorpudding> of RWH?
15:52:39 <rgr> bnijk_: and the number of readers are influenced by the quality (hard work) of the authors. Who need to be compensated in some way. I'm sure your thanks go a long way though ...
15:52:40 <Cale> Yeah
15:52:45 <Cale> Probably not so hard.
15:52:51 <tensorpudding> probably not
15:52:52 <BONUS> but anyway that's OT
15:52:55 <Cale> Just grab the HTML and start doing s/// commands
15:52:59 <yitz> port it to pandoc first
15:53:12 <bnijk_> grabbing HTML and doing s/// commands++
15:53:16 <yitz> or docbook, or dita
15:53:29 <stroan> so many terminals open, all of them running ghci
15:53:35 <stroan> I need to manage my windows better...
15:53:35 <mauke> #perl would give you a beating for that
15:53:36 <lunabot>  luna: Not in scope: `perl'
15:53:53 <tensorpudding> having # as luna's trigger is a bit annoying
15:54:29 <copumpkin> ] nah
15:54:30 <lunabot>  luna: Not in scope: `nah'
15:54:36 <xternal> stroan: I find I get a little less window happy if I run a slime-like setup
15:54:45 <xternal> but I still go nuts.
15:55:14 <tensorpudding> emacs is pretty good with ghci
15:55:19 * xternal doesn't know enough haskell to know if slime-ishness would work with it
15:55:31 <xternal> I could imagine some issues.
15:55:33 <stroan> can I make haskell-mode run ghci with specific -l flags?
15:55:36 <mmorrow> tensorpudding: which alternate char do you suggest? (i didn't think of #irc-channels when i chose #)
15:55:39 <stroan> if so back to that I go
15:56:04 <tensorpudding> ] foo
15:56:05 <lunabot>  luna: Not in scope: `foo'
15:56:07 <mauke> ;obviously
15:56:10 <tensorpudding> using ] works
15:56:12 <mmorrow> tensorpudding: but anyhow, the goal was to choose a char that's least likely to be triggered
15:56:21 <mmorrow> tensorpudding: that's already used though
15:56:32 * bnijk_ figures out what fixed point combinators are
15:56:33 <mmorrow> ;
15:56:35 <bnijk_> ohhhhhh
15:56:47 <mmorrow> mauke: hmm
15:57:10 <tensorpudding> mmorrow: how many triggers do you need?
15:57:19 <tensorpudding> or do they do different things...
15:57:50 <tensorpudding> ,
15:57:50 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
15:57:58 <mmorrow> they do different things
15:58:00 <tensorpudding> [
15:58:03 <mmorrow> , and ] do the same thing
15:58:04 <lunabot>  luna: parse error on input `]'
15:58:10 <mmorrow>  # does something else
15:58:44 <tensorpudding> ; is a good choice i guess
15:59:12 <gwern> @hoogle a -> Maybe [a] -> Maybe [a]
15:59:13 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
15:59:13 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
15:59:13 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
15:59:41 <gwern> hm
15:59:46 <gwern> @botsnack
15:59:46 <lunabot>  :o
15:59:47 <lambdabot> :)
16:00:25 <bnijk_> you'll spoil them
16:00:31 <bnijk_> get away from there!
16:00:45 <gwern> > liftM ('a':) (Just "foo")
16:00:46 <lambdabot>   Just "afoo"
16:00:58 --- mode: ChanServ set +o mauke
16:01:05 --- mode: mauke set +v preflex
16:01:07 --- mode: mauke set -o mauke
16:01:20 <bnijk_> what does the fixed point combinator do on the identity function
16:01:24 <tensorpudding> > liftM2 (++) (Just "foo") (Just "bar")
16:01:25 <lambdabot>   Just "foobar"
16:01:33 <tensorpudding> > fix id
16:01:37 <lambdabot>   mueval-core: Time limit exceeded
16:01:41 <bnijk_> lol
16:01:50 <bnijk_> i should have seen that coming
16:02:13 <bnijk_> :t id
16:02:14 <lambdabot> forall a. a -> a
16:02:20 <bnijk_> fascinating
16:02:27 <MoALTz> @src fix
16:02:27 <lambdabot> fix f = let x = f x in x
16:02:58 <tensorpudding> fix is crazy
16:02:59 <yitz> > fix show -- my favorite
16:03:00 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:03:01 <bnijk_> @define f x = x**2
16:03:06 <shachaf> Are there any interesting (Just "another Haskell hacker") implementations?
16:03:15 <shachaf> > fix error
16:03:19 <bnijk_> that's not it
16:03:21 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
16:03:22 <bnijk_> > f x = x**2
16:03:24 <lambdabot>   <no location info>: parse error on input `='
16:03:39 <shrughes> @let f x = x**2
16:03:40 <lambdabot>  Defined.
16:03:43 <bnijk_> ok
16:03:45 <bnijk_> > fix f
16:03:45 <mauke> @undefine
16:03:46 <lambdabot>   Ambiguous occurrence `f'
16:03:46 <lambdabot>  It could refer to either `L.f', defined at <local...
16:03:52 <bnijk_> ugh
16:03:58 <bnijk_> @let ff x = x**2
16:03:59 <bnijk_> > fix ff
16:04:01 <lambdabot>  Defined.
16:04:06 <tensorpudding> > > let f = (^2) at fix f
16:04:07 <lambdabot>   mueval-core: Time limit exceeded
16:04:09 <lambdabot>   <no location info>: parse error on input `>'
16:04:21 <mauke> bnijk_: why give it a name first?
16:04:28 <shrughes> > foldr f z [1..]
16:04:29 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
16:04:36 <mauke> bnijk_: you could just say '> let ff x = x**2 in fix ff' or simply '> fix (**2)'
16:05:00 <bnijk_> mmn
16:05:01 <bnijk_> yes
16:05:05 <bnijk_> > fix (**2)
16:05:10 <lambdabot>   mueval-core: Time limit exceeded
16:05:21 <bnijk_> why can't it solve that?
16:05:29 <mmorrow> , fix (h . (g::Expr->Expr) . (f::Expr->Expr))
16:05:32 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
16:05:39 <shrughes> @src fix
16:05:39 <lambdabot> fix f = let x = f x in x
16:05:51 <mauke> bnijk_: it did, and the result was an infinite loop
16:05:55 <shrughes> bnijk_: that's fix right there -- it doesn't "solve" for the fixed point
16:06:09 <bnijk_> mmn
16:06:11 <mmorrow> bnijk_: if doesn't stop if the function happens to return the "same" value twice
16:06:16 <shachaf> shrughes: _|_ is a fixed point.
16:06:26 <shrughes> shachaf: it still doesn't solve for it
16:06:49 <shachaf> Is there ever a case where (fix f) isn't a fixed point of f?
16:07:00 <copumpkin> no
16:07:13 <shrughes> if you use unsafePerformIO
16:07:21 <bnijk_> fix is weird
16:07:21 <bd_> shachaf: No. fix f = let r = f r in r, so one way or another you're going to get a fixed point.
16:07:30 <mmorrow> @free fix
16:07:30 <lambdabot> f . g = h . f => f (fix g) = fix h
16:07:32 <bd_> The fixed point may be _|_ of course
16:07:40 <copumpkin> most often it is
16:07:41 <shachaf> bd_: Yep. So why not say that it "solves" it?
16:07:53 <tensorpudding> is there any functions that have non-_|_ fixed points?
16:08:04 <shachaf> > fix (1:)
16:08:05 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:08:05 <mmorrow> , fix (0:)
16:08:06 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:08:12 <shrughes> > fix ((1:) . scanl (+) 1)
16:08:13 <bd_> of course, if you use unsafePerformIO you can make the same function return something different if you invoke it more than once - but that still was a fixed point that once
16:08:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:08:14 <mmorrow> , fix (interleave [0..])
16:08:15 <lunabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16...
16:08:17 <mmorrow> , fix show
16:08:18 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\...
16:08:27 <bd_> > fix (const ())
16:08:28 <lambdabot>   ()
16:08:31 <shachaf> > fix (\f x -> if x < 1 then 1 else x * f (x - 1)) 5
16:08:33 <lambdabot>   120
16:08:36 <mmorrow> , levels (fix (\me -> Node () [me,me]))
16:08:37 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
16:08:49 <tensorpudding> okay, that's enough..
16:08:49 <mauke> > fix error
16:08:50 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
16:08:53 <bnijk_> > fix ("`':;.,_,.;:'`":)
16:08:54 <lambdabot>   ["`':;.,_,.;:'`","`':;.,_,.;:'`","`':;.,_,.;:'`","`':;.,_,.;:'`","`':;.,_,....
16:08:56 <bnijk_> wheeee
16:09:03 <bd_> In general, any function that's not strict on its argument has a fixed point
16:09:05 <tensorpudding> oh god, some of those are nasty
16:09:07 <mmorrow> fix error is a nice touch
16:09:18 <c_wraith> > fix $ const 5
16:09:19 <lambdabot>   5
16:09:27 <c_wraith> look, sometimes fix has a small result. :)
16:09:29 <mmorrow> bd_: that also returns some initial result without pulling on the input
16:09:42 <mmorrow> since it needs to produce something it can pull on first
16:09:46 <shachaf> > fmap fix return 5
16:09:47 <lambdabot>   5
16:09:47 <tensorpudding> huh, you can use fix to define the fibonacci sequence
16:09:48 <bd_> mmorrow: If it pulls on the input without returning an initial result, then it's strict on its argument.
16:09:57 <bnijk_> tensorpudding: do it
16:10:00 <mmorrow> bd_: hmm
16:10:02 <bd_> mmorrow: So we're saying the same thing :)
16:10:03 <shachaf> tensorpudding: You can use fix to do anything recursive.
16:10:04 * mmorrow considers that
16:10:06 <copumpkin> you can use fix to define primes if you really try
16:10:18 <MoALTz> wow
16:10:23 <copumpkin> I did it a few weeks ago
16:10:27 <copumpkin> but it was painful
16:10:27 <tensorpudding> ah, yes
16:10:35 <sproingie> fix still breaks my brain
16:10:45 <tensorpudding> the y combinator
16:10:49 <shachaf> copumpkin: Painful? More than the regular way of defining them?
16:11:02 <c_wraith> sproingie:  think of fix as replacing named recursion
16:11:10 <mmorrow> bd_: i can't decide if that really implies it's strict in its arg or not
16:11:11 <copumpkin> shachaf: it isn't that bad if you do it inefficiently
16:11:21 <MoALTz> there is a wikibook on fix. i didn't get around to reading it all
16:11:28 <c_wraith> > let fibs = 0 : scanl (+) 1 fibs in fibs
16:11:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:11:39 <mmorrow> bd_: well first, what definition of "f is strict in argument i" are you using?
16:11:42 <bd_> mmorrow: Okay, consider this: I evaluate (f x) to WHNF. This either does or does not evaluate x to WHNF - if it does, it can examine what constructor x used; otherwise it can't.
16:11:46 <MoALTz> http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
16:11:53 <c_wraith> > let fibs = (0:) . scanl (+) 1 $ fibs
16:11:57 <lambdabot>   not an expression: `let fibs = (0:) . scanl (+) 1 $ fibs'
16:12:01 <c_wraith> > let fibs = (0:) . scanl (+) 1 $ fibs  in fibs
16:12:01 <bd_> If it does evalute x to WHNF, it's strict on x; and therefore fix f will loop (producing _|_)
16:12:02 <copumpkin> > nubBy (((>1) .) . gcd) [2..]
16:12:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:12:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:12:14 <bnijk_> o.o
16:12:17 <c_wraith> > fix (0:) . scanl (+) 1
16:12:19 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
16:12:23 <c_wraith> > fix $ (0:) . scanl (+) 1
16:12:25 <bd_> If it does not evaluate x to WHNF, then it doesn't care what x is (at least for the purposes of bringing f x to WHNF). So fix f is defined.
16:12:26 <shachaf> > fix((1:).scanl(+)1)
16:12:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:12:32 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:12:35 <mmorrow> , fix (\me -> (0,fst me)) {- ? -}
16:12:36 <lunabot>  (0,0)
16:12:47 <c_wraith> fix just replaces named recursion.
16:12:50 <copumpkin> > nubBy (\x y -> x `mod` y == 0) [2..]
16:12:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:12:57 <bd_> mmorrow: Note that I'm only talking about evaluating f x or fix f to WHNF; any further examination would depend on what f is.
16:13:01 <yitz> > fix $ (1:) . (1:) . (zipWith (+) <*> tail)
16:13:02 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:13:28 <bnijk_> > [ x**x| x<-[1,4..1000], (x mod 30) > 15]
16:13:29 <lambdabot>   No instance for (GHC.Float.Floating ((a -> a -> a) -> t -> a1))
16:13:29 <lambdabot>    arising ...
16:13:36 <bnijk_> > [ x^x| x<-[1,4..1000], (x mod 30) > 15]
16:13:38 <lambdabot>   No instance for (GHC.Real.Integral ((a -> a -> a) -> t -> a1))
16:13:38 <lambdabot>    arising f...
16:13:43 <bnijk_> yipes
16:13:56 <mmorrow> bd_: (note that i don't have a particular one in mind ahead of time), how are you defining  "f is strict in argument i" here?
16:14:04 <mmorrow> (out of curiosity)
16:14:19 <shachaf> mmorrow: Is there more than one standard definition?
16:14:25 <bd_> mmorrow: f is strict in argument i if (i is _|_) implies (f i `seq` () is _|_)
16:14:27 <bnijk_> what am i supposed to do when i get that error
16:14:51 <mmorrow> shachaf: it's not that there's more than one definition, just that that statement is used to mean a few subtly different things
16:15:11 <mmorrow> so it's more that there's more that one concept sometimes associated with that statement
16:15:13 <bnijk_> > [ 2**x | x<-[1,4..1000], (x mod 30) > 15]
16:15:15 <lambdabot>   No instance for (GHC.Float.Floating ((a -> a -> a) -> t -> a1))
16:15:15 <lambdabot>    arising ...
16:15:35 <mmorrow> bd_: ok
16:15:35 <bnijk_> hey BONUS where did you go
16:15:41 <BMeph> > [ 2**x | x<-[1,4..1000], (x `mod` 30) > 15]
16:15:42 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:15:43 <lambdabot>    `GHC.Real.Integral t'
16:15:43 <lambdabot>   ...
16:15:50 <mauke> BMeph: ^
16:16:05 <bd_> mmorrow: It should be clear that if that is not true, then f i will never be _|_. Therefore fix f will never be _|_
16:16:16 <BMeph> > [ x^x| x<-[1,4..1000], (x `mod` 30) > 15]
16:16:17 <bnijk_> > [ 2^x | x<-[1,4..1000], (x `mod` 30) > 15]
16:16:17 <lambdabot>   [18446744073709551616,1978419655660313589123979,341427877364219557396646723...
16:16:18 <lambdabot>   [65536,524288,4194304,33554432,268435456,70368744177664,562949953421312,450...
16:16:32 <bnijk_> oh cool
16:16:35 <bnijk_> it starts with 65536
16:16:45 <bd_> Moreover, if it is strict, then fix f must examine the value of (fix f) in order to evaluate (fix f). This clearly results in an infinite loop, so (fix f) is _|_
16:16:47 <bnijk_> no secret why i suppose
16:16:58 <mmorrow> bd_: ah right, your statement is correct by construction essentially
16:17:06 <bd_> Essentially :)
16:17:09 <bnijk_> > [ 2^x | x<-[1,4..1000], (x `mod` 3) > 1]
16:17:10 <lambdabot>   []
16:17:23 <bnijk_> > [ 2^x | x<-[1,4..1000], (x `mod` 3) >= 1]
16:17:24 <lambdabot>   [2,16,128,1024,8192,65536,524288,4194304,33554432,268435456,2147483648,1717...
16:17:26 <BMeph> bnijk_: Because 2^16 is 65536? :)
16:17:30 <bnijk_> yes BMeph ;)
16:17:37 <bd_> But I think it's an interesting property to consider, that fix f is always defined on non-strict f. It may not be very meaningful of course ... :)
16:17:48 <bnijk_> > [ x^x | x<-[1,4..1000], (x `mod` 3) >= 1]
16:17:50 <lambdabot>   [1,256,823543,10000000000,302875106592253,18446744073709551616,197841965566...
16:18:26 <bnijk_> > [ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)
16:18:27 <lambdabot>   <no location info>:
16:18:27 <lambdabot>      lexical error in string/character literal at end o...
16:18:40 <bnijk_> > [ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", x > "h"]
16:18:41 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:18:41 <lambdabot>         against inferred type...
16:18:57 <bnijk_> what's that char to int function
16:19:07 <kmc> > ord
16:19:08 <lambdabot>   {'a'->97;'b'->98;'c'->99;'d'->100}
16:19:10 <shachaf> @hoogle Char -> Int
16:19:11 <lambdabot> Data.Char digitToInt :: Char -> Int
16:19:11 <lambdabot> Data.Char ord :: Char -> Int
16:19:12 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
16:19:20 <bnijk_> > [ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord x > ord "h"]
16:19:22 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:19:22 <lambdabot>         against inferred type...
16:19:29 <kmc> ord is a type specialization of fromEnum
16:19:29 <shachaf> Since when does lambdabot have a Show instance that does that?
16:19:33 <bnijk_> inferred type what
16:19:34 <mmorrow> bd_: (this piqued my attention since i've been thinking about strictness of args/related in the context of analyzing/optimizing haskell code recently)
16:19:35 <tensorpudding> > [(x,y)| x <- [1..100], y <- [1,100], (3*x+2*y) `mod` 10 == 1]
16:19:37 <lambdabot>   [(3,1),(7,100),(13,1),(17,100),(23,1),(27,100),(33,1),(37,100),(43,1),(47,1...
16:19:42 <rwx> i've had advanced math (set theory, topology, discrete); what would be the 'best' book to read to understand haskell?
16:19:42 <mauke> bnijk_: [Char]
16:19:56 <kmc> @more
16:20:07 <adu> rwx: RWH
16:20:08 <mmorrow> bd_: i like that definition of "strict in argument i" you gave
16:20:15 <bnijk_> > [ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord [x] > ord "h"]
16:20:16 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:20:16 <lambdabot>         against inferred type...
16:20:20 <bnijk_> err
16:20:44 <bnijk_> bugger
16:21:18 <bd_> mmorrow: Note that with that definition, _|_ is strict :)
16:21:21 <mmorrow> bd_: one interesting "of note" thing that i hadn't thought of before reading about it, is you can have situations where, say, arguments i and j of f are coupled wrt strictness
16:21:35 <bnijk_> how do i turn [Char] into Char
16:21:36 <bd_> coupled?
16:21:56 <shachaf> bnijk_: const 'a'
16:21:57 <copumpkin> bnijk_: head
16:22:02 <bd_> bnijk_: undefined
16:22:05 <copumpkin> last
16:22:06 <bnijk_> > [ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord $ head x > ord "h"]
16:22:07 <lambdabot>   Couldn't match expected type `[a]'
16:22:07 <lambdabot>         against inferred type `GHC.Types...
16:22:09 <copumpkin> (!! 2)
16:22:11 <bnijk_> > [ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord . head x > ord "h"]
16:22:13 <lambdabot>   Couldn't match expected type `[a]'
16:22:13 <lambdabot>         against inferred type `GHC.Types...
16:22:16 <bnijk_> haskell sucks i give up
16:22:28 <shachaf> bnijk_: Sigh... You want «ord 'h'», not «ord "h"».
16:22:38 <bd_> bnijk_: But seriously though, Char can represent something on the order of 2^32 values. [Char] can represent potentially 2^(how many bits of ram you have) values. You can't fit that many values into Char. What are you really trying to do?
16:22:39 <bnijk_> > [ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord x > ord 'h']
16:22:40 <lambdabot>   "uttinkitsnintrstinproprtytoonsirttixislwysinonnonstrittmynotvrymninuloours"
16:22:49 <bnijk_> how wonderful
16:23:03 <mmorrow> bd_: like, if arg i gets evaluated by f, then j will to, and possibly vice-versa (or not)
16:23:06 <bd_> bnijk_: So I guess what I'm trying to say is your question makes no sense, and you'll have to explain what you're trying to do.
16:23:15 <bnijk_> > fix ([ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord x > ord 'h']:)
16:23:16 <lambdabot>   ["uttinkitsnintrstinproprtytoonsirttixislwysinonnonstrittmynotvrymninuloour...
16:23:24 <bnijk_> > fix ([ x|x<-"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord x > ord 't']:)
16:23:26 <lambdabot>   ["uyxwyyvyuu","uyxwyyvyuu","uyxwyyvyuu","uyxwyyvyuu","uyxwyyvyuu","uyxwyyvy...
16:23:39 <copumpkin> fix (x:) == repeat x
16:23:44 <yitz> > sort "But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)"
16:23:45 <lambdabot>   "                             '),-....:BIIaaaaaabcccdddeeeeeeeeeeffffffgghh...
16:23:53 <bnijk_> lol
16:23:59 <mmorrow> bd_: a better way to say that is that a function f can be conditionally strict in an argument i dependent on whether argument j is evaluated
16:24:07 <mmorrow> (or not)
16:24:11 <bd_> hmm
16:24:19 <bd_> mmorrow: The function has to unconditionally evaluate at least one of those
16:24:34 <bd_> Or unconditionally evaluate none of them (completely non-strict)
16:24:56 <mmorrow> f x y z = if .. z .. then (if y then ... x `seq` () ... else ...) else ...
16:25:12 <shachaf> > fix the world
16:25:14 <lambdabot>   The world is now fixed.
16:25:19 <mmorrow> err, that's not the nest example actually
16:25:23 <mmorrow> *best
16:25:24 <bnijk_> that was easy
16:25:33 <mmorrow> since the else branch of the inner if could be taken
16:25:41 <bd_> Right, so f i j is non-strict on all of its arguments. If we look at (f i j) z, then (f i j) is strict, and may be undefined depending on i and j
16:26:21 <mmorrow> bd_: let me find and example of what was meant by an arg being conditionally strict in two args
16:27:15 <Apocalisp> So... comonadic IO is pretty interesting.
16:27:54 <bnijk_> > fix ([ x|"But I think it's an interesting property to consider,  that fix f is always defined on non-strict f. It may  not be very meaningful of course ... :)", ord x > ord 't']:)
16:27:56 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:27:56 <lambdabot>         against inferred type ...
16:28:02 <bnijk_> what
16:28:06 <rwx> since arrows are a generalization of monads (right?) why aren't they talked about more?
16:28:08 <bnijk_> no i didn't paste that
16:28:47 <bnijk_> > sort [x|x<-"The soul like the body may have a virginity. For the woman to yield it or for the man to take it is the act of love. Love (understood as the desire of good for another) is in fact so unnatural a phenomenon that it can scarcely repeat itself, the soul being unable to become virgin again and not having energy enough to cast itself out again into the ocean of another's soul.", ord x > ord 'r']
16:28:48 <lambdabot>   "sssssssssssssstttttttttttttttttttttttttttttttuuuuuuuuuvvvvvvwyyyyyy"
16:29:03 <bd_> :t the
16:29:04 <lambdabot> Not in scope: `the'
16:29:04 <bnijk_> stupid lambdabot
16:29:06 <bd_> :t world
16:29:07 <lambdabot> Not in scope: `world'
16:29:10 <bd_> :t fix the world
16:29:11 <lambdabot> Not in scope: `the'
16:29:11 <lambdabot> Not in scope: `world'
16:29:13 <bd_> :|
16:29:21 <rwx> > mergesort "hfskhskdfh"
16:29:22 <lambdabot>   Not in scope: `mergesort'
16:29:33 <rwx> default sort is mergesort?
16:29:44 <bd_> rwx: The default sort is unspecified :)
16:29:52 <rwx> :-)
16:29:56 <rwx> silly lambdabot
16:31:17 <yitz> rwx: is splits the list into singletons, then starts merging them in pairs
16:31:51 <yitz> rwx: so it's a bottom-to-top merge sort
16:32:20 <mmorrow> bd_: i'm having trouble finding any references (i can't remember where i was reading about that), but what i think was meant is:
16:33:24 <mmorrow> bd_: something like, a function (f x1 x2 x3 x4 x5) can be s.t. (x1,x3) evaluated ==> (x4, if x2 evaluated ==> x5 is evaluated)
16:33:37 <mmorrow> and stuff like that
16:33:43 <bd_> Hm, but what do you mean 'if x2 is evaluated'?
16:34:11 <mmorrow> bd_: if x2 happens to be evaluated to WHNF by (f a b c d e) `seq` ()
16:34:22 <bd_> Ah, but that's not the right casual relation, I don't think
16:34:36 <bd_> If you're saying that "If x2 is evaluated, regardless of the value of x2, x5 is evaluated"
16:34:46 <mmorrow> bd_: right. it depends on from what pov you're looking at this analysis/situation
16:34:48 <bd_> then what this really means is that "If (some condition), x2 and x5 are evaluated"
16:35:20 <mmorrow> are you trying to "solve" for the strictness of some params to be able to generate better code? or are you thinking about it from somewhere else? (rhetorical)
16:35:33 <bd_> We can observe that x2 is evaluated iff $condition, and x5 is evaluated iff $condition, and therefore x2 is evaluated => x5 is evaluated, but I'm not sure that conclusion is very interesting.
16:36:29 <mmorrow> bd_: what if you're generating code that checks the evaluatedness of x2, and now you're generating code for a branch from that test where you know that the iseval test was true?
16:36:42 <mmorrow> then you know x5 is evaluated, saving you am entry
16:36:44 <bd_> You can't check the evaluatedness of x2 in haskell.
16:36:56 <mmorrow> bd_: i'm talking about generating code in a haskell compiler
16:37:10 <bd_> Ahh, okay.
16:38:02 <mmorrow> yeah, this is what i meant by perspective, it gets confusing talking about it in different contexts because it seems like the pov you're (one) looks at it from is highly context-dependent
16:38:07 <rgr> can one display the code of a function in the interpreter from the name (so I don thave to switch buffers to the source package) ?
16:40:43 <Saizan> rgr: no
16:45:21 <dobblego> why does QuickCheck2 define a Monad for Gen but not an Applicative?
16:45:39 <ivanm> dobblego: ask the dev
16:45:46 <dobblego> but why!?
16:45:57 <ivanm> dobblego: as I tried to hint to you yesterday, maybe because Applicative wasn't that big/popular when QC2 was written
16:46:08 <ivanm> or else the dev has never heard of/used Applicative
16:46:08 <dobblego> I doubt that, QC2 is not that old
16:46:17 <ivanm> it was post Typeclassopedia don't forget ;-)
16:46:30 <dobblego> probably because everyone in the whole universe is using Monad while I prefer Applicative
16:46:49 <ivanm> 2.1 is over a year old, but IIRC there was unofficial 2.0 builds a while before that
16:46:55 <ivanm> dobblego: and there's that ;-)
16:47:03 <ivanm> <ivanm> or else the dev has never heard of/used Applicative
16:57:29 <ivanm> Axman6: don't you want to be a virtual cake anymore?
16:57:56 <Axman6> not really
17:00:14 <pastah> i love lazyness
17:00:36 * pastah generates an infinite list of random values without having to worry about it
17:01:01 <dolio> @quote laziness
17:01:02 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
17:01:02 <lambdabot> true functional programming), and you've got haskell
17:01:16 <dolio> @quote laziness.*can't.*write
17:01:16 <lambdabot> JonHarrop says: Absolutely, but you don't want laziness everywhere all the time because it means you can't write fast code.
17:02:56 <tensorpudding> so you boil lisp for an hour to sift out the parentheses and impurities, make a whitespace sauce with liberal syntactic sugar, and you have haskell a la mode
17:03:09 <copumpkin> mmmm
17:03:15 <copumpkin> now I'm hungry again
17:03:21 <ivanm> tensorpudding: heh
17:03:26 <pastah> @pl (\i -> ts !! i)
17:03:27 <lambdabot> (ts !!)
17:03:28 <ivanm> @remember tensorpudding so you boil lisp for an hour to sift out the parentheses and impurities, make a whitespace sauce with liberal syntactic sugar, and you have haskell a la mode
17:03:28 <lambdabot> I will never forget.
17:03:37 <ivanm> tensorpudding: was your food analogy suggested by your nickname? :p
17:03:43 <tensorpudding> no, because i'm hungry
17:04:08 <copumpkin> whoa
17:04:08 <ivanm> heh
17:04:12 <copumpkin> jdh was in here
17:04:18 <ivanm> copumpkin: he has been
17:04:25 <copumpkin> has he spoken?
17:04:29 <ivanm> oh, wait, just now...
17:04:36 <ivanm> copumpkin: wait, it wasn't him
17:04:38 <Axman6> :o
17:04:42 <ivanm> unless he's on holiday in australia...
17:04:43 <copumpkin> oh?
17:04:45 * dobblego giggles
17:04:48 <Axman6> yeah
17:04:49 <copumpkin> lol
17:04:50 <ivanm> @slap dobblego
17:04:50 * lambdabot would never hurt dobblego!
17:04:54 <dobblego> I own jdh30
17:04:59 <copumpkin> nice
17:05:03 <dolio> Heh.
17:05:07 <ivanm> [jdh30] (n=Rain@220-245-107-64.static.tpgi.com.au): Tony Morris
17:05:22 <ivanm> lambdabot: shut up and do as you're told!
17:07:47 <pastah> http://tetris.wikia.com/wiki/TGM_randomizer <-- translating this to haskell == NOT FUN
17:07:57 <bnijk_> do we have programs that compile things to C from machine code yet
17:08:03 <bnijk_> er, decompile
17:08:10 <copumpkin> hex-rays.com
17:08:11 <bnijk_> if not, what's taking so long
17:08:17 <copumpkin> it's hard
17:08:22 <copumpkin> information is lost, you need heuristics
17:08:37 <bnijk_> feh
17:08:55 <bnijk_> should be done by now ;)
17:09:00 <ksf> pastah, take out paper+pencil and convert that to ssa
17:09:07 <ksf> ...then stuff should be clearer
17:09:33 * ksf is a big fan of paper+pencil design
17:09:44 <bnijk_> can you imagine the wealth of code that will be lost from people stubbornly refusing to release it, even after it's no longer profitable
17:10:24 <allbery_b> it's an old problem
17:10:28 <ksf> can you imagine the total loss to society induced by people who don't present as a gift that what they can't turn into money?
17:10:51 <tensorpudding> we need a software that turns hand-drawn graphs into real ones
17:11:02 <ksf> not really.
17:11:06 <ksf> I could use a scanner, though.
17:11:20 <copumpkin> some undergrads here made something to do that for a class project a couple of years ago
17:11:44 <Adamant> copumpkin: where is here?
17:11:58 <tensorpudding> well, you have OCR software that can read words, maybe it could also make out boxes and arrows
17:12:13 <ksf> my drawings are usually full of leaps, ad-hoc generalisations and implicit fixed points I can't reconstruct from the drawing a year later.
17:12:20 <mmorrow> bd_: gah! our discussion led me to like 5 papers that i've now got to print out and add to the stack.... it seems to never get smaller
17:12:27 <mmorrow> bd_: :)
17:12:38 <ksf> it's more of a thinking tool than code itself.
17:12:49 <CoverSlide> there is raster to vector software
17:13:13 <copumpkin> Adamant: dartmouth
17:13:18 <Adamant> ah
17:13:22 <ksf> I rarely do boxes, it's just numbers, words, and (possibly directed) edges
17:13:27 <Adamant> good school
17:13:36 <pastah> ksf: doing my little state hacking thing here... i'm onto something...
17:14:10 <heterarchy> hola amigos
17:15:08 <dolio> mmorrow: I think I forgot to mention, but the guys who did the EPTS paper have a paper or two on constructing appropriately annotated EPTS terms from un-annotated terms.
17:15:21 <mmorrow> here's the coolest looking control-flow graph (that i've happened to render with graphviz) i've seen yet http://moonpatio.com/images/rfft.png
17:15:23 <dolio> Which is the part you were actually interested in, as I recall.
17:15:29 <mmorrow> it's a real fast fourier transform
17:15:54 <mmorrow> dolio: oh, interesting
17:16:19 <ivanm> mmorrow: where is this rfft function?
17:16:37 <mmorrow> dolio: so you're saying that would be how one might implement the type inference haskell needs/does given that your underlying type model is a PTS?
17:16:42 <mmorrow> ivanm: one sec
17:17:07 <mmorrow> ivanm: http://moonpatio.com/repos/MISC/fft-misc/rsplitfft.c
17:17:31 <ivanm> awwww, you mean it's not haskell code? :(
17:17:41 <mmorrow> dolio: that remind me too, (recapping to remind myself exactly what we were talking about)
17:18:12 <dolio> mmorrow: No, I'm talking about figuring out which lambdas/etc. can be annotated as erasible, without requiring the programmer to specify it.
17:18:12 <mmorrow> ivanm: ghc-produced asm rarely has even a single static loop :(
17:18:50 <copumpkin> wow, really?
17:18:59 <mmorrow> dolio: oh. and these are type lambdas you mean? (so this goes back to a old old discussion we had about this?)
17:19:00 <ivanm> mmorrow: so did you do that graph by hand?
17:19:33 <dolio> They don't have to be type lambdas, but type erasure is an obvious and large special case.
17:19:33 <mmorrow> ivanm: i have an asm parser, then collected the jmps and labels, then printed out dot
17:19:43 <ivanm> mmorrow: *nod*
17:20:12 <mmorrow> dolio: hmm, i'm confused, is this in response to our most recent discussion about this? or an older one?
17:20:25 <mmorrow> (i'm not sure what context to think about this in)
17:20:32 <dolio> Did we have a recent discussion about this?
17:20:57 <mmorrow> dolio: err, we were talking about impredicativity, then GHC's implem, then PTSs
17:21:01 <mmorrow> most recently
17:21:32 <mmorrow> but then we've also talked about that one paper by iirc sheard about type erasure in PTS
17:21:47 <mmorrow> which analyzes which part of the program can be erased
17:21:49 <dolio> Yeah, this has to do with the Sheard stuff.
17:21:54 <mmorrow> ahh, ok.
17:22:01 <mmorrow> cool
17:22:08 <patch-tag> any idea what package to install for the "opengl c" dependency required by haskell platform? (on ubuntu)
17:22:19 <dolio> Although, if you want to see the paper, I think you should look up the other author, Mishra-Linger.
17:22:27 <dolio> He has a thesis on the stuff, too.
17:23:00 <sproingie> i have a very sophisticated analyzer that determines i'm wasting my time and can therefore erase everything
17:23:13 <ivanm> patch-tag: check what debian uses
17:23:21 <ivanm> they have platform support in unstable now IIRC
17:23:58 <patch-tag> found a blog as well: http://nathanwiegand.com/blog/2009/07/haskell-platform-on-ubuntu.html
17:24:04 <patch-tag> looks rather dodgy but I'll try that
17:25:12 <gOcOOl> @src (++)
17:25:13 <lambdabot> []     ++ ys = ys
17:25:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:25:13 <lambdabot> -- OR
17:25:13 <lambdabot> xs ++ ys = foldr (:) ys xs
17:25:45 <mmorrow> dolio: nice, found it
17:27:22 <dolio> mmorrow: It's possible you've already read it. I seem to recall that last time we talked about this, you were saying they had implemented erasibility analysis, and I told you that they just had a type system whose rules ensured erasibility was sound...
17:27:46 <dolio> But, the analysis paper appears to pre-date the type system paper, so maybe we just read different papers.
17:27:53 <tensorpudding> @src foldr
17:27:53 <lambdabot> foldr f z []     = z
17:27:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:27:57 <mmorrow> dolio: ah right, i was referring to the algorithm in that sheard paper
17:28:02 <tensorpudding> yum yum tail recursion
17:28:46 <mmorrow> dolio: this one http://web.cecs.pdx.edu/~sheard/papers/FossacsErasure08.pdf
17:28:53 <copumpkin> omnmo
17:29:03 <mmorrow> dolio: aha, i see the co-author is this guy
17:29:08 <copumpkin> omnom
17:31:08 <dolio> mmorrow: Yeah, but the paper from '08 doesn't go into analyzing a normal language for erasure opportunities, other than "find CCs". The one from '07 appears to actually be about how to do that.
17:31:42 <mmorrow> oh?
17:32:07 <mmorrow> a sheard one? (i'm looking at http://web.cecs.pdx.edu/~sheard/)
17:32:16 <dolio> http://web.cecs.pdx.edu/~rlinger/publications/ErasabilityAnalysisForPureTypeSystems.Linger_Sheard.pdf
17:32:33 <enolan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5018#a5018
17:32:40 <MoALTz> > fix (\rec x -> rec $ (1+x)**0.5) 1
17:32:43 <enolan> Why doesn't this give bind: resource busy?
17:32:44 <lambdabot>   mueval-core: Time limit exceeded
17:32:52 <mmorrow> dolio: ah, sweet
17:32:55 <dolio> mmorrow: No, it's not on Sheard's page for some reason.
17:32:56 <enolan> It does the expected if the forkIO is removed...
17:33:59 <Asztal> enolan: it probably exits immediately after creating the threads -- it won't wait for them to finish before exiting
17:34:20 <cygnus> Where can I find Read and Show instances for Data.Time.Clock.UTCTime?
17:34:21 <enolan> It doesn't wait for threads to finish?
17:35:50 <cygnus> (actually, just Show.)
17:36:37 <ivanm> cygnus: maybe there aren't any?
17:36:50 <ivanm> try converting it to a different representation first?
17:37:16 <cygnus> Yeah. I just figured there has to be an instance out there somewhere. :)
17:37:25 <cygnus> But, there really should be one in Data.Time.Clock.
17:37:50 <ivanm> which package is this? time?
17:37:54 <cygnus> Yeah.
17:38:29 <ivanm> cygnus: ummm... UTCTime does have  ashow instance :s
17:38:37 <ivanm> cygnus: which version of time are you using?
17:38:51 <ivanm> Axman6: cut that out!
17:38:52 <ivanm> ;-)
17:39:01 <ivanm> cygnus: http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Clock.html#t%3AUTCTime
17:39:10 <ivanm> see? "Show UTCTime"
17:39:45 <cygnus> Hah. Well. I am not using 1.1.4! :)
17:39:54 <ivanm> which version are you using?
17:39:57 <cygnus> 1.1.3. :)
17:40:09 <Axman6> ivanm: ?
17:40:12 <ivanm> cygnus: still there...
17:40:20 <ivanm> Axman6: connecting and then disconnecting
17:40:23 <ivanm> ;-)
17:40:29 <Axman6> not my fault
17:40:39 <ivanm> _sure_ it wasn't...
17:41:40 <cygnus> ivanm: that's interesting, because it doesn't work for me.
17:41:44 * cygnus looks at ghc-pkg
17:43:27 <mmorrow> dolio: adding that one to the to-print list too...
17:43:33 <dolio> :)
17:44:00 <enolan> Asztal: looks like you're right. Waiting for them all to signal finishing gives the expected behavior. Thanks.
17:44:23 <dolio> mmorrow: You might want to just get the thesis. It looks like it includes the stuff from both papers, plus other stuff.
17:44:25 <mmorrow> dolio: it's interesting how they're using a SAT solver for the constraints, that's totally applicable to program analyses in general too
17:44:33 <dolio> Although, 328 pages is a lot to print out.
17:44:59 <mmorrow> dolio: heh, yeah might leave that one on-disk
17:46:31 <heterarchy> built ghc-6.12.0.20091118 but I'm confused why there aren't any extra libraries like parsec in it
17:46:58 <Axman6> did you build the extralibs?
17:47:46 <heterarchy> well, I didn't see any source package for that - maybe I'm blind or stupid
17:47:57 <heterarchy> and the tarball for 6.12 was so big I thought it was in there :/
17:48:25 <Asztal> they are moving to the haskell platform, IIRC
17:52:26 <ivanm> anyone know why all the haddock docs say that Data.Time.Clock.UTCTime has a Show instance, but ghci doesn't?
17:53:24 <Asztal> ivanm: I only get them if I import Data.Time.
17:53:26 <ivanm> the source doesn't have an instance, but it does have a typeable instance... is that where it's getting thw Show instance from?
17:53:29 <ivanm> Asztal: weird...
17:53:33 <ivanm> cygnus: ^^
17:54:03 <ivanm> can anyone say orphan instance? :s
17:54:17 <SamB_XP> huh. it looks like microsoft has come full circle with C:\Users ;-)
17:54:29 <ivanm> must be getting it from LocalTIme or Format or something
17:54:33 <ivanm> SamB_XP: waddaya mean?
17:54:52 <cygnus> Asztal: that did it.
17:54:54 <SamB_XP> well, that seems to be what they called it in NT 3.51 too ;-)
17:54:55 <cygnus> Why? :)
17:55:03 <Saizan> ivanm: the Show instance is probably defined in a module you didn't import in ghci
17:55:09 <ivanm> Saizan: yeah
17:55:15 <ivanm> I think its in Data.Time.Format or something
17:55:18 <ivanm> SamB_XP: heh
17:55:25 <cygnus> Data.Time doesn't seem to be special, expect it has different re-exports. Probably they have other importing side effects that make it work.
17:55:37 <ivanm> so they specify how to format it elsewhere to avoid cyclic dependencies between modules probably
17:56:31 <ivanm> yeah, I think they somewhere make all instances of FormatTime an instnace of Show
17:56:35 <ivanm> dunno where though
17:57:03 <cygnus> Ah, Data.Time.LocalTime.LocalTime, ironically.
17:57:06 <cygnus> Good grief.
17:57:15 <ivanm> heh
17:57:32 <blackh> How do you delete an item from a Data.Sequence (is a splitAt required?)
17:57:38 <ivanm> so whoever wrote time didn't read/get the memo that Show and Read are meant to be code representations? :p
17:57:45 <ivanm> blackh: might be... lemme have a look
17:57:54 <ivanm> but I think that's how I've done it with fingertrees...
17:58:06 <cygnus> At the very least, that is not quite the best source location for that instance. :)
17:58:38 <ivanm> cygnus: it's probably to avoid cycles
17:58:40 <Gracenotes> ivanm: at least, if there is a Read instance
17:59:04 <ivanm> Gracenotes: yeah
17:59:12 <ivanm> Show also helps with ghci debugging
17:59:24 <Gracenotes> if there isn't, Show can probably be suited otherwise if necessary, possibly at one's detriment :o
17:59:27 <ivanm> blackh: yeah, looks like you have to
18:00:29 <blackh> ivanm: I thought so - that's fine - just thought I was going mad for a second there.
18:01:18 <ivanm> blackh: unless you use Foldable or something?
18:01:42 <ivanm> Traversable also might have something
18:02:14 <ivanm> nope, they dont' :(
18:02:29 <blackh> ivanm: I think Foldable and Traversable can't do random-access stuff
18:03:23 <augur> guys, whats the function for getting the first index of something in an array :|
18:03:37 <tommd> @hoogle index
18:03:40 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
18:03:40 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
18:03:40 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
18:04:03 <blackh> augur: let (ix, _) = bounds ar
18:04:08 <augur> :|
18:04:10 <augur> obnoxious
18:04:29 <blackh> augur: At least I think that's what you mean!
18:04:44 <tommd> augur: So what exactly are you wanting?  elemIndex?  What blackh said?  Something else?
18:04:51 <augur> oh maybe elemIndex :o
18:07:20 <augur> i keep forgetting that in haskell theyre /lists/ not /arrays/
18:07:20 <augur> :p
18:08:12 <gwern> an easy mistake
18:08:27 <gwern> but the occasional n or n^2 implementation will remind you what's what
18:48:44 * hackagebot upload: gnome-keyring 0.2 - Bindings for libgnome-keyring (JohnMillikin)
18:49:17 <roconnor> LambdaCube is a 3D rendering engine written entirely in Haskell.
18:49:23 <roconnor> dependencies: OpenGL
18:49:24 <roconnor> ...
18:49:34 <roconnor> Does a 3D rendering engine not mean what I think it means?
18:49:45 <roconnor> and if so, what is it instead?
18:49:51 <SamB_XP> roconnor: indeed
18:50:01 <jmillikin> They wrote an engine, using an engine (yo dog)
18:50:02 <ddarius> roconnor: Possibly it doesn't have a 2D rendering engine...
18:50:04 <SamB_XP> evidently, it means the software that drives the API
18:50:07 <roconnor> ddarius: :D
18:50:35 <SamB_XP> games are often said to have 3D rendering engines, I believe
18:50:51 <SamB_XP> that do higher-level things than the APIs support
18:51:04 <jmillikin> Games have game engines; they typically handle much more than just rendering, such as physics, sound, network, etc
18:51:11 <roconnor> SamB_XP: do you have an example in mind.
18:51:16 <ddarius> roconnor: Actually finding a decent 2D rendering library is tricky and OpenGL is one of the better options.
18:51:17 <roconnor> I was thinking of the Doom engine
18:51:24 <roconnor> but that was a 3d rendering engine
18:51:30 <SamB_XP> jmillikin: yeah, but typically those components are semi-independant
18:52:04 <SamB_XP> I mean, the network and sound parts are a bit distant from the nitty gritty of how to get geometry on the screen
18:53:06 <ddarius> roconnor: But according to the overview, it does leave the graphics to an (arbitrary) rendering backend such as OpenGL or DirectX.
18:53:31 <roconnor> the 3d-graphics?
18:53:42 <SamB_XP> hey, it needs *some* way of mesh-"blitting"
18:54:04 <ddarius> "The code sits between the low-level C API (raw OpenGL, DirectX or anything equivalent; the engine core is graphics backend agnostic) and the application, and gives the user a high-level API to work with."
18:54:44 <SamB_XP> every 3D game that's any good uses one ;-)
18:54:58 <ddarius> roconnor: I'm pretty sure it uses OpenGL or DirectX to do (3D) rendering, which is, of course, the right thing to do with modern graphics hardware.
18:56:10 <SamB_XP> indeed
18:56:24 <roconnor> ddarius: that makes it a Utility Library?
18:56:33 <roconnor> rather than a 3D rendering engine?
18:56:45 <SamB_XP> roconnor: no, that's what these things are called, okay?
18:56:56 <roconnor> really?
18:57:03 <SamB_XP> yeah, really
18:57:11 <roconnor> SamB_XP: I can't tell if you are serious or not.
18:57:18 <ddarius> roconnor: Nowadays, OpenGL/DirectX -is- the low-level interface (arguably).  It is what the graphics card vendors provide.
18:57:20 <nvoorhies> a rendering engine is a word processor to opengl's printer driver, basically
18:57:22 <SamB_XP> you seem to be confused and thinking that the graphics hardware is called that
18:57:37 * thunderbolt likes nvoorhies analogy
18:57:56 <SamB_XP> yeah, nvoorhies has explained it in one sentance ;-)
18:57:57 <tensorpudding> lol, that is a good analogy
18:58:01 <nvoorhies> OpenGL's always been on the low level side of things, even back when it was competing with PHIGS and other retained mode APIs
18:58:04 <roconnor> SamB_XP: well, normally I'd reserve the term for software.
18:58:33 <ddarius> roconnor: One could make an analogy with saying a file manager is written "entirely in Haskell" even though it uses the OS to actually read and write data.
18:58:46 <SamB_XP> well, like your printer driver, OpenGL ideally does as little as possible
18:58:51 <ddarius> roconnor: As fun as writing a software renderer is, those days are unfortunately over.
18:58:53 <SamB_XP> and leaves the work to the hardware
18:58:57 <roconnor> sure
18:59:01 <roconnor> I agree those days are over
18:59:03 <SamB_XP> ddarius: are not!
18:59:12 <roconnor> but I don't know if it means we change to change what the words mean.
18:59:15 <SamB_XP> you just have more interesting ways to write them ;-)
18:59:23 <roconnor> that seems like a confusing thing to do.
18:59:37 <SamB_XP> roconnor: the words have meant this for a while now
18:59:57 <roconnor> SamB_XP: did it change in the last 10 years?
19:00:01 <ddarius> roconnor: I probably wouldn't call it a "3D rendering engine" but then I did write some (toy) software rendering code.
19:00:06 * roconnor took his graphics course 10 years ago
19:00:12 <ddarius> roconnor: Most likely.
19:00:19 <roconnor> damn it
19:00:23 <roconnor> that is stupid
19:00:26 <SamB_XP> roconnor: how often do you hang out with folks from the industry ?
19:00:33 <roconnor> almost never
19:00:45 <SamB_XP> well, that would be why you're out of touch with the lingo ;-P
19:01:00 <SamB_XP> the software does more work than ever, really
19:01:13 <roconnor> SamB_XP: like what?
19:01:16 <SamB_XP> it's just different work
19:02:00 <SamB_XP> roconnor: it has to figures out what to draw, where, when!
19:02:30 <thunderbolt> Here, now!
19:02:45 <SamB_XP> it just has far more sophisticated primitives than it used to
19:03:36 <thunderbolt> Anyone know of a good, simple, discrete time simulator written in haskell?
19:04:18 * ddarius can't wait until raytracing coprocessors are commonplace.
19:04:32 <roconnor> oh okay
19:04:40 <roconnor> rederning engines go from models to pixels
19:04:48 <roconnor> I guess openGL doesn't do all of that.
19:05:05 <SamB_XP> roconnor: well, from models to GL/DX calls, at least
19:05:30 <p_l> roconnor: that was OpenInventor's role (model management etc.)
19:05:49 <Adamant> ddarius: how many years off do you think that is?
19:06:04 <h20xt> can anyone tell me why this http://pastebin.com/m70bcb9b1 gives me an 'hPutBuf: failed (Bad address)' error on runtime
19:07:50 <p_l> OpenGL actually succeeded due to being close to hardware, unlike rest (also, didn't SGI hw actually interpret GL calls directly?)
19:08:01 <blackh> h20xt: Why are you doing it like that?
19:08:12 <h20xt> i don't know my other options
19:08:16 <h20xt> i looked around for a while
19:08:21 <h20xt> but this is what i came up with
19:08:28 <h20xt> im trying to write bitmap images
19:08:39 <h20xt> i came up with something, but it was incredibly slow
19:09:06 <blackh> h20xt: Just thought I'd ask!
19:09:39 <h20xt> blackh: sorry, out of curioisty what is the best way to do something like this?
19:10:43 <roconnor> h20xt: bytestring would be better
19:10:57 <blackh> h20xt: I am not sure why it isn't working... but anyway, the best way to do it depends to a certain extent on what your code is doing.
19:11:03 <roconnor> I'm not sure what is best for serializing arrays
19:11:17 <h20xt> its not serializing arrays i want to do
19:11:26 <h20xt> what i really want is to serialize a c type structure
19:11:33 <h20xt> bitmap header information
19:12:06 <blackh> h20xt: The binary package on hackage is a good way to do this sort of thng.
19:13:02 <BMeph> h20xt: The biggest problem (for you) is that by declaring your data as [Word8], you have effectively forced your list to be of size 256. This is probably not what you thought you were doing. :)
19:13:40 <h20xt> BMeph: is the type variable for the array the same as the size?
19:13:45 <roconnor> @type newArray
19:13:47 <lambdabot> Not in scope: `newArray'
19:13:52 <roconnor> @hoogle newArray
19:13:53 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
19:13:53 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
19:13:53 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
19:13:54 <BMeph> h20xt: At least, I'm hoping this, since you try to stuff it in a 16M buffer as if it were filling it all. :\
19:14:07 <h20xt> @type take
19:14:09 <lambdabot> forall a. Int -> [a] -> [a]
19:14:28 <roconnor> oh Foreign.Marshal.Array
19:14:52 <h20xt> wait how am i limiting the size to 256?
19:15:05 <roconnor> ya, how is he limiting to size 256?
19:15:08 <blackh> h20xt: BMeph is right! That'll be the reason for the crash.
19:15:18 <blackh> > length ([0..]::[Word8])
19:15:19 <lambdabot>   256
19:15:26 <roconnor> :D
19:15:28 <roconnor> of course
19:15:35 <h20xt> what is that though?
19:15:42 <h20xt> the index is just assumed to be the same type?
19:15:52 <blackh> h20xt: What you probably want is replicate sz 0 :: [Word8]
19:15:54 <roconnor> h20xt: [0..] only goes upto maxbound
19:16:02 <h20xt> oh
19:16:03 <h20xt> haha
19:16:03 <roconnor> > [0..
19:16:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:16:05 <roconnor> > [0..]
19:16:05 <h20xt> it increments
19:16:06 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:16:10 <h20xt> i thought it was repeated zeros
19:16:11 <h20xt> doh
19:16:13 <BMeph> h20xt: If I understand what you're asking, I'd say "not usually", but the way you declared it to be, you're forcing it to be so. Yeah, roconnor spotted it. :)
19:16:21 <tensorpudding> > repeat 0
19:16:22 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:16:27 <h20xt> thanks you guys
19:16:34 <h20xt> but so i should look at bytestring
19:17:05 <h20xt> i thought that might be a pain breaking up my 4 byte words, then i have to deal with Data.Bits, but I should probably do it that way
19:17:15 <blackh> h20xt: Take a look at 'binary'
19:17:29 <h20xt> blackh: what is the best way to get those packages?
19:17:45 <blackh> h20xt: cabal update ; cabal install binary
19:18:30 <blackh> h20xt: If you haven't got the cabal utility, you'll have to install that.
19:18:37 <h20xt> blackh: perfect, thanks, i just did
19:18:39 <ivanm> @where cabal-install
19:18:39 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
19:18:49 <h20xt> pacman ;)
19:19:53 <ivanm> h20xt: :o are you telling me dons hasn't provided a binary package for arch?
19:20:21 <h20xt> ah
19:20:24 <h20xt> there is one in aur
19:20:53 <sileni> hello everyone
19:21:01 <blackh> hello!
19:21:10 <sileni> im trying to implement the functionality of the last function
19:21:24 <roconnor> > last [1,2,3]
19:21:25 <lambdabot>   3
19:21:34 * ivanm waves idly in sileni's general direction
19:21:38 <sileni> i want to do something like last1 ns = (ns !! (length ns -1))
19:21:40 <roconnor> > last []
19:21:41 <lambdabot>   * Exception: Prelude.last: empty list
19:21:52 <h20xt> :(
19:21:54 <sileni> but it says unexpected =
19:22:00 <copumpkin> :t let last xs = const [] in last
19:22:01 <lambdabot> forall t b a. t -> b -> [a]
19:22:11 <ivanm> sileni: if you're doing it in ghci or something, you'd need to use a let
19:22:23 <sileni> im doing this in Hugs
19:22:27 <ivanm> sileni: right
19:22:31 <roconnor> > let last1 ns = (ns !! (length ns -1)) in last1 [1,2,3]
19:22:32 <lambdabot>   3
19:22:33 <ivanm> sileni: you have to use let to define functions
19:22:38 <sileni> wow
19:22:42 <sileni> thank you very much
19:22:43 <ivanm> like copumpkin and roconnor did
19:22:47 <ivanm> @src last
19:22:47 <sileni> very helpful channel
19:22:47 <lambdabot> last [x]    = x
19:22:47 <lambdabot> last (_:xs) = last xs
19:22:47 <lambdabot> last []     = undefined
19:22:51 <ivanm> ...
19:23:03 <roconnor> , let last1 ns = (ns !! (length ns -1)) in last1 [0..]
19:23:07 <lunabot>  Killed.
19:23:29 <roconnor> , let last1 ns = (ns !! (length ns -1)) in last1 [0,0,0..]
19:23:30 <lunabot>  luna: parse error on input `..'
19:23:36 <roconnor> , let last1 ns = (ns !! (length ns -1)) in last1 [0,0]++[0..]
19:23:37 <lunabot>  luna: No instance for (GHC.Num.Num [a])
19:23:40 <roconnor> , let last1 ns = (ns !! (length ns -1)) in last1 ([0,0]++[0..])
19:23:45 <lunabot>  Killed.
19:23:58 <roconnor> , let last1 ns = (ns !! (length ns -1)) in last1 [minBound..]
19:23:59 <lunabot>  ()
19:24:12 <blackh> sileni: We love it when people are learning Haskell!
19:24:19 <roconnor> , let last1 ns = (ns !! (length ns -1)) in last1 [(minBound :: Int)..]
19:24:22 <copumpkin> speak for yourself! I hate it!
19:24:23 <lunabot>  Killed.
19:24:29 <sileni> so it should be let last1 ns = (ns !! (length ns -1))?
19:24:34 <tensorpudding> lunabot is killing everything
19:24:34 <ivanm> copumpkin: heh
19:24:39 <roconnor> , let last1 ns = (ns !! (length ns -1)) in last1 ([0,0]++[(minBound :: Int)..])
19:24:43 <lunabot>  Killed.
19:24:49 <copumpkin> ivanm: heh to you
19:24:51 <blackh> sileni: Yes, that's right
19:24:52 <roconnor> damn
19:25:00 <sileni> blackh: coming from heavy cpp background haskell is so much easier for simple coding
19:25:05 * ivanm puts up a heh-shield
19:25:05 <roconnor> , length [(minBound :: Int)..]
19:25:08 <sileni> functional programming is amazing
19:25:11 <lunabot>  Killed.
19:25:18 <blackh> sileni: I have done an awful lot of C++ myself
19:25:28 <johnw> roconnor: you can't take the length of an infinite series
19:25:35 <blackh> sileni: I agree!
19:25:47 <roconnor> johnw: it isn't infinite.
19:25:52 <copumpkin> johnw: yeah you can
19:26:10 <johnw> , length [1..]
19:26:16 <lunabot>  Killed.
19:26:23 <sileni> blackh: now it says unexpected end of input
19:26:24 <sileni> :S
19:26:24 <copumpkin> > genericLength [1..] > (4 :: Natural)
19:26:25 <lambdabot>   True
19:26:34 <conal> :)
19:26:37 <sileni> let last1 ns = (ns !! ((length ns)-1))
19:27:08 <ManateeLazyCat> When i try to forkProcess, it will block current process when child process is *main loop*, so need other thread to do forkProcess?
19:27:26 <blackh> sileni: That's correct - it should work.  You can leave out some of the parentheses, e.g. let last1 ns = ns !! (length ns - 1)
19:27:35 <blackh> sileni: I don't know why it's saying that - I've never used hugs in my life
19:27:47 <sileni> you use ghc?
19:27:52 <copumpkin> sileni: everyone does
19:28:33 <MakoryuOnIce> sileni: The other implementations of Haskell aren't really useful these days
19:28:40 <sileni> ok
19:28:44 <MakoryuOnIce> sileni: The only other complete one is Hugs, I think
19:28:54 <MakoryuOnIce> And it won't run most code you find "in the wild"
19:29:03 <copumpkin> MakoryuOnIce: why are you on ice?
19:29:15 <MakoryuOnIce> copumpkin: You know, I have no idea
19:29:24 <copumpkin> fair enough :)
19:29:55 <sileni> ghc is 215 mb o-0?
19:32:20 <Makoryu> sileni: I can't think of any compiler that is both useful and small
19:34:21 <sileni> Makoryu: making me cry
19:34:56 <Makoryu> sileni: Sorry. The same goes for any language, really.... For example, GCC (C and C++ compiler) is huge, and takes forever to build
19:34:57 <sileni> Makoryu: to test stuff with ghc i just write code to a file like main { cod here } .. then ghc filename?
19:35:18 <sileni> Makoryu: oh no not worried about ghc already have it installed ><
19:35:25 <Makoryu> sileni: Ah
19:35:32 <Makoryu> sileni: The file extension you want is .hs
19:35:43 <sileni> yes
19:35:46 <sileni> i have that
19:36:08 <sileni> ghc is complaining on a where statement
19:36:39 <Makoryu> sileni: Paste your code somewhere
19:36:47 <Makoryu> codepad.org for example
19:37:07 <mwc> What's the best way of ensuring that AC_INIT in a configure.ac and the cabal file have the same version/name? I'm trying to avoid repeating it
19:37:48 <mwc> sed the name and version out of the .cabal?
19:38:42 <Cale> @hpaste
19:38:42 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:39:12 <sileni> Makoryu: http://codepad.org/39ioSO6Q
19:39:28 <Cale> sileni: tabs
19:39:40 <Makoryu> Cale: Good lord, that's the least of his problems
19:39:45 <Cale> Well, yes
19:39:57 <blackh> sileni: Take the {'s out...
19:39:57 <Cale> But the first step to cleaning things up: configure your text editor not to put tabs in your source code.
19:39:59 <sileni> Cale, i thought using {} explicitly takes care of that
19:40:04 <Cale> sileni: well, yes
19:40:12 <sproingie> sileni: if you just want to run one file of code for testing, you might want runhaskell instead
19:40:20 <Cale> but if you use {}'s, you also need semicolons
19:40:26 <Makoryu> sileni: Using {} requires that you also use explicit semicolons
19:40:32 <sileni> ah
19:40:35 <blackh> sileni: Get rid of 'main', or replace it with module Main where
19:40:45 <Cale> also... yeah, that main thing is just weird.
19:40:46 <Makoryu> sileni: Also, "main { ... }" should not be there
19:40:57 <sileni> so just top of the file it should say module Main?
19:41:00 <mwc> packages like X11 don't seem to bother, and alas, there's a mismatch between the versions in configure.ac and X11.cabal :(
19:41:07 <Makoryu> sileni: No, write "module Main where { ... }"
19:41:14 <Cale> sileni: Either   "module Main where"   or nothing at all
19:41:38 <Makoryu> sileni: If you leave out "module Main where" then the compiler will insert it for you
19:41:45 <Cale> sileni: Main is the default module name anyway
19:42:21 <Cale> sileni: If you're using vim, you'll want to put  set expandtab  in your .vimrc
19:42:35 <Cale> Most text editors have a way to expand tabs into spaces.
19:42:37 <sileni> Cale: how did you know i was using vi
19:42:47 <Cale> sileni: I didn't, I just guessed.
19:43:20 <Cale> Most people around here use vim or emacs.
19:43:41 <tensorpudding> notepad!
19:43:42 <sileni> so the file should be module main where { code here } ?
19:43:51 <Cale> sileni: case is important
19:43:57 <sileni> module Main
19:44:04 <sileni> but then ghc says main function is not found
19:44:16 <Cale> Yeah, just leave the module declaration out.
19:44:28 <Cale> Oh, you're trying to compile the code to an executable?
19:44:31 <Makoryu> sileni: http://codepad.org/6PmsKOgo <- That's because it can't compile your file into a program with no main function
19:44:34 <Cale> Don't do that.
19:44:36 <sileni> i just want to test the codes
19:44:38 <Cale> Just load it in ghci
19:44:39 <ksf> Cale, does that mean that you're in favour of the proposal to outlaw tabs in h'?
19:44:45 <Cale> ksf: Absolutely.
19:44:56 <SamB_XP> ksf: those things are still allowed ?
19:44:57 <Cale> ksf: I think tabs should be an outright lexical error.
19:45:05 <ivanm> ksf: as am I
19:45:08 <Makoryu> Does anyone besides mauke actually use tabs in Haskell?
19:45:10 <sileni> omg
19:45:15 <ivanm> mauke uses tabs? :o
19:45:18 <sileni> thats what i was looking for ghci
19:45:19 <sileni> ><
19:45:22 <Makoryu> sileni: Heh >_>
19:45:26 <sileni> i didn't know there was interactive mode haha
19:45:30 <dancor> Makoryu: i know of no one.
19:45:54 <sproingie> sileni: have you read a tutorial yet?
19:45:59 <Cale> sileni: ghci will let you load your declarations from a file, and then you can input expressions and test things
19:46:10 <sproingie> i don't know of any recent ones that don't start with the interpreter
19:46:12 <sileni> sproingie: yea on how to use Hugs not ghci the book uses hugs
19:46:20 <Makoryu> sileni: In interactive mode, remember that you have to use "let foo =" instead of just "foo =" to define new functions
19:46:26 <sproingie> old book
19:46:29 <Makoryu> sileni: And yes, I know this is confusing
19:46:45 <Makoryu> sileni: GHCi is mostly the same as hugs
19:47:04 <Cale> (but you probably don't really want to define new functions in ghci, since it's awkward to define anything longer than a line, and things go away when you reload your file
19:47:45 <mauke> Makoryu: I don't use tabs in Haskell (anymore)
19:47:51 <Cale> A good way of doing things is to keep two terminals open: one with your editor and one with ghci
19:47:53 <dancor> Cale: do you know if it's possible to make ghci do incremental compilation (only reloading files which change)
19:47:59 <Makoryu> mauke: O RLY
19:48:13 <Cale> dancor: I don't know.
19:48:17 <sileni> hurray!!!!!
19:48:18 <sileni> it works
19:48:23 <sileni> thats just wayy too sexeh
19:48:28 <Cale> dancor: If you use ghc to compile things, it will just load the .o files though
19:48:31 <Makoryu> Cale: Who runs editors in terminals these days? I mean, except ed users :p
19:48:39 <sproingie> me
19:48:42 <Cale> Makoryu: vim works well from a terminal
19:48:43 * ball <-
19:48:49 <Cale> (I can even use the mouse :)
19:48:54 <Makoryu> Cale: And gvim works better!
19:49:14 <Cale> Makoryu: but that opens a new window
19:49:32 <Cale> ;)
19:49:33 <sproingie> usually run emacs locally but i'll pull it up on the host on occasion
19:49:42 <dancor> ah, so you can do a ghc compile and reinvoke ghci anytime after code change
19:49:50 <sproingie> remote file editing in emacs is still a little glitchy
19:49:55 <Makoryu> Cale: Presumably you're using xmonad... So how is this a problem, again? ;)
19:50:12 <Cale> Makoryu: Not unless xmonad gets better support for floating windows.
19:50:21 <Cale> I hate tiling windowmanagers
19:50:43 <dancor> xmonad has any support for floating windows?
19:50:54 <Cale> dancor: Yeah, a bit.
19:50:58 <SamB_XP> dancor: for dialog boxes, I gather
19:51:35 <camio> Anyone know what the deal is with idioms? Should we stop using the term applicative functor now? Every recent paper I read likes to call them idioms.
19:51:52 <dancor> i tile my terminals with wmctrl in a non-tiling window manager.  just so i can still use crazy floating stuff if needed
19:51:52 <SamB_XP> camio: the papers are silly, I guess ...
19:51:53 <Cale> I've tried xmonad and it was interesting, but like all tiling windowmanagers I've ever seen, it was completely unaware of the contents of my windows, and would squish them into shapes where they were useless.
19:52:01 <sileni> this channel strictly no homework question?
19:52:12 <SamB_XP> sileni: heck no
19:52:21 <Cale> sileni: You can ask homework questions, but people might answer them and you'll fail the final.
19:52:22 <SamB_XP> unless it says that in /topic somehwere ?
19:52:26 <camio> SamB_XP: huh?
19:52:41 <sproingie> wait is that what an idiom is?
19:52:43 <SamB_XP> that is, homework questions are welcome
19:52:46 <sileni> Cale: hehe i do the work just need to see what im missing
19:52:49 <sileni> http://codepad.org/6QnlfE3F
19:53:05 <mauke> sileni: variables must start with a lowercase letter
19:53:07 <sileni> in that im supposed to fidn three faults, the first one i see is N is capital
19:53:07 <sileni> yea
19:53:08 <Cale> sileni: ah, "a" and "xs" need to line up
19:53:10 <SamB_XP> sproingie: no, an idiom is some phrase that doesn't make any sense unless you already know what it means
19:53:11 <sileni> and the layout
19:53:13 <sileni> yes
19:53:16 <ksf> Cale, that's why fullscreen is a default layout in xmonad
19:53:17 <mauke> do ho ho
19:53:20 <camio> sproingie: That's what they're calling Applicative functors lately. I've 4/4 recept papers I've read call AF's idioms.
19:53:20 <sileni> but i can't see the last one
19:53:22 <sproingie> i think "applicative" is the preferred term
19:53:37 <ksf> Cale, navigate to the proper window, and meta+space
19:53:49 <sproingie> i google "haskell idiom" and it pulls up, well, haskell idioms.  in the normal sense.
19:53:50 <Cale> ksf: I don't like fullscreen either
19:54:04 <Cale> ksf: I never even fullscreen my web browser
19:54:10 <ksf> there's a command to make a window the main window, too.
19:54:17 <camio> Arg. I mean I've read 4 recent papers and they've all called them idioms. The first one had an explination for the new name. Lemme see if I can find it...
19:54:17 <ksf> dunno remember which, though.
19:54:21 <sileni> Cale: do you see the 3rd one?
19:54:36 <ksf> and I seem to be incapable of deciding whether I want two shells on top or next to each other
19:54:39 <mauke> sileni: the third problem is that there are only two
19:54:53 * SamB_XP only fullscreens his web browser when it gets really cramped in there due to an oversized site layout or google reader's chrome ...
19:54:54 <Cale> sileni: 3rd what?
19:55:01 <Cale> sileni: Oh, N should be n
19:55:06 <sileni> Cale, there are 3
19:55:13 <mauke> sileni: no, there aren't
19:55:13 <sileni> Cale, yes i got that and the layout
19:55:18 <wdonnelly> sileni: it seems not, it runs with just those two fixes
19:55:22 * ksf uses tab layout for his firefox windows
19:55:30 <ksf> ...they've got a dedicated workspace.
19:55:34 <ksf> as does xchat
19:55:57 <ksf> but then I'm on a dual-screen setup
19:57:28 <camio> I've seen idioms in "The bird tree", "Idioms are oblivious, arrows are meticulous, monads are promiscuous", and another paper that had the explination for the name change that I can't find.
19:58:06 <camio> I can see why the new name is popular, it is much shorter for instance.
19:58:15 <ksf> applicative functors are called applicative because the function you fmap is inside the functor itself, not pure.
19:58:24 <ksf> :t <$> -- functor
19:58:25 <lambdabot> parse error on input `<$>'
19:58:31 <ksf> :t (<$>) -- functor
19:58:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:58:39 <ksf> :t (<*>) -- applicative functor
19:58:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:59:19 <SamB_XP> camio: I think the "idioms are ..." paper just did it that way for the silly title
19:59:31 <ksf> the typeclassopedia does a great job explaining all that
19:59:37 <tensorpudding> so <$> is fmap?
19:59:42 <ksf> yep
19:59:48 <ksf> as is map and (.)
19:59:48 <tensorpudding> ah, i think i knew that
19:59:58 <tensorpudding> and <*> is just fmap for applicatives?
19:59:59 <camio> SamB_XP: There's some serious precedance now for calling them idioms in the academic world.
20:00:12 <Draconx> @type <$>
20:00:14 <lambdabot> parse error on input `<$>'
20:00:15 <ksf> map in Functor [a], and . in Functor ((->)a)
20:00:17 <Draconx> @type (<$>)
20:00:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:00:21 <Draconx> @type (<*>)
20:00:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:00:27 <ksf> tensorpudding, no.
20:00:28 <Draconx> tensorpudding, note the difference in the types.
20:00:29 <SamB_XP> camio: well, tey really should know better 'cause you can't google that
20:00:39 <Cale> sileni: sorry, did you have another problem?
20:00:40 <ksf> well at least not without employing much abstract nonsense
20:00:43 <tensorpudding> i find the fact that (->) a is a functor really titillating
20:00:43 <Makoryu> camio: Cedere, ne cedare, amabo te
20:00:59 <dobblego> (->) is not a functor, but forall t. ((->) t) is
20:01:02 * camio runs off to bed.
20:01:03 <SamB_XP> and anyway, there's plenty of precedent for the other name
20:01:05 <tensorpudding> i need to read more about category theory
20:01:20 <Cale> (->) is a functor too
20:01:22 <tensorpudding> that is what I meant, i wrote (->) a
20:01:36 <Cale> It's a functor Hask^op x Hask -> Hask
20:01:49 <dobblego> how is (->) a functor without the right kind?
20:01:53 <ksf> (->) should be applicative, too.
20:01:55 * SamB_XP hands Cale a mop & bucket
20:02:10 * ksf at least imagines to see an iso to currying, there.
20:02:13 <Cale> It's just not an instance of the Functor class, because it's not an endofunctor on Hask :)
20:02:39 <SamB_XP> Cale: do you know what I have handed you these objects for ?
20:02:39 <mmorrow> > 10000 * 10000 :: Natural
20:02:42 <lambdabot>   * Exception: stack overflow
20:02:49 <mmorrow> :(
20:02:51 <Cale> SamB_XP: yeah, I suspect :)
20:03:06 <Cale> mmorrow: I have no idea what's up with that funny Natural module
20:03:22 <copumpkin> it's unary
20:03:24 <SamB_XP> mmorrow: I think that's from the printing
20:03:39 <tensorpudding> is there a way to enumerate all integers?
20:03:46 <ksf> agda has naturals that are native ints, iirc
20:03:49 <copumpkin> @hackage enumerable
20:03:49 <lambdabot> http://hackage.haskell.org/package/enumerable
20:03:57 <ksf> tensorpudding, not in finite time
20:04:11 <copumpkin> tensorpudding: that module will enumerate them all
20:04:16 <tensorpudding> i mean, in the same way that [1..] enumerates the naturals
20:04:17 <tensorpudding> okay
20:04:43 <tensorpudding> all of them?
20:04:48 <tensorpudding> even the uncountable sets?
20:05:01 <copumpkin> all the integers :)
20:05:33 <Cale> dobblego: If you have categories C and D, you can form the product category C x D, which has as objects pairs (c,d) with c in C and d in D, and for arrows, it has pairs of arrows: if f: c -> c', and g: d -> d' then (f,g): (c,d) -> (c',d'), and composition is componentwise
20:06:13 <Cale> dobblego: Also, if you have any category C, you can form the opposite category C^op which has the same objects as C, and the same arrows, except they all point in the opposite direction
20:07:00 <mmorrow> > let x = 10000 * 10000 :: Natural in x == x+1
20:07:04 <lambdabot>   mueval-core: Time limit exceeded
20:07:17 <mmorrow> > let x = 1000 * 10000 :: Natural in x == x+1
20:07:19 <lambdabot>   False
20:07:37 <tensorpudding> the product of categories is a bifunctor
20:07:42 <Cale> So, if we take an object (a,b) in Hask^op x Hask (which is essentially a pair of types), (->) gives us the type (a -> b) in Hask
20:07:49 <mmorrow> copumpkin: is Natural a [()] iso or some such?
20:08:08 <copumpkin> mmorrow: I think it's just data Natural = Z | Suc Natural
20:08:11 <copumpkin> or something like that
20:08:13 <mmorrow> well, a reverse-[()] iso
20:08:17 <mmorrow> yeah
20:08:28 <mmorrow> err
20:08:32 <mmorrow> no i guess it's a [()]
20:08:38 <copumpkin> @hackage numbers
20:08:39 <lambdabot> http://hackage.haskell.org/package/numbers
20:08:42 <dobblego> Cale, thanks
20:09:07 <Cale> Moreover, if we have a pair of arrows in Hask: f: a' -> a and g: b -> b', then the arrow (f,g): (a,b) -> (a',b') in Hask^op x Hask can get sent to an arrow (a -> b) -> (a' -> b')
20:09:18 <mmorrow> heh, actually a better iso to that would be (Mu Maybe)
20:09:23 <mmorrow> ftw!
20:09:27 <copumpkin> :)
20:09:30 <Cale> Which sends an arrow h to g . h . f
20:09:31 <mmorrow> , fix (Mu . Just)
20:09:33 <lunabot>  Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu ...
20:09:40 <mmorrow> infinity and beyond
20:09:58 <tensorpudding> Mu is awesome
20:09:59 <Cale> and moreover it satisfies the functor laws and associativity :)
20:10:11 <Cale> er, by associativity
20:11:45 <tensorpudding> so in category theory you can relate the objects in a category to the identity arrow for that object, can you do that with Hask?
20:12:15 <Saizan> ?type id
20:12:16 <lambdabot> forall a. a -> a
20:13:01 <Apocalisp> @type Endo
20:13:02 <lambdabot> forall a. (a -> a) -> Endo a
20:13:16 <tensorpudding> oh
20:13:19 <tensorpudding> hmm
20:13:55 <tensorpudding> @hoogle Endo
20:13:56 <lambdabot> Data.Monoid newtype Endo a
20:13:56 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
20:13:56 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
20:13:59 <sileni> i want to name my baby haskell
20:14:11 <ivanm> sileni: Haskell Curry hated his name
20:14:16 <Apocalisp> Wouldn't be the first baby named Haskell
20:14:42 <JohnnyL> sileni i want to have your baby.
20:14:44 <JohnnyL> haha jk
20:14:54 <sileni> dang
20:14:58 <Apocalisp> You can't have your baby and eat it too
20:14:59 <sileni> got my hopes up , are you a women?
20:15:13 <JohnnyL> sileni well, no , I'm trying to cut down actually.
20:15:22 <mauke> preflex: remember <Apocalisp> You can't have your baby and eat it too
20:15:51 <tensorpudding> i thought i read that haskell curry's name was pronounced to rhyme like Pascal
20:16:18 <tensorpudding> and not in the way that most people pronounce the programming language Haskell
20:16:54 <Apocalisp> People from Haskell emphasise the Hask
20:17:13 <Apocalisp> (Haskell County, TX)
20:17:15 <ivanm> just to avoid the rhyming
20:17:21 <ivanm> oh, that Haskell
20:17:46 <ivanm> it's rather annoying trying to search for unis that teach haskell, since one of the top results is haskell university :s
20:18:16 <blackh> ivanm: That sounds like a good university!
20:18:27 <Apocalisp> I really want to drive out there and paint a big lambda on their water tower.
20:18:44 <ivanm> but will any of them get it?
20:18:59 <Apocalisp> it will be over their heads, as it were
20:19:10 <ksf> tensorpudding, pascal isn't written paiscelle, and neither pronounced like that, unless your native language is english.
20:20:00 <ivanm> Apocalisp: heh
20:20:43 <tensorpudding> ksf: ?
20:21:41 <tensorpudding> i'm not sure if you're saying that my understanding of how Pascal's name is flawed, or my understanding of Curry's name is flawed, or both, or neither
20:22:09 <tensorpudding> as I don't know how paiscelle would be pronounced
20:22:13 <ksf> all that I'm hinting at is that english doesn't have the same "a" sound as the a in pascal
20:22:24 <copumpkin> is there a way to input mathematica code into wolfram alpha?
20:22:34 <tensorpudding> err, "how _'s name is pronounced"
20:22:36 <copumpkin> or must I input the stuff in human/pseudomath?
20:23:16 <ksf> a jamaican pronouncing "relax" comes close, though.
20:23:33 <Makoryu> tensorpudding: I like to pronounce it as "wut"
20:23:40 <Cale> copumpkin: You can try just putting mathematica code in
20:23:41 <ksf> ...and the ending l is short and abrupt.
20:24:01 <copumpkin> Cale: I tried putting in the mathematica code it gave me back for an expression it understood, and it said it couldn't understand
20:25:57 <sproingie> Apocalisp: i think the townsfolk of haskell would think you were from Valve software doing a guerilla marketing campaign for Episode 3
20:26:08 <Apocalisp> hah
20:26:17 <copumpkin> maybe it isn't real mathematica code
20:26:32 <roconnor> > (exp (0.0025*(47/365.242199))-1)*833.05 :: CReal
20:26:33 <lambdabot>   0.2680389114668546438827211048537632558641
20:27:12 <Cale> copumpkin: What is it?
20:27:15 <sproingie> something funny i read this week was how Haskell Curry's wife mentioned how he never liked the name Haskell
20:27:47 <copumpkin> Cale: now that I look at the code it spat out, it looks rather sketchy: -sum_(1+n)^mf(y) log(f(y))
20:28:03 <copumpkin> not sure how it can determine what's in the sum and what's in the superscript
20:28:05 <Cale> copumpkin: yeah, that isn't mathematica code
20:28:15 <copumpkin> what is it spitting out then??
20:28:18 <copumpkin> it gave me that :o
20:28:34 <Cale> Did it really display with the underscore like that?
20:28:56 <Makoryu> Apocalisp: Instead of just a lambda, use the logo for the Ministry of Safety and Happiness
20:28:57 <copumpkin> yep, if I click on the (correctly displayed/interpreted) expression it gives me "copyable plaintext"
20:29:04 <copumpkin> and it was exactly what I just gave you
20:29:14 <Cale> oh
20:29:25 <copumpkin> it's not what I typed in
20:29:32 <Cale> yeah, that's just some funny representation of traditional mathematics (and not a very good one)
20:29:38 <copumpkin> weird
20:29:53 <Cale> - Sum[f[y] Log[f[y]], {y,1+n,m}]
20:29:56 <poe> copumpkin - sum f(y) log(f(y)) for y=1+n to m
20:29:58 <copumpkin> oh
20:30:04 <Cale> Heh, it gives -Null for that
20:30:16 <copumpkin> poe: yeah, that was more or less my input
20:30:22 <Cale> Though I guess that is not much of a surprise
20:30:35 <copumpkin> oh I wasn't trying to get it to do much with the expression :)
20:30:42 <copumpkin> it was a building block for something else
20:30:42 <Cale> though a better result would have been an unchanged version of the input
20:30:54 <copumpkin> for me it just displays the input in pretty math
20:31:15 <copumpkin> http://snapplr.com/qes8
20:31:30 <poe> indeed
20:32:30 <tensorpudding> > take 10 $ enumerate :: [Ratio Integer]
20:32:31 <lambdabot>   Not in scope: `enumerate'
20:32:35 <tensorpudding> :\
20:33:08 <copumpkin> tensorpudding: that module is still a big mess :) haven't touched it since I first uploaded it
20:34:09 <Cale> @let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)])
20:34:10 <lambdabot>  Defined.
20:34:17 <copumpkin> :O
20:34:17 <Cale> @let rationals = 0 : (posRationals >>= \x -> [x,-x])
20:34:18 <lambdabot>  Defined.
20:34:20 <tensorpudding> is the enumeration of Q the standard Cantor one?
20:34:31 <copumpkin> should be
20:34:35 <copumpkin> can't remember though :)
20:34:36 <tensorpudding> awesome
20:34:56 <copumpkin> > take 10 posRationals
20:34:57 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
20:34:58 <Cale> It's the Stern-Brocot tree
20:35:16 <Cale> Should have put a type signature
20:35:20 <copumpkin> yeah :/
20:35:32 <Cale> > take 10 posRationals :: [Ratio Integer]
20:35:33 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3]
20:35:39 <Cale> Oh, at least that does work :)
20:35:49 <tensorpudding> nice
20:36:13 <Cale> I used that when writing a program to generate pythagorean triplets
20:36:43 <rwx> i'm trying to figure out how to represent e and pi to arbitrary precision
20:36:52 <Cale> @let pyth :: Rational -> (Integer, Integer, Integer); pyth r = (x,y,z) where { m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2] }
20:36:53 <lambdabot>  Defined.
20:37:01 <Cale> @let triples = map (pyth . (+1)) posRationals
20:37:02 <lambdabot>  Defined.
20:37:06 <Cale> > triples
20:37:08 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
20:37:08 <poe> that's pretty.
20:37:12 <rwx> in a lazy way, i.e. as a computation needs more digits of precision, it gets them
20:37:26 <Gracenotes> that is some lovely math
20:37:30 <rwx> nice cale
20:37:50 <ivanm> is that pythagorean triples?
20:37:55 <Cale> ivanm: yep
20:38:10 <Saizan> rwx: the CReal module should have those
20:38:12 <ivanm> hang on, what's posRationals?
20:38:20 <Cale> positive rationals
20:38:27 <Cale> well, non-negative
20:38:38 <ivanm> > posRationals
20:38:39 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
20:38:45 <Cale> uh, no strictly positive
20:38:46 <ivanm> Cale: yes, but in what order?
20:38:58 <Cale> ivanm: Stern-Brocot order?
20:39:02 <Cale> I'm not sure it has a name
20:39:04 * ivanm wikipedias
20:39:18 <Cale> http://en.wikipedia.org/wiki/Stern_Brocot_tree
20:39:25 <rwx> Saizan, thanks, i'm looking for that now
20:39:43 <ivanm> "Stern Brockot Sequence" ?
20:40:05 <rwx> aesthetically i find the type Real to be annoying
20:40:10 <rwx> it's not like you can actually represent them
20:40:18 <rwx> i mean, nonrationals
20:40:35 <Saizan> the C in CReal stands for Computable
20:40:50 <dancor> you can represent infinite length digit streams
20:40:51 <Cale> rwx: You could represent the real reals, sort of, but it would be a lot of work.
20:40:57 <rwx> oh :-D
20:41:17 <dancor> type Real = [Bool]
20:41:23 <Cale> The real (possibly noncomputable) reals, you'd want to represent as proofs of existence and uniqueness of certain sets.
20:41:49 <ivanm> but would anyone ever care about an incomputable real?
20:41:50 <Saizan> [Bool] is problematic for things with a repeating 1 suffix
20:42:07 <dancor> depends what you do with it ;)
20:42:12 <Cale> ivanm: They have nice abstract properties :)
20:42:23 <ivanm> such as?
20:42:48 <Cale> If you have any bounded set of them, it has a least upper bound :)
20:43:00 <Cale> Er, nonempty bounded set
20:43:29 <rwx> ivanm there's also the interestingness 'paradox'
20:43:30 <Cale> and you don't have to be able to compute the bound even
20:43:35 <ivanm> rwx: heh
20:43:36 <rwx> i.e. yes we care about them :)
20:43:48 <ivanm> Cale: "least upper bound"? the smallest highest value? :s
20:43:51 <FunctorSalad> @tell Baughn the Agda input method is pretty good for Haskell too... (since it doesn't make entering comments near-impossible like the tex input method does)... maybe include with haskell-mode
20:43:51 <lambdabot> Consider it noted.
20:44:00 <rwx> chaitin and i think kolmogorov did cool stuff with uncomputable numbers
20:44:06 <ivanm> FunctorSalad: why, what does agda do?
20:44:07 <rwx> one of my profs back in school had dinner with chaitin once
20:44:08 <dancor> this was illuminating to me: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
20:44:15 <rwx> apparently all the people at the conference avoided going to this dinner
20:44:21 <Cale> ivanm: If S is some set of real numbers, then an upper bound for S is a number M such that every x in S has that x <= M
20:44:22 <FunctorSalad> ivanm: Agda input method for emacs
20:44:26 <dancor> "It can be argued that the computable elements of the Cantor space form a countable set. However, they are not computably countable (or r.e.), with the very same proof given by Cantor in the non-computable case, by diagonalization. (Exercise: write a Haskell program that given any infinite lazy list of elements of the Cantor space, produces an element that is not in the list. This amounts to an implementation of Cantor’s proof of the non-enumerability of 
20:44:29 <rwx> because this guy chaitin is brilliant but like, intense as fuck and kind of insuffurably verbose
20:44:41 <ivanm> FunctorSalad: oh, right, not how to input haskell in agda-mode
20:44:46 <Cale> ivanm: A least upper bound is a number N such that if M is any upper bound for S, then N <= M
20:45:00 <FunctorSalad> ivanm: the tex input methods garbles your dashes :)
20:45:06 <rwx> cale is that the supremum?
20:45:10 <FunctorSalad> so it sucks for entering haskell comments
20:45:14 <Cale> rwx: yes
20:45:18 <ivanm> Cale: so it's a number that all upper bounds are higher than or equal to, but not necessarily in that set?
20:45:19 <Cale> supremum is another name for it
20:45:37 <Cale> ivanm: yeah, not necessarily in S, but a real number anyway
20:45:39 <rwx> ivan the supremum for all x < 1 is 1
20:45:39 <ivanm> FunctorSalad: *nod*
20:45:47 <ivanm> Cale: I thought you meant the "least upper bound" was in the set ;-)
20:45:47 <FunctorSalad> a supremum is just a colimit in the category of .... *runs*
20:45:50 <ivanm> hence my confusion
20:45:55 <Saizan> dancor: i've written that proof in agda, btw!
20:46:07 <Cale> ivanm: The problem would be if the least upper bound wasn't in R
20:46:09 <dancor> now i really believe it
20:46:09 <rwx> okay so admission: i have a set theory background, and the set theorists i've met all poo-poo on category theory
20:46:28 <ivanm> Cale: ummm.... what would it be in then? C?
20:46:34 <rwx> do you guys have any recommendations on where to start learning the hardcore category theory from hopefully a set theory background?
20:46:35 <copumpkin> rwx: as they should
20:46:36 <FunctorSalad> rwx: I was being facetious :)
20:46:43 <rwx> haha
20:46:44 <dancor> is anyone working on compu-formally proving fermat's last theorem
20:46:54 <copumpkin> sounds like a nightmare
20:46:55 <rwx> MORPHISM
20:46:58 <Cale> ivanm: Well, it just wouldn't exist.
20:47:07 <FunctorSalad> /nick ridiculorphism
20:47:11 <ivanm> Cale: right
20:47:13 <Cale> rwx: I will send you a book :)
20:47:22 <Cale> ivanm: Consider the rational numbers
20:47:26 <copumpkin> dancor: that proof would be a gigabyte!
20:47:44 <Cale> ivanm: the set of all rational numbers x such that x^2 < 2, for instance
20:47:50 <sproingie> isn't the current contender for a proof a machine-assisted one?
20:47:54 <dancor> copumpkin: don't you think it will happen eventually that ppl will expand what is formally proven and use computers in math more until they basically are only using computers?
20:48:02 <Cale> ivanm: It doesn't have a least upper bound in Q
20:48:12 <Cale> ivanm: But it has one in R, which is sqrt(2)
20:48:15 <copumpkin> dancor: I hope so :) but it's painful to do even basic things right now (at least for me :P)
20:48:21 <allbery_b> hm.  somehow I was under the impression that category theory is ultra-generalized set theory
20:48:36 <dancor> copumpkin: ya i guess there will probably be a lot of improvement in the tools before anyone gets close to FLT
20:48:38 <ivanm> Cale: how can you guarantee that any non-empty set of those numbers will have a value >= sqrt 2 ?
20:48:46 <Cale> rwx: http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
20:48:52 <copumpkin> omg
20:49:03 <Cale> ivanm: hm?
20:49:15 <ivanm> Cale: so now you're _explicitly_ giving it away? :p
20:49:25 <rwx> Cale, thanks!
20:49:33 <Cale> ivanm: I figure it was on reddit the other week anyway
20:49:38 <ivanm> heh
20:49:42 <ivanm> Cale: wait, does the upper bound for a set have to be in the set?
20:49:46 <Cale> (though it had a different page layout)
20:49:50 <Cale> ivanm: no
20:49:55 <copumpkin> what's the simplest way to take the partial derivative of a fairly complex expression? it's rather painful to get wolfram alpha to accept what I want to do, and I'm too lazy to do it by hand
20:49:57 <Cale> ivanm: Most upper bounds will not be
20:50:02 <ivanm> Cale: OK...
20:50:29 * ivanm gives up on this, and goes back to combinatorics, which he groks better
20:50:30 <Cale> ivanm: If x and y are upper bounds for S and are elements of S, then x = y
20:50:39 <krainbolt> Sleepy sleepy.
20:50:44 <Cale> ivanm: I can turn it into category theory if you prefer that
20:50:52 <ivanm> Cale: nooooo!!!
20:50:55 <copumpkin> lol
20:50:57 <ivanm> I understand that even less! ;-)
20:51:14 <FunctorSalad> copumpkin: hmm isn't differentiating straightforward?
20:51:26 <copumpkin> the borg will assimilate you too
20:51:26 <copumpkin> eventually
20:51:35 <dancor> copumpkin: and how is it painful in wolfram?
20:51:40 <sproingie> i have a truly marvellous proof that is too small to fit in this 140-character tweet
20:51:46 <rwx> ivanm, http://mathworld.wolfram.com/Supremum.html
20:51:53 <rwx> haha
20:51:56 <sproingie> er too big.  dammit.
20:52:02 <copumpkin> dancor: it's a large expression and I can't get alpha to even parse it
20:52:16 <copumpkin> I want something I can write LaTeX into
20:52:19 <copumpkin> and it'll do magic to
20:52:23 <copumpkin> :P
20:52:28 <rwx> pari/gp?
20:52:28 <Cale> Consider the category whose objects are the real numbers, and where there's a single arrow x -> y when x <= y (and no others)
20:52:46 <FunctorSalad> or take this order: 1, 2, 3, ......., 3', 2', 1', 0' .
20:52:56 <FunctorSalad> the set 1,2,3, ....     doesn't have a supremum
20:52:58 <FunctorSalad> :)
20:53:13 <Cale> Then if S is any nonempty set of objects such that there's an object M for which there are arrows x -> M for every x in S, then the coproduct of the objects in S exists.
20:53:26 <FunctorSalad> (though it does have upper bounds)
20:53:34 <ivanm> oh, right, your < 2 example was in Q, not R
20:53:41 <ivanm> that didn't help my confusion ;-)
20:53:45 <Cale> ivanm: right, right.
20:54:01 <Cale> ivanm: I was trying to show how this property can break down when it's not the reals.
20:54:18 <ivanm> Cale: but how do you prove there is no rational number sqrt 2 < q <= 2 ?
20:54:39 <Cale> uhhh
20:54:41 <tensorpudding> um
20:54:42 <FunctorSalad> there are such q
20:54:45 <FunctorSalad> just not a least one
20:54:50 <mwc> @pl getProgName >>= \s -> withCString s wozzle
20:54:50 <lambdabot> flip withCString wozzle =<< getProgName
20:55:16 <Cale> Yeah, you would take any rational number which is an upper bound for that set, and show that you can find a smaller one which is also an upper bound
20:55:19 <mwc> hmm, anyway to write that in point free style where wozzle is a do expression?
20:55:22 <copumpkin> @pl is prejudiced against >>= it seems
20:55:23 <lambdabot> it seems =<< is prejudiced against
20:55:24 <ivanm> well, that link that rwx gave me said the least upper bound is some M which is >= all values of an arbitrary set ...
20:55:30 <tensorpudding> the supremum property applies to R but not to Q
20:55:31 <copumpkin> :)
20:55:37 <mwc> copumpkin: doh, thanks
20:55:44 <ivanm> tensorpudding: ahhh
20:55:57 <rwx> could you restate why it applies to R and not Q?
20:56:00 <tensorpudding> because R is complete with respect to the metric
20:56:06 <ivanm> Cale: ummm, how can you find a _smaller value_ which is also an upper bound for that set?
20:56:11 <rwx> do you mean some strict subset of R, or the entire thing?
20:56:20 <rwx> (or of Q)
20:56:41 <Cale> rwx: Every nonempty bounded subset of R has a least upper bound.
20:56:53 <rwx> yes
20:57:07 <Cale> But not every nonempty bounded subset of Q has a least upper bound.
20:57:38 <tensorpudding> a metric space is complete if it contains all limits to Cauchy sequences
20:57:40 <Cale> ivanm: Because upper bound just means larger than or equal to all the elements
20:58:08 <FunctorSalad> lazy way for finding a smaller q: take (sqrt(2) + q)/2, take suffciently accurate rational approximation for that ;))
20:58:09 <rwx> e.g., all a = {x | x < pi}, pi is not an elem of Q, so a has no supremum?
20:58:18 <ivanm> Cale: but can't you just grab the largest value in that set, and call that the least upper bound of that set?
20:58:23 <rwx> (get rid of that "all")
20:58:34 <Cale> ivanm: and because I'll be able to apply the trick which you might have seen in SICP a couple times to get a rational number which if we treat it as a real is still larger than sqrt(2), but slightly closer to it.
20:58:36 <akappa> ivanm, the set is dense
20:58:42 <akappa> you don't have the "maximum"
20:58:53 <Cale> ivanm: The set also doesn't have a maximum value, yeah.
20:58:55 * ivanm doesn't recall any trick in SICP about this...
20:59:06 <ivanm> then again, I haven't read SICP in a while...
20:59:14 <Cale> One of the first lectures, he talks about computing the square root of a number
20:59:22 <Cale> By finding closer approximations
20:59:38 <ivanm> Cale: OK, so how come in R sqrt 2 is a valid upper bound in this?
20:59:48 <ivanm> Cale: to me, SICP == book, not lectures ;-)
20:59:54 <ivanm> right, I vaguely recall that
21:00:05 <tensorpudding> sqrt 2 is not in Q
21:00:23 <dancor> copumpkin: how large is it? is it online? what are you going to do with the differentiated result?
21:00:49 <copumpkin> dancor: not online, just want to verify someone's result
21:00:59 <copumpkin> I might just do it by hand
21:01:02 * copumpkin sighs
21:01:04 <ivanm> tensorpudding: I did say R ...
21:01:15 <Cale> In R, if x^2 < 2 and suppose that x is positive, then sqrt(x^2) < sqrt(2), and so x < sqrt(2)
21:01:56 <Cale> Yeah?
21:02:03 <Cale> So sqrt(2) is an upper bound for the set
21:02:10 <Cale> Is it the least one?
21:02:23 <ivanm> Cale: oh, we're considering x where x^2 < 2; thought we were talking about x < 2 :s
21:02:34 <tensorpudding> whoops
21:02:38 <ivanm> Cale: and yeah, I can see why it would be the least one, since it's just out of the set
21:03:11 <rwx> you can think of it in terms of limits
21:03:17 <ivanm> yeah
21:03:26 <rwx> that's not how it's defined, but metaphorically it's equivalent afaict
21:03:28 <ivanm> but the ^2 made a lot of difference ;-)
21:03:36 <tensorpudding> the successive approximations that Cale mentioned get very close, arbitrarily close, to sqrt(2), it defines a sequence that converges to sqrt(2)
21:03:37 <dancor> copumpkin: if it's really that big, you should definitely not do it by hand since computer derivatives are a solved problem!
21:03:58 <tensorpudding> and each term in that sequence is in Q, but the limit, sqrt(2), is not
21:04:10 <ivanm> tensorpudding: yeah, I get it now! ;-)
21:04:21 <copumpkin> dancor: it's not really that big :) it'll fit on a line of a notebook, but has several rather large fractions and a couple of sums in it
21:04:30 <copumpkin> dancor: but I may or may not be installing mathematica right now
21:04:49 <dancor> i would use gp/pari, or implement differentiation in haskell for fun
21:04:49 <ivanm> copumpkin: you may or may not have found a legal copy of mathematica to install right now? :p
21:04:53 <rwx> so i started learning haskell a month ago
21:05:01 <copumpkin> ivanm: conveniently my school has a site license
21:05:02 <rwx> and my new job, in a few weeks, i've got to use ruby and java
21:05:03 <rwx> groan
21:05:11 <rwx> any advice on how to deal with that horror?
21:05:18 <copumpkin> ruby isn't so horrific
21:05:27 <ivanm> copumpkin: yeah, yank unis seem to have better deals on all the math software
21:05:45 <Cale> ivanm: Another way to look at this property of the reals: we call a sequence {x_0, x_1, x_2, ...} Cauchy if for any e > 0, we can find some M so that if n and m are both larger than M, we have |x_n - x_m| < e
21:05:47 <ivanm> but in the long run, I'm glad we didn't; I have matlab installed here, but only use it when I need to check someone elses work
21:05:50 <dancor> will learning category theory make me better at programming
21:06:00 <copumpkin> dancor: it'll make you worse
21:06:02 <ivanm> even before that, I used it just to produce graphs, etc. from data generated in another lang
21:06:07 <Cale> ivanm: That is, the elements of the sequence are all getting close together. We'd expect such a sequence to converge.
21:06:11 <tensorpudding> woo topology in #haskell
21:06:12 <dancor> copumpkin: at programming?  or as a person
21:06:13 <copumpkin> I hate matlab but have it installed too
21:06:13 <rwx> cale, did you mean: couch-y?
21:06:16 <copumpkin> dancor: both
21:06:18 <ivanm> Cale: I THINK I GET IT NOW!
21:06:26 <Cale> ivanm: In the rationals, or the computable reals, sometimes they don't.
21:06:27 <ivanm> you and tensorpudding can stop trying to provide analogies, etc. :p
21:06:44 <ivanm> your example confused me because I missed the "^2", that's all
21:06:48 <copumpkin> ivanm: so it's like a burrito
21:06:49 <Cale> ah
21:06:54 <ivanm> @slap copumpkin
21:06:55 <lambdabot> stop telling me what to do
21:06:56 <rwx> copumpkin, ruby is so... imprecise feeling
21:07:07 <copumpkin> rwx: yep :/
21:07:10 <Cale> You're probably wondering why we're calling it a "burrito"...
21:07:13 <rwx> copumpkin, i think it's the typing that does that, same with plt scheme unfortunately
21:07:13 <copumpkin> my previous favorite language :)
21:07:27 <copumpkin> now I can barely stand it, sadly
21:07:27 <tensorpudding> it turns out that "every number which can be arbitrarily approximated by elements in the set A is contained in A" is equivalent to "every bounded subset of A contains a least upper bound in A"
21:07:59 <tensorpudding> assuming that A is totally ordered
21:08:15 <rwx> copumpkin, is it true that matz made ruby as kind of a newb lisp dialect?
21:08:17 <ivanm> Cale: I remember the fake monad tutorial
21:08:27 <ivanm> rwx: I've heard that
21:08:37 <Cale> Dude, I totally ordered that pizza, like, an hour ago.
21:08:40 <ivanm> rwx: but I suspect you'd have to ask matz to get the truth
21:08:41 <ivanm> ;-)
21:08:45 <akappa> Sorry, maybe I've misunderstood, but { y \in Q | y < pi } doesn't have a least upper bound equals to pi? Q is dense in R...
21:08:51 <copumpkin> rwx: beats me :) the comparisons to lisp seemed rather lame when I saw them, but maybe I just saw bad ones
21:08:52 <sproingie> rwx: more like smalltalk
21:08:59 <tensorpudding> ruby is kinda like smalltalk and perl having a child
21:09:08 <tensorpudding> but lisp was the frumpy nanny
21:09:14 <Cale> akappa: pi is not a rational number
21:09:38 <rwx> "matz, did you commit symbolic genocide by taking scheme, removing macros, and making everything an "object" [woooo!]?"
21:09:45 <akappa> Cale, yes, but Q is dense in R, so we can well-approximate any number in R, or not?
21:12:13 <Cale> rwx: Ruby seems a lot more like a Smalltalk dialect to me
21:12:13 <Cale> akappa: Oh, sure.
21:12:13 <rwx> cale i'm smalltalk ignorant... have you tried squeak?
21:12:13 <Cale> rwx: yeah
21:12:13 <tensorpudding> for any real number, there is a rational number arbitrary close to it
21:12:13 <copumpkin> tensorpudding: nuh uh, I have one in my head that no rational will get near
21:12:13 <akappa> Cale, so, if I take a neighborhood of pi, I found at least one element in Q... so, an upper bound can't be less than pi, right?
21:12:13 <sproingie> squeak's a really amazing toy.  i mean it's impressive but i can't honestly figure out what to *do* with it
21:12:13 <tensorpudding> copumpkin: i'm thinking of a real number between 0 and 1...
21:12:13 <Cale> akappa: right
21:12:13 <copumpkin> tensorpudding: mine is between 0 and 1
21:12:13 <Cale> akappa: But there will be smaller and smaller rational approximations to pi which are larger than pi
21:12:13 <tensorpudding> whoops, it turns out it was not computable
21:12:13 <copumpkin> but it's a secret... :(
21:12:13 <Makoryu> Cale: Smalltalk was fairly Lisp-ish to begin with... sort of.
21:12:13 <Cale> Makoryu: true
21:12:41 <akappa> Cale, okay, so?
21:12:48 <tensorpudding> the real numbers are crazy, most of them aren't even computable
21:13:09 <akappa> tensorpudding, for a cardinality reason :)
21:13:12 <copumpkin> tensorpudding: like 100% of them!
21:13:32 <tensorpudding> the probability of choosing one that isn't is 0
21:13:46 <rwx> choosing, HA HA HA
21:13:51 <copumpkin> one that isn't not computable?
21:14:02 <tensorpudding> err, one that isn't not computable
21:14:06 <tensorpudding> double negatives!
21:14:10 <copumpkin> :)
21:14:32 <akappa> copumpkin, is the same probability of getting an integer out of a real set
21:14:33 <tensorpudding> i once found a freshman math major
21:14:35 <rwx> but they are hypercomputable! (tier-1 hypercomputation i guess you'd say?)
21:14:36 <akappa> *it's
21:14:38 <dancor> what is the most famous non-computable real, is it this: http://en.wikipedia.org/wiki/Chaitin%27s_constant
21:14:47 <tensorpudding> and showed them cantor's argument for countable vs. uncountable sets
21:14:55 <copumpkin> dancor: probably
21:15:00 <tensorpudding> and i think it scared them
21:15:18 <dancor> are there even good bounds on that number
21:15:26 <tensorpudding> chaitin's constant is the most famous, probably
21:15:31 <akappa> tensorpudding, wtf, a freshman math major?
21:15:31 <rwx> i got invited to take set theory because i met the prof in a coffee shop and started asking all these silly questions about busy beavers and information theory
21:15:37 <rwx> and he was like ok ok could you just take my class?
21:15:41 <rwx> i didn't study math really
21:16:00 <rwx> cale i hope you do something like that for someone
21:16:12 <copumpkin> chmod a-w rwx
21:16:42 <akappa> Cale, oh, I understand: we want to express the least upper bound of the set with a number in Q, right?
21:16:56 <akappa> _not_ in R
21:16:57 <Cale> akappa: yeah
21:17:09 <akappa> Cale, that's why I haven't understood :)
21:17:16 <akappa> now it's clear and obvious, thanks
21:17:20 <Cale> akappa: If you think of Q as a subset of R, then sure, every nonempty set of elements of Q will have a least upper bound in R
21:17:31 <mwc> Hmmm, should -pgmc be honoured by hsc2hs?
21:17:34 <Cale> sorry, every *bounded* nonempty set of elements
21:17:45 <mwc> I'm setting ghc-options in cabal
21:17:51 <tensorpudding> let's use the extended real numbers
21:17:59 <poe> a better approach is to represent it as all the rational numbers less than or equal to x (that is, dedekind cuts!)
21:18:08 <dancor> are there non-transcendental non-computable reals?  any ones with names?
21:18:26 <copumpkin> it seems impossible?
21:18:29 <dancor> i guess "non-transcendental" === "algebraic"
21:18:42 <akappa> dancor, if it is non-trascendental, then it is algebraic and then computable
21:18:53 <ivanm> tensorpudding: hmmm?
21:18:55 <akappa> (I guess)
21:19:13 <tensorpudding> the extended real numbers are the real numbers with infinity thrown in
21:19:34 <tensorpudding> it breaks the algebraic properties a bit
21:19:38 <copumpkin> we need a non-computable rational!
21:19:40 <dancor> also why don't ppl say incomputable which is at least a scrabble word
21:19:45 <tensorpudding> but if you define the sets right, it is compact
21:20:05 <Cale> http://cale.yi.org/share/Screenshot-Squeak.png <-- a picture of Squeak coming apart at the seams
21:20:17 <copumpkin> that sounds cruel
21:20:19 <tensorpudding> it's actually the one-point compactification of R
21:20:51 <Cale> (but actually it handles it rather well)
21:20:52 <poe> tensorpudding yeah, alexandroff, and there is the two-point one "between" R and yours
21:21:00 <dancor> Cale: is squeak known for being slow
21:21:10 <Cale> dancor: I'm not sure, but it is slow.
21:21:19 <dancor> ha
21:21:44 <copumpkin> I think a lolcat took over your computer
21:21:50 <tensorpudding> my topology is kinda creaky unfortunately, i don't remember the two-point one
21:22:06 <poe> tensorpudding -oo +oo
21:22:10 <tensorpudding> ah right
21:22:18 <tensorpudding> I was just thinking about the single point at infinity
21:22:32 <copumpkin> oOo
21:22:39 <poe> that you get by identifying those two
21:22:42 <mmorrow> tensorpudding: a sphere
21:22:45 <Cale> I'm in ur Squeak, upgrading ur objectz.
21:22:48 <tensorpudding> yes
21:22:56 <tensorpudding> the complex plane
21:23:03 <tensorpudding> plus the point at infinity
21:23:27 <tensorpudding> can be wrapped up into a sphere
21:23:36 <mwc> Problem with Cabal: there's no way to pass options to hsc2hs except as command line flags? I can't set them in buildinfo?
21:23:45 <tensorpudding> and there is even a logical way to define sets containing the point at infinity
21:23:47 <mmorrow> you might also construct it with two copies of R^2
21:24:03 <mmorrow> if you were doing differential geometry
21:24:10 <copumpkin> too many mathematicians in here
21:24:12 <poe> it's easier to see if one uses (0,1) instead of R (being homeomorphic), first you get [0,1] and then you get S^1. the same works for two dimensions
21:24:23 <tensorpudding> yeah
21:24:29 <mmorrow> S^n even
21:24:32 <tensorpudding> is it true for general n?
21:24:35 <tensorpudding> cool
21:24:39 <Cale> Too many mathematicians spoil the paper?
21:24:48 <poe> it depends on the identifications you put on the square though.
21:24:51 <Cale> mwc: hmm
21:24:54 <copumpkin> :)
21:25:04 <poe> R^2 -> (0,1)x(0,1) naturally
21:25:14 <Cale> mwc: I think hsc2hs is a completely separate tool from Cabal
21:25:36 <poe> which is included in [0,1]x[0,1] but now you get different things depending on how you identify the borders.
21:25:39 <mwc> Cale: well, the build phase can take arguments for subprograms: --alex-options, --hsc2hs-options, etc.
21:25:55 <tensorpudding> i remember when we talked about the hilbert cube, that was some crazy stuff
21:26:17 <tensorpudding> topology is stranger than an acid trip
21:26:43 <poe> and the one to get S^n isn't the most natural (I think)
21:27:05 <poe> the prettier way to get S^n is the suspension of a S^(n-1)
21:27:34 <Cale> There's a really nice proof that R is uncountable which uses only topological properties. You can show that any compact Hausdorff space with no isolated points is uncountable directly, and that gives that [0,1] is uncountable.
21:28:07 <mwc> even passing my own arguments at build phase, hsc2hs is called with --cc mpicc --ld mpicc --cc /usr/bin/gcc --ld=/usr/bin/gcc ... and so chokes
21:28:24 <poe> X a top.sp. SX = Xx[0,1]/~ the suspension of x where (x,y)~(x,y) and (x,0)~(y,0) and (x,1)~(y,1) for all x,y
21:29:03 <poe> for example take the circumference S^1, multiply it by [0,1] and get a cylinder, squeeze the circular borders to a point, and you get S^2
21:29:10 <poe> and that works for each and every n
21:29:27 <tensorpudding> that's something i've never seen before...
21:29:50 <Cale> mwc: maybe dcoutts or dons would know...
21:30:17 <Cale> hmm
21:30:32 * Cale googles
21:31:00 <Cale> oh
21:31:24 <Cale> mwc: Cabal apparently does have support for running hsc2hs on files directly?
21:31:49 <Cale> (it supposedly just transparently calls hsc2hs on any .hsc files in your list)
21:31:58 <poe> (~ is better written as (x,s)~(x,s) and (x,0)~(y,0) and (x,1)~(y,1) for all x,y in X, s in [0,1])
21:32:08 <akappa> oh, since there are so many mathematician: a good source to study the fourier transform?
21:32:32 <mwc> Cale: yeah, if you list them as other-modules or in exposed modules, and there's a .hsc but no .hs, then it will run it
21:33:02 <poe> akappa Gasquet-Witomski is comprehensive
21:33:19 <akappa> poe, merçi
21:33:36 <copumpkin> no need for cedilla!
21:33:40 <akappa> no?
21:33:42 <akappa> ops :D
21:33:57 <copumpkin> garçon
21:34:09 <tensorpudding> what does the cedilla actually do?
21:34:24 <copumpkin> gives you a S sound with a C, when it's not in front of an E or an I
21:34:26 <tensorpudding> does it modify the vowel, or change the c
21:34:31 <copumpkin> not sure why they don't just use the S
21:36:17 <ksf> is the set of programs without semantic duplicates finite?
21:36:41 <akappa> what is a "semantic duplicate"?
21:36:43 <Cale> mwc: So there's nothing like "hsc2hs-options:" for the .cabal file?
21:36:43 <copumpkin> semantic duplicates?
21:37:00 <ksf> like x = x + 2 - 1 and x = x + 1
21:37:04 <Cale> mwc: I'm not all that familiar with the fiddly details of the .cabal file format :)
21:37:20 <ksf> er make that ssa
21:37:22 <akappa> ksf, you can have x = i, with i integer
21:37:23 <copumpkin> ksf: oh, no
21:37:31 <akappa> ksf, so, why they should be finite?
21:37:33 <ksf> somehow I've written imperative examples there
21:37:50 <poe> S^3 then becomes the suspension of S^2, which is quite hard to visualize (embedded in R^4), but there is a trick: imagine two distinct S^2 and a point travelling inside one of them that when reaches the border of one disappears and reappears inside the other one, with the same velocity, but on the antipodal point
21:38:06 <ksf> akappa, well, let's make that x = y + z, that is, everything is a free variable.
21:38:31 <copumpkin> ksf: just think about enumerating the domain->range mappings
21:38:37 <copumpkin> ksf: without caring about how you get there
21:38:43 <akappa> ksf, you have a program for each integer
21:38:44 <ksf> or am I just reducing everything to one computational kernel?
21:38:48 <poe> that is also interesting because it is one possibile shape for the universe :) an astronaut travelling out to infinity could come back from the opposite direction with the body swapped!
21:38:55 <akappa> a program that throws away the input and returns i
21:39:05 <akappa> so they are at least N
21:39:08 <poe> (and that in turn is connected with poincarè's conjecture, recently proved)
21:39:16 <sproingie> poe: wouldn't it take the entire lifetime of the universe to do so?
21:39:40 * ksf always assumed that space expands as soon as you get near the border of the univers.
21:40:00 <ksf> that is, the only reason there's no space there is because why should there be space, when there's no matter that takes it up?
21:40:05 <sproingie> i believe it's that you end up where you started
21:40:13 <sproingie> but it takes literally all time to get there
21:40:22 <poe> (I'm not *completely* sure of the physics, but the mathematical point takes finite time to travel that model of the three-sphere.)
21:40:40 <sproingie> cosmology hurts my brane
21:40:44 <sproingie> hurr hurrr
21:40:51 <akappa> cosmology is fucking cool
21:41:14 <sproingie> now i have that autotuned sagan song in my head again
21:41:18 <akappa> (I assume that I can use bad words here)
21:41:43 <sproingie> it's after the kids bedtime, so yes
21:41:46 <copumpkin> astrology is much cooler
21:42:01 <akappa> sproingie, in which country? ;)
21:42:06 <sproingie> copumpkin: cool in that it turns BS into a steady income i suppose
21:42:22 <sproingie> i should have gotten into new age, but i just can't lie convincingly
21:42:51 <Cale> I like that Poincaré's conjecture and FLT were both proved as corollaries to much more general theorems. :)
21:42:55 <tensorpudding> poe: this is assuming that the universe has positive curvature which i'm not sure is true or not
21:43:08 <Cale> HARD HARD HARD HARD trivial.
21:43:53 <poe> tensorpudding yeah, S^3 is *one* possibility, if e.g. the universe turns out to be non-orientable. then there are others, connected to hyperbolic geometry.
21:43:56 <ksf> every truth becomes trivial after you understood it.
21:44:54 <tensorpudding> the curvature of the universe is related to the matter-energy density
21:45:12 <sproingie> ksf: that's kind of a tautological definition of "understand"
21:45:15 <akappa> even göedel's incompleteness theorem?
21:45:20 <tensorpudding> also, there are terms for the lambda or dark energy contribution
21:45:20 <sproingie> some truths really escape understanding
21:45:31 <tensorpudding> which of course is not yet understood
21:45:39 <ksf> well, every theorem is a tautology as soon as you understand it.
21:46:02 <akappa> ksf, but this doesn't make them trivial!
21:46:08 <poe> haven't taken GR yet. I know from SR that (minkowski) space has some kind of hyperboliticy to it, but not much else.
21:46:12 <tensorpudding> and the total mass density is dominated by the dark matter contribution
21:46:19 <ksf> not unless you understand them, no.
21:46:51 <Cale> Well, not strictly a tautology
21:46:52 <ksf> there's a difference between spotting that the set of sets that don't contain themselves is kinda strange and actually grokking it.
21:46:55 <tensorpudding> in cosmology, the standard model (the lambda-CDM model) uses a simplified metric to describe spacetime, that uses several assumptions
21:47:05 <ksf> that was one of the loudest tilts my brain ever made.
21:47:28 <akappa> ksf, this is like say that you really understand something when you find it trivial... you're defining what understanding means :P
21:47:30 <sproingie> i always understand it as something like an incomplete definition
21:47:42 <ksf> ...saying "hey, don't expect an answer if you throw unsound logic at me"
21:48:01 <tensorpudding> it assumes the universe is isotropic, expanding and simply-connected
21:48:02 <Cale> There is no set of all sets to begin with :)
21:48:15 <tensorpudding> it turns out the universe is not entirely isotropic
21:48:30 <Cale> and no set contains itself as an element
21:48:33 <tensorpudding> most people believe the universe is expanding nowadays
21:48:51 <ksf> well, if one allows for infinite constructions...
21:49:03 <ksf> at least its semi-thinkable.
21:49:05 <sproingie> the set of all sets is reasonable enough
21:49:08 <tensorpudding> simply-connected rules out the more complex topologies on spacetime..there are lots of different models for alternatives to this
21:49:09 <poe> and there is no set that contains all OTHER sets as well :)
21:49:14 <sproingie> it isn't enumerable of course
21:49:17 <copumpkin> sproingie: :O
21:49:57 <tensorpudding> man, how long has it been since we were talking about haskell
21:50:04 <sproingie> the set of all sets that don't contain themselves is like saying the set that is not itself, or something
21:50:31 <Cale> sproingie: well, yeah, you get a contradiction pretty quickly
21:50:34 <ksf> it can't be constructed in sound logic and evaluate to "that set exists", yes.
21:50:36 <sproingie> which makes a cute zen koan, but not much else
21:51:02 <tensorpudding> you need axioms to prevent the construction of sets like that
21:51:23 <tensorpudding> or you need classes
21:51:25 <sproingie> i guess the problem with absurdities is that there's several routes to them
21:51:42 <ksf> or you need to be a constructivist
21:51:47 <tensorpudding> ZFC goes the first route, NBG goes the second
21:52:25 <tensorpudding> didn't constructive set theory derive from russell's theory of types?
21:52:50 <ksf> you have, after all, prove for every possible set that it does not contain itself, which seems to reduce to the halting problem.
21:54:42 <Cale> tensorpudding: Well, the axiom of regularity doesn't exactly prevent their construction, it's just that it directly contradicts their existence.
21:55:11 * ksf just knows that he's constructivist, but doesn't actually have much of an idea about maths. I blame the formalistic curriculum.
21:55:14 <Cale> tensorpudding: If they were constructible using the other axioms, they'd still be constructible, but regularity would lead to a contradiction.
21:55:34 <jeffwheeler> This should be easy, but I'm having a lot of trouble installing the platform on Ubuntu 9.10.
21:55:47 * Cale is a formalist, but the sort who recognises the importance of intuition.
21:55:48 <tensorpudding> i think constructivist is usually taken to mean that you reject the law of the excluded middle, and the axiom of choice
21:55:50 <jeffwheeler> I'm basically following this, either by hand or just running that directly: http://gist.github.com/230010
21:56:07 <tensorpudding> and possibly the axiom of infinity too
21:56:15 <Cale> jeffwheeler: Don't. Just install the GHC generic linux binary from the GHC website, and then grab cabal-install.
21:56:16 * ksf rejects teabag-swinging.
21:56:23 <jeffwheeler> Sorry, this was the error I end up with: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12453
21:56:29 <jeffwheeler> Cale: hmm, thinking
21:56:31 <Cale> jeffwheeler: (it'll be less trouble)
21:56:36 <ksf> you know, the proof of the tea is in the cooking.
21:56:57 <jeffwheeler> Is the GHC generic binary better than the one in Ubuntu?
21:57:30 <Cale> jeffwheeler: I'm not sure, but I've heard about other people having trouble with the Ubuntu build
21:57:51 <jeffwheeler> Cale: hmm, okay, I'll try the one on GHC's site. Then you suggest not installing the platform, but just cabal-install?
21:57:58 <copumpkin> mathematica is so much nicer than matlab so far
21:57:59 <Cale> jeffwheeler: yeah
21:58:05 <Cale> jeffwheeler: For now it's easier.
21:58:13 <jeffwheeler> Cale: alright, I'll try that; thanks for the suggestion
21:58:27 <jeffwheeler> copumpkin: I'm a big fan of Mathematica; it's really easy
21:58:27 <Cale> jeffwheeler: The platform is meant to be something to be picked up by the people who are making packages for distributions, I think.
21:58:35 <jeffwheeler> Cale: oh, okay
21:58:45 <tensorpudding> so is intuitionism a subset of constructivism?
21:58:51 <Cale> jeffwheeler: But I'm not really sure about that.
21:59:03 <jeffwheeler> Cale: well, I'll give that a shot; thanks
21:59:27 <Cale> tensorpudding: It depends on what you mean by each of those :)
21:59:43 <ksf> tensorpudding, I deny that 0.333... * 3 is 1, but won't deny that 1/3*3 is 1. but that's not because I think infinity is evil by itself, but because I keep track of loss of information.
21:59:55 <ksf> ...which is the reason why I consider floats to be evil.
22:00:04 <Cale> ksf: That's odd of you.
22:00:19 <ksf> i'm more of a coder than a mathematician.
22:00:22 <Cale> ksf: It sounds more like a misunderstanding about what decimal expansions mean :)
22:00:24 <tensorpudding> Cale: how disagreeable that they don't even have set meanings
22:00:54 <poe> How'd you go about proving that every (computable) real number has at most two decimal representation
22:00:55 <Makoryu> Really, Rational should be the default FP representation in HLLs, not Floats or Doubles.
22:00:56 <Cale> tensorpudding: If you talk about an intuitionist logic, that tends to have a set meaning.
22:01:08 <Cale> tensorpudding: But that's different from intuitionism
22:01:21 <Cale> (which is a philosophical standpoint on mathematics, rather than a formalism)
22:01:26 <ksf> Cale, can you decide in finite time whether or not some random series of digits repeats itself or terminates, in the general case?
22:01:29 <tensorpudding> ah
22:01:59 <tensorpudding> intuitionist logic is what intuitionistic type theory uses i'd imagine
22:02:05 <Cale> yeah
22:02:06 <QtPlaty[HireMe]> ksf: What do you mean by "Some random series"?
22:02:17 <ksf> let's say, the fast quintillion digits of pi
22:02:18 <Cale> basically, rejection of the excluded middle
22:02:22 <tensorpudding> (they could have made intuitionistic easier to spell)
22:02:29 <ksf> ...without you knowing how it was constructed.
22:02:40 <tensorpudding> i thought that rejection of the excluded middle was the central tenet of constructivism
22:02:41 <ksf> *first
22:02:50 <Cale> ksf: What do you mean by 'random series of digits'?
22:02:53 <QtPlaty[HireMe]> If your asking if out of all possable series you pick one at random, then it will not terminate.
22:03:12 <ksf> yep.
22:03:14 <Cale> ksf: If it's only the first quintillion, I can't tell you if it repeats or not.
22:03:31 <Cale> ksf: Because there are continuations of it which repeat and continuations which don't.
22:03:33 <akappa> ksf, if you assign numbers to source line then you would have solved the halting problem
22:03:41 <ksf> ...so you can't tell, in the general case, whether 3.33333... is 1/3, in the general case.
22:03:49 <Cale> ksf: But real numbers are not sequences of digits.
22:03:56 <copumpkin> ksf: except writing 3.33... is a convention/shorthand
22:04:09 <copumpkin> ksf: for 3 + 0.3 + 0.03 + 0.003, _and so on_
22:04:13 <dancor> Cale: aren't they isomorphic to infinite sequences of digits?
22:04:14 <Cale> ksf: Real numbers are represented by sequences of decimal digits, and this representation is not even bijective.
22:04:15 <ksf> ...I'm not talking about the convention.
22:04:21 <dancor> mm
22:04:27 <dancor> i guess it's no bijective
22:04:31 <dancor> not
22:04:36 <akappa> 0.9... = 1
22:04:39 <Cale> In particular, 0.9999... is the same real number as 1
22:05:16 <ksf> yep I spend a few weeks confusing people with that one.
22:05:18 <Cale> This is because the limit as n -> infinity of sum over k = 1 to n of 9/10^k = 1
22:05:20 * copumpkin waits for someone to "disagree"
22:05:21 <tensorpudding> 0.9999.. is the same thing as the infinite sum 9*10^(-n)
22:05:30 <tensorpudding> which is 1
22:05:33 * dancor waits for something to happen
22:05:33 <Cale> right
22:05:46 <QtPlaty[HireMe]> Because there are 2^Alphe_null sequences of which Alphe_null terminate or repeat.  There is no chance of picking a member of the terminating subset from the much larger set.
22:05:46 <copumpkin> yay, no objections
22:05:54 <poe> ..and those are the only two. I'd like to see a way to prove that there are at most two for each real.
22:05:57 <akappa> some people interpret the limit as a procedure that goes on for a long time, but eventually stops
22:06:06 <akappa> for that reason they don't accept that 0.9... = 1
22:06:20 <Cale> QtPlaty[HireMe]: You're assuming a continuous probability distribution :)
22:06:21 <dancor> s/ppl/crazies
22:06:23 <sproingie> limits are funny things
22:06:32 <copumpkin> how about the colimit :o
22:06:34 <poe> that's wrong, limits are finitary measure to encapsulate infinities
22:06:39 * Cale assigns probability 1/2 to 0
22:07:08 <QtPlaty[HireMe]> Cale: True, if you cheet then it doesn't work like that.
22:08:15 <Cale> But yeah, if you do something like take the uniform distribution on [0,1], you get that the probability of a terminating or repeating sequence is 0
22:08:16 * dancor casts bayes theorem
22:08:26 <shrughes> 0.9999... < 1 because 0.9999... = 1.0000...-1
22:08:31 <copumpkin> dancor: psykotic recast it in a cool way recently :)
22:08:50 <ksf> 1.0000...-1 == 0
22:09:04 <ksf> well, as is 0.999999...-1 == 0
22:09:04 <mauke> 0.9̅ = 1
22:09:08 <Cale> shrughes: Yeah, 1 - 1 is 0 ;)
22:09:14 <copumpkin> ooh, fancy overbar
22:09:15 <shrughes> no the -1 is a digit :(
22:09:24 <copumpkin> lol
22:09:27 <Cale> shrughes: which digit?
22:09:34 <shrughes> the last digit
22:09:38 <akappa> last?
22:09:40 <akappa> lol
22:09:40 <vikipedia> map
22:09:43 <mwc> @seen dons
22:09:43 <lambdabot> Unknown command, try @list
22:09:44 <Cale> shrughes: which one is the last one?
22:09:48 <shrughes> after uncountably infinitely many zeros yeah i said uncountably that's rite
22:09:57 <copumpkin> o.O
22:10:02 <dancor> even statisticians have avatars nicknowadays
22:10:10 <Cale> heh
22:10:13 <mauke> preflex: seen dons
22:10:13 <preflex>  dons was last seen on #ghc 3 days, 6 hours, 6 minutes and 57 seconds ago, saying: dcoutts: ok.
22:10:18 <akappa> shrughes, are you one of those people that I've mentioned earlier? :D
22:10:33 <dancor> dons is too famous to hang out here anymore
22:10:39 <shrughes> I don't know what you mentioned
22:10:46 <copumpkin> dancor: bayes' theorem is apparently the inversion of a relation over a topos!
22:10:54 <ddarius> akappa: Any realizable process will eventually finish in our universe (or at least in the span of human existence)
22:10:59 * Cale suspects that shrughes is just trolling :)
22:10:59 <dancor> now i have to learn category theory
22:11:12 <copumpkin> shrughes: we were taking bets on how long it would be before someone denied that 0.9... == 1
22:11:16 <akappa> ddarius, yeah... so? :P
22:11:16 <ksf> ...in algebra, non-terminating recursions actually terminate, due to axiomatic magic.
22:11:17 <Cale> yaaaaaay category theory
22:11:31 <copumpkin> dancor: and he provides haskell code for it!
22:11:37 <dancor> the 'gory details
22:11:41 <ddarius> akappa: Strict finitism all the way.
22:11:45 <shrughes> Cale: I was trying to be funny rather than trolling but people misinterpreted my joke about what people say the value of 1 - 0.9999... looks like
22:11:48 <copumpkin> dancor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9423#a9423
22:12:17 <akappa> shrughes, btw, this isn't the first time that I hear that argument ;)
22:12:24 <Cale> shrughes: actually it might be interesting to formalise a sort of number whose elements are mappings from particular ordinals to digits.
22:12:37 * hackagebot upload: hcc 0.0.0 - A toy C compiler. (TomHawkins)
22:12:45 <shrughes> Cale: sure
22:12:50 <dancor> hadn't seen OPTIONS before.  this post is already unsettlingly deviant..
22:12:51 <Cale> Though presumably you'd use binary to preserve your sanity :)
22:12:54 <copumpkin> oh wow, a c compiler in haskell
22:13:00 <ksf> > (1/3)*3 :: CReal
22:13:01 <lambdabot>   1.0
22:13:03 <ksf> hey
22:13:04 <copumpkin> @hackage hcc
22:13:05 <lambdabot> http://hackage.haskell.org/package/hcc
22:13:14 <sproingie> version 0.0.0
22:13:14 <ksf> > (1/3)*3 :: Real
22:13:15 <lambdabot>   Class `GHC.Real.Real' used as a type
22:13:20 <ksf> > (1/3)*3 :: Float
22:13:20 <ivanm> @hackage PackageGenerator
22:13:20 <lambdabot> http://hackage.haskell.org/package/PackageGenerator
22:13:20 <lambdabot>   1.0
22:13:22 <sproingie> it compiles every program into "Hello world"
22:13:24 <ksf> ...but that's a fake.
22:13:25 <ivanm> ;-)
22:13:37 <dancor> > (1/3) :: CReal
22:13:38 <lambdabot>   0.3333333333333333333333333333333333333333
22:13:44 <ksf> > (1/5)*5 :: Float
22:13:45 <lambdabot>   1.0
22:13:52 <Cale> copumpkin: Awesome, we can make it produce executables which fire up a game of tetris on any undefined behaviour!
22:14:07 <ksf> ...now if I would remember which fractions aren't representable...
22:14:11 <dancor> haskell's failwhale
22:14:19 <copumpkin> so far it looks like a very thin wrapper around Language.C :)
22:14:26 <copumpkin> so thin it doesn't actually compile anything
22:14:55 <dancor> got to start somewhere.  or nowhere in this case.
22:15:17 <ddarius> Language.C + Zipper + Hoopl = Done.
22:15:26 <ksf> what's the plan, submitting C shootout entries and compile them with GHC?
22:15:45 <dancor> > (1/5) :: CReal
22:15:46 <lambdabot>   0.2
22:15:59 <dancor> shouldn't that produce 0.200000000000000.. forever
22:16:09 <Cale> CReal takes an arbitrary approximation, and chops trailing 0's
22:16:10 <ivanm> dancor: no, why?
22:16:20 <dancor> uh huh, that's cheating
22:16:22 <dancor> it's a lie
22:16:23 <Cale> I think the show instance uses 200 digits
22:16:29 <dancor> if it _knew_ it was done that would be one thing
22:16:31 <Cale> or maybe even less
22:16:34 <shrughes> > (1/3) * 3 :: CReal
22:16:36 <lambdabot>   1.0
22:16:38 <copumpkin> only 40
22:16:54 <dancor> CReaLie
22:17:03 <Cale> dancor: It's just the show instance though
22:17:11 <copumpkin> > showCReal 200 (1/5)
22:17:12 <lambdabot>   "0.2"
22:17:12 <dancor> show is supposed to be re-readable!
22:17:20 <Cale> heh
22:17:28 <copumpkin> > showCReal 200 (1/3)
22:17:29 <lambdabot>   "0.333333333333333333333333333333333333333333333333333333333333333333333333...
22:17:40 <dancor> showInternalWorkingsCReal
22:17:48 <dancor> i guess we can't do that without reflection
22:17:52 <ddarius> "<function>"
22:18:09 <ivanm> dancor: well, we don't have showInternal{Map,Set}Representation
22:18:19 <copumpkin> vacuum
22:18:20 <shrughes> > ((1/3) * 3 :: CReal) == 1
22:18:21 <lambdabot>   True
22:18:23 <dancor> ya and we don't _lose_info_ for those either
22:18:30 <copumpkin> == for CReal is sketchy
22:18:33 <dancor> CFail
22:20:24 <shrughes> > ((1/89) :: CReal) == sum [x*0.1^n | x <- fix ((1:) . scanl (+) 1) | n <- [2..200]]
22:20:26 <dancor> also isn't it hard to make a correct/infinite show for CReal
22:20:28 <lambdabot>   mueval-core: Time limit exceeded
22:20:40 <shrughes> > ((1/89) :: CReal) == sum [x*0.1^n | x <- fix ((1:) . scanl (+) 1) | n <- [2..50]]
22:20:44 <lambdabot>   mueval-core: Time limit exceeded
22:20:50 <dancor> since it takes like a d and computes an a/2^d approx
22:20:50 <copumpkin> lol
22:21:17 * dancor is holding out for a CReal that keeps it real
22:21:31 <shrughes> > sum [x*0.1^n | x <- fix ((1:) . scanl (+) 1) | n <- [2..50]]
22:21:32 <copumpkin> CReal and Milk
22:21:33 <lambdabot>   1.1235955056179782e-2
22:21:45 <shrughes> > 1/89 == sum [x*0.1^n | x <- fix ((1:) . scanl (+) 1) | n <- [2..50]]
22:21:46 <lambdabot>   False
22:21:56 <dancor> MIlk is an interesting lib name
22:22:11 <copumpkin> Monad for LL(k) grammars
22:22:50 <dancor> i'ven't seen a lib name that makes use of i/l lexicographic ambiguity b4
22:25:43 <vikipedia> ls
22:25:45 <vikipedia> ls
22:26:43 <Makoryu> vikipedia: Wrong window?
22:26:59 <poe> . ..
22:27:18 <copumpkin> cd ..
22:27:25 <copumpkin> ls -l
22:27:29 <tensorpudding> ghci ~/code/haskell/DestroyTheUniverse.hs
22:27:43 <copumpkin> :r
22:27:51 <ivanm> Makoryu: maybe he's trying to get a list of all people in this channel...
22:28:05 <tensorpudding> :%s/pumpkin/copumpkin/g
22:28:09 <poe> that'd be /names
22:28:50 <pikhq> f _ = (unsafePerformIO launchTheMissiles) `seq` 0
22:28:59 <tensorpudding> kill -9 *
22:29:03 <ivanm> hmmm... need to alias /whois to ls -l ... :p
22:32:42 * hackagebot upload: HSHHelpers 0.21 - Convenience functions that use HSH, instances for HSH. (ThomasHartman)
22:37:44 * hackagebot upload: happstack-helpers 0.44 - Convenience functions for Happstack. (ThomasHartman)
22:42:46 <manju> hello
22:43:13 <manju> I wrote a small prog in haskell, rather copied it from the open book
22:43:36 <manju> I get this error, process_text.hs:15:16:
22:43:36 <manju>     The last statement in a 'do' construct must be an expression
22:43:36 <manju> Failed, modules loaded: none.
22:43:45 <manju> can anyone help
22:44:02 * copumpkin tries to read manju's mind from a distance
22:44:04 * copumpkin fails
22:44:16 <manju> I am pasting it in pastebin
22:44:27 <copumpkin> thanks :) my telepathy's all used up today
22:44:29 <ivanm> paste first, ask questions later! :p
22:44:47 * ivanm sneaks off and steals copumpkin's share of telepathy for tomorrow
22:44:52 <manju> http://pastebin.ca/1678989
22:45:14 <copumpkin> the last line is indented wrong
22:45:23 <manju> sorry, I was trying to find the button for haskell syntax and couldn't find one
22:45:29 <manju> but I am using emacs
22:45:31 <copumpkin> it needs to line up with ineof
22:45:36 <ivanm> manju: the "readLoop" should be indented as much as the "if"
22:45:37 <manju> and it is auto indented
22:45:45 <ivanm> manju: ummm, it isn't perfect ;-)
22:46:01 <ivanm> manju: and AFAIK all indentation modes in haskell-mode will say that that's wrong...
22:46:16 <manju> ivanm, ok...
22:46:26 <manju> I indented it with if, but I still get the error
22:46:49 <manju> the same error
22:46:55 <ivanm> oh, wait, the readLoop inh is wrong as well
22:47:12 <ivanm> manju: "readLoop inh" should be indented with the inh <-
22:47:22 <ivanm> and you're mixing your indentation styles for do statements ;-)
22:47:56 <manju> ok
22:47:59 <manju> let me try this again
22:49:22 <manju> http://pastebin.ca/1678992
22:49:26 <manju> is this any better ?
22:49:35 <manju> I mean I get the same error but in a different line
22:49:45 <ivanm> manju: eh, I liked the old way you had the do block in readloop
22:49:49 <ivanm> manju: fix up the readloop in main
22:49:54 <ivanm> (which I mentioned before)
22:50:56 <manju> Prelude> :load ./process_text.hs
22:50:56 <manju> [1 of 1] Compiling Main             ( process_text.hs, interpreted )
22:50:56 <manju> process_text.hs:15:15: parse error on input `readLoop'
22:50:56 <manju> Failed, modules loaded: none.
22:51:01 <manju> Ok cool I get a new error
22:51:04 <manju> which is progress
22:51:22 <manju> updating paste
22:51:36 <ivanm> manju: your if-then-else block in readloop isn't indented properly
22:51:41 <manju> http://pastebin.ca/1678993
22:52:12 <copumpkin> no
22:52:26 <ivanm> manju: http://pastebin.ca/1678994
22:52:34 <copumpkin> manju: maybe you should take a moment to understand how haskell indentation works :)
22:52:39 <copumpkin> rather than trying all indentation combinations
22:53:40 <manju> probably
22:53:44 <manju> *sigh*
22:53:54 <manju> I didn't know haskell was indentation dependent
22:54:05 <copumpkin> it doesn't have to be, but everyone writes it that way
22:54:22 <manju> as I said, I looked at the first chapter of the book and jumped in
22:55:08 <ivanm> manju: you can use { ... ; ... ; ... }, but it's fuglier
22:55:31 <manju> ah...cool
22:55:39 <manju> I like ugly but understable
22:56:15 <manju> you know what
22:56:28 <manju> there is no change in spaces between my code and the one you pasted
22:56:31 <dobblego> the ugly way is not just as stable as the reasonable way
22:56:39 <manju> but the one you pasted compiles but not mine :-(
22:56:46 <manju> ah...ok
22:57:07 <manju> ack...now it does
22:57:12 <ivanm> manju: also, note that you shouldn't use tabs
22:57:14 * manju bangs head on the keyboard
22:57:27 <ivanm> since for haskell, tab == 8 spaces, which most people don't use
22:57:28 <manju> no I think emacs puts spaces instead of tabs
22:57:44 <copumpkin> I can't imagine who thought 8 spaces was a good idea
22:57:49 <manju> how do I call this function now ?
22:58:14 <manju> cool
22:58:16 <manju> main
22:58:31 <manju> Why doesn't the program exit ?
22:58:45 <manju> I mean when I type main in ghci
22:58:58 <manju> it reads the contents of the file prints it and hangs
22:59:05 <manju> I need to press ctrl+c
22:59:22 <manju> is there like an exit(0) ?
22:59:26 <tensorpudding> i think emacs uses tabs, but changes them into spaces
22:59:38 <tensorpudding> and haskell-mode knows the right amount to use by default
22:59:41 <ivanm> tensorpudding: well, it uses the tab key
22:59:50 <ivanm> and inserts the correct number of spaces for that indentation
22:59:52 <tensorpudding> yeah, but it converts them into spaces when you save
22:59:59 <ivanm> @hoogle exit
22:59:59 <lambdabot> module System.Exit
23:00:00 <lambdabot> System.Exit data ExitCode
23:00:00 <lambdabot> Control.OldException ExitException :: ExitCode -> Exception
23:00:03 <ivanm> manju: ^^
23:00:11 <ivanm> manju: basically, that code is the wrong way of doing it
23:02:26 <manju> ivanm, ok
23:06:53 <ksf> hmmm does hGetLine block if you try to read a file that has no trailing newline?
23:07:24 <ksf> manju, your code should exit like it is. not out of ghci, of course.
23:07:29 <ivanm> dunno
23:07:59 <manju> no not out ghci
23:08:09 <manju> I hit ctrl+c to get ghci command prompt
23:08:18 <manju> I think there is something wrong with hGetLine
23:09:53 <copumpkin> right
23:09:58 <ksf> yep
23:10:15 <copumpkin> when in doubt with one's first venture into a new language, blame the standard library
23:10:45 <ksf> the idiomatic way for such things (I take it you want to write a shell filter) is interact
23:10:47 <ksf> :t interact
23:10:48 <lambdabot> (String -> String) -> IO ()
23:10:56 <ksf> ...and
23:10:59 <ksf> :t unlines
23:11:01 <lambdabot> [String] -> String
23:11:04 <ksf> er no
23:11:06 <ksf> :t lines
23:11:07 <lambdabot> String -> [String]
23:11:50 <manju> no I mean something wrong with my usage of GetLine
23:11:58 <ksf> nope
23:12:18 <tensorpudding> what is the haskell standard library? the prelude?
23:12:37 <ivanm> tensorpudding: the base package
23:12:47 <ivanm> probably with array and containers thrown in for good measure
23:12:53 <tensorpudding> okay
23:12:56 <ivanm> tensorpudding: or, slightly more loosely, whatever comes with GHC
23:13:05 <ivanm> (not including extralibs for older versions)
23:13:16 <ksf> ah duh.
23:13:17 <manju> does anyone know why program in not exiting ?
23:13:28 <ksf> because return doesn't return.
23:13:50 <ksf> it's just a noop, in this case.
23:13:52 <manju> but the real world book uses it
23:13:53 <ivanm> return doesn't exit the function automagically
23:14:03 <manju> http://book.realworldhaskell.org/read/io.html
23:14:24 <ivanm> manju: indent "readLoop inh" to be under "putStrLn inpStr"
23:14:35 <ivanm> I think that's probably what you're wanting
23:15:07 <manju> ah...cool
23:15:10 <manju> yes
23:15:14 <manju> it works thanks ivanm
23:15:20 <ivanm> no worries
23:16:53 <ksf> :t return
23:16:53 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:17:00 <ksf> :t return () :: IO ()
23:17:02 <lambdabot> IO ()
23:17:16 <ksf> it's just a way to inject a value into the monad
23:18:09 <manju> well...maybe I can't learn haskell by using it to write small scripts
23:18:17 <manju> :-(
23:18:23 <manju> like python or ruby
23:18:35 <manju> I don't even understand what lambdabot says
23:18:41 <ksf> oh, you can.
23:19:13 <ksf> but chapter 7 of rwh is probably too early to figure return out by yourself, especially if you used imperative languages, before
23:19:27 <manju> ok...
23:19:48 * ksf still thinks it's the worst named function in the whole Prelude, as it doesn't follow the principle of least suprise
23:19:52 <manju> can you tell me how my program started working when I put readLoop inh inside the else ?
23:20:22 <manju> instead of putting it at the same place as the ineof
23:20:47 <ksf> I think it's better if you witness that yourself.
23:20:54 <ksf> ...add an import Debug.Trace
23:21:09 <ksf> and replace the condition with "trace ("ineof" ++ show ineof) ineof"
23:21:12 <ksf> and run the code
23:21:54 <ksf> (Debug.Trace being a refreshing desert in an oasis of purity)
23:23:12 <ksf> ...or, actually, just say "print ineof" on the line before the if
23:23:25 * manju 's jaw drops to the ground
23:23:32 <manju> wow
23:23:38 <manju> that is co sool
23:23:43 <manju> that is so cool
23:26:08 <mwc> I think the entire channel can appreciate this http://people.planetpostgresql.org/andrew/uploads/php-bugfix.png
23:26:16 * ksf recommends whileFile inh f = do { ineof <- hIsEOF inh; if ineof then return () else do {f; readLoop inH} }
23:26:47 <ksf> make that f "f inh"
23:26:50 <ksf> then you can do
23:27:29 <ksf> whileFile (\inh -> do { inpStr <- hGetLine inh; putStrLn inpStr } and don't ever have to worry about looping, again
23:28:23 <manju> that is cool
23:30:09 <manju> thanks for the help
23:30:16 <manju> I think I will read the book first though
23:30:21 <manju> to understand the above code
23:30:54 <ksf> it's a relatively common ideom
23:31:07 <ksf> ...but it's not easy to accustom to.
23:31:30 <ksf> whileFile :: Handle -> (Handle -> IO ()) -> IO ()
23:32:04 <manju> is the (\inh part of the code
23:32:09 <ksf> yep
23:32:14 <manju> ok
23:32:17 <ksf> read \ as lambda
23:32:30 <manju> ah
23:55:22 <BMeph> Cool - whileFile = >$>
23:57:38 <ksf> erm...
23:57:48 <ksf> you're not serious, are you?
23:58:11 <ksf> I wouldn't be surprised if we have a function with that signature, but with the same code?
23:59:35 <ksf> hInteract and withFiles :: [FilePath] -> (Handle -> IO ()) -> IO () would be good additions to the standard libs, I think
