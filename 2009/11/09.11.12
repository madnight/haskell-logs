00:00:07 <bos> it's just the result of "show >>value that is NaN<<"
00:00:36 <c_wraith> > read "NaN" :: Double
00:00:38 <lambdabot>   NaN
00:00:39 <copumpkin> it seems like the notions of slice category and hom functor are related?
00:00:41 <c_wraith> hehe. :)
00:00:43 <Veinor>  recurse f x = snd $ until (liftA2 (==) fst snd) (snd &&& (f $ snd)) (f x, x)
00:00:57 <Veinor> why does this fail trying to construct an infinite type?
00:00:58 <copumpkin> Veinor: as kmc said, just replace liftA2 (==) fst snd with uncurry (==)
00:01:09 <copumpkin> it's not f $ snd
00:01:10 <copumpkin> it's f . snd
00:01:13 <copumpkin> or f $ snd x
00:02:00 <copumpkin> :t until (uncurry (==)) (snd &&& (f . snd)) (f x, x)
00:02:02 <lambdabot> (Expr, Expr)
00:02:10 <Veinor> ahh
00:02:22 <copumpkin> :t let recurse f x = snd $ until (uncurry (==)) (snd &&& f . snd) (f x, x) in recurse
00:02:24 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
00:03:22 <c_wraith> > let recurse f x = snd $ until (uncurry (==)) (snd &&& f . snd) (f x, x) in recurse (floor . sqrt . fromIntegral) 77
00:03:23 <lambdabot>   1
00:03:31 <c_wraith> it works! :)
00:03:34 <copumpkin> nice ;)
00:03:42 <Veinor> haha, yep
00:04:07 <Veinor> is that a good way to write recurse, or is there a 'haskellier' way?
00:04:31 <c_wraith> well.  It's a fixed point calculation, so I'd name it something like that.  but "fix" is already taken.  :)
00:05:11 <Veinor> hm, enlargeToFixed? fixedPoint?
00:05:57 <c_wraith> But the code is pretty idiomatic.
00:06:39 <Veinor> I think fixedPoint is a good name for it.
00:06:53 <copumpkin> it can be made even more point-free without getting too ugly, fwiw
00:07:24 <Veinor> oh?
00:07:28 <copumpkin> :t let recurse f = snd . until (uncurry (==)) (snd &&& f . snd) . (f &&& id) in recurse
00:07:30 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
00:07:46 <copumpkin> anything beyond that would kill it :P
00:08:19 <Veinor> heh
00:08:57 <c_wraith> @pl \f -> snd . until (uncurry (==)) (snd &&& f . snd) . (f &&& id)
00:08:57 <lambdabot> (snd .) . ap ((.) . until (uncurry (==)) . (snd &&&) . (. snd)) (&&& id)
00:09:15 <c_wraith> it only got slightly longer!
00:09:39 <Veinor> hehe
00:10:06 <Veinor> @unpl  snd . until (uncurry (==)) (snd &&& f . snd) . (f &&& id)
00:10:07 <lambdabot> (\ d -> snd (until (uncurry (==)) (\ k -> (snd &&& f) (snd k)) ((f &&& \ a -> a) d)))
00:10:37 <kmc> so given that everyone has Go fever... is anyone working on a Haskell module Language.Go?
00:10:39 <c_wraith> @unpl expanded id to \a -> a ?
00:10:40 <lambdabot>  Parse error at "\a" (column 16)
00:10:57 <Veinor> @unpl id
00:10:57 <lambdabot> (\ a -> a)
00:11:04 <Veinor> well, id is technically pointless :P
00:11:05 <kmc> or Language.Issue9 if you prefer
00:11:20 <kmc> i think it could be a good compiler target language for some things
00:12:18 <ttmrichter> Where is this Go fever, kmc?
00:12:23 <ttmrichter> I need to know what to avoid.  :)
00:12:46 <kmc> go-norrhea
00:13:16 <Veinor> > let recurse f x = snd $ until (uncurry (==)) (snd &&& f . snd) (f x, x) in recurse (floor . sqrt . fromIntegral) -1
00:13:17 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
00:13:17 <lambdabot>    arising from the literal `1' at <...
00:13:22 <Veinor> what
00:13:31 <c_wraith> (-1)
00:13:33 <Veinor> oh
00:13:37 <Veinor> that keeps tripping me up
00:13:40 <Veinor> > let recurse f x = snd $ until (uncurry (==)) (snd &&& f . snd) (f x, x) in recurse (floor . sqrt . fromIntegral) (-1)
00:13:41 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
00:13:54 <c_wraith> Hmm.  that answer confuses me
00:14:05 <Veinor> sqrt of a negative number is NaN
00:14:14 <Veinor> floor NaN is -2696...
00:14:21 <c_wraith> > floor (0/0)
00:14:22 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
00:14:36 <c_wraith> I see.  So it becomes a fixed point rapidly
00:14:50 <tensorpudding> > fix floor
00:14:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:14:52 <lambdabot>    `GHC.Real.RealFrac a'
00:14:52 <lambdabot>   ...
00:14:53 <Veinor> Yeah.
00:15:09 <copumpkin> > fix floor :: Double
00:15:10 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
00:15:11 <lambdabot>    arising from a use ...
00:15:21 <copumpkin> > fix (fromIntegral . floor) :: Double
00:15:26 <lambdabot>   mueval-core: Time limit exceeded
00:15:31 <copumpkin> :)
00:15:38 <tensorpudding> lol
00:19:05 <Veinor> if anybody's curious the reason I need fixedPoint is because the inverse of a nimber is defined as the smallest S that cannot be enlarged by a certain operation :D
00:19:16 <copumpkin> nimber?
00:19:38 <tensorpudding> the unverse a nimber, for the foxedPint
00:19:45 <Veinor> ... what?
00:19:47 <copumpkin> lol
00:20:03 <Veinor> for my purposes nimbers are basically an alternate field over the reals
00:20:14 <Veinor> er
00:20:18 <Veinor> non-negative integers
00:20:21 <Veinor> bit of a difference there!
00:20:24 <copumpkin> just a tad
00:20:49 <tensorpudding> Z+ forms a field?
00:20:51 <tensorpudding> news to me
00:21:15 <Veinor> nimbers do, x + x = 0 for all x :D
00:21:18 <jfredett> So... I just got the weirdest error I've ever gotten in Haskell...
00:21:20 <copumpkin> :o
00:21:46 <medfly> jfredett, what is it?
00:21:48 <jfredett> When building up a Monad Transformer Stack:  Exception: No match in record selector Var.tcTyVarDetails
00:21:59 <Veinor> technically they're defined over the ordinals, but I don't know how to implement that
00:22:02 <jfredett> I think that's part of the deriving stuff
00:22:12 <copumpkin> Veinor: lattice?
00:22:14 <Veinor> plus then I'd have to wrap my head around the fact that omega^3 = 2 :/
00:22:40 <tensorpudding> i'm a bit confused by what you're talking about
00:22:42 <copumpkin> Veinor: did you see that thing I linked to earlier?
00:22:46 <tensorpudding> okay, not a bit, a lot
00:22:54 <Veinor> yeah, I didn't understand it
00:22:57 <Veinor> :D
00:23:04 <Veinor> I'm taking the combinatorial game theory approach here
00:23:04 <c_wraith> You know, a foxedPint sounds good about now
00:23:05 <c_wraith> :)
00:23:39 <jfredett> i do : deriving (Functor, Monad, MonadReader Email, MonadState Bool, MonadIO) on a stack which looks like: newtype FooC t => Foo t a = F ReaderT String (StateT t IO) a
00:23:57 <jfredett> I can paste the code, but it's such an odd error, I was curious if anyone had ever ran into it...
00:24:20 <Veinor> but yeah, the thing is that the cube of omega is equal to... 2.
00:24:45 <Veinor> and I don't get why and it makes my head hurt.
00:24:53 <tensorpudding> wait, what?
00:24:54 <copumpkin> cube of omega is 2?
00:25:01 <c_wraith> http://en.wikipedia.org/wiki/Nimber
00:25:01 <jfredett> Veinor: so omega = cuberoot(2)?
00:25:03 <jfredett> ...
00:25:08 <tensorpudding> omega being the first infinite ordinal?
00:25:22 <Veinor> yes, that omega
00:25:25 <tensorpudding> how do you talk about cubing an ordinal
00:25:26 <jfredett> Veinor: oh
00:25:27 <copumpkin> oh
00:25:36 <jfredett> that is significantly more weird...
00:25:43 <copumpkin> Veinor: by yes, that omega, you mean cuberoot(2)
00:25:48 <copumpkin> not the first infinite ordinal
00:26:02 <jfredett> copumpkin: I kindof hope it's the first inf. ordinal...
00:26:12 <Veinor> the first infinite ordinal considered as a nimber
00:26:15 <jfredett> that would be delightful brainhurt
00:26:24 <tensorpudding> my brain hurts already
00:26:26 <copumpkin> sounds weird :)
00:26:35 <jfredett> so -- no takers on my Var.tcTyVarDetails problem?
00:26:37 <jfredett> :)
00:26:38 <Veinor> the convention is to use *2 for the nimber 2, so *omega * *omega * *omega = 2
00:26:40 <tensorpudding> after we started talking about algebra on ordinals
00:27:28 <jfredett> Perhaps it's something silly happening since the class restriction involves assoc. types.
00:27:31 <Veinor> or if you want, omega ** omega ** omega = 2, where ** is nim-multiplication
00:27:33 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3621
00:27:57 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3422
00:28:04 <jfredett> I should start checking the GHC trac before I ask about obscure errors...
00:28:16 <Veinor> I have no clue what that means but it's cool
00:28:43 <copumpkin> seems fairly common, but none of those exactly match your circumstances
00:28:51 <copumpkin> 2714 is another one
00:28:55 <Veinor> apparently the smallest algebraically closed field is the set of all nimbers less than omega^(omega^omega), so yeah.
00:29:02 <jfredett> copumpkin: I imagine I'll be able to generalize, thanks...
00:29:33 <tensorpudding> the smallest?
00:29:55 <Veinor> yeah.
00:30:00 <tensorpudding> hmm, i do suppose that is the only countable algebraically closed field i know of
00:30:06 <Veinor> the set of 'finite' nimbers isn't algebraically closed
00:30:24 <Veinor> tensorpudding: that's not a countable set though :P
00:30:50 <tensorpudding> if it's not countable, then in what sense is it the smallest?
00:31:07 <copumpkin> it's between countable and 2^n O:-)
00:31:14 <Veinor> haha
00:31:23 <tensorpudding> what?
00:31:35 <Veinor> you can define size relations between uncountable sets, you know :P
00:31:57 <Veinor> and ordinal numbers have the property that x < x + 1, unlike infinite cardinalities
00:32:40 <Veinor> (by the way, I think omega^omega^omega has cardinality of aleph-2, but I'm not entirely sure.)
00:32:56 <Veinor> it's certainly at least as big as aleph-2.
00:32:58 <tensorpudding> i thought that omega^omega was countable
00:33:25 <copumpkin> Veinor: you should this in agda, not haskell
00:33:29 <copumpkin> and then prove stuff about it
00:33:42 <Veinor> hm, it might be countable actually
00:33:44 <c_wraith> does agda support ordinals? ;)
00:33:50 <Veinor> ... frig, you're right, it is
00:33:58 <copumpkin> nope
00:34:01 <copumpkin> well, not directly
00:34:39 <tensorpudding> it can be reached using countably many applications of the ordinal successor function
00:34:40 <Veinor> ... or is it? I forget, is 1 + w^2 + w^4 + w^6 + ... in w^w?
00:34:54 <tensorpudding> i think
00:35:06 <tensorpudding> this is my understanding from the wiki article on ordinals
00:35:30 <Veinor> hm
00:35:42 <Veinor> I think part of the problem is I'm used to combinatorial ordinals, which have different properties
00:36:00 <Veinor> like, in a combinatorial sense, 1+w=w+1, but not according to traditional ordinal theory
00:36:27 <tensorpudding> ordinals are really complex
00:36:31 <Veinor> but yeah, wiki says w^w^w is countably infinite
00:36:56 <tensorpudding> compared to cardinals, which have that continuum hypothesis
00:37:01 <Veinor> heh
00:37:04 <bastl> Good morning! After upgrading ubuntu, i have probnlems with gtk2hs, specifically mozembed / xulrunner-dev:
00:37:09 <tensorpudding> you only have one countably infinite cardinal
00:37:27 <bastl> When linking my Application I get this error: /usr/bin/ld: warning: libmozjs.so, needed by /usr/lib/xulrunner-devel-1.9.1.4/lib/libxul.so, not found (try using -rpath or -rpath-link) (sorry for pasting)
00:37:36 <Veinor> games are a really fun extension to the reals, you lose trichotomy
00:38:00 <Veinor> you have to define x || y, meaning 'is fuzzy to' :P
00:40:03 <tensorpudding> this sounds like sketchy math
00:40:15 <Veinor> eh, you can definite it rigorously
00:40:32 <Veinor> they're related to dedekind cuts
00:40:45 <Veinor> only the left set doesn't have to be greater than the right set, and the two sets don't have to make up the entire real line
00:41:14 <Veinor> so you have {1 | -1}, which is less than all numbers > 1, greater than all numbers < -1, and fuzzy with everything else
00:42:42 <Veinor> they don't have much use outside of combinatorial game theory but I think they're cool
00:43:04 <tensorpudding> i'm surprised such odd things would come out of a realm called combinatorial game theory, but it sounds cool
00:43:19 <lament> dude, CGT is the best
00:43:34 <Veinor> well, CGT is basically designed to assign values to positions in certain games
00:43:41 <lament> in Go!
00:43:46 <Veinor> in hackenbush!
00:43:51 <lament> Go!
00:44:09 <Veinor> Domineering!
00:44:15 <lament> CGT is a tool developed to study go, and hackenbush is a tool developed to study CGT
00:44:20 <Veinor> :P
00:44:27 <c_wraith> Surreal Numbers were also an offshoot of this research.
00:44:44 <c_wraith> And fall somewhere between Games and Dedekind Cuts
00:44:55 <Veinor> yeah, surreal numbers are games restricted to L < R
00:47:03 <donri> what actually is (->), it's difficult to search for
00:47:17 <kmc> in what context?
00:47:29 <kmc> -> is the infix constructor of function types
00:47:31 <copumpkin> it's a few different things
00:47:33 <mmorrow> @type id :: (->) a a
00:47:33 <kmc> ((->) a b) means a -> b
00:47:34 <lambdabot> forall a. a -> a
00:47:52 <copumpkin> :t \x -> x
00:47:54 <lambdabot> forall t. t -> t
00:48:02 <c_wraith> It's also used for specifying functional dependencies in typeclasses
00:48:04 <copumpkin> :t \x -> case x of x -> x
00:48:05 <lambdabot> forall t. t -> t
00:48:30 <mmorrow> @let x\->f = f x
00:48:31 <lambdabot>  Defined.
00:48:34 <mmorrow> :)
00:48:45 <copumpkin> and view patterns, if we're going into extensions
00:48:47 <donri> but what are its implications? i first thought it was only a syntax for type declarations, but it's used for case switches, there's a ((->) r) monad...
00:48:54 <donri> i'm a little confused as to what it actually means/is/uh
00:48:57 <mmorrow> @type (\->\x->(x\->))
00:48:58 <lambdabot> parse error on input `->'
00:49:08 <copumpkin> donri: those are all different uses of the same symbol
00:49:13 <mmorrow> @type (\-> \x->(x\->))
00:49:14 <lambdabot> forall t t1. t -> (t -> t1) -> t1
00:49:26 <copumpkin> well, type declaration (->) is the same as the ((->) r) monad instance
00:49:34 <copumpkin> but everywhere else it's just syntax
00:49:40 <mmorrow> type Function = (->)
00:49:45 <mmorrow> id :: Function a a
00:50:22 <donri> so in case switches it's just syntax, not some infix function or anything?
00:50:42 <c_wraith> in case and lambda expressions, it's just syntax
00:50:49 <mmorrow> donri: it's reserved syntax, so it's kindof irregular in some contexts
00:50:58 <mmorrow> syntactically
00:51:02 <copumpkin> > let (–>) = flip (^) in 2 –> 3
00:51:04 <lambdabot>   9
00:51:08 <mmorrow> cheater!
00:51:09 <donri> ah, maybe that's why it confuses me
00:51:17 <copumpkin> sorry, don't pay attention to me
00:51:20 <mmorrow> :)
00:51:35 * copumpkin grins
00:51:47 <donri> so uhm, there you overrode the syntax with an infix function?
00:52:01 <c_wraith> he cheated by using a unicode character
00:52:04 <donri> oh!
00:52:10 <donri> sneaky
00:53:05 <donri> > let (→) = flip (^) in 2 → 3
00:53:06 <lambdabot>   <no location info>: parse error on input `→'
00:53:10 <donri> heh
00:53:29 <mmorrow> @let (↺) = fix
00:53:30 <lambdabot>  Defined.
00:53:39 <c_wraith> hahah.  that's evocative.
00:53:42 <copumpkin> that's an awesome character for fix
00:53:47 <copumpkin> pity we can't use it on its own
00:53:59 <copumpkin> I guess if you have postfix operators we can use it postfix
00:54:02 <donri> why doesn't → work
00:54:11 <copumpkin> > const ↺ 4
00:54:13 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
00:54:17 <mmorrow> yeah, having to parenthesize operators gets kindof annoying
00:54:17 <c_wraith> > ((1:) ↺)
00:54:18 <copumpkin> donri: it does
00:54:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:54:25 <copumpkin> cute :)
00:54:29 <donri> copumpkin, what am i doing wrong, then?
00:54:30 <mmorrow> SML does it right
00:54:36 <copumpkin> donri: you just didn't write a full expression :)
00:54:41 <copumpkin> o hwait, you did
00:54:43 <int-e> > let id :: a → a; id x = x in id 2
00:54:45 <lambdabot>   2
00:54:57 <copumpkin> donri: we have unicode syntax turned on
00:55:03 <copumpkin> so the character you used was still syntax :P
00:56:01 <donri> huh?
00:56:07 <copumpkin> that unicode arrow
00:56:15 <copumpkin> is syntax in GHC if you turn on a language extension
00:56:24 <donri> awesome
00:56:24 <copumpkin> which lambdabot happens to have turned on
00:57:15 <c_wraith> > (scanl (+) 1 ↺)
00:57:16 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
00:57:43 <int-e> let (⇛) = (^) in 2 ⇛ 3 -- also ↠↦↬↪⇀⇉⇨⇢⇰⇾⇸⇻
00:57:50 <copumpkin> > (((0:) . scanl (+) 1) ↺)
00:57:51 <donri> > do x ← Nothing; y ← Just "something; return y
00:57:51 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:57:52 <lambdabot>   <no location info>:
00:57:53 <lambdabot>      lexical error in string/character literal at end o...
00:58:04 <donri> doh
00:58:08 <donri> > do x ← Nothing; y ← Just "something"; return y
00:58:09 <lambdabot>   Nothing
00:58:13 <donri> cute
00:58:30 <copumpkin> int-e: needs to be flip (^) !!!
00:58:51 <c_wraith> that looks like part of the definition of Ackerman's function
00:58:53 <donri> > “hi”
00:58:55 <lambdabot>   <no location info>: lexical error at character '\8220'
00:58:56 <mmorrow> gah, there's gotta be a unicode subscript "i"
00:59:23 <mmorrow> can't seem to find one using charmap, but then again this is probably the least efficient way of searching..
00:59:33 <donri> is there a listing of interpreted unicode with this extension somewhere?
00:59:33 <int-e> copumpkin: http://en.wikipedia.org/wiki/Conway_chained_arrow_notation ... no ;-)
00:59:34 <copumpkin> there aren't very many subscripts in there sadly
01:00:03 <mmorrow> it's funny how you know exactly what the unicode char you want /looks/ like, but you have no way of expressing that to the computer to find it for you
01:00:13 <copumpkin> int-e: oh, different arrow then :o
01:00:51 <int-e> copumpkin: that one looks hard to implement in haskell though; it's ternary.
01:00:58 <copumpkin> yep
01:01:02 <mmorrow> woot, Phonetic Extensions ftw
01:01:06 <mmorrow> xᵢ
01:01:10 <copumpkin> nice
01:01:13 <copumpkin> is it in the bmp?
01:01:26 <mmorrow> err, what do you mean?
01:01:36 <copumpkin> basic multilingual plane
01:01:44 <copumpkin> does it have a code point below 65k?
01:01:49 <mmorrow> U+1D62 LATIN SUBSCRIPT SMALL LETTER I
01:01:55 <copumpkin> oh cool
01:01:58 <mmorrow> , "ᵢ"
01:02:00 <lunabot>  "\7522"
01:02:06 <mmorrow> , utf8enc "ᵢ"
01:02:07 <lunabot>  "\225\181\162"
01:02:38 <kmc> how do i use a Parsec parser in such a way as to get not only the parse result, but also the input consumed?
01:04:27 <donri> doesn't parsec fail unless it consumes the whole input
01:05:24 <donri> oh, perhaps not.
01:06:34 <int-e> kmc: use getInput
01:07:09 <int-e> kmc: i.e.  parseWithRest x = do result <- x; rest <- getInput; return (x, rest)
01:07:09 <kmc> that will work to get the consumed bit of a smaller parser within a bigger one?
01:07:15 <kmc> cool
01:07:15 <quicksilver> donri: no, if you want it to do that you use "eof" at the end.
01:07:18 <kmc> thanks
01:07:40 <donri> quicksilver, yea, realised that. :)
01:08:15 <int-e> kmc: sorry, I answered the wrong question. Hmm.
01:08:24 <copumpkin> w00t, I just wrote ackermann in agda
01:08:32 <copumpkin> the power!
01:12:01 <int-e> kmc: I doubt that you can get the consumed part directly; the parser tries to release it as soon as possible. You can compare remaining input and original input, or try your luck with making sense of the SourcePos data (see getPosition).
01:13:04 <mmorrow> @let kmp p s = let go [] _ _ _  = True; go (_:_) [] _ _ = False; go (p:ps) (s:ss) op os = if(p==s)then(go ps ss op os)else(case os of []->False; _:ss->go op ss op ss) in go p s p s
01:13:05 <lambdabot>  Defined.
01:13:53 <mmorrow> @let myIsInfixOf p s = let tails [] = [[]]; tails xxs@(_:xs) = xxs : tails xs; isPrefixOf [] _ = True; isPrefixOf _  [] = False; isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys in any (isPrefixOf p) (tails s) {- so it's bytecode too -}
01:13:54 <lambdabot>  Defined.
01:13:59 <fasta> Is there a Haskell equivalent of readlink -f which is portable?
01:14:10 <mmorrow> > kmp "asdf" (take 1000000 (cycle "asd@@@@@@@@@@@@@@@@") ++ "asdf")
01:14:12 <lambdabot>   True
01:14:17 <mmorrow> > myIsInfixOf "asdf" (take 1000000 (cycle "asd@@@@@@@@@@@@@@@@") ++ "asdf")
01:14:21 <lambdabot>   True
01:14:25 <mmorrow> > myIsInfixOf "asdf" (take 10000000 (cycle "asd@@@@@@@@@@@@@@@@") ++ "asdf")
01:14:29 <lambdabot>   mueval-core: Time limit exceeded
01:14:30 <mmorrow> > kmp "asdf" (take 10000000 (cycle "asd@@@@@@@@@@@@@@@@") ++ "asdf")
01:14:34 <lambdabot>   mueval-core: Time limit exceeded
01:14:36 <mmorrow> bah
01:14:44 <mmorrow> it's faster
01:15:19 <mmorrow> , let kmp p s = let go [] _ _ _  = True; go (_:_) [] _ _ = False; go (p:ps) (s:ss) op os = if(p==s)then(go ps ss op os)else(case os of []->False; _:ss->go op ss op ss) in go p s p s in time (kmp "asdf" (take 1000000 (cycle "asd@@@@@@@@@@@@@@@@") ++ "asdf"))
01:15:23 <lunabot>  (0.761885,True)
01:15:53 <mmorrow> , let myIsInfixOf p s = let tails [] = [[]]; tails xxs@(_:xs) = xxs : tails xs; isPrefixOf [] _ = True; isPrefixOf _  [] = False; isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys in any (isPrefixOf p) (tails s) in time (myIsInfixOf "asdf" (take 1000000 (cycle "asd@@@@@@@@@@@@@@@@") ++ "asdf"))
01:15:57 <lunabot>  (1.9167079999999999,True)
01:16:48 * mmorrow just lifted that (unspecialized) knuth-morris-pratt matcher from a partial-eval/comp paper
01:17:53 <mmorrow> where the test of different method of partial computation was whether or not they could derive a specialized knuth-morris-pratt matcher from that function and a known first argument
01:19:24 <mmorrow> http://citeseer.ist.psu.edu/94413.html is the link if anyone is interested (although it isn't loading for me atm)
01:20:17 <fasta> Is there any reason why installing the unix package does not work on Windows Vista?
01:20:49 <fasta> Most of the file stuff should be possible to do, AFAIK, at least.
01:20:49 <copumpkin> not loading for me either
01:21:10 <sieni> Is there a reason why RJ-45 cable doesn't plug into the mains socket?
01:22:01 <ehamberg> sieni: it's not itended to fit. oh, i see what you did there.
01:22:36 <copumpkin> that's true PoE
01:22:43 <mmorrow> here it is http://moonpatio.com/repos/unifying_partialeval_supercomp.ps
01:23:21 <copumpkin> I think we should have a unifying grammar of paper titles
01:23:32 <copumpkin> "Towards" is a title function
01:23:39 <copumpkin> it takes a title and makes it incomplete
01:23:57 <mmorrow> heh
01:24:19 <copumpkin> not that it's a bad thing :)
01:24:40 <int-e> mmorrow: hmm, that's not KMP
01:24:52 <mmorrow> copumpkin: heh at making the grammar rigorous
01:25:01 <mmorrow> int-e: err, apparently it's a "
01:25:05 * mmorrow checks the paper
01:25:31 <mmorrow> oh, right
01:25:33 <int-e> mmorrow: it's a streamlined filter (isPrefixOf needle) (tails haystack)
01:25:44 <mmorrow> int-e: it becomes one once it's specialized on a known first argument
01:25:57 <int-e> mmorrow: ah I can believe that.
01:26:23 <copumpkin> what other logics are there beyond intuitionist/constructivist and classical?
01:26:30 <mmorrow> apparently deforestation and partial-eval aren't enough by themselves, and supercompilation and "generalized partial computation" are
01:26:34 <mmorrow> enough
01:28:22 <mmorrow> since the latter two propagate information from the pattern match that would have to take place to follow that branch, down that branch during various forms of abstract interp
01:28:29 <mmorrow> and the former two don't
01:31:58 <bastl> Can anyone provide the equivalent of "data2tree" using multirec? I feel it should be a oneliner, but im still struggling with understanding the background/foundations ...
01:32:07 <mmorrow> (propagate down *every* branch)
01:33:11 <dreixel> bastl: I don't think it'll be a one-liner
01:33:51 <dreixel> but I don't think it's hard. Give me 5 minutes...
01:33:56 <bastl> :-)
01:34:49 <chachaonnaog> software and algorithms shouldn't be free
01:34:50 <fasta> Can I programmatically get how long ago cabal update has been run successfully?
01:35:02 <chachaonnaog> dreixel: charge for your services
01:35:19 <chachaonnaog> bastl: you don't beg, but PAY
01:35:20 <chachaonnaog> muahaha
01:35:23 <bastl> chachaonaog: this is research, and that should be fre.
01:35:26 <dreixel> lol
01:35:43 <dreixel> if I charge for this I'm afraid I'll have to declare that to my funding institution and return some money to them...
01:36:12 <chachaonnaog> now you see.. free software is like a plague
01:36:16 <chachaonnaog> :)
01:36:57 <fasta> chachaonnaog, do you also have any new points? Like a new economic model for software-development?
01:37:23 <fasta> chachaonnaog, if not, go to #chachaonnaog. You can talk there as much as you want.
01:38:28 <fasta> In principle _nothing_ is truly free, because you only live for a finite amount of time.
01:40:44 <chachaonnaog> i see you have thought about this much, muh boy. good!
01:41:29 <chachaonnaog> the sad part is that nothing is gonna change
01:42:12 <medfly> a trll?
01:42:14 <medfly> troll
01:42:25 <copumpkin> seems fine to me
01:42:32 <fasta> medfly, yes, obvious troll.
01:42:37 <medfly> okay
01:43:17 <copumpkin> :)
01:44:55 <chachaonnaog> is troll a person who has no another utopic economic model for software development?
01:45:14 <quicksilver> chachaonnaog: this channel is for haskell chat please
01:45:23 <medfly> well, that isn't so true
01:45:27 <medfly> thisc hannel is so many things :)
01:45:32 <copumpkin> chachaonnaog: you should talk to shelby moore
01:45:48 <kmc> > text "information just wants to be free, man"
01:45:49 <lambdabot>   information just wants to be free, man
01:46:28 <squidsoup> so my local university has abandoned it's haskell paper, and now has no functional programming offering
01:46:29 <kmc> > text $ map succ "information just wants to be free, man"
01:46:30 <lambdabot>   jogpsnbujpo!kvtu!xbout!up!cf!gsff-!nbo
01:46:38 <squidsoup> *its
01:46:40 <kmc> for $9.95 i'll decode what lambdabot just said
01:46:58 <jelly12gen> squidsoup: that's bad
01:47:03 <Alpounet> squidsoup, way much easier to understand this way
01:47:03 <jelly12gen> and sad
01:47:11 <squidsoup> indeed
01:47:21 <Alpounet> it's just... obvious.
01:47:25 <jelly12gen> kmc: that's easy :D
01:47:26 <squidsoup> apparently java is more interesting.
01:47:28 <squidsoup> :/
01:47:33 <jelly12gen> @t text
01:47:34 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:48:02 * jelly12gen hoogles
01:48:10 <Alpounet> @type text
01:48:11 <lambdabot> String -> Doc
01:48:59 <kmc> > hsep $ map show [1,3..21]
01:48:59 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
01:49:00 <lambdabot>         agains...
01:49:08 <kmc> :t hsep
01:49:09 <lambdabot> [Doc] -> Doc
01:49:15 <kmc> > hsep $ map doc [1,3..21]
01:49:16 <lambdabot>   Not in scope: `doc'
01:49:21 <kmc> > hsep $ map (text.show) [1,3..21]
01:49:22 <lambdabot>   1 3 5 7 9 11 13 15 17 19 21
01:52:53 <jelly12gen> there is ghci :D
01:59:36 <dreixel> bastl: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12069#a12069
02:01:32 <bastl> dreixel: cool. gotta try to adapt that to my (big) languages.
02:01:47 <bastl> and afterwards udnerstand :-)
02:02:54 <maartenm> hello I have a question about monads, just learnign about them in LYAH
02:03:01 <maartenm> getContents is "lazy" IO
02:03:23 <maartenm> while getLine is not lazy
02:03:24 <bastl> and referring to chachasomething: If someone read "the cathedral and the bazaar", dont miss "the midget and the turd": http://fringe.davesource.com/Fringe/Computers/Philosophy/Cathedral_Bazaar/Parody.html
02:03:50 <maartenm> how does this get defined in haskell, how can I create my own lazy IO?
02:04:12 <dreixel> bastl: what exactly do you need? some sort of a serializer?
02:04:12 <fasta> maartenm, quicksilver will kill you if you do.
02:04:21 <quicksilver> maartenm: lazy IO is a mangled train wreck, cannot be implemented in haskell, and should never have been part of the standard.
02:04:23 <maartenm> he's probably asleep
02:04:24 <maartenm> damn
02:04:38 <quicksilver> maartenm: if you want to implement your own, the key primitive is 'unsafeInterleaveIO'
02:04:38 <maartenm> ok so it's a hack
02:04:41 <maartenm> just as I thought
02:04:43 <flux> quickninja
02:04:48 <bastl> dreixel: it's just a finger exercise
02:04:50 <quicksilver> quickninja never sleeps
02:05:25 <bastl> we have developed a GTK-based AST viewer which is based on SYB and data2tree at the moment.
02:05:38 <maartenm> well, lazy IO seemed nice for asynchronous messaging (think AJAX)
02:05:41 <bastl> ill upload it to hackage next week
02:05:45 <maartenm> but there's better ways to implement that I guess
02:06:11 <fasta> I get module Prelude is deprecated. What is its replacement?
02:06:14 <dreixel> bastl: ah, ok, cool.
02:06:57 <fasta> It seems like a very questionable decision to make it deprecated without further context.
02:10:25 <yitz> anyone else (besides me) a US citizen residing abroad?
02:12:30 <ivanm> yitz: I doubt you'd be the only one
02:12:35 <ivanm> the only one here, maybe... ;-)
02:12:40 <yitz> heh
02:12:58 <yitz> haskellers tend to move around...
02:13:11 <hrgh> why are you in israel?
02:13:24 <ivanm> hrgh: because he wants to be there?
02:13:27 <fasta> He is a spy, obviously.
02:13:35 <yitz> hrgh: I live here with my family.
02:13:40 <ivanm> fasta: of course!
02:13:50 <ivanm> it all makes sense now!
02:13:50 <hrgh> ivanm: i had something more detailed in mind
02:13:56 <hrgh> yitz: ok
02:13:59 <fasta> ivanm, yes, I figured if nobody points out the obvious, I will do so.
02:14:05 <ivanm> yitz: you're behind the zionist world take-over plot, aren't you!
02:14:05 <ivanm> :p
02:14:06 <hrgh> unles you're religious, israel seems like a pretty crappy place to be..
02:14:13 <hrgh> *unless
02:14:29 <ivanm> hrgh: or you were born there and happen to call it home...
02:14:49 <hrgh> yeah, that adds some nostalgia, but meh..
02:15:00 <yitz> hrgh: it's actually a great place to live. just wish all the politicians and militants would shut up already though.
02:15:04 <bastl> dreixel: hmm. nothing to adapt. it works out of the box. the first _useful_ generic program i see :-)
02:15:15 * ivanm still calls australia home...
02:15:16 <ivanm> ;-)
02:15:25 <dreixel> bastl: so generic show and read are not useful?...
02:15:32 <hrgh> they should bomb all the holy sites. that'd make things interesting at least.
02:15:51 <ivanm> @slap hrgh
02:15:51 * lambdabot is overcome by a sudden desire to hurt hrgh
02:15:52 <bastl> well, i had no use case until now.
02:15:52 <yitz> hrgh: please, no thanks. that's all we need.
02:15:59 <ivanm> that's a pretty stupid thing to say...
02:16:56 <dreixel> bastl: when you do |deriving ...| in Haskell, you are efectively using some form of a generic program
02:17:14 <bastl> sure, but thats nothing i write myself.
02:17:39 <blackh> yitz: I will come and visit you one day.  I've been possessed with an irrational desire to learn Hebrew over the last few years and I need to come over and practise.
02:17:41 <bastl> dreixel: so you hData2Tree follows the same pattern as hmap? define it inductively for all base constructors ?
02:17:58 <hrgh> it would be pretty interesting to see the reactions though. i wonder if the remains would still be considered "holy" and continue to incite holy war..
02:18:01 <bastl> i thought on had to define hData2Tree in terms of hmap or similar ...
02:18:12 <yitz> blackh: great, let me know, we'd be happy to have you.
02:18:21 <bastl> on = one
02:18:21 <hrgh> not that that's the only excuse for the violence
02:18:52 <yitz> hrgh: since there is a certain likelyhood that those reactions would involve my death, I don't think it would be interesting to see them at all.
02:18:55 <bastl> and constructors is functors (sum, product, etc)
02:19:39 <dreixel> bastl: I wanted to define it as a fold, but I don't think I can, since constants (K) need to be added to the tree as well.
02:20:17 <dreixel> then again, it prob can be done in a similar way to generic show (in multireC)
02:20:25 <dreixel> by generating an algebra
02:20:34 <hrgh> yitz: i was thinking something along the lines of a third party destroying them, or them just spontaneously disintegrating or whatever..
02:20:38 <bastl> i have to study it. anyway a good example to learn how to _do_ GP ..
02:20:40 <dreixel> that formulation would probably also be more concise.
02:20:50 <yitz> hrgh: it wouldn't help
02:20:52 <bastl> thanks anyway
02:20:55 <hrgh> or in general, what difference it'd make if the holy sites went away, without either side being to blame
02:20:57 <dreixel> you're welcome
02:21:05 <hrgh> nah, i don't think so either
02:21:16 <maartenm> is there a way to experiment with do blocks in ghci?
02:21:18 <yitz> hrgh: the reality wouldn't matter, each would blame the other
02:21:29 <maartenm> each time i press newline it tries to execute
02:22:12 <maartenm> no "do putStrLn \ return "test"" like in say, bash?
02:22:53 <blackh> maartenm: Use curly brackets, e.g. do { h <- getLine ; .. etc .. }
02:23:29 <maartenm> ok, thanks
02:23:44 * hackagebot upload: timeplot 0.1.3 - A tool for visualizing time series from log files. (EugeneKirpichov)
02:24:22 <mlesniak> I have a (quite general) question about the design of function-call chains. See http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4913#a4913 I'd be very happy if someone could enlighten me :-)
02:24:45 * hackagebot upload: timeplot 0.1.4 - A tool for visualizing time series from log files. (EugeneKirpichov)
02:24:57 <yitz> maartenm: usually you don't even need the curly brackets, just do followed by statements separated by semi-colons on a single line.
02:25:14 <maartenm> ok, didn't try the semi-colon for some reason
02:25:35 <maartenm> it's syntactic sugar or an actual function?
02:25:39 <maartenm> hmm, sugar it seems
02:26:55 <fasta> Anyone who knows about this cabal install madness? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12070#a12070
02:27:18 <fasta> Basically it says that I need to add mtl to the build depends, but it is already there.
02:28:35 <yitz> mlesniak: one way to simplify would be to pass "f3 open back blocks nexts" to f2 instead of all the parameters
02:30:28 <blackh> mlesniak: aww... I was going to say that (pass "f3 ... " to f2) but I'll have to come up with another suggestion: define f2 and f3 in a let inside f1 and take the values from the scope.
02:30:53 <yitz> maartenm: yes, it's syntax.
02:31:21 <mlesniak> blackh: sounds good
02:31:33 <mlesniak> yitz: can you elaborate a bit?
02:32:23 <mlesniak> blackh: but if both f2 and f3 are quite "big" functions wouldn't it look a bit ... "ugly"?
02:32:42 <yitz> mlesniak: when you compute "f3 open back blocks nexts", it doesn't actually perform an action. It just returns an IO object which, when executed, performs an action. you can pass around IO objects just like anything other value in Haskell.
02:32:43 * mlesniak is not sure that he understands the suggestions correctly :)
02:32:43 <blackh> mlesniak: They would. That's why yitz's suggestion is better.
02:33:38 <mlesniak> Aaaaaaah
02:33:41 <mlesniak> Now I understand
02:33:47 <blackh> mlesniak: Pass partially evaluated functions around everywhere.  It's great fun!
02:33:51 <mlesniak> Yes, thats a good idea :)
02:34:19 <mlesniak> blackh: I curry so much I'm a part-time indian
02:34:43 <yitz> @quote curry
02:34:44 <lambdabot> sjanssen says: @djinn Haskell -> Curry
02:34:59 <yitz> @quote curry
02:35:00 <lambdabot> sjanssen says: @djinn Haskell -> Curry
02:35:24 <medfly> what's djinn?
02:35:25 <mlesniak> blackh: yitz: Thanks for your suggestions! Sometimes the solution is so obvious after someone helped you ;-)
02:44:06 <maartenm> I do    gen <- getStdGen
02:44:15 <maartenm> then I get some random numbers from it
02:44:23 <maartenm> and then I do gen <- getStdGen   again
02:44:26 <maartenm> I get teh same numbers
02:44:32 <maartenm> is that due to ghci
02:44:56 <yitz> maartenm: newStdGen
02:45:45 <maartenm> ok.. I should've continue reading the book
02:47:06 <maartenm> I can understand that the random numbers generator is implemented in such a way that it minimalizes the use of monads?
02:47:13 <yitz> maartenm: getStdGen is actually a bit ugly, it uses a horrible hack to store a global variable - something that Haskell is supposed to help you avoid.
02:47:17 <maartenm> by trying to do as much as possible of it purely?
02:47:37 <maartenm> and then there's a layer of ugliness around it in the form of these newStdGen and getStdGen
02:47:40 <yitz> maartenm: it was designed before monads in Haskell were understood
02:47:45 <maartenm> ah
02:47:58 <yitz> maartenm: you can use MonadRandom
02:47:58 <maartenm> it's very verbose
02:48:04 <maartenm> ok
02:48:32 <maartenm> LYAH should remove it from the book
02:48:37 <maartenm> it has no place in there
02:49:42 <yitz> tell BONUS
02:50:05 <maartenm> I will after reading the book, it's very good so far
02:50:23 <yitz> yes, i like it too.
02:51:20 <gio123> is there any english native speaker?
02:51:43 <blackh> gio123: Yes
02:51:55 <gio123> u?
02:52:03 <gio123> may I pm u?
02:52:18 <ehamberg> i know the answer! it is "you"!
02:52:33 <Jafet> µ?
02:59:15 <medfly> gio123, if you want to ask some English related question there's an #english channel :)
02:59:26 <maartenm> silly question, is there a way to edit ghci's prompt dynamically?
02:59:27 <mreh> @seen Cale
02:59:27 <lambdabot> Unknown command, try @list
02:59:33 <maartenm> it keeps showing a list of modules
02:59:37 <maartenm> it's annoying
03:00:00 <mreh> Does anyone feel like helping me with my Mathematica?
03:00:06 <fasta> Is there a pure Haskell regular expression library?
03:00:08 <mreh> I know this is completely the wrong place
03:00:34 <maartenm> I used mathematica in uni but probably can't help you
03:00:35 <mreh> fasta: I don't think you could make it pure
03:00:47 <mreh> unless you used monads
03:00:51 <fasta> mreh, what do you mean by that?
03:00:59 <fasta> mreggen, monads are still pure.
03:01:00 <luite> preflex: seen Cale
03:01:00 <preflex>  Cale was last seen on #haskell 3 hours, 22 minutes and 56 seconds ago, saying: > sequence [[1,2,3],[4,5],[6,7,8]]
03:01:37 <mreh> maartenm: thanks anyway
03:01:39 <fasta> mreh, well, pure is not well-defined.
03:01:59 <mreh> fasta: I know what you mean
03:02:15 <mreh> is  impure haskell is there?
03:02:16 <fasta> mreh, anyway by pure I meant 1) that it doesn't break Haskell 98 rules 2) that it just works 3) No C dependencies.
03:02:35 <MyCatVerbs> fasta: but Java dependencies are fine? ;)
03:02:55 <fasta> MyCatVerbs, well, if you implement foreing jvmcall bla bla bla, sure.
03:03:00 <fasta> foreign*
03:04:22 <quicksilver> fasta: afaik, regex-dfa and regex-parsec are both pure haskell in the sense of no C dependencies.
03:04:31 <quicksilver> fasta: they may well not be haskll 98
03:04:41 <yitz> maartenm: :set prompt
03:05:38 <maartenm> urgh, the shame
03:05:50 <maartenm> it stings
03:10:07 <yitz> maartenm: no worries :) you can do :set prompt "%s> " to get back the default behavior
03:18:04 <fasta> quicksilver, both of those packages don't build with even 6.10.4, because of ill-defined dependencies.
03:21:42 <watermind> hi guys
03:23:36 <Svrog> the agda channel is pretty quiet, i was wondering if someone here might have played with it a bit and could answer an agda related question
03:23:37 <blackh> Greetings!
03:23:43 <watermind> how can I tell the maximum number of chars available?
03:23:48 <Svrog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12073
03:24:01 <Svrog> is there a way to write this so it doesn't cause termination checking to fail?
03:24:16 <watermind> I want to do  c->succ(c) for every char
03:24:27 <watermind> but then the last one should become the 1st
03:24:41 <mreh> how much bandwidth is wasted by people bitching when you go offtopic in a dead channel?
03:24:46 <watermind> or more generaly I might want to do succ^k(c)
03:24:56 <watermind> mreh: not much
03:25:02 <watermind> mreh: it's just text
03:25:04 <poe> > drop 4 ([minBound..maxBound] :: [Char])
03:25:09 <lambdabot>   "\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ETB\CAN\EM\SU...
03:25:27 <watermind> ah minBound maxBound thanks poe
03:25:33 <poe> (4 being k)
03:26:11 <watermind> poe: sure the example was not relevant I was just looking for something like this maxBound
03:26:22 <mreh> I'm genuinely afraid to venture into other channels
03:26:42 <mreh> #haskell is so cozy
03:26:43 <watermind> poe: is class Bounded a haskell 98 thing?
03:27:27 <jelly12gen> are there any good docs about monads?
03:27:33 <quicksilver> yes, Bounded is in haskell98
03:27:45 <watermind> great
03:27:47 <quicksilver> jelly12gen: tehre is an entire cottage industry of monad tutorials.
03:27:54 <watermind> thanks
03:28:17 <quicksilver> jelly12gen: http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
03:28:28 <jelly12gen> quicksilver: ok thanks, watching a video about XMonad and that wants me to understand how monads work
03:28:47 <jelly12gen> actually almost every presentation about haskell wants me to learn more haskell
03:28:52 <koeien37> good :)
03:29:15 <jelly12gen> the documentation + hoogle is nice :)
03:29:52 <watermind> by the way
03:30:07 <jelly12gen> quicksilver: that link provides enough info :)
03:31:18 <watermind> I saw someone mention a trick to define Sets and Arrays and other types requiring Eq as Monads
03:31:39 <koeien37> on the -cafe
03:31:43 <watermind> does anybody know what trick that is?
03:32:00 <koeien37> iirc this was "wrapping it in the continuation monad"?
03:32:06 <watermind> koeien37: I just heard it on a talk on monads that was online
03:32:21 <koeien37> i can link you to the thread, hold on
03:32:24 <watermind> koeien37: http://www.vimeo.com/6590617
03:32:34 <watermind> koeien37: it's a video :)
03:32:59 <watermind> koeien37: the guy does really neat things with monad instances of arrays
03:33:33 <koeien37> watermind: http://www.haskell.org/pipermail/haskell-cafe/2009-November/068757.html
03:33:34 <quicksilver> watermind: http://comonad.com/reader/2007/parameterized-monads-in-haskell/ perhaps
03:33:57 <quicksilver> well, also the links in the first para
03:41:17 * hackagebot upload: shpider 0.0.7 - Web automation library in Haskell. (JohnnyMorrice)
03:42:00 <watermind> koeien37, quicksilver: all pretty interesting thanks
03:43:22 <watermind> is there actually a categorical notion of parameterized monad?
03:44:20 <watermind> I've never seen any papers using it
03:45:19 <watermind> but seems like an obvious generalization to persue... e.g. going from a usual lifting (Maybe) to one with multiple 'bottoms' (Either e)
03:47:54 <dmwit> watermind: It isn't needed in category theory because you can just switch which category you're using.
03:47:55 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
03:48:07 <dmwit> In Haskell, you're *always* using category Hask, so you need some hacks.
03:48:18 <dmwit> ?messages
03:48:19 <lambdabot> dschoepe said 1h 44m 6s ago: It seems I updated the wrong documentation: Could you copy the files in /srv/code/xmonad-extras/documentation/ to /srv/projects/xmonad-extras? (I can't due to the
03:48:19 <lambdabot> permissions of the files in that folder)
03:50:38 <maartenm> man, exceptions in Haskell sure take some getting used to
03:50:52 <maartenm> are they used a lot or is this still a draft version?
03:52:49 <koeien37> they changed in ghc 6.10.x vs 6.8.x
03:52:55 <dmwit> ?tell dschoepe I've moved in the documentation you asked for, and fixed the permissions (I think), but it still doesn't look right... it's got the 0.0 version number still.
03:52:56 <lambdabot> Consider it noted.
03:53:11 <int-e> I'd say they are used a lot, although the majority of the code is (should be?) pure.
03:53:59 <maartenm> well I was reading LYAH, they felt horrible to use.. but maybe 6.10 version is better
03:54:31 <fasta> maartenm, not more horrible than in any other language.
03:54:36 <maartenm> maybe the haskell community should've used syntax more like othe rlanguages do
03:54:51 <fasta> maartenm, oh, yeah, more syntax, what a GREAT idea.
03:54:56 <maartenm> :)
03:55:21 <int-e> uhm, they do?  foo `catch` \e -> somehow_handle e
03:55:53 <int-e> foo `finally` somethingorother.  bracket has no equivalent in other languages that I'm aware of.
03:55:54 <maartenm> yeah,w ell, catch is a function
03:56:02 <int-e> maartenm: so what?
03:56:05 <maartenm> which is beautiful in a way
03:56:20 <maartenm> but causes all sorts of verbose stuff that othe rlanguages have avoided with their throw/rescue/try/whatever clauses
03:56:23 <int-e> I still think it doesn't look much different from other languages, all things considered.
03:56:43 <fasta> I think we definitely need begin-syntax-really-exception and end-syntax-really-exception. Otherwise Haskell will just not reach critical mass.
03:56:44 <maartenm> the fact that you need boolean functions defined to determine what type an exception is, is absurd to me
03:56:48 <maartenm> but maybe I need illumination
03:57:11 <maartenm> fasta: no need to get cynical, I'm just expressing my first thoughts with them
03:57:35 <maartenm> maybe I'll change my mind, although to be fair I guess with haskell you have far less use of them
03:57:40 <int-e> fasta: oh, I smell code size explosion, bigger hard disks and ultimately a black hole consuming everything Haskell related. :)
03:57:51 <fasta> maartenm, well, read all the papers first and then you can put out your thoughts if you still believe they are relevant.
03:58:00 <maartenm> yeah, I'll read all the papers
03:58:06 <maartenm> that's what everyone shoudl do to form an opinion
03:58:37 <int-e> @src bracket
03:58:38 <lambdabot> bracket before after thing = block $ do
03:58:38 <lambdabot>     a <- before
03:58:38 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
03:58:38 <lambdabot>     after a
03:58:38 <lambdabot>     return r
03:59:00 <dmwit> So what is the "plus" by lambdabot in irssi mean?
03:59:24 <Jafet> "Improve your opinion, keep it to yourself!"
03:59:24 <luite> that it has a voiced status?
03:59:48 <int-e> ok, the block/unblock stuff is not very intuitive. ignoring that, it's a nice idiom built on top of the existing 'catch' primitive. try that in other languages.
03:59:53 <blackh> maartenm: The new extensible exceptions are much nicer.
04:00:08 <maartenm> I'm really only talking about the exceptions
04:00:17 <maartenm> catch/etc controls are beautiful
04:00:20 <maartenm> isDoesNotExistError e  is horrible
04:01:13 <blackh> maartenm: I agree.
04:01:19 <maartenm> it's something I see a lot in haskell, The Price of Beauty.. there's often a hidden secret in the basement
04:02:09 <fasta> maartenm, are you working on the next nethack?
04:02:20 <Jafet> Perhaps there should be an undo notation
04:02:35 <blackh> maartenm: Do you know about the trick of putting do ; code ; `catch` \exc -> do ; more code .... the trick being that `catch` is indented a little to the left of 'code' ?
04:02:48 <maartenm> I'm too european to know Nethack
04:03:01 <maartenm> blackh: no
04:03:41 <maartenm> I'm not scared of the code size, I just read the LYAH and probably know about 1% of the system, but the way exceptions are tested felt absurd
04:04:06 <blackh> maartenm: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=4914#a4914
04:04:07 <maartenm> in other languages (not necessarily OOP) you can easily use the hierarchies inherent in the exceptions
04:04:34 <maartenm> here you need some kind of encyclopedic knowledge of the IO module
04:04:40 <blackh> maartenm: I use exceptions a lot in Haskell, and I really like them.  I only use them in IO code, though.
04:05:32 <knobo> if I have a function f (x,y,z) = ... can I refer to the whole tuple argument without reconstructing it?
04:05:51 <blackh> knobo: f tuple@(x,y,z) = ....
04:05:58 <MyCatVerbs> knobo: f give_the_tuple_a_name@(x,y,z) = ... :)
04:06:03 <Beelsebob> > let f t@(x,y,z) = t in f (1,2,3)
04:06:04 <lambdabot>   (1,2,3)
04:06:14 <MyCatVerbs> name@(binding) is the general case to make an alias for a binding.
04:06:23 <knobo> how about lists? f list@x:xs ?
04:06:32 <MyCatVerbs> f list@(x:xs)
04:06:36 <koeien37> + parens
04:06:37 <koeien37> yes
04:06:39 <knobo> ok, great! :)
04:06:46 <MyCatVerbs> Needs to be outside of parens to avoid annoying the parser, but yes.
04:06:49 <Beelsebob> knobo: this works for all pattern matches
04:07:24 <Beelsebob> f bob@(MyDataStructure (x,y) t@(a:(b@(c:d))))
04:08:30 <fasta> Is there a way to use LGPL'ed Haskell code already in a closed source system?
04:08:36 <MyCatVerbs> > case (Just 5) of alias1@(alias2@(alias3@(Just x))) -> ("Of course we can nest these.",x,alias1,alias2,alias3)
04:08:37 <lambdabot>   ("Of course we can nest these.",5,Just 5,Just 5,Just 5)
04:09:18 <Beelsebob> fasta: write a bit of C that sets up the ghc runtime, runs the haskell, and tears it down, and then dynamic link with that
04:09:21 <Beelsebob> (ugly)
04:09:27 <Beelsebob> (but the only way I know how)
04:09:53 <fasta> Beelsebob, so, you have two Haskell run-time systems running then?
04:10:31 <Beelsebob> I’m not sure – I’ve never risked not starting it in the dynamically linked bit
04:10:33 <Beelsebob> it might work
04:10:41 <fasta> Beelsebob, I suppose just releasing all the object files is also possible.
04:11:45 <Beelsebob> personally I’d go with emailing the guy who used LGPL and say “hey, I’d like to use your code as a library, but the only thing I can do is static link it, can you relicense with a bit of an honour type thing, we contribute back library changes, but get to static link into our product”
04:12:21 <koeien37> that is not always possible if they accepted contributions
04:12:29 <Beelsebob> indeed
04:12:30 <fasta> Beelsebob, yes, I did that once for a GPL library (just a binding)  and they changed to MIT :)
04:12:32 <Beelsebob> but worth a try
04:12:48 <Eduard_Munteanu> Hi. Can anyone explain me how using Haskell as a theorem prover works? AFAIK, the compiler should bail out if my theorem is invalid.
04:12:54 <Svrog> i wonder how many haskell libraries released under lgpl were only released under it due to misconceptions and confusion regarding the license
04:12:59 <Eduard_Munteanu> But I seemingly can prove false theorems.
04:13:09 <int-e> @type fix
04:13:11 <lambdabot> forall a. (a -> a) -> a
04:13:14 <fasta> Svrog, probably all of them that don't have exception clauses.
04:13:16 <Beelsebob> o/ Svrog
04:13:22 <Beelsebob> and probably a decent number
04:13:27 <Svrog> hi Beelsebob :)
04:13:30 <luite> is there already some ghc 6.12 compatible cabal-install (darcs, inofficial patch?) available?
04:13:44 <quicksilver> luite: the darcs version, yes
04:13:56 <fasta> quicksilver, but it doesn't work.
04:14:08 <quicksilver> so I hear :)
04:14:11 <fasta> And I know because I wrote the patches.
04:14:15 <quicksilver> I also hear it works sometimes for some people.
04:14:18 <fasta> luite, yes, bug the network package author to apply my patches and it will.
04:14:19 <luite> oh
04:14:30 <fasta> luite, and on Linux it probably does work.
04:14:43 <luite> oh I use windows
04:14:50 <fasta> luite, my patches are for mingw.
04:15:41 <Eduard_Munteanu> Here is my code, adapted the from wiki: http://pastebin.com/d52e0a6a2
04:15:47 <fasta> luite, (which is how I build a working cabal install). Stil, you don't want to use 6.12.
04:15:50 <Eduard_Munteanu> testI is fine, testII is incomplete but it works.
04:15:55 <fasta> It's pretty incomplete, imho.
04:15:57 <Eduard_Munteanu> and it shouldn't.
04:16:31 <Eduard_Munteanu> Thoughts?
04:20:10 <quicksilver> Eduard_Munteanu: well it's a partial function
04:20:12 <luite> fasta: what is incomplete?
04:20:19 <quicksilver> Eduard_Munteanu: it throws an execption if you give it a Right.
04:20:32 <Eduard_Munteanu> quicksilver, how am I supposed to test proofs then?
04:20:38 <quicksilver> Eduard_Munteanu: partial functions do not correnspond to logical proofs - total functions do.
04:20:53 <Eduard_Munteanu> quicksilver, any way to show totality then?
04:20:53 <koeien37> otherwise you could prove a -> b -- undefined
04:21:44 <Eduard_Munteanu> Or, IOW, can ghc throw an error at compile time if functions are partial?
04:21:47 <quicksilver> there are some ghc flags to warn on incomplete pattern matches
04:22:04 <Eduard_Munteanu> quicksilver, does it warn me "provably"?
04:22:08 <quicksilver> of course not
04:22:09 <Eduard_Munteanu> :)
04:22:13 <koeien37> no, that would be the halting problem? :)
04:22:15 <quicksilver> GHC is a huge piece of software full of bugs
04:22:19 <quicksilver> it's not a theorem prover
04:22:19 <Eduard_Munteanu> koeien37, I see.
04:22:48 <quicksilver> it seems unlikely there are undiscovered bugs in the basic type inference which corresponds to simple propositions
04:22:58 <quicksilver> what is your tolerance for probable proof? ;)
04:23:35 <Eduard_Munteanu> quicksilver, GHC could be wrong by a coding mistake on the developer part, but if the theory behind it is sound I'm okay.
04:23:35 <dmwit> you guys
04:23:52 <dmwit> There is so a warning in GHC for incomplete pattern matches.
04:24:06 <Eduard_Munteanu> IOW, is theorem proving possible in non-total functional languages?
04:24:13 <dmwit> Unless you're using GADTs, that can catch *every* incomplete pattern match (up to, as quicksilver says, bugs in the implementation).
04:24:14 <quicksilver> dmwit: that's what I said.
04:24:25 <Eduard_Munteanu> dmwit, thanks.
04:25:52 <Eduard_Munteanu> So basically, if I got it right, w/o GADTs and with total functions, Haskell will always bail out on false proofs? I'm kinda new to this.
04:26:15 <dmwit> Eduard_Munteanu: Sadly, still no.
04:26:23 <dmwit> There's "undefined", which proves anything.
04:26:31 <dmwit> ?quote Cale inconsistent
04:26:32 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
04:26:50 <yoshi765> fuck freenode
04:27:01 <yoshi765> damn freenode
04:27:05 <Eduard_Munteanu> Crap... what's so hard in making Haskell optionally total? I hear dependent types is all that's required.
04:27:11 <yoshi765> freenode sucks
04:27:12 <Eduard_Munteanu> dmwit, is this correct?
04:27:18 <quicksilver> yoshi765: hush
04:27:25 <quicksilver> Eduard_Munteanu: the answer is in the question
04:27:25 <yoshi765> damn this channel
04:27:28 --- mode: ChanServ set +o quicksilver
04:27:30 <yoshi765> ASS
04:27:31 --- mode: quicksilver set +b *!*n=nds@*.dsl.scrm01.sbcglobal.net
04:27:31 --- kick: yoshi765 was kicked by quicksilver (fuck you)
04:27:40 --- mode: quicksilver set -o quicksilver
04:27:52 <quicksilver> Eduard_Munteanu: "dependent types" is an unsolved problem in many ways.
04:28:30 <dmwit> Eduard_Munteanu: Total languages are not Turing complete!
04:28:36 <Eduard_Munteanu> quicksilver, hm, I hear Agda / Coq (don't remember which) are doing fine.
04:28:49 <dmwit> Eduard_Munteanu: That's a fine trade-off to make, it just wasn't one of the tradeoffs chosen for Haskell (or most other languages).
04:29:03 <Eduard_Munteanu> dmwit, yeah, that's not a problem. Basically you could shout "Haskell is pure!", but you can use monads. Then codata makes up for totality.
04:29:03 <quicksilver> Eduard_Munteanu: they're doing fine, but they don't actually work.
04:29:21 <quicksilver> Eduard_Munteanu: they are fascinating research projects, but nobody writes code in them.
04:29:35 <quicksilver> the represent a forefront of a certain kind of progress, which is very interesting.
04:29:37 * Eduard_Munteanu grrr....
04:29:42 <Eduard_Munteanu> Haskell started like that :P
04:29:49 <quicksilver> well I wouldn't say that
04:29:57 <quicksilver> haskell has always been a bit more practical
04:30:12 <quicksilver> writing programs which do stuff (as opposed to proving theorems) has alwas been the agenda
04:30:37 <quicksilver> Coq is, first-and-foremost, a theorem proving toolkit / logical exploration tool
04:30:45 <quicksilver> haskell is first-and-foremost a language to write programs in
04:30:56 <medfly> mathematicians are taking over my programming!
04:31:07 <quicksilver> agda has, as I understand it, more practical goals but it is far from practical in execution thus far
04:31:08 <Eduard_Munteanu> quicksilver, sorry if I'm mistaken, but total languages + co-X (where X is data, induction etc.) are Turing-complete.
04:31:37 <Eduard_Munteanu> So in a sense, they only isolate, much like Haskell does with monads and purity.
04:32:05 <dmwit> No, the halting problem shows that any Turing-complete language is necessarily non-total.
04:32:40 <Eduard_Munteanu> dmwit, yes, but the point is you can write total code. Then you can add non-total parts. Sure, on the whole it's non-total.
04:32:40 <quicksilver> Eduard_Munteanu: it is hypothesis that total + codata is an interesting programming model (see Turner)
04:32:51 <Eduard_Munteanu> quicksilver, that's what I read in fact :)
04:32:53 <quicksilver> but it's not proven its practicality yet.
04:34:14 <Eduard_Munteanu> IMHO, totality is good in that you can do unit testing that, up to non-total interaction, provably halts.
04:35:15 <Eduard_Munteanu> Anyway, thanks for the pointers.
04:35:47 <Eduard_Munteanu> BTW, Agda is the one closer to Haskell syntax-wise, right? I'm unsure what to try for theorem proving.
04:35:55 <Svrog> has anyone played with agda?
04:35:56 <quicksilver> sure, but provably halts != feasibly halts
04:36:12 <Eduard_Munteanu> quicksilver, that's also true unfortunately.
04:36:25 <quicksilver> plenty of things have finite input but demonstrably exponential or double exponential input spaces
04:36:29 <Eduard_Munteanu> Svrog, I was going to, but I need to get my Gentoo to build it :)
04:36:40 <quicksilver> exhaustively proving all cases isn't going to work for quite a large class of problems :)
04:36:45 <Svrog> i'm playing with it right now and i'm stuck which is why i'm asking :P
04:36:48 <Svrog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12073
04:37:26 <Svrog> "Termination checking failed for the following functions: sequence."
04:37:27 <Eduard_Munteanu> WTF, is this APL?! Only that one used non-printable, non-keyboard symbols.
04:37:31 <Eduard_Munteanu> :)
04:37:34 <Svrog> that is agda
04:38:07 <Eduard_Munteanu> Looks Haskellish to me though, lemme emerge it again.
04:38:13 <mmorrow> Eduard_Munteanu: here's an algo for termination checking, also it proves a lower bound wrt complexity http://portal.acm.org/citation.cfm?id=360204.360210&coll=GUIDE&dl=GUIDE&CFID=62520405&CFTOKEN=87492642
04:38:23 <mmorrow> it's PSPACE complete apparently
04:38:45 <Svrog> also can't figure out how to map Int-s from haskell to an agda data type
04:39:08 <Svrog> i found some examples that no longer work - no mention of it anywhere else
04:40:55 <Eduard_Munteanu> mmorrow, thanks, will take a look at it.
04:40:59 <mmorrow> so from what i grok from briefly consulting the googlemachine, that means that any NP-complete problem can be reduced to it, ie PSPACE properly contains NP
04:42:31 <mmorrow> Eduard_Munteanu: but anyways, yeah i actually found that paper a few hours ago coming from a different direction, but it's interesting
04:42:32 <Eduard_Munteanu> mmorrow, hm, termination isn't a strict thing, as false positives (falsely reported as non-terminating) aren't too much of an issue. You'd only need to prove it better to the compiler, as far as I've heard.
04:42:56 <Eduard_Munteanu> That is, in total languages.
04:43:05 <mmorrow> Eduard_Munteanu: screw that, prove it with a number two pencil and sticky notes!
04:43:09 <mmorrow> :)
04:43:13 <Eduard_Munteanu> Heh :)
04:44:15 <mmorrow> but really though, if you wanted to use such a thing with a for-programming programming language, you'd need to automate that quite a bit. e.g., register allocation is nice an automated
04:44:31 <mmorrow> that would suck to have to do manually for every program, because the compiler couldn't figure it out
04:44:38 <luite> what's a number two pencil in european units?
04:44:44 <mmorrow> (graph coloring is NP-hard in the general case)
04:44:52 <mmorrow> luite: i think 90 furlongs
04:44:56 <ivanm> you have pencil units? :o
04:45:14 <luite> don't know, but I have never heard of 'number two'
04:45:18 <Eduard_Munteanu> mmorrow, hm, but linear allocators do almost as well. They're used in JITing code.
04:45:34 <luite> if it describes the hardness, I guess we have things like 2B, B, HB, H etc
04:45:49 <mmorrow> Eduard_Munteanu: right, because they're fast, but at the cost of quality of the generated code
04:45:58 <ivanm> luite: oh, right
04:46:11 <ivanm> luite: those kinds of pencils I know of; "number two" I don't
04:46:14 <mmorrow> but if you're jitting, anything costlier than a certain amount is unacceptable
04:46:31 <Eduard_Munteanu> mmorrow, yeah, but it's pretty good AFAIK.
04:46:32 <mmorrow> despite the cost wrt code-quality
04:46:39 <Svrog> http://en.wikipedia.org/wiki/Number_2_pencil#Grading_and_classification
04:47:05 <mmorrow> Eduard_Munteanu: i'm not saying it's bad :)
04:47:35 <mmorrow> Eduard_Munteanu: but i am saying that the code isn't as good as a better algorithm would produce
04:47:52 <ivanm> OK, number two pencil == HB (i.e. "normal" pencil)
04:47:57 <Eduard_Munteanu> mmorrow, of course. Graph coloring is optimal IIRC.
04:48:00 <ivanm> silly yanks...
04:48:51 <mmorrow> Eduard_Munteanu: ah, i think so yeah (in the ideal case)
04:49:13 <mmorrow> Eduard_Munteanu: but it's not a polynomial algorithm without heuristics
04:50:01 <Eduard_Munteanu> mmorrow, hm, I see, so a full solution space search eventually gets the best solution.
04:50:04 * mmorrow is holding out for them quantum puters
04:50:28 <Eduard_Munteanu> mmorrow, yeah, backtracking in linear time :)
04:50:40 <mmorrow> Eduard_Munteanu: from what i understand, it would yeah
04:50:51 <Eduard_Munteanu> Quantum computing is awesome. Except for the part where it's probabilistic :(
04:51:03 <Eduard_Munteanu> as in "I may screw up".
04:51:05 <mmorrow> and the whole vaporware aspect too..
04:51:08 <mmorrow> :)
04:51:10 <Eduard_Munteanu> Yeah.
04:51:17 <koeien37> Eduard_Munteanu: why is that a problem?
04:51:48 <Eduard_Munteanu> koeien37, it is a problem when checking a solution is hard as well. Otherwise it isn't.
04:51:53 <MacCoaster> the state monad tutorials are usually confusing... can anyone point me out to a good general guide, because i need to keep state of a list and modify their contents as i traverse a graph
04:52:24 <koeien37> Eduard_Munteanu: well, if it is not even in NP... are there problems that can be efficiently solved by qc's, that are not in NP?
04:53:40 <Eduard_Munteanu> koeien37, I'm not too great in theoretical CS, but I'm not sure how a bigger-than-NP problem would look.
04:53:55 <Eduard_Munteanu> koeien37, basically QC can solve any non-deterministic problem deterministically.
04:54:10 <koeien37> QC is nondeterministic
04:54:25 <koeien37> sometimes you have algorithms that "with probability 1" give a certain answer
04:55:03 <Eduard_Munteanu> koeien37, in the CS sense, it means that when backtracking a tree it does not need to make decisions on where to branch. It can "take all branches".
04:55:09 <Eduard_Munteanu> Or so is my understanding.
04:55:53 <Eduard_Munteanu> Some sort of probabilistic oracle machine.
04:56:07 <koeien37> that would mean that BQP contains NPC , right?
04:56:24 <Eduard_Munteanu> koeien37, dunno about BQP.
04:56:53 <Eduard_Munteanu> But it means it can solve NP-complete problems quite fast :)
04:57:11 <koeien37> i am not aware of any problem in NPC that is in BQP
04:57:38 <koeien37> "the class of all decision problems solvable with a quantum computer, allowing for a bounded error probability"
04:57:44 <cathper> When I have a compare function, how do I get the "inverse" (to use in sortBy)?
04:58:37 <luite> > sortBy (flip compare) [1..10]
04:58:38 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
04:58:51 <koeien37> Eduard_Munteanu: although there are some problems, such as integer factorization, that are in BQP which are not known to be in P
04:59:22 <cathper> Garh, flip. Of course. Thanks luite :-)
04:59:23 <Eduard_Munteanu> koeien37, yeah, that's why there's all that fuss that QC will make RSA/DSA piece of cake.
04:59:40 <koeien37> Eduard_Munteanu: yeah, DH too by the way
05:00:03 <koeien37> or ElGamal
05:00:18 <Eduard_Munteanu> koeien37, ElGamal?
05:00:30 <koeien37> Eduard_Munteanu: a cryptosystem based on the discrete logarithm problem
05:00:34 <Eduard_Munteanu> Hm, I was under the impression that was for encrypting the master key itself.
05:00:38 <Eduard_Munteanu> Oh.
05:01:15 <koeien37> so, we should use mceliece from now on ;)
05:01:29 <Eduard_Munteanu> koeien37, hm? Lemme look that up...
05:02:12 <Eduard_Munteanu> koeien37, nice, thanks.
05:02:36 <koeien37> i've heard that this is not known to be broken by QC
05:03:21 <fasta> We should just figure out how our universe was created if it is not a virtual one and then make our own with different constants to do faster computation.
05:03:26 <maartenm> maybe it will be broken by maths though
05:03:40 <fasta> Now, *that* is vaporware.
05:03:50 <Eduard_Munteanu> koeien37, Wikipedia seems to confirm that it's not vulnerable to Shor's algorithm.
05:03:55 <koeien37> maartenm: yep, sure. it has also gotten less attention than RSA, for example
05:04:13 <koeien37> Eduard_Munteanu: that may be true, but that is not the only quantum algorithm in existence ;)
05:04:33 <mmorrow> MacCoaster: here's a graph bfs that uses an IntSet for seen nodes, and a Data.Sequence for the queue (explicitly passes these). the State monad equiv would be pretty straightforward from those two params it's propagating  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4899#a4900
05:04:34 <Eduard_Munteanu> fasta, yeah, it seems like Planck's length is the discretization step. We're in Matrix.
05:04:43 <fasta> I find it interesting that Kirkhoff principle only applies to consumer applications.
05:04:46 <Eduard_Munteanu> koeien37, possibly.
05:04:56 <fasta> Even though, it was discovered in a military context.
05:06:02 <koeien37> Eduard_Munteanu: there is no proof that it is in NPC, too, so it may even be easy on classical computers even if P != NP (same holds for RSA)
05:06:12 <maartenm> btw, koeien37
05:06:13 <mmorrow> like,  data Env = Env {seen::IntSet, todo::Seq IntSet, bfn::IntMap Int}; type M a = State Env a; bfs :: (Int -> IntSet) -> M (); bfs g = do ..
05:06:18 <maartenm> the wikipedia article says "for both problems efficient algorithms on quantum computers are known,"
05:06:20 <mmorrow> MacCoaster:
05:06:22 <maartenm> no source
05:06:34 <koeien37> maartenm: which problems?
05:06:42 <fasta> koeien37, uhm, both are not in NPC.
05:06:47 <Eduard_Munteanu> maartenm, koeien37, Wikipedia says there are some vulnerabilities, but they can be improved upon.
05:06:50 <maartenm> elgamal and integer factorization
05:07:01 <fasta> koeien37, unless of course P=NP.
05:07:03 <mmorrow> err, and a root node
05:07:16 <koeien37> maartenm: integer factorization and discrete logarithm are in BQP
05:07:31 <koeien37> fasta: yes, sure
05:07:36 <maartenm> ah, because you said "<koeien37> i've heard that this is not known to be broken by QC"
05:07:47 <koeien37> maartenm: yeah, the McEliece cryptosystem
05:07:53 <maartenm> oh, sorry
05:07:56 <bastl> dreixel: your data2Tree does not descent to Lists e.g. data Expr = List [Expr]. Is that a shortcoming of multirec or could this be fixed ?
05:08:08 <fasta> I still want someone to come with a good debunking of the Merlin paper.
05:08:11 <maartenm> it caught my interest because I studied the discrete logarithms and foudn it odd that QC couldn't break it
05:08:14 <maartenm> nevermind
05:08:50 <MacCoaster> mmorrow: ya i saw that yesterday, you showed that to me, but i think i wrote a bfs without state, so i have a [Vertex] traversed in BFS order, now im trying to use that list to implement bipartite testing by going through that list and getting the neighbors then marking its entry in a list (stateful) so i can figure out if the neighbors have the same "color" as the vertex being visited thus rejecting bipartitness
05:10:11 <MacCoaster> mmorrow: so i might need something like State Int [Vertex] ?
05:11:31 <MacCoaster> mmorrow:  erm no, more like State Int [Int]   that makes it [Int] -> (Int, [Int])   where the [Int] would be something like [0,-1,-1,-1,-1,-1] for vertices 1 .. 6 for example
05:12:55 <MacCoaster> and i change it every time i loop through the BFS list, visting the neighbors figuring out if [0,-1,-1..] !! currentVertex == [0,-1,-1...] !! oneOfCurrentVertexsNeighbor
05:13:02 <MacCoaster> mmorrow: im not sure if im explaining it clearly?
05:16:02 <dreixel> bastl: in case it's lists of an element of the family, then the current version of multirec cannot express it, I'm afraid
05:16:23 <dreixel> so your case Expr = List [Expr] is a pathological one. That might be a problem for ASTs in general, of course...
05:16:40 <dankna> hm
05:16:47 <dankna> can't make a Dynamic out of a polymorphic function :(
05:17:11 <dankna> trying to come up with a workaround...  lot of context to explain about what I'm doing and why, so I'm not really asking for help
05:19:16 <dankna> I mean, I get why you can't, but it's annoying :)
05:19:46 <dankna> defining an instance of Typeable for my class that I'm polymorphic on might possibly work, except I can't do that because the instances of it are already Typeable and there would be a conflict
05:21:47 * hackagebot upload: hint 0.3.2.1 - Runtime Haskell interpreter (GHC API wrapper) (DanielGorin)
05:21:49 * hackagebot upload: wxdirect 0.12.1.1 - helper tool for building wxHaskell (JeremyODonoghue)
05:22:14 <mmorrow> MacCoaster: ah cool
05:22:35 <SamB_XP_> hmm, apparantly usenet is peer-to-peer, fairly anonymized, and based on public-key-cryptography in the future
05:23:02 <MacCoaster> mmorrow: i think, i havent tested it exhaustively :) but yeah i just need a state for a list :\
05:24:57 <zygoloid> SamB_XP_: if i were sending myself information from the future, that's not what i'd send :)
05:25:03 <fasta> Eduard_Munteanu, "Contrary to statements sometimes found in the popular press, there is no evidence to suggest that distances in space are quantized in units of the Planck length. "
05:25:51 <fasta> SamB_XP_, how do you mean future? It already is SSL for commercial providers and in Freenet it already is.
05:25:51 <MoALTz> ??
05:26:01 <Xilon> Hi. I'm wondeing about C++ and Haskell interoperability. As far as I know Haskell needs to be run first to initialize GC and other stuff. C++ also needs to be run first to initialize some things. Is it possible to write a C++ program that uses Haskell code or vice versa? The wiki seems to suggest so, but it mainly focuses on pure C.
05:26:09 <SamB_XP_> fasta: well, yeah, I was talking about the latter
05:26:34 <fasta> Xilon, you export the C++ stuff to C, and then call the C stuff.
05:26:47 <SamB_XP_> I also keep for getting that the PKI is technically based on public-key cryptography ;-P
05:27:04 <dankna> I'd think there would be trouble with getting class variables initialized and the like, though.
05:27:07 <fasta> Xilon, you can also call the C++ stuff directly, but then you depend on mangled symbols.
05:27:27 <fasta> Xilon, so, one compiler change and your library is destroyed.
05:28:11 <luite> loading a C++ library into ghci causes problems though (even if you call it through a C wrapper), because of those global static initializers and destructors
05:29:36 <dankna> one workaround I've seen (not with C++ though) is to know what name the library-startup code has and call it directly
05:29:37 <fasta> Foreign language interoperability is just not as good as it could be, but that goes for a lot of things.
05:29:55 <dankna> very very fragile approach, of course
05:30:23 <SamB_XP_> one thing I'm a bit worried about is whether I should really be fetching the messages for fr.pedophilie or not -- apparently if you skip certain groups, it can make it easier to figure out who you are ?
05:30:35 <zygoloid> i think the FFI provides an interface for initializing the haskell RTS from C code; you could call haskell from C++ that way i think
05:30:36 <Xilon> Yeah, I'm not even too keen on using C++, but I want to try making a game, but use C++ for rendering and such (I'd use C at least, but most engines are in C++)
05:31:21 <dankna> SamB: since it's not legal to retrieve those in many jurisdictions, you probably want to skip them, regardless of the anonymity concern
05:31:28 <Xilon> zygoloid: Any documentation on that?
05:32:11 <Xilon> If it's a lot of trouble I might just go with Lua instead of Haskell, though I was hoping for Haskell :(
05:32:29 <MoALTz> i've wondered before whether ffi between languages is a case of "worse is better". say you have a language A and a language B, and your source base has code in both that call functions/read values/etc in the other. all other things being ~equal, if it's really easy to call language B stuff from language A, but a huge pain-in-the-arse to call language A stuff from language B, then you'd be tempted to develop primarily in language A...
05:32:34 <SamB_XP_> dankna: yeah, I guess you're right
05:32:55 <mmorrow> MacCoaster: something like this i'd do http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4915#a4915
05:32:59 <mreh> does anyone want to talk Mathematica again?
05:33:04 <mmorrow> MacCoaster: in terms of the general pattern
05:33:24 <mmorrow> MacCoaster: whether that exactly, i'm not sure for what you're doing
05:33:31 <SamB_XP_> dankna: which leaves me wondering how to have FMS instaban anything of that sort ...
05:33:37 <Eduard_Munteanu> fasta, that's what the uncertainty principle states in some way or another.
05:33:52 <dankna> SamB: yeah, hm, indeed.  not sure.
05:34:08 <mreh> @Seen Cale
05:34:08 <lambdabot> Unknown command, try @list
05:34:11 <mreh> @seen Cale
05:34:12 <lambdabot> Unknown command, try @list
05:34:14 <mmorrow> MacCoaster: but just extending/generalizing that Env type, and for each field you add to Env, have a getter/modifier monadic function for that piece of data
05:34:23 <luite> preflex: seen Calse
05:34:23 <preflex>  Sorry, I haven't seen Calse
05:34:25 <luite> preflex: seen Cale
05:34:25 <preflex>  Cale was last seen on #haskell 5 hours, 56 minutes and 21 seconds ago, saying: > sequence [[1,2,3],[4,5],[6,7,8]]
05:34:27 <SamB_XP_> perhaps by subscribing to some kind of shared blacklist ...?
05:34:27 <mmorrow> MacCoaster: that does whatever needs to be done commonly to that
05:34:40 <dankna> that would make sense, if there is such a thing
05:34:44 <luite> mreh: @seen was disabled in lambdabot because of leaking too much memory
05:35:08 <SamB_XP_> I'm just trying to think of how it ought to work, especially in order to best preserve anonymity
05:35:08 <mreh> luite: okay
05:35:17 <mmorrow> MacCoaster: that's if you really feel like you want a monad
05:35:20 <Eduard_Munteanu> LOL, "saying: > sequence [[1,2,3],[4,5],[6,7,8]]"
05:35:33 <mmorrow> MacCoaster: it's kind of a decision, because it'll change how you write all your code
05:36:06 <SamB_XP_> 'cause I figure if a bunch of people subscribed to a single blacklist, that'd compromise their anonymity far less than if they each opt out manually as they notice things
05:36:32 <dankna> right, logical enough
05:36:51 <MacCoaster> mmorrow: ok, slow down if you dont mind... whats the actual state and wheres the data?
05:37:20 <mmorrow> MacCoaster: with graphs it's pretty much foo g stuff = go mempty .. mempty where go = ... go ... foldl' (foldl' .. go)), or everything's in a "do" block and no explicit mention is made of the state, since you're implicitly modifying it with your monadic state manipulators
05:37:36 <mmorrow> being what would change
05:37:56 <zygoloid> Xilon: there's something here, but there's better documentation somewhere (still looking): http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
05:37:59 <Xilon> MoALTz: I'd be mostly using Haskell really, and only sending "messages", or "events" to the C++ side for rendering and other logic. It should be a fairly clean design once it's set up, and would allow me to use haskell for all the game logic, essentially like a scripting language.
05:38:08 <mmorrow> MacCoaster: the data's all stored in the Node type
05:38:14 <mmorrow> MacCoaster: in `embed'
05:38:27 <zygoloid> Xilon: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html <-- that's what i was looking for
05:38:30 <MacCoaster> so thats what you use for seen ?
05:38:38 <mmorrow> then that Env type is just a quicky off-the-cuff copy specialized for a bfs function
05:38:47 <pao> I'm not finding cairo and gtk on hackage... what's happening with those packages?
05:38:47 <zygoloid> Xilon: particularly the 'Using your own main()' section
05:38:57 <mmorrow> MacCoaster: ah right, so `seen' is kept in the Env type
05:38:58 <ivanm> pao: they're part of gtk2hs
05:39:04 <ivanm> which is as yet not cabalised, so they're not on hackage
05:39:08 <ivanm> @where gtk2hs
05:39:08 <lambdabot> http://haskell.org/gtk2hs/
05:39:10 <mmorrow> MacCoaster: and Env is the top-level state container
05:39:11 <ivanm> pao: ^^
05:39:24 <pao> ivanm: thanks
05:39:34 <ivanm> no worries
05:39:50 <Xilon> zygoloid: That looks quite simple. Thanks!
05:40:03 <MacCoaster> so you're saying you make Node (Env b) then seen will be stored in node using embed, mmorrow ?
05:40:15 <mmorrow> MacCoaster: so, an Env of (1) a graph of (nodes of {(a) stuff, (b) succs}), (2) a seen set, (3) a queue
05:40:29 <mmorrow> MacCoaster: right
05:40:52 <mmorrow> MacCoaster: and if you wanted to attach data to edges, you could either
05:41:11 <mmorrow> (if you'll be accessing it from nodes) /in/ the Node type, or
05:41:35 <mmorrow> (if you want to access it from outside of the graph) in the Env type
05:41:43 <mmorrow> oh,
05:41:49 <Xilon> zygoloid: Know of any problems regarding that? That web page doesn't seem to indicate of any, which is good.
05:41:51 <mmorrow> like, NodeMap e
05:42:19 <mmorrow> data Env e v = Env {graph :: G e v, ...}
05:42:30 <mmorrow> G = NodeMap (Node v e)
05:42:33 <mmorrow> err
05:42:34 <mmorrow> e v
05:44:18 <MacCoaster> mmorrow: sorry, still trying to parse all this, a bit much for me :)
05:44:55 <mmorrow> err, a (NodeMap (Set edge)) or something
05:44:59 <mmorrow> rather
05:45:32 <mmorrow> MacCoaster: so essentially it's just using (Map a b) and (Set c), and then building structures with those two primitives
05:45:42 <mmorrow> (or IntMap/IntSet)
05:45:52 <mmorrow> and maybe a Tree or Seq here or there
05:46:20 <mmorrow> if you have some complex state that's being kept, probably use a monad
05:46:49 <pao> @hpaste
05:46:50 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:47:00 <mmorrow> but if the state's more just a Map/Set/Tree/Seq construction in a newtype or something, maybe just pass it along
05:47:33 <pao> hmmm... somehow gtk2hs configure script doesn't find gtk ... http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4916#a4916
05:47:38 <mmorrow> the fold functions over the Maps are super useful for building a new Map of .. as you fold over another one
05:48:14 <Saizan> pao: do you have gtk's -dev package (or your distro equivalent) installed?
05:48:41 <pao> Saizan: I've installed gtk via mac ports... include files are always installed
05:49:47 <mreh> does anyone know how I can plot graphics in Mathematica by sending the plot to some kind of standard output, rather than returning it as the value of an expression
05:50:05 <MacCoaster> mmorrow: you mean as in passing a list around as an argument?
05:50:10 <MacCoaster> recursively that is
05:50:23 <MacCoaster> and just modify it before passing it?
06:03:55 <dankna> okay, so why is my instance (Bindable a) => Bindable [a] matching on String when I don't have an instance Bindable Char?
06:04:06 <dankna> it's causing a conflict, because I do have a separate instance Bindable String...
06:04:37 <sior|oifig_> I tried using the cabal install for System.Vacuum.Cairo, but I can't import the module in a .hs file nor load it in ghci
06:04:43 <sior|oifig_> Is there an issue I should know about?
06:05:41 <MyCatVerbs> dankna: It's because Haskell interfaces are searched based on what's on the right hand side of the => only.
06:05:47 <dankna> hmm
06:05:55 <dankna> that makes sense, but what can I do about it :(
06:06:25 <dankna> well, I appreciate the information
06:06:42 <MyCatVerbs> Haskell sees that it has a way to search for Bindable [a]. The type variable a gets unified with Char, and it succeeds. Hence it then looks for an instance (Bindable Char). Since there isn't one, that search fails and so the whole search fails and you get a type error.
06:06:57 <MyCatVerbs> (Er, since String is actually [a], but you already knew that.)
06:07:00 <dankna> right
06:07:08 <MyCatVerbs> (Er, [Char], but you knew that too. ^~)
06:07:11 <dankna> haha
06:07:20 <MyCatVerbs> So the traditional approach is to use a newtype wrapper.
06:07:21 <Saizan> there's OverlappingInstances that would make it work for your case, but it's a bit controversial as an extension
06:07:26 <dankna> oh, a newtype wrapper, hmm
06:07:31 <dankna> that would make sense
06:07:55 <MyCatVerbs> The H98 way is: newtype Bindystring = Bindystring String; instance (Bindable Bindystring) where ...
06:08:00 <dankna> haha
06:08:03 <dankna> Bindystring
06:08:08 <MyCatVerbs> OverlappingInstances may be more convenient.
06:08:23 <MyCatVerbs> Personally, I would recommend against using String in the first place.
06:08:27 <dankna> oh?
06:08:49 <dankna> you mean, not use it by using a newtype instead, or some third approach?
06:09:10 <MyCatVerbs> A third approach - use different data types.
06:09:12 <MyCatVerbs> Use Data.Text instead for printable text - that is, anything which you ought to know the character encoding for.
06:09:17 <dankna> hm
06:09:23 <dankna> that's a point
06:09:30 <MyCatVerbs> Use Data.ByteString instead for byte data which isn't necessarily printable.
06:09:52 <MyCatVerbs> IMHO it is a vast improvement to have a clear seperation between the two.
06:09:54 <dankna> I'll chew on that.  It's printable (UTF8, in fact), but I'd have to rework most of my program to do that.  Wish I'd known about it before.
06:10:17 <dankna> You're right of course that it's good to separate them.
06:10:36 <MyCatVerbs> Data.Text is backed by efficient UTF-16 variables, and handles conversion to/from other character encodings The Right Way.
06:10:57 * dankna nods
06:11:23 <dankna> Data.Text is a Hackage package?  Which one?
06:11:27 <MyCatVerbs> Data.ByteString gives plain byte arrays.
06:11:37 <MyCatVerbs> Uh, can't remember. It is on Hackage, though.
06:11:41 <dankna> ah, found it
06:11:42 <dankna> http://hackage.haskell.org/package/text
06:11:47 <dankna> sorry, should have searched before asking :)
06:11:55 <MyCatVerbs> Thank you for saving me the trouble of looking up Hackage's URL. ;)
06:11:58 <dankna> yeah, I use ByteString where it's appopriate already
06:12:07 <dankna> I'm a big fan of it
06:12:38 <MyCatVerbs> Sticking to Data.Text and Data.ByteString will usually make your program(s) more efficient, since [Char] is such a pig.
06:12:42 * dankna nods
06:12:45 <dankna> logical
06:13:00 <MyCatVerbs> Which isn't usually the most important thing in the end, but it's a nice bonus. ^_^
06:13:04 <fasta> Ah, a cabal bug, how nice: cabal.exe: Distribution\Client\Dependency\TopDown.hs:169:37-73: Non-exhaustive patterns in lambda
06:13:17 <dankna> fasta: report it
06:13:27 <sior|oifig_> MyCatVerbs although appends are usually less than happy in those languages
06:13:34 <dankna> yeah, it's certainly nice when that happens
06:13:34 <sior|oifig_> *libraries
06:19:42 <MyCatVerbs> sior|oifig_: appends? (++) on [a] also costs O(length of left string).
06:22:26 <Jafet> Appending should really be more or less constant time
06:22:42 <Jafet> As with prepending, joining, splicing...
06:23:52 <desp> Is it possible to give a default value to a record field?
06:24:01 <desp> The obvious syntax didn't work.
06:24:13 <Zao> Omit it?
06:24:26 <Zao> Depending on what syntax you use, that is.
06:24:34 <desp> Zao: how do I define the default value?
06:24:43 <Zao> Oh, you're thinking like that.
06:25:07 <Zao> Write a creation function like mkFoo a c d = Foo a 9001 c d -- ?
06:25:15 <desp> :/
06:25:47 <Zao> Or another ctor with smaller arity?
06:26:06 <Zao> Both of which doesn't scale horribly well.
06:26:38 <desp> Thanks.  I wish someone would fix the Haskell records.
06:28:16 <Taejo> desp: one way (which I use, and is used in XMonad) is to have a defaultFoo, and then instead of constructing a Foo, you modify the default one
06:28:46 <Axman6> hell yes, just found out i got 18.5/20 for my concurrent and distributed systems assignment, using C with pipes, sockets, fork and exec
06:29:03 <koeien37> are you french? :)
06:29:04 <Vanadium> condolences
06:29:27 <Vanadium> Hi! Why is System.Random so slow and what can I use instead, ie. for statistics homework?
06:29:36 <Zao> Axman6: Madness. I just passed my Disturbed Systems course.
06:29:42 <Zao> Using glorious *cough* Java RMI.
06:29:43 <Taejo> Vanadium: you can try mersenne-random
06:29:48 <Vanadium> thank you
06:29:56 <Taejo> unfortunately it's very IO-y
06:30:11 <Axman6> Zao: i'm sitting on 49.6% right now, and i should pass the 40% final exam :D
06:30:29 <fasta> Zao, and CORBA?
06:30:41 <fasta> Zao, and writing  IDL :)
06:31:13 <Axman6> i need 30.3/40 for the final exam to get a high distinction... that's possible :D
06:31:36 <Zao> fasta: As heterogeneous platforms was not a requirement, none of that sillyness.
06:31:46 <Zao> Interoperability is for the weak.
06:31:51 <fasta> Zao, heh
06:32:29 <Zao> The next course is about SoA (Service-oriented Architectures). I'm entertaining the thought of using happstack for it.
06:32:29 <fasta> Zao, we had no choice. Other than that we got to choose the technologies as long as it was heterogeneous.
06:35:23 <desp> GHC is supposed to include Cabal now, right?
06:37:01 <fasta> desp, it does (the library).
06:37:08 <koeien37> Cabal != cabal-install
06:37:13 <desp> Ah.
06:37:30 <fasta> Maybe Cabal should be named LibCabal.
06:37:39 <EnglishGent> hi all :)
06:38:14 <rasfar> hi
06:38:15 <Lemmih> Top of the morning to you, good Sir.
06:38:31 <rasfar> (that too)
06:43:13 * knobo likes showing off his new language skills, as he just learned haskell some days ago :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12080
06:43:13 <Veinor> is there a function f g (x,y) = (g x, g y) ?
06:44:10 <koeien37> (&&&) or (***)
06:44:10 <RayNbow> :t (&&&)
06:44:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:44:17 <quicksilver> g *** g
06:44:21 <koeien37> import Control.Arrow -- you need this
06:44:26 <quicksilver> so, your "f" is called "join (***)"
06:44:33 <quicksilver> if you really don't want to mention g twice
06:44:41 <Veinor> thanks!
06:44:42 <quicksilver> > join (***) negate (5,-6)
06:44:43 <lambdabot>   (-5,6)
06:44:56 <quicksilver> but I would normally just write
06:45:04 <quicksilver> > negate *** negate $ (5,-6)
06:45:05 <quicksilver> personally.
06:45:05 <lambdabot>   (-5,6)
06:45:17 <EnglishGent> hello Lemmih :)
06:45:23 <RayNbow> > let both f = f *** f     in   both negate (5,-6)
06:45:24 <EnglishGent> hi rasfar :)
06:45:25 <lambdabot>   (-5,6)
06:47:03 <RayNbow> hmm quicksilver, f *** f might be preferable in certain cases where you need more polymorphism, right?
06:47:14 <quicksilver> RayNbow: yes
06:47:16 <koeien37> yeah
06:47:30 <koeien37> > id *** id $ ("Hello", 37)
06:47:31 <lambdabot>   ("Hello",37)
06:47:35 <quicksilver> > negate *** negate $ (1::Int,1::Double)
06:47:37 <lambdabot>   (-1,-1.0)
06:47:47 <quicksilver> > join (***) negate  (1::Int,1::Double)
06:47:48 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:47:48 <lambdabot>         against inferred type ...
06:47:57 <Vanadium> @type getStdGen >>= randoms
06:47:58 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[a]'
06:47:59 <lambdabot>     In the second argument of `(>>=)', namely `randoms'
06:47:59 <lambdabot>     In the expression: getStdGen >>= randoms
06:48:07 <koeien37> :t randoms
06:48:09 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
06:48:17 <koeien37> :t randoms `liftM` getStdGen
06:48:18 <lambdabot> forall a. (Random a) => IO [a]
06:48:26 <Vanadium> woops
06:48:39 <Vanadium> Tank you
06:48:41 <Vanadium> Thank, even
06:52:02 <EnglishGent> quick question -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12082#a12082
06:52:09 <knobo> I now fully comprehend list comprehention :)
06:52:22 <fasta> Ah, the irony.
06:52:39 <EnglishGent> this routine gets called on *lots* of inputs, is it memory safe? or might it leave file handles open? (I'm not sure of the exact behaviour of readfile here)
06:52:45 <donri> knobo, if you do not yet understand recursion, read this sentence.
06:53:02 <koeien37> EnglishGent: they will be garbage collected
06:53:12 <koeien37> "eventually"
06:53:14 * hackagebot upload: wx 0.12.1.1 - wxHaskell (JeremyODonoghue)
06:53:34 <EnglishGent> hmm - is there a way to force a close? some operating systems arent very happy if the number of open file handles becomes large
06:53:41 <EnglishGent> thanks btw :)
06:53:46 <quicksilver> EnglishGent: that's fine, because == traverses the entire file and therefore should get the handles closed.
06:53:47 <knobo> said I to myself said I
06:54:16 <EnglishGent> does it? if the files differ it wont traverse all of them surely?
06:54:23 <koeien37> quicksilver: i don't know how == works on bytestrings, but couldn't it be that not the whole file is traversed if a difference is detected?
06:55:25 <fasta> When I run ghci in msys, all I get when I evaluate a name with a constant rhs is an empty line.
06:57:15 <rasfar> EnglishGent: sounds like you want more strictness in this case.  Or if you want to preserve laziness to the greatest possible extent, I wonder if there's a way to force file closure only as a resource limit is approached?
06:58:13 <EnglishGent> for the application I have in mind rasfar lazyness is much better - the files I'm checking might be *large* - a gigabyte plus - so I dont want to have to load them both into memory
06:58:42 <EnglishGent> (Real World Haskell explicitly recommends lazy bytestrings if dealing with large files)
07:01:35 <rasfar> yeah, that makes sense.  i'm interested to hear the verdict on ==.  i agree that it should not have to traverse the whole shortest file if an earlier difference is detected, but i don't know how it behaves.
07:02:16 <quicksilver> koeien37: well at the very least the length has to be checked, right/
07:02:23 <quicksilver> koeien37: ah no, you're right.
07:02:29 <quicksilver> koeien37: damn. It's a bad idea.
07:02:38 <quicksilver> a scourge on you, readFile, and all who sail in you.
07:04:49 <Saizan_> rasfar: that's how it behaves http://haskell.org/ghc/docs/latest/html/libraries/bytestring/src/Data-ByteString-Lazy.html <- search for "eq" here
07:12:04 <rasfar> thanks for the link Saizan_.
07:14:14 <eldragon> @where SKIBCY
07:14:14 <lambdabot> I know nothing about skibcy.
07:14:49 <eldragon> @google SKIBCY
07:14:50 <lambdabot> No Result Found.
07:15:06 <eldragon> @google SKIBC
07:15:12 <lambdabot> http://www.joeant.com/DIR/info/get/20118/94546
07:15:13 <lambdabot> Title: 2f Ski BC: Ski Accommodation - www.skibc.com skibc 9
07:15:45 <saml> what does bcy mean?
07:16:41 <eldragon> SKIBCY means S(distributor), K(cancellator), I(identity), B(compositor), C(permutator, Y(fixed point).
07:18:00 <eldragon> i want to know the Turner/Curry set of >20 combinators, where can i find this set?
07:20:22 <saml> 20 combinators?
07:20:41 <eldragon> yes saml
07:20:51 <saml> http://en.wikipedia.org/wiki/Combinatory_logic#Combinators_B.2C_C  ?
07:22:21 <EnglishGent> @hoogle Handle
07:22:22 <lambdabot> System.IO data Handle
07:22:22 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
07:22:22 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
07:23:27 <EnglishGent> @hoogle Handle -> IO ByteString
07:23:28 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
07:23:28 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
07:23:28 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
07:26:24 <EnglishGent> ah! according to the package documentation
07:26:27 <EnglishGent> Read an entire file lazily into a ByteString. The Handle will be held open until EOF is encountered.
07:27:01 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12084#a12086 <-- any suggestions on how to make this coinflipping less embarassing?
07:28:05 <luite> gwern: use MonadRandom perhaps?
07:28:21 <gwern> luite: don't want to use a library; this is for reddit
07:29:04 <luite> ah
07:29:11 <Vanadium> fmap randoms newStdGen for an infinite list of bools instead of generating a new one all the time, maybe?
07:29:25 <gwern> hm
07:29:44 <gwern> but I'd still have to thread through the list
07:33:26 <sjanssen> gwern: I think randoms would still be nicer, you can pattern match on the LHS of equations
07:34:26 * hackagebot upload: matsuri 0.0.2 - ncurses XMPP client (OlegIvanov)
07:34:50 <sjanssen> gwern: str ++ "A" repeatedly is sad
07:35:06 <maartenm> koeien37: would you know irc channels where I could learn more about QC?
07:35:06 <gwern> oh come on the concatenation isn't happening that often
07:35:27 <koeien37> maartenm: i don't know, maybe ##physics or #math
07:35:47 <maartenm> #qc is invite-only and might stand for Quench for Chicks for all I know
07:35:54 <koeien37> i can recommend the text by nielsen & chuang
07:35:55 <maartenm> tried #physics.. not much goign on there
07:35:58 <maartenm> ok
07:36:15 <koeien37> 'quantum computation & quantum information' i think
07:36:29 <maartenm> I'm at work, read abotu Shor's algorithm this afternoon.. trying to understand it
07:36:36 <sjanssen> gwern: what's up with the b' in the else clause in first?
07:36:48 <sjanssen> it is intentionally ignored?  Doesn't really make sense to me
07:36:52 <rasfar> Okay, so equality test will stop on the first Chunk that differs (in length or content), and yet the Handle will not close until EOF?  But it will be closed eventually through garbage collection.  I guess this doesn't resolve your question EnglishGent...
07:37:06 <koeien37> maartenm: the text doesn't assume too much background -- i could follow it, although i know next to nothing about physics
07:37:14 <gwern> sjanssen: 'if it's heads, keep flipping until...'
07:37:14 <maartenm> cool, thanks
07:37:28 <McManiaC> http://npaste.de/2p ← can anyone tell me what this means?
07:37:52 <EnglishGent> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12087#a12087 -- any ideas anyone? I thought I'd fixed the problem - but no :|
07:38:04 <sjanssen> gwern: but doesn't the extra generation mean you're throwing away one of the flips?
07:38:15 <jkramer> Hello
07:38:16 <koeien37> McManiaC: hmm, is this linux or freebsd or something else?
07:38:21 <gwern> isn't that what it says? throw away flips?
07:38:23 <McManiaC> linux
07:38:35 <EnglishGent> hi jkramer :)
07:38:49 <jkramer> I'm trying to do some simple work with UTCTime and NominalDiffTime, but I'm getting confused
07:39:02 <koeien37> McManiaC: i have no idea, you could try #happs, although it's not very active over there
07:39:11 <rasfar> EnglishGent: do you use the result in the test?  I think equality won't be evaluated until you need it?
07:39:13 <maartenm> koeien: sheesh, the eBook is like 67$
07:39:14 <jkramer> I have an amount of seconds (Int) and want to make it a NominalDiffTime that I can add to an UTCTime
07:39:15 <EnglishGent> no - it doesnt rasfar, as I really want to make sure the handles are closed when the function exits
07:39:27 <McManiaC> i already did, seems to be a problem with one of their modules :S
07:39:29 <quicksilver> jkramer: fromIntegral
07:39:32 <EnglishGent> there's a way to force an expression to be evaluated isnt there?
07:39:35 <maartenm> koeien37: no, sorry.. different book.. I'll find an 'e' version
07:39:36 <jkramer> To me, it looks like NominalDiffTime is just an Int or at least Num
07:39:40 <jkramer> Ah
07:40:03 <rasfar> that's where the strcitness might be useful.  someone else better give you the details, i'm VERY rusty and not very knowledgeable
07:40:15 <jkramer> quicksilver: Thanks, that was it :)
07:40:44 <quicksilver> jkramer: of course, since NominalDiffTime is a Num, you can just use a literal (like 5) directly as a NominalDiffTime
07:40:58 <quicksilver> jkramer: but if you actually have an Int from somewhere else, then fromIntegral is what you want.
07:41:26 <quicksilver> (a literal like 5 is just shorthand for "fromInteger (5::Integer)" anyway)
07:41:33 <Lemmih> McManiaC: 'cabal clean' doesn't fix it?
07:41:57 <rasfar> i would put the equality test in a seperate function with a strictness annotation.
07:42:12 <McManiaC> Lemmih: cabal clean what?
07:42:12 <rasfar> someone else will probably have a better idea?
07:43:23 <gwern> @hoogle a -> [a] -> Int
07:43:24 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
07:43:24 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
07:43:24 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
07:45:36 <Vanadium> Are you still flipping coins
07:45:40 <gwern> Vanadium: yes
07:45:44 <EnglishGent> fixed it - change the line calculating the result to: result <- return $! (x_content == y_content) ;
07:46:08 <EnglishGent> and that forces it to evalute the == :)
07:46:14 <gwern> so I've discovered the fellow is wrong that 1/2 the entries will be B, but I'm still not sure what deterministic algorithm I can give that will be better than random searches
07:46:16 <EnglishGent> evaluate*
07:46:17 <gwern> hm
07:47:23 <Vanadium> I like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12089#a12089
07:48:39 <rasfar> $! -- yeah, that's it.
07:49:02 <gwern> Vanadium: could you just say isHeads True = True; isHeads x = x?
07:49:29 <gwern> 2 functions seems like overkill
07:51:12 <Vanadium> you can remove both isHeads and isTails and replace the uses of isHeads with id, I suppose..
07:52:40 <gwern> for that matter, isn't it redundanti with just 'if c'?
07:52:52 <Vanadium> Yeah, it is.
07:52:58 <Vanadium> Maybe we can use
07:52:59 <Vanadium> newtype Coin = Coin { isHeads :: Bool } deriving Random
07:53:05 <Vanadium> instead to pretend we are all high-level and abstract
07:53:08 <gwern> -_-
07:53:11 <gwern> this isn't ##java
07:53:19 <sjanssen> gwern: how about this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12084#a12090
07:54:08 <Vanadium> I just wanted the loop to be readable without knowing what way I interpreted the bools in the random list
07:55:21 <Vanadium> That seems to look better
07:56:36 * hackagebot upload: regex-xmlschema 0.1.3 - A regular expression library for W3C XML Schema regular expressions (UweSchmidt)
07:57:39 <gwern> sjanssen: that looks better though I don't like the type class
07:57:47 * gwern is late now though and so will pick this up later
07:58:34 <rasfar> EnglishGent: Probably at some later point you will be able to relax the $! since presumably you are going to consume the results of your equality tests.
08:03:28 <EnglishGent> well this is part of a file-system library, so I'm trying not to make too many assumptions
08:04:22 <EnglishGent> besides - it seems to introduce a bug if I relax it to the point of not including it, and I'm not sure yet what a good compromise would be
08:04:34 * EnglishGent is fairly new to Haskell still & working most of this out as he goes along :)
08:14:42 * hackagebot upload: bindings-DSL 1.0.1 - Domain specific language for FFI description, on top of hsc2hs. (MauricioAntunes)
08:22:19 <mreh> Cale, are you here?
08:22:27 <mreh> i can't @seen anyone
08:22:55 <luite> mreh: preflex: seen
08:23:06 <mreh> preflex: seen Cale
08:23:06 <preflex>  Cale was last seen on #haskell 8 hours, 45 minutes and 2 seconds ago, saying: > sequence [[1,2,3],[4,5],[6,7,8]]
08:23:10 <mreh> heh
08:26:25 <saml> > sequence ["hello", "world"]
08:26:26 <lambdabot>   ["hw","ho","hr","hl","hd","ew","eo","er","el","ed","lw","lo","lr","ll","ld"...
08:26:38 <mreh> disgusting
08:26:44 <saml> > sequence ["a", "bc"]
08:26:45 <lambdabot>   ["ab","ac"]
08:27:04 <saml> oh.. it's like... something.. combination?
08:27:11 <saml> > sequence ["ab", "cd"]
08:27:12 <lambdabot>   ["ac","ad","bc","bd"]
08:27:49 <jmcarthur_work> saml, think of it like nested for loops, if you wish
08:28:21 <mreh> > [[x,y]| x <- (a,b,c), y <- (1,2,3)]
08:28:22 <lambdabot>   Couldn't match expected type `[t]'
08:28:22 <lambdabot>         against inferred type `(SimpleRe...
08:28:24 <saml> ah this could be useful for matrices
08:28:55 <mreh> >a
08:29:02 <mreh> > a
08:29:03 <lambdabot>   a
08:29:10 <mreh> :t a
08:29:11 <lambdabot> Expr
08:30:48 <saml> > sequence [[a,b], [c,d]]
08:30:49 <lambdabot>   [[a,c],[a,d],[b,c],[b,d]]
08:31:35 <mreh>  [[x,y]| x <- [a,b,c], y <- [1,2,3]]
08:31:42 <mreh> >  [[x,y]| x <- [a,b,c], y <- [1,2,3]]
08:31:43 <lambdabot>   [[a,1],[a,2],[a,3],[b,1],[b,2],[b,3],[c,1],[c,2],[c,3]]
08:31:49 <jmcarthur_work> > sequence . sequence $ [[a,b], [c,d]]
08:31:50 <lambdabot>   [[a,a,b,b],[a,a,b,d],[a,a,c,b],[a,a,c,d],[a,d,b,b],[a,d,b,d],[a,d,c,b],[a,d...
08:32:11 <mreh> I don't understand that
08:32:20 * mreh brane asplode
08:36:53 * hackagebot upload: bindings-gsl 0.1.1 - Low level bindings to GNU GSL. (MauricioAntunes)
08:43:01 <dcoutts> to all #haskell denizens:
08:43:03 <dcoutts> please try the cabal-install-0.6.x darcs branch
08:43:09 <dcoutts> http://darcs.haskell.org/cabal-branches/cabal-install-0.6/
08:43:16 <dcoutts> and report any regressions vs 0.6.2
08:43:36 <dcoutts> try it as your day-to-day version
08:52:31 * Saizan_ pulls
08:55:42 <eldragon> i want to extend the SKIBCY machine as a LEGO hobby, guessing the bigger Turner/Curry set of combinators (>20, i want something as >50).
08:56:29 <dancor> hm?  what is SKIBCY
08:57:11 <eldragon> SKIBCY are the 6 common combinators: S(distributor), K(cancellator), I(identity), B(compositor), C(permutator), Y(fixed point).
09:00:23 <red-agent> How do I foldl through the (Map a b) in order function to receive (a, b) pair as the item argument? Data.Foldable receives only b (which is the value).
09:00:28 <red-agent> The key seems to be lost
09:00:34 <eldragon> the minimal machine is SK but it's practically very inefficient.
09:00:48 <m0nkfish> surely the acronym would be like.. biscky
09:01:05 <tromp_> you can compile to efficient sk
09:01:22 <tromp_> just have to be careful how to bracket abstract
09:01:41 <poe> red-agent http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#13
09:01:53 <eldragon> SK can't manage recursion so that the minimal is SKY
09:02:12 <tromp_> Y is easily expressed in SK
09:02:27 <red-agent> poe: Cool. Thanks.
09:03:05 <tromp_> Y=SSK(S(K(SS(S(SSK))))K)
09:03:39 <eldragon> oh
09:07:57 <eldragon> tromp_, what means that it has to be careful? is confluent the compilation/reduction for efficent WHNF?
09:08:20 <eldragon>  /efficient WHNF/shorter WHNF/
09:08:51 <tromp_> i suggest some abstraction rules in http://www.cwi.nl/~tromp/cl/LC.pdf
09:09:12 <tromp_> that seem to achieve the same effect as turner's extra combinators
09:09:13 <eldragon> thanks
09:09:17 <tromp_> but using only S,K
09:12:32 <eldragon> using SK only generates longer strings but i think that i can compact them using LZ77 dictionary + rangecoder.
09:13:14 <eldragon> that often appears many repeated substrings.
09:13:17 <tromp_> they can be easily encoded in binary
09:13:42 <tromp_> an expression of n S/K takes 3n-1 bits
09:14:23 <tromp_> so Y is only 3*12-1=35 bits
09:14:35 <tromp_> less than 5 bytes
09:14:49 <eldragon> in complexity theory, there are many recursive functions, so many Ys
09:15:09 <tromp_> but 12 is minimum in S&K
09:15:12 <eldragon> i want a way to compact this inefficiency.
09:17:07 <tromp_> well, binary lambda calculus generally gives you the shortest code
09:18:06 <tromp_> e.g. it allows for a brainfuck interpreter in only 117 bytes
09:18:49 <eldragon> i think that each lambda definition/function can be guessed its shortest SK string with A* search but i don't know how.
09:19:37 <tromp_> finding the shortest is in general undecidable
09:22:07 <dankna> hmmmm
09:22:18 <dankna> can somebody tell me if the problem I am suspecting is possible?
09:22:27 <dankna> I have a computation which may generate an error
09:22:35 <dankna> I wrap "catch" around it, just in case
09:22:41 <dankna> can laziness interfere with that
09:22:50 <dankna> so that the value is actually determined after the catch has exited
09:22:56 <dankna> so that the handler doesn't catch the exception?
09:23:34 <lilac> what's the type of your computation?
09:23:36 <quicksilver> yes, which is why you don't do that
09:23:39 <dankna> I should note that I'm using OldException because one of my libraries doesn't give me a choice about that.  But if I have to go into the library and modify it to use new exceptions, I will; I just need to understand the source of the problem
09:23:42 <quicksilver> we don't bury exceptions in pure values
09:23:58 <dankna> it's actually an IO-based monad
09:24:00 <quicksilver> (except to signal unrecoverable error, which we dont' expect to recover from)
09:24:05 <dankna> hmm
09:24:07 <dankna> I take your point
09:24:17 <quicksilver> throwing exceptions in IO is fine
09:24:24 <quicksilver> they're always catchable
09:24:30 <quicksilver> it's burying them in pure values which is a bad idea
09:24:31 <lilac> dankna: if it's an IO exception then yes, you can catch it. if it's a pure exception then you can but you shouldn't ;)
09:24:35 <quicksilver> (for this very reason)
09:24:38 <dankna> lilac: hmmm okay
09:24:57 <dankna> well, I think I may have put exceptions in pure values somewhere within the larger computation
09:25:02 <dankna> hrm
09:25:12 <dankna> guess I need to rip out a lot of code then, that's a shame
09:25:29 <drhodes> it looks like go designed their interface construct around typeclasses, anyone else see this?
09:25:32 <dankna> but I appreciate everyone's time :) bad news is still helpful
09:25:53 <lilac> drhodes: no, they're not typeclasses, due to implicit instances...
09:26:14 <dankna> they remind me of Objective-C classes
09:26:19 <dankna> or interfaces, rather
09:26:26 <dankna> but I didn't look at them that deeply
09:26:33 <lilac> they remind me of c++' aborted feature of implicit concepts
09:26:37 <drhodes> hmmm, ok, I'll need to look closer
09:26:39 <dankna> haha
09:27:33 <dankna> but yeah, I found Go disappointing.  it's great that it has closures and GC, of course.  and I understand that what they're trying for is a better C.  but there are all these other concepts that they could have put in but didn't...
09:27:59 <m0nkfish> lazy evaluation
09:28:01 <m0nkfish> ;)
09:28:02 <dankna> yes indeed
09:28:55 <eldragon> m0nkfish, yes, avoiding to do the work that was made previously.
09:30:42 <m0nkfish> normal order graph reduction then 8)
09:31:23 <eldragon> yes, always on a Graph Rewriting System <:)
09:37:00 <eldragon> in the biblioteque, i did read a detail, the problem of desharing, peeling off a copy (Wadsworth 1971), problem of avoiding duplication of work is called "optimality problem" (Levy 1980), and its algorithm that solves it is Lamping 1990's and is very complex. Where can i find this newer algorithm?
09:38:46 <MyCatVerbs> eldragon: I don't know that paper, but have you tried Google Scholar?
09:39:06 <eldragon> i will try it.
09:43:20 <int-e> eldragon: are you looking for lambdascope?
09:43:59 <eldragon> thanks int-e, it too.
09:58:30 <tautologico> who decided that I need to install ghc6 if I have to install the emacs haskell-mode in ubuntu 9.10?
09:59:52 <opdolio> Not me.
10:00:02 <voker57> it's recommended, not required
10:00:09 <voker57> config yer package manager
10:00:31 <opdolio> Ubuntu doesn't have the latest haskell-mode anymore, either. :)
10:00:36 <tautologico> no, i try to install haskell-mode and it says "the following additional packages will be installed"
10:01:01 <tautologico> not recommended
10:01:49 <voker57> try --no-install-recommends
10:02:50 <FauxFaux> aptitude and similar tools also won't fight you if you mark ghc6 not to be installed on the "proposal" screen (along with having a "graphical" way to turn on the above flag).
10:02:57 <tautologico> yes, it worked, thanks
10:03:39 <tautologico> well apt-get install haskell-mode includes ghc6 and other packages automatically
10:04:08 <dankna> tell the Ubuntu people about it
10:04:20 <tautologico> well, at least the packaged version is 6.10.4
10:04:38 <tautologico> 9.04 had 6.8
10:04:42 <tautologico> 6.8.something
10:19:19 <Exteris> anyone familiar with sqlite here?
10:19:33 <dankna> me
10:20:15 <Exteris> dankna: do you know how i can fix this: http://pastie.org/private/fwe7hrzkvuiruxlra95w
10:20:51 <dankna> I think you want id INTEGER PRIMARY KEY AUTOINCREMENT, rather than id INTEGER NOT NULL,
10:20:57 <dankna> but read the docs on how autoincrement behaves
10:21:05 <dankna> snarkily, I could say "fix what?  it's behaving as designed"
10:21:17 <dankna> you understand why you get the error, right?
10:21:26 <dankna> you specified a NOT NULL constraint and then tried to omit that column
10:22:18 <dankna> http://www.sqlite.org/autoinc.html here - read this before using autoincrement
10:23:11 <Exteris> oh wait
10:23:22 <Exteris> i thought i had set autoincrement for that column:M
10:23:24 <Exteris> stupid
10:23:25 <Exteris> thanks
10:23:28 <dankna> sure thing
10:24:02 <dankna> note that, as that page describes, autoincrement isn't implemented in sqlite unless the column is that exact type - INTEGER PRIMARY KEY AUTOINCREMENT.
10:26:42 <bos> preflex: seen dons
10:26:42 <preflex>  dons was last seen on #haskell 19 hours, 49 minutes and 48 seconds ago, saying: so you could have main :: IO Int
10:27:01 <bos> dcoutts: did you get my mail the other day?
10:27:31 <dcoutts> bos: about utf8 decoding speed?
10:28:11 <dcoutts> bos: I've not played much with the current inlining behaviour so I don't have any magic tricks
10:28:11 <bos> yep
10:28:17 <bos> dcoutts: ok :-)
10:28:47 <dcoutts> my understanding is just that inline means it keeps the original unoptimised and dumps it into the call site
10:29:05 <dcoutts> so you should get multi-level inlining happening at the call site
10:29:22 <dcoutts> unless ghc decides a function is not a candidate for inlining
10:29:42 <bos> dcoutts: it's more tricky than that, unfortunately.
10:30:09 <EnglishGent> hello :)
10:30:09 <dcoutts> sounds like the problem is not the inlining though but the worker/wrapper and unboxing
10:30:56 <EnglishGent> does anyone here know how to get HDBC working with Postgres?
10:31:03 <bos> dcoutts: i have this lovely example where if the call site is not evaluated strictly, the stream fusion rules fire, and everything gets inlined. if i do evaluate strictly, the stream fusion rules don't fire (and they shouldn't), but none of the inlining occurs. my head asplode.
10:31:31 <dcoutts> bos: present your example on the ghc users list
10:32:13 <bos> dcoutts: yeah, i wish it was a simpler example.
10:32:20 <dpratt71> anyone around who'd be willing (and able) to try to make me understand GADT syntax?
10:33:22 <dpratt71> specifically, I'm a bit thrown by something that looks like a type signature, but seems to function as a type constructor
10:34:34 <sjanssen> dpratt71: the truth is that even standard constructor syntax defines functions for each constructor, they're just implicit
10:35:07 * hackagebot upload: hogre 0.0.2 - Haskell binding to a subset of OGRE (AnttiSalonen)
10:35:15 <sjanssen> GADTs let you define this constructor's type explicitly, giving you a bit more flexibility
10:35:19 <kmc_> :t Just
10:35:21 <lambdabot> forall a. a -> Maybe a
10:35:30 <kmc_> data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a
10:35:34 <dayz> hi
10:36:07 <kmc_> dpratt71, the return value of the ctor must be in the type you're defining
10:36:27 <dpratt71> referring to the "parser" example here: http://haskell.org/haskellwiki/Generalised_algebraic_datatype ...
10:36:35 <dayz> i have a slightly unrelated question: if a theory T has a single axiom a & b, how many models would T have?
10:36:45 <kmc_> but unlike a regular ADT you can give more specific types... so you could say Thing :: Char -> Maybe Int
10:36:56 <sjanssen> dpratt71: that uses not only the GADT syntax, but the semantics too
10:37:03 <kmc_> and then when pattern-matching on Thing, you know that the "a" type variable is instantiated at Int... that's what makes them more powerful
10:37:05 <dpratt71> considering a constructor that looks like this: Satisfy :: ([tok] -> Bool) -> Parser tok [tok] ...
10:37:08 * hackagebot upload: hogre-examples 0.0.2 - Examples for using Hogre. (AnttiSalonen)
10:37:19 <kmc_> but you can also write any old-style ADT as a GADT without using this extra power
10:37:53 <dpratt71> what is the semantics of specifying "Parser tok [tok]" ? what is being expressed here?
10:38:12 <dpratt71> that was one long question, btw
10:38:40 <kmc_> that the constructor Satisfy has one data field, of type ([tok] -> Bool), and the constructed value has type Parser tok [tok]
10:38:52 <kmc_> which youll notice is a specialization of the type named in the "data" head, Parser tok a
10:39:06 <zygoloid> dpratt71: it means that the constructor Satisfy has type ([tok] -> Bool) -> Parser tok [tok]
10:39:38 <dpratt71> when (or in what situation) does the "constructed type" become meaningful?
10:39:46 <kmc_> what do you mean?
10:40:04 <zygoloid> dpratt71: if you understand ~, it means data Parser tok toks = (toks ~ [tok]) => Satisfy ([tok] -> Bool)
10:40:15 <kmc_> if you pattern match on the constructor pattern (Satisfy f), you get to assume f :: [tok] -> Bool
10:40:43 <kmc_> but you also get to assume (Satisfy f) :: Parser tok [tok], rather than a more general (Satisfy f) :: Parser tok a
10:40:45 <zygoloid> dpratt71: if you pattern match a (Parser a b) and get Satisfy f, you get to assume that [a] ~ b
10:41:16 <dpratt71> I mean, could I change it to (for example) "Satisfy :: ([tok] -> Bool) -> Parser tok tok"?
10:41:21 <kmc_> yes
10:42:04 <dpratt71> ok; really dumb question, but what is the significance of such a change? it doesn't change pattern matching on Satisfy, right?
10:42:50 <zygoloid> dpratt71: it means that ifyou pattern match a (Parser a b) and get Satisfy f, you get to assume that a ~ b
10:43:09 <kmc_> dpratt71, look at http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
10:43:30 <kmc_> look at how "eval" is written
10:43:48 <kmc_> its type is "Term a -> a", but the RHS of each function equation does more specific things like arithmetic, making tuples, etc
10:44:05 <dpratt71> will do; thanks kmc_, zygoloid
10:45:29 <sjanssen> I lost the SSH key I use to log in to darcs.haskell.org, where can I find a superuser to fix it for me?
10:45:47 <kmc_> so that, e.g. when you pattern match the Pair constructor, you know that a ~ (b,c) with e1::b and e2::c; thus it's fair to return (e1,e2) :: (b,c) even though the "overall" signature is Term a -> a
10:45:56 <kmc_> err (eval e1, eval e2)
10:46:31 <kmc_> "~" means that the two types can be "unified"
10:56:09 <eldragon> the smallest program that aproximates to the Kolmogorov complexity is the SK string of binary combinatory logic although it's written as non-universal program, right?
10:57:13 <EnglishGent> anyone here managed to get HDBC working with Postgres?
10:57:58 <profmakx> anybody at all getting any kind of database working with haskell in a reasonable way... it doesn't seem like databases are a high priority in the haskell community ;)
10:58:16 <Zao> Sounds like something fun to try. I've only used it with SQLite thus far.
10:58:37 <EnglishGent> I've managed to get sqlite working with HDBC profmakx :)
10:59:01 <EnglishGent> unfortuantely - I seem to be having trouble finding out how to install the postgres driver
10:59:04 <profmakx> i don't remember what i tried, but i failed
10:59:05 <EnglishGent> :|
10:59:06 <dankna> profmakx: sqlite works fine with the various drivers
10:59:22 <dankna> I eventually wrote my own binding to it that does a better job of Unicode handling than any of the ones out there, but is less complete than them
10:59:30 <profmakx> couchdb works too
10:59:30 <dankna> it's not on Hackage yet because it's not stable
10:59:32 <profmakx> i used that one
10:59:51 <profmakx> but all the "hihger level" libraries did not work at all
11:00:06 <profmakx> and if it was only for a lack of examples/documentation
11:00:11 <dankna> my understanding is that HaskellDB wants to replace HDBC
11:00:21 <dankna> I may have that backwards
11:00:36 <dankna> but it's certainly a caveat-emptor situation no matter what
11:00:42 <sproingie> haskelldb i believe is a higher level wrapper for hsql and hdbc
11:00:50 <EnglishGent> that's my understanding too - as far as I'm aware HaskellDB operates at a higher level of abstraction - you dont feed SQL strings to the database
11:01:30 <EnglishGent> but right now I'd like a low-level connection, whilst I try to figure out what exactly is going on! I'm still quite new to Haskell :)
11:01:36 * dankna nods
11:01:56 <eldragon> what's the matter if the smaller SK string program is compressed with adaptive arithcoder/rangecoder due to different frecuencies of 0 & 1 ? maybe that arith/range compressed SK string is smaller than the uncompressed?
11:02:08 <dankna> my thing wouldn't be useful to you anyway, EnglishGent, as it isn't what the higher-level libraries you're using are based on
11:02:24 <dankna> (also as it's SQLite rather than PostgreSQL)
11:02:40 <EnglishGent> presumably there must be a cabal package that contains the Database.HDBC.PostgreSQL module?
11:02:49 <dankna> yes
11:02:51 <dankna> it's in the list
11:02:52 <dankna> one sec
11:03:05 <EnglishGent> (in fact - that's a more general issue - if I know the module name for something, how do I find out what to tell cabal to import?) :)
11:03:07 <EnglishGent> thanks! :)
11:03:13 <sproingie> it'd be nice if cabal could install by module name the way CPAN can
11:03:15 <dankna> (you have to just know)
11:03:23 <dankna> http://hackage.haskell.org/package/haskelldb-hdbc-postgresql
11:03:34 <EnglishGent> thanks! :)
11:03:43 <dankna> (I found that by going to the main list at http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database and skimming)
11:03:50 <dankna> sure :)
11:04:07 <c_wraith> sproingie:  that'd be tough when many packages export the same modules
11:04:13 <dankna> sproingie: well, Cabal makes the design decision to - what Wraith just said
11:04:15 <sproingie> c_wraith: then it would complain at you
11:04:30 <dankna> well, I approve of the feature; add it :D
11:04:46 <dankna> note: I have no connection to the people who implement Cabal
11:05:14 <c_wraith> preflex: seen dcoutts
11:05:15 <preflex>  dcoutts was last seen on #haskell 33 minutes and 43 seconds ago, saying: bos: present your example on the ghc users list
11:05:24 <sproingie> never looked at cabal code, don't know what it uses for the index right now
11:05:30 <c_wraith> Oh, hey.  he was even around recently.  he's one of the cabal devs
11:06:51 <dankna> the index format is a tarfile containing .cabal files
11:07:04 <dankna> I don't understand how that can possibly be fast enough, but apparently it is
11:07:42 <dankna> if I were writing it, I would probably have used an sqlite database :)
11:08:22 <c_wraith> it's fast enough because a) tar files aren't compressed and b) the whole index is small, for computers these days
11:08:32 <dankna> must be
11:08:46 <sproingie> yah i think that'll have to be revisited for, well, anything complex at all
11:09:02 <dankna> note that this is not where the index of *installed* packages is kept
11:09:09 <dankna> that's kept by ghc-pkg or whatever
11:09:18 <dankna> (I'm not sure what hugs and nhc use)
11:09:28 <trofi> ~/.ghc/
11:09:35 <sproingie> does hugs even have a package system?
11:09:39 <dankna> not sure
11:09:56 <Saizan_> not really
11:11:19 <yokto> Hi does anyone know how i can make a list of (booleans/bits) from a file/string?
11:11:27 <sproingie> the package system is up to ghc, i'm mostly interested in indexing hackage
11:12:22 <sproingie> pretty much all cabal has to know is "is package X in version range Y installed"
11:13:05 <dankna> right
11:14:59 <eldragon> is the Kolmogorov theory for the creators of the smallest intelligent autonomous viruses?
11:15:15 <desim> could anyone assist me with java coding?
11:15:30 <Saizan_> sproingie: there was some talk about generating a local reverse index from modules to package in the past, it'd also be useful for when you get some code without a .cabal file: scan the imports, install the packages
11:15:31 <mauke> desim: how is that a Haskell question?
11:15:45 <MoALTz> how do people who have java questions find this channel???
11:15:46 <EnglishGent> okay - cabal gives me a verrrry long error message: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12094#a12094
11:15:56 <sproingie> Saizan_: might be better to just autogenerate .cabal files
11:16:08 <dankna> EnglishGent: I see you haven't been doing Haskell very long :D
11:16:13 <dankna> that isn't that long an error, haha
11:16:13 <Saizan_> sproingie: yeah, also that
11:16:16 <desim> its not but the java chatroom isnt getting any results so i figured there had to be some talented fols around here somehwere
11:16:19 <EnglishGent> I havent dankna
11:16:24 * EnglishGent freely admits it :)
11:16:30 <dankna> hehe, okay
11:16:34 <dankna> now let me look at it...
11:16:52 <Saizan_> sproingie: but if you generate .cabal files for some code you've developed you probably already have the packages installed, so you can ask ghc-pkg for which package provides which module
11:17:01 <mauke> desim: if I wanted to think about java, I'd be in ##java
11:17:08 <dankna> too late
11:17:10 <dankna> he left
11:17:17 <EnglishGent> there was a lot of stuff before it - but that was all successes of various bits compiling, so I dont think it's relevant
11:17:18 <EnglishGent> :)
11:17:23 <dankna> I don't understand that attitude >< oh well, the less said about it the better
11:17:26 <eldragon> call it Kolmogorov-viruses because they are the strongest and dangeroust of the Earth's viruses.
11:17:58 <sproingie> wouldn't a virus with no redundancy actually be pretty fragile?
11:18:24 <kmc_> MoALTz, they look for the biggest channels on freenode
11:18:38 <c_wraith> MoALTz:  there are queries about java coding to which google responds with a link to *this channel* on some irc gateway
11:18:54 <sproingie> since its encoding would be maximally compressed, it would probably admit no mutations, which would mean immunity would be pretty simple
11:18:57 <MoALTz> that is bizzare
11:19:35 <kmc_> yeah, most living things have intentionally redundant genomes
11:19:41 <eldragon> all that is possible in the computation world is traslated to the biological world, the viruses codificated with Kolmogorov DNA strings.
11:20:01 <sproingie> viruses technically aren't even living things by most definitions, but they do need to mutate to propagate
11:20:04 <kmc_> even the encoding from base-pair triples to amino acids is error-correcting around the most common amino acids
11:20:14 <sproingie> er to be successful that is
11:20:14 <kmc_> they don't need to mutate to propagate
11:20:16 <kmc_> they just will anyay
11:20:29 <sproingie> to continue propagating successfully i mean
11:21:19 <kmc_> it is really quite significant that living things work largely by interpreting a digital code
11:21:32 <kmc_> it's good empirical evidence that there's something to this whole computer idea after all
11:21:58 <dankna> yes, it's interesting to think about
11:22:02 <sproingie> planck space and planck time could be betraying the granularity of the sim
11:22:13 <EnglishGent> actually - when they do come here .. shouldnt we convert them?
11:22:18 <EnglishGent> resistance is futile!
11:22:19 <EnglishGent> :)
11:22:47 <burp> a computer.. must be a huge thing -.-
11:22:51 <EnglishGent> poor Java people - they think paramterised types are a new thing .. really, we ought to have some sympathy.... :)
11:23:22 <dankna> amusement!
11:23:38 <mulletron> what were the issues with hs-plugins that caused a move to mueval?
11:23:45 <sproingie> voltage over current is futule!
11:23:48 <mulletron> was it just the lack of sandboxing?
11:23:58 <burp> hm, but if it was awkwardly slow, and just had much space, would we notice it?
11:24:10 <EnglishGent> can you make any sense of that error dankna? becuase to me it effecively reads as "wibble wibble wibble -- something went wrong"
11:24:10 <EnglishGent> :)
11:24:27 <dankna> EnglishGent: anyway, your errors to me look like the package convertible is broken because of changes in the underlying Time library
11:24:50 <sproingie> EnglishGent: it doesn't help that said parameterized types are totally second-class since they're erased
11:25:04 <dankna> specifically, the types POSIXTime and UTCTime don't have instances of Typeable, which they would need to be stored in a Dynamic, for example
11:25:33 <dankna> it's a two-line change to the underlying library, but I'm not sure who maintains that library and what their reasons might be for not already deriving Typeable
11:25:49 <dankna> or what Convertible is doing that makes it want that
11:25:50 <sproingie> granted you can do erasure without totally screwing the pooch, but java didn't go that far
11:26:04 <dankna> is this any help to you?
11:26:07 <doublethink_work> dankna: you don't need to modify the library, you can use the 'standalone deriving' feature
11:26:13 <dankna> oh?  nice
11:26:31 <doublethink_work> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
11:26:34 <dankna> okay, so you can fix things by modifying Convertible instead of Time, that's probably good
11:26:37 <EnglishGent> um - some
11:26:47 <EnglishGent> I guess I can try & find out who maintains the library
11:27:00 <dankna> look for who maintains Convertible
11:27:10 <doublethink_work> i believe it's CosmicRay
11:27:16 <dankna> ah, useful :D
11:28:34 <EnglishGent> I take it they come here? :)
11:29:55 <dankna> sounds that way
11:30:42 <doublethink_work> @seen CosmicRay
11:30:43 <lambdabot> Unknown command, try @list
11:30:46 <doublethink_work> :(
11:30:49 <doublethink_work> preflex: seen CosmicRay
11:30:49 <preflex>  CosmicRay was last seen on #haskell 9 days, 54 minutes and 16 seconds ago, saying: heh
11:31:53 * EnglishGent guesses he can leave him a message
11:31:55 * EnglishGent shrugs
11:34:51 <dankna> Hackage lists his email as the maintainer
11:34:54 <dankna> http://hackage.haskell.org/package/convertible
11:35:03 <EnglishGent> oh - ty :)
11:49:41 <yokto> how can I make a list of bits/bools from a string/file?
11:50:58 <Tobsan> yokto: that is not exactly trivial
11:51:06 <sproingie> map someFuncToTurnStringsToBools $ unlines someString
11:51:16 <Tobsan> funny though, me and anders^^ is working on such a library!
11:52:17 <kmc_> yokto, you probably want to read Word8 (bytes) rather than Char (Unicode codepoints)
11:52:26 <kmc_> you can read them into a ByteString
11:52:42 <kmc_> :t testBit
11:52:43 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
11:53:16 <sproingie> @info Bits
11:53:17 <lambdabot> Bits
11:53:23 <sproingie> well that was less than helpful
11:53:29 <roconnor> http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Data-Bits.html#t%3ABits
11:53:29 <mauke> there is no @info
11:53:41 <sproingie> oh
11:54:10 <galdor> does someone know how to generate a "pre" block with haddock ?
11:54:12 <kmc_> :t concatMap (\a -> map (testBit a) [0..7])
11:54:13 <lambdabot> forall a. (Bits a) => [a] -> [Bool]
11:54:36 <Twey> galdor: Start the lines with >
11:54:36 <galdor> @...@ generates a "tt" block, but this breaks the line formatting
11:54:37 <lambdabot> Unknown command, try @list
11:54:38 <roconnor> :type concatMap (\a -> map (testBit a) [0..bitsize a])
11:54:48 <roconnor> :t concatMap (\a -> map (testBit a) [0..bitsize a])
11:54:49 <lambdabot> Not in scope: `bitsize'
11:54:54 <roconnor> :t concatMap (\a -> map (testBit a) [0..bitSize a])
11:54:55 <lambdabot> forall a. (Bits a) => [a] -> [Bool]
11:55:02 <kmc_> > let f = concatMap (\a -> map (testBit a) [0..bitsize a]) in f ([32, 58, 16, 79, 123] :: [Word8])
11:55:03 <lambdabot>   Not in scope: `bitsize'
11:55:08 <kmc_> > let f = concatMap (\a -> map (testBit a) [0..bitSize a]) in f ([32, 58, 16, 79, 123] :: [Word8])
11:55:10 <lambdabot>   [False,False,False,False,False,True,False,False,False,False,True,False,True...
11:55:11 <galdor> Twey: that works, thank you :)
11:55:39 <roconnor> :t concatMap (\a -> map (testBit a) [0..bitSize a]) (map char "yokto")
11:55:40 <lambdabot>     No instance for (Bits Doc)
11:55:40 <lambdabot>       arising from a use of `testBit' at <interactive>:1:22-30
11:55:40 <lambdabot>     Possible fix: add an instance declaration for (Bits Doc)
11:55:42 <kmc_> yokto, ^^^
11:55:48 <roconnor> > concatMap (\a -> map (testBit a) [0..bitSize a]) (map char "yokto")
11:55:49 <lambdabot>   No instance for (Data.Bits.Bits Text.PrettyPrint.HughesPJ.Doc)
11:55:49 <lambdabot>    arising f...
11:55:50 <yokto> ok
11:55:59 <yokto> thx
11:56:10 <roconnor> @hoogle char
11:56:11 <kmc_> > map (fromIntegral . fromEnum) "yokto" :: [Word8]
11:56:11 <lambdabot> Text.Parsec.Char char :: Stream s m Char => Char -> ParsecT s u m Char
11:56:11 <lambdabot> Text.ParserCombinators.ReadP char :: Char -> ReadP Char
11:56:11 <lambdabot> Text.PrettyPrint.HughesPJ char :: Char -> Doc
11:56:12 <lambdabot>   [121,111,107,116,111]
11:56:33 <roconnor> @hoogle Char -> Int
11:56:34 <lambdabot> Data.Char digitToInt :: Char -> Int
11:56:34 <lambdabot> Data.Char ord :: Char -> Int
11:56:34 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
11:56:44 <roconnor> @hoogle Int -> Char
11:56:44 <lambdabot> Data.Char chr :: Int -> Char
11:56:44 <lambdabot> Data.Char intToDigit :: Int -> Char
11:56:44 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
11:57:01 <kmc_>  let f = concatMap (\a -> map (testBit a) [0..bitSize a]) in text $ concatMap (show.fromEnum) $ f (map (fromIntegral . fromEnum) "yokto" :: [Word8])
11:57:07 <kmc_> > let f = concatMap (\a -> map (testBit a) [0..bitSize a]) in text $ concatMap (show.fromEnum) $ f (map (fromIntegral . fromEnum) "yokto" :: [Word8])
11:57:08 <lambdabot>   100111100111101100110101100001011100111101100
11:57:12 <roconnor> yokto: better to use Bytestring
11:57:24 <roconnor> @type ByteString.concatMap
11:57:25 <lambdabot> Couldn't find qualified module.
11:57:35 <roconnor> @hoogle ByteString.concatMap
11:57:36 <lambdabot> No results found
11:57:38 <yokto> is this irc actually a haskell interpreter?
11:57:41 <roconnor> @hoogle concatMap
11:57:41 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
11:57:42 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
11:57:42 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
11:57:48 <kmc_> > text "i am a haskell interpreter"
11:57:49 <lambdabot>   i am a haskell interpreter
11:57:53 <kmc_> @vixen are you a haskell interpreter?
11:57:53 <lambdabot> church is my favourite computer scientist.
11:58:37 <kmc_> @vixen what do you think of dependent types?
11:58:38 <lambdabot> any type will due
11:59:21 <dankna> @vixen is this a random thing that pulls from a list of quotes, or do you know the answers to specific questions?
11:59:22 <lambdabot> yeah, i know
11:59:25 <dankna> haha
11:59:33 <m0nkfish> hehe
11:59:35 <kmc_> it's a fairly intelligent chatterbot
11:59:38 <kmc_> @vixen are you a bot?
11:59:39 <lambdabot> no, how dare you ask if i'm a bot!
11:59:42 <m0nkfish> x)
11:59:44 <kmc_> @vixen what are you wearing?
11:59:45 <lambdabot> tanktops and shorts, you?
11:59:45 <c_wraith> seems to pick keywords and respond to them
11:59:46 <dankna> haha nice
11:59:48 <m0nkfish> haha cool
12:00:02 <kmc_> it's supposed to trick teenagers into cybering with her
12:00:03 <m0nkfish> @vixen what's your favourite colour?
12:00:03 <lambdabot> i don't know, what?
12:00:11 <dankna> highly entertaining
12:00:14 <kmc_> @nixon
12:00:14 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
12:00:16 <yokto> does he make it all through the touring test?
12:00:18 <kmc_> @nixon
12:00:19 <lambdabot> I can see clearly now... that I was wrong in not acting more decisively and more forthrightly in dealing with Watergate.
12:00:26 <kmc_> @. vixen nixon
12:00:27 <lambdabot> i forget stuff pretty easily sometimes
12:00:29 <kmc_> @. vixen nixon
12:00:29 <lambdabot> no, i'm not angry at all actually
12:00:33 <kmc_> @. vixen nixon
12:00:34 <lambdabot> Tell me truthfully what the nastiest thing you have ever done.
12:00:42 <sproingie> ew
12:00:57 <kmc_> that's wonderful
12:00:58 <Adamant> @. elite nixon
12:00:58 <lambdabot> ANY ladY W|-|O IS phiR$7 lADY 1IkE$ 8EIng phiR57 l4DY. i D0n'7 C4Re w|-|A7 +h3y say, 7|-|3y LIx3 it.
12:01:53 <dankna> gah
12:02:11 <sproingie> @. elite elite vixen
12:02:12 <lambdabot> viXEN
12:02:16 <sproingie> darg
12:02:23 <kmc_> @. . elite elite vixen
12:02:23 <lambdabot> Plugin `compose' failed with: Unknown command: "3|I+E"
12:02:27 <kmc_> hahaha
12:02:34 <sproingie> that's awesome
12:02:38 <dankna> amusing
12:02:43 <kmc_> just not elite enough...
12:02:49 <kmc_> @. elite nixon
12:02:50 <lambdabot> Y0U |-|4Ve +o phacE Th3 phac+ tHa+ w|-|O1e PrOBLem I5 r34|Ly +h3 b14xx$. Th3 kEY is T0 DIvi$3 a 5y$7e/\/\ THa7 r3C0NIz3$ +|-|is WHILE nOt aPPe4RiN9 7O...
12:03:05 <sproingie> @remember lambdabot <+lambdabot> Plugin `compose' failed with: Unknown command: "3|I+E"
12:03:05 <lambdabot> Done.
12:21:06 <jelly12gen> hi, i am working on a haskell logging bot
12:21:17 <jelly12gen> the only problem i am facing atm is actions in IRC
12:21:39 <kmc_> iirc actions come across as a PRIVMSG with content "\1ACTION bleh"
12:21:48 <jelly12gen> ^AACTION
12:21:53 <jelly12gen> so i tried replacing it
12:21:57 <ksf> why reinvent the wheel, when there's lambdabot?
12:22:06 <jelly12gen> ksf: it does that :o
12:22:19 <jelly12gen> ksf: probaly because coding haskell is nice :)
12:22:38 <ksf> well iirc lambdabot doesn't have a logging plugin.
12:22:46 <kmc_> jelly12gen, can't you pattern-match it?
12:23:04 <ksf> it also doesn't come with a happstack server to serve the logs to the world.
12:23:16 <ksf> so there's ample opportunity to code without duplicating effort.
12:23:36 <jelly12gen> happstack server?
12:24:59 <ksf> http://happstack.com/
12:25:19 <ksf> or, rather, http://tutorial.happstack.com/
12:25:52 <jelly12gen> well i started with rolling your own irc bot
12:26:58 <jelly12gen> the problem is replacing actions
12:26:59 <jelly12gen> Thu Nov 12 21:26:35 CET 2009  freenode-connect: VERSION
12:27:14 <jelly12gen> shows up in vim as ^AVERSION^A
12:27:18 <bsod666> if a have function1 can i do function1 function1 in haskell without any other arguments?
12:27:40 <kmc_> jelly12gen, did you see http://hackage.haskell.org/package/irc
12:27:54 <jelly12gen> kmc_: i didn't
12:28:03 <jelly12gen> i made it all by myself :o
12:28:07 <m0nkfish> bsod666... what?
12:28:26 <lpjhjdh> bsod666: in general you'll get a type error
12:28:27 <bsod666> can i call a function and use it as its own argument?
12:28:40 <m0nkfish> > :t flip flip
12:28:41 <lambdabot>   <no location info>: parse error on input `:'
12:28:41 <bsod666> or will i end up an infinite type error
12:28:45 <copumpkin> bsod666: you asked that yesterday
12:28:48 <m0nkfish> @type flip flip
12:28:49 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:28:55 <m0nkfish> there you go ^_^
12:29:26 <copumpkin> bsod666: why do you ask?
12:29:27 <bsod666> yeah and you simply confused me
12:29:35 <m0nkfish> its a confusing question
12:29:39 <m0nkfish> you "can" do it
12:29:43 <m0nkfish> the real question is why
12:29:59 <copumpkin> bsod666: it's the kind of thing one only does to show things are possible in lambda calculus
12:30:02 <bsod666> can you explain monkfish
12:30:19 <dankna> no, Monkfish is inexplicable
12:30:37 <copumpkin> bsod666: it is possible in certain restricted situations with higher-rank polymorphism
12:30:58 <copumpkin> bsod666: but you should probably learn more haskell before diving in the deep end :)
12:30:59 <bsod666> can you give me an example of such a function
12:31:05 <jelly12gen> kmc_: going to read that :)
12:32:16 <copumpkin> bsod666: well think first about what kinds of arguments you could give to a function that called a function on itself
12:32:17 <m0nkfish> bsod666: flip
12:32:51 <m0nkfish> basically this function needs to take an function as an input and give a function as an output
12:32:53 <bsod666> well im confused as haskell wrks out types by inference
12:33:12 <bsod666> but how can it decide type on func1 func 1
12:33:20 <bsod666> func1 func1
12:33:32 <copumpkin> > id id 5
12:33:33 <lambdabot>   5
12:33:44 <Twey> bsod666: With ease.
12:33:50 <Twey> :t id id
12:33:51 <lambdabot> forall a. a -> a
12:33:55 <Twey> :t id
12:33:56 <lambdabot> forall a. a -> a
12:33:57 <sproingie> if you use its returned value, you'll use it as some type
12:33:58 <m0nkfish> :t flip
12:33:59 <bsod666> surely its infinite? no
12:33:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:34:01 <m0nkfish> :t flip flip
12:34:01 <copumpkin> bsod666: you don't even ned higher-rank polymorphism for that. I thought you were talking about a higher-order function that applies a function to itself
12:34:02 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:34:06 <Twey> bsod666: No
12:34:15 <Twey> bsod666: It's not infinite.
12:34:31 <sproingie> @type fix fix
12:34:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
12:34:33 <lambdabot>     Probable cause: `fix' is applied to too many arguments
12:34:33 <lambdabot>     In the first argument of `fix', namely `fix'
12:34:41 <shepheb> :t const const
12:34:43 <lambdabot> forall a b b1. b1 -> a -> b -> a
12:34:57 <bsod666> can someone give me an example other than id id
12:34:58 <EloquentRaven> is it possible to check a type from within a function (eg can i say if this variables type is null then... else ....)
12:34:58 <Twey> id :: a -> a, therefore (id :: (a -> a) -> (a -> a)) (id :: a -> a) :: a -> a
12:35:06 <McManiaC> how do i remove cabal-packages again?
12:35:06 <Twey> :t const
12:35:07 <lambdabot> forall a b. a -> b -> a
12:35:16 <sproingie> McManiaC: ghc-pkg unregister blah
12:35:45 <Twey> const :: a -> b -> a, therefore (const :: (a -> b -> a) -> b -> (a -> b -> a)) (const :: a -> b -> a) :: b -> a -> b -> a
12:36:04 <Twey> Nothing about it is infinite.  It's solveable just like any other type.
12:36:08 <m0nkfish> bsod how many times
12:36:10 <m0nkfish> :t flip
12:36:11 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:36:11 <m0nkfish> :t flip flip
12:36:13 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:36:23 <copumpkin> :t flip flip flip
12:36:24 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
12:36:28 <m0nkfish> :D
12:36:29 * copumpkin coughs
12:36:31 <sieni> :t flip flip flip flip
12:36:32 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
12:36:36 <m0nkfish> STAP
12:36:42 * copumpkin flips sieni off
12:36:45 * sproingie is dizzy from the flipping
12:36:56 <copumpkin> bsod666: what made you think they'd be infinite? did someone tell you they would be? :o
12:36:57 <sproingie> @pl flip flip flip flip flip
12:36:58 <lambdabot> flip flip flip
12:37:08 <bsod666> i dunno it just sounded cool
12:37:25 <copumpkin> hmm
12:37:28 <m0nkfish> bsod666 are you referring to a function that calls itself
12:37:28 <Polarina> Is there a nice and a simple FastCGI library for Haskell?
12:37:38 <copumpkin> so you just randomly thought "I bet this is infinite! cause infinity is cool!"
12:37:40 <copumpkin> :)
12:37:48 <sproingie> there's a fastcgi package in hackage
12:37:54 <sproingie> happstack does it
12:38:11 <Vanadium> When I say 'id id', the first id has a different type than the second?
12:38:12 <EloquentRaven> i think he means can you call a function with itself as the argument (eg in hugs x x)
12:38:46 <copumpkin> EloquentRaven: you are indeed an eloquent raven!
12:38:52 <copumpkin> I'm impressed
12:39:34 <EloquentRaven> anyway can anyone answer my earlier question
12:39:53 <mauke> 'null' is not a type
12:39:55 <copumpkin> but we already talked about calling functions with themselves as arguments, with const, flip, and id
12:39:55 * hackagebot upload: hesql 0.2 - Haskell's embedded SQL (ChristophBauer)
12:40:03 <EloquentRaven> ah
12:40:19 <shambler> bsod666, http://en.wikipedia.org/wiki/Kleene%E2%80%93Rosser_paradox ! woohoo!
12:40:40 <EloquentRaven> i want to write a function which says if this input is a list then do this if not then do this, is this possible?
12:40:57 <copumpkin> you can sort of do that with a typeclas
12:41:06 <copumpkin> but it isn't a concise definition
12:41:48 <Vanadium> Does typeOf let you do that?
12:41:54 <Twey> Yup
12:42:02 <Twey> You can do it with Data.Dynamic, indeed
12:42:06 <Twey> But think carefully before you do
12:42:38 <copumpkin> EloquentRaven: you should probably try to think of a more idiomatic way of doing it though :)
12:42:54 <mtnviewmark> any Mac OS X Snow Leopard users here?
12:43:06 <mtnviewmark> cabal is dyin' on 10.6!
12:43:21 <lpjhjdh> dynamic only works on monomorphic types I thought
12:43:24 <copumpkin> cabal be dyin!
12:43:45 <mtnviewmark> are you echoing me or is that a warning sign?
12:44:03 <copumpkin> sorry, just feeling stupid
12:44:18 <mtnviewmark> (I like cabal! it is the only community package system that be defaults to installing in ~)
12:44:20 * copumpkin is home with flu and very bored
12:44:40 <voker57> mtnviewmark: gem?
12:45:04 <mtnviewmark> but anyway ---- I can get ghc to work with -optc-m32 -opta-m32 -optl-m32
12:45:11 <jkramer> re
12:45:19 <mtnviewmark> but getting cabal to pass those to ghc is -- well, uneven
12:45:38 <mtnviewmark> works with cabal install --ghc-options="-optc-m32 -opta-m32 -optl-m32"
12:45:47 <copumpkin> oh, people often modify the `which ghc` script
12:45:58 <mtnviewmark> but fails for cabal configure and install --- those commands appear to parse ghc-options, er, diferently
12:46:00 <copumpkin> mtnviewmark: there's also a cabal config file you could stick those options in
12:46:05 <mtnviewmark> er, config or build
12:46:14 <mtnviewmark> copumpkin --- really? I couldn't get it to take it
12:46:34 <copumpkin> but I'd recommend modifying `which ghc` (which is just a one-line shell script anyway)
12:47:02 <mtnviewmark> can't add it to flags:  in .cabal/config
12:47:09 <mtnviewmark> and don't seem to be able to add it to ghc-options
12:47:14 <mtnviewmark> in .cabal/config
12:47:52 <FunctorSalad> @tell dolio that "fast and loose" paper is pretty insightful :)
12:47:52 <lambdabot> Consider it noted.
12:47:58 <RayNbow> > 1e6 -- didn't know this notation was possible in Haskell :p
12:48:00 <lambdabot>   1000000.0
12:48:29 <m0nkfish> is -- a comment in haskell
12:48:37 <skorpan> NO
12:49:05 <c_wraith> By which he means yes
12:49:09 <jkramer> I have little problem with laziness I think
12:49:13 <shambler> @src flip
12:49:13 <lambdabot> flip f x y = f y x
12:49:28 <c_wraith> -- starts a line comment.  It continues until the end of the line
12:49:39 <jkramer> Especially with Haskells laziness :D
12:49:40 <c_wraith> There are other syntaxes for multiline comments
12:49:49 <tommd> {-
12:49:49 <tommd> Like this
12:49:49 <tommd> -}
12:50:11 <jkramer> I'm trying to do something like: writeFile "foo.txt" (someFunction someArgs)
12:50:19 <jkramer> Where someFunction may error out at some point
12:50:43 <jkramer> In which case writeFile leaves an empty file
12:50:45 <tommd> jkramer: So you need Control.Exception.catch?
12:50:53 <FunctorSalad> there are several ways of handling errors in haskell
12:51:08 <jkramer> No, I just want writeFile to open the file for writing before someFunction is fully evaluated
12:51:17 <tommd> You can get text strictly before the write: "let !text = someFunction someArgs"
12:51:30 <FunctorSalad> jkramer: use the lower-level functions
12:51:36 <FunctorSalad> openFile??
12:51:44 <FunctorSalad> err that double '?' was a typo
12:51:49 <FunctorSalad> @hoogle openFile
12:51:49 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
12:51:57 <jkramer> I also tried writeFile "foo.txt" $! (someFunc ...), but it didn't work either
12:52:13 <FunctorSalad> that does the opposite of what you want ;)
12:52:15 <c_wraith> FunctorSalad:  I don't think that's the right approach.  I think the right approach is just forcing evaluation before writing.
12:52:16 <jkramer> Shouldn't $! force someFunc to be solid-head or what it's named?
12:52:24 <c_wraith> it forces it to whnf
12:52:29 <c_wraith> but that's not good enough, for a list.
12:52:42 <c_wraith> It just forces it to determine if there's a first element
12:52:42 <jkramer> Hrm
12:52:46 <FunctorSalad> he wants to open the file first, then evaluate the function, not other way around
12:52:53 <FunctorSalad> I'd just use openFile
12:52:54 <c_wraith> no, he said it backwards
12:52:57 <jkramer> Noooo
12:53:02 <c_wraith> he wants to force the function, then open the file
12:53:09 <jkramer> Don't open the file for writing if there's nothing to write
12:53:35 <c_wraith> force evaluating the length of the result string
12:53:36 <c_wraith> That will force the whole string
12:53:36 <jkramer> The problem is the writeFile opens the file and then someFunc errors out, which leaves an empty file (previous contents lost)
12:53:47 <FunctorSalad> let x = someFunc ... in unless (null x) (writeFile "foo" x)
12:54:01 <c_wraith> FunctorSalad, that fails due to laziness
12:54:11 <c_wraith> He needs to force the length of the result string, not just the head
12:54:18 <kmc_> :t unless
12:54:19 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:54:22 <FunctorSalad> let x = (someFunc ...) `using` rnf in unless (null x) (writeFile "foo" x)
12:54:24 <FunctorSalad> :p
12:54:24 <kmc_> :t when
12:54:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:54:59 <FunctorSalad> rnf is the seldgehammer for this kind of thing
12:55:09 <c_wraith> or....  just force the length
12:55:16 <FunctorSalad> that wouldn't force the chars, would it
12:55:23 <c_wraith> No, but it forces the constructors
12:55:24 <Twey> Also, eww hack
12:55:27 <c_wraith> Which is good enough
12:56:03 <Twey> There's no guarantee that that will cause it to be evaluated, much less stored
12:56:57 <jkramer> http://dpaste.com/119737/ - this seems to work
12:56:58 <c_wraith> do { let {text = blah} ; evaluate $ length text ; writefile "blah" text }
12:57:16 <FunctorSalad> c_wraith: but I don't think "unless" fails due to laziness
12:57:16 * Twey shudders.
12:57:21 <skorpan> jkramer: flip some more
12:57:23 <jkramer> I guess the "all" is the important part that forces evaluation
12:57:29 <FunctorSalad> c_wraith: (fail in not opening the file if there's nothing to write)
12:57:37 <FunctorSalad> Twey: which?
12:57:54 <Twey> c_wraith: That works until some clever compiler decides to store the length of a list behind the scenes for performance purposes.  ☺
12:58:07 <skorpan> also, use more 'when'!
12:58:08 <FunctorSalad> evaluation of the "writeFile" doesn't matter, it must get *executed*
12:58:15 <Confused> sum 2 3
12:58:17 <Twey> FunctorSalad: c_wraith's
12:58:18 <FunctorSalad> and it will only get executed if the condition in the unless succeeds
12:58:27 <FunctorSalad> *fails
12:58:30 <skorpan> when (all enough log) $ getLogFile >>= flip writeFile (show log)
12:59:06 <jkramer> Thats nicer, thanks :)
12:59:15 <Confused> sum [2,3]
12:59:28 <bsod666> :t id
12:59:29 <lambdabot> forall a. a -> a
12:59:35 <jkramer> :i when
12:59:41 <jkramer> Hrm
13:02:42 <Cale> Did everyone else get the "[Haskell] Tabla de calculo de dolares viajero CADIVI" message from the mailing list?
13:02:56 <copumpkin> lol yep
13:03:04 <danderson> @hoogle DiffArray
13:03:05 <lambdabot> Data.Array.Diff type DiffArray = IOToDiffArray IOArray
13:03:05 <copumpkin> I think it was a legitimate mistake from somebody
13:03:05 <lambdabot> Data.Array.Diff data IOToDiffArray a i e
13:03:05 <lambdabot> Data.Array.Diff newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
13:03:08 <c_wraith> FunctorSalad: the condition in the "unless" is insufficient to get failure if the function blows up past the first element
13:03:45 <FunctorSalad> c_wraith: then we understood "nothing to write" differently :)
13:04:04 <FunctorSalad> the cleanest way I guess would be to just use pure error handling
13:04:14 <FunctorSalad> (return a Maybe String)
13:06:21 <ve> where would I find where c_write is defined (looking for something like foreign import unsafe ccall "write")? Somehow can't find it in ghc-6.10 System.Posix.IO docs/source.
13:07:04 <bsod666> can i get a log of this channel so  i can review everything everybodys said?
13:07:09 <mauke> /topic
13:07:14 <bsod666> like over the past week?
13:07:43 <noteventime> Is it possible to use the automatic deriving mechanism without having access to the newtype declaration?
13:07:51 <copumpkin> bsod666: url to logs is in the topic
13:08:02 <copumpkin> http://tunes.org/~nef/logs/haskell/
13:08:39 <noteventime> What I mean is, automatically derive an instance for something you can't change :)
13:12:29 <dpratt71> alright, I'm still on this GADT...journey, and I think I've finally managed to formulate a semi-coherent question...
13:13:06 <kmc_> :)
13:13:09 <dpratt71> I realized that there may be some wrinkle of plain-ol ADTs that previously escaped me...
13:13:16 <FunctorSalad> noteventime: -XStandaloneDeriving
13:13:28 <FunctorSalad> noteventime: as long as the constr is exported
13:13:31 <noteventime> FunctorSalad: Thanks :)
13:13:42 <noteventime> Yea, it's the Product wrapper from Monoid
13:15:54 * dpratt71 thinks that the hardest part of figuring stuff out is formulating a question 
13:16:17 <noteventime> Any particular reason why Product and Sum don't have Num instances?
13:18:09 <FunctorSalad> noteventime: probably not, but you can derive any class for newtypes
13:18:37 <dpratt71> ok, taking this declaration as an example: data Tree a = Leaf a | Node (Tree a) (Tree a)
13:18:46 <noteventime> I know, it's not a problem, just a little weird
13:18:54 <dpratt71> "a" is a type placeholder, of course...
13:18:56 <mtnviewmark> FOUND THE FIX!  (for cabal/ghc on Snow Leopard)
13:19:14 <mtnviewmark> you have to edit the script ghc-6.10.4
13:19:21 <mtnviewmark> in /Library/Frameworks/GHC.framework/Versions/Current/usr/bin
13:19:45 <mtnviewmark> to have  -optc-m32 -opta-m32 -optl-m32
13:20:04 <mtnviewmark> and you have to do that one, no the one in /usr/bin --- because of the maze of twisty symlinks
13:20:05 <dpratt71> if I do: x = Leaf 'C', I believe the type of x will be Tree Char, yes?
13:20:15 <mtnviewmark> form the various flavors of ghc, runghc and runhaskell
13:22:29 <Twey> dpratt71: Yes
13:22:54 <dpratt71> Twey: cool; sorry....for.....the....long....pauses, btw
13:24:04 <Cale> noteventime: No *good* reason.
13:24:17 <Cale> noteventime: It's just something that was apparently overlooked.
13:24:20 <dpratt71> so my next question is: so what? why does it matter that x :: Tree Char? in light of patter matching it seems to only be relevant that x is Leaf Char
13:24:47 <Cale> dpratt71: huh?
13:24:55 <Cale> dpratt71: I'm not sure that I understand your question.
13:25:09 <dpratt71> Cale: that makes two of us :)
13:25:15 <kmc_> Leaf Char is not a type
13:25:18 <Cale> Leaf Char doesn't make sense, because it's something at the value level applied to something at the type level.
13:25:34 <Cale> Leaf is a function a -> Tree a
13:25:37 <Cale> Char is a type
13:25:52 <Cale> These things live in separate worlds and separate namespaces.
13:26:05 <dpratt71> but I'm going to deconstruct x based on its constructor, Leaf, right?
13:26:12 <Cale> Char only exists at compile time, Leaf exists at runtime.
13:26:26 <kmc_> "a" is a type placeholder.  in the data decl, on the LHS it means "put a type here" and on the RHS it means "a *value* of type a goes here"
13:26:38 <Cale> dpratt71: Sure, and what constructors are available is a property of which type x is.
13:26:42 <kmc_> so Leaf 'X'  ::  Tree Char
13:27:13 <kmc_> the point of variants (that is, the "|" in a data decl) is that something of type Tree Char could have been constructed using *ether* Leaf *or* Node
13:27:25 <kmc_> you don't have a type that expresses that it'd be Leaf specifically
13:27:36 <Cale> Perhaps it's just that the syntax for data declarations, which is based loosely on the syntax of context free grammars is confusing.
13:27:48 <Cale> Here's another way to define the same tree type
13:27:50 <kmc_> the GADT syntax is actually less confusing in this respect
13:27:54 <Cale> data Tree a where
13:27:59 <Cale>   Leaf :: a -> Tree a
13:28:08 <Cale>   Node :: Tree a -> Tree a -> Tree a
13:29:15 <Cale> Leaf and Node are values, Tree is a type constructor. They live on different sides of the ::
13:29:20 <kmc_> so there you see explicitly that Leaf and Node are like functions, but different in two respects:
13:29:22 <sproingie> i wish everything used GADT syntax
13:29:25 <kmc_> - you don't give code for them
13:29:30 <dpratt71> alright, let me ask it this way: supposing I have a value :: Tree Char; if I don't have a constructor to deconstruct that value, it might as well be a black box, no?
13:29:31 <kmc_> - you can pattern-match on them
13:29:38 <sproingie> existential types look a lot nicer in GADT syntax too
13:29:42 <Cale> dpratt71: sure.
13:29:53 <kmc_> dpratt71, if you exported Tree from a module, and didn't export Leaf or Node, you'd be in that situation as a user of the module
13:30:07 <kmc_> this is called an "abstract data type"
13:30:16 <Cale> dpratt71: If the constructors have been hidden by a module boundary, and you haven't been provided functions for taking it apart, you're completely out of luck.
13:30:24 <kmc_> (unfortunately the same acronym but not the same concept as "algebraic data type")
13:31:23 <dpratt71> given this, I am sort of not getting the relevance of x :: Tree Char, citing my previous example
13:31:34 <Cale> why do you think that's irrelevant?
13:31:52 <kmc_> well, suppose you *do* have access to those constructors
13:31:54 <Cale> The type system still needs to ensure that when x is passed around, it is used in a consistent fashion.
13:31:58 <kmc_> as you would in the module where you defined them
13:32:00 <dpratt71> Cale: I don't think it's irrelevant; I just don't see the relevance
13:32:11 <kmc_> then, from x :: Tree x, you know that you can pattern match with Leaf and Node
13:32:16 <Cale> dpratt71: Why is it relevant that anything has the type that it does?
13:32:19 <kmc_> :t \(Just x) -> x
13:32:20 <lambdabot> forall t. Maybe t -> t
13:32:33 <kmc_> dpratt71, note that from using "Just" the system inferred that the argument has type "Maybe"
13:32:34 <Cale> dpratt71: It's so that when you eventually use it, the compiler can ensure that you use it correctly.
13:32:38 <kmc_> "Maybe t" that is
13:32:53 <Veinor> @pl find (\x -> not $ x `elem` xs) [0..]
13:32:54 <lambdabot> find (not . (`elem` xs)) [0..]
13:33:22 <Cale> dpratt71: If the module in which Tree is defined doesn't export the constructors Leaf and Node, it probably will export other functions for operating on Tree values.
13:33:26 <Veinor> ah, I keep forgetting about sections :D
13:33:43 <Cale> dpratt71: and those operations still need to be typechecked so that they don't just get passed Strings where they expect Trees.
13:33:59 <Twey> lambdabot: find (`notElem` xs) [0 ..]
13:34:01 <dpratt71> this gets back to GADTs, of course, where (to me) the relevance of how constructor params are mapped to type params seems somewhat arbitrary
13:34:03 <Twey> Er, Veinor
13:34:19 <Veinor> ah
13:34:19 <kmc_> dpratt71, they are arbitrary for the author of the GADT
13:34:30 <kmc_> the point is that you pick them so that *later* they'll help you write some other function
13:34:31 <Veinor> now how do you make that pointless in xs? :P
13:34:38 <kmc_> like "eval" in the GHC docs i linked you to
13:34:49 <kmc_> it's a concept sort of like one use case of phantom types
13:34:50 <Twey> Veinor: (find .) . notElem
13:34:50 <kmc_> but much cleaner
13:35:02 <Twey> Hm
13:35:04 <Twey> Veinor: (find .) . flip notElem
13:35:15 <Twey> Take xs first, then x
13:35:28 <Cale> dpratt71: What programming languages are you most used to outside of Haskell?
13:35:30 <kmc_> :t \f g -> (f .) . g
13:35:31 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
13:35:46 <Twey> Veinor: Or fmap find . flip notElem, if you prefer that
13:35:56 <dpratt71> Cale: C# these days
13:36:33 <Twey> :t (\xs -> find (`notElem` xs))
13:36:33 <Veinor> I like the version that
13:36:34 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe a
13:36:41 <Veinor> 's pointful in xs; it seems more readable to me
13:36:45 <Twey> :t fmap find . flip notElem
13:36:46 <lambdabot>     Couldn't match expected type `a -> Bool'
13:36:46 <lambdabot>            against inferred type `Bool'
13:36:46 <lambdabot>     In the first argument of `flip', namely `notElem'
13:36:49 <Twey> Bah
13:37:32 <dpratt71> from the wiki page on GADTs, there is an example where one of the type constructors of Parser is: Satisfy :: ([tok] -> Bool) -> Parser tok [tok]...
13:37:42 <Veinor> @pl find (not . (`elem` xs)) [0..]
13:37:43 <lambdabot> find (not . (`elem` xs)) [0..]
13:37:49 <Veinor> @pl \xs -> find (not . (`elem` xs)) [0..]
13:37:49 <lambdabot> flip find [0..] . (not .) . flip elem
13:38:00 <Veinor> @pl \xs -> find (`notElem` xs)) [0..]
13:38:00 <lambdabot> (line 1, column 27):
13:38:01 <lambdabot> unexpected ")"
13:38:01 <lambdabot> expecting variable, "(", operator or end of input
13:38:03 <Veinor> @pl \xs -> find (`notElem` xs) [0..]
13:38:04 <lambdabot> flip find [0..] . flip notElem
13:38:14 <yitz> why do lambdabot and preflex have a + next to their name in irssi, but not lunabot?
13:38:14 <Veinor> heh, that works
13:38:22 --- mode: ChanServ set +o mauke
13:38:22 --- mode: mauke set +v lunabot
13:38:30 <Veinor> :D
13:38:34 <Zao> yitz: Voiced.
13:38:44 <Zao> For some hysterical raisin.
13:38:59 <yitz> voiced?
13:39:00 <dpratt71> that the second type parameter should be...pardon my terminology...mapped to "[tok]", rather than "tok" or "(tok, tok)" or...I'm not sure I fully understand the implications
13:39:13 <copumpkin> lunabot is voiced too
13:39:16 <copumpkin> at least over here
13:39:22 <kmc_> dpratt71, the reason is that later you write a function using it
13:39:22 --- mode: mauke set -o mauke
13:39:27 <kmc_> and you want that function's type to work out
13:39:27 <copumpkin> but my IRC client is pretty shitty
13:39:32 <kmc_> look at the example in the GHC docs i linked
13:39:33 <kmc_> it's simpler
13:39:35 <Veinor> copumpkin: mauke just voiced lunabot :P
13:39:38 <copumpkin> oh :)
13:39:45 <kmc_> dpratt71: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
13:40:02 <kmc_> look at the definition of Pair and the eval (Pair e1 e2) clause
13:40:24 <FunctorSalad> dpratt71: for me, the key insight to really understanding GADTs was that pattern matching on a constructor brings a *type equality* into scope
13:40:26 <kmc_> and think about what would happen if you changed the former to Pair :: Term a -> Term b -> Term c
13:40:48 <kmc_> or Term a -> Term b -> Term Char
13:40:57 <FunctorSalad> dpratt71: in fact, you can express all GADTs with just the equality GADT
13:41:07 <FunctorSalad> which is:
13:41:30 <FunctorSalad> data (:=:) a b where Refl :: a :=: b
13:41:31 <dpratt71> FunctorSalad: don't do it! :)
13:41:32 <FunctorSalad> err
13:41:33 <FunctorSalad> data (:=:) a b where Refl :: a :=: a
13:41:34 <Veinor>     (+) (Nimber x) (Nimber y) = Nimber (x `xor` y)
13:41:41 <kmc_> it's like agda :)
13:41:41 <FunctorSalad> dpratt71: what?
13:41:48 <Veinor> is there a 'nicer' way to write that, or do types not work that way?
13:41:56 * dpratt71 head exploded
13:41:58 <copumpkin> oh it's Veinor and his nimbers again
13:42:05 <copumpkin> Veinor: write them in agda
13:42:05 <kmc_> Veinor, nicer how?
13:42:09 <Veinor> :P
13:42:12 <kmc_> what about the types is distressing?
13:42:23 <Veinor> I mean, without going Nimber Nimber Nimber all over the place
13:42:23 <kmc_> it has nothing to do with types, but you can write + infix
13:42:26 * copumpkin whispers "come to the dark side"
13:42:32 <kmc_> Veinor, nope
13:42:34 <Veinor> xD
13:42:39 <kmc_> you have to wrap and unwrap the type
13:42:42 <FunctorSalad> "<dpratt71> this gets back to GADTs, of course, where (to me) the relevance of how constructor params are mapped to type params seems somewhat arbitrary" <-- the params names after the "data Foo" are meaningless for GADTs
13:42:43 <Veinor> figured.
13:42:44 <copumpkin> Veinor: make them applicative
13:42:52 <copumpkin> Veinor: then (+) = liftA2 xor
13:42:56 <Veinor> applicative?
13:43:05 <Axman6> Veinor: you could make it shorter if you had a Functor instance
13:43:08 <Axman6> matbe
13:43:09 <Axman6> y*
13:43:32 <Veinor> ah, yeah, these seem Functor-y
13:43:33 <dpratt71> FunctorSalad: ok, I'll try to accept that :)
13:43:40 <FunctorSalad> is there an tutorial about GADTs via equality?
13:43:50 <Axman6> like, (+) (Nibler x) y = (x `xor`) `fmap) y
13:43:54 <copumpkin> Veinor: instance Applicative Nimber where  (Nimber f) <*> (Nimber y) = Nimber (f x)
13:43:56 <Axman6> or, maybe more confusing
13:44:02 <kmc_> nibbler!
13:44:03 <FunctorSalad> if not, maybe someone should write one
13:44:07 <kmc_> dpratt71, did you look at the GHC example?
13:44:12 <Veinor> nibbler :D
13:44:14 <copumpkin> Veinor: it's obviously also a functor
13:44:16 <Axman6> @src Applicative
13:44:17 <lambdabot> class Functor f => Applicative f where
13:44:17 <lambdabot>     pure  :: a -> f a
13:44:17 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:44:54 <Axman6> copumpkin: i'm not sure it is, i thing the thing in the Nibler is an Int (or some other specific Num type, from previous discussions)
13:45:13 <dpratt71> kmc_: I was scrolled up reading your comments about Pair...
13:45:25 <Veinor> it's an Integer.
13:45:35 <kmc_> okay, cool
13:45:36 <copumpkin> it could be polymorphic, with the Nimber being a type synonym for NimberThingy Integer
13:46:06 <copumpkin> then you could still do liftA2 xor
13:46:31 <bsod666> :reload
13:47:00 <dpratt71> kmc_: so "Pair :: Term a -> Term b -> Term c" would be valid Haskell, yes?
13:47:21 <EloquentRaven> x = 7+13
13:47:35 <dpratt71> how would that affect "eval (Pair e1 e2)"?
13:48:02 <Veinor> also, I think I'm going to use nibler in internal code now, just because I like the sound of it
13:49:48 <yitz> the word "nimber" for nim values was coined by John Conway, I believe.
13:50:36 <m0nkfish> @index Nibler
13:50:36 <lambdabot> bzzt
13:50:47 <m0nkfish> @hoogle Nibler
13:50:47 <lambdabot> No results found
13:50:51 <m0nkfish> :[
13:51:12 <Veinor> yitz: yeah.
13:51:47 <Confused> haskell is confusing
13:52:19 <Veinor> now I just have to figure out how to instance Nimbers into Functor/Applicative
13:52:32 <yitz> Confused: you seem lucid enought to have grabbed that nick, though.
13:52:39 <dpratt71> Confused: I've come to believe that Haskell itself is not confusing; rather I'm confused by everything I learned before Haskell :)
13:52:59 <kmc_> dpratt71, yes it would be correct
13:53:07 <kmc_> now look at the type of eval
13:53:11 <kmc_> Term a -> a
13:53:46 <copumpkin> Confused: maybe it isn't haskell that is confusing you, but your preconceptions that are confusing your ideas about haskell!
13:53:47 <kmc_> with the alternate definition, (Pair e1 e2) :: Term c
13:54:00 <EloquentRaven> Confused: verily the language that tou doth call haskell is a confusing one, but fear not it only gets worse............wait
13:54:02 <Confused> now i am really confused!
13:54:16 <copumpkin> muahahaha
13:54:18 <kmc_> so (eval (Pair e1 e2)) :: c if we are to satisfy the "overall" signature for eval
13:54:25 <kmc_> dpratt71, with me so far?
13:54:48 <yitz> Confused: better reserve the nick "Enlightened" now, you'll need it soon.
13:54:53 <dpratt71> kmc_: not quite there; gimme a minute :)...
13:55:01 <Confused> yitz: I hope so!
13:55:51 <sereven>  @quote ksf confusion
13:56:10 <sereven> ksf says: Confusion is the first step to enlightenment
13:56:31 <yitz> sereven: you seem to have confused lambdabot
13:56:47 <sereven> drop isSpace problems I think
13:56:50 <ksf> is region inference for a turing complete language even decidable?
13:56:56 <Veinor> I need a symbol for something that's like multiplication
13:57:05 <yitz> oh, I see. haha.
13:57:32 <yitz> !*!
13:57:37 <Veinor> haha
13:57:38 <ksf> I'm getting no search results with real info, and everything that's there seems to either leak memory or rely on an additional gc...
13:57:49 <ksf> Veinor, <*>
13:58:15 <Veinor> that'll work, it even looks like the usual symbol
13:58:21 <copumpkin> Veinor: why not (*) ?
13:58:25 <ksf> ...just look at Functor [], it's muliplicative.
13:58:43 <ksf> er applicative.
13:58:45 <ksf> whatever.
13:58:57 <skorpan> ASSOCIATIVE
13:59:04 <copumpkin> ALTERNATIVE!
13:59:12 <yitz> Veinor: <*> is defined in Applicative, ksf means don't define a new symbol, just give it an Applicative instance.
13:59:26 <copumpkin> I've been telling him to give it an applicative instance for hours now!!
13:59:30 <Veinor> :P
13:59:33 <copumpkin> but nobody listens to me :'(
13:59:33 <ksf> :t (<*>)
13:59:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:59:39 <Veinor> because I think I'm going to just use Nimber as an alias for Integer and use alternative addition/multiplication
13:59:46 <dpratt71> gotta run, thanks kmc_, et al
13:59:49 <Veinor> as opposed to making a Nimber data that's in Num
13:59:59 <copumpkin> aliases are a pain
14:00:09 <skorpan> i'm going to make a new typeclass called associative which defines one single associative operator (+)...  the only rule is f + g <==> g + f.
14:00:12 <FunctorSalad> `Nimber'? o_O
14:00:14 <yitz> use a newtype
14:00:19 <copumpkin> skorpan: lol
14:00:25 <FunctorSalad> aliases?
14:00:28 <Veinor> that's what I'm doing right now, making Nimber an instance of Enum
14:00:33 <Veinor> skorpan: except that's commutative :P
14:00:39 <skorpan> Veinor: that's the joke
14:00:42 <FunctorSalad> <copumpkin> but nobody listens to me :'( <-- aww :(
14:00:43 <Veinor> oh, haha
14:00:49 <ksf> skorpan, call it MonoidPlus
14:00:56 <ksf> and have an identity, there.
14:01:01 <ksf> and then do MonoidMult
14:01:02 <copumpkin> <FunctorSalad> <copumpkin> but nobody listens to me :'( <-- aww :( <-- aww :(
14:01:10 <ksf> if you've got both, you should have a field.
14:01:15 <Veinor> but anyway, I don't know how to make Nimber an instance of Applicative
14:01:20 <Veinor> also brb
14:01:21 <yitz> skorpan: make it a Lie algebra
14:01:21 <copumpkin> not quite a field
14:01:24 <dpratt71> perhaps I don't have to run quite yet...kmc_ I think I'm "with you"...sorta
14:01:29 <bsod666> for the horses man!
14:01:30 <skorpan> ksf: nah... that wouldn't be as useful.
14:01:32 <sinelaw> cool, the wikipedia page on trie uses FIRST haskell examples
14:01:42 <sinelaw> before any other language
14:01:48 <copumpkin> yitz: LIES
14:01:52 <CalJohn> ksf: do two monoids actually make a field?
14:01:57 <copumpkin> nope
14:02:06 <sproingie> sinelaw: that just means some haskeller edited it
14:02:10 <skorpan> sinelaw: i think i've seen several articles where that is the case
14:02:13 <ksf> I'm mathematically disabled, sorry, can't tell.
14:02:27 <yitz> @google lie algebra
14:02:28 <lambdabot> http://en.wikipedia.org/wiki/Lie_algebra
14:02:28 <lambdabot> Title: Lie algebra - Wikipedia, the free encyclopedia
14:02:29 <CalJohn> no, they don't, i was wondering why you said that
14:02:29 <kmc_> dpratt71, so given that definition of "eval (Pair e1 e2)", do you see why we need air   :: Term a -> Term b -> Term (a,b)
14:02:30 <sproingie> wikipedia otherwise has no standards for pseudocode
14:02:34 <FunctorSalad> associativity is a kind of commutativity too
14:02:44 <CalJohn> FunctorSalad: ?!
14:02:58 <dpratt71> kmc_: kinda...
14:03:00 <copumpkin> two monoids are closest to a semiring
14:03:11 <kmc_> why would anyone write imperative pseudocode instead of Python?
14:03:21 <copumpkin> but a semiring requires the first be commutative and distributive property between them
14:03:25 <FunctorSalad> CalJohn: in fact, the monad law for "join" expresses associativity as the commutation of two transformation
14:03:31 <skorpan> kmc_: because of TRE
14:03:43 <mtnviewmark> kmc -- cause some of us were around before Python?
14:03:43 <Cale> kmc_: You can gloss over larger details in imperative pseudocode.
14:03:44 <dpratt71> kmc_: I can't argue with the logic; presently it's just hard to see all the implications
14:03:46 <CalJohn> FunctorSalad: ok, i think i need to come to understand category theory soon.
14:03:48 <ksf> why would anyone write python instead of imperative pseudocode that happens to be valid haskell syntax?
14:04:17 <FunctorSalad> CalJohn: of course it's associativity at a different level :)
14:04:32 <FunctorSalad> CalJohn: the law says that the two ways to flatten "m (m (m a))" are equal
14:04:39 <kmc_> you can always gloss over details by calling undefined functions
14:04:43 <kmc_> and commenting what they do
14:04:44 <Cale> For example, details about the set library API
14:05:00 <skorpan> CalJohn: anyone who claims to understand category theory just learned the buzzwords and the rules for putting them next to eachother in the right order
14:05:03 <Cale> It's often nicer just to write things in English or mathematics.
14:05:09 <ksf> ...as seen in http://stllambdalounge.files.wordpress.com/2009/03/post_monads_lambdalounge_talk.pdf , page 8
14:05:41 <ksf> skorpan, isn't that the essence of CT, learning to put them next to each other?
14:05:54 <skorpan> ksf: i don't know, i don't understand CT :P
14:06:27 <FunctorSalad> (I meant this diagram http://upload.wikimedia.org/wikipedia/en/1/14/Monad_mult.png )
14:06:49 <FunctorSalad> I think it is some sort of associativity if you squint the right way ;)
14:07:20 <sinelaw> @type lookup
14:07:21 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:07:24 <Cale> Argh, that talk abuses the word 'monad'!
14:07:46 <Cale> (by referring to values as monads when they are not)
14:07:59 <FunctorSalad> it kinda says that if you quote trice, it doesn't matter whether you first evaluate the inner level or the outer level
14:08:08 <Veinor> back
14:08:16 <ksf> yep, it's the typeclass that's "a monad"
14:08:24 <FunctorSalad> (thinking of the monad as the monad for some algebraic structure)
14:08:28 <yitz> Cale: monad means "cool fancy buzzword" now, didn't you know that?
14:08:36 <Veinor> \o/
14:08:37 <ksf> abstractions without objects to back them up always seem to confuse people.
14:08:57 <sinelaw> @type Id
14:08:58 <lambdabot> Not in scope: data constructor `Id'
14:08:59 <sinelaw> @type ID
14:09:00 <lambdabot> Not in scope: data constructor `ID'
14:09:05 <Cale> The instances of the concept "monad" are at the type level
14:09:11 <andun> 2222778aoeu
14:09:30 <mmmdonuts> "monadic value" is a mouthful, though. Is there a more concise term?
14:09:34 <Cale> andun: encoding fail?
14:09:41 <sinelaw> andun: welcome root, you have mail. /$
14:09:42 * ksf considers a page about "what monads are not"
14:09:51 <mauke> monaddle
14:10:05 <sinelaw> mmmdonuts: monav
14:10:07 <Cale> mmmdonuts: Usually 'action' is appropriate, or 'computation'
14:10:12 <dibblego> I am giving a talk next week titled "What Does Monad Mean?" and I start of with a slide titled "Mythology"
14:10:17 <Cale> (at least in a programming context)
14:10:25 <sproingie> monut
14:10:26 <kmc_> myths: strict, impure, magic, language feature, complicated
14:10:31 <sinelaw> sinelaw but seriously, what Cale said.
14:10:32 <ksf> but having something buzzy for "monadic action" would be nice.
14:10:34 <mmmdonuts> Cale, thx.
14:10:36 <sproingie> monugget
14:10:44 <mmmdonuts> "Who's your monaddy?"
14:10:45 <sinelaw> argg self reference...
14:10:47 <kmc_> mmmdonuts, these days i explain it  as "recipe", at least in IO
14:10:54 <Cale> FunctorSalad: That Monad_mult.png is indeed a kind of associativity diagram.
14:10:58 <ksf> chicken. they can be curried, after all.
14:11:03 <sinelaw> heh
14:11:07 <sproingie> chicken monugget
14:11:15 <kmc_> you can curry any animal
14:11:22 <dpratt71> Cale: the problem with terms like 'action' or 'computation' is that they are *very* overloaded words...
14:11:26 <sinelaw> also rice
14:11:27 <Cale> dpratt71: indeed.
14:11:27 <Veinor> dibblego: you should write something about primordial monads in ancient mythology
14:11:33 <sproingie> curried snail
14:11:35 <FunctorSalad> but monads *are* general
14:11:35 <Veinor> then "oh wait, sorry, that's the other monad"
14:11:44 <FunctorSalad> I don't know anything better than "monadic value" either
14:11:47 <Cale> dpratt71: So when we want to be precise, monadic value is good.
14:11:50 <sinelaw> moniac
14:11:53 <dpratt71> Cale: I know, I know...very intentionally so, right? :)
14:11:55 <FunctorSalad> if it's some algebra monad there is "term" of course :)
14:12:13 <yitz> monadee
14:12:32 <FunctorSalad> monval
14:12:38 <sproingie> nad
14:12:38 <ksf> monad part?
14:12:48 <ksf> is in, all of those actions form a monad.
14:12:48 <sinelaw> money
14:12:54 <FunctorSalad> yitz: too confusing IMHO. it isn't like the value is being made into a monad
14:12:58 <ksf> short mopart.
14:13:02 <sproingie> big monad, no wammies!
14:13:09 <Cale> Yeah, you can say that x :: m a is "in the monad m"
14:13:24 <yitz> FunctorSalad: yeah.
14:13:26 <FunctorSalad> you can say it is being put into the monad, but it doesn't become a monad
14:13:31 <FunctorSalad> ;)
14:13:39 <sunrayser> how do I map a String->String function to a [(String, [String])] if I need to change only the first part of the tuples and leave the second part as is?
14:13:40 * dpratt71 is really leaving this time! no foolin'!
14:13:45 * Cale is motivated to write more about adjunctions.
14:13:56 * ksf reads it mop-art and has some awsome flashs of artists making installations using mops
14:14:19 <Cale> sunrayser: map (\(x,y) -> (f x, y))
14:14:29 <Cale> sunrayser: Or, importing Control.Arrow,  map (first f)
14:14:33 <sinelaw> first
14:14:37 <sinelaw> yeah :)
14:14:38 <sproingie> yay first and second
14:14:48 <mtnviewmark> I've been using the term "in the context of" as in "the funciton foo :: a -> m b computes the value b from the value a in the context of m"
14:14:49 <FunctorSalad> kmc_: what about the empty animal?
14:14:57 <kmc_> that's just curry then
14:14:59 <sproingie> stalking the wild Unit
14:15:16 <ksf> If noone's objecting, I'm going to officialize "mopart" now.
14:15:16 <sunrayser> Cale: I thought of something complex, thanks for pinting me to the simpler direction
14:15:34 <sproingie> Enterprise MonadBean
14:15:37 <sinelaw> do you like your wings flipped, fmapped or joined?
14:15:40 <kmc_> seriously though, we should have this "what monads aren't" page
14:15:48 <CalJohn> skorpan: i don't think category theory is buzzwords in the right order
14:15:54 <mtnviewmark> "mopart"? you're kidding me?
14:16:14 <ksf> no. any "monadic action" is part of what forms a particular monad.
14:16:57 * mtnviewmark is one of the group that thinks Haskell would be MUCH better off without all the mathematical names....
14:17:14 <FunctorSalad> mtnviewmark: has been discussed
14:17:20 * mtnviewmark ducks from all the tomatoes 
14:17:21 <ksf> we need to be intimidating, otherwise we're going to have success.
14:17:23 <mmmdonuts> mobit
14:17:30 <ksf> that's even better.
14:17:31 <mtnviewmark> mo'betta
14:17:45 <Cale> On my blog I want to get at the intuitive idea between the left adjoint sort of posing a problem and the right adjoint being the simplest solution to it, or the right adjoint being a solution, and the left adjoint being the hardest problem that it solves.
14:17:47 <mtnviewmark> "Haskell: It's mo'bettah!"
14:17:48 <FunctorSalad> mathematical names have well-defined meanings
14:17:52 <sinelaw> mtnviewmark, nah. besides, you should be ducking curried chicken wings
14:18:09 <Cale> I think I have a course of articles which should get me there :)
14:18:13 <FunctorSalad> while ad-hoc programming terms often don't
14:18:19 <mtnviewmark> for better or worse, strlen() is C has a well defined meaning too
14:18:19 <mmmdonuts> Haskell programmers have mo'nads.
14:18:24 <ksf> "curried mobits" also sounds like something tasty.
14:18:28 <Daimonic> BONUS seriously, your wombat style is adorable
14:18:37 <FunctorSalad> mtnviewmark: we are talking about concepts, not functions, right?
14:18:40 <newsham> mmmdonuts: what are go's monads called?
14:18:46 <sproingie> not going there
14:18:49 <BONUS> Daimonic: haha :D
14:18:50 <FunctorSalad> (Monoid vs Appendable)
14:18:51 <ksf> blocks, it seems.
14:19:02 <BONUS> i stole it somewhere though. if you google vim wombat i think you get the original author
14:19:04 <newsham> /join #go-nads
14:19:10 <Cale> newsham: It doesn't even have parametric polymorphism, it has no hope of abstracting over monads.
14:19:13 <ksf> and they're limited to IO.
14:19:16 <mtnviewmark> true 'nuf - but I, perhaps like ksf, am trying to explain haskell to people with plenty of programming experience and no formal mathematics since college....
14:19:30 <Cale> If you only have one monad, the fact that it's a monad is completely irrelevant.
14:19:38 <sinelaw> FunctorSalad but the problem could be mixing mathematical concepts with programmatic ones when they are not exactly the same - you can have precise programmatic concepts without sharing names with math
14:19:45 <sproingie> it's the Everything Monad
14:19:54 <sproingie> >> is called ;
14:19:57 <sinelaw> (i don't know if the shared names are really precisely justified, if they are then it's ok)
14:20:00 <kmc_> mtnviewmark, you don't actually need to know any category theory to understand monads in haskell
14:20:05 <FunctorSalad> Cale: either the left or right adjoint can be "optimal solutions" depending on whether you're min'ing or max'ing, no?
14:20:06 <mtnviewmark> but I realize that this one of the ever-swirling debates...
14:20:08 <kmc_> i don't see why the name "monad" is worse than any other random name
14:20:12 <Cale> FunctorSalad: yeah
14:20:16 <Daimonic> BONUS: You got a be kidding me, I told some of my fellow students, you are the great one who gave me this awesome style. We better both forgot what you've said
14:20:19 <newsham> cale: what about    foo() && bar() && blah() ?
14:20:21 <mtnviewmark> true -- but I still ahve to say "Monadic expression"
14:20:24 <kmc_> if it's a totally new concept with a totally new name why do you care that there's an extra unexplored layer?
14:20:37 <BONUS> well i mean like i did propagate it
14:20:39 <Cale> FunctorSalad: There's a connection here between duality in optimisation and duality in category theory :)
14:20:41 <BONUS> and change the original ones :D
14:20:42 <Cale> newsham: huh?
14:20:43 <BONUS> a bit
14:20:48 <BONUS> but i found it here http://dengmao.wordpress.com/2007/01/22/vim-color-scheme-wombat/
14:20:52 <newsham> cale: short circuit evaluation
14:20:56 <Daimonic> yeah so... it's yout wombat style :D
14:21:08 <Cale> newsham: I don't know why you are bringing it up.
14:21:16 <newsham> sorta like Maybe monad
14:21:22 <mtnviewmark> actually - i'm happy with the names, I'm less happy with the normal ways to explain them -- since most of them seem deleriously happy to dip into things like category theory at will
14:21:29 <kmc_> okay
14:21:31 <BONUS> haha well maybe! it doesn't matter whose it is, it's just cool that it's there :D
14:21:36 <newsham> perhaps a little bit of a stretch :)
14:21:44 <Daimonic> *nod*
14:21:45 <kmc_> i thought the usual monad tutorial is not so much category theory as bad analogies
14:21:49 <sinelaw> BONUS what's the one you created for haskell? also for vim?
14:21:58 <kmc_> "a monad is like an invisible train filled with jello travelling backwards in time"
14:22:02 <BONUS> although to be fair, wombat is a modified desert
14:22:03 <Cale> newsham: I guess you can analyse it that way, but that's unsurprising. You can't really say that a programming language supports monads in any way unless you can write code which is polymorphic in the type of monad which it operates.
14:22:04 <FunctorSalad> Cale: can that be made precise?
14:22:14 <FunctorSalad> (adjoints and LP duality)
14:22:14 <Cale> FunctorSalad: I think so.
14:22:20 <mtnviewmark> kmc's description wins
14:22:22 <sinelaw> kmc_ what color jello?
14:22:24 <FunctorSalad> that would be hilarious
14:22:28 <BONUS> i just uhh ported wombat to the SyntaxHighlighter js library so that it can be used on the web
14:22:28 <mtnviewmark> I'm putting THAT in all my slides from now on
14:22:33 <sproingie> i never had the CT underpinnings of monads til Cale took a while to explain them in #haskell-in-depth
14:22:34 <mtnviewmark> w/credit
14:22:34 <Cale> FunctorSalad: But I have to check teh detailz.
14:22:39 <Daimonic> *makes a wombat pose* Wombat Coding Style ...
14:22:41 <Philippa_> mtnviewmark: I'd say "in m", and explain that that's the same way you'd talk about "in C" or "in Java" - it's a way of doing things
14:22:43 <sproingie> no tutorial i've read has ever used CT
14:22:46 <sohum> ok. why on /earth/ do newtypes need a constructor?
14:22:50 <kmc_> sinelaw, ham!
14:22:56 <sinelaw> BONUS if you port it to emacs or yi, notify me
14:23:02 <sproingie> sohum: so you can construct an instance of the newtype
14:23:03 <Cale> sohum: Because how are you supposed to tell what type the values belong to without it?
14:23:04 <BONUS> haha alrighty
14:23:10 <sinelaw> in fact i couldn't find how to change colors in Yi
14:23:15 <kmc_> sohum, to keep them separate from the thing they wrap
14:23:16 <ksf> type Mobit a = Monad m => m a
14:23:18 <sproingie> sohum: there'd otherwise be no way at all to make a new value, since it's not an alias
14:23:32 <kmc_> otherwise, it's a simple alias and gives you no extra type safety
14:23:34 <Daimonic> My tutor wrote this BSc. thesis about crane coding: He proved that foldl is turing complete
14:23:36 <sinelaw> kmc_ i'll stop using monads then. not kosher.
14:23:38 <Daimonic> his*
14:23:48 <sohum> sproingie: type inference! Cale: type checking? kmc_ : why do you need to keep it separate syntactically?
14:23:50 <kmc_> sinelaw, it's ham-colored but made of ponies
14:24:01 <sproingie> my big beef with monad tutorials is they do a crappy job of explaining the State monad
14:24:04 <Cale> sohum: Type inference indeed.
14:24:22 <kmc_> sohum, because what good does it do to say "X is an Int but not fungible with Ints" if it will then inferr the funging for you?
14:24:26 <Cale> sohum: Suppose I define   newtype Foo = MkFoo String
14:24:36 <Cale> sohum: And then somewhere I write   "hello"
14:24:37 <Daimonic> sadly german only: http://page.mi.fu-berlin.de/aneumann/arbeit.pdf
14:24:38 <sinelaw> sohum, you can define type class instances for the newtype, does that require a new constructor? I'm not sure.
14:24:47 <Cale> sohum: what type does that have? Is it String or is it Foo?
14:24:50 <sohum> kmc_: because otherwise you funge it yourself, and it's exactly the same
14:24:59 <FunctorSalad> monads are also often add-on languages for haskell in a way (domain-specific environments in which the rest of the code operates)
14:25:02 <kmc_> sohum, but if you /didn't/ mean to funge it
14:25:04 <kmc_> and it does it for you
14:25:04 <Daimonic> If I can remember rightly, he coded a turing machine with foldl
14:25:07 <kmc_> then you've lost the safety
14:25:12 <sinelaw> kmc_ ponies aren't any more kosher than ham, unless the ponies  that the ham-colored jello is made of, are made of something else
14:25:15 <sproingie> sohum: how can you infer the value of a type you can't construct?
14:25:19 <sohum> Cale: depends on what type that expression needs to be.
14:25:22 <kmc_> they're made of magic ofcourse
14:25:27 <sproingie> er other way around
14:25:33 <Cale> sohum: Every expression *must* have some type
14:25:36 <sproingie> how can you infer the type of a value you can't construct?
14:25:49 <Cale> sohum: So you're saying that it has some kind of union type  Foo + String ?
14:26:08 <sproingie> remember, newtype isn't an alias for an existing type
14:26:16 <Cale> sohum: These have serious issues, not only because they result in combinatorial explosion in the typechecker in some cases.
14:26:25 <sohum> Cale: ConstructableFromString a => a would work, I suppose
14:26:26 <sinelaw> so, monads are like an invisible train filled with jello made of ham-colored ponies that are made of magic, travelling backwards in time.
14:26:36 <sinelaw> kmc_ are there any more important details?
14:26:43 <Cale> sohum: But then we need a new typeclass for absolutely every type.
14:26:53 <sproingie> sinelaw: the ponies are wearing spacesuits
14:26:55 <sohum> Cale: Constructable String a => a
14:26:57 <sproingie> they're space ponies
14:27:12 <Cale> sohum: In any case, this is just not what a newtype is trying to express.
14:27:31 <Cale> sohum: The whole point is that we want values of the newtype *not* to be treated as values of the original type.
14:27:45 <Cale> (it's a *new* type)
14:27:59 <Cale> The implementation of the type is the same as the one for the original type though.
14:28:02 <kmc_> sohum, think of "newtype" as an optimized version of "data"
14:28:07 <kmc_> not as some variant on "type"
14:28:09 <sohum> Cale: I /know/. But my point basically is that you /can/ treat values of the orginal type as values of the newtype, which basically eliminates a lot of boilerplate.
14:28:17 <sproingie> can 'data' ever get optimized that way behind your back?
14:28:30 <sohum> kmc_: heck, I have this issue with data as well, but data has the discrimination problem
14:28:33 <eldragon> is there any good Graph Rewriting System implementation anywhere?
14:28:40 <kmc_> sproingie, maybe if you annotate the field as strict
14:28:48 <Cale> sohum: Forcing that boilerplate is the whole point, because that boilerplate is where things can go wrong.
14:28:52 <kmc_> or it somehow knows you only use it strictl
14:29:03 <Cale> sohum: Especially if it's done in a naive way.
14:29:05 <sinelaw> kmc_ will that deal with the bottom lifting?
14:29:11 <FunctorSalad> you may not *always* want the boilerplate
14:29:15 <sohum> Cale: but as is, you write the boilerplate /twice/. At the type level and at the code level.
14:29:18 <copumpkin> eldragon: if you find one, let me know
14:29:24 <Cale> sohum: Consider something like  newtype Dollars = Dollars Integer  and  newtype Pounds = Pounds Integer
14:29:28 <FunctorSalad> newtype can help already even if polymorphisms sometimes counters them
14:29:33 <eldragon> ok copumpkin
14:29:38 <Cale> sohum: Converting between these two in the trivial way is liable to be incorrect.
14:29:43 <copumpkin> eldragon: it'd be nice if big chunks of GHC could be pulled out without using the entire GHC API
14:29:57 <sohum> I'm not saying you should be able to treat Dollars as Pounds
14:30:04 <Cale> sohum: So that's why we want to enforce that the programmer write the explicit code whenever they want to convert.
14:30:07 <sohum> I'm saying you should be able to treat Integer as Dollars
14:30:13 <sohum> or Integer as Pounds
14:30:17 <Cale> That also could be just as much of a mistake.
14:30:18 <sohum> /only/ that way
14:30:29 <FunctorSalad> sohum: (deriving Num), then
14:30:36 <copumpkin> that seems wrong
14:30:42 <Cale> The Dollars constructor is how you express that "this integer is really a number of Dollars and I mean it."
14:30:47 <sohum> well, presumably only if the type constructor is visible.
14:30:59 <Cale> data constructor, but I know what you mean
14:31:07 <sohum> what's the difference between "Dollars 5" and "5 :: Dollars"?
14:31:14 <kmc_> eldragon, copumpkin: for some things, Hint is a nice simple way to access GHC API
14:31:14 <sohum> right, yeah
14:31:27 <copumpkin> kmc_: not for graph rewriting :)
14:31:42 <Cale> sohum: of course, you can write an instance of Num for Dollars, but that would be at least a bit ill-advised, because multiplying two dollar amounts doesn't make sense.
14:31:45 <copumpkin> sohum: the latter can be implicit if something expects dollars and you pass it a 5
14:31:49 <FunctorSalad> if you abuse IsString enough, "5" can mean *anything* :D
14:32:02 <sohum> copumpkin: my point exactly.
14:32:09 <copumpkin> sohum: and that's a bad thing
14:32:16 <FunctorSalad> but it can really be a typing-saver
14:32:39 <Cale> sohum: What you're asking for goes against how we use types to protect us from making mistakes, basically.
14:32:42 <sohum> what's the difference between centsToDollars :: Integer -> Dollars; centsToDollars x = Dollars (x/100) and centsToDollars x = x/100 ?
14:33:03 <sohum> (ignoring the fractional issue for this purpose)
14:33:08 <copumpkin> what's the difference between x = "1" + 2?
14:33:11 <copumpkin> and x = 1 + 2?
14:33:22 <Twey> One breaks.  ;)
14:33:27 <copumpkin> not in some languages
14:33:34 <Cale> Making automatic conversions is the road to insanity. Look at PHP.
14:33:41 <kmc_> or Perl
14:33:48 <Twey> Or C
14:33:55 <kmc_> the entire point of newtype is to require explicit conversions
14:34:00 <kmc_> if you don't like that, don't use newtype
14:34:03 <kmc_> it's really that simple
14:34:07 <sohum> copumpkin: different things. One is explictly constructed from and only from an Integer, while Strings/Integers are not defined in such a way.
14:34:21 <sohum> and that's an argument from slippery slope
14:34:21 <sinelaw> or C++
14:34:22 <Cale> sohum: Just to check, you are aware that 'type' exists?
14:34:23 <FunctorSalad> you also need newtype for things like the constant functor or identity functor
14:34:31 <sinelaw> or Java
14:34:32 <blackh> Here's a good perl example: In a bank I worked for, they tested a y2k fix... it had the perl string "year" in it (instead of $year)..
14:34:34 <sohum> Cale: yes. sometimes it's not powerful enough.
14:34:35 <FunctorSalad> there the wrapifying is unwanted
14:34:44 <FunctorSalad> it's just required for the typechecker
14:35:03 <sohum> Cale: or should I say, distinct enough.
14:35:18 <blackh> They wound the clock forward to 2000, and it worked.  Then they put it into production, and *bang*.  For some perl reason I don't understand, 'year' resolved to 0, and it didn't work in 1999.
14:35:32 <kmc_> we had a perl program wrapper which worked fine until you wanted to pass "0" as a cmd line argument to your program, because the perl script iterated while($x = shift ARGV) and "0" is false
14:35:51 <kmc_> the solution -- in numerous perl apis -- is to return the string "0 but true" when you want a numerical zero but a boolean true
14:36:04 <Cale> kmc_: ahahaha
14:36:18 <sinelaw> that's bananas
14:36:27 <kmc_> it's funny that people think these kinds of problems are the core issues of software engineering
14:36:36 <sohum> just because unchecked type conversion can lead to a lot of problems, doesn't mean oneway conversion when the newtype is already explicitly defined in terms of the old type and your types are already there and fitting nicely is a bad thing
14:36:42 <Cale> In PHP the strings "" and "0" are false, and 0 is false, as well as 0.0, but "0.0" is true.
14:36:48 <kmc_> and it's funny that the perl designer(s) thought it made the programmer's life *easier* to mudddle "0" and 0
14:37:11 <SimonRC> in bash, 0 is true and every other int is false
14:37:44 <SimonRC> thought that makes sense, since success is boring but failure can happen in many many ways
14:37:45 <FunctorSalad> 0 errors. obvious, isn't it?
14:37:46 <sinelaw> in python, 0 or an empty string or list is false,
14:37:48 <SimonRC> *though
14:37:50 <sohum> kmc_: I'd prefer not to use newtype, as it exists. Is there an equivalent construct that allows me to, say, define separate instances of a typeclass for a type?
14:38:09 <kmc_> no, unfortunately, there are no scoped instances
14:38:15 <kynky> exit 0 is success in many languages?
14:38:16 <kmc_> though you can get a similar effect with implicit parameters
14:38:23 <kmc_> exit 0 is success in UNIX, any language
14:38:36 <MoALTz> kynky: consider returning 0 as saying "no problems"
14:38:36 <mshaw> kmc_: they didn't muddle "0" and 0
14:38:44 <MoALTz> for C anyway...
14:38:53 <watermind> I thought implicit parameters had been deprecated
14:38:58 <mshaw> "", 0, (), "0", undef are all false
14:38:58 <SimonRC> exit("0") ;-)
14:38:59 <kmc_> anyway it seems most programmers think of types as specifying representation rather than specifying correctness
14:39:15 <mshaw> "0 but true" is true because it is none of those.
14:39:16 <kmc_> mshaw, how so?
14:39:21 <sohum> kmc_: is there an equivalent construct that allows me to create recursive structures without the same boilerplate?
14:39:28 <mshaw> it's a string that can't reliably be parsed into a number
14:39:30 <kmc_> SYB?
14:39:34 <sinelaw> SimonRC: vs. exit("0 but true. Hah! fooled u!!!!111!!111")
14:39:41 <kmc_> mshaw, correct
14:39:51 <watermind> kmc_: how do they specify correctness?
14:39:54 <kmc_> but ("0" + 3) and (0 + 3) use 0 and "0" interchangeably
14:40:03 <gwern> 'Suppose you're given an n-bit string, and you're promised that exactly n/4 of the bits are 1, and they're either all in the left half of the string or all in the right half. The problem is to decide which. It's clear that any deterministic algorithm needs to examine at least n/4 + 1 of the bits to solve this problem. On the other hand, a randomized sampling algorithm can solve the problem with certainty after looking at only O(1) bits ...
14:40:08 <kmc_> watermind, by allowing you to specify how your data is allowed to mix, and how it's *not* allowed to mixk
14:40:09 <gwern> ... on average.'
14:40:10 <kmc_> mix*
14:40:12 <gwern> wait what
14:40:21 * gwern is confused. what is scott aaronson saying there?
14:40:49 <SimonRC> sinelaw: I think often just the lowest byte goes back to the OS
14:40:50 <watermind> kmc_: that's kind of the same as specifying representation
14:40:50 <watermind> kmc_: no?
14:40:56 <mtnviewmark> style question.... I realize (and understand) the great dislike of error in Monad
14:40:56 <kmc_> watermind, for example, any XML schema can be encoded as a haskell datatype.  you can then prove at compile time that your program outputs well-formed XML
14:41:01 <Cale> sohum: What is it that you're trying to accomplish? You can certainly write a typeclass which implements these conversions handily. You can also use newtype deriving to effectively write the boilerplate instances of typeclasses on the original type for the newtype.
14:41:03 <SimonRC> so there is a small chance that exit("0") will actually return zero
14:41:07 <SimonRC> but that is very fragile
14:41:11 <SimonRC> in C, that is
14:41:24 <mtnviewmark> however, when I'm coding in a do block under the Either monad --- using return and error seems to read much better than Left and Right
14:41:24 <sproingie> how do you look at O(1) bits?  sounds like mixing levels of abstraction
14:41:28 <FunctorSalad> we don't even need empty stuff coercing to bools, due to pattern matching :D
14:41:36 <sohum> Cale: I'm trying to find ways to reduce boilerplate in Haskell, is all, given that that's the one thing that annoys me most often about it.
14:41:36 <mtnviewmark> (since I'm using them in the manner of Control.Monad.Error)
14:41:41 <FunctorSalad> other languages rely on 'if' for nonstrictness
14:41:43 <sinelaw> yeah, the O(1) there is confusing
14:41:47 <watermind> kmc_: which is because in that case correctness has to do with structure
14:41:50 <kmc_> what i mean is that, when programming an RPG, many C programmers would consider it acceptable to use "int" for level, gold points, and player x position on the screen
14:41:50 <copumpkin> sproingie: by taking a fixed number that doesn't depend on n?
14:41:56 <kmc_> because, hey, they're all integral
14:42:00 <sproingie> O(1) means constant, but that's cold comfort if the constant is 234525632563456734562453456
14:42:04 <Cale> But the whole point of newtype is to prevent you from mixing the things up, and the data constructor/pattern matching are the extra added bit of friction which helps make it hard to screw up.
14:42:10 <kmc_> the compiler represents them all with a 64-bit field and that's good enough for their view of types
14:42:16 <FunctorSalad> not the only point
14:42:27 <sinelaw> sproingie i fail to see how it is constant in this case
14:42:29 <watermind> kmc_: I think that everyone is aware that types can help you with the correctness of your program
14:42:29 <kmc_> but in Haskell we'd rather distinguish them, even though the implementaiton will use the same bit-level representation at runtime
14:42:37 <mtnviewmark> So the question is: Is the hatred of error so great, i should avoid it -- or is it considered "okay" when used with a Monday for which it is known to be safe?
14:42:38 <kmc_> many people are not
14:42:50 <sinelaw> gwern can you explain why it's O(1) for a randomized sampler?
14:43:01 <gwern> sinelaw: no, I can't
14:43:02 <sproingie> a Monday?
14:43:11 <copumpkin> gwern: link?
14:43:16 <SimonRC> sproingie: hehehe
14:43:19 <sinelaw> gwern doesn't make sense
14:43:19 <sohum> Cale: I know, but given that we're only going the way we would have gone in the first place, and only if that intent is already explicitly stated in the type, I see no reason to have to state it again in the code.
14:43:25 <gwern> http://lesswrong.com/lw/vq/the_weighted_majority_algorithm/owv <-- apparently aaronson explaining how O(1) makes sense
14:43:28 <watermind> kmc_: ok, I got your point, and yes of course you're right
14:43:32 <kmc_> most programmers think in terms of "i need a new type iff the representation is different"
14:43:33 <sg> hi
14:43:35 <sproingie> that's what we could call monads
14:43:36 <sinelaw> gwern, THAT doesn't make sense, not you :)
14:43:38 <kmc_> hi sg
14:43:38 <sproingie> Mondays
14:43:42 <watermind> kmc_: yeap agree
14:43:48 <SimonRC> the O(1) is only on average I expect
14:43:49 <Cale> mtnviewmark: You shouldn't use error, use throwError perhaps
14:43:57 <kmc_> interestingly, Issue9's typedef-like thing is more like newtype
14:44:00 <kmc_> i wonder if it will catch on
14:44:04 <SimonRC> the upper bound is still O(n)
14:44:12 <Cale> mtnviewmark: error is for when you want to insist that the thing will not fail, but can't explain that directly in the code.
14:44:21 <mtnviewmark> but - I'm just returning a Left v
14:44:23 <eldragon> copumpkin, i've seen http://rewriting.loria.fr/systems.html
14:44:27 <sproingie> mtnviewmark: error is fine if you know it's defined reasonably, it's just not ideal for fully generic code
14:44:35 <Cale> mtnviewmark: error is not equivalent to Left :)
14:44:40 <idnar> YOU SHALL NOT FAIL! *slams staff against bridge*
14:44:45 <mtnviewmark> right - this isn't generic code - it only works in the Either monad
14:44:52 <kmc_> sproingie, sounds like somebody's got a case of the Mondays!
14:45:02 <Cale> mtnviewmark: Using the Either monad is fine, if that's what you're asking.
14:45:03 <FunctorSalad> ...
14:45:13 <kmc_> partial functions are evil
14:45:18 <mtnviewmark> copumpkin: (after reading scroll back) Fun game: what does    "2" + 2    mean in Java, C, C++, Pythong, Perl, and PHP?
14:45:23 <kmc_> unsafeHead
14:45:25 <kmc_> unsafeFromJust
14:45:29 <sproingie> scala does some nice things wrt partial functions
14:45:29 <mtnviewmark> (surprisingly different answers!)
14:45:36 <Cale> sohum: I guess it's there for the case that you don't write the type signature.
14:45:38 <eldragon> i think that none of them are Graph Rewriting Systems
14:45:44 <Cale> sohum: For me, that's actually fairly often.
14:45:46 <FunctorSalad> you shouldn't use error if you mean to handle the error, especially if you need to handle it from something that isn't IO
14:46:08 <kmc_> Java: "2" + Integer(2).toString() ?
14:46:12 <mtnviewmark> Cale - it is if the type of the function is explicitly in the Either monad, is it not?
14:46:20 <mtnviewmark> well Either String a monad
14:46:27 <kmc_> in C it's pointer arithmetic.   in C++ it depends on what operators you have in scope
14:46:39 <Cale> mtnviewmark: hm?
14:46:47 <kmc_> in Python it's a type error
14:46:56 <SimonRC> but which of the 3 Ps say "4" and which say "22"?
14:47:04 <mtnviewmark> no, in C++ I'm pretty sure you can't overrride that and it is a valid pointer just after the null in the string constant
14:47:11 <kmc_> in Perl it's 4 because + is for ints
14:47:12 <mtnviewmark> in C++, oddly,   "3" + 3   is illegal!
14:47:15 <kmc_> really?
14:47:18 <copumpkin> gwern: that seems reasonable
14:47:24 <sohum> Cale: well, by type signature I also mean the inferred type, I suppose.
14:47:26 <mtnviewmark> (you are allowed to point one unit after the end of an array, but no more!)
14:47:31 <kmc_> you can't define foo operator+(const char* x, int y) ?
14:47:33 <Cale> mtnviewmark: I see no problem with having explicit use of the Either String monad in your code. You might care to generalise it to MonadError or something, but I actually find that type to be nicely expressive.
14:47:38 <gwern> copumpkin: you'll have to explain it to me then :(
14:47:41 <mtnviewmark> (not that any compiler I know of enforces that rule)
14:47:42 <sinelaw> those were the days! http://www.chemeng.ed.ac.uk/people/jack/history/autocodes/
14:47:50 <sinelaw> (the days before my parent were born!)
14:47:57 <sinelaw> *parents
14:47:59 <kmc_> in PHP it's also 4
14:48:15 <sproingie> what about javascript
14:48:16 <sinelaw> nah actually they were in preschool back then
14:48:18 <kmc_> > "2" + 2
14:48:19 <copumpkin> gwern: so you have n/4 one bits and a guarantee that all of them are on one side of the string, right?
14:48:19 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
14:48:19 <lambdabot>    arising from the literal ...
14:48:20 <gwern> copumpkin: you'll have to explain it to me then :(
14:48:22 <gwern> erk
14:48:45 * kmc_ defines instance (Num a) => IsString a
14:49:22 <sproingie> ah yes, JS will stringify anything that's involved with a string in +
14:49:24 <sproingie> not just to the right
14:49:36 <Cale> sohum: The problem with this in-between sort of behaviour is that our type system has no way to express that one thing is naturally isomorphic to another (at least not without more boilerplate), and adding one severely complicates things like type inference and checking.
14:49:51 <sproingie> 3 + "2" => "32"
14:49:54 <kmc_> i always have fun in C++ concatencating std::string and string literals, because it works unless you get two string literals next to each other
14:50:16 <sinelaw> how fun
14:50:17 <copumpkin> gwern: now that you have the guarantee that all of them are on one side, assume you decide to query a bit on the side of the string that does have the one bits. What's the probability that it's a 1 bit?
14:50:20 <Vanadium> If you get two string literals next to each other, you omit the +
14:50:27 <Vanadium> "3" "2" => "32"
14:50:29 <kmc_> yes
14:50:37 <gwern> copumpkin: hm. 1/2
14:50:40 <gwern> right?
14:50:44 <copumpkin> yep
14:50:45 <ddarius> See Frank Atanassow's work, re isomorphisms.
14:50:47 <sproingie> that's just the standard string concatenation that many languages do
14:50:49 <copumpkin> how about if you query on the other side?
14:51:07 <mtnviewmark> actually, I have a Haskell implementation of LLSD, which is a interchange format with these sorts of conversions
14:51:10 <gwern> copumpkin: it'd be 0 chance we get a 1
14:51:38 <mtnviewmark> I have it so that you can write things like       a = (fromLLSD  (toLLSD "42") ) :: Int
14:51:40 <copumpkin> yep
14:51:44 <Vanadium> So does Haskell have anything for multiplexing? Waiting on multiple MVars/reads on handles/Chans at once?
14:52:27 <c_wraith> forkIO and let the RTS handle the details?
14:52:35 * ddarius recommends the CML package on Hackage to Vanadium.
14:53:02 <sohum> Cale: true. my inspiration here is stuff like fromInteger, though, and its implict wrapping of all int literals in ghci. what would be the issue with, say, Constructable a b where construct :: a -> b, and implicitly wrapping that around all literals?
14:53:17 <Vanadium> c_wraith: But say I only want to read from one source :<
14:53:20 <copumpkin> gwern: so now, let's say you don't know what side is which (which is the real problem). You query a random bit on one side and it's a zero, and query another random bit on that side and it's also a zero, what can you (probably) say?
14:53:27 <Vanadium> Do I need to kill the other thread really quick with an async exception? :\
14:53:46 <Cale> sohum: Mainly issues with ambiguous types.
14:53:49 <kmc_> can't you un-take from a TChan?
14:54:04 <copumpkin> gwern: keep in mind that your decision is truly random so an adversary can't lay out bits in such a way that will make it unlikely for you to find a true pattern
14:54:22 <Vanadium> I only played with non-T Chans so far :<
14:54:24 <gwern> hm. I would say... that the odds I could do that if that were the right side were just 1/4, since 1/2 * 1/2
14:54:40 <Vanadium> and the last time I tried to unget on one of those, unget blocked :(
14:54:45 <kmc_> err regular chans maybe as well?
14:54:51 <Cale> sohum: We also have numeric defaulting which in part eases the problem with making integer and fractional literals polymorphic
14:55:03 <gwern> so my confidence would decrease that I'm looking at the winning side; although the exact bayesian update escapes me at the moment
14:55:04 <kmc_> defaulting is a haaaaack
14:55:07 <sohum> Cale: numeric defaulting?
14:55:08 <kmc_> > id
14:55:09 <lambdabot>   {()->()}
14:55:20 <kmc_> :t let x = x in x
14:55:22 <lambdabot> forall t. t
14:55:23 <ddarius> Perhap (readTChan chan1 `orElse` readTChan chan2) may do what you want.
14:55:27 <Vanadium> ddarius: That package sounds pretty interesting
14:55:34 <Cale> sohum: Yeah, like 5 :: (Num a) => a gets defaulted to Integer if its type isn't resolved by the top of the module.
14:55:41 <copumpkin> well, the outcomes are: 0 and 0 on one side (suggests strongly that the 1 bits are on the opposite side), you find a 1 and you're certain what side it is
14:55:44 <Cale> (and it isn't explicitly generalised)
14:56:06 <copumpkin> gwern: all he's talking about is expected number of tries
14:56:19 <copumpkin> gwern: so if your probability is 1/2, you're expected to get a 1 in two tries
14:56:24 <Cale> sohum: It's an awful hack, but it's required in order to not make everything involving integer literals horribly inconvenient.
14:56:56 <Cale> After all, if the user types  2 + 3  in ghci, they definitely do not want an error about the type being ambiguous.
14:57:17 <sinelaw> Cale is that only in ghci?
14:57:27 <sinelaw> or will that hack apply in haskell in general?
14:57:27 <Cale> No, it's also in the middle of a program.
14:57:32 <gwern> copumpkin: hm. but the bits could be laid out unfortunately for our random guesser, giving the same worst-case as a sensible deterministic solver, no?
14:57:35 <sohum> Cale: right. why's this a hack? isn't it reasonable to expect a literal to mean something "by default"?
14:57:37 <sinelaw> Cale, that's ugly
14:57:37 <Cale> Though ghci does it a bit more aggressively by default.
14:58:31 <copumpkin> gwern: certainly, but it's unlikely, and when people talk about expectation it's really just about that. If someone tells you you might win $100 with 50% probability (with no change for the other 50%), people talk about an expected winning of $50 even though that actual amount is impossible to get
14:58:48 <Jackdaw> hi, simple one i think, i have a function f(a,b) and i want to map it over a list but like this f(list_element, b) where b is something else, now i was able to do f(b, list_element) easily enough with currying, but how can i flip the arguments? I could rewrite f but i've already kind of settled on this way around in the rest of my code
14:58:49 <Cale> sohum: By the way, though, what you're asking for wasn't just for literals, because the newtype data constructor might have occurred anywhere in an expression.
14:59:12 <sinelaw> Jackdaw, "flip f"
14:59:17 <Zao> @type flip
14:59:18 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:59:18 <Jackdaw> damn, i new it would be simple
14:59:23 <Cale> sohum: So you're forced to apply that constructible thing throughout the code because the types might not match up at any given point.
14:59:24 <Jackdaw> thanks
14:59:43 <MoALTz> is there an `elem`-like function for monotone increasing sequences?
14:59:56 <sinelaw> @type elem
14:59:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:59:58 <sohum> Cale: well, not necessarily, if Constructable recurses itself. but yea, I see what you mean.
15:00:00 <copumpkin> gwern: it might help to think of it as "because your algorithm is random, no decision your adversary can make will affect the outcome. Run 10000 rounds of this algorithm and count the average number of times it took to get the right answer."
15:00:01 <Cale> sohum: and determining if the resulting set of type equations has a solution is hard (if it has one, it will have many, but if it has none...)
15:00:14 <MoALTz> *infinitely long
15:00:24 <ddarius> MoALTz: You could make one very easily using other library functions.
15:00:26 <gwern> copumpkin: ok, I think I'm starting to understand
15:00:36 <sinelaw> actually expectation is correct in the limit of n -> infinity
15:00:37 <Cale> sohum: Because you've relaxed equality of types to a funny equivalence of types
15:00:37 <MoALTz> so that 5 `elem` [2,4..] fails instead of trying forever
15:00:38 <MoALTz> ok
15:01:08 <copumpkin> gwern: that's all he means by expectation. A few times it will certainly be the case that it'll take maybe even a dozen queries for him to get the right answer, but on average he'll stay around two (because all he needs is to find one 1 to get the right answer, and there's a fairly high chance of finding that)
15:01:12 <sinelaw> @hoogle a -> [a] -> Bool
15:01:12 <Cale> (is it even going to be a proper equivalence relation?)
15:01:13 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
15:01:13 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
15:01:13 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
15:01:27 <Cale> Well, one might hope
15:01:52 <copumpkin> eldragon: thanks for that link by the way :)
15:01:55 <mauke> > 5 `elem` takeWhile (<= 5) [2, 4 ..]
15:01:57 <lambdabot>   False
15:02:07 <sinelaw> mauke, nice :)
15:02:09 <idnar> > let n `monoElem` xs = n `elem` takeWhile (<= n) xs in 5 `monoElem` [2, 4..]
15:02:10 <lambdabot>   False
15:02:12 <idnar> aww, beat me to it
15:02:14 <Zao> > let f x y = x `elem` takeWhile (<x) y in f 5 [0,2..]
15:02:15 <lambdabot>   False
15:02:16 <sohum> Cale: there's some mismatch between what you're thinking and what I'm thinking, but I can't figure out how to articulate it
15:02:17 <MoALTz> yeah just did it that way mauke
15:02:21 <idnar> @pl n `monoElem` xs = n `elem` takeWhile (<= n) xs
15:02:22 <lambdabot> (line 1, column 17):
15:02:22 <lambdabot> unexpected "="
15:02:22 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:02:31 <idnar> @pl \n xs -> n `elem` takeWhile (<= n) xs
15:02:32 <lambdabot> liftM2 (.) elem (takeWhile . flip (<=))
15:02:36 <idnar> yuck
15:02:40 <copumpkin> lol
15:02:51 * ddarius doesn't like that definition.
15:02:55 <sinelaw> liftM2 on (.) always confuses me
15:03:02 <mauke> > let f x y = x `elem` takeWhile (<x) y in f 5 [1,2..]
15:03:04 <lambdabot>   False
15:03:07 <mauke> Zao: fail
15:03:29 <gwern> shoot
15:03:31 <Zao> mauke: Indeed :)
15:03:34 <Zao> mauke: I hoped someone would notice.
15:03:35 <gwern> I just realized my program is wrong
15:03:41 <gwern> and so are all my statistics
15:03:53 <sinelaw> ...since the dawn of time
15:03:54 <copumpkin> oh no
15:03:54 <Zao> gwern: Please say that you've published a paper based on them.
15:03:58 <mauke> and so's the cake
15:04:15 <gwern> Zao: my global warming comrades are going to be unhappy, lemme tell you
15:04:27 <eldragon> copumpkin, Tom could provide the Graph Rewriting System, http://tom.loria.fr/wiki/index.php5/Documentation:Term-Graph_Rewriting
15:04:34 <ddarius> > let monoElem x = foldr (\y b -> x == y || b) False in 5 `monoElem` [2,4..]
15:04:38 <lambdabot>   mueval-core: Time limit exceeded
15:04:38 <idnar> @unpl liftM@ (.)
15:04:39 <lambdabot>  Parse error in expression at end of input
15:04:43 <idnar> @unpl liftM2 (.)
15:04:44 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (\ h -> b (a h)))
15:04:45 <gwern> fortunately, I know the American public is sensible and will take my retraction in the spirit offered, with all due consideration
15:05:05 <idnar> uhm, no
15:05:07 <sinelaw> @type liftM2 (.)
15:05:08 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
15:05:10 <ddarius> > let monoElem x = foldr (\y b -> x == y || y < x && b) False in 5 `monoElem` [2,4..]
15:05:12 <lambdabot>   False
15:05:17 <gwern> idnar: I have faith in the system!
15:05:19 <ddarius> > let monoElem x = foldr (\y b -> x == y || y < x && b) False in 5 `monoElem` [2,4,5]
15:05:20 <idnar> @type (.)
15:05:20 <lambdabot>   True
15:05:21 <sinelaw> that's just fmap?
15:05:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:05:26 <idnar> bah, caleskell doesn't help here
15:05:34 <ddarius> @pl \y b -> x == y || y < x && b
15:05:35 <lambdabot> ap ((.) . (||) . (x ==)) ((&&) . (< x))
15:05:51 <idnar> @liftM2 (.) f x y
15:05:52 <lambdabot> Unknown command, try @list
15:05:54 <idnar> > liftM2 (.) f x y
15:05:56 <lambdabot>   Couldn't match expected type `m (f a)'
15:05:56 <lambdabot>         against inferred type `Simpl...
15:06:04 <Gracenotes> idnar:  :O
15:06:13 <sinelaw> > liftM2 (.) (+1) 2
15:06:15 <lambdabot>   No instance for (GHC.Num.Num ((a -> b) -> f a))
15:06:15 <lambdabot>    arising from the literal...
15:06:29 <BONUS> liftM/A2 (.) is just weird
15:06:42 <sinelaw> i think it's exactly like fmap
15:06:46 <idnar> > liftM2 (.) (+1.0) (+0.5) 10
15:06:47 <lambdabot>   No instance for (GHC.Real.Fractional (b -> b))
15:06:48 <lambdabot>    arising from the literal ...
15:06:58 <idnar> @type liftM2 (.) (+1)
15:07:00 <lambdabot> forall a b (f :: * -> *). (Functor f, Num (a -> b)) => ((a -> b) -> f a) -> (a -> b) -> f b
15:07:10 <idnar> no
15:07:10 <BONUS> however composing liftAn is awesome :D
15:07:12 <idnar> @type liftM2 (.) (+)
15:07:13 <sinelaw> > liftM2 (.) (:[]) 1
15:07:13 <lambdabot> forall b (f :: * -> *). (Functor f, Num b) => (b -> f b) -> b -> f b
15:07:15 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
15:07:22 <BONUS> i love doing that
15:07:26 <idnar> @type liftM2 (.) (+) (+1)
15:07:28 <lambdabot>     Occurs check: cannot construct the infinite type: b = f b
15:07:28 <lambdabot>       Expected type: f b
15:07:28 <lambdabot>       Inferred type: b
15:07:31 <idnar> @type liftM2 (.) (+) (*)
15:07:32 <lambdabot> forall b. (Num b) => b -> b -> b
15:07:34 <sinelaw> @type liftM2 (.) (:[])
15:07:36 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
15:07:36 <lambdabot>     In the second argument of `liftM2', namely `(: [])'
15:07:36 <lambdabot>     In the expression: liftM2 (.) (: [])
15:07:43 <idnar> > liftM2 (.) (+) (*) 5 10
15:07:45 <lambdabot>   55
15:07:52 <idnar> > liftM2 (.) f g x y
15:07:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:07:54 <lambdabot>    `GHC.Show.Show a'
15:07:54 <lambdabot>      a...
15:08:00 <sinelaw> aaaaah
15:08:03 <idnar> nooo
15:08:22 <idnar> @type liftM2 (.) f g x y
15:08:23 <sinelaw> liftM2 (.) f g x = (f.g) x
15:08:23 <lambdabot>     Ambiguous type variable `a' in the constraints:
15:08:24 <lambdabot>       `Show a' arising from a use of `f' at <interactive>:1:11
15:08:24 <lambdabot>       `SimpleReflect.FromExpr a'
15:08:29 <idnar> @type liftM2 (.) f
15:08:31 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, SimpleReflect.FromExpr (m (a -> b)), Monad m) => m (f a) -> m (f b)
15:08:34 <sinelaw> oops, add a y
15:09:21 <BONUS> liftA2 (.) is just basically: give me two applicatives and compose their results, giving an applicative
15:09:21 <idnar> liftM2 (.) f g x y is something like f (g x y) y
15:09:24 <BONUS> still hurts the brain though
15:09:39 <idnar> no
15:09:41 <sinelaw> idnar, no
15:09:42 <idnar> f x (g x y) maybe
15:09:52 <BONUS> > fromJust (liftA2 (.) (Just (+1)) (Just (+3))) 5
15:09:54 <lambdabot>   9
15:09:55 <sinelaw> (f x y) . (g x y)
15:09:59 <sinelaw> i think
15:10:09 <idnar> that doesn't match the types
15:10:21 <sinelaw> @type \f g x y -> (f x y) . (g x y)
15:10:22 <lambdabot> forall t t1 a b (f :: * -> *). (Functor f) => (t -> t1 -> a -> b) -> (t -> t1 -> f a) -> t -> t1 -> f b
15:10:42 <idnar> @type liftM2 ((.) :: (b -> c) -> (a -> b) -> (a -> c))
15:10:44 <sinelaw> @type \f g x y -> liftM2 (.) f g x y
15:10:44 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
15:10:45 <lambdabot> forall a b t t1. (Functor ((->) t), Monad ((->) t1)) => (t1 -> a -> b) -> (t1 -> t -> a) -> t1 -> t -> b
15:11:15 <sinelaw> idnar, right
15:11:25 <BONUS> > liftA2 (.) (+) (*) 3 9 -- this will result in ((3+) . (3*)) 9, which will result in 30
15:11:26 <lambdabot>   30
15:11:39 <idnar> so that's (r -> b -> c) -> (r -> a -> b) -> (r -> a -> c) or something
15:11:40 <sinelaw> it's  (f x) . (g x y)
15:11:58 <copumpkin> > liftA2 f g x y :: Expr
15:12:00 <lambdabot>   Couldn't match expected type `t -> b'
15:12:00 <lambdabot>         against inferred type `Simple...
15:12:11 <idnar> sinelaw: (f x) . (g x) $ y rather?
15:12:23 <BONUS> still, i don't see myself looking at some code and saying: ah that's the old liftA2 (.) trick to pl that thing there
15:12:55 <sinelaw> idnar, that's the same no?
15:13:07 <idnar> > (f x) . (g x y)
15:13:09 <lambdabot>   No instance for (SimpleReflect.FromExpr (f a))
15:13:09 <lambdabot>    arising from a use of `Si...
15:13:27 <sinelaw> @type \f g x y -> (f x) . (g x y)
15:13:29 <lambdabot> forall t t1 a b (f :: * -> *). (Functor f) => (t -> a -> b) -> (t -> t1 -> f a) -> t -> t1 -> f b
15:13:36 <sinelaw> @type \f g x y -> ((f x) . (g x) $ y)
15:13:37 <lambdabot> forall t a b a1. (t -> a -> b) -> (t -> a1 -> a) -> t -> a1 -> b
15:13:46 <lilac> > let monoElem x xs = (LT==) . mconcat $ map (toEnum . (`mod`3) . pred . fromEnum . compare x) xs in monoElem 3 [2,4..]
15:13:48 <lambdabot>   False
15:14:25 <lilac> pity that pred LT is _|_ rather than GT :(
15:14:40 <copumpkin> damn bottoms
15:14:47 <idnar> > let f = (+); g = (*); x = 5; y = 10 in (f x) . (g x) $ y
15:14:49 <lambdabot>   55
15:14:52 <idnar> > let f = (+); g = (*); x = 5; y = 10 in (f x) . (g x y)
15:14:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
15:15:00 <idnar> there we go :P
15:15:12 <idnar> BONUS: no, I don't see that either
15:15:32 <idnar> I see me saying "who the !#%!#% wrote this line noise?"
15:15:42 <BONUS> ya
15:16:11 <BONUS> i wonder if people think (liftA2 . liftA2) (,) take drop 3 "wooooot" is acceptable though
15:16:24 <BONUS> i find that to be quite elegant
15:16:30 <kmc_> :t (liftA2 . liftA2) (,) take drop
15:16:31 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:16:41 <kmc_> :t liftA2 . liftA2
15:16:42 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
15:16:49 <gOcOOl> when the strict version of foldl (i.e. foldl') is called, depending on the context ofcourse, does it evaluate it's arguments to WHNF?
15:17:04 <sinelaw> BONUS may be elegant, but my brain melted.
15:17:05 <kmc_> @src foldl'
15:17:05 <lambdabot> foldl' f a []     = a
15:17:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:17:09 <lilac> gOcOOl: eventually.
15:17:24 <idnar> BONUS: I can almost work that out, I guess
15:17:28 <lilac> gOcOOl: on the assumption that f is left-strict, i think
15:17:36 <idnar> BONUS: it's easier to recognise, anyhow
15:17:45 <BONUS> the trick is in seeing a function that takes two parameters as a nested applicative
15:17:48 <BONUS> yeah
15:18:09 <Saizan_> gOcOOl: the accumulator is evaluated to WHNF at each step
15:18:12 <lilac> BONUS: that's a nice trick. elegant generalization of 'fmap . fmap' to higher arity...
15:18:15 <BONUS> and basically liftA2 . liftA2 is: "takes a function and makes it so it works on f (f a)"
15:18:18 <BONUS> yeah
15:18:21 <kmc_> :t liftA4 . liftA4
15:18:23 <lambdabot> Not in scope: `liftA4'
15:18:23 <lambdabot> Not in scope: `liftA4'
15:18:24 <BONUS> Cale showed me that :D
15:18:29 <kmc_> :t liftA2 . liftA2 . liftA2
15:18:31 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b c (f2 :: * -> *). (Applicative f, Applicative f1, Applicative f2) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
15:18:37 <copumpkin> nice
15:19:08 <copumpkin> I've only ever done that two nestings deep
15:19:15 * copumpkin bows to kmc_'s superior l33tness
15:19:26 <BONUS> > (liftA2.liftA2.liftA2) (,,) take drop find 3 [1,2,3,4,5,6,7,8,9]
15:19:27 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `[a1]'
15:19:33 <BONUS> hmm the what now
15:19:34 <Jackdaw> i have a data type and i want to initialise instances with random things inside, i hoped i could do something like map( Type (take 5 randoms)) where randoms is a list of random numbers but that doesn't seem to work
15:19:48 <Jackdaw> oh and the datatype takes all the same type of things (floats)
15:20:01 <kmc_> copumpkin, i stood on the shoulders of giants
15:20:17 <sinelaw> Jackdaw look at how QuickCheck works
15:20:20 <BONUS> ah yeah find takes a predicate of course
15:21:42 <copumpkin> kmc_: ah, of course
15:21:49 <Saizan_> ?type randoms
15:21:50 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
15:21:52 <Jackdaw> so um this is my first real attempt at haskell,quick check isa bit hard
15:22:09 <Saizan_> Jackdaw: you just need to give a seed to randoms
15:22:27 <Saizan_> > take 5 (randoms (mkStdGen 42))
15:22:28 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
15:22:42 <BONUS> > (liftA3.liftA3) (,,) take drop intersperse 3 [1..9]
15:22:43 <lambdabot>   ([1,2,3],[4,5,6,7,8,9],[1,3,2,3,3,3,4,3,5,3,6,3,7,3,8,3,9])
15:22:54 <jmcarthur_work> YUCK
15:23:01 <copumpkin> BEAUTIFUL
15:23:14 <Jackdaw> thanks Saizan i think i see what you mean
15:23:23 <jmcarthur_work> i see some beauty there
15:23:28 <jmcarthur_work> but it's still horrible
15:23:48 <kmc_> :t randoms
15:23:49 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
15:23:52 <kmc_> :t mkStdGen
15:23:54 <lambdabot> Int -> StdGen
15:23:54 <idnar> it has a kind af elegance, I wouldn't call it beauty
15:24:03 <jmcarthur_work> ditto
15:24:10 <Saizan_> Jackdaw: if you want different results on each invocation of your program you can get a seed from the main action with newStdGen
15:24:11 <kmc_> :t randomRs
15:24:12 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
15:24:13 <copumpkin> that's actually fairly simple
15:24:28 <jmcarthur_work> yeah, you can analyze it a few seconds and see what it does
15:24:33 <lilac> > (liftA2.liftA2.liftA2.liftA2) (,) take drop 3 ["ab", "c", "def", "AB"]
15:24:35 <lambdabot>   [[('a','A'),('a','B'),('b','A'),('b','B')],[('c','A'),('c','B')],[('d','A')...
15:24:39 <kmc_> > take 5 $ randomRs (0,9) $ mkStdGen 42
15:24:41 <lambdabot>   [1,1,7,4,6]
15:24:48 <kmc_> > randomRs (0,9) $ mkStdGen 42
15:24:49 <lambdabot>   [1,1,7,4,6,1,8,1,8,5,5,9,6,8,4,5,7,1,3,6,6,4,2,4,6,4,0,8,3,4,4,5,2,2,6,3,4,...
15:24:55 <kmc_> > randomRs (0,9) $ mkStdGen 43
15:24:56 <lambdabot>   [5,5,9,0,3,1,3,3,7,5,3,4,8,9,6,3,9,0,3,8,9,7,2,1,7,5,7,3,3,2,3,0,5,7,8,5,4,...
15:25:53 <BONUS> lilac: that's awesome
15:26:06 * mwc just discovered that you can scope fixity. Awesome
15:26:08 <kmc_> > map (toEnum . (+97)) $ randomRs (0,25) $ mkStdGen 43 :: String
15:26:09 <lambdabot>   "nnjmpjdxftpeypupfcfivxybjrhnjyvgndijgkniserqpuxbkgimwuafqmpbtlipzolcrkarni...
15:26:35 <idnar> I have no clue what lilac's expression does
15:26:40 <idnar> maybe I should go sleep
15:26:52 <jmcarthur_work> > (take 5 *** take 5) $ randomRs (0,9) *** randomRs (10,19) $ split . mkStdGen $ 42
15:26:52 <mauke> maybe you should Frankerner poesemiformakishness iodoitlestead dunct
15:26:54 <lambdabot>   ([5,8,0,5,5],[18,13,18,16,14])
15:27:54 <lilac> idnar: it's pretty simple really: it drips the flenk smapplers winjelsh 3 woeriwp fwpeormfqpemck wqej lcq2nij3gqj (,) ak12!2r'
15:28:21 <lambdabot> has anyone really been far even as decided to use even go want to do look more like?
15:28:39 <jmcarthur_work> who made lambdabot do that?
15:28:44 <lilac> shush lambdabot, grownups are playing now
15:30:30 <copumpkin>  > map (toEnum . (+97)) $ randomRs (0,25) $ mkStdGen 43 :: String
15:30:33 <lambdabot> "Whoa, is this consciousness?"
15:30:45 <zygoloid> > (liftA2.liftA2.liftA2.liftA2.liftA2) (,) take drop 3 [Just "ab", Just "c", Nothing, Just "AB"]
15:30:46 <lambdabot>   [Just [('a','A'),('a','B'),('b','A'),('b','B')],Just [('c','A'),('c','B')],...
15:31:21 <zygoloid> copumpkin: that was a lucky choice of stdgen seed! :)
15:31:31 <copumpkin> indeed!
15:31:35 <copumpkin> who would've thought
15:32:01 <zygoloid> nbsp after > would have been more elegant :)
15:32:19 <copumpkin> hm?
15:35:07 <Jackdaw> ok so i have plenty of random numbers, but if i have a type like k(a,b,c) and a list [1,2,3] how do i get the list elements into the slots of the constructor
15:35:21 <copumpkin> with pain
15:35:25 <copumpkin> and manual labor
15:35:28 <Jackdaw> really?
15:35:35 <copumpkin> basically
15:35:52 <Jackdaw> ok fair enough
15:35:59 <lilac> f (a:b:c:_) = K a b c
15:36:39 <Jackdaw> thanks lilac, i'll do that, 9 arguments though :(
15:37:19 <mtnviewmark> You have a type that takes 9 values all of the same type?
15:37:24 <Jackdaw> yes
15:37:25 <sinelaw>  >
15:37:28 <mtnviewmark> mmmmmmmatrix?
15:38:13 <copumpkin> Jackdaw: wow, what is it?
15:38:27 <copumpkin> type-level naturals for the win
15:38:53 <Jackdaw> was writing a simple nbody code, so it's x, v, a
15:39:04 <Jackdaw> and yes i guess i should have a proper vector type, but i didn't do that yet
15:39:53 <copumpkin> :o
15:43:24 * jmcarthur_work has never written a function with that many arguments
15:43:37 <copumpkin> I've only done it in agda
15:43:42 <copumpkin> maybe not even
15:43:51 <jmcarthur_work> agda gets kind of ugly sometimes
15:43:59 <copumpkin> yep
15:44:07 <copumpkin> but awesome too
15:44:13 <jmcarthur_work> indeed
15:44:14 <copumpkin> and it gets especially ugly when I write it
15:47:05 <mtnviewmark> many language implementations have a limit at 16 or so arguments -- even if the languages have no such limit
15:48:10 <rickasaurus> as long as they are named and have defaults I don't see any problem :)
15:51:11 <copumpkin> I don't think haksell does
15:51:19 <copumpkin> since all functions have one argument anyway
15:51:25 <kmc_> yeah one is the limit :)
15:51:41 <kmc_> is there a limit to how big you can make a tuple?
15:51:46 <copumpkin> you just get a bit of syntactic sugar to process their arguments at once
15:51:48 <copumpkin> yeah
15:51:52 <copumpkin> I think it's 60-something in ghc
15:51:54 <kmc_> > (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
15:51:55 <lambdabot>   A 75-tuple is too large for GHC
15:51:55 <lambdabot>    (max size is 62)
15:51:55 <lambdabot>    Workaround: use nest...
15:51:59 <kmc_> haha
15:52:07 <sproingie> haskell 98 only requires supporting up to 15-tuples
15:52:08 <kmc_> an unexpectedly helpful message
15:52:40 <mtnviewmark> yes, not the normal "crazy moon poetry" of GHC errors...
15:52:47 <sproingie> oddly the constructor is as big as you want it to be
15:52:49 <kmc_> @quote error
15:52:50 <lambdabot> ghc says: internal error: Invalid object in processHeapClosureForDead
15:52:52 <kmc_> @quote error
15:52:53 <lambdabot> byorgey says: a bus error? try recompiling with -fsubway, perhaps
15:52:58 <sproingie> for example @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:53:01 <copumpkin> @ghc
15:53:03 <lambdabot> ghc says: In a case expression, type of scrutinee does not match patterns
15:53:09 <sproingie> (output way too big to show in channel)
15:53:19 <copumpkin> it won't stop someone from trying
15:53:45 <copumpkin> :O
15:54:05 <kmc_> @ghc
15:54:05 <lambdabot> ghc says: Can't reify a non-Haskell-98 data constructor
15:54:13 <kmc_> @. vixen ghc
15:54:14 <lambdabot> i am just a fun girl!
15:54:17 <kmc_> @. elite ghc
15:54:18 <lambdabot> Gh( $aYz: dSeXPr.dS3xpr: INFINI+e pArAl|eL 4rr4Y!
15:54:29 <copumpkin> lol
15:54:32 <kmc_> @. vixen ghc
15:54:33 <lambdabot> what do you want me to explain?
15:54:36 <kmc_> @. vixen ghc
15:54:37 <lambdabot> what's worth more a flush or a full house?
15:55:00 <sproingie> full house i think
15:55:09 <copumpkin> full horse
15:55:39 <gwern> @hoogle Int -> [a] -> [a]
15:55:40 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:55:40 <lambdabot> Prelude take :: Int -> [a] -> [a]
15:55:40 <lambdabot> Data.List drop :: Int -> [a] -> [a]
15:56:12 <Confused> hey, can you do optional parameters in Haskell?
15:56:23 <kmc_> to functions? no
15:56:33 <Confused> really?
15:56:36 <gwern> tsk, no delete-at-index
15:56:38 <sproingie> all haskell functions only take one argument
15:56:39 <kmc_> yes, i'm not lying
15:56:43 <sproingie> pretty hard to make them optional
15:56:50 <gwern> Confused: they're lying to you
15:56:50 <kmc_> every haskell function takes exactly one argument
15:57:09 <kmc_> you can use type classes to fake them, i'm sure
15:57:12 <sproingie> you model this sort of thing in haskell with pattern matching
15:57:25 <Confused> was reading a blog and apparently it is possible, but was (unsurprisingly) a bit confused
15:57:36 <sproingie> you can fake them to varying degrees
15:57:38 <kmc_> the Haskelly way to do an optional argument would be to define a datatype for the function argument(s), which has some constructors that let you leave out values
15:57:48 <sproingie> the simplest example being Maybe
15:57:58 <kmc_> so e.g. a mandatory int and an optional int might get data T = Both Int Int | One Int
15:58:16 <kmc_> Maybe isn't a great example because you still have to pass something even for zero args
15:58:21 <sproingie> true
15:58:56 <m0nkfish> just pass a list
15:59:02 <m0nkfish> if the list is empty then its empty
15:59:06 <m0nkfish> if it has a thing then it has a thing
15:59:09 <Confused> basically, I want to be able to do: f f, where the second f returns a value, and the first then uses that value
15:59:17 <kmc_> m0nkfish, if your arguments are totally unrelated types, that's bad
15:59:22 <sproingie> Confused: be more specific?
15:59:27 <kmc_> also you lose the safety of bounding the number of args statically
15:59:30 <m0nkfish> kmc: it works :p
15:59:37 <kmc_> another person passing f to itself
15:59:39 <sproingie> Confused: sounds like you want compose
15:59:42 <kmc_> Confused, i think you mean (f . f) ?
16:00:01 <Confused> nah, i trying for f f
16:00:04 <m0nkfish> Confused: what situation
16:00:08 <Confused> ok
16:00:08 <kmc_> which in math is written: f(f)
16:00:09 <sproingie> is f the same function?
16:00:12 <kmc_> is that really want you want?
16:00:12 <m0nkfish> whats the context
16:00:18 <kmc_> or do you want f(f(nothing))
16:00:23 <kmc_> because there's a huge difference
16:00:39 <Confused> running winhugs, I want to do: main> f f
16:00:40 <sproingie> is "the second f" the same function as f?
16:00:45 <Confused> yes
16:00:46 <kmc_> haha, this again
16:00:48 <Confused> same function
16:00:55 <kmc_> Confused, can you explain why?
16:01:01 <Confused> assessment
16:01:04 <sproingie> @src fix
16:01:05 <lambdabot> fix f = let x = f x in x
16:01:12 <Confused> well
16:01:13 <kmc_> as in a test?
16:01:14 <Confused> practical
16:01:16 <Confused> nah
16:01:21 <sproingie> :t id id
16:01:23 <lambdabot> forall a. a -> a
16:01:24 <Draconx> > (id id) $ 5
16:01:25 <lambdabot>   5
16:01:29 <copumpkin> Confused: what practical use do you have for applying a function to itself?
16:01:36 <copumpkin> I'm getting really curious here
16:01:40 <MyCatVerbs> copumpkin: fix. :)
16:01:47 <Draconx> oops, excess parentheses
16:01:52 <copumpkin> I don't count that ;)
16:02:13 <BONUS> don't you mean what use do you have passing a function as a parameter to itself
16:02:15 <sproingie> i've written my own y combinator in other languages, but i'm still mystified at the theory of fix
16:02:23 <kmc_> @src fix
16:02:24 <lambdabot> fix f = let x = f x in x
16:02:24 <MyCatVerbs> > fix (\r x -> if x == 1 then 1 else x * r (x - 1)) 5
16:02:26 <lambdabot>   120
16:02:33 <Confused> I am at uni learning haskall, and we bn asked to research the way to allow a function f to be called and use itself as a parameter. The line we should therefore inout at prompt is: f f
16:02:34 <Cale> BONUS: Isn't that the exact same thing worded differently?
16:02:48 <kmc_> Confused, that means f has to be polymorphic.
16:02:50 <kmc_> do you understand why?
16:02:54 <BONUS> Cale: whoops, you're right :D
16:02:57 <BONUS> yeah, sorry
16:03:13 <copumpkin> Confused: what university? we've had several people asking similar questions recently and I'm just curious :)
16:03:13 <kmc_> if f is monomorphic, with type like A -> B, then its argument has to have type A.  and A is not ever equal to A -> B
16:03:19 <sproingie> must be the same class
16:03:21 <BONUS> > let f = id in f f
16:03:23 <lambdabot>   {()->()}
16:03:26 <Confused> yes I understand
16:03:31 <Confused> Aberdeen, Scotland
16:03:35 <copumpkin> aha
16:03:41 <kmc_> so functions like "id" can be used this way because their type is a "forall" type
16:03:43 <kmc_> :t id
16:03:44 <lambdabot> forall a. a -> a
16:03:47 <kmc_> i.e., polymorphic
16:03:51 <sproingie> vague question is vague
16:03:52 <kmc_> but it's being used at two different types
16:04:00 <MyCatVerbs> > let f = (:[]) in f f <*> ['a']
16:04:01 <lambdabot>   ["a"]
16:04:02 <BONUS> ah, infinite types
16:04:19 <Cale> Yeah, anything of type  forall a. a -> b for a fixed b will work as well.
16:04:33 <Cale> > const 5 (const 5)
16:04:34 <MyCatVerbs> The monkey combinator always makes me desire rum and bananas.
16:04:35 <lambdabot>   5
16:04:41 <copumpkin> ook
16:04:44 <kmc_> :t (:[])
16:04:45 <lambdabot> forall a. a -> [a]
16:04:46 <MyCatVerbs> copumpkin: quite.
16:04:50 <kmc_> monkey with baseball cap
16:04:50 * copumpkin flings poo at MyCatVerbs
16:04:56 <Cale> And then typeclasses muddy the waters further.
16:05:00 <MyCatVerbs> ;-;
16:05:11 <Cale> I'm not sure what the complete answer is if we involve typeclasses.
16:05:11 <kmc_> methinks it's a weird question to ask in a beginning haskell class
16:05:32 <kmc_> hmm, i should steal some bananas from work
16:05:37 <copumpkin> ook
16:05:38 <Cale> > let x = const 5 in x x
16:05:40 <lambdabot>   5
16:05:40 <kmc_> maybe some rum too
16:05:45 <Cale> ^^ that will stop working soon!
16:05:47 <MyCatVerbs> Cale: what? I don't actually believe you.
16:05:48 <Vanadium> oh god i would unsafePerformGetBanana right now
16:05:55 <MyCatVerbs> Cale: you're Cale, you always know the complete answer.
16:06:01 <Cale> MyCatVerbs: hehe
16:06:07 <copumpkin> Cale: is that certain? I thought it was just being proposed
16:06:17 <MyCatVerbs> copumpkin: Yes, it's certain.
16:06:20 <Cale> copumpkin: Well, okay, it will stop working in GHC soon.
16:06:22 <blackdog> has anyone attempted the C10K problem in haskell?
16:06:23 <Vanadium> Why will it stop working?
16:06:28 <copumpkin> :O
16:06:32 <MyCatVerbs> copumpkin: It's in the GHC 6.12 announcement, and I believe that it's in Haskell' too.
16:06:34 <Cale> Vanadium: Because let generalisation is going away
16:06:45 <BONUS> what, this is news to me
16:06:46 <kmc_> but you can write in a signature yes?
16:06:48 <MyCatVerbs> Vanadium: because let bindings won't automatically be made as-general-as-possible anymore.
16:06:49 <Cale> (in the absence of explicit type signatures)
16:06:52 <Cale> yeah
16:06:57 <Vanadium> aw.
16:06:57 <MyCatVerbs> But you can of course write in a signature.
16:06:58 <Confused> ok, think I gonna need to read some more stuff about this now
16:07:01 <Confused> thanks!
16:07:03 <Cale> You'll have to write the signature on explicitly
16:07:06 <BONUS> anyone got a cafe link for this?
16:07:20 <Cale> I heard about it in the middle of a talk.
16:07:25 <MyCatVerbs> Vanadium: It's being changed because let binding generalisation was a real cow to support along with other, more useful type system features.
16:07:50 <BONUS> my first thought at this is: this sucks
16:08:01 <Cale> Though, that's odd. They're only removing the *inference* of general types there
16:08:12 <Cale> Not the ability to give things those types.
16:08:12 <BONUS> but i don't know enough about the rationale behind the decision to have a valid opinion so
16:08:12 <Vanadium> Can I still write let x = const 5 :: forall a. a -> b in x x or whatever?
16:08:17 <kmc_> yes
16:08:25 <copumpkin> I see
16:08:38 <Vanadium> Where do I read that ghc announcement?
16:08:45 <Cale> > let x :: forall a b. (Num b) => a -> b; x = const 5 in x x
16:08:46 <lambdabot>   5
16:08:48 <BONUS> won't this like really hamper GHCi?
16:08:57 <MyCatVerbs> It's just the "what's new in GHC 6.12" accouncement.
16:09:06 <Cale> BONUS: You'll still be able to write the signature explicitly
16:09:40 <BONUS> yeah but still, more typing in ghci
16:09:41 <Vanadium> MyCatVerbs: Yeah but where is it announced?
16:09:41 <BONUS> hmm
16:09:43 <Cale> and it doesn't apply to top-level bindings
16:09:50 <kmc_> :t let map f [] = []; map f (x:xs) = f x : map f xs in f
16:09:52 <Cale> Only to the inside of let/where
16:09:52 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:09:53 <BONUS> oh man this will be a pain to explain in the beginning chapters of lyah
16:09:59 <kmc_> :t let map f [] = []; map f (x:xs) = f x : map f xs in map
16:10:00 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
16:10:08 <kmc_> so after this change, will ^^^^^ change?
16:10:10 <Cale> Yeah, it's awkward, and I don't really care for it either.
16:10:17 <MyCatVerbs> http://www.haskell.org/pipermail/haskell-cafe/2009-June/063681.html is Peyton `Simon` Jones's GHC6.12 announcement.
16:10:21 <copumpkin> what's the rationale?
16:10:22 <Cale> kmc_: Good question...
16:10:35 <Confused> ok, I understand the idea behind polumorphism, and can see some places where is would work, but as yet, am unsure how to implement something that can jst be called with f f
16:10:39 <MyCatVerbs> Er, I have a distinct feeling that I was wrong on that count, and it's actually going away in GHC 6.14 or later instead.
16:10:53 <kmc_> > let f x = x in f f
16:10:54 <lambdabot>   {()->()}
16:10:56 <kmc_> Confused, ^^^^
16:11:01 <kmc_> :t let f x = x in f f
16:11:03 <lambdabot> forall t. t -> t
16:11:05 <Confused> thanks
16:11:05 <copumpkin> MyCatVerbs: interesting infix choice there
16:11:07 <MyCatVerbs> Confused: well, if f doesn't care at all about what type its parameter has then there won't be a problem.
16:11:07 <kmc_> :t let f x = x in f f f f f f
16:11:09 <lambdabot> forall t. t -> t
16:11:25 <MyCatVerbs> Confused: It's a lame joke that I refuse to let go of, ever. :)
16:11:26 <kmc_> :t let f _ = "bleh" in f f f f f f
16:11:28 <lambdabot>     Couldn't match expected type `(t1 -> [Char])
16:11:28 <lambdabot>                                   -> (t2 -> [Char])
16:11:28 <lambdabot>                                   -> (t3 -> [Char])
16:11:37 <copumpkin> fail
16:11:40 <kmc_> :(
16:11:43 <Vanadium> :t let f x = x in fix f
16:11:44 <lambdabot> forall a. a
16:11:45 <kmc_> @nixon
16:11:46 <MyCatVerbs> Er, that last statement was meant to be directed at copumpkin. :/
16:11:46 <lambdabot> Your boys will be home for Christmas.
16:11:51 <kmc_> @. elite nixon
16:11:53 <lambdabot> A /\/\An is NOt FINI5heD \/\/HeN hE Is DefE4Ted. h3 Iz phiNi5H3D \/\/HeN |-|3 quITz.
16:12:00 <Confused> yes, well, f still cares ;)
16:12:04 <Confused> for now anyways :P
16:12:11 <copumpkin> :)
16:12:15 <BONUS> people complain enough with not being able to define types and typeclasses inside ghci
16:12:55 <BONUS> i wonder how they'll handle type inference being hampered for functions defined inside ghci
16:13:01 <kmc_> @protontorpedo
16:13:02 <lambdabot> why is haskell bette than java? java has a shitload of frameworks. its xrazy
16:13:03 <MyCatVerbs> copumpkin: I did actually tell that to P `S` J once, but he didn't find it amusing.
16:13:04 <Cale> Trac ought to have a feature to sort bugs by number of people on the cc list.
16:13:16 * SimonRC goes to bed
16:13:20 <copumpkin> MyCatVerbs: as in, distinctly unamusing, or just didn't find it very funny?
16:13:26 <MyCatVerbs> copumpkin: The way he reacted, I think he thought that it was a type error to try to use Simon as a function. :)
16:13:31 <copumpkin> lol
16:13:38 <copumpkin> well it clearly is
16:14:06 <sjanssen> BONUS: GHC has lots of special magic for GHCI, perhaps they'll treat let bindings at the interpreter specially?
16:14:07 <MyCatVerbs> Like he kind of... well, didn't find it very funny because I think (rather than the joke going over his head (oh no no no) or the joke being beneath him) he kind of sailed right around it.
16:14:23 <BONUS> sjanssen: i hope so
16:14:26 <Cale> oh, it does
16:14:30 <MyCatVerbs> copumpkin: Dunno, maybe Simon is actually an Arrow? :)
16:14:41 <copumpkin> MyCatVerbs: Peyton and Jones are clearly separate nullary constructors of an instance of Num, which is how they get subtracted from one another, and Simon is a unary data constructor, not binary
16:15:05 <Cale> Heh, two of the top 3 issues by cc list length are marked milestone _|_
16:15:06 <kmc_> Simon $ Peyton-Jones
16:15:14 <copumpkin> that's it
16:15:21 <BONUS> but still, agh, this is gonna be annoying. i for one really like writing polymorphic helper functions
16:15:33 <copumpkin> I think you can still define them at the top level
16:15:34 <kmc_> does it apply to "where" too?
16:15:42 <copumpkin> where is just let in disguise
16:15:46 <kmc_> i tend to define helpers in "where", and i wouldn't mind too much giving a sig
16:15:47 <Cale> kmc_: If it doesn't, I will be quite surprised.
16:15:49 <Vanadium> Cale: How do you sort it that way?
16:15:59 <Cale> http://hackage.haskell.org/trac/ghc/report/17
16:16:01 <BONUS> yeah but then you're messing up the top level namespace
16:16:34 <Cale> The ordering of those tickets is not surprising to me at all.
16:16:47 <Cale> Though I would have expected #3 to be #2
16:17:04 <copumpkin> I'd like a serious revamp of modules in general, not just easy recursively dependent modules
16:17:17 <copumpkin> parametrized modules, multiple modules per file, etc. :P
16:17:18 <Vanadium> I am surprised that #3 is such a big deal
16:17:29 <Cale> The newtypes and type families thing is really dumb.
16:17:40 <BONUS> Cale: in what way
16:17:55 <Cale> It's just someone interpreted the rules described in the paper incorrectly.
16:17:59 <kmc_> #1496 is scary
16:18:19 <copumpkin> Cale: yeah, I'm not sure how making ~ not "see through" newtypes is controversial at all
16:18:20 <Cale> (when implementing it)
16:18:30 <Cale> copumpkin: right.
16:18:32 <kmc_> it might hide optimizations?
16:18:40 <kmc_> it seems like we need two relations
16:18:47 <kmc_> one for type equality and one for representation equality
16:19:18 <Cale> In this case, it's intended to be type equality, but for some ridiculous reason ends up being representation equality.
16:19:23 <Confused> kmc_: how would you use "let f x = x in f f" in Haskell. I know I must sound pretty stupid here, but I just can't quite see how its all meant to come together.
16:19:33 <kmc_> what do you mean how would you use it?
16:19:33 <copumpkin> what puzzles me is how it's stayed open so long :)
16:19:43 <kmc_> like, what is it good for?
16:19:47 <Cale> Confused: You mainly wouldn't. It's not useful. The question is mostly a puzzle.
16:19:48 <BONUS> Confused: you would never use it except as an academic exercise or whatever
16:19:49 <kmc_> it's not good for anything.  f f is the same as f there
16:19:54 <BONUS> agh, beaten
16:20:01 * copumpkin beats BONUS
16:20:02 <Confused> I got to add all functions to a .hs file
16:20:05 <kmc_> how would you use it syntactically? that's a haskell expression.  you can put it anywhere a haskell expression is expected
16:20:07 <BONUS> noo
16:20:17 <copumpkin> with a pink unicorn
16:20:20 <Confused> so I can load it into winhugs
16:20:30 <BONUS> or like how would you use it, for good or for evil. well that depends on your moral type system
16:20:33 <Confused> then say f f and get back something not an error
16:20:55 <Cale> Confused: put  f x = x  in your file
16:21:02 <Confused> ok
16:21:34 <BONUS> or f = const 5. doing f x = x and then doing f f will make hugs complain at you that it doesn't have a Show instance for a -> a
16:21:37 <Confused> only, everything I ever write in a function starts with something like "f :: Int -> Bool" etc
16:21:59 <BONUS> that's a type signature. just do f :: a -> a (if you're doing f x = x)
16:22:14 <BONUS> or f :: a -> String (if you're oding say f = const "haha")
16:22:39 <Confused> ok
16:23:41 <Confused> f :: a -> String <lb>
16:23:42 <Confused> let f x = x in f f <lb>
16:23:42 <Confused> f x = "ha"
16:23:43 <Cale> Confused: Haskell doesn't require you to write type signatures yourself though. If you leave them out, they will usually be inferred by the implementation.
16:23:50 <Confused> <lb> = line break
16:23:52 <BONUS> regarding that let thing: so in the future, the code let l = foldr (const (+1)) 0 in (l "hey", l [1,2,3]) won't be valid?
16:24:07 <Cale> Confused: There's no way those 3 lines make sense in the same place
16:24:15 <BONUS> Confused: do f :: a -> String and then f = const "haha"
16:24:22 <Confused> ok
16:24:39 <Cale> Confused: f :: a -> String is a declaration (a type declaration), and f x = "ha" is a declaration (a function declaration), but let f x = x in f f is an expression
16:25:02 <Confused> oh.....
16:25:07 <BONUS> Confused: a question, which year of uni are you? (i have a friend who's at aberdeen and i'm interested as to when/if she'll have mandatory haskell)
16:25:13 <Cale> Confused: declarations serve to define new things, expressions denote values
16:25:15 <Confused> 4th
16:25:24 <BONUS> ah
16:25:32 <Confused> so that would explain the syntax error thing
16:25:42 <Confused> BONUS: what year is ur friend in?
16:25:54 <Cale> Confused: Yeah, you could write  g = let f x = x in f f
16:25:55 <BONUS> i think 2nd
16:26:21 <Cale> Confused: and that would define g as being a name for that value
16:26:22 <Confused> really? got a first name? I mentored some 1st years last year
16:26:28 <Confused> I see
16:27:42 <bsod666> hey can someone help me with a user error in haskell
16:28:00 <Axman6> not without code and info we can't
16:28:10 <Cale> :)
16:28:29 <Axman6> @where help
16:28:30 <lambdabot> I know nothing about help.
16:28:42 <Cale> haha
16:28:53 <Axman6> @where+ help Got the code? Got the info? Then we've got the help for you!
16:28:54 <lambdabot> I will never forget.
16:28:57 <Axman6> @where help
16:28:58 <lambdabot> Got the code? Got the info? Then we've got the help for you!
16:29:39 <ksf> how do I do inline monospaced text on the wiki?
16:30:01 <bsod666> i get a user Program  error:user error (preludeIO.readio: no pase)
16:30:21 <Axman6> bsod666: do you have the code for us or not?
16:30:30 <Confused> so is the function expandable?
16:30:46 <bsod666> basically the code runs but only if you run that function first
16:30:49 <Confused> ie: for every f i type, there is anextra "ha" added
16:31:04 <Axman6> bsod666: can we see the code please, or no one can help you
16:31:22 <BONUS> Confused: well yeah but then it becomes less polymorphic
16:31:51 <BONUS> and it has to have an edge case if you're not using fix, so uhh, well, nah :D
16:31:52 <copumpkin> Confused: do you know bsod666?
16:32:03 <BONUS> :t (++"ha")
16:32:04 <lambdabot> [Char] -> [Char]
16:32:08 <bsod666> lol same ip
16:32:14 <copumpkin> hence the question :)
16:32:15 * bos spends yet more time fighting with the inliner
16:32:20 <BONUS> > let f = (++"ha") in f (f (f (f (f ""))))
16:32:20 <bsod666> i guess he does
16:32:22 <lambdabot>   "hahahahaha"
16:32:30 <Confused> maybe :P
16:32:31 * copumpkin cheers bos on
16:32:37 <Confused> ah ok
16:32:48 <BONUS> but notice there's f ""
16:32:50 <Confused> but I couldn't just do f f f
16:32:58 <BONUS> i don't know how you could do f f f that would return, like "hahaha"
16:33:01 <Confused> ach nm
16:33:01 <bos> by adding/removing one INLINE pragma, i can make fused code fast and unfused code slow, or fused code stop fusing and unfused code fast.
16:33:13 <bos> this is making me nuts.
16:33:37 <BONUS> i have a feeling you can't, but never say "can't" twice in this channel. otherwise Oleg or someone comes along and proves you wrong
16:33:40 * bos throws the 6.10 unliner under a bus.
16:33:48 <bos> unliner. inliner. all the same to me.
16:33:53 <BONUS> haha
16:33:56 <dolio> bos: Was marking a recursive function INLINE ever a good idea?
16:34:01 <Vanadium> What is fused code?
16:34:08 <bos> dolio: these aren't recursive functions!
16:34:13 <dolio> Oh. :)
16:34:22 <Vanadium> Is this the thing where you iterate over a list but you are not paying attention to the list and then the compiler takes the list away and you do not even notice?
16:34:31 <copumpkin> Vanadium: when you compile code on a machine with bad cooling, and it gets so hot that it fuses together
16:34:32 <bos> Vanadium: more or less, yes
16:34:37 <copumpkin> oh, or that too
16:35:32 <Vanadium> Is there a way to see whether my code, uh, fuses, short of inspecting the raw compiler output?
16:36:37 <bos> Vanadium: yes, you can look at simplifier output
16:36:56 <bos> Vanadium: but most code won't be fused unless you're using specific libraries or patterns of traversal.
16:37:19 <Vanadium> aw
16:38:00 <eldragon> copumpkin, http://www.info.uni-karlsruhe.de/software/grgen/ is another GRS but written in awful C#/Java.
16:38:10 <copumpkin> oh, I love awful C#/Java
16:38:47 <Vanadium> Oh, neat, Karlsruhe.
16:38:50 <BONUS> Dune time, later y'all
16:38:55 <lament> is C#/Java the new C/C++?
16:39:03 <JohnnyL> BONUS game or movie?
16:39:04 <BONUS> lol
16:39:09 <jasonmay> or book?
16:39:11 <BONUS> JohnnyL: book :]
16:39:13 <JohnnyL> ah ok
16:39:30 <Cale> The books are much better, just stick with the ones by Frank
16:39:30 <copumpkin> eldragon: the only solution is for you to write a beautiful, performant, idiomatic, abstract and general graph rewriting system in haskell
16:39:32 <JohnnyL> lots of pointy things in the movies.
16:39:37 <BONUS> ya, so i've heard
16:39:40 <eldragon> there are some extincted/obsolete GRSs as PROGRES, Optimix, etc.
16:39:59 <Confused> Guys, I owe you big time
16:40:04 <Confused> thanks for this
16:40:10 <JohnnyL> there yeah is 13,492 in the system Karakas. And amoungst their chief weoponry are knifes....
16:40:22 <JohnnyL> ... 'and a rutheless devotion to the pope'.
16:40:34 <eldragon> copumpkin, i want GRS made in either C, C++, Pascal or Ada.
16:40:59 <Axman6> Ada++
16:41:21 <eldragon> providing an API for graph reduction
16:41:56 <bsod666> compumpkin: im using readLn
16:42:25 <bsod666> copumpkin: the function works if i call it first
16:42:51 <copumpkin> eldragon: why not haskell?
16:42:59 <bsod666> copumpkin: if i call it after a function it fails with that error ..no parse
16:43:11 <copumpkin> bsod666: huh? code
16:43:11 <Cale> So, if C and D are preorder categories, and F: C <- D is left adjoint to G: C -> D, then we have that GX maximises F subject to the constraint that F(GX) <= X, and dually, that FY minimises G subject to Y <= G(FY)
16:43:30 <eldragon> because Haskell has its exagerated complexities
16:43:40 <copumpkin> :o
16:43:52 <copumpkin> Cale: what's that in response to?
16:43:56 <Cale> Nothing :)
16:44:36 <Cale> But I'm thinking about a way to make the connection to duality in LP a little closer.
16:45:04 <rickasaurus> what's your favorite CUFP video?
16:45:18 <Cale> I think it would be really delicious to see linear programming duality where you're taking the transpose (also: adjoint) as an example of an adjunction. :)
16:45:33 * CalJohn wishes he could get an internship with a CUFP company...
16:45:53 <copumpkin> Cale: hmm, now I'm curious
16:45:58 <eldragon> i'm looking for hard it
16:46:19 <rickasaurus> CalJohn, the best way to do that would probably be to just go to the conf and meet people
16:46:33 <pkrumins> Hi guys. Could anyone help me understand the type definition of foldr? It's `foldr :: (a -> b -> b) -> b -> [a] -> b`. I understand what foldr does, but I can't figure out what it does from its type definition. What is the correct way to reason of this type?
16:46:35 <pkrumins> If I write `foldr f v xs`, then it seems that (a -> b -> b) is type of f, b is type of v and [a] is type of xs. and the last b seems the return type of foldr. But why is f of type (a -> b -> b) and not (a -> a -> a)? For example, in `sum = foldr (+) 0` the (+) is of type `a -> a -> a` and not `a -> b -> b`.
16:46:57 <Cale> pkrumins: foldr (:) []
16:47:00 <copumpkin> pkrumins: the a and b just mean they _can_ be different, not that they must be
16:47:01 <CalJohn> rickasaurus: yes, that would be lovely, except that I can't afford to travel
16:47:19 <pkrumins> copumpkin, ok i see. i am not processing what Cale's example.
16:47:28 <pkrumins> s/not/now/
16:48:00 <Cale> pkrumins: You can see foldr f z as replacing each (:) in a list with f, and the [] at the end with z
16:48:24 <copumpkin> > foldr f z [a, b, c, d]
16:48:26 <lambdabot>   f a (f b (f c (f d z)))
16:48:27 <Cale> So, if we replace (:) with (:) and [] with [], it should be the identity function
16:48:35 <Cale> (:) :: a -> [a] -> [a]
16:48:46 <pkrumins> Oh I see.
16:49:03 <McManiaC> can anyone help me with Network.Curl? If i set "CurlPostFields ["foo=" ++ content]" and content contains any & not the whole content gets posted… I tried to map HSP.XML.PCDATA (escape) over the list but without success :(
16:49:10 <pkrumins> a = a, and b = [a]
16:49:18 <Cale> pkrumins: in that case, yes :)
16:49:57 <copumpkin> pkrumins: it also helps to relabel one's type variables sometimes :P
16:50:06 <mauke> .oO( sub foldr { my ($f, $z, $xs) = @_; null $xs ? $z : $f->(head($xs), foldr($f, $z, tail $xs)) } )
16:50:16 <Cale> In general, the second parameter of f will need to have the same type as z, because foldr f z [x] = f x (foldr f z []) = f x z
16:50:37 <Vanadium> why is mauke taking so many $ sections
16:50:44 <Cale> and clearly, from this example, the first parameter of f must have the same type as the elements of the list
16:51:08 <Cale> So you can think of foldr as replacing the constructors which build up the list, so that we now build up a structure of possibly some other type b
16:51:13 <mauke> Vanadium: http://mauke.ath.cx/stuff/c/yes.c
16:51:34 <Vanadium> my goodness
16:52:37 <pkrumins> Cale, good points! thanks!
16:54:15 <ksf> http://haskell.org/haskellwiki/What_a_Monad_is_not
16:54:36 <copumpkin> Monads are so last year, http://www.ams.org/notices/200406/what-is.pdf are where it's at
16:54:38 <ksf> that's merely a quick+dirty braindump, please contribute, enhance, delete etc.
16:55:10 <pkrumins> Operads
16:55:28 <mauke> safarids?
16:55:28 <Vanadium> Hm, I did not realise addition and multiplication are literally monoids
16:55:37 <copumpkin> lol
16:55:38 <Cale> copumpkin: Functional programming and higher-dimensional category theory are on a collision course.
16:55:44 <copumpkin> Cale: yay
16:55:56 <copumpkin> soon we'll need multi/ncategory-extras
16:55:56 <MyCatVerbs> Vanadium: Groups, too. (Except for 0 in the latter case). :)
16:56:12 <MyCatVerbs> copumpkin: we already do.
16:56:26 <MyCatVerbs> We are simply co-aware of the fact that we are missing it. :)
16:56:30 <Vanadium> MyCatVerbs: I figured the positive natural numbers were the monoids :<
16:56:39 <copumpkin> but being a copumpkin, I can see it coming!
16:56:41 <ksf> ...in virtualy any introduction to monoids I've seen those were the prime examples.
16:56:50 <MyCatVerbs> Vanadium: er, well, all groups are monoids. And a lot more besides. ^^
16:56:55 <copumpkin> Vanadium: but those too
16:57:02 <MyCatVerbs> Vanadium: but those too. :)
16:57:12 <Vanadium> So is the monoid the numbers or the operator?
16:57:15 <mauke> the set of nonnegative integers together with (+) forms a monoid
16:57:20 <ksf> probably because virtually everyone has a fairly good understanding of addition and multiplication over the natural numbers.
16:57:23 <Cale> http://arxiv.org/abs/math.CT/0305049
16:57:36 <Cale> ^^ Tom Leinster: Higher Operads, Higher Categories
16:57:36 <holmak> Hey, does anyone know where I can get a good Haskell syntax file for vim?
16:57:40 <ksf> (+) and 0, but that's a detail.
16:57:43 <mauke> wait, are monoids 2-tuples or 3-tuples?
16:57:44 <Cale> holmak: Doesn't it come with one?
16:57:46 <ksf> ... and (*) and 1
16:58:02 <holmak> Its decent, I was wondering if there was a better one that people use
16:58:06 <rasfar> hey i met tom!  nice guy.
16:58:10 <mauke> holmak: better how?
16:58:24 <MyCatVerbs> Vanadium: Both.
16:58:25 <holmak> the default one is pretty bare-bones
16:58:28 <bsod666> copumpkin: doesnt matter i was bing dense, i had actually named one of my variables the same as a function
16:58:43 <MyCatVerbs> Vanadium: (integers,(+)) is one monoid. (lists,(++)) is another.
16:58:43 <holmak> for instance, gedit highlights types differently, but vim doesn't
16:58:50 <ksf> the peano numbers are a monoid with succ as operator and zero as identity.
16:58:51 <Vanadium> Well, okay, that works.
16:59:08 <ksf> ...so, yes, numbers are somewhat the addition monoid.
16:59:09 <MyCatVerbs> Vanadium: mathematically a monoid is a set together with a binary operation on that set that obeys the monoid laws.
16:59:34 <ksf> er no.
16:59:34 <Cale> Look at page xii of that PDF for the short version of why computer science and topological quantum field theory are really the same thing ;)
16:59:39 <bsod666> why cant i use backspace in haskell without getting a parse error?
16:59:40 <ksf> succ is hardly binary.
16:59:45 <bsod666> when i use readLn
16:59:53 <Vanadium> quantum? :<
16:59:59 <ksf> bsod666, try haskeline.
17:00:00 <mauke> bsod666: probably because your terminal is in raw mode
17:00:04 <mauke> bsod666: is this in ghci?
17:00:11 <bsod666> winhugs?
17:00:16 <mauke> hmm, then no idea
17:00:17 <MyCatVerbs> Vanadium: So when you have instance (Monoid x) where { mempty = ...; mappend = ...; }, the set is x, the binary operation is mappend and the identity element is mempty.
17:00:27 <Axman6> bsod666: use ghc
17:00:37 <mauke> bsod666: maybe it's just a quirk of winhugs
17:00:42 <bsod666> hmm doesnt really matter that much just wondering
17:00:42 <Vanadium> Yeah, I think I understand that, I just did not get what exactly was the Monoid
17:00:50 <Vanadium> or rather which exactly
17:01:06 <pkrumins> Cale, looks like string theory as well
17:01:10 <Cale> pkrumins: yeah
17:01:39 <Cale> pkrumins: Basically all this stuff about diagrams is unified by variations of higher dimensional category theory.
17:02:08 <pkrumins> this is the most excellent
17:04:17 <MyCatVerbs> Cale: define "higher dimensional" category theory? I thought all graphs were embeddable into three dimensions. ;P
17:04:18 <copumpkin> Cale: so what were you thinking of when you meant they were on a collision course?
17:04:24 <Cale> lol, look at the awesome diagram on page 39
17:05:36 <Cale> MyCatVerbs: So, first of all, you have 2-categories, where there are not only objects and arrows, but arrows between the arrows which might be thought of as 2D directed sheets joining arrows together
17:06:46 <Cale> A natural example of those is provided by the category of categories, where you have objects (0-cells) which are categories, arrows (1-cells) which are functors, and then arrows between arrows (2-cells) which are natural transformations.
17:06:52 <dolio> Whoa, 410 pages.
17:07:02 <MyCatVerbs> Cale: Ah, nifty. And so you inductively define a k-category as a category in which the objects are arrows in a (k-1) category.
17:07:19 <MyCatVerbs> Whose thesis are you reading?
17:07:22 <Cale> MyCatVerbs: Yeah, though this definition turns out to be too restrictive to include many examples.
17:07:48 <dolio> The one that Cale linked 10 minutes ago.
17:08:19 <MyCatVerbs> I can't honestly say that it immediately leaped at me as particularly useful either, but it is the natural definition.
17:08:22 <Cale> Basically, it's the associativity being on-the-nose which kills you.
17:08:52 <ksf> someone give me an example for a monad over the natural numbers.
17:08:55 <Cale> So you start relaxing conditions saying that, oh, maybe k-composition for k <= n only needs to be associative up to isomorphism.
17:09:19 <Cale> ksf: As an order category or as a monoid category?
17:09:52 <ksf> as an example to complete the picture that monads aren't values in the same sense that addition and multiplication aren't numbers.
17:10:26 <Cale> MyCatVerbs: but formalising how the isomorphisms ought to interact gets more and more complicated, so there are other approaches to tackling it
17:10:26 <ksf> http://haskell.org/haskellwiki/What_a_Monad_is_not#Monads_are_not_values
17:11:03 <ksf> that page can certainly use some input from the CT wizards here
17:11:11 <Confused> OK guys, night night, thanks for all your help!
17:11:26 <Cale> There are two natural ways to turn the natural numbers into a category so that we can define monads in them.
17:11:27 <MyCatVerbs> Cale: can't you just do most of the relaxation simply by adding "up to isomorphism" to the inductive step going from k-categories to (k+1)-categories?
17:11:28 <ksf> ...I can't do much more than parrot stuff.
17:11:53 <kmc_> ksf, want more suggestions on what monads are not?
17:12:07 <c_wraith> monads are not nomads
17:12:14 <Cale> MyCatVerbs: But that's a bit *too* weak, because you really want some kind of coherence of isomorphisms
17:12:15 <ksf> Cale, do those happen to relate to the difference between multiplication and addition?
17:12:15 <kmc_> the monad that can be etc.
17:12:22 <c_wraith> though nomadic programming sounds pretty cool. :)
17:12:30 <ksf> kmc_, even more than that, I want _wiki edits_
17:12:36 <Cale> ksf: Well, okay, there are at least 3 :)
17:12:37 <kmc_> i don't have an account
17:13:03 <MyCatVerbs> c_wraith: isn't that the one where you work entirely from the deck of a yacht?
17:13:03 <ksf> request one.
17:13:08 <kmc_> i have to email someone
17:13:15 <MyCatVerbs> c_wraith: or if you're poor, a coffee shop.
17:13:16 <kmc_> i don't want to
17:13:22 <ksf> or just spurt them out for the time being.
17:13:30 <ksf> Cale, care to add those to the page?
17:13:38 <MyCatVerbs> c_wraith: Or if you're very poor, a park bench. ;)
17:13:51 <kmc_> Monads are not a language feature
17:13:57 <ksf> quick braindumps are ok, it's just a brainstorming page atm.
17:13:59 <kmc_> like lists, they're regular algebraic datatypes which we have a little sugar for
17:14:02 <ksf> (I should write that down)
17:14:54 <kmc_> monads are not "impure", in the moral sense
17:14:59 <Cale> ksf: We can form a category on the naturals whose objects are natural numbers, and where there is exactly one arrow n -> m whenever n <= m, and no arrows otherwise.
17:15:02 <kmc_> that is, non-monadic code is not always preferable to monadic code
17:15:08 <Cale> (composites are just the only thing they could be)
17:15:26 <kmc_> show an example of State monad... it's just the same as passing values explicitly, but more concise
17:15:53 <Cale> ksf: Then a functor F: N -> N will be a function N -> N such that whenever we have an arrow n -> m, then we have an arrow Fn -> Fm
17:16:01 <SmurfOR>  Does anyone here have a link to the video "Brian Beckman: Don't fear the Monad"?  The channel 9 page for it (here: http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/) only has a .mp3 now :(
17:16:09 <Cale> which means that n <= m implies Fn <= Fm, so this is a monotone function.
17:16:52 <kw317> SmurfOR: I might still have the video
17:16:54 <Cale> and then a natural transformation eta: F -> G has a component at X for each X which is an arrow eta_X: FX -> GX, which means that FX <= GX for all X.
17:16:54 <kw317> SmurfOR: hold on..
17:17:01 <SmurfOR> kw317, thanks :)
17:17:06 <jaj> hmm, looks like google were inspired by Haskell for their Go language
17:17:09 <Cale> (the naturality square commutes because any diagram does in this category)
17:17:11 <kmc_> jaj, they deny it
17:17:19 <kw317> SmurfOR: sorry, not anymore :-(
17:17:50 <Cale> So to reiterate that, saying that there's a natural transformation F -> G means that Fn <= Gn for all natural numbers n
17:17:51 <jaj> kmc_: :/
17:18:01 <Cale> Now let's look at the definition of a monad
17:18:21 <SmurfOR> kw317, darn
17:18:24 <EloquentRaven> thank you very much guys, by helping Confused you also answered a question i was going to ask (were on the same course)
17:18:40 <kw317> SmurfOR: I didn't find that talk very good
17:18:43 <ksf> Cale, I think the other two monads play nicer into the point.
17:18:47 <Cale> A monad T will be a functor (monotone function) on the naturals, together with natural transformations 1 -> T and T^2 -> T, satisfying some laws.
17:18:54 <SmurfOR> kw317, do you have any recommendations?
17:18:56 <kw317> SmurfOR: it's a lot of chat, not much "meat"
17:19:02 <kw317> SmurfOR: s-inf.de
17:19:06 <jaj> kmc_: but like so many declarative languages that try to implement features which are available in functional languages for 20 years, it's always crippled
17:19:10 <ksf> otoh, the page could say "monads aren't values in the same sense that an order relation isn't numbers"
17:19:17 <kw317> SmurfOR: Die Grundlagen der Funktionalen Programmierung (in english)
17:19:22 <kmc_> i don't see what "declarative" has got to do with it
17:19:26 <kmc_> haskell is very declarative
17:19:28 <Cale> So that means n <= Tn for each n, but T(T n) <= T n for each n.
17:19:34 <kw317> SmurfOR: hasell + denotational semantics + operational semantcs (lambda calc)
17:19:35 <kmc_> but otherwise yes i agree
17:19:41 <kw317> SmurfOR: but I can't remember if it covers monads
17:20:00 <kmc_> they do have first class functions with free variable closure, and they have a literal syntax for them (lambdas)
17:20:06 <jaj> kmc_: sorry, imperative
17:20:24 <kmc_> but they don't have parametric polymorphism so you can't write a proper "map"
17:20:41 <Cale> But of course, since n <= Tn and T is monotone, we already have that T n <= T(T n)
17:20:48 <ksf> kmc_, that's not embarrassing enough.
17:20:54 <Cale> So this means T(T n) = T n for each n
17:21:10 <kmc_> i don't like the convention that imperative is an antonym for functional.  haskell is a great imperative language.  since "functional" means "has first class functions", the antonym should be a negative, like "dysfunctional"
17:21:17 <ksf> why mention map if you can say that "they don't have parametric polymorphism so they have to provide len as a primitive"?
17:21:20 <FunctorSalad> "<MyCatVerbs> Cale: Ah, nifty. And so you inductively define a k-category as a category in which the objects are arrows in a (k-1) category." <-- the *homsets* are (k-1)-categories
17:21:39 <Cale> FunctorSalad: ah, good catch, I wasn't watching carefully enough
17:21:45 <SmurfOR> kw317, a ctrl+f doesn't find that on that page
17:22:05 <Cale> So for an example of a monad on this category of natural numbers, we have something like, rounding up to the nearest 10.
17:22:08 <pkrumins> What's the banana split rule? I can't find any good info on it.
17:22:10 <kw317> SmurfOR: hold on..
17:22:10 <kmc_> whoever added my two cents about monads to the page, thank you muchly
17:22:18 <kmc_> oh, another
17:22:33 <kw317> SmurfOR: http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
17:22:37 <kmc_> "Monads are not essential for doing interesting things in Haskell"
17:22:51 <Cale> In general, it will be a function which is something like a "closure operator".
17:22:52 <ksf> I still don't see any edits that aren't mine. shame on you all.
17:23:01 <rieux_> ksf: that's not why len has to be a primitive, afaict
17:23:32 <FunctorSalad> data (forall a b. Category (c a b)) => Category2 c where ...
17:23:34 <FunctorSalad> :)
17:23:34 <Cale> It will push numbers generally upward to points where they will stay.
17:23:57 <FunctorSalad> (btw we do in fact have qualified constraints already... kinda)
17:23:59 <Cale> Another way to say it is that it's a nondecreasing idempotent function.
17:24:13 <FunctorSalad> *quantified
17:24:18 <Cale> Let's look at the monoid category for +
17:24:30 <gOcOOl> I sort of understand WHNF and stuff about evaluating the outermost constructor when it comes to data constructors like (:), (,) etc but I'm not sure what evaluating to WHNF means when talking about evaluating a function like f x y. Any insights?
17:24:36 <jaj> does anybody know when bootstrapping will be available in ghc again?
17:24:37 <FunctorSalad> constraint :: forall a b r. (Category (c a b) => r) -> r
17:24:58 <Cale> So, in this category we have only one object, and the arrows are natural numbers, and the composition of arrows is simply addition.
17:25:13 <ksf> gOcOOl, it means exactly the same thing.
17:25:17 <kmc_> gOcOOl, (f x) is not in WHNF.  you substitute x into the body of f and continue reducing
17:25:23 <kmc_> but (\x -> e) is WHNF, even if e is not
17:25:35 <kmc_> that's the "weak" part... it means that only the *outermost* expression component is irreducible
17:25:53 <Cale> A functor f: N -> N will then have no choice about where to send the object, but it has to map natural numbers to natural numbers such that F(n + m) = Fn + Fm
17:26:00 <Cale> That is, it will be an additive function.
17:26:17 <Cale> (and F0 = 0)
17:26:28 <kmc_> so ((\x -> \y -> (add x) y) 3)  ==> (\y -> (add 3) y)  which is WHNF, even though (add 3) could be reduced
17:26:30 <Cale> er, used a lowercase f once there, sorry)
17:26:35 <kmc_> that's the "lazy" part -- we don't reduce untli we have to
17:26:43 <Cale> So what will a monad on this category be?
17:26:51 <Cale> Oh, natural transformation first :)
17:27:59 <Cale> A natural transformation eta: F -> G will be a collection of maps eta_X: FX -> GX, oh, but we already know what FX and GX have to be. They have to be the same object X.
17:28:08 <Cale> (there's only one object here)
17:28:25 <Cale> So a natural transformation will be a single map X -> X, which is just a number
17:29:56 <Cale> But it has to satisfy a naturality condition.
17:31:06 <jaj> ghc 6.10.4 can't bootstrapped from hc files, can it?
17:31:25 <copumpkin> not out of the box
17:31:40 <copumpkin> probably could if you wanted to go fix a bunch of stuff :P
17:31:48 <jaj> :)
17:32:10 <Cale> In this case, the naturality is a bit funny since addition is commutative and cancellative. It says that eta . Fn = Gn . eta for all n, that is eta + Fn = Gn + eta, or Fn = Gn for all n.
17:32:37 <Cale> So natural transformations are *really boring* here.
17:32:46 <ksf> .hc bootstrapping isn't broken unless target and host differ.
17:33:09 <Cale> For our monad T, it'll have to be an additive function with a natural transformation 1 -> T, which means that n = Tn for all n.
17:33:20 <Cale> So the only monad is the identity monad :)
17:33:24 <ksf> ...not that anyone in the right state of mind would bootstrap from hc to build a native compiler.
17:33:40 <Axman6> is any set a subset of itself?
17:33:53 <Cale> Axman6: usually, yes
17:33:54 <Axman6> so, {x,y} is a subset of {y,x}?
17:33:54 <copumpkin> all sets are
17:33:58 <ksf> a proper subset or subset?
17:34:03 <Axman6> excellent, just checking :)
17:34:03 <Cale> Hmm, what if we treat the naturals under the divisibility order?
17:34:53 <ksf> {x,y} isn't a proper subset of {x,y}, but {x} and {y} are. it's a mere subset.
17:34:58 <Cale> That is, there is exactly one arrow n -> m when n | m, that is, when there is some k for which m = n*k.
17:35:08 <jaj> ksf: really?
17:35:32 <Cale> jaj: Yep, that's the difference between the terms 'proper subset' and 'subset'
17:35:37 <jaj> ksf: that means I don't need any version of ghc installed if I want to build the current ghc for my machine?
17:35:40 <Cale> oh
17:35:41 <Cale> heh
17:35:56 <ksf> jaj, iff you have .hc files, yes.
17:36:00 <ksf> but chances are you don't.
17:36:07 <ksf> as to build these .hc files, you'd need a ghc.
17:36:18 <jaj> I see
17:36:36 <jaj> and how was this solved for 6.6?
17:36:48 <Cale> So a functor F: (N,|) -> (N,|) would then be a function such that whenever n | m we have F(n) | F(m)
17:36:54 <jaj> where there some pre-generated .hc files that were included?
17:36:54 <ksf> see, you have to be Mnchhausen to bootstrap.
17:37:17 <Cale> (Is anyone following the stuff that I'm saying? I'm certainly having fun going over this :)
17:37:53 <ksf> It's a tradition that ghc is either completely impossible or infeasably hard to bootstrap.
17:38:26 <Cale> and so a natural transformation F -> G is then an assertion that F(n) | G(n) for all n
17:38:32 <ksf> you can direct flames to #ghc, if you feel like it.
17:38:44 <jaj> ksf: which makes it infeasably hard or impossible to package ;)
17:38:50 <ivanm> ksf: does shell redirection work?
17:38:57 <ivanm> cat flames >> #ghc
17:38:57 <ivanm> ;-)
17:39:07 <ksf> gentoo solves it by providing a binary package.
17:39:12 <ksf> er no.
17:39:14 <Cale> and so a monad in that category is a function T such that n | T n for all n, and T (T n) | T n for all n, and so T (T n) = T n
17:39:15 <ksf> does it?
17:39:35 <ksf> I think it solves it by conditionally downloading a pre-built ghc in case none is installed.
17:39:53 <ivanm> ksf: for gentoo, we pre-build a gentoo-binary
17:40:04 <ivanm> users then have the option of using that (USE=binary) or using it to build their own
17:40:25 <ivanm> one of the difference that it makes is that if you want documentation, it gets provided from the binary rather than you rebuilding it yourself
17:40:26 <jaj> ksf: no I don't feel like joining #ghc just for flaming, I guess others did that before :)
17:40:31 <Cale> Hmmm...
17:40:32 <ivanm> (to avoid bootstrapping haddock as well)
17:40:38 <Cale> Can anyone think of such a function?
17:41:00 <ksf> argh yes. bootstrapping haddock.
17:41:01 <ivanm> (note that we still haven't reliably gotten the 6.12 RC done yet)
17:41:04 <Cale> Well, okay, aside from the identity function
17:41:10 <jaj> ksf: yeah that gentoo way is merely a hack
17:41:14 <Cale> That's a sort of interesting number theory problem :)
17:41:22 <ksf> I had to do USE=-doc to make the dependencies non-recursive.
17:41:35 <ivanm> ksf: did you have USE=ghcbootstrap?
17:41:40 <ksf> dunno.
17:41:50 <ivanm> ksf: because USE="doc -ghcbootstrap" will _not_ recurse on anything
17:41:57 <ivanm> and you're not meant to use ghcbootstrap ;-)
17:42:04 <ksf> yep it's set.
17:42:17 <ksf> +doc +ghcbootstrap -binary
17:42:21 <ivanm> then unset it!
17:42:24 <ivanm> you're not meant to use it!
17:42:32 <ivanm> (the elog message tells you as much)
17:42:32 <jaj> at one point I had ghc-6.10.3, I think, packaged more or less correctly with a build dependency to 6.6
17:42:47 <jaj> it built fine on i386 but then on amd64 haddock failed to build
17:42:52 <ksf> I think I had to, once, because the binary used to bootstrap wasn't buid, yet.
17:42:58 <jaj> and then I was too frustrated to go further
17:43:07 <ivanm> ksf: right, in that case ask us on #gentoo-haskell to make it ;-)
17:43:35 <Cale> Hmm, so one example would be the function which sends each number n = p_1^n_1 * ... * p_k^n_k to the number p_1^m * ... * p_k^m where m = max {n_1, n_2,..., n_k}
17:43:36 <ivanm> ksf: and in <haskell overlay>/projects/bootstrap.sh (something like that, forget the actual name) is the bootstrap script we use if you're sick of waiting for us
17:43:40 <ksf> but that takes ages, in comparison to doing it myself.
17:44:13 <ksf> anyway, the next time this is going to come up is when either 6.12 or 6.10.5 hit stable.
17:44:22 <ivanm> ksf: there is no 6.10.5 AFAIK
17:44:26 <jaj> :)
17:44:35 <poe> Cale fibonacci
17:44:37 <ivanm> ksf: and we can't get 6.12 RC to reliably build yet
17:44:43 <ivanm> poe: Calanacci? :p
17:45:01 <poe> I mean F(n) = F_n
17:45:04 <BlackM> :t swap
17:45:05 <lambdabot> Not in scope: `swap'
17:45:06 <Cale> hmm
17:45:16 <ksf> I've got a 6.12 on my system, but I've never really used it because there's no cabal-install.
17:45:21 <Cale> That's a functor anyway :)
17:45:27 <ksf> I know I shouldn't be such a pussy, but I'm lazy.
17:45:33 <ivanm> ksf: what, from the RC ebuild? :o
17:45:34 <Cale> I don't think it's a monad
17:45:40 <ksf> nope, from the tgz
17:45:43 <ivanm> ahhh
17:45:59 <poe> n|m <=> F_n|F_m  (n>3)
17:46:01 * ivanm is trying to work out why haddock is still being built and included in the tarball when we don't want it...
17:46:17 <jaj> is haddock obsolete?
17:46:32 <ksf> not at all
17:46:36 * jaj has been out of haskell world for one year
17:46:42 <Cale> hmm, so we might have to modify it for small numbers so that it's a little smoother, but good catch :)
17:46:53 <ksf> but the ghc tarball comes with a lot of stuff, and gentoo likes to split stuff up.
17:47:10 <ksf> I can still remember all that kde split ebuild punk.
17:47:21 * Twey imagines Gentoo taking the -dev route
17:47:25 <ivanm> ksf: well, dcoutts and kolmodin have been discussing whether we should use GHC's haddock or not...
17:47:34 <ivanm> @slap Twey
17:47:35 * lambdabot karate-chops Twey into two equally sized halves
17:47:38 <Twey> :þ
17:47:41 <poe> Cale use less of N :)
17:47:47 <poe> *or use
17:47:51 <Cale> yeah
17:47:53 <copumpkin> what is up with LaTeX's diagonal lines? http://en.wikipedia.org/wiki/File:Monad_unit_explicit.svg this has bugged me for years :P
17:47:55 * ksf thinks the haddock situation is unsatisfying in any case.
17:48:02 <Cale> Need to keep the 0 though.
17:48:11 <Cale> er
17:48:17 <poe> do we?
17:48:19 <Cale> No
17:48:25 <ivanm> ksf: which situation?
17:48:27 <ksf> the point is that if you install missing documentation, documentation that should refer to it has to be rebuilt.
17:48:32 <Cale> I suddenly had gone back to the addition category :)
17:48:40 <ivanm> copumpkin: looks like a graphviz thingy to me
17:48:42 <poe> very natural :)
17:48:43 <ksf> I'd like stuff to be done on the fly.
17:49:06 <ivanm> copumpkin: there's mention on the graphviz site IIRC about wanting to use an svg editor to fix up lines in some cases like that when it doesn't lay them out properly
17:49:07 <copumpkin> ivanm: looks like LaTeX to me, but even if it isn't, LaTeX does that weird diagonal line thing too
17:49:12 <jaj> is mmorrow still around here?
17:49:24 <ivanm> ksf: well, not sure what could be done to it...
17:49:25 <ksf> ...a bunch of files with a haskell interface that things like leksah can query, a shell interface that vim can query, and a happstack server that my browser can query.
17:49:27 <Cale> So yeah, we can just lose the objects less than or equal to 3 and then we have the Fibonacci functor on the rest :)
17:49:29 <ivanm> preflex: seen mm_freak
17:49:29 <preflex>  mm_freak was last seen on #haskell 12 days, 2 hours, 57 minutes and 11 seconds ago, saying: > fix (fix (fix (fix (1:):):):)
17:49:31 <jaj> oops yes, it just takes 2 m
17:49:32 <ivanm> jaj: ^^
17:49:41 <ivanm> bah, tabbing failure
17:49:45 <ivanm> preflex: seen mmorrow
17:49:45 <preflex>  mmorrow was last seen on #haskell 12 hours, 2 minutes and 6 seconds ago, saying: the fold functions over the Maps are super useful for building a new Map of .. as you fold over another one
17:49:51 <ksf> basically, don't pregenerate .html files.
17:50:01 <ksf> manpages are rendered on the fly too, after all.
17:50:09 <ivanm> ksf: so you want to dynamically re-generate documentation all the time? :s
17:50:17 <ksf> yep.
17:50:20 <ksf> just like man does.
17:50:34 <ivanm> ksf: well, you stil have to have haddock or whatever create the data files
17:50:37 <BMeph> Does anyone know of a text that discusses lagged fibonacci sequences, more than saying how wonderful they are for PRNGs? :)
17:50:49 <ivanm> and the problem currently is the same: what happens if you don't generate the files?
17:50:52 <ksf> yes, but in a way that leaves references unresolved.
17:50:52 <poe> Cale now for a functor to be a monad... maybe #haskell-overflow?
17:51:06 <ksf> so you don't have to re-run haddock if stuff changes.
17:51:25 <ksf> poe, first it has to be an applicative before it can be a monad.
17:51:56 <ivanm> ksf: still need to know what to link it to...
17:52:10 <ivanm> ksf: I suppose the big problem is that docs are per-package rather than a central repo
17:52:14 <ksf> packagename module function, yes.
17:52:33 <ksf> you get that while compiling.
17:52:37 <ivanm> ksf: AFAIK, haddock can't tell which package it's from
17:52:48 <ivanm> ksf: note that man pages don't link to each other, they just tell you what to look at with a text field
17:52:54 <ksf> but ghc knows it.
17:53:27 <ivanm> this sounds way too complicated...
17:53:27 <ksf> I'd be surprised if it's not exposed in the api.
17:53:29 <Saizan_> ksf: with dcoutts we were thinking of going that route, have haskell produce a machine readable format with all the info, that can be rendered in multiple formats (it's needed for hoogle indexes when you don't have the sources, for example)
17:53:38 <ivanm> ksf: after all, this is now assuming that GHC is your compiler...
17:53:59 <ksf> doesn't haddock depend on ghc, anyway?
17:54:05 <Saizan_> with haddock you _are_ assuming ghc is your compiler :)
17:54:17 <ivanm> Saizan_: for current versions, yes
17:54:31 <Saizan_> s/haskell produce/haddock produce/
17:54:31 <ivanm> Saizan_: but aren't they talking about splitting it back out again from using ghc as the parser?
17:54:42 <ksf> oh. a local hoogle server would be even cooler.
17:54:50 <jaj> most stuff in haskell world is way too ghc-specific IMHO
17:55:06 <ivanm> jaj: mainly because there's no real alternative that's good enough yet
17:55:15 <ivanm> so people take advantages of the ghc stuff
17:55:19 <ksf> maybe parts of the ghc library should be nailed stable and implemented by other compilers, too.
17:55:39 <jaj> ivanm: yeah but that makes it harder and harde to come up with an alternative
17:55:45 <Saizan_> a big tie is TH
17:55:45 <ksf> ...or haddock should use a wrapper lib or something.
17:56:05 <ivanm> jaj: which is why I try to avoid extensions as much as possible
17:56:33 * ksf defines haskell to be what spj thinks it is.
17:56:38 <ivanm> Saizan_: no other compiler even pretends to have TH functionality?
17:56:41 <jaj> it's just about the same thing with C and gcc extensions
17:56:49 <ivanm> ksf: a playground for doing cool stuff?
17:56:54 <ivanm> jaj: yeah
17:57:05 <ksf> playgrounds yay
17:57:17 <Saizan_> ivanm: not that i know of
17:57:25 <ksf> little kids having fun in the day, big kids drinking beer in the night.
17:57:56 * ivanm doesn't count "drinking beer in the night" as "doing cool stuff"
17:57:57 <ivanm> :p
17:58:02 <jaj> I'm kinda frustrated since I think Haskell is great but I haven't been coding in haskell for one year because it's too hard to keep up with ghc
17:58:21 <ksf> oh, it's possible to look darn cool on a swing.
17:58:22 <Saizan_> do you really need to "keep up with ghc"?
17:58:55 <jaj> Saizan_: well currently $myos ships ghc 6.6 because it's the last one that it is possible to bootstrap
17:59:07 <ksf> ouch.
17:59:21 <jaj> and packaging ghc 6.10 and 6.6 together and stuff is really a pain
17:59:30 <ksf> hopefully the boostrap situation will resolve itself with llvm
17:59:45 <ivanm> jaj: what's #myos ?
17:59:49 <ivanm> s/#/$/
17:59:53 <jaj> ivanm: openbsd
17:59:56 <Saizan_> mh, not much of hackage still builds on 6.6 i bet :)
17:59:58 <ivanm> ahhh
18:00:13 <jaj> Saizan_: just about nothing ;)
18:00:18 <ivanm> jaj: so you have to explicitly build everything from source with no binary deps on openbsd?
18:00:19 <jaj> ksf: llvm?
18:00:28 <Saizan_> but, can't you just build later versions with it?
18:00:32 <ivanm> jaj: there's a project done on adding an llvm backend to GHC
18:00:38 <ivanm> I doubt it would help with bootstrapping
18:00:46 <jaj> some CPS -> SSD translator?
18:01:25 <ksf> ivanm, not in the state that's described in the thesis, but it will, if stuff isn't compiled down to .o before linking.
18:01:31 <jaj> s/SSD/SSA/
18:02:09 <ksf> we can generate llvm assembly from haskell files and then run them anywhere llvm runs, which is about everywhere.
18:02:31 <ksf> a big topic is the rts, of course, and such things as the posix package.
18:02:42 <ivanm> ksf: I thought they were using LLVM to make binaries, not using it as a VM...
18:02:50 <jaj> but llvm assembly is very different from what functional languages look like
18:03:05 <ksf> what he's done is a cmm->llvm compiler.
18:03:06 <Axman6> jaj: so's C
18:03:17 <Axman6> ksf: i'm not sure he has
18:03:21 <jaj> ivanm: I could build everything but it's so much nicer to have everything packaged
18:03:35 <ivanm> jaj: so build it and submit it
18:03:42 <ksf> ...and injected it in the most straight-forward way to make stuff work, which is injecting it where the current backends are, which emit native assembly.
18:03:42 <ivanm> use 6.6 to build 6.8, use 6.8 to build 6.10
18:03:49 <ivanm> then submit a package
18:04:21 <ksf> he's actually mentioning tackling not generating native assembly right away next, because llvm can do nifty link-time optimization.
18:04:30 <jaj> ivanm: I cannot just submit a binary package, I need to submit ports which are buildable on most platforms but the building cluster
18:04:48 <jaj> and which obey to a certain set of rules like where to store documentation and so on
18:05:12 <BMeph> That's it; we should hijack a Chicken compiler to do Haskell! ;p
18:05:33 <ksf> jaj, that's true, and he found that llvm fails to optimize stuff because all the information is hidden behind the stg.
18:05:47 <Axman6> i was very impressed with the DPH results from the LLVM work
18:06:17 <Axman6> 25% increase in speed from a basic, unoptimised implementation is awesome
18:06:51 <ksf> the not-pinning-stg-registers thing is also interesting.
18:07:07 <ksf> ...well, at least for people who are stuck on an architecture without a decent amount of registers.
18:07:45 <jaj> from what I've heard and seen so far llvm is really great
18:08:33 <jaj> with llvm we could program GPUs in haskell :)
18:09:14 <ksf> actually, I've shelved porting ghc to haiku until either someone fixes the build system for me, or I can get my hands on the llvm stuff.
18:09:30 <ksf> we can program gpus in haskell.
18:09:51 <Axman6> jaj: well, sort of, using LLVM doesn't automatically give you GPU support
18:10:00 <ksf> even non-cuda ones, though stuff you can do is restricted, of course.
18:11:01 <Axman6> ChilliX is working on LLVM bindings for his accelerate framework, which also supports a CUDA backend, and hopefully an OpenCL one soon too
18:11:08 <ksf> jaj, http://hackage.haskell.org/package/GPipe-1.0.4
18:11:26 <jaj> ksf: cool :)
18:12:48 <ksf> one caveat, though: stuff is going to be utterly slow if you don't replace a Double->GLdouble conversion in its source with unsafeCoerce, as it'd go via rational to do it.
18:14:21 * ksf doesn't like how people are dropping glsl like it wouldn't be usable for anything.
18:14:31 <jaj> unsafeCoerce: here there be dragons
18:15:24 <ksf> well if your opengl.h resolves gldouble to double, it's perfecly safe.
18:15:37 <ksf> you're just ignoring a newtype constructor, then.
18:21:05 <jaj> somehow the fact that you are able to write a coerce function in haskell makes me think of gdel's incompleteness theorem
18:23:23 <jaj> It occurs to me that gdel's theorem dictates that in a language as powerful as haskell you cannot prevent somebody from writing a coerce function
18:24:33 <gwern> http://www.reddit.com/r/compsci/comments/a2zow/ask_compsci_what_is_the_smallest_or_easiest_or/c0fmqew <-- bleh. I'm starting to get really sick of this
18:25:00 <FunctorSalad> jaj: ? unsafeCoerce isn't pure haskell
18:25:40 <gwern> FunctorSalad: no doubt oleg could do something with pure, non-total haskell
18:25:46 <ivanm> gwern: sick of what?
18:25:55 <FunctorSalad> if anything you might be able to use the incompleteness theorem to argue that unsafeCoerce is necessary sometimes (but I don't know if the logic corresponding to haskell is strong enough)
18:26:24 <gwern> ivanm: trying to figure out what deterministic algorithm is as good as a randomized one, or alternately, why my deterministic algorithms all have different performance when they ought to be the same
18:26:50 <ivanm> pi is a random number now? :s
18:27:00 <jaj> ivanm: just like 1
18:27:00 <copumpkin> definitely
18:27:06 <gwern> ivanm: not you too x.x
18:27:10 <jaj> took a fair dice, roled it, got 1
18:27:41 <ivanm> I did a course where we used random algorithms for comp phys because in some cases they're easier/better
18:27:53 <ksf> you can use unsafePerformIO and IORefs to implement unsafeCoerce.
18:27:55 <copumpkin> here, if you want true randomness, just go to a trusted third party!! duh! https://www.grc.com/passwords.htm
18:28:13 <ivanm> jaj: I thought the xkcd comic had proven that 4 is the random number...
18:28:20 <ivanm> copumpkin: random.org ?
18:28:24 <ivanm> we have a hackage package for that! \o/
18:28:27 <copumpkin> lol
18:28:57 <ksf> ...but if the typechecker and langeage doesn't let you, nope, you won't be able to implement unsafeCoerce, in the same way that you can't make a total language loop infinitely.
18:29:02 <jaj> ivanm: couldn't remember which number it was but I was thinking of the xkcd comic :)
18:29:10 <copumpkin> 4
18:29:32 <Draconx> the dilbert version was better.
18:30:01 <gwern> ivanm: my problem is, why does reversing the list and iterating it down it perform better than just iterating down the list, and why does starting at the median do better than starting at length/4? they should all be equally good if random indexes are the best solution
18:30:03 <copumpkin> the (insert less popular, well-known version here) version was better
18:30:18 <ivanm> Draconx: oh, with the trolls?
18:30:21 <Draconx> http://www.random.org/analysis/dilbert.jpg
18:30:24 <jaj> FunctorSalad: I don't know about the exact implementation but I think unsafeCoerce is closely related to unsafeInterleaveIO, which I think can be implemented in pure haskell and which can be used to implement a coerce according to what some savvy guy wrote here some time ago
18:30:33 <ivanm> copumpkin: heh
18:30:47 <copumpkin> ivanm: heh right back at you
18:31:13 * ivanm quickly raises his shield, thus deflecting the heh
18:31:23 <dolio> I suspect someone has proved the soundness of a type system pretty similar to Haskell's, which means you can't write unsafeCoerce in it, if you limit yourself to a sufficiently academic portion.
18:31:26 <jaj> Draconx: http://www.gergely.risko.hu/debian-dsa1571/dilbert9.jpg
18:31:43 <Draconx> jaj, brilliant!
18:31:47 <ivanm> heh
18:32:08 * copumpkin unhehs ivanm
18:32:10 <ManateeLazyCat> I test Google Wave today, amazing!
18:32:29 <ManateeLazyCat> Real time talk.
18:32:30 * copumpkin still hasn't tried it
18:32:31 <jaj> ManateeLazyCat: it's mail + instant messenger?
18:32:41 <Draconx> jaj, + wiki, pretty much.
18:32:48 <ManateeLazyCat> jaj: Yes, but more.
18:32:48 <jaj> that's like my screen (tmux) session running on my server
18:33:12 <ManateeLazyCat> jaj: Email + IM + Wiki + Mail List. And real-time.
18:33:36 <ManateeLazyCat> My friend can see my word when i was typing.
18:33:41 <copumpkin> jajaja
18:33:52 <gwern> jamaicing me crazy
18:34:07 <ManateeLazyCat> Most time, your friend can understand you meaning in real-time.
18:34:12 <Draconx> ah yes, I forgot that it is also "+ unix talk"
18:34:15 <ManateeLazyCat> Don't need wait.
18:34:20 <jaj> ManateeLazyCat: does it have collaborative editing?
18:34:34 <ManateeLazyCat> jaj: I never test it.
18:34:45 <ManateeLazyCat> I just start use it few hours.
18:34:53 <jaj> problem is that google can also read real time what you're typing
18:35:03 <Endo> Hi!
18:35:09 <copumpkin> jaj: not necessarily
18:35:27 <copumpkin> supposedly it's an open protocol that anyone can implement
18:35:33 <copumpkin> whether that will happen or not is another question
18:35:37 <jaj> and problem is they will remember what you typed once they have released their voting machine webapp and run for election
18:35:42 <jaj> </fud> ;)
18:36:02 <Endo> anyone available for a little support?
18:36:09 <bos> preflex: seen dons
18:36:09 <preflex>  dons was last seen on #haskell 1 day, 3 hours, 59 minutes and 14 seconds ago, saying: so you could have main :: IO Int
18:36:44 <rasfar> hi Endo, what's up?
18:36:44 <copumpkin> there needs to be a red phone
18:36:54 <ManateeLazyCat> Emacs crash agina.
18:37:00 <ManateeLazyCat> again.
18:37:02 * copumpkin composes appEndo with Endo
18:37:03 <Endo> hi rasfar
18:37:09 * ManateeLazyCat I have it.
18:37:18 <Endo> copumpkin: :o
18:37:19 * ManateeLazyCat hate it
18:37:30 <copumpkin> :t appEndo . Endo
18:37:32 <lambdabot> forall a. (a -> a) -> a -> a
18:37:36 <ManateeLazyCat> Anyone use Google Wave in here?
18:37:36 <copumpkin> damn right
18:38:04 <copumpkin> there are infinite functions with that signature!
18:38:08 <copumpkin> muahahaha
18:38:09 <Endo> I just need some directions to some partial evaluation framework with an
18:38:25 <Endo> I just need some directions to some partial evaluation framework with a web interface
18:38:41 <jaj> copumpkin: I guess there are infinite functions with any signature
18:38:49 <dolio> Nope.
18:38:52 <copumpkin> lol
18:38:55 * copumpkin sets dibblego on jaj
18:39:13 * rasfar tried to decide if Endo is joking
18:39:24 <copumpkin> depends how you define equality
18:39:30 <Endo> rasfar: not joking, just newbie to haskell
18:39:33 <FunctorSalad> jaj: I'd be very surprised if you could implement unsafeCoerce in haskell
18:39:36 <Endo> :P
18:39:47 <FunctorSalad> are you sure unsafe*interleave* was enough?
18:39:53 <ivanm> copumpkin: why dibblego?
18:39:56 <rasfar> well, there's lambdabot...  that's sort of a web interface
18:39:57 <FunctorSalad> that's a different beast than unsafePerform
18:40:07 <copumpkin> ivanm: he was ranting about precisely that in #haskell-in-depth an hour or so ago
18:40:21 <ivanm> about there being or not being infinite funcs?
18:40:32 <copumpkin> about people insisting that there are when there aren't
18:40:35 <rasfar> omg, there's a #haskell-in-depth channel??  i'm already out of my depth.
18:40:36 <copumpkin> (for the type of (.))
18:40:52 <ivanm> copumpkin: for appEndo . Endo ?
18:40:56 <ivanm> copumpkin: oh, (.)
18:40:57 <FunctorSalad> what's an infinite function?
18:40:59 * ksf imagines curryable webforms.
18:41:05 <ivanm> FunctorSalad: infinite possible functions
18:41:11 <FunctorSalad> appEndo . Endo. serious business
18:41:13 <jaj> FunctorSalad: I really don't know actually, that's what I remembered but I have no idea how they are implemented and it was a long time ago so perhaps I remembered the wrong wording
18:41:15 <copumpkin> srsly
18:41:20 <FunctorSalad> @type appEndo
18:41:21 <lambdabot> forall a. Endo a -> a -> a
18:41:23 <FunctorSalad> @type Endo
18:41:24 <lambdabot> forall a. (a -> a) -> Endo a
18:41:24 <ksf> I actually think it's quite a common concept, at least under web developers who are worth their wage.
18:41:28 <Endo> hahahahah
18:41:46 <ivanm> copumpkin: well, I see how there's infinite possible funcs, since you don't know how many times the function you pass to it is applied
18:41:50 <ksf> btw, does happstack has a continuation interface?
18:42:05 <copumpkin> FunctorSalad: newtype NfntFnctn a = NfntFunctn a -> a
18:42:15 <copumpkin> ivanm: yep
18:42:22 <dolio> (a -> a) -> a -> a is the type of Church numerals.
18:42:27 <copumpkin> ivanm: in the one I gave earlier
18:42:30 <dolio> So there's obviously infinitely many of those.
18:42:34 <ivanm> copumpkin: infinite possible _sensible_ functions, no
18:42:44 <copumpkin> but the type of (.) has a unique function in it, if you exclude bottoms
18:42:44 <ivanm> dolio: right, but it's countably infinite! :p
18:42:51 <ray> copumpkin: there are infinite functions with the signature a -> a
18:43:05 <copumpkin> ray: only if you look at their structure
18:43:11 <FunctorSalad> if the codomain is infinite there are infinitely many const functions, duh
18:43:14 <copumpkin> or if you're sneaking something about the lack of a forall there
18:43:18 <ivanm> ray: that assumes you know something about the type
18:43:19 <ksf> ray, also if the set of types is closed?
18:43:19 <ray> id, id . id, id . id . id...
18:43:29 <dolio> Those are all the same function.
18:43:32 <ivanm> ray: infinitely possible _unique_ functions
18:43:37 <FunctorSalad> extensional equality
18:43:39 <copumpkin> extensionally the same
18:43:44 <FunctorSalad> or even better, moral equality :D
18:43:56 <copumpkin> I'm the moral _|_
18:44:02 <dolio> They're intensionally the same, too.
18:44:06 <FunctorSalad> morally there's just one "a -> a", no?
18:44:26 <ksf> there's no a -> a, at all. polymorphism is syntactic sugar.
18:44:30 <ray> but seriously there is more than one, because _|_
18:44:39 <copumpkin> ray: I explicitly said I was ignoring that ;)
18:44:44 <jaj> ivanm: well, for Int -> Int you can for example have f a = a + 1, f a = a + 2, ...
18:44:55 <copumpkin> jaj: yeah, that has lots of functions in it
18:44:57 <ray> i thought you meant explicit in the music-video sense
18:45:04 <copumpkin> jaj: 2^32^(2^32)
18:45:15 <ivanm> jaj: but it isn't
18:45:18 <ivanm> jaj: it's a -> a
18:45:18 <jaj> copumpkin: Integer -> Integer :p
18:45:18 <FunctorSalad> moral equality for functions is: forall x y, x ~ y ==> f x ~ g y
18:45:27 <Axman6> > 2^32^(2^32)
18:45:32 * Axman6 waits
18:45:33 <lambdabot>   mueval: ExitFailure 1
18:45:38 <Axman6> failure!
18:45:45 <copumpkin> jaj: then it has uncountable functions in it unless you consider Integer to be finite because of its implementation :)
18:45:47 <FunctorSalad> where the "~" is this PER in the paper...
18:46:00 <copumpkin> the paper that you haven't yet cited?
18:46:14 <FunctorSalad> weren't you around yesterday?
18:46:25 <copumpkin> I was, but #haskell wasn't :o
18:46:26 <FunctorSalad> the fast-and-loose-reasoning one
18:46:36 <jaj> ivanm: but the set of Int -> Int function is embedded in the set of a -> a functions, isn't it?
18:46:50 <ivanm> Axman6: what's the usage of non-windows OSs like for CS at ANU?
18:46:52 <FunctorSalad> copumpkin: yes I'm typing-lazy right now
18:46:52 <copumpkin> jaj: but any a -> a must work on all types
18:47:07 <ivanm> right, what copumpkin said
18:47:14 <copumpkin> jaj: how many pure functions exist with type a -> b?
18:47:19 <ivanm> jaj: we're talking specifically about "a -> a"; so you have no idea what type a is
18:47:22 <FunctorSalad> jaj: no, "a -> a" is more like the intersection of all the A -> A
18:47:22 <Axman6> ivanm: it's all linux in the comp labs, and all the library labs are 50/50 PC/Mac
18:47:28 <ivanm> @djinn a -> a
18:47:28 <lambdabot> f a = a
18:47:31 <FunctorSalad> (which must be made precise of course)
18:47:36 <ivanm> Axman6: good-o
18:47:53 <copumpkin> I used to say goodie goodie gumdrops as a kid
18:48:01 <jaj> yeah with forall a
18:48:03 <ray> and that's why you grew up depraved
18:48:12 <Axman6> ivanm: if you're doing a PHD, i think you either get your own office, or a honours/PhD only lab
18:48:20 <ivanm> yeah
18:48:22 <copumpkin> mmm exclusivity
18:48:33 <Axman6> ivanm: you better let me chill in your office on hot days :P
18:48:38 * copumpkin has never spent any time in his office
18:48:45 <Axman6> becuase fark it's hot at the moment
18:48:47 <ivanm> Axman6: I know for maths here, people have the option of having linux (fedora usually), but most want windows and ssh into the linux machines
18:48:54 <copumpkin> eww
18:48:58 <ivanm> Axman6: heh, what, all 3 of them? :p
18:49:07 <ivanm> copumpkin: what's the eww for?
18:49:10 <copumpkin> windows
18:49:16 <ivanm> ahhh
18:49:29 <ivanm> copumpkin: for the most part, it's because they have to use outlook, etc.
18:49:33 <copumpkin> damn
18:49:44 <copumpkin> remind me not to go down under
18:49:52 <dibblego> I've been in that situation -- outlook in a vmware image
18:49:53 <ksf> issue9 is a fascist language, to the bone.
18:49:53 <ivanm> copumpkin: my supervisor is now associate dean of the new science faculty; the people running it are mac-lovers, but he uses windows
18:50:22 <ksf> _they_ can do parametric polymorphisms, simple coders can't.
18:50:23 <ivanm> thus they bought a mac, wiped OSX, put windows on it, and he does most of his work ssh'd in to a *nix machine (I think he still uses one of the old solaris boxes usually)
18:50:33 <copumpkin> wow
18:50:35 <ivanm> ksf: how does that make it fascist?
18:50:38 <FunctorSalad> ksf: sauce?
18:50:40 <ksf> not giving the people the same powers.
18:50:46 <ivanm> dibblego: well, the sysadmin does that
18:50:48 <copumpkin> fascist is the new word for "I don't like it"
18:51:00 <ivanm> dibblego: since some diagnostic tools are also windows-only :s
18:51:04 <ivanm> copumpkin: since when?
18:51:10 <copumpkin> since at least 2001
18:51:16 <ivanm> ksf: sounds like communism to me...
18:51:26 <copumpkin> communism is also the new word for "I don't like it"
18:51:29 <ivanm> communism: everything that is yours is mine, everything that is mine is not yours!
18:51:39 <ivanm> copumpkin: how about bolshie? :p
18:51:42 <ksf> uh, communism as has been in e.g. the ussr is also fascist.
18:51:51 <ksf> there's two dimensions to politics, not one.
18:51:56 <FunctorSalad> word fight :D
18:52:01 <copumpkin> ivanm: that would imply the people using those words to actually know what they're talking about
18:52:03 <ivanm> ksf: :o
18:52:12 <ivanm> copumpkin: yeah, and most don't
18:52:32 <copumpkin> so no, bolshie doesn't mean anything beyond its original meaning for now :)
18:52:35 <ivanm> I had a bunch of guys at high school that suddenly decided that communism was cool, as it was the end goal of socialism/marxism
18:52:37 <ivanm> idiots
18:52:39 <FunctorSalad> copumpkin: well "fascist" does apply sometimes. the word isn't limited to the nazis
18:52:39 <ksf> there's authoritan <-> anarchist and no market <-> unleashed market
18:52:56 <copumpkin> FunctorSalad: I typically apply it to the fascists anyway :)
18:53:14 <ksf> hitler was less right-wing than the current social democrats. vastly more authoritan, though.
18:53:27 * gwern hopes ghci can handle 169M of text
18:53:53 <copumpkin> 12 sticks!
18:54:05 <FunctorSalad> ^^
18:54:10 <copumpkin> (fagot!)
18:54:32 <copumpkin> (literally, a bundle of sticks)
18:54:42 <ksf> and if it weren't for economics, hitler and stalin would have made great pals.
18:55:05 <gwern> hm
18:55:06 <gwern> nope
18:55:06 <ivanm> copumpkin: isn't that faggot?
18:55:12 <copumpkin> ivanm: both spellings work
18:55:12 <gwern> it can't handle 169M of text
18:55:17 <ivanm> which is also another name for the bassoon
18:55:18 <copumpkin> ivanm: and the latter one is more recognized as offensive
18:55:24 <copumpkin> yep
18:55:25 <ivanm> copumpkin: bah
18:55:31 <ivanm> gay == happy
18:55:35 <copumpkin> lol
18:55:45 <copumpkin> you can fight the glacier of language
18:55:46 <ivanm> gwern: through the terminal, or running inside emacs or something?
18:55:50 <gwern> terminal
18:55:54 <copumpkin> it doesn't really care :P
18:56:00 <jaj> ksf: there has been no communism in the ussr
18:56:04 <ivanm> OK, I knew of a problem within emacs
18:56:11 <jaj> ksf: just because they say so doesn't make it ture
18:56:11 <ivanm> jaj: ummmm, yes there was...
18:56:12 <FunctorSalad> I think on 4chan the "fag" postfix has nearly lost is association with gayness
18:56:14 <jaj> *true
18:56:20 <ksf> jaj, I truly don't care.
18:56:22 <ivanm> jaj: communism == whatever the party says it is
18:56:25 <gwern> says the namefag FunctorSalad!
18:56:29 <copumpkin> #haskell-blah
18:56:34 <FunctorSalad> sorry
18:56:39 <ksf> ivanm, that'd make communism fascist by default.
18:56:50 <jaj> ivanm: in true communism there is no party
18:56:55 <bos> guys.
18:57:03 * ivanm desists
18:57:03 <ksf> there's been some takes on non-authoritaritan socialism, but they all got stomped.
18:57:27 <ksf> well vietnam, and (possibly, let's see) cuba look quite promising.
18:57:28 <jaj> ivanm: communism is living as a community, it's more like utopic anarchism
18:57:44 <jaj> if communism is what marx wrote
18:57:46 <bos> #haskell-blah please, gentlemen.
18:57:58 <jaj> bos: yeah I stop, sorry
18:58:25 <ksf> jaj, rest of you: http://www.politicalcompass.org/test
19:00:05 * bos resumes attempts to package ghc 6.12 RC1
19:00:55 <ivanm> jaj: it isn't
19:01:00 * ivanm really disists
19:01:02 <ivanm> *desists
19:01:07 <ivanm> bos: for what distro/OS?
19:01:14 <bos> fedora
19:01:16 <ivanm> bos: good luck, because I'm failing for gentoo :s
19:01:52 <bos> so far, it's all just been minor deviations in build process between 6.10 and 6.12 for me.
19:02:22 <ivanm> bos: yeah, but we have to package it in a reproducible way ;-)
19:02:35 <ivanm> bos: even more specifically, create a binary that can be used to build it
19:02:42 <ivanm> and I get a GHC panic when I try to do that :s
19:09:49 <nolrai_FG> Okay there was this paper about type theory, more precisely how a certain kind of tree had a ?natural tranformation? to a 7-tuple of a simpleler kind of tree. Someone here recomened it to me I think.
19:10:08 <nolrai_FG> Any Idea what it was called?
19:11:55 <nolrai_FG> Wow is there no one here?
19:11:58 <nolrai_FG> hmm
19:13:53 <ivanm> nolrai_FG: well, I just came back from getting something to eat...
19:14:02 <ivanm> and maybe no-one recalls what the paper was...
19:15:59 <nolrai_FG> Oh right my irc was being wierd, saying what happened yesterday.
19:16:28 <copumpkin> Veinor: that's why MIT sucks
19:16:56 <nolrai_FG> So whats a cool topic having to do with technology?
19:17:46 <copumpkin> http://www.realtouch.com/dispatcher/index
19:17:50 <copumpkin> oh wait, sorry
19:18:36 <copumpkin> http://en.wikipedia.org/wiki/Teledildonics
19:20:04 <red-agent> Is there any kind of `flatten :: [(a, a)] -> [a]`?
19:20:24 <SmurfOR> copumpkin, colour me enlightened :|
19:21:27 <nolrai_FG> copumpkin: Yeah, at least I wouldn't be talking about with the head of the CS department.
19:21:32 <aavogt> @hoogle (a,a) -> [a]
19:21:32 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
19:21:32 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
19:21:32 <lambdabot> Prelude snd :: (a, b) -> b
19:22:02 <BMeph> red-agent: Make one! :)
19:22:38 <red-agent> BMeph: Sure. I just needed to be sure I'm reinventing the wheel, before I make one =)
19:22:46 <red-agent> *I'm not
19:22:46 <BMeph> red-agent: concatMap (\(a,b) -> [a,b])
19:25:19 <BMeph> red-agent: I don't know that it's particular popular, or particularly tricky, so I don't see it being done up. Then again, someone made a Hackage write-up just of the "take a number and make a list of its digits" function...
19:25:48 <copumpkin> red-agent: how did you get the (a, a) in the first place?
19:26:00 <hydromoron> BMeph: fmap read . show?
19:26:20 <red-agent> copumpkin: By converting map to a list.
19:26:26 <copumpkin> ah
19:26:28 <hydromoron> > (fmap read . show) 131 :: [Int]
19:26:29 <BMeph> Haskell seems to be chock-full of wheel-reinventing. Then, one day gets tired of it, writes a paper about it and puts it on Hackage. ;)
19:26:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:26:30 <lambdabot>         against inferred ty...
19:26:34 <copumpkin> so you're putting the keys with the values?
19:26:42 <hydromoron> > (fmap (read . return) . show) 131 :: [Int]
19:26:43 <lambdabot>   [1,3,1]
19:26:50 <BMeph> one day *someone
19:27:02 <hydromoron> anyone else always use fmap instead of map?
19:27:02 <copumpkin> I dunno, the day itself might get tired of it too
19:27:07 <copumpkin> mmorrow does I think
19:27:15 <hydromoron> advantage: it doesn't break once you import Data.Map :/
19:27:23 <aavogt> it makes type errors less specific
19:29:42 <aavogt> then again, there's usually enough different possible interpretations of a type error that ghc doesn't tell you exactly what you got wrong without adding lots of type signatures, even without using fmap when map is sufficient
19:37:37 <ksf> type errors that are hard to track down are quite rare.
19:38:10 <ksf> ...well, at least if you start out with a sane number of type annotations, say, one for each top-level function.
19:38:37 <ksf> or one for each where-function in case you're going the one-module-one-function path.
19:39:57 <ksf> > toUpper . "amazing"
19:39:58 <lambdabot>   "AMAZING"
19:40:23 <FunctorSalad> ?
19:40:27 <FunctorSalad> @ty (.)
19:40:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:40:39 <ksf> lambdabot speaks caleskell.
19:41:09 <Draconx> so (.) = fmap ?
19:41:12 <ksf> yep.
19:41:19 <ksf> Functor ((->) a)
19:41:19 <Draconx> @ty map
19:41:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:41:41 <Draconx> yet not map = fmap :/
19:41:51 <copumpkin> :t (++)
19:41:53 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:42:10 <copumpkin> > Just Nothing ++ Just (Just Nothing)
19:42:12 <lambdabot>   Just (Just Nothing)
19:42:17 <ksf> usually restrained to lists, isn't it?
19:42:21 <copumpkin> yep
19:42:31 <FunctorSalad> {-# LANGUAGE Caleskell #-}
19:42:40 <ksf> makes a lot of sense, the monoidal version.
19:43:05 <ksf> > 1 ++ 2
19:43:06 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:43:06 <lambdabot>    `GHC.Num.Num t' arising ...
19:43:11 <ksf> > 1 ++ 2 :: Int
19:43:12 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
19:43:13 <lambdabot>    arising from a use of...
19:43:18 <ksf> > 1 ++ 2 :: Natural
19:43:19 <Draconx> the monoid operation should be (*), or (・), though :P
19:43:19 <lambdabot>   No instance for (Data.Monoid.Monoid Data.Number.Natural.Natural)
19:43:20 <lambdabot>    arising...
19:43:30 <ksf> aaaah.
19:43:32 <ksf> uh.
19:43:47 <ksf> somehow, that sucks.
19:44:01 <ksf> we'd need newtypes for *, + and ord.
19:44:21 <aavogt> > Sum 1 +++ Sum 3
19:44:22 <lambdabot>   Couldn't match expected type `a b c'
19:44:22 <lambdabot>         against inferred type `Data.Mo...
19:44:29 <aavogt> > Sum 1 ++ Sum 3
19:44:30 <lambdabot>   Sum {getSum = 4}
19:44:39 <FunctorSalad> ah the weakly Num/Monoid debate
19:44:44 <FunctorSalad> *weekly
19:44:59 <ksf> heh. I hardly get what a field is.
19:45:30 <ksf> but if you've even implemented the num hierarchy for anything, you'd know that the current way is utterly broken.
19:45:33 <FunctorSalad> I mean the debate about how to make (+) and (*) monoids such that (+) and (*) still work on numbers
19:46:05 <FunctorSalad> where the first "(+) and (*)" refers to the meanings and the second two the symbols
19:46:08 <FunctorSalad> :)
19:46:28 <ksf> I was rather thinking into the direction of making separate MultiplicativeMonoid/AdditiveMonoid classes.
19:46:36 <ksf> and of coures HasIdentity or something.
19:46:36 <BMeph> The main problem as I see it, is that monoids should be defined on the binary operator, not the types that the operator works on.
19:46:38 <FunctorSalad> yeah, that's one camp
19:46:53 <FunctorSalad> the other camp says Monoid should be (*), and (+) should be a method of ring
19:46:54 <ksf> ah no you need two hasIdentities if you've got two monoid classes.
19:47:10 <copumpkin> FunctorSalad: I think they should be in semiring, should I go into the third camp?
19:47:15 <FunctorSalad> :)
19:47:27 <FunctorSalad> copumpkin: seminearrng?
19:47:31 <copumpkin> lol
19:47:43 <BMeph> What's a good example of a non-numeric field? :)
19:47:44 <FunctorSalad> (no I don't know what that is but think I've seen it on hackage or so)
19:47:51 <copumpkin> the earliest two-operation structure you're willing to describe
19:47:57 <FunctorSalad> BMeph: numeric?
19:47:58 <Draconx> BMeph, the field of fractions over a polynomial ring?
19:48:27 <FunctorSalad> good one
19:48:39 <copumpkin> BMeph: what do you consider a number? :o
19:48:42 <FunctorSalad> IIRC even meromorphic functions form a field
19:48:46 <FunctorSalad> o_O
19:48:49 <ksf> wikipedia even mentions fields of functions
19:49:10 <copumpkin> beware of crop circles in your fields
19:49:39 <copumpkin> (yes, I'm aware that my jokes are terrible)
19:50:14 <ksf> they're cofunny?
19:50:25 <copumpkin> that's it, yep
19:50:31 <tensorpudding> cojokes are getting cotired
19:50:43 <Veinor> copumpkin: :P
19:50:47 <FunctorSalad> they're getting better and better?
19:50:50 <copumpkin> yeah
19:50:55 <copumpkin> Veinor: took you long enough
19:51:02 <Veinor> nah, more like 'that's why I shouldn't take courses I don't really want to'
19:51:17 <copumpkin> Veinor: that's what MIT is about though
19:51:32 <copumpkin> taking science courses you don't want to take
19:51:36 <Veinor> heh
19:51:45 <Veinor> I took the advanced version of this course when I really shouldn't have
19:51:50 <copumpkin> ah
19:52:17 <copumpkin> whoa, some structures are closed
19:52:22 <copumpkin> but this one's real closed: http://en.wikipedia.org/wiki/Real_closed_field
19:52:29 <FunctorSalad> lol
19:53:08 * ComonadDessert thinks it might almost be worthwile to defer reinventing the libraries until we get proper closed type funs and data kinds.
19:53:30 <copumpkin> and context families and aliases or whatever you want to call them
19:53:33 <Veinor> anyway
19:53:50 <ComonadDessert> typetype classclasses.
19:54:16 <ComonadDessert> i think that'd be kindschools.
19:54:18 <Veinor> so copumpkin, I remember you saying I should make Nimbers Applicative
19:54:22 <FunctorSalad> someone will demand the next level
19:54:25 <copumpkin> Veinor: yep!
19:54:40 <FunctorSalad> ComonadDessert: kindschools is cool
19:54:41 <copumpkin> newtype Nimber a = Nimber a -- :)
19:54:42 <Veinor> I agree, but.... how?
19:54:55 <copumpkin> Veinor: type Intiger = Nimber Integer
19:55:04 <FunctorSalad> ComonadDessert: but what is a "closed type function"?
19:55:05 <ComonadDessert> school even means collection, at least if you're talking about dolphins.
19:55:14 <ComonadDessert> well, our current ones are open.
19:55:14 <FunctorSalad> yes, I understood it as 'collection'
19:55:24 <copumpkin> FunctorSalad: a type family that you can close
19:55:27 <ComonadDessert> you can add to them in different modules.
19:55:35 <FunctorSalad> I made these in my type-settheory
19:55:45 <FunctorSalad> just use GADTs, not classes
19:55:57 <ComonadDessert> but I actually got the idea by looking at "class" and seeing that "school" is a thing that contains multiple classes.
19:56:10 <Veinor> copumpkin: ok, I'm not really sure about typeclasses and all that, so you'll have to walk me through that
19:56:15 <FunctorSalad> though the treatment of functions as subsets of (a,b) gets a bit messy
19:56:33 <Veinor> right now I have newtype Nimber = Nimber { fromNimber :: Integer }
19:56:34 <copumpkin> Veinor: oh, at that point you define instance Functor Nimber where fmap f (Nimber a) = Nimber (f a)
19:57:00 <copumpkin> and then instance Applicative Nimber where pure = Nimber; (Nimber f) <*> (Nimber a) = Nimber (f a)
19:57:26 <Veinor> ok, I'm a bit confused
19:57:28 <nolrai_FG> copumpink: ??
19:57:29 <ComonadDessert> that doesn't work with his newtype.
19:57:30 <copumpkin> then instance Num (Nimber Integer) where (+) = liftA2 xor
19:57:36 <ComonadDessert> his newtype has kind *.
19:57:39 <Veinor> yeah, that doesn't work with the newtype
19:57:48 <copumpkin> I already redefined your newtype
19:57:49 <copumpkin> up above
19:57:52 <copumpkin> :P
19:57:56 <ComonadDessert> newtype Nimber = Nimber a
19:58:08 <ComonadDessert> oh.
19:58:09 <ComonadDessert> wrong.
19:58:16 <ComonadDessert> listen to copumkin.
19:58:19 <ComonadDessert> colisten to me.
19:58:26 <copumpkin> Nimber is basically Identity
19:58:32 <Veinor> ok, Nimber a = Nimber a
19:58:33 <copumpkin> you just use it as a tag to treat it differently
19:58:43 <copumpkin> cause we love to discriminate
19:58:45 <Veinor> still getting kind errors
19:58:52 <FunctorSalad> @ty xor
19:58:52 <lambdabot> forall a. (Bits a) => a -> a -> a
19:58:59 <copumpkin> what's the code?
19:59:05 <FunctorSalad> call it XOROID
19:59:08 <copumpkin> lol
19:59:15 <FunctorSalad> that sounds much manlier than "Nimber"
19:59:25 <Veinor> ahh, now a different thing is type mismatching
19:59:28 <copumpkin> newtype XOROID a = XOROID a
19:59:35 <FunctorSalad> what is the multiplication btw?
19:59:57 <ComonadDessert> Addoid and Multoid
20:00:02 <copumpkin> lol
20:00:18 <Veinor> FunctorSalad: mex {a' b + a b' + a' b'} I think
20:00:30 <copumpkin> what are the primes?
20:00:38 <Veinor> a' < a, b' < b, mex means 'minimal element not in this set'
20:00:45 <Veinor> anyway
20:01:00 <FunctorSalad> do you really mean a singleton set?
20:01:08 <Veinor> no, it's a set comprehension :D
20:01:15 <FunctorSalad> ah
20:01:28 <Veinor> and it turns out that that distributes over xor
20:01:46 <Veinor> anyway, okay. I'm going to nuke my current Nimber.hs and start over, walk me through this
20:02:09 <copumpkin> okay, brainpower is low cause headache :/
20:02:19 <ComonadDessert> Oh, I once did a similar thing.
20:02:26 <ComonadDessert> I don't think I got it quite right, though.
20:03:05 <FunctorSalad> does "xor" have some arithmetical meaning?
20:03:25 <Veinor> not really.
20:03:27 * BlackM is strangely hungry for copineapple...
20:03:28 <FunctorSalad> apart from the definition by binary expansions of course
20:03:38 <copumpkin> BlackM: what's a copineapple?
20:03:43 <Veinor> it has meaning in CGT, though
20:03:53 <copumpkin> if you treat them as sets
20:04:00 <Veinor> copumpkin: I have newtype Nimber a = Nimber a and type Intiger = Nimber Integer
20:04:07 <copumpkin> yep
20:04:13 <Draconx> FunctorSalad, it's addition in Z_2[X].
20:04:21 <Veinor> ahhhhhh, that it is
20:04:23 <ComonadDessert> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12107#a12107
20:04:46 <Veinor> except nim-multiplication doesn't translate to multiplication over Z_2(x)
20:04:49 <Draconx> FunctorSalad, (the ring of polynomials with coefficients in Z_2).
20:04:51 <Veinor> but anyway!
20:05:01 <FunctorSalad> Draconx: I meant this "xor" on integers
20:05:08 <Draconx> FunctorSalad, yes.
20:05:11 <copumpkin> they're intigers!
20:05:27 <ComonadDessert> xor has interesting properties.
20:05:31 <FunctorSalad> Draconx: but Integer isn't Z_2[X] ;)
20:05:49 <ComonadDessert> like x `xor` x = 0 and that encryption thingie.
20:06:00 <Draconx> FunctorSalad, map each bit to a coefficient in a polynomial.
20:06:01 <ComonadDessert> yeah, xor.
20:06:20 <FunctorSalad> Draconx: yes, I'm just wondering why to use integers in the first place then
20:06:23 <ComonadDessert> I loved to confuse my assembly tutor by writing things like xor eax, eax
20:06:51 <tensorpudding> is it pronounced EX-or or KSOR or something else
20:07:02 <Veinor> I pronounce it EX-or.
20:07:12 <Veinor> Or sometimes zor.
20:07:23 <c_wraith> who is confused by that, who's even mildly competent at assembly?
20:07:24 <FunctorSalad> KSOR
20:07:25 <tensorpudding> lately i've been pronouncing fmap as one syllable
20:07:35 * copumpkin fmaps to the thought of that
20:07:38 <Veinor> haha
20:07:40 <FunctorSalad> ^^
20:07:45 * ComonadDessert pronouces it ixxor.
20:07:48 <ComonadDessert> german heritage.
20:07:52 <FunctorSalad> tensorpudding: how's that possible?
20:08:03 <FunctorSalad> ComonadDessert: I used to do that too
20:08:14 <tensorpudding> it sounds odd
20:08:30 <FunctorSalad> I don't know the exact def of 'syllable'
20:08:36 <ComonadDessert> but ksor is common in german, too.
20:08:36 <Draconx> FunctorSalad, well, xor is not a one of the usual operations on integers.  addition of integers is quite a different beast.
20:08:48 <FunctorSalad> but I'm not sure it is one syllable even if you don't pronoune the 'f' as 'efff'
20:08:51 <tensorpudding> what i mean is, that you pronounce the fm consonant cluster as one sound
20:08:56 <Veinor> yeah
20:08:58 <tensorpudding> instead of saying f and then map
20:09:02 <Veinor> which isn't usual in English.
20:09:03 <copumpkin> ksor reminds me of kuso in japanese
20:09:07 <tensorpudding> obviously not
20:09:23 * BMeph likes "ECK-ees-or"
20:09:34 <tensorpudding> but there are lots of consonant clusters that appear in, say, russian or german, which don't exist in english
20:10:00 <ComonadDessert> if somoene ever does a ffi binding and needs flag support, have a look at that code I posted. I noticed that something's important is missing when you end up using it (don't remember what exactly right now), but it's a cool thing to have in general.
20:10:12 <Veinor> copumpkin: okay, yeah, that's working
20:10:16 <copumpkin> yay
20:10:19 <ComonadDessert> russian's even more extreme than german.
20:10:28 <ComonadDessert> well it doesn't have "du schluchtzt"
20:10:35 <ComonadDessert> s/t//
20:10:45 <Veinor> you sluts?
20:10:46 <FunctorSalad> that is german?
20:10:56 <copumpkin> lol
20:10:56 <ComonadDessert> schluchzen means to sob.
20:10:57 <stoop> -blah
20:10:59 <tensorpudding> russian has some nice ones
20:11:04 <FunctorSalad> not "du schluchtzst"?
20:11:11 <BMeph> Dutch, too. :)
20:11:17 <copumpkin> #haskell-blah, too
20:11:25 <Cale> http://analogical-engine.com/wordpress/ -- new post :)
20:11:33 <ComonadDessert> FunctorSalad, do I have to decide without looking it up?
20:11:48 <tensorpudding> the russian letter ve is put in extreme situations
20:12:10 <ComonadDessert> russian has some very different combinations, too. like "kt".
20:12:15 <tensorpudding> yes
20:12:20 <tensorpudding> kto
20:12:23 <FunctorSalad> tensorpudding: letter of last resort?
20:12:32 <ComonadDessert> or gde
20:12:48 <Veinor> copumpkin: the one problem is that I can't do instance Num Nimber
20:12:59 <copumpkin> Veinor: you can with TypeSynonymInstances
20:13:09 <Cale> Less diagrams, more inequalities this time. I almost feel like making a rough graph with a monotone function on it to help keep things straight.
20:13:10 <copumpkin> but that's why I wrote instance Num (Nimber Integer)
20:13:14 <Veinor> ahh
20:13:45 <Veinor> haskell seems to be very extension-y.
20:13:50 <copumpkin> yep
20:13:58 <copumpkin> or you can just avoid it and do what I wrote
20:14:23 <FunctorSalad> copumpkin: for newtypes?
20:14:34 <FunctorSalad> or is it a tysyn now
20:14:40 <copumpkin> for type Intiger = Nimber Integer
20:15:13 <Veinor> that fails though
20:15:20 <copumpkin> oh no
20:15:21 <BMeph> Another yummy Russian consonant combo: zdr
20:15:23 <Veinor> Illegal instance declaration
20:15:34 <copumpkin> what's the instance declaration?
20:15:35 <tensorpudding> yeah, that's a fun one
20:15:51 <Veinor> instance Num (Nimber Integer) where (+) = liftA2 xor
20:16:06 <Veinor> brb
20:16:21 <FunctorSalad> flexible instances or sth
20:16:31 <FunctorSalad> the error should tell you actually
20:17:23 <copumpkin> yeah, I think it needs that
20:17:28 <aavogt> won't that work for  instance Bits a => Num (Nimber a) ... (which should be legal H98). Or are there some other reasons the instance must only be for Integer?
20:17:37 <copumpkin> "In Haskell 98, instances may only be declared for a data or newtype type constructor applied to type variables"
20:17:41 <Veinor> ok, back
20:17:57 <copumpkin> aavogt: that works too, I guess, but I wasn't sure what else he wanted to do with it
20:18:21 <Veinor> ok, anyway
20:20:30 <Veinor> ahhh, now I see what it is, when I write Nimber 5 + Nimber 8 it's not coercing it into integers for whatever reason
20:21:38 <FunctorSalad> disable DMR, then it will be type Num a => Nimber a
20:21:44 <Veinor> DMR?
20:21:51 <FunctorSalad> monomorphism restriction
20:22:04 <ComonadDessert> free yourselfs from mental slavery! none but -XTypeFamilies can free you!
20:22:05 <Veinor> how do I do that?
20:22:06 <aavogt> isn't that one undecidable?
20:22:14 <ComonadDessert> er emancipate yourselves.
20:22:32 <FunctorSalad> {-# LANGUAGE NoMonomorphismRestriction #-}
20:22:37 <FunctorSalad> Veinor: on top of file
20:22:49 <FunctorSalad> not sure if that's your problem actually, though
20:22:54 <copumpkin> aavogt: only if you wanted to write that as an instance
20:23:02 <Veinor> still causes it to fail
20:23:03 <ComonadDessert> aavogt, nope, nimber isn't a typeclass, so you could'nt write Nimber a => Num a
20:23:03 <FunctorSalad> but I always add it
20:23:15 <Veinor> Nimber 5 + Nimber 8
20:23:17 <copumpkin> Veinor: "it'z b0rked" isn't a very good way to get help ;)
20:23:26 <Veinor> No instance for (Num (Nimber t)) arising from a use of '+'
20:23:48 <aavogt> ah, I see now
20:23:49 <copumpkin> hmm
20:23:49 <FunctorSalad> did you declare (Nimber t) to be Num for all Nums?
20:23:49 <ComonadDessert> try to give a "Nimber Integer" annotation.
20:24:01 <copumpkin> yeah, you might need the instance aavogt suggested
20:24:07 <copumpkin> rather than the specific one I gave
20:24:20 <copumpkin> if you want to do it without more type annotations
20:24:29 <ComonadDessert> instance Num t => Num (Nimber t)
20:24:38 <copumpkin> and Bits t
20:24:39 <FunctorSalad> (will need Bits too)
20:24:47 <FunctorSalad> then it should work for polymorphic nimbers
20:24:51 <Veinor> that's not true, though
20:24:52 <aavogt> this is presumably why FlexibleInstances isn't in haskell 98?
20:25:02 <aavogt> @src Bits
20:25:03 <lambdabot> Source not found. My mind is going. I can feel it.
20:25:07 <Veinor> just because Num t doesn't mean that Num (Nimber t)
20:25:23 <Veinor> in particular, I don't even know how to define Nimber t for ts that aren't Integers
20:25:24 <copumpkin> this is all a hack anyway
20:25:28 <Veinor> heh
20:25:35 <copumpkin> to let you use liftA2 xor
20:25:36 <copumpkin> shh ;)
20:25:38 <tensorpudding> the integers were a hack job
20:25:43 <FunctorSalad> Veinor: the point is just that you must have "instance .... => Num (Nimber t)"
20:25:53 <FunctorSalad> the resolver doesn't care about the ....
20:26:02 <FunctorSalad> you can have "Bits" there too
20:26:48 <copumpkin> Veinor: a much cleaner approach would be to return to your original Nimber newtype, and to simply define liftN f (Nimber n) = Nimber (f n) and liftN2 f (Nimber a) (Nimber b) = Nimber (f a b)
20:27:03 <Veinor> copumpkin: heh, I think I'll do that
20:27:07 <copumpkin> :P
20:27:15 <copumpkin> then instance Num Nimber where (+) = liftN2 xor
20:27:20 <FunctorSalad> o_O
20:27:29 <Veinor> -- I really don't feel like messing around with Applicative
20:27:30 <Veinor> :P
20:27:30 <FunctorSalad> so you don't want any `a's other than Integer?
20:27:44 <Veinor> FunctorSalad: You can't define nimbers over anything else.
20:27:44 <copumpkin> nope, this was all a hack I suggested so he could use applicative
20:27:55 <FunctorSalad> instance (Integer ~ t) => Num (Nimber t)
20:27:57 <FunctorSalad> that will work
20:28:01 <Veinor> in particular, you can't define rational nimbers since they're already closed under division
20:28:01 <ComonadDessert> Veinor, probably everything that is Bits a.
20:28:06 <FunctorSalad> (but you won't be able to define any other instances)
20:28:11 <ComonadDessert> but starting out with Integers won't hurt.
20:28:21 <ComonadDessert> rationals don't have bits defined.
20:28:36 <Veinor> they also need to be well-ordered
20:28:42 <FunctorSalad> it's a funny way to lure the resolver down one path
20:28:47 <Veinor> and countable
20:28:56 <Veinor> what is in Bits anyway other than Integer and such?
20:29:04 <copumpkin> not much
20:29:05 <FunctorSalad> Int,Bool,Word
20:29:05 <ComonadDessert> similar, but bounded types.
20:29:09 <Veinor> ah
20:29:50 <FunctorSalad> Veinor: try the "Integer ~ t" if you really don't want any other Num Nimber instances
20:30:44 <aavogt> FunctorSalad: what does '~' in an instance head mean?
20:30:52 <FunctorSalad> aavogt: equality
20:30:55 <Cale> My new article just so happens to be about the stuff I was talking about earlier.
20:31:02 <ComonadDessert> ~ is spj for type equality
20:31:06 <Veinor> I think I'll just go with copumpkin's hack
20:31:17 <Veinor> with liftN and liftN2
20:31:26 <FunctorSalad> yes mine is an even worse hack for being able to keep with liftA2 ;)
20:31:37 <bos> ivanm: where do you get stuck in the ghc 6.12 build?
20:31:55 <Cale> I wish that PNGs could be baseline-aware for insertion into text.
20:31:57 <bos> ivanm: i can't figure out how to build or install the documentation.
20:32:14 <copumpkin> Cale: very nice series on adjunctions so far :)
20:32:17 <nolrai_FG> Cale: PNG?
20:32:24 <Cale> nolrai_FG: the image format
20:32:29 <Veinor> time to git rever
20:32:30 <Veinor> t
20:32:37 <copumpkin> Veinor: yay!
20:32:42 <FunctorSalad> Cale: hmm are images really the way to do this?
20:32:50 <Cale> FunctorSalad: Well, that's true.
20:32:52 <Veinor> er, git reset. whatever.
20:33:02 <copumpkin> git reset --ILIKEITHARD
20:33:10 <FunctorSalad> Cale: there are all these things like JSMath and MathML, but I haven't tried them either
20:33:19 <Cale> FunctorSalad: But in general it would be a nice thing to be able to specify that if an image is to be inserted into text, how it should align itself.
20:33:28 <nolrai_FG> Cale: What artical?
20:33:30 <FunctorSalad> (JSMath has tex syntax afaik?)
20:33:36 <Cale> http://analogical-engine.com/wordpress/
20:34:27 <ComonadDessert> oh, I've got to remember the word "catalogism"
20:34:28 <ddarius> Someone should make a Num instance for surreal numbers .....
20:34:38 <ddarius> @wn catalogism
20:34:40 <lambdabot> No match for "catalogism".
20:34:52 <ComonadDessert> all those unenlightened ones will thing it's something like a catalogue.
20:35:10 <aavogt> so I'm not familiar with TypeFamilies
20:35:11 <copumpkin> Cale: zomg, there's a typo in one of Robin's entries!
20:35:13 <FunctorSalad> ddarius: my memory is a bit hazy. data Surreal = Surreal [Surreal] [Surreal] ?
20:35:15 <ComonadDessert> it's like "eloquent", which means "talks a lot of nonsense"
20:35:18 <Cale> copumpkin: which one?
20:35:28 <copumpkin> Permutations, third word in
20:35:34 <copumpkin> http://analogical-engine.com/?p=6
20:35:34 <Cale> ah, that one :)
20:35:58 <Cale> Yeah, I sent her an email about it the other day.
20:36:09 <ddarius> FunctorSalad: Something like that.
20:36:38 <copumpkin> Cale: does she haskell too?
20:36:41 <Cale> yep
20:36:41 <FunctorSalad> I guess you'd want smart constructors to keep the lists ordered
20:37:06 <Cale> When I taught her Haskell, she claimed to have invented functional programming as a child. :)
20:37:12 <copumpkin> :o
20:37:15 <FunctorSalad> who?
20:37:20 <copumpkin> Robin!
20:37:34 * ComonadDessert invented declarative programming as a child.
20:37:35 <Cale> Robin, the person who I am doing this blog with :)
20:38:00 <ComonadDessert> problem being: I had a very clear image of what the problem definition was, and no idea how to solve it.
20:38:29 <Cale> She had me teach her via a series of exercises, and I basically had her implement lots of standard libraries, mtl, and so on :)
20:38:54 <SubStack> are any of those euphemisms?
20:38:59 <copumpkin> lol
20:39:01 <Cale> no
20:39:13 <FunctorSalad> Cale: lol @ the "Categories" list
20:39:33 <Cale> FunctorSalad: yeah, I decided to take it literally
20:39:52 <copumpkin> Rel gets no love
20:40:12 <Cale> I'm adding them as we have articles about them
20:41:46 * ComonadDessert misses Hask
20:42:01 <Cale> Yeah, we plan to write about Haskell too :)
20:44:12 <FunctorSalad> the laws for the various constructions in Hask even work out if you use Moral Equality
20:44:16 <ComonadDessert> http://jacobian.org/writing/great-documentation/
20:44:32 <ComonadDessert> just wanted to throw that one to the masses, generically
20:45:40 <copumpkin> I like his typography
20:45:52 <copumpkin> although the smallcaps kinda suck :/
20:45:57 <copumpkin> that's browser's fault though
20:45:59 <FunctorSalad> btw why is haskellwiki nearly dead?
20:46:12 <FunctorSalad> well maybe not dead, but little activity
20:46:27 <ComonadDessert> or the font's.
20:46:38 <ComonadDessert> some fonts have abysmal small caps.
20:47:03 <Cale> Hmm, he doesn't like automatically generated documentation, but it's rarely the case that I can imagine better documentation for a Haskell library than what Haddock produces, if the thing is well-commented.
20:47:04 <ComonadDessert> basically, capital letters at baseline size, even without stroke strength tuning.
20:47:21 <ComonadDessert> if it's well-documented, yes.
20:47:41 <ComonadDessert> if there's either no or bad comments and no source links, thei're worthless.
20:47:53 <FunctorSalad> I'd like to see more diagrams in documentation to quickly give the big picture
20:48:00 <FunctorSalad> (when appropriate)
20:48:07 <Cale> Well, even with no comments, I usually find Haddock to be pretty useful.
20:48:35 <ComonadDessert> also, there are many cases where you can have as many per-function and per-module docs, if you don't have a text that gives you the big picture and a few examples you get nowhere.
20:48:44 <Cale> I guess our type signatures are much more expressive than the type signatures in Java.
20:49:08 <Cale> So even just seeing a list of functions and their type signatures is more satisfying.
20:49:22 <ComonadDessert> maybe that's because you're one of those guys that actually considers a type annotation that mentions zygohistomorphic prepromorphisms as documentation.
20:49:29 <Cale> heh
20:49:44 <sjanssen> what is supposed to stand-in for auto-documentation?  Prose is no good for reference documentation
20:50:21 <ComonadDessert> I think he's complaining about auto-generated docs without handwritten comments.
20:50:39 <ComonadDessert> they're worse than source because you have even less information.
20:50:49 <Cale> I think a crucial step in my process of falling in love with type signatures as documentation was the simple fact that if you need a value of type A, you don't just look for functions whose type looks like (... -> A), you also look for ones whose type is (A -> ...) -> ...
20:51:33 <ComonadDessert> that should actually be a part of haskell tutorials.
20:52:01 <ComonadDessert> also makes bind's signature easier to grok for beginners.
20:53:49 <blackh> Haddock comments are needed to deal with the fact that type signatures are a very abstract way to describe the function.
20:54:15 <ComonadDessert> they wouldn't be as abstract if people would use other variables than a, b and c.
20:54:37 <ComonadDessert> length :: [xs] -> Int
20:54:51 <Cale> I think that's a strange example actually
20:55:05 <Cale> (but I agree with the overall point)
20:55:30 <ComonadDessert> so do I, but It examplifies using the same convention for value and type bindings.
20:56:03 <ComonadDessert> [(xs, ys)] == [ts]
20:56:53 <Cale> So apparently there are some users of my AStar library.
20:57:04 <ComonadDessert> also, a very important point, documenting stuff argument by argument.
20:57:12 <Cale> I got an email from some students in Spain the other day who asked for some examples :)
20:57:32 <Cale> Perhaps I should add the example I gave to the Haddock comments
20:58:00 <ComonadDessert> oh, yes, I wanted to look at that and see how good it maps to an optimally-efficient implementation for vanilla square 2d maps.
20:58:26 <Cale> Hehe, probably the performance is terrible, but I would be interested to know.
20:58:47 <Cale> I did go to the trouble of using a priority search queue to implement it.
20:58:55 <ComonadDessert> hmm yes. I don't think you're using binominal heaps for the open list...
20:59:56 <ComonadDessert> but having the whole thing abstracted over graphs that support the distance heuristic is very, very, handy.
21:00:02 <Cale> The structures I'm using are asymptotically good.
21:00:37 <Cale> Yeah, I've actually only tested the thing on infinite graphs.
21:01:17 <Cale> Because it's so much easier to define adjacency functions on (Integer, Integer) than it is to actually represent a specific finite graph somehow :)
21:01:27 <ivanm> Cale: we really should keep going with that generic graph thingy
21:01:34 <Cale> Watch it completely fail when the graph turns out to be finite ;)
21:01:37 <ComonadDessert> spherical maps would be great, but afair there's just no sane way to grid a sphere.
21:01:58 <Cale> Is there something wrong with citeseer?
21:02:12 <ComonadDessert> they're apparantly moving stuff to some beta server.
21:02:14 <FunctorSalad> spherical maps of what?
21:02:19 <ComonadDessert> it's linked from the citeulike pages.
21:02:25 <ivanm> ComonadDessert: haven't they been doing that for a while?
21:02:30 <Cale> here we go: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.18.1149&rep=rep1&type=pdf
21:02:31 <ComonadDessert> like the earth.
21:02:43 <Cale> That paper documents the data structure I used.
21:02:58 <ComonadDessert> settlers has something not entirely unlike like that, but they use hexgrids and just repeat stuff on all sides.
21:03:09 <Cale> So, it is quite similar to a binomial heap.
21:03:20 <ComonadDessert> imagine an rts that actually spans a whole planet and you actually see a sphere when you zoom out.
21:04:20 <FunctorSalad> do RTSs really need a grid?
21:04:26 <ComonadDessert> nope
21:04:38 <ComonadDessert> well they need a coordinate system, that's for sure.
21:04:57 <ComonadDessert> and somehow square buildings have to line up if you plant them.
21:05:15 * kmc thought you were all talking about run-time systems and was very confused
21:05:31 <FunctorSalad> ComonadDessert: to satisfy obsessive tendencies of the players? ;)
21:05:53 <FunctorSalad> kmc: hehe
21:06:09 <ComonadDessert> but not representing the map as a lattice has certainly cool advantages.
21:06:34 <kmc> Program terminated: require more Vespine gas
21:06:50 <ComonadDessert> industrial-strength astars also do more stuff, like pre-calculating paths at different resolutions.
21:08:48 <FunctorSalad> ComonadDessert: RTS on the projective plane :D
21:08:50 <ComonadDessert> either that, or supporting dynamic updates of calculated paths as the world changes (i.e. a unit happens to be in your way). otherwise, the sheer number of paths calculates is going to kill performance.
21:10:08 <ComonadDessert> but, actually it might be wise to not use a* at all in very close proximity of the unit, just for longer stuff.
21:10:13 <Cale> My life for Aiur!
21:10:39 <ComonadDessert> most stuff I know about this completely ignores all that nice swarm stuff.
21:10:39 <Cale> My orientability for Aiur!
21:11:37 <FunctorSalad> this might make for some quite fun confusion
21:11:52 <FunctorSalad> I don't even really get the topology of that thing
21:12:15 <Cale> You ought to be familiar with it because you are constantly staring at it, in a sense :)
21:12:31 <ComonadDessert> the overview map should be a dynmaxion map that streches the borders of those vertices that are kinda adjectant to line up, and automatically refolds itself as you scroll across.
21:12:39 <FunctorSalad> Cale: hmm but just a contractible subset
21:12:45 <Cale> That's true.
21:13:07 <ComonadDessert> http://en.wikipedia.org/wiki/File:Dymaxion_map_ocean2.png
21:13:20 <Cale> Also, the *rays* through the origin aren't really the same as the lines
21:13:55 <FunctorSalad> I guess the simplest representation is "a disk with opposite points at the boundary identified"?
21:15:25 <nolrai_FG> Eh, i find the prjective plane fairly intuitive.
21:16:36 <nolrai_FG> FunctorSalad: sure.
21:17:55 <FunctorSalad> nolrai_FG: but do you find it intuitive why it has fundamental group Z/2 ? (IIRC)
21:18:00 <nolrai_FG> God I am totaly blanking on interesting topics about technology.
21:18:10 <nolrai_FG> fundamental group?
21:18:18 <ComonadDessert> I rather dream of rts in a klein bottle.
21:18:43 <FunctorSalad> nolrai_FG: the equivalence-classes-of-paths one
21:19:21 <nolrai_FG> So every paths or closed paths?
21:19:45 <nolrai_FG> er, paths or closed paths?
21:19:48 <FunctorSalad> uh there are some variations, but let's say closed path with some fixed start/end-point
21:20:01 <FunctorSalad> (and homotopy relative endpoints)
21:20:42 <nolrai_FG> Z/2 is that integers mod 2. so theres only two diffent paths. hmm that is odd.
21:21:18 <FunctorSalad> yeah :)
21:21:23 <nolrai_FG> Whats the fundamental group for R ^2?
21:21:34 <dmwit> Z
21:21:47 <dmwit> (Just a guess.)
21:22:16 <nolrai_FG> I would have guseed the trivial group.
21:22:37 <dmwit> Well, you can make a path with any turning number, right?
21:22:45 <FunctorSalad> the trivial group
21:23:07 <FunctorSalad> dmwit: maybe you're thinking of R^2 with a hole?
21:23:11 <FunctorSalad> then it's Z
21:23:19 <dmwit> Maybe I am.
21:23:34 <FunctorSalad> if there's no hole you can just contract the loops
21:24:00 <nolrai_FG> Okay. hmm so what does the other path look like? the one that doesn't contract.
21:24:40 <ComonadDessert> hum. representing maps that are merely some kind of (infinite) plane with additional height information seems easy, but stuff gets involved as soon as you want to have a tunnel.
21:25:16 <ComonadDessert> but they say that all graphs are embeddable into 3 dimensions.
21:25:27 <nolrai_FG> ComonadDesert: Hmm yes it does.
21:25:51 <FunctorSalad> you probably want a manifold then
21:26:45 <FunctorSalad> nolrai_FG: I think it's the path starting from the center and walking straight ahead in some direction until you arrive at the center again
21:26:47 <ComonadDessert> you can completely forget height information then, as you need a more powerful representation for the base geometry, anyway.
21:28:19 <FunctorSalad> so in the "lines in R^3" picture that would be "rotate the line around 180 degrees"
21:28:25 <FunctorSalad> which makes the Z/2 thing somewhat plausible
21:29:23 <nolrai_FG> Why doesn't it contract down to a point though?
21:30:04 <nolrai_FG> Hmm, is infinity sort of sticky?
21:30:15 <FunctorSalad> :)
21:30:51 <FunctorSalad> infinity?
21:30:59 <nolrai_FG> the horizen
21:31:23 <FunctorSalad> ah that's yet another picture
21:31:34 <FunctorSalad> R^2 with a semicircle at infinity
21:31:48 <nolrai_FG> sorry they sort of blur together for me.
21:32:28 <FunctorSalad> yes it seems like it's sticky, but if you go through it twice, it cancels out ;)
21:32:30 <ivanm> does anyone know of any good uses of runInteractiveCommand in any libraries I can look at?
21:32:41 <ivanm> I think what I've got here is rather kludgy... :s
21:33:57 <FunctorSalad> ivanm: actually "readProcess" in System.Process shows you how to properly do it
21:34:03 <nolrai_FG> hmm I need to learn me some topology, cause in pure geometric sense that isnt makeing any sense to me.
21:34:07 <ComonadDessert> gragh I really can't concentrate on math while inventing the story on how the universe happened to collapse into those geometric beasts.
21:34:11 <FunctorSalad> (fork a thread to read from the programs outpipe)
21:34:11 <ivanm> FunctorSalad: good-o; thanks!
21:34:24 <ComonadDessert> probably something involving the LHC.
21:34:59 <FunctorSalad> nolrai_FG: in the "lines in R^3" picture it makes more sense I think
21:35:01 <copumpkin> Veinor: WTF?
21:36:16 <ivanm> FunctorSalad: what I'm hoping to do is stop forking a thread to redirect error output to stderr and instead use it to return an IO (Either String a) rather than an IO (Maybe a)
21:37:11 <ygd-coder> ghc is saying that it can't find the module Text.Regex
21:37:26 <nolrai_FG> right its the path that goes 180. I was thinking 360.
21:37:50 <FunctorSalad> ivanm: fork two threads to read both the out and err
21:37:58 <ivanm> ahh, right
21:38:01 <FunctorSalad> then decide whether to return Left or Right
21:38:07 <ivanm> I see what it's doing now... I thought it returned them intermingled
21:38:24 <ivanm> hmmm.... myabe readProcessWithExitCode...
21:38:30 <ygd-coder> I quote "Could not find module `Text.Regex'"
21:38:53 <ygd-coder> do I not have some package installed?
21:38:54 <ivanm> ygd-coder: do you have regex-base installed?
21:39:10 <ygd-coder> installing it now
21:39:23 <ygd-coder> you mean libghc-rejex-base?
21:40:04 <Veinor> copumpkin: I honestly have no clue either
21:40:14 <ivanm> ygd-coder: regex, not rejex :p
21:40:18 <ivanm> but yes, that's probably it
21:40:29 <ivanm> ygd-coder: you'd then need an actual regex engine such as regex-posix
21:40:56 <ygd-coder> okay
21:40:58 <ivanm> FunctorSalad: any idea what this CreatePipe the System.Process code uses is?
21:41:21 <FunctorSalad> ivanm: :info CreatePipe? ;)
21:41:35 <FunctorSalad> IIRC it just tells it whether to create a pipe
21:41:39 <nolrai_FG> Hey whats the paper that describes how to take the derivative of a type?
21:41:56 <ivanm> it's not exported
21:42:15 <ivanm> nolrai_FG: with respect to what variable? :p
21:42:44 <ygd-coder> ivanm: it still cant find it even after I installed them
21:42:54 <ivanm> ygd-coder: "ghc-pkg list | grep -i regex"
21:42:56 <FunctorSalad> ivanm: data StdStream = Inherit | UseHandle GHC.IOBase.Handle | CreatePipe
21:43:04 <ivanm> ygd-coder: you might need to restart ghci
21:43:16 <ygd-coder> ivanm: i'm using runhaskell/runghc
21:43:18 <FunctorSalad> it tells createProcess what to do with the in (/out/err) of the process
21:43:23 <ivanm> ygd-coder: OK
21:43:27 <nolrai_FG> ivanm: :p Its some cool almost understandable type theory. Says that makeing a zipper is a derivative.
21:43:30 <ivanm> FunctorSalad: *nod*
21:43:38 <ygd-coder> ivnam: random-1.0.0.1, regex-base-0.93.1, regex-posix-0.93.1, rts-1.0,
21:43:56 <ivanm> ygd-coder: you might need the 0.3x versions
21:44:10 <ygd-coder> ivanm: how do i get those?
21:44:18 <nolrai_FG> Like the chain rule, and sum rule and even the polynomial rules work.
21:45:13 <FunctorSalad> nolrai_FG: google "one-hole context", IIRC that word appears in the paper ;)
21:45:15 <BMeph> http://www.cs.nott.ac.uk/~ctm/diff.pdf
21:45:29 <FunctorSalad> http://scholar.google.com/scholar?hl=en&lr=&safe=off&c2coff=1&q=%22one-hole%20context%22&btnG=Search
21:46:24 <nolrai_FG> Thank you!
21:46:28 <ivanm> ygd-coder: dunno how your distro packages them :s
21:47:02 <ygd-coder> ivanm: is there a download site (i use ubuntu)
21:47:10 <ComonadDessert> oooooh http://www.dimensions-math.org/Dim_E.htm
21:47:16 <ivanm> ygd-coder: no idea
21:47:24 <tensorpudding> there is always cabal
21:47:32 <ivanm> tensorpudding: you mean cabal-install ?
21:47:37 <tensorpudding> yes
21:47:39 <ivanm> cabal is a library
21:47:55 <tensorpudding> that's unfortunate
21:49:11 <ivanm> why?
21:49:12 <jmcarthur> what is?
21:49:14 <ygd-coder> :ivanm I installed libghc6-regex-compat and it seems to work now
21:49:20 <bos> ygd-coder: ubuntu has all the packages broken out
21:49:27 <ygd-coder> ivnam: thanks for your help
21:49:38 <ivanm> no worries
21:52:42 <tensorpudding> why do we have cabal and cabal-install?
21:53:05 <ivanm> tensorpudding: Cabal == Common Architecture for Building Applications and LIbraries
21:53:14 <ivanm> it's what's actually used to build packages, etc.
21:53:42 <ivanm> cabal-install is a library that uses cabal and the info in the .cabal files from each project to build things automagically for you
21:53:49 <Cale> I guess it's a good question as to why cabal install is distributed separately from the Cabal library
21:54:04 <Cale> cabal-install is the program, Cabal is the library...
21:54:13 <ivanm> Cale: too many deps
21:54:23 <ivanm> that's why it's separate
21:55:03 <ivanm> Cale: they were originally going to have to put it into the library, but since it requires Network, etc. ...
21:55:48 <tensorpudding> is it considered better to use distro packages or cabal?
21:56:10 <ivanm> tensorpudding: I prefer distro packages
21:56:14 <ivanm> as they bring in C libs, etc.
21:56:33 <tensorpudding> the problem with distro packages is that you must use the version of GHC in your distro.
21:56:43 <tensorpudding> Which, for debian, is 6.8.2 I believe.
21:56:55 <ivanm> tensorpudding: well, I'm considering "nice" distros ;-)
21:57:12 <ivanm> tensorpudding: there's the platform available for Debian IIRC...
21:57:15 <tensorpudding> For most languages, having a version of the compiler that is a year old is not a problem.
21:57:29 <reltuk> why does arch have such good hsakell support?  is that just a few motivated haskellers who like it?
21:57:34 <tensorpudding> But, GHC seems to evolve rapidly
21:57:48 <ivanm> reltuk: pretty much
21:58:20 <tensorpudding> I have 6.10.1, which has a version of base too old for some packages.
21:58:28 <ivanm> tensorpudding: how?
21:58:38 <tensorpudding> Specifically, agda.
21:58:38 <ivanm> it has base 4...
22:00:04 <ivanm> hmmmm...
22:00:14 <ivanm> which version of base comes with 6.10.1 ?
22:00:20 <tensorpudding> 4.1.0.0
22:00:30 <tensorpudding> agda wants 4.2.0.0, it seems
22:00:51 <ivanm> tensorpudding: it wants >= 4.1 < 4.2
22:01:30 <tensorpudding> wait, now i'm confused
22:01:32 <tensorpudding> i get an error
22:02:44 <tensorpudding> i have 4.1.0.0 but it wont install agda because it's excluded
22:02:55 <tensorpudding> for a top level dependency base -any
22:03:02 <ivanm> how are you installing agda?
22:03:19 <tensorpudding> through cabal-install
22:03:40 <ivanm> "cabal install agda" ?
22:03:45 <tensorpudding> yes
22:04:28 <ivanm> weird
22:04:35 <ivanm> tensorpudding: have you done a "cabal update" recently?
22:04:40 <tensorpudding> yes
22:04:53 <tensorpudding> i do an update every time i want to install a package
22:05:46 <ivanm> which version of agda is it wanting to install?
22:06:02 <tensorpudding> 2.2.4
22:06:28 <ivanm> tensorpudding: can you paste the entire build output somewhere?
22:08:51 <tensorpudding> http://pastebin.com/m6e8fa6e3 there it is
22:10:19 <tensorpudding> with --verbose
22:10:33 <ivanm> OK, that's just... weird :s
22:10:38 <ivanm> tensorpudding: ghc-pkg list base
22:10:55 <tensorpudding> wait, i don't have 4.1.0.0
22:12:17 <tensorpudding> i was confused, 6.10.1 comes with 4.0.0.0, and agda requires 4.1.0.0
22:12:36 <Axman6> , ty ''Mu
22:12:38 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name -> a'
22:12:41 <tensorpudding> and of course, you can't upgrade base
22:12:55 <tensorpudding> at least, it doesn't look like it
22:13:18 <tommd> No, you really don't want to upgrade base.
22:14:05 <tensorpudding> i suppose 6.10.1 is a year old or so, since i installed it about a year ago
22:15:15 <sieni> Can't get qtHaskell to work at all
22:15:29 <tensorpudding> but upgrading will be unpleasant
22:15:32 <sieni> I guess it's time to play around with Gtk2Hs then
22:15:44 <tensorpudding> i'll probably wait until 6.12 shows up
22:15:45 <mmorrow> , [$ty| Mu |]
22:15:49 <lunabot>  forall f . f (Mu f) -> Mu f
22:15:54 <mmorrow> , src ''Mu
22:15:57 <lunabot>  newtype Mu f = Mu (f (Mu f))
22:16:17 <mmorrow> , fix (Mu . Just)
22:16:19 <lunabot>  Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu ...
22:17:02 <tensorpudding> mu is mu
22:17:22 <BMeph> Just Mu It. ;p
22:18:50 <mmorrow> , fix (Mu . flip Node [])
22:18:52 <lunabot>  Mu (Node {rootLabel = Mu (Node {rootLabel = Mu (Node {rootLabel = Mu (Nod...
22:19:19 <Axman6> ha, i love you guys
22:19:38 <Axman6> mmorrow: what's the kind of Mu?
22:19:55 <mmorrow> (* -> *) -> *
22:20:11 <Axman6> , [|$ty| fix (Mu . Just) |]
22:20:12 <lunabot>  luna: parse error on input `|'
22:20:19 <Axman6> , [$ty| fix (Mu . Just) |]
22:20:22 <lunabot>  Mu Maybe
22:20:37 <mmorrow> Maybe (Maybe (Maybe ...)))
22:20:39 <mmorrow> Maybe (Maybe (Maybe ...))
22:20:59 <tensorpudding> > Mu Mu
22:21:00 <lambdabot>   Not in scope: data constructor `Mu'Not in scope: data constructor `Mu'
22:21:13 <tensorpudding> what is lunabot anyway
22:21:24 <mmorrow> it's an evalbot
22:21:40 <mmorrow> it can do template-haskell and some other things lambdabot doesn't do
22:21:57 <tensorpudding> > let Mu f = Mu (f (Mu f)) in Mu Mu
22:21:58 <lambdabot>   Not in scope: data constructor `Mu'Not in scope: data constructor `Mu'Not i...
22:22:02 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\") :: Integer
22:22:04 <lunabot>  luna: lexical error in string/character literal at end of input
22:22:08 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
22:22:11 <lunabot>  42
22:22:13 <Axman6> , [$ty| fix (Mu) |]
22:22:16 <lunabot>  luna: Exception when trying to run compile-time code:
22:23:06 <mmorrow> , fix fix
22:23:07 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = a -> a
22:23:11 <mmorrow> Mu Mu ==> can't construct the infinite kind * = * -> *
22:24:17 <mmorrow> , Mu Mu
22:24:18 <lunabot>  luna: Occurs check: cannot construct the infinite type:
22:24:20 <Axman6> bleh, Mu is just type level fix isn't it
22:24:43 <Axman6> , Mu (Mu Left)
22:24:44 <lunabot>  luna: Couldn't match expected type `Luna.Mu.Mu ((->) a)'
22:24:48 <Axman6> , Mu (Mu . Left)
22:24:49 <lunabot>  luna: Couldn't match expected type `Data.Either.Either
22:24:54 <mmorrow> right, but kinds are boring compared to types
22:24:57 <Axman6> , fix (Mu . Left)
22:24:58 <lunabot>  luna: Occurs check: cannot construct the infinite type:
22:25:03 <Axman6> bah
22:25:41 <mmorrow> , Mu (Left 42)
22:25:43 <lunabot>  Mu (Left 42)
22:27:04 <mmorrow> Mu (Either Int)
22:27:19 <Axman6> , fix (Mu . Right)
22:27:21 <ddarius> Types are boring compared to values.
22:27:21 <lunabot>  Mu (Right (Mu (Right (Mu (Right (Mu (Right (Mu (Right (Mu (Right (Mu (Rig...
22:27:23 <Axman6> >_>
22:27:50 <mmorrow> ddarius: better said
22:28:32 <dolio> They aren't if you turn on all the extensions.
22:28:40 <dolio> Just more tedious to work with.
22:29:24 <mmorrow> dolio: -XPolymorphicKinds ?
22:29:32 <ddarius> It's really the constraint system rather than the types per se that get "interesting."
22:30:27 <c_wraith> @hoogle sequence
22:30:27 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:30:27 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
22:30:27 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
22:30:41 <dolio> mmorrow: You can only use that if you have UHC.
22:30:52 <dolio> But then you don't need any flags, I think.
22:30:57 <ddarius> Some day the Great Generalization will occur.
22:31:03 <mmorrow> dolio: oh nice, i din't know UHC had those
22:31:25 * ddarius has use cases for polymorphic and product kinds.
22:31:42 <ivanm> ddarius: generalization of what?
22:31:58 * mmorrow thinks it should rather be Kind = Type = Exp
22:32:03 <ddarius> ivanm: Of the Haskell standard librarie.
22:32:16 <ddarius> mmorrow wants * : * for shame.
22:33:58 <mmorrow> a functor is an object in a category with natural transformations as morphisms
22:34:27 <mmorrow> a category is an object in a category with functors as morphisms
22:34:50 <mmorrow> more along those lines i meant it, i'm not sure how to say it precisely though
22:34:52 <lament> category theory is a powerful tool developed to study category theory
22:35:05 <mmorrow> lament: yes!
22:36:25 <ddarius> a (small) category is an object in a (large) category with functors as morphisms
22:36:33 <ivanm> ddarius: he wants * : * for what?
22:36:49 <ddarius> ivanm: shame
22:36:55 <ivanm> ...
22:36:55 <mmorrow> heh
22:39:12 <ivanm> is he proposing to replace Haskell with Caleskell?
22:39:29 <dolio> He didn't say he wants * : *. He just wants to force every language implementation to represent kinds, types and values with a single data type.
22:39:29 <ddarius> Cale wouldn't want that axiom.
22:39:33 <mmorrow> but i didn't say *all* categories were in this category of (some unspecified particular type of) categories
22:40:03 <mmorrow> dolio: right, that's more what i meant
22:40:33 * ivanm is still trying to work out what mmorrow apparently wants
22:41:01 <copumpkin> lol
22:41:17 * tensorpudding just discovered Lazy K, and has decided to go on a SKIing trip
22:41:24 <dolio> ivanm: In a back-of-the-envelope implementation of a dependently typed language, you'd typically use a single datatype for all terms, whether they're values, types or kinds (or beyond).
22:41:31 <dolio> Because they're all intermixed.
22:41:44 <ivanm> O...K...
22:41:45 <ddarius> Or one could use a Pure Type System.
22:41:50 <ivanm> tensorpudding: leave ski alone!
22:42:20 <ddarius> * : * is the axiom that there is a type of types.
22:42:57 <tensorpudding> the type of all types that do not contain themselves
22:42:57 <dolio> Well, I mean, I've implemented pure type systems that way.
22:43:58 <dolio> Technically that doesn't apply to just dependent types, since obviously not all pure type systems are dependently typed.
22:44:42 <dolio> So you can represent values, types, kinds... all in a single datatype even if you have a Haskell-like type system.
22:45:17 <dolio> What you get out depends on what axioms and rules you put into the pure type system.
22:45:43 <ivanm> ddarius: I wasn't sure if you were just emphasising the list constructor or meaning something else...
22:46:58 * ddarius needs to buy another pomegranate.
22:47:07 <copumpkin> mmm
22:47:31 <dolio> To feed to your phoenix?
22:47:47 <ddarius> dolio: My phoenix died.
22:47:52 <ivanm> dolio: maybe he needs it to feed himself?
22:47:57 <dolio> My condolences.
22:48:00 <ivanm> ddarius: well, it was re-born in flames, wasn't it?
22:48:15 <ddarius> ivanm: Actually, that's how it died.
22:48:21 <copumpkin> what if it was an impotent phoenix?
22:48:27 <ivanm> but a new one appeared, right?
22:48:37 <ivanm> copumpkin: don't be ridiculous!
22:48:37 <ddarius> Not yet...
22:48:46 * ivanm wonders at the evolutionary path that led to phoenixes arising
22:48:59 <copumpkin> ivanm: I dunno, I hear that using a laptop for a long time can do bad things
22:49:11 <copumpkin> and phoenices these days
22:49:23 <ivanm> heh
22:49:29 <ivanm> phoen-book? :p
22:49:58 * copumpkin wonders what dolio/ddarius were actually talking about
22:50:08 <ivanm> copumpkin: does it matter? :p
22:50:09 <dolio> Which part?
22:50:23 <ddarius> I was talking?
22:50:27 <copumpkin> the phoenix
22:51:10 <copumpkin> the preorder of the phoenix?
22:51:11 <dolio> Pomegranates were the favorite food of the phoenix in Conan: the Adventurer.
22:51:15 <copumpkin> oh
22:52:31 <copumpkin> don't think that one ever made it to myland
22:53:09 <copumpkin> oh, maybe it did
22:58:06 <ivanm> "myland" ?
23:01:12 <mmorrow> ivanm: as opposed to yourland
23:01:30 <Raevel> this land is my land...
23:05:03 <c_wraith> blah.  is there a way to match the end of the file with uu-parsinglib that doesn't interfere with the parser state?
23:06:38 <c_wraith> :t pToken
23:06:39 <lambdabot> Not in scope: `pToken'
23:07:07 <copumpkin> bos: have you tried a SPECIALIZE annotation on your lengthI function?
23:09:33 <bos> copumpkin: that defeats the inliner in another way
23:09:38 <copumpkin> oh :(
23:10:49 <bos> the function body gets not-inlined at a different call site instead
23:11:02 <copumpkin> sounds like a sad story indeed
23:11:30 <bos> the inliner is just extremely fragile in 6.10.
23:11:53 <bos> but my goofy unicode wc program is still 2.5x faster than GNU "wc -m"
23:11:58 <bos> it could just be faster still
23:14:12 <Cale> http://analogical-engine.com/wordpress/?p=15 -- moar Moar MOAR!
23:14:48 <copumpkin> Cale has been infected with 4chanisms, quick, purge him!
23:14:54 <kfisher> Is there a way to set RTS options in ghci?  In particular, the option to tell the runtime system to switch threads as often as possible?
23:15:29 <Cale> kfisher: ghci is itself a program written in Haskell
23:15:45 <Cale> So you can apply them at the commandline as usual, at least.
23:16:15 <dmwit> +RTS <RTS options go here> -RTS
23:16:45 <dmwit> Try +RTS --help -RTS to start with. ;-)
23:17:11 <kfisher> I've been using +RTS -C when I use ghc
23:17:17 * Cale frets about how the baseline of his text is all messed up by interspersing mathematics.
23:17:29 <kfisher> I'm just not sure how to use it with ghci
23:17:43 <dmwit> Cale: yeah, that's always a bummer =/
23:17:46 <Cale> I want good typography on the web. I could use full page images, but that's not so nice a thing to do to people either.
23:17:54 <dmwit> use \[ \] as much as possible
23:18:07 <Cale> Why can't web browsers embed LaTeX?
23:18:13 <dmwit> seriously
23:18:16 <copumpkin> I'd like that too
23:18:19 <Cale> and use the TeX engine to do all the typesetting
23:18:19 <copumpkin> petition!
23:18:33 <dmwit> For that matter, why do we have separate img and video tags?
23:18:47 <dmwit> <object type="image/jpg">
23:19:06 <dmwit> "text/LaTeX" would fit quite nicely in there
23:19:31 <Cale> Oh, I was thinking something far more drastic.
23:19:34 <Cale> :)
23:19:38 <dmwit> =)
23:20:05 <copumpkin> well, I actually think latex the language is really ugly
23:20:11 <copumpkin> its output is attractive though
23:20:12 <Cale> HTML -> LaTeX -> PDF -> Display
23:20:55 <dmwit> copumpkin: Knuth himself thinks the language is ugly.
23:20:57 <Cale> I admit there are places where this falls down.
23:21:13 <dmwit> It was designed shortly before the CFG breakthrough, no?
23:21:31 <hansfbaier> Cale: Ever heard of JSMath?
23:21:42 <Cale> hansfbaier: yeah
23:22:01 <Cale> hansfbaier: But that just does what I'm currently doing, only using the client side, doesn't it?
23:22:13 <hansfbaier> Cale: yes.
23:22:16 <Cale> (embedded page images)
23:22:19 <dmwit> Well, before the parsing-of-CFG's breakthrough, anyway.
23:22:25 * hansfbaier didnt follow the whole discussion
23:22:58 <Cale> Ah, the problem is that typography on the web sucks, and it sucks particularly awfully when using inline images for math.
23:24:06 <gio123> Cale: hi
23:24:12 <Cale> I thought of a lightweight solution earlier: define a way for various image formats (I'm thinking PNG in particular) to express information about where the text baseline in them is.
23:24:23 <Cale> gio123: hello
23:24:55 <Cale> So at least you could have images which were just that little bit aware of their surroundings.
23:25:07 <gio123> Cale: can u see pm please
23:25:19 <Cale> gio123: I did. You just said the same thing you said here.
23:26:18 <dolio> You could use mathml, like the n-category cafe does. Of course, then I'd have to read your blog in firefox, like I do theirs.
23:26:27 <dolio> I'm not sure it does diagrams, either.
23:32:14 <Cale> Well, mathml is not postscript, so probably not
23:32:30 <Cale> Though I can imagine doing some convoluted postscript to SVG conversion
23:32:44 <Cale> (or PDF to SVG)
23:32:57 <Cale> actually, that would be interesting
23:33:06 <Cale> Embedded SVG page images.
23:33:20 <dolio> Well, I don't think they write mathml directly. They have some latex -> mathml converter they use.
23:33:28 <Cale> Yeah, obviously.
23:33:38 <dolio> Because, who knows mathml?
23:33:38 <Cale> mathml is not human readable or writable
23:33:48 <Cale> Despite being an XML format.
23:34:03 <dolio> http://www.comfsm.fm/~dleeling/tech/mathml-in-svg.xhtml
23:34:12 <dolio> That looks pretty sweet, too.
23:34:22 <Cale> You can technically piece through it, but it would consume your life energy until you were an empty husk.
23:36:33 <dolio> Are you using the same setup as edwardk?
23:36:45 <copumpkin> preflex: seen edwardk
23:36:46 <preflex>  edwardk was last seen on ##logic 10 days, 12 hours, 16 minutes and 9 seconds ago, saying:  /j #lock-free
23:36:49 <copumpkin> boo
23:42:06 <hansfbaier> preflex: seen drobilla
23:42:06 <preflex>  Sorry, I haven't seen drobilla
23:49:43 <kmc> so it seems you could define a category from any graph with the vertices as objects and paths as arrows
23:49:54 <kmc> is this something interesting or useful?
23:50:21 <dolio> Yes, you can do that.
23:50:32 <dolio> That may be the free category generated by a graph.
23:50:38 <dolio> I'm not sure if that's the right terminology.
23:51:00 <kmc> yeah wikipedia says so
23:51:01 <kmc> thanks
23:52:46 <kmc> categories made a lot more sense when someone explained them as "typed monoids"
23:59:40 <Reshure> Question - Is there any difference between rem and mod?
23:59:48 <copumpkin> only on negative values
