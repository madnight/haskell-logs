00:00:01 <blackdog> i usually use it as a way to avoid coming up with names for things
00:00:04 <mxc> i think if you need to use a tool to generate the point free version, that is almost certainly not its place
00:00:34 <ivanm> mxc: I sometimes use @pl because I keep forgetting about ap, etc.
00:00:42 <ivanm> and occasionally it does come up with something nicer
00:00:44 <mxc> ivanm:  fair point
00:03:29 <Keko> what does 'lines'?
00:03:54 <ivanm> Keko: what does 'lines' what?
00:04:10 <ivanm> > lines "Line 1\nLine 2\nNot a line"
00:04:11 <lambdabot>   ["Line 1","Line 2","Not a line"]
00:04:24 <Keko> function lines
00:04:43 <ivanm> Keko: yes, but what do you want to _know_?
00:04:52 <ivanm> that's like me asking "What does cheese?"
00:05:44 <rasfar> cheese functions how?
00:06:15 <dmwit> Aw, give him a break.  English is probably his second language.
00:06:15 <ivanm> *groan*
00:06:20 <Keko> oh I forget put 'do' in the ask, what does do 'lines' function?
00:06:32 <ivanm> dmwit: I'm trying to, but I'm still not sure what he wants to know
00:06:34 <rasfar> :)
00:06:42 <dmwit> Keko: It breaks a string at newline characters.
00:06:45 <ivanm> Keko: you mean what does it do?
00:06:49 <ivanm> see the example I did above
00:07:15 <Keko> ok thks, sry Im not english native :)
00:10:08 <mxc> ?pl \n s ->  take n (s ++ (take n $ repeat " "))
00:10:08 <lambdabot> liftM2 (.) take (flip (++) . ($ repeat " ") . take)
00:11:14 <mxc> that would be in the group of things not worth doing in point free...
00:26:46 <byorgey> mxc: pretty much anything of the form  \x -> ... x ... x ...  is not worth doing point free
00:26:55 <byorgey> i.e. if an argument is used more than once on the RHS.
00:27:48 <mxc> yup
00:28:11 <mxc> shame we didn't get to catch up when i was in philly
00:28:16 <gmaslov> @pl \(a,b) (c,d) -> (a+c,b+d)
00:28:17 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
00:28:42 <gmaslov> not exactly what i was looking for, lambdabot
00:28:59 <dmwit> That particular function doesn't need to mention 'n' twice, though.
00:29:18 <dmwit> ?pl \n s -> take n (s ++ repeat ' ')
00:29:18 <lambdabot> (. (++ repeat ' ')) . take
00:29:40 <dmwit> take n . (++ repeat ' ') -- not horrible
00:30:13 <mxc> that is much nicer
00:30:14 <mxc> t
00:30:26 <mxc> the nested take doesn't make it any faster right?
00:30:41 <dmwit> It might even make it slower. =P
00:32:06 <mxc> i would have loved to have actually been able to take a class in haskell or learn form someone in person
00:32:34 <mxc> i'm about 10k lines into a project, entirely self learned..  think i'm missing a lot
00:35:08 <ddarius> mxc: Look at existing code.
00:35:31 <mxc> i do, but I do miss having a partner or someone to critique mine
00:35:43 <mxc> unfortuantely, i can't really release most of what i'm doing
00:36:06 <mxc> i will release what I can
00:36:12 <mxc> like the hscurrency library i started
00:36:46 <mreh> i am in type hell: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11415#a11415
00:36:53 <mreh> I don't know what any of those mean!
00:37:56 <Woof> So, dogmaT
00:38:02 <Woof> DoYouKnow*
00:38:14 <Woof> What'd you like to see her do?
00:39:43 <DoYouKnow> see who do?
00:39:48 <mxc> mreh - seems like hte issue might be with type signatures
00:39:53 <Woof> DoYouKnow: lambdabot
00:39:58 <DoYouKnow> oh
00:40:20 <mxc> if you make the offending parts top level definitions and comment out the type singatures, GHC will tell you the types (if it typechecks)
00:40:57 <mreh> mxc: I like the strategy, it's too complicated to debug
00:41:04 <mreh> as it is
00:41:17 <mxc> that actually makes it less complicated
00:41:20 <DoYouKnow> let's say... fill a 24-element int array with letters from my nickname padded with 1s, then convert to uppercase, then convert to a string
00:41:22 <mreh> will GHC also tell me the class of a parametric type
00:41:29 <mxc> yeah
00:41:42 <mxc> if the offending bits are top level, then you can test them individually in GHCi much more easiler
00:41:44 <mxc> easily
00:42:13 <mreh> mxc: is english your first language?
00:42:14 <mxc> in GHCi, the :t command is your friend
00:42:17 <mxc> yeah
00:42:21 <mreh> haha
00:42:25 <mxc> but typing is not
00:42:34 <mreh> I know the feeling
00:42:42 <mreh> accuracy is my biggest foible
00:42:56 <Woof> DoYouKnow: Why int array?
00:43:34 <DoYouKnow> can you do network programming with ghci?
00:43:38 <Woof> Yes
00:43:49 <dmwit> DoYouKnow: If you change "int array" to "char list", here's an implementation:
00:44:15 <dmwit> > map toUpper . take 24 $ "DoYouKnow" ++ repeat '1'
00:44:16 <lambdabot>   "DOYOUKNOW111111111111111"
00:44:27 <Woof> No, padded with
00:44:32 <Woof> @let theArr zip "DoYouKnow" [1,1..]
00:44:32 <DoYouKnow> wow
00:44:32 <lambdabot>   Parse error: SemiColon
00:44:39 <Woof> @let theArr = zip "DoYouKnow" [1,1..]
00:44:40 <lambdabot>  Defined.
00:44:45 <Woof> > the Arr
00:44:46 <lambdabot>   Not in scope: `the'Not in scope: data constructor `Arr'
00:44:47 <Woof> > theArr
00:44:47 <dmwit> (This exploits the fact that a Char list *is* a String in Haskell, so no conversion is needed.)
00:44:48 <lambdabot>   [('D',1),('o',1),('Y',1),('o',1),('u',1),('K',1),('n',1),('o',1),('w',1)]
00:45:13 <Zao> Woof: Your definition of "padded with" is rather odd.
00:45:27 <Woof> Zao: Because I don't know how to make a single list with different types
00:45:31 <DoYouKnow> dmwit had it right
00:45:42 <Woof> ?
00:45:43 <Zao> Woof: You can't. A list is homogeneous.
00:45:54 <Woof> Zao: Exactly. So I have to go for tuples
00:46:02 <Woof> Either a list of tuples or on 24-tuple
00:46:05 <Woof> one*
00:46:13 <Woof> DoYouKnow: Padded is interpersed, right?
00:46:18 <Zao> Woof: I'd reckon his "int array" was sourced in that a character literal in C has type int?
00:46:19 <DoYouKnow> no, just at the end
00:46:22 <Woof> Oh
00:46:24 <Woof> Okay
00:46:49 <Woof> Zao: Yeah, so this is the closest I could get to that. OR intersperse with '1'
00:47:03 <dmwit> :t intersperse
00:47:04 <lambdabot> forall a. a -> [a] -> [a]
00:47:15 <dmwit> > intersperse '1' "DoYouKnow"
00:47:15 <lambdabot>   "D1o1Y1o1u1K1n1o1w"
00:47:17 <Woof> > interperse '1' "DoYouKnow"
00:47:18 <lambdabot>   Not in scope: `interperse'
00:47:24 <Woof> Yeah
00:47:25 <DoYouKnow> @let network_address = 192.168.1.1
00:47:27 <lambdabot>  Defined.
00:47:41 <dmwit> DoYouKnow: Oh, that's going to give you funny type errors.
00:47:46 <dmwit> :t 192.168.1.1
00:47:47 <lambdabot> forall a b (f :: * -> *). (Fractional (a -> b), Fractional (f a), Functor f) => f b
00:48:00 <dmwit> DoYouKnow: (.) is an operator in Haskell.
00:48:14 <Woof> > network_address
00:48:15 <lambdabot>   No instance for (GHC.Show.Show (f b))
00:48:15 <lambdabot>    arising from a use of `M4171932112...
00:48:17 <dmwit> DoYouKnow: It makes parsing fun: you have to know when it should be read as part of a number literal, and when it should be read as an identifier. ^_^
00:48:34 <ddarius> dmwit: Not usually...
00:48:50 <dmwit> s/parsing/lexing/
00:49:35 <DoYouKnow> @let = network_address = "11000000101010000000000100000001"
00:49:36 <lambdabot>   Parse error: Equals
00:49:43 <DoYouKnow> @let network_address = "11000000101010000000000100000001"
00:49:44 <lambdabot>  <local>:19:0:
00:49:44 <lambdabot>      Multiple declarations of `L.network_address'
00:49:44 <lambdabot>      Declare...
00:49:51 <dmwit> ?undefine
00:49:56 <dmwit> Now go ahead.
00:50:13 <DoYouKnow> @let ip address = "11000000101010000000000100000001"
00:50:15 <lambdabot>  Defined.
00:50:24 <DoYouKnow> ooops
00:50:26 <Woof> DoYouKnow: You just defined a function ip
00:50:28 <Woof> > ip 1
00:50:29 <lambdabot>   "11000000101010000000000100000001"
00:50:31 <Woof> > ip 2
00:50:32 <DoYouKnow> @let ip_address = "11000000101010000000000100000001"
00:50:32 <lambdabot>   "11000000101010000000000100000001"
00:50:33 <lambdabot>  Defined.
00:50:37 <Woof> A constant function ; )
00:51:10 <DoYouKnow> @let subnet_mask = "11111111111111111111111100000000"
00:51:11 <lambdabot>  Defined.
00:51:18 <DoYouKnow> ?and
00:51:18 <lambdabot> Maybe you meant: arr ask bid id kind undo wn
00:51:26 <dmwit> heh
00:51:32 <DoYouKnow> how do you and?
00:51:36 <Woof> DoYouKnow: How do you get those binary numbers?
00:51:45 <DoYouKnow> I just typed them out
00:51:48 <Woof> DoYouKnow: Bitwise?
00:52:03 <DoYouKnow> well, one is an ip address, the other is a subnet mask
00:52:06 <ivanm> *sigh* why is lambdabot being taught all these useless functions/variables this time?
00:52:18 <dmwit> > let ip_address' = map (== '1') ip_address; subnet_mask' = map (== '1') subnet_mask in zipWith (&&) ip_address' subnet_mask'
00:52:19 <lambdabot>   [True,True,False,False,False,False,False,False,True,False,True,False,True,F...
00:52:42 <dmwit> ivanm: You're grumpy tonight.  Did you forget your pills?
00:52:49 <ivanm> heh
00:52:59 <dmwit> =)
00:53:09 <ivanm> dmwit: I usually find it annoying when people add lots of @let's, possibly changing the meaning of things, etc.
00:53:10 <DoYouKnow> dmwit, so how do I and them?
00:53:12 <dibblego> is there a function to give an arbitrary filename that does not exist?
00:53:19 <dmwit> DoYouKnow: with (&&)
00:53:25 <dmwit> DoYouKnow: See it in there after the "in"?
00:53:41 <ivanm> dibblego: there's temp file functions IIRC
00:53:44 <ivanm> @hoogle temp
00:53:44 <lambdabot> package template-haskell
00:53:44 <lambdabot> Foreign.C.Error eNOTEMPTY :: Errno
00:53:44 <lambdabot> System.Console.Editline.Readline getAttemptedCompletionOver :: IO Bool
00:53:47 <ivanm> bah
00:53:54 * ivanm thinks it might be in directory
00:54:03 <dibblego> ivanm, I only see getTemporaryDirectory ("/tmp")
00:54:05 <dmwit> ? let fromString = map (== '1'); toString = map (\b -> if b then '1' else '0')
00:54:08 <dmwit> ?let fromString = map (== '1'); toString = map (\b -> if b then '1' else '0')
00:54:09 <lambdabot>  Defined.
00:54:23 <ivanm> dibblego: tried filepath?
00:54:26 <dibblego> yes
00:54:45 <DoYouKnow> well, from what I can see it's right
00:54:49 <dibblego> none of the functions in System.FilePath have IO
00:54:54 <ivanm> dibblego: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:openTempFile
00:55:07 <dibblego> yeah that's to open a file handle
00:55:16 <ivanm> oh, bugger...
00:55:18 <dmwit> > toString $ zipWith (&&) (fromString "11000000101010000000000100000001") (fromString "11111111111111111111111100000000")
00:55:19 <lambdabot>   "11000000101010000000000100000000"
00:55:20 <ivanm> plugins has some...
00:55:26 <Woof> Hm
00:55:36 <dmwit> DoYouKnow: There we go... much more readable. =)
00:55:50 <dibblego> I'm thinking of writing my own from System.Random
00:55:58 <dmwit> DoYouKnow: But usually, this kind of thing is done with numbers, not Strings.
00:56:01 <dmwit> DoYouKnow: For example:
00:56:09 <ivanm> dibblego: you want something to give you a filename? i.e. IO FIlePath ?
00:56:10 <dmwit> > 0xffee .&. 0xee00
00:56:11 <lambdabot>   Ambiguous type variable `t' in the constraint:
00:56:11 <lambdabot>    `Data.Bits.Bits t'
00:56:11 <lambdabot>      a...
00:56:13 <dibblego> ivanm, yes
00:56:14 <dmwit> > 0xffee .&. 0xee00 :: Integer
00:56:15 <lambdabot>   60928
00:56:23 <dmwit> :t showHex
00:56:23 <lambdabot> forall a. (Integral a) => a -> String -> String
00:56:36 <dmwit> > showHex (0xffee .&. 0xee00 :: Integer) ""
00:56:37 <lambdabot>   "ee00"
00:57:28 <ivanm> dibblego: RWH has some code that does something similar...
00:57:36 <dibblego> that's under my monitor
00:57:46 <ivanm> heh
00:57:49 <dibblego> page number?
00:57:50 <ivanm> http://books.google.com.au/books?id=nh0okI1a1sQC&pg=PT214&lpg=PT214&dq=temporary+file+haskell&source=bl&ots=sXWLo9eQhO&sig=lEFCHOWzQ_mYI77Owg0sTCDozrU&hl=en&ei=MD_tSqL9NqPm6gOa0JHqCw&sa=X&oi=book_result&ct=result&resnum=5&ved=0CBwQ6AEwBA#v=onepage&q=temporary%20file%20haskell&f=false
00:57:57 <dibblego> ta
00:57:59 <ivanm> 176
00:58:41 <ivanm> dibblego: maybe see how cautious-file creates temp files...
00:58:41 <DoYouKnow> 0x0005 .&. 0xfffa :: Integer
00:58:48 <ivanm> but I guess it uses the System.IO function
00:58:50 <Woof> > let str = map (toS.and) (zip ip_address subnet_mask) where and (x, y) = (x == '1') && (y == '1'); toS True = '1'; toS False = '0'
00:58:51 <lambdabot>   not an expression: `let str = map (toS.and) (zip ip_address subnet_mask) wh...
00:58:53 <DoYouKnow> > 0x0005 .&. 0xfffa :: Integer
00:58:54 <lambdabot>   0
00:58:57 <dibblego> yeah looks like it uses openTempFile
00:59:08 <Woof> >let str = map (toS.and) (zip ip_address subnet_mask) where and (x, y) = (x == '1') && (y == '1'); toS True = '1'; toS False = '0'
00:59:12 <Woof> No
00:59:26 <Woof> > map (toS.and) (zip ip_address subnet_mask) where and (x, y) = (x == '1') && (y == '1'); toS True = '1'; toS False = '0'
00:59:27 <lambdabot>   <no location info>: parse error on input `where'
00:59:30 <Woof> >: O
00:59:43 <Woof> @let str = map (toS.and) (zip ip_address subnet_mask) where and (x, y) = (x == '1') && (y == '1'); toS True = '1'; toS False = '0'
00:59:44 <lambdabot>  Defined.
00:59:46 <Woof> > str
00:59:47 <lambdabot>   "11000000101010000000000100000000"
01:00:23 <ivanm> dibblego: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/17 <-- dons mentions some System.Posix.Temp ...
01:00:24 <DoYouKnow> there's also got to be a way to put it back in dotted decimal... that is, add dots for every 8 bits, and convert each grouping of 8 bits to decimal
01:00:28 <ivanm> obviously not cross platform though :s
01:00:40 <DoYouKnow> ?tobinary
01:00:40 <lambdabot> Unknown command, try @list
01:01:03 <DoYouKnow> how do you describe a binary int?
01:01:06 <dibblego> ivanm, yeah that opens a file handle as well (don't care about non-posix)
01:01:08 <dmwit> DoYouKnow: Naturally, you would use a library for this stuff.
01:01:12 <DoYouKnow> ok
01:01:13 <dmwit> DoYouKnow: There are several of them on hackage.
01:01:16 <dmwit> ?where hackage
01:01:16 <lambdabot> http://web.archive.org/web/20080624112926/http://hackage.haskell.org/
01:01:25 <ivanm> dibblego: you want to use it "by hand" rather than using a Handle?
01:01:29 <dmwit> err
01:01:31 <dibblego> ivanm, yes
01:01:36 <ivanm> :o
01:01:42 <dmwit> ?where+ hackage http://hackage.haskell.org/package
01:01:42 <lambdabot> I will remember.
01:01:52 <ivanm> dmwit: someone was obviously annoyed by hackage being down last year...
01:02:03 <dmwit> ?where+ hackage http://hackage.haskell.org/packages/archive/pkg-list.html
01:02:03 <lambdabot> Done.
01:02:12 <ivanm> heh, the wayback machine doesn't like that URL ;-)
01:02:18 <ivanm> @where hackage
01:02:18 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
01:02:29 <ivanm> dmwit: methinks just use the short version
01:02:47 <dmwit> DoYouKnow: Check the "Network" section on there.
01:02:49 <dmwit> ivanm: ?
01:02:55 <DoYouKnow> cool
01:03:13 <ivanm> dmwit: just hackage.haskell.org/package/ rather than the explicit archive/pkg-list.html
01:03:33 <dmwit> ivanm: That 404's for me.
01:03:42 <ivanm> dmwit: :o
01:03:48 <ivanm> WORKSFORME
01:03:59 <ivanm> dmwit: you need a trailing slash
01:04:03 <dmwit> ah
01:04:06 <Woof> @let toBin 0 = 0; toBin dec = dec `mod` 2 + 10 * (toBin (dec `div` 2))
01:04:07 <lambdabot>  Defined.
01:04:11 <dmwit> ?where+ hackage http://hackage.haskell.org/package/
01:04:12 <lambdabot> Nice!
01:04:12 <Woof> > toBin 1232
01:04:13 <lambdabot>   10011010000
01:04:17 <Woof> There, DoYouKnow
01:04:23 <dmwit> :t showBin
01:04:24 <lambdabot> Not in scope: `showBin'
01:04:27 <dmwit> :t showAtBase
01:04:28 <lambdabot> Not in scope: `showAtBase'
01:04:51 <ivanm> @hoogle bin
01:04:51 <lambdabot> Trace.Hpc.Mix BinBox :: CondBox -> Bool -> BoxLabel
01:04:51 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
01:04:51 <lambdabot> System.Console.Editline.Readline bindKey :: Char -> Callback -> IO ()
01:04:54 <dmwit> :t showIntAtBase
01:04:55 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
01:05:13 <Woof> @let toDec 0 = 0; toDec bin = bin `div` 10 + 10 * (toDec (bin `div` 10)
01:05:13 <lambdabot>   Parse error: SemiColon
01:05:31 <dmwit> ?let showBin n = showIntAtBase 2 ("01"!!) n ""
01:05:32 <lambdabot>  Defined.
01:05:39 <dmwit> > showBin "32"
01:05:40 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
01:05:40 <lambdabot>    arising from a use ...
01:05:41 <Woof> @let toDec 0 = 0; toDec bin = bin `div` 10 + 10 * (toDec (bin `div` 10))
01:05:42 <lambdabot>  Defined.
01:05:48 <Woof> > toDec 10010101
01:05:49 <lambdabot>   7004020
01:05:53 <Woof> Oops
01:05:59 <Woof> > toDec 100
01:06:00 <lambdabot>   20
01:06:07 <Woof> Hm wait
01:06:22 <Woof> @let toDec 0 = 0; toDec bin = bin `div` 10 + 2 * (toDec (bin `div` 10))
01:06:22 <lambdabot>  <local>:8:0:
01:06:22 <lambdabot>      Warning: Pattern match(es) are overlapped
01:06:22 <lambdabot>               In...
01:06:26 <Woof> Blast
01:06:32 <dmwit> > showBin 32
01:06:33 <lambdabot>   "100000"
01:06:44 <Woof> @let toDec2 0 = 0; toDec2 bin = bin `div` 10 + 2 * (toDec2 (bin `div` 10))
01:06:45 <lambdabot>  Defined.
01:06:51 <gmaslov> i think technically toDec = id
01:06:53 <dmwit> Woof: We have showIntAtBase and readInt for a reason. ;-)
01:06:59 <Woof> > toDec2 100
01:07:00 <lambdabot>   12
01:07:04 <Woof> >: O
01:07:06 <Woof> What's that reason, dmwit?
01:07:29 <dmwit> Woof: So we don't re-implement this stuff incorrectly all the time!
01:08:03 <dmwit> > readInt 2 (`elem` "01") ("01"!!) . show $ 100
01:08:04 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:08:04 <lambdabot>         against inferred type...
01:08:26 <Woof> dmwit: Lol true, but when I'm looking at a language for the first time, I like to see how I can implement stuff in it using basic language constructs rather than what library functions are available
01:09:10 <Woof> It's reasonable to assume there'll be libraries for all these small stuff, but that doesn't give me much of an idea about the language itself
01:09:33 <dmwit> :t readInt 2 (`elem` "01") ("01"!!)
01:09:34 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
01:09:34 <lambdabot>     In the third argument of `readInt', namely `("01" !!)'
01:09:34 <lambdabot>     In the expression: readInt 2 (`elem` "01") ("01" !!)
01:09:41 <dmwit> oh
01:09:43 <ivanm> Woof: Haskell doesn't have as much "built-in" stuff as other languages
01:09:46 <ivanm> dmwit: heh
01:09:52 <dibblego> @hoogle doWhile
01:09:53 <lambdabot> No results found
01:10:11 <dmwit> > readInt 2 (`elem` "01") (\c -> ord c - ord '0') . show $ 100
01:10:12 <lambdabot>   [(4,"")]
01:10:46 <Woof> > readInt 2 (`elem` "01") (\c -> ord c - ord '0') . show $ 1000
01:10:47 <lambdabot>   [(8,"")]
01:10:48 <dibblego> @type findM
01:10:49 <lambdabot> Not in scope: `findM'
01:10:51 <Woof> Nice
01:10:57 <dmwit> ?let toDec3 = fst . head . readInt 2 (`elem` "01") (\c -> ord c - ord '0') . show
01:10:58 <lambdabot>  Defined.
01:11:09 <Woof> > toDec3 (toBin 43)
01:11:10 <lambdabot>   43
01:11:13 <Woof> : D
01:11:15 <dibblego> @hoogle findM
01:11:16 <lambdabot> Data.IntMap findMax :: IntMap a -> a
01:11:16 <lambdabot> Data.IntSet findMax :: IntSet -> Int
01:11:16 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
01:11:42 <trofi> findM ?
01:11:48 <trofi> :t filterM
01:11:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
01:12:28 <dmwit> :t toDec3 . toBin >>= (==)
01:12:29 <lambdabot> forall a. (Integral a) => a -> Bool
01:12:38 <dmwit> ?check toDec3 . toBin >>= (==)
01:12:39 <lambdabot>   Not in scope: `toDec3'Not in scope: `toBin'
01:12:44 <dmwit> oh, bah
01:13:06 <dmwit> > lexDigits "342.526"
01:13:07 <lambdabot>   [("342",".526")]
01:13:09 <dmwit> huh
01:13:20 <dmwit> > lexDigits ".526"
01:13:21 <lambdabot>   []
01:13:35 <Woof> :src lexDigits
01:13:36 <gmaslov> > test (\x -> toDec3 (toBin x) == x)
01:13:37 <lambdabot>   Not in scope: `test'
01:13:46 <Woof> @src lexDigits
01:13:47 <lambdabot> Source not found. Do you think like you type?
01:13:48 <gmaslov> aw, lambdabot doesn't do quickcheck?
01:13:56 <dmwit> Sure she does.
01:14:01 <dmwit> ?check \x -> x == x
01:14:02 <lambdabot>   "OK, passed 500 tests."
01:14:06 <gmaslov> aha
01:14:23 <dmwit> It's just that ?define'd things aren't available in ?check.
01:14:25 <dmwit> (unfortunately)
01:14:55 <dmwit> Woof: http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Read.html#lexDigits
01:16:28 <keko> can separate lines in file and then use one line with one function, and other line with other function?
01:16:46 <dmwit> ?faq can separate lines in file and then use one line with one function, and other line  with other function?
01:16:46 <lambdabot> The answer is: Yes! Haskell can do that.
01:17:21 <Woof> > break (not Char.isDigit) "342.526"
01:17:21 <lambdabot>   Not in scope: `Char.isDigit'
01:17:24 <Woof> > break (not isDigit) "342.526"
01:17:25 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
01:17:25 <lambdabot>         against inferred type ...
01:17:42 <dmwit> > break (not . isDigit) "342.526"
01:17:43 <lambdabot>   ("342",".526")
01:17:46 <Woof> Oh yeah
01:17:54 <dmwit> But this function is not (quite) the same.
01:17:57 <dmwit> Compare:
01:18:20 <dmwit> > (lexDigits "3.0", lexDigits ".0", break (not . isDigit) "3.0", break (not . isDigit) ".0")
01:18:21 <lambdabot>   ([("3",".0")],[],("3",".0"),("",".0"))
01:19:08 <Woof> > lexDigits "3.4.5.6"
01:19:08 <lambdabot>   [("3",".4.5.6")]
01:19:22 <Woof> Why does it do that with ".0"?
01:19:36 <dmwit> That's the power of "munch1" as opposed to "munch".
01:19:46 <Woof> Hm, what is the purpose?
01:20:06 <DoYouKnow> > ToBin (11000000101010000000000100000000 && 11111111000000000000000000000000)
01:20:07 <lambdabot>   Not in scope: data constructor `ToBin'
01:20:07 <dmwit> .0 is not a valid number literal in Haskell.
01:20:11 <dmwit> > .0
01:20:11 <lambdabot>   <no location info>: parse error on input `.'
01:20:15 <dmwit> > 0.0
01:20:16 <lambdabot>   0.0
01:20:30 <Woof> DoYouKnow: toBin, also, you can't && them like that
01:20:36 <Woof> Oh, I see, dmwit
01:20:47 <DoYouKnow> > toBin (11000000101010000000000100000000 && 11111111000000000000000000000000)
01:20:48 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
01:20:48 <lambdabot>    arising from a use of ...
01:20:48 <dmwit> DoYouKnow: .&. is bitwise and.
01:20:57 <DoYouKnow> > toBin (11000000101010000000000100000000 .&. 11111111000000000000000000000000)
01:20:58 <lambdabot>   100010000001010011101010100100100100011001000000000110001010101000000010001...
01:21:00 <dmwit> DoYouKnow: But you probably want
01:21:15 <Woof> > toDec3 (11000000101010000000000100000000 .&. 11111111000000000000000000000000)
01:21:16 <lambdabot>   Ambiguous type variable `t' in the constraint:
01:21:16 <lambdabot>    `Data.Bits.Bits t'
01:21:16 <lambdabot>      a...
01:21:25 <dmwit> > toDec3 (toBin 11000000101010000000000100000000 .&. toBin 11111111000000000000000000000000)
01:21:26 <lambdabot>   16
01:21:31 <dmwit> augh, backwards
01:21:40 <Woof> Lol
01:21:44 <dmwit> > toBin (toDec3 11000000101010000000000100000000 .&. toDec3 11111111000000000000000000000000)
01:21:45 <lambdabot>   11000000000000000000000000000000
01:21:58 <Woof> Makes sense
01:22:03 <DoYouKnow> toDec 11000000000000000000000000000000
01:22:10 <Woof> >
01:22:13 <DoYouKnow> > toDec 11000000000000000000000000000000
01:22:15 <lambdabot>   34000000000000000000000000000000
01:22:18 <DoYouKnow> err
01:22:21 <dmwit> DoYouKnow: I should point out that this writing numbers as bit strings stuff is highly irregular.
01:22:41 <DoYouKnow> it's a bitmask
01:22:46 <DoYouKnow> how do you write a bitmask?
01:22:51 <dmwit> in hex
01:22:59 <DoYouKnow> ok
01:23:15 <dmwit> > 0xff000000
01:23:16 <lambdabot>   4278190080
01:23:28 <dmwit> > toDec3 11111111000000000000000000000000
01:23:29 <lambdabot>   4278190080
01:23:51 <dmwit> Preferably, you don't write a bitmask at all.
01:24:06 <DoYouKnow> this is used for routing
01:24:18 <dmwit> I'm aware of that.
01:24:23 <DoYouKnow> ok
01:26:15 <dmwit> To clarify: I think it's pretty rare (not only in Haskell) to write a literal bitmask in a source file.  In a config file somewhere? Sure.  But hardcoded? Mostly no...
01:27:52 <DoYouKnow> dmwit, oh, yeah... well this is just as an example
01:28:02 <DoYouKnow> normally you'd get it from some other source
01:28:12 <dmwit> right
01:28:15 <DoYouKnow> I was curious
01:28:19 <dmwit> yeah =)
01:28:24 <DoYouKnow> :)
01:41:05 <malie> ghci tells me "Not in scope: `verboseCheck'" though I have imported Test.QuickCheck. `quickCheck' is visible and if I understand the modules source code verboseCheck should be too...
01:41:34 <zrbecker> does haskell have a factorial function?
01:42:05 <byorgey> malie: might be a version mismatch.  what version of the documentation are you reading, and what version of QuickCheck is installed?
01:42:11 <dolio> > product [1..6]
01:42:12 <lambdabot>   720
01:42:20 <byorgey> zrbecker: not built into the standard libraries, but it's easy to implement
01:42:37 <malie> I m reading the source code that cabal unpacked for me via `cabal unpack'
01:42:38 <zrbecker> ok, thanks. Yeah very easy. heh.
01:42:43 <dolio> > product [1..0]
01:42:44 <lambdabot>   1
01:42:52 <byorgey> > product [1..500]
01:42:54 <lambdabot>   122013682599111006870123878542304692625357434280319284219241358838584537315...
01:42:58 <byorgey> =D
01:43:05 <malie> the documentation is old http://www.math.chalmers.se/~rjmh/QuickCheck/manual.html
01:43:13 <byorgey> malie: ah, I see =)
01:43:15 <shachaf> > product [1..1.5]
01:43:16 <lambdabot>   2.0
01:43:19 <ddarius> There are more efficient versions than product . enumFromTo 1
01:44:14 <DoYouKnow> > product [1...123]
01:44:15 <lambdabot>   Not in scope: `...'
01:44:21 <DoYouKnow> > product [1..123]
01:44:22 <lambdabot>   121463043670253296757662432418812958554542170884833823153289181618292358923...
01:44:43 <DoYouKnow> > product [40..123]
01:44:44 <lambdabot>   595468898127500568354428941135094684702855881704617867904401020698460696727...
01:45:13 <byorgey> malie: I don't see verboseCheck in the most recent version.
01:45:42 <byorgey> malie: in what source file do you see it?
01:45:59 <sinelaw> > compare 2.3000000000000001 2.3
01:45:59 <lambdabot>   GT
01:46:01 <sinelaw> > compare 2.3000000000000001 2.301
01:46:02 <lambdabot>   LT
01:46:05 <sinelaw> huh?
01:46:18 <sinelaw> ah.
01:46:25 <byorgey> sinelaw: I am confused by your confusion.
01:46:38 <sinelaw> byorgey, Mission Accomplished
01:47:12 <byorgey> =)
01:47:34 <malie> byorgey, cabal installed QuickCheck 1.2.0.0 AND 2.1.0.2. seems cabal unpack took the old one. thanks
01:47:45 <dolio> I'd probably hold off on performance tuning the factorial function until you verify that it's dominating your program's runtime, though.
01:48:11 <malie> btw was the first time i used cabal unpack, with tar xzf ~/.cabal/packages/... I had seen the versions
01:48:21 <dolio> Although, I guess it doesn't foldr/build fuse.
01:49:03 <ddarius> dolio: The issue isn't with fusion.
01:49:35 <dolio> Yes, well, there's multiplying like-sized numbers as well.
01:49:52 <dolio> But that's extra work.
01:51:05 <ddarius> product = fold (*) 1.  The question is just a matter of choosing the right fold for 'fold'
01:52:05 <sinelaw> @src product
01:52:05 <lambdabot> product = foldl (*) 1
01:58:40 <dmwit> > let foldb1 (*) one (x:y:rest) = foldb1 (*) one (x * y : foldb1 (*) one rest); foldb1 (*) one [x] = x; foldb1 (*) one [] = one in foldb1 (*) 1 [2..3000]
01:58:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:59:15 <dmwit> > let foldb1 (*) one (x:y:rest) = foldb1 (*) one ((x * y) : foldb1 (*) one rest); foldb1 (*) one [x] = x; foldb1 (*) one [] = one in foldb1 (*) 1 [2..3000]
01:59:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:59:59 <dolio> The type-level tracking of distributed evaluation from Roman Leshchinskiy's talk on data parallelism a week or so ago would actually have something like the right building blocks.
01:00:53 <dolio> prodD . mapD prod . splitD . enumFromTo 1
01:02:39 <dolio> Plus, free multi-core evaluation.
01:23:48 <dmwit> ?let foldb' op xs (x:y:zs) = foldb' op (op x y : foldb' op zs); foldb' op xs = xs; foldb1 op = head . foldb1 op; foldb op z = foldb1 op . (z:)
01:23:49 <lambdabot>   arity mismatch for 'foldb''
01:24:06 <dmwit> ?let foldb' op (x:y:zs) = foldb' op (op x y : foldb' op zs); foldb' op xs = xs; foldb1 op = head . foldb1 op; foldb op z = foldb1 op . (z:)
01:24:07 <lambdabot>  <local>:11:87:
01:24:07 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
01:24:10 <dmwit> aaargh
01:26:22 <dmwit> ?let foldb' op (x:y:zs) = foldb' op (op x y : foldb' op zs); foldb' op xs = xs; foldb1 op = head . foldb' op; foldb op z = foldb1 op . (z:)
01:26:24 <lambdabot>  Defined.
01:26:41 <dmwit> > foldb (*) 1 [2..3000]
01:26:43 <lambdabot>   414935960343785408555686709308661217095111919493180991768946765769755856512...
01:26:52 <dmwit> > foldl' (*) 1 [2..3000]
01:26:54 <lambdabot>   414935960343785408555686709308661217095111919493180991768946765769755856512...
01:26:58 <dmwit> > foldl' (*) 1 [2..5000]
01:27:00 <lambdabot>   422857792660554352220106420023358440539078667462664674884978240218135805270...
01:27:08 <dmwit> > foldl' (*) 1 [2..10000] `seq` ()
01:27:09 <lambdabot>   ()
01:27:15 <dmwit> > foldl' (*) 1 [2..100000] `seq` ()
01:27:19 <lambdabot>   mueval-core: Time limit exceeded
01:30:14 <Jafet> > product [1..100000]
01:30:18 <lambdabot>   mueval-core: Time limit exceeded
01:30:24 <Jafet> > product [1..10000]
01:30:25 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
01:30:29 <dmwit> Oh, this is not actually foldb.
01:30:39 <dmwit> ?undefine
01:34:07 <magthe> Is there a way to get rid of the '_'s in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11416#a11416 ?
01:34:40 <sioraiocht> magthe: give those variables names?
01:34:49 <dmwit> Foo {}
01:35:09 <dmwit> That will match any number of underscores.
01:35:15 <sioraiocht> magthe: also, why do you pattern match? you are doing the same thing to it regardless
01:36:43 <magthe> sioraiocht: it's a minimal example based on more complicated code... no point posting 20+ lines, when 6 will do :-)
01:37:24 <magthe> dmwit: thanks, that's what I needed
01:41:06 <zygoloid> magthe: processFoo f = putStrLn "Got foo" >> print f  ?
01:41:11 <zrbecker> Is there a way to get the length of a list as an Integer as oppose to a Int? I'm having type errors with this example http://pastebin.com/m635d78c1
01:41:47 <zygoloid> zrbecker: there's genericLength in Data.List, or fromIntegral . length.
01:42:05 <zrbecker> Awesome thanks
01:42:37 <magthe> zygoloid: that was a typo of mine... modified to avoid misunderstandings
01:42:53 <dmwit> zygoloid: Turning off the dreaded MR should fix that, too.
01:43:08 <dmwit> err
01:43:10 <zygoloid> zrbecker: looks like you've been hit by the monomo- right
01:43:15 <dmwit> I meant that to be aimed at zrbecker.
01:43:20 <mxc> sorta on that note, if I newtype an int or integer, i essentially get fromIntegral for free (newtype T = T Int deriving (Integral) ) to convert back and forth..  is there an equivalent for doubles?
01:43:42 <mxc> i.e. newtype D = D Double deriving (xxx)
01:43:51 <mxc> couldn't find an easy solution going through the docs
01:44:02 <zygoloid> Real?
01:44:05 <dmwit> :t fromRational
01:44:06 <zygoloid> @src Real
01:44:06 <lambdabot> class  (Num a, Ord a) => Real a  where
01:44:06 <lambdabot>     toRational      ::  a -> Rational
01:44:07 <lambdabot> forall a. (Fractional a) => Rational -> a
01:44:28 <mxc> that gives a rational
01:44:38 <dmwit> fromRational gets you the rest of the way. ;-)
01:44:40 <zrbecker> dmwit: What is MR?
01:44:50 <dmwit> ?go monomorphism restriction
01:44:51 <lambdabot> Maybe you meant: google googleit do
01:44:55 <dmwit> ?google monomorphism restriction
01:44:58 <mxc> ty dmwit
01:45:09 <dmwit> hum
01:45:09 <mxc> fromRational was the missing bit
01:45:10 <lambdabot> Plugin `search' failed with: thread killed
01:45:16 <dmwit> ?wiki Monomorphism Restriction
01:45:16 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_Restriction
01:45:24 <zygoloid> zrbecker: the monomorphism restriction is forcing 'factorial' to have a narrower type than it should
01:45:48 <benmachine> :t fromRational
01:45:49 <zygoloid> that is, it's Integer -> Integer rather than Num a => a -> a
01:45:49 <lambdabot> forall a. (Fractional a) => Rational -> a
01:46:09 <zygoloid> hmm, (Enum a, Num a) => a -> a
01:46:15 <zrbecker> zygoloid, dmwit: cool reading about it now. Thanks.
01:46:18 <sinelaw> > 3%3
01:46:19 <lambdabot>   1 % 1
01:46:32 <sinelaw> > (fromRational (1%2)) :: Int
01:46:33 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
01:46:33 <lambdabot>    arising from a use o...
01:46:40 <sinelaw> > (fromRational (1%2)) :: Double
01:46:41 <lambdabot>   0.5
01:50:16 <dmwit> That makes me wonder: how does pattern-matching on Fractionals work?
01:50:25 <dmwit> > let f 0.3 = 0.5 in f 0.3
01:50:26 <lambdabot>   0.5
01:51:05 <dmwit> I mean, doesn't that stand for (fromRational (3%10)), which isn't really a pattern?
01:51:23 <dmwit> For that matter, how does pattern-matching on Integrals work? =P
01:52:27 <noteventime> > 0.5::Rational
01:52:28 <lambdabot>   1 % 2
01:52:59 <dmwit> > 0xffee.fefe -- hmm
01:53:00 <lambdabot>   Not in scope: `fefe'
01:53:07 <dmwit> ah, that's a shame
01:53:53 <Saizan> dmwit: there's a reason Eq is a superclass of Num :)
01:54:08 <dmwit> ...no
01:54:25 <noteventime> Ahh, that's interesting
01:54:31 <dmwit> =(
01:54:50 <noteventime> I've always wondered why that was the case
01:55:21 <ivanm> Saizan: what particular reason? pattern matching not working?
01:55:31 <ivanm> s/not//
01:55:35 <ivanm> eh, whatever
01:55:37 <dolio> It isn't a good reason.
01:55:53 <ivanm> when don't you want equality for numbers?
01:56:02 <dmwit> ivanm: I think the idea is that "f 0.3 = 0.5" gets translated to "f x | x == 0.3 = 0.5".
01:56:26 <dmwit> ...and that's the reason Eq is a superclass, because otherwise there would be way for pattern-matching to work.
01:56:42 <ivanm> because they aren't actually constructors?
01:57:08 <dmwit> Right, 0.3 stands for (fromRational (3%10)), and 15 stands for (fromInteger 15).
02:04:01 <dolio> That could still work without the superclass. It'd just add an Eq constraint.
02:04:12 <dolio> The reason it's a superclass is to avoid the extra constraint.
02:05:49 <mmorrow> the Show constraint is even more ludicrous
02:06:05 <mmorrow> ("ludicrous" may be a strong word here, but still)
02:06:31 <dolio> Yeah, that isn't even used in sugar, is it? The rationale is just "you want to print numbers a lot of the time, and don't want to write Show".
02:06:48 <mmorrow> yeah, that's the only rationale i can figure
02:15:58 <ivanm> mmorrow: well, didn't Haskell come out of a language-research/teaching environment rather than a mathematical one?
02:19:14 <mmorrow> ivanm: perhaps, but that explains the Show constraint?
02:19:47 <mmorrow> ivanm: but i understand what you're saying
02:20:08 <ivanm> mmorrow: AFAIK, there's three ways of teaching languages: string-based, calculator-based and random (e.g. LYAH)
02:20:26 <ivanm> Haskell is typically done using calcualtor-based AFAICT, so a Show constraint is usually needed
02:21:03 <david1> I'd like to pattern match against an empty Data.Map. I haven't found out how to do. Any ideas/hints/tips?
02:22:07 <ivanm> david1: you can't
02:22:14 <ivanm> @hoogle Map a b -> Bool
02:22:14 <lambdabot> Data.Map null :: Map k a -> Bool
02:22:14 <lambdabot> Data.Map valid :: Ord k => Map k a -> Bool
02:22:14 <lambdabot> Data.Map member :: Ord k => k -> Map k a -> Bool
02:22:25 <ivanm> david1: ^^ use Data.Map.null as a guard or something instead
02:22:26 <magthe> david1: use guards instead, maybe?
02:22:29 <ivanm> s/as/in/
02:25:53 <david1> ivanm: ok
02:26:35 <mmorrow> ivanm: i think saying that that implies that all Nums should be Shows is dubious at best
02:28:36 <david1> ivanm: why is it impossible? (I'm trying to understand why...)
02:28:53 <david1> ivanm: I mean, you can with lists, but not maps
02:28:59 <mmorrow> instance (Num a, Num b) => Num (a -> b) where f + g = (\a -> f a + g a); f * g = (\a -> f a * g a); f - g = (\a -> f a - g a); negate f = negate . f; ...
02:29:52 <mmorrow> instance Show (a -> b) where show = unsafePerformIO (peek nullPtr :: IO Int) `seq` "42"
02:55:27 <zygoloid> mmorrow: you didn't use (Num a) there :)
03:06:39 <mmorrow> zygoloid: true
03:09:10 <zygoloid> i prefer: instance Num a => Num (a -> a) where fromInteger n a = fromInteger n * a; (f + g) a = f a + g a; (f * g) a = f (g a); negate f a = negate (f a)
03:17:32 <dolio> That isn't Haskell98 + FFI, though.
03:18:10 <zygoloid> true, but flexible instances is pretty common, rigt?
03:19:10 <dolio> I don't think it's very controversial.
03:19:37 <dolio> That was more of a joke, that mmorrow's unsafePerformIO segfault is conformant Haskell.
03:19:58 <zygoloid> heh, well fair enough :)
03:20:03 <mmorrow> :)
03:21:41 <dolio> Although I'd go with the 'fromIntegral = const . fromIntegral' version.
03:23:04 <zygoloid> i just like being able to write "f x = 2 x^2 + 3 x + 4"
03:23:06 <zygoloid> :D
03:23:30 <dolio> Yeah, I don't think that's very important. :)
03:23:47 <dolio> Also, you know that's (2*x)^2 at the beginning, right?
03:23:50 <int-e> but is'nt it confusing that it means 4*(x^2)?
03:24:24 <zygoloid> dolio, int-e: that's all part of the fun :)
03:25:17 <dmwit> I find your definition of (f * g) a = f (g a) highly unintuitive.
03:25:34 <dmwit> wait, no
03:26:54 <dmwit> Well, there doesn't seem to be any really "good" thing to put there, anyway.
03:40:19 <ivanm> davidL: sorry, was AFK
03:40:31 <ivanm> wait, does davidL == david1 ?
03:45:36 <dolio> dmwit: Well, application is supposed to be multiplication in the underlying Num. So (f + g) a = (f + g) * a = f*a + g*a = f a + g a, and (f * g) a = (f * g) * a = f * (g * a) = f (g a).
03:47:36 <dolio> (negate f) a = (negate f) * a = negate (f*a) = negate (f a)
03:56:09 <mxc> if you're building a project via cabal/ghc, is there a way to compile distinct modules in parallel?
03:56:24 <ivanm> mxc: not yet
03:56:40 <ivanm> mxc: it's an often asked-for feature though
03:57:29 <mxc> having never looked at GHC's internals, is it a reasonable GHC-newbie project?
03:57:42 * ivanm doubts it
03:58:02 <ivanm> mainly because if it was that easy, it would have been done by now
03:58:33 <mxc> in theory, its not a super difficult problem, if modules are distinct, compiling them is 'pure' in the sense that the creation of .o files doesn't really matter
03:58:35 <Saizan> nominolo worked on it for a while, not sure how it went
03:59:14 <Saizan> mxc: you need the .hi files, so you've to build them in dependency order
03:59:18 <mxc> yeah
03:59:38 <mxc> what I meant by 'distinct' was modules w/out mutual dependencies
03:59:48 <mxc> s/mutual//
04:00:08 <zygoloid> aren't ghc compile times fast enough already? :)
04:01:06 <mxc> zygoloid, i use a lot of TH that spits out a couple thouands lines of splices, which slows it down..
04:01:14 <zygoloid> ah :)
04:01:14 <Berengal> Doesn't ghc do somewhat extensive cross-module compilation?
04:01:15 <Saizan> however the problem is that the ghc code has some assumptions that prevents it to compile in multiple threads at the same time
04:01:33 <mxc> that must be the problem then
04:01:51 <mxc> and, that also means that this is way beyond what I have the time and experience to do
04:01:52 <Saizan> nominolo has done some work on removing those, iirc
04:02:14 <zygoloid> can't ghc just fork? ;-)
04:02:19 <mxc> what about compiling in sep processes?
04:02:30 <mmorrow> mxc: a much more realistic approach imo is to use `ghc -M' to get the deps in the form of make rules (e.g. "Foo.o: Foo.hs Bar.hs .."), then implement the algo that make would use to use those rules to build the project in parallel
04:02:41 <mmorrow> mxc: then this can be added to cabal
04:02:47 <mmorrow> PROFIT!!@
04:03:02 <Saizan> sep processes have a big overhead
04:03:28 <mxc> but that overhead is small relative to compiling a seperate file, isn't it?
04:03:30 <Saizan> i couldn't get huge speedups, but i don't have that many cores either
04:04:05 <Saizan> using separate processes ghc has to reload libs and the package db every time
04:04:11 <mmorrow> Saizan: i just know that compiling ghc itself with make -j1 takes X number of minutes, and make -j3 take (x / a lot) number of minutes
04:04:17 <mxc> mmorrow - thanks
04:04:29 <Saizan> the package db format has improved in 6.12 though
04:04:38 <Axman6> mmorrow: so, did you make those pure-fft changes yet?
04:04:44 <mxc> saizan, not if it just fork()s right?
04:04:59 <mmorrow> also, cabal uses ghc --make which tediously will scan each of your 100 modules and try to compile them, realize that they don't need compiling, and on and on..
04:05:44 * mmorrow recently switched to a makefile for a large project since it was starting to get painful using only one core
04:06:45 <mmorrow> and there's something nice about doing "make" two times in a row, and the second time finishing w/in a second saying "up to date" instead of trying to compile every module, then re-installing everything
04:07:02 <mmorrow> </rant> :)
04:07:07 <Saizan> well, ghc --make does the same thing the makefile does, no?
04:07:33 * mmorrow checks what exactly ghc does
04:08:08 <Saizan> (to only build there's "cabal build")
04:08:14 <Baughn> mmorrow: cabal make?
04:08:37 <mxc> on an unrelated note, is it inappropriate to use Haskell-Cafe to announce users group meetings?
04:08:50 <Axman6> i wouldn't say so
04:09:24 <Baughn> It always seemed noisy to me, mainly since the groups are universally not-here.
04:10:11 <blackdog> mxc: it's not bad form to announce a few times, but you should probably have your own local mailing list
04:10:26 <mxc> we will, this is our first meeting..
04:10:32 <Baughn> Mm. I'd be fine with announcing its existence, but not the weekly meetings.
04:10:36 <blackdog> mxc: where are you?
04:10:42 <mxc> singapore
04:10:53 <Axman6> mmorrow?
04:14:17 <namor> How do you write a ' as a char literal?
04:14:24 <namor> '\'' does not work..
04:14:25 <Baughn> > '\''
04:14:26 <lambdabot>   '\''
04:14:31 <Baughn> Does too.
04:14:49 <mmorrow> Saizan: ok, i just realized why ghc --make takes so much longer than make
04:15:04 <Axman6> > text "\'"
04:15:05 <lambdabot>   '
04:15:07 <Twey> > '\'' : '"' : '\'' : []
04:15:08 <lambdabot>   "'\"'"
04:15:09 <mmorrow> Saizan: so suppose you have source-dirs: one, two, three, four, five
04:15:10 <namor> Douh..  I just wrote '\' due to this lambda-symbols in my emacs. Thanks, Baughn ..
04:15:13 <Axman6> > text ['\'']
04:15:14 <lambdabot>   '
04:15:17 <mmorrow> and one of your modules is Foo
04:15:27 <mmorrow> ghc --make will call stat() on
04:15:43 <mmorrow> *all* of {one,two,three,four,five}/Foo.{gc,chs,hsc,x,y,ly,cpphs,hs,lhs}
04:16:03 <mmorrow> regardless of whether it found Foo in one/Foo.gc
04:16:05 <Baughn> namor: Yeah, I should do something about that.
04:16:15 <mmorrow> , 5 * 9
04:16:16 <lunabot>  45
04:16:23 <mmorrow> 45 stat() calls per module there
04:16:28 <mmorrow> , 100 * 45
04:16:29 <lunabot>  4500
04:16:29 <Axman6> {one,two,three,four,five}?
04:16:39 <mmorrow> 4500 stat() calls if there are 100 modules
04:16:48 <Baughn> mmorrow: Well, I don't think 45 stat calls, even multiplied by 100 modules, is going to take a noticable amount of time..
04:16:52 <mmorrow> Axman6: sh glob syntax
04:16:54 <Baughn> System calls aren't /that/ expensive
04:17:14 <mmorrow> Baughn: compared to the 200 stat() calls the Makefile would cause make to make
04:17:17 <Twey> Baughn: Where's your updated haskell-mode repo, again?
04:17:27 <blackdog> hm, so I'm moving from using "system" to compile new code to using the ghc api... but i'm passing all the flags in as a big stringy list anyway
04:17:28 <Axman6> mmorrow: yeah, but what is the one, two... for? why's it checking there?
04:17:28 <Twey> Baughn: I don't suppose you could get it put on elpa?
04:17:31 <blackdog> i just can't be good, it seems.
04:17:35 <Baughn> Twey: http://projects.haskell.org/haskellmode-emacs/
04:17:38 <Baughn> Twey: elpa?
04:17:39 <Twey> Ah, thanks
04:17:47 <Twey> The emacs package archive
04:17:49 <Baughn> mmorrow: That's a symptom. I don't think it's the cause.
04:17:52 <mmorrow> Axman6: because in the .cabal file, it specifies source-dirs: one two three four five
04:17:59 <Axman6> ah
04:18:00 <Twey> http://www.emacswiki.org/emacs/ELPA
04:18:00 <Baughn> mmorrow: Ask yourself what sort of code ghc is using that needs to call stat 45 times.
04:18:09 <Axman6> also, did you push those oatches yet?
04:18:21 <mmorrow> Baughn: true, i'm sure there're other contributing factors
04:18:27 <mmorrow> Axman6: not yet
04:18:31 <Axman6> heh
04:18:36 <mmorrow> Axman6: i really am going to though!
04:18:42 <Axman6> i know :)
04:18:44 <Baughn> Twey: Well, I'll update the wiki, I guess
04:18:48 <Axman6> it's more fun when you haven't anyway
04:18:49 <mmorrow> Axman6: :)
04:19:09 <Baughn> mmorrow: As an experiment, create a C program that does nothing but stat 4500 times. See how long it takes.
04:19:12 * Axman6 goes back to watching the OpenCL MacResearch podcast thing
04:19:18 <Twey> Baughn: Wiki?
04:19:19 <Baughn> mmorrow: Or wait two minutes. I'm curious myself. :P
04:19:23 <Twey> Baughn: http://tromey.com/elpa/upload.html
04:19:49 <Baughn> Twey: Oh. I see no reason to upload there; there's already a perfectly good page on p.haskell.org
04:19:59 <Baughn> Twey: Unless I can figure out how to do it automatically. I'll look into it.
04:20:02 <mmorrow> Baughn: i'm curious too
04:20:28 <Twey> Baughn: Well, if it's in ELPA it can be automatically installed/updated from within emacs
04:20:58 <mmorrow> Baughn: heh, actually it's more than 45 per module... i didn't scroll down the output from strace enough
04:21:15 <Baughn> mmorrow: Statting test.hs 1,000,000 times took 0.7 seconds
04:21:23 <Baughn> So, yeah, syscalls are slow.
04:21:26 <Baughn> But not /that/ slow.
04:22:25 <Baughn> (Unless there's some bizarre interaction in the VFS, I guess. This was on ext4. I don't know if that matters.)
04:23:52 <mmorrow> for every module, it checks for each of these extensions, in every source dir specified:
04:23:55 <mmorrow> .1.0.o .chs .cpphs .dyn_o .gc .hs .hsc .lhs .ly .o .p_o .x .y
04:24:08 <ivanm> Baughn: are you going to "borrow" some keybindings from indent to indentation in haskell-mode (or whichever way round it's meant to be...) ?
04:24:26 <blackdog> hm. what's an .ly file?
04:24:35 <mmorrow> err, well the object files it only checks the build directory
04:24:46 <mmorrow> blackdog: a literate happy parser
04:24:50 <mmorrow> hehe
04:25:03 <mmorrow> wut, no .lx!?!
04:25:25 <Baughn> ivanm: Such as?
04:25:28 <blackdog> mmorrow: lodge a bug:)
04:25:37 <ivanm> Baughn: C-c C-=
04:25:49 <Baughn> ivanm: Eh. Perhaps, if it doesn't take too much work.
04:25:53 <ivanm> that was one of the reasons I switched back to indent
04:26:12 <ivanm> (that and indentation not letting me stop work on one function mid-way through to write another lower one)
04:26:17 <Baughn> ivanm: haskell-indentation.el is hard to understand.. and I've only been at this a week. I intend to fix the bugs before I consider new stuff. :P
04:26:27 <ivanm> heh, fair enough
04:26:41 <Baughn> Also, eh? Indentation lets you do that..
04:29:43 <ivanm> Baughn: it didn't when I tried it a few months back (when it was still officially called kuribas' mode by quicksilver :p )
04:30:38 <Baughn> ivanm: I never noticed. I know I've done that..
04:30:46 <Baughn> ivanm: Define "doesn't work", please?
04:31:05 <ivanm> Baughn: it wouldn't indent properly, and kept whining
04:31:06 <ivanm> ;-)
04:31:27 <ivanm> Baughn: I've seen posts about defining a new keybinding to force a newline without the indentation stuff; that kind of thing would have been handy
04:31:32 <Baughn> ivanm: Ah yeah.
04:31:36 <Baughn> ivanm: I've fixed that bug.
04:31:41 <Baughn> It's in the darcs repo. ;)
04:32:01 <ivanm> right, which means "it's not in a release yet" ;-)
04:32:25 <Baughn> I'll release it later today. ^^;
04:32:44 <Baughn> It still actually errors out, but I've got it handling the error and at least inserting a literal newline/space/whatever.
04:34:37 <ivanm> Baughn: if it errors out, then shouldn't you fix that before releasing?
04:34:58 <Baughn> ivanm: It always errored out. Now I handle the error and insert whatever key you asked for before showing it.
04:35:05 <ivanm> ahhh
04:35:08 <mmorrow> Saizan: yeah, separate processes doesn't seem ideal from the pov of each ghc instance needing to load its init stuff every time, but istr the paper on ghc compiling in parallel concluding that separate processes with make -jN turned out to be pretty much the same, and also ghc seems to be plagued with non-thread-safety
04:35:24 <ivanm> so you tell emacs to stop throwing hissy fits? :p
04:35:49 <Baughn> Yep.
04:35:52 <ivanm> Baughn: tbh, I quite like the tab cycle concept... now, if only kuribas' parser could be used instead to give better suggestions... >_>
04:36:10 <Baughn> ivanm: I'll look into it.
04:36:19 <Baughn> Might be doable, I'm not sure
04:36:59 <Baughn> ..ideally, the parser would never error out in the first place, but it's /complex/. There will probably always be bugs. At least this ways they're a light annoyance that doesn't really break your focus.
04:37:51 <ivanm> Baughn: is it complex because it's hard to parse Haskell, or because it's in elisp?
04:38:05 <Twey> Heh
04:38:14 <blackdog> ivanm: it can be two things:)
04:38:21 <Twey> indent indents to the *last* term of a do-extract
04:38:25 <ivanm> blackdog: "or" implies "at least one"
04:38:35 <Twey> n = do x <- a
04:38:43 <blackdog> ivanm: only if you're a programmer
04:38:47 <Twey>             y <- b
04:38:59 <Twey>                  z <- c
04:39:03 <ivanm> blackdog: or a mathematician!
04:39:08 <Twey> And it kind of drifts away down the page :
04:39:15 <ivanm> heh
04:40:07 <Baughn> ivanm: Both.
04:40:26 <mmorrow> Saizan: ah found it, the par --make experiment writeup is in http://www.haskell.org/~simonmar/papers/multiproc.pdf
04:40:34 <Baughn> ivanm: It's mainly haskell, but the (car (cdr (cdr (car (caddadr ...))))))) forms don't help.
04:40:55 <ivanm> heh
04:41:01 <flux> baughn, just write structural pattern matcher first :)
04:41:21 <Twey> The font-lock symbols are cool
04:41:33 * Baughn is off to watch clouds.
04:41:52 <Twey> Does it adjust indentation on saving when they're different widths to the original?
04:41:57 <Twey> Enjoy :
04:42:00 <Twey> Oh, okay
04:43:33 <Twey> Seems not.  Aw.
04:51:33 <ben_m> I couldn't come up with a pointfree way for 1-based list access (xs !! (n-1)) so I fed it to the pointfree program
04:51:42 <ben_m> It came back with "(. subtract 1) . (!!)"
04:52:01 <ben_m> I've been staring at that for 10 minutes, trying to understand it.
04:52:17 <Axman6> heh
04:53:00 <Twey> Hehe
04:53:03 <ivanm> @unpl (. subtract 1) . (!!)
04:53:03 <lambdabot> (\ d g -> d !! (subtract 1 g))
04:53:10 <ben_m> yeah
04:53:15 <Axman6> ((. subtract 1) . (!!)) xs n -> ((xs !!) . subtract 1) n -> ...
04:53:27 <ben_m> *blinks*
04:53:35 <Twey> @pl \a b -> f a (c b)
04:53:35 <lambdabot> (. c) . f
04:53:44 <Axman6> hmm, less helpful than i wan hoping for
04:53:46 <Twey> You can remember that as a general rule
04:53:56 * Axman6 prefers not to
04:54:09 <ben_m> yeah
04:54:22 <ben_m> I'm trying to understand how you can function compose a function composition :D
04:54:34 <Twey> (. c) . f $ a b ==> (. c) (f a) $ b ==> f a . c $ b ==> f a $ c b
04:55:11 <Twey> It's one of those stumbling blocks that everyone encounters, I think :
04:58:35 <blackdog> nothing better than being able to delete a comment like "OH GOD FIXME FIXME FIXME"
04:58:43 <Twey> Hahaha
04:59:12 <ben_m> But not fixing whatever it refers to? :P
04:59:17 * Axman6 has never written code requiring such comments :P
04:59:20 <blackdog> no, the monster is dead
04:59:24 <blackdog> Axman6: liar!
04:59:29 <Axman6> nuh uh!
04:59:37 * Axman6 writes perfect code first time
05:00:27 <ivanm> *cough* yeah right *cough*
05:00:49 <blackdog> I'm trying to find an acceptably polite way to suggest I don't quite believe you, you lying canberran bastard:)
05:01:27 * Twey laughs.
05:01:52 <blackdog> the old code was calling out to ghc again in a system call, with the path defined by hard-coded constants in the source. production-ready, as they say.
05:02:34 <Axman6> "Everyone has a /Users/Axman right?"
05:03:11 <blackdog> they'd better also have ruby 1.9.1 installed in /usr/local, or they're going to get precious little satisfaction
05:03:45 <Axman6> symlinked fine?
05:05:46 <blackdog> sure. if their platform doesn't support symlinks it's not my fault...
05:06:03 <p_l> what platform these days doesn't support symlinks?
05:06:29 * p_l conveniently forgets about outdated/incorrectly installed windows
05:06:50 <blackdog> p_l: you need cygwin to get them on windows, don't you?
05:06:56 <det> Windows supports symlinks ?
05:07:06 <p_l> blackdog: nope, NTFS supports hard links and symlinks
05:07:14 <p_l> explorer.exe doesn't like them, though :P
05:07:28 <ben_m> explorer.exe doesn't even like itself
05:07:44 <p_l> in fact, the reason Vista requires NTFS is mainly because it relies on hard links
05:07:45 <blackdog> explorer.exe got real bad self-esteem problems
05:07:58 <blackdog> sometimes, explorer.exe cuts itself to feel something
05:08:03 <blackdog> ... wow, that went dark fast. sorry.
05:08:11 <p_l> explorer.exe is EMO
05:08:13 <ben_m> That's expected in discussions about Windows.
05:08:21 <ben_m> They go either dark or hilarious.
05:10:32 <Twey> So, let me get this straight the filesystem that Microsoft developed supports symlinks, but the file manager Microsoft developed to browse the filesystem that Microsoft developed doesn't?
05:10:57 <Saizan> mmorrow: the measurements change dramatically depending on how many packages you've installed, though ghc-6.12 should have improved this
05:11:08 <yitz> Twey: it's hard to teach an old dog new tricks
05:11:51 * Twey headdesks repeatedly.
05:12:12 <p_l> Twey: dichotomy caused by mixing NT and DOS-based technology...
05:13:10 * p_l patiently waits for nmap to finish scanning the idiot that tried to hack his corporate server...
05:15:06 <Axman6> sounds like a job for backtrack linux
05:15:16 <ivanm> Axman6: what's that?
05:15:47 <Axman6> a hackers wet dream: http://www.remote-exploit.org/backtrack_download.html
05:16:19 <Axman6> worth downloading and checking
05:16:32 <mauke> ttps://wiki.remote-exploit.org/backtrack - SSL received a record that exceeded the maximum permissible length.
05:16:34 <Axman6> i, uh, imagine it would be very good for wardriving >_>
05:16:36 <mauke> (Error code: ssl_error_rx_record_too_long)
05:16:48 <Axman6> mauke: yeah, safari doesn't like it either
05:17:33 <p_l> Axman6: I visited auth.log after few days. Someone was idiotic and tried to search usernames from one IP...
05:18:53 <p_l> interestingly, no one played with mail server...
05:19:42 <Twey> Oh, new version at last
05:27:04 <blackdog> Twey: ?
05:27:43 <Twey> BackTrack
05:31:09 <paper_cc> is Hackage down?
05:31:54 <mauke> yes
05:32:12 <koeien> ... :( again
05:32:15 <koeien> i need a package
05:34:40 <heita> /join #haskell:*.jp
05:34:43 <mmorrow> Saizan: what i'm really on about is getting the ability to use all cores you might have with cabal
05:35:20 <mmorrow> Saizan: however it's done is the same to me, i just really want it to be done somehow
05:35:47 <mmorrow> Saizan: what do you think are the most feasible options?
05:36:27 <mmorrow> Saizan: what is the information/capabilities hbuild needs to be able to do it?
05:36:36 <mmorrow> module dep info from ghc?
05:37:06 <Twey> #haskell-ja
05:37:09 <Twey> What happened to it?
05:37:15 <mmorrow> Saizan: (i'm talking intra-package parallelism here)
05:37:55 <mmorrow> Saizan: inter-package would be nice as well, for when you're building multiple packages in one go, but i'm most interested in the intra-package case at the moment.
05:38:56 <mmorrow> Saizan: well, also inter-package parallelism seems to be the easier-to-implement of the two anyways, since cabal already has all the dep info it needs to do this.
05:43:04 <mmorrow> Saizan: i guess i'm also not considering getting ghc to do it a feasible option
05:43:30 <Twey> http://downforeveryoneorjustme.com/hackage.haskell.org
05:43:31 <Twey> >.<
05:43:38 <mmorrow> since no one has managed it yet, but not for lack of attempts
05:43:57 <Twey> The Hackage server seems about as stable as a card castle
05:44:11 <mmorrow> ..in a wind tunnel
05:44:40 * mmorrow is in a super positive mood right now :)
05:44:45 <Twey> Hehehe
05:44:51 <lantti> Hmmm... There's a new research project...
05:44:58 <Twey> Hahaha
05:45:26 <blackdog> alright. a clean compile, and i'm going to bed before i break anything in a sleep-deprived stupor. Night, all.
05:46:05 <Axman6> o/ blackdog
05:46:17 <mmorrow> night
05:46:23 * Axman6 deletes one line of hubris before he goes to sleep
05:47:41 <blackdog> KILL YOU WITH FIRE
05:48:43 <ivanm> blackdog: want some matches? :p
06:03:03 <ben_m> Alright, writing _everything_ pointfree is not a good idea
06:03:20 <Twey> Writing many things point-free is not a good idea
06:03:32 <ben_m> Helps me learn stuff though
06:03:42 <Twey> Some functions are nicer point-free.  Most aren't.  Try to arrange your code to maximise the ones that are.
06:03:45 <ben_m> But my pointfree version of isPalindrome is ugly
06:03:52 <ben_m> Using Arrows though, so I learned something again.
06:04:23 <Twey> isPalindrome = uncurry (==) . (id &&& reverse)
06:04:33 <Twey> (navely)
06:04:38 <ben_m> Yep
06:04:41 <ben_m> That's what I have
06:04:48 <Twey> That's not ugly :
06:04:59 <ben_m> isPalindrome xs = xs == (reverse xs)
06:05:03 <ben_m> That's a lot clearer though :D
06:05:25 <Twey> They're about the same to me
06:05:30 <Twey> (you don't need the brackets)
06:05:39 <Twey> Shorter, yes; clearer, not really
06:05:39 <ben_m> oh right
06:05:57 <Axman6> what's the alternative?
06:05:58 <kw317> much clearer -- you don't need to know about arrows
06:06:08 <kw317> adding another abstra
06:06:14 <Twey> That doesn't make it clearer, kw317
06:06:18 <Twey> Just more newbie-friendly
06:06:24 <mauke> ap (==) reverse
06:06:27 <kw317> ction for no good reason is not a good idea
06:06:29 <Twey> :t ap
06:06:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:06:31 <Twey> mauke: Nice
06:06:39 * Axman6 agrees with kw317 
06:06:41 <ben_m> ... :(
06:06:56 <ben_m> bunch of one-uppers!
06:07:05 <mauke> obvious solution
06:07:22 <ben_m> Not for me yet ;)
06:07:51 <mauke> touch your inner SKI
06:08:24 <Baughn> ivanm: How about if, instead of tab doing nothing when at the rightmost position, it switches to the leftmost? That'd be easy to implement, and it sounds cycle-ish.
06:08:27 <kw317> <quote>Thus spake the master programmer: ``Though a program be but three lines long, someday it will have to be maintained.''</quote>
06:08:35 <ben_m> SKI is one of those things I keep not looking at because it looks scary
06:08:40 <Baughn> ivanm: Though pressing backspace at that point would go back to the previous line. Hm.
06:08:58 <Twey> kw317: And if it's being maintained by someone who doesn't know arrows, you're in big trouble.  ;)
06:09:15 <Axman6> ok, sleep time. night all
06:09:23 <Twey> Not that you really need to know arrows here
06:09:28 <mauke> ben_m: it's pretty simple. I x = x; K x y = x; S f g x = f x (g x)
06:09:30 <Twey> We're just using the handy tuple functions
06:09:30 <kw317> ben_m: ski is dead simple really
06:09:35 <Twey> 'night, Axman6 
06:10:10 <Twey> id, constant what does the s stand for?
06:10:19 <mauke> ap
06:10:23 <Twey> Hahaha
06:10:29 <Axman6> ap doesn't start with S!
06:10:36 <mauke> constant doesn't start with K!
06:10:47 <Axman6> sounds like it does!
06:10:49 <Twey> But everybody uses k for a constant :
06:10:58 <Berengal> or C
06:11:04 <Twey> Aye
06:11:11 <mauke> wasn't C join?
06:11:17 <yitz> constant starts with a k in german
06:11:18 <Berengal> But then again, everyone forgets about the C
06:11:31 <Twey> So clearly we should use k instead :
06:11:45 <SamB_XP> does ap start with s in german?
06:11:57 <kw317> not really ;-)
06:11:58 <Twey> ap Sie!
06:12:15 <yitz> Twey: that' it! :)
06:12:19 <yitz> that's
06:12:21 <kw317> lol
06:12:35 <Berengal> I've always called them "identity", "constant" and "smurf"...
06:12:46 <yitz> oh wait - then it only works for imperative languages. drat.
06:13:00 * Twey laughs.
06:13:07 <Axman6> speaking of SKI, you guys might find this quite interesting: http://www-staff.it.uts.edu.au/~cbj/Publications/factor_talk.pdf
06:13:26 <mauke> hah, apparently Curry is to blame for K
06:13:34 <mauke> Schnfinkel called it C
06:13:59 <yitz> oh, S stands for Schnfinkel
06:14:57 <Axman6> adds a new combinator F: FAMN -> M, F(PQ)MN -> NPQ (ie, pattern matching on partially applied values). supposedly adds a lot of new power
06:14:59 <Twey> yitz: Oh, obviously.  How did I miss that?
06:15:19 <Twey> What's the point of the I?  It's just SKK anyway
06:15:39 <yitz> Twey: right, it's just a convenience
06:15:42 <mauke> they couldn't decide whether to use SKK or SKS
06:15:49 <yitz> syntactic sugar
06:16:18 <Axman6> no one's interested in SF-logic? :(
06:16:19 <Twey> Aha
06:16:26 <Twey> mauke: Haha :
06:16:29 <Twey> Axman6: I'm reading it!  :
06:16:33 <Axman6> good :)
06:16:35 <Berengal> It doesn't take much syntactic sugar to make SKI or LC rather nice languages, actually...
06:16:36 <Twey> Slowly.
06:16:59 <yitz> Berengal: sure. look at unlambda, for instance.
06:17:09 <mauke> he said "nice"
06:17:28 <Berengal> yitz, unlambda isn't nice...
06:17:41 <Berengal> But really, simple text substitution macros are all you need
06:17:45 * yitz removes tongue from cheek
06:17:58 <mauke> I think S stands for substitute
06:17:59 <Berengal> Give a name to a common pattern
06:18:22 <yitz> what's the lazy version of unlambda called again - lazy k or something?
06:18:38 <Berengal> lazy k, yeah
06:19:09 <Axman6> Twey: when i saw the talk about this stuff given, he said that he was told to be very careful about what he said about this SF stuff, because it rewrites a lot of the last 40 or so years CS (or something along those lines)
06:19:18 <jkramer> Hello
06:19:22 <yitz> Berengal: so you're saying unlambda+m4 is nice?
06:19:27 <Axman6> 'lo jkramer
06:19:38 <jkramer> I'm lookup for something like parMap, but for IO functions
06:19:44 <jkramer> Is there something in haskell core?
06:19:59 <Axman6> jkramer: what should its type be?
06:20:07 <Berengal> yitz, what's m4?
06:20:24 <ben_m> When do I have to promote a function to a monad and when don't I?
06:20:39 <ben_m> When I use ap
06:20:52 <jkramer> Axman6: I'm not sure, maybe (a -> IO b) -> [a] -> [b]
06:21:08 <Axman6> that'd have to be IO [b]
06:21:21 <Berengal> ben_m, ap always takes two monads as arguments, so when you only have a pure function would be the answer
06:21:22 <jkramer> Oh right
06:21:50 <Berengal> ben_m, of course, pure functions are also monads...
06:21:56 <jkramer> I only find mapM, but I guess that's not parallel
06:22:47 <Axman6> jkramer: something like: parMapIO f xs = forM xs (\x -> do var <- newEmptyMVar; forkIO (f x >>= putMVar var); takeMVar var)?
06:22:51 <Berengal> jkramer, I don't think that exists. I wrote it some time back, just to check out STM, and it wasn't too hard
06:23:14 <jkramer> Ok, I'll have a look, thanks
06:23:16 <Axman6> not ideal of course
06:23:38 <Axman6> since if earlier calls take longer than later ones, you might not get much speedup
06:23:46 <ben_m> Functions as instances of Monads/Arrows/Applicative still confuses me
06:24:02 <jkramer> Axman6: Thanks, I think I'll build on top of that
06:24:09 <jkramer> I need some more functionality anyway
06:24:17 <Axman6> ok
06:24:38 <Berengal> ben_m, arguably, they're the easiest arrows to understand. Monads and Applicatives... not so much
06:25:05 <ben_m> Oh yeah, function as Arrows is pretty obvious
06:25:07 * Axman6 agrees, and goes to sleep
06:27:18 <FunctorSalad_> functions as arrows is not the same idea as the ((->) e) functor though
06:27:22 <mauke> ben_m: do you know Reader?
06:27:46 <malosh> hackage seems down ?
06:28:06 <Berengal> Functions as arrows is just (->), i.e. functions
06:28:42 <MrBlueSky> Yeah, hackage is down for me
06:28:54 <malosh> and there are no mirrors ?
06:28:55 <ben_m> mauke: no
06:29:22 <FunctorSalad_> so did anyone grab the tarball after it was back up last time...?;)
06:29:44 <mauke> yes
06:29:56 <mauke> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.tar
06:30:38 <FunctorSalad_> mauke: nice
06:31:15 <mauke> maybe I should make a torrent
06:31:42 <fentiman> hello all, I am new to irc and haskell
06:31:52 <mauke> hi
06:33:03 <Berengal> mauke, I'd seed a torrent, slow as my upload may well be...
06:33:56 <medfly> yo
06:34:42 <WillOne> Hay Medfly
06:34:57 <WillOne> Come join #wrongplanet, we miss you :3
06:35:29 <koeien> i'd seed too, i have 100 mbit up
06:36:14 <mauke> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.tar.torrent
06:36:21 <jokerGTA> guys can anyone help me with parser i am trying to write
06:36:50 <Berengal> Hmmm, I wonder if a cabal torrent client thingy would be nice...
06:36:52 <mercury^> mauke: how large is the whole ball?
06:36:57 <koeien> 86 mb
06:37:22 <mauke> wait, maybe I should untar this thing first
06:37:27 <mercury^> Quite moderate.
06:37:37 <koeien> yes, so people can select a few packages they want?
06:38:05 <Taejo> jokerGTA: I'm sure somebody can. What seems to be troubling you?
06:38:07 <koeien> jokerGTA: a bit more specific? what is your problem?
06:38:13 <malosh> is it possible to reconfigure cabal so that it fetches packages at a specific address ?
06:38:43 <jokerGTA> i have simple gramar that i have to parse...i made 2 different data types...1 data type for expression and one for statement
06:38:48 <koeien> malosh: ~/.cabal/config
06:38:50 <dcoutts> malosh: you mean uses a different hackage server? if so yes, you can have several
06:38:52 <jokerGTA> ill post what i have so far
06:39:16 <malosh> koeien : thanks
06:39:25 <malosh> dcoutts : that was it ;-)
06:39:44 <koeien> mauke: are you going to untar it, or is this the final torrent?
06:39:54 <mauke> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
06:39:58 <jokerGTA> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4553#a4553
06:39:58 <mauke> should be untarred
06:40:48 <Taejo> jokerGTA: I would recommend using parsec rather than trying to write a Read instance
06:41:30 <Taejo> IMO, Read is hard-to-use, and makes up for it by being slow
06:41:35 <jokerGTA> how would o change it
06:42:05 <malosh> Berengal : want to set up a trac and darcs to start a torrent-cabal ?
06:42:27 <koeien> the only problem i see is authentication of packages
06:42:29 <Taejo> jokerGTA: I see you're importing Parsec, but you're not actually using it. Try find a good Parsec tutorial
06:42:44 <Taejo> does anybody know of a good Parsec tut?
06:43:33 <mauke> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
06:43:37 <Beelsebob> Taejo: I recommend finding a good applicative functors tutorial
06:43:38 <jokerGTA> even if i used it i am note sure how would i made difference between statement and expression
06:43:42 <Beelsebob> and then parsec will magically make sense
06:44:18 <jokerGTA> it always picks one word or token or whatever and then you can do something with it....the rest is just the string
06:44:24 <Taejo> jokerGTA: well you would have a parseStatement parser and a parseExpression parser
06:44:34 <jokerGTA> ok then what
06:44:48 <jokerGTA> i am reading one string
06:44:50 <jokerGTA> like this one
06:44:55 <jokerGTA> while not(atExit) do     if look and not(atExit) then move;turn(Left) else turn(Right) fi od
06:45:07 <jokerGTA> this is what i need to read
06:45:56 <mauke> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent - come on, I want more peers! :-)
06:46:19 <Taejo> mauke: if I had bandwidth to burn, I would gladly help you
06:46:39 <mercury^> mauke: You need to make a website where our ratio is tracked.
06:46:43 <jokerGTA> i cant run 2 parser at the time
06:46:56 <Taejo> jokerGTA: well, the statement parser can refer to the expression parser, if that's what you're worried about
06:47:42 <jokerGTA> how?lets just say this...you read string ....and it encounters word "while" how does it know if it need expression parser or statement parser
06:48:05 <koeien> while (expr) <-- you cannot have a statement in the guard of the while, can you?
06:48:17 <Taejo> well jokerGTA I don't know your language, but isn't "while" always a statement?
06:48:30 <jokerGTA> exactly...
06:48:45 <jokerGTA> this is part i dont get
06:48:50 <jokerGTA> we have one string right
06:48:56 <Taejo> jokerGTA: but you haven't read the parsec tutorial
06:48:57 <malosh> jokerGTA : are you having problem with a not LL(1) grammar ? i.e. maybe whilewhile could be a variable ?
06:48:58 <jokerGTA> that consist of statemtnets..and expression
06:49:04 <Taejo> how can you know what's not to get?
06:49:07 <mauke> jokerGTA: only statements
06:49:24 <jokerGTA> sentence i showed you consist of both
06:49:28 <mauke> jokerGTA: no
06:49:31 <jokerGTA> ?
06:49:40 <Taejo> it consists only of statements
06:49:49 <Taejo> some of those statements *contain* expressions
06:50:12 <jokerGTA> so i would start reading with statement parser?
06:50:19 <mauke> yes
06:50:39 <Taejo> jokerGTA: why don't you learn parsec first, instead of trying to guess what problems you might encounter with it?
06:50:45 <jokerGTA> at what point i would call expression parser? when it find words described in my expression data type?
06:52:01 <mauke> statement = 'while' '(' expression ')' statement | 'if' '(' expression ')' statement 'else' statement | expression ';'   # this is basically how C does it
06:52:32 <mauke> jokerGTA: when you need to parse an expression
06:54:19 <jokerGTA> i am gonna try to go over that tutorial.. mauke
06:58:25 <Taejo> is hackage down?
06:58:29 <koeien> yes
06:59:23 <profmakx> hackage grief again :(
07:00:40 <malosh> I'm trying to make a mirror. I have the archive, now I get a 404 error from cabal when I try to update.
07:00:45 <malosh> How is the package list called ?
07:05:56 <koeien> malosh: i would try 00-index.tar.gz
07:07:29 <malosh> It seems to work
07:07:42 <malosh> I'll post the address as soon as cabal update finishes
07:07:58 <FunctorSalad_> modify (\s -> s {topic = http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent : topic s})
07:08:01 <FunctorSalad_> ?
07:08:09 <koeien> i've posted to -cafe too
07:08:09 <ben_m> Can you see how instances are defined? For example the function instance for Monads?
07:09:50 <FunctorSalad_> ben_m: ":i Monad" in ghci will tell you where they are defined
07:11:45 --- mode: ChanServ set +o mauke
07:11:45 --- topic: set to '["hackage is down, backup torrent at http://xrl.us/bfzy7n", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]' by mauke
07:12:45 --- mode: mauke set -o mauke
07:13:29 <koeien> another seed up :)
07:13:59 <jkramer> I think hackage is having problems again :(
07:14:16 <mauke> o rly
07:14:25 <koeien> jkramer, yes, there is a torrent available at http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
07:14:27 <malosh> seems that http://www.lama.univ-savoie.fr/~meunier/archive can replace hackage (temporarily of course !)
07:14:51 <koeien> malosh: let me try that
07:15:18 <jkramer> malosh: I get an empty page :)
07:15:30 <malosh> I won't mirror the http content
07:15:42 <jkramer> Ah
07:15:44 <malosh> so it will not be possible to upload. Only to download packages
07:15:56 <malosh> configure ~/.cabal/config to use it
07:21:16 <FunctorSalad_> can you seed without having to open a port in the NAT?
07:21:36 <koeien> yes, provided that the other person has opened his port
07:36:21 <ben_m> So what does ap do in the context of functions? I can't find how it is defined for them :/
07:36:30 <jkramer> Is there a simple way to wait for all child processes to finish?
07:36:40 <Taejo> ben_m: ap is defined in the same way for all monads
07:36:43 <Taejo> @src ap
07:36:43 <lambdabot> ap = liftM2 id
07:36:58 <ben_m> Oh :)
07:36:59 <jkramer> It seems that a haskell program just kills everything when the main line is finished
07:37:05 <ben_m> Taejo: thanks
07:37:15 <ben_m> Where does lambdabot look for the @src definitions?
07:37:35 <Taejo> ben_m: nobody seems to be sure :) it very often doesn't work
07:37:40 <koeien> they are not always the "real" definition
07:37:52 <mauke> ben_m: in a text file
07:37:53 <ben_m> Just tried looking for the definition of ap myself, but couldn't find it
07:37:58 <mreh> no hackage? :(
07:38:03 <mauke> mreh: /topic
07:38:05 <koeien> ben_m: hoogle is very often efficient
07:38:10 <koeien> effective*
07:38:14 <ben_m> Oh yeah, I use Hoogle a lot
07:38:31 <ben_m> It just said ap could be used instead of liftMn
07:38:35 <koeien> did you notice the "view source" links at the right?
07:38:39 <ben_m> No, I did not.
07:38:58 <ben_m> That's awesome.
07:39:01 <ben_m> Thanks a lot :)
07:39:23 <byorgey> jkramer: I think the easiest way is to create MVars which the child processes write to when they're done; then have the main thread read all the MVars before exiting
07:39:42 <jkramer> Hmm, ok
07:39:48 <byorgey> jkramer: you're right that by default the main thread does not wait for child processes.
07:39:57 <byorgey> er, child threads I mean
07:39:58 <koeien> processes or threads?
07:40:37 <mreh> i thought they had cut off my internet for a moment
07:41:00 <mreh> hackageDB isn't my homepage if you're thinking that
07:48:32 <Botje> mreh: it should be!
07:48:36 <Baughn> mauke: So, hang on, hackage distribution has moved to bittorrent?
07:48:52 <jmcarthur> temporarily, i assume
07:48:55 <koeien> there is a backup torrent available, yes
07:49:21 <Baughn> That makes me want to implement pgp signatures.
07:49:21 <koeien> the filename suggests it was a snapshot of hackage at Oct 19, so it is two weeks old
07:49:25 <koeien> Baughn: yes :)
07:49:41 <jmcarthur> pgp would rock
07:49:46 <koeien> some kind of PKI, like in apt, would be very useful
07:49:54 <Baughn> http://vimeo.com/6590617 <-- Well, in lack of hackage, have a haskell lecture. :3
07:50:16 <Botje> does it discuss monsters?
07:50:26 <mreh> well thank god I don't have a project due in 48 hours written extensively in haskell
07:50:26 <koeien> commutative monads
07:50:28 <mreh> OH WAIT!
07:50:29 <koeien> i think it qualifies
07:50:33 <Baughn> Botje: Nah, just warm fuzzy things
07:50:41 <Botje> oh, allright then
07:50:45 <Baughn> Botje: *Commutative* warm fuzzy thigns.
07:50:47 <Botje> :)
07:50:57 <mreh> does anyone know why hackage is porly?
07:51:34 <Baughn> Could be a disk failure again. Good things often come in twos.
07:51:47 <Baughn> If all their disks are from the same batch..
07:51:52 <mreh> disc failures always come in twos!
07:51:54 <mreh> why is that
07:52:10 <Baughn> Batches often fail at the same time. :P
07:52:19 <Baughn> That's why you want RAID disks to be as heterogenous as possible
07:52:45 <mreh> what, different kinds of discs running in one RAID array?
07:52:47 <mreh> oops
07:52:57 <Baughn> Yes
07:53:12 <p_l> mreh: or at least ones from different batches
07:53:20 <mreh> I've got an old 20GB drive floating around somewhere
07:53:23 <Baughn> Not necessarily to the point of using both magnetic disks and flash, but at least using both samsung and seagate, or something
07:53:38 <Baughn> Or, if not that, then disks from different batches. That's an absolute minimum.
07:53:44 <p_l> Baughn: as long as firmware doesn't conflict, ofcourse
07:53:47 <mreh> do they backup hackage regularly>
07:53:56 <mreh> everynight?
07:54:00 <p_l> (that's more towards hardware arrays)
07:54:05 <Baughn> p_l: ..yeah.
07:54:16 <mreh> who actually runs the server, they're doing a stellar job really
07:54:19 <Baughn> Software raid is more reliable anyhow.
07:54:34 <mreh> hardware RAID is faster
07:54:36 <Baughn> mreh: ..it's just that we all get up in arms anytime there's downtime
07:54:43 <Baughn> mreh: And no, hardware raid is often /not/ faster
07:54:57 <mreh> that seems counter intuitive to me
07:55:00 <p_l> Baughn: well, depends on the exact RAID engine used
07:55:19 <Baughn> mreh: It's a thing. Hardware raid tends to lag CPUs in performance.
07:55:22 <p_l> mreh: question - did you mean *real* hardware RAID, or the shit that is sold to people? ;)
07:55:42 <mreh> p_l: I have a SATA RAID card
07:55:43 <Baughn> mreh: Still, so long as they can at least manage the disks you connect in realtime, that's good enough; cpu offloading is fine
07:55:45 <mreh> real hardware RAID
07:55:53 <p_l> Baughn: higher-end raid hardware tends to be more I/O-bound
07:55:55 <Baughn> And decent hardware raid also has battery-backed caches, etc.
07:56:22 <p_l> battery-backed cache is just the beginning :D
07:56:30 <Baughn> The main problem with hardware raid is, if the /controller/ fails, you may have problems finding new ones that can still read your data
07:56:32 <p_l> log replay in case of failure etc :)
07:56:54 <p_l> Baughn: That's something to take care when you choose manufacturer - some publish their specs, some not
07:57:08 <mreh> so who owns the server? it's good of them to do all this for the community
07:57:16 <p_l> for some *big* ones you can get tools or support, but then we are talking about FC arrays :)
07:57:17 <Baughn> mreh: The galois monk
07:57:18 <koeien> galois
08:00:59 * Baughn ponders commutative IO
08:01:13 <mreh> :t minus
08:01:14 <lambdabot> Not in scope: `minus'
08:01:19 <mauke> :t subtract
08:01:20 <lambdabot> forall a. (Num a) => a -> a -> a
08:01:22 <koeien> :t negate
08:01:23 <lambdabot> forall a. (Num a) => a -> a
08:01:23 <mreh> (y)
08:02:31 <Baughn> p_l: I could probably make IO commutative (monad? Not quite sure..), if I tag each action with the time it should be executed - which is exactly what FRP does. Hm. Neat..
08:02:56 <Baughn> p_l: ..and you have no idea what I just said, do you? Sorry. :P
08:03:42 <p_l> Baughn: Actually I have :P
08:04:32 <p_l> btw, consider checking (or explicit way to pass that info?) for dependencies between I/O actions, then make it run asynchronously :P
08:05:34 <Baughn> p_l: Using FRP, the dependencies get passed implicitly. ;)
08:06:29 <p_l> Baughn: good. Now port GHC to VMS and use its awesome async IO :P
08:13:49 <Baughn> p_l: Watch that movie. At 18.5 minutes, magic happens.
08:14:14 <koeien> you mean the commutative monads thing?
08:14:17 <Baughn> Yep
08:14:23 <koeien> i don't see any magic yet :P
08:14:33 <koeien> free vector spaces!
08:14:37 <Baughn> Well, it looks nice at least. :
08:14:54 <Baughn> And I'm trying to motivate p_l to learn more haskell.
08:18:04 <EddyDean> Is Data.Ratio lazy enough not to simplify fractions if it's not needed?
08:18:16 <jokerGTA> guys when parser encounters first token (lets say word i am looking for) it returns it....but what happens for the rest of the given input
08:18:23 <Baughn> EddyDean: Not so much, no.
08:18:26 <EddyDean> I want the precision, but it's not neccesary that it simplifies for example 10%100 to 1%10
08:18:28 <koeien> EddyDean: i don't see how you can do that
08:18:53 <koeien> ah no, if you ask for numerator or denominator it will reduce
08:19:03 <Baughn> EddyDean: The various ratio functions pretty much assume that all inputs have already been simplified. Breaking this may or may not have consequences.
08:19:09 <Twey> But not otherwise, obviously.
08:19:17 <EddyDean> Okay
08:19:52 <EddyDean> Because I'm doing something similar to [0%1, 1%1000 .. 1%1], and I don't need it to simplify the fractions
08:20:06 <Baughn> EddyDean: Is it a problem if they get simplified?
08:20:22 <koeien> it may actually sometimes be more efficient to reduce, because your intermediate results become smaller
08:20:25 <EddyDean> Performance is important for this program
08:20:26 <koeien> and gcd is very cheap anyway
08:21:03 <malosh> EddyDean : then cheap unboxed couples of unboxed Int# may be better than Data.Ratio, if you can spend the time to rewrite all instances
08:21:16 <p_l> Baughn: you don't have to motivate me, it's just that I've got things in the queue that have higher priority right now ;)
08:21:30 <EddyDean> Well, I'll just have to see if Ratio is fast enough
08:21:35 * p_l already decided that a certain project of his will use Haskell
08:21:39 <EddyDean> if it isn't I'll figure something out
08:21:59 <koeien> Ratio Int /= Ratio Integer, the former is more likely to be efficient, if you can stand the possibility of overflow
08:22:01 <malosh> As always : "premature optimization is the root of all evil". If you've not written the program...
08:22:29 <Baughn> p_l: See, that means I /do/ have to motivate you.
08:22:46 <EddyDean> malosh: I am currently writing the program and it seems to be too slow to be usable
08:23:03 <p_l> Baughn: the "higher priority" is of "non-maskable" kind
08:23:08 <p_l> Baughn: unless you pay me
08:23:17 <malosh> EddyDean : have you profiled it yet ?
08:23:20 <Baughn> p_l: Payment would count as a SMI?
08:24:00 <EddyDean> malosh: No, but it's a very small program
08:24:14 <EddyDean> malosh: I'm sure I'll figure something out, thanks for your help
08:24:19 <iaefai_> Does anyone have trouble getting to http://hackage.haskell.org/packages/archive/pkg-list.html ?
08:24:35 <Twey> Hackage is down
08:24:37 <koeien> yes, hackage is down
08:24:38 <Twey> Again
08:24:39 <koeien> see /topic
08:24:49 <iaefai_> oh ok
08:25:11 <iaefai_> I don't think I have documentation for httpd-shed that I need locally ;-(
08:25:26 <koeien> there is a torrent that you can use
08:25:30 <malosh> iaefai_ : there is a torrent  http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
08:25:42 <mauke> see /topic
08:25:51 <FunctorSalad_> iaefai_: cabal haddock, if you have the package locally
08:27:12 <iaefai_> I just installed it with cabal, I don't think I manually downloaded it. I am looking at the torrent now
08:27:30 <p_l> Baughn: payment would elevate it to the same class, and same class would mean it could get higher priority
08:27:38 <koeien> iaefai_: in that case it is in ~/.cabal/packages
08:28:47 <iaefai_> koeien: Apparently not on windows :p
08:29:12 <koeien> iaefai_: in that case it is *somewhere*, i just don't know where ;)
08:29:46 <iaefai_> ~\AppData\Roaming\cabal
08:46:04 <noZone> Is hackage.haskell.org down or behaving badly?
08:46:15 <koeien> see /topic
08:46:15 <jmillikin> see the title: hackage is currently down
08:46:37 <Zao> If only people could be stabbed in the face with the topic when connecting with popular clients.
08:46:45 <noZone> Thanks... my pathetic eyes didn't see it.
08:47:01 <noZone> Except I've been connected for a long time.
08:47:15 <noZone> And my client *does* stab me in the face.
08:47:26 <Saizan> that must hurt
08:47:38 <noZone> Yeah, it's why I can't read the topic.
08:48:15 <osfameron> heh
08:52:15 <mreh> what? hackage is down?
08:52:56 <Twey> Yes
08:53:07 <mreh> just kidding ;)
08:53:16 <mreh> hahahahaha
08:53:48 <chrisdone> check this, bit of zen html coding: http://gist.github.com/223576
08:55:41 <mandy_> wow hakel just looks so beautiful
08:55:43 <orbitz> is there a shuffle funciton/
08:56:05 <copumpkin> orbitz: nope
08:56:07 <Twey> chrisdone: Nice
08:56:17 <orbitz> drats
08:56:25 <Twey> Now interface it to emacs :
08:56:34 <chrisdone> Twey: already done it!
08:58:20 <iaefai_> Is there any way of generating documentation and having it install it with the rest of the documentation I have, accessible through file:///C:/Program%20Files%20(x86)/Haskell%20Platform/2009.2.0.2/doc/libraries/index.html
08:58:27 <chrisdone> Twey: added an emacs snippet http://gist.github.com/223576
09:01:33 <deech> Hi all, how do I kill a thread spawned by forkIO? In GHCI forkIO returns a 'ThreadID <someID>', but I can't just throw that back into killThread because I get a "Expected type: GHC.Prim.ThreadId#" error.
09:01:37 <Saizan> iaefai_: in ~/.cabal/config set documentation: True and doc-index-file: to some filw writable by cabal
09:02:05 <Saizan> ?type forkIO
09:02:05 <mauke> deech: what's the inferred type?
09:02:06 <lambdabot> Not in scope: `forkIO'
09:02:17 <chrisdone> Twey: first haskell coding I've done for months ;_; been stuck with c#
09:02:23 <Saizan> i think your problem might be unpacking the constructor
09:02:30 <deech> mauke : forkIO :: IO () -> IO ThreadId
09:02:45 <mauke> er, what
09:02:48 <mauke> that's forkIO itself
09:02:58 <mauke> of course you can't killThread forkIO
09:03:15 <Saizan> the ThreadId type is the same as the one of killThread
09:03:37 <deech> Saizan: Yes I believe that is correct. But how do I make a ThreadId out of an Int?
09:03:47 <Saizan> you don't^
09:03:49 <Saizan> ?
09:03:57 <Saizan> why do you want to do that?
09:04:07 <iaefai_> Saizan: Warning: C:\Users\Jeffrey\AppData\Roaming\cabal\config: Unrecognized field doc-index-file on line 13
09:05:05 <Saizan> iaefai_: cabal --version? maybe that feature is not released yet..
09:05:17 <dcoutts> Saizan: it's not
09:05:17 <deech> Saizan: because I am forking threads at the REPL. So, "forkIO $ <some action>" prints out "ThreadID <someid>". I just want to know if there is some way to kill the thread if I didn't assign it to a variable like " x <- forkIO $ <some action>"
09:05:27 <iaefai_> cabal-install version 0.6.2 using version 1.6.0.3 of the Cabal library
09:05:53 <mauke> deech: unlikely
09:06:00 <jokerGTA> guys once when the parser find the for example word i am looking for....what does it do with the rest of this input string
09:06:57 <Saizan> iaefai_: ah, sorry then, it's only available in the darcs version
09:07:39 <iaefai_> Seems like a feature that would be most important :p
09:07:55 <Saizan> jokerGTA: the rest is still there to be consumed by the subsequent parsers
09:08:26 <jokerGTA> so once one parser is done and it finds the word then it calls second parser?
09:08:41 <Saizan> jokerGTA: i.e. in the parser "foo >> bar", first foo consumes as much of the input as it wants, then bar get to look at the rest
09:09:41 <Saizan> iaefai_: only when hackage is down ;)
09:09:44 <jokerGTA> ok tx
09:25:00 <ben_m> Functions as monads are tricky! :D
09:26:28 <byorgey> ben_m: you mean the  ((->) e)  monad?
09:26:33 <ben_m> yeah
09:26:58 <byorgey> yes, it can be tricky to think about the first few times you see it.
09:27:11 <ben_m> On my quest to understanding `ap` I had to understand that first, then work my way to liftM2,then to the do notation, then de-sugar that to >>=
09:27:20 <ben_m> Then it finally made sense.
09:27:24 <byorgey> ben_m: excellent =)
09:27:46 <FunctorSalad_> (->) is also a functor from Hask^op to Hask -> Hask *g*
09:27:49 <Twey> ap is just fmap for monads
09:27:52 <ben_m> I don't understand it will enough to come up with these things though
09:28:07 <Twey> :t ap
09:28:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:28:08 <Twey> :t fmap
09:28:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:28:11 <ben_m> well*
09:28:14 <byorgey> Twey: what?
09:28:14 <Twey> fmap for monads.
09:28:27 <Twey> Oh, wait
09:28:31 <Twey> There's an extra m in there
09:28:37 <copumpkin> liftM is fmap for monad
09:28:40 <byorgey> Twey: indeed, it's a very important m =)
09:28:44 <Twey> Yeah.  Heh.
09:28:51 <copumpkin> ap takes a function inside the monad and makes it operate on the monad
09:29:04 <copumpkin> it's Applicative's "special feature" :P
09:29:05 <Twey> Isn't that <*>?
09:29:06 <byorgey> ap is just function application in a monadic context.
09:29:08 <Twey> :t (<*>)
09:29:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:29:10 <byorgey> Twey: indeed.
09:29:11 <copumpkin> Twey: <*> is ap
09:29:14 <Twey> Yay.
09:29:16 <ben_m> Yeah that's not hard to grasp
09:29:22 <ben_m> Just in the context of ((->) r)
09:29:36 <ben_m> Is a bit tricky for me
09:29:49 <ddarius> ap = liftM2 ($)
09:29:57 <Cale> ap :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
09:29:57 <ben_m> liftM2 id actually
09:30:01 <ddarius> aka ap = liftM2 id
09:30:09 <ddarius> ben_m: ($) = id
09:30:13 <ben_m> That still wouldn't have helped me
09:30:36 <ddarius> ap for (e->) = S
09:31:00 <Cale> ap x y z = x z (y z)
09:31:01 <ben_m> That's SKI stuff again, right?
09:31:23 <byorgey> ben_m: right.  S = ap,  K = const,  I = id
09:31:34 <ddarius> S = ap; K = return
09:31:46 <Twey> But only for functions
09:32:01 <Twey> :t id
09:32:02 <lambdabot> forall a. a -> a
09:32:03 <Twey> :t return
09:32:04 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:32:11 <Twey> Hm
09:32:12 <Twey> Yes
09:32:18 <Twey> I think
09:32:21 <ben_m> I haven't looked at SKI yet, so I have no idea what this is about :)
09:32:24 <Twey> Oh, yes
09:32:25 <Twey> I mean
09:32:27 <mreh> can I use anonymous variables to see how a function is working exactly, like algebraic variables?
09:32:27 <Twey> :t const
09:32:27 <lambdabot> forall a b. a -> b -> a
09:32:31 <ben_m> I will come back to the logs though once I did.
09:32:42 <Cale> ben_m: Well, K x y = x, S x y z = x z (y z), I x = x
09:32:54 <kmc> > map f [x, y, z]
09:32:55 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:32:55 <lambdabot>    `GHC.Show.Show b'
09:32:55 <lambdabot>      a...
09:33:02 <Twey> const = return in Reader
09:33:04 <kmc> > map (f :: Expr -> Expr) [x, y, z]
09:33:05 <lambdabot>   [f x,f y,f z]
09:33:11 <kmc> mreh, like that?
09:33:14 <mreh> kmc, yah
09:33:16 <mreh> in ghc
09:33:21 <ddarius> ben_m: Look up "bracket abstraction"
09:33:22 <Cale> ben_m: In an untyped setting, those three terms (or really just S and K) are enough to compute anything you like.
09:34:08 <Cale> In a typed setting, they're not, but they are the axioms for intuitionist implicational logic.
09:34:09 <kmc> > foldr (+) 0 [x, y, z]
09:34:10 <lambdabot>   x + (y + (z + 0))
09:34:13 <mreh> map (f) ([x, y, z] :: [Expr])
09:34:17 <mreh> > map (f) ([x, y, z] :: [Expr])
09:34:18 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:34:18 <lambdabot>    `GHC.Show.Show b'
09:34:18 <lambdabot>      a...
09:34:36 <kmc> i forgot the name of the package that provides Expr, and hackage isn't loading
09:35:02 <ddarius> SimpleReflect
09:35:04 <mreh> kmc: GHC just says not in scope
09:35:05 <ddarius> :t x
09:35:06 <lambdabot> Expr
09:35:11 <ddarius> :t f
09:35:13 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:35:18 <mreh> kewl
09:37:59 <mreh> it's quite useful to see how your prog is working
09:38:14 <mreh> to say the least
09:38:27 <kmc> > map show [x,y,z]
09:38:28 <lambdabot>   ["x","y","z"]
09:50:52 <iaefai_> Is there any precanned way of providing for user configuration like cabal's config is formatted? I am pretty much just interested in setting: answer format
09:51:22 <dcoutts> iaefai_: I don't quite follow
09:51:39 <iaefai_> dcoutts: Is there something that exists that does this so I don't have to write a configuration parser myself
09:51:48 <dcoutts> does what exactly?
09:51:58 <FunctorSalad_> iaefai_: there are some "config" packages yes
09:52:23 <FunctorSalad_> cabal list config
09:52:36 <keko9> hi, anyone can help with this http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11432#a11432
09:52:37 <keko9> ?
09:53:01 <dcoutts> iaefai_: are you looking for a lib to help with config files, or are you interested specifically in the ~/.cabal/config format?
09:53:20 <iaefai_> dcoutts: primarily the former, ideally the latter
09:53:23 <koeien> keko9: using "lines" is better, yes
09:54:06 <iaefai_> I notice ConfigFile, EEConfig, hsConfigure, and tconfig
09:54:20 <dcoutts> iaefai: if you're actually trying to parse the cabal config file (which you probably should not) then just use the code from the cabal-install program
09:54:37 <dcoutts> iaefai_: if you just want a config file for your own program then use one of the libs from hackage
09:54:46 <keko9> ok thks koeien
09:54:54 <koeien> keko9: main = readFile "your_file_name"  >>= putStrLn . unlines . f . lines -- and now write f
09:55:14 <kmc> :t interact
09:55:15 <lambdabot> (String -> String) -> IO ()
09:55:17 <kmc> :t hInteract
09:55:18 <lambdabot> Not in scope: `hInteract'
09:55:39 <koeien> interact is even nicer/better, but requires you to invoke your program in a slightly different way
09:56:22 <Cale> I find that when there's a composition on the right side of >>= it's nicer to flip the thing over and use =<< by the way
09:56:40 <koeien> yes, that is nicer too
09:56:47 <Cale> main = putStrLn . unlines . f . lines =<< readFile "..."
09:58:03 <mreh> mmmm, backwards bind
09:58:51 <iaefai_> Do we have any eta on hackage coming back up? I am going back home now and need to know if I should take the  downloaded torrent with me :p
10:00:59 <mreh> is there a multiplicative inverse function?
10:01:02 <mreh> (1/)
10:01:05 <mreh> i suppose
10:01:07 <koeien> recip
10:01:12 <koeien> :t recip
10:01:13 <lambdabot> forall a. (Fractional a) => a -> a
10:01:15 <mreh> thx
10:01:18 <iaefai_> @src recip
10:01:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:01:43 <koeien> iaefai_: it is in a class, definition is different for each type
10:02:41 <iaefai_> koeien: How would you specify a specific one for @src?
10:03:03 <tommd> @hayoo temp
10:03:04 <lambdabot> Unknown command, try @list
10:03:32 <keko9> koeien or Cale do u have an example to use putStrLn . unlines . f . lines , Ive never see that
10:03:41 <keko9> ?
10:04:08 <koeien> f = reverse -- example
10:04:08 <iaefai_> c'ya all later
10:11:36 * sieni gets prepared to hack some haskell
10:12:39 <keko9> hmmm,but that apply f to all lines?
10:12:55 <ben_m> That's the point
10:12:55 <koeien> what would be the type of f ?
10:12:59 <copumpkin> unlines . map f . lines
10:13:38 <keko9> I need to apply f's to even lines and other f's to odd lines
10:14:11 <koeien> yes
10:14:21 <_Ray_> Which max function is the "preferred haskell" way, max1 or max2? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11435 .  (Yes, I know there's already a max)
10:14:25 <koeien> first try to figure out the type of f
10:14:54 <koeien> _Ray_: this is a fold
10:15:09 <_Ray_> koeien, yes, without using higher order functions.
10:15:13 <koeien> but if i had to choose, it would be max2
10:15:32 <Cale> (The preferred Haskell way is always to use higher order functions ;)
10:15:50 <_Ray_> Unfortunately it's forbidden in the course, at least for now =p
10:16:08 <_Ray_> Mainly because some exercises would be solved in 1 line if we were able to use them, as opposed to a page of text.
10:16:17 <koeien> ... which is the point, no?
10:16:37 <_Ray_> Not really - this is an introduction to algorithms course. The point is to get us to write our programs and prove their correctness.
10:17:05 <koeien> how did they define the maximum of a sequence, then?
10:17:29 <_Ray_> An element which is larger than or equal to every element in the list.
10:17:54 <_Ray_> (If by sequence you meant list - otherwise I'm unclear as to the meaning of sequence)
10:17:55 <mreh> you can only define it recursively
10:18:14 <mreh> which is the definition of the algorithm
10:18:57 <_Ray_> Sort of - in both cases (max1 and max2) you can easily prove they'll find the max.
10:19:05 <koeien> _Ray_: i think your max2 is more transparent, but only , of course, if higher-order functions are "forbidden"
10:19:13 <_Ray_> Indeed
10:19:41 <Cale> _Ray_: How about defining other functions to help?
10:19:49 <_Ray_> Cale, such as?
10:19:55 <Cale> _Ray_: Using a function which gives the maximum of two element
10:19:56 <Cale> s
10:20:01 <koeien> fold
10:20:09 <Cale> Yeah, even without the fold
10:20:10 <mreh> @hoogle a -> b -> (a,b)
10:20:15 <copumpkin> (,)
10:20:18 <Cale> maximum [x] = x
10:20:27 <mreh> > (,) 1 2
10:20:31 <Cale> maximum (x:xs) = max x (maximum xs)
10:20:38 <copumpkin> @botsmack
10:20:38 <lunabot>  :o
10:20:44 <mreh> > (,) 1 2
10:20:44 <copumpkin> failambdabot
10:20:48 <copumpkin> , (,) 1 2
10:20:50 <koeien> , (,) 1 2
10:20:51 <lunabot>  (1,2)
10:20:51 <lunabot>  (1,2)
10:20:57 <copumpkin> kopykat
10:20:59 <_Ray_> Hrm. Yeah, looks pretty.
10:21:02 <mreh> > (,,) 1 2 3
10:21:12 <mreh> :D
10:21:17 <_Ray_> Right, you'll go piling up the max's when the recursion comes back
10:21:38 <Cale> "comes back"?
10:21:45 <_Ray_> Returns
10:21:51 <copumpkin> > (,,,) 1 2 3 4
10:21:57 <_Ray_> When you're..."going back" x_x
10:22:01 <lambdabot>   (1,2,3,4)
10:22:04 <Saizan> if the max here is strict that's not the best way to write it
10:22:19 <ddarius> max is usually strict...
10:22:33 <koeien> _Ray_: haskell is lazy, if i have a "strange" definition of "max", i can even apply it to an infinite list
10:22:35 <Cale> maximum (1:2:3:4:[]) = max 1 (maximum (2:3:4:[])) = max 1 (max 2 (maximum (3:4:[]))) = ...
10:22:43 <Cale> _Ray_: that's how I think of it ^^
10:22:49 <_Ray_> koeien, but would it ever finish?
10:22:54 <koeien> yes
10:23:11 <copumpkin> write max as a catamorphism!
10:23:12 <_Ray_> Cale, yeah, that's how I think of it as well - the 'max's go piling up.
10:23:21 <Cale> _Ray_: okay :)
10:23:28 <_Ray_> And then, when you get to the base case of [x] = x, you reduce the expressions back, with no functions that recurse anymore
10:23:33 <koeien> data CompactR = Infinity | RealNumber Double -- example
10:23:39 <Cale> _Ray_: okay
10:26:41 <mreh> @hoogle [a] -> [a] -> [[a]]
10:26:42 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:26:42 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
10:26:42 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:27:10 <mreh> i wanna zip two lists but into lists, not tupes
10:27:29 <jaspervdj> mreh: use zipWith?
10:27:34 <koeien> :t zipWith
10:27:36 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:27:47 <Cale> > zipWith (\x y -> [x,y]) [1,2,3,4] [5,6,7,8]
10:27:49 <lambdabot>   [[1,5],[2,6],[3,7],[4,8]]
10:27:50 <copumpkin> :t (transpose .) . (++)
10:27:52 <lambdabot> forall a. [[a]] -> [[a]] -> [[a]]
10:27:56 <copumpkin> oh whoops
10:28:22 <copumpkin> :t \x y -> transpose [x, y]
10:28:23 <lambdabot> forall a. [a] -> [a] -> [[a]]
10:28:31 <Cale> > (\x y -> transpose [x,y]) [1,2,3,4] [5,6,7,8]
10:28:33 <lambdabot>   [[1,5],[2,6],[3,7],[4,8]]
10:28:35 <Cale> > (\x y -> transpose [x,y]) [1,2,3,4] [5,6,7]
10:28:37 <lambdabot>   [[1,5],[2,6],[3,7],[4]]
10:28:46 <copumpkin> zomg
10:29:16 <vy> Hi! I'm a Haskell newbie and amazed by how complete the Haskell concurrency and parallelization system is. Looking at networking side, Haskell is still using the thin C wrappers over old POSIX socket's API, e.g. no [e]poll/kqueue support. Will there be anything addressing this (networking stuff) issue/problem(?) in the next Haskell language report?
10:29:19 <_Ray_> When the bot says "forall", that's not valid syntax, is it?
10:29:26 <copumpkin> it is, but not h98
10:29:28 <Cale> vy: Not in the report
10:29:29 <ddarius> :t max
10:29:30 <lambdabot> forall a. (Ord a) => a -> a -> a
10:29:36 <ddarius> > max True False
10:29:38 <lambdabot>   True
10:29:44 <Cale> vy: The report wouldn't be the place for that sort of thing, it's an implementation detail :)
10:30:21 <Cale> vy: Lots of people want epoll/kqueue support in GHC. Supposedly it should take someone who knows the relevant APIs and GHC about a week.
10:30:51 <Cale> vy: When someone gets around to it, your concurrent programs will just get faster
10:30:56 <ben_m> Is there a function to return every n'th item in a list?
10:31:24 <ddarius> > let or' = maximum; examples = [[False, True], [False, False], [True, False, undefined]] in (map or' examples, map or examples)
10:31:25 <lambdabot>   ([True,False,* Exception: Prelude.undefined
10:31:29 <koeien> ben_m: not that i know of, but you can make one yourself. look at splitAt
10:31:31 <koeien> :t splitAt
10:31:32 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:31:40 <vy> Cale: I see. Thanks.
10:31:42 <kmc> > map head $ iterate (drop 4) [1..]
10:31:43 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,10...
10:31:44 <ben_m> Yeah, just thought there'd be one :)
10:31:46 <ddarius> > let or' = maximum; examples = [[False, True], [False, False], [True, False, undefined]] in (map or examples, map or' examples)
10:31:47 <lambdabot>   ([True,False,True],[True,False,* Exception: Prelude.undefined
10:31:48 <Cale> [x | (k,x) <- zip [0..] xs; k `mod` n == 0]
10:32:00 <ddarius> > max True undefined
10:32:01 <lambdabot>   * Exception: Prelude.undefined
10:32:13 <Cale> (that's probably not the best way :P)
10:32:48 <Cale> > map head . takeWhile (not . null) . iterate (drop 4) $ "abracadabra"
10:32:50 <lambdabot>   "acb"
10:34:45 <ddarius> > let nths n [] = []; nths n (x:xs) = x:nths n (drop (n-1) xs) in nths 3 "ansotehuosaeh"
10:34:47 <lambdabot>   "aohsh"
10:36:23 <ddarius> > map head . takeWhile (not . null) . iterate (drop 3) $ "ansotehuosaeh"
10:36:25 <lambdabot>   "aohsh"
10:38:16 <BONUS> thinkin bout an idiomatic way to make (Maybe a,b) -> Maybe (a,b)
10:38:21 <BONUS> any ideas?
10:39:18 <sjanssen> @djinn (Maybe a, b) -> Maybe (a, b)
10:39:18 <lambdabot> f (a, b) =
10:39:18 <lambdabot>     case a of
10:39:18 <lambdabot>     Nothing -> Nothing
10:39:18 <lambdabot>     Just c -> Just (c, b)
10:39:26 <sjanssen> @. pl djinn (Maybe a, b) -> Maybe (a, b)
10:39:27 <lambdabot> (line 3, column 13):
10:39:27 <fentiman> hey BONUS, I'm reading "learn you a haskell", really good, thanks. :)
10:39:27 <lambdabot> unexpected ">" or "-"
10:39:27 <lambdabot> expecting variable, "(", operator or end of input
10:39:39 <BONUS> hey thankyou :D more stuff coming soon!!!
10:40:32 <sjanssen> f (mx, y) = fmap (flip (,) y) mx
10:41:17 <BONUS> hmm that's one way yeah
10:41:42 <sjanssen> @djinn f (mx, y) = fmap (flip (,) y) mx
10:41:43 <lambdabot> Cannot parse command
10:41:50 <sjanssen> @pl f (mx, y) = fmap (flip (,) y) mx
10:41:51 <lambdabot> f = uncurry (flip (fmap . flip (,)))
10:42:26 <aavogt> @type Data.Traversable.sequenceA (1, Just 1)
10:42:27 <lambdabot> forall t t1. (Num t, Num t1, Data.Traversable.Traversable ((,) t)) => Maybe (t, t1)
10:42:38 <aavogt> > Data.Traversable.sequenceA (1, Just 1)
10:42:39 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t))
10:42:39 <lambdabot>    arising from a us...
10:42:53 <BONUS> (,) t ain't traversable :[
10:44:11 <aavogt> can't it be though?
10:44:19 <Cale> > map head . takeWhile (not . null) . iterate (drop 3) $ "Phuhbn'wxnltgyhlpsuzliew nbmudgellmuwea'p:nmyaerfgthop OaCarteghnuurhlpzhxquar AmRte'mulaxyopeerhai axwatgraalmhop'yhnixawkgarleh aafhuhrktmnaligopnwf"
10:44:21 <lambdabot>   "Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn"
10:44:38 <mreh> eeee... my k means clustering works, i thought I'd like to share that with all of you
10:44:47 <mreh> is there GNUplot binding for haskell?
10:44:57 <mreh> i can't tell with hackageDB porly
10:44:58 <shambler_> Cale, damn you! You made me disconnect!
10:45:18 <BONUS> you'd have to newtype it
10:45:31 <BONUS> i mean if you wanted it to be on the first component of the tuple
10:45:32 <aavogt> mreh: yeah, and a library that does decent plots with cairo too
10:45:33 <burp> mreh: yes
10:45:45 <mreh> cairo? hmm
10:46:09 <ddarius> BONUS: Incidentally, that function on Maybe is the strength of the Maybe monad.
10:46:09 <aavogt> one's called gnuplot, the other one chart
10:47:32 <ddarius> > let strength :: (m a, b) -> m (a, b); strength (m, b) = liftM (flip (,) b) m in (strength (Nothing, 3), strength (Just 1, 3))
10:47:34 <lambdabot>   Could not deduce (GHC.Base.Monad m) from the context ()
10:47:34 <lambdabot>    arising from a u...
10:47:43 <ddarius> > let strength :: Monad m => (m a, b) -> m (a, b); strength (m, b) = liftM (flip (,) b) m in (strength (Nothing, 3), strength (Just 1, 3))
10:47:44 <lambdabot>   (Nothing,Just (1,3))
10:47:48 <BONUS> hmm
10:50:10 <ddarius> :t liftM . (,)
10:50:11 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => a -> m a1 -> m (a, a1)
10:50:20 <ddarius> :t uncurry $ liftM . (,)
10:50:21 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a, m a1) -> m (a, a1)
10:50:21 <copumpkin> I like the uncurried version
10:56:43 <aavogt> mreh: also hackage description mirror here: http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
10:56:50 <aavogt> but it doesn't host any of the packages
10:57:00 <mreh> aavogt: good job
10:57:13 <mreh> whoever did this
10:57:14 <aavogt> not mine though
11:04:28 <burp> I think hackage is down every sunday
11:04:40 <FunctorSalad_> inductive reasoning...
11:04:48 <FunctorSalad_> :)
11:05:54 <orbitz> what do i need ot do to successfuly: let x = 10; y = 100 in printf "%f\n" (x / y)
11:06:23 <aavogt> > printf "%f\n" (10/100) :: String
11:06:24 <lambdabot>   "0.1\n"
11:06:48 <burp> > let x = 10; y = 100 in printf "%f\n" (x / y)
11:06:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:06:49 <lambdabot>    `Text.Printf.PrintfType ...
11:07:15 <burp> um, yes
11:07:37 <aavogt> you need to specify a type
11:07:51 <aavogt> > let x = 10; y = 100 in printf "%f\n" (x / y) :: IO ()
11:07:53 <lambdabot>   <IO ()>
11:07:54 <ben_m> > let x = 10; y = 100 in printf "%f\n" (x / y) :: IO ()
11:07:55 <lambdabot>   <IO ()>
11:07:56 <ben_m> Doh :(
11:07:56 <aavogt> > let x = 10; y = 100 in printf "%f\n" (x / y) :: String
11:07:58 <lambdabot>   "0.1\n"
11:08:13 <burp> that's why it works in ghci
11:08:38 <aavogt> @index printf
11:08:39 <lambdabot> Text.Printf
11:09:51 <aavogt> yeah ghci is in IO
11:09:57 <orbitz> hrm
11:09:58 <aavogt> and then the a gets defaulted to ()
11:10:18 <orbitz> so that owrks in let, but not when i do let x = 10\n let y = 100\n printf ... in ghci
11:10:29 <ben_m> improvements? http://sprunge.us/iBic?haskell
11:11:08 <Baughn> http://projects.haskell.org/haskellmode-emacs/ <-- Haskell-mode 2.6 has been released. Some useful changes.
11:11:44 <EnglishGent> cool :)
11:12:00 <ben_m> I'm probably not even using 10% of Haskell-mode
11:14:00 <ReDAeR> Uhm question why is this returning '[]' an empty list?: http://pastebin.com/dcaf9d07
11:14:19 <Cale> ben_m: I would have gone the other way with  nth n = map head . takeWhile (not . null) . iterate (drop n)
11:14:57 <ben_m> Blast, I forgot about iterate
11:15:00 <ReDAeR> I'm trying to solve project euler problems (#1) to help me learn Haskell, i know this isn't the best way to solve this problem in Haskell but i'm curious why this don't work.
11:15:00 <koeien> ReDAeR: do you know what a monad is?
11:15:06 <Cale> ReDAeR: That's in the list monad.
11:15:07 <ReDAeR> koeien: Nope
11:15:12 <koeien> in case you don't, then don't use "do":)
11:15:27 <ReDAeR> I thought everytime i use more then 1 line i need to use do
11:15:29 <koeien> this is doing something completely different
11:15:29 <ReDAeR> else i can't use if/else
11:15:52 <FunctorSalad_> Baughn: awesome. is the "bug-fix for inferior-haskell-type" the thing were it won't parse long types?
11:15:52 <Cale> ReDAeR: getList (x-1) is eventually getList 1 which you've defined as [], which means that there are no choices available for 'rest'
11:16:19 <Cale> ReDAeR: do is for gluing together actions in some monad.
11:16:31 <Cale> ReDAeR: You probably don't want it at all here.
11:16:31 <Baughn> FunctorSalad_: I believe so. I didn't find anything the old one actually errors out on, but that's what it looks like.
11:16:53 <FunctorSalad_> Baughn: anything long I think
11:16:54 <Cale> ReDAeR: You *might* want let
11:16:55 <FunctorSalad_> (not srue)
11:17:05 <Cale> ReDAeR: or where
11:17:11 <ReDAeR> Cale: but it checks if x is mod 3/5 is so it adds itself to to list, right?
11:17:34 <ReDAeR> That was the basic idea, start with an empty list if number can be 'modded' by 3 and 5 add it to the list
11:17:37 <koeien> ReDAeR: no
11:17:43 <koeien> "add it to the list" is not possible in haskell
11:17:53 <Baughn> "Make a new list with the new elements", is.
11:17:54 <ReDAeR> (x:rest) is for that?
11:18:01 <Baughn> ReDAeR: That makes a new list
11:18:03 <koeien> yes
11:18:11 <Cale> ReDAeR: The code doesn't mean at all what you want it to mean as it stands
11:18:18 <FunctorSalad_> errm but () now sugars as ?
11:18:22 <koeien> (x:rest) is a list, e.g.
11:18:25 <FunctorSalad_> () isn't empty
11:18:25 <Cale> ReDAeR: Currently, it's a computation in the list monad...
11:18:33 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
11:18:33 <koeien> > (1:[2,3,4])
11:18:34 <lambdabot>   [1,2,3,4]
11:18:34 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:19:22 <ReDAeR> so let rest = getList (x-1) would be better?
11:19:23 <Cale> ReDAeR: Why not use filter?
11:19:26 <Twey> > liftM2 (,) [1, 2, 3] [4, 5]
11:19:27 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:19:34 <Cale> ReDAeR: yeah, and let instead of do
11:19:44 <ReDAeR> Cale: Yes i know i did it the 'dumb' way but i'm trying to figure out why it didn't work
11:19:54 <Twey> > sequence [[1, 2, 3], [4, 5]]
11:19:55 <lambdabot>   [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
11:20:00 <Cale> ReDAeR: let rest = getLine (x-1) in if (x `mod` 3) == 0 || (x `mod` 5) == 0 then x : rest else rest
11:20:07 <ReDAeR> Since in YAHT it is using the same technique to make a list of words you entered
11:20:23 <koeien> that has probably to do with I/O
11:20:25 <Cale> ReDAeR: That do is for combining the IO actions
11:20:31 <koeien> you are not doing I/O actions here
11:20:33 <ReDAeR> Ok
11:21:09 <koeien> the problem is that haskell is sufficiently general to also allow "do" in the usage you tried, but this is not what you want
11:30:27 <ReDAeR> Thank you Cale it's running good now even got an error about infinite type, a forum said i shouldn't use return statements in main, is this just in main or always?
11:30:47 <Baughn> ReDAeR: Completely untrue, rather
11:31:14 <koeien> ReDAeR: in the beginning, i would stick with pure functions (so no I/O) and the GHC interactive environment.
11:31:29 <Baughn> ReDAeR: return has the same meaning in main as anywhere else, and you might well want to use it. Although, the most common use of return is to return a value from a function, which you won't need in main - main returns (), a null value
11:31:31 <koeien> in that case you will not need return (unless you do some monadic things)
11:32:01 <ReDAeR> Ok, thank you
11:32:02 <Baughn> ReDAeR: However, do keep in mind that return is *not* a flow-control statement. It means "make a function that, when executed, returns this", not "return this from the currently running do-block" or whatever
11:32:54 <koeien> > do { return 37; print 42 } -- this WILL, when performed, print 42, to illustrate Baughn's point
11:32:55 <lambdabot>   <IO ()>
11:32:58 <Cale> "make an action that..."
11:33:09 <HaudRex> @type \x -> x x
11:33:10 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:33:11 <lambdabot>     Probable cause: `x' is applied to too many arguments
11:33:11 <lambdabot>     In the expression: x x
11:33:11 <Cale> Functions have parameters, IO actions don't :)
11:33:17 <aavogt> > do { return 1 ; Just 2 }
11:33:18 <lambdabot>   Just 2
11:33:19 <Baughn> Sorry, sorry. :P
11:33:41 <ReDAeR> Ok that's.. againt my logical programming instinct.. but ok
11:34:05 <ReDAeR> That's why you always must have an else in Haskell?
11:34:08 <mauke> 'return' is not a keyword or built in
11:34:15 <mauke> it's just another library function
11:34:19 <ddarius> main :: IO a
11:34:23 <koeien> ReDAeR: if p then x else y -- this is an expression, it has a value!
11:34:30 <Cale> ReDAeR: Well, you must always have an 'else' because 'if/then/else' is an expression form
11:34:36 <Cale> ReDAeR: and so it has to have a value
11:34:46 <koeien> > if 1 > 0 then 37 else 42 -- This makes no sense if you leave off the "else "
11:34:47 <lambdabot>   37
11:34:57 <koeien> :t if 1 > 0 then 37 else 42
11:34:58 <lambdabot> forall t. (Num t) => t
11:35:10 <koeien> this means "it is a numeric type", because both 37 and 42 are numbers
11:35:12 <Baughn> ReDAeR: In expression context, it makes no sense to not have a value. In a monadic context, the special value "do nothing" may be useful, but you're not always in monads.
11:35:13 <ReDAeR> koeien: I know but i'm used to write things like: if(someObjects == null) return;   other code...
11:35:29 <Cale> ReDAeR: Yeah, you can't write things like that.
11:35:30 <copumpkin> ReDAeR: we do that with guards/monadplus
11:35:30 <ReDAeR> So without the else clause
11:35:36 <Baughn> ReDAeR: We don"t even have null. :P
11:35:38 <koeien> ReDAeR: yes, that is not possible, you would need to use guards for that
11:35:45 <koeien> no, no nulls, and that is a feature
11:35:49 <ReDAeR> Baughn: You guys have 'Maybe'
11:35:53 <koeien> correct
11:35:58 <Cale> ReDAeR: You take apart Maybe with case
11:36:02 <Cale> case someObjects of
11:36:06 <Cale>   Nothing -> ...
11:36:06 <Baughn> ReDAeR: We don't lift every single type into Maybe, though. ;)
11:36:10 <Cale>   Just x -> ...
11:36:36 <koeien> yes, and the compiler can warn you if you forget a part
11:36:37 <ddarius> Baughn: Even if we did, it still wouldn't be equivalent to nullable types.
11:36:59 <koeien> ddarius: you mean, nested Maybe's ?
11:37:03 <Baughn> It would if the compiler inserted fromJust everywhere
11:37:12 <ddarius> koeien: That is one issue, yes.
11:37:20 * Baughn shudders at the thought
11:37:39 <HaudRex> Nothing = K
11:38:03 <HaudRex> Just = \x y z -> z x
11:38:59 <mercury^> ReDAeR: return in the continuation monad behaves like you'd expect.
11:39:08 <ReDAeR> Ok
11:39:14 <Cale> ... no it doesn't.
11:39:19 <Baughn> Ha. But I doubt the continuation monad as a whole behaves like he'd expect. ^^;
11:39:20 <ReDAeR> Oh it doesn't :P
11:39:35 <koeien> Baughn: very true :)
11:39:46 <Cale> Wrapping the procedure in callCC and calling the continuation that you're passed behaves like you'd expect return to in an imperative language
11:40:08 <mercury^> Cale: calCC $ \return ->
11:40:10 <copumpkin> we should make a ContT IO more common, to make imperative programming even more like what newbies expect
11:40:13 <ddarius> mercury^: return always behaves the same in every monad.
11:40:14 <Cale> mercury^: heh
11:40:16 <mercury^> callCC*
11:40:17 <ddarius> mercury^: That's evil.
11:40:31 <Cale> Yeah, don't shadow the definition of return like that :P
11:40:34 <Baughn> copumpkin: ..is that a demonic duck of some sort?
11:41:00 <Cale> Heh, we should just make IO an instance of MonadCont
11:41:07 <copumpkin> well, we say that IO monad programming is just like an imperative language... but return doesn't behave the way people expect, and there's no easy way to give them that without Cont
11:41:18 <Baughn> There is one easy way
11:41:22 <Baughn> Rename return to pure.
11:41:40 <Cale> I think it's stupid to expect everything to mean the same thing as it does in an imperative language
11:42:00 <koeien> i think the name "return" is not well-chosen
11:42:03 <koeien> maybe "inject" ?
11:42:06 <Baughn> pure.
11:42:07 <copumpkin> yeah, I think it's bad too
11:42:08 <copumpkin> point
11:42:09 <Cale> I think it is well chosen.
11:42:13 <Baughn> class Applicative a => Monad a...
11:42:20 <Cale> return x is the action which... returns x.
11:42:21 <Baughn> We've already /got/ a different name for return, guys
11:42:22 <copumpkin> class Pointed a => Applicative a
11:42:30 <Baughn> copumpkin: Point
11:42:39 <mercury^> Cale: return, I think,  was chosen specifically to reflect its usage in imperative programming. It just does a poor job at it.
11:42:47 <copumpkin> Baughn: ?
11:42:57 <koeien> Cale: not in every monad we have an "action" metaphor?
11:43:01 <Baughn> copumpkin: Pun intended.
11:43:07 <Cale> koeien: hm?
11:43:08 <copumpkin> aha :)
11:43:20 <Cale> koeien: We do though.
11:43:26 <koeien> e.g. Maybe, does this really represent an "action" in your view?
11:43:28 <gio123> Cale: hi
11:43:31 <copumpkin> koeien: yep
11:43:32 <Cale> koeien: It may.
11:43:33 <ddarius> koeien: Yes.
11:44:09 <copumpkin> oh my
11:44:09 <copumpkin> freenode really sucks
11:44:16 <zygoloid> crikey!
11:44:30 <copumpkin> freenode really needs to get its shit together :/
11:44:32 <Baughn> ..it's the apocalypse! Everybody, run!
11:44:33 <zygoloid> :O
11:44:33 <koeien> wtf
11:44:43 <rasfar> i feel like i'm witnessing a rare cosmological event...
11:44:55 <koeien> the rapture!
11:44:57 * Baughn examines the wild Netsplit in its native terrain
11:45:04 <ReDAeR> Lol?
11:45:04 <Baughn> Crikey! Now that was a big one!
11:45:04 <shapr> yay, netsplit!
11:45:10 <shapr> I think it's happening AGAIN!
11:45:11 <Zao> "look at all those suckers, on the other side of the split! it never happens to me!"
11:45:12 <Baughn> This is no mere netsplit!
11:45:13 <shapr> whee!
11:45:15 <ddarius> That wasn't a netsplit.
11:45:17 <ReDAeR> Zao: Indeed :P
11:45:19 <Baughn> This is a netquake!
11:45:20 <shapr> It's an IRCQUAKE!
11:45:25 <BONUS> i just got disconnected
11:45:30 <koeien> BONUS: orly?
11:45:33 <shambler> omg
11:45:34 * shapr grabs onto Baughn for security
11:45:35 <BONUS> ya ... rly
11:45:40 <koeien> no wai! :P
11:45:42 <ben_m> Pretty colours.
11:45:43 <MyCatVerbs> shapr: I'm going to have to throw a spoon at you for excessive melodrama.
11:45:44 * Baughn pushes shapr under a truck!
11:45:44 <shambler> @yarrr
11:45:45 <lambdabot> Yarrr!
11:45:49 <Cale> Freenode is "awesome"
11:45:54 <zygoloid> this isn't just a netsplit, this is a Marks and Spencer delicious netsplit, with nick collisions and multiple rejoins...
11:45:57 <viator_sg> yep
11:46:01 <koeien> so, was that it?
11:46:01 <copumpkin> yeah, it's awesome
11:46:03 <gio123> Cale: hi
11:46:04 <ReDAeR> Isn't this cool?
11:46:04 <shapr> whew, is it over?
11:46:06 <Baughn> koeien: No.
11:46:07 <copumpkin> IRC is such a shitty protocol
11:46:07 <drhodes> is this an attack?
11:46:12 <copumpkin> drhodes: nope
11:46:14 <shapr> MyCatVerbs, I'm always melodramatic!
11:46:14 <drhodes> ok
11:46:16 <copumpkin> drhodes: just epic fail
11:46:20 <Baughn> drhodes: Netquakes sometimes happen
11:46:22 <HaudRex> It's the Russians!
11:46:26 <dons> scary
11:46:32 --- mode: irc.freenode.net set +o ChanServ
11:46:36 <HaudRex> Whew
11:46:39 <zygoloid> ChanServ: welcome bac.. oh
11:46:40 --- mode: irc.freenode.net set +o ChanServ
11:46:40 <Baughn> Yeah, that felt exactly like I think an earthquake would
11:46:41 <Cale> It's also doesn't appear to be a netsplit
11:46:54 <drhodes> some deep seated part of me, the part that hope for nuclear war, always gets excited when disaster looms.
11:46:56 <gio123> Cale: hi
11:46:57 <Cale> The disconnect messages were (Nick collision from syn.)
11:47:04 <dons> something nasty
11:47:10 <dons> "11:46 [freenode] -Md(i=md@freenode/staff/md)- [GlobalNotice] sorry for the recent mass-kill issue! we  are investigating what happened exactly
11:47:14 <dons> "
11:47:14 <ddarius> drhodes: Why hope?  Be more active.
11:47:21 <HaudRex> Anyway, return should be called ?. Everybody knows that.
11:47:26 <dons> no high assurance irc server
11:47:26 <gio123> Cale: hi
11:47:35 <HaudRex> That was supposed to be "eta".
11:47:36 <ddarius> dons: It could have been user error...
11:47:52 <paolino> hi, what kind of error could produce a <<loop>> run time error ?
11:47:52 <ddarius> 
11:47:57 <dcoutts> dons: more to do with mis-configured services
11:48:07 <Baughn> > let x = x in x
11:48:08 <ddarius> paolino: Having a vicious value recursion, e.g. let x = x in x
11:48:11 <lambdabot>   mueval-core: Time limit exceeded
11:48:22 <Cale> paolino: making use of the value which you are trying to compute
11:48:24 * shapr hugs MyCatVerbs 
11:48:31 <shapr> Yay, I'm safe from the netquake!
11:48:33 <Cale> paolino: (without a constructor in between)
11:48:57 <Baughn> shapr: Yeah, but I pushed you under a truck
11:48:59 <gio123> Cale: hi
11:49:10 <shapr> Baughn, luckily the truck was netsplit at the right time, and I SURVIVED!
11:49:20 <MyCatVerbs> shapr: I care about you too man, but what's with the hug?
11:49:26 <viator_sg> 600! :D
11:49:27 <shapr> MyCatVerbs, you're cute!
11:49:28 <Cale> gio123: Hello. (I heard you the first 18 times ;)
11:49:33 <ddarius> MyCatVerbs: You've never been hugged by shapr before?
11:49:36 <dons> back to 601. not bad.
11:49:36 <MyCatVerbs> shapr: ...thank you.
11:49:39 <Baughn> shapr: If it wasn't for those meddling kids and their netsplit, I would've gotten away with it too!
11:49:39 * shapr hugs ddarius 
11:49:41 <shapr> ddarius, yay!
11:49:46 <MyCatVerbs> ddarius: I don't recall having run into shapr in person.
11:49:46 <shapr> Baughn, haha
11:49:49 <gio123> Cale: can u see pm
11:49:53 <int-e> @users
11:49:53 <lambdabot> Unknown command, try @list
11:49:58 <ddarius> MyCatVerbs: Then you haven't, or else you'd recall.
11:50:02 <MyCatVerbs> Admittedly I've seen photos and he does look huggable.
11:50:05 <shapr> yay!
11:50:07 * copumpkin hasn't been hugged by shapr either
11:50:16 <eflister> hi, i have a record with an existential field and am having trouble understanding why that introduces so many restrictions (ie, accessor methods no longer work, record update syntax doesn't work, etc).
11:50:19 <eflister> i don't get why the accessors to the non-existential fields are affected, and i don't get why the accessor for the existential field can't just be of an existential type (ie, forall x. (SomeClass x) => Record -> x).  am i right that in 6.13 update syntax is back unrestricted?  any idea on when to expect 6.13 to be the stable release?
11:50:20 <shapr> copumpkin, and I even met you... what was WRONG with me?
11:50:22 <Cale> gio123: When you ask a question or say something other than "hi", I will see it then. :)
11:50:27 <copumpkin> shapr: I know! :(
11:50:34 <gio123> :)
11:50:39 <MakoryuOnIce> So what's this I hear about the whole network being under attack?
11:50:39 <shapr> d00d, I must totally remedy that next time I see you.
11:50:40 <paolino> ah , something like :%s/something/somethingelse/g resulting in a somethingelse=somethingelse definition :D ?
11:50:53 <int-e> heh. has anybody attempted to sell sugar-lambda proof armour to us #haskell folks?
11:51:01 <koeien> paolino: that may be it, yes
11:51:19 * shapr throws sugar lambdas in random directions
11:51:23 * byorgey also has met but not been hugged by shapr =(  (as far as I remember)
11:51:52 <shapr> byorgey, I got better!
11:51:57 <FunctorSalad_> @get-shapr
11:51:57 <lambdabot> shapr!!
11:52:04 <shapr> I'm HERE!
11:52:06 <FunctorSalad_> :D
11:52:44 --- mode: irc.freenode.net set +o ChanServ
11:53:24 <byorgey> what the heck?
11:53:31 * rasfar tastes first sugar lambda abstractedly
11:54:27 <eflister> anyone able to help me understand my existential record question above?
11:54:50 <koeien> "above"
11:55:03 <Guest31337> eflister: can you hpaste some code?
11:55:20 <edwardk> an existential record sounds like a something you'd play on LP.
11:55:23 <eflister> sure (first repeating question for recent net-disaster rejoins)
11:55:25 <eflister> hi, i have a record with an existential field and am having trouble understanding why that introduces so many restrictions (ie, accessor methods no longer work, record update syntax doesn't work, etc).
11:55:30 <Cale> eflister: Haskell doesn't have first-class existentials.
11:55:36 <eflister> i don't get why the accessors to the non-existential fields are affected, and i don't get why the accessor for the existential field can't just be of an existential type (ie, forall x. (SomeClass x) => Record -> x).  am i right that in 6.13 update syntax is back unrestricted?  any idea on when to expect 6.13 to be the stable release?
11:55:46 <int-e> eflister: by existential record, you mean data Foo = forall x . Foo { a :: x, b :: Int } ?
11:55:52 <Cale> eflister: So, there are no types which look like (exists x. ...) -- that's not even in the syntax.
11:55:52 <edwardk> once you make a data type with existentials you need to use pattern matching on it
11:56:02 <edwardk> the types involved in the accessors just become useless
11:56:11 <edwardk> at least with regards to the type system we have
11:56:23 <copumpkin> zomg it's edwardk
11:56:23 <eflister> here's code: http://code.google.com/p/h1ccup/source/browse/trunk/theory/haskell/src/PMTest.hs  -- the relevant record is defined at line 215
11:56:25 <FunctorSalad_> eflister: you can't directly grab the value of existential type out of the record
11:56:34 <FunctorSalad_> eflister: you have to eliminate it with a universal handler
11:56:55 --- mode: ChanServ set +o mauke
11:56:55 <edwardk> copumpkin: not for long. vanishing in 3...2...1...
11:57:00 <copumpkin> damn!
11:57:10 <FunctorSalad_> take data Ex = forall a. { foo :: [a] }
11:57:18 <eflister> i was actually hoping some people would be willing to do a code review -- i've got this file as clean as i can from what i've been able to learn so far.  it works fine, i just would like to get style advice from the experts.  :)
11:57:29 <copumpkin> FunctorSalad_: missing a data constructor :P
11:57:40 <FunctorSalad_> then you want an eliminator: elimEx :: (forall a. [a] -> r) -> r
11:57:45 <eflister> int-e: yes
11:57:49 <copumpkin> FunctorSalad_: it's basically equivalent to data Nat = Z | S Nat though isn't it?
11:57:50 <FunctorSalad_> elimEx (Ex x) k = k x
11:57:54 <FunctorSalad_> err, the type should be:
11:57:57 <zygospasm> foo :: exists a. Ex -> [a]
11:58:01 <FunctorSalad_> elimEx :: Ex -> (forall a. [a] -> r) -> r
11:58:31 <FunctorSalad_> copumpkin: hmm?
11:58:41 <eflister> edwardk and FunctorSalad_: i'm trying to understand why those rules are true
11:58:53 <copumpkin> FunctorSalad_: you can never say anything about the value inside the list, so all you know is the length of the list
11:59:01 <luite> make
11:59:05 <luite> err wrong window
11:59:12 <FunctorSalad_> eflister: the existential can contain *any* type, so to use it you must be able to handle *every* type
11:59:36 <FunctorSalad_> copumpkin: oh, true
11:59:53 <eflister> FunctorSalad_: if there are class constraints, then that's no longer a problem
12:00:20 <FunctorSalad_> eflister: the classes aren't essential, maybe try to figure out the case without classes first
12:01:19 <alinp> hi guys
12:01:23 <alinp> a little help please
12:01:27 <gmaslov> i'm trying to define an instance of Functor for homogeneous tuples, but seem to be stuck because you can't partially apply type synonyms (why?). any ideas? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11438#a11438
12:01:41 <eflister> FunctorSalad_: in this case, the class plays a useful role -- i believe what i'm doing could be accomplished without a class, at the cost of having to add extra Value Constructors in my DSL that i don't want.
12:02:00 <Cale> eflister: You can never definitively say that some type is *not* a member of some class.
12:02:11 <Cale> eflister: At least, GHC will never assume that.
12:02:22 <FunctorSalad_> eflister: not saying you shouldn't use classes, just that to learn about existential it might be simplest to start with the simplest case
12:02:24 <Cale> eflister: (because there might be some future module which defines an instance)
12:02:32 <alinp> why the following code is not working ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4554#a4554
12:02:36 <FunctorSalad_> Cale: there is a trick to close classes :)
12:02:41 <alinp> getDouble JNumber 5
12:02:50 <int-e> eflister: I'm sure there is no fundamental reason why record updates not involving fields mentioning x don't work. But the way ghc implements existentials, only pattern matching can unpack the associated class dictionaries. This makes things simpler because there is a well-defined scope where those type class instances are visible.
12:03:04 <FunctorSalad_> Cale: make a GADT which has one constructor for every type in the class
12:03:06 <mauke> alinp: because getDouble only takes one argument, not two
12:03:12 <FunctorSalad_> (all it Fam)
12:03:17 <eflister> Cale: when did i say anything about a type not being in a class?
12:03:23 <FunctorSalad_> then require a class method: "proof :: Fam a"
12:03:32 <alinp> so, getDouble (JNumber 4)
12:03:35 <alinp> shouldn't work ?
12:03:43 <FunctorSalad_> s/all/call
12:04:00 <alinp> hmmm
12:04:25 <alinp> in fact is working ... what did I missed ... :)
12:04:27 <alinp> thanks
12:04:46 <FunctorSalad_> ._.
12:05:05 <fentiman> o_0
12:05:22 <eflister> FunctorSalad_: well, i'm trying to accomplish a specific task while learning haskell :)  i think i get existentials in the non-class case, and can see how an accessor in that case would have zero information -- but when there is a class constraint, i believe it would be totally well-defined and useful to have accessors
12:05:51 <Cale> eflister: The exchange between you and FunctorSalad_ led me to believe that you might have thought the class constraints would seriously restrict the types you have to make the code work for. All that you get is that it belongs to the class -- you can't make use of the fact that it's one of the existing instances.
12:05:54 <FunctorSalad_> eflister: if there is a class constraint, your eliminator may use the knowledge "Foo a"
12:06:03 <FunctorSalad_> (where Foo is the class now ;))
12:06:23 <byorgey> gmaslov: you'll have to make TwoTuple a newtype instead of a type synonym
12:06:38 <FunctorSalad_> as Cale said
12:06:41 <byorgey> gmaslov: I forget why you can't partially apply type synonyms, but you can't.
12:07:06 <eflister> Cale: right, i just want to be able to call class methods on the result of the accessor
12:07:14 <FunctorSalad_> eflister: you can
12:07:31 <eflister> FunctorSalad_: except there's no accessor anymore afaict
12:07:42 <FunctorSalad_> eflister: you need to write your own CPS-accessor
12:07:55 <FunctorSalad_> data S = forall a. Show a => S a
12:08:01 <eflister> FunctorSalad_: that's what i'm trying to understand, why can't the normal accessor work?
12:08:08 <FunctorSalad_> elimS :: S -> (forall a. Show a => r) -> r
12:08:15 <FunctorSalad_> * elimS :: S -> (forall a. Show a => a -> r) -> r
12:08:30 <FunctorSalad_> eflister: because there's no direct "exists" in types
12:08:47 <gmaslov> byorgey: well, that works, but doesn't let me say "fmap (+1) (1,2,3)" instead of "fmap (+1) (ThreeTuple (1,2,3))"
12:08:52 <eflister> FunctorSalad_: can you spell that out, i don't get what you mean
12:09:15 <FunctorSalad_> eflister: the type of the accessor would be: S -> (exists a. Show a => a)
12:09:31 <FunctorSalad_> but that's not possible so you CPS it
12:09:48 <FunctorSalad_> and use the fact that "exists" turns into "forall" on the left-hand-side of an arrow
12:10:10 <gio123>  (\x -> x x) z =??
12:10:22 <FunctorSalad_> (exists a. P[a]) ~ ((forall a. P[a] -> r) -> r)
12:10:42 <byorgey> gmaslov: indeed.
12:11:05 <byorgey> gmaslov: note that there is already a functor instance for ((,) a) which would conflict with it anyway.
12:11:13 <MakoryuOnIce> :t (\x -> x x)
12:11:14 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
12:11:15 <lambdabot>     Probable cause: `x' is applied to too many arguments
12:11:15 <lambdabot>     In the expression: x x
12:12:05 <byorgey> gio123: self-application is not well typed.  but in the untyped lambda calculus that reduces to  z z .
12:14:14 <FunctorSalad_> eflister: in other words, there is no type that expresses "value of unknown type, except that it must be Show"
12:14:33 <copumpkin> "all I know is that this type carries a method dictionary for Show"
12:14:48 <FunctorSalad_> eflister: but we can express the equivalent type "something that can be used, if you can use every type which is Show"
12:17:29 <ddarius> Or one could switch to hbc.
12:17:36 <eflister> FunctorSalad_: that is exactly the distinction i don't get -- those sound exactly equivalent to me
12:17:57 <ddarius> equivalent /= equal
12:18:01 <FunctorSalad_> eflister: they are, but the second one is expressed purely in terms of "forall"
12:18:09 <FunctorSalad_> and we have "forall"
12:19:01 * eflister trying to find CPS on google, only finds it in yaht
12:19:26 <eflister> FunctorSalad_: but couldn't an accessor with that forall type just be made for me automatically?
12:19:32 <PeakerWork> Hackage is down again? :-( Where can I download the platform for OSX?
12:19:34 <FunctorSalad_> "continuation passing style", but you don't need to worry about continuations here really
12:19:52 <FunctorSalad_> I just call it like that because it looks similar to @unmtl Cont
12:20:07 <eflister> FunctorSalad_: yikes yeah i have been avoiding continuations!
12:20:07 <FunctorSalad_> eflister: yes
12:20:40 <copumpkin> they're useful if you're working with forall'd types
12:21:50 <eflister> int-e: just saw your response -- am i right that in 6.13 the update will work again?  (that's my read of http://www.haskell.org/ghc/dist/current/docs/html/users_guide/data-type-extensions.html#existential-records) -- and if so, when to expect 6.13 to be the stable release?
12:22:15 <Zao> When 6.14 is released?
12:22:15 <eflister> copumpkin: ok, maybe today's when i try to understand them then.  :)  care to walk me through a simple example?
12:22:46 <copumpkin> instead of returning something at the end of a function, you get passed a function to call
12:22:56 <copumpkin> with the value you'd otherwise return
12:23:01 <eflister> Zao: just wondering if people have an idea of that timeline (i'm trying to decide whether to manually install the dev branch, which sounds a bit painful esp lining it up with my cabal installed libraries, etc)
12:24:08 <eflister> copumpkin: that sounds easy enough, but how does that match up with "saving my current state of execution and magically finding myself back in that state next time i'm called"?
12:24:51 <Cale> eflister: first-class continuations /= continuation passing style
12:25:00 <eflister> Cale: oh :(
12:25:00 <int-e> eflister: Oh that's new. It works in 6.12 (snapshot), so it will work in 6.12.1 when it's released.
12:25:23 <eflister> int-e: i thought i checked the 6.12 docs and it was only in the 6.13 ones?
12:26:00 <int-e> eflister: "it" being the updates of the fields that don't mention the existentially bound variables.
12:26:48 <int-e> eflister: that is, with  data Foo = forall x . Foo { bar :: Int, baz :: x }  the following works in 6.12:  x :: Foo -> Foo; x a = a { bar = 42 }
12:27:05 <copumpkin> it didn't work before?
12:27:18 <eflister> int-e: oh ok.  in the 6.13 docs it says "Record update syntax is supported for existentials -- The rule for record update is this: the types of the updated fields may mention only the universally-quantified type variables of the data constructor."  but i couldn't figure out if that meant everything BUT the existential fields.
12:27:32 <copumpkin> oh I see
12:27:36 <int-e> copumpkin: nope. "Record update for the non-Haskell-98 data type `Foo' is not (yet) supported. Use pattern-matching instead"
12:27:42 <copumpkin> yeah
12:28:30 <int-e> eflister: yes, that's what it means. the universally quantified variables are the type parameters of the data type.
12:28:41 <eflister> int-e: now as i read that, it sounds like what you're describing is true of 6.12.  but i don't see that in the 6.12 docs, only 6.13
12:29:12 <eflister> int-e: why shouldn't i be able to update an existential field?
12:29:24 <copumpkin> someone may have just forgotten to update the docs for 6.12
12:29:40 <int-e> eflister: eflister where did you find 6.12 docs?
12:29:47 <eflister> copumpkin: oh ok, that would be great.  6.12 is almost about to be released?
12:29:48 <int-e> 6.12 is not released yet after all
12:30:08 <copumpkin> eflister: a few months off for a real release
12:30:25 <PeakerWork> who is in charge of hackage? Can't it be mirrored anywhere?
12:31:20 <dankna> true, it would be nice having mirrors - it's a very valuable site
12:31:59 <PeakerWork> I just wanted to download the Haskell platform and that seems to be the only source
12:32:05 <eflister> int-e: i think inside one of these http://www.haskell.org/ghc/dist/stable/dist/
12:32:21 <PeakerWork> if its a matter of money, I'm sure a little donation site + reddit link will fund the first few years of hosting costs
12:32:30 <int-e> eflister: that's still 6.10.4, I think
12:32:43 <eflister> int-e: not if you look in there
12:32:48 <copumpkin> PeakerWork: I've even offered a free mirror on a university network, but they didn't sound very enthusiastic
12:33:14 <PeakerWork> copumpkin: maybe you can wget -m them without asking? :-)
12:33:29 <dankna> that wouldn't really be ethical
12:34:05 <int-e> eflister: http://www.haskell.org/ghc/dist/stable/docs/users_guide/index.html says 6.10.3.20090517. *shrugs*
12:34:32 <eflister> int-e: but there's snapshots in there of 6.12
12:35:26 <int-e> eflister: oh I think I see what you're saying.
12:35:42 <dankna> but yeah, it's one of our community centers, we should take care of it.  somebody should talk to the maintainers and find out what exactly their position on it is - why they don't want mirrors and how they can be talked into it, haha
12:35:54 <dankna> if it's a matter of somebody to do the coding, I could donate my time
12:36:31 <McManiaC> hackage down?
12:36:34 <dankna> yes
12:36:37 <McManiaC> k
12:36:42 <eflister> int-e, copumpkin, FunctorSalad_: ok to summarize: 6.12 will let me update non-existential fields, but i don't see why i shouldn't be able to update existential fields.  in any case, i need to make my own accessors to take advantage of class constraints even though they could automatically be made for me.  CPS would be effective here but i need some guidance there.
12:39:34 <int-e> eflister: I guess if you mentioned that problem on ghc-users, SPJ would reply with an explanation why it would be a complication to the ghc proper and suggest you report it as a feature request on the ghc bugtracker, so it can be implemented anyway if more people request the feature. ;)
12:39:38 <PeakerWork> dankna: why not?
12:39:50 <PeakerWork> dankna: not ethical to wget -m a public website?
12:40:08 <dankna> ethical to wget -m it, but not ethical to actually host a mirror of it
12:42:24 <eflister> int-e: the auto generation of an accessor?  and/or updating existential fields?  it sounds like these restrictions are not due to principles, just haven't been implemented?  which makes me wonder if i should be doing something differently if no one else ever runs into this...
12:42:53 <int-e> eflister: fwiw, the documentation shipped with the latest x86 build of the snapshot also matches the ghc 6.13 one.
12:43:28 <int-e> eflister: your example is atypical in that there is only one field mentioning the existential x type at all.
12:43:49 <eflister> int-e: latest 6.12 snapshot?
12:44:57 <int-e> eflister: typically you'll either rewrite all those fields simultaneously - which makes the update record less of the code-saver - or you'll want to reuse the existing dictionaries for x, in which case you'll have to pattern match on the original value anyway.
12:45:04 <sinelaw> Is auto converting Lisp to Haskell a hard problem
12:45:06 <sinelaw> ?
12:45:13 <copumpkin> yes
12:45:16 <sinelaw> or straightforward
12:45:18 <sinelaw> copumpkin, why?
12:45:48 <copumpkin> one allows you to write \x -> x x, the other doesn't
12:46:00 <copumpkin> (types, unrestricted side-effecfts, etc.)
12:46:26 <eflister> int-e (+ anyone else): would you have time to look at the reason i'm using it and opine if there is a more idiomatic way?  :)  at line 225 here: http://code.google.com/p/h1ccup/source/browse/trunk/theory/haskell/src/PMTest.hs -- you can see my type definitions, which are trying to model musical note durations.
12:46:53 <pao> I've becomed to depended on hoogle and hackage :-)
12:46:59 <desp> I have an odd IO-related problem...
12:46:59 <pao> *too
12:47:01 <int-e> eflister: And perhaps people usually wrap their existentials into smaller boxes, without all the annotations. Imagine that instead of forall x. Foo x => Bar { many fields, x_field :: x } you had Bar { many fields, x_field :: AnX }, data AnX = forall x . Foo x => AnX x. Then the update trouble would be much smaller for you
12:47:10 <eflister> int-e: and then at line 43 is where the updaters are very nice, to avoid having to write things like lines 80-111
12:47:25 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11440#a11440
12:47:38 <desp> What's the difference?
12:48:01 <kmc> sinelaw, copumpkin, you could write a Haskell type representing dynamically typed LISP values, and a monad to model its side effects
12:48:16 <eflister> int-e: the boxing seems like it would work.  i'm just surprised this isn't straightforward...
12:48:23 <kmc> basically it would be straightforward to do a translation into Haskell that would not look like haskell code anyone actually writes
12:48:57 <sinelaw> @let f = (\x -> x x)
12:48:58 <lambdabot>  <local>:1:11:
12:48:58 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -...
12:49:14 <kmc> if your goal is LISP/Haskell interoperation, there is probably a better way
12:49:36 <kmc> for starters it's very easy to write an interpreter for a little LISP-like language in Haskell
12:50:26 <sinelaw> kmc, nah i want a clean conversion. most of the code i want to convert is probably pure
12:50:34 <sinelaw> (i'm thinking about Maxima)
12:50:49 <sinelaw> never looked at it and i have no idea how to read Lisp, so i may be wrong.
12:51:51 <kmc> you should be able to statically determine (a) whether a given expression is pure, and (b) whether it is well-typed in haskell's type system
12:52:01 <kmc> then manually deal with the ones that aren't
12:52:57 <desp> This is really odd.  I have no idea what's eating the exception.
12:53:14 <kmc> it sounds like a fun project, actually.  ghc api might be helpful
12:54:06 <Zao> http://announce.freenode.net <- nice bug.
12:54:24 <Zao> Serves you all with idents with a leading a-f right.
12:56:28 <int-e> eflister: generally I guess people try to get away with closed data hierarchies, for example  data NoteDur = DurBase DurBase | ModDur ModDur ... which will make the existential unnecessary, but will also prevent extending the type by adding new instances of NoteDur.
12:59:13 <eflister> int-e: thanks for taking a look!  yeah i don't so much care about keeping the class (or keeping it open) -- i just didn't want to introduce constructors like DurBase and ModDur into the DSL that the clients will use (i like "Dotted $Triplet Quarter" alot better than "ModDur Dotted $ ModDur Triplet $ DurBase Quarter") -- would there be any way to get the best of both worlds?  i'd even like to get rid of the $ necessary in the former if
12:59:14 <eflister> possible...
12:59:36 --- mode: mauke set -o mauke
13:00:24 <int-e> eflister: provide smart constructors? dotted $ triplet quarter  instead of  ModDur $ Dotted $ ModDur $ Triplet $ DurBase Quarter?
13:00:41 <eflister> int-e: oh yeah, that hadn't occurred to me...
13:00:55 <int-e> (well, that's stretching the term "smart constructor" a bit.)
13:01:31 <int-e> oh.
13:02:32 <int-e> and it won't quite work, right? you'll be able to write triplet $ triplet $ whole
13:02:54 <eflister> int-e: i was thinking enough layers of types would be able to prevent that...
13:06:23 <int-e> eflister: well, the issue is that with x :: DurBase, you want to be able to use all of  Dotted (Triplet x)  and  Triplet x  and  x  as NoteDur values. But the types of x and Triplet x must be different to prevent writing Triplet $ Triplet x. So if you want to do that with a single type inside Note and smart constructors, some of these constructors will end up in type classes, and that will be a bigger mess than you have right now (which...
13:06:29 <int-e> ...isn't all that bad, I guess, if you package the existential separately)
13:07:33 <int-e> eflister: or you could resort to runtime errors for  triplet $ triplet x, but that's unsatisfactory.
13:07:50 <eflister> int-e: isn't it surprising that this is hard in a language that emphasizes DSL's?
13:08:17 <eflister> int-e: i could give up on multiple levels of Dotted if necessary
13:09:32 <brooksbp> Hello
13:09:40 <ben_m> Hello
13:09:44 <brooksbp> is anyone working with separation logic?
13:11:26 <namor> brooksbp, ah
13:11:32 <dons> heya brooksbp
13:11:41 <dons> there's some guys at PSU. tommd might  know more.
13:11:41 <namor> brooksbp, What would you call separation logic?
13:11:54 <dons> http://en.wikipedia.org/wiki/Separation_logic
13:11:55 <tommd> More about what?
13:12:01 <tommd> Separation logic?
13:12:06 <dons> who's doing sep. logic @ PSU
13:12:40 <tommd> brooksbp, dons: Its mostly Andrew Mccreight
13:13:06 <tommd> Andrew Tolmach does some of the work too, but Andrew McCreight does the vast majority of the separation proofs.
13:13:20 <int-e> eflister: It's hard mainly because Haskell's type system is a separate language, and not as expressive as one might wish. (Aside: in Lisp we wouldn't even be discussing type safety of this kind. We might be discussing verifying well-formedness with macros; well, Template Haskell could do that as well.) Dependent types would probably make this easier (I say probably because I don't know a whole lot about them.)
13:13:51 <brooksbp> Do they frequent #haskell often?
13:13:56 <namor> Are there some usable hs-libraries for doing logic in general?
13:14:05 <tommd> brooksbp: No, they don't get on IRC as far as I know.
13:14:06 <eflister> int-e: i was trying to find out about dependent types after seeing some comment somewhere that they were awesome.  but i couldn't find an easy intro
13:14:19 <copumpkin> I'd start with agda
13:14:20 <copumpkin> in fact, I did
13:14:30 <copumpkin> it's closest in syntax to haskell
13:14:39 <int-e> is http://unit.aist.go.jp/cvs/Agda/tutorial/ any good?
13:14:54 <eflister> guess i didn't look hard enough http://en.wikipedia.org/wiki/Dependent_types
13:14:57 <copumpkin> never tried that one, but #agda and there's another pdf
13:15:12 <brooksbp> Ok
13:15:14 <copumpkin> http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Othertutorials the top one is what I was looking at
13:15:23 <copumpkin> it's not up to date with the latest agda but the differences aren't that big
13:15:28 <brooksbp> Is there anyone doing work on type systems for mutable state?
13:17:02 <copumpkin> brooksbp: not sure how many practical implementations there are, but (AT)TaPL covers a lot of ideas along those lines
13:17:10 <Guest69778> Hello. I'M a complete newbie with haskell and need some help. Would anyone be so kind as to point me to my error within my fine 5 lines of code?
13:17:32 <copumpkin> Guest69778: I would be happy to, but my mind-reading capabilities are not strong enough
13:17:52 <sjanssen> Guest69778: line 3
13:18:09 <dmwit> You don't need mind-reading, merely remote hard-drive reading. ;-)
13:18:13 <brooksbp> copumpkin: (AT)TaPL??
13:18:15 <d4mien> hi could anyone point me in right direction if I want to go through two integer list and do something with the first item in boths lists and then move on the too the second integer etc.
13:18:20 <int-e> @paste
13:18:20 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:18:22 <mauke> d4mien: zipWith
13:18:37 <Guest69778>  gleichung ::  (Double, Double, Double) -> (Double, Double)
13:18:38 <d4mien> mauke ok cool gonna check it up. big thanks
13:18:47 <Guest69778> that would be the code
13:18:58 <copumpkin> Guest69778: nothing inherently wrong with that
13:19:03 <mauke> that doesn't look like 5 lines
13:19:05 <int-e> Guest69778: please use a paste bin. http://hpaste.org/ is popular here
13:19:09 <dmwit> Guest69778: You should paste the other 4 lines to hpaste.org.
13:19:14 <Guest69778> allright
13:19:17 <copumpkin> Guest69778: a more descriptive nickname for yourself would also help us talk to you, as there are many other people in here with the same prefix as you
13:19:33 <copumpkin> :)
13:19:40 <copumpkin> oh
13:19:40 <int-e> uh.
13:19:42 <BONUS> lol
13:19:43 <copumpkin> well
13:19:45 <copumpkin> um
13:19:46 <desp> mauke, copumpkin: could you spare a moment to help me with a problem that has me completely stumped?
13:19:48 <ben_m> success?
13:19:59 <pao> Hi all, can anyone suggest the fastest random generator available for haskell? System.Random seems quite slow compared to Python os.urandom (based on /dev/urandom)
13:20:02 <copumpkin> desp: sure, just ask away and if we or anyone else knows the answer, they'll answer
13:20:08 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11440
13:20:18 <desp> I cannot for the life of me see the difference between the two approaches.
13:20:33 <brooksbp> copumpkin: what is (AT)TaPL?  Something with the Pierce book?
13:20:36 <copumpkin> desp: nothing's forcing the second one to compute it
13:20:38 <sjanssen> pao: bos recently released a fast generator recently, I can't remember what the package is called
13:20:40 <copumpkin> brooksbp: yep
13:20:46 <int-e> desp: the second one never evaluates the result of checkZero
13:20:52 <copumpkin> sjanssen, pao: statistics
13:21:01 <lpeterse> hackage.illdefined.org
13:21:08 <pao> copumpkin: sjanssen: thanks!
13:21:20 <dmwit> desp: It's the difference between (error "foo") and (return (error "foo")).
13:21:30 <pao> now I have to wait for hackage to come back :-)
13:21:36 <int-e> desp: it's lazy evaluation at work really. (good point, dmwit)
13:21:44 <dmwit> desp: Try putting (return (error "not zero")) in the second branch of readZeroA and you'll see the same behavior. =)
13:21:56 <desp> Ahh.
13:22:00 * desp slaps self.
13:22:01 <desp> Thanks.
13:22:23 <int-e> checkZero 0 = ()
13:22:25 <dons> pao: mersenne-random
13:22:25 <int-e> argh
13:22:30 <dons> pao: on hackage, its about 200x faster.
13:22:35 <int-e> checkZero 0 = return ()  (with checkZero :: Int -> ()
13:22:48 <dons> pao: you can grab the torrent, or from code.haskell.org/~dons/mersenne-random
13:22:49 <int-e> (with checkZero :: Int -> IO ())
13:22:50 <pao> dons: thanks a lot... so you confirm System.Random is a bit slow, right?
13:22:54 <dons> indeed.
13:22:57 <int-e> would also do the trick.
13:22:59 <dons> and for well understood reasons
13:23:05 <int-e> (sorry, my cut&paste-foo is broken)
13:23:18 <int-e> or -fu.
13:23:43 <brooksbp> copumpkin: can you elaborate on what you mean by: brooksbp: not sure how many practical implementations there are, but (AT)TaPL covers a lot of ideas along those lines
13:23:44 <pao> dons: thanks a lot
13:24:06 <dons> http://code.haskell.org/~dons/code/mersenne-random/
13:24:24 <copumpkin> brooksbp: I know that clean does uniqueness types and ATS does linear types, but there are more ideas along those lines covered in Pierce's books that I don't know implementations of
13:25:18 <pao> dons: .... Waiting for code.haskell.org ....
13:25:19 <dmwit> pao, dons: There's also the statistics library's implementation of MWC256.  More information here: http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/
13:25:35 <ccasin> brooksbp: the ynot project at harvard has developed a pretty impressive dependent type system for reasoning about imperative programs, including state.  Their papers are very interesting
13:26:03 <brooksbp> is it based off HTT?
13:26:06 <ccasin> yes
13:26:53 <pao> dmwit: now I get why my micro-bench was slow! :-)
13:27:16 <dmwit> pao: Yes, System.Random is glacial. =P
13:27:20 <brooksbp> Anybody have any ideas for an undergraduate thesis on type systems for memory management or mutable state?
13:29:35 <pao> @hpaste
13:29:36 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:29:59 <luite> can ghci only load dynamic (foreign) libraries? I link my program with -lClp, but I only have a static Clp library (libClp.a), ghci says that it tries to load a dynamic one (and fails)
13:30:33 <copumpkin> brooksbp: I'd read as many abstracts I could find from papers in the field and then try to make an informed proposal :P
13:31:33 <pollygreeneyes> Okay, been like 6 years since I last used IRC... Now I'm back with a working client and all. What was the url of the pastebin again?
13:31:37 <kmc> brooksbp, that's sort of a specific area
13:31:39 <kmc> @hpaste
13:31:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:32:01 <brooksbp> copumpkin: I've spent months doing so... I could simply just read for more months to come without doing anything...
13:32:05 <kmc> brooksbp, maybe use a type system to facilitate region inference for allocation
13:32:45 <brooksbp> kmc: Do you mean for dynamic regions?
13:32:51 <kmc> maybe
13:32:55 <kmc> just thinking out loud
13:33:19 <brooksbp> Can you explain? Because I thought region inference had already been done
13:33:26 <kmc> probably
13:34:15 <pollygreeneyes> allright. now that piece of code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4555 gives me type matching errors when I run it with the input 'gleichung 2 2 2' why would that be? I cant get my head around it
13:34:24 <Asztal> luite: unfortunately, yes
13:34:38 <kmc> pollygreeneyes, gleichung (2,2,2)
13:34:55 <kmc> but, it's more typical to take three arguments instead of a single argument which is a three-tuple
13:35:51 <pollygreeneyes> omg thanks...
13:36:17 <luite> Asztal: ok, I'll try to build a dynamic one then
13:36:17 <pollygreeneyes> still doesn't work as intended but i'm one step closer i guess. thanks again
13:36:47 <ben_m> Heh. 20 minutes to get used to irc clients, 3 minutes to paste, 15 seconds to actually solve the problem
13:36:52 <kmc> :D
13:38:29 <tommd> ben_m: That is typical of technology of all sorts.
13:38:51 * dmwit points at TV
13:38:51 <kmc> for programs too
13:38:58 <dmwit> TV has never solved any problem in any amount of time. =(
13:38:59 <kmc> 90% of any program is just piping data around
13:40:36 <Adamant> dmwit: there was an interesting article suggesting otherwise
13:41:15 <Adamant> about how TV was more likely to reduce birthrate to roughly ~2 kids per couple than anything else in developing countries
13:41:26 <dmwit> agh
13:41:27 <Twey> kmc, pollygreeneyes: Unless they're related (e.g. a three-dimensional point)
13:41:29 <dmwit> That's horrible.
13:41:37 <Twey> Adamant: Haha.
13:41:47 <Adamant> dmwit: why?
13:42:31 <blackdog> filling those long evenings with something productive, like watching reality shows... go civilisation!
13:42:58 <Adamant> it was more the soap operas actually, or so they theorize
13:43:18 <jokerGTA> guys can anyone tell me why am i getting "possible inccorect identation" error on this code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4556#a4556
13:43:22 <kmc> solution: an hour a day where every channel shows porn
13:44:36 <kmc> jokerGTA, that's really messy... are you using ReadS for a particular reason?
13:44:39 <kmc> Parsec might be more appropriate
13:45:00 <jokerGTA> to be honest kmc this is the best i could come up with
13:45:21 <jokerGTA> trying to understand parsec is taking me too much time
13:45:29 <kmc> with Parsec you can use the "do" notation, and the Monad / Applicative operators.  i don't know if there's a Monad instance for ReadS
13:45:33 <blackdog> before i reinvent the wheel, is the Z->ZZ, z->zz, .->zd etc encoding used in GHC in a module somewhere?
13:45:35 <jokerGTA> this way i was able to make some progress
13:45:52 <Vanadium> The number of parentheses in the last line seems uneaven?
13:45:56 <dmwit> mauke: ping
13:46:06 <jokerGTA> you think you could somehow translate this into parsec so i can see how it works
13:46:39 <dmwit> jokerGTA: You've got mismatched parens in there, haven't you?
13:46:54 <dmwit> on the last line
13:47:07 <jokerGTA> yeah last line is where error is..when i comment it out it works
13:47:20 <dmwit> blackdog: The only thing I can think of is if there's a module in preflex for it.
13:47:48 <kmc> jokerGTA, yeah, one sec
13:48:03 <jokerGTA> thanks kmc
13:48:04 <mauke> http://mauke.ath.cx/preflex/Plugin/ZCode.hs
13:48:12 <kmc> can you give me your "data MyProgram" definition?
13:48:30 <dmwit> sweet
13:48:32 <jokerGTA> yes....i had to change some things just for simplicity
13:48:36 <jokerGTA> hang on'
13:48:58 <blackdog> dmwit: is that a hackage package?
13:49:07 <pao> @hpaste
13:49:07 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:49:18 <dmwit> blackdog: I don't think so, but mauke just pasted a link to the source for the zdec/zenc bits of preflex.
13:49:36 <m4ik3ru> Howdy.
13:49:51 <m4ik3ru> In this function call: checkStmt ast@(ASTVariableDecl ident ty) = do
13:49:51 <jokerGTA> kmc http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4559#a4559
13:50:06 <m4ik3ru> What does ast@(...) mean?
13:50:06 <jokerGTA> i have all the functions done
13:50:16 <pao> dons: would you mind giving a look to this micro benchmark? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4558#a4558
13:50:33 <jokerGTA> MyProgram is actually MouseProgram
13:50:36 <blackdog> dmwit, mauke: ah, thanks.
13:50:42 <copumpkin> m4ik3ru: it binds the entire pattern inside the parentheses
13:50:57 <copumpkin> > let all@(x:xs) = [1..3] in (all, x, xs)
13:50:58 <lambdabot>   ([1,2,3],1,[2,3])
13:51:44 <m4ik3ru> Ah.
13:51:54 <m4ik3ru> Thanks :)
13:52:02 <copumpkin> no problem!
13:52:07 <m4ik3ru> Working on a typechecker assignment for class.
13:52:10 <copumpkin> the bit inside can be arbitrarily complex
13:52:15 <m4ik3ru> Monads are extremely confusing...
13:52:24 <copumpkin> m4ik3ru: only because people explain them wrong!
13:52:30 <ben_m> agreed
13:52:44 <eflister> m4ik3ru: typeclassopedia will unconfuse it
13:52:44 <kmc> m4ik3ru, what are you trying to learn re: monads?
13:52:53 <copumpkin> m4ik3ru: if you call within the next 20 minutes, you get my free personalized monad tutorial, completely free! that's right, you heard me right. A full $40 value for free!
13:53:16 <blackdog> copumpkin: are monads like a free set of steak knives?
13:53:25 <copumpkin> blackdog: nah, those are junk
13:54:08 <eflister> everything other than typeclassopedia is just a variant on this http://koweycode.blogspot.com/2007/01/think-of-monad.html
13:54:09 <ben_m> And if you call NOW, you will also get an Arrow tutorial for free.
13:54:17 <copumpkin> eflister: nuh uh, not my way
13:54:35 <m4ik3ru> kmc: We're basically implementing ask, local, tell, get, put, modify, throwError and catchError from Reader, Writer, State and Monad to typecheck a subset of the C language.
13:54:36 <eflister> copumpkin? eh?
13:54:45 <kmc> wow
13:54:52 <blackdog> copumpkin: ah. so they're more like pyramid selling? or aztec sacrifice? help me out here, man, i need an inappropriate hook to hang some purely definitional knowledge on
13:54:53 <kmc> m4ik3ru, have you worked with simpler monads like Maybe?
13:54:57 <flippo> I want an abelian group, not a monoid.
13:55:03 <m4ik3ru> We were given a huge chunk of code that was mostly done, and we just have to fill in a few things.
13:55:08 <m4ik3ru> kmc: Only barely.
13:55:13 <copumpkin> flippo: we got no typeclass for that, sadly
13:55:18 <kmc> m4ik3ru, i recommend you implement the Maybe monad yourself
13:55:22 <m4ik3ru> kmc: I understand how that one works for the most part.
13:55:26 <kmc> then play around with programming with it, both using "do" and the operators
13:55:33 <jokerGTA> did you see my data type kmc
13:55:41 <kmc> yeah
13:55:45 <kmc> i'm writing the parser
13:55:46 <copumpkin> m4ik3ru: I'd be happy to test my 'splainin skills on you in pm
13:55:54 <ben_m> copumpkin: aww, no pm
13:55:56 <copumpkin> lol
13:55:58 <jokerGTA> thank you
13:56:01 <ben_m> I think I understand Monads, but I want to listen anyways
13:56:03 <kmc> no problem
13:56:09 <kmc> Parsec can be tricky, hopefully this will get you started
13:56:23 <m4ik3ru> copumpkin, go for it.  Never pass up an opportunity to try to learn something new!
13:56:25 * ben_m can't find a good Parsec tutorial
13:56:28 <jokerGTA> yeah i also have i got like a week to do it
13:56:40 <copumpkin> ben_m, m4ik3ru: how about #monadsarecool
13:56:50 <ben_m> #>>=
13:57:37 <BMeph> copumpkin: What's wrong with #haskell-overflow? Isn't that channel made for this? ;)
13:57:45 <eflister> ben_m: is rwh's discussion of parsec not adequate?
13:57:55 <copumpkin> BMeph: true, but what's done is done
13:58:11 <ben_m> eflister: rwh's?
13:58:20 <ben_m> eflister: I don't know that, got a URL?
13:58:51 <eflister> ben_m: http://book.realworldhaskell.org/read/using-parsec.html
13:59:33 <ben_m> Oh, thanks :)
13:59:39 <ben_m> I haven't read real world haskell that much
14:01:54 <hamandine> any workaround for cabal install while hackage is down?
14:02:23 <blackdog> hamandine: there's a torrent floating around
14:02:27 <koeien> see /topic for a torrent
14:02:44 <osfameron> hackage isn't distributed?
14:02:48 <hamandine> how can the torrent be used?
14:02:55 <osfameron> CPAN++ # doesn't go down ;-)
14:02:57 * osfameron ducks
14:03:08 <ben_m> cpan++ ;)
14:03:39 <Berengal_> Hackage is distributed, but only by one server ;)
14:03:42 <kmc> :t foldr1
14:03:43 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:03:55 <hamandine> do I have to download the torrent first?
14:04:11 <koeien> do you have a bittorrent client ?
14:04:15 <hamandine> yes
14:04:32 <Cale> Good bittorrent clients will let you select which files you want to download
14:04:39 <blackdog> I wonder how hard it'd be to actually host hackage properly on bittorrent.
14:04:54 <blackdog> suppose you'd end up with trustability problems
14:05:02 <koeien> blackdog: bittorrent has hashing
14:05:12 <hamandine> it's only 85M, so not too bad
14:05:15 <koeien> i.e. if you trust the torrent file, you can trust the result
14:05:16 <Berengal_> blackdog, I thought about that myself. You'd want some kind of PKI though
14:05:43 <koeien> but, then you still have the torrent file in 1 location, which is not so nice
14:05:50 <blackdog> koeien: that's a point. i guess updates could be tricky, too
14:06:05 <koeien> yes
14:06:14 <blackdog> koeien: one small-ish file is probably bearable, and easier to host in multiple places
14:06:16 <Berengal_> Cabal could use bittorrent as a fallback
14:06:39 <blackdog> you'd need to serialise updates somewhere, but if that server went down, you'd just end up with a slightly stale repo
14:06:58 <koeien> maybe rsync + gpg + a list of mirrors ?
14:07:19 <kmc> jokerGTA, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11442#a11442
14:08:02 <HaudRex> Can foldr be defined in terms of fix?
14:08:07 <jokerGTA> kmc tx man
14:08:18 <jokerGTA> i gotta try to understand all this
14:08:37 <kmc> ask away
14:08:44 <mauke> HaudRex: sure, why not?
14:08:47 <kmc> one thing to know about parsec, that i'm not using here, is "try"
14:08:53 <kmc> basically a parser can fail, but still consume some input
14:09:23 <kmc> in that case you can wrap it with "try", to make it not consume input on failure
14:09:24 <jokerGTA> why do you have system (getArgs)
14:09:26 <kmc> but at a performance cost
14:09:33 <kmc> jokerGTA, in main i use it to parse input from the cmdline
14:09:52 <kmc> not necessary if you're playing around in ghci
14:09:52 <narens> hello, what is the general method to do this: you are doing a fold on a type with a function a -> Maybe a. Now, when that function returns Nothing.. I want it to return the result of the previous fold and short circuit.
14:10:03 <kmc> narens, you want to use Maybe as a monad
14:10:09 <kmc> :t foldM
14:10:10 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:10:18 <mauke> @src foldM
14:10:19 <lambdabot> foldM _ a []     = return a
14:10:19 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:10:45 <kmc> narens, a fold function usually has two arguments
14:11:10 <kmc> hmm but that will give Nothing, not the previous result
14:11:21 <narens> kmc: hmm... but even in foldM if Nothing >>= something its going to return Nothing
14:11:28 <kmc> yeah
14:11:43 <mauke> my brain is telling me "continuations"
14:11:54 <mauke> not sure if I can trust it, though
14:11:55 <kmc> that seems like overkill, but would work
14:12:02 <narens> kmc: i kind of need a reverse mplus. I just want to avoid using an if statemtn
14:12:28 <narens> kmc: but, seems like i might be asking for too much
14:13:47 <yitz> > let fixFoldr f x ys = let g h f x (y:ys) = f y (h f x ys); g _ _ x _ = x in fix g in fixFoldr (:) [] [1..10]
14:13:48 <lambdabot>   {{()->{()->()}}->{()->{[]->();[()]->();[(),()]->();[(),(),()]->()}}}
14:13:56 <yitz> hoo
14:13:57 <koeien> yikes
14:16:18 <kmc> narens, i'd just write the fold yourself
14:16:31 <HaudRex> yitz: Very nice.
14:17:03 <HaudRex> @let fixFoldr f x ys = let g h f x (y:ys) = f y (h f x ys); g _ _ x _ = x in fix g in fixFoldr (:) [] [1..10]
14:17:04 <lambdabot>   Parse error: KW_In
14:17:18 <HaudRex> @let fixFoldr f x ys = let g h f x (y:ys) = f y (h f x ys); g _ _ x _ = x in fix g
14:17:19 <lambdabot>  Defined.
14:17:29 <mauke> :t fixFoldr
14:17:30 <lambdabot> forall t t1 t2 t3 t4. t -> t1 -> t2 -> (t3 -> t4 -> t4) -> t4 -> [t3] -> t4
14:17:33 <mauke> yeah, no
14:17:41 <HaudRex> hmm
14:18:03 <BONUS> maybe you could fold with Either a (a,a) where the tuple holds the previous and the current result.
14:18:12 <HaudRex> \f z xs -> fix (f (head xs) something with tails here )
14:18:20 <BONUS> if your function returns a Left something, replace that something with the first a from the tuple
14:18:24 <BONUS> and it will short circuit with that
14:19:36 <mauke> > fix (\self f z ys -> case xs of [] -> z; x : xs -> f x (self f z xs)) (:) [] "abc"
14:19:37 <lambdabot>   Not in scope: `xs'
14:19:42 <mauke> > fix (\self f z ys -> case ys of [] -> z; x : xs -> f x (self f z xs)) (:) [] "abc"
14:19:43 <lambdabot>   "abc"
14:20:30 <yitz> mauke: hmm, why is that not identical to what I wrote?
14:20:38 <hamandine> cabal complains about missing "cairo -any, glade -any, gtk -any"... those are not hackage packages, are they?
14:21:23 <mauke> yitz: you seem to have several unused parameters
14:22:06 <yitz> ah
14:22:20 <yitz> > let fixFoldr = let g h f x (y:ys) = f y (h f x ys); g _ _ x _ = x in fix g in fixFoldr (:) [] [1..10]
14:22:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:23:28 <luite> hm, I'm trying to build a shared library so that I can use my ffi bindings in ghci, but I get this: "WARNING: On Msys, shared objects are not supported. I'm disabling your choice." (by the libClp configure). is this really true?
14:23:33 <Axman6> hamandine: those are gtk2hs packages
14:26:05 <HaudRex> @let Nil = \x y h f -> x
14:26:06 <lambdabot>  <local>:4:0: Not in scope: data constructor `Nil'
14:26:29 <HaudRex> @let myNil = \x y h f -> x
14:26:31 <lambdabot>  Defined.
14:26:33 <hamandine> Axman6: what does that mean?
14:26:47 <Axman6> hamandine: it means you need to install gtk2hs
14:26:57 <hamandine> hmm, I thought I did
14:29:24 <hamandine> Axman6: gtk2hs isn't cabalized... do I need to indicate where it lives?
14:29:39 <Axman6> possibly
14:29:55 <mauke> unlikely
14:30:16 <dmwit> "ghc-pkg list gtk2hs" will tell if GHC knows where it lives.
14:30:48 <dmwit> err
14:31:03 <hamandine> it's not there, although I did 'make install'
14:31:14 <dmwit> I guess the package name would be "gtk", not "gtk2hs".
14:31:42 <hamandine> oh, that one is there
14:32:18 <dmwit> Are you creating your own cabal file, or are you trying to build an existing project?
14:32:29 <dmwit> If you're building your own, have you listed gtk in your package dependencies?
14:32:40 <dmwit> oh
14:32:43 <dmwit> I bet I know what it is.
14:32:49 <dmwit> I bet it's a user/system thing.
14:33:24 <hamandine> I'm trying to build ThreadScope
14:33:32 <dmwit> I bet you installed gtk2hs into your user's package list, and are now trying to configure ThreadScope as non-user.
14:33:36 <dmwit> try
14:33:39 <dmwit> cabal configure --user
14:34:46 <hamandine> dmwit: exactly!
14:34:48 <hamandine> thanks
14:34:52 <hamandine> what does '--user' mean?
14:35:13 <dmwit> GHC tracks two different views of what packages are installed.
14:35:34 <dmwit> One of them is the list of packages installed for every user, and one of them is the list of packages that you have installed only for yourself.
14:35:42 <dmwit> This is super useful on machines where you happen not to have root.
14:35:54 <dmwit> (Because it means you can still install packages for yourself and use them.)
14:35:59 <hamandine> is that orthogonal to their location in the file system?
14:36:03 <dmwit> yes
14:37:03 <dmwit> ~/.cabal/config should have a setting for this; the default is to specify --user, so it sounds like you've modified that file at some time and now forgotten about it.
14:37:24 <dmwit> In any case, perhaps the best thing is to re-install gtk2hs into the "every user" package list.
14:38:40 <hamandine> it contains '-- user-install: True'
14:38:55 <hamandine> but I was doing a manual install, without cabal-install, since hackage is down today
14:39:05 <d4mien> hi could anyone take a quick look at this and tell me why this won't work. I think it is very strange http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11443#a11443
14:39:27 <Saizan> you can use "cabal install" in a directory with the .cabal file.
14:39:27 <koeien> d4mien: [(Bool,Bool)]
14:39:30 <dmwit> ah
14:39:32 <koeien> line 11
14:39:46 <d4mien> koeien oh one sec let me test =)
14:40:02 <koeien> d4mien: i didn't check the rest though
14:40:31 <d4mien> koeien it didn't work :/
14:41:15 <d4mien> does it have to do with ( ) or lack of it in my case =)
14:41:15 <dmwit> d4mien: I think you're confused about what zip and zipWith do.
14:41:17 <hamandine> why is gtk2hs not cabalized?
14:41:51 <dmwit> d4mien: There's so many things, it's hard to know where to start.  For example, "a" and "b" are not in scope.
14:42:04 <dmwit> d4mien: zip takes two arguments, but you give it 8.
14:42:05 <d4mien> dmwit hm ok, if I got it right zipWith takes two lists and goes throgh with it and does what i tell right after zipWith ex (+)
14:42:28 <d4mien> and zip just combines two lists into a [(a,a)] ?
14:42:40 <d4mien> with the first elemnt of each list as the first
14:42:43 <d4mien> and so on
14:42:49 <medfly> they can be of different types
14:43:03 <d4mien> in my case they are all bools
14:43:17 <medfly> oh, okay... sorry, wasn't reading the entire conversation
14:43:28 <d4mien> just a test function that runs some tests on some functions and they should get the same result
14:43:47 <medfly> Haskell has some kind of test function
14:43:58 <medfly> okay, I'm doing it again
14:44:00 <medfly> sorry
14:44:09 <d4mien> and therefor I want it like [(True,True),(False,True)] so I can see it
14:44:10 <dmwit> d4mien: Yes, I see what you're going for here.  You need more parens, as you say.
14:44:22 <d4mien> dmwit ok thought it was that
14:44:36 <d4mien> probaly zip (....) (....) I guess
14:45:21 <d4mien> yeah it worked =)
14:46:15 <hamandine> is the 6.12 manual available somewhere?
14:46:18 <d4mien> so little code with haskell to do things that takes more code in OO languages
14:46:24 <dmwit> hamandine: I don't remember why gtk2hs is not cabalized, but it's mostly a technical reason.
14:46:47 <dmwit> hamandine: i.e. cabal doesn't support something that gtk2hs needs to build; maybe it was the ./configure script or something like that.
14:47:02 <dmwit> In any case, the devs are aware of it, and fixing it is on their wishlist. =)
14:47:50 <dmwit> hamandine: Seems not, but the 6.10.4 docs should be very close to 6.12 stuff.
14:47:54 <jokerGTA> kmc you still there?
14:47:56 <kmc> yeah
14:47:57 <dmwit> Is there a particular 6.12 feature you're wondering about?
14:48:22 <jokerGTA> ill copy this whole thing i have to show you something
14:48:25 <hamandine> dmwit: flags for multi-core
14:49:12 <jokerGTA> i added this because i thought that will allow me to use my show functions I wrote...instance ParsecRead MouseProgram where 	parsecRead = parseOne
14:50:14 <jokerGTA> instance Show MouseProgram where 	showsPrec _ Stay           = showString "Stay"
14:50:14 <aweber> is http://hackage.haskell.org/ down?
14:50:22 <jmillikin> see topic
14:50:24 <koeien> aweber: yes, see /topic
14:50:50 <aweber> koeien, ah sorry - thanks
14:51:00 * blackdog wants a big bucket of green slime a la "You can't do that on television"
14:51:44 <jokerGTA> but it gives me errors because "no Instance for Show [Char ]->Eighter Parse Error MouseProgram
14:51:50 <jokerGTA> i tried to do this on commadn line
14:51:59 <jokerGTA> parse parseOne "stay"
14:52:40 <Saizan> parse takes 3 arguments
14:52:53 <jokerGTA> empty string as well?
14:53:11 <jokerGTA> parse parseOne "" "stay"   <- like this
14:53:35 <Saizan> yeah, the "" is basically the name of the source "file"
14:54:16 <jokerGTA> yeah i see it now
14:54:26 <jokerGTA> anyone here from toronto area by the way
14:56:40 <luite> I have a function that uses a global array to do some lookups (read only, so no ST or IO involved). the problem is that the required size of the array depends on the input of the function. is it possible to replace this array by a larger one if my function gets called with an input for which the larger array is required?
14:57:21 <blackdog> luite: wouldn't think so. could you chunk it into a list of arrays, perhaps?
14:57:37 <blackdog> then you could define it lazily with a bounded amount of wasted space
14:58:29 <jokerGTA> kmc for example if your input string is like this "word1  word 2 word 3 word 4"...parser detects for example word1 now what happens to the rest of the input
14:58:47 <kmc> in what code?
14:59:42 <jokerGTA> in the one you sent me
14:59:59 <jokerGTA> lets say it detects word "stay"
15:00:07 <jokerGTA> it returns "right stay"
15:00:49 <jokerGTA> or it might unexpected something
15:01:04 <jokerGTA> now i want to call constructor of Stay
15:01:10 <HaudRex> @let myNothing = const
15:01:11 <lambdabot>  Defined.
15:01:13 <jokerGTA> can i just say Stay stay
15:01:18 <HaudRex> @let myJust = \x y z -> z x
15:01:19 <lambdabot>  <local>:4:0:
15:01:19 <lambdabot>      Multiple declarations of `L.myJust'
15:01:19 <lambdabot>      Declared at: <loc...
15:01:44 <HaudRex> (myJust 10) 0 (+1)
15:01:48 <HaudRex> > (myJust 10) 0 (+1)
15:01:50 <lambdabot>   11
15:01:59 <HaudRex> > myNothing 0 (+1)
15:02:01 <lambdabot>   0
15:02:06 <HaudRex> yay
15:02:15 <HaudRex> I want to do that with List
15:02:18 <luite> blackdog: unfortunately that's not possible. I need to zip this array with another array (uvector zip, where the zipped array is just a data type with the two original arrays, the lookup function looks up the index in both arrays and returns a pair)
15:03:29 <luite> it's for automatic differentiation of a UArr Double -> Double  function
15:04:11 <jokerGTA> oh yeah i see that...its already there the call for constructor
15:04:43 <dons> can't wait to see the code, luite
15:05:04 <luite> which then more or less becomes: gradient::(UArr (Double :*: Double) -> Double :*:) -> UArr Double -> [Double]
15:05:13 <luite> oops, forgot a Double there
15:06:51 <luite> dons: don't expect too much, I stripped all the fancy AD things you might have seen elsewhere, it's now just a very simple thing that can only calculate the first derivative :)
15:07:58 <luite> but I'm kind of stuck at the moment, I need shared objects for the linear programming solver used in this program (Clp), but apparently I can't build them with msys
15:09:46 <luite> dons: are there any issues with uvector 1.0.4 I should know about?
15:10:59 <hamandine> what happened to the -g RTS option in 6.12? seems to be gone...
15:12:39 <Kruppe> Anyone know what errors like these mean in ghc: Main.o: In function `r2J5_info':
15:12:39 <Kruppe> (.text+0x95a): undefined reference to `containerszm0zi1zi0zi1_DataziMap_fromList_closure' ?
15:12:51 <Botje> Kruppe: are you calling ghc with --make ?
15:12:53 <Botje> if not, do so :)
15:13:11 <Kruppe> ah
15:13:13 <Kruppe> thanks :)
15:13:16 <Kruppe> works now
15:14:03 <tommd> It shouldn't be too hard to make a bot recognize issues where people fail to use --make.  It would be funny to have lambdabot answer those questions.
15:15:24 <koeien> it wouldn't be too hard to patch ghc to detect this?
15:15:31 <lantti> Or ghc
15:15:42 <lantti> Ah koeien beat me to it :)
15:15:45 <koeien> it comes up so often
15:15:59 <Botje> i wonder why it's not the default, anywa
15:16:16 <Kruppe> is it only when it needs to do linking that you need --make?
15:16:22 <bob0> what's wrong with hackage?
15:16:52 <koeien> bob0: it's down, see /topic
15:17:31 <Saizan> Kruppe: if you're compiling a bunch of source files together too
15:17:52 <Kruppe> isnt that linking?
15:17:55 <jokerGTA> kmc
15:17:55 <koeien> in that case you only need to mention the one with "main", and ghc will figure out where the rest is
15:19:14 <Saizan> Kruppe: you can just generate the .hi and .o files for all the modules without linking, and in fact that's what happens when cabal compiles a library
15:20:52 <Kruppe> Saizan: they would have to be modules that don't depend on something else though right?
15:21:21 <Saizan> Kruppe: no, why?
15:21:50 <Kruppe> Saizan: ehhh It's not important, just curious
15:22:09 <jokerGTA> guys is there any way i get get nice editor when working with ghci rather then working with command line interface..like editor with syntax highlights and keyworkds etc
15:22:26 <Kruppe> jokerGTA: emacs
15:22:29 <skorpan> well, there's emacs
15:23:04 <blackdog> if you have haskell-mode turned on, C-c C-l should get you a ghci instance running inside emacs, too
15:23:06 <jokerGTA> so i just dowload it and works with ghci?
15:23:15 <skorpan> yes
15:23:21 <skorpan> but you also need to download haskell-mode
15:23:25 <Kruppe> jokerGTA: you need to get the mode if its not included in your default package
15:23:28 <BMeph> jokerGTA: Use ":set editor" :)
15:23:37 <Botje> how far is along is leksah?
15:23:43 <jokerGTA> use it where.....once when i dowload it
15:24:34 <Kruppe> jokerGTA: i think he was talking about within ghci
15:24:39 <BMeph> jokerGTA: Sorry; in GHCi, or in a ".ghci" file, type ":set editor <the name of the command to use your editor>" and it'll do that.
15:25:01 <jokerGTA> what do i dowload from here....http://ftp.gnu.org/pub/gnu/emacs/
15:25:02 <Kruppe> jokerGTA: thats how the vim people roll as i understand it
15:25:04 <hamandine> what exactly does 'maximum heap residency' mean?
15:25:05 <dons> luite: no outstanding issues. unfinished api is biggest issue
15:25:23 <skorpan> jokerGTA: if you can't get it from your distribution's package manager, use http://ftp.gnu.org/pub/gnu/emacs/emacs-23.1.tar.gz
15:25:54 <jokerGTA> ok i am dowloading it now....
15:26:12 <blackdog> jokerGTA: what OS are you using, btw?
15:26:21 <jokerGTA> windows xp
15:26:27 <skorpan> oh, well, then...
15:26:27 <blackdog> you probably want to download a binary, then
15:26:42 <skorpan> jokerGTA: http://ftp.gnu.org/pub/gnu/emacs/windows/emacs-23.1-bin-i386.zip
15:27:44 <jokerGTA> where do i find ".ghci" file to change setting
15:28:28 <Kruppe> jokerGTA: you wont find it on windows, not sure how you configure ghci there
15:30:35 <skorpan> the same way as on other OSs i guess
15:30:49 <skorpan> but ~ is probably C:/Documents and Settings/yourUserName/Application Data/
15:31:01 <skorpan> or maybe that but without application data
15:33:23 <yitz> skorpan: on XP
15:33:43 <yitz> skorpan: but on Vista and Windows 7, it's something else
15:34:17 <yitz> C:\Users\name I think
15:34:35 <yitz> kinda like MacOS X. oops, hush!
15:35:26 <hamandine> is there a way to get the maximum heap size at runtime?
15:36:06 <skorpan> yitz: yes, but this guy said he's using win XP
15:36:12 <yitz> oh, ok
15:36:44 <skorpan> that's one good thing about windows vista... dropping the whitespaces in important folder names
15:38:14 <jokerGTA> so now i just run install?
15:38:39 <yitz> skorpan: it's no use, windows users regularly put spaces, symbols, and other nasty unicode in their file names. you can forget using unix-like tools, unless you yourself are the only one using that computer.
15:39:07 <yitz> and you never receive files from anyone else.
15:39:35 <jokerGTA> i should probably leave windows out of it and install it on my debian machine
15:40:18 <yitz> jokerGTA: now you're talking
15:40:40 <yitz> seriously, everything ought to work ok on windows
15:40:51 <skorpan> everything does work on windows
15:41:01 <jokerGTA> well ....i install debian few weeks ago on my pc....i have dual boot on it....but most of my wor i get done on windows xp notebook since i am new to linux
15:41:21 <koeien> you start with debian? that's the spirit! :)
15:41:44 <jokerGTA> well you gotta try...then fail..then you try again:)
15:42:16 <blackdog> jokerGTA: everything does work fine with windows, but you'll probably get better help with debian or mac, just because more of us run it
15:42:33 <skorpan> more mac users than windows?  no way.
15:42:40 <Kruppe> that use haskell
15:42:43 <skorpan> really?
15:42:52 <Kruppe> that hang out in here
15:43:05 <Kruppe> at least thats the impression i get
15:43:10 <Kruppe> clearly i have no solid data on this
15:43:11 <jokerGTA> well right now to be honest i just want something better then command line..because every time i want to recomiple i have to close my .hs file before i do that
15:43:12 <yitz> mac users, raise your hands
15:43:14 <yitz> o/
15:43:19 <jokerGTA> i write the code with notepad.
15:43:30 <monochrom> "close"? you can just save.
15:43:49 <blackdog> skorpan: i'd say so, but i have no data
15:43:52 <jokerGTA> yeah i save..but with hugs you dont have to close
15:43:56 <Kruppe> jokerGTA: at least use notepad++!
15:43:59 <jokerGTA> with command interface you have to close
15:44:00 <skorpan> blackdog: i challenge you!
15:44:09 <mauke> jokerGTA: uh, what?
15:44:11 <Saizan> jokerGTA: why close?
15:44:37 <monochrom> I don't have that problem. I just save. I cannot reproduce your problem.
15:44:49 <jokerGTA> becaue otherwise my command line ...lets say i type something in interface and i want to edit the file..i can do this :e
15:44:53 <Saizan> you can just switch between programs keeping both open
15:44:56 <jokerGTA> now my .hs file is open right
15:45:04 <mauke> I don't use :e
15:45:19 <Saizan> yeah, don't use :e
15:45:24 <skorpan> hehe, i love the fact that we recommended this guy to switch to debian and emacs for this problem :)
15:45:31 <jokerGTA> lol
15:45:35 <jokerGTA> hehe
15:45:36 <koeien> emacs? heretics!
15:45:49 <skorpan> oh please, vim barely supports haskell ;)
15:45:58 <koeien> at least it has normal keybindings ;)
15:46:13 <yitz> skorpan: vim supports haskell better than notepad
15:46:23 <jokerGTA> anyone from toronto here by the way
15:46:25 <blackdog> skorpan: that's more in the way of general life advice
15:46:27 <Kruppe> yitz: true
15:46:27 <skorpan> really?  you have to hit "i" twice to insert an actual "i"! :)
15:47:06 <Kruppe> I use vim keybindings in emacs :O
15:47:11 <Kruppe> because i like them better
15:47:14 <Kruppe> but find vim lacking in
15:47:15 <blackdog> Kruppe: pervert:)
15:47:18 <Kruppe> lots
15:47:28 <jokerGTA> ok so how are you able to type on windows command interface without closing the file....id like to know guys
15:47:38 <Kruppe> blackdog: pfft, you know you want to do what i do
15:47:40 <jokerGTA> i must know:)
15:47:45 <BMeph> jokerGTA: When you use ":e", GHCi suspends itself until it receives an "I'm done!" signal from your editor, which it'll only do when it's "closed" (AKA when you exit the editor). If you weren't calling your editor from within GHCi, it wouldn't expect to gain control from it, and so it (GHCi) wouldn't care if the editor's still open. :)
15:47:48 <Vanadium> Open another windows command interface
15:47:48 <monochrom> You sound like you're using DOS 3.3
15:48:27 <monochrom> Or else, you sound like you're using DOS 3.3 techniques on Windows 7.
15:48:42 <yitz> skorpan: no, vim gurus can always just type p because they somehow always have i in the buffer when they need to type i.
15:48:59 <monochrom> (Why would you launch notepad from command line? Start -> Accessories -> Notepad or something already.)
15:49:41 <skorpan> yitz: in emacs we just hit i ;P
15:49:50 * BMeph uses notepad++, because he's too scared to use SciTE. ;)
15:49:53 <jokerGTA> when i installed ghci it probably did this by default..i never really bother to change it because my assgnments before were too hard...now i am woring on this assignemnt and i need to redo things so many times
15:49:56 <jokerGTA> its becoming pain
15:50:01 <skorpan> windows actually has a gmrun clone... win+r
15:50:25 <Saizan> jokerGTA: it's not something you've to change in ghci
15:50:32 <mauke> skorpan: vim supports F1 to open the help
15:50:33 <monochrom> ghci installs dos 3.3 by default?!
15:50:41 <Saizan> jokerGTA: you just have to open your editor indipendently of ghci
15:51:21 <monochrom> Really, :e is for people who still uses a vt100 terminal
15:51:37 <yitz> skorpan: i've been using emacs for years. but increasing my vi-fu is on my wish list.
15:51:47 <ivanm> OK, so the @seen plugin has gone... _now_ why is lambdabot dying every other day?
15:52:10 <skorpan> mauke: congratulations on that achievement
15:52:13 <Saizan> @bot
15:52:13 <lunabot>  :o
15:52:14 <lambdabot> :)
15:52:18 <ivanm> @uptime
15:52:19 <lambdabot> uptime: 5h 31m 10s, longest uptime: 1m 10d 23h 44m 29s
15:52:22 <skorpan> yitz: vi is not a bad editor, it just lacks a good operating system
15:52:29 <ivanm> it was up to 22 days a couple of days ago...
15:52:36 <Saizan> ivanm: because she feels like so!
15:52:36 <sinelaw> that's one month without me trying to kill it
15:52:42 <ivanm> skorpan: heh, an interesting twist ;-)
15:52:52 <yitz> @vixen how are you feeling today?
15:52:53 <lambdabot> i'm good, you?
15:53:31 <sinelaw> @vixen why do you keep crashing?
15:53:32 <lambdabot> why anything?
15:53:48 <sinelaw> @vixen *sigh*
15:53:48 <lambdabot> hahaha.
15:53:52 <sinelaw> bastard
15:53:55 <blackdog> she's not a nice girl.
15:54:02 <yitz> sinelaw: please, you'll cause her to have an existential crisis.
15:54:05 <blackdog> @vixen I thought you liked Haskell programmers
15:54:05 <lambdabot> church is my favourite computer scientist.
15:54:19 <blackdog> eesh, playing the theorist card.
15:54:36 <sinelaw> i liked SPJ's line about "And then god came, in the form of Church"
15:54:52 <sinelaw> or something of the sort
15:55:19 <jlouis> I like that many many years ago, vixen was also part of lambdabot. She is one of the earliest modules
15:55:49 <medfly> isn't vixen a person
15:55:57 <yitz> @vixen how old are you?
15:55:58 <lambdabot> 19, you?
15:56:06 <sinelaw> btw, there used to be a real vixey around here, what happened to her?
15:56:09 <skorpan> @vixen how old are you now?
15:56:09 <lambdabot> 19, you?
15:56:12 <skorpan> what the...
15:56:13 <blackdog> jlouis: she's not that old
15:56:14 <monochrom> I remember that someone had an existential crisis yesterday... his existential type code didn't typecheck and he couldn't figure out why. he then said "did you find types hard when you were newbie?"
15:56:22 <jlouis> I might add that several years ago, vixen was also 19...
15:56:42 <blackdog> jlouis: oh, sure, she should be honest about her age. that'd be realistic.
15:57:02 <jlouis> blackdog: it is more realistic her not being, I think
15:57:05 <sinelaw> jlouis, my mom was once 29 for about 10 years straight
15:57:07 <yitz> ,seen vixey
15:57:09 <lunabot>  luna: Not in scope: `seen'
15:57:10 <sinelaw> or even more
15:57:19 <yitz> preflex: seen vixey
15:57:21 <preflex>  vixey was last seen on ##javascript 35 days and 17 minutes ago, saying: that bit "new Ext.ux.Rating" kinda makes a difference
15:57:23 <blackdog> jlouis: am a bit sad I couldn't find the person who wrote the original VB script
15:57:43 <yitz> ##javascript??
15:57:44 <sinelaw> yitz, javascript???
15:57:58 <blackdog> they used to have a big collection of conversations people had had with her posted
15:58:51 <yitz> my mother-in-law says she's 16 going on 15 and a half
16:02:10 <monochrom> "I am sixteen, going on fifteen, stuck in a time machine..."
16:02:11 <jokerGTA> my godness i am getting to old for this:)
16:02:14 <Botje> @quote
16:02:14 <lambdabot> byorgey says: a bus error? try recompiling with -fsubway, perhaps
16:02:15 <Axman6> does she act it yitz?
16:02:29 <ivanm> heya Axman6
16:02:34 <skorpan> that would be hot
16:03:41 <blackdog> Axman6: give me back my line of code. this doesn't need to get ugly.
16:04:15 <Axman6> oh, i lost power and didn't have a backup, sorry :\
16:05:03 <jokerGTA>  :t sepBy
16:06:11 <ivanm> preflex: seen Baughn
16:06:11 <preflex>  Baughn was last seen on #haskell 4 hours, 16 minutes and 32 seconds ago, saying: shapr: If it wasn't for those meddling kids and their netsplit, I would've gotten away with it too!
16:06:37 <ivanm> @tell Baughn *sigh* I just managed to get the emacs devs in gentoo to package 2.5, and you go and release 2.6 on me?
16:06:38 <lambdabot> Consider it noted.
16:07:21 <yitz> Axman6: she's cute. but no, not really. :)
16:07:35 <Baughn> ivanm: It's all your fault, too. :P
16:07:36 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
16:07:39 <ivanm> Baughn: heh
16:07:47 <Axman6> yitz: good. women like that suck >_<
16:07:50 <Baughn> @clear
16:07:50 <lambdabot> Messages cleared.
16:07:54 <ivanm> Baughn: looks like Paczesiowa got confused about indent no longer being the default
16:08:02 <ivanm> http://www.reddit.com/r/haskell/comments/9zxkx/announce_haskellmode_26/
16:08:06 <luite> should it be possible to link C objects and dll files compiled with msvc with ghc?
16:08:15 <ivanm> Baughn: you mieght need to make it more obvious ;-)
16:08:55 <jokerGTA> seen kmc
16:09:40 <ivanm> Axman6: are you stealing blackdog's code again?
16:09:40 <yitz> preflex: seen kmc
16:09:41 <preflex>  kmc was last seen on #haskell 1 hour, 10 minutes and 53 seconds ago, saying: in what code?
16:10:04 <Baughn> ivanm: Eheh. Maybe I'll make the /new/ mode on by default.
16:10:16 <yitz> mauke: rename preflex to seenbot
16:10:36 <luite> is there a way to convert a .a to a .dll or .so (mingw)?
16:10:53 <ivanm> Baughn: if it's possible, have a dumb mode on default that when tabbing will pop up a message saying "please select an indentation mode" or soemthing?
16:10:59 <ivanm> yitz: heh
16:11:11 <ivanm> luite: recompile? *shrug*
16:11:11 <stoop> Any tools similar to http://cloc.sourceforge.net/#Overview that you know of? Maybe something with Haskell support?
16:11:15 <Baughn> luite: That should be doable. The other way around isn't.
16:11:20 <mauke> yitz: ew, no
16:11:23 <jokerGTA> if the parser return type is "Eighter Error or MyType" how do i get MyTYpe out
16:11:26 <ivanm> stoop: sloccount
16:11:26 <Baughn> luite: A .a is just a tarball of .o files, minus the tar
16:11:40 <ivanm> stoop: there's a comment counter on the (currently dead) hackage as well
16:11:43 <luite> ivanm: the configure script refuses to build shared libraries for mingw
16:11:49 <Baughn> luite: You can pass it to whatever you use to build a dynamic library, just like a .o
16:11:52 <ivanm> luite: no idea then ;-)
16:12:07 <Saizan> jokerGTA: pattern match on it
16:12:12 <Saizan> ?src Either
16:12:13 <lambdabot> Source not found. :(
16:12:14 <Baughn> ivanm: Heh. And what of the people who don't want one? ^^;
16:12:23 <Baughn> ivanm: It's pretty clearly spelled out in the readme, you know..
16:12:26 <ivanm> Baughn: bah ;-)
16:12:29 <luite> Baughn: hmm, I have no idea how to do that
16:12:38 <ivanm> Baughn: I think the problem is, most people don't expect it to have changed...
16:12:39 <stoop> ivanm, thanks!
16:12:41 <Saizan> > case Right 1 of Left () -> "foo"; Right x -> show x
16:12:42 <lambdabot>   "1"
16:12:43 <Baughn> luite: Mingw? Me neither.
16:12:50 <luite> but does that mean that if I extract all .o files from the .a, I can manually add all them to the ghci command line?
16:13:01 <ivanm> Baughn: if you made it 3.0, then it might have been a bit more obvious; especially if you said there wsa a change in the announce emails and on the website
16:13:16 <yitz> ivanm: in dumb mode, tab should just insert a tab and stay out of the way
16:13:20 <Baughn> ivanm: Fine, fine...
16:13:28 <ivanm> Baughn: heh
16:14:11 <dmwit> I say screw people.  Change things if there's a better way.
16:14:32 <Baughn> ivanm: There.
16:14:49 <ivanm> *groan* not another release?
16:14:50 <dmwit> > either (const "foo") show (Right 1)
16:14:51 <yitz> mauke: ok. quasiquotebot then.
16:14:52 <lambdabot>   "1"
16:15:01 <ivanm> dmwit: I'm OK with changing things, just make it obvious about the change
16:15:26 <sinelaw> woohoo, just "finished" my first haskell program. ask me how to pronounce anything.
16:16:02 <Baughn> ivanm: Sure, I've uploaded a new release.
16:16:04 <yitz> sinelaw: yay!
16:16:04 <Baughn> ivanm: Of the website.
16:16:05 <ivanm> sinelaw: pronounce "asldkfa;sldibherwser;balsdrh" ;-)
16:16:09 <ivanm> Baughn: *phew*
16:16:12 <jokerGTA> is there any other way then pattern matching since i am fairly new to haskell
16:16:16 <sinelaw> ivanm, it has to be an english word or common name
16:16:19 <jokerGTA> not that confortable with pattern matching
16:16:19 <ivanm> jokerGTA: to do what?
16:16:22 <Baughn> ivanm: Keeping it in darcs seems to be helping. :)
16:16:27 <ivanm> sinelaw: _now_ you place restrictions!
16:16:51 <sinelaw> R IY0 S T R IH1 K SH AH0 N Z
16:16:59 <Baughn> ivanm: Now, if people /still/ have trouble, there might be a new release with a first-run configuration wizard or something.
16:17:00 <luite> Baughn: would you happen to know the command to extract a .a file?
16:17:06 <Baughn> But geez, it's emacs. *Emacs*!
16:17:07 <kmc> ar
16:17:08 <dmwit> jokerGTA: Yes, but pattern-matching is the Right Way, and is not that hard to understand.
16:17:12 <sinelaw> :) that's using CMU's pronunciation notation. i think i need to add conversion of that to something more reasonable
16:17:15 <Baughn> luite: ar x
16:17:20 <luite> thanks
16:17:30 <ivanm> Baughn: heh, having it on the website, etc. should be enough IMHO
16:17:30 <dmwit> :t either -- jokerGTA: another way
16:17:32 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:17:36 <Baughn> luite: Er, you don't actually need to extract it, though
16:17:39 <luite> google didn't help much with ".a" because it seemed to strip the dot
16:17:43 <ivanm> Baughn: it's just that people have been used to having indent as the default for so long...
16:17:50 <sinelaw> ivanm,
16:17:52 <sinelaw> $ ./pronounce cmudict.0.7a.bin IVAN
16:17:52 <sinelaw> AY1 V AH0 N
16:17:54 <ivanm> sinelaw,
16:18:00 <ivanm> @slap sinelaw
16:18:00 * lambdabot pokes sinelaw in the eye
16:18:02 <ivanm> WRONG!
16:18:10 <ivanm> (dumb yanks and their stuffed up pronounciations)
16:18:20 <Baughn> ivanm: Now, then. SHould I add a blink tag?
16:18:21 <sinelaw> yeah i was surprised too
16:18:26 <ivanm> sinelaw: I bet your program prononounces Iraq as EYE-RACK as well...
16:18:27 <Baughn> ivanm: Server-side blink sounds fun
16:18:29 <sinelaw> i don't say it that way, i say EEE van
16:18:29 <ivanm> Baughn: heh
16:18:33 <luite> Baughn: I'm trying another workaournd first, compile with each object file separately instead of -lClp
16:18:34 <ivanm> Web 2.1! ;-)
16:18:42 <ivanm> sinelaw: you're spared this time :p
16:19:05 <dmwit> Baughn: http://cheese.blartwendo.com/web21-demo.html in case that wasn't a reference already
16:19:07 <sinelaw> ivanm, i happend to know a whole bunch of russians, so i couldn't be wrong. i even know how to say the soft 'L'
16:19:16 * ivanm isn't Russian...
16:19:26 <hamandine> when the CPU is waiting for RAM, is this counted as MUT?
16:19:31 <Baughn> dmwit: It was, but I'm sure others will be amused
16:19:31 <ivanm> dmwit: that's what I was getting at ;-)
16:19:41 <medfly> none of you can say Iraq correctly anyhow...
16:19:44 <sinelaw> ivanm, ok, but it's also a Russian name, and they would never say something like "Eye-van!"
16:19:54 <Axman6> medfly?
16:19:58 <dmwit> medfly: I find that unlikely.
16:20:06 <ivanm> medfly: i - raaaaq (kinda, no idea how to do that pronounciation spelling)
16:20:10 <ivanm> that's a short i
16:20:16 <ivanm> sinelaw: true
16:20:18 <dmwit> ee raak
16:20:20 <sinelaw> nope
16:20:22 <Axman6> i-rark
16:20:26 <medfly> it has an ayin in it. I don't know any non-Semitic languages that have it.
16:20:27 <sinelaw> the 'q' doesn't have an equivalent in english
16:20:28 <hamandine> medfly: 3iraak
16:20:34 <medfly> hamandine, :-)
16:20:40 <sinelaw> medfly, it's the 'q' that's more problematic
16:20:40 <ivanm> medfly: where is the ayin?
16:20:45 <jokerGTA> can you show me working example of that dmvit...can you?
16:20:54 <medfly> it's the first letter.
16:20:57 <hamandine> 
16:20:57 <dmwit> jokerGTA: See above.
16:21:01 <Baughn> ivanm: Oh well.. this is pretty easy. You have /no idea/ the amount of work I had to do to utterly foolproof my mother's guestbook. Meant for people with negative computer knowledge.
16:21:03 <ivanm> jokerGTA: what are you wanting to do?
16:21:05 <Warrigal> There are a bunch of pronunciation spellings.
16:21:11 <ivanm> Baughn: heh
16:21:13 <yitz> sinelaw: do dict<-readFile"/usr/share/dict/words"; let {ws = words dict}; n <- randomRIO(0,length ws - 1); return $ ws !! n
16:21:17 <Baughn> ivanm: Seriously, if it could be done wrong, they did it. Up to and including closing the browser to submit.
16:21:19 <ivanm> Baughn: there's an easy way: make it static! ;-)
16:21:27 <yitz> sinelaw: "shover"
16:21:30 <jokerGTA> well you have return type of eighter....i want to get my value out of there
16:21:31 <dmwit> > either (const "foo") show (Right 1)
16:21:32 <lambdabot>   "1"
16:21:41 * Warrigal looks up the pronunciation of "Iraq" on Wikipedia.
16:22:10 <yitz> Warrigal: Bush pronounces it like "a rack".
16:22:10 <sinelaw> yitz, $ ./pronounce cmudict.0.7a.bin SHOVER
16:22:10 <sinelaw> SH AH1 V ER0
16:22:20 <Baughn> ivanm: Oh and, er, about those gentoo devs...
16:22:27 <ivanm> yitz: so do a lot of other american media personalities AFAICT...
16:22:27 <medfly> [irq]
16:22:28 <yitz> sinelaw: "binary"
16:22:32 <Baughn> ivanm: 2.6.1 has some pretty nasty bugs re. to indentation.
16:22:39 <ivanm> Baughn: of what kind?
16:22:40 <sinelaw> B AY1 N ER0 IY0
16:22:41 <Warrigal> medfly: gracias.
16:22:52 <Baughn> ivanm: Pressing enter occasionally does not work.
16:23:00 <ivanm> medfly: wikipedia disagrees :p
16:23:10 <ivanm> Baughn: so indentation is still beta? ;-)
16:23:13 <yitz> "posnet" (huh?)
16:23:16 <sinelaw> cmu says: IH0 R AA1 K
16:23:41 <Warrigal> So a lot like the /rk/ that Wikipedia gives.
16:23:45 <medfly> The Arabic pronunciation is [irq]. In English, it is either /rk/ ... or /rk/ ... /ark/ is frequently heard in US media.
16:23:45 <Baughn> ivanm: Yeah. The solution I'm using has "hack" written all over it.
16:24:06 <ivanm> Baughn: heh
16:24:10 <medfly> I just thought it's funny to point out :)
16:24:12 <Baughn> ivanm: Though to be honest, it's likely to /remain/ in beta until haskell becomes so successful that there can be no more syntax extensions
16:24:27 <sinelaw> medfly, but there is no equivalent for neither the 'i', 'r' nor the 'q' in iraq
16:24:37 <ivanm> Baughn: heh
16:24:48 <Saizan> jokerGTA: pattern matching is pretty fundamental, you should read up on algebraic datatypes
16:24:56 <medfly> sinelaw, what do you mean?
16:25:04 <sinelaw> medfly, ...in english
16:25:18 <ivanm> Baughn: my elisp-fu is weak, so I don't know how difficult this might be: how about using indent if no indentation mode is defined?
16:25:24 <yitz> medfly: most colloquial dialects of arabic don't have q
16:25:55 <medfly> I just said it as a bit of a joke, because you were talking about "pronouncing it wrong" :)
16:26:05 <Baughn> ivanm: Perfectly doable. Just get 2.6 into gentoo, and I'll have 2.7 up in a day or two, eh?
16:26:09 <iaefai> Where can one get the latest haddock from darcs?
16:26:22 <Warrigal> Well, [i] is used in English; [i], not so much.
16:26:27 <medfly> /rk/ is fairly OK :-)
16:26:31 <ivanm> Baughn: heh, in that case I might not tell the emacs devs about 2.6 until you have 2.7 released ;-)
16:26:35 <Warrigal> People say [i], but not phonemically.
16:26:36 <Baughn> ivanm: Although if I were to do that, I'd default to indentation, not indent
16:26:38 <medfly> eye-rack sucks, though.
16:26:46 <yitz> iaefai: nowhere at the moment. hopefully, hackage will be up again momentarily.
16:26:47 <ivanm> Baughn: since indentation has the bugs...
16:26:51 <ivanm> and people are used to indent...
16:26:53 <iaefai> awesome
16:27:10 <Baughn> ivanm: The bugs aren't noticably in 2.6. They're still /there/, but the paint is working.
16:27:28 <ivanm> ahhh, good old camo paint? :p
16:27:46 <Baughn> Good old "handle error, run simpler code instead" paint. :P
16:27:59 <sinelaw> @hoogle [m a] -> m [a]
16:28:00 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
16:28:00 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
16:28:00 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
16:28:18 <yitz> iaefai: though i suspect it will be more like 15 or 16 hours from now, when people come in to work tomorrow morning on the US west coast.
16:28:30 <iaefai> heh
16:28:48 <Baughn> ivanm: Since you would've already known all this if you'd read the release announcement.. you've got your tab-cycle feature.
16:29:04 <ivanm> what announcement?
16:29:08 <Baughn> On haskell-cafe
16:29:13 * ivanm gets digest of haskell{,-cafe}...
16:29:14 <luite> bah I'm really fed up with this now... each time I try to link foreign code with haskell, on windows, I seem to have to spend weeks to get it to compile at all, only to discover loads of new problems when actually trying to use it :(
16:30:03 <Baughn> luite: Sadly, none of the core developers care much about windows, and the people who care about windows don't seem to care about haskell, so they don't help much
16:30:29 <Baughn> And by "sadly", I mean "I don't care, but empathize in a general manner"
16:30:35 <iaefai> Is there a way to tell cabal to use the files from the torrent downloaded when installing?
16:31:21 <Baughn> iaefai: Putting tarballs in the appropriate places in ~/.cabal/packages should work
16:31:34 <yitz> things on windows were a little better before ndm got a day job.
16:31:58 <Baughn> ivanm: http://www.haskell.org/pipermail/haskell-cafe/2009-November/068410.html
16:32:04 <ivanm> ta
16:32:34 <ivanm> Baughn: \o/
16:32:46 <ivanm> Baughn: OK, you've convinced me to try indentation again ;-)
16:33:28 <sinelaw> help, how do i end this main function? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11449#a11449
16:33:34 <sinelaw> keep getting type errors on last line
16:33:43 <sinelaw> pronounce.hs:23:2:
16:33:43 <sinelaw>     Couldn't match expected type `()' against inferred type `[()]'
16:33:43 <sinelaw>       Expected type: IO ()
16:33:43 <sinelaw>       Inferred type: IO [()]
16:33:47 <Baughn> sinelaw: Switch out sequence for sequence_
16:33:53 <Baughn> @type sequence_
16:33:54 <sinelaw> @type sequence_
16:33:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:33:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:33:56 <sinelaw> :)
16:34:20 <yitz> Baughn: my only problem with haskell mode has been that ^C-^O gets too global and makes a wreck of my program, so i never use it. is that improved now?
16:34:23 <Baughn> Or you could've appended 'return ()'
16:34:41 <sinelaw> Baughn, thanks. ok.
16:34:47 <ivanm> yitz: C-0? what's that?
16:34:48 <jokerGTA> kmc you there?
16:34:53 <yitz> otherwise
16:34:57 <Baughn> yitz: Um. What's that supposed to do? It's unbound here.
16:35:14 <Baughn> yitz: Oh.. not so much, no. I suppose that's from haskell-indent
16:35:16 <yitz> oh. am i using the same haskell-mode?
16:35:19 <ivanm> yitz: oh, C-o
16:35:29 <Baughn> You may be using different indentation modes. :P
16:35:37 <ivanm> to insert | otherwise =
16:35:38 <yitz> yeah C-c C-o. sorry.
16:36:05 <ivanm> even with a dot inside the 0 in my font, I still read O as 0 :s
16:36:27 <Baughn> yitz: ..anyway. No, I haven't fixed it, and i'm not likely to. I might reimplement it in haskell-indentation, but I've got higher-priority enhancements first.
16:36:46 <Baughn> yitz: Frankly, it's hard enough figuring out /one/ indentation mode. :/
16:36:57 <ivanm> Baughn: so yoiu're trying to eventually dump the other two?
16:36:58 <yitz> ok fair enough
16:37:37 <Baughn> ivanm: No reason to, but I'd like to at least eventually deprecate them
16:39:08 <Baughn> sinelaw: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11449#a11450 <-- Have a better one
16:39:59 <eliasvc> hello?
16:40:20 <sinelaw> cool, thanks.
16:40:22 <sinelaw> eliasvc, hi.
16:40:41 <Baughn> sinelaw: Oh. The \x thing? Make it pron x = ...
16:40:59 <iaefai> It appears that the packages dir does not take additions, it still tries to download if the thing exists there
16:41:02 <sinelaw> yes, right.
16:41:10 <Baughn> eliasvc: Welcome to our little corner of the universe. We're still recovering from the ircquake of '09, though.
16:41:53 <eliasvc> I have a question about type constraints
16:42:54 <Colours> hello I am having problems with running these bits of code, they compile fine but something does not appear to be linking correctly: http://pastebin.com/d28ab3fcb <- that is the code and http://pastebin.com/d250b43fe is the output of compiling and running the code
16:43:57 <eliasvc> if I declare a function like for example
16:44:10 <eliasvc> head' [] = []
16:44:13 <Colours> I am trying to use the hs-plugins package following the tutorial here http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-6.html (`)
16:44:40 <eliasvc> head' (x:_) = x
16:45:12 <monochrom> why are you returning x? it is usually a wrong type.
16:45:23 <mauke> head' :: [[a]] -> [a]
16:45:34 <monochrom> or perhaps why are you returning [] when you see head' [].
16:46:11 <monochrom> [] is not like Java's null. It does not stand for "no good answer".
16:46:24 <eliasvc> yeah that is exactly what i get when I type :t head' mauke
16:46:40 <mauke> eliasvc: ok, so do you have a question?
16:46:51 <eliasvc> I guess my question is:
16:46:54 <ivanm> eliasvc: head' [] = []; head' xs = head xs ?
16:47:15 <luite> Baughn: thanks for the tips (and the general empathy :p ), I have built the dlls now. (but now I'm back to the dreaded "Unknown PEi386 section name `/22' (while processing: Lp\lp.o)" error)
16:47:16 <ivanm> Colours: hs-plugins is dead
16:47:27 <Colours> w h a t
16:47:27 <ivanm> there's a new package called plugins now IIRC that duplicates the functionality
16:47:43 <eliasvc> what does the [[a]] -> [a] mean?
16:47:49 <Colours> oh
16:47:54 <ivanm> eliasvc: given a list of lists, it will return a list
16:47:56 <Zao> eliasvc: It's a function from a list of list of a to a list of a.
16:47:57 <eliasvc> especifically the [[a]]
16:48:02 <mauke> list of list of a
16:48:11 <Baughn> eliasvc: For any (type-)value of a
16:48:12 <Zao> @type [[42, 3], [5]]
16:48:14 <lambdabot> forall t. (Num t) => [[t]]
16:48:15 <ivanm> eliasvc: [[1,2], [3], []] :: [[Int]]
16:50:27 <sinelaw> @vixey say something that i may feed into my pronunciation program
16:50:28 <lambdabot> what's a program?
16:50:36 <eliasvc> but when I declare the first part as head' [] = error "some message" then I get head :: [a] -> a
16:50:41 <mauke> yes
16:50:50 <sinelaw> w-ah1-t-s ah0 p-r-ow1-g-r-ae2-m
16:50:53 <copumpkin> preflex: seen vixey
16:50:54 <preflex>  vixey was last seen on ##javascript 35 days, 1 hour, 10 minutes and 33 seconds ago, saying: that bit "new Ext.ux.Rating" kinda makes a difference
16:51:10 <Baughn> eliasvc: Remember, a can be /any/ type - including lists
16:51:14 <monochrom> error "blah" is what you should consider for "no good answer".
16:51:15 <mauke> eliasvc: [[a]] -> [a] is a specialization of [a] -> a
16:51:31 <mauke> maybe I should use different variables there
16:51:31 <monochrom> :type error "message"
16:51:36 <monochrom> @type error "message"
16:51:38 <lambdabot> forall a. a
16:51:47 <mauke> [[c]] -> [c] is a specialization of [b] -> b (with b = [c])
16:51:48 <Axman6> > error "message"
16:51:49 <monochrom> It is polymorphic.
16:51:49 <lambdabot>   * Exception: message
16:51:51 <sinelaw> monochrom, m-ey1-b-iy0 ay1 sh-uh1-d y-uw1-s d-ih1-f-er0-ah0-n-t v-eh1-r-iy0-ah0-b-ah0-l-z dh-eh1-r
16:52:15 <Baughn> @unelite  m-ey1-b-iy0 ay1 sh-uh1-d y-uw1-s                  d-ih1-f-er0-ah0-n-t v-eh1-r-iy0-ah0-b-ah0-l-z dh-eh1-r
16:52:15 <lambdabot> M-3y1-b-IY0 aY1 sH-Uh1-D y-uw1-5 D-iH1-ph-eR0-4H0-n-t v-Eh1-R-IY0-ah0-8-4h0-|-s dH-eh1-R
16:52:34 <Baughn> ..that did not help.
16:52:47 <ivanm> heh
16:52:50 <sinelaw> i need to add a part that converts cmu pronunciation syntax to something more readable
16:52:58 <sinelaw> that still retains the phonetic information
16:53:02 <mauke> yeah, something like ... english!
16:53:04 <eliasvc> ooh now I get it
16:53:12 <monochrom> "may be I should use different variables there"
16:53:20 <eliasvc> thank you very much guys
16:53:50 <sinelaw> monochrom, i meant to aim it at mauke :)
16:54:03 <mauke> sinelaw: 'twas brillig and the slithy toves did gyre and gimble in the wabe.
16:54:04 <lpjhjdh> so does anyone know if splicing types is working in 6.12 rc1?
16:54:51 * Cale wonders about what's left before the 6.12 release
16:55:02 <sinelaw> mauke, it didn't recognize brillig, slithy, toves, gyre, gimble and wabe.
16:55:05 <sinelaw> so no use :)
16:55:06 * Cale goes to look at the GHC trac
16:55:13 <sinelaw> it's an american dictionary i think
16:55:18 <mauke> sinelaw: mature nature
16:55:20 <ivanm> Cale: time
16:55:21 <ivanm> ;-)
16:55:27 <Baughn> sinelaw: I doubt you'd find those in an english one
16:55:29 <Cale> ivanm: just time?
16:55:33 <sinelaw> m-ah0-ch-uh1-r n-ey1-ch-er0
16:55:33 <Baughn> sinelaw: Mature manure in nature
16:55:41 <ivanm> well, there's time before the full release... ;-)
16:55:50 <ivanm> there's probably a reason for that time being there though...
16:56:08 <mauke> all mimsy were the borogoves and the mome raths outgrabe
16:56:33 <sinelaw> sh-iy1 s-eh1-l-z s-iy1 sh-eh1-l-z aa1-n dh-ah0 s-iy1 sh-ao1-r
16:56:40 <Baughn> mauke: ..you're giving me flashbacks to McGee's Alice
16:57:08 <sinelaw> mauke, where're those gems from?
16:57:21 <sinelaw> (yes, i just invented "where're")
16:57:26 <mauke> T J
16:57:29 <Baughn> sinelaw: No, did not..
16:57:33 <Baughn> ack
16:57:34 <monochrom> sixteen sick teens
16:57:39 <Baughn> He named it!
16:58:05 <sinelaw> s-ih0-k-s-t-iy1-n s-ih1-k t-iy1-n-z
16:58:13 <sinelaw> you can see that it's almost a repetition of phonetic movements
16:58:46 <sinelaw> maybe i can find this db to make up new hard-to-pronounce sentences
16:58:56 <sinelaw> s/find/use/
16:59:06 <sinelaw> automagically, of course.
16:59:15 <Baughn> mauke: Dare you hunt a snark, knowing it may be a boojum?
16:59:33 <luite> isn't it possible to have GHC evaluate TH code using a real, compiled, version of the program, instead of the bytecode interpreter?
16:59:35 <mauke> not familiar with the hunting of the snark, sorry
16:59:47 <sinelaw> haha
17:03:39 <sinelaw> i found proof that the Sun, Moon and stars were created in Haskell, it's in "Eil Addon" from the Jewish prayer on Sabbath morning, and it goes thus: "...he has created them in knowledge, intelligence, and Haskell!"
17:04:32 <mightybyte> @pl arr . const
17:04:32 <lambdabot> arr . const
17:05:31 <Baughn> @pl \a b c -> c
17:05:32 <lambdabot> const (const id)
17:05:38 <Baughn> @pl \a b c -> b
17:05:39 <lambdabot> const const
17:06:13 <mauke> @unpl const (flip const)
17:06:13 <lambdabot> (\ _ c d -> d)
17:06:21 <mauke> haha, what
17:06:31 <Axman6> o.O
17:06:33 <mauke> why is the c not _?
17:06:44 <Vanadium> Where is a and b? :<
17:07:10 <Peaker> @unpl const id
17:07:10 <Axman6> @remember mauke "@unpl const (flip const)" lambdabot: (\ _ c d -> d)
17:07:10 <lambdabot> Done.
17:07:11 <lambdabot> (\ _ b -> b)
17:07:26 <Peaker> mauke, seems like a special case for const that's lost when (flip const) is used
17:08:24 <Baughn> @unpl const const const const
17:08:24 <lambdabot> (\ _ d _ -> d)
17:08:44 <Baughn> @unpl const const const const const
17:08:44 <lambdabot> (\ d _ -> d)
17:08:47 <Baughn> @unpl const const const const const const
17:08:48 <lambdabot> (\ _ f _ -> f)
17:08:52 <Baughn> @unpl const const const const const const const
17:08:53 <lambdabot> (\ f _ -> f)
17:09:00 <Baughn> @unpl const const const const const const const const -- Hm. I see a pattern now.
17:09:00 <lambdabot> (\ _ h _ -> h)
17:09:10 <Peaker> @unpl flip const
17:09:11 <lambdabot> (\ b c -> c)
17:09:18 <Peaker> there goes the _
17:10:07 <Baughn> @unpl id const id const
17:10:08 <lambdabot> (\ c -> c)
17:10:12 <mauke> @let buffalo = const
17:10:13 <lambdabot>  Defined.
17:10:34 <Baughn> @unpl buffalo buffalo
17:10:34 <lambdabot> buffalo buffalo
17:10:44 <HaudRex> @let nil = const
17:10:45 <lambdabot>  Defined.
17:10:57 <Peaker> when will Hackage be up?
17:11:05 <HaudRex> @let cons h t = \n c -> c h (t n c)
17:11:07 <lambdabot>  Defined.
17:11:13 <Baughn> Peaker: Once they've slain the grue, I'd guess
17:11:23 <HaudRex> @let car xs = xs undefined (\h t -> h)
17:11:24 <lambdabot>  Defined.
17:11:45 <mauke> @unpl fmap fix return
17:11:46 <lambdabot> fmap fix return
17:11:56 <HaudRex> @let cdr xs = fst (xs (nil, nil) (\x p -> (snd p, cons x (snd p))))
17:11:58 <lambdabot>  Defined.
17:12:29 <Peaker> Baughn, the what? :)
17:12:46 <HaudRex> > car (cdr (cons 1 (cons 2 (cons 3 nil))))
17:12:47 <lambdabot>   2
17:13:20 <Baughn> Peaker: It's always dark.. inside the computers
17:13:22 <HaudRex> > (cdr (cons 1 (cons 2 (cons 3 nil)))) 0 (+)
17:13:24 <lambdabot>   5
17:13:52 <impl> lisp? in my haskell? it's more likely than you think.
17:14:18 <mauke> looks more like lambda calculus/church encoding
17:15:00 <gnut> Do we have to recompile ghc from source if we want to use "ghc -shared" ? or will the Linux binaries (64-bit) on the ghc page work?
17:15:02 <HaudRex> mauke: Is there a difference? :)
17:16:12 <luite> how could I compile this so that I can load the .o in ghci? (linux this time) http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11451#a11451
17:16:12 <ivanm> gnut: I think you need to compile it yourself
17:16:18 <gnut> ok
17:16:36 <Baughn> gnut: While 6.12 isn't actually /out/ yet, last I checked it's compiled with shared library support by default
17:16:53 <gnut> ahhh  ok
17:17:06 <ivanm> Baughn: it is? even on *nix? :o
17:17:18 * ivanm thought static linking was going to be the default for a while yet...
17:17:37 <Baughn> luite: You'd need a .hs file with the appropriate foreign import lines, and link it with that
17:17:41 <Baughn> ivanm: Especially on *nix
17:17:49 <luite> Baughn: yes I know, but the problem is that it's C++
17:18:10 <Baughn> luite: Anything wrapped in extern "C" should be perfectly importable
17:18:18 <gnut> that's what I thought. I just wasn't sure.
17:18:21 <Baughn> ivanm: Static linking /is/ the default, but ghc is linked with shared library support too
17:18:32 <gnut> I've been struggling trying to recompile ghc, but I guess I'll keep trying.
17:18:41 <ivanm> wait, do shared libraries mean the same as dynamic linking?
17:18:43 <luite> Baughn: ok, I'll try to make a complete example and see if it works
17:18:52 <Baughn> ivanm: Well, you can't have the one without the other
17:19:28 <gnut> you can have statically linked shared objects and dynamically linked, no?
17:19:33 <Baughn> gnut: For 6.12rc1, you shouldn't need to do anything more than ./configure;make;make install
17:19:49 <gnut> Baughn: okay. is 6.12rc1 on the page already?
17:19:51 <gnut> let me check
17:19:59 <Baughn> gnut: ..well, you can statically link other libraries into a shared library, but you can't statically link /to/ a shared library
17:20:04 <ivanm> Baughn: OK, what are shared libraries then?
17:20:16 <gnut> Baughn: yeah.. okay.
17:20:31 <gnut> Baughn: that's right.
17:20:40 <Baughn> ivanm: Relocatable ELF files (hopefully with PIC), that can be loaded at runtime
17:21:01 <ivanm> OK, so what does that mean for static linking if it's still the default?
17:21:21 <Baughn> ivanm: GHC builds static archives (.a) /and/ shared libraries (.so)
17:21:35 <Baughn> ivanm: It installs both. Then, when you actually compile your own haskell code, you choose which to link with.
17:21:51 <ivanm> oh, I thought dynamic linking was an all-or-nothing affair
17:21:56 <Baughn> It is
17:21:59 <gnut> which one is 6.12rc1? is it the ones on the download page listed as 6.13?
17:22:00 <Baughn> It just compiles itself twice
17:22:03 <ivanm> as in with regards to ghc
17:22:15 <Baughn> It's the same thing as with profiling, really
17:22:16 <ivanm> either ghc did static or dynamic, you couldn't mix nad match
17:22:32 <Baughn> A given /executable/ can't
17:22:45 <Baughn> But GHC can certainly install multiple copies of its libraries
17:22:56 <Baughn> It's just that you can only use one of the four sets at a time
17:23:01 <ivanm> gnut: the development snapshots here? http://www.haskell.org/ghc/download.html
17:23:24 <gnut> ivanm: yeah. I'm on that page.
17:23:30 <gnut> I see 6.11 and 6.13
17:23:33 <ivanm> Baughn: OK, I was under the impression that if you built GHC with dynamic support, everything is dynamic; otherwise, everything is static
17:23:35 <gnut> I'm guessing I want 6.133
17:23:38 <ivanm> gnut: 6.11
17:23:39 <Baughn> gnut: In my experience, only 6.12rc1 actually compiles. :P
17:23:42 <luite> Baughn: nope does not work
17:23:46 <ivanm> 6.13 is the one _after_ 6.12 ;-)
17:24:00 <ivanm> gnut:
17:24:01 <ivanm> http://www.haskell.org/ghc/dist/stable/dist/
17:24:06 <ivanm> ^^ the dated versions
17:24:16 <gnut> ah. okay
17:24:22 <gnut> i was looking at the HEAD branch
17:24:29 <gnut> let me get 6.12 then ... thanks :)
17:25:25 <Baughn> ivanm: The way cabal has been rewritten, it's like this..
17:25:41 <Baughn> ivanm: Enable shared, and you get static /and/ shared libraries. Disable it, and you only get static.
17:25:53 <jokerGTA> i have MyType for which I wrote custom show function......in order to do that i made this type an instance of Show class and that way i could have used my function for printing
17:25:59 <Baughn> ivanm: Then, once you actually compile an /executable/, you decide which libraries to link to
17:26:01 <jokerGTA> something like this
17:26:12 <mpiechotka> Is there any mirror of hackage
17:26:15 <mpiechotka> ?
17:26:30 <jokerGTA> instance Show MyType where     show = printMyType
17:26:38 <luite> Baughn: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11452#a11452
17:26:49 <Cale> Heh, I noticed that my tab with the GHC trac hadn't loaded, and then realised that was on hackage.haskell.org too.
17:27:02 <Cale> We really need some weekend administrators for that machine.
17:27:16 <Cale> The people at Galois go home and their machines die ;P
17:27:35 <Baughn> luite: Could you try compiling it instead of loading in ghci?
17:27:42 <luite> Baughn: yes that works fine
17:27:50 <luite> Baughn: but I need to be able to ghci it
17:27:52 <jokerGTA> Now i need to change that into instance of ParsecRead ..i tried like this instance ParsecRead MyType where     show = printMyType
17:28:04 <jokerGTA> but that obviosly is wrong since i got bunch of errors
17:28:13 <Cale> Watch it turn out to be some janitor unplugging the cable to run the vacuum ;)
17:28:23 <luite> Baughn: because ghc uses ghci to evaluate template haskell
17:28:41 <Baughn> luite: It seems to be due to some baroque libstdc++ linker script thing
17:28:56 <Baughn> luite: I find bug reports all the way back to 2002
17:30:01 <gnut> hope this works. starting long compile jobo
17:30:03 <Baughn> luite: Say, are you on OS X?
17:30:25 <luite> Baughn: linux
17:30:29 <ivanm> Baughn: ahhh, OK, that makes sense then
17:30:51 <Baughn> luite: Well.. I don't know. Ask haskell-cafe?
17:31:53 <Peaker> Baughn, haskell-mode has haskell-indent, haskell-indentation, simple-indent, which should I enable?
17:32:07 <Baughn> Peaker: haskell-indentation
17:32:12 <Peaker> Baughn, thanks
17:32:32 <ivanm> Peaker: indent is old-style, indentation is the new name for kuribas' mode
17:34:07 <Peaker> its still a little dumb
17:34:21 <Baughn> It's got issues. It's still by far the nicest one. :)
17:34:31 <Peaker> x = [1,2,3] <enter>  continues after the =
17:34:49 <Peaker> I might want to apply [1,2,3] as a function, but its unlikely because I could have done that on the same line, I wouldn't newline
17:34:51 <ivanm> Peaker: :o
17:34:56 <ben_m> It is amazing, compared to what Vim has :/
17:35:45 <Baughn> Peaker: I don't see that. In what context?
17:35:47 <luite> Baughn: I've asked in #ghc, if I can't find a solution I'll post in haskell-cafe
17:35:58 <Peaker> Baughn, top-level
17:36:15 <luite> hopefully there are more people using linux :)
17:36:41 <Baughn> Peaker: Pressing enter defaults to the same indentation as the x started at. It does generate one at the level of the [, admittedly
17:36:45 <Baughn> Peaker: Is that what you mean?
17:36:53 <Peaker> Baughn, yeah
17:37:07 <Baughn> Peaker: And what would you prefer instead?
17:37:07 <Peaker> Baughn, I usually want newline to go lefter than continuing current expression
17:37:18 <Peaker> Baughn, if I wanted to continue current expression I wouldn't have newline'd
17:37:37 <Baughn> It doesn't continue the same expression, though..
17:37:44 <Peaker> Baughn, perhaps there should be a different key for "newline due to line-wrap" and "exit current scope" which newlines and unindents
17:37:57 <Peaker> Baughn, Why? after the ] or at the indent level of [ are same no?
17:38:28 <Baughn> Peaker: If I've got 'x = [1,2,3]', then press enter, the point ends up on column 0 directly underneath the x
17:38:57 <Baughn> Peaker: Oh, but that's a good idea. I could implement a newline-and-unindent pretty easily.
17:39:08 <Peaker> Baughn, underneath '[' here
17:39:57 <Peaker> Baughn, I misinterpreted what you said above, I didn't mean there is an indent level under [, I meant its the one I get when pressing enter
17:41:21 <Baughn> Peaker: Hm. Are we running the same haskell-mode? Version 2.6 or 2.7?
17:41:48 <Baughn> Peaker: What does M-x haskell-version say?
17:41:55 <Peaker> I installed the one from darcs
17:42:14 <Peaker> $Name:  $ (screwy result, probably darcs)
17:42:27 <Baughn> Yeah, that's darcs.
17:42:39 <Baughn> Peaker: And you're using haskell-indentation, not haskell-indent?
17:42:44 <luite> Baughn: a similar problem was posted last month: http://www.haskell.org/pipermail/glasgow-haskell-users/2009-September/017746.html
17:42:44 <Peaker> afaik, yea
17:43:03 <luite> this is the error you get when you don't have -lstd++ on the command line
17:43:05 <Peaker> Baughn, the minor mode in the mode line is presented as "Ind"
17:43:13 <Baughn> Peaker: They all are. :/
17:43:32 <Baughn> Peaker: Try pressing tab a few times. If it pases once at the rightmost level, printing a warning, before going to the leftmost one, then it's haskell-indentation
17:43:35 <Peaker> Baughn, in the customize-group of haskell I unchecked "haskell-indent" and checked "haskell-indentation"
17:43:50 <jokerGTA> read::(Read a) => String -> a
17:43:58 <dibblego> @hoogle (a -> m Bool) -> [a] -> m ()
17:43:59 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:43:59 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:43:59 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
17:44:03 <jokerGTA> does this mean this type takes String as parametar?
17:44:10 <gnut> is hackage down?
17:44:15 <jokerGTA>  :t read
17:44:25 <Baughn> jokerGTA: Yes.
17:44:27 <Peaker> Baughn, the hook list of enter-haskell-mode I removed turn-on-haskell-indent and put turn-on-haskell-indentation, more precisely
17:44:31 <gnut> I can't seem to connect. My ghc compile errored out saying I needed hscolour
17:44:31 <ivanm> gnut: yes
17:44:41 <ivanm> gnut: there's a torrent available from mauke if you need something
17:44:44 <gnut> ivanm: thanks.
17:44:45 <Baughn> Peaker: Well, could you try the experiment I suggested?
17:44:54 <jokerGTA> it doesnt allow me to try this function on comand line for some reason
17:44:57 <ivanm> gnut: reddit.com/r/haskell has a link to it
17:45:02 <Peaker> Baughn, the warning is "Press TAB again..."?
17:45:06 <gnut> thanks. I'll look it up.
17:45:21 <gnut> can we build ghc without hscolour?
17:45:42 <jokerGTA>  :t Int
17:45:42 <Baughn> Peaker: ..yeah.
17:45:44 <Baughn> Peaker: Very odd.
17:45:48 <jokerGTA>  :t Int
17:45:51 <Peaker> Baughn, I don't get the problem in a "do" block btw
17:46:06 <ivanm> gnut: yes, probably
17:46:12 <Peaker> I don't get it in a let, either
17:46:14 <Peaker> just top-level
17:46:21 <Baughn> Peaker: I just don't get it, period
17:47:27 <roconnor> nix is great.
17:47:44 <roconnor> hackage is down, but I was able to "prefetch" my hackage package from the mirror
17:47:47 <blackdog> is there any clever way to get ghci to recognise c2hs files the way cabal does?
17:47:51 <roconnor> and that was enough for the build to proceed
17:47:53 <Peaker> Baughn, http://paste2.org/p/494590 try adding a top-level  x = [1,2,3] at the end of that
17:48:16 <ivanm> hey roconnor
17:48:28 <ivanm> did you happen to look through that module I sent you?
17:48:34 <ivanm> blackdog: I doubt it
17:48:39 <roconnor> ivanm: ya I did
17:48:41 <ivanm> since it needs pre-processing
17:49:08 <blackdog> ivanm: yeah, i suppose so. pity we can't write these things as source filters the way the lisp guys do
17:49:26 <ivanm> roconnor: waddaya think?
17:49:32 <ivanm> blackdog: yeah
17:49:46 <roconnor> ivanm: One concern I have is that the X11 colours don't reference a particular colour coordinate system.
17:50:02 <blackdog> I suppose if you were willing to let TH do IO, you might be able to finagle something
17:50:04 <Baughn> Peaker: Nope, works fine
17:50:06 <roconnor> ivanm: so the X11 colours seems like they are device dependent
17:50:13 <ivanm> roconnor: AFAIK they are
17:50:17 <roconnor> ivanm: which makes me hesitate including them in my distribution.
17:50:17 <Baughn> Peaker: Maybe you've got some odd haskell-indentation customize-group settings?
17:50:25 <ivanm> roconnor: *nod*
17:50:26 <roconnor> ivanm: I mean sRGB is the obvious interpretation
17:50:26 <Baughn> Peaker: Try cleaning them out of .emacs?
17:50:55 <roconnor> ivanm: prehaps we can keep it in a separate package for the time being.
17:51:03 <ivanm> OK
17:51:04 <drhodes> can cabal install from a local directory?
17:51:13 <luite> has anyone here succeeded in loading an object that uses c++ in ghci? (and can point me to a working example)?
17:51:14 <ivanm> drhodes: as in an unpacked package?
17:51:18 <ivanm> or a local mirror?
17:51:22 <drhodes> local mirror
17:51:26 <Peaker> Baughn, its clean. I guess this is already good enough/better than what it was before
17:51:36 <ivanm> roconnor: well, I have sRGB conversion one way...
17:51:48 <ivanm> drhodes: put the packages you need into ~/.cabal/packages or something like that
17:51:54 <roconnor> ivanm: one way?
17:52:00 <drhodes> oh, ok - thanks ivanm
17:52:11 <ivanm> roconnor: X11 -> sRGB
17:52:25 <roconnor> ya
17:52:25 <Baughn> Peaker: Try moving point to the end of that x =-line, then say M-: (haskell-indentation-find-indentations)
17:52:26 <ivanm> since there's no obvious way of guaranteeing sRGB -> X11
17:52:34 <Baughn> Peaker: It should return (0 4)
17:52:53 <roconnor> ivanm: but I mean that one could also interpet the X11 colour coordinate in different colour spaces
17:53:04 <roconnor> ivanm: in particular with different "gamma" values
17:53:15 <ivanm> not sure I'm following you... never did much with colours ;-)
17:53:18 <roconnor> ivanm: like the ones used in SGI Octanes or whatnot
17:53:34 <roconnor> ivanm: ya, it is all technical colour mumbo jumbo
17:53:41 <ivanm> roconnor: well, the sRGB conversions I used are apparently the "standard" ones...
17:53:52 <roconnor> ivanm: remember how pictures used to look different on PCs and Macs (and SGI Ocatnes)?
17:53:57 <dibblego> @hoogle takeWhileM
17:53:58 <lambdabot> No results found
17:54:05 <ivanm> roconnor: no ;-)
17:54:12 <ivanm> never used an SGI Octane for starters :p
17:54:21 <roconnor> ivanm: true, but this sRGB standard postates the X11 colours
17:54:35 <ivanm> you mean "postdates"?
17:54:44 <ivanm> roconnor: so does sRGB == "normal" RGB values ?
17:54:45 <roconnor> ya postdates
17:55:08 <Peaker> Baughn, its what it says, it tabs through them correctly. It just defaults to start with 4 rather than 0
17:55:14 <Peaker> Baughn, maybe that's a darcs thing now?
17:55:15 <roconnor> ivanm: eventually the graphics world standardized an interpretation of what colours RGB triples refer to.
17:55:22 <Peaker> Baughn, (maybe it wasn't in the release?)
17:55:35 <roconnor> ivanm: about 10 - 15 years ago.
17:55:50 <copumpkin> blackh: I was just rereading your arrow tutorial, and noticed that your Circuit definition is exactly a Mealy machine
17:55:54 <ivanm> in terms of what "Red = 15" actually meant, etc.?
17:56:08 <luite> hmm, apparently it's basically impossible to load anything that uses C++ in ghci
17:56:10 <dibblego> is there a takeWhileM on hackage when it is up?
17:56:19 <blackh> copumpkin: Cool!  I think I remember reading about those at some point.
17:56:19 <copumpkin> dibblego: not that I know of
17:56:24 <roconnor> ivanm: maybe you can point me to some recent X11 documentation that says that these colours coordinates officially mean sRGB coordinates
17:56:41 <ivanm> dibblego: try using hayoo to find out?
17:56:55 <roconnor> ivanm: ya, the coordinates don't vary linearly in output intensity.
17:56:57 <copumpkin> blackh: here's some code that edwardk wrote a few months ago relating moore/mealy with folds and lots of instances: http://comonad.com/haskell/Origami.hs
17:57:32 <ivanm> roconnor: http://cvsweb.xfree86.org/cvsweb/xc/programs/rgb/rgb.txt?rev=1.2&content-type=text/vnd.viewcvs-markup
17:57:34 <roconnor> ivanm: it used to be that different computers varied non-linearly in various different ways.
17:57:49 <ivanm> note that I'm using hex values as that's what I copy/pasted from emacs's display...
17:59:12 <ivanm> roconnor: though here, I have the duplicate names as well in my /usr/share/X11/rgb.txt
17:59:36 <Peaker> Baughn, anyway, thanks, this is good stuff anyway :)
18:00:32 <blackh> copumpkin: Reading - thanks.
18:00:56 <copumpkin> blackh: thank you, it's a good tutorial, finally got around to rereading it :)
18:01:36 <blackh> copumpkin: Thanks for the nice comments. Writing it certainly helped me, and I am pretty sure it fills a gap.
18:02:44 <roconnor> ivanm: ya, I see no evidence that these refer to sRGB colours.
18:02:54 <roconnor> though that is the natural interpretation.
18:03:02 <ivanm> yeah
18:03:05 <roconnor> ivanm: maybe I'm being too stingy
18:03:08 <ivanm> heh
18:03:20 <ivanm> roconnor: look, I agree that it doesn't exactly fit in with the rest of your package
18:03:39 <ivanm> roconnor: so I'm more than happy to use a separate package for this
18:03:50 <ivanm> (since I need these, and other people might want them as well)
18:04:00 <roconnor> ivanm: ya, let's make it an external package for the time being
18:04:15 <ivanm> good-o
18:04:44 <copumpkin> you know what a really cool impure function is? nmergeio
18:04:51 <copumpkin> @hoogle nmergeio
18:04:51 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
18:05:01 <ivanm> what does it do?
18:05:40 <copumpkin> it's like an unsafely interleaved concat
18:05:48 <copumpkin> whatever is done sooner appears first in the list
18:05:56 <copumpkin> mergeIO :: [a] -> [a] -> IO [a]	
18:05:59 <dibblego> I am really looking for a loop: (a -> m Bool) -> (a -> m ()) -> [a] -> m ()
18:06:02 <copumpkin> that's the simpler version
18:06:19 <RyanT5000> so, is there any way to use that hackage torrent non-annoyingly?
18:06:19 <lambdabot> RyanT5000: You have 1 new message. '/msg lambdabot @messages' to read it.
18:06:27 <copumpkin> omg it's RyanT5000
18:06:34 <Peaker> dibblego, why the extra (a -> m ())? Why doesn't the m Bool contain the effect too?
18:06:37 <copumpkin> (no I don't think so)
18:06:40 <yousoboil> Hello, I am tryint to write to a normal usb drive (non encrypted) from a encrypted hidden system truecrypt volume, it makes the USB drive mount read only. How can I make truecrypt make volumes not read only, but so i am able to backup some data?
18:06:41 <RyanT5000> yo copumpkin, how's it going
18:06:51 <ivanm> copumpkin: so order isn't kept?
18:06:55 <copumpkin> yousoboil: what channel are you in?
18:07:00 <ivanm> dibblego: while?
18:07:00 <dibblego> Peaker, if the Bool is False, then stop running the loop and therefore, the given action
18:07:14 <ivanm> RyanT5000: define "non-annoyingly"?
18:07:18 <copumpkin> ivanm: nope, whatever completes first appears first in the list, so if you have several slow computations it's a nice way of spitting stuff out as it finishes
18:07:20 <dibblego> @hoogle while
18:07:21 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
18:07:21 <lambdabot> Data.ByteString dropWhile :: (Word8 -> Bool) -> ByteString -> ByteString
18:07:21 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
18:07:29 <sjanssen> yousoboil: you're in #haskell, which is for discussion about the Haskell programming language.  You might want to try one of the Linux related channels instead?
18:07:36 <RyanT5000> ivanm: without having to manually chase dependency graphs
18:07:38 <ivanm> copumpkin: hmmm, it could be useful...
18:07:51 <Peaker> dibblego, well, you could merge the predicate with the action, at least conditionally
18:07:51 <ivanm> RyanT5000: probably not
18:07:55 <copumpkin> ivanm: yeah, I really like the idea of it, although I've never found a use for it because I don't usually make interactive programs
18:08:12 <ivanm> I wonder if you can change remote-repo and remote-repo-cache for cabal-install...
18:08:27 <ivanm> @hoogle whileM
18:08:27 <lambdabot> No results found
18:08:34 <Peaker> @type \pred act -> pred >>= (`when` act)
18:08:36 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
18:08:51 * ivanm thought there was a "while" function...
18:09:11 <dibblego> Peaker, I suppose
18:09:15 <RyanT5000> ivanm: i was hoping there would be some way of telling cabal-install to look at my local disk instead of at http://hackage.haskell.org/
18:09:16 <Peaker> @type \pred act -> pred >>= \p -> (p `when` act) >> return p
18:09:17 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m Bool
18:09:27 <ivanm> RyanT5000: ivanm> I wonder if you can change remote-repo and remote-repo-cache for cabal-install...
18:09:38 <ivanm> ;-)
18:09:42 <copumpkin> dibblego: so your function would consume elements of the list until some condition is met, and perform actions for each of them too?
18:09:45 <Peaker> dibblego, then you can have:  (a -> m Bool) -> [a] -> m ()
18:09:45 <RyanT5000> ah, didn't see that
18:09:49 <dibblego> copumpkin, yes
18:09:52 <ivanm> RyanT5000: ;-)
18:10:05 <roconnor> ahh, I'm in cabal dependency hell!
18:10:15 <RyanT5000> roconnor: you're not alone :P
18:10:41 <ivanm> roconnor: heh
18:11:02 <rasfar> yep, mirrors would be handy at times like this.
18:11:02 <RyanT5000> ah, dang
18:11:07 <RyanT5000> cabal-install can't bootstrap
18:11:21 <roconnor> only the latest hackage packages are in the torrent mirror
18:11:30 <roconnor> which isn't enough to satisfy all dependencies
18:11:43 <yousoboil> this is the right channel for this question
18:11:46 <ivanm> RyanT5000: because it tries to download?
18:11:51 <ivanm> yousoboil: is it? why?
18:11:52 <Peaker> dibblego, I had a whileM :: Monad m => (a -> Bool) -> m a -> m [a]
18:11:55 <RyanT5000> roconnor: ah, that's even worse than my problem
18:11:58 <ivanm> we're about programming, not about USBs...
18:11:59 <RyanT5000> ivanm: yeah
18:12:04 <dibblego> Peaker, how about whileM_ ?
18:12:06 <ivanm> RyanT5000: edit the bootstrap script?
18:12:15 <yousoboil> fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu
18:12:16 <ivanm> dibblego: so it has return () ?
18:12:23 <dibblego> yes
18:12:26 <Peaker> dibblego, well, your predicate is monadic and mine is pure
18:12:35 <RyanT5000> ivanm: i'm just going to do all the dependency chasing myself :P
18:12:36 <dibblego> ah yeah
18:12:40 <Peaker> dibblego, what's your predicate? do you really need a monadic one?
18:12:48 <dibblego> yes
18:12:55 <dibblego> doesFileExist
18:13:00 <ivanm> RyanT5000: heh
18:13:21 <ivanm> dibblego: is this for mkTemp ?
18:13:26 <aavogt> @type \p -> sequence . until p
18:13:27 <lambdabot>     Couldn't match expected type `[m a]'
18:13:27 <dibblego> no
18:13:27 <lambdabot>            against inferred type `a1 -> a1'
18:13:27 <lambdabot>     Probable cause: `until' is applied to too few arguments
18:13:39 <aavogt> @type until
18:13:41 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
18:13:59 <aavogt> @type \p f -> sequence . until p f
18:14:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => ([m a] -> Bool) -> ([m a] -> [m a]) -> [m a] -> m [a]
18:14:09 <Peaker> @hoogle takeWhileM
18:14:10 <lambdabot> No results found
18:14:28 <aavogt> hmm, that's not right
18:14:50 <franksh> what's this about a hackage torrent? is there a backup repo online somewhere? and/or a page/blog/twitter/whatever i can watch for news on when hackage.haskell.org is coming back?
18:15:23 <ivanm> franksh: http://www.haskell.org/pipermail/haskell-cafe/2009-November/068398.html
18:15:49 <dibblego> @type let loop_ p a [] = return (); loop_ p a (x:xs) = p x >>= flip when (a >> loop_ p a xs) in loop_
18:15:50 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t -> m Bool) -> m a -> [t] -> m ()
18:16:16 <dibblego> @type let loop_ p a [] = return (); loop_ p a (x:xs) = p x >>= flip when (a x >> loop_ p a xs) in loop_
18:16:17 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t -> m Bool) -> (t -> m a) -> [t] -> m ()
18:16:21 <jokerGTA> guys i have to 2 data types that i need to make instance of class ParsecRead but when i do that i get error that this class is not instantianable
18:16:40 <ivanm> jokerGTA: paste them and the error up somewhere?
18:16:53 <jokerGTA> ok ivan hvala:)
18:17:29 <ivanm> nema nishta
18:19:41 <jokerGTA> ivane http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4560#a4560
18:21:27 <ivanm> jokerGTA: can you paste the class up?
18:21:41 <jokerGTA> which class?
18:21:49 <ivanm> or is it from Parsec itself?
18:21:53 <ivanm> jokerGTA: ParsecRead?
18:23:14 <jokerGTA> he wants me to make it an instance of class Read actually...but he said in order to do that i must use ParsecRead class
18:23:19 <jokerGTA> ivan http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4561#a4561
18:23:21 <dolio> Has anyone installed the 2.6.1 haskell mode?
18:23:34 <ivanm> dolio: I haven't yet
18:23:40 <dibblego> @type anyM -- bet not
18:23:42 <lambdabot> Not in scope: `anyM'
18:23:58 <ivanm> jokerGTA: get rid of that "instance ParsecRead a => Read a where"
18:24:18 <ivanm> jokerGTA: that won't let you make any other instances IIRC
18:24:24 <ivanm> jokerGTA: can you paste the entire module up?
18:24:30 <ivanm> @hoogle anyM
18:24:30 <lambdabot> Data.Graph.Inductive.Monad matchAnyM :: GraphM m gr => m (gr a b) -> m (GDecomp gr a b)
18:24:41 <ivanm> heh
18:25:05 <jokerGTA> i cant..that get rid of that.....if put Read instead of ParsecRead then it works
18:25:13 <jokerGTA> he wants me to use it just as it is
18:25:39 <jokerGTA> why would he say that in order to make my type instance of class Read i have to use ParsecRead
18:25:53 <ivanm> who is this "he"?
18:26:05 <jokerGTA> and at the same time ill be able to use ParsecRead library
18:26:07 <jokerGTA> prof
18:26:10 <ivanm> OK
18:26:15 <ivanm> can you paste the entire file up?
18:26:25 <ivanm> because I see no real reason why you can't produce an instance
18:27:06 <jokerGTA> all i did was this newtype World = Wo (Maze,Mouse) deriving (Eq,ParsecRead)
18:27:22 <jokerGTA> when i do this newtype World = Wo (Maze,Mouse) deriving (Eq,Read) then it compiles
18:27:39 <monochrom> Why do you have "deriving ParsecRead"? Is it a requirement?
18:27:48 <jokerGTA> yes
18:28:00 <ivanm> jokerGTA: oh, you can't do that
18:28:08 <ivanm> jokerGTA: you need to make a manual instance of ParsecRead
18:28:15 <jokerGTA> oh
18:28:17 <jokerGTA> how?
18:28:21 <ivanm> jokerGTA: unless you use newtypederiving like the error says
18:28:32 <jokerGTA> i have module which represents my type
18:28:59 <monochrom> (Maze,Mouse) is already a ParsecRead instance iff World deriving ParsecRead is sensible.
18:30:50 <RyanT5000> so, what's the deal with Hackage?
18:31:00 <RyanT5000> anyone know why it's down?
18:31:17 <monochrom> It is down again?
18:31:23 <ivanm> yes
18:31:30 <monochrom> darn
18:31:32 <ivanm> RyanT5000: because galois stuffed up again? *shrug*
18:31:41 <jokerGTA> ivan how do i make manual instance of each type i have
18:31:44 <ivanm> monochrom: where have you been? :o
18:31:45 <RyanT5000> is it mostly static?
18:31:58 <monochrom> I have been outside of hackage.
18:32:04 <ivanm> jokerGTA: "instance ParsecRead Blah where ... "
18:32:15 <ivanm> jokerGTA: or, for your specific case, enable GeneralizedNewtypeDeriving
18:32:22 <monochrom> Is this World homework due tomorrow?
18:32:22 <ivanm> (if you're allowed to make extensions)
18:32:26 <RyanT5000> i have some spare hosting that I might be able to put a Hackage mirror on
18:32:27 <jokerGTA> oh no
18:32:32 <jokerGTA> week to go
18:32:41 <RyanT5000> i'm not sure what would be involved, though, in setting that up
18:32:48 <stroan> how large is hackage?
18:33:04 <RyanT5000> the torrent mentioned in the topic is only 85 MB
18:33:09 <RyanT5000> but it doesn't have previous versions
18:33:14 <RyanT5000> i imagine it's at most a few gigs though
18:33:34 <stroan> grand, I also have a dedicated box I can use as a mirror if that's being set up
18:33:35 <RyanT5000> it's mostly static content, right?
18:33:45 <ivanm> RyanT5000: there's no infrastructure in terms of fallback mirror setup, etc. AFAIK though...
18:33:57 <ivanm> RyanT5000: not sure if the pages are dynamic or static
18:34:05 <ivanm> you can get the hackage source and have a look...
18:34:14 <ivanm> (except that guess where it's probably hosted... :P )
18:34:17 <iaefai> Can anyone help me trying to understand ConfigFile? I have some code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11454#a11454   but for some reason I get a parse error on line 13, and I can't find any practical examples for a simple use of ConfigFile
18:34:27 <RyanT5000> well, I assume there's a way to change the URL cabal-install looks for
18:34:30 <copumpkin> RyanT5000: I've offered some too, but they didn't seem too enthusiastic
18:34:43 <RyanT5000> dons is at galois, right?
18:34:52 <copumpkin> yep
18:35:29 <ivanm> RyanT5000: yes
18:35:37 <ivanm> it's for non-cabal-install stuff that could be a problem
18:35:42 <ivanm> uploading, etc. as well
18:35:47 <RyanT5000> yeah, well that's not so important
18:35:56 <ivanm> copumpkin: I'm guessing because they're re-writing the hackage code as is
18:35:58 <ivanm> *it is
18:36:00 <RyanT5000> what's really important is that there are probably a lot of people out there being unable to use haskell easily right now
18:36:06 <ivanm> IIRC, there's going to be mirror support in there
18:36:13 * ivanm can use Haskell just fine...
18:36:26 <ivanm> might not be able to get any new packages, but it's not stopping me from using haskell ;-)
18:36:27 <jokerGTA> thats the thing Ivan.....when you say ""instance ParsecRead Blah where ... "  there has to be something under the where....
18:36:27 <copumpkin> ivanm: then I guess you're not one of the lot of people
18:36:37 <ivanm> heh
18:36:38 <RyanT5000> sure, you can, and I can, but imagine what it must be like for a newbie
18:36:43 <ivanm> jokerGTA: right...
18:36:49 <ivanm> I'm not going to tell you _everything_!
18:36:50 <jokerGTA> all i have defined in each module is type and functions describing that type
18:37:04 <RyanT5000> getting started on haskell is not exactly trivial in any circumstance
18:37:24 <jokerGTA> ok
18:37:25 <copumpkin> this is part of our avoid success at all costs mission
18:37:37 <ivanm> zigackly!
18:37:37 <jre2> copumpkin: exactly
18:38:07 <roconnor> finally got HXT installed
18:38:11 <roconnor> now I can rebuild my blog
18:41:23 <iaefai> :t Either
18:41:24 <lambdabot> Not in scope: data constructor `Either'
18:41:42 <jre2> roconnor: have a custom setup?
18:41:48 <iaefai> What does this type signature say exactly? IO (Either (C.CPErrorData,String) Blog)
18:41:50 <roconnor> jre2: yep
18:42:55 <jre2> iaefai: it does IO, returns a Blog, and if it fails it returns instead a tuple with the error data and presumably a message summarizing the error
18:43:33 <drhodes> I read a good rational for avoiding success.  Languages that get popular too soon are often hastily grown and become inconsistent when differences of opinion lead to disjointed implementation.
18:43:35 <iaefai> ok, is Either the thing with left and right?
18:43:39 <blackdog> iaefai: it's like a beefier Maybe - you get some information about what screwed up
18:43:45 <blackdog> yeah
18:44:18 <RyanT5000> drhodes: i think that's a feature of weak leadership, not strong constituency
18:44:26 <aavogt> drhodes: what is this anecdotal evidence?
18:44:41 <drhodes> let me track down the article
18:45:47 <jre2> RyanT5000: but it's not like there's a despot ruler. if a language becomes popular enough the majority will drive it however they wish
18:47:34 <blackdog> jre2, RyanT5000: D is an interesting example there, actually. there are basically two languages now, D1 and D2. D2 is the one Walter Bright actually works on, D1 is what everybody else uses...
18:48:27 <luite> is there a way to 'repackage' a c++ library along with all its dependencies in a single large shared library that only exposes C functions?
18:48:30 <jre2> and 3 standard libraries
18:48:53 <RyanT5000> jre2: some languages do have despot rulers
18:48:58 <RyanT5000> e.g.: python
18:49:22 <RyanT5000> C++ did for a while - until ANSI and ISO got involved
18:49:37 <RyanT5000> (and, yeah, industry pressure on *that* sort of scale can produce a revolution that unseats the ruler)
18:49:46 <RyanT5000> C# has a despot - Microsoft
18:49:51 <RyanT5000> Java does
18:50:02 <iaefai> Is it possible to step through code to see what goes on?
18:50:04 <aavogt> despot being one person in those cases?
18:50:12 <RyanT5000> aavogt: one entity
18:50:13 <iaefai> A corporation is a despot of many faces
18:50:40 <RyanT5000> iaefai: sure, but it's way more coherent than a standards committee
18:50:47 <RyanT5000> i mean, have you guys read C++0x?
18:50:53 <jre2> c# is aided by the fact that people can "easily" make .NET compatible forks
18:51:03 <RyanT5000> that standard is the definition of "kitchen sink" standards
18:51:06 <iaefai> jre2: With a lot of effort or money
18:51:18 <iaefai> RyanT5000: Think C++ dies? :P
18:51:31 <iaefai> It should have been still born
18:51:34 <RyanT5000> haha
18:51:48 <RyanT5000> jre2: yeah, mono is horribly nonconforming
18:51:59 <RyanT5000> i had the extreme displeasure of writing a large project in C# on mono
18:52:12 <RyanT5000> especially on an *old* version of mono
18:52:16 <iaefai> I have a friend that doesn't think he could use anything else after .net
18:52:18 <RyanT5000> it was horrible
18:52:32 <RyanT5000> iaefai: tell him to read Graham's article on "blub"
18:52:44 <iaefai> RyanT5000: Which Graham?
18:52:58 <CalJohn> the problem is that Graham is wrong about blub
18:53:04 <RyanT5000> paul
18:53:07 <iaefai> God no
18:53:12 <RyanT5000> haha
18:53:16 <RyanT5000> i didn't say i agreed with him
18:53:18 <jre2> I just started playing with a very largescale project using mono, so I hope that's different now...
18:53:24 <CalJohn> advantages of languages _can_ be explained to people, it's just that he was always a terrible programmer
18:53:24 <iaefai> pg writes out of his ass
18:53:25 <RyanT5000> i just thought your friend might be really offended by the article :P
18:53:42 <RyanT5000> so it would be amusing to suggest it
18:53:51 <monochrom> I have a friend who doesn't think he could use anything else after haskell
18:53:55 <RyanT5000> i think the blub paradox exists to some extent
18:54:00 <iaefai> RyanT5000: this? http://www.paulgraham.com/avg.html
18:54:09 <RyanT5000> yeah
18:54:26 <RyanT5000> i think the real thing is that until people have *experienced* the limitations of their language of choice
18:54:30 <RyanT5000> they don't care enough to learn something else
18:54:31 <iaefai> I mean this is the guy that pushed 'arc' as the language for the next 50 years or was it century?
18:54:34 <blackdog> the cute bit about the blub article is that he's referred to Haskell as a "weird academic language"...
18:55:01 <Axman6> blackdog: well, it is... it's just an awful lot more than that too
18:55:06 <RyanT5000> but experiencing the limitations of your language of choice is difficult, because it requires thinking outside the box
18:55:13 <iaefai> When arc was finally released, it was a piece of shit
18:55:21 <hexpuem> having academic backing is pretty big
18:55:22 <RyanT5000> you have to have an internal model of programming that's more general than your programming language of choice
18:55:34 <CalJohn> i read Paul Graham when I was 16.  I thought he was amazing, and I went out and learnt Common Lisp.  Now, I am not impressed
18:55:44 <hexpuem> mentioning D again, one of the problems with it was there was no academics involved, no corporations and a smallish use community
18:55:49 <monochrom> RyanT5000 nails it.
18:55:54 <hexpuem> user*
18:56:10 <RyanT5000> it's a lot like the question of whether people think in English (or whatever other language(s) they know) or in some other non-language
18:56:32 <Axman6> illustrated english
18:56:51 <RyanT5000> Axman6: perhaps - but at the very least, illustrated with *all* the senses, not just sight
18:56:51 <iaefai> CalJohn: Real lisp programmers got to me - that is what put pg in his proper place in my mind.
18:56:59 <RyanT5000> Axman6: and probably some more
18:57:33 <Axman6> anyway, i have no idea why, but i've been writing an HTML DSL... it's surprisingly easy
18:57:37 <drhodes> aavogt: this is what I was referring to: http://news.ycombinator.com/item?id=886744
18:57:37 <RyanT5000> CalJohn: I think there are a lot of things about lisp that beat out Haskell - it's really freeing to never care about proving anything about your types :P
18:57:44 <blackdog> Axman6: the point being that he makes fun of people who pooh-pooh languages above them on his notional pyramid
18:58:13 <RyanT5000> CalJohn: which basically means that progress on lisp library features can exceed progress on lisp theory
18:58:31 <blackdog> RyanT5000: Disagree, completely - I'd hate to lose the type system. It'd be nice to have a more regular syntax, though - would make metaprogramming simpler.
18:58:34 <CalJohn> RyanT5000: "lisp" <-- meaning which?
18:58:46 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11455#a11455 anyone have any thoughts?
18:58:50 <Axman6> apart from "why?"
18:58:50 <RyanT5000> blackdog: I didn't say i preferred it; i just said it's not *strictly* less powerful
18:58:51 <kmc> RyanT5000, yes it's freeing, frees you to make a lot of mistakes that aren't caught until production
18:58:52 <kmc> ;)
18:59:14 <CalJohn> i think Common Lisp is much less expressive than Haskell.  Scheme is also less expressive
18:59:16 <sieni> RyanT5000: Which, of course, is also a nuisance, when you get a stack trace in production code. "Expected an object of type #<cadarable value>, got 7".
18:59:20 <blackdog> RyanT5000: I'm not sure it is. You could use Dynamic as your only type in haskell - with a few helper functions, you'd end up with basically the same thing, i think.
18:59:41 <RyanT5000> blackdog: sure, everything's turing-complete; syntactic overhead matters, though
18:59:52 <RyanT5000> in any case, i agree completely, kmc and blackdog, which is why you won't find me in #lisp very often
18:59:58 <CalJohn> Common Lisp is a better language than most industry languages around now (with the exclusion of Java, which, with a good IDE, is better)
19:00:02 <RyanT5000> however, i'm very thankful that there are lisp hackers out there
19:00:15 <RyanT5000> for example, if nobody had made call/cc in that horrible untyped way
19:00:22 <kmc> it's easier to do dynamic typing in a statically typed language than the other way around
19:00:33 <blackdog> not really making the turing-complete argument - I meant more that you could map features over one-to-one, rather than having to interpret them in another layer the way you'd have to with C
19:00:35 <RyanT5000> people probably would not have been as inspired to figure out delimited continuations
19:00:55 <BMeph> blackdog: Have you read oleg's one type-class article? :)
19:01:36 <RyanT5000> blackdog: sure, but that kind of isomorphism is not an equivalence class programmers think in
19:01:45 <sieni> certain kinds of polymorphism are at least inconvenient to express in scheme/lisp
19:01:48 <Adamant> CalJohn: until Haskell gets macros I won't consider it more expressive than Scheme
19:02:03 <RyanT5000> at the end of the day, the only thing i can bring myself to care about is programmer productivity
19:02:07 <kmc> what do you want macros for that isn't handled nice by TH?
19:02:14 <Adamant> kmc: TH sucking
19:02:19 <kmc> or by regular higher-order functions + laziness?
19:02:25 <sieni> like polymorphism in the return values
19:02:25 <c_wraith> Adamant:  I'd guess you've never used TH then.
19:02:26 <RyanT5000> kmc: i've got one
19:02:30 <Adamant> kmc: now that's a copout
19:02:43 <RyanT5000> i'd like something that lets me build variants of datastructures
19:02:43 <CalJohn> Adamant: scheme macros aren't that expressive anyway...
19:02:53 <Adamant> CalJohn: I think they are
19:02:56 <kmc> i can't speak to whether TH sucks, as i haven't used it much
19:02:58 <RyanT5000> in the same basic way, and with the same basic ease, as C++ lets me take a datastructure and make it "const"
19:03:01 <CalJohn> Adamant: compare to CL or Clojure
19:03:04 <aavogt> drhodes: funny how this is brought up at the same time as another paulgraham essay
19:03:07 <CalJohn> Adamant: they are not
19:03:13 <pikhq> Adamant: In Lisp, code is data. In Haskell, data is code.
19:03:22 <kmc> RyanT5000, newtype + deriving classes?
19:03:23 * pikhq runs off, confusing all
19:03:32 <Adamant> pikhq: :P
19:03:40 <sieni> CalJohn: What kind of limitations are you thinking about in Scheme macros?
19:03:44 <RyanT5000> kmc: no, i'm talking about related *types*, not related *functions*
19:03:48 <iaefai> So if I have a data Config = Config { documentRoot :: String } deriving (Read, Show)  trapped in a right side of an Either, what is the proper way to extract the documentRoot?
19:03:50 <Adamant> CalJohn: you like types but you don't like hygiene?
19:03:57 <kmc> RyanT5000, i mean that your related type can be a newtype over the original one
19:04:01 <Adamant> that's weird.
19:04:23 <RyanT5000> kmc: not really, because it typically requires changes to the original datastructure
19:04:29 <kmc> RyanT5000, i absolutely agree about programmer productivity.  but that means fixing bugs, not just writing code
19:04:44 <Adamant> also most Schemes macro systems are built on a unhygenic core
19:04:51 <kmc> RyanT5000, how so?
19:04:57 <CalJohn> Adamant: no, I'm not a big macro fan, but it's unusual to hear someone advocate the more limited macroes over full laziness and type specialisations
19:05:01 <Adamant> c_wraith: I haven't used it in anger but I have fooled around with it
19:05:03 <RyanT5000> kmc: for example, in haskell, you could conceive of having one version of a datatype that's pure
19:05:05 <kmc> if you write all your code in terms of typeclasses, you can easily make new types that act like others
19:05:17 <RyanT5000> kmc: and another version that has monadically mutable members
19:05:35 <kmc> yeah, haskell has a big problem where refactoring pure code to be impure is a pain
19:05:38 <RyanT5000> kmc: which is somewhat similar to C++'s const/nonconst distinction (though, clearly, not identical)
19:05:50 <RyanT5000> kmc: right, so having a nice macro system would help with this
19:05:56 <pikhq> iaefai: Pattern match?
19:05:57 <RyanT5000> kmc: but you'd still have trouble expressing it properly in the type system
19:06:00 <Adamant> CalJohn: I like having lots of kinds of power
19:06:15 <Adamant> macros are powerful, so is laziness
19:06:19 <kmc> what would help is applicative brackets, or something like that
19:06:28 <RyanT5000> kmc: so, all i'm saying is that having a strong type system is good *most* of the time, but it also forces you to invent theory ahead of yourself
19:06:37 <RyanT5000> and sometimes, in industry, you simply don't have the time to figure out the theory
19:06:41 <kmc> yeah
19:06:45 <RyanT5000> so you take a guess, make something (hopefully) useful, and test it
19:06:56 <RyanT5000> and you *assume* that if it works for you, it'll work for your users
19:07:04 <kmc> luckily there are a lot of insanely smart people who think up haskell theory as a hobby
19:07:12 <RyanT5000> kmc: right, and that's what makes haskell so awesome
19:07:25 <RyanT5000> kmc: but they'll never be able to lay *all* the railroad tracks ahead of *everyone*
19:07:29 <kmc> i like how typeclasses were just a trick to get rid of ML's + versus +.
19:07:31 <FunctorSal> "<RyanT5000> kmc: and another version that has monadically mutable members" <--- make the recursive positions explicit
19:07:43 <kmc> and they turned out to be really general and useful
19:07:56 <FunctorSal> like "data Expr expr = Var String | Plus expr expr"
19:08:10 <RyanT5000> FunctorSal: yeah, i've tried that; it gets really syntactically heinous really fast
19:08:53 <RyanT5000> FunctorSal: especially when you have several mutually recursive datatypes
19:09:29 <RyanT5000> FunctorSal: in order to make that really feasible you'd need submodules and they'd need to be able to take types as parameters
19:09:36 <RyanT5000> FunctorSal: which essentially gets you back to ML-style modules
19:09:36 <jmillikin> Is there any ETA on repairing Hackage?
19:09:39 <FunctorSal> RyanT5000: *nod* I think it's better to have a single higher-order parameter in that case (mutual recursion)
19:09:44 <FunctorSal> like in multirec
19:09:57 <RyanT5000> FunctorSal: you mean like a type function?
19:10:18 <RyanT5000> jmillikin: i'm not aware of one, but i've offered to host a mirror
19:10:24 <RyanT5000> jmillikin: nobody seems to know how to set that up, though
19:10:43 <iaefai> pikhq: Yeah, I have just started trying a case operation. I have to have a way of failing while outputing the error...
19:11:14 <FunctorSal> RyanT5000: you'd turn your original mutually recursive types A,B,C into (Fam A') (Fam B') (Fam C') instead
19:11:18 <iaefai> I have no documentation for Control.Monad.Error
19:11:25 <FunctorSal> (the A' etc can be empty dummies)
19:11:31 <pikhq> iaefai: Case? No, no, no, no, no.
19:11:46 <pikhq> Try to make as much of it be monadic code as you can.
19:11:51 <pikhq> ;)
19:11:58 <kmc> iaefai, http://www.haskell.org/ghc/docs/latest/html/libraries/
19:12:01 <kmc> bookmark that :)
19:12:06 <iaefai> pikhq: I am afraid I don't know what that would be :p
19:12:10 <kmc> i have a window manager hotkey to open it in the nearest firefox
19:12:44 <iaefai> kmc, a bookmark will do :p
19:12:47 <jre2> jmillikin: I don't know, but I'm starting to wonder whether we should try to get mirrors setup
19:12:55 <FunctorSal> RyanT5000: instead of taking the fixpoint of a functor, you'll be taking the fixpoint of a (* -> *) -> (* -> *) thing then
19:13:08 <FunctorSal> (the family)
19:13:21 <RyanT5000> FunctorSal: that makes sense, though I suspect the syntax would still be pretty awful
19:13:51 <copumpkin> yeah, I like the idea of taking type fixpoints and compositions, but the newtypes involved are painful as hell
19:14:00 <FunctorSal> RyanT5000: less repetition, but a bit mind-bending
19:14:06 <iaefai> So what precisely would it mean to be 'monadic'?
19:14:31 <iaefai> In the real world haskell, pg 453, there is a 'monadic use of either', but i am not sure if it would apply directly
19:15:11 <kmc> iaefai, i'd say monadic is any code that invokes a Monad typeclass member, directly or indirectly
19:15:13 <RyanT5000> FunctorSal: i've lately become of the mind that algebraic datatypes have pretty severe semantic limitations
19:15:30 <FunctorSal> which?
19:15:38 <RyanT5000> well, here's a problem i recently encountered
19:15:39 <pikhq> iaefai: do let Right (Config x) = yourEitherHere; x' <- documentRoot x; {- Do stuff with your value x' here -}
19:15:47 <RyanT5000> so, as many of you know, i'm writing a video game right now
19:15:59 <RyanT5000> anyhow, there's a huge, important datastructure: the terrain mesh
19:16:02 <iaefai> pikhq: But what about errors?
19:16:04 <pikhq> Oh, and finally: return (someValue)
19:16:18 <RyanT5000> it's a collection of vertices, faces, and edges, with adjacency information
19:16:32 <RyanT5000> but then, almost every other subsystem of the game needs it to store some random other information
19:16:44 <RyanT5000> for example, the pathfinding system needs traversability and cost information for every face
19:16:44 <jokerGTA> kmc i have little trouble trying to make each of my types instances of ParsecRead
19:16:48 <pikhq> iaefai: That's the beauty of it: the resultant value of that do expression is an Either that has either your result value or the error.
19:17:06 <kmc> hmm, i haven't used ParsecRead
19:17:09 <pikhq> And because of how the Either monad is implemented, it just stops when it gets to an error.
19:17:17 <RyanT5000> the fluid simulator needs to know the gradient of each face, a bunch of stuff about where puddles form (attached to vertices),  and some random other stuff
19:17:18 <pikhq> Hooray, monads.
19:17:22 <ivanm> kmc: it's a custom class he has to use
19:17:23 <RyanT5000> the terrain generation system needs other information
19:17:36 <ivanm> kmc: he has to either use GeneralizedNewtypeDeriving or manually create instances
19:17:39 <iaefai> How do I actually know this is a monad I am working with? I am afraid it seems a little confused.
19:17:46 <pikhq> Either is a monad.
19:17:48 <iaefai> I can see how the value is liberated from Either
19:17:49 <FunctorSal> RyanT5000: that sounds like a good case for parameterised decorations
19:18:06 <pikhq> Erm. My code example was wrong, BTW.
19:18:07 <RyanT5000> FunctorSal: i'll have to look that up
19:18:30 <FunctorSal> RyanT5000: uh, not a technical term. I just mean your terrain type would take an extra type parameter
19:18:34 <pikhq> do let Config x = yourEitherHere; x' <- documentRoot x; {- Do stuff with your value x' here -};return resultValueHere
19:19:01 <FunctorSal> RyanT5000: and every face could contain a value of that parameter
19:19:01 <RyanT5000> FunctorSal: yeah, but these are not simple relationships here, really
19:19:04 <kmc> jokerGTA, can you hpaste the definition of the ParsecRead class?
19:19:09 <RyanT5000> for example
19:19:27 <RyanT5000> each vertex has a reference to a "puddle slab", and each puddle slab has a reference to a bunch of faces
19:19:33 <copumpkin> aw cute name
19:19:42 <RyanT5000> lol
19:20:13 <RyanT5000> so, what i *really* want is a way that each programmer can write some kind of schema
19:20:19 <RyanT5000> that describes certain aspects of a graph
19:20:28 <RyanT5000> and then, all the schema can be combined into a single datastructure
19:20:40 <copumpkin> what would a schema like this specify?
19:20:41 * BMeph coos: "Who's a good puddle slab? YOU're a good puddle slab, yes you are!" ;)
19:20:50 <copumpkin> lol
19:20:58 <iaefai> pikhq: It seems to be wrong, let me do an hpaste with my error received
19:21:01 <RyanT5000> copumpkin: well, it would basically specify what sorts of relationships a particular subsystem cares about
19:21:08 <jokerGTA> kmc http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4561#a4561
19:22:07 <FunctorSal> RyanT5000: the "Annotated" modules of haskell-src-exts are an example of parameterising out the annotation type
19:22:08 <iaefai> pikhq: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11458#a11459
19:22:20 <RyanT5000> e.g.: the one for the navigation mesh might look something like: "{ traversability :: Face -> Maybe Cost }"
19:22:26 <iaefai> I don't see how you can use Config x = ... when it is using an Either without a constructor in the pattern
19:23:06 <kmc> jokerGTA, cool, that's a good class to have
19:23:13 <pikhq> iaefai: What you wrote there is in the IO monad.
19:23:27 <pikhq> iaefai: Erm. No.
19:23:40 <pikhq> iaefai: ... I should not be touching Haskell code at the moment, I see.
19:23:45 <pikhq> Anyone else care to help him?
19:24:37 <jokerGTA> he wants us to do this...."make each of your types instances of class Read... In order to do so use the class ParsecRead and and the parser library Parsec
19:25:13 <kmc> iaefai, you should probably use a case expression
19:25:26 <iaefai> kmc, lovely :p
19:26:13 <kmc> config <- case opt of { Left err -> printErrorAndDie err; Right cfg -> return cfg }
19:26:24 <kmc> where printErrorAndDie is something you define that, err, does what it says
19:26:28 * pikhq makes a note to self: "ask for a bloody code example -- it helps. A lot."
19:26:58 <jokerGTA> i dont get how i can make each type at the same time instance of Read and instance of ParsecRead
19:27:19 <kmc> jokerGTA, if you make it an instance of ParsecRead, then it defines Read for you
19:27:29 <iaefai> kmc, I noticed something called throwError: Would that be of use?
19:27:33 <kmc> maybe
19:28:02 <kmc> jokerGTA, you have "instance ParsecRead a => Read a"
19:28:15 <kmc> meaning, for any type satisfying (ParsecRead a), you have an instance for (Read a)
19:28:21 <jokerGTA> yes in the file i showed you just now
19:28:38 <jokerGTA> but it doesnt allow me to derive from ParsecRead
19:28:45 <jokerGTA> it says that it is not instatanable
19:29:00 <iaefai> :t throwError
19:29:01 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
19:29:03 <kmc> can you paste the error?
19:29:20 <jokerGTA> yes give me sec
19:29:26 <kmc> i don't know what you mean by "derive from"
19:29:42 <kmc> are you trying to do "data Foo = Bar deriving (ParsecRead)"?
19:29:55 <ivanm> kmc: yes, he is
19:29:57 <kmc> you can't do that; you'll have to write your own ParsecRead instance for that type
19:30:06 <ivanm> he has to use either GeneralizedNewtypeDeriving if he wants that
19:30:10 <ivanm> since it's a newtype
19:30:20 <ivanm> kmc: I've told him that at least twice, he doesn't want to listen
19:30:42 <kmc> jokerGTA, is it clear what ivanm and i are suggesting?
19:31:15 <jokerGTA> no i wish it is kmc
19:31:35 <kmc> jokerGTA, do you understand what "deriving" is, and how it differs from a regular instance declaration?
19:31:50 <jokerGTA> no i dont kmc
19:31:52 <kmc> okay
19:31:58 <ivanm> jokerGTA: can you use extensions?
19:32:05 <kmc> so you have a type Foo, and you want to make it an instance of ParsecRead
19:32:10 <kmc> you would have to write something like this:
19:32:10 <jokerGTA> ok
19:32:22 <kmc> instance ParsecRead Foo where { parsecRead = {- my parser here -} }
19:32:43 <jokerGTA> yes  but my parser is in totally different module
19:32:46 <ivanm> jokerGTA: deriving is only used in two cases: 1) a couple of simple inbuilt classes such as Show, Read, Eq, etc.; 2) if you newtype something, then the GeneralizedNewtypeDeriving extension lets you derive instances of whatever classes the underlying type is an instance of
19:32:59 <kmc> jokerGTA, then you have a name for it, in that module, right?
19:33:04 <kmc> you can just say
19:33:08 <jokerGTA> yes i do
19:33:13 <jokerGTA> remember we talked about that today
19:33:13 <ivanm> jokerGTA: have you actually read through any Haskell tutorials to know how classes, etc. work?
19:33:14 <kmc> instance ParsecRead Foo where { parsecRead = myParserFromTheOtherModule }
19:33:17 <ivanm> @where wikibook
19:33:18 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:33:20 <jokerGTA> yes ivan i did
19:33:33 <ivanm> jokerGTA: ^^ read through the sections on classes and instances there
19:33:37 <ivanm> because I don't think you're getting it
19:33:40 <kmc> if you already have an appropriate parser, you just tell it to use ti
19:33:41 <kmc> it*
19:33:55 <jokerGTA> there are 3 different parsers thats the thing kmc
19:33:59 <kmc> well, pick one
19:34:03 <jokerGTA> oh
19:34:13 <kmc> they all have the appropriate type?
19:34:51 <jokerGTA> they all have same type
19:34:55 <kmc> if you're defining "instance ParsecRead Foo", you'll need something of type "GenParser Char st Foo"
19:34:59 <kmc> why do you have three parsers?
19:35:11 <jokerGTA> those are the one you showed me today
19:35:17 <jokerGTA> for expression and statements etc
19:35:18 <jokerGTA> ..
19:35:26 <jokerGTA> i am writitng part for while loop now
19:35:31 <jokerGTA> i am trying to anyway
19:35:42 <kmc> iirc i had parseOne and parseMany
19:35:47 <jokerGTA> ye
19:35:48 <kmc> and parseMany used parseOne
19:35:50 <jokerGTA> yes
19:35:51 <kmc> so it makes sense to pick parseMany
19:35:56 <iaefai> :t ioError
19:35:57 <lambdabot> forall a. IOError -> IO a
19:35:58 <kmc> because it will cover both the one-statement case and the :+: case
19:36:45 <jokerGTA> ok...kmc..sorry guys for all the questions..i am trying the best i can to do as much on my own
19:37:27 <kmc> "deriving" is something totally different.  it's used to tell the compiler that it should automatically generate an instance in some "obvious" way
19:37:35 <kmc> like, for Show, it will just print the names of constructors, etc
19:37:50 <jokerGTA> yeah i undewrstand show class because i wored with it before
19:38:10 <kmc> ghc doesn't know anything about your ParsecRead class, and certainly can't write instances itself
19:38:14 <jokerGTA> like before i derived inatnce of show and generated my own print function..i didnt want to use predefined
19:38:42 <jokerGTA> same for Eq...i derived that to use some function from that class
19:38:46 <jokerGTA> like equality
19:38:48 <kmc> when you say "deriving (ParsecRead)" you are asking it to write the whole parser for you, which it can't
19:39:12 <kmc> it can only do that for certain built-in classes, or the case of newtype that ivanm mentioned, with a ghc extension
19:39:28 <jokerGTA> why wouldnt be sutable to chose parseOne as opposed to parseMany
19:39:34 <jokerGTA> what would be the difference
19:39:59 <kmc> jokerGTA, do you understand how the parsers are written?
19:40:10 <ivanm> jokerGTA: parseMany: keep parsing as much as possible
19:40:18 <ivanm> parseOne: try to get one of the parsers from this list to work
19:40:29 <ivanm> (I'm guessing, based on how I used polyparse)
19:40:29 <kmc> ivanm, they're things i defined in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11442
19:40:34 <jokerGTA> yeah and it stops and use the rest for another parser
19:40:48 <ivanm> oh, forget that then
19:41:30 <kmc> jokerGTA, you'll see that my parseOne parses only a single "stay", "move", or "turn"
19:41:43 <jokerGTA> yes..i saw that
19:41:48 <kmc> and that parseMany uses the parsec combinator sepBy to invoke parseOne repeatedly
19:41:58 <kmc> where each individual parse is separated by a semicolon and optional whitespace
19:42:05 <iaefai> Is there a way to get ghc to output a source of all the types it sees things at, especially just before an error
19:42:05 <iaefai> :t (<<=)
19:42:06 <lambdabot> Not in scope: `<<='
19:42:09 <jokerGTA> yes
19:42:15 <jokerGTA> i understand that
19:42:27 <kmc> so... which one do you want as *the* canonical way to parse a MouseProgram?
19:42:36 <kmc> because when you define that instance, you're saying this is *the* parser
19:42:50 <ivanm> dibblego: where's parsing tutorial you wrote?
19:43:06 <dibblego> slides you mean?
19:43:15 <dibblego> http://projects.tmorris.net/public/haskell-parsers/artifacts/0.9/html/index.html
19:44:11 <ivanm> yeah
19:44:14 <ivanm> jokerGTA: ^^ have a look at that
19:44:25 <jokerGTA> ok ivan tx
19:50:47 <jokerGTA> is there any rule when you importing modules so you dont get "imports form cycles for modules".....i have like 6 modules and each import the other 5
19:51:45 <kmc> haha
19:51:58 <kmc> don't import in cycles?
19:52:04 <kmc> there is a way to do it with ghc
19:52:12 <kmc> but i've never had to use it even in moderately big projects
19:52:17 <kmc> and it's ugly
19:52:46 <kmc> you're probably not using modules properly if they all depend on the others
19:53:00 <dolio> Technically, the report says mutually recursive modules are fine, but I don't think any compiler implements them well.
19:53:25 <copumpkin> what's the big difficulty?
19:53:30 <ivanm> hmmmm, I thought one of them could...
19:53:41 <kmc> jhc is sort of whole-program
19:53:42 <roconnor> copumpkin: compilation units
19:53:43 <kmc> it might handle it well
19:53:51 <roconnor> copumpkin: which is dumb
19:53:52 <dolio> Yeah, jhc might work fine.
19:54:27 <roconnor> modules should be grouped according to human needs.  compilation units probably ought to be more fine grained.
19:54:46 <dazza_> i did a smelly fart
19:54:50 <kmc> roconnor, i agree... i think incremental compilation should be totally transparent
19:54:58 <copumpkin> dazza_: good to know
19:55:20 <dazza_> yep and i forgot what foldr does
19:55:27 <ve> is there some existing function like this? diffs n [x] = [n-x]; diffs _ (x:y:xs) = [y-x]:diffs (y:xs)
19:55:36 <copumpkin> > foldr f z [a, b, c] :: Expr
19:55:36 <jokerGTA> if i have module a and that module imports "something"....now my module b imports module a.....so that means it doesnt need to imports 'something" as well....right?
19:55:36 <kmc> > foldr (+) 0 [a, b, c, d]
19:55:37 <lambdabot>   f a (f b (f c z))
19:55:38 <lambdabot>   a + (b + (c + (d + 0)))
19:55:42 <roconnor> I'd guess compilation units should be the smallest groups of functions that are mutually dependent.
19:55:54 <kmc> jokerGTA, as long as module a exports the something
19:56:06 <roconnor> and hence would largely consist of individual functions.
19:56:14 <ivanm> ve: well, your recursive call to diffs is the wrong type... ;-)
19:56:19 <jokerGTA> yes..makes sense
19:57:49 <ve> oops, I meant: diffs n [x] = [n-x]; diffs n (x:y:xs) = (y-x):diffs n (y:xs)
19:57:49 <dolio> > (zipWith subtract `ap` drop 1) [1..10]
19:57:50 <lambdabot>   [1,1,1,1,1,1,1,1,1]
19:57:56 <dazza_> > foldr (\x y->2*x+y) 2 [1,2,3]
19:57:57 <lambdabot>   14
19:58:33 <copumpkin> > foldr (\x y -> 2 * y + x) 2 [1,2,3]
19:58:34 <lambdabot>   33
19:59:03 <dolio> > (\n -> zipWith subtract `ap` (++ [n]) . drop 1) 35 [1..10]
19:59:05 <lambdabot>   [0,0,0,0,0,0,0,0,0]
19:59:15 <dolio> > (\n -> zipWith subtract `ap` ((++ [n]) . drop 1)) 35 [1..10]
19:59:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,25]
20:01:54 <iaefai> Is there a generic    function of (String -> String) that just returns what it is given?
20:02:30 <ivanm> iaefai: id ?
20:02:37 <iaefai> :t id
20:02:38 <lambdabot> forall a. a -> a
20:02:44 <iaefai> @src id
20:02:44 <lambdabot> id x = x
20:02:47 <iaefai> lovely
20:02:48 <ivanm> > id "foo"
20:02:49 <lambdabot>   "foo"
20:05:27 <ve> is there a better way to partition a number randomly than by generating n-1 random numbers, sorting them, and using their differences (adding 0 and n to the list) to get each component?
20:05:59 <iaefai> In this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11454#a11463  on line 23 it says it is inferring a type of IO Char, but if I get rid of a certain return on the line before it gives another error Couldn't match expected type `IO a' against inferred type `Config'   So I am not sure what I can do with this section to make sure it works
20:07:43 <ve> er, I mean to partition a number into n-1 random components where N is the number and the sorted list has 0 and N added to it.
20:08:19 <blackdog> ve: is probably in Knuth
20:08:20 <ve> need to sleep.. n random components with n-1 random numbers, that is.
20:08:49 <ve> then I'll probably stick to using the differences for now.
20:18:52 <m4ik3ru> Howdy.
20:19:29 <m4ik3ru> Darn, I wanted to apologize to copumpkin for having been absent in the tutorial I pretty much asked for...
20:19:35 <m4ik3ru> Feel like a jerk :)
20:19:46 <m4ik3ru> Hope somebody else got something out of it, at least!
20:19:51 <iaefai> m4ik3ru: let me guess -  a monad tutorial
20:19:56 <m4ik3ru> AND!  My assignment is almost done :)
20:20:02 <m4ik3ru> iaefai, That was the one.
20:20:09 <m4ik3ru> Is he good at those?
20:20:15 <iaefai> I think all tutorials are monad tutorials
20:20:20 <m4ik3ru> Heh :)
20:20:32 <m4ik3ru> Yeah, they're weird.
20:20:39 <iaefai> I might have been a student of his many many months ago, but I forget if I got it from him.
20:20:41 <m4ik3ru> I'm vaguely understading how to use them now, at least.
20:20:45 <m4ik3ru> A little bit.
20:21:00 <iaefai> I have been into it two times now and I am going to be relearning shortly, but I aim to do it by book
20:21:24 <m4ik3ru> The book required by the class pretty much just glazes over them, it seems like.
20:21:30 <m4ik3ru> Actually, over everything.
20:21:36 <m4ik3ru> it's a good intro, for sure.
20:21:42 <iaefai> What book?
20:21:45 <m4ik3ru> But that seems to be about it :)
20:21:59 <ivanm> most books glaze over monads
20:22:00 <m4ik3ru> Graham Hutton's "Programming In Haskell"
20:22:09 <iaefai> I have that one
20:22:15 <iaefai> Real World Haskell seems to be better
20:22:22 <ivanm> because they're beginners books, they get close to the end of the book and suddenly go "oh no, we forgot to mention the M word! :o"
20:22:28 <ivanm> iaefai: yes, but they're different audiences
20:22:51 <ivanm> hutton's book (same as SoE, craft, etc.) are aimed at beginners, including those that have never programmed before
20:23:10 <iaefai> I did get something out of hutton's
20:23:11 <ivanm> RWH has some intro material for people that are programmers but have never used Haskell, but overall it's a medium-advanced book
20:23:30 <m4ik3ru> I'm sliding into the medium range, I think.
20:23:31 <kmc> there's a lot to be said for not learning monads early on
20:23:33 <iaefai> But this error handling thing is bugging me
20:23:48 <ivanm> I think Axman6's IO tutorial is good
20:23:54 <ivanm> in that it avoids monads
20:23:57 <Axman6> really?
20:24:00 <Axman6> :)
20:24:02 <ivanm> Axman6: isn't that your one?
20:24:05 <Axman6> needs some work...
20:24:10 <Axman6> yeah
20:24:13 <ivanm> Axman6: not that I've actually read it, the _concept_ is good ;-)
20:24:16 <Axman6> it's a bit cheesy
20:24:32 <ivanm> realisitically, despite IO being the impetus for monads, the IO monad is completely different than all the rest
20:25:01 <ivanm> Axman6: as long as it isn't BONUS-level cheesy, it's OK
20:25:03 <ddarius> IO was not the impetus for monads.
20:25:09 <ivanm> ddarius: wasn't it? :o
20:25:16 <ivanm> I thought that was the main reason monads were included
20:25:42 <Axman6> i quite like BONUS' cheesiness
20:25:45 <m4ik3ru> Impurifying a pure language for the sake of usability, it seems.
20:25:47 <Cale> I sort of doubt that IO was the impetus for monads.
20:25:50 <ddarius> The first work on monads for FP (as opposed to denotational semantics) used monad comprehensions.
20:26:00 <Cale> The first papers on the use of monads in functional programming don't mention IO
20:26:02 <ddarius> Moggi definitely didn't care particularly about IO.
20:26:11 <ivanm> I mean impetus for putting it into Haskell
20:26:20 <ivanm> that was the impression I had...
20:26:21 <kmc> anyway it's the impetus for a lot of people learning monads
20:26:43 <m4ik3ru> Parsing was our impetus.
20:26:59 <m4ik3ru> In class.
20:27:03 <m4ik3ru> That is.
20:27:03 <iaefai> Would it be correct to say that the return from a case has to be all the same types from all branches?
20:27:14 <kmc> yes
20:27:14 <ivanm> iaefai: yes
20:27:15 <Cale> iaefai: yes, of course :)
20:27:16 <Axman6> i don't personally think that the word monad should be used at all when teaching IO to beginners of haskell
20:27:35 <ivanm> though using "return" there got me confused for a bit ;-)
20:27:36 <ddarius> Crap.  This "Shelby Moore" person has moved from LtU to Haskell-Cafe.
20:27:52 <ivanm> Axman6: agreed... IIRC, that's what RWH does (or doesn't, depending on how you look at it)
20:27:56 <ddarius> iaefai: In Haskell, yes, mostly...
20:27:58 <ivanm> ddarius: which persion?
20:28:00 <Cale> iaefai: It's true of every expression. Every expression gets just one type regardless of what value it has at runtime.
20:28:09 <iaefai> Now if on the other end of that case is a x <-   and one of the branches is an ioError and the other is a type we shall call Beta, does that mean a return Beta has to be used?
20:28:37 <ddarius> ivanm: I'm not sure how to answer that other than to say the obvious thing, the person who goes by "Shelby Moore" on LtU and Haskell-Cafe.
20:28:50 <ivanm> heh
20:28:55 <SamB_XP> iaefai: unless the cased-over data refines the types differently, but that only happens when you use GADTs
20:29:07 <Cale> iaefai: hmm... well, if one is an IO action, they should all be IO actions.
20:29:09 <ivanm> OK, let me re-phrase: why is this person worthy of comment?
20:29:13 <ddarius> One could potentially do more than GADTs.
20:29:21 <ivanm> Cale: IO actions of the same type as well
20:29:24 <Cale> iaefai: you can use return to turn a value into an IO action which does nothing but to return that value
20:29:32 <Cale> Indeed, actions of the same type
20:29:41 <SamB_XP> ddarius: in Haskell ?
20:29:43 <iaefai> What I refer to specifically is lines 21, 22 of this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11454#a11463
20:29:54 <ddarius> SamB_XP: Not current Haskell.
20:30:07 <ddarius> There's nothing making case have to be so stringently typed.
20:30:16 <iaefai> Would it be correct to say that <- is a way of dropping IO while inside IO?
20:30:22 <ddarius> ivanm: I haven't looked at what he has written on Haskell-Cafe, but on LtU it was mass quantities of nonsense.
20:31:08 <ivanm> iaefai: it's a way of simulating extracting the value from the monad inside the do block
20:31:15 <ivanm> ddarius: right
20:31:24 <Cale> iaefai: v <- x means "run the IO action x and name its result v"
20:31:53 <Cale> and because of that, if x :: IO t, then v :: t
20:32:05 <Cale> But to think of it as "unwrapping" is not a very good analogy.
20:32:38 <Cale> You're running the IO action to produce a value. It might be a different value every time. It might depend on user input.
20:32:48 <SamB_XP> it's more like "doing your homework" than "unwrapping" ;-P
20:32:57 <jre2> is there an existing function that's basically "mapM f xs" but if f fails it doesn't apply f to the rest of the list (but returns anything that succeeded thus far plus the remaining)?
20:33:09 <ivanm> ddarius: this individual?
20:33:10 <ivanm> http://www.mail-archive.com/haskell-cafe@haskell.org/msg66486.html
20:33:12 <iaefai> I can't really think of a way to get config to just be a String, because of that ioError branch
20:33:13 * ddarius hates the terminology "(un)wrapping from a monad"
20:33:28 <ddarius> or "extracting the value from a monad"
20:33:48 <SamB_XP> yeah, you can only do that for comonads!
20:33:49 <Axman6> ddarius: i think it's very useful for beginners, even if it's wrong
20:33:51 <iaefai> ddarius: What about eviserating the monad's value?
20:33:55 <Cale> Using the word "monad" in reference to a value makes my teeth hurt.
20:34:28 * ivanm passes Cale some paste to make his teeth numb
20:34:29 <ivanm> ;-)
20:34:44 <SamB_XP> why your teeth ?
20:34:50 <iaefai> :t runErrorT
20:34:51 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
20:35:13 <ivanm> SamB_XP: presumably because he grinds his teeth...
20:35:25 <SamB_XP> oh, right
20:35:29 <SamB_XP> I do that sometimes :-(
20:35:42 <Cale> "A monad" is a type level thing. It's the type constructor (together with an appropriate instance of Monad).
20:35:46 <iaefai> How does <$> work?
20:35:54 <ivanm> @src (<$>)
20:35:54 <lambdabot> f <$> a = fmap f a
20:36:02 <Cale> :t (<$>)
20:36:03 <ddarius> ivanm: That person yes, and a reasonable example of a pile of meaningless nonsense.  At least he didn't try to invoke thermodynamics, using a complete misunderstanding of it, that time.
20:36:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:36:04 <ivanm> iaefai: ^^ <$> == `fmap`
20:36:11 <ivanm> ddarius: heh
20:37:09 <ddarius> Axman6: I think it leads directly to people wanting IO a -> a functions and not understanding why that isn't sensible, even ignoring purity issues.
20:37:12 <Cale> When the functor happens to be a monad, you have that f <$> x = do v <- x; return (f v)
20:37:16 <iaefai> So in the line 	Config <$> get "Document-Root"   it would be fmap Config $ get "Document-Root" ?
20:37:25 <Cale> yep
20:37:41 <ddarius> Then many people respond that "IO is special" though almost no monads have a 'M a -> a' function.
20:38:04 <ivanm> well, which monads have completely same m a -> a functions?
20:38:25 <kmc> ddarius, a lot of them do, as partial applications of something like runState
20:38:29 <ivanm> maybe, list and either don't...
20:38:33 <jmcarthur> copointed ones
20:38:39 <jmcarthur> Stream
20:38:44 <jmcarthur> is my most common example
20:38:46 <SamB_XP> Id
20:39:09 <ddarius> kmc: I can write a total function a -> IO a -> a too.
20:39:15 <ivanm> but any monad that has a failure type/representation doesn't...
20:39:21 <ivanm> ddarius: called "const"? :p
20:39:55 <kmc> right, the point isn't just the type, the point is to do something useful
20:40:07 <kmc> "maybe myDefault id" is a useful function of type Maybe a -> a
20:40:24 <ddarius> It's not of type Maybe a -> a
20:40:43 <ivanm> kmc: it's of type a -> Maybe a -> a
20:40:48 <ivanm> and that's called fromMaybe
20:40:54 <ivanm> @src fromMaybe
20:40:54 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
20:41:00 <kmc> right... it's still useful
20:41:05 <kmc> unlike const :: a -> IO a -> a
20:41:09 <iaefai> In this line: get :: MonadError CPError m => ConfigParser -> SectionSpec -> OptionSpec -> m a   ; where type CPError = (CPErrorData, String)    does that mean that it will then return a MonadError (CPErrorData, String) a    ... and if so, how would you go about getting the String portion in the return from get?
20:41:12 <ivanm> kmc: useful, yes... m a -> a, no
20:41:29 <ddarius> kmc: My point is that "running" a monad is not a trivial operation.  There isn't a value just sitting there waiting to be extracted.
20:41:33 <kmc> i agree
20:41:52 <ivanm> ddarius: well, for arbitrary monads
20:41:53 <kmc> but it also doesn't mean that Maybe is "one-way" in the same way that IO is
20:42:11 <ivanm> kmc: no monad is one-way the way IO is (ignoring unsafe*)
20:42:20 <ivanm> since all other monads at least have m -> IO functions
20:42:40 <ivanm> (otherwise, they'd never be able to be used...)
20:42:48 <kmc> maybe House's hardware monad?
20:43:15 <ivanm> kmc: well, AFAIK Haskell programs running on House still would need IO as the main function...
20:43:39 <gpogo> is hackage coming up anytime soon?
20:43:54 * noZone gets out and pushes hackage
20:43:54 <iaefai> gpogo: end of the month
20:43:55 <EvanCarroll> what is the best tutorial for someone new to haskell and functional programming
20:43:55 <ivanm> gpogo: no idea, but there's a torrent with the packages on it
20:44:04 <ivanm> EvanCarroll: online or book?
20:44:09 <ivanm> iaefai: :o
20:44:13 <EvanCarroll> online
20:44:21 <ivanm> some people like LYAH
20:44:27 <ivanm> there's also the wikibook and YAHT
20:44:30 <ivanm> @where LYAH
20:44:30 <lambdabot> www.learnyouahaskell.com
20:44:32 <ivanm> @where wikibook
20:44:33 <lambdabot> http://en.wikibooks.org/wiki/Haskell
20:44:35 <ivanm> @where YAHT
20:44:35 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:45:06 <ddarius> IO is "one-way" simply because it is an abstract data type with no operations provided to get out of it.  Admittedly, it is that way for a reason, but you can make your own types that are similar.
20:45:37 <ivanm> ddarius: yes, but then you'd never be able to use them if there was no way to get them into IO
20:45:42 <gpogo> ivanm: do I just drop that in my ~/.cabal/packages/hackage.haskell.org dir?
20:45:47 <ivanm> or there'd be no point in using them anyway
20:46:06 <ivanm> gpogo: individual tarballs, yes
20:46:18 <kmc> i can imagine a useful system where the user provides values of type "M a" for some monad M /= IO, without allowing them to "run" those values in IO or otherwise
20:46:25 <gpogo> ivanm: thanks!
20:46:27 <kmc> it seems that a lot of DSLs would work this way
20:46:33 <ddarius> kmc: Indeed.
20:46:37 <kmc> where is this torrent?
20:46:40 <ivanm> kmc: then how would you actually run your program?
20:46:44 <Cale> @let equivalent = (==) `on` (sort . map toLower)
20:46:45 <lambdabot>  Defined.
20:46:58 <Cale> @let origText = "This text and the one beside it are equal. I wrote this one first, and then I gave it to my friend Christian Bok and asked him to generate a new text using every letter and every punctuation mark that I used in mine. The other text is his."
20:46:59 <lambdabot>  Defined.
20:47:05 <ivanm> @where+ hackage-torrent = http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
20:47:05 <lambdabot> Done.
20:47:09 <Cale> @let newText = "Micah Lexier requested in advance that I reinvent his text. So I unknotted it and reknitted it into this very form, but then I began to think that his message had already resewn a touted art of genuine poetry. His eerie text was mine."
20:47:10 <lambdabot>  Defined.
20:47:17 <Cale> > equivalent origText newText
20:47:17 <ddarius> @where hackage-torrent
20:47:17 <lambdabot> = http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
20:47:18 <ivanm> bah, didn't mean to have the = there
20:47:18 <lambdabot>   False
20:47:25 <kmc> ivanm, through the machinery provided by the DSL's implementation
20:47:37 <ivanm> @where+ hackage-torrent http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
20:47:37 <lambdabot> Done.
20:47:55 <ivanm> kmc: yes, but to get into main you'd eventually have some way of going m -> IO
20:48:01 <ivanm> even if it's hidden within the DSL
20:48:03 <Cale> > (equivalent `on` filter (not . isSpace)) origText newText
20:48:05 <lambdabot>   True
20:48:19 <kmc> main is already written, and loads your code for you
20:48:19 <ivanm> Cale: isn't it a permutation?
20:48:21 <kmc> like lambdabot does
20:48:31 <Cale> ivanm: have to remove spaces
20:48:33 <kmc> or ghci (if you ignore that it also lets you provide IO actions)
20:48:36 <ivanm> oh, right, that's what your equivalent function does
20:48:54 <ivanm> kmc: yes, but even if you print your results that's still getting into IO
20:48:59 <Cale> yeah, I forgot to lose the spaces when I defined it though
20:49:13 <Cale> @undefined
20:49:15 <ivanm> so it's not quite a permutation
20:49:15 <Cale> @undefine
20:50:26 <ivanm> the @help plugin should have a better message if an invalid plugin is passed to it IMHO
20:50:44 <ivanm> @help undefined
20:50:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:50:58 <ivanm> ^^ looks like @help doesn't do anything...
20:52:47 <kmc> @help help
20:52:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:52:56 <ddarius> @help list
20:52:57 <lambdabot> list [module|command]
20:52:57 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
20:57:04 <jre2> @seen Bonus
20:57:05 <lambdabot> Unknown command, try @list
20:57:52 <ivanm> preflex: seen BONUS
20:57:52 <preflex>  BONUS was last seen on #haskell 6 hours, 39 minutes and 28 seconds ago, saying: and it will short circuit with that
20:57:57 <ivanm> jre2: @seen no longer works
20:58:34 <Axman6> @list Data.List
20:58:34 <lambdabot> No module "Data.List" loaded
20:58:40 <Axman6> @list
20:58:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:58:42 <Axman6> Prelude
20:58:48 <Axman6> @list Prelude
20:58:48 <lambdabot> No module "Prelude" loaded
20:58:51 <Axman6> ...
20:58:52 <Axman6> :O
20:59:03 <ivanm> Axman6: ummm, @list gives the plugins modules...
20:59:03 <Axman6> oh... right, ha
20:59:08 <Axman6> lambdabot modules
20:59:37 <jre2> ivanm: but..why?
20:59:52 <ivanm> jre2: because it leaked memory like a sieve
20:59:59 <ivanm> and was the most common reason for lambdabot dying
21:00:05 <ivanm> so they've dropped it for now
21:00:08 <lpjhjdh> does anyone know if 6.12.1rc1 is stable enough for day to day use?
21:00:15 <ivanm> preflex's seen command works well enough
21:00:25 <hexpuem> the rc is out?
21:00:26 <ivanm> lpjhjdh: if you don't need 6.12 support yet, I'd wait for a full release
21:00:31 <ivanm> hexpuem: has been for a while
21:00:41 <hexpuem> wow i fail then
21:00:41 <hexpuem> haha
21:00:42 <lpjhjdh> ivanm: splicing of types and deriving functor+foldable are very appealing
21:00:44 <hexpuem> was like omg when its coming out
21:00:45 <SamB_XP> lpjhjdh: I would wait for the release unless you're planning to upgrade when it comes out anyway ...
21:01:00 <jre2> ivanm: I wouldn't expect a simple seen implementation to do that, but ok
21:01:17 <ivanm> jre2: it was the way it was storing user details
21:01:26 <ivanm> besides, preflex's is nicer by giving their last message as well
21:01:32 <ivanm> preflex: seen jre2
21:01:32 <preflex>  jre2 was last seen on #haskell 32 seconds ago, saying: ivanm: I wouldn't expect a simple seen implementation to do that, but ok
21:01:33 <jre2> that's true
21:01:46 <SamB_XP> @seen SamB
21:01:46 <lambdabot> Unknown command, try @list
21:01:50 <SamB_XP> preflex: seen SamB
21:01:50 <preflex>  SamB was last seen on #haskell 29 days, 13 hours, 26 minutes and 33 seconds ago, saying: you can't use ++ in a nick anyway, it seems
21:02:00 <lpjhjdh> SamB_XP: I'll be upgrading as soon as it comes out, or sooner if the rc is useable enough
21:02:06 <jre2> what's preflex based on? lambdabot fork or completely different?
21:02:20 <SamB_XP> totally different afaik
21:02:47 <SamB_XP> definitely uses a totally different architecture, but it's possible some IRC protocol code was scavanged or something ;-)
21:04:56 <lpjhjdh> I think I'll give it a try, thanks
21:05:14 <jre2> is preflex's code available? google is flooded with irc logs
21:05:35 <SamB_XP> preflex: source
21:05:39 <SamB_XP> preflex: about
21:05:43 <SamB_XP> preflex: help
21:05:43 <preflex>  try 'help help' or see 'list' for available commands
21:05:46 <SamB_XP> preflex: help help
21:05:46 <preflex>  help COMMAND - show help for a command
21:05:49 <ivanm> preflex: list
21:05:49 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
21:05:57 <ivanm> preflex: xseen
21:05:57 <preflex>  what
21:05:59 <SamB_XP> preflex: version
21:05:59 <preflex>  0.289
21:06:01 <ivanm> preflex: help xseen
21:06:01 <preflex>  xseen NICK - report when a user has been seen (on any network)
21:06:07 <kmc> preflex: cdecl declare x as const pointer to volatile int
21:06:07 <preflex>  trailing garbage
21:06:11 <ivanm> preflex: xseen dons
21:06:11 <preflex>  dons was last seen on freenode/#haskell 5 hours, 41 minutes and 6 seconds ago, saying: luite: no outstanding issues. unfinished api is biggest issue
21:06:14 <ivanm> preflex: seen dons
21:06:14 <preflex>  dons was last seen on #haskell 5 hours, 41 minutes and 9 seconds ago, saying: luite: no outstanding issues. unfinished api is biggest issue
21:06:20 <ivanm> OK, that's cross-network...
21:06:26 <kmc> preflex, make me a sandwich
21:06:48 <ivanm> preflex: 8ball
21:06:48 <preflex>  what
21:06:49 <jre2> lazy robot...
21:06:56 <ivanm> preflex: 8ball is your source publically available?
21:06:56 <preflex>  very doubtful
21:06:59 <ivanm> :(
21:07:12 <ivanm> preflex: help karmatop
21:07:12 <preflex>  karmatop - list the 10 topmost karma entries
21:07:16 <iaefai> preflex: sudo make me a sandwich
21:07:17 <ivanm> preflex: karmatop
21:07:21 <preflex>  c: 45485; g: 2523; ##c: 2189; c/c: 1120; vc: 945; bacek: 936; #c: 757; notepad: 744; pmichaud: 716; coke: 670
21:07:54 <ivanm> bah, that's fake because of people talking about C plus plus
21:07:58 <ivanm> preflex: seen coke
21:07:59 <preflex>  coke was last seen on ##c 10 days, 10 hours, 33 minutes and 29 seconds ago, saying: lemonade`: thank you
21:08:15 <ivanm> didn't think it was a haskeller...
21:08:46 <SamB_XP> apparantly people talk far too much about c/c++
21:09:34 <SamB_XP> most of those are bogus, actually
21:09:50 <SamB_XP> bacek might not be, and pmichaud is presumably not ...
21:10:00 <ivanm> yeah, dunno about vc
21:10:01 <lazyshrk> is it just me or is hackage.haskell.org down (again)?
21:10:03 <ivanm> but the rest are bogus
21:10:09 <ivanm> @where hackage-torrent
21:10:09 <lambdabot> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
21:10:11 <SamB_XP> that would be Visual C Plus Plus
21:10:16 <ivanm> lazyshrk: ^^ torrent if you want packages
21:10:19 <ivanm> SamB_XP: true
21:10:25 <lazyshrk> is there a way to use sparky.haskell.org with cabal?
21:10:39 <SamB_XP> personally, I always call the thing MSVC
21:10:49 <SamB_XP> or maybe CL
21:10:49 <ivanm> lazyshrk: try changing the config settings for cabal-install?
21:11:04 <ivanm> lazyshrk: but I don't know if sparky is up to date...
21:11:10 <ivanm> SamB_XP: CL?
21:11:17 <ivanm> Common Lisp?
21:11:37 <SamB_XP> ivanm: that's the compiler command, for some reason
21:11:44 <ivanm> :o
21:12:02 <dmwit> CompiLe
21:12:37 <lazyshrk> ivanm: don't think i can specify port 8080 in the cabal config file, but thanks for the torrent though
21:20:01 <keko9> there is a function that can do that?  i.e. [1234] and return [1,2,3,4] ?
21:21:58 <jre2> ? map read (show (xs !! 0)) :: [Int] -> [Int]
21:22:45 <ivanm> keko9: so you want to get the digits of a number?
21:22:51 <ivanm> use a fold with divMod or something
21:23:29 <keko9> the digits or the character of a string [TNM AEIO] ['T','N','M'...]
21:24:09 <ivanm> keko9: ummm... what type do you actually want?
21:24:17 <ivanm> String -> [String] ?
21:24:22 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 1234
21:24:23 <lambdabot>   [1,2,3,4]
21:24:28 <keko9> both, char and numbers
21:24:33 <Cale> > map (reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)) $ [1234]
21:24:34 <lambdabot>   [[1,2,3,4]]
21:24:42 <jre2> keko9: the input is a list with a single thing?
21:24:47 <Cale> > concatMap (reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)) $ [1234]
21:24:49 <lambdabot>   [1,2,3,4]
21:24:57 <ivanm> keko9: there's no generic function that will work on both Int -> [Int] and String -> [String] that does what you want
21:25:06 <ivanm> > map return "1234"
21:25:07 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
21:25:07 <lambdabot>    arising from a use of...
21:25:12 <ivanm> > map return "TNM AEIO"
21:25:13 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
21:25:13 <lambdabot>    arising from a use of...
21:25:20 <ivanm> bah
21:25:26 <Cale> Too polymorphic.
21:25:28 <ivanm> > map (:[]) "TNM AEIO"
21:25:29 <lambdabot>   ["T","N","M"," ","A","E","I","O"]
21:25:40 <ivanm> Cale: yeah, I'm used to doing it in my code where other types constrain it to list
21:25:54 <cjs> hackage is unhappy again? Or is it just me?
21:26:01 <jre2> see motd
21:26:04 <sjanssen> cjs: no, it's down
21:26:08 <ivanm> @where hackage-torrent
21:26:09 <lambdabot> http://mauke.ath.cx/tmp/2009-10-19-hackage-archive.torrent
21:26:21 <cjs> Ooo, that sounds handy.
21:26:21 <ivanm> oh, dind't realise there was a link to the torrent in the topic
21:26:26 <dmwit> > "TNM AEIO" == ['T', 'N', 'M', ' ', 'A', 'E', 'I', 'O'] -- no conversion needed, keko9
21:26:27 <lambdabot>   True
21:26:45 <ivanm> dmwit: which is why I was asking him to clarify what he wanted...
21:26:56 <keko9> thks
21:27:32 <cjs> Is ktorrent a good client?
21:27:53 <sjanssen> cjs: it works for me.  It's not without bugs, however
21:28:05 <dmwit> Do you need a good client?  I take it you don't torrent very often...
21:28:17 <cjs> Actually, I'm on a link with a reasonable amount of bandwidth (100 Mbps), so something I could leave running nohupp'd when I'm logged out would let me distribute better.
21:28:18 * Axman6 recommends Transmission
21:28:38 <dmwit> cjs: rtorrent
21:28:40 <cjs> Actually, I'd like something with a daemon that runs in the background all the time,and a nice ktorrent-like UI I can bring up and down as necessary.
21:28:42 <Axman6> cjs: transmission can do that
21:28:43 <ivanm> Axman6: I like deluge
21:28:50 <cjs> dmwit: No, I don't torrent very often.
21:28:53 <ivanm> but the newest version has a truckload of deps like twisted :s
21:28:57 <dmwit> screen + rtorrent
21:29:03 <ivanm> cjs: deluge has a daemon...
21:29:15 <Axman6> cjs: it's also possible the transmission daemon has a web interface, but i can't remember for sure
21:30:15 <jre2> azuereus has a decent CLI at one point
21:30:23 <cjs> Hm. Transmission looks ok, and the gui is already installed by default, with a daemon and cli available. I'll try that.
21:30:53 <Cale> I use Deluge, it's rather good, but the rc1 for the newest version sucks, so avoid that. :)
21:31:08 <ivanm> jre2: azureus is now called vuze, and is full of ads IIRC
21:31:15 <ivanm> Cale: oh? I just installed it :s
21:31:27 <ivanm> didn't like it's usage of heaps of extra deps like pygame though :@
21:31:32 <cjs> Not only does transmission have a web client, it's enabled in "open" mode by default. Sheesh.
21:31:49 <Cale> There's nothing too bad about it, but the listview of the torrents doesn't update.
21:31:51 <ivanm> which means?
21:31:54 <Cale> (sometimes)
21:32:12 <cjs> 88.5 MB? Hackage is that small?
21:32:12 <Cale> So, your torrents might be running, but it'll look like it's at 0%
21:32:28 <sjanssen> cjs: it's just the latest versions of each package
21:32:57 <jre2> cjs: it also doesn't store GHC and such
21:33:02 <ivanm> sjanssen: what about things like regex-base which have dev and stable versions?
21:33:15 <sjanssen> ivanm: yep, it's an issue
21:33:37 <ivanm> heh
21:34:01 <cjs> Hm, not so helpful when I just want to browse the APIs of a half dozen packages in order to decide which to use.
21:34:12 <cjs> Still, better than nothing.
21:34:49 <ivanm> cjs: http://sparky.haskell.org:8080/
21:34:54 <ivanm> not sure how up-to-date it is...
21:35:15 <ivanm> oh, no haddock docs...
21:48:26 <luite> mmorrow: I finally have my program compiling again (TH caused some issues with a C++ binding, I had to restructure the code a little to make it compile). that TH code (sumQ) you gave me yesterday saves a huge amount of allocations, the function is also more than twice as fast
21:49:07 <c_wraith> luite:  Did you just move generation of some complex value to compile time?
21:49:50 <kmc> hmm i'd like to look at this sumQ, is it online?
21:50:26 <luite> c_wraith: no, I replaced the equivalent of  sum $ map (\i -> f i * g i) [0..p]  for a fixed p with the expansion of that sum
21:50:52 <luite> $(sumQ p) f g
21:50:55 <luite> gives the same result now
21:51:06 <luite> with the restriction that p has to be known at compile time
21:51:16 <c_wraith> luite: That sounds like doing a complex calculation at compile time instead of runtime to me....
21:52:04 <kmc> did that expansion expose additional compile-time optimizations?
21:52:05 <luite> c_wraith: is it? the compiler could have optimized away the list because p was constant anyway
21:52:19 <kmc> were you using -O2 or higher in both cases?
21:52:24 <luite> -O2 yes
21:52:36 <c_wraith> Well, it sounds like it'd enable stream fusion
21:53:04 <luite> I don't think theres anything to stream left?
21:54:10 <c_wraith> huh.  Interesting.
21:54:40 <luite> $(sumQ 3) f' g' generates:  (\f g -> 0 + (f 0 * g 0 + (f 1 * g 1 + (f 2 * g 2)))) f' g'
22:17:05 <keko9> I have a trouble with this, f2 :: Integral a :: [Int] -> [a]  ; f2 x = concatMap (reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)) x , and haskell said me Inferred type : Integral Int => [Int] -> [Int], then tried with that and said Illegal Haskell 98 class constraint in type declaration :S
22:17:51 <sjanssen> keko9: you want "[Int] -> [Int]"
22:18:04 <sjanssen> or "Integral a => [a] -> [a]"
22:20:13 <ivanm> unless you have a map fromIntegral in there with it
22:22:34 <keko9> No, I havent
22:22:45 <twb> $ cabal install --dry-run text ==> Resolving dependencies...  cabal: There is no available version of parsec that satisfies <3
22:22:59 <ivanm> twb: hackage is down
22:23:01 <twb> What, I can't put an explicit parsec<3 constraint in my .cabal/config?
22:23:09 <ivanm> and the torrent probably only has parsec-3
22:23:12 <ivanm> twb: you can
22:23:18 <twb> What torrent?
22:23:19 <keko9> I tried using Integral a => [a] -> [a] , but now have another problem "Instance of Integral [Char] required for definition of f"
22:23:44 <ivanm> twb: are you trying to use cabal-install?
22:23:48 <ivanm> duh, you are
22:24:00 <ivanm> twb: which versions of parsec do you have installed?
22:24:10 <ivanm> I'm not sure if "cabal install" running on the .cabal file there will auto-install deps
22:24:15 <sjanssen> keko9: characters aren't numbers, you're apparently attempting to use them as such
22:24:16 <twb> None via cabal-install.
22:24:21 <ivanm> twb: you have to grab a copy of parsec-2.* from somewhere
22:24:34 <twb> I have a copy of parsec 2 installed via apt-get.
22:25:01 <ivanm> twb: "ghc-pkg list parsec" show it?
22:25:14 <twb> ivanm: /var/lib/ghc-6.10.4/./package.conf: parsec-2.1.0.1
22:25:25 <ivanm> twb: :o
22:25:30 <ivanm> maybe hide 3.* for now?
22:25:37 <twb> ivanm: note that I was doing "cabal install --dry-run text", not "cabal install --dry-run"
22:25:45 <ivanm> oh, right
22:25:48 <ivanm> missed that
22:26:21 <ivanm> twb: which package is it complaining about? text doesn't use parsec AFAICT...
22:26:21 <twb> of course, if I remove the constraint it finishes the dry run happily :-/
22:26:32 <ivanm> twb: constraint from where?
22:26:37 <twb> ~/.cabal/config
22:26:47 <ivanm> cabal-install defaults to parsec<3 anyway I think...
22:26:57 <twb> I know -- I felt like making it explicit
22:27:11 <ivanm> twb: must be some other dep needs parsec-3 or something... *shrug*
22:27:12 <twb> I didn't want some unaccountable bastard ruining things again by removing the constraint without telling me
22:27:36 <ivanm> twb: blame the devs that just say "parsec" for the build-depends without checking if it works with -3 as well
22:27:52 <twb> I blame the parsec developers for releasing a 3.x and then telling everyone not to use it
22:28:02 <ivanm> twb: did they? really?
22:28:07 <twb> Apparently.
22:28:07 <ivanm> I thought people just chose not to use it...
22:28:23 <ivanm> twb: I just heard that 3 was apparently slower...
22:28:29 <ivanm> and people couldn't be bothered porting
22:28:42 <twb> At least some projects work with both parsec-2 and parsec-3
22:29:13 <twb> But because everyone ELSE says no to parsec-3, I have to as well, or things mysteriously break later on due to diamond dependency nonsense.
22:29:18 <ivanm> right, but unless they explicitly say so you can't check it
22:29:25 <ivanm> twb: yeah
22:29:35 <ivanm> someone was planning on doing a criterion comparison...
22:31:32 * ivanm has never used parsec, but is happy with polyparse
22:31:52 <ivanm> malcolmw++ for not making me choose which version to use because of compatibility concerns :p
22:32:18 <ivanm> twb: no mention of "don't use it" in the original announcement: http://old.nabble.com/ANN:-Parsec-3.0.0-td15867629.html
22:42:25 <Hunner> What does =<< do?
22:42:41 <Hunner> googling these things sucks >->
22:42:43 <ivanm> Hunner: flipped version of >>=
22:42:48 <ivanm> @hoogle (>->)
22:42:49 <lambdabot> No results found
22:42:55 <ivanm> @hoogle (=<<)
22:42:56 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
22:42:56 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
22:43:05 <ivanm> @hoogle (>>=)
22:43:05 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
22:43:06 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
22:43:06 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
22:43:14 <Hunner> okay thanks
22:43:15 <ivanm> oh, wait, I take it back, =<< is the flipped form
22:43:37 <ivanm> wait, I was right..
22:43:41 * ivanm is confusing himself
22:43:42 <Hunner> yes, you were right
22:43:50 <ivanm> Hunner: there's also online versions of hoogle and hayoo
22:44:29 <jekor> Is there a list somewhere or some heuristics on finding what would cause a GHC-generated program to segfault? The program uses no unsafe functions that I know of. Perhaps a library does, but...
22:44:41 <jekor> Even stranger is that it does not segfault in production, only on my local machine.
22:45:01 <ivanm> jekor: which OS, arch and GHC version?
22:45:05 <ivanm> and does it differ?
22:45:16 <ivanm> segfaults are rather rare...
22:45:30 <jekor> GHC 6.10.4, Linux minuskla 2.6.30-ARCH #1 SMP PREEMPT Mon Aug 17 18:04:53 CEST 2009 i686 Intel(R) Atom(TM) CPU N280 @ 1.66GHz GenuineIntel GNU/Linux
22:45:49 <jekor> I thought at first it was related to database access.
22:45:54 <ivanm> what's minuskla?
22:45:59 <jekor> It's an SCGI program that uses PostgreSQL.
22:46:01 <jekor> hostname
22:46:04 <ivanm> ahhh
22:46:14 <ivanm> heh, thought it was some random distro I'd never thought of...
22:46:17 <jekor> :)
22:46:29 <jekor> The code doesn't differ. I compile it separately on each machine.
22:46:34 <jekor> The server it's running on...
22:46:45 <jekor> Linux efektiva 2.6.18-92.1.22.el5xen #1 SMP Tue Dec 16 12:26:32 EST 2008 x86_64 Dual Core AMD Opteron(tm) Processor 265 AuthenticAMD GNU/Linux
22:46:48 <strangebotwin> ?DCC SEND "ff???f?" 0 0 0
22:46:48 <lambdabot> Unknown command, try @list
22:46:58 <jekor> Ah, version 6.10.3 on production.
22:47:05 <ski> (ivanm :  `f' is the flipped version of `g'  <=>  `g' is the flipped version of `f'  :)
22:47:14 <ivanm> methinks we have a spammer!
22:47:18 <ivanm> ski: yeah, I know
22:47:26 <ivanm> @where ops
22:47:27 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
22:47:39 <dibblego> wossup?
22:48:06 <ivanm> dibblego: strangebotwin appears to have used some DCC error/hole to kick some people off with dodgy irc clients
22:48:10 <ivanm> but he's quit now...
22:48:11 <dibblego> yeah just saw it
22:48:17 <jekor> Heh.
22:48:21 <ivanm> dibblego: notice the username...
22:48:23 --- mode: ChanServ set +o dibblego
22:48:29 <ivanm> wtf? an internode user?
22:48:36 <ivanm> *sigh* they'll sign anyone up nowadays... :p
22:48:49 <strangebotwin> ?DCC SEND "ff???f?" 0 0 0
22:48:49 <lambdabot> Unknown command, try @list
22:49:01 <ivanm> ski: though I was getting at that (=<<) is defined as flip (>>=)
22:49:01 --- mode: dibblego set +b *!n=IMFUCKNG@*.lns20.mel6.internode.on.net
22:49:11 <kmc> is that some kind of exploit
22:49:14 <ski> yes
22:49:21 <ivanm> kmc: yes, an oldish one I think
22:49:24 <kmc> did everyone who just quit get owned?
22:49:32 <ivanm> there was one a year or so ago that most clients fixed I think...
22:49:34 <ivanm> kmc: yup
22:49:39 <kmc> okay
22:49:40 <ivanm> notice it was the same people both times
22:49:53 <Hunner> @hoogle whenJust
22:49:53 <lambdabot> No results found
22:50:44 <dibblego> they appear to all be different clients
22:51:26 <ivanm> a whole bunch of different clients?
22:51:39 --- mode: dibblego set -b *!n=IMFUCKNG@*.lns20.mel6.internode.on.net
22:51:42 <dibblego> yes
22:51:57 <ivanm> s/different/old/
22:51:59 <ivanm> bah
22:52:02 <ski> iirc, the vulnerability was in routers, not in irc clients
22:52:11 * ivanm is having trouble working out which damn word he wants today...
22:52:19 <ivanm> ski: oh, yeah, that was another one...
22:52:27 <ivanm> a dlink router or something wasn't it?
22:52:35 <kmc> haha
22:57:56 <arcatan> huh
23:11:08 <angles> ?DCC SEND "ff???f?" 0 0 0
23:11:09 <lambdabot> Unknown command, try @list
23:11:26 <ivanm> angles: please go lose yourself
23:11:32 <ivanm> dibblego: we got another one...
23:11:42 * angles dances
23:11:47 --- mode: ChanServ set +o dibblego
23:11:47 <angles> oh wait.
23:11:50 <angles> ?DCC SEND "ff???f?" 0 0 0
23:11:51 <lambdabot> Unknown command, try @list
23:12:00 --- mode: dibblego set +b *!*n=angelv@*.ll.iac.es
23:12:04 --- mode: dibblego set +b angels!*@*
23:12:04 <ivanm> he's also in #ubuntu according to /whois
23:12:09 <ivanm> \o/
23:12:10 --- mode: dibblego set -b *!*n=angelv@*.ll.iac.es
23:12:32 <angles> oh noes! Not a whois!
23:12:35 <angles> ?DCC SEND "ff???f?" 0 0 0
23:12:36 <lambdabot> Unknown command, try @list
23:12:47 <Hunner> @hoogle (>>)
23:12:48 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
23:12:48 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
23:12:48 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
23:12:49 <ivanm> dibblego: it obviously didn't work...
23:12:59 --- mode: dibblego set +b angles!*@*
23:13:03 <ivanm> @src (>>)
23:13:03 <lambdabot> m >> k      = m >>= \_ -> k
23:13:05 <ivanm> Hunner: ^^
23:13:06 --- mode: dibblego set -b angels!*@*
23:21:46 <dibblego> @hoogle (Monad m) => Bool -> m () -> m ()
23:21:47 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
23:21:47 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
23:21:47 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
23:25:42 <iaefai> "Je vois des gens morts." <-- great film
23:27:15 <luite> what's the difference between a regular function and something spliced by TH?
23:27:34 <luite> the latter gave me a type error
23:27:44 <luite> can't the spliced code be polymorphic?
23:28:40 <luite> if I replace the splice expression by the code from -ddump-splices, the program compiles
23:35:30 <luite> the problem is that I use the spliced code in a function that needs to be both [Double] -> Double and [D] -> D, where D is my own dual number type for automatic differentiation
23:38:02 <Dunearhp> Is hackage down for anyone else?
23:39:17 <malosh> Dunearhp : configure ~/.cabal/config to point to http://www.lama.univ-savoie.fr/~meunier/archive
23:39:44 <Dunearhp> mirror?
23:39:49 <malosh> (and, btw, tell me if it works for you :-)
23:39:53 <malosh> temporary mirror
23:39:58 <luite> Dunearhp: it's been down for a while
23:40:12 <Dunearhp> ok thanks
23:40:22 <malosh> someone here yesterday posted a backup archive
23:47:33 <luite> hm, the RelaxedPolyRec extension lets me compile this thing
23:48:07 <luite> no idea what it does :)
23:49:29 <Dunearhp> malosh: mirror seems to be working, thanks. I needed to get a hold of QuickCheck today.
23:55:01 <Woof> Twey >: O
