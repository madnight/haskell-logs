00:00:16 <ksf> vi, you can't, but you can differentiate beween Left and Right.
00:00:19 <hotzen> ksf: is this the famous type-level-computation of naturals?`
00:00:24 <kmc> vy, case f x of Left x -> ...; Right y -> ...
00:00:25 <mtnviewmark> there is no way for the type of accu to be inferred with just that one equation
00:00:33 <ksf> case foo of {Left str -> ...; Right i -> ...}
00:00:45 <ksf> hotzen, yes.
00:00:48 <kmc> or, build it into multiple function equations
00:00:51 <ksf> I did'nt do div, though.
00:00:53 <pastah_rhymez> @paste
00:00:53 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
00:01:05 <vy> kmc: What's Left and Right?
00:01:07 <hotzen> mtnviewmark: oh, i see. but are the types in principle correct?
00:01:24 <ksf> but Vec is probably more interesting as a use case of such stuff
00:01:29 <kmc> @src Either
00:01:29 <lambdabot> Source not found. Just try something else.
00:01:35 <mtnviewmark> I think so --- but smartConcat2' doesn't work, even that one caluse
00:01:37 <ksf> (we really, really should have type-level naturals as primitives)
00:01:46 <Veinor> how 'good' is gtk2hs?
00:01:50 <kmc> vy, an element of Either String Int is not a String or an Int.  it's (Left x) for some string x, or (Right y) for some int y
00:01:54 <kmc> :t Left
00:01:55 <lambdabot> forall a b. a -> Either a b
00:01:55 <kmc> :t Right
00:01:56 <lambdabot> forall b a. b -> Either a b
00:01:58 <dblhelix> vy: these are the constructors (tags if you will) assigned to the String and Int resp. to tell them apart
00:02:16 <vy> kmc: What about more than two values in an Either clause?
00:02:17 <mtnviewmark> smartConcat2 as bs = foldr smartCons bs as
00:02:19 <kmc> vy, you can't
00:02:25 <hotzen> mtnviewmark: i have problems to accumulate the concated list, which could be a new type (resulting from NewListTy a b) on every cons.
00:02:26 <vy> kmc: Hrm... Thanks.
00:02:28 <kmc> Either is a type constructor that takes exactly two type arguments
00:02:31 <hotzen> hm
00:02:39 <dblhelix> vy: a value of type Either String Int is either ;-) of the form Left s (with s a String) or Right n (with n an Int)
00:02:40 <kmc> vy, really you should define your own datatype if you want something more complicated
00:03:02 <kmc> vy, like:   data Attribute = Height Float | Color String | IsOnFire Bool
00:03:06 <kmc> see, now the tags are nice and semantic
00:03:22 <hotzen> mtnviewmark: ..... why does this work and mine not? :(
00:03:33 <hotzen> do i have some error of thought?
00:03:34 <vy> kmc: You know... RWH obligations.
00:03:39 <mtnviewmark> well, look at your one equation --- ys isn't even used!
00:03:49 <mtnviewmark> and there is no termination on the recursion
00:03:53 <kmc> vy, you can, also, nest Either, like Either (Either a b) c.  but it's really not a common thing to do
00:04:04 <ksf> hotzen, also note that "mult" needs UndecidableInstances.
00:04:07 <mtnviewmark> as smartConcat2' just fails on null xs
00:04:12 <hotzen> i know, i wanted to implement the equations stepwise as i have given explicit types for everything
00:04:19 <kmc> beginners tend to overuse Either and tuples.  remember, these are just particular examples of the sort of datatypes you can define yourself in one line of code
00:04:21 <pastah_rhymez> vy: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5075#a5075
00:04:24 <kmc> and with better names
00:04:26 <hotzen> ksf: what does this mean?
00:04:34 <mtnviewmark> right - BUT without the base case, there is nothing for the type inference engine to hang on to
00:04:45 <mtnviewmark> so if you want to do that, always start wtih the base case
00:04:47 <ksf> you can look very smart if you mention that the algorithm by itself can be proved to terminate automatically, but ghc just doesn't do it.
00:04:52 <hotzen> which is the empty list?
00:04:56 <mtnviewmark> yes
00:04:58 <mtnviewmark> so
00:05:03 <hotzen> hm, thanks a bunch
00:05:27 <ksf> hotzen, the implementation paper talks en detail about when ghc fails to accept good programs because otherwise it can't guarantee the typechecker to terminate.
00:05:28 <kmc> pastah_rhymez, vy, i added one more alternative
00:05:41 <ksf> it bogs down to nested calls to type families.
00:05:57 <hotzen> ksf:  thank you, will read this part now
00:06:31 <kmc> it's not hard to make GHC diverge
00:06:32 <mtnviewmark> smartConcat2' accu [] ys = accu ++ ys  -- given the way you've defined smartConcat2
00:06:40 <kmc> there's that russel's paradox thing with the inliner, which iirc is H98
00:07:49 <ksf> hotzen, you'll even look smarter by mentioning "structurally decreasing". and that we'd need closed type families (ie ones that you can't add cases to once defined) to do such stuff.
00:07:53 <hotzen> k, i will try to complete my overcoded concat
00:08:16 <hotzen> ksf: thanks for that ;)
00:08:43 <ksf> concatV :: Vec n a -> Vec m a -> Vec (n `Add` m) a
00:16:13 <hotzen> mtnviewmarkt: the inferred type-signature of your foldr-concat is rather psycho. involving type-equalities. is the reason the recursive building of new NewListTy or that I used types instead of datas?
00:16:20 <hotzen> mtnviewmark: the inferred type-signature of your foldr-concat is rather psycho. involving type-equalities. is the reason the recursive building of new NewListTy or that I used types instead of datas?
00:16:55 <hotzen> smartConcat :: (NewListTy a listTy ~ listTy, SmartList a listTy) => [listTy] -> [a] -> [listTy]
00:21:33 <vy> kmc: pastah_rhymez: What's wrong with this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5075#a5077
00:22:55 <Cale> vy: The 'either id reduce' bit
00:23:30 <Cale> vy: You probably want to replace that with fmap reduce
00:24:04 <Cale> which is the same as  either Left (Right . reduce)
00:24:11 <Cale> :t either
00:24:12 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:24:14 <kmc> :t either
00:24:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:24:18 <Cale> :t either id
00:24:19 <lambdabot> forall a b. (b -> a) -> Either a b -> a
00:24:26 <Cale> :t either id id
00:24:27 <lambdabot> forall b. Either b b -> b
00:24:30 <thoughtpolice> yow! http://gist.github.com/raw/241730/9db506b976ff144a407d78793ffae4c90d42f2bb/gistfile1
00:24:33 <Cale> :t either id sum
00:24:34 <lambdabot> forall a. (Num a) => Either a [a] -> a
00:25:03 <thoughtpolice> neat experiment, criterion is aweosme :)
00:25:06 <kmc> vy, if you're not too confident with algebraic datatypes, i'd use pattern matching instead of "either".  "either" is mostly useful in higher-order cases, like mapping it over a list of Either-typed values
00:25:36 <toast-opt> hmm, so much for hugs as a backup
00:25:48 <vy> kmc: I'm trying to solve exercises in chapter 4 of RWH. Because of it tells me to use Either...
00:26:06 <toast-opt> ERROR "G:\tools\WinHugs\packages\hugsbase\Hugs\ST.hs":51 - Syntax error in ...
00:26:07 <Cale> :t fmap sum
00:26:08 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f [a] -> f a
00:26:13 <kmc> right.  I'm saying use (the type constructor) Either, but not (the function) either
00:26:27 <Cale> :t fmap sum :: Either String [Integer] -> Either String Integer
00:26:28 <lambdabot> Either String [Integer] -> Either String Integer
00:26:39 <kmc> is ch 4 functors?
00:26:50 <vy> kmc: Hrm... I see. Let me check. (OTOH, I'd be happy to fix current "either" usage also.)
00:27:01 <vy> kmc: functional programming.
00:27:02 <Cale> vy: fmap reduce is what you're looking for
00:27:10 <Cale> (by the looks of it)
00:27:20 <vy> Cale: I still don't know fmap, but i'll give it a hayoo.
00:27:30 <kmc> the nice way to write it is:   reduce <$> asUIntList cs b
00:27:33 <kmc> which is just infix fmap
00:27:41 <kmc> that's from Applicative, which is covered later i thin
00:27:45 <kmc> (it is in LYAH anyway)
00:27:50 <Cale> vy: for Either, it's just  fmap f (Left e) = Left e; fmap f (Right x) = Right (f x)
00:28:07 <Cale> vy: fmap is like map, but generalised to work on various other types
00:28:30 <kmc> but it doesn't get across the point of a general tagged-union because, as Cale illustrated, Either is asymmetric when treated as a functor; the Left values "fall through", while only the right values get a function applied
00:28:52 <tensorpudding> map is fmap, specialized to the functor []
00:29:13 <vy> Aren't functors an OCaml thingy?
00:29:16 <kmc> if you don't know what a "functor" is, the starting definition would be "container type".  it's a good deal more general
00:29:30 <kmc> ocaml's functors are like functions between first-class modules
00:29:35 <Cale> vy: In this case, a category theory thingy
00:29:40 <kmc> so are ocaml's
00:29:44 <kmc> but they translate to very different code
00:29:58 <kmc> unlike C++'s functors, which have nothing to do with maths and are just a fancy name to obscure a bug in the language
00:30:08 <tensorpudding> C++ has functors?
00:30:09 * kmc hides the monads quickly
00:30:15 <shambler> yeah
00:30:23 <shambler> classes with the operator() overloaded
00:30:33 <Cale> I haven't gone to the trouble of working out just how O'Caml's functors are actually functors.
00:30:48 <tensorpudding> is it O'Caml?
00:30:51 <tensorpudding> or OCaml?
00:30:57 <tensorpudding> the former sounds irish
00:31:04 <kmc> the language is french
00:31:32 <kmc> parts of the VM are only documented in french :/
00:31:42 <kmc> CS students: choose your lab partners wisely
00:31:45 <tensorpudding> at inria
00:31:58 <kmc> one who speaks french, one who speaks irc
00:32:45 <tensorpudding> hmm, ocaml predates haskell
00:33:07 <shambler> sooo?
00:34:29 <vy> kmc: Cale: Now it's even more uglier, but working: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5075#a5078
00:34:50 <shambler> tensorpudding, wait, OCaml was created in 1996
00:35:06 <shambler> if the O part is important
00:35:23 <ray> it's O(Caml)
00:35:36 <shambler> yes
00:35:48 <kmc> they're distant cousins
00:36:16 <manju> how do I define a fun which takes an Int and returns an Int ?
00:36:23 <manju> both positive and negative
00:36:28 <kmc> OCaml is descended from ML, which begat Lazy ML, which begat Gofer, which begat Haskell98
00:36:38 <kmc> manju, that depends on what the function does
00:36:52 <vy> manju: What's wrong with :: Int -> Int?
00:37:05 <kmc> that doesn't define a function, just declares what its type is
00:37:29 <vy> "id" is a cool function, ain't?
00:37:42 <manju> vy I get some weird error
00:37:46 <kmc> @src (<<=)
00:37:46 <lambdabot> Source not found. I am sorry.
00:37:54 <kmc> @src (=<<)
00:37:54 <lambdabot> f =<< x = x >>= f
00:37:57 <manju> fibonacci n
00:37:57 <manju>   | n < 1 =  0
00:37:57 <manju>   | otherwise = n
00:38:08 <manju> i call this as fibonacci -3
00:38:14 <manju> forget the function name
00:38:15 <kmc> fibonacci (-3)
00:38:23 <manju> currently it doesn't do anything
00:38:25 <kmc> fibonacci -3  is "fibonacci minus three"
00:38:31 <kmc> which is nonsense
00:38:31 <manju> ah
00:38:36 <kmc> and unfortunately the error msg is not convenient
00:38:46 <manju> gak!
00:38:46 <kmc> or indeed comprehensible
00:38:49 <manju> thanks :-)
00:38:54 <kmc> it thinks you meant to subtract two functions, and complains that it can't do that
00:38:55 <quicksilver> Cale, kmc : Surely an ML functor is just a function? ML modules are "just" tuples conforming to a signature, and a functor is "just" a function from module to module?
00:39:12 <Cale> quicksilver: right... but those modules can define types...
00:39:21 <kmc> quicksilver, they're tuples of types and values both
00:39:26 <quicksilver> ah right.
00:39:32 <kmc> and functors are not functions of the same sort as ML's functions
00:39:33 <Cale> quicksilver: I think the connection is a lot weaker
00:39:51 <Cale> I'm not sure where the mapping on arrows comes in
00:39:59 <kmc> right -- it doesn't necessarily map each object to an object and each arrow to an arrow such that etc.  it just uses them somehow
00:40:16 <Veinor> is gtk2hs an experimental sort of thing, or is it usable?
00:40:23 <hotzen> can somebody explain the type (type families) of smartConcat to me? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13084
00:40:27 <Cale> Veinor: quite usable
00:41:05 <Veinor> are there any important features that are missing?
00:41:19 <kmc> manju, now if you want to get into it, i think (-3) shouldn't work either.  because with any other operator, e.g. (/ 3) or (+ 3), it's a "section", i.e. a function that takes an argument, and returns that argument over 3, or plus 3, etc.  but - is special-cased
00:41:25 <Cale> Veinor: Not that I'm aware of.
00:41:26 <kmc> so it does work
00:41:35 <Cale> Veinor: But I haven't used it extensively.
00:41:45 <Veinor> yeah, if - wasn't special-cased there wouldn't be a nice way to express negative numbers :P
00:41:46 <kmc> > let f = (/ 3) in f 9
00:41:46 <lambdabot>   3.0
00:42:06 <kmc> you could make it lexical; -3 is one token, a literal signed int, but - 3 is two tokens, an infix app
00:42:13 <kmc> as for non-literals, "negate" is fine
00:42:17 <Veinor> that's personally my favorite approach
00:42:24 <Cale> I'm actually perfectly happy with that part of the Haskell syntax, unlike many others.
00:42:33 <kmc> it's a really minor thing
00:42:49 <manju> kmc, you are teaching a kindergarten kid Phd level haskell :-(
00:42:50 <Veinor> it's one of those things that comes back to bite you in the ass every once in a while
00:42:51 <Cale> I like being about to write things like (\x -> -x^3 + x + 1)
00:42:53 <Veinor> like the type of length
00:42:57 <kmc> manju, no, just trivia
00:43:08 <Cale> able*
00:43:09 <kmc> manju, unlike C++ the hard parts of Haskell are not bizarre syntactic special cases
00:43:24 <kmc> the hard parts of haskell are... things that solve hard problems!
00:43:26 <Cale> not sure why I wrote "about", but I should probably sleep
00:43:41 <Cale> hotzen: hmm
00:44:12 <hotzen> Cale: I dont understand the type at all ...
00:44:30 <Jedai> hotzen: ~ check equality between types
00:44:31 <Cale> hotzen: Do you know what ~ means?
00:44:40 <hotzen> i think type-equality
00:44:47 <Cale> right
00:45:26 <Jedai> hotzen: NewListTy is like a function on types, it takes two types in parameter and return a third type
00:45:41 <Cale> This is actually a pretty weird typeclass, what's the point of this?
00:46:23 <hotzen> Jedai, Cale: I know, i wrote that example but dont understand the inferred type of smartConcat. The whole example is to show how TypeFamilies/Assoc Types work and what they could be good for
00:46:55 <Cale> hotzen: Well, the type is sensible.
00:47:09 <Cale> hotzen: Maybe replace a with elemTy and it's more readable?
00:47:36 <Jedai> hotzen: your smartConcat is reversed compared to concat though
00:48:00 <Cale> Jedai: oh?
00:48:11 <Cale> oh, I suppose it is
00:48:18 <Cale> Reversed relative to (++)
00:48:28 <Cale> Rather than concat
00:48:28 <hotzen> hm hm hm
00:48:39 <Jedai> it should be "smartConcat xs ys = foldr smartCons ys xs"
00:48:46 <Cale> > foldr (:) [4,5] [1,2,3]
00:48:46 <lambdabot>   [1,2,3,4,5]
00:49:29 <Cale> hotzen: What kind of instances are you planning to write?
00:50:07 <hotzen> Cale: just basic ones like Double Double, Int Double, Char Double, etc
00:50:18 <Cale> hotzen: Char Double?
00:50:49 <Cale> Well, I guess it's possible to encode characters as Doubles.
00:51:00 <Jedai> Cale: I don't think it's really important, this is just a proof of concept ;)
00:51:18 <hotzen> instance SmartList Char Int where  type NewListTy Char Int = Int   smartCons x ys = ord x : ys
00:51:20 <hotzen> etc ...
00:51:26 <hotzen> yes, just a PoC
00:52:19 <hotzen> even with the foldr ys xs, i dont get the inferred result
00:52:36 <hotzen> do you have any explanation for the type-equality constraint?
00:53:24 <Cale> hotzen: You're going to repeatedly smartCons elements into the list, so when you insert one, it had better result in the same type of list as before
00:54:08 <Cale> So that when you insert the next one, it won't be some new type of list which was not an instance of SmartList
00:54:25 <hotzen> ah
00:55:29 <Cale> Well, actually there's a better reason still that it's got to be exactly the same type
00:58:11 <Jedai> Cale: the fact that a smartCons call can only have one type ?
00:58:57 <Jedai> ... That didn't come out right, how would you say it ?
00:59:10 <Cale> well, hmm
00:59:47 <Cale> :t foldr
00:59:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:00:39 <Cale> One of those b's is unified with [listTy], and the other with [NewListTy a listTy]
01:00:47 <Cale> in the function parameter
01:00:58 <Cale> So those had better be equal types
01:01:29 <Cale> (or [NewListTy elemTy listTy])
01:02:30 <Cale> hotzen: See that?
01:02:35 <Cale> We match:
01:02:39 <Cale> (a -> b -> b)
01:02:47 <Cale> with the type of smartCons, which is
01:02:48 <hotzen> Cale: im trying to understand
01:02:51 <Cale> elemTy -> [listTy] -> [NewListTy elemTy listTy]
01:03:12 <hotzen> yes
01:03:22 <Cale> So we generate the equations:  a ~ elemTy,  b ~ [listTy],  b ~ [NewListTy elemTy listTy]
01:03:53 <Cale> and then we can eliminate b, giving [listTy] ~ [NewListTy elemTy listTy]
01:04:22 <Cale> and then eliminate the list type constructor which appears on both sides, giving listTy ~ NewListTy elemTy listTy
01:04:57 <Cale> and a ~ elemTy here
01:05:09 <hotzen> thanks, will reread that, give me a minute
01:07:17 <Cale> foldr isn't willing to have the overall result type change on every list element, it forces the result of combining the rest of the list to have the same type as the result of combining the first element with that.
01:07:45 <Cale> That is, foldr f z xs and foldr f z (x:xs) have the same type :)
01:08:09 <hotzen> that makes sense
01:08:11 <Cale> and that's where the equality constraint is coming from
01:09:02 <hotzen> so it basically requires that the resulting type of every foldr f-call is a NewListTy ?
01:09:24 <Cale> It's saying that listTy has to be some type where if I smartCons on another element of type a, it's not going to change on me.
01:09:44 <Cale> Consider if you had the instance...
01:09:57 <Cale> instance SmartList Int Char where
01:10:08 <Cale>   type NewListTy Int Char = Double
01:10:10 <Cale>   ...
01:10:14 <hotzen> yes
01:10:23 <Cale> This would be unacceptable with that foldr
01:10:39 <Cale> because  smartCons :: Int -> [Char] -> [Double]  now
01:10:46 <hotzen> yeah
01:10:57 <hotzen> thats tricky stuff... without type-inference i would shoot me
01:11:35 <hotzen> thank you very much cale
01:11:43 <Cale> no problem
01:12:16 <Cale> You might consider trying to write a generalised foldr, but I don't think the constraint language is rich enough to express the type it ought to have
01:12:39 <Cale> Maybe it's impossible as a compile-time thing anyway
01:12:44 <geir> are there any haskell functions like "getpassword" that will not echo the typed password back to the terminal?
01:13:00 <Cale> :t hSetEcho
01:13:01 <lambdabot> Not in scope: `hSetEcho'
01:13:03 <Cale> er...
01:13:19 <Cale> :t System.IO.hSetEcho
01:13:20 <lambdabot> GHC.IOBase.Handle -> Bool -> IO ()
01:13:36 <Cale> hSetEcho stdin False  ought to disable the echo
01:13:36 <geir> thanks
01:14:00 <geir> Cale: thank you.. that would be what I'm after.
01:14:03 <Peaker> Cale, Probably possible with DT
01:15:34 <Cale> Yeah, you'd also need to express control over the length of the list, since the result type depends on that too now.
01:16:18 <Cale> (each element you tack on walks you around through a graph of types...)
01:17:19 <Peaker> Cale, Epigram's examples do a lot of that
01:18:06 <hotzen> DT?
01:18:07 <Cale> It should be less than an oleg of type system hackery to get a generalised  foldr smartCons  working, but generalising foldr itself to do something like that, I'm not so sure it's doable :)
01:19:24 <Cale> maybe :)
01:20:51 <vy> For instance, I can use foldl' in the current namespace, is it possible to gather which package supplies foldl' in ghci?
01:22:12 <Cale> vy: :info foldl'
01:22:15 <Peaker> hotzen, Dependent types -- instead of S->T functions, you have (s::S)=>T  functions where T is allowed to refer to "s"
01:22:27 <vy> Cale: Thanks!
01:22:40 <path[l]> what function would people recommend for comparing 2 lists element by element? A zipWith, followed by a fold?
01:22:42 <Peaker> hotzen, So the type of a function's result can vary based on the *value* of its argument
01:23:00 <hotzen> oh, thanks
01:23:01 <Peaker> path[l], (==) on lists?
01:23:11 <path[l]> oh does that work
01:23:24 <Peaker> hotzen, There are some research languages exploring the DT idea: Epigram, Agda, Coq, and more
01:23:28 <Cale> path[l]: What kind of element-by-element comparison are you talking about?
01:23:35 <Cale> > [1,2,3] == [1,2]
01:23:36 <lambdabot>   False
01:23:38 <Cale> > [1,2,3] == [1,2,3]
01:23:39 <lambdabot>   True
01:23:47 <Cale> > [1,2,3] == [1,4,3]
01:23:48 <lambdabot>   False
01:23:59 <path[l]> hmm well testing for equality sounds good enough. I didnt know -- works
01:24:04 <path[l]> I didnt see it on data.list
01:24:21 <Cale> path[l]: In the Prelude, there is an instance Eq a => Eq [a]
01:24:23 <Beelsebob> it's implemented as deriving Eq
01:24:26 <path[l]> ah
01:24:38 <path[l]> would there be an equivalent where I can choose my element comparator?
01:24:41 <Peaker> hotzen, There's an extremely nice mathematical relationship found by Curry and Howard, called the Curry Howard isomorphism -- that shows that functional types are logical propositions, and total values of those types are proofs of those propositions
01:24:48 <path[l]> so I pass in a function that acts on a a
01:24:59 <path[l]> and it operates on [a] [a]
01:25:14 <path[l]> (a -> a) -> [a] -> [a] -> bool
01:25:24 <hotzen> hm
01:25:30 <Peaker> path[l], You don't have to pass it in, the compiler finds out whether the contained type of the list has an Eq instance and if so passes it automaticlaly
01:25:43 <path[l]> well Im just using ints
01:25:50 <Cale> and (zipWith f xs ys)
01:26:00 <path[l]> hmm
01:26:00 <Beelsebob> > let comp f l l' = (all $ zipWith f l l') && length l == length l' in comp (>) [9,2,8] [4,1,1]
01:26:00 <romand> hi. I'm going to write client-server application and looking some some stateful protocol for communications (over tcp), with authentification and good support in haskell; any ideas?
01:26:01 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
01:26:01 <lambdabot>         against inferred ...
01:26:07 <Cale> path[l]: You mean (a -> a -> Bool) -> [a] -> [a] -> Bool
01:26:11 <Beelsebob> @type all
01:26:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:26:13 <path[l]> Cale: oops yes
01:26:18 <Peaker> hotzen, so in DT languages, they also use types to represent logical propositions, and pass around values of those types that act only as evidence (proof) that those propositions are true
01:26:18 <Beelsebob> > let comp f l l' = (and $ zipWith f l l') && length l == length l' in comp (>) [9,2,8] [4,1,1]
01:26:19 <lambdabot>   True
01:26:26 <Beelsebob> > let comp f l l' = (and $ zipWith f l l') && length l == length l' in comp (>) [9,2,8] [4,10,1]
01:26:26 <lambdabot>   False
01:26:48 <Cale> ah, the length test is important too, yeah
01:26:51 <Peaker> @type (==)
01:26:52 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:27:00 <path[l]> hmm zipwith doesn;t check for length equality but its not important for me actually
01:27:14 <path[l]> so I can go ahead with that
01:27:58 <blueonyx> hi, is there a function to check whether some element of
01:28:10 <path[l]> what I have is 2 ints and I wanna be sure that all elements are equal or all not equal
01:28:20 <path[l]> so Im thinking zipwith will give me all trues or all false
01:28:38 <Peaker> path[l], all elements are equal to either of your 2 ints?
01:28:38 <blueonyx> hi, is there a function to check whether some element of `getDirectoryContent`s is really a file?
01:28:45 <blueonyx> +result
01:28:58 <Peaker> @hoogle isFile --info
01:28:58 <lambdabot> No results found
01:29:17 <path[l]> no I mean its either a[i] == b[i] for all i or a[i] /= b[i] for all i
01:29:29 <Cale> romand: er, I'm not sure I understand that -- you don't care what protocol your client-server application uses? What's wrong with communicating authentication over plain TCP?
01:29:54 <path[l]> but actually nm, Im gonna think this through a bit more
01:30:03 <path[l]> Im letting whats there affect my design too much
01:30:28 <blueonyx> Peaker: yea tried that and FilePath -> Bool :(
01:31:31 <romand> Cale: I'd like to use existing implementation of such things as auth, states, etc
01:32:02 <path[l]> ok I have a style question. I have a function which takes a list AND a list of indices. It does some operation over each element using the index list. Which parameter should be first
01:32:17 <Peaker> blueonyx, FilePath -> IO Bool for sure :)
01:32:22 <romand> Cale: http + cookies over ssl is good, but may be someone knows even more simple approaches...
01:32:24 <blueonyx> yea got it ^^
01:32:41 <path[l]> so I mean I pass [1,2,3,4,5] and [2,4] and so my function takes the first list and squares elements at 2 and 4 giving me [1,4,3,16,5]
01:32:50 <blueonyx> thanks Peaker, its doesFileExist
01:32:53 <path[l]> so should the index list be first or second according to haskell convention
01:33:14 <Cale> path[l]: Arguments to a function always go in increasing order of rate of expected change
01:33:26 <path[l]> ah
01:33:27 <path[l]> ok
01:33:35 <path[l]> that answers my question here :)
01:33:47 <path[l]> so my index list is fixed but I pass many rows
01:33:53 <path[l]> so the rows should be the second parameter
01:33:56 <Cale> yeah
01:34:10 <path[l]> thanks, I think I see why too. Easier to partially apply
01:34:13 <Cale> yeah
01:35:44 <Peaker> path[l], you can compose that function from 2 simpler ones
01:35:45 <path[l]> yesterday someone mentioned a function which gives me indexes of a list. (I usually just zip the list with [1,2..]
01:35:57 <romand> seems no...
01:36:06 <path[l]> Peaker: oh? Can you tell me how?
01:36:11 <path[l]> :)
01:36:42 <Peaker> @let nth 0 f (x:xs) = f x : xs  ;  nth n f (x:xs) = x : nth (n-1) f xs
01:36:44 <lambdabot>  Defined.
01:36:51 <Peaker> path[l], first, this "nth" function is really useful in general
01:37:02 <Peaker> > nth 5 (*100) [1..10]
01:37:03 <lambdabot>   [1,2,3,4,5,600,7,8,9,10]
01:37:25 <path[l]> ah
01:37:40 <Cale> romand: Well, I'm not very aware of what networking stuff is available myself.
01:38:02 <opqdonut> i think it's cute how stuff like nth is like a state machine
01:38:02 <Peaker> path[l], then, you can   map nth yourIndexList -- then you can map ($(^2))  over the result, then you can  foldr (.) id   the resulting list of functions, and apply it to your source list
01:38:10 <opqdonut> many other list traversals too
01:38:15 <path[l]> but if I define nth and I use it on a long list. Wouldnt it keep counting from the beginning again and again?
01:38:30 <path[l]> I mean Im making a n^2 algorithm out of something I can do in n
01:38:42 <Peaker> path[l], Yeah, maybe you want an optimized nth for multiple n's
01:38:46 <Cale> romand: If it's a web application, you might try using something like happstack.
01:38:53 <path[l]> (in this case it matters since Im solving a contest problem)
01:39:04 <path[l]> hmm
01:39:19 <Cale> romand: I haven't really had a chance to play with that though, so I don't know what's there.
01:39:31 <Cale> http://happstack.com/docs/0.2/index.html
01:39:42 <path[l]> one more thing. Is there a recursive splitAt ?
01:40:02 <path[l]> so I can take a list of 10 items and break it into lists of size 2
01:40:14 <Cale> path[l]: There is in the split package on hackage
01:40:26 <Cale> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
01:40:36 <path[l]> oh hmmm no I cant use any non ghc packages
01:40:41 <path[l]> nm then
01:41:40 <path[l]> Im on one of those online coding sites and Im solving older problems and using it as an excuse to get used to haskell
01:41:41 <path[l]> lol
01:42:01 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1..10]
01:42:02 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
01:42:28 <mmorrow> , let ixs = let go _ [] _ = []; go _ _ [] = []; go n (i:is) (x:xs) | i < n = [] | i==n = x : go (n+1) is xs | otherwise = go (n+1) (i:is) xs in go 0 in ixs [0,3,29,99] ['a'..]
01:42:29 <lunabot>  "ad~\196"
01:42:39 <mmorrow> path[l]: or something i guess
01:43:06 <mmorrow> (i've actually needed that same function a few times lately)
01:43:12 <mmorrow> ..too
01:43:47 <romand> Cale: thanks! this helped a lot!
01:44:22 <path[l]> hmm trying to read it lol
01:44:27 <path[l]> Im slow at reading haskell yet
01:44:44 <mmorrow> it's nth, but does n at a time
01:44:50 <path[l]> ah
01:44:55 <kmc> > (\(+) -> 3 + 4) (*)
01:44:56 <lambdabot>   12
01:45:05 <mmorrow> @let ixs = let go _ [] _ = []; go _ _ [] = []; go n (i:is) (x:xs) | i < n = [] | i==n = x : go (n+1) is xs | otherwise = go (n+1) (i:is) xs in go 0
01:45:06 <lambdabot>  Defined.
01:45:11 <romand> although it is not web application, seems like happstack is good toolkit for writing serverware
01:45:20 <mmorrow> > ixs [0,42,9999,10000] [0..]
01:45:21 <lambdabot>   [0,42,9999,10000]
01:45:42 <kmc> @pl \(+) -> map ($ (+2))
01:45:42 <lambdabot> (line 1, column 3):
01:45:43 <lambdabot> unexpected "+"
01:45:43 <lambdabot> expecting pattern
01:47:06 <path[l]> aha I get it now
01:47:17 <path[l]> those are guards right? Im still not used to using those
01:47:27 <mmorrow> path[l]: hmm, you can ditch the "i < n" check actually there
01:47:32 <kmc> @pl \f -> map ($ (\x -> f x 2))
01:47:33 <lambdabot> map . flip id . flip flip 2
01:47:33 <path[l]> I tend to use where mostly instead of let
01:47:35 <mmorrow> err, actually no
01:47:43 <path[l]> oh?
01:47:45 <kmc> :t flip flip
01:47:46 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
01:47:47 <mmorrow> bah, maybe sort the list first
01:47:52 <path[l]> heh
01:48:01 <mmorrow> path[l]: because that assumes the list is sorted
01:48:06 <mmorrow> (it'd have to be)
01:48:08 <kmc> :t flip id
01:48:09 <lambdabot> forall b c. b -> (b -> c) -> c
01:48:11 <path[l]> assumes the list of n's is sorted?
01:48:15 <path[l]> Thats ok with me
01:48:15 <kmc> :t flip id . flip flip
01:48:16 <lambdabot> forall c a b c1. b -> (((a -> b -> c1) -> a -> c1) -> c) -> c
01:48:19 <mmorrow> the list of indeices
01:48:19 <kmc> :t flip id . flip flip ()
01:48:20 <lambdabot> forall c a c1. (a -> () -> c1) -> ((a -> c1) -> c) -> c
01:48:23 <path[l]> yeah
01:49:28 <path[l]> can you help me understand that line actually, the moddle bit
01:49:39 <path[l]> go n (i:is) (x:xs) | i < n = [] | i==n = x : go (n+1) is xs | otherwise = go (n+1) (i:is) xs
01:49:44 <mmorrow> @let ixs' is xs = let go _ [] _ = []; go _ _ [] = []; go n (i:is) (x:xs) | i==n = x : go (n+1) is xs | otherwise = go (n+1) (i:is) xs; js = dropWhile (< 0) (sort is) in go 0 js xs
01:49:45 <lambdabot>  Defined.
01:50:03 <mmorrow> gah!
01:50:16 <mmorrow> @let ixs'' is xs = let go _ [] _ = []; go _ _ [] = []; go n (i:is) (x:xs) | i==n = x : go (n+1) is xs | otherwise = go (n+1) (i:is) xs; js = filter (>= 0) (sort is) in go 0 js xs
01:50:17 <lambdabot>  Defined.
01:50:23 <mmorrow> > ixs [0,42,9999,3,negate 1000000,4,5] [0..]
01:50:24 <lambdabot>   [0,42,9999]
01:50:26 <mmorrow> > ixs'' [0,42,9999,3,negate 1000000,4,5] [0..]
01:50:27 <lambdabot>   [0,3,4,5,42,9999]
01:50:48 <mmorrow> (s/dropWhile/filter/)
01:50:58 <path[l]> is that go being defined with 3 cases?
01:51:03 <mmorrow> heh, actually dropWhile would work i guess, since we just sorted)
01:51:17 <mmorrow> err, 2 + 2
01:51:46 <path[l]> because it's in a single line I dont get how it works. When you do | i < n = [] | i ==n
01:51:51 <mmorrow> (2 in the third case, with the "| i==n = ... | otherwise = ..."
01:51:52 <mmorrow> )
01:52:02 <path[l]> does it mean the i < n has been defined and the i == n is a seperate case?
01:52:07 <mmorrow> it just looks odd one-linerized
01:52:18 <path[l]> ah
01:52:22 <mmorrow> foo x
01:52:28 <mmorrow>   | .. x .. = ..
01:52:31 <mmorrow>   | otherwise = ..
01:52:34 <john2009> hey any body there today
01:52:41 <mmorrow> foo x | .. x .. = .. | otherwise = ..
01:52:48 <path[l]> ah
01:53:00 <john2009> im john fro the us any body from the us
01:53:20 <path[l]> why does i < n not make a recursive call?
01:53:42 <mmorrow> i ditched that check, because it's unneeded now
01:53:45 <john2009> hey check this site out www.new-ages.yolasite.com
01:54:24 <john2009> http://www.new-ages.yolasite.com
01:54:26 <path[l]> hmm but what was it doing earlier?
01:54:33 <path[l]> I didnt understand it when you first used it
01:54:47 <john2009> www.my-website.yolasite.com
01:55:21 <john2009> http://www.my-website1.yolasite.com
01:55:32 <path[l]> oh
01:55:34 <path[l]> I see
01:55:42 <path[l]> i < n should never happen
01:56:12 <mmorrow> path[l]: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5082#a5082
01:56:17 <mmorrow> path[l]: right
01:56:24 <john2009> http://www.true-value.us
01:56:29 <path[l]> got it thanks
01:56:39 <mmorrow> @ops
01:56:39 <lambdabot> Maybe you meant: docs oeis pl
01:56:41 <mmorrow> @where ops
01:56:41 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
01:56:45 <john2009> hey anybody there
01:57:02 <john2009> hello people
01:57:06 <mmorrow> john2009: oh hai john2009!!!@
01:57:12 <john2009> any one in florida?
01:57:17 --- mode: ChanServ set +o dibblego
01:57:18 <mmorrow> everyone john2009!!
01:57:29 --- kick: john2009 was kicked by dibblego (dibblego)
01:57:39 <path[l]> hmm what does that mean when you do ixs is xs = ?
01:57:45 <path[l]> Ive not seen 'is' before
01:57:56 <mmorrow> that's just a variable name
01:58:02 <mmorrow> ah, right not the word "is"
01:58:12 <mmorrow> xs, ys, is, js
01:58:18 <mmorrow> convention for lists
01:58:20 <mmorrow> *s
01:58:20 <path[l]> oh
01:58:21 <path[l]> haha
01:58:22 <path[l]> sorry
01:58:25 <path[l]> that was dumb
01:58:33 <mmorrow> heh
02:00:03 <Peaker> path[l], http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13092#a13092
02:00:26 <Peaker> oh mmorrow already wrote "go" there
02:00:40 <Peaker> I called it funcsAt
02:01:12 <path[l]> heh yeah
02:01:27 <Peaker> but it doesn't seem to change the list in-place?
02:01:50 <path[l]> hmm actually yeah nth wont help me cause it wont change the list in place
02:02:12 <path[l]> anyway
02:02:16 <path[l]> Ill change it
02:02:17 <Peaker> s/in-place/returns-modified-list
02:02:21 <Peaker> path[l], funcsAt is what you need
02:02:27 <Peaker> path[l], or, (`funcAt` (^2))
02:02:27 <path[l]> yeah
02:02:49 <path[l]> but one question. whats an elegant way to get a recursive splitAt, I didnt understand the earlier solution
02:03:00 <path[l]> to take a list of m items and split it into lists of n items
02:03:07 <Peaker> you mean a splitsAt?
02:03:29 <Peaker> splitsAt :: [Int] -> [a] -> [[a]] ?
02:03:38 <path[l]> huh it exists?
02:04:07 <path[l]> I was gonna just define it using splitAt
02:05:08 <int-e> > let f n = map (take n) . takeWhile (not . null) . iterate (drop n) in f 5 [1..12]
02:05:09 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12]]
02:05:09 <lambdabot> int-e: You have 1 new message. '/msg lambdabot @messages' to read it.
02:06:07 <path[l]> splitsAt n [] = [], splitsAt n xs = ys:(splitsAt n zs) where (ys, zs) = splitAt n xs
02:07:16 <Peaker> path[l], no need for the () there
02:07:21 <path[l]> > let splitsAt n [] = []; splitsAt n xs = ys:(splitsAt n zs) where (ys, zs) = splitAt n xs in splitsAt 5 [1..12]
02:07:22 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12]]
02:07:32 <path[l]> which one?
02:07:39 <path[l]> oh for the splitsAt inside?
02:07:49 <Peaker> path[l], yeah, prefix precedence always stronger
02:07:56 <path[l]> > let splitsAt n [] = []; splitsAt n xs = ys: splitsAt n zs where (ys, zs) = splitAt n xs in splitsAt 5 [1..12]
02:07:57 <lambdabot>   <no location info>: lexical error at character '\FS'
02:08:13 <Peaker> path[l], I have:
02:08:14 <path[l]> it doesnt like it
02:08:38 <Peaker> @let gapList = gapList' 0 where gapList' _ [] = [] ; gapList' i (x:xs) = x-i : gapList' x xs
02:08:39 <lambdabot>  Defined.
02:08:47 <Peaker> > gapList [1,3,10,19]
02:08:48 <lambdabot>   [1,2,7,9]
02:08:58 <mmorrow> path[l]: you've got some weird character in that last expression you gave lambdabot
02:09:13 <mmorrow> , "splitA"
02:09:14 <lunabot>  luna: lexical error in string/character literal at character '\FS'
02:09:31 <path[l]> > let splitsAt n [] = []; splitsAt n xs = ys: splitsAt n zs where (ys, zs) = splitAt n xs in splitsAt 5 [1..12]
02:09:31 <lambdabot>   <no location info>: lexical error at character '\FS'
02:09:32 <Peaker> @let splitsAt = splitsAt' . gapList where splitsAt' [] xs = [xs] ; splitsAt' (i:is) xs = before : splitsAt' is after where (before, after) = splitAt i xs
02:09:33 <lambdabot>  Defined.
02:09:42 <mmorrow> path[l]: still there
02:09:48 <path[l]> wierd
02:09:53 <path[l]> must be my irc client
02:10:01 <Peaker> > splitsAt [5, 11, 13] "hello world! blah"
02:10:02 <lambdabot>   ["hello"," world","! ","blah"]
02:10:16 <mmorrow> .....sp<HERE>litAt n xs in splitsAt 5 [1..12]
02:10:25 <lomeo> @hoogle splitsAt
02:10:26 <lambdabot> No results found
02:10:26 <path[l]> oh no Peaker that wasnt what I wanted
02:10:31 <path[l]> I wanted what I built
02:10:39 <Peaker> path[l], Ah, just a chunkify
02:10:43 <path[l]> yeah
02:11:00 <path[l]> I didnt understand int-e 's solution of the same though
02:11:34 <path[l]> oh
02:11:36 <path[l]> iterate
02:11:38 <path[l]> now I see
02:11:56 <Peaker> > let chunks n = map (take n) . takeWhile (not . null) . iterate (drop n) in chunks 2 "hello world"
02:11:57 <lambdabot>   ["he","ll","o ","wo","rl","d"]
02:12:33 <path[l]> why is the takeWhile not null needed
02:12:40 <Peaker> > let chunks n = map (take n) . iterate (drop n) in chunks 2 "hello world"
02:12:41 <lambdabot>   ["he","ll","o ","wo","rl","d","","","","","","","","","","","","","","","",...
02:12:50 <path[l]> hmmm
02:12:53 <path[l]> ok
02:12:58 <path[l]> cause the original list is infinite
02:12:59 <path[l]> got it
02:13:02 <Peaker> path[l], iterate makes an infinite list, drop on empty list yields empty list again
02:13:14 <path[l]> thans
02:13:16 <path[l]> thanks
02:14:09 <Peaker> Using splitAt is slightly more efficient, possibly, because "drop n" and "take n" are both applied on the same list, which might be slower than just applying splitAt
02:14:20 <Peaker> but this definition is more elegant :)
02:14:24 <path[l]> heh
02:16:56 <Veinor> god, I hate joe arpaio
02:17:09 <Veinor> wrong channel
02:17:57 <int-e> > unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt 2)) "Hello, world!"
02:17:58 <lambdabot>   ["He","ll","o,"," w","or","ld","!"]
02:20:10 <kmc> :t liftM2 (>>)
02:20:11 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
02:21:07 <int-e> :t liftM2 (>>) ?a ?b ?x
02:21:08 <lambdabot> forall (m :: * -> *) a b t. (Monad m, ?a::t -> m a, ?b::t -> m b, ?x::t, Monad ((->) t)) => m b
02:22:45 <int-e> \x -> guard (not (null x)) >> return (splitAt 2 x)  would be clearer.
02:23:39 <int-e> perhaps rename x to xs to be more in line with Haskell conventions.
02:28:45 <quicksilver> Peaker: in fact, the take/drop version is faster, at least when it was tested last
02:28:54 <quicksilver> Peaker: probably it fuses better but that's only a guess
02:28:59 <Peaker> quicksilver, ah, cool.. though weird
02:29:32 <Peaker> quicksilver, maybe it has to do with the size of n too
02:29:45 <path[l]> heh interesting
02:30:06 <Peaker> for example, n=10000000 on a list whose length is n+1
02:30:44 <Peaker> We really need our coding environments to be able to visualize for us the optimizations that took place
02:30:59 <Eftarjin> hi. i'd like to build a .exe for my gtk2hs app so that windows users do not need to install GTK and other libs themselves. Does haskell have something like python's py2exe ?
02:31:34 <Peaker> Eftarjin, I think with py2exe and import gtk, you'd still need the C Gtk+ to be in place
02:31:58 <Peaker> (py2exe just puts the imported modules in there, and ghc statically links them in.  FFI'd code is still a dependency)
02:32:05 <Peaker> in both cases
02:33:13 <Eftarjin> Peaker: anyway to have maybe a (zipped) directory with everything? (some DLLs, ...)
02:33:44 <Peaker> Eftarjin, Maybe you can just have an installer that also installs Gtk?
02:33:49 <Peaker> Windows is so stone-age
02:36:41 <Eftarjin> the problem is i don't have privileges to install gtk system-wide on my school's computers (and i sure didn't choose their OS)
02:41:39 <path[l]> is there a simple ternary operator syntax for haskell
02:41:57 <ziman> :t if'
02:41:58 <lambdabot> forall t. Bool -> t -> t -> t
02:42:20 <Eftarjin> path[l]: if (condition) then (...) else (...) is an expression
02:42:30 <path[l]> ah
02:42:33 <ziman> this is the simplest way I know
02:43:08 <path[l]> if' is in ghc?
02:44:30 <ziman> @index if'
02:44:30 <lambdabot> bzzt
02:45:11 <ziman> hm, i don't know where if' is defined
02:47:03 <path[l]> hmm
02:48:36 <path[l]> here's what Im trying to do
02:48:37 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13094#a13094
02:48:41 <path[l]> its a ternary function
02:49:02 <path[l]> but right now its not even compiling meh
02:49:37 <path[l]> oops
02:49:41 <path[l]> extra =
02:51:07 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13094#a13095 <--- fixed but still ugly
02:51:11 <path[l]> how can I prettify that?
02:51:20 <Zariel> Hi all, im trying to make this split at interval S and not have s in the list, but I cant quite get it http://pastebin.com/d489c7136
02:52:50 <blackh> Zariel: What do you want it to do?
02:53:47 <Zariel> blackh: if i do, slit [1,2,3,4] 3, i want to return, [[1,2],[4]]
02:54:05 <blueonyx> path[l]: how about \xs ys -> xs == ys || xs == reverse ys ?
02:54:38 <blackh> Zariel: You won't be able to do that with a list comprehension.  You'll need to base it on 'break'
02:54:56 <path[l]> huh? doesnt reverse just reverse the list?
02:55:12 <blueonyx> > reverse [1,2,3]
02:55:13 <lambdabot>   [3,2,1]
02:55:30 <path[l]> I meant as in 1s become 0s and 0s become 1s
02:55:47 <path[l]> thats why I map with (1 - )
02:56:07 <blueonyx> oh sry
02:56:57 <ziman> path[l], what about this one? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13094#a13096
02:57:08 <Zariel> blackh: will that work if you have say, [ 1,2, 3, 4,5, 3, 6,7 ] -> [[1,2],[4,5],[6,7]] ?
02:58:03 <path[l]> ziman:  ah yeah, hmm. So double the time possibly but nicer looking. I'll try it then :). I can always revert if its too slow
02:58:18 <blackh> Zariel: You can write it using break and explicit recursion.  I can't think of any more elegant way of doing it (i.e. without explicit recursion).
02:58:53 <path[l]> probably shouldnt use flip. flip is a haskell function right?
02:59:16 <Botje> you yeah.
02:59:18 <ziman> path[l], well, there's another trick
02:59:23 <blackh> Zariel: Something like split [] _ = [] ; split xs s = let (h,t) = break (==s) xs in ....
02:59:26 <Botje> also, you can always rule out one case after one element
03:00:00 <Botje> so you could unroll it in two cases (equal or not equal) that each walk the list and return something else otherwise
03:00:04 <Botje> that'd be optimal.
03:00:08 <path[l]> Botje:  thats what I was trying to do at first, but it looked pretty sad.
03:00:22 <path[l]> any ways to write that elegantly
03:00:36 <ziman> if you're sure there will be only 0s and 1s
03:01:12 <ziman> ... I'll write it in the hpaste
03:01:35 <path[l]> yeah Im sure about the 0s and 1s
03:05:55 <Phyx-> hello, i'm using mapM_ (\a->inform _detail ("Cleaning '" ++ a ++ "'...") >> liftIO $ removeFile a) inside a stateT, now it does remove the file, but the feedback is never printed
03:06:51 <Phyx-> any ideas?
03:07:34 <Phyx-> full code is http://phyx.pastebin.com/d6c4e9993
03:08:28 <Phyx-> oops, i see a typo after asking
03:08:44 <Zariel> What type error am I doing wrong here ? http://pastebin.com/m7fa320a8
03:09:36 <Phyx-> yeah, ok, nvm, was a type, sorry :(
03:09:51 <Axman6> Zariel: look at the type of splitAt:
03:09:54 <Axman6> :t splitAt
03:09:55 <lambdabot> forall a. Int -> [a] -> ([a], [a])
03:10:10 <Axman6> you're giving it something of type a, not an int
03:10:28 <Zariel> ah i see
03:10:31 <Zariel> :t break
03:10:32 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:10:37 <Zariel> thats what i want
03:10:48 <Axman6> yep. though you'll need (== s)
03:11:05 <path[l]> how does $ precedence compare with :
03:11:07 <blackh> Zariel: I'll wait for your next version... :)
03:13:30 <Zariel> blackh: ^^ ill get haskell eventually
03:14:14 * hackagebot upload: ghc-paths 0.1.0.6 - Knowledge of GHC's installation directories (SimonMarlow)
03:15:54 <Zariel> Still type errors, cant spot them http://pastebin.com/d51075536
03:17:14 <ziman> path[l], this is what I meant: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13094#a13097
03:17:33 <blackh> Zariel: Your first 'break' returns a tuple ... but you're trying to create an element of [[a]], so it's expecting [a]
03:17:47 <blackh> Zariel: Do you need to use 'break' twice?
03:18:41 <path[l]> whats the null case for?
03:19:29 <ziman> path[l], for the empty list
03:19:36 <path[l]> ah
03:19:39 <ziman> > (null [], null [1,2])
03:19:40 <lambdabot>   (True,False)
03:20:32 <tibbe> dcoutts: ping
03:20:36 <path[l]> hmm
03:20:54 <Phyx-> ping failure
03:20:56 <path[l]> nice
03:21:28 <path[l]> I would modify it slightly
03:22:58 <Zariel> blackh: hm, i need to keep chopping the snd list incase it has the break point in it again, ie, [1,3,2,3,4]
03:23:01 <path[l]> wait diff is an incomplete map?
03:23:11 <path[l]> oh nm
03:23:36 <ziman> > zipWith (-) [1,2,3,4,5,100] [1,1,1,1,1,1]
03:23:37 <lambdabot>   [0,1,2,3,4,99]
03:23:41 <blackh> Zariel: Better is to do it once in your function and call 'split' recursively
03:24:41 <path[l]> how about this ziman
03:24:42 <path[l]> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13094#a13099
03:24:43 <Zariel> blackh: that way im making an infinite list which i dont want
03:25:15 <blackh> Zariel: You need a termination case, i.e. split [] _ = [] ; split xs s = ...
03:25:29 <ziman> Pthing, will that compile_
03:25:31 <ziman> oops
03:25:36 <ziman> path[l], will that compile_
03:25:47 <path[l]> checking =p
03:26:03 <Zariel> blackh: that still makes it infinite
03:26:45 <ziman> hm, i hit capslock instead of "a", which hilighted pth* instead of path* -- and changed my keyboard layout :)
03:27:02 <Pthing> a lesson in being too clever
03:27:05 <blackh> Zariel: No... it's not infinite. It'll just pull loop round once for each output chunk.
03:27:45 <Zariel> Occurs check: cannot construct the infinite type: a = [a]
03:27:49 <blackh> Zariel: I meant to say... it'll just loop round once ...
03:28:32 <blackh> Zariel: "Occurs check" means that when the compiler tried to infer the types of your code, it concluded that you were saying that a = [a]...
03:28:50 <blackh> Zariel: And this means that you need to find out where you're giving [a] instead of a or vice versa.
03:28:55 <Zariel> shouldnt have the ': []'
03:29:07 <fasta> Is it supposed to be possible to initialize a Haskell library, deinitialize it and load it again with dlopen/loadlibrary like functions?
03:29:10 <Zariel> it works, except for the case of [1,2,3,4,3,5]
03:29:39 <ziman> path[l], you need "map abs" there because the user can exchange xs and ys; furthermore, the second argument of "all" must be a list, not a number -- and you forgot to change "uniform" to "equals" in the guards
03:30:05 <blackh> Zariel: Well, that's got to be a good thing!
03:31:09 <Zariel> blackh: yep :) just need to fix the recursion
03:33:25 <boogyman> Twey, if you're lurking can you please PM me
03:34:58 <Zariel> blackh: how can I pattern match S out of snd x' when S is always the head ?
03:36:12 <blackh> Zariel: You'll need to say something like let (h,t) = break (== s) xs in h:split (drop 1 t) s
03:36:41 <blackh> Zariel: You can assume that the second value returned by break is either [s, ...] or []
03:36:54 <blackh> Zariel: 'drop 1' is like a safe version of 'tail'
03:39:18 <Zariel> yeah just ran into the ugly tail
03:40:12 <Zariel> blackh: awesome <3 thanks so much
03:40:55 <blackh> Zariel: No worries - I know Haskell is strange but stick at it - it's worth it!
03:41:36 <Zariel> im not used to having to use so much from the prelude
03:42:04 <Zariel> blackh: 4 lines of code took almost 3 hours to figure out lol ..
03:43:05 <ppavelV6> haskell is not strange. It's just a slight feeling that will go away in less then 5 years, relax :)
03:43:17 <Zariel> :)
03:46:34 <Zariel> :src words
03:46:39 <Zariel> @src words
03:46:39 <lambdabot> words s = case dropWhile isSpace s of
03:46:39 <lambdabot>     "" -> []
03:46:39 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
03:47:52 <Axman6> hmm, wonder why they didn't make it "" -> ""
03:48:19 <Axman6> oh wait, never mind
03:48:41 <ivanm> Axman6: I _might_ be in canberra on saturday
03:48:43 <ivanm> on a flying visit
03:49:01 <RayNbow> hmm... pattern guards are changed for Haskell 2010?
03:49:22 <Axman6> nice. let me know if you know any closer to saturday any plans you've got
03:50:51 <vic_> @src map
03:50:51 <lambdabot> map _ []     = []
03:50:52 <lambdabot> map f (x:xs) = f x : map f xs
03:52:26 <vic_> @src dropWhile
03:52:26 <lambdabot> Source not found. Maybe you made a typo?
03:53:31 <vic_> !help
03:54:16 <vic_> > dropWhile (<4) [1,2,4,5,6,8,13,15]
03:54:18 <lambdabot>   [4,5,6,8,13,15]
03:54:43 <ivanm> @list
03:54:44 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:54:46 <ivanm> @help list
03:54:47 <lambdabot> list [module|command]
03:54:47 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
03:54:50 <ivanm> vic_: ^^
03:54:56 <dancor> @pl \ (a, (b, c)) -> (f a b, c)
03:54:56 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . f)
03:54:56 <vic_> ivanm: thanks ;-)
03:55:07 <vic_> I was reading the wiki atm
03:55:10 <dancor> @pl \ (a, (b, c)) -> ((a, b), c)
03:55:10 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))
03:55:29 <vic_> I should install it locally, but I'm too lazy
03:55:46 <ivanm> heh
03:56:30 <vic_> Hmmm ...  @src dropWhile doesn't work? It's not in Prelude?
03:56:46 <ivanm> why did they include FFI into Haskell 2010?  I thought it was already in the revised report for 98...
03:57:26 <fasta> ivanm, addendum.
03:57:38 <ivanm> ahhh
03:57:43 <ivanm> so now its officially official?
03:57:44 <fasta> ivanm, Haskell 98 and Haskell 98 + Addendum are two different things.
03:57:57 <fasta> ivanm, what is "official"?
03:58:15 <zygoloid> hold on, is haskell 2010 out?
03:58:23 <vic_> Not yet
03:58:40 <opqdonut> is haskell 2010 haskell prime?
03:58:41 <ivanm> zygoloid: the official report will be out in a couple of months
03:58:53 <fasta> ivanm, where is the current report?
03:58:55 <ivanm> fasta: so its in an actual language spec/report rather than an "extension" to one
03:59:07 <fasta> ivanm, I mean the one which is "in progress".
03:59:12 <Axman6> Haskell 2010 /= Haskell'?
03:59:14 <opqdonut> ah, seems so
03:59:20 <ivanm> fasta: http://hackage.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&state=accepted&milestone=Haskell+2010&order=priority
03:59:25 <opqdonut> Axman6: haskell 2010 is the first release by the haskell' workgroup
03:59:26 <ivanm> Axman6: first step of Haskell'
03:59:30 <fasta> ivanm, yes, but I don't care about those qualifications.
03:59:37 <ivanm> Axman6: the new approach is that they have a new revision each year IIRC
03:59:41 <ivanm> with only small changes in each one
03:59:44 <opqdonut> sounds really good
03:59:47 <ivanm> evolutionary rather than revolutionary
04:00:05 <Axman6> sounds like a good plan
04:00:25 <vic_> sounds like'
04:00:31 <ivanm> so, what does this new do-if-then-else syntax look like?
04:00:47 <ivanm> do if b then; etc.?
04:01:18 <Axman6> do if x then y;?
04:01:33 <quicksilver> do if x ;then y; else z
04:01:36 <quicksilver> both ; are optional
04:01:41 <ivanm> right
04:01:49 <ivanm> quicksilver: but non-optional if you want funky indentation?
04:01:52 <Axman6> what's the point?
04:02:00 <quicksilver> ivanm: your question makes no sense ;)
04:02:03 <quicksilver> ivanm: they are optional.
04:02:13 <quicksilver> you're asking "are they non-optional if I use them?"
04:02:23 <quicksilver> well, if you use them, then you've chosen that option ;)
04:02:30 <ivanm> quicksilver: I know, but how would the example on the proposal look?
04:02:33 <ivanm> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
04:02:42 <quicksilver> Axman6: so that stupid people can write do if x \n then y \n else z
04:02:50 <fasta> The only controversial change I see are Pattern Guards in 2010.
04:02:55 <ivanm> quicksilver: as in, how specifically does it fix that layout/indentation?
04:03:06 * RayNbow notices he misread the Pattern Guards wiki entry... "syntax" referred to the H98 syntax...
04:03:16 <quicksilver> ivanm: because layout is sugar for semicolons.
04:03:26 <fasta> I have the impression they are like implicit parameters. Nobody uses them.
04:03:48 <ivanm> quicksilver: OK, so now then and else don't have to be indented further in a do block?
04:04:03 <ivanm> that would make the person bitching about it here yesterday happy...
04:04:07 <ivanm> ;-)
04:04:34 <quicksilver> ivanm: correct.
04:04:42 <quicksilver> ivanm: because not indenting them is putting a ; in
04:04:48 <quicksilver> and putting a ; in is now allowed :)
04:04:55 <ivanm> *nod*
04:05:38 <quicksilver> to be honest, I don't really like it because I think it makes layout harder to explain
04:05:42 <quicksilver> (by adding a special case)
04:05:56 <quicksilver> and by the time you've explained it, including the special case, you might as well have explained how to do it the old way.
04:06:19 <quicksilver> however I respect the fact that a committee of people smarter than me had to make a decision, and they made one
04:06:28 <quicksilver> and I'd rather have progress than not :)
04:06:28 <ivanm> heh
04:07:01 <ivanm> the reason you (still) need to indent then and else further is to emphasise that they're part of the same expression, right?
04:07:19 <ivanm> whereas in do blocks each new line indented to the same amount is a new expression/statement
04:07:25 <path[l]> whats wrong with this code score xs | -1 `elem` xs = -1 | otherwise = foldl' (1+) 0 xs
04:07:46 <Axman6> path[l]: (-1)
04:07:48 <ivanm> path[l]: brackets around the -1 ?
04:07:50 <zygoloid> path[l]: unary negate is evil
04:07:55 <path[l]> oh
04:08:01 <ivanm> zygoloid: IIUC, a necessary evil
04:08:06 <ivanm> unless you special case it everywhere
04:08:17 <path[l]> bah lol
04:08:30 <zygoloid> though it's not actually the problem here
04:08:43 <ivanm> hmmm.... with the line comment syntax change, does this mean all my --: , --; , etc. operators will no longer work in 6.14? :p
04:08:44 <zygoloid> -1 `elem` xs == (-1) `elem` xs
04:08:55 <quicksilver> ivanm: when you say 'still'...
04:09:03 <quicksilver> ivanm: in haskell 2010 you don't need to indent then and else further.
04:09:20 <ivanm> quicksilver: well, it's "still" because no compiler yet supports 2010
04:09:27 <zygoloid> path[l]: what's wrong with it is that (1+) isn't a binary operator
04:09:32 <ivanm> whereas with 2010 you won't _have_ to
04:09:36 <zygoloid> path[l]: did you mean foldl' (+) 0 xs?
04:09:50 <zygoloid> (if so, did you mean sum xs?)
04:09:59 <path[l]> oh yeah I meant sum
04:10:01 <path[l]> oops
04:10:02 <path[l]> wierd
04:10:07 <path[l]> thanks
04:10:10 <path[l]> I dunno why I used 1
04:10:38 <zygoloid> path[l]: so you could trick us into lambasting unary negation?
04:10:46 <path[l]> lol
04:12:16 <RayNbow> ivanm: as far as I understand it, line comment syntax change is to allow --: as an operator
04:12:26 <RayNbow> the H98 report considered it as a comment
04:12:29 <ivanm> oh, it does allow it now?
04:12:34 <ivanm> damn, my facetious comment fell flat on its face...
04:13:22 <Veinor> @pl \x -> f x == x
04:13:22 <lambdabot> (==) =<< f
04:13:22 <ivanm> hang on, so MMR is still in? :(
04:13:32 <Veinor> ok, I don't understand that at all so I'm not going to use it
04:13:42 <path[l]> what does this mean -> No instance for (Num [Int])
04:13:59 <zygoloid> ivanm: M? has the insult been upgraded from Damned?
04:14:10 <ivanm> path[l]: you're trying to do something like [1,2] + [3]
04:14:18 <ivanm> zygoloid: heh
04:14:24 <ivanm> Mono-Morphism Restriction
04:14:27 <ivanm> or is it just MR ?
04:14:37 <zygoloid> monomorphism is one word
04:14:44 <path[l]> hmm
04:15:04 <Veinor> @pl \f x -> fromJust $ find (\x -> f x == x) $ iterate f x
04:15:04 <lambdabot> (fromJust .) . ap ((.) . find . ((==) =<<)) iterate
04:15:06 <ivanm> zygoloid: hmmm, I thought I'd seen it referred to as MMR...
04:15:12 <zygoloid> DMR?
04:15:18 <ivanm> maybe I'm getting it mixed up with Measles, Mumps and Rubella... ;-)
04:15:33 <zygoloid> well, haskell' could use a DMR vaccine...
04:16:37 <ivanm> s/use/contain/
04:17:39 <Veinor> @pl \a b -> f $ g $ h a b
04:17:39 <lambdabot> ((f . g) .) . h
04:17:51 <Veinor> @unpl f . g . h
04:17:51 <lambdabot> (\ c -> f (g (h c)))
04:18:09 <Veinor> @pl \a b -> f (g (h a b))
04:18:09 <lambdabot> ((f . g) .) . h
04:18:17 <Veinor> @src .
04:18:17 <lambdabot> (f . g) x = f (g x)
04:22:21 <Veinor> @unpl (f . g .)
04:22:22 <lambdabot> (\ a i -> f (g (a i)))
04:22:33 <Veinor> @unpl (f . g)
04:22:33 <lambdabot> (\ c -> f (g c))
04:22:39 <Veinor> ahhh.
04:22:50 <vy> Is there any Haskell equivalent of #\Newline character variable in Common Lisp?
04:23:15 <ivanm> anyone know if its possible to re-direct the output of QuickCheck?
04:23:25 <ivanm> I want to save the failed data value it generates to file
04:26:11 <ivanm> (that is, I want to do it within the program that runs quickCheck)
04:30:56 <RayNbow> vy: what are you trying to do?
04:36:54 <vy> RayNbow: Instead of doing '\n':xs, I'd like replace '\n' with a portable character. (Trying to implement "unlines" on my own.)
04:37:12 <ivanm> vy: see the split package
04:38:26 <ivanm> vy: note that in Haskell, unless you read in a windows file in linux or something, then the IO functions convert all new-line types to '\n'
04:40:22 <SamB_XP_> ivanm: that's hardly unique to Haskell ;-P
04:40:52 <ivanm> SamB_XP_: well, it's the only thing I can think of by what vy refers to as a #\Newline character variable in Common Lisp
04:41:21 <SamB_XP_> ivanm: I meant the newline translation
04:41:32 <ivanm> I know you did
04:41:54 <SamB_XP_> C has the same thing ...
04:41:57 <ivanm> but the usage of such a variable sounds to me as if Common Lisp doesn't do that at read/write time...
04:52:43 <blueonyx> @info liftIO
04:52:43 <lambdabot> liftIO
04:53:01 <blueonyx> :i lifIO
04:53:02 <SamB_XP_> ivanm: yeah, I guess not
04:53:22 <SamB_XP_> ivanm: well, actually, wait
04:53:35 <SamB_XP_> is #\Newline a variable ?
04:54:05 <SamB_XP_> it looks like a reader macro to me ...
04:54:16 <SamB_XP_> grrrrr.
04:54:36 <blueonyx> where is liftIO defined?
04:54:44 <ivanm> SamB_XP_: vy called it a variable
04:54:44 <ivanm> @hoogle liftIO
04:54:44 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
04:54:45 <SamB_XP_> where can I get a search engine that can handle punctuation characters as essential components of the searched-for text ?
04:54:49 <ivanm> blueonyx: ^^
04:55:00 <ivanm> SamB_XP_: the one that you write
04:55:01 <blueonyx> yea hoogle -.-
04:55:01 <ivanm> ;-)
04:55:24 <SamB_XP_> ivanm: I don't have anywhere near enough computers to run a search engine on
04:55:37 <ivanm> heh
04:55:44 <ivanm> then buy some more!
04:55:59 <path[l]> is there a map and zip?
04:56:09 <SamB_XP_> I'd have to do something evil like write a worm that turns my school's computer lab machines into a search-engine botnet
04:56:22 <SamB_XP_> ivanm: with what money ?
04:56:40 <mmorrow> SamB_XP_: the money you make from your botnet, duh
04:57:24 <path[l]> I want to take x and get zip of x f(x), but I want x to be cached :/
04:58:02 <SamB_XP_> anyway, to make a botnet that way, I'd first have to learn all sorts of malware delivery stuff
04:58:02 <mmorrow> what do you mean "cached"?
04:58:23 <mmorrow> SamB_XP_: they say there's no free lunch..
04:58:34 <SamB_XP_> path[l]: zipWith ?
04:58:40 <path[l]> well x itself comes from a where clause. I just wanna make sure it doesnt calculate f twice
04:58:45 <SamB_XP_> no, waity
04:58:59 <SamB_XP_> @type (id &&& ?f)
04:59:00 <lambdabot> forall b c'. (?f::b -> c') => b -> (b, c')
04:59:15 <mmorrow> path[l]: (\f -> let x = 1 + 1 in (f x, f x)) will compute "f x" twice
04:59:27 <path[l]> hmm
04:59:31 <dcoutts> tibbe: pong
04:59:31 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:00:12 <mmorrow> path[l]: if you don't want to do that, and you've got a list, you'd need to either nub (or equiv) the list, or keep a Map/something of values as you fold over the list, and first check the Map before doing "f x"
05:00:16 <SamB_XP_> path[l]: you mentioned map ... so where does that come in ?
05:00:50 <path[l]> well I have xs and I wanna zip xs with the f(x)s
05:00:59 <path[l]> so I have to map f over xs
05:01:05 <path[l]> and zip with xs
05:01:12 <SamB_XP_> ivanm: it seems #\Newline is just a character value in CL
05:01:35 <mmorrow> @type (\f xs -> zip xs (fmap f xs))
05:01:36 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
05:01:37 <mmorrow> ?
05:02:11 <SamB_XP_> ivanm: that's what I get out of http://www.franz.com/support/tech_corner/anynewline-011507.lhtml anyhow
05:02:17 <mmorrow> path[l]: that doesn't prevent computing "f x" multiple times for a given value of "x" if there are duplicates in "xs" though
05:02:27 <path[l]> oh no
05:02:32 <path[l]> thats not what I meant
05:02:47 <path[l]> anyway nm for now :)
05:02:52 <mmorrow> ah, in that case is (\f xs -> zip xs (fmap f xs)) what you want?
05:02:52 <SamB_XP_> @type map (id &&& f)
05:02:53 <lambdabot> forall a c'. (Show a, SimpleReflect.FromExpr c') => [a] -> [(a, c')]
05:02:53 <ivanm> SamB_XP_: *shrug*
05:03:02 <SamB_XP_> @type map (id &&& ?f)
05:03:03 <lambdabot> forall a c'. (?f::a -> c') => [a] -> [(a, c')]
05:03:03 <path[l]> whats fmap
05:03:10 <mmorrow> map
05:03:16 <mmorrow> @src [] fmap
05:03:16 <lambdabot> fmap = map
05:03:24 <path[l]> why the other name
05:03:29 <mmorrow> @src Maybe fmap
05:03:29 <lambdabot> fmap _ Nothing       = Nothing
05:03:29 <lambdabot> fmap f (Just a)      = Just (f a)
05:03:29 <SamB_XP_> fmap is just the new name for the map method from Functor
05:03:37 <mmorrow> @src Tree fmap
05:03:37 <lambdabot> Source not found. stty: unknown mode: doofus
05:03:38 <path[l]> oh
05:03:50 <SamB_XP_> where by new, I mean 11 years old
05:03:51 <mmorrow> fmap f (Node x xs) = Node (f x) ((fmap . fmap) f xs)
05:03:56 <mmorrow> (Tree)
05:03:59 <path[l]> I normally use the map of list
05:04:07 <path[l]> or prelude
05:04:11 <SamB_XP_> that's certainly longer than I've been using Haskell ;-)
05:04:20 <mmorrow> i use fmap out of habit at this point
05:04:42 <mmorrow> @type fmap :: (a -> b) -> ([a] -> [b])
05:04:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:04:47 <mmorrow> @type fmap :: (a -> b) -> (Tree a -> Tree b)
05:04:48 <lambdabot> forall a b. (a -> b) -> Tree a -> Tree b
05:04:54 <mmorrow> @type fmap :: (a -> b) -> (Maybe a -> Maybe b)
05:04:55 <lambdabot> forall a b. (a -> b) -> Maybe a -> Maybe b
05:05:02 <mmorrow> @type fmap :: (a -> b) -> (IO a -> IO b)
05:05:03 <lambdabot> forall a b. (a -> b) -> IO a -> IO b
05:05:03 <mmorrow> etc
05:05:03 <ivanm> mmorrow: but do you use Caleskell where (.) = fmap, map = fmap, etc.? :p
05:05:07 <mmorrow> nevar
05:05:08 <SamB_XP_> ... and in this case I think the Haskell 98 commitee didn't make a big mistake
05:05:22 <SamB_XP_> unlike, say, the MR
05:05:35 <path[l]> how do I create an ordering value
05:05:37 <SamB_XP_> the MR is just so evil, and it's very tricky to implement too
05:05:41 <path[l]> with say 1 and 2
05:05:56 <mmorrow> , compare 1 2
05:05:57 <lunabot>  LT
05:06:01 <path[l]> oh compare
05:06:01 <SamB_XP_> > 1 `compare` 2
05:06:02 <lambdabot>   LT
05:06:04 <path[l]> ok
05:06:11 <path[l]> thanks
05:07:41 <SamB_XP_> > map (compare `on` (negate . length . show &&& id)) [1..] [2..]
05:07:42 <lambdabot>   Couldn't match expected type `[t1] -> t'
05:07:42 <lambdabot>         against inferred type `[a ...
05:07:56 <SamB_XP_> > map (compare `on` ((negate . length . show) &&& id)) [1..] [2..]
05:07:57 <lambdabot>   Couldn't match expected type `[t1] -> t'
05:07:57 <lambdabot>         against inferred type `[a ...
05:08:08 <SamB_XP_> > zipWith (compare `on` ((negate . length . show) &&& id)) [1..] [2..]
05:08:09 <lambdabot>   [LT,LT,LT,LT,LT,LT,LT,LT,GT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT...
05:08:20 <SamB_XP_> hmm ...
05:08:34 <SamB_XP_> oh, there is a GT in there every so often, good ;-)
05:09:06 <ivanm> anyone know how I can get the data-structure that caused the quickcheck failure out within the code that runs quickCheck?
05:09:26 <mmorrow> :o
05:09:27 <SamB_XP_> ivanm: no clue :-(
05:09:32 <ivanm> e.g. I have a testing app, and I'd like to save all test failures to a file to be able to play with by hand
05:09:33 <ivanm> SamB_XP_: :(
05:10:00 <SamB_XP_> well, getting them saved to a file is probably easier than getting them in Haskell-minipulable form ...
05:10:09 <ivanm> SamB_XP_: right
05:10:16 <mmorrow> ivanm: i'm not familiar enough with quickcheck, but if it's not possible as-is, you could always hack quickcheck itself to do it
05:10:21 <ivanm> but the only way I can figure it out is to brute-force redirect all std-out to file
05:10:33 <ivanm> mmorrow: I'd rather not fork it ;-)
05:10:42 <SamB_XP_> ugh.
05:10:47 <SamB_XP_> @go quickcheck
05:10:47 <lambdabot> Maybe you meant: google googleit do
05:10:51 <fasta> ivanm, quickcheck is only 300 lines; everyone has forked it already ;)
05:10:52 <SamB_XP_> @google quickcheck
05:10:53 <lambdabot> http://www.quick-chek.com/
05:10:53 <lambdabot> Title: Quick Chek
05:11:09 <SamB_XP_> some kind of fast food :-(
05:11:22 <SamB_XP_> oh, convenience store
05:11:24 <mmorrow> ivanm: you'd just be making your own custom copy, "fork" is a rather strong word for that..
05:11:33 <ivanm> :o QC is now a commercial product? :o http://quviq.com/
05:11:47 <Veinor> what is this 'qc' of which you speak?
05:12:06 <ivanm> mmorrow: right, then I'd have to embed my custom copy into the lib tarball just in case anyone wants to run my tests...
05:12:09 <ivanm> Veinor: QuickCheck
05:12:15 <ivanm> @where QuickCheck
05:12:15 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
05:12:17 <SamB_XP_> ivanm: no, notice the spelling -- also it's unrelated except sounding similar
05:12:35 <SamB_XP_> ivanm: oh, that
05:12:36 <ivanm> SamB_XP_: it _is_
05:12:37 <fasta> ivanm, it has been for a long time.
05:12:41 <SamB_XP_> so what?
05:12:42 <mmorrow> ivanm: the license is bsd3 iirc..
05:13:00 <ivanm> is that why it isn't being developed anymore (in terms of the version on hackage)?
05:13:13 <ivanm> I take that back...
05:13:18 <ivanm> last upload was in September :s
05:13:34 <fasta> ivanm, QuickCheck 1 and 2 are by different authors, AFAIK.
05:13:44 <SamB_XP_> ivanm: I think it's safe to say that that isn't causing us any problems
05:13:51 <SamB_XP_> the commercial one isn't for Haskell, afaict
05:14:09 <SamB_XP_> I mean, why else would they bother to mention that that ours is ?
05:15:05 <ivanm> fasta: all the version on hackage have "Koen Classen" as an author
05:15:11 <ivanm> though version 1 has John Hughes as well
05:15:18 <ivanm> SamB_XP_: well, they mention Haskell on their site
05:15:23 <ivanm> but seem to focus more on Erlang and C
05:16:09 <ivanm> mmorrow: so what did you get your custom copy of quickcheck to do?
05:16:13 <fasta> ivanm, ah, ok. It must have been one of those academic cooperations in which the professor gets the credits for doing the work of whoever is below him/her.
05:16:16 * ivanm finds the QC code rather hard to read...
05:16:20 <ivanm> fasta: heh
05:16:42 <SamB_XP_> fasta: I don't think so
05:16:45 <Phyx-> bah, sometimes i think the typechecker just wants to screw with me
05:16:58 <fasta> SamB_XP_, what?
05:17:16 <SamB_XP_> well, it looks like Hughes is involved with QuviQ
05:17:26 <fasta> SamB_XP_, yes, I know that.
05:17:36 <fasta> SamB_XP_, it is his business.
05:17:53 <mmorrow> ivanm: i don't have my own custom quickcheck, but i have my own version of a bunch of other things
05:18:01 <SamB_XP_> well, so why do you think one of them was just getting credit ?
05:18:04 <mmorrow> ivanm: whatever you need it to do
05:18:15 <SamB_XP_> or was there a third name that you were speaking of ?
05:18:16 <fasta> SamB_XP_, just to be clear: I don't actually know it in this case. I was just making generalisations.
05:18:32 <SamB_XP_> fasta: well, sure, that happens a lot, yes
05:18:45 <SamB_XP_> sometimes I think they just get SPJs name on stuff so people will read it ;-P
05:19:53 <ivanm> mmorrow: well, sjanssen convinced me that my test suite should be released with graphviz
05:20:06 <ivanm> but if I customise QC, then I'd have to include that custom version...
05:20:30 <ivanm> hmmmm.... anyone know what the point of labels in QC2 is?
05:20:31 <mmorrow> ivanm: you can't have your cake and eat it too :)
05:21:01 <SamB_XP_> ivanm: perhaps the customizations don't need to take place within the test suite ?
05:21:22 <SamB_XP_> or, that is, perhaps the test suite doesn't need to know one way or the other?
05:21:32 <ivanm> mmorrow: heh
05:21:36 <mmorrow> ivanm: if what you need quickcheck to do is important enough that it warrants you to hack it and include the hacked version in your code, i say go for it
05:21:44 <ivanm> SamB_XP_: so under-the-hood stuff just for me to hack with?
05:22:37 <SamB_XP_> ivanm: I was thinking more like "write a seperate patch to add the stuff you want to QuickCheck" + "make it so that only the test-running script needs to care"
05:22:40 <mmorrow> ivanm: i think the decision should only be made on the basis of cost/benefit
05:22:44 <mmorrow> to you
05:22:57 <ivanm> mmorrow: *nod*
05:23:13 <SamB_XP_> not the individual test properties
05:23:13 <ivanm> ideally, it shouldn't matter after I release it because there _won't_ be any bugs... ;-)
05:23:35 <SamB_XP_> ivanm: the quickcheck properties should be useful documentation, however ;-)
05:23:42 <ivanm> SamB_XP_: right
05:24:31 <SamB_XP_> it's always nice to know the identities that are supposed to hold for a given library ;-)
05:24:31 <ivanm> is there any way of overriding instances defined elsewhere?
05:24:39 <SamB_XP_> no :-(
05:24:47 <SamB_XP_> what for?
05:25:04 <ivanm> SamB_XP_: to override QC's instance of Arbitrary for lists
05:25:33 <SamB_XP_> anyway, QuviQ's QuickCheck is apparantly written in Erlang, fwiw...
05:26:19 <SamB_XP_> there are some combinators to use a different generator than the Arbitrary ones, I believe
05:26:22 <shambler> http://www.infoq.com/interviews/Erlang-Haskell-John-Hughes
05:27:30 <quicksilver> ivanm: all the compilers support DoIfThenElse
05:27:44 <Phyx-> hmm.. this is odd... why does importing a module with a wrong name (eg. i have one named Test.Foo) and i do import (TEst.Foo) does ghc give the error in Test.Foo instead of in the file i did import
05:28:43 <SamB_XP_> Phyx-: are you on Windows ?
05:29:20 <Phyx-> SamB_XP_: yeah
05:45:10 <ivanm> Phyx-: case insensitivity perhaps?
05:45:10 <Eftarjin> hi. is it possible to make ghc compile libs (eg libc, libpcre, ...) statically ? (-static doesn't seem to do that)
05:45:10 <ivanm> Eftarjin: IIRC, glibc is one of the few it can't link to statically
05:45:10 <Phyx-> ivanm: right mostlikely why it found the file, but i would still expect the error to be in the file doing the import, since the filename (Test.Foo) did match it's module declaration (Test.Foo aswell) so it would seem to me the error ghc generates should not say Test\Foo.hs:23:3: <etc>
05:45:10 <Eftarjin> ivanm: maybe some other was to compile on a system and run on another with different version of libs?
05:45:10 <Eftarjin> some other way*
05:45:10 <ivanm> nope, not that I know of
05:45:10 <path[l]> hmm how do I map [True,False, False...] to [1,0,0, succintly
05:45:10 <path[l]> true becoming 0 and 1 becoming fals
05:45:10 <path[l]> e
05:45:10 <Phyx-> as it stands, i took me a while to realize it was the import in the *other* file that was wrong after scratching my head at the error
05:45:10 <fasta> Phyx-, I think bugs like those are already reported.
05:45:10 <Zao> > map fromEnum [True, False, False, True]
05:45:10 <lambdabot>   [1,0,0,1]
05:45:10 <fasta> Phyx-, UI bugs, that is.
05:45:10 <Zao> path[l]: ^
05:45:10 <path[l]> fromEnum ?
05:45:10 <path[l]> hmm
05:45:10 <Zao> Err, fromEnum . not
05:45:10 <path[l]> > fromEnum True
05:45:10 <lambdabot>   1
05:45:10 <path[l]> > fromEnum False
05:45:10 <lambdabot>   0
05:45:10 <path[l]> I see
05:45:10 <Phyx-> fasta: ah ok , cool
05:45:10 <path[l]> thanks :)
05:45:10 <Zao> > succ False
05:45:10 <lambdabot>   True
05:45:10 <Zao> > succ True
05:45:10 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
05:45:10 <Zao> True is enumerable, with two values.
05:45:10 <Phyx-> :t succ
05:45:10 <lambdabot> forall a. (Enum a) => a -> a
05:45:10 <Zao> Err, Bool.
05:45:10 <Zao> @src Bool
05:45:10 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:45:10 <Asztal> It has Read, Show, Enum, and Bounded instances too
05:45:10 <tibbe> dcoutts: is there a working cabal for testing 6.12?
05:45:10 <fasta> tibbe, yes
05:45:10 <fasta> tibbe, did you get my patches in the end?
05:45:10 <path[l]> ah I see
05:45:10 <Phyx-> WinDll.exe: Prelude.undefined <-- oh man, I so hate that error, time to grep...
05:45:10 <path[l]> hmm so whats wrong with this line -> zipWith fromEnum.(/=) xs ys
05:45:10 <fasta> tibbe, the darcs version works , AFAIK.
05:45:10 <tibbe> fasta: ok
05:45:10 <tibbe> fasta: windows patches for network?
05:45:10 <fasta> tibbe, yes
05:45:10 <path[l]> oh hmm that doesnt work
05:45:10 <tibbe> fasta: I'm trying to get things to build with 6.12 to test things out
05:45:10 <tibbe> fasta: it's a bit of a pain
05:45:10 <fasta> tibbe, I already built it on Windows.
05:45:10 <path[l]> @pl f x y = fromEnum(x /= y)
05:45:10 <lambdabot> f = (fromEnum .) . (/=)
05:45:10 <fasta> tibbe, (cabal)
05:45:10 <fasta> tibbe, that's why I fixed network.
05:45:10 <tibbe> fasta: sure. I just feel better if I test things as maintainer before releaseing
05:45:10 <tibbe> fasta: but I might skip
05:45:10 <fasta> tibbe, thank you, we need more people like that :)
05:45:10 <tibbe> fasta: and just commit it if you tested it thouroughly
05:45:10 <tibbe> fasta: I might just test with 6.10 so we didn't break old stuff
05:45:10 <tibbe> fasta: http://trac.haskell.org/network/ticket/20 <-- is that the problem you fixed?
05:45:10 <fasta> Lack of QA is what makes me sick of lots of open-source stuff. Please just don't release anything if it doesn't work.
05:45:10 <tibbe> fasta: testing on OS X and Linux is simple. Windows is a PITA
05:45:18 <tibbe> fasta: I could use a Windows only maintainer
05:45:21 <tibbe> for network
05:45:35 <fasta> tibbe, I only fixed my own problems to the point such that it compiled. I did not pay attention to the trac, but yes, that is the issue.
05:45:48 <tibbe> fasta: cool
05:45:55 <tibbe> fasta: I just wanted to make sure it solved the problem
05:46:01 <tibbe> fasta: let me attach the patch to the ticket
05:46:02 <fasta> tibbe, my boss is not interested in fixing platform stuff, since it is not core-business and I agree.
05:46:13 <tibbe> fasta: sure
05:46:23 <tibbe> fasta: I let Neil test the patch too as he ran into the error
05:46:37 <fasta> tibbe, I imagine Google has more things to do related to the network ;)
05:46:42 <path[l]> is there a xor operator
05:46:51 <tibbe> fasta: well yes, not to haskell though
05:47:07 <fasta> tibbe, no, I can imagine they just test it.
05:47:26 <tibbe> fasta: we don't use haskell very much
05:47:29 <fasta> tibbe, kind of like the Facebook people to look cool ;)
05:47:35 <tibbe> fasta: in fact very little, although I'd like to change that
05:47:50 <tibbe> fasta: haha sure. actually I want haskell because C++ makes me miserable
05:47:52 <fasta> tibbe, yes, Java, C++ mostly, from what I read.
05:50:48 <m0nkfish> path[l]: ^
05:51:04 <path[l]> huh isnt that power
05:51:23 <path[l]> I wanna do 1 xor 1
05:51:31 <m0nkfish> no. ^ is xor
05:51:37 <m0nkfish> in pretty much every programming language
05:51:49 <ivanm> m0nkfish: so? just because they're wrong...
05:51:51 <path[l]> > 2^2
05:51:51 <lambdabot>   4
05:51:58 <ivanm> path[l]: (/=)
05:52:03 <ivanm> that's the xor operator
05:52:04 <ivanm> ;-)
05:52:04 <m0nkfish> oh this isn't #python
05:52:04 <m0nkfish> lol
05:52:08 <ivanm> oh, you mean bit-wise?
05:52:13 <path[l]> yeah bitwise
05:52:27 <path[l]> Im trying to use Data.Bits.xor
05:52:37 <ivanm> @slap m0nkfish
05:52:37 <ivanm> how dare you confuse us with them!
05:52:37 <ivanm> @hoogle xor
05:52:37 <ivanm> path[l]: look in Data.Bit (or is it Data.Bits ?)
05:52:38 * lambdabot pulls m0nkfish through the Evil Mangler
05:52:38 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
05:52:38 <blueonyx> > ^2
05:52:39 <lambdabot>   <no location info>: parse error on input `^'
05:52:42 <path[l]> but it says there's an ambiguous type variable t
05:52:54 <ivanm> @instances-importing Data.Bits Bits
05:52:55 <lambdabot> Int, Integer
05:52:59 <ivanm> path[l]: put a type sig onto it
05:53:11 <ivanm> > 1 `xor` 1 :: Int
05:53:12 <lambdabot>   0
05:53:13 <RayNbow> > 2 ^ 3 ^ 3 -- my TI-83+ calculator gets this wrong
05:53:14 <lambdabot>   134217728
05:53:15 <path[l]> ah
05:53:17 <path[l]> thanks
05:53:17 <ivanm> > 3 `xor` 1 :: Int
05:53:18 <lambdabot>   2
05:53:31 <ivanm> RayNbow: why? wrong fixity?
05:53:39 <RayNbow> indeed
05:57:34 <ivanm> as in, infixl rather than infixr?
05:57:34 * RayNbow nods
05:57:34 <ivanm> silly TI ;-)
05:57:34 * ivanm wonders where his HP calculator is so he can check that...
05:57:34 <path[l]> can I import Data.Bit.xor of Int as xor?
05:57:34 <ivanm> it's wrong as well :(
05:57:34 <ivanm> path[l]: no
05:57:34 <ivanm> path[l]: you have to use a type sig
05:57:34 <path[l]> aw
05:57:34 * RayNbow starts VB5
05:57:34 <ivanm> RayNbow: heh
05:57:34 <RayNbow> VB5 also uses left fixity
05:57:34 * RayNbow tries Python
05:57:34 <ivanm> VB5 also lets you write cool hacker GUIs! :p
05:57:34 <RayNbow> yay, Python has it right :)
05:57:34 <ivanm> yup
05:57:34 <RayNbow> ivanm: yeah, but real hackers use VB6
05:57:34 <ivanm> RayNbow: especially if you use pow(2,pow(2,3)) ;-)
05:57:34 <ivanm> RayNbow: true
05:57:34 * RayNbow can't find his setup discs for VB6 though
05:57:34 * ivanm can't be bothered starting up matlab...
05:57:48 <RayNbow> ah crap
05:57:54 <RayNbow> gotta reactivate Matlab?
05:57:59 <ivanm> no
05:58:07 <ivanm> just can't be bothered waiting for 3 hours for it to load
05:58:08 <ivanm> ;-)
05:58:08 <RayNbow> no, I gotta reactivate Matlab :p
05:58:40 <ivanm> heh
05:58:41 <RayNbow> probably because I restored a backup image when I received my laptop after repair :p
05:58:48 <ivanm> RayNbow: obviously your copy isn't magical enough...
05:58:48 <ivanm> ;-)
05:58:52 <ehamberg> matblab sez 512
05:58:58 <quicksilver> path[l]: you can write "xor :: Int -> Int -> Int; xor = Data.Bits.xor"
05:59:11 <path[l]> ah
05:59:16 <path[l]> thanks
06:01:54 <oteren> in a function, how far does a where clause define itself?
06:02:16 <oteren> for the entire function?
06:02:16 <ivanm> oteren: the whole function
06:02:16 <RayNbow> ah never mind... Windows was stupid enough to choose the "Activate Matlab" shortcut instead of Matlab itself
06:02:16 <ivanm> and nothing but the function
06:02:17 <ivanm> RayNbow: heh
06:02:30 <oteren> what if i dont use guards, but just "rewrite" the function
06:02:30 <RayNbow> ivanm: why does it take 3 hours to load on your machine btw? :p
06:02:35 <oteren> func a b = blabla
06:02:39 <oteren> func a [] = blabla
06:02:41 <RayNbow> (here it's started within a few secs)
06:02:42 <oteren> and in the first i have a where
06:02:49 <oteren> does it apply for the second too?
06:03:07 <ivanm> RayNbow: Java
06:03:15 <ivanm> OK, I over-exagerrated
06:03:23 <ivanm> but ever since they started to use Java for the GUI...
06:03:33 <ivanm> oteren: nope
06:03:38 <ivanm> only for that specific pattern match
06:04:01 <quicksilver> oteren: where clauses scope over the definition they attach to
06:04:12 <ivanm> oteren: if you want it for both, you have three choices: duplicate where statements (bad), external function definition or replace pattern matching with a case statement or guards
06:04:14 <quicksilver> oteren: ...including all guards of that definition, but only taht definition
06:04:46 <quicksilver> oteren: actually a better word is 'equation'. Replace 'definition' by 'equation' in my answer :)
06:04:54 <quicksilver> your 'func' example is two equations.
06:05:58 <oteren> thanks, both of you :)
06:06:20 <ivanm> no worries!
06:06:26 <gwern> mein gott. haskell 2010?
06:06:29 <path[l]> hmm why is 0 `xor` 0 giving me 0
06:07:01 <gwern> path[l]: wait, isn't that right? shouldn't it be 1 xor 1 = 0, 0 xor 0 = 0, 1 xor 0 = 1, 0 xor 1 = 1?
06:07:03 <path[l]> oh right oops
06:07:19 <path[l]> yeah sorry =p
08:06:40 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
08:06:40 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
08:06:40 --- names: list (clog joed gemie eivuokko Apocalisp oubiwann JaffaCake1 jfredett_ oskimura XGas_ fasta AnMaster ujihisa perspectival Mowah danvet nathanic_work centrinia paulvdw Athas bgs100 Kamujin Rotaerk dfdf Pellwurst bohanlon alexsuraci` Hiato cognominal ttodos anRch jmcarthur_work Stefa1 trie MoALTz Dessous malie noteventime lazni arvidj Schmallon1 Nshag _zenon_ flazz Philonous dpratt71 simonf ajhager novas0x2a rgr noddy oteren lurkymclurkleton gwern)
08:06:40 --- names: list (gorthaur ts33kr roconnor eevar2 kpreid igel ikke mdordal2 jre2 ddvlad portnov ville medfly dikini seanmcl dreixel weihsiu paolino shambler linimoo maltem pao arnihermann Philippa vy paper_cc EnglishGent^afk niksnut m-i-l-a-n ivanm u_quark bhierof swol slabanja twanvl meridion jlouis kalven jlaire andun ath tavelram smiler ath^_ welterde Tobsan FauxFaux Jedai dcolish guerby wimt Lycurgus RayNbow Phyx- abbe brunov hrehf tibbe epmf eox425)
08:06:40 --- names: list (booxter drwho trin_cz paulvisschers _andre lefant Asztal Taejo spaceodyssey LouisJB SamB_XP_ fbru02 Pthing blastbeat carlocci Beelsebob shag blackdog yowgi Cale aeter LeCamarade hackagebot path[l] c_wraith QplQyer dschoepe hotzen defmacro leoncamel yamafaktory galdor Berengal rickasaurus arjanoosting Esmil nvoorhies blueflute jsgf kayess danly notweebl Igloo rasfar manju|afk fracture shintah alexbobp kfish Wraithan otto_s_ magicman mikm)
08:06:40 --- names: list (Draconx mmorrow Gracenotes pifish Axman6 blackh jabagawee tommd pem Boney BgPerl-VB17 saccade_ geoaxis_ SimonRC M| andrewsw-afk Arnar agemo qeb`away nothingmuch majoh venkatg Sisu tmatix loop peddie Stephan202 sproingie mjv Vulpyne Nafai orbitz karld_ dionoea electrogeek Laney mattam daed nlogax mauke eno__ jmcarthur Colours augur m0nkfish Nereid_ Cobra^^ altmattr eelco Kim^Walkman GNU\colossus ClaudiusMaximus akamaus mahogny fredcy EvilRanter)
08:06:40 --- names: list (ahf jimmyjazz14 pchiusano Garfinkle mm_freak therp tarbo kniu Alpounet Whitesquall Exteris jvogel PsiOmega ezrakilty s76_ awarring dancor zhijie drhodes ^Einstein ChthonLaptop aluink glith Aikawa_ felipe_ droidcore suiside gogonkt mikste BONUS_ bolrod EvanCarroll emias drspider deiga And[y] DrSyzygy neurocyte pcc1 wornof canvon Badger zaarg davidL inimino periodic_ wagle_home lispnik m4thrick doublethink_work gnuvince lomeo Cthulhon preflex)
08:06:40 --- names: list (XGas levitation_ crem wisemanby Bleadof sohum Cal__ Neronus onodrim rdd` fihi09`` pa_ zachk Jiten ski zax_ BMeph Nanar stepnem BONUS DekuNut smg midnite_ tensorpudding xinming kynky wagle tamiko Megant SmurfOR McManiaC DEVOKUN da-x__ zygoloid sjanssen Optimo mle ksandstr saiam opqdonut joga enolan wzp igorgue h20xt jan_ snorble scree muri_one Bassetts Annie|Home geir Spockz Gabbie ziman matthew-_ anji drbean Peaker hiredman mike8901 dogmaT)
08:06:40 --- names: list (jrockway Hunner alexsuraci ibid Innominate Deewiant Vq samulihs rwx eagletmt thetallguy mr_ank MacCoaster kuningas sgf StarFire nasloc__ shortcircuit borism trez aiko kadoban_ MarcWeber mfoemmel sieni amgarching shepheb anders^^ rey_ dixie_ qwr_ liff fritschy_ nablaa bran wolverian koala_man byorgey djinni boyscared Blub\0 pettter t OnionKnight thingwath caligula_ pragma_ dmwit Adamant profmakx tlvb kmc StoneToad_ chrisdone Baughn juhp)
08:06:40 --- names: list (pastah_rhymez myrkiada kosmic olsner eyck wharrgarble sebbe1991 quetzal- prigaux nathanic clarkb spoop gOcOOl jfredett stoop Blaketh jayne koninkje_away lsthemes cathper cods koeien deadguys_ danopia diginux deavid lavish lambdabot TML Nereid epokal skaar cdfh QtPlaty[HireMe] astrocub slbkbs xternal Country-Strike fnordus sbok jleedev edwtjo tew88 ertai dankna jml qm13 newsham mjrosenb dilinger erg _Jordan__ jvoorhis tmug kw317 sioraiocht)
08:06:40 --- names: list (dfeuer gbeshers_home Botje dino- int-e Poeir ned- Khisanth angelixd whoppix Chile mercury^ nazgjunk ggreg_ leimy ray flux im_macie1 mun bbee jims tuukkah taruti allbery_b rapacity netcat sebas_ tltstc SeaPrior det clanehin mrd thomastc mshaw ps-auxw dumael stroan _br_ DRMacIver gdsx BrianHV Zao ac jnwhiteh nimred franksh harlekin ben0x539 nornagon Paradox924X tkr glitch r0bby thorkilnaur_ erk aep wm_eddie jelly12gen Polarina idnar +lunabot)
08:06:40 --- names: list (gbacon noj nnunley alpheccar regulate jones- mfp dcoutts alip hellige aempirei mw493 brx AndyP thoughtpolice equanimity Raevel xian Ornedan_ quicksilver Elly greap wang arkx nwf srcerer jonafan CodeBlock ystael @ChanServ kosmikus willb emma lament kolmodin luite hsaliak__ dons PeakerWork tilman Jaak Twey Liskni_si Lemmih araujo ToRA LeoD heaumer_ Veinor jbauman Raku^ Eelis jtra baaba linkinus jix burp ve jaj tessier jontore eek nipuL reltuk)
08:06:40 --- names: list (__marius__ tromp_ dcoutts_ PHO_ endojelly desp bockmabe_ beibmozoi bd_ mml`_ theclaw mux mokus nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak laz0r dqd absentia icee Twigathy thetallguy1 Gilly cjay p_l aavogt cygnus_ jasonmay guerrilla osfameron ehamberg poe thedward companion_square authentic jql anekos malouin qed desu kar-1 mlh SubStack jfoutz kakeman webframp da-xw impl mornfall mmmulani ahihi sunnavy ido lanaer wdonnelly)
08:06:40 --- names: list (poucet Aisling danderson fxr Milo- integral wormwood shachaf)
08:06:45 <mauke> the external representation of text files depends on the system
08:06:46 <gemie> hi, Is there anyway that I can say that the length of a [a] inside another [] has to be like 3 so for example I want something like this "all (length [Int] == 3) [[1,2,3], [1,2,3,4]]" ?
08:06:51 <mauke> newline is always \n
08:07:04 <fasta> mauke, where do you find that knowledge?
08:07:10 <mauke> gemie: no, you can only use tuples
08:07:15 <Lemmih> gemie: [(Int,Int,Int)]?
08:07:19 <jmcarthur_work> \n = line feed, not newline
08:07:24 <mauke> fasta: I learned it from C
08:07:26 <mauke> jmcarthur_work: no
08:07:43 <mauke> where do people get this stuff?
08:07:59 <fasta> mauke, ok, that is a fairly valid point.
08:08:25 <gemie> mauke , Lemmih ok thats to bad :/ making a property and there I got [[Int]] and I have to check that each inner [] has the length of 3
08:08:29 <jmcarthur_work> \r = move to the beginning of the line horizontally, \n = move to the next line vertically. various computer systems have changed what they actually do, but that is what they were originally intended to mean
08:08:35 <mauke> jmcarthur_work: no
08:08:47 <jmcarthur_work> mauke, i would love some citations
08:08:55 <mauke> there are systems that use fixed-length records to store text files
08:08:56 <jmcarthur_work> http://en.wikipedia.org/wiki/Newline
08:09:01 <mauke> shorter lines are padded with spaces
08:09:07 <gemie> mauke is there any way around it?
08:09:24 <mauke> the C standard library still represents that as \n
08:09:34 <mauke> \n is a virtual character, so to speak.
08:09:40 <jmcarthur_work> the C standard library is newer than the definition of \r and \n
08:09:48 <mauke> this is also the reason why C doesn't guarantee to preserve trailing spaces in lines
08:09:53 <gemie> Lemmih what did you mean by [(int, Int, Int)] ?
08:09:55 <mauke> jmcarthur_work: C invented \n
08:09:58 <Lemmih> gemie: You can easily check it at runtime.
08:10:01 <jmcarthur_work> okay, to be pedantic, i'm talking about CR+LF
08:10:10 <mauke> jmcarthur_work: THAT'S SOMETHING COMPLETELY DIFFERENT
08:10:15 <gemie> Lemmih I want to do it in a quickcheck property
08:10:17 <jmcarthur_work> \n = LF
08:10:21 <mauke> jmcarthur_work: NO
08:10:34 <mauke> jmcarthur_work: also, there's at least one real system where \n = CR
08:10:50 <Lemmih> gemie: all (hasLength 3) where hasLength n lst = length lst == n
08:10:56 <RayNbow> mauke: Macs don't count :p
08:11:01 <rwx> jmcarthur, it's elucidated on the wikipedia page iirc
08:11:15 <stoop> jmcarthur, he is right.
08:11:24 <Lemmih> > let test = all (hasLength 3) where hasLength n lst = length lst == n in (test [[1,2,3]], test [[1,2,3,4]])
08:11:26 <lambdabot>   (True,False)
08:11:35 <jmcarthur_work> mauke, rwx stoop: i realized that and just looked it up myself
08:11:41 <jmcarthur_work> sorry for the confusion
08:12:24 <mauke> and this is why I think \r\n is always wrong: you either mean \n or CRLF
08:12:36 <mauke> it's different abstraction levels
08:12:41 <jmcarthur_work> mauke, "When writing a file in text mode, '\n' is transparently translated to the native newline sequence used by the system, which may be longer than one character."
08:12:50 <fasta> mauke, but Haskell lets \r\n leak.
08:12:55 <jmcarthur_work> mauke, according to the wikipedia page, that's the C standard
08:12:58 <gemie> Lemmih hm that seems interesting gonna test it out. thanks alot let you know =)
08:13:02 <mauke> jmcarthur_work: yeah, and there may not even be such a "sequence"
08:13:08 <mauke> fasta: how?
08:13:09 <stoop> There is nothing to leak, a newline is "\n", fasta and not "\r\n".
08:13:17 <jmcarthur_work> mauke, is that sequence not \r\n on windows?
08:13:37 <RayNbow> on Windows it's CRLF
08:13:37 <stoop> jmcarthur, what exactly does \r do?
08:13:52 <jmcarthur_work> yeah, i meant what RayNbow said
08:13:54 <RayNbow> the confusion here seems to be that some people equate \n = LF
08:14:08 <oteren> http://haskell.pastebin.com/m4fc544dd
08:14:10 <jmcarthur_work> RayNbow, which is what i was doing
08:14:16 <oteren> why isnt that working unless i remove the (Ord a) definition
08:14:45 <fasta> stoop, if you open a tekst editor on Windows and you see two different lines, it translates to bla\r\nfoo. Now, I would think that every human would say there are two lines. One containing bla and one containing foo. So, the thing which is between it, would be the line-separator. That seems very solid logic to me.
08:14:53 <jmcarthur_work> i think fasta's problem is that on windows, CRLF is being read in as \r\n?
08:15:01 <mauke> fasta: it doesn't translate to \r\n
08:15:22 <fasta> mauke, it does so when you call readFile.
08:15:27 <mauke> fasta: no
08:15:54 <RayNbow> if I read a file on Windows containing "foo[CRLF]bar" using readFile, I'll get "foo\nbar"
08:16:30 <fasta> Ok, so then the problem is that this occurs when you run it under Msys ;)
08:16:46 <stoop> Msys?
08:16:47 <fasta> (which isn't that surprising)
08:16:56 <fasta> stoop, mingw
08:17:00 <eivuokko> You mean rxvt?
08:17:13 <quicksilver> that sounds familiar. I think mingw uses [LF] as a line separate even though the host system is using [CRLF]
08:17:17 <fasta> eivuokko, that would be the terminal emulator.
08:17:18 <jmcarthur_work> how does one explicitly output CRLF in a portable way, now that i know \n isn't necessarily LF?
08:17:27 <quicksilver> so mingw has an incompatible encoding with its host
08:17:28 <jmcarthur_work> for example, for an HTTP connection?
08:17:33 <mauke> "\13\10"
08:17:34 <quicksilver> jmcarthur_work: using binary mode not text mode
08:17:37 <jmcarthur_work> eek
08:17:41 <jmcarthur_work> i've been doing it so wrong
08:17:56 <eivuokko> fasta, Yes, but it's the closest I can see msys has to do with haskell code, as haskell binaries don't depend on msys runtime normally?
08:17:57 <quicksilver> HTTP should be binary mode because it should use the network line convention not the native one.
08:18:06 <jmcarthur_work> i see
08:18:10 <Athas> Is there a Haskell interface to select() somewhere?
08:18:19 <RayNbow> @hoogle select
08:18:19 <lambdabot> Text.Html select :: Html -> Html
08:18:19 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
08:18:19 <lambdabot> Text.XHtml.Strict select :: Html -> Html
08:18:20 <mauke> Athas: only indirectly, through threads
08:18:22 <quicksilver> Athas: in a sense.
08:18:23 <RayNbow> hmm
08:18:32 <quicksilver> Athas: haskell threads multiplex their IO using select() behind the scenes.
08:18:46 <Athas> Hmmm.
08:18:49 <RayNbow> wasn't there a select in one of the network libs?
08:18:54 <ben0x539> What does 'nonfix' mean?
08:18:58 <mauke> you can actually build your own select using threads
08:19:20 <quicksilver> ben0x539: must always be explicitly paranthesised, I think
08:19:23 <Athas> Right, I'm interacting with a C library through the FFI, and I need to call select() on a descriptor I can get from it.
08:19:28 <Athas> What would be a good way to solve this?
08:19:30 <mauke> Athas: why?
08:19:41 <ben0x539> > True == True == True
08:19:42 <lambdabot>   Precedence parsing error
08:19:42 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
08:19:46 <ben0x539> :o
08:19:47 <quicksilver> ben0x539: if ~ is nonfix then a ~ b ~ c is an illegal term.
08:19:49 <mauke> Athas: I mean why do you think you need to call select on the descriptor?
08:20:14 <Athas> mauke: I need to wait (block) for either a SIGCHLD or for something to be readable on that descriptor.
08:20:16 <Athas> Do you have a better way of solving this?
08:20:26 <stoop> > (True == True) == True
08:20:27 <lambdabot>   True
08:20:46 <mauke> Athas: can't you just read from the descriptor?
08:21:20 <Athas> mauke: if I can read zero bytes...
08:21:54 <jmcarthur_work> can't you read signals even if you are blocked?
08:22:02 <jmcarthur_work> like an interrupt?
08:22:14 <mauke> Athas: oh, so you don't actually want to read data?
08:23:08 <Athas> mauke: no.  This is Xlib, the actual data reading will be done by exposed functions.
08:23:19 <mauke> Athas: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v%3AthreadWaitRead
08:23:27 <Athas> Logically, I need to block for an Xlib *event* or a SIGCHLD, but...
08:23:43 <Athas> Oh, neato.
08:25:53 <Polarina> I have GHC installed on a 64-bit computer, producing x86_64 ELF binaries. How do I make it produce a x86 ELF binary?
08:28:04 <tommd> Polarina: GHC isn't a cross compiler
08:28:15 <Polarina> :(
08:28:27 <Athas> Maybe polling with a timeout is better.  Curses.
08:28:29 <tommd> Unfortunately, the Haskell community really isn't a cross compiling community either, what with our use of hsc2hs.
08:28:45 <Polarina> tommd: hsc?
08:29:08 <tommd> hsc2hs is a tool that generates .hs files to use in making bindings to C libraries.
08:29:13 <DrSyzygy> I have a vague recollection of something like x :: forall a. a forces x = undefined. Any type theory wizards who care to help me get the facts straight?
08:29:25 <Polarina> tommd: Nice! :D
08:29:50 <Athas> Actually, has anyone made a dictionary mapping POSIXisms to Haskell/GHC libraries?
08:30:13 <tommd> It works by generating a c program that will, once compiled, generate the needed .hs file.  In this manner it can acquire the constants, offsets, etc, from GCC (or another C compiler).  Unfortunately, this destroys any hope of cross compiling those packages until/unless they move to something like c2hs.
08:30:56 <RayNbow> DrSyzygy: I'm not a type theory wizard, but yes, x :: a means that x can only be bottom
08:31:08 <tommd> Athas: Do you want the posix library? its on hackage
08:31:55 <tommd> bindings-posix, posix-realtime, and 'unix' are all libraries that I would look at if I were you.  Also, making such primitive FFI calls is not hard.
08:32:29 <tommd> There is another one out there with just math ops (cmath, I think) and yet another with file operations only.
08:32:32 <Athas> Right, I really appreciate how well Haskell wraps C stuff.
08:33:58 <ezrakilty> DrSyzygy: In "forall a. a" you could instantiate "a" with any type; so values of "forall a. a" must be values in any type. The only such value in Haskell is undefined.
08:34:11 <RayNbow> "∀a. a is a type that can give us an object of type B for any B. There is no way to to this. How could such a function manufacture an element of B for any B with nothing to work from? It would have to work even for types that haven't been defined yet."
08:34:11 <DrSyzygy> Gotcha.
08:34:17 <ezrakilty> In System F, there simply is no such value, so "forall a. a" is uninhabited.
08:34:21 <RayNbow> ( taken from: http://blog.sigfpe.com/2009/11/memoizing-polymorphic-functions-with.html )
08:34:31 <oteren> http://haskell.pastebin.com/m4fc544dd
08:34:31 * DrSyzygy is trying to write up a handwavy introduction to topos logic.
08:34:38 <oteren> this is not working without me removing the Ord a
08:34:47 <DrSyzygy> And so I'm trying to motivate the definition of false = \forall a. a
08:34:49 <oteren> minimum is also of Ord a
08:34:51 <oteren> dont get it :(
08:34:58 <mauke> oteren: that doesn't work at all
08:35:06 <mauke> oteren: I don't see what Ord a has to do with it
08:35:27 <oteren> it works without the (Ord a) => definition
08:35:37 <mauke> oteren: no, it doesn't
08:36:51 <oteren> hmm no
08:36:52 <oteren> it doesnt
08:36:52 <oteren> :D
08:36:59 <oteren> it *compiles* without the Ord a!
08:37:02 <mauke> oteren: no, it doesn't
08:37:13 <oteren> yes it does, thats what tricked me
08:37:27 <oteren> if you want to come over here and have a discussion with my GHC, go ahead
08:37:31 <mauke> oteren: no, it doesn't
08:37:36 <mauke> I'm getting two type errors
08:38:11 <mauke> Couldn't match expected type `a' against inferred type `[Char] -> t'
08:38:16 <mauke> No instance for (Ord ([Char] -> t)) arising from a use of `minimum' at irc.hs:5:7-18
08:38:46 <oteren> compiles like a mofo here
08:38:50 <oteren> got a shining .o looking at me
08:38:52 <jmcarthur_work> what version?
08:39:00 <oteren> 6.something i think
08:39:02 <mauke> oteren: well, then you're doing it wrong
08:39:02 <jmcarthur_work> and are you sure it's actually rebuilding?
08:39:23 <oteren> lets not get hung up in that my compiler is letting me compile something thats wrong
08:39:29 <oteren> and rather lets try to figure out what i'm not getting
08:39:30 <mauke> yes, let's
08:39:41 <jmcarthur_work> what does ghc --version say?
08:39:52 <oteren> i'm using ghc via eclipse
08:40:04 <jmcarthur_work> open a shell and see what it says
08:40:17 <jmcarthur_work> maybe try building without eclipse, even
08:40:26 <jmcarthur_work> eclipse could be lying to you or something
08:40:49 <oteren> yes, the shell told me it doesnt compile
08:40:59 <oteren> but tbh, i dont care much about it compiling stuff that doesnt work
08:41:03 <oteren> i want to figure out why this is wrong
08:41:14 <jmcarthur_work> why it's wrong without Ord?
08:41:16 <mauke> oteren: because error is a function that expects a string
08:41:32 <oteren> aha
08:41:34 <jmcarthur_work> oh that
08:41:40 <fasta> What exactly does System.Info.os return? It returns mingw32 in a ghci started in cmd.exe, which seems clearly wrong.
08:41:49 <mauke> if you add the string (and don't remove the Ord constraint), it compiles
08:41:54 <jmcarthur_work> you could use undefined instead of error if you don't want to use an error message
08:42:05 <oteren> ah
08:42:12 <oteren> yeah, added "not possible" now
08:42:23 <oteren> ty :D
08:42:26 <fasta> It might be that having multiple instances running messes up ghci's notion of "os".
08:42:33 <fasta> (that would still be a bug, of course)
08:42:43 <Baughn> @where+ no http://brage.info/~svein/no.jpg
08:42:44 <lambdabot> Done.
08:42:49 <fasta> > System.Info.os
08:42:51 <lambdabot>   Not in scope: `System.Info.os'
08:43:59 <eivuokko> fasta, I think the idea is that it returns runtime.  Probably something to do with the rotted-away cygwin support.
08:44:18 <fasta> eivuokko, yes, that's what the _documentation_ says.
08:44:37 <fasta> eivuokko, but those two don't always match.
08:44:50 <fasta> Can anyone run it on Windows?
08:45:06 <eivuokko> Eh?
08:45:28 <fasta> eivuokko, to see what it returns on another machine.
08:45:29 <eivuokko> The runtime would be mingw32 always in Windows, as that's the only supported runtime?
08:45:35 <oteren> can i run it in winhugs?
08:45:38 <oteren> i'm in windows
08:46:06 <fasta> eivuokko, ah, I see what you mean now. "The operating system on which the program is running.
08:46:06 <fasta> " is the documentation.
08:46:07 <eivuokko> "mingw32", ghc run from cmd
08:46:20 <Phyx-> i use it in my processor and always get mingw32
08:46:24 <Phyx-> on windows
08:47:04 <fasta> eivuokko, ok, well, I expected something like "win32" or "winnt" or something similar.
08:47:16 <fasta> eivuokko, thanks
08:47:35 <eivuokko> fasta, and you are right, anyway, it doesn't really make that much sense.  Bad thing, if it's used, it's used by dynamic checks, so changing the behaviour invites bugs.
08:48:05 <fasta> The whole "let's use Strings" is also very anti-Haskell.
08:48:54 <Polarina> How do I create a .so (or .dll) with Haskell functions (what command line options?) that a Haskell executable can link to? And how would I link such a library?
08:49:24 <mauke> Polarina: you can't
08:49:33 <Polarina> Why?
08:49:45 <mauke> because it's not 6.12 yet
08:49:54 <Polarina> Ok, if it were 6.12?
08:50:14 <mauke> then I'd look at the manual for ghc 6.12
08:50:18 <Polarina> Ok.
08:50:23 <Polarina> ETA on 6.12?
08:50:31 <Botje> Real Soon Now(tm)
08:50:40 <Polarina> :D
08:50:57 <Phyx-> mauke: small question, will 6.12 support dynamic linking on windows aswell?
08:51:01 <mauke> no idea
08:51:42 <Apocalisp> I used to have a manager who had three concepts of time: "two seconds", "a while", and "a WHILE"
08:51:54 <Phyx-> someone told me it would only be for unix like OSes, so i wanted to confirm, oh well
08:51:58 <Phyx-> thanks anyway
08:52:22 <Baughn> Phyx-: That's probably going to be the case. Windows DLLs are.. pretty weird, and it would take a lot of extra work
08:52:38 <quicksilver> Polarina: I think you might be asking the wrong question.
08:52:48 <quicksilver> Polarina: what are you really trying to achieve?
08:52:52 <Baughn> Phyx-: Then again, IIRC GHC also used to have shared library support on windows /before/ it had anything on unix.. I'm not sure what the story is there
08:52:56 <quicksilver> haskell librarys (packages) have worked for ages.
08:53:08 <quicksilver> alternative, haskell dynamic loading (plugins) has also worked for ages
08:53:16 <quicksilver> surely one or the other is right for you?
08:53:36 <Polarina> quicksilver: Make a library.
08:54:27 <quicksilver> Polarina: haskell libraries are called packages.
08:54:42 <Polarina> How do they work?
08:54:49 <quicksilver> you normally install them using Cabal
08:54:51 <mauke> with static linking
08:55:00 <fasta> Polarina, do you want a DLL or do you want to call stuff from the Haskell world only?
08:55:10 <Polarina> fasta: Huh?
08:55:11 <fasta> Polarina, with stuff being other Haskell code?
08:55:20 <quicksilver> Polarina: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
08:55:39 <Polarina> fasta: Haskell-world only would suffice.
08:55:44 <quicksilver> Polarina: (section 3 is about libraries but the whole thing is relevant)
08:55:47 <fasta> Polarina, then you have no need for DLLs.
08:55:58 <quicksilver> I believe Polarina asked the wrong question. They didn't really care if the linking was static or dynamic.
08:56:01 <Polarina> fasta: Ok.
08:56:05 <DrSyzygy> Graaaargh! Logicians are crazy!
08:56:12 <fasta> Polarina, importing a library is just import MyLib.
08:56:19 <quicksilver> DrSyzygy: and yet, strikingly handsome.
08:56:30 <Polarina> fasta: Thanks.
08:56:31 <DrSyzygy> I have a derivation, I think, of that \forall x.x really implies everything in topoidal logic. And I have no idea whether I get to do the things I do.
08:56:40 <fasta> Polarina, and when actually building, you have to do -package mypackagename
08:56:41 <DrSyzygy> quicksilver: Have a look, would you?
08:56:58 <fasta> Polarina, just Haskell <-> Haskell is very solid and has worked for a very long time.
08:57:13 <quicksilver> DrSyzygy: sure. it's a very long time since I looked at a topos though.
08:57:17 <DrSyzygy> * | \forall x.x : \forall x.x by the introduction rule that anything entails itself.
08:57:22 <Phyx-_> hrm
08:57:27 <Phyx-_> connection died
08:57:41 <Phyx-_> Baughn: for the most part windows dll are the same PE format though, and ghc can compile dlls as is, aslong as the appropriate Storable instances and c headers files are created
08:57:44 <DrSyzygy> \forall x.x : \forall x.x | \forall x.x : x by the forall removal rule.
08:57:50 <quicksilver> DrSyzygy: paste maybe? I'm guessing a whole proof is too long for this channel.
08:57:57 <quicksilver> DrSyzygy: or #haskell-blah if you prefer
08:57:58 <DrSyzygy> sure...
08:58:24 <p_l> Phyx-: afaik, didn't DLL files differ only by having one bit flipped?
08:58:31 <Phyx-> p_l: pretty much
08:58:50 <p_l> kinda like ELF ones (I was quite surprised when I "executed" a library)
08:59:05 <Phyx-> and having the export table filled in, but the differences aren't much
08:59:34 <Phyx-> p_l: rundll basically does the same on windows
08:59:58 <tavelram> @pl \(x,y) -> [x,y]
08:59:59 <lambdabot> uncurry ((. return) . (:))
08:59:59 <p_l> Phyx-: except that ELF libraries are executables as well (just most of them don't supply necessary entry point)
09:00:06 <Phyx-> aha
09:00:06 <p_l> no rundll at all
09:00:32 <p_l> actually, one of them is involved every time you execute a program, apparently (learned this while debugging dynamic loading)
09:01:00 <p_l> (program interpreter field in ELF header)
09:01:56 <Phyx-> have never taken a look at ELF, i've only just recently started using linux again alot. mostly becuase of some unix only haskell tools, and cygwin was becoming annoying
09:02:40 <p_l> Phyx-: try executing /lib/ld-<version>.so
09:03:10 <Phyx-> p_l: i'm in windows atm
09:03:40 <Phyx-> but i'll give it a try next time i'm in fedora
09:05:43 <p_l> Phyx-: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13109#a13109
09:06:55 <p_l> iirc the whole dynamic linking is implemented by that executable
09:07:52 <Phyx-> ah, cool :)
09:08:09 <Phyx-> what are these "auditors"
09:08:56 <p_l> Phyx-: afaik they are called by hooks in various stages of the linking
09:09:22 <Polarina> Why do people recommend Darcs over Subversion?
09:10:00 <dqd> Because Darcs is distributed and it is written in Haskell.
09:10:01 <jmcarthur_work> darcs is better in pretty much every way. the biggest advantage is the ability to work with a set of changes rather than a sequence of versions
09:10:05 <p_l> Phyx-: The dynamic linker will notify the audit libraries at so-called auditing checkpoints—for example, loading a new library, resolving a symbol, or  calling  a  symbol from another shared object—by calling an appropriate function within the audit library.  For details, see rtld-audit(7).  The auditing interface is largely compatible with that provided on Solaris, as described in its Linker and Libraries Guide, in ...
09:10:12 <p_l> ... the chapter Runtime Linker Auditing Interface.
09:10:56 <Polarina> jmcarthur_work: Could you explain that feature a bit further, please?
09:11:45 <Phyx-> p_l: ah ok, i get it, cool
09:12:01 <jmcarthur_work> Polarina, say you commit A, B, C, D, E, F, and G. i can pull A, C, and G from you without necessarily pulling the others, unless the others are dependencies
09:12:11 <Phyx-> doesn't subversion also support patches these days
09:12:29 <jmcarthur_work> Polarina, or you can remove one of those changes without touching the others
09:12:36 <jmcarthur_work> in any order
09:12:51 <jmcarthur_work> Polarina, does that make sense?
09:12:55 <oteren> in what way is this an advantage over svn?
09:13:05 <Polarina> jmcarthur_work: Yes. :)
09:13:06 <jmcarthur_work> Phyx-, subversion has merge tracking now, but it's total crap and not the same
09:13:08 <oteren> or rather, svn can do that too
09:13:12 <Polarina> jmcarthur_work: Git allows that too?
09:13:35 <jmcarthur_work> Polarina, git does allow it, but not in a way i would consider very simple (i was a git user before i was a darcs user)
09:13:47 <Polarina> Ah. :)
09:13:52 <jmcarthur_work> Polarina, and git will not, say, pull dependencies when you cherry pick
09:13:55 <jmcarthur_work> darcs does
09:14:15 <quicksilver> the converse view is that patch theory is unsound and therefore a *dis*advantage of darcs, whilst a tree-based approach is more correct :)
09:14:17 <Polarina> :)
09:14:21 <Phyx-> jmcarthur_work: clean checkouts of everything usually take alot longer on darcs though
09:14:27 <Phyx-> and recording changes are more of a hassle
09:14:32 <quicksilver> I think the more important advantage of (darc/bzr/hg/git) is the decentralisation.
09:14:40 <jmcarthur_work> Phyx-, yes to the former, no to the latter in my experiences
09:14:44 <p_l> Phyx-: SVN depends on centralised server, darcs, mercurial and git are distributed (this is the main advantage for me)
09:14:59 <oteren> whats wrong with having a decentralized server
09:15:04 <oteren> or rather, whats the incentive to not have it
09:15:10 <h20xt> for me the main advantage of git is light branching :)
09:15:19 <jmcarthur_work> Phyx-, darcs r -a -m 'blah blah blah' is no harder than with git or svn, i think
09:15:29 <oteren> *having a centralized
09:15:35 <jmcarthur_work> h20xt, darcs has an even lighter alternative :)
09:15:44 <Polarina> I prefer(ed, if you wish) subversion because if it's extremely simple usage.
09:15:48 <jmcarthur_work> h20xt, http://wiki.darcs.net/SpontaneousBranches
09:15:48 <Phyx-> p_l: no no, i know what they are, lol. i'm just mentioning what my experience has been :P
09:16:04 <oteren> Polarina: i agree
09:16:17 <h20xt> jmcarthur_work: ill take a look
09:16:17 <oteren> time should be spent coding, not learning how to optimize your version control
09:16:17 <oteren> :p
09:16:19 <Phyx-> jmcarthur_work: well, i've only used it a couple of times
09:16:20 <int-e> oteren: it doesn't fit open source software development workflows very well.
09:16:25 <Polarina> oteren: :D
09:16:30 <Phyx-> but i still prefer subversion
09:16:42 <oteren> i use subversion for anything i do
09:16:47 <jmcarthur_work> i hate being stuck to the internet just to use version control
09:16:48 <h20xt> oteren: a little time spent optimizing version control, is a lot of saved time down the road
09:16:52 <jmcarthur_work> why would you want that?
09:17:21 <oteren> jmcarthur_work: moot point, even starbucks in the jungle of africa gives you free internet now
09:17:30 <p_l> oteren: people locking each other from files, requires setting up infrastructure instead of just sending changesets, harder to merge work done by many  people on the same files
09:17:31 <oteren> i'd understand the issue if this was 1995
09:17:41 <jmcarthur_work> oteren, have you ever actually used a dvcs?
09:17:45 <Polarina> jmcarthur_work: Good point!
09:17:51 <oteren> yeah, i can undertand it from the open source point of view
09:17:55 <Phyx-> and you can have local repositories with svn
09:18:00 <Phyx-> takes a bit more work than darcs
09:18:01 <Phyx-> but you can
09:18:07 <jmcarthur_work> Phyx-, but then you can't share it out
09:18:42 <dcoutts> oteren: it means I can commit code on the train on the way back from visiting clients, disconnected operation is really useful
09:18:53 <jmcarthur_work> oteren, the ability to send patches wherever they belong selectively and whenever you want is a less of a distraction than having to constantly sync with some server as though you are using rsync or something
09:19:00 <oteren> no i havent jmcarthur, which is why i was asking what the big deal was
09:19:12 <Phyx-> jmcarthur_work: well, you can relocate and commit to another repo, if your local was a copy of remote one. created with for instance svn dump afaik
09:19:14 <int-e> oteren: svn makes it hard to work on a series of patches on top of some upstream repository. svn makes it even harder to share such patches without involving the upstream server in the process. however, giving out commit access is not done lightly. so for an open source project it means that contributing or forking become harder than necessary. all that just because it has a centralized server, and that crazy idea of a linear history.
09:19:15 <oteren> svn works perfectly for all my uses, so i havent really bothered looking into other stuff
09:19:28 <int-e> oteren: "my" is sort of a keyword there.
09:19:32 <jmcarthur_work> Phyx-, crazy amount of effort for that
09:19:52 <oteren> calm down all of you, i'm asking cause i want to know, not because i'm any sort of svn warrior
09:19:52 <oteren> :D
09:20:13 <jmelesky> oteren: that's a bit tautological. it works for all your uses of it, because it only allows certain uses of it.
09:20:15 <jmcarthur_work> oteren, even for a single user, a dvcs is usually a major enhancement to productivity. perhaps it's one of those things that is hard to explain
09:20:27 <jmcarthur_work> oteren, like explaining version control to somebody who has never heard of it
09:20:46 <Phyx-> I use svn for all my personal developement
09:20:46 <quicksilver> for me the big win of a dvcs is local branches for experiments and local merging
09:20:55 <Phyx-> i just have a public server running i can access
09:20:58 <quicksilver> I also work on the train like dcoutts too
09:21:14 <p_l> oteren: also, dcoutts' example was very good. Mercurial includes a very good example as well, showing an example of work on a kernel driver patches, where you don't want to disturb the mainline but you need to manage your own branch and prepare it for mergin with mainline (which is normal for both open-source and closed source)
09:21:25 <jmcarthur_work> there are features i still wish darcs (or any dvcs) had that i think would open minds to new ways of developing
09:21:48 <jmcarthur_work> things which, with effort, can be emulated, but would be much more convenient if supported natively
09:22:10 <Saizan> jmcarthur_work: like?
09:22:12 <oteren> yes, a one-click local branch
09:22:15 <oteren> is somethinig i want in svn
09:22:21 <jmcarthur_work> such as the ability to stores tons of patches in a repository while only some of them are currently applied in the working copy
09:22:28 <jmcarthur_work> *store
09:22:30 <jmelesky> jmcarthur_work: i actually prefer darcs' narrow focus over the git/hg model of adding features. it's more unix-like in philosophy
09:22:38 <oteren> although it isnt harder than just checking out the main project once more to another project usually
09:22:41 <Saizan> one command local branch is what you get with dvcs
09:22:52 <jmcarthur_work> jmelesky, i think my ideas don't clash with the darcs philosophy
09:23:35 <p_l> jmelesky: I think git is very unixy - at the core, it's just an object store that's content-addressable which can be used to store a filesystem tree with versioning
09:23:45 <jmcarthur_work> oteren, with darcs you don't even have to make a branch in tons of cases that you would with svn since you can manipulate your changes individually
09:23:51 <tensorpudding> git is fast and potent
09:24:01 <jmcarthur_work> i like git too
09:24:17 <tensorpudding> i found darcs before i found git
09:24:34 <tensorpudding> i liked darcs a lot, but i ended up leaving it because git was just more popular
09:24:37 <oteren> svn is fast, and i'm very much potent
09:24:41 <jmcarthur_work> me too, but i used git more seriously for a long time before switching back to darcs
09:24:46 <oteren> but yes, this sounds nice
09:24:56 <oteren> but i prefer the way of least resistance, -> stick with svn :)
09:25:00 * bos is stuck using all of them
09:25:24 <defmacro> oteren: use what you know, always good
09:25:32 <tensorpudding> svn doesn't seem fast to me
09:25:57 <jmelesky> p_l: git might be unixy in that it's like unix itself: lots of parts which make lots of features, but not unix-like insofar as it's a simple tool with orthogonal uses
09:26:40 <jmelesky> oteren: the fact that you're not suggesting cvs means that you'll probably switch eventually. :)
09:27:16 <oteren> i've never used cvs
09:27:31 <oteren> it was the de facto standard for version control a couple of years back wasnt it?
09:27:31 <int-e> lucky you.
09:27:42 <tensorpudding> depending on your definition of a couple
09:27:44 <Polarina> oteren: It was, but in my experience, CVS is not worth it.
09:27:47 <bos> git has the most complicated usage model of the lot of them (except for maybe cvs)
09:28:09 <tensorpudding> cvs was nice and confusing the few times i had to explicitly use i
09:28:09 <oteren> tensorpudding: 5 -/+ 2
09:28:11 <tensorpudding> it*
09:28:11 <jmelesky> svn was developed specifically to replace cvs
09:28:16 <int-e> . o O ( CVS has a usage model? Could've fooled me. )
09:28:41 <Polarina> Darcs looks promising. :)
09:28:42 <c_wraith> int-e: it involves lots of cursing and prayer
09:28:57 <jmelesky> cvs worked fine, so long as you didn't need to branch too much. or version directories. or merge.
09:29:06 <c_wraith> Polarina: Darcs is great except the times it decides to go exponential on merges.
09:29:13 <int-e> I'm with Linus on that one. "CVS done right" is a recipe for producing a mediocre VCS.
09:29:15 <Polarina> c_wraith: o.O
09:29:17 <bos> darcs doesn't really seem to do that any more.
09:29:24 <c_wraith> not very often.
09:29:34 <c_wraith> It can still happen, but it's a lot less of an issue since darcs 2
09:29:40 <Polarina> :)
09:29:40 <int-e> (He put it more bluntly. "There is no way to do CVS right.")
09:30:02 <rwx> @src Enum
09:30:03 <lambdabot> class  Enum a   where
09:30:03 <lambdabot>     succ                     :: a -> a
09:30:03 <lambdabot>     pred                     :: a -> a
09:30:03 <lambdabot>     toEnum                   :: Int -> a
09:30:03 <lambdabot>     fromEnum                 :: a -> Int
09:30:05 <lambdabot> [3 @more lines]
09:30:13 <c_wraith> Now, darcs issues I run into generally involve things like "cannot record a patch that resolves this conflict"
09:30:24 <c_wraith> Which is a truly baffling problem.
09:31:05 <sm>  c_wraith: is there an example of that in the tracker ?
09:31:18 <sm> or that you could paste ?
09:31:29 <c_wraith> sm:  I'm not sure.  it was a while ago that I ran into it.
09:31:39 <c_wraith> And I have no clue how the repo got in that state
09:32:02 <int-e> My primary grudge against darcs comes from bad experiences trying to unrecord old local patches which have accumulated conflicts with upstream in the meantime. I've often ended up with just getting a fresh copy of the upstream repo.
09:32:03 <sm> never saw that one. But I tend to run current darcs and keep conflicts to a minimum
09:32:19 <c_wraith> I just know that if I recorded a patch, then did "darcs resolve" it would re-add the conflict.
09:32:42 <c_wraith> I eventually solved it with a sledgehammer:  I recorded a patch removing that file, then another re-adding it with the correct contents
09:33:40 <sproingie> i'll let you know what my problem with darcs is when it finishes pulling what i started yesterday
09:34:10 <jmcarthur_work> yeah, big pulls are my main issue with darcs
09:34:21 <jmcarthur_work> i have no problems with *using* a repository that i already have though
09:34:27 <sm> there are usually ways to make that faster, like use modern darcs and repo format
09:34:33 <quicksilver> to express it as a haskell geek, it's not so much that problemsWithDarcs isn't [], it's more the fact that it's _|_
09:34:36 <oteren> since its distributed
09:34:40 <sm> or pull a tarball to start
09:34:41 <oteren> where do you pull the update from?
09:34:44 <c_wraith> Oh, yeah.  one of my co-workers can't pull one of our repos.  using darcs 2.3.1 and a dars2 format repo
09:34:45 <oteren> images of a sort?
09:34:46 <sproingie> following both ghc and cabal's instructions to get partial repos still takes FOREVER
09:34:56 <oteren> or rather, where do you pull the initial checkout
09:34:56 <c_wraith> err, he can't "get" it.  he can pull if he has an empty repo
09:35:09 <oteren> is it p2p?
09:35:26 <oteren> or is it possible to set up something central for archiving purposes?
09:35:38 <oteren> like a mix of central and dcvs
09:35:40 <int-e> sproingie: for ghc the advice is to use a recent snapshot from http://darcs.haskell.org/ (like  ghc-HEAD-2009-10-23-ghc-corelibs.tar.bz2) as a starting point
09:35:56 <oteren> ah, snapshots indeed
09:36:00 <jmcarthur_work> oteren, often you have a designated "central" repository with a dvcs
09:36:03 <sproingie> int-e: sure, but i shouldn't have to
09:36:39 <int-e> sproingie: right, it's a fairly practical workaround though.
09:37:28 <oteren> that its this much hassle to get a clean first time checkout, doesnt make for good advertisement
09:37:30 <oteren> ;)
09:37:40 <jmcarthur_work> it's not
09:38:12 <jmcarthur_work> svn is slow, too, in my opinion
09:38:24 <oteren> how so?
09:38:35 <oteren> i'm mostly only limited by network speed
09:38:41 <jmcarthur_work> exactly
09:38:51 <oteren> (which you will be in any case in a first time checkout)
09:38:55 <jmcarthur_work> with a dvcs you can operate without network connections
09:39:04 <oteren> you need to get your initial code from *somewhere*
09:39:06 <jmcarthur_work> even just establishing a connection on a fast network takes a while sometimes
09:39:11 <jmcarthur_work> i'm not talking about initial code
09:39:24 <jmcarthur_work> i'm talking about using it, which is the vast majority of how you use a version control system
09:39:35 <FliPPeh> How would I go and create a framework in Haskell, like I could do in any OOP language by using a base class and deriving from it? Is there any haskell approach to that?
09:39:38 <FliPPeh> ;o
09:39:42 <int-e> things like "what's the difference between revision X and revision Y"
09:39:46 <jmcarthur_work> right
09:39:55 <int-e> "when did we last change file baz.bar?"
09:40:00 <int-e> (and why?)
09:40:24 <oteren> diffs arent that slow, and if you use the comment field correctly, the why is pulled in as a default
09:40:30 <jmcarthur_work> heck, even svn log has to touch the network
09:40:32 <jmcarthur_work> it's so stupid
09:40:46 <oteren> i believe svn will change over time though
09:40:48 <int-e> oteren: but it's an online operation, it won't work on a train.
09:40:51 <oteren> taking stuff from the dcvs systems
09:41:00 <jmcarthur_work> svn has been doing that... very badly
09:41:06 <oteren> it will work for me, i got mobile broadband!
09:41:07 <jmcarthur_work> *cough*merge tracking*cough*
09:41:09 <int-e> likewise recording patches (which means committing them in svn's model) must be done online with SVN
09:41:26 <jmcarthur_work> why wait for svn to do it when the features already exist elsewhere?
09:41:31 * int-e will have to read about that merge tracking thing.
09:41:46 <jmcarthur_work> int-e, don't bother unless you need more material to bash svn
09:41:46 <EnglishGent> hi all :)
09:41:58 <oteren> because svn is set up and in use in under 1 minute
09:42:06 * int-e wonders why nobody has mentioned svk yet.
09:42:07 <oteren> mostly
09:42:09 <EnglishGent> does anyone know any Haskell code for extracting tags from an MP3 file?
09:42:11 <int-e> so is git
09:42:14 <jmcarthur_work> oteren, darcs is set up and in use in about a second
09:42:16 <jmcarthur_work> darcs init
09:42:19 <sproingie> i still have to use cvs at work
09:42:19 <oteren> still have to learn it
09:42:21 <oteren> hehe
09:42:23 <int-e> git init-db
09:42:25 * EnglishGent has tried googling - but not much joy
09:43:52 <oteren> tags are store in cleartext in the beginning of the mp3 afaik
09:43:55 <oteren> *stored
09:44:16 <oteren> no, end
09:44:32 <EnglishGent> ah ty oteren :)
09:44:35 <jmcarthur_work> yeah, it would be bad trying to prepend data to an mp3 every time you update a tag
09:44:39 <FliPPeh> No ideas for me? :(
09:44:54 <jmcarthur_work> FliPPeh, look at any library on hackage
09:45:00 <oteren> specification, http://en.wikipedia.org/wiki/ID3 EnglishGent
09:45:01 <jmcarthur_work> the question is a bit ambiguous, really
09:45:08 <EnglishGent> thanks :)
09:45:45 <FliPPeh> I just want some tips or guidelines on how to create something with a solid base, while having it easy to modify and enhance
09:46:05 <FliPPeh> s/want/need
09:46:08 <FliPPeh> :)
09:46:41 <oteren> no, actually
09:46:45 <oteren> the new id3v2
09:46:49 <oteren> is at the beginning of the file
09:47:18 <jmcarthur_work> FliPPeh, in haskell we tend to prefer simple composable pieces you can use to build bigger things with rather than open-ended pieces you can further complicate :)
09:48:19 <jmcarthur_work> this is the source of my frustration with things like inheritance
09:48:41 <FliPPeh> I know, but I cannot apply this style, because I'm always tempted to do lots of stuff inside a single function.. mostly in the IO monad, or any state monad :/
09:49:15 <sproingie> nothing wrong with IO, just lift stuff in there as needed
09:49:19 <rwx> FliPPeh, try to get a sense for how much work you'll waste if you keep on coding that way
09:49:47 <sproingie> you'll find as you lift more things you can factor out the stuff that doesn't really use IO
09:50:38 <sproingie> as for organizing beyond that, i'm still trying to figure it out.  not helped by my choice of project either.
09:50:54 <EnglishGent> what's your choice of project sproingie? :)
09:50:55 <FliPPeh> I'm obsessed with IRC bots
09:51:08 <sproingie> EnglishGent: a sim-roguelike, like dwarf fortress.
09:51:12 <FliPPeh> I don't know why, in every language I have ever used, I've always written one
09:51:42 <EnglishGent> perhaps becuase they are sort of turing-testish FliPPeh? :)
09:51:43 <FliPPeh> It starts to get lame, but hell, I want to top the last one I wrote in Haskell
09:52:06 <FliPPeh> It tells me a lot about the language's string, network and thread capabilities, yes
09:52:44 <lament> the world always needs more IRC bots.
09:52:48 <c_wraith> Hmm.  happstack is really low-level.  Is there any work on a higher-level web app project?
09:54:47 <qiemem> If I have, say, a binary tree with two identical subtrees, will there be two copies of the subtree in memory or just one? What if the two subtrees are evaluated at different times?
09:54:51 <jmcarthur_work> happstack is designed for flexibility, not the "convention over configuration" philosophy that the rails-like frameworks tout
09:55:07 <jmcarthur_work> besides that, i don't think it's very low level at all
09:55:20 <lament> qiemem: that depends on how the tree is created.
09:55:23 <jmcarthur_work> qiemem, it depends
09:55:40 <c_wraith> I guess I just felt that way since its fileserve module was too inflexible, so I had to reimplement that functionality
09:55:43 <sm> c_wraith: turbinado, orchid (I think), hack+loli
09:55:56 <jmcarthur_work> qiemem, let x = subtree in Tree x x -- will share the subtree structure on both sides
09:56:03 <sm> they're all immature
09:56:06 <c_wraith> But serving static files is low-level in any platform
09:56:10 <qiemem> lament, jmcarthur_work: I suspected as much. Anywhere I can find out what it depends on?
09:56:29 <jmcarthur_work> qiemem, search for sharing
09:56:35 <qiemem> jmcarthur_work: Ah, so do I have to make it explicit that they are in fact the same subtree?
09:56:45 <lament> qiemem: haskell should somehow know that they're the same, yeah
09:57:15 <lament> it's not going to randomly compare objects to see if they're the same
09:57:25 <jmcarthur_work> qiemem, if they are defined by the same expression, they should be shared unless that expression is parameterized in a significant way. probably best to just look it up for a more formal explanation though
09:57:53 <jmcarthur_work> qiemem, another thing to search for is "call be need"
09:58:10 <jmcarthur_work> *call by need
09:58:29 <qiemem> lament: I was thinking some clever hashing techniques or something could be employed, but I suppose that seems unreasonable.
09:59:24 <rwx> @src cons
09:59:24 <lambdabot> Source not found. Wrong!  You cheating scum!
09:59:32 <rwx> @src (:)
09:59:32 <lambdabot> Source not found. Are you on drugs?
09:59:35 <c_wraith> qiemem: especially when you are using expressions that involve functions
09:59:42 <qiemem> jmcarthur_work: Thanks! Sharing led straight to what I was looking for. I'll check out call by need too.
10:00:17 <c_wraith> how does one really check if two functions are equal?  ;)
10:00:53 <chrisdone> c_wraith: groan
10:02:05 <qiemem> c_wraith: I guess I was imagining that, post evaluation, the values could be checked against each other or something.
10:03:06 <jmcarthur_work> could be an interesting GC feature, perhaps, but i don't know if it's realistic
10:03:32 <qiemem> On a related note, does anyone know if vacuum accurately represents how the data structure is being represented in memory? That is, if the left and right of the root of my tree point to a single subtree, I can be sure that there is only one copy of it memory?
10:03:35 <chrisdone> wouldn't mind paying the speed hit if it saved memory and I REALLY needed all the memory I could get
10:03:38 <c_wraith> qiemem:  I meant things where that's really not feasible.  Like if you have "data Blah = Blah (Integer -> Integer)"...  Comparing two Blahs is basically impossible
10:04:34 <sproingie> it can't be done
10:04:36 <qiemem> c_wrait: Oh, oh. Got it. Misinterpreted what you said. Yes, that would be the case in which you couldn't possibly do what I'm talking about.
10:04:44 <qiemem> *c_wraith
10:05:14 <chrisdone> c_wraith: you could give a class instance for values that are cacheable and GHC picks up on that
10:05:25 <c_wraith> sproingie:  theoretically, it can, since Integer's implementation results in an upper and lower bound.  But there isn't that much CPU time in the universe
10:05:55 <sproingie> Integer has no bound other than the memory in your machine
10:06:12 <sproingie> if it's infinite, it will take infinite time
10:07:44 <c_wraith> I'm pretty sure there are limitations on Integer.  Like the number of words has to be less than maxbound :: Int
10:08:01 <c_wraith> Which more than exceeds memory on nearly every machine
10:08:05 <jmcarthur_work> Integer is bounded, it's just higher than your machine can handle
10:08:51 <c_wraith> And even if your machine had that much memory, there isn't enough CPU time in the universe to enumerate it anyway
10:09:28 <ben0x539> @quote hierarchical
10:09:28 <lambdabot> mauke says: trees are hierarchical
10:11:02 <ben0x539> :<
10:11:59 <tensorpudding> so we run into the hard limits of big numbers
10:12:01 <ben0x539> Is lambdabot's quote database on the web?
10:12:08 <tensorpudding> numbers too big for our piddly universe
10:12:12 <oteren> Java.BigInteger spits on you all!
10:12:54 <c_wraith> Java's BigInteger has the same limitation
10:13:00 <c_wraith> It uses an array of ints
10:13:04 <oteren> (it was a joke)
10:13:15 <oteren> probably the sloppiest big integer implementation in the universe
10:13:16 <ben0x539> Math spits on us all :<
10:13:28 <tensorpudding> what is the smallest number non-representable in the universe?
10:13:45 <oteren> with or without quantum numbers?
10:13:55 <c_wraith> In what system of representation?
10:13:58 <oteren> that too
10:14:26 <tensorpudding> i suppose it is representation dependent
10:14:30 <jmcarthur_work> the smallest is probably related to the largest
10:14:32 <Axman6> tensorpudding: it's 10, in base that number
10:14:46 <c_wraith> Axman6:  what about.....  11?
10:14:55 <sproingie> these go up to 11
10:14:55 <Axman6> can't be represented
10:15:04 <Axman6> just can't
10:15:10 <mercury^> tensorpudding: you mean the number you just represented?
10:15:11 <c_wraith> Now this feels like the Mr. Show sketch about the biggest number, so I'm going to stop.
10:15:15 <Axman6> stop trying, you're just making yourself look silly
10:15:21 <Twey> A(g_64, g_64)
10:15:39 <tensorpudding> let's not get into paradoxes here
10:15:49 <Twey> tensorpudding: It's not a paradox
10:16:07 <tensorpudding> talking about what i was thinking mercury^ was implying
10:16:07 <Twey> Er, it *results* in a paradox, but that paradox is quite relevant
10:16:20 <Twey> For someone to answer your question, they have to represent the number
10:16:23 <sproingie> if this paradox is paradoxical it is not a paradox
10:16:24 <tensorpudding> that by saying "this number can't be represented" i am representing it
10:16:25 <Twey> So it's unanswerable :þ
10:17:09 <tensorpudding> i'm thinking of a physical representation
10:17:32 <sproingie> ceci n'est pas une pipe
10:17:36 <tensorpudding> but of course, that depends on what you mean by physical representation
10:17:45 <Axman6> an easier one: what is the smallest number that cannot be described in ten words?
10:17:48 <mercury^> tensorpudding: you can perfectly well encode that sentence physically.
10:17:57 <tensorpudding> maybe one that distinguishes between every number
10:18:08 <mercury^> But the number is
10:18:11 <mercury^> > undefined
10:18:12 <mercury^> anyway
10:18:12 <lambdabot>   * Exception: Prelude.undefined
10:18:14 <c_wraith> I'd think it's slightly less pointless to ask a related question:  What's the maximum number of state changes possible in the universe, given reasonable assumptions about physics and the size of the universe?
10:18:19 <qiemem> tensorpudding: How is "the smallest nonrepresentable number" not a physical representation?
10:18:27 <sproingie> c_wraith: all of them
10:18:45 <Axman6> fuck, it's 5:20AM, and i hjave to leave in 20 minutes to go and cook breakfast for white ribbon day >_<
10:18:51 <tensorpudding> saying aleph-not does not mean that infinity exists
10:19:00 <c_wraith> sproingie:  the count thereof, that is.  Assuming you had all the energy in the universe to work with, etc.
10:19:03 <tensorpudding> err, aleph-naught
10:19:06 <qiemem> But you are representing it.
10:19:11 <sproingie> more than ten
10:19:20 <mercury^> qiemem: he is representing bottom.
10:19:23 <Axman6> depends is represent == describe
10:20:10 <tromp_> let's make it easier, what is the smallest number that cannot be described in one word?
10:20:32 <Axman6> it
10:20:32 <Apocalisp> how long is a word?
10:20:33 <qiemem> make one ten
10:20:34 <tensorpudding> the nature of language makes that question unanswerable
10:20:52 <qiemem> and word words
10:21:25 <qiemem> Ditto for the representation question, though, right?
10:21:37 <tromp_> how many words is onehundredandone?
10:22:08 <Polarina> How would I use darcs to run a series of tests (test suite) before pushing each patch?
10:22:18 <Axman6> qiemem: i think it's more fun it you make is largest too
10:22:44 <c_wraith> tromp_:  7
10:22:49 <qiemem> ha, right didn't catch that
10:23:02 <qiemem> Or, wait, why?
10:23:04 <mercury^> Axman6: because every number above a certain bound can be described?
10:23:06 <mercury^> :P
10:23:53 <Apocalisp> What's the measure of size here? Number of factors?
10:24:48 <mercury^> Apocalisp: a well order is preferable.
10:24:49 <c_wraith> Polarina:  It can be done.  I'm trying to find it.  (It's not completely obvious, and easy to forget once you set it up)
10:27:08 <c_wraith> Polarina: darcs setpref test <command to run>
10:27:12 <c_wraith> Polarina: I think
10:27:29 <Polarina> c_wraith: Thanks. Is that local for the user?
10:27:48 <c_wraith> Polarina:  Using setpref allows you to record it and push it as a patch
10:27:52 <qiemem> Oh, hey, about my original question though: is there any way to tell when sharing will occur? Or does it only happen for things like "let x = sin 5; x+x"?
10:28:07 <Polarina> Nice.
10:32:42 <jmcarthur_work> qiemem, i suppose there is a way to force it (let) but not a way to tell generally due to (the rarely invoked by ghc?) CSE optimization
10:33:00 <eivuokko> qiemem, And what would you expect to be the "other kind" of sharing?
10:33:20 <jmcarthur_work> eivuokko, CSE would be one way
10:33:54 <qiemem> If you had (expression1, expression2), and expression1 and expression2 resulted in the same value.
10:34:09 <eivuokko> jmcarthur_work, Yes, but as you point out, it doesn't really happen.
10:34:10 <jmcarthur_work> i don't think you can tell
10:34:15 <jmcarthur_work> eivuokko, it does sometimes
10:34:36 <eivuokko> There's also some optimisation in ghc gc for ints and chars.
10:34:57 <jmcarthur_work> i recall an example for two invokations of the same thing in the Writer monad resulting in CSE completely eliminating half the work
10:35:04 <jmcarthur_work> resulting in an exponential speedup in this particular case
10:35:34 <doublethink_work> i believe it was roconnor who did that
10:36:02 <doublethink_work> naive translation from python -> haskell == runtime implosion
10:36:13 <jmcarthur_work> that's right
10:36:30 <eugenn> I want a function that takes a number, and if the number is less that 5 returns [1,2,3], otherwise return 8. Is it true that it's impossible to do it in Haskell because of the type checking?
10:36:45 <jmcarthur_work> eugenn, you could return [8] instead
10:36:46 <lament> eugenn: yes.
10:36:57 <jmcarthur_work> or you could do Either [Int] Int
10:37:02 <doublethink_work> eugenn: yes, but you can wrap those return possibilities in a datatype
10:37:04 <doublethink_work> like Either
10:37:05 <ben0x539> Do we not just need a Num instance for lists?
10:37:17 <Botje> eugenn: how will this function be used?
10:37:21 <eugenn> ooh yes I see
10:37:23 <Twey> ben0x539: No
10:37:30 <Twey> ben0x539: You'd also need existential types
10:37:37 <lament> eugenn: but yeah, most importantly, why the hell would you ever want this?
10:37:42 <lament> your function is nuts.
10:37:48 <eugenn> No, it's just an example they gave in class of something haskell forbids to do
10:37:49 <jmcarthur_work> Twey, i don't see how you would need that
10:37:59 <jmcarthur_work> Twey, instance Num a ⇒ Num [a] where...
10:37:59 <lament> eugenn: right, haskell forbids to do it, because it's nuts
10:38:13 <jmcarthur_work> not that it's such a great idea, in my opinion
10:38:27 <eugenn> It could be done in dinamically typed languages
10:38:35 <lament> eugenn: while there're some legitimate cases for mixing types, that function is exactly the example of something that's probably a bug and that haskell rightfully disallows
10:38:38 <jmcarthur_work> eugenn, to what purpose though?
10:38:40 <Twey> eugenn: But good style forbids it, even there.
10:39:07 <eugenn> I see, so in any case it's a bad thing to do
10:39:09 <doublethink_work> eugenn: that can be qualified as both a good and bad thing
10:39:30 <lament> if you write such a function in Python (which you can do), Python programmers will certainly frown at you
10:39:32 <doublethink_work> but i mostly rank it as bad :)
10:40:35 <eugenn> thanks for the answers :)
10:55:35 <Apocalisp> @type \x -> if x < 5 then Left [1,2,3] else Right 8
10:55:36 <lambdabot> forall a t b. (Num a, Ord a, Num t, Num b) => a -> Either [t] b
10:56:02 <Apocalisp> eugenn ^^
10:56:15 <eugenn> hi!
10:57:06 <Cale> eugenn: Yeah, as Apocalisp points out, if you really need to produce values of two different types, you can use Either.
10:57:10 <tensorpudding> either is kinda nasty
10:57:27 <Apocalisp> nasty?
10:57:40 <Cale> eugenn: If things are more complicated still, you can define a new datatype of your own. The advantage to using Either in the simple case is that many instances for it already exist.
10:57:44 <tensorpudding> well rather, in this case it is nasty
10:57:46 <prof_nimnul> And HList is even nastier :-)
10:58:14 <eugenn> oh, I thonk I grasp waht Either does
10:58:19 <eugenn> *think
10:58:22 <Apocalisp> Either is disjoint union. It's fundamental.
10:58:57 <Apocalisp> @type either -- Either is the datatype encoding of this function
10:58:58 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
10:59:31 <eugenn> I see
11:00:01 <eugenn> I could define something like Either that lets me do left, right, up and down, or even more 'dimensions' right?
11:00:10 <Apocalisp> what would you do if you called this kind of function in a dynamic language? What would you do with the return value?
11:00:22 * Cale wonders why Xorg has grown to 335 MB, with 270 MB resident...
11:01:00 <mercury^> eugenn: most likely the program you have at hand (if any) can be solved better by not translating a previous solution in another language word by word.
11:01:02 <eugenn> I guess I didn't thought abot that :) it would be terribly messy code
11:01:02 <Cale> eugenn: Well, yes, though the Left and Right are mostly labels for which type of the two type parameters.
11:01:35 <Apocalisp> eugenn: You would have to figure out if it had returned a list or a number.
11:01:53 <eugenn> right
11:02:00 <Cale> eugenn: (and since you can't place type parameters in two dimensions, the Up and Down wouldn't quite work out in the same way :)
11:02:22 <eugenn> This was told to me as an example of a property of statically typed languages that could be seen as a disadvantage
11:02:32 <eugenn> But it's clear it's not a big deal
11:02:33 <mercury^> Cale: Right, Up, Left, Down.
11:03:01 <Apocalisp> Either [Int] Int   means "a list of integers or an integer".
11:03:18 <Cale> B, A, B, A, Select, Start?
11:03:27 <eugenn> haha
11:04:18 <mercury^> Cale: :D
11:04:48 <qiemem> eugenn: Honestly, I've come to see such things as advantage. Its like the compiler telling you, "You know, that's really not a very good idea." and you're like "Doh! You're totally right! Didn't even think about the consequences of my actions." Haskell's type system is totally like that angel on your shoulder like in those cartoons.
11:05:13 <Gracenotes> hm. is there a trac page about allowing "case of { alts }", which is sugar for "\x -> case x of { alts }"?
11:05:43 <eugenn> I agree. I wonder where haskell is not nearly as popular as e.g. Java
11:05:48 <mercury^> qiemem: if Data.Dynamic was better I'd agree with you wholeheartedly.
11:05:52 <eugenn> I'm sure there a good reson for that though
11:05:56 <mercury^> But as is, the type system is sometimes very annoying.
11:06:39 <Cale> eugenn: Because it's too different from the programming languages of the 1970's and people are resistant to any real change :)
11:07:03 <Apocalisp> eugenn: In some cases, it totally makes sense to want to return "either a value of type a or a value of type b". For example: Maybe. (Maybe a) is equivalent to (Either () a).
11:07:07 <Gracenotes> Google search doesn't yield anything
11:07:26 <eugenn> wow, if that one of the most powerful reasons then I'm surprised!
11:08:00 <mercury^> Gracenotes: doesn't seem too useful.
11:08:07 <Apocalisp> inertia is a powerful reason
11:08:19 <medfly> eugenn, a lot of people come here complaining about how Haskell is very different from what they know.
11:08:30 <eugenn> Apocalisp: I have almost non-existant knowledge about Maybe, but it has something to do with monads right?
11:08:48 <Cale> eugenn: It happens to be a monad.
11:08:53 <qiemem> eugenn: It is a monad.
11:08:56 <Cale> eugenn: But it's just a simple datatype
11:08:58 <mercury^> eugenn: it is a Monad, but you can understand it without understanding Monads (not that monads "are hard").
11:09:03 <Cale> data Maybe a = Nothing | Just a
11:09:25 <Gracenotes> mercury^: it seems nice as a syntactical idiom. in most cases, code is structured so case statements aren't used like that
11:09:29 <mercury^> Maybe is probably a good monad to study if you want to learn about monads.
11:09:42 <Gracenotes> particularly when it comes to explicit parameters
11:09:47 <Rotaerk> lists are too
11:09:59 <sproingie> lists are tricky
11:10:00 <qiemem> Cale: Cale! Its bryan`, if you remember from back a while ago (changed my name). You taught me some category theory? Oh, and how to use irc. :P
11:10:03 <medfly> eugenn, besides, it's not like some big company is behind Haskell.
11:10:23 <holmak> I think RWH has a pretty sweet example of the list monad in action
11:10:25 <Apocalisp> Lists are just the free monad of monoids. Any foo kno that.
11:10:27 <lament> medfly: microsoft!
11:10:28 <eugenn> right, I didn't think about that
11:10:29 <int-e> is there a lossless cabal file parser somewhere? (I'm thinking of writing a tool for manipulating dependencies. Such a parser would be a good starting point.)
11:10:30 <Philonous> medfly: Microsoft is not that big, is it.
11:10:36 <Cale> qiemem: Perhaps I do :)
11:10:36 <eugenn> a monad is not always a datatype right? this is only a specific case
11:10:44 <medfly> is Microsoft pushing for Haskell to be used?
11:10:47 <medfly> do they even use it?
11:10:53 <sproingie> microsoft employs the Simons
11:10:53 <holmak> MS research loves haskell
11:11:14 <int-e> eugenn: there is an  instance Monad ((->) r)  for functions.
11:11:16 <holmak> if you grab the source for their latest experiemental OS, barrelfish
11:11:23 <eugenn> I'm sure MS copied more that one concept of haskell to C#
11:11:26 <holmak> absolutely full of haskell tools
11:11:35 <medfly> but they're pushing for C#, which is indeed somewhat popular.
11:11:38 <sproingie> eugenn: F# perhaps.  C#, i can't say they did.
11:11:39 <lament> medfly: MS is pushing for haskell research, not haskell usage.
11:11:40 <qiemem> Cale: Heh. I've been enjoying those catsters videos. Introduced some others to them as well.
11:11:40 <tensorpudding> probably F#
11:11:45 <dcoutts> int-e: I've been planning to overhaul the main Cabal parser for some time with that feature in mind
11:11:46 <medfly> ^^
11:11:49 <lament> medfly: ...which is what haskell is designed for
11:11:51 <sproingie> F# gets more from ocaml, and is developed by different people
11:11:54 <sproingie> MS is not a hive mind
11:11:58 <medfly> I personally like how Haskell isn't popular.
11:12:07 <lament> sproingie: different people who work next door
11:12:08 <dcoutts> int-e: if you go ahead, it'd be great if you could design it to go into the main Cabal lib
11:12:15 <medfly> because if it were, this channel would be more like ##php
11:12:16 <eugenn> oh right, F# has more of functional paradigm
11:12:17 <holmak> few backward dependencies to break
11:12:27 <akappa> medfly, because you think it's cool to master an "esoteric" language?
11:12:31 <medfly> instead, I get to meet all these cool, unusually smart people.
11:12:36 <ben0x539> Is it semantically correct and morally proper to use ErrorT for any monadic shenanigans where I might want to abort, whether it is a proper error condition or not?
11:12:51 <sproingie> ben0x539: it certainly beats using fail
11:12:53 <holmak> I like that, "monadic shananigans"
11:12:54 <Philonous> If haskell whas popular, we'd never see dependent types in it.
11:12:55 * Cale likes how Haskell isn't popular also. Popularity makes it hard for languages to change, and so the things which are broken in a popular language will never improve.
11:12:59 <sproingie> monadigans
11:13:07 <ben0x539> sproingie: Right now it just ought to be a lot of nested if/case expressions.
11:13:10 <eugenn> Very good point
11:13:12 <tensorpudding> it's pretty impossible to have a fun channel that is full of so many people
11:13:15 <mercury^> Cale: you think Haskell is still fundamentally improving? :>
11:13:16 <dcoutts> int-e: the design I was thinking of uses two stages where the first stage retains all the info (comments etc) but the second stage does not
11:13:25 <Cale> mercury^: I'd like to think it's still possible.
11:13:25 <holmak> ##c++ is brutal
11:13:26 <medfly> akappa, no, because it means that people who aren't very good or interested in programming would know it. :)
11:13:27 <lunabot>  luna: parse error on input `|]'
11:13:29 <sproingie> ben0x539: sounds like a case for a monad :)
11:13:45 <Cale> mercury^: That optimism might be unfounded.
11:13:47 <ben0x539> sproingie: I mean, I am in the IO monad already, but clearly adding more monads will make my code simpler.
11:13:47 <copumpkin> ALLO ALLO
11:13:47 <dcoutts> int-e: then there'd be a way of printing a PackageDescription back to the intermediate representation and merging the old and new to preserve layout and comments for the bits that had not changed
11:13:51 <copumpkin> holmak: orbitz makes it especially brutal to make people appreciate #haskell more
11:14:07 <akappa> medfly, but haskell, unlikely php, requires a good understanding of the principle of the language in order to do anything significant
11:14:18 <copumpkin> php is indeed very unlikely
11:14:24 <akappa> medfly, so I think that the "quality" of the community is somehow "intrinsic"
11:14:41 <mercury^> Cale: even spj said it is far more likely for a new language to come along with fundamental improvements iirc.
11:14:45 <akappa> *unlike
11:14:50 <medfly> I dunno. as a complete idiot, I can tell you that I can get Haskell.
11:14:52 <sproingie> ben0x539: ErrorT is a perfectly good monad, and it makes fail not suck, tho you should still use throwError instead of fail
11:15:09 <akappa> medfly, it's a fact of competency, not of intelligence :)
11:15:10 <medfly> I don't do very complex things, but I can use it, and I hang out here.
11:15:17 <ben0x539> Ideally I would use a custom error type that is an algebraic data type so that I might decide what to do with the errors at a single point
11:15:19 <sproingie> s/good monad/good monad transformer/
11:15:26 <Twey> 19:16:03 < copumpkin> holmak: orbitz makes it especially brutal to make people appreciate #haskell more
11:15:26 <Apocalisp> medfly: Heh, that's what I tell people too. If I can get Haskell, then so can you!
11:15:28 * Twey chuckles.
11:15:30 <Apocalisp> a fortiori
11:15:45 <sproingie> theory-wise i'm a total moron, but i grok the basics of haskell now.
11:15:46 <copumpkin> fortior!
11:15:50 <medfly> if maybe 80% of the channel was like me, then this channel would look more like other programming language where people do very silly things.
11:16:07 <Twey> @remember copumpkin orbitz makes [##C++] especially brutal to make people appreciate #haskell more
11:16:07 <lambdabot> Done.
11:16:08 <sproingie> figuring out how to assemble larger programs is a little tough for me, but i just have to try it and fail a few times i guess
11:16:21 <BONUS> has anyone noticed a huge increase of homework inquiries in the past week or so?
11:16:28 <Twey> BONUS: They come and go
11:16:29 <copumpkin> BONUS: it's near the end of terms
11:16:30 <BONUS> on the channel and in general
11:16:35 <BONUS> ah
11:16:56 <akappa> medfly, I think that this channel is interesting because it is filled with mathematicians :D
11:17:01 <sproingie> not me
11:17:01 <medfly> but now, people discuss advanced maths here and theoretical ideas, and I get to learn a fair bit, and now my employer actually thinks I'm this hax person.
11:17:03 <medfly> hurray!
11:17:09 * sproingie is more an amateur philosophy geek
11:17:10 <copumpkin> BONUS: I'm sure finals are coming up
11:17:23 <copumpkin> medfly: omgwtfhax
11:17:25 <BONUS> imo haskell shouldn't be taught in undergrad
11:17:29 <mercury^> medfly: you haz job now?
11:17:29 <int-e> dcoutts: oh so you'd manipulate the package description rather than the intermediate representation. which is great of course if the merging operation works reliably. food for thought.
11:17:30 <copumpkin> shouldn't???
11:17:35 <medfly> mercury^, omg yes!!!!!!
11:17:37 <sproingie> similar mindset tho, abstraction appeals to me :)
11:17:40 <copumpkin> BONUS: so you want it in high school instead, right?
11:17:44 <BONUS> haha
11:17:49 <copumpkin> I'm serious :P
11:17:49 <BONUS> well i'm only semi serious
11:17:51 <lament> highschool
11:17:52 <sproingie> grade school
11:17:56 <dcoutts> int-e: ideally yes
11:18:03 <BONUS> but i can see how if haskell was forced upon me
11:18:03 <sproingie> seriously.  some logo-like subset of haskell would be ideal
11:18:03 <copumpkin> I wish I had been introduced to it way earlier
11:18:04 <akappa> BONUS, in my university they taught ocaml in the first year courses, and people hate it
11:18:07 <sproingie> the Turtle monad
11:18:10 <Philonous> BONUS: You kiddin, right? they should never spoil those poor kids minds with anything that doesn't have at least a type system that deserves it's name
11:18:13 <medfly> mercury^, however, I fear that my employer will learn what nick I use on line
11:18:13 <copumpkin> it would've changed my perception of CS
11:18:17 <akappa> BONUS, imagine what they should think about haskell :D
11:18:19 <nagnatron> I'm sure there are kids being home schooled in Haskell right now.
11:18:20 <BONUS> haha
11:18:24 <medfly> mercury^, he uses IRC too, and I had to tell him about freenode
11:18:24 <dcoutts> int-e: but the intermediate representation is useful anyway, the parser pretty much has to be two-stage
11:18:37 <BONUS> i mean if uni forced me to learn haskell with the university pace, i'd probably hate it by now
11:18:37 <medfly> mercury^, ever since then I think twice about asking for help with my tasks on IRC.
11:18:45 <sproingie> come to think, anyone actually gone and done a Turtle monad?
11:18:46 <medfly> BONUS, slow?
11:18:47 <mercury^> ^^
11:18:54 <BONUS> hehe, well depends
11:18:55 <dcoutts> int-e: so for your use case you might be able to get away with only doing the first stage parse and then looking through the semi-parsed tree
11:18:56 <akappa> "pattern match? WTF is that shit? I want cycles and conditional branches!!!"
11:18:58 <mercury^> Well, as long as the problem is solved, he shouldn't care about the methods you employ.
11:19:17 <dcoutts> int-e: but it'd still be useful to have that first lossless stage in the main Cabal lib parser
11:19:20 <EnglishGent> sproingie - I've been thinking along *exactly* those lines of late (a logo like subset)
11:19:21 <sproingie> akappa: more like "branches?  WTF, I want pattern matches!"
11:19:24 <BONUS> but maybe it's just me, i tend to really hate doing everything i *have* to do
11:19:29 <BONUS> and love doing stuff i don't have to
11:19:29 <ben0x539> sproingie: Someone should totally build a Turtle monad.
11:19:32 <medfly> mercury^, but I have this fear that people I know in real life will know about what I do on IRC
11:19:35 * EnglishGent is interested in the problem of designing child friendly computer languages
11:19:36 <ben0x539> cairo should be up to it
11:19:46 <Cale> ben0x539: Cairo basically is a turtle monad.
11:19:50 <copumpkin> BONUS: depends how it's presented to you, I think
11:19:51 <BONUS> that's why i'd think hard before accepting a haskell job, cause i love haskell so much
11:19:55 <nagnatron> What do people here think of the channel 9 Haskell videos by Erik Meijer?
11:19:58 <Apocalisp> akappa: A common programmer newbie mistake is to choose large amounts of familiar complexity over unfamiliar simplicity.
11:20:01 <lament> medfly: You're fired.
11:20:02 <EnglishGent> the thing that bothers me re: children & Haskell is the whole monad thing - enough adults find it confusing
11:20:02 <sproingie> i think haskell's error feedback might not quite be up to a child friendly subset
11:20:04 <medfly> mercury^, I like the real life me.
11:20:07 <medfly> hahaha
11:20:12 <akappa> Apocalisp, ahah, nice nick :)
11:20:20 <Apocalisp> ta
11:20:22 <Philonous> BONUS: You'd love my programming languages professor. He's the reason I started learning haskell in the first place, because he made fun of it
11:20:25 * EnglishGent has been wondering if that problem might be mitigated with some careful overloading of standard operations
11:20:39 <BONUS> Philonous: haha cool. sadly, such is usually the exception
11:20:41 <sproingie> calling it something other than "Monad" might help
11:20:49 <EnglishGent> sproingie - how about Action ?
11:20:56 <BONUS> most attempts to teach languages at my uni were boring as hell
11:20:57 <sproingie> with a logo subset, you could call 'em turtles
11:21:13 <BONUS> i think when learning languages, it's really important to have your own pace, and not a pace that's imposed
11:21:14 <sproingie> or "shells"
11:21:25 <sproingie> EnglishGent: actions are more like monadic values
11:21:25 <BONUS> some might breeze by some subject matters but then get stuck on others
11:21:26 <medfly> BONUS, my sister is learning C at uni now, she does seem to get that WOAH! IT WORRRRRRRKS! excitement.
11:21:35 <copumpkin> aha, now I know why psykotic hasn't been posting often
11:21:39 <akappa> Apocalisp, few people realize that some things takes a little to master but let you lower the complexity
11:21:40 <copumpkin> he too is addicted to dragon age
11:21:42 <copumpkin> just like edwardk
11:21:52 <akappa> Apocalisp, this is true even in object-oriented context
11:21:56 <Philonous> BONUS: Don't get me wrong, this guy doesn't know jack. He thinks java is some kind of silver bullet. He seriously dislikes haskell.
11:22:04 <medfly> BONUS, though I imagine I'll just act it as an easy class to do other things at.
11:22:04 <BONUS> oh? lol
11:22:09 <BONUS> java profs haha. never change.
11:22:15 <EnglishGent> <cliche>when all you have is a hammer....</cliche>
11:22:22 <lament> not like Haskell profs - they change all the time (?)
11:22:24 <sproingie> mmm dragon age.  i've gotta get that.
11:22:29 <Apocalisp> akappa: Very true in a lot of contexts. I don't know, how you say, "object-oriented".
11:22:39 <akappa> a good, unit-testable design might be boring to design, but it let you debug and implement the program quickly and with less pain
11:22:41 <int-e> EnglishGent: you'll soon starve to death ;)
11:22:45 <chrisdone> there a quick IO function I can use inside ghci to test execution time?
11:22:49 <sproingie> not sure if i should get it PC or console.  PC is supposed to be more challenging, but consoles Just Work.
11:22:54 <akappa> s/to design/to obtain/
11:22:56 <copumpkin> sproingie: don't get it!
11:22:57 <int-e> EnglishGent: (non-cliche continuation)
11:23:04 <copumpkin> sproingie: you'll never get any work done afterwards!
11:23:22 <sproingie> i have a new kitten.  not getting any work done these days anyway
11:23:29 <sproingie> he likes to jump up on my keyboard
11:23:32 <medfly> it's the kitten!
11:23:39 <akappa> I'll go to see inter-barça... see you!
11:23:46 <medfly> have fun akamaus
11:23:47 <medfly> er..
11:23:49 <medfly> akappa,
11:23:55 <lament> ooh that sounds fun
11:24:04 <lament> i'm gonna watch them at lunch!
11:29:09 <chrisdone> sproingie: he likes big keyboards and he cannot lie. those other kitties can't deny
11:30:13 <prof_nimnul> @hoogle Microbench
11:30:14 <lambdabot> No results found
11:30:27 <Lemmih> chrisdone: :set +s
11:30:53 <chrisdone> :(
11:30:54 <prof_nimnul> @hoogle microbench
11:30:55 <lambdabot> No results found
11:31:00 <jfredett_> chrisdone: we a machine boots up with an itty-bitty mouse and some keys as big as a house you get ...
11:31:06 <jfredett_> s/we/when/
11:31:25 <chrisdone> Lemmih: oh, haha. I read that as /set, and +s as silent. hehe
11:31:29 <chrisdone> Lemmih: nice one, thanks
11:31:30 <prof_nimnul> christdone: there is a microbench package on Hackage http://hackage.haskell.org/packages/archive/microbench/0.1/doc/html/Microbench.html
11:31:58 <chrisdone> prof_nimnul: hmm nice idea
11:32:11 <chrisdone> prof_nimnul: that's actually what I'm doing, comparing implementations of the same algo.
11:37:24 <chrisdone> does anyone else code with like three buffers open and ghci?
11:37:34 <chrisdone> I need a bigger screen
11:37:50 * copumpkin has a 30-incher
11:37:57 <Rotaerk> ..
11:38:01 * copumpkin hugs said screen
11:38:02 <chrisdone> copumpkin: hello, sailor!
11:38:07 <chrisdone> how much was that?
11:38:34 * Cale considers @remembering that quote out of context
11:38:42 <chrisdone> hehe
11:39:27 <prof_nimnul> chrisdone: Perl has a rather elaborate benchmarking library. You can look at their design and implement something like that yourself. http://search.cpan.org/~dapm/perl-5.10.1/lib/Benchmark.pm
11:39:48 <prof_nimnul> chrisdone: You'd better buy several monitors
11:40:03 <copumpkin> lol
11:40:08 <chrisdone> yeah
11:40:16 <copumpkin> criterion is cool!
11:40:35 <chrisdone> http://chrisdone.com/pics/needbiggerscreen.png
11:41:02 <Cale> Seriously? DoAndIfThenElse is accepted?!
11:41:08 <copumpkin> lol
11:41:13 <copumpkin> such a radical language standard, eh
11:41:38 <Cale> But even if you're changing minor things, don't pick the stupid ones.
11:41:56 <chrisdone> I thought it was a monadic-do and monadic-if. at first I was like :D, but then I :(
11:42:18 <Rotaerk> is that ubuntu?
11:42:41 <Rotaerk> nm, yes
11:42:52 <tensorpudding> ubuntu is a thing
11:44:10 <Cale> If anything, I would make the layout rule stricter and less willing to accept garbage layouts.
11:44:39 <Cale> I would demand that the 'then' and 'else' are aligned to the same column if they appear on different lines.
11:45:05 <Twey> Cale: Why shouldn't it be accepted?
11:45:26 <copumpkin> I want if/then/else to get dropped from the language!
11:45:26 <Cale> Twey: because it helps people indent their source in a messy way
11:45:33 <copumpkin> so damn making workarounds for its layout :P
11:45:43 <tensorpudding> what would we replace if then else with?
11:45:50 <tensorpudding> every language has it
11:45:51 <copumpkin> nothing
11:46:00 <copumpkin> or a function or two, possibly with an inverted fixity for $
11:46:10 <tensorpudding> that would be nice
11:46:17 <tensorpudding> maybe
11:46:19 <tensorpudding> if it wasn't confusing
11:46:53 <Cale> Twey: We already have enough of a problem with people coming from C indenting if/then/else incorrectly. We don't need to help them do it the wrong way. ;)
11:46:54 <edwardk> I would rather see a generalized form of DoAndIfThenElse -- it is just a symptom of a larger potential fix
11:47:06 <copumpkin> omg it's edwardk
11:47:10 <Twey> I concur
11:47:11 * copumpkin is about to hop on a bus!
11:47:16 <Cale> edwardk: I think the layout rule should be much more draconian :)
11:47:42 <edwardk> uniform version: if you have an open ( [ or other opening context then don't do semicolon insertion. treat if..else like [..] and (..)
11:47:57 <edwardk> then you get all of the c formatting you can stomach and layout isn't broken
11:48:35 <edwardk> and you can end your paren or brace or bracket on the following line like a c programmer
11:48:50 <Cale> edwardk: Why should the compiler let people write code like that?
11:49:01 <edwardk> cale: why should it force you to waste spaces? =)
11:49:02 <prof_nimnul> I once tried to design a language and allowed only exactly one \t for identation, and trailing spaces/empty lines were syntax errors
11:49:48 <prof_nimnul> Draconian formatting rules remind me of VB6 with its autoformatting
11:49:50 <edwardk> cale: i implemented things that way for kata because it gave me a consistent version of the if then else rule
11:49:56 <tromp_> i wldnt mind a language that forbids tabs altogether
11:50:00 * hackagebot upload: data-aviary 0.2.0 - Combinator birds. (StephenTetley)
11:50:05 <copumpkin> yep, let's forbid tabs!
11:50:10 <copumpkin> anyway, off I go, ciao :)
11:50:16 <luqui> that's not really necessary
11:50:18 <edwardk> see you soon pumpkin
11:50:24 <Cale> edwardk: I would simply demand that unless 'then' and 'else' are on the same line, they must start in the exact same column.
11:50:28 <edwardk> er that sounded like a term of endearment
11:50:33 <luqui> all you have to do is make tabs and spaces incomparable for indentation comparisons
11:50:53 <Cale> I think tabs should be a lexical error
11:51:03 <edwardk> cale: it was an easier fit for my combinators for me to go with treating if and else as a matched pair =)
11:51:31 <prof_nimnul> mixing tabs and spaces is not good. Either only tabs or only spaces.
11:51:31 <Cale> I don't understand how 'else' could be anything like 'if'
11:51:34 <edwardk> if else, case of, ( ), [ ], { }
11:51:38 <luqui> edwardk, what is kata all about anyway?
11:51:58 <edwardk> luqui: short answer: rip out the type system of haskell and see what you can run on a spineless tagless g-machine
11:52:38 <luqui> oh... i thought it would have something to do with recursion schemes, given its name
11:52:42 <edwardk> luqui: long answer, ripping out the types costs you typeclasses, so you need modules, modules suck for verbosity, so borrow tools from oop to get code reuse on modules and avoid having to qualify everything
11:52:45 <Cale> prof_nimnul: Also, tabs are bad. Only spaces.
11:53:10 <luqui> that's a very ... opinion
11:53:50 <luqui> edwardk, hm.
11:54:30 <edwardk> luqui: end result is a lazy language with half of a type system. the type system can check to make sure that you provided all of the properties to instantiate a class, and classes exist for code reuse purposes, but aren't used for dispatch once everything is flattened out.
11:54:42 <prof_nimnul> Flexible space is bad. It encourages you to paint ascii art in source code instead of working.
11:54:58 <luqui> i'm getting irritated hearing "X is good / Y is bad"
11:55:04 <luqui> i suppose i could not listen
11:55:39 <luqui> prof_nimnul, oh, it was a joke.  ha... far be it from me to read your entire line before complaining!
11:56:04 <Cale> prof_nimnul: When alignment is syntax, using space to align things gets work done :)
11:56:37 <edwardk> luqui: in the end, classes are my mechanism for code reuse, but they are tossed around like module signatures, you tend to make smart objects that manipulate dumb data.
11:56:39 <Cale> But tabs have come to mean an arbitrary unknown amount of space, and so they have no place in any such language.
11:57:12 <luqui> edwardk, hmm. hard for me to visualize, but i think i see what you're saying
11:57:14 <edwardk> cale: i feel the same thing about the fixed width font. why should every character have the same width cost? =)
11:57:41 <edwardk> luqui: /j #kata and i'll go deeper if you want. i don't want to spam the poor people here again ;)
11:57:41 <Cale> edwardk: If you want to do away with the fixed width font, storing things as text is probably a bad idea.
11:58:01 <edwardk> Cale: bah, take any japanese font for instance. ;)
11:58:17 <luqui> edwardk, i'm kind of on a different sort of binge atm.  another time :-)
11:58:23 <edwardk> luqui: np
11:59:10 <rwx> i'm writing code to index numbers like lists, e.g. 12345 !! 2 == 3; i'm wondering about how to do this concisely; how does it work to extend a typeclass? (this may not be the correct term)
11:59:24 <Cale> edwardk: Ah, okay, in that sense. Well, we probably should have some provision for other cell-widths there.
12:00:11 <edwardk> cale: well, there is a fairly simple fix. any layout that depends on the width of a token be it a space, tab, or any other character should be a syntax error.
12:00:21 <edwardk> then you can do on one line, or do multiline do, etc.
12:00:21 <ray> integer multiples of your fixed width are still fixed width
12:00:32 <edwardk> cale: not willing to propose that for haskell
12:00:47 <luqui> edwardk, oh, here's something you (i guess others on this channel) could help me with.   how is continuity expressed in CT?
12:00:47 <ray> (philosophically)
12:00:53 <edwardk> but if you're starting from scratch wit hthe intention of designing a layout oriented unicode encoded language, it isn't a terrible leap
12:00:55 <prof_nimnul> Cale: Variable tab length is an obstacle only if tabs can freely be mixed with spaces. Let's say syntax forces you to indent using exactly one tab and nothing else. Then everybody can have his own visually appealing tab size in editor, and things don't break. Everyone still has his code aligned.
12:01:28 <Cale> prof_nimnul:
12:01:38 <Cale> foo = do x <- getLine
12:01:39 <edwardk> luqui: preservation of limits
12:01:40 <ray> i'd like to extend the same argument, but for variable space length
12:01:44 <Cale>          putStrLn x
12:02:11 <Cale> prof_nimnul: It's important to be able to align with specific characters in the previous line.
12:02:19 <luqui> edwardk, ah, simple enough.  i still have a vague picture of what a limit is, and pictures are what i'm after. :-)
12:02:49 <Cale> prof_nimnul: Tabs are the wrong thing. Perhaps some sort of encoding whereby a specific character is used to mark a position where the next line can align to.
12:02:56 <prof_nimnul> Cale: it's a bad idea to use such alignment, I think
12:03:06 <edwardk> luqui: in a category of type sense, they transform into universal quantification (or existential for colimits)
12:03:20 <Cale> prof_nimnul: But of course, that requires editor support, and it just becomes ridiculous quickly -- why not just store the syntax tree directly?
12:03:22 <prof_nimnul> Cale: Well, at least I have never used that
12:04:13 <edwardk> luqui: it is a little tricky to see that given the monomorphic nature of category-theory-as-defined
12:04:23 <prof_nimnul> Cale: Storing a tree directly will force if...then..else to always have the same shape
12:04:51 <prof_nimnul> and I don't know if it's good or bad
12:04:56 <luqui> edwardk, yeah, i have a lot of trouble with CT's language sometimes, although I find the concepts (that i understand so far) aren't too bad.
12:05:00 <Cale> prof_nimnul: Well, it'll always have some sane shape based on what fits best on the page
12:05:18 <Cale> prof_nimnul: With the 'then' and 'else' either on the same line, or directly aligned vertically.
12:05:26 <edwardk> cale: my answer for that in kata is that that use of do is an unfortunate syntax error. it is brittle with regards to refactoring anyay. rename foo to foo' and it breaks unless you do a potentially large amount of indentation below it
12:05:48 <luqui> edwardk, so... F continuous if forall x. F (G x) = F (forall x. G x)  ?  that seems wrong
12:05:51 <Cale> edwardk: An editor can easily take care of that
12:06:46 <edwardk> luqui: http://en.wikipedia.org/wiki/Limit_(category_theory)#Preservation_of_limits
12:06:50 <Cale> edwardk: We should have editors which are aware of the layout keywords, so that any edit which causes the first non-whitespace character after a layout keyword to move will move the rest of the block
12:06:58 <luqui> edwardk, thanks
12:07:09 <Cale> edwardk: and it should be recursive, so that all the rest of the layout blocks inside that block will move along with it :)
12:07:25 <prof_nimnul> Cale: Well, I type foo = do\nx <- getLine
12:07:50 <Cale> prof_nimnul: Yeah, I don't particularly care for that somehow. I'll move the do to the next line along with the block if I do that.
12:07:56 <edwardk> cale: the alternative is that i can make a minor change in a nascent language definition that no one uses yet anyways, and i get a syntax that permits local refactoring without the need of a magical unwritten editor ;)
12:08:04 <Cale> foo some long parameters which take lots of space =
12:08:10 <Cale>   do x <- getLine
12:08:16 <Cale>      putStrLn x
12:09:35 <Cale> edwardk: yi has some support for that, but it's doing it wrong at present, so it's a little fragile. Good enough for small edits like the one you mentioned though.
12:09:59 <Cale> (but if you put a newline, it gets confused and stops the magic)
12:10:39 <straw> Just out of curiousity.. is it possible to put a "do msg <- recv blubb, return foobar" in a anonymous function?
12:11:07 <Cale> straw: yeah
12:11:15 <Cale> straw: do-blocks are an expression form
12:11:32 <Cale> straw: that comma should be a semicolon
12:11:55 <Cale> (that is, if you want to squish it onto one line)
12:12:08 <Cale> straw: It's very common to write things like:
12:12:34 <Cale> forM xs $ \x ->
12:12:40 <Cale>   do somethingWith x
12:12:50 <Cale>      blah blah blah
12:13:24 <edwardk> cale: what i currently do is i allow do foo; bar; baz on one line, but in essence with my layout if you break it across multiple lines (and need indentation control) you need to move it down, since i don't know that the width of space, d, and o are the same.
12:14:11 <straw> Cale: Thank you, I'll try that out!
12:15:19 <Cale> straw: In this case, for some odd syntactic reason, the $, or else parens around the whole block, is required
12:15:40 <straw> Cale: okidoki
12:15:53 <Cale> Er, the whole lambda, rather
12:16:18 <rwx> is there a haskell book like "the little schemer"?
12:16:44 <tromp_> there's learn you a haskell
12:16:56 <rwx> nah
12:17:13 <rwx> i mean in that enlightening didactic style
12:20:49 <rwx> @src :
12:20:49 <lambdabot> Source not found.
12:20:56 <rwx> gah
12:21:00 <rwx> i want to make a cons for numbers
12:21:05 <sm> I don't think so, but graham hutton's programming in haskell or paul hudak's haskell school of expression seem didactic
12:23:25 <rwx> sm, thanks
12:23:55 <EvanCarroll> you know what
12:24:18 <EvanCarroll> i think something major just clicked by looking at the fold[lr] parenthicizing notations
12:24:41 <ezyang> whoo
12:26:32 <BONUS> EvanCarroll: yo
12:26:35 <BONUS> coolio
12:26:54 <BONUS> what
12:27:44 <bos> any #haskell folks want wave invites?
12:28:15 <Apocalisp> Already got 17 to hand out
12:28:22 <BONUS> thanks i got it already :)
12:28:25 <EvanCarroll> I was thinking foldr was (1 + ( 2 + ( 3 + 4 ) ) ), and i thought foldl, was written ( ( ( 1 + 2 ) + 3 ) + 4 ), i think it makes more sense though, to do write them with prefix notations + ( + ( + 1 2 ) 3 ) for lfold, and + 1 ( + 2 ( + 3 ) ) for rfold
12:28:31 <tommd> wave needs flash, right?
12:28:33 <EvanCarroll> BONUS: i'll take one
12:28:37 <EvanCarroll> re:bos
12:28:39 <bos> tommd: no
12:28:40 <EvanCarroll> me@evancarroll.com
12:29:00 <tommd> oh, then I'd be interested in taking a look. If you're low then skip me but if you have them to spare...
12:29:12 <bos> tommd: PM me your addy
12:31:12 <Apocalisp> EvanCarroll: Whatever floats your boat. :)
12:32:18 <EvanCarroll> I like the prefix notation better for folds for two reasons, (a) it demonstrates clearly that foldl recurses immediately by eliminating the obstruction of the argument, and that it breaks the mnemenic that i was making, folds accumulate the parents on the said side.
12:32:23 <BONUS> am i correct in thinking that a MVar () can be used basically as a very simple mutex
12:32:57 <EvanCarroll> I was thinking foldr, is the one with the bunch of parents on the right, foldl, with a bunch of parens on the left, and each time i would think about it I would draw those sum-parenthesized examples
12:32:58 <BONUS> EvanCarroll: yeah you can think of it that way, yes
12:35:03 <EvanCarroll> I suppose you can still think of it that way
12:37:18 <EvanCarroll> does a foldr have a redex if it done a non-infinite list?
12:37:27 <EvanCarroll> My understanding is that it won't work in constant memmory?
12:37:42 <Exteris> bos could i get one?
12:41:25 * hackagebot upload: bibtex 0.0.1 - Parse, format and processing BibTeX files (HenningThielemann)
12:47:14 <hotzen> hey, does anyone know the type level brainfuck interpreter? http://killersmurf.blogspot.com/2009/11/typefuck.html
12:47:15 <hotzen> i cant get it to run
12:47:27 <hotzen> there are kind-errors...
12:48:02 <ezyang> What version GHC?
12:49:00 <hotzen> the newest 6.10.4
12:49:32 <hotzen> show_type :: Brainfuck Add (Cons (Succ (Succ (Succ Zero))) (Cons (Succ (Succ Zero)) Nil)) results in Kind error: `Brainfuck' is applied to too many type arguments
12:54:59 <authorblues> im trying to figure out how to solve the problem of turning a paragraph of text into sentences, but i am having a hard time conceptualizing it functionally. i am trying to avoid thinking about it iteratively, and im whole-heartedly opposed to any regex solution (which is the common solution to this problem in other languages). right now i am breaking on ending punctuation ".!?", but that fails for abbreviations
12:56:17 <danderson> parsec parser that looks ahead after punctuation for space + capitalized letter to determine whether it should break or not?
12:56:41 <danderson> (not a deep haskell expert by any means, wait for someone else to reply, just my 2 cents)
12:56:46 <authorblues> that would fail for names, such as T. S. Eliot
12:57:23 <rwx> you're screwed there
12:57:32 <rwx> you could demand that a sentence have at least 2 characters?
12:57:55 <osfameron> Though:  O!  and I!  might be valid sentences, no?
12:57:55 <tromp_> last char before period shld not be capitalized?
12:58:15 <authorblues> tromp_: fails for Mr. Anderson
12:58:19 <rwx> i think english does not properly separate between syntax and semantics
12:58:30 <osfameron> Do people write "Mr." anymore?
12:58:38 <rwx> yes
12:59:01 <BONUS> basically, of all the languages you could parse, you chose english :)
12:59:04 <authorblues> osfameron: as my corpus is made up of a variety of documents from different eras, i allow myself no luxuries for assumptions
12:59:04 <rwx> authorblues, i suggest making a parser for names, then using that in the manner danderson suggested
12:59:09 <osfameron> fair enough
12:59:12 <rwx> and for abbreviations
12:59:20 <osfameron> ah, the period is still used in US and Canada, but not so much elsewhere
12:59:27 <rwx> that way you can lookahead for names/whatever, if they are not present, end the sentence
12:59:55 <authorblues> osfameron: in modern english, the period is rarely used. but the corpus is made up of everything from plato to shakespeare to modern books (in the public domain)
13:00:08 <doublethink_work> well hi there authorblues :)
13:00:16 <authorblues> actually, to be more direct, my corpus is roughly 400 books from project gutenberg
13:00:44 <osfameron> authorblues: what are you marking it up for?  concordance analysis?
13:01:00 <authorblues> osfameron: document summarization
13:01:37 <authorblues> im using the good old tf-idf algorithm, but i wanna play with some ideas and see if i can improve it any
13:02:07 <osfameron> Can you get it to warn you about 1-2 character sentences, and then you can add those to a list of stopwords manually?
13:03:21 <authorblues> osfameron: i think, after a lot of great brainstorming here with you guys, that im going to err HEAVILY on the side of caution, and assume that if the word prior to the punctuation is not in my small dictionary, that its definitely an abbreviation, and just paste it back together with its successor
13:04:05 <jmcarthur_work> I live in the US and have never even heard of not having a period in Mr. Anderson.
13:04:21 <authorblues> jmcarthur_work: depends on if youre being formal or not
13:04:31 <nvoorhies> One thing that worked well when I was doing that kind of thing in school was trying a pass over the corpus to find names and pulling those out first.
13:05:01 <authorblues> nvoorhies: yeah, my corpus is muddy with names. i wish i had the forethought to take that into consideration
13:05:15 <cads> Nope, we put periods after a abbreviation, unless we're talking on teh netz
13:05:15 <cads> an*
13:05:17 <hotzen> how do i enable flexible-contexts?
13:05:36 <cads> hotzen, what are those?
13:05:47 <hotzen> Non type-variable argument in the constraint: Add Zero Zero ab
13:05:48 <hotzen> (Use -XFlexibleContexts to permit this)
13:05:49 <allbery_b> {-# LANGUAGE FlexibleContexts #-}
13:05:52 <hotzen> {-# LANGUAGE FlexibleContexts #-}
13:05:58 <hotzen> doesnt seem to work
13:06:04 <hotzen> the error persists
13:06:09 <blackh> In New Zealand full stops (as we call them) are completely disappearing after abbreviations like Mr.
13:06:18 <hotzen> im trying: :t undefined :: (Add Zero Zero ab) => ab
13:06:22 <poe> hotzen {-# OPTIONS_GHC .. #-} ?
13:06:27 <osfameron> cads: or unless the abbreviation has become a word (laser etc.) ;-)
13:06:40 <osfameron> good ol' human language
13:06:59 <cads> I forgot the term for phenomenon when acronyms get turned into words
13:07:03 <hotzen> {-# OPTIONS_GHC -XFlexibleContexts #-} doesnt work either
13:07:05 <authorblues> osfameron: the flexibility of written language will the downfall of language parsibility forever
13:07:55 <hotzen> is this type-check not correct? "class Add a b ab | a b -> ab, a ab -> b" im using ":t undefined :: (Add Zero Zero ab) => ab"
13:08:41 <osfameron> what's amazing is that some strategies are Good Enough (TM) to work at all (document searching, summary extraction, keyword extraction and categorization etc.)...
13:08:43 <cads> authorblues, humans parse language too, it's just the grammars are vague and nebulous
13:08:57 <holmak> need those markov things
13:08:59 <cads> and don't even think about the semantics :)
13:08:59 <blackh> hotzen: {-# LANGUAGE FunctionalDependencies #-} ?
13:09:17 <hotzen> blackh: already have that
13:09:24 <hotzen> is my type-check correct?
13:09:28 <poe> hotzen {-# OPTIONS_GHC -fglasgow-exts #-} might work :)
13:09:45 <hotzen> no :(
13:10:14 <poe> :(
13:10:32 <hotzen> how would you type-check http://www.haskell.org/haskellwiki/Peano_numbers ?
13:11:27 <cads> osfameron, using just information about how academic papers cite each other, we can separate papers into different disciplines and do language analysis to see how information flows between them
13:12:18 <osfameron> yeah, that's interesting (though doesn't even really require any parsing of the language, does it?)
13:12:24 <authorblues> cads: id love to get that far eventually. right now i want to do the summary extraction because document "theme" extraction is sort of a buzz-worthy area in academia right now
13:12:36 <osfameron> the research into medieval manuscript "genetics" is also fascinating
13:13:04 <aavogt> people already specify keywords
13:13:35 <authorblues> aavogt: but imagine GETTING keywords from a document for which they havent been specified
13:13:35 <geekagent> why does the ghc have to block when calling an unsafe foreign import?
13:14:07 <aavogt> authorblues: I can by reading the document ;)
13:14:14 <aavogt> but I see what your goal is
13:14:19 <cads> heh, I'd just like to find some library that lets me write a little organizing script that can rename my papers and categorize them a bit!
13:14:52 <cads> must have hundreds of arxiv papers named 2345.9001.pdf and the like
13:16:03 <cads> authorblues, reading the abstract and the summary/bibliography is pretty good/quick summary I find
13:16:15 <Phyx-> side question, what week number are we on?
13:16:23 <cads> also looking at the pictures :)
13:16:29 <poe> cads hang on, there is a program that does that.
13:16:44 <authorblues> cads: im sure you are being cute. you ARE aware that is not the point :D
13:17:23 <cads> I dunno, was thinking maybe you're a scifi author needed inspiration from theo. phys. papers :D
13:18:27 <cads> are you talking about a summary that would allow you to learn the relevant info from the paper without reading author's introduction and blab?
13:19:01 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13119 <-- If I remove the signature on line 5, GHC chokes. Shouldn't the type-checker be able to handle that?
13:19:11 <authorblues> i mean, its not FOR me, to expedite anything. its a thought experiment. im trying to see if i can come up with a better approach than other people have
13:19:19 <poe> cads http://en.wikipedia.org/wiki/Comparison%5Fof%5Freference%5Fmanagement%5Fsoftware
13:19:47 <cads> what!
13:20:03 <cads> there's a comparison page about the software I want
13:20:12 <cads> I love that so much
13:20:17 <cads> thankyou poe!
13:20:31 <jelly12gen> he is anyone familiar with the Network.IRC lib?
13:21:55 <dibblego> how do I install QuickCheck2 from hackage?
13:22:11 <jelly12gen> i think cabal
13:22:23 <Saizan> cabal install "quickcheck >= 2"
13:22:33 <dcoutts> dibblego: cabal install 'quickcheck >= 2'
13:22:36 <dibblego> cabal install QuickCheck installs version 1.2.0.0
13:22:47 <dcoutts> dibblego: because the default version is still 1.x
13:23:00 <dibblego> cabal: There is no package named quickcheck2
13:23:06 <dibblego> oops
13:23:12 <dcoutts> dibblego: it's right, there isn't :-)
13:23:17 <dibblego> sorry
13:23:42 <dibblego> got it, thanks
13:24:16 * dcoutts appreciates the info about default versions could be better
13:27:27 <ben0x539> > case 1 of n | n < 2 -> "toot"
13:27:28 <lambdabot>   "toot"
13:29:23 <jelly12gen> hi
13:29:29 <ben0x539> Hi
13:29:44 <jelly12gen> i am trying to understand an function that returns `Maybe Message`
13:29:57 <jelly12gen> so if i am sure it returns or Just Message or Nothing
13:30:17 <wagle_home> is access to http://portal.acm.org broken for anyone else?
13:30:49 <authorblues> wagle_home: everything a-ok here, boss!
13:31:14 <ezrakilty> wagle_home: try http://downforeveryoneorjustme.com/
13:31:44 <ezrakilty> jelly12gen: such a function can return "Just x" where x is a Message, or it can return Nothing.
13:32:03 <jelly12gen> ezrakilty: yeah but how could i use it in another function?
13:32:09 <medfly> :t maybe
13:32:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:32:37 <ezrakilty> jerlly12gen: a typical way to use it would be to pattern match on the result, having one case for "Just x" and another for Nothing
13:32:46 <wagle_home> heh/sigh..  thanks
13:33:01 <medfly> another is maybe!
13:33:04 <ezrakilty> > case Just 7 of Just x -> x+1 | Nothing -> 0
13:33:05 <lambdabot>   <no location info>: parse error on input `|'
13:33:10 <ezrakilty> > case Just 7 of Just x -> x+1 ; Nothing -> 0
13:33:11 <lambdabot>   8
13:33:24 <jelly12gen> http://hackage.haskell.org/packages/archive/irc/0.4.4.2/doc/html/Network-IRC-Parser.html#v%3Amessage
13:33:25 <medfly> maybe 0 (\x->x+1) Just 5
13:33:26 <medfly> > maybe 0 (\x->x+1) Just 5
13:33:28 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
13:33:28 <lambdabot>         against inferred ...
13:33:36 <medfly> hmm...
13:33:43 <ezrakilty> > maybe 0 (\x->x+1) (Just 5)
13:33:44 <lambdabot>   6
13:33:44 <wagle_home> zOMG!  /me is opening all the urls on the index thats all brand new!  lets shut him down for hours at least!
13:33:45 <medfly> > maybe 0 (\x->x+1) (Just 5)
13:33:46 <lambdabot>   6
13:33:47 <medfly> hehehe
13:34:00 <jelly12gen> hmm..
13:34:23 <ezrakilty> jelly12gen: another way to use a Maybe type is with do notation.
13:34:44 <jelly12gen> ezrakilty: well i already got an function (not made by me) that does
13:34:48 <ezrakilty> > do x <- lookup "foo" [("foo", "bar")] ; return (x ++ " is the result")
13:34:49 <lambdabot>   Just "bar is the result"
13:34:54 <jelly12gen> decode :: String -> Maybe Mesage
13:34:58 <ezrakilty> > do x <- lookup "fox" [("foo", "bar")] ; return (x ++ " is the result")
13:34:58 <lambdabot>   Nothing
13:35:12 <jelly12gen> then i want to print the message with  showMessage :: Message -> String
13:35:28 <medfly> what's Message?
13:35:34 <medfly> oh, oops
13:35:34 <jelly12gen> it's an irc lib
13:35:34 <hotzen> regarding type-families, how do you check the types? is it generally ":t undefined (TypeFamilyClass A B C) => u" ?
13:35:37 <jelly12gen> medfly: http://hackage.haskell.org/packages/archive/irc/0.4.4.2/doc/html/Network-IRC-Parser.html#v%3Amessage
13:35:39 <medfly> nvm, I thought that's THE question
13:35:59 <jelly12gen> i am making my own irc logging bot
13:36:09 <jelly12gen> saw the article "rolling your own irc bot"
13:36:21 <luqui> jelly12gen, and if there is no message, then what do you do?
13:36:25 <jelly12gen> but i need to parse the messages nicely like irssi log's function does
13:36:30 <jelly12gen> luqui: do nothing
13:37:05 <ezrakilty> jelly12gen: try some variation of the "do" notations i was demonstrating
13:37:09 <Saizan> hotzen: can you give a more concrete example?
13:37:44 <hotzen> class AddFunDep a b ab | a b -> ab, a ab -> b
13:37:44 <hotzen> instance AddFunDep Zero b b
13:37:44 <hotzen> instance (AddFunDep a b ab) => AddFunDep (Succ a) b (Succ ab)
13:37:52 <hotzen> i just want to test (AddFunDep Zero Zero)
13:37:54 <jelly12gen> erg: ok let me see
13:38:01 <jelly12gen> ezrakilty: let me see
13:38:17 <hotzen> but i cant get rid of the flexiblecontexts-is-required-error, although i have everything set
13:38:31 <jelly12gen> ezrakilty: i just had some haskell @ uni , and got interested but never understood monads
13:38:33 <Saizan> hotzen: FlexibleContexts is a must
13:38:36 <hotzen> I try ":t undefined :: (AddFunDep Zero Zero) => u
13:38:43 <hotzen> {-# LANGUAGE FlexibleContexts #-}
13:38:43 <hotzen> {-# OPTIONS -fglasgow-exts #-}
13:38:43 <hotzen> {-# OPTIONS -fallow-undecidable-instances #-}
13:38:47 <hotzen> i have everything regarding flex contexts
13:39:34 <ezrakilty> jelly12gen: you don't need to understand monads deeply to use do notation with Maybe types.
13:39:54 <Saizan> hotzen: let foo : AddFunDep a b c => a -> b -> c; foo = undefined; then :t foo (undefined :: Zero) (undefined :: Zero)
13:40:04 <jelly12gen> ezrakilty: ok, but still I want to learn them ;)
13:40:07 <ezrakilty> in the case of Maybe, you can think of do notation as a sequence of instructions, each returning a Maybe type, which sort of "quits" if one of them returns Nothing; then the whole expression returns Nothing
13:40:18 <Saizan> hotzen: s/:/::/
13:40:26 <jelly12gen> ezrakilty: ok
13:40:29 <hotzen> k, thank you
13:40:38 <Saizan> hotzen: you can't partially apply classes :)
13:40:57 <ezrakilty> > do x <- Just 3; y <- Just 7 ; return (x+y)
13:40:57 <lambdabot>   Just 10
13:41:03 <ezrakilty> > do x <- Just 3; y <- Nothing ; return (x+y)
13:41:04 <lambdabot>   Nothing
13:41:09 <ezrakilty> > do x <- Nothing; y <- Just 7 ; return (x+y)
13:41:10 <lambdabot>   Nothing
13:41:18 <ezrakilty> does that help, jelly12gen?
13:42:12 <hotzen> Saizan: thanks!
13:43:00 <ben0x539> > case Left x of ~(Right z@y) -> y
13:43:01 <lambdabot>   * Exception: <interactive>:1:133-164: Irrefutable pattern failed for patter...
13:43:10 <ben0x539> > case Left x of ~(Right z)@y -> y
13:43:11 <lambdabot>   <no location info>: parse error on input `@'
13:43:31 <ben0x539> > case Left x of ~Right z@y -> y
13:43:32 <lambdabot>   <no location info>: Parse error in pattern
13:43:37 <ben0x539> > case Left x of (~Right z)@y -> y
13:43:38 <lambdabot>   <no location info>: Parse error in pattern
13:43:39 <ben0x539> Aaaaaaa
13:43:43 <jelly12gen> ezrakilty: i am trying
13:45:28 <PeakerWork> jelly12gen: Maybe its better to understand Functors, then Applicatives, then Monads
13:45:34 <jelly12gen> ok
13:45:44 <ben0x539> help how do I combine ~ and @ in pattern matching
13:45:45 <PeakerWork> jelly12gen: do you understand Functors?
13:45:47 <jelly12gen> yeah, i must admit i am a bit lazy somethimes
13:45:52 <jelly12gen> PeakerWork: hmmz never heard of that
13:46:22 <PeakerWork> jelly12gen: Functor is a type-class of types that take 1 type parameter, like Monad
13:46:33 <PeakerWork> jelly12gen: Functor has only one method:  fmap :: (a -> b) -> f a -> f b
13:46:42 <jelly12gen> ok
13:46:54 <jelly12gen> PeakerWork: where can i read about this?
13:47:01 <jelly12gen> the haskell book?
13:47:23 <PeakerWork> jelly12gen: probably, or LYAH, I'm not sure.  Probably #haskell can explain too
13:47:24 <scree> > case Left x of y@(~(Right z)) -> y
13:47:26 <lambdabot>   Left x
13:48:09 <scree> ben0x539: ^^^
13:48:26 <ben0x539> Oh, look. I got the @ wrong to begin with. Thank you.
13:48:31 <jelly12gen> PeakerWork: lyah is cool :D
13:48:39 <PeakerWork> jelly12gen: yeah, it is :)
13:48:46 <jelly12gen> http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas nice
13:48:47 <hotzen> anyone an idea how to solve peano-numbers with type-families?
13:49:05 <PeakerWork> BONUS: More kudos to you, more people at my workplace too, send their regards for your great work :)
13:51:17 <scree> hotzen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13123
13:51:38 <Saizan> hotzen: type family Add a b :: *; type instance Add Zero b = b; type instance Add (Succ a) b = Succ (Add a b)
13:51:49 <hotzen> ah thats the trick
13:52:07 <Saizan> which trick?
13:53:08 <hotzen> scree, saizan: thank you very much
13:56:12 <hotzen> i tried it with an associated and haskell didnt allow me to use the class for Succ (SumType a b)
13:56:32 <hotzen> now the output is: *Main> :t add' (undefined::Two) (undefined::Two)
13:56:33 <hotzen> add' (undefined::Two) (undefined::Two) :: Sum' Two Two
13:56:41 <hotzen> is there a way to check what Sum' Two Two is?
13:57:10 <hotzen> add' ::  a -> b -> Sum' a b
13:57:10 <hotzen> add' = undefined
14:00:02 <BONUS> PeakerWork: oh thank you very much! :) tell them i said hi!
14:04:06 <sohum> @pl \p -> p*p <= n
14:04:06 <lambdabot> (<= n) . join (*)
14:04:24 <PeakerWork> BONUS: will do :)
14:04:37 <ezrakilty> :t join
14:04:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:04:54 <sohum> :t all
14:04:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:05:03 <sohum> > all
14:05:04 <lambdabot>   {()->True}->
14:05:04 <lambdabot>    {[]->True;[()]->True;[(),()]->True;[(),(),()]->True}
14:05:04 <lambdabot>  {()->...
14:05:05 <ezrakilty> :t join (*)
14:05:06 <lambdabot> forall a. (Num a) => a -> a
14:05:15 <sohum> ...?
14:05:15 <sohum> oh
14:05:26 <PeakerWork> join :: (r -> r -> a) -> r -> a
14:05:37 <PeakerWork> (in the (r->) monad)
14:05:47 <PeakerWork> Did Haskell 2010 get type sections?
14:05:53 <PeakerWork> and type operators?
14:05:57 <ezrakilty> PeakerWork: ok; that's lucky...!
14:06:08 <PeakerWork> ezrakilty: in what sense is it lucky? :)
14:07:32 <ezrakilty> PeakerWork: it seems surprising to me, but I'll have to think why so
14:08:17 <PeakerWork> ezrakilty: The way each monad instance does useful things in completely different contexts surprised me too at first
14:08:35 <ezrakilty> yeah; probably just my intuitions about the (r->) monad aren't broad enough
14:09:20 <PeakerWork> ezrakilty: The (r->) monad is all about implicitly passing around an argument, and duplicating it if fusing together multiple functions
14:11:25 <ezrakilty> yes, and here the "multiple functions" are one curried function, which is what twisted my intuition I guess.
14:11:28 <jmcarthur_work> ezrakilty, perhaps it would make more sense like this: join ∷ (r → (r → a)) → (r → a)
14:11:42 <jmcarthur_work> shows the m (m a) → m a structure better
14:12:40 <ezrakilty> I do see that; it's just that it clashed with my intuition of (r->) as the "environment" monad. i.e., the one where you've got an environment that you can read from.
14:13:07 <ezrakilty> I guess join (*) is saying "read (a number) from the environment twice, and do this operation to it"
14:15:19 <opqdonut> ezrakilty: or rather "transform this operation that accesses the environment twice into one that only accesses it once (and uses the value twice)"
14:16:13 <jmcarthur_work> :t (<=<)
14:16:14 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:17:16 <PeakerWork> maybe function types should be   (b <- a)  to match the direction it has in the value world? :)
14:18:12 <Polarina> PeakerWork: That doesn't make any sense at all.
14:18:28 <PeakerWork> (<=<) :: (Monad m) => (m c <- a) <- (m c <- b) <- (m b <- a)
14:18:48 <jmcarthur_work> i think that's wrong anyway
14:19:02 <PeakerWork> Polarina: Heh, its silly, I know. I find it annoying that (.), (>>=) and others use different data-flow directions
14:19:25 <monochrom> b<-a is not silly. Richard Bird uses it.
14:21:21 <eugenn> hello everyone :) quick question. I'm reading the monad article in wikipedia. Is Either a monad?
14:22:04 <Botje> "Either e" is
14:22:14 <Botje> Either by itself isn't, because it has the wrong kind
14:22:23 <eugenn> oh
14:25:34 <ezrakilty> eugenn: "wrong kind" in the sense that it takes two arguments and a Monad must take one
14:26:03 <eugenn> All monads take one argument. got it
14:26:11 <PeakerWork> * -> * -> *   instead of  * -> *
14:36:17 <aavogt> I'm failing to convince cabal that my source files are in a directory src/
14:36:20 <aavogt> cabal: can't find source for Main in ., dist/build/autogen
14:36:58 <aavogt> but in my executable section, I did specify hs-source-dirs: src
14:36:59 <Kim^Walkman> What does your .cabal file look like?
14:38:05 <dcoutts> @hpaste!
14:38:05 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:39:58 <aavogt> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5089#a5089
14:40:18 <The_User> Hi! Do you know any cheap book about category theory? (english or german)
14:40:37 <aavogt> I cut down the exposed exposed-modules and build-depends
14:40:39 <koeien37> awodey's text is available  for free on the internet
14:40:59 <ivanm> preflex: seen Cale
14:40:59 <preflex>  Cale was last seen on #haskell 2 hours, 25 minutes and 10 seconds ago, saying: Er, the whole lambda, rather
14:41:00 <koeien37> Cale recommends it. (i haven't read it yet myself)
14:41:16 <aavogt> dcoutts, Kim^Walkman ^^
14:41:49 <ivanm> koeien37: yeah, I can't recall where is copy is, since he says its better than the normal one floating around
14:42:29 <Kim^Walkman> Haven't played around with .cabal files too much, but aren’t the executable section a block rather than a key-value option, aavogt?
14:42:39 <heterarchy> hello
14:42:54 <Kim^Walkman> aavogt: Sec, I'll show you what I mean
14:42:57 <aavogt> I think either variation should work
14:44:05 <Kim^Walkman> aavogt: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5089#a5092 — layouted like that, my own project accepts it :p
14:44:06 <dcoutts> aavogt: you do not have hs-source-dirs in the lib section, but you use exposed-modules: Main
14:44:14 <dcoutts> which I presume is under src/
14:44:25 <dcoutts> aavogt: you've only got hs-source-dirs in the exe section
14:44:37 <dcoutts> each component has essentially independent settings
14:44:40 <aavogt> exactly!
14:45:40 <dcoutts> aavogt: ok, so got it working now then?
14:50:09 <Cale> The_User: Awodey's book is awesome, and I can give you a PDF of it
14:50:33 <aavogt> dcoutts: is there a way to avoid specifying the same build-depends twice?
14:51:03 <Cale> The_User: http://cale.yi.org/share/Category%20Theory%20-%20Awodey.pdf
14:51:29 <Cale> ivanm: My copy is not better than the other one floating around
14:51:43 <Cale> ivanm: Just has slightly different page formatting as far as I can tell.
14:51:53 <PeakerWork> how old is the yi project?
14:51:58 <ivanm> oh, fair enough
14:51:59 <dcoutts> aavogt: you mean since each component uses the same build-depends. Not really.
14:52:03 <Cale> (Probably just a paper size change)
14:52:07 <dcoutts> aavogt: There is a feature in Cabal-1.8, that lets you have exes depend on the lib in the same package.
14:52:47 <aavogt> that's coming out with ghc612?
14:52:56 <ivanm> yup
14:52:56 <dcoutts> aavogt: but if you're directly importing the same packages in modules in the exe then that does not help
14:52:58 <dcoutts> aavogt: right
14:53:22 <aavogt> I suppose I don't really need to export a library...
14:54:19 <The_User> Cale: Thanks
14:59:20 * hackagebot upload: wumpus-core 0.12.0 - Pure Haskell PostScript and SVG generation. (StephenTetley)
15:06:16 <PeakerWork> why can't gtk2hs just use cabal and use custom IO actions in their setup.hs for whatever features are missing?
15:06:28 <PeakerWork> Instead of using custom IO actions for the whole build
15:06:50 <dcoutts> PeakerWork: because Cabal does not yet handle .chs file dependencies
15:07:12 <dcoutts> and there are many other less significant reasons
15:07:41 <PeakerWork> dcoutts: couldn't their setup just manually run c2hs on all of those and then invoke cabal install?
15:07:53 <PeakerWork> (Simple workarounds that make it accessible via cabal-install)
15:07:57 <heterarchy> hi, what's the best way to setup an event that is fired at a regular interval?
15:08:22 <dcoutts> PeakerWork: it'd be a massive pita to hack on if it did that
15:08:32 <dcoutts> it'd re-run c2hs on all 100+ files every time you made a change to one of them
15:08:59 <dcoutts> that might be ok for a deployed package, but people need to be able to develop the thing too
15:09:19 <dcoutts> heterarchy: use forkIO + threadDelay
15:09:30 <PeakerWork> dcoutts: c2hs is not instantenous?
15:09:43 <heterarchy> ok, thanks that's what I thought but I was having trouble implementing it
15:10:03 <dcoutts> PeakerWork: no, it has to pares many megabytes of C header files
15:10:06 <dcoutts> parse
15:10:36 <PeakerWork> C's lack of module system :-(((
15:10:43 <dcoutts> gtk2hs even has a fork of c2hs that pre-parses everything and keeps a binary cache
15:10:53 <dcoutts> but it's still not that fast to process each .chs file
15:11:09 <heterarchy> yay, that worked
15:11:17 <heterarchy> danke schoen
15:11:38 <tensorpudding> C lacks a lot of things
15:11:53 <tensorpudding> most of them good things to lack, others not so much
15:12:55 <PeakerWork> dcoutts: well, a hack that uses mtime comparison specifically for those files -- could still be easy, no?
15:13:27 <dcoutts> PeakerWork: or we could do it properly, but it all takes time
15:13:52 <PeakerWork> dcoutts: until then -- it would be nicer if "cabal install" could install gtk2hs though :)
15:14:05 <PeakerWork> even if its a temp. hack
15:14:09 <dcoutts> PeakerWork: it'd be a lot of work if you did it as a hack
15:14:16 <dcoutts> not much less than doing it properly
15:14:19 <heterarchy> now I want to have my SDL surface in global scope without passing it around
15:14:38 <ivanm> roconnor: lol with your Caleskell 2011 committe ;-)
15:15:25 <PeakerWork> heterarchy: Use a ReaderT
15:15:32 <heterarchy> ok. thanks
15:15:32 <ray> rayskell 2002
15:15:42 <ray> (one of my proposals is to add causality violation)
15:16:11 <PeakerWork> heterarchy: newtype a Monad type for your game that has a ReaderT IO or such, and then give names to the lifters of the various layers, or even a name to an action that yields the "global surface"
15:16:47 <heterarchy> PeakerWork thanks
15:22:14 <joe_____> has anyone tried haskell on embedded systems? is there such an effort ?
15:23:15 <PeakerWork> joe_____: I think there's an attempt to put it on the iPhone
15:23:25 <PeakerWork> > take 3 "joe_____"
15:23:26 <watermind> so what are these empty data declarations used for?
15:23:26 <lambdabot>   "joe"
15:23:40 <PeakerWork> watermind: For the 0 type (that has no values, except bottom)
15:23:44 <PeakerWork> Also called Void
15:23:44 <ezrakilty> > length "joe_____"
15:23:45 <lambdabot>   8
15:23:46 <watermind> I looked at the ticket but didn't find any motivation for them
15:24:02 <Igloo> watermind: They're often used for C datatypes you have a pointer to
15:24:06 <watermind> PeakerWork: so basically so that we can declare our own Void type
15:24:18 <watermind> Igloo: ah I see
15:24:44 <jmcarthur_work> watermind, also for phantom types
15:24:57 <PeakerWork> @type forever
15:24:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:25:07 <ivanm> Igloo: oh, you mean they're not just for people to write code in the type system?
15:25:08 <ivanm> ;-)
15:25:08 <PeakerWork> watermind: Well, types are built from 0, 1, (+), (*), and (^),  Haskell has 1 as (), (+) as Either or |, (*) as (,) or multiple fields in a constructor, and (^) as (->) but lacked 0 (You could define it cleverly, though).   0 is useful for things like the type of forever, if its type was: forever :: m a -> m Void   rather than  m a -> m b -- it would help communicating that it cannot return a value
15:25:55 <aavogt> > forever []
15:25:57 <lambdabot>   []
15:26:06 <PeakerWork> watermind: Also, in the Curry Howard isomorphism, the type Void represents False
15:26:22 <PeakerWork> > forever [1]
15:26:24 <lambdabot>   * Exception: stack overflow
15:26:27 <jmcarthur_work> aavogt, good call
15:26:40 <PeakerWork> forever doesn't return a value here,  its still [Void]
15:27:01 <PeakerWork> By "return" I mean the Monadic "return" method, the value inside the "m" :)
15:27:14 <aavogt> > runWriter $ forever (tell [1])
15:27:18 <lambdabot>   mueval-core: Time limit exceeded
15:27:59 <PeakerWork> even without Void, the fact forever uses a (forall b. b) as its contained value implies it cannot have anything but bottom there
15:28:15 <watermind> PeakerWork: I see very good points
15:28:16 <PeakerWork> (forall a. a) = Void, I think (Anyone correct me?)
15:28:38 <jmcarthur_work> not the same because forall a . a unifies with anything
15:28:48 <jmcarthur_work> isomorphic though, i think
15:29:01 <jmcarthur_work> or some similar concept...
15:29:10 <PeakerWork> jmcarthur_work: (forall a. a) becomes: exists a. a inside a broader context -- and then can't unify with stuff, no?
15:29:38 <jmcarthur_work> :t (undefined ∷ forall a . a) (undefined ∷ Int)
15:29:39 <lambdabot> Not in scope: `???'
15:29:40 <lambdabot> Not in scope: `forall'
15:29:40 <lambdabot> Not in scope: `???'
15:29:50 <jmcarthur_work> i think i'm sick of unicode
15:30:00 <jmcarthur_work> :t (undefined :: forall a . a) (undefined :: Int)
15:30:02 <lambdabot> forall t. t
15:30:09 <PeakerWork> ah, I see
15:30:16 <jmcarthur_work> oh i'm dumb
15:30:32 <jmcarthur_work> :t (undefined :: forall a . a) :: Int
15:30:34 <lambdabot> Int
15:30:40 <jmcarthur_work> that's what i meant
15:30:56 <PeakerWork> well, you unified with Int -> t  before, that's ok too
15:30:57 <aavogt> > execWriter $ forever (tell (First (Just 1)))
15:30:58 <lambdabot>   First {getFirst = Just 1}
15:31:01 <jmcarthur_work> yeah
15:31:13 <jmcarthur_work> regardless, i can't think of any case in which it will fail to unify
15:31:17 <theoros> what is haskell, exactly?
15:31:23 <jmcarthur_work> a programming language
15:31:23 <PeakerWork> aavogt: you're still getting the effect (the "m" part, not the "a" part, in "m a")
15:32:19 <PeakerWork> jmcarthur_work: (forall a. a) acts like Void when you try to make values like it, but not like Void when you use it -- but using it doesn't matter at all, because you can't be provided such a value
15:32:25 <tensorpudding> @haskell
15:32:25 <lambdabot> Unknown command, try @list
15:32:31 <tensorpudding> hmm
15:32:32 <aavogt> PeakerWork: that's true
15:33:06 <jmcarthur_work> PeakerWork, they are the same as far as i know, except that Void complains more loudly at compile time
15:36:14 <ac> I'm not sure if I'll ever understand the purpose of the list monad
15:36:36 <ac> am I the only one who thinks it's a pretty bizarre set of functionality?
15:36:39 <jmcarthur_work> ac, nondeterminism
15:36:57 <ben0x539> i think so too :3
15:37:06 <aavogt> do you use list-comprehensions?
15:37:14 <ac> occasionally
15:37:14 <PeakerWork> ac: basically, each "computation" in the list monad can have multiple results, and chaining these together, all possible combinations are attempted
15:37:19 <jmcarthur_work> same thing
15:37:39 <PeakerWork> > filterM (\x -> [True, False]) [1..3]  -- Both take and don't take each item in [1,2,3]
15:37:40 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
15:37:44 <jmcarthur_work> ac, any experience with scheme? specifically amb?
15:37:46 <PeakerWork> ac: ^^ That's nice use of the list monad
15:38:13 <PeakerWork> > sequence [[1,2],[3,4],[5,6]] -- cartesian product
15:38:14 <Philonous> ac: List monad makes to pretty easy to deal with functions that return multiple (or no) values. For example solving a polynomial
15:38:15 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
15:38:17 <ac> PeakerWork: yeah, good example
15:38:44 <ac> :t sequence
15:38:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:38:51 <PeakerWork> > liftA3 (,,) ["mr", "mrs"] [1,2,3] "jones"
15:38:53 <lambdabot>   [("mr",1,'j'),("mr",1,'o'),("mr",1,'n'),("mr",1,'e'),("mr",1,'s'),("mr",2,'...
15:39:07 <PeakerWork> -- ^ cartesian product with more general types
15:39:08 <jmcarthur_work> think of it as a generalization of the maybe monad. instead of just 0 or 1 possible result, there could be any number of results
15:40:52 <aavogt> negative results!?!!!!
15:41:10 <Philonous> With list monad + lazy evaluation you have a simple constraint solver (with backtracking)
15:41:12 <aavogt> =)
15:41:52 <jmcarthur_work> Philonous, unfortunately not a very good one. a logic monad is nicer for that
15:41:52 <h20xt> Philonous: what does that mean?
15:42:09 <Apocalisp> Another view of the list monad is fodlr. folrdr [] is >>=, just like maybe Nothing is >>=.
15:42:11 <jmcarthur_work> h20xt, like prolog
15:42:18 <Apocalisp> shees, I cannot write foldr
15:42:35 <h20xt> jmcarthur_work: oh so, like the logical language discussed in sicp?
15:42:38 * Apocalisp cleans the keybord
15:42:51 <jmcarthur_work> h20xt, i don't remember much sicp, admittedly
15:43:19 <jmcarthur_work> h20xt, but if you remember amb, it's kind of like that
15:43:21 <Philonous> h20xt: A constraint solver is an algorith that searches for values that satisfy certain properties in a (finite) set set of possible values
15:43:29 <h20xt> jmcarthur_work: ah amb
15:43:37 <h20xt> you set a bunch of requires?
15:43:43 <h20xt> and make queries
15:43:45 <Apocalisp> http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
15:43:50 <jmcarthur_work> :t guard
15:43:52 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:44:03 <jmcarthur_work> h20xt, something like that
15:44:30 <PeakerWork> Apocalisp: you mean concatMap, not foldr
15:44:45 <watermind> I was looking at pattern guards
15:44:45 <jmcarthur_work> h20xt, my comparison to amb is more of [] in general, not really the logical language aspect of it
15:44:55 <watermind> the example in GHC manual to motivate them is pretty bad
15:44:56 <watermind> :S
15:45:04 <h20xt> neat, i will read that paper, thanks
15:45:04 <Apocalisp> concatMap == flip foldr $ [], no?
15:45:10 <watermind> http://www.haskell.org/ghc/docs/6.4/html/users_guide/syntax-extns.html
15:45:18 <jmcarthur_work> :t flip foldr []
15:45:20 <lambdabot> forall a a1. (a -> [a1] -> [a1]) -> [a] -> [a1]
15:45:31 <Apocalisp> :t flip foldr $ []
15:45:32 <PeakerWork> @src concatMap
15:45:32 <lambdabot> forall a a1. (a -> [a1] -> [a1]) -> [a] -> [a1]
15:45:32 <lambdabot> concatMap f = foldr ((++) . f) []
15:45:38 <watermind> we could just do instead, case (lookup env var1, lookup env var1) of
15:45:46 <PeakerWork> Apocalisp: concatMap f = concat . map f
15:45:59 <jmcarthur_work> :t concatMap
15:46:00 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:46:07 <PeakerWork> Apocalisp: sure, both concat and map can be defined in terms of (`foldr` [])
15:46:09 <watermind> and match it with (Just val1, Just val2)
15:46:25 <watermind> there is no need for the nested cases in that example
15:46:28 <PeakerWork> Apocalisp: and as such, so is their composition, but its still not true to say that (>>=) is just a foldr, its a very specific foldr
15:47:26 <watermind> there would be a need for a nested case if var2 = val1
15:47:51 <watermind> would pattern guards deal with that?
15:48:35 <watermind> can you use a variable in the pattern match in a guard as part of the expression for the next one?
15:49:14 <aavogt> no, you have to nest your expressions
15:49:47 <watermind> :S
15:50:06 <aavogt> but perhaps you don't know that you can put multiple guards on any pattern?
15:50:18 <aavogt> well, except for lambdas
15:50:49 <PeakerWork> Haskell has crippled lambdas, just like Python .. :-)
15:50:56 <watermind> aavogt: that's two patterns in that example...
15:50:59 <aavogt> > case () of _ | False -> "hai" | True -> "bye"
15:51:00 <lambdabot>   "bye"
15:51:04 <watermind> aavogt: and an expression for each
15:52:03 <aavogt> hey, at least the keyword isn't crazy long in haskell
15:52:33 <tensorpudding> what's crippled about haskell lambdas?
15:53:08 <sm> oh man.. deeply, deeply crippled
15:53:17 <aavogt> > (\Just x | x == 1 -> "tensorpudding") (Just 2)
15:53:18 <lambdabot>   <no location info>: parse error on input `|'
15:53:36 <aavogt> > (\(Just x) | x == 1 -> "tensorpudding") (Just 2)
15:53:37 <lambdabot>   <no location info>: parse error on input `|'
15:53:55 <aavogt> > (\((Just x) | x == 1) -> "tp") (Just 2)
15:53:56 <lambdabot>   <no location info>: parse error on input `|'
15:54:08 <aavogt> I swear that could work
15:54:16 <tensorpudding> okay, so you can't have lambdas with guards in them?
15:55:10 <jmcarthur_work> or with multiple patterns
15:58:07 <watermind> so can I do
15:58:20 <watermind>  | Just x <- m, odd x
15:58:31 <watermind> in a guard?
16:00:43 <watermind> ah apparently it works
16:01:10 <watermind> hmmm and no multiparameter type classes in 2010??
16:02:00 <watermind> I thought that was one of the "must have"'s when prime was being discussed
16:02:11 <bos> haskell' is a multi-year project.
16:02:20 <bos> MPTCs are not a settled question.
16:04:50 <watermind> bos: oh when I saw 2010 I thought it was just the final name for haskell'
16:05:05 <medfly> isn't 2010 a year
16:05:08 <bos> no.
16:05:12 <medfly> hehehe
16:05:49 <watermind> also shouldn't it be 2009
16:06:08 <watermind> since were not really in 2010 yet...
16:06:48 <mrbluesky> Anyone mind looking at my code real fast and telling me what's wrong?
16:06:48 <mrbluesky> http://pastebin.com/d7325d8e2
16:07:13 <mrbluesky> I'm getting that error with runhaskell
16:07:21 <aavogt> it probably won't be out properly until 2010 though
16:07:52 <watermind> mrbluesky: the compiler thinks the last line is still part of the function definition
16:07:59 <watermind> mrbluesky: you're not supposed to put that there
16:08:23 <watermind> mrbluesky:  either remove "a 2 2" from your file
16:08:24 <mrbluesky> Where should it go then? 0:
16:08:24 <watermind> mrbluesky:  and then you can type that in the compiler
16:08:26 <Polarina> mrbluesky: Wrong use of indentation?
16:08:45 <watermind> mrbluesky:  just type it in the interpreter
16:08:49 <watermind> mrbluesky:  run ghci
16:08:53 <watermind> mrbluesky:  load the file
16:08:56 <Polarina> WRONG USE OF INDENTATION!
16:09:17 <watermind> mrbluesky:  then type a 2 2
16:09:22 <watermind> Polarina: no it's not
16:09:26 <mrbluesky> yeah, I understand that
16:09:28 <mrbluesky> it works fine in ghci
16:09:36 <Polarina> watermind: Yes, the error message explains it.
16:09:40 <mrbluesky> but I want to call it from the script
16:09:56 <watermind> mrbluesky:  if you want to have it in the file you need something like "b = a 2 2"
16:10:21 <watermind> mrbluesky:  but then you still have to type b in the interpreter
16:10:47 <aavogt> main = print (a 2 2) -- probably what you want?
16:10:49 <Polarina> watermind: Wrong use of indentation, won't you realize?
16:10:52 <watermind> mrbluesky: basically if you're using the interpreter you always have to type in the expression you want to evaluate
16:11:04 <mrbluesky> thanks aavogt, that's exactly what I wanted!
16:11:16 <mrbluesky> I think
16:12:09 <aavogt> without a main action, runhaskell is quite useless
16:12:47 <mrbluesky> Yeah, I was trying to put a 2 2 in the main action but kept getting an IO expected error
16:12:58 <mrbluesky> I understand why now.
16:26:11 * hackagebot upload: hpage 0.4.6 - A scrapbook for Haskell developers (FernandoBenavides)
16:33:10 <dv_> hi
16:33:22 <dv_> what is the current sdl binding for haskell? hsdl?
16:34:26 <PeakerWork> dv_: cabal install sdl
16:34:50 <PeakerWork> SDL is so much easier to use than GLUT, but OTOH, SDL is so crappy compared to GL's performance
16:35:09 <dv_> heh
16:36:12 <dv_> cabal: The package requires Cabal library version -any && >=1.6 but no suitable version is installed.      but -> using version 1.6.0.3 of the Cabal library ?
16:40:10 <cads> hey, in a language like coq we can write the type of a monad triple which obeys the axioms of a mathematical monad, and we can try to verify whether a given structure is a monad
16:40:41 <cads> this seems neat, and I was wondering if this is possible in dependent languages like agda
16:41:17 <cads> also to me it's wild that some monads used in haskell are not perfectly consistent with the axioms!
16:41:32 <PeakerWork> cads: which monads break the monad laws?
16:41:40 <dv_> (.data+0x88): undefined reference to `SDLzm0zi5zi9_GraphicsziUIziSDLziGeneral_init_closure' etc.
16:41:43 <PeakerWork> or are these axioms different? (I don't know CT)
16:41:50 <dv_> how do I add sdl to my build?
16:41:53 <PeakerWork> dv_: did you bypass cabal?
16:42:02 <dv_> no this is a custom program now
16:42:09 <dv_> cabal installed sdl
16:42:19 <PeakerWork> dv_: if SDL is installed properly, then ghc --make yourprogram should link to SDL automatically
16:42:32 <dv_> ah missed --make :)
16:42:41 <cads> PeakerWork, there's a blog post claiming the state monad doesn't satisfy the laws
16:42:53 <cads> but i wonder if that's because of some technical limiation
16:43:03 <cads> limitation*
16:43:05 <PeakerWork> cads: Bottoms always ruin everything
16:43:09 <PeakerWork> cads: maybe its something like that
16:43:21 <cads> yeah
16:43:31 <PeakerWork> cads: Ignoring bottoms, State's bind is easily associative, and return has no effect..
16:44:05 <cads> let me see if post clarifies it
16:45:11 <PeakerWork> gotta go
16:51:53 <shachaf> caleskell++
16:52:13 <ivanm> caleskell--
16:52:32 <Axman6> caleskell-- when he decides to change lambdabot!
16:52:35 <monochrom> caleskell++
16:52:42 <lament> @karma caleskell
16:52:43 <lambdabot> caleskell has a karma of 1
16:52:44 <heterarchy> dv_: what kinds of SDL stuff are you working on?
16:52:44 <ivanm> Axman6: exactly!
16:54:36 <IceDane> What would be an optimal way of structuring your main, so that it checks its args, and exits if there are none? Should I just use an if statement?
16:55:11 <Axman6> pattern matching on the result of getArgs
16:56:07 <IceDane> In another function, then? That function would still have to return a Bool which I'd have to act on, no?
16:56:20 <mauke> no, in main
16:56:33 <IceDane> How
16:56:33 <Axman6> pattern match using case
16:56:36 <IceDane> ? O.o
16:56:37 <IceDane> ah...
16:56:38 <IceDane> yeah
16:56:44 <IceDane> never even used  case, but that should work.
16:56:52 <IceDane> Thanks
16:57:59 <ac> say I have a big unsorted list and I want to count how many times each element occurs in the list. What's an elegant solution?
16:58:18 <Axman6> length . filter?
16:58:23 <IceDane> length . filter predicate $ list?
16:58:24 <IceDane> ah
16:58:34 <Axman6> or do you want to count how many times each thing occurs?
16:58:47 <mauke> some kind of fold with M.insert
16:59:05 <aavogt> I dunno how idiomatic it is, but you can do this:   main = do x @ ~(x:y:z:_) <- get; when (null x) $ exitSuccess -- or something else?
16:59:31 <Axman6> @ IceDane i assume?
16:59:32 <ac> @?
16:59:40 <aavogt> yes
16:59:47 <mauke> aavogt: multiple bindings for x?
16:59:48 <ac> :t (@)
16:59:49 <lambdabot> parse error on input `@'
16:59:58 <Axman6> ac: xss@(x:xs) means xss == x:xs
17:00:10 <IceDane> Ah, thanks
17:00:15 <aavogt> mauke: yeah, the second x should be something else
17:00:20 <Axman6> it gives a name to the whole thing, instead of having to resonctruct values
17:00:43 <mauke> :t foldl' (\z x -> M.insertWith (+) x 1 z) M.empty
17:00:44 <lambdabot> forall b a. (Num a, Ord b) => [b] -> M.Map b a
17:00:58 <aavogt> and if you put the ~ in there, the list can be empty, and it won't fail until you try to use y or z
17:01:23 <ac> mauke: that looks like a good general solution
17:01:35 <ac> the Ord constraint is reasonable
17:01:38 <aavogt> this approach gives shorter code, but case is probably easier to read
17:02:03 <aavogt> since people don't seem to use lazy pattern matches much
17:03:21 <aavogt> err, using an explicit case makes the evaluation order explicit
17:09:20 <Axman6> hooray! hayoo.info!
17:15:33 <IceDane> It is not possible to use an if expression directly within main? I know the do in main needs to end with an expression, but I assumed that when if was evaluated, provided all paths end with an expression, it would be valid?
17:16:13 <mauke> your indentation is probably wrong
17:16:45 <IceDane> i'm using emacs with haskell mode, already been through all of it tabbing to try to see if it got any better
17:16:48 <IceDane> I'll try again
17:16:58 <mauke> use your brain instead of emacs
17:17:16 <IceDane> wait, I can do that?
17:20:52 <monochrom> hahaha
17:21:33 <monochrom> put your "then" and "else" more indented than "if". you must do this to get through the layout parser.
17:22:07 <IceDane> monochrom: Yeah, I did that but it's whining about a parse error in pattern, at the start of my if expression
17:22:58 <monochrom> Furthermore, in the scope of "then", you must start a new do-block if you need one. Similar for "else".  The outer "do" (i.e., the do outside the "if") does not carry over.
17:24:11 <IceDane> monochrom: Wouldn't it just evaluate directly to the expression within the "then" or "else" ? I'm basically doing "if null arguments then putStrLn "File input missing" else ... do whatever
17:24:12 <monochrom> This business of needing inner do-blocks holds for case too.
17:24:19 <IceDane> and everything is indented poperly
17:24:43 <monochrom> If you have just one thing without "then", of course you don't need a new do-block.
17:24:50 <MoALTz> > map (chr) [63, 82, 53, 63]
17:24:51 <lambdabot>   "?R5?"
17:24:53 <monochrom> s/without/within/
17:25:06 <paulo_> hello
17:25:28 <IceDane> monochrom: ah, thanks, that was it
17:25:43 <IceDane> the last then(in a nested if) did two actions
17:25:44 <IceDane> Thanks
17:26:04 <paulo_> how do I replace a char in a string, given a char and the index where to replace?
17:26:13 <paulo_> I tried searching this is data.list
17:26:23 <paulo_> and there is no function like that
17:27:09 <monochrom> It is an unusual thing to do.
17:27:41 <MoALTz> hope you are not replacing one char, then repeating this operation with another, then another, and so on
17:27:42 <Saizan> if you need positional update it's better to use a structure designed to support that like Data.Sequence
17:27:54 <monochrom> even array
17:28:41 <Saizan> if you don't care that it's an O(n) operation it's not hard to write using splitAt
17:29:08 <monochrom> Data.Sequence doesn't have a ready-made positional mutation function either. but you can write one and it is acceptably cheap.
17:30:01 <paulo_> splitat?
17:30:10 <paulo_> like, cut the list in two
17:30:20 <Saizan> yeah
17:30:23 <paulo_> remove the tail where the char is
17:30:28 <Peaker> > nth 5 succ "Hello world"
17:30:29 <paulo_> and add the new one?
17:30:30 <lambdabot>   "Hello!world"
17:31:05 <Saizan> paulo_: and join the pieces back together with ++
17:31:14 <paulo_> saizan, that looks like a simple solution =)
17:31:45 <Peaker> @let nth' n f xs = before ++ (f x : after) where (before, x:after) = splitAt xs
17:31:46 <lambdabot>  <local>:17:64:
17:31:46 <lambdabot>      Couldn't match expected type `(t, [t1])'
17:31:46 <lambdabot>             aga...
17:31:56 <Peaker> @let nth' n f xs = before ++ (f x : after) where (before, x:after) = splitAt n xs
17:31:58 <lambdabot>  Defined.
17:32:04 <Peaker> @type (nth, nth')
17:32:05 <lambdabot> forall t a a1. (Num t) => (t -> (a -> a) -> [a] -> [a], Int -> (a1 -> a1) -> [a1] -> [a1])
17:32:52 <Peaker> @check (liftA2 . liftA2) (==) nth nth'
17:32:53 <lambdabot>   Not in scope: `nth'Not in scope: `nth''
17:33:12 <Peaker>  @check doesn't have these definitions in scope? :-P
17:33:35 <Saizan> evidently :)
17:34:48 <Peaker> @check (liftA2 . liftA2) (==) (/) (*)
17:34:50 <lambdabot>   "Falsifiable, after 0 tests:\n1.0\n3.5\n"
17:36:05 <Saizan> actually, i don't see why we've a check command when we could just have quickCheck exposed in @run
17:39:27 <Saizan> (and maybe keep @check as convenience)
17:41:35 <Saizan> ah, because quickCheck is in IO
17:46:06 <IceDane> Is it possible to make the expressions "contents" and "exists" evaluate lazily in a way that I don't get an exception from head for an empty list when I run it with no arguments? I thought it wouldn't evaluate until I did arguments had been evaluated in the if statement, and and then exists not until after that? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13131#a13131
17:46:25 <IceDane> s/I did//
17:53:14 <IceDane> Any takers? :P
17:53:55 <Axman6> i'd use 'if null arguments' personally
17:54:38 <IceDane> Axman6: I did
17:54:41 <IceDane> originally
17:54:45 <IceDane> But that's not the issue
17:54:52 <IceDane> just changed it for debugging before
17:55:06 <Axman6> IceDane: the IO monad is used for programming not just IO, but ordered IO. the readFile comes before the if, and it need to come after/inside it
17:55:40 <IceDane> Axman6: Yeah, that was what the code looked like bfore, but it was such a mess I wanted to avoid it
17:55:56 <IceDane> I thought it'd work due to lazy evaluation
17:56:08 <IceDane> Nothing being evaluated(including head arguments) until it got forced
17:56:28 <IceDane> which would mean that exists would never get evaluated if arguments was empty
17:56:34 <IceDane> Is it possible to set it up like that?
17:56:37 <Axman6> IO doesn;t work like that
17:56:47 <Axman6> lazy evaluation only makes sense for pure values
17:57:20 <Axman6> IceDane: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13131#a13136 the one down the bottom
17:57:59 <IceDane> hmm, yes, that would work
17:58:05 <Axman6> i'll rewrite it more for you, so it's mor idionatic
17:58:07 <Axman6> m*
17:58:16 <IceDane> Heh, you're welcome to do so =)
17:58:18 <IceDane> I might learn something
17:59:48 <rwx> > f . g . h
17:59:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:59:49 <lambdabot>    `GHC.Show.Show a'
17:59:49 <lambdabot>      a...
18:01:35 <Axman6> IceDane: try this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13131#a13135
18:02:47 <IceDane> alright
18:03:28 <IceDane> Axman6: Sweet. Thanks =)
18:03:42 <IceDane> oh
18:03:53 <IceDane> that's smart usage of the case expression
18:04:05 <Axman6> uh, there's more that needs doing (likie you can reference file, instead of using head arguments)
18:04:55 <IceDane> yeah, I just did that
18:04:58 <Axman6> 13:02 < lambdabot>      a...
18:04:59 <IceDane> thanks though
18:05:01 <Axman6> argh
18:05:03 <Axman6> >_><
18:05:11 <Axman6> stupid putty
18:08:51 <Axman6> IceDane: in general, using head should be avoided, because it's not safe (ie., i calls error and kills your program if you give it an empty list)
18:10:09 <Axman6> IceDane: it's a handy function for some things, but in general should be avoided
18:10:54 <IceDane> Axman6: yeah, RWH said so as well
18:11:11 <IceDane> I try to use it only when it has been confirmed that there is at least one element in it.
18:11:17 <IceDane> the list, that is.
18:11:30 <IceDane> And I thought I was doing so because lazy evaluation worked a different way than I thought
18:12:35 <Axman6> i prefer using pattern matching through case, because it means you can be more sure you've covered all possibilities, and you can also use it to give names to things you'll want to use later
18:14:36 <IceDane> yeah
18:17:16 <visualbasicgui> Hi all. My cat asked me how one might write the declaration to make a list of 2-tuples where fst and snd are of the same type into an instance of class X. I said I din't know, and so now I've come here.
18:17:41 <blackdog> "(map (head . group)) . sort" is still cute, though
18:17:54 <visualbasicgui> I tried "instance X [(a, a)] where..." but that doesn't seem to work.
18:18:31 <heterarchy> my cat just sits by the food bowl and whines
18:19:13 <visualbasicgui> well she's there now. But as soon as she finishes eating she'll probably be back and expect me to have an answer :|
18:19:57 <blackdog> @pl let f xs = map head $ List.group $List.sort xs
18:19:58 <lambdabot> (line 1, column 47):
18:19:58 <lambdabot> unexpected end of input
18:19:58 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
18:20:14 <blackdog> @pl f xs = map head $ List.group $List.sort xs
18:20:15 <lambdabot> f = map head . List.group . List.sort
18:20:25 <blackdog> blah, that was simpler than i expected;)
18:20:26 <visualbasicgui> i guess it's not very busy in here
18:20:30 <Axman6> blackdog: ... $ instead of .? :O
18:20:32 <visualbasicgui> :( aaaargh i must figure this out
18:20:57 <Axman6> visualbasicgui: what's the class look like?
18:21:01 <blackdog> Axman6: yeah:) not quite firing yet
18:21:17 <Axman6> i've been up since 5:10 >_<
18:21:23 <visualbasicgui> well does it matter? It's declaration would be "class X where ..."
18:21:28 <visualbasicgui> i mean
18:21:37 <Axman6> visualbasicgui: yes, it does matter :)
18:21:38 <visualbasicgui> "class X a where ..."
18:21:46 <visualbasicgui> aw really
18:22:00 <blackdog> Axman6: masochist
18:22:15 <Axman6> and it also matters what the error is, and what the code is, and any other information that might be helpful for us to help you
18:22:20 <visualbasicgui> but in rwh for example, they have a class "JSON a where"
18:22:23 <visualbasicgui> etc...
18:22:29 <blackdog> Axman6: if i was living in canberra i'd be spending as much time unconscious as i could
18:22:35 <visualbasicgui> and they declare instances for both [a] and [(String, a)]
18:22:38 <Axman6> blackdog: it was for a very good cause, cooking breakfast for white ribbon day with the SES
18:22:50 <blackdog> Axman6: aw, now i feel like a jerk
18:22:53 <visualbasicgui> where a in both those cases is also a JSON
18:22:55 <Axman6> you are a jerk
18:23:00 * blackdog walked into that one
18:23:05 <Axman6> :P
18:23:32 <Axman6> but you're not as much of a jerk as the guys who beat their wives. they're just scum
18:23:47 <blackdog> yeah, i stopped beating my wife ages ago
18:23:57 <blackdog> damn, that came out wrong
18:24:38 <Axman6> i don't know how that could have come out well at all...
18:25:03 <IceDane> reminds me of the trick question "So, have you stopped beating your wife?"
18:25:07 <IceDane> no..
18:25:08 <IceDane> yes..
18:25:25 <heterarchy> :)
18:25:52 <Axman6> anyway, white ribbon day is an international day, so you should all pay attention and not be jerks
18:25:57 <visualbasicgui> So why is it that "instance X [a] where ..." works and "instance X [(a, a)] where" doesn't?
18:26:17 <lpjhjdh> so to say that something is "polymorphic in a functor", does that mean it varies over functors or over a single functor polymorphic over categories?
18:26:19 <Axman6> visualbasicgui: well, they overlap for one
18:26:35 <visualbasicgui> oh i suppose that's true
18:26:35 <cads> thought technically you never stopped beating your wife even if you never beat her
18:26:46 <blackdog> IceDane: well, yeah - was trying to make the reference. obviously i failed miserably...
18:26:46 <visualbasicgui> I have OverlappingInstances
18:26:57 <IceDane> blackdog: I noticed
18:27:13 <visualbasicgui> the error i get is that "all instance types must be of the form (T a1 ... an) etc..."
18:27:26 <blackdog> IceDane: i've been looking at Smullyan's coercive logic, actually. fun stuff
18:27:48 <blackdog> visualbasicgui: i think that error message lists a language extension you need
18:27:54 <IceDane> Haha, that sounds like something one could use to force arguments in your favor
18:27:55 <blackdog> something like TypeSynonymInstances?
18:28:02 <blackdog> IceDane: it is!
18:28:12 <IceDane> I wondered if women are made study this in secret
18:28:47 <Axman6> visualbasicgui: make a type synonym ... however it's spelt: type MyThing a = [(a,a)]
18:28:56 <blackdog> for instance: i will give you 1 million dollars to answer a yes/no question truthfully
18:29:03 <Axman6> then class X (MyThing a) where...
18:29:16 <blackdog> IceDane: would you accept that deal?
18:29:34 <IceDane> blackdog: Let's say I say yes
18:29:58 <Berengal_> visualbasicgui: -XFlexibleInstances work?
18:30:07 <blackdog> IceDane: aw, hypotheticals are no fun:) but ok
18:30:29 <visualbasicgui> I thought i had flexibleinstnaces
18:30:42 <IceDane> blackdog: then what question will you ask me that will put me off?
18:30:45 <IceDane> I assume that's the point
18:30:47 <visualbasicgui> The top of the file has: -- {-# LANGUAGE TypeSynonymInstances, OverlappingInstances, FlexibleInstances #-}
18:30:55 <blackdog> IceDane: the question is this: "Will you either pay me two million dollars or answer no to this question?"
18:31:33 <IceDane> hahaha
18:31:33 <visualbasicgui> I thought (a, a) was it's own type, just a parametric one, just like maybe
18:31:44 <Adamant> just say "pancakes". there's no requirement to answer a yes or no question with a yes or no.
18:31:46 <blackdog> visualbasicgui: put it on a pasteboard
18:31:51 <heterarchy> yes, good idea
18:32:08 <Berengal_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13139#a13139
18:32:16 <blackdog> Adamant: I think the "truthfully" bit constrains you
18:32:17 <IceDane> blackdog: Still, if I say yes, I can still say yes and not pay you, heh :P
18:32:17 <Berengal_> visualbasicgui: ↑ that works
18:32:19 <IceDane> but that's cool
18:32:29 <Adamant> blackdog: what's not truthful about pancakes?
18:32:44 <visualbasicgui> http://pastebin.com/d35e071fe There it is.
18:33:55 <blackdog> IceDane: you larcenous beast!
18:34:29 <IceDane> blackdog: Me in a nutshell
18:34:30 <blackdog> Adamant: it's not really an answer, more than not truthful, i suppose.
18:34:37 <Berengal_> visualbasicgui: http://pastebin.com/m206ac229 fixed
18:34:47 <blackdog> i'll never make high-stakes bets in an IRC channel again
18:34:59 <Adamant> blackdog: it's a perfectly valid answer if you're a surrealist.
18:35:54 <blackdog> Yes, but a surrealist wouldn't make the agreement in the first brightly coloured machine tools.
18:35:57 <Berengal_> blackdog: wu
18:36:27 <visualbasicgui> Berengal: The impact between my face and my palm was loud enough to be heard on the moon.
18:36:28 <Adamant> blackdog: disagreement, funny mustache man made lots of scripted paper
18:37:00 <blackdog> actually, i think there's a form of it that doesn't even require you to be truthful,  so long as you're willing to be bound by the constraints of saying either yes or no.
18:37:11 <IceDane> blackdog: I'm trying to come up with a way to ask that that question that always leaves me free of paying 1 million dollars, heh
18:37:24 <heterarchy> visualbasicgui: same here :)
18:37:25 <Adamant> then you just say "either yes or no"
18:37:25 <IceDane> I'm thinking it should have something to do with "are you/were you going to lie" or something in that direction
18:37:31 <IceDane> but I can't come up with it
18:38:26 <blackdog> Adamant: i should not be having this much trouble in a Haskell channel. Maybe I need to phrase it in types:)
18:38:56 <IceDane> blackdog: I might use that as a party trick, 'tis funny stuff
18:38:59 <Adamant> blackdog: I'm not a very good Haskeller, that must be the problem :P
18:39:15 <blackdog> IceDane: Will you either truthfully answer no to this question, or falsely answer yes, or pay me two million dollars?
18:39:28 <IceDane> hahaha
18:39:29 <IceDane> yeah
18:40:07 <Berengal> Querstion = Either PayMoney (Not Question)
18:40:22 <Berengal> There's types for you
18:41:39 <aavogt> are you aware that your answer is incorrect?
18:42:22 <blackdog> I'm about to pull a slightly filthy trick, but before i do: can anyone think of a reason you might want to cuonstruct a Ruby exception in Haskell, and then pass it back, rather than just throwing it?
18:43:47 <c_wraith> So, is haskell' exciting and amazing?
18:44:45 <ddarius> c_wraith: No
18:45:05 <c_wraith> Is at least actually done?
18:45:50 <Saizan> it's become a rolling release standard
18:46:10 <Saizan> basically they just standardize LANGUAGE extensions
18:46:13 <cads> does anyone else wish ruby had a formal semantics?
18:46:19 <ddarius> Freakin' DoAndIfThenElse
18:46:21 <ddarius> Bastards
18:46:27 <c_wraith> I wish ruby had a specification.
18:46:33 <c_wraith> Let alone formal semantics
18:46:43 <c_wraith> Or did they finally publish one of them?
18:46:45 <cads> I would love on it so much then
18:46:55 <blackdog> c_wraith: i think there was some movement on it
18:47:12 <cads> I hope they do.. whoever "they" would be in ruby's community of fuzzy bearded wisemen
18:47:14 <blackdog> cads: does haskell have a formal operational semantics?
18:47:23 <blackdog> I was under the impression it didn't...
18:47:29 <ddarius> c_wraith: I doubt there will ever be a formal semantics for ruby other than the interpreter.
18:47:55 <ddarius> blackdog: It doesn't anymore.  I don't think it ever had a complete one.
18:48:06 <cads> ddarius, there's the test suite invented by the jRuby and rubinius guys
18:48:15 <cads> that's kind of an operational definition
18:48:22 <ddarius> A test suite is a far cry from a formal semantics.
18:48:31 <cads> for sure
18:49:31 <blackdog> c_wraith: rubysppecoorg
18:49:38 <blackdog> blah. rubyspec.org. sorry.
18:49:43 <blackdog> baaaad lag.
18:50:17 <cads> there are lots of implementations out there
18:50:40 <c_wraith> well.  a specification is a step up from "it's correct if it does the same thing the base implementation does"
18:51:55 <cads> blackdog, do we just assume that a sufficiently tidy formal semantics for haskell exists and leave it at that?
18:52:24 <cads> I thought it would have one
18:52:53 <Saizan> there's nothing more than the haskell report
18:53:32 <cads> the report gives production rules for the language?
18:53:52 <cads> i remember seeing really neat railroad diagrams of the syntax
18:54:14 <cads> ruby's diagrams would be more chaotic
18:54:14 <ivanm> what? a railroad uses Haskell now as well?
18:54:16 <ivanm> ;-)
18:54:52 <sophacles> what's a railroad diagram?
18:55:45 <ivanm> sophacles: a diagram made of the rail tracks!
18:55:52 * ivanm is being deliberately obtuse
18:56:04 <Saizan> you mean there isn't even an official ruby grammar?
18:56:12 <sophacles> :)
18:56:55 <cads> sophaclese, a railroad diagram is a graphical way of representing a ebnf grammar http://stackoverflow.com/questions/796824/tool-for-generating-railroad-diagram-used-on-json-org
18:57:07 <ivanm> Saizan: IIRC, until that Haskeller did one there wasn't a full blown official python grammar
18:57:12 <ivanm> just a default implementation
18:57:22 <ddarius> cads: The semantics for Haskell would not be particularly tidy.
18:57:44 <ivanm> whereas haskell kinda does it the other way round: we have an official spec which most people agree is useless and use the de-facto implementations "extensions" instead
18:57:57 <sophacles> cads: thanks for the link :)
18:58:04 <c_wraith> but haskell' fixes that, right?  >_>  (yeah, I know.  optimism)
18:58:32 <ddarius> c_wraith: The way Haskell standardization is proposed to work now, things would be "fixed" gradually.
18:58:40 <ivanm> c_wraith: _gradually_
18:59:14 <ddarius> If the process maintains, it will be interesting to see what Haskell 2020 will be like.
19:00:15 <cads> ddarius, it's true the semantics of haskell is a scary thing to think about looking at :)
19:04:25 <Saizan> there's a paper giving a partial formalization, probably without IO
19:04:44 <Saizan> and probably outdated now
19:06:37 <rasfar> ivanm: do I need 6.12 to build SourceGraph?
19:07:16 <ivanm> rasfar: no
19:07:22 <ivanm> rasfar: it won't work in 6.12 yet ;-)
19:07:49 <ivanm> (the development version in darcs kinda can, except I think it's currently broken...)
19:08:46 <rasfar> oh heh.  maybe i shouldn't be building it with runhaskell Setup configure --user?  it complains I don't have Cabal ==1.8.*, and it looks like Cabal 1.6 is what comes with ghc 6.10?
19:09:49 <rasfar> cabal install SourceGraph ... is working.  Why didn't I do this before?
19:14:28 <rasfar> I'm seeing a lot of "/bin/sh: dot: not found" when I run:  SourceGraph Parsing.hs
19:16:17 --- mode: irc.freenode.net set +o ChanServ
19:17:59 <ivanm> rasfar: ummm.... where you trying to build the darcs version?
19:18:14 <ivanm> if so, note that there is never any guarantees that my darcs repos contain working code ;-)
19:18:30 <rasfar> I don't think do; I went "cabal install SourceGraph", that's it.
19:18:42 <rasfar> 0.5.5.0 I believe?
19:19:28 <ivanm> rasfar: yes, it doesn't use Cabal 1.8
19:19:32 <ivanm> so I don't know where you got that from
19:20:12 <ivanm> rasfar: but you have to have graphviz installed: www.graphviz.org
19:20:18 <ivanm> that's where the errors are coming from
19:22:22 <ivanm> @ask dcoutts with cabal 1.8, is there any extra syntax required to state that an app uses a library from that package?
19:22:23 <rasfar> Ah, excellent I'll install graphviz then.  You are right, the Cabal 1.8 errors were when trying to build a version I obtained from darcs.
19:22:40 * ivanm might have to include warning messages in all his darcs repos...
19:23:50 <rasfar> \rasfar ponders the wisdom of putting forth these questions just as the chocolate for these strawberries has melted...
19:24:08 <sm> ack! damn you rasfar
19:24:35 <sm> now I am having visions
19:25:03 <rasfar> hey, maybe you live nearby? there's plenty to go around....
19:27:04 <sm> you are very kind :) are you in west los angeles ?
19:27:40 <sm> never mind, go go
19:29:32 <rasfar> sorry sm, it's a longish haul!
19:35:26 <rasfar> ivanm: if you're willing, i do believe graphviz was already installed.  (2999.6.0.0)
19:35:36 <ivanm> rasfar: wrong one ;-)
19:35:42 <ivanm> rasfar: that's my haskellian bindings to Graphviz
19:35:48 <ivanm> which are at graphviz.org
19:36:10 <rasfar> oh.  (well, you use those too!  that's what I get for relying on a grep...)
19:38:02 <Alpounet> @hoogle HTML
19:38:12 <Alpounet> damn
19:38:15 <Alpounet> she's gone.
19:39:27 <ivanm> yeah :(
19:39:30 <Axman6> she has departed
19:39:36 <Axman6> she has left this mortal coil
19:39:36 <ivanm> preflex: seen lament
19:39:36 <preflex>  lament was last seen on #haskell 2 hours, 46 minutes and 58 seconds ago, saying: @karma caleskell
19:39:38 <ivanm> preflex: seen lambdabot
19:39:38 <Axman6> never to return
19:39:38 <preflex>  lambdabot was last seen on #haskell 1 hour, 19 minutes and 25 seconds ago, saying: f = map head . List.group . List.sort
19:39:39 <ivanm> bah
19:39:40 <rasfar> graphviz in jaunty seems to be up to the job.  looking at the generated html now.  neat...
19:39:54 <ivanm> Axman6: :(
19:40:24 <Axman6> for she, has ascended into greatness
19:41:55 <Axman6> http://www.phenomenica.com/2009/11/jumping-peacock-spider.html <-- awesome
19:46:02 <ivanm> Axman6: you getting one as a pet?
19:46:13 <Axman6> i'd probably squish it
19:48:51 <kniu> alright, lemme get something straight
19:48:57 <kniu> >1 : 2 : 3 : 4 : []
19:49:01 <kniu> > 1 : 2 : 3 : 4 : []
19:49:07 <kniu> wha
19:49:17 <Axman6> lambdabot's departed
19:49:19 <path[l]> when I compile wit profiling whats that scc stuff about?
19:49:24 <kniu> damn.
19:49:24 <Axman6> , 1:2:3:4:[]
19:49:26 <lunabot>  [1,2,3,4]
19:49:32 <kniu> , [1, 2, 3, 4]
19:49:33 <lunabot>  [1,2,3,4]
19:49:37 <path[l]> oh , for lunabot eh
19:49:51 <kniu> You're typing the SAME NUMBER OF CHARACTERS.
19:50:04 <kniu> why use [,] in the first place?
19:50:28 <Axman6> because it looks more like a list
19:50:35 <path[l]> otherwise they'd both respond
19:50:38 <Axman6> it's convenient syntax
19:50:40 <path[l]> lunabot and lambdabot
19:50:44 <path[l]> oh heh
19:50:53 <path[l]> you mean for that
19:50:56 <kniu> I don't see the convenience.
19:51:01 <path[l]> yeah its more readable
19:51:09 <path[l]> to see a list like this [1,2,3]
19:51:19 <Axman6> kniu: and no, you're not, since you'd almost always have to use (a:b:c:d:[]), which is longer
19:51:20 <jmcarthur> i think kniu has a point
19:51:27 <Axman6> i don
19:51:28 <Axman6> 't
19:51:33 <jmcarthur> yeah the parens add to it
19:51:36 <kniu> If (,) were cons instead, lists would look thusly:
19:51:40 <kniu> (1, 2, 3, 4, [])
19:51:55 <Axman6> that's ugly
19:51:57 <path[l]> yeah how does it affect precedence. What has higher precedence than :
19:52:04 <Axman6> very lisp like
19:52:11 <jmcarthur> i rather like that 1:2:3:4:[] shows the linked list structure clearly
19:52:15 <Axman6> path[l]: function application
19:52:21 <path[l]> if I do f 1:2:[] is it (f 1) :2:[] or f(1:2:[])
19:52:22 <path[l]> ah
19:52:23 <path[l]> ok
19:52:51 <path[l]> btw Im looking at the profiler documentation. What's this scc construct thing
19:52:53 <kniu> f(1:2:[])
19:53:00 <kniu> vs. f[1, 2]
19:53:06 <kniu> well, I guess that's shorter.
19:53:23 <Axman6> who writes function without a space...
19:53:29 <jmcarthur> C programmers
19:53:40 <jmcarthur> some of them
19:53:40 <path[l]> its not the length though. I think the [1,2,3] reads better.
19:53:50 <Axman6> path[l]: they let you add annotations to the pieces of your code inside functions you'd like to know how often they are called
19:53:58 <Axman6> path[l]: i do too
19:54:05 <Alpounet> any advice about gettign HTML page title in Haskell ?
19:54:10 <Alpounet> any library you have used ?
19:54:17 <jmcarthur> Alpounet: tagsoup?
19:54:21 <path[l]> can you explain a bit more Axman6? What annotation do I need to add?
19:54:30 <jmcarthur> not the most elegant, but elegance isn't the point with scraping
19:54:55 <path[l]> so should I be doing -prof -auto usually?
19:55:12 <Alpounet> jmcarthur, I'll check this out
19:55:13 <Axman6> -prof -auto-all is what i always use
19:55:14 <Alpounet> thanks :-)
19:55:17 <path[l]> ah
19:55:30 <jmcarthur> Alpounet: tagsoup should make it easy, especially for a simple tag like <title>
19:56:29 <Alpounet> I seems so yeah
19:56:48 <path[l]> and normally do you RTS with -p -s?
19:57:05 <Axman6> path[l]: say you've got a somewhat complicated function, which has a lot of lets/wheres, you can say: f x = ... where blah = {-# SCC fPart1 #-} expensiveFunc x; baz = {-# SCC bleh #-} rawr x
19:57:17 <path[l]> ah
19:57:23 <conal> byorgey: ping
19:57:34 <Axman6> lets you get more fine grained profiling results
19:59:05 <path[l]> hmm I did auto-all but I didnt get function times
19:59:16 <path[l]> but the compiler didnt seem to recompile
19:59:32 <Axman6> it won't unless you change something
19:59:40 <path[l]> ugh
19:59:43 <path[l]> thanks
20:00:17 <Axman6> just add a space to a line or something. it's a pain in the arse and i wish it wasn't so
20:00:44 <path[l]> gc time of 59.5% is bad right?
20:00:54 <Axman6> yes
20:01:10 <path[l]> heh now I need to figure out how to get rid of that
20:01:14 <Axman6> means mosr than half the runtime of your code is garbage collection
20:02:36 <Axman6> more*
20:02:49 <path[l]> wait my .prof file still has no function times
20:02:54 <path[l]> even though I recompiled
20:03:03 <Axman6> you're not profiling with the right args i guess
20:03:21 <Axman6> i can't remember what the right ones are. use +RTS --help to find out
20:03:54 <path[l]> oh I used auto instead of auto-all
20:04:01 <path[l]> maybe I misread what they mean
20:05:13 <path[l]> would you mind taking a look at it?
20:05:14 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5094
20:05:21 <path[l]> Im sure Ive missed some simple tricks
20:12:18 <Axman6> path[l]: sorry, i'll check when i can, my wireless is being retarded
20:12:27 <path[l]> oh ok np
20:12:48 <path[l]> my guess I need to make some Prelude.maps strict somehow
20:12:53 <path[l]> but its just a shot in the dark
20:13:12 <Axman6> so, talk me through the code. where are all the allocations happening?
20:15:09 <Axman6> path[l]: hmm, something very odd it happening there
20:15:36 <Axman6> path[l]: you probably want to use forM_ for a lot of your for
20:15:37 <path[l]> sure give me a sec. Let me quickly modify the code with some comments that'll explain what its doing
20:15:40 <Axman6> forM's
20:15:47 <path[l]> huh?
20:15:55 <path[l]> in the input area?
20:16:09 <Axman6> oh, no, sorry
20:17:56 <Axman6> path[l]: well, time to add some cost centers. not sure where to add them though...
20:18:48 <path[l]> hmm
20:19:46 <Axman6> it's very odd that all the allocation is happening in main though
20:20:28 <Axman6> path[l]: you might ocnsider using replicateM btw
20:20:30 <Axman6> :t replicateM
20:20:35 <Axman6> rarg!
20:20:42 <path[l]> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5095 <---- here
20:21:45 <Axman6> i'd love to help- more, but i've got to go and pick up my girlfriend from work.
20:22:45 <SamB_XP_> Axman6: right...
20:23:36 <path[l]> hehe ok thanks
20:23:46 <path[l]> if you've got time later Id still appreicate the help :)
20:23:56 <path[l]> let me see what replicateM does meanwhile
20:24:53 <path[l]> hmmm oh so replicateM instead of forM to improve readability not performance
20:31:21 <Alpounet> guys
20:31:25 <Alpounet> mlbot.hs: /home/alp/.cabal/lib/download-0.3/ghc-6.10.4/HSdownload-0.3.o: unknown symbol `stat64'
20:31:25 <Alpounet> mlbot.hs: mlbot.hs: unable to load package `download-0.3'
20:31:29 <Alpounet> any idea ?
20:36:23 <manju|afk> How do I do ? float(sqrt(m))
20:38:07 <blackh> manjunaths: is m Float ?
20:38:15 <manjunaths> no
20:38:35 <blackh> manjunaths: Then you want.... sqrt (realToFrac m) :: Float
20:38:50 <manjunaths> ah...ok
20:38:54 <blackh> or ... sqrt (realToFrac m :: Float)
20:39:14 <manjunaths> I mean sorry I want to convert to Int not Float
20:39:19 <manjunaths> so
20:39:30 <manjunaths> sqrt(realToFrac m) :: Int
20:39:45 <blackh> You need to say "round (sqrt m)"
20:40:00 <rasfar> Alpounet: look for stat64 on http://tuukka.iki.fi/tmp/haskell-2008-09-26.html and hope that helps.
20:40:05 <manjunaths> ah...ok
20:40:12 <blackh> or floor or ceiling
20:40:52 <blackh> If m is an Int you'd need to say...  round (sqrt $ fromIntegral m)
20:41:12 <blackh> The reason for this is that sqrt only works with floating point types
20:42:04 <MarcWeber> dcoutts_: I've sent an email to haskell-cafe about my latest work which
20:42:16 <MarcWeber> introducing another cabal dependency solver.
20:43:04 <Alpounet> rasfar, thanks
20:43:40 <rasfar> and you're welcome!
20:46:12 <lispy|web> Hello
20:46:32 <blackh> lispy|web: Hello!
20:46:43 <lispy|web> blackh: how's code?
20:47:01 <blackh> lispy|web: I'm stuck, but otherwise very good!
20:47:13 <lispy|web> Stuck?
20:47:25 * lispy|web gets out a lambda shaped pry bar
20:48:13 <sohum> hm.
20:48:17 <sohum> :t pure
20:48:25 <blackh> lispy|web: 3D models - I've nearly got it all figured out - just one last detail.
20:48:33 <lispy|web> blackh: oh
20:48:38 * sohum pokes lavish 
20:48:41 <sohum> wait, no
20:48:42 <lispy|web> blackh: did you try the nehe-tuts?
20:48:45 <sohum> sorry, lavish
20:48:53 <lispy|web> blackh: or is your problem more specific than general opengl?
20:48:55 <sohum> oh, lamdbabot's down
20:49:57 <lispy|web> oh
20:50:06 <lispy|web> I wonder if Cale is have problems with my server
20:50:30 <blackh> lispy|web: I've been through all that and I'm onto the hard stuff now - generating triangle strips, splitting the model for matrix palette rendering...
20:51:25 <lispy|web> blackh: ah, okay.  beyond my current level of opengl-fu then
20:53:26 <blackh> lispy|web: At the moment I'm figuring out how to get animations from one file and appearance from another file.  I've made a lot of things that look like The Thing (out of that movie called The Thing, that is).
20:53:58 <lispy|web> ah, cool
20:54:17 <blackh> This is a lot of fun!
20:58:22 <ivanm> :o my QC tests found a bug in FGL! :o
21:06:42 <cads> wow, antlr studio! http://placidsystems.com/feature-lexwiz.aspx
21:06:45 <cads> hehe
21:06:55 <cads> cuuute!
21:07:31 <orbitz> what does the predicate part of list comprehension translate to in monad form?
21:08:33 <kmc> guard
21:08:35 <kmc> :t guard
21:08:51 <kmc> oh no
21:08:57 <kmc> lambdabot come back
21:09:03 <kmc> , [$ty| guard |]
21:09:04 <Elly> it's on the wrong side of a netsplit
21:09:07 <lunabot>  forall m . MonadPlus m => Bool -> m ()
21:09:26 <kmc> , do { x <- [1..10]; guard (odd x) }
21:09:28 <lunabot>  [(),(),(),(),()]
21:09:33 <kmc> , do { x <- [1..10]; guard (odd x); return x }
21:09:34 <lunabot>  [1,3,5,7,9]
21:09:47 <orbitz> how can i search hoogle for specific monad instance?
21:10:19 <kmc> what do you mean
21:10:59 <orbitz> i want to see the defintion sfo >>= for Monad [a]
21:11:31 <orbitz> also, where can i look up how guard works
21:11:39 <orbitz> i see it's soem MonadPlus/mzero thing
21:11:52 <kmc> @src guard
21:11:58 <kmc> (would work if \bot were here)
21:12:07 <kmc> , src 'guard
21:12:09 <lunabot>  guard :: forall m . MonadPlus m => Bool -> m ()
21:12:41 <kmc> if you know the module and it's standard, source is linked from these: http://www.haskell.org/ghc/docs/latest/html/libraries/
21:12:47 <kmc> that's basically the most important haskell doc link
21:12:51 <kmc> if it's not standard, find it on hackage
21:13:02 <kmc> guard is in Control.Monad
21:13:07 <kmc> guard True = return (); guard False = mzero
21:15:10 <kmc> (>>=) for lists is (flip concatMap)
21:16:42 <kmc> it makes sense in the context of nondeterminism, where a list is of "alternative" values
21:16:57 <kmc> the possibilities for xs >>= f  are any value that's in (f x) for some x in xs
21:20:04 <orbitz> hrm
21:20:15 <orbitz> how can i write the guard in >>= style
21:21:39 <kmc> you can't
21:21:57 <kmc> neither "return ()" nor "mzero" is built out of other monad actions
21:22:14 <kmc> return is a monad "primitive" and mzero is for MonadPlus
21:22:49 <manjunaths> ack!
21:23:00 <manjunaths> haskell is killing me :-)
21:23:05 <kmc> or do you mean, how can you *use* guard with >>= ?
21:23:10 <manjunaths> rather C++ is killing me
21:23:26 <manjunaths> I can't get my head to wrap around the concepts of haskell
21:23:43 <orbitz> kmc: yes sorry
21:23:48 <kmc> , [1..10] >>= \x -> (guard (odd x)) >> (return x)
21:23:49 <lunabot>  [1,3,5,7,9]
21:24:01 <kmc> orbitz, you can learn the general translation between "do" and >>=
21:24:06 <kmc> in fact lambdabot can do it with @do / @undo
21:24:09 <kmc> manjunaths, which one(s)
21:24:27 <orbitz> kmc: ah i had the basics of that but was puttign paren sin teh wrong place
21:24:41 <kmc> some of those parens are unnecessary
21:24:48 <kmc> like around return
21:24:57 <orbitz> yeah i was just grouping the wrong thigns together
21:24:57 <kmc> because binary operators always bind weaker than function application
21:25:07 <manjunaths> kmc, I am trying the 3rd problem in project euler
21:25:10 <kmc> , [1..10] >>= \x -> guard (odd x) >> (return x)
21:25:11 <lunabot>  [1,3,5,7,9]
21:25:33 <manjunaths> kmc, but the first 2 where fun
21:25:47 <kmc> manjunaths, are you stuck somewhere specific on this problem?
21:26:34 <manjunaths> kmc, yeah...I don't know how to loop over a list inside a loop over a list
21:26:44 <kmc> haskell doesn't have loops
21:26:52 <kmc> to the extent it does, they're just ordinary functions
21:26:53 <manjunaths> kmc, :-( I know
21:27:04 <kmc> manjunaths, can you write the list of all prime numbers?
21:27:20 <manjunaths> kmc, no
21:27:26 <manjunaths> that is where I am stuck
21:27:39 <h20xt> kmc how does gaurd work? does it just return () if the predicate is false?
21:27:49 <kmc> guard True = return (); guard False = mzero
21:28:00 <h20xt> ah i see
21:28:08 <h20xt> backwards
21:28:10 <kmc> manjunaths, http://www.haskell.org/haskellwiki/Prime_numbers has solutions, spoiler alert etc.
21:28:16 <manjunaths> kmc, nevermind, I will figure it out, rather I want to figure it out so I can learn haskell
21:28:23 <kmc> do you want a hint?
21:28:30 <manjunaths> kmc, please
21:29:51 <sproingie> wow, git is just totally freaking impenetrable
21:29:57 * kmc <3 git
21:30:13 <sproingie> i do a git init, a git pull, a git commit from where i pulled, and a git push
21:30:33 <sproingie> and i get a 20 line warning that makes zero sense
21:30:41 <manjunaths> Yesterday, I realized, I haven't learnt anything in which I had to think so differently in such a long time, that learning haskell is making the gears in my brain turn and I can hear the rusty creak
21:30:55 <sproingie> and no changes on the remote til i do what the warning says and do a git reset --hard, which i don't know what that does but it sounds brutal
21:31:02 <orbitz> manjunaths: it's awesome isn't it? if a bit frustrating
21:31:04 <sproingie> mercurial simply is not this obtuse
21:31:09 <kmc> manjunaths, write a function "sieve :: [Integer] -> [Integer]".  it takes a list and returns the first element of that list, followed by the elements from the rest of the list which *aren't* divisible by the first one
21:31:10 <manjunaths> orbitz, truly
21:31:21 <kmc> sproingie, git has a steep learning curve but is amazingly powerful and nice
21:31:25 <copumpkin> orbitz: you got immortalized in a @quote earlier!
21:31:27 <manjunaths> kmc, cool..ok
21:31:33 <kmc> manjunaths, it should be one line
21:31:37 <kmc> and you don't have to handle the empty list case
21:31:39 <sproingie> git has a steep learning curve for really basic things
21:31:43 <sproingie> i think it's just a minefield
21:31:43 <kmc> (i didn't say how, since i said "first element")
21:31:45 <orbitz> copumpkin: zomg! for realz?
21:31:51 <manjunaths> kmc, ok :-)
21:31:54 <kmc> manjunaths, one line besides the type signature i mean :)
21:31:55 <copumpkin> pity lambdabot is gone
21:31:56 <orbitz> copumpkin: where can I see
21:31:58 <copumpkin> so the @quote is inaccessible
21:32:01 <manjunaths> heh...ok
21:33:01 <manjunaths> so how many people here use haskell for their day job ?
21:33:01 <kmc> sproingie, "git reset foo" resets the current branch to commit "foo", which could be another branch, a tag, a SHA1 id or prefix, etc. (any of the usual names git accepts for a commit)
21:33:09 <kmc> --hard additionally wipes out your working directory
21:33:14 <kmc> back to the commit you reset to
21:33:16 <kmc> so yes it is brutal
21:33:34 <kmc> git has a bunch of complicated fancy commands, which operate on a very simple data model
21:33:45 <kmc> it's essential to understand the latter before you try to understand any given command
21:33:52 <orbitz> copumpkin: haha i found it!
21:33:58 <kmc> manjunaths, i wish :/
21:34:02 <copumpkin> orbitz: yay
21:34:05 <kmc> i hope that will change one day
21:34:13 <manjunaths> kmc, I write bash scripts :-(
21:34:18 <orbitz> copumpkin: solid quote too
21:34:18 <kmc> that's better than C++
21:34:26 <copumpkin> orbitz: we all know it's true
21:34:44 <manjunaths> kmc, :-) I am not so sure, or I may not be
21:34:45 <orbitz> manjunaths: i mostly write Python at work, however I'm starting to write both as I transition to going steady with Haskell
21:34:58 <kmc> python is a fine language
21:35:02 <kmc> with crappy implementations
21:35:11 <sproingie> kmc: so a push to a remote repo doesn't actually update that repo?
21:35:13 <orbitz> kmc: I just hatez the type system
21:35:29 <manjunaths> orbitz, I don't think I have the opportunity in this job, although I don't know
21:35:49 <kmc> sproingie, it does.   "git push foo bar:baz" sets remote repo "foo"'s branch "baz" to be equal to your branch "bar"
21:35:49 <orbitz> my current job is fairly open thankfully, as long as i get work done how i do it is up to me
21:36:02 <kmc> it also transfers any objects that are reachable from there, and aren't in the remote already
21:36:37 <kmc> sproingie, and depending on circumstances some or all of those args can be omitted.  i'm not an expert on that part
21:36:37 <manjunaths> orbitz, cool
21:36:54 <manjunaths> I tried learning haskell 1998 - 1999
21:36:57 <kmc> usually the remote will be set up to reject unless its old baz is an ancestor of the new one
21:37:03 <kmc> manjunaths, it's changed a lot ;)
21:37:13 <sproingie> no such thing happened til i did git reset after that 20 line warning
21:37:25 <manjunaths> but gave up quickly as I didn't know anything and in the online book it started with monads and I didn't understand a word :-)
21:37:32 <manjunaths> kmc, truly
21:37:33 <kmc> yeah monads are not a good place to start
21:37:38 <kmc> you can do so much without them
21:38:12 <copumpkin> wow, haskell 2010 on slashdot front page!
21:38:15 <copumpkin> how far we have come!
21:38:20 <manjunaths> I wonder if the book still exists
21:38:38 <orbitz> is Haskell 2010 == Haskell'?
21:38:56 <copumpkin> yeah
21:39:02 <kmc> Haskell++1x
21:39:15 <tensorpudding> no
21:39:27 <orbitz> So, most of haskell 2010 seems to exist from wha ti could tell.  Does that mean Haskell 2010 is pretty much done, jus tneed to move some code aroudn?
21:39:39 <sproingie> Haskell' is the HEAD branch of the haskell spec
21:39:44 <copumpkin> orbitz: yeah
21:39:45 <tensorpudding> isn't haskell' the set of all the extensions, and haskell 2010 is just the first installment?
21:40:02 <copumpkin> I assumed haskell' was just the next iteration
21:40:04 <copumpkin> which is 2010
21:40:08 <copumpkin> but there will be more frequent revisions now
21:40:10 <orbitz> i like the idea of just taking de facto standard extensions and making them standard
21:40:13 <orbitz> as a language evolution
21:40:22 <copumpkin> no GADTs :(
21:40:24 <tensorpudding> haskell 2010 is the first stage
21:40:27 <tensorpudding> yeah
21:40:33 <sproingie> yearly.  but seriously, waiting another year for really basic things like fundeps and dropping the MR?
21:40:35 <tensorpudding> no gadts or multi-param typeclasses
21:40:38 <tensorpudding> (yet)
21:41:04 <copumpkin> I don't care so much about dropping MR
21:41:15 <orbitz> MR?
21:41:16 <copumpkin> and fundeps/MPTC vs. type families are still a contentious issue
21:41:19 <copumpkin> monomorphism restriction
21:41:21 <kmc> i mean nobody writes serious haskell code without some ghc extensions
21:41:38 <copumpkin> but GADTs seem pretty basic
21:41:45 <copumpkin> along with flexibleinstances and contexts
21:41:50 <sproingie> MR doesn't bite me, but it seems a legacy thing that could easily be dropped
21:41:53 <kmc> mptc can be useful without fundep or asstypes
21:42:05 <Veinor> What other languages are so relient on compiler/language extensions
21:42:05 <kmc> don't GADTs significantly complicate type inference
21:42:11 <copumpkin> Veinor: not many
21:42:18 <kmc> Veinor, many languages have no standard
21:42:22 <sproingie> GADTs imply existential types, also quite useful
21:42:31 <copumpkin> yeah
21:42:33 <kmc> what about rank-N types
21:42:37 <kmc> rank-2 at least is needed for ST
21:42:42 <sproingie> i think it implies those too
21:42:46 <copumpkin> GADTs don't
21:43:56 <copumpkin> Gracenotes: you gonna throw a party for your anniversary?
21:44:04 <copumpkin>  / our anniversary
21:44:09 <copumpkin> ;)
21:44:15 <Gracenotes> :3
21:44:40 <Gracenotes> yes, I might have the time this break to complete my masterful STG engine. that's implemented in Haskell and ridiculously inefficient for much else.
21:45:05 <copumpkin> :)
21:45:05 <ivanm> copumpkin: IIRC, GADTS aren't still fully worked out yet
21:45:12 <copumpkin> ivanm: how so?
21:45:31 <Gracenotes> copumpkin: and of course we could invite some spambots to Haskell and pay them to celebrate. That's the internet equivalent of strippers, right?
21:45:31 <ivanm> don't recall that bit ;-)
21:45:38 <copumpkin> Gracenotes: yep!
21:45:51 <copumpkin> #gracenotes-and-copumpkins-haskell-anniversary
21:45:52 <lunabot>  luna: A section must be enclosed in parentheses
21:47:02 <kmc> what does lunabot's # do
21:47:10 <copumpkin> beats me
21:48:48 <centrinia> @slap copumpkin
21:49:10 <copumpkin> no lambdabot
21:49:13 * copumpkin sticks his tongue out at centrinia
21:49:15 <orbitz> ahh Happstack seems to use the record trick for lots of config options
21:49:15 <centrinia> Damn. :|
21:49:39 <orbitz> foo{value = update} binds tighter than functiona pplication?
21:49:58 <manjunaths> heh...the slashdot comments are funny and uninformed
21:50:00 <copumpkin> yep
21:50:20 <orbitz> that works quite well
21:50:31 <manjunaths> the detractors comments I mean
21:50:44 <copumpkin> orbitz: you can also use some fun extensions to make things more pleasant
21:51:05 <centrinia> Uh oh, someone might realize what my Slashdot name is.
21:51:13 <copumpkin> orbitz: Foo{..} in a pattern will bring all the labels into scope bound to the values
21:51:19 <copumpkin> if you have RecordWildcards enabled
21:53:11 <orbitz> so if Foo has a member roflcakes i can do Foo{..} and htena cess roflcakes?
21:53:34 <sm> would anyone know the easier trick for constructing format strings, better than printf ("%-"++(show width)++"s") ...
21:54:04 <copumpkin> orbitz: indeed
21:54:33 <orbitz> copumpkin: i'm fascinated by your ideas and wish to subscribe to yoru newsletter
21:54:47 <copumpkin> http://pumpkinpat.ch !
21:54:49 <copumpkin> :P
21:54:57 <copumpkin> oh wait
21:55:01 <copumpkin> there's nothing there
21:55:29 <orbitz> dam youu
21:55:50 <centrinia> copumpkin is Swiss?
21:55:55 <copumpkin> nope
21:55:59 <copumpkin> I just bought a swiss domain
21:56:55 <orbitz> it's spellt Swedish
21:57:00 <copumpkin> :O
21:57:06 <copumpkin> pumpkinpat.se
21:57:07 <kmc> bork bork
21:57:46 <copumpkin> b0rk b0rk
21:57:58 <copumpkin> today's Boston HUG was really empty
21:58:01 <copumpkin> there were maybe 7 of us
21:58:27 <orbitz> copumpkin: you're in bostonia?
21:58:40 <copumpkin> right now I am :) takes me three hours to get here though
21:58:45 <orbitz> hah
21:58:52 <orbitz> from NH?
21:58:54 <copumpkin> yep
21:59:05 <centrinia> What else are you doing in Boston?
21:59:09 <orbitz> do you live in New Lebenon
21:59:10 <copumpkin> sitting in logan right now
21:59:19 <copumpkin> going to baltimore in the morning
21:59:23 <centrinia> Don't tell us that you only went there to get a HUG.
21:59:24 <copumpkin> I live in Lebanon
21:59:26 <centrinia> Oh.
21:59:27 <orbitz> that's funny
21:59:29 <copumpkin> lol
21:59:31 <orbitz> i am no tin boston
21:59:32 <orbitz> but
21:59:34 <orbitz> i'm in baltimore
21:59:35 <orbitz> right now
21:59:39 <orbitz> i'm from boston area
21:59:39 <copumpkin> !
21:59:41 <copumpkin> lol
21:59:47 <orbitz> How long you in baldimore
22:00:11 <copumpkin> couple of days, need to get back to work but my girlfriend is in baltimore and there's no one for me to hang out with in NH
22:00:25 <orbitz> letus grab a drink!
22:00:56 <Apocalisp> There's a pretty active Haskell group in Boston, yeah?
22:01:21 <copumpkin> sure! but I'm not sure what my schedule will be, because I'm doing lots of errands with my girlfriend as she's moving to utah in a couple of days :P
22:01:26 <copumpkin> Apocalisp: usually, but not today
22:01:43 <Apocalisp> well, not every day can be Haskell day, I suppose.
22:01:48 <copumpkin> yeah :/
22:01:48 <SamB_XP_> copumpkin: what is this "today" you speak of ?
22:02:00 <copumpkin> SamB_XP_: well, the 24th
22:02:06 <copumpkin> my days go in awake-cycles
22:02:21 <orbitz> copumpkin: i am busy until probably saturday (depends on if i am going to DC with lady freind friday) if you like scotch i know an excellent quiet place though!
22:02:28 <copumpkin> ooh
22:02:37 <copumpkin> I'm leaving saturday early in the morning :/
22:02:38 <Apocalisp> I'm definitely coming to the Boston HUG
22:02:52 <copumpkin> Apocalisp: yay! next one? there's a mailing list
22:03:04 <copumpkin> orbitz: sure, I barely know the city so I accept suggestions, thanks :)
22:03:12 <orbitz> copumpkin: I ill see about friday then!
22:03:15 <Apocalisp> I'm there in January
22:04:22 <copumpkin> cool :)
22:04:29 <copumpkin> orbitz: you should come to the next one!
22:05:00 <orbitz> the enxt boston hug?
22:05:11 <orbitz> if it is around christmas i can make it, that is when i shall be in boston next
22:05:55 <centrinia> How was the Boston HUG despite the low turnout?
22:06:18 <copumpkin> it's fun! there's edwardk who's always interesting to talk to / listen to :P
22:06:39 <Apocalisp> trying to grok the List monad at the moment. So as I understand it, a list can be seen as a function that, when given a monoid, multiplies a bunch of values together.
22:06:41 <copumpkin> orbitz: there's not a very regular schedule beyond "once a month" but with any luck it'll be around then
22:06:52 <Apocalisp> ..which is join
22:06:54 <copumpkin> Apocalisp: I just think of it as the "nondeterminism monad"
22:07:02 <copumpkin> Set could be too, if Set could be a monad
22:07:15 <Apocalisp> I forget why Set can't.
22:07:22 <copumpkin> Ord constraint on its element
22:07:25 <Apocalisp> Oh yeah, because it's not covariant.
22:07:40 <copumpkin> it should be fine for that
22:08:15 <orbitz> copumpkin: you planning on making it regularly?
22:08:18 <orbitz> is there a baltimore hug?
22:08:19 <copumpkin> orbitz: I
22:08:21 * orbitz hugs
22:08:23 <copumpkin> 'd like to
22:08:29 <Apocalisp> Set a implies a -> a -> b for some ordering b.
22:08:31 <copumpkin> costs me about 60 bucks to come down
22:08:32 <sshc_> Couldn't match expected type `IO ()' against inferred type `FilePath -> b'      In a stmt of a 'do' expression: contents <- getDirectoryContents
22:08:38 <sshc_> what does this error mean?
22:08:51 <copumpkin> but this is my second one and I'll try to get a more regular rhythm
22:09:01 <ddarius> :t getDirectoryContents
22:09:02 <orbitz> sshc_: do you mean to speify a directory name?
22:09:05 <copumpkin> sshc_: you didn't pass an argument to it
22:09:27 <sshc_> aha, right, thanks!
22:11:37 <Apocalisp> copumpkin: Yeah, nondeterminism monad. But why? Because it's the multiplication monad. It's specifically the free monad of products. Right?
22:12:02 <copumpkin> free monad of products? not sure I understand that
22:12:05 <Apocalisp> La = 1 + a x La
22:12:25 <copumpkin> ah
22:12:42 <copumpkin> makes sense :)
22:12:54 <Apocalisp> ((,) a) is left adjunct to Maybe
22:13:13 <ddarius> Apocalisp: What are you talking about?
22:13:20 <Apocalisp> just talking to myself mostly
22:14:08 <ddarius> The right adjoint of ((,) a) is (a ->)
22:14:29 <copumpkin> (a,)
22:16:40 <Apocalisp> Oh. Right.
22:19:41 <osaunders> Can anyone recommend a good book for learning Haskell?
22:19:47 <tensorpudding> @where rwh
22:20:00 <tensorpudding> hmm
22:20:02 <tensorpudding> @bot
22:20:02 <lunabot>  :o
22:20:07 <tensorpudding> no lambdabot
22:20:17 <tensorpudding> osaunders: real world haskell is the current favorite book
22:20:49 <osaunders> Yeah I saw that, something about that title turns me off though.
22:20:58 <copumpkin> well then
22:21:02 <kmc> you can read Learn You A Haskell
22:21:05 <kmc> it has a dumber title
22:21:07 <tensorpudding> you don't like real world?
22:21:10 <copumpkin> why judge a book by its cover when you can judge it by its title
22:21:15 <kmc> but it's a pretty good tutorial
22:21:23 <kmc> anyway just find something, and ask questions here if you get stuck
22:21:24 <tensorpudding> the cover of RWH has a rhinoceros beetle on it
22:21:35 <osaunders> kmc: I quite like Learn You A Haskell, I've been following that but I wondered if a published book would be better.
22:21:38 * copumpkin learned haskell using this channel
22:21:43 <kmc> RWH does cover significantly more
22:21:46 <tensorpudding> but that is par for the course on O'Reilley
22:21:51 * orbitz is learning haskell using copumpkin 
22:21:54 <copumpkin> lol
22:22:09 * copumpkin just encountered nonterminating typechecking
22:22:30 <orbitz> i must do chores and then participate in this unknwon activity known as 'napping'. tata
22:22:36 <osaunders> tensorpudding: I guess I want to really appreciate the language on its design merits.
22:22:50 <osaunders> In a way I'm not sure if I do like real world.
22:22:53 <copumpkin> orbitz: enjoy!
22:22:55 <copumpkin> ooh it's Cale
22:23:05 <orbitz> osaunders: gotta start somewhere, and RWH is a great place ot start
22:23:19 <osaunders> Hm, OK.
22:23:33 <Apocalisp> Ah, ok. The free monad of (b,) is Free b a = Either a (b, Free b a)
22:23:37 <tensorpudding> Cale is a good resource for learning Haskell
22:23:41 <tensorpudding> just hang around here for a while
22:24:07 <copumpkin> yep
22:24:15 <copumpkin> he'll even use his mental reduceron!
22:24:17 <ddarius> Apocalisp: The list monad is isomorphic to a free monad.
22:24:21 <osaunders> Damn, my library has exactly 0 books on Haskell.
22:24:42 <osaunders> I feel like I should complain.
22:24:45 <tensorpudding> free as in beer, or free as in monads
22:25:04 <copumpkin> cofree as in coffee
22:25:18 <tensorpudding> is there such a concept as cofree?
22:25:23 <tensorpudding> @botsnack
22:25:23 <Apocalisp> sure
22:25:23 <lunabot>  :o
22:25:25 <ddarius> tensorpudding: Yes.
22:25:36 <copumpkin> tensorpudding: definitely
22:25:40 <copumpkin> there's the cofree comonad!
22:25:44 <copumpkin> super cool
22:26:00 <lambdabot> :)
22:26:00 <copumpkin> tensorpudding: good overview at http://hackage.haskell.org/packages/archive/category-extras/0.2/doc/html/Control-Comonad-Cofree.html
22:26:02 <osaunders> What's the deal with the joining?
22:26:07 <tensorpudding> i'm trying to remember what the definition of a free object is
22:26:11 <copumpkin> osaunders: opposite of a netsplit
22:26:11 <Zao> osaunders: Massive multi-hour split.
22:26:53 <domino14> what type of problems is haskell specially suited to solve, as opposed to using an imperative language?
22:26:59 <osaunders> Ah
22:27:09 <Zao> domino14: All.
22:27:11 <Apocalisp> let's see if I recall... the cofree comonad of a functor F is given by... Cofree a = (a, F (Cofree a))
22:27:32 <osaunders> domino14: Haskell is a general purpose programming language.
22:27:33 <ddarius> tensorpudding: One rather general definition is an object in the image of the left adjoint to a "forgetful" functor.
22:27:45 <Berengal> I keep reading cofree that as coffee...
22:27:51 <sshc> I'm trying to use getDirectoryContents, but it fails when the dir is a symlink, and doesDirectoryExist returns false
22:27:52 <tensorpudding> i haven't yet gotten to adjunctions in my study of category theory
22:27:53 <domino14> i realize that, but what do people use functional languages for?
22:28:12 <Berengal> domino14: I use it for everything, unless I'm required to use another language by bosses
22:28:13 <osaunders> I want to use it to implement my own language :-P (I'm learning)
22:28:31 <osaunders> Then I'll use it to write web apps.
22:28:40 <Apocalisp> I read bosses as bossness
22:28:46 <domino14> at work it seems like im building gui applications, talking to USB, etc, i can imagine that C++/Qt is better suited for that
22:28:51 <domino14> im loking for some excuse to use Haskell
22:29:19 <BMeph> domino14: Complicated data transformations. :)
22:29:20 <ivanm> who needs an excuse? :p
22:29:25 <sshc> I'm trying to use getDirectoryContents, but it fails when the dir is a symlink, and doesDirectoryExist returns false
22:29:26 <Berengal> IMHO C++ is a pretty good excuse to use Haskell ;)
22:29:36 <ivanm> domino14: IIRC, there's a libusb library for Haskell...
22:29:53 <osaunders> I really don't like C++.
22:30:03 <tensorpudding> you can't use Haskell for everything that you can do in C++
22:30:14 <Berengal> tensorpudding: says who?
22:30:19 <tensorpudding> at the moment
22:30:28 <ddarius> domino14: I've used Haskell to make GUI applications and talk to USB.
22:30:32 <tensorpudding> unless you want to write some libraries
22:30:39 <osaunders> tensorpudding: Do you mean the low level stuff or some of the language features of C++?
22:30:49 <domino14> i have a client-server application written in C++ with Qt, it's multiple clients that connect to a remote server and play a game
22:30:49 <tensorpudding> or hook into the FFI
22:31:02 <domino14> i'm wondering if i can rewrite it in Haskell and what advantages it may have
22:31:10 <tensorpudding> well, there are lots of features in C++ that don't exist in Haskell
22:31:12 <tensorpudding> and vice-versa
22:31:34 <Berengal> domino14: There is Qt for haskell. It's just a low-level binding, but still...
22:31:38 <sshc> how do I get the contents of a directory that's a symlink?
22:31:57 <tensorpudding> i wouldn't necessarily say that C++ has any features which are particularly desirable
22:32:50 <Saizan> sshc: resolve the symlink first?
22:33:07 <sshc> Saizan: ok, how do I resolve symlinks?
22:34:12 <ddarius> sshc: You'll need to use unix specific functions.
22:34:55 <osaunders> This guy explains what bothers me about Real World Haskell (book) http://www.amazon.co.uk/product-reviews/0596514980/ref=cm_cr_dp_hist_2?ie=UTF8&showViewpoints=0&filterBy=addTwoStar
22:36:45 <sshc> ddarius: which unix specfic functions do I need?
22:37:32 <ddarius> sshc: I don't know; I've never needed them.  Look at what is available in the unix package and/or google the mailing list for your issue.
22:38:20 <tensorpudding> to be fair
22:38:28 <tensorpudding> i skipped the stupid bar coding program chapter
22:38:59 <thecheat418> can a noob ask questions in this channel?
22:39:10 <tensorpudding> surely
22:39:12 <c_wraith> as long as it doesn't involve lightswitch raves
22:39:20 <thecheat418> haha
22:39:42 <thecheat418> I have just really been having a hard time understanding monads
22:40:30 <c_wraith> To some extent, you don't have to.  But what's giving you trouble, specifically?
22:40:35 <osaunders> I thought these places existed for noobs.
22:40:54 <aavogt> osaunders: somethimes they exist for making fun of them
22:41:16 <osaunders> Oh. That's bad.
22:41:24 <Apocalisp> #java is pretty hostile to noobs, for example.
22:41:25 <lunabot>  luna: Not in scope: `java'
22:41:25 <thecheat418> well, I made a monad, but have no clue how it is to be used
22:41:38 <tensorpudding> this channel is one of those noob-friendly channels
22:41:52 <c_wraith> thecheat418: which one?
22:42:07 <thecheat418> a state monad
22:42:17 <osaunders> tensorpudding: I'm definitely glad.
22:43:42 <Alpounet> When using the "download" package, in particular the openURIString function, I get : Failed to connect: No address record
22:43:44 <Alpounet> any idea ?
22:44:14 <c_wraith> thecheat418: Ok.  You can kind of think of computations involving a monad as computations where you have a couple extra functions that just work.
22:45:04 <c_wraith> The extra functions for State are get, put, and modify
22:45:12 <domino14> whats wrong with the bar coding chapter/
22:45:20 <domino14> i was just reading the book.. seems ok .. ?
22:45:31 <c_wraith> get fetches a state that's being carried around implicitly.  put sets the state being carried around implicitly.  modify applies a function to the state.
22:45:49 <c_wraith> Understanding the details of how it works isn't especially important, beyond that.
22:46:14 <domino14> hmm, those reviews arent too appealing
22:46:53 <kyagrd> Is there a haskell emacs mode that uses Agda like special characters for certain operators like logical negation, logical and, composition, etc? (just like the lhs2TeX format)?
22:49:45 <Apocalisp> thecheat418: What's your motivation for using monads?
22:50:35 <thecheat418> I am writing an interpreter for a simple language in haskell, we have to introduce mutable objects using a state monad
22:51:56 <c_wraith> I kind of agree with this criticism of RWH:  Chapters introduce important bits of knowledge that are referred to later...  But often you have little interest in the specific topic a chapter covers, skip it, and end up totally lost.
22:52:44 <Alpounet> nobody for the error with the "download" package ?
22:52:58 <c_wraith> As in, there's too much emphasis in each chapter on the project, rather than the topics the chapter is intended to introduce
22:53:27 <Apocalisp> I liked SOE
22:53:51 <aavogt> either way, you can complain: "not real-world" or "deemphasises the concepts"
22:54:18 <aavogt> assuming you have a limited amount of emphasis to put in the book
22:54:29 <c_wraith> Well, perhaps the complaint is really:  the content is too serial
22:54:35 <Apocalisp> aavogt: Maybe the real problem is that it's premised on a theory/practise dichotomy.
22:54:48 <c_wraith> You can't skip a chapter and make much sense out of later ones.
22:55:32 <sm> how do I convert a GenParser Char ParseState a to a GenParser Char () a ? ie discard the state ?
22:57:30 <aavogt> @type return . evalState ?s
22:57:31 <lambdabot> forall a (m :: * -> *) s. (Monad m, ?s::State s a) => s -> m a
22:58:49 <aavogt> sm: parsec lets you grab all input, so you could do that... I'm not sure what that does about the lazy consumption of parser input though
22:59:03 <sm> thanks aavogt
23:00:30 <sm> it seems what I want to do should be easy, but I haven't figured out the types
23:00:53 <sm> the state influences a sub-parser, but isn't used by the higher-level parsers
23:16:53 <fffej> is it possible to define a data type that is a synonym for a fixed size array?  I'm trying to do something like "data Foo = Foo (Array 5 [Bar])" but I'm getting "Only unit numeric type pattern is valid"
23:17:51 <Saizan> Array doesn't take a parameter for the size, only for the type of the index
23:17:52 <opqdonut> not by using Array at least
23:18:09 <Saizan> there are sized vectors in some libraries on hackage
23:18:30 <fffej> thanks, sized vectors sound useful - I'll see if I can dig them up!
23:19:01 <Saizan> alternatively you can use a tuple
23:19:16 <Saizan> or a record type
23:19:38 <Saizan> since it seems your size is fixed
23:19:43 <fffej> the problem is I want to return an index that I can use to reference one of the records - I don't see how to do that with a tuple and a record seems very verbose
23:21:24 <Saizan> only reading or also updating?
23:21:51 <Saizan> which operations should be available for this pointer, i mean
23:22:00 <fffej> both update and reference- I'm trying to model a card game (Solitaire) and I want to represent the piles of cards
23:22:38 <fffej> so at the moment I have 7 stacks (lists) of cards and I want to return something that says Move this card to "here" where here is a specific pile of cards
23:24:01 <Saizan> i see, you can use things like the so-called "functional references", there are packages like fclabels and data-accessor for them
23:24:54 <Saizan> the idea is to bundle the function to access the field and to update it in a datatype that you can then pass around
23:25:28 <Saizan> they also provides TH macros to generate these references/labels from a record definition automatically
23:26:28 <fffej> sounds very heavyweight for what I need - perhaps I should try and simplify the design
23:26:55 <Saizan> maybe the sized vectors would work better here
23:27:24 <fffej> i had a quick look on hackage, but couldn't see anything other than math type vectors - do you have an idea what package I can look at?
23:28:45 <RAndrew> <fffej> sounds like you are writing imperative programm using functional language
23:29:16 <fffej> randrew: almost certainly :) any better suggestions?
23:34:09 * hackagebot upload: starling 0.0.1 - A memcached client (AntoineLatter)
23:34:11 * hackagebot upload: starling 0.0.2 - A memcached client (AntoineLatter)
23:37:36 <Saizan> http://hackage.haskell.org/package/sized-types
23:37:51 <Saizan> quite advanced use of types there though :)
23:38:10 <fffej> saizan: thanks
23:38:12 <Saizan> maybe you could just not enforce this restriction in the types for now
23:38:36 <fffej> saizan: that's what I was thinking - I'll get something that works first, and then get it critiqued by someone who knows what they are doing :)
23:42:52 <RAndrew> what about generating new board after each turn? functional lang will reduce it to update only moved cards on screen. At least i hope it will...
23:43:50 <fffej> RAndrew: I'm generating a new board on each turn, but the problem is I have an abstraction of a "Move" which represents where a card goes to and from.  I'm having trouble representing the to and from
23:45:12 <maurer_> Anyone in here familiar with hMatrix? Some code I wrote using it has the bottleneck being "withMatrix", and is clearly taking too long. I have no idea how to debug this.
23:47:39 <RAndrew> what about data Move = Move pileFrom pileTo cardNumbFrom cardNumbFrom, and regen func will be like regen pileFrom and pileTo, replacing 2 cards: 5-6 strings of code
23:48:10 <RAndrew> data Move = Move pileFrom pileTo cardNumbFrom cardNumbTo, even
23:48:12 <fffej> randrew that's what I thought, but piles are currently of type [Card] and therefore [] will be ambiguous
23:48:23 <fffej> maybe I just need to introduce a new type wrapping [Card]?
23:49:55 <path[l]> hi can someone help me with a performance problem? Ive got code that spends 59.5% time in gc
23:50:46 <path[l]> here's my code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5094#a5095
23:58:01 <Saizan> path[l]: i'd split main into functions, and i'd also do an heap profile rather than a time one
23:58:18 <path[l]> ah I see. hmm
23:58:46 <path[l]> let me look at how to do a heap profile and reduce main. But a large part of main is just IO. The real work is in solve
